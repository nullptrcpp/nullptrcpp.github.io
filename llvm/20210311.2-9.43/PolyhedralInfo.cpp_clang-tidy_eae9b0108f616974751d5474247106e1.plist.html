<!DOCTYPE html>
<html>
  <head>
    <title>Plist HTML Viewer</title>

    <meta charset="UTF-8">

    <style type="text/css">
      .CodeMirror{font-family:monospace;height:300px;color:#000;direction:ltr}.CodeMirror-lines{padding:4px 0}.CodeMirror pre{padding:0 4px}.CodeMirror-gutter-filler,.CodeMirror-scrollbar-filler{background-color:#fff}.CodeMirror-gutters{border-right:1px solid #ddd;background-color:#f7f7f7;white-space:nowrap}.CodeMirror-linenumber{padding:0 3px 0 5px;min-width:20px;text-align:right;color:#999;white-space:nowrap}.CodeMirror-guttermarker{color:#000}.CodeMirror-guttermarker-subtle{color:#999}.CodeMirror-cursor{border-left:1px solid #000;border-right:none;width:0}.CodeMirror div.CodeMirror-secondarycursor{border-left:1px solid silver}.cm-fat-cursor .CodeMirror-cursor{width:auto;border:0!important;background:#7e7}.cm-fat-cursor div.CodeMirror-cursors{z-index:1}.cm-animate-fat-cursor{width:auto;border:0;-webkit-animation:blink 1.06s steps(1) infinite;-moz-animation:blink 1.06s steps(1) infinite;animation:blink 1.06s steps(1) infinite;background-color:#7e7}@-moz-keyframes blink{50%{background-color:transparent}}@-webkit-keyframes blink{50%{background-color:transparent}}@keyframes blink{50%{background-color:transparent}}.cm-tab{display:inline-block;text-decoration:inherit}.CodeMirror-rulers{position:absolute;left:0;right:0;top:-50px;bottom:-20px;overflow:hidden}.CodeMirror-ruler{border-left:1px solid #ccc;top:0;bottom:0;position:absolute}.cm-s-default .cm-header{color:#00f}.cm-s-default .cm-quote{color:#090}.cm-negative{color:#d44}.cm-positive{color:#292}.cm-header,.cm-strong{font-weight:700}.cm-em{font-style:italic}.cm-link{text-decoration:underline}.cm-strikethrough{text-decoration:line-through}.cm-s-default .cm-keyword{color:#708}.cm-s-default .cm-atom{color:#219}.cm-s-default .cm-number{color:#164}.cm-s-default .cm-def{color:#00f}.cm-s-default .cm-variable-2{color:#05a}.cm-s-default .cm-type,.cm-s-default .cm-variable-3{color:#085}.cm-s-default .cm-comment{color:#a50}.cm-s-default .cm-string{color:#a11}.cm-s-default .cm-string-2{color:#f50}.cm-s-default .cm-meta{color:#555}.cm-s-default .cm-qualifier{color:#555}.cm-s-default .cm-builtin{color:#30a}.cm-s-default .cm-bracket{color:#997}.cm-s-default .cm-tag{color:#170}.cm-s-default .cm-attribute{color:#00c}.cm-s-default .cm-hr{color:#999}.cm-s-default .cm-link{color:#00c}.cm-s-default .cm-error{color:red}.cm-invalidchar{color:red}.CodeMirror-composing{border-bottom:2px solid}div.CodeMirror span.CodeMirror-matchingbracket{color:#0f0}div.CodeMirror span.CodeMirror-nonmatchingbracket{color:#f22}.CodeMirror-matchingtag{background:rgba(255,150,0,.3)}.CodeMirror-activeline-background{background:#e8f2ff}.CodeMirror{position:relative;overflow:hidden;background:#fff}.CodeMirror-scroll{overflow:scroll!important;margin-bottom:-30px;margin-right:-30px;padding-bottom:30px;height:100%;outline:0;position:relative}.CodeMirror-sizer{position:relative;border-right:30px solid transparent}.CodeMirror-gutter-filler,.CodeMirror-hscrollbar,.CodeMirror-scrollbar-filler,.CodeMirror-vscrollbar{position:absolute;z-index:6;display:none}.CodeMirror-vscrollbar{right:0;top:0;overflow-x:hidden;overflow-y:scroll}.CodeMirror-hscrollbar{bottom:0;left:0;overflow-y:hidden;overflow-x:scroll}.CodeMirror-scrollbar-filler{right:0;bottom:0}.CodeMirror-gutter-filler{left:0;bottom:0}.CodeMirror-gutters{position:absolute;left:0;top:0;min-height:100%;z-index:3}.CodeMirror-gutter{white-space:normal;height:100%;display:inline-block;vertical-align:top;margin-bottom:-30px}.CodeMirror-gutter-wrapper{position:absolute;z-index:4;background:0 0!important;border:none!important}.CodeMirror-gutter-background{position:absolute;top:0;bottom:0;z-index:4}.CodeMirror-gutter-elt{position:absolute;cursor:default;z-index:4}.CodeMirror-gutter-wrapper ::selection{background-color:transparent}.CodeMirror-gutter-wrapper ::-moz-selection{background-color:transparent}.CodeMirror-lines{cursor:text;min-height:1px}.CodeMirror pre{-moz-border-radius:0;-webkit-border-radius:0;border-radius:0;border-width:0;background:0 0;font-family:inherit;font-size:inherit;margin:0;white-space:pre;word-wrap:normal;line-height:inherit;color:inherit;z-index:2;position:relative;overflow:visible;-webkit-tap-highlight-color:transparent;-webkit-font-variant-ligatures:contextual;font-variant-ligatures:contextual}.CodeMirror-wrap pre{word-wrap:break-word;white-space:pre-wrap;word-break:normal}.CodeMirror-linebackground{position:absolute;left:0;right:0;top:0;bottom:0;z-index:0}.CodeMirror-linewidget{position:relative;z-index:2;overflow:auto}.CodeMirror-rtl pre{direction:rtl}.CodeMirror-code{outline:0}.CodeMirror-gutter,.CodeMirror-gutters,.CodeMirror-linenumber,.CodeMirror-scroll,.CodeMirror-sizer{-moz-box-sizing:content-box;box-sizing:content-box}.CodeMirror-measure{position:absolute;width:100%;height:0;overflow:hidden;visibility:hidden}.CodeMirror-cursor{position:absolute;pointer-events:none}.CodeMirror-measure pre{position:static}div.CodeMirror-cursors{visibility:hidden;position:relative;z-index:3}div.CodeMirror-dragcursors{visibility:visible}.CodeMirror-focused div.CodeMirror-cursors{visibility:visible}.CodeMirror-selected{background:#d9d9d9}.CodeMirror-focused .CodeMirror-selected{background:#d7d4f0}.CodeMirror-crosshair{cursor:crosshair}.CodeMirror-line::selection,.CodeMirror-line>span::selection,.CodeMirror-line>span>span::selection{background:#d7d4f0}.CodeMirror-line::-moz-selection,.CodeMirror-line>span::-moz-selection,.CodeMirror-line>span>span::-moz-selection{background:#d7d4f0}.cm-searching{background-color:#ffa;background-color:rgba(255,255,0,.4)}.cm-force-border{padding-right:.1px}@media print{.CodeMirror div.CodeMirror-cursors{visibility:hidden}}.cm-tab-wrap-hack:after{content:''}span.CodeMirror-selectedtext{background:0 0}
/*# sourceMappingURL=codemirror.min.css.map */

      .severity-low {
  background-color: #669603;
}

.severity-low:after {
  content : 'L';
}

.severity-unspecified {
  background-color: #666666;
}

.severity-unspecified:after {
  content : 'U';
}

.severity-style {
  background-color: #9932cc;
}

.severity-style:after {
  content : 'S';
}

.severity-medium {
  background-color: #a9d323;
  color: black;
}

.severity-medium:after {
  content : 'M';
}

.severity-high {
  background-color: #ffa800;
}

.severity-high:after {
  content : 'H';
}

.severity-critical {
  background-color: #e92625;
}

.severity-critical:after {
  content : 'C';
}

i[class*="severity-"] {
  line-height: normal;
  text-transform: capitalize;
  font-size: 0.8em;
  font-weight: bold;
  color: white;
  display: inline-block;
  width: 16px;
  height: 16px;
  text-align: center;
  font-family: sans-serif;
}

      html, body {
  width: 100%;
  height: 100%;
  padding: 0px;
  margin: 0px;
}

div.container {
  padding: 10px;
}

#content {
  height: 100%;
  display: block;
  overflow: hidden;
}

#content > div {
  margin: 10px;
  overflow: hidden;
  border: 1px solid #ddd;
  border-radius: 3px;
  overflow: hidden;
  height: 97%;
}

.button {
  background-color: #f1f1f1;
  text-decoration: none;
  display: inline-block;
  padding: 8px 16px;
  color: black;
  cursor: pointer;
}

.button:hover {
  background-color: #ddd;
  color: black;
}

.review-status {
  color: white;
  text-align: center;
}

.review-status-confirmed {
  background-color: #e92625;
}

.review-status-false-positive {
  background-color: grey;
}

.review-status-intentional {
  background-color: #669603;
}

      div.container {
  width: 100%;
  height: 100%;
  padding: 0px;
}

#editor-wrapper {
  margin: 10px;
}

#side-bar {
  float: left;
  width: 260px;
  margin: 0px;
}

#report-nav ul {
  list-style-type: none;
  padding: 0;
  margin: 0;
  overflow-y: auto;
  height: 100%;
}

#report-nav ul > li {
  padding: .4em;
  background-color: #fff;
  border-bottom: 1px solid rgba(0,0,0,.125);
  text-align: left;
  overflow: hidden;
  white-space: nowrap;
  text-overflow: ellipsis;
}

#report-nav ul > li.active {
  background-color: #427ea9;
  color: white;
}

#report-nav ul > li:hover {
  background-color: #427ea9;
  color: white;
  cursor: pointer;
}

#report-nav ul a {
  text-decoration: none;
}

#report-nav i[class*="severity-"] {
  margin-right: 5px;
}

.header {
  border-bottom: 1px solid lightgrey;
  font-family: monospace;
  padding: 10px;
  background-color: #fafbfc;
  border-bottom: 1px solid #e1e4e8;
  border-top-left-radius: 2px;
  border-top-right-radius: 2px;
}

#report-nav .header {
  font-weight: bold;
}

#editor-wrapper .header > div {
  padding-top: 2px;
}

#file-path,
#checker-name {
  color: #195ea2;
}

#review-status {
  padding: 0px 5px;
}

#file-path {
  font-family: monospace;
}

.check-msg {
  display: inline-block;
  padding: 3px 6px;
  margin: 1px;
  -webkit-border-radius: 5px;
  -moz-border-radius: 5px;
  border-radius: 5px;
}

.check-msg.info {
  color: #00546f;
  background-color: #bfdfe9;
  border: 1px solid #87a8b3;
}

.check-msg.error {
  background-color: #f2dede;
  color: #a94442;
  border: 1px solid #ebcccc;
}

.check-msg.macro {
  background-color: #d7dac2;
  color: #4f5c6d;
  border: 1px solid #d7dac2;
}

.check-msg.note {
  background-color: #d7d7d7;
  color: #4f5c6d;
  border: 1px solid #bfbfbf;
}

.check-msg.current {
  border: 2px dashed #3692ff;
}

.check-msg .tag {
  padding: 1px 5px;
  text-align: center;
  border-radius: 2px;
  margin-right: 5px;
  text-decoration: inherit;
}

.check-msg .tag.macro {
  background-color: #83876a;
  color: white;
  text-transform: capitalize;
}

.check-msg .tag.note {
  background-color: #9299a1;
  color: white;
  text-transform: capitalize;
}

.checker-enum {
  color: white;
  padding: 1px 5px;
  text-align: center;
  border-radius: 25px;
  margin-right: 5px;
  text-decoration: inherit;
}

.checker-enum.info {
  background-color: #427ea9;
}

.checker-enum.error {
  background-color: #a94442;
}

.arrow {
  border: solid black;
  border-width: 0 3px 3px 0;
  display: inline-block;
  padding: 3px;
  cursor: pointer;
  margin: 0px 5px;
}

.arrow:hover {
  border: solid #437ea8;
  border-width: 0 3px 3px 0;
}

.left-arrow {
  transform: rotate(135deg);
  -webkit-transform: rotate(135deg);
}

.right-arrow {
  transform: rotate(-45deg);
  -webkit-transform: rotate(-45deg);
}

    </style>

    <script type="text/javascript">
      function setNonCompatibleBrowserMessage() {
  document.body.innerHTML =
    '<h2 style="margin-left: 20px;">Your browser is not compatible with CodeChecker Viewer!</h2> \
     <p style="margin-left: 20px;">The version required for the following browsers are:</p> \
     <ul style="margin-left: 20px;"> \
     <li>Internet Explorer: version 9 or newer</li> \
     <li>Firefox: version 22.0 or newer</li> \
     </ul>';
}

// http://stackoverflow.com/questions/5916900/how-can-you-detect-the-version-of-a-browser
var browserVersion = (function(){
  var ua = navigator.userAgent, tem,
    M = ua.match(/(opera|chrome|safari|firefox|msie|trident(?=\/))\/?\s*(\d+)/i) || [];

  if (/trident/i.test(M[1])) {
    tem = /\brv[ :]+(\d+)/g.exec(ua) || [];
    return 'IE ' + (tem[1] || '');
  }

  if (M[1] === 'Chrome') {
    tem = ua.match(/\b(OPR|Edge)\/(\d+)/);
    if (tem != null) return tem.slice(1).join(' ').replace('OPR', 'Opera');
  }

  M = M[2] ? [M[1], M[2]] : [navigator.appName, navigator.appVersion, '-?'];
  if ((tem = ua.match(/version\/(\d+)/i)) != null) M.splice(1, 1, tem[1]);
    return M.join(' ');
})();

var pos = browserVersion.indexOf(' ');
var browser = browserVersion.substr(0, pos);
var version = parseInt(browserVersion.substr(pos + 1));

var browserCompatible
  = browser === 'Firefox'
  ? version >= 22
  : browser === 'IE'
  ? version >= 9
  : true;


      /* MIT License

Copyright (C) 2017 by Marijn Haverbeke <marijnh@gmail.com> and others

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
 */
      !function(e,t){"object"==typeof exports&&"undefined"!=typeof module?module.exports=t():"function"==typeof define&&define.amd?define(t):e.CodeMirror=t()}(this,function(){"use strict";function e(e){return new RegExp("(^|\\s)"+e+"(?:$|\\s)\\s*")}function t(e){for(var t=e.childNodes.length;t>0;--t)e.removeChild(e.firstChild);return e}function r(e,r){return t(e).appendChild(r)}function n(e,t,r,n){var i=document.createElement(e);if(r&&(i.className=r),n&&(i.style.cssText=n),"string"==typeof t)i.appendChild(document.createTextNode(t));else if(t)for(var o=0;o<t.length;++o)i.appendChild(t[o]);return i}function i(e,t,r,i){var o=n(e,t,r,i);return o.setAttribute("role","presentation"),o}function o(e,t){if(3==t.nodeType&&(t=t.parentNode),e.contains)return e.contains(t);do{if(11==t.nodeType&&(t=t.host),t==e)return!0}while(t=t.parentNode)}function l(){var e;try{e=document.activeElement}catch(t){e=document.body||null}for(;e&&e.shadowRoot&&e.shadowRoot.activeElement;)e=e.shadowRoot.activeElement;return e}function s(t,r){var n=t.className;e(r).test(n)||(t.className+=(n?" ":"")+r)}function a(t,r){for(var n=t.split(" "),i=0;i<n.length;i++)n[i]&&!e(n[i]).test(r)&&(r+=" "+n[i]);return r}function u(e){var t=Array.prototype.slice.call(arguments,1);return function(){return e.apply(null,t)}}function c(e,t,r){t||(t={});for(var n in e)!e.hasOwnProperty(n)||!1===r&&t.hasOwnProperty(n)||(t[n]=e[n]);return t}function f(e,t,r,n,i){null==t&&-1==(t=e.search(/[^\s\u00a0]/))&&(t=e.length);for(var o=n||0,l=i||0;;){var s=e.indexOf("\t",o);if(s<0||s>=t)return l+(t-o);l+=s-o,l+=r-l%r,o=s+1}}function h(e,t){for(var r=0;r<e.length;++r)if(e[r]==t)return r;return-1}function d(e,t,r){for(var n=0,i=0;;){var o=e.indexOf("\t",n);-1==o&&(o=e.length);var l=o-n;if(o==e.length||i+l>=t)return n+Math.min(l,t-i);if(i+=o-n,i+=r-i%r,n=o+1,i>=t)return n}}function p(e){for(;Kl.length<=e;)Kl.push(g(Kl)+" ");return Kl[e]}function g(e){return e[e.length-1]}function v(e,t){for(var r=[],n=0;n<e.length;n++)r[n]=t(e[n],n);return r}function m(e,t,r){for(var n=0,i=r(t);n<e.length&&r(e[n])<=i;)n++;e.splice(n,0,t)}function y(){}function b(e,t){var r;return Object.create?r=Object.create(e):(y.prototype=e,r=new y),t&&c(t,r),r}function w(e){return/\w/.test(e)||e>""&&(e.toUpperCase()!=e.toLowerCase()||jl.test(e))}function x(e,t){return t?!!(t.source.indexOf("\\w")>-1&&w(e))||t.test(e):w(e)}function C(e){for(var t in e)if(e.hasOwnProperty(t)&&e[t])return!1;return!0}function S(e){return e.charCodeAt(0)>=768&&Xl.test(e)}function L(e,t,r){for(;(r<0?t>0:t<e.length)&&S(e.charAt(t));)t+=r;return t}function k(e,t,r){for(var n=t>r?-1:1;;){if(t==r)return t;var i=(t+r)/2,o=n<0?Math.ceil(i):Math.floor(i);if(o==t)return e(o)?t:r;e(o)?r=o:t=o+n}}function T(e,t,r){var o=this;this.input=r,o.scrollbarFiller=n("div",null,"CodeMirror-scrollbar-filler"),o.scrollbarFiller.setAttribute("cm-not-content","true"),o.gutterFiller=n("div",null,"CodeMirror-gutter-filler"),o.gutterFiller.setAttribute("cm-not-content","true"),o.lineDiv=i("div",null,"CodeMirror-code"),o.selectionDiv=n("div",null,null,"position: relative; z-index: 1"),o.cursorDiv=n("div",null,"CodeMirror-cursors"),o.measure=n("div",null,"CodeMirror-measure"),o.lineMeasure=n("div",null,"CodeMirror-measure"),o.lineSpace=i("div",[o.measure,o.lineMeasure,o.selectionDiv,o.cursorDiv,o.lineDiv],null,"position: relative; outline: none");var l=i("div",[o.lineSpace],"CodeMirror-lines");o.mover=n("div",[l],null,"position: relative"),o.sizer=n("div",[o.mover],"CodeMirror-sizer"),o.sizerWidth=null,o.heightForcer=n("div",null,null,"position: absolute; height: "+Rl+"px; width: 1px;"),o.gutters=n("div",null,"CodeMirror-gutters"),o.lineGutter=null,o.scroller=n("div",[o.sizer,o.heightForcer,o.gutters],"CodeMirror-scroll"),o.scroller.setAttribute("tabIndex","-1"),o.wrapper=n("div",[o.scrollbarFiller,o.gutterFiller,o.scroller],"CodeMirror"),gl&&vl<8&&(o.gutters.style.zIndex=-1,o.scroller.style.paddingRight=0),ml||fl&&Tl||(o.scroller.draggable=!0),e&&(e.appendChild?e.appendChild(o.wrapper):e(o.wrapper)),o.viewFrom=o.viewTo=t.first,o.reportedViewFrom=o.reportedViewTo=t.first,o.view=[],o.renderedView=null,o.externalMeasured=null,o.viewOffset=0,o.lastWrapHeight=o.lastWrapWidth=0,o.updateLineNumbers=null,o.nativeBarWidth=o.barHeight=o.barWidth=0,o.scrollbarsClipped=!1,o.lineNumWidth=o.lineNumInnerWidth=o.lineNumChars=null,o.alignWidgets=!1,o.cachedCharWidth=o.cachedTextHeight=o.cachedPaddingH=null,o.maxLine=null,o.maxLineLength=0,o.maxLineChanged=!1,o.wheelDX=o.wheelDY=o.wheelStartX=o.wheelStartY=null,o.shift=!1,o.selForContextMenu=null,o.activeTouch=null,r.init(o)}function M(e,t){if((t-=e.first)<0||t>=e.size)throw new Error("There is no line "+(t+e.first)+" in the document.");for(var r=e;!r.lines;)for(var n=0;;++n){var i=r.children[n],o=i.chunkSize();if(t<o){r=i;break}t-=o}return r.lines[t]}function N(e,t,r){var n=[],i=t.line;return e.iter(t.line,r.line+1,function(e){var o=e.text;i==r.line&&(o=o.slice(0,r.ch)),i==t.line&&(o=o.slice(t.ch)),n.push(o),++i}),n}function O(e,t,r){var n=[];return e.iter(t,r,function(e){n.push(e.text)}),n}function A(e,t){var r=t-e.height;if(r)for(var n=e;n;n=n.parent)n.height+=r}function W(e){if(null==e.parent)return null;for(var t=e.parent,r=h(t.lines,e),n=t.parent;n;t=n,n=n.parent)for(var i=0;n.children[i]!=t;++i)r+=n.children[i].chunkSize();return r+t.first}function D(e,t){var r=e.first;e:do{for(var n=0;n<e.children.length;++n){var i=e.children[n],o=i.height;if(t<o){e=i;continue e}t-=o,r+=i.chunkSize()}return r}while(!e.lines);for(var l=0;l<e.lines.length;++l){var s=e.lines[l].height;if(t<s)break;t-=s}return r+l}function H(e,t){return t>=e.first&&t<e.first+e.size}function F(e,t){return String(e.lineNumberFormatter(t+e.firstLineNumber))}function E(e,t,r){if(void 0===r&&(r=null),!(this instanceof E))return new E(e,t,r);this.line=e,this.ch=t,this.sticky=r}function P(e,t){return e.line-t.line||e.ch-t.ch}function I(e,t){return e.sticky==t.sticky&&0==P(e,t)}function z(e){return E(e.line,e.ch)}function R(e,t){return P(e,t)<0?t:e}function B(e,t){return P(e,t)<0?e:t}function G(e,t){return Math.max(e.first,Math.min(t,e.first+e.size-1))}function U(e,t){if(t.line<e.first)return E(e.first,0);var r=e.first+e.size-1;return t.line>r?E(r,M(e,r).text.length):V(t,M(e,t.line).text.length)}function V(e,t){var r=e.ch;return null==r||r>t?E(e.line,t):r<0?E(e.line,0):e}function K(e,t){for(var r=[],n=0;n<t.length;n++)r[n]=U(e,t[n]);return r}function j(){Yl=!0}function X(){_l=!0}function Y(e,t,r){this.marker=e,this.from=t,this.to=r}function _(e,t){if(e)for(var r=0;r<e.length;++r){var n=e[r];if(n.marker==t)return n}}function $(e,t){for(var r,n=0;n<e.length;++n)e[n]!=t&&(r||(r=[])).push(e[n]);return r}function q(e,t){e.markedSpans=e.markedSpans?e.markedSpans.concat([t]):[t],t.marker.attachLine(e)}function Z(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t)||o.from==t&&"bookmark"==l.type&&(!r||!o.marker.insertLeft)){var s=null==o.to||(l.inclusiveRight?o.to>=t:o.to>t);(n||(n=[])).push(new Y(l,o.from,s?null:o.to))}}return n}function Q(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.to||(l.inclusiveRight?o.to>=t:o.to>t)||o.from==t&&"bookmark"==l.type&&(!r||o.marker.insertLeft)){var s=null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t);(n||(n=[])).push(new Y(l,s?null:o.from-t,null==o.to?null:o.to-t))}}return n}function J(e,t){if(t.full)return null;var r=H(e,t.from.line)&&M(e,t.from.line).markedSpans,n=H(e,t.to.line)&&M(e,t.to.line).markedSpans;if(!r&&!n)return null;var i=t.from.ch,o=t.to.ch,l=0==P(t.from,t.to),s=Z(r,i,l),a=Q(n,o,l),u=1==t.text.length,c=g(t.text).length+(u?i:0);if(s)for(var f=0;f<s.length;++f){var h=s[f];if(null==h.to){var d=_(a,h.marker);d?u&&(h.to=null==d.to?null:d.to+c):h.to=i}}if(a)for(var p=0;p<a.length;++p){var v=a[p];null!=v.to&&(v.to+=c),null==v.from?_(s,v.marker)||(v.from=c,u&&(s||(s=[])).push(v)):(v.from+=c,u&&(s||(s=[])).push(v))}s&&(s=ee(s)),a&&a!=s&&(a=ee(a));var m=[s];if(!u){var y,b=t.text.length-2;if(b>0&&s)for(var w=0;w<s.length;++w)null==s[w].to&&(y||(y=[])).push(new Y(s[w].marker,null,null));for(var x=0;x<b;++x)m.push(y);m.push(a)}return m}function ee(e){for(var t=0;t<e.length;++t){var r=e[t];null!=r.from&&r.from==r.to&&!1!==r.marker.clearWhenEmpty&&e.splice(t--,1)}return e.length?e:null}function te(e,t,r){var n=null;if(e.iter(t.line,r.line+1,function(e){if(e.markedSpans)for(var t=0;t<e.markedSpans.length;++t){var r=e.markedSpans[t].marker;!r.readOnly||n&&-1!=h(n,r)||(n||(n=[])).push(r)}}),!n)return null;for(var i=[{from:t,to:r}],o=0;o<n.length;++o)for(var l=n[o],s=l.find(0),a=0;a<i.length;++a){var u=i[a];if(!(P(u.to,s.from)<0||P(u.from,s.to)>0)){var c=[a,1],f=P(u.from,s.from),d=P(u.to,s.to);(f<0||!l.inclusiveLeft&&!f)&&c.push({from:u.from,to:s.from}),(d>0||!l.inclusiveRight&&!d)&&c.push({from:s.to,to:u.to}),i.splice.apply(i,c),a+=c.length-3}}return i}function re(e){var t=e.markedSpans;if(t){for(var r=0;r<t.length;++r)t[r].marker.detachLine(e);e.markedSpans=null}}function ne(e,t){if(t){for(var r=0;r<t.length;++r)t[r].marker.attachLine(e);e.markedSpans=t}}function ie(e){return e.inclusiveLeft?-1:0}function oe(e){return e.inclusiveRight?1:0}function le(e,t){var r=e.lines.length-t.lines.length;if(0!=r)return r;var n=e.find(),i=t.find(),o=P(n.from,i.from)||ie(e)-ie(t);if(o)return-o;var l=P(n.to,i.to)||oe(e)-oe(t);return l||t.id-e.id}function se(e,t){var r,n=_l&&e.markedSpans;if(n)for(var i=void 0,o=0;o<n.length;++o)(i=n[o]).marker.collapsed&&null==(t?i.from:i.to)&&(!r||le(r,i.marker)<0)&&(r=i.marker);return r}function ae(e){return se(e,!0)}function ue(e){return se(e,!1)}function ce(e,t,r,n,i){var o=M(e,t),l=_l&&o.markedSpans;if(l)for(var s=0;s<l.length;++s){var a=l[s];if(a.marker.collapsed){var u=a.marker.find(0),c=P(u.from,r)||ie(a.marker)-ie(i),f=P(u.to,n)||oe(a.marker)-oe(i);if(!(c>=0&&f<=0||c<=0&&f>=0)&&(c<=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.to,r)>=0:P(u.to,r)>0)||c>=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.from,n)<=0:P(u.from,n)<0)))return!0}}}function fe(e){for(var t;t=ae(e);)e=t.find(-1,!0).line;return e}function he(e){for(var t;t=ue(e);)e=t.find(1,!0).line;return e}function de(e){for(var t,r;t=ue(e);)e=t.find(1,!0).line,(r||(r=[])).push(e);return r}function pe(e,t){var r=M(e,t),n=fe(r);return r==n?t:W(n)}function ge(e,t){if(t>e.lastLine())return t;var r,n=M(e,t);if(!ve(e,n))return t;for(;r=ue(n);)n=r.find(1,!0).line;return W(n)+1}function ve(e,t){var r=_l&&t.markedSpans;if(r)for(var n=void 0,i=0;i<r.length;++i)if((n=r[i]).marker.collapsed){if(null==n.from)return!0;if(!n.marker.widgetNode&&0==n.from&&n.marker.inclusiveLeft&&me(e,t,n))return!0}}function me(e,t,r){if(null==r.to){var n=r.marker.find(1,!0);return me(e,n.line,_(n.line.markedSpans,r.marker))}if(r.marker.inclusiveRight&&r.to==t.text.length)return!0;for(var i=void 0,o=0;o<t.markedSpans.length;++o)if((i=t.markedSpans[o]).marker.collapsed&&!i.marker.widgetNode&&i.from==r.to&&(null==i.to||i.to!=r.from)&&(i.marker.inclusiveLeft||r.marker.inclusiveRight)&&me(e,t,i))return!0}function ye(e){for(var t=0,r=(e=fe(e)).parent,n=0;n<r.lines.length;++n){var i=r.lines[n];if(i==e)break;t+=i.height}for(var o=r.parent;o;r=o,o=r.parent)for(var l=0;l<o.children.length;++l){var s=o.children[l];if(s==r)break;t+=s.height}return t}function be(e){if(0==e.height)return 0;for(var t,r=e.text.length,n=e;t=ae(n);){var i=t.find(0,!0);n=i.from.line,r+=i.from.ch-i.to.ch}for(n=e;t=ue(n);){var o=t.find(0,!0);r-=n.text.length-o.from.ch,r+=(n=o.to.line).text.length-o.to.ch}return r}function we(e){var t=e.display,r=e.doc;t.maxLine=M(r,r.first),t.maxLineLength=be(t.maxLine),t.maxLineChanged=!0,r.iter(function(e){var r=be(e);r>t.maxLineLength&&(t.maxLineLength=r,t.maxLine=e)})}function xe(e,t,r,n){if(!e)return n(t,r,"ltr",0);for(var i=!1,o=0;o<e.length;++o){var l=e[o];(l.from<r&&l.to>t||t==r&&l.to==t)&&(n(Math.max(l.from,t),Math.min(l.to,r),1==l.level?"rtl":"ltr",o),i=!0)}i||n(t,r,"ltr")}function Ce(e,t,r){var n;$l=null;for(var i=0;i<e.length;++i){var o=e[i];if(o.from<t&&o.to>t)return i;o.to==t&&(o.from!=o.to&&"before"==r?n=i:$l=i),o.from==t&&(o.from!=o.to&&"before"!=r?n=i:$l=i)}return null!=n?n:$l}function Se(e,t){var r=e.order;return null==r&&(r=e.order=ql(e.text,t)),r}function Le(e,t){return e._handlers&&e._handlers[t]||Zl}function ke(e,t,r){if(e.removeEventListener)e.removeEventListener(t,r,!1);else if(e.detachEvent)e.detachEvent("on"+t,r);else{var n=e._handlers,i=n&&n[t];if(i){var o=h(i,r);o>-1&&(n[t]=i.slice(0,o).concat(i.slice(o+1)))}}}function Te(e,t){var r=Le(e,t);if(r.length)for(var n=Array.prototype.slice.call(arguments,2),i=0;i<r.length;++i)r[i].apply(null,n)}function Me(e,t,r){return"string"==typeof t&&(t={type:t,preventDefault:function(){this.defaultPrevented=!0}}),Te(e,r||t.type,e,t),He(t)||t.codemirrorIgnore}function Ne(e){var t=e._handlers&&e._handlers.cursorActivity;if(t)for(var r=e.curOp.cursorActivityHandlers||(e.curOp.cursorActivityHandlers=[]),n=0;n<t.length;++n)-1==h(r,t[n])&&r.push(t[n])}function Oe(e,t){return Le(e,t).length>0}function Ae(e){e.prototype.on=function(e,t){Ql(this,e,t)},e.prototype.off=function(e,t){ke(this,e,t)}}function We(e){e.preventDefault?e.preventDefault():e.returnValue=!1}function De(e){e.stopPropagation?e.stopPropagation():e.cancelBubble=!0}function He(e){return null!=e.defaultPrevented?e.defaultPrevented:0==e.returnValue}function Fe(e){We(e),De(e)}function Ee(e){return e.target||e.srcElement}function Pe(e){var t=e.which;return null==t&&(1&e.button?t=1:2&e.button?t=3:4&e.button&&(t=2)),Ml&&e.ctrlKey&&1==t&&(t=3),t}function Ie(e){if(null==Il){var t=n("span","​");r(e,n("span",[t,document.createTextNode("x")])),0!=e.firstChild.offsetHeight&&(Il=t.offsetWidth<=1&&t.offsetHeight>2&&!(gl&&vl<8))}var i=Il?n("span","​"):n("span"," ",null,"display: inline-block; width: 1px; margin-right: -1px");return i.setAttribute("cm-text",""),i}function ze(e){if(null!=zl)return zl;var n=r(e,document.createTextNode("AخA")),i=Wl(n,0,1).getBoundingClientRect(),o=Wl(n,1,2).getBoundingClientRect();return t(e),!(!i||i.left==i.right)&&(zl=o.right-i.right<3)}function Re(e){if(null!=ns)return ns;var t=r(e,n("span","x")),i=t.getBoundingClientRect(),o=Wl(t,0,1).getBoundingClientRect();return ns=Math.abs(i.left-o.left)>1}function Be(e,t){arguments.length>2&&(t.dependencies=Array.prototype.slice.call(arguments,2)),is[e]=t}function Ge(e){if("string"==typeof e&&os.hasOwnProperty(e))e=os[e];else if(e&&"string"==typeof e.name&&os.hasOwnProperty(e.name)){var t=os[e.name];"string"==typeof t&&(t={name:t}),(e=b(t,e)).name=t.name}else{if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+xml$/.test(e))return Ge("application/xml");if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+json$/.test(e))return Ge("application/json")}return"string"==typeof e?{name:e}:e||{name:"null"}}function Ue(e,t){t=Ge(t);var r=is[t.name];if(!r)return Ue(e,"text/plain");var n=r(e,t);if(ls.hasOwnProperty(t.name)){var i=ls[t.name];for(var o in i)i.hasOwnProperty(o)&&(n.hasOwnProperty(o)&&(n["_"+o]=n[o]),n[o]=i[o])}if(n.name=t.name,t.helperType&&(n.helperType=t.helperType),t.modeProps)for(var l in t.modeProps)n[l]=t.modeProps[l];return n}function Ve(e,t){c(t,ls.hasOwnProperty(e)?ls[e]:ls[e]={})}function Ke(e,t){if(!0===t)return t;if(e.copyState)return e.copyState(t);var r={};for(var n in t){var i=t[n];i instanceof Array&&(i=i.concat([])),r[n]=i}return r}function je(e,t){for(var r;e.innerMode&&(r=e.innerMode(t))&&r.mode!=e;)t=r.state,e=r.mode;return r||{mode:e,state:t}}function Xe(e,t,r){return!e.startState||e.startState(t,r)}function Ye(e,t,r,n){var i=[e.state.modeGen],o={};tt(e,t.text,e.doc.mode,r,function(e,t){return i.push(e,t)},o,n);for(var l=r.state,s=0;s<e.state.overlays.length;++s)!function(n){var l=e.state.overlays[n],s=1,a=0;r.state=!0,tt(e,t.text,l.mode,r,function(e,t){for(var r=s;a<e;){var n=i[s];n>e&&i.splice(s,1,e,i[s+1],n),s+=2,a=Math.min(e,n)}if(t)if(l.opaque)i.splice(r,s-r,e,"overlay "+t),s=r+2;else for(;r<s;r+=2){var o=i[r+1];i[r+1]=(o?o+" ":"")+"overlay "+t}},o)}(s);return r.state=l,{styles:i,classes:o.bgClass||o.textClass?o:null}}function _e(e,t,r){if(!t.styles||t.styles[0]!=e.state.modeGen){var n=$e(e,W(t)),i=t.text.length>e.options.maxHighlightLength&&Ke(e.doc.mode,n.state),o=Ye(e,t,n);i&&(n.state=i),t.stateAfter=n.save(!i),t.styles=o.styles,o.classes?t.styleClasses=o.classes:t.styleClasses&&(t.styleClasses=null),r===e.doc.highlightFrontier&&(e.doc.modeFrontier=Math.max(e.doc.modeFrontier,++e.doc.highlightFrontier))}return t.styles}function $e(e,t,r){var n=e.doc,i=e.display;if(!n.mode.startState)return new us(n,!0,t);var o=rt(e,t,r),l=o>n.first&&M(n,o-1).stateAfter,s=l?us.fromSaved(n,l,o):new us(n,Xe(n.mode),o);return n.iter(o,t,function(r){qe(e,r.text,s);var n=s.line;r.stateAfter=n==t-1||n%5==0||n>=i.viewFrom&&n<i.viewTo?s.save():null,s.nextLine()}),r&&(n.modeFrontier=s.line),s}function qe(e,t,r,n){var i=e.doc.mode,o=new ss(t,e.options.tabSize,r);for(o.start=o.pos=n||0,""==t&&Ze(i,r.state);!o.eol();)Qe(i,o,r.state),o.start=o.pos}function Ze(e,t){if(e.blankLine)return e.blankLine(t);if(e.innerMode){var r=je(e,t);return r.mode.blankLine?r.mode.blankLine(r.state):void 0}}function Qe(e,t,r,n){for(var i=0;i<10;i++){n&&(n[0]=je(e,r).mode);var o=e.token(t,r);if(t.pos>t.start)return o}throw new Error("Mode "+e.name+" failed to advance stream.")}function Je(e,t,r,n){var i,o,l=e.doc,s=l.mode,a=M(l,(t=U(l,t)).line),u=$e(e,t.line,r),c=new ss(a.text,e.options.tabSize,u);for(n&&(o=[]);(n||c.pos<t.ch)&&!c.eol();)c.start=c.pos,i=Qe(s,c,u.state),n&&o.push(new cs(c,i,Ke(l.mode,u.state)));return n?o:new cs(c,i,u.state)}function et(e,t){if(e)for(;;){var r=e.match(/(?:^|\s+)line-(background-)?(\S+)/);if(!r)break;e=e.slice(0,r.index)+e.slice(r.index+r[0].length);var n=r[1]?"bgClass":"textClass";null==t[n]?t[n]=r[2]:new RegExp("(?:^|s)"+r[2]+"(?:$|s)").test(t[n])||(t[n]+=" "+r[2])}return e}function tt(e,t,r,n,i,o,l){var s=r.flattenSpans;null==s&&(s=e.options.flattenSpans);var a,u=0,c=null,f=new ss(t,e.options.tabSize,n),h=e.options.addModeClass&&[null];for(""==t&&et(Ze(r,n.state),o);!f.eol();){if(f.pos>e.options.maxHighlightLength?(s=!1,l&&qe(e,t,n,f.pos),f.pos=t.length,a=null):a=et(Qe(r,f,n.state,h),o),h){var d=h[0].name;d&&(a="m-"+(a?d+" "+a:d))}if(!s||c!=a){for(;u<f.start;)i(u=Math.min(f.start,u+5e3),c);c=a}f.start=f.pos}for(;u<f.pos;){var p=Math.min(f.pos,u+5e3);i(p,c),u=p}}function rt(e,t,r){for(var n,i,o=e.doc,l=r?-1:t-(e.doc.mode.innerMode?1e3:100),s=t;s>l;--s){if(s<=o.first)return o.first;var a=M(o,s-1),u=a.stateAfter;if(u&&(!r||s+(u instanceof as?u.lookAhead:0)<=o.modeFrontier))return s;var c=f(a.text,null,e.options.tabSize);(null==i||n>c)&&(i=s-1,n=c)}return i}function nt(e,t){if(e.modeFrontier=Math.min(e.modeFrontier,t),!(e.highlightFrontier<t-10)){for(var r=e.first,n=t-1;n>r;n--){var i=M(e,n).stateAfter;if(i&&(!(i instanceof as)||n+i.lookAhead<t)){r=n+1;break}}e.highlightFrontier=Math.min(e.highlightFrontier,r)}}function it(e,t,r,n){e.text=t,e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null),null!=e.order&&(e.order=null),re(e),ne(e,r);var i=n?n(e):1;i!=e.height&&A(e,i)}function ot(e){e.parent=null,re(e)}function lt(e,t){if(!e||/^\s*$/.test(e))return null;var r=t.addModeClass?ps:ds;return r[e]||(r[e]=e.replace(/\S+/g,"cm-$&"))}function st(e,t){var r=i("span",null,null,ml?"padding-right: .1px":null),n={pre:i("pre",[r],"CodeMirror-line"),content:r,col:0,pos:0,cm:e,trailingSpace:!1,splitSpaces:(gl||ml)&&e.getOption("lineWrapping")};t.measure={};for(var o=0;o<=(t.rest?t.rest.length:0);o++){var l=o?t.rest[o-1]:t.line,s=void 0;n.pos=0,n.addToken=ut,ze(e.display.measure)&&(s=Se(l,e.doc.direction))&&(n.addToken=ft(n.addToken,s)),n.map=[],dt(l,n,_e(e,l,t!=e.display.externalMeasured&&W(l))),l.styleClasses&&(l.styleClasses.bgClass&&(n.bgClass=a(l.styleClasses.bgClass,n.bgClass||"")),l.styleClasses.textClass&&(n.textClass=a(l.styleClasses.textClass,n.textClass||""))),0==n.map.length&&n.map.push(0,0,n.content.appendChild(Ie(e.display.measure))),0==o?(t.measure.map=n.map,t.measure.cache={}):((t.measure.maps||(t.measure.maps=[])).push(n.map),(t.measure.caches||(t.measure.caches=[])).push({}))}if(ml){var u=n.content.lastChild;(/\bcm-tab\b/.test(u.className)||u.querySelector&&u.querySelector(".cm-tab"))&&(n.content.className="cm-tab-wrap-hack")}return Te(e,"renderLine",e,t.line,n.pre),n.pre.className&&(n.textClass=a(n.pre.className,n.textClass||"")),n}function at(e){var t=n("span","•","cm-invalidchar");return t.title="\\u"+e.charCodeAt(0).toString(16),t.setAttribute("aria-label",t.title),t}function ut(e,t,r,i,o,l,s){if(t){var a,u=e.splitSpaces?ct(t,e.trailingSpace):t,c=e.cm.state.specialChars,f=!1;if(c.test(t)){a=document.createDocumentFragment();for(var h=0;;){c.lastIndex=h;var d=c.exec(t),g=d?d.index-h:t.length-h;if(g){var v=document.createTextNode(u.slice(h,h+g));gl&&vl<9?a.appendChild(n("span",[v])):a.appendChild(v),e.map.push(e.pos,e.pos+g,v),e.col+=g,e.pos+=g}if(!d)break;h+=g+1;var m=void 0;if("\t"==d[0]){var y=e.cm.options.tabSize,b=y-e.col%y;(m=a.appendChild(n("span",p(b),"cm-tab"))).setAttribute("role","presentation"),m.setAttribute("cm-text","\t"),e.col+=b}else"\r"==d[0]||"\n"==d[0]?((m=a.appendChild(n("span","\r"==d[0]?"␍":"␤","cm-invalidchar"))).setAttribute("cm-text",d[0]),e.col+=1):((m=e.cm.options.specialCharPlaceholder(d[0])).setAttribute("cm-text",d[0]),gl&&vl<9?a.appendChild(n("span",[m])):a.appendChild(m),e.col+=1);e.map.push(e.pos,e.pos+1,m),e.pos++}}else e.col+=t.length,a=document.createTextNode(u),e.map.push(e.pos,e.pos+t.length,a),gl&&vl<9&&(f=!0),e.pos+=t.length;if(e.trailingSpace=32==u.charCodeAt(t.length-1),r||i||o||f||s){var w=r||"";i&&(w+=i),o&&(w+=o);var x=n("span",[a],w,s);return l&&(x.title=l),e.content.appendChild(x)}e.content.appendChild(a)}}function ct(e,t){if(e.length>1&&!/  /.test(e))return e;for(var r=t,n="",i=0;i<e.length;i++){var o=e.charAt(i);" "!=o||!r||i!=e.length-1&&32!=e.charCodeAt(i+1)||(o=" "),n+=o,r=" "==o}return n}function ft(e,t){return function(r,n,i,o,l,s,a){i=i?i+" cm-force-border":"cm-force-border";for(var u=r.pos,c=u+n.length;;){for(var f=void 0,h=0;h<t.length&&!((f=t[h]).to>u&&f.from<=u);h++);if(f.to>=c)return e(r,n,i,o,l,s,a);e(r,n.slice(0,f.to-u),i,o,null,s,a),o=null,n=n.slice(f.to-u),u=f.to}}}function ht(e,t,r,n){var i=!n&&r.widgetNode;i&&e.map.push(e.pos,e.pos+t,i),!n&&e.cm.display.input.needsContentAttribute&&(i||(i=e.content.appendChild(document.createElement("span"))),i.setAttribute("cm-marker",r.id)),i&&(e.cm.display.input.setUneditable(i),e.content.appendChild(i)),e.pos+=t,e.trailingSpace=!1}function dt(e,t,r){var n=e.markedSpans,i=e.text,o=0;if(n)for(var l,s,a,u,c,f,h,d=i.length,p=0,g=1,v="",m=0;;){if(m==p){a=u=c=f=s="",h=null,m=1/0;for(var y=[],b=void 0,w=0;w<n.length;++w){var x=n[w],C=x.marker;"bookmark"==C.type&&x.from==p&&C.widgetNode?y.push(C):x.from<=p&&(null==x.to||x.to>p||C.collapsed&&x.to==p&&x.from==p)?(null!=x.to&&x.to!=p&&m>x.to&&(m=x.to,u=""),C.className&&(a+=" "+C.className),C.css&&(s=(s?s+";":"")+C.css),C.startStyle&&x.from==p&&(c+=" "+C.startStyle),C.endStyle&&x.to==m&&(b||(b=[])).push(C.endStyle,x.to),C.title&&!f&&(f=C.title),C.collapsed&&(!h||le(h.marker,C)<0)&&(h=x)):x.from>p&&m>x.from&&(m=x.from)}if(b)for(var S=0;S<b.length;S+=2)b[S+1]==m&&(u+=" "+b[S]);if(!h||h.from==p)for(var L=0;L<y.length;++L)ht(t,0,y[L]);if(h&&(h.from||0)==p){if(ht(t,(null==h.to?d+1:h.to)-p,h.marker,null==h.from),null==h.to)return;h.to==p&&(h=!1)}}if(p>=d)break;for(var k=Math.min(d,m);;){if(v){var T=p+v.length;if(!h){var M=T>k?v.slice(0,k-p):v;t.addToken(t,M,l?l+a:a,c,p+M.length==m?u:"",f,s)}if(T>=k){v=v.slice(k-p),p=k;break}p=T,c=""}v=i.slice(o,o=r[g++]),l=lt(r[g++],t.cm.options)}}else for(var N=1;N<r.length;N+=2)t.addToken(t,i.slice(o,o=r[N]),lt(r[N+1],t.cm.options))}function pt(e,t,r){this.line=t,this.rest=de(t),this.size=this.rest?W(g(this.rest))-r+1:1,this.node=this.text=null,this.hidden=ve(e,t)}function gt(e,t,r){for(var n,i=[],o=t;o<r;o=n){var l=new pt(e.doc,M(e.doc,o),o);n=o+l.size,i.push(l)}return i}function vt(e){gs?gs.ops.push(e):e.ownsGroup=gs={ops:[e],delayedCallbacks:[]}}function mt(e){var t=e.delayedCallbacks,r=0;do{for(;r<t.length;r++)t[r].call(null);for(var n=0;n<e.ops.length;n++){var i=e.ops[n];if(i.cursorActivityHandlers)for(;i.cursorActivityCalled<i.cursorActivityHandlers.length;)i.cursorActivityHandlers[i.cursorActivityCalled++].call(null,i.cm)}}while(r<t.length)}function yt(e,t){var r=e.ownsGroup;if(r)try{mt(r)}finally{gs=null,t(r)}}function bt(e,t){var r=Le(e,t);if(r.length){var n,i=Array.prototype.slice.call(arguments,2);gs?n=gs.delayedCallbacks:vs?n=vs:(n=vs=[],setTimeout(wt,0));for(var o=0;o<r.length;++o)!function(e){n.push(function(){return r[e].apply(null,i)})}(o)}}function wt(){var e=vs;vs=null;for(var t=0;t<e.length;++t)e[t]()}function xt(e,t,r,n){for(var i=0;i<t.changes.length;i++){var o=t.changes[i];"text"==o?kt(e,t):"gutter"==o?Mt(e,t,r,n):"class"==o?Tt(e,t):"widget"==o&&Nt(e,t,n)}t.changes=null}function Ct(e){return e.node==e.text&&(e.node=n("div",null,null,"position: relative"),e.text.parentNode&&e.text.parentNode.replaceChild(e.node,e.text),e.node.appendChild(e.text),gl&&vl<8&&(e.node.style.zIndex=2)),e.node}function St(e,t){var r=t.bgClass?t.bgClass+" "+(t.line.bgClass||""):t.line.bgClass;if(r&&(r+=" CodeMirror-linebackground"),t.background)r?t.background.className=r:(t.background.parentNode.removeChild(t.background),t.background=null);else if(r){var i=Ct(t);t.background=i.insertBefore(n("div",null,r),i.firstChild),e.display.input.setUneditable(t.background)}}function Lt(e,t){var r=e.display.externalMeasured;return r&&r.line==t.line?(e.display.externalMeasured=null,t.measure=r.measure,r.built):st(e,t)}function kt(e,t){var r=t.text.className,n=Lt(e,t);t.text==t.node&&(t.node=n.pre),t.text.parentNode.replaceChild(n.pre,t.text),t.text=n.pre,n.bgClass!=t.bgClass||n.textClass!=t.textClass?(t.bgClass=n.bgClass,t.textClass=n.textClass,Tt(e,t)):r&&(t.text.className=r)}function Tt(e,t){St(e,t),t.line.wrapClass?Ct(t).className=t.line.wrapClass:t.node!=t.text&&(t.node.className="");var r=t.textClass?t.textClass+" "+(t.line.textClass||""):t.line.textClass;t.text.className=r||""}function Mt(e,t,r,i){if(t.gutter&&(t.node.removeChild(t.gutter),t.gutter=null),t.gutterBackground&&(t.node.removeChild(t.gutterBackground),t.gutterBackground=null),t.line.gutterClass){var o=Ct(t);t.gutterBackground=n("div",null,"CodeMirror-gutter-background "+t.line.gutterClass,"left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px; width: "+i.gutterTotalWidth+"px"),e.display.input.setUneditable(t.gutterBackground),o.insertBefore(t.gutterBackground,t.text)}var l=t.line.gutterMarkers;if(e.options.lineNumbers||l){var s=Ct(t),a=t.gutter=n("div",null,"CodeMirror-gutter-wrapper","left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px");if(e.display.input.setUneditable(a),s.insertBefore(a,t.text),t.line.gutterClass&&(a.className+=" "+t.line.gutterClass),!e.options.lineNumbers||l&&l["CodeMirror-linenumbers"]||(t.lineNumber=a.appendChild(n("div",F(e.options,r),"CodeMirror-linenumber CodeMirror-gutter-elt","left: "+i.gutterLeft["CodeMirror-linenumbers"]+"px; width: "+e.display.lineNumInnerWidth+"px"))),l)for(var u=0;u<e.options.gutters.length;++u){var c=e.options.gutters[u],f=l.hasOwnProperty(c)&&l[c];f&&a.appendChild(n("div",[f],"CodeMirror-gutter-elt","left: "+i.gutterLeft[c]+"px; width: "+i.gutterWidth[c]+"px"))}}}function Nt(e,t,r){t.alignable&&(t.alignable=null);for(var n=t.node.firstChild,i=void 0;n;n=i)i=n.nextSibling,"CodeMirror-linewidget"==n.className&&t.node.removeChild(n);At(e,t,r)}function Ot(e,t,r,n){var i=Lt(e,t);return t.text=t.node=i.pre,i.bgClass&&(t.bgClass=i.bgClass),i.textClass&&(t.textClass=i.textClass),Tt(e,t),Mt(e,t,r,n),At(e,t,n),t.node}function At(e,t,r){if(Wt(e,t.line,t,r,!0),t.rest)for(var n=0;n<t.rest.length;n++)Wt(e,t.rest[n],t,r,!1)}function Wt(e,t,r,i,o){if(t.widgets)for(var l=Ct(r),s=0,a=t.widgets;s<a.length;++s){var u=a[s],c=n("div",[u.node],"CodeMirror-linewidget");u.handleMouseEvents||c.setAttribute("cm-ignore-events","true"),Dt(u,c,r,i),e.display.input.setUneditable(c),o&&u.above?l.insertBefore(c,r.gutter||r.text):l.appendChild(c),bt(u,"redraw")}}function Dt(e,t,r,n){if(e.noHScroll){(r.alignable||(r.alignable=[])).push(t);var i=n.wrapperWidth;t.style.left=n.fixedPos+"px",e.coverGutter||(i-=n.gutterTotalWidth,t.style.paddingLeft=n.gutterTotalWidth+"px"),t.style.width=i+"px"}e.coverGutter&&(t.style.zIndex=5,t.style.position="relative",e.noHScroll||(t.style.marginLeft=-n.gutterTotalWidth+"px"))}function Ht(e){if(null!=e.height)return e.height;var t=e.doc.cm;if(!t)return 0;if(!o(document.body,e.node)){var i="position: relative;";e.coverGutter&&(i+="margin-left: -"+t.display.gutters.offsetWidth+"px;"),e.noHScroll&&(i+="width: "+t.display.wrapper.clientWidth+"px;"),r(t.display.measure,n("div",[e.node],null,i))}return e.height=e.node.parentNode.offsetHeight}function Ft(e,t){for(var r=Ee(t);r!=e.wrapper;r=r.parentNode)if(!r||1==r.nodeType&&"true"==r.getAttribute("cm-ignore-events")||r.parentNode==e.sizer&&r!=e.mover)return!0}function Et(e){return e.lineSpace.offsetTop}function Pt(e){return e.mover.offsetHeight-e.lineSpace.offsetHeight}function It(e){if(e.cachedPaddingH)return e.cachedPaddingH;var t=r(e.measure,n("pre","x")),i=window.getComputedStyle?window.getComputedStyle(t):t.currentStyle,o={left:parseInt(i.paddingLeft),right:parseInt(i.paddingRight)};return isNaN(o.left)||isNaN(o.right)||(e.cachedPaddingH=o),o}function zt(e){return Rl-e.display.nativeBarWidth}function Rt(e){return e.display.scroller.clientWidth-zt(e)-e.display.barWidth}function Bt(e){return e.display.scroller.clientHeight-zt(e)-e.display.barHeight}function Gt(e,t,r){var n=e.options.lineWrapping,i=n&&Rt(e);if(!t.measure.heights||n&&t.measure.width!=i){var o=t.measure.heights=[];if(n){t.measure.width=i;for(var l=t.text.firstChild.getClientRects(),s=0;s<l.length-1;s++){var a=l[s],u=l[s+1];Math.abs(a.bottom-u.bottom)>2&&o.push((a.bottom+u.top)/2-r.top)}}o.push(r.bottom-r.top)}}function Ut(e,t,r){if(e.line==t)return{map:e.measure.map,cache:e.measure.cache};for(var n=0;n<e.rest.length;n++)if(e.rest[n]==t)return{map:e.measure.maps[n],cache:e.measure.caches[n]};for(var i=0;i<e.rest.length;i++)if(W(e.rest[i])>r)return{map:e.measure.maps[i],cache:e.measure.caches[i],before:!0}}function Vt(e,t){var n=W(t=fe(t)),i=e.display.externalMeasured=new pt(e.doc,t,n);i.lineN=n;var o=i.built=st(e,i);return i.text=o.pre,r(e.display.lineMeasure,o.pre),i}function Kt(e,t,r,n){return Yt(e,Xt(e,t),r,n)}function jt(e,t){if(t>=e.display.viewFrom&&t<e.display.viewTo)return e.display.view[Lr(e,t)];var r=e.display.externalMeasured;return r&&t>=r.lineN&&t<r.lineN+r.size?r:void 0}function Xt(e,t){var r=W(t),n=jt(e,r);n&&!n.text?n=null:n&&n.changes&&(xt(e,n,r,br(e)),e.curOp.forceUpdate=!0),n||(n=Vt(e,t));var i=Ut(n,t,r);return{line:t,view:n,rect:null,map:i.map,cache:i.cache,before:i.before,hasHeights:!1}}function Yt(e,t,r,n,i){t.before&&(r=-1);var o,l=r+(n||"");return t.cache.hasOwnProperty(l)?o=t.cache[l]:(t.rect||(t.rect=t.view.text.getBoundingClientRect()),t.hasHeights||(Gt(e,t.view,t.rect),t.hasHeights=!0),(o=qt(e,t,r,n)).bogus||(t.cache[l]=o)),{left:o.left,right:o.right,top:i?o.rtop:o.top,bottom:i?o.rbottom:o.bottom}}function _t(e,t,r){for(var n,i,o,l,s,a,u=0;u<e.length;u+=3)if(s=e[u],a=e[u+1],t<s?(i=0,o=1,l="left"):t<a?o=(i=t-s)+1:(u==e.length-3||t==a&&e[u+3]>t)&&(i=(o=a-s)-1,t>=a&&(l="right")),null!=i){if(n=e[u+2],s==a&&r==(n.insertLeft?"left":"right")&&(l=r),"left"==r&&0==i)for(;u&&e[u-2]==e[u-3]&&e[u-1].insertLeft;)n=e[2+(u-=3)],l="left";if("right"==r&&i==a-s)for(;u<e.length-3&&e[u+3]==e[u+4]&&!e[u+5].insertLeft;)n=e[(u+=3)+2],l="right";break}return{node:n,start:i,end:o,collapse:l,coverStart:s,coverEnd:a}}function $t(e,t){var r=ms;if("left"==t)for(var n=0;n<e.length&&(r=e[n]).left==r.right;n++);else for(var i=e.length-1;i>=0&&(r=e[i]).left==r.right;i--);return r}function qt(e,t,r,n){var i,o=_t(t.map,r,n),l=o.node,s=o.start,a=o.end,u=o.collapse;if(3==l.nodeType){for(var c=0;c<4;c++){for(;s&&S(t.line.text.charAt(o.coverStart+s));)--s;for(;o.coverStart+a<o.coverEnd&&S(t.line.text.charAt(o.coverStart+a));)++a;if((i=gl&&vl<9&&0==s&&a==o.coverEnd-o.coverStart?l.parentNode.getBoundingClientRect():$t(Wl(l,s,a).getClientRects(),n)).left||i.right||0==s)break;a=s,s-=1,u="right"}gl&&vl<11&&(i=Zt(e.display.measure,i))}else{s>0&&(u=n="right");var f;i=e.options.lineWrapping&&(f=l.getClientRects()).length>1?f["right"==n?f.length-1:0]:l.getBoundingClientRect()}if(gl&&vl<9&&!s&&(!i||!i.left&&!i.right)){var h=l.parentNode.getClientRects()[0];i=h?{left:h.left,right:h.left+yr(e.display),top:h.top,bottom:h.bottom}:ms}for(var d=i.top-t.rect.top,p=i.bottom-t.rect.top,g=(d+p)/2,v=t.view.measure.heights,m=0;m<v.length-1&&!(g<v[m]);m++);var y=m?v[m-1]:0,b=v[m],w={left:("right"==u?i.right:i.left)-t.rect.left,right:("left"==u?i.left:i.right)-t.rect.left,top:y,bottom:b};return i.left||i.right||(w.bogus=!0),e.options.singleCursorHeightPerLine||(w.rtop=d,w.rbottom=p),w}function Zt(e,t){if(!window.screen||null==screen.logicalXDPI||screen.logicalXDPI==screen.deviceXDPI||!Re(e))return t;var r=screen.logicalXDPI/screen.deviceXDPI,n=screen.logicalYDPI/screen.deviceYDPI;return{left:t.left*r,right:t.right*r,top:t.top*n,bottom:t.bottom*n}}function Qt(e){if(e.measure&&(e.measure.cache={},e.measure.heights=null,e.rest))for(var t=0;t<e.rest.length;t++)e.measure.caches[t]={}}function Jt(e){e.display.externalMeasure=null,t(e.display.lineMeasure);for(var r=0;r<e.display.view.length;r++)Qt(e.display.view[r])}function er(e){Jt(e),e.display.cachedCharWidth=e.display.cachedTextHeight=e.display.cachedPaddingH=null,e.options.lineWrapping||(e.display.maxLineChanged=!0),e.display.lineNumChars=null}function tr(){return bl&&kl?-(document.body.getBoundingClientRect().left-parseInt(getComputedStyle(document.body).marginLeft)):window.pageXOffset||(document.documentElement||document.body).scrollLeft}function rr(){return bl&&kl?-(document.body.getBoundingClientRect().top-parseInt(getComputedStyle(document.body).marginTop)):window.pageYOffset||(document.documentElement||document.body).scrollTop}function nr(e){var t=0;if(e.widgets)for(var r=0;r<e.widgets.length;++r)e.widgets[r].above&&(t+=Ht(e.widgets[r]));return t}function ir(e,t,r,n,i){if(!i){var o=nr(t);r.top+=o,r.bottom+=o}if("line"==n)return r;n||(n="local");var l=ye(t);if("local"==n?l+=Et(e.display):l-=e.display.viewOffset,"page"==n||"window"==n){var s=e.display.lineSpace.getBoundingClientRect();l+=s.top+("window"==n?0:rr());var a=s.left+("window"==n?0:tr());r.left+=a,r.right+=a}return r.top+=l,r.bottom+=l,r}function or(e,t,r){if("div"==r)return t;var n=t.left,i=t.top;if("page"==r)n-=tr(),i-=rr();else if("local"==r||!r){var o=e.display.sizer.getBoundingClientRect();n+=o.left,i+=o.top}var l=e.display.lineSpace.getBoundingClientRect();return{left:n-l.left,top:i-l.top}}function lr(e,t,r,n,i){return n||(n=M(e.doc,t.line)),ir(e,n,Kt(e,n,t.ch,i),r)}function sr(e,t,r,n,i,o){function l(t,l){var s=Yt(e,i,t,l?"right":"left",o);return l?s.left=s.right:s.right=s.left,ir(e,n,s,r)}function s(e,t,r){var n=1==a[t].level;return l(r?e-1:e,n!=r)}n=n||M(e.doc,t.line),i||(i=Xt(e,n));var a=Se(n,e.doc.direction),u=t.ch,c=t.sticky;if(u>=n.text.length?(u=n.text.length,c="before"):u<=0&&(u=0,c="after"),!a)return l("before"==c?u-1:u,"before"==c);var f=Ce(a,u,c),h=$l,d=s(u,f,"before"==c);return null!=h&&(d.other=s(u,h,"before"!=c)),d}function ar(e,t){var r=0;t=U(e.doc,t),e.options.lineWrapping||(r=yr(e.display)*t.ch);var n=M(e.doc,t.line),i=ye(n)+Et(e.display);return{left:r,right:r,top:i,bottom:i+n.height}}function ur(e,t,r,n,i){var o=E(e,t,r);return o.xRel=i,n&&(o.outside=!0),o}function cr(e,t,r){var n=e.doc;if((r+=e.display.viewOffset)<0)return ur(n.first,0,null,!0,-1);var i=D(n,r),o=n.first+n.size-1;if(i>o)return ur(n.first+n.size-1,M(n,o).text.length,null,!0,1);t<0&&(t=0);for(var l=M(n,i);;){var s=pr(e,l,i,t,r),a=ue(l),u=a&&a.find(0,!0);if(!a||!(s.ch>u.from.ch||s.ch==u.from.ch&&s.xRel>0))return s;i=W(l=u.to.line)}}function fr(e,t,r,n){n-=nr(t);var i=t.text.length,o=k(function(t){return Yt(e,r,t-1).bottom<=n},i,0);return i=k(function(t){return Yt(e,r,t).top>n},o,i),{begin:o,end:i}}function hr(e,t,r,n){return r||(r=Xt(e,t)),fr(e,t,r,ir(e,t,Yt(e,r,n),"line").top)}function dr(e,t,r,n){return!(e.bottom<=r)&&(e.top>r||(n?e.left:e.right)>t)}function pr(e,t,r,n,i){i-=ye(t);var o=Xt(e,t),l=nr(t),s=0,a=t.text.length,u=!0,c=Se(t,e.doc.direction);if(c){var f=(e.options.lineWrapping?vr:gr)(e,t,r,o,c,n,i);s=(u=1!=f.level)?f.from:f.to-1,a=u?f.to:f.from-1}var h,d,p=null,g=null,v=k(function(t){var r=Yt(e,o,t);return r.top+=l,r.bottom+=l,!!dr(r,n,i,!1)&&(r.top<=i&&r.left<=n&&(p=t,g=r),!0)},s,a),m=!1;if(g){var y=n-g.left<g.right-n,b=y==u;v=p+(b?0:1),d=b?"after":"before",h=y?g.left:g.right}else{u||v!=a&&v!=s||v++,d=0==v?"after":v==t.text.length?"before":Yt(e,o,v-(u?1:0)).bottom+l<=i==u?"after":"before";var w=sr(e,E(r,v,d),"line",t,o);h=w.left,m=i<w.top||i>=w.bottom}return v=L(t.text,v,1),ur(r,v,d,m,n-h)}function gr(e,t,r,n,i,o,l){var s=k(function(s){var a=i[s],u=1!=a.level;return dr(sr(e,E(r,u?a.to:a.from,u?"before":"after"),"line",t,n),o,l,!0)},0,i.length-1),a=i[s];if(s>0){var u=1!=a.level,c=sr(e,E(r,u?a.from:a.to,u?"after":"before"),"line",t,n);dr(c,o,l,!0)&&c.top>l&&(a=i[s-1])}return a}function vr(e,t,r,n,i,o,l){for(var s=fr(e,t,n,l),a=s.begin,u=s.end,c=null,f=null,h=0;h<i.length;h++){var d=i[h];if(!(d.from>=u||d.to<=a)){var p=Yt(e,n,1!=d.level?Math.min(u,d.to)-1:Math.max(a,d.from)).right,g=p<o?o-p+1e9:p-o;(!c||f>g)&&(c=d,f=g)}}return c||(c=i[i.length-1]),c.from<a&&(c={from:a,to:c.to,level:c.level}),c.to>u&&(c={from:c.from,to:u,level:c.level}),c}function mr(e){if(null!=e.cachedTextHeight)return e.cachedTextHeight;if(null==hs){hs=n("pre");for(var i=0;i<49;++i)hs.appendChild(document.createTextNode("x")),hs.appendChild(n("br"));hs.appendChild(document.createTextNode("x"))}r(e.measure,hs);var o=hs.offsetHeight/50;return o>3&&(e.cachedTextHeight=o),t(e.measure),o||1}function yr(e){if(null!=e.cachedCharWidth)return e.cachedCharWidth;var t=n("span","xxxxxxxxxx"),i=n("pre",[t]);r(e.measure,i);var o=t.getBoundingClientRect(),l=(o.right-o.left)/10;return l>2&&(e.cachedCharWidth=l),l||10}function br(e){for(var t=e.display,r={},n={},i=t.gutters.clientLeft,o=t.gutters.firstChild,l=0;o;o=o.nextSibling,++l)r[e.options.gutters[l]]=o.offsetLeft+o.clientLeft+i,n[e.options.gutters[l]]=o.clientWidth;return{fixedPos:wr(t),gutterTotalWidth:t.gutters.offsetWidth,gutterLeft:r,gutterWidth:n,wrapperWidth:t.wrapper.clientWidth}}function wr(e){return e.scroller.getBoundingClientRect().left-e.sizer.getBoundingClientRect().left}function xr(e){var t=mr(e.display),r=e.options.lineWrapping,n=r&&Math.max(5,e.display.scroller.clientWidth/yr(e.display)-3);return function(i){if(ve(e.doc,i))return 0;var o=0;if(i.widgets)for(var l=0;l<i.widgets.length;l++)i.widgets[l].height&&(o+=i.widgets[l].height);return r?o+(Math.ceil(i.text.length/n)||1)*t:o+t}}function Cr(e){var t=e.doc,r=xr(e);t.iter(function(e){var t=r(e);t!=e.height&&A(e,t)})}function Sr(e,t,r,n){var i=e.display;if(!r&&"true"==Ee(t).getAttribute("cm-not-content"))return null;var o,l,s=i.lineSpace.getBoundingClientRect();try{o=t.clientX-s.left,l=t.clientY-s.top}catch(t){return null}var a,u=cr(e,o,l);if(n&&1==u.xRel&&(a=M(e.doc,u.line).text).length==u.ch){var c=f(a,a.length,e.options.tabSize)-a.length;u=E(u.line,Math.max(0,Math.round((o-It(e.display).left)/yr(e.display))-c))}return u}function Lr(e,t){if(t>=e.display.viewTo)return null;if((t-=e.display.viewFrom)<0)return null;for(var r=e.display.view,n=0;n<r.length;n++)if((t-=r[n].size)<0)return n}function kr(e){e.display.input.showSelection(e.display.input.prepareSelection())}function Tr(e,t){void 0===t&&(t=!0);for(var r=e.doc,n={},i=n.cursors=document.createDocumentFragment(),o=n.selection=document.createDocumentFragment(),l=0;l<r.sel.ranges.length;l++)if(t||l!=r.sel.primIndex){var s=r.sel.ranges[l];if(!(s.from().line>=e.display.viewTo||s.to().line<e.display.viewFrom)){var a=s.empty();(a||e.options.showCursorWhenSelecting)&&Mr(e,s.head,i),a||Or(e,s,o)}}return n}function Mr(e,t,r){var i=sr(e,t,"div",null,null,!e.options.singleCursorHeightPerLine),o=r.appendChild(n("div"," ","CodeMirror-cursor"));if(o.style.left=i.left+"px",o.style.top=i.top+"px",o.style.height=Math.max(0,i.bottom-i.top)*e.options.cursorHeight+"px",i.other){var l=r.appendChild(n("div"," ","CodeMirror-cursor CodeMirror-secondarycursor"));l.style.display="",l.style.left=i.other.left+"px",l.style.top=i.other.top+"px",l.style.height=.85*(i.other.bottom-i.other.top)+"px"}}function Nr(e,t){return e.top-t.top||e.left-t.left}function Or(e,t,r){function i(e,t,r,i){t<0&&(t=0),t=Math.round(t),i=Math.round(i),a.appendChild(n("div",null,"CodeMirror-selected","position: absolute; left: "+e+"px;\n                             top: "+t+"px; width: "+(null==r?f-e:r)+"px;\n                             height: "+(i-t)+"px"))}function o(t,r,n){function o(r,n){return lr(e,E(t,r),"div",u,n)}var l,a,u=M(s,t),h=u.text.length,d=Se(u,s.direction);return xe(d,r||0,null==n?h:n,function(t,s,p,g){var v=o(t,"ltr"==p?"left":"right"),m=o(s-1,"ltr"==p?"right":"left");if("ltr"==p){var y=null==r&&0==t?c:v.left,b=null==n&&s==h?f:m.right;m.top-v.top<=3?i(y,m.top,b-y,m.bottom):(i(y,v.top,null,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top),i(c,m.top,m.right,m.bottom))}else if(t<s){var w=null==r&&0==t?f:v.right,x=null==n&&s==h?c:m.left;if(m.top-v.top<=3)i(x,m.top,w-x,m.bottom);else{var C=c;if(g){var S=hr(e,u,null,t).end;C=o(S-(/\s/.test(u.text.charAt(S-1))?2:1),"left").left}i(C,v.top,w-C,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top);var L=null;d.length,L=o(hr(e,u,null,s).begin,"right").right-x,i(x,m.top,L,m.bottom)}}(!l||Nr(v,l)<0)&&(l=v),Nr(m,l)<0&&(l=m),(!a||Nr(v,a)<0)&&(a=v),Nr(m,a)<0&&(a=m)}),{start:l,end:a}}var l=e.display,s=e.doc,a=document.createDocumentFragment(),u=It(e.display),c=u.left,f=Math.max(l.sizerWidth,Rt(e)-l.sizer.offsetLeft)-u.right,h=t.from(),d=t.to();if(h.line==d.line)o(h.line,h.ch,d.ch);else{var p=M(s,h.line),g=M(s,d.line),v=fe(p)==fe(g),m=o(h.line,h.ch,v?p.text.length+1:null).end,y=o(d.line,v?0:null,d.ch).start;v&&(m.top<y.top-2?(i(m.right,m.top,null,m.bottom),i(c,y.top,y.left,y.bottom)):i(m.right,m.top,y.left-m.right,m.bottom)),m.bottom<y.top&&i(c,m.bottom,null,y.top)}r.appendChild(a)}function Ar(e){if(e.state.focused){var t=e.display;clearInterval(t.blinker);var r=!0;t.cursorDiv.style.visibility="",e.options.cursorBlinkRate>0?t.blinker=setInterval(function(){return t.cursorDiv.style.visibility=(r=!r)?"":"hidden"},e.options.cursorBlinkRate):e.options.cursorBlinkRate<0&&(t.cursorDiv.style.visibility="hidden")}}function Wr(e){e.state.focused||(e.display.input.focus(),Hr(e))}function Dr(e){e.state.delayingBlurEvent=!0,setTimeout(function(){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1,Fr(e))},100)}function Hr(e,t){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1),"nocursor"!=e.options.readOnly&&(e.state.focused||(Te(e,"focus",e,t),e.state.focused=!0,s(e.display.wrapper,"CodeMirror-focused"),e.curOp||e.display.selForContextMenu==e.doc.sel||(e.display.input.reset(),ml&&setTimeout(function(){return e.display.input.reset(!0)},20)),e.display.input.receivedFocus()),Ar(e))}function Fr(e,t){e.state.delayingBlurEvent||(e.state.focused&&(Te(e,"blur",e,t),e.state.focused=!1,Fl(e.display.wrapper,"CodeMirror-focused")),clearInterval(e.display.blinker),setTimeout(function(){e.state.focused||(e.display.shift=!1)},150))}function Er(e){for(var t=e.display,r=t.lineDiv.offsetTop,n=0;n<t.view.length;n++){var i=t.view[n],o=void 0;if(!i.hidden){if(gl&&vl<8){var l=i.node.offsetTop+i.node.offsetHeight;o=l-r,r=l}else{var s=i.node.getBoundingClientRect();o=s.bottom-s.top}var a=i.line.height-o;if(o<2&&(o=mr(t)),(a>.005||a<-.005)&&(A(i.line,o),Pr(i.line),i.rest))for(var u=0;u<i.rest.length;u++)Pr(i.rest[u])}}}function Pr(e){if(e.widgets)for(var t=0;t<e.widgets.length;++t)e.widgets[t].height=e.widgets[t].node.parentNode.offsetHeight}function Ir(e,t,r){var n=r&&null!=r.top?Math.max(0,r.top):e.scroller.scrollTop;n=Math.floor(n-Et(e));var i=r&&null!=r.bottom?r.bottom:n+e.wrapper.clientHeight,o=D(t,n),l=D(t,i);if(r&&r.ensure){var s=r.ensure.from.line,a=r.ensure.to.line;s<o?(o=s,l=D(t,ye(M(t,s))+e.wrapper.clientHeight)):Math.min(a,t.lastLine())>=l&&(o=D(t,ye(M(t,a))-e.wrapper.clientHeight),l=a)}return{from:o,to:Math.max(l,o+1)}}function zr(e){var t=e.display,r=t.view;if(t.alignWidgets||t.gutters.firstChild&&e.options.fixedGutter){for(var n=wr(t)-t.scroller.scrollLeft+e.doc.scrollLeft,i=t.gutters.offsetWidth,o=n+"px",l=0;l<r.length;l++)if(!r[l].hidden){e.options.fixedGutter&&(r[l].gutter&&(r[l].gutter.style.left=o),r[l].gutterBackground&&(r[l].gutterBackground.style.left=o));var s=r[l].alignable;if(s)for(var a=0;a<s.length;a++)s[a].style.left=o}e.options.fixedGutter&&(t.gutters.style.left=n+i+"px")}}function Rr(e){if(!e.options.lineNumbers)return!1;var t=e.doc,r=F(e.options,t.first+t.size-1),i=e.display;if(r.length!=i.lineNumChars){var o=i.measure.appendChild(n("div",[n("div",r)],"CodeMirror-linenumber CodeMirror-gutter-elt")),l=o.firstChild.offsetWidth,s=o.offsetWidth-l;return i.lineGutter.style.width="",i.lineNumInnerWidth=Math.max(l,i.lineGutter.offsetWidth-s)+1,i.lineNumWidth=i.lineNumInnerWidth+s,i.lineNumChars=i.lineNumInnerWidth?r.length:-1,i.lineGutter.style.width=i.lineNumWidth+"px",Wn(e),!0}return!1}function Br(e,t){if(!Me(e,"scrollCursorIntoView")){var r=e.display,i=r.sizer.getBoundingClientRect(),o=null;if(t.top+i.top<0?o=!0:t.bottom+i.top>(window.innerHeight||document.documentElement.clientHeight)&&(o=!1),null!=o&&!Sl){var l=n("div","​",null,"position: absolute;\n                         top: "+(t.top-r.viewOffset-Et(e.display))+"px;\n                         height: "+(t.bottom-t.top+zt(e)+r.barHeight)+"px;\n                         left: "+t.left+"px; width: "+Math.max(2,t.right-t.left)+"px;");e.display.lineSpace.appendChild(l),l.scrollIntoView(o),e.display.lineSpace.removeChild(l)}}}function Gr(e,t,r,n){null==n&&(n=0);var i;e.options.lineWrapping||t!=r||(r="before"==(t=t.ch?E(t.line,"before"==t.sticky?t.ch-1:t.ch,"after"):t).sticky?E(t.line,t.ch+1,"before"):t);for(var o=0;o<5;o++){var l=!1,s=sr(e,t),a=r&&r!=t?sr(e,r):s,u=Vr(e,i={left:Math.min(s.left,a.left),top:Math.min(s.top,a.top)-n,right:Math.max(s.left,a.left),bottom:Math.max(s.bottom,a.bottom)+n}),c=e.doc.scrollTop,f=e.doc.scrollLeft;if(null!=u.scrollTop&&(qr(e,u.scrollTop),Math.abs(e.doc.scrollTop-c)>1&&(l=!0)),null!=u.scrollLeft&&(Qr(e,u.scrollLeft),Math.abs(e.doc.scrollLeft-f)>1&&(l=!0)),!l)break}return i}function Ur(e,t){var r=Vr(e,t);null!=r.scrollTop&&qr(e,r.scrollTop),null!=r.scrollLeft&&Qr(e,r.scrollLeft)}function Vr(e,t){var r=e.display,n=mr(e.display);t.top<0&&(t.top=0);var i=e.curOp&&null!=e.curOp.scrollTop?e.curOp.scrollTop:r.scroller.scrollTop,o=Bt(e),l={};t.bottom-t.top>o&&(t.bottom=t.top+o);var s=e.doc.height+Pt(r),a=t.top<n,u=t.bottom>s-n;if(t.top<i)l.scrollTop=a?0:t.top;else if(t.bottom>i+o){var c=Math.min(t.top,(u?s:t.bottom)-o);c!=i&&(l.scrollTop=c)}var f=e.curOp&&null!=e.curOp.scrollLeft?e.curOp.scrollLeft:r.scroller.scrollLeft,h=Rt(e)-(e.options.fixedGutter?r.gutters.offsetWidth:0),d=t.right-t.left>h;return d&&(t.right=t.left+h),t.left<10?l.scrollLeft=0:t.left<f?l.scrollLeft=Math.max(0,t.left-(d?0:10)):t.right>h+f-3&&(l.scrollLeft=t.right+(d?0:10)-h),l}function Kr(e,t){null!=t&&(_r(e),e.curOp.scrollTop=(null==e.curOp.scrollTop?e.doc.scrollTop:e.curOp.scrollTop)+t)}function jr(e){_r(e);var t=e.getCursor();e.curOp.scrollToPos={from:t,to:t,margin:e.options.cursorScrollMargin}}function Xr(e,t,r){null==t&&null==r||_r(e),null!=t&&(e.curOp.scrollLeft=t),null!=r&&(e.curOp.scrollTop=r)}function Yr(e,t){_r(e),e.curOp.scrollToPos=t}function _r(e){var t=e.curOp.scrollToPos;t&&(e.curOp.scrollToPos=null,$r(e,ar(e,t.from),ar(e,t.to),t.margin))}function $r(e,t,r,n){var i=Vr(e,{left:Math.min(t.left,r.left),top:Math.min(t.top,r.top)-n,right:Math.max(t.right,r.right),bottom:Math.max(t.bottom,r.bottom)+n});Xr(e,i.scrollLeft,i.scrollTop)}function qr(e,t){Math.abs(e.doc.scrollTop-t)<2||(fl||On(e,{top:t}),Zr(e,t,!0),fl&&On(e),Cn(e,100))}function Zr(e,t,r){t=Math.min(e.display.scroller.scrollHeight-e.display.scroller.clientHeight,t),(e.display.scroller.scrollTop!=t||r)&&(e.doc.scrollTop=t,e.display.scrollbars.setScrollTop(t),e.display.scroller.scrollTop!=t&&(e.display.scroller.scrollTop=t))}function Qr(e,t,r,n){t=Math.min(t,e.display.scroller.scrollWidth-e.display.scroller.clientWidth),(r?t==e.doc.scrollLeft:Math.abs(e.doc.scrollLeft-t)<2)&&!n||(e.doc.scrollLeft=t,zr(e),e.display.scroller.scrollLeft!=t&&(e.display.scroller.scrollLeft=t),e.display.scrollbars.setScrollLeft(t))}function Jr(e){var t=e.display,r=t.gutters.offsetWidth,n=Math.round(e.doc.height+Pt(e.display));return{clientHeight:t.scroller.clientHeight,viewHeight:t.wrapper.clientHeight,scrollWidth:t.scroller.scrollWidth,clientWidth:t.scroller.clientWidth,viewWidth:t.wrapper.clientWidth,barLeft:e.options.fixedGutter?r:0,docHeight:n,scrollHeight:n+zt(e)+t.barHeight,nativeBarWidth:t.nativeBarWidth,gutterWidth:r}}function en(e,t){t||(t=Jr(e));var r=e.display.barWidth,n=e.display.barHeight;tn(e,t);for(var i=0;i<4&&r!=e.display.barWidth||n!=e.display.barHeight;i++)r!=e.display.barWidth&&e.options.lineWrapping&&Er(e),tn(e,Jr(e)),r=e.display.barWidth,n=e.display.barHeight}function tn(e,t){var r=e.display,n=r.scrollbars.update(t);r.sizer.style.paddingRight=(r.barWidth=n.right)+"px",r.sizer.style.paddingBottom=(r.barHeight=n.bottom)+"px",r.heightForcer.style.borderBottom=n.bottom+"px solid transparent",n.right&&n.bottom?(r.scrollbarFiller.style.display="block",r.scrollbarFiller.style.height=n.bottom+"px",r.scrollbarFiller.style.width=n.right+"px"):r.scrollbarFiller.style.display="",n.bottom&&e.options.coverGutterNextToScrollbar&&e.options.fixedGutter?(r.gutterFiller.style.display="block",r.gutterFiller.style.height=n.bottom+"px",r.gutterFiller.style.width=t.gutterWidth+"px"):r.gutterFiller.style.display=""}function rn(e){e.display.scrollbars&&(e.display.scrollbars.clear(),e.display.scrollbars.addClass&&Fl(e.display.wrapper,e.display.scrollbars.addClass)),e.display.scrollbars=new ws[e.options.scrollbarStyle](function(t){e.display.wrapper.insertBefore(t,e.display.scrollbarFiller),Ql(t,"mousedown",function(){e.state.focused&&setTimeout(function(){return e.display.input.focus()},0)}),t.setAttribute("cm-not-content","true")},function(t,r){"horizontal"==r?Qr(e,t):qr(e,t)},e),e.display.scrollbars.addClass&&s(e.display.wrapper,e.display.scrollbars.addClass)}function nn(e){e.curOp={cm:e,viewChanged:!1,startHeight:e.doc.height,forceUpdate:!1,updateInput:null,typing:!1,changeObjs:null,cursorActivityHandlers:null,cursorActivityCalled:0,selectionChanged:!1,updateMaxLine:!1,scrollLeft:null,scrollTop:null,scrollToPos:null,focus:!1,id:++xs},vt(e.curOp)}function on(e){yt(e.curOp,function(e){for(var t=0;t<e.ops.length;t++)e.ops[t].cm.curOp=null;ln(e)})}function ln(e){for(var t=e.ops,r=0;r<t.length;r++)sn(t[r]);for(var n=0;n<t.length;n++)an(t[n]);for(var i=0;i<t.length;i++)un(t[i]);for(var o=0;o<t.length;o++)cn(t[o]);for(var l=0;l<t.length;l++)fn(t[l])}function sn(e){var t=e.cm,r=t.display;Ln(t),e.updateMaxLine&&we(t),e.mustUpdate=e.viewChanged||e.forceUpdate||null!=e.scrollTop||e.scrollToPos&&(e.scrollToPos.from.line<r.viewFrom||e.scrollToPos.to.line>=r.viewTo)||r.maxLineChanged&&t.options.lineWrapping,e.update=e.mustUpdate&&new Cs(t,e.mustUpdate&&{top:e.scrollTop,ensure:e.scrollToPos},e.forceUpdate)}function an(e){e.updatedDisplay=e.mustUpdate&&Mn(e.cm,e.update)}function un(e){var t=e.cm,r=t.display;e.updatedDisplay&&Er(t),e.barMeasure=Jr(t),r.maxLineChanged&&!t.options.lineWrapping&&(e.adjustWidthTo=Kt(t,r.maxLine,r.maxLine.text.length).left+3,t.display.sizerWidth=e.adjustWidthTo,e.barMeasure.scrollWidth=Math.max(r.scroller.clientWidth,r.sizer.offsetLeft+e.adjustWidthTo+zt(t)+t.display.barWidth),e.maxScrollLeft=Math.max(0,r.sizer.offsetLeft+e.adjustWidthTo-Rt(t))),(e.updatedDisplay||e.selectionChanged)&&(e.preparedSelection=r.input.prepareSelection())}function cn(e){var t=e.cm;null!=e.adjustWidthTo&&(t.display.sizer.style.minWidth=e.adjustWidthTo+"px",e.maxScrollLeft<t.doc.scrollLeft&&Qr(t,Math.min(t.display.scroller.scrollLeft,e.maxScrollLeft),!0),t.display.maxLineChanged=!1);var r=e.focus&&e.focus==l();e.preparedSelection&&t.display.input.showSelection(e.preparedSelection,r),(e.updatedDisplay||e.startHeight!=t.doc.height)&&en(t,e.barMeasure),e.updatedDisplay&&Dn(t,e.barMeasure),e.selectionChanged&&Ar(t),t.state.focused&&e.updateInput&&t.display.input.reset(e.typing),r&&Wr(e.cm)}function fn(e){var t=e.cm,r=t.display,n=t.doc;e.updatedDisplay&&Nn(t,e.update),null==r.wheelStartX||null==e.scrollTop&&null==e.scrollLeft&&!e.scrollToPos||(r.wheelStartX=r.wheelStartY=null),null!=e.scrollTop&&Zr(t,e.scrollTop,e.forceScroll),null!=e.scrollLeft&&Qr(t,e.scrollLeft,!0,!0),e.scrollToPos&&Br(t,Gr(t,U(n,e.scrollToPos.from),U(n,e.scrollToPos.to),e.scrollToPos.margin));var i=e.maybeHiddenMarkers,o=e.maybeUnhiddenMarkers;if(i)for(var l=0;l<i.length;++l)i[l].lines.length||Te(i[l],"hide");if(o)for(var s=0;s<o.length;++s)o[s].lines.length&&Te(o[s],"unhide");r.wrapper.offsetHeight&&(n.scrollTop=t.display.scroller.scrollTop),e.changeObjs&&Te(t,"changes",t,e.changeObjs),e.update&&e.update.finish()}function hn(e,t){if(e.curOp)return t();nn(e);try{return t()}finally{on(e)}}function dn(e,t){return function(){if(e.curOp)return t.apply(e,arguments);nn(e);try{return t.apply(e,arguments)}finally{on(e)}}}function pn(e){return function(){if(this.curOp)return e.apply(this,arguments);nn(this);try{return e.apply(this,arguments)}finally{on(this)}}}function gn(e){return function(){var t=this.cm;if(!t||t.curOp)return e.apply(this,arguments);nn(t);try{return e.apply(this,arguments)}finally{on(t)}}}function vn(e,t,r,n){null==t&&(t=e.doc.first),null==r&&(r=e.doc.first+e.doc.size),n||(n=0);var i=e.display;if(n&&r<i.viewTo&&(null==i.updateLineNumbers||i.updateLineNumbers>t)&&(i.updateLineNumbers=t),e.curOp.viewChanged=!0,t>=i.viewTo)_l&&pe(e.doc,t)<i.viewTo&&yn(e);else if(r<=i.viewFrom)_l&&ge(e.doc,r+n)>i.viewFrom?yn(e):(i.viewFrom+=n,i.viewTo+=n);else if(t<=i.viewFrom&&r>=i.viewTo)yn(e);else if(t<=i.viewFrom){var o=bn(e,r,r+n,1);o?(i.view=i.view.slice(o.index),i.viewFrom=o.lineN,i.viewTo+=n):yn(e)}else if(r>=i.viewTo){var l=bn(e,t,t,-1);l?(i.view=i.view.slice(0,l.index),i.viewTo=l.lineN):yn(e)}else{var s=bn(e,t,t,-1),a=bn(e,r,r+n,1);s&&a?(i.view=i.view.slice(0,s.index).concat(gt(e,s.lineN,a.lineN)).concat(i.view.slice(a.index)),i.viewTo+=n):yn(e)}var u=i.externalMeasured;u&&(r<u.lineN?u.lineN+=n:t<u.lineN+u.size&&(i.externalMeasured=null))}function mn(e,t,r){e.curOp.viewChanged=!0;var n=e.display,i=e.display.externalMeasured;if(i&&t>=i.lineN&&t<i.lineN+i.size&&(n.externalMeasured=null),!(t<n.viewFrom||t>=n.viewTo)){var o=n.view[Lr(e,t)];if(null!=o.node){var l=o.changes||(o.changes=[]);-1==h(l,r)&&l.push(r)}}}function yn(e){e.display.viewFrom=e.display.viewTo=e.doc.first,e.display.view=[],e.display.viewOffset=0}function bn(e,t,r,n){var i,o=Lr(e,t),l=e.display.view;if(!_l||r==e.doc.first+e.doc.size)return{index:o,lineN:r};for(var s=e.display.viewFrom,a=0;a<o;a++)s+=l[a].size;if(s!=t){if(n>0){if(o==l.length-1)return null;i=s+l[o].size-t,o++}else i=s-t;t+=i,r+=i}for(;pe(e.doc,r)!=r;){if(o==(n<0?0:l.length-1))return null;r+=n*l[o-(n<0?1:0)].size,o+=n}return{index:o,lineN:r}}function wn(e,t,r){var n=e.display;0==n.view.length||t>=n.viewTo||r<=n.viewFrom?(n.view=gt(e,t,r),n.viewFrom=t):(n.viewFrom>t?n.view=gt(e,t,n.viewFrom).concat(n.view):n.viewFrom<t&&(n.view=n.view.slice(Lr(e,t))),n.viewFrom=t,n.viewTo<r?n.view=n.view.concat(gt(e,n.viewTo,r)):n.viewTo>r&&(n.view=n.view.slice(0,Lr(e,r)))),n.viewTo=r}function xn(e){for(var t=e.display.view,r=0,n=0;n<t.length;n++){var i=t[n];i.hidden||i.node&&!i.changes||++r}return r}function Cn(e,t){e.doc.highlightFrontier<e.display.viewTo&&e.state.highlight.set(t,u(Sn,e))}function Sn(e){var t=e.doc;if(!(t.highlightFrontier>=e.display.viewTo)){var r=+new Date+e.options.workTime,n=$e(e,t.highlightFrontier),i=[];t.iter(n.line,Math.min(t.first+t.size,e.display.viewTo+500),function(o){if(n.line>=e.display.viewFrom){var l=o.styles,s=o.text.length>e.options.maxHighlightLength?Ke(t.mode,n.state):null,a=Ye(e,o,n,!0);s&&(n.state=s),o.styles=a.styles;var u=o.styleClasses,c=a.classes;c?o.styleClasses=c:u&&(o.styleClasses=null);for(var f=!l||l.length!=o.styles.length||u!=c&&(!u||!c||u.bgClass!=c.bgClass||u.textClass!=c.textClass),h=0;!f&&h<l.length;++h)f=l[h]!=o.styles[h];f&&i.push(n.line),o.stateAfter=n.save(),n.nextLine()}else o.text.length<=e.options.maxHighlightLength&&qe(e,o.text,n),o.stateAfter=n.line%5==0?n.save():null,n.nextLine();if(+new Date>r)return Cn(e,e.options.workDelay),!0}),t.highlightFrontier=n.line,t.modeFrontier=Math.max(t.modeFrontier,n.line),i.length&&hn(e,function(){for(var t=0;t<i.length;t++)mn(e,i[t],"text")})}}function Ln(e){var t=e.display;!t.scrollbarsClipped&&t.scroller.offsetWidth&&(t.nativeBarWidth=t.scroller.offsetWidth-t.scroller.clientWidth,t.heightForcer.style.height=zt(e)+"px",t.sizer.style.marginBottom=-t.nativeBarWidth+"px",t.sizer.style.borderRightWidth=zt(e)+"px",t.scrollbarsClipped=!0)}function kn(e){if(e.hasFocus())return null;var t=l();if(!t||!o(e.display.lineDiv,t))return null;var r={activeElt:t};if(window.getSelection){var n=window.getSelection();n.anchorNode&&n.extend&&o(e.display.lineDiv,n.anchorNode)&&(r.anchorNode=n.anchorNode,r.anchorOffset=n.anchorOffset,r.focusNode=n.focusNode,r.focusOffset=n.focusOffset)}return r}function Tn(e){if(e&&e.activeElt&&e.activeElt!=l()&&(e.activeElt.focus(),e.anchorNode&&o(document.body,e.anchorNode)&&o(document.body,e.focusNode))){var t=window.getSelection(),r=document.createRange();r.setEnd(e.anchorNode,e.anchorOffset),r.collapse(!1),t.removeAllRanges(),t.addRange(r),t.extend(e.focusNode,e.focusOffset)}}function Mn(e,r){var n=e.display,i=e.doc;if(r.editorIsHidden)return yn(e),!1;if(!r.force&&r.visible.from>=n.viewFrom&&r.visible.to<=n.viewTo&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo)&&n.renderedView==n.view&&0==xn(e))return!1;Rr(e)&&(yn(e),r.dims=br(e));var o=i.first+i.size,l=Math.max(r.visible.from-e.options.viewportMargin,i.first),s=Math.min(o,r.visible.to+e.options.viewportMargin);n.viewFrom<l&&l-n.viewFrom<20&&(l=Math.max(i.first,n.viewFrom)),n.viewTo>s&&n.viewTo-s<20&&(s=Math.min(o,n.viewTo)),_l&&(l=pe(e.doc,l),s=ge(e.doc,s));var a=l!=n.viewFrom||s!=n.viewTo||n.lastWrapHeight!=r.wrapperHeight||n.lastWrapWidth!=r.wrapperWidth;wn(e,l,s),n.viewOffset=ye(M(e.doc,n.viewFrom)),e.display.mover.style.top=n.viewOffset+"px";var u=xn(e);if(!a&&0==u&&!r.force&&n.renderedView==n.view&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo))return!1;var c=kn(e);return u>4&&(n.lineDiv.style.display="none"),An(e,n.updateLineNumbers,r.dims),u>4&&(n.lineDiv.style.display=""),n.renderedView=n.view,Tn(c),t(n.cursorDiv),t(n.selectionDiv),n.gutters.style.height=n.sizer.style.minHeight=0,a&&(n.lastWrapHeight=r.wrapperHeight,n.lastWrapWidth=r.wrapperWidth,Cn(e,400)),n.updateLineNumbers=null,!0}function Nn(e,t){for(var r=t.viewport,n=!0;(n&&e.options.lineWrapping&&t.oldDisplayWidth!=Rt(e)||(r&&null!=r.top&&(r={top:Math.min(e.doc.height+Pt(e.display)-Bt(e),r.top)}),t.visible=Ir(e.display,e.doc,r),!(t.visible.from>=e.display.viewFrom&&t.visible.to<=e.display.viewTo)))&&Mn(e,t);n=!1){Er(e);var i=Jr(e);kr(e),en(e,i),Dn(e,i),t.force=!1}t.signal(e,"update",e),e.display.viewFrom==e.display.reportedViewFrom&&e.display.viewTo==e.display.reportedViewTo||(t.signal(e,"viewportChange",e,e.display.viewFrom,e.display.viewTo),e.display.reportedViewFrom=e.display.viewFrom,e.display.reportedViewTo=e.display.viewTo)}function On(e,t){var r=new Cs(e,t);if(Mn(e,r)){Er(e),Nn(e,r);var n=Jr(e);kr(e),en(e,n),Dn(e,n),r.finish()}}function An(e,r,n){function i(t){var r=t.nextSibling;return ml&&Ml&&e.display.currentWheelTarget==t?t.style.display="none":t.parentNode.removeChild(t),r}for(var o=e.display,l=e.options.lineNumbers,s=o.lineDiv,a=s.firstChild,u=o.view,c=o.viewFrom,f=0;f<u.length;f++){var d=u[f];if(d.hidden);else if(d.node&&d.node.parentNode==s){for(;a!=d.node;)a=i(a);var p=l&&null!=r&&r<=c&&d.lineNumber;d.changes&&(h(d.changes,"gutter")>-1&&(p=!1),xt(e,d,c,n)),p&&(t(d.lineNumber),d.lineNumber.appendChild(document.createTextNode(F(e.options,c)))),a=d.node.nextSibling}else{var g=Ot(e,d,c,n);s.insertBefore(g,a)}c+=d.size}for(;a;)a=i(a)}function Wn(e){var t=e.display.gutters.offsetWidth;e.display.sizer.style.marginLeft=t+"px"}function Dn(e,t){e.display.sizer.style.minHeight=t.docHeight+"px",e.display.heightForcer.style.top=t.docHeight+"px",e.display.gutters.style.height=t.docHeight+e.display.barHeight+zt(e)+"px"}function Hn(e){var r=e.display.gutters,i=e.options.gutters;t(r);for(var o=0;o<i.length;++o){var l=i[o],s=r.appendChild(n("div",null,"CodeMirror-gutter "+l));"CodeMirror-linenumbers"==l&&(e.display.lineGutter=s,s.style.width=(e.display.lineNumWidth||1)+"px")}r.style.display=o?"":"none",Wn(e)}function Fn(e){var t=h(e.gutters,"CodeMirror-linenumbers");-1==t&&e.lineNumbers?e.gutters=e.gutters.concat(["CodeMirror-linenumbers"]):t>-1&&!e.lineNumbers&&(e.gutters=e.gutters.slice(0),e.gutters.splice(t,1))}function En(e){var t=e.wheelDeltaX,r=e.wheelDeltaY;return null==t&&e.detail&&e.axis==e.HORIZONTAL_AXIS&&(t=e.detail),null==r&&e.detail&&e.axis==e.VERTICAL_AXIS?r=e.detail:null==r&&(r=e.wheelDelta),{x:t,y:r}}function Pn(e){var t=En(e);return t.x*=Ls,t.y*=Ls,t}function In(e,t){var r=En(t),n=r.x,i=r.y,o=e.display,l=o.scroller,s=l.scrollWidth>l.clientWidth,a=l.scrollHeight>l.clientHeight;if(n&&s||i&&a){if(i&&Ml&&ml)e:for(var u=t.target,c=o.view;u!=l;u=u.parentNode)for(var f=0;f<c.length;f++)if(c[f].node==u){e.display.currentWheelTarget=u;break e}if(n&&!fl&&!wl&&null!=Ls)return i&&a&&qr(e,Math.max(0,l.scrollTop+i*Ls)),Qr(e,Math.max(0,l.scrollLeft+n*Ls)),(!i||i&&a)&&We(t),void(o.wheelStartX=null);if(i&&null!=Ls){var h=i*Ls,d=e.doc.scrollTop,p=d+o.wrapper.clientHeight;h<0?d=Math.max(0,d+h-50):p=Math.min(e.doc.height,p+h+50),On(e,{top:d,bottom:p})}Ss<20&&(null==o.wheelStartX?(o.wheelStartX=l.scrollLeft,o.wheelStartY=l.scrollTop,o.wheelDX=n,o.wheelDY=i,setTimeout(function(){if(null!=o.wheelStartX){var e=l.scrollLeft-o.wheelStartX,t=l.scrollTop-o.wheelStartY,r=t&&o.wheelDY&&t/o.wheelDY||e&&o.wheelDX&&e/o.wheelDX;o.wheelStartX=o.wheelStartY=null,r&&(Ls=(Ls*Ss+r)/(Ss+1),++Ss)}},200)):(o.wheelDX+=n,o.wheelDY+=i))}}function zn(e,t){var r=e[t];e.sort(function(e,t){return P(e.from(),t.from())}),t=h(e,r);for(var n=1;n<e.length;n++){var i=e[n],o=e[n-1];if(P(o.to(),i.from())>=0){var l=B(o.from(),i.from()),s=R(o.to(),i.to()),a=o.empty()?i.from()==i.head:o.from()==o.head;n<=t&&--t,e.splice(--n,2,new Ts(a?s:l,a?l:s))}}return new ks(e,t)}function Rn(e,t){return new ks([new Ts(e,t||e)],0)}function Bn(e){return e.text?E(e.from.line+e.text.length-1,g(e.text).length+(1==e.text.length?e.from.ch:0)):e.to}function Gn(e,t){if(P(e,t.from)<0)return e;if(P(e,t.to)<=0)return Bn(t);var r=e.line+t.text.length-(t.to.line-t.from.line)-1,n=e.ch;return e.line==t.to.line&&(n+=Bn(t).ch-t.to.ch),E(r,n)}function Un(e,t){for(var r=[],n=0;n<e.sel.ranges.length;n++){var i=e.sel.ranges[n];r.push(new Ts(Gn(i.anchor,t),Gn(i.head,t)))}return zn(r,e.sel.primIndex)}function Vn(e,t,r){return e.line==t.line?E(r.line,e.ch-t.ch+r.ch):E(r.line+(e.line-t.line),e.ch)}function Kn(e,t,r){for(var n=[],i=E(e.first,0),o=i,l=0;l<t.length;l++){var s=t[l],a=Vn(s.from,i,o),u=Vn(Bn(s),i,o);if(i=s.to,o=u,"around"==r){var c=e.sel.ranges[l],f=P(c.head,c.anchor)<0;n[l]=new Ts(f?u:a,f?a:u)}else n[l]=new Ts(a,a)}return new ks(n,e.sel.primIndex)}function jn(e){e.doc.mode=Ue(e.options,e.doc.modeOption),Xn(e)}function Xn(e){e.doc.iter(function(e){e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null)}),e.doc.modeFrontier=e.doc.highlightFrontier=e.doc.first,Cn(e,100),e.state.modeGen++,e.curOp&&vn(e)}function Yn(e,t){return 0==t.from.ch&&0==t.to.ch&&""==g(t.text)&&(!e.cm||e.cm.options.wholeLineUpdateBefore)}function _n(e,t,r,n){function i(e){return r?r[e]:null}function o(e,r,i){it(e,r,i,n),bt(e,"change",e,t)}function l(e,t){for(var r=[],o=e;o<t;++o)r.push(new fs(u[o],i(o),n));return r}var s=t.from,a=t.to,u=t.text,c=M(e,s.line),f=M(e,a.line),h=g(u),d=i(u.length-1),p=a.line-s.line;if(t.full)e.insert(0,l(0,u.length)),e.remove(u.length,e.size-u.length);else if(Yn(e,t)){var v=l(0,u.length-1);o(f,f.text,d),p&&e.remove(s.line,p),v.length&&e.insert(s.line,v)}else if(c==f)if(1==u.length)o(c,c.text.slice(0,s.ch)+h+c.text.slice(a.ch),d);else{var m=l(1,u.length-1);m.push(new fs(h+c.text.slice(a.ch),d,n)),o(c,c.text.slice(0,s.ch)+u[0],i(0)),e.insert(s.line+1,m)}else if(1==u.length)o(c,c.text.slice(0,s.ch)+u[0]+f.text.slice(a.ch),i(0)),e.remove(s.line+1,p);else{o(c,c.text.slice(0,s.ch)+u[0],i(0)),o(f,h+f.text.slice(a.ch),d);var y=l(1,u.length-1);p>1&&e.remove(s.line+1,p-1),e.insert(s.line+1,y)}bt(e,"change",e,t)}function $n(e,t,r){function n(e,i,o){if(e.linked)for(var l=0;l<e.linked.length;++l){var s=e.linked[l];if(s.doc!=i){var a=o&&s.sharedHist;r&&!a||(t(s.doc,a),n(s.doc,e,a))}}}n(e,null,!0)}function qn(e,t){if(t.cm)throw new Error("This document is already in use.");e.doc=t,t.cm=e,Cr(e),jn(e),Zn(e),e.options.lineWrapping||we(e),e.options.mode=t.modeOption,vn(e)}function Zn(e){("rtl"==e.doc.direction?s:Fl)(e.display.lineDiv,"CodeMirror-rtl")}function Qn(e){hn(e,function(){Zn(e),vn(e)})}function Jn(e){this.done=[],this.undone=[],this.undoDepth=1/0,this.lastModTime=this.lastSelTime=0,this.lastOp=this.lastSelOp=null,this.lastOrigin=this.lastSelOrigin=null,this.generation=this.maxGeneration=e||1}function ei(e,t){var r={from:z(t.from),to:Bn(t),text:N(e,t.from,t.to)};return si(e,r,t.from.line,t.to.line+1),$n(e,function(e){return si(e,r,t.from.line,t.to.line+1)},!0),r}function ti(e){for(;e.length&&g(e).ranges;)e.pop()}function ri(e,t){return t?(ti(e.done),g(e.done)):e.done.length&&!g(e.done).ranges?g(e.done):e.done.length>1&&!e.done[e.done.length-2].ranges?(e.done.pop(),g(e.done)):void 0}function ni(e,t,r,n){var i=e.history;i.undone.length=0;var o,l,s=+new Date;if((i.lastOp==n||i.lastOrigin==t.origin&&t.origin&&("+"==t.origin.charAt(0)&&e.cm&&i.lastModTime>s-e.cm.options.historyEventDelay||"*"==t.origin.charAt(0)))&&(o=ri(i,i.lastOp==n)))l=g(o.changes),0==P(t.from,t.to)&&0==P(t.from,l.to)?l.to=Bn(t):o.changes.push(ei(e,t));else{var a=g(i.done);for(a&&a.ranges||li(e.sel,i.done),o={changes:[ei(e,t)],generation:i.generation},i.done.push(o);i.done.length>i.undoDepth;)i.done.shift(),i.done[0].ranges||i.done.shift()}i.done.push(r),i.generation=++i.maxGeneration,i.lastModTime=i.lastSelTime=s,i.lastOp=i.lastSelOp=n,i.lastOrigin=i.lastSelOrigin=t.origin,l||Te(e,"historyAdded")}function ii(e,t,r,n){var i=t.charAt(0);return"*"==i||"+"==i&&r.ranges.length==n.ranges.length&&r.somethingSelected()==n.somethingSelected()&&new Date-e.history.lastSelTime<=(e.cm?e.cm.options.historyEventDelay:500)}function oi(e,t,r,n){var i=e.history,o=n&&n.origin;r==i.lastSelOp||o&&i.lastSelOrigin==o&&(i.lastModTime==i.lastSelTime&&i.lastOrigin==o||ii(e,o,g(i.done),t))?i.done[i.done.length-1]=t:li(t,i.done),i.lastSelTime=+new Date,i.lastSelOrigin=o,i.lastSelOp=r,n&&!1!==n.clearRedo&&ti(i.undone)}function li(e,t){var r=g(t);r&&r.ranges&&r.equals(e)||t.push(e)}function si(e,t,r,n){var i=t["spans_"+e.id],o=0;e.iter(Math.max(e.first,r),Math.min(e.first+e.size,n),function(r){r.markedSpans&&((i||(i=t["spans_"+e.id]={}))[o]=r.markedSpans),++o})}function ai(e){if(!e)return null;for(var t,r=0;r<e.length;++r)e[r].marker.explicitlyCleared?t||(t=e.slice(0,r)):t&&t.push(e[r]);return t?t.length?t:null:e}function ui(e,t){var r=t["spans_"+e.id];if(!r)return null;for(var n=[],i=0;i<t.text.length;++i)n.push(ai(r[i]));return n}function ci(e,t){var r=ui(e,t),n=J(e,t);if(!r)return n;if(!n)return r;for(var i=0;i<r.length;++i){var o=r[i],l=n[i];if(o&&l)e:for(var s=0;s<l.length;++s){for(var a=l[s],u=0;u<o.length;++u)if(o[u].marker==a.marker)continue e;o.push(a)}else l&&(r[i]=l)}return r}function fi(e,t,r){for(var n=[],i=0;i<e.length;++i){var o=e[i];if(o.ranges)n.push(r?ks.prototype.deepCopy.call(o):o);else{var l=o.changes,s=[];n.push({changes:s});for(var a=0;a<l.length;++a){var u=l[a],c=void 0;if(s.push({from:u.from,to:u.to,text:u.text}),t)for(var f in u)(c=f.match(/^spans_(\d+)$/))&&h(t,Number(c[1]))>-1&&(g(s)[f]=u[f],delete u[f])}}}return n}function hi(e,t,r,n){if(n){var i=e.anchor;if(r){var o=P(t,i)<0;o!=P(r,i)<0?(i=t,t=r):o!=P(t,r)<0&&(t=r)}return new Ts(i,t)}return new Ts(r||t,t)}function di(e,t,r,n,i){null==i&&(i=e.cm&&(e.cm.display.shift||e.extend)),bi(e,new ks([hi(e.sel.primary(),t,r,i)],0),n)}function pi(e,t,r){for(var n=[],i=e.cm&&(e.cm.display.shift||e.extend),o=0;o<e.sel.ranges.length;o++)n[o]=hi(e.sel.ranges[o],t[o],null,i);bi(e,zn(n,e.sel.primIndex),r)}function gi(e,t,r,n){var i=e.sel.ranges.slice(0);i[t]=r,bi(e,zn(i,e.sel.primIndex),n)}function vi(e,t,r,n){bi(e,Rn(t,r),n)}function mi(e,t,r){var n={ranges:t.ranges,update:function(t){var r=this;this.ranges=[];for(var n=0;n<t.length;n++)r.ranges[n]=new Ts(U(e,t[n].anchor),U(e,t[n].head))},origin:r&&r.origin};return Te(e,"beforeSelectionChange",e,n),e.cm&&Te(e.cm,"beforeSelectionChange",e.cm,n),n.ranges!=t.ranges?zn(n.ranges,n.ranges.length-1):t}function yi(e,t,r){var n=e.history.done,i=g(n);i&&i.ranges?(n[n.length-1]=t,wi(e,t,r)):bi(e,t,r)}function bi(e,t,r){wi(e,t,r),oi(e,e.sel,e.cm?e.cm.curOp.id:NaN,r)}function wi(e,t,r){(Oe(e,"beforeSelectionChange")||e.cm&&Oe(e.cm,"beforeSelectionChange"))&&(t=mi(e,t,r)),xi(e,Si(e,t,r&&r.bias||(P(t.primary().head,e.sel.primary().head)<0?-1:1),!0)),r&&!1===r.scroll||!e.cm||jr(e.cm)}function xi(e,t){t.equals(e.sel)||(e.sel=t,e.cm&&(e.cm.curOp.updateInput=e.cm.curOp.selectionChanged=!0,Ne(e.cm)),bt(e,"cursorActivity",e))}function Ci(e){xi(e,Si(e,e.sel,null,!1))}function Si(e,t,r,n){for(var i,o=0;o<t.ranges.length;o++){var l=t.ranges[o],s=t.ranges.length==e.sel.ranges.length&&e.sel.ranges[o],a=ki(e,l.anchor,s&&s.anchor,r,n),u=ki(e,l.head,s&&s.head,r,n);(i||a!=l.anchor||u!=l.head)&&(i||(i=t.ranges.slice(0,o)),i[o]=new Ts(a,u))}return i?zn(i,t.primIndex):t}function Li(e,t,r,n,i){var o=M(e,t.line);if(o.markedSpans)for(var l=0;l<o.markedSpans.length;++l){var s=o.markedSpans[l],a=s.marker;if((null==s.from||(a.inclusiveLeft?s.from<=t.ch:s.from<t.ch))&&(null==s.to||(a.inclusiveRight?s.to>=t.ch:s.to>t.ch))){if(i&&(Te(a,"beforeCursorEnter"),a.explicitlyCleared)){if(o.markedSpans){--l;continue}break}if(!a.atomic)continue;if(r){var u=a.find(n<0?1:-1),c=void 0;if((n<0?a.inclusiveRight:a.inclusiveLeft)&&(u=Ti(e,u,-n,u&&u.line==t.line?o:null)),u&&u.line==t.line&&(c=P(u,r))&&(n<0?c<0:c>0))return Li(e,u,t,n,i)}var f=a.find(n<0?-1:1);return(n<0?a.inclusiveLeft:a.inclusiveRight)&&(f=Ti(e,f,n,f.line==t.line?o:null)),f?Li(e,f,t,n,i):null}}return t}function ki(e,t,r,n,i){var o=n||1,l=Li(e,t,r,o,i)||!i&&Li(e,t,r,o,!0)||Li(e,t,r,-o,i)||!i&&Li(e,t,r,-o,!0);return l||(e.cantEdit=!0,E(e.first,0))}function Ti(e,t,r,n){return r<0&&0==t.ch?t.line>e.first?U(e,E(t.line-1)):null:r>0&&t.ch==(n||M(e,t.line)).text.length?t.line<e.first+e.size-1?E(t.line+1,0):null:new E(t.line,t.ch+r)}function Mi(e){e.setSelection(E(e.firstLine(),0),E(e.lastLine()),Gl)}function Ni(e,t,r){var n={canceled:!1,from:t.from,to:t.to,text:t.text,origin:t.origin,cancel:function(){return n.canceled=!0}};return r&&(n.update=function(t,r,i,o){t&&(n.from=U(e,t)),r&&(n.to=U(e,r)),i&&(n.text=i),void 0!==o&&(n.origin=o)}),Te(e,"beforeChange",e,n),e.cm&&Te(e.cm,"beforeChange",e.cm,n),n.canceled?null:{from:n.from,to:n.to,text:n.text,origin:n.origin}}function Oi(e,t,r){if(e.cm){if(!e.cm.curOp)return dn(e.cm,Oi)(e,t,r);if(e.cm.state.suppressEdits)return}if(!(Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"))||(t=Ni(e,t,!0))){var n=Yl&&!r&&te(e,t.from,t.to);if(n)for(var i=n.length-1;i>=0;--i)Ai(e,{from:n[i].from,to:n[i].to,text:i?[""]:t.text,origin:t.origin});else Ai(e,t)}}function Ai(e,t){if(1!=t.text.length||""!=t.text[0]||0!=P(t.from,t.to)){var r=Un(e,t);ni(e,t,r,e.cm?e.cm.curOp.id:NaN),Hi(e,t,r,J(e,t));var n=[];$n(e,function(e,r){r||-1!=h(n,e.history)||(zi(e.history,t),n.push(e.history)),Hi(e,t,null,J(e,t))})}}function Wi(e,t,r){if(!e.cm||!e.cm.state.suppressEdits||r){for(var n,i=e.history,o=e.sel,l="undo"==t?i.done:i.undone,s="undo"==t?i.undone:i.done,a=0;a<l.length&&(n=l[a],r?!n.ranges||n.equals(e.sel):n.ranges);a++);if(a!=l.length){for(i.lastOrigin=i.lastSelOrigin=null;(n=l.pop()).ranges;){if(li(n,s),r&&!n.equals(e.sel))return void bi(e,n,{clearRedo:!1});o=n}var u=[];li(o,s),s.push({changes:u,generation:i.generation}),i.generation=n.generation||++i.maxGeneration;for(var c=Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"),f=n.changes.length-1;f>=0;--f){var d=function(r){var i=n.changes[r];if(i.origin=t,c&&!Ni(e,i,!1))return l.length=0,{};u.push(ei(e,i));var o=r?Un(e,i):g(l);Hi(e,i,o,ci(e,i)),!r&&e.cm&&e.cm.scrollIntoView({from:i.from,to:Bn(i)});var s=[];$n(e,function(e,t){t||-1!=h(s,e.history)||(zi(e.history,i),s.push(e.history)),Hi(e,i,null,ci(e,i))})}(f);if(d)return d.v}}}}function Di(e,t){if(0!=t&&(e.first+=t,e.sel=new ks(v(e.sel.ranges,function(e){return new Ts(E(e.anchor.line+t,e.anchor.ch),E(e.head.line+t,e.head.ch))}),e.sel.primIndex),e.cm)){vn(e.cm,e.first,e.first-t,t);for(var r=e.cm.display,n=r.viewFrom;n<r.viewTo;n++)mn(e.cm,n,"gutter")}}function Hi(e,t,r,n){if(e.cm&&!e.cm.curOp)return dn(e.cm,Hi)(e,t,r,n);if(t.to.line<e.first)Di(e,t.text.length-1-(t.to.line-t.from.line));else if(!(t.from.line>e.lastLine())){if(t.from.line<e.first){var i=t.text.length-1-(e.first-t.from.line);Di(e,i),t={from:E(e.first,0),to:E(t.to.line+i,t.to.ch),text:[g(t.text)],origin:t.origin}}var o=e.lastLine();t.to.line>o&&(t={from:t.from,to:E(o,M(e,o).text.length),text:[t.text[0]],origin:t.origin}),t.removed=N(e,t.from,t.to),r||(r=Un(e,t)),e.cm?Fi(e.cm,t,n):_n(e,t,n),wi(e,r,Gl)}}function Fi(e,t,r){var n=e.doc,i=e.display,o=t.from,l=t.to,s=!1,a=o.line;e.options.lineWrapping||(a=W(fe(M(n,o.line))),n.iter(a,l.line+1,function(e){if(e==i.maxLine)return s=!0,!0})),n.sel.contains(t.from,t.to)>-1&&Ne(e),_n(n,t,r,xr(e)),e.options.lineWrapping||(n.iter(a,o.line+t.text.length,function(e){var t=be(e);t>i.maxLineLength&&(i.maxLine=e,i.maxLineLength=t,i.maxLineChanged=!0,s=!1)}),s&&(e.curOp.updateMaxLine=!0)),nt(n,o.line),Cn(e,400);var u=t.text.length-(l.line-o.line)-1;t.full?vn(e):o.line!=l.line||1!=t.text.length||Yn(e.doc,t)?vn(e,o.line,l.line+1,u):mn(e,o.line,"text");var c=Oe(e,"changes"),f=Oe(e,"change");if(f||c){var h={from:o,to:l,text:t.text,removed:t.removed,origin:t.origin};f&&bt(e,"change",e,h),c&&(e.curOp.changeObjs||(e.curOp.changeObjs=[])).push(h)}e.display.selForContextMenu=null}function Ei(e,t,r,n,i){if(n||(n=r),P(n,r)<0){var o;r=(o=[n,r])[0],n=o[1]}"string"==typeof t&&(t=e.splitLines(t)),Oi(e,{from:r,to:n,text:t,origin:i})}function Pi(e,t,r,n){r<e.line?e.line+=n:t<e.line&&(e.line=t,e.ch=0)}function Ii(e,t,r,n){for(var i=0;i<e.length;++i){var o=e[i],l=!0;if(o.ranges){o.copied||((o=e[i]=o.deepCopy()).copied=!0);for(var s=0;s<o.ranges.length;s++)Pi(o.ranges[s].anchor,t,r,n),Pi(o.ranges[s].head,t,r,n)}else{for(var a=0;a<o.changes.length;++a){var u=o.changes[a];if(r<u.from.line)u.from=E(u.from.line+n,u.from.ch),u.to=E(u.to.line+n,u.to.ch);else if(t<=u.to.line){l=!1;break}}l||(e.splice(0,i+1),i=0)}}}function zi(e,t){var r=t.from.line,n=t.to.line,i=t.text.length-(n-r)-1;Ii(e.done,r,n,i),Ii(e.undone,r,n,i)}function Ri(e,t,r,n){var i=t,o=t;return"number"==typeof t?o=M(e,G(e,t)):i=W(t),null==i?null:(n(o,i)&&e.cm&&mn(e.cm,i,r),o)}function Bi(e){var t=this;this.lines=e,this.parent=null;for(var r=0,n=0;n<e.length;++n)e[n].parent=t,r+=e[n].height;this.height=r}function Gi(e){var t=this;this.children=e;for(var r=0,n=0,i=0;i<e.length;++i){var o=e[i];r+=o.chunkSize(),n+=o.height,o.parent=t}this.size=r,this.height=n,this.parent=null}function Ui(e,t,r){ye(t)<(e.curOp&&e.curOp.scrollTop||e.doc.scrollTop)&&Kr(e,r)}function Vi(e,t,r,n){var i=new Ms(e,r,n),o=e.cm;return o&&i.noHScroll&&(o.display.alignWidgets=!0),Ri(e,t,"widget",function(t){var r=t.widgets||(t.widgets=[]);if(null==i.insertAt?r.push(i):r.splice(Math.min(r.length-1,Math.max(0,i.insertAt)),0,i),i.line=t,o&&!ve(e,t)){var n=ye(t)<e.scrollTop;A(t,t.height+Ht(i)),n&&Kr(o,i.height),o.curOp.forceUpdate=!0}return!0}),bt(o,"lineWidgetAdded",o,i,"number"==typeof t?t:W(t)),i}function Ki(e,t,r,n,o){if(n&&n.shared)return ji(e,t,r,n,o);if(e.cm&&!e.cm.curOp)return dn(e.cm,Ki)(e,t,r,n,o);var l=new Os(e,o),s=P(t,r);if(n&&c(n,l,!1),s>0||0==s&&!1!==l.clearWhenEmpty)return l;if(l.replacedWith&&(l.collapsed=!0,l.widgetNode=i("span",[l.replacedWith],"CodeMirror-widget"),n.handleMouseEvents||l.widgetNode.setAttribute("cm-ignore-events","true"),n.insertLeft&&(l.widgetNode.insertLeft=!0)),l.collapsed){if(ce(e,t.line,t,r,l)||t.line!=r.line&&ce(e,r.line,t,r,l))throw new Error("Inserting collapsed marker partially overlapping an existing one");X()}l.addToHistory&&ni(e,{from:t,to:r,origin:"markText"},e.sel,NaN);var a,u=t.line,f=e.cm;if(e.iter(u,r.line+1,function(e){f&&l.collapsed&&!f.options.lineWrapping&&fe(e)==f.display.maxLine&&(a=!0),l.collapsed&&u!=t.line&&A(e,0),q(e,new Y(l,u==t.line?t.ch:null,u==r.line?r.ch:null)),++u}),l.collapsed&&e.iter(t.line,r.line+1,function(t){ve(e,t)&&A(t,0)}),l.clearOnEnter&&Ql(l,"beforeCursorEnter",function(){return l.clear()}),l.readOnly&&(j(),(e.history.done.length||e.history.undone.length)&&e.clearHistory()),l.collapsed&&(l.id=++Ns,l.atomic=!0),f){if(a&&(f.curOp.updateMaxLine=!0),l.collapsed)vn(f,t.line,r.line+1);else if(l.className||l.title||l.startStyle||l.endStyle||l.css)for(var h=t.line;h<=r.line;h++)mn(f,h,"text");l.atomic&&Ci(f.doc),bt(f,"markerAdded",f,l)}return l}function ji(e,t,r,n,i){(n=c(n)).shared=!1;var o=[Ki(e,t,r,n,i)],l=o[0],s=n.widgetNode;return $n(e,function(e){s&&(n.widgetNode=s.cloneNode(!0)),o.push(Ki(e,U(e,t),U(e,r),n,i));for(var a=0;a<e.linked.length;++a)if(e.linked[a].isParent)return;l=g(o)}),new As(o,l)}function Xi(e){return e.findMarks(E(e.first,0),e.clipPos(E(e.lastLine())),function(e){return e.parent})}function Yi(e,t){for(var r=0;r<t.length;r++){var n=t[r],i=n.find(),o=e.clipPos(i.from),l=e.clipPos(i.to);if(P(o,l)){var s=Ki(e,o,l,n.primary,n.primary.type);n.markers.push(s),s.parent=n}}}function _i(e){for(var t=0;t<e.length;t++)!function(t){var r=e[t],n=[r.primary.doc];$n(r.primary.doc,function(e){return n.push(e)});for(var i=0;i<r.markers.length;i++){var o=r.markers[i];-1==h(n,o.doc)&&(o.parent=null,r.markers.splice(i--,1))}}(t)}function $i(e){var t=this;if(Qi(t),!Me(t,e)&&!Ft(t.display,e)){We(e),gl&&(Hs=+new Date);var r=Sr(t,e,!0),n=e.dataTransfer.files;if(r&&!t.isReadOnly())if(n&&n.length&&window.FileReader&&window.File)for(var i=n.length,o=Array(i),l=0,s=0;s<i;++s)!function(e,n){if(!t.options.allowDropFileTypes||-1!=h(t.options.allowDropFileTypes,e.type)){var s=new FileReader;s.onload=dn(t,function(){var e=s.result;if(/[\x00-\x08\x0e-\x1f]{2}/.test(e)&&(e=""),o[n]=e,++l==i){var a={from:r=U(t.doc,r),to:r,text:t.doc.splitLines(o.join(t.doc.lineSeparator())),origin:"paste"};Oi(t.doc,a),yi(t.doc,Rn(r,Bn(a)))}}),s.readAsText(e)}}(n[s],s);else{if(t.state.draggingText&&t.doc.sel.contains(r)>-1)return t.state.draggingText(e),void setTimeout(function(){return t.display.input.focus()},20);try{var a=e.dataTransfer.getData("Text");if(a){var u;if(t.state.draggingText&&!t.state.draggingText.copy&&(u=t.listSelections()),wi(t.doc,Rn(r,r)),u)for(var c=0;c<u.length;++c)Ei(t.doc,"",u[c].anchor,u[c].head,"drag");t.replaceSelection(a,"around","paste"),t.display.input.focus()}}catch(e){}}}}function qi(e,t){if(gl&&(!e.state.draggingText||+new Date-Hs<100))Fe(t);else if(!Me(e,t)&&!Ft(e.display,t)&&(t.dataTransfer.setData("Text",e.getSelection()),t.dataTransfer.effectAllowed="copyMove",t.dataTransfer.setDragImage&&!xl)){var r=n("img",null,null,"position: fixed; left: 0; top: 0;");r.src="data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==",wl&&(r.width=r.height=1,e.display.wrapper.appendChild(r),r._top=r.offsetTop),t.dataTransfer.setDragImage(r,0,0),wl&&r.parentNode.removeChild(r)}}function Zi(e,t){var i=Sr(e,t);if(i){var o=document.createDocumentFragment();Mr(e,i,o),e.display.dragCursor||(e.display.dragCursor=n("div",null,"CodeMirror-cursors CodeMirror-dragcursors"),e.display.lineSpace.insertBefore(e.display.dragCursor,e.display.cursorDiv)),r(e.display.dragCursor,o)}}function Qi(e){e.display.dragCursor&&(e.display.lineSpace.removeChild(e.display.dragCursor),e.display.dragCursor=null)}function Ji(e){if(document.getElementsByClassName)for(var t=document.getElementsByClassName("CodeMirror"),r=0;r<t.length;r++){var n=t[r].CodeMirror;n&&e(n)}}function eo(){Fs||(to(),Fs=!0)}function to(){var e;Ql(window,"resize",function(){null==e&&(e=setTimeout(function(){e=null,Ji(ro)},100))}),Ql(window,"blur",function(){return Ji(Fr)})}function ro(e){var t=e.display;t.lastWrapHeight==t.wrapper.clientHeight&&t.lastWrapWidth==t.wrapper.clientWidth||(t.cachedCharWidth=t.cachedTextHeight=t.cachedPaddingH=null,t.scrollbarsClipped=!1,e.setSize())}function no(e){var t=e.split(/-(?!$)/);e=t[t.length-1];for(var r,n,i,o,l=0;l<t.length-1;l++){var s=t[l];if(/^(cmd|meta|m)$/i.test(s))o=!0;else if(/^a(lt)?$/i.test(s))r=!0;else if(/^(c|ctrl|control)$/i.test(s))n=!0;else{if(!/^s(hift)?$/i.test(s))throw new Error("Unrecognized modifier name: "+s);i=!0}}return r&&(e="Alt-"+e),n&&(e="Ctrl-"+e),o&&(e="Cmd-"+e),i&&(e="Shift-"+e),e}function io(e){var t={};for(var r in e)if(e.hasOwnProperty(r)){var n=e[r];if(/^(name|fallthrough|(de|at)tach)$/.test(r))continue;if("..."==n){delete e[r];continue}for(var i=v(r.split(" "),no),o=0;o<i.length;o++){var l=void 0,s=void 0;o==i.length-1?(s=i.join(" "),l=n):(s=i.slice(0,o+1).join(" "),l="...");var a=t[s];if(a){if(a!=l)throw new Error("Inconsistent bindings for "+s)}else t[s]=l}delete e[r]}for(var u in t)e[u]=t[u];return e}function oo(e,t,r,n){var i=(t=uo(t)).call?t.call(e,n):t[e];if(!1===i)return"nothing";if("..."===i)return"multi";if(null!=i&&r(i))return"handled";if(t.fallthrough){if("[object Array]"!=Object.prototype.toString.call(t.fallthrough))return oo(e,t.fallthrough,r,n);for(var o=0;o<t.fallthrough.length;o++){var l=oo(e,t.fallthrough[o],r,n);if(l)return l}}}function lo(e){var t="string"==typeof e?e:Es[e.keyCode];return"Ctrl"==t||"Alt"==t||"Shift"==t||"Mod"==t}function so(e,t,r){var n=e;return t.altKey&&"Alt"!=n&&(e="Alt-"+e),(Dl?t.metaKey:t.ctrlKey)&&"Ctrl"!=n&&(e="Ctrl-"+e),(Dl?t.ctrlKey:t.metaKey)&&"Cmd"!=n&&(e="Cmd-"+e),!r&&t.shiftKey&&"Shift"!=n&&(e="Shift-"+e),e}function ao(e,t){if(wl&&34==e.keyCode&&e.char)return!1;var r=Es[e.keyCode];return null!=r&&!e.altGraphKey&&so(r,e,t)}function uo(e){return"string"==typeof e?Rs[e]:e}function co(e,t){for(var r=e.doc.sel.ranges,n=[],i=0;i<r.length;i++){for(var o=t(r[i]);n.length&&P(o.from,g(n).to)<=0;){var l=n.pop();if(P(l.from,o.from)<0){o.from=l.from;break}}n.push(o)}hn(e,function(){for(var t=n.length-1;t>=0;t--)Ei(e.doc,"",n[t].from,n[t].to,"+delete");jr(e)})}function fo(e,t,r){var n=L(e.text,t+r,r);return n<0||n>e.text.length?null:n}function ho(e,t,r){var n=fo(e,t.ch,r);return null==n?null:new E(t.line,n,r<0?"after":"before")}function po(e,t,r,n,i){if(e){var o=Se(r,t.doc.direction);if(o){var l,s=i<0?g(o):o[0],a=i<0==(1==s.level)?"after":"before";if(s.level>0){var u=Xt(t,r);l=i<0?r.text.length-1:0;var c=Yt(t,u,l).top;l=k(function(e){return Yt(t,u,e).top==c},i<0==(1==s.level)?s.from:s.to-1,l),"before"==a&&(l=fo(r,l,1))}else l=i<0?s.to:s.from;return new E(n,l,a)}}return new E(n,i<0?r.text.length:0,i<0?"before":"after")}function go(e,t,r,n){var i=Se(t,e.doc.direction);if(!i)return ho(t,r,n);r.ch>=t.text.length?(r.ch=t.text.length,r.sticky="before"):r.ch<=0&&(r.ch=0,r.sticky="after");var o=Ce(i,r.ch,r.sticky),l=i[o];if("ltr"==e.doc.direction&&l.level%2==0&&(n>0?l.to>r.ch:l.from<r.ch))return ho(t,r,n);var s,a=function(e,r){return fo(t,e instanceof E?e.ch:e,r)},u=function(r){return e.options.lineWrapping?(s=s||Xt(e,t),hr(e,t,s,r)):{begin:0,end:t.text.length}},c=u("before"==r.sticky?a(r,-1):r.ch);if("rtl"==e.doc.direction||1==l.level){var f=1==l.level==n<0,h=a(r,f?1:-1);if(null!=h&&(f?h<=l.to&&h<=c.end:h>=l.from&&h>=c.begin)){var d=f?"before":"after";return new E(r.line,h,d)}}var p=function(e,t,n){for(var o=function(e,t){return t?new E(r.line,a(e,1),"before"):new E(r.line,e,"after")};e>=0&&e<i.length;e+=t){var l=i[e],s=t>0==(1!=l.level),u=s?n.begin:a(n.end,-1);if(l.from<=u&&u<l.to)return o(u,s);if(u=s?l.from:a(l.to,-1),n.begin<=u&&u<n.end)return o(u,s)}},g=p(o+n,n,c);if(g)return g;var v=n>0?c.end:a(c.begin,-1);return null==v||n>0&&v==t.text.length||!(g=p(n>0?0:i.length-1,n,u(v)))?null:g}function vo(e,t){var r=M(e.doc,t),n=fe(r);return n!=r&&(t=W(n)),po(!0,e,n,t,1)}function mo(e,t){var r=M(e.doc,t),n=he(r);return n!=r&&(t=W(n)),po(!0,e,r,t,-1)}function yo(e,t){var r=vo(e,t.line),n=M(e.doc,r.line),i=Se(n,e.doc.direction);if(!i||0==i[0].level){var o=Math.max(0,n.text.search(/\S/)),l=t.line==r.line&&t.ch<=o&&t.ch;return E(r.line,l?0:o,r.sticky)}return r}function bo(e,t,r){if("string"==typeof t&&!(t=Bs[t]))return!1;e.display.input.ensurePolled();var n=e.display.shift,i=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),r&&(e.display.shift=!1),i=t(e)!=Bl}finally{e.display.shift=n,e.state.suppressEdits=!1}return i}function wo(e,t,r){for(var n=0;n<e.state.keyMaps.length;n++){var i=oo(t,e.state.keyMaps[n],r,e);if(i)return i}return e.options.extraKeys&&oo(t,e.options.extraKeys,r,e)||oo(t,e.options.keyMap,r,e)}function xo(e,t,r,n){var i=e.state.keySeq;if(i){if(lo(t))return"handled";Gs.set(50,function(){e.state.keySeq==i&&(e.state.keySeq=null,e.display.input.reset())}),t=i+" "+t}var o=wo(e,t,n);return"multi"==o&&(e.state.keySeq=t),"handled"==o&&bt(e,"keyHandled",e,t,r),"handled"!=o&&"multi"!=o||(We(r),Ar(e)),i&&!o&&/\'$/.test(t)?(We(r),!0):!!o}function Co(e,t){var r=ao(t,!0);return!!r&&(t.shiftKey&&!e.state.keySeq?xo(e,"Shift-"+r,t,function(t){return bo(e,t,!0)})||xo(e,r,t,function(t){if("string"==typeof t?/^go[A-Z]/.test(t):t.motion)return bo(e,t)}):xo(e,r,t,function(t){return bo(e,t)}))}function So(e,t,r){return xo(e,"'"+r+"'",t,function(t){return bo(e,t,!0)})}function Lo(e){var t=this;if(t.curOp.focus=l(),!Me(t,e)){gl&&vl<11&&27==e.keyCode&&(e.returnValue=!1);var r=e.keyCode;t.display.shift=16==r||e.shiftKey;var n=Co(t,e);wl&&(Us=n?r:null,!n&&88==r&&!rs&&(Ml?e.metaKey:e.ctrlKey)&&t.replaceSelection("",null,"cut")),18!=r||/\bCodeMirror-crosshair\b/.test(t.display.lineDiv.className)||ko(t)}}function ko(e){function t(e){18!=e.keyCode&&e.altKey||(Fl(r,"CodeMirror-crosshair"),ke(document,"keyup",t),ke(document,"mouseover",t))}var r=e.display.lineDiv;s(r,"CodeMirror-crosshair"),Ql(document,"keyup",t),Ql(document,"mouseover",t)}function To(e){16==e.keyCode&&(this.doc.sel.shift=!1),Me(this,e)}function Mo(e){var t=this;if(!(Ft(t.display,e)||Me(t,e)||e.ctrlKey&&!e.altKey||Ml&&e.metaKey)){var r=e.keyCode,n=e.charCode;if(wl&&r==Us)return Us=null,void We(e);if(!wl||e.which&&!(e.which<10)||!Co(t,e)){var i=String.fromCharCode(null==n?r:n);"\b"!=i&&(So(t,e,i)||t.display.input.onKeyPress(e))}}}function No(e,t){var r=+new Date;return js&&js.compare(r,e,t)?(Ks=js=null,"triple"):Ks&&Ks.compare(r,e,t)?(js=new Vs(r,e,t),Ks=null,"double"):(Ks=new Vs(r,e,t),js=null,"single")}function Oo(e){var t=this,r=t.display;if(!(Me(t,e)||r.activeTouch&&r.input.supportsTouch()))if(r.input.ensurePolled(),r.shift=e.shiftKey,Ft(r,e))ml||(r.scroller.draggable=!1,setTimeout(function(){return r.scroller.draggable=!0},100));else if(!zo(t,e)){var n=Sr(t,e),i=Pe(e),o=n?No(n,i):"single";window.focus(),1==i&&t.state.selectingText&&t.state.selectingText(e),n&&Ao(t,i,n,o,e)||(1==i?n?Do(t,n,o,e):Ee(e)==r.scroller&&We(e):2==i?(n&&di(t.doc,n),setTimeout(function(){return r.input.focus()},20)):3==i&&(Hl?Ro(t,e):Dr(t)))}}function Ao(e,t,r,n,i){var o="Click";return"double"==n?o="Double"+o:"triple"==n&&(o="Triple"+o),o=(1==t?"Left":2==t?"Middle":"Right")+o,xo(e,so(o,i),i,function(t){if("string"==typeof t&&(t=Bs[t]),!t)return!1;var n=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),n=t(e,r)!=Bl}finally{e.state.suppressEdits=!1}return n})}function Wo(e,t,r){var n=e.getOption("configureMouse"),i=n?n(e,t,r):{};if(null==i.unit){var o=Nl?r.shiftKey&&r.metaKey:r.altKey;i.unit=o?"rectangle":"single"==t?"char":"double"==t?"word":"line"}return(null==i.extend||e.doc.extend)&&(i.extend=e.doc.extend||r.shiftKey),null==i.addNew&&(i.addNew=Ml?r.metaKey:r.ctrlKey),null==i.moveOnDrag&&(i.moveOnDrag=!(Ml?r.altKey:r.ctrlKey)),i}function Do(e,t,r,n){gl?setTimeout(u(Wr,e),0):e.curOp.focus=l();var i,o=Wo(e,r,n),s=e.doc.sel;e.options.dragDrop&&Jl&&!e.isReadOnly()&&"single"==r&&(i=s.contains(t))>-1&&(P((i=s.ranges[i]).from(),t)<0||t.xRel>0)&&(P(i.to(),t)>0||t.xRel<0)?Ho(e,n,t,o):Eo(e,n,t,o)}function Ho(e,t,r,n){var i=e.display,o=!1,l=dn(e,function(t){ml&&(i.scroller.draggable=!1),e.state.draggingText=!1,ke(document,"mouseup",l),ke(document,"mousemove",s),ke(i.scroller,"dragstart",a),ke(i.scroller,"drop",l),o||(We(t),n.addNew||di(e.doc,r,null,null,n.extend),ml||gl&&9==vl?setTimeout(function(){document.body.focus(),i.input.focus()},20):i.input.focus())}),s=function(e){o=o||Math.abs(t.clientX-e.clientX)+Math.abs(t.clientY-e.clientY)>=10},a=function(){return o=!0};ml&&(i.scroller.draggable=!0),e.state.draggingText=l,l.copy=!n.moveOnDrag,i.scroller.dragDrop&&i.scroller.dragDrop(),Ql(document,"mouseup",l),Ql(document,"mousemove",s),Ql(i.scroller,"dragstart",a),Ql(i.scroller,"drop",l),Dr(e),setTimeout(function(){return i.input.focus()},20)}function Fo(e,t,r){if("char"==r)return new Ts(t,t);if("word"==r)return e.findWordAt(t);if("line"==r)return new Ts(E(t.line,0),U(e.doc,E(t.line+1,0)));var n=r(e,t);return new Ts(n.from,n.to)}function Eo(e,t,r,n){function i(t){if(0!=P(m,t))if(m=t,"rectangle"==n.unit){for(var i=[],o=e.options.tabSize,l=f(M(u,r.line).text,r.ch,o),s=f(M(u,t.line).text,t.ch,o),a=Math.min(l,s),g=Math.max(l,s),v=Math.min(r.line,t.line),y=Math.min(e.lastLine(),Math.max(r.line,t.line));v<=y;v++){var b=M(u,v).text,w=d(b,a,o);a==g?i.push(new Ts(E(v,w),E(v,w))):b.length>w&&i.push(new Ts(E(v,w),E(v,d(b,g,o))))}i.length||i.push(new Ts(r,r)),bi(u,zn(p.ranges.slice(0,h).concat(i),h),{origin:"*mouse",scroll:!1}),e.scrollIntoView(t)}else{var x,C=c,S=Fo(e,t,n.unit),L=C.anchor;P(S.anchor,L)>0?(x=S.head,L=B(C.from(),S.anchor)):(x=S.anchor,L=R(C.to(),S.head));var k=p.ranges.slice(0);k[h]=Po(e,new Ts(U(u,L),x)),bi(u,zn(k,h),Ul)}}function o(t){var r=++b,s=Sr(e,t,!0,"rectangle"==n.unit);if(s)if(0!=P(s,m)){e.curOp.focus=l(),i(s);var c=Ir(a,u);(s.line>=c.to||s.line<c.from)&&setTimeout(dn(e,function(){b==r&&o(t)}),150)}else{var f=t.clientY<y.top?-20:t.clientY>y.bottom?20:0;f&&setTimeout(dn(e,function(){b==r&&(a.scroller.scrollTop+=f,o(t))}),50)}}function s(t){e.state.selectingText=!1,b=1/0,We(t),a.input.focus(),ke(document,"mousemove",w),ke(document,"mouseup",x),u.history.lastSelOrigin=null}var a=e.display,u=e.doc;We(t);var c,h,p=u.sel,g=p.ranges;if(n.addNew&&!n.extend?(h=u.sel.contains(r),c=h>-1?g[h]:new Ts(r,r)):(c=u.sel.primary(),h=u.sel.primIndex),"rectangle"==n.unit)n.addNew||(c=new Ts(r,r)),r=Sr(e,t,!0,!0),h=-1;else{var v=Fo(e,r,n.unit);c=n.extend?hi(c,v.anchor,v.head,n.extend):v}n.addNew?-1==h?(h=g.length,bi(u,zn(g.concat([c]),h),{scroll:!1,origin:"*mouse"})):g.length>1&&g[h].empty()&&"char"==n.unit&&!n.extend?(bi(u,zn(g.slice(0,h).concat(g.slice(h+1)),0),{scroll:!1,origin:"*mouse"}),p=u.sel):gi(u,h,c,Ul):(h=0,bi(u,new ks([c],0),Ul),p=u.sel);var m=r,y=a.wrapper.getBoundingClientRect(),b=0,w=dn(e,function(e){Pe(e)?o(e):s(e)}),x=dn(e,s);e.state.selectingText=x,Ql(document,"mousemove",w),Ql(document,"mouseup",x)}function Po(e,t){var r=t.anchor,n=t.head,i=M(e.doc,r.line);if(0==P(r,n)&&r.sticky==n.sticky)return t;var o=Se(i);if(!o)return t;var l=Ce(o,r.ch,r.sticky),s=o[l];if(s.from!=r.ch&&s.to!=r.ch)return t;var a=l+(s.from==r.ch==(1!=s.level)?0:1);if(0==a||a==o.length)return t;var u;if(n.line!=r.line)u=(n.line-r.line)*("ltr"==e.doc.direction?1:-1)>0;else{var c=Ce(o,n.ch,n.sticky),f=c-l||(n.ch-r.ch)*(1==s.level?-1:1);u=c==a-1||c==a?f<0:f>0}var h=o[a+(u?-1:0)],d=u==(1==h.level),p=d?h.from:h.to,g=d?"after":"before";return r.ch==p&&r.sticky==g?t:new Ts(new E(r.line,p,g),n)}function Io(e,t,r,n){var i,o;if(t.touches)i=t.touches[0].clientX,o=t.touches[0].clientY;else try{i=t.clientX,o=t.clientY}catch(t){return!1}if(i>=Math.floor(e.display.gutters.getBoundingClientRect().right))return!1;n&&We(t);var l=e.display,s=l.lineDiv.getBoundingClientRect();if(o>s.bottom||!Oe(e,r))return He(t);o-=s.top-l.viewOffset;for(var a=0;a<e.options.gutters.length;++a){var u=l.gutters.childNodes[a];if(u&&u.getBoundingClientRect().right>=i)return Te(e,r,e,D(e.doc,o),e.options.gutters[a],t),He(t)}}function zo(e,t){return Io(e,t,"gutterClick",!0)}function Ro(e,t){Ft(e.display,t)||Bo(e,t)||Me(e,t,"contextmenu")||e.display.input.onContextMenu(t)}function Bo(e,t){return!!Oe(e,"gutterContextMenu")&&Io(e,t,"gutterContextMenu",!1)}function Go(e){e.display.wrapper.className=e.display.wrapper.className.replace(/\s*cm-s-\S+/g,"")+e.options.theme.replace(/(^|\s)\s*/g," cm-s-"),er(e)}function Uo(e){Hn(e),vn(e),zr(e)}function Vo(e,t,r){if(!t!=!(r&&r!=Xs)){var n=e.display.dragFunctions,i=t?Ql:ke;i(e.display.scroller,"dragstart",n.start),i(e.display.scroller,"dragenter",n.enter),i(e.display.scroller,"dragover",n.over),i(e.display.scroller,"dragleave",n.leave),i(e.display.scroller,"drop",n.drop)}}function Ko(e){e.options.lineWrapping?(s(e.display.wrapper,"CodeMirror-wrap"),e.display.sizer.style.minWidth="",e.display.sizerWidth=null):(Fl(e.display.wrapper,"CodeMirror-wrap"),we(e)),Cr(e),vn(e),er(e),setTimeout(function(){return en(e)},100)}function jo(e,t){var r=this;if(!(this instanceof jo))return new jo(e,t);this.options=t=t?c(t):{},c(Ys,t,!1),Fn(t);var n=t.value;"string"==typeof n&&(n=new Ds(n,t.mode,null,t.lineSeparator,t.direction)),this.doc=n;var i=new jo.inputStyles[t.inputStyle](this),o=this.display=new T(e,n,i);o.wrapper.CodeMirror=this,Hn(this),Go(this),t.lineWrapping&&(this.display.wrapper.className+=" CodeMirror-wrap"),rn(this),this.state={keyMaps:[],overlays:[],modeGen:0,overwrite:!1,delayingBlurEvent:!1,focused:!1,suppressEdits:!1,pasteIncoming:!1,cutIncoming:!1,selectingText:!1,draggingText:!1,highlight:new Pl,keySeq:null,specialChars:null},t.autofocus&&!Tl&&o.input.focus(),gl&&vl<11&&setTimeout(function(){return r.display.input.reset(!0)},20),Xo(this),eo(),nn(this),this.curOp.forceUpdate=!0,qn(this,n),t.autofocus&&!Tl||this.hasFocus()?setTimeout(u(Hr,this),20):Fr(this);for(var l in _s)_s.hasOwnProperty(l)&&_s[l](r,t[l],Xs);Rr(this),t.finishInit&&t.finishInit(this);for(var s=0;s<$s.length;++s)$s[s](r);on(this),ml&&t.lineWrapping&&"optimizelegibility"==getComputedStyle(o.lineDiv).textRendering&&(o.lineDiv.style.textRendering="auto")}function Xo(e){function t(){i.activeTouch&&(o=setTimeout(function(){return i.activeTouch=null},1e3),(l=i.activeTouch).end=+new Date)}function r(e){if(1!=e.touches.length)return!1;var t=e.touches[0];return t.radiusX<=1&&t.radiusY<=1}function n(e,t){if(null==t.left)return!0;var r=t.left-e.left,n=t.top-e.top;return r*r+n*n>400}var i=e.display;Ql(i.scroller,"mousedown",dn(e,Oo)),gl&&vl<11?Ql(i.scroller,"dblclick",dn(e,function(t){if(!Me(e,t)){var r=Sr(e,t);if(r&&!zo(e,t)&&!Ft(e.display,t)){We(t);var n=e.findWordAt(r);di(e.doc,n.anchor,n.head)}}})):Ql(i.scroller,"dblclick",function(t){return Me(e,t)||We(t)}),Hl||Ql(i.scroller,"contextmenu",function(t){return Ro(e,t)});var o,l={end:0};Ql(i.scroller,"touchstart",function(t){if(!Me(e,t)&&!r(t)&&!zo(e,t)){i.input.ensurePolled(),clearTimeout(o);var n=+new Date;i.activeTouch={start:n,moved:!1,prev:n-l.end<=300?l:null},1==t.touches.length&&(i.activeTouch.left=t.touches[0].pageX,i.activeTouch.top=t.touches[0].pageY)}}),Ql(i.scroller,"touchmove",function(){i.activeTouch&&(i.activeTouch.moved=!0)}),Ql(i.scroller,"touchend",function(r){var o=i.activeTouch;if(o&&!Ft(i,r)&&null!=o.left&&!o.moved&&new Date-o.start<300){var l,s=e.coordsChar(i.activeTouch,"page");l=!o.prev||n(o,o.prev)?new Ts(s,s):!o.prev.prev||n(o,o.prev.prev)?e.findWordAt(s):new Ts(E(s.line,0),U(e.doc,E(s.line+1,0))),e.setSelection(l.anchor,l.head),e.focus(),We(r)}t()}),Ql(i.scroller,"touchcancel",t),Ql(i.scroller,"scroll",function(){i.scroller.clientHeight&&(qr(e,i.scroller.scrollTop),Qr(e,i.scroller.scrollLeft,!0),Te(e,"scroll",e))}),Ql(i.scroller,"mousewheel",function(t){return In(e,t)}),Ql(i.scroller,"DOMMouseScroll",function(t){return In(e,t)}),Ql(i.wrapper,"scroll",function(){return i.wrapper.scrollTop=i.wrapper.scrollLeft=0}),i.dragFunctions={enter:function(t){Me(e,t)||Fe(t)},over:function(t){Me(e,t)||(Zi(e,t),Fe(t))},start:function(t){return qi(e,t)},drop:dn(e,$i),leave:function(t){Me(e,t)||Qi(e)}};var s=i.input.getField();Ql(s,"keyup",function(t){return To.call(e,t)}),Ql(s,"keydown",dn(e,Lo)),Ql(s,"keypress",dn(e,Mo)),Ql(s,"focus",function(t){return Hr(e,t)}),Ql(s,"blur",function(t){return Fr(e,t)})}function Yo(e,t,r,n){var i,o=e.doc;null==r&&(r="add"),"smart"==r&&(o.mode.indent?i=$e(e,t).state:r="prev");var l=e.options.tabSize,s=M(o,t),a=f(s.text,null,l);s.stateAfter&&(s.stateAfter=null);var u,c=s.text.match(/^\s*/)[0];if(n||/\S/.test(s.text)){if("smart"==r&&((u=o.mode.indent(i,s.text.slice(c.length),s.text))==Bl||u>150)){if(!n)return;r="prev"}}else u=0,r="not";"prev"==r?u=t>o.first?f(M(o,t-1).text,null,l):0:"add"==r?u=a+e.options.indentUnit:"subtract"==r?u=a-e.options.indentUnit:"number"==typeof r&&(u=a+r),u=Math.max(0,u);var h="",d=0;if(e.options.indentWithTabs)for(var g=Math.floor(u/l);g;--g)d+=l,h+="\t";if(d<u&&(h+=p(u-d)),h!=c)return Ei(o,h,E(t,0),E(t,c.length),"+input"),s.stateAfter=null,!0;for(var v=0;v<o.sel.ranges.length;v++){var m=o.sel.ranges[v];if(m.head.line==t&&m.head.ch<c.length){var y=E(t,c.length);gi(o,v,new Ts(y,y));break}}}function _o(e){qs=e}function $o(e,t,r,n,i){var o=e.doc;e.display.shift=!1,n||(n=o.sel);var l=e.state.pasteIncoming||"paste"==i,s=es(t),a=null;if(l&&n.ranges.length>1)if(qs&&qs.text.join("\n")==t){if(n.ranges.length%qs.text.length==0){a=[];for(var u=0;u<qs.text.length;u++)a.push(o.splitLines(qs.text[u]))}}else s.length==n.ranges.length&&e.options.pasteLinesPerSelection&&(a=v(s,function(e){return[e]}));for(var c,f=n.ranges.length-1;f>=0;f--){var h=n.ranges[f],d=h.from(),p=h.to();h.empty()&&(r&&r>0?d=E(d.line,d.ch-r):e.state.overwrite&&!l?p=E(p.line,Math.min(M(o,p.line).text.length,p.ch+g(s).length)):qs&&qs.lineWise&&qs.text.join("\n")==t&&(d=p=E(d.line,0))),c=e.curOp.updateInput;var m={from:d,to:p,text:a?a[f%a.length]:s,origin:i||(l?"paste":e.state.cutIncoming?"cut":"+input")};Oi(e.doc,m),bt(e,"inputRead",e,m)}t&&!l&&Zo(e,t),jr(e),e.curOp.updateInput=c,e.curOp.typing=!0,e.state.pasteIncoming=e.state.cutIncoming=!1}function qo(e,t){var r=e.clipboardData&&e.clipboardData.getData("Text");if(r)return e.preventDefault(),t.isReadOnly()||t.options.disableInput||hn(t,function(){return $o(t,r,0,null,"paste")}),!0}function Zo(e,t){if(e.options.electricChars&&e.options.smartIndent)for(var r=e.doc.sel,n=r.ranges.length-1;n>=0;n--){var i=r.ranges[n];if(!(i.head.ch>100||n&&r.ranges[n-1].head.line==i.head.line)){var o=e.getModeAt(i.head),l=!1;if(o.electricChars){for(var s=0;s<o.electricChars.length;s++)if(t.indexOf(o.electricChars.charAt(s))>-1){l=Yo(e,i.head.line,"smart");break}}else o.electricInput&&o.electricInput.test(M(e.doc,i.head.line).text.slice(0,i.head.ch))&&(l=Yo(e,i.head.line,"smart"));l&&bt(e,"electricInput",e,i.head.line)}}}function Qo(e){for(var t=[],r=[],n=0;n<e.doc.sel.ranges.length;n++){var i=e.doc.sel.ranges[n].head.line,o={anchor:E(i,0),head:E(i+1,0)};r.push(o),t.push(e.getRange(o.anchor,o.head))}return{text:t,ranges:r}}function Jo(e,t){e.setAttribute("autocorrect","off"),e.setAttribute("autocapitalize","off"),e.setAttribute("spellcheck",!!t)}function el(){var e=n("textarea",null,null,"position: absolute; bottom: -1em; padding: 0; width: 1px; height: 1em; outline: none"),t=n("div",[e],null,"overflow: hidden; position: relative; width: 3px; height: 0px;");return ml?e.style.width="1000px":e.setAttribute("wrap","off"),Ll&&(e.style.border="1px solid black"),Jo(e),t}function tl(e,t,r,n,i){function o(){var n=t.line+r;return!(n<e.first||n>=e.first+e.size)&&(t=new E(n,t.ch,t.sticky),u=M(e,n))}function l(n){var l;if(null==(l=i?go(e.cm,u,t,r):ho(u,t,r))){if(n||!o())return!1;t=po(i,e.cm,u,t.line,r)}else t=l;return!0}var s=t,a=r,u=M(e,t.line);if("char"==n)l();else if("column"==n)l(!0);else if("word"==n||"group"==n)for(var c=null,f="group"==n,h=e.cm&&e.cm.getHelper(t,"wordChars"),d=!0;!(r<0)||l(!d);d=!1){var p=u.text.charAt(t.ch)||"\n",g=x(p,h)?"w":f&&"\n"==p?"n":!f||/\s/.test(p)?null:"p";if(!f||d||g||(g="s"),c&&c!=g){r<0&&(r=1,l(),t.sticky="after");break}if(g&&(c=g),r>0&&!l(!d))break}var v=ki(e,t,s,a,!0);return I(s,v)&&(v.hitSide=!0),v}function rl(e,t,r,n){var i,o=e.doc,l=t.left;if("page"==n){var s=Math.min(e.display.wrapper.clientHeight,window.innerHeight||document.documentElement.clientHeight),a=Math.max(s-.5*mr(e.display),3);i=(r>0?t.bottom:t.top)+r*a}else"line"==n&&(i=r>0?t.bottom+3:t.top-3);for(var u;(u=cr(e,l,i)).outside;){if(r<0?i<=0:i>=o.height){u.hitSide=!0;break}i+=5*r}return u}function nl(e,t){var r=jt(e,t.line);if(!r||r.hidden)return null;var n=M(e.doc,t.line),i=Ut(r,n,t.line),o=Se(n,e.doc.direction),l="left";o&&(l=Ce(o,t.ch)%2?"right":"left");var s=_t(i.map,t.ch,l);return s.offset="right"==s.collapse?s.end:s.start,s}function il(e){for(var t=e;t;t=t.parentNode)if(/CodeMirror-gutter-wrapper/.test(t.className))return!0;return!1}function ol(e,t){return t&&(e.bad=!0),e}function ll(e,t,r,n,i){function o(e){return function(t){return t.id==e}}function l(){c&&(u+=f,c=!1)}function s(e){e&&(l(),u+=e)}function a(t){if(1==t.nodeType){var r=t.getAttribute("cm-text");if(null!=r)return void s(r||t.textContent.replace(/\u200b/g,""));var u,h=t.getAttribute("cm-marker");if(h){var d=e.findMarks(E(n,0),E(i+1,0),o(+h));return void(d.length&&(u=d[0].find(0))&&s(N(e.doc,u.from,u.to).join(f)))}if("false"==t.getAttribute("contenteditable"))return;var p=/^(pre|div|p)$/i.test(t.nodeName);p&&l();for(var g=0;g<t.childNodes.length;g++)a(t.childNodes[g]);p&&(c=!0)}else 3==t.nodeType&&s(t.nodeValue)}for(var u="",c=!1,f=e.doc.lineSeparator();a(t),t!=r;)t=t.nextSibling;return u}function sl(e,t,r){var n;if(t==e.display.lineDiv){if(!(n=e.display.lineDiv.childNodes[r]))return ol(e.clipPos(E(e.display.viewTo-1)),!0);t=null,r=0}else for(n=t;;n=n.parentNode){if(!n||n==e.display.lineDiv)return null;if(n.parentNode&&n.parentNode==e.display.lineDiv)break}for(var i=0;i<e.display.view.length;i++){var o=e.display.view[i];if(o.node==n)return al(o,t,r)}}function al(e,t,r){function n(t,r,n){for(var i=-1;i<(f?f.length:0);i++)for(var o=i<0?c.map:f[i],l=0;l<o.length;l+=3){var s=o[l+2];if(s==t||s==r){var a=W(i<0?e.line:e.rest[i]),u=o[l]+n;return(n<0||s!=t)&&(u=o[l+(n?1:0)]),E(a,u)}}}var i=e.text.firstChild,l=!1;if(!t||!o(i,t))return ol(E(W(e.line),0),!0);if(t==i&&(l=!0,t=i.childNodes[r],r=0,!t)){var s=e.rest?g(e.rest):e.line;return ol(E(W(s),s.text.length),l)}var a=3==t.nodeType?t:null,u=t;for(a||1!=t.childNodes.length||3!=t.firstChild.nodeType||(a=t.firstChild,r&&(r=a.nodeValue.length));u.parentNode!=i;)u=u.parentNode;var c=e.measure,f=c.maps,h=n(a,u,r);if(h)return ol(h,l);for(var d=u.nextSibling,p=a?a.nodeValue.length-r:0;d;d=d.nextSibling){if(h=n(d,d.firstChild,0))return ol(E(h.line,h.ch-p),l);p+=d.textContent.length}for(var v=u.previousSibling,m=r;v;v=v.previousSibling){if(h=n(v,v.firstChild,-1))return ol(E(h.line,h.ch+m),l);m+=v.textContent.length}}var ul=navigator.userAgent,cl=navigator.platform,fl=/gecko\/\d/i.test(ul),hl=/MSIE \d/.test(ul),dl=/Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(ul),pl=/Edge\/(\d+)/.exec(ul),gl=hl||dl||pl,vl=gl&&(hl?document.documentMode||6:+(pl||dl)[1]),ml=!pl&&/WebKit\//.test(ul),yl=ml&&/Qt\/\d+\.\d+/.test(ul),bl=!pl&&/Chrome\//.test(ul),wl=/Opera\//.test(ul),xl=/Apple Computer/.test(navigator.vendor),Cl=/Mac OS X 1\d\D([8-9]|\d\d)\D/.test(ul),Sl=/PhantomJS/.test(ul),Ll=!pl&&/AppleWebKit/.test(ul)&&/Mobile\/\w+/.test(ul),kl=/Android/.test(ul),Tl=Ll||kl||/webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(ul),Ml=Ll||/Mac/.test(cl),Nl=/\bCrOS\b/.test(ul),Ol=/win/i.test(cl),Al=wl&&ul.match(/Version\/(\d*\.\d*)/);Al&&(Al=Number(Al[1])),Al&&Al>=15&&(wl=!1,ml=!0);var Wl,Dl=Ml&&(yl||wl&&(null==Al||Al<12.11)),Hl=fl||gl&&vl>=9,Fl=function(t,r){var n=t.className,i=e(r).exec(n);if(i){var o=n.slice(i.index+i[0].length);t.className=n.slice(0,i.index)+(o?i[1]+o:"")}};Wl=document.createRange?function(e,t,r,n){var i=document.createRange();return i.setEnd(n||e,r),i.setStart(e,t),i}:function(e,t,r){var n=document.body.createTextRange();try{n.moveToElementText(e.parentNode)}catch(e){return n}return n.collapse(!0),n.moveEnd("character",r),n.moveStart("character",t),n};var El=function(e){e.select()};Ll?El=function(e){e.selectionStart=0,e.selectionEnd=e.value.length}:gl&&(El=function(e){try{e.select()}catch(e){}});var Pl=function(){this.id=null};Pl.prototype.set=function(e,t){clearTimeout(this.id),this.id=setTimeout(t,e)};var Il,zl,Rl=30,Bl={toString:function(){return"CodeMirror.Pass"}},Gl={scroll:!1},Ul={origin:"*mouse"},Vl={origin:"+move"},Kl=[""],jl=/[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/,Xl=/[\u0300-\u036f\u0483-\u0489\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u065e\u0670\u06d6-\u06dc\u06de-\u06e4\u06e7\u06e8\u06ea-\u06ed\u0711\u0730-\u074a\u07a6-\u07b0\u07eb-\u07f3\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0900-\u0902\u093c\u0941-\u0948\u094d\u0951-\u0955\u0962\u0963\u0981\u09bc\u09be\u09c1-\u09c4\u09cd\u09d7\u09e2\u09e3\u0a01\u0a02\u0a3c\u0a41\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a70\u0a71\u0a75\u0a81\u0a82\u0abc\u0ac1-\u0ac5\u0ac7\u0ac8\u0acd\u0ae2\u0ae3\u0b01\u0b3c\u0b3e\u0b3f\u0b41-\u0b44\u0b4d\u0b56\u0b57\u0b62\u0b63\u0b82\u0bbe\u0bc0\u0bcd\u0bd7\u0c3e-\u0c40\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0cbc\u0cbf\u0cc2\u0cc6\u0ccc\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0d3e\u0d41-\u0d44\u0d4d\u0d57\u0d62\u0d63\u0dca\u0dcf\u0dd2-\u0dd4\u0dd6\u0ddf\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0eb1\u0eb4-\u0eb9\u0ebb\u0ebc\u0ec8-\u0ecd\u0f18\u0f19\u0f35\u0f37\u0f39\u0f71-\u0f7e\u0f80-\u0f84\u0f86\u0f87\u0f90-\u0f97\u0f99-\u0fbc\u0fc6\u102d-\u1030\u1032-\u1037\u1039\u103a\u103d\u103e\u1058\u1059\u105e-\u1060\u1071-\u1074\u1082\u1085\u1086\u108d\u109d\u135f\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b7-\u17bd\u17c6\u17c9-\u17d3\u17dd\u180b-\u180d\u18a9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193b\u1a17\u1a18\u1a56\u1a58-\u1a5e\u1a60\u1a62\u1a65-\u1a6c\u1a73-\u1a7c\u1a7f\u1b00-\u1b03\u1b34\u1b36-\u1b3a\u1b3c\u1b42\u1b6b-\u1b73\u1b80\u1b81\u1ba2-\u1ba5\u1ba8\u1ba9\u1c2c-\u1c33\u1c36\u1c37\u1cd0-\u1cd2\u1cd4-\u1ce0\u1ce2-\u1ce8\u1ced\u1dc0-\u1de6\u1dfd-\u1dff\u200c\u200d\u20d0-\u20f0\u2cef-\u2cf1\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua66f-\ua672\ua67c\ua67d\ua6f0\ua6f1\ua802\ua806\ua80b\ua825\ua826\ua8c4\ua8e0-\ua8f1\ua926-\ua92d\ua947-\ua951\ua980-\ua982\ua9b3\ua9b6-\ua9b9\ua9bc\uaa29-\uaa2e\uaa31\uaa32\uaa35\uaa36\uaa43\uaa4c\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uabe5\uabe8\uabed\udc00-\udfff\ufb1e\ufe00-\ufe0f\ufe20-\ufe26\uff9e\uff9f]/,Yl=!1,_l=!1,$l=null,ql=function(){function e(e){return e<=247?r.charAt(e):1424<=e&&e<=1524?"R":1536<=e&&e<=1785?n.charAt(e-1536):1774<=e&&e<=2220?"r":8192<=e&&e<=8203?"w":8204==e?"b":"L"}function t(e,t,r){this.level=e,this.from=t,this.to=r}var r="bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLN",n="nnnnnnNNr%%r,rNNmmmmmmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmmmnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmnNmmmmmmrrmmNmmmmrr1111111111",i=/[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/,o=/[stwN]/,l=/[LRr]/,s=/[Lb1n]/,a=/[1n]/;return function(r,n){var u="ltr"==n?"L":"R";if(0==r.length||"ltr"==n&&!i.test(r))return!1;for(var c=r.length,f=[],h=0;h<c;++h)f.push(e(r.charCodeAt(h)));for(var d=0,p=u;d<c;++d){var v=f[d];"m"==v?f[d]=p:p=v}for(var m=0,y=u;m<c;++m){var b=f[m];"1"==b&&"r"==y?f[m]="n":l.test(b)&&(y=b,"r"==b&&(f[m]="R"))}for(var w=1,x=f[0];w<c-1;++w){var C=f[w];"+"==C&&"1"==x&&"1"==f[w+1]?f[w]="1":","!=C||x!=f[w+1]||"1"!=x&&"n"!=x||(f[w]=x),x=C}for(var S=0;S<c;++S){var L=f[S];if(","==L)f[S]="N";else if("%"==L){var k=void 0;for(k=S+1;k<c&&"%"==f[k];++k);for(var T=S&&"!"==f[S-1]||k<c&&"1"==f[k]?"1":"N",M=S;M<k;++M)f[M]=T;S=k-1}}for(var N=0,O=u;N<c;++N){var A=f[N];"L"==O&&"1"==A?f[N]="L":l.test(A)&&(O=A)}for(var W=0;W<c;++W)if(o.test(f[W])){var D=void 0;for(D=W+1;D<c&&o.test(f[D]);++D);for(var H="L"==(W?f[W-1]:u),F=H==("L"==(D<c?f[D]:u))?H?"L":"R":u,E=W;E<D;++E)f[E]=F;W=D-1}for(var P,I=[],z=0;z<c;)if(s.test(f[z])){var R=z;for(++z;z<c&&s.test(f[z]);++z);I.push(new t(0,R,z))}else{var B=z,G=I.length;for(++z;z<c&&"L"!=f[z];++z);for(var U=B;U<z;)if(a.test(f[U])){B<U&&I.splice(G,0,new t(1,B,U));var V=U;for(++U;U<z&&a.test(f[U]);++U);I.splice(G,0,new t(2,V,U)),B=U}else++U;B<z&&I.splice(G,0,new t(1,B,z))}return 1==I[0].level&&(P=r.match(/^\s+/))&&(I[0].from=P[0].length,I.unshift(new t(0,0,P[0].length))),1==g(I).level&&(P=r.match(/\s+$/))&&(g(I).to-=P[0].length,I.push(new t(0,c-P[0].length,c))),"rtl"==n?I.reverse():I}}(),Zl=[],Ql=function(e,t,r){if(e.addEventListener)e.addEventListener(t,r,!1);else if(e.attachEvent)e.attachEvent("on"+t,r);else{var n=e._handlers||(e._handlers={});n[t]=(n[t]||Zl).concat(r)}},Jl=function(){if(gl&&vl<9)return!1;var e=n("div");return"draggable"in e||"dragDrop"in e}(),es=3!="\n\nb".split(/\n/).length?function(e){for(var t=0,r=[],n=e.length;t<=n;){var i=e.indexOf("\n",t);-1==i&&(i=e.length);var o=e.slice(t,"\r"==e.charAt(i-1)?i-1:i),l=o.indexOf("\r");-1!=l?(r.push(o.slice(0,l)),t+=l+1):(r.push(o),t=i+1)}return r}:function(e){return e.split(/\r\n?|\n/)},ts=window.getSelection?function(e){try{return e.selectionStart!=e.selectionEnd}catch(e){return!1}}:function(e){var t;try{t=e.ownerDocument.selection.createRange()}catch(e){}return!(!t||t.parentElement()!=e)&&0!=t.compareEndPoints("StartToEnd",t)},rs=function(){var e=n("div");return"oncopy"in e||(e.setAttribute("oncopy","return;"),"function"==typeof e.oncopy)}(),ns=null,is={},os={},ls={},ss=function(e,t,r){this.pos=this.start=0,this.string=e,this.tabSize=t||8,this.lastColumnPos=this.lastColumnValue=0,this.lineStart=0,this.lineOracle=r};ss.prototype.eol=function(){return this.pos>=this.string.length},ss.prototype.sol=function(){return this.pos==this.lineStart},ss.prototype.peek=function(){return this.string.charAt(this.pos)||void 0},ss.prototype.next=function(){if(this.pos<this.string.length)return this.string.charAt(this.pos++)},ss.prototype.eat=function(e){var t=this.string.charAt(this.pos);if("string"==typeof e?t==e:t&&(e.test?e.test(t):e(t)))return++this.pos,t},ss.prototype.eatWhile=function(e){for(var t=this.pos;this.eat(e););return this.pos>t},ss.prototype.eatSpace=function(){for(var e=this,t=this.pos;/[\s\u00a0]/.test(this.string.charAt(this.pos));)++e.pos;return this.pos>t},ss.prototype.skipToEnd=function(){this.pos=this.string.length},ss.prototype.skipTo=function(e){var t=this.string.indexOf(e,this.pos);if(t>-1)return this.pos=t,!0},ss.prototype.backUp=function(e){this.pos-=e},ss.prototype.column=function(){return this.lastColumnPos<this.start&&(this.lastColumnValue=f(this.string,this.start,this.tabSize,this.lastColumnPos,this.lastColumnValue),this.lastColumnPos=this.start),this.lastColumnValue-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.indentation=function(){return f(this.string,null,this.tabSize)-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.match=function(e,t,r){if("string"!=typeof e){var n=this.string.slice(this.pos).match(e);return n&&n.index>0?null:(n&&!1!==t&&(this.pos+=n[0].length),n)}var i=function(e){return r?e.toLowerCase():e};if(i(this.string.substr(this.pos,e.length))==i(e))return!1!==t&&(this.pos+=e.length),!0},ss.prototype.current=function(){return this.string.slice(this.start,this.pos)},ss.prototype.hideFirstChars=function(e,t){this.lineStart+=e;try{return t()}finally{this.lineStart-=e}},ss.prototype.lookAhead=function(e){var t=this.lineOracle;return t&&t.lookAhead(e)};var as=function(e,t){this.state=e,this.lookAhead=t},us=function(e,t,r,n){this.state=t,this.doc=e,this.line=r,this.maxLookAhead=n||0};us.prototype.lookAhead=function(e){var t=this.doc.getLine(this.line+e);return null!=t&&e>this.maxLookAhead&&(this.maxLookAhead=e),t},us.prototype.nextLine=function(){this.line++,this.maxLookAhead>0&&this.maxLookAhead--},us.fromSaved=function(e,t,r){return t instanceof as?new us(e,Ke(e.mode,t.state),r,t.lookAhead):new us(e,Ke(e.mode,t),r)},us.prototype.save=function(e){var t=!1!==e?Ke(this.doc.mode,this.state):this.state;return this.maxLookAhead>0?new as(t,this.maxLookAhead):t};var cs=function(e,t,r){this.start=e.start,this.end=e.pos,this.string=e.current(),this.type=t||null,this.state=r},fs=function(e,t,r){this.text=e,ne(this,t),this.height=r?r(this):1};fs.prototype.lineNo=function(){return W(this)},Ae(fs);var hs,ds={},ps={},gs=null,vs=null,ms={left:0,right:0,top:0,bottom:0},ys=function(e,t,r){this.cm=r;var i=this.vert=n("div",[n("div",null,null,"min-width: 1px")],"CodeMirror-vscrollbar"),o=this.horiz=n("div",[n("div",null,null,"height: 100%; min-height: 1px")],"CodeMirror-hscrollbar");e(i),e(o),Ql(i,"scroll",function(){i.clientHeight&&t(i.scrollTop,"vertical")}),Ql(o,"scroll",function(){o.clientWidth&&t(o.scrollLeft,"horizontal")}),this.checkedZeroWidth=!1,gl&&vl<8&&(this.horiz.style.minHeight=this.vert.style.minWidth="18px")};ys.prototype.update=function(e){var t=e.scrollWidth>e.clientWidth+1,r=e.scrollHeight>e.clientHeight+1,n=e.nativeBarWidth;if(r){this.vert.style.display="block",this.vert.style.bottom=t?n+"px":"0";var i=e.viewHeight-(t?n:0);this.vert.firstChild.style.height=Math.max(0,e.scrollHeight-e.clientHeight+i)+"px"}else this.vert.style.display="",this.vert.firstChild.style.height="0";if(t){this.horiz.style.display="block",this.horiz.style.right=r?n+"px":"0",this.horiz.style.left=e.barLeft+"px";var o=e.viewWidth-e.barLeft-(r?n:0);this.horiz.firstChild.style.width=Math.max(0,e.scrollWidth-e.clientWidth+o)+"px"}else this.horiz.style.display="",this.horiz.firstChild.style.width="0";return!this.checkedZeroWidth&&e.clientHeight>0&&(0==n&&this.zeroWidthHack(),this.checkedZeroWidth=!0),{right:r?n:0,bottom:t?n:0}},ys.prototype.setScrollLeft=function(e){this.horiz.scrollLeft!=e&&(this.horiz.scrollLeft=e),this.disableHoriz&&this.enableZeroWidthBar(this.horiz,this.disableHoriz,"horiz")},ys.prototype.setScrollTop=function(e){this.vert.scrollTop!=e&&(this.vert.scrollTop=e),this.disableVert&&this.enableZeroWidthBar(this.vert,this.disableVert,"vert")},ys.prototype.zeroWidthHack=function(){var e=Ml&&!Cl?"12px":"18px";this.horiz.style.height=this.vert.style.width=e,this.horiz.style.pointerEvents=this.vert.style.pointerEvents="none",this.disableHoriz=new Pl,this.disableVert=new Pl},ys.prototype.enableZeroWidthBar=function(e,t,r){function n(){var i=e.getBoundingClientRect();("vert"==r?document.elementFromPoint(i.right-1,(i.top+i.bottom)/2):document.elementFromPoint((i.right+i.left)/2,i.bottom-1))!=e?e.style.pointerEvents="none":t.set(1e3,n)}e.style.pointerEvents="auto",t.set(1e3,n)},ys.prototype.clear=function(){var e=this.horiz.parentNode;e.removeChild(this.horiz),e.removeChild(this.vert)};var bs=function(){};bs.prototype.update=function(){return{bottom:0,right:0}},bs.prototype.setScrollLeft=function(){},bs.prototype.setScrollTop=function(){},bs.prototype.clear=function(){};var ws={native:ys,null:bs},xs=0,Cs=function(e,t,r){var n=e.display;this.viewport=t,this.visible=Ir(n,e.doc,t),this.editorIsHidden=!n.wrapper.offsetWidth,this.wrapperHeight=n.wrapper.clientHeight,this.wrapperWidth=n.wrapper.clientWidth,this.oldDisplayWidth=Rt(e),this.force=r,this.dims=br(e),this.events=[]};Cs.prototype.signal=function(e,t){Oe(e,t)&&this.events.push(arguments)},Cs.prototype.finish=function(){for(var e=this,t=0;t<this.events.length;t++)Te.apply(null,e.events[t])};var Ss=0,Ls=null;gl?Ls=-.53:fl?Ls=15:bl?Ls=-.7:xl&&(Ls=-1/3);var ks=function(e,t){this.ranges=e,this.primIndex=t};ks.prototype.primary=function(){return this.ranges[this.primIndex]},ks.prototype.equals=function(e){var t=this;if(e==this)return!0;if(e.primIndex!=this.primIndex||e.ranges.length!=this.ranges.length)return!1;for(var r=0;r<this.ranges.length;r++){var n=t.ranges[r],i=e.ranges[r];if(!I(n.anchor,i.anchor)||!I(n.head,i.head))return!1}return!0},ks.prototype.deepCopy=function(){for(var e=this,t=[],r=0;r<this.ranges.length;r++)t[r]=new Ts(z(e.ranges[r].anchor),z(e.ranges[r].head));return new ks(t,this.primIndex)},ks.prototype.somethingSelected=function(){for(var e=this,t=0;t<this.ranges.length;t++)if(!e.ranges[t].empty())return!0;return!1},ks.prototype.contains=function(e,t){var r=this;t||(t=e);for(var n=0;n<this.ranges.length;n++){var i=r.ranges[n];if(P(t,i.from())>=0&&P(e,i.to())<=0)return n}return-1};var Ts=function(e,t){this.anchor=e,this.head=t};Ts.prototype.from=function(){return B(this.anchor,this.head)},Ts.prototype.to=function(){return R(this.anchor,this.head)},Ts.prototype.empty=function(){return this.head.line==this.anchor.line&&this.head.ch==this.anchor.ch},Bi.prototype={chunkSize:function(){return this.lines.length},removeInner:function(e,t){for(var r=this,n=e,i=e+t;n<i;++n){var o=r.lines[n];r.height-=o.height,ot(o),bt(o,"delete")}this.lines.splice(e,t)},collapse:function(e){e.push.apply(e,this.lines)},insertInner:function(e,t,r){var n=this;this.height+=r,this.lines=this.lines.slice(0,e).concat(t).concat(this.lines.slice(e));for(var i=0;i<t.length;++i)t[i].parent=n},iterN:function(e,t,r){for(var n=this,i=e+t;e<i;++e)if(r(n.lines[e]))return!0}},Gi.prototype={chunkSize:function(){return this.size},removeInner:function(e,t){var r=this;this.size-=t;for(var n=0;n<this.children.length;++n){var i=r.children[n],o=i.chunkSize();if(e<o){var l=Math.min(t,o-e),s=i.height;if(i.removeInner(e,l),r.height-=s-i.height,o==l&&(r.children.splice(n--,1),i.parent=null),0==(t-=l))break;e=0}else e-=o}if(this.size-t<25&&(this.children.length>1||!(this.children[0]instanceof Bi))){var a=[];this.collapse(a),this.children=[new Bi(a)],this.children[0].parent=this}},collapse:function(e){for(var t=this,r=0;r<this.children.length;++r)t.children[r].collapse(e)},insertInner:function(e,t,r){var n=this;this.size+=t.length,this.height+=r;for(var i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<=l){if(o.insertInner(e,t,r),o.lines&&o.lines.length>50){for(var s=o.lines.length%25+25,a=s;a<o.lines.length;){var u=new Bi(o.lines.slice(a,a+=25));o.height-=u.height,n.children.splice(++i,0,u),u.parent=n}o.lines=o.lines.slice(0,s),n.maybeSpill()}break}e-=l}},maybeSpill:function(){if(!(this.children.length<=10)){var e=this;do{var t=new Gi(e.children.splice(e.children.length-5,5));if(e.parent){e.size-=t.size,e.height-=t.height;var r=h(e.parent.children,e);e.parent.children.splice(r+1,0,t)}else{var n=new Gi(e.children);n.parent=e,e.children=[n,t],e=n}t.parent=e.parent}while(e.children.length>10);e.parent.maybeSpill()}},iterN:function(e,t,r){for(var n=this,i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<l){var s=Math.min(t,l-e);if(o.iterN(e,s,r))return!0;if(0==(t-=s))break;e=0}else e-=l}}};var Ms=function(e,t,r){var n=this;if(r)for(var i in r)r.hasOwnProperty(i)&&(n[i]=r[i]);this.doc=e,this.node=t};Ms.prototype.clear=function(){var e=this,t=this.doc.cm,r=this.line.widgets,n=this.line,i=W(n);if(null!=i&&r){for(var o=0;o<r.length;++o)r[o]==e&&r.splice(o--,1);r.length||(n.widgets=null);var l=Ht(this);A(n,Math.max(0,n.height-l)),t&&(hn(t,function(){Ui(t,n,-l),mn(t,i,"widget")}),bt(t,"lineWidgetCleared",t,this,i))}},Ms.prototype.changed=function(){var e=this,t=this.height,r=this.doc.cm,n=this.line;this.height=null;var i=Ht(this)-t;i&&(A(n,n.height+i),r&&hn(r,function(){r.curOp.forceUpdate=!0,Ui(r,n,i),bt(r,"lineWidgetChanged",r,e,W(n))}))},Ae(Ms);var Ns=0,Os=function(e,t){this.lines=[],this.type=t,this.doc=e,this.id=++Ns};Os.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){var t=this.doc.cm,r=t&&!t.curOp;if(r&&nn(t),Oe(this,"clear")){var n=this.find();n&&bt(this,"clear",n.from,n.to)}for(var i=null,o=null,l=0;l<this.lines.length;++l){var s=e.lines[l],a=_(s.markedSpans,e);t&&!e.collapsed?mn(t,W(s),"text"):t&&(null!=a.to&&(o=W(s)),null!=a.from&&(i=W(s))),s.markedSpans=$(s.markedSpans,a),null==a.from&&e.collapsed&&!ve(e.doc,s)&&t&&A(s,mr(t.display))}if(t&&this.collapsed&&!t.options.lineWrapping)for(var u=0;u<this.lines.length;++u){var c=fe(e.lines[u]),f=be(c);f>t.display.maxLineLength&&(t.display.maxLine=c,t.display.maxLineLength=f,t.display.maxLineChanged=!0)}null!=i&&t&&this.collapsed&&vn(t,i,o+1),this.lines.length=0,this.explicitlyCleared=!0,this.atomic&&this.doc.cantEdit&&(this.doc.cantEdit=!1,t&&Ci(t.doc)),t&&bt(t,"markerCleared",t,this,i,o),r&&on(t),this.parent&&this.parent.clear()}},Os.prototype.find=function(e,t){var r=this;null==e&&"bookmark"==this.type&&(e=1);for(var n,i,o=0;o<this.lines.length;++o){var l=r.lines[o],s=_(l.markedSpans,r);if(null!=s.from&&(n=E(t?l:W(l),s.from),-1==e))return n;if(null!=s.to&&(i=E(t?l:W(l),s.to),1==e))return i}return n&&{from:n,to:i}},Os.prototype.changed=function(){var e=this,t=this.find(-1,!0),r=this,n=this.doc.cm;t&&n&&hn(n,function(){var i=t.line,o=W(t.line),l=jt(n,o);if(l&&(Qt(l),n.curOp.selectionChanged=n.curOp.forceUpdate=!0),n.curOp.updateMaxLine=!0,!ve(r.doc,i)&&null!=r.height){var s=r.height;r.height=null;var a=Ht(r)-s;a&&A(i,i.height+a)}bt(n,"markerChanged",n,e)})},Os.prototype.attachLine=function(e){if(!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;t.maybeHiddenMarkers&&-1!=h(t.maybeHiddenMarkers,this)||(t.maybeUnhiddenMarkers||(t.maybeUnhiddenMarkers=[])).push(this)}this.lines.push(e)},Os.prototype.detachLine=function(e){if(this.lines.splice(h(this.lines,e),1),!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;(t.maybeHiddenMarkers||(t.maybeHiddenMarkers=[])).push(this)}},Ae(Os);var As=function(e,t){var r=this;this.markers=e,this.primary=t;for(var n=0;n<e.length;++n)e[n].parent=r};As.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){this.explicitlyCleared=!0;for(var t=0;t<this.markers.length;++t)e.markers[t].clear();bt(this,"clear")}},As.prototype.find=function(e,t){return this.primary.find(e,t)},Ae(As);var Ws=0,Ds=function(e,t,r,n,i){if(!(this instanceof Ds))return new Ds(e,t,r,n,i);null==r&&(r=0),Gi.call(this,[new Bi([new fs("",null)])]),this.first=r,this.scrollTop=this.scrollLeft=0,this.cantEdit=!1,this.cleanGeneration=1,this.modeFrontier=this.highlightFrontier=r;var o=E(r,0);this.sel=Rn(o),this.history=new Jn(null),this.id=++Ws,this.modeOption=t,this.lineSep=n,this.direction="rtl"==i?"rtl":"ltr",this.extend=!1,"string"==typeof e&&(e=this.splitLines(e)),_n(this,{from:o,to:o,text:e}),bi(this,Rn(o),Gl)};Ds.prototype=b(Gi.prototype,{constructor:Ds,iter:function(e,t,r){r?this.iterN(e-this.first,t-e,r):this.iterN(this.first,this.first+this.size,e)},insert:function(e,t){for(var r=0,n=0;n<t.length;++n)r+=t[n].height;this.insertInner(e-this.first,t,r)},remove:function(e,t){this.removeInner(e-this.first,t)},getValue:function(e){var t=O(this,this.first,this.first+this.size);return!1===e?t:t.join(e||this.lineSeparator())},setValue:gn(function(e){var t=E(this.first,0),r=this.first+this.size-1;Oi(this,{from:t,to:E(r,M(this,r).text.length),text:this.splitLines(e),origin:"setValue",full:!0},!0),this.cm&&Xr(this.cm,0,0),bi(this,Rn(t),Gl)}),replaceRange:function(e,t,r,n){Ei(this,e,t=U(this,t),r=r?U(this,r):t,n)},getRange:function(e,t,r){var n=N(this,U(this,e),U(this,t));return!1===r?n:n.join(r||this.lineSeparator())},getLine:function(e){var t=this.getLineHandle(e);return t&&t.text},getLineHandle:function(e){if(H(this,e))return M(this,e)},getLineNumber:function(e){return W(e)},getLineHandleVisualStart:function(e){return"number"==typeof e&&(e=M(this,e)),fe(e)},lineCount:function(){return this.size},firstLine:function(){return this.first},lastLine:function(){return this.first+this.size-1},clipPos:function(e){return U(this,e)},getCursor:function(e){var t=this.sel.primary();return null==e||"head"==e?t.head:"anchor"==e?t.anchor:"end"==e||"to"==e||!1===e?t.to():t.from()},listSelections:function(){return this.sel.ranges},somethingSelected:function(){return this.sel.somethingSelected()},setCursor:gn(function(e,t,r){vi(this,U(this,"number"==typeof e?E(e,t||0):e),null,r)}),setSelection:gn(function(e,t,r){vi(this,U(this,e),U(this,t||e),r)}),extendSelection:gn(function(e,t,r){di(this,U(this,e),t&&U(this,t),r)}),extendSelections:gn(function(e,t){pi(this,K(this,e),t)}),extendSelectionsBy:gn(function(e,t){pi(this,K(this,v(this.sel.ranges,e)),t)}),setSelections:gn(function(e,t,r){var n=this;if(e.length){for(var i=[],o=0;o<e.length;o++)i[o]=new Ts(U(n,e[o].anchor),U(n,e[o].head));null==t&&(t=Math.min(e.length-1,this.sel.primIndex)),bi(this,zn(i,t),r)}}),addSelection:gn(function(e,t,r){var n=this.sel.ranges.slice(0);n.push(new Ts(U(this,e),U(this,t||e))),bi(this,zn(n,n.length-1),r)}),getSelection:function(e){for(var t,r=this,n=this.sel.ranges,i=0;i<n.length;i++){var o=N(r,n[i].from(),n[i].to());t=t?t.concat(o):o}return!1===e?t:t.join(e||this.lineSeparator())},getSelections:function(e){for(var t=this,r=[],n=this.sel.ranges,i=0;i<n.length;i++){var o=N(t,n[i].from(),n[i].to());!1!==e&&(o=o.join(e||t.lineSeparator())),r[i]=o}return r},replaceSelection:function(e,t,r){for(var n=[],i=0;i<this.sel.ranges.length;i++)n[i]=e;this.replaceSelections(n,t,r||"+input")},replaceSelections:gn(function(e,t,r){for(var n=this,i=[],o=this.sel,l=0;l<o.ranges.length;l++){var s=o.ranges[l];i[l]={from:s.from(),to:s.to(),text:n.splitLines(e[l]),origin:r}}for(var a=t&&"end"!=t&&Kn(this,i,t),u=i.length-1;u>=0;u--)Oi(n,i[u]);a?yi(this,a):this.cm&&jr(this.cm)}),undo:gn(function(){Wi(this,"undo")}),redo:gn(function(){Wi(this,"redo")}),undoSelection:gn(function(){Wi(this,"undo",!0)}),redoSelection:gn(function(){Wi(this,"redo",!0)}),setExtending:function(e){this.extend=e},getExtending:function(){return this.extend},historySize:function(){for(var e=this.history,t=0,r=0,n=0;n<e.done.length;n++)e.done[n].ranges||++t;for(var i=0;i<e.undone.length;i++)e.undone[i].ranges||++r;return{undo:t,redo:r}},clearHistory:function(){this.history=new Jn(this.history.maxGeneration)},markClean:function(){this.cleanGeneration=this.changeGeneration(!0)},changeGeneration:function(e){return e&&(this.history.lastOp=this.history.lastSelOp=this.history.lastOrigin=null),this.history.generation},isClean:function(e){return this.history.generation==(e||this.cleanGeneration)},getHistory:function(){return{done:fi(this.history.done),undone:fi(this.history.undone)}},setHistory:function(e){var t=this.history=new Jn(this.history.maxGeneration);t.done=fi(e.done.slice(0),null,!0),t.undone=fi(e.undone.slice(0),null,!0)},setGutterMarker:gn(function(e,t,r){return Ri(this,e,"gutter",function(e){var n=e.gutterMarkers||(e.gutterMarkers={});return n[t]=r,!r&&C(n)&&(e.gutterMarkers=null),!0})}),clearGutter:gn(function(e){var t=this;this.iter(function(r){r.gutterMarkers&&r.gutterMarkers[e]&&Ri(t,r,"gutter",function(){return r.gutterMarkers[e]=null,C(r.gutterMarkers)&&(r.gutterMarkers=null),!0})})}),lineInfo:function(e){var t;if("number"==typeof e){if(!H(this,e))return null;if(t=e,!(e=M(this,e)))return null}else if(null==(t=W(e)))return null;return{line:t,handle:e,text:e.text,gutterMarkers:e.gutterMarkers,textClass:e.textClass,bgClass:e.bgClass,wrapClass:e.wrapClass,widgets:e.widgets}},addLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass";if(t[i]){if(e(n).test(t[i]))return!1;t[i]+=" "+n}else t[i]=n;return!0})}),removeLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass",o=t[i];if(!o)return!1;if(null==n)t[i]=null;else{var l=o.match(e(n));if(!l)return!1;var s=l.index+l[0].length;t[i]=o.slice(0,l.index)+(l.index&&s!=o.length?" ":"")+o.slice(s)||null}return!0})}),addLineWidget:gn(function(e,t,r){return Vi(this,e,t,r)}),removeLineWidget:function(e){e.clear()},markText:function(e,t,r){return Ki(this,U(this,e),U(this,t),r,r&&r.type||"range")},setBookmark:function(e,t){var r={replacedWith:t&&(null==t.nodeType?t.widget:t),insertLeft:t&&t.insertLeft,clearWhenEmpty:!1,shared:t&&t.shared,handleMouseEvents:t&&t.handleMouseEvents};return e=U(this,e),Ki(this,e,e,r,"bookmark")},findMarksAt:function(e){var t=[],r=M(this,(e=U(this,e)).line).markedSpans;if(r)for(var n=0;n<r.length;++n){var i=r[n];(null==i.from||i.from<=e.ch)&&(null==i.to||i.to>=e.ch)&&t.push(i.marker.parent||i.marker)}return t},findMarks:function(e,t,r){e=U(this,e),t=U(this,t);var n=[],i=e.line;return this.iter(e.line,t.line+1,function(o){var l=o.markedSpans;if(l)for(var s=0;s<l.length;s++){var a=l[s];null!=a.to&&i==e.line&&e.ch>=a.to||null==a.from&&i!=e.line||null!=a.from&&i==t.line&&a.from>=t.ch||r&&!r(a.marker)||n.push(a.marker.parent||a.marker)}++i}),n},getAllMarks:function(){var e=[];return this.iter(function(t){var r=t.markedSpans;if(r)for(var n=0;n<r.length;++n)null!=r[n].from&&e.push(r[n].marker)}),e},posFromIndex:function(e){var t,r=this.first,n=this.lineSeparator().length;return this.iter(function(i){var o=i.text.length+n;if(o>e)return t=e,!0;e-=o,++r}),U(this,E(r,t))},indexFromPos:function(e){var t=(e=U(this,e)).ch;if(e.line<this.first||e.ch<0)return 0;var r=this.lineSeparator().length;return this.iter(this.first,e.line,function(e){t+=e.text.length+r}),t},copy:function(e){var t=new Ds(O(this,this.first,this.first+this.size),this.modeOption,this.first,this.lineSep,this.direction);return t.scrollTop=this.scrollTop,t.scrollLeft=this.scrollLeft,t.sel=this.sel,t.extend=!1,e&&(t.history.undoDepth=this.history.undoDepth,t.setHistory(this.getHistory())),t},linkedDoc:function(e){e||(e={});var t=this.first,r=this.first+this.size;null!=e.from&&e.from>t&&(t=e.from),null!=e.to&&e.to<r&&(r=e.to);var n=new Ds(O(this,t,r),e.mode||this.modeOption,t,this.lineSep,this.direction);return e.sharedHist&&(n.history=this.history),(this.linked||(this.linked=[])).push({doc:n,sharedHist:e.sharedHist}),n.linked=[{doc:this,isParent:!0,sharedHist:e.sharedHist}],Yi(n,Xi(this)),n},unlinkDoc:function(e){var t=this;if(e instanceof jo&&(e=e.doc),this.linked)for(var r=0;r<this.linked.length;++r)if(t.linked[r].doc==e){t.linked.splice(r,1),e.unlinkDoc(t),_i(Xi(t));break}if(e.history==this.history){var n=[e.id];$n(e,function(e){return n.push(e.id)},!0),e.history=new Jn(null),e.history.done=fi(this.history.done,n),e.history.undone=fi(this.history.undone,n)}},iterLinkedDocs:function(e){$n(this,e)},getMode:function(){return this.mode},getEditor:function(){return this.cm},splitLines:function(e){return this.lineSep?e.split(this.lineSep):es(e)},lineSeparator:function(){return this.lineSep||"\n"},setDirection:gn(function(e){"rtl"!=e&&(e="ltr"),e!=this.direction&&(this.direction=e,this.iter(function(e){return e.order=null}),this.cm&&Qn(this.cm))})}),Ds.prototype.eachLine=Ds.prototype.iter;for(var Hs=0,Fs=!1,Es={3:"Enter",8:"Backspace",9:"Tab",13:"Enter",16:"Shift",17:"Ctrl",18:"Alt",19:"Pause",20:"CapsLock",27:"Esc",32:"Space",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"Left",38:"Up",39:"Right",40:"Down",44:"PrintScrn",45:"Insert",46:"Delete",59:";",61:"=",91:"Mod",92:"Mod",93:"Mod",106:"*",107:"=",109:"-",110:".",111:"/",127:"Delete",173:"-",186:";",187:"=",188:",",189:"-",190:".",191:"/",192:"`",219:"[",220:"\\",221:"]",222:"'",63232:"Up",63233:"Down",63234:"Left",63235:"Right",63272:"Delete",63273:"Home",63275:"End",63276:"PageUp",63277:"PageDown",63302:"Insert"},Ps=0;Ps<10;Ps++)Es[Ps+48]=Es[Ps+96]=String(Ps);for(var Is=65;Is<=90;Is++)Es[Is]=String.fromCharCode(Is);for(var zs=1;zs<=12;zs++)Es[zs+111]=Es[zs+63235]="F"+zs;var Rs={};Rs.basic={Left:"goCharLeft",Right:"goCharRight",Up:"goLineUp",Down:"goLineDown",End:"goLineEnd",Home:"goLineStartSmart",PageUp:"goPageUp",PageDown:"goPageDown",Delete:"delCharAfter",Backspace:"delCharBefore","Shift-Backspace":"delCharBefore",Tab:"defaultTab","Shift-Tab":"indentAuto",Enter:"newlineAndIndent",Insert:"toggleOverwrite",Esc:"singleSelection"},Rs.pcDefault={"Ctrl-A":"selectAll","Ctrl-D":"deleteLine","Ctrl-Z":"undo","Shift-Ctrl-Z":"redo","Ctrl-Y":"redo","Ctrl-Home":"goDocStart","Ctrl-End":"goDocEnd","Ctrl-Up":"goLineUp","Ctrl-Down":"goLineDown","Ctrl-Left":"goGroupLeft","Ctrl-Right":"goGroupRight","Alt-Left":"goLineStart","Alt-Right":"goLineEnd","Ctrl-Backspace":"delGroupBefore","Ctrl-Delete":"delGroupAfter","Ctrl-S":"save","Ctrl-F":"find","Ctrl-G":"findNext","Shift-Ctrl-G":"findPrev","Shift-Ctrl-F":"replace","Shift-Ctrl-R":"replaceAll","Ctrl-[":"indentLess","Ctrl-]":"indentMore","Ctrl-U":"undoSelection","Shift-Ctrl-U":"redoSelection","Alt-U":"redoSelection",fallthrough:"basic"},Rs.emacsy={"Ctrl-F":"goCharRight","Ctrl-B":"goCharLeft","Ctrl-P":"goLineUp","Ctrl-N":"goLineDown","Alt-F":"goWordRight","Alt-B":"goWordLeft","Ctrl-A":"goLineStart","Ctrl-E":"goLineEnd","Ctrl-V":"goPageDown","Shift-Ctrl-V":"goPageUp","Ctrl-D":"delCharAfter","Ctrl-H":"delCharBefore","Alt-D":"delWordAfter","Alt-Backspace":"delWordBefore","Ctrl-K":"killLine","Ctrl-T":"transposeChars","Ctrl-O":"openLine"},Rs.macDefault={"Cmd-A":"selectAll","Cmd-D":"deleteLine","Cmd-Z":"undo","Shift-Cmd-Z":"redo","Cmd-Y":"redo","Cmd-Home":"goDocStart","Cmd-Up":"goDocStart","Cmd-End":"goDocEnd","Cmd-Down":"goDocEnd","Alt-Left":"goGroupLeft","Alt-Right":"goGroupRight","Cmd-Left":"goLineLeft","Cmd-Right":"goLineRight","Alt-Backspace":"delGroupBefore","Ctrl-Alt-Backspace":"delGroupAfter","Alt-Delete":"delGroupAfter","Cmd-S":"save","Cmd-F":"find","Cmd-G":"findNext","Shift-Cmd-G":"findPrev","Cmd-Alt-F":"replace","Shift-Cmd-Alt-F":"replaceAll","Cmd-[":"indentLess","Cmd-]":"indentMore","Cmd-Backspace":"delWrappedLineLeft","Cmd-Delete":"delWrappedLineRight","Cmd-U":"undoSelection","Shift-Cmd-U":"redoSelection","Ctrl-Up":"goDocStart","Ctrl-Down":"goDocEnd",fallthrough:["basic","emacsy"]},Rs.default=Ml?Rs.macDefault:Rs.pcDefault;var Bs={selectAll:Mi,singleSelection:function(e){return e.setSelection(e.getCursor("anchor"),e.getCursor("head"),Gl)},killLine:function(e){return co(e,function(t){if(t.empty()){var r=M(e.doc,t.head.line).text.length;return t.head.ch==r&&t.head.line<e.lastLine()?{from:t.head,to:E(t.head.line+1,0)}:{from:t.head,to:E(t.head.line,r)}}return{from:t.from(),to:t.to()}})},deleteLine:function(e){return co(e,function(t){return{from:E(t.from().line,0),to:U(e.doc,E(t.to().line+1,0))}})},delLineLeft:function(e){return co(e,function(e){return{from:E(e.from().line,0),to:e.from()}})},delWrappedLineLeft:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5;return{from:e.coordsChar({left:0,top:r},"div"),to:t.from()}})},delWrappedLineRight:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5,n=e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div");return{from:t.from(),to:n}})},undo:function(e){return e.undo()},redo:function(e){return e.redo()},undoSelection:function(e){return e.undoSelection()},redoSelection:function(e){return e.redoSelection()},goDocStart:function(e){return e.extendSelection(E(e.firstLine(),0))},goDocEnd:function(e){return e.extendSelection(E(e.lastLine()))},goLineStart:function(e){return e.extendSelectionsBy(function(t){return vo(e,t.head.line)},{origin:"+move",bias:1})},goLineStartSmart:function(e){return e.extendSelectionsBy(function(t){return yo(e,t.head)},{origin:"+move",bias:1})},goLineEnd:function(e){return e.extendSelectionsBy(function(t){return mo(e,t.head.line)},{origin:"+move",bias:-1})},goLineRight:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div")},Vl)},goLineLeft:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:0,top:r},"div")},Vl)},goLineLeftSmart:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5,n=e.coordsChar({left:0,top:r},"div");return n.ch<e.getLine(n.line).search(/\S/)?yo(e,t.head):n},Vl)},goLineUp:function(e){return e.moveV(-1,"line")},goLineDown:function(e){return e.moveV(1,"line")},goPageUp:function(e){return e.moveV(-1,"page")},goPageDown:function(e){return e.moveV(1,"page")},goCharLeft:function(e){return e.moveH(-1,"char")},goCharRight:function(e){return e.moveH(1,"char")},goColumnLeft:function(e){return e.moveH(-1,"column")},goColumnRight:function(e){return e.moveH(1,"column")},goWordLeft:function(e){return e.moveH(-1,"word")},goGroupRight:function(e){return e.moveH(1,"group")},goGroupLeft:function(e){return e.moveH(-1,"group")},goWordRight:function(e){return e.moveH(1,"word")},delCharBefore:function(e){return e.deleteH(-1,"char")},delCharAfter:function(e){return e.deleteH(1,"char")},delWordBefore:function(e){return e.deleteH(-1,"word")},delWordAfter:function(e){return e.deleteH(1,"word")},delGroupBefore:function(e){return e.deleteH(-1,"group")},delGroupAfter:function(e){return e.deleteH(1,"group")},indentAuto:function(e){return e.indentSelection("smart")},indentMore:function(e){return e.indentSelection("add")},indentLess:function(e){return e.indentSelection("subtract")},insertTab:function(e){return e.replaceSelection("\t")},insertSoftTab:function(e){for(var t=[],r=e.listSelections(),n=e.options.tabSize,i=0;i<r.length;i++){var o=r[i].from(),l=f(e.getLine(o.line),o.ch,n);t.push(p(n-l%n))}e.replaceSelections(t)},defaultTab:function(e){e.somethingSelected()?e.indentSelection("add"):e.execCommand("insertTab")},transposeChars:function(e){return hn(e,function(){for(var t=e.listSelections(),r=[],n=0;n<t.length;n++)if(t[n].empty()){var i=t[n].head,o=M(e.doc,i.line).text;if(o)if(i.ch==o.length&&(i=new E(i.line,i.ch-1)),i.ch>0)i=new E(i.line,i.ch+1),e.replaceRange(o.charAt(i.ch-1)+o.charAt(i.ch-2),E(i.line,i.ch-2),i,"+transpose");else if(i.line>e.doc.first){var l=M(e.doc,i.line-1).text;l&&(i=new E(i.line,1),e.replaceRange(o.charAt(0)+e.doc.lineSeparator()+l.charAt(l.length-1),E(i.line-1,l.length-1),i,"+transpose"))}r.push(new Ts(i,i))}e.setSelections(r)})},newlineAndIndent:function(e){return hn(e,function(){for(var t=e.listSelections(),r=t.length-1;r>=0;r--)e.replaceRange(e.doc.lineSeparator(),t[r].anchor,t[r].head,"+input");t=e.listSelections();for(var n=0;n<t.length;n++)e.indentLine(t[n].from().line,null,!0);jr(e)})},openLine:function(e){return e.replaceSelection("\n","start")},toggleOverwrite:function(e){return e.toggleOverwrite()}},Gs=new Pl,Us=null,Vs=function(e,t,r){this.time=e,this.pos=t,this.button=r};Vs.prototype.compare=function(e,t,r){return this.time+400>e&&0==P(t,this.pos)&&r==this.button};var Ks,js,Xs={toString:function(){return"CodeMirror.Init"}},Ys={},_s={};jo.defaults=Ys,jo.optionHandlers=_s;var $s=[];jo.defineInitHook=function(e){return $s.push(e)};var qs=null,Zs=function(e){this.cm=e,this.lastAnchorNode=this.lastAnchorOffset=this.lastFocusNode=this.lastFocusOffset=null,this.polling=new Pl,this.composing=null,this.gracePeriod=!1,this.readDOMTimeout=null};Zs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()}),"cut"==e.type&&i.replaceSelection("",null,"cut");else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type&&i.operation(function(){i.setSelections(t.ranges,0,Gl),i.replaceSelection("",null,"cut")})}if(e.clipboardData){e.clipboardData.clearData();var r=qs.text.join("\n");if(e.clipboardData.setData("Text",r),e.clipboardData.getData("Text")==r)return void e.preventDefault()}var l=el(),s=l.firstChild;i.display.lineSpace.insertBefore(l,i.display.lineSpace.firstChild),s.value=qs.text.join("\n");var a=document.activeElement;El(s),setTimeout(function(){i.display.lineSpace.removeChild(l),a.focus(),a==o&&n.showPrimarySelection()},50)}}var r=this,n=this,i=n.cm,o=n.div=e.lineDiv;Jo(o,i.options.spellcheck),Ql(o,"paste",function(e){Me(i,e)||qo(e,i)||vl<=11&&setTimeout(dn(i,function(){return r.updateFromDOM()}),20)}),Ql(o,"compositionstart",function(e){r.composing={data:e.data,done:!1}}),Ql(o,"compositionupdate",function(e){r.composing||(r.composing={data:e.data,done:!1})}),Ql(o,"compositionend",function(e){r.composing&&(e.data!=r.composing.data&&r.readFromDOMSoon(),r.composing.done=!0)}),Ql(o,"touchstart",function(){return n.forceCompositionEnd()}),Ql(o,"input",function(){r.composing||r.readFromDOMSoon()}),Ql(o,"copy",t),Ql(o,"cut",t)},Zs.prototype.prepareSelection=function(){var e=Tr(this.cm,!1);return e.focus=this.cm.state.focused,e},Zs.prototype.showSelection=function(e,t){e&&this.cm.display.view.length&&((e.focus||t)&&this.showPrimarySelection(),this.showMultipleSelections(e))},Zs.prototype.showPrimarySelection=function(){var e=window.getSelection(),t=this.cm,r=t.doc.sel.primary(),n=r.from(),i=r.to();if(t.display.viewTo==t.display.viewFrom||n.line>=t.display.viewTo||i.line<t.display.viewFrom)e.removeAllRanges();else{var o=sl(t,e.anchorNode,e.anchorOffset),l=sl(t,e.focusNode,e.focusOffset);if(!o||o.bad||!l||l.bad||0!=P(B(o,l),n)||0!=P(R(o,l),i)){var s=t.display.view,a=n.line>=t.display.viewFrom&&nl(t,n)||{node:s[0].measure.map[2],offset:0},u=i.line<t.display.viewTo&&nl(t,i);if(!u){var c=s[s.length-1].measure,f=c.maps?c.maps[c.maps.length-1]:c.map;u={node:f[f.length-1],offset:f[f.length-2]-f[f.length-3]}}if(a&&u){var h,d=e.rangeCount&&e.getRangeAt(0);try{h=Wl(a.node,a.offset,u.offset,u.node)}catch(e){}h&&(!fl&&t.state.focused?(e.collapse(a.node,a.offset),h.collapsed||(e.removeAllRanges(),e.addRange(h))):(e.removeAllRanges(),e.addRange(h)),d&&null==e.anchorNode?e.addRange(d):fl&&this.startGracePeriod()),this.rememberSelection()}else e.removeAllRanges()}}},Zs.prototype.startGracePeriod=function(){var e=this;clearTimeout(this.gracePeriod),this.gracePeriod=setTimeout(function(){e.gracePeriod=!1,e.selectionChanged()&&e.cm.operation(function(){return e.cm.curOp.selectionChanged=!0})},20)},Zs.prototype.showMultipleSelections=function(e){r(this.cm.display.cursorDiv,e.cursors),r(this.cm.display.selectionDiv,e.selection)},Zs.prototype.rememberSelection=function(){var e=window.getSelection();this.lastAnchorNode=e.anchorNode,this.lastAnchorOffset=e.anchorOffset,this.lastFocusNode=e.focusNode,this.lastFocusOffset=e.focusOffset},Zs.prototype.selectionInEditor=function(){var e=window.getSelection();if(!e.rangeCount)return!1;var t=e.getRangeAt(0).commonAncestorContainer;return o(this.div,t)},Zs.prototype.focus=function(){"nocursor"!=this.cm.options.readOnly&&(this.selectionInEditor()||this.showSelection(this.prepareSelection(),!0),this.div.focus())},Zs.prototype.blur=function(){this.div.blur()},Zs.prototype.getField=function(){return this.div},Zs.prototype.supportsTouch=function(){return!0},Zs.prototype.receivedFocus=function(){function e(){t.cm.state.focused&&(t.pollSelection(),t.polling.set(t.cm.options.pollInterval,e))}var t=this;this.selectionInEditor()?this.pollSelection():hn(this.cm,function(){return t.cm.curOp.selectionChanged=!0}),this.polling.set(this.cm.options.pollInterval,e)},Zs.prototype.selectionChanged=function(){var e=window.getSelection();return e.anchorNode!=this.lastAnchorNode||e.anchorOffset!=this.lastAnchorOffset||e.focusNode!=this.lastFocusNode||e.focusOffset!=this.lastFocusOffset},Zs.prototype.pollSelection=function(){if(null==this.readDOMTimeout&&!this.gracePeriod&&this.selectionChanged()){var e=window.getSelection(),t=this.cm;if(kl&&bl&&this.cm.options.gutters.length&&il(e.anchorNode))return this.cm.triggerOnKeyDown({type:"keydown",keyCode:8,preventDefault:Math.abs}),this.blur(),void this.focus();if(!this.composing){this.rememberSelection();var r=sl(t,e.anchorNode,e.anchorOffset),n=sl(t,e.focusNode,e.focusOffset);r&&n&&hn(t,function(){bi(t.doc,Rn(r,n),Gl),(r.bad||n.bad)&&(t.curOp.selectionChanged=!0)})}}},Zs.prototype.pollContent=function(){null!=this.readDOMTimeout&&(clearTimeout(this.readDOMTimeout),this.readDOMTimeout=null);var e=this.cm,t=e.display,r=e.doc.sel.primary(),n=r.from(),i=r.to();if(0==n.ch&&n.line>e.firstLine()&&(n=E(n.line-1,M(e.doc,n.line-1).length)),i.ch==M(e.doc,i.line).text.length&&i.line<e.lastLine()&&(i=E(i.line+1,0)),n.line<t.viewFrom||i.line>t.viewTo-1)return!1;var o,l,s;n.line==t.viewFrom||0==(o=Lr(e,n.line))?(l=W(t.view[0].line),s=t.view[0].node):(l=W(t.view[o].line),s=t.view[o-1].node.nextSibling);var a,u,c=Lr(e,i.line);if(c==t.view.length-1?(a=t.viewTo-1,u=t.lineDiv.lastChild):(a=W(t.view[c+1].line)-1,u=t.view[c+1].node.previousSibling),!s)return!1;for(var f=e.doc.splitLines(ll(e,s,u,l,a)),h=N(e.doc,E(l,0),E(a,M(e.doc,a).text.length));f.length>1&&h.length>1;)if(g(f)==g(h))f.pop(),h.pop(),a--;else{if(f[0]!=h[0])break;f.shift(),h.shift(),l++}for(var d=0,p=0,v=f[0],m=h[0],y=Math.min(v.length,m.length);d<y&&v.charCodeAt(d)==m.charCodeAt(d);)++d;for(var b=g(f),w=g(h),x=Math.min(b.length-(1==f.length?d:0),w.length-(1==h.length?d:0));p<x&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)++p;if(1==f.length&&1==h.length&&l==n.line)for(;d&&d>n.ch&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)d--,p++;f[f.length-1]=b.slice(0,b.length-p).replace(/^\u200b+/,""),f[0]=f[0].slice(d).replace(/\u200b+$/,"");var C=E(l,d),S=E(a,h.length?g(h).length-p:0);return f.length>1||f[0]||P(C,S)?(Ei(e.doc,f,C,S,"+input"),!0):void 0},Zs.prototype.ensurePolled=function(){this.forceCompositionEnd()},Zs.prototype.reset=function(){this.forceCompositionEnd()},Zs.prototype.forceCompositionEnd=function(){this.composing&&(clearTimeout(this.readDOMTimeout),this.composing=null,this.updateFromDOM(),this.div.blur(),this.div.focus())},Zs.prototype.readFromDOMSoon=function(){var e=this;null==this.readDOMTimeout&&(this.readDOMTimeout=setTimeout(function(){if(e.readDOMTimeout=null,e.composing){if(!e.composing.done)return;e.composing=null}e.updateFromDOM()},80))},Zs.prototype.updateFromDOM=function(){var e=this;!this.cm.isReadOnly()&&this.pollContent()||hn(this.cm,function(){return vn(e.cm)})},Zs.prototype.setUneditable=function(e){e.contentEditable="false"},Zs.prototype.onKeyPress=function(e){0!=e.charCode&&(e.preventDefault(),this.cm.isReadOnly()||dn(this.cm,$o)(this.cm,String.fromCharCode(null==e.charCode?e.keyCode:e.charCode),0))},Zs.prototype.readOnlyChanged=function(e){this.div.contentEditable=String("nocursor"!=e)},Zs.prototype.onContextMenu=function(){},Zs.prototype.resetPosition=function(){},Zs.prototype.needsContentAttribute=!0;var Qs=function(e){this.cm=e,this.prevInput="",this.pollingFast=!1,this.polling=new Pl,this.hasSelection=!1,this.composing=null};Qs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()});else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type?i.setSelections(t.ranges,null,Gl):(n.prevInput="",l.value=t.text.join("\n"),El(l))}"cut"==e.type&&(i.state.cutIncoming=!0)}}var r=this,n=this,i=this.cm,o=this.wrapper=el(),l=this.textarea=o.firstChild;e.wrapper.insertBefore(o,e.wrapper.firstChild),Ll&&(l.style.width="0px"),Ql(l,"input",function(){gl&&vl>=9&&r.hasSelection&&(r.hasSelection=null),n.poll()}),Ql(l,"paste",function(e){Me(i,e)||qo(e,i)||(i.state.pasteIncoming=!0,n.fastPoll())}),Ql(l,"cut",t),Ql(l,"copy",t),Ql(e.scroller,"paste",function(t){Ft(e,t)||Me(i,t)||(i.state.pasteIncoming=!0,n.focus())}),Ql(e.lineSpace,"selectstart",function(t){Ft(e,t)||We(t)}),Ql(l,"compositionstart",function(){var e=i.getCursor("from");n.composing&&n.composing.range.clear(),n.composing={start:e,range:i.markText(e,i.getCursor("to"),{className:"CodeMirror-composing"})}}),Ql(l,"compositionend",function(){n.composing&&(n.poll(),n.composing.range.clear(),n.composing=null)})},Qs.prototype.prepareSelection=function(){var e=this.cm,t=e.display,r=e.doc,n=Tr(e);if(e.options.moveInputWithCursor){var i=sr(e,r.sel.primary().head,"div"),o=t.wrapper.getBoundingClientRect(),l=t.lineDiv.getBoundingClientRect();n.teTop=Math.max(0,Math.min(t.wrapper.clientHeight-10,i.top+l.top-o.top)),n.teLeft=Math.max(0,Math.min(t.wrapper.clientWidth-10,i.left+l.left-o.left))}return n},Qs.prototype.showSelection=function(e){var t=this.cm.display;r(t.cursorDiv,e.cursors),r(t.selectionDiv,e.selection),null!=e.teTop&&(this.wrapper.style.top=e.teTop+"px",this.wrapper.style.left=e.teLeft+"px")},Qs.prototype.reset=function(e){if(!this.contextMenuPending&&!this.composing){var t=this.cm;if(t.somethingSelected()){this.prevInput="";var r=t.getSelection();this.textarea.value=r,t.state.focused&&El(this.textarea),gl&&vl>=9&&(this.hasSelection=r)}else e||(this.prevInput=this.textarea.value="",gl&&vl>=9&&(this.hasSelection=null))}},Qs.prototype.getField=function(){return this.textarea},Qs.prototype.supportsTouch=function(){return!1},Qs.prototype.focus=function(){if("nocursor"!=this.cm.options.readOnly&&(!Tl||l()!=this.textarea))try{this.textarea.focus()}catch(e){}},Qs.prototype.blur=function(){this.textarea.blur()},Qs.prototype.resetPosition=function(){this.wrapper.style.top=this.wrapper.style.left=0},Qs.prototype.receivedFocus=function(){this.slowPoll()},Qs.prototype.slowPoll=function(){var e=this;this.pollingFast||this.polling.set(this.cm.options.pollInterval,function(){e.poll(),e.cm.state.focused&&e.slowPoll()})},Qs.prototype.fastPoll=function(){function e(){r.poll()||t?(r.pollingFast=!1,r.slowPoll()):(t=!0,r.polling.set(60,e))}var t=!1,r=this;r.pollingFast=!0,r.polling.set(20,e)},Qs.prototype.poll=function(){var e=this,t=this.cm,r=this.textarea,n=this.prevInput;if(this.contextMenuPending||!t.state.focused||ts(r)&&!n&&!this.composing||t.isReadOnly()||t.options.disableInput||t.state.keySeq)return!1;var i=r.value;if(i==n&&!t.somethingSelected())return!1;if(gl&&vl>=9&&this.hasSelection===i||Ml&&/[\uf700-\uf7ff]/.test(i))return t.display.input.reset(),!1;if(t.doc.sel==t.display.selForContextMenu){var o=i.charCodeAt(0);if(8203!=o||n||(n="​"),8666==o)return this.reset(),this.cm.execCommand("undo")}for(var l=0,s=Math.min(n.length,i.length);l<s&&n.charCodeAt(l)==i.charCodeAt(l);)++l;return hn(t,function(){$o(t,i.slice(l),n.length-l,null,e.composing?"*compose":null),i.length>1e3||i.indexOf("\n")>-1?r.value=e.prevInput="":e.prevInput=i,e.composing&&(e.composing.range.clear(),e.composing.range=t.markText(e.composing.start,t.getCursor("to"),{className:"CodeMirror-composing"}))}),!0},Qs.prototype.ensurePolled=function(){this.pollingFast&&this.poll()&&(this.pollingFast=!1)},Qs.prototype.onKeyPress=function(){gl&&vl>=9&&(this.hasSelection=null),this.fastPoll()},Qs.prototype.onContextMenu=function(e){function t(){if(null!=l.selectionStart){var e=i.somethingSelected(),t="​"+(e?l.value:"");l.value="⇚",l.value=t,n.prevInput=e?"":"​",l.selectionStart=1,l.selectionEnd=t.length,o.selForContextMenu=i.doc.sel}}function r(){if(n.contextMenuPending=!1,n.wrapper.style.cssText=c,l.style.cssText=u,gl&&vl<9&&o.scrollbars.setScrollTop(o.scroller.scrollTop=a),null!=l.selectionStart){(!gl||gl&&vl<9)&&t();var e=0,r=function(){o.selForContextMenu==i.doc.sel&&0==l.selectionStart&&l.selectionEnd>0&&"​"==n.prevInput?dn(i,Mi)(i):e++<10?o.detectingSelectAll=setTimeout(r,500):(o.selForContextMenu=null,o.input.reset())};o.detectingSelectAll=setTimeout(r,200)}}var n=this,i=n.cm,o=i.display,l=n.textarea,s=Sr(i,e),a=o.scroller.scrollTop;if(s&&!wl){i.options.resetSelectionOnContextMenu&&-1==i.doc.sel.contains(s)&&dn(i,bi)(i.doc,Rn(s),Gl);var u=l.style.cssText,c=n.wrapper.style.cssText;n.wrapper.style.cssText="position: absolute";var f=n.wrapper.getBoundingClientRect();l.style.cssText="position: absolute; width: 30px; height: 30px;\n      top: "+(e.clientY-f.top-5)+"px; left: "+(e.clientX-f.left-5)+"px;\n      z-index: 1000; background: "+(gl?"rgba(255, 255, 255, .05)":"transparent")+";\n      outline: none; border-width: 0; outline: none; overflow: hidden; opacity: .05; filter: alpha(opacity=5);";var h;if(ml&&(h=window.scrollY),o.input.focus(),ml&&window.scrollTo(null,h),o.input.reset(),i.somethingSelected()||(l.value=n.prevInput=" "),n.contextMenuPending=!0,o.selForContextMenu=i.doc.sel,clearTimeout(o.detectingSelectAll),gl&&vl>=9&&t(),Hl){Fe(e);var d=function(){ke(window,"mouseup",d),setTimeout(r,20)};Ql(window,"mouseup",d)}else setTimeout(r,50)}},Qs.prototype.readOnlyChanged=function(e){e||this.reset(),this.textarea.disabled="nocursor"==e},Qs.prototype.setUneditable=function(){},Qs.prototype.needsContentAttribute=!1,function(e){function t(t,n,i,o){e.defaults[t]=n,i&&(r[t]=o?function(e,t,r){r!=Xs&&i(e,t,r)}:i)}var r=e.optionHandlers;e.defineOption=t,e.Init=Xs,t("value","",function(e,t){return e.setValue(t)},!0),t("mode",null,function(e,t){e.doc.modeOption=t,jn(e)},!0),t("indentUnit",2,jn,!0),t("indentWithTabs",!1),t("smartIndent",!0),t("tabSize",4,function(e){Xn(e),er(e),vn(e)},!0),t("lineSeparator",null,function(e,t){if(e.doc.lineSep=t,t){var r=[],n=e.doc.first;e.doc.iter(function(e){for(var i=0;;){var o=e.text.indexOf(t,i);if(-1==o)break;i=o+t.length,r.push(E(n,o))}n++});for(var i=r.length-1;i>=0;i--)Ei(e.doc,t,r[i],E(r[i].line,r[i].ch+t.length))}}),t("specialChars",/[\u0000-\u001f\u007f-\u009f\u00ad\u061c\u200b-\u200f\u2028\u2029\ufeff]/g,function(e,t,r){e.state.specialChars=new RegExp(t.source+(t.test("\t")?"":"|\t"),"g"),r!=Xs&&e.refresh()}),t("specialCharPlaceholder",at,function(e){return e.refresh()},!0),t("electricChars",!0),t("inputStyle",Tl?"contenteditable":"textarea",function(){throw new Error("inputStyle can not (yet) be changed in a running editor")},!0),t("spellcheck",!1,function(e,t){return e.getInputField().spellcheck=t},!0),t("rtlMoveVisually",!Ol),t("wholeLineUpdateBefore",!0),t("theme","default",function(e){Go(e),Uo(e)},!0),t("keyMap","default",function(e,t,r){var n=uo(t),i=r!=Xs&&uo(r);i&&i.detach&&i.detach(e,n),n.attach&&n.attach(e,i||null)}),t("extraKeys",null),t("configureMouse",null),t("lineWrapping",!1,Ko,!0),t("gutters",[],function(e){Fn(e.options),Uo(e)},!0),t("fixedGutter",!0,function(e,t){e.display.gutters.style.left=t?wr(e.display)+"px":"0",e.refresh()},!0),t("coverGutterNextToScrollbar",!1,function(e){return en(e)},!0),t("scrollbarStyle","native",function(e){rn(e),en(e),e.display.scrollbars.setScrollTop(e.doc.scrollTop),e.display.scrollbars.setScrollLeft(e.doc.scrollLeft)},!0),t("lineNumbers",!1,function(e){Fn(e.options),Uo(e)},!0),t("firstLineNumber",1,Uo,!0),t("lineNumberFormatter",function(e){return e},Uo,!0),t("showCursorWhenSelecting",!1,kr,!0),t("resetSelectionOnContextMenu",!0),t("lineWiseCopyCut",!0),t("pasteLinesPerSelection",!0),t("readOnly",!1,function(e,t){"nocursor"==t&&(Fr(e),e.display.input.blur()),e.display.input.readOnlyChanged(t)}),t("disableInput",!1,function(e,t){t||e.display.input.reset()},!0),t("dragDrop",!0,Vo),t("allowDropFileTypes",null),t("cursorBlinkRate",530),t("cursorScrollMargin",0),t("cursorHeight",1,kr,!0),t("singleCursorHeightPerLine",!0,kr,!0),t("workTime",100),t("workDelay",100),t("flattenSpans",!0,Xn,!0),t("addModeClass",!1,Xn,!0),t("pollInterval",100),t("undoDepth",200,function(e,t){return e.doc.history.undoDepth=t}),t("historyEventDelay",1250),t("viewportMargin",10,function(e){return e.refresh()},!0),t("maxHighlightLength",1e4,Xn,!0),t("moveInputWithCursor",!0,function(e,t){t||e.display.input.resetPosition()}),t("tabindex",null,function(e,t){return e.display.input.getField().tabIndex=t||""}),t("autofocus",null),t("direction","ltr",function(e,t){return e.doc.setDirection(t)},!0)}(jo),function(e){var t=e.optionHandlers,r=e.helpers={};e.prototype={constructor:e,focus:function(){window.focus(),this.display.input.focus()},setOption:function(e,r){var n=this.options,i=n[e];n[e]==r&&"mode"!=e||(n[e]=r,t.hasOwnProperty(e)&&dn(this,t[e])(this,r,i),Te(this,"optionChange",this,e))},getOption:function(e){return this.options[e]},getDoc:function(){return this.doc},addKeyMap:function(e,t){this.state.keyMaps[t?"push":"unshift"](uo(e))},removeKeyMap:function(e){for(var t=this.state.keyMaps,r=0;r<t.length;++r)if(t[r]==e||t[r].name==e)return t.splice(r,1),!0},addOverlay:pn(function(t,r){var n=t.token?t:e.getMode(this.options,t);if(n.startState)throw new Error("Overlays may not be stateful.");m(this.state.overlays,{mode:n,modeSpec:t,opaque:r&&r.opaque,priority:r&&r.priority||0},function(e){return e.priority}),this.state.modeGen++,vn(this)}),removeOverlay:pn(function(e){for(var t=this,r=this.state.overlays,n=0;n<r.length;++n){var i=r[n].modeSpec;if(i==e||"string"==typeof e&&i.name==e)return r.splice(n,1),t.state.modeGen++,void vn(t)}}),indentLine:pn(function(e,t,r){"string"!=typeof t&&"number"!=typeof t&&(t=null==t?this.options.smartIndent?"smart":"prev":t?"add":"subtract"),H(this.doc,e)&&Yo(this,e,t,r)}),indentSelection:pn(function(e){for(var t=this,r=this.doc.sel.ranges,n=-1,i=0;i<r.length;i++){var o=r[i];if(o.empty())o.head.line>n&&(Yo(t,o.head.line,e,!0),n=o.head.line,i==t.doc.sel.primIndex&&jr(t));else{var l=o.from(),s=o.to(),a=Math.max(n,l.line);n=Math.min(t.lastLine(),s.line-(s.ch?0:1))+1;for(var u=a;u<n;++u)Yo(t,u,e);var c=t.doc.sel.ranges;0==l.ch&&r.length==c.length&&c[i].from().ch>0&&gi(t.doc,i,new Ts(l,c[i].to()),Gl)}}}),getTokenAt:function(e,t){return Je(this,e,t)},getLineTokens:function(e,t){return Je(this,E(e),t,!0)},getTokenTypeAt:function(e){e=U(this.doc,e);var t,r=_e(this,M(this.doc,e.line)),n=0,i=(r.length-1)/2,o=e.ch;if(0==o)t=r[2];else for(;;){var l=n+i>>1;if((l?r[2*l-1]:0)>=o)i=l;else{if(!(r[2*l+1]<o)){t=r[2*l+2];break}n=l+1}}var s=t?t.indexOf("overlay "):-1;return s<0?t:0==s?null:t.slice(0,s-1)},getModeAt:function(t){var r=this.doc.mode;return r.innerMode?e.innerMode(r,this.getTokenAt(t).state).mode:r},getHelper:function(e,t){return this.getHelpers(e,t)[0]},getHelpers:function(e,t){var n=this,i=[];if(!r.hasOwnProperty(t))return i;var o=r[t],l=this.getModeAt(e);if("string"==typeof l[t])o[l[t]]&&i.push(o[l[t]]);else if(l[t])for(var s=0;s<l[t].length;s++){var a=o[l[t][s]];a&&i.push(a)}else l.helperType&&o[l.helperType]?i.push(o[l.helperType]):o[l.name]&&i.push(o[l.name]);for(var u=0;u<o._global.length;u++){var c=o._global[u];c.pred(l,n)&&-1==h(i,c.val)&&i.push(c.val)}return i},getStateAfter:function(e,t){var r=this.doc;return e=G(r,null==e?r.first+r.size-1:e),$e(this,e+1,t).state},cursorCoords:function(e,t){var r,n=this.doc.sel.primary();return r=null==e?n.head:"object"==typeof e?U(this.doc,e):e?n.from():n.to(),sr(this,r,t||"page")},charCoords:function(e,t){return lr(this,U(this.doc,e),t||"page")},coordsChar:function(e,t){return e=or(this,e,t||"page"),cr(this,e.left,e.top)},lineAtHeight:function(e,t){return e=or(this,{top:e,left:0},t||"page").top,D(this.doc,e+this.display.viewOffset)},heightAtLine:function(e,t,r){var n,i=!1;if("number"==typeof e){var o=this.doc.first+this.doc.size-1;e<this.doc.first?e=this.doc.first:e>o&&(e=o,i=!0),n=M(this.doc,e)}else n=e;return ir(this,n,{top:0,left:0},t||"page",r||i).top+(i?this.doc.height-ye(n):0)},defaultTextHeight:function(){return mr(this.display)},defaultCharWidth:function(){return yr(this.display)},getViewport:function(){return{from:this.display.viewFrom,to:this.display.viewTo}},addWidget:function(e,t,r,n,i){var o=this.display,l=(e=sr(this,U(this.doc,e))).bottom,s=e.left;if(t.style.position="absolute",t.setAttribute("cm-ignore-events","true"),this.display.input.setUneditable(t),o.sizer.appendChild(t),"over"==n)l=e.top;else if("above"==n||"near"==n){var a=Math.max(o.wrapper.clientHeight,this.doc.height),u=Math.max(o.sizer.clientWidth,o.lineSpace.clientWidth);("above"==n||e.bottom+t.offsetHeight>a)&&e.top>t.offsetHeight?l=e.top-t.offsetHeight:e.bottom+t.offsetHeight<=a&&(l=e.bottom),s+t.offsetWidth>u&&(s=u-t.offsetWidth)}t.style.top=l+"px",t.style.left=t.style.right="","right"==i?(s=o.sizer.clientWidth-t.offsetWidth,t.style.right="0px"):("left"==i?s=0:"middle"==i&&(s=(o.sizer.clientWidth-t.offsetWidth)/2),t.style.left=s+"px"),r&&Ur(this,{left:s,top:l,right:s+t.offsetWidth,bottom:l+t.offsetHeight})},triggerOnKeyDown:pn(Lo),triggerOnKeyPress:pn(Mo),triggerOnKeyUp:To,triggerOnMouseDown:pn(Oo),execCommand:function(e){if(Bs.hasOwnProperty(e))return Bs[e].call(null,this)},triggerElectric:pn(function(e){Zo(this,e)}),findPosH:function(e,t,r,n){var i=this,o=1;t<0&&(o=-1,t=-t);for(var l=U(this.doc,e),s=0;s<t&&!(l=tl(i.doc,l,o,r,n)).hitSide;++s);return l},moveH:pn(function(e,t){var r=this;this.extendSelectionsBy(function(n){return r.display.shift||r.doc.extend||n.empty()?tl(r.doc,n.head,e,t,r.options.rtlMoveVisually):e<0?n.from():n.to()},Vl)}),deleteH:pn(function(e,t){var r=this.doc.sel,n=this.doc;r.somethingSelected()?n.replaceSelection("",null,"+delete"):co(this,function(r){var i=tl(n,r.head,e,t,!1);return e<0?{from:i,to:r.head}:{from:r.head,to:i}})}),findPosV:function(e,t,r,n){var i=this,o=1,l=n;t<0&&(o=-1,t=-t);for(var s=U(this.doc,e),a=0;a<t;++a){var u=sr(i,s,"div");if(null==l?l=u.left:u.left=l,(s=rl(i,u,o,r)).hitSide)break}return s},moveV:pn(function(e,t){var r=this,n=this.doc,i=[],o=!this.display.shift&&!n.extend&&n.sel.somethingSelected();if(n.extendSelectionsBy(function(l){if(o)return e<0?l.from():l.to();var s=sr(r,l.head,"div");null!=l.goalColumn&&(s.left=l.goalColumn),i.push(s.left);var a=rl(r,s,e,t);return"page"==t&&l==n.sel.primary()&&Kr(r,lr(r,a,"div").top-s.top),a},Vl),i.length)for(var l=0;l<n.sel.ranges.length;l++)n.sel.ranges[l].goalColumn=i[l]}),findWordAt:function(e){var t=M(this.doc,e.line).text,r=e.ch,n=e.ch;if(t){var i=this.getHelper(e,"wordChars");"before"!=e.sticky&&n!=t.length||!r?++n:--r;for(var o=t.charAt(r),l=x(o,i)?function(e){return x(e,i)}:/\s/.test(o)?function(e){return/\s/.test(e)}:function(e){return!/\s/.test(e)&&!x(e)};r>0&&l(t.charAt(r-1));)--r;for(;n<t.length&&l(t.charAt(n));)++n}return new Ts(E(e.line,r),E(e.line,n))},toggleOverwrite:function(e){null!=e&&e==this.state.overwrite||((this.state.overwrite=!this.state.overwrite)?s(this.display.cursorDiv,"CodeMirror-overwrite"):Fl(this.display.cursorDiv,"CodeMirror-overwrite"),Te(this,"overwriteToggle",this,this.state.overwrite))},hasFocus:function(){return this.display.input.getField()==l()},isReadOnly:function(){return!(!this.options.readOnly&&!this.doc.cantEdit)},scrollTo:pn(function(e,t){Xr(this,e,t)}),getScrollInfo:function(){var e=this.display.scroller;return{left:e.scrollLeft,top:e.scrollTop,height:e.scrollHeight-zt(this)-this.display.barHeight,width:e.scrollWidth-zt(this)-this.display.barWidth,clientHeight:Bt(this),clientWidth:Rt(this)}},scrollIntoView:pn(function(e,t){null==e?(e={from:this.doc.sel.primary().head,to:null},null==t&&(t=this.options.cursorScrollMargin)):"number"==typeof e?e={from:E(e,0),to:null}:null==e.from&&(e={from:e,to:null}),e.to||(e.to=e.from),e.margin=t||0,null!=e.from.line?Yr(this,e):$r(this,e.from,e.to,e.margin)}),setSize:pn(function(e,t){var r=this,n=function(e){return"number"==typeof e||/^\d+$/.test(String(e))?e+"px":e};null!=e&&(this.display.wrapper.style.width=n(e)),null!=t&&(this.display.wrapper.style.height=n(t)),this.options.lineWrapping&&Jt(this);var i=this.display.viewFrom;this.doc.iter(i,this.display.viewTo,function(e){if(e.widgets)for(var t=0;t<e.widgets.length;t++)if(e.widgets[t].noHScroll){mn(r,i,"widget");break}++i}),this.curOp.forceUpdate=!0,Te(this,"refresh",this)}),operation:function(e){return hn(this,e)},startOperation:function(){return nn(this)},endOperation:function(){return on(this)},refresh:pn(function(){var e=this.display.cachedTextHeight;vn(this),this.curOp.forceUpdate=!0,er(this),Xr(this,this.doc.scrollLeft,this.doc.scrollTop),Wn(this),(null==e||Math.abs(e-mr(this.display))>.5)&&Cr(this),Te(this,"refresh",this)}),swapDoc:pn(function(e){var t=this.doc;return t.cm=null,qn(this,e),er(this),this.display.input.reset(),Xr(this,e.scrollLeft,e.scrollTop),this.curOp.forceScroll=!0,bt(this,"swapDoc",this,t),t}),getInputField:function(){return this.display.input.getField()},getWrapperElement:function(){return this.display.wrapper},getScrollerElement:function(){return this.display.scroller},getGutterElement:function(){return this.display.gutters}},Ae(e),e.registerHelper=function(t,n,i){r.hasOwnProperty(t)||(r[t]=e[t]={_global:[]}),r[t][n]=i},e.registerGlobalHelper=function(t,n,i,o){e.registerHelper(t,n,o),r[t]._global.push({pred:i,val:o})}}(jo);var Js="iter insert remove copy getEditor constructor".split(" ");for(var ea in Ds.prototype)Ds.prototype.hasOwnProperty(ea)&&h(Js,ea)<0&&(jo.prototype[ea]=function(e){return function(){return e.apply(this.doc,arguments)}}(Ds.prototype[ea]));return Ae(Ds),jo.inputStyles={textarea:Qs,contenteditable:Zs},jo.defineMode=function(e){jo.defaults.mode||"null"==e||(jo.defaults.mode=e),Be.apply(this,arguments)},jo.defineMIME=function(e,t){os[e]=t},jo.defineMode("null",function(){return{token:function(e){return e.skipToEnd()}}}),jo.defineMIME("text/plain","null"),jo.defineExtension=function(e,t){jo.prototype[e]=t},jo.defineDocExtension=function(e,t){Ds.prototype[e]=t},jo.fromTextArea=function(e,t){function r(){e.value=a.getValue()}if(t=t?c(t):{},t.value=e.value,!t.tabindex&&e.tabIndex&&(t.tabindex=e.tabIndex),!t.placeholder&&e.placeholder&&(t.placeholder=e.placeholder),null==t.autofocus){var n=l();t.autofocus=n==e||null!=e.getAttribute("autofocus")&&n==document.body}var i;if(e.form&&(Ql(e.form,"submit",r),!t.leaveSubmitMethodAlone)){var o=e.form;i=o.submit;try{var s=o.submit=function(){r(),o.submit=i,o.submit(),o.submit=s}}catch(e){}}t.finishInit=function(t){t.save=r,t.getTextArea=function(){return e},t.toTextArea=function(){t.toTextArea=isNaN,r(),e.parentNode.removeChild(t.getWrapperElement()),e.style.display="",e.form&&(ke(e.form,"submit",r),"function"==typeof e.form.submit&&(e.form.submit=i))}},e.style.display="none";var a=jo(function(t){return e.parentNode.insertBefore(t,e.nextSibling)},t);return a},function(e){e.off=ke,e.on=Ql,e.wheelEventPixels=Pn,e.Doc=Ds,e.splitLines=es,e.countColumn=f,e.findColumn=d,e.isWordChar=w,e.Pass=Bl,e.signal=Te,e.Line=fs,e.changeEnd=Bn,e.scrollbarModel=ws,e.Pos=E,e.cmpPos=P,e.modes=is,e.mimeModes=os,e.resolveMode=Ge,e.getMode=Ue,e.modeExtensions=ls,e.extendMode=Ve,e.copyState=Ke,e.startState=Xe,e.innerMode=je,e.commands=Bs,e.keyMap=Rs,e.keyName=ao,e.isModifierKey=lo,e.lookupKey=oo,e.normalizeKeyMap=io,e.StringStream=ss,e.SharedTextMarker=As,e.TextMarker=Os,e.LineWidget=Ms,e.e_preventDefault=We,e.e_stopPropagation=De,e.e_stop=Fe,e.addClass=s,e.contains=o,e.rmClass=Fl,e.keyNames=Es}(jo),jo.version="5.30.0",jo});
      !function(e){"object"==typeof exports&&"object"==typeof module?e(require("../../lib/codemirror")):"function"==typeof define&&define.amd?define(["../../lib/codemirror"],e):e(CodeMirror)}(function(e){"use strict";function t(e,t,n,r,o,a){this.indented=e,this.column=t,this.type=n,this.info=r,this.align=o,this.prev=a}function n(e,n,r,o){var a=e.indented;return e.context&&"statement"==e.context.type&&"statement"!=r&&(a=e.context.indented),e.context=new t(a,n,r,o,null,e.context)}function r(e){var t=e.context.type;return")"!=t&&"]"!=t&&"}"!=t||(e.indented=e.context.indented),e.context=e.context.prev}function o(e,t,n){return"variable"==t.prevToken||"type"==t.prevToken||(!!/\S(?:[^- ]>|[*\]])\s*$|\*$/.test(e.string.slice(0,n))||(!(!t.typeAtEndOfLine||e.column()!=e.indentation())||void 0))}function a(e){for(;;){if(!e||"top"==e.type)return!0;if("}"==e.type&&"namespace"!=e.prev.info)return!1;e=e.prev}}function i(e){for(var t={},n=e.split(" "),r=0;r<n.length;++r)t[n[r]]=!0;return t}function l(e,t){return"function"==typeof e?e(t):e.propertyIsEnumerable(t)}function s(e,t){if(!t.startOfLine)return!1;for(var n,r=null;n=e.peek();){if("\\"==n&&e.match(/^.$/)){r=s;break}if("/"==n&&e.match(/^\/[\/\*]/,!1))break;e.next()}return t.tokenize=r,"meta"}function c(e,t){return"type"==t.prevToken&&"type"}function u(e){return e.eatWhile(/[\w\.']/),"number"}function d(e,t){if(e.backUp(1),e.match(/(R|u8R|uR|UR|LR)/)){var n=e.match(/"([^\s\\()]{0,16})\(/);return!!n&&(t.cpp11RawStringDelim=n[1],t.tokenize=m,m(e,t))}return e.match(/(u8|u|U|L)/)?!!e.match(/["']/,!1)&&"string":(e.next(),!1)}function f(e){var t=/(\w+)::~?(\w+)$/.exec(e);return t&&t[1]==t[2]}function p(e,t){for(var n;null!=(n=e.next());)if('"'==n&&!e.eat('"')){t.tokenize=null;break}return"string"}function m(e,t){var n=t.cpp11RawStringDelim.replace(/[^\w\s]/g,"\\$&");return e.match(new RegExp(".*?\\)"+n+'"'))?t.tokenize=null:e.skipToEnd(),"string"}function h(t,n){function r(e){if(e)for(var t in e)e.hasOwnProperty(t)&&o.push(t)}"string"==typeof t&&(t=[t]);var o=[];r(n.keywords),r(n.types),r(n.builtin),r(n.atoms),o.length&&(n.helperType=t[0],e.registerHelper("hintWords",t[0],o));for(var a=0;a<t.length;++a)e.defineMIME(t[a],n)}function g(e,t){for(var n=!1;!e.eol();){if(!n&&e.match('"""')){t.tokenize=null;break}n="\\"==e.next()&&!n}return"string"}function y(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!e&&!o&&t.match('"')){a=!0;break}if(e&&t.match('"""')){a=!0;break}r=t.next(),!o&&"$"==r&&t.match("{")&&t.skipTo("}"),o=!o&&"\\"==r&&!e}return!a&&e||(n.tokenize=null),"string"}}function x(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!o&&t.match('"')&&("single"==e||t.match('""'))){a=!0;break}if(!o&&t.match("``")){w=x(e),a=!0;break}r=t.next(),o="single"==e&&!o&&"\\"==r}return a&&(n.tokenize=null),"string"}}e.defineMode("clike",function(i,s){function c(e,t){var n=e.next();if(S[n]){var r=S[n](e,t);if(!1!==r)return r}if('"'==n||"'"==n)return t.tokenize=u(n),t.tokenize(e,t);if(D.test(n))return p=n,null;if(L.test(n)){if(e.backUp(1),e.match(I))return"number";e.next()}if("/"==n){if(e.eat("*"))return t.tokenize=d,d(e,t);if(e.eat("/"))return e.skipToEnd(),"comment"}if(F.test(n)){for(;!e.match(/^\/[\/*]/,!1)&&e.eat(F););return"operator"}if(e.eatWhile(z),P)for(;e.match(P);)e.eatWhile(z);var o=e.current();return l(x,o)?(l(w,o)&&(p="newstatement"),l(v,o)&&(m=!0),"keyword"):l(b,o)?"type":l(k,o)?(l(w,o)&&(p="newstatement"),"builtin"):l(_,o)?"atom":"variable"}function u(e){return function(t,n){for(var r,o=!1,a=!1;null!=(r=t.next());){if(r==e&&!o){a=!0;break}o=!o&&"\\"==r}return(a||!o&&!C)&&(n.tokenize=null),"string"}}function d(e,t){for(var n,r=!1;n=e.next();){if("/"==n&&r){t.tokenize=null;break}r="*"==n}return"comment"}function f(e,t){s.typeFirstDefinitions&&e.eol()&&a(t.context)&&(t.typeAtEndOfLine=o(e,t,e.pos))}var p,m,h=i.indentUnit,g=s.statementIndentUnit||h,y=s.dontAlignCalls,x=s.keywords||{},b=s.types||{},k=s.builtin||{},w=s.blockKeywords||{},v=s.defKeywords||{},_=s.atoms||{},S=s.hooks||{},C=s.multiLineStrings,T=!1!==s.indentStatements,M=!1!==s.indentSwitch,P=s.namespaceSeparator,D=s.isPunctuationChar||/[\[\]{}\(\),;\:\.]/,L=s.numberStart||/[\d\.]/,I=s.number||/^(?:0x[a-f\d]+|0b[01]+|(?:\d+\.?\d*|\.\d+)(?:e[-+]?\d+)?)(u|ll?|l|f)?/i,F=s.isOperatorChar||/[+\-*&%=<>!?|\/]/,z=s.isIdentifierChar||/[\w\$_\xa1-\uffff]/;return{startState:function(e){return{tokenize:null,context:new t((e||0)-h,0,"top",null,!1),indented:0,startOfLine:!0,prevToken:null}},token:function(e,t){var i=t.context;if(e.sol()&&(null==i.align&&(i.align=!1),t.indented=e.indentation(),t.startOfLine=!0),e.eatSpace())return f(e,t),null;p=m=null;var l=(t.tokenize||c)(e,t);if("comment"==l||"meta"==l)return l;if(null==i.align&&(i.align=!0),";"==p||":"==p||","==p&&e.match(/^\s*(?:\/\/.*)?$/,!1))for(;"statement"==t.context.type;)r(t);else if("{"==p)n(t,e.column(),"}");else if("["==p)n(t,e.column(),"]");else if("("==p)n(t,e.column(),")");else if("}"==p){for(;"statement"==i.type;)i=r(t);for("}"==i.type&&(i=r(t));"statement"==i.type;)i=r(t)}else p==i.type?r(t):T&&(("}"==i.type||"top"==i.type)&&";"!=p||"statement"==i.type&&"newstatement"==p)&&n(t,e.column(),"statement",e.current());if("variable"==l&&("def"==t.prevToken||s.typeFirstDefinitions&&o(e,t,e.start)&&a(t.context)&&e.match(/^\s*\(/,!1))&&(l="def"),S.token){var u=S.token(e,t,l);void 0!==u&&(l=u)}return"def"==l&&!1===s.styleDefs&&(l="variable"),t.startOfLine=!1,t.prevToken=m?"def":l||p,f(e,t),l},indent:function(t,n){if(t.tokenize!=c&&null!=t.tokenize||t.typeAtEndOfLine)return e.Pass;var r=t.context,o=n&&n.charAt(0);if("statement"==r.type&&"}"==o&&(r=r.prev),s.dontIndentStatements)for(;"statement"==r.type&&s.dontIndentStatements.test(r.info);)r=r.prev;if(S.indent){var a=S.indent(t,r,n);if("number"==typeof a)return a}var i=o==r.type,l=r.prev&&"switch"==r.prev.info;if(s.allmanIndentation&&/[{(]/.test(o)){for(;"top"!=r.type&&"}"!=r.type;)r=r.prev;return r.indented}return"statement"==r.type?r.indented+("{"==o?0:g):!r.align||y&&")"==r.type?")"!=r.type||i?r.indented+(i?0:h)+(i||!l||/^(?:case|default)\b/.test(n)?0:h):r.indented+g:r.column+(i?0:1)},electricInput:M?/^\s*(?:case .*?:|default:|\{\}?|\})$/:/^\s*[{}]$/,blockCommentStart:"/*",blockCommentEnd:"*/",lineComment:"//",fold:"brace"}});var b="auto if break case register continue return default do sizeof static else struct switch extern typedef union for goto while enum const volatile",k="int long char short double float unsigned signed void size_t ptrdiff_t";h(["text/x-csrc","text/x-c","text/x-chdr"],{name:"clike",keywords:i(b),types:i(k+" bool _Complex _Bool float_t double_t intptr_t intmax_t int8_t int16_t int32_t int64_t uintptr_t uintmax_t uint8_t uint16_t uint32_t uint64_t"),blockKeywords:i("case do else for if switch while struct"),defKeywords:i("struct"),typeFirstDefinitions:!0,atoms:i("null true false"),hooks:{"#":s,"*":c},modeProps:{fold:["brace","include"]}}),h(["text/x-c++src","text/x-c++hdr"],{name:"clike",keywords:i(b+" asm dynamic_cast namespace reinterpret_cast try explicit new static_cast typeid catch operator template typename class friend private this using const_cast inline public throw virtual delete mutable protected alignas alignof constexpr decltype nullptr noexcept thread_local final static_assert override"),types:i(k+" bool wchar_t"),blockKeywords:i("catch class do else finally for if struct switch try while"),defKeywords:i("class namespace struct enum union"),typeFirstDefinitions:!0,atoms:i("true false null"),dontIndentStatements:/^template$/,isIdentifierChar:/[\w\$_~\xa1-\uffff]/,hooks:{"#":s,"*":c,u:d,U:d,L:d,R:d,0:u,1:u,2:u,3:u,4:u,5:u,6:u,7:u,8:u,9:u,token:function(e,t,n){if("variable"==n&&"("==e.peek()&&(";"==t.prevToken||null==t.prevToken||"}"==t.prevToken)&&f(e.current()))return"def"}},namespaceSeparator:"::",modeProps:{fold:["brace","include"]}}),h("text/x-java",{name:"clike",keywords:i("abstract assert break case catch class const continue default do else enum extends final finally float for goto if implements import instanceof interface native new package private protected public return static strictfp super switch synchronized this throw throws transient try volatile while @interface"),types:i("byte short int long float double boolean char void Boolean Byte Character Double Float Integer Long Number Object Short String StringBuffer StringBuilder Void"),blockKeywords:i("catch class do else finally for if switch try while"),defKeywords:i("class interface package enum @interface"),typeFirstDefinitions:!0,atoms:i("true false null"),number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,hooks:{"@":function(e){return!e.match("interface",!1)&&(e.eatWhile(/[\w\$_]/),"meta")}},modeProps:{fold:["brace","import"]}}),h("text/x-csharp",{name:"clike",keywords:i("abstract as async await base break case catch checked class const continue default delegate do else enum event explicit extern finally fixed for foreach goto if implicit in interface internal is lock namespace new operator out override params private protected public readonly ref return sealed sizeof stackalloc static struct switch this throw try typeof unchecked unsafe using virtual void volatile while add alias ascending descending dynamic from get global group into join let orderby partial remove select set value var yield"),types:i("Action Boolean Byte Char DateTime DateTimeOffset Decimal Double Func Guid Int16 Int32 Int64 Object SByte Single String Task TimeSpan UInt16 UInt32 UInt64 bool byte char decimal double short int long object sbyte float string ushort uint ulong"),blockKeywords:i("catch class do else finally for foreach if struct switch try while"),defKeywords:i("class interface namespace struct var"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"@":function(e,t){return e.eat('"')?(t.tokenize=p,p(e,t)):(e.eatWhile(/[\w\$_]/),"meta")}}}),h("text/x-scala",{name:"clike",keywords:i("abstract case catch class def do else extends final finally for forSome if implicit import lazy match new null object override package private protected return sealed super this throw trait try type val var while with yield _ assert assume require print println printf readLine readBoolean readByte readShort readChar readInt readLong readFloat readDouble"),types:i("AnyVal App Application Array BufferedIterator BigDecimal BigInt Char Console Either Enumeration Equiv Error Exception Fractional Function IndexedSeq Int Integral Iterable Iterator List Map Numeric Nil NotNull Option Ordered Ordering PartialFunction PartialOrdering Product Proxy Range Responder Seq Serializable Set Specializable Stream StringBuilder StringContext Symbol Throwable Traversable TraversableOnce Tuple Unit Vector Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),multiLineStrings:!0,blockKeywords:i("catch class enum do else finally for forSome if match switch try while"),defKeywords:i("class enum def object package trait type val var"),atoms:i("true false null"),indentStatements:!1,indentSwitch:!1,isOperatorChar:/[+\-*&%=<>!?|\/#:@]/,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return!!e.match('""')&&(t.tokenize=g,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},"=":function(e,n){var r=n.context;return!("}"!=r.type||!r.align||!e.eat(">"))&&(n.context=new t(r.indented,r.column,r.type,r.info,null,r.prev),"operator")}},modeProps:{closeBrackets:{triples:'"'}}}),h("text/x-kotlin",{name:"clike",keywords:i("package as typealias class interface this super val var fun for is in This throw return break continue object if else while do try when !in !is as? file import where by get set abstract enum open inner override private public internal protected catch finally out final vararg reified dynamic companion constructor init sealed field property receiver param sparam lateinit data inline noinline tailrec external annotation crossinline const operator infix suspend"),types:i("Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),intendSwitch:!1,indentStatements:!1,multiLineStrings:!0,number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,blockKeywords:i("catch class do else finally for if where try while enum"),defKeywords:i("class val var object package interface fun"),atoms:i("true false null this"),hooks:{'"':function(e,t){return t.tokenize=y(e.match('""')),t.tokenize(e,t)}},modeProps:{closeBrackets:{triples:'"'}}}),h(["x-shader/x-vertex","x-shader/x-fragment"],{name:"clike",keywords:i("sampler1D sampler2D sampler3D samplerCube sampler1DShadow sampler2DShadow const attribute uniform varying break continue discard return for while do if else struct in out inout"),types:i("float int bool void vec2 vec3 vec4 ivec2 ivec3 ivec4 bvec2 bvec3 bvec4 mat2 mat3 mat4"),blockKeywords:i("for while do if else struct"),builtin:i("radians degrees sin cos tan asin acos atan pow exp log exp2 sqrt inversesqrt abs sign floor ceil fract mod min max clamp mix step smoothstep length distance dot cross normalize ftransform faceforward reflect refract matrixCompMult lessThan lessThanEqual greaterThan greaterThanEqual equal notEqual any all not texture1D texture1DProj texture1DLod texture1DProjLod texture2D texture2DProj texture2DLod texture2DProjLod texture3D texture3DProj texture3DLod texture3DProjLod textureCube textureCubeLod shadow1D shadow2D shadow1DProj shadow2DProj shadow1DLod shadow2DLod shadow1DProjLod shadow2DProjLod dFdx dFdy fwidth noise1 noise2 noise3 noise4"),atoms:i("true false gl_FragColor gl_SecondaryColor gl_Normal gl_Vertex gl_MultiTexCoord0 gl_MultiTexCoord1 gl_MultiTexCoord2 gl_MultiTexCoord3 gl_MultiTexCoord4 gl_MultiTexCoord5 gl_MultiTexCoord6 gl_MultiTexCoord7 gl_FogCoord gl_PointCoord gl_Position gl_PointSize gl_ClipVertex gl_FrontColor gl_BackColor gl_FrontSecondaryColor gl_BackSecondaryColor gl_TexCoord gl_FogFragCoord gl_FragCoord gl_FrontFacing gl_FragData gl_FragDepth gl_ModelViewMatrix gl_ProjectionMatrix gl_ModelViewProjectionMatrix gl_TextureMatrix gl_NormalMatrix gl_ModelViewMatrixInverse gl_ProjectionMatrixInverse gl_ModelViewProjectionMatrixInverse gl_TexureMatrixTranspose gl_ModelViewMatrixInverseTranspose gl_ProjectionMatrixInverseTranspose gl_ModelViewProjectionMatrixInverseTranspose gl_TextureMatrixInverseTranspose gl_NormalScale gl_DepthRange gl_ClipPlane gl_Point gl_FrontMaterial gl_BackMaterial gl_LightSource gl_LightModel gl_FrontLightModelProduct gl_BackLightModelProduct gl_TextureColor gl_EyePlaneS gl_EyePlaneT gl_EyePlaneR gl_EyePlaneQ gl_FogParameters gl_MaxLights gl_MaxClipPlanes gl_MaxTextureUnits gl_MaxTextureCoords gl_MaxVertexAttribs gl_MaxVertexUniformComponents gl_MaxVaryingFloats gl_MaxVertexTextureImageUnits gl_MaxTextureImageUnits gl_MaxFragmentUniformComponents gl_MaxCombineTextureImageUnits gl_MaxDrawBuffers"),indentSwitch:!1,hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-nesc",{name:"clike",keywords:i(b+"as atomic async call command component components configuration event generic implementation includes interface module new norace nx_struct nx_union post provides signal task uses abstract extends"),types:i(k),blockKeywords:i("case do else for if switch while struct"),atoms:i("null true false"),hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-objectivec",{name:"clike",keywords:i(b+"inline restrict _Bool _Complex _Imaginary BOOL Class bycopy byref id IMP in inout nil oneway out Protocol SEL self super atomic nonatomic retain copy readwrite readonly"),types:i(k),atoms:i("YES NO NULL NILL ON OFF true false"),hooks:{"@":function(e){return e.eatWhile(/[\w\$]/),"keyword"},"#":s,indent:function(e,t,n){if("statement"==t.type&&/^@\w/.test(n))return t.indented}},modeProps:{fold:"brace"}}),h("text/x-squirrel",{name:"clike",keywords:i("base break clone continue const default delete enum extends function in class foreach local resume return this throw typeof yield constructor instanceof static"),types:i(k),blockKeywords:i("case catch class else for foreach if switch try while"),defKeywords:i("function local class"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"#":s},modeProps:{fold:["brace","include"]}});var w=null;h("text/x-ceylon",{name:"clike",keywords:i("abstracts alias assembly assert assign break case catch class continue dynamic else exists extends finally for function given if import in interface is let module new nonempty object of out outer package return satisfies super switch then this throw try value void while"),types:function(e){var t=e.charAt(0);return t===t.toUpperCase()&&t!==t.toLowerCase()},blockKeywords:i("case catch class dynamic else finally for function if interface module new object switch try while"),defKeywords:i("class dynamic function interface module object package value"),builtin:i("abstract actual aliased annotation by default deprecated doc final formal late license native optional sealed see serializable shared suppressWarnings tagged throws variable"),isPunctuationChar:/[\[\]{}\(\),;\:\.`]/,isOperatorChar:/[+\-*&%=<>!?|^~:\/]/,numberStart:/[\d#$]/,number:/^(?:#[\da-fA-F_]+|\$[01_]+|[\d_]+[kMGTPmunpf]?|[\d_]+\.[\d_]+(?:[eE][-+]?\d+|[kMGTPmunpf]|)|)/i,multiLineStrings:!0,typeFirstDefinitions:!0,atoms:i("true false null larger smaller equal empty finished"),indentSwitch:!1,styleDefs:!1,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return t.tokenize=x(e.match('""')?"triple":"single"),t.tokenize(e,t)},"`":function(e,t){return!(!w||!e.match("`"))&&(t.tokenize=w,w=null,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},token:function(e,t,n){if(("variable"==n||"type"==n)&&"."==t.prevToken)return"variable-2"}},modeProps:{fold:["brace","import"],closeBrackets:{triples:'"'}}})});
      // -------------------------------------------------------------------------
//  Part of the CodeChecker project, under the Apache License v2.0 with
//  LLVM Exceptions. See LICENSE for license information.
//  SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
// -------------------------------------------------------------------------

var BugViewer = {
  _files : [],
  _reports : [],
  _lineWidgets : [],
  _navigationMenuItems : [],
  _sourceFileData : null,
  _currentReport : null,
  _lastBugEvent  : null,

  init : function (files, reports) {
    this._files = files;
    this._reports = reports;

    this.initEscapeChars();
  },

  initEscapeChars : function () {
    this.escapeChars = {
      ' ' : 'nbsp',
      '<' : 'lt',
      '>' : 'gt',
      '"' : 'quot',
      '&' : 'amp'
    };

    var regexString = '[';
    for (var key in this.escapeChars) {
      regexString += key;
    }
    regexString += ']';

    this.escapeRegExp = new RegExp( regexString, 'g');
  },

  escapeHTML : function (str) {
    var that = this;

    return str.replace(this.escapeRegExp, function (m) {
      return '&' + that.escapeChars[m] + ';';
    });
  },

  initByUrl : function () {
    if (!this._reports) return;

    var state = {};
    window.location.hash.substr(1).split('&').forEach(function (s) {
      var parts = s.split('=');
      state[parts[0]] = parts[1];
    });

    for (var key in this._reports) {
      var report = this._reports[key];
      if (report.reportHash === state['reportHash']) {
        this.navigate(report);
        return;
      }
    }

    this.navigate(this._reports[0]);
  },

  create : function () {
    this._content = document.getElementById('editor-wrapper');
    this._filepath = document.getElementById('file-path');
    this._checkerName = document.getElementById('checker-name');
    this._reviewStatusWrapper =
      document.getElementById('review-status-wrapper');
    this._reviewStatus = document.getElementById('review-status');
    this._editor = document.getElementById('editor');

    this._codeMirror = CodeMirror(this._editor, {
      mode: 'text/x-c++src',
      matchBrackets : true,
      lineNumbers : true,
      readOnly : true,
      foldGutter : true,
      extraKeys : {},
      viewportMargin : 100
    });

    this._createNavigationMenu();
  },

  navigate : function (report, item) {
    if (!item) {
      var items = this._navigationMenuItems.filter(function (navItem) {
        return navItem.report.reportHash === report.reportHash;
      });

      if (!items.length) return;

      item = items[0].widget;
    }

    this._selectedReport.classList.remove('active');
    this._selectedReport = item;
    this._selectedReport.classList.add('active');
    this.setReport(report);
  },

  _createNavigationMenu : function () {
    var that = this;

    var nav = document.getElementById('report-nav');
    var list = document.createElement('ul');
    this._reports.forEach(function (report) {
      var events = report['events'];
      var lastBugEvent = events[events.length - 1];
      var item = document.createElement('li');

      var severity = document.createElement('i');
      severity.className = 'severity-' + report.severity.toLowerCase();

      item.appendChild(severity);
      item.appendChild(document.createTextNode(lastBugEvent.message));

      item.addEventListener('click', function () {
        that.navigate(report, item);
      })
      list.appendChild(item);
      that._navigationMenuItems.push({ report : report, widget : item });
    });

    if (!this._selectedReport && list.childNodes.length) {
      this._selectedReport = list.childNodes[0];
      this._selectedReport.classList.add('active');
    }

    nav.appendChild(list);
  },

  setReport : function (report) {
    this._currentReport = report;
    var events = report['events'];
    var lastBugEvent = events[events.length - 1];
    this.setCurrentBugEvent(lastBugEvent, events.length - 1);
    this.setCheckerName(report.checkerName);
    this.setReviewStatus(report.reviewStatus);

    window.location.hash = '#reportHash=' + report.reportHash;
  },

  setCurrentBugEvent : function (event, idx) {
    this._currentBugEvent = event;
    this.setSourceFileData(this._files[event.location.file]);
    this.drawBugPath();

    this.jumpTo(event.location.line, 0);
    this.highlightBugEvent(event, idx);
  },

  highlightBugEvent : function (event, idx) {
    this._lineWidgets.forEach(function (widget) {
      var lineIdx = widget.node.getAttribute('idx');
      if (parseInt(lineIdx) === idx) {
        widget.node.classList.add('current');
      }
    });
  },

  setCheckerName : function (checkerName) {
    this._checkerName.innerHTML = checkerName;
  },

  setReviewStatus : function (status) {
    if (status) {
      var className =
        'review-status-' + status.toLowerCase().split(' ').join('-');
      this._reviewStatus.className = "review-status " + className;

      this._reviewStatus.innerHTML = status;
      this._reviewStatusWrapper.style.display = 'block';
    } else {
      this._reviewStatusWrapper.style.display = 'none';
    }
  },

  setSourceFileData : function (file) {
    if (this._sourceFileData && file.id === this._sourceFileData.id) {
      return;
    }

    this._sourceFileData = file;
    this._filepath.innerHTML = file.path;
    this._codeMirror.doc.setValue(file.content);
    this._refresh();
  },

  _refresh : function () {
    var that = this;
    setTimeout(function () {
      var fullHeight = parseInt(that._content.clientHeight);
      var headerHeight = that._filepath.clientHeight;

      that._codeMirror.setSize('auto', fullHeight - headerHeight);
      that._codeMirror.refresh();
    }, 200);
  },

  clearBubbles : function () {
    this._lineWidgets.forEach(function (widget) { widget.clear(); });
    this._lineWidgets = [];
  },

  getMessage : function (event, kind) {
    if (kind === 'macro') {
      var name = 'macro expansion' + (event.name ? ': ' + event.name : '');

      return '<span class="tag macro">' + name + '</span>'
        + this.escapeHTML(event.expansion).replace(/(?:\r\n|\r|\n)/g, '<br>');
    } else if (kind === 'note') {
      return '<span class="tag note">note</span>'
        +  this.escapeHTML(event.message).replace(/(?:\r\n|\r|\n)/g, '<br>');
    }
  },

  addExtraPathEvents : function (events, kind) {
    var that = this;

    if (!events) {
      return;
    }

    events.forEach(function (event) {
      if (event.location.file !== that._currentBugEvent.location.file) {
        return;
      }

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + kind);

      var msg = document.createElement('span');
      msg.innerHTML = that.getMessage(event, kind);
      element.appendChild(msg);

      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  drawBugPath : function () {
    var that = this;

    this.clearBubbles();

    this.addExtraPathEvents(this._currentReport.macros, 'macro');
    this.addExtraPathEvents(this._currentReport.notes, 'note');

    // Processing bug path events.
    var currentEvents = this._currentReport.events;
    currentEvents.forEach(function (event, step) {
      if (event.location.file !== that._currentBugEvent.location.file)
        return;

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';
      var type = step === currentEvents.length - 1 ? 'error' : 'info';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + type);
      element.setAttribute('idx', step);

      var enumeration = document.createElement('span');
      enumeration.setAttribute('class', 'checker-enum ' + type);
      enumeration.innerHTML = step + 1;

      if (currentEvents.length > 1)
        element.appendChild(enumeration);

      var prevBugEvent = step - 1;
      if (step > 0) {
        var prevBug = document.createElement('span');
        prevBug.setAttribute('class', 'arrow left-arrow');
        prevBug.addEventListener('click', function () {
          var event = currentEvents[prevBugEvent];
          that.setCurrentBugEvent(event, prevBugEvent);
        });
        element.appendChild(prevBug);
      }

      var msg = document.createElement('span');
      msg.innerHTML = that.escapeHTML(event.message)
        .replace(/(?:\r\n|\r|\n)/g, '<br>');

      element.appendChild(msg);

      var nextBugEvent = step + 1;
      if (nextBugEvent < currentEvents.length) {
        var nextBug = document.createElement('span');
        nextBug.setAttribute('class', 'arrow right-arrow');
        nextBug.addEventListener('click', function () {
          var event = currentEvents[nextBugEvent];
          that.setCurrentBugEvent(event, nextBugEvent);
        });
        element.appendChild(nextBug);
      }


      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  jumpTo : function (line, column) {
    var that = this;

    setTimeout(function () {
      var selPosPixel
        = that._codeMirror.charCoords({ line : line, ch : column }, 'local');
      var editorSize = {
        width  : that._editor.clientWidth,
        height : that._editor.clientHeight
      };

      that._codeMirror.scrollIntoView({
        top    : selPosPixel.top - 100,
        bottom : selPosPixel.top + editorSize.height - 150,
        left   : selPosPixel.left < editorSize.width - 100
               ? 0
               : selPosPixel.left - 50,
        right  : selPosPixel.left < editorSize.width - 100
               ? 10
               : selPosPixel.left + editorSize.width - 100
      });
    }, 0);
  }
}


      var data = {"files": {"17": {"id": 17, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Analysis/AliasSetTracker.h", "content": "//===- llvm/Analysis/AliasSetTracker.h - Build Alias Sets -------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// This file defines two classes: AliasSetTracker and AliasSet. These interfaces\n// are used to classify a collection of pointer references into a maximal number\n// of disjoint sets. Each AliasSet object constructed by the AliasSetTracker\n// object refers to memory disjoint from the other sets.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_ANALYSIS_ALIASSETTRACKER_H\n#define LLVM_ANALYSIS_ALIASSETTRACKER_H\n\n#include \"llvm/ADT/DenseMap.h\"\n#include \"llvm/ADT/DenseMapInfo.h\"\n#include \"llvm/ADT/ilist.h\"\n#include \"llvm/ADT/ilist_node.h\"\n#include \"llvm/Analysis/MemoryLocation.h\"\n#include \"llvm/IR/Instruction.h\"\n#include \"llvm/IR/Metadata.h\"\n#include \"llvm/IR/PassManager.h\"\n#include \"llvm/IR/ValueHandle.h\"\n#include \"llvm/Support/Casting.h\"\n#include <cassert>\n#include <cstddef>\n#include <cstdint>\n#include <iterator>\n#include <vector>\n\nnamespace llvm {\n\nclass AAResults;\nclass AliasSetTracker;\nclass BasicBlock;\nclass LoadInst;\nclass Loop;\nclass MemorySSA;\nclass AnyMemSetInst;\nclass AnyMemTransferInst;\nclass raw_ostream;\nclass StoreInst;\nclass VAArgInst;\nclass Value;\n\nenum AliasResult : uint8_t;\n\nclass AliasSet : public ilist_node<AliasSet> {\n  friend class AliasSetTracker;\n\n  class PointerRec {\n    Value *Val;  // The pointer this record corresponds to.\n    PointerRec **PrevInList = nullptr;\n    PointerRec *NextInList = nullptr;\n    AliasSet *AS = nullptr;\n    LocationSize Size = LocationSize::mapEmpty();\n    AAMDNodes AAInfo;\n\n    // Whether the size for this record has been set at all. This makes no\n    // guarantees about the size being known.\n    bool isSizeSet() const { return Size != LocationSize::mapEmpty(); }\n\n  public:\n    PointerRec(Value *V)\n      : Val(V), AAInfo(DenseMapInfo<AAMDNodes>::getEmptyKey()) {}\n\n    Value *getValue() const { return Val; }\n\n    PointerRec *getNext() const { return NextInList; }\n    bool hasAliasSet() const { return AS != nullptr; }\n\n    PointerRec** setPrevInList(PointerRec **PIL) {\n      PrevInList = PIL;\n      return &NextInList;\n    }\n\n    bool updateSizeAndAAInfo(LocationSize NewSize, const AAMDNodes &NewAAInfo) {\n      bool SizeChanged = false;\n      if (NewSize != Size) {\n        LocationSize OldSize = Size;\n        Size = isSizeSet() ? Size.unionWith(NewSize) : NewSize;\n        SizeChanged = OldSize != Size;\n      }\n\n      if (AAInfo == DenseMapInfo<AAMDNodes>::getEmptyKey())\n        // We don't have a AAInfo yet. Set it to NewAAInfo.\n        AAInfo = NewAAInfo;\n      else {\n        AAMDNodes Intersection(AAInfo.intersect(NewAAInfo));\n        SizeChanged |= Intersection != AAInfo;\n        AAInfo = Intersection;\n      }\n      return SizeChanged;\n    }\n\n    LocationSize getSize() const {\n      assert(isSizeSet() && \"Getting an unset size!\");\n      return Size;\n    }\n\n    /// Return the AAInfo, or null if there is no information or conflicting\n    /// information.\n    AAMDNodes getAAInfo() const {\n      // If we have missing or conflicting AAInfo, return null.\n      if (AAInfo == DenseMapInfo<AAMDNodes>::getEmptyKey() ||\n          AAInfo == DenseMapInfo<AAMDNodes>::getTombstoneKey())\n        return AAMDNodes();\n      return AAInfo;\n    }\n\n    AliasSet *getAliasSet(AliasSetTracker &AST) {\n      assert(AS && \"No AliasSet yet!\");\n      if (AS->Forward) {\n        AliasSet *OldAS = AS;\n        AS = OldAS->getForwardedTarget(AST);\n        AS->addRef();\n        OldAS->dropRef(AST);\n      }\n      return AS;\n    }\n\n    void setAliasSet(AliasSet *as) {\n      assert(!AS && \"Already have an alias set!\");\n      AS = as;\n    }\n\n    void eraseFromList() {\n      if (NextInList) NextInList->PrevInList = PrevInList;\n      *PrevInList = NextInList;\n      if (AS->PtrListEnd == &NextInList) {\n        AS->PtrListEnd = PrevInList;\n        assert(*AS->PtrListEnd == nullptr && \"List not terminated right!\");\n      }\n      delete this;\n    }\n  };\n\n  // Doubly linked list of nodes.\n  PointerRec *PtrList = nullptr;\n  PointerRec **PtrListEnd;\n  // Forwarding pointer.\n  AliasSet *Forward = nullptr;\n\n  /// All instructions without a specific address in this alias set.\n  /// In rare cases this vector can have a null'ed out WeakVH\n  /// instances (can happen if some other loop pass deletes an\n  /// instruction in this list).\n  std::vector<WeakVH> UnknownInsts;\n\n  /// Number of nodes pointing to this AliasSet plus the number of AliasSets\n  /// forwarding to it.\n  unsigned RefCount : 27;\n\n  // Signifies that this set should be considered to alias any pointer.\n  // Use when the tracker holding this set is saturated.\n  unsigned AliasAny : 1;\n\n  /// The kinds of access this alias set models.\n  ///\n  /// We keep track of whether this alias set merely refers to the locations of\n  /// memory (and not any particular access), whether it modifies or references\n  /// the memory, or whether it does both. The lattice goes from \"NoAccess\" to\n  /// either RefAccess or ModAccess, then to ModRefAccess as necessary.\n  enum AccessLattice {\n    NoAccess = 0,\n    RefAccess = 1,\n    ModAccess = 2,\n    ModRefAccess = RefAccess | ModAccess\n  };\n  unsigned Access : 2;\n\n  /// The kind of alias relationship between pointers of the set.\n  ///\n  /// These represent conservatively correct alias results between any members\n  /// of the set. We represent these independently of the values of alias\n  /// results in order to pack it into a single bit. Lattice goes from\n  /// MustAlias to MayAlias.\n  enum AliasLattice {\n    SetMustAlias = 0, SetMayAlias = 1\n  };\n  unsigned Alias : 1;\n\n  unsigned SetSize = 0;\n\n  void addRef() { ++RefCount; }\n\n  void dropRef(AliasSetTracker &AST) {\n    assert(RefCount >= 1 && \"Invalid reference count detected!\");\n    if (--RefCount == 0)\n      removeFromTracker(AST);\n  }\n\n  Instruction *getUnknownInst(unsigned i) const {\n    assert(i < UnknownInsts.size());\n    return cast_or_null<Instruction>(UnknownInsts[i]);\n  }\n\npublic:\n  AliasSet(const AliasSet &) = delete;\n  AliasSet &operator=(const AliasSet &) = delete;\n\n  /// Accessors...\n  bool isRef() const { return Access & RefAccess; }\n  bool isMod() const { return Access & ModAccess; }\n  bool isMustAlias() const { return Alias == SetMustAlias; }\n  bool isMayAlias()  const { return Alias == SetMayAlias; }\n\n  /// Return true if this alias set should be ignored as part of the\n  /// AliasSetTracker object.\n  bool isForwardingAliasSet() const { return Forward; }\n\n  /// Merge the specified alias set into this alias set.\n  void mergeSetIn(AliasSet &AS, AliasSetTracker &AST);\n\n  // Alias Set iteration - Allow access to all of the pointers which are part of\n  // this alias set.\n  class iterator;\n  iterator begin() const { return iterator(PtrList); }\n  iterator end()   const { return iterator(); }\n  bool empty() const { return PtrList == nullptr; }\n\n  // Unfortunately, ilist::size() is linear, so we have to add code to keep\n  // track of the list's exact size.\n  unsigned size() { return SetSize; }\n\n  /// If this alias set is known to contain a single instruction and *only* a\n  /// single unique instruction, return it.  Otherwise, return nullptr.\n  Instruction* getUniqueInstruction();\n\n  void print(raw_ostream &OS) const;\n  void dump() const;\n\n  /// Define an iterator for alias sets... this is just a forward iterator.\n  class iterator : public std::iterator<std::forward_iterator_tag,\n                                        PointerRec, ptrdiff_t> {\n    PointerRec *CurNode;\n\n  public:\n    explicit iterator(PointerRec *CN = nullptr) : CurNode(CN) {}\n\n    bool operator==(const iterator& x) const {\n      return CurNode == x.CurNode;\n    }\n    bool operator!=(const iterator& x) const { return !operator==(x); }\n\n    value_type &operator*() const {\n      assert(CurNode && \"Dereferencing AliasSet.end()!\");\n      return *CurNode;\n    }\n    value_type *operator->() const { return &operator*(); }\n\n    Value *getPointer() const { return CurNode->getValue(); }\n    LocationSize getSize() const { return CurNode->getSize(); }\n    AAMDNodes getAAInfo() const { return CurNode->getAAInfo(); }\n\n    iterator& operator++() {                // Preincrement\n      assert(CurNode && \"Advancing past AliasSet.end()!\");\n      CurNode = CurNode->getNext();\n      return *this;\n    }\n    iterator operator++(int) { // Postincrement\n      iterator tmp = *this; ++*this; return tmp;\n    }\n  };\n\nprivate:\n  // Can only be created by AliasSetTracker.\n  AliasSet()\n      : PtrListEnd(&PtrList), RefCount(0),  AliasAny(false), Access(NoAccess),\n        Alias(SetMustAlias) {}\n\n  PointerRec *getSomePointer() const {\n    return PtrList;\n  }\n\n  /// Return the real alias set this represents. If this has been merged with\n  /// another set and is forwarding, return the ultimate destination set. This\n  /// also implements the union-find collapsing as well.\n  AliasSet *getForwardedTarget(AliasSetTracker &AST) {\n    if (!Forward) return this;\n\n    AliasSet *Dest = Forward->getForwardedTarget(AST);\n    if (Dest != Forward) {\n      Dest->addRef();\n      Forward->dropRef(AST);\n      Forward = Dest;\n    }\n    return Dest;\n  }\n\n  void removeFromTracker(AliasSetTracker &AST);\n\n  void addPointer(AliasSetTracker &AST, PointerRec &Entry, LocationSize Size,\n                  const AAMDNodes &AAInfo, bool KnownMustAlias = false,\n                  bool SkipSizeUpdate = false);\n  void addUnknownInst(Instruction *I, AAResults &AA);\n\n  void removeUnknownInst(AliasSetTracker &AST, Instruction *I) {\n    bool WasEmpty = UnknownInsts.empty();\n    for (size_t i = 0, e = UnknownInsts.size(); i != e; ++i)\n      if (UnknownInsts[i] == I) {\n        UnknownInsts[i] = UnknownInsts.back();\n        UnknownInsts.pop_back();\n        --i; --e;  // Revisit the moved entry.\n      }\n    if (!WasEmpty && UnknownInsts.empty())\n      dropRef(AST);\n  }\n\npublic:\n  /// If the specified pointer \"may\" (or must) alias one of the members in the\n  /// set return the appropriate AliasResult. Otherwise return NoAlias.\n  AliasResult aliasesPointer(const Value *Ptr, LocationSize Size,\n                             const AAMDNodes &AAInfo, AAResults &AA) const;\n  bool aliasesUnknownInst(const Instruction *Inst, AAResults &AA) const;\n};\n\ninline raw_ostream& operator<<(raw_ostream &OS, const AliasSet &AS) {\n  AS.print(OS);\n  return OS;\n}\n\nclass AliasSetTracker {\n  /// A CallbackVH to arrange for AliasSetTracker to be notified whenever a\n  /// Value is deleted.\n  class ASTCallbackVH final : public CallbackVH {\n    AliasSetTracker *AST;\n\n    void deleted() override;\n    void allUsesReplacedWith(Value *) override;\n\n  public:\n    ASTCallbackVH(Value *V, AliasSetTracker *AST = nullptr);\n\n    ASTCallbackVH &operator=(Value *V);\n  };\n  /// Traits to tell DenseMap that tell us how to compare and hash the value\n  /// handle.\n  struct ASTCallbackVHDenseMapInfo : public DenseMapInfo<Value *> {};\n\n  AAResults &AA;\n  MemorySSA *MSSA = nullptr;\n  Loop *L = nullptr;\n  ilist<AliasSet> AliasSets;\n\n  using PointerMapType = DenseMap<ASTCallbackVH, AliasSet::PointerRec *,\n                                  ASTCallbackVHDenseMapInfo>;\n\n  // Map from pointers to their node\n  PointerMapType PointerMap;\n\npublic:\n  /// Create an empty collection of AliasSets, and use the specified alias\n  /// analysis object to disambiguate load and store addresses.\n  explicit AliasSetTracker(AAResults &AA) : AA(AA) {}\n  explicit AliasSetTracker(AAResults &AA, MemorySSA *MSSA, Loop *L)\n      : AA(AA), MSSA(MSSA), L(L) {}\n  ~AliasSetTracker() { clear(); }\n\n  /// These methods are used to add different types of instructions to the alias\n  /// sets. Adding a new instruction can result in one of three actions\n  /// happening:\n  ///\n  ///   1. If the instruction doesn't alias any other sets, create a new set.\n  ///   2. If the instruction aliases exactly one set, add it to the set\n  ///   3. If the instruction aliases multiple sets, merge the sets, and add\n  ///      the instruction to the result.\n  ///\n  /// These methods return true if inserting the instruction resulted in the\n  /// addition of a new alias set (i.e., the pointer did not alias anything).\n  ///\n  void add(Value *Ptr, LocationSize Size, const AAMDNodes &AAInfo); // Add a loc\n  void add(LoadInst *LI);\n  void add(StoreInst *SI);\n  void add(VAArgInst *VAAI);\n  void add(AnyMemSetInst *MSI);\n  void add(AnyMemTransferInst *MTI);\n  void add(Instruction *I);       // Dispatch to one of the other add methods...\n  void add(BasicBlock &BB);       // Add all instructions in basic block\n  void add(const AliasSetTracker &AST); // Add alias relations from another AST\n  void addUnknown(Instruction *I);\n  void addAllInstructionsInLoopUsingMSSA();\n\n  void clear();\n\n  /// Return the alias sets that are active.\n  const ilist<AliasSet> &getAliasSets() const { return AliasSets; }\n\n  /// Return the alias set which contains the specified memory location.  If\n  /// the memory location aliases two or more existing alias sets, will have\n  /// the effect of merging those alias sets before the single resulting alias\n  /// set is returned.\n  AliasSet &getAliasSetFor(const MemoryLocation &MemLoc);\n\n  /// Return the underlying alias analysis object used by this tracker.\n  AAResults &getAliasAnalysis() const { return AA; }\n\n  /// This method is used to remove a pointer value from the AliasSetTracker\n  /// entirely. It should be used when an instruction is deleted from the\n  /// program to update the AST. If you don't use this, you would have dangling\n  /// pointers to deleted instructions.\n  void deleteValue(Value *PtrVal);\n\n  /// This method should be used whenever a preexisting value in the program is\n  /// copied or cloned, introducing a new value.  Note that it is ok for clients\n  /// that use this method to introduce the same value multiple times: if the\n  /// tracker already knows about a value, it will ignore the request.\n  void copyValue(Value *From, Value *To);\n\n  using iterator = ilist<AliasSet>::iterator;\n  using const_iterator = ilist<AliasSet>::const_iterator;\n\n  const_iterator begin() const { return AliasSets.begin(); }\n  const_iterator end()   const { return AliasSets.end(); }\n\n  iterator begin() { return AliasSets.begin(); }\n  iterator end()   { return AliasSets.end(); }\n\n  void print(raw_ostream &OS) const;\n  void dump() const;\n\nprivate:\n  friend class AliasSet;\n\n  // The total number of pointers contained in all \"may\" alias sets.\n  unsigned TotalMayAliasSetSize = 0;\n\n  // A non-null value signifies this AST is saturated. A saturated AST lumps\n  // all pointers into a single \"May\" set.\n  AliasSet *AliasAnyAS = nullptr;\n\n  void removeAliasSet(AliasSet *AS);\n\n  /// Just like operator[] on the map, except that it creates an entry for the\n  /// pointer if it doesn't already exist.\n  AliasSet::PointerRec &getEntryFor(Value *V) {\n    AliasSet::PointerRec *&Entry = PointerMap[ASTCallbackVH(V, this)];\n    if (!Entry)\n      Entry = new AliasSet::PointerRec(V);\n    return *Entry;\n  }\n\n  AliasSet &addPointer(MemoryLocation Loc, AliasSet::AccessLattice E);\n  AliasSet *mergeAliasSetsForPointer(const Value *Ptr, LocationSize Size,\n                                     const AAMDNodes &AAInfo,\n                                     bool &MustAliasAll);\n\n  /// Merge all alias sets into a single set that is considered to alias any\n  /// pointer.\n  AliasSet &mergeAllAliasSets();\n\n  AliasSet *findAliasSetForUnknownInst(Instruction *Inst);\n};\n\ninline raw_ostream& operator<<(raw_ostream &OS, const AliasSetTracker &AST) {\n  AST.print(OS);\n  return OS;\n}\n\nclass AliasSetsPrinterPass : public PassInfoMixin<AliasSetsPrinterPass> {\n  raw_ostream &OS;\n\npublic:\n  explicit AliasSetsPrinterPass(raw_ostream &OS);\n  PreservedAnalyses run(Function &F, FunctionAnalysisManager &AM);\n};\n\n} // end namespace llvm\n\n#endif // LLVM_ANALYSIS_ALIASSETTRACKER_H\n"}, "18": {"id": 18, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Analysis/LoopInfo.h", "content": "//===- llvm/Analysis/LoopInfo.h - Natural Loop Calculator -------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// This file defines the LoopInfo class that is used to identify natural loops\n// and determine the loop depth of various nodes of the CFG.  A natural loop\n// has exactly one entry-point, which is called the header. Note that natural\n// loops may actually be several loops that share the same header node.\n//\n// This analysis calculates the nesting structure of loops in a function.  For\n// each natural loop identified, this analysis identifies natural loops\n// contained entirely within the loop and the basic blocks the make up the loop.\n//\n// It can calculate on the fly various bits of information, for example:\n//\n//  * whether there is a preheader for the loop\n//  * the number of back edges to the header\n//  * whether or not a particular block branches out of the loop\n//  * the successor blocks of the loop\n//  * the loop depth\n//  * etc...\n//\n// Note that this analysis specifically identifies *Loops* not cycles or SCCs\n// in the CFG.  There can be strongly connected components in the CFG which\n// this analysis will not recognize and that will not be represented by a Loop\n// instance.  In particular, a Loop might be inside such a non-loop SCC, or a\n// non-loop SCC might contain a sub-SCC which is a Loop.\n//\n// For an overview of terminology used in this API (and thus all of our loop\n// analyses or transforms), see docs/LoopTerminology.rst.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_ANALYSIS_LOOPINFO_H\n#define LLVM_ANALYSIS_LOOPINFO_H\n\n#include \"llvm/ADT/DenseMap.h\"\n#include \"llvm/ADT/DenseSet.h\"\n#include \"llvm/ADT/GraphTraits.h\"\n#include \"llvm/ADT/SmallPtrSet.h\"\n#include \"llvm/ADT/SmallVector.h\"\n#include \"llvm/IR/CFG.h\"\n#include \"llvm/IR/Instruction.h\"\n#include \"llvm/IR/Instructions.h\"\n#include \"llvm/IR/PassManager.h\"\n#include \"llvm/Pass.h\"\n#include \"llvm/Support/Allocator.h\"\n#include <algorithm>\n#include <utility>\n\nnamespace llvm {\n\nclass DominatorTree;\nclass LoopInfo;\nclass Loop;\nclass InductionDescriptor;\nclass MDNode;\nclass MemorySSAUpdater;\nclass ScalarEvolution;\nclass raw_ostream;\ntemplate <class N, bool IsPostDom> class DominatorTreeBase;\ntemplate <class N, class M> class LoopInfoBase;\ntemplate <class N, class M> class LoopBase;\n\n//===----------------------------------------------------------------------===//\n/// Instances of this class are used to represent loops that are detected in the\n/// flow graph.\n///\ntemplate <class BlockT, class LoopT> class LoopBase {\n  LoopT *ParentLoop;\n  // Loops contained entirely within this one.\n  std::vector<LoopT *> SubLoops;\n\n  // The list of blocks in this loop. First entry is the header node.\n  std::vector<BlockT *> Blocks;\n\n  SmallPtrSet<const BlockT *, 8> DenseBlockSet;\n\n#if LLVM_ENABLE_ABI_BREAKING_CHECKS\n  /// Indicator that this loop is no longer a valid loop.\n  bool IsInvalid = false;\n#endif\n\n  LoopBase(const LoopBase<BlockT, LoopT> &) = delete;\n  const LoopBase<BlockT, LoopT> &\n  operator=(const LoopBase<BlockT, LoopT> &) = delete;\n\npublic:\n  /// Return the nesting level of this loop.  An outer-most loop has depth 1,\n  /// for consistency with loop depth values used for basic blocks, where depth\n  /// 0 is used for blocks not inside any loops.\n  unsigned getLoopDepth() const {\n    assert(!isInvalid() && \"Loop not in a valid state!\");\n    unsigned D = 1;\n    for (const LoopT *CurLoop = ParentLoop; CurLoop;\n         CurLoop = CurLoop->ParentLoop)\n      ++D;\n    return D;\n  }\n  BlockT *getHeader() const { return getBlocks().front(); }\n  /// Return the parent loop if it exists or nullptr for top\n  /// level loops.\n\n  /// A loop is either top-level in a function (that is, it is not\n  /// contained in any other loop) or it is entirely enclosed in\n  /// some other loop.\n  /// If a loop is top-level, it has no parent, otherwise its\n  /// parent is the innermost loop in which it is enclosed.\n  LoopT *getParentLoop() const { return ParentLoop; }\n\n  /// This is a raw interface for bypassing addChildLoop.\n  void setParentLoop(LoopT *L) {\n    assert(!isInvalid() && \"Loop not in a valid state!\");\n    ParentLoop = L;\n  }\n\n  /// Return true if the specified loop is contained within in this loop.\n  bool contains(const LoopT *L) const {\n    assert(!isInvalid() && \"Loop not in a valid state!\");\n    if (L == this)\n      return true;\n    if (!L)\n      return false;\n    return contains(L->getParentLoop());\n  }\n\n  /// Return true if the specified basic block is in this loop.\n  bool contains(const BlockT *BB) const {\n    assert(!isInvalid() && \"Loop not in a valid state!\");\n    return DenseBlockSet.count(BB);\n  }\n\n  /// Return true if the specified instruction is in this loop.\n  template <class InstT> bool contains(const InstT *Inst) const {\n    return contains(Inst->getParent());\n  }\n\n  /// Return the loops contained entirely within this loop.\n  const std::vector<LoopT *> &getSubLoops() const {\n    assert(!isInvalid() && \"Loop not in a valid state!\");\n    return SubLoops;\n  }\n  std::vector<LoopT *> &getSubLoopsVector() {\n    assert(!isInvalid() && \"Loop not in a valid state!\");\n    return SubLoops;\n  }\n  typedef typename std::vector<LoopT *>::const_iterator iterator;\n  typedef\n      typename std::vector<LoopT *>::const_reverse_iterator reverse_iterator;\n  iterator begin() const { return getSubLoops().begin(); }\n  iterator end() const { return getSubLoops().end(); }\n  reverse_iterator rbegin() const { return getSubLoops().rbegin(); }\n  reverse_iterator rend() const { return getSubLoops().rend(); }\n\n  // LoopInfo does not detect irreducible control flow, just natural\n  // loops. That is, it is possible that there is cyclic control\n  // flow within the \"innermost loop\" or around the \"outermost\n  // loop\".\n\n  /// Return true if the loop does not contain any (natural) loops.\n  bool isInnermost() const { return getSubLoops().empty(); }\n  /// Return true if the loop does not have a parent (natural) loop\n  // (i.e. it is outermost, which is the same as top-level).\n  bool isOutermost() const { return getParentLoop() == nullptr; }\n\n  /// Get a list of the basic blocks which make up this loop.\n  ArrayRef<BlockT *> getBlocks() const {\n    assert(!isInvalid() && \"Loop not in a valid state!\");\n    return Blocks;\n  }\n  typedef typename ArrayRef<BlockT *>::const_iterator block_iterator;\n  block_iterator block_begin() const { return getBlocks().begin(); }\n  block_iterator block_end() const { return getBlocks().end(); }\n  inline iterator_range<block_iterator> blocks() const {\n    assert(!isInvalid() && \"Loop not in a valid state!\");\n    return make_range(block_begin(), block_end());\n  }\n\n  /// Get the number of blocks in this loop in constant time.\n  /// Invalidate the loop, indicating that it is no longer a loop.\n  unsigned getNumBlocks() const {\n    assert(!isInvalid() && \"Loop not in a valid state!\");\n    return Blocks.size();\n  }\n\n  /// Return a direct, mutable handle to the blocks vector so that we can\n  /// mutate it efficiently with techniques like `std::remove`.\n  std::vector<BlockT *> &getBlocksVector() {\n    assert(!isInvalid() && \"Loop not in a valid state!\");\n    return Blocks;\n  }\n  /// Return a direct, mutable handle to the blocks set so that we can\n  /// mutate it efficiently.\n  SmallPtrSetImpl<const BlockT *> &getBlocksSet() {\n    assert(!isInvalid() && \"Loop not in a valid state!\");\n    return DenseBlockSet;\n  }\n\n  /// Return a direct, immutable handle to the blocks set.\n  const SmallPtrSetImpl<const BlockT *> &getBlocksSet() const {\n    assert(!isInvalid() && \"Loop not in a valid state!\");\n    return DenseBlockSet;\n  }\n\n  /// Return true if this loop is no longer valid.  The only valid use of this\n  /// helper is \"assert(L.isInvalid())\" or equivalent, since IsInvalid is set to\n  /// true by the destructor.  In other words, if this accessor returns true,\n  /// the caller has already triggered UB by calling this accessor; and so it\n  /// can only be called in a context where a return value of true indicates a\n  /// programmer error.\n  bool isInvalid() const {\n#if LLVM_ENABLE_ABI_BREAKING_CHECKS\n    return IsInvalid;\n#else\n    return false;\n#endif\n  }\n\n  /// True if terminator in the block can branch to another block that is\n  /// outside of the current loop. \\p BB must be inside the loop.\n  bool isLoopExiting(const BlockT *BB) const {\n    assert(!isInvalid() && \"Loop not in a valid state!\");\n    assert(contains(BB) && \"Exiting block must be part of the loop\");\n    for (const auto *Succ : children<const BlockT *>(BB)) {\n      if (!contains(Succ))\n        return true;\n    }\n    return false;\n  }\n\n  /// Returns true if \\p BB is a loop-latch.\n  /// A latch block is a block that contains a branch back to the header.\n  /// This function is useful when there are multiple latches in a loop\n  /// because \\fn getLoopLatch will return nullptr in that case.\n  bool isLoopLatch(const BlockT *BB) const {\n    assert(!isInvalid() && \"Loop not in a valid state!\");\n    assert(contains(BB) && \"block does not belong to the loop\");\n\n    BlockT *Header = getHeader();\n    auto PredBegin = GraphTraits<Inverse<BlockT *>>::child_begin(Header);\n    auto PredEnd = GraphTraits<Inverse<BlockT *>>::child_end(Header);\n    return std::find(PredBegin, PredEnd, BB) != PredEnd;\n  }\n\n  /// Calculate the number of back edges to the loop header.\n  unsigned getNumBackEdges() const {\n    assert(!isInvalid() && \"Loop not in a valid state!\");\n    unsigned NumBackEdges = 0;\n    BlockT *H = getHeader();\n\n    for (const auto Pred : children<Inverse<BlockT *>>(H))\n      if (contains(Pred))\n        ++NumBackEdges;\n\n    return NumBackEdges;\n  }\n\n  //===--------------------------------------------------------------------===//\n  // APIs for simple analysis of the loop.\n  //\n  // Note that all of these methods can fail on general loops (ie, there may not\n  // be a preheader, etc).  For best success, the loop simplification and\n  // induction variable canonicalization pass should be used to normalize loops\n  // for easy analysis.  These methods assume canonical loops.\n\n  /// Return all blocks inside the loop that have successors outside of the\n  /// loop. These are the blocks _inside of the current loop_ which branch out.\n  /// The returned list is always unique.\n  void getExitingBlocks(SmallVectorImpl<BlockT *> &ExitingBlocks) const;\n\n  /// If getExitingBlocks would return exactly one block, return that block.\n  /// Otherwise return null.\n  BlockT *getExitingBlock() const;\n\n  /// Return all of the successor blocks of this loop. These are the blocks\n  /// _outside of the current loop_ which are branched to.\n  void getExitBlocks(SmallVectorImpl<BlockT *> &ExitBlocks) const;\n\n  /// If getExitBlocks would return exactly one block, return that block.\n  /// Otherwise return null.\n  BlockT *getExitBlock() const;\n\n  /// Return true if no exit block for the loop has a predecessor that is\n  /// outside the loop.\n  bool hasDedicatedExits() const;\n\n  /// Return all unique successor blocks of this loop.\n  /// These are the blocks _outside of the current loop_ which are branched to.\n  void getUniqueExitBlocks(SmallVectorImpl<BlockT *> &ExitBlocks) const;\n\n  /// Return all unique successor blocks of this loop except successors from\n  /// Latch block are not considered. If the exit comes from Latch has also\n  /// non Latch predecessor in a loop it will be added to ExitBlocks.\n  /// These are the blocks _outside of the current loop_ which are branched to.\n  void getUniqueNonLatchExitBlocks(SmallVectorImpl<BlockT *> &ExitBlocks) const;\n\n  /// If getUniqueExitBlocks would return exactly one block, return that block.\n  /// Otherwise return null.\n  BlockT *getUniqueExitBlock() const;\n\n  /// Return true if this loop does not have any exit blocks.\n  bool hasNoExitBlocks() const;\n\n  /// Edge type.\n  typedef std::pair<BlockT *, BlockT *> Edge;\n\n  /// Return all pairs of (_inside_block_,_outside_block_).\n  void getExitEdges(SmallVectorImpl<Edge> &ExitEdges) const;\n\n  /// If there is a preheader for this loop, return it. A loop has a preheader\n  /// if there is only one edge to the header of the loop from outside of the\n  /// loop. If this is the case, the block branching to the header of the loop\n  /// is the preheader node.\n  ///\n  /// This method returns null if there is no preheader for the loop.\n  BlockT *getLoopPreheader() const;\n\n  /// If the given loop's header has exactly one unique predecessor outside the\n  /// loop, return it. Otherwise return null.\n  ///  This is less strict that the loop \"preheader\" concept, which requires\n  /// the predecessor to have exactly one successor.\n  BlockT *getLoopPredecessor() const;\n\n  /// If there is a single latch block for this loop, return it.\n  /// A latch block is a block that contains a branch back to the header.\n  BlockT *getLoopLatch() const;\n\n  /// Return all loop latch blocks of this loop. A latch block is a block that\n  /// contains a branch back to the header.\n  void getLoopLatches(SmallVectorImpl<BlockT *> &LoopLatches) const {\n    assert(!isInvalid() && \"Loop not in a valid state!\");\n    BlockT *H = getHeader();\n    for (const auto Pred : children<Inverse<BlockT *>>(H))\n      if (contains(Pred))\n        LoopLatches.push_back(Pred);\n  }\n\n  /// Return all inner loops in the loop nest rooted by the loop in preorder,\n  /// with siblings in forward program order.\n  template <class Type>\n  static void getInnerLoopsInPreorder(const LoopT &L,\n                                      SmallVectorImpl<Type> &PreOrderLoops) {\n    SmallVector<LoopT *, 4> PreOrderWorklist;\n    PreOrderWorklist.append(L.rbegin(), L.rend());\n\n    while (!PreOrderWorklist.empty()) {\n      LoopT *L = PreOrderWorklist.pop_back_val();\n      // Sub-loops are stored in forward program order, but will process the\n      // worklist backwards so append them in reverse order.\n      PreOrderWorklist.append(L->rbegin(), L->rend());\n      PreOrderLoops.push_back(L);\n    }\n  }\n\n  /// Return all loops in the loop nest rooted by the loop in preorder, with\n  /// siblings in forward program order.\n  SmallVector<const LoopT *, 4> getLoopsInPreorder() const {\n    SmallVector<const LoopT *, 4> PreOrderLoops;\n    const LoopT *CurLoop = static_cast<const LoopT *>(this);\n    PreOrderLoops.push_back(CurLoop);\n    getInnerLoopsInPreorder(*CurLoop, PreOrderLoops);\n    return PreOrderLoops;\n  }\n  SmallVector<LoopT *, 4> getLoopsInPreorder() {\n    SmallVector<LoopT *, 4> PreOrderLoops;\n    LoopT *CurLoop = static_cast<LoopT *>(this);\n    PreOrderLoops.push_back(CurLoop);\n    getInnerLoopsInPreorder(*CurLoop, PreOrderLoops);\n    return PreOrderLoops;\n  }\n\n  //===--------------------------------------------------------------------===//\n  // APIs for updating loop information after changing the CFG\n  //\n\n  /// This method is used by other analyses to update loop information.\n  /// NewBB is set to be a new member of the current loop.\n  /// Because of this, it is added as a member of all parent loops, and is added\n  /// to the specified LoopInfo object as being in the current basic block.  It\n  /// is not valid to replace the loop header with this method.\n  void addBasicBlockToLoop(BlockT *NewBB, LoopInfoBase<BlockT, LoopT> &LI);\n\n  /// This is used when splitting loops up. It replaces the OldChild entry in\n  /// our children list with NewChild, and updates the parent pointer of\n  /// OldChild to be null and the NewChild to be this loop.\n  /// This updates the loop depth of the new child.\n  void replaceChildLoopWith(LoopT *OldChild, LoopT *NewChild);\n\n  /// Add the specified loop to be a child of this loop.\n  /// This updates the loop depth of the new child.\n  void addChildLoop(LoopT *NewChild) {\n    assert(!isInvalid() && \"Loop not in a valid state!\");\n    assert(!NewChild->ParentLoop && \"NewChild already has a parent!\");\n    NewChild->ParentLoop = static_cast<LoopT *>(this);\n    SubLoops.push_back(NewChild);\n  }\n\n  /// This removes the specified child from being a subloop of this loop. The\n  /// loop is not deleted, as it will presumably be inserted into another loop.\n  LoopT *removeChildLoop(iterator I) {\n    assert(!isInvalid() && \"Loop not in a valid state!\");\n    assert(I != SubLoops.end() && \"Cannot remove end iterator!\");\n    LoopT *Child = *I;\n    assert(Child->ParentLoop == this && \"Child is not a child of this loop!\");\n    SubLoops.erase(SubLoops.begin() + (I - begin()));\n    Child->ParentLoop = nullptr;\n    return Child;\n  }\n\n  /// This removes the specified child from being a subloop of this loop. The\n  /// loop is not deleted, as it will presumably be inserted into another loop.\n  LoopT *removeChildLoop(LoopT *Child) {\n    return removeChildLoop(llvm::find(*this, Child));\n  }\n\n  /// This adds a basic block directly to the basic block list.\n  /// This should only be used by transformations that create new loops.  Other\n  /// transformations should use addBasicBlockToLoop.\n  void addBlockEntry(BlockT *BB) {\n    assert(!isInvalid() && \"Loop not in a valid state!\");\n    Blocks.push_back(BB);\n    DenseBlockSet.insert(BB);\n  }\n\n  /// interface to reverse Blocks[from, end of loop] in this loop\n  void reverseBlock(unsigned from) {\n    assert(!isInvalid() && \"Loop not in a valid state!\");\n    std::reverse(Blocks.begin() + from, Blocks.end());\n  }\n\n  /// interface to do reserve() for Blocks\n  void reserveBlocks(unsigned size) {\n    assert(!isInvalid() && \"Loop not in a valid state!\");\n    Blocks.reserve(size);\n  }\n\n  /// This method is used to move BB (which must be part of this loop) to be the\n  /// loop header of the loop (the block that dominates all others).\n  void moveToHeader(BlockT *BB) {\n    assert(!isInvalid() && \"Loop not in a valid state!\");\n    if (Blocks[0] == BB)\n      return;\n    for (unsigned i = 0;; ++i) {\n      assert(i != Blocks.size() && \"Loop does not contain BB!\");\n      if (Blocks[i] == BB) {\n        Blocks[i] = Blocks[0];\n        Blocks[0] = BB;\n        return;\n      }\n    }\n  }\n\n  /// This removes the specified basic block from the current loop, updating the\n  /// Blocks as appropriate. This does not update the mapping in the LoopInfo\n  /// class.\n  void removeBlockFromLoop(BlockT *BB) {\n    assert(!isInvalid() && \"Loop not in a valid state!\");\n    auto I = find(Blocks, BB);\n    assert(I != Blocks.end() && \"N is not in this list!\");\n    Blocks.erase(I);\n\n    DenseBlockSet.erase(BB);\n  }\n\n  /// Verify loop structure\n  void verifyLoop() const;\n\n  /// Verify loop structure of this loop and all nested loops.\n  void verifyLoopNest(DenseSet<const LoopT *> *Loops) const;\n\n  /// Returns true if the loop is annotated parallel.\n  ///\n  /// Derived classes can override this method using static template\n  /// polymorphism.\n  bool isAnnotatedParallel() const { return false; }\n\n  /// Print loop with all the BBs inside it.\n  void print(raw_ostream &OS, unsigned Depth = 0, bool Verbose = false) const;\n\nprotected:\n  friend class LoopInfoBase<BlockT, LoopT>;\n\n  /// This creates an empty loop.\n  LoopBase() : ParentLoop(nullptr) {}\n\n  explicit LoopBase(BlockT *BB) : ParentLoop(nullptr) {\n    Blocks.push_back(BB);\n    DenseBlockSet.insert(BB);\n  }\n\n  // Since loop passes like SCEV are allowed to key analysis results off of\n  // `Loop` pointers, we cannot re-use pointers within a loop pass manager.\n  // This means loop passes should not be `delete` ing `Loop` objects directly\n  // (and risk a later `Loop` allocation re-using the address of a previous one)\n  // but should be using LoopInfo::markAsRemoved, which keeps around the `Loop`\n  // pointer till the end of the lifetime of the `LoopInfo` object.\n  //\n  // To make it easier to follow this rule, we mark the destructor as\n  // non-public.\n  ~LoopBase() {\n    for (auto *SubLoop : SubLoops)\n      SubLoop->~LoopT();\n\n#if LLVM_ENABLE_ABI_BREAKING_CHECKS\n    IsInvalid = true;\n#endif\n    SubLoops.clear();\n    Blocks.clear();\n    DenseBlockSet.clear();\n    ParentLoop = nullptr;\n  }\n};\n\ntemplate <class BlockT, class LoopT>\nraw_ostream &operator<<(raw_ostream &OS, const LoopBase<BlockT, LoopT> &Loop) {\n  Loop.print(OS);\n  return OS;\n}\n\n// Implementation in LoopInfoImpl.h\nextern template class LoopBase<BasicBlock, Loop>;\n\n/// Represents a single loop in the control flow graph.  Note that not all SCCs\n/// in the CFG are necessarily loops.\nclass Loop : public LoopBase<BasicBlock, Loop> {\npublic:\n  /// A range representing the start and end location of a loop.\n  class LocRange {\n    DebugLoc Start;\n    DebugLoc End;\n\n  public:\n    LocRange() {}\n    LocRange(DebugLoc Start) : Start(Start), End(Start) {}\n    LocRange(DebugLoc Start, DebugLoc End)\n        : Start(std::move(Start)), End(std::move(End)) {}\n\n    const DebugLoc &getStart() const { return Start; }\n    const DebugLoc &getEnd() const { return End; }\n\n    /// Check for null.\n    ///\n    explicit operator bool() const { return Start && End; }\n  };\n\n  /// Return true if the specified value is loop invariant.\n  bool isLoopInvariant(const Value *V) const;\n\n  /// Return true if all the operands of the specified instruction are loop\n  /// invariant.\n  bool hasLoopInvariantOperands(const Instruction *I) const;\n\n  /// If the given value is an instruction inside of the loop and it can be\n  /// hoisted, do so to make it trivially loop-invariant.\n  /// Return true if the value after any hoisting is loop invariant. This\n  /// function can be used as a slightly more aggressive replacement for\n  /// isLoopInvariant.\n  ///\n  /// If InsertPt is specified, it is the point to hoist instructions to.\n  /// If null, the terminator of the loop preheader is used.\n  bool makeLoopInvariant(Value *V, bool &Changed,\n                         Instruction *InsertPt = nullptr,\n                         MemorySSAUpdater *MSSAU = nullptr) const;\n\n  /// If the given instruction is inside of the loop and it can be hoisted, do\n  /// so to make it trivially loop-invariant.\n  /// Return true if the instruction after any hoisting is loop invariant. This\n  /// function can be used as a slightly more aggressive replacement for\n  /// isLoopInvariant.\n  ///\n  /// If InsertPt is specified, it is the point to hoist instructions to.\n  /// If null, the terminator of the loop preheader is used.\n  ///\n  bool makeLoopInvariant(Instruction *I, bool &Changed,\n                         Instruction *InsertPt = nullptr,\n                         MemorySSAUpdater *MSSAU = nullptr) const;\n\n  /// Check to see if the loop has a canonical induction variable: an integer\n  /// recurrence that starts at 0 and increments by one each time through the\n  /// loop. If so, return the phi node that corresponds to it.\n  ///\n  /// The IndVarSimplify pass transforms loops to have a canonical induction\n  /// variable.\n  ///\n  PHINode *getCanonicalInductionVariable() const;\n\n  /// Obtain the unique incoming and back edge. Return false if they are\n  /// non-unique or the loop is dead; otherwise, return true.\n  bool getIncomingAndBackEdge(BasicBlock *&Incoming,\n                              BasicBlock *&Backedge) const;\n\n  /// Below are some utilities to get the loop guard, loop bounds and induction\n  /// variable, and to check if a given phinode is an auxiliary induction\n  /// variable, if the loop is guarded, and if the loop is canonical.\n  ///\n  /// Here is an example:\n  /// \\code\n  /// for (int i = lb; i < ub; i+=step)\n  ///   <loop body>\n  /// --- pseudo LLVMIR ---\n  /// beforeloop:\n  ///   guardcmp = (lb < ub)\n  ///   if (guardcmp) goto preheader; else goto afterloop\n  /// preheader:\n  /// loop:\n  ///   i_1 = phi[{lb, preheader}, {i_2, latch}]\n  ///   <loop body>\n  ///   i_2 = i_1 + step\n  /// latch:\n  ///   cmp = (i_2 < ub)\n  ///   if (cmp) goto loop\n  /// exit:\n  /// afterloop:\n  /// \\endcode\n  ///\n  /// - getBounds\n  ///   - getInitialIVValue      --> lb\n  ///   - getStepInst            --> i_2 = i_1 + step\n  ///   - getStepValue           --> step\n  ///   - getFinalIVValue        --> ub\n  ///   - getCanonicalPredicate  --> '<'\n  ///   - getDirection           --> Increasing\n  ///\n  /// - getInductionVariable            --> i_1\n  /// - isAuxiliaryInductionVariable(x) --> true if x == i_1\n  /// - getLoopGuardBranch()\n  ///                 --> `if (guardcmp) goto preheader; else goto afterloop`\n  /// - isGuarded()                     --> true\n  /// - isCanonical                     --> false\n  struct LoopBounds {\n    /// Return the LoopBounds object if\n    /// - the given \\p IndVar is an induction variable\n    /// - the initial value of the induction variable can be found\n    /// - the step instruction of the induction variable can be found\n    /// - the final value of the induction variable can be found\n    ///\n    /// Else None.\n    static Optional<Loop::LoopBounds> getBounds(const Loop &L, PHINode &IndVar,\n                                                ScalarEvolution &SE);\n\n    /// Get the initial value of the loop induction variable.\n    Value &getInitialIVValue() const { return InitialIVValue; }\n\n    /// Get the instruction that updates the loop induction variable.\n    Instruction &getStepInst() const { return StepInst; }\n\n    /// Get the step that the loop induction variable gets updated by in each\n    /// loop iteration. Return nullptr if not found.\n    Value *getStepValue() const { return StepValue; }\n\n    /// Get the final value of the loop induction variable.\n    Value &getFinalIVValue() const { return FinalIVValue; }\n\n    /// Return the canonical predicate for the latch compare instruction, if\n    /// able to be calcuated. Else BAD_ICMP_PREDICATE.\n    ///\n    /// A predicate is considered as canonical if requirements below are all\n    /// satisfied:\n    /// 1. The first successor of the latch branch is the loop header\n    ///    If not, inverse the predicate.\n    /// 2. One of the operands of the latch comparison is StepInst\n    ///    If not, and\n    ///    - if the current calcuated predicate is not ne or eq, flip the\n    ///      predicate.\n    ///    - else if the loop is increasing, return slt\n    ///      (notice that it is safe to change from ne or eq to sign compare)\n    ///    - else if the loop is decreasing, return sgt\n    ///      (notice that it is safe to change from ne or eq to sign compare)\n    ///\n    /// Here is an example when both (1) and (2) are not satisfied:\n    /// \\code\n    /// loop.header:\n    ///  %iv = phi [%initialiv, %loop.preheader], [%inc, %loop.header]\n    ///  %inc = add %iv, %step\n    ///  %cmp = slt %iv, %finaliv\n    ///  br %cmp, %loop.exit, %loop.header\n    /// loop.exit:\n    /// \\endcode\n    /// - The second successor of the latch branch is the loop header instead\n    ///   of the first successor (slt -> sge)\n    /// - The first operand of the latch comparison (%cmp) is the IndVar (%iv)\n    ///   instead of the StepInst (%inc) (sge -> sgt)\n    ///\n    /// The predicate would be sgt if both (1) and (2) are satisfied.\n    /// getCanonicalPredicate() returns sgt for this example.\n    /// Note: The IR is not changed.\n    ICmpInst::Predicate getCanonicalPredicate() const;\n\n    /// An enum for the direction of the loop\n    /// - for (int i = 0; i < ub; ++i)  --> Increasing\n    /// - for (int i = ub; i > 0; --i)  --> Descresing\n    /// - for (int i = x; i != y; i+=z) --> Unknown\n    enum class Direction { Increasing, Decreasing, Unknown };\n\n    /// Get the direction of the loop.\n    Direction getDirection() const;\n\n  private:\n    LoopBounds(const Loop &Loop, Value &I, Instruction &SI, Value *SV, Value &F,\n               ScalarEvolution &SE)\n        : L(Loop), InitialIVValue(I), StepInst(SI), StepValue(SV),\n          FinalIVValue(F), SE(SE) {}\n\n    const Loop &L;\n\n    // The initial value of the loop induction variable\n    Value &InitialIVValue;\n\n    // The instruction that updates the loop induction variable\n    Instruction &StepInst;\n\n    // The value that the loop induction variable gets updated by in each loop\n    // iteration\n    Value *StepValue;\n\n    // The final value of the loop induction variable\n    Value &FinalIVValue;\n\n    ScalarEvolution &SE;\n  };\n\n  /// Return the struct LoopBounds collected if all struct members are found,\n  /// else None.\n  Optional<LoopBounds> getBounds(ScalarEvolution &SE) const;\n\n  /// Return the loop induction variable if found, else return nullptr.\n  /// An instruction is considered as the loop induction variable if\n  /// - it is an induction variable of the loop; and\n  /// - it is used to determine the condition of the branch in the loop latch\n  ///\n  /// Note: the induction variable doesn't need to be canonical, i.e. starts at\n  /// zero and increments by one each time through the loop (but it can be).\n  PHINode *getInductionVariable(ScalarEvolution &SE) const;\n\n  /// Get the loop induction descriptor for the loop induction variable. Return\n  /// true if the loop induction variable is found.\n  bool getInductionDescriptor(ScalarEvolution &SE,\n                              InductionDescriptor &IndDesc) const;\n\n  /// Return true if the given PHINode \\p AuxIndVar is\n  /// - in the loop header\n  /// - not used outside of the loop\n  /// - incremented by a loop invariant step for each loop iteration\n  /// - step instruction opcode should be add or sub\n  /// Note: auxiliary induction variable is not required to be used in the\n  ///       conditional branch in the loop latch. (but it can be)\n  bool isAuxiliaryInductionVariable(PHINode &AuxIndVar,\n                                    ScalarEvolution &SE) const;\n\n  /// Return the loop guard branch, if it exists.\n  ///\n  /// This currently only works on simplified loop, as it requires a preheader\n  /// and a latch to identify the guard. It will work on loops of the form:\n  /// \\code\n  /// GuardBB:\n  ///   br cond1, Preheader, ExitSucc <== GuardBranch\n  /// Preheader:\n  ///   br Header\n  /// Header:\n  ///  ...\n  ///   br Latch\n  /// Latch:\n  ///   br cond2, Header, ExitBlock\n  /// ExitBlock:\n  ///   br ExitSucc\n  /// ExitSucc:\n  /// \\endcode\n  BranchInst *getLoopGuardBranch() const;\n\n  /// Return true iff the loop is\n  /// - in simplify rotated form, and\n  /// - guarded by a loop guard branch.\n  bool isGuarded() const { return (getLoopGuardBranch() != nullptr); }\n\n  /// Return true if the loop is in rotated form.\n  ///\n  /// This does not check if the loop was rotated by loop rotation, instead it\n  /// only checks if the loop is in rotated form (has a valid latch that exists\n  /// the loop).\n  bool isRotatedForm() const {\n    assert(!isInvalid() && \"Loop not in a valid state!\");\n    BasicBlock *Latch = getLoopLatch();\n    return Latch && isLoopExiting(Latch);\n  }\n\n  /// Return true if the loop induction variable starts at zero and increments\n  /// by one each time through the loop.\n  bool isCanonical(ScalarEvolution &SE) const;\n\n  /// Return true if the Loop is in LCSSA form.\n  bool isLCSSAForm(const DominatorTree &DT) const;\n\n  /// Return true if this Loop and all inner subloops are in LCSSA form.\n  bool isRecursivelyLCSSAForm(const DominatorTree &DT,\n                              const LoopInfo &LI) const;\n\n  /// Return true if the Loop is in the form that the LoopSimplify form\n  /// transforms loops to, which is sometimes called normal form.\n  bool isLoopSimplifyForm() const;\n\n  /// Return true if the loop body is safe to clone in practice.\n  bool isSafeToClone() const;\n\n  /// Returns true if the loop is annotated parallel.\n  ///\n  /// A parallel loop can be assumed to not contain any dependencies between\n  /// iterations by the compiler. That is, any loop-carried dependency checking\n  /// can be skipped completely when parallelizing the loop on the target\n  /// machine. Thus, if the parallel loop information originates from the\n  /// programmer, e.g. via the OpenMP parallel for pragma, it is the\n  /// programmer's responsibility to ensure there are no loop-carried\n  /// dependencies. The final execution order of the instructions across\n  /// iterations is not guaranteed, thus, the end result might or might not\n  /// implement actual concurrent execution of instructions across multiple\n  /// iterations.\n  bool isAnnotatedParallel() const;\n\n  /// Return the llvm.loop loop id metadata node for this loop if it is present.\n  ///\n  /// If this loop contains the same llvm.loop metadata on each branch to the\n  /// header then the node is returned. If any latch instruction does not\n  /// contain llvm.loop or if multiple latches contain different nodes then\n  /// 0 is returned.\n  MDNode *getLoopID() const;\n  /// Set the llvm.loop loop id metadata for this loop.\n  ///\n  /// The LoopID metadata node will be added to each terminator instruction in\n  /// the loop that branches to the loop header.\n  ///\n  /// The LoopID metadata node should have one or more operands and the first\n  /// operand should be the node itself.\n  void setLoopID(MDNode *LoopID) const;\n\n  /// Add llvm.loop.unroll.disable to this loop's loop id metadata.\n  ///\n  /// Remove existing unroll metadata and add unroll disable metadata to\n  /// indicate the loop has already been unrolled.  This prevents a loop\n  /// from being unrolled more than is directed by a pragma if the loop\n  /// unrolling pass is run more than once (which it generally is).\n  void setLoopAlreadyUnrolled();\n\n  /// Add llvm.loop.mustprogress to this loop's loop id metadata.\n  void setLoopMustProgress();\n\n  void dump() const;\n  void dumpVerbose() const;\n\n  /// Return the debug location of the start of this loop.\n  /// This looks for a BB terminating instruction with a known debug\n  /// location by looking at the preheader and header blocks. If it\n  /// cannot find a terminating instruction with location information,\n  /// it returns an unknown location.\n  DebugLoc getStartLoc() const;\n\n  /// Return the source code span of the loop.\n  LocRange getLocRange() const;\n\n  StringRef getName() const {\n    if (BasicBlock *Header = getHeader())\n      if (Header->hasName())\n        return Header->getName();\n    return \"<unnamed loop>\";\n  }\n\nprivate:\n  Loop() = default;\n\n  friend class LoopInfoBase<BasicBlock, Loop>;\n  friend class LoopBase<BasicBlock, Loop>;\n  explicit Loop(BasicBlock *BB) : LoopBase<BasicBlock, Loop>(BB) {}\n  ~Loop() = default;\n};\n\n//===----------------------------------------------------------------------===//\n/// This class builds and contains all of the top-level loop\n/// structures in the specified function.\n///\n\ntemplate <class BlockT, class LoopT> class LoopInfoBase {\n  // BBMap - Mapping of basic blocks to the inner most loop they occur in\n  DenseMap<const BlockT *, LoopT *> BBMap;\n  std::vector<LoopT *> TopLevelLoops;\n  BumpPtrAllocator LoopAllocator;\n\n  friend class LoopBase<BlockT, LoopT>;\n  friend class LoopInfo;\n\n  void operator=(const LoopInfoBase &) = delete;\n  LoopInfoBase(const LoopInfoBase &) = delete;\n\npublic:\n  LoopInfoBase() {}\n  ~LoopInfoBase() { releaseMemory(); }\n\n  LoopInfoBase(LoopInfoBase &&Arg)\n      : BBMap(std::move(Arg.BBMap)),\n        TopLevelLoops(std::move(Arg.TopLevelLoops)),\n        LoopAllocator(std::move(Arg.LoopAllocator)) {\n    // We have to clear the arguments top level loops as we've taken ownership.\n    Arg.TopLevelLoops.clear();\n  }\n  LoopInfoBase &operator=(LoopInfoBase &&RHS) {\n    BBMap = std::move(RHS.BBMap);\n\n    for (auto *L : TopLevelLoops)\n      L->~LoopT();\n\n    TopLevelLoops = std::move(RHS.TopLevelLoops);\n    LoopAllocator = std::move(RHS.LoopAllocator);\n    RHS.TopLevelLoops.clear();\n    return *this;\n  }\n\n  void releaseMemory() {\n    BBMap.clear();\n\n    for (auto *L : TopLevelLoops)\n      L->~LoopT();\n    TopLevelLoops.clear();\n    LoopAllocator.Reset();\n  }\n\n  template <typename... ArgsTy> LoopT *AllocateLoop(ArgsTy &&... Args) {\n    LoopT *Storage = LoopAllocator.Allocate<LoopT>();\n    return new (Storage) LoopT(std::forward<ArgsTy>(Args)...);\n  }\n\n  /// iterator/begin/end - The interface to the top-level loops in the current\n  /// function.\n  ///\n  typedef typename std::vector<LoopT *>::const_iterator iterator;\n  typedef\n      typename std::vector<LoopT *>::const_reverse_iterator reverse_iterator;\n  iterator begin() const { return TopLevelLoops.begin(); }\n  iterator end() const { return TopLevelLoops.end(); }\n  reverse_iterator rbegin() const { return TopLevelLoops.rbegin(); }\n  reverse_iterator rend() const { return TopLevelLoops.rend(); }\n  bool empty() const { return TopLevelLoops.empty(); }\n\n  /// Return all of the loops in the function in preorder across the loop\n  /// nests, with siblings in forward program order.\n  ///\n  /// Note that because loops form a forest of trees, preorder is equivalent to\n  /// reverse postorder.\n  SmallVector<LoopT *, 4> getLoopsInPreorder();\n\n  /// Return all of the loops in the function in preorder across the loop\n  /// nests, with siblings in *reverse* program order.\n  ///\n  /// Note that because loops form a forest of trees, preorder is equivalent to\n  /// reverse postorder.\n  ///\n  /// Also note that this is *not* a reverse preorder. Only the siblings are in\n  /// reverse program order.\n  SmallVector<LoopT *, 4> getLoopsInReverseSiblingPreorder();\n\n  /// Return the inner most loop that BB lives in. If a basic block is in no\n  /// loop (for example the entry node), null is returned.\n  LoopT *getLoopFor(const BlockT *BB) const { return BBMap.lookup(BB); }\n\n  /// Same as getLoopFor.\n  const LoopT *operator[](const BlockT *BB) const { return getLoopFor(BB); }\n\n  /// Return the loop nesting level of the specified block. A depth of 0 means\n  /// the block is not inside any loop.\n  unsigned getLoopDepth(const BlockT *BB) const {\n    const LoopT *L = getLoopFor(BB);\n    return L ? L->getLoopDepth() : 0;\n  }\n\n  // True if the block is a loop header node\n  bool isLoopHeader(const BlockT *BB) const {\n    const LoopT *L = getLoopFor(BB);\n    return L && L->getHeader() == BB;\n  }\n\n  /// Return the top-level loops.\n  const std::vector<LoopT *> &getTopLevelLoops() const { return TopLevelLoops; }\n\n  /// Return the top-level loops.\n  std::vector<LoopT *> &getTopLevelLoopsVector() { return TopLevelLoops; }\n\n  /// This removes the specified top-level loop from this loop info object.\n  /// The loop is not deleted, as it will presumably be inserted into\n  /// another loop.\n  LoopT *removeLoop(iterator I) {\n    assert(I != end() && \"Cannot remove end iterator!\");\n    LoopT *L = *I;\n    assert(L->isOutermost() && \"Not a top-level loop!\");\n    TopLevelLoops.erase(TopLevelLoops.begin() + (I - begin()));\n    return L;\n  }\n\n  /// Change the top-level loop that contains BB to the specified loop.\n  /// This should be used by transformations that restructure the loop hierarchy\n  /// tree.\n  void changeLoopFor(BlockT *BB, LoopT *L) {\n    if (!L) {\n      BBMap.erase(BB);\n      return;\n    }\n    BBMap[BB] = L;\n  }\n\n  /// Replace the specified loop in the top-level loops list with the indicated\n  /// loop.\n  void changeTopLevelLoop(LoopT *OldLoop, LoopT *NewLoop) {\n    auto I = find(TopLevelLoops, OldLoop);\n    assert(I != TopLevelLoops.end() && \"Old loop not at top level!\");\n    *I = NewLoop;\n    assert(!NewLoop->ParentLoop && !OldLoop->ParentLoop &&\n           \"Loops already embedded into a subloop!\");\n  }\n\n  /// This adds the specified loop to the collection of top-level loops.\n  void addTopLevelLoop(LoopT *New) {\n    assert(New->isOutermost() && \"Loop already in subloop!\");\n    TopLevelLoops.push_back(New);\n  }\n\n  /// This method completely removes BB from all data structures,\n  /// including all of the Loop objects it is nested in and our mapping from\n  /// BasicBlocks to loops.\n  void removeBlock(BlockT *BB) {\n    auto I = BBMap.find(BB);\n    if (I != BBMap.end()) {\n      for (LoopT *L = I->second; L; L = L->getParentLoop())\n        L->removeBlockFromLoop(BB);\n\n      BBMap.erase(I);\n    }\n  }\n\n  // Internals\n\n  static bool isNotAlreadyContainedIn(const LoopT *SubLoop,\n                                      const LoopT *ParentLoop) {\n    if (!SubLoop)\n      return true;\n    if (SubLoop == ParentLoop)\n      return false;\n    return isNotAlreadyContainedIn(SubLoop->getParentLoop(), ParentLoop);\n  }\n\n  /// Create the loop forest using a stable algorithm.\n  void analyze(const DominatorTreeBase<BlockT, false> &DomTree);\n\n  // Debugging\n  void print(raw_ostream &OS) const;\n\n  void verify(const DominatorTreeBase<BlockT, false> &DomTree) const;\n\n  /// Destroy a loop that has been removed from the `LoopInfo` nest.\n  ///\n  /// This runs the destructor of the loop object making it invalid to\n  /// reference afterward. The memory is retained so that the *pointer* to the\n  /// loop remains valid.\n  ///\n  /// The caller is responsible for removing this loop from the loop nest and\n  /// otherwise disconnecting it from the broader `LoopInfo` data structures.\n  /// Callers that don't naturally handle this themselves should probably call\n  /// `erase' instead.\n  void destroy(LoopT *L) {\n    L->~LoopT();\n\n    // Since LoopAllocator is a BumpPtrAllocator, this Deallocate only poisons\n    // \\c L, but the pointer remains valid for non-dereferencing uses.\n    LoopAllocator.Deallocate(L);\n  }\n};\n\n// Implementation in LoopInfoImpl.h\nextern template class LoopInfoBase<BasicBlock, Loop>;\n\nclass LoopInfo : public LoopInfoBase<BasicBlock, Loop> {\n  typedef LoopInfoBase<BasicBlock, Loop> BaseT;\n\n  friend class LoopBase<BasicBlock, Loop>;\n\n  void operator=(const LoopInfo &) = delete;\n  LoopInfo(const LoopInfo &) = delete;\n\npublic:\n  LoopInfo() {}\n  explicit LoopInfo(const DominatorTreeBase<BasicBlock, false> &DomTree);\n\n  LoopInfo(LoopInfo &&Arg) : BaseT(std::move(static_cast<BaseT &>(Arg))) {}\n  LoopInfo &operator=(LoopInfo &&RHS) {\n    BaseT::operator=(std::move(static_cast<BaseT &>(RHS)));\n    return *this;\n  }\n\n  /// Handle invalidation explicitly.\n  bool invalidate(Function &F, const PreservedAnalyses &PA,\n                  FunctionAnalysisManager::Invalidator &);\n\n  // Most of the public interface is provided via LoopInfoBase.\n\n  /// Update LoopInfo after removing the last backedge from a loop. This updates\n  /// the loop forest and parent loops for each block so that \\c L is no longer\n  /// referenced, but does not actually delete \\c L immediately. The pointer\n  /// will remain valid until this LoopInfo's memory is released.\n  void erase(Loop *L);\n\n  /// Returns true if replacing From with To everywhere is guaranteed to\n  /// preserve LCSSA form.\n  bool replacementPreservesLCSSAForm(Instruction *From, Value *To) {\n    // Preserving LCSSA form is only problematic if the replacing value is an\n    // instruction.\n    Instruction *I = dyn_cast<Instruction>(To);\n    if (!I)\n      return true;\n    // If both instructions are defined in the same basic block then replacement\n    // cannot break LCSSA form.\n    if (I->getParent() == From->getParent())\n      return true;\n    // If the instruction is not defined in a loop then it can safely replace\n    // anything.\n    Loop *ToLoop = getLoopFor(I->getParent());\n    if (!ToLoop)\n      return true;\n    // If the replacing instruction is defined in the same loop as the original\n    // instruction, or in a loop that contains it as an inner loop, then using\n    // it as a replacement will not break LCSSA form.\n    return ToLoop->contains(getLoopFor(From->getParent()));\n  }\n\n  /// Checks if moving a specific instruction can break LCSSA in any loop.\n  ///\n  /// Return true if moving \\p Inst to before \\p NewLoc will break LCSSA,\n  /// assuming that the function containing \\p Inst and \\p NewLoc is currently\n  /// in LCSSA form.\n  bool movementPreservesLCSSAForm(Instruction *Inst, Instruction *NewLoc) {\n    assert(Inst->getFunction() == NewLoc->getFunction() &&\n           \"Can't reason about IPO!\");\n\n    auto *OldBB = Inst->getParent();\n    auto *NewBB = NewLoc->getParent();\n\n    // Movement within the same loop does not break LCSSA (the equality check is\n    // to avoid doing a hashtable lookup in case of intra-block movement).\n    if (OldBB == NewBB)\n      return true;\n\n    auto *OldLoop = getLoopFor(OldBB);\n    auto *NewLoop = getLoopFor(NewBB);\n\n    if (OldLoop == NewLoop)\n      return true;\n\n    // Check if Outer contains Inner; with the null loop counting as the\n    // \"outermost\" loop.\n    auto Contains = [](const Loop *Outer, const Loop *Inner) {\n      return !Outer || Outer->contains(Inner);\n    };\n\n    // To check that the movement of Inst to before NewLoc does not break LCSSA,\n    // we need to check two sets of uses for possible LCSSA violations at\n    // NewLoc: the users of NewInst, and the operands of NewInst.\n\n    // If we know we're hoisting Inst out of an inner loop to an outer loop,\n    // then the uses *of* Inst don't need to be checked.\n\n    if (!Contains(NewLoop, OldLoop)) {\n      for (Use &U : Inst->uses()) {\n        auto *UI = cast<Instruction>(U.getUser());\n        auto *UBB = isa<PHINode>(UI) ? cast<PHINode>(UI)->getIncomingBlock(U)\n                                     : UI->getParent();\n        if (UBB != NewBB && getLoopFor(UBB) != NewLoop)\n          return false;\n      }\n    }\n\n    // If we know we're sinking Inst from an outer loop into an inner loop, then\n    // the *operands* of Inst don't need to be checked.\n\n    if (!Contains(OldLoop, NewLoop)) {\n      // See below on why we can't handle phi nodes here.\n      if (isa<PHINode>(Inst))\n        return false;\n\n      for (Use &U : Inst->operands()) {\n        auto *DefI = dyn_cast<Instruction>(U.get());\n        if (!DefI)\n          return false;\n\n        // This would need adjustment if we allow Inst to be a phi node -- the\n        // new use block won't simply be NewBB.\n\n        auto *DefBlock = DefI->getParent();\n        if (DefBlock != NewBB && getLoopFor(DefBlock) != NewLoop)\n          return false;\n      }\n    }\n\n    return true;\n  }\n};\n\n// Allow clients to walk the list of nested loops...\ntemplate <> struct GraphTraits<const Loop *> {\n  typedef const Loop *NodeRef;\n  typedef LoopInfo::iterator ChildIteratorType;\n\n  static NodeRef getEntryNode(const Loop *L) { return L; }\n  static ChildIteratorType child_begin(NodeRef N) { return N->begin(); }\n  static ChildIteratorType child_end(NodeRef N) { return N->end(); }\n};\n\ntemplate <> struct GraphTraits<Loop *> {\n  typedef Loop *NodeRef;\n  typedef LoopInfo::iterator ChildIteratorType;\n\n  static NodeRef getEntryNode(Loop *L) { return L; }\n  static ChildIteratorType child_begin(NodeRef N) { return N->begin(); }\n  static ChildIteratorType child_end(NodeRef N) { return N->end(); }\n};\n\n/// Analysis pass that exposes the \\c LoopInfo for a function.\nclass LoopAnalysis : public AnalysisInfoMixin<LoopAnalysis> {\n  friend AnalysisInfoMixin<LoopAnalysis>;\n  static AnalysisKey Key;\n\npublic:\n  typedef LoopInfo Result;\n\n  LoopInfo run(Function &F, FunctionAnalysisManager &AM);\n};\n\n/// Printer pass for the \\c LoopAnalysis results.\nclass LoopPrinterPass : public PassInfoMixin<LoopPrinterPass> {\n  raw_ostream &OS;\n\npublic:\n  explicit LoopPrinterPass(raw_ostream &OS) : OS(OS) {}\n  PreservedAnalyses run(Function &F, FunctionAnalysisManager &AM);\n};\n\n/// Verifier pass for the \\c LoopAnalysis results.\nstruct LoopVerifierPass : public PassInfoMixin<LoopVerifierPass> {\n  PreservedAnalyses run(Function &F, FunctionAnalysisManager &AM);\n};\n\n/// The legacy pass manager's analysis pass to compute loop information.\nclass LoopInfoWrapperPass : public FunctionPass {\n  LoopInfo LI;\n\npublic:\n  static char ID; // Pass identification, replacement for typeid\n\n  LoopInfoWrapperPass();\n\n  LoopInfo &getLoopInfo() { return LI; }\n  const LoopInfo &getLoopInfo() const { return LI; }\n\n  /// Calculate the natural loop information for a given function.\n  bool runOnFunction(Function &F) override;\n\n  void verifyAnalysis() const override;\n\n  void releaseMemory() override { LI.releaseMemory(); }\n\n  void print(raw_ostream &O, const Module *M = nullptr) const override;\n\n  void getAnalysisUsage(AnalysisUsage &AU) const override;\n};\n\n/// Function to print a loop's contents as LLVM's text IR assembly.\nvoid printLoop(Loop &L, raw_ostream &OS, const std::string &Banner = \"\");\n\n/// Find and return the loop attribute node for the attribute @p Name in\n/// @p LoopID. Return nullptr if there is no such attribute.\nMDNode *findOptionMDForLoopID(MDNode *LoopID, StringRef Name);\n\n/// Find string metadata for a loop.\n///\n/// Returns the MDNode where the first operand is the metadata's name. The\n/// following operands are the metadata's values. If no metadata with @p Name is\n/// found, return nullptr.\nMDNode *findOptionMDForLoop(const Loop *TheLoop, StringRef Name);\n\n/// Return whether an MDNode might represent an access group.\n///\n/// Access group metadata nodes have to be distinct and empty. Being\n/// always-empty ensures that it never needs to be changed (which -- because\n/// MDNodes are designed immutable -- would require creating a new MDNode). Note\n/// that this is not a sufficient condition: not every distinct and empty NDNode\n/// is representing an access group.\nbool isValidAsAccessGroup(MDNode *AccGroup);\n\n/// Create a new LoopID after the loop has been transformed.\n///\n/// This can be used when no follow-up loop attributes are defined\n/// (llvm::makeFollowupLoopID returning None) to stop transformations to be\n/// applied again.\n///\n/// @param Context        The LLVMContext in which to create the new LoopID.\n/// @param OrigLoopID     The original LoopID; can be nullptr if the original\n///                       loop has no LoopID.\n/// @param RemovePrefixes Remove all loop attributes that have these prefixes.\n///                       Use to remove metadata of the transformation that has\n///                       been applied.\n/// @param AddAttrs       Add these loop attributes to the new LoopID.\n///\n/// @return A new LoopID that can be applied using Loop::setLoopID().\nllvm::MDNode *\nmakePostTransformationMetadata(llvm::LLVMContext &Context, MDNode *OrigLoopID,\n                               llvm::ArrayRef<llvm::StringRef> RemovePrefixes,\n                               llvm::ArrayRef<llvm::MDNode *> AddAttrs);\n\n} // End llvm namespace\n\n#endif\n"}, "19": {"id": 19, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Analysis/MemoryLocation.h", "content": "//===- MemoryLocation.h - Memory location descriptions ----------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n/// \\file\n/// This file provides utility analysis objects describing memory locations.\n/// These are used both by the Alias Analysis infrastructure and more\n/// specialized memory analysis layers.\n///\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_ANALYSIS_MEMORYLOCATION_H\n#define LLVM_ANALYSIS_MEMORYLOCATION_H\n\n#include \"llvm/ADT/DenseMapInfo.h\"\n#include \"llvm/ADT/Optional.h\"\n#include \"llvm/IR/Metadata.h\"\n#include \"llvm/Support/TypeSize.h\"\n\nnamespace llvm {\n\nclass CallBase;\nclass Instruction;\nclass LoadInst;\nclass StoreInst;\nclass MemTransferInst;\nclass MemIntrinsic;\nclass AtomicCmpXchgInst;\nclass AtomicMemTransferInst;\nclass AtomicMemIntrinsic;\nclass AtomicRMWInst;\nclass AnyMemTransferInst;\nclass AnyMemIntrinsic;\nclass TargetLibraryInfo;\nclass VAArgInst;\n\n// Represents the size of a MemoryLocation. Logically, it's an\n// Optional<uint63_t> that also carries a bit to represent whether the integer\n// it contains, N, is 'precise'. Precise, in this context, means that we know\n// that the area of storage referenced by the given MemoryLocation must be\n// precisely N bytes. An imprecise value is formed as the union of two or more\n// precise values, and can conservatively represent all of the values unioned\n// into it. Importantly, imprecise values are an *upper-bound* on the size of a\n// MemoryLocation.\n//\n// Concretely, a precise MemoryLocation is (%p, 4) in\n// store i32 0, i32* %p\n//\n// Since we know that %p must be at least 4 bytes large at this point.\n// Otherwise, we have UB. An example of an imprecise MemoryLocation is (%p, 4)\n// at the memcpy in\n//\n//   %n = select i1 %foo, i64 1, i64 4\n//   call void @llvm.memcpy.p0i8.p0i8.i64(i8* %p, i8* %baz, i64 %n, i32 1,\n//                                        i1 false)\n//\n// ...Since we'll copy *up to* 4 bytes into %p, but we can't guarantee that\n// we'll ever actually do so.\n//\n// If asked to represent a pathologically large value, this will degrade to\n// None.\nclass LocationSize {\n  enum : uint64_t {\n    BeforeOrAfterPointer = ~uint64_t(0),\n    AfterPointer = BeforeOrAfterPointer - 1,\n    MapEmpty = BeforeOrAfterPointer - 2,\n    MapTombstone = BeforeOrAfterPointer - 3,\n    ImpreciseBit = uint64_t(1) << 63,\n\n    // The maximum value we can represent without falling back to 'unknown'.\n    MaxValue = (MapTombstone - 1) & ~ImpreciseBit,\n  };\n\n  uint64_t Value;\n\n  // Hack to support implicit construction. This should disappear when the\n  // public LocationSize ctor goes away.\n  enum DirectConstruction { Direct };\n\n  constexpr LocationSize(uint64_t Raw, DirectConstruction): Value(Raw) {}\n\n  static_assert(AfterPointer & ImpreciseBit,\n                \"AfterPointer is imprecise by definition.\");\n  static_assert(BeforeOrAfterPointer & ImpreciseBit,\n                \"BeforeOrAfterPointer is imprecise by definition.\");\n\npublic:\n  // FIXME: Migrate all users to construct via either `precise` or `upperBound`,\n  // to make it more obvious at the callsite the kind of size that they're\n  // providing.\n  //\n  // Since the overwhelming majority of users of this provide precise values,\n  // this assumes the provided value is precise.\n  constexpr LocationSize(uint64_t Raw)\n      : Value(Raw > MaxValue ? AfterPointer : Raw) {}\n\n  static LocationSize precise(uint64_t Value) { return LocationSize(Value); }\n  static LocationSize precise(TypeSize Value) {\n    if (Value.isScalable())\n      return afterPointer();\n    return precise(Value.getFixedSize());\n  }\n\n  static LocationSize upperBound(uint64_t Value) {\n    // You can't go lower than 0, so give a precise result.\n    if (LLVM_UNLIKELY(Value == 0))\n      return precise(0);\n    if (LLVM_UNLIKELY(Value > MaxValue))\n      return afterPointer();\n    return LocationSize(Value | ImpreciseBit, Direct);\n  }\n  static LocationSize upperBound(TypeSize Value) {\n    if (Value.isScalable())\n      return afterPointer();\n    return upperBound(Value.getFixedSize());\n  }\n\n  /// Any location after the base pointer (but still within the underlying\n  /// object).\n  constexpr static LocationSize afterPointer() {\n    return LocationSize(AfterPointer, Direct);\n  }\n\n  /// Any location before or after the base pointer (but still within the\n  /// underlying object).\n  constexpr static LocationSize beforeOrAfterPointer() {\n    return LocationSize(BeforeOrAfterPointer, Direct);\n  }\n\n  // Sentinel values, generally used for maps.\n  constexpr static LocationSize mapTombstone() {\n    return LocationSize(MapTombstone, Direct);\n  }\n  constexpr static LocationSize mapEmpty() {\n    return LocationSize(MapEmpty, Direct);\n  }\n\n  // Returns a LocationSize that can correctly represent either `*this` or\n  // `Other`.\n  LocationSize unionWith(LocationSize Other) const {\n    if (Other == *this)\n      return *this;\n\n    if (Value == BeforeOrAfterPointer || Other.Value == BeforeOrAfterPointer)\n      return beforeOrAfterPointer();\n    if (Value == AfterPointer || Other.Value == AfterPointer)\n      return afterPointer();\n\n    return upperBound(std::max(getValue(), Other.getValue()));\n  }\n\n  bool hasValue() const {\n    return Value != AfterPointer && Value != BeforeOrAfterPointer;\n  }\n  uint64_t getValue() const {\n    assert(hasValue() && \"Getting value from an unknown LocationSize!\");\n    return Value & ~ImpreciseBit;\n  }\n\n  // Returns whether or not this value is precise. Note that if a value is\n  // precise, it's guaranteed to not be unknown.\n  bool isPrecise() const {\n    return (Value & ImpreciseBit) == 0;\n  }\n\n  // Convenience method to check if this LocationSize's value is 0.\n  bool isZero() const { return hasValue() && getValue() == 0; }\n\n  /// Whether accesses before the base pointer are possible.\n  bool mayBeBeforePointer() const { return Value == BeforeOrAfterPointer; }\n\n  bool operator==(const LocationSize &Other) const {\n    return Value == Other.Value;\n  }\n\n  bool operator!=(const LocationSize &Other) const {\n    return !(*this == Other);\n  }\n\n  // Ordering operators are not provided, since it's unclear if there's only one\n  // reasonable way to compare:\n  // - values that don't exist against values that do, and\n  // - precise values to imprecise values\n\n  void print(raw_ostream &OS) const;\n\n  // Returns an opaque value that represents this LocationSize. Cannot be\n  // reliably converted back into a LocationSize.\n  uint64_t toRaw() const { return Value; }\n};\n\ninline raw_ostream &operator<<(raw_ostream &OS, LocationSize Size) {\n  Size.print(OS);\n  return OS;\n}\n\n/// Representation for a specific memory location.\n///\n/// This abstraction can be used to represent a specific location in memory.\n/// The goal of the location is to represent enough information to describe\n/// abstract aliasing, modification, and reference behaviors of whatever\n/// value(s) are stored in memory at the particular location.\n///\n/// The primary user of this interface is LLVM's Alias Analysis, but other\n/// memory analyses such as MemoryDependence can use it as well.\nclass MemoryLocation {\npublic:\n  /// UnknownSize - This is a special value which can be used with the\n  /// size arguments in alias queries to indicate that the caller does not\n  /// know the sizes of the potential memory references.\n  enum : uint64_t { UnknownSize = ~UINT64_C(0) };\n\n  /// The address of the start of the location.\n  const Value *Ptr;\n\n  /// The maximum size of the location, in address-units, or\n  /// UnknownSize if the size is not known.\n  ///\n  /// Note that an unknown size does not mean the pointer aliases the entire\n  /// virtual address space, because there are restrictions on stepping out of\n  /// one object and into another. See\n  /// http://llvm.org/docs/LangRef.html#pointeraliasing\n  LocationSize Size;\n\n  /// The metadata nodes which describes the aliasing of the location (each\n  /// member is null if that kind of information is unavailable).\n  AAMDNodes AATags;\n\n  void print(raw_ostream &OS) const { OS << *Ptr << \" \" << Size << \"\\n\"; }\n\n  /// Return a location with information about the memory reference by the given\n  /// instruction.\n  static MemoryLocation get(const LoadInst *LI);\n  static MemoryLocation get(const StoreInst *SI);\n  static MemoryLocation get(const VAArgInst *VI);\n  static MemoryLocation get(const AtomicCmpXchgInst *CXI);\n  static MemoryLocation get(const AtomicRMWInst *RMWI);\n  static MemoryLocation get(const Instruction *Inst) {\n    return *MemoryLocation::getOrNone(Inst);\n  }\n  static Optional<MemoryLocation> getOrNone(const Instruction *Inst);\n\n  /// Return a location representing the source of a memory transfer.\n  static MemoryLocation getForSource(const MemTransferInst *MTI);\n  static MemoryLocation getForSource(const AtomicMemTransferInst *MTI);\n  static MemoryLocation getForSource(const AnyMemTransferInst *MTI);\n\n  /// Return a location representing the destination of a memory set or\n  /// transfer.\n  static MemoryLocation getForDest(const MemIntrinsic *MI);\n  static MemoryLocation getForDest(const AtomicMemIntrinsic *MI);\n  static MemoryLocation getForDest(const AnyMemIntrinsic *MI);\n\n  /// Return a location representing a particular argument of a call.\n  static MemoryLocation getForArgument(const CallBase *Call, unsigned ArgIdx,\n                                       const TargetLibraryInfo *TLI);\n  static MemoryLocation getForArgument(const CallBase *Call, unsigned ArgIdx,\n                                       const TargetLibraryInfo &TLI) {\n    return getForArgument(Call, ArgIdx, &TLI);\n  }\n\n  /// Return a location that may access any location after Ptr, while remaining\n  /// within the underlying object.\n  static MemoryLocation getAfter(const Value *Ptr,\n                                 const AAMDNodes &AATags = AAMDNodes()) {\n    return MemoryLocation(Ptr, LocationSize::afterPointer(), AATags);\n  }\n\n  /// Return a location that may access any location before or after Ptr, while\n  /// remaining within the underlying object.\n  static MemoryLocation\n  getBeforeOrAfter(const Value *Ptr, const AAMDNodes &AATags = AAMDNodes()) {\n    return MemoryLocation(Ptr, LocationSize::beforeOrAfterPointer(), AATags);\n  }\n\n  // Return the exact size if the exact size is known at compiletime,\n  // otherwise return MemoryLocation::UnknownSize.\n  static uint64_t getSizeOrUnknown(const TypeSize &T) {\n    return T.isScalable() ? UnknownSize : T.getFixedSize();\n  }\n\n  MemoryLocation()\n      : Ptr(nullptr), Size(LocationSize::beforeOrAfterPointer()), AATags() {}\n\n  explicit MemoryLocation(const Value *Ptr, LocationSize Size,\n                          const AAMDNodes &AATags = AAMDNodes())\n      : Ptr(Ptr), Size(Size), AATags(AATags) {}\n\n  MemoryLocation getWithNewPtr(const Value *NewPtr) const {\n    MemoryLocation Copy(*this);\n    Copy.Ptr = NewPtr;\n    return Copy;\n  }\n\n  MemoryLocation getWithNewSize(LocationSize NewSize) const {\n    MemoryLocation Copy(*this);\n    Copy.Size = NewSize;\n    return Copy;\n  }\n\n  MemoryLocation getWithoutAATags() const {\n    MemoryLocation Copy(*this);\n    Copy.AATags = AAMDNodes();\n    return Copy;\n  }\n\n  bool operator==(const MemoryLocation &Other) const {\n    return Ptr == Other.Ptr && Size == Other.Size && AATags == Other.AATags;\n  }\n};\n\n// Specialize DenseMapInfo.\ntemplate <> struct DenseMapInfo<LocationSize> {\n  static inline LocationSize getEmptyKey() {\n    return LocationSize::mapEmpty();\n  }\n  static inline LocationSize getTombstoneKey() {\n    return LocationSize::mapTombstone();\n  }\n  static unsigned getHashValue(const LocationSize &Val) {\n    return DenseMapInfo<uint64_t>::getHashValue(Val.toRaw());\n  }\n  static bool isEqual(const LocationSize &LHS, const LocationSize &RHS) {\n    return LHS == RHS;\n  }\n};\n\ntemplate <> struct DenseMapInfo<MemoryLocation> {\n  static inline MemoryLocation getEmptyKey() {\n    return MemoryLocation(DenseMapInfo<const Value *>::getEmptyKey(),\n                          DenseMapInfo<LocationSize>::getEmptyKey());\n  }\n  static inline MemoryLocation getTombstoneKey() {\n    return MemoryLocation(DenseMapInfo<const Value *>::getTombstoneKey(),\n                          DenseMapInfo<LocationSize>::getTombstoneKey());\n  }\n  static unsigned getHashValue(const MemoryLocation &Val) {\n    return DenseMapInfo<const Value *>::getHashValue(Val.Ptr) ^\n           DenseMapInfo<LocationSize>::getHashValue(Val.Size) ^\n           DenseMapInfo<AAMDNodes>::getHashValue(Val.AATags);\n  }\n  static bool isEqual(const MemoryLocation &LHS, const MemoryLocation &RHS) {\n    return LHS == RHS;\n  }\n};\n}\n\n#endif\n"}, "20": {"id": 20, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Analysis/RegionPass.h", "content": "//===- RegionPass.h - RegionPass class --------------------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// This file defines the RegionPass class. All region based analysis,\n// optimization and transformation passes are derived from RegionPass.\n// This class is implemented following the some ideas of the LoopPass.h class.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_ANALYSIS_REGIONPASS_H\n#define LLVM_ANALYSIS_REGIONPASS_H\n\n#include \"llvm/Analysis/RegionInfo.h\"\n#include \"llvm/IR/LegacyPassManagers.h\"\n#include \"llvm/Pass.h\"\n#include <deque>\n\nnamespace llvm {\nclass Function;\nclass RGPassManager;\n\n//===----------------------------------------------------------------------===//\n/// A pass that runs on each Region in a function.\n///\n/// RegionPass is managed by RGPassManager.\nclass RegionPass : public Pass {\npublic:\n  explicit RegionPass(char &pid) : Pass(PT_Region, pid) {}\n\n  //===--------------------------------------------------------------------===//\n  /// @name To be implemented by every RegionPass\n  ///\n  //@{\n  /// Run the pass on a specific Region\n  ///\n  /// Accessing regions not contained in the current region is not allowed.\n  ///\n  /// @param R The region this pass is run on.\n  /// @param RGM The RegionPassManager that manages this Pass.\n  ///\n  /// @return True if the pass modifies this Region.\n  virtual bool runOnRegion(Region *R, RGPassManager &RGM) = 0;\n\n  /// Get a pass to print the LLVM IR in the region.\n  ///\n  /// @param O      The output stream to print the Region.\n  /// @param Banner The banner to separate different printed passes.\n  ///\n  /// @return The pass to print the LLVM IR in the region.\n  Pass *createPrinterPass(raw_ostream &O,\n                          const std::string &Banner) const override;\n\n  using llvm::Pass::doInitialization;\n  using llvm::Pass::doFinalization;\n\n  virtual bool doInitialization(Region *R, RGPassManager &RGM) { return false; }\n  virtual bool doFinalization() { return false; }\n  //@}\n\n  //===--------------------------------------------------------------------===//\n  /// @name PassManager API\n  ///\n  //@{\n  void preparePassManager(PMStack &PMS) override;\n\n  void assignPassManager(PMStack &PMS,\n                         PassManagerType PMT = PMT_RegionPassManager) override;\n\n  PassManagerType getPotentialPassManagerType() const override {\n    return PMT_RegionPassManager;\n  }\n  //@}\n\nprotected:\n  /// Optional passes call this function to check whether the pass should be\n  /// skipped. This is the case when optimization bisect is over the limit.\n  bool skipRegion(Region &R) const;\n};\n\n/// The pass manager to schedule RegionPasses.\nclass RGPassManager : public FunctionPass, public PMDataManager {\n  std::deque<Region*> RQ;\n  RegionInfo *RI;\n  Region *CurrentRegion;\n\npublic:\n  static char ID;\n  explicit RGPassManager();\n\n  /// Execute all of the passes scheduled for execution.\n  ///\n  /// @return True if any of the passes modifies the function.\n  bool runOnFunction(Function &F) override;\n\n  /// Pass Manager itself does not invalidate any analysis info.\n  /// RGPassManager needs RegionInfo.\n  void getAnalysisUsage(AnalysisUsage &Info) const override;\n\n  StringRef getPassName() const override { return \"Region Pass Manager\"; }\n\n  PMDataManager *getAsPMDataManager() override { return this; }\n  Pass *getAsPass() override { return this; }\n\n  /// Print passes managed by this manager.\n  void dumpPassStructure(unsigned Offset) override;\n\n  /// Get passes contained by this manager.\n  Pass *getContainedPass(unsigned N) {\n    assert(N < PassVector.size() && \"Pass number out of range!\");\n    Pass *FP = static_cast<Pass *>(PassVector[N]);\n    return FP;\n  }\n\n  PassManagerType getPassManagerType() const override {\n    return PMT_RegionPassManager;\n  }\n};\n\n} // End llvm namespace\n\n#endif\n"}, "21": {"id": 21, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h", "content": "//===- llvm/Analysis/ScalarEvolution.h - Scalar Evolution -------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// The ScalarEvolution class is an LLVM pass which can be used to analyze and\n// categorize scalar expressions in loops.  It specializes in recognizing\n// general induction variables, representing them with the abstract and opaque\n// SCEV class.  Given this analysis, trip counts of loops and other important\n// properties can be obtained.\n//\n// This analysis is primarily useful for induction variable substitution and\n// strength reduction.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_ANALYSIS_SCALAREVOLUTION_H\n#define LLVM_ANALYSIS_SCALAREVOLUTION_H\n\n#include \"llvm/ADT/APInt.h\"\n#include \"llvm/ADT/ArrayRef.h\"\n#include \"llvm/ADT/DenseMap.h\"\n#include \"llvm/ADT/DenseMapInfo.h\"\n#include \"llvm/ADT/FoldingSet.h\"\n#include \"llvm/ADT/Hashing.h\"\n#include \"llvm/ADT/Optional.h\"\n#include \"llvm/ADT/PointerIntPair.h\"\n#include \"llvm/ADT/SetVector.h\"\n#include \"llvm/ADT/SmallPtrSet.h\"\n#include \"llvm/ADT/SmallVector.h\"\n#include \"llvm/IR/ConstantRange.h\"\n#include \"llvm/IR/Function.h\"\n#include \"llvm/IR/InstrTypes.h\"\n#include \"llvm/IR/Instructions.h\"\n#include \"llvm/IR/Operator.h\"\n#include \"llvm/IR/PassManager.h\"\n#include \"llvm/IR/ValueHandle.h\"\n#include \"llvm/IR/ValueMap.h\"\n#include \"llvm/Pass.h\"\n#include \"llvm/Support/Allocator.h\"\n#include \"llvm/Support/Casting.h\"\n#include \"llvm/Support/Compiler.h\"\n#include <algorithm>\n#include <cassert>\n#include <cstdint>\n#include <memory>\n#include <utility>\n\nnamespace llvm {\n\nclass AssumptionCache;\nclass BasicBlock;\nclass Constant;\nclass ConstantInt;\nclass DataLayout;\nclass DominatorTree;\nclass GEPOperator;\nclass Instruction;\nclass LLVMContext;\nclass Loop;\nclass LoopInfo;\nclass raw_ostream;\nclass ScalarEvolution;\nclass SCEVAddRecExpr;\nclass SCEVUnknown;\nclass StructType;\nclass TargetLibraryInfo;\nclass Type;\nclass Value;\nenum SCEVTypes : unsigned short;\n\n/// This class represents an analyzed expression in the program.  These are\n/// opaque objects that the client is not allowed to do much with directly.\n///\nclass SCEV : public FoldingSetNode {\n  friend struct FoldingSetTrait<SCEV>;\n\n  /// A reference to an Interned FoldingSetNodeID for this node.  The\n  /// ScalarEvolution's BumpPtrAllocator holds the data.\n  FoldingSetNodeIDRef FastID;\n\n  // The SCEV baseclass this node corresponds to\n  const SCEVTypes SCEVType;\n\nprotected:\n  // Estimated complexity of this node's expression tree size.\n  const unsigned short ExpressionSize;\n\n  /// This field is initialized to zero and may be used in subclasses to store\n  /// miscellaneous information.\n  unsigned short SubclassData = 0;\n\npublic:\n  /// NoWrapFlags are bitfield indices into SubclassData.\n  ///\n  /// Add and Mul expressions may have no-unsigned-wrap <NUW> or\n  /// no-signed-wrap <NSW> properties, which are derived from the IR\n  /// operator. NSW is a misnomer that we use to mean no signed overflow or\n  /// underflow.\n  ///\n  /// AddRec expressions may have a no-self-wraparound <NW> property if, in\n  /// the integer domain, abs(step) * max-iteration(loop) <=\n  /// unsigned-max(bitwidth).  This means that the recurrence will never reach\n  /// its start value if the step is non-zero.  Computing the same value on\n  /// each iteration is not considered wrapping, and recurrences with step = 0\n  /// are trivially <NW>.  <NW> is independent of the sign of step and the\n  /// value the add recurrence starts with.\n  ///\n  /// Note that NUW and NSW are also valid properties of a recurrence, and\n  /// either implies NW. For convenience, NW will be set for a recurrence\n  /// whenever either NUW or NSW are set.\n  enum NoWrapFlags {\n    FlagAnyWrap = 0,    // No guarantee.\n    FlagNW = (1 << 0),  // No self-wrap.\n    FlagNUW = (1 << 1), // No unsigned wrap.\n    FlagNSW = (1 << 2), // No signed wrap.\n    NoWrapMask = (1 << 3) - 1\n  };\n\n  explicit SCEV(const FoldingSetNodeIDRef ID, SCEVTypes SCEVTy,\n                unsigned short ExpressionSize)\n      : FastID(ID), SCEVType(SCEVTy), ExpressionSize(ExpressionSize) {}\n  SCEV(const SCEV &) = delete;\n  SCEV &operator=(const SCEV &) = delete;\n\n  SCEVTypes getSCEVType() const { return SCEVType; }\n\n  /// Return the LLVM type of this SCEV expression.\n  Type *getType() const;\n\n  /// Return true if the expression is a constant zero.\n  bool isZero() const;\n\n  /// Return true if the expression is a constant one.\n  bool isOne() const;\n\n  /// Return true if the expression is a constant all-ones value.\n  bool isAllOnesValue() const;\n\n  /// Return true if the specified scev is negated, but not a constant.\n  bool isNonConstantNegative() const;\n\n  // Returns estimated size of the mathematical expression represented by this\n  // SCEV. The rules of its calculation are following:\n  // 1) Size of a SCEV without operands (like constants and SCEVUnknown) is 1;\n  // 2) Size SCEV with operands Op1, Op2, ..., OpN is calculated by formula:\n  //    (1 + Size(Op1) + ... + Size(OpN)).\n  // This value gives us an estimation of time we need to traverse through this\n  // SCEV and all its operands recursively. We may use it to avoid performing\n  // heavy transformations on SCEVs of excessive size for sake of saving the\n  // compilation time.\n  unsigned short getExpressionSize() const {\n    return ExpressionSize;\n  }\n\n  /// Print out the internal representation of this scalar to the specified\n  /// stream.  This should really only be used for debugging purposes.\n  void print(raw_ostream &OS) const;\n\n  /// This method is used for debugging.\n  void dump() const;\n};\n\n// Specialize FoldingSetTrait for SCEV to avoid needing to compute\n// temporary FoldingSetNodeID values.\ntemplate <> struct FoldingSetTrait<SCEV> : DefaultFoldingSetTrait<SCEV> {\n  static void Profile(const SCEV &X, FoldingSetNodeID &ID) { ID = X.FastID; }\n\n  static bool Equals(const SCEV &X, const FoldingSetNodeID &ID, unsigned IDHash,\n                     FoldingSetNodeID &TempID) {\n    return ID == X.FastID;\n  }\n\n  static unsigned ComputeHash(const SCEV &X, FoldingSetNodeID &TempID) {\n    return X.FastID.ComputeHash();\n  }\n};\n\ninline raw_ostream &operator<<(raw_ostream &OS, const SCEV &S) {\n  S.print(OS);\n  return OS;\n}\n\n/// An object of this class is returned by queries that could not be answered.\n/// For example, if you ask for the number of iterations of a linked-list\n/// traversal loop, you will get one of these.  None of the standard SCEV\n/// operations are valid on this class, it is just a marker.\nstruct SCEVCouldNotCompute : public SCEV {\n  SCEVCouldNotCompute();\n\n  /// Methods for support type inquiry through isa, cast, and dyn_cast:\n  static bool classof(const SCEV *S);\n};\n\n/// This class represents an assumption made using SCEV expressions which can\n/// be checked at run-time.\nclass SCEVPredicate : public FoldingSetNode {\n  friend struct FoldingSetTrait<SCEVPredicate>;\n\n  /// A reference to an Interned FoldingSetNodeID for this node.  The\n  /// ScalarEvolution's BumpPtrAllocator holds the data.\n  FoldingSetNodeIDRef FastID;\n\npublic:\n  enum SCEVPredicateKind { P_Union, P_Equal, P_Wrap };\n\nprotected:\n  SCEVPredicateKind Kind;\n  ~SCEVPredicate() = default;\n  SCEVPredicate(const SCEVPredicate &) = default;\n  SCEVPredicate &operator=(const SCEVPredicate &) = default;\n\npublic:\n  SCEVPredicate(const FoldingSetNodeIDRef ID, SCEVPredicateKind Kind);\n\n  SCEVPredicateKind getKind() const { return Kind; }\n\n  /// Returns the estimated complexity of this predicate.  This is roughly\n  /// measured in the number of run-time checks required.\n  virtual unsigned getComplexity() const { return 1; }\n\n  /// Returns true if the predicate is always true. This means that no\n  /// assumptions were made and nothing needs to be checked at run-time.\n  virtual bool isAlwaysTrue() const = 0;\n\n  /// Returns true if this predicate implies \\p N.\n  virtual bool implies(const SCEVPredicate *N) const = 0;\n\n  /// Prints a textual representation of this predicate with an indentation of\n  /// \\p Depth.\n  virtual void print(raw_ostream &OS, unsigned Depth = 0) const = 0;\n\n  /// Returns the SCEV to which this predicate applies, or nullptr if this is\n  /// a SCEVUnionPredicate.\n  virtual const SCEV *getExpr() const = 0;\n};\n\ninline raw_ostream &operator<<(raw_ostream &OS, const SCEVPredicate &P) {\n  P.print(OS);\n  return OS;\n}\n\n// Specialize FoldingSetTrait for SCEVPredicate to avoid needing to compute\n// temporary FoldingSetNodeID values.\ntemplate <>\nstruct FoldingSetTrait<SCEVPredicate> : DefaultFoldingSetTrait<SCEVPredicate> {\n  static void Profile(const SCEVPredicate &X, FoldingSetNodeID &ID) {\n    ID = X.FastID;\n  }\n\n  static bool Equals(const SCEVPredicate &X, const FoldingSetNodeID &ID,\n                     unsigned IDHash, FoldingSetNodeID &TempID) {\n    return ID == X.FastID;\n  }\n\n  static unsigned ComputeHash(const SCEVPredicate &X,\n                              FoldingSetNodeID &TempID) {\n    return X.FastID.ComputeHash();\n  }\n};\n\n/// This class represents an assumption that two SCEV expressions are equal,\n/// and this can be checked at run-time.\nclass SCEVEqualPredicate final : public SCEVPredicate {\n  /// We assume that LHS == RHS.\n  const SCEV *LHS;\n  const SCEV *RHS;\n\npublic:\n  SCEVEqualPredicate(const FoldingSetNodeIDRef ID, const SCEV *LHS,\n                     const SCEV *RHS);\n\n  /// Implementation of the SCEVPredicate interface\n  bool implies(const SCEVPredicate *N) const override;\n  void print(raw_ostream &OS, unsigned Depth = 0) const override;\n  bool isAlwaysTrue() const override;\n  const SCEV *getExpr() const override;\n\n  /// Returns the left hand side of the equality.\n  const SCEV *getLHS() const { return LHS; }\n\n  /// Returns the right hand side of the equality.\n  const SCEV *getRHS() const { return RHS; }\n\n  /// Methods for support type inquiry through isa, cast, and dyn_cast:\n  static bool classof(const SCEVPredicate *P) {\n    return P->getKind() == P_Equal;\n  }\n};\n\n/// This class represents an assumption made on an AddRec expression. Given an\n/// affine AddRec expression {a,+,b}, we assume that it has the nssw or nusw\n/// flags (defined below) in the first X iterations of the loop, where X is a\n/// SCEV expression returned by getPredicatedBackedgeTakenCount).\n///\n/// Note that this does not imply that X is equal to the backedge taken\n/// count. This means that if we have a nusw predicate for i32 {0,+,1} with a\n/// predicated backedge taken count of X, we only guarantee that {0,+,1} has\n/// nusw in the first X iterations. {0,+,1} may still wrap in the loop if we\n/// have more than X iterations.\nclass SCEVWrapPredicate final : public SCEVPredicate {\npublic:\n  /// Similar to SCEV::NoWrapFlags, but with slightly different semantics\n  /// for FlagNUSW. The increment is considered to be signed, and a + b\n  /// (where b is the increment) is considered to wrap if:\n  ///    zext(a + b) != zext(a) + sext(b)\n  ///\n  /// If Signed is a function that takes an n-bit tuple and maps to the\n  /// integer domain as the tuples value interpreted as twos complement,\n  /// and Unsigned a function that takes an n-bit tuple and maps to the\n  /// integer domain as as the base two value of input tuple, then a + b\n  /// has IncrementNUSW iff:\n  ///\n  /// 0 <= Unsigned(a) + Signed(b) < 2^n\n  ///\n  /// The IncrementNSSW flag has identical semantics with SCEV::FlagNSW.\n  ///\n  /// Note that the IncrementNUSW flag is not commutative: if base + inc\n  /// has IncrementNUSW, then inc + base doesn't neccessarily have this\n  /// property. The reason for this is that this is used for sign/zero\n  /// extending affine AddRec SCEV expressions when a SCEVWrapPredicate is\n  /// assumed. A {base,+,inc} expression is already non-commutative with\n  /// regards to base and inc, since it is interpreted as:\n  ///     (((base + inc) + inc) + inc) ...\n  enum IncrementWrapFlags {\n    IncrementAnyWrap = 0,     // No guarantee.\n    IncrementNUSW = (1 << 0), // No unsigned with signed increment wrap.\n    IncrementNSSW = (1 << 1), // No signed with signed increment wrap\n                              // (equivalent with SCEV::NSW)\n    IncrementNoWrapMask = (1 << 2) - 1\n  };\n\n  /// Convenient IncrementWrapFlags manipulation methods.\n  LLVM_NODISCARD static SCEVWrapPredicate::IncrementWrapFlags\n  clearFlags(SCEVWrapPredicate::IncrementWrapFlags Flags,\n             SCEVWrapPredicate::IncrementWrapFlags OffFlags) {\n    assert((Flags & IncrementNoWrapMask) == Flags && \"Invalid flags value!\");\n    assert((OffFlags & IncrementNoWrapMask) == OffFlags &&\n           \"Invalid flags value!\");\n    return (SCEVWrapPredicate::IncrementWrapFlags)(Flags & ~OffFlags);\n  }\n\n  LLVM_NODISCARD static SCEVWrapPredicate::IncrementWrapFlags\n  maskFlags(SCEVWrapPredicate::IncrementWrapFlags Flags, int Mask) {\n    assert((Flags & IncrementNoWrapMask) == Flags && \"Invalid flags value!\");\n    assert((Mask & IncrementNoWrapMask) == Mask && \"Invalid mask value!\");\n\n    return (SCEVWrapPredicate::IncrementWrapFlags)(Flags & Mask);\n  }\n\n  LLVM_NODISCARD static SCEVWrapPredicate::IncrementWrapFlags\n  setFlags(SCEVWrapPredicate::IncrementWrapFlags Flags,\n           SCEVWrapPredicate::IncrementWrapFlags OnFlags) {\n    assert((Flags & IncrementNoWrapMask) == Flags && \"Invalid flags value!\");\n    assert((OnFlags & IncrementNoWrapMask) == OnFlags &&\n           \"Invalid flags value!\");\n\n    return (SCEVWrapPredicate::IncrementWrapFlags)(Flags | OnFlags);\n  }\n\n  /// Returns the set of SCEVWrapPredicate no wrap flags implied by a\n  /// SCEVAddRecExpr.\n  LLVM_NODISCARD static SCEVWrapPredicate::IncrementWrapFlags\n  getImpliedFlags(const SCEVAddRecExpr *AR, ScalarEvolution &SE);\n\nprivate:\n  const SCEVAddRecExpr *AR;\n  IncrementWrapFlags Flags;\n\npublic:\n  explicit SCEVWrapPredicate(const FoldingSetNodeIDRef ID,\n                             const SCEVAddRecExpr *AR,\n                             IncrementWrapFlags Flags);\n\n  /// Returns the set assumed no overflow flags.\n  IncrementWrapFlags getFlags() const { return Flags; }\n\n  /// Implementation of the SCEVPredicate interface\n  const SCEV *getExpr() const override;\n  bool implies(const SCEVPredicate *N) const override;\n  void print(raw_ostream &OS, unsigned Depth = 0) const override;\n  bool isAlwaysTrue() const override;\n\n  /// Methods for support type inquiry through isa, cast, and dyn_cast:\n  static bool classof(const SCEVPredicate *P) {\n    return P->getKind() == P_Wrap;\n  }\n};\n\n/// This class represents a composition of other SCEV predicates, and is the\n/// class that most clients will interact with.  This is equivalent to a\n/// logical \"AND\" of all the predicates in the union.\n///\n/// NB! Unlike other SCEVPredicate sub-classes this class does not live in the\n/// ScalarEvolution::Preds folding set.  This is why the \\c add function is sound.\nclass SCEVUnionPredicate final : public SCEVPredicate {\nprivate:\n  using PredicateMap =\n      DenseMap<const SCEV *, SmallVector<const SCEVPredicate *, 4>>;\n\n  /// Vector with references to all predicates in this union.\n  SmallVector<const SCEVPredicate *, 16> Preds;\n\n  /// Maps SCEVs to predicates for quick look-ups.\n  PredicateMap SCEVToPreds;\n\npublic:\n  SCEVUnionPredicate();\n\n  const SmallVectorImpl<const SCEVPredicate *> &getPredicates() const {\n    return Preds;\n  }\n\n  /// Adds a predicate to this union.\n  void add(const SCEVPredicate *N);\n\n  /// Returns a reference to a vector containing all predicates which apply to\n  /// \\p Expr.\n  ArrayRef<const SCEVPredicate *> getPredicatesForExpr(const SCEV *Expr);\n\n  /// Implementation of the SCEVPredicate interface\n  bool isAlwaysTrue() const override;\n  bool implies(const SCEVPredicate *N) const override;\n  void print(raw_ostream &OS, unsigned Depth) const override;\n  const SCEV *getExpr() const override;\n\n  /// We estimate the complexity of a union predicate as the size number of\n  /// predicates in the union.\n  unsigned getComplexity() const override { return Preds.size(); }\n\n  /// Methods for support type inquiry through isa, cast, and dyn_cast:\n  static bool classof(const SCEVPredicate *P) {\n    return P->getKind() == P_Union;\n  }\n};\n\n/// The main scalar evolution driver. Because client code (intentionally)\n/// can't do much with the SCEV objects directly, they must ask this class\n/// for services.\nclass ScalarEvolution {\n  friend class ScalarEvolutionsTest;\n\npublic:\n  /// An enum describing the relationship between a SCEV and a loop.\n  enum LoopDisposition {\n    LoopVariant,   ///< The SCEV is loop-variant (unknown).\n    LoopInvariant, ///< The SCEV is loop-invariant.\n    LoopComputable ///< The SCEV varies predictably with the loop.\n  };\n\n  /// An enum describing the relationship between a SCEV and a basic block.\n  enum BlockDisposition {\n    DoesNotDominateBlock,  ///< The SCEV does not dominate the block.\n    DominatesBlock,        ///< The SCEV dominates the block.\n    ProperlyDominatesBlock ///< The SCEV properly dominates the block.\n  };\n\n  /// Convenient NoWrapFlags manipulation that hides enum casts and is\n  /// visible in the ScalarEvolution name space.\n  LLVM_NODISCARD static SCEV::NoWrapFlags maskFlags(SCEV::NoWrapFlags Flags,\n                                                    int Mask) {\n    return (SCEV::NoWrapFlags)(Flags & Mask);\n  }\n  LLVM_NODISCARD static SCEV::NoWrapFlags setFlags(SCEV::NoWrapFlags Flags,\n                                                   SCEV::NoWrapFlags OnFlags) {\n    return (SCEV::NoWrapFlags)(Flags | OnFlags);\n  }\n  LLVM_NODISCARD static SCEV::NoWrapFlags\n  clearFlags(SCEV::NoWrapFlags Flags, SCEV::NoWrapFlags OffFlags) {\n    return (SCEV::NoWrapFlags)(Flags & ~OffFlags);\n  }\n\n  ScalarEvolution(Function &F, TargetLibraryInfo &TLI, AssumptionCache &AC,\n                  DominatorTree &DT, LoopInfo &LI);\n  ScalarEvolution(ScalarEvolution &&Arg);\n  ~ScalarEvolution();\n\n  LLVMContext &getContext() const { return F.getContext(); }\n\n  /// Test if values of the given type are analyzable within the SCEV\n  /// framework. This primarily includes integer types, and it can optionally\n  /// include pointer types if the ScalarEvolution class has access to\n  /// target-specific information.\n  bool isSCEVable(Type *Ty) const;\n\n  /// Return the size in bits of the specified type, for which isSCEVable must\n  /// return true.\n  uint64_t getTypeSizeInBits(Type *Ty) const;\n\n  /// Return a type with the same bitwidth as the given type and which\n  /// represents how SCEV will treat the given type, for which isSCEVable must\n  /// return true. For pointer types, this is the pointer-sized integer type.\n  Type *getEffectiveSCEVType(Type *Ty) const;\n\n  // Returns a wider type among {Ty1, Ty2}.\n  Type *getWiderType(Type *Ty1, Type *Ty2) const;\n\n  /// Return true if the SCEV is a scAddRecExpr or it contains\n  /// scAddRecExpr. The result will be cached in HasRecMap.\n  bool containsAddRecurrence(const SCEV *S);\n\n  /// Erase Value from ValueExprMap and ExprValueMap.\n  void eraseValueFromMap(Value *V);\n\n  /// Return a SCEV expression for the full generality of the specified\n  /// expression.\n  const SCEV *getSCEV(Value *V);\n\n  const SCEV *getConstant(ConstantInt *V);\n  const SCEV *getConstant(const APInt &Val);\n  const SCEV *getConstant(Type *Ty, uint64_t V, bool isSigned = false);\n  const SCEV *getPtrToIntExpr(const SCEV *Op, Type *Ty, unsigned Depth = 0);\n  const SCEV *getTruncateExpr(const SCEV *Op, Type *Ty, unsigned Depth = 0);\n  const SCEV *getZeroExtendExpr(const SCEV *Op, Type *Ty, unsigned Depth = 0);\n  const SCEV *getSignExtendExpr(const SCEV *Op, Type *Ty, unsigned Depth = 0);\n  const SCEV *getAnyExtendExpr(const SCEV *Op, Type *Ty);\n  const SCEV *getAddExpr(SmallVectorImpl<const SCEV *> &Ops,\n                         SCEV::NoWrapFlags Flags = SCEV::FlagAnyWrap,\n                         unsigned Depth = 0);\n  const SCEV *getAddExpr(const SCEV *LHS, const SCEV *RHS,\n                         SCEV::NoWrapFlags Flags = SCEV::FlagAnyWrap,\n                         unsigned Depth = 0) {\n    SmallVector<const SCEV *, 2> Ops = {LHS, RHS};\n    return getAddExpr(Ops, Flags, Depth);\n  }\n  const SCEV *getAddExpr(const SCEV *Op0, const SCEV *Op1, const SCEV *Op2,\n                         SCEV::NoWrapFlags Flags = SCEV::FlagAnyWrap,\n                         unsigned Depth = 0) {\n    SmallVector<const SCEV *, 3> Ops = {Op0, Op1, Op2};\n    return getAddExpr(Ops, Flags, Depth);\n  }\n  const SCEV *getMulExpr(SmallVectorImpl<const SCEV *> &Ops,\n                         SCEV::NoWrapFlags Flags = SCEV::FlagAnyWrap,\n                         unsigned Depth = 0);\n  const SCEV *getMulExpr(const SCEV *LHS, const SCEV *RHS,\n                         SCEV::NoWrapFlags Flags = SCEV::FlagAnyWrap,\n                         unsigned Depth = 0) {\n    SmallVector<const SCEV *, 2> Ops = {LHS, RHS};\n    return getMulExpr(Ops, Flags, Depth);\n  }\n  const SCEV *getMulExpr(const SCEV *Op0, const SCEV *Op1, const SCEV *Op2,\n                         SCEV::NoWrapFlags Flags = SCEV::FlagAnyWrap,\n                         unsigned Depth = 0) {\n    SmallVector<const SCEV *, 3> Ops = {Op0, Op1, Op2};\n    return getMulExpr(Ops, Flags, Depth);\n  }\n  const SCEV *getUDivExpr(const SCEV *LHS, const SCEV *RHS);\n  const SCEV *getUDivExactExpr(const SCEV *LHS, const SCEV *RHS);\n  const SCEV *getURemExpr(const SCEV *LHS, const SCEV *RHS);\n  const SCEV *getAddRecExpr(const SCEV *Start, const SCEV *Step, const Loop *L,\n                            SCEV::NoWrapFlags Flags);\n  const SCEV *getAddRecExpr(SmallVectorImpl<const SCEV *> &Operands,\n                            const Loop *L, SCEV::NoWrapFlags Flags);\n  const SCEV *getAddRecExpr(const SmallVectorImpl<const SCEV *> &Operands,\n                            const Loop *L, SCEV::NoWrapFlags Flags) {\n    SmallVector<const SCEV *, 4> NewOp(Operands.begin(), Operands.end());\n    return getAddRecExpr(NewOp, L, Flags);\n  }\n\n  /// Checks if \\p SymbolicPHI can be rewritten as an AddRecExpr under some\n  /// Predicates. If successful return these <AddRecExpr, Predicates>;\n  /// The function is intended to be called from PSCEV (the caller will decide\n  /// whether to actually add the predicates and carry out the rewrites).\n  Optional<std::pair<const SCEV *, SmallVector<const SCEVPredicate *, 3>>>\n  createAddRecFromPHIWithCasts(const SCEVUnknown *SymbolicPHI);\n\n  /// Returns an expression for a GEP\n  ///\n  /// \\p GEP The GEP. The indices contained in the GEP itself are ignored,\n  /// instead we use IndexExprs.\n  /// \\p IndexExprs The expressions for the indices.\n  const SCEV *getGEPExpr(GEPOperator *GEP,\n                         const SmallVectorImpl<const SCEV *> &IndexExprs);\n  const SCEV *getAbsExpr(const SCEV *Op, bool IsNSW);\n  const SCEV *getSignumExpr(const SCEV *Op);\n  const SCEV *getMinMaxExpr(SCEVTypes Kind,\n                            SmallVectorImpl<const SCEV *> &Operands);\n  const SCEV *getSMaxExpr(const SCEV *LHS, const SCEV *RHS);\n  const SCEV *getSMaxExpr(SmallVectorImpl<const SCEV *> &Operands);\n  const SCEV *getUMaxExpr(const SCEV *LHS, const SCEV *RHS);\n  const SCEV *getUMaxExpr(SmallVectorImpl<const SCEV *> &Operands);\n  const SCEV *getSMinExpr(const SCEV *LHS, const SCEV *RHS);\n  const SCEV *getSMinExpr(SmallVectorImpl<const SCEV *> &Operands);\n  const SCEV *getUMinExpr(const SCEV *LHS, const SCEV *RHS);\n  const SCEV *getUMinExpr(SmallVectorImpl<const SCEV *> &Operands);\n  const SCEV *getUnknown(Value *V);\n  const SCEV *getCouldNotCompute();\n\n  /// Return a SCEV for the constant 0 of a specific type.\n  const SCEV *getZero(Type *Ty) { return getConstant(Ty, 0); }\n\n  /// Return a SCEV for the constant 1 of a specific type.\n  const SCEV *getOne(Type *Ty) { return getConstant(Ty, 1); }\n\n  /// Return a SCEV for the constant -1 of a specific type.\n  const SCEV *getMinusOne(Type *Ty) {\n    return getConstant(Ty, -1, /*isSigned=*/true);\n  }\n\n  /// Return an expression for sizeof ScalableTy that is type IntTy, where\n  /// ScalableTy is a scalable vector type.\n  const SCEV *getSizeOfScalableVectorExpr(Type *IntTy,\n                                          ScalableVectorType *ScalableTy);\n\n  /// Return an expression for the alloc size of AllocTy that is type IntTy\n  const SCEV *getSizeOfExpr(Type *IntTy, Type *AllocTy);\n\n  /// Return an expression for the store size of StoreTy that is type IntTy\n  const SCEV *getStoreSizeOfExpr(Type *IntTy, Type *StoreTy);\n\n  /// Return an expression for offsetof on the given field with type IntTy\n  const SCEV *getOffsetOfExpr(Type *IntTy, StructType *STy, unsigned FieldNo);\n\n  /// Return the SCEV object corresponding to -V.\n  const SCEV *getNegativeSCEV(const SCEV *V,\n                              SCEV::NoWrapFlags Flags = SCEV::FlagAnyWrap);\n\n  /// Return the SCEV object corresponding to ~V.\n  const SCEV *getNotSCEV(const SCEV *V);\n\n  /// Return LHS-RHS.  Minus is represented in SCEV as A+B*-1.\n  const SCEV *getMinusSCEV(const SCEV *LHS, const SCEV *RHS,\n                           SCEV::NoWrapFlags Flags = SCEV::FlagAnyWrap,\n                           unsigned Depth = 0);\n\n  /// Return a SCEV corresponding to a conversion of the input value to the\n  /// specified type.  If the type must be extended, it is zero extended.\n  const SCEV *getTruncateOrZeroExtend(const SCEV *V, Type *Ty,\n                                      unsigned Depth = 0);\n\n  /// Return a SCEV corresponding to a conversion of the input value to the\n  /// specified type.  If the type must be extended, it is sign extended.\n  const SCEV *getTruncateOrSignExtend(const SCEV *V, Type *Ty,\n                                      unsigned Depth = 0);\n\n  /// Return a SCEV corresponding to a conversion of the input value to the\n  /// specified type.  If the type must be extended, it is zero extended.  The\n  /// conversion must not be narrowing.\n  const SCEV *getNoopOrZeroExtend(const SCEV *V, Type *Ty);\n\n  /// Return a SCEV corresponding to a conversion of the input value to the\n  /// specified type.  If the type must be extended, it is sign extended.  The\n  /// conversion must not be narrowing.\n  const SCEV *getNoopOrSignExtend(const SCEV *V, Type *Ty);\n\n  /// Return a SCEV corresponding to a conversion of the input value to the\n  /// specified type. If the type must be extended, it is extended with\n  /// unspecified bits. The conversion must not be narrowing.\n  const SCEV *getNoopOrAnyExtend(const SCEV *V, Type *Ty);\n\n  /// Return a SCEV corresponding to a conversion of the input value to the\n  /// specified type.  The conversion must not be widening.\n  const SCEV *getTruncateOrNoop(const SCEV *V, Type *Ty);\n\n  /// Promote the operands to the wider of the types using zero-extension, and\n  /// then perform a umax operation with them.\n  const SCEV *getUMaxFromMismatchedTypes(const SCEV *LHS, const SCEV *RHS);\n\n  /// Promote the operands to the wider of the types using zero-extension, and\n  /// then perform a umin operation with them.\n  const SCEV *getUMinFromMismatchedTypes(const SCEV *LHS, const SCEV *RHS);\n\n  /// Promote the operands to the wider of the types using zero-extension, and\n  /// then perform a umin operation with them. N-ary function.\n  const SCEV *getUMinFromMismatchedTypes(SmallVectorImpl<const SCEV *> &Ops);\n\n  /// Transitively follow the chain of pointer-type operands until reaching a\n  /// SCEV that does not have a single pointer operand. This returns a\n  /// SCEVUnknown pointer for well-formed pointer-type expressions, but corner\n  /// cases do exist.\n  const SCEV *getPointerBase(const SCEV *V);\n\n  /// Return a SCEV expression for the specified value at the specified scope\n  /// in the program.  The L value specifies a loop nest to evaluate the\n  /// expression at, where null is the top-level or a specified loop is\n  /// immediately inside of the loop.\n  ///\n  /// This method can be used to compute the exit value for a variable defined\n  /// in a loop by querying what the value will hold in the parent loop.\n  ///\n  /// In the case that a relevant loop exit value cannot be computed, the\n  /// original value V is returned.\n  const SCEV *getSCEVAtScope(const SCEV *S, const Loop *L);\n\n  /// This is a convenience function which does getSCEVAtScope(getSCEV(V), L).\n  const SCEV *getSCEVAtScope(Value *V, const Loop *L);\n\n  /// Test whether entry to the loop is protected by a conditional between LHS\n  /// and RHS.  This is used to help avoid max expressions in loop trip\n  /// counts, and to eliminate casts.\n  bool isLoopEntryGuardedByCond(const Loop *L, ICmpInst::Predicate Pred,\n                                const SCEV *LHS, const SCEV *RHS);\n\n  /// Test whether entry to the basic block is protected by a conditional\n  /// between LHS and RHS.\n  bool isBasicBlockEntryGuardedByCond(const BasicBlock *BB,\n                                      ICmpInst::Predicate Pred, const SCEV *LHS,\n                                      const SCEV *RHS);\n\n  /// Test whether the backedge of the loop is protected by a conditional\n  /// between LHS and RHS.  This is used to eliminate casts.\n  bool isLoopBackedgeGuardedByCond(const Loop *L, ICmpInst::Predicate Pred,\n                                   const SCEV *LHS, const SCEV *RHS);\n\n  /// Returns the maximum trip count of the loop if it is a single-exit\n  /// loop and we can compute a small maximum for that loop.\n  ///\n  /// Implemented in terms of the \\c getSmallConstantTripCount overload with\n  /// the single exiting block passed to it. See that routine for details.\n  unsigned getSmallConstantTripCount(const Loop *L);\n\n  /// Returns the maximum trip count of this loop as a normal unsigned\n  /// value. Returns 0 if the trip count is unknown or not constant. This\n  /// \"trip count\" assumes that control exits via ExitingBlock. More\n  /// precisely, it is the number of times that control may reach ExitingBlock\n  /// before taking the branch. For loops with multiple exits, it may not be\n  /// the number times that the loop header executes if the loop exits\n  /// prematurely via another branch.\n  unsigned getSmallConstantTripCount(const Loop *L,\n                                     const BasicBlock *ExitingBlock);\n\n  /// Returns the upper bound of the loop trip count as a normal unsigned\n  /// value.\n  /// Returns 0 if the trip count is unknown or not constant.\n  unsigned getSmallConstantMaxTripCount(const Loop *L);\n\n  /// Returns the largest constant divisor of the trip count of the\n  /// loop if it is a single-exit loop and we can compute a small maximum for\n  /// that loop.\n  ///\n  /// Implemented in terms of the \\c getSmallConstantTripMultiple overload with\n  /// the single exiting block passed to it. See that routine for details.\n  unsigned getSmallConstantTripMultiple(const Loop *L);\n\n  /// Returns the largest constant divisor of the trip count of this loop as a\n  /// normal unsigned value, if possible. This means that the actual trip\n  /// count is always a multiple of the returned value (don't forget the trip\n  /// count could very well be zero as well!). As explained in the comments\n  /// for getSmallConstantTripCount, this assumes that control exits the loop\n  /// via ExitingBlock.\n  unsigned getSmallConstantTripMultiple(const Loop *L,\n                                        const BasicBlock *ExitingBlock);\n\n  /// The terms \"backedge taken count\" and \"exit count\" are used\n  /// interchangeably to refer to the number of times the backedge of a loop \n  /// has executed before the loop is exited.\n  enum ExitCountKind {\n    /// An expression exactly describing the number of times the backedge has\n    /// executed when a loop is exited.\n    Exact,\n    /// A constant which provides an upper bound on the exact trip count.\n    ConstantMaximum,\n    /// An expression which provides an upper bound on the exact trip count.\n    SymbolicMaximum,\n  };\n\n  /// Return the number of times the backedge executes before the given exit\n  /// would be taken; if not exactly computable, return SCEVCouldNotCompute. \n  /// For a single exit loop, this value is equivelent to the result of\n  /// getBackedgeTakenCount.  The loop is guaranteed to exit (via *some* exit)\n  /// before the backedge is executed (ExitCount + 1) times.  Note that there\n  /// is no guarantee about *which* exit is taken on the exiting iteration.\n  const SCEV *getExitCount(const Loop *L, const BasicBlock *ExitingBlock,\n                           ExitCountKind Kind = Exact);\n\n  /// If the specified loop has a predictable backedge-taken count, return it,\n  /// otherwise return a SCEVCouldNotCompute object. The backedge-taken count is\n  /// the number of times the loop header will be branched to from within the\n  /// loop, assuming there are no abnormal exists like exception throws. This is\n  /// one less than the trip count of the loop, since it doesn't count the first\n  /// iteration, when the header is branched to from outside the loop.\n  ///\n  /// Note that it is not valid to call this method on a loop without a\n  /// loop-invariant backedge-taken count (see\n  /// hasLoopInvariantBackedgeTakenCount).\n  const SCEV *getBackedgeTakenCount(const Loop *L, ExitCountKind Kind = Exact);\n\n  /// Similar to getBackedgeTakenCount, except it will add a set of\n  /// SCEV predicates to Predicates that are required to be true in order for\n  /// the answer to be correct. Predicates can be checked with run-time\n  /// checks and can be used to perform loop versioning.\n  const SCEV *getPredicatedBackedgeTakenCount(const Loop *L,\n                                              SCEVUnionPredicate &Predicates);\n\n  /// When successful, this returns a SCEVConstant that is greater than or equal\n  /// to (i.e. a \"conservative over-approximation\") of the value returend by\n  /// getBackedgeTakenCount.  If such a value cannot be computed, it returns the\n  /// SCEVCouldNotCompute object.\n  const SCEV *getConstantMaxBackedgeTakenCount(const Loop *L) {\n    return getBackedgeTakenCount(L, ConstantMaximum);\n  }\n\n  /// When successful, this returns a SCEV that is greater than or equal\n  /// to (i.e. a \"conservative over-approximation\") of the value returend by\n  /// getBackedgeTakenCount.  If such a value cannot be computed, it returns the\n  /// SCEVCouldNotCompute object.\n  const SCEV *getSymbolicMaxBackedgeTakenCount(const Loop *L) {\n    return getBackedgeTakenCount(L, SymbolicMaximum);\n  }\n\n  /// Return true if the backedge taken count is either the value returned by\n  /// getConstantMaxBackedgeTakenCount or zero.\n  bool isBackedgeTakenCountMaxOrZero(const Loop *L);\n\n  /// Return true if the specified loop has an analyzable loop-invariant\n  /// backedge-taken count.\n  bool hasLoopInvariantBackedgeTakenCount(const Loop *L);\n\n  // This method should be called by the client when it made any change that\n  // would invalidate SCEV's answers, and the client wants to remove all loop\n  // information held internally by ScalarEvolution. This is intended to be used\n  // when the alternative to forget a loop is too expensive (i.e. large loop\n  // bodies).\n  void forgetAllLoops();\n\n  /// This method should be called by the client when it has changed a loop in\n  /// a way that may effect ScalarEvolution's ability to compute a trip count,\n  /// or if the loop is deleted.  This call is potentially expensive for large\n  /// loop bodies.\n  void forgetLoop(const Loop *L);\n\n  // This method invokes forgetLoop for the outermost loop of the given loop\n  // \\p L, making ScalarEvolution forget about all this subtree. This needs to\n  // be done whenever we make a transform that may affect the parameters of the\n  // outer loop, such as exit counts for branches.\n  void forgetTopmostLoop(const Loop *L);\n\n  /// This method should be called by the client when it has changed a value\n  /// in a way that may effect its value, or which may disconnect it from a\n  /// def-use chain linking it to a loop.\n  void forgetValue(Value *V);\n\n  /// Called when the client has changed the disposition of values in\n  /// this loop.\n  ///\n  /// We don't have a way to invalidate per-loop dispositions. Clear and\n  /// recompute is simpler.\n  void forgetLoopDispositions(const Loop *L);\n\n  /// Determine the minimum number of zero bits that S is guaranteed to end in\n  /// (at every loop iteration).  It is, at the same time, the minimum number\n  /// of times S is divisible by 2.  For example, given {4,+,8} it returns 2.\n  /// If S is guaranteed to be 0, it returns the bitwidth of S.\n  uint32_t GetMinTrailingZeros(const SCEV *S);\n\n  /// Determine the unsigned range for a particular SCEV.\n  /// NOTE: This returns a copy of the reference returned by getRangeRef.\n  ConstantRange getUnsignedRange(const SCEV *S) {\n    return getRangeRef(S, HINT_RANGE_UNSIGNED);\n  }\n\n  /// Determine the min of the unsigned range for a particular SCEV.\n  APInt getUnsignedRangeMin(const SCEV *S) {\n    return getRangeRef(S, HINT_RANGE_UNSIGNED).getUnsignedMin();\n  }\n\n  /// Determine the max of the unsigned range for a particular SCEV.\n  APInt getUnsignedRangeMax(const SCEV *S) {\n    return getRangeRef(S, HINT_RANGE_UNSIGNED).getUnsignedMax();\n  }\n\n  /// Determine the signed range for a particular SCEV.\n  /// NOTE: This returns a copy of the reference returned by getRangeRef.\n  ConstantRange getSignedRange(const SCEV *S) {\n    return getRangeRef(S, HINT_RANGE_SIGNED);\n  }\n\n  /// Determine the min of the signed range for a particular SCEV.\n  APInt getSignedRangeMin(const SCEV *S) {\n    return getRangeRef(S, HINT_RANGE_SIGNED).getSignedMin();\n  }\n\n  /// Determine the max of the signed range for a particular SCEV.\n  APInt getSignedRangeMax(const SCEV *S) {\n    return getRangeRef(S, HINT_RANGE_SIGNED).getSignedMax();\n  }\n\n  /// Test if the given expression is known to be negative.\n  bool isKnownNegative(const SCEV *S);\n\n  /// Test if the given expression is known to be positive.\n  bool isKnownPositive(const SCEV *S);\n\n  /// Test if the given expression is known to be non-negative.\n  bool isKnownNonNegative(const SCEV *S);\n\n  /// Test if the given expression is known to be non-positive.\n  bool isKnownNonPositive(const SCEV *S);\n\n  /// Test if the given expression is known to be non-zero.\n  bool isKnownNonZero(const SCEV *S);\n\n  /// Splits SCEV expression \\p S into two SCEVs. One of them is obtained from\n  /// \\p S by substitution of all AddRec sub-expression related to loop \\p L\n  /// with initial value of that SCEV. The second is obtained from \\p S by\n  /// substitution of all AddRec sub-expressions related to loop \\p L with post\n  /// increment of this AddRec in the loop \\p L. In both cases all other AddRec\n  /// sub-expressions (not related to \\p L) remain the same.\n  /// If the \\p S contains non-invariant unknown SCEV the function returns\n  /// CouldNotCompute SCEV in both values of std::pair.\n  /// For example, for SCEV S={0, +, 1}<L1> + {0, +, 1}<L2> and loop L=L1\n  /// the function returns pair:\n  /// first = {0, +, 1}<L2>\n  /// second = {1, +, 1}<L1> + {0, +, 1}<L2>\n  /// We can see that for the first AddRec sub-expression it was replaced with\n  /// 0 (initial value) for the first element and to {1, +, 1}<L1> (post\n  /// increment value) for the second one. In both cases AddRec expression\n  /// related to L2 remains the same.\n  std::pair<const SCEV *, const SCEV *> SplitIntoInitAndPostInc(const Loop *L,\n                                                                const SCEV *S);\n\n  /// We'd like to check the predicate on every iteration of the most dominated\n  /// loop between loops used in LHS and RHS.\n  /// To do this we use the following list of steps:\n  /// 1. Collect set S all loops on which either LHS or RHS depend.\n  /// 2. If S is non-empty\n  /// a. Let PD be the element of S which is dominated by all other elements.\n  /// b. Let E(LHS) be value of LHS on entry of PD.\n  ///    To get E(LHS), we should just take LHS and replace all AddRecs that are\n  ///    attached to PD on with their entry values.\n  ///    Define E(RHS) in the same way.\n  /// c. Let B(LHS) be value of L on backedge of PD.\n  ///    To get B(LHS), we should just take LHS and replace all AddRecs that are\n  ///    attached to PD on with their backedge values.\n  ///    Define B(RHS) in the same way.\n  /// d. Note that E(LHS) and E(RHS) are automatically available on entry of PD,\n  ///    so we can assert on that.\n  /// e. Return true if isLoopEntryGuardedByCond(Pred, E(LHS), E(RHS)) &&\n  ///                   isLoopBackedgeGuardedByCond(Pred, B(LHS), B(RHS))\n  bool isKnownViaInduction(ICmpInst::Predicate Pred, const SCEV *LHS,\n                           const SCEV *RHS);\n\n  /// Test if the given expression is known to satisfy the condition described\n  /// by Pred, LHS, and RHS.\n  bool isKnownPredicate(ICmpInst::Predicate Pred, const SCEV *LHS,\n                        const SCEV *RHS);\n\n  /// Test if the given expression is known to satisfy the condition described\n  /// by Pred, LHS, and RHS in the given Context.\n  bool isKnownPredicateAt(ICmpInst::Predicate Pred, const SCEV *LHS,\n                        const SCEV *RHS, const Instruction *Context);\n\n  /// Test if the condition described by Pred, LHS, RHS is known to be true on\n  /// every iteration of the loop of the recurrency LHS.\n  bool isKnownOnEveryIteration(ICmpInst::Predicate Pred,\n                               const SCEVAddRecExpr *LHS, const SCEV *RHS);\n\n  /// A predicate is said to be monotonically increasing if may go from being\n  /// false to being true as the loop iterates, but never the other way\n  /// around.  A predicate is said to be monotonically decreasing if may go\n  /// from being true to being false as the loop iterates, but never the other\n  /// way around.\n  enum MonotonicPredicateType {\n    MonotonicallyIncreasing,\n    MonotonicallyDecreasing\n  };\n\n  /// If, for all loop invariant X, the predicate \"LHS `Pred` X\" is\n  /// monotonically increasing or decreasing, returns\n  /// Some(MonotonicallyIncreasing) and Some(MonotonicallyDecreasing)\n  /// respectively. If we could not prove either of these facts, returns None.\n  Optional<MonotonicPredicateType>\n  getMonotonicPredicateType(const SCEVAddRecExpr *LHS,\n                            ICmpInst::Predicate Pred);\n\n  struct LoopInvariantPredicate {\n    ICmpInst::Predicate Pred;\n    const SCEV *LHS;\n    const SCEV *RHS;\n\n    LoopInvariantPredicate(ICmpInst::Predicate Pred, const SCEV *LHS,\n                           const SCEV *RHS)\n        : Pred(Pred), LHS(LHS), RHS(RHS) {}\n  };\n  /// If the result of the predicate LHS `Pred` RHS is loop invariant with\n  /// respect to L, return a LoopInvariantPredicate with LHS and RHS being\n  /// invariants, available at L's entry. Otherwise, return None.\n  Optional<LoopInvariantPredicate>\n  getLoopInvariantPredicate(ICmpInst::Predicate Pred, const SCEV *LHS,\n                            const SCEV *RHS, const Loop *L);\n\n  /// If the result of the predicate LHS `Pred` RHS is loop invariant with\n  /// respect to L at given Context during at least first MaxIter iterations,\n  /// return a LoopInvariantPredicate with LHS and RHS being invariants,\n  /// available at L's entry. Otherwise, return None. The predicate should be\n  /// the loop's exit condition.\n  Optional<LoopInvariantPredicate>\n  getLoopInvariantExitCondDuringFirstIterations(ICmpInst::Predicate Pred,\n                                                const SCEV *LHS,\n                                                const SCEV *RHS, const Loop *L,\n                                                const Instruction *Context,\n                                                const SCEV *MaxIter);\n\n  /// Simplify LHS and RHS in a comparison with predicate Pred. Return true\n  /// iff any changes were made. If the operands are provably equal or\n  /// unequal, LHS and RHS are set to the same value and Pred is set to either\n  /// ICMP_EQ or ICMP_NE.\n  bool SimplifyICmpOperands(ICmpInst::Predicate &Pred, const SCEV *&LHS,\n                            const SCEV *&RHS, unsigned Depth = 0);\n\n  /// Return the \"disposition\" of the given SCEV with respect to the given\n  /// loop.\n  LoopDisposition getLoopDisposition(const SCEV *S, const Loop *L);\n\n  /// Return true if the value of the given SCEV is unchanging in the\n  /// specified loop.\n  bool isLoopInvariant(const SCEV *S, const Loop *L);\n\n  /// Determine if the SCEV can be evaluated at loop's entry. It is true if it\n  /// doesn't depend on a SCEVUnknown of an instruction which is dominated by\n  /// the header of loop L.\n  bool isAvailableAtLoopEntry(const SCEV *S, const Loop *L);\n\n  /// Return true if the given SCEV changes value in a known way in the\n  /// specified loop.  This property being true implies that the value is\n  /// variant in the loop AND that we can emit an expression to compute the\n  /// value of the expression at any particular loop iteration.\n  bool hasComputableLoopEvolution(const SCEV *S, const Loop *L);\n\n  /// Return the \"disposition\" of the given SCEV with respect to the given\n  /// block.\n  BlockDisposition getBlockDisposition(const SCEV *S, const BasicBlock *BB);\n\n  /// Return true if elements that makes up the given SCEV dominate the\n  /// specified basic block.\n  bool dominates(const SCEV *S, const BasicBlock *BB);\n\n  /// Return true if elements that makes up the given SCEV properly dominate\n  /// the specified basic block.\n  bool properlyDominates(const SCEV *S, const BasicBlock *BB);\n\n  /// Test whether the given SCEV has Op as a direct or indirect operand.\n  bool hasOperand(const SCEV *S, const SCEV *Op) const;\n\n  /// Return the size of an element read or written by Inst.\n  const SCEV *getElementSize(Instruction *Inst);\n\n  /// Compute the array dimensions Sizes from the set of Terms extracted from\n  /// the memory access function of this SCEVAddRecExpr (second step of\n  /// delinearization).\n  void findArrayDimensions(SmallVectorImpl<const SCEV *> &Terms,\n                           SmallVectorImpl<const SCEV *> &Sizes,\n                           const SCEV *ElementSize);\n\n  void print(raw_ostream &OS) const;\n  void verify() const;\n  bool invalidate(Function &F, const PreservedAnalyses &PA,\n                  FunctionAnalysisManager::Invalidator &Inv);\n\n  /// Collect parametric terms occurring in step expressions (first step of\n  /// delinearization).\n  void collectParametricTerms(const SCEV *Expr,\n                              SmallVectorImpl<const SCEV *> &Terms);\n\n  /// Return in Subscripts the access functions for each dimension in Sizes\n  /// (third step of delinearization).\n  void computeAccessFunctions(const SCEV *Expr,\n                              SmallVectorImpl<const SCEV *> &Subscripts,\n                              SmallVectorImpl<const SCEV *> &Sizes);\n\n  /// Gathers the individual index expressions from a GEP instruction.\n  ///\n  /// This function optimistically assumes the GEP references into a fixed size\n  /// array. If this is actually true, this function returns a list of array\n  /// subscript expressions in \\p Subscripts and a list of integers describing\n  /// the size of the individual array dimensions in \\p Sizes. Both lists have\n  /// either equal length or the size list is one element shorter in case there\n  /// is no known size available for the outermost array dimension. Returns true\n  /// if successful and false otherwise.\n  bool getIndexExpressionsFromGEP(const GetElementPtrInst *GEP,\n                                  SmallVectorImpl<const SCEV *> &Subscripts,\n                                  SmallVectorImpl<int> &Sizes);\n\n  /// Split this SCEVAddRecExpr into two vectors of SCEVs representing the\n  /// subscripts and sizes of an array access.\n  ///\n  /// The delinearization is a 3 step process: the first two steps compute the\n  /// sizes of each subscript and the third step computes the access functions\n  /// for the delinearized array:\n  ///\n  /// 1. Find the terms in the step functions\n  /// 2. Compute the array size\n  /// 3. Compute the access function: divide the SCEV by the array size\n  ///    starting with the innermost dimensions found in step 2. The Quotient\n  ///    is the SCEV to be divided in the next step of the recursion. The\n  ///    Remainder is the subscript of the innermost dimension. Loop over all\n  ///    array dimensions computed in step 2.\n  ///\n  /// To compute a uniform array size for several memory accesses to the same\n  /// object, one can collect in step 1 all the step terms for all the memory\n  /// accesses, and compute in step 2 a unique array shape. This guarantees\n  /// that the array shape will be the same across all memory accesses.\n  ///\n  /// FIXME: We could derive the result of steps 1 and 2 from a description of\n  /// the array shape given in metadata.\n  ///\n  /// Example:\n  ///\n  /// A[][n][m]\n  ///\n  /// for i\n  ///   for j\n  ///     for k\n  ///       A[j+k][2i][5i] =\n  ///\n  /// The initial SCEV:\n  ///\n  /// A[{{{0,+,2*m+5}_i, +, n*m}_j, +, n*m}_k]\n  ///\n  /// 1. Find the different terms in the step functions:\n  /// -> [2*m, 5, n*m, n*m]\n  ///\n  /// 2. Compute the array size: sort and unique them\n  /// -> [n*m, 2*m, 5]\n  /// find the GCD of all the terms = 1\n  /// divide by the GCD and erase constant terms\n  /// -> [n*m, 2*m]\n  /// GCD = m\n  /// divide by GCD -> [n, 2]\n  /// remove constant terms\n  /// -> [n]\n  /// size of the array is A[unknown][n][m]\n  ///\n  /// 3. Compute the access function\n  /// a. Divide {{{0,+,2*m+5}_i, +, n*m}_j, +, n*m}_k by the innermost size m\n  /// Quotient: {{{0,+,2}_i, +, n}_j, +, n}_k\n  /// Remainder: {{{0,+,5}_i, +, 0}_j, +, 0}_k\n  /// The remainder is the subscript of the innermost array dimension: [5i].\n  ///\n  /// b. Divide Quotient: {{{0,+,2}_i, +, n}_j, +, n}_k by next outer size n\n  /// Quotient: {{{0,+,0}_i, +, 1}_j, +, 1}_k\n  /// Remainder: {{{0,+,2}_i, +, 0}_j, +, 0}_k\n  /// The Remainder is the subscript of the next array dimension: [2i].\n  ///\n  /// The subscript of the outermost dimension is the Quotient: [j+k].\n  ///\n  /// Overall, we have: A[][n][m], and the access function: A[j+k][2i][5i].\n  void delinearize(const SCEV *Expr, SmallVectorImpl<const SCEV *> &Subscripts,\n                   SmallVectorImpl<const SCEV *> &Sizes,\n                   const SCEV *ElementSize);\n\n  /// Return the DataLayout associated with the module this SCEV instance is\n  /// operating on.\n  const DataLayout &getDataLayout() const {\n    return F.getParent()->getDataLayout();\n  }\n\n  const SCEVPredicate *getEqualPredicate(const SCEV *LHS, const SCEV *RHS);\n\n  const SCEVPredicate *\n  getWrapPredicate(const SCEVAddRecExpr *AR,\n                   SCEVWrapPredicate::IncrementWrapFlags AddedFlags);\n\n  /// Re-writes the SCEV according to the Predicates in \\p A.\n  const SCEV *rewriteUsingPredicate(const SCEV *S, const Loop *L,\n                                    SCEVUnionPredicate &A);\n  /// Tries to convert the \\p S expression to an AddRec expression,\n  /// adding additional predicates to \\p Preds as required.\n  const SCEVAddRecExpr *convertSCEVToAddRecWithPredicates(\n      const SCEV *S, const Loop *L,\n      SmallPtrSetImpl<const SCEVPredicate *> &Preds);\n\n  /// Compute \\p LHS - \\p RHS and returns the result as an APInt if it is a\n  /// constant, and None if it isn't.\n  ///\n  /// This is intended to be a cheaper version of getMinusSCEV.  We can be\n  /// frugal here since we just bail out of actually constructing and\n  /// canonicalizing an expression in the cases where the result isn't going\n  /// to be a constant.\n  Optional<APInt> computeConstantDifference(const SCEV *LHS, const SCEV *RHS);\n\n  /// Update no-wrap flags of an AddRec. This may drop the cached info about\n  /// this AddRec (such as range info) in case if new flags may potentially\n  /// sharpen it.\n  void setNoWrapFlags(SCEVAddRecExpr *AddRec, SCEV::NoWrapFlags Flags);\n\n  /// Try to apply information from loop guards for \\p L to \\p Expr.\n  const SCEV *applyLoopGuards(const SCEV *Expr, const Loop *L);\n\nprivate:\n  /// A CallbackVH to arrange for ScalarEvolution to be notified whenever a\n  /// Value is deleted.\n  class SCEVCallbackVH final : public CallbackVH {\n    ScalarEvolution *SE;\n\n    void deleted() override;\n    void allUsesReplacedWith(Value *New) override;\n\n  public:\n    SCEVCallbackVH(Value *V, ScalarEvolution *SE = nullptr);\n  };\n\n  friend class SCEVCallbackVH;\n  friend class SCEVExpander;\n  friend class SCEVUnknown;\n\n  /// The function we are analyzing.\n  Function &F;\n\n  /// Does the module have any calls to the llvm.experimental.guard intrinsic\n  /// at all?  If this is false, we avoid doing work that will only help if\n  /// thare are guards present in the IR.\n  bool HasGuards;\n\n  /// The target library information for the target we are targeting.\n  TargetLibraryInfo &TLI;\n\n  /// The tracker for \\@llvm.assume intrinsics in this function.\n  AssumptionCache &AC;\n\n  /// The dominator tree.\n  DominatorTree &DT;\n\n  /// The loop information for the function we are currently analyzing.\n  LoopInfo &LI;\n\n  /// This SCEV is used to represent unknown trip counts and things.\n  std::unique_ptr<SCEVCouldNotCompute> CouldNotCompute;\n\n  /// The type for HasRecMap.\n  using HasRecMapType = DenseMap<const SCEV *, bool>;\n\n  /// This is a cache to record whether a SCEV contains any scAddRecExpr.\n  HasRecMapType HasRecMap;\n\n  /// The type for ExprValueMap.\n  using ValueOffsetPair = std::pair<Value *, ConstantInt *>;\n  using ExprValueMapType = DenseMap<const SCEV *, SetVector<ValueOffsetPair>>;\n\n  /// ExprValueMap -- This map records the original values from which\n  /// the SCEV expr is generated from.\n  ///\n  /// We want to represent the mapping as SCEV -> ValueOffsetPair instead\n  /// of SCEV -> Value:\n  /// Suppose we know S1 expands to V1, and\n  ///  S1 = S2 + C_a\n  ///  S3 = S2 + C_b\n  /// where C_a and C_b are different SCEVConstants. Then we'd like to\n  /// expand S3 as V1 - C_a + C_b instead of expanding S2 literally.\n  /// It is helpful when S2 is a complex SCEV expr.\n  ///\n  /// In order to do that, we represent ExprValueMap as a mapping from\n  /// SCEV to ValueOffsetPair. We will save both S1->{V1, 0} and\n  /// S2->{V1, C_a} into the map when we create SCEV for V1. When S3\n  /// is expanded, it will first expand S2 to V1 - C_a because of\n  /// S2->{V1, C_a} in the map, then expand S3 to V1 - C_a + C_b.\n  ///\n  /// Note: S->{V, Offset} in the ExprValueMap means S can be expanded\n  /// to V - Offset.\n  ExprValueMapType ExprValueMap;\n\n  /// The type for ValueExprMap.\n  using ValueExprMapType =\n      DenseMap<SCEVCallbackVH, const SCEV *, DenseMapInfo<Value *>>;\n\n  /// This is a cache of the values we have analyzed so far.\n  ValueExprMapType ValueExprMap;\n\n  /// Mark predicate values currently being processed by isImpliedCond.\n  SmallPtrSet<const Value *, 6> PendingLoopPredicates;\n\n  /// Mark SCEVUnknown Phis currently being processed by getRangeRef.\n  SmallPtrSet<const PHINode *, 6> PendingPhiRanges;\n\n  // Mark SCEVUnknown Phis currently being processed by isImpliedViaMerge.\n  SmallPtrSet<const PHINode *, 6> PendingMerges;\n\n  /// Set to true by isLoopBackedgeGuardedByCond when we're walking the set of\n  /// conditions dominating the backedge of a loop.\n  bool WalkingBEDominatingConds = false;\n\n  /// Set to true by isKnownPredicateViaSplitting when we're trying to prove a\n  /// predicate by splitting it into a set of independent predicates.\n  bool ProvingSplitPredicate = false;\n\n  /// Memoized values for the GetMinTrailingZeros\n  DenseMap<const SCEV *, uint32_t> MinTrailingZerosCache;\n\n  /// Return the Value set from which the SCEV expr is generated.\n  SetVector<ValueOffsetPair> *getSCEVValues(const SCEV *S);\n\n  /// Private helper method for the GetMinTrailingZeros method\n  uint32_t GetMinTrailingZerosImpl(const SCEV *S);\n\n  /// Information about the number of loop iterations for which a loop exit's\n  /// branch condition evaluates to the not-taken path.  This is a temporary\n  /// pair of exact and max expressions that are eventually summarized in\n  /// ExitNotTakenInfo and BackedgeTakenInfo.\n  struct ExitLimit {\n    const SCEV *ExactNotTaken; // The exit is not taken exactly this many times\n    const SCEV *MaxNotTaken; // The exit is not taken at most this many times\n\n    // Not taken either exactly MaxNotTaken or zero times\n    bool MaxOrZero = false;\n\n    /// A set of predicate guards for this ExitLimit. The result is only valid\n    /// if all of the predicates in \\c Predicates evaluate to 'true' at\n    /// run-time.\n    SmallPtrSet<const SCEVPredicate *, 4> Predicates;\n\n    void addPredicate(const SCEVPredicate *P) {\n      assert(!isa<SCEVUnionPredicate>(P) && \"Only add leaf predicates here!\");\n      Predicates.insert(P);\n    }\n\n    /// Construct either an exact exit limit from a constant, or an unknown\n    /// one from a SCEVCouldNotCompute.  No other types of SCEVs are allowed\n    /// as arguments and asserts enforce that internally.\n    /*implicit*/ ExitLimit(const SCEV *E);\n\n    ExitLimit(\n        const SCEV *E, const SCEV *M, bool MaxOrZero,\n        ArrayRef<const SmallPtrSetImpl<const SCEVPredicate *> *> PredSetList);\n\n    ExitLimit(const SCEV *E, const SCEV *M, bool MaxOrZero,\n              const SmallPtrSetImpl<const SCEVPredicate *> &PredSet);\n\n    ExitLimit(const SCEV *E, const SCEV *M, bool MaxOrZero);\n\n    /// Test whether this ExitLimit contains any computed information, or\n    /// whether it's all SCEVCouldNotCompute values.\n    bool hasAnyInfo() const {\n      return !isa<SCEVCouldNotCompute>(ExactNotTaken) ||\n             !isa<SCEVCouldNotCompute>(MaxNotTaken);\n    }\n\n    bool hasOperand(const SCEV *S) const;\n\n    /// Test whether this ExitLimit contains all information.\n    bool hasFullInfo() const {\n      return !isa<SCEVCouldNotCompute>(ExactNotTaken);\n    }\n  };\n\n  /// Information about the number of times a particular loop exit may be\n  /// reached before exiting the loop.\n  struct ExitNotTakenInfo {\n    PoisoningVH<BasicBlock> ExitingBlock;\n    const SCEV *ExactNotTaken;\n    const SCEV *MaxNotTaken;\n    std::unique_ptr<SCEVUnionPredicate> Predicate;\n\n    explicit ExitNotTakenInfo(PoisoningVH<BasicBlock> ExitingBlock,\n                              const SCEV *ExactNotTaken,\n                              const SCEV *MaxNotTaken,\n                              std::unique_ptr<SCEVUnionPredicate> Predicate)\n      : ExitingBlock(ExitingBlock), ExactNotTaken(ExactNotTaken),\n        MaxNotTaken(ExactNotTaken), Predicate(std::move(Predicate)) {}\n\n    bool hasAlwaysTruePredicate() const {\n      return !Predicate || Predicate->isAlwaysTrue();\n    }\n  };\n\n  /// Information about the backedge-taken count of a loop. This currently\n  /// includes an exact count and a maximum count.\n  ///\n  class BackedgeTakenInfo {\n    /// A list of computable exits and their not-taken counts.  Loops almost\n    /// never have more than one computable exit.\n    SmallVector<ExitNotTakenInfo, 1> ExitNotTaken;\n\n    /// Expression indicating the least constant maximum backedge-taken count of\n    /// the loop that is known, or a SCEVCouldNotCompute. This expression is\n    /// only valid if the redicates associated with all loop exits are true.\n    const SCEV *ConstantMax;\n\n    /// Indicating if \\c ExitNotTaken has an element for every exiting block in\n    /// the loop.\n    bool IsComplete;\n\n    /// Expression indicating the least maximum backedge-taken count of the loop\n    /// that is known, or a SCEVCouldNotCompute. Lazily computed on first query.\n    const SCEV *SymbolicMax = nullptr;\n\n    /// True iff the backedge is taken either exactly Max or zero times.\n    bool MaxOrZero = false;\n\n    bool isComplete() const { return IsComplete; }\n    const SCEV *getConstantMax() const { return ConstantMax; }\n\n  public:\n    BackedgeTakenInfo() : ConstantMax(nullptr), IsComplete(false) {}\n    BackedgeTakenInfo(BackedgeTakenInfo &&) = default;\n    BackedgeTakenInfo &operator=(BackedgeTakenInfo &&) = default;\n\n    using EdgeExitInfo = std::pair<BasicBlock *, ExitLimit>;\n\n    /// Initialize BackedgeTakenInfo from a list of exact exit counts.\n    BackedgeTakenInfo(ArrayRef<EdgeExitInfo> ExitCounts, bool IsComplete,\n                      const SCEV *ConstantMax, bool MaxOrZero);\n\n    /// Test whether this BackedgeTakenInfo contains any computed information,\n    /// or whether it's all SCEVCouldNotCompute values.\n    bool hasAnyInfo() const {\n      return !ExitNotTaken.empty() ||\n             !isa<SCEVCouldNotCompute>(getConstantMax());\n    }\n\n    /// Test whether this BackedgeTakenInfo contains complete information.\n    bool hasFullInfo() const { return isComplete(); }\n\n    /// Return an expression indicating the exact *backedge-taken*\n    /// count of the loop if it is known or SCEVCouldNotCompute\n    /// otherwise.  If execution makes it to the backedge on every\n    /// iteration (i.e. there are no abnormal exists like exception\n    /// throws and thread exits) then this is the number of times the\n    /// loop header will execute minus one.\n    ///\n    /// If the SCEV predicate associated with the answer can be different\n    /// from AlwaysTrue, we must add a (non null) Predicates argument.\n    /// The SCEV predicate associated with the answer will be added to\n    /// Predicates. A run-time check needs to be emitted for the SCEV\n    /// predicate in order for the answer to be valid.\n    ///\n    /// Note that we should always know if we need to pass a predicate\n    /// argument or not from the way the ExitCounts vector was computed.\n    /// If we allowed SCEV predicates to be generated when populating this\n    /// vector, this information can contain them and therefore a\n    /// SCEVPredicate argument should be added to getExact.\n    const SCEV *getExact(const Loop *L, ScalarEvolution *SE,\n                         SCEVUnionPredicate *Predicates = nullptr) const;\n\n    /// Return the number of times this loop exit may fall through to the back\n    /// edge, or SCEVCouldNotCompute. The loop is guaranteed not to exit via\n    /// this block before this number of iterations, but may exit via another\n    /// block.\n    const SCEV *getExact(const BasicBlock *ExitingBlock,\n                         ScalarEvolution *SE) const;\n\n    /// Get the constant max backedge taken count for the loop.\n    const SCEV *getConstantMax(ScalarEvolution *SE) const;\n\n    /// Get the constant max backedge taken count for the particular loop exit.\n    const SCEV *getConstantMax(const BasicBlock *ExitingBlock,\n                               ScalarEvolution *SE) const;\n\n    /// Get the symbolic max backedge taken count for the loop.\n    const SCEV *getSymbolicMax(const Loop *L, ScalarEvolution *SE);\n\n    /// Return true if the number of times this backedge is taken is either the\n    /// value returned by getConstantMax or zero.\n    bool isConstantMaxOrZero(ScalarEvolution *SE) const;\n\n    /// Return true if any backedge taken count expressions refer to the given\n    /// subexpression.\n    bool hasOperand(const SCEV *S, ScalarEvolution *SE) const;\n\n    /// Invalidate this result and free associated memory.\n    void clear();\n  };\n\n  /// Cache the backedge-taken count of the loops for this function as they\n  /// are computed.\n  DenseMap<const Loop *, BackedgeTakenInfo> BackedgeTakenCounts;\n\n  /// Cache the predicated backedge-taken count of the loops for this\n  /// function as they are computed.\n  DenseMap<const Loop *, BackedgeTakenInfo> PredicatedBackedgeTakenCounts;\n\n  /// This map contains entries for all of the PHI instructions that we\n  /// attempt to compute constant evolutions for.  This allows us to avoid\n  /// potentially expensive recomputation of these properties.  An instruction\n  /// maps to null if we are unable to compute its exit value.\n  DenseMap<PHINode *, Constant *> ConstantEvolutionLoopExitValue;\n\n  /// This map contains entries for all the expressions that we attempt to\n  /// compute getSCEVAtScope information for, which can be expensive in\n  /// extreme cases.\n  DenseMap<const SCEV *, SmallVector<std::pair<const Loop *, const SCEV *>, 2>>\n      ValuesAtScopes;\n\n  /// Memoized computeLoopDisposition results.\n  DenseMap<const SCEV *,\n           SmallVector<PointerIntPair<const Loop *, 2, LoopDisposition>, 2>>\n      LoopDispositions;\n\n  struct LoopProperties {\n    /// Set to true if the loop contains no instruction that can have side\n    /// effects (i.e. via throwing an exception, volatile or atomic access).\n    bool HasNoAbnormalExits;\n\n    /// Set to true if the loop contains no instruction that can abnormally exit\n    /// the loop (i.e. via throwing an exception, by terminating the thread\n    /// cleanly or by infinite looping in a called function).  Strictly\n    /// speaking, the last one is not leaving the loop, but is identical to\n    /// leaving the loop for reasoning about undefined behavior.\n    bool HasNoSideEffects;\n  };\n\n  /// Cache for \\c getLoopProperties.\n  DenseMap<const Loop *, LoopProperties> LoopPropertiesCache;\n\n  /// Return a \\c LoopProperties instance for \\p L, creating one if necessary.\n  LoopProperties getLoopProperties(const Loop *L);\n\n  bool loopHasNoSideEffects(const Loop *L) {\n    return getLoopProperties(L).HasNoSideEffects;\n  }\n\n  bool loopHasNoAbnormalExits(const Loop *L) {\n    return getLoopProperties(L).HasNoAbnormalExits;\n  }\n\n  /// Compute a LoopDisposition value.\n  LoopDisposition computeLoopDisposition(const SCEV *S, const Loop *L);\n\n  /// Memoized computeBlockDisposition results.\n  DenseMap<\n      const SCEV *,\n      SmallVector<PointerIntPair<const BasicBlock *, 2, BlockDisposition>, 2>>\n      BlockDispositions;\n\n  /// Compute a BlockDisposition value.\n  BlockDisposition computeBlockDisposition(const SCEV *S, const BasicBlock *BB);\n\n  /// Memoized results from getRange\n  DenseMap<const SCEV *, ConstantRange> UnsignedRanges;\n\n  /// Memoized results from getRange\n  DenseMap<const SCEV *, ConstantRange> SignedRanges;\n\n  /// Used to parameterize getRange\n  enum RangeSignHint { HINT_RANGE_UNSIGNED, HINT_RANGE_SIGNED };\n\n  /// Set the memoized range for the given SCEV.\n  const ConstantRange &setRange(const SCEV *S, RangeSignHint Hint,\n                                ConstantRange CR) {\n    DenseMap<const SCEV *, ConstantRange> &Cache =\n        Hint == HINT_RANGE_UNSIGNED ? UnsignedRanges : SignedRanges;\n\n    auto Pair = Cache.try_emplace(S, std::move(CR));\n    if (!Pair.second)\n      Pair.first->second = std::move(CR);\n    return Pair.first->second;\n  }\n\n  /// Determine the range for a particular SCEV.\n  /// NOTE: This returns a reference to an entry in a cache. It must be\n  /// copied if its needed for longer.\n  const ConstantRange &getRangeRef(const SCEV *S, RangeSignHint Hint);\n\n  /// Determines the range for the affine SCEVAddRecExpr {\\p Start,+,\\p Stop}.\n  /// Helper for \\c getRange.\n  ConstantRange getRangeForAffineAR(const SCEV *Start, const SCEV *Stop,\n                                    const SCEV *MaxBECount, unsigned BitWidth);\n\n  /// Determines the range for the affine non-self-wrapping SCEVAddRecExpr {\\p\n  /// Start,+,\\p Stop}<nw>.\n  ConstantRange getRangeForAffineNoSelfWrappingAR(const SCEVAddRecExpr *AddRec,\n                                                  const SCEV *MaxBECount,\n                                                  unsigned BitWidth,\n                                                  RangeSignHint SignHint);\n\n  /// Try to compute a range for the affine SCEVAddRecExpr {\\p Start,+,\\p\n  /// Stop} by \"factoring out\" a ternary expression from the add recurrence.\n  /// Helper called by \\c getRange.\n  ConstantRange getRangeViaFactoring(const SCEV *Start, const SCEV *Stop,\n                                     const SCEV *MaxBECount, unsigned BitWidth);\n\n  /// We know that there is no SCEV for the specified value.  Analyze the\n  /// expression.\n  const SCEV *createSCEV(Value *V);\n\n  /// Provide the special handling we need to analyze PHI SCEVs.\n  const SCEV *createNodeForPHI(PHINode *PN);\n\n  /// Helper function called from createNodeForPHI.\n  const SCEV *createAddRecFromPHI(PHINode *PN);\n\n  /// A helper function for createAddRecFromPHI to handle simple cases.\n  const SCEV *createSimpleAffineAddRec(PHINode *PN, Value *BEValueV,\n                                            Value *StartValueV);\n\n  /// Helper function called from createNodeForPHI.\n  const SCEV *createNodeFromSelectLikePHI(PHINode *PN);\n\n  /// Provide special handling for a select-like instruction (currently this\n  /// is either a select instruction or a phi node).  \\p I is the instruction\n  /// being processed, and it is assumed equivalent to \"Cond ? TrueVal :\n  /// FalseVal\".\n  const SCEV *createNodeForSelectOrPHI(Instruction *I, Value *Cond,\n                                       Value *TrueVal, Value *FalseVal);\n\n  /// Provide the special handling we need to analyze GEP SCEVs.\n  const SCEV *createNodeForGEP(GEPOperator *GEP);\n\n  /// Implementation code for getSCEVAtScope; called at most once for each\n  /// SCEV+Loop pair.\n  const SCEV *computeSCEVAtScope(const SCEV *S, const Loop *L);\n\n  /// This looks up computed SCEV values for all instructions that depend on\n  /// the given instruction and removes them from the ValueExprMap map if they\n  /// reference SymName. This is used during PHI resolution.\n  void forgetSymbolicName(Instruction *I, const SCEV *SymName);\n\n  /// Return the BackedgeTakenInfo for the given loop, lazily computing new\n  /// values if the loop hasn't been analyzed yet. The returned result is\n  /// guaranteed not to be predicated.\n  BackedgeTakenInfo &getBackedgeTakenInfo(const Loop *L);\n\n  /// Similar to getBackedgeTakenInfo, but will add predicates as required\n  /// with the purpose of returning complete information.\n  const BackedgeTakenInfo &getPredicatedBackedgeTakenInfo(const Loop *L);\n\n  /// Compute the number of times the specified loop will iterate.\n  /// If AllowPredicates is set, we will create new SCEV predicates as\n  /// necessary in order to return an exact answer.\n  BackedgeTakenInfo computeBackedgeTakenCount(const Loop *L,\n                                              bool AllowPredicates = false);\n\n  /// Compute the number of times the backedge of the specified loop will\n  /// execute if it exits via the specified block. If AllowPredicates is set,\n  /// this call will try to use a minimal set of SCEV predicates in order to\n  /// return an exact answer.\n  ExitLimit computeExitLimit(const Loop *L, BasicBlock *ExitingBlock,\n                             bool AllowPredicates = false);\n\n  /// Compute the number of times the backedge of the specified loop will\n  /// execute if its exit condition were a conditional branch of ExitCond.\n  ///\n  /// \\p ControlsExit is true if ExitCond directly controls the exit\n  /// branch. In this case, we can assume that the loop exits only if the\n  /// condition is true and can infer that failing to meet the condition prior\n  /// to integer wraparound results in undefined behavior.\n  ///\n  /// If \\p AllowPredicates is set, this call will try to use a minimal set of\n  /// SCEV predicates in order to return an exact answer.\n  ExitLimit computeExitLimitFromCond(const Loop *L, Value *ExitCond,\n                                     bool ExitIfTrue, bool ControlsExit,\n                                     bool AllowPredicates = false);\n\n  /// Return a symbolic upper bound for the backedge taken count of the loop.\n  /// This is more general than getConstantMaxBackedgeTakenCount as it returns\n  /// an arbitrary expression as opposed to only constants.\n  const SCEV *computeSymbolicMaxBackedgeTakenCount(const Loop *L);\n\n  // Helper functions for computeExitLimitFromCond to avoid exponential time\n  // complexity.\n\n  class ExitLimitCache {\n    // It may look like we need key on the whole (L, ExitIfTrue, ControlsExit,\n    // AllowPredicates) tuple, but recursive calls to\n    // computeExitLimitFromCondCached from computeExitLimitFromCondImpl only\n    // vary the in \\c ExitCond and \\c ControlsExit parameters.  We remember the\n    // initial values of the other values to assert our assumption.\n    SmallDenseMap<PointerIntPair<Value *, 1>, ExitLimit> TripCountMap;\n\n    const Loop *L;\n    bool ExitIfTrue;\n    bool AllowPredicates;\n\n  public:\n    ExitLimitCache(const Loop *L, bool ExitIfTrue, bool AllowPredicates)\n        : L(L), ExitIfTrue(ExitIfTrue), AllowPredicates(AllowPredicates) {}\n\n    Optional<ExitLimit> find(const Loop *L, Value *ExitCond, bool ExitIfTrue,\n                             bool ControlsExit, bool AllowPredicates);\n\n    void insert(const Loop *L, Value *ExitCond, bool ExitIfTrue,\n                bool ControlsExit, bool AllowPredicates, const ExitLimit &EL);\n  };\n\n  using ExitLimitCacheTy = ExitLimitCache;\n\n  ExitLimit computeExitLimitFromCondCached(ExitLimitCacheTy &Cache,\n                                           const Loop *L, Value *ExitCond,\n                                           bool ExitIfTrue,\n                                           bool ControlsExit,\n                                           bool AllowPredicates);\n  ExitLimit computeExitLimitFromCondImpl(ExitLimitCacheTy &Cache, const Loop *L,\n                                         Value *ExitCond, bool ExitIfTrue,\n                                         bool ControlsExit,\n                                         bool AllowPredicates);\n  Optional<ScalarEvolution::ExitLimit>\n  computeExitLimitFromCondFromBinOp(ExitLimitCacheTy &Cache, const Loop *L,\n                                    Value *ExitCond, bool ExitIfTrue,\n                                    bool ControlsExit, bool AllowPredicates);\n\n  /// Compute the number of times the backedge of the specified loop will\n  /// execute if its exit condition were a conditional branch of the ICmpInst\n  /// ExitCond and ExitIfTrue. If AllowPredicates is set, this call will try\n  /// to use a minimal set of SCEV predicates in order to return an exact\n  /// answer.\n  ExitLimit computeExitLimitFromICmp(const Loop *L, ICmpInst *ExitCond,\n                                     bool ExitIfTrue,\n                                     bool IsSubExpr,\n                                     bool AllowPredicates = false);\n\n  /// Compute the number of times the backedge of the specified loop will\n  /// execute if its exit condition were a switch with a single exiting case\n  /// to ExitingBB.\n  ExitLimit computeExitLimitFromSingleExitSwitch(const Loop *L,\n                                                 SwitchInst *Switch,\n                                                 BasicBlock *ExitingBB,\n                                                 bool IsSubExpr);\n\n  /// Given an exit condition of 'icmp op load X, cst', try to see if we can\n  /// compute the backedge-taken count.\n  ExitLimit computeLoadConstantCompareExitLimit(LoadInst *LI, Constant *RHS,\n                                                const Loop *L,\n                                                ICmpInst::Predicate p);\n\n  /// Compute the exit limit of a loop that is controlled by a\n  /// \"(IV >> 1) != 0\" type comparison.  We cannot compute the exact trip\n  /// count in these cases (since SCEV has no way of expressing them), but we\n  /// can still sometimes compute an upper bound.\n  ///\n  /// Return an ExitLimit for a loop whose backedge is guarded by `LHS Pred\n  /// RHS`.\n  ExitLimit computeShiftCompareExitLimit(Value *LHS, Value *RHS, const Loop *L,\n                                         ICmpInst::Predicate Pred);\n\n  /// If the loop is known to execute a constant number of times (the\n  /// condition evolves only from constants), try to evaluate a few iterations\n  /// of the loop until we get the exit condition gets a value of ExitWhen\n  /// (true or false).  If we cannot evaluate the exit count of the loop,\n  /// return CouldNotCompute.\n  const SCEV *computeExitCountExhaustively(const Loop *L, Value *Cond,\n                                           bool ExitWhen);\n\n  /// Return the number of times an exit condition comparing the specified\n  /// value to zero will execute.  If not computable, return CouldNotCompute.\n  /// If AllowPredicates is set, this call will try to use a minimal set of\n  /// SCEV predicates in order to return an exact answer.\n  ExitLimit howFarToZero(const SCEV *V, const Loop *L, bool IsSubExpr,\n                         bool AllowPredicates = false);\n\n  /// Return the number of times an exit condition checking the specified\n  /// value for nonzero will execute.  If not computable, return\n  /// CouldNotCompute.\n  ExitLimit howFarToNonZero(const SCEV *V, const Loop *L);\n\n  /// Return the number of times an exit condition containing the specified\n  /// less-than comparison will execute.  If not computable, return\n  /// CouldNotCompute.\n  ///\n  /// \\p isSigned specifies whether the less-than is signed.\n  ///\n  /// \\p ControlsExit is true when the LHS < RHS condition directly controls\n  /// the branch (loops exits only if condition is true). In this case, we can\n  /// use NoWrapFlags to skip overflow checks.\n  ///\n  /// If \\p AllowPredicates is set, this call will try to use a minimal set of\n  /// SCEV predicates in order to return an exact answer.\n  ExitLimit howManyLessThans(const SCEV *LHS, const SCEV *RHS, const Loop *L,\n                             bool isSigned, bool ControlsExit,\n                             bool AllowPredicates = false);\n\n  ExitLimit howManyGreaterThans(const SCEV *LHS, const SCEV *RHS, const Loop *L,\n                                bool isSigned, bool IsSubExpr,\n                                bool AllowPredicates = false);\n\n  /// Return a predecessor of BB (which may not be an immediate predecessor)\n  /// which has exactly one successor from which BB is reachable, or null if\n  /// no such block is found.\n  std::pair<const BasicBlock *, const BasicBlock *>\n  getPredecessorWithUniqueSuccessorForBB(const BasicBlock *BB) const;\n\n  /// Test whether the condition described by Pred, LHS, and RHS is true\n  /// whenever the given FoundCondValue value evaluates to true in given\n  /// Context. If Context is nullptr, then the found predicate is true\n  /// everywhere. LHS and FoundLHS may have different type width.\n  bool isImpliedCond(ICmpInst::Predicate Pred, const SCEV *LHS, const SCEV *RHS,\n                     const Value *FoundCondValue, bool Inverse,\n                     const Instruction *Context = nullptr);\n\n  /// Test whether the condition described by Pred, LHS, and RHS is true\n  /// whenever the given FoundCondValue value evaluates to true in given\n  /// Context. If Context is nullptr, then the found predicate is true\n  /// everywhere. LHS and FoundLHS must have same type width.\n  bool isImpliedCondBalancedTypes(ICmpInst::Predicate Pred, const SCEV *LHS,\n                                  const SCEV *RHS,\n                                  ICmpInst::Predicate FoundPred,\n                                  const SCEV *FoundLHS, const SCEV *FoundRHS,\n                                  const Instruction *Context);\n\n  /// Test whether the condition described by Pred, LHS, and RHS is true\n  /// whenever the condition described by FoundPred, FoundLHS, FoundRHS is\n  /// true in given Context. If Context is nullptr, then the found predicate is\n  /// true everywhere.\n  bool isImpliedCond(ICmpInst::Predicate Pred, const SCEV *LHS, const SCEV *RHS,\n                     ICmpInst::Predicate FoundPred, const SCEV *FoundLHS,\n                     const SCEV *FoundRHS,\n                     const Instruction *Context = nullptr);\n\n  /// Test whether the condition described by Pred, LHS, and RHS is true\n  /// whenever the condition described by Pred, FoundLHS, and FoundRHS is\n  /// true in given Context. If Context is nullptr, then the found predicate is\n  /// true everywhere.\n  bool isImpliedCondOperands(ICmpInst::Predicate Pred, const SCEV *LHS,\n                             const SCEV *RHS, const SCEV *FoundLHS,\n                             const SCEV *FoundRHS,\n                             const Instruction *Context = nullptr);\n\n  /// Test whether the condition described by Pred, LHS, and RHS is true\n  /// whenever the condition described by Pred, FoundLHS, and FoundRHS is\n  /// true. Here LHS is an operation that includes FoundLHS as one of its\n  /// arguments.\n  bool isImpliedViaOperations(ICmpInst::Predicate Pred,\n                              const SCEV *LHS, const SCEV *RHS,\n                              const SCEV *FoundLHS, const SCEV *FoundRHS,\n                              unsigned Depth = 0);\n\n  /// Test whether the condition described by Pred, LHS, and RHS is true.\n  /// Use only simple non-recursive types of checks, such as range analysis etc.\n  bool isKnownViaNonRecursiveReasoning(ICmpInst::Predicate Pred,\n                                       const SCEV *LHS, const SCEV *RHS);\n\n  /// Test whether the condition described by Pred, LHS, and RHS is true\n  /// whenever the condition described by Pred, FoundLHS, and FoundRHS is\n  /// true.\n  bool isImpliedCondOperandsHelper(ICmpInst::Predicate Pred, const SCEV *LHS,\n                                   const SCEV *RHS, const SCEV *FoundLHS,\n                                   const SCEV *FoundRHS);\n\n  /// Test whether the condition described by Pred, LHS, and RHS is true\n  /// whenever the condition described by Pred, FoundLHS, and FoundRHS is\n  /// true.  Utility function used by isImpliedCondOperands.  Tries to get\n  /// cases like \"X `sgt` 0 => X - 1 `sgt` -1\".\n  bool isImpliedCondOperandsViaRanges(ICmpInst::Predicate Pred, const SCEV *LHS,\n                                      const SCEV *RHS, const SCEV *FoundLHS,\n                                      const SCEV *FoundRHS);\n\n  /// Return true if the condition denoted by \\p LHS \\p Pred \\p RHS is implied\n  /// by a call to @llvm.experimental.guard in \\p BB.\n  bool isImpliedViaGuard(const BasicBlock *BB, ICmpInst::Predicate Pred,\n                         const SCEV *LHS, const SCEV *RHS);\n\n  /// Test whether the condition described by Pred, LHS, and RHS is true\n  /// whenever the condition described by Pred, FoundLHS, and FoundRHS is\n  /// true.\n  ///\n  /// This routine tries to rule out certain kinds of integer overflow, and\n  /// then tries to reason about arithmetic properties of the predicates.\n  bool isImpliedCondOperandsViaNoOverflow(ICmpInst::Predicate Pred,\n                                          const SCEV *LHS, const SCEV *RHS,\n                                          const SCEV *FoundLHS,\n                                          const SCEV *FoundRHS);\n\n  /// Test whether the condition described by Pred, LHS, and RHS is true\n  /// whenever the condition described by Pred, FoundLHS, and FoundRHS is\n  /// true.\n  ///\n  /// This routine tries to weaken the known condition basing on fact that\n  /// FoundLHS is an AddRec.\n  bool isImpliedCondOperandsViaAddRecStart(ICmpInst::Predicate Pred,\n                                           const SCEV *LHS, const SCEV *RHS,\n                                           const SCEV *FoundLHS,\n                                           const SCEV *FoundRHS,\n                                           const Instruction *Context);\n\n  /// Test whether the condition described by Pred, LHS, and RHS is true\n  /// whenever the condition described by Pred, FoundLHS, and FoundRHS is\n  /// true.\n  ///\n  /// This routine tries to figure out predicate for Phis which are SCEVUnknown\n  /// if it is true for every possible incoming value from their respective\n  /// basic blocks.\n  bool isImpliedViaMerge(ICmpInst::Predicate Pred,\n                         const SCEV *LHS, const SCEV *RHS,\n                         const SCEV *FoundLHS, const SCEV *FoundRHS,\n                         unsigned Depth);\n\n  /// If we know that the specified Phi is in the header of its containing\n  /// loop, we know the loop executes a constant number of times, and the PHI\n  /// node is just a recurrence involving constants, fold it.\n  Constant *getConstantEvolutionLoopExitValue(PHINode *PN, const APInt &BEs,\n                                              const Loop *L);\n\n  /// Test if the given expression is known to satisfy the condition described\n  /// by Pred and the known constant ranges of LHS and RHS.\n  bool isKnownPredicateViaConstantRanges(ICmpInst::Predicate Pred,\n                                         const SCEV *LHS, const SCEV *RHS);\n\n  /// Try to prove the condition described by \"LHS Pred RHS\" by ruling out\n  /// integer overflow.\n  ///\n  /// For instance, this will return true for \"A s< (A + C)<nsw>\" if C is\n  /// positive.\n  bool isKnownPredicateViaNoOverflow(ICmpInst::Predicate Pred, const SCEV *LHS,\n                                     const SCEV *RHS);\n\n  /// Try to split Pred LHS RHS into logical conjunctions (and's) and try to\n  /// prove them individually.\n  bool isKnownPredicateViaSplitting(ICmpInst::Predicate Pred, const SCEV *LHS,\n                                    const SCEV *RHS);\n\n  /// Try to match the Expr as \"(L + R)<Flags>\".\n  bool splitBinaryAdd(const SCEV *Expr, const SCEV *&L, const SCEV *&R,\n                      SCEV::NoWrapFlags &Flags);\n\n  /// Drop memoized information computed for S.\n  void forgetMemoizedResults(const SCEV *S);\n\n  /// Return an existing SCEV for V if there is one, otherwise return nullptr.\n  const SCEV *getExistingSCEV(Value *V);\n\n  /// Return false iff given SCEV contains a SCEVUnknown with NULL value-\n  /// pointer.\n  bool checkValidity(const SCEV *S) const;\n\n  /// Return true if `ExtendOpTy`({`Start`,+,`Step`}) can be proved to be\n  /// equal to {`ExtendOpTy`(`Start`),+,`ExtendOpTy`(`Step`)}.  This is\n  /// equivalent to proving no signed (resp. unsigned) wrap in\n  /// {`Start`,+,`Step`} if `ExtendOpTy` is `SCEVSignExtendExpr`\n  /// (resp. `SCEVZeroExtendExpr`).\n  template <typename ExtendOpTy>\n  bool proveNoWrapByVaryingStart(const SCEV *Start, const SCEV *Step,\n                                 const Loop *L);\n\n  /// Try to prove NSW or NUW on \\p AR relying on ConstantRange manipulation.\n  SCEV::NoWrapFlags proveNoWrapViaConstantRanges(const SCEVAddRecExpr *AR);\n\n  /// Try to prove NSW on \\p AR by proving facts about conditions known  on\n  /// entry and backedge.\n  SCEV::NoWrapFlags proveNoSignedWrapViaInduction(const SCEVAddRecExpr *AR);\n\n  /// Try to prove NUW on \\p AR by proving facts about conditions known on\n  /// entry and backedge.\n  SCEV::NoWrapFlags proveNoUnsignedWrapViaInduction(const SCEVAddRecExpr *AR);\n\n  Optional<MonotonicPredicateType>\n  getMonotonicPredicateTypeImpl(const SCEVAddRecExpr *LHS,\n                                ICmpInst::Predicate Pred);\n\n  /// Return SCEV no-wrap flags that can be proven based on reasoning about\n  /// how poison produced from no-wrap flags on this value (e.g. a nuw add)\n  /// would trigger undefined behavior on overflow.\n  SCEV::NoWrapFlags getNoWrapFlagsFromUB(const Value *V);\n\n  /// Return true if the SCEV corresponding to \\p I is never poison.  Proving\n  /// this is more complex than proving that just \\p I is never poison, since\n  /// SCEV commons expressions across control flow, and you can have cases\n  /// like:\n  ///\n  ///   idx0 = a + b;\n  ///   ptr[idx0] = 100;\n  ///   if (<condition>) {\n  ///     idx1 = a +nsw b;\n  ///     ptr[idx1] = 200;\n  ///   }\n  ///\n  /// where the SCEV expression (+ a b) is guaranteed to not be poison (and\n  /// hence not sign-overflow) only if \"<condition>\" is true.  Since both\n  /// `idx0` and `idx1` will be mapped to the same SCEV expression, (+ a b),\n  /// it is not okay to annotate (+ a b) with <nsw> in the above example.\n  bool isSCEVExprNeverPoison(const Instruction *I);\n\n  /// This is like \\c isSCEVExprNeverPoison but it specifically works for\n  /// instructions that will get mapped to SCEV add recurrences.  Return true\n  /// if \\p I will never generate poison under the assumption that \\p I is an\n  /// add recurrence on the loop \\p L.\n  bool isAddRecNeverPoison(const Instruction *I, const Loop *L);\n\n  /// Similar to createAddRecFromPHI, but with the additional flexibility of\n  /// suggesting runtime overflow checks in case casts are encountered.\n  /// If successful, the analysis records that for this loop, \\p SymbolicPHI,\n  /// which is the UnknownSCEV currently representing the PHI, can be rewritten\n  /// into an AddRec, assuming some predicates; The function then returns the\n  /// AddRec and the predicates as a pair, and caches this pair in\n  /// PredicatedSCEVRewrites.\n  /// If the analysis is not successful, a mapping from the \\p SymbolicPHI to\n  /// itself (with no predicates) is recorded, and a nullptr with an empty\n  /// predicates vector is returned as a pair.\n  Optional<std::pair<const SCEV *, SmallVector<const SCEVPredicate *, 3>>>\n  createAddRecFromPHIWithCastsImpl(const SCEVUnknown *SymbolicPHI);\n\n  /// Compute the backedge taken count knowing the interval difference, the\n  /// stride and presence of the equality in the comparison.\n  const SCEV *computeBECount(const SCEV *Delta, const SCEV *Stride,\n                             bool Equality);\n\n  /// Compute the maximum backedge count based on the range of values\n  /// permitted by Start, End, and Stride. This is for loops of the form\n  /// {Start, +, Stride} LT End.\n  ///\n  /// Precondition: the induction variable is known to be positive.  We *don't*\n  /// assert these preconditions so please be careful.\n  const SCEV *computeMaxBECountForLT(const SCEV *Start, const SCEV *Stride,\n                                     const SCEV *End, unsigned BitWidth,\n                                     bool IsSigned);\n\n  /// Verify if an linear IV with positive stride can overflow when in a\n  /// less-than comparison, knowing the invariant term of the comparison,\n  /// the stride and the knowledge of NSW/NUW flags on the recurrence.\n  bool doesIVOverflowOnLT(const SCEV *RHS, const SCEV *Stride, bool IsSigned,\n                          bool NoWrap);\n\n  /// Verify if an linear IV with negative stride can overflow when in a\n  /// greater-than comparison, knowing the invariant term of the comparison,\n  /// the stride and the knowledge of NSW/NUW flags on the recurrence.\n  bool doesIVOverflowOnGT(const SCEV *RHS, const SCEV *Stride, bool IsSigned,\n                          bool NoWrap);\n\n  /// Get add expr already created or create a new one.\n  const SCEV *getOrCreateAddExpr(ArrayRef<const SCEV *> Ops,\n                                 SCEV::NoWrapFlags Flags);\n\n  /// Get mul expr already created or create a new one.\n  const SCEV *getOrCreateMulExpr(ArrayRef<const SCEV *> Ops,\n                                 SCEV::NoWrapFlags Flags);\n\n  // Get addrec expr already created or create a new one.\n  const SCEV *getOrCreateAddRecExpr(ArrayRef<const SCEV *> Ops,\n                                    const Loop *L, SCEV::NoWrapFlags Flags);\n\n  /// Return x if \\p Val is f(x) where f is a 1-1 function.\n  const SCEV *stripInjectiveFunctions(const SCEV *Val) const;\n\n  /// Find all of the loops transitively used in \\p S, and fill \\p LoopsUsed.\n  /// A loop is considered \"used\" by an expression if it contains\n  /// an add rec on said loop.\n  void getUsedLoops(const SCEV *S, SmallPtrSetImpl<const Loop *> &LoopsUsed);\n\n  /// Find all of the loops transitively used in \\p S, and update \\c LoopUsers\n  /// accordingly.\n  void addToLoopUseLists(const SCEV *S);\n\n  /// Try to match the pattern generated by getURemExpr(A, B). If successful,\n  /// Assign A and B to LHS and RHS, respectively.\n  bool matchURem(const SCEV *Expr, const SCEV *&LHS, const SCEV *&RHS);\n\n  /// Look for a SCEV expression with type `SCEVType` and operands `Ops` in\n  /// `UniqueSCEVs`.\n  ///\n  /// The first component of the returned tuple is the SCEV if found and null\n  /// otherwise.  The second component is the `FoldingSetNodeID` that was\n  /// constructed to look up the SCEV and the third component is the insertion\n  /// point.\n  std::tuple<SCEV *, FoldingSetNodeID, void *>\n  findExistingSCEVInCache(SCEVTypes SCEVType, ArrayRef<const SCEV *> Ops);\n\n  FoldingSet<SCEV> UniqueSCEVs;\n  FoldingSet<SCEVPredicate> UniquePreds;\n  BumpPtrAllocator SCEVAllocator;\n\n  /// This maps loops to a list of SCEV expressions that (transitively) use said\n  /// loop.\n  DenseMap<const Loop *, SmallVector<const SCEV *, 4>> LoopUsers;\n\n  /// Cache tentative mappings from UnknownSCEVs in a Loop, to a SCEV expression\n  /// they can be rewritten into under certain predicates.\n  DenseMap<std::pair<const SCEVUnknown *, const Loop *>,\n           std::pair<const SCEV *, SmallVector<const SCEVPredicate *, 3>>>\n      PredicatedSCEVRewrites;\n\n  /// The head of a linked list of all SCEVUnknown values that have been\n  /// allocated. This is used by releaseMemory to locate them all and call\n  /// their destructors.\n  SCEVUnknown *FirstUnknown = nullptr;\n};\n\n/// Analysis pass that exposes the \\c ScalarEvolution for a function.\nclass ScalarEvolutionAnalysis\n    : public AnalysisInfoMixin<ScalarEvolutionAnalysis> {\n  friend AnalysisInfoMixin<ScalarEvolutionAnalysis>;\n\n  static AnalysisKey Key;\n\npublic:\n  using Result = ScalarEvolution;\n\n  ScalarEvolution run(Function &F, FunctionAnalysisManager &AM);\n};\n\n/// Verifier pass for the \\c ScalarEvolutionAnalysis results.\nclass ScalarEvolutionVerifierPass\n    : public PassInfoMixin<ScalarEvolutionVerifierPass> {\npublic:\n  PreservedAnalyses run(Function &F, FunctionAnalysisManager &AM);\n};\n\n/// Printer pass for the \\c ScalarEvolutionAnalysis results.\nclass ScalarEvolutionPrinterPass\n    : public PassInfoMixin<ScalarEvolutionPrinterPass> {\n  raw_ostream &OS;\n\npublic:\n  explicit ScalarEvolutionPrinterPass(raw_ostream &OS) : OS(OS) {}\n\n  PreservedAnalyses run(Function &F, FunctionAnalysisManager &AM);\n};\n\nclass ScalarEvolutionWrapperPass : public FunctionPass {\n  std::unique_ptr<ScalarEvolution> SE;\n\npublic:\n  static char ID;\n\n  ScalarEvolutionWrapperPass();\n\n  ScalarEvolution &getSE() { return *SE; }\n  const ScalarEvolution &getSE() const { return *SE; }\n\n  bool runOnFunction(Function &F) override;\n  void releaseMemory() override;\n  void getAnalysisUsage(AnalysisUsage &AU) const override;\n  void print(raw_ostream &OS, const Module * = nullptr) const override;\n  void verifyAnalysis() const override;\n};\n\n/// An interface layer with SCEV used to manage how we see SCEV expressions\n/// for values in the context of existing predicates. We can add new\n/// predicates, but we cannot remove them.\n///\n/// This layer has multiple purposes:\n///   - provides a simple interface for SCEV versioning.\n///   - guarantees that the order of transformations applied on a SCEV\n///     expression for a single Value is consistent across two different\n///     getSCEV calls. This means that, for example, once we've obtained\n///     an AddRec expression for a certain value through expression\n///     rewriting, we will continue to get an AddRec expression for that\n///     Value.\n///   - lowers the number of expression rewrites.\nclass PredicatedScalarEvolution {\npublic:\n  PredicatedScalarEvolution(ScalarEvolution &SE, Loop &L);\n\n  const SCEVUnionPredicate &getUnionPredicate() const;\n\n  /// Returns the SCEV expression of V, in the context of the current SCEV\n  /// predicate.  The order of transformations applied on the expression of V\n  /// returned by ScalarEvolution is guaranteed to be preserved, even when\n  /// adding new predicates.\n  const SCEV *getSCEV(Value *V);\n\n  /// Get the (predicated) backedge count for the analyzed loop.\n  const SCEV *getBackedgeTakenCount();\n\n  /// Adds a new predicate.\n  void addPredicate(const SCEVPredicate &Pred);\n\n  /// Attempts to produce an AddRecExpr for V by adding additional SCEV\n  /// predicates. If we can't transform the expression into an AddRecExpr we\n  /// return nullptr and not add additional SCEV predicates to the current\n  /// context.\n  const SCEVAddRecExpr *getAsAddRec(Value *V);\n\n  /// Proves that V doesn't overflow by adding SCEV predicate.\n  void setNoOverflow(Value *V, SCEVWrapPredicate::IncrementWrapFlags Flags);\n\n  /// Returns true if we've proved that V doesn't wrap by means of a SCEV\n  /// predicate.\n  bool hasNoOverflow(Value *V, SCEVWrapPredicate::IncrementWrapFlags Flags);\n\n  /// Returns the ScalarEvolution analysis used.\n  ScalarEvolution *getSE() const { return &SE; }\n\n  /// We need to explicitly define the copy constructor because of FlagsMap.\n  PredicatedScalarEvolution(const PredicatedScalarEvolution &);\n\n  /// Print the SCEV mappings done by the Predicated Scalar Evolution.\n  /// The printed text is indented by \\p Depth.\n  void print(raw_ostream &OS, unsigned Depth) const;\n\n  /// Check if \\p AR1 and \\p AR2 are equal, while taking into account\n  /// Equal predicates in Preds.\n  bool areAddRecsEqualWithPreds(const SCEVAddRecExpr *AR1,\n                                const SCEVAddRecExpr *AR2) const;\n\nprivate:\n  /// Increments the version number of the predicate.  This needs to be called\n  /// every time the SCEV predicate changes.\n  void updateGeneration();\n\n  /// Holds a SCEV and the version number of the SCEV predicate used to\n  /// perform the rewrite of the expression.\n  using RewriteEntry = std::pair<unsigned, const SCEV *>;\n\n  /// Maps a SCEV to the rewrite result of that SCEV at a certain version\n  /// number. If this number doesn't match the current Generation, we will\n  /// need to do a rewrite. To preserve the transformation order of previous\n  /// rewrites, we will rewrite the previous result instead of the original\n  /// SCEV.\n  DenseMap<const SCEV *, RewriteEntry> RewriteMap;\n\n  /// Records what NoWrap flags we've added to a Value *.\n  ValueMap<Value *, SCEVWrapPredicate::IncrementWrapFlags> FlagsMap;\n\n  /// The ScalarEvolution analysis.\n  ScalarEvolution &SE;\n\n  /// The analyzed Loop.\n  const Loop &L;\n\n  /// The SCEVPredicate that forms our context. We will rewrite all\n  /// expressions assuming that this predicate true.\n  SCEVUnionPredicate Preds;\n\n  /// Marks the version of the SCEV predicate used. When rewriting a SCEV\n  /// expression we mark it with the version of the predicate. We use this to\n  /// figure out if the predicate has changed from the last rewrite of the\n  /// SCEV. If so, we need to perform a new rewrite.\n  unsigned Generation = 0;\n\n  /// The backedge taken count.\n  const SCEV *BackedgeCount = nullptr;\n};\n\n} // end namespace llvm\n\n#endif // LLVM_ANALYSIS_SCALAREVOLUTION_H\n"}, "22": {"id": 22, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/IR/Attributes.h", "content": "//===- llvm/Attributes.h - Container for Attributes -------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n/// \\file\n/// This file contains the simple types necessary to represent the\n/// attributes associated with functions and their calls.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_IR_ATTRIBUTES_H\n#define LLVM_IR_ATTRIBUTES_H\n\n#include \"llvm-c/Types.h\"\n#include \"llvm/ADT/ArrayRef.h\"\n#include \"llvm/ADT/Optional.h\"\n#include \"llvm/ADT/StringRef.h\"\n#include \"llvm/ADT/iterator_range.h\"\n#include \"llvm/Config/llvm-config.h\"\n#include \"llvm/Support/Alignment.h\"\n#include \"llvm/Support/PointerLikeTypeTraits.h\"\n#include <bitset>\n#include <cassert>\n#include <cstdint>\n#include <map>\n#include <string>\n#include <utility>\n\nnamespace llvm {\n\nclass AttrBuilder;\nclass AttributeImpl;\nclass AttributeListImpl;\nclass AttributeSetNode;\ntemplate<typename T> struct DenseMapInfo;\nclass FoldingSetNodeID;\nclass Function;\nclass LLVMContext;\nclass Type;\n\n//===----------------------------------------------------------------------===//\n/// \\class\n/// Functions, function parameters, and return types can have attributes\n/// to indicate how they should be treated by optimizations and code\n/// generation. This class represents one of those attributes. It's light-weight\n/// and should be passed around by-value.\nclass Attribute {\npublic:\n  /// This enumeration lists the attributes that can be associated with\n  /// parameters, function results, or the function itself.\n  ///\n  /// Note: The `uwtable' attribute is about the ABI or the user mandating an\n  /// entry in the unwind table. The `nounwind' attribute is about an exception\n  /// passing by the function.\n  ///\n  /// In a theoretical system that uses tables for profiling and SjLj for\n  /// exceptions, they would be fully independent. In a normal system that uses\n  /// tables for both, the semantics are:\n  ///\n  /// nil                = Needs an entry because an exception might pass by.\n  /// nounwind           = No need for an entry\n  /// uwtable            = Needs an entry because the ABI says so and because\n  ///                      an exception might pass by.\n  /// uwtable + nounwind = Needs an entry because the ABI says so.\n\n  enum AttrKind {\n    // IR-Level Attributes\n    None,                  ///< No attributes have been set\n    #define GET_ATTR_NAMES\n    #define ATTRIBUTE_ENUM(ENUM_NAME, OTHER) ENUM_NAME,\n    #include \"llvm/IR/Attributes.inc\"\n    EndAttrKinds,          ///< Sentinal value useful for loops\n    EmptyKey,              ///< Use as Empty key for DenseMap of AttrKind\n    TombstoneKey,          ///< Use as Tombstone key for DenseMap of AttrKind\n  };\n\nprivate:\n  AttributeImpl *pImpl = nullptr;\n\n  Attribute(AttributeImpl *A) : pImpl(A) {}\n\npublic:\n  Attribute() = default;\n\n  //===--------------------------------------------------------------------===//\n  // Attribute Construction\n  //===--------------------------------------------------------------------===//\n\n  /// Return a uniquified Attribute object.\n  static Attribute get(LLVMContext &Context, AttrKind Kind, uint64_t Val = 0);\n  static Attribute get(LLVMContext &Context, StringRef Kind,\n                       StringRef Val = StringRef());\n  static Attribute get(LLVMContext &Context, AttrKind Kind, Type *Ty);\n\n  /// Return a uniquified Attribute object that has the specific\n  /// alignment set.\n  static Attribute getWithAlignment(LLVMContext &Context, Align Alignment);\n  static Attribute getWithStackAlignment(LLVMContext &Context, Align Alignment);\n  static Attribute getWithDereferenceableBytes(LLVMContext &Context,\n                                              uint64_t Bytes);\n  static Attribute getWithDereferenceableOrNullBytes(LLVMContext &Context,\n                                                     uint64_t Bytes);\n  static Attribute getWithAllocSizeArgs(LLVMContext &Context,\n                                        unsigned ElemSizeArg,\n                                        const Optional<unsigned> &NumElemsArg);\n  static Attribute getWithByValType(LLVMContext &Context, Type *Ty);\n  static Attribute getWithStructRetType(LLVMContext &Context, Type *Ty);\n  static Attribute getWithByRefType(LLVMContext &Context, Type *Ty);\n  static Attribute getWithPreallocatedType(LLVMContext &Context, Type *Ty);\n\n  /// For a typed attribute, return the equivalent attribute with the type\n  /// changed to \\p ReplacementTy.\n  Attribute getWithNewType(LLVMContext &Context, Type *ReplacementTy) {\n    assert(isTypeAttribute() && \"this requires a typed attribute\");\n    return get(Context, getKindAsEnum(), ReplacementTy);\n  }\n\n  static Attribute::AttrKind getAttrKindFromName(StringRef AttrName);\n\n  static StringRef getNameFromAttrKind(Attribute::AttrKind AttrKind);\n\n  /// Return true if and only if the attribute has an Argument.\n  static bool doesAttrKindHaveArgument(Attribute::AttrKind AttrKind);\n\n  /// Return true if the provided string matches the IR name of an attribute.\n  /// example: \"noalias\" return true but not \"NoAlias\"\n  static bool isExistingAttribute(StringRef Name);\n\n  //===--------------------------------------------------------------------===//\n  // Attribute Accessors\n  //===--------------------------------------------------------------------===//\n\n  /// Return true if the attribute is an Attribute::AttrKind type.\n  bool isEnumAttribute() const;\n\n  /// Return true if the attribute is an integer attribute.\n  bool isIntAttribute() const;\n\n  /// Return true if the attribute is a string (target-dependent)\n  /// attribute.\n  bool isStringAttribute() const;\n\n  /// Return true if the attribute is a type attribute.\n  bool isTypeAttribute() const;\n\n  /// Return true if the attribute is any kind of attribute.\n  bool isValid() const { return pImpl; }\n\n  /// Return true if the attribute is present.\n  bool hasAttribute(AttrKind Val) const;\n\n  /// Return true if the target-dependent attribute is present.\n  bool hasAttribute(StringRef Val) const;\n\n  /// Return the attribute's kind as an enum (Attribute::AttrKind). This\n  /// requires the attribute to be an enum or integer attribute.\n  Attribute::AttrKind getKindAsEnum() const;\n\n  /// Return the attribute's value as an integer. This requires that the\n  /// attribute be an integer attribute.\n  uint64_t getValueAsInt() const;\n\n  /// Return the attribute's kind as a string. This requires the\n  /// attribute to be a string attribute.\n  StringRef getKindAsString() const;\n\n  /// Return the attribute's value as a string. This requires the\n  /// attribute to be a string attribute.\n  StringRef getValueAsString() const;\n\n  /// Return the attribute's value as a Type. This requires the attribute to be\n  /// a type attribute.\n  Type *getValueAsType() const;\n\n  /// Returns the alignment field of an attribute as a byte alignment\n  /// value.\n  MaybeAlign getAlignment() const;\n\n  /// Returns the stack alignment field of an attribute as a byte\n  /// alignment value.\n  MaybeAlign getStackAlignment() const;\n\n  /// Returns the number of dereferenceable bytes from the\n  /// dereferenceable attribute.\n  uint64_t getDereferenceableBytes() const;\n\n  /// Returns the number of dereferenceable_or_null bytes from the\n  /// dereferenceable_or_null attribute.\n  uint64_t getDereferenceableOrNullBytes() const;\n\n  /// Returns the argument numbers for the allocsize attribute (or pair(0, 0)\n  /// if not known).\n  std::pair<unsigned, Optional<unsigned>> getAllocSizeArgs() const;\n\n  /// The Attribute is converted to a string of equivalent mnemonic. This\n  /// is, presumably, for writing out the mnemonics for the assembly writer.\n  std::string getAsString(bool InAttrGrp = false) const;\n\n  /// Equality and non-equality operators.\n  bool operator==(Attribute A) const { return pImpl == A.pImpl; }\n  bool operator!=(Attribute A) const { return pImpl != A.pImpl; }\n\n  /// Less-than operator. Useful for sorting the attributes list.\n  bool operator<(Attribute A) const;\n\n  void Profile(FoldingSetNodeID &ID) const;\n\n  /// Return a raw pointer that uniquely identifies this attribute.\n  void *getRawPointer() const {\n    return pImpl;\n  }\n\n  /// Get an attribute from a raw pointer created by getRawPointer.\n  static Attribute fromRawPointer(void *RawPtr) {\n    return Attribute(reinterpret_cast<AttributeImpl*>(RawPtr));\n  }\n};\n\n// Specialized opaque value conversions.\ninline LLVMAttributeRef wrap(Attribute Attr) {\n  return reinterpret_cast<LLVMAttributeRef>(Attr.getRawPointer());\n}\n\n// Specialized opaque value conversions.\ninline Attribute unwrap(LLVMAttributeRef Attr) {\n  return Attribute::fromRawPointer(Attr);\n}\n\n//===----------------------------------------------------------------------===//\n/// \\class\n/// This class holds the attributes for a particular argument, parameter,\n/// function, or return value. It is an immutable value type that is cheap to\n/// copy. Adding and removing enum attributes is intended to be fast, but adding\n/// and removing string or integer attributes involves a FoldingSet lookup.\nclass AttributeSet {\n  friend AttributeListImpl;\n  template <typename Ty> friend struct DenseMapInfo;\n\n  // TODO: Extract AvailableAttrs from AttributeSetNode and store them here.\n  // This will allow an efficient implementation of addAttribute and\n  // removeAttribute for enum attrs.\n\n  /// Private implementation pointer.\n  AttributeSetNode *SetNode = nullptr;\n\nprivate:\n  explicit AttributeSet(AttributeSetNode *ASN) : SetNode(ASN) {}\n\npublic:\n  /// AttributeSet is a trivially copyable value type.\n  AttributeSet() = default;\n  AttributeSet(const AttributeSet &) = default;\n  ~AttributeSet() = default;\n\n  static AttributeSet get(LLVMContext &C, const AttrBuilder &B);\n  static AttributeSet get(LLVMContext &C, ArrayRef<Attribute> Attrs);\n\n  bool operator==(const AttributeSet &O) const { return SetNode == O.SetNode; }\n  bool operator!=(const AttributeSet &O) const { return !(*this == O); }\n\n  /// Add an argument attribute. Returns a new set because attribute sets are\n  /// immutable.\n  LLVM_NODISCARD AttributeSet addAttribute(LLVMContext &C,\n                                           Attribute::AttrKind Kind) const;\n\n  /// Add a target-dependent attribute. Returns a new set because attribute sets\n  /// are immutable.\n  LLVM_NODISCARD AttributeSet addAttribute(LLVMContext &C, StringRef Kind,\n                                           StringRef Value = StringRef()) const;\n\n  /// Add attributes to the attribute set. Returns a new set because attribute\n  /// sets are immutable.\n  LLVM_NODISCARD AttributeSet addAttributes(LLVMContext &C,\n                                            AttributeSet AS) const;\n\n  /// Remove the specified attribute from this set. Returns a new set because\n  /// attribute sets are immutable.\n  LLVM_NODISCARD AttributeSet removeAttribute(LLVMContext &C,\n                                              Attribute::AttrKind Kind) const;\n\n  /// Remove the specified attribute from this set. Returns a new set because\n  /// attribute sets are immutable.\n  LLVM_NODISCARD AttributeSet removeAttribute(LLVMContext &C,\n                                              StringRef Kind) const;\n\n  /// Remove the specified attributes from this set. Returns a new set because\n  /// attribute sets are immutable.\n  LLVM_NODISCARD AttributeSet\n  removeAttributes(LLVMContext &C, const AttrBuilder &AttrsToRemove) const;\n\n  /// Return the number of attributes in this set.\n  unsigned getNumAttributes() const;\n\n  /// Return true if attributes exists in this set.\n  bool hasAttributes() const { return SetNode != nullptr; }\n\n  /// Return true if the attribute exists in this set.\n  bool hasAttribute(Attribute::AttrKind Kind) const;\n\n  /// Return true if the attribute exists in this set.\n  bool hasAttribute(StringRef Kind) const;\n\n  /// Return the attribute object.\n  Attribute getAttribute(Attribute::AttrKind Kind) const;\n\n  /// Return the target-dependent attribute object.\n  Attribute getAttribute(StringRef Kind) const;\n\n  MaybeAlign getAlignment() const;\n  MaybeAlign getStackAlignment() const;\n  uint64_t getDereferenceableBytes() const;\n  uint64_t getDereferenceableOrNullBytes() const;\n  Type *getByValType() const;\n  Type *getStructRetType() const;\n  Type *getByRefType() const;\n  Type *getPreallocatedType() const;\n  std::pair<unsigned, Optional<unsigned>> getAllocSizeArgs() const;\n  std::string getAsString(bool InAttrGrp = false) const;\n\n  using iterator = const Attribute *;\n\n  iterator begin() const;\n  iterator end() const;\n#if !defined(NDEBUG) || defined(LLVM_ENABLE_DUMP)\n  void dump() const;\n#endif\n};\n\n//===----------------------------------------------------------------------===//\n/// \\class\n/// Provide DenseMapInfo for AttributeSet.\ntemplate <> struct DenseMapInfo<AttributeSet> {\n  static AttributeSet getEmptyKey() {\n    auto Val = static_cast<uintptr_t>(-1);\n    Val <<= PointerLikeTypeTraits<void *>::NumLowBitsAvailable;\n    return AttributeSet(reinterpret_cast<AttributeSetNode *>(Val));\n  }\n\n  static AttributeSet getTombstoneKey() {\n    auto Val = static_cast<uintptr_t>(-2);\n    Val <<= PointerLikeTypeTraits<void *>::NumLowBitsAvailable;\n    return AttributeSet(reinterpret_cast<AttributeSetNode *>(Val));\n  }\n\n  static unsigned getHashValue(AttributeSet AS) {\n    return (unsigned((uintptr_t)AS.SetNode) >> 4) ^\n           (unsigned((uintptr_t)AS.SetNode) >> 9);\n  }\n\n  static bool isEqual(AttributeSet LHS, AttributeSet RHS) { return LHS == RHS; }\n};\n\n//===----------------------------------------------------------------------===//\n/// \\class\n/// This class holds the attributes for a function, its return value, and\n/// its parameters. You access the attributes for each of them via an index into\n/// the AttributeList object. The function attributes are at index\n/// `AttributeList::FunctionIndex', the return value is at index\n/// `AttributeList::ReturnIndex', and the attributes for the parameters start at\n/// index `AttributeList::FirstArgIndex'.\nclass AttributeList {\npublic:\n  enum AttrIndex : unsigned {\n    ReturnIndex = 0U,\n    FunctionIndex = ~0U,\n    FirstArgIndex = 1,\n  };\n\nprivate:\n  friend class AttrBuilder;\n  friend class AttributeListImpl;\n  friend class AttributeSet;\n  friend class AttributeSetNode;\n  template <typename Ty> friend struct DenseMapInfo;\n\n  /// The attributes that we are managing. This can be null to represent\n  /// the empty attributes list.\n  AttributeListImpl *pImpl = nullptr;\n\npublic:\n  /// Create an AttributeList with the specified parameters in it.\n  static AttributeList get(LLVMContext &C,\n                           ArrayRef<std::pair<unsigned, Attribute>> Attrs);\n  static AttributeList get(LLVMContext &C,\n                           ArrayRef<std::pair<unsigned, AttributeSet>> Attrs);\n\n  /// Create an AttributeList from attribute sets for a function, its\n  /// return value, and all of its arguments.\n  static AttributeList get(LLVMContext &C, AttributeSet FnAttrs,\n                           AttributeSet RetAttrs,\n                           ArrayRef<AttributeSet> ArgAttrs);\n\nprivate:\n  explicit AttributeList(AttributeListImpl *LI) : pImpl(LI) {}\n\n  static AttributeList getImpl(LLVMContext &C, ArrayRef<AttributeSet> AttrSets);\n\n  AttributeList setAttributes(LLVMContext &C, unsigned Index,\n                              AttributeSet Attrs) const;\n\npublic:\n  AttributeList() = default;\n\n  //===--------------------------------------------------------------------===//\n  // AttributeList Construction and Mutation\n  //===--------------------------------------------------------------------===//\n\n  /// Return an AttributeList with the specified parameters in it.\n  static AttributeList get(LLVMContext &C, ArrayRef<AttributeList> Attrs);\n  static AttributeList get(LLVMContext &C, unsigned Index,\n                           ArrayRef<Attribute::AttrKind> Kinds);\n  static AttributeList get(LLVMContext &C, unsigned Index,\n                           ArrayRef<Attribute::AttrKind> Kinds,\n                           ArrayRef<uint64_t> Values);\n  static AttributeList get(LLVMContext &C, unsigned Index,\n                           ArrayRef<StringRef> Kind);\n  static AttributeList get(LLVMContext &C, unsigned Index,\n                           const AttrBuilder &B);\n\n  /// Add an attribute to the attribute set at the given index.\n  /// Returns a new list because attribute lists are immutable.\n  LLVM_NODISCARD AttributeList addAttribute(LLVMContext &C, unsigned Index,\n                                            Attribute::AttrKind Kind) const;\n\n  /// Add an attribute to the attribute set at the given index.\n  /// Returns a new list because attribute lists are immutable.\n  LLVM_NODISCARD AttributeList\n  addAttribute(LLVMContext &C, unsigned Index, StringRef Kind,\n               StringRef Value = StringRef()) const;\n\n  /// Add an attribute to the attribute set at the given index.\n  /// Returns a new list because attribute lists are immutable.\n  LLVM_NODISCARD AttributeList addAttribute(LLVMContext &C, unsigned Index,\n                                            Attribute A) const;\n\n  /// Add attributes to the attribute set at the given index.\n  /// Returns a new list because attribute lists are immutable.\n  LLVM_NODISCARD AttributeList addAttributes(LLVMContext &C, unsigned Index,\n                                             const AttrBuilder &B) const;\n\n  /// Add an argument attribute to the list. Returns a new list because\n  /// attribute lists are immutable.\n  LLVM_NODISCARD AttributeList addParamAttribute(\n      LLVMContext &C, unsigned ArgNo, Attribute::AttrKind Kind) const {\n    return addAttribute(C, ArgNo + FirstArgIndex, Kind);\n  }\n\n  /// Add an argument attribute to the list. Returns a new list because\n  /// attribute lists are immutable.\n  LLVM_NODISCARD AttributeList\n  addParamAttribute(LLVMContext &C, unsigned ArgNo, StringRef Kind,\n                    StringRef Value = StringRef()) const {\n    return addAttribute(C, ArgNo + FirstArgIndex, Kind, Value);\n  }\n\n  /// Add an attribute to the attribute list at the given arg indices. Returns a\n  /// new list because attribute lists are immutable.\n  LLVM_NODISCARD AttributeList addParamAttribute(LLVMContext &C,\n                                                 ArrayRef<unsigned> ArgNos,\n                                                 Attribute A) const;\n\n  /// Add an argument attribute to the list. Returns a new list because\n  /// attribute lists are immutable.\n  LLVM_NODISCARD AttributeList addParamAttributes(LLVMContext &C,\n                                                  unsigned ArgNo,\n                                                  const AttrBuilder &B) const {\n    return addAttributes(C, ArgNo + FirstArgIndex, B);\n  }\n\n  /// Remove the specified attribute at the specified index from this\n  /// attribute list. Returns a new list because attribute lists are immutable.\n  LLVM_NODISCARD AttributeList removeAttribute(LLVMContext &C, unsigned Index,\n                                               Attribute::AttrKind Kind) const;\n\n  /// Remove the specified attribute at the specified index from this\n  /// attribute list. Returns a new list because attribute lists are immutable.\n  LLVM_NODISCARD AttributeList removeAttribute(LLVMContext &C, unsigned Index,\n                                               StringRef Kind) const;\n\n  /// Remove the specified attributes at the specified index from this\n  /// attribute list. Returns a new list because attribute lists are immutable.\n  LLVM_NODISCARD AttributeList removeAttributes(\n      LLVMContext &C, unsigned Index, const AttrBuilder &AttrsToRemove) const;\n\n  /// Remove all attributes at the specified index from this\n  /// attribute list. Returns a new list because attribute lists are immutable.\n  LLVM_NODISCARD AttributeList removeAttributes(LLVMContext &C,\n                                                unsigned Index) const;\n\n  /// Remove the specified attribute at the specified arg index from this\n  /// attribute list. Returns a new list because attribute lists are immutable.\n  LLVM_NODISCARD AttributeList removeParamAttribute(\n      LLVMContext &C, unsigned ArgNo, Attribute::AttrKind Kind) const {\n    return removeAttribute(C, ArgNo + FirstArgIndex, Kind);\n  }\n\n  /// Remove the specified attribute at the specified arg index from this\n  /// attribute list. Returns a new list because attribute lists are immutable.\n  LLVM_NODISCARD AttributeList removeParamAttribute(LLVMContext &C,\n                                                    unsigned ArgNo,\n                                                    StringRef Kind) const {\n    return removeAttribute(C, ArgNo + FirstArgIndex, Kind);\n  }\n\n  /// Remove the specified attribute at the specified arg index from this\n  /// attribute list. Returns a new list because attribute lists are immutable.\n  LLVM_NODISCARD AttributeList removeParamAttributes(\n      LLVMContext &C, unsigned ArgNo, const AttrBuilder &AttrsToRemove) const {\n    return removeAttributes(C, ArgNo + FirstArgIndex, AttrsToRemove);\n  }\n\n  /// Remove all attributes at the specified arg index from this\n  /// attribute list. Returns a new list because attribute lists are immutable.\n  LLVM_NODISCARD AttributeList removeParamAttributes(LLVMContext &C,\n                                                     unsigned ArgNo) const {\n    return removeAttributes(C, ArgNo + FirstArgIndex);\n  }\n\n  /// Replace the type contained by attribute \\p AttrKind at index \\p ArgNo wih\n  /// \\p ReplacementTy, preserving all other attributes.\n  LLVM_NODISCARD AttributeList replaceAttributeType(LLVMContext &C,\n                                                    unsigned ArgNo,\n                                                    Attribute::AttrKind Kind,\n                                                    Type *ReplacementTy) const {\n    Attribute Attr = getAttribute(ArgNo, Kind);\n    auto Attrs = removeAttribute(C, ArgNo, Kind);\n    return Attrs.addAttribute(C, ArgNo, Attr.getWithNewType(C, ReplacementTy));\n  }\n\n  /// \\brief Add the dereferenceable attribute to the attribute set at the given\n  /// index. Returns a new list because attribute lists are immutable.\n  LLVM_NODISCARD AttributeList addDereferenceableAttr(LLVMContext &C,\n                                                      unsigned Index,\n                                                      uint64_t Bytes) const;\n\n  /// \\brief Add the dereferenceable attribute to the attribute set at the given\n  /// arg index. Returns a new list because attribute lists are immutable.\n  LLVM_NODISCARD AttributeList addDereferenceableParamAttr(\n      LLVMContext &C, unsigned ArgNo, uint64_t Bytes) const {\n    return addDereferenceableAttr(C, ArgNo + FirstArgIndex, Bytes);\n  }\n\n  /// Add the dereferenceable_or_null attribute to the attribute set at\n  /// the given index. Returns a new list because attribute lists are immutable.\n  LLVM_NODISCARD AttributeList addDereferenceableOrNullAttr(\n      LLVMContext &C, unsigned Index, uint64_t Bytes) const;\n\n  /// Add the dereferenceable_or_null attribute to the attribute set at\n  /// the given arg index. Returns a new list because attribute lists are\n  /// immutable.\n  LLVM_NODISCARD AttributeList addDereferenceableOrNullParamAttr(\n      LLVMContext &C, unsigned ArgNo, uint64_t Bytes) const {\n    return addDereferenceableOrNullAttr(C, ArgNo + FirstArgIndex, Bytes);\n  }\n\n  /// Add the allocsize attribute to the attribute set at the given index.\n  /// Returns a new list because attribute lists are immutable.\n  LLVM_NODISCARD AttributeList\n  addAllocSizeAttr(LLVMContext &C, unsigned Index, unsigned ElemSizeArg,\n                   const Optional<unsigned> &NumElemsArg);\n\n  /// Add the allocsize attribute to the attribute set at the given arg index.\n  /// Returns a new list because attribute lists are immutable.\n  LLVM_NODISCARD AttributeList\n  addAllocSizeParamAttr(LLVMContext &C, unsigned ArgNo, unsigned ElemSizeArg,\n                        const Optional<unsigned> &NumElemsArg) {\n    return addAllocSizeAttr(C, ArgNo + FirstArgIndex, ElemSizeArg, NumElemsArg);\n  }\n\n  //===--------------------------------------------------------------------===//\n  // AttributeList Accessors\n  //===--------------------------------------------------------------------===//\n\n  /// The attributes for the specified index are returned.\n  AttributeSet getAttributes(unsigned Index) const;\n\n  /// The attributes for the argument or parameter at the given index are\n  /// returned.\n  AttributeSet getParamAttributes(unsigned ArgNo) const;\n\n  /// The attributes for the ret value are returned.\n  AttributeSet getRetAttributes() const;\n\n  /// The function attributes are returned.\n  AttributeSet getFnAttributes() const;\n\n  /// Return true if the attribute exists at the given index.\n  bool hasAttribute(unsigned Index, Attribute::AttrKind Kind) const;\n\n  /// Return true if the attribute exists at the given index.\n  bool hasAttribute(unsigned Index, StringRef Kind) const;\n\n  /// Return true if attribute exists at the given index.\n  bool hasAttributes(unsigned Index) const;\n\n  /// Return true if the attribute exists for the given argument\n  bool hasParamAttr(unsigned ArgNo, Attribute::AttrKind Kind) const {\n    return hasAttribute(ArgNo + FirstArgIndex, Kind);\n  }\n\n  /// Return true if the attribute exists for the given argument\n  bool hasParamAttr(unsigned ArgNo, StringRef Kind) const {\n    return hasAttribute(ArgNo + FirstArgIndex, Kind);\n  }\n\n  /// Return true if attributes exists for the given argument\n  bool hasParamAttrs(unsigned ArgNo) const {\n    return hasAttributes(ArgNo + FirstArgIndex);\n  }\n\n  /// Equivalent to hasAttribute(AttributeList::FunctionIndex, Kind) but\n  /// may be faster.\n  bool hasFnAttribute(Attribute::AttrKind Kind) const;\n\n  /// Equivalent to hasAttribute(AttributeList::FunctionIndex, Kind) but\n  /// may be faster.\n  bool hasFnAttribute(StringRef Kind) const;\n\n  /// Equivalent to hasAttribute(ArgNo + FirstArgIndex, Kind).\n  bool hasParamAttribute(unsigned ArgNo, Attribute::AttrKind Kind) const;\n\n  /// Return true if the specified attribute is set for at least one\n  /// parameter or for the return value. If Index is not nullptr, the index\n  /// of a parameter with the specified attribute is provided.\n  bool hasAttrSomewhere(Attribute::AttrKind Kind,\n                        unsigned *Index = nullptr) const;\n\n  /// Return the attribute object that exists at the given index.\n  Attribute getAttribute(unsigned Index, Attribute::AttrKind Kind) const;\n\n  /// Return the attribute object that exists at the given index.\n  Attribute getAttribute(unsigned Index, StringRef Kind) const;\n\n  /// Return the attribute object that exists at the arg index.\n  Attribute getParamAttr(unsigned ArgNo, Attribute::AttrKind Kind) const {\n    return getAttribute(ArgNo + FirstArgIndex, Kind);\n  }\n\n  /// Return the attribute object that exists at the given index.\n  Attribute getParamAttr(unsigned ArgNo, StringRef Kind) const {\n    return getAttribute(ArgNo + FirstArgIndex, Kind);\n  }\n\n  /// Return the alignment of the return value.\n  MaybeAlign getRetAlignment() const;\n\n  /// Return the alignment for the specified function parameter.\n  MaybeAlign getParamAlignment(unsigned ArgNo) const;\n\n  /// Return the byval type for the specified function parameter.\n  Type *getParamByValType(unsigned ArgNo) const;\n\n  /// Return the sret type for the specified function parameter.\n  Type *getParamStructRetType(unsigned ArgNo) const;\n\n  /// Return the byref type for the specified function parameter.\n  Type *getParamByRefType(unsigned ArgNo) const;\n\n  /// Return the preallocated type for the specified function parameter.\n  Type *getParamPreallocatedType(unsigned ArgNo) const;\n\n  /// Get the stack alignment.\n  MaybeAlign getStackAlignment(unsigned Index) const;\n\n  /// Get the number of dereferenceable bytes (or zero if unknown).\n  uint64_t getDereferenceableBytes(unsigned Index) const;\n\n  /// Get the number of dereferenceable bytes (or zero if unknown) of an\n  /// arg.\n  uint64_t getParamDereferenceableBytes(unsigned ArgNo) const {\n    return getDereferenceableBytes(ArgNo + FirstArgIndex);\n  }\n\n  /// Get the number of dereferenceable_or_null bytes (or zero if\n  /// unknown).\n  uint64_t getDereferenceableOrNullBytes(unsigned Index) const;\n\n  /// Get the number of dereferenceable_or_null bytes (or zero if\n  /// unknown) of an arg.\n  uint64_t getParamDereferenceableOrNullBytes(unsigned ArgNo) const {\n    return getDereferenceableOrNullBytes(ArgNo + FirstArgIndex);\n  }\n\n  /// Get the allocsize argument numbers (or pair(0, 0) if unknown).\n  std::pair<unsigned, Optional<unsigned>>\n  getAllocSizeArgs(unsigned Index) const;\n\n  /// Return the attributes at the index as a string.\n  std::string getAsString(unsigned Index, bool InAttrGrp = false) const;\n\n  //===--------------------------------------------------------------------===//\n  // AttributeList Introspection\n  //===--------------------------------------------------------------------===//\n\n  using iterator = const AttributeSet *;\n\n  iterator begin() const;\n  iterator end() const;\n\n  unsigned getNumAttrSets() const;\n\n  /// Use these to iterate over the valid attribute indices.\n  unsigned index_begin() const { return AttributeList::FunctionIndex; }\n  unsigned index_end() const { return getNumAttrSets() - 1; }\n\n  /// operator==/!= - Provide equality predicates.\n  bool operator==(const AttributeList &RHS) const { return pImpl == RHS.pImpl; }\n  bool operator!=(const AttributeList &RHS) const { return pImpl != RHS.pImpl; }\n\n  /// Return a raw pointer that uniquely identifies this attribute list.\n  void *getRawPointer() const {\n    return pImpl;\n  }\n\n  /// Return true if there are no attributes.\n  bool isEmpty() const { return pImpl == nullptr; }\n\n  void dump() const;\n};\n\n//===----------------------------------------------------------------------===//\n/// \\class\n/// Provide DenseMapInfo for AttributeList.\ntemplate <> struct DenseMapInfo<AttributeList> {\n  static AttributeList getEmptyKey() {\n    auto Val = static_cast<uintptr_t>(-1);\n    Val <<= PointerLikeTypeTraits<void*>::NumLowBitsAvailable;\n    return AttributeList(reinterpret_cast<AttributeListImpl *>(Val));\n  }\n\n  static AttributeList getTombstoneKey() {\n    auto Val = static_cast<uintptr_t>(-2);\n    Val <<= PointerLikeTypeTraits<void*>::NumLowBitsAvailable;\n    return AttributeList(reinterpret_cast<AttributeListImpl *>(Val));\n  }\n\n  static unsigned getHashValue(AttributeList AS) {\n    return (unsigned((uintptr_t)AS.pImpl) >> 4) ^\n           (unsigned((uintptr_t)AS.pImpl) >> 9);\n  }\n\n  static bool isEqual(AttributeList LHS, AttributeList RHS) {\n    return LHS == RHS;\n  }\n};\n\n//===----------------------------------------------------------------------===//\n/// \\class\n/// This class is used in conjunction with the Attribute::get method to\n/// create an Attribute object. The object itself is uniquified. The Builder's\n/// value, however, is not. So this can be used as a quick way to test for\n/// equality, presence of attributes, etc.\nclass AttrBuilder {\n  std::bitset<Attribute::EndAttrKinds> Attrs;\n  std::map<std::string, std::string, std::less<>> TargetDepAttrs;\n  MaybeAlign Alignment;\n  MaybeAlign StackAlignment;\n  uint64_t DerefBytes = 0;\n  uint64_t DerefOrNullBytes = 0;\n  uint64_t AllocSizeArgs = 0;\n  Type *ByValType = nullptr;\n  Type *StructRetType = nullptr;\n  Type *ByRefType = nullptr;\n  Type *PreallocatedType = nullptr;\n\npublic:\n  AttrBuilder() = default;\n\n  AttrBuilder(const Attribute &A) {\n    addAttribute(A);\n  }\n\n  AttrBuilder(AttributeList AS, unsigned Idx);\n  AttrBuilder(AttributeSet AS);\n\n  void clear();\n\n  /// Add an attribute to the builder.\n  AttrBuilder &addAttribute(Attribute::AttrKind Val) {\n    assert((unsigned)Val < Attribute::EndAttrKinds &&\n           \"Attribute out of range!\");\n    assert(!Attribute::doesAttrKindHaveArgument(Val) &&\n           \"Adding integer attribute without adding a value!\");\n    Attrs[Val] = true;\n    return *this;\n  }\n\n  /// Add the Attribute object to the builder.\n  AttrBuilder &addAttribute(Attribute A);\n\n  /// Add the target-dependent attribute to the builder.\n  AttrBuilder &addAttribute(StringRef A, StringRef V = StringRef());\n\n  /// Remove an attribute from the builder.\n  AttrBuilder &removeAttribute(Attribute::AttrKind Val);\n\n  /// Remove the attributes from the builder.\n  AttrBuilder &removeAttributes(AttributeList A, uint64_t WithoutIndex);\n\n  /// Remove the target-dependent attribute to the builder.\n  AttrBuilder &removeAttribute(StringRef A);\n\n  /// Add the attributes from the builder.\n  AttrBuilder &merge(const AttrBuilder &B);\n\n  /// Remove the attributes from the builder.\n  AttrBuilder &remove(const AttrBuilder &B);\n\n  /// Return true if the builder has any attribute that's in the\n  /// specified builder.\n  bool overlaps(const AttrBuilder &B) const;\n\n  /// Return true if the builder has the specified attribute.\n  bool contains(Attribute::AttrKind A) const {\n    assert((unsigned)A < Attribute::EndAttrKinds && \"Attribute out of range!\");\n    return Attrs[A];\n  }\n\n  /// Return true if the builder has the specified target-dependent\n  /// attribute.\n  bool contains(StringRef A) const;\n\n  /// Return true if the builder has IR-level attributes.\n  bool hasAttributes() const;\n\n  /// Return true if the builder has any attribute that's in the\n  /// specified attribute.\n  bool hasAttributes(AttributeList A, uint64_t Index) const;\n\n  /// Return true if the builder has an alignment attribute.\n  bool hasAlignmentAttr() const;\n\n  /// Retrieve the alignment attribute, if it exists.\n  MaybeAlign getAlignment() const { return Alignment; }\n\n  /// Retrieve the stack alignment attribute, if it exists.\n  MaybeAlign getStackAlignment() const { return StackAlignment; }\n\n  /// Retrieve the number of dereferenceable bytes, if the\n  /// dereferenceable attribute exists (zero is returned otherwise).\n  uint64_t getDereferenceableBytes() const { return DerefBytes; }\n\n  /// Retrieve the number of dereferenceable_or_null bytes, if the\n  /// dereferenceable_or_null attribute exists (zero is returned otherwise).\n  uint64_t getDereferenceableOrNullBytes() const { return DerefOrNullBytes; }\n\n  /// Retrieve the byval type.\n  Type *getByValType() const { return ByValType; }\n\n  /// Retrieve the sret type.\n  Type *getStructRetType() const { return StructRetType; }\n\n  /// Retrieve the byref type.\n  Type *getByRefType() const { return ByRefType; }\n\n  /// Retrieve the preallocated type.\n  Type *getPreallocatedType() const { return PreallocatedType; }\n\n  /// Retrieve the allocsize args, if the allocsize attribute exists.  If it\n  /// doesn't exist, pair(0, 0) is returned.\n  std::pair<unsigned, Optional<unsigned>> getAllocSizeArgs() const;\n\n  /// This turns an alignment into the form used internally in Attribute.\n  /// This call has no effect if Align is not set.\n  AttrBuilder &addAlignmentAttr(MaybeAlign Align);\n\n  /// This turns an int alignment (which must be a power of 2) into the\n  /// form used internally in Attribute.\n  /// This call has no effect if Align is 0.\n  /// Deprecated, use the version using a MaybeAlign.\n  inline AttrBuilder &addAlignmentAttr(unsigned Align) {\n    return addAlignmentAttr(MaybeAlign(Align));\n  }\n\n  /// This turns a stack alignment into the form used internally in Attribute.\n  /// This call has no effect if Align is not set.\n  AttrBuilder &addStackAlignmentAttr(MaybeAlign Align);\n\n  /// This turns an int stack alignment (which must be a power of 2) into\n  /// the form used internally in Attribute.\n  /// This call has no effect if Align is 0.\n  /// Deprecated, use the version using a MaybeAlign.\n  inline AttrBuilder &addStackAlignmentAttr(unsigned Align) {\n    return addStackAlignmentAttr(MaybeAlign(Align));\n  }\n\n  /// This turns the number of dereferenceable bytes into the form used\n  /// internally in Attribute.\n  AttrBuilder &addDereferenceableAttr(uint64_t Bytes);\n\n  /// This turns the number of dereferenceable_or_null bytes into the\n  /// form used internally in Attribute.\n  AttrBuilder &addDereferenceableOrNullAttr(uint64_t Bytes);\n\n  /// This turns one (or two) ints into the form used internally in Attribute.\n  AttrBuilder &addAllocSizeAttr(unsigned ElemSizeArg,\n                                const Optional<unsigned> &NumElemsArg);\n\n  /// This turns a byval type into the form used internally in Attribute.\n  AttrBuilder &addByValAttr(Type *Ty);\n\n  /// This turns a sret type into the form used internally in Attribute.\n  AttrBuilder &addStructRetAttr(Type *Ty);\n\n  /// This turns a byref type into the form used internally in Attribute.\n  AttrBuilder &addByRefAttr(Type *Ty);\n\n  /// This turns a preallocated type into the form used internally in Attribute.\n  AttrBuilder &addPreallocatedAttr(Type *Ty);\n\n  /// Add an allocsize attribute, using the representation returned by\n  /// Attribute.getIntValue().\n  AttrBuilder &addAllocSizeAttrFromRawRepr(uint64_t RawAllocSizeRepr);\n\n  /// Return true if the builder contains no target-independent\n  /// attributes.\n  bool empty() const { return Attrs.none(); }\n\n  // Iterators for target-dependent attributes.\n  using td_type = std::pair<std::string, std::string>;\n  using td_iterator = decltype(TargetDepAttrs)::iterator;\n  using td_const_iterator = decltype(TargetDepAttrs)::const_iterator;\n  using td_range = iterator_range<td_iterator>;\n  using td_const_range = iterator_range<td_const_iterator>;\n\n  td_iterator td_begin() { return TargetDepAttrs.begin(); }\n  td_iterator td_end() { return TargetDepAttrs.end(); }\n\n  td_const_iterator td_begin() const { return TargetDepAttrs.begin(); }\n  td_const_iterator td_end() const { return TargetDepAttrs.end(); }\n\n  td_range td_attrs() { return td_range(td_begin(), td_end()); }\n\n  td_const_range td_attrs() const {\n    return td_const_range(td_begin(), td_end());\n  }\n\n  bool td_empty() const { return TargetDepAttrs.empty(); }\n\n  bool operator==(const AttrBuilder &B) const;\n  bool operator!=(const AttrBuilder &B) const { return !(*this == B); }\n};\n\nnamespace AttributeFuncs {\n\n/// Which attributes cannot be applied to a type.\nAttrBuilder typeIncompatible(Type *Ty);\n\n/// \\returns Return true if the two functions have compatible target-independent\n/// attributes for inlining purposes.\nbool areInlineCompatible(const Function &Caller, const Function &Callee);\n\n\n/// Checks  if there are any incompatible function attributes between\n/// \\p A and \\p B.\n///\n/// \\param [in] A - The first function to be compared with.\n/// \\param [in] B - The second function to be compared with.\n/// \\returns true if the functions have compatible attributes.\nbool areOutlineCompatible(const Function &A, const Function &B);\n\n/// Merge caller's and callee's attributes.\nvoid mergeAttributesForInlining(Function &Caller, const Function &Callee);\n\n/// Merges the functions attributes from \\p ToMerge into function \\p Base.\n///\n/// \\param [in,out] Base - The function being merged into.\n/// \\param [in] ToMerge - The function to merge attributes from.\nvoid mergeAttributesForOutlining(Function &Base, const Function &ToMerge);\n\n} // end namespace AttributeFuncs\n\n} // end namespace llvm\n\n#endif // LLVM_IR_ATTRIBUTES_H\n"}, "24": {"id": 24, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/IR/ConstantRange.h", "content": "//===- ConstantRange.h - Represent a range ----------------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// Represent a range of possible values that may occur when the program is run\n// for an integral value.  This keeps track of a lower and upper bound for the\n// constant, which MAY wrap around the end of the numeric range.  To do this, it\n// keeps track of a [lower, upper) bound, which specifies an interval just like\n// STL iterators.  When used with boolean values, the following are important\n// ranges: :\n//\n//  [F, F) = {}     = Empty set\n//  [T, F) = {T}\n//  [F, T) = {F}\n//  [T, T) = {F, T} = Full set\n//\n// The other integral ranges use min/max values for special range values. For\n// example, for 8-bit types, it uses:\n// [0, 0)     = {}       = Empty set\n// [255, 255) = {0..255} = Full Set\n//\n// Note that ConstantRange can be used to represent either signed or\n// unsigned ranges.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_IR_CONSTANTRANGE_H\n#define LLVM_IR_CONSTANTRANGE_H\n\n#include \"llvm/ADT/APInt.h\"\n#include \"llvm/IR/InstrTypes.h\"\n#include \"llvm/IR/Instruction.h\"\n#include \"llvm/Support/Compiler.h\"\n#include <cstdint>\n\nnamespace llvm {\n\nclass MDNode;\nclass raw_ostream;\nstruct KnownBits;\n\n/// This class represents a range of values.\nclass LLVM_NODISCARD ConstantRange {\n  APInt Lower, Upper;\n\n  /// Create empty constant range with same bitwidth.\n  ConstantRange getEmpty() const {\n    return ConstantRange(getBitWidth(), false);\n  }\n\n  /// Create full constant range with same bitwidth.\n  ConstantRange getFull() const {\n    return ConstantRange(getBitWidth(), true);\n  }\n\npublic:\n  /// Initialize a full or empty set for the specified bit width.\n  explicit ConstantRange(uint32_t BitWidth, bool isFullSet);\n\n  /// Initialize a range to hold the single specified value.\n  ConstantRange(APInt Value);\n\n  /// Initialize a range of values explicitly. This will assert out if\n  /// Lower==Upper and Lower != Min or Max value for its type. It will also\n  /// assert out if the two APInt's are not the same bit width.\n  ConstantRange(APInt Lower, APInt Upper);\n\n  /// Create empty constant range with the given bit width.\n  static ConstantRange getEmpty(uint32_t BitWidth) {\n    return ConstantRange(BitWidth, false);\n  }\n\n  /// Create full constant range with the given bit width.\n  static ConstantRange getFull(uint32_t BitWidth) {\n    return ConstantRange(BitWidth, true);\n  }\n\n  /// Create non-empty constant range with the given bounds. If Lower and\n  /// Upper are the same, a full range is returned.\n  static ConstantRange getNonEmpty(APInt Lower, APInt Upper) {\n    if (Lower == Upper)\n      return getFull(Lower.getBitWidth());\n    return ConstantRange(std::move(Lower), std::move(Upper));\n  }\n\n  /// Initialize a range based on a known bits constraint. The IsSigned flag\n  /// indicates whether the constant range should not wrap in the signed or\n  /// unsigned domain.\n  static ConstantRange fromKnownBits(const KnownBits &Known, bool IsSigned);\n\n  /// Produce the smallest range such that all values that may satisfy the given\n  /// predicate with any value contained within Other is contained in the\n  /// returned range.  Formally, this returns a superset of\n  /// 'union over all y in Other . { x : icmp op x y is true }'.  If the exact\n  /// answer is not representable as a ConstantRange, the return value will be a\n  /// proper superset of the above.\n  ///\n  /// Example: Pred = ult and Other = i8 [2, 5) returns Result = [0, 4)\n  static ConstantRange makeAllowedICmpRegion(CmpInst::Predicate Pred,\n                                             const ConstantRange &Other);\n\n  /// Produce the largest range such that all values in the returned range\n  /// satisfy the given predicate with all values contained within Other.\n  /// Formally, this returns a subset of\n  /// 'intersection over all y in Other . { x : icmp op x y is true }'.  If the\n  /// exact answer is not representable as a ConstantRange, the return value\n  /// will be a proper subset of the above.\n  ///\n  /// Example: Pred = ult and Other = i8 [2, 5) returns [0, 2)\n  static ConstantRange makeSatisfyingICmpRegion(CmpInst::Predicate Pred,\n                                                const ConstantRange &Other);\n\n  /// Produce the exact range such that all values in the returned range satisfy\n  /// the given predicate with any value contained within Other. Formally, this\n  /// returns the exact answer when the superset of 'union over all y in Other\n  /// is exactly same as the subset of intersection over all y in Other.\n  /// { x : icmp op x y is true}'.\n  ///\n  /// Example: Pred = ult and Other = i8 3 returns [0, 3)\n  static ConstantRange makeExactICmpRegion(CmpInst::Predicate Pred,\n                                           const APInt &Other);\n\n  /// Produce the largest range containing all X such that \"X BinOp Y\" is\n  /// guaranteed not to wrap (overflow) for *all* Y in Other. However, there may\n  /// be *some* Y in Other for which additional X not contained in the result\n  /// also do not overflow.\n  ///\n  /// NoWrapKind must be one of OBO::NoUnsignedWrap or OBO::NoSignedWrap.\n  ///\n  /// Examples:\n  ///  typedef OverflowingBinaryOperator OBO;\n  ///  #define MGNR makeGuaranteedNoWrapRegion\n  ///  MGNR(Add, [i8 1, 2), OBO::NoSignedWrap) == [-128, 127)\n  ///  MGNR(Add, [i8 1, 2), OBO::NoUnsignedWrap) == [0, -1)\n  ///  MGNR(Add, [i8 0, 1), OBO::NoUnsignedWrap) == Full Set\n  ///  MGNR(Add, [i8 -1, 6), OBO::NoSignedWrap) == [INT_MIN+1, INT_MAX-4)\n  ///  MGNR(Sub, [i8 1, 2), OBO::NoSignedWrap) == [-127, 128)\n  ///  MGNR(Sub, [i8 1, 2), OBO::NoUnsignedWrap) == [1, 0)\n  static ConstantRange makeGuaranteedNoWrapRegion(Instruction::BinaryOps BinOp,\n                                                  const ConstantRange &Other,\n                                                  unsigned NoWrapKind);\n\n  /// Produce the range that contains X if and only if \"X BinOp Other\" does\n  /// not wrap.\n  static ConstantRange makeExactNoWrapRegion(Instruction::BinaryOps BinOp,\n                                             const APInt &Other,\n                                             unsigned NoWrapKind);\n\n  /// Returns true if ConstantRange calculations are supported for intrinsic\n  /// with \\p IntrinsicID.\n  static bool isIntrinsicSupported(Intrinsic::ID IntrinsicID);\n\n  /// Compute range of intrinsic result for the given operand ranges.\n  static ConstantRange intrinsic(Intrinsic::ID IntrinsicID,\n                                 ArrayRef<ConstantRange> Ops);\n\n  /// Set up \\p Pred and \\p RHS such that\n  /// ConstantRange::makeExactICmpRegion(Pred, RHS) == *this.  Return true if\n  /// successful.\n  bool getEquivalentICmp(CmpInst::Predicate &Pred, APInt &RHS) const;\n\n  /// Return the lower value for this range.\n  const APInt &getLower() const { return Lower; }\n\n  /// Return the upper value for this range.\n  const APInt &getUpper() const { return Upper; }\n\n  /// Get the bit width of this ConstantRange.\n  uint32_t getBitWidth() const { return Lower.getBitWidth(); }\n\n  /// Return true if this set contains all of the elements possible\n  /// for this data-type.\n  bool isFullSet() const;\n\n  /// Return true if this set contains no members.\n  bool isEmptySet() const;\n\n  /// Return true if this set wraps around the unsigned domain. Special cases:\n  ///  * Empty set: Not wrapped.\n  ///  * Full set: Not wrapped.\n  ///  * [X, 0) == [X, Max]: Not wrapped.\n  bool isWrappedSet() const;\n\n  /// Return true if the exclusive upper bound wraps around the unsigned\n  /// domain. Special cases:\n  ///  * Empty set: Not wrapped.\n  ///  * Full set: Not wrapped.\n  ///  * [X, 0): Wrapped.\n  bool isUpperWrapped() const;\n\n  /// Return true if this set wraps around the signed domain. Special cases:\n  ///  * Empty set: Not wrapped.\n  ///  * Full set: Not wrapped.\n  ///  * [X, SignedMin) == [X, SignedMax]: Not wrapped.\n  bool isSignWrappedSet() const;\n\n  /// Return true if the (exclusive) upper bound wraps around the signed\n  /// domain. Special cases:\n  ///  * Empty set: Not wrapped.\n  ///  * Full set: Not wrapped.\n  ///  * [X, SignedMin): Wrapped.\n  bool isUpperSignWrapped() const;\n\n  /// Return true if the specified value is in the set.\n  bool contains(const APInt &Val) const;\n\n  /// Return true if the other range is a subset of this one.\n  bool contains(const ConstantRange &CR) const;\n\n  /// If this set contains a single element, return it, otherwise return null.\n  const APInt *getSingleElement() const {\n    if (Upper == Lower + 1)\n      return &Lower;\n    return nullptr;\n  }\n\n  /// If this set contains all but a single element, return it, otherwise return\n  /// null.\n  const APInt *getSingleMissingElement() const {\n    if (Lower == Upper + 1)\n      return &Upper;\n    return nullptr;\n  }\n\n  /// Return true if this set contains exactly one member.\n  bool isSingleElement() const { return getSingleElement() != nullptr; }\n\n  /// Compare set size of this range with the range CR.\n  bool isSizeStrictlySmallerThan(const ConstantRange &CR) const;\n\n  /// Compare set size of this range with Value.\n  bool isSizeLargerThan(uint64_t MaxSize) const;\n\n  /// Return true if all values in this range are negative.\n  bool isAllNegative() const;\n\n  /// Return true if all values in this range are non-negative.\n  bool isAllNonNegative() const;\n\n  /// Return the largest unsigned value contained in the ConstantRange.\n  APInt getUnsignedMax() const;\n\n  /// Return the smallest unsigned value contained in the ConstantRange.\n  APInt getUnsignedMin() const;\n\n  /// Return the largest signed value contained in the ConstantRange.\n  APInt getSignedMax() const;\n\n  /// Return the smallest signed value contained in the ConstantRange.\n  APInt getSignedMin() const;\n\n  /// Return true if this range is equal to another range.\n  bool operator==(const ConstantRange &CR) const {\n    return Lower == CR.Lower && Upper == CR.Upper;\n  }\n  bool operator!=(const ConstantRange &CR) const {\n    return !operator==(CR);\n  }\n\n  /// Compute the maximal number of active bits needed to represent every value\n  /// in this range.\n  unsigned getActiveBits() const;\n\n  /// Compute the maximal number of bits needed to represent every value\n  /// in this signed range.\n  unsigned getMinSignedBits() const;\n\n  /// Subtract the specified constant from the endpoints of this constant range.\n  ConstantRange subtract(const APInt &CI) const;\n\n  /// Subtract the specified range from this range (aka relative complement of\n  /// the sets).\n  ConstantRange difference(const ConstantRange &CR) const;\n\n  /// If represented precisely, the result of some range operations may consist\n  /// of multiple disjoint ranges. As only a single range may be returned, any\n  /// range covering these disjoint ranges constitutes a valid result, but some\n  /// may be more useful than others depending on context. The preferred range\n  /// type specifies whether a range that is non-wrapping in the unsigned or\n  /// signed domain, or has the smallest size, is preferred. If a signedness is\n  /// preferred but all ranges are non-wrapping or all wrapping, then the\n  /// smallest set size is preferred. If there are multiple smallest sets, any\n  /// one of them may be returned.\n  enum PreferredRangeType { Smallest, Unsigned, Signed };\n\n  /// Return the range that results from the intersection of this range with\n  /// another range. If the intersection is disjoint, such that two results\n  /// are possible, the preferred range is determined by the PreferredRangeType.\n  ConstantRange intersectWith(const ConstantRange &CR,\n                              PreferredRangeType Type = Smallest) const;\n\n  /// Return the range that results from the union of this range\n  /// with another range.  The resultant range is guaranteed to include the\n  /// elements of both sets, but may contain more.  For example, [3, 9) union\n  /// [12,15) is [3, 15), which includes 9, 10, and 11, which were not included\n  /// in either set before.\n  ConstantRange unionWith(const ConstantRange &CR,\n                          PreferredRangeType Type = Smallest) const;\n\n  /// Return a new range representing the possible values resulting\n  /// from an application of the specified cast operator to this range. \\p\n  /// BitWidth is the target bitwidth of the cast.  For casts which don't\n  /// change bitwidth, it must be the same as the source bitwidth.  For casts\n  /// which do change bitwidth, the bitwidth must be consistent with the\n  /// requested cast and source bitwidth.\n  ConstantRange castOp(Instruction::CastOps CastOp,\n                       uint32_t BitWidth) const;\n\n  /// Return a new range in the specified integer type, which must\n  /// be strictly larger than the current type.  The returned range will\n  /// correspond to the possible range of values if the source range had been\n  /// zero extended to BitWidth.\n  ConstantRange zeroExtend(uint32_t BitWidth) const;\n\n  /// Return a new range in the specified integer type, which must\n  /// be strictly larger than the current type.  The returned range will\n  /// correspond to the possible range of values if the source range had been\n  /// sign extended to BitWidth.\n  ConstantRange signExtend(uint32_t BitWidth) const;\n\n  /// Return a new range in the specified integer type, which must be\n  /// strictly smaller than the current type.  The returned range will\n  /// correspond to the possible range of values if the source range had been\n  /// truncated to the specified type.\n  ConstantRange truncate(uint32_t BitWidth) const;\n\n  /// Make this range have the bit width given by \\p BitWidth. The\n  /// value is zero extended, truncated, or left alone to make it that width.\n  ConstantRange zextOrTrunc(uint32_t BitWidth) const;\n\n  /// Make this range have the bit width given by \\p BitWidth. The\n  /// value is sign extended, truncated, or left alone to make it that width.\n  ConstantRange sextOrTrunc(uint32_t BitWidth) const;\n\n  /// Return a new range representing the possible values resulting\n  /// from an application of the specified binary operator to an left hand side\n  /// of this range and a right hand side of \\p Other.\n  ConstantRange binaryOp(Instruction::BinaryOps BinOp,\n                         const ConstantRange &Other) const;\n\n  /// Return a new range representing the possible values resulting\n  /// from an application of the specified overflowing binary operator to a\n  /// left hand side of this range and a right hand side of \\p Other given\n  /// the provided knowledge about lack of wrapping \\p NoWrapKind.\n  ConstantRange overflowingBinaryOp(Instruction::BinaryOps BinOp,\n                                    const ConstantRange &Other,\n                                    unsigned NoWrapKind) const;\n\n  /// Return a new range representing the possible values resulting\n  /// from an addition of a value in this range and a value in \\p Other.\n  ConstantRange add(const ConstantRange &Other) const;\n\n  /// Return a new range representing the possible values resulting\n  /// from an addition with wrap type \\p NoWrapKind of a value in this\n  /// range and a value in \\p Other.\n  /// If the result range is disjoint, the preferred range is determined by the\n  /// \\p PreferredRangeType.\n  ConstantRange addWithNoWrap(const ConstantRange &Other, unsigned NoWrapKind,\n                              PreferredRangeType RangeType = Smallest) const;\n\n  /// Return a new range representing the possible values resulting\n  /// from a subtraction of a value in this range and a value in \\p Other.\n  ConstantRange sub(const ConstantRange &Other) const;\n\n  /// Return a new range representing the possible values resulting\n  /// from an subtraction with wrap type \\p NoWrapKind of a value in this\n  /// range and a value in \\p Other.\n  /// If the result range is disjoint, the preferred range is determined by the\n  /// \\p PreferredRangeType.\n  ConstantRange subWithNoWrap(const ConstantRange &Other, unsigned NoWrapKind,\n                              PreferredRangeType RangeType = Smallest) const;\n\n  /// Return a new range representing the possible values resulting\n  /// from a multiplication of a value in this range and a value in \\p Other,\n  /// treating both this and \\p Other as unsigned ranges.\n  ConstantRange multiply(const ConstantRange &Other) const;\n\n  /// Return a new range representing the possible values resulting\n  /// from a signed maximum of a value in this range and a value in \\p Other.\n  ConstantRange smax(const ConstantRange &Other) const;\n\n  /// Return a new range representing the possible values resulting\n  /// from an unsigned maximum of a value in this range and a value in \\p Other.\n  ConstantRange umax(const ConstantRange &Other) const;\n\n  /// Return a new range representing the possible values resulting\n  /// from a signed minimum of a value in this range and a value in \\p Other.\n  ConstantRange smin(const ConstantRange &Other) const;\n\n  /// Return a new range representing the possible values resulting\n  /// from an unsigned minimum of a value in this range and a value in \\p Other.\n  ConstantRange umin(const ConstantRange &Other) const;\n\n  /// Return a new range representing the possible values resulting\n  /// from an unsigned division of a value in this range and a value in\n  /// \\p Other.\n  ConstantRange udiv(const ConstantRange &Other) const;\n\n  /// Return a new range representing the possible values resulting\n  /// from a signed division of a value in this range and a value in\n  /// \\p Other. Division by zero and division of SignedMin by -1 are considered\n  /// undefined behavior, in line with IR, and do not contribute towards the\n  /// result.\n  ConstantRange sdiv(const ConstantRange &Other) const;\n\n  /// Return a new range representing the possible values resulting\n  /// from an unsigned remainder operation of a value in this range and a\n  /// value in \\p Other.\n  ConstantRange urem(const ConstantRange &Other) const;\n\n  /// Return a new range representing the possible values resulting\n  /// from a signed remainder operation of a value in this range and a\n  /// value in \\p Other.\n  ConstantRange srem(const ConstantRange &Other) const;\n\n  /// Return a new range representing the possible values resulting from\n  /// a binary-xor of a value in this range by an all-one value,\n  /// aka bitwise complement operation.\n  ConstantRange binaryNot() const;\n\n  /// Return a new range representing the possible values resulting\n  /// from a binary-and of a value in this range by a value in \\p Other.\n  ConstantRange binaryAnd(const ConstantRange &Other) const;\n\n  /// Return a new range representing the possible values resulting\n  /// from a binary-or of a value in this range by a value in \\p Other.\n  ConstantRange binaryOr(const ConstantRange &Other) const;\n\n  /// Return a new range representing the possible values resulting\n  /// from a binary-xor of a value in this range by a value in \\p Other.\n  ConstantRange binaryXor(const ConstantRange &Other) const;\n\n  /// Return a new range representing the possible values resulting\n  /// from a left shift of a value in this range by a value in \\p Other.\n  /// TODO: This isn't fully implemented yet.\n  ConstantRange shl(const ConstantRange &Other) const;\n\n  /// Return a new range representing the possible values resulting from a\n  /// logical right shift of a value in this range and a value in \\p Other.\n  ConstantRange lshr(const ConstantRange &Other) const;\n\n  /// Return a new range representing the possible values resulting from a\n  /// arithmetic right shift of a value in this range and a value in \\p Other.\n  ConstantRange ashr(const ConstantRange &Other) const;\n\n  /// Perform an unsigned saturating addition of two constant ranges.\n  ConstantRange uadd_sat(const ConstantRange &Other) const;\n\n  /// Perform a signed saturating addition of two constant ranges.\n  ConstantRange sadd_sat(const ConstantRange &Other) const;\n\n  /// Perform an unsigned saturating subtraction of two constant ranges.\n  ConstantRange usub_sat(const ConstantRange &Other) const;\n\n  /// Perform a signed saturating subtraction of two constant ranges.\n  ConstantRange ssub_sat(const ConstantRange &Other) const;\n\n  /// Perform an unsigned saturating multiplication of two constant ranges.\n  ConstantRange umul_sat(const ConstantRange &Other) const;\n\n  /// Perform a signed saturating multiplication of two constant ranges.\n  ConstantRange smul_sat(const ConstantRange &Other) const;\n\n  /// Perform an unsigned saturating left shift of this constant range by a\n  /// value in \\p Other.\n  ConstantRange ushl_sat(const ConstantRange &Other) const;\n\n  /// Perform a signed saturating left shift of this constant range by a\n  /// value in \\p Other.\n  ConstantRange sshl_sat(const ConstantRange &Other) const;\n\n  /// Return a new range that is the logical not of the current set.\n  ConstantRange inverse() const;\n\n  /// Calculate absolute value range. If the original range contains signed\n  /// min, then the resulting range will contain signed min if and only if\n  /// \\p IntMinIsPoison is false.\n  ConstantRange abs(bool IntMinIsPoison = false) const;\n\n  /// Represents whether an operation on the given constant range is known to\n  /// always or never overflow.\n  enum class OverflowResult {\n    /// Always overflows in the direction of signed/unsigned min value.\n    AlwaysOverflowsLow,\n    /// Always overflows in the direction of signed/unsigned max value.\n    AlwaysOverflowsHigh,\n    /// May or may not overflow.\n    MayOverflow,\n    /// Never overflows.\n    NeverOverflows,\n  };\n\n  /// Return whether unsigned add of the two ranges always/never overflows.\n  OverflowResult unsignedAddMayOverflow(const ConstantRange &Other) const;\n\n  /// Return whether signed add of the two ranges always/never overflows.\n  OverflowResult signedAddMayOverflow(const ConstantRange &Other) const;\n\n  /// Return whether unsigned sub of the two ranges always/never overflows.\n  OverflowResult unsignedSubMayOverflow(const ConstantRange &Other) const;\n\n  /// Return whether signed sub of the two ranges always/never overflows.\n  OverflowResult signedSubMayOverflow(const ConstantRange &Other) const;\n\n  /// Return whether unsigned mul of the two ranges always/never overflows.\n  OverflowResult unsignedMulMayOverflow(const ConstantRange &Other) const;\n\n  /// Print out the bounds to a stream.\n  void print(raw_ostream &OS) const;\n\n  /// Allow printing from a debugger easily.\n  void dump() const;\n};\n\ninline raw_ostream &operator<<(raw_ostream &OS, const ConstantRange &CR) {\n  CR.print(OS);\n  return OS;\n}\n\n/// Parse out a conservative ConstantRange from !range metadata.\n///\n/// E.g. if RangeMD is !{i32 0, i32 10, i32 15, i32 20} then return [0, 20).\nConstantRange getConstantRangeFromMetadata(const MDNode &RangeMD);\n\n} // end namespace llvm\n\n#endif // LLVM_IR_CONSTANTRANGE_H\n"}, "28": {"id": 28, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/IR/DiagnosticInfo.h", "content": "//===- llvm/IR/DiagnosticInfo.h - Diagnostic Declaration --------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// This file declares the different classes involved in low level diagnostics.\n//\n// Diagnostics reporting is still done as part of the LLVMContext.\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_IR_DIAGNOSTICINFO_H\n#define LLVM_IR_DIAGNOSTICINFO_H\n\n#include \"llvm-c/Types.h\"\n#include \"llvm/ADT/Optional.h\"\n#include \"llvm/ADT/SmallVector.h\"\n#include \"llvm/ADT/StringRef.h\"\n#include \"llvm/ADT/Twine.h\"\n#include \"llvm/IR/DebugLoc.h\"\n#include \"llvm/Support/CBindingWrapping.h\"\n#include \"llvm/Support/TypeSize.h\"\n#include \"llvm/Support/YAMLTraits.h\"\n#include <algorithm>\n#include <cstdint>\n#include <functional>\n#include <iterator>\n#include <string>\n\nnamespace llvm {\n\n// Forward declarations.\nclass DiagnosticPrinter;\nclass Function;\nclass Instruction;\nclass InstructionCost;\nclass LLVMContext;\nclass Module;\nclass SMDiagnostic;\n\n/// Defines the different supported severity of a diagnostic.\nenum DiagnosticSeverity : char {\n  DS_Error,\n  DS_Warning,\n  DS_Remark,\n  // A note attaches additional information to one of the previous diagnostic\n  // types.\n  DS_Note\n};\n\n/// Defines the different supported kind of a diagnostic.\n/// This enum should be extended with a new ID for each added concrete subclass.\nenum DiagnosticKind {\n  DK_InlineAsm,\n  DK_ResourceLimit,\n  DK_StackSize,\n  DK_Linker,\n  DK_Lowering,\n  DK_DebugMetadataVersion,\n  DK_DebugMetadataInvalid,\n  DK_ISelFallback,\n  DK_SampleProfile,\n  DK_OptimizationRemark,\n  DK_OptimizationRemarkMissed,\n  DK_OptimizationRemarkAnalysis,\n  DK_OptimizationRemarkAnalysisFPCommute,\n  DK_OptimizationRemarkAnalysisAliasing,\n  DK_OptimizationFailure,\n  DK_FirstRemark = DK_OptimizationRemark,\n  DK_LastRemark = DK_OptimizationFailure,\n  DK_MachineOptimizationRemark,\n  DK_MachineOptimizationRemarkMissed,\n  DK_MachineOptimizationRemarkAnalysis,\n  DK_FirstMachineRemark = DK_MachineOptimizationRemark,\n  DK_LastMachineRemark = DK_MachineOptimizationRemarkAnalysis,\n  DK_MIRParser,\n  DK_PGOProfile,\n  DK_Unsupported,\n  DK_SrcMgr,\n  DK_FirstPluginKind // Must be last value to work with\n                     // getNextAvailablePluginDiagnosticKind\n};\n\n/// Get the next available kind ID for a plugin diagnostic.\n/// Each time this function is called, it returns a different number.\n/// Therefore, a plugin that wants to \"identify\" its own classes\n/// with a dynamic identifier, just have to use this method to get a new ID\n/// and assign it to each of its classes.\n/// The returned ID will be greater than or equal to DK_FirstPluginKind.\n/// Thus, the plugin identifiers will not conflict with the\n/// DiagnosticKind values.\nint getNextAvailablePluginDiagnosticKind();\n\n/// This is the base abstract class for diagnostic reporting in\n/// the backend.\n/// The print method must be overloaded by the subclasses to print a\n/// user-friendly message in the client of the backend (let us call it a\n/// frontend).\nclass DiagnosticInfo {\nprivate:\n  /// Kind defines the kind of report this is about.\n  const /* DiagnosticKind */ int Kind;\n  /// Severity gives the severity of the diagnostic.\n  const DiagnosticSeverity Severity;\n\n  virtual void anchor();\npublic:\n  DiagnosticInfo(/* DiagnosticKind */ int Kind, DiagnosticSeverity Severity)\n      : Kind(Kind), Severity(Severity) {}\n\n  virtual ~DiagnosticInfo() = default;\n\n  /* DiagnosticKind */ int getKind() const { return Kind; }\n  DiagnosticSeverity getSeverity() const { return Severity; }\n\n  /// Print using the given \\p DP a user-friendly message.\n  /// This is the default message that will be printed to the user.\n  /// It is used when the frontend does not directly take advantage\n  /// of the information contained in fields of the subclasses.\n  /// The printed message must not end with '.' nor start with a severity\n  /// keyword.\n  virtual void print(DiagnosticPrinter &DP) const = 0;\n};\n\nusing DiagnosticHandlerFunction = std::function<void(const DiagnosticInfo &)>;\n\n/// Diagnostic information for inline asm reporting.\n/// This is basically a message and an optional location.\nclass DiagnosticInfoInlineAsm : public DiagnosticInfo {\nprivate:\n  /// Optional line information. 0 if not set.\n  unsigned LocCookie = 0;\n  /// Message to be reported.\n  const Twine &MsgStr;\n  /// Optional origin of the problem.\n  const Instruction *Instr = nullptr;\n\npublic:\n  /// \\p MsgStr is the message to be reported to the frontend.\n  /// This class does not copy \\p MsgStr, therefore the reference must be valid\n  /// for the whole life time of the Diagnostic.\n  DiagnosticInfoInlineAsm(const Twine &MsgStr,\n                          DiagnosticSeverity Severity = DS_Error)\n      : DiagnosticInfo(DK_InlineAsm, Severity), MsgStr(MsgStr) {}\n\n  /// \\p LocCookie if non-zero gives the line number for this report.\n  /// \\p MsgStr gives the message.\n  /// This class does not copy \\p MsgStr, therefore the reference must be valid\n  /// for the whole life time of the Diagnostic.\n  DiagnosticInfoInlineAsm(unsigned LocCookie, const Twine &MsgStr,\n                          DiagnosticSeverity Severity = DS_Error)\n      : DiagnosticInfo(DK_InlineAsm, Severity), LocCookie(LocCookie),\n        MsgStr(MsgStr) {}\n\n  /// \\p Instr gives the original instruction that triggered the diagnostic.\n  /// \\p MsgStr gives the message.\n  /// This class does not copy \\p MsgStr, therefore the reference must be valid\n  /// for the whole life time of the Diagnostic.\n  /// Same for \\p I.\n  DiagnosticInfoInlineAsm(const Instruction &I, const Twine &MsgStr,\n                          DiagnosticSeverity Severity = DS_Error);\n\n  unsigned getLocCookie() const { return LocCookie; }\n  const Twine &getMsgStr() const { return MsgStr; }\n  const Instruction *getInstruction() const { return Instr; }\n\n  /// \\see DiagnosticInfo::print.\n  void print(DiagnosticPrinter &DP) const override;\n\n  static bool classof(const DiagnosticInfo *DI) {\n    return DI->getKind() == DK_InlineAsm;\n  }\n};\n\n/// Diagnostic information for stack size etc. reporting.\n/// This is basically a function and a size.\nclass DiagnosticInfoResourceLimit : public DiagnosticInfo {\nprivate:\n  /// The function that is concerned by this resource limit diagnostic.\n  const Function &Fn;\n\n  /// Description of the resource type (e.g. stack size)\n  const char *ResourceName;\n\n  /// The computed size usage\n  uint64_t ResourceSize;\n\n  // Threshould passed\n  uint64_t ResourceLimit;\n\npublic:\n  /// \\p The function that is concerned by this stack size diagnostic.\n  /// \\p The computed stack size.\n  DiagnosticInfoResourceLimit(const Function &Fn, const char *ResourceName,\n                              uint64_t ResourceSize,\n                              DiagnosticSeverity Severity = DS_Warning,\n                              DiagnosticKind Kind = DK_ResourceLimit,\n                              uint64_t ResourceLimit = 0)\n      : DiagnosticInfo(Kind, Severity), Fn(Fn), ResourceName(ResourceName),\n        ResourceSize(ResourceSize), ResourceLimit(ResourceLimit) {}\n\n  const Function &getFunction() const { return Fn; }\n  const char *getResourceName() const { return ResourceName; }\n  uint64_t getResourceSize() const { return ResourceSize; }\n  uint64_t getResourceLimit() const { return ResourceLimit; }\n\n  /// \\see DiagnosticInfo::print.\n  void print(DiagnosticPrinter &DP) const override;\n\n  static bool classof(const DiagnosticInfo *DI) {\n    return DI->getKind() == DK_ResourceLimit || DI->getKind() == DK_StackSize;\n  }\n};\n\nclass DiagnosticInfoStackSize : public DiagnosticInfoResourceLimit {\n  void anchor() override;\npublic:\n  DiagnosticInfoStackSize(const Function &Fn, uint64_t StackSize,\n                          DiagnosticSeverity Severity = DS_Warning,\n                          uint64_t StackLimit = 0)\n      : DiagnosticInfoResourceLimit(Fn, \"stack size\", StackSize, Severity,\n                                    DK_StackSize, StackLimit) {}\n\n  uint64_t getStackSize() const { return getResourceSize(); }\n  uint64_t getStackLimit() const { return getResourceLimit(); }\n\n  static bool classof(const DiagnosticInfo *DI) {\n    return DI->getKind() == DK_StackSize;\n  }\n};\n\n/// Diagnostic information for debug metadata version reporting.\n/// This is basically a module and a version.\nclass DiagnosticInfoDebugMetadataVersion : public DiagnosticInfo {\nprivate:\n  /// The module that is concerned by this debug metadata version diagnostic.\n  const Module &M;\n  /// The actual metadata version.\n  unsigned MetadataVersion;\n\npublic:\n  /// \\p The module that is concerned by this debug metadata version diagnostic.\n  /// \\p The actual metadata version.\n  DiagnosticInfoDebugMetadataVersion(const Module &M, unsigned MetadataVersion,\n                                     DiagnosticSeverity Severity = DS_Warning)\n      : DiagnosticInfo(DK_DebugMetadataVersion, Severity), M(M),\n        MetadataVersion(MetadataVersion) {}\n\n  const Module &getModule() const { return M; }\n  unsigned getMetadataVersion() const { return MetadataVersion; }\n\n  /// \\see DiagnosticInfo::print.\n  void print(DiagnosticPrinter &DP) const override;\n\n  static bool classof(const DiagnosticInfo *DI) {\n    return DI->getKind() == DK_DebugMetadataVersion;\n  }\n};\n\n/// Diagnostic information for stripping invalid debug metadata.\nclass DiagnosticInfoIgnoringInvalidDebugMetadata : public DiagnosticInfo {\nprivate:\n  /// The module that is concerned by this debug metadata version diagnostic.\n  const Module &M;\n\npublic:\n  /// \\p The module that is concerned by this debug metadata version diagnostic.\n  DiagnosticInfoIgnoringInvalidDebugMetadata(\n      const Module &M, DiagnosticSeverity Severity = DS_Warning)\n      : DiagnosticInfo(DK_DebugMetadataVersion, Severity), M(M) {}\n\n  const Module &getModule() const { return M; }\n\n  /// \\see DiagnosticInfo::print.\n  void print(DiagnosticPrinter &DP) const override;\n\n  static bool classof(const DiagnosticInfo *DI) {\n    return DI->getKind() == DK_DebugMetadataInvalid;\n  }\n};\n\n/// Diagnostic information for the sample profiler.\nclass DiagnosticInfoSampleProfile : public DiagnosticInfo {\npublic:\n  DiagnosticInfoSampleProfile(StringRef FileName, unsigned LineNum,\n                              const Twine &Msg,\n                              DiagnosticSeverity Severity = DS_Error)\n      : DiagnosticInfo(DK_SampleProfile, Severity), FileName(FileName),\n        LineNum(LineNum), Msg(Msg) {}\n  DiagnosticInfoSampleProfile(StringRef FileName, const Twine &Msg,\n                              DiagnosticSeverity Severity = DS_Error)\n      : DiagnosticInfo(DK_SampleProfile, Severity), FileName(FileName),\n        Msg(Msg) {}\n  DiagnosticInfoSampleProfile(const Twine &Msg,\n                              DiagnosticSeverity Severity = DS_Error)\n      : DiagnosticInfo(DK_SampleProfile, Severity), Msg(Msg) {}\n\n  /// \\see DiagnosticInfo::print.\n  void print(DiagnosticPrinter &DP) const override;\n\n  static bool classof(const DiagnosticInfo *DI) {\n    return DI->getKind() == DK_SampleProfile;\n  }\n\n  StringRef getFileName() const { return FileName; }\n  unsigned getLineNum() const { return LineNum; }\n  const Twine &getMsg() const { return Msg; }\n\nprivate:\n  /// Name of the input file associated with this diagnostic.\n  StringRef FileName;\n\n  /// Line number where the diagnostic occurred. If 0, no line number will\n  /// be emitted in the message.\n  unsigned LineNum = 0;\n\n  /// Message to report.\n  const Twine &Msg;\n};\n\n/// Diagnostic information for the PGO profiler.\nclass DiagnosticInfoPGOProfile : public DiagnosticInfo {\npublic:\n  DiagnosticInfoPGOProfile(const char *FileName, const Twine &Msg,\n                           DiagnosticSeverity Severity = DS_Error)\n      : DiagnosticInfo(DK_PGOProfile, Severity), FileName(FileName), Msg(Msg) {}\n\n  /// \\see DiagnosticInfo::print.\n  void print(DiagnosticPrinter &DP) const override;\n\n  static bool classof(const DiagnosticInfo *DI) {\n    return DI->getKind() == DK_PGOProfile;\n  }\n\n  const char *getFileName() const { return FileName; }\n  const Twine &getMsg() const { return Msg; }\n\nprivate:\n  /// Name of the input file associated with this diagnostic.\n  const char *FileName;\n\n  /// Message to report.\n  const Twine &Msg;\n};\n\nclass DiagnosticLocation {\n  DIFile *File = nullptr;\n  unsigned Line = 0;\n  unsigned Column = 0;\n\npublic:\n  DiagnosticLocation() = default;\n  DiagnosticLocation(const DebugLoc &DL);\n  DiagnosticLocation(const DISubprogram *SP);\n\n  bool isValid() const { return File; }\n  /// Return the full path to the file.\n  std::string getAbsolutePath() const;\n  /// Return the file name relative to the compilation directory.\n  StringRef getRelativePath() const;\n  unsigned getLine() const { return Line; }\n  unsigned getColumn() const { return Column; }\n};\n\n/// Common features for diagnostics with an associated location.\nclass DiagnosticInfoWithLocationBase : public DiagnosticInfo {\n  void anchor() override;\npublic:\n  /// \\p Fn is the function where the diagnostic is being emitted. \\p Loc is\n  /// the location information to use in the diagnostic.\n  DiagnosticInfoWithLocationBase(enum DiagnosticKind Kind,\n                                 enum DiagnosticSeverity Severity,\n                                 const Function &Fn,\n                                 const DiagnosticLocation &Loc)\n      : DiagnosticInfo(Kind, Severity), Fn(Fn), Loc(Loc) {}\n\n  /// Return true if location information is available for this diagnostic.\n  bool isLocationAvailable() const { return Loc.isValid(); }\n\n  /// Return a string with the location information for this diagnostic\n  /// in the format \"file:line:col\". If location information is not available,\n  /// it returns \"<unknown>:0:0\".\n  std::string getLocationStr() const;\n\n  /// Return location information for this diagnostic in three parts:\n  /// the relative source file path, line number and column.\n  void getLocation(StringRef &RelativePath, unsigned &Line,\n                   unsigned &Column) const;\n\n  /// Return the absolute path tot the file.\n  std::string getAbsolutePath() const;\n  \n  const Function &getFunction() const { return Fn; }\n  DiagnosticLocation getLocation() const { return Loc; }\n\nprivate:\n  /// Function where this diagnostic is triggered.\n  const Function &Fn;\n\n  /// Debug location where this diagnostic is triggered.\n  DiagnosticLocation Loc;\n};\n\n/// Common features for diagnostics dealing with optimization remarks\n/// that are used by both IR and MIR passes.\nclass DiagnosticInfoOptimizationBase : public DiagnosticInfoWithLocationBase {\npublic:\n  /// Used to set IsVerbose via the stream interface.\n  struct setIsVerbose {};\n\n  /// When an instance of this is inserted into the stream, the arguments\n  /// following will not appear in the remark printed in the compiler output\n  /// (-Rpass) but only in the optimization record file\n  /// (-fsave-optimization-record).\n  struct setExtraArgs {};\n\n  /// Used in the streaming interface as the general argument type.  It\n  /// internally converts everything into a key-value pair.\n  struct Argument {\n    std::string Key;\n    std::string Val;\n    // If set, the debug location corresponding to the value.\n    DiagnosticLocation Loc;\n\n    explicit Argument(StringRef Str = \"\") : Key(\"String\"), Val(Str) {}\n    Argument(StringRef Key, const Value *V);\n    Argument(StringRef Key, const Type *T);\n    Argument(StringRef Key, StringRef S);\n    Argument(StringRef Key, const char *S) : Argument(Key, StringRef(S)) {};\n    Argument(StringRef Key, int N);\n    Argument(StringRef Key, float N);\n    Argument(StringRef Key, long N);\n    Argument(StringRef Key, long long N);\n    Argument(StringRef Key, unsigned N);\n    Argument(StringRef Key, unsigned long N);\n    Argument(StringRef Key, unsigned long long N);\n    Argument(StringRef Key, ElementCount EC);\n    Argument(StringRef Key, bool B) : Key(Key), Val(B ? \"true\" : \"false\") {}\n    Argument(StringRef Key, DebugLoc dl);\n    Argument(StringRef Key, InstructionCost C);\n  };\n\n  /// \\p PassName is the name of the pass emitting this diagnostic. \\p\n  /// RemarkName is a textual identifier for the remark (single-word,\n  /// camel-case). \\p Fn is the function where the diagnostic is being emitted.\n  /// \\p Loc is the location information to use in the diagnostic. If line table\n  /// information is available, the diagnostic will include the source code\n  /// location.\n  DiagnosticInfoOptimizationBase(enum DiagnosticKind Kind,\n                                 enum DiagnosticSeverity Severity,\n                                 const char *PassName, StringRef RemarkName,\n                                 const Function &Fn,\n                                 const DiagnosticLocation &Loc)\n      : DiagnosticInfoWithLocationBase(Kind, Severity, Fn, Loc),\n        PassName(PassName), RemarkName(RemarkName) {}\n\n  void insert(StringRef S);\n  void insert(Argument A);\n  void insert(setIsVerbose V);\n  void insert(setExtraArgs EA);\n\n  /// \\see DiagnosticInfo::print.\n  void print(DiagnosticPrinter &DP) const override;\n\n  /// Return true if this optimization remark is enabled by one of\n  /// of the LLVM command line flags (-pass-remarks, -pass-remarks-missed,\n  /// or -pass-remarks-analysis). Note that this only handles the LLVM\n  /// flags. We cannot access Clang flags from here (they are handled\n  /// in BackendConsumer::OptimizationRemarkHandler).\n  virtual bool isEnabled() const = 0;\n\n  StringRef getPassName() const { return PassName; }\n  StringRef getRemarkName() const { return RemarkName; }\n  std::string getMsg() const;\n  Optional<uint64_t> getHotness() const { return Hotness; }\n  void setHotness(Optional<uint64_t> H) { Hotness = H; }\n\n  bool isVerbose() const { return IsVerbose; }\n\n  ArrayRef<Argument> getArgs() const { return Args; }\n\n  static bool classof(const DiagnosticInfo *DI) {\n    return (DI->getKind() >= DK_FirstRemark &&\n            DI->getKind() <= DK_LastRemark) ||\n           (DI->getKind() >= DK_FirstMachineRemark &&\n            DI->getKind() <= DK_LastMachineRemark);\n  }\n\n  bool isPassed() const {\n    return (getKind() == DK_OptimizationRemark ||\n            getKind() == DK_MachineOptimizationRemark);\n  }\n\n  bool isMissed() const {\n    return (getKind() == DK_OptimizationRemarkMissed ||\n            getKind() == DK_MachineOptimizationRemarkMissed);\n  }\n\n  bool isAnalysis() const {\n    return (getKind() == DK_OptimizationRemarkAnalysis ||\n            getKind() == DK_MachineOptimizationRemarkAnalysis);\n  }\n\nprotected:\n  /// Name of the pass that triggers this report. If this matches the\n  /// regular expression given in -Rpass=regexp, then the remark will\n  /// be emitted.\n  const char *PassName;\n\n  /// Textual identifier for the remark (single-word, camel-case). Can be used\n  /// by external tools reading the output file for optimization remarks to\n  /// identify the remark.\n  StringRef RemarkName;\n\n  /// If profile information is available, this is the number of times the\n  /// corresponding code was executed in a profile instrumentation run.\n  Optional<uint64_t> Hotness;\n\n  /// Arguments collected via the streaming interface.\n  SmallVector<Argument, 4> Args;\n\n  /// The remark is expected to be noisy.\n  bool IsVerbose = false;\n\n  /// If positive, the index of the first argument that only appear in\n  /// the optimization records and not in the remark printed in the compiler\n  /// output.\n  int FirstExtraArgIndex = -1;\n};\n\n/// Allow the insertion operator to return the actual remark type rather than a\n/// common base class.  This allows returning the result of the insertion\n/// directly by value, e.g. return OptimizationRemarkAnalysis(...) << \"blah\".\ntemplate <class RemarkT>\nRemarkT &\noperator<<(RemarkT &R,\n           std::enable_if_t<\n               std::is_base_of<DiagnosticInfoOptimizationBase, RemarkT>::value,\n               StringRef>\n               S) {\n  R.insert(S);\n  return R;\n}\n\n/// Also allow r-value for the remark to allow insertion into a\n/// temporarily-constructed remark.\ntemplate <class RemarkT>\nRemarkT &\noperator<<(RemarkT &&R,\n           std::enable_if_t<\n               std::is_base_of<DiagnosticInfoOptimizationBase, RemarkT>::value,\n               StringRef>\n               S) {\n  R.insert(S);\n  return R;\n}\n\ntemplate <class RemarkT>\nRemarkT &\noperator<<(RemarkT &R,\n           std::enable_if_t<\n               std::is_base_of<DiagnosticInfoOptimizationBase, RemarkT>::value,\n               DiagnosticInfoOptimizationBase::Argument>\n               A) {\n  R.insert(A);\n  return R;\n}\n\ntemplate <class RemarkT>\nRemarkT &\noperator<<(RemarkT &&R,\n           std::enable_if_t<\n               std::is_base_of<DiagnosticInfoOptimizationBase, RemarkT>::value,\n               DiagnosticInfoOptimizationBase::Argument>\n               A) {\n  R.insert(A);\n  return R;\n}\n\ntemplate <class RemarkT>\nRemarkT &\noperator<<(RemarkT &R,\n           std::enable_if_t<\n               std::is_base_of<DiagnosticInfoOptimizationBase, RemarkT>::value,\n               DiagnosticInfoOptimizationBase::setIsVerbose>\n               V) {\n  R.insert(V);\n  return R;\n}\n\ntemplate <class RemarkT>\nRemarkT &\noperator<<(RemarkT &&R,\n           std::enable_if_t<\n               std::is_base_of<DiagnosticInfoOptimizationBase, RemarkT>::value,\n               DiagnosticInfoOptimizationBase::setIsVerbose>\n               V) {\n  R.insert(V);\n  return R;\n}\n\ntemplate <class RemarkT>\nRemarkT &\noperator<<(RemarkT &R,\n           std::enable_if_t<\n               std::is_base_of<DiagnosticInfoOptimizationBase, RemarkT>::value,\n               DiagnosticInfoOptimizationBase::setExtraArgs>\n               EA) {\n  R.insert(EA);\n  return R;\n}\n\n/// Common features for diagnostics dealing with optimization remarks\n/// that are used by IR passes.\nclass DiagnosticInfoIROptimization : public DiagnosticInfoOptimizationBase {\n  void anchor() override;\npublic:\n  /// \\p PassName is the name of the pass emitting this diagnostic. \\p\n  /// RemarkName is a textual identifier for the remark (single-word,\n  /// camel-case). \\p Fn is the function where the diagnostic is being emitted.\n  /// \\p Loc is the location information to use in the diagnostic. If line table\n  /// information is available, the diagnostic will include the source code\n  /// location. \\p CodeRegion is IR value (currently basic block) that the\n  /// optimization operates on. This is currently used to provide run-time\n  /// hotness information with PGO.\n  DiagnosticInfoIROptimization(enum DiagnosticKind Kind,\n                               enum DiagnosticSeverity Severity,\n                               const char *PassName, StringRef RemarkName,\n                               const Function &Fn,\n                               const DiagnosticLocation &Loc,\n                               const Value *CodeRegion = nullptr)\n      : DiagnosticInfoOptimizationBase(Kind, Severity, PassName, RemarkName, Fn,\n                                       Loc),\n        CodeRegion(CodeRegion) {}\n\n  /// This is ctor variant allows a pass to build an optimization remark\n  /// from an existing remark.\n  ///\n  /// This is useful when a transformation pass (e.g LV) wants to emit a remark\n  /// (\\p Orig) generated by one of its analyses (e.g. LAA) as its own analysis\n  /// remark.  The string \\p Prepend will be emitted before the original\n  /// message.\n  DiagnosticInfoIROptimization(const char *PassName, StringRef Prepend,\n                               const DiagnosticInfoIROptimization &Orig)\n      : DiagnosticInfoOptimizationBase(\n            (DiagnosticKind)Orig.getKind(), Orig.getSeverity(), PassName,\n            Orig.RemarkName, Orig.getFunction(), Orig.getLocation()),\n        CodeRegion(Orig.getCodeRegion()) {\n    *this << Prepend;\n    std::copy(Orig.Args.begin(), Orig.Args.end(), std::back_inserter(Args));\n  }\n\n  /// Legacy interface.\n  /// \\p PassName is the name of the pass emitting this diagnostic.\n  /// \\p Fn is the function where the diagnostic is being emitted. \\p Loc is\n  /// the location information to use in the diagnostic. If line table\n  /// information is available, the diagnostic will include the source code\n  /// location. \\p Msg is the message to show. Note that this class does not\n  /// copy this message, so this reference must be valid for the whole life time\n  /// of the diagnostic.\n  DiagnosticInfoIROptimization(enum DiagnosticKind Kind,\n                               enum DiagnosticSeverity Severity,\n                               const char *PassName, const Function &Fn,\n                               const DiagnosticLocation &Loc, const Twine &Msg)\n      : DiagnosticInfoOptimizationBase(Kind, Severity, PassName, \"\", Fn, Loc) {\n    *this << Msg.str();\n  }\n\n  const Value *getCodeRegion() const { return CodeRegion; }\n\n  static bool classof(const DiagnosticInfo *DI) {\n    return DI->getKind() >= DK_FirstRemark && DI->getKind() <= DK_LastRemark;\n  }\n\nprivate:\n  /// The IR value (currently basic block) that the optimization operates on.\n  /// This is currently used to provide run-time hotness information with PGO.\n  const Value *CodeRegion = nullptr;\n};\n\n/// Diagnostic information for applied optimization remarks.\nclass OptimizationRemark : public DiagnosticInfoIROptimization {\npublic:\n  /// \\p PassName is the name of the pass emitting this diagnostic. If this name\n  /// matches the regular expression given in -Rpass=, then the diagnostic will\n  /// be emitted. \\p RemarkName is a textual identifier for the remark (single-\n  /// word, camel-case). \\p Loc is the debug location and \\p CodeRegion is the\n  /// region that the optimization operates on (currently only block is\n  /// supported).\n  OptimizationRemark(const char *PassName, StringRef RemarkName,\n                     const DiagnosticLocation &Loc, const Value *CodeRegion);\n\n  /// Same as above, but the debug location and code region are derived from \\p\n  /// Instr.\n  OptimizationRemark(const char *PassName, StringRef RemarkName,\n                     const Instruction *Inst);\n\n  /// Same as above, but the debug location and code region are derived from \\p\n  /// Func.\n  OptimizationRemark(const char *PassName, StringRef RemarkName,\n                     const Function *Func);\n\n  static bool classof(const DiagnosticInfo *DI) {\n    return DI->getKind() == DK_OptimizationRemark;\n  }\n\n  /// \\see DiagnosticInfoOptimizationBase::isEnabled.\n  bool isEnabled() const override;\n\nprivate:\n  /// This is deprecated now and only used by the function API below.\n  /// \\p PassName is the name of the pass emitting this diagnostic. If\n  /// this name matches the regular expression given in -Rpass=, then the\n  /// diagnostic will be emitted. \\p Fn is the function where the diagnostic\n  /// is being emitted. \\p Loc is the location information to use in the\n  /// diagnostic. If line table information is available, the diagnostic\n  /// will include the source code location. \\p Msg is the message to show.\n  /// Note that this class does not copy this message, so this reference\n  /// must be valid for the whole life time of the diagnostic.\n  OptimizationRemark(const char *PassName, const Function &Fn,\n                     const DiagnosticLocation &Loc, const Twine &Msg)\n      : DiagnosticInfoIROptimization(DK_OptimizationRemark, DS_Remark, PassName,\n                                     Fn, Loc, Msg) {}\n};\n\n/// Diagnostic information for missed-optimization remarks.\nclass OptimizationRemarkMissed : public DiagnosticInfoIROptimization {\npublic:\n  /// \\p PassName is the name of the pass emitting this diagnostic. If this name\n  /// matches the regular expression given in -Rpass-missed=, then the\n  /// diagnostic will be emitted. \\p RemarkName is a textual identifier for the\n  /// remark (single-word, camel-case). \\p Loc is the debug location and \\p\n  /// CodeRegion is the region that the optimization operates on (currently only\n  /// block is supported).\n  OptimizationRemarkMissed(const char *PassName, StringRef RemarkName,\n                           const DiagnosticLocation &Loc,\n                           const Value *CodeRegion);\n\n  /// Same as above but \\p Inst is used to derive code region and debug\n  /// location.\n  OptimizationRemarkMissed(const char *PassName, StringRef RemarkName,\n                           const Instruction *Inst);\n\n  static bool classof(const DiagnosticInfo *DI) {\n    return DI->getKind() == DK_OptimizationRemarkMissed;\n  }\n\n  /// \\see DiagnosticInfoOptimizationBase::isEnabled.\n  bool isEnabled() const override;\n\nprivate:\n  /// This is deprecated now and only used by the function API below.\n  /// \\p PassName is the name of the pass emitting this diagnostic. If\n  /// this name matches the regular expression given in -Rpass-missed=, then the\n  /// diagnostic will be emitted. \\p Fn is the function where the diagnostic\n  /// is being emitted. \\p Loc is the location information to use in the\n  /// diagnostic. If line table information is available, the diagnostic\n  /// will include the source code location. \\p Msg is the message to show.\n  /// Note that this class does not copy this message, so this reference\n  /// must be valid for the whole life time of the diagnostic.\n  OptimizationRemarkMissed(const char *PassName, const Function &Fn,\n                           const DiagnosticLocation &Loc, const Twine &Msg)\n      : DiagnosticInfoIROptimization(DK_OptimizationRemarkMissed, DS_Remark,\n                                     PassName, Fn, Loc, Msg) {}\n};\n\n/// Diagnostic information for optimization analysis remarks.\nclass OptimizationRemarkAnalysis : public DiagnosticInfoIROptimization {\npublic:\n  /// \\p PassName is the name of the pass emitting this diagnostic. If this name\n  /// matches the regular expression given in -Rpass-analysis=, then the\n  /// diagnostic will be emitted. \\p RemarkName is a textual identifier for the\n  /// remark (single-word, camel-case). \\p Loc is the debug location and \\p\n  /// CodeRegion is the region that the optimization operates on (currently only\n  /// block is supported).\n  OptimizationRemarkAnalysis(const char *PassName, StringRef RemarkName,\n                             const DiagnosticLocation &Loc,\n                             const Value *CodeRegion);\n\n  /// This is ctor variant allows a pass to build an optimization remark\n  /// from an existing remark.\n  ///\n  /// This is useful when a transformation pass (e.g LV) wants to emit a remark\n  /// (\\p Orig) generated by one of its analyses (e.g. LAA) as its own analysis\n  /// remark.  The string \\p Prepend will be emitted before the original\n  /// message.\n  OptimizationRemarkAnalysis(const char *PassName, StringRef Prepend,\n                             const OptimizationRemarkAnalysis &Orig)\n      : DiagnosticInfoIROptimization(PassName, Prepend, Orig) {}\n\n  /// Same as above but \\p Inst is used to derive code region and debug\n  /// location.\n  OptimizationRemarkAnalysis(const char *PassName, StringRef RemarkName,\n                             const Instruction *Inst);\n\n  static bool classof(const DiagnosticInfo *DI) {\n    return DI->getKind() == DK_OptimizationRemarkAnalysis;\n  }\n\n  /// \\see DiagnosticInfoOptimizationBase::isEnabled.\n  bool isEnabled() const override;\n\n  static const char *AlwaysPrint;\n\n  bool shouldAlwaysPrint() const { return getPassName() == AlwaysPrint; }\n\nprotected:\n  OptimizationRemarkAnalysis(enum DiagnosticKind Kind, const char *PassName,\n                             const Function &Fn, const DiagnosticLocation &Loc,\n                             const Twine &Msg)\n      : DiagnosticInfoIROptimization(Kind, DS_Remark, PassName, Fn, Loc, Msg) {}\n\n  OptimizationRemarkAnalysis(enum DiagnosticKind Kind, const char *PassName,\n                             StringRef RemarkName,\n                             const DiagnosticLocation &Loc,\n                             const Value *CodeRegion);\n\nprivate:\n  /// This is deprecated now and only used by the function API below.\n  /// \\p PassName is the name of the pass emitting this diagnostic. If\n  /// this name matches the regular expression given in -Rpass-analysis=, then\n  /// the diagnostic will be emitted. \\p Fn is the function where the diagnostic\n  /// is being emitted. \\p Loc is the location information to use in the\n  /// diagnostic. If line table information is available, the diagnostic will\n  /// include the source code location. \\p Msg is the message to show. Note that\n  /// this class does not copy this message, so this reference must be valid for\n  /// the whole life time of the diagnostic.\n  OptimizationRemarkAnalysis(const char *PassName, const Function &Fn,\n                             const DiagnosticLocation &Loc, const Twine &Msg)\n      : DiagnosticInfoIROptimization(DK_OptimizationRemarkAnalysis, DS_Remark,\n                                     PassName, Fn, Loc, Msg) {}\n};\n\n/// Diagnostic information for optimization analysis remarks related to\n/// floating-point non-commutativity.\nclass OptimizationRemarkAnalysisFPCommute : public OptimizationRemarkAnalysis {\n  void anchor() override;\npublic:\n  /// \\p PassName is the name of the pass emitting this diagnostic. If this name\n  /// matches the regular expression given in -Rpass-analysis=, then the\n  /// diagnostic will be emitted. \\p RemarkName is a textual identifier for the\n  /// remark (single-word, camel-case). \\p Loc is the debug location and \\p\n  /// CodeRegion is the region that the optimization operates on (currently only\n  /// block is supported). The front-end will append its own message related to\n  /// options that address floating-point non-commutativity.\n  OptimizationRemarkAnalysisFPCommute(const char *PassName,\n                                      StringRef RemarkName,\n                                      const DiagnosticLocation &Loc,\n                                      const Value *CodeRegion)\n      : OptimizationRemarkAnalysis(DK_OptimizationRemarkAnalysisFPCommute,\n                                   PassName, RemarkName, Loc, CodeRegion) {}\n\n  static bool classof(const DiagnosticInfo *DI) {\n    return DI->getKind() == DK_OptimizationRemarkAnalysisFPCommute;\n  }\n\nprivate:\n  /// This is deprecated now and only used by the function API below.\n  /// \\p PassName is the name of the pass emitting this diagnostic. If\n  /// this name matches the regular expression given in -Rpass-analysis=, then\n  /// the diagnostic will be emitted. \\p Fn is the function where the diagnostic\n  /// is being emitted. \\p Loc is the location information to use in the\n  /// diagnostic. If line table information is available, the diagnostic will\n  /// include the source code location. \\p Msg is the message to show. The\n  /// front-end will append its own message related to options that address\n  /// floating-point non-commutativity. Note that this class does not copy this\n  /// message, so this reference must be valid for the whole life time of the\n  /// diagnostic.\n  OptimizationRemarkAnalysisFPCommute(const char *PassName, const Function &Fn,\n                                      const DiagnosticLocation &Loc,\n                                      const Twine &Msg)\n      : OptimizationRemarkAnalysis(DK_OptimizationRemarkAnalysisFPCommute,\n                                   PassName, Fn, Loc, Msg) {}\n};\n\n/// Diagnostic information for optimization analysis remarks related to\n/// pointer aliasing.\nclass OptimizationRemarkAnalysisAliasing : public OptimizationRemarkAnalysis {\n  void anchor() override;\npublic:\n  /// \\p PassName is the name of the pass emitting this diagnostic. If this name\n  /// matches the regular expression given in -Rpass-analysis=, then the\n  /// diagnostic will be emitted. \\p RemarkName is a textual identifier for the\n  /// remark (single-word, camel-case). \\p Loc is the debug location and \\p\n  /// CodeRegion is the region that the optimization operates on (currently only\n  /// block is supported). The front-end will append its own message related to\n  /// options that address pointer aliasing legality.\n  OptimizationRemarkAnalysisAliasing(const char *PassName, StringRef RemarkName,\n                                     const DiagnosticLocation &Loc,\n                                     const Value *CodeRegion)\n      : OptimizationRemarkAnalysis(DK_OptimizationRemarkAnalysisAliasing,\n                                   PassName, RemarkName, Loc, CodeRegion) {}\n\n  static bool classof(const DiagnosticInfo *DI) {\n    return DI->getKind() == DK_OptimizationRemarkAnalysisAliasing;\n  }\n\nprivate:\n  /// This is deprecated now and only used by the function API below.\n  /// \\p PassName is the name of the pass emitting this diagnostic. If\n  /// this name matches the regular expression given in -Rpass-analysis=, then\n  /// the diagnostic will be emitted. \\p Fn is the function where the diagnostic\n  /// is being emitted. \\p Loc is the location information to use in the\n  /// diagnostic. If line table information is available, the diagnostic will\n  /// include the source code location. \\p Msg is the message to show. The\n  /// front-end will append its own message related to options that address\n  /// pointer aliasing legality. Note that this class does not copy this\n  /// message, so this reference must be valid for the whole life time of the\n  /// diagnostic.\n  OptimizationRemarkAnalysisAliasing(const char *PassName, const Function &Fn,\n                                     const DiagnosticLocation &Loc,\n                                     const Twine &Msg)\n      : OptimizationRemarkAnalysis(DK_OptimizationRemarkAnalysisAliasing,\n                                   PassName, Fn, Loc, Msg) {}\n};\n\n/// Diagnostic information for machine IR parser.\n// FIXME: Remove this, use DiagnosticInfoSrcMgr instead.\nclass DiagnosticInfoMIRParser : public DiagnosticInfo {\n  const SMDiagnostic &Diagnostic;\n\npublic:\n  DiagnosticInfoMIRParser(DiagnosticSeverity Severity,\n                          const SMDiagnostic &Diagnostic)\n      : DiagnosticInfo(DK_MIRParser, Severity), Diagnostic(Diagnostic) {}\n\n  const SMDiagnostic &getDiagnostic() const { return Diagnostic; }\n\n  void print(DiagnosticPrinter &DP) const override;\n\n  static bool classof(const DiagnosticInfo *DI) {\n    return DI->getKind() == DK_MIRParser;\n  }\n};\n\n/// Diagnostic information for ISel fallback path.\nclass DiagnosticInfoISelFallback : public DiagnosticInfo {\n  /// The function that is concerned by this diagnostic.\n  const Function &Fn;\n\npublic:\n  DiagnosticInfoISelFallback(const Function &Fn,\n                             DiagnosticSeverity Severity = DS_Warning)\n      : DiagnosticInfo(DK_ISelFallback, Severity), Fn(Fn) {}\n\n  const Function &getFunction() const { return Fn; }\n\n  void print(DiagnosticPrinter &DP) const override;\n\n  static bool classof(const DiagnosticInfo *DI) {\n    return DI->getKind() == DK_ISelFallback;\n  }\n};\n\n// Create wrappers for C Binding types (see CBindingWrapping.h).\nDEFINE_SIMPLE_CONVERSION_FUNCTIONS(DiagnosticInfo, LLVMDiagnosticInfoRef)\n\n/// Diagnostic information for optimization failures.\nclass DiagnosticInfoOptimizationFailure : public DiagnosticInfoIROptimization {\npublic:\n  /// \\p Fn is the function where the diagnostic is being emitted. \\p Loc is\n  /// the location information to use in the diagnostic. If line table\n  /// information is available, the diagnostic will include the source code\n  /// location. \\p Msg is the message to show. Note that this class does not\n  /// copy this message, so this reference must be valid for the whole life time\n  /// of the diagnostic.\n  DiagnosticInfoOptimizationFailure(const Function &Fn,\n                                    const DiagnosticLocation &Loc,\n                                    const Twine &Msg)\n      : DiagnosticInfoIROptimization(DK_OptimizationFailure, DS_Warning,\n                                     nullptr, Fn, Loc, Msg) {}\n\n  /// \\p PassName is the name of the pass emitting this diagnostic.  \\p\n  /// RemarkName is a textual identifier for the remark (single-word,\n  /// camel-case).  \\p Loc is the debug location and \\p CodeRegion is the\n  /// region that the optimization operates on (currently basic block is\n  /// supported).\n  DiagnosticInfoOptimizationFailure(const char *PassName, StringRef RemarkName,\n                                    const DiagnosticLocation &Loc,\n                                    const Value *CodeRegion);\n\n  static bool classof(const DiagnosticInfo *DI) {\n    return DI->getKind() == DK_OptimizationFailure;\n  }\n\n  /// \\see DiagnosticInfoOptimizationBase::isEnabled.\n  bool isEnabled() const override;\n};\n\n/// Diagnostic information for unsupported feature in backend.\nclass DiagnosticInfoUnsupported : public DiagnosticInfoWithLocationBase {\nprivate:\n  Twine Msg;\n\npublic:\n  /// \\p Fn is the function where the diagnostic is being emitted. \\p Loc is\n  /// the location information to use in the diagnostic. If line table\n  /// information is available, the diagnostic will include the source code\n  /// location. \\p Msg is the message to show. Note that this class does not\n  /// copy this message, so this reference must be valid for the whole life time\n  /// of the diagnostic.\n  DiagnosticInfoUnsupported(\n      const Function &Fn, const Twine &Msg,\n      const DiagnosticLocation &Loc = DiagnosticLocation(),\n      DiagnosticSeverity Severity = DS_Error)\n      : DiagnosticInfoWithLocationBase(DK_Unsupported, Severity, Fn, Loc),\n        Msg(Msg) {}\n\n  static bool classof(const DiagnosticInfo *DI) {\n    return DI->getKind() == DK_Unsupported;\n  }\n\n  const Twine &getMessage() const { return Msg; }\n\n  void print(DiagnosticPrinter &DP) const override;\n};\n\nstatic DiagnosticSeverity getDiagnosticSeverity(SourceMgr::DiagKind DK) {\n  switch (DK) {\n  case llvm::SourceMgr::DK_Error:\n    return DS_Error;\n    break;\n  case llvm::SourceMgr::DK_Warning:\n    return DS_Warning;\n    break;\n  case llvm::SourceMgr::DK_Note:\n    return DS_Note;\n    break;\n  case llvm::SourceMgr::DK_Remark:\n    return DS_Remark;\n    break;\n  }\n  llvm_unreachable(\"unknown SourceMgr::DiagKind\");\n}\n\n/// Diagnostic information for SMDiagnostic reporting.\nclass DiagnosticInfoSrcMgr : public DiagnosticInfo {\n  const SMDiagnostic &Diagnostic;\n\n  // For inlineasm !srcloc translation.\n  bool InlineAsmDiag;\n  unsigned LocCookie;\n\npublic:\n  DiagnosticInfoSrcMgr(const SMDiagnostic &Diagnostic,\n                       bool InlineAsmDiag = true, unsigned LocCookie = 0)\n      : DiagnosticInfo(DK_SrcMgr, getDiagnosticSeverity(Diagnostic.getKind())),\n        Diagnostic(Diagnostic), InlineAsmDiag(InlineAsmDiag),\n        LocCookie(LocCookie) {}\n\n  bool isInlineAsmDiag() const { return InlineAsmDiag; }\n  const SMDiagnostic &getSMDiag() const { return Diagnostic; }\n  unsigned getLocCookie() const { return LocCookie; }\n  void print(DiagnosticPrinter &DP) const override;\n\n  static bool classof(const DiagnosticInfo *DI) {\n    return DI->getKind() == DK_SrcMgr;\n  }\n};\n\n} // end namespace llvm\n\n#endif // LLVM_IR_DIAGNOSTICINFO_H\n"}, "31": {"id": 31, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/IR/InstrTypes.h", "content": "//===- llvm/InstrTypes.h - Important Instruction subclasses -----*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// This file defines various meta classes of instructions that exist in the VM\n// representation.  Specific concrete subclasses of these may be found in the\n// i*.h files...\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_IR_INSTRTYPES_H\n#define LLVM_IR_INSTRTYPES_H\n\n#include \"llvm/ADT/ArrayRef.h\"\n#include \"llvm/ADT/None.h\"\n#include \"llvm/ADT/Optional.h\"\n#include \"llvm/ADT/STLExtras.h\"\n#include \"llvm/ADT/StringMap.h\"\n#include \"llvm/ADT/StringRef.h\"\n#include \"llvm/ADT/Twine.h\"\n#include \"llvm/ADT/iterator_range.h\"\n#include \"llvm/IR/Attributes.h\"\n#include \"llvm/IR/CallingConv.h\"\n#include \"llvm/IR/Constants.h\"\n#include \"llvm/IR/DerivedTypes.h\"\n#include \"llvm/IR/Function.h\"\n#include \"llvm/IR/Instruction.h\"\n#include \"llvm/IR/LLVMContext.h\"\n#include \"llvm/IR/OperandTraits.h\"\n#include \"llvm/IR/Type.h\"\n#include \"llvm/IR/User.h\"\n#include \"llvm/IR/Value.h\"\n#include \"llvm/Support/Casting.h\"\n#include \"llvm/Support/ErrorHandling.h\"\n#include <algorithm>\n#include <cassert>\n#include <cstddef>\n#include <cstdint>\n#include <iterator>\n#include <string>\n#include <vector>\n\nnamespace llvm {\n\nnamespace Intrinsic {\ntypedef unsigned ID;\n}\n\n//===----------------------------------------------------------------------===//\n//                          UnaryInstruction Class\n//===----------------------------------------------------------------------===//\n\nclass UnaryInstruction : public Instruction {\nprotected:\n  UnaryInstruction(Type *Ty, unsigned iType, Value *V,\n                   Instruction *IB = nullptr)\n    : Instruction(Ty, iType, &Op<0>(), 1, IB) {\n    Op<0>() = V;\n  }\n  UnaryInstruction(Type *Ty, unsigned iType, Value *V, BasicBlock *IAE)\n    : Instruction(Ty, iType, &Op<0>(), 1, IAE) {\n    Op<0>() = V;\n  }\n\npublic:\n  // allocate space for exactly one operand\n  void *operator new(size_t s) {\n    return User::operator new(s, 1);\n  }\n\n  /// Transparently provide more efficient getOperand methods.\n  DECLARE_TRANSPARENT_OPERAND_ACCESSORS(Value);\n\n  // Methods for support type inquiry through isa, cast, and dyn_cast:\n  static bool classof(const Instruction *I) {\n    return I->isUnaryOp() ||\n           I->getOpcode() == Instruction::Alloca ||\n           I->getOpcode() == Instruction::Load ||\n           I->getOpcode() == Instruction::VAArg ||\n           I->getOpcode() == Instruction::ExtractValue ||\n           (I->getOpcode() >= CastOpsBegin && I->getOpcode() < CastOpsEnd);\n  }\n  static bool classof(const Value *V) {\n    return isa<Instruction>(V) && classof(cast<Instruction>(V));\n  }\n};\n\ntemplate <>\nstruct OperandTraits<UnaryInstruction> :\n  public FixedNumOperandTraits<UnaryInstruction, 1> {\n};\n\nDEFINE_TRANSPARENT_OPERAND_ACCESSORS(UnaryInstruction, Value)\n\n//===----------------------------------------------------------------------===//\n//                                UnaryOperator Class\n//===----------------------------------------------------------------------===//\n\nclass UnaryOperator : public UnaryInstruction {\n  void AssertOK();\n\nprotected:\n  UnaryOperator(UnaryOps iType, Value *S, Type *Ty,\n                const Twine &Name, Instruction *InsertBefore);\n  UnaryOperator(UnaryOps iType, Value *S, Type *Ty,\n                const Twine &Name, BasicBlock *InsertAtEnd);\n\n  // Note: Instruction needs to be a friend here to call cloneImpl.\n  friend class Instruction;\n\n  UnaryOperator *cloneImpl() const;\n\npublic:\n\n  /// Construct a unary instruction, given the opcode and an operand.\n  /// Optionally (if InstBefore is specified) insert the instruction\n  /// into a BasicBlock right before the specified instruction.  The specified\n  /// Instruction is allowed to be a dereferenced end iterator.\n  ///\n  static UnaryOperator *Create(UnaryOps Op, Value *S,\n                               const Twine &Name = Twine(),\n                               Instruction *InsertBefore = nullptr);\n\n  /// Construct a unary instruction, given the opcode and an operand.\n  /// Also automatically insert this instruction to the end of the\n  /// BasicBlock specified.\n  ///\n  static UnaryOperator *Create(UnaryOps Op, Value *S,\n                               const Twine &Name,\n                               BasicBlock *InsertAtEnd);\n\n  /// These methods just forward to Create, and are useful when you\n  /// statically know what type of instruction you're going to create.  These\n  /// helpers just save some typing.\n#define HANDLE_UNARY_INST(N, OPC, CLASS) \\\n  static UnaryOperator *Create##OPC(Value *V, const Twine &Name = \"\") {\\\n    return Create(Instruction::OPC, V, Name);\\\n  }\n#include \"llvm/IR/Instruction.def\"\n#define HANDLE_UNARY_INST(N, OPC, CLASS) \\\n  static UnaryOperator *Create##OPC(Value *V, const Twine &Name, \\\n                                    BasicBlock *BB) {\\\n    return Create(Instruction::OPC, V, Name, BB);\\\n  }\n#include \"llvm/IR/Instruction.def\"\n#define HANDLE_UNARY_INST(N, OPC, CLASS) \\\n  static UnaryOperator *Create##OPC(Value *V, const Twine &Name, \\\n                                    Instruction *I) {\\\n    return Create(Instruction::OPC, V, Name, I);\\\n  }\n#include \"llvm/IR/Instruction.def\"\n\n  static UnaryOperator *\n  CreateWithCopiedFlags(UnaryOps Opc, Value *V, Instruction *CopyO,\n                        const Twine &Name = \"\",\n                        Instruction *InsertBefore = nullptr) {\n    UnaryOperator *UO = Create(Opc, V, Name, InsertBefore);\n    UO->copyIRFlags(CopyO);\n    return UO;\n  }\n\n  static UnaryOperator *CreateFNegFMF(Value *Op, Instruction *FMFSource,\n                                      const Twine &Name = \"\",\n                                      Instruction *InsertBefore = nullptr) {\n    return CreateWithCopiedFlags(Instruction::FNeg, Op, FMFSource, Name,\n                                 InsertBefore);\n  }\n\n  UnaryOps getOpcode() const {\n    return static_cast<UnaryOps>(Instruction::getOpcode());\n  }\n\n  // Methods for support type inquiry through isa, cast, and dyn_cast:\n  static bool classof(const Instruction *I) {\n    return I->isUnaryOp();\n  }\n  static bool classof(const Value *V) {\n    return isa<Instruction>(V) && classof(cast<Instruction>(V));\n  }\n};\n\n//===----------------------------------------------------------------------===//\n//                           BinaryOperator Class\n//===----------------------------------------------------------------------===//\n\nclass BinaryOperator : public Instruction {\n  void AssertOK();\n\nprotected:\n  BinaryOperator(BinaryOps iType, Value *S1, Value *S2, Type *Ty,\n                 const Twine &Name, Instruction *InsertBefore);\n  BinaryOperator(BinaryOps iType, Value *S1, Value *S2, Type *Ty,\n                 const Twine &Name, BasicBlock *InsertAtEnd);\n\n  // Note: Instruction needs to be a friend here to call cloneImpl.\n  friend class Instruction;\n\n  BinaryOperator *cloneImpl() const;\n\npublic:\n  // allocate space for exactly two operands\n  void *operator new(size_t s) {\n    return User::operator new(s, 2);\n  }\n\n  /// Transparently provide more efficient getOperand methods.\n  DECLARE_TRANSPARENT_OPERAND_ACCESSORS(Value);\n\n  /// Construct a binary instruction, given the opcode and the two\n  /// operands.  Optionally (if InstBefore is specified) insert the instruction\n  /// into a BasicBlock right before the specified instruction.  The specified\n  /// Instruction is allowed to be a dereferenced end iterator.\n  ///\n  static BinaryOperator *Create(BinaryOps Op, Value *S1, Value *S2,\n                                const Twine &Name = Twine(),\n                                Instruction *InsertBefore = nullptr);\n\n  /// Construct a binary instruction, given the opcode and the two\n  /// operands.  Also automatically insert this instruction to the end of the\n  /// BasicBlock specified.\n  ///\n  static BinaryOperator *Create(BinaryOps Op, Value *S1, Value *S2,\n                                const Twine &Name, BasicBlock *InsertAtEnd);\n\n  /// These methods just forward to Create, and are useful when you\n  /// statically know what type of instruction you're going to create.  These\n  /// helpers just save some typing.\n#define HANDLE_BINARY_INST(N, OPC, CLASS) \\\n  static BinaryOperator *Create##OPC(Value *V1, Value *V2, \\\n                                     const Twine &Name = \"\") {\\\n    return Create(Instruction::OPC, V1, V2, Name);\\\n  }\n#include \"llvm/IR/Instruction.def\"\n#define HANDLE_BINARY_INST(N, OPC, CLASS) \\\n  static BinaryOperator *Create##OPC(Value *V1, Value *V2, \\\n                                     const Twine &Name, BasicBlock *BB) {\\\n    return Create(Instruction::OPC, V1, V2, Name, BB);\\\n  }\n#include \"llvm/IR/Instruction.def\"\n#define HANDLE_BINARY_INST(N, OPC, CLASS) \\\n  static BinaryOperator *Create##OPC(Value *V1, Value *V2, \\\n                                     const Twine &Name, Instruction *I) {\\\n    return Create(Instruction::OPC, V1, V2, Name, I);\\\n  }\n#include \"llvm/IR/Instruction.def\"\n\n  static BinaryOperator *CreateWithCopiedFlags(BinaryOps Opc,\n                                               Value *V1, Value *V2,\n                                               Instruction *CopyO,\n                                               const Twine &Name = \"\") {\n    BinaryOperator *BO = Create(Opc, V1, V2, Name);\n    BO->copyIRFlags(CopyO);\n    return BO;\n  }\n\n  static BinaryOperator *CreateFAddFMF(Value *V1, Value *V2,\n                                       Instruction *FMFSource,\n                                       const Twine &Name = \"\") {\n    return CreateWithCopiedFlags(Instruction::FAdd, V1, V2, FMFSource, Name);\n  }\n  static BinaryOperator *CreateFSubFMF(Value *V1, Value *V2,\n                                       Instruction *FMFSource,\n                                       const Twine &Name = \"\") {\n    return CreateWithCopiedFlags(Instruction::FSub, V1, V2, FMFSource, Name);\n  }\n  static BinaryOperator *CreateFMulFMF(Value *V1, Value *V2,\n                                       Instruction *FMFSource,\n                                       const Twine &Name = \"\") {\n    return CreateWithCopiedFlags(Instruction::FMul, V1, V2, FMFSource, Name);\n  }\n  static BinaryOperator *CreateFDivFMF(Value *V1, Value *V2,\n                                       Instruction *FMFSource,\n                                       const Twine &Name = \"\") {\n    return CreateWithCopiedFlags(Instruction::FDiv, V1, V2, FMFSource, Name);\n  }\n  static BinaryOperator *CreateFRemFMF(Value *V1, Value *V2,\n                                       Instruction *FMFSource,\n                                       const Twine &Name = \"\") {\n    return CreateWithCopiedFlags(Instruction::FRem, V1, V2, FMFSource, Name);\n  }\n\n  static BinaryOperator *CreateNSW(BinaryOps Opc, Value *V1, Value *V2,\n                                   const Twine &Name = \"\") {\n    BinaryOperator *BO = Create(Opc, V1, V2, Name);\n    BO->setHasNoSignedWrap(true);\n    return BO;\n  }\n  static BinaryOperator *CreateNSW(BinaryOps Opc, Value *V1, Value *V2,\n                                   const Twine &Name, BasicBlock *BB) {\n    BinaryOperator *BO = Create(Opc, V1, V2, Name, BB);\n    BO->setHasNoSignedWrap(true);\n    return BO;\n  }\n  static BinaryOperator *CreateNSW(BinaryOps Opc, Value *V1, Value *V2,\n                                   const Twine &Name, Instruction *I) {\n    BinaryOperator *BO = Create(Opc, V1, V2, Name, I);\n    BO->setHasNoSignedWrap(true);\n    return BO;\n  }\n\n  static BinaryOperator *CreateNUW(BinaryOps Opc, Value *V1, Value *V2,\n                                   const Twine &Name = \"\") {\n    BinaryOperator *BO = Create(Opc, V1, V2, Name);\n    BO->setHasNoUnsignedWrap(true);\n    return BO;\n  }\n  static BinaryOperator *CreateNUW(BinaryOps Opc, Value *V1, Value *V2,\n                                   const Twine &Name, BasicBlock *BB) {\n    BinaryOperator *BO = Create(Opc, V1, V2, Name, BB);\n    BO->setHasNoUnsignedWrap(true);\n    return BO;\n  }\n  static BinaryOperator *CreateNUW(BinaryOps Opc, Value *V1, Value *V2,\n                                   const Twine &Name, Instruction *I) {\n    BinaryOperator *BO = Create(Opc, V1, V2, Name, I);\n    BO->setHasNoUnsignedWrap(true);\n    return BO;\n  }\n\n  static BinaryOperator *CreateExact(BinaryOps Opc, Value *V1, Value *V2,\n                                     const Twine &Name = \"\") {\n    BinaryOperator *BO = Create(Opc, V1, V2, Name);\n    BO->setIsExact(true);\n    return BO;\n  }\n  static BinaryOperator *CreateExact(BinaryOps Opc, Value *V1, Value *V2,\n                                     const Twine &Name, BasicBlock *BB) {\n    BinaryOperator *BO = Create(Opc, V1, V2, Name, BB);\n    BO->setIsExact(true);\n    return BO;\n  }\n  static BinaryOperator *CreateExact(BinaryOps Opc, Value *V1, Value *V2,\n                                     const Twine &Name, Instruction *I) {\n    BinaryOperator *BO = Create(Opc, V1, V2, Name, I);\n    BO->setIsExact(true);\n    return BO;\n  }\n\n#define DEFINE_HELPERS(OPC, NUWNSWEXACT)                                       \\\n  static BinaryOperator *Create##NUWNSWEXACT##OPC(Value *V1, Value *V2,        \\\n                                                  const Twine &Name = \"\") {    \\\n    return Create##NUWNSWEXACT(Instruction::OPC, V1, V2, Name);                \\\n  }                                                                            \\\n  static BinaryOperator *Create##NUWNSWEXACT##OPC(                             \\\n      Value *V1, Value *V2, const Twine &Name, BasicBlock *BB) {               \\\n    return Create##NUWNSWEXACT(Instruction::OPC, V1, V2, Name, BB);            \\\n  }                                                                            \\\n  static BinaryOperator *Create##NUWNSWEXACT##OPC(                             \\\n      Value *V1, Value *V2, const Twine &Name, Instruction *I) {               \\\n    return Create##NUWNSWEXACT(Instruction::OPC, V1, V2, Name, I);             \\\n  }\n\n  DEFINE_HELPERS(Add, NSW) // CreateNSWAdd\n  DEFINE_HELPERS(Add, NUW) // CreateNUWAdd\n  DEFINE_HELPERS(Sub, NSW) // CreateNSWSub\n  DEFINE_HELPERS(Sub, NUW) // CreateNUWSub\n  DEFINE_HELPERS(Mul, NSW) // CreateNSWMul\n  DEFINE_HELPERS(Mul, NUW) // CreateNUWMul\n  DEFINE_HELPERS(Shl, NSW) // CreateNSWShl\n  DEFINE_HELPERS(Shl, NUW) // CreateNUWShl\n\n  DEFINE_HELPERS(SDiv, Exact)  // CreateExactSDiv\n  DEFINE_HELPERS(UDiv, Exact)  // CreateExactUDiv\n  DEFINE_HELPERS(AShr, Exact)  // CreateExactAShr\n  DEFINE_HELPERS(LShr, Exact)  // CreateExactLShr\n\n#undef DEFINE_HELPERS\n\n  /// Helper functions to construct and inspect unary operations (NEG and NOT)\n  /// via binary operators SUB and XOR:\n  ///\n  /// Create the NEG and NOT instructions out of SUB and XOR instructions.\n  ///\n  static BinaryOperator *CreateNeg(Value *Op, const Twine &Name = \"\",\n                                   Instruction *InsertBefore = nullptr);\n  static BinaryOperator *CreateNeg(Value *Op, const Twine &Name,\n                                   BasicBlock *InsertAtEnd);\n  static BinaryOperator *CreateNSWNeg(Value *Op, const Twine &Name = \"\",\n                                      Instruction *InsertBefore = nullptr);\n  static BinaryOperator *CreateNSWNeg(Value *Op, const Twine &Name,\n                                      BasicBlock *InsertAtEnd);\n  static BinaryOperator *CreateNUWNeg(Value *Op, const Twine &Name = \"\",\n                                      Instruction *InsertBefore = nullptr);\n  static BinaryOperator *CreateNUWNeg(Value *Op, const Twine &Name,\n                                      BasicBlock *InsertAtEnd);\n  static BinaryOperator *CreateNot(Value *Op, const Twine &Name = \"\",\n                                   Instruction *InsertBefore = nullptr);\n  static BinaryOperator *CreateNot(Value *Op, const Twine &Name,\n                                   BasicBlock *InsertAtEnd);\n\n  BinaryOps getOpcode() const {\n    return static_cast<BinaryOps>(Instruction::getOpcode());\n  }\n\n  /// Exchange the two operands to this instruction.\n  /// This instruction is safe to use on any binary instruction and\n  /// does not modify the semantics of the instruction.  If the instruction\n  /// cannot be reversed (ie, it's a Div), then return true.\n  ///\n  bool swapOperands();\n\n  // Methods for support type inquiry through isa, cast, and dyn_cast:\n  static bool classof(const Instruction *I) {\n    return I->isBinaryOp();\n  }\n  static bool classof(const Value *V) {\n    return isa<Instruction>(V) && classof(cast<Instruction>(V));\n  }\n};\n\ntemplate <>\nstruct OperandTraits<BinaryOperator> :\n  public FixedNumOperandTraits<BinaryOperator, 2> {\n};\n\nDEFINE_TRANSPARENT_OPERAND_ACCESSORS(BinaryOperator, Value)\n\n//===----------------------------------------------------------------------===//\n//                               CastInst Class\n//===----------------------------------------------------------------------===//\n\n/// This is the base class for all instructions that perform data\n/// casts. It is simply provided so that instruction category testing\n/// can be performed with code like:\n///\n/// if (isa<CastInst>(Instr)) { ... }\n/// Base class of casting instructions.\nclass CastInst : public UnaryInstruction {\nprotected:\n  /// Constructor with insert-before-instruction semantics for subclasses\n  CastInst(Type *Ty, unsigned iType, Value *S,\n           const Twine &NameStr = \"\", Instruction *InsertBefore = nullptr)\n    : UnaryInstruction(Ty, iType, S, InsertBefore) {\n    setName(NameStr);\n  }\n  /// Constructor with insert-at-end-of-block semantics for subclasses\n  CastInst(Type *Ty, unsigned iType, Value *S,\n           const Twine &NameStr, BasicBlock *InsertAtEnd)\n    : UnaryInstruction(Ty, iType, S, InsertAtEnd) {\n    setName(NameStr);\n  }\n\npublic:\n  /// Provides a way to construct any of the CastInst subclasses using an\n  /// opcode instead of the subclass's constructor. The opcode must be in the\n  /// CastOps category (Instruction::isCast(opcode) returns true). This\n  /// constructor has insert-before-instruction semantics to automatically\n  /// insert the new CastInst before InsertBefore (if it is non-null).\n  /// Construct any of the CastInst subclasses\n  static CastInst *Create(\n    Instruction::CastOps,    ///< The opcode of the cast instruction\n    Value *S,                ///< The value to be casted (operand 0)\n    Type *Ty,          ///< The type to which cast should be made\n    const Twine &Name = \"\", ///< Name for the instruction\n    Instruction *InsertBefore = nullptr ///< Place to insert the instruction\n  );\n  /// Provides a way to construct any of the CastInst subclasses using an\n  /// opcode instead of the subclass's constructor. The opcode must be in the\n  /// CastOps category. This constructor has insert-at-end-of-block semantics\n  /// to automatically insert the new CastInst at the end of InsertAtEnd (if\n  /// its non-null).\n  /// Construct any of the CastInst subclasses\n  static CastInst *Create(\n    Instruction::CastOps,    ///< The opcode for the cast instruction\n    Value *S,                ///< The value to be casted (operand 0)\n    Type *Ty,          ///< The type to which operand is casted\n    const Twine &Name, ///< The name for the instruction\n    BasicBlock *InsertAtEnd  ///< The block to insert the instruction into\n  );\n\n  /// Create a ZExt or BitCast cast instruction\n  static CastInst *CreateZExtOrBitCast(\n    Value *S,                ///< The value to be casted (operand 0)\n    Type *Ty,          ///< The type to which cast should be made\n    const Twine &Name = \"\", ///< Name for the instruction\n    Instruction *InsertBefore = nullptr ///< Place to insert the instruction\n  );\n\n  /// Create a ZExt or BitCast cast instruction\n  static CastInst *CreateZExtOrBitCast(\n    Value *S,                ///< The value to be casted (operand 0)\n    Type *Ty,          ///< The type to which operand is casted\n    const Twine &Name, ///< The name for the instruction\n    BasicBlock *InsertAtEnd  ///< The block to insert the instruction into\n  );\n\n  /// Create a SExt or BitCast cast instruction\n  static CastInst *CreateSExtOrBitCast(\n    Value *S,                ///< The value to be casted (operand 0)\n    Type *Ty,          ///< The type to which cast should be made\n    const Twine &Name = \"\", ///< Name for the instruction\n    Instruction *InsertBefore = nullptr ///< Place to insert the instruction\n  );\n\n  /// Create a SExt or BitCast cast instruction\n  static CastInst *CreateSExtOrBitCast(\n    Value *S,                ///< The value to be casted (operand 0)\n    Type *Ty,          ///< The type to which operand is casted\n    const Twine &Name, ///< The name for the instruction\n    BasicBlock *InsertAtEnd  ///< The block to insert the instruction into\n  );\n\n  /// Create a BitCast AddrSpaceCast, or a PtrToInt cast instruction.\n  static CastInst *CreatePointerCast(\n    Value *S,                ///< The pointer value to be casted (operand 0)\n    Type *Ty,          ///< The type to which operand is casted\n    const Twine &Name, ///< The name for the instruction\n    BasicBlock *InsertAtEnd  ///< The block to insert the instruction into\n  );\n\n  /// Create a BitCast, AddrSpaceCast or a PtrToInt cast instruction.\n  static CastInst *CreatePointerCast(\n    Value *S,                ///< The pointer value to be casted (operand 0)\n    Type *Ty,          ///< The type to which cast should be made\n    const Twine &Name = \"\", ///< Name for the instruction\n    Instruction *InsertBefore = nullptr ///< Place to insert the instruction\n  );\n\n  /// Create a BitCast or an AddrSpaceCast cast instruction.\n  static CastInst *CreatePointerBitCastOrAddrSpaceCast(\n    Value *S,                ///< The pointer value to be casted (operand 0)\n    Type *Ty,          ///< The type to which operand is casted\n    const Twine &Name, ///< The name for the instruction\n    BasicBlock *InsertAtEnd  ///< The block to insert the instruction into\n  );\n\n  /// Create a BitCast or an AddrSpaceCast cast instruction.\n  static CastInst *CreatePointerBitCastOrAddrSpaceCast(\n    Value *S,                ///< The pointer value to be casted (operand 0)\n    Type *Ty,          ///< The type to which cast should be made\n    const Twine &Name = \"\", ///< Name for the instruction\n    Instruction *InsertBefore = nullptr ///< Place to insert the instruction\n  );\n\n  /// Create a BitCast, a PtrToInt, or an IntToPTr cast instruction.\n  ///\n  /// If the value is a pointer type and the destination an integer type,\n  /// creates a PtrToInt cast. If the value is an integer type and the\n  /// destination a pointer type, creates an IntToPtr cast. Otherwise, creates\n  /// a bitcast.\n  static CastInst *CreateBitOrPointerCast(\n    Value *S,                ///< The pointer value to be casted (operand 0)\n    Type *Ty,          ///< The type to which cast should be made\n    const Twine &Name = \"\", ///< Name for the instruction\n    Instruction *InsertBefore = nullptr ///< Place to insert the instruction\n  );\n\n  /// Create a ZExt, BitCast, or Trunc for int -> int casts.\n  static CastInst *CreateIntegerCast(\n    Value *S,                ///< The pointer value to be casted (operand 0)\n    Type *Ty,          ///< The type to which cast should be made\n    bool isSigned,           ///< Whether to regard S as signed or not\n    const Twine &Name = \"\", ///< Name for the instruction\n    Instruction *InsertBefore = nullptr ///< Place to insert the instruction\n  );\n\n  /// Create a ZExt, BitCast, or Trunc for int -> int casts.\n  static CastInst *CreateIntegerCast(\n    Value *S,                ///< The integer value to be casted (operand 0)\n    Type *Ty,          ///< The integer type to which operand is casted\n    bool isSigned,           ///< Whether to regard S as signed or not\n    const Twine &Name, ///< The name for the instruction\n    BasicBlock *InsertAtEnd  ///< The block to insert the instruction into\n  );\n\n  /// Create an FPExt, BitCast, or FPTrunc for fp -> fp casts\n  static CastInst *CreateFPCast(\n    Value *S,                ///< The floating point value to be casted\n    Type *Ty,          ///< The floating point type to cast to\n    const Twine &Name = \"\", ///< Name for the instruction\n    Instruction *InsertBefore = nullptr ///< Place to insert the instruction\n  );\n\n  /// Create an FPExt, BitCast, or FPTrunc for fp -> fp casts\n  static CastInst *CreateFPCast(\n    Value *S,                ///< The floating point value to be casted\n    Type *Ty,          ///< The floating point type to cast to\n    const Twine &Name, ///< The name for the instruction\n    BasicBlock *InsertAtEnd  ///< The block to insert the instruction into\n  );\n\n  /// Create a Trunc or BitCast cast instruction\n  static CastInst *CreateTruncOrBitCast(\n    Value *S,                ///< The value to be casted (operand 0)\n    Type *Ty,          ///< The type to which cast should be made\n    const Twine &Name = \"\", ///< Name for the instruction\n    Instruction *InsertBefore = nullptr ///< Place to insert the instruction\n  );\n\n  /// Create a Trunc or BitCast cast instruction\n  static CastInst *CreateTruncOrBitCast(\n    Value *S,                ///< The value to be casted (operand 0)\n    Type *Ty,          ///< The type to which operand is casted\n    const Twine &Name, ///< The name for the instruction\n    BasicBlock *InsertAtEnd  ///< The block to insert the instruction into\n  );\n\n  /// Check whether a bitcast between these types is valid\n  static bool isBitCastable(\n    Type *SrcTy, ///< The Type from which the value should be cast.\n    Type *DestTy ///< The Type to which the value should be cast.\n  );\n\n  /// Check whether a bitcast, inttoptr, or ptrtoint cast between these\n  /// types is valid and a no-op.\n  ///\n  /// This ensures that any pointer<->integer cast has enough bits in the\n  /// integer and any other cast is a bitcast.\n  static bool isBitOrNoopPointerCastable(\n      Type *SrcTy,  ///< The Type from which the value should be cast.\n      Type *DestTy, ///< The Type to which the value should be cast.\n      const DataLayout &DL);\n\n  /// Returns the opcode necessary to cast Val into Ty using usual casting\n  /// rules.\n  /// Infer the opcode for cast operand and type\n  static Instruction::CastOps getCastOpcode(\n    const Value *Val, ///< The value to cast\n    bool SrcIsSigned, ///< Whether to treat the source as signed\n    Type *Ty,   ///< The Type to which the value should be casted\n    bool DstIsSigned  ///< Whether to treate the dest. as signed\n  );\n\n  /// There are several places where we need to know if a cast instruction\n  /// only deals with integer source and destination types. To simplify that\n  /// logic, this method is provided.\n  /// @returns true iff the cast has only integral typed operand and dest type.\n  /// Determine if this is an integer-only cast.\n  bool isIntegerCast() const;\n\n  /// A lossless cast is one that does not alter the basic value. It implies\n  /// a no-op cast but is more stringent, preventing things like int->float,\n  /// long->double, or int->ptr.\n  /// @returns true iff the cast is lossless.\n  /// Determine if this is a lossless cast.\n  bool isLosslessCast() const;\n\n  /// A no-op cast is one that can be effected without changing any bits.\n  /// It implies that the source and destination types are the same size. The\n  /// DataLayout argument is to determine the pointer size when examining casts\n  /// involving Integer and Pointer types. They are no-op casts if the integer\n  /// is the same size as the pointer. However, pointer size varies with\n  /// platform.  Note that a precondition of this method is that the cast is\n  /// legal - i.e. the instruction formed with these operands would verify.\n  static bool isNoopCast(\n    Instruction::CastOps Opcode, ///< Opcode of cast\n    Type *SrcTy,         ///< SrcTy of cast\n    Type *DstTy,         ///< DstTy of cast\n    const DataLayout &DL ///< DataLayout to get the Int Ptr type from.\n  );\n\n  /// Determine if this cast is a no-op cast.\n  ///\n  /// \\param DL is the DataLayout to determine pointer size.\n  bool isNoopCast(const DataLayout &DL) const;\n\n  /// Determine how a pair of casts can be eliminated, if they can be at all.\n  /// This is a helper function for both CastInst and ConstantExpr.\n  /// @returns 0 if the CastInst pair can't be eliminated, otherwise\n  /// returns Instruction::CastOps value for a cast that can replace\n  /// the pair, casting SrcTy to DstTy.\n  /// Determine if a cast pair is eliminable\n  static unsigned isEliminableCastPair(\n    Instruction::CastOps firstOpcode,  ///< Opcode of first cast\n    Instruction::CastOps secondOpcode, ///< Opcode of second cast\n    Type *SrcTy, ///< SrcTy of 1st cast\n    Type *MidTy, ///< DstTy of 1st cast & SrcTy of 2nd cast\n    Type *DstTy, ///< DstTy of 2nd cast\n    Type *SrcIntPtrTy, ///< Integer type corresponding to Ptr SrcTy, or null\n    Type *MidIntPtrTy, ///< Integer type corresponding to Ptr MidTy, or null\n    Type *DstIntPtrTy  ///< Integer type corresponding to Ptr DstTy, or null\n  );\n\n  /// Return the opcode of this CastInst\n  Instruction::CastOps getOpcode() const {\n    return Instruction::CastOps(Instruction::getOpcode());\n  }\n\n  /// Return the source type, as a convenience\n  Type* getSrcTy() const { return getOperand(0)->getType(); }\n  /// Return the destination type, as a convenience\n  Type* getDestTy() const { return getType(); }\n\n  /// This method can be used to determine if a cast from SrcTy to DstTy using\n  /// Opcode op is valid or not.\n  /// @returns true iff the proposed cast is valid.\n  /// Determine if a cast is valid without creating one.\n  static bool castIsValid(Instruction::CastOps op, Type *SrcTy, Type *DstTy);\n  static bool castIsValid(Instruction::CastOps op, Value *S, Type *DstTy) {\n    return castIsValid(op, S->getType(), DstTy);\n  }\n\n  /// Methods for support type inquiry through isa, cast, and dyn_cast:\n  static bool classof(const Instruction *I) {\n    return I->isCast();\n  }\n  static bool classof(const Value *V) {\n    return isa<Instruction>(V) && classof(cast<Instruction>(V));\n  }\n};\n\n//===----------------------------------------------------------------------===//\n//                               CmpInst Class\n//===----------------------------------------------------------------------===//\n\n/// This class is the base class for the comparison instructions.\n/// Abstract base class of comparison instructions.\nclass CmpInst : public Instruction {\npublic:\n  /// This enumeration lists the possible predicates for CmpInst subclasses.\n  /// Values in the range 0-31 are reserved for FCmpInst, while values in the\n  /// range 32-64 are reserved for ICmpInst. This is necessary to ensure the\n  /// predicate values are not overlapping between the classes.\n  ///\n  /// Some passes (e.g. InstCombine) depend on the bit-wise characteristics of\n  /// FCMP_* values. Changing the bit patterns requires a potential change to\n  /// those passes.\n  enum Predicate : unsigned {\n    // Opcode            U L G E    Intuitive operation\n    FCMP_FALSE = 0, ///< 0 0 0 0    Always false (always folded)\n    FCMP_OEQ = 1,   ///< 0 0 0 1    True if ordered and equal\n    FCMP_OGT = 2,   ///< 0 0 1 0    True if ordered and greater than\n    FCMP_OGE = 3,   ///< 0 0 1 1    True if ordered and greater than or equal\n    FCMP_OLT = 4,   ///< 0 1 0 0    True if ordered and less than\n    FCMP_OLE = 5,   ///< 0 1 0 1    True if ordered and less than or equal\n    FCMP_ONE = 6,   ///< 0 1 1 0    True if ordered and operands are unequal\n    FCMP_ORD = 7,   ///< 0 1 1 1    True if ordered (no nans)\n    FCMP_UNO = 8,   ///< 1 0 0 0    True if unordered: isnan(X) | isnan(Y)\n    FCMP_UEQ = 9,   ///< 1 0 0 1    True if unordered or equal\n    FCMP_UGT = 10,  ///< 1 0 1 0    True if unordered or greater than\n    FCMP_UGE = 11,  ///< 1 0 1 1    True if unordered, greater than, or equal\n    FCMP_ULT = 12,  ///< 1 1 0 0    True if unordered or less than\n    FCMP_ULE = 13,  ///< 1 1 0 1    True if unordered, less than, or equal\n    FCMP_UNE = 14,  ///< 1 1 1 0    True if unordered or not equal\n    FCMP_TRUE = 15, ///< 1 1 1 1    Always true (always folded)\n    FIRST_FCMP_PREDICATE = FCMP_FALSE,\n    LAST_FCMP_PREDICATE = FCMP_TRUE,\n    BAD_FCMP_PREDICATE = FCMP_TRUE + 1,\n    ICMP_EQ = 32,  ///< equal\n    ICMP_NE = 33,  ///< not equal\n    ICMP_UGT = 34, ///< unsigned greater than\n    ICMP_UGE = 35, ///< unsigned greater or equal\n    ICMP_ULT = 36, ///< unsigned less than\n    ICMP_ULE = 37, ///< unsigned less or equal\n    ICMP_SGT = 38, ///< signed greater than\n    ICMP_SGE = 39, ///< signed greater or equal\n    ICMP_SLT = 40, ///< signed less than\n    ICMP_SLE = 41, ///< signed less or equal\n    FIRST_ICMP_PREDICATE = ICMP_EQ,\n    LAST_ICMP_PREDICATE = ICMP_SLE,\n    BAD_ICMP_PREDICATE = ICMP_SLE + 1\n  };\n  using PredicateField =\n      Bitfield::Element<Predicate, 0, 6, LAST_ICMP_PREDICATE>;\n\nprotected:\n  CmpInst(Type *ty, Instruction::OtherOps op, Predicate pred,\n          Value *LHS, Value *RHS, const Twine &Name = \"\",\n          Instruction *InsertBefore = nullptr,\n          Instruction *FlagsSource = nullptr);\n\n  CmpInst(Type *ty, Instruction::OtherOps op, Predicate pred,\n          Value *LHS, Value *RHS, const Twine &Name,\n          BasicBlock *InsertAtEnd);\n\npublic:\n  // allocate space for exactly two operands\n  void *operator new(size_t s) {\n    return User::operator new(s, 2);\n  }\n\n  /// Construct a compare instruction, given the opcode, the predicate and\n  /// the two operands.  Optionally (if InstBefore is specified) insert the\n  /// instruction into a BasicBlock right before the specified instruction.\n  /// The specified Instruction is allowed to be a dereferenced end iterator.\n  /// Create a CmpInst\n  static CmpInst *Create(OtherOps Op,\n                         Predicate predicate, Value *S1,\n                         Value *S2, const Twine &Name = \"\",\n                         Instruction *InsertBefore = nullptr);\n\n  /// Construct a compare instruction, given the opcode, the predicate and the\n  /// two operands.  Also automatically insert this instruction to the end of\n  /// the BasicBlock specified.\n  /// Create a CmpInst\n  static CmpInst *Create(OtherOps Op, Predicate predicate, Value *S1,\n                         Value *S2, const Twine &Name, BasicBlock *InsertAtEnd);\n\n  /// Get the opcode casted to the right type\n  OtherOps getOpcode() const {\n    return static_cast<OtherOps>(Instruction::getOpcode());\n  }\n\n  /// Return the predicate for this instruction.\n  Predicate getPredicate() const { return getSubclassData<PredicateField>(); }\n\n  /// Set the predicate for this instruction to the specified value.\n  void setPredicate(Predicate P) { setSubclassData<PredicateField>(P); }\n\n  static bool isFPPredicate(Predicate P) {\n    static_assert(FIRST_FCMP_PREDICATE == 0,\n                  \"FIRST_FCMP_PREDICATE is required to be 0\");\n    return P <= LAST_FCMP_PREDICATE;\n  }\n\n  static bool isIntPredicate(Predicate P) {\n    return P >= FIRST_ICMP_PREDICATE && P <= LAST_ICMP_PREDICATE;\n  }\n\n  static StringRef getPredicateName(Predicate P);\n\n  bool isFPPredicate() const { return isFPPredicate(getPredicate()); }\n  bool isIntPredicate() const { return isIntPredicate(getPredicate()); }\n\n  /// For example, EQ -> NE, UGT -> ULE, SLT -> SGE,\n  ///              OEQ -> UNE, UGT -> OLE, OLT -> UGE, etc.\n  /// @returns the inverse predicate for the instruction's current predicate.\n  /// Return the inverse of the instruction's predicate.\n  Predicate getInversePredicate() const {\n    return getInversePredicate(getPredicate());\n  }\n\n  /// For example, EQ -> NE, UGT -> ULE, SLT -> SGE,\n  ///              OEQ -> UNE, UGT -> OLE, OLT -> UGE, etc.\n  /// @returns the inverse predicate for predicate provided in \\p pred.\n  /// Return the inverse of a given predicate\n  static Predicate getInversePredicate(Predicate pred);\n\n  /// For example, EQ->EQ, SLE->SGE, ULT->UGT,\n  ///              OEQ->OEQ, ULE->UGE, OLT->OGT, etc.\n  /// @returns the predicate that would be the result of exchanging the two\n  /// operands of the CmpInst instruction without changing the result\n  /// produced.\n  /// Return the predicate as if the operands were swapped\n  Predicate getSwappedPredicate() const {\n    return getSwappedPredicate(getPredicate());\n  }\n\n  /// This is a static version that you can use without an instruction\n  /// available.\n  /// Return the predicate as if the operands were swapped.\n  static Predicate getSwappedPredicate(Predicate pred);\n\n  /// This is a static version that you can use without an instruction\n  /// available.\n  /// @returns true if the comparison predicate is strict, false otherwise.\n  static bool isStrictPredicate(Predicate predicate);\n\n  /// @returns true if the comparison predicate is strict, false otherwise.\n  /// Determine if this instruction is using an strict comparison predicate.\n  bool isStrictPredicate() const { return isStrictPredicate(getPredicate()); }\n\n  /// This is a static version that you can use without an instruction\n  /// available.\n  /// @returns true if the comparison predicate is non-strict, false otherwise.\n  static bool isNonStrictPredicate(Predicate predicate);\n\n  /// @returns true if the comparison predicate is non-strict, false otherwise.\n  /// Determine if this instruction is using an non-strict comparison predicate.\n  bool isNonStrictPredicate() const {\n    return isNonStrictPredicate(getPredicate());\n  }\n\n  /// For example, SGE -> SGT, SLE -> SLT, ULE -> ULT, UGE -> UGT.\n  /// Returns the strict version of non-strict comparisons.\n  Predicate getStrictPredicate() const {\n    return getStrictPredicate(getPredicate());\n  }\n\n  /// This is a static version that you can use without an instruction\n  /// available.\n  /// @returns the strict version of comparison provided in \\p pred.\n  /// If \\p pred is not a strict comparison predicate, returns \\p pred.\n  /// Returns the strict version of non-strict comparisons.\n  static Predicate getStrictPredicate(Predicate pred);\n\n  /// For example, SGT -> SGE, SLT -> SLE, ULT -> ULE, UGT -> UGE.\n  /// Returns the non-strict version of strict comparisons.\n  Predicate getNonStrictPredicate() const {\n    return getNonStrictPredicate(getPredicate());\n  }\n\n  /// This is a static version that you can use without an instruction\n  /// available.\n  /// @returns the non-strict version of comparison provided in \\p pred.\n  /// If \\p pred is not a strict comparison predicate, returns \\p pred.\n  /// Returns the non-strict version of strict comparisons.\n  static Predicate getNonStrictPredicate(Predicate pred);\n\n  /// This is a static version that you can use without an instruction\n  /// available.\n  /// Return the flipped strictness of predicate\n  static Predicate getFlippedStrictnessPredicate(Predicate pred);\n\n  /// For predicate of kind \"is X or equal to 0\" returns the predicate \"is X\".\n  /// For predicate of kind \"is X\" returns the predicate \"is X or equal to 0\".\n  /// does not support other kind of predicates.\n  /// @returns the predicate that does not contains is equal to zero if\n  /// it had and vice versa.\n  /// Return the flipped strictness of predicate\n  Predicate getFlippedStrictnessPredicate() const {\n    return getFlippedStrictnessPredicate(getPredicate());\n  }\n\n  /// Provide more efficient getOperand methods.\n  DECLARE_TRANSPARENT_OPERAND_ACCESSORS(Value);\n\n  /// This is just a convenience that dispatches to the subclasses.\n  /// Swap the operands and adjust predicate accordingly to retain\n  /// the same comparison.\n  void swapOperands();\n\n  /// This is just a convenience that dispatches to the subclasses.\n  /// Determine if this CmpInst is commutative.\n  bool isCommutative() const;\n\n  /// Determine if this is an equals/not equals predicate.\n  /// This is a static version that you can use without an instruction\n  /// available.\n  static bool isEquality(Predicate pred);\n\n  /// Determine if this is an equals/not equals predicate.\n  bool isEquality() const { return isEquality(getPredicate()); }\n\n  /// Return true if the predicate is relational (not EQ or NE).\n  static bool isRelational(Predicate P) { return !isEquality(P); }\n\n  /// Return true if the predicate is relational (not EQ or NE).\n  bool isRelational() const { return !isEquality(); }\n\n  /// @returns true if the comparison is signed, false otherwise.\n  /// Determine if this instruction is using a signed comparison.\n  bool isSigned() const {\n    return isSigned(getPredicate());\n  }\n\n  /// @returns true if the comparison is unsigned, false otherwise.\n  /// Determine if this instruction is using an unsigned comparison.\n  bool isUnsigned() const {\n    return isUnsigned(getPredicate());\n  }\n\n  /// For example, ULT->SLT, ULE->SLE, UGT->SGT, UGE->SGE, SLT->Failed assert\n  /// @returns the signed version of the unsigned predicate pred.\n  /// return the signed version of a predicate\n  static Predicate getSignedPredicate(Predicate pred);\n\n  /// For example, ULT->SLT, ULE->SLE, UGT->SGT, UGE->SGE, SLT->Failed assert\n  /// @returns the signed version of the predicate for this instruction (which\n  /// has to be an unsigned predicate).\n  /// return the signed version of a predicate\n  Predicate getSignedPredicate() {\n    return getSignedPredicate(getPredicate());\n  }\n\n  /// For example, SLT->ULT, SLE->ULE, SGT->UGT, SGE->UGE, ULT->Failed assert\n  /// @returns the unsigned version of the signed predicate pred.\n  static Predicate getUnsignedPredicate(Predicate pred);\n\n  /// For example, SLT->ULT, SLE->ULE, SGT->UGT, SGE->UGE, ULT->Failed assert\n  /// @returns the unsigned version of the predicate for this instruction (which\n  /// has to be an signed predicate).\n  /// return the unsigned version of a predicate\n  Predicate getUnsignedPredicate() {\n    return getUnsignedPredicate(getPredicate());\n  }\n\n  /// For example, SLT->ULT, ULT->SLT, SLE->ULE, ULE->SLE, EQ->Failed assert\n  /// @returns the unsigned version of the signed predicate pred or\n  ///          the signed version of the signed predicate pred.\n  static Predicate getFlippedSignednessPredicate(Predicate pred);\n\n  /// For example, SLT->ULT, ULT->SLT, SLE->ULE, ULE->SLE, EQ->Failed assert\n  /// @returns the unsigned version of the signed predicate pred or\n  ///          the signed version of the signed predicate pred.\n  Predicate getFlippedSignednessPredicate() {\n    return getFlippedSignednessPredicate(getPredicate());\n  }\n\n  /// This is just a convenience.\n  /// Determine if this is true when both operands are the same.\n  bool isTrueWhenEqual() const {\n    return isTrueWhenEqual(getPredicate());\n  }\n\n  /// This is just a convenience.\n  /// Determine if this is false when both operands are the same.\n  bool isFalseWhenEqual() const {\n    return isFalseWhenEqual(getPredicate());\n  }\n\n  /// @returns true if the predicate is unsigned, false otherwise.\n  /// Determine if the predicate is an unsigned operation.\n  static bool isUnsigned(Predicate predicate);\n\n  /// @returns true if the predicate is signed, false otherwise.\n  /// Determine if the predicate is an signed operation.\n  static bool isSigned(Predicate predicate);\n\n  /// Determine if the predicate is an ordered operation.\n  static bool isOrdered(Predicate predicate);\n\n  /// Determine if the predicate is an unordered operation.\n  static bool isUnordered(Predicate predicate);\n\n  /// Determine if the predicate is true when comparing a value with itself.\n  static bool isTrueWhenEqual(Predicate predicate);\n\n  /// Determine if the predicate is false when comparing a value with itself.\n  static bool isFalseWhenEqual(Predicate predicate);\n\n  /// Determine if Pred1 implies Pred2 is true when two compares have matching\n  /// operands.\n  static bool isImpliedTrueByMatchingCmp(Predicate Pred1, Predicate Pred2);\n\n  /// Determine if Pred1 implies Pred2 is false when two compares have matching\n  /// operands.\n  static bool isImpliedFalseByMatchingCmp(Predicate Pred1, Predicate Pred2);\n\n  /// Methods for support type inquiry through isa, cast, and dyn_cast:\n  static bool classof(const Instruction *I) {\n    return I->getOpcode() == Instruction::ICmp ||\n           I->getOpcode() == Instruction::FCmp;\n  }\n  static bool classof(const Value *V) {\n    return isa<Instruction>(V) && classof(cast<Instruction>(V));\n  }\n\n  /// Create a result type for fcmp/icmp\n  static Type* makeCmpResultType(Type* opnd_type) {\n    if (VectorType* vt = dyn_cast<VectorType>(opnd_type)) {\n      return VectorType::get(Type::getInt1Ty(opnd_type->getContext()),\n                             vt->getElementCount());\n    }\n    return Type::getInt1Ty(opnd_type->getContext());\n  }\n\nprivate:\n  // Shadow Value::setValueSubclassData with a private forwarding method so that\n  // subclasses cannot accidentally use it.\n  void setValueSubclassData(unsigned short D) {\n    Value::setValueSubclassData(D);\n  }\n};\n\n// FIXME: these are redundant if CmpInst < BinaryOperator\ntemplate <>\nstruct OperandTraits<CmpInst> : public FixedNumOperandTraits<CmpInst, 2> {\n};\n\nDEFINE_TRANSPARENT_OPERAND_ACCESSORS(CmpInst, Value)\n\n/// A lightweight accessor for an operand bundle meant to be passed\n/// around by value.\nstruct OperandBundleUse {\n  ArrayRef<Use> Inputs;\n\n  OperandBundleUse() = default;\n  explicit OperandBundleUse(StringMapEntry<uint32_t> *Tag, ArrayRef<Use> Inputs)\n      : Inputs(Inputs), Tag(Tag) {}\n\n  /// Return true if the operand at index \\p Idx in this operand bundle\n  /// has the attribute A.\n  bool operandHasAttr(unsigned Idx, Attribute::AttrKind A) const {\n    if (isDeoptOperandBundle())\n      if (A == Attribute::ReadOnly || A == Attribute::NoCapture)\n        return Inputs[Idx]->getType()->isPointerTy();\n\n    // Conservative answer:  no operands have any attributes.\n    return false;\n  }\n\n  /// Return the tag of this operand bundle as a string.\n  StringRef getTagName() const {\n    return Tag->getKey();\n  }\n\n  /// Return the tag of this operand bundle as an integer.\n  ///\n  /// Operand bundle tags are interned by LLVMContextImpl::getOrInsertBundleTag,\n  /// and this function returns the unique integer getOrInsertBundleTag\n  /// associated the tag of this operand bundle to.\n  uint32_t getTagID() const {\n    return Tag->getValue();\n  }\n\n  /// Return true if this is a \"deopt\" operand bundle.\n  bool isDeoptOperandBundle() const {\n    return getTagID() == LLVMContext::OB_deopt;\n  }\n\n  /// Return true if this is a \"funclet\" operand bundle.\n  bool isFuncletOperandBundle() const {\n    return getTagID() == LLVMContext::OB_funclet;\n  }\n\n  /// Return true if this is a \"cfguardtarget\" operand bundle.\n  bool isCFGuardTargetOperandBundle() const {\n    return getTagID() == LLVMContext::OB_cfguardtarget;\n  }\n\nprivate:\n  /// Pointer to an entry in LLVMContextImpl::getOrInsertBundleTag.\n  StringMapEntry<uint32_t> *Tag;\n};\n\n/// A container for an operand bundle being viewed as a set of values\n/// rather than a set of uses.\n///\n/// Unlike OperandBundleUse, OperandBundleDefT owns the memory it carries, and\n/// so it is possible to create and pass around \"self-contained\" instances of\n/// OperandBundleDef and ConstOperandBundleDef.\ntemplate <typename InputTy> class OperandBundleDefT {\n  std::string Tag;\n  std::vector<InputTy> Inputs;\n\npublic:\n  explicit OperandBundleDefT(std::string Tag, std::vector<InputTy> Inputs)\n      : Tag(std::move(Tag)), Inputs(std::move(Inputs)) {}\n  explicit OperandBundleDefT(std::string Tag, ArrayRef<InputTy> Inputs)\n      : Tag(std::move(Tag)), Inputs(Inputs) {}\n\n  explicit OperandBundleDefT(const OperandBundleUse &OBU) {\n    Tag = std::string(OBU.getTagName());\n    llvm::append_range(Inputs, OBU.Inputs);\n  }\n\n  ArrayRef<InputTy> inputs() const { return Inputs; }\n\n  using input_iterator = typename std::vector<InputTy>::const_iterator;\n\n  size_t input_size() const { return Inputs.size(); }\n  input_iterator input_begin() const { return Inputs.begin(); }\n  input_iterator input_end() const { return Inputs.end(); }\n\n  StringRef getTag() const { return Tag; }\n};\n\nusing OperandBundleDef = OperandBundleDefT<Value *>;\nusing ConstOperandBundleDef = OperandBundleDefT<const Value *>;\n\n//===----------------------------------------------------------------------===//\n//                               CallBase Class\n//===----------------------------------------------------------------------===//\n\n/// Base class for all callable instructions (InvokeInst and CallInst)\n/// Holds everything related to calling a function.\n///\n/// All call-like instructions are required to use a common operand layout:\n/// - Zero or more arguments to the call,\n/// - Zero or more operand bundles with zero or more operand inputs each\n///   bundle,\n/// - Zero or more subclass controlled operands\n/// - The called function.\n///\n/// This allows this base class to easily access the called function and the\n/// start of the arguments without knowing how many other operands a particular\n/// subclass requires. Note that accessing the end of the argument list isn't\n/// as cheap as most other operations on the base class.\nclass CallBase : public Instruction {\nprotected:\n  // The first two bits are reserved by CallInst for fast retrieval,\n  using CallInstReservedField = Bitfield::Element<unsigned, 0, 2>;\n  using CallingConvField =\n      Bitfield::Element<CallingConv::ID, CallInstReservedField::NextBit, 10,\n                        CallingConv::MaxID>;\n  static_assert(\n      Bitfield::areContiguous<CallInstReservedField, CallingConvField>(),\n      \"Bitfields must be contiguous\");\n\n  /// The last operand is the called operand.\n  static constexpr int CalledOperandOpEndIdx = -1;\n\n  AttributeList Attrs; ///< parameter attributes for callable\n  FunctionType *FTy;\n\n  template <class... ArgsTy>\n  CallBase(AttributeList const &A, FunctionType *FT, ArgsTy &&... Args)\n      : Instruction(std::forward<ArgsTy>(Args)...), Attrs(A), FTy(FT) {}\n\n  using Instruction::Instruction;\n\n  bool hasDescriptor() const { return Value::HasDescriptor; }\n\n  unsigned getNumSubclassExtraOperands() const {\n    switch (getOpcode()) {\n    case Instruction::Call:\n      return 0;\n    case Instruction::Invoke:\n      return 2;\n    case Instruction::CallBr:\n      return getNumSubclassExtraOperandsDynamic();\n    }\n    llvm_unreachable(\"Invalid opcode!\");\n  }\n\n  /// Get the number of extra operands for instructions that don't have a fixed\n  /// number of extra operands.\n  unsigned getNumSubclassExtraOperandsDynamic() const;\n\npublic:\n  using Instruction::getContext;\n\n  /// Create a clone of \\p CB with a different set of operand bundles and\n  /// insert it before \\p InsertPt.\n  ///\n  /// The returned call instruction is identical \\p CB in every way except that\n  /// the operand bundles for the new instruction are set to the operand bundles\n  /// in \\p Bundles.\n  static CallBase *Create(CallBase *CB, ArrayRef<OperandBundleDef> Bundles,\n                          Instruction *InsertPt = nullptr);\n\n  /// Create a clone of \\p CB with the operand bundle with the tag matching\n  /// \\p Bundle's tag replaced with Bundle, and insert it before \\p InsertPt.\n  ///\n  /// The returned call instruction is identical \\p CI in every way except that\n  /// the specified operand bundle has been replaced.\n  static CallBase *Create(CallBase *CB,\n                          OperandBundleDef Bundle,\n                          Instruction *InsertPt = nullptr);\n\n  /// Create a clone of \\p CB with operand bundle \\p OB added.\n  static CallBase *addOperandBundle(CallBase *CB, uint32_t ID,\n                                    OperandBundleDef OB,\n                                    Instruction *InsertPt = nullptr);\n\n  /// Create a clone of \\p CB with operand bundle \\p ID removed.\n  static CallBase *removeOperandBundle(CallBase *CB, uint32_t ID,\n                                       Instruction *InsertPt = nullptr);\n\n  static bool classof(const Instruction *I) {\n    return I->getOpcode() == Instruction::Call ||\n           I->getOpcode() == Instruction::Invoke ||\n           I->getOpcode() == Instruction::CallBr;\n  }\n  static bool classof(const Value *V) {\n    return isa<Instruction>(V) && classof(cast<Instruction>(V));\n  }\n\n  FunctionType *getFunctionType() const { return FTy; }\n\n  void mutateFunctionType(FunctionType *FTy) {\n    Value::mutateType(FTy->getReturnType());\n    this->FTy = FTy;\n  }\n\n  DECLARE_TRANSPARENT_OPERAND_ACCESSORS(Value);\n\n  /// data_operands_begin/data_operands_end - Return iterators iterating over\n  /// the call / invoke argument list and bundle operands.  For invokes, this is\n  /// the set of instruction operands except the invoke target and the two\n  /// successor blocks; and for calls this is the set of instruction operands\n  /// except the call target.\n  User::op_iterator data_operands_begin() { return op_begin(); }\n  User::const_op_iterator data_operands_begin() const {\n    return const_cast<CallBase *>(this)->data_operands_begin();\n  }\n  User::op_iterator data_operands_end() {\n    // Walk from the end of the operands over the called operand and any\n    // subclass operands.\n    return op_end() - getNumSubclassExtraOperands() - 1;\n  }\n  User::const_op_iterator data_operands_end() const {\n    return const_cast<CallBase *>(this)->data_operands_end();\n  }\n  iterator_range<User::op_iterator> data_ops() {\n    return make_range(data_operands_begin(), data_operands_end());\n  }\n  iterator_range<User::const_op_iterator> data_ops() const {\n    return make_range(data_operands_begin(), data_operands_end());\n  }\n  bool data_operands_empty() const {\n    return data_operands_end() == data_operands_begin();\n  }\n  unsigned data_operands_size() const {\n    return std::distance(data_operands_begin(), data_operands_end());\n  }\n\n  bool isDataOperand(const Use *U) const {\n    assert(this == U->getUser() &&\n           \"Only valid to query with a use of this instruction!\");\n    return data_operands_begin() <= U && U < data_operands_end();\n  }\n  bool isDataOperand(Value::const_user_iterator UI) const {\n    return isDataOperand(&UI.getUse());\n  }\n\n  /// Given a value use iterator, return the data operand corresponding to it.\n  /// Iterator must actually correspond to a data operand.\n  unsigned getDataOperandNo(Value::const_user_iterator UI) const {\n    return getDataOperandNo(&UI.getUse());\n  }\n\n  /// Given a use for a data operand, get the data operand number that\n  /// corresponds to it.\n  unsigned getDataOperandNo(const Use *U) const {\n    assert(isDataOperand(U) && \"Data operand # out of range!\");\n    return U - data_operands_begin();\n  }\n\n  /// Return the iterator pointing to the beginning of the argument list.\n  User::op_iterator arg_begin() { return op_begin(); }\n  User::const_op_iterator arg_begin() const {\n    return const_cast<CallBase *>(this)->arg_begin();\n  }\n\n  /// Return the iterator pointing to the end of the argument list.\n  User::op_iterator arg_end() {\n    // From the end of the data operands, walk backwards past the bundle\n    // operands.\n    return data_operands_end() - getNumTotalBundleOperands();\n  }\n  User::const_op_iterator arg_end() const {\n    return const_cast<CallBase *>(this)->arg_end();\n  }\n\n  /// Iteration adapter for range-for loops.\n  iterator_range<User::op_iterator> args() {\n    return make_range(arg_begin(), arg_end());\n  }\n  iterator_range<User::const_op_iterator> args() const {\n    return make_range(arg_begin(), arg_end());\n  }\n  bool arg_empty() const { return arg_end() == arg_begin(); }\n  unsigned arg_size() const { return arg_end() - arg_begin(); }\n\n  // Legacy API names that duplicate the above and will be removed once users\n  // are migrated.\n  iterator_range<User::op_iterator> arg_operands() {\n    return make_range(arg_begin(), arg_end());\n  }\n  iterator_range<User::const_op_iterator> arg_operands() const {\n    return make_range(arg_begin(), arg_end());\n  }\n  unsigned getNumArgOperands() const { return arg_size(); }\n\n  Value *getArgOperand(unsigned i) const {\n    assert(i < getNumArgOperands() && \"Out of bounds!\");\n    return getOperand(i);\n  }\n\n  void setArgOperand(unsigned i, Value *v) {\n    assert(i < getNumArgOperands() && \"Out of bounds!\");\n    setOperand(i, v);\n  }\n\n  /// Wrappers for getting the \\c Use of a call argument.\n  const Use &getArgOperandUse(unsigned i) const {\n    assert(i < getNumArgOperands() && \"Out of bounds!\");\n    return User::getOperandUse(i);\n  }\n  Use &getArgOperandUse(unsigned i) {\n    assert(i < getNumArgOperands() && \"Out of bounds!\");\n    return User::getOperandUse(i);\n  }\n\n  bool isArgOperand(const Use *U) const {\n    assert(this == U->getUser() &&\n           \"Only valid to query with a use of this instruction!\");\n    return arg_begin() <= U && U < arg_end();\n  }\n  bool isArgOperand(Value::const_user_iterator UI) const {\n    return isArgOperand(&UI.getUse());\n  }\n\n  /// Given a use for a arg operand, get the arg operand number that\n  /// corresponds to it.\n  unsigned getArgOperandNo(const Use *U) const {\n    assert(isArgOperand(U) && \"Arg operand # out of range!\");\n    return U - arg_begin();\n  }\n\n  /// Given a value use iterator, return the arg operand number corresponding to\n  /// it. Iterator must actually correspond to a data operand.\n  unsigned getArgOperandNo(Value::const_user_iterator UI) const {\n    return getArgOperandNo(&UI.getUse());\n  }\n\n  /// Returns true if this CallSite passes the given Value* as an argument to\n  /// the called function.\n  bool hasArgument(const Value *V) const {\n    return llvm::is_contained(args(), V);\n  }\n\n  Value *getCalledOperand() const { return Op<CalledOperandOpEndIdx>(); }\n\n  const Use &getCalledOperandUse() const { return Op<CalledOperandOpEndIdx>(); }\n  Use &getCalledOperandUse() { return Op<CalledOperandOpEndIdx>(); }\n\n  /// Returns the function called, or null if this is an\n  /// indirect function invocation.\n  Function *getCalledFunction() const {\n    return dyn_cast_or_null<Function>(getCalledOperand());\n  }\n\n  /// Return true if the callsite is an indirect call.\n  bool isIndirectCall() const;\n\n  /// Determine whether the passed iterator points to the callee operand's Use.\n  bool isCallee(Value::const_user_iterator UI) const {\n    return isCallee(&UI.getUse());\n  }\n\n  /// Determine whether this Use is the callee operand's Use.\n  bool isCallee(const Use *U) const { return &getCalledOperandUse() == U; }\n\n  /// Helper to get the caller (the parent function).\n  Function *getCaller();\n  const Function *getCaller() const {\n    return const_cast<CallBase *>(this)->getCaller();\n  }\n\n  /// Tests if this call site must be tail call optimized. Only a CallInst can\n  /// be tail call optimized.\n  bool isMustTailCall() const;\n\n  /// Tests if this call site is marked as a tail call.\n  bool isTailCall() const;\n\n  /// Returns the intrinsic ID of the intrinsic called or\n  /// Intrinsic::not_intrinsic if the called function is not an intrinsic, or if\n  /// this is an indirect call.\n  Intrinsic::ID getIntrinsicID() const;\n\n  void setCalledOperand(Value *V) { Op<CalledOperandOpEndIdx>() = V; }\n\n  /// Sets the function called, including updating the function type.\n  void setCalledFunction(Function *Fn) {\n    setCalledFunction(Fn->getFunctionType(), Fn);\n  }\n\n  /// Sets the function called, including updating the function type.\n  void setCalledFunction(FunctionCallee Fn) {\n    setCalledFunction(Fn.getFunctionType(), Fn.getCallee());\n  }\n\n  /// Sets the function called, including updating to the specified function\n  /// type.\n  void setCalledFunction(FunctionType *FTy, Value *Fn) {\n    this->FTy = FTy;\n    assert(FTy == cast<FunctionType>(\n                      cast<PointerType>(Fn->getType())->getElementType()));\n    // This function doesn't mutate the return type, only the function\n    // type. Seems broken, but I'm just gonna stick an assert in for now.\n    assert(getType() == FTy->getReturnType());\n    setCalledOperand(Fn);\n  }\n\n  CallingConv::ID getCallingConv() const {\n    return getSubclassData<CallingConvField>();\n  }\n\n  void setCallingConv(CallingConv::ID CC) {\n    setSubclassData<CallingConvField>(CC);\n  }\n\n  /// Check if this call is an inline asm statement.\n  bool isInlineAsm() const { return isa<InlineAsm>(getCalledOperand()); }\n\n  /// \\name Attribute API\n  ///\n  /// These methods access and modify attributes on this call (including\n  /// looking through to the attributes on the called function when necessary).\n  ///@{\n\n  /// Return the parameter attributes for this call.\n  ///\n  AttributeList getAttributes() const { return Attrs; }\n\n  /// Set the parameter attributes for this call.\n  ///\n  void setAttributes(AttributeList A) { Attrs = A; }\n\n  /// Determine whether this call has the given attribute. If it does not\n  /// then determine if the called function has the attribute, but only if\n  /// the attribute is allowed for the call.\n  bool hasFnAttr(Attribute::AttrKind Kind) const {\n    assert(Kind != Attribute::NoBuiltin &&\n           \"Use CallBase::isNoBuiltin() to check for Attribute::NoBuiltin\");\n    return hasFnAttrImpl(Kind);\n  }\n\n  /// Determine whether this call has the given attribute. If it does not\n  /// then determine if the called function has the attribute, but only if\n  /// the attribute is allowed for the call.\n  bool hasFnAttr(StringRef Kind) const { return hasFnAttrImpl(Kind); }\n\n  /// adds the attribute to the list of attributes.\n  void addAttribute(unsigned i, Attribute::AttrKind Kind) {\n    AttributeList PAL = getAttributes();\n    PAL = PAL.addAttribute(getContext(), i, Kind);\n    setAttributes(PAL);\n  }\n\n  /// adds the attribute to the list of attributes.\n  void addAttribute(unsigned i, Attribute Attr) {\n    AttributeList PAL = getAttributes();\n    PAL = PAL.addAttribute(getContext(), i, Attr);\n    setAttributes(PAL);\n  }\n\n  /// Adds the attribute to the indicated argument\n  void addParamAttr(unsigned ArgNo, Attribute::AttrKind Kind) {\n    assert(ArgNo < getNumArgOperands() && \"Out of bounds\");\n    AttributeList PAL = getAttributes();\n    PAL = PAL.addParamAttribute(getContext(), ArgNo, Kind);\n    setAttributes(PAL);\n  }\n\n  /// Adds the attribute to the indicated argument\n  void addParamAttr(unsigned ArgNo, Attribute Attr) {\n    assert(ArgNo < getNumArgOperands() && \"Out of bounds\");\n    AttributeList PAL = getAttributes();\n    PAL = PAL.addParamAttribute(getContext(), ArgNo, Attr);\n    setAttributes(PAL);\n  }\n\n  /// removes the attribute from the list of attributes.\n  void removeAttribute(unsigned i, Attribute::AttrKind Kind) {\n    AttributeList PAL = getAttributes();\n    PAL = PAL.removeAttribute(getContext(), i, Kind);\n    setAttributes(PAL);\n  }\n\n  /// removes the attribute from the list of attributes.\n  void removeAttribute(unsigned i, StringRef Kind) {\n    AttributeList PAL = getAttributes();\n    PAL = PAL.removeAttribute(getContext(), i, Kind);\n    setAttributes(PAL);\n  }\n\n  void removeAttributes(unsigned i, const AttrBuilder &Attrs) {\n    AttributeList PAL = getAttributes();\n    PAL = PAL.removeAttributes(getContext(), i, Attrs);\n    setAttributes(PAL);\n  }\n\n  /// Removes the attribute from the given argument\n  void removeParamAttr(unsigned ArgNo, Attribute::AttrKind Kind) {\n    assert(ArgNo < getNumArgOperands() && \"Out of bounds\");\n    AttributeList PAL = getAttributes();\n    PAL = PAL.removeParamAttribute(getContext(), ArgNo, Kind);\n    setAttributes(PAL);\n  }\n\n  /// Removes the attribute from the given argument\n  void removeParamAttr(unsigned ArgNo, StringRef Kind) {\n    assert(ArgNo < getNumArgOperands() && \"Out of bounds\");\n    AttributeList PAL = getAttributes();\n    PAL = PAL.removeParamAttribute(getContext(), ArgNo, Kind);\n    setAttributes(PAL);\n  }\n\n  /// adds the dereferenceable attribute to the list of attributes.\n  void addDereferenceableAttr(unsigned i, uint64_t Bytes) {\n    AttributeList PAL = getAttributes();\n    PAL = PAL.addDereferenceableAttr(getContext(), i, Bytes);\n    setAttributes(PAL);\n  }\n\n  /// adds the dereferenceable_or_null attribute to the list of\n  /// attributes.\n  void addDereferenceableOrNullAttr(unsigned i, uint64_t Bytes) {\n    AttributeList PAL = getAttributes();\n    PAL = PAL.addDereferenceableOrNullAttr(getContext(), i, Bytes);\n    setAttributes(PAL);\n  }\n\n  /// Determine whether the return value has the given attribute.\n  bool hasRetAttr(Attribute::AttrKind Kind) const {\n    return hasRetAttrImpl(Kind);\n  }\n  /// Determine whether the return value has the given attribute.\n  bool hasRetAttr(StringRef Kind) const { return hasRetAttrImpl(Kind); }\n\n  /// Determine whether the argument or parameter has the given attribute.\n  bool paramHasAttr(unsigned ArgNo, Attribute::AttrKind Kind) const;\n\n  /// Get the attribute of a given kind at a position.\n  Attribute getAttribute(unsigned i, Attribute::AttrKind Kind) const {\n    return getAttributes().getAttribute(i, Kind);\n  }\n\n  /// Get the attribute of a given kind at a position.\n  Attribute getAttribute(unsigned i, StringRef Kind) const {\n    return getAttributes().getAttribute(i, Kind);\n  }\n\n  /// Get the attribute of a given kind from a given arg\n  Attribute getParamAttr(unsigned ArgNo, Attribute::AttrKind Kind) const {\n    assert(ArgNo < getNumArgOperands() && \"Out of bounds\");\n    return getAttributes().getParamAttr(ArgNo, Kind);\n  }\n\n  /// Get the attribute of a given kind from a given arg\n  Attribute getParamAttr(unsigned ArgNo, StringRef Kind) const {\n    assert(ArgNo < getNumArgOperands() && \"Out of bounds\");\n    return getAttributes().getParamAttr(ArgNo, Kind);\n  }\n\n  /// Return true if the data operand at index \\p i has the attribute \\p\n  /// A.\n  ///\n  /// Data operands include call arguments and values used in operand bundles,\n  /// but does not include the callee operand.  This routine dispatches to the\n  /// underlying AttributeList or the OperandBundleUser as appropriate.\n  ///\n  /// The index \\p i is interpreted as\n  ///\n  ///  \\p i == Attribute::ReturnIndex  -> the return value\n  ///  \\p i in [1, arg_size + 1)  -> argument number (\\p i - 1)\n  ///  \\p i in [arg_size + 1, data_operand_size + 1) -> bundle operand at index\n  ///     (\\p i - 1) in the operand list.\n  bool dataOperandHasImpliedAttr(unsigned i, Attribute::AttrKind Kind) const {\n    // Note that we have to add one because `i` isn't zero-indexed.\n    assert(i < (getNumArgOperands() + getNumTotalBundleOperands() + 1) &&\n           \"Data operand index out of bounds!\");\n\n    // The attribute A can either be directly specified, if the operand in\n    // question is a call argument; or be indirectly implied by the kind of its\n    // containing operand bundle, if the operand is a bundle operand.\n\n    if (i == AttributeList::ReturnIndex)\n      return hasRetAttr(Kind);\n\n    // FIXME: Avoid these i - 1 calculations and update the API to use\n    // zero-based indices.\n    if (i < (getNumArgOperands() + 1))\n      return paramHasAttr(i - 1, Kind);\n\n    assert(hasOperandBundles() && i >= (getBundleOperandsStartIndex() + 1) &&\n           \"Must be either a call argument or an operand bundle!\");\n    return bundleOperandHasAttr(i - 1, Kind);\n  }\n\n  /// Determine whether this data operand is not captured.\n  // FIXME: Once this API is no longer duplicated in `CallSite`, rename this to\n  // better indicate that this may return a conservative answer.\n  bool doesNotCapture(unsigned OpNo) const {\n    return dataOperandHasImpliedAttr(OpNo + 1, Attribute::NoCapture);\n  }\n\n  /// Determine whether this argument is passed by value.\n  bool isByValArgument(unsigned ArgNo) const {\n    return paramHasAttr(ArgNo, Attribute::ByVal);\n  }\n\n  /// Determine whether this argument is passed in an alloca.\n  bool isInAllocaArgument(unsigned ArgNo) const {\n    return paramHasAttr(ArgNo, Attribute::InAlloca);\n  }\n\n  /// Determine whether this argument is passed by value, in an alloca, or is\n  /// preallocated.\n  bool isPassPointeeByValueArgument(unsigned ArgNo) const {\n    return paramHasAttr(ArgNo, Attribute::ByVal) ||\n           paramHasAttr(ArgNo, Attribute::InAlloca) ||\n           paramHasAttr(ArgNo, Attribute::Preallocated);\n  }\n\n  /// Determine whether passing undef to this argument is undefined behavior.\n  /// If passing undef to this argument is UB, passing poison is UB as well\n  /// because poison is more undefined than undef.\n  bool isPassingUndefUB(unsigned ArgNo) const {\n    return paramHasAttr(ArgNo, Attribute::NoUndef) ||\n           // dereferenceable implies noundef.\n           paramHasAttr(ArgNo, Attribute::Dereferenceable) ||\n           // dereferenceable implies noundef, and null is a well-defined value.\n           paramHasAttr(ArgNo, Attribute::DereferenceableOrNull);\n  }\n\n  /// Determine if there are is an inalloca argument. Only the last argument can\n  /// have the inalloca attribute.\n  bool hasInAllocaArgument() const {\n    return !arg_empty() && paramHasAttr(arg_size() - 1, Attribute::InAlloca);\n  }\n\n  // FIXME: Once this API is no longer duplicated in `CallSite`, rename this to\n  // better indicate that this may return a conservative answer.\n  bool doesNotAccessMemory(unsigned OpNo) const {\n    return dataOperandHasImpliedAttr(OpNo + 1, Attribute::ReadNone);\n  }\n\n  // FIXME: Once this API is no longer duplicated in `CallSite`, rename this to\n  // better indicate that this may return a conservative answer.\n  bool onlyReadsMemory(unsigned OpNo) const {\n    return dataOperandHasImpliedAttr(OpNo + 1, Attribute::ReadOnly) ||\n           dataOperandHasImpliedAttr(OpNo + 1, Attribute::ReadNone);\n  }\n\n  // FIXME: Once this API is no longer duplicated in `CallSite`, rename this to\n  // better indicate that this may return a conservative answer.\n  bool doesNotReadMemory(unsigned OpNo) const {\n    return dataOperandHasImpliedAttr(OpNo + 1, Attribute::WriteOnly) ||\n           dataOperandHasImpliedAttr(OpNo + 1, Attribute::ReadNone);\n  }\n\n  LLVM_ATTRIBUTE_DEPRECATED(unsigned getRetAlignment() const,\n                            \"Use getRetAlign() instead\") {\n    if (const auto MA = Attrs.getRetAlignment())\n      return MA->value();\n    return 0;\n  }\n\n  /// Extract the alignment of the return value.\n  MaybeAlign getRetAlign() const { return Attrs.getRetAlignment(); }\n\n  /// Extract the alignment for a call or parameter (0=unknown).\n  LLVM_ATTRIBUTE_DEPRECATED(unsigned getParamAlignment(unsigned ArgNo) const,\n                            \"Use getParamAlign() instead\") {\n    if (const auto MA = Attrs.getParamAlignment(ArgNo))\n      return MA->value();\n    return 0;\n  }\n\n  /// Extract the alignment for a call or parameter (0=unknown).\n  MaybeAlign getParamAlign(unsigned ArgNo) const {\n    return Attrs.getParamAlignment(ArgNo);\n  }\n\n  /// Extract the byval type for a call or parameter.\n  Type *getParamByValType(unsigned ArgNo) const {\n    Type *Ty = Attrs.getParamByValType(ArgNo);\n    return Ty ? Ty : getArgOperand(ArgNo)->getType()->getPointerElementType();\n  }\n\n  /// Extract the preallocated type for a call or parameter.\n  Type *getParamPreallocatedType(unsigned ArgNo) const {\n    Type *Ty = Attrs.getParamPreallocatedType(ArgNo);\n    return Ty ? Ty : getArgOperand(ArgNo)->getType()->getPointerElementType();\n  }\n\n  /// Extract the number of dereferenceable bytes for a call or\n  /// parameter (0=unknown).\n  uint64_t getDereferenceableBytes(unsigned i) const {\n    return Attrs.getDereferenceableBytes(i);\n  }\n\n  /// Extract the number of dereferenceable_or_null bytes for a call or\n  /// parameter (0=unknown).\n  uint64_t getDereferenceableOrNullBytes(unsigned i) const {\n    return Attrs.getDereferenceableOrNullBytes(i);\n  }\n\n  /// Return true if the return value is known to be not null.\n  /// This may be because it has the nonnull attribute, or because at least\n  /// one byte is dereferenceable and the pointer is in addrspace(0).\n  bool isReturnNonNull() const;\n\n  /// Determine if the return value is marked with NoAlias attribute.\n  bool returnDoesNotAlias() const {\n    return Attrs.hasAttribute(AttributeList::ReturnIndex, Attribute::NoAlias);\n  }\n\n  /// If one of the arguments has the 'returned' attribute, returns its\n  /// operand value. Otherwise, return nullptr.\n  Value *getReturnedArgOperand() const;\n\n  /// Return true if the call should not be treated as a call to a\n  /// builtin.\n  bool isNoBuiltin() const {\n    return hasFnAttrImpl(Attribute::NoBuiltin) &&\n           !hasFnAttrImpl(Attribute::Builtin);\n  }\n\n  /// Determine if the call requires strict floating point semantics.\n  bool isStrictFP() const { return hasFnAttr(Attribute::StrictFP); }\n\n  /// Return true if the call should not be inlined.\n  bool isNoInline() const { return hasFnAttr(Attribute::NoInline); }\n  void setIsNoInline() {\n    addAttribute(AttributeList::FunctionIndex, Attribute::NoInline);\n  }\n  /// Determine if the call does not access memory.\n  bool doesNotAccessMemory() const { return hasFnAttr(Attribute::ReadNone); }\n  void setDoesNotAccessMemory() {\n    addAttribute(AttributeList::FunctionIndex, Attribute::ReadNone);\n  }\n\n  /// Determine if the call does not access or only reads memory.\n  bool onlyReadsMemory() const {\n    return doesNotAccessMemory() || hasFnAttr(Attribute::ReadOnly);\n  }\n\n  void setOnlyReadsMemory() {\n    addAttribute(AttributeList::FunctionIndex, Attribute::ReadOnly);\n  }\n\n  /// Determine if the call does not access or only writes memory.\n  bool doesNotReadMemory() const {\n    return doesNotAccessMemory() || hasFnAttr(Attribute::WriteOnly);\n  }\n  void setDoesNotReadMemory() {\n    addAttribute(AttributeList::FunctionIndex, Attribute::WriteOnly);\n  }\n\n  /// Determine if the call can access memmory only using pointers based\n  /// on its arguments.\n  bool onlyAccessesArgMemory() const {\n    return hasFnAttr(Attribute::ArgMemOnly);\n  }\n  void setOnlyAccessesArgMemory() {\n    addAttribute(AttributeList::FunctionIndex, Attribute::ArgMemOnly);\n  }\n\n  /// Determine if the function may only access memory that is\n  /// inaccessible from the IR.\n  bool onlyAccessesInaccessibleMemory() const {\n    return hasFnAttr(Attribute::InaccessibleMemOnly);\n  }\n  void setOnlyAccessesInaccessibleMemory() {\n    addAttribute(AttributeList::FunctionIndex, Attribute::InaccessibleMemOnly);\n  }\n\n  /// Determine if the function may only access memory that is\n  /// either inaccessible from the IR or pointed to by its arguments.\n  bool onlyAccessesInaccessibleMemOrArgMem() const {\n    return hasFnAttr(Attribute::InaccessibleMemOrArgMemOnly);\n  }\n  void setOnlyAccessesInaccessibleMemOrArgMem() {\n    addAttribute(AttributeList::FunctionIndex,\n                 Attribute::InaccessibleMemOrArgMemOnly);\n  }\n  /// Determine if the call cannot return.\n  bool doesNotReturn() const { return hasFnAttr(Attribute::NoReturn); }\n  void setDoesNotReturn() {\n    addAttribute(AttributeList::FunctionIndex, Attribute::NoReturn);\n  }\n\n  /// Determine if the call should not perform indirect branch tracking.\n  bool doesNoCfCheck() const { return hasFnAttr(Attribute::NoCfCheck); }\n\n  /// Determine if the call cannot unwind.\n  bool doesNotThrow() const { return hasFnAttr(Attribute::NoUnwind); }\n  void setDoesNotThrow() {\n    addAttribute(AttributeList::FunctionIndex, Attribute::NoUnwind);\n  }\n\n  /// Determine if the invoke cannot be duplicated.\n  bool cannotDuplicate() const { return hasFnAttr(Attribute::NoDuplicate); }\n  void setCannotDuplicate() {\n    addAttribute(AttributeList::FunctionIndex, Attribute::NoDuplicate);\n  }\n\n  /// Determine if the call cannot be tail merged.\n  bool cannotMerge() const { return hasFnAttr(Attribute::NoMerge); }\n  void setCannotMerge() {\n    addAttribute(AttributeList::FunctionIndex, Attribute::NoMerge);\n  }\n\n  /// Determine if the invoke is convergent\n  bool isConvergent() const { return hasFnAttr(Attribute::Convergent); }\n  void setConvergent() {\n    addAttribute(AttributeList::FunctionIndex, Attribute::Convergent);\n  }\n  void setNotConvergent() {\n    removeAttribute(AttributeList::FunctionIndex, Attribute::Convergent);\n  }\n\n  /// Determine if the call returns a structure through first\n  /// pointer argument.\n  bool hasStructRetAttr() const {\n    if (getNumArgOperands() == 0)\n      return false;\n\n    // Be friendly and also check the callee.\n    return paramHasAttr(0, Attribute::StructRet);\n  }\n\n  /// Determine if any call argument is an aggregate passed by value.\n  bool hasByValArgument() const {\n    return Attrs.hasAttrSomewhere(Attribute::ByVal);\n  }\n\n  ///@{\n  // End of attribute API.\n\n  /// \\name Operand Bundle API\n  ///\n  /// This group of methods provides the API to access and manipulate operand\n  /// bundles on this call.\n  /// @{\n\n  /// Return the number of operand bundles associated with this User.\n  unsigned getNumOperandBundles() const {\n    return std::distance(bundle_op_info_begin(), bundle_op_info_end());\n  }\n\n  /// Return true if this User has any operand bundles.\n  bool hasOperandBundles() const { return getNumOperandBundles() != 0; }\n\n  /// Return the index of the first bundle operand in the Use array.\n  unsigned getBundleOperandsStartIndex() const {\n    assert(hasOperandBundles() && \"Don't call otherwise!\");\n    return bundle_op_info_begin()->Begin;\n  }\n\n  /// Return the index of the last bundle operand in the Use array.\n  unsigned getBundleOperandsEndIndex() const {\n    assert(hasOperandBundles() && \"Don't call otherwise!\");\n    return bundle_op_info_end()[-1].End;\n  }\n\n  /// Return true if the operand at index \\p Idx is a bundle operand.\n  bool isBundleOperand(unsigned Idx) const {\n    return hasOperandBundles() && Idx >= getBundleOperandsStartIndex() &&\n           Idx < getBundleOperandsEndIndex();\n  }\n\n  /// Returns true if the use is a bundle operand.\n  bool isBundleOperand(const Use *U) const {\n    assert(this == U->getUser() &&\n           \"Only valid to query with a use of this instruction!\");\n    return hasOperandBundles() && isBundleOperand(U - op_begin());\n  }\n  bool isBundleOperand(Value::const_user_iterator UI) const {\n    return isBundleOperand(&UI.getUse());\n  }\n\n  /// Return the total number operands (not operand bundles) used by\n  /// every operand bundle in this OperandBundleUser.\n  unsigned getNumTotalBundleOperands() const {\n    if (!hasOperandBundles())\n      return 0;\n\n    unsigned Begin = getBundleOperandsStartIndex();\n    unsigned End = getBundleOperandsEndIndex();\n\n    assert(Begin <= End && \"Should be!\");\n    return End - Begin;\n  }\n\n  /// Return the operand bundle at a specific index.\n  OperandBundleUse getOperandBundleAt(unsigned Index) const {\n    assert(Index < getNumOperandBundles() && \"Index out of bounds!\");\n    return operandBundleFromBundleOpInfo(*(bundle_op_info_begin() + Index));\n  }\n\n  /// Return the number of operand bundles with the tag Name attached to\n  /// this instruction.\n  unsigned countOperandBundlesOfType(StringRef Name) const {\n    unsigned Count = 0;\n    for (unsigned i = 0, e = getNumOperandBundles(); i != e; ++i)\n      if (getOperandBundleAt(i).getTagName() == Name)\n        Count++;\n\n    return Count;\n  }\n\n  /// Return the number of operand bundles with the tag ID attached to\n  /// this instruction.\n  unsigned countOperandBundlesOfType(uint32_t ID) const {\n    unsigned Count = 0;\n    for (unsigned i = 0, e = getNumOperandBundles(); i != e; ++i)\n      if (getOperandBundleAt(i).getTagID() == ID)\n        Count++;\n\n    return Count;\n  }\n\n  /// Return an operand bundle by name, if present.\n  ///\n  /// It is an error to call this for operand bundle types that may have\n  /// multiple instances of them on the same instruction.\n  Optional<OperandBundleUse> getOperandBundle(StringRef Name) const {\n    assert(countOperandBundlesOfType(Name) < 2 && \"Precondition violated!\");\n\n    for (unsigned i = 0, e = getNumOperandBundles(); i != e; ++i) {\n      OperandBundleUse U = getOperandBundleAt(i);\n      if (U.getTagName() == Name)\n        return U;\n    }\n\n    return None;\n  }\n\n  /// Return an operand bundle by tag ID, if present.\n  ///\n  /// It is an error to call this for operand bundle types that may have\n  /// multiple instances of them on the same instruction.\n  Optional<OperandBundleUse> getOperandBundle(uint32_t ID) const {\n    assert(countOperandBundlesOfType(ID) < 2 && \"Precondition violated!\");\n\n    for (unsigned i = 0, e = getNumOperandBundles(); i != e; ++i) {\n      OperandBundleUse U = getOperandBundleAt(i);\n      if (U.getTagID() == ID)\n        return U;\n    }\n\n    return None;\n  }\n\n  /// Return the list of operand bundles attached to this instruction as\n  /// a vector of OperandBundleDefs.\n  ///\n  /// This function copies the OperandBundeUse instances associated with this\n  /// OperandBundleUser to a vector of OperandBundleDefs.  Note:\n  /// OperandBundeUses and OperandBundleDefs are non-trivially *different*\n  /// representations of operand bundles (see documentation above).\n  void getOperandBundlesAsDefs(SmallVectorImpl<OperandBundleDef> &Defs) const;\n\n  /// Return the operand bundle for the operand at index OpIdx.\n  ///\n  /// It is an error to call this with an OpIdx that does not correspond to an\n  /// bundle operand.\n  OperandBundleUse getOperandBundleForOperand(unsigned OpIdx) const {\n    return operandBundleFromBundleOpInfo(getBundleOpInfoForOperand(OpIdx));\n  }\n\n  /// Return true if this operand bundle user has operand bundles that\n  /// may read from the heap.\n  bool hasReadingOperandBundles() const {\n    // Implementation note: this is a conservative implementation of operand\n    // bundle semantics, where *any* operand bundle forces a callsite to be at\n    // least readonly.\n    return hasOperandBundles();\n  }\n\n  /// Return true if this operand bundle user has operand bundles that\n  /// may write to the heap.\n  bool hasClobberingOperandBundles() const {\n    for (auto &BOI : bundle_op_infos()) {\n      if (BOI.Tag->second == LLVMContext::OB_deopt ||\n          BOI.Tag->second == LLVMContext::OB_funclet)\n        continue;\n\n      // This instruction has an operand bundle that is not known to us.\n      // Assume the worst.\n      return true;\n    }\n\n    return false;\n  }\n\n  /// Return true if the bundle operand at index \\p OpIdx has the\n  /// attribute \\p A.\n  bool bundleOperandHasAttr(unsigned OpIdx,  Attribute::AttrKind A) const {\n    auto &BOI = getBundleOpInfoForOperand(OpIdx);\n    auto OBU = operandBundleFromBundleOpInfo(BOI);\n    return OBU.operandHasAttr(OpIdx - BOI.Begin, A);\n  }\n\n  /// Return true if \\p Other has the same sequence of operand bundle\n  /// tags with the same number of operands on each one of them as this\n  /// OperandBundleUser.\n  bool hasIdenticalOperandBundleSchema(const CallBase &Other) const {\n    if (getNumOperandBundles() != Other.getNumOperandBundles())\n      return false;\n\n    return std::equal(bundle_op_info_begin(), bundle_op_info_end(),\n                      Other.bundle_op_info_begin());\n  }\n\n  /// Return true if this operand bundle user contains operand bundles\n  /// with tags other than those specified in \\p IDs.\n  bool hasOperandBundlesOtherThan(ArrayRef<uint32_t> IDs) const {\n    for (unsigned i = 0, e = getNumOperandBundles(); i != e; ++i) {\n      uint32_t ID = getOperandBundleAt(i).getTagID();\n      if (!is_contained(IDs, ID))\n        return true;\n    }\n    return false;\n  }\n\n  /// Is the function attribute S disallowed by some operand bundle on\n  /// this operand bundle user?\n  bool isFnAttrDisallowedByOpBundle(StringRef S) const {\n    // Operand bundles only possibly disallow readnone, readonly and argmemonly\n    // attributes.  All String attributes are fine.\n    return false;\n  }\n\n  /// Is the function attribute A disallowed by some operand bundle on\n  /// this operand bundle user?\n  bool isFnAttrDisallowedByOpBundle(Attribute::AttrKind A) const {\n    switch (A) {\n    default:\n      return false;\n\n    case Attribute::InaccessibleMemOrArgMemOnly:\n      return hasReadingOperandBundles();\n\n    case Attribute::InaccessibleMemOnly:\n      return hasReadingOperandBundles();\n\n    case Attribute::ArgMemOnly:\n      return hasReadingOperandBundles();\n\n    case Attribute::ReadNone:\n      return hasReadingOperandBundles();\n\n    case Attribute::ReadOnly:\n      return hasClobberingOperandBundles();\n    }\n\n    llvm_unreachable(\"switch has a default case!\");\n  }\n\n  /// Used to keep track of an operand bundle.  See the main comment on\n  /// OperandBundleUser above.\n  struct BundleOpInfo {\n    /// The operand bundle tag, interned by\n    /// LLVMContextImpl::getOrInsertBundleTag.\n    StringMapEntry<uint32_t> *Tag;\n\n    /// The index in the Use& vector where operands for this operand\n    /// bundle starts.\n    uint32_t Begin;\n\n    /// The index in the Use& vector where operands for this operand\n    /// bundle ends.\n    uint32_t End;\n\n    bool operator==(const BundleOpInfo &Other) const {\n      return Tag == Other.Tag && Begin == Other.Begin && End == Other.End;\n    }\n  };\n\n  /// Simple helper function to map a BundleOpInfo to an\n  /// OperandBundleUse.\n  OperandBundleUse\n  operandBundleFromBundleOpInfo(const BundleOpInfo &BOI) const {\n    auto begin = op_begin();\n    ArrayRef<Use> Inputs(begin + BOI.Begin, begin + BOI.End);\n    return OperandBundleUse(BOI.Tag, Inputs);\n  }\n\n  using bundle_op_iterator = BundleOpInfo *;\n  using const_bundle_op_iterator = const BundleOpInfo *;\n\n  /// Return the start of the list of BundleOpInfo instances associated\n  /// with this OperandBundleUser.\n  ///\n  /// OperandBundleUser uses the descriptor area co-allocated with the host User\n  /// to store some meta information about which operands are \"normal\" operands,\n  /// and which ones belong to some operand bundle.\n  ///\n  /// The layout of an operand bundle user is\n  ///\n  ///          +-----------uint32_t End-------------------------------------+\n  ///          |                                                            |\n  ///          |  +--------uint32_t Begin--------------------+              |\n  ///          |  |                                          |              |\n  ///          ^  ^                                          v              v\n  ///  |------|------|----|----|----|----|----|---------|----|---------|----|-----\n  ///  | BOI0 | BOI1 | .. | DU | U0 | U1 | .. | BOI0_U0 | .. | BOI1_U0 | .. | Un\n  ///  |------|------|----|----|----|----|----|---------|----|---------|----|-----\n  ///   v  v                                  ^              ^\n  ///   |  |                                  |              |\n  ///   |  +--------uint32_t Begin------------+              |\n  ///   |                                                    |\n  ///   +-----------uint32_t End-----------------------------+\n  ///\n  ///\n  /// BOI0, BOI1 ... are descriptions of operand bundles in this User's use\n  /// list. These descriptions are installed and managed by this class, and\n  /// they're all instances of OperandBundleUser<T>::BundleOpInfo.\n  ///\n  /// DU is an additional descriptor installed by User's 'operator new' to keep\n  /// track of the 'BOI0 ... BOIN' co-allocation.  OperandBundleUser does not\n  /// access or modify DU in any way, it's an implementation detail private to\n  /// User.\n  ///\n  /// The regular Use& vector for the User starts at U0.  The operand bundle\n  /// uses are part of the Use& vector, just like normal uses.  In the diagram\n  /// above, the operand bundle uses start at BOI0_U0.  Each instance of\n  /// BundleOpInfo has information about a contiguous set of uses constituting\n  /// an operand bundle, and the total set of operand bundle uses themselves\n  /// form a contiguous set of uses (i.e. there are no gaps between uses\n  /// corresponding to individual operand bundles).\n  ///\n  /// This class does not know the location of the set of operand bundle uses\n  /// within the use list -- that is decided by the User using this class via\n  /// the BeginIdx argument in populateBundleOperandInfos.\n  ///\n  /// Currently operand bundle users with hung-off operands are not supported.\n  bundle_op_iterator bundle_op_info_begin() {\n    if (!hasDescriptor())\n      return nullptr;\n\n    uint8_t *BytesBegin = getDescriptor().begin();\n    return reinterpret_cast<bundle_op_iterator>(BytesBegin);\n  }\n\n  /// Return the start of the list of BundleOpInfo instances associated\n  /// with this OperandBundleUser.\n  const_bundle_op_iterator bundle_op_info_begin() const {\n    auto *NonConstThis = const_cast<CallBase *>(this);\n    return NonConstThis->bundle_op_info_begin();\n  }\n\n  /// Return the end of the list of BundleOpInfo instances associated\n  /// with this OperandBundleUser.\n  bundle_op_iterator bundle_op_info_end() {\n    if (!hasDescriptor())\n      return nullptr;\n\n    uint8_t *BytesEnd = getDescriptor().end();\n    return reinterpret_cast<bundle_op_iterator>(BytesEnd);\n  }\n\n  /// Return the end of the list of BundleOpInfo instances associated\n  /// with this OperandBundleUser.\n  const_bundle_op_iterator bundle_op_info_end() const {\n    auto *NonConstThis = const_cast<CallBase *>(this);\n    return NonConstThis->bundle_op_info_end();\n  }\n\n  /// Return the range [\\p bundle_op_info_begin, \\p bundle_op_info_end).\n  iterator_range<bundle_op_iterator> bundle_op_infos() {\n    return make_range(bundle_op_info_begin(), bundle_op_info_end());\n  }\n\n  /// Return the range [\\p bundle_op_info_begin, \\p bundle_op_info_end).\n  iterator_range<const_bundle_op_iterator> bundle_op_infos() const {\n    return make_range(bundle_op_info_begin(), bundle_op_info_end());\n  }\n\n  /// Populate the BundleOpInfo instances and the Use& vector from \\p\n  /// Bundles.  Return the op_iterator pointing to the Use& one past the last\n  /// last bundle operand use.\n  ///\n  /// Each \\p OperandBundleDef instance is tracked by a OperandBundleInfo\n  /// instance allocated in this User's descriptor.\n  op_iterator populateBundleOperandInfos(ArrayRef<OperandBundleDef> Bundles,\n                                         const unsigned BeginIndex);\n\npublic:\n  /// Return the BundleOpInfo for the operand at index OpIdx.\n  ///\n  /// It is an error to call this with an OpIdx that does not correspond to an\n  /// bundle operand.\n  BundleOpInfo &getBundleOpInfoForOperand(unsigned OpIdx);\n  const BundleOpInfo &getBundleOpInfoForOperand(unsigned OpIdx) const {\n    return const_cast<CallBase *>(this)->getBundleOpInfoForOperand(OpIdx);\n  }\n\nprotected:\n  /// Return the total number of values used in \\p Bundles.\n  static unsigned CountBundleInputs(ArrayRef<OperandBundleDef> Bundles) {\n    unsigned Total = 0;\n    for (auto &B : Bundles)\n      Total += B.input_size();\n    return Total;\n  }\n\n  /// @}\n  // End of operand bundle API.\n\nprivate:\n  bool hasFnAttrOnCalledFunction(Attribute::AttrKind Kind) const;\n  bool hasFnAttrOnCalledFunction(StringRef Kind) const;\n\n  template <typename AttrKind> bool hasFnAttrImpl(AttrKind Kind) const {\n    if (Attrs.hasFnAttribute(Kind))\n      return true;\n\n    // Operand bundles override attributes on the called function, but don't\n    // override attributes directly present on the call instruction.\n    if (isFnAttrDisallowedByOpBundle(Kind))\n      return false;\n\n    return hasFnAttrOnCalledFunction(Kind);\n  }\n\n  /// Determine whether the return value has the given attribute. Supports\n  /// Attribute::AttrKind and StringRef as \\p AttrKind types.\n  template <typename AttrKind> bool hasRetAttrImpl(AttrKind Kind) const {\n    if (Attrs.hasAttribute(AttributeList::ReturnIndex, Kind))\n      return true;\n\n    // Look at the callee, if available.\n    if (const Function *F = getCalledFunction())\n      return F->getAttributes().hasAttribute(AttributeList::ReturnIndex, Kind);\n    return false;\n  }\n};\n\ntemplate <>\nstruct OperandTraits<CallBase> : public VariadicOperandTraits<CallBase, 1> {};\n\nDEFINE_TRANSPARENT_OPERAND_ACCESSORS(CallBase, Value)\n\n//===----------------------------------------------------------------------===//\n//                           FuncletPadInst Class\n//===----------------------------------------------------------------------===//\nclass FuncletPadInst : public Instruction {\nprivate:\n  FuncletPadInst(const FuncletPadInst &CPI);\n\n  explicit FuncletPadInst(Instruction::FuncletPadOps Op, Value *ParentPad,\n                          ArrayRef<Value *> Args, unsigned Values,\n                          const Twine &NameStr, Instruction *InsertBefore);\n  explicit FuncletPadInst(Instruction::FuncletPadOps Op, Value *ParentPad,\n                          ArrayRef<Value *> Args, unsigned Values,\n                          const Twine &NameStr, BasicBlock *InsertAtEnd);\n\n  void init(Value *ParentPad, ArrayRef<Value *> Args, const Twine &NameStr);\n\nprotected:\n  // Note: Instruction needs to be a friend here to call cloneImpl.\n  friend class Instruction;\n  friend class CatchPadInst;\n  friend class CleanupPadInst;\n\n  FuncletPadInst *cloneImpl() const;\n\npublic:\n  /// Provide fast operand accessors\n  DECLARE_TRANSPARENT_OPERAND_ACCESSORS(Value);\n\n  /// getNumArgOperands - Return the number of funcletpad arguments.\n  ///\n  unsigned getNumArgOperands() const { return getNumOperands() - 1; }\n\n  /// Convenience accessors\n\n  /// Return the outer EH-pad this funclet is nested within.\n  ///\n  /// Note: This returns the associated CatchSwitchInst if this FuncletPadInst\n  /// is a CatchPadInst.\n  Value *getParentPad() const { return Op<-1>(); }\n  void setParentPad(Value *ParentPad) {\n    assert(ParentPad);\n    Op<-1>() = ParentPad;\n  }\n\n  /// getArgOperand/setArgOperand - Return/set the i-th funcletpad argument.\n  ///\n  Value *getArgOperand(unsigned i) const { return getOperand(i); }\n  void setArgOperand(unsigned i, Value *v) { setOperand(i, v); }\n\n  /// arg_operands - iteration adapter for range-for loops.\n  op_range arg_operands() { return op_range(op_begin(), op_end() - 1); }\n\n  /// arg_operands - iteration adapter for range-for loops.\n  const_op_range arg_operands() const {\n    return const_op_range(op_begin(), op_end() - 1);\n  }\n\n  // Methods for support type inquiry through isa, cast, and dyn_cast:\n  static bool classof(const Instruction *I) { return I->isFuncletPad(); }\n  static bool classof(const Value *V) {\n    return isa<Instruction>(V) && classof(cast<Instruction>(V));\n  }\n};\n\ntemplate <>\nstruct OperandTraits<FuncletPadInst>\n    : public VariadicOperandTraits<FuncletPadInst, /*MINARITY=*/1> {};\n\nDEFINE_TRANSPARENT_OPERAND_ACCESSORS(FuncletPadInst, Value)\n\n} // end namespace llvm\n\n#endif // LLVM_IR_INSTRTYPES_H\n"}, "32": {"id": 32, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/IR/IntrinsicInst.h", "content": "//===-- llvm/IntrinsicInst.h - Intrinsic Instruction Wrappers ---*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// This file defines classes that make it really easy to deal with intrinsic\n// functions with the isa/dyncast family of functions.  In particular, this\n// allows you to do things like:\n//\n//     if (MemCpyInst *MCI = dyn_cast<MemCpyInst>(Inst))\n//        ... MCI->getDest() ... MCI->getSource() ...\n//\n// All intrinsic function calls are instances of the call instruction, so these\n// are all subclasses of the CallInst class.  Note that none of these classes\n// has state or virtual methods, which is an important part of this gross/neat\n// hack working.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_IR_INTRINSICINST_H\n#define LLVM_IR_INTRINSICINST_H\n\n#include \"llvm/IR/Constants.h\"\n#include \"llvm/IR/DebugInfoMetadata.h\"\n#include \"llvm/IR/DerivedTypes.h\"\n#include \"llvm/IR/FPEnv.h\"\n#include \"llvm/IR/Function.h\"\n#include \"llvm/IR/GlobalVariable.h\"\n#include \"llvm/IR/Instructions.h\"\n#include \"llvm/IR/Intrinsics.h\"\n#include \"llvm/IR/Metadata.h\"\n#include \"llvm/IR/Value.h\"\n#include \"llvm/Support/Casting.h\"\n#include <cassert>\n#include <cstdint>\n\nnamespace llvm {\n\n/// A wrapper class for inspecting calls to intrinsic functions.\n/// This allows the standard isa/dyncast/cast functionality to work with calls\n/// to intrinsic functions.\nclass IntrinsicInst : public CallInst {\npublic:\n  IntrinsicInst() = delete;\n  IntrinsicInst(const IntrinsicInst &) = delete;\n  IntrinsicInst &operator=(const IntrinsicInst &) = delete;\n\n  /// Return the intrinsic ID of this intrinsic.\n  Intrinsic::ID getIntrinsicID() const {\n    return getCalledFunction()->getIntrinsicID();\n  }\n\n  /// Return true if swapping the first two arguments to the intrinsic produces\n  /// the same result.\n  bool isCommutative() const {\n    switch (getIntrinsicID()) {\n    case Intrinsic::maxnum:\n    case Intrinsic::minnum:\n    case Intrinsic::maximum:\n    case Intrinsic::minimum:\n    case Intrinsic::smax:\n    case Intrinsic::smin:\n    case Intrinsic::umax:\n    case Intrinsic::umin:\n    case Intrinsic::sadd_sat:\n    case Intrinsic::uadd_sat:\n    case Intrinsic::sadd_with_overflow:\n    case Intrinsic::uadd_with_overflow:\n    case Intrinsic::smul_with_overflow:\n    case Intrinsic::umul_with_overflow:\n    case Intrinsic::smul_fix:\n    case Intrinsic::umul_fix:\n    case Intrinsic::smul_fix_sat:\n    case Intrinsic::umul_fix_sat:\n    case Intrinsic::fma:\n    case Intrinsic::fmuladd:\n      return true;\n    default:\n      return false;\n    }\n  }\n\n  // Checks if the intrinsic is an annotation.\n  bool isAssumeLikeIntrinsic() const {\n    switch (getIntrinsicID()) {\n    default: break;\n    case Intrinsic::assume:\n    case Intrinsic::sideeffect:\n    case Intrinsic::pseudoprobe:\n    case Intrinsic::dbg_declare:\n    case Intrinsic::dbg_value:\n    case Intrinsic::dbg_label:\n    case Intrinsic::invariant_start:\n    case Intrinsic::invariant_end:\n    case Intrinsic::lifetime_start:\n    case Intrinsic::lifetime_end:\n    case Intrinsic::experimental_noalias_scope_decl:\n    case Intrinsic::objectsize:\n    case Intrinsic::ptr_annotation:\n    case Intrinsic::var_annotation:\n      return true;\n    }\n    return false;\n  }\n\n  // Methods for support type inquiry through isa, cast, and dyn_cast:\n  static bool classof(const CallInst *I) {\n    if (const Function *CF = I->getCalledFunction())\n      return CF->isIntrinsic();\n    return false;\n  }\n  static bool classof(const Value *V) {\n    return isa<CallInst>(V) && classof(cast<CallInst>(V));\n  }\n};\n\n/// Check if \\p ID corresponds to a debug info intrinsic.\nstatic inline bool isDbgInfoIntrinsic(Intrinsic::ID ID) {\n  switch (ID) {\n  case Intrinsic::dbg_declare:\n  case Intrinsic::dbg_value:\n  case Intrinsic::dbg_addr:\n  case Intrinsic::dbg_label:\n    return true;\n  default:\n    return false;\n  }\n}\n\n/// This is the common base class for debug info intrinsics.\nclass DbgInfoIntrinsic : public IntrinsicInst {\npublic:\n  /// \\name Casting methods\n  /// @{\n  static bool classof(const IntrinsicInst *I) {\n    return isDbgInfoIntrinsic(I->getIntrinsicID());\n  }\n  static bool classof(const Value *V) {\n    return isa<IntrinsicInst>(V) && classof(cast<IntrinsicInst>(V));\n  }\n  /// @}\n};\n\n/// This is the common base class for debug info intrinsics for variables.\nclass DbgVariableIntrinsic : public DbgInfoIntrinsic {\npublic:\n  // Iterator for ValueAsMetadata that internally uses direct pointer iteration\n  // over either a ValueAsMetadata* or a ValueAsMetadata**, dereferencing to the\n  // ValueAsMetadata .\n  class location_op_iterator\n      : public iterator_facade_base<location_op_iterator,\n                                    std::bidirectional_iterator_tag, Value *> {\n    PointerUnion<ValueAsMetadata *, ValueAsMetadata **> I;\n\n  public:\n    location_op_iterator(ValueAsMetadata *SingleIter) : I(SingleIter) {}\n    location_op_iterator(ValueAsMetadata **MultiIter) : I(MultiIter) {}\n\n    location_op_iterator(const location_op_iterator &R) : I(R.I) {}\n    location_op_iterator &operator=(const location_op_iterator &R) {\n      I = R.I;\n      return *this;\n    }\n    bool operator==(const location_op_iterator &RHS) const {\n      return I == RHS.I;\n    }\n    const Value *operator*() const {\n      ValueAsMetadata *VAM = I.is<ValueAsMetadata *>()\n                                 ? I.get<ValueAsMetadata *>()\n                                 : *I.get<ValueAsMetadata **>();\n      return VAM->getValue();\n    };\n    Value *operator*() {\n      ValueAsMetadata *VAM = I.is<ValueAsMetadata *>()\n                                 ? I.get<ValueAsMetadata *>()\n                                 : *I.get<ValueAsMetadata **>();\n      return VAM->getValue();\n    }\n    location_op_iterator &operator++() {\n      if (I.is<ValueAsMetadata *>())\n        I = I.get<ValueAsMetadata *>() + 1;\n      else\n        I = I.get<ValueAsMetadata **>() + 1;\n      return *this;\n    }\n    location_op_iterator &operator--() {\n      if (I.is<ValueAsMetadata *>())\n        I = I.get<ValueAsMetadata *>() - 1;\n      else\n        I = I.get<ValueAsMetadata **>() - 1;\n      return *this;\n    }\n  };\n\n  /// Get the locations corresponding to the variable referenced by the debug\n  /// info intrinsic.  Depending on the intrinsic, this could be the\n  /// variable's value or its address.\n  iterator_range<location_op_iterator> location_ops() const;\n\n  Value *getVariableLocationOp(unsigned OpIdx) const;\n\n  void replaceVariableLocationOp(Value *OldValue, Value *NewValue);\n  void replaceVariableLocationOp(unsigned OpIdx, Value *NewValue);\n\n  void setVariable(DILocalVariable *NewVar) {\n    setArgOperand(1, MetadataAsValue::get(NewVar->getContext(), NewVar));\n  }\n\n  void setExpression(DIExpression *NewExpr) {\n    setArgOperand(2, MetadataAsValue::get(NewExpr->getContext(), NewExpr));\n  }\n\n  unsigned getNumVariableLocationOps() const {\n    if (hasArgList())\n      return cast<DIArgList>(getRawLocation())->getArgs().size();\n    return 1;\n  }\n\n  bool hasArgList() const { return isa<DIArgList>(getRawLocation()); }\n\n  /// Does this describe the address of a local variable. True for dbg.addr\n  /// and dbg.declare, but not dbg.value, which describes its value.\n  bool isAddressOfVariable() const {\n    return getIntrinsicID() != Intrinsic::dbg_value;\n  }\n\n  void setUndef() {\n    // TODO: When/if we remove duplicate values from DIArgLists, we don't need\n    // this set anymore.\n    SmallPtrSet<Value *, 4> RemovedValues;\n    for (Value *OldValue : location_ops()) {\n      if (!RemovedValues.insert(OldValue).second)\n        continue;\n      Value *Undef = UndefValue::get(OldValue->getType());\n      replaceVariableLocationOp(OldValue, Undef);\n    }\n  }\n\n  bool isUndef() const {\n    return (getNumVariableLocationOps() == 0 &&\n            !getExpression()->isComplex()) ||\n           any_of(location_ops(), [](Value *V) { return isa<UndefValue>(V); });\n  }\n\n  DILocalVariable *getVariable() const {\n    return cast<DILocalVariable>(getRawVariable());\n  }\n\n  DIExpression *getExpression() const {\n    return cast<DIExpression>(getRawExpression());\n  }\n\n  Metadata *getRawLocation() const {\n    return cast<MetadataAsValue>(getArgOperand(0))->getMetadata();\n  }\n\n  Metadata *getRawVariable() const {\n    return cast<MetadataAsValue>(getArgOperand(1))->getMetadata();\n  }\n\n  Metadata *getRawExpression() const {\n    return cast<MetadataAsValue>(getArgOperand(2))->getMetadata();\n  }\n\n  /// Get the size (in bits) of the variable, or fragment of the variable that\n  /// is described.\n  Optional<uint64_t> getFragmentSizeInBits() const;\n\n  /// \\name Casting methods\n  /// @{\n  static bool classof(const IntrinsicInst *I) {\n    switch (I->getIntrinsicID()) {\n    case Intrinsic::dbg_declare:\n    case Intrinsic::dbg_value:\n    case Intrinsic::dbg_addr:\n      return true;\n    default:\n      return false;\n    }\n  }\n  static bool classof(const Value *V) {\n    return isa<IntrinsicInst>(V) && classof(cast<IntrinsicInst>(V));\n  }\n  /// @}\nprivate:\n  void setArgOperand(unsigned i, Value *v) {\n    DbgInfoIntrinsic::setArgOperand(i, v);\n  }\n  void setOperand(unsigned i, Value *v) { DbgInfoIntrinsic::setOperand(i, v); }\n};\n\n/// This represents the llvm.dbg.declare instruction.\nclass DbgDeclareInst : public DbgVariableIntrinsic {\npublic:\n  Value *getAddress() const {\n    assert(getNumVariableLocationOps() == 1 &&\n           \"dbg.declare must have exactly 1 location operand.\");\n    return getVariableLocationOp(0);\n  }\n\n  /// \\name Casting methods\n  /// @{\n  static bool classof(const IntrinsicInst *I) {\n    return I->getIntrinsicID() == Intrinsic::dbg_declare;\n  }\n  static bool classof(const Value *V) {\n    return isa<IntrinsicInst>(V) && classof(cast<IntrinsicInst>(V));\n  }\n  /// @}\n};\n\n/// This represents the llvm.dbg.addr instruction.\nclass DbgAddrIntrinsic : public DbgVariableIntrinsic {\npublic:\n  Value *getAddress() const {\n    assert(getNumVariableLocationOps() == 1 &&\n           \"dbg.addr must have exactly 1 location operand.\");\n    return getVariableLocationOp(0);\n  }\n\n  /// \\name Casting methods\n  /// @{\n  static bool classof(const IntrinsicInst *I) {\n    return I->getIntrinsicID() == Intrinsic::dbg_addr;\n  }\n  static bool classof(const Value *V) {\n    return isa<IntrinsicInst>(V) && classof(cast<IntrinsicInst>(V));\n  }\n};\n\n/// This represents the llvm.dbg.value instruction.\nclass DbgValueInst : public DbgVariableIntrinsic {\npublic:\n  // The default argument should only be used in ISel, and the default option\n  // should be removed once ISel support for multiple location ops is complete.\n  Value *getValue(unsigned OpIdx = 0) const {\n    return getVariableLocationOp(OpIdx);\n  }\n  iterator_range<location_op_iterator> getValues() const {\n    return location_ops();\n  }\n\n  /// \\name Casting methods\n  /// @{\n  static bool classof(const IntrinsicInst *I) {\n    return I->getIntrinsicID() == Intrinsic::dbg_value;\n  }\n  static bool classof(const Value *V) {\n    return isa<IntrinsicInst>(V) && classof(cast<IntrinsicInst>(V));\n  }\n  /// @}\n};\n\n/// This represents the llvm.dbg.label instruction.\nclass DbgLabelInst : public DbgInfoIntrinsic {\npublic:\n  DILabel *getLabel() const { return cast<DILabel>(getRawLabel()); }\n\n  Metadata *getRawLabel() const {\n    return cast<MetadataAsValue>(getArgOperand(0))->getMetadata();\n  }\n\n  /// Methods for support type inquiry through isa, cast, and dyn_cast:\n  /// @{\n  static bool classof(const IntrinsicInst *I) {\n    return I->getIntrinsicID() == Intrinsic::dbg_label;\n  }\n  static bool classof(const Value *V) {\n    return isa<IntrinsicInst>(V) && classof(cast<IntrinsicInst>(V));\n  }\n  /// @}\n};\n\n/// This is the common base class for vector predication intrinsics.\nclass VPIntrinsic : public IntrinsicInst {\npublic:\n  static Optional<int> GetMaskParamPos(Intrinsic::ID IntrinsicID);\n  static Optional<int> GetVectorLengthParamPos(Intrinsic::ID IntrinsicID);\n\n  /// The llvm.vp.* intrinsics for this instruction Opcode\n  static Intrinsic::ID GetForOpcode(unsigned OC);\n\n  // Whether \\p ID is a VP intrinsic ID.\n  static bool IsVPIntrinsic(Intrinsic::ID);\n\n  /// \\return the mask parameter or nullptr.\n  Value *getMaskParam() const;\n\n  /// \\return the vector length parameter or nullptr.\n  Value *getVectorLengthParam() const;\n\n  /// \\return whether the vector length param can be ignored.\n  bool canIgnoreVectorLengthParam() const;\n\n  /// \\return the static element count (vector number of elements) the vector\n  /// length parameter applies to.\n  ElementCount getStaticVectorLength() const;\n\n  // Methods for support type inquiry through isa, cast, and dyn_cast:\n  static bool classof(const IntrinsicInst *I) {\n    return IsVPIntrinsic(I->getIntrinsicID());\n  }\n  static bool classof(const Value *V) {\n    return isa<IntrinsicInst>(V) && classof(cast<IntrinsicInst>(V));\n  }\n\n  // Equivalent non-predicated opcode\n  unsigned getFunctionalOpcode() const {\n    return GetFunctionalOpcodeForVP(getIntrinsicID());\n  }\n\n  // Equivalent non-predicated opcode\n  static unsigned GetFunctionalOpcodeForVP(Intrinsic::ID ID);\n};\n\n/// This is the common base class for constrained floating point intrinsics.\nclass ConstrainedFPIntrinsic : public IntrinsicInst {\npublic:\n  bool isUnaryOp() const;\n  bool isTernaryOp() const;\n  Optional<RoundingMode> getRoundingMode() const;\n  Optional<fp::ExceptionBehavior> getExceptionBehavior() const;\n\n  // Methods for support type inquiry through isa, cast, and dyn_cast:\n  static bool classof(const IntrinsicInst *I);\n  static bool classof(const Value *V) {\n    return isa<IntrinsicInst>(V) && classof(cast<IntrinsicInst>(V));\n  }\n};\n\n/// Constrained floating point compare intrinsics.\nclass ConstrainedFPCmpIntrinsic : public ConstrainedFPIntrinsic {\npublic:\n  FCmpInst::Predicate getPredicate() const;\n\n  // Methods for support type inquiry through isa, cast, and dyn_cast:\n  static bool classof(const IntrinsicInst *I) {\n    switch (I->getIntrinsicID()) {\n    case Intrinsic::experimental_constrained_fcmp:\n    case Intrinsic::experimental_constrained_fcmps:\n      return true;\n    default:\n      return false;\n    }\n  }\n  static bool classof(const Value *V) {\n    return isa<IntrinsicInst>(V) && classof(cast<IntrinsicInst>(V));\n  }\n};\n\n/// This class represents an intrinsic that is based on a binary operation.\n/// This includes op.with.overflow and saturating add/sub intrinsics.\nclass BinaryOpIntrinsic : public IntrinsicInst {\npublic:\n  static bool classof(const IntrinsicInst *I) {\n    switch (I->getIntrinsicID()) {\n    case Intrinsic::uadd_with_overflow:\n    case Intrinsic::sadd_with_overflow:\n    case Intrinsic::usub_with_overflow:\n    case Intrinsic::ssub_with_overflow:\n    case Intrinsic::umul_with_overflow:\n    case Intrinsic::smul_with_overflow:\n    case Intrinsic::uadd_sat:\n    case Intrinsic::sadd_sat:\n    case Intrinsic::usub_sat:\n    case Intrinsic::ssub_sat:\n      return true;\n    default:\n      return false;\n    }\n  }\n  static bool classof(const Value *V) {\n    return isa<IntrinsicInst>(V) && classof(cast<IntrinsicInst>(V));\n  }\n\n  Value *getLHS() const { return const_cast<Value *>(getArgOperand(0)); }\n  Value *getRHS() const { return const_cast<Value *>(getArgOperand(1)); }\n\n  /// Returns the binary operation underlying the intrinsic.\n  Instruction::BinaryOps getBinaryOp() const;\n\n  /// Whether the intrinsic is signed or unsigned.\n  bool isSigned() const;\n\n  /// Returns one of OBO::NoSignedWrap or OBO::NoUnsignedWrap.\n  unsigned getNoWrapKind() const;\n};\n\n/// Represents an op.with.overflow intrinsic.\nclass WithOverflowInst : public BinaryOpIntrinsic {\npublic:\n  static bool classof(const IntrinsicInst *I) {\n    switch (I->getIntrinsicID()) {\n    case Intrinsic::uadd_with_overflow:\n    case Intrinsic::sadd_with_overflow:\n    case Intrinsic::usub_with_overflow:\n    case Intrinsic::ssub_with_overflow:\n    case Intrinsic::umul_with_overflow:\n    case Intrinsic::smul_with_overflow:\n      return true;\n    default:\n      return false;\n    }\n  }\n  static bool classof(const Value *V) {\n    return isa<IntrinsicInst>(V) && classof(cast<IntrinsicInst>(V));\n  }\n};\n\n/// Represents a saturating add/sub intrinsic.\nclass SaturatingInst : public BinaryOpIntrinsic {\npublic:\n  static bool classof(const IntrinsicInst *I) {\n    switch (I->getIntrinsicID()) {\n    case Intrinsic::uadd_sat:\n    case Intrinsic::sadd_sat:\n    case Intrinsic::usub_sat:\n    case Intrinsic::ssub_sat:\n      return true;\n    default:\n      return false;\n    }\n  }\n  static bool classof(const Value *V) {\n    return isa<IntrinsicInst>(V) && classof(cast<IntrinsicInst>(V));\n  }\n};\n\n/// Common base class for all memory intrinsics. Simply provides\n/// common methods.\n/// Written as CRTP to avoid a common base class amongst the\n/// three atomicity hierarchies.\ntemplate <typename Derived> class MemIntrinsicBase : public IntrinsicInst {\nprivate:\n  enum { ARG_DEST = 0, ARG_LENGTH = 2 };\n\npublic:\n  Value *getRawDest() const {\n    return const_cast<Value *>(getArgOperand(ARG_DEST));\n  }\n  const Use &getRawDestUse() const { return getArgOperandUse(ARG_DEST); }\n  Use &getRawDestUse() { return getArgOperandUse(ARG_DEST); }\n\n  Value *getLength() const {\n    return const_cast<Value *>(getArgOperand(ARG_LENGTH));\n  }\n  const Use &getLengthUse() const { return getArgOperandUse(ARG_LENGTH); }\n  Use &getLengthUse() { return getArgOperandUse(ARG_LENGTH); }\n\n  /// This is just like getRawDest, but it strips off any cast\n  /// instructions (including addrspacecast) that feed it, giving the\n  /// original input.  The returned value is guaranteed to be a pointer.\n  Value *getDest() const { return getRawDest()->stripPointerCasts(); }\n\n  unsigned getDestAddressSpace() const {\n    return cast<PointerType>(getRawDest()->getType())->getAddressSpace();\n  }\n\n  /// FIXME: Remove this function once transition to Align is over.\n  /// Use getDestAlign() instead.\n  unsigned getDestAlignment() const {\n    if (auto MA = getParamAlign(ARG_DEST))\n      return MA->value();\n    return 0;\n  }\n  MaybeAlign getDestAlign() const { return getParamAlign(ARG_DEST); }\n\n  /// Set the specified arguments of the instruction.\n  void setDest(Value *Ptr) {\n    assert(getRawDest()->getType() == Ptr->getType() &&\n           \"setDest called with pointer of wrong type!\");\n    setArgOperand(ARG_DEST, Ptr);\n  }\n\n  /// FIXME: Remove this function once transition to Align is over.\n  /// Use the version that takes MaybeAlign instead of this one.\n  void setDestAlignment(unsigned Alignment) {\n    setDestAlignment(MaybeAlign(Alignment));\n  }\n  void setDestAlignment(MaybeAlign Alignment) {\n    removeParamAttr(ARG_DEST, Attribute::Alignment);\n    if (Alignment)\n      addParamAttr(ARG_DEST,\n                   Attribute::getWithAlignment(getContext(), *Alignment));\n  }\n  void setDestAlignment(Align Alignment) {\n    removeParamAttr(ARG_DEST, Attribute::Alignment);\n    addParamAttr(ARG_DEST,\n                 Attribute::getWithAlignment(getContext(), Alignment));\n  }\n\n  void setLength(Value *L) {\n    assert(getLength()->getType() == L->getType() &&\n           \"setLength called with value of wrong type!\");\n    setArgOperand(ARG_LENGTH, L);\n  }\n};\n\n/// Common base class for all memory transfer intrinsics. Simply provides\n/// common methods.\ntemplate <class BaseCL> class MemTransferBase : public BaseCL {\nprivate:\n  enum { ARG_SOURCE = 1 };\n\npublic:\n  /// Return the arguments to the instruction.\n  Value *getRawSource() const {\n    return const_cast<Value *>(BaseCL::getArgOperand(ARG_SOURCE));\n  }\n  const Use &getRawSourceUse() const {\n    return BaseCL::getArgOperandUse(ARG_SOURCE);\n  }\n  Use &getRawSourceUse() { return BaseCL::getArgOperandUse(ARG_SOURCE); }\n\n  /// This is just like getRawSource, but it strips off any cast\n  /// instructions that feed it, giving the original input.  The returned\n  /// value is guaranteed to be a pointer.\n  Value *getSource() const { return getRawSource()->stripPointerCasts(); }\n\n  unsigned getSourceAddressSpace() const {\n    return cast<PointerType>(getRawSource()->getType())->getAddressSpace();\n  }\n\n  /// FIXME: Remove this function once transition to Align is over.\n  /// Use getSourceAlign() instead.\n  unsigned getSourceAlignment() const {\n    if (auto MA = BaseCL::getParamAlign(ARG_SOURCE))\n      return MA->value();\n    return 0;\n  }\n\n  MaybeAlign getSourceAlign() const {\n    return BaseCL::getParamAlign(ARG_SOURCE);\n  }\n\n  void setSource(Value *Ptr) {\n    assert(getRawSource()->getType() == Ptr->getType() &&\n           \"setSource called with pointer of wrong type!\");\n    BaseCL::setArgOperand(ARG_SOURCE, Ptr);\n  }\n\n  /// FIXME: Remove this function once transition to Align is over.\n  /// Use the version that takes MaybeAlign instead of this one.\n  void setSourceAlignment(unsigned Alignment) {\n    setSourceAlignment(MaybeAlign(Alignment));\n  }\n  void setSourceAlignment(MaybeAlign Alignment) {\n    BaseCL::removeParamAttr(ARG_SOURCE, Attribute::Alignment);\n    if (Alignment)\n      BaseCL::addParamAttr(ARG_SOURCE, Attribute::getWithAlignment(\n                                           BaseCL::getContext(), *Alignment));\n  }\n  void setSourceAlignment(Align Alignment) {\n    BaseCL::removeParamAttr(ARG_SOURCE, Attribute::Alignment);\n    BaseCL::addParamAttr(ARG_SOURCE, Attribute::getWithAlignment(\n                                         BaseCL::getContext(), Alignment));\n  }\n};\n\n/// Common base class for all memset intrinsics. Simply provides\n/// common methods.\ntemplate <class BaseCL> class MemSetBase : public BaseCL {\nprivate:\n  enum { ARG_VALUE = 1 };\n\npublic:\n  Value *getValue() const {\n    return const_cast<Value *>(BaseCL::getArgOperand(ARG_VALUE));\n  }\n  const Use &getValueUse() const { return BaseCL::getArgOperandUse(ARG_VALUE); }\n  Use &getValueUse() { return BaseCL::getArgOperandUse(ARG_VALUE); }\n\n  void setValue(Value *Val) {\n    assert(getValue()->getType() == Val->getType() &&\n           \"setValue called with value of wrong type!\");\n    BaseCL::setArgOperand(ARG_VALUE, Val);\n  }\n};\n\n// The common base class for the atomic memset/memmove/memcpy intrinsics\n// i.e. llvm.element.unordered.atomic.memset/memcpy/memmove\nclass AtomicMemIntrinsic : public MemIntrinsicBase<AtomicMemIntrinsic> {\nprivate:\n  enum { ARG_ELEMENTSIZE = 3 };\n\npublic:\n  Value *getRawElementSizeInBytes() const {\n    return const_cast<Value *>(getArgOperand(ARG_ELEMENTSIZE));\n  }\n\n  ConstantInt *getElementSizeInBytesCst() const {\n    return cast<ConstantInt>(getRawElementSizeInBytes());\n  }\n\n  uint32_t getElementSizeInBytes() const {\n    return getElementSizeInBytesCst()->getZExtValue();\n  }\n\n  void setElementSizeInBytes(Constant *V) {\n    assert(V->getType() == Type::getInt8Ty(getContext()) &&\n           \"setElementSizeInBytes called with value of wrong type!\");\n    setArgOperand(ARG_ELEMENTSIZE, V);\n  }\n\n  static bool classof(const IntrinsicInst *I) {\n    switch (I->getIntrinsicID()) {\n    case Intrinsic::memcpy_element_unordered_atomic:\n    case Intrinsic::memmove_element_unordered_atomic:\n    case Intrinsic::memset_element_unordered_atomic:\n      return true;\n    default:\n      return false;\n    }\n  }\n  static bool classof(const Value *V) {\n    return isa<IntrinsicInst>(V) && classof(cast<IntrinsicInst>(V));\n  }\n};\n\n/// This class represents atomic memset intrinsic\n// i.e. llvm.element.unordered.atomic.memset\nclass AtomicMemSetInst : public MemSetBase<AtomicMemIntrinsic> {\npublic:\n  static bool classof(const IntrinsicInst *I) {\n    return I->getIntrinsicID() == Intrinsic::memset_element_unordered_atomic;\n  }\n  static bool classof(const Value *V) {\n    return isa<IntrinsicInst>(V) && classof(cast<IntrinsicInst>(V));\n  }\n};\n\n// This class wraps the atomic memcpy/memmove intrinsics\n// i.e. llvm.element.unordered.atomic.memcpy/memmove\nclass AtomicMemTransferInst : public MemTransferBase<AtomicMemIntrinsic> {\npublic:\n  static bool classof(const IntrinsicInst *I) {\n    switch (I->getIntrinsicID()) {\n    case Intrinsic::memcpy_element_unordered_atomic:\n    case Intrinsic::memmove_element_unordered_atomic:\n      return true;\n    default:\n      return false;\n    }\n  }\n  static bool classof(const Value *V) {\n    return isa<IntrinsicInst>(V) && classof(cast<IntrinsicInst>(V));\n  }\n};\n\n/// This class represents the atomic memcpy intrinsic\n/// i.e. llvm.element.unordered.atomic.memcpy\nclass AtomicMemCpyInst : public AtomicMemTransferInst {\npublic:\n  static bool classof(const IntrinsicInst *I) {\n    return I->getIntrinsicID() == Intrinsic::memcpy_element_unordered_atomic;\n  }\n  static bool classof(const Value *V) {\n    return isa<IntrinsicInst>(V) && classof(cast<IntrinsicInst>(V));\n  }\n};\n\n/// This class represents the atomic memmove intrinsic\n/// i.e. llvm.element.unordered.atomic.memmove\nclass AtomicMemMoveInst : public AtomicMemTransferInst {\npublic:\n  static bool classof(const IntrinsicInst *I) {\n    return I->getIntrinsicID() == Intrinsic::memmove_element_unordered_atomic;\n  }\n  static bool classof(const Value *V) {\n    return isa<IntrinsicInst>(V) && classof(cast<IntrinsicInst>(V));\n  }\n};\n\n/// This is the common base class for memset/memcpy/memmove.\nclass MemIntrinsic : public MemIntrinsicBase<MemIntrinsic> {\nprivate:\n  enum { ARG_VOLATILE = 3 };\n\npublic:\n  ConstantInt *getVolatileCst() const {\n    return cast<ConstantInt>(const_cast<Value *>(getArgOperand(ARG_VOLATILE)));\n  }\n\n  bool isVolatile() const { return !getVolatileCst()->isZero(); }\n\n  void setVolatile(Constant *V) { setArgOperand(ARG_VOLATILE, V); }\n\n  // Methods for support type inquiry through isa, cast, and dyn_cast:\n  static bool classof(const IntrinsicInst *I) {\n    switch (I->getIntrinsicID()) {\n    case Intrinsic::memcpy:\n    case Intrinsic::memmove:\n    case Intrinsic::memset:\n    case Intrinsic::memcpy_inline:\n      return true;\n    default:\n      return false;\n    }\n  }\n  static bool classof(const Value *V) {\n    return isa<IntrinsicInst>(V) && classof(cast<IntrinsicInst>(V));\n  }\n};\n\n/// This class wraps the llvm.memset intrinsic.\nclass MemSetInst : public MemSetBase<MemIntrinsic> {\npublic:\n  // Methods for support type inquiry through isa, cast, and dyn_cast:\n  static bool classof(const IntrinsicInst *I) {\n    return I->getIntrinsicID() == Intrinsic::memset;\n  }\n  static bool classof(const Value *V) {\n    return isa<IntrinsicInst>(V) && classof(cast<IntrinsicInst>(V));\n  }\n};\n\n/// This class wraps the llvm.memcpy/memmove intrinsics.\nclass MemTransferInst : public MemTransferBase<MemIntrinsic> {\npublic:\n  // Methods for support type inquiry through isa, cast, and dyn_cast:\n  static bool classof(const IntrinsicInst *I) {\n    switch (I->getIntrinsicID()) {\n    case Intrinsic::memcpy:\n    case Intrinsic::memmove:\n    case Intrinsic::memcpy_inline:\n      return true;\n    default:\n      return false;\n    }\n  }\n  static bool classof(const Value *V) {\n    return isa<IntrinsicInst>(V) && classof(cast<IntrinsicInst>(V));\n  }\n};\n\n/// This class wraps the llvm.memcpy intrinsic.\nclass MemCpyInst : public MemTransferInst {\npublic:\n  // Methods for support type inquiry through isa, cast, and dyn_cast:\n  static bool classof(const IntrinsicInst *I) {\n    return I->getIntrinsicID() == Intrinsic::memcpy;\n  }\n  static bool classof(const Value *V) {\n    return isa<IntrinsicInst>(V) && classof(cast<IntrinsicInst>(V));\n  }\n};\n\n/// This class wraps the llvm.memmove intrinsic.\nclass MemMoveInst : public MemTransferInst {\npublic:\n  // Methods for support type inquiry through isa, cast, and dyn_cast:\n  static bool classof(const IntrinsicInst *I) {\n    return I->getIntrinsicID() == Intrinsic::memmove;\n  }\n  static bool classof(const Value *V) {\n    return isa<IntrinsicInst>(V) && classof(cast<IntrinsicInst>(V));\n  }\n};\n\n/// This class wraps the llvm.memcpy.inline intrinsic.\nclass MemCpyInlineInst : public MemTransferInst {\npublic:\n  ConstantInt *getLength() const {\n    return cast<ConstantInt>(MemTransferInst::getLength());\n  }\n  // Methods for support type inquiry through isa, cast, and dyn_cast:\n  static bool classof(const IntrinsicInst *I) {\n    return I->getIntrinsicID() == Intrinsic::memcpy_inline;\n  }\n  static bool classof(const Value *V) {\n    return isa<IntrinsicInst>(V) && classof(cast<IntrinsicInst>(V));\n  }\n};\n\n// The common base class for any memset/memmove/memcpy intrinsics;\n// whether they be atomic or non-atomic.\n// i.e. llvm.element.unordered.atomic.memset/memcpy/memmove\n//  and llvm.memset/memcpy/memmove\nclass AnyMemIntrinsic : public MemIntrinsicBase<AnyMemIntrinsic> {\npublic:\n  bool isVolatile() const {\n    // Only the non-atomic intrinsics can be volatile\n    if (auto *MI = dyn_cast<MemIntrinsic>(this))\n      return MI->isVolatile();\n    return false;\n  }\n\n  static bool classof(const IntrinsicInst *I) {\n    switch (I->getIntrinsicID()) {\n    case Intrinsic::memcpy:\n    case Intrinsic::memcpy_inline:\n    case Intrinsic::memmove:\n    case Intrinsic::memset:\n    case Intrinsic::memcpy_element_unordered_atomic:\n    case Intrinsic::memmove_element_unordered_atomic:\n    case Intrinsic::memset_element_unordered_atomic:\n      return true;\n    default:\n      return false;\n    }\n  }\n  static bool classof(const Value *V) {\n    return isa<IntrinsicInst>(V) && classof(cast<IntrinsicInst>(V));\n  }\n};\n\n/// This class represents any memset intrinsic\n// i.e. llvm.element.unordered.atomic.memset\n// and  llvm.memset\nclass AnyMemSetInst : public MemSetBase<AnyMemIntrinsic> {\npublic:\n  static bool classof(const IntrinsicInst *I) {\n    switch (I->getIntrinsicID()) {\n    case Intrinsic::memset:\n    case Intrinsic::memset_element_unordered_atomic:\n      return true;\n    default:\n      return false;\n    }\n  }\n  static bool classof(const Value *V) {\n    return isa<IntrinsicInst>(V) && classof(cast<IntrinsicInst>(V));\n  }\n};\n\n// This class wraps any memcpy/memmove intrinsics\n// i.e. llvm.element.unordered.atomic.memcpy/memmove\n// and  llvm.memcpy/memmove\nclass AnyMemTransferInst : public MemTransferBase<AnyMemIntrinsic> {\npublic:\n  static bool classof(const IntrinsicInst *I) {\n    switch (I->getIntrinsicID()) {\n    case Intrinsic::memcpy:\n    case Intrinsic::memcpy_inline:\n    case Intrinsic::memmove:\n    case Intrinsic::memcpy_element_unordered_atomic:\n    case Intrinsic::memmove_element_unordered_atomic:\n      return true;\n    default:\n      return false;\n    }\n  }\n  static bool classof(const Value *V) {\n    return isa<IntrinsicInst>(V) && classof(cast<IntrinsicInst>(V));\n  }\n};\n\n/// This class represents any memcpy intrinsic\n/// i.e. llvm.element.unordered.atomic.memcpy\n///  and llvm.memcpy\nclass AnyMemCpyInst : public AnyMemTransferInst {\npublic:\n  static bool classof(const IntrinsicInst *I) {\n    switch (I->getIntrinsicID()) {\n    case Intrinsic::memcpy:\n    case Intrinsic::memcpy_inline:\n    case Intrinsic::memcpy_element_unordered_atomic:\n      return true;\n    default:\n      return false;\n    }\n  }\n  static bool classof(const Value *V) {\n    return isa<IntrinsicInst>(V) && classof(cast<IntrinsicInst>(V));\n  }\n};\n\n/// This class represents any memmove intrinsic\n/// i.e. llvm.element.unordered.atomic.memmove\n///  and llvm.memmove\nclass AnyMemMoveInst : public AnyMemTransferInst {\npublic:\n  static bool classof(const IntrinsicInst *I) {\n    switch (I->getIntrinsicID()) {\n    case Intrinsic::memmove:\n    case Intrinsic::memmove_element_unordered_atomic:\n      return true;\n    default:\n      return false;\n    }\n  }\n  static bool classof(const Value *V) {\n    return isa<IntrinsicInst>(V) && classof(cast<IntrinsicInst>(V));\n  }\n};\n\n/// This represents the llvm.va_start intrinsic.\nclass VAStartInst : public IntrinsicInst {\npublic:\n  static bool classof(const IntrinsicInst *I) {\n    return I->getIntrinsicID() == Intrinsic::vastart;\n  }\n  static bool classof(const Value *V) {\n    return isa<IntrinsicInst>(V) && classof(cast<IntrinsicInst>(V));\n  }\n\n  Value *getArgList() const { return const_cast<Value *>(getArgOperand(0)); }\n};\n\n/// This represents the llvm.va_end intrinsic.\nclass VAEndInst : public IntrinsicInst {\npublic:\n  static bool classof(const IntrinsicInst *I) {\n    return I->getIntrinsicID() == Intrinsic::vaend;\n  }\n  static bool classof(const Value *V) {\n    return isa<IntrinsicInst>(V) && classof(cast<IntrinsicInst>(V));\n  }\n\n  Value *getArgList() const { return const_cast<Value *>(getArgOperand(0)); }\n};\n\n/// This represents the llvm.va_copy intrinsic.\nclass VACopyInst : public IntrinsicInst {\npublic:\n  static bool classof(const IntrinsicInst *I) {\n    return I->getIntrinsicID() == Intrinsic::vacopy;\n  }\n  static bool classof(const Value *V) {\n    return isa<IntrinsicInst>(V) && classof(cast<IntrinsicInst>(V));\n  }\n\n  Value *getDest() const { return const_cast<Value *>(getArgOperand(0)); }\n  Value *getSrc() const { return const_cast<Value *>(getArgOperand(1)); }\n};\n\n/// This represents the llvm.instrprof_increment intrinsic.\nclass InstrProfIncrementInst : public IntrinsicInst {\npublic:\n  static bool classof(const IntrinsicInst *I) {\n    return I->getIntrinsicID() == Intrinsic::instrprof_increment;\n  }\n  static bool classof(const Value *V) {\n    return isa<IntrinsicInst>(V) && classof(cast<IntrinsicInst>(V));\n  }\n\n  GlobalVariable *getName() const {\n    return cast<GlobalVariable>(\n        const_cast<Value *>(getArgOperand(0))->stripPointerCasts());\n  }\n\n  ConstantInt *getHash() const {\n    return cast<ConstantInt>(const_cast<Value *>(getArgOperand(1)));\n  }\n\n  ConstantInt *getNumCounters() const {\n    return cast<ConstantInt>(const_cast<Value *>(getArgOperand(2)));\n  }\n\n  ConstantInt *getIndex() const {\n    return cast<ConstantInt>(const_cast<Value *>(getArgOperand(3)));\n  }\n\n  Value *getStep() const;\n};\n\nclass InstrProfIncrementInstStep : public InstrProfIncrementInst {\npublic:\n  static bool classof(const IntrinsicInst *I) {\n    return I->getIntrinsicID() == Intrinsic::instrprof_increment_step;\n  }\n  static bool classof(const Value *V) {\n    return isa<IntrinsicInst>(V) && classof(cast<IntrinsicInst>(V));\n  }\n};\n\n/// This represents the llvm.instrprof_value_profile intrinsic.\nclass InstrProfValueProfileInst : public IntrinsicInst {\npublic:\n  static bool classof(const IntrinsicInst *I) {\n    return I->getIntrinsicID() == Intrinsic::instrprof_value_profile;\n  }\n  static bool classof(const Value *V) {\n    return isa<IntrinsicInst>(V) && classof(cast<IntrinsicInst>(V));\n  }\n\n  GlobalVariable *getName() const {\n    return cast<GlobalVariable>(\n        const_cast<Value *>(getArgOperand(0))->stripPointerCasts());\n  }\n\n  ConstantInt *getHash() const {\n    return cast<ConstantInt>(const_cast<Value *>(getArgOperand(1)));\n  }\n\n  Value *getTargetValue() const {\n    return cast<Value>(const_cast<Value *>(getArgOperand(2)));\n  }\n\n  ConstantInt *getValueKind() const {\n    return cast<ConstantInt>(const_cast<Value *>(getArgOperand(3)));\n  }\n\n  // Returns the value site index.\n  ConstantInt *getIndex() const {\n    return cast<ConstantInt>(const_cast<Value *>(getArgOperand(4)));\n  }\n};\n\nclass PseudoProbeInst : public IntrinsicInst {\npublic:\n  static bool classof(const IntrinsicInst *I) {\n    return I->getIntrinsicID() == Intrinsic::pseudoprobe;\n  }\n\n  static bool classof(const Value *V) {\n    return isa<IntrinsicInst>(V) && classof(cast<IntrinsicInst>(V));\n  }\n\n  ConstantInt *getFuncGuid() const {\n    return cast<ConstantInt>(const_cast<Value *>(getArgOperand(0)));\n  }\n\n  ConstantInt *getIndex() const {\n    return cast<ConstantInt>(const_cast<Value *>(getArgOperand(1)));\n  }\n\n  ConstantInt *getAttributes() const {\n    return cast<ConstantInt>(const_cast<Value *>(getArgOperand(2)));\n  }\n\n  ConstantInt *getFactor() const {\n    return cast<ConstantInt>(const_cast<Value *>(getArgOperand(3)));\n  }\n};\n\nclass NoAliasScopeDeclInst : public IntrinsicInst {\npublic:\n  static bool classof(const IntrinsicInst *I) {\n    return I->getIntrinsicID() == Intrinsic::experimental_noalias_scope_decl;\n  }\n\n  static bool classof(const Value *V) {\n    return isa<IntrinsicInst>(V) && classof(cast<IntrinsicInst>(V));\n  }\n\n  MDNode *getScopeList() const {\n    auto *MV =\n        cast<MetadataAsValue>(getOperand(Intrinsic::NoAliasScopeDeclScopeArg));\n    return cast<MDNode>(MV->getMetadata());\n  }\n\n  void setScopeList(MDNode *ScopeList) {\n    setOperand(Intrinsic::NoAliasScopeDeclScopeArg,\n               MetadataAsValue::get(getContext(), ScopeList));\n  }\n};\n\n} // end namespace llvm\n\n#endif // LLVM_IR_INTRINSICINST_H\n"}, "34": {"id": 34, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/IR/LegacyPassManagers.h", "content": "//===- LegacyPassManagers.h - Legacy Pass Infrastructure --------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// This file declares the LLVM Pass Manager infrastructure.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_IR_LEGACYPASSMANAGERS_H\n#define LLVM_IR_LEGACYPASSMANAGERS_H\n\n#include \"llvm/ADT/DenseMap.h\"\n#include \"llvm/ADT/FoldingSet.h\"\n#include \"llvm/ADT/SmallPtrSet.h\"\n#include \"llvm/ADT/SmallVector.h\"\n#include \"llvm/Pass.h\"\n#include <vector>\n\n//===----------------------------------------------------------------------===//\n// Overview:\n// The Pass Manager Infrastructure manages passes. It's responsibilities are:\n//\n//   o Manage optimization pass execution order\n//   o Make required Analysis information available before pass P is run\n//   o Release memory occupied by dead passes\n//   o If Analysis information is dirtied by a pass then regenerate Analysis\n//     information before it is consumed by another pass.\n//\n// Pass Manager Infrastructure uses multiple pass managers.  They are\n// PassManager, FunctionPassManager, MPPassManager, FPPassManager, BBPassManager.\n// This class hierarchy uses multiple inheritance but pass managers do not\n// derive from another pass manager.\n//\n// PassManager and FunctionPassManager are two top-level pass manager that\n// represents the external interface of this entire pass manager infrastucture.\n//\n// Important classes :\n//\n// [o] class PMTopLevelManager;\n//\n// Two top level managers, PassManager and FunctionPassManager, derive from\n// PMTopLevelManager. PMTopLevelManager manages information used by top level\n// managers such as last user info.\n//\n// [o] class PMDataManager;\n//\n// PMDataManager manages information, e.g. list of available analysis info,\n// used by a pass manager to manage execution order of passes. It also provides\n// a place to implement common pass manager APIs. All pass managers derive from\n// PMDataManager.\n//\n// [o] class FunctionPassManager;\n//\n// This is a external interface used to manage FunctionPasses. This\n// interface relies on FunctionPassManagerImpl to do all the tasks.\n//\n// [o] class FunctionPassManagerImpl : public ModulePass, PMDataManager,\n//                                     public PMTopLevelManager;\n//\n// FunctionPassManagerImpl is a top level manager. It manages FPPassManagers\n//\n// [o] class FPPassManager : public ModulePass, public PMDataManager;\n//\n// FPPassManager manages FunctionPasses and BBPassManagers\n//\n// [o] class MPPassManager : public Pass, public PMDataManager;\n//\n// MPPassManager manages ModulePasses and FPPassManagers\n//\n// [o] class PassManager;\n//\n// This is a external interface used by various tools to manages passes. It\n// relies on PassManagerImpl to do all the tasks.\n//\n// [o] class PassManagerImpl : public Pass, public PMDataManager,\n//                             public PMTopLevelManager\n//\n// PassManagerImpl is a top level pass manager responsible for managing\n// MPPassManagers.\n//===----------------------------------------------------------------------===//\n\n#include \"llvm/Support/PrettyStackTrace.h\"\n\nnamespace llvm {\ntemplate <typename T> class ArrayRef;\nclass Module;\nclass StringRef;\nclass Value;\nclass Timer;\nclass PMDataManager;\n\n// enums for debugging strings\nenum PassDebuggingString {\n  EXECUTION_MSG, // \"Executing Pass '\" + PassName\n  MODIFICATION_MSG, // \"Made Modification '\" + PassName\n  FREEING_MSG, // \" Freeing Pass '\" + PassName\n  ON_FUNCTION_MSG, // \"' on Function '\" + FunctionName + \"'...\\n\"\n  ON_MODULE_MSG, // \"' on Module '\" + ModuleName + \"'...\\n\"\n  ON_REGION_MSG, // \"' on Region '\" + Msg + \"'...\\n'\"\n  ON_LOOP_MSG, // \"' on Loop '\" + Msg + \"'...\\n'\"\n  ON_CG_MSG // \"' on Call Graph Nodes '\" + Msg + \"'...\\n'\"\n};\n\n/// PassManagerPrettyStackEntry - This is used to print informative information\n/// about what pass is running when/if a stack trace is generated.\nclass PassManagerPrettyStackEntry : public PrettyStackTraceEntry {\n  Pass *P;\n  Value *V;\n  Module *M;\n\npublic:\n  explicit PassManagerPrettyStackEntry(Pass *p)\n    : P(p), V(nullptr), M(nullptr) {}  // When P is releaseMemory'd.\n  PassManagerPrettyStackEntry(Pass *p, Value &v)\n    : P(p), V(&v), M(nullptr) {} // When P is run on V\n  PassManagerPrettyStackEntry(Pass *p, Module &m)\n    : P(p), V(nullptr), M(&m) {} // When P is run on M\n\n  /// print - Emit information about this stack frame to OS.\n  void print(raw_ostream &OS) const override;\n};\n\n//===----------------------------------------------------------------------===//\n// PMStack\n//\n/// PMStack - This class implements a stack data structure of PMDataManager\n/// pointers.\n///\n/// Top level pass managers (see PassManager.cpp) maintain active Pass Managers\n/// using PMStack. Each Pass implements assignPassManager() to connect itself\n/// with appropriate manager. assignPassManager() walks PMStack to find\n/// suitable manager.\nclass PMStack {\npublic:\n  typedef std::vector<PMDataManager *>::const_reverse_iterator iterator;\n  iterator begin() const { return S.rbegin(); }\n  iterator end() const { return S.rend(); }\n\n  void pop();\n  PMDataManager *top() const { return S.back(); }\n  void push(PMDataManager *PM);\n  bool empty() const { return S.empty(); }\n\n  void dump() const;\n\nprivate:\n  std::vector<PMDataManager *> S;\n};\n\n//===----------------------------------------------------------------------===//\n// PMTopLevelManager\n//\n/// PMTopLevelManager manages LastUser info and collects common APIs used by\n/// top level pass managers.\nclass PMTopLevelManager {\nprotected:\n  explicit PMTopLevelManager(PMDataManager *PMDM);\n\n  unsigned getNumContainedManagers() const {\n    return (unsigned)PassManagers.size();\n  }\n\n  void initializeAllAnalysisInfo();\n\nprivate:\n  virtual PMDataManager *getAsPMDataManager() = 0;\n  virtual PassManagerType getTopLevelPassManagerType() = 0;\n\npublic:\n  /// Schedule pass P for execution. Make sure that passes required by\n  /// P are run before P is run. Update analysis info maintained by\n  /// the manager. Remove dead passes. This is a recursive function.\n  void schedulePass(Pass *P);\n\n  /// Set pass P as the last user of the given analysis passes.\n  void setLastUser(ArrayRef<Pass*> AnalysisPasses, Pass *P);\n\n  /// Collect passes whose last user is P\n  void collectLastUses(SmallVectorImpl<Pass *> &LastUses, Pass *P);\n\n  /// Find the pass that implements Analysis AID. Search immutable\n  /// passes and all pass managers. If desired pass is not found\n  /// then return NULL.\n  Pass *findAnalysisPass(AnalysisID AID);\n\n  /// Retrieve the PassInfo for an analysis.\n  const PassInfo *findAnalysisPassInfo(AnalysisID AID) const;\n\n  /// Find analysis usage information for the pass P.\n  AnalysisUsage *findAnalysisUsage(Pass *P);\n\n  virtual ~PMTopLevelManager();\n\n  /// Add immutable pass and initialize it.\n  void addImmutablePass(ImmutablePass *P);\n\n  inline SmallVectorImpl<ImmutablePass *>& getImmutablePasses() {\n    return ImmutablePasses;\n  }\n\n  void addPassManager(PMDataManager *Manager) {\n    PassManagers.push_back(Manager);\n  }\n\n  // Add Manager into the list of managers that are not directly\n  // maintained by this top level pass manager\n  inline void addIndirectPassManager(PMDataManager *Manager) {\n    IndirectPassManagers.push_back(Manager);\n  }\n\n  // Print passes managed by this top level manager.\n  void dumpPasses() const;\n  void dumpArguments() const;\n\n  // Active Pass Managers\n  PMStack activeStack;\n\nprotected:\n  /// Collection of pass managers\n  SmallVector<PMDataManager *, 8> PassManagers;\n\nprivate:\n  /// Collection of pass managers that are not directly maintained\n  /// by this pass manager\n  SmallVector<PMDataManager *, 8> IndirectPassManagers;\n\n  // Map to keep track of last user of the analysis pass.\n  // LastUser->second is the last user of Lastuser->first.\n  // This is kept in sync with InversedLastUser.\n  DenseMap<Pass *, Pass *> LastUser;\n\n  // Map to keep track of passes that are last used by a pass.\n  // This is kept in sync with LastUser.\n  DenseMap<Pass *, SmallPtrSet<Pass *, 8> > InversedLastUser;\n\n  /// Immutable passes are managed by top level manager.\n  SmallVector<ImmutablePass *, 16> ImmutablePasses;\n\n  /// Map from ID to immutable passes.\n  SmallDenseMap<AnalysisID, ImmutablePass *, 8> ImmutablePassMap;\n\n\n  /// A wrapper around AnalysisUsage for the purpose of uniqueing.  The wrapper\n  /// is used to avoid needing to make AnalysisUsage itself a folding set node.\n  struct AUFoldingSetNode : public FoldingSetNode {\n    AnalysisUsage AU;\n    AUFoldingSetNode(const AnalysisUsage &AU) : AU(AU) {}\n    void Profile(FoldingSetNodeID &ID) const {\n      Profile(ID, AU);\n    }\n    static void Profile(FoldingSetNodeID &ID, const AnalysisUsage &AU) {\n      // TODO: We could consider sorting the dependency arrays within the\n      // AnalysisUsage (since they are conceptually unordered).\n      ID.AddBoolean(AU.getPreservesAll());\n      auto ProfileVec = [&](const SmallVectorImpl<AnalysisID>& Vec) {\n        ID.AddInteger(Vec.size());\n        for(AnalysisID AID : Vec)\n          ID.AddPointer(AID);\n      };\n      ProfileVec(AU.getRequiredSet());\n      ProfileVec(AU.getRequiredTransitiveSet());\n      ProfileVec(AU.getPreservedSet());\n      ProfileVec(AU.getUsedSet());\n    }\n  };\n\n  // Contains all of the unique combinations of AnalysisUsage.  This is helpful\n  // when we have multiple instances of the same pass since they'll usually\n  // have the same analysis usage and can share storage.\n  FoldingSet<AUFoldingSetNode> UniqueAnalysisUsages;\n\n  // Allocator used for allocating UAFoldingSetNodes.  This handles deletion of\n  // all allocated nodes in one fell swoop.\n  SpecificBumpPtrAllocator<AUFoldingSetNode> AUFoldingSetNodeAllocator;\n\n  // Maps from a pass to it's associated entry in UniqueAnalysisUsages.  Does\n  // not own the storage associated with either key or value..\n  DenseMap<Pass *, AnalysisUsage*> AnUsageMap;\n\n  /// Collection of PassInfo objects found via analysis IDs and in this top\n  /// level manager. This is used to memoize queries to the pass registry.\n  /// FIXME: This is an egregious hack because querying the pass registry is\n  /// either slow or racy.\n  mutable DenseMap<AnalysisID, const PassInfo *> AnalysisPassInfos;\n};\n\n//===----------------------------------------------------------------------===//\n// PMDataManager\n\n/// PMDataManager provides the common place to manage the analysis data\n/// used by pass managers.\nclass PMDataManager {\npublic:\n  explicit PMDataManager() : TPM(nullptr), Depth(0) {\n    initializeAnalysisInfo();\n  }\n\n  virtual ~PMDataManager();\n\n  virtual Pass *getAsPass() = 0;\n\n  /// Augment AvailableAnalysis by adding analysis made available by pass P.\n  void recordAvailableAnalysis(Pass *P);\n\n  /// verifyPreservedAnalysis -- Verify analysis presreved by pass P.\n  void verifyPreservedAnalysis(Pass *P);\n\n  /// Remove Analysis that is not preserved by the pass\n  void removeNotPreservedAnalysis(Pass *P);\n\n  /// Remove dead passes used by P.\n  void removeDeadPasses(Pass *P, StringRef Msg,\n                        enum PassDebuggingString);\n\n  /// Remove P.\n  void freePass(Pass *P, StringRef Msg,\n                enum PassDebuggingString);\n\n  /// Add pass P into the PassVector. Update\n  /// AvailableAnalysis appropriately if ProcessAnalysis is true.\n  void add(Pass *P, bool ProcessAnalysis = true);\n\n  /// Add RequiredPass into list of lower level passes required by pass P.\n  /// RequiredPass is run on the fly by Pass Manager when P requests it\n  /// through getAnalysis interface.\n  virtual void addLowerLevelRequiredPass(Pass *P, Pass *RequiredPass);\n\n  virtual std::tuple<Pass *, bool> getOnTheFlyPass(Pass *P, AnalysisID PI,\n                                                   Function &F);\n\n  /// Initialize available analysis information.\n  void initializeAnalysisInfo() {\n    AvailableAnalysis.clear();\n    for (auto &IA : InheritedAnalysis)\n      IA = nullptr;\n  }\n\n  // Return true if P preserves high level analysis used by other\n  // passes that are managed by this manager.\n  bool preserveHigherLevelAnalysis(Pass *P);\n\n  /// Populate UsedPasses with analysis pass that are used or required by pass\n  /// P and are available. Populate ReqPassNotAvailable with analysis pass that\n  /// are required by pass P but are not available.\n  void collectRequiredAndUsedAnalyses(\n      SmallVectorImpl<Pass *> &UsedPasses,\n      SmallVectorImpl<AnalysisID> &ReqPassNotAvailable, Pass *P);\n\n  /// All Required analyses should be available to the pass as it runs!  Here\n  /// we fill in the AnalysisImpls member of the pass so that it can\n  /// successfully use the getAnalysis() method to retrieve the\n  /// implementations it needs.\n  void initializeAnalysisImpl(Pass *P);\n\n  /// Find the pass that implements Analysis AID. If desired pass is not found\n  /// then return NULL.\n  Pass *findAnalysisPass(AnalysisID AID, bool Direction);\n\n  // Access toplevel manager\n  PMTopLevelManager *getTopLevelManager() { return TPM; }\n  void setTopLevelManager(PMTopLevelManager *T) { TPM = T; }\n\n  unsigned getDepth() const { return Depth; }\n  void setDepth(unsigned newDepth) { Depth = newDepth; }\n\n  // Print routines used by debug-pass\n  void dumpLastUses(Pass *P, unsigned Offset) const;\n  void dumpPassArguments() const;\n  void dumpPassInfo(Pass *P, enum PassDebuggingString S1,\n                    enum PassDebuggingString S2, StringRef Msg);\n  void dumpRequiredSet(const Pass *P) const;\n  void dumpPreservedSet(const Pass *P) const;\n  void dumpUsedSet(const Pass *P) const;\n\n  unsigned getNumContainedPasses() const {\n    return (unsigned)PassVector.size();\n  }\n\n  virtual PassManagerType getPassManagerType() const {\n    assert ( 0 && \"Invalid use of getPassManagerType\");\n    return PMT_Unknown;\n  }\n\n  DenseMap<AnalysisID, Pass*> *getAvailableAnalysis() {\n    return &AvailableAnalysis;\n  }\n\n  // Collect AvailableAnalysis from all the active Pass Managers.\n  void populateInheritedAnalysis(PMStack &PMS) {\n    unsigned Index = 0;\n    for (PMDataManager *PMDM : PMS)\n      InheritedAnalysis[Index++] = PMDM->getAvailableAnalysis();\n  }\n\n  /// Set the initial size of the module if the user has specified that they\n  /// want remarks for size.\n  /// Returns 0 if the remark was not requested.\n  unsigned initSizeRemarkInfo(\n      Module &M,\n      StringMap<std::pair<unsigned, unsigned>> &FunctionToInstrCount);\n\n  /// Emit a remark signifying that the number of IR instructions in the module\n  /// changed.\n  /// \\p F is optionally passed by passes which run on Functions, and thus\n  /// always know whether or not a non-empty function is available.\n  ///\n  /// \\p FunctionToInstrCount maps the name of a \\p Function to a pair. The\n  /// first member of the pair is the IR count of the \\p Function before running\n  /// \\p P, and the second member is the IR count of the \\p Function after\n  /// running \\p P.\n  void emitInstrCountChangedRemark(\n      Pass *P, Module &M, int64_t Delta, unsigned CountBefore,\n      StringMap<std::pair<unsigned, unsigned>> &FunctionToInstrCount,\n      Function *F = nullptr);\n\nprotected:\n  // Top level manager.\n  PMTopLevelManager *TPM;\n\n  // Collection of pass that are managed by this manager\n  SmallVector<Pass *, 16> PassVector;\n\n  // Collection of Analysis provided by Parent pass manager and\n  // used by current pass manager. At at time there can not be more\n  // then PMT_Last active pass mangers.\n  DenseMap<AnalysisID, Pass *> *InheritedAnalysis[PMT_Last];\n\n  /// isPassDebuggingExecutionsOrMore - Return true if -debug-pass=Executions\n  /// or higher is specified.\n  bool isPassDebuggingExecutionsOrMore() const;\n\nprivate:\n  void dumpAnalysisUsage(StringRef Msg, const Pass *P,\n                         const AnalysisUsage::VectorType &Set) const;\n\n  // Set of available Analysis. This information is used while scheduling\n  // pass. If a pass requires an analysis which is not available then\n  // the required analysis pass is scheduled to run before the pass itself is\n  // scheduled to run.\n  DenseMap<AnalysisID, Pass*> AvailableAnalysis;\n\n  // Collection of higher level analysis used by the pass managed by\n  // this manager.\n  SmallVector<Pass *, 16> HigherLevelAnalysis;\n\n  unsigned Depth;\n};\n\n//===----------------------------------------------------------------------===//\n// FPPassManager\n//\n/// FPPassManager manages BBPassManagers and FunctionPasses.\n/// It batches all function passes and basic block pass managers together and\n/// sequence them to process one function at a time before processing next\n/// function.\nclass FPPassManager : public ModulePass, public PMDataManager {\npublic:\n  static char ID;\n  explicit FPPassManager()\n  : ModulePass(ID), PMDataManager() { }\n\n  /// run - Execute all of the passes scheduled for execution.  Keep track of\n  /// whether any of the passes modifies the module, and if so, return true.\n  bool runOnFunction(Function &F);\n  bool runOnModule(Module &M) override;\n\n  /// cleanup - After running all passes, clean up pass manager cache.\n  void cleanup();\n\n  /// doInitialization - Overrides ModulePass doInitialization for global\n  /// initialization tasks\n  ///\n  using ModulePass::doInitialization;\n\n  /// doInitialization - Run all of the initializers for the function passes.\n  ///\n  bool doInitialization(Module &M) override;\n\n  /// doFinalization - Overrides ModulePass doFinalization for global\n  /// finalization tasks\n  ///\n  using ModulePass::doFinalization;\n\n  /// doFinalization - Run all of the finalizers for the function passes.\n  ///\n  bool doFinalization(Module &M) override;\n\n  PMDataManager *getAsPMDataManager() override { return this; }\n  Pass *getAsPass() override { return this; }\n\n  /// Pass Manager itself does not invalidate any analysis info.\n  void getAnalysisUsage(AnalysisUsage &Info) const override {\n    Info.setPreservesAll();\n  }\n\n  // Print passes managed by this manager\n  void dumpPassStructure(unsigned Offset) override;\n\n  StringRef getPassName() const override { return \"Function Pass Manager\"; }\n\n  FunctionPass *getContainedPass(unsigned N) {\n    assert ( N < PassVector.size() && \"Pass number out of range!\");\n    FunctionPass *FP = static_cast<FunctionPass *>(PassVector[N]);\n    return FP;\n  }\n\n  PassManagerType getPassManagerType() const override {\n    return PMT_FunctionPassManager;\n  }\n};\n\n}\n\n#endif\n"}, "35": {"id": 35, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/IR/Metadata.h", "content": "//===- llvm/IR/Metadata.h - Metadata definitions ----------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n/// @file\n/// This file contains the declarations for metadata subclasses.\n/// They represent the different flavors of metadata that live in LLVM.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_IR_METADATA_H\n#define LLVM_IR_METADATA_H\n\n#include \"llvm/ADT/ArrayRef.h\"\n#include \"llvm/ADT/DenseMap.h\"\n#include \"llvm/ADT/DenseMapInfo.h\"\n#include \"llvm/ADT/None.h\"\n#include \"llvm/ADT/PointerUnion.h\"\n#include \"llvm/ADT/STLExtras.h\"\n#include \"llvm/ADT/SmallVector.h\"\n#include \"llvm/ADT/StringMap.h\"\n#include \"llvm/ADT/StringRef.h\"\n#include \"llvm/ADT/ilist_node.h\"\n#include \"llvm/ADT/iterator_range.h\"\n#include \"llvm/IR/Constant.h\"\n#include \"llvm/IR/LLVMContext.h\"\n#include \"llvm/IR/Value.h\"\n#include \"llvm/Support/CBindingWrapping.h\"\n#include \"llvm/Support/Casting.h\"\n#include \"llvm/Support/ErrorHandling.h\"\n#include <cassert>\n#include <cstddef>\n#include <cstdint>\n#include <iterator>\n#include <memory>\n#include <string>\n#include <type_traits>\n#include <utility>\n\nnamespace llvm {\n\nclass Module;\nclass ModuleSlotTracker;\nclass raw_ostream;\nclass Type;\n\nenum LLVMConstants : uint32_t {\n  DEBUG_METADATA_VERSION = 3 // Current debug info version number.\n};\n\n/// Root of the metadata hierarchy.\n///\n/// This is a root class for typeless data in the IR.\nclass Metadata {\n  friend class ReplaceableMetadataImpl;\n\n  /// RTTI.\n  const unsigned char SubclassID;\n\nprotected:\n  /// Active type of storage.\n  enum StorageType { Uniqued, Distinct, Temporary };\n\n  /// Storage flag for non-uniqued, otherwise unowned, metadata.\n  unsigned char Storage : 7;\n\n  unsigned char SubclassData1 : 1;\n  unsigned short SubclassData16 = 0;\n  unsigned SubclassData32 = 0;\n\npublic:\n  enum MetadataKind {\n#define HANDLE_METADATA_LEAF(CLASS) CLASS##Kind,\n#include \"llvm/IR/Metadata.def\"\n  };\n\nprotected:\n  Metadata(unsigned ID, StorageType Storage)\n      : SubclassID(ID), Storage(Storage), SubclassData1(false) {\n    static_assert(sizeof(*this) == 8, \"Metadata fields poorly packed\");\n  }\n\n  ~Metadata() = default;\n\n  /// Default handling of a changed operand, which asserts.\n  ///\n  /// If subclasses pass themselves in as owners to a tracking node reference,\n  /// they must provide an implementation of this method.\n  void handleChangedOperand(void *, Metadata *) {\n    llvm_unreachable(\"Unimplemented in Metadata subclass\");\n  }\n\npublic:\n  unsigned getMetadataID() const { return SubclassID; }\n\n  /// User-friendly dump.\n  ///\n  /// If \\c M is provided, metadata nodes will be numbered canonically;\n  /// otherwise, pointer addresses are substituted.\n  ///\n  /// Note: this uses an explicit overload instead of default arguments so that\n  /// the nullptr version is easy to call from a debugger.\n  ///\n  /// @{\n  void dump() const;\n  void dump(const Module *M) const;\n  /// @}\n\n  /// Print.\n  ///\n  /// Prints definition of \\c this.\n  ///\n  /// If \\c M is provided, metadata nodes will be numbered canonically;\n  /// otherwise, pointer addresses are substituted.\n  /// @{\n  void print(raw_ostream &OS, const Module *M = nullptr,\n             bool IsForDebug = false) const;\n  void print(raw_ostream &OS, ModuleSlotTracker &MST, const Module *M = nullptr,\n             bool IsForDebug = false) const;\n  /// @}\n\n  /// Print as operand.\n  ///\n  /// Prints reference of \\c this.\n  ///\n  /// If \\c M is provided, metadata nodes will be numbered canonically;\n  /// otherwise, pointer addresses are substituted.\n  /// @{\n  void printAsOperand(raw_ostream &OS, const Module *M = nullptr) const;\n  void printAsOperand(raw_ostream &OS, ModuleSlotTracker &MST,\n                      const Module *M = nullptr) const;\n  /// @}\n};\n\n// Create wrappers for C Binding types (see CBindingWrapping.h).\nDEFINE_ISA_CONVERSION_FUNCTIONS(Metadata, LLVMMetadataRef)\n\n// Specialized opaque metadata conversions.\ninline Metadata **unwrap(LLVMMetadataRef *MDs) {\n  return reinterpret_cast<Metadata**>(MDs);\n}\n\n#define HANDLE_METADATA(CLASS) class CLASS;\n#include \"llvm/IR/Metadata.def\"\n\n// Provide specializations of isa so that we don't need definitions of\n// subclasses to see if the metadata is a subclass.\n#define HANDLE_METADATA_LEAF(CLASS)                                            \\\n  template <> struct isa_impl<CLASS, Metadata> {                               \\\n    static inline bool doit(const Metadata &MD) {                              \\\n      return MD.getMetadataID() == Metadata::CLASS##Kind;                      \\\n    }                                                                          \\\n  };\n#include \"llvm/IR/Metadata.def\"\n\ninline raw_ostream &operator<<(raw_ostream &OS, const Metadata &MD) {\n  MD.print(OS);\n  return OS;\n}\n\n/// Metadata wrapper in the Value hierarchy.\n///\n/// A member of the \\a Value hierarchy to represent a reference to metadata.\n/// This allows, e.g., instrinsics to have metadata as operands.\n///\n/// Notably, this is the only thing in either hierarchy that is allowed to\n/// reference \\a LocalAsMetadata.\nclass MetadataAsValue : public Value {\n  friend class ReplaceableMetadataImpl;\n  friend class LLVMContextImpl;\n\n  Metadata *MD;\n\n  MetadataAsValue(Type *Ty, Metadata *MD);\n\n  /// Drop use of metadata (during teardown).\n  void dropUse() { MD = nullptr; }\n\npublic:\n  ~MetadataAsValue();\n\n  static MetadataAsValue *get(LLVMContext &Context, Metadata *MD);\n  static MetadataAsValue *getIfExists(LLVMContext &Context, Metadata *MD);\n\n  Metadata *getMetadata() const { return MD; }\n\n  static bool classof(const Value *V) {\n    return V->getValueID() == MetadataAsValueVal;\n  }\n\nprivate:\n  void handleChangedMetadata(Metadata *MD);\n  void track();\n  void untrack();\n};\n\n/// API for tracking metadata references through RAUW and deletion.\n///\n/// Shared API for updating \\a Metadata pointers in subclasses that support\n/// RAUW.\n///\n/// This API is not meant to be used directly.  See \\a TrackingMDRef for a\n/// user-friendly tracking reference.\nclass MetadataTracking {\npublic:\n  /// Track the reference to metadata.\n  ///\n  /// Register \\c MD with \\c *MD, if the subclass supports tracking.  If \\c *MD\n  /// gets RAUW'ed, \\c MD will be updated to the new address.  If \\c *MD gets\n  /// deleted, \\c MD will be set to \\c nullptr.\n  ///\n  /// If tracking isn't supported, \\c *MD will not change.\n  ///\n  /// \\return true iff tracking is supported by \\c MD.\n  static bool track(Metadata *&MD) {\n    return track(&MD, *MD, static_cast<Metadata *>(nullptr));\n  }\n\n  /// Track the reference to metadata for \\a Metadata.\n  ///\n  /// As \\a track(Metadata*&), but with support for calling back to \\c Owner to\n  /// tell it that its operand changed.  This could trigger \\c Owner being\n  /// re-uniqued.\n  static bool track(void *Ref, Metadata &MD, Metadata &Owner) {\n    return track(Ref, MD, &Owner);\n  }\n\n  /// Track the reference to metadata for \\a MetadataAsValue.\n  ///\n  /// As \\a track(Metadata*&), but with support for calling back to \\c Owner to\n  /// tell it that its operand changed.  This could trigger \\c Owner being\n  /// re-uniqued.\n  static bool track(void *Ref, Metadata &MD, MetadataAsValue &Owner) {\n    return track(Ref, MD, &Owner);\n  }\n\n  /// Stop tracking a reference to metadata.\n  ///\n  /// Stops \\c *MD from tracking \\c MD.\n  static void untrack(Metadata *&MD) { untrack(&MD, *MD); }\n  static void untrack(void *Ref, Metadata &MD);\n\n  /// Move tracking from one reference to another.\n  ///\n  /// Semantically equivalent to \\c untrack(MD) followed by \\c track(New),\n  /// except that ownership callbacks are maintained.\n  ///\n  /// Note: it is an error if \\c *MD does not equal \\c New.\n  ///\n  /// \\return true iff tracking is supported by \\c MD.\n  static bool retrack(Metadata *&MD, Metadata *&New) {\n    return retrack(&MD, *MD, &New);\n  }\n  static bool retrack(void *Ref, Metadata &MD, void *New);\n\n  /// Check whether metadata is replaceable.\n  static bool isReplaceable(const Metadata &MD);\n\n  using OwnerTy = PointerUnion<MetadataAsValue *, Metadata *>;\n\nprivate:\n  /// Track a reference to metadata for an owner.\n  ///\n  /// Generalized version of tracking.\n  static bool track(void *Ref, Metadata &MD, OwnerTy Owner);\n};\n\n/// Shared implementation of use-lists for replaceable metadata.\n///\n/// Most metadata cannot be RAUW'ed.  This is a shared implementation of\n/// use-lists and associated API for the two that support it (\\a ValueAsMetadata\n/// and \\a TempMDNode).\nclass ReplaceableMetadataImpl {\n  friend class MetadataTracking;\n\npublic:\n  using OwnerTy = MetadataTracking::OwnerTy;\n\nprivate:\n  LLVMContext &Context;\n  uint64_t NextIndex = 0;\n  SmallDenseMap<void *, std::pair<OwnerTy, uint64_t>, 4> UseMap;\n\npublic:\n  ReplaceableMetadataImpl(LLVMContext &Context) : Context(Context) {}\n\n  ~ReplaceableMetadataImpl() {\n    assert(UseMap.empty() && \"Cannot destroy in-use replaceable metadata\");\n  }\n\n  LLVMContext &getContext() const { return Context; }\n\n  /// Replace all uses of this with MD.\n  ///\n  /// Replace all uses of this with \\c MD, which is allowed to be null.\n  void replaceAllUsesWith(Metadata *MD);\n\n  /// Returns the list of all DIArgList users of this.\n  SmallVector<Metadata *, 4> getAllArgListUsers();\n\n  /// Resolve all uses of this.\n  ///\n  /// Resolve all uses of this, turning off RAUW permanently.  If \\c\n  /// ResolveUsers, call \\a MDNode::resolve() on any users whose last operand\n  /// is resolved.\n  void resolveAllUses(bool ResolveUsers = true);\n\nprivate:\n  void addRef(void *Ref, OwnerTy Owner);\n  void dropRef(void *Ref);\n  void moveRef(void *Ref, void *New, const Metadata &MD);\n\n  /// Lazily construct RAUW support on MD.\n  ///\n  /// If this is an unresolved MDNode, RAUW support will be created on-demand.\n  /// ValueAsMetadata always has RAUW support.\n  static ReplaceableMetadataImpl *getOrCreate(Metadata &MD);\n\n  /// Get RAUW support on MD, if it exists.\n  static ReplaceableMetadataImpl *getIfExists(Metadata &MD);\n\n  /// Check whether this node will support RAUW.\n  ///\n  /// Returns \\c true unless getOrCreate() would return null.\n  static bool isReplaceable(const Metadata &MD);\n};\n\n/// Value wrapper in the Metadata hierarchy.\n///\n/// This is a custom value handle that allows other metadata to refer to\n/// classes in the Value hierarchy.\n///\n/// Because of full uniquing support, each value is only wrapped by a single \\a\n/// ValueAsMetadata object, so the lookup maps are far more efficient than\n/// those using ValueHandleBase.\nclass ValueAsMetadata : public Metadata, ReplaceableMetadataImpl {\n  friend class ReplaceableMetadataImpl;\n  friend class LLVMContextImpl;\n\n  Value *V;\n\n  /// Drop users without RAUW (during teardown).\n  void dropUsers() {\n    ReplaceableMetadataImpl::resolveAllUses(/* ResolveUsers */ false);\n  }\n\nprotected:\n  ValueAsMetadata(unsigned ID, Value *V)\n      : Metadata(ID, Uniqued), ReplaceableMetadataImpl(V->getContext()), V(V) {\n    assert(V && \"Expected valid value\");\n  }\n\n  ~ValueAsMetadata() = default;\n\npublic:\n  static ValueAsMetadata *get(Value *V);\n\n  static ConstantAsMetadata *getConstant(Value *C) {\n    return cast<ConstantAsMetadata>(get(C));\n  }\n\n  static LocalAsMetadata *getLocal(Value *Local) {\n    return cast<LocalAsMetadata>(get(Local));\n  }\n\n  static ValueAsMetadata *getIfExists(Value *V);\n\n  static ConstantAsMetadata *getConstantIfExists(Value *C) {\n    return cast_or_null<ConstantAsMetadata>(getIfExists(C));\n  }\n\n  static LocalAsMetadata *getLocalIfExists(Value *Local) {\n    return cast_or_null<LocalAsMetadata>(getIfExists(Local));\n  }\n\n  Value *getValue() const { return V; }\n  Type *getType() const { return V->getType(); }\n  LLVMContext &getContext() const { return V->getContext(); }\n\n  SmallVector<Metadata *, 4> getAllArgListUsers() {\n    return ReplaceableMetadataImpl::getAllArgListUsers();\n  }\n\n  static void handleDeletion(Value *V);\n  static void handleRAUW(Value *From, Value *To);\n\nprotected:\n  /// Handle collisions after \\a Value::replaceAllUsesWith().\n  ///\n  /// RAUW isn't supported directly for \\a ValueAsMetadata, but if the wrapped\n  /// \\a Value gets RAUW'ed and the target already exists, this is used to\n  /// merge the two metadata nodes.\n  void replaceAllUsesWith(Metadata *MD) {\n    ReplaceableMetadataImpl::replaceAllUsesWith(MD);\n  }\n\npublic:\n  static bool classof(const Metadata *MD) {\n    return MD->getMetadataID() == LocalAsMetadataKind ||\n           MD->getMetadataID() == ConstantAsMetadataKind;\n  }\n};\n\nclass ConstantAsMetadata : public ValueAsMetadata {\n  friend class ValueAsMetadata;\n\n  ConstantAsMetadata(Constant *C)\n      : ValueAsMetadata(ConstantAsMetadataKind, C) {}\n\npublic:\n  static ConstantAsMetadata *get(Constant *C) {\n    return ValueAsMetadata::getConstant(C);\n  }\n\n  static ConstantAsMetadata *getIfExists(Constant *C) {\n    return ValueAsMetadata::getConstantIfExists(C);\n  }\n\n  Constant *getValue() const {\n    return cast<Constant>(ValueAsMetadata::getValue());\n  }\n\n  static bool classof(const Metadata *MD) {\n    return MD->getMetadataID() == ConstantAsMetadataKind;\n  }\n};\n\nclass LocalAsMetadata : public ValueAsMetadata {\n  friend class ValueAsMetadata;\n\n  LocalAsMetadata(Value *Local)\n      : ValueAsMetadata(LocalAsMetadataKind, Local) {\n    assert(!isa<Constant>(Local) && \"Expected local value\");\n  }\n\npublic:\n  static LocalAsMetadata *get(Value *Local) {\n    return ValueAsMetadata::getLocal(Local);\n  }\n\n  static LocalAsMetadata *getIfExists(Value *Local) {\n    return ValueAsMetadata::getLocalIfExists(Local);\n  }\n\n  static bool classof(const Metadata *MD) {\n    return MD->getMetadataID() == LocalAsMetadataKind;\n  }\n};\n\n/// Transitional API for extracting constants from Metadata.\n///\n/// This namespace contains transitional functions for metadata that points to\n/// \\a Constants.\n///\n/// In prehistory -- when metadata was a subclass of \\a Value -- \\a MDNode\n/// operands could refer to any \\a Value.  There's was a lot of code like this:\n///\n/// \\code\n///     MDNode *N = ...;\n///     auto *CI = dyn_cast<ConstantInt>(N->getOperand(2));\n/// \\endcode\n///\n/// Now that \\a Value and \\a Metadata are in separate hierarchies, maintaining\n/// the semantics for \\a isa(), \\a cast(), \\a dyn_cast() (etc.) requires three\n/// steps: cast in the \\a Metadata hierarchy, extraction of the \\a Value, and\n/// cast in the \\a Value hierarchy.  Besides creating boiler-plate, this\n/// requires subtle control flow changes.\n///\n/// The end-goal is to create a new type of metadata, called (e.g.) \\a MDInt,\n/// so that metadata can refer to numbers without traversing a bridge to the \\a\n/// Value hierarchy.  In this final state, the code above would look like this:\n///\n/// \\code\n///     MDNode *N = ...;\n///     auto *MI = dyn_cast<MDInt>(N->getOperand(2));\n/// \\endcode\n///\n/// The API in this namespace supports the transition.  \\a MDInt doesn't exist\n/// yet, and even once it does, changing each metadata schema to use it is its\n/// own mini-project.  In the meantime this API prevents us from introducing\n/// complex and bug-prone control flow that will disappear in the end.  In\n/// particular, the above code looks like this:\n///\n/// \\code\n///     MDNode *N = ...;\n///     auto *CI = mdconst::dyn_extract<ConstantInt>(N->getOperand(2));\n/// \\endcode\n///\n/// The full set of provided functions includes:\n///\n///   mdconst::hasa                <=> isa\n///   mdconst::extract             <=> cast\n///   mdconst::extract_or_null     <=> cast_or_null\n///   mdconst::dyn_extract         <=> dyn_cast\n///   mdconst::dyn_extract_or_null <=> dyn_cast_or_null\n///\n/// The target of the cast must be a subclass of \\a Constant.\nnamespace mdconst {\n\nnamespace detail {\n\ntemplate <class T> T &make();\ntemplate <class T, class Result> struct HasDereference {\n  using Yes = char[1];\n  using No = char[2];\n  template <size_t N> struct SFINAE {};\n\n  template <class U, class V>\n  static Yes &hasDereference(SFINAE<sizeof(static_cast<V>(*make<U>()))> * = 0);\n  template <class U, class V> static No &hasDereference(...);\n\n  static const bool value =\n      sizeof(hasDereference<T, Result>(nullptr)) == sizeof(Yes);\n};\ntemplate <class V, class M> struct IsValidPointer {\n  static const bool value = std::is_base_of<Constant, V>::value &&\n                            HasDereference<M, const Metadata &>::value;\n};\ntemplate <class V, class M> struct IsValidReference {\n  static const bool value = std::is_base_of<Constant, V>::value &&\n                            std::is_convertible<M, const Metadata &>::value;\n};\n\n} // end namespace detail\n\n/// Check whether Metadata has a Value.\n///\n/// As an analogue to \\a isa(), check whether \\c MD has an \\a Value inside of\n/// type \\c X.\ntemplate <class X, class Y>\ninline std::enable_if_t<detail::IsValidPointer<X, Y>::value, bool>\nhasa(Y &&MD) {\n  assert(MD && \"Null pointer sent into hasa\");\n  if (auto *V = dyn_cast<ConstantAsMetadata>(MD))\n    return isa<X>(V->getValue());\n  return false;\n}\ntemplate <class X, class Y>\ninline std::enable_if_t<detail::IsValidReference<X, Y &>::value, bool>\nhasa(Y &MD) {\n  return hasa(&MD);\n}\n\n/// Extract a Value from Metadata.\n///\n/// As an analogue to \\a cast(), extract the \\a Value subclass \\c X from \\c MD.\ntemplate <class X, class Y>\ninline std::enable_if_t<detail::IsValidPointer<X, Y>::value, X *>\nextract(Y &&MD) {\n  return cast<X>(cast<ConstantAsMetadata>(MD)->getValue());\n}\ntemplate <class X, class Y>\ninline std::enable_if_t<detail::IsValidReference<X, Y &>::value, X *>\nextract(Y &MD) {\n  return extract(&MD);\n}\n\n/// Extract a Value from Metadata, allowing null.\n///\n/// As an analogue to \\a cast_or_null(), extract the \\a Value subclass \\c X\n/// from \\c MD, allowing \\c MD to be null.\ntemplate <class X, class Y>\ninline std::enable_if_t<detail::IsValidPointer<X, Y>::value, X *>\nextract_or_null(Y &&MD) {\n  if (auto *V = cast_or_null<ConstantAsMetadata>(MD))\n    return cast<X>(V->getValue());\n  return nullptr;\n}\n\n/// Extract a Value from Metadata, if any.\n///\n/// As an analogue to \\a dyn_cast_or_null(), extract the \\a Value subclass \\c X\n/// from \\c MD, return null if \\c MD doesn't contain a \\a Value or if the \\a\n/// Value it does contain is of the wrong subclass.\ntemplate <class X, class Y>\ninline std::enable_if_t<detail::IsValidPointer<X, Y>::value, X *>\ndyn_extract(Y &&MD) {\n  if (auto *V = dyn_cast<ConstantAsMetadata>(MD))\n    return dyn_cast<X>(V->getValue());\n  return nullptr;\n}\n\n/// Extract a Value from Metadata, if any, allowing null.\n///\n/// As an analogue to \\a dyn_cast_or_null(), extract the \\a Value subclass \\c X\n/// from \\c MD, return null if \\c MD doesn't contain a \\a Value or if the \\a\n/// Value it does contain is of the wrong subclass, allowing \\c MD to be null.\ntemplate <class X, class Y>\ninline std::enable_if_t<detail::IsValidPointer<X, Y>::value, X *>\ndyn_extract_or_null(Y &&MD) {\n  if (auto *V = dyn_cast_or_null<ConstantAsMetadata>(MD))\n    return dyn_cast<X>(V->getValue());\n  return nullptr;\n}\n\n} // end namespace mdconst\n\n//===----------------------------------------------------------------------===//\n/// A single uniqued string.\n///\n/// These are used to efficiently contain a byte sequence for metadata.\n/// MDString is always unnamed.\nclass MDString : public Metadata {\n  friend class StringMapEntryStorage<MDString>;\n\n  StringMapEntry<MDString> *Entry = nullptr;\n\n  MDString() : Metadata(MDStringKind, Uniqued) {}\n\npublic:\n  MDString(const MDString &) = delete;\n  MDString &operator=(MDString &&) = delete;\n  MDString &operator=(const MDString &) = delete;\n\n  static MDString *get(LLVMContext &Context, StringRef Str);\n  static MDString *get(LLVMContext &Context, const char *Str) {\n    return get(Context, Str ? StringRef(Str) : StringRef());\n  }\n\n  StringRef getString() const;\n\n  unsigned getLength() const { return (unsigned)getString().size(); }\n\n  using iterator = StringRef::iterator;\n\n  /// Pointer to the first byte of the string.\n  iterator begin() const { return getString().begin(); }\n\n  /// Pointer to one byte past the end of the string.\n  iterator end() const { return getString().end(); }\n\n  const unsigned char *bytes_begin() const { return getString().bytes_begin(); }\n  const unsigned char *bytes_end() const { return getString().bytes_end(); }\n\n  /// Methods for support type inquiry through isa, cast, and dyn_cast.\n  static bool classof(const Metadata *MD) {\n    return MD->getMetadataID() == MDStringKind;\n  }\n};\n\n/// A collection of metadata nodes that might be associated with a\n/// memory access used by the alias-analysis infrastructure.\nstruct AAMDNodes {\n  explicit AAMDNodes() = default;\n  explicit AAMDNodes(MDNode *T, MDNode *TS, MDNode *S, MDNode *N)\n      : TBAA(T), TBAAStruct(TS), Scope(S), NoAlias(N) {}\n\n  bool operator==(const AAMDNodes &A) const {\n    return TBAA == A.TBAA && TBAAStruct == A.TBAAStruct && Scope == A.Scope &&\n           NoAlias == A.NoAlias;\n  }\n\n  bool operator!=(const AAMDNodes &A) const { return !(*this == A); }\n\n  explicit operator bool() const {\n    return TBAA || TBAAStruct || Scope || NoAlias;\n  }\n\n  /// The tag for type-based alias analysis.\n  MDNode *TBAA = nullptr;\n\n  /// The tag for type-based alias analysis (tbaa struct).\n  MDNode *TBAAStruct = nullptr;\n\n  /// The tag for alias scope specification (used with noalias).\n  MDNode *Scope = nullptr;\n\n  /// The tag specifying the noalias scope.\n  MDNode *NoAlias = nullptr;\n\n  // Shift tbaa Metadata node to start off bytes later\n  static MDNode *ShiftTBAA(MDNode *M, size_t off);\n\n  // Shift tbaa.struct Metadata node to start off bytes later\n  static MDNode *ShiftTBAAStruct(MDNode *M, size_t off);\n\n  /// Given two sets of AAMDNodes that apply to the same pointer,\n  /// give the best AAMDNodes that are compatible with both (i.e. a set of\n  /// nodes whose allowable aliasing conclusions are a subset of those\n  /// allowable by both of the inputs). However, for efficiency\n  /// reasons, do not create any new MDNodes.\n  AAMDNodes intersect(const AAMDNodes &Other) {\n    AAMDNodes Result;\n    Result.TBAA = Other.TBAA == TBAA ? TBAA : nullptr;\n    Result.TBAAStruct = Other.TBAAStruct == TBAAStruct ? TBAAStruct : nullptr;\n    Result.Scope = Other.Scope == Scope ? Scope : nullptr;\n    Result.NoAlias = Other.NoAlias == NoAlias ? NoAlias : nullptr;\n    return Result;\n  }\n\n  /// Create a new AAMDNode that describes this AAMDNode after applying a\n  /// constant offset to the start of the pointer\n  AAMDNodes shift(size_t Offset) {\n    AAMDNodes Result;\n    Result.TBAA = TBAA ? ShiftTBAA(TBAA, Offset) : nullptr;\n    Result.TBAAStruct =\n        TBAAStruct ? ShiftTBAAStruct(TBAAStruct, Offset) : nullptr;\n    Result.Scope = Scope;\n    Result.NoAlias = NoAlias;\n    return Result;\n  }\n};\n\n// Specialize DenseMapInfo for AAMDNodes.\ntemplate<>\nstruct DenseMapInfo<AAMDNodes> {\n  static inline AAMDNodes getEmptyKey() {\n    return AAMDNodes(DenseMapInfo<MDNode *>::getEmptyKey(),\n                     nullptr, nullptr, nullptr);\n  }\n\n  static inline AAMDNodes getTombstoneKey() {\n    return AAMDNodes(DenseMapInfo<MDNode *>::getTombstoneKey(),\n                     nullptr, nullptr, nullptr);\n  }\n\n  static unsigned getHashValue(const AAMDNodes &Val) {\n    return DenseMapInfo<MDNode *>::getHashValue(Val.TBAA) ^\n           DenseMapInfo<MDNode *>::getHashValue(Val.TBAAStruct) ^\n           DenseMapInfo<MDNode *>::getHashValue(Val.Scope) ^\n           DenseMapInfo<MDNode *>::getHashValue(Val.NoAlias);\n  }\n\n  static bool isEqual(const AAMDNodes &LHS, const AAMDNodes &RHS) {\n    return LHS == RHS;\n  }\n};\n\n/// Tracking metadata reference owned by Metadata.\n///\n/// Similar to \\a TrackingMDRef, but it's expected to be owned by an instance\n/// of \\a Metadata, which has the option of registering itself for callbacks to\n/// re-unique itself.\n///\n/// In particular, this is used by \\a MDNode.\nclass MDOperand {\n  Metadata *MD = nullptr;\n\npublic:\n  MDOperand() = default;\n  MDOperand(MDOperand &&) = delete;\n  MDOperand(const MDOperand &) = delete;\n  MDOperand &operator=(MDOperand &&) = delete;\n  MDOperand &operator=(const MDOperand &) = delete;\n  ~MDOperand() { untrack(); }\n\n  Metadata *get() const { return MD; }\n  operator Metadata *() const { return get(); }\n  Metadata *operator->() const { return get(); }\n  Metadata &operator*() const { return *get(); }\n\n  void reset() {\n    untrack();\n    MD = nullptr;\n  }\n  void reset(Metadata *MD, Metadata *Owner) {\n    untrack();\n    this->MD = MD;\n    track(Owner);\n  }\n\nprivate:\n  void track(Metadata *Owner) {\n    if (MD) {\n      if (Owner)\n        MetadataTracking::track(this, *MD, *Owner);\n      else\n        MetadataTracking::track(MD);\n    }\n  }\n\n  void untrack() {\n    assert(static_cast<void *>(this) == &MD && \"Expected same address\");\n    if (MD)\n      MetadataTracking::untrack(MD);\n  }\n};\n\ntemplate <> struct simplify_type<MDOperand> {\n  using SimpleType = Metadata *;\n\n  static SimpleType getSimplifiedValue(MDOperand &MD) { return MD.get(); }\n};\n\ntemplate <> struct simplify_type<const MDOperand> {\n  using SimpleType = Metadata *;\n\n  static SimpleType getSimplifiedValue(const MDOperand &MD) { return MD.get(); }\n};\n\n/// Pointer to the context, with optional RAUW support.\n///\n/// Either a raw (non-null) pointer to the \\a LLVMContext, or an owned pointer\n/// to \\a ReplaceableMetadataImpl (which has a reference to \\a LLVMContext).\nclass ContextAndReplaceableUses {\n  PointerUnion<LLVMContext *, ReplaceableMetadataImpl *> Ptr;\n\npublic:\n  ContextAndReplaceableUses(LLVMContext &Context) : Ptr(&Context) {}\n  ContextAndReplaceableUses(\n      std::unique_ptr<ReplaceableMetadataImpl> ReplaceableUses)\n      : Ptr(ReplaceableUses.release()) {\n    assert(getReplaceableUses() && \"Expected non-null replaceable uses\");\n  }\n  ContextAndReplaceableUses() = delete;\n  ContextAndReplaceableUses(ContextAndReplaceableUses &&) = delete;\n  ContextAndReplaceableUses(const ContextAndReplaceableUses &) = delete;\n  ContextAndReplaceableUses &operator=(ContextAndReplaceableUses &&) = delete;\n  ContextAndReplaceableUses &\n  operator=(const ContextAndReplaceableUses &) = delete;\n  ~ContextAndReplaceableUses() { delete getReplaceableUses(); }\n\n  operator LLVMContext &() { return getContext(); }\n\n  /// Whether this contains RAUW support.\n  bool hasReplaceableUses() const {\n    return Ptr.is<ReplaceableMetadataImpl *>();\n  }\n\n  LLVMContext &getContext() const {\n    if (hasReplaceableUses())\n      return getReplaceableUses()->getContext();\n    return *Ptr.get<LLVMContext *>();\n  }\n\n  ReplaceableMetadataImpl *getReplaceableUses() const {\n    if (hasReplaceableUses())\n      return Ptr.get<ReplaceableMetadataImpl *>();\n    return nullptr;\n  }\n\n  /// Ensure that this has RAUW support, and then return it.\n  ReplaceableMetadataImpl *getOrCreateReplaceableUses() {\n    if (!hasReplaceableUses())\n      makeReplaceable(std::make_unique<ReplaceableMetadataImpl>(getContext()));\n    return getReplaceableUses();\n  }\n\n  /// Assign RAUW support to this.\n  ///\n  /// Make this replaceable, taking ownership of \\c ReplaceableUses (which must\n  /// not be null).\n  void\n  makeReplaceable(std::unique_ptr<ReplaceableMetadataImpl> ReplaceableUses) {\n    assert(ReplaceableUses && \"Expected non-null replaceable uses\");\n    assert(&ReplaceableUses->getContext() == &getContext() &&\n           \"Expected same context\");\n    delete getReplaceableUses();\n    Ptr = ReplaceableUses.release();\n  }\n\n  /// Drop RAUW support.\n  ///\n  /// Cede ownership of RAUW support, returning it.\n  std::unique_ptr<ReplaceableMetadataImpl> takeReplaceableUses() {\n    assert(hasReplaceableUses() && \"Expected to own replaceable uses\");\n    std::unique_ptr<ReplaceableMetadataImpl> ReplaceableUses(\n        getReplaceableUses());\n    Ptr = &ReplaceableUses->getContext();\n    return ReplaceableUses;\n  }\n};\n\nstruct TempMDNodeDeleter {\n  inline void operator()(MDNode *Node) const;\n};\n\n#define HANDLE_MDNODE_LEAF(CLASS)                                              \\\n  using Temp##CLASS = std::unique_ptr<CLASS, TempMDNodeDeleter>;\n#define HANDLE_MDNODE_BRANCH(CLASS) HANDLE_MDNODE_LEAF(CLASS)\n#include \"llvm/IR/Metadata.def\"\n\n/// Metadata node.\n///\n/// Metadata nodes can be uniqued, like constants, or distinct.  Temporary\n/// metadata nodes (with full support for RAUW) can be used to delay uniquing\n/// until forward references are known.  The basic metadata node is an \\a\n/// MDTuple.\n///\n/// There is limited support for RAUW at construction time.  At construction\n/// time, if any operand is a temporary node (or an unresolved uniqued node,\n/// which indicates a transitive temporary operand), the node itself will be\n/// unresolved.  As soon as all operands become resolved, it will drop RAUW\n/// support permanently.\n///\n/// If an unresolved node is part of a cycle, \\a resolveCycles() needs\n/// to be called on some member of the cycle once all temporary nodes have been\n/// replaced.\nclass MDNode : public Metadata {\n  friend class ReplaceableMetadataImpl;\n  friend class LLVMContextImpl;\n\n  unsigned NumOperands;\n  unsigned NumUnresolved;\n\n  ContextAndReplaceableUses Context;\n\nprotected:\n  MDNode(LLVMContext &Context, unsigned ID, StorageType Storage,\n         ArrayRef<Metadata *> Ops1, ArrayRef<Metadata *> Ops2 = None);\n  ~MDNode() = default;\n\n  void *operator new(size_t Size, unsigned NumOps);\n  void operator delete(void *Mem);\n\n  /// Required by std, but never called.\n  void operator delete(void *, unsigned) {\n    llvm_unreachable(\"Constructor throws?\");\n  }\n\n  /// Required by std, but never called.\n  void operator delete(void *, unsigned, bool) {\n    llvm_unreachable(\"Constructor throws?\");\n  }\n\n  void dropAllReferences();\n\n  MDOperand *mutable_begin() { return mutable_end() - NumOperands; }\n  MDOperand *mutable_end() { return reinterpret_cast<MDOperand *>(this); }\n\n  using mutable_op_range = iterator_range<MDOperand *>;\n\n  mutable_op_range mutable_operands() {\n    return mutable_op_range(mutable_begin(), mutable_end());\n  }\n\npublic:\n  MDNode(const MDNode &) = delete;\n  void operator=(const MDNode &) = delete;\n  void *operator new(size_t) = delete;\n\n  static inline MDTuple *get(LLVMContext &Context, ArrayRef<Metadata *> MDs);\n  static inline MDTuple *getIfExists(LLVMContext &Context,\n                                     ArrayRef<Metadata *> MDs);\n  static inline MDTuple *getDistinct(LLVMContext &Context,\n                                     ArrayRef<Metadata *> MDs);\n  static inline TempMDTuple getTemporary(LLVMContext &Context,\n                                         ArrayRef<Metadata *> MDs);\n\n  /// Create a (temporary) clone of this.\n  TempMDNode clone() const;\n\n  /// Deallocate a node created by getTemporary.\n  ///\n  /// Calls \\c replaceAllUsesWith(nullptr) before deleting, so any remaining\n  /// references will be reset.\n  static void deleteTemporary(MDNode *N);\n\n  LLVMContext &getContext() const { return Context.getContext(); }\n\n  /// Replace a specific operand.\n  void replaceOperandWith(unsigned I, Metadata *New);\n\n  /// Check if node is fully resolved.\n  ///\n  /// If \\a isTemporary(), this always returns \\c false; if \\a isDistinct(),\n  /// this always returns \\c true.\n  ///\n  /// If \\a isUniqued(), returns \\c true if this has already dropped RAUW\n  /// support (because all operands are resolved).\n  ///\n  /// As forward declarations are resolved, their containers should get\n  /// resolved automatically.  However, if this (or one of its operands) is\n  /// involved in a cycle, \\a resolveCycles() needs to be called explicitly.\n  bool isResolved() const { return !isTemporary() && !NumUnresolved; }\n\n  bool isUniqued() const { return Storage == Uniqued; }\n  bool isDistinct() const { return Storage == Distinct; }\n  bool isTemporary() const { return Storage == Temporary; }\n\n  /// RAUW a temporary.\n  ///\n  /// \\pre \\a isTemporary() must be \\c true.\n  void replaceAllUsesWith(Metadata *MD) {\n    assert(isTemporary() && \"Expected temporary node\");\n    if (Context.hasReplaceableUses())\n      Context.getReplaceableUses()->replaceAllUsesWith(MD);\n  }\n\n  /// Resolve cycles.\n  ///\n  /// Once all forward declarations have been resolved, force cycles to be\n  /// resolved.\n  ///\n  /// \\pre No operands (or operands' operands, etc.) have \\a isTemporary().\n  void resolveCycles();\n\n  /// Resolve a unique, unresolved node.\n  void resolve();\n\n  /// Replace a temporary node with a permanent one.\n  ///\n  /// Try to create a uniqued version of \\c N -- in place, if possible -- and\n  /// return it.  If \\c N cannot be uniqued, return a distinct node instead.\n  template <class T>\n  static std::enable_if_t<std::is_base_of<MDNode, T>::value, T *>\n  replaceWithPermanent(std::unique_ptr<T, TempMDNodeDeleter> N) {\n    return cast<T>(N.release()->replaceWithPermanentImpl());\n  }\n\n  /// Replace a temporary node with a uniqued one.\n  ///\n  /// Create a uniqued version of \\c N -- in place, if possible -- and return\n  /// it.  Takes ownership of the temporary node.\n  ///\n  /// \\pre N does not self-reference.\n  template <class T>\n  static std::enable_if_t<std::is_base_of<MDNode, T>::value, T *>\n  replaceWithUniqued(std::unique_ptr<T, TempMDNodeDeleter> N) {\n    return cast<T>(N.release()->replaceWithUniquedImpl());\n  }\n\n  /// Replace a temporary node with a distinct one.\n  ///\n  /// Create a distinct version of \\c N -- in place, if possible -- and return\n  /// it.  Takes ownership of the temporary node.\n  template <class T>\n  static std::enable_if_t<std::is_base_of<MDNode, T>::value, T *>\n  replaceWithDistinct(std::unique_ptr<T, TempMDNodeDeleter> N) {\n    return cast<T>(N.release()->replaceWithDistinctImpl());\n  }\n\nprivate:\n  MDNode *replaceWithPermanentImpl();\n  MDNode *replaceWithUniquedImpl();\n  MDNode *replaceWithDistinctImpl();\n\nprotected:\n  /// Set an operand.\n  ///\n  /// Sets the operand directly, without worrying about uniquing.\n  void setOperand(unsigned I, Metadata *New);\n\n  void storeDistinctInContext();\n  template <class T, class StoreT>\n  static T *storeImpl(T *N, StorageType Storage, StoreT &Store);\n  template <class T> static T *storeImpl(T *N, StorageType Storage);\n\nprivate:\n  void handleChangedOperand(void *Ref, Metadata *New);\n\n  /// Drop RAUW support, if any.\n  void dropReplaceableUses();\n\n  void resolveAfterOperandChange(Metadata *Old, Metadata *New);\n  void decrementUnresolvedOperandCount();\n  void countUnresolvedOperands();\n\n  /// Mutate this to be \"uniqued\".\n  ///\n  /// Mutate this so that \\a isUniqued().\n  /// \\pre \\a isTemporary().\n  /// \\pre already added to uniquing set.\n  void makeUniqued();\n\n  /// Mutate this to be \"distinct\".\n  ///\n  /// Mutate this so that \\a isDistinct().\n  /// \\pre \\a isTemporary().\n  void makeDistinct();\n\n  void deleteAsSubclass();\n  MDNode *uniquify();\n  void eraseFromStore();\n\n  template <class NodeTy> struct HasCachedHash;\n  template <class NodeTy>\n  static void dispatchRecalculateHash(NodeTy *N, std::true_type) {\n    N->recalculateHash();\n  }\n  template <class NodeTy>\n  static void dispatchRecalculateHash(NodeTy *, std::false_type) {}\n  template <class NodeTy>\n  static void dispatchResetHash(NodeTy *N, std::true_type) {\n    N->setHash(0);\n  }\n  template <class NodeTy>\n  static void dispatchResetHash(NodeTy *, std::false_type) {}\n\npublic:\n  using op_iterator = const MDOperand *;\n  using op_range = iterator_range<op_iterator>;\n\n  op_iterator op_begin() const {\n    return const_cast<MDNode *>(this)->mutable_begin();\n  }\n\n  op_iterator op_end() const {\n    return const_cast<MDNode *>(this)->mutable_end();\n  }\n\n  op_range operands() const { return op_range(op_begin(), op_end()); }\n\n  const MDOperand &getOperand(unsigned I) const {\n    assert(I < NumOperands && \"Out of range\");\n    return op_begin()[I];\n  }\n\n  /// Return number of MDNode operands.\n  unsigned getNumOperands() const { return NumOperands; }\n\n  /// Methods for support type inquiry through isa, cast, and dyn_cast:\n  static bool classof(const Metadata *MD) {\n    switch (MD->getMetadataID()) {\n    default:\n      return false;\n#define HANDLE_MDNODE_LEAF(CLASS)                                              \\\n  case CLASS##Kind:                                                            \\\n    return true;\n#include \"llvm/IR/Metadata.def\"\n    }\n  }\n\n  /// Check whether MDNode is a vtable access.\n  bool isTBAAVtableAccess() const;\n\n  /// Methods for metadata merging.\n  static MDNode *concatenate(MDNode *A, MDNode *B);\n  static MDNode *intersect(MDNode *A, MDNode *B);\n  static MDNode *getMostGenericTBAA(MDNode *A, MDNode *B);\n  static MDNode *getMostGenericFPMath(MDNode *A, MDNode *B);\n  static MDNode *getMostGenericRange(MDNode *A, MDNode *B);\n  static MDNode *getMostGenericAliasScope(MDNode *A, MDNode *B);\n  static MDNode *getMostGenericAlignmentOrDereferenceable(MDNode *A, MDNode *B);\n};\n\n/// Tuple of metadata.\n///\n/// This is the simple \\a MDNode arbitrary tuple.  Nodes are uniqued by\n/// default based on their operands.\nclass MDTuple : public MDNode {\n  friend class LLVMContextImpl;\n  friend class MDNode;\n\n  MDTuple(LLVMContext &C, StorageType Storage, unsigned Hash,\n          ArrayRef<Metadata *> Vals)\n      : MDNode(C, MDTupleKind, Storage, Vals) {\n    setHash(Hash);\n  }\n\n  ~MDTuple() { dropAllReferences(); }\n\n  void setHash(unsigned Hash) { SubclassData32 = Hash; }\n  void recalculateHash();\n\n  static MDTuple *getImpl(LLVMContext &Context, ArrayRef<Metadata *> MDs,\n                          StorageType Storage, bool ShouldCreate = true);\n\n  TempMDTuple cloneImpl() const {\n    return getTemporary(getContext(), SmallVector<Metadata *, 4>(operands()));\n  }\n\npublic:\n  /// Get the hash, if any.\n  unsigned getHash() const { return SubclassData32; }\n\n  static MDTuple *get(LLVMContext &Context, ArrayRef<Metadata *> MDs) {\n    return getImpl(Context, MDs, Uniqued);\n  }\n\n  static MDTuple *getIfExists(LLVMContext &Context, ArrayRef<Metadata *> MDs) {\n    return getImpl(Context, MDs, Uniqued, /* ShouldCreate */ false);\n  }\n\n  /// Return a distinct node.\n  ///\n  /// Return a distinct node -- i.e., a node that is not uniqued.\n  static MDTuple *getDistinct(LLVMContext &Context, ArrayRef<Metadata *> MDs) {\n    return getImpl(Context, MDs, Distinct);\n  }\n\n  /// Return a temporary node.\n  ///\n  /// For use in constructing cyclic MDNode structures. A temporary MDNode is\n  /// not uniqued, may be RAUW'd, and must be manually deleted with\n  /// deleteTemporary.\n  static TempMDTuple getTemporary(LLVMContext &Context,\n                                  ArrayRef<Metadata *> MDs) {\n    return TempMDTuple(getImpl(Context, MDs, Temporary));\n  }\n\n  /// Return a (temporary) clone of this.\n  TempMDTuple clone() const { return cloneImpl(); }\n\n  static bool classof(const Metadata *MD) {\n    return MD->getMetadataID() == MDTupleKind;\n  }\n};\n\nMDTuple *MDNode::get(LLVMContext &Context, ArrayRef<Metadata *> MDs) {\n  return MDTuple::get(Context, MDs);\n}\n\nMDTuple *MDNode::getIfExists(LLVMContext &Context, ArrayRef<Metadata *> MDs) {\n  return MDTuple::getIfExists(Context, MDs);\n}\n\nMDTuple *MDNode::getDistinct(LLVMContext &Context, ArrayRef<Metadata *> MDs) {\n  return MDTuple::getDistinct(Context, MDs);\n}\n\nTempMDTuple MDNode::getTemporary(LLVMContext &Context,\n                                 ArrayRef<Metadata *> MDs) {\n  return MDTuple::getTemporary(Context, MDs);\n}\n\nvoid TempMDNodeDeleter::operator()(MDNode *Node) const {\n  MDNode::deleteTemporary(Node);\n}\n\n/// This is a simple wrapper around an MDNode which provides a higher-level\n/// interface by hiding the details of how alias analysis information is encoded\n/// in its operands.\nclass AliasScopeNode {\n  const MDNode *Node = nullptr;\n\npublic:\n  AliasScopeNode() = default;\n  explicit AliasScopeNode(const MDNode *N) : Node(N) {}\n\n  /// Get the MDNode for this AliasScopeNode.\n  const MDNode *getNode() const { return Node; }\n\n  /// Get the MDNode for this AliasScopeNode's domain.\n  const MDNode *getDomain() const {\n    if (Node->getNumOperands() < 2)\n      return nullptr;\n    return dyn_cast_or_null<MDNode>(Node->getOperand(1));\n  }\n  StringRef getName() const {\n    if (Node->getNumOperands() > 2)\n      if (MDString *N = dyn_cast_or_null<MDString>(Node->getOperand(2)))\n        return N->getString();\n    return StringRef();\n  }\n};\n\n/// Typed iterator through MDNode operands.\n///\n/// An iterator that transforms an \\a MDNode::iterator into an iterator over a\n/// particular Metadata subclass.\ntemplate <class T>\nclass TypedMDOperandIterator\n    : public std::iterator<std::input_iterator_tag, T *, std::ptrdiff_t, void,\n                           T *> {\n  MDNode::op_iterator I = nullptr;\n\npublic:\n  TypedMDOperandIterator() = default;\n  explicit TypedMDOperandIterator(MDNode::op_iterator I) : I(I) {}\n\n  T *operator*() const { return cast_or_null<T>(*I); }\n\n  TypedMDOperandIterator &operator++() {\n    ++I;\n    return *this;\n  }\n\n  TypedMDOperandIterator operator++(int) {\n    TypedMDOperandIterator Temp(*this);\n    ++I;\n    return Temp;\n  }\n\n  bool operator==(const TypedMDOperandIterator &X) const { return I == X.I; }\n  bool operator!=(const TypedMDOperandIterator &X) const { return I != X.I; }\n};\n\n/// Typed, array-like tuple of metadata.\n///\n/// This is a wrapper for \\a MDTuple that makes it act like an array holding a\n/// particular type of metadata.\ntemplate <class T> class MDTupleTypedArrayWrapper {\n  const MDTuple *N = nullptr;\n\npublic:\n  MDTupleTypedArrayWrapper() = default;\n  MDTupleTypedArrayWrapper(const MDTuple *N) : N(N) {}\n\n  template <class U>\n  MDTupleTypedArrayWrapper(\n      const MDTupleTypedArrayWrapper<U> &Other,\n      std::enable_if_t<std::is_convertible<U *, T *>::value> * = nullptr)\n      : N(Other.get()) {}\n\n  template <class U>\n  explicit MDTupleTypedArrayWrapper(\n      const MDTupleTypedArrayWrapper<U> &Other,\n      std::enable_if_t<!std::is_convertible<U *, T *>::value> * = nullptr)\n      : N(Other.get()) {}\n\n  explicit operator bool() const { return get(); }\n  explicit operator MDTuple *() const { return get(); }\n\n  MDTuple *get() const { return const_cast<MDTuple *>(N); }\n  MDTuple *operator->() const { return get(); }\n  MDTuple &operator*() const { return *get(); }\n\n  // FIXME: Fix callers and remove condition on N.\n  unsigned size() const { return N ? N->getNumOperands() : 0u; }\n  bool empty() const { return N ? N->getNumOperands() == 0 : true; }\n  T *operator[](unsigned I) const { return cast_or_null<T>(N->getOperand(I)); }\n\n  // FIXME: Fix callers and remove condition on N.\n  using iterator = TypedMDOperandIterator<T>;\n\n  iterator begin() const { return N ? iterator(N->op_begin()) : iterator(); }\n  iterator end() const { return N ? iterator(N->op_end()) : iterator(); }\n};\n\n#define HANDLE_METADATA(CLASS)                                                 \\\n  using CLASS##Array = MDTupleTypedArrayWrapper<CLASS>;\n#include \"llvm/IR/Metadata.def\"\n\n/// Placeholder metadata for operands of distinct MDNodes.\n///\n/// This is a lightweight placeholder for an operand of a distinct node.  It's\n/// purpose is to help track forward references when creating a distinct node.\n/// This allows distinct nodes involved in a cycle to be constructed before\n/// their operands without requiring a heavyweight temporary node with\n/// full-blown RAUW support.\n///\n/// Each placeholder supports only a single MDNode user.  Clients should pass\n/// an ID, retrieved via \\a getID(), to indicate the \"real\" operand that this\n/// should be replaced with.\n///\n/// While it would be possible to implement move operators, they would be\n/// fairly expensive.  Leave them unimplemented to discourage their use\n/// (clients can use std::deque, std::list, BumpPtrAllocator, etc.).\nclass DistinctMDOperandPlaceholder : public Metadata {\n  friend class MetadataTracking;\n\n  Metadata **Use = nullptr;\n\npublic:\n  explicit DistinctMDOperandPlaceholder(unsigned ID)\n      : Metadata(DistinctMDOperandPlaceholderKind, Distinct) {\n    SubclassData32 = ID;\n  }\n\n  DistinctMDOperandPlaceholder() = delete;\n  DistinctMDOperandPlaceholder(DistinctMDOperandPlaceholder &&) = delete;\n  DistinctMDOperandPlaceholder(const DistinctMDOperandPlaceholder &) = delete;\n\n  ~DistinctMDOperandPlaceholder() {\n    if (Use)\n      *Use = nullptr;\n  }\n\n  unsigned getID() const { return SubclassData32; }\n\n  /// Replace the use of this with MD.\n  void replaceUseWith(Metadata *MD) {\n    if (!Use)\n      return;\n    *Use = MD;\n\n    if (*Use)\n      MetadataTracking::track(*Use);\n\n    Metadata *T = cast<Metadata>(this);\n    MetadataTracking::untrack(T);\n    assert(!Use && \"Use is still being tracked despite being untracked!\");\n  }\n};\n\n//===----------------------------------------------------------------------===//\n/// A tuple of MDNodes.\n///\n/// Despite its name, a NamedMDNode isn't itself an MDNode.\n///\n/// NamedMDNodes are named module-level entities that contain lists of MDNodes.\n///\n/// It is illegal for a NamedMDNode to appear as an operand of an MDNode.\nclass NamedMDNode : public ilist_node<NamedMDNode> {\n  friend class LLVMContextImpl;\n  friend class Module;\n\n  std::string Name;\n  Module *Parent = nullptr;\n  void *Operands; // SmallVector<TrackingMDRef, 4>\n\n  void setParent(Module *M) { Parent = M; }\n\n  explicit NamedMDNode(const Twine &N);\n\n  template<class T1, class T2>\n  class op_iterator_impl :\n      public std::iterator<std::bidirectional_iterator_tag, T2> {\n    friend class NamedMDNode;\n\n    const NamedMDNode *Node = nullptr;\n    unsigned Idx = 0;\n\n    op_iterator_impl(const NamedMDNode *N, unsigned i) : Node(N), Idx(i) {}\n\n  public:\n    op_iterator_impl() = default;\n\n    bool operator==(const op_iterator_impl &o) const { return Idx == o.Idx; }\n    bool operator!=(const op_iterator_impl &o) const { return Idx != o.Idx; }\n\n    op_iterator_impl &operator++() {\n      ++Idx;\n      return *this;\n    }\n\n    op_iterator_impl operator++(int) {\n      op_iterator_impl tmp(*this);\n      operator++();\n      return tmp;\n    }\n\n    op_iterator_impl &operator--() {\n      --Idx;\n      return *this;\n    }\n\n    op_iterator_impl operator--(int) {\n      op_iterator_impl tmp(*this);\n      operator--();\n      return tmp;\n    }\n\n    T1 operator*() const { return Node->getOperand(Idx); }\n  };\n\npublic:\n  NamedMDNode(const NamedMDNode &) = delete;\n  ~NamedMDNode();\n\n  /// Drop all references and remove the node from parent module.\n  void eraseFromParent();\n\n  /// Remove all uses and clear node vector.\n  void dropAllReferences() { clearOperands(); }\n  /// Drop all references to this node's operands.\n  void clearOperands();\n\n  /// Get the module that holds this named metadata collection.\n  inline Module *getParent() { return Parent; }\n  inline const Module *getParent() const { return Parent; }\n\n  MDNode *getOperand(unsigned i) const;\n  unsigned getNumOperands() const;\n  void addOperand(MDNode *M);\n  void setOperand(unsigned I, MDNode *New);\n  StringRef getName() const;\n  void print(raw_ostream &ROS, bool IsForDebug = false) const;\n  void print(raw_ostream &ROS, ModuleSlotTracker &MST,\n             bool IsForDebug = false) const;\n  void dump() const;\n\n  // ---------------------------------------------------------------------------\n  // Operand Iterator interface...\n  //\n  using op_iterator = op_iterator_impl<MDNode *, MDNode>;\n\n  op_iterator op_begin() { return op_iterator(this, 0); }\n  op_iterator op_end()   { return op_iterator(this, getNumOperands()); }\n\n  using const_op_iterator = op_iterator_impl<const MDNode *, MDNode>;\n\n  const_op_iterator op_begin() const { return const_op_iterator(this, 0); }\n  const_op_iterator op_end()   const { return const_op_iterator(this, getNumOperands()); }\n\n  inline iterator_range<op_iterator>  operands() {\n    return make_range(op_begin(), op_end());\n  }\n  inline iterator_range<const_op_iterator> operands() const {\n    return make_range(op_begin(), op_end());\n  }\n};\n\n// Create wrappers for C Binding types (see CBindingWrapping.h).\nDEFINE_ISA_CONVERSION_FUNCTIONS(NamedMDNode, LLVMNamedMDNodeRef)\n\n} // end namespace llvm\n\n#endif // LLVM_IR_METADATA_H\n"}, "37": {"id": 37, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/IR/Operator.h", "content": "//===-- llvm/Operator.h - Operator utility subclass -------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// This file defines various classes for working with Instructions and\n// ConstantExprs.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_IR_OPERATOR_H\n#define LLVM_IR_OPERATOR_H\n\n#include \"llvm/ADT/None.h\"\n#include \"llvm/ADT/Optional.h\"\n#include \"llvm/IR/Constants.h\"\n#include \"llvm/IR/Instruction.h\"\n#include \"llvm/IR/Type.h\"\n#include \"llvm/IR/Value.h\"\n#include \"llvm/Support/Casting.h\"\n#include <cstddef>\n\nnamespace llvm {\n\n/// This is a utility class that provides an abstraction for the common\n/// functionality between Instructions and ConstantExprs.\nclass Operator : public User {\npublic:\n  // The Operator class is intended to be used as a utility, and is never itself\n  // instantiated.\n  Operator() = delete;\n  ~Operator() = delete;\n\n  void *operator new(size_t s) = delete;\n\n  /// Return the opcode for this Instruction or ConstantExpr.\n  unsigned getOpcode() const {\n    if (const Instruction *I = dyn_cast<Instruction>(this))\n      return I->getOpcode();\n    return cast<ConstantExpr>(this)->getOpcode();\n  }\n\n  /// If V is an Instruction or ConstantExpr, return its opcode.\n  /// Otherwise return UserOp1.\n  static unsigned getOpcode(const Value *V) {\n    if (const Instruction *I = dyn_cast<Instruction>(V))\n      return I->getOpcode();\n    if (const ConstantExpr *CE = dyn_cast<ConstantExpr>(V))\n      return CE->getOpcode();\n    return Instruction::UserOp1;\n  }\n\n  static bool classof(const Instruction *) { return true; }\n  static bool classof(const ConstantExpr *) { return true; }\n  static bool classof(const Value *V) {\n    return isa<Instruction>(V) || isa<ConstantExpr>(V);\n  }\n};\n\n/// Utility class for integer operators which may exhibit overflow - Add, Sub,\n/// Mul, and Shl. It does not include SDiv, despite that operator having the\n/// potential for overflow.\nclass OverflowingBinaryOperator : public Operator {\npublic:\n  enum {\n    AnyWrap        = 0,\n    NoUnsignedWrap = (1 << 0),\n    NoSignedWrap   = (1 << 1)\n  };\n\nprivate:\n  friend class Instruction;\n  friend class ConstantExpr;\n\n  void setHasNoUnsignedWrap(bool B) {\n    SubclassOptionalData =\n      (SubclassOptionalData & ~NoUnsignedWrap) | (B * NoUnsignedWrap);\n  }\n  void setHasNoSignedWrap(bool B) {\n    SubclassOptionalData =\n      (SubclassOptionalData & ~NoSignedWrap) | (B * NoSignedWrap);\n  }\n\npublic:\n  /// Test whether this operation is known to never\n  /// undergo unsigned overflow, aka the nuw property.\n  bool hasNoUnsignedWrap() const {\n    return SubclassOptionalData & NoUnsignedWrap;\n  }\n\n  /// Test whether this operation is known to never\n  /// undergo signed overflow, aka the nsw property.\n  bool hasNoSignedWrap() const {\n    return (SubclassOptionalData & NoSignedWrap) != 0;\n  }\n\n  static bool classof(const Instruction *I) {\n    return I->getOpcode() == Instruction::Add ||\n           I->getOpcode() == Instruction::Sub ||\n           I->getOpcode() == Instruction::Mul ||\n           I->getOpcode() == Instruction::Shl;\n  }\n  static bool classof(const ConstantExpr *CE) {\n    return CE->getOpcode() == Instruction::Add ||\n           CE->getOpcode() == Instruction::Sub ||\n           CE->getOpcode() == Instruction::Mul ||\n           CE->getOpcode() == Instruction::Shl;\n  }\n  static bool classof(const Value *V) {\n    return (isa<Instruction>(V) && classof(cast<Instruction>(V))) ||\n           (isa<ConstantExpr>(V) && classof(cast<ConstantExpr>(V)));\n  }\n};\n\n/// A udiv or sdiv instruction, which can be marked as \"exact\",\n/// indicating that no bits are destroyed.\nclass PossiblyExactOperator : public Operator {\npublic:\n  enum {\n    IsExact = (1 << 0)\n  };\n\nprivate:\n  friend class Instruction;\n  friend class ConstantExpr;\n\n  void setIsExact(bool B) {\n    SubclassOptionalData = (SubclassOptionalData & ~IsExact) | (B * IsExact);\n  }\n\npublic:\n  /// Test whether this division is known to be exact, with zero remainder.\n  bool isExact() const {\n    return SubclassOptionalData & IsExact;\n  }\n\n  static bool isPossiblyExactOpcode(unsigned OpC) {\n    return OpC == Instruction::SDiv ||\n           OpC == Instruction::UDiv ||\n           OpC == Instruction::AShr ||\n           OpC == Instruction::LShr;\n  }\n\n  static bool classof(const ConstantExpr *CE) {\n    return isPossiblyExactOpcode(CE->getOpcode());\n  }\n  static bool classof(const Instruction *I) {\n    return isPossiblyExactOpcode(I->getOpcode());\n  }\n  static bool classof(const Value *V) {\n    return (isa<Instruction>(V) && classof(cast<Instruction>(V))) ||\n           (isa<ConstantExpr>(V) && classof(cast<ConstantExpr>(V)));\n  }\n};\n\n/// Convenience struct for specifying and reasoning about fast-math flags.\nclass FastMathFlags {\nprivate:\n  friend class FPMathOperator;\n\n  unsigned Flags = 0;\n\n  FastMathFlags(unsigned F) {\n    // If all 7 bits are set, turn this into -1. If the number of bits grows,\n    // this must be updated. This is intended to provide some forward binary\n    // compatibility insurance for the meaning of 'fast' in case bits are added.\n    if (F == 0x7F) Flags = ~0U;\n    else Flags = F;\n  }\n\npublic:\n  // This is how the bits are used in Value::SubclassOptionalData so they\n  // should fit there too.\n  // WARNING: We're out of space. SubclassOptionalData only has 7 bits. New\n  // functionality will require a change in how this information is stored.\n  enum {\n    AllowReassoc    = (1 << 0),\n    NoNaNs          = (1 << 1),\n    NoInfs          = (1 << 2),\n    NoSignedZeros   = (1 << 3),\n    AllowReciprocal = (1 << 4),\n    AllowContract   = (1 << 5),\n    ApproxFunc      = (1 << 6)\n  };\n\n  FastMathFlags() = default;\n\n  static FastMathFlags getFast() {\n    FastMathFlags FMF;\n    FMF.setFast();\n    return FMF;\n  }\n\n  bool any() const { return Flags != 0; }\n  bool none() const { return Flags == 0; }\n  bool all() const { return Flags == ~0U; }\n\n  void clear() { Flags = 0; }\n  void set()   { Flags = ~0U; }\n\n  /// Flag queries\n  bool allowReassoc() const    { return 0 != (Flags & AllowReassoc); }\n  bool noNaNs() const          { return 0 != (Flags & NoNaNs); }\n  bool noInfs() const          { return 0 != (Flags & NoInfs); }\n  bool noSignedZeros() const   { return 0 != (Flags & NoSignedZeros); }\n  bool allowReciprocal() const { return 0 != (Flags & AllowReciprocal); }\n  bool allowContract() const   { return 0 != (Flags & AllowContract); }\n  bool approxFunc() const      { return 0 != (Flags & ApproxFunc); }\n  /// 'Fast' means all bits are set.\n  bool isFast() const          { return all(); }\n\n  /// Flag setters\n  void setAllowReassoc(bool B = true) {\n    Flags = (Flags & ~AllowReassoc) | B * AllowReassoc;\n  }\n  void setNoNaNs(bool B = true) {\n    Flags = (Flags & ~NoNaNs) | B * NoNaNs;\n  }\n  void setNoInfs(bool B = true) {\n    Flags = (Flags & ~NoInfs) | B * NoInfs;\n  }\n  void setNoSignedZeros(bool B = true) {\n    Flags = (Flags & ~NoSignedZeros) | B * NoSignedZeros;\n  }\n  void setAllowReciprocal(bool B = true) {\n    Flags = (Flags & ~AllowReciprocal) | B * AllowReciprocal;\n  }\n  void setAllowContract(bool B = true) {\n    Flags = (Flags & ~AllowContract) | B * AllowContract;\n  }\n  void setApproxFunc(bool B = true) {\n    Flags = (Flags & ~ApproxFunc) | B * ApproxFunc;\n  }\n  void setFast(bool B = true) { B ? set() : clear(); }\n\n  void operator&=(const FastMathFlags &OtherFlags) {\n    Flags &= OtherFlags.Flags;\n  }\n  void operator|=(const FastMathFlags &OtherFlags) {\n    Flags |= OtherFlags.Flags;\n  }\n};\n\n/// Utility class for floating point operations which can have\n/// information about relaxed accuracy requirements attached to them.\nclass FPMathOperator : public Operator {\nprivate:\n  friend class Instruction;\n\n  /// 'Fast' means all bits are set.\n  void setFast(bool B) {\n    setHasAllowReassoc(B);\n    setHasNoNaNs(B);\n    setHasNoInfs(B);\n    setHasNoSignedZeros(B);\n    setHasAllowReciprocal(B);\n    setHasAllowContract(B);\n    setHasApproxFunc(B);\n  }\n\n  void setHasAllowReassoc(bool B) {\n    SubclassOptionalData =\n    (SubclassOptionalData & ~FastMathFlags::AllowReassoc) |\n    (B * FastMathFlags::AllowReassoc);\n  }\n\n  void setHasNoNaNs(bool B) {\n    SubclassOptionalData =\n      (SubclassOptionalData & ~FastMathFlags::NoNaNs) |\n      (B * FastMathFlags::NoNaNs);\n  }\n\n  void setHasNoInfs(bool B) {\n    SubclassOptionalData =\n      (SubclassOptionalData & ~FastMathFlags::NoInfs) |\n      (B * FastMathFlags::NoInfs);\n  }\n\n  void setHasNoSignedZeros(bool B) {\n    SubclassOptionalData =\n      (SubclassOptionalData & ~FastMathFlags::NoSignedZeros) |\n      (B * FastMathFlags::NoSignedZeros);\n  }\n\n  void setHasAllowReciprocal(bool B) {\n    SubclassOptionalData =\n      (SubclassOptionalData & ~FastMathFlags::AllowReciprocal) |\n      (B * FastMathFlags::AllowReciprocal);\n  }\n\n  void setHasAllowContract(bool B) {\n    SubclassOptionalData =\n        (SubclassOptionalData & ~FastMathFlags::AllowContract) |\n        (B * FastMathFlags::AllowContract);\n  }\n\n  void setHasApproxFunc(bool B) {\n    SubclassOptionalData =\n        (SubclassOptionalData & ~FastMathFlags::ApproxFunc) |\n        (B * FastMathFlags::ApproxFunc);\n  }\n\n  /// Convenience function for setting multiple fast-math flags.\n  /// FMF is a mask of the bits to set.\n  void setFastMathFlags(FastMathFlags FMF) {\n    SubclassOptionalData |= FMF.Flags;\n  }\n\n  /// Convenience function for copying all fast-math flags.\n  /// All values in FMF are transferred to this operator.\n  void copyFastMathFlags(FastMathFlags FMF) {\n    SubclassOptionalData = FMF.Flags;\n  }\n\npublic:\n  /// Test if this operation allows all non-strict floating-point transforms.\n  bool isFast() const {\n    return ((SubclassOptionalData & FastMathFlags::AllowReassoc) != 0 &&\n            (SubclassOptionalData & FastMathFlags::NoNaNs) != 0 &&\n            (SubclassOptionalData & FastMathFlags::NoInfs) != 0 &&\n            (SubclassOptionalData & FastMathFlags::NoSignedZeros) != 0 &&\n            (SubclassOptionalData & FastMathFlags::AllowReciprocal) != 0 &&\n            (SubclassOptionalData & FastMathFlags::AllowContract) != 0 &&\n            (SubclassOptionalData & FastMathFlags::ApproxFunc) != 0);\n  }\n\n  /// Test if this operation may be simplified with reassociative transforms.\n  bool hasAllowReassoc() const {\n    return (SubclassOptionalData & FastMathFlags::AllowReassoc) != 0;\n  }\n\n  /// Test if this operation's arguments and results are assumed not-NaN.\n  bool hasNoNaNs() const {\n    return (SubclassOptionalData & FastMathFlags::NoNaNs) != 0;\n  }\n\n  /// Test if this operation's arguments and results are assumed not-infinite.\n  bool hasNoInfs() const {\n    return (SubclassOptionalData & FastMathFlags::NoInfs) != 0;\n  }\n\n  /// Test if this operation can ignore the sign of zero.\n  bool hasNoSignedZeros() const {\n    return (SubclassOptionalData & FastMathFlags::NoSignedZeros) != 0;\n  }\n\n  /// Test if this operation can use reciprocal multiply instead of division.\n  bool hasAllowReciprocal() const {\n    return (SubclassOptionalData & FastMathFlags::AllowReciprocal) != 0;\n  }\n\n  /// Test if this operation can be floating-point contracted (FMA).\n  bool hasAllowContract() const {\n    return (SubclassOptionalData & FastMathFlags::AllowContract) != 0;\n  }\n\n  /// Test if this operation allows approximations of math library functions or\n  /// intrinsics.\n  bool hasApproxFunc() const {\n    return (SubclassOptionalData & FastMathFlags::ApproxFunc) != 0;\n  }\n\n  /// Convenience function for getting all the fast-math flags\n  FastMathFlags getFastMathFlags() const {\n    return FastMathFlags(SubclassOptionalData);\n  }\n\n  /// Get the maximum error permitted by this operation in ULPs. An accuracy of\n  /// 0.0 means that the operation should be performed with the default\n  /// precision.\n  float getFPAccuracy() const;\n\n  static bool classof(const Value *V) {\n    unsigned Opcode;\n    if (auto *I = dyn_cast<Instruction>(V))\n      Opcode = I->getOpcode();\n    else if (auto *CE = dyn_cast<ConstantExpr>(V))\n      Opcode = CE->getOpcode();\n    else\n      return false;\n\n    switch (Opcode) {\n    case Instruction::FNeg:\n    case Instruction::FAdd:\n    case Instruction::FSub:\n    case Instruction::FMul:\n    case Instruction::FDiv:\n    case Instruction::FRem:\n    // FIXME: To clean up and correct the semantics of fast-math-flags, FCmp\n    //        should not be treated as a math op, but the other opcodes should.\n    //        This would make things consistent with Select/PHI (FP value type\n    //        determines whether they are math ops and, therefore, capable of\n    //        having fast-math-flags).\n    case Instruction::FCmp:\n      return true;\n    case Instruction::PHI:\n    case Instruction::Select:\n    case Instruction::Call: {\n      Type *Ty = V->getType();\n      while (ArrayType *ArrTy = dyn_cast<ArrayType>(Ty))\n        Ty = ArrTy->getElementType();\n      return Ty->isFPOrFPVectorTy();\n    }\n    default:\n      return false;\n    }\n  }\n};\n\n/// A helper template for defining operators for individual opcodes.\ntemplate<typename SuperClass, unsigned Opc>\nclass ConcreteOperator : public SuperClass {\npublic:\n  static bool classof(const Instruction *I) {\n    return I->getOpcode() == Opc;\n  }\n  static bool classof(const ConstantExpr *CE) {\n    return CE->getOpcode() == Opc;\n  }\n  static bool classof(const Value *V) {\n    return (isa<Instruction>(V) && classof(cast<Instruction>(V))) ||\n           (isa<ConstantExpr>(V) && classof(cast<ConstantExpr>(V)));\n  }\n};\n\nclass AddOperator\n  : public ConcreteOperator<OverflowingBinaryOperator, Instruction::Add> {\n};\nclass SubOperator\n  : public ConcreteOperator<OverflowingBinaryOperator, Instruction::Sub> {\n};\nclass MulOperator\n  : public ConcreteOperator<OverflowingBinaryOperator, Instruction::Mul> {\n};\nclass ShlOperator\n  : public ConcreteOperator<OverflowingBinaryOperator, Instruction::Shl> {\n};\n\nclass SDivOperator\n  : public ConcreteOperator<PossiblyExactOperator, Instruction::SDiv> {\n};\nclass UDivOperator\n  : public ConcreteOperator<PossiblyExactOperator, Instruction::UDiv> {\n};\nclass AShrOperator\n  : public ConcreteOperator<PossiblyExactOperator, Instruction::AShr> {\n};\nclass LShrOperator\n  : public ConcreteOperator<PossiblyExactOperator, Instruction::LShr> {\n};\n\nclass ZExtOperator : public ConcreteOperator<Operator, Instruction::ZExt> {};\n\nclass GEPOperator\n  : public ConcreteOperator<Operator, Instruction::GetElementPtr> {\n  friend class GetElementPtrInst;\n  friend class ConstantExpr;\n\n  enum {\n    IsInBounds = (1 << 0),\n    // InRangeIndex: bits 1-6\n  };\n\n  void setIsInBounds(bool B) {\n    SubclassOptionalData =\n      (SubclassOptionalData & ~IsInBounds) | (B * IsInBounds);\n  }\n\npublic:\n  /// Test whether this is an inbounds GEP, as defined by LangRef.html.\n  bool isInBounds() const {\n    return SubclassOptionalData & IsInBounds;\n  }\n\n  /// Returns the offset of the index with an inrange attachment, or None if\n  /// none.\n  Optional<unsigned> getInRangeIndex() const {\n    if (SubclassOptionalData >> 1 == 0) return None;\n    return (SubclassOptionalData >> 1) - 1;\n  }\n\n  inline op_iterator       idx_begin()       { return op_begin()+1; }\n  inline const_op_iterator idx_begin() const { return op_begin()+1; }\n  inline op_iterator       idx_end()         { return op_end(); }\n  inline const_op_iterator idx_end()   const { return op_end(); }\n\n  Value *getPointerOperand() {\n    return getOperand(0);\n  }\n  const Value *getPointerOperand() const {\n    return getOperand(0);\n  }\n  static unsigned getPointerOperandIndex() {\n    return 0U;                      // get index for modifying correct operand\n  }\n\n  /// Method to return the pointer operand as a PointerType.\n  Type *getPointerOperandType() const {\n    return getPointerOperand()->getType();\n  }\n\n  Type *getSourceElementType() const;\n  Type *getResultElementType() const;\n\n  /// Method to return the address space of the pointer operand.\n  unsigned getPointerAddressSpace() const {\n    return getPointerOperandType()->getPointerAddressSpace();\n  }\n\n  unsigned getNumIndices() const {  // Note: always non-negative\n    return getNumOperands() - 1;\n  }\n\n  bool hasIndices() const {\n    return getNumOperands() > 1;\n  }\n\n  /// Return true if all of the indices of this GEP are zeros.\n  /// If so, the result pointer and the first operand have the same\n  /// value, just potentially different types.\n  bool hasAllZeroIndices() const {\n    for (const_op_iterator I = idx_begin(), E = idx_end(); I != E; ++I) {\n      if (ConstantInt *C = dyn_cast<ConstantInt>(I))\n        if (C->isZero())\n          continue;\n      return false;\n    }\n    return true;\n  }\n\n  /// Return true if all of the indices of this GEP are constant integers.\n  /// If so, the result pointer and the first operand have\n  /// a constant offset between them.\n  bool hasAllConstantIndices() const {\n    for (const_op_iterator I = idx_begin(), E = idx_end(); I != E; ++I) {\n      if (!isa<ConstantInt>(I))\n        return false;\n    }\n    return true;\n  }\n\n  unsigned countNonConstantIndices() const {\n    return count_if(make_range(idx_begin(), idx_end()), [](const Use& use) {\n        return !isa<ConstantInt>(*use);\n      });\n  }\n\n  /// Compute the maximum alignment that this GEP is garranteed to preserve.\n  Align getMaxPreservedAlignment(const DataLayout &DL) const;\n\n  /// Accumulate the constant address offset of this GEP if possible.\n  ///\n  /// This routine accepts an APInt into which it will try to accumulate the\n  /// constant offset of this GEP.\n  ///\n  /// If \\p ExternalAnalysis is provided it will be used to calculate a offset\n  /// when a operand of GEP is not constant.\n  /// For example, for a value \\p ExternalAnalysis might try to calculate a\n  /// lower bound. If \\p ExternalAnalysis is successful, it should return true.\n  ///\n  /// If the \\p ExternalAnalysis returns false or the value returned by \\p\n  /// ExternalAnalysis results in a overflow/underflow, this routine returns\n  /// false and the value of the offset APInt is undefined (it is *not*\n  /// preserved!).\n  ///\n  /// The APInt passed into this routine must be at exactly as wide as the\n  /// IntPtr type for the address space of the base GEP pointer.\n  bool accumulateConstantOffset(\n      const DataLayout &DL, APInt &Offset,\n      function_ref<bool(Value &, APInt &)> ExternalAnalysis = nullptr) const;\n\n  static bool accumulateConstantOffset(\n      Type *SourceType, ArrayRef<const Value *> Index, const DataLayout &DL,\n      APInt &Offset,\n      function_ref<bool(Value &, APInt &)> ExternalAnalysis = nullptr);\n};\n\nclass PtrToIntOperator\n    : public ConcreteOperator<Operator, Instruction::PtrToInt> {\n  friend class PtrToInt;\n  friend class ConstantExpr;\n\npublic:\n  Value *getPointerOperand() {\n    return getOperand(0);\n  }\n  const Value *getPointerOperand() const {\n    return getOperand(0);\n  }\n\n  static unsigned getPointerOperandIndex() {\n    return 0U;                      // get index for modifying correct operand\n  }\n\n  /// Method to return the pointer operand as a PointerType.\n  Type *getPointerOperandType() const {\n    return getPointerOperand()->getType();\n  }\n\n  /// Method to return the address space of the pointer operand.\n  unsigned getPointerAddressSpace() const {\n    return cast<PointerType>(getPointerOperandType())->getAddressSpace();\n  }\n};\n\nclass BitCastOperator\n    : public ConcreteOperator<Operator, Instruction::BitCast> {\n  friend class BitCastInst;\n  friend class ConstantExpr;\n\npublic:\n  Type *getSrcTy() const {\n    return getOperand(0)->getType();\n  }\n\n  Type *getDestTy() const {\n    return getType();\n  }\n};\n\nclass AddrSpaceCastOperator\n    : public ConcreteOperator<Operator, Instruction::AddrSpaceCast> {\n  friend class AddrSpaceCastInst;\n  friend class ConstantExpr;\n\npublic:\n  Value *getPointerOperand() { return getOperand(0); }\n\n  const Value *getPointerOperand() const { return getOperand(0); }\n\n  unsigned getSrcAddressSpace() const {\n    return getPointerOperand()->getType()->getPointerAddressSpace();\n  }\n\n  unsigned getDestAddressSpace() const {\n    return getType()->getPointerAddressSpace();\n  }\n};\n\n} // end namespace llvm\n\n#endif // LLVM_IR_OPERATOR_H\n"}, "42": {"id": 42, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/PassAnalysisSupport.h", "content": "//===- llvm/PassAnalysisSupport.h - Analysis Pass Support code --*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// This file defines stuff that is used to define and \"use\" Analysis Passes.\n// This file is automatically #included by Pass.h, so:\n//\n//           NO .CPP FILES SHOULD INCLUDE THIS FILE DIRECTLY\n//\n// Instead, #include Pass.h\n//\n//===----------------------------------------------------------------------===//\n\n#if !defined(LLVM_PASS_H) || defined(LLVM_PASSANALYSISSUPPORT_H)\n#error \"Do not include <PassAnalysisSupport.h>; include <Pass.h> instead\"\n#endif\n\n#ifndef LLVM_PASSANALYSISSUPPORT_H\n#define LLVM_PASSANALYSISSUPPORT_H\n\n#include \"llvm/ADT/STLExtras.h\"\n#include \"llvm/ADT/SmallVector.h\"\n#include <cassert>\n#include <tuple>\n#include <utility>\n#include <vector>\n\nnamespace llvm {\n\nclass Function;\nclass Pass;\nclass PMDataManager;\nclass StringRef;\n\n//===----------------------------------------------------------------------===//\n/// Represent the analysis usage information of a pass.  This tracks analyses\n/// that the pass REQUIRES (must be available when the pass runs), REQUIRES\n/// TRANSITIVE (must be available throughout the lifetime of the pass), and\n/// analyses that the pass PRESERVES (the pass does not invalidate the results\n/// of these analyses).  This information is provided by a pass to the Pass\n/// infrastructure through the getAnalysisUsage virtual function.\n///\nclass AnalysisUsage {\npublic:\n  using VectorType = SmallVectorImpl<AnalysisID>;\n\nprivate:\n  /// Sets of analyses required and preserved by a pass\n  // TODO: It's not clear that SmallVector is an appropriate data structure for\n  // this usecase.  The sizes were picked to minimize wasted space, but are\n  // otherwise fairly meaningless.\n  SmallVector<AnalysisID, 8> Required;\n  SmallVector<AnalysisID, 2> RequiredTransitive;\n  SmallVector<AnalysisID, 2> Preserved;\n  SmallVector<AnalysisID, 0> Used;\n  bool PreservesAll = false;\n\n  void pushUnique(VectorType &Set, AnalysisID ID) {\n    if (!llvm::is_contained(Set, ID))\n      Set.push_back(ID);\n  }\n\npublic:\n  AnalysisUsage() = default;\n\n  ///@{\n  /// Add the specified ID to the required set of the usage info for a pass.\n  AnalysisUsage &addRequiredID(const void *ID);\n  AnalysisUsage &addRequiredID(char &ID);\n  template<class PassClass>\n  AnalysisUsage &addRequired() {\n    return addRequiredID(PassClass::ID);\n  }\n\n  AnalysisUsage &addRequiredTransitiveID(char &ID);\n  template<class PassClass>\n  AnalysisUsage &addRequiredTransitive() {\n    return addRequiredTransitiveID(PassClass::ID);\n  }\n  ///@}\n\n  ///@{\n  /// Add the specified ID to the set of analyses preserved by this pass.\n  AnalysisUsage &addPreservedID(const void *ID) {\n    pushUnique(Preserved, ID);\n    return *this;\n  }\n  AnalysisUsage &addPreservedID(char &ID) {\n    pushUnique(Preserved, &ID);\n    return *this;\n  }\n  /// Add the specified Pass class to the set of analyses preserved by this pass.\n  template<class PassClass>\n  AnalysisUsage &addPreserved() {\n    pushUnique(Preserved, &PassClass::ID);\n    return *this;\n  }\n  ///@}\n\n  ///@{\n  /// Add the specified ID to the set of analyses used by this pass if they are\n  /// available..\n  AnalysisUsage &addUsedIfAvailableID(const void *ID) {\n    pushUnique(Used, ID);\n    return *this;\n  }\n  AnalysisUsage &addUsedIfAvailableID(char &ID) {\n    pushUnique(Used, &ID);\n    return *this;\n  }\n  /// Add the specified Pass class to the set of analyses used by this pass.\n  template<class PassClass>\n  AnalysisUsage &addUsedIfAvailable() {\n    pushUnique(Used, &PassClass::ID);\n    return *this;\n  }\n  ///@}\n\n  /// Add the Pass with the specified argument string to the set of analyses\n  /// preserved by this pass. If no such Pass exists, do nothing. This can be\n  /// useful when a pass is trivially preserved, but may not be linked in. Be\n  /// careful about spelling!\n  AnalysisUsage &addPreserved(StringRef Arg);\n\n  /// Set by analyses that do not transform their input at all\n  void setPreservesAll() { PreservesAll = true; }\n\n  /// Determine whether a pass said it does not transform its input at all\n  bool getPreservesAll() const { return PreservesAll; }\n\n  /// This function should be called by the pass, iff they do not:\n  ///\n  ///  1. Add or remove basic blocks from the function\n  ///  2. Modify terminator instructions in any way.\n  ///\n  /// This function annotates the AnalysisUsage info object to say that analyses\n  /// that only depend on the CFG are preserved by this pass.\n  void setPreservesCFG();\n\n  const VectorType &getRequiredSet() const { return Required; }\n  const VectorType &getRequiredTransitiveSet() const {\n    return RequiredTransitive;\n  }\n  const VectorType &getPreservedSet() const { return Preserved; }\n  const VectorType &getUsedSet() const { return Used; }\n};\n\n//===----------------------------------------------------------------------===//\n/// AnalysisResolver - Simple interface used by Pass objects to pull all\n/// analysis information out of pass manager that is responsible to manage\n/// the pass.\n///\nclass AnalysisResolver {\npublic:\n  AnalysisResolver() = delete;\n  explicit AnalysisResolver(PMDataManager &P) : PM(P) {}\n\n  PMDataManager &getPMDataManager() { return PM; }\n\n  /// Find pass that is implementing PI.\n  Pass *findImplPass(AnalysisID PI) {\n    Pass *ResultPass = nullptr;\n    for (const auto &AnalysisImpl : AnalysisImpls) {\n      if (AnalysisImpl.first == PI) {\n        ResultPass = AnalysisImpl.second;\n        break;\n      }\n    }\n    return ResultPass;\n  }\n\n  /// Find pass that is implementing PI. Initialize pass for Function F.\n  std::tuple<Pass *, bool> findImplPass(Pass *P, AnalysisID PI, Function &F);\n\n  void addAnalysisImplsPair(AnalysisID PI, Pass *P) {\n    if (findImplPass(PI) == P)\n      return;\n    std::pair<AnalysisID, Pass*> pir = std::make_pair(PI,P);\n    AnalysisImpls.push_back(pir);\n  }\n\n  /// Clear cache that is used to connect a pass to the analysis (PassInfo).\n  void clearAnalysisImpls() {\n    AnalysisImpls.clear();\n  }\n\n  /// Return analysis result or null if it doesn't exist.\n  Pass *getAnalysisIfAvailable(AnalysisID ID) const;\n\nprivate:\n  /// This keeps track of which passes implements the interfaces that are\n  /// required by the current pass (to implement getAnalysis()).\n  std::vector<std::pair<AnalysisID, Pass *>> AnalysisImpls;\n\n  /// PassManager that is used to resolve analysis info\n  PMDataManager &PM;\n};\n\n/// getAnalysisIfAvailable<AnalysisType>() - Subclasses use this function to\n/// get analysis information that might be around, for example to update it.\n/// This is different than getAnalysis in that it can fail (if the analysis\n/// results haven't been computed), so should only be used if you can handle\n/// the case when the analysis is not available.  This method is often used by\n/// transformation APIs to update analysis results for a pass automatically as\n/// the transform is performed.\ntemplate<typename AnalysisType>\nAnalysisType *Pass::getAnalysisIfAvailable() const {\n  assert(Resolver && \"Pass not resident in a PassManager object!\");\n\n  const void *PI = &AnalysisType::ID;\n\n  Pass *ResultPass = Resolver->getAnalysisIfAvailable(PI);\n  if (!ResultPass) return nullptr;\n\n  // Because the AnalysisType may not be a subclass of pass (for\n  // AnalysisGroups), we use getAdjustedAnalysisPointer here to potentially\n  // adjust the return pointer (because the class may multiply inherit, once\n  // from pass, once from AnalysisType).\n  return (AnalysisType*)ResultPass->getAdjustedAnalysisPointer(PI);\n}\n\n/// getAnalysis<AnalysisType>() - This function is used by subclasses to get\n/// to the analysis information that they claim to use by overriding the\n/// getAnalysisUsage function.\ntemplate<typename AnalysisType>\nAnalysisType &Pass::getAnalysis() const {\n  assert(Resolver && \"Pass has not been inserted into a PassManager object!\");\n  return getAnalysisID<AnalysisType>(&AnalysisType::ID);\n}\n\ntemplate<typename AnalysisType>\nAnalysisType &Pass::getAnalysisID(AnalysisID PI) const {\n  assert(PI && \"getAnalysis for unregistered pass!\");\n  assert(Resolver&&\"Pass has not been inserted into a PassManager object!\");\n  // PI *must* appear in AnalysisImpls.  Because the number of passes used\n  // should be a small number, we just do a linear search over a (dense)\n  // vector.\n  Pass *ResultPass = Resolver->findImplPass(PI);\n  assert(ResultPass &&\n         \"getAnalysis*() called on an analysis that was not \"\n         \"'required' by pass!\");\n\n  // Because the AnalysisType may not be a subclass of pass (for\n  // AnalysisGroups), we use getAdjustedAnalysisPointer here to potentially\n  // adjust the return pointer (because the class may multiply inherit, once\n  // from pass, once from AnalysisType).\n  return *(AnalysisType*)ResultPass->getAdjustedAnalysisPointer(PI);\n}\n\n/// getAnalysis<AnalysisType>() - This function is used by subclasses to get\n/// to the analysis information that they claim to use by overriding the\n/// getAnalysisUsage function. If as part of the dependencies, an IR\n/// transformation is triggered (e.g. because the analysis requires\n/// BreakCriticalEdges), and Changed is non null, *Changed is updated.\ntemplate <typename AnalysisType>\nAnalysisType &Pass::getAnalysis(Function &F, bool *Changed) {\n  assert(Resolver &&\"Pass has not been inserted into a PassManager object!\");\n\n  return getAnalysisID<AnalysisType>(&AnalysisType::ID, F, Changed);\n}\n\ntemplate <typename AnalysisType>\nAnalysisType &Pass::getAnalysisID(AnalysisID PI, Function &F, bool *Changed) {\n  assert(PI && \"getAnalysis for unregistered pass!\");\n  assert(Resolver && \"Pass has not been inserted into a PassManager object!\");\n  // PI *must* appear in AnalysisImpls.  Because the number of passes used\n  // should be a small number, we just do a linear search over a (dense)\n  // vector.\n  Pass *ResultPass;\n  bool LocalChanged;\n  std::tie(ResultPass, LocalChanged) = Resolver->findImplPass(this, PI, F);\n\n  assert(ResultPass && \"Unable to find requested analysis info\");\n  if (Changed)\n    *Changed |= LocalChanged;\n  else\n    assert(!LocalChanged &&\n           \"A pass trigged a code update but the update status is lost\");\n\n  // Because the AnalysisType may not be a subclass of pass (for\n  // AnalysisGroups), we use getAdjustedAnalysisPointer here to potentially\n  // adjust the return pointer (because the class may multiply inherit, once\n  // from pass, once from AnalysisType).\n  return *(AnalysisType*)ResultPass->getAdjustedAnalysisPointer(PI);\n}\n\n} // end namespace llvm\n\n#endif // LLVM_PASSANALYSISSUPPORT_H\n"}, "44": {"id": 44, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/CommandLine.h", "content": "//===- llvm/Support/CommandLine.h - Command line handler --------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// This class implements a command line argument processor that is useful when\n// creating a tool.  It provides a simple, minimalistic interface that is easily\n// extensible and supports nonlocal (library) command line options.\n//\n// Note that rather than trying to figure out what this code does, you should\n// read the library documentation located in docs/CommandLine.html or looks at\n// the many example usages in tools/*/*.cpp\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_SUPPORT_COMMANDLINE_H\n#define LLVM_SUPPORT_COMMANDLINE_H\n\n#include \"llvm/ADT/ArrayRef.h\"\n#include \"llvm/ADT/None.h\"\n#include \"llvm/ADT/Optional.h\"\n#include \"llvm/ADT/STLExtras.h\"\n#include \"llvm/ADT/SmallPtrSet.h\"\n#include \"llvm/ADT/SmallVector.h\"\n#include \"llvm/ADT/StringMap.h\"\n#include \"llvm/ADT/StringRef.h\"\n#include \"llvm/ADT/Twine.h\"\n#include \"llvm/ADT/iterator_range.h\"\n#include \"llvm/Support/ErrorHandling.h\"\n#include \"llvm/Support/ManagedStatic.h\"\n#include \"llvm/Support/VirtualFileSystem.h\"\n#include \"llvm/Support/raw_ostream.h\"\n#include <cassert>\n#include <climits>\n#include <cstddef>\n#include <functional>\n#include <initializer_list>\n#include <string>\n#include <type_traits>\n#include <vector>\n\nnamespace llvm {\n\nclass StringSaver;\n\n/// cl Namespace - This namespace contains all of the command line option\n/// processing machinery.  It is intentionally a short name to make qualified\n/// usage concise.\nnamespace cl {\n\n//===----------------------------------------------------------------------===//\n// ParseCommandLineOptions - Command line option processing entry point.\n//\n// Returns true on success. Otherwise, this will print the error message to\n// stderr and exit if \\p Errs is not set (nullptr by default), or print the\n// error message to \\p Errs and return false if \\p Errs is provided.\n//\n// If EnvVar is not nullptr, command-line options are also parsed from the\n// environment variable named by EnvVar.  Precedence is given to occurrences\n// from argv.  This precedence is currently implemented by parsing argv after\n// the environment variable, so it is only implemented correctly for options\n// that give precedence to later occurrences.  If your program supports options\n// that give precedence to earlier occurrences, you will need to extend this\n// function to support it correctly.\nbool ParseCommandLineOptions(int argc, const char *const *argv,\n                             StringRef Overview = \"\",\n                             raw_ostream *Errs = nullptr,\n                             const char *EnvVar = nullptr,\n                             bool LongOptionsUseDoubleDash = false);\n\n// Function pointer type for printing version information.\nusing VersionPrinterTy = std::function<void(raw_ostream &)>;\n\n///===---------------------------------------------------------------------===//\n/// SetVersionPrinter - Override the default (LLVM specific) version printer\n///                     used to print out the version when --version is given\n///                     on the command line. This allows other systems using the\n///                     CommandLine utilities to print their own version string.\nvoid SetVersionPrinter(VersionPrinterTy func);\n\n///===---------------------------------------------------------------------===//\n/// AddExtraVersionPrinter - Add an extra printer to use in addition to the\n///                          default one. This can be called multiple times,\n///                          and each time it adds a new function to the list\n///                          which will be called after the basic LLVM version\n///                          printing is complete. Each can then add additional\n///                          information specific to the tool.\nvoid AddExtraVersionPrinter(VersionPrinterTy func);\n\n// PrintOptionValues - Print option values.\n// With -print-options print the difference between option values and defaults.\n// With -print-all-options print all option values.\n// (Currently not perfect, but best-effort.)\nvoid PrintOptionValues();\n\n// Forward declaration - AddLiteralOption needs to be up here to make gcc happy.\nclass Option;\n\n/// Adds a new option for parsing and provides the option it refers to.\n///\n/// \\param O pointer to the option\n/// \\param Name the string name for the option to handle during parsing\n///\n/// Literal options are used by some parsers to register special option values.\n/// This is how the PassNameParser registers pass names for opt.\nvoid AddLiteralOption(Option &O, StringRef Name);\n\n//===----------------------------------------------------------------------===//\n// Flags permitted to be passed to command line arguments\n//\n\nenum NumOccurrencesFlag { // Flags for the number of occurrences allowed\n  Optional = 0x00,        // Zero or One occurrence\n  ZeroOrMore = 0x01,      // Zero or more occurrences allowed\n  Required = 0x02,        // One occurrence required\n  OneOrMore = 0x03,       // One or more occurrences required\n\n  // ConsumeAfter - Indicates that this option is fed anything that follows the\n  // last positional argument required by the application (it is an error if\n  // there are zero positional arguments, and a ConsumeAfter option is used).\n  // Thus, for example, all arguments to LLI are processed until a filename is\n  // found.  Once a filename is found, all of the succeeding arguments are\n  // passed, unprocessed, to the ConsumeAfter option.\n  //\n  ConsumeAfter = 0x04\n};\n\nenum ValueExpected { // Is a value required for the option?\n  // zero reserved for the unspecified value\n  ValueOptional = 0x01,  // The value can appear... or not\n  ValueRequired = 0x02,  // The value is required to appear!\n  ValueDisallowed = 0x03 // A value may not be specified (for flags)\n};\n\nenum OptionHidden {   // Control whether -help shows this option\n  NotHidden = 0x00,   // Option included in -help & -help-hidden\n  Hidden = 0x01,      // -help doesn't, but -help-hidden does\n  ReallyHidden = 0x02 // Neither -help nor -help-hidden show this arg\n};\n\n// Formatting flags - This controls special features that the option might have\n// that cause it to be parsed differently...\n//\n// Prefix - This option allows arguments that are otherwise unrecognized to be\n// matched by options that are a prefix of the actual value.  This is useful for\n// cases like a linker, where options are typically of the form '-lfoo' or\n// '-L../../include' where -l or -L are the actual flags.  When prefix is\n// enabled, and used, the value for the flag comes from the suffix of the\n// argument.\n//\n// AlwaysPrefix - Only allow the behavior enabled by the Prefix flag and reject\n// the Option=Value form.\n//\n\nenum FormattingFlags {\n  NormalFormatting = 0x00, // Nothing special\n  Positional = 0x01,       // Is a positional argument, no '-' required\n  Prefix = 0x02,           // Can this option directly prefix its value?\n  AlwaysPrefix = 0x03      // Can this option only directly prefix its value?\n};\n\nenum MiscFlags {             // Miscellaneous flags to adjust argument\n  CommaSeparated = 0x01,     // Should this cl::list split between commas?\n  PositionalEatsArgs = 0x02, // Should this positional cl::list eat -args?\n  Sink = 0x04,               // Should this cl::list eat all unknown options?\n\n  // Grouping - Can this option group with other options?\n  // If this is enabled, multiple letter options are allowed to bunch together\n  // with only a single hyphen for the whole group.  This allows emulation\n  // of the behavior that ls uses for example: ls -la === ls -l -a\n  Grouping = 0x08,\n\n  // Default option\n  DefaultOption = 0x10\n};\n\n//===----------------------------------------------------------------------===//\n// Option Category class\n//\nclass OptionCategory {\nprivate:\n  StringRef const Name;\n  StringRef const Description;\n\n  void registerCategory();\n\npublic:\n  OptionCategory(StringRef const Name,\n                 StringRef const Description = \"\")\n      : Name(Name), Description(Description) {\n    registerCategory();\n  }\n\n  StringRef getName() const { return Name; }\n  StringRef getDescription() const { return Description; }\n};\n\n// The general Option Category (used as default category).\nextern OptionCategory GeneralCategory;\n\n//===----------------------------------------------------------------------===//\n// SubCommand class\n//\nclass SubCommand {\nprivate:\n  StringRef Name;\n  StringRef Description;\n\nprotected:\n  void registerSubCommand();\n  void unregisterSubCommand();\n\npublic:\n  SubCommand(StringRef Name, StringRef Description = \"\")\n      : Name(Name), Description(Description) {\n        registerSubCommand();\n  }\n  SubCommand() = default;\n\n  void reset();\n\n  explicit operator bool() const;\n\n  StringRef getName() const { return Name; }\n  StringRef getDescription() const { return Description; }\n\n  SmallVector<Option *, 4> PositionalOpts;\n  SmallVector<Option *, 4> SinkOpts;\n  StringMap<Option *> OptionsMap;\n\n  Option *ConsumeAfterOpt = nullptr; // The ConsumeAfter option if it exists.\n};\n\n// A special subcommand representing no subcommand\nextern ManagedStatic<SubCommand> TopLevelSubCommand;\n\n// A special subcommand that can be used to put an option into all subcommands.\nextern ManagedStatic<SubCommand> AllSubCommands;\n\n//===----------------------------------------------------------------------===//\n// Option Base class\n//\nclass Option {\n  friend class alias;\n\n  // handleOccurrences - Overriden by subclasses to handle the value passed into\n  // an argument.  Should return true if there was an error processing the\n  // argument and the program should exit.\n  //\n  virtual bool handleOccurrence(unsigned pos, StringRef ArgName,\n                                StringRef Arg) = 0;\n\n  virtual enum ValueExpected getValueExpectedFlagDefault() const {\n    return ValueOptional;\n  }\n\n  // Out of line virtual function to provide home for the class.\n  virtual void anchor();\n\n  uint16_t NumOccurrences; // The number of times specified\n  // Occurrences, HiddenFlag, and Formatting are all enum types but to avoid\n  // problems with signed enums in bitfields.\n  uint16_t Occurrences : 3; // enum NumOccurrencesFlag\n  // not using the enum type for 'Value' because zero is an implementation\n  // detail representing the non-value\n  uint16_t Value : 2;\n  uint16_t HiddenFlag : 2; // enum OptionHidden\n  uint16_t Formatting : 2; // enum FormattingFlags\n  uint16_t Misc : 5;\n  uint16_t FullyInitialized : 1; // Has addArgument been called?\n  uint16_t Position;             // Position of last occurrence of the option\n  uint16_t AdditionalVals;       // Greater than 0 for multi-valued option.\n\npublic:\n  StringRef ArgStr;   // The argument string itself (ex: \"help\", \"o\")\n  StringRef HelpStr;  // The descriptive text message for -help\n  StringRef ValueStr; // String describing what the value of this option is\n  SmallVector<OptionCategory *, 1>\n      Categories;                    // The Categories this option belongs to\n  SmallPtrSet<SubCommand *, 1> Subs; // The subcommands this option belongs to.\n\n  inline enum NumOccurrencesFlag getNumOccurrencesFlag() const {\n    return (enum NumOccurrencesFlag)Occurrences;\n  }\n\n  inline enum ValueExpected getValueExpectedFlag() const {\n    return Value ? ((enum ValueExpected)Value) : getValueExpectedFlagDefault();\n  }\n\n  inline enum OptionHidden getOptionHiddenFlag() const {\n    return (enum OptionHidden)HiddenFlag;\n  }\n\n  inline enum FormattingFlags getFormattingFlag() const {\n    return (enum FormattingFlags)Formatting;\n  }\n\n  inline unsigned getMiscFlags() const { return Misc; }\n  inline unsigned getPosition() const { return Position; }\n  inline unsigned getNumAdditionalVals() const { return AdditionalVals; }\n\n  // hasArgStr - Return true if the argstr != \"\"\n  bool hasArgStr() const { return !ArgStr.empty(); }\n  bool isPositional() const { return getFormattingFlag() == cl::Positional; }\n  bool isSink() const { return getMiscFlags() & cl::Sink; }\n  bool isDefaultOption() const { return getMiscFlags() & cl::DefaultOption; }\n\n  bool isConsumeAfter() const {\n    return getNumOccurrencesFlag() == cl::ConsumeAfter;\n  }\n\n  bool isInAllSubCommands() const {\n    return any_of(Subs, [](const SubCommand *SC) {\n      return SC == &*AllSubCommands;\n    });\n  }\n\n  //-------------------------------------------------------------------------===\n  // Accessor functions set by OptionModifiers\n  //\n  void setArgStr(StringRef S);\n  void setDescription(StringRef S) { HelpStr = S; }\n  void setValueStr(StringRef S) { ValueStr = S; }\n  void setNumOccurrencesFlag(enum NumOccurrencesFlag Val) { Occurrences = Val; }\n  void setValueExpectedFlag(enum ValueExpected Val) { Value = Val; }\n  void setHiddenFlag(enum OptionHidden Val) { HiddenFlag = Val; }\n  void setFormattingFlag(enum FormattingFlags V) { Formatting = V; }\n  void setMiscFlag(enum MiscFlags M) { Misc |= M; }\n  void setPosition(unsigned pos) { Position = pos; }\n  void addCategory(OptionCategory &C);\n  void addSubCommand(SubCommand &S) { Subs.insert(&S); }\n\nprotected:\n  explicit Option(enum NumOccurrencesFlag OccurrencesFlag,\n                  enum OptionHidden Hidden)\n      : NumOccurrences(0), Occurrences(OccurrencesFlag), Value(0),\n        HiddenFlag(Hidden), Formatting(NormalFormatting), Misc(0),\n        FullyInitialized(false), Position(0), AdditionalVals(0) {\n    Categories.push_back(&GeneralCategory);\n  }\n\n  inline void setNumAdditionalVals(unsigned n) { AdditionalVals = n; }\n\npublic:\n  virtual ~Option() = default;\n\n  // addArgument - Register this argument with the commandline system.\n  //\n  void addArgument();\n\n  /// Unregisters this option from the CommandLine system.\n  ///\n  /// This option must have been the last option registered.\n  /// For testing purposes only.\n  void removeArgument();\n\n  // Return the width of the option tag for printing...\n  virtual size_t getOptionWidth() const = 0;\n\n  // printOptionInfo - Print out information about this option.  The\n  // to-be-maintained width is specified.\n  //\n  virtual void printOptionInfo(size_t GlobalWidth) const = 0;\n\n  virtual void printOptionValue(size_t GlobalWidth, bool Force) const = 0;\n\n  virtual void setDefault() = 0;\n\n  // Prints the help string for an option.\n  //\n  // This maintains the Indent for multi-line descriptions.\n  // FirstLineIndentedBy is the count of chars of the first line\n  //      i.e. the one containing the --<option name>.\n  static void printHelpStr(StringRef HelpStr, size_t Indent,\n                           size_t FirstLineIndentedBy);\n\n  // Prints the help string for an enum value.\n  //\n  // This maintains the Indent for multi-line descriptions.\n  // FirstLineIndentedBy is the count of chars of the first line\n  //      i.e. the one containing the =<value>.\n  static void printEnumValHelpStr(StringRef HelpStr, size_t Indent,\n                                  size_t FirstLineIndentedBy);\n\n  virtual void getExtraOptionNames(SmallVectorImpl<StringRef> &) {}\n\n  // addOccurrence - Wrapper around handleOccurrence that enforces Flags.\n  //\n  virtual bool addOccurrence(unsigned pos, StringRef ArgName, StringRef Value,\n                             bool MultiArg = false);\n\n  // Prints option name followed by message.  Always returns true.\n  bool error(const Twine &Message, StringRef ArgName = StringRef(), raw_ostream &Errs = llvm::errs());\n  bool error(const Twine &Message, raw_ostream &Errs) {\n    return error(Message, StringRef(), Errs);\n  }\n\n  inline int getNumOccurrences() const { return NumOccurrences; }\n  void reset();\n};\n\n//===----------------------------------------------------------------------===//\n// Command line option modifiers that can be used to modify the behavior of\n// command line option parsers...\n//\n\n// desc - Modifier to set the description shown in the -help output...\nstruct desc {\n  StringRef Desc;\n\n  desc(StringRef Str) : Desc(Str) {}\n\n  void apply(Option &O) const { O.setDescription(Desc); }\n};\n\n// value_desc - Modifier to set the value description shown in the -help\n// output...\nstruct value_desc {\n  StringRef Desc;\n\n  value_desc(StringRef Str) : Desc(Str) {}\n\n  void apply(Option &O) const { O.setValueStr(Desc); }\n};\n\n// init - Specify a default (initial) value for the command line argument, if\n// the default constructor for the argument type does not give you what you\n// want.  This is only valid on \"opt\" arguments, not on \"list\" arguments.\n//\ntemplate <class Ty> struct initializer {\n  const Ty &Init;\n  initializer(const Ty &Val) : Init(Val) {}\n\n  template <class Opt> void apply(Opt &O) const { O.setInitialValue(Init); }\n};\n\ntemplate <class Ty> initializer<Ty> init(const Ty &Val) {\n  return initializer<Ty>(Val);\n}\n\n// location - Allow the user to specify which external variable they want to\n// store the results of the command line argument processing into, if they don't\n// want to store it in the option itself.\n//\ntemplate <class Ty> struct LocationClass {\n  Ty &Loc;\n\n  LocationClass(Ty &L) : Loc(L) {}\n\n  template <class Opt> void apply(Opt &O) const { O.setLocation(O, Loc); }\n};\n\ntemplate <class Ty> LocationClass<Ty> location(Ty &L) {\n  return LocationClass<Ty>(L);\n}\n\n// cat - Specifiy the Option category for the command line argument to belong\n// to.\nstruct cat {\n  OptionCategory &Category;\n\n  cat(OptionCategory &c) : Category(c) {}\n\n  template <class Opt> void apply(Opt &O) const { O.addCategory(Category); }\n};\n\n// sub - Specify the subcommand that this option belongs to.\nstruct sub {\n  SubCommand &Sub;\n\n  sub(SubCommand &S) : Sub(S) {}\n\n  template <class Opt> void apply(Opt &O) const { O.addSubCommand(Sub); }\n};\n\n// Specify a callback function to be called when an option is seen.\n// Can be used to set other options automatically.\ntemplate <typename R, typename Ty> struct cb {\n  std::function<R(Ty)> CB;\n\n  cb(std::function<R(Ty)> CB) : CB(CB) {}\n\n  template <typename Opt> void apply(Opt &O) const { O.setCallback(CB); }\n};\n\nnamespace detail {\ntemplate <typename F>\nstruct callback_traits : public callback_traits<decltype(&F::operator())> {};\n\ntemplate <typename R, typename C, typename... Args>\nstruct callback_traits<R (C::*)(Args...) const> {\n  using result_type = R;\n  using arg_type = std::tuple_element_t<0, std::tuple<Args...>>;\n  static_assert(sizeof...(Args) == 1, \"callback function must have one and only one parameter\");\n  static_assert(std::is_same<result_type, void>::value,\n                \"callback return type must be void\");\n  static_assert(std::is_lvalue_reference<arg_type>::value &&\n                    std::is_const<std::remove_reference_t<arg_type>>::value,\n                \"callback arg_type must be a const lvalue reference\");\n};\n} // namespace detail\n\ntemplate <typename F>\ncb<typename detail::callback_traits<F>::result_type,\n   typename detail::callback_traits<F>::arg_type>\ncallback(F CB) {\n  using result_type = typename detail::callback_traits<F>::result_type;\n  using arg_type = typename detail::callback_traits<F>::arg_type;\n  return cb<result_type, arg_type>(CB);\n}\n\n//===----------------------------------------------------------------------===//\n// OptionValue class\n\n// Support value comparison outside the template.\nstruct GenericOptionValue {\n  virtual bool compare(const GenericOptionValue &V) const = 0;\n\nprotected:\n  GenericOptionValue() = default;\n  GenericOptionValue(const GenericOptionValue&) = default;\n  GenericOptionValue &operator=(const GenericOptionValue &) = default;\n  ~GenericOptionValue() = default;\n\nprivate:\n  virtual void anchor();\n};\n\ntemplate <class DataType> struct OptionValue;\n\n// The default value safely does nothing. Option value printing is only\n// best-effort.\ntemplate <class DataType, bool isClass>\nstruct OptionValueBase : public GenericOptionValue {\n  // Temporary storage for argument passing.\n  using WrapperType = OptionValue<DataType>;\n\n  bool hasValue() const { return false; }\n\n  const DataType &getValue() const { llvm_unreachable(\"no default value\"); }\n\n  // Some options may take their value from a different data type.\n  template <class DT> void setValue(const DT & /*V*/) {}\n\n  bool compare(const DataType & /*V*/) const { return false; }\n\n  bool compare(const GenericOptionValue & /*V*/) const override {\n    return false;\n  }\n\nprotected:\n  ~OptionValueBase() = default;\n};\n\n// Simple copy of the option value.\ntemplate <class DataType> class OptionValueCopy : public GenericOptionValue {\n  DataType Value;\n  bool Valid = false;\n\nprotected:\n  OptionValueCopy(const OptionValueCopy&) = default;\n  OptionValueCopy &operator=(const OptionValueCopy &) = default;\n  ~OptionValueCopy() = default;\n\npublic:\n  OptionValueCopy() = default;\n\n  bool hasValue() const { return Valid; }\n\n  const DataType &getValue() const {\n    assert(Valid && \"invalid option value\");\n    return Value;\n  }\n\n  void setValue(const DataType &V) {\n    Valid = true;\n    Value = V;\n  }\n\n  bool compare(const DataType &V) const { return Valid && (Value != V); }\n\n  bool compare(const GenericOptionValue &V) const override {\n    const OptionValueCopy<DataType> &VC =\n        static_cast<const OptionValueCopy<DataType> &>(V);\n    if (!VC.hasValue())\n      return false;\n    return compare(VC.getValue());\n  }\n};\n\n// Non-class option values.\ntemplate <class DataType>\nstruct OptionValueBase<DataType, false> : OptionValueCopy<DataType> {\n  using WrapperType = DataType;\n\nprotected:\n  OptionValueBase() = default;\n  OptionValueBase(const OptionValueBase&) = default;\n  OptionValueBase &operator=(const OptionValueBase &) = default;\n  ~OptionValueBase() = default;\n};\n\n// Top-level option class.\ntemplate <class DataType>\nstruct OptionValue final\n    : OptionValueBase<DataType, std::is_class<DataType>::value> {\n  OptionValue() = default;\n\n  OptionValue(const DataType &V) { this->setValue(V); }\n\n  // Some options may take their value from a different data type.\n  template <class DT> OptionValue<DataType> &operator=(const DT &V) {\n    this->setValue(V);\n    return *this;\n  }\n};\n\n// Other safe-to-copy-by-value common option types.\nenum boolOrDefault { BOU_UNSET, BOU_TRUE, BOU_FALSE };\ntemplate <>\nstruct OptionValue<cl::boolOrDefault> final\n    : OptionValueCopy<cl::boolOrDefault> {\n  using WrapperType = cl::boolOrDefault;\n\n  OptionValue() = default;\n\n  OptionValue(const cl::boolOrDefault &V) { this->setValue(V); }\n\n  OptionValue<cl::boolOrDefault> &operator=(const cl::boolOrDefault &V) {\n    setValue(V);\n    return *this;\n  }\n\nprivate:\n  void anchor() override;\n};\n\ntemplate <>\nstruct OptionValue<std::string> final : OptionValueCopy<std::string> {\n  using WrapperType = StringRef;\n\n  OptionValue() = default;\n\n  OptionValue(const std::string &V) { this->setValue(V); }\n\n  OptionValue<std::string> &operator=(const std::string &V) {\n    setValue(V);\n    return *this;\n  }\n\nprivate:\n  void anchor() override;\n};\n\n//===----------------------------------------------------------------------===//\n// Enum valued command line option\n//\n\n// This represents a single enum value, using \"int\" as the underlying type.\nstruct OptionEnumValue {\n  StringRef Name;\n  int Value;\n  StringRef Description;\n};\n\n#define clEnumVal(ENUMVAL, DESC)                                               \\\n  llvm::cl::OptionEnumValue { #ENUMVAL, int(ENUMVAL), DESC }\n#define clEnumValN(ENUMVAL, FLAGNAME, DESC)                                    \\\n  llvm::cl::OptionEnumValue { FLAGNAME, int(ENUMVAL), DESC }\n\n// values - For custom data types, allow specifying a group of values together\n// as the values that go into the mapping that the option handler uses.\n//\nclass ValuesClass {\n  // Use a vector instead of a map, because the lists should be short,\n  // the overhead is less, and most importantly, it keeps them in the order\n  // inserted so we can print our option out nicely.\n  SmallVector<OptionEnumValue, 4> Values;\n\npublic:\n  ValuesClass(std::initializer_list<OptionEnumValue> Options)\n      : Values(Options) {}\n\n  template <class Opt> void apply(Opt &O) const {\n    for (const auto &Value : Values)\n      O.getParser().addLiteralOption(Value.Name, Value.Value,\n                                     Value.Description);\n  }\n};\n\n/// Helper to build a ValuesClass by forwarding a variable number of arguments\n/// as an initializer list to the ValuesClass constructor.\ntemplate <typename... OptsTy> ValuesClass values(OptsTy... Options) {\n  return ValuesClass({Options...});\n}\n\n//===----------------------------------------------------------------------===//\n// parser class - Parameterizable parser for different data types.  By default,\n// known data types (string, int, bool) have specialized parsers, that do what\n// you would expect.  The default parser, used for data types that are not\n// built-in, uses a mapping table to map specific options to values, which is\n// used, among other things, to handle enum types.\n\n//--------------------------------------------------\n// generic_parser_base - This class holds all the non-generic code that we do\n// not need replicated for every instance of the generic parser.  This also\n// allows us to put stuff into CommandLine.cpp\n//\nclass generic_parser_base {\nprotected:\n  class GenericOptionInfo {\n  public:\n    GenericOptionInfo(StringRef name, StringRef helpStr)\n        : Name(name), HelpStr(helpStr) {}\n    StringRef Name;\n    StringRef HelpStr;\n  };\n\npublic:\n  generic_parser_base(Option &O) : Owner(O) {}\n\n  virtual ~generic_parser_base() = default;\n  // Base class should have virtual-destructor\n\n  // getNumOptions - Virtual function implemented by generic subclass to\n  // indicate how many entries are in Values.\n  //\n  virtual unsigned getNumOptions() const = 0;\n\n  // getOption - Return option name N.\n  virtual StringRef getOption(unsigned N) const = 0;\n\n  // getDescription - Return description N\n  virtual StringRef getDescription(unsigned N) const = 0;\n\n  // Return the width of the option tag for printing...\n  virtual size_t getOptionWidth(const Option &O) const;\n\n  virtual const GenericOptionValue &getOptionValue(unsigned N) const = 0;\n\n  // printOptionInfo - Print out information about this option.  The\n  // to-be-maintained width is specified.\n  //\n  virtual void printOptionInfo(const Option &O, size_t GlobalWidth) const;\n\n  void printGenericOptionDiff(const Option &O, const GenericOptionValue &V,\n                              const GenericOptionValue &Default,\n                              size_t GlobalWidth) const;\n\n  // printOptionDiff - print the value of an option and it's default.\n  //\n  // Template definition ensures that the option and default have the same\n  // DataType (via the same AnyOptionValue).\n  template <class AnyOptionValue>\n  void printOptionDiff(const Option &O, const AnyOptionValue &V,\n                       const AnyOptionValue &Default,\n                       size_t GlobalWidth) const {\n    printGenericOptionDiff(O, V, Default, GlobalWidth);\n  }\n\n  void initialize() {}\n\n  void getExtraOptionNames(SmallVectorImpl<StringRef> &OptionNames) {\n    // If there has been no argstr specified, that means that we need to add an\n    // argument for every possible option.  This ensures that our options are\n    // vectored to us.\n    if (!Owner.hasArgStr())\n      for (unsigned i = 0, e = getNumOptions(); i != e; ++i)\n        OptionNames.push_back(getOption(i));\n  }\n\n  enum ValueExpected getValueExpectedFlagDefault() const {\n    // If there is an ArgStr specified, then we are of the form:\n    //\n    //    -opt=O2   or   -opt O2  or  -optO2\n    //\n    // In which case, the value is required.  Otherwise if an arg str has not\n    // been specified, we are of the form:\n    //\n    //    -O2 or O2 or -la (where -l and -a are separate options)\n    //\n    // If this is the case, we cannot allow a value.\n    //\n    if (Owner.hasArgStr())\n      return ValueRequired;\n    else\n      return ValueDisallowed;\n  }\n\n  // findOption - Return the option number corresponding to the specified\n  // argument string.  If the option is not found, getNumOptions() is returned.\n  //\n  unsigned findOption(StringRef Name);\n\nprotected:\n  Option &Owner;\n};\n\n// Default parser implementation - This implementation depends on having a\n// mapping of recognized options to values of some sort.  In addition to this,\n// each entry in the mapping also tracks a help message that is printed with the\n// command line option for -help.  Because this is a simple mapping parser, the\n// data type can be any unsupported type.\n//\ntemplate <class DataType> class parser : public generic_parser_base {\nprotected:\n  class OptionInfo : public GenericOptionInfo {\n  public:\n    OptionInfo(StringRef name, DataType v, StringRef helpStr)\n        : GenericOptionInfo(name, helpStr), V(v) {}\n\n    OptionValue<DataType> V;\n  };\n  SmallVector<OptionInfo, 8> Values;\n\npublic:\n  parser(Option &O) : generic_parser_base(O) {}\n\n  using parser_data_type = DataType;\n\n  // Implement virtual functions needed by generic_parser_base\n  unsigned getNumOptions() const override { return unsigned(Values.size()); }\n  StringRef getOption(unsigned N) const override { return Values[N].Name; }\n  StringRef getDescription(unsigned N) const override {\n    return Values[N].HelpStr;\n  }\n\n  // getOptionValue - Return the value of option name N.\n  const GenericOptionValue &getOptionValue(unsigned N) const override {\n    return Values[N].V;\n  }\n\n  // parse - Return true on error.\n  bool parse(Option &O, StringRef ArgName, StringRef Arg, DataType &V) {\n    StringRef ArgVal;\n    if (Owner.hasArgStr())\n      ArgVal = Arg;\n    else\n      ArgVal = ArgName;\n\n    for (size_t i = 0, e = Values.size(); i != e; ++i)\n      if (Values[i].Name == ArgVal) {\n        V = Values[i].V.getValue();\n        return false;\n      }\n\n    return O.error(\"Cannot find option named '\" + ArgVal + \"'!\");\n  }\n\n  /// addLiteralOption - Add an entry to the mapping table.\n  ///\n  template <class DT>\n  void addLiteralOption(StringRef Name, const DT &V, StringRef HelpStr) {\n    assert(findOption(Name) == Values.size() && \"Option already exists!\");\n    OptionInfo X(Name, static_cast<DataType>(V), HelpStr);\n    Values.push_back(X);\n    AddLiteralOption(Owner, Name);\n  }\n\n  /// removeLiteralOption - Remove the specified option.\n  ///\n  void removeLiteralOption(StringRef Name) {\n    unsigned N = findOption(Name);\n    assert(N != Values.size() && \"Option not found!\");\n    Values.erase(Values.begin() + N);\n  }\n};\n\n//--------------------------------------------------\n// basic_parser - Super class of parsers to provide boilerplate code\n//\nclass basic_parser_impl { // non-template implementation of basic_parser<t>\npublic:\n  basic_parser_impl(Option &) {}\n\n  virtual ~basic_parser_impl() {}\n\n  enum ValueExpected getValueExpectedFlagDefault() const {\n    return ValueRequired;\n  }\n\n  void getExtraOptionNames(SmallVectorImpl<StringRef> &) {}\n\n  void initialize() {}\n\n  // Return the width of the option tag for printing...\n  size_t getOptionWidth(const Option &O) const;\n\n  // printOptionInfo - Print out information about this option.  The\n  // to-be-maintained width is specified.\n  //\n  void printOptionInfo(const Option &O, size_t GlobalWidth) const;\n\n  // printOptionNoValue - Print a placeholder for options that don't yet support\n  // printOptionDiff().\n  void printOptionNoValue(const Option &O, size_t GlobalWidth) const;\n\n  // getValueName - Overload in subclass to provide a better default value.\n  virtual StringRef getValueName() const { return \"value\"; }\n\n  // An out-of-line virtual method to provide a 'home' for this class.\n  virtual void anchor();\n\nprotected:\n  // A helper for basic_parser::printOptionDiff.\n  void printOptionName(const Option &O, size_t GlobalWidth) const;\n};\n\n// basic_parser - The real basic parser is just a template wrapper that provides\n// a typedef for the provided data type.\n//\ntemplate <class DataType> class basic_parser : public basic_parser_impl {\npublic:\n  using parser_data_type = DataType;\n  using OptVal = OptionValue<DataType>;\n\n  basic_parser(Option &O) : basic_parser_impl(O) {}\n};\n\n//--------------------------------------------------\n// parser<bool>\n//\ntemplate <> class parser<bool> : public basic_parser<bool> {\npublic:\n  parser(Option &O) : basic_parser(O) {}\n\n  // parse - Return true on error.\n  bool parse(Option &O, StringRef ArgName, StringRef Arg, bool &Val);\n\n  void initialize() {}\n\n  enum ValueExpected getValueExpectedFlagDefault() const {\n    return ValueOptional;\n  }\n\n  // getValueName - Do not print =<value> at all.\n  StringRef getValueName() const override { return StringRef(); }\n\n  void printOptionDiff(const Option &O, bool V, OptVal Default,\n                       size_t GlobalWidth) const;\n\n  // An out-of-line virtual method to provide a 'home' for this class.\n  void anchor() override;\n};\n\nextern template class basic_parser<bool>;\n\n//--------------------------------------------------\n// parser<boolOrDefault>\ntemplate <> class parser<boolOrDefault> : public basic_parser<boolOrDefault> {\npublic:\n  parser(Option &O) : basic_parser(O) {}\n\n  // parse - Return true on error.\n  bool parse(Option &O, StringRef ArgName, StringRef Arg, boolOrDefault &Val);\n\n  enum ValueExpected getValueExpectedFlagDefault() const {\n    return ValueOptional;\n  }\n\n  // getValueName - Do not print =<value> at all.\n  StringRef getValueName() const override { return StringRef(); }\n\n  void printOptionDiff(const Option &O, boolOrDefault V, OptVal Default,\n                       size_t GlobalWidth) const;\n\n  // An out-of-line virtual method to provide a 'home' for this class.\n  void anchor() override;\n};\n\nextern template class basic_parser<boolOrDefault>;\n\n//--------------------------------------------------\n// parser<int>\n//\ntemplate <> class parser<int> : public basic_parser<int> {\npublic:\n  parser(Option &O) : basic_parser(O) {}\n\n  // parse - Return true on error.\n  bool parse(Option &O, StringRef ArgName, StringRef Arg, int &Val);\n\n  // getValueName - Overload in subclass to provide a better default value.\n  StringRef getValueName() const override { return \"int\"; }\n\n  void printOptionDiff(const Option &O, int V, OptVal Default,\n                       size_t GlobalWidth) const;\n\n  // An out-of-line virtual method to provide a 'home' for this class.\n  void anchor() override;\n};\n\nextern template class basic_parser<int>;\n\n//--------------------------------------------------\n// parser<long>\n//\ntemplate <> class parser<long> final : public basic_parser<long> {\npublic:\n  parser(Option &O) : basic_parser(O) {}\n\n  // parse - Return true on error.\n  bool parse(Option &O, StringRef ArgName, StringRef Arg, long &Val);\n\n  // getValueName - Overload in subclass to provide a better default value.\n  StringRef getValueName() const override { return \"long\"; }\n\n  void printOptionDiff(const Option &O, long V, OptVal Default,\n                       size_t GlobalWidth) const;\n\n  // An out-of-line virtual method to provide a 'home' for this class.\n  void anchor() override;\n};\n\nextern template class basic_parser<long>;\n\n//--------------------------------------------------\n// parser<long long>\n//\ntemplate <> class parser<long long> : public basic_parser<long long> {\npublic:\n  parser(Option &O) : basic_parser(O) {}\n\n  // parse - Return true on error.\n  bool parse(Option &O, StringRef ArgName, StringRef Arg, long long &Val);\n\n  // getValueName - Overload in subclass to provide a better default value.\n  StringRef getValueName() const override { return \"long\"; }\n\n  void printOptionDiff(const Option &O, long long V, OptVal Default,\n                       size_t GlobalWidth) const;\n\n  // An out-of-line virtual method to provide a 'home' for this class.\n  void anchor() override;\n};\n\nextern template class basic_parser<long long>;\n\n//--------------------------------------------------\n// parser<unsigned>\n//\ntemplate <> class parser<unsigned> : public basic_parser<unsigned> {\npublic:\n  parser(Option &O) : basic_parser(O) {}\n\n  // parse - Return true on error.\n  bool parse(Option &O, StringRef ArgName, StringRef Arg, unsigned &Val);\n\n  // getValueName - Overload in subclass to provide a better default value.\n  StringRef getValueName() const override { return \"uint\"; }\n\n  void printOptionDiff(const Option &O, unsigned V, OptVal Default,\n                       size_t GlobalWidth) const;\n\n  // An out-of-line virtual method to provide a 'home' for this class.\n  void anchor() override;\n};\n\nextern template class basic_parser<unsigned>;\n\n//--------------------------------------------------\n// parser<unsigned long>\n//\ntemplate <>\nclass parser<unsigned long> final : public basic_parser<unsigned long> {\npublic:\n  parser(Option &O) : basic_parser(O) {}\n\n  // parse - Return true on error.\n  bool parse(Option &O, StringRef ArgName, StringRef Arg, unsigned long &Val);\n\n  // getValueName - Overload in subclass to provide a better default value.\n  StringRef getValueName() const override { return \"ulong\"; }\n\n  void printOptionDiff(const Option &O, unsigned long V, OptVal Default,\n                       size_t GlobalWidth) const;\n\n  // An out-of-line virtual method to provide a 'home' for this class.\n  void anchor() override;\n};\n\nextern template class basic_parser<unsigned long>;\n\n//--------------------------------------------------\n// parser<unsigned long long>\n//\ntemplate <>\nclass parser<unsigned long long> : public basic_parser<unsigned long long> {\npublic:\n  parser(Option &O) : basic_parser(O) {}\n\n  // parse - Return true on error.\n  bool parse(Option &O, StringRef ArgName, StringRef Arg,\n             unsigned long long &Val);\n\n  // getValueName - Overload in subclass to provide a better default value.\n  StringRef getValueName() const override { return \"ulong\"; }\n\n  void printOptionDiff(const Option &O, unsigned long long V, OptVal Default,\n                       size_t GlobalWidth) const;\n\n  // An out-of-line virtual method to provide a 'home' for this class.\n  void anchor() override;\n};\n\nextern template class basic_parser<unsigned long long>;\n\n//--------------------------------------------------\n// parser<double>\n//\ntemplate <> class parser<double> : public basic_parser<double> {\npublic:\n  parser(Option &O) : basic_parser(O) {}\n\n  // parse - Return true on error.\n  bool parse(Option &O, StringRef ArgName, StringRef Arg, double &Val);\n\n  // getValueName - Overload in subclass to provide a better default value.\n  StringRef getValueName() const override { return \"number\"; }\n\n  void printOptionDiff(const Option &O, double V, OptVal Default,\n                       size_t GlobalWidth) const;\n\n  // An out-of-line virtual method to provide a 'home' for this class.\n  void anchor() override;\n};\n\nextern template class basic_parser<double>;\n\n//--------------------------------------------------\n// parser<float>\n//\ntemplate <> class parser<float> : public basic_parser<float> {\npublic:\n  parser(Option &O) : basic_parser(O) {}\n\n  // parse - Return true on error.\n  bool parse(Option &O, StringRef ArgName, StringRef Arg, float &Val);\n\n  // getValueName - Overload in subclass to provide a better default value.\n  StringRef getValueName() const override { return \"number\"; }\n\n  void printOptionDiff(const Option &O, float V, OptVal Default,\n                       size_t GlobalWidth) const;\n\n  // An out-of-line virtual method to provide a 'home' for this class.\n  void anchor() override;\n};\n\nextern template class basic_parser<float>;\n\n//--------------------------------------------------\n// parser<std::string>\n//\ntemplate <> class parser<std::string> : public basic_parser<std::string> {\npublic:\n  parser(Option &O) : basic_parser(O) {}\n\n  // parse - Return true on error.\n  bool parse(Option &, StringRef, StringRef Arg, std::string &Value) {\n    Value = Arg.str();\n    return false;\n  }\n\n  // getValueName - Overload in subclass to provide a better default value.\n  StringRef getValueName() const override { return \"string\"; }\n\n  void printOptionDiff(const Option &O, StringRef V, const OptVal &Default,\n                       size_t GlobalWidth) const;\n\n  // An out-of-line virtual method to provide a 'home' for this class.\n  void anchor() override;\n};\n\nextern template class basic_parser<std::string>;\n\n//--------------------------------------------------\n// parser<char>\n//\ntemplate <> class parser<char> : public basic_parser<char> {\npublic:\n  parser(Option &O) : basic_parser(O) {}\n\n  // parse - Return true on error.\n  bool parse(Option &, StringRef, StringRef Arg, char &Value) {\n    Value = Arg[0];\n    return false;\n  }\n\n  // getValueName - Overload in subclass to provide a better default value.\n  StringRef getValueName() const override { return \"char\"; }\n\n  void printOptionDiff(const Option &O, char V, OptVal Default,\n                       size_t GlobalWidth) const;\n\n  // An out-of-line virtual method to provide a 'home' for this class.\n  void anchor() override;\n};\n\nextern template class basic_parser<char>;\n\n//--------------------------------------------------\n// PrintOptionDiff\n//\n// This collection of wrappers is the intermediary between class opt and class\n// parser to handle all the template nastiness.\n\n// This overloaded function is selected by the generic parser.\ntemplate <class ParserClass, class DT>\nvoid printOptionDiff(const Option &O, const generic_parser_base &P, const DT &V,\n                     const OptionValue<DT> &Default, size_t GlobalWidth) {\n  OptionValue<DT> OV = V;\n  P.printOptionDiff(O, OV, Default, GlobalWidth);\n}\n\n// This is instantiated for basic parsers when the parsed value has a different\n// type than the option value. e.g. HelpPrinter.\ntemplate <class ParserDT, class ValDT> struct OptionDiffPrinter {\n  void print(const Option &O, const parser<ParserDT> &P, const ValDT & /*V*/,\n             const OptionValue<ValDT> & /*Default*/, size_t GlobalWidth) {\n    P.printOptionNoValue(O, GlobalWidth);\n  }\n};\n\n// This is instantiated for basic parsers when the parsed value has the same\n// type as the option value.\ntemplate <class DT> struct OptionDiffPrinter<DT, DT> {\n  void print(const Option &O, const parser<DT> &P, const DT &V,\n             const OptionValue<DT> &Default, size_t GlobalWidth) {\n    P.printOptionDiff(O, V, Default, GlobalWidth);\n  }\n};\n\n// This overloaded function is selected by the basic parser, which may parse a\n// different type than the option type.\ntemplate <class ParserClass, class ValDT>\nvoid printOptionDiff(\n    const Option &O,\n    const basic_parser<typename ParserClass::parser_data_type> &P,\n    const ValDT &V, const OptionValue<ValDT> &Default, size_t GlobalWidth) {\n\n  OptionDiffPrinter<typename ParserClass::parser_data_type, ValDT> printer;\n  printer.print(O, static_cast<const ParserClass &>(P), V, Default,\n                GlobalWidth);\n}\n\n//===----------------------------------------------------------------------===//\n// applicator class - This class is used because we must use partial\n// specialization to handle literal string arguments specially (const char* does\n// not correctly respond to the apply method).  Because the syntax to use this\n// is a pain, we have the 'apply' method below to handle the nastiness...\n//\ntemplate <class Mod> struct applicator {\n  template <class Opt> static void opt(const Mod &M, Opt &O) { M.apply(O); }\n};\n\n// Handle const char* as a special case...\ntemplate <unsigned n> struct applicator<char[n]> {\n  template <class Opt> static void opt(StringRef Str, Opt &O) {\n    O.setArgStr(Str);\n  }\n};\ntemplate <unsigned n> struct applicator<const char[n]> {\n  template <class Opt> static void opt(StringRef Str, Opt &O) {\n    O.setArgStr(Str);\n  }\n};\ntemplate <> struct applicator<StringRef > {\n  template <class Opt> static void opt(StringRef Str, Opt &O) {\n    O.setArgStr(Str);\n  }\n};\n\ntemplate <> struct applicator<NumOccurrencesFlag> {\n  static void opt(NumOccurrencesFlag N, Option &O) {\n    O.setNumOccurrencesFlag(N);\n  }\n};\n\ntemplate <> struct applicator<ValueExpected> {\n  static void opt(ValueExpected VE, Option &O) { O.setValueExpectedFlag(VE); }\n};\n\ntemplate <> struct applicator<OptionHidden> {\n  static void opt(OptionHidden OH, Option &O) { O.setHiddenFlag(OH); }\n};\n\ntemplate <> struct applicator<FormattingFlags> {\n  static void opt(FormattingFlags FF, Option &O) { O.setFormattingFlag(FF); }\n};\n\ntemplate <> struct applicator<MiscFlags> {\n  static void opt(MiscFlags MF, Option &O) {\n    assert((MF != Grouping || O.ArgStr.size() == 1) &&\n           \"cl::Grouping can only apply to single charater Options.\");\n    O.setMiscFlag(MF);\n  }\n};\n\n// apply method - Apply modifiers to an option in a type safe way.\ntemplate <class Opt, class Mod, class... Mods>\nvoid apply(Opt *O, const Mod &M, const Mods &... Ms) {\n  applicator<Mod>::opt(M, *O);\n  apply(O, Ms...);\n}\n\ntemplate <class Opt, class Mod> void apply(Opt *O, const Mod &M) {\n  applicator<Mod>::opt(M, *O);\n}\n\n//===----------------------------------------------------------------------===//\n// opt_storage class\n\n// Default storage class definition: external storage.  This implementation\n// assumes the user will specify a variable to store the data into with the\n// cl::location(x) modifier.\n//\ntemplate <class DataType, bool ExternalStorage, bool isClass>\nclass opt_storage {\n  DataType *Location = nullptr; // Where to store the object...\n  OptionValue<DataType> Default;\n\n  void check_location() const {\n    assert(Location && \"cl::location(...) not specified for a command \"\n                       \"line option with external storage, \"\n                       \"or cl::init specified before cl::location()!!\");\n  }\n\npublic:\n  opt_storage() = default;\n\n  bool setLocation(Option &O, DataType &L) {\n    if (Location)\n      return O.error(\"cl::location(x) specified more than once!\");\n    Location = &L;\n    Default = L;\n    return false;\n  }\n\n  template <class T> void setValue(const T &V, bool initial = false) {\n    check_location();\n    *Location = V;\n    if (initial)\n      Default = V;\n  }\n\n  DataType &getValue() {\n    check_location();\n    return *Location;\n  }\n  const DataType &getValue() const {\n    check_location();\n    return *Location;\n  }\n\n  operator DataType() const { return this->getValue(); }\n\n  const OptionValue<DataType> &getDefault() const { return Default; }\n};\n\n// Define how to hold a class type object, such as a string.  Since we can\n// inherit from a class, we do so.  This makes us exactly compatible with the\n// object in all cases that it is used.\n//\ntemplate <class DataType>\nclass opt_storage<DataType, false, true> : public DataType {\npublic:\n  OptionValue<DataType> Default;\n\n  template <class T> void setValue(const T &V, bool initial = false) {\n    DataType::operator=(V);\n    if (initial)\n      Default = V;\n  }\n\n  DataType &getValue() { return *this; }\n  const DataType &getValue() const { return *this; }\n\n  const OptionValue<DataType> &getDefault() const { return Default; }\n};\n\n// Define a partial specialization to handle things we cannot inherit from.  In\n// this case, we store an instance through containment, and overload operators\n// to get at the value.\n//\ntemplate <class DataType> class opt_storage<DataType, false, false> {\npublic:\n  DataType Value;\n  OptionValue<DataType> Default;\n\n  // Make sure we initialize the value with the default constructor for the\n  // type.\n  opt_storage() : Value(DataType()), Default(DataType()) {}\n\n  template <class T> void setValue(const T &V, bool initial = false) {\n    Value = V;\n    if (initial)\n      Default = V;\n  }\n  DataType &getValue() { return Value; }\n  DataType getValue() const { return Value; }\n\n  const OptionValue<DataType> &getDefault() const { return Default; }\n\n  operator DataType() const { return getValue(); }\n\n  // If the datatype is a pointer, support -> on it.\n  DataType operator->() const { return Value; }\n};\n\n//===----------------------------------------------------------------------===//\n// opt - A scalar command line option.\n//\ntemplate <class DataType, bool ExternalStorage = false,\n          class ParserClass = parser<DataType>>\nclass opt : public Option,\n            public opt_storage<DataType, ExternalStorage,\n                               std::is_class<DataType>::value> {\n  ParserClass Parser;\n\n  bool handleOccurrence(unsigned pos, StringRef ArgName,\n                        StringRef Arg) override {\n    typename ParserClass::parser_data_type Val =\n        typename ParserClass::parser_data_type();\n    if (Parser.parse(*this, ArgName, Arg, Val))\n      return true; // Parse error!\n    this->setValue(Val);\n    this->setPosition(pos);\n    Callback(Val);\n    return false;\n  }\n\n  enum ValueExpected getValueExpectedFlagDefault() const override {\n    return Parser.getValueExpectedFlagDefault();\n  }\n\n  void getExtraOptionNames(SmallVectorImpl<StringRef> &OptionNames) override {\n    return Parser.getExtraOptionNames(OptionNames);\n  }\n\n  // Forward printing stuff to the parser...\n  size_t getOptionWidth() const override {\n    return Parser.getOptionWidth(*this);\n  }\n\n  void printOptionInfo(size_t GlobalWidth) const override {\n    Parser.printOptionInfo(*this, GlobalWidth);\n  }\n\n  void printOptionValue(size_t GlobalWidth, bool Force) const override {\n    if (Force || this->getDefault().compare(this->getValue())) {\n      cl::printOptionDiff<ParserClass>(*this, Parser, this->getValue(),\n                                       this->getDefault(), GlobalWidth);\n    }\n  }\n\n  template <class T,\n            class = std::enable_if_t<std::is_assignable<T &, T>::value>>\n  void setDefaultImpl() {\n    const OptionValue<DataType> &V = this->getDefault();\n    if (V.hasValue())\n      this->setValue(V.getValue());\n  }\n\n  template <class T,\n            class = std::enable_if_t<!std::is_assignable<T &, T>::value>>\n  void setDefaultImpl(...) {}\n\n  void setDefault() override { setDefaultImpl<DataType>(); }\n\n  void done() {\n    addArgument();\n    Parser.initialize();\n  }\n\npublic:\n  // Command line options should not be copyable\n  opt(const opt &) = delete;\n  opt &operator=(const opt &) = delete;\n\n  // setInitialValue - Used by the cl::init modifier...\n  void setInitialValue(const DataType &V) { this->setValue(V, true); }\n\n  ParserClass &getParser() { return Parser; }\n\n  template <class T> DataType &operator=(const T &Val) {\n    this->setValue(Val);\n    Callback(Val);\n    return this->getValue();\n  }\n\n  template <class... Mods>\n  explicit opt(const Mods &... Ms)\n      : Option(llvm::cl::Optional, NotHidden), Parser(*this) {\n    apply(this, Ms...);\n    done();\n  }\n\n  void setCallback(\n      std::function<void(const typename ParserClass::parser_data_type &)> CB) {\n    Callback = CB;\n  }\n\n  std::function<void(const typename ParserClass::parser_data_type &)> Callback =\n      [](const typename ParserClass::parser_data_type &) {};\n};\n\nextern template class opt<unsigned>;\nextern template class opt<int>;\nextern template class opt<std::string>;\nextern template class opt<char>;\nextern template class opt<bool>;\n\n//===----------------------------------------------------------------------===//\n// list_storage class\n\n// Default storage class definition: external storage.  This implementation\n// assumes the user will specify a variable to store the data into with the\n// cl::location(x) modifier.\n//\ntemplate <class DataType, class StorageClass> class list_storage {\n  StorageClass *Location = nullptr; // Where to store the object...\n\npublic:\n  list_storage() = default;\n\n  void clear() {}\n\n  bool setLocation(Option &O, StorageClass &L) {\n    if (Location)\n      return O.error(\"cl::location(x) specified more than once!\");\n    Location = &L;\n    return false;\n  }\n\n  template <class T> void addValue(const T &V) {\n    assert(Location != 0 && \"cl::location(...) not specified for a command \"\n                            \"line option with external storage!\");\n    Location->push_back(V);\n  }\n};\n\n// Define how to hold a class type object, such as a string.\n// Originally this code inherited from std::vector. In transitioning to a new\n// API for command line options we should change this. The new implementation\n// of this list_storage specialization implements the minimum subset of the\n// std::vector API required for all the current clients.\n//\n// FIXME: Reduce this API to a more narrow subset of std::vector\n//\ntemplate <class DataType> class list_storage<DataType, bool> {\n  std::vector<DataType> Storage;\n\npublic:\n  using iterator = typename std::vector<DataType>::iterator;\n\n  iterator begin() { return Storage.begin(); }\n  iterator end() { return Storage.end(); }\n\n  using const_iterator = typename std::vector<DataType>::const_iterator;\n\n  const_iterator begin() const { return Storage.begin(); }\n  const_iterator end() const { return Storage.end(); }\n\n  using size_type = typename std::vector<DataType>::size_type;\n\n  size_type size() const { return Storage.size(); }\n\n  bool empty() const { return Storage.empty(); }\n\n  void push_back(const DataType &value) { Storage.push_back(value); }\n  void push_back(DataType &&value) { Storage.push_back(value); }\n\n  using reference = typename std::vector<DataType>::reference;\n  using const_reference = typename std::vector<DataType>::const_reference;\n\n  reference operator[](size_type pos) { return Storage[pos]; }\n  const_reference operator[](size_type pos) const { return Storage[pos]; }\n\n  void clear() {\n    Storage.clear();\n  }\n\n  iterator erase(const_iterator pos) { return Storage.erase(pos); }\n  iterator erase(const_iterator first, const_iterator last) {\n    return Storage.erase(first, last);\n  }\n\n  iterator erase(iterator pos) { return Storage.erase(pos); }\n  iterator erase(iterator first, iterator last) {\n    return Storage.erase(first, last);\n  }\n\n  iterator insert(const_iterator pos, const DataType &value) {\n    return Storage.insert(pos, value);\n  }\n  iterator insert(const_iterator pos, DataType &&value) {\n    return Storage.insert(pos, value);\n  }\n\n  iterator insert(iterator pos, const DataType &value) {\n    return Storage.insert(pos, value);\n  }\n  iterator insert(iterator pos, DataType &&value) {\n    return Storage.insert(pos, value);\n  }\n\n  reference front() { return Storage.front(); }\n  const_reference front() const { return Storage.front(); }\n\n  operator std::vector<DataType> &() { return Storage; }\n  operator ArrayRef<DataType>() const { return Storage; }\n  std::vector<DataType> *operator&() { return &Storage; }\n  const std::vector<DataType> *operator&() const { return &Storage; }\n\n  template <class T> void addValue(const T &V) { Storage.push_back(V); }\n};\n\n//===----------------------------------------------------------------------===//\n// list - A list of command line options.\n//\ntemplate <class DataType, class StorageClass = bool,\n          class ParserClass = parser<DataType>>\nclass list : public Option, public list_storage<DataType, StorageClass> {\n  std::vector<unsigned> Positions;\n  ParserClass Parser;\n\n  enum ValueExpected getValueExpectedFlagDefault() const override {\n    return Parser.getValueExpectedFlagDefault();\n  }\n\n  void getExtraOptionNames(SmallVectorImpl<StringRef> &OptionNames) override {\n    return Parser.getExtraOptionNames(OptionNames);\n  }\n\n  bool handleOccurrence(unsigned pos, StringRef ArgName,\n                        StringRef Arg) override {\n    typename ParserClass::parser_data_type Val =\n        typename ParserClass::parser_data_type();\n    if (Parser.parse(*this, ArgName, Arg, Val))\n      return true; // Parse Error!\n    list_storage<DataType, StorageClass>::addValue(Val);\n    setPosition(pos);\n    Positions.push_back(pos);\n    Callback(Val);\n    return false;\n  }\n\n  // Forward printing stuff to the parser...\n  size_t getOptionWidth() const override {\n    return Parser.getOptionWidth(*this);\n  }\n\n  void printOptionInfo(size_t GlobalWidth) const override {\n    Parser.printOptionInfo(*this, GlobalWidth);\n  }\n\n  // Unimplemented: list options don't currently store their default value.\n  void printOptionValue(size_t /*GlobalWidth*/, bool /*Force*/) const override {\n  }\n\n  void setDefault() override {\n    Positions.clear();\n    list_storage<DataType, StorageClass>::clear();\n  }\n\n  void done() {\n    addArgument();\n    Parser.initialize();\n  }\n\npublic:\n  // Command line options should not be copyable\n  list(const list &) = delete;\n  list &operator=(const list &) = delete;\n\n  ParserClass &getParser() { return Parser; }\n\n  unsigned getPosition(unsigned optnum) const {\n    assert(optnum < this->size() && \"Invalid option index\");\n    return Positions[optnum];\n  }\n\n  void setNumAdditionalVals(unsigned n) { Option::setNumAdditionalVals(n); }\n\n  template <class... Mods>\n  explicit list(const Mods &... Ms)\n      : Option(ZeroOrMore, NotHidden), Parser(*this) {\n    apply(this, Ms...);\n    done();\n  }\n\n  void setCallback(\n      std::function<void(const typename ParserClass::parser_data_type &)> CB) {\n    Callback = CB;\n  }\n\n  std::function<void(const typename ParserClass::parser_data_type &)> Callback =\n      [](const typename ParserClass::parser_data_type &) {};\n};\n\n// multi_val - Modifier to set the number of additional values.\nstruct multi_val {\n  unsigned AdditionalVals;\n  explicit multi_val(unsigned N) : AdditionalVals(N) {}\n\n  template <typename D, typename S, typename P>\n  void apply(list<D, S, P> &L) const {\n    L.setNumAdditionalVals(AdditionalVals);\n  }\n};\n\n//===----------------------------------------------------------------------===//\n// bits_storage class\n\n// Default storage class definition: external storage.  This implementation\n// assumes the user will specify a variable to store the data into with the\n// cl::location(x) modifier.\n//\ntemplate <class DataType, class StorageClass> class bits_storage {\n  unsigned *Location = nullptr; // Where to store the bits...\n\n  template <class T> static unsigned Bit(const T &V) {\n    unsigned BitPos = reinterpret_cast<unsigned>(V);\n    assert(BitPos < sizeof(unsigned) * CHAR_BIT &&\n           \"enum exceeds width of bit vector!\");\n    return 1 << BitPos;\n  }\n\npublic:\n  bits_storage() = default;\n\n  bool setLocation(Option &O, unsigned &L) {\n    if (Location)\n      return O.error(\"cl::location(x) specified more than once!\");\n    Location = &L;\n    return false;\n  }\n\n  template <class T> void addValue(const T &V) {\n    assert(Location != 0 && \"cl::location(...) not specified for a command \"\n                            \"line option with external storage!\");\n    *Location |= Bit(V);\n  }\n\n  unsigned getBits() { return *Location; }\n\n  template <class T> bool isSet(const T &V) {\n    return (*Location & Bit(V)) != 0;\n  }\n};\n\n// Define how to hold bits.  Since we can inherit from a class, we do so.\n// This makes us exactly compatible with the bits in all cases that it is used.\n//\ntemplate <class DataType> class bits_storage<DataType, bool> {\n  unsigned Bits; // Where to store the bits...\n\n  template <class T> static unsigned Bit(const T &V) {\n    unsigned BitPos = (unsigned)V;\n    assert(BitPos < sizeof(unsigned) * CHAR_BIT &&\n           \"enum exceeds width of bit vector!\");\n    return 1 << BitPos;\n  }\n\npublic:\n  template <class T> void addValue(const T &V) { Bits |= Bit(V); }\n\n  unsigned getBits() { return Bits; }\n\n  template <class T> bool isSet(const T &V) { return (Bits & Bit(V)) != 0; }\n};\n\n//===----------------------------------------------------------------------===//\n// bits - A bit vector of command options.\n//\ntemplate <class DataType, class Storage = bool,\n          class ParserClass = parser<DataType>>\nclass bits : public Option, public bits_storage<DataType, Storage> {\n  std::vector<unsigned> Positions;\n  ParserClass Parser;\n\n  enum ValueExpected getValueExpectedFlagDefault() const override {\n    return Parser.getValueExpectedFlagDefault();\n  }\n\n  void getExtraOptionNames(SmallVectorImpl<StringRef> &OptionNames) override {\n    return Parser.getExtraOptionNames(OptionNames);\n  }\n\n  bool handleOccurrence(unsigned pos, StringRef ArgName,\n                        StringRef Arg) override {\n    typename ParserClass::parser_data_type Val =\n        typename ParserClass::parser_data_type();\n    if (Parser.parse(*this, ArgName, Arg, Val))\n      return true; // Parse Error!\n    this->addValue(Val);\n    setPosition(pos);\n    Positions.push_back(pos);\n    Callback(Val);\n    return false;\n  }\n\n  // Forward printing stuff to the parser...\n  size_t getOptionWidth() const override {\n    return Parser.getOptionWidth(*this);\n  }\n\n  void printOptionInfo(size_t GlobalWidth) const override {\n    Parser.printOptionInfo(*this, GlobalWidth);\n  }\n\n  // Unimplemented: bits options don't currently store their default values.\n  void printOptionValue(size_t /*GlobalWidth*/, bool /*Force*/) const override {\n  }\n\n  void setDefault() override {}\n\n  void done() {\n    addArgument();\n    Parser.initialize();\n  }\n\npublic:\n  // Command line options should not be copyable\n  bits(const bits &) = delete;\n  bits &operator=(const bits &) = delete;\n\n  ParserClass &getParser() { return Parser; }\n\n  unsigned getPosition(unsigned optnum) const {\n    assert(optnum < this->size() && \"Invalid option index\");\n    return Positions[optnum];\n  }\n\n  template <class... Mods>\n  explicit bits(const Mods &... Ms)\n      : Option(ZeroOrMore, NotHidden), Parser(*this) {\n    apply(this, Ms...);\n    done();\n  }\n\n  void setCallback(\n      std::function<void(const typename ParserClass::parser_data_type &)> CB) {\n    Callback = CB;\n  }\n\n  std::function<void(const typename ParserClass::parser_data_type &)> Callback =\n      [](const typename ParserClass::parser_data_type &) {};\n};\n\n//===----------------------------------------------------------------------===//\n// Aliased command line option (alias this name to a preexisting name)\n//\n\nclass alias : public Option {\n  Option *AliasFor;\n\n  bool handleOccurrence(unsigned pos, StringRef /*ArgName*/,\n                        StringRef Arg) override {\n    return AliasFor->handleOccurrence(pos, AliasFor->ArgStr, Arg);\n  }\n\n  bool addOccurrence(unsigned pos, StringRef /*ArgName*/, StringRef Value,\n                     bool MultiArg = false) override {\n    return AliasFor->addOccurrence(pos, AliasFor->ArgStr, Value, MultiArg);\n  }\n\n  // Handle printing stuff...\n  size_t getOptionWidth() const override;\n  void printOptionInfo(size_t GlobalWidth) const override;\n\n  // Aliases do not need to print their values.\n  void printOptionValue(size_t /*GlobalWidth*/, bool /*Force*/) const override {\n  }\n\n  void setDefault() override { AliasFor->setDefault(); }\n\n  ValueExpected getValueExpectedFlagDefault() const override {\n    return AliasFor->getValueExpectedFlag();\n  }\n\n  void done() {\n    if (!hasArgStr())\n      error(\"cl::alias must have argument name specified!\");\n    if (!AliasFor)\n      error(\"cl::alias must have an cl::aliasopt(option) specified!\");\n    if (!Subs.empty())\n      error(\"cl::alias must not have cl::sub(), aliased option's cl::sub() will be used!\");\n    Subs = AliasFor->Subs;\n    Categories = AliasFor->Categories;\n    addArgument();\n  }\n\npublic:\n  // Command line options should not be copyable\n  alias(const alias &) = delete;\n  alias &operator=(const alias &) = delete;\n\n  void setAliasFor(Option &O) {\n    if (AliasFor)\n      error(\"cl::alias must only have one cl::aliasopt(...) specified!\");\n    AliasFor = &O;\n  }\n\n  template <class... Mods>\n  explicit alias(const Mods &... Ms)\n      : Option(Optional, Hidden), AliasFor(nullptr) {\n    apply(this, Ms...);\n    done();\n  }\n};\n\n// aliasfor - Modifier to set the option an alias aliases.\nstruct aliasopt {\n  Option &Opt;\n\n  explicit aliasopt(Option &O) : Opt(O) {}\n\n  void apply(alias &A) const { A.setAliasFor(Opt); }\n};\n\n// extrahelp - provide additional help at the end of the normal help\n// output. All occurrences of cl::extrahelp will be accumulated and\n// printed to stderr at the end of the regular help, just before\n// exit is called.\nstruct extrahelp {\n  StringRef morehelp;\n\n  explicit extrahelp(StringRef help);\n};\n\nvoid PrintVersionMessage();\n\n/// This function just prints the help message, exactly the same way as if the\n/// -help or -help-hidden option had been given on the command line.\n///\n/// \\param Hidden if true will print hidden options\n/// \\param Categorized if true print options in categories\nvoid PrintHelpMessage(bool Hidden = false, bool Categorized = false);\n\n//===----------------------------------------------------------------------===//\n// Public interface for accessing registered options.\n//\n\n/// Use this to get a StringMap to all registered named options\n/// (e.g. -help).\n///\n/// \\return A reference to the StringMap used by the cl APIs to parse options.\n///\n/// Access to unnamed arguments (i.e. positional) are not provided because\n/// it is expected that the client already has access to these.\n///\n/// Typical usage:\n/// \\code\n/// main(int argc,char* argv[]) {\n/// StringMap<llvm::cl::Option*> &opts = llvm::cl::getRegisteredOptions();\n/// assert(opts.count(\"help\") == 1)\n/// opts[\"help\"]->setDescription(\"Show alphabetical help information\")\n/// // More code\n/// llvm::cl::ParseCommandLineOptions(argc,argv);\n/// //More code\n/// }\n/// \\endcode\n///\n/// This interface is useful for modifying options in libraries that are out of\n/// the control of the client. The options should be modified before calling\n/// llvm::cl::ParseCommandLineOptions().\n///\n/// Hopefully this API can be deprecated soon. Any situation where options need\n/// to be modified by tools or libraries should be handled by sane APIs rather\n/// than just handing around a global list.\nStringMap<Option *> &getRegisteredOptions(SubCommand &Sub = *TopLevelSubCommand);\n\n/// Use this to get all registered SubCommands from the provided parser.\n///\n/// \\return A range of all SubCommand pointers registered with the parser.\n///\n/// Typical usage:\n/// \\code\n/// main(int argc, char* argv[]) {\n///   llvm::cl::ParseCommandLineOptions(argc, argv);\n///   for (auto* S : llvm::cl::getRegisteredSubcommands()) {\n///     if (*S) {\n///       std::cout << \"Executing subcommand: \" << S->getName() << std::endl;\n///       // Execute some function based on the name...\n///     }\n///   }\n/// }\n/// \\endcode\n///\n/// This interface is useful for defining subcommands in libraries and\n/// the dispatch from a single point (like in the main function).\niterator_range<typename SmallPtrSet<SubCommand *, 4>::iterator>\ngetRegisteredSubcommands();\n\n//===----------------------------------------------------------------------===//\n// Standalone command line processing utilities.\n//\n\n/// Tokenizes a command line that can contain escapes and quotes.\n//\n/// The quoting rules match those used by GCC and other tools that use\n/// libiberty's buildargv() or expandargv() utilities, and do not match bash.\n/// They differ from buildargv() on treatment of backslashes that do not escape\n/// a special character to make it possible to accept most Windows file paths.\n///\n/// \\param [in] Source The string to be split on whitespace with quotes.\n/// \\param [in] Saver Delegates back to the caller for saving parsed strings.\n/// \\param [in] MarkEOLs true if tokenizing a response file and you want end of\n/// lines and end of the response file to be marked with a nullptr string.\n/// \\param [out] NewArgv All parsed strings are appended to NewArgv.\nvoid TokenizeGNUCommandLine(StringRef Source, StringSaver &Saver,\n                            SmallVectorImpl<const char *> &NewArgv,\n                            bool MarkEOLs = false);\n\n/// Tokenizes a Windows command line which may contain quotes and escaped\n/// quotes.\n///\n/// See MSDN docs for CommandLineToArgvW for information on the quoting rules.\n/// http://msdn.microsoft.com/en-us/library/windows/desktop/17w5ykft(v=vs.85).aspx\n///\n/// \\param [in] Source The string to be split on whitespace with quotes.\n/// \\param [in] Saver Delegates back to the caller for saving parsed strings.\n/// \\param [in] MarkEOLs true if tokenizing a response file and you want end of\n/// lines and end of the response file to be marked with a nullptr string.\n/// \\param [out] NewArgv All parsed strings are appended to NewArgv.\nvoid TokenizeWindowsCommandLine(StringRef Source, StringSaver &Saver,\n                                SmallVectorImpl<const char *> &NewArgv,\n                                bool MarkEOLs = false);\n\n/// Tokenizes a Windows command line while attempting to avoid copies. If no\n/// quoting or escaping was used, this produces substrings of the original\n/// string. If a token requires unquoting, it will be allocated with the\n/// StringSaver.\nvoid TokenizeWindowsCommandLineNoCopy(StringRef Source, StringSaver &Saver,\n                                      SmallVectorImpl<StringRef> &NewArgv);\n\n/// String tokenization function type.  Should be compatible with either\n/// Windows or Unix command line tokenizers.\nusing TokenizerCallback = void (*)(StringRef Source, StringSaver &Saver,\n                                   SmallVectorImpl<const char *> &NewArgv,\n                                   bool MarkEOLs);\n\n/// Tokenizes content of configuration file.\n///\n/// \\param [in] Source The string representing content of config file.\n/// \\param [in] Saver Delegates back to the caller for saving parsed strings.\n/// \\param [out] NewArgv All parsed strings are appended to NewArgv.\n/// \\param [in] MarkEOLs Added for compatibility with TokenizerCallback.\n///\n/// It works like TokenizeGNUCommandLine with ability to skip comment lines.\n///\nvoid tokenizeConfigFile(StringRef Source, StringSaver &Saver,\n                        SmallVectorImpl<const char *> &NewArgv,\n                        bool MarkEOLs = false);\n\n/// Reads command line options from the given configuration file.\n///\n/// \\param [in] CfgFileName Path to configuration file.\n/// \\param [in] Saver  Objects that saves allocated strings.\n/// \\param [out] Argv Array to which the read options are added.\n/// \\return true if the file was successfully read.\n///\n/// It reads content of the specified file, tokenizes it and expands \"@file\"\n/// commands resolving file names in them relative to the directory where\n/// CfgFilename resides.\n///\nbool readConfigFile(StringRef CfgFileName, StringSaver &Saver,\n                    SmallVectorImpl<const char *> &Argv);\n\n/// Expand response files on a command line recursively using the given\n/// StringSaver and tokenization strategy.  Argv should contain the command line\n/// before expansion and will be modified in place. If requested, Argv will\n/// also be populated with nullptrs indicating where each response file line\n/// ends, which is useful for the \"/link\" argument that needs to consume all\n/// remaining arguments only until the next end of line, when in a response\n/// file.\n///\n/// \\param [in] Saver Delegates back to the caller for saving parsed strings.\n/// \\param [in] Tokenizer Tokenization strategy. Typically Unix or Windows.\n/// \\param [in,out] Argv Command line into which to expand response files.\n/// \\param [in] MarkEOLs Mark end of lines and the end of the response file\n/// with nullptrs in the Argv vector.\n/// \\param [in] RelativeNames true if names of nested response files must be\n/// resolved relative to including file.\n/// \\param [in] FS File system used for all file access when running the tool.\n/// \\param [in] CurrentDir Path used to resolve relative rsp files. If set to\n/// None, process' cwd is used instead.\n/// \\return true if all @files were expanded successfully or there were none.\nbool ExpandResponseFiles(\n    StringSaver &Saver, TokenizerCallback Tokenizer,\n    SmallVectorImpl<const char *> &Argv, bool MarkEOLs = false,\n    bool RelativeNames = false,\n    llvm::vfs::FileSystem &FS = *llvm::vfs::getRealFileSystem(),\n    llvm::Optional<llvm::StringRef> CurrentDir = llvm::None);\n\n/// A convenience helper which concatenates the options specified by the\n/// environment variable EnvVar and command line options, then expands response\n/// files recursively. The tokenizer is a predefined GNU or Windows one.\n/// \\return true if all @files were expanded successfully or there were none.\nbool expandResponseFiles(int Argc, const char *const *Argv, const char *EnvVar,\n                         StringSaver &Saver,\n                         SmallVectorImpl<const char *> &NewArgv);\n\n/// Mark all options not part of this category as cl::ReallyHidden.\n///\n/// \\param Category the category of options to keep displaying\n///\n/// Some tools (like clang-format) like to be able to hide all options that are\n/// not specific to the tool. This function allows a tool to specify a single\n/// option category to display in the -help output.\nvoid HideUnrelatedOptions(cl::OptionCategory &Category,\n                          SubCommand &Sub = *TopLevelSubCommand);\n\n/// Mark all options not part of the categories as cl::ReallyHidden.\n///\n/// \\param Categories the categories of options to keep displaying.\n///\n/// Some tools (like clang-format) like to be able to hide all options that are\n/// not specific to the tool. This function allows a tool to specify a single\n/// option category to display in the -help output.\nvoid HideUnrelatedOptions(ArrayRef<const cl::OptionCategory *> Categories,\n                          SubCommand &Sub = *TopLevelSubCommand);\n\n/// Reset all command line options to a state that looks as if they have\n/// never appeared on the command line.  This is useful for being able to parse\n/// a command line multiple times (especially useful for writing tests).\nvoid ResetAllOptionOccurrences();\n\n/// Reset the command line parser back to its initial state.  This\n/// removes\n/// all options, categories, and subcommands and returns the parser to a state\n/// where no options are supported.\nvoid ResetCommandLineParser();\n\n/// Parses `Arg` into the option handler `Handler`.\nbool ProvidePositionalOption(Option *Handler, StringRef Arg, int i);\n\n} // end namespace cl\n\n} // end namespace llvm\n\n#endif // LLVM_SUPPORT_COMMANDLINE_H\n"}, "48": {"id": 48, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/InstructionCost.h", "content": "//===- InstructionCost.h ----------------------------------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n/// \\file\n/// This file defines an InstructionCost class that is used when calculating\n/// the cost of an instruction, or a group of instructions. In addition to a\n/// numeric value representing the cost the class also contains a state that\n/// can be used to encode particular properties, i.e. a cost being invalid or\n/// unknown.\n///\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_SUPPORT_INSTRUCTIONCOST_H\n#define LLVM_SUPPORT_INSTRUCTIONCOST_H\n\n#include \"llvm/ADT/Optional.h\"\n\nnamespace llvm {\n\nclass raw_ostream;\n\nclass InstructionCost {\npublic:\n  using CostType = int;\n\n  /// These states can currently be used to indicate whether a cost is valid or\n  /// invalid. Examples of an invalid cost might be where the cost is\n  /// prohibitively expensive and the user wants to prevent certain\n  /// optimizations being performed. Or perhaps the cost is simply unknown\n  /// because the operation makes no sense in certain circumstances. These\n  /// states can be expanded in future to support other cases if necessary.\n  enum CostState { Valid, Invalid };\n\nprivate:\n  CostType Value = 0;\n  CostState State = Valid;\n\n  void propagateState(const InstructionCost &RHS) {\n    if (RHS.State == Invalid)\n      State = Invalid;\n  }\n\npublic:\n  // A default constructed InstructionCost is a valid zero cost\n  InstructionCost() = default;\n\n  InstructionCost(CostState) = delete;\n  InstructionCost(CostType Val) : Value(Val), State(Valid) {}\n\n  static InstructionCost getInvalid(CostType Val = 0) {\n    InstructionCost Tmp(Val);\n    Tmp.setInvalid();\n    return Tmp;\n  }\n\n  bool isValid() const { return State == Valid; }\n  void setValid() { State = Valid; }\n  void setInvalid() { State = Invalid; }\n  CostState getState() const { return State; }\n\n  /// This function is intended to be used as sparingly as possible, since the\n  /// class provides the full range of operator support required for arithmetic\n  /// and comparisons.\n  Optional<CostType> getValue() const {\n    if (isValid())\n      return Value;\n    return None;\n  }\n\n  /// For all of the arithmetic operators provided here any invalid state is\n  /// perpetuated and cannot be removed. Once a cost becomes invalid it stays\n  /// invalid, and it also inherits any invalid state from the RHS. Regardless\n  /// of the state, arithmetic and comparisons work on the actual values in the\n  /// same way as they would on a basic type, such as integer.\n\n  InstructionCost &operator+=(const InstructionCost &RHS) {\n    propagateState(RHS);\n    Value += RHS.Value;\n    return *this;\n  }\n\n  InstructionCost &operator+=(const CostType RHS) {\n    InstructionCost RHS2(RHS);\n    *this += RHS2;\n    return *this;\n  }\n\n  InstructionCost &operator-=(const InstructionCost &RHS) {\n    propagateState(RHS);\n    Value -= RHS.Value;\n    return *this;\n  }\n\n  InstructionCost &operator-=(const CostType RHS) {\n    InstructionCost RHS2(RHS);\n    *this -= RHS2;\n    return *this;\n  }\n\n  InstructionCost &operator*=(const InstructionCost &RHS) {\n    propagateState(RHS);\n    Value *= RHS.Value;\n    return *this;\n  }\n\n  InstructionCost &operator*=(const CostType RHS) {\n    InstructionCost RHS2(RHS);\n    *this *= RHS2;\n    return *this;\n  }\n\n  InstructionCost &operator/=(const InstructionCost &RHS) {\n    propagateState(RHS);\n    Value /= RHS.Value;\n    return *this;\n  }\n\n  InstructionCost &operator/=(const CostType RHS) {\n    InstructionCost RHS2(RHS);\n    *this /= RHS2;\n    return *this;\n  }\n\n  InstructionCost &operator++() {\n    *this += 1;\n    return *this;\n  }\n\n  InstructionCost operator++(int) {\n    InstructionCost Copy = *this;\n    ++*this;\n    return Copy;\n  }\n\n  InstructionCost &operator--() {\n    *this -= 1;\n    return *this;\n  }\n\n  InstructionCost operator--(int) {\n    InstructionCost Copy = *this;\n    --*this;\n    return Copy;\n  }\n\n  /// For the comparison operators we have chosen to use lexicographical\n  /// ordering where valid costs are always considered to be less than invalid\n  /// costs. This avoids having to add asserts to the comparison operators that\n  /// the states are valid and users can test for validity of the cost\n  /// explicitly.\n  bool operator<(const InstructionCost &RHS) const {\n    if (State != RHS.State)\n      return State < RHS.State;\n    return Value < RHS.Value;\n  }\n\n  // Implement in terms of operator< to ensure that the two comparisons stay in\n  // sync\n  bool operator==(const InstructionCost &RHS) const {\n    return !(*this < RHS) && !(RHS < *this);\n  }\n\n  bool operator!=(const InstructionCost &RHS) const { return !(*this == RHS); }\n\n  bool operator==(const CostType RHS) const {\n    InstructionCost RHS2(RHS);\n    return *this == RHS2;\n  }\n\n  bool operator!=(const CostType RHS) const { return !(*this == RHS); }\n\n  bool operator>(const InstructionCost &RHS) const { return RHS < *this; }\n\n  bool operator<=(const InstructionCost &RHS) const { return !(RHS < *this); }\n\n  bool operator>=(const InstructionCost &RHS) const { return !(*this < RHS); }\n\n  bool operator<(const CostType RHS) const {\n    InstructionCost RHS2(RHS);\n    return *this < RHS2;\n  }\n\n  bool operator>(const CostType RHS) const {\n    InstructionCost RHS2(RHS);\n    return *this > RHS2;\n  }\n\n  bool operator<=(const CostType RHS) const {\n    InstructionCost RHS2(RHS);\n    return *this <= RHS2;\n  }\n\n  bool operator>=(const CostType RHS) const {\n    InstructionCost RHS2(RHS);\n    return *this >= RHS2;\n  }\n\n  void print(raw_ostream &OS) const;\n};\n\ninline InstructionCost operator+(const InstructionCost &LHS,\n                                 const InstructionCost &RHS) {\n  InstructionCost LHS2(LHS);\n  LHS2 += RHS;\n  return LHS2;\n}\n\ninline InstructionCost operator-(const InstructionCost &LHS,\n                                 const InstructionCost &RHS) {\n  InstructionCost LHS2(LHS);\n  LHS2 -= RHS;\n  return LHS2;\n}\n\ninline InstructionCost operator*(const InstructionCost &LHS,\n                                 const InstructionCost &RHS) {\n  InstructionCost LHS2(LHS);\n  LHS2 *= RHS;\n  return LHS2;\n}\n\ninline InstructionCost operator/(const InstructionCost &LHS,\n                                 const InstructionCost &RHS) {\n  InstructionCost LHS2(LHS);\n  LHS2 /= RHS;\n  return LHS2;\n}\n\ninline raw_ostream &operator<<(raw_ostream &OS, const InstructionCost &V) {\n  V.print(OS);\n  return OS;\n}\n\n} // namespace llvm\n\n#endif\n"}, "60": {"id": 60, "path": "/home/vsts/work/1/llvm-project/polly/include/polly/DependenceInfo.h", "content": "//===--- polly/DependenceInfo.h - Polyhedral dependency analysis *- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// Calculate the data dependency relations for a Scop using ISL.\n//\n// The integer set library (ISL) from Sven has an integrated dependency analysis\n// to calculate data dependences. This pass takes advantage of this and\n// calculates those dependences of a Scop.\n//\n// The dependences in this pass are exact in terms that for a specific read\n// statement instance only the last write statement instance is returned. In\n// case of may-writes, a set of possible write instances is returned. This\n// analysis will never produce redundant dependences.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef POLLY_DEPENDENCE_INFO_H\n#define POLLY_DEPENDENCE_INFO_H\n\n#include \"polly/ScopPass.h\"\n#include \"isl/ctx.h\"\n#include \"isl/isl-noexceptions.h\"\n\nnamespace polly {\n\n/// The accumulated dependence information for a SCoP.\n///\n/// The Dependences struct holds all dependence information we collect and\n/// compute for one SCoP. It also offers an interface that allows users to\n/// query only specific parts.\nstruct Dependences {\n  // Granularities of the current dependence analysis\n  enum AnalysisLevel {\n    AL_Statement = 0,\n    // Distinguish accessed memory references in the same statement\n    AL_Reference,\n    // Distinguish memory access instances in the same statement\n    AL_Access,\n\n    NumAnalysisLevels\n  };\n\n  /// Map type for reduction dependences.\n  using ReductionDependencesMapTy = DenseMap<MemoryAccess *, isl_map *>;\n\n  /// Map type to associate statements with schedules.\n  using StatementToIslMapTy = DenseMap<ScopStmt *, isl::map>;\n\n  /// The type of the dependences.\n  ///\n  /// Reduction dependences are separated from RAW/WAW/WAR dependences because\n  /// we can ignore them during the scheduling. That's because the order\n  /// in which the reduction statements are executed does not matter. However,\n  /// if they are executed in parallel we need to take additional measures\n  /// (e.g, privatization) to ensure a correct result. The (reverse) transitive\n  /// closure of the reduction dependences are used to check for parallel\n  /// executed reduction statements during code generation. These dependences\n  /// connect all instances of a reduction with each other, they are therefore\n  /// cyclic and possibly \"reversed\".\n  enum Type {\n    // Write after read\n    TYPE_WAR = 1 << 0,\n\n    // Read after write\n    TYPE_RAW = 1 << 1,\n\n    // Write after write\n    TYPE_WAW = 1 << 2,\n\n    // Reduction dependences\n    TYPE_RED = 1 << 3,\n\n    // Transitive closure of the reduction dependences (& the reverse)\n    TYPE_TC_RED = 1 << 4,\n  };\n\n  const std::shared_ptr<isl_ctx> &getSharedIslCtx() const { return IslCtx; }\n\n  /// Get the dependences of type @p Kinds.\n  ///\n  /// @param Kinds This integer defines the different kinds of dependences\n  ///              that will be returned. To return more than one kind, the\n  ///              different kinds are 'ored' together.\n  isl::union_map getDependences(int Kinds) const;\n\n  /// Report if valid dependences are available.\n  bool hasValidDependences() const;\n\n  /// Return the reduction dependences caused by @p MA.\n  ///\n  /// @return The reduction dependences caused by @p MA or nullptr if none.\n  __isl_give isl_map *getReductionDependences(MemoryAccess *MA) const;\n\n  /// Return all reduction dependences.\n  const ReductionDependencesMapTy &getReductionDependences() const {\n    return ReductionDependences;\n  }\n\n  /// Check if a partial schedule is parallel wrt to @p Deps.\n  ///\n  /// @param Schedule       The subset of the schedule space that we want to\n  ///                       check.\n  /// @param Deps           The dependences @p Schedule needs to respect.\n  /// @param MinDistancePtr If not nullptr, the minimal dependence distance will\n  ///                       be returned at the address of that pointer\n  ///\n  /// @return Returns true, if executing parallel the outermost dimension of\n  ///         @p Schedule is valid according to the dependences @p Deps.\n  bool isParallel(__isl_keep isl_union_map *Schedule,\n                  __isl_take isl_union_map *Deps,\n                  __isl_give isl_pw_aff **MinDistancePtr = nullptr) const;\n\n  /// Check if a new schedule is valid.\n  ///\n  /// @param S             The current SCoP.\n  /// @param NewSchedules  The new schedules\n  ///\n  /// @return True if the new schedule is valid, false if it reverses\n  ///         dependences.\n  bool isValidSchedule(Scop &S, const StatementToIslMapTy &NewSchedules) const;\n\n  /// Print the stored dependence information.\n  void print(llvm::raw_ostream &OS) const;\n\n  /// Dump the dependence information stored to the dbgs stream.\n  void dump() const;\n\n  /// Return the granularity of this dependence analysis.\n  AnalysisLevel getDependenceLevel() { return Level; }\n\n  /// Allow the DependenceInfo access to private members and methods.\n  ///\n  /// To restrict access to the internal state, only the DependenceInfo class\n  /// is able to call or modify a Dependences struct.\n  friend struct DependenceAnalysis;\n  friend struct DependenceInfoPrinterPass;\n  friend class DependenceInfo;\n  friend class DependenceInfoWrapperPass;\n\n  /// Destructor that will free internal objects.\n  ~Dependences() { releaseMemory(); }\n\nprivate:\n  /// Create an empty dependences struct.\n  explicit Dependences(const std::shared_ptr<isl_ctx> &IslCtx,\n                       AnalysisLevel Level)\n      : RAW(nullptr), WAR(nullptr), WAW(nullptr), RED(nullptr), TC_RED(nullptr),\n        IslCtx(IslCtx), Level(Level) {}\n\n  /// Calculate and add at the privatization dependences.\n  void addPrivatizationDependences();\n\n  /// Calculate the dependences for a certain SCoP @p S.\n  void calculateDependences(Scop &S);\n\n  /// Set the reduction dependences for @p MA to @p Deps.\n  void setReductionDependences(MemoryAccess *MA, __isl_take isl_map *Deps);\n\n  /// Free the objects associated with this Dependences struct.\n  ///\n  /// The Dependences struct will again be \"empty\" afterwards.\n  void releaseMemory();\n\n  /// The different basic kinds of dependences we calculate.\n  isl_union_map *RAW;\n  isl_union_map *WAR;\n  isl_union_map *WAW;\n\n  /// The special reduction dependences.\n  isl_union_map *RED;\n\n  /// The (reverse) transitive closure of reduction dependences.\n  isl_union_map *TC_RED;\n\n  /// Mapping from memory accesses to their reduction dependences.\n  ReductionDependencesMapTy ReductionDependences;\n\n  /// Isl context from the SCoP.\n  std::shared_ptr<isl_ctx> IslCtx;\n\n  /// Granularity of this dependence analysis.\n  const AnalysisLevel Level;\n};\n\nstruct DependenceAnalysis : public AnalysisInfoMixin<DependenceAnalysis> {\n  static AnalysisKey Key;\n  struct Result {\n    Scop &S;\n    std::unique_ptr<Dependences> D[Dependences::NumAnalysisLevels];\n\n    /// Return the dependence information for the current SCoP.\n    ///\n    /// @param Level The granularity of dependence analysis result.\n    ///\n    /// @return The dependence analysis result\n    ///\n    const Dependences &getDependences(Dependences::AnalysisLevel Level);\n\n    /// Recompute dependences from schedule and memory accesses.\n    const Dependences &recomputeDependences(Dependences::AnalysisLevel Level);\n  };\n  Result run(Scop &S, ScopAnalysisManager &SAM,\n             ScopStandardAnalysisResults &SAR);\n};\n\nstruct DependenceInfoPrinterPass\n    : public PassInfoMixin<DependenceInfoPrinterPass> {\n  DependenceInfoPrinterPass(raw_ostream &OS) : OS(OS) {}\n\n  PreservedAnalyses run(Scop &S, ScopAnalysisManager &,\n                        ScopStandardAnalysisResults &, SPMUpdater &);\n\n  raw_ostream &OS;\n};\n\nclass DependenceInfo : public ScopPass {\npublic:\n  static char ID;\n\n  /// Construct a new DependenceInfo pass.\n  DependenceInfo() : ScopPass(ID) {}\n\n  /// Return the dependence information for the current SCoP.\n  ///\n  /// @param Level The granularity of dependence analysis result.\n  ///\n  /// @return The dependence analysis result\n  ///\n  const Dependences &getDependences(Dependences::AnalysisLevel Level);\n\n  /// Recompute dependences from schedule and memory accesses.\n  const Dependences &recomputeDependences(Dependences::AnalysisLevel Level);\n\n  /// Compute the dependence information for the SCoP @p S.\n  bool runOnScop(Scop &S) override;\n\n  /// Print the dependences for the given SCoP to @p OS.\n  void printScop(raw_ostream &OS, Scop &) const override;\n\n  /// Release the internal memory.\n  void releaseMemory() override {\n    for (auto &d : D)\n      d.reset();\n  }\n\n  /// Register all analyses and transformation required.\n  void getAnalysisUsage(AnalysisUsage &AU) const override;\n\nprivate:\n  Scop *S;\n\n  /// Dependences struct for the current SCoP.\n  std::unique_ptr<Dependences> D[Dependences::NumAnalysisLevels];\n};\n\n/// Construct a new DependenceInfoWrapper pass.\nclass DependenceInfoWrapperPass : public FunctionPass {\npublic:\n  static char ID;\n\n  /// Construct a new DependenceInfoWrapper pass.\n  DependenceInfoWrapperPass() : FunctionPass(ID) {}\n\n  /// Return the dependence information for the given SCoP.\n  ///\n  /// @param S     SCoP object.\n  /// @param Level The granularity of dependence analysis result.\n  ///\n  /// @return The dependence analysis result\n  ///\n  const Dependences &getDependences(Scop *S, Dependences::AnalysisLevel Level);\n\n  /// Recompute dependences from schedule and memory accesses.\n  const Dependences &recomputeDependences(Scop *S,\n                                          Dependences::AnalysisLevel Level);\n\n  /// Compute the dependence information on-the-fly for the function.\n  bool runOnFunction(Function &F) override;\n\n  /// Print the dependences for the current function to @p OS.\n  void print(raw_ostream &OS, const Module *M = nullptr) const override;\n\n  /// Release the internal memory.\n  void releaseMemory() override { ScopToDepsMap.clear(); }\n\n  /// Register all analyses and transformation required.\n  void getAnalysisUsage(AnalysisUsage &AU) const override;\n\nprivate:\n  using ScopToDepsMapTy = DenseMap<Scop *, std::unique_ptr<Dependences>>;\n\n  /// Scop to Dependence map for the current function.\n  ScopToDepsMapTy ScopToDepsMap;\n};\n} // namespace polly\n\nnamespace llvm {\nvoid initializeDependenceInfoPass(llvm::PassRegistry &);\nvoid initializeDependenceInfoWrapperPassPass(llvm::PassRegistry &);\n} // namespace llvm\n\n#endif\n"}, "61": {"id": 61, "path": "/home/vsts/work/1/llvm-project/polly/include/polly/ScopDetectionDiagnostic.h", "content": "//===- ScopDetectionDiagnostic.h - Diagnostic for ScopDetection -*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// Small set of diagnostic helper classes to encapsulate any errors occurred\n// during the detection of Scops.\n//\n// The ScopDetection defines a set of error classes (via Statistic variables)\n// that groups a number of individual errors into a group, e.g. non-affinity\n// related errors.\n// On error we generate an object that carries enough additional information\n// to diagnose the error and generate a helpful error message.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef POLLY_SCOPDETECTIONDIAGNOSTIC_H\n#define POLLY_SCOPDETECTIONDIAGNOSTIC_H\n\n#include \"llvm/Analysis/LoopInfo.h\"\n#include \"llvm/IR/DebugLoc.h\"\n#include \"llvm/IR/Instruction.h\"\n#include <cstddef>\n\nnamespace llvm {\nclass AliasSet;\nclass BasicBlock;\nclass OptimizationRemarkEmitter;\nclass Region;\nclass SCEV;\n} // namespace llvm\n\nnamespace polly {\nusing llvm::AliasSet;\nusing llvm::BasicBlock;\nusing llvm::DebugLoc;\nusing llvm::Instruction;\nusing llvm::Loop;\nusing llvm::OptimizationRemarkEmitter;\nusing llvm::raw_ostream;\nusing llvm::Region;\nusing llvm::SCEV;\nusing llvm::SmallVector;\nusing llvm::Value;\n\n/// Type to hold region delimiters (entry & exit block).\nusing BBPair = std::pair<BasicBlock *, BasicBlock *>;\n\n/// Return the region delimiters (entry & exit block) of @p R.\nBBPair getBBPairForRegion(const Region *R);\n\n/// Set the begin and end source location for the region limited by @p P.\nvoid getDebugLocations(const BBPair &P, DebugLoc &Begin, DebugLoc &End);\n\nclass RejectLog;\n\n/// Emit optimization remarks about the rejected regions to the user.\n///\n/// This emits the content of the reject log as optimization remarks.\n/// Remember to at least track failures (-polly-detect-track-failures).\n/// @param P The region delimiters (entry & exit) we emit remarks for.\n/// @param Log The error log containing all messages being emitted as remark.\nvoid emitRejectionRemarks(const BBPair &P, const RejectLog &Log,\n                          OptimizationRemarkEmitter &ORE);\n\n// Discriminator for LLVM-style RTTI (dyn_cast<> et al.)\nenum class RejectReasonKind {\n  // CFG Category\n  CFG,\n  InvalidTerminator,\n  IrreducibleRegion,\n  UnreachableInExit,\n  LastCFG,\n\n  // Non-Affinity\n  AffFunc,\n  UndefCond,\n  InvalidCond,\n  UndefOperand,\n  NonAffBranch,\n  NoBasePtr,\n  UndefBasePtr,\n  VariantBasePtr,\n  NonAffineAccess,\n  DifferentElementSize,\n  LastAffFunc,\n\n  LoopBound,\n  LoopHasNoExit,\n  LoopHasMultipleExits,\n  LoopOnlySomeLatches,\n\n  FuncCall,\n  NonSimpleMemoryAccess,\n\n  Alias,\n\n  // Other\n  Other,\n  IntToPtr,\n  Alloca,\n  UnknownInst,\n  Entry,\n  Unprofitable,\n  LastOther\n};\n\n//===----------------------------------------------------------------------===//\n/// Base class of all reject reasons found during Scop detection.\n///\n/// Subclasses of RejectReason should provide means to capture enough\n/// diagnostic information to help clients figure out what and where something\n/// went wrong in the Scop detection.\nclass RejectReason {\nprivate:\n  const RejectReasonKind Kind;\n\nprotected:\n  static const DebugLoc Unknown;\n\npublic:\n  RejectReason(RejectReasonKind K);\n\n  virtual ~RejectReason() = default;\n\n  RejectReasonKind getKind() const { return Kind; }\n\n  /// Generate the remark name to identify this remark.\n  ///\n  /// @return A short string that identifies the error.\n  virtual std::string getRemarkName() const = 0;\n\n  /// Get the Basic Block containing this remark.\n  ///\n  /// @return The Basic Block containing this remark.\n  virtual const Value *getRemarkBB() const = 0;\n\n  /// Generate a reasonable diagnostic message describing this error.\n  ///\n  /// @return A debug message representing this error.\n  virtual std::string getMessage() const = 0;\n\n  /// Generate a message for the end-user describing this error.\n  ///\n  /// The message provided has to be suitable for the end-user. So it should\n  /// not reference any LLVM internal data structures or terminology.\n  /// Ideally, the message helps the end-user to increase the size of the\n  /// regions amenable to Polly.\n  ///\n  /// @return A short message representing this error.\n  virtual std::string getEndUserMessage() const { return \"Unspecified error.\"; }\n\n  /// Get the source location of this error.\n  ///\n  /// @return The debug location for this error.\n  virtual const DebugLoc &getDebugLoc() const;\n};\n\nusing RejectReasonPtr = std::shared_ptr<RejectReason>;\n\n/// Stores all errors that occurred during the detection.\nclass RejectLog {\n  Region *R;\n  SmallVector<RejectReasonPtr, 1> ErrorReports;\n\npublic:\n  explicit RejectLog(Region *R) : R(R) {}\n\n  using iterator = SmallVector<RejectReasonPtr, 1>::const_iterator;\n\n  iterator begin() const { return ErrorReports.begin(); }\n  iterator end() const { return ErrorReports.end(); }\n  size_t size() const { return ErrorReports.size(); }\n\n  /// Returns true, if we store at least one error.\n  ///\n  /// @return true, if we store at least one error.\n  bool hasErrors() const { return size() > 0; }\n\n  void print(raw_ostream &OS, int level = 0) const;\n\n  const Region *region() const { return R; }\n  void report(RejectReasonPtr Reject) { ErrorReports.push_back(Reject); }\n};\n\n//===----------------------------------------------------------------------===//\n/// Base class for CFG related reject reasons.\n///\n/// Scop candidates that violate structural restrictions can be grouped under\n/// this reject reason class.\nclass ReportCFG : public RejectReason {\npublic:\n  ReportCFG(const RejectReasonKind K);\n\n  /// @name LLVM-RTTI interface\n  //@{\n  static bool classof(const RejectReason *RR);\n  //@}\n};\n\n//===----------------------------------------------------------------------===//\n/// Captures bad terminator within a Scop candidate.\nclass ReportInvalidTerminator : public ReportCFG {\n  BasicBlock *BB;\n\npublic:\n  ReportInvalidTerminator(BasicBlock *BB)\n      : ReportCFG(RejectReasonKind::InvalidTerminator), BB(BB) {}\n\n  /// @name LLVM-RTTI interface\n  //@{\n  static bool classof(const RejectReason *RR);\n  //@}\n\n  /// @name RejectReason interface\n  //@{\n  std::string getRemarkName() const override;\n  const Value *getRemarkBB() const override;\n  std::string getMessage() const override;\n  const DebugLoc &getDebugLoc() const override;\n  //@}\n};\n\n//===----------------------------------------------------------------------===//\n/// Captures irreducible regions in CFG.\nclass ReportIrreducibleRegion : public ReportCFG {\n  Region *R;\n  DebugLoc DbgLoc;\n\npublic:\n  ReportIrreducibleRegion(Region *R, DebugLoc DbgLoc)\n      : ReportCFG(RejectReasonKind::IrreducibleRegion), R(R), DbgLoc(DbgLoc) {}\n\n  /// @name LLVM-RTTI interface\n  //@{\n  static bool classof(const RejectReason *RR);\n  //@}\n\n  /// @name RejectReason interface\n  //@{\n  std::string getRemarkName() const override;\n  const Value *getRemarkBB() const override;\n  std::string getMessage() const override;\n  std::string getEndUserMessage() const override;\n  const DebugLoc &getDebugLoc() const override;\n  //@}\n};\n\n//===----------------------------------------------------------------------===//\n/// Captures regions with an unreachable in the exit block.\nclass ReportUnreachableInExit : public ReportCFG {\n  BasicBlock *BB;\n  DebugLoc DbgLoc;\n\npublic:\n  ReportUnreachableInExit(BasicBlock *BB, DebugLoc DbgLoc)\n      : ReportCFG(RejectReasonKind::UnreachableInExit), BB(BB), DbgLoc(DbgLoc) {\n  }\n\n  /// @name LLVM-RTTI interface\n  //@{\n  static bool classof(const RejectReason *RR);\n  //@}\n\n  /// @name RejectReason interface\n  //@{\n  std::string getRemarkName() const override;\n  const Value *getRemarkBB() const override;\n  std::string getMessage() const override;\n  std::string getEndUserMessage() const override;\n  const DebugLoc &getDebugLoc() const override;\n  //@}\n};\n\n//===----------------------------------------------------------------------===//\n/// Base class for non-affine reject reasons.\n///\n/// Scop candidates that violate restrictions to affinity are reported under\n/// this class.\nclass ReportAffFunc : public RejectReason {\nprotected:\n  // The instruction that caused non-affinity to occur.\n  const Instruction *Inst;\n\npublic:\n  ReportAffFunc(const RejectReasonKind K, const Instruction *Inst);\n\n  /// @name LLVM-RTTI interface\n  //@{\n  static bool classof(const RejectReason *RR);\n  //@}\n\n  /// @name RejectReason interface\n  //@{\n  const DebugLoc &getDebugLoc() const override { return Inst->getDebugLoc(); }\n  //@}\n};\n\n//===----------------------------------------------------------------------===//\n/// Captures a condition that is based on an 'undef' value.\nclass ReportUndefCond : public ReportAffFunc {\n  // The BasicBlock we found the broken condition in.\n  BasicBlock *BB;\n\npublic:\n  ReportUndefCond(const Instruction *Inst, BasicBlock *BB)\n      : ReportAffFunc(RejectReasonKind::UndefCond, Inst), BB(BB) {}\n\n  /// @name LLVM-RTTI interface\n  //@{\n  static bool classof(const RejectReason *RR);\n  //@}\n\n  /// @name RejectReason interface\n  //@{\n  std::string getRemarkName() const override;\n  const Value *getRemarkBB() const override;\n  std::string getMessage() const override;\n  //@}\n};\n\n//===----------------------------------------------------------------------===//\n/// Captures an invalid condition\n///\n/// Conditions have to be either constants or icmp instructions.\nclass ReportInvalidCond : public ReportAffFunc {\n  // The BasicBlock we found the broken condition in.\n  BasicBlock *BB;\n\npublic:\n  ReportInvalidCond(const Instruction *Inst, BasicBlock *BB)\n      : ReportAffFunc(RejectReasonKind::InvalidCond, Inst), BB(BB) {}\n\n  /// @name LLVM-RTTI interface\n  //@{\n  static bool classof(const RejectReason *RR);\n  //@}\n\n  /// @name RejectReason interface\n  //@{\n  std::string getRemarkName() const override;\n  const Value *getRemarkBB() const override;\n  std::string getMessage() const override;\n  //@}\n};\n\n//===----------------------------------------------------------------------===//\n/// Captures an undefined operand.\nclass ReportUndefOperand : public ReportAffFunc {\n  // The BasicBlock we found the undefined operand in.\n  BasicBlock *BB;\n\npublic:\n  ReportUndefOperand(BasicBlock *BB, const Instruction *Inst)\n      : ReportAffFunc(RejectReasonKind::UndefOperand, Inst), BB(BB) {}\n\n  /// @name LLVM-RTTI interface\n  //@{\n  static bool classof(const RejectReason *RR);\n  //@}\n\n  /// @name RejectReason interface\n  //@{\n  std::string getRemarkName() const override;\n  const Value *getRemarkBB() const override;\n  std::string getMessage() const override;\n  //@}\n};\n\n//===----------------------------------------------------------------------===//\n/// Captures a non-affine branch.\nclass ReportNonAffBranch : public ReportAffFunc {\n  // The BasicBlock we found the non-affine branch in.\n  BasicBlock *BB;\n\n  /// LHS & RHS of the failed condition.\n  //@{\n  const SCEV *LHS;\n  const SCEV *RHS;\n  //@}\n\npublic:\n  ReportNonAffBranch(BasicBlock *BB, const SCEV *LHS, const SCEV *RHS,\n                     const Instruction *Inst)\n      : ReportAffFunc(RejectReasonKind::NonAffBranch, Inst), BB(BB), LHS(LHS),\n        RHS(RHS) {}\n\n  const SCEV *lhs() { return LHS; }\n  const SCEV *rhs() { return RHS; }\n\n  /// @name LLVM-RTTI interface\n  //@{\n  static bool classof(const RejectReason *RR);\n  //@}\n\n  /// @name RejectReason interface\n  //@{\n  std::string getRemarkName() const override;\n  const Value *getRemarkBB() const override;\n  std::string getMessage() const override;\n  //@}\n};\n\n//===----------------------------------------------------------------------===//\n/// Captures a missing base pointer.\nclass ReportNoBasePtr : public ReportAffFunc {\npublic:\n  ReportNoBasePtr(const Instruction *Inst)\n      : ReportAffFunc(RejectReasonKind::NoBasePtr, Inst) {}\n\n  /// @name LLVM-RTTI interface\n  //@{\n  static bool classof(const RejectReason *RR);\n  //@}\n\n  /// @name RejectReason interface\n  //@{\n  std::string getRemarkName() const override;\n  const Value *getRemarkBB() const override;\n  std::string getMessage() const override;\n  //@}\n};\n\n//===----------------------------------------------------------------------===//\n/// Captures an undefined base pointer.\nclass ReportUndefBasePtr : public ReportAffFunc {\npublic:\n  ReportUndefBasePtr(const Instruction *Inst)\n      : ReportAffFunc(RejectReasonKind::UndefBasePtr, Inst) {}\n\n  /// @name LLVM-RTTI interface\n  //@{\n  static bool classof(const RejectReason *RR);\n  //@}\n\n  /// @name RejectReason interface\n  //@{\n  std::string getRemarkName() const override;\n  const Value *getRemarkBB() const override;\n  std::string getMessage() const override;\n  //@}\n};\n\n//===----------------------------------------------------------------------===//\n/// Captures a base pointer that is not invariant in the region.\nclass ReportVariantBasePtr : public ReportAffFunc {\n  // The variant base pointer.\n  Value *BaseValue;\n\npublic:\n  ReportVariantBasePtr(Value *BaseValue, const Instruction *Inst)\n      : ReportAffFunc(RejectReasonKind::VariantBasePtr, Inst),\n        BaseValue(BaseValue) {}\n\n  /// @name LLVM-RTTI interface\n  //@{\n  static bool classof(const RejectReason *RR);\n  //@}\n\n  /// @name RejectReason interface\n  //@{\n  std::string getRemarkName() const override;\n  const Value *getRemarkBB() const override;\n  std::string getMessage() const override;\n  std::string getEndUserMessage() const override;\n  //@}\n};\n\n//===----------------------------------------------------------------------===//\n/// Captures a non-affine access function.\nclass ReportNonAffineAccess : public ReportAffFunc {\n  // The non-affine access function.\n  const SCEV *AccessFunction;\n\n  // The base pointer of the memory access.\n  const Value *BaseValue;\n\npublic:\n  ReportNonAffineAccess(const SCEV *AccessFunction, const Instruction *Inst,\n                        const Value *V)\n      : ReportAffFunc(RejectReasonKind::NonAffineAccess, Inst),\n        AccessFunction(AccessFunction), BaseValue(V) {}\n\n  const SCEV *get() { return AccessFunction; }\n\n  /// @name LLVM-RTTI interface\n  //@{\n  static bool classof(const RejectReason *RR);\n  //@}\n\n  /// @name RejectReason interface\n  //@{\n  std::string getRemarkName() const override;\n  const Value *getRemarkBB() const override;\n  std::string getMessage() const override;\n  std::string getEndUserMessage() const override;\n  //@}\n};\n\n//===----------------------------------------------------------------------===//\n/// Report array accesses with differing element size.\nclass ReportDifferentArrayElementSize : public ReportAffFunc {\n  // The base pointer of the memory access.\n  const Value *BaseValue;\n\npublic:\n  ReportDifferentArrayElementSize(const Instruction *Inst, const Value *V)\n      : ReportAffFunc(RejectReasonKind::DifferentElementSize, Inst),\n        BaseValue(V) {}\n\n  /// @name LLVM-RTTI interface\n  //@{\n  static bool classof(const RejectReason *RR);\n  //@}\n\n  /// @name RejectReason interface\n  //@{\n  std::string getRemarkName() const override;\n  const Value *getRemarkBB() const override;\n  std::string getMessage() const override;\n  std::string getEndUserMessage() const override;\n  //@}\n};\n\n//===----------------------------------------------------------------------===//\n/// Captures errors with non affine loop bounds.\nclass ReportLoopBound : public RejectReason {\n  // The offending loop.\n  Loop *L;\n\n  // The non-affine loop bound.\n  const SCEV *LoopCount;\n\n  // A copy of the offending loop's debug location.\n  const DebugLoc Loc;\n\npublic:\n  ReportLoopBound(Loop *L, const SCEV *LoopCount);\n\n  const SCEV *loopCount() { return LoopCount; }\n\n  /// @name LLVM-RTTI interface\n  //@{\n  static bool classof(const RejectReason *RR);\n  //@}\n\n  /// @name RejectReason interface\n  //@{\n  std::string getRemarkName() const override;\n  const Value *getRemarkBB() const override;\n  std::string getMessage() const override;\n  const DebugLoc &getDebugLoc() const override;\n  std::string getEndUserMessage() const override;\n  //@}\n};\n\n//===----------------------------------------------------------------------===//\n/// Captures errors when loop has no exit.\nclass ReportLoopHasNoExit : public RejectReason {\n  /// The loop that has no exit.\n  Loop *L;\n\n  const DebugLoc Loc;\n\npublic:\n  ReportLoopHasNoExit(Loop *L)\n      : RejectReason(RejectReasonKind::LoopHasNoExit), L(L),\n        Loc(L->getStartLoc()) {}\n\n  /// @name LLVM-RTTI interface\n  //@{\n  static bool classof(const RejectReason *RR);\n  //@}\n\n  /// @name RejectReason interface\n  //@{\n  std::string getRemarkName() const override;\n  const Value *getRemarkBB() const override;\n  std::string getMessage() const override;\n  const DebugLoc &getDebugLoc() const override;\n  std::string getEndUserMessage() const override;\n  //@}\n};\n\n//===----------------------------------------------------------------------===//\n/// Captures errors when a loop has multiple exists.\nclass ReportLoopHasMultipleExits : public RejectReason {\n  /// The loop that has multiple exits.\n  Loop *L;\n\n  const DebugLoc Loc;\n\npublic:\n  ReportLoopHasMultipleExits(Loop *L)\n      : RejectReason(RejectReasonKind::LoopHasMultipleExits), L(L),\n        Loc(L->getStartLoc()) {}\n\n  /// @name LLVM-RTTI interface\n  //@{\n  static bool classof(const RejectReason *RR);\n  //@}\n\n  /// @name RejectReason interface\n  //@{\n  std::string getRemarkName() const override;\n  const Value *getRemarkBB() const override;\n  std::string getMessage() const override;\n  const DebugLoc &getDebugLoc() const override;\n  std::string getEndUserMessage() const override;\n  //@}\n};\n\n//===----------------------------------------------------------------------===//\n/// Captures errors when not all loop latches are part of the scop.\nclass ReportLoopOnlySomeLatches : public RejectReason {\n  /// The loop for which not all loop latches are part of the scop.\n  Loop *L;\n\n  const DebugLoc Loc;\n\npublic:\n  ReportLoopOnlySomeLatches(Loop *L)\n      : RejectReason(RejectReasonKind::LoopOnlySomeLatches), L(L),\n        Loc(L->getStartLoc()) {}\n\n  /// @name LLVM-RTTI interface\n  //@{\n  static bool classof(const RejectReason *RR);\n  //@}\n\n  /// @name RejectReason interface\n  //@{\n  std::string getRemarkName() const override;\n  const Value *getRemarkBB() const override;\n  std::string getMessage() const override;\n  const DebugLoc &getDebugLoc() const override;\n  std::string getEndUserMessage() const override;\n  //@}\n};\n\n//===----------------------------------------------------------------------===//\n/// Captures errors with non-side-effect-known function calls.\nclass ReportFuncCall : public RejectReason {\n  // The offending call instruction.\n  Instruction *Inst;\n\npublic:\n  ReportFuncCall(Instruction *Inst);\n\n  /// @name LLVM-RTTI interface\n  //@{\n  static bool classof(const RejectReason *RR);\n  //@}\n\n  /// @name RejectReason interface\n  //@{\n  std::string getRemarkName() const override;\n  const Value *getRemarkBB() const override;\n  std::string getMessage() const override;\n  const DebugLoc &getDebugLoc() const override;\n  std::string getEndUserMessage() const override;\n  //@}\n};\n\n//===----------------------------------------------------------------------===//\n/// Captures errors with aliasing.\nclass ReportAlias : public RejectReason {\npublic:\n  using PointerSnapshotTy = std::vector<const Value *>;\n\nprivate:\n  /// Format an invalid alias set.\n  ///\n  //  @param Prefix A prefix string to put before the list of aliasing pointers.\n  //  @param Suffix A suffix string to put after the list of aliasing pointers.\n  std::string formatInvalidAlias(std::string Prefix = \"\",\n                                 std::string Suffix = \"\") const;\n\n  Instruction *Inst;\n\n  // A snapshot of the llvm values that took part in the aliasing error.\n  mutable PointerSnapshotTy Pointers;\n\npublic:\n  ReportAlias(Instruction *Inst, AliasSet &AS);\n\n  const PointerSnapshotTy &getPointers() const { return Pointers; }\n\n  /// @name LLVM-RTTI interface\n  //@{\n  static bool classof(const RejectReason *RR);\n  //@}\n\n  /// @name RejectReason interface\n  //@{\n  std::string getRemarkName() const override;\n  const Value *getRemarkBB() const override;\n  std::string getMessage() const override;\n  const DebugLoc &getDebugLoc() const override;\n  std::string getEndUserMessage() const override;\n  //@}\n};\n\n//===----------------------------------------------------------------------===//\n/// Base class for otherwise ungrouped reject reasons.\nclass ReportOther : public RejectReason {\npublic:\n  ReportOther(const RejectReasonKind K);\n\n  /// @name LLVM-RTTI interface\n  //@{\n  static bool classof(const RejectReason *RR);\n  //@}\n\n  /// @name RejectReason interface\n  //@{\n  std::string getRemarkName() const override;\n  std::string getMessage() const override;\n  //@}\n};\n\n//===----------------------------------------------------------------------===//\n/// Captures errors with bad IntToPtr instructions.\nclass ReportIntToPtr : public ReportOther {\n  // The offending base value.\n  Instruction *BaseValue;\n\npublic:\n  ReportIntToPtr(Instruction *BaseValue);\n\n  /// @name LLVM-RTTI interface\n  //@{\n  static bool classof(const RejectReason *RR);\n  //@}\n\n  /// @name RejectReason interface\n  //@{\n  std::string getRemarkName() const override;\n  const Value *getRemarkBB() const override;\n  std::string getMessage() const override;\n  const DebugLoc &getDebugLoc() const override;\n  //@}\n};\n\n//===----------------------------------------------------------------------===//\n/// Captures errors with alloca instructions.\nclass ReportAlloca : public ReportOther {\n  Instruction *Inst;\n\npublic:\n  ReportAlloca(Instruction *Inst);\n\n  /// @name LLVM-RTTI interface\n  //@{\n  static bool classof(const RejectReason *RR);\n  //@}\n\n  /// @name RejectReason interface\n  //@{\n  std::string getRemarkName() const override;\n  const Value *getRemarkBB() const override;\n  std::string getMessage() const override;\n  const DebugLoc &getDebugLoc() const override;\n  //@}\n};\n\n//===----------------------------------------------------------------------===//\n/// Captures errors with unknown instructions.\nclass ReportUnknownInst : public ReportOther {\n  Instruction *Inst;\n\npublic:\n  ReportUnknownInst(Instruction *Inst);\n\n  /// @name LLVM-RTTI interface\n  //@{\n  static bool classof(const RejectReason *RR);\n  //@}\n\n  /// @name RejectReason interface\n  //@{\n  std::string getRemarkName() const override;\n  const Value *getRemarkBB() const override;\n  std::string getMessage() const override;\n  const DebugLoc &getDebugLoc() const override;\n  //@}\n};\n\n//===----------------------------------------------------------------------===//\n/// Captures errors with regions containing the function entry block.\nclass ReportEntry : public ReportOther {\n  BasicBlock *BB;\n\npublic:\n  ReportEntry(BasicBlock *BB);\n\n  /// @name LLVM-RTTI interface\n  //@{\n  static bool classof(const RejectReason *RR);\n  //@}\n\n  /// @name RejectReason interface\n  //@{\n  std::string getRemarkName() const override;\n  const Value *getRemarkBB() const override;\n  std::string getMessage() const override;\n  std::string getEndUserMessage() const override;\n  const DebugLoc &getDebugLoc() const override;\n  //@}\n};\n\n//===----------------------------------------------------------------------===//\n/// Report regions that seem not profitable to be optimized.\nclass ReportUnprofitable : public ReportOther {\n  Region *R;\n\npublic:\n  ReportUnprofitable(Region *R);\n\n  /// @name LLVM-RTTI interface\n  //@{\n  static bool classof(const RejectReason *RR);\n  //@}\n\n  /// @name RejectReason interface\n  //@{\n  std::string getRemarkName() const override;\n  const Value *getRemarkBB() const override;\n  std::string getMessage() const override;\n  std::string getEndUserMessage() const override;\n  const DebugLoc &getDebugLoc() const override;\n  //@}\n};\n\n//===----------------------------------------------------------------------===//\n/// Captures errors with non-simple memory accesses.\nclass ReportNonSimpleMemoryAccess : public ReportOther {\n  // The offending call instruction.\n  Instruction *Inst;\n\npublic:\n  ReportNonSimpleMemoryAccess(Instruction *Inst);\n\n  /// @name LLVM-RTTI interface\n  //@{\n  static bool classof(const RejectReason *RR);\n  //@}\n\n  /// @name RejectReason interface\n  //@{\n  std::string getRemarkName() const override;\n  const Value *getRemarkBB() const override;\n  std::string getMessage() const override;\n  const DebugLoc &getDebugLoc() const override;\n  std::string getEndUserMessage() const override;\n  //@}\n};\n} // namespace polly\n\n#endif // POLLY_SCOPDETECTIONDIAGNOSTIC_H\n"}, "62": {"id": 62, "path": "/home/vsts/work/1/llvm-project/polly/include/polly/ScopPass.h", "content": "//===--------- ScopPass.h - Pass for Static Control Parts --------*-C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// This file defines the ScopPass class.  ScopPasses are just RegionPasses,\n// except they operate on Polly IR (Scop and ScopStmt) built by ScopInfo Pass.\n// Because they operate on Polly IR, not the LLVM IR, ScopPasses are not allowed\n// to modify the LLVM IR. Due to this limitation, the ScopPass class takes\n// care of declaring that no LLVM passes are invalidated.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef POLLY_SCOP_PASS_H\n#define POLLY_SCOP_PASS_H\n\n#include \"polly/ScopInfo.h\"\n#include \"llvm/ADT/PriorityWorklist.h\"\n#include \"llvm/Analysis/RegionPass.h\"\n#include \"llvm/Analysis/TargetTransformInfo.h\"\n#include \"llvm/IR/PassManager.h\"\n#include \"llvm/IR/PassManagerImpl.h\"\n\nnamespace polly {\nusing llvm::AllAnalysesOn;\nusing llvm::AnalysisManager;\nusing llvm::DominatorTreeAnalysis;\nusing llvm::InnerAnalysisManagerProxy;\nusing llvm::LoopAnalysis;\nusing llvm::OuterAnalysisManagerProxy;\nusing llvm::PassManager;\nusing llvm::RegionInfoAnalysis;\nusing llvm::ScalarEvolutionAnalysis;\nusing llvm::SmallPriorityWorklist;\nusing llvm::TargetIRAnalysis;\nusing llvm::TargetTransformInfo;\n\nclass Scop;\nclass SPMUpdater;\nstruct ScopStandardAnalysisResults;\n\nusing ScopAnalysisManager =\n    AnalysisManager<Scop, ScopStandardAnalysisResults &>;\nusing ScopAnalysisManagerFunctionProxy =\n    InnerAnalysisManagerProxy<ScopAnalysisManager, Function>;\nusing FunctionAnalysisManagerScopProxy =\n    OuterAnalysisManagerProxy<FunctionAnalysisManager, Scop,\n                              ScopStandardAnalysisResults &>;\n} // namespace polly\n\nnamespace llvm {\nusing polly::Scop;\nusing polly::ScopAnalysisManager;\nusing polly::ScopAnalysisManagerFunctionProxy;\nusing polly::ScopInfo;\nusing polly::ScopStandardAnalysisResults;\nusing polly::SPMUpdater;\n\ntemplate <>\nclass InnerAnalysisManagerProxy<ScopAnalysisManager, Function>::Result {\npublic:\n  explicit Result(ScopAnalysisManager &InnerAM, ScopInfo &SI)\n      : InnerAM(&InnerAM), SI(&SI) {}\n  Result(Result &&R) : InnerAM(std::move(R.InnerAM)), SI(R.SI) {\n    R.InnerAM = nullptr;\n  }\n  Result &operator=(Result &&RHS) {\n    InnerAM = RHS.InnerAM;\n    SI = RHS.SI;\n    RHS.InnerAM = nullptr;\n    return *this;\n  }\n  ~Result() {\n    if (!InnerAM)\n      return;\n    InnerAM->clear();\n  }\n\n  ScopAnalysisManager &getManager() { return *InnerAM; }\n\n  bool invalidate(Function &F, const PreservedAnalyses &PA,\n                  FunctionAnalysisManager::Invalidator &Inv);\n\nprivate:\n  ScopAnalysisManager *InnerAM;\n  ScopInfo *SI;\n};\n\n// A partial specialization of the require analysis template pass to handle\n// extra parameters\ntemplate <typename AnalysisT>\nstruct RequireAnalysisPass<AnalysisT, Scop, ScopAnalysisManager,\n                           ScopStandardAnalysisResults &, SPMUpdater &>\n    : PassInfoMixin<\n          RequireAnalysisPass<AnalysisT, Scop, ScopAnalysisManager,\n                              ScopStandardAnalysisResults &, SPMUpdater &>> {\n  PreservedAnalyses run(Scop &L, ScopAnalysisManager &AM,\n                        ScopStandardAnalysisResults &AR, SPMUpdater &) {\n    (void)AM.template getResult<AnalysisT>(L, AR);\n    return PreservedAnalyses::all();\n  }\n};\n\ntemplate <>\nInnerAnalysisManagerProxy<ScopAnalysisManager, Function>::Result\nInnerAnalysisManagerProxy<ScopAnalysisManager, Function>::run(\n    Function &F, FunctionAnalysisManager &FAM);\n\ntemplate <>\nPreservedAnalyses\nPassManager<Scop, ScopAnalysisManager, ScopStandardAnalysisResults &,\n            SPMUpdater &>::run(Scop &InitialS, ScopAnalysisManager &AM,\n                               ScopStandardAnalysisResults &, SPMUpdater &);\nextern template class PassManager<Scop, ScopAnalysisManager,\n                                  ScopStandardAnalysisResults &, SPMUpdater &>;\nextern template class InnerAnalysisManagerProxy<ScopAnalysisManager, Function>;\nextern template class OuterAnalysisManagerProxy<FunctionAnalysisManager, Scop,\n                                                ScopStandardAnalysisResults &>;\n} // namespace llvm\n\nnamespace polly {\n\ntemplate <typename AnalysisManagerT, typename IRUnitT, typename... ExtraArgTs>\nclass OwningInnerAnalysisManagerProxy\n    : public InnerAnalysisManagerProxy<AnalysisManagerT, IRUnitT> {\npublic:\n  OwningInnerAnalysisManagerProxy()\n      : InnerAnalysisManagerProxy<AnalysisManagerT, IRUnitT>(InnerAM) {}\n  using Result = typename InnerAnalysisManagerProxy<AnalysisManagerT, IRUnitT,\n                                                    ExtraArgTs...>::Result;\n  Result run(IRUnitT &IR, AnalysisManager<IRUnitT, ExtraArgTs...> &AM,\n             ExtraArgTs...) {\n    return Result(InnerAM);\n  }\n\n  AnalysisManagerT &getManager() { return InnerAM; }\n\nprivate:\n  AnalysisManagerT InnerAM;\n};\n\ntemplate <>\nOwningInnerAnalysisManagerProxy<ScopAnalysisManager, Function>::Result\nOwningInnerAnalysisManagerProxy<ScopAnalysisManager, Function>::run(\n    Function &F, FunctionAnalysisManager &FAM);\nextern template class OwningInnerAnalysisManagerProxy<ScopAnalysisManager,\n                                                      Function>;\n\nusing OwningScopAnalysisManagerFunctionProxy =\n    OwningInnerAnalysisManagerProxy<ScopAnalysisManager, Function>;\nusing ScopPassManager =\n    PassManager<Scop, ScopAnalysisManager, ScopStandardAnalysisResults &,\n                SPMUpdater &>;\n\n/// ScopPass - This class adapts the RegionPass interface to allow convenient\n/// creation of passes that operate on the Polly IR. Instead of overriding\n/// runOnRegion, subclasses override runOnScop.\nclass ScopPass : public RegionPass {\n  Scop *S;\n\nprotected:\n  explicit ScopPass(char &ID) : RegionPass(ID), S(0) {}\n\n  /// runOnScop - This method must be overloaded to perform the\n  /// desired Polyhedral transformation or analysis.\n  ///\n  virtual bool runOnScop(Scop &S) = 0;\n\n  /// Print method for SCoPs.\n  virtual void printScop(raw_ostream &OS, Scop &S) const {}\n\n  /// getAnalysisUsage - Subclasses that override getAnalysisUsage\n  /// must call this.\n  ///\n  virtual void getAnalysisUsage(AnalysisUsage &AU) const override;\n\nprivate:\n  bool runOnRegion(Region *R, RGPassManager &RGM) override;\n  void print(raw_ostream &OS, const Module *) const override;\n};\n\nstruct ScopStandardAnalysisResults {\n  DominatorTree &DT;\n  ScopInfo &SI;\n  ScalarEvolution &SE;\n  LoopInfo &LI;\n  RegionInfo &RI;\n  TargetTransformInfo &TTI;\n};\n\nclass SPMUpdater {\npublic:\n  SPMUpdater(SmallPriorityWorklist<Region *, 4> &Worklist,\n             ScopAnalysisManager &SAM)\n      : InvalidateCurrentScop(false), Worklist(Worklist), SAM(SAM) {}\n\n  bool invalidateCurrentScop() const { return InvalidateCurrentScop; }\n\n  void invalidateScop(Scop &S) {\n    if (&S == CurrentScop)\n      InvalidateCurrentScop = true;\n\n    Worklist.erase(&S.getRegion());\n    SAM.clear(S, S.getName());\n  }\n\nprivate:\n  Scop *CurrentScop;\n  bool InvalidateCurrentScop;\n  SmallPriorityWorklist<Region *, 4> &Worklist;\n  ScopAnalysisManager &SAM;\n  template <typename ScopPassT> friend class FunctionToScopPassAdaptor;\n};\n\ntemplate <typename ScopPassT>\nclass FunctionToScopPassAdaptor\n    : public PassInfoMixin<FunctionToScopPassAdaptor<ScopPassT>> {\npublic:\n  explicit FunctionToScopPassAdaptor(ScopPassT Pass) : Pass(std::move(Pass)) {}\n\n  PreservedAnalyses run(Function &F, FunctionAnalysisManager &AM) {\n    ScopDetection &SD = AM.getResult<ScopAnalysis>(F);\n    ScopInfo &SI = AM.getResult<ScopInfoAnalysis>(F);\n    if (SI.empty()) {\n      // With no scops having been detected, no IR changes have been made and\n      // therefore all analyses are preserved. However, we must still free the\n      // Scop analysis results which may hold AssertingVH that cause an error\n      // if its value is destroyed.\n      AM.invalidate<ScopInfoAnalysis>(F);\n      AM.invalidate<ScopAnalysis>(F);\n      return PreservedAnalyses::all();\n    }\n\n    SmallPriorityWorklist<Region *, 4> Worklist;\n    for (auto &S : SI)\n      if (S.second)\n        Worklist.insert(S.first);\n\n    ScopStandardAnalysisResults AR = {AM.getResult<DominatorTreeAnalysis>(F),\n                                      AM.getResult<ScopInfoAnalysis>(F),\n                                      AM.getResult<ScalarEvolutionAnalysis>(F),\n                                      AM.getResult<LoopAnalysis>(F),\n                                      AM.getResult<RegionInfoAnalysis>(F),\n                                      AM.getResult<TargetIRAnalysis>(F)};\n\n    ScopAnalysisManager &SAM =\n        AM.getResult<ScopAnalysisManagerFunctionProxy>(F).getManager();\n\n    SPMUpdater Updater{Worklist, SAM};\n\n    while (!Worklist.empty()) {\n      Region *R = Worklist.pop_back_val();\n      if (!SD.isMaxRegionInScop(*R, /*Verifying=*/false))\n        continue;\n      Scop *scop = SI.getScop(R);\n      if (!scop)\n        continue;\n      Updater.CurrentScop = scop;\n      Updater.InvalidateCurrentScop = false;\n      PreservedAnalyses PassPA = Pass.run(*scop, SAM, AR, Updater);\n\n      SAM.invalidate(*scop, PassPA);\n      if (Updater.invalidateCurrentScop())\n        SI.recompute();\n    };\n\n    // FIXME: For the same reason as we add a BarrierNoopPass in the legacy pass\n    // manager, do not preserve any analyses. While CodeGeneration may preserve\n    // IR analyses sufficiently to process another Scop in the same function (it\n    // has to, otherwise the ScopDetection result itself would need to be\n    // invalidated), it is not sufficient for other purposes. For instance,\n    // CodeGeneration does not inform LoopInfo about new loops in the\n    // Polly-generated IR.\n    return PreservedAnalyses::none();\n  }\n\nprivate:\n  ScopPassT Pass;\n};\n\ntemplate <typename ScopPassT>\nFunctionToScopPassAdaptor<ScopPassT>\ncreateFunctionToScopPassAdaptor(ScopPassT Pass) {\n  return FunctionToScopPassAdaptor<ScopPassT>(std::move(Pass));\n}\n} // namespace polly\n\n#endif\n"}, "63": {"id": 63, "path": "/home/vsts/work/1/llvm-project/polly/include/polly/Support/ScopHelper.h", "content": "//===------ Support/ScopHelper.h -- Some Helper Functions for Scop. -------===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// Small functions that help with LLVM-IR.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef POLLY_SUPPORT_IRHELPER_H\n#define POLLY_SUPPORT_IRHELPER_H\n\n#include \"llvm/ADT/SetVector.h\"\n#include \"llvm/IR/Instructions.h\"\n#include \"llvm/IR/IntrinsicInst.h\"\n#include \"llvm/IR/ValueHandle.h\"\n#include \"isl/isl-noexceptions.h\"\n\nnamespace llvm {\nclass LoopInfo;\nclass Loop;\nclass ScalarEvolution;\nclass SCEV;\nclass Region;\nclass Pass;\nclass DominatorTree;\nclass RegionInfo;\nclass RegionNode;\n} // namespace llvm\n\nnamespace polly {\nclass Scop;\nclass ScopStmt;\n\n/// Enumeration of assumptions Polly can take.\nenum AssumptionKind {\n  ALIASING,\n  INBOUNDS,\n  WRAPPING,\n  UNSIGNED,\n  PROFITABLE,\n  ERRORBLOCK,\n  COMPLEXITY,\n  INFINITELOOP,\n  INVARIANTLOAD,\n  DELINEARIZATION,\n};\n\n/// Enum to distinguish between assumptions and restrictions.\nenum AssumptionSign { AS_ASSUMPTION, AS_RESTRICTION };\n\n/// Helper struct to remember assumptions.\nstruct Assumption {\n  /// The kind of the assumption (e.g., WRAPPING).\n  AssumptionKind Kind;\n\n  /// Flag to distinguish assumptions and restrictions.\n  AssumptionSign Sign;\n\n  /// The valid/invalid context if this is an assumption/restriction.\n  isl::set Set;\n\n  /// The location that caused this assumption.\n  llvm::DebugLoc Loc;\n\n  /// An optional block whose domain can simplify the assumption.\n  llvm::BasicBlock *BB;\n\n  // Whether the assumption must be checked at runtime.\n  bool RequiresRTC;\n};\n\nusing RecordedAssumptionsTy = llvm::SmallVector<Assumption, 8>;\n\n/// Record an assumption for later addition to the assumed context.\n///\n/// This function will add the assumption to the RecordedAssumptions. This\n/// collection will be added (@see addAssumption) to the assumed context once\n/// all paramaters are known and the context is fully built.\n///\n/// @param RecordedAssumption container which keeps all recorded assumptions.\n/// @param Kind The assumption kind describing the underlying cause.\n/// @param Set  The relations between parameters that are assumed to hold.\n/// @param Loc  The location in the source that caused this assumption.\n/// @param Sign Enum to indicate if the assumptions in @p Set are positive\n///             (needed/assumptions) or negative (invalid/restrictions).\n/// @param BB   The block in which this assumption was taken. If it is\n///             set, the domain of that block will be used to simplify the\n///             actual assumption in @p Set once it is added. This is useful\n///             if the assumption was created prior to the domain.\n/// @param RTC  Does the assumption require a runtime check?\nvoid recordAssumption(RecordedAssumptionsTy *RecordedAssumptions,\n                      AssumptionKind Kind, isl::set Set, llvm::DebugLoc Loc,\n                      AssumptionSign Sign, llvm::BasicBlock *BB = nullptr,\n                      bool RTC = true);\n\n/// Type to remap values.\nusing ValueMapT = llvm::DenseMap<llvm::AssertingVH<llvm::Value>,\n                                 llvm::AssertingVH<llvm::Value>>;\n\n/// Type for a set of invariant loads.\nusing InvariantLoadsSetTy = llvm::SetVector<llvm::AssertingVH<llvm::LoadInst>>;\n\n/// Set type for parameters.\nusing ParameterSetTy = llvm::SetVector<const llvm::SCEV *>;\n\n/// Set of loops (used to remember loops in non-affine subregions).\nusing BoxedLoopsSetTy = llvm::SetVector<const llvm::Loop *>;\n\n/// Utility proxy to wrap the common members of LoadInst and StoreInst.\n///\n/// This works like the LLVM utility class CallSite, ie. it forwards all calls\n/// to either a LoadInst, StoreInst, MemIntrinsic or MemTransferInst.\n/// It is similar to LLVM's utility classes IntrinsicInst, MemIntrinsic,\n/// MemTransferInst, etc. in that it offers a common interface, but does not act\n/// as a fake base class.\n/// It is similar to StringRef and ArrayRef in that it holds a pointer to the\n/// referenced object and should be passed by-value as it is small enough.\n///\n/// This proxy can either represent a LoadInst instance, a StoreInst instance,\n/// a MemIntrinsic instance (memset, memmove, memcpy), a CallInst instance or a\n/// nullptr (only creatable using the default constructor); never an Instruction\n/// that is neither of the above mentioned. When representing a nullptr, only\n/// the following methods are defined:\n/// isNull(), isInstruction(), isLoad(), isStore(), ..., isMemTransferInst(),\n/// operator bool(), operator!()\n///\n/// The functions isa, cast, cast_or_null, dyn_cast are modeled te resemble\n/// those from llvm/Support/Casting.h. Partial template function specialization\n/// is currently not supported in C++ such that those cannot be used directly.\n/// (llvm::isa could, but then llvm:cast etc. would not have the expected\n/// behavior)\nclass MemAccInst {\nprivate:\n  llvm::Instruction *I;\n\npublic:\n  MemAccInst() : I(nullptr) {}\n  MemAccInst(const MemAccInst &Inst) : I(Inst.I) {}\n  /* implicit */ MemAccInst(llvm::LoadInst &LI) : I(&LI) {}\n  /* implicit */ MemAccInst(llvm::LoadInst *LI) : I(LI) {}\n  /* implicit */ MemAccInst(llvm::StoreInst &SI) : I(&SI) {}\n  /* implicit */ MemAccInst(llvm::StoreInst *SI) : I(SI) {}\n  /* implicit */ MemAccInst(llvm::MemIntrinsic *MI) : I(MI) {}\n  /* implicit */ MemAccInst(llvm::CallInst *CI) : I(CI) {}\n  explicit MemAccInst(llvm::Instruction &I) : I(&I) { assert(isa(I)); }\n  explicit MemAccInst(llvm::Instruction *I) : I(I) { assert(isa(I)); }\n\n  static bool isa(const llvm::Value &V) {\n    return llvm::isa<llvm::LoadInst>(V) || llvm::isa<llvm::StoreInst>(V) ||\n           llvm::isa<llvm::CallInst>(V) || llvm::isa<llvm::MemIntrinsic>(V);\n  }\n  static bool isa(const llvm::Value *V) {\n    return llvm::isa<llvm::LoadInst>(V) || llvm::isa<llvm::StoreInst>(V) ||\n           llvm::isa<llvm::CallInst>(V) || llvm::isa<llvm::MemIntrinsic>(V);\n  }\n  static MemAccInst cast(llvm::Value &V) {\n    return MemAccInst(llvm::cast<llvm::Instruction>(V));\n  }\n  static MemAccInst cast(llvm::Value *V) {\n    return MemAccInst(llvm::cast<llvm::Instruction>(V));\n  }\n  static MemAccInst cast_or_null(llvm::Value &V) {\n    return MemAccInst(llvm::cast<llvm::Instruction>(V));\n  }\n  static MemAccInst cast_or_null(llvm::Value *V) {\n    if (!V)\n      return MemAccInst();\n    return MemAccInst(llvm::cast<llvm::Instruction>(V));\n  }\n  static MemAccInst dyn_cast(llvm::Value &V) {\n    if (isa(V))\n      return MemAccInst(llvm::cast<llvm::Instruction>(V));\n    return MemAccInst();\n  }\n  static MemAccInst dyn_cast(llvm::Value *V) {\n    assert(V);\n    if (isa(V))\n      return MemAccInst(llvm::cast<llvm::Instruction>(V));\n    return MemAccInst();\n  }\n\n  MemAccInst &operator=(const MemAccInst &Inst) {\n    I = Inst.I;\n    return *this;\n  }\n  MemAccInst &operator=(llvm::LoadInst &LI) {\n    I = &LI;\n    return *this;\n  }\n  MemAccInst &operator=(llvm::LoadInst *LI) {\n    I = LI;\n    return *this;\n  }\n  MemAccInst &operator=(llvm::StoreInst &SI) {\n    I = &SI;\n    return *this;\n  }\n  MemAccInst &operator=(llvm::StoreInst *SI) {\n    I = SI;\n    return *this;\n  }\n  MemAccInst &operator=(llvm::MemIntrinsic &MI) {\n    I = &MI;\n    return *this;\n  }\n  MemAccInst &operator=(llvm::MemIntrinsic *MI) {\n    I = MI;\n    return *this;\n  }\n  MemAccInst &operator=(llvm::CallInst &CI) {\n    I = &CI;\n    return *this;\n  }\n  MemAccInst &operator=(llvm::CallInst *CI) {\n    I = CI;\n    return *this;\n  }\n\n  llvm::Instruction *get() const {\n    assert(I && \"Unexpected nullptr!\");\n    return I;\n  }\n  operator llvm::Instruction *() const { return asInstruction(); }\n  llvm::Instruction *operator->() const { return get(); }\n\n  explicit operator bool() const { return isInstruction(); }\n  bool operator!() const { return isNull(); }\n\n  llvm::Value *getValueOperand() const {\n    if (isLoad())\n      return asLoad();\n    if (isStore())\n      return asStore()->getValueOperand();\n    if (isMemIntrinsic())\n      return nullptr;\n    if (isCallInst())\n      return nullptr;\n    llvm_unreachable(\"Operation not supported on nullptr\");\n  }\n  llvm::Value *getPointerOperand() const {\n    if (isLoad())\n      return asLoad()->getPointerOperand();\n    if (isStore())\n      return asStore()->getPointerOperand();\n    if (isMemIntrinsic())\n      return asMemIntrinsic()->getRawDest();\n    if (isCallInst())\n      return nullptr;\n    llvm_unreachable(\"Operation not supported on nullptr\");\n  }\n\n  unsigned getAlignment() const {\n    if (isLoad())\n      return asLoad()->getAlignment();\n    if (isStore())\n      return asStore()->getAlignment();\n    if (isMemTransferInst())\n      return std::min(asMemTransferInst()->getDestAlignment(),\n                      asMemTransferInst()->getSourceAlignment());\n    if (isMemIntrinsic())\n      return asMemIntrinsic()->getDestAlignment();\n    if (isCallInst())\n      return 0;\n    llvm_unreachable(\"Operation not supported on nullptr\");\n  }\n  bool isVolatile() const {\n    if (isLoad())\n      return asLoad()->isVolatile();\n    if (isStore())\n      return asStore()->isVolatile();\n    if (isMemIntrinsic())\n      return asMemIntrinsic()->isVolatile();\n    if (isCallInst())\n      return false;\n    llvm_unreachable(\"Operation not supported on nullptr\");\n  }\n  bool isSimple() const {\n    if (isLoad())\n      return asLoad()->isSimple();\n    if (isStore())\n      return asStore()->isSimple();\n    if (isMemIntrinsic())\n      return !asMemIntrinsic()->isVolatile();\n    if (isCallInst())\n      return true;\n    llvm_unreachable(\"Operation not supported on nullptr\");\n  }\n  llvm::AtomicOrdering getOrdering() const {\n    if (isLoad())\n      return asLoad()->getOrdering();\n    if (isStore())\n      return asStore()->getOrdering();\n    if (isMemIntrinsic())\n      return llvm::AtomicOrdering::NotAtomic;\n    if (isCallInst())\n      return llvm::AtomicOrdering::NotAtomic;\n    llvm_unreachable(\"Operation not supported on nullptr\");\n  }\n  bool isUnordered() const {\n    if (isLoad())\n      return asLoad()->isUnordered();\n    if (isStore())\n      return asStore()->isUnordered();\n    // Copied from the Load/Store implementation of isUnordered:\n    if (isMemIntrinsic())\n      return !asMemIntrinsic()->isVolatile();\n    if (isCallInst())\n      return true;\n    llvm_unreachable(\"Operation not supported on nullptr\");\n  }\n\n  bool isNull() const { return !I; }\n  bool isInstruction() const { return I; }\n\n  llvm::Instruction *asInstruction() const { return I; }\n\nprivate:\n  bool isLoad() const { return I && llvm::isa<llvm::LoadInst>(I); }\n  bool isStore() const { return I && llvm::isa<llvm::StoreInst>(I); }\n  bool isCallInst() const { return I && llvm::isa<llvm::CallInst>(I); }\n  bool isMemIntrinsic() const { return I && llvm::isa<llvm::MemIntrinsic>(I); }\n  bool isMemSetInst() const { return I && llvm::isa<llvm::MemSetInst>(I); }\n  bool isMemTransferInst() const {\n    return I && llvm::isa<llvm::MemTransferInst>(I);\n  }\n\n  llvm::LoadInst *asLoad() const { return llvm::cast<llvm::LoadInst>(I); }\n  llvm::StoreInst *asStore() const { return llvm::cast<llvm::StoreInst>(I); }\n  llvm::CallInst *asCallInst() const { return llvm::cast<llvm::CallInst>(I); }\n  llvm::MemIntrinsic *asMemIntrinsic() const {\n    return llvm::cast<llvm::MemIntrinsic>(I);\n  }\n  llvm::MemSetInst *asMemSetInst() const {\n    return llvm::cast<llvm::MemSetInst>(I);\n  }\n  llvm::MemTransferInst *asMemTransferInst() const {\n    return llvm::cast<llvm::MemTransferInst>(I);\n  }\n};\n} // namespace polly\n\nnamespace llvm {\n/// Specialize simplify_type for MemAccInst to enable dyn_cast and cast\n///        from a MemAccInst object.\ntemplate <> struct simplify_type<polly::MemAccInst> {\n  typedef Instruction *SimpleType;\n  static SimpleType getSimplifiedValue(polly::MemAccInst &I) {\n    return I.asInstruction();\n  }\n};\n} // namespace llvm\n\nnamespace polly {\n\n/// Simplify the region to have a single unconditional entry edge and a\n/// single exit edge.\n///\n/// Although this function allows DT and RI to be null, regions only work\n/// properly if the DominatorTree (for Region::contains) and RegionInfo are kept\n/// up-to-date.\n///\n/// @param R  The region to be simplified\n/// @param DT DominatorTree to be updated.\n/// @param LI LoopInfo to be updated.\n/// @param RI RegionInfo to be updated.\nvoid simplifyRegion(llvm::Region *R, llvm::DominatorTree *DT,\n                    llvm::LoopInfo *LI, llvm::RegionInfo *RI);\n\n/// Split the entry block of a function to store the newly inserted\n///        allocations outside of all Scops.\n///\n/// @param EntryBlock The entry block of the current function.\n/// @param P          The pass that currently running.\n///\nvoid splitEntryBlockForAlloca(llvm::BasicBlock *EntryBlock, llvm::Pass *P);\n\n/// Split the entry block of a function to store the newly inserted\n///        allocations outside of all Scops.\n///\n/// @param DT DominatorTree to be updated.\n/// @param LI LoopInfo to be updated.\n/// @param RI RegionInfo to be updated.\nvoid splitEntryBlockForAlloca(llvm::BasicBlock *EntryBlock,\n                              llvm::DominatorTree *DT, llvm::LoopInfo *LI,\n                              llvm::RegionInfo *RI);\n\n/// Wrapper for SCEVExpander extended to all Polly features.\n///\n/// This wrapper will internally call the SCEVExpander but also makes sure that\n/// all additional features not represented in SCEV (e.g., SDiv/SRem are not\n/// black boxes but can be part of the function) will be expanded correctly.\n///\n/// The parameters are the same as for the creation of a SCEVExpander as well\n/// as the call to SCEVExpander::expandCodeFor:\n///\n/// @param S     The current Scop.\n/// @param SE    The Scalar Evolution pass.\n/// @param DL    The module data layout.\n/// @param Name  The suffix added to the new instruction names.\n/// @param E     The expression for which code is actually generated.\n/// @param Ty    The type of the resulting code.\n/// @param IP    The insertion point for the new code.\n/// @param VMap  A remapping of values used in @p E.\n/// @param RTCBB The last block of the RTC. Used to insert loop-invariant\n///              instructions in rare cases.\nllvm::Value *expandCodeFor(Scop &S, llvm::ScalarEvolution &SE,\n                           const llvm::DataLayout &DL, const char *Name,\n                           const llvm::SCEV *E, llvm::Type *Ty,\n                           llvm::Instruction *IP, ValueMapT *VMap,\n                           llvm::BasicBlock *RTCBB);\n\n/// Check if the block is a error block.\n///\n/// A error block is currently any block that fulfills at least one of\n/// the following conditions:\n///\n///  - It is terminated by an unreachable instruction\n///  - It contains a call to a non-pure function that is not immediately\n///    dominated by a loop header and that does not dominate the region exit.\n///    This is a heuristic to pick only error blocks that are conditionally\n///    executed and can be assumed to be not executed at all without the domains\n///    being available.\n///\n/// @param BB The block to check.\n/// @param R  The analyzed region.\n/// @param LI The loop info analysis.\n/// @param DT The dominator tree of the function.\n///\n/// @return True if the block is a error block, false otherwise.\nbool isErrorBlock(llvm::BasicBlock &BB, const llvm::Region &R,\n                  llvm::LoopInfo &LI, const llvm::DominatorTree &DT);\n\n/// Return the condition for the terminator @p TI.\n///\n/// For unconditional branches the \"i1 true\" condition will be returned.\n///\n/// @param TI The terminator to get the condition from.\n///\n/// @return The condition of @p TI and nullptr if none could be extracted.\nllvm::Value *getConditionFromTerminator(llvm::Instruction *TI);\n\n/// Get the smallest loop that contains @p S but is not in @p S.\nllvm::Loop *getLoopSurroundingScop(Scop &S, llvm::LoopInfo &LI);\n\n/// Get the number of blocks in @p L.\n///\n/// The number of blocks in a loop are the number of basic blocks actually\n/// belonging to the loop, as well as all single basic blocks that the loop\n/// exits to and which terminate in an unreachable instruction. We do not\n/// allow such basic blocks in the exit of a scop, hence they belong to the\n/// scop and represent run-time conditions which we want to model and\n/// subsequently speculate away.\n///\n/// @see getRegionNodeLoop for additional details.\nunsigned getNumBlocksInLoop(llvm::Loop *L);\n\n/// Get the number of blocks in @p RN.\nunsigned getNumBlocksInRegionNode(llvm::RegionNode *RN);\n\n/// Return the smallest loop surrounding @p RN.\nllvm::Loop *getRegionNodeLoop(llvm::RegionNode *RN, llvm::LoopInfo &LI);\n\n/// Check if @p LInst can be hoisted in @p R.\n///\n/// @param LInst The load to check.\n/// @param R     The analyzed region.\n/// @param LI    The loop info.\n/// @param SE    The scalar evolution analysis.\n/// @param DT    The dominator tree of the function.\n/// @param KnownInvariantLoads The invariant load set.\n///\n/// @return True if @p LInst can be hoisted in @p R.\nbool isHoistableLoad(llvm::LoadInst *LInst, llvm::Region &R, llvm::LoopInfo &LI,\n                     llvm::ScalarEvolution &SE, const llvm::DominatorTree &DT,\n                     const InvariantLoadsSetTy &KnownInvariantLoads);\n\n/// Return true iff @p V is an intrinsic that we ignore during code\n///        generation.\nbool isIgnoredIntrinsic(const llvm::Value *V);\n\n/// Check whether a value an be synthesized by the code generator.\n///\n/// Some value will be recalculated only from information that is code generated\n/// from the polyhedral representation. For such instructions we do not need to\n/// ensure that their operands are available during code generation.\n///\n/// @param V The value to check.\n/// @param S The current SCoP.\n/// @param SE The scalar evolution database.\n/// @param Scope Location where the value would by synthesized.\n/// @return If the instruction I can be regenerated from its\n///         scalar evolution representation, return true,\n///         otherwise return false.\nbool canSynthesize(const llvm::Value *V, const Scop &S,\n                   llvm::ScalarEvolution *SE, llvm::Loop *Scope);\n\n/// Return the block in which a value is used.\n///\n/// For normal instructions, this is the instruction's parent block. For PHI\n/// nodes, this is the incoming block of that use, because this is where the\n/// operand must be defined (i.e. its definition dominates this block).\n/// Non-instructions do not use operands at a specific point such that in this\n/// case this function returns nullptr.\nllvm::BasicBlock *getUseBlock(const llvm::Use &U);\n\n// If the loop is nonaffine/boxed, return the first non-boxed surrounding loop\n// for Polly. If the loop is affine, return the loop itself.\n//\n// @param L             Pointer to the Loop object to analyze.\n// @param LI            Reference to the LoopInfo.\n// @param BoxedLoops    Set of Boxed Loops we get from the SCoP.\nllvm::Loop *getFirstNonBoxedLoopFor(llvm::Loop *L, llvm::LoopInfo &LI,\n                                    const BoxedLoopsSetTy &BoxedLoops);\n\n// If the Basic Block belongs to a loop that is nonaffine/boxed, return the\n// first non-boxed surrounding loop for Polly. If the loop is affine, return\n// the loop itself.\n//\n// @param BB            Pointer to the Basic Block to analyze.\n// @param LI            Reference to the LoopInfo.\n// @param BoxedLoops    Set of Boxed Loops we get from the SCoP.\nllvm::Loop *getFirstNonBoxedLoopFor(llvm::BasicBlock *BB, llvm::LoopInfo &LI,\n                                    const BoxedLoopsSetTy &BoxedLoops);\n\n/// Is the given instruction a call to a debug function?\n///\n/// A debug function can be used to insert output in Polly-optimized code which\n/// normally does not allow function calls with side-effects. For instance, a\n/// printf can be inserted to check whether a value still has the expected value\n/// after Polly generated code:\n///\n///     int sum = 0;\n///     for (int i = 0; i < 16; i+=1) {\n///       sum += i;\n///       printf(\"The value of sum at i=%d is %d\\n\", sum, i);\n///     }\nbool isDebugCall(llvm::Instruction *Inst);\n\n/// Does the statement contain a call to a debug function?\n///\n/// Such a statement must not be removed, even if has no side-effects.\nbool hasDebugCall(ScopStmt *Stmt);\n} // namespace polly\n#endif\n"}, "64": {"id": 64, "path": "/home/vsts/work/1/llvm-project/polly/lib/External/isl/include/isl/isl-noexceptions.h", "content": "/// These are automatically generated checked C++ bindings for isl.\n///\n/// isl is a library for computing with integer sets and maps described by\n/// Presburger formulas. On top of this, isl provides various tools for\n/// polyhedral compilation, ranging from dependence analysis over scheduling\n/// to AST generation.\n\n#ifndef ISL_CPP_CHECKED\n#define ISL_CPP_CHECKED\n\n#include <isl/id.h>\n#include <isl/space.h>\n#include <isl/val.h>\n#include <isl/aff.h>\n#include <isl/set.h>\n#include <isl/id.h>\n#include <isl/map.h>\n#include <isl/vec.h>\n#include <isl/ilp.h>\n#include <isl/union_set.h>\n#include <isl/union_map.h>\n#include <isl/flow.h>\n#include <isl/schedule.h>\n#include <isl/schedule_node.h>\n#include <isl/ast_build.h>\n#include <isl/fixed_box.h>\n#include <isl/constraint.h>\n#include <isl/polynomial.h>\n#include <isl/mat.h>\n#include <isl/fixed_box.h>\n#include <stdio.h>\n#include <stdlib.h>\n\n#include <functional>\n#include <string>\n\nnamespace isl {\ninline namespace noexceptions {\n\n#define ISLPP_STRINGIZE_(X) #X\n#define ISLPP_STRINGIZE(X) ISLPP_STRINGIZE_(X)\n\n#define ISLPP_ASSERT(test, message)                          \\\n  do {                                                       \\\n    if (test)                                                \\\n      break;                                                 \\\n    fputs(\"Assertion \\\"\" #test \"\\\" failed at \" __FILE__      \\\n      \":\" ISLPP_STRINGIZE(__LINE__) \"\\n  \" message \"\\n\",     \\\n      stderr);                                               \\\n    abort();                                                 \\\n  } while (0)\n\nclass boolean {\nprivate:\n  mutable bool checked = false;\n  isl_bool val;\n\n  friend boolean manage(isl_bool val);\n  boolean(isl_bool val): val(val) {}\npublic:\n  boolean()\n      : val(isl_bool_error) {}\n  ~boolean() {\n    // ISLPP_ASSERT(checked, \"IMPLEMENTATION ERROR: Unchecked state\");\n  }\n\n  /* implicit */ boolean(bool val)\n      : val(val ? isl_bool_true : isl_bool_false) {}\n\n  bool is_error() const { checked = true; return val == isl_bool_error; }\n  bool is_false() const { checked = true; return val == isl_bool_false; }\n  bool is_true() const { checked = true; return val == isl_bool_true; }\n\n  operator bool() const {\n    // ISLPP_ASSERT(checked, \"IMPLEMENTATION ERROR: Unchecked error state\");\n    ISLPP_ASSERT(!is_error(), \"IMPLEMENTATION ERROR: Unhandled error state\");\n    return is_true();\n  }\n\n  boolean operator!() const {\n    if (is_error())\n      return *this;\n    return !is_true();\n  }\n};\n\ninline boolean manage(isl_bool val) {\n  return boolean(val);\n}\n\nclass ctx {\n  isl_ctx *ptr;\npublic:\n  /* implicit */ ctx(isl_ctx *ctx)\n      : ptr(ctx) {}\n  isl_ctx *release() {\n    auto tmp = ptr;\n    ptr = nullptr;\n    return tmp;\n  }\n  isl_ctx *get() {\n    return ptr;\n  }\n};\n\n/* Class encapsulating an isl_stat value.\n */\nclass stat {\nprivate:\n\tmutable bool checked = false;\n\tisl_stat val;\n\n\tfriend stat manage(isl_stat val);\npublic:\n\tconstexpr stat(isl_stat val) : val(val) {}\n\tstatic stat ok() {\n\t\treturn stat(isl_stat_ok);\n\t}\n\tstatic stat error() {\n\t\treturn stat(isl_stat_error);\n\t}\n\tstat() : val(isl_stat_error) {}\n\t~stat() {\n\t\t// ISLPP_ASSERT(checked, \"IMPLEMENTATION ERROR: Unchecked state\");\n\t}\n\n\tisl_stat release() {\n\t\tchecked = true;\n\t\treturn val;\n\t}\n\n\tbool is_error() const {\n\t\tchecked = true;\n\t\treturn val == isl_stat_error;\n\t}\n\tbool is_ok() const {\n\t\tchecked = true;\n\t\treturn val == isl_stat_ok;\n\t}\n};\n\n\ninline stat manage(isl_stat val)\n{\n\treturn stat(val);\n}\n\nenum class dim {\n  cst = isl_dim_cst,\n  param = isl_dim_param,\n  in = isl_dim_in,\n  out = isl_dim_out,\n  set = isl_dim_set,\n  div = isl_dim_div,\n  all = isl_dim_all\n};\n\n}\n} // namespace isl\n\nnamespace isl {\n\ninline namespace noexceptions {\n\n// forward declarations\nclass aff;\nclass aff_list;\nclass ast_build;\nclass ast_expr;\nclass ast_expr_list;\nclass ast_node;\nclass ast_node_list;\nclass basic_map;\nclass basic_map_list;\nclass basic_set;\nclass basic_set_list;\nclass constraint;\nclass constraint_list;\nclass fixed_box;\nclass id;\nclass id_list;\nclass id_to_ast_expr;\nclass local_space;\nclass map;\nclass map_list;\nclass mat;\nclass multi_aff;\nclass multi_id;\nclass multi_pw_aff;\nclass multi_union_pw_aff;\nclass multi_val;\nclass point;\nclass pw_aff;\nclass pw_aff_list;\nclass pw_multi_aff;\nclass pw_multi_aff_list;\nclass pw_qpolynomial;\nclass pw_qpolynomial_fold_list;\nclass pw_qpolynomial_list;\nclass qpolynomial;\nclass qpolynomial_list;\nclass schedule;\nclass schedule_constraints;\nclass schedule_node;\nclass set;\nclass set_list;\nclass space;\nclass term;\nclass union_access_info;\nclass union_flow;\nclass union_map;\nclass union_map_list;\nclass union_pw_aff;\nclass union_pw_aff_list;\nclass union_pw_multi_aff;\nclass union_pw_multi_aff_list;\nclass union_pw_qpolynomial;\nclass union_set;\nclass union_set_list;\nclass val;\nclass val_list;\nclass vec;\n\n// declarations for isl::aff\ninline aff manage(__isl_take isl_aff *ptr);\ninline aff manage_copy(__isl_keep isl_aff *ptr);\n\nclass aff {\n  friend inline aff manage(__isl_take isl_aff *ptr);\n  friend inline aff manage_copy(__isl_keep isl_aff *ptr);\n\n  isl_aff *ptr = nullptr;\n\n  inline explicit aff(__isl_take isl_aff *ptr);\n\npublic:\n  inline /* implicit */ aff();\n  inline /* implicit */ aff(const aff &obj);\n  inline /* implicit */ aff(std::nullptr_t);\n  inline explicit aff(ctx ctx, const std::string &str);\n  inline explicit aff(local_space ls, val val);\n  inline explicit aff(local_space ls);\n  inline aff &operator=(aff obj);\n  inline ~aff();\n  inline __isl_give isl_aff *copy() const &;\n  inline __isl_give isl_aff *copy() && = delete;\n  inline __isl_keep isl_aff *get() const;\n  inline __isl_give isl_aff *release();\n  inline bool is_null() const;\n  inline explicit operator bool() const;\n  inline ctx get_ctx() const;\n  inline std::string to_str() const;\n  inline void dump() const;\n\n  inline aff add(aff aff2) const;\n  inline aff add_coefficient_si(isl::dim type, int pos, int v) const;\n  inline aff add_coefficient_val(isl::dim type, int pos, val v) const;\n  inline aff add_constant(val v) const;\n  inline aff add_constant_num_si(int v) const;\n  inline aff add_constant_si(int v) const;\n  inline aff add_dims(isl::dim type, unsigned int n) const;\n  inline aff align_params(space model) const;\n  inline basic_set bind(id id) const;\n  inline aff ceil() const;\n  inline int coefficient_sgn(isl::dim type, int pos) const;\n  inline isl_size dim(isl::dim type) const;\n  inline aff div(aff aff2) const;\n  inline aff drop_dims(isl::dim type, unsigned int first, unsigned int n) const;\n  inline basic_set eq_basic_set(aff aff2) const;\n  inline set eq_set(aff aff2) const;\n  inline val eval(point pnt) const;\n  inline int find_dim_by_name(isl::dim type, const std::string &name) const;\n  inline aff floor() const;\n  inline aff from_range() const;\n  inline basic_set ge_basic_set(aff aff2) const;\n  inline set ge_set(aff aff2) const;\n  inline val get_coefficient_val(isl::dim type, int pos) const;\n  inline val get_constant_val() const;\n  inline val get_denominator_val() const;\n  inline std::string get_dim_name(isl::dim type, unsigned int pos) const;\n  inline aff get_div(int pos) const;\n  inline local_space get_domain_local_space() const;\n  inline space get_domain_space() const;\n  inline uint32_t get_hash() const;\n  inline local_space get_local_space() const;\n  inline space get_space() const;\n  inline aff gist(set context) const;\n  inline aff gist_params(set context) const;\n  inline basic_set gt_basic_set(aff aff2) const;\n  inline set gt_set(aff aff2) const;\n  inline aff insert_dims(isl::dim type, unsigned int first, unsigned int n) const;\n  inline boolean involves_dims(isl::dim type, unsigned int first, unsigned int n) const;\n  inline boolean involves_locals() const;\n  inline boolean is_cst() const;\n  inline boolean is_nan() const;\n  inline basic_set le_basic_set(aff aff2) const;\n  inline set le_set(aff aff2) const;\n  inline basic_set lt_basic_set(aff aff2) const;\n  inline set lt_set(aff aff2) const;\n  inline aff mod(val mod) const;\n  inline aff move_dims(isl::dim dst_type, unsigned int dst_pos, isl::dim src_type, unsigned int src_pos, unsigned int n) const;\n  inline aff mul(aff aff2) const;\n  static inline aff nan_on_domain(local_space ls);\n  static inline aff nan_on_domain_space(space space);\n  inline set ne_set(aff aff2) const;\n  inline aff neg() const;\n  inline basic_set neg_basic_set() const;\n  static inline aff param_on_domain_space_id(space space, id id);\n  inline boolean plain_is_equal(const aff &aff2) const;\n  inline boolean plain_is_zero() const;\n  inline aff project_domain_on_params() const;\n  inline aff pullback(multi_aff ma) const;\n  inline aff pullback_aff(aff aff2) const;\n  inline aff scale(val v) const;\n  inline aff scale_down(val v) const;\n  inline aff scale_down_ui(unsigned int f) const;\n  inline aff set_coefficient_si(isl::dim type, int pos, int v) const;\n  inline aff set_coefficient_val(isl::dim type, int pos, val v) const;\n  inline aff set_constant_si(int v) const;\n  inline aff set_constant_val(val v) const;\n  inline aff set_dim_id(isl::dim type, unsigned int pos, id id) const;\n  inline aff set_tuple_id(isl::dim type, id id) const;\n  inline aff sub(aff aff2) const;\n  inline aff unbind_params_insert_domain(multi_id domain) const;\n  static inline aff val_on_domain_space(space space, val val);\n  static inline aff var_on_domain(local_space ls, isl::dim type, unsigned int pos);\n  inline basic_set zero_basic_set() const;\n  static inline aff zero_on_domain(space space);\n};\n\n// declarations for isl::aff_list\ninline aff_list manage(__isl_take isl_aff_list *ptr);\ninline aff_list manage_copy(__isl_keep isl_aff_list *ptr);\n\nclass aff_list {\n  friend inline aff_list manage(__isl_take isl_aff_list *ptr);\n  friend inline aff_list manage_copy(__isl_keep isl_aff_list *ptr);\n\n  isl_aff_list *ptr = nullptr;\n\n  inline explicit aff_list(__isl_take isl_aff_list *ptr);\n\npublic:\n  inline /* implicit */ aff_list();\n  inline /* implicit */ aff_list(const aff_list &obj);\n  inline /* implicit */ aff_list(std::nullptr_t);\n  inline aff_list &operator=(aff_list obj);\n  inline ~aff_list();\n  inline __isl_give isl_aff_list *copy() const &;\n  inline __isl_give isl_aff_list *copy() && = delete;\n  inline __isl_keep isl_aff_list *get() const;\n  inline __isl_give isl_aff_list *release();\n  inline bool is_null() const;\n  inline explicit operator bool() const;\n  inline ctx get_ctx() const;\n  inline std::string to_str() const;\n  inline void dump() const;\n\n  inline aff_list add(aff el) const;\n  static inline aff_list alloc(ctx ctx, int n);\n  inline aff_list clear() const;\n  inline aff_list concat(aff_list list2) const;\n  inline aff_list drop(unsigned int first, unsigned int n) const;\n  inline stat foreach(const std::function<stat(aff)> &fn) const;\n  static inline aff_list from_aff(aff el);\n  inline aff get_aff(int index) const;\n  inline aff get_at(int index) const;\n  inline aff_list insert(unsigned int pos, aff el) const;\n  inline isl_size n_aff() const;\n  inline aff_list reverse() const;\n  inline aff_list set_aff(int index, aff el) const;\n  inline isl_size size() const;\n  inline aff_list swap(unsigned int pos1, unsigned int pos2) const;\n};\n\n// declarations for isl::ast_build\ninline ast_build manage(__isl_take isl_ast_build *ptr);\ninline ast_build manage_copy(__isl_keep isl_ast_build *ptr);\n\nclass ast_build {\n  friend inline ast_build manage(__isl_take isl_ast_build *ptr);\n  friend inline ast_build manage_copy(__isl_keep isl_ast_build *ptr);\n\n  isl_ast_build *ptr = nullptr;\n\n  inline explicit ast_build(__isl_take isl_ast_build *ptr);\n\npublic:\n  inline /* implicit */ ast_build();\n  inline /* implicit */ ast_build(const ast_build &obj);\n  inline /* implicit */ ast_build(std::nullptr_t);\n  inline explicit ast_build(ctx ctx);\n  inline ast_build &operator=(ast_build obj);\n  inline ~ast_build();\n  inline __isl_give isl_ast_build *copy() const &;\n  inline __isl_give isl_ast_build *copy() && = delete;\n  inline __isl_keep isl_ast_build *get() const;\n  inline __isl_give isl_ast_build *release();\n  inline bool is_null() const;\n  inline explicit operator bool() const;\n  inline ctx get_ctx() const;\n\n  inline ast_expr access_from(multi_pw_aff mpa) const;\n  inline ast_expr access_from(pw_multi_aff pma) const;\n  inline ast_node ast_from_schedule(union_map schedule) const;\n  inline ast_expr call_from(multi_pw_aff mpa) const;\n  inline ast_expr call_from(pw_multi_aff pma) const;\n  inline ast_expr expr_from(pw_aff pa) const;\n  inline ast_expr expr_from(set set) const;\n  static inline ast_build from_context(set set);\n  inline union_map get_schedule() const;\n  inline space get_schedule_space() const;\n  inline ast_node node_from(schedule schedule) const;\n  inline ast_node node_from_schedule_map(union_map schedule) const;\n  inline ast_build restrict(set set) const;\n};\n\n// declarations for isl::ast_expr\ninline ast_expr manage(__isl_take isl_ast_expr *ptr);\ninline ast_expr manage_copy(__isl_keep isl_ast_expr *ptr);\n\nclass ast_expr {\n  friend inline ast_expr manage(__isl_take isl_ast_expr *ptr);\n  friend inline ast_expr manage_copy(__isl_keep isl_ast_expr *ptr);\n\n  isl_ast_expr *ptr = nullptr;\n\n  inline explicit ast_expr(__isl_take isl_ast_expr *ptr);\n\npublic:\n  inline /* implicit */ ast_expr();\n  inline /* implicit */ ast_expr(const ast_expr &obj);\n  inline /* implicit */ ast_expr(std::nullptr_t);\n  inline ast_expr &operator=(ast_expr obj);\n  inline ~ast_expr();\n  inline __isl_give isl_ast_expr *copy() const &;\n  inline __isl_give isl_ast_expr *copy() && = delete;\n  inline __isl_keep isl_ast_expr *get() const;\n  inline __isl_give isl_ast_expr *release();\n  inline bool is_null() const;\n  inline explicit operator bool() const;\n  inline ctx get_ctx() const;\n  inline std::string to_str() const;\n  inline void dump() const;\n\n  inline ast_expr access(ast_expr_list indices) const;\n  inline ast_expr add(ast_expr expr2) const;\n  inline ast_expr address_of() const;\n  inline ast_expr call(ast_expr_list arguments) const;\n  inline ast_expr div(ast_expr expr2) const;\n  inline ast_expr eq(ast_expr expr2) const;\n  static inline ast_expr from_id(id id);\n  static inline ast_expr from_val(val v);\n  inline ast_expr ge(ast_expr expr2) const;\n  inline id get_id() const;\n  inline ast_expr get_op_arg(int pos) const;\n  inline isl_size get_op_n_arg() const;\n  inline val get_val() const;\n  inline ast_expr gt(ast_expr expr2) const;\n  inline id id_get_id() const;\n  inline val int_get_val() const;\n  inline boolean is_equal(const ast_expr &expr2) const;\n  inline ast_expr le(ast_expr expr2) const;\n  inline ast_expr lt(ast_expr expr2) const;\n  inline ast_expr mul(ast_expr expr2) const;\n  inline ast_expr neg() const;\n  inline ast_expr op_get_arg(int pos) const;\n  inline isl_size op_get_n_arg() const;\n  inline ast_expr pdiv_q(ast_expr expr2) const;\n  inline ast_expr pdiv_r(ast_expr expr2) const;\n  inline ast_expr set_op_arg(int pos, ast_expr arg) const;\n  inline ast_expr sub(ast_expr expr2) const;\n  inline ast_expr substitute_ids(id_to_ast_expr id2expr) const;\n  inline std::string to_C_str() const;\n};\n\n// declarations for isl::ast_expr_list\ninline ast_expr_list manage(__isl_take isl_ast_expr_list *ptr);\ninline ast_expr_list manage_copy(__isl_keep isl_ast_expr_list *ptr);\n\nclass ast_expr_list {\n  friend inline ast_expr_list manage(__isl_take isl_ast_expr_list *ptr);\n  friend inline ast_expr_list manage_copy(__isl_keep isl_ast_expr_list *ptr);\n\n  isl_ast_expr_list *ptr = nullptr;\n\n  inline explicit ast_expr_list(__isl_take isl_ast_expr_list *ptr);\n\npublic:\n  inline /* implicit */ ast_expr_list();\n  inline /* implicit */ ast_expr_list(const ast_expr_list &obj);\n  inline /* implicit */ ast_expr_list(std::nullptr_t);\n  inline ast_expr_list &operator=(ast_expr_list obj);\n  inline ~ast_expr_list();\n  inline __isl_give isl_ast_expr_list *copy() const &;\n  inline __isl_give isl_ast_expr_list *copy() && = delete;\n  inline __isl_keep isl_ast_expr_list *get() const;\n  inline __isl_give isl_ast_expr_list *release();\n  inline bool is_null() const;\n  inline explicit operator bool() const;\n  inline ctx get_ctx() const;\n  inline std::string to_str() const;\n  inline void dump() const;\n\n  inline ast_expr_list add(ast_expr el) const;\n  static inline ast_expr_list alloc(ctx ctx, int n);\n  inline ast_expr_list clear() const;\n  inline ast_expr_list concat(ast_expr_list list2) const;\n  inline ast_expr_list drop(unsigned int first, unsigned int n) const;\n  inline stat foreach(const std::function<stat(ast_expr)> &fn) const;\n  static inline ast_expr_list from_ast_expr(ast_expr el);\n  inline ast_expr get_ast_expr(int index) const;\n  inline ast_expr get_at(int index) const;\n  inline ast_expr_list insert(unsigned int pos, ast_expr el) const;\n  inline isl_size n_ast_expr() const;\n  inline ast_expr_list reverse() const;\n  inline ast_expr_list set_ast_expr(int index, ast_expr el) const;\n  inline isl_size size() const;\n  inline ast_expr_list swap(unsigned int pos1, unsigned int pos2) const;\n};\n\n// declarations for isl::ast_node\ninline ast_node manage(__isl_take isl_ast_node *ptr);\ninline ast_node manage_copy(__isl_keep isl_ast_node *ptr);\n\nclass ast_node {\n  friend inline ast_node manage(__isl_take isl_ast_node *ptr);\n  friend inline ast_node manage_copy(__isl_keep isl_ast_node *ptr);\n\n  isl_ast_node *ptr = nullptr;\n\n  inline explicit ast_node(__isl_take isl_ast_node *ptr);\n\npublic:\n  inline /* implicit */ ast_node();\n  inline /* implicit */ ast_node(const ast_node &obj);\n  inline /* implicit */ ast_node(std::nullptr_t);\n  inline ast_node &operator=(ast_node obj);\n  inline ~ast_node();\n  inline __isl_give isl_ast_node *copy() const &;\n  inline __isl_give isl_ast_node *copy() && = delete;\n  inline __isl_keep isl_ast_node *get() const;\n  inline __isl_give isl_ast_node *release();\n  inline bool is_null() const;\n  inline explicit operator bool() const;\n  inline ctx get_ctx() const;\n  inline std::string to_str() const;\n  inline void dump() const;\n\n  static inline ast_node alloc_user(ast_expr expr);\n  inline ast_node_list block_get_children() const;\n  inline ast_node for_get_body() const;\n  inline ast_expr for_get_cond() const;\n  inline ast_expr for_get_inc() const;\n  inline ast_expr for_get_init() const;\n  inline ast_expr for_get_iterator() const;\n  inline boolean for_is_degenerate() const;\n  inline id get_annotation() const;\n  inline ast_expr if_get_cond() const;\n  inline ast_node if_get_else() const;\n  inline ast_node if_get_else_node() const;\n  inline ast_node if_get_then() const;\n  inline ast_node if_get_then_node() const;\n  inline boolean if_has_else() const;\n  inline boolean if_has_else_node() const;\n  inline id mark_get_id() const;\n  inline ast_node mark_get_node() const;\n  inline ast_node set_annotation(id annotation) const;\n  inline std::string to_C_str() const;\n  inline ast_expr user_get_expr() const;\n};\n\n// declarations for isl::ast_node_list\ninline ast_node_list manage(__isl_take isl_ast_node_list *ptr);\ninline ast_node_list manage_copy(__isl_keep isl_ast_node_list *ptr);\n\nclass ast_node_list {\n  friend inline ast_node_list manage(__isl_take isl_ast_node_list *ptr);\n  friend inline ast_node_list manage_copy(__isl_keep isl_ast_node_list *ptr);\n\n  isl_ast_node_list *ptr = nullptr;\n\n  inline explicit ast_node_list(__isl_take isl_ast_node_list *ptr);\n\npublic:\n  inline /* implicit */ ast_node_list();\n  inline /* implicit */ ast_node_list(const ast_node_list &obj);\n  inline /* implicit */ ast_node_list(std::nullptr_t);\n  inline ast_node_list &operator=(ast_node_list obj);\n  inline ~ast_node_list();\n  inline __isl_give isl_ast_node_list *copy() const &;\n  inline __isl_give isl_ast_node_list *copy() && = delete;\n  inline __isl_keep isl_ast_node_list *get() const;\n  inline __isl_give isl_ast_node_list *release();\n  inline bool is_null() const;\n  inline explicit operator bool() const;\n  inline ctx get_ctx() const;\n  inline std::string to_str() const;\n  inline void dump() const;\n\n  inline ast_node_list add(ast_node el) const;\n  static inline ast_node_list alloc(ctx ctx, int n);\n  inline ast_node_list clear() const;\n  inline ast_node_list concat(ast_node_list list2) const;\n  inline ast_node_list drop(unsigned int first, unsigned int n) const;\n  inline stat foreach(const std::function<stat(ast_node)> &fn) const;\n  static inline ast_node_list from_ast_node(ast_node el);\n  inline ast_node get_ast_node(int index) const;\n  inline ast_node get_at(int index) const;\n  inline ast_node_list insert(unsigned int pos, ast_node el) const;\n  inline isl_size n_ast_node() const;\n  inline ast_node_list reverse() const;\n  inline ast_node_list set_ast_node(int index, ast_node el) const;\n  inline isl_size size() const;\n  inline ast_node_list swap(unsigned int pos1, unsigned int pos2) const;\n};\n\n// declarations for isl::basic_map\ninline basic_map manage(__isl_take isl_basic_map *ptr);\ninline basic_map manage_copy(__isl_keep isl_basic_map *ptr);\n\nclass basic_map {\n  friend inline basic_map manage(__isl_take isl_basic_map *ptr);\n  friend inline basic_map manage_copy(__isl_keep isl_basic_map *ptr);\n\n  isl_basic_map *ptr = nullptr;\n\n  inline explicit basic_map(__isl_take isl_basic_map *ptr);\n\npublic:\n  inline /* implicit */ basic_map();\n  inline /* implicit */ basic_map(const basic_map &obj);\n  inline /* implicit */ basic_map(std::nullptr_t);\n  inline explicit basic_map(ctx ctx, const std::string &str);\n  inline basic_map &operator=(basic_map obj);\n  inline ~basic_map();\n  inline __isl_give isl_basic_map *copy() const &;\n  inline __isl_give isl_basic_map *copy() && = delete;\n  inline __isl_keep isl_basic_map *get() const;\n  inline __isl_give isl_basic_map *release();\n  inline bool is_null() const;\n  inline explicit operator bool() const;\n  inline ctx get_ctx() const;\n  inline std::string to_str() const;\n  inline void dump() const;\n\n  inline basic_map add_constraint(constraint constraint) const;\n  inline basic_map add_dims(isl::dim type, unsigned int n) const;\n  inline basic_map affine_hull() const;\n  inline basic_map align_params(space model) const;\n  inline basic_map apply_domain(basic_map bmap2) const;\n  inline basic_map apply_range(basic_map bmap2) const;\n  inline boolean can_curry() const;\n  inline boolean can_uncurry() const;\n  inline boolean can_zip() const;\n  inline basic_map curry() const;\n  inline basic_set deltas() const;\n  inline basic_map deltas_map() const;\n  inline basic_map detect_equalities() const;\n  inline isl_size dim(isl::dim type) const;\n  inline basic_set domain() const;\n  inline basic_map domain_map() const;\n  inline basic_map domain_product(basic_map bmap2) const;\n  inline basic_map drop_constraints_involving_dims(isl::dim type, unsigned int first, unsigned int n) const;\n  inline basic_map drop_constraints_not_involving_dims(isl::dim type, unsigned int first, unsigned int n) const;\n  inline basic_map drop_unused_params() const;\n  inline basic_map eliminate(isl::dim type, unsigned int first, unsigned int n) const;\n  static inline basic_map empty(space space);\n  static inline basic_map equal(space space, unsigned int n_equal);\n  inline mat equalities_matrix(isl::dim c1, isl::dim c2, isl::dim c3, isl::dim c4, isl::dim c5) const;\n  inline basic_map equate(isl::dim type1, int pos1, isl::dim type2, int pos2) const;\n  inline int find_dim_by_name(isl::dim type, const std::string &name) const;\n  inline basic_map fix_si(isl::dim type, unsigned int pos, int value) const;\n  inline basic_map fix_val(isl::dim type, unsigned int pos, val v) const;\n  inline basic_map flat_product(basic_map bmap2) const;\n  inline basic_map flat_range_product(basic_map bmap2) const;\n  inline basic_map flatten() const;\n  inline basic_map flatten_domain() const;\n  inline basic_map flatten_range() const;\n  inline stat foreach_constraint(const std::function<stat(constraint)> &fn) const;\n  static inline basic_map from_aff(aff aff);\n  static inline basic_map from_aff_list(space domain_space, aff_list list);\n  static inline basic_map from_constraint(constraint constraint);\n  static inline basic_map from_domain(basic_set bset);\n  static inline basic_map from_domain_and_range(basic_set domain, basic_set range);\n  static inline basic_map from_multi_aff(multi_aff maff);\n  static inline basic_map from_qpolynomial(qpolynomial qp);\n  static inline basic_map from_range(basic_set bset);\n  inline constraint_list get_constraint_list() const;\n  inline std::string get_dim_name(isl::dim type, unsigned int pos) const;\n  inline aff get_div(int pos) const;\n  inline local_space get_local_space() const;\n  inline space get_space() const;\n  inline std::string get_tuple_name(isl::dim type) const;\n  inline basic_map gist(basic_map context) const;\n  inline basic_map gist_domain(basic_set context) const;\n  inline boolean has_dim_id(isl::dim type, unsigned int pos) const;\n  static inline basic_map identity(space space);\n  inline boolean image_is_bounded() const;\n  inline mat inequalities_matrix(isl::dim c1, isl::dim c2, isl::dim c3, isl::dim c4, isl::dim c5) const;\n  inline basic_map insert_dims(isl::dim type, unsigned int pos, unsigned int n) const;\n  inline basic_map intersect(basic_map bmap2) const;\n  inline basic_map intersect_domain(basic_set bset) const;\n  inline basic_map intersect_range(basic_set bset) const;\n  inline boolean involves_dims(isl::dim type, unsigned int first, unsigned int n) const;\n  inline boolean is_disjoint(const basic_map &bmap2) const;\n  inline boolean is_empty() const;\n  inline boolean is_equal(const basic_map &bmap2) const;\n  inline boolean is_rational() const;\n  inline boolean is_single_valued() const;\n  inline boolean is_strict_subset(const basic_map &bmap2) const;\n  inline boolean is_subset(const basic_map &bmap2) const;\n  inline boolean is_universe() const;\n  static inline basic_map less_at(space space, unsigned int pos);\n  inline map lexmax() const;\n  inline map lexmin() const;\n  inline pw_multi_aff lexmin_pw_multi_aff() const;\n  inline basic_map lower_bound_si(isl::dim type, unsigned int pos, int value) const;\n  static inline basic_map more_at(space space, unsigned int pos);\n  inline basic_map move_dims(isl::dim dst_type, unsigned int dst_pos, isl::dim src_type, unsigned int src_pos, unsigned int n) const;\n  inline isl_size n_constraint() const;\n  static inline basic_map nat_universe(space space);\n  inline basic_map neg() const;\n  inline basic_map order_ge(isl::dim type1, int pos1, isl::dim type2, int pos2) const;\n  inline basic_map order_gt(isl::dim type1, int pos1, isl::dim type2, int pos2) const;\n  inline val plain_get_val_if_fixed(isl::dim type, unsigned int pos) const;\n  inline boolean plain_is_empty() const;\n  inline boolean plain_is_universe() const;\n  inline basic_map preimage_domain_multi_aff(multi_aff ma) const;\n  inline basic_map preimage_range_multi_aff(multi_aff ma) const;\n  inline basic_map product(basic_map bmap2) const;\n  inline basic_map project_out(isl::dim type, unsigned int first, unsigned int n) const;\n  inline basic_set range() const;\n  inline basic_map range_map() const;\n  inline basic_map range_product(basic_map bmap2) const;\n  inline basic_map remove_dims(isl::dim type, unsigned int first, unsigned int n) const;\n  inline basic_map remove_divs() const;\n  inline basic_map remove_divs_involving_dims(isl::dim type, unsigned int first, unsigned int n) const;\n  inline basic_map remove_redundancies() const;\n  inline basic_map reverse() const;\n  inline basic_map sample() const;\n  inline basic_map set_tuple_id(isl::dim type, id id) const;\n  inline basic_map set_tuple_name(isl::dim type, const std::string &s) const;\n  inline basic_map sum(basic_map bmap2) const;\n  inline basic_map uncurry() const;\n  inline map unite(basic_map bmap2) const;\n  static inline basic_map universe(space space);\n  inline basic_map upper_bound_si(isl::dim type, unsigned int pos, int value) const;\n  inline basic_set wrap() const;\n  inline basic_map zip() const;\n};\n\n// declarations for isl::basic_map_list\ninline basic_map_list manage(__isl_take isl_basic_map_list *ptr);\ninline basic_map_list manage_copy(__isl_keep isl_basic_map_list *ptr);\n\nclass basic_map_list {\n  friend inline basic_map_list manage(__isl_take isl_basic_map_list *ptr);\n  friend inline basic_map_list manage_copy(__isl_keep isl_basic_map_list *ptr);\n\n  isl_basic_map_list *ptr = nullptr;\n\n  inline explicit basic_map_list(__isl_take isl_basic_map_list *ptr);\n\npublic:\n  inline /* implicit */ basic_map_list();\n  inline /* implicit */ basic_map_list(const basic_map_list &obj);\n  inline /* implicit */ basic_map_list(std::nullptr_t);\n  inline basic_map_list &operator=(basic_map_list obj);\n  inline ~basic_map_list();\n  inline __isl_give isl_basic_map_list *copy() const &;\n  inline __isl_give isl_basic_map_list *copy() && = delete;\n  inline __isl_keep isl_basic_map_list *get() const;\n  inline __isl_give isl_basic_map_list *release();\n  inline bool is_null() const;\n  inline explicit operator bool() const;\n  inline ctx get_ctx() const;\n  inline std::string to_str() const;\n  inline void dump() const;\n\n  inline basic_map_list add(basic_map el) const;\n  static inline basic_map_list alloc(ctx ctx, int n);\n  inline basic_map_list clear() const;\n  inline basic_map_list concat(basic_map_list list2) const;\n  inline basic_map_list drop(unsigned int first, unsigned int n) const;\n  inline stat foreach(const std::function<stat(basic_map)> &fn) const;\n  static inline basic_map_list from_basic_map(basic_map el);\n  inline basic_map get_at(int index) const;\n  inline basic_map get_basic_map(int index) const;\n  inline basic_map_list insert(unsigned int pos, basic_map el) const;\n  inline isl_size n_basic_map() const;\n  inline basic_map_list reverse() const;\n  inline basic_map_list set_basic_map(int index, basic_map el) const;\n  inline isl_size size() const;\n  inline basic_map_list swap(unsigned int pos1, unsigned int pos2) const;\n};\n\n// declarations for isl::basic_set\ninline basic_set manage(__isl_take isl_basic_set *ptr);\ninline basic_set manage_copy(__isl_keep isl_basic_set *ptr);\n\nclass basic_set {\n  friend inline basic_set manage(__isl_take isl_basic_set *ptr);\n  friend inline basic_set manage_copy(__isl_keep isl_basic_set *ptr);\n\n  isl_basic_set *ptr = nullptr;\n\n  inline explicit basic_set(__isl_take isl_basic_set *ptr);\n\npublic:\n  inline /* implicit */ basic_set();\n  inline /* implicit */ basic_set(const basic_set &obj);\n  inline /* implicit */ basic_set(std::nullptr_t);\n  inline /* implicit */ basic_set(point pnt);\n  inline explicit basic_set(ctx ctx, const std::string &str);\n  inline basic_set &operator=(basic_set obj);\n  inline ~basic_set();\n  inline __isl_give isl_basic_set *copy() const &;\n  inline __isl_give isl_basic_set *copy() && = delete;\n  inline __isl_keep isl_basic_set *get() const;\n  inline __isl_give isl_basic_set *release();\n  inline bool is_null() const;\n  inline explicit operator bool() const;\n  inline ctx get_ctx() const;\n  inline std::string to_str() const;\n  inline void dump() const;\n\n  inline basic_set affine_hull() const;\n  inline basic_set align_params(space model) const;\n  inline basic_set apply(basic_map bmap) const;\n  static inline basic_set box_from_points(point pnt1, point pnt2);\n  inline basic_set coefficients() const;\n  inline basic_set detect_equalities() const;\n  inline isl_size dim(isl::dim type) const;\n  inline val dim_max_val(int pos) const;\n  inline basic_set drop_constraints_involving_dims(isl::dim type, unsigned int first, unsigned int n) const;\n  inline basic_set drop_constraints_not_involving_dims(isl::dim type, unsigned int first, unsigned int n) const;\n  inline basic_set drop_unused_params() const;\n  inline basic_set eliminate(isl::dim type, unsigned int first, unsigned int n) const;\n  static inline basic_set empty(space space);\n  inline mat equalities_matrix(isl::dim c1, isl::dim c2, isl::dim c3, isl::dim c4) const;\n  inline basic_set fix_si(isl::dim type, unsigned int pos, int value) const;\n  inline basic_set fix_val(isl::dim type, unsigned int pos, val v) const;\n  inline basic_set flat_product(basic_set bset2) const;\n  inline basic_set flatten() const;\n  inline stat foreach_bound_pair(isl::dim type, unsigned int pos, const std::function<stat(constraint, constraint, basic_set)> &fn) const;\n  inline stat foreach_constraint(const std::function<stat(constraint)> &fn) const;\n  static inline basic_set from_constraint(constraint constraint);\n  static inline basic_set from_multi_aff(multi_aff ma);\n  inline basic_set from_params() const;\n  inline constraint_list get_constraint_list() const;\n  inline id get_dim_id(isl::dim type, unsigned int pos) const;\n  inline std::string get_dim_name(isl::dim type, unsigned int pos) const;\n  inline aff get_div(int pos) const;\n  inline local_space get_local_space() const;\n  inline space get_space() const;\n  inline std::string get_tuple_name() const;\n  inline basic_set gist(basic_set context) const;\n  inline mat inequalities_matrix(isl::dim c1, isl::dim c2, isl::dim c3, isl::dim c4) const;\n  inline basic_set insert_dims(isl::dim type, unsigned int pos, unsigned int n) const;\n  inline basic_set intersect(basic_set bset2) const;\n  inline basic_set intersect_params(basic_set bset2) const;\n  inline boolean involves_dims(isl::dim type, unsigned int first, unsigned int n) const;\n  inline boolean is_bounded() const;\n  inline boolean is_disjoint(const basic_set &bset2) const;\n  inline boolean is_empty() const;\n  inline boolean is_equal(const basic_set &bset2) const;\n  inline int is_rational() const;\n  inline boolean is_subset(const basic_set &bset2) const;\n  inline boolean is_universe() const;\n  inline boolean is_wrapping() const;\n  inline set lexmax() const;\n  inline set lexmin() const;\n  inline basic_set lower_bound_val(isl::dim type, unsigned int pos, val value) const;\n  inline val max_val(const aff &obj) const;\n  inline basic_set move_dims(isl::dim dst_type, unsigned int dst_pos, isl::dim src_type, unsigned int src_pos, unsigned int n) const;\n  inline isl_size n_constraint() const;\n  inline isl_size n_dim() const;\n  static inline basic_set nat_universe(space space);\n  inline basic_set neg() const;\n  inline basic_set params() const;\n  inline boolean plain_is_empty() const;\n  inline boolean plain_is_equal(const basic_set &bset2) const;\n  inline boolean plain_is_universe() const;\n  static inline basic_set positive_orthant(space space);\n  inline basic_set preimage_multi_aff(multi_aff ma) const;\n  inline basic_set project_out(isl::dim type, unsigned int first, unsigned int n) const;\n  inline mat reduced_basis() const;\n  inline basic_set remove_dims(isl::dim type, unsigned int first, unsigned int n) const;\n  inline basic_set remove_divs() const;\n  inline basic_set remove_divs_involving_dims(isl::dim type, unsigned int first, unsigned int n) const;\n  inline basic_set remove_redundancies() const;\n  inline basic_set remove_unknown_divs() const;\n  inline basic_set sample() const;\n  inline point sample_point() const;\n  inline basic_set set_tuple_id(id id) const;\n  inline basic_set set_tuple_name(const std::string &s) const;\n  inline basic_set solutions() const;\n  inline set unite(basic_set bset2) const;\n  static inline basic_set universe(space space);\n  inline basic_map unwrap() const;\n  inline basic_set upper_bound_val(isl::dim type, unsigned int pos, val value) const;\n};\n\n// declarations for isl::basic_set_list\ninline basic_set_list manage(__isl_take isl_basic_set_list *ptr);\ninline basic_set_list manage_copy(__isl_keep isl_basic_set_list *ptr);\n\nclass basic_set_list {\n  friend inline basic_set_list manage(__isl_take isl_basic_set_list *ptr);\n  friend inline basic_set_list manage_copy(__isl_keep isl_basic_set_list *ptr);\n\n  isl_basic_set_list *ptr = nullptr;\n\n  inline explicit basic_set_list(__isl_take isl_basic_set_list *ptr);\n\npublic:\n  inline /* implicit */ basic_set_list();\n  inline /* implicit */ basic_set_list(const basic_set_list &obj);\n  inline /* implicit */ basic_set_list(std::nullptr_t);\n  inline basic_set_list &operator=(basic_set_list obj);\n  inline ~basic_set_list();\n  inline __isl_give isl_basic_set_list *copy() const &;\n  inline __isl_give isl_basic_set_list *copy() && = delete;\n  inline __isl_keep isl_basic_set_list *get() const;\n  inline __isl_give isl_basic_set_list *release();\n  inline bool is_null() const;\n  inline explicit operator bool() const;\n  inline ctx get_ctx() const;\n  inline std::string to_str() const;\n  inline void dump() const;\n\n  inline basic_set_list add(basic_set el) const;\n  static inline basic_set_list alloc(ctx ctx, int n);\n  inline basic_set_list clear() const;\n  inline basic_set_list coefficients() const;\n  inline basic_set_list concat(basic_set_list list2) const;\n  inline basic_set_list drop(unsigned int first, unsigned int n) const;\n  inline stat foreach(const std::function<stat(basic_set)> &fn) const;\n  static inline basic_set_list from_basic_set(basic_set el);\n  inline basic_set get_at(int index) const;\n  inline basic_set get_basic_set(int index) const;\n  inline basic_set_list insert(unsigned int pos, basic_set el) const;\n  inline isl_size n_basic_set() const;\n  inline basic_set_list reverse() const;\n  inline basic_set_list set_basic_set(int index, basic_set el) const;\n  inline isl_size size() const;\n  inline basic_set_list swap(unsigned int pos1, unsigned int pos2) const;\n};\n\n// declarations for isl::constraint\ninline constraint manage(__isl_take isl_constraint *ptr);\ninline constraint manage_copy(__isl_keep isl_constraint *ptr);\n\nclass constraint {\n  friend inline constraint manage(__isl_take isl_constraint *ptr);\n  friend inline constraint manage_copy(__isl_keep isl_constraint *ptr);\n\n  isl_constraint *ptr = nullptr;\n\n  inline explicit constraint(__isl_take isl_constraint *ptr);\n\npublic:\n  inline /* implicit */ constraint();\n  inline /* implicit */ constraint(const constraint &obj);\n  inline /* implicit */ constraint(std::nullptr_t);\n  inline constraint &operator=(constraint obj);\n  inline ~constraint();\n  inline __isl_give isl_constraint *copy() const &;\n  inline __isl_give isl_constraint *copy() && = delete;\n  inline __isl_keep isl_constraint *get() const;\n  inline __isl_give isl_constraint *release();\n  inline bool is_null() const;\n  inline explicit operator bool() const;\n  inline ctx get_ctx() const;\n  inline void dump() const;\n\n  static inline constraint alloc_equality(local_space ls);\n  static inline constraint alloc_inequality(local_space ls);\n  inline int cmp_last_non_zero(const constraint &c2) const;\n  inline aff get_aff() const;\n  inline aff get_bound(isl::dim type, int pos) const;\n  inline val get_coefficient_val(isl::dim type, int pos) const;\n  inline val get_constant_val() const;\n  inline std::string get_dim_name(isl::dim type, unsigned int pos) const;\n  inline aff get_div(int pos) const;\n  inline local_space get_local_space() const;\n  inline space get_space() const;\n  inline boolean involves_dims(isl::dim type, unsigned int first, unsigned int n) const;\n  inline boolean is_div_constraint() const;\n  inline boolean is_lower_bound(isl::dim type, unsigned int pos) const;\n  inline boolean is_upper_bound(isl::dim type, unsigned int pos) const;\n  inline int plain_cmp(const constraint &c2) const;\n  inline constraint set_coefficient_si(isl::dim type, int pos, int v) const;\n  inline constraint set_coefficient_val(isl::dim type, int pos, val v) const;\n  inline constraint set_constant_si(int v) const;\n  inline constraint set_constant_val(val v) const;\n};\n\n// declarations for isl::constraint_list\ninline constraint_list manage(__isl_take isl_constraint_list *ptr);\ninline constraint_list manage_copy(__isl_keep isl_constraint_list *ptr);\n\nclass constraint_list {\n  friend inline constraint_list manage(__isl_take isl_constraint_list *ptr);\n  friend inline constraint_list manage_copy(__isl_keep isl_constraint_list *ptr);\n\n  isl_constraint_list *ptr = nullptr;\n\n  inline explicit constraint_list(__isl_take isl_constraint_list *ptr);\n\npublic:\n  inline /* implicit */ constraint_list();\n  inline /* implicit */ constraint_list(const constraint_list &obj);\n  inline /* implicit */ constraint_list(std::nullptr_t);\n  inline constraint_list &operator=(constraint_list obj);\n  inline ~constraint_list();\n  inline __isl_give isl_constraint_list *copy() const &;\n  inline __isl_give isl_constraint_list *copy() && = delete;\n  inline __isl_keep isl_constraint_list *get() const;\n  inline __isl_give isl_constraint_list *release();\n  inline bool is_null() const;\n  inline explicit operator bool() const;\n  inline ctx get_ctx() const;\n  inline std::string to_str() const;\n  inline void dump() const;\n\n  inline constraint_list add(constraint el) const;\n  static inline constraint_list alloc(ctx ctx, int n);\n  inline constraint_list clear() const;\n  inline constraint_list concat(constraint_list list2) const;\n  inline constraint_list drop(unsigned int first, unsigned int n) const;\n  inline stat foreach(const std::function<stat(constraint)> &fn) const;\n  static inline constraint_list from_constraint(constraint el);\n  inline constraint get_at(int index) const;\n  inline constraint get_constraint(int index) const;\n  inline constraint_list insert(unsigned int pos, constraint el) const;\n  inline isl_size n_constraint() const;\n  inline constraint_list reverse() const;\n  inline constraint_list set_constraint(int index, constraint el) const;\n  inline isl_size size() const;\n  inline constraint_list swap(unsigned int pos1, unsigned int pos2) const;\n};\n\n// declarations for isl::fixed_box\ninline fixed_box manage(__isl_take isl_fixed_box *ptr);\ninline fixed_box manage_copy(__isl_keep isl_fixed_box *ptr);\n\nclass fixed_box {\n  friend inline fixed_box manage(__isl_take isl_fixed_box *ptr);\n  friend inline fixed_box manage_copy(__isl_keep isl_fixed_box *ptr);\n\n  isl_fixed_box *ptr = nullptr;\n\n  inline explicit fixed_box(__isl_take isl_fixed_box *ptr);\n\npublic:\n  inline /* implicit */ fixed_box();\n  inline /* implicit */ fixed_box(const fixed_box &obj);\n  inline /* implicit */ fixed_box(std::nullptr_t);\n  inline fixed_box &operator=(fixed_box obj);\n  inline ~fixed_box();\n  inline __isl_give isl_fixed_box *copy() const &;\n  inline __isl_give isl_fixed_box *copy() && = delete;\n  inline __isl_keep isl_fixed_box *get() const;\n  inline __isl_give isl_fixed_box *release();\n  inline bool is_null() const;\n  inline explicit operator bool() const;\n  inline ctx get_ctx() const;\n  inline std::string to_str() const;\n  inline void dump() const;\n\n  inline multi_aff get_offset() const;\n  inline multi_val get_size() const;\n  inline space get_space() const;\n  inline boolean is_valid() const;\n};\n\n// declarations for isl::id\ninline id manage(__isl_take isl_id *ptr);\ninline id manage_copy(__isl_keep isl_id *ptr);\n\nclass id {\n  friend inline id manage(__isl_take isl_id *ptr);\n  friend inline id manage_copy(__isl_keep isl_id *ptr);\n\n  isl_id *ptr = nullptr;\n\n  inline explicit id(__isl_take isl_id *ptr);\n\npublic:\n  inline /* implicit */ id();\n  inline /* implicit */ id(const id &obj);\n  inline /* implicit */ id(std::nullptr_t);\n  inline explicit id(ctx ctx, const std::string &str);\n  inline id &operator=(id obj);\n  inline ~id();\n  inline __isl_give isl_id *copy() const &;\n  inline __isl_give isl_id *copy() && = delete;\n  inline __isl_keep isl_id *get() const;\n  inline __isl_give isl_id *release();\n  inline bool is_null() const;\n  inline explicit operator bool() const;\n  inline ctx get_ctx() const;\n  inline std::string to_str() const;\n  inline void dump() const;\n\n  static inline id alloc(ctx ctx, const std::string &name, void * user);\n  inline uint32_t get_hash() const;\n  inline std::string get_name() const;\n  inline void * get_user() const;\n};\n\n// declarations for isl::id_list\ninline id_list manage(__isl_take isl_id_list *ptr);\ninline id_list manage_copy(__isl_keep isl_id_list *ptr);\n\nclass id_list {\n  friend inline id_list manage(__isl_take isl_id_list *ptr);\n  friend inline id_list manage_copy(__isl_keep isl_id_list *ptr);\n\n  isl_id_list *ptr = nullptr;\n\n  inline explicit id_list(__isl_take isl_id_list *ptr);\n\npublic:\n  inline /* implicit */ id_list();\n  inline /* implicit */ id_list(const id_list &obj);\n  inline /* implicit */ id_list(std::nullptr_t);\n  inline id_list &operator=(id_list obj);\n  inline ~id_list();\n  inline __isl_give isl_id_list *copy() const &;\n  inline __isl_give isl_id_list *copy() && = delete;\n  inline __isl_keep isl_id_list *get() const;\n  inline __isl_give isl_id_list *release();\n  inline bool is_null() const;\n  inline explicit operator bool() const;\n  inline ctx get_ctx() const;\n  inline std::string to_str() const;\n  inline void dump() const;\n\n  inline id_list add(id el) const;\n  static inline id_list alloc(ctx ctx, int n);\n  inline id_list clear() const;\n  inline id_list concat(id_list list2) const;\n  inline id_list drop(unsigned int first, unsigned int n) const;\n  inline stat foreach(const std::function<stat(id)> &fn) const;\n  static inline id_list from_id(id el);\n  inline id get_at(int index) const;\n  inline id get_id(int index) const;\n  inline id_list insert(unsigned int pos, id el) const;\n  inline isl_size n_id() const;\n  inline id_list reverse() const;\n  inline id_list set_id(int index, id el) const;\n  inline isl_size size() const;\n  inline id_list swap(unsigned int pos1, unsigned int pos2) const;\n};\n\n// declarations for isl::id_to_ast_expr\ninline id_to_ast_expr manage(__isl_take isl_id_to_ast_expr *ptr);\ninline id_to_ast_expr manage_copy(__isl_keep isl_id_to_ast_expr *ptr);\n\nclass id_to_ast_expr {\n  friend inline id_to_ast_expr manage(__isl_take isl_id_to_ast_expr *ptr);\n  friend inline id_to_ast_expr manage_copy(__isl_keep isl_id_to_ast_expr *ptr);\n\n  isl_id_to_ast_expr *ptr = nullptr;\n\n  inline explicit id_to_ast_expr(__isl_take isl_id_to_ast_expr *ptr);\n\npublic:\n  inline /* implicit */ id_to_ast_expr();\n  inline /* implicit */ id_to_ast_expr(const id_to_ast_expr &obj);\n  inline /* implicit */ id_to_ast_expr(std::nullptr_t);\n  inline id_to_ast_expr &operator=(id_to_ast_expr obj);\n  inline ~id_to_ast_expr();\n  inline __isl_give isl_id_to_ast_expr *copy() const &;\n  inline __isl_give isl_id_to_ast_expr *copy() && = delete;\n  inline __isl_keep isl_id_to_ast_expr *get() const;\n  inline __isl_give isl_id_to_ast_expr *release();\n  inline bool is_null() const;\n  inline explicit operator bool() const;\n  inline ctx get_ctx() const;\n  inline void dump() const;\n\n  static inline id_to_ast_expr alloc(ctx ctx, int min_size);\n  inline id_to_ast_expr drop(id key) const;\n  inline stat foreach(const std::function<stat(id, ast_expr)> &fn) const;\n  inline ast_expr get(id key) const;\n  inline boolean has(const id &key) const;\n  inline id_to_ast_expr set(id key, ast_expr val) const;\n};\n\n// declarations for isl::local_space\ninline local_space manage(__isl_take isl_local_space *ptr);\ninline local_space manage_copy(__isl_keep isl_local_space *ptr);\n\nclass local_space {\n  friend inline local_space manage(__isl_take isl_local_space *ptr);\n  friend inline local_space manage_copy(__isl_keep isl_local_space *ptr);\n\n  isl_local_space *ptr = nullptr;\n\n  inline explicit local_space(__isl_take isl_local_space *ptr);\n\npublic:\n  inline /* implicit */ local_space();\n  inline /* implicit */ local_space(const local_space &obj);\n  inline /* implicit */ local_space(std::nullptr_t);\n  inline explicit local_space(space space);\n  inline local_space &operator=(local_space obj);\n  inline ~local_space();\n  inline __isl_give isl_local_space *copy() const &;\n  inline __isl_give isl_local_space *copy() && = delete;\n  inline __isl_keep isl_local_space *get() const;\n  inline __isl_give isl_local_space *release();\n  inline bool is_null() const;\n  inline explicit operator bool() const;\n  inline ctx get_ctx() const;\n  inline void dump() const;\n\n  inline local_space add_dims(isl::dim type, unsigned int n) const;\n  inline isl_size dim(isl::dim type) const;\n  inline local_space domain() const;\n  inline local_space drop_dims(isl::dim type, unsigned int first, unsigned int n) const;\n  inline int find_dim_by_name(isl::dim type, const std::string &name) const;\n  inline local_space flatten_domain() const;\n  inline local_space flatten_range() const;\n  inline local_space from_domain() const;\n  inline id get_dim_id(isl::dim type, unsigned int pos) const;\n  inline std::string get_dim_name(isl::dim type, unsigned int pos) const;\n  inline aff get_div(int pos) const;\n  inline space get_space() const;\n  inline boolean has_dim_id(isl::dim type, unsigned int pos) const;\n  inline boolean has_dim_name(isl::dim type, unsigned int pos) const;\n  inline local_space insert_dims(isl::dim type, unsigned int first, unsigned int n) const;\n  inline local_space intersect(local_space ls2) const;\n  inline boolean is_equal(const local_space &ls2) const;\n  inline boolean is_params() const;\n  inline boolean is_set() const;\n  inline local_space range() const;\n  inline local_space set_dim_id(isl::dim type, unsigned int pos, id id) const;\n  inline local_space set_from_params() const;\n  inline local_space set_tuple_id(isl::dim type, id id) const;\n  inline local_space wrap() const;\n};\n\n// declarations for isl::map\ninline map manage(__isl_take isl_map *ptr);\ninline map manage_copy(__isl_keep isl_map *ptr);\n\nclass map {\n  friend inline map manage(__isl_take isl_map *ptr);\n  friend inline map manage_copy(__isl_keep isl_map *ptr);\n\n  isl_map *ptr = nullptr;\n\n  inline explicit map(__isl_take isl_map *ptr);\n\npublic:\n  inline /* implicit */ map();\n  inline /* implicit */ map(const map &obj);\n  inline /* implicit */ map(std::nullptr_t);\n  inline /* implicit */ map(basic_map bmap);\n  inline explicit map(ctx ctx, const std::string &str);\n  inline map &operator=(map obj);\n  inline ~map();\n  inline __isl_give isl_map *copy() const &;\n  inline __isl_give isl_map *copy() && = delete;\n  inline __isl_keep isl_map *get() const;\n  inline __isl_give isl_map *release();\n  inline bool is_null() const;\n  inline explicit operator bool() const;\n  inline ctx get_ctx() const;\n  inline std::string to_str() const;\n  inline void dump() const;\n\n  inline map add_constraint(constraint constraint) const;\n  inline map add_dims(isl::dim type, unsigned int n) const;\n  inline basic_map affine_hull() const;\n  inline map align_params(space model) const;\n  inline map apply_domain(map map2) const;\n  inline map apply_range(map map2) const;\n  inline set bind_domain(multi_id tuple) const;\n  inline set bind_range(multi_id tuple) const;\n  inline boolean can_curry() const;\n  inline boolean can_range_curry() const;\n  inline boolean can_uncurry() const;\n  inline boolean can_zip() const;\n  inline map coalesce() const;\n  inline map complement() const;\n  inline basic_map convex_hull() const;\n  inline map curry() const;\n  inline set deltas() const;\n  inline map deltas_map() const;\n  inline map detect_equalities() const;\n  inline isl_size dim(isl::dim type) const;\n  inline pw_aff dim_max(int pos) const;\n  inline pw_aff dim_min(int pos) const;\n  inline set domain() const;\n  inline map domain_factor_domain() const;\n  inline map domain_factor_range() const;\n  inline boolean domain_is_wrapping() const;\n  inline map domain_map() const;\n  inline map domain_product(map map2) const;\n  inline map drop_constraints_involving_dims(isl::dim type, unsigned int first, unsigned int n) const;\n  inline map drop_constraints_not_involving_dims(isl::dim type, unsigned int first, unsigned int n) const;\n  inline map drop_unused_params() const;\n  inline map eliminate(isl::dim type, unsigned int first, unsigned int n) const;\n  static inline map empty(space space);\n  inline map eq_at(multi_pw_aff mpa) const;\n  inline map equate(isl::dim type1, int pos1, isl::dim type2, int pos2) const;\n  inline map factor_domain() const;\n  inline map factor_range() const;\n  inline int find_dim_by_id(isl::dim type, const id &id) const;\n  inline int find_dim_by_name(isl::dim type, const std::string &name) const;\n  inline map fix_si(isl::dim type, unsigned int pos, int value) const;\n  inline map fix_val(isl::dim type, unsigned int pos, val v) const;\n  inline map fixed_power_val(val exp) const;\n  inline map flat_domain_product(map map2) const;\n  inline map flat_product(map map2) const;\n  inline map flat_range_product(map map2) const;\n  inline map flatten() const;\n  inline map flatten_domain() const;\n  inline map flatten_range() const;\n  inline map floordiv_val(val d) const;\n  inline stat foreach_basic_map(const std::function<stat(basic_map)> &fn) const;\n  static inline map from_aff(aff aff);\n  static inline map from_domain(set set);\n  static inline map from_domain_and_range(set domain, set range);\n  static inline map from_multi_aff(multi_aff maff);\n  static inline map from_multi_pw_aff(multi_pw_aff mpa);\n  static inline map from_pw_aff(pw_aff pwaff);\n  static inline map from_pw_multi_aff(pw_multi_aff pma);\n  static inline map from_range(set set);\n  static inline map from_union_map(union_map umap);\n  inline basic_map_list get_basic_map_list() const;\n  inline id get_dim_id(isl::dim type, unsigned int pos) const;\n  inline std::string get_dim_name(isl::dim type, unsigned int pos) const;\n  inline uint32_t get_hash() const;\n  inline fixed_box get_range_simple_fixed_box_hull() const;\n  inline space get_space() const;\n  inline id get_tuple_id(isl::dim type) const;\n  inline std::string get_tuple_name(isl::dim type) const;\n  inline map gist(map context) const;\n  inline map gist_basic_map(basic_map context) const;\n  inline map gist_domain(set context) const;\n  inline map gist_params(set context) const;\n  inline map gist_range(set context) const;\n  inline boolean has_dim_id(isl::dim type, unsigned int pos) const;\n  inline boolean has_dim_name(isl::dim type, unsigned int pos) const;\n  inline boolean has_equal_space(const map &map2) const;\n  inline boolean has_tuple_id(isl::dim type) const;\n  inline boolean has_tuple_name(isl::dim type) const;\n  static inline map identity(space space);\n  inline map insert_dims(isl::dim type, unsigned int pos, unsigned int n) const;\n  inline map intersect(map map2) const;\n  inline map intersect_domain(set set) const;\n  inline map intersect_domain_factor_domain(map factor) const;\n  inline map intersect_domain_factor_range(map factor) const;\n  inline map intersect_params(set params) const;\n  inline map intersect_range(set set) const;\n  inline map intersect_range_factor_domain(map factor) const;\n  inline map intersect_range_factor_range(map factor) const;\n  inline boolean involves_dims(isl::dim type, unsigned int first, unsigned int n) const;\n  inline boolean is_bijective() const;\n  inline boolean is_disjoint(const map &map2) const;\n  inline boolean is_empty() const;\n  inline boolean is_equal(const map &map2) const;\n  inline boolean is_identity() const;\n  inline boolean is_injective() const;\n  inline boolean is_product() const;\n  inline boolean is_single_valued() const;\n  inline boolean is_strict_subset(const map &map2) const;\n  inline boolean is_subset(const map &map2) const;\n  inline int is_translation() const;\n  static inline map lex_ge(space set_space);\n  inline map lex_ge_at(multi_pw_aff mpa) const;\n  static inline map lex_ge_first(space space, unsigned int n);\n  inline map lex_ge_map(map map2) const;\n  static inline map lex_gt(space set_space);\n  inline map lex_gt_at(multi_pw_aff mpa) const;\n  static inline map lex_gt_first(space space, unsigned int n);\n  inline map lex_gt_map(map map2) const;\n  static inline map lex_le(space set_space);\n  inline map lex_le_at(multi_pw_aff mpa) const;\n  static inline map lex_le_first(space space, unsigned int n);\n  inline map lex_le_map(map map2) const;\n  static inline map lex_lt(space set_space);\n  inline map lex_lt_at(multi_pw_aff mpa) const;\n  static inline map lex_lt_first(space space, unsigned int n);\n  inline map lex_lt_map(map map2) const;\n  inline map lexmax() const;\n  inline pw_multi_aff lexmax_pw_multi_aff() const;\n  inline map lexmin() const;\n  inline pw_multi_aff lexmin_pw_multi_aff() const;\n  inline map lower_bound(multi_pw_aff lower) const;\n  inline map lower_bound_si(isl::dim type, unsigned int pos, int value) const;\n  inline map lower_bound_val(isl::dim type, unsigned int pos, val value) const;\n  inline multi_pw_aff max_multi_pw_aff() const;\n  inline multi_pw_aff min_multi_pw_aff() const;\n  inline map move_dims(isl::dim dst_type, unsigned int dst_pos, isl::dim src_type, unsigned int src_pos, unsigned int n) const;\n  inline isl_size n_basic_map() const;\n  static inline map nat_universe(space space);\n  inline map neg() const;\n  inline map oppose(isl::dim type1, int pos1, isl::dim type2, int pos2) const;\n  inline map order_ge(isl::dim type1, int pos1, isl::dim type2, int pos2) const;\n  inline map order_gt(isl::dim type1, int pos1, isl::dim type2, int pos2) const;\n  inline map order_le(isl::dim type1, int pos1, isl::dim type2, int pos2) const;\n  inline map order_lt(isl::dim type1, int pos1, isl::dim type2, int pos2) const;\n  inline set params() const;\n  inline val plain_get_val_if_fixed(isl::dim type, unsigned int pos) const;\n  inline boolean plain_is_empty() const;\n  inline boolean plain_is_equal(const map &map2) const;\n  inline boolean plain_is_injective() const;\n  inline boolean plain_is_single_valued() const;\n  inline boolean plain_is_universe() const;\n  inline basic_map plain_unshifted_simple_hull() const;\n  inline basic_map polyhedral_hull() const;\n  inline map preimage_domain(multi_aff ma) const;\n  inline map preimage_domain(multi_pw_aff mpa) const;\n  inline map preimage_domain(pw_multi_aff pma) const;\n  inline map preimage_range(multi_aff ma) const;\n  inline map preimage_range(pw_multi_aff pma) const;\n  inline map product(map map2) const;\n  inline map project_out(isl::dim type, unsigned int first, unsigned int n) const;\n  inline map project_out_all_params() const;\n  inline set range() const;\n  inline map range_curry() const;\n  inline map range_factor_domain() const;\n  inline map range_factor_range() const;\n  inline boolean range_is_wrapping() const;\n  inline map range_map() const;\n  inline map range_product(map map2) const;\n  inline map range_reverse() const;\n  inline map remove_dims(isl::dim type, unsigned int first, unsigned int n) const;\n  inline map remove_divs() const;\n  inline map remove_divs_involving_dims(isl::dim type, unsigned int first, unsigned int n) const;\n  inline map remove_redundancies() const;\n  inline map remove_unknown_divs() const;\n  inline map reset_tuple_id(isl::dim type) const;\n  inline map reset_user() const;\n  inline map reverse() const;\n  inline basic_map sample() const;\n  inline map set_dim_id(isl::dim type, unsigned int pos, id id) const;\n  inline map set_tuple_id(isl::dim type, id id) const;\n  inline map set_tuple_name(isl::dim type, const std::string &s) const;\n  inline basic_map simple_hull() const;\n  inline map subtract(map map2) const;\n  inline map subtract_domain(set dom) const;\n  inline map subtract_range(set dom) const;\n  inline map sum(map map2) const;\n  inline map uncurry() const;\n  inline map unite(map map2) const;\n  static inline map universe(space space);\n  inline basic_map unshifted_simple_hull() const;\n  inline basic_map unshifted_simple_hull_from_map_list(map_list list) const;\n  inline map upper_bound(multi_pw_aff upper) const;\n  inline map upper_bound_si(isl::dim type, unsigned int pos, int value) const;\n  inline map upper_bound_val(isl::dim type, unsigned int pos, val value) const;\n  inline set wrap() const;\n  inline map zip() const;\n};\n\n// declarations for isl::map_list\ninline map_list manage(__isl_take isl_map_list *ptr);\ninline map_list manage_copy(__isl_keep isl_map_list *ptr);\n\nclass map_list {\n  friend inline map_list manage(__isl_take isl_map_list *ptr);\n  friend inline map_list manage_copy(__isl_keep isl_map_list *ptr);\n\n  isl_map_list *ptr = nullptr;\n\n  inline explicit map_list(__isl_take isl_map_list *ptr);\n\npublic:\n  inline /* implicit */ map_list();\n  inline /* implicit */ map_list(const map_list &obj);\n  inline /* implicit */ map_list(std::nullptr_t);\n  inline map_list &operator=(map_list obj);\n  inline ~map_list();\n  inline __isl_give isl_map_list *copy() const &;\n  inline __isl_give isl_map_list *copy() && = delete;\n  inline __isl_keep isl_map_list *get() const;\n  inline __isl_give isl_map_list *release();\n  inline bool is_null() const;\n  inline explicit operator bool() const;\n  inline ctx get_ctx() const;\n  inline std::string to_str() const;\n  inline void dump() const;\n\n  inline map_list add(map el) const;\n  static inline map_list alloc(ctx ctx, int n);\n  inline map_list clear() const;\n  inline map_list concat(map_list list2) const;\n  inline map_list drop(unsigned int first, unsigned int n) const;\n  inline stat foreach(const std::function<stat(map)> &fn) const;\n  static inline map_list from_map(map el);\n  inline map get_at(int index) const;\n  inline map get_map(int index) const;\n  inline map_list insert(unsigned int pos, map el) const;\n  inline isl_size n_map() const;\n  inline map_list reverse() const;\n  inline map_list set_map(int index, map el) const;\n  inline isl_size size() const;\n  inline map_list swap(unsigned int pos1, unsigned int pos2) const;\n};\n\n// declarations for isl::mat\ninline mat manage(__isl_take isl_mat *ptr);\ninline mat manage_copy(__isl_keep isl_mat *ptr);\n\nclass mat {\n  friend inline mat manage(__isl_take isl_mat *ptr);\n  friend inline mat manage_copy(__isl_keep isl_mat *ptr);\n\n  isl_mat *ptr = nullptr;\n\n  inline explicit mat(__isl_take isl_mat *ptr);\n\npublic:\n  inline /* implicit */ mat();\n  inline /* implicit */ mat(const mat &obj);\n  inline /* implicit */ mat(std::nullptr_t);\n  inline mat &operator=(mat obj);\n  inline ~mat();\n  inline __isl_give isl_mat *copy() const &;\n  inline __isl_give isl_mat *copy() && = delete;\n  inline __isl_keep isl_mat *get() const;\n  inline __isl_give isl_mat *release();\n  inline bool is_null() const;\n  inline explicit operator bool() const;\n  inline ctx get_ctx() const;\n  inline void dump() const;\n\n  inline mat add_rows(unsigned int n) const;\n  inline mat add_zero_cols(unsigned int n) const;\n  inline mat add_zero_rows(unsigned int n) const;\n  inline mat aff_direct_sum(mat right) const;\n  static inline mat alloc(ctx ctx, unsigned int n_row, unsigned int n_col);\n  inline isl_size cols() const;\n  inline mat concat(mat bot) const;\n  inline mat diagonal(mat mat2) const;\n  inline mat drop_cols(unsigned int col, unsigned int n) const;\n  inline mat drop_rows(unsigned int row, unsigned int n) const;\n  static inline mat from_row_vec(vec vec);\n  inline val get_element_val(int row, int col) const;\n  inline boolean has_linearly_independent_rows(const mat &mat2) const;\n  inline int initial_non_zero_cols() const;\n  inline mat insert_cols(unsigned int col, unsigned int n) const;\n  inline mat insert_rows(unsigned int row, unsigned int n) const;\n  inline mat insert_zero_cols(unsigned int first, unsigned int n) const;\n  inline mat insert_zero_rows(unsigned int row, unsigned int n) const;\n  inline mat inverse_product(mat right) const;\n  inline boolean is_equal(const mat &mat2) const;\n  inline mat lin_to_aff() const;\n  inline mat move_cols(unsigned int dst_col, unsigned int src_col, unsigned int n) const;\n  inline mat normalize() const;\n  inline mat normalize_row(int row) const;\n  inline mat product(mat right) const;\n  inline isl_size rank() const;\n  inline mat right_inverse() const;\n  inline mat right_kernel() const;\n  inline mat row_basis() const;\n  inline mat row_basis_extension(mat mat2) const;\n  inline isl_size rows() const;\n  inline mat set_element_si(int row, int col, int v) const;\n  inline mat set_element_val(int row, int col, val v) const;\n  inline mat swap_cols(unsigned int i, unsigned int j) const;\n  inline mat swap_rows(unsigned int i, unsigned int j) const;\n  inline mat transpose() const;\n  inline mat unimodular_complete(int row) const;\n  inline mat vec_concat(vec bot) const;\n  inline vec vec_inverse_product(vec vec) const;\n  inline vec vec_product(vec vec) const;\n};\n\n// declarations for isl::multi_aff\ninline multi_aff manage(__isl_take isl_multi_aff *ptr);\ninline multi_aff manage_copy(__isl_keep isl_multi_aff *ptr);\n\nclass multi_aff {\n  friend inline multi_aff manage(__isl_take isl_multi_aff *ptr);\n  friend inline multi_aff manage_copy(__isl_keep isl_multi_aff *ptr);\n\n  isl_multi_aff *ptr = nullptr;\n\n  inline explicit multi_aff(__isl_take isl_multi_aff *ptr);\n\npublic:\n  inline /* implicit */ multi_aff();\n  inline /* implicit */ multi_aff(const multi_aff &obj);\n  inline /* implicit */ multi_aff(std::nullptr_t);\n  inline /* implicit */ multi_aff(aff aff);\n  inline explicit multi_aff(space space, aff_list list);\n  inline explicit multi_aff(ctx ctx, const std::string &str);\n  inline multi_aff &operator=(multi_aff obj);\n  inline ~multi_aff();\n  inline __isl_give isl_multi_aff *copy() const &;\n  inline __isl_give isl_multi_aff *copy() && = delete;\n  inline __isl_keep isl_multi_aff *get() const;\n  inline __isl_give isl_multi_aff *release();\n  inline bool is_null() const;\n  inline explicit operator bool() const;\n  inline ctx get_ctx() const;\n  inline std::string to_str() const;\n  inline void dump() const;\n\n  inline multi_aff add(multi_aff multi2) const;\n  inline multi_aff add_constant(multi_val mv) const;\n  inline multi_aff add_constant(val v) const;\n  inline multi_aff add_dims(isl::dim type, unsigned int n) const;\n  inline multi_aff align_params(space model) const;\n  inline basic_set bind(multi_id tuple) const;\n  inline multi_aff bind_domain(multi_id tuple) const;\n  inline multi_aff bind_domain_wrapped_domain(multi_id tuple) const;\n  inline isl_size dim(isl::dim type) const;\n  static inline multi_aff domain_map(space space);\n  inline multi_aff drop_dims(isl::dim type, unsigned int first, unsigned int n) const;\n  inline multi_aff factor_range() const;\n  inline int find_dim_by_id(isl::dim type, const id &id) const;\n  inline int find_dim_by_name(isl::dim type, const std::string &name) const;\n  inline multi_aff flat_range_product(multi_aff multi2) const;\n  inline multi_aff flatten_domain() const;\n  inline multi_aff flatten_range() const;\n  inline multi_aff floor() const;\n  inline multi_aff from_range() const;\n  inline aff get_aff(int pos) const;\n  inline aff get_at(int pos) const;\n  inline multi_val get_constant_multi_val() const;\n  inline id get_dim_id(isl::dim type, unsigned int pos) const;\n  inline space get_domain_space() const;\n  inline aff_list get_list() const;\n  inline space get_space() const;\n  inline id get_tuple_id(isl::dim type) const;\n  inline std::string get_tuple_name(isl::dim type) const;\n  inline multi_aff gist(set context) const;\n  inline multi_aff gist_params(set context) const;\n  inline boolean has_tuple_id(isl::dim type) const;\n  static inline multi_aff identity(space space);\n  inline multi_aff identity() const;\n  static inline multi_aff identity_on_domain(space space);\n  inline multi_aff insert_dims(isl::dim type, unsigned int first, unsigned int n) const;\n  inline multi_aff insert_domain(space domain) const;\n  inline boolean involves_dims(isl::dim type, unsigned int first, unsigned int n) const;\n  inline boolean involves_locals() const;\n  inline boolean involves_nan() const;\n  inline set lex_ge_set(multi_aff ma2) const;\n  inline set lex_gt_set(multi_aff ma2) const;\n  inline set lex_le_set(multi_aff ma2) const;\n  inline set lex_lt_set(multi_aff ma2) const;\n  inline multi_aff mod_multi_val(multi_val mv) const;\n  inline multi_aff move_dims(isl::dim dst_type, unsigned int dst_pos, isl::dim src_type, unsigned int src_pos, unsigned int n) const;\n  static inline multi_aff multi_val_on_space(space space, multi_val mv);\n  inline multi_aff neg() const;\n  inline int plain_cmp(const multi_aff &multi2) const;\n  inline boolean plain_is_equal(const multi_aff &multi2) const;\n  inline multi_aff product(multi_aff multi2) const;\n  inline multi_aff project_domain_on_params() const;\n  static inline multi_aff project_out_map(space space, isl::dim type, unsigned int first, unsigned int n);\n  inline multi_aff pullback(multi_aff ma2) const;\n  inline multi_aff range_factor_domain() const;\n  inline multi_aff range_factor_range() const;\n  inline boolean range_is_wrapping() const;\n  static inline multi_aff range_map(space space);\n  inline multi_aff range_product(multi_aff multi2) const;\n  inline multi_aff range_splice(unsigned int pos, multi_aff multi2) const;\n  inline multi_aff reset_tuple_id(isl::dim type) const;\n  inline multi_aff reset_user() const;\n  inline multi_aff scale(multi_val mv) const;\n  inline multi_aff scale(val v) const;\n  inline multi_aff scale_down(multi_val mv) const;\n  inline multi_aff scale_down(val v) const;\n  inline multi_aff set_aff(int pos, aff el) const;\n  inline multi_aff set_at(int pos, aff el) const;\n  inline multi_aff set_dim_id(isl::dim type, unsigned int pos, id id) const;\n  inline multi_aff set_tuple_id(isl::dim type, id id) const;\n  inline multi_aff set_tuple_name(isl::dim type, const std::string &s) const;\n  inline isl_size size() const;\n  inline multi_aff splice(unsigned int in_pos, unsigned int out_pos, multi_aff multi2) const;\n  inline multi_aff sub(multi_aff multi2) const;\n  inline multi_aff unbind_params_insert_domain(multi_id domain) const;\n  static inline multi_aff zero(space space);\n};\n\n// declarations for isl::multi_id\ninline multi_id manage(__isl_take isl_multi_id *ptr);\ninline multi_id manage_copy(__isl_keep isl_multi_id *ptr);\n\nclass multi_id {\n  friend inline multi_id manage(__isl_take isl_multi_id *ptr);\n  friend inline multi_id manage_copy(__isl_keep isl_multi_id *ptr);\n\n  isl_multi_id *ptr = nullptr;\n\n  inline explicit multi_id(__isl_take isl_multi_id *ptr);\n\npublic:\n  inline /* implicit */ multi_id();\n  inline /* implicit */ multi_id(const multi_id &obj);\n  inline /* implicit */ multi_id(std::nullptr_t);\n  inline explicit multi_id(space space, id_list list);\n  inline explicit multi_id(ctx ctx, const std::string &str);\n  inline multi_id &operator=(multi_id obj);\n  inline ~multi_id();\n  inline __isl_give isl_multi_id *copy() const &;\n  inline __isl_give isl_multi_id *copy() && = delete;\n  inline __isl_keep isl_multi_id *get() const;\n  inline __isl_give isl_multi_id *release();\n  inline bool is_null() const;\n  inline explicit operator bool() const;\n  inline ctx get_ctx() const;\n  inline std::string to_str() const;\n  inline void dump() const;\n\n  inline multi_id align_params(space model) const;\n  inline multi_id factor_range() const;\n  inline multi_id flat_range_product(multi_id multi2) const;\n  inline multi_id flatten_range() const;\n  inline multi_id from_range() const;\n  inline id get_at(int pos) const;\n  inline space get_domain_space() const;\n  inline id get_id(int pos) const;\n  inline id_list get_list() const;\n  inline space get_space() const;\n  inline boolean plain_is_equal(const multi_id &multi2) const;\n  inline multi_id range_factor_domain() const;\n  inline multi_id range_factor_range() const;\n  inline boolean range_is_wrapping() const;\n  inline multi_id range_product(multi_id multi2) const;\n  inline multi_id range_splice(unsigned int pos, multi_id multi2) const;\n  inline multi_id reset_user() const;\n  inline multi_id set_at(int pos, id el) const;\n  inline multi_id set_id(int pos, id el) const;\n  inline isl_size size() const;\n};\n\n// declarations for isl::multi_pw_aff\ninline multi_pw_aff manage(__isl_take isl_multi_pw_aff *ptr);\ninline multi_pw_aff manage_copy(__isl_keep isl_multi_pw_aff *ptr);\n\nclass multi_pw_aff {\n  friend inline multi_pw_aff manage(__isl_take isl_multi_pw_aff *ptr);\n  friend inline multi_pw_aff manage_copy(__isl_keep isl_multi_pw_aff *ptr);\n\n  isl_multi_pw_aff *ptr = nullptr;\n\n  inline explicit multi_pw_aff(__isl_take isl_multi_pw_aff *ptr);\n\npublic:\n  inline /* implicit */ multi_pw_aff();\n  inline /* implicit */ multi_pw_aff(const multi_pw_aff &obj);\n  inline /* implicit */ multi_pw_aff(std::nullptr_t);\n  inline /* implicit */ multi_pw_aff(aff aff);\n  inline /* implicit */ multi_pw_aff(multi_aff ma);\n  inline /* implicit */ multi_pw_aff(pw_aff pa);\n  inline explicit multi_pw_aff(space space, pw_aff_list list);\n  inline /* implicit */ multi_pw_aff(pw_multi_aff pma);\n  inline explicit multi_pw_aff(ctx ctx, const std::string &str);\n  inline multi_pw_aff &operator=(multi_pw_aff obj);\n  inline ~multi_pw_aff();\n  inline __isl_give isl_multi_pw_aff *copy() const &;\n  inline __isl_give isl_multi_pw_aff *copy() && = delete;\n  inline __isl_keep isl_multi_pw_aff *get() const;\n  inline __isl_give isl_multi_pw_aff *release();\n  inline bool is_null() const;\n  inline explicit operator bool() const;\n  inline ctx get_ctx() const;\n  inline std::string to_str() const;\n  inline void dump() const;\n\n  inline multi_pw_aff add(multi_pw_aff multi2) const;\n  inline multi_pw_aff add_constant(multi_val mv) const;\n  inline multi_pw_aff add_constant(val v) const;\n  inline multi_pw_aff add_dims(isl::dim type, unsigned int n) const;\n  inline multi_pw_aff align_params(space model) const;\n  inline set bind(multi_id tuple) const;\n  inline multi_pw_aff bind_domain(multi_id tuple) const;\n  inline multi_pw_aff bind_domain_wrapped_domain(multi_id tuple) const;\n  inline multi_pw_aff coalesce() const;\n  inline isl_size dim(isl::dim type) const;\n  inline set domain() const;\n  inline multi_pw_aff drop_dims(isl::dim type, unsigned int first, unsigned int n) const;\n  inline map eq_map(multi_pw_aff mpa2) const;\n  inline multi_pw_aff factor_range() const;\n  inline int find_dim_by_id(isl::dim type, const id &id) const;\n  inline int find_dim_by_name(isl::dim type, const std::string &name) const;\n  inline multi_pw_aff flat_range_product(multi_pw_aff multi2) const;\n  inline multi_pw_aff flatten_range() const;\n  inline multi_pw_aff from_range() const;\n  inline pw_aff get_at(int pos) const;\n  inline id get_dim_id(isl::dim type, unsigned int pos) const;\n  inline space get_domain_space() const;\n  inline uint32_t get_hash() const;\n  inline pw_aff_list get_list() const;\n  inline pw_aff get_pw_aff(int pos) const;\n  inline space get_space() const;\n  inline id get_tuple_id(isl::dim type) const;\n  inline std::string get_tuple_name(isl::dim type) const;\n  inline multi_pw_aff gist(set set) const;\n  inline multi_pw_aff gist_params(set set) const;\n  inline boolean has_tuple_id(isl::dim type) const;\n  static inline multi_pw_aff identity(space space);\n  inline multi_pw_aff identity() const;\n  static inline multi_pw_aff identity_on_domain(space space);\n  inline multi_pw_aff insert_dims(isl::dim type, unsigned int first, unsigned int n) const;\n  inline multi_pw_aff insert_domain(space domain) const;\n  inline multi_pw_aff intersect_domain(set domain) const;\n  inline multi_pw_aff intersect_params(set set) const;\n  inline boolean involves_dims(isl::dim type, unsigned int first, unsigned int n) const;\n  inline boolean involves_nan() const;\n  inline boolean involves_param(const id &id) const;\n  inline boolean involves_param(const id_list &list) const;\n  inline boolean is_cst() const;\n  inline boolean is_equal(const multi_pw_aff &mpa2) const;\n  inline map lex_ge_map(multi_pw_aff mpa2) const;\n  inline map lex_gt_map(multi_pw_aff mpa2) const;\n  inline map lex_le_map(multi_pw_aff mpa2) const;\n  inline map lex_lt_map(multi_pw_aff mpa2) const;\n  inline multi_pw_aff max(multi_pw_aff multi2) const;\n  inline multi_val max_multi_val() const;\n  inline multi_pw_aff min(multi_pw_aff multi2) const;\n  inline multi_val min_multi_val() const;\n  inline multi_pw_aff mod_multi_val(multi_val mv) const;\n  inline multi_pw_aff move_dims(isl::dim dst_type, unsigned int dst_pos, isl::dim src_type, unsigned int src_pos, unsigned int n) const;\n  inline multi_pw_aff neg() const;\n  inline boolean plain_is_equal(const multi_pw_aff &multi2) const;\n  inline multi_pw_aff product(multi_pw_aff multi2) const;\n  inline multi_pw_aff project_domain_on_params() const;\n  inline multi_pw_aff pullback(multi_aff ma) const;\n  inline multi_pw_aff pullback(multi_pw_aff mpa2) const;\n  inline multi_pw_aff pullback(pw_multi_aff pma) const;\n  inline multi_pw_aff range_factor_domain() const;\n  inline multi_pw_aff range_factor_range() const;\n  inline boolean range_is_wrapping() const;\n  inline multi_pw_aff range_product(multi_pw_aff multi2) const;\n  inline multi_pw_aff range_splice(unsigned int pos, multi_pw_aff multi2) const;\n  inline multi_pw_aff reset_tuple_id(isl::dim type) const;\n  inline multi_pw_aff reset_user() const;\n  inline multi_pw_aff scale(multi_val mv) const;\n  inline multi_pw_aff scale(val v) const;\n  inline multi_pw_aff scale_down(multi_val mv) const;\n  inline multi_pw_aff scale_down(val v) const;\n  inline multi_pw_aff set_at(int pos, pw_aff el) const;\n  inline multi_pw_aff set_dim_id(isl::dim type, unsigned int pos, id id) const;\n  inline multi_pw_aff set_pw_aff(int pos, pw_aff el) const;\n  inline multi_pw_aff set_tuple_id(isl::dim type, id id) const;\n  inline multi_pw_aff set_tuple_name(isl::dim type, const std::string &s) const;\n  inline isl_size size() const;\n  inline multi_pw_aff splice(unsigned int in_pos, unsigned int out_pos, multi_pw_aff multi2) const;\n  inline multi_pw_aff sub(multi_pw_aff multi2) const;\n  inline multi_pw_aff unbind_params_insert_domain(multi_id domain) const;\n  inline multi_pw_aff union_add(multi_pw_aff mpa2) const;\n  static inline multi_pw_aff zero(space space);\n};\n\n// declarations for isl::multi_union_pw_aff\ninline multi_union_pw_aff manage(__isl_take isl_multi_union_pw_aff *ptr);\ninline multi_union_pw_aff manage_copy(__isl_keep isl_multi_union_pw_aff *ptr);\n\nclass multi_union_pw_aff {\n  friend inline multi_union_pw_aff manage(__isl_take isl_multi_union_pw_aff *ptr);\n  friend inline multi_union_pw_aff manage_copy(__isl_keep isl_multi_union_pw_aff *ptr);\n\n  isl_multi_union_pw_aff *ptr = nullptr;\n\n  inline explicit multi_union_pw_aff(__isl_take isl_multi_union_pw_aff *ptr);\n\npublic:\n  inline /* implicit */ multi_union_pw_aff();\n  inline /* implicit */ multi_union_pw_aff(const multi_union_pw_aff &obj);\n  inline /* implicit */ multi_union_pw_aff(std::nullptr_t);\n  inline /* implicit */ multi_union_pw_aff(multi_pw_aff mpa);\n  inline /* implicit */ multi_union_pw_aff(union_pw_aff upa);\n  inline explicit multi_union_pw_aff(space space, union_pw_aff_list list);\n  inline explicit multi_union_pw_aff(union_pw_multi_aff upma);\n  inline explicit multi_union_pw_aff(ctx ctx, const std::string &str);\n  inline multi_union_pw_aff &operator=(multi_union_pw_aff obj);\n  inline ~multi_union_pw_aff();\n  inline __isl_give isl_multi_union_pw_aff *copy() const &;\n  inline __isl_give isl_multi_union_pw_aff *copy() && = delete;\n  inline __isl_keep isl_multi_union_pw_aff *get() const;\n  inline __isl_give isl_multi_union_pw_aff *release();\n  inline bool is_null() const;\n  inline explicit operator bool() const;\n  inline ctx get_ctx() const;\n  inline std::string to_str() const;\n  inline void dump() const;\n\n  inline multi_union_pw_aff add(multi_union_pw_aff multi2) const;\n  inline multi_union_pw_aff align_params(space model) const;\n  inline union_pw_aff apply_aff(aff aff) const;\n  inline union_pw_aff apply_pw_aff(pw_aff pa) const;\n  inline multi_union_pw_aff apply_pw_multi_aff(pw_multi_aff pma) const;\n  inline union_set bind(multi_id tuple) const;\n  inline multi_union_pw_aff coalesce() const;\n  inline isl_size dim(isl::dim type) const;\n  inline union_set domain() const;\n  inline multi_union_pw_aff drop_dims(isl::dim type, unsigned int first, unsigned int n) const;\n  inline multi_pw_aff extract_multi_pw_aff(space space) const;\n  inline multi_union_pw_aff factor_range() const;\n  inline int find_dim_by_id(isl::dim type, const id &id) const;\n  inline int find_dim_by_name(isl::dim type, const std::string &name) const;\n  inline multi_union_pw_aff flat_range_product(multi_union_pw_aff multi2) const;\n  inline multi_union_pw_aff flatten_range() const;\n  inline multi_union_pw_aff floor() const;\n  static inline multi_union_pw_aff from_multi_aff(multi_aff ma);\n  inline multi_union_pw_aff from_range() const;\n  static inline multi_union_pw_aff from_union_map(union_map umap);\n  inline union_pw_aff get_at(int pos) const;\n  inline id get_dim_id(isl::dim type, unsigned int pos) const;\n  inline space get_domain_space() const;\n  inline union_pw_aff_list get_list() const;\n  inline space get_space() const;\n  inline id get_tuple_id(isl::dim type) const;\n  inline std::string get_tuple_name(isl::dim type) const;\n  inline union_pw_aff get_union_pw_aff(int pos) const;\n  inline multi_union_pw_aff gist(union_set context) const;\n  inline multi_union_pw_aff gist_params(set context) const;\n  inline boolean has_tuple_id(isl::dim type) const;\n  inline multi_union_pw_aff intersect_domain(union_set uset) const;\n  inline multi_union_pw_aff intersect_params(set params) const;\n  inline multi_union_pw_aff intersect_range(set set) const;\n  inline boolean involves_nan() const;\n  inline multi_val max_multi_val() const;\n  inline multi_val min_multi_val() const;\n  inline multi_union_pw_aff mod_multi_val(multi_val mv) const;\n  static inline multi_union_pw_aff multi_aff_on_domain(union_set domain, multi_aff ma);\n  static inline multi_union_pw_aff multi_val_on_domain(union_set domain, multi_val mv);\n  inline multi_union_pw_aff neg() const;\n  inline boolean plain_is_equal(const multi_union_pw_aff &multi2) const;\n  inline multi_union_pw_aff pullback(union_pw_multi_aff upma) const;\n  static inline multi_union_pw_aff pw_multi_aff_on_domain(union_set domain, pw_multi_aff pma);\n  inline multi_union_pw_aff range_factor_domain() const;\n  inline multi_union_pw_aff range_factor_range() const;\n  inline boolean range_is_wrapping() const;\n  inline multi_union_pw_aff range_product(multi_union_pw_aff multi2) const;\n  inline multi_union_pw_aff range_splice(unsigned int pos, multi_union_pw_aff multi2) const;\n  inline multi_union_pw_aff reset_tuple_id(isl::dim type) const;\n  inline multi_union_pw_aff reset_user() const;\n  inline multi_union_pw_aff scale(multi_val mv) const;\n  inline multi_union_pw_aff scale(val v) const;\n  inline multi_union_pw_aff scale_down(multi_val mv) const;\n  inline multi_union_pw_aff scale_down(val v) const;\n  inline multi_union_pw_aff set_at(int pos, union_pw_aff el) const;\n  inline multi_union_pw_aff set_dim_id(isl::dim type, unsigned int pos, id id) const;\n  inline multi_union_pw_aff set_tuple_id(isl::dim type, id id) const;\n  inline multi_union_pw_aff set_tuple_name(isl::dim type, const std::string &s) const;\n  inline multi_union_pw_aff set_union_pw_aff(int pos, union_pw_aff el) const;\n  inline isl_size size() const;\n  inline multi_union_pw_aff sub(multi_union_pw_aff multi2) const;\n  inline multi_union_pw_aff union_add(multi_union_pw_aff mupa2) const;\n  static inline multi_union_pw_aff zero(space space);\n  inline union_set zero_union_set() const;\n};\n\n// declarations for isl::multi_val\ninline multi_val manage(__isl_take isl_multi_val *ptr);\ninline multi_val manage_copy(__isl_keep isl_multi_val *ptr);\n\nclass multi_val {\n  friend inline multi_val manage(__isl_take isl_multi_val *ptr);\n  friend inline multi_val manage_copy(__isl_keep isl_multi_val *ptr);\n\n  isl_multi_val *ptr = nullptr;\n\n  inline explicit multi_val(__isl_take isl_multi_val *ptr);\n\npublic:\n  inline /* implicit */ multi_val();\n  inline /* implicit */ multi_val(const multi_val &obj);\n  inline /* implicit */ multi_val(std::nullptr_t);\n  inline explicit multi_val(space space, val_list list);\n  inline explicit multi_val(ctx ctx, const std::string &str);\n  inline multi_val &operator=(multi_val obj);\n  inline ~multi_val();\n  inline __isl_give isl_multi_val *copy() const &;\n  inline __isl_give isl_multi_val *copy() && = delete;\n  inline __isl_keep isl_multi_val *get() const;\n  inline __isl_give isl_multi_val *release();\n  inline bool is_null() const;\n  inline explicit operator bool() const;\n  inline ctx get_ctx() const;\n  inline std::string to_str() const;\n  inline void dump() const;\n\n  inline multi_val add(multi_val multi2) const;\n  inline multi_val add(val v) const;\n  inline multi_val add_dims(isl::dim type, unsigned int n) const;\n  inline multi_val align_params(space model) const;\n  inline isl_size dim(isl::dim type) const;\n  inline multi_val drop_dims(isl::dim type, unsigned int first, unsigned int n) const;\n  inline multi_val factor_range() const;\n  inline int find_dim_by_id(isl::dim type, const id &id) const;\n  inline int find_dim_by_name(isl::dim type, const std::string &name) const;\n  inline multi_val flat_range_product(multi_val multi2) const;\n  inline multi_val flatten_range() const;\n  inline multi_val from_range() const;\n  inline val get_at(int pos) const;\n  inline id get_dim_id(isl::dim type, unsigned int pos) const;\n  inline space get_domain_space() const;\n  inline val_list get_list() const;\n  inline space get_space() const;\n  inline id get_tuple_id(isl::dim type) const;\n  inline std::string get_tuple_name(isl::dim type) const;\n  inline val get_val(int pos) const;\n  inline boolean has_tuple_id(isl::dim type) const;\n  inline multi_val insert_dims(isl::dim type, unsigned int first, unsigned int n) const;\n  inline boolean involves_dims(isl::dim type, unsigned int first, unsigned int n) const;\n  inline boolean involves_nan() const;\n  inline boolean is_zero() const;\n  inline multi_val max(multi_val multi2) const;\n  inline multi_val min(multi_val multi2) const;\n  inline multi_val mod_multi_val(multi_val mv) const;\n  inline multi_val mod_val(val v) const;\n  inline multi_val neg() const;\n  inline boolean plain_is_equal(const multi_val &multi2) const;\n  inline multi_val product(multi_val multi2) const;\n  inline multi_val project_domain_on_params() const;\n  inline multi_val range_factor_domain() const;\n  inline multi_val range_factor_range() const;\n  inline boolean range_is_wrapping() const;\n  inline multi_val range_product(multi_val multi2) const;\n  inline multi_val range_splice(unsigned int pos, multi_val multi2) const;\n  inline multi_val reset_tuple_id(isl::dim type) const;\n  inline multi_val reset_user() const;\n  inline multi_val scale(multi_val mv) const;\n  inline multi_val scale(val v) const;\n  inline multi_val scale_down(multi_val mv) const;\n  inline multi_val scale_down(val v) const;\n  inline multi_val set_at(int pos, val el) const;\n  inline multi_val set_dim_id(isl::dim type, unsigned int pos, id id) const;\n  inline multi_val set_tuple_id(isl::dim type, id id) const;\n  inline multi_val set_tuple_name(isl::dim type, const std::string &s) const;\n  inline multi_val set_val(int pos, val el) const;\n  inline isl_size size() const;\n  inline multi_val splice(unsigned int in_pos, unsigned int out_pos, multi_val multi2) const;\n  inline multi_val sub(multi_val multi2) const;\n  static inline multi_val zero(space space);\n};\n\n// declarations for isl::point\ninline point manage(__isl_take isl_point *ptr);\ninline point manage_copy(__isl_keep isl_point *ptr);\n\nclass point {\n  friend inline point manage(__isl_take isl_point *ptr);\n  friend inline point manage_copy(__isl_keep isl_point *ptr);\n\n  isl_point *ptr = nullptr;\n\n  inline explicit point(__isl_take isl_point *ptr);\n\npublic:\n  inline /* implicit */ point();\n  inline /* implicit */ point(const point &obj);\n  inline /* implicit */ point(std::nullptr_t);\n  inline explicit point(space dim);\n  inline point &operator=(point obj);\n  inline ~point();\n  inline __isl_give isl_point *copy() const &;\n  inline __isl_give isl_point *copy() && = delete;\n  inline __isl_keep isl_point *get() const;\n  inline __isl_give isl_point *release();\n  inline bool is_null() const;\n  inline explicit operator bool() const;\n  inline ctx get_ctx() const;\n  inline std::string to_str() const;\n  inline void dump() const;\n\n  inline point add_ui(isl::dim type, int pos, unsigned int val) const;\n  inline val get_coordinate_val(isl::dim type, int pos) const;\n  inline multi_val get_multi_val() const;\n  inline space get_space() const;\n  inline point set_coordinate_val(isl::dim type, int pos, val v) const;\n  inline point sub_ui(isl::dim type, int pos, unsigned int val) const;\n};\n\n// declarations for isl::pw_aff\ninline pw_aff manage(__isl_take isl_pw_aff *ptr);\ninline pw_aff manage_copy(__isl_keep isl_pw_aff *ptr);\n\nclass pw_aff {\n  friend inline pw_aff manage(__isl_take isl_pw_aff *ptr);\n  friend inline pw_aff manage_copy(__isl_keep isl_pw_aff *ptr);\n\n  isl_pw_aff *ptr = nullptr;\n\n  inline explicit pw_aff(__isl_take isl_pw_aff *ptr);\n\npublic:\n  inline /* implicit */ pw_aff();\n  inline /* implicit */ pw_aff(const pw_aff &obj);\n  inline /* implicit */ pw_aff(std::nullptr_t);\n  inline /* implicit */ pw_aff(aff aff);\n  inline explicit pw_aff(ctx ctx, const std::string &str);\n  inline explicit pw_aff(set domain, val v);\n  inline explicit pw_aff(local_space ls);\n  inline pw_aff &operator=(pw_aff obj);\n  inline ~pw_aff();\n  inline __isl_give isl_pw_aff *copy() const &;\n  inline __isl_give isl_pw_aff *copy() && = delete;\n  inline __isl_keep isl_pw_aff *get() const;\n  inline __isl_give isl_pw_aff *release();\n  inline bool is_null() const;\n  inline explicit operator bool() const;\n  inline ctx get_ctx() const;\n  inline std::string to_str() const;\n  inline void dump() const;\n\n  inline pw_aff add(pw_aff pwaff2) const;\n  inline pw_aff add_constant(val v) const;\n  inline pw_aff add_dims(isl::dim type, unsigned int n) const;\n  inline pw_aff align_params(space model) const;\n  static inline pw_aff alloc(set set, aff aff);\n  inline aff as_aff() const;\n  inline set bind(id id) const;\n  inline pw_aff bind_domain(multi_id tuple) const;\n  inline pw_aff bind_domain_wrapped_domain(multi_id tuple) const;\n  inline pw_aff ceil() const;\n  inline pw_aff coalesce() const;\n  inline pw_aff cond(pw_aff pwaff_true, pw_aff pwaff_false) const;\n  inline isl_size dim(isl::dim type) const;\n  inline pw_aff div(pw_aff pa2) const;\n  inline set domain() const;\n  inline pw_aff drop_dims(isl::dim type, unsigned int first, unsigned int n) const;\n  inline pw_aff drop_unused_params() const;\n  static inline pw_aff empty(space space);\n  inline map eq_map(pw_aff pa2) const;\n  inline set eq_set(pw_aff pwaff2) const;\n  inline val eval(point pnt) const;\n  inline int find_dim_by_name(isl::dim type, const std::string &name) const;\n  inline pw_aff floor() const;\n  inline stat foreach_piece(const std::function<stat(set, aff)> &fn) const;\n  inline pw_aff from_range() const;\n  inline map ge_map(pw_aff pa2) const;\n  inline set ge_set(pw_aff pwaff2) const;\n  inline id get_dim_id(isl::dim type, unsigned int pos) const;\n  inline std::string get_dim_name(isl::dim type, unsigned int pos) const;\n  inline space get_domain_space() const;\n  inline uint32_t get_hash() const;\n  inline space get_space() const;\n  inline id get_tuple_id(isl::dim type) const;\n  inline pw_aff gist(set context) const;\n  inline pw_aff gist_params(set context) const;\n  inline map gt_map(pw_aff pa2) const;\n  inline set gt_set(pw_aff pwaff2) const;\n  inline boolean has_dim_id(isl::dim type, unsigned int pos) const;\n  inline boolean has_tuple_id(isl::dim type) const;\n  inline pw_aff insert_dims(isl::dim type, unsigned int first, unsigned int n) const;\n  inline pw_aff insert_domain(space domain) const;\n  inline pw_aff intersect_domain(set set) const;\n  inline pw_aff intersect_domain_wrapped_domain(set set) const;\n  inline pw_aff intersect_domain_wrapped_range(set set) const;\n  inline pw_aff intersect_params(set set) const;\n  inline boolean involves_dims(isl::dim type, unsigned int first, unsigned int n) const;\n  inline boolean involves_nan() const;\n  inline boolean involves_param_id(const id &id) const;\n  inline boolean is_cst() const;\n  inline boolean is_empty() const;\n  inline boolean is_equal(const pw_aff &pa2) const;\n  inline boolean isa_aff() const;\n  inline map le_map(pw_aff pa2) const;\n  inline set le_set(pw_aff pwaff2) const;\n  inline map lt_map(pw_aff pa2) const;\n  inline set lt_set(pw_aff pwaff2) const;\n  inline pw_aff max(pw_aff pwaff2) const;\n  inline pw_aff min(pw_aff pwaff2) const;\n  inline pw_aff mod(val mod) const;\n  inline pw_aff move_dims(isl::dim dst_type, unsigned int dst_pos, isl::dim src_type, unsigned int src_pos, unsigned int n) const;\n  inline pw_aff mul(pw_aff pwaff2) const;\n  inline isl_size n_piece() const;\n  static inline pw_aff nan_on_domain(local_space ls);\n  static inline pw_aff nan_on_domain_space(space space);\n  inline set ne_set(pw_aff pwaff2) const;\n  inline pw_aff neg() const;\n  inline set non_zero_set() const;\n  inline set nonneg_set() const;\n  static inline pw_aff param_on_domain(set domain, id id);\n  inline set params() const;\n  inline int plain_cmp(const pw_aff &pa2) const;\n  inline boolean plain_is_equal(const pw_aff &pwaff2) const;\n  inline set pos_set() const;\n  inline pw_aff project_domain_on_params() const;\n  inline pw_aff pullback(multi_aff ma) const;\n  inline pw_aff pullback(multi_pw_aff mpa) const;\n  inline pw_aff pullback(pw_multi_aff pma) const;\n  inline pw_aff reset_tuple_id(isl::dim type) const;\n  inline pw_aff reset_user() const;\n  inline pw_aff scale(val v) const;\n  inline pw_aff scale_down(val f) const;\n  inline pw_aff set_dim_id(isl::dim type, unsigned int pos, id id) const;\n  inline pw_aff set_tuple_id(isl::dim type, id id) const;\n  inline pw_aff sub(pw_aff pwaff2) const;\n  inline pw_aff subtract_domain(set set) const;\n  inline pw_aff tdiv_q(pw_aff pa2) const;\n  inline pw_aff tdiv_r(pw_aff pa2) const;\n  inline pw_aff union_add(pw_aff pwaff2) const;\n  inline pw_aff union_max(pw_aff pwaff2) const;\n  inline pw_aff union_min(pw_aff pwaff2) const;\n  static inline pw_aff var_on_domain(local_space ls, isl::dim type, unsigned int pos);\n  inline set zero_set() const;\n};\n\n// declarations for isl::pw_aff_list\ninline pw_aff_list manage(__isl_take isl_pw_aff_list *ptr);\ninline pw_aff_list manage_copy(__isl_keep isl_pw_aff_list *ptr);\n\nclass pw_aff_list {\n  friend inline pw_aff_list manage(__isl_take isl_pw_aff_list *ptr);\n  friend inline pw_aff_list manage_copy(__isl_keep isl_pw_aff_list *ptr);\n\n  isl_pw_aff_list *ptr = nullptr;\n\n  inline explicit pw_aff_list(__isl_take isl_pw_aff_list *ptr);\n\npublic:\n  inline /* implicit */ pw_aff_list();\n  inline /* implicit */ pw_aff_list(const pw_aff_list &obj);\n  inline /* implicit */ pw_aff_list(std::nullptr_t);\n  inline pw_aff_list &operator=(pw_aff_list obj);\n  inline ~pw_aff_list();\n  inline __isl_give isl_pw_aff_list *copy() const &;\n  inline __isl_give isl_pw_aff_list *copy() && = delete;\n  inline __isl_keep isl_pw_aff_list *get() const;\n  inline __isl_give isl_pw_aff_list *release();\n  inline bool is_null() const;\n  inline explicit operator bool() const;\n  inline ctx get_ctx() const;\n  inline std::string to_str() const;\n  inline void dump() const;\n\n  inline pw_aff_list add(pw_aff el) const;\n  static inline pw_aff_list alloc(ctx ctx, int n);\n  inline pw_aff_list clear() const;\n  inline pw_aff_list concat(pw_aff_list list2) const;\n  inline pw_aff_list drop(unsigned int first, unsigned int n) const;\n  inline set eq_set(pw_aff_list list2) const;\n  inline stat foreach(const std::function<stat(pw_aff)> &fn) const;\n  static inline pw_aff_list from_pw_aff(pw_aff el);\n  inline set ge_set(pw_aff_list list2) const;\n  inline pw_aff get_at(int index) const;\n  inline pw_aff get_pw_aff(int index) const;\n  inline set gt_set(pw_aff_list list2) const;\n  inline pw_aff_list insert(unsigned int pos, pw_aff el) const;\n  inline set le_set(pw_aff_list list2) const;\n  inline set lt_set(pw_aff_list list2) const;\n  inline pw_aff max() const;\n  inline pw_aff min() const;\n  inline isl_size n_pw_aff() const;\n  inline set ne_set(pw_aff_list list2) const;\n  inline pw_aff_list reverse() const;\n  inline pw_aff_list set_pw_aff(int index, pw_aff el) const;\n  inline isl_size size() const;\n  inline pw_aff_list swap(unsigned int pos1, unsigned int pos2) const;\n};\n\n// declarations for isl::pw_multi_aff\ninline pw_multi_aff manage(__isl_take isl_pw_multi_aff *ptr);\ninline pw_multi_aff manage_copy(__isl_keep isl_pw_multi_aff *ptr);\n\nclass pw_multi_aff {\n  friend inline pw_multi_aff manage(__isl_take isl_pw_multi_aff *ptr);\n  friend inline pw_multi_aff manage_copy(__isl_keep isl_pw_multi_aff *ptr);\n\n  isl_pw_multi_aff *ptr = nullptr;\n\n  inline explicit pw_multi_aff(__isl_take isl_pw_multi_aff *ptr);\n\npublic:\n  inline /* implicit */ pw_multi_aff();\n  inline /* implicit */ pw_multi_aff(const pw_multi_aff &obj);\n  inline /* implicit */ pw_multi_aff(std::nullptr_t);\n  inline /* implicit */ pw_multi_aff(multi_aff ma);\n  inline /* implicit */ pw_multi_aff(pw_aff pa);\n  inline explicit pw_multi_aff(ctx ctx, const std::string &str);\n  inline pw_multi_aff &operator=(pw_multi_aff obj);\n  inline ~pw_multi_aff();\n  inline __isl_give isl_pw_multi_aff *copy() const &;\n  inline __isl_give isl_pw_multi_aff *copy() && = delete;\n  inline __isl_keep isl_pw_multi_aff *get() const;\n  inline __isl_give isl_pw_multi_aff *release();\n  inline bool is_null() const;\n  inline explicit operator bool() const;\n  inline ctx get_ctx() const;\n  inline std::string to_str() const;\n  inline void dump() const;\n\n  inline pw_multi_aff add(pw_multi_aff pma2) const;\n  inline pw_multi_aff add_constant(multi_val mv) const;\n  inline pw_multi_aff add_constant(val v) const;\n  inline pw_multi_aff align_params(space model) const;\n  static inline pw_multi_aff alloc(set set, multi_aff maff);\n  inline multi_aff as_multi_aff() const;\n  inline pw_multi_aff bind_domain(multi_id tuple) const;\n  inline pw_multi_aff bind_domain_wrapped_domain(multi_id tuple) const;\n  inline pw_multi_aff coalesce() const;\n  inline isl_size dim(isl::dim type) const;\n  inline set domain() const;\n  static inline pw_multi_aff domain_map(space space);\n  inline pw_multi_aff drop_dims(isl::dim type, unsigned int first, unsigned int n) const;\n  inline pw_multi_aff drop_unused_params() const;\n  static inline pw_multi_aff empty(space space);\n  inline int find_dim_by_name(isl::dim type, const std::string &name) const;\n  inline pw_multi_aff fix_si(isl::dim type, unsigned int pos, int value) const;\n  inline pw_multi_aff flat_range_product(pw_multi_aff pma2) const;\n  inline stat foreach_piece(const std::function<stat(set, multi_aff)> &fn) const;\n  static inline pw_multi_aff from_domain(set set);\n  static inline pw_multi_aff from_map(map map);\n  static inline pw_multi_aff from_multi_pw_aff(multi_pw_aff mpa);\n  static inline pw_multi_aff from_set(set set);\n  inline id get_dim_id(isl::dim type, unsigned int pos) const;\n  inline std::string get_dim_name(isl::dim type, unsigned int pos) const;\n  inline space get_domain_space() const;\n  inline pw_aff get_pw_aff(int pos) const;\n  inline space get_space() const;\n  inline id get_tuple_id(isl::dim type) const;\n  inline std::string get_tuple_name(isl::dim type) const;\n  inline pw_multi_aff gist(set set) const;\n  inline pw_multi_aff gist_params(set set) const;\n  inline boolean has_tuple_id(isl::dim type) const;\n  inline boolean has_tuple_name(isl::dim type) const;\n  static inline pw_multi_aff identity(space space);\n  static inline pw_multi_aff identity_on_domain(space space);\n  inline pw_multi_aff insert_domain(space domain) const;\n  inline pw_multi_aff intersect_domain(set set) const;\n  inline pw_multi_aff intersect_domain_wrapped_domain(set set) const;\n  inline pw_multi_aff intersect_domain_wrapped_range(set set) const;\n  inline pw_multi_aff intersect_params(set set) const;\n  inline boolean involves_dims(isl::dim type, unsigned int first, unsigned int n) const;\n  inline boolean involves_locals() const;\n  inline boolean involves_nan() const;\n  inline boolean involves_param_id(const id &id) const;\n  inline boolean is_equal(const pw_multi_aff &pma2) const;\n  inline boolean isa_multi_aff() const;\n  inline multi_val max_multi_val() const;\n  inline multi_val min_multi_val() const;\n  static inline pw_multi_aff multi_val_on_domain(set domain, multi_val mv);\n  inline isl_size n_piece() const;\n  inline pw_multi_aff neg() const;\n  inline boolean plain_is_equal(const pw_multi_aff &pma2) const;\n  inline pw_multi_aff preimage_domain_wrapped_domain(pw_multi_aff pma2) const;\n  inline pw_multi_aff product(pw_multi_aff pma2) const;\n  inline pw_multi_aff project_domain_on_params() const;\n  static inline pw_multi_aff project_out_map(space space, isl::dim type, unsigned int first, unsigned int n);\n  inline pw_multi_aff pullback(multi_aff ma) const;\n  inline pw_multi_aff pullback(pw_multi_aff pma2) const;\n  inline pw_multi_aff range_factor_domain() const;\n  inline pw_multi_aff range_factor_range() const;\n  static inline pw_multi_aff range_map(space space);\n  inline pw_multi_aff range_product(pw_multi_aff pma2) const;\n  inline pw_multi_aff reset_tuple_id(isl::dim type) const;\n  inline pw_multi_aff reset_user() const;\n  inline pw_multi_aff scale(val v) const;\n  inline pw_multi_aff scale_down(val v) const;\n  inline pw_multi_aff scale_multi_val(multi_val mv) const;\n  inline pw_multi_aff set_dim_id(isl::dim type, unsigned int pos, id id) const;\n  inline pw_multi_aff set_pw_aff(unsigned int pos, pw_aff pa) const;\n  inline pw_multi_aff set_tuple_id(isl::dim type, id id) const;\n  inline pw_multi_aff sub(pw_multi_aff pma2) const;\n  inline pw_multi_aff subtract_domain(set set) const;\n  inline pw_multi_aff union_add(pw_multi_aff pma2) const;\n  inline pw_multi_aff union_lexmax(pw_multi_aff pma2) const;\n  inline pw_multi_aff union_lexmin(pw_multi_aff pma2) const;\n  static inline pw_multi_aff zero(space space);\n};\n\n// declarations for isl::pw_multi_aff_list\ninline pw_multi_aff_list manage(__isl_take isl_pw_multi_aff_list *ptr);\ninline pw_multi_aff_list manage_copy(__isl_keep isl_pw_multi_aff_list *ptr);\n\nclass pw_multi_aff_list {\n  friend inline pw_multi_aff_list manage(__isl_take isl_pw_multi_aff_list *ptr);\n  friend inline pw_multi_aff_list manage_copy(__isl_keep isl_pw_multi_aff_list *ptr);\n\n  isl_pw_multi_aff_list *ptr = nullptr;\n\n  inline explicit pw_multi_aff_list(__isl_take isl_pw_multi_aff_list *ptr);\n\npublic:\n  inline /* implicit */ pw_multi_aff_list();\n  inline /* implicit */ pw_multi_aff_list(const pw_multi_aff_list &obj);\n  inline /* implicit */ pw_multi_aff_list(std::nullptr_t);\n  inline pw_multi_aff_list &operator=(pw_multi_aff_list obj);\n  inline ~pw_multi_aff_list();\n  inline __isl_give isl_pw_multi_aff_list *copy() const &;\n  inline __isl_give isl_pw_multi_aff_list *copy() && = delete;\n  inline __isl_keep isl_pw_multi_aff_list *get() const;\n  inline __isl_give isl_pw_multi_aff_list *release();\n  inline bool is_null() const;\n  inline explicit operator bool() const;\n  inline ctx get_ctx() const;\n  inline std::string to_str() const;\n  inline void dump() const;\n\n  inline pw_multi_aff_list add(pw_multi_aff el) const;\n  static inline pw_multi_aff_list alloc(ctx ctx, int n);\n  inline pw_multi_aff_list clear() const;\n  inline pw_multi_aff_list concat(pw_multi_aff_list list2) const;\n  inline pw_multi_aff_list drop(unsigned int first, unsigned int n) const;\n  inline stat foreach(const std::function<stat(pw_multi_aff)> &fn) const;\n  static inline pw_multi_aff_list from_pw_multi_aff(pw_multi_aff el);\n  inline pw_multi_aff get_at(int index) const;\n  inline pw_multi_aff get_pw_multi_aff(int index) const;\n  inline pw_multi_aff_list insert(unsigned int pos, pw_multi_aff el) const;\n  inline isl_size n_pw_multi_aff() const;\n  inline pw_multi_aff_list reverse() const;\n  inline pw_multi_aff_list set_pw_multi_aff(int index, pw_multi_aff el) const;\n  inline isl_size size() const;\n  inline pw_multi_aff_list swap(unsigned int pos1, unsigned int pos2) const;\n};\n\n// declarations for isl::pw_qpolynomial\ninline pw_qpolynomial manage(__isl_take isl_pw_qpolynomial *ptr);\ninline pw_qpolynomial manage_copy(__isl_keep isl_pw_qpolynomial *ptr);\n\nclass pw_qpolynomial {\n  friend inline pw_qpolynomial manage(__isl_take isl_pw_qpolynomial *ptr);\n  friend inline pw_qpolynomial manage_copy(__isl_keep isl_pw_qpolynomial *ptr);\n\n  isl_pw_qpolynomial *ptr = nullptr;\n\n  inline explicit pw_qpolynomial(__isl_take isl_pw_qpolynomial *ptr);\n\npublic:\n  inline /* implicit */ pw_qpolynomial();\n  inline /* implicit */ pw_qpolynomial(const pw_qpolynomial &obj);\n  inline /* implicit */ pw_qpolynomial(std::nullptr_t);\n  inline explicit pw_qpolynomial(ctx ctx, const std::string &str);\n  inline pw_qpolynomial &operator=(pw_qpolynomial obj);\n  inline ~pw_qpolynomial();\n  inline __isl_give isl_pw_qpolynomial *copy() const &;\n  inline __isl_give isl_pw_qpolynomial *copy() && = delete;\n  inline __isl_keep isl_pw_qpolynomial *get() const;\n  inline __isl_give isl_pw_qpolynomial *release();\n  inline bool is_null() const;\n  inline explicit operator bool() const;\n  inline ctx get_ctx() const;\n  inline std::string to_str() const;\n  inline void dump() const;\n\n  inline pw_qpolynomial add(pw_qpolynomial pwqp2) const;\n  inline pw_qpolynomial add_dims(isl::dim type, unsigned int n) const;\n  static inline pw_qpolynomial alloc(set set, qpolynomial qp);\n  inline qpolynomial as_qpolynomial() const;\n  inline pw_qpolynomial coalesce() const;\n  inline isl_size dim(isl::dim type) const;\n  inline set domain() const;\n  inline pw_qpolynomial drop_dims(isl::dim type, unsigned int first, unsigned int n) const;\n  inline pw_qpolynomial drop_unused_params() const;\n  inline val eval(point pnt) const;\n  inline int find_dim_by_name(isl::dim type, const std::string &name) const;\n  inline pw_qpolynomial fix_val(isl::dim type, unsigned int n, val v) const;\n  inline stat foreach_piece(const std::function<stat(set, qpolynomial)> &fn) const;\n  static inline pw_qpolynomial from_pw_aff(pw_aff pwaff);\n  static inline pw_qpolynomial from_qpolynomial(qpolynomial qp);\n  inline pw_qpolynomial from_range() const;\n  inline space get_domain_space() const;\n  inline space get_space() const;\n  inline pw_qpolynomial gist(set context) const;\n  inline pw_qpolynomial gist_params(set context) const;\n  inline boolean has_equal_space(const pw_qpolynomial &pwqp2) const;\n  inline pw_qpolynomial insert_dims(isl::dim type, unsigned int first, unsigned int n) const;\n  inline pw_qpolynomial intersect_domain(set set) const;\n  inline pw_qpolynomial intersect_domain_wrapped_domain(set set) const;\n  inline pw_qpolynomial intersect_domain_wrapped_range(set set) const;\n  inline pw_qpolynomial intersect_params(set set) const;\n  inline boolean involves_dims(isl::dim type, unsigned int first, unsigned int n) const;\n  inline boolean involves_nan() const;\n  inline boolean involves_param_id(const id &id) const;\n  inline boolean is_zero() const;\n  inline boolean isa_qpolynomial() const;\n  inline val max() const;\n  inline val min() const;\n  inline pw_qpolynomial move_dims(isl::dim dst_type, unsigned int dst_pos, isl::dim src_type, unsigned int src_pos, unsigned int n) const;\n  inline pw_qpolynomial mul(pw_qpolynomial pwqp2) const;\n  inline isl_size n_piece() const;\n  inline pw_qpolynomial neg() const;\n  inline boolean plain_is_equal(const pw_qpolynomial &pwqp2) const;\n  inline pw_qpolynomial pow(unsigned int exponent) const;\n  inline pw_qpolynomial project_domain_on_params() const;\n  inline pw_qpolynomial reset_domain_space(space space) const;\n  inline pw_qpolynomial reset_user() const;\n  inline pw_qpolynomial scale_down_val(val v) const;\n  inline pw_qpolynomial scale_val(val v) const;\n  inline pw_qpolynomial split_dims(isl::dim type, unsigned int first, unsigned int n) const;\n  inline pw_qpolynomial split_periods(int max_periods) const;\n  inline pw_qpolynomial sub(pw_qpolynomial pwqp2) const;\n  inline pw_qpolynomial subtract_domain(set set) const;\n  inline pw_qpolynomial to_polynomial(int sign) const;\n  static inline pw_qpolynomial zero(space space);\n};\n\n// declarations for isl::pw_qpolynomial_fold_list\ninline pw_qpolynomial_fold_list manage(__isl_take isl_pw_qpolynomial_fold_list *ptr);\ninline pw_qpolynomial_fold_list manage_copy(__isl_keep isl_pw_qpolynomial_fold_list *ptr);\n\nclass pw_qpolynomial_fold_list {\n  friend inline pw_qpolynomial_fold_list manage(__isl_take isl_pw_qpolynomial_fold_list *ptr);\n  friend inline pw_qpolynomial_fold_list manage_copy(__isl_keep isl_pw_qpolynomial_fold_list *ptr);\n\n  isl_pw_qpolynomial_fold_list *ptr = nullptr;\n\n  inline explicit pw_qpolynomial_fold_list(__isl_take isl_pw_qpolynomial_fold_list *ptr);\n\npublic:\n  inline /* implicit */ pw_qpolynomial_fold_list();\n  inline /* implicit */ pw_qpolynomial_fold_list(const pw_qpolynomial_fold_list &obj);\n  inline /* implicit */ pw_qpolynomial_fold_list(std::nullptr_t);\n  inline pw_qpolynomial_fold_list &operator=(pw_qpolynomial_fold_list obj);\n  inline ~pw_qpolynomial_fold_list();\n  inline __isl_give isl_pw_qpolynomial_fold_list *copy() const &;\n  inline __isl_give isl_pw_qpolynomial_fold_list *copy() && = delete;\n  inline __isl_keep isl_pw_qpolynomial_fold_list *get() const;\n  inline __isl_give isl_pw_qpolynomial_fold_list *release();\n  inline bool is_null() const;\n  inline explicit operator bool() const;\n  inline ctx get_ctx() const;\n  inline std::string to_str() const;\n  inline void dump() const;\n\n};\n\n// declarations for isl::pw_qpolynomial_list\ninline pw_qpolynomial_list manage(__isl_take isl_pw_qpolynomial_list *ptr);\ninline pw_qpolynomial_list manage_copy(__isl_keep isl_pw_qpolynomial_list *ptr);\n\nclass pw_qpolynomial_list {\n  friend inline pw_qpolynomial_list manage(__isl_take isl_pw_qpolynomial_list *ptr);\n  friend inline pw_qpolynomial_list manage_copy(__isl_keep isl_pw_qpolynomial_list *ptr);\n\n  isl_pw_qpolynomial_list *ptr = nullptr;\n\n  inline explicit pw_qpolynomial_list(__isl_take isl_pw_qpolynomial_list *ptr);\n\npublic:\n  inline /* implicit */ pw_qpolynomial_list();\n  inline /* implicit */ pw_qpolynomial_list(const pw_qpolynomial_list &obj);\n  inline /* implicit */ pw_qpolynomial_list(std::nullptr_t);\n  inline pw_qpolynomial_list &operator=(pw_qpolynomial_list obj);\n  inline ~pw_qpolynomial_list();\n  inline __isl_give isl_pw_qpolynomial_list *copy() const &;\n  inline __isl_give isl_pw_qpolynomial_list *copy() && = delete;\n  inline __isl_keep isl_pw_qpolynomial_list *get() const;\n  inline __isl_give isl_pw_qpolynomial_list *release();\n  inline bool is_null() const;\n  inline explicit operator bool() const;\n  inline ctx get_ctx() const;\n  inline std::string to_str() const;\n  inline void dump() const;\n\n  inline pw_qpolynomial_list add(pw_qpolynomial el) const;\n  static inline pw_qpolynomial_list alloc(ctx ctx, int n);\n  inline pw_qpolynomial_list clear() const;\n  inline pw_qpolynomial_list concat(pw_qpolynomial_list list2) const;\n  inline pw_qpolynomial_list drop(unsigned int first, unsigned int n) const;\n  inline stat foreach(const std::function<stat(pw_qpolynomial)> &fn) const;\n  static inline pw_qpolynomial_list from_pw_qpolynomial(pw_qpolynomial el);\n  inline pw_qpolynomial get_at(int index) const;\n  inline pw_qpolynomial get_pw_qpolynomial(int index) const;\n  inline pw_qpolynomial_list insert(unsigned int pos, pw_qpolynomial el) const;\n  inline isl_size n_pw_qpolynomial() const;\n  inline pw_qpolynomial_list reverse() const;\n  inline pw_qpolynomial_list set_pw_qpolynomial(int index, pw_qpolynomial el) const;\n  inline isl_size size() const;\n  inline pw_qpolynomial_list swap(unsigned int pos1, unsigned int pos2) const;\n};\n\n// declarations for isl::qpolynomial\ninline qpolynomial manage(__isl_take isl_qpolynomial *ptr);\ninline qpolynomial manage_copy(__isl_keep isl_qpolynomial *ptr);\n\nclass qpolynomial {\n  friend inline qpolynomial manage(__isl_take isl_qpolynomial *ptr);\n  friend inline qpolynomial manage_copy(__isl_keep isl_qpolynomial *ptr);\n\n  isl_qpolynomial *ptr = nullptr;\n\n  inline explicit qpolynomial(__isl_take isl_qpolynomial *ptr);\n\npublic:\n  inline /* implicit */ qpolynomial();\n  inline /* implicit */ qpolynomial(const qpolynomial &obj);\n  inline /* implicit */ qpolynomial(std::nullptr_t);\n  inline qpolynomial &operator=(qpolynomial obj);\n  inline ~qpolynomial();\n  inline __isl_give isl_qpolynomial *copy() const &;\n  inline __isl_give isl_qpolynomial *copy() && = delete;\n  inline __isl_keep isl_qpolynomial *get() const;\n  inline __isl_give isl_qpolynomial *release();\n  inline bool is_null() const;\n  inline explicit operator bool() const;\n  inline ctx get_ctx() const;\n  inline void dump() const;\n\n  inline qpolynomial add(qpolynomial qp2) const;\n  inline qpolynomial add_dims(isl::dim type, unsigned int n) const;\n  inline qpolynomial align_params(space model) const;\n  inline stat as_polynomial_on_domain(const basic_set &bset, const std::function<stat(basic_set, qpolynomial)> &fn) const;\n  inline isl_size dim(isl::dim type) const;\n  inline qpolynomial drop_dims(isl::dim type, unsigned int first, unsigned int n) const;\n  inline val eval(point pnt) const;\n  inline stat foreach_term(const std::function<stat(term)> &fn) const;\n  static inline qpolynomial from_aff(aff aff);\n  static inline qpolynomial from_constraint(constraint c, isl::dim type, unsigned int pos);\n  static inline qpolynomial from_term(term term);\n  inline val get_constant_val() const;\n  inline space get_domain_space() const;\n  inline space get_space() const;\n  inline qpolynomial gist(set context) const;\n  inline qpolynomial gist_params(set context) const;\n  inline qpolynomial homogenize() const;\n  static inline qpolynomial infty_on_domain(space domain);\n  inline qpolynomial insert_dims(isl::dim type, unsigned int first, unsigned int n) const;\n  inline boolean involves_dims(isl::dim type, unsigned int first, unsigned int n) const;\n  inline boolean is_infty() const;\n  inline boolean is_nan() const;\n  inline boolean is_neginfty() const;\n  inline boolean is_zero() const;\n  inline qpolynomial move_dims(isl::dim dst_type, unsigned int dst_pos, isl::dim src_type, unsigned int src_pos, unsigned int n) const;\n  inline qpolynomial mul(qpolynomial qp2) const;\n  static inline qpolynomial nan_on_domain(space domain);\n  inline qpolynomial neg() const;\n  static inline qpolynomial neginfty_on_domain(space domain);\n  static inline qpolynomial one_on_domain(space domain);\n  inline boolean plain_is_equal(const qpolynomial &qp2) const;\n  inline qpolynomial pow(unsigned int power) const;\n  inline qpolynomial project_domain_on_params() const;\n  inline qpolynomial scale_down_val(val v) const;\n  inline qpolynomial scale_val(val v) const;\n  inline int sgn() const;\n  inline qpolynomial sub(qpolynomial qp2) const;\n  static inline qpolynomial val_on_domain(space space, val val);\n  static inline qpolynomial var_on_domain(space domain, isl::dim type, unsigned int pos);\n  static inline qpolynomial zero_on_domain(space domain);\n};\n\n// declarations for isl::qpolynomial_list\ninline qpolynomial_list manage(__isl_take isl_qpolynomial_list *ptr);\ninline qpolynomial_list manage_copy(__isl_keep isl_qpolynomial_list *ptr);\n\nclass qpolynomial_list {\n  friend inline qpolynomial_list manage(__isl_take isl_qpolynomial_list *ptr);\n  friend inline qpolynomial_list manage_copy(__isl_keep isl_qpolynomial_list *ptr);\n\n  isl_qpolynomial_list *ptr = nullptr;\n\n  inline explicit qpolynomial_list(__isl_take isl_qpolynomial_list *ptr);\n\npublic:\n  inline /* implicit */ qpolynomial_list();\n  inline /* implicit */ qpolynomial_list(const qpolynomial_list &obj);\n  inline /* implicit */ qpolynomial_list(std::nullptr_t);\n  inline qpolynomial_list &operator=(qpolynomial_list obj);\n  inline ~qpolynomial_list();\n  inline __isl_give isl_qpolynomial_list *copy() const &;\n  inline __isl_give isl_qpolynomial_list *copy() && = delete;\n  inline __isl_keep isl_qpolynomial_list *get() const;\n  inline __isl_give isl_qpolynomial_list *release();\n  inline bool is_null() const;\n  inline explicit operator bool() const;\n  inline ctx get_ctx() const;\n  inline std::string to_str() const;\n  inline void dump() const;\n\n  inline qpolynomial_list add(qpolynomial el) const;\n  static inline qpolynomial_list alloc(ctx ctx, int n);\n  inline qpolynomial_list clear() const;\n  inline qpolynomial_list concat(qpolynomial_list list2) const;\n  inline qpolynomial_list drop(unsigned int first, unsigned int n) const;\n  inline stat foreach(const std::function<stat(qpolynomial)> &fn) const;\n  static inline qpolynomial_list from_qpolynomial(qpolynomial el);\n  inline qpolynomial get_at(int index) const;\n  inline qpolynomial get_qpolynomial(int index) const;\n  inline qpolynomial_list insert(unsigned int pos, qpolynomial el) const;\n  inline isl_size n_qpolynomial() const;\n  inline qpolynomial_list reverse() const;\n  inline qpolynomial_list set_qpolynomial(int index, qpolynomial el) const;\n  inline isl_size size() const;\n  inline qpolynomial_list swap(unsigned int pos1, unsigned int pos2) const;\n};\n\n// declarations for isl::schedule\ninline schedule manage(__isl_take isl_schedule *ptr);\ninline schedule manage_copy(__isl_keep isl_schedule *ptr);\n\nclass schedule {\n  friend inline schedule manage(__isl_take isl_schedule *ptr);\n  friend inline schedule manage_copy(__isl_keep isl_schedule *ptr);\n\n  isl_schedule *ptr = nullptr;\n\n  inline explicit schedule(__isl_take isl_schedule *ptr);\n\npublic:\n  inline /* implicit */ schedule();\n  inline /* implicit */ schedule(const schedule &obj);\n  inline /* implicit */ schedule(std::nullptr_t);\n  inline explicit schedule(ctx ctx, const std::string &str);\n  inline schedule &operator=(schedule obj);\n  inline ~schedule();\n  inline __isl_give isl_schedule *copy() const &;\n  inline __isl_give isl_schedule *copy() && = delete;\n  inline __isl_keep isl_schedule *get() const;\n  inline __isl_give isl_schedule *release();\n  inline bool is_null() const;\n  inline explicit operator bool() const;\n  inline ctx get_ctx() const;\n  inline std::string to_str() const;\n  inline void dump() const;\n\n  inline schedule align_params(space space) const;\n  static inline schedule empty(space space);\n  static inline schedule from_domain(union_set domain);\n  inline union_set get_domain() const;\n  inline union_map get_map() const;\n  inline schedule_node get_root() const;\n  inline schedule gist_domain_params(set context) const;\n  inline schedule insert_context(set context) const;\n  inline schedule insert_guard(set guard) const;\n  inline schedule insert_partial_schedule(multi_union_pw_aff partial) const;\n  inline schedule intersect_domain(union_set domain) const;\n  inline boolean plain_is_equal(const schedule &schedule2) const;\n  inline schedule pullback(union_pw_multi_aff upma) const;\n  inline schedule reset_user() const;\n  inline schedule sequence(schedule schedule2) const;\n};\n\n// declarations for isl::schedule_constraints\ninline schedule_constraints manage(__isl_take isl_schedule_constraints *ptr);\ninline schedule_constraints manage_copy(__isl_keep isl_schedule_constraints *ptr);\n\nclass schedule_constraints {\n  friend inline schedule_constraints manage(__isl_take isl_schedule_constraints *ptr);\n  friend inline schedule_constraints manage_copy(__isl_keep isl_schedule_constraints *ptr);\n\n  isl_schedule_constraints *ptr = nullptr;\n\n  inline explicit schedule_constraints(__isl_take isl_schedule_constraints *ptr);\n\npublic:\n  inline /* implicit */ schedule_constraints();\n  inline /* implicit */ schedule_constraints(const schedule_constraints &obj);\n  inline /* implicit */ schedule_constraints(std::nullptr_t);\n  inline explicit schedule_constraints(ctx ctx, const std::string &str);\n  inline schedule_constraints &operator=(schedule_constraints obj);\n  inline ~schedule_constraints();\n  inline __isl_give isl_schedule_constraints *copy() const &;\n  inline __isl_give isl_schedule_constraints *copy() && = delete;\n  inline __isl_keep isl_schedule_constraints *get() const;\n  inline __isl_give isl_schedule_constraints *release();\n  inline bool is_null() const;\n  inline explicit operator bool() const;\n  inline ctx get_ctx() const;\n  inline std::string to_str() const;\n  inline void dump() const;\n\n  inline schedule_constraints apply(union_map umap) const;\n  inline schedule compute_schedule() const;\n  inline union_map get_coincidence() const;\n  inline union_map get_conditional_validity() const;\n  inline union_map get_conditional_validity_condition() const;\n  inline set get_context() const;\n  inline union_set get_domain() const;\n  inline union_map get_proximity() const;\n  inline union_map get_validity() const;\n  static inline schedule_constraints on_domain(union_set domain);\n  inline schedule_constraints set_coincidence(union_map coincidence) const;\n  inline schedule_constraints set_conditional_validity(union_map condition, union_map validity) const;\n  inline schedule_constraints set_context(set context) const;\n  inline schedule_constraints set_proximity(union_map proximity) const;\n  inline schedule_constraints set_validity(union_map validity) const;\n};\n\n// declarations for isl::schedule_node\ninline schedule_node manage(__isl_take isl_schedule_node *ptr);\ninline schedule_node manage_copy(__isl_keep isl_schedule_node *ptr);\n\nclass schedule_node {\n  friend inline schedule_node manage(__isl_take isl_schedule_node *ptr);\n  friend inline schedule_node manage_copy(__isl_keep isl_schedule_node *ptr);\n\n  isl_schedule_node *ptr = nullptr;\n\n  inline explicit schedule_node(__isl_take isl_schedule_node *ptr);\n\npublic:\n  inline /* implicit */ schedule_node();\n  inline /* implicit */ schedule_node(const schedule_node &obj);\n  inline /* implicit */ schedule_node(std::nullptr_t);\n  inline schedule_node &operator=(schedule_node obj);\n  inline ~schedule_node();\n  inline __isl_give isl_schedule_node *copy() const &;\n  inline __isl_give isl_schedule_node *copy() && = delete;\n  inline __isl_keep isl_schedule_node *get() const;\n  inline __isl_give isl_schedule_node *release();\n  inline bool is_null() const;\n  inline explicit operator bool() const;\n  inline ctx get_ctx() const;\n  inline std::string to_str() const;\n  inline void dump() const;\n\n  inline schedule_node align_params(space space) const;\n  inline schedule_node ancestor(int generation) const;\n  inline boolean band_member_get_coincident(int pos) const;\n  inline schedule_node band_member_set_coincident(int pos, int coincident) const;\n  inline schedule_node band_set_ast_build_options(union_set options) const;\n  inline schedule_node child(int pos) const;\n  inline set context_get_context() const;\n  inline schedule_node cut() const;\n  inline union_set domain_get_domain() const;\n  inline union_pw_multi_aff expansion_get_contraction() const;\n  inline union_map expansion_get_expansion() const;\n  inline union_map extension_get_extension() const;\n  inline union_set filter_get_filter() const;\n  inline schedule_node first_child() const;\n  inline stat foreach_ancestor_top_down(const std::function<stat(schedule_node)> &fn) const;\n  static inline schedule_node from_domain(union_set domain);\n  static inline schedule_node from_extension(union_map extension);\n  inline isl_size get_ancestor_child_position(const schedule_node &ancestor) const;\n  inline schedule_node get_child(int pos) const;\n  inline isl_size get_child_position() const;\n  inline union_set get_domain() const;\n  inline multi_union_pw_aff get_prefix_schedule_multi_union_pw_aff() const;\n  inline union_map get_prefix_schedule_relation() const;\n  inline union_map get_prefix_schedule_union_map() const;\n  inline union_pw_multi_aff get_prefix_schedule_union_pw_multi_aff() const;\n  inline schedule get_schedule() const;\n  inline isl_size get_schedule_depth() const;\n  inline schedule_node get_shared_ancestor(const schedule_node &node2) const;\n  inline union_pw_multi_aff get_subtree_contraction() const;\n  inline union_map get_subtree_expansion() const;\n  inline union_map get_subtree_schedule_union_map() const;\n  inline isl_size get_tree_depth() const;\n  inline union_set get_universe_domain() const;\n  inline schedule_node graft_after(schedule_node graft) const;\n  inline schedule_node graft_before(schedule_node graft) const;\n  inline schedule_node group(id group_id) const;\n  inline set guard_get_guard() const;\n  inline boolean has_children() const;\n  inline boolean has_next_sibling() const;\n  inline boolean has_parent() const;\n  inline boolean has_previous_sibling() const;\n  inline schedule_node insert_context(set context) const;\n  inline schedule_node insert_filter(union_set filter) const;\n  inline schedule_node insert_guard(set context) const;\n  inline schedule_node insert_mark(id mark) const;\n  inline schedule_node insert_partial_schedule(multi_union_pw_aff schedule) const;\n  inline schedule_node insert_sequence(union_set_list filters) const;\n  inline schedule_node insert_set(union_set_list filters) const;\n  inline boolean is_equal(const schedule_node &node2) const;\n  inline boolean is_subtree_anchored() const;\n  inline id mark_get_id() const;\n  inline isl_size n_children() const;\n  inline schedule_node next_sibling() const;\n  inline schedule_node order_after(union_set filter) const;\n  inline schedule_node order_before(union_set filter) const;\n  inline schedule_node parent() const;\n  inline schedule_node previous_sibling() const;\n  inline schedule_node reset_user() const;\n  inline schedule_node root() const;\n  inline schedule_node sequence_splice_child(int pos) const;\n};\n\n// declarations for isl::set\ninline set manage(__isl_take isl_set *ptr);\ninline set manage_copy(__isl_keep isl_set *ptr);\n\nclass set {\n  friend inline set manage(__isl_take isl_set *ptr);\n  friend inline set manage_copy(__isl_keep isl_set *ptr);\n\n  isl_set *ptr = nullptr;\n\n  inline explicit set(__isl_take isl_set *ptr);\n\npublic:\n  inline /* implicit */ set();\n  inline /* implicit */ set(const set &obj);\n  inline /* implicit */ set(std::nullptr_t);\n  inline /* implicit */ set(basic_set bset);\n  inline /* implicit */ set(point pnt);\n  inline explicit set(union_set uset);\n  inline explicit set(ctx ctx, const std::string &str);\n  inline set &operator=(set obj);\n  inline ~set();\n  inline __isl_give isl_set *copy() const &;\n  inline __isl_give isl_set *copy() && = delete;\n  inline __isl_keep isl_set *get() const;\n  inline __isl_give isl_set *release();\n  inline bool is_null() const;\n  inline explicit operator bool() const;\n  inline ctx get_ctx() const;\n  inline std::string to_str() const;\n  inline void dump() const;\n\n  inline set add_constraint(constraint constraint) const;\n  inline set add_dims(isl::dim type, unsigned int n) const;\n  inline basic_set affine_hull() const;\n  inline set align_params(space model) const;\n  inline set apply(map map) const;\n  inline set bind(multi_id tuple) const;\n  inline basic_set bounded_simple_hull() const;\n  static inline set box_from_points(point pnt1, point pnt2);\n  inline set coalesce() const;\n  inline basic_set coefficients() const;\n  inline set complement() const;\n  inline basic_set convex_hull() const;\n  inline val count_val() const;\n  inline set detect_equalities() const;\n  inline isl_size dim(isl::dim type) const;\n  inline boolean dim_has_any_lower_bound(isl::dim type, unsigned int pos) const;\n  inline boolean dim_has_any_upper_bound(isl::dim type, unsigned int pos) const;\n  inline boolean dim_has_lower_bound(isl::dim type, unsigned int pos) const;\n  inline boolean dim_has_upper_bound(isl::dim type, unsigned int pos) const;\n  inline boolean dim_is_bounded(isl::dim type, unsigned int pos) const;\n  inline pw_aff dim_max(int pos) const;\n  inline val dim_max_val(int pos) const;\n  inline pw_aff dim_min(int pos) const;\n  inline val dim_min_val(int pos) const;\n  inline set drop_constraints_involving_dims(isl::dim type, unsigned int first, unsigned int n) const;\n  inline set drop_constraints_not_involving_dims(isl::dim type, unsigned int first, unsigned int n) const;\n  inline set drop_unused_params() const;\n  inline set eliminate(isl::dim type, unsigned int first, unsigned int n) const;\n  static inline set empty(space space);\n  inline set equate(isl::dim type1, int pos1, isl::dim type2, int pos2) const;\n  inline int find_dim_by_id(isl::dim type, const id &id) const;\n  inline int find_dim_by_name(isl::dim type, const std::string &name) const;\n  inline set fix_si(isl::dim type, unsigned int pos, int value) const;\n  inline set fix_val(isl::dim type, unsigned int pos, val v) const;\n  inline set flat_product(set set2) const;\n  inline set flatten() const;\n  inline map flatten_map() const;\n  inline int follows_at(const set &set2, int pos) const;\n  inline stat foreach_basic_set(const std::function<stat(basic_set)> &fn) const;\n  inline stat foreach_point(const std::function<stat(point)> &fn) const;\n  static inline set from_multi_aff(multi_aff ma);\n  static inline set from_multi_pw_aff(multi_pw_aff mpa);\n  inline set from_params() const;\n  static inline set from_pw_aff(pw_aff pwaff);\n  static inline set from_pw_multi_aff(pw_multi_aff pma);\n  inline basic_set_list get_basic_set_list() const;\n  inline id get_dim_id(isl::dim type, unsigned int pos) const;\n  inline std::string get_dim_name(isl::dim type, unsigned int pos) const;\n  inline multi_val get_plain_multi_val_if_fixed() const;\n  inline fixed_box get_simple_fixed_box_hull() const;\n  inline space get_space() const;\n  inline val get_stride(int pos) const;\n  inline id get_tuple_id() const;\n  inline std::string get_tuple_name() const;\n  inline set gist(set context) const;\n  inline set gist_basic_set(basic_set context) const;\n  inline set gist_params(set context) const;\n  inline boolean has_dim_id(isl::dim type, unsigned int pos) const;\n  inline boolean has_dim_name(isl::dim type, unsigned int pos) const;\n  inline boolean has_equal_space(const set &set2) const;\n  inline boolean has_tuple_id() const;\n  inline boolean has_tuple_name() const;\n  inline map identity() const;\n  inline pw_aff indicator_function() const;\n  inline set insert_dims(isl::dim type, unsigned int pos, unsigned int n) const;\n  inline map insert_domain(space domain) const;\n  inline set intersect(set set2) const;\n  inline set intersect_factor_domain(set domain) const;\n  inline set intersect_factor_range(set range) const;\n  inline set intersect_params(set params) const;\n  inline boolean involves_dims(isl::dim type, unsigned int first, unsigned int n) const;\n  inline boolean involves_locals() const;\n  inline boolean is_bounded() const;\n  inline boolean is_box() const;\n  inline boolean is_disjoint(const set &set2) const;\n  inline boolean is_empty() const;\n  inline boolean is_equal(const set &set2) const;\n  inline boolean is_params() const;\n  inline boolean is_singleton() const;\n  inline boolean is_strict_subset(const set &set2) const;\n  inline boolean is_subset(const set &set2) const;\n  inline boolean is_wrapping() const;\n  inline map lex_ge_set(set set2) const;\n  inline map lex_gt_set(set set2) const;\n  inline map lex_le_set(set set2) const;\n  inline map lex_lt_set(set set2) const;\n  inline set lexmax() const;\n  inline pw_multi_aff lexmax_pw_multi_aff() const;\n  inline set lexmin() const;\n  inline pw_multi_aff lexmin_pw_multi_aff() const;\n  inline set lower_bound(multi_pw_aff lower) const;\n  inline set lower_bound(multi_val lower) const;\n  inline set lower_bound_si(isl::dim type, unsigned int pos, int value) const;\n  inline set lower_bound_val(isl::dim type, unsigned int pos, val value) const;\n  inline multi_pw_aff max_multi_pw_aff() const;\n  inline val max_val(const aff &obj) const;\n  inline multi_pw_aff min_multi_pw_aff() const;\n  inline val min_val(const aff &obj) const;\n  inline set move_dims(isl::dim dst_type, unsigned int dst_pos, isl::dim src_type, unsigned int src_pos, unsigned int n) const;\n  inline isl_size n_basic_set() const;\n  inline isl_size n_dim() const;\n  static inline set nat_universe(space space);\n  inline set neg() const;\n  inline set params() const;\n  inline int plain_cmp(const set &set2) const;\n  inline val plain_get_val_if_fixed(isl::dim type, unsigned int pos) const;\n  inline boolean plain_is_disjoint(const set &set2) const;\n  inline boolean plain_is_empty() const;\n  inline boolean plain_is_equal(const set &set2) const;\n  inline boolean plain_is_universe() const;\n  inline basic_set plain_unshifted_simple_hull() const;\n  inline basic_set polyhedral_hull() const;\n  inline set preimage(multi_aff ma) const;\n  inline set preimage(multi_pw_aff mpa) const;\n  inline set preimage(pw_multi_aff pma) const;\n  inline set product(set set2) const;\n  inline map project_onto_map(isl::dim type, unsigned int first, unsigned int n) const;\n  inline set project_out(isl::dim type, unsigned int first, unsigned int n) const;\n  inline set project_out_all_params() const;\n  inline set project_out_param(id id) const;\n  inline set project_out_param(id_list list) const;\n  inline set remove_dims(isl::dim type, unsigned int first, unsigned int n) const;\n  inline set remove_divs() const;\n  inline set remove_divs_involving_dims(isl::dim type, unsigned int first, unsigned int n) const;\n  inline set remove_redundancies() const;\n  inline set remove_unknown_divs() const;\n  inline set reset_space(space space) const;\n  inline set reset_tuple_id() const;\n  inline set reset_user() const;\n  inline basic_set sample() const;\n  inline point sample_point() const;\n  inline set set_dim_id(isl::dim type, unsigned int pos, id id) const;\n  inline set set_tuple_id(id id) const;\n  inline set set_tuple_name(const std::string &s) const;\n  inline basic_set simple_hull() const;\n  inline int size() const;\n  inline basic_set solutions() const;\n  inline set split_dims(isl::dim type, unsigned int first, unsigned int n) const;\n  inline set subtract(set set2) const;\n  inline set sum(set set2) const;\n  inline map translation() const;\n  inline set unbind_params(multi_id tuple) const;\n  inline map unbind_params_insert_domain(multi_id domain) const;\n  inline set unite(set set2) const;\n  static inline set universe(space space);\n  inline basic_set unshifted_simple_hull() const;\n  inline basic_set unshifted_simple_hull_from_set_list(set_list list) const;\n  inline map unwrap() const;\n  inline set upper_bound(multi_pw_aff upper) const;\n  inline set upper_bound(multi_val upper) const;\n  inline set upper_bound_si(isl::dim type, unsigned int pos, int value) const;\n  inline set upper_bound_val(isl::dim type, unsigned int pos, val value) const;\n  inline map wrapped_domain_map() const;\n};\n\n// declarations for isl::set_list\ninline set_list manage(__isl_take isl_set_list *ptr);\ninline set_list manage_copy(__isl_keep isl_set_list *ptr);\n\nclass set_list {\n  friend inline set_list manage(__isl_take isl_set_list *ptr);\n  friend inline set_list manage_copy(__isl_keep isl_set_list *ptr);\n\n  isl_set_list *ptr = nullptr;\n\n  inline explicit set_list(__isl_take isl_set_list *ptr);\n\npublic:\n  inline /* implicit */ set_list();\n  inline /* implicit */ set_list(const set_list &obj);\n  inline /* implicit */ set_list(std::nullptr_t);\n  inline set_list &operator=(set_list obj);\n  inline ~set_list();\n  inline __isl_give isl_set_list *copy() const &;\n  inline __isl_give isl_set_list *copy() && = delete;\n  inline __isl_keep isl_set_list *get() const;\n  inline __isl_give isl_set_list *release();\n  inline bool is_null() const;\n  inline explicit operator bool() const;\n  inline ctx get_ctx() const;\n  inline std::string to_str() const;\n  inline void dump() const;\n\n  inline set_list add(set el) const;\n  static inline set_list alloc(ctx ctx, int n);\n  inline set_list clear() const;\n  inline set_list concat(set_list list2) const;\n  inline set_list drop(unsigned int first, unsigned int n) const;\n  inline stat foreach(const std::function<stat(set)> &fn) const;\n  static inline set_list from_set(set el);\n  inline set get_at(int index) const;\n  inline set get_set(int index) const;\n  inline set_list insert(unsigned int pos, set el) const;\n  inline isl_size n_set() const;\n  inline set_list reverse() const;\n  inline set_list set_set(int index, set el) const;\n  inline isl_size size() const;\n  inline set_list swap(unsigned int pos1, unsigned int pos2) const;\n  inline set unite() const;\n};\n\n// declarations for isl::space\ninline space manage(__isl_take isl_space *ptr);\ninline space manage_copy(__isl_keep isl_space *ptr);\n\nclass space {\n  friend inline space manage(__isl_take isl_space *ptr);\n  friend inline space manage_copy(__isl_keep isl_space *ptr);\n\n  isl_space *ptr = nullptr;\n\n  inline explicit space(__isl_take isl_space *ptr);\n\npublic:\n  inline /* implicit */ space();\n  inline /* implicit */ space(const space &obj);\n  inline /* implicit */ space(std::nullptr_t);\n  inline explicit space(ctx ctx, unsigned int nparam, unsigned int n_in, unsigned int n_out);\n  inline explicit space(ctx ctx, unsigned int nparam, unsigned int dim);\n  inline space &operator=(space obj);\n  inline ~space();\n  inline __isl_give isl_space *copy() const &;\n  inline __isl_give isl_space *copy() && = delete;\n  inline __isl_keep isl_space *get() const;\n  inline __isl_give isl_space *release();\n  inline bool is_null() const;\n  inline explicit operator bool() const;\n  inline ctx get_ctx() const;\n  inline std::string to_str() const;\n  inline void dump() const;\n\n  inline space add_dims(isl::dim type, unsigned int n) const;\n  inline space add_named_tuple(id tuple_id, unsigned int dim) const;\n  inline space add_param_id(id id) const;\n  inline space add_unnamed_tuple(unsigned int dim) const;\n  inline space align_params(space space2) const;\n  inline boolean can_curry() const;\n  inline boolean can_range_curry() const;\n  inline boolean can_uncurry() const;\n  inline boolean can_zip() const;\n  inline space curry() const;\n  inline isl_size dim(isl::dim type) const;\n  inline space domain() const;\n  inline space domain_factor_domain() const;\n  inline space domain_factor_range() const;\n  inline boolean domain_is_wrapping() const;\n  inline space domain_map() const;\n  inline space domain_product(space right) const;\n  inline space drop_all_params() const;\n  inline space drop_dims(isl::dim type, unsigned int first, unsigned int num) const;\n  inline space factor_domain() const;\n  inline space factor_range() const;\n  inline int find_dim_by_id(isl::dim type, const id &id) const;\n  inline int find_dim_by_name(isl::dim type, const std::string &name) const;\n  inline space flatten_domain() const;\n  inline space flatten_range() const;\n  inline space from_domain() const;\n  inline space from_range() const;\n  inline id get_dim_id(isl::dim type, unsigned int pos) const;\n  inline std::string get_dim_name(isl::dim type, unsigned int pos) const;\n  inline id get_tuple_id(isl::dim type) const;\n  inline std::string get_tuple_name(isl::dim type) const;\n  inline boolean has_dim_id(isl::dim type, unsigned int pos) const;\n  inline boolean has_dim_name(isl::dim type, unsigned int pos) const;\n  inline boolean has_equal_params(const space &space2) const;\n  inline boolean has_equal_tuples(const space &space2) const;\n  inline boolean has_tuple_id(isl::dim type) const;\n  inline boolean has_tuple_name(isl::dim type) const;\n  inline space insert_dims(isl::dim type, unsigned int pos, unsigned int n) const;\n  inline boolean is_domain(const space &space2) const;\n  inline boolean is_equal(const space &space2) const;\n  inline boolean is_map() const;\n  inline boolean is_params() const;\n  inline boolean is_product() const;\n  inline boolean is_range(const space &space2) const;\n  inline boolean is_set() const;\n  inline boolean is_wrapping() const;\n  inline space join(space right) const;\n  inline space map_from_domain_and_range(space range) const;\n  inline space map_from_set() const;\n  inline space move_dims(isl::dim dst_type, unsigned int dst_pos, isl::dim src_type, unsigned int src_pos, unsigned int n) const;\n  inline space params() const;\n  static inline space params_alloc(ctx ctx, unsigned int nparam);\n  inline space product(space right) const;\n  inline space range() const;\n  inline space range_curry() const;\n  inline space range_factor_domain() const;\n  inline space range_factor_range() const;\n  inline boolean range_is_wrapping() const;\n  inline space range_map() const;\n  inline space range_product(space right) const;\n  inline space range_reverse() const;\n  inline space reset_tuple_id(isl::dim type) const;\n  inline space reset_user() const;\n  inline space reverse() const;\n  inline space set_dim_id(isl::dim type, unsigned int pos, id id) const;\n  inline space set_from_params() const;\n  inline space set_tuple_id(isl::dim type, id id) const;\n  inline space set_tuple_name(isl::dim type, const std::string &s) const;\n  inline boolean tuple_is_equal(isl::dim type1, const space &space2, isl::dim type2) const;\n  inline space uncurry() const;\n  static inline space unit(ctx ctx);\n  inline space unwrap() const;\n  inline space wrap() const;\n  inline space zip() const;\n};\n\n// declarations for isl::term\ninline term manage(__isl_take isl_term *ptr);\ninline term manage_copy(__isl_keep isl_term *ptr);\n\nclass term {\n  friend inline term manage(__isl_take isl_term *ptr);\n  friend inline term manage_copy(__isl_keep isl_term *ptr);\n\n  isl_term *ptr = nullptr;\n\n  inline explicit term(__isl_take isl_term *ptr);\n\npublic:\n  inline /* implicit */ term();\n  inline /* implicit */ term(const term &obj);\n  inline /* implicit */ term(std::nullptr_t);\n  inline term &operator=(term obj);\n  inline ~term();\n  inline __isl_give isl_term *copy() const &;\n  inline __isl_give isl_term *copy() && = delete;\n  inline __isl_keep isl_term *get() const;\n  inline __isl_give isl_term *release();\n  inline bool is_null() const;\n  inline explicit operator bool() const;\n  inline ctx get_ctx() const;\n\n  inline isl_size dim(isl::dim type) const;\n  inline val get_coefficient_val() const;\n  inline aff get_div(unsigned int pos) const;\n  inline isl_size get_exp(isl::dim type, unsigned int pos) const;\n};\n\n// declarations for isl::union_access_info\ninline union_access_info manage(__isl_take isl_union_access_info *ptr);\ninline union_access_info manage_copy(__isl_keep isl_union_access_info *ptr);\n\nclass union_access_info {\n  friend inline union_access_info manage(__isl_take isl_union_access_info *ptr);\n  friend inline union_access_info manage_copy(__isl_keep isl_union_access_info *ptr);\n\n  isl_union_access_info *ptr = nullptr;\n\n  inline explicit union_access_info(__isl_take isl_union_access_info *ptr);\n\npublic:\n  inline /* implicit */ union_access_info();\n  inline /* implicit */ union_access_info(const union_access_info &obj);\n  inline /* implicit */ union_access_info(std::nullptr_t);\n  inline explicit union_access_info(union_map sink);\n  inline union_access_info &operator=(union_access_info obj);\n  inline ~union_access_info();\n  inline __isl_give isl_union_access_info *copy() const &;\n  inline __isl_give isl_union_access_info *copy() && = delete;\n  inline __isl_keep isl_union_access_info *get() const;\n  inline __isl_give isl_union_access_info *release();\n  inline bool is_null() const;\n  inline explicit operator bool() const;\n  inline ctx get_ctx() const;\n  inline std::string to_str() const;\n\n  inline union_flow compute_flow() const;\n  inline union_access_info set_kill(union_map kill) const;\n  inline union_access_info set_may_source(union_map may_source) const;\n  inline union_access_info set_must_source(union_map must_source) const;\n  inline union_access_info set_schedule(schedule schedule) const;\n  inline union_access_info set_schedule_map(union_map schedule_map) const;\n};\n\n// declarations for isl::union_flow\ninline union_flow manage(__isl_take isl_union_flow *ptr);\ninline union_flow manage_copy(__isl_keep isl_union_flow *ptr);\n\nclass union_flow {\n  friend inline union_flow manage(__isl_take isl_union_flow *ptr);\n  friend inline union_flow manage_copy(__isl_keep isl_union_flow *ptr);\n\n  isl_union_flow *ptr = nullptr;\n\n  inline explicit union_flow(__isl_take isl_union_flow *ptr);\n\npublic:\n  inline /* implicit */ union_flow();\n  inline /* implicit */ union_flow(const union_flow &obj);\n  inline /* implicit */ union_flow(std::nullptr_t);\n  inline union_flow &operator=(union_flow obj);\n  inline ~union_flow();\n  inline __isl_give isl_union_flow *copy() const &;\n  inline __isl_give isl_union_flow *copy() && = delete;\n  inline __isl_keep isl_union_flow *get() const;\n  inline __isl_give isl_union_flow *release();\n  inline bool is_null() const;\n  inline explicit operator bool() const;\n  inline ctx get_ctx() const;\n  inline std::string to_str() const;\n\n  inline union_map get_full_may_dependence() const;\n  inline union_map get_full_must_dependence() const;\n  inline union_map get_may_dependence() const;\n  inline union_map get_may_no_source() const;\n  inline union_map get_must_dependence() const;\n  inline union_map get_must_no_source() const;\n};\n\n// declarations for isl::union_map\ninline union_map manage(__isl_take isl_union_map *ptr);\ninline union_map manage_copy(__isl_keep isl_union_map *ptr);\n\nclass union_map {\n  friend inline union_map manage(__isl_take isl_union_map *ptr);\n  friend inline union_map manage_copy(__isl_keep isl_union_map *ptr);\n\n  isl_union_map *ptr = nullptr;\n\n  inline explicit union_map(__isl_take isl_union_map *ptr);\n\npublic:\n  inline /* implicit */ union_map();\n  inline /* implicit */ union_map(const union_map &obj);\n  inline /* implicit */ union_map(std::nullptr_t);\n  inline /* implicit */ union_map(basic_map bmap);\n  inline /* implicit */ union_map(map map);\n  inline explicit union_map(union_pw_multi_aff upma);\n  inline explicit union_map(ctx ctx, const std::string &str);\n  inline union_map &operator=(union_map obj);\n  inline ~union_map();\n  inline __isl_give isl_union_map *copy() const &;\n  inline __isl_give isl_union_map *copy() && = delete;\n  inline __isl_keep isl_union_map *get() const;\n  inline __isl_give isl_union_map *release();\n  inline bool is_null() const;\n  inline explicit operator bool() const;\n  inline ctx get_ctx() const;\n  inline std::string to_str() const;\n  inline void dump() const;\n\n  inline union_map add_map(map map) const;\n  inline union_map affine_hull() const;\n  inline union_map align_params(space model) const;\n  inline union_map apply_domain(union_map umap2) const;\n  inline union_map apply_range(union_map umap2) const;\n  inline union_set bind_range(multi_id tuple) const;\n  inline union_map coalesce() const;\n  inline boolean contains(const space &space) const;\n  inline union_map curry() const;\n  inline union_set deltas() const;\n  inline union_map deltas_map() const;\n  inline union_map detect_equalities() const;\n  inline isl_size dim(isl::dim type) const;\n  inline union_set domain() const;\n  inline union_map domain_factor_domain() const;\n  inline union_map domain_factor_range() const;\n  inline union_map domain_map() const;\n  inline union_pw_multi_aff domain_map_union_pw_multi_aff() const;\n  inline union_map domain_product(union_map umap2) const;\n  static inline union_map empty(space space);\n  static inline union_map empty(ctx ctx);\n  static inline union_map empty_space(space space);\n  inline union_map eq_at(multi_union_pw_aff mupa) const;\n  inline map extract_map(space space) const;\n  inline union_map factor_domain() const;\n  inline union_map factor_range() const;\n  inline int find_dim_by_name(isl::dim type, const std::string &name) const;\n  inline union_map fixed_power(val exp) const;\n  inline union_map flat_domain_product(union_map umap2) const;\n  inline union_map flat_range_product(union_map umap2) const;\n  inline stat foreach_map(const std::function<stat(map)> &fn) const;\n  static inline union_map from(multi_union_pw_aff mupa);\n  static inline union_map from_domain(union_set uset);\n  static inline union_map from_domain_and_range(union_set domain, union_set range);\n  static inline union_map from_range(union_set uset);\n  static inline union_map from_union_pw_aff(union_pw_aff upa);\n  inline id get_dim_id(isl::dim type, unsigned int pos) const;\n  inline uint32_t get_hash() const;\n  inline map_list get_map_list() const;\n  inline space get_space() const;\n  inline union_map gist(union_map context) const;\n  inline union_map gist_domain(union_set uset) const;\n  inline union_map gist_params(set set) const;\n  inline union_map gist_range(union_set uset) const;\n  inline union_map intersect(union_map umap2) const;\n  inline union_map intersect_domain(space space) const;\n  inline union_map intersect_domain(union_set uset) const;\n  inline union_map intersect_domain_factor_domain(union_map factor) const;\n  inline union_map intersect_domain_factor_range(union_map factor) const;\n  inline union_map intersect_params(set set) const;\n  inline union_map intersect_range(space space) const;\n  inline union_map intersect_range(union_set uset) const;\n  inline union_map intersect_range_factor_domain(union_map factor) const;\n  inline union_map intersect_range_factor_range(union_map factor) const;\n  inline boolean involves_dims(isl::dim type, unsigned int first, unsigned int n) const;\n  inline boolean is_bijective() const;\n  inline boolean is_disjoint(const union_map &umap2) const;\n  inline boolean is_empty() const;\n  inline boolean is_equal(const union_map &umap2) const;\n  inline boolean is_identity() const;\n  inline boolean is_injective() const;\n  inline boolean is_single_valued() const;\n  inline boolean is_strict_subset(const union_map &umap2) const;\n  inline boolean is_subset(const union_map &umap2) const;\n  inline boolean isa_map() const;\n  inline union_map lex_ge_at_multi_union_pw_aff(multi_union_pw_aff mupa) const;\n  inline union_map lex_ge_union_map(union_map umap2) const;\n  inline union_map lex_gt_at_multi_union_pw_aff(multi_union_pw_aff mupa) const;\n  inline union_map lex_gt_union_map(union_map umap2) const;\n  inline union_map lex_le_at_multi_union_pw_aff(multi_union_pw_aff mupa) const;\n  inline union_map lex_le_union_map(union_map umap2) const;\n  inline union_map lex_lt_at_multi_union_pw_aff(multi_union_pw_aff mupa) const;\n  inline union_map lex_lt_union_map(union_map umap2) const;\n  inline union_map lexmax() const;\n  inline union_map lexmin() const;\n  inline isl_size n_map() const;\n  inline set params() const;\n  inline boolean plain_is_empty() const;\n  inline boolean plain_is_injective() const;\n  inline union_map polyhedral_hull() const;\n  inline union_map preimage_domain(multi_aff ma) const;\n  inline union_map preimage_domain(multi_pw_aff mpa) const;\n  inline union_map preimage_domain(pw_multi_aff pma) const;\n  inline union_map preimage_domain(union_pw_multi_aff upma) const;\n  inline union_map preimage_range(multi_aff ma) const;\n  inline union_map preimage_range(pw_multi_aff pma) const;\n  inline union_map preimage_range(union_pw_multi_aff upma) const;\n  inline union_map product(union_map umap2) const;\n  inline union_map project_out(isl::dim type, unsigned int first, unsigned int n) const;\n  inline union_map project_out_all_params() const;\n  inline union_set range() const;\n  inline union_map range_curry() const;\n  inline union_map range_factor_domain() const;\n  inline union_map range_factor_range() const;\n  inline union_map range_map() const;\n  inline union_map range_product(union_map umap2) const;\n  inline union_map range_reverse() const;\n  inline union_map remove_divs() const;\n  inline union_map remove_redundancies() const;\n  inline union_map reset_user() const;\n  inline union_map reverse() const;\n  inline basic_map sample() const;\n  inline union_map simple_hull() const;\n  inline union_map subtract(union_map umap2) const;\n  inline union_map subtract_domain(union_set dom) const;\n  inline union_map subtract_range(union_set dom) const;\n  inline union_map uncurry() const;\n  inline union_map unite(union_map umap2) const;\n  inline union_map universe() const;\n  inline union_set wrap() const;\n  inline union_map zip() const;\n};\n\n// declarations for isl::union_map_list\ninline union_map_list manage(__isl_take isl_union_map_list *ptr);\ninline union_map_list manage_copy(__isl_keep isl_union_map_list *ptr);\n\nclass union_map_list {\n  friend inline union_map_list manage(__isl_take isl_union_map_list *ptr);\n  friend inline union_map_list manage_copy(__isl_keep isl_union_map_list *ptr);\n\n  isl_union_map_list *ptr = nullptr;\n\n  inline explicit union_map_list(__isl_take isl_union_map_list *ptr);\n\npublic:\n  inline /* implicit */ union_map_list();\n  inline /* implicit */ union_map_list(const union_map_list &obj);\n  inline /* implicit */ union_map_list(std::nullptr_t);\n  inline union_map_list &operator=(union_map_list obj);\n  inline ~union_map_list();\n  inline __isl_give isl_union_map_list *copy() const &;\n  inline __isl_give isl_union_map_list *copy() && = delete;\n  inline __isl_keep isl_union_map_list *get() const;\n  inline __isl_give isl_union_map_list *release();\n  inline bool is_null() const;\n  inline explicit operator bool() const;\n  inline ctx get_ctx() const;\n  inline std::string to_str() const;\n  inline void dump() const;\n\n  inline union_map_list add(union_map el) const;\n  static inline union_map_list alloc(ctx ctx, int n);\n  inline union_map_list clear() const;\n  inline union_map_list concat(union_map_list list2) const;\n  inline union_map_list drop(unsigned int first, unsigned int n) const;\n  inline stat foreach(const std::function<stat(union_map)> &fn) const;\n  static inline union_map_list from_union_map(union_map el);\n  inline union_map get_at(int index) const;\n  inline union_map get_union_map(int index) const;\n  inline union_map_list insert(unsigned int pos, union_map el) const;\n  inline isl_size n_union_map() const;\n  inline union_map_list reverse() const;\n  inline union_map_list set_union_map(int index, union_map el) const;\n  inline isl_size size() const;\n  inline union_map_list swap(unsigned int pos1, unsigned int pos2) const;\n};\n\n// declarations for isl::union_pw_aff\ninline union_pw_aff manage(__isl_take isl_union_pw_aff *ptr);\ninline union_pw_aff manage_copy(__isl_keep isl_union_pw_aff *ptr);\n\nclass union_pw_aff {\n  friend inline union_pw_aff manage(__isl_take isl_union_pw_aff *ptr);\n  friend inline union_pw_aff manage_copy(__isl_keep isl_union_pw_aff *ptr);\n\n  isl_union_pw_aff *ptr = nullptr;\n\n  inline explicit union_pw_aff(__isl_take isl_union_pw_aff *ptr);\n\npublic:\n  inline /* implicit */ union_pw_aff();\n  inline /* implicit */ union_pw_aff(const union_pw_aff &obj);\n  inline /* implicit */ union_pw_aff(std::nullptr_t);\n  inline /* implicit */ union_pw_aff(aff aff);\n  inline /* implicit */ union_pw_aff(pw_aff pa);\n  inline explicit union_pw_aff(ctx ctx, const std::string &str);\n  inline explicit union_pw_aff(union_set domain, val v);\n  inline union_pw_aff &operator=(union_pw_aff obj);\n  inline ~union_pw_aff();\n  inline __isl_give isl_union_pw_aff *copy() const &;\n  inline __isl_give isl_union_pw_aff *copy() && = delete;\n  inline __isl_keep isl_union_pw_aff *get() const;\n  inline __isl_give isl_union_pw_aff *release();\n  inline bool is_null() const;\n  inline explicit operator bool() const;\n  inline ctx get_ctx() const;\n  inline std::string to_str() const;\n  inline void dump() const;\n\n  inline union_pw_aff add(union_pw_aff upa2) const;\n  inline union_pw_aff add_pw_aff(pw_aff pa) const;\n  static inline union_pw_aff aff_on_domain(union_set domain, aff aff);\n  inline union_pw_aff align_params(space model) const;\n  inline union_set bind(id id) const;\n  inline union_pw_aff coalesce() const;\n  inline isl_size dim(isl::dim type) const;\n  inline union_set domain() const;\n  inline union_pw_aff drop_dims(isl::dim type, unsigned int first, unsigned int n) const;\n  static inline union_pw_aff empty(space space);\n  static inline union_pw_aff empty_ctx(ctx ctx);\n  static inline union_pw_aff empty_space(space space);\n  inline pw_aff extract_pw_aff(space space) const;\n  inline int find_dim_by_name(isl::dim type, const std::string &name) const;\n  inline union_pw_aff floor() const;\n  inline stat foreach_pw_aff(const std::function<stat(pw_aff)> &fn) const;\n  inline pw_aff_list get_pw_aff_list() const;\n  inline space get_space() const;\n  inline union_pw_aff gist(union_set context) const;\n  inline union_pw_aff gist_params(set context) const;\n  inline union_pw_aff intersect_domain(space space) const;\n  inline union_pw_aff intersect_domain(union_set uset) const;\n  inline union_pw_aff intersect_domain_wrapped_domain(union_set uset) const;\n  inline union_pw_aff intersect_domain_wrapped_range(union_set uset) const;\n  inline union_pw_aff intersect_params(set set) const;\n  inline boolean involves_nan() const;\n  inline val max_val() const;\n  inline val min_val() const;\n  inline union_pw_aff mod_val(val f) const;\n  inline isl_size n_pw_aff() const;\n  inline union_pw_aff neg() const;\n  static inline union_pw_aff param_on_domain_id(union_set domain, id id);\n  inline boolean plain_is_equal(const union_pw_aff &upa2) const;\n  inline union_pw_aff pullback(union_pw_multi_aff upma) const;\n  static inline union_pw_aff pw_aff_on_domain(union_set domain, pw_aff pa);\n  inline union_pw_aff reset_user() const;\n  inline union_pw_aff scale_down_val(val v) const;\n  inline union_pw_aff scale_val(val v) const;\n  inline union_pw_aff sub(union_pw_aff upa2) const;\n  inline union_pw_aff subtract_domain(space space) const;\n  inline union_pw_aff subtract_domain(union_set uset) const;\n  inline union_pw_aff union_add(union_pw_aff upa2) const;\n  inline union_set zero_union_set() const;\n};\n\n// declarations for isl::union_pw_aff_list\ninline union_pw_aff_list manage(__isl_take isl_union_pw_aff_list *ptr);\ninline union_pw_aff_list manage_copy(__isl_keep isl_union_pw_aff_list *ptr);\n\nclass union_pw_aff_list {\n  friend inline union_pw_aff_list manage(__isl_take isl_union_pw_aff_list *ptr);\n  friend inline union_pw_aff_list manage_copy(__isl_keep isl_union_pw_aff_list *ptr);\n\n  isl_union_pw_aff_list *ptr = nullptr;\n\n  inline explicit union_pw_aff_list(__isl_take isl_union_pw_aff_list *ptr);\n\npublic:\n  inline /* implicit */ union_pw_aff_list();\n  inline /* implicit */ union_pw_aff_list(const union_pw_aff_list &obj);\n  inline /* implicit */ union_pw_aff_list(std::nullptr_t);\n  inline union_pw_aff_list &operator=(union_pw_aff_list obj);\n  inline ~union_pw_aff_list();\n  inline __isl_give isl_union_pw_aff_list *copy() const &;\n  inline __isl_give isl_union_pw_aff_list *copy() && = delete;\n  inline __isl_keep isl_union_pw_aff_list *get() const;\n  inline __isl_give isl_union_pw_aff_list *release();\n  inline bool is_null() const;\n  inline explicit operator bool() const;\n  inline ctx get_ctx() const;\n  inline std::string to_str() const;\n  inline void dump() const;\n\n  inline union_pw_aff_list add(union_pw_aff el) const;\n  static inline union_pw_aff_list alloc(ctx ctx, int n);\n  inline union_pw_aff_list clear() const;\n  inline union_pw_aff_list concat(union_pw_aff_list list2) const;\n  inline union_pw_aff_list drop(unsigned int first, unsigned int n) const;\n  inline stat foreach(const std::function<stat(union_pw_aff)> &fn) const;\n  static inline union_pw_aff_list from_union_pw_aff(union_pw_aff el);\n  inline union_pw_aff get_at(int index) const;\n  inline union_pw_aff get_union_pw_aff(int index) const;\n  inline union_pw_aff_list insert(unsigned int pos, union_pw_aff el) const;\n  inline isl_size n_union_pw_aff() const;\n  inline union_pw_aff_list reverse() const;\n  inline union_pw_aff_list set_union_pw_aff(int index, union_pw_aff el) const;\n  inline isl_size size() const;\n  inline union_pw_aff_list swap(unsigned int pos1, unsigned int pos2) const;\n};\n\n// declarations for isl::union_pw_multi_aff\ninline union_pw_multi_aff manage(__isl_take isl_union_pw_multi_aff *ptr);\ninline union_pw_multi_aff manage_copy(__isl_keep isl_union_pw_multi_aff *ptr);\n\nclass union_pw_multi_aff {\n  friend inline union_pw_multi_aff manage(__isl_take isl_union_pw_multi_aff *ptr);\n  friend inline union_pw_multi_aff manage_copy(__isl_keep isl_union_pw_multi_aff *ptr);\n\n  isl_union_pw_multi_aff *ptr = nullptr;\n\n  inline explicit union_pw_multi_aff(__isl_take isl_union_pw_multi_aff *ptr);\n\npublic:\n  inline /* implicit */ union_pw_multi_aff();\n  inline /* implicit */ union_pw_multi_aff(const union_pw_multi_aff &obj);\n  inline /* implicit */ union_pw_multi_aff(std::nullptr_t);\n  inline /* implicit */ union_pw_multi_aff(aff aff);\n  inline explicit union_pw_multi_aff(union_set uset);\n  inline /* implicit */ union_pw_multi_aff(multi_aff ma);\n  inline explicit union_pw_multi_aff(multi_union_pw_aff mupa);\n  inline /* implicit */ union_pw_multi_aff(pw_multi_aff pma);\n  inline explicit union_pw_multi_aff(union_map umap);\n  inline /* implicit */ union_pw_multi_aff(union_pw_aff upa);\n  inline explicit union_pw_multi_aff(ctx ctx, const std::string &str);\n  inline union_pw_multi_aff &operator=(union_pw_multi_aff obj);\n  inline ~union_pw_multi_aff();\n  inline __isl_give isl_union_pw_multi_aff *copy() const &;\n  inline __isl_give isl_union_pw_multi_aff *copy() && = delete;\n  inline __isl_keep isl_union_pw_multi_aff *get() const;\n  inline __isl_give isl_union_pw_multi_aff *release();\n  inline bool is_null() const;\n  inline explicit operator bool() const;\n  inline ctx get_ctx() const;\n  inline std::string to_str() const;\n  inline void dump() const;\n\n  inline union_pw_multi_aff add(union_pw_multi_aff upma2) const;\n  inline union_pw_multi_aff add_pw_multi_aff(pw_multi_aff pma) const;\n  inline union_pw_multi_aff align_params(space model) const;\n  inline union_pw_multi_aff apply(union_pw_multi_aff upma2) const;\n  inline pw_multi_aff as_pw_multi_aff() const;\n  inline union_pw_multi_aff coalesce() const;\n  inline isl_size dim(isl::dim type) const;\n  inline union_set domain() const;\n  inline union_pw_multi_aff drop_dims(isl::dim type, unsigned int first, unsigned int n) const;\n  static inline union_pw_multi_aff empty(space space);\n  static inline union_pw_multi_aff empty(ctx ctx);\n  static inline union_pw_multi_aff empty_space(space space);\n  inline pw_multi_aff extract_pw_multi_aff(space space) const;\n  inline int find_dim_by_name(isl::dim type, const std::string &name) const;\n  inline union_pw_multi_aff flat_range_product(union_pw_multi_aff upma2) const;\n  inline stat foreach_pw_multi_aff(const std::function<stat(pw_multi_aff)> &fn) const;\n  static inline union_pw_multi_aff from_union_set(union_set uset);\n  inline pw_multi_aff_list get_pw_multi_aff_list() const;\n  inline space get_space() const;\n  inline union_pw_aff get_union_pw_aff(int pos) const;\n  inline union_pw_multi_aff gist(union_set context) const;\n  inline union_pw_multi_aff gist_params(set context) const;\n  inline union_pw_multi_aff intersect_domain(space space) const;\n  inline union_pw_multi_aff intersect_domain(union_set uset) const;\n  inline union_pw_multi_aff intersect_domain_wrapped_domain(union_set uset) const;\n  inline union_pw_multi_aff intersect_domain_wrapped_range(union_set uset) const;\n  inline union_pw_multi_aff intersect_params(set set) const;\n  inline boolean involves_locals() const;\n  inline boolean involves_nan() const;\n  inline boolean isa_pw_multi_aff() const;\n  static inline union_pw_multi_aff multi_val_on_domain(union_set domain, multi_val mv);\n  inline isl_size n_pw_multi_aff() const;\n  inline union_pw_multi_aff neg() const;\n  inline boolean plain_is_empty() const;\n  inline boolean plain_is_equal(const union_pw_multi_aff &upma2) const;\n  inline union_pw_multi_aff preimage_domain_wrapped_domain(union_pw_multi_aff upma2) const;\n  inline union_pw_multi_aff pullback(union_pw_multi_aff upma2) const;\n  inline union_pw_multi_aff range_factor_domain() const;\n  inline union_pw_multi_aff range_factor_range() const;\n  inline union_pw_multi_aff range_product(union_pw_multi_aff upma2) const;\n  inline union_pw_multi_aff reset_user() const;\n  inline union_pw_multi_aff scale_down_val(val val) const;\n  inline union_pw_multi_aff scale_multi_val(multi_val mv) const;\n  inline union_pw_multi_aff scale_val(val val) const;\n  inline union_pw_multi_aff sub(union_pw_multi_aff upma2) const;\n  inline union_pw_multi_aff subtract_domain(space space) const;\n  inline union_pw_multi_aff subtract_domain(union_set uset) const;\n  inline union_pw_multi_aff union_add(union_pw_multi_aff upma2) const;\n};\n\n// declarations for isl::union_pw_multi_aff_list\ninline union_pw_multi_aff_list manage(__isl_take isl_union_pw_multi_aff_list *ptr);\ninline union_pw_multi_aff_list manage_copy(__isl_keep isl_union_pw_multi_aff_list *ptr);\n\nclass union_pw_multi_aff_list {\n  friend inline union_pw_multi_aff_list manage(__isl_take isl_union_pw_multi_aff_list *ptr);\n  friend inline union_pw_multi_aff_list manage_copy(__isl_keep isl_union_pw_multi_aff_list *ptr);\n\n  isl_union_pw_multi_aff_list *ptr = nullptr;\n\n  inline explicit union_pw_multi_aff_list(__isl_take isl_union_pw_multi_aff_list *ptr);\n\npublic:\n  inline /* implicit */ union_pw_multi_aff_list();\n  inline /* implicit */ union_pw_multi_aff_list(const union_pw_multi_aff_list &obj);\n  inline /* implicit */ union_pw_multi_aff_list(std::nullptr_t);\n  inline union_pw_multi_aff_list &operator=(union_pw_multi_aff_list obj);\n  inline ~union_pw_multi_aff_list();\n  inline __isl_give isl_union_pw_multi_aff_list *copy() const &;\n  inline __isl_give isl_union_pw_multi_aff_list *copy() && = delete;\n  inline __isl_keep isl_union_pw_multi_aff_list *get() const;\n  inline __isl_give isl_union_pw_multi_aff_list *release();\n  inline bool is_null() const;\n  inline explicit operator bool() const;\n  inline ctx get_ctx() const;\n  inline std::string to_str() const;\n  inline void dump() const;\n\n  inline union_pw_multi_aff_list add(union_pw_multi_aff el) const;\n  static inline union_pw_multi_aff_list alloc(ctx ctx, int n);\n  inline union_pw_multi_aff_list clear() const;\n  inline union_pw_multi_aff_list concat(union_pw_multi_aff_list list2) const;\n  inline union_pw_multi_aff_list drop(unsigned int first, unsigned int n) const;\n  inline stat foreach(const std::function<stat(union_pw_multi_aff)> &fn) const;\n  static inline union_pw_multi_aff_list from_union_pw_multi_aff(union_pw_multi_aff el);\n  inline union_pw_multi_aff get_at(int index) const;\n  inline union_pw_multi_aff get_union_pw_multi_aff(int index) const;\n  inline union_pw_multi_aff_list insert(unsigned int pos, union_pw_multi_aff el) const;\n  inline isl_size n_union_pw_multi_aff() const;\n  inline union_pw_multi_aff_list reverse() const;\n  inline union_pw_multi_aff_list set_union_pw_multi_aff(int index, union_pw_multi_aff el) const;\n  inline isl_size size() const;\n  inline union_pw_multi_aff_list swap(unsigned int pos1, unsigned int pos2) const;\n};\n\n// declarations for isl::union_pw_qpolynomial\ninline union_pw_qpolynomial manage(__isl_take isl_union_pw_qpolynomial *ptr);\ninline union_pw_qpolynomial manage_copy(__isl_keep isl_union_pw_qpolynomial *ptr);\n\nclass union_pw_qpolynomial {\n  friend inline union_pw_qpolynomial manage(__isl_take isl_union_pw_qpolynomial *ptr);\n  friend inline union_pw_qpolynomial manage_copy(__isl_keep isl_union_pw_qpolynomial *ptr);\n\n  isl_union_pw_qpolynomial *ptr = nullptr;\n\n  inline explicit union_pw_qpolynomial(__isl_take isl_union_pw_qpolynomial *ptr);\n\npublic:\n  inline /* implicit */ union_pw_qpolynomial();\n  inline /* implicit */ union_pw_qpolynomial(const union_pw_qpolynomial &obj);\n  inline /* implicit */ union_pw_qpolynomial(std::nullptr_t);\n  inline explicit union_pw_qpolynomial(ctx ctx, const std::string &str);\n  inline union_pw_qpolynomial &operator=(union_pw_qpolynomial obj);\n  inline ~union_pw_qpolynomial();\n  inline __isl_give isl_union_pw_qpolynomial *copy() const &;\n  inline __isl_give isl_union_pw_qpolynomial *copy() && = delete;\n  inline __isl_keep isl_union_pw_qpolynomial *get() const;\n  inline __isl_give isl_union_pw_qpolynomial *release();\n  inline bool is_null() const;\n  inline explicit operator bool() const;\n  inline ctx get_ctx() const;\n  inline std::string to_str() const;\n\n  inline union_pw_qpolynomial add(union_pw_qpolynomial upwqp2) const;\n  inline union_pw_qpolynomial add_pw_qpolynomial(pw_qpolynomial pwqp) const;\n  inline union_pw_qpolynomial align_params(space model) const;\n  inline union_pw_qpolynomial coalesce() const;\n  inline isl_size dim(isl::dim type) const;\n  inline union_set domain() const;\n  inline union_pw_qpolynomial drop_dims(isl::dim type, unsigned int first, unsigned int n) const;\n  inline val eval(point pnt) const;\n  inline pw_qpolynomial extract_pw_qpolynomial(space space) const;\n  inline int find_dim_by_name(isl::dim type, const std::string &name) const;\n  inline stat foreach_pw_qpolynomial(const std::function<stat(pw_qpolynomial)> &fn) const;\n  static inline union_pw_qpolynomial from_pw_qpolynomial(pw_qpolynomial pwqp);\n  inline pw_qpolynomial_list get_pw_qpolynomial_list() const;\n  inline space get_space() const;\n  inline union_pw_qpolynomial gist(union_set context) const;\n  inline union_pw_qpolynomial gist_params(set context) const;\n  inline union_pw_qpolynomial intersect_domain(union_set uset) const;\n  inline union_pw_qpolynomial intersect_domain_space(space space) const;\n  inline union_pw_qpolynomial intersect_domain_union_set(union_set uset) const;\n  inline union_pw_qpolynomial intersect_domain_wrapped_domain(union_set uset) const;\n  inline union_pw_qpolynomial intersect_domain_wrapped_range(union_set uset) const;\n  inline union_pw_qpolynomial intersect_params(set set) const;\n  inline boolean involves_nan() const;\n  inline union_pw_qpolynomial mul(union_pw_qpolynomial upwqp2) const;\n  inline isl_size n_pw_qpolynomial() const;\n  inline union_pw_qpolynomial neg() const;\n  inline boolean plain_is_equal(const union_pw_qpolynomial &upwqp2) const;\n  inline union_pw_qpolynomial reset_user() const;\n  inline union_pw_qpolynomial scale_down_val(val v) const;\n  inline union_pw_qpolynomial scale_val(val v) const;\n  inline union_pw_qpolynomial sub(union_pw_qpolynomial upwqp2) const;\n  inline union_pw_qpolynomial subtract_domain(union_set uset) const;\n  inline union_pw_qpolynomial subtract_domain_space(space space) const;\n  inline union_pw_qpolynomial subtract_domain_union_set(union_set uset) const;\n  inline union_pw_qpolynomial to_polynomial(int sign) const;\n  static inline union_pw_qpolynomial zero(space space);\n  static inline union_pw_qpolynomial zero_ctx(ctx ctx);\n  static inline union_pw_qpolynomial zero_space(space space);\n};\n\n// declarations for isl::union_set\ninline union_set manage(__isl_take isl_union_set *ptr);\ninline union_set manage_copy(__isl_keep isl_union_set *ptr);\n\nclass union_set {\n  friend inline union_set manage(__isl_take isl_union_set *ptr);\n  friend inline union_set manage_copy(__isl_keep isl_union_set *ptr);\n\n  isl_union_set *ptr = nullptr;\n\n  inline explicit union_set(__isl_take isl_union_set *ptr);\n\npublic:\n  inline /* implicit */ union_set();\n  inline /* implicit */ union_set(const union_set &obj);\n  inline /* implicit */ union_set(std::nullptr_t);\n  inline /* implicit */ union_set(basic_set bset);\n  inline /* implicit */ union_set(point pnt);\n  inline /* implicit */ union_set(set set);\n  inline explicit union_set(ctx ctx, const std::string &str);\n  inline union_set &operator=(union_set obj);\n  inline ~union_set();\n  inline __isl_give isl_union_set *copy() const &;\n  inline __isl_give isl_union_set *copy() && = delete;\n  inline __isl_keep isl_union_set *get() const;\n  inline __isl_give isl_union_set *release();\n  inline bool is_null() const;\n  inline explicit operator bool() const;\n  inline ctx get_ctx() const;\n  inline std::string to_str() const;\n  inline void dump() const;\n\n  inline union_set add_set(set set) const;\n  inline union_set affine_hull() const;\n  inline union_set align_params(space model) const;\n  inline union_set apply(union_map umap) const;\n  inline union_set coalesce() const;\n  inline union_set coefficients() const;\n  inline schedule compute_schedule(union_map validity, union_map proximity) const;\n  inline boolean contains(const space &space) const;\n  inline union_set detect_equalities() const;\n  inline isl_size dim(isl::dim type) const;\n  static inline union_set empty(space space);\n  static inline union_set empty(ctx ctx);\n  static inline union_set empty_space(space space);\n  inline set extract_set(space space) const;\n  inline stat foreach_point(const std::function<stat(point)> &fn) const;\n  inline stat foreach_set(const std::function<stat(set)> &fn) const;\n  inline basic_set_list get_basic_set_list() const;\n  inline uint32_t get_hash() const;\n  inline set_list get_set_list() const;\n  inline space get_space() const;\n  inline union_set gist(union_set context) const;\n  inline union_set gist_params(set set) const;\n  inline union_map identity() const;\n  inline union_pw_multi_aff identity_union_pw_multi_aff() const;\n  inline union_set intersect(union_set uset2) const;\n  inline union_set intersect_params(set set) const;\n  inline boolean is_disjoint(const union_set &uset2) const;\n  inline boolean is_empty() const;\n  inline boolean is_equal(const union_set &uset2) const;\n  inline boolean is_params() const;\n  inline boolean is_strict_subset(const union_set &uset2) const;\n  inline boolean is_subset(const union_set &uset2) const;\n  inline boolean isa_set() const;\n  inline union_map lex_ge_union_set(union_set uset2) const;\n  inline union_map lex_gt_union_set(union_set uset2) const;\n  inline union_map lex_le_union_set(union_set uset2) const;\n  inline union_map lex_lt_union_set(union_set uset2) const;\n  inline union_set lexmax() const;\n  inline union_set lexmin() const;\n  inline multi_val min_multi_union_pw_aff(const multi_union_pw_aff &obj) const;\n  inline isl_size n_set() const;\n  inline set params() const;\n  inline union_set polyhedral_hull() const;\n  inline union_set preimage(multi_aff ma) const;\n  inline union_set preimage(pw_multi_aff pma) const;\n  inline union_set preimage(union_pw_multi_aff upma) const;\n  inline union_set product(union_set uset2) const;\n  inline union_set project_out(isl::dim type, unsigned int first, unsigned int n) const;\n  inline union_set project_out_all_params() const;\n  inline union_set remove_divs() const;\n  inline union_set remove_redundancies() const;\n  inline union_set reset_user() const;\n  inline basic_set sample() const;\n  inline point sample_point() const;\n  inline union_set simple_hull() const;\n  inline union_set solutions() const;\n  inline union_set subtract(union_set uset2) const;\n  inline union_set unite(union_set uset2) const;\n  inline union_set universe() const;\n  inline union_map unwrap() const;\n  inline union_map wrapped_domain_map() const;\n};\n\n// declarations for isl::union_set_list\ninline union_set_list manage(__isl_take isl_union_set_list *ptr);\ninline union_set_list manage_copy(__isl_keep isl_union_set_list *ptr);\n\nclass union_set_list {\n  friend inline union_set_list manage(__isl_take isl_union_set_list *ptr);\n  friend inline union_set_list manage_copy(__isl_keep isl_union_set_list *ptr);\n\n  isl_union_set_list *ptr = nullptr;\n\n  inline explicit union_set_list(__isl_take isl_union_set_list *ptr);\n\npublic:\n  inline /* implicit */ union_set_list();\n  inline /* implicit */ union_set_list(const union_set_list &obj);\n  inline /* implicit */ union_set_list(std::nullptr_t);\n  inline union_set_list &operator=(union_set_list obj);\n  inline ~union_set_list();\n  inline __isl_give isl_union_set_list *copy() const &;\n  inline __isl_give isl_union_set_list *copy() && = delete;\n  inline __isl_keep isl_union_set_list *get() const;\n  inline __isl_give isl_union_set_list *release();\n  inline bool is_null() const;\n  inline explicit operator bool() const;\n  inline ctx get_ctx() const;\n  inline std::string to_str() const;\n  inline void dump() const;\n\n  inline union_set_list add(union_set el) const;\n  static inline union_set_list alloc(ctx ctx, int n);\n  inline union_set_list clear() const;\n  inline union_set_list concat(union_set_list list2) const;\n  inline union_set_list drop(unsigned int first, unsigned int n) const;\n  inline stat foreach(const std::function<stat(union_set)> &fn) const;\n  static inline union_set_list from_union_set(union_set el);\n  inline union_set get_at(int index) const;\n  inline union_set get_union_set(int index) const;\n  inline union_set_list insert(unsigned int pos, union_set el) const;\n  inline isl_size n_union_set() const;\n  inline union_set_list reverse() const;\n  inline union_set_list set_union_set(int index, union_set el) const;\n  inline isl_size size() const;\n  inline union_set_list swap(unsigned int pos1, unsigned int pos2) const;\n  inline union_set unite() const;\n};\n\n// declarations for isl::val\ninline val manage(__isl_take isl_val *ptr);\ninline val manage_copy(__isl_keep isl_val *ptr);\n\nclass val {\n  friend inline val manage(__isl_take isl_val *ptr);\n  friend inline val manage_copy(__isl_keep isl_val *ptr);\n\n  isl_val *ptr = nullptr;\n\n  inline explicit val(__isl_take isl_val *ptr);\n\npublic:\n  inline /* implicit */ val();\n  inline /* implicit */ val(const val &obj);\n  inline /* implicit */ val(std::nullptr_t);\n  inline explicit val(ctx ctx, long i);\n  inline explicit val(ctx ctx, const std::string &str);\n  inline val &operator=(val obj);\n  inline ~val();\n  inline __isl_give isl_val *copy() const &;\n  inline __isl_give isl_val *copy() && = delete;\n  inline __isl_keep isl_val *get() const;\n  inline __isl_give isl_val *release();\n  inline bool is_null() const;\n  inline explicit operator bool() const;\n  inline ctx get_ctx() const;\n  inline std::string to_str() const;\n  inline void dump() const;\n\n  inline val abs() const;\n  inline boolean abs_eq(const val &v2) const;\n  inline val add(val v2) const;\n  inline val add_ui(unsigned long v2) const;\n  inline val ceil() const;\n  inline int cmp_si(long i) const;\n  inline val div(val v2) const;\n  inline val div_ui(unsigned long v2) const;\n  inline boolean eq(const val &v2) const;\n  inline boolean eq_si(long i) const;\n  inline val floor() const;\n  inline val gcd(val v2) const;\n  inline boolean ge(const val &v2) const;\n  inline uint32_t get_hash() const;\n  inline long get_num_si() const;\n  inline boolean gt(const val &v2) const;\n  inline boolean gt_si(long i) const;\n  static inline val infty(ctx ctx);\n  static inline val int_from_ui(ctx ctx, unsigned long u);\n  inline val inv() const;\n  inline boolean is_divisible_by(const val &v2) const;\n  inline boolean is_infty() const;\n  inline boolean is_int() const;\n  inline boolean is_nan() const;\n  inline boolean is_neg() const;\n  inline boolean is_neginfty() const;\n  inline boolean is_negone() const;\n  inline boolean is_nonneg() const;\n  inline boolean is_nonpos() const;\n  inline boolean is_one() const;\n  inline boolean is_pos() const;\n  inline boolean is_rat() const;\n  inline boolean is_zero() const;\n  inline boolean le(const val &v2) const;\n  inline boolean lt(const val &v2) const;\n  inline val max(val v2) const;\n  inline val min(val v2) const;\n  inline val mod(val v2) const;\n  inline val mul(val v2) const;\n  inline val mul_ui(unsigned long v2) const;\n  inline isl_size n_abs_num_chunks(size_t size) const;\n  static inline val nan(ctx ctx);\n  inline boolean ne(const val &v2) const;\n  inline val neg() const;\n  static inline val neginfty(ctx ctx);\n  static inline val negone(ctx ctx);\n  static inline val one(ctx ctx);\n  inline val pow2() const;\n  inline val set_si(long i) const;\n  inline int sgn() const;\n  inline val sub(val v2) const;\n  inline val sub_ui(unsigned long v2) const;\n  inline val trunc() const;\n  static inline val zero(ctx ctx);\n};\n\n// declarations for isl::val_list\ninline val_list manage(__isl_take isl_val_list *ptr);\ninline val_list manage_copy(__isl_keep isl_val_list *ptr);\n\nclass val_list {\n  friend inline val_list manage(__isl_take isl_val_list *ptr);\n  friend inline val_list manage_copy(__isl_keep isl_val_list *ptr);\n\n  isl_val_list *ptr = nullptr;\n\n  inline explicit val_list(__isl_take isl_val_list *ptr);\n\npublic:\n  inline /* implicit */ val_list();\n  inline /* implicit */ val_list(const val_list &obj);\n  inline /* implicit */ val_list(std::nullptr_t);\n  inline val_list &operator=(val_list obj);\n  inline ~val_list();\n  inline __isl_give isl_val_list *copy() const &;\n  inline __isl_give isl_val_list *copy() && = delete;\n  inline __isl_keep isl_val_list *get() const;\n  inline __isl_give isl_val_list *release();\n  inline bool is_null() const;\n  inline explicit operator bool() const;\n  inline ctx get_ctx() const;\n  inline std::string to_str() const;\n  inline void dump() const;\n\n  inline val_list add(val el) const;\n  static inline val_list alloc(ctx ctx, int n);\n  inline val_list clear() const;\n  inline val_list concat(val_list list2) const;\n  inline val_list drop(unsigned int first, unsigned int n) const;\n  inline stat foreach(const std::function<stat(val)> &fn) const;\n  static inline val_list from_val(val el);\n  inline val get_at(int index) const;\n  inline val get_val(int index) const;\n  inline val_list insert(unsigned int pos, val el) const;\n  inline isl_size n_val() const;\n  inline val_list reverse() const;\n  inline val_list set_val(int index, val el) const;\n  inline isl_size size() const;\n  inline val_list swap(unsigned int pos1, unsigned int pos2) const;\n};\n\n// declarations for isl::vec\ninline vec manage(__isl_take isl_vec *ptr);\ninline vec manage_copy(__isl_keep isl_vec *ptr);\n\nclass vec {\n  friend inline vec manage(__isl_take isl_vec *ptr);\n  friend inline vec manage_copy(__isl_keep isl_vec *ptr);\n\n  isl_vec *ptr = nullptr;\n\n  inline explicit vec(__isl_take isl_vec *ptr);\n\npublic:\n  inline /* implicit */ vec();\n  inline /* implicit */ vec(const vec &obj);\n  inline /* implicit */ vec(std::nullptr_t);\n  inline vec &operator=(vec obj);\n  inline ~vec();\n  inline __isl_give isl_vec *copy() const &;\n  inline __isl_give isl_vec *copy() && = delete;\n  inline __isl_keep isl_vec *get() const;\n  inline __isl_give isl_vec *release();\n  inline bool is_null() const;\n  inline explicit operator bool() const;\n  inline ctx get_ctx() const;\n  inline void dump() const;\n\n  inline vec add(vec vec2) const;\n  inline vec add_els(unsigned int n) const;\n  static inline vec alloc(ctx ctx, unsigned int size);\n  inline vec ceil() const;\n  inline vec clr() const;\n  inline int cmp_element(const vec &vec2, int pos) const;\n  inline vec concat(vec vec2) const;\n  inline vec drop_els(unsigned int pos, unsigned int n) const;\n  inline vec extend(unsigned int size) const;\n  inline val get_element_val(int pos) const;\n  inline vec insert_els(unsigned int pos, unsigned int n) const;\n  inline vec insert_zero_els(unsigned int pos, unsigned int n) const;\n  inline boolean is_equal(const vec &vec2) const;\n  inline vec mat_product(mat mat) const;\n  inline vec move_els(unsigned int dst_col, unsigned int src_col, unsigned int n) const;\n  inline vec neg() const;\n  inline vec set_element_si(int pos, int v) const;\n  inline vec set_element_val(int pos, val v) const;\n  inline vec set_si(int v) const;\n  inline vec set_val(val v) const;\n  inline isl_size size() const;\n  inline vec sort() const;\n  static inline vec zero(ctx ctx, unsigned int size);\n  inline vec zero_extend(unsigned int size) const;\n};\n\n// implementations for isl::aff\naff manage(__isl_take isl_aff *ptr) {\n  return aff(ptr);\n}\naff manage_copy(__isl_keep isl_aff *ptr) {\n  ptr = isl_aff_copy(ptr);\n  return aff(ptr);\n}\n\naff::aff()\n    : ptr(nullptr) {}\n\naff::aff(const aff &obj)\n    : ptr(nullptr)\n{\n  ptr = obj.copy();\n}\naff::aff(std::nullptr_t)\n    : ptr(nullptr) {}\n\n\naff::aff(__isl_take isl_aff *ptr)\n    : ptr(ptr) {}\n\naff::aff(ctx ctx, const std::string &str)\n{\n  auto res = isl_aff_read_from_str(ctx.release(), str.c_str());\n  ptr = res;\n}\naff::aff(local_space ls, val val)\n{\n  auto res = isl_aff_val_on_domain(ls.release(), val.release());\n  ptr = res;\n}\naff::aff(local_space ls)\n{\n  auto res = isl_aff_zero_on_domain(ls.release());\n  ptr = res;\n}\n\naff &aff::operator=(aff obj) {\n  std::swap(this->ptr, obj.ptr);\n  return *this;\n}\n\naff::~aff() {\n  if (ptr)\n    isl_aff_free(ptr);\n}\n\n__isl_give isl_aff *aff::copy() const & {\n  return isl_aff_copy(ptr);\n}\n\n__isl_keep isl_aff *aff::get() const {\n  return ptr;\n}\n\n__isl_give isl_aff *aff::release() {\n  isl_aff *tmp = ptr;\n  ptr = nullptr;\n  return tmp;\n}\n\nbool aff::is_null() const {\n  return ptr == nullptr;\n}\naff::operator bool() const {\n  return !is_null();\n}\n\n\nctx aff::get_ctx() const {\n  return ctx(isl_aff_get_ctx(ptr));\n}\nstd::string aff::to_str() const {\n  char *Tmp = isl_aff_to_str(get());\n  if (!Tmp)\n    return \"\";\n  std::string S(Tmp);\n  free(Tmp);\n  return S;\n}\n\n\nvoid aff::dump() const {\n  isl_aff_dump(get());\n}\n\n\naff aff::add(aff aff2) const\n{\n  auto res = isl_aff_add(copy(), aff2.release());\n  return manage(res);\n}\n\naff aff::add_coefficient_si(isl::dim type, int pos, int v) const\n{\n  auto res = isl_aff_add_coefficient_si(copy(), static_cast<enum isl_dim_type>(type), pos, v);\n  return manage(res);\n}\n\naff aff::add_coefficient_val(isl::dim type, int pos, val v) const\n{\n  auto res = isl_aff_add_coefficient_val(copy(), static_cast<enum isl_dim_type>(type), pos, v.release());\n  return manage(res);\n}\n\naff aff::add_constant(val v) const\n{\n  auto res = isl_aff_add_constant_val(copy(), v.release());\n  return manage(res);\n}\n\naff aff::add_constant_num_si(int v) const\n{\n  auto res = isl_aff_add_constant_num_si(copy(), v);\n  return manage(res);\n}\n\naff aff::add_constant_si(int v) const\n{\n  auto res = isl_aff_add_constant_si(copy(), v);\n  return manage(res);\n}\n\naff aff::add_dims(isl::dim type, unsigned int n) const\n{\n  auto res = isl_aff_add_dims(copy(), static_cast<enum isl_dim_type>(type), n);\n  return manage(res);\n}\n\naff aff::align_params(space model) const\n{\n  auto res = isl_aff_align_params(copy(), model.release());\n  return manage(res);\n}\n\nbasic_set aff::bind(id id) const\n{\n  auto res = isl_aff_bind_id(copy(), id.release());\n  return manage(res);\n}\n\naff aff::ceil() const\n{\n  auto res = isl_aff_ceil(copy());\n  return manage(res);\n}\n\nint aff::coefficient_sgn(isl::dim type, int pos) const\n{\n  auto res = isl_aff_coefficient_sgn(get(), static_cast<enum isl_dim_type>(type), pos);\n  return res;\n}\n\nisl_size aff::dim(isl::dim type) const\n{\n  auto res = isl_aff_dim(get(), static_cast<enum isl_dim_type>(type));\n  return res;\n}\n\naff aff::div(aff aff2) const\n{\n  auto res = isl_aff_div(copy(), aff2.release());\n  return manage(res);\n}\n\naff aff::drop_dims(isl::dim type, unsigned int first, unsigned int n) const\n{\n  auto res = isl_aff_drop_dims(copy(), static_cast<enum isl_dim_type>(type), first, n);\n  return manage(res);\n}\n\nbasic_set aff::eq_basic_set(aff aff2) const\n{\n  auto res = isl_aff_eq_basic_set(copy(), aff2.release());\n  return manage(res);\n}\n\nset aff::eq_set(aff aff2) const\n{\n  auto res = isl_aff_eq_set(copy(), aff2.release());\n  return manage(res);\n}\n\nval aff::eval(point pnt) const\n{\n  auto res = isl_aff_eval(copy(), pnt.release());\n  return manage(res);\n}\n\nint aff::find_dim_by_name(isl::dim type, const std::string &name) const\n{\n  auto res = isl_aff_find_dim_by_name(get(), static_cast<enum isl_dim_type>(type), name.c_str());\n  return res;\n}\n\naff aff::floor() const\n{\n  auto res = isl_aff_floor(copy());\n  return manage(res);\n}\n\naff aff::from_range() const\n{\n  auto res = isl_aff_from_range(copy());\n  return manage(res);\n}\n\nbasic_set aff::ge_basic_set(aff aff2) const\n{\n  auto res = isl_aff_ge_basic_set(copy(), aff2.release());\n  return manage(res);\n}\n\nset aff::ge_set(aff aff2) const\n{\n  auto res = isl_aff_ge_set(copy(), aff2.release());\n  return manage(res);\n}\n\nval aff::get_coefficient_val(isl::dim type, int pos) const\n{\n  auto res = isl_aff_get_coefficient_val(get(), static_cast<enum isl_dim_type>(type), pos);\n  return manage(res);\n}\n\nval aff::get_constant_val() const\n{\n  auto res = isl_aff_get_constant_val(get());\n  return manage(res);\n}\n\nval aff::get_denominator_val() const\n{\n  auto res = isl_aff_get_denominator_val(get());\n  return manage(res);\n}\n\nstd::string aff::get_dim_name(isl::dim type, unsigned int pos) const\n{\n  auto res = isl_aff_get_dim_name(get(), static_cast<enum isl_dim_type>(type), pos);\n  std::string tmp(res);\n  return tmp;\n}\n\naff aff::get_div(int pos) const\n{\n  auto res = isl_aff_get_div(get(), pos);\n  return manage(res);\n}\n\nlocal_space aff::get_domain_local_space() const\n{\n  auto res = isl_aff_get_domain_local_space(get());\n  return manage(res);\n}\n\nspace aff::get_domain_space() const\n{\n  auto res = isl_aff_get_domain_space(get());\n  return manage(res);\n}\n\nuint32_t aff::get_hash() const\n{\n  auto res = isl_aff_get_hash(get());\n  return res;\n}\n\nlocal_space aff::get_local_space() const\n{\n  auto res = isl_aff_get_local_space(get());\n  return manage(res);\n}\n\nspace aff::get_space() const\n{\n  auto res = isl_aff_get_space(get());\n  return manage(res);\n}\n\naff aff::gist(set context) const\n{\n  auto res = isl_aff_gist(copy(), context.release());\n  return manage(res);\n}\n\naff aff::gist_params(set context) const\n{\n  auto res = isl_aff_gist_params(copy(), context.release());\n  return manage(res);\n}\n\nbasic_set aff::gt_basic_set(aff aff2) const\n{\n  auto res = isl_aff_gt_basic_set(copy(), aff2.release());\n  return manage(res);\n}\n\nset aff::gt_set(aff aff2) const\n{\n  auto res = isl_aff_gt_set(copy(), aff2.release());\n  return manage(res);\n}\n\naff aff::insert_dims(isl::dim type, unsigned int first, unsigned int n) const\n{\n  auto res = isl_aff_insert_dims(copy(), static_cast<enum isl_dim_type>(type), first, n);\n  return manage(res);\n}\n\nboolean aff::involves_dims(isl::dim type, unsigned int first, unsigned int n) const\n{\n  auto res = isl_aff_involves_dims(get(), static_cast<enum isl_dim_type>(type), first, n);\n  return manage(res);\n}\n\nboolean aff::involves_locals() const\n{\n  auto res = isl_aff_involves_locals(get());\n  return manage(res);\n}\n\nboolean aff::is_cst() const\n{\n  auto res = isl_aff_is_cst(get());\n  return manage(res);\n}\n\nboolean aff::is_nan() const\n{\n  auto res = isl_aff_is_nan(get());\n  return manage(res);\n}\n\nbasic_set aff::le_basic_set(aff aff2) const\n{\n  auto res = isl_aff_le_basic_set(copy(), aff2.release());\n  return manage(res);\n}\n\nset aff::le_set(aff aff2) const\n{\n  auto res = isl_aff_le_set(copy(), aff2.release());\n  return manage(res);\n}\n\nbasic_set aff::lt_basic_set(aff aff2) const\n{\n  auto res = isl_aff_lt_basic_set(copy(), aff2.release());\n  return manage(res);\n}\n\nset aff::lt_set(aff aff2) const\n{\n  auto res = isl_aff_lt_set(copy(), aff2.release());\n  return manage(res);\n}\n\naff aff::mod(val mod) const\n{\n  auto res = isl_aff_mod_val(copy(), mod.release());\n  return manage(res);\n}\n\naff aff::move_dims(isl::dim dst_type, unsigned int dst_pos, isl::dim src_type, unsigned int src_pos, unsigned int n) const\n{\n  auto res = isl_aff_move_dims(copy(), static_cast<enum isl_dim_type>(dst_type), dst_pos, static_cast<enum isl_dim_type>(src_type), src_pos, n);\n  return manage(res);\n}\n\naff aff::mul(aff aff2) const\n{\n  auto res = isl_aff_mul(copy(), aff2.release());\n  return manage(res);\n}\n\naff aff::nan_on_domain(local_space ls)\n{\n  auto res = isl_aff_nan_on_domain(ls.release());\n  return manage(res);\n}\n\naff aff::nan_on_domain_space(space space)\n{\n  auto res = isl_aff_nan_on_domain_space(space.release());\n  return manage(res);\n}\n\nset aff::ne_set(aff aff2) const\n{\n  auto res = isl_aff_ne_set(copy(), aff2.release());\n  return manage(res);\n}\n\naff aff::neg() const\n{\n  auto res = isl_aff_neg(copy());\n  return manage(res);\n}\n\nbasic_set aff::neg_basic_set() const\n{\n  auto res = isl_aff_neg_basic_set(copy());\n  return manage(res);\n}\n\naff aff::param_on_domain_space_id(space space, id id)\n{\n  auto res = isl_aff_param_on_domain_space_id(space.release(), id.release());\n  return manage(res);\n}\n\nboolean aff::plain_is_equal(const aff &aff2) const\n{\n  auto res = isl_aff_plain_is_equal(get(), aff2.get());\n  return manage(res);\n}\n\nboolean aff::plain_is_zero() const\n{\n  auto res = isl_aff_plain_is_zero(get());\n  return manage(res);\n}\n\naff aff::project_domain_on_params() const\n{\n  auto res = isl_aff_project_domain_on_params(copy());\n  return manage(res);\n}\n\naff aff::pullback(multi_aff ma) const\n{\n  auto res = isl_aff_pullback_multi_aff(copy(), ma.release());\n  return manage(res);\n}\n\naff aff::pullback_aff(aff aff2) const\n{\n  auto res = isl_aff_pullback_aff(copy(), aff2.release());\n  return manage(res);\n}\n\naff aff::scale(val v) const\n{\n  auto res = isl_aff_scale_val(copy(), v.release());\n  return manage(res);\n}\n\naff aff::scale_down(val v) const\n{\n  auto res = isl_aff_scale_down_val(copy(), v.release());\n  return manage(res);\n}\n\naff aff::scale_down_ui(unsigned int f) const\n{\n  auto res = isl_aff_scale_down_ui(copy(), f);\n  return manage(res);\n}\n\naff aff::set_coefficient_si(isl::dim type, int pos, int v) const\n{\n  auto res = isl_aff_set_coefficient_si(copy(), static_cast<enum isl_dim_type>(type), pos, v);\n  return manage(res);\n}\n\naff aff::set_coefficient_val(isl::dim type, int pos, val v) const\n{\n  auto res = isl_aff_set_coefficient_val(copy(), static_cast<enum isl_dim_type>(type), pos, v.release());\n  return manage(res);\n}\n\naff aff::set_constant_si(int v) const\n{\n  auto res = isl_aff_set_constant_si(copy(), v);\n  return manage(res);\n}\n\naff aff::set_constant_val(val v) const\n{\n  auto res = isl_aff_set_constant_val(copy(), v.release());\n  return manage(res);\n}\n\naff aff::set_dim_id(isl::dim type, unsigned int pos, id id) const\n{\n  auto res = isl_aff_set_dim_id(copy(), static_cast<enum isl_dim_type>(type), pos, id.release());\n  return manage(res);\n}\n\naff aff::set_tuple_id(isl::dim type, id id) const\n{\n  auto res = isl_aff_set_tuple_id(copy(), static_cast<enum isl_dim_type>(type), id.release());\n  return manage(res);\n}\n\naff aff::sub(aff aff2) const\n{\n  auto res = isl_aff_sub(copy(), aff2.release());\n  return manage(res);\n}\n\naff aff::unbind_params_insert_domain(multi_id domain) const\n{\n  auto res = isl_aff_unbind_params_insert_domain(copy(), domain.release());\n  return manage(res);\n}\n\naff aff::val_on_domain_space(space space, val val)\n{\n  auto res = isl_aff_val_on_domain_space(space.release(), val.release());\n  return manage(res);\n}\n\naff aff::var_on_domain(local_space ls, isl::dim type, unsigned int pos)\n{\n  auto res = isl_aff_var_on_domain(ls.release(), static_cast<enum isl_dim_type>(type), pos);\n  return manage(res);\n}\n\nbasic_set aff::zero_basic_set() const\n{\n  auto res = isl_aff_zero_basic_set(copy());\n  return manage(res);\n}\n\naff aff::zero_on_domain(space space)\n{\n  auto res = isl_aff_zero_on_domain_space(space.release());\n  return manage(res);\n}\n\n// implementations for isl::aff_list\naff_list manage(__isl_take isl_aff_list *ptr) {\n  return aff_list(ptr);\n}\naff_list manage_copy(__isl_keep isl_aff_list *ptr) {\n  ptr = isl_aff_list_copy(ptr);\n  return aff_list(ptr);\n}\n\naff_list::aff_list()\n    : ptr(nullptr) {}\n\naff_list::aff_list(const aff_list &obj)\n    : ptr(nullptr)\n{\n  ptr = obj.copy();\n}\naff_list::aff_list(std::nullptr_t)\n    : ptr(nullptr) {}\n\n\naff_list::aff_list(__isl_take isl_aff_list *ptr)\n    : ptr(ptr) {}\n\n\naff_list &aff_list::operator=(aff_list obj) {\n  std::swap(this->ptr, obj.ptr);\n  return *this;\n}\n\naff_list::~aff_list() {\n  if (ptr)\n    isl_aff_list_free(ptr);\n}\n\n__isl_give isl_aff_list *aff_list::copy() const & {\n  return isl_aff_list_copy(ptr);\n}\n\n__isl_keep isl_aff_list *aff_list::get() const {\n  return ptr;\n}\n\n__isl_give isl_aff_list *aff_list::release() {\n  isl_aff_list *tmp = ptr;\n  ptr = nullptr;\n  return tmp;\n}\n\nbool aff_list::is_null() const {\n  return ptr == nullptr;\n}\naff_list::operator bool() const {\n  return !is_null();\n}\n\n\nctx aff_list::get_ctx() const {\n  return ctx(isl_aff_list_get_ctx(ptr));\n}\nstd::string aff_list::to_str() const {\n  char *Tmp = isl_aff_list_to_str(get());\n  if (!Tmp)\n    return \"\";\n  std::string S(Tmp);\n  free(Tmp);\n  return S;\n}\n\n\nvoid aff_list::dump() const {\n  isl_aff_list_dump(get());\n}\n\n\naff_list aff_list::add(aff el) const\n{\n  auto res = isl_aff_list_add(copy(), el.release());\n  return manage(res);\n}\n\naff_list aff_list::alloc(ctx ctx, int n)\n{\n  auto res = isl_aff_list_alloc(ctx.release(), n);\n  return manage(res);\n}\n\naff_list aff_list::clear() const\n{\n  auto res = isl_aff_list_clear(copy());\n  return manage(res);\n}\n\naff_list aff_list::concat(aff_list list2) const\n{\n  auto res = isl_aff_list_concat(copy(), list2.release());\n  return manage(res);\n}\n\naff_list aff_list::drop(unsigned int first, unsigned int n) const\n{\n  auto res = isl_aff_list_drop(copy(), first, n);\n  return manage(res);\n}\n\nstat aff_list::foreach(const std::function<stat(aff)> &fn) const\n{\n  struct fn_data {\n    const std::function<stat(aff)> *func;\n  } fn_data = { &fn };\n  auto fn_lambda = [](isl_aff *arg_0, void *arg_1) -> isl_stat {\n    auto *data = static_cast<struct fn_data *>(arg_1);\n    stat ret = (*data->func)(manage(arg_0));\n    return ret.release();\n  };\n  auto res = isl_aff_list_foreach(get(), fn_lambda, &fn_data);\n  return manage(res);\n}\n\naff_list aff_list::from_aff(aff el)\n{\n  auto res = isl_aff_list_from_aff(el.release());\n  return manage(res);\n}\n\naff aff_list::get_aff(int index) const\n{\n  auto res = isl_aff_list_get_aff(get(), index);\n  return manage(res);\n}\n\naff aff_list::get_at(int index) const\n{\n  auto res = isl_aff_list_get_at(get(), index);\n  return manage(res);\n}\n\naff_list aff_list::insert(unsigned int pos, aff el) const\n{\n  auto res = isl_aff_list_insert(copy(), pos, el.release());\n  return manage(res);\n}\n\nisl_size aff_list::n_aff() const\n{\n  auto res = isl_aff_list_n_aff(get());\n  return res;\n}\n\naff_list aff_list::reverse() const\n{\n  auto res = isl_aff_list_reverse(copy());\n  return manage(res);\n}\n\naff_list aff_list::set_aff(int index, aff el) const\n{\n  auto res = isl_aff_list_set_aff(copy(), index, el.release());\n  return manage(res);\n}\n\nisl_size aff_list::size() const\n{\n  auto res = isl_aff_list_size(get());\n  return res;\n}\n\naff_list aff_list::swap(unsigned int pos1, unsigned int pos2) const\n{\n  auto res = isl_aff_list_swap(copy(), pos1, pos2);\n  return manage(res);\n}\n\n// implementations for isl::ast_build\nast_build manage(__isl_take isl_ast_build *ptr) {\n  return ast_build(ptr);\n}\nast_build manage_copy(__isl_keep isl_ast_build *ptr) {\n  ptr = isl_ast_build_copy(ptr);\n  return ast_build(ptr);\n}\n\nast_build::ast_build()\n    : ptr(nullptr) {}\n\nast_build::ast_build(const ast_build &obj)\n    : ptr(nullptr)\n{\n  ptr = obj.copy();\n}\nast_build::ast_build(std::nullptr_t)\n    : ptr(nullptr) {}\n\n\nast_build::ast_build(__isl_take isl_ast_build *ptr)\n    : ptr(ptr) {}\n\nast_build::ast_build(ctx ctx)\n{\n  auto res = isl_ast_build_alloc(ctx.release());\n  ptr = res;\n}\n\nast_build &ast_build::operator=(ast_build obj) {\n  std::swap(this->ptr, obj.ptr);\n  return *this;\n}\n\nast_build::~ast_build() {\n  if (ptr)\n    isl_ast_build_free(ptr);\n}\n\n__isl_give isl_ast_build *ast_build::copy() const & {\n  return isl_ast_build_copy(ptr);\n}\n\n__isl_keep isl_ast_build *ast_build::get() const {\n  return ptr;\n}\n\n__isl_give isl_ast_build *ast_build::release() {\n  isl_ast_build *tmp = ptr;\n  ptr = nullptr;\n  return tmp;\n}\n\nbool ast_build::is_null() const {\n  return ptr == nullptr;\n}\nast_build::operator bool() const {\n  return !is_null();\n}\n\n\nctx ast_build::get_ctx() const {\n  return ctx(isl_ast_build_get_ctx(ptr));\n}\n\n\nast_expr ast_build::access_from(multi_pw_aff mpa) const\n{\n  auto res = isl_ast_build_access_from_multi_pw_aff(get(), mpa.release());\n  return manage(res);\n}\n\nast_expr ast_build::access_from(pw_multi_aff pma) const\n{\n  auto res = isl_ast_build_access_from_pw_multi_aff(get(), pma.release());\n  return manage(res);\n}\n\nast_node ast_build::ast_from_schedule(union_map schedule) const\n{\n  auto res = isl_ast_build_ast_from_schedule(get(), schedule.release());\n  return manage(res);\n}\n\nast_expr ast_build::call_from(multi_pw_aff mpa) const\n{\n  auto res = isl_ast_build_call_from_multi_pw_aff(get(), mpa.release());\n  return manage(res);\n}\n\nast_expr ast_build::call_from(pw_multi_aff pma) const\n{\n  auto res = isl_ast_build_call_from_pw_multi_aff(get(), pma.release());\n  return manage(res);\n}\n\nast_expr ast_build::expr_from(pw_aff pa) const\n{\n  auto res = isl_ast_build_expr_from_pw_aff(get(), pa.release());\n  return manage(res);\n}\n\nast_expr ast_build::expr_from(set set) const\n{\n  auto res = isl_ast_build_expr_from_set(get(), set.release());\n  return manage(res);\n}\n\nast_build ast_build::from_context(set set)\n{\n  auto res = isl_ast_build_from_context(set.release());\n  return manage(res);\n}\n\nunion_map ast_build::get_schedule() const\n{\n  auto res = isl_ast_build_get_schedule(get());\n  return manage(res);\n}\n\nspace ast_build::get_schedule_space() const\n{\n  auto res = isl_ast_build_get_schedule_space(get());\n  return manage(res);\n}\n\nast_node ast_build::node_from(schedule schedule) const\n{\n  auto res = isl_ast_build_node_from_schedule(get(), schedule.release());\n  return manage(res);\n}\n\nast_node ast_build::node_from_schedule_map(union_map schedule) const\n{\n  auto res = isl_ast_build_node_from_schedule_map(get(), schedule.release());\n  return manage(res);\n}\n\nast_build ast_build::restrict(set set) const\n{\n  auto res = isl_ast_build_restrict(copy(), set.release());\n  return manage(res);\n}\n\n// implementations for isl::ast_expr\nast_expr manage(__isl_take isl_ast_expr *ptr) {\n  return ast_expr(ptr);\n}\nast_expr manage_copy(__isl_keep isl_ast_expr *ptr) {\n  ptr = isl_ast_expr_copy(ptr);\n  return ast_expr(ptr);\n}\n\nast_expr::ast_expr()\n    : ptr(nullptr) {}\n\nast_expr::ast_expr(const ast_expr &obj)\n    : ptr(nullptr)\n{\n  ptr = obj.copy();\n}\nast_expr::ast_expr(std::nullptr_t)\n    : ptr(nullptr) {}\n\n\nast_expr::ast_expr(__isl_take isl_ast_expr *ptr)\n    : ptr(ptr) {}\n\n\nast_expr &ast_expr::operator=(ast_expr obj) {\n  std::swap(this->ptr, obj.ptr);\n  return *this;\n}\n\nast_expr::~ast_expr() {\n  if (ptr)\n    isl_ast_expr_free(ptr);\n}\n\n__isl_give isl_ast_expr *ast_expr::copy() const & {\n  return isl_ast_expr_copy(ptr);\n}\n\n__isl_keep isl_ast_expr *ast_expr::get() const {\n  return ptr;\n}\n\n__isl_give isl_ast_expr *ast_expr::release() {\n  isl_ast_expr *tmp = ptr;\n  ptr = nullptr;\n  return tmp;\n}\n\nbool ast_expr::is_null() const {\n  return ptr == nullptr;\n}\nast_expr::operator bool() const {\n  return !is_null();\n}\n\n\nctx ast_expr::get_ctx() const {\n  return ctx(isl_ast_expr_get_ctx(ptr));\n}\nstd::string ast_expr::to_str() const {\n  char *Tmp = isl_ast_expr_to_str(get());\n  if (!Tmp)\n    return \"\";\n  std::string S(Tmp);\n  free(Tmp);\n  return S;\n}\n\n\nvoid ast_expr::dump() const {\n  isl_ast_expr_dump(get());\n}\n\n\nast_expr ast_expr::access(ast_expr_list indices) const\n{\n  auto res = isl_ast_expr_access(copy(), indices.release());\n  return manage(res);\n}\n\nast_expr ast_expr::add(ast_expr expr2) const\n{\n  auto res = isl_ast_expr_add(copy(), expr2.release());\n  return manage(res);\n}\n\nast_expr ast_expr::address_of() const\n{\n  auto res = isl_ast_expr_address_of(copy());\n  return manage(res);\n}\n\nast_expr ast_expr::call(ast_expr_list arguments) const\n{\n  auto res = isl_ast_expr_call(copy(), arguments.release());\n  return manage(res);\n}\n\nast_expr ast_expr::div(ast_expr expr2) const\n{\n  auto res = isl_ast_expr_div(copy(), expr2.release());\n  return manage(res);\n}\n\nast_expr ast_expr::eq(ast_expr expr2) const\n{\n  auto res = isl_ast_expr_eq(copy(), expr2.release());\n  return manage(res);\n}\n\nast_expr ast_expr::from_id(id id)\n{\n  auto res = isl_ast_expr_from_id(id.release());\n  return manage(res);\n}\n\nast_expr ast_expr::from_val(val v)\n{\n  auto res = isl_ast_expr_from_val(v.release());\n  return manage(res);\n}\n\nast_expr ast_expr::ge(ast_expr expr2) const\n{\n  auto res = isl_ast_expr_ge(copy(), expr2.release());\n  return manage(res);\n}\n\nid ast_expr::get_id() const\n{\n  auto res = isl_ast_expr_get_id(get());\n  return manage(res);\n}\n\nast_expr ast_expr::get_op_arg(int pos) const\n{\n  auto res = isl_ast_expr_get_op_arg(get(), pos);\n  return manage(res);\n}\n\nisl_size ast_expr::get_op_n_arg() const\n{\n  auto res = isl_ast_expr_get_op_n_arg(get());\n  return res;\n}\n\nval ast_expr::get_val() const\n{\n  auto res = isl_ast_expr_get_val(get());\n  return manage(res);\n}\n\nast_expr ast_expr::gt(ast_expr expr2) const\n{\n  auto res = isl_ast_expr_gt(copy(), expr2.release());\n  return manage(res);\n}\n\nid ast_expr::id_get_id() const\n{\n  auto res = isl_ast_expr_id_get_id(get());\n  return manage(res);\n}\n\nval ast_expr::int_get_val() const\n{\n  auto res = isl_ast_expr_int_get_val(get());\n  return manage(res);\n}\n\nboolean ast_expr::is_equal(const ast_expr &expr2) const\n{\n  auto res = isl_ast_expr_is_equal(get(), expr2.get());\n  return manage(res);\n}\n\nast_expr ast_expr::le(ast_expr expr2) const\n{\n  auto res = isl_ast_expr_le(copy(), expr2.release());\n  return manage(res);\n}\n\nast_expr ast_expr::lt(ast_expr expr2) const\n{\n  auto res = isl_ast_expr_lt(copy(), expr2.release());\n  return manage(res);\n}\n\nast_expr ast_expr::mul(ast_expr expr2) const\n{\n  auto res = isl_ast_expr_mul(copy(), expr2.release());\n  return manage(res);\n}\n\nast_expr ast_expr::neg() const\n{\n  auto res = isl_ast_expr_neg(copy());\n  return manage(res);\n}\n\nast_expr ast_expr::op_get_arg(int pos) const\n{\n  auto res = isl_ast_expr_op_get_arg(get(), pos);\n  return manage(res);\n}\n\nisl_size ast_expr::op_get_n_arg() const\n{\n  auto res = isl_ast_expr_op_get_n_arg(get());\n  return res;\n}\n\nast_expr ast_expr::pdiv_q(ast_expr expr2) const\n{\n  auto res = isl_ast_expr_pdiv_q(copy(), expr2.release());\n  return manage(res);\n}\n\nast_expr ast_expr::pdiv_r(ast_expr expr2) const\n{\n  auto res = isl_ast_expr_pdiv_r(copy(), expr2.release());\n  return manage(res);\n}\n\nast_expr ast_expr::set_op_arg(int pos, ast_expr arg) const\n{\n  auto res = isl_ast_expr_set_op_arg(copy(), pos, arg.release());\n  return manage(res);\n}\n\nast_expr ast_expr::sub(ast_expr expr2) const\n{\n  auto res = isl_ast_expr_sub(copy(), expr2.release());\n  return manage(res);\n}\n\nast_expr ast_expr::substitute_ids(id_to_ast_expr id2expr) const\n{\n  auto res = isl_ast_expr_substitute_ids(copy(), id2expr.release());\n  return manage(res);\n}\n\nstd::string ast_expr::to_C_str() const\n{\n  auto res = isl_ast_expr_to_C_str(get());\n  std::string tmp(res);\n  free(res);\n  return tmp;\n}\n\n// implementations for isl::ast_expr_list\nast_expr_list manage(__isl_take isl_ast_expr_list *ptr) {\n  return ast_expr_list(ptr);\n}\nast_expr_list manage_copy(__isl_keep isl_ast_expr_list *ptr) {\n  ptr = isl_ast_expr_list_copy(ptr);\n  return ast_expr_list(ptr);\n}\n\nast_expr_list::ast_expr_list()\n    : ptr(nullptr) {}\n\nast_expr_list::ast_expr_list(const ast_expr_list &obj)\n    : ptr(nullptr)\n{\n  ptr = obj.copy();\n}\nast_expr_list::ast_expr_list(std::nullptr_t)\n    : ptr(nullptr) {}\n\n\nast_expr_list::ast_expr_list(__isl_take isl_ast_expr_list *ptr)\n    : ptr(ptr) {}\n\n\nast_expr_list &ast_expr_list::operator=(ast_expr_list obj) {\n  std::swap(this->ptr, obj.ptr);\n  return *this;\n}\n\nast_expr_list::~ast_expr_list() {\n  if (ptr)\n    isl_ast_expr_list_free(ptr);\n}\n\n__isl_give isl_ast_expr_list *ast_expr_list::copy() const & {\n  return isl_ast_expr_list_copy(ptr);\n}\n\n__isl_keep isl_ast_expr_list *ast_expr_list::get() const {\n  return ptr;\n}\n\n__isl_give isl_ast_expr_list *ast_expr_list::release() {\n  isl_ast_expr_list *tmp = ptr;\n  ptr = nullptr;\n  return tmp;\n}\n\nbool ast_expr_list::is_null() const {\n  return ptr == nullptr;\n}\nast_expr_list::operator bool() const {\n  return !is_null();\n}\n\n\nctx ast_expr_list::get_ctx() const {\n  return ctx(isl_ast_expr_list_get_ctx(ptr));\n}\nstd::string ast_expr_list::to_str() const {\n  char *Tmp = isl_ast_expr_list_to_str(get());\n  if (!Tmp)\n    return \"\";\n  std::string S(Tmp);\n  free(Tmp);\n  return S;\n}\n\n\nvoid ast_expr_list::dump() const {\n  isl_ast_expr_list_dump(get());\n}\n\n\nast_expr_list ast_expr_list::add(ast_expr el) const\n{\n  auto res = isl_ast_expr_list_add(copy(), el.release());\n  return manage(res);\n}\n\nast_expr_list ast_expr_list::alloc(ctx ctx, int n)\n{\n  auto res = isl_ast_expr_list_alloc(ctx.release(), n);\n  return manage(res);\n}\n\nast_expr_list ast_expr_list::clear() const\n{\n  auto res = isl_ast_expr_list_clear(copy());\n  return manage(res);\n}\n\nast_expr_list ast_expr_list::concat(ast_expr_list list2) const\n{\n  auto res = isl_ast_expr_list_concat(copy(), list2.release());\n  return manage(res);\n}\n\nast_expr_list ast_expr_list::drop(unsigned int first, unsigned int n) const\n{\n  auto res = isl_ast_expr_list_drop(copy(), first, n);\n  return manage(res);\n}\n\nstat ast_expr_list::foreach(const std::function<stat(ast_expr)> &fn) const\n{\n  struct fn_data {\n    const std::function<stat(ast_expr)> *func;\n  } fn_data = { &fn };\n  auto fn_lambda = [](isl_ast_expr *arg_0, void *arg_1) -> isl_stat {\n    auto *data = static_cast<struct fn_data *>(arg_1);\n    stat ret = (*data->func)(manage(arg_0));\n    return ret.release();\n  };\n  auto res = isl_ast_expr_list_foreach(get(), fn_lambda, &fn_data);\n  return manage(res);\n}\n\nast_expr_list ast_expr_list::from_ast_expr(ast_expr el)\n{\n  auto res = isl_ast_expr_list_from_ast_expr(el.release());\n  return manage(res);\n}\n\nast_expr ast_expr_list::get_ast_expr(int index) const\n{\n  auto res = isl_ast_expr_list_get_ast_expr(get(), index);\n  return manage(res);\n}\n\nast_expr ast_expr_list::get_at(int index) const\n{\n  auto res = isl_ast_expr_list_get_at(get(), index);\n  return manage(res);\n}\n\nast_expr_list ast_expr_list::insert(unsigned int pos, ast_expr el) const\n{\n  auto res = isl_ast_expr_list_insert(copy(), pos, el.release());\n  return manage(res);\n}\n\nisl_size ast_expr_list::n_ast_expr() const\n{\n  auto res = isl_ast_expr_list_n_ast_expr(get());\n  return res;\n}\n\nast_expr_list ast_expr_list::reverse() const\n{\n  auto res = isl_ast_expr_list_reverse(copy());\n  return manage(res);\n}\n\nast_expr_list ast_expr_list::set_ast_expr(int index, ast_expr el) const\n{\n  auto res = isl_ast_expr_list_set_ast_expr(copy(), index, el.release());\n  return manage(res);\n}\n\nisl_size ast_expr_list::size() const\n{\n  auto res = isl_ast_expr_list_size(get());\n  return res;\n}\n\nast_expr_list ast_expr_list::swap(unsigned int pos1, unsigned int pos2) const\n{\n  auto res = isl_ast_expr_list_swap(copy(), pos1, pos2);\n  return manage(res);\n}\n\n// implementations for isl::ast_node\nast_node manage(__isl_take isl_ast_node *ptr) {\n  return ast_node(ptr);\n}\nast_node manage_copy(__isl_keep isl_ast_node *ptr) {\n  ptr = isl_ast_node_copy(ptr);\n  return ast_node(ptr);\n}\n\nast_node::ast_node()\n    : ptr(nullptr) {}\n\nast_node::ast_node(const ast_node &obj)\n    : ptr(nullptr)\n{\n  ptr = obj.copy();\n}\nast_node::ast_node(std::nullptr_t)\n    : ptr(nullptr) {}\n\n\nast_node::ast_node(__isl_take isl_ast_node *ptr)\n    : ptr(ptr) {}\n\n\nast_node &ast_node::operator=(ast_node obj) {\n  std::swap(this->ptr, obj.ptr);\n  return *this;\n}\n\nast_node::~ast_node() {\n  if (ptr)\n    isl_ast_node_free(ptr);\n}\n\n__isl_give isl_ast_node *ast_node::copy() const & {\n  return isl_ast_node_copy(ptr);\n}\n\n__isl_keep isl_ast_node *ast_node::get() const {\n  return ptr;\n}\n\n__isl_give isl_ast_node *ast_node::release() {\n  isl_ast_node *tmp = ptr;\n  ptr = nullptr;\n  return tmp;\n}\n\nbool ast_node::is_null() const {\n  return ptr == nullptr;\n}\nast_node::operator bool() const {\n  return !is_null();\n}\n\n\nctx ast_node::get_ctx() const {\n  return ctx(isl_ast_node_get_ctx(ptr));\n}\nstd::string ast_node::to_str() const {\n  char *Tmp = isl_ast_node_to_str(get());\n  if (!Tmp)\n    return \"\";\n  std::string S(Tmp);\n  free(Tmp);\n  return S;\n}\n\n\nvoid ast_node::dump() const {\n  isl_ast_node_dump(get());\n}\n\n\nast_node ast_node::alloc_user(ast_expr expr)\n{\n  auto res = isl_ast_node_alloc_user(expr.release());\n  return manage(res);\n}\n\nast_node_list ast_node::block_get_children() const\n{\n  auto res = isl_ast_node_block_get_children(get());\n  return manage(res);\n}\n\nast_node ast_node::for_get_body() const\n{\n  auto res = isl_ast_node_for_get_body(get());\n  return manage(res);\n}\n\nast_expr ast_node::for_get_cond() const\n{\n  auto res = isl_ast_node_for_get_cond(get());\n  return manage(res);\n}\n\nast_expr ast_node::for_get_inc() const\n{\n  auto res = isl_ast_node_for_get_inc(get());\n  return manage(res);\n}\n\nast_expr ast_node::for_get_init() const\n{\n  auto res = isl_ast_node_for_get_init(get());\n  return manage(res);\n}\n\nast_expr ast_node::for_get_iterator() const\n{\n  auto res = isl_ast_node_for_get_iterator(get());\n  return manage(res);\n}\n\nboolean ast_node::for_is_degenerate() const\n{\n  auto res = isl_ast_node_for_is_degenerate(get());\n  return manage(res);\n}\n\nid ast_node::get_annotation() const\n{\n  auto res = isl_ast_node_get_annotation(get());\n  return manage(res);\n}\n\nast_expr ast_node::if_get_cond() const\n{\n  auto res = isl_ast_node_if_get_cond(get());\n  return manage(res);\n}\n\nast_node ast_node::if_get_else() const\n{\n  auto res = isl_ast_node_if_get_else(get());\n  return manage(res);\n}\n\nast_node ast_node::if_get_else_node() const\n{\n  auto res = isl_ast_node_if_get_else_node(get());\n  return manage(res);\n}\n\nast_node ast_node::if_get_then() const\n{\n  auto res = isl_ast_node_if_get_then(get());\n  return manage(res);\n}\n\nast_node ast_node::if_get_then_node() const\n{\n  auto res = isl_ast_node_if_get_then_node(get());\n  return manage(res);\n}\n\nboolean ast_node::if_has_else() const\n{\n  auto res = isl_ast_node_if_has_else(get());\n  return manage(res);\n}\n\nboolean ast_node::if_has_else_node() const\n{\n  auto res = isl_ast_node_if_has_else_node(get());\n  return manage(res);\n}\n\nid ast_node::mark_get_id() const\n{\n  auto res = isl_ast_node_mark_get_id(get());\n  return manage(res);\n}\n\nast_node ast_node::mark_get_node() const\n{\n  auto res = isl_ast_node_mark_get_node(get());\n  return manage(res);\n}\n\nast_node ast_node::set_annotation(id annotation) const\n{\n  auto res = isl_ast_node_set_annotation(copy(), annotation.release());\n  return manage(res);\n}\n\nstd::string ast_node::to_C_str() const\n{\n  auto res = isl_ast_node_to_C_str(get());\n  std::string tmp(res);\n  free(res);\n  return tmp;\n}\n\nast_expr ast_node::user_get_expr() const\n{\n  auto res = isl_ast_node_user_get_expr(get());\n  return manage(res);\n}\n\n// implementations for isl::ast_node_list\nast_node_list manage(__isl_take isl_ast_node_list *ptr) {\n  return ast_node_list(ptr);\n}\nast_node_list manage_copy(__isl_keep isl_ast_node_list *ptr) {\n  ptr = isl_ast_node_list_copy(ptr);\n  return ast_node_list(ptr);\n}\n\nast_node_list::ast_node_list()\n    : ptr(nullptr) {}\n\nast_node_list::ast_node_list(const ast_node_list &obj)\n    : ptr(nullptr)\n{\n  ptr = obj.copy();\n}\nast_node_list::ast_node_list(std::nullptr_t)\n    : ptr(nullptr) {}\n\n\nast_node_list::ast_node_list(__isl_take isl_ast_node_list *ptr)\n    : ptr(ptr) {}\n\n\nast_node_list &ast_node_list::operator=(ast_node_list obj) {\n  std::swap(this->ptr, obj.ptr);\n  return *this;\n}\n\nast_node_list::~ast_node_list() {\n  if (ptr)\n    isl_ast_node_list_free(ptr);\n}\n\n__isl_give isl_ast_node_list *ast_node_list::copy() const & {\n  return isl_ast_node_list_copy(ptr);\n}\n\n__isl_keep isl_ast_node_list *ast_node_list::get() const {\n  return ptr;\n}\n\n__isl_give isl_ast_node_list *ast_node_list::release() {\n  isl_ast_node_list *tmp = ptr;\n  ptr = nullptr;\n  return tmp;\n}\n\nbool ast_node_list::is_null() const {\n  return ptr == nullptr;\n}\nast_node_list::operator bool() const {\n  return !is_null();\n}\n\n\nctx ast_node_list::get_ctx() const {\n  return ctx(isl_ast_node_list_get_ctx(ptr));\n}\nstd::string ast_node_list::to_str() const {\n  char *Tmp = isl_ast_node_list_to_str(get());\n  if (!Tmp)\n    return \"\";\n  std::string S(Tmp);\n  free(Tmp);\n  return S;\n}\n\n\nvoid ast_node_list::dump() const {\n  isl_ast_node_list_dump(get());\n}\n\n\nast_node_list ast_node_list::add(ast_node el) const\n{\n  auto res = isl_ast_node_list_add(copy(), el.release());\n  return manage(res);\n}\n\nast_node_list ast_node_list::alloc(ctx ctx, int n)\n{\n  auto res = isl_ast_node_list_alloc(ctx.release(), n);\n  return manage(res);\n}\n\nast_node_list ast_node_list::clear() const\n{\n  auto res = isl_ast_node_list_clear(copy());\n  return manage(res);\n}\n\nast_node_list ast_node_list::concat(ast_node_list list2) const\n{\n  auto res = isl_ast_node_list_concat(copy(), list2.release());\n  return manage(res);\n}\n\nast_node_list ast_node_list::drop(unsigned int first, unsigned int n) const\n{\n  auto res = isl_ast_node_list_drop(copy(), first, n);\n  return manage(res);\n}\n\nstat ast_node_list::foreach(const std::function<stat(ast_node)> &fn) const\n{\n  struct fn_data {\n    const std::function<stat(ast_node)> *func;\n  } fn_data = { &fn };\n  auto fn_lambda = [](isl_ast_node *arg_0, void *arg_1) -> isl_stat {\n    auto *data = static_cast<struct fn_data *>(arg_1);\n    stat ret = (*data->func)(manage(arg_0));\n    return ret.release();\n  };\n  auto res = isl_ast_node_list_foreach(get(), fn_lambda, &fn_data);\n  return manage(res);\n}\n\nast_node_list ast_node_list::from_ast_node(ast_node el)\n{\n  auto res = isl_ast_node_list_from_ast_node(el.release());\n  return manage(res);\n}\n\nast_node ast_node_list::get_ast_node(int index) const\n{\n  auto res = isl_ast_node_list_get_ast_node(get(), index);\n  return manage(res);\n}\n\nast_node ast_node_list::get_at(int index) const\n{\n  auto res = isl_ast_node_list_get_at(get(), index);\n  return manage(res);\n}\n\nast_node_list ast_node_list::insert(unsigned int pos, ast_node el) const\n{\n  auto res = isl_ast_node_list_insert(copy(), pos, el.release());\n  return manage(res);\n}\n\nisl_size ast_node_list::n_ast_node() const\n{\n  auto res = isl_ast_node_list_n_ast_node(get());\n  return res;\n}\n\nast_node_list ast_node_list::reverse() const\n{\n  auto res = isl_ast_node_list_reverse(copy());\n  return manage(res);\n}\n\nast_node_list ast_node_list::set_ast_node(int index, ast_node el) const\n{\n  auto res = isl_ast_node_list_set_ast_node(copy(), index, el.release());\n  return manage(res);\n}\n\nisl_size ast_node_list::size() const\n{\n  auto res = isl_ast_node_list_size(get());\n  return res;\n}\n\nast_node_list ast_node_list::swap(unsigned int pos1, unsigned int pos2) const\n{\n  auto res = isl_ast_node_list_swap(copy(), pos1, pos2);\n  return manage(res);\n}\n\n// implementations for isl::basic_map\nbasic_map manage(__isl_take isl_basic_map *ptr) {\n  return basic_map(ptr);\n}\nbasic_map manage_copy(__isl_keep isl_basic_map *ptr) {\n  ptr = isl_basic_map_copy(ptr);\n  return basic_map(ptr);\n}\n\nbasic_map::basic_map()\n    : ptr(nullptr) {}\n\nbasic_map::basic_map(const basic_map &obj)\n    : ptr(nullptr)\n{\n  ptr = obj.copy();\n}\nbasic_map::basic_map(std::nullptr_t)\n    : ptr(nullptr) {}\n\n\nbasic_map::basic_map(__isl_take isl_basic_map *ptr)\n    : ptr(ptr) {}\n\nbasic_map::basic_map(ctx ctx, const std::string &str)\n{\n  auto res = isl_basic_map_read_from_str(ctx.release(), str.c_str());\n  ptr = res;\n}\n\nbasic_map &basic_map::operator=(basic_map obj) {\n  std::swap(this->ptr, obj.ptr);\n  return *this;\n}\n\nbasic_map::~basic_map() {\n  if (ptr)\n    isl_basic_map_free(ptr);\n}\n\n__isl_give isl_basic_map *basic_map::copy() const & {\n  return isl_basic_map_copy(ptr);\n}\n\n__isl_keep isl_basic_map *basic_map::get() const {\n  return ptr;\n}\n\n__isl_give isl_basic_map *basic_map::release() {\n  isl_basic_map *tmp = ptr;\n  ptr = nullptr;\n  return tmp;\n}\n\nbool basic_map::is_null() const {\n  return ptr == nullptr;\n}\nbasic_map::operator bool() const {\n  return !is_null();\n}\n\n\nctx basic_map::get_ctx() const {\n  return ctx(isl_basic_map_get_ctx(ptr));\n}\nstd::string basic_map::to_str() const {\n  char *Tmp = isl_basic_map_to_str(get());\n  if (!Tmp)\n    return \"\";\n  std::string S(Tmp);\n  free(Tmp);\n  return S;\n}\n\n\nvoid basic_map::dump() const {\n  isl_basic_map_dump(get());\n}\n\n\nbasic_map basic_map::add_constraint(constraint constraint) const\n{\n  auto res = isl_basic_map_add_constraint(copy(), constraint.release());\n  return manage(res);\n}\n\nbasic_map basic_map::add_dims(isl::dim type, unsigned int n) const\n{\n  auto res = isl_basic_map_add_dims(copy(), static_cast<enum isl_dim_type>(type), n);\n  return manage(res);\n}\n\nbasic_map basic_map::affine_hull() const\n{\n  auto res = isl_basic_map_affine_hull(copy());\n  return manage(res);\n}\n\nbasic_map basic_map::align_params(space model) const\n{\n  auto res = isl_basic_map_align_params(copy(), model.release());\n  return manage(res);\n}\n\nbasic_map basic_map::apply_domain(basic_map bmap2) const\n{\n  auto res = isl_basic_map_apply_domain(copy(), bmap2.release());\n  return manage(res);\n}\n\nbasic_map basic_map::apply_range(basic_map bmap2) const\n{\n  auto res = isl_basic_map_apply_range(copy(), bmap2.release());\n  return manage(res);\n}\n\nboolean basic_map::can_curry() const\n{\n  auto res = isl_basic_map_can_curry(get());\n  return manage(res);\n}\n\nboolean basic_map::can_uncurry() const\n{\n  auto res = isl_basic_map_can_uncurry(get());\n  return manage(res);\n}\n\nboolean basic_map::can_zip() const\n{\n  auto res = isl_basic_map_can_zip(get());\n  return manage(res);\n}\n\nbasic_map basic_map::curry() const\n{\n  auto res = isl_basic_map_curry(copy());\n  return manage(res);\n}\n\nbasic_set basic_map::deltas() const\n{\n  auto res = isl_basic_map_deltas(copy());\n  return manage(res);\n}\n\nbasic_map basic_map::deltas_map() const\n{\n  auto res = isl_basic_map_deltas_map(copy());\n  return manage(res);\n}\n\nbasic_map basic_map::detect_equalities() const\n{\n  auto res = isl_basic_map_detect_equalities(copy());\n  return manage(res);\n}\n\nisl_size basic_map::dim(isl::dim type) const\n{\n  auto res = isl_basic_map_dim(get(), static_cast<enum isl_dim_type>(type));\n  return res;\n}\n\nbasic_set basic_map::domain() const\n{\n  auto res = isl_basic_map_domain(copy());\n  return manage(res);\n}\n\nbasic_map basic_map::domain_map() const\n{\n  auto res = isl_basic_map_domain_map(copy());\n  return manage(res);\n}\n\nbasic_map basic_map::domain_product(basic_map bmap2) const\n{\n  auto res = isl_basic_map_domain_product(copy(), bmap2.release());\n  return manage(res);\n}\n\nbasic_map basic_map::drop_constraints_involving_dims(isl::dim type, unsigned int first, unsigned int n) const\n{\n  auto res = isl_basic_map_drop_constraints_involving_dims(copy(), static_cast<enum isl_dim_type>(type), first, n);\n  return manage(res);\n}\n\nbasic_map basic_map::drop_constraints_not_involving_dims(isl::dim type, unsigned int first, unsigned int n) const\n{\n  auto res = isl_basic_map_drop_constraints_not_involving_dims(copy(), static_cast<enum isl_dim_type>(type), first, n);\n  return manage(res);\n}\n\nbasic_map basic_map::drop_unused_params() const\n{\n  auto res = isl_basic_map_drop_unused_params(copy());\n  return manage(res);\n}\n\nbasic_map basic_map::eliminate(isl::dim type, unsigned int first, unsigned int n) const\n{\n  auto res = isl_basic_map_eliminate(copy(), static_cast<enum isl_dim_type>(type), first, n);\n  return manage(res);\n}\n\nbasic_map basic_map::empty(space space)\n{\n  auto res = isl_basic_map_empty(space.release());\n  return manage(res);\n}\n\nbasic_map basic_map::equal(space space, unsigned int n_equal)\n{\n  auto res = isl_basic_map_equal(space.release(), n_equal);\n  return manage(res);\n}\n\nmat basic_map::equalities_matrix(isl::dim c1, isl::dim c2, isl::dim c3, isl::dim c4, isl::dim c5) const\n{\n  auto res = isl_basic_map_equalities_matrix(get(), static_cast<enum isl_dim_type>(c1), static_cast<enum isl_dim_type>(c2), static_cast<enum isl_dim_type>(c3), static_cast<enum isl_dim_type>(c4), static_cast<enum isl_dim_type>(c5));\n  return manage(res);\n}\n\nbasic_map basic_map::equate(isl::dim type1, int pos1, isl::dim type2, int pos2) const\n{\n  auto res = isl_basic_map_equate(copy(), static_cast<enum isl_dim_type>(type1), pos1, static_cast<enum isl_dim_type>(type2), pos2);\n  return manage(res);\n}\n\nint basic_map::find_dim_by_name(isl::dim type, const std::string &name) const\n{\n  auto res = isl_basic_map_find_dim_by_name(get(), static_cast<enum isl_dim_type>(type), name.c_str());\n  return res;\n}\n\nbasic_map basic_map::fix_si(isl::dim type, unsigned int pos, int value) const\n{\n  auto res = isl_basic_map_fix_si(copy(), static_cast<enum isl_dim_type>(type), pos, value);\n  return manage(res);\n}\n\nbasic_map basic_map::fix_val(isl::dim type, unsigned int pos, val v) const\n{\n  auto res = isl_basic_map_fix_val(copy(), static_cast<enum isl_dim_type>(type), pos, v.release());\n  return manage(res);\n}\n\nbasic_map basic_map::flat_product(basic_map bmap2) const\n{\n  auto res = isl_basic_map_flat_product(copy(), bmap2.release());\n  return manage(res);\n}\n\nbasic_map basic_map::flat_range_product(basic_map bmap2) const\n{\n  auto res = isl_basic_map_flat_range_product(copy(), bmap2.release());\n  return manage(res);\n}\n\nbasic_map basic_map::flatten() const\n{\n  auto res = isl_basic_map_flatten(copy());\n  return manage(res);\n}\n\nbasic_map basic_map::flatten_domain() const\n{\n  auto res = isl_basic_map_flatten_domain(copy());\n  return manage(res);\n}\n\nbasic_map basic_map::flatten_range() const\n{\n  auto res = isl_basic_map_flatten_range(copy());\n  return manage(res);\n}\n\nstat basic_map::foreach_constraint(const std::function<stat(constraint)> &fn) const\n{\n  struct fn_data {\n    const std::function<stat(constraint)> *func;\n  } fn_data = { &fn };\n  auto fn_lambda = [](isl_constraint *arg_0, void *arg_1) -> isl_stat {\n    auto *data = static_cast<struct fn_data *>(arg_1);\n    stat ret = (*data->func)(manage(arg_0));\n    return ret.release();\n  };\n  auto res = isl_basic_map_foreach_constraint(get(), fn_lambda, &fn_data);\n  return manage(res);\n}\n\nbasic_map basic_map::from_aff(aff aff)\n{\n  auto res = isl_basic_map_from_aff(aff.release());\n  return manage(res);\n}\n\nbasic_map basic_map::from_aff_list(space domain_space, aff_list list)\n{\n  auto res = isl_basic_map_from_aff_list(domain_space.release(), list.release());\n  return manage(res);\n}\n\nbasic_map basic_map::from_constraint(constraint constraint)\n{\n  auto res = isl_basic_map_from_constraint(constraint.release());\n  return manage(res);\n}\n\nbasic_map basic_map::from_domain(basic_set bset)\n{\n  auto res = isl_basic_map_from_domain(bset.release());\n  return manage(res);\n}\n\nbasic_map basic_map::from_domain_and_range(basic_set domain, basic_set range)\n{\n  auto res = isl_basic_map_from_domain_and_range(domain.release(), range.release());\n  return manage(res);\n}\n\nbasic_map basic_map::from_multi_aff(multi_aff maff)\n{\n  auto res = isl_basic_map_from_multi_aff(maff.release());\n  return manage(res);\n}\n\nbasic_map basic_map::from_qpolynomial(qpolynomial qp)\n{\n  auto res = isl_basic_map_from_qpolynomial(qp.release());\n  return manage(res);\n}\n\nbasic_map basic_map::from_range(basic_set bset)\n{\n  auto res = isl_basic_map_from_range(bset.release());\n  return manage(res);\n}\n\nconstraint_list basic_map::get_constraint_list() const\n{\n  auto res = isl_basic_map_get_constraint_list(get());\n  return manage(res);\n}\n\nstd::string basic_map::get_dim_name(isl::dim type, unsigned int pos) const\n{\n  auto res = isl_basic_map_get_dim_name(get(), static_cast<enum isl_dim_type>(type), pos);\n  std::string tmp(res);\n  return tmp;\n}\n\naff basic_map::get_div(int pos) const\n{\n  auto res = isl_basic_map_get_div(get(), pos);\n  return manage(res);\n}\n\nlocal_space basic_map::get_local_space() const\n{\n  auto res = isl_basic_map_get_local_space(get());\n  return manage(res);\n}\n\nspace basic_map::get_space() const\n{\n  auto res = isl_basic_map_get_space(get());\n  return manage(res);\n}\n\nstd::string basic_map::get_tuple_name(isl::dim type) const\n{\n  auto res = isl_basic_map_get_tuple_name(get(), static_cast<enum isl_dim_type>(type));\n  std::string tmp(res);\n  return tmp;\n}\n\nbasic_map basic_map::gist(basic_map context) const\n{\n  auto res = isl_basic_map_gist(copy(), context.release());\n  return manage(res);\n}\n\nbasic_map basic_map::gist_domain(basic_set context) const\n{\n  auto res = isl_basic_map_gist_domain(copy(), context.release());\n  return manage(res);\n}\n\nboolean basic_map::has_dim_id(isl::dim type, unsigned int pos) const\n{\n  auto res = isl_basic_map_has_dim_id(get(), static_cast<enum isl_dim_type>(type), pos);\n  return manage(res);\n}\n\nbasic_map basic_map::identity(space space)\n{\n  auto res = isl_basic_map_identity(space.release());\n  return manage(res);\n}\n\nboolean basic_map::image_is_bounded() const\n{\n  auto res = isl_basic_map_image_is_bounded(get());\n  return manage(res);\n}\n\nmat basic_map::inequalities_matrix(isl::dim c1, isl::dim c2, isl::dim c3, isl::dim c4, isl::dim c5) const\n{\n  auto res = isl_basic_map_inequalities_matrix(get(), static_cast<enum isl_dim_type>(c1), static_cast<enum isl_dim_type>(c2), static_cast<enum isl_dim_type>(c3), static_cast<enum isl_dim_type>(c4), static_cast<enum isl_dim_type>(c5));\n  return manage(res);\n}\n\nbasic_map basic_map::insert_dims(isl::dim type, unsigned int pos, unsigned int n) const\n{\n  auto res = isl_basic_map_insert_dims(copy(), static_cast<enum isl_dim_type>(type), pos, n);\n  return manage(res);\n}\n\nbasic_map basic_map::intersect(basic_map bmap2) const\n{\n  auto res = isl_basic_map_intersect(copy(), bmap2.release());\n  return manage(res);\n}\n\nbasic_map basic_map::intersect_domain(basic_set bset) const\n{\n  auto res = isl_basic_map_intersect_domain(copy(), bset.release());\n  return manage(res);\n}\n\nbasic_map basic_map::intersect_range(basic_set bset) const\n{\n  auto res = isl_basic_map_intersect_range(copy(), bset.release());\n  return manage(res);\n}\n\nboolean basic_map::involves_dims(isl::dim type, unsigned int first, unsigned int n) const\n{\n  auto res = isl_basic_map_involves_dims(get(), static_cast<enum isl_dim_type>(type), first, n);\n  return manage(res);\n}\n\nboolean basic_map::is_disjoint(const basic_map &bmap2) const\n{\n  auto res = isl_basic_map_is_disjoint(get(), bmap2.get());\n  return manage(res);\n}\n\nboolean basic_map::is_empty() const\n{\n  auto res = isl_basic_map_is_empty(get());\n  return manage(res);\n}\n\nboolean basic_map::is_equal(const basic_map &bmap2) const\n{\n  auto res = isl_basic_map_is_equal(get(), bmap2.get());\n  return manage(res);\n}\n\nboolean basic_map::is_rational() const\n{\n  auto res = isl_basic_map_is_rational(get());\n  return manage(res);\n}\n\nboolean basic_map::is_single_valued() const\n{\n  auto res = isl_basic_map_is_single_valued(get());\n  return manage(res);\n}\n\nboolean basic_map::is_strict_subset(const basic_map &bmap2) const\n{\n  auto res = isl_basic_map_is_strict_subset(get(), bmap2.get());\n  return manage(res);\n}\n\nboolean basic_map::is_subset(const basic_map &bmap2) const\n{\n  auto res = isl_basic_map_is_subset(get(), bmap2.get());\n  return manage(res);\n}\n\nboolean basic_map::is_universe() const\n{\n  auto res = isl_basic_map_is_universe(get());\n  return manage(res);\n}\n\nbasic_map basic_map::less_at(space space, unsigned int pos)\n{\n  auto res = isl_basic_map_less_at(space.release(), pos);\n  return manage(res);\n}\n\nmap basic_map::lexmax() const\n{\n  auto res = isl_basic_map_lexmax(copy());\n  return manage(res);\n}\n\nmap basic_map::lexmin() const\n{\n  auto res = isl_basic_map_lexmin(copy());\n  return manage(res);\n}\n\npw_multi_aff basic_map::lexmin_pw_multi_aff() const\n{\n  auto res = isl_basic_map_lexmin_pw_multi_aff(copy());\n  return manage(res);\n}\n\nbasic_map basic_map::lower_bound_si(isl::dim type, unsigned int pos, int value) const\n{\n  auto res = isl_basic_map_lower_bound_si(copy(), static_cast<enum isl_dim_type>(type), pos, value);\n  return manage(res);\n}\n\nbasic_map basic_map::more_at(space space, unsigned int pos)\n{\n  auto res = isl_basic_map_more_at(space.release(), pos);\n  return manage(res);\n}\n\nbasic_map basic_map::move_dims(isl::dim dst_type, unsigned int dst_pos, isl::dim src_type, unsigned int src_pos, unsigned int n) const\n{\n  auto res = isl_basic_map_move_dims(copy(), static_cast<enum isl_dim_type>(dst_type), dst_pos, static_cast<enum isl_dim_type>(src_type), src_pos, n);\n  return manage(res);\n}\n\nisl_size basic_map::n_constraint() const\n{\n  auto res = isl_basic_map_n_constraint(get());\n  return res;\n}\n\nbasic_map basic_map::nat_universe(space space)\n{\n  auto res = isl_basic_map_nat_universe(space.release());\n  return manage(res);\n}\n\nbasic_map basic_map::neg() const\n{\n  auto res = isl_basic_map_neg(copy());\n  return manage(res);\n}\n\nbasic_map basic_map::order_ge(isl::dim type1, int pos1, isl::dim type2, int pos2) const\n{\n  auto res = isl_basic_map_order_ge(copy(), static_cast<enum isl_dim_type>(type1), pos1, static_cast<enum isl_dim_type>(type2), pos2);\n  return manage(res);\n}\n\nbasic_map basic_map::order_gt(isl::dim type1, int pos1, isl::dim type2, int pos2) const\n{\n  auto res = isl_basic_map_order_gt(copy(), static_cast<enum isl_dim_type>(type1), pos1, static_cast<enum isl_dim_type>(type2), pos2);\n  return manage(res);\n}\n\nval basic_map::plain_get_val_if_fixed(isl::dim type, unsigned int pos) const\n{\n  auto res = isl_basic_map_plain_get_val_if_fixed(get(), static_cast<enum isl_dim_type>(type), pos);\n  return manage(res);\n}\n\nboolean basic_map::plain_is_empty() const\n{\n  auto res = isl_basic_map_plain_is_empty(get());\n  return manage(res);\n}\n\nboolean basic_map::plain_is_universe() const\n{\n  auto res = isl_basic_map_plain_is_universe(get());\n  return manage(res);\n}\n\nbasic_map basic_map::preimage_domain_multi_aff(multi_aff ma) const\n{\n  auto res = isl_basic_map_preimage_domain_multi_aff(copy(), ma.release());\n  return manage(res);\n}\n\nbasic_map basic_map::preimage_range_multi_aff(multi_aff ma) const\n{\n  auto res = isl_basic_map_preimage_range_multi_aff(copy(), ma.release());\n  return manage(res);\n}\n\nbasic_map basic_map::product(basic_map bmap2) const\n{\n  auto res = isl_basic_map_product(copy(), bmap2.release());\n  return manage(res);\n}\n\nbasic_map basic_map::project_out(isl::dim type, unsigned int first, unsigned int n) const\n{\n  auto res = isl_basic_map_project_out(copy(), static_cast<enum isl_dim_type>(type), first, n);\n  return manage(res);\n}\n\nbasic_set basic_map::range() const\n{\n  auto res = isl_basic_map_range(copy());\n  return manage(res);\n}\n\nbasic_map basic_map::range_map() const\n{\n  auto res = isl_basic_map_range_map(copy());\n  return manage(res);\n}\n\nbasic_map basic_map::range_product(basic_map bmap2) const\n{\n  auto res = isl_basic_map_range_product(copy(), bmap2.release());\n  return manage(res);\n}\n\nbasic_map basic_map::remove_dims(isl::dim type, unsigned int first, unsigned int n) const\n{\n  auto res = isl_basic_map_remove_dims(copy(), static_cast<enum isl_dim_type>(type), first, n);\n  return manage(res);\n}\n\nbasic_map basic_map::remove_divs() const\n{\n  auto res = isl_basic_map_remove_divs(copy());\n  return manage(res);\n}\n\nbasic_map basic_map::remove_divs_involving_dims(isl::dim type, unsigned int first, unsigned int n) const\n{\n  auto res = isl_basic_map_remove_divs_involving_dims(copy(), static_cast<enum isl_dim_type>(type), first, n);\n  return manage(res);\n}\n\nbasic_map basic_map::remove_redundancies() const\n{\n  auto res = isl_basic_map_remove_redundancies(copy());\n  return manage(res);\n}\n\nbasic_map basic_map::reverse() const\n{\n  auto res = isl_basic_map_reverse(copy());\n  return manage(res);\n}\n\nbasic_map basic_map::sample() const\n{\n  auto res = isl_basic_map_sample(copy());\n  return manage(res);\n}\n\nbasic_map basic_map::set_tuple_id(isl::dim type, id id) const\n{\n  auto res = isl_basic_map_set_tuple_id(copy(), static_cast<enum isl_dim_type>(type), id.release());\n  return manage(res);\n}\n\nbasic_map basic_map::set_tuple_name(isl::dim type, const std::string &s) const\n{\n  auto res = isl_basic_map_set_tuple_name(copy(), static_cast<enum isl_dim_type>(type), s.c_str());\n  return manage(res);\n}\n\nbasic_map basic_map::sum(basic_map bmap2) const\n{\n  auto res = isl_basic_map_sum(copy(), bmap2.release());\n  return manage(res);\n}\n\nbasic_map basic_map::uncurry() const\n{\n  auto res = isl_basic_map_uncurry(copy());\n  return manage(res);\n}\n\nmap basic_map::unite(basic_map bmap2) const\n{\n  auto res = isl_basic_map_union(copy(), bmap2.release());\n  return manage(res);\n}\n\nbasic_map basic_map::universe(space space)\n{\n  auto res = isl_basic_map_universe(space.release());\n  return manage(res);\n}\n\nbasic_map basic_map::upper_bound_si(isl::dim type, unsigned int pos, int value) const\n{\n  auto res = isl_basic_map_upper_bound_si(copy(), static_cast<enum isl_dim_type>(type), pos, value);\n  return manage(res);\n}\n\nbasic_set basic_map::wrap() const\n{\n  auto res = isl_basic_map_wrap(copy());\n  return manage(res);\n}\n\nbasic_map basic_map::zip() const\n{\n  auto res = isl_basic_map_zip(copy());\n  return manage(res);\n}\n\n// implementations for isl::basic_map_list\nbasic_map_list manage(__isl_take isl_basic_map_list *ptr) {\n  return basic_map_list(ptr);\n}\nbasic_map_list manage_copy(__isl_keep isl_basic_map_list *ptr) {\n  ptr = isl_basic_map_list_copy(ptr);\n  return basic_map_list(ptr);\n}\n\nbasic_map_list::basic_map_list()\n    : ptr(nullptr) {}\n\nbasic_map_list::basic_map_list(const basic_map_list &obj)\n    : ptr(nullptr)\n{\n  ptr = obj.copy();\n}\nbasic_map_list::basic_map_list(std::nullptr_t)\n    : ptr(nullptr) {}\n\n\nbasic_map_list::basic_map_list(__isl_take isl_basic_map_list *ptr)\n    : ptr(ptr) {}\n\n\nbasic_map_list &basic_map_list::operator=(basic_map_list obj) {\n  std::swap(this->ptr, obj.ptr);\n  return *this;\n}\n\nbasic_map_list::~basic_map_list() {\n  if (ptr)\n    isl_basic_map_list_free(ptr);\n}\n\n__isl_give isl_basic_map_list *basic_map_list::copy() const & {\n  return isl_basic_map_list_copy(ptr);\n}\n\n__isl_keep isl_basic_map_list *basic_map_list::get() const {\n  return ptr;\n}\n\n__isl_give isl_basic_map_list *basic_map_list::release() {\n  isl_basic_map_list *tmp = ptr;\n  ptr = nullptr;\n  return tmp;\n}\n\nbool basic_map_list::is_null() const {\n  return ptr == nullptr;\n}\nbasic_map_list::operator bool() const {\n  return !is_null();\n}\n\n\nctx basic_map_list::get_ctx() const {\n  return ctx(isl_basic_map_list_get_ctx(ptr));\n}\nstd::string basic_map_list::to_str() const {\n  char *Tmp = isl_basic_map_list_to_str(get());\n  if (!Tmp)\n    return \"\";\n  std::string S(Tmp);\n  free(Tmp);\n  return S;\n}\n\n\nvoid basic_map_list::dump() const {\n  isl_basic_map_list_dump(get());\n}\n\n\nbasic_map_list basic_map_list::add(basic_map el) const\n{\n  auto res = isl_basic_map_list_add(copy(), el.release());\n  return manage(res);\n}\n\nbasic_map_list basic_map_list::alloc(ctx ctx, int n)\n{\n  auto res = isl_basic_map_list_alloc(ctx.release(), n);\n  return manage(res);\n}\n\nbasic_map_list basic_map_list::clear() const\n{\n  auto res = isl_basic_map_list_clear(copy());\n  return manage(res);\n}\n\nbasic_map_list basic_map_list::concat(basic_map_list list2) const\n{\n  auto res = isl_basic_map_list_concat(copy(), list2.release());\n  return manage(res);\n}\n\nbasic_map_list basic_map_list::drop(unsigned int first, unsigned int n) const\n{\n  auto res = isl_basic_map_list_drop(copy(), first, n);\n  return manage(res);\n}\n\nstat basic_map_list::foreach(const std::function<stat(basic_map)> &fn) const\n{\n  struct fn_data {\n    const std::function<stat(basic_map)> *func;\n  } fn_data = { &fn };\n  auto fn_lambda = [](isl_basic_map *arg_0, void *arg_1) -> isl_stat {\n    auto *data = static_cast<struct fn_data *>(arg_1);\n    stat ret = (*data->func)(manage(arg_0));\n    return ret.release();\n  };\n  auto res = isl_basic_map_list_foreach(get(), fn_lambda, &fn_data);\n  return manage(res);\n}\n\nbasic_map_list basic_map_list::from_basic_map(basic_map el)\n{\n  auto res = isl_basic_map_list_from_basic_map(el.release());\n  return manage(res);\n}\n\nbasic_map basic_map_list::get_at(int index) const\n{\n  auto res = isl_basic_map_list_get_at(get(), index);\n  return manage(res);\n}\n\nbasic_map basic_map_list::get_basic_map(int index) const\n{\n  auto res = isl_basic_map_list_get_basic_map(get(), index);\n  return manage(res);\n}\n\nbasic_map_list basic_map_list::insert(unsigned int pos, basic_map el) const\n{\n  auto res = isl_basic_map_list_insert(copy(), pos, el.release());\n  return manage(res);\n}\n\nisl_size basic_map_list::n_basic_map() const\n{\n  auto res = isl_basic_map_list_n_basic_map(get());\n  return res;\n}\n\nbasic_map_list basic_map_list::reverse() const\n{\n  auto res = isl_basic_map_list_reverse(copy());\n  return manage(res);\n}\n\nbasic_map_list basic_map_list::set_basic_map(int index, basic_map el) const\n{\n  auto res = isl_basic_map_list_set_basic_map(copy(), index, el.release());\n  return manage(res);\n}\n\nisl_size basic_map_list::size() const\n{\n  auto res = isl_basic_map_list_size(get());\n  return res;\n}\n\nbasic_map_list basic_map_list::swap(unsigned int pos1, unsigned int pos2) const\n{\n  auto res = isl_basic_map_list_swap(copy(), pos1, pos2);\n  return manage(res);\n}\n\n// implementations for isl::basic_set\nbasic_set manage(__isl_take isl_basic_set *ptr) {\n  return basic_set(ptr);\n}\nbasic_set manage_copy(__isl_keep isl_basic_set *ptr) {\n  ptr = isl_basic_set_copy(ptr);\n  return basic_set(ptr);\n}\n\nbasic_set::basic_set()\n    : ptr(nullptr) {}\n\nbasic_set::basic_set(const basic_set &obj)\n    : ptr(nullptr)\n{\n  ptr = obj.copy();\n}\nbasic_set::basic_set(std::nullptr_t)\n    : ptr(nullptr) {}\n\n\nbasic_set::basic_set(__isl_take isl_basic_set *ptr)\n    : ptr(ptr) {}\n\nbasic_set::basic_set(point pnt)\n{\n  auto res = isl_basic_set_from_point(pnt.release());\n  ptr = res;\n}\nbasic_set::basic_set(ctx ctx, const std::string &str)\n{\n  auto res = isl_basic_set_read_from_str(ctx.release(), str.c_str());\n  ptr = res;\n}\n\nbasic_set &basic_set::operator=(basic_set obj) {\n  std::swap(this->ptr, obj.ptr);\n  return *this;\n}\n\nbasic_set::~basic_set() {\n  if (ptr)\n    isl_basic_set_free(ptr);\n}\n\n__isl_give isl_basic_set *basic_set::copy() const & {\n  return isl_basic_set_copy(ptr);\n}\n\n__isl_keep isl_basic_set *basic_set::get() const {\n  return ptr;\n}\n\n__isl_give isl_basic_set *basic_set::release() {\n  isl_basic_set *tmp = ptr;\n  ptr = nullptr;\n  return tmp;\n}\n\nbool basic_set::is_null() const {\n  return ptr == nullptr;\n}\nbasic_set::operator bool() const {\n  return !is_null();\n}\n\n\nctx basic_set::get_ctx() const {\n  return ctx(isl_basic_set_get_ctx(ptr));\n}\nstd::string basic_set::to_str() const {\n  char *Tmp = isl_basic_set_to_str(get());\n  if (!Tmp)\n    return \"\";\n  std::string S(Tmp);\n  free(Tmp);\n  return S;\n}\n\n\nvoid basic_set::dump() const {\n  isl_basic_set_dump(get());\n}\n\n\nbasic_set basic_set::affine_hull() const\n{\n  auto res = isl_basic_set_affine_hull(copy());\n  return manage(res);\n}\n\nbasic_set basic_set::align_params(space model) const\n{\n  auto res = isl_basic_set_align_params(copy(), model.release());\n  return manage(res);\n}\n\nbasic_set basic_set::apply(basic_map bmap) const\n{\n  auto res = isl_basic_set_apply(copy(), bmap.release());\n  return manage(res);\n}\n\nbasic_set basic_set::box_from_points(point pnt1, point pnt2)\n{\n  auto res = isl_basic_set_box_from_points(pnt1.release(), pnt2.release());\n  return manage(res);\n}\n\nbasic_set basic_set::coefficients() const\n{\n  auto res = isl_basic_set_coefficients(copy());\n  return manage(res);\n}\n\nbasic_set basic_set::detect_equalities() const\n{\n  auto res = isl_basic_set_detect_equalities(copy());\n  return manage(res);\n}\n\nisl_size basic_set::dim(isl::dim type) const\n{\n  auto res = isl_basic_set_dim(get(), static_cast<enum isl_dim_type>(type));\n  return res;\n}\n\nval basic_set::dim_max_val(int pos) const\n{\n  auto res = isl_basic_set_dim_max_val(copy(), pos);\n  return manage(res);\n}\n\nbasic_set basic_set::drop_constraints_involving_dims(isl::dim type, unsigned int first, unsigned int n) const\n{\n  auto res = isl_basic_set_drop_constraints_involving_dims(copy(), static_cast<enum isl_dim_type>(type), first, n);\n  return manage(res);\n}\n\nbasic_set basic_set::drop_constraints_not_involving_dims(isl::dim type, unsigned int first, unsigned int n) const\n{\n  auto res = isl_basic_set_drop_constraints_not_involving_dims(copy(), static_cast<enum isl_dim_type>(type), first, n);\n  return manage(res);\n}\n\nbasic_set basic_set::drop_unused_params() const\n{\n  auto res = isl_basic_set_drop_unused_params(copy());\n  return manage(res);\n}\n\nbasic_set basic_set::eliminate(isl::dim type, unsigned int first, unsigned int n) const\n{\n  auto res = isl_basic_set_eliminate(copy(), static_cast<enum isl_dim_type>(type), first, n);\n  return manage(res);\n}\n\nbasic_set basic_set::empty(space space)\n{\n  auto res = isl_basic_set_empty(space.release());\n  return manage(res);\n}\n\nmat basic_set::equalities_matrix(isl::dim c1, isl::dim c2, isl::dim c3, isl::dim c4) const\n{\n  auto res = isl_basic_set_equalities_matrix(get(), static_cast<enum isl_dim_type>(c1), static_cast<enum isl_dim_type>(c2), static_cast<enum isl_dim_type>(c3), static_cast<enum isl_dim_type>(c4));\n  return manage(res);\n}\n\nbasic_set basic_set::fix_si(isl::dim type, unsigned int pos, int value) const\n{\n  auto res = isl_basic_set_fix_si(copy(), static_cast<enum isl_dim_type>(type), pos, value);\n  return manage(res);\n}\n\nbasic_set basic_set::fix_val(isl::dim type, unsigned int pos, val v) const\n{\n  auto res = isl_basic_set_fix_val(copy(), static_cast<enum isl_dim_type>(type), pos, v.release());\n  return manage(res);\n}\n\nbasic_set basic_set::flat_product(basic_set bset2) const\n{\n  auto res = isl_basic_set_flat_product(copy(), bset2.release());\n  return manage(res);\n}\n\nbasic_set basic_set::flatten() const\n{\n  auto res = isl_basic_set_flatten(copy());\n  return manage(res);\n}\n\nstat basic_set::foreach_bound_pair(isl::dim type, unsigned int pos, const std::function<stat(constraint, constraint, basic_set)> &fn) const\n{\n  struct fn_data {\n    const std::function<stat(constraint, constraint, basic_set)> *func;\n  } fn_data = { &fn };\n  auto fn_lambda = [](isl_constraint *arg_0, isl_constraint *arg_1, isl_basic_set *arg_2, void *arg_3) -> isl_stat {\n    auto *data = static_cast<struct fn_data *>(arg_3);\n    stat ret = (*data->func)(manage(arg_0), manage(arg_1), manage(arg_2));\n    return ret.release();\n  };\n  auto res = isl_basic_set_foreach_bound_pair(get(), static_cast<enum isl_dim_type>(type), pos, fn_lambda, &fn_data);\n  return manage(res);\n}\n\nstat basic_set::foreach_constraint(const std::function<stat(constraint)> &fn) const\n{\n  struct fn_data {\n    const std::function<stat(constraint)> *func;\n  } fn_data = { &fn };\n  auto fn_lambda = [](isl_constraint *arg_0, void *arg_1) -> isl_stat {\n    auto *data = static_cast<struct fn_data *>(arg_1);\n    stat ret = (*data->func)(manage(arg_0));\n    return ret.release();\n  };\n  auto res = isl_basic_set_foreach_constraint(get(), fn_lambda, &fn_data);\n  return manage(res);\n}\n\nbasic_set basic_set::from_constraint(constraint constraint)\n{\n  auto res = isl_basic_set_from_constraint(constraint.release());\n  return manage(res);\n}\n\nbasic_set basic_set::from_multi_aff(multi_aff ma)\n{\n  auto res = isl_basic_set_from_multi_aff(ma.release());\n  return manage(res);\n}\n\nbasic_set basic_set::from_params() const\n{\n  auto res = isl_basic_set_from_params(copy());\n  return manage(res);\n}\n\nconstraint_list basic_set::get_constraint_list() const\n{\n  auto res = isl_basic_set_get_constraint_list(get());\n  return manage(res);\n}\n\nid basic_set::get_dim_id(isl::dim type, unsigned int pos) const\n{\n  auto res = isl_basic_set_get_dim_id(get(), static_cast<enum isl_dim_type>(type), pos);\n  return manage(res);\n}\n\nstd::string basic_set::get_dim_name(isl::dim type, unsigned int pos) const\n{\n  auto res = isl_basic_set_get_dim_name(get(), static_cast<enum isl_dim_type>(type), pos);\n  std::string tmp(res);\n  return tmp;\n}\n\naff basic_set::get_div(int pos) const\n{\n  auto res = isl_basic_set_get_div(get(), pos);\n  return manage(res);\n}\n\nlocal_space basic_set::get_local_space() const\n{\n  auto res = isl_basic_set_get_local_space(get());\n  return manage(res);\n}\n\nspace basic_set::get_space() const\n{\n  auto res = isl_basic_set_get_space(get());\n  return manage(res);\n}\n\nstd::string basic_set::get_tuple_name() const\n{\n  auto res = isl_basic_set_get_tuple_name(get());\n  std::string tmp(res);\n  return tmp;\n}\n\nbasic_set basic_set::gist(basic_set context) const\n{\n  auto res = isl_basic_set_gist(copy(), context.release());\n  return manage(res);\n}\n\nmat basic_set::inequalities_matrix(isl::dim c1, isl::dim c2, isl::dim c3, isl::dim c4) const\n{\n  auto res = isl_basic_set_inequalities_matrix(get(), static_cast<enum isl_dim_type>(c1), static_cast<enum isl_dim_type>(c2), static_cast<enum isl_dim_type>(c3), static_cast<enum isl_dim_type>(c4));\n  return manage(res);\n}\n\nbasic_set basic_set::insert_dims(isl::dim type, unsigned int pos, unsigned int n) const\n{\n  auto res = isl_basic_set_insert_dims(copy(), static_cast<enum isl_dim_type>(type), pos, n);\n  return manage(res);\n}\n\nbasic_set basic_set::intersect(basic_set bset2) const\n{\n  auto res = isl_basic_set_intersect(copy(), bset2.release());\n  return manage(res);\n}\n\nbasic_set basic_set::intersect_params(basic_set bset2) const\n{\n  auto res = isl_basic_set_intersect_params(copy(), bset2.release());\n  return manage(res);\n}\n\nboolean basic_set::involves_dims(isl::dim type, unsigned int first, unsigned int n) const\n{\n  auto res = isl_basic_set_involves_dims(get(), static_cast<enum isl_dim_type>(type), first, n);\n  return manage(res);\n}\n\nboolean basic_set::is_bounded() const\n{\n  auto res = isl_basic_set_is_bounded(get());\n  return manage(res);\n}\n\nboolean basic_set::is_disjoint(const basic_set &bset2) const\n{\n  auto res = isl_basic_set_is_disjoint(get(), bset2.get());\n  return manage(res);\n}\n\nboolean basic_set::is_empty() const\n{\n  auto res = isl_basic_set_is_empty(get());\n  return manage(res);\n}\n\nboolean basic_set::is_equal(const basic_set &bset2) const\n{\n  auto res = isl_basic_set_is_equal(get(), bset2.get());\n  return manage(res);\n}\n\nint basic_set::is_rational() const\n{\n  auto res = isl_basic_set_is_rational(get());\n  return res;\n}\n\nboolean basic_set::is_subset(const basic_set &bset2) const\n{\n  auto res = isl_basic_set_is_subset(get(), bset2.get());\n  return manage(res);\n}\n\nboolean basic_set::is_universe() const\n{\n  auto res = isl_basic_set_is_universe(get());\n  return manage(res);\n}\n\nboolean basic_set::is_wrapping() const\n{\n  auto res = isl_basic_set_is_wrapping(get());\n  return manage(res);\n}\n\nset basic_set::lexmax() const\n{\n  auto res = isl_basic_set_lexmax(copy());\n  return manage(res);\n}\n\nset basic_set::lexmin() const\n{\n  auto res = isl_basic_set_lexmin(copy());\n  return manage(res);\n}\n\nbasic_set basic_set::lower_bound_val(isl::dim type, unsigned int pos, val value) const\n{\n  auto res = isl_basic_set_lower_bound_val(copy(), static_cast<enum isl_dim_type>(type), pos, value.release());\n  return manage(res);\n}\n\nval basic_set::max_val(const aff &obj) const\n{\n  auto res = isl_basic_set_max_val(get(), obj.get());\n  return manage(res);\n}\n\nbasic_set basic_set::move_dims(isl::dim dst_type, unsigned int dst_pos, isl::dim src_type, unsigned int src_pos, unsigned int n) const\n{\n  auto res = isl_basic_set_move_dims(copy(), static_cast<enum isl_dim_type>(dst_type), dst_pos, static_cast<enum isl_dim_type>(src_type), src_pos, n);\n  return manage(res);\n}\n\nisl_size basic_set::n_constraint() const\n{\n  auto res = isl_basic_set_n_constraint(get());\n  return res;\n}\n\nisl_size basic_set::n_dim() const\n{\n  auto res = isl_basic_set_n_dim(get());\n  return res;\n}\n\nbasic_set basic_set::nat_universe(space space)\n{\n  auto res = isl_basic_set_nat_universe(space.release());\n  return manage(res);\n}\n\nbasic_set basic_set::neg() const\n{\n  auto res = isl_basic_set_neg(copy());\n  return manage(res);\n}\n\nbasic_set basic_set::params() const\n{\n  auto res = isl_basic_set_params(copy());\n  return manage(res);\n}\n\nboolean basic_set::plain_is_empty() const\n{\n  auto res = isl_basic_set_plain_is_empty(get());\n  return manage(res);\n}\n\nboolean basic_set::plain_is_equal(const basic_set &bset2) const\n{\n  auto res = isl_basic_set_plain_is_equal(get(), bset2.get());\n  return manage(res);\n}\n\nboolean basic_set::plain_is_universe() const\n{\n  auto res = isl_basic_set_plain_is_universe(get());\n  return manage(res);\n}\n\nbasic_set basic_set::positive_orthant(space space)\n{\n  auto res = isl_basic_set_positive_orthant(space.release());\n  return manage(res);\n}\n\nbasic_set basic_set::preimage_multi_aff(multi_aff ma) const\n{\n  auto res = isl_basic_set_preimage_multi_aff(copy(), ma.release());\n  return manage(res);\n}\n\nbasic_set basic_set::project_out(isl::dim type, unsigned int first, unsigned int n) const\n{\n  auto res = isl_basic_set_project_out(copy(), static_cast<enum isl_dim_type>(type), first, n);\n  return manage(res);\n}\n\nmat basic_set::reduced_basis() const\n{\n  auto res = isl_basic_set_reduced_basis(get());\n  return manage(res);\n}\n\nbasic_set basic_set::remove_dims(isl::dim type, unsigned int first, unsigned int n) const\n{\n  auto res = isl_basic_set_remove_dims(copy(), static_cast<enum isl_dim_type>(type), first, n);\n  return manage(res);\n}\n\nbasic_set basic_set::remove_divs() const\n{\n  auto res = isl_basic_set_remove_divs(copy());\n  return manage(res);\n}\n\nbasic_set basic_set::remove_divs_involving_dims(isl::dim type, unsigned int first, unsigned int n) const\n{\n  auto res = isl_basic_set_remove_divs_involving_dims(copy(), static_cast<enum isl_dim_type>(type), first, n);\n  return manage(res);\n}\n\nbasic_set basic_set::remove_redundancies() const\n{\n  auto res = isl_basic_set_remove_redundancies(copy());\n  return manage(res);\n}\n\nbasic_set basic_set::remove_unknown_divs() const\n{\n  auto res = isl_basic_set_remove_unknown_divs(copy());\n  return manage(res);\n}\n\nbasic_set basic_set::sample() const\n{\n  auto res = isl_basic_set_sample(copy());\n  return manage(res);\n}\n\npoint basic_set::sample_point() const\n{\n  auto res = isl_basic_set_sample_point(copy());\n  return manage(res);\n}\n\nbasic_set basic_set::set_tuple_id(id id) const\n{\n  auto res = isl_basic_set_set_tuple_id(copy(), id.release());\n  return manage(res);\n}\n\nbasic_set basic_set::set_tuple_name(const std::string &s) const\n{\n  auto res = isl_basic_set_set_tuple_name(copy(), s.c_str());\n  return manage(res);\n}\n\nbasic_set basic_set::solutions() const\n{\n  auto res = isl_basic_set_solutions(copy());\n  return manage(res);\n}\n\nset basic_set::unite(basic_set bset2) const\n{\n  auto res = isl_basic_set_union(copy(), bset2.release());\n  return manage(res);\n}\n\nbasic_set basic_set::universe(space space)\n{\n  auto res = isl_basic_set_universe(space.release());\n  return manage(res);\n}\n\nbasic_map basic_set::unwrap() const\n{\n  auto res = isl_basic_set_unwrap(copy());\n  return manage(res);\n}\n\nbasic_set basic_set::upper_bound_val(isl::dim type, unsigned int pos, val value) const\n{\n  auto res = isl_basic_set_upper_bound_val(copy(), static_cast<enum isl_dim_type>(type), pos, value.release());\n  return manage(res);\n}\n\n// implementations for isl::basic_set_list\nbasic_set_list manage(__isl_take isl_basic_set_list *ptr) {\n  return basic_set_list(ptr);\n}\nbasic_set_list manage_copy(__isl_keep isl_basic_set_list *ptr) {\n  ptr = isl_basic_set_list_copy(ptr);\n  return basic_set_list(ptr);\n}\n\nbasic_set_list::basic_set_list()\n    : ptr(nullptr) {}\n\nbasic_set_list::basic_set_list(const basic_set_list &obj)\n    : ptr(nullptr)\n{\n  ptr = obj.copy();\n}\nbasic_set_list::basic_set_list(std::nullptr_t)\n    : ptr(nullptr) {}\n\n\nbasic_set_list::basic_set_list(__isl_take isl_basic_set_list *ptr)\n    : ptr(ptr) {}\n\n\nbasic_set_list &basic_set_list::operator=(basic_set_list obj) {\n  std::swap(this->ptr, obj.ptr);\n  return *this;\n}\n\nbasic_set_list::~basic_set_list() {\n  if (ptr)\n    isl_basic_set_list_free(ptr);\n}\n\n__isl_give isl_basic_set_list *basic_set_list::copy() const & {\n  return isl_basic_set_list_copy(ptr);\n}\n\n__isl_keep isl_basic_set_list *basic_set_list::get() const {\n  return ptr;\n}\n\n__isl_give isl_basic_set_list *basic_set_list::release() {\n  isl_basic_set_list *tmp = ptr;\n  ptr = nullptr;\n  return tmp;\n}\n\nbool basic_set_list::is_null() const {\n  return ptr == nullptr;\n}\nbasic_set_list::operator bool() const {\n  return !is_null();\n}\n\n\nctx basic_set_list::get_ctx() const {\n  return ctx(isl_basic_set_list_get_ctx(ptr));\n}\nstd::string basic_set_list::to_str() const {\n  char *Tmp = isl_basic_set_list_to_str(get());\n  if (!Tmp)\n    return \"\";\n  std::string S(Tmp);\n  free(Tmp);\n  return S;\n}\n\n\nvoid basic_set_list::dump() const {\n  isl_basic_set_list_dump(get());\n}\n\n\nbasic_set_list basic_set_list::add(basic_set el) const\n{\n  auto res = isl_basic_set_list_add(copy(), el.release());\n  return manage(res);\n}\n\nbasic_set_list basic_set_list::alloc(ctx ctx, int n)\n{\n  auto res = isl_basic_set_list_alloc(ctx.release(), n);\n  return manage(res);\n}\n\nbasic_set_list basic_set_list::clear() const\n{\n  auto res = isl_basic_set_list_clear(copy());\n  return manage(res);\n}\n\nbasic_set_list basic_set_list::coefficients() const\n{\n  auto res = isl_basic_set_list_coefficients(copy());\n  return manage(res);\n}\n\nbasic_set_list basic_set_list::concat(basic_set_list list2) const\n{\n  auto res = isl_basic_set_list_concat(copy(), list2.release());\n  return manage(res);\n}\n\nbasic_set_list basic_set_list::drop(unsigned int first, unsigned int n) const\n{\n  auto res = isl_basic_set_list_drop(copy(), first, n);\n  return manage(res);\n}\n\nstat basic_set_list::foreach(const std::function<stat(basic_set)> &fn) const\n{\n  struct fn_data {\n    const std::function<stat(basic_set)> *func;\n  } fn_data = { &fn };\n  auto fn_lambda = [](isl_basic_set *arg_0, void *arg_1) -> isl_stat {\n    auto *data = static_cast<struct fn_data *>(arg_1);\n    stat ret = (*data->func)(manage(arg_0));\n    return ret.release();\n  };\n  auto res = isl_basic_set_list_foreach(get(), fn_lambda, &fn_data);\n  return manage(res);\n}\n\nbasic_set_list basic_set_list::from_basic_set(basic_set el)\n{\n  auto res = isl_basic_set_list_from_basic_set(el.release());\n  return manage(res);\n}\n\nbasic_set basic_set_list::get_at(int index) const\n{\n  auto res = isl_basic_set_list_get_at(get(), index);\n  return manage(res);\n}\n\nbasic_set basic_set_list::get_basic_set(int index) const\n{\n  auto res = isl_basic_set_list_get_basic_set(get(), index);\n  return manage(res);\n}\n\nbasic_set_list basic_set_list::insert(unsigned int pos, basic_set el) const\n{\n  auto res = isl_basic_set_list_insert(copy(), pos, el.release());\n  return manage(res);\n}\n\nisl_size basic_set_list::n_basic_set() const\n{\n  auto res = isl_basic_set_list_n_basic_set(get());\n  return res;\n}\n\nbasic_set_list basic_set_list::reverse() const\n{\n  auto res = isl_basic_set_list_reverse(copy());\n  return manage(res);\n}\n\nbasic_set_list basic_set_list::set_basic_set(int index, basic_set el) const\n{\n  auto res = isl_basic_set_list_set_basic_set(copy(), index, el.release());\n  return manage(res);\n}\n\nisl_size basic_set_list::size() const\n{\n  auto res = isl_basic_set_list_size(get());\n  return res;\n}\n\nbasic_set_list basic_set_list::swap(unsigned int pos1, unsigned int pos2) const\n{\n  auto res = isl_basic_set_list_swap(copy(), pos1, pos2);\n  return manage(res);\n}\n\n// implementations for isl::constraint\nconstraint manage(__isl_take isl_constraint *ptr) {\n  return constraint(ptr);\n}\nconstraint manage_copy(__isl_keep isl_constraint *ptr) {\n  ptr = isl_constraint_copy(ptr);\n  return constraint(ptr);\n}\n\nconstraint::constraint()\n    : ptr(nullptr) {}\n\nconstraint::constraint(const constraint &obj)\n    : ptr(nullptr)\n{\n  ptr = obj.copy();\n}\nconstraint::constraint(std::nullptr_t)\n    : ptr(nullptr) {}\n\n\nconstraint::constraint(__isl_take isl_constraint *ptr)\n    : ptr(ptr) {}\n\n\nconstraint &constraint::operator=(constraint obj) {\n  std::swap(this->ptr, obj.ptr);\n  return *this;\n}\n\nconstraint::~constraint() {\n  if (ptr)\n    isl_constraint_free(ptr);\n}\n\n__isl_give isl_constraint *constraint::copy() const & {\n  return isl_constraint_copy(ptr);\n}\n\n__isl_keep isl_constraint *constraint::get() const {\n  return ptr;\n}\n\n__isl_give isl_constraint *constraint::release() {\n  isl_constraint *tmp = ptr;\n  ptr = nullptr;\n  return tmp;\n}\n\nbool constraint::is_null() const {\n  return ptr == nullptr;\n}\nconstraint::operator bool() const {\n  return !is_null();\n}\n\n\nctx constraint::get_ctx() const {\n  return ctx(isl_constraint_get_ctx(ptr));\n}\n\nvoid constraint::dump() const {\n  isl_constraint_dump(get());\n}\n\n\nconstraint constraint::alloc_equality(local_space ls)\n{\n  auto res = isl_constraint_alloc_equality(ls.release());\n  return manage(res);\n}\n\nconstraint constraint::alloc_inequality(local_space ls)\n{\n  auto res = isl_constraint_alloc_inequality(ls.release());\n  return manage(res);\n}\n\nint constraint::cmp_last_non_zero(const constraint &c2) const\n{\n  auto res = isl_constraint_cmp_last_non_zero(get(), c2.get());\n  return res;\n}\n\naff constraint::get_aff() const\n{\n  auto res = isl_constraint_get_aff(get());\n  return manage(res);\n}\n\naff constraint::get_bound(isl::dim type, int pos) const\n{\n  auto res = isl_constraint_get_bound(get(), static_cast<enum isl_dim_type>(type), pos);\n  return manage(res);\n}\n\nval constraint::get_coefficient_val(isl::dim type, int pos) const\n{\n  auto res = isl_constraint_get_coefficient_val(get(), static_cast<enum isl_dim_type>(type), pos);\n  return manage(res);\n}\n\nval constraint::get_constant_val() const\n{\n  auto res = isl_constraint_get_constant_val(get());\n  return manage(res);\n}\n\nstd::string constraint::get_dim_name(isl::dim type, unsigned int pos) const\n{\n  auto res = isl_constraint_get_dim_name(get(), static_cast<enum isl_dim_type>(type), pos);\n  std::string tmp(res);\n  return tmp;\n}\n\naff constraint::get_div(int pos) const\n{\n  auto res = isl_constraint_get_div(get(), pos);\n  return manage(res);\n}\n\nlocal_space constraint::get_local_space() const\n{\n  auto res = isl_constraint_get_local_space(get());\n  return manage(res);\n}\n\nspace constraint::get_space() const\n{\n  auto res = isl_constraint_get_space(get());\n  return manage(res);\n}\n\nboolean constraint::involves_dims(isl::dim type, unsigned int first, unsigned int n) const\n{\n  auto res = isl_constraint_involves_dims(get(), static_cast<enum isl_dim_type>(type), first, n);\n  return manage(res);\n}\n\nboolean constraint::is_div_constraint() const\n{\n  auto res = isl_constraint_is_div_constraint(get());\n  return manage(res);\n}\n\nboolean constraint::is_lower_bound(isl::dim type, unsigned int pos) const\n{\n  auto res = isl_constraint_is_lower_bound(get(), static_cast<enum isl_dim_type>(type), pos);\n  return manage(res);\n}\n\nboolean constraint::is_upper_bound(isl::dim type, unsigned int pos) const\n{\n  auto res = isl_constraint_is_upper_bound(get(), static_cast<enum isl_dim_type>(type), pos);\n  return manage(res);\n}\n\nint constraint::plain_cmp(const constraint &c2) const\n{\n  auto res = isl_constraint_plain_cmp(get(), c2.get());\n  return res;\n}\n\nconstraint constraint::set_coefficient_si(isl::dim type, int pos, int v) const\n{\n  auto res = isl_constraint_set_coefficient_si(copy(), static_cast<enum isl_dim_type>(type), pos, v);\n  return manage(res);\n}\n\nconstraint constraint::set_coefficient_val(isl::dim type, int pos, val v) const\n{\n  auto res = isl_constraint_set_coefficient_val(copy(), static_cast<enum isl_dim_type>(type), pos, v.release());\n  return manage(res);\n}\n\nconstraint constraint::set_constant_si(int v) const\n{\n  auto res = isl_constraint_set_constant_si(copy(), v);\n  return manage(res);\n}\n\nconstraint constraint::set_constant_val(val v) const\n{\n  auto res = isl_constraint_set_constant_val(copy(), v.release());\n  return manage(res);\n}\n\n// implementations for isl::constraint_list\nconstraint_list manage(__isl_take isl_constraint_list *ptr) {\n  return constraint_list(ptr);\n}\nconstraint_list manage_copy(__isl_keep isl_constraint_list *ptr) {\n  ptr = isl_constraint_list_copy(ptr);\n  return constraint_list(ptr);\n}\n\nconstraint_list::constraint_list()\n    : ptr(nullptr) {}\n\nconstraint_list::constraint_list(const constraint_list &obj)\n    : ptr(nullptr)\n{\n  ptr = obj.copy();\n}\nconstraint_list::constraint_list(std::nullptr_t)\n    : ptr(nullptr) {}\n\n\nconstraint_list::constraint_list(__isl_take isl_constraint_list *ptr)\n    : ptr(ptr) {}\n\n\nconstraint_list &constraint_list::operator=(constraint_list obj) {\n  std::swap(this->ptr, obj.ptr);\n  return *this;\n}\n\nconstraint_list::~constraint_list() {\n  if (ptr)\n    isl_constraint_list_free(ptr);\n}\n\n__isl_give isl_constraint_list *constraint_list::copy() const & {\n  return isl_constraint_list_copy(ptr);\n}\n\n__isl_keep isl_constraint_list *constraint_list::get() const {\n  return ptr;\n}\n\n__isl_give isl_constraint_list *constraint_list::release() {\n  isl_constraint_list *tmp = ptr;\n  ptr = nullptr;\n  return tmp;\n}\n\nbool constraint_list::is_null() const {\n  return ptr == nullptr;\n}\nconstraint_list::operator bool() const {\n  return !is_null();\n}\n\n\nctx constraint_list::get_ctx() const {\n  return ctx(isl_constraint_list_get_ctx(ptr));\n}\nstd::string constraint_list::to_str() const {\n  char *Tmp = isl_constraint_list_to_str(get());\n  if (!Tmp)\n    return \"\";\n  std::string S(Tmp);\n  free(Tmp);\n  return S;\n}\n\n\nvoid constraint_list::dump() const {\n  isl_constraint_list_dump(get());\n}\n\n\nconstraint_list constraint_list::add(constraint el) const\n{\n  auto res = isl_constraint_list_add(copy(), el.release());\n  return manage(res);\n}\n\nconstraint_list constraint_list::alloc(ctx ctx, int n)\n{\n  auto res = isl_constraint_list_alloc(ctx.release(), n);\n  return manage(res);\n}\n\nconstraint_list constraint_list::clear() const\n{\n  auto res = isl_constraint_list_clear(copy());\n  return manage(res);\n}\n\nconstraint_list constraint_list::concat(constraint_list list2) const\n{\n  auto res = isl_constraint_list_concat(copy(), list2.release());\n  return manage(res);\n}\n\nconstraint_list constraint_list::drop(unsigned int first, unsigned int n) const\n{\n  auto res = isl_constraint_list_drop(copy(), first, n);\n  return manage(res);\n}\n\nstat constraint_list::foreach(const std::function<stat(constraint)> &fn) const\n{\n  struct fn_data {\n    const std::function<stat(constraint)> *func;\n  } fn_data = { &fn };\n  auto fn_lambda = [](isl_constraint *arg_0, void *arg_1) -> isl_stat {\n    auto *data = static_cast<struct fn_data *>(arg_1);\n    stat ret = (*data->func)(manage(arg_0));\n    return ret.release();\n  };\n  auto res = isl_constraint_list_foreach(get(), fn_lambda, &fn_data);\n  return manage(res);\n}\n\nconstraint_list constraint_list::from_constraint(constraint el)\n{\n  auto res = isl_constraint_list_from_constraint(el.release());\n  return manage(res);\n}\n\nconstraint constraint_list::get_at(int index) const\n{\n  auto res = isl_constraint_list_get_at(get(), index);\n  return manage(res);\n}\n\nconstraint constraint_list::get_constraint(int index) const\n{\n  auto res = isl_constraint_list_get_constraint(get(), index);\n  return manage(res);\n}\n\nconstraint_list constraint_list::insert(unsigned int pos, constraint el) const\n{\n  auto res = isl_constraint_list_insert(copy(), pos, el.release());\n  return manage(res);\n}\n\nisl_size constraint_list::n_constraint() const\n{\n  auto res = isl_constraint_list_n_constraint(get());\n  return res;\n}\n\nconstraint_list constraint_list::reverse() const\n{\n  auto res = isl_constraint_list_reverse(copy());\n  return manage(res);\n}\n\nconstraint_list constraint_list::set_constraint(int index, constraint el) const\n{\n  auto res = isl_constraint_list_set_constraint(copy(), index, el.release());\n  return manage(res);\n}\n\nisl_size constraint_list::size() const\n{\n  auto res = isl_constraint_list_size(get());\n  return res;\n}\n\nconstraint_list constraint_list::swap(unsigned int pos1, unsigned int pos2) const\n{\n  auto res = isl_constraint_list_swap(copy(), pos1, pos2);\n  return manage(res);\n}\n\n// implementations for isl::fixed_box\nfixed_box manage(__isl_take isl_fixed_box *ptr) {\n  return fixed_box(ptr);\n}\nfixed_box manage_copy(__isl_keep isl_fixed_box *ptr) {\n  ptr = isl_fixed_box_copy(ptr);\n  return fixed_box(ptr);\n}\n\nfixed_box::fixed_box()\n    : ptr(nullptr) {}\n\nfixed_box::fixed_box(const fixed_box &obj)\n    : ptr(nullptr)\n{\n  ptr = obj.copy();\n}\nfixed_box::fixed_box(std::nullptr_t)\n    : ptr(nullptr) {}\n\n\nfixed_box::fixed_box(__isl_take isl_fixed_box *ptr)\n    : ptr(ptr) {}\n\n\nfixed_box &fixed_box::operator=(fixed_box obj) {\n  std::swap(this->ptr, obj.ptr);\n  return *this;\n}\n\nfixed_box::~fixed_box() {\n  if (ptr)\n    isl_fixed_box_free(ptr);\n}\n\n__isl_give isl_fixed_box *fixed_box::copy() const & {\n  return isl_fixed_box_copy(ptr);\n}\n\n__isl_keep isl_fixed_box *fixed_box::get() const {\n  return ptr;\n}\n\n__isl_give isl_fixed_box *fixed_box::release() {\n  isl_fixed_box *tmp = ptr;\n  ptr = nullptr;\n  return tmp;\n}\n\nbool fixed_box::is_null() const {\n  return ptr == nullptr;\n}\nfixed_box::operator bool() const {\n  return !is_null();\n}\n\n\nctx fixed_box::get_ctx() const {\n  return ctx(isl_fixed_box_get_ctx(ptr));\n}\nstd::string fixed_box::to_str() const {\n  char *Tmp = isl_fixed_box_to_str(get());\n  if (!Tmp)\n    return \"\";\n  std::string S(Tmp);\n  free(Tmp);\n  return S;\n}\n\n\nvoid fixed_box::dump() const {\n  isl_fixed_box_dump(get());\n}\n\n\nmulti_aff fixed_box::get_offset() const\n{\n  auto res = isl_fixed_box_get_offset(get());\n  return manage(res);\n}\n\nmulti_val fixed_box::get_size() const\n{\n  auto res = isl_fixed_box_get_size(get());\n  return manage(res);\n}\n\nspace fixed_box::get_space() const\n{\n  auto res = isl_fixed_box_get_space(get());\n  return manage(res);\n}\n\nboolean fixed_box::is_valid() const\n{\n  auto res = isl_fixed_box_is_valid(get());\n  return manage(res);\n}\n\n// implementations for isl::id\nid manage(__isl_take isl_id *ptr) {\n  return id(ptr);\n}\nid manage_copy(__isl_keep isl_id *ptr) {\n  ptr = isl_id_copy(ptr);\n  return id(ptr);\n}\n\nid::id()\n    : ptr(nullptr) {}\n\nid::id(const id &obj)\n    : ptr(nullptr)\n{\n  ptr = obj.copy();\n}\nid::id(std::nullptr_t)\n    : ptr(nullptr) {}\n\n\nid::id(__isl_take isl_id *ptr)\n    : ptr(ptr) {}\n\nid::id(ctx ctx, const std::string &str)\n{\n  auto res = isl_id_read_from_str(ctx.release(), str.c_str());\n  ptr = res;\n}\n\nid &id::operator=(id obj) {\n  std::swap(this->ptr, obj.ptr);\n  return *this;\n}\n\nid::~id() {\n  if (ptr)\n    isl_id_free(ptr);\n}\n\n__isl_give isl_id *id::copy() const & {\n  return isl_id_copy(ptr);\n}\n\n__isl_keep isl_id *id::get() const {\n  return ptr;\n}\n\n__isl_give isl_id *id::release() {\n  isl_id *tmp = ptr;\n  ptr = nullptr;\n  return tmp;\n}\n\nbool id::is_null() const {\n  return ptr == nullptr;\n}\nid::operator bool() const {\n  return !is_null();\n}\n\n\nctx id::get_ctx() const {\n  return ctx(isl_id_get_ctx(ptr));\n}\nstd::string id::to_str() const {\n  char *Tmp = isl_id_to_str(get());\n  if (!Tmp)\n    return \"\";\n  std::string S(Tmp);\n  free(Tmp);\n  return S;\n}\n\n\nvoid id::dump() const {\n  isl_id_dump(get());\n}\n\n\nid id::alloc(ctx ctx, const std::string &name, void * user)\n{\n  auto res = isl_id_alloc(ctx.release(), name.c_str(), user);\n  return manage(res);\n}\n\nuint32_t id::get_hash() const\n{\n  auto res = isl_id_get_hash(get());\n  return res;\n}\n\nstd::string id::get_name() const\n{\n  auto res = isl_id_get_name(get());\n  std::string tmp(res);\n  return tmp;\n}\n\nvoid * id::get_user() const\n{\n  auto res = isl_id_get_user(get());\n  return res;\n}\n\n// implementations for isl::id_list\nid_list manage(__isl_take isl_id_list *ptr) {\n  return id_list(ptr);\n}\nid_list manage_copy(__isl_keep isl_id_list *ptr) {\n  ptr = isl_id_list_copy(ptr);\n  return id_list(ptr);\n}\n\nid_list::id_list()\n    : ptr(nullptr) {}\n\nid_list::id_list(const id_list &obj)\n    : ptr(nullptr)\n{\n  ptr = obj.copy();\n}\nid_list::id_list(std::nullptr_t)\n    : ptr(nullptr) {}\n\n\nid_list::id_list(__isl_take isl_id_list *ptr)\n    : ptr(ptr) {}\n\n\nid_list &id_list::operator=(id_list obj) {\n  std::swap(this->ptr, obj.ptr);\n  return *this;\n}\n\nid_list::~id_list() {\n  if (ptr)\n    isl_id_list_free(ptr);\n}\n\n__isl_give isl_id_list *id_list::copy() const & {\n  return isl_id_list_copy(ptr);\n}\n\n__isl_keep isl_id_list *id_list::get() const {\n  return ptr;\n}\n\n__isl_give isl_id_list *id_list::release() {\n  isl_id_list *tmp = ptr;\n  ptr = nullptr;\n  return tmp;\n}\n\nbool id_list::is_null() const {\n  return ptr == nullptr;\n}\nid_list::operator bool() const {\n  return !is_null();\n}\n\n\nctx id_list::get_ctx() const {\n  return ctx(isl_id_list_get_ctx(ptr));\n}\nstd::string id_list::to_str() const {\n  char *Tmp = isl_id_list_to_str(get());\n  if (!Tmp)\n    return \"\";\n  std::string S(Tmp);\n  free(Tmp);\n  return S;\n}\n\n\nvoid id_list::dump() const {\n  isl_id_list_dump(get());\n}\n\n\nid_list id_list::add(id el) const\n{\n  auto res = isl_id_list_add(copy(), el.release());\n  return manage(res);\n}\n\nid_list id_list::alloc(ctx ctx, int n)\n{\n  auto res = isl_id_list_alloc(ctx.release(), n);\n  return manage(res);\n}\n\nid_list id_list::clear() const\n{\n  auto res = isl_id_list_clear(copy());\n  return manage(res);\n}\n\nid_list id_list::concat(id_list list2) const\n{\n  auto res = isl_id_list_concat(copy(), list2.release());\n  return manage(res);\n}\n\nid_list id_list::drop(unsigned int first, unsigned int n) const\n{\n  auto res = isl_id_list_drop(copy(), first, n);\n  return manage(res);\n}\n\nstat id_list::foreach(const std::function<stat(id)> &fn) const\n{\n  struct fn_data {\n    const std::function<stat(id)> *func;\n  } fn_data = { &fn };\n  auto fn_lambda = [](isl_id *arg_0, void *arg_1) -> isl_stat {\n    auto *data = static_cast<struct fn_data *>(arg_1);\n    stat ret = (*data->func)(manage(arg_0));\n    return ret.release();\n  };\n  auto res = isl_id_list_foreach(get(), fn_lambda, &fn_data);\n  return manage(res);\n}\n\nid_list id_list::from_id(id el)\n{\n  auto res = isl_id_list_from_id(el.release());\n  return manage(res);\n}\n\nid id_list::get_at(int index) const\n{\n  auto res = isl_id_list_get_at(get(), index);\n  return manage(res);\n}\n\nid id_list::get_id(int index) const\n{\n  auto res = isl_id_list_get_id(get(), index);\n  return manage(res);\n}\n\nid_list id_list::insert(unsigned int pos, id el) const\n{\n  auto res = isl_id_list_insert(copy(), pos, el.release());\n  return manage(res);\n}\n\nisl_size id_list::n_id() const\n{\n  auto res = isl_id_list_n_id(get());\n  return res;\n}\n\nid_list id_list::reverse() const\n{\n  auto res = isl_id_list_reverse(copy());\n  return manage(res);\n}\n\nid_list id_list::set_id(int index, id el) const\n{\n  auto res = isl_id_list_set_id(copy(), index, el.release());\n  return manage(res);\n}\n\nisl_size id_list::size() const\n{\n  auto res = isl_id_list_size(get());\n  return res;\n}\n\nid_list id_list::swap(unsigned int pos1, unsigned int pos2) const\n{\n  auto res = isl_id_list_swap(copy(), pos1, pos2);\n  return manage(res);\n}\n\n// implementations for isl::id_to_ast_expr\nid_to_ast_expr manage(__isl_take isl_id_to_ast_expr *ptr) {\n  return id_to_ast_expr(ptr);\n}\nid_to_ast_expr manage_copy(__isl_keep isl_id_to_ast_expr *ptr) {\n  ptr = isl_id_to_ast_expr_copy(ptr);\n  return id_to_ast_expr(ptr);\n}\n\nid_to_ast_expr::id_to_ast_expr()\n    : ptr(nullptr) {}\n\nid_to_ast_expr::id_to_ast_expr(const id_to_ast_expr &obj)\n    : ptr(nullptr)\n{\n  ptr = obj.copy();\n}\nid_to_ast_expr::id_to_ast_expr(std::nullptr_t)\n    : ptr(nullptr) {}\n\n\nid_to_ast_expr::id_to_ast_expr(__isl_take isl_id_to_ast_expr *ptr)\n    : ptr(ptr) {}\n\n\nid_to_ast_expr &id_to_ast_expr::operator=(id_to_ast_expr obj) {\n  std::swap(this->ptr, obj.ptr);\n  return *this;\n}\n\nid_to_ast_expr::~id_to_ast_expr() {\n  if (ptr)\n    isl_id_to_ast_expr_free(ptr);\n}\n\n__isl_give isl_id_to_ast_expr *id_to_ast_expr::copy() const & {\n  return isl_id_to_ast_expr_copy(ptr);\n}\n\n__isl_keep isl_id_to_ast_expr *id_to_ast_expr::get() const {\n  return ptr;\n}\n\n__isl_give isl_id_to_ast_expr *id_to_ast_expr::release() {\n  isl_id_to_ast_expr *tmp = ptr;\n  ptr = nullptr;\n  return tmp;\n}\n\nbool id_to_ast_expr::is_null() const {\n  return ptr == nullptr;\n}\nid_to_ast_expr::operator bool() const {\n  return !is_null();\n}\n\n\nctx id_to_ast_expr::get_ctx() const {\n  return ctx(isl_id_to_ast_expr_get_ctx(ptr));\n}\n\nvoid id_to_ast_expr::dump() const {\n  isl_id_to_ast_expr_dump(get());\n}\n\n\nid_to_ast_expr id_to_ast_expr::alloc(ctx ctx, int min_size)\n{\n  auto res = isl_id_to_ast_expr_alloc(ctx.release(), min_size);\n  return manage(res);\n}\n\nid_to_ast_expr id_to_ast_expr::drop(id key) const\n{\n  auto res = isl_id_to_ast_expr_drop(copy(), key.release());\n  return manage(res);\n}\n\nstat id_to_ast_expr::foreach(const std::function<stat(id, ast_expr)> &fn) const\n{\n  struct fn_data {\n    const std::function<stat(id, ast_expr)> *func;\n  } fn_data = { &fn };\n  auto fn_lambda = [](isl_id *arg_0, isl_ast_expr *arg_1, void *arg_2) -> isl_stat {\n    auto *data = static_cast<struct fn_data *>(arg_2);\n    stat ret = (*data->func)(manage(arg_0), manage(arg_1));\n    return ret.release();\n  };\n  auto res = isl_id_to_ast_expr_foreach(get(), fn_lambda, &fn_data);\n  return manage(res);\n}\n\nast_expr id_to_ast_expr::get(id key) const\n{\n  auto res = isl_id_to_ast_expr_get(get(), key.release());\n  return manage(res);\n}\n\nboolean id_to_ast_expr::has(const id &key) const\n{\n  auto res = isl_id_to_ast_expr_has(get(), key.get());\n  return manage(res);\n}\n\nid_to_ast_expr id_to_ast_expr::set(id key, ast_expr val) const\n{\n  auto res = isl_id_to_ast_expr_set(copy(), key.release(), val.release());\n  return manage(res);\n}\n\n// implementations for isl::local_space\nlocal_space manage(__isl_take isl_local_space *ptr) {\n  return local_space(ptr);\n}\nlocal_space manage_copy(__isl_keep isl_local_space *ptr) {\n  ptr = isl_local_space_copy(ptr);\n  return local_space(ptr);\n}\n\nlocal_space::local_space()\n    : ptr(nullptr) {}\n\nlocal_space::local_space(const local_space &obj)\n    : ptr(nullptr)\n{\n  ptr = obj.copy();\n}\nlocal_space::local_space(std::nullptr_t)\n    : ptr(nullptr) {}\n\n\nlocal_space::local_space(__isl_take isl_local_space *ptr)\n    : ptr(ptr) {}\n\nlocal_space::local_space(space space)\n{\n  auto res = isl_local_space_from_space(space.release());\n  ptr = res;\n}\n\nlocal_space &local_space::operator=(local_space obj) {\n  std::swap(this->ptr, obj.ptr);\n  return *this;\n}\n\nlocal_space::~local_space() {\n  if (ptr)\n    isl_local_space_free(ptr);\n}\n\n__isl_give isl_local_space *local_space::copy() const & {\n  return isl_local_space_copy(ptr);\n}\n\n__isl_keep isl_local_space *local_space::get() const {\n  return ptr;\n}\n\n__isl_give isl_local_space *local_space::release() {\n  isl_local_space *tmp = ptr;\n  ptr = nullptr;\n  return tmp;\n}\n\nbool local_space::is_null() const {\n  return ptr == nullptr;\n}\nlocal_space::operator bool() const {\n  return !is_null();\n}\n\n\nctx local_space::get_ctx() const {\n  return ctx(isl_local_space_get_ctx(ptr));\n}\n\nvoid local_space::dump() const {\n  isl_local_space_dump(get());\n}\n\n\nlocal_space local_space::add_dims(isl::dim type, unsigned int n) const\n{\n  auto res = isl_local_space_add_dims(copy(), static_cast<enum isl_dim_type>(type), n);\n  return manage(res);\n}\n\nisl_size local_space::dim(isl::dim type) const\n{\n  auto res = isl_local_space_dim(get(), static_cast<enum isl_dim_type>(type));\n  return res;\n}\n\nlocal_space local_space::domain() const\n{\n  auto res = isl_local_space_domain(copy());\n  return manage(res);\n}\n\nlocal_space local_space::drop_dims(isl::dim type, unsigned int first, unsigned int n) const\n{\n  auto res = isl_local_space_drop_dims(copy(), static_cast<enum isl_dim_type>(type), first, n);\n  return manage(res);\n}\n\nint local_space::find_dim_by_name(isl::dim type, const std::string &name) const\n{\n  auto res = isl_local_space_find_dim_by_name(get(), static_cast<enum isl_dim_type>(type), name.c_str());\n  return res;\n}\n\nlocal_space local_space::flatten_domain() const\n{\n  auto res = isl_local_space_flatten_domain(copy());\n  return manage(res);\n}\n\nlocal_space local_space::flatten_range() const\n{\n  auto res = isl_local_space_flatten_range(copy());\n  return manage(res);\n}\n\nlocal_space local_space::from_domain() const\n{\n  auto res = isl_local_space_from_domain(copy());\n  return manage(res);\n}\n\nid local_space::get_dim_id(isl::dim type, unsigned int pos) const\n{\n  auto res = isl_local_space_get_dim_id(get(), static_cast<enum isl_dim_type>(type), pos);\n  return manage(res);\n}\n\nstd::string local_space::get_dim_name(isl::dim type, unsigned int pos) const\n{\n  auto res = isl_local_space_get_dim_name(get(), static_cast<enum isl_dim_type>(type), pos);\n  std::string tmp(res);\n  return tmp;\n}\n\naff local_space::get_div(int pos) const\n{\n  auto res = isl_local_space_get_div(get(), pos);\n  return manage(res);\n}\n\nspace local_space::get_space() const\n{\n  auto res = isl_local_space_get_space(get());\n  return manage(res);\n}\n\nboolean local_space::has_dim_id(isl::dim type, unsigned int pos) const\n{\n  auto res = isl_local_space_has_dim_id(get(), static_cast<enum isl_dim_type>(type), pos);\n  return manage(res);\n}\n\nboolean local_space::has_dim_name(isl::dim type, unsigned int pos) const\n{\n  auto res = isl_local_space_has_dim_name(get(), static_cast<enum isl_dim_type>(type), pos);\n  return manage(res);\n}\n\nlocal_space local_space::insert_dims(isl::dim type, unsigned int first, unsigned int n) const\n{\n  auto res = isl_local_space_insert_dims(copy(), static_cast<enum isl_dim_type>(type), first, n);\n  return manage(res);\n}\n\nlocal_space local_space::intersect(local_space ls2) const\n{\n  auto res = isl_local_space_intersect(copy(), ls2.release());\n  return manage(res);\n}\n\nboolean local_space::is_equal(const local_space &ls2) const\n{\n  auto res = isl_local_space_is_equal(get(), ls2.get());\n  return manage(res);\n}\n\nboolean local_space::is_params() const\n{\n  auto res = isl_local_space_is_params(get());\n  return manage(res);\n}\n\nboolean local_space::is_set() const\n{\n  auto res = isl_local_space_is_set(get());\n  return manage(res);\n}\n\nlocal_space local_space::range() const\n{\n  auto res = isl_local_space_range(copy());\n  return manage(res);\n}\n\nlocal_space local_space::set_dim_id(isl::dim type, unsigned int pos, id id) const\n{\n  auto res = isl_local_space_set_dim_id(copy(), static_cast<enum isl_dim_type>(type), pos, id.release());\n  return manage(res);\n}\n\nlocal_space local_space::set_from_params() const\n{\n  auto res = isl_local_space_set_from_params(copy());\n  return manage(res);\n}\n\nlocal_space local_space::set_tuple_id(isl::dim type, id id) const\n{\n  auto res = isl_local_space_set_tuple_id(copy(), static_cast<enum isl_dim_type>(type), id.release());\n  return manage(res);\n}\n\nlocal_space local_space::wrap() const\n{\n  auto res = isl_local_space_wrap(copy());\n  return manage(res);\n}\n\n// implementations for isl::map\nmap manage(__isl_take isl_map *ptr) {\n  return map(ptr);\n}\nmap manage_copy(__isl_keep isl_map *ptr) {\n  ptr = isl_map_copy(ptr);\n  return map(ptr);\n}\n\nmap::map()\n    : ptr(nullptr) {}\n\nmap::map(const map &obj)\n    : ptr(nullptr)\n{\n  ptr = obj.copy();\n}\nmap::map(std::nullptr_t)\n    : ptr(nullptr) {}\n\n\nmap::map(__isl_take isl_map *ptr)\n    : ptr(ptr) {}\n\nmap::map(basic_map bmap)\n{\n  auto res = isl_map_from_basic_map(bmap.release());\n  ptr = res;\n}\nmap::map(ctx ctx, const std::string &str)\n{\n  auto res = isl_map_read_from_str(ctx.release(), str.c_str());\n  ptr = res;\n}\n\nmap &map::operator=(map obj) {\n  std::swap(this->ptr, obj.ptr);\n  return *this;\n}\n\nmap::~map() {\n  if (ptr)\n    isl_map_free(ptr);\n}\n\n__isl_give isl_map *map::copy() const & {\n  return isl_map_copy(ptr);\n}\n\n__isl_keep isl_map *map::get() const {\n  return ptr;\n}\n\n__isl_give isl_map *map::release() {\n  isl_map *tmp = ptr;\n  ptr = nullptr;\n  return tmp;\n}\n\nbool map::is_null() const {\n  return ptr == nullptr;\n}\nmap::operator bool() const {\n  return !is_null();\n}\n\n\nctx map::get_ctx() const {\n  return ctx(isl_map_get_ctx(ptr));\n}\nstd::string map::to_str() const {\n  char *Tmp = isl_map_to_str(get());\n  if (!Tmp)\n    return \"\";\n  std::string S(Tmp);\n  free(Tmp);\n  return S;\n}\n\n\nvoid map::dump() const {\n  isl_map_dump(get());\n}\n\n\nmap map::add_constraint(constraint constraint) const\n{\n  auto res = isl_map_add_constraint(copy(), constraint.release());\n  return manage(res);\n}\n\nmap map::add_dims(isl::dim type, unsigned int n) const\n{\n  auto res = isl_map_add_dims(copy(), static_cast<enum isl_dim_type>(type), n);\n  return manage(res);\n}\n\nbasic_map map::affine_hull() const\n{\n  auto res = isl_map_affine_hull(copy());\n  return manage(res);\n}\n\nmap map::align_params(space model) const\n{\n  auto res = isl_map_align_params(copy(), model.release());\n  return manage(res);\n}\n\nmap map::apply_domain(map map2) const\n{\n  auto res = isl_map_apply_domain(copy(), map2.release());\n  return manage(res);\n}\n\nmap map::apply_range(map map2) const\n{\n  auto res = isl_map_apply_range(copy(), map2.release());\n  return manage(res);\n}\n\nset map::bind_domain(multi_id tuple) const\n{\n  auto res = isl_map_bind_domain(copy(), tuple.release());\n  return manage(res);\n}\n\nset map::bind_range(multi_id tuple) const\n{\n  auto res = isl_map_bind_range(copy(), tuple.release());\n  return manage(res);\n}\n\nboolean map::can_curry() const\n{\n  auto res = isl_map_can_curry(get());\n  return manage(res);\n}\n\nboolean map::can_range_curry() const\n{\n  auto res = isl_map_can_range_curry(get());\n  return manage(res);\n}\n\nboolean map::can_uncurry() const\n{\n  auto res = isl_map_can_uncurry(get());\n  return manage(res);\n}\n\nboolean map::can_zip() const\n{\n  auto res = isl_map_can_zip(get());\n  return manage(res);\n}\n\nmap map::coalesce() const\n{\n  auto res = isl_map_coalesce(copy());\n  return manage(res);\n}\n\nmap map::complement() const\n{\n  auto res = isl_map_complement(copy());\n  return manage(res);\n}\n\nbasic_map map::convex_hull() const\n{\n  auto res = isl_map_convex_hull(copy());\n  return manage(res);\n}\n\nmap map::curry() const\n{\n  auto res = isl_map_curry(copy());\n  return manage(res);\n}\n\nset map::deltas() const\n{\n  auto res = isl_map_deltas(copy());\n  return manage(res);\n}\n\nmap map::deltas_map() const\n{\n  auto res = isl_map_deltas_map(copy());\n  return manage(res);\n}\n\nmap map::detect_equalities() const\n{\n  auto res = isl_map_detect_equalities(copy());\n  return manage(res);\n}\n\nisl_size map::dim(isl::dim type) const\n{\n  auto res = isl_map_dim(get(), static_cast<enum isl_dim_type>(type));\n  return res;\n}\n\npw_aff map::dim_max(int pos) const\n{\n  auto res = isl_map_dim_max(copy(), pos);\n  return manage(res);\n}\n\npw_aff map::dim_min(int pos) const\n{\n  auto res = isl_map_dim_min(copy(), pos);\n  return manage(res);\n}\n\nset map::domain() const\n{\n  auto res = isl_map_domain(copy());\n  return manage(res);\n}\n\nmap map::domain_factor_domain() const\n{\n  auto res = isl_map_domain_factor_domain(copy());\n  return manage(res);\n}\n\nmap map::domain_factor_range() const\n{\n  auto res = isl_map_domain_factor_range(copy());\n  return manage(res);\n}\n\nboolean map::domain_is_wrapping() const\n{\n  auto res = isl_map_domain_is_wrapping(get());\n  return manage(res);\n}\n\nmap map::domain_map() const\n{\n  auto res = isl_map_domain_map(copy());\n  return manage(res);\n}\n\nmap map::domain_product(map map2) const\n{\n  auto res = isl_map_domain_product(copy(), map2.release());\n  return manage(res);\n}\n\nmap map::drop_constraints_involving_dims(isl::dim type, unsigned int first, unsigned int n) const\n{\n  auto res = isl_map_drop_constraints_involving_dims(copy(), static_cast<enum isl_dim_type>(type), first, n);\n  return manage(res);\n}\n\nmap map::drop_constraints_not_involving_dims(isl::dim type, unsigned int first, unsigned int n) const\n{\n  auto res = isl_map_drop_constraints_not_involving_dims(copy(), static_cast<enum isl_dim_type>(type), first, n);\n  return manage(res);\n}\n\nmap map::drop_unused_params() const\n{\n  auto res = isl_map_drop_unused_params(copy());\n  return manage(res);\n}\n\nmap map::eliminate(isl::dim type, unsigned int first, unsigned int n) const\n{\n  auto res = isl_map_eliminate(copy(), static_cast<enum isl_dim_type>(type), first, n);\n  return manage(res);\n}\n\nmap map::empty(space space)\n{\n  auto res = isl_map_empty(space.release());\n  return manage(res);\n}\n\nmap map::eq_at(multi_pw_aff mpa) const\n{\n  auto res = isl_map_eq_at_multi_pw_aff(copy(), mpa.release());\n  return manage(res);\n}\n\nmap map::equate(isl::dim type1, int pos1, isl::dim type2, int pos2) const\n{\n  auto res = isl_map_equate(copy(), static_cast<enum isl_dim_type>(type1), pos1, static_cast<enum isl_dim_type>(type2), pos2);\n  return manage(res);\n}\n\nmap map::factor_domain() const\n{\n  auto res = isl_map_factor_domain(copy());\n  return manage(res);\n}\n\nmap map::factor_range() const\n{\n  auto res = isl_map_factor_range(copy());\n  return manage(res);\n}\n\nint map::find_dim_by_id(isl::dim type, const id &id) const\n{\n  auto res = isl_map_find_dim_by_id(get(), static_cast<enum isl_dim_type>(type), id.get());\n  return res;\n}\n\nint map::find_dim_by_name(isl::dim type, const std::string &name) const\n{\n  auto res = isl_map_find_dim_by_name(get(), static_cast<enum isl_dim_type>(type), name.c_str());\n  return res;\n}\n\nmap map::fix_si(isl::dim type, unsigned int pos, int value) const\n{\n  auto res = isl_map_fix_si(copy(), static_cast<enum isl_dim_type>(type), pos, value);\n  return manage(res);\n}\n\nmap map::fix_val(isl::dim type, unsigned int pos, val v) const\n{\n  auto res = isl_map_fix_val(copy(), static_cast<enum isl_dim_type>(type), pos, v.release());\n  return manage(res);\n}\n\nmap map::fixed_power_val(val exp) const\n{\n  auto res = isl_map_fixed_power_val(copy(), exp.release());\n  return manage(res);\n}\n\nmap map::flat_domain_product(map map2) const\n{\n  auto res = isl_map_flat_domain_product(copy(), map2.release());\n  return manage(res);\n}\n\nmap map::flat_product(map map2) const\n{\n  auto res = isl_map_flat_product(copy(), map2.release());\n  return manage(res);\n}\n\nmap map::flat_range_product(map map2) const\n{\n  auto res = isl_map_flat_range_product(copy(), map2.release());\n  return manage(res);\n}\n\nmap map::flatten() const\n{\n  auto res = isl_map_flatten(copy());\n  return manage(res);\n}\n\nmap map::flatten_domain() const\n{\n  auto res = isl_map_flatten_domain(copy());\n  return manage(res);\n}\n\nmap map::flatten_range() const\n{\n  auto res = isl_map_flatten_range(copy());\n  return manage(res);\n}\n\nmap map::floordiv_val(val d) const\n{\n  auto res = isl_map_floordiv_val(copy(), d.release());\n  return manage(res);\n}\n\nstat map::foreach_basic_map(const std::function<stat(basic_map)> &fn) const\n{\n  struct fn_data {\n    const std::function<stat(basic_map)> *func;\n  } fn_data = { &fn };\n  auto fn_lambda = [](isl_basic_map *arg_0, void *arg_1) -> isl_stat {\n    auto *data = static_cast<struct fn_data *>(arg_1);\n    stat ret = (*data->func)(manage(arg_0));\n    return ret.release();\n  };\n  auto res = isl_map_foreach_basic_map(get(), fn_lambda, &fn_data);\n  return manage(res);\n}\n\nmap map::from_aff(aff aff)\n{\n  auto res = isl_map_from_aff(aff.release());\n  return manage(res);\n}\n\nmap map::from_domain(set set)\n{\n  auto res = isl_map_from_domain(set.release());\n  return manage(res);\n}\n\nmap map::from_domain_and_range(set domain, set range)\n{\n  auto res = isl_map_from_domain_and_range(domain.release(), range.release());\n  return manage(res);\n}\n\nmap map::from_multi_aff(multi_aff maff)\n{\n  auto res = isl_map_from_multi_aff(maff.release());\n  return manage(res);\n}\n\nmap map::from_multi_pw_aff(multi_pw_aff mpa)\n{\n  auto res = isl_map_from_multi_pw_aff(mpa.release());\n  return manage(res);\n}\n\nmap map::from_pw_aff(pw_aff pwaff)\n{\n  auto res = isl_map_from_pw_aff(pwaff.release());\n  return manage(res);\n}\n\nmap map::from_pw_multi_aff(pw_multi_aff pma)\n{\n  auto res = isl_map_from_pw_multi_aff(pma.release());\n  return manage(res);\n}\n\nmap map::from_range(set set)\n{\n  auto res = isl_map_from_range(set.release());\n  return manage(res);\n}\n\nmap map::from_union_map(union_map umap)\n{\n  auto res = isl_map_from_union_map(umap.release());\n  return manage(res);\n}\n\nbasic_map_list map::get_basic_map_list() const\n{\n  auto res = isl_map_get_basic_map_list(get());\n  return manage(res);\n}\n\nid map::get_dim_id(isl::dim type, unsigned int pos) const\n{\n  auto res = isl_map_get_dim_id(get(), static_cast<enum isl_dim_type>(type), pos);\n  return manage(res);\n}\n\nstd::string map::get_dim_name(isl::dim type, unsigned int pos) const\n{\n  auto res = isl_map_get_dim_name(get(), static_cast<enum isl_dim_type>(type), pos);\n  std::string tmp(res);\n  return tmp;\n}\n\nuint32_t map::get_hash() const\n{\n  auto res = isl_map_get_hash(get());\n  return res;\n}\n\nfixed_box map::get_range_simple_fixed_box_hull() const\n{\n  auto res = isl_map_get_range_simple_fixed_box_hull(get());\n  return manage(res);\n}\n\nspace map::get_space() const\n{\n  auto res = isl_map_get_space(get());\n  return manage(res);\n}\n\nid map::get_tuple_id(isl::dim type) const\n{\n  auto res = isl_map_get_tuple_id(get(), static_cast<enum isl_dim_type>(type));\n  return manage(res);\n}\n\nstd::string map::get_tuple_name(isl::dim type) const\n{\n  auto res = isl_map_get_tuple_name(get(), static_cast<enum isl_dim_type>(type));\n  std::string tmp(res);\n  return tmp;\n}\n\nmap map::gist(map context) const\n{\n  auto res = isl_map_gist(copy(), context.release());\n  return manage(res);\n}\n\nmap map::gist_basic_map(basic_map context) const\n{\n  auto res = isl_map_gist_basic_map(copy(), context.release());\n  return manage(res);\n}\n\nmap map::gist_domain(set context) const\n{\n  auto res = isl_map_gist_domain(copy(), context.release());\n  return manage(res);\n}\n\nmap map::gist_params(set context) const\n{\n  auto res = isl_map_gist_params(copy(), context.release());\n  return manage(res);\n}\n\nmap map::gist_range(set context) const\n{\n  auto res = isl_map_gist_range(copy(), context.release());\n  return manage(res);\n}\n\nboolean map::has_dim_id(isl::dim type, unsigned int pos) const\n{\n  auto res = isl_map_has_dim_id(get(), static_cast<enum isl_dim_type>(type), pos);\n  return manage(res);\n}\n\nboolean map::has_dim_name(isl::dim type, unsigned int pos) const\n{\n  auto res = isl_map_has_dim_name(get(), static_cast<enum isl_dim_type>(type), pos);\n  return manage(res);\n}\n\nboolean map::has_equal_space(const map &map2) const\n{\n  auto res = isl_map_has_equal_space(get(), map2.get());\n  return manage(res);\n}\n\nboolean map::has_tuple_id(isl::dim type) const\n{\n  auto res = isl_map_has_tuple_id(get(), static_cast<enum isl_dim_type>(type));\n  return manage(res);\n}\n\nboolean map::has_tuple_name(isl::dim type) const\n{\n  auto res = isl_map_has_tuple_name(get(), static_cast<enum isl_dim_type>(type));\n  return manage(res);\n}\n\nmap map::identity(space space)\n{\n  auto res = isl_map_identity(space.release());\n  return manage(res);\n}\n\nmap map::insert_dims(isl::dim type, unsigned int pos, unsigned int n) const\n{\n  auto res = isl_map_insert_dims(copy(), static_cast<enum isl_dim_type>(type), pos, n);\n  return manage(res);\n}\n\nmap map::intersect(map map2) const\n{\n  auto res = isl_map_intersect(copy(), map2.release());\n  return manage(res);\n}\n\nmap map::intersect_domain(set set) const\n{\n  auto res = isl_map_intersect_domain(copy(), set.release());\n  return manage(res);\n}\n\nmap map::intersect_domain_factor_domain(map factor) const\n{\n  auto res = isl_map_intersect_domain_factor_domain(copy(), factor.release());\n  return manage(res);\n}\n\nmap map::intersect_domain_factor_range(map factor) const\n{\n  auto res = isl_map_intersect_domain_factor_range(copy(), factor.release());\n  return manage(res);\n}\n\nmap map::intersect_params(set params) const\n{\n  auto res = isl_map_intersect_params(copy(), params.release());\n  return manage(res);\n}\n\nmap map::intersect_range(set set) const\n{\n  auto res = isl_map_intersect_range(copy(), set.release());\n  return manage(res);\n}\n\nmap map::intersect_range_factor_domain(map factor) const\n{\n  auto res = isl_map_intersect_range_factor_domain(copy(), factor.release());\n  return manage(res);\n}\n\nmap map::intersect_range_factor_range(map factor) const\n{\n  auto res = isl_map_intersect_range_factor_range(copy(), factor.release());\n  return manage(res);\n}\n\nboolean map::involves_dims(isl::dim type, unsigned int first, unsigned int n) const\n{\n  auto res = isl_map_involves_dims(get(), static_cast<enum isl_dim_type>(type), first, n);\n  return manage(res);\n}\n\nboolean map::is_bijective() const\n{\n  auto res = isl_map_is_bijective(get());\n  return manage(res);\n}\n\nboolean map::is_disjoint(const map &map2) const\n{\n  auto res = isl_map_is_disjoint(get(), map2.get());\n  return manage(res);\n}\n\nboolean map::is_empty() const\n{\n  auto res = isl_map_is_empty(get());\n  return manage(res);\n}\n\nboolean map::is_equal(const map &map2) const\n{\n  auto res = isl_map_is_equal(get(), map2.get());\n  return manage(res);\n}\n\nboolean map::is_identity() const\n{\n  auto res = isl_map_is_identity(get());\n  return manage(res);\n}\n\nboolean map::is_injective() const\n{\n  auto res = isl_map_is_injective(get());\n  return manage(res);\n}\n\nboolean map::is_product() const\n{\n  auto res = isl_map_is_product(get());\n  return manage(res);\n}\n\nboolean map::is_single_valued() const\n{\n  auto res = isl_map_is_single_valued(get());\n  return manage(res);\n}\n\nboolean map::is_strict_subset(const map &map2) const\n{\n  auto res = isl_map_is_strict_subset(get(), map2.get());\n  return manage(res);\n}\n\nboolean map::is_subset(const map &map2) const\n{\n  auto res = isl_map_is_subset(get(), map2.get());\n  return manage(res);\n}\n\nint map::is_translation() const\n{\n  auto res = isl_map_is_translation(get());\n  return res;\n}\n\nmap map::lex_ge(space set_space)\n{\n  auto res = isl_map_lex_ge(set_space.release());\n  return manage(res);\n}\n\nmap map::lex_ge_at(multi_pw_aff mpa) const\n{\n  auto res = isl_map_lex_ge_at_multi_pw_aff(copy(), mpa.release());\n  return manage(res);\n}\n\nmap map::lex_ge_first(space space, unsigned int n)\n{\n  auto res = isl_map_lex_ge_first(space.release(), n);\n  return manage(res);\n}\n\nmap map::lex_ge_map(map map2) const\n{\n  auto res = isl_map_lex_ge_map(copy(), map2.release());\n  return manage(res);\n}\n\nmap map::lex_gt(space set_space)\n{\n  auto res = isl_map_lex_gt(set_space.release());\n  return manage(res);\n}\n\nmap map::lex_gt_at(multi_pw_aff mpa) const\n{\n  auto res = isl_map_lex_gt_at_multi_pw_aff(copy(), mpa.release());\n  return manage(res);\n}\n\nmap map::lex_gt_first(space space, unsigned int n)\n{\n  auto res = isl_map_lex_gt_first(space.release(), n);\n  return manage(res);\n}\n\nmap map::lex_gt_map(map map2) const\n{\n  auto res = isl_map_lex_gt_map(copy(), map2.release());\n  return manage(res);\n}\n\nmap map::lex_le(space set_space)\n{\n  auto res = isl_map_lex_le(set_space.release());\n  return manage(res);\n}\n\nmap map::lex_le_at(multi_pw_aff mpa) const\n{\n  auto res = isl_map_lex_le_at_multi_pw_aff(copy(), mpa.release());\n  return manage(res);\n}\n\nmap map::lex_le_first(space space, unsigned int n)\n{\n  auto res = isl_map_lex_le_first(space.release(), n);\n  return manage(res);\n}\n\nmap map::lex_le_map(map map2) const\n{\n  auto res = isl_map_lex_le_map(copy(), map2.release());\n  return manage(res);\n}\n\nmap map::lex_lt(space set_space)\n{\n  auto res = isl_map_lex_lt(set_space.release());\n  return manage(res);\n}\n\nmap map::lex_lt_at(multi_pw_aff mpa) const\n{\n  auto res = isl_map_lex_lt_at_multi_pw_aff(copy(), mpa.release());\n  return manage(res);\n}\n\nmap map::lex_lt_first(space space, unsigned int n)\n{\n  auto res = isl_map_lex_lt_first(space.release(), n);\n  return manage(res);\n}\n\nmap map::lex_lt_map(map map2) const\n{\n  auto res = isl_map_lex_lt_map(copy(), map2.release());\n  return manage(res);\n}\n\nmap map::lexmax() const\n{\n  auto res = isl_map_lexmax(copy());\n  return manage(res);\n}\n\npw_multi_aff map::lexmax_pw_multi_aff() const\n{\n  auto res = isl_map_lexmax_pw_multi_aff(copy());\n  return manage(res);\n}\n\nmap map::lexmin() const\n{\n  auto res = isl_map_lexmin(copy());\n  return manage(res);\n}\n\npw_multi_aff map::lexmin_pw_multi_aff() const\n{\n  auto res = isl_map_lexmin_pw_multi_aff(copy());\n  return manage(res);\n}\n\nmap map::lower_bound(multi_pw_aff lower) const\n{\n  auto res = isl_map_lower_bound_multi_pw_aff(copy(), lower.release());\n  return manage(res);\n}\n\nmap map::lower_bound_si(isl::dim type, unsigned int pos, int value) const\n{\n  auto res = isl_map_lower_bound_si(copy(), static_cast<enum isl_dim_type>(type), pos, value);\n  return manage(res);\n}\n\nmap map::lower_bound_val(isl::dim type, unsigned int pos, val value) const\n{\n  auto res = isl_map_lower_bound_val(copy(), static_cast<enum isl_dim_type>(type), pos, value.release());\n  return manage(res);\n}\n\nmulti_pw_aff map::max_multi_pw_aff() const\n{\n  auto res = isl_map_max_multi_pw_aff(copy());\n  return manage(res);\n}\n\nmulti_pw_aff map::min_multi_pw_aff() const\n{\n  auto res = isl_map_min_multi_pw_aff(copy());\n  return manage(res);\n}\n\nmap map::move_dims(isl::dim dst_type, unsigned int dst_pos, isl::dim src_type, unsigned int src_pos, unsigned int n) const\n{\n  auto res = isl_map_move_dims(copy(), static_cast<enum isl_dim_type>(dst_type), dst_pos, static_cast<enum isl_dim_type>(src_type), src_pos, n);\n  return manage(res);\n}\n\nisl_size map::n_basic_map() const\n{\n  auto res = isl_map_n_basic_map(get());\n  return res;\n}\n\nmap map::nat_universe(space space)\n{\n  auto res = isl_map_nat_universe(space.release());\n  return manage(res);\n}\n\nmap map::neg() const\n{\n  auto res = isl_map_neg(copy());\n  return manage(res);\n}\n\nmap map::oppose(isl::dim type1, int pos1, isl::dim type2, int pos2) const\n{\n  auto res = isl_map_oppose(copy(), static_cast<enum isl_dim_type>(type1), pos1, static_cast<enum isl_dim_type>(type2), pos2);\n  return manage(res);\n}\n\nmap map::order_ge(isl::dim type1, int pos1, isl::dim type2, int pos2) const\n{\n  auto res = isl_map_order_ge(copy(), static_cast<enum isl_dim_type>(type1), pos1, static_cast<enum isl_dim_type>(type2), pos2);\n  return manage(res);\n}\n\nmap map::order_gt(isl::dim type1, int pos1, isl::dim type2, int pos2) const\n{\n  auto res = isl_map_order_gt(copy(), static_cast<enum isl_dim_type>(type1), pos1, static_cast<enum isl_dim_type>(type2), pos2);\n  return manage(res);\n}\n\nmap map::order_le(isl::dim type1, int pos1, isl::dim type2, int pos2) const\n{\n  auto res = isl_map_order_le(copy(), static_cast<enum isl_dim_type>(type1), pos1, static_cast<enum isl_dim_type>(type2), pos2);\n  return manage(res);\n}\n\nmap map::order_lt(isl::dim type1, int pos1, isl::dim type2, int pos2) const\n{\n  auto res = isl_map_order_lt(copy(), static_cast<enum isl_dim_type>(type1), pos1, static_cast<enum isl_dim_type>(type2), pos2);\n  return manage(res);\n}\n\nset map::params() const\n{\n  auto res = isl_map_params(copy());\n  return manage(res);\n}\n\nval map::plain_get_val_if_fixed(isl::dim type, unsigned int pos) const\n{\n  auto res = isl_map_plain_get_val_if_fixed(get(), static_cast<enum isl_dim_type>(type), pos);\n  return manage(res);\n}\n\nboolean map::plain_is_empty() const\n{\n  auto res = isl_map_plain_is_empty(get());\n  return manage(res);\n}\n\nboolean map::plain_is_equal(const map &map2) const\n{\n  auto res = isl_map_plain_is_equal(get(), map2.get());\n  return manage(res);\n}\n\nboolean map::plain_is_injective() const\n{\n  auto res = isl_map_plain_is_injective(get());\n  return manage(res);\n}\n\nboolean map::plain_is_single_valued() const\n{\n  auto res = isl_map_plain_is_single_valued(get());\n  return manage(res);\n}\n\nboolean map::plain_is_universe() const\n{\n  auto res = isl_map_plain_is_universe(get());\n  return manage(res);\n}\n\nbasic_map map::plain_unshifted_simple_hull() const\n{\n  auto res = isl_map_plain_unshifted_simple_hull(copy());\n  return manage(res);\n}\n\nbasic_map map::polyhedral_hull() const\n{\n  auto res = isl_map_polyhedral_hull(copy());\n  return manage(res);\n}\n\nmap map::preimage_domain(multi_aff ma) const\n{\n  auto res = isl_map_preimage_domain_multi_aff(copy(), ma.release());\n  return manage(res);\n}\n\nmap map::preimage_domain(multi_pw_aff mpa) const\n{\n  auto res = isl_map_preimage_domain_multi_pw_aff(copy(), mpa.release());\n  return manage(res);\n}\n\nmap map::preimage_domain(pw_multi_aff pma) const\n{\n  auto res = isl_map_preimage_domain_pw_multi_aff(copy(), pma.release());\n  return manage(res);\n}\n\nmap map::preimage_range(multi_aff ma) const\n{\n  auto res = isl_map_preimage_range_multi_aff(copy(), ma.release());\n  return manage(res);\n}\n\nmap map::preimage_range(pw_multi_aff pma) const\n{\n  auto res = isl_map_preimage_range_pw_multi_aff(copy(), pma.release());\n  return manage(res);\n}\n\nmap map::product(map map2) const\n{\n  auto res = isl_map_product(copy(), map2.release());\n  return manage(res);\n}\n\nmap map::project_out(isl::dim type, unsigned int first, unsigned int n) const\n{\n  auto res = isl_map_project_out(copy(), static_cast<enum isl_dim_type>(type), first, n);\n  return manage(res);\n}\n\nmap map::project_out_all_params() const\n{\n  auto res = isl_map_project_out_all_params(copy());\n  return manage(res);\n}\n\nset map::range() const\n{\n  auto res = isl_map_range(copy());\n  return manage(res);\n}\n\nmap map::range_curry() const\n{\n  auto res = isl_map_range_curry(copy());\n  return manage(res);\n}\n\nmap map::range_factor_domain() const\n{\n  auto res = isl_map_range_factor_domain(copy());\n  return manage(res);\n}\n\nmap map::range_factor_range() const\n{\n  auto res = isl_map_range_factor_range(copy());\n  return manage(res);\n}\n\nboolean map::range_is_wrapping() const\n{\n  auto res = isl_map_range_is_wrapping(get());\n  return manage(res);\n}\n\nmap map::range_map() const\n{\n  auto res = isl_map_range_map(copy());\n  return manage(res);\n}\n\nmap map::range_product(map map2) const\n{\n  auto res = isl_map_range_product(copy(), map2.release());\n  return manage(res);\n}\n\nmap map::range_reverse() const\n{\n  auto res = isl_map_range_reverse(copy());\n  return manage(res);\n}\n\nmap map::remove_dims(isl::dim type, unsigned int first, unsigned int n) const\n{\n  auto res = isl_map_remove_dims(copy(), static_cast<enum isl_dim_type>(type), first, n);\n  return manage(res);\n}\n\nmap map::remove_divs() const\n{\n  auto res = isl_map_remove_divs(copy());\n  return manage(res);\n}\n\nmap map::remove_divs_involving_dims(isl::dim type, unsigned int first, unsigned int n) const\n{\n  auto res = isl_map_remove_divs_involving_dims(copy(), static_cast<enum isl_dim_type>(type), first, n);\n  return manage(res);\n}\n\nmap map::remove_redundancies() const\n{\n  auto res = isl_map_remove_redundancies(copy());\n  return manage(res);\n}\n\nmap map::remove_unknown_divs() const\n{\n  auto res = isl_map_remove_unknown_divs(copy());\n  return manage(res);\n}\n\nmap map::reset_tuple_id(isl::dim type) const\n{\n  auto res = isl_map_reset_tuple_id(copy(), static_cast<enum isl_dim_type>(type));\n  return manage(res);\n}\n\nmap map::reset_user() const\n{\n  auto res = isl_map_reset_user(copy());\n  return manage(res);\n}\n\nmap map::reverse() const\n{\n  auto res = isl_map_reverse(copy());\n  return manage(res);\n}\n\nbasic_map map::sample() const\n{\n  auto res = isl_map_sample(copy());\n  return manage(res);\n}\n\nmap map::set_dim_id(isl::dim type, unsigned int pos, id id) const\n{\n  auto res = isl_map_set_dim_id(copy(), static_cast<enum isl_dim_type>(type), pos, id.release());\n  return manage(res);\n}\n\nmap map::set_tuple_id(isl::dim type, id id) const\n{\n  auto res = isl_map_set_tuple_id(copy(), static_cast<enum isl_dim_type>(type), id.release());\n  return manage(res);\n}\n\nmap map::set_tuple_name(isl::dim type, const std::string &s) const\n{\n  auto res = isl_map_set_tuple_name(copy(), static_cast<enum isl_dim_type>(type), s.c_str());\n  return manage(res);\n}\n\nbasic_map map::simple_hull() const\n{\n  auto res = isl_map_simple_hull(copy());\n  return manage(res);\n}\n\nmap map::subtract(map map2) const\n{\n  auto res = isl_map_subtract(copy(), map2.release());\n  return manage(res);\n}\n\nmap map::subtract_domain(set dom) const\n{\n  auto res = isl_map_subtract_domain(copy(), dom.release());\n  return manage(res);\n}\n\nmap map::subtract_range(set dom) const\n{\n  auto res = isl_map_subtract_range(copy(), dom.release());\n  return manage(res);\n}\n\nmap map::sum(map map2) const\n{\n  auto res = isl_map_sum(copy(), map2.release());\n  return manage(res);\n}\n\nmap map::uncurry() const\n{\n  auto res = isl_map_uncurry(copy());\n  return manage(res);\n}\n\nmap map::unite(map map2) const\n{\n  auto res = isl_map_union(copy(), map2.release());\n  return manage(res);\n}\n\nmap map::universe(space space)\n{\n  auto res = isl_map_universe(space.release());\n  return manage(res);\n}\n\nbasic_map map::unshifted_simple_hull() const\n{\n  auto res = isl_map_unshifted_simple_hull(copy());\n  return manage(res);\n}\n\nbasic_map map::unshifted_simple_hull_from_map_list(map_list list) const\n{\n  auto res = isl_map_unshifted_simple_hull_from_map_list(copy(), list.release());\n  return manage(res);\n}\n\nmap map::upper_bound(multi_pw_aff upper) const\n{\n  auto res = isl_map_upper_bound_multi_pw_aff(copy(), upper.release());\n  return manage(res);\n}\n\nmap map::upper_bound_si(isl::dim type, unsigned int pos, int value) const\n{\n  auto res = isl_map_upper_bound_si(copy(), static_cast<enum isl_dim_type>(type), pos, value);\n  return manage(res);\n}\n\nmap map::upper_bound_val(isl::dim type, unsigned int pos, val value) const\n{\n  auto res = isl_map_upper_bound_val(copy(), static_cast<enum isl_dim_type>(type), pos, value.release());\n  return manage(res);\n}\n\nset map::wrap() const\n{\n  auto res = isl_map_wrap(copy());\n  return manage(res);\n}\n\nmap map::zip() const\n{\n  auto res = isl_map_zip(copy());\n  return manage(res);\n}\n\n// implementations for isl::map_list\nmap_list manage(__isl_take isl_map_list *ptr) {\n  return map_list(ptr);\n}\nmap_list manage_copy(__isl_keep isl_map_list *ptr) {\n  ptr = isl_map_list_copy(ptr);\n  return map_list(ptr);\n}\n\nmap_list::map_list()\n    : ptr(nullptr) {}\n\nmap_list::map_list(const map_list &obj)\n    : ptr(nullptr)\n{\n  ptr = obj.copy();\n}\nmap_list::map_list(std::nullptr_t)\n    : ptr(nullptr) {}\n\n\nmap_list::map_list(__isl_take isl_map_list *ptr)\n    : ptr(ptr) {}\n\n\nmap_list &map_list::operator=(map_list obj) {\n  std::swap(this->ptr, obj.ptr);\n  return *this;\n}\n\nmap_list::~map_list() {\n  if (ptr)\n    isl_map_list_free(ptr);\n}\n\n__isl_give isl_map_list *map_list::copy() const & {\n  return isl_map_list_copy(ptr);\n}\n\n__isl_keep isl_map_list *map_list::get() const {\n  return ptr;\n}\n\n__isl_give isl_map_list *map_list::release() {\n  isl_map_list *tmp = ptr;\n  ptr = nullptr;\n  return tmp;\n}\n\nbool map_list::is_null() const {\n  return ptr == nullptr;\n}\nmap_list::operator bool() const {\n  return !is_null();\n}\n\n\nctx map_list::get_ctx() const {\n  return ctx(isl_map_list_get_ctx(ptr));\n}\nstd::string map_list::to_str() const {\n  char *Tmp = isl_map_list_to_str(get());\n  if (!Tmp)\n    return \"\";\n  std::string S(Tmp);\n  free(Tmp);\n  return S;\n}\n\n\nvoid map_list::dump() const {\n  isl_map_list_dump(get());\n}\n\n\nmap_list map_list::add(map el) const\n{\n  auto res = isl_map_list_add(copy(), el.release());\n  return manage(res);\n}\n\nmap_list map_list::alloc(ctx ctx, int n)\n{\n  auto res = isl_map_list_alloc(ctx.release(), n);\n  return manage(res);\n}\n\nmap_list map_list::clear() const\n{\n  auto res = isl_map_list_clear(copy());\n  return manage(res);\n}\n\nmap_list map_list::concat(map_list list2) const\n{\n  auto res = isl_map_list_concat(copy(), list2.release());\n  return manage(res);\n}\n\nmap_list map_list::drop(unsigned int first, unsigned int n) const\n{\n  auto res = isl_map_list_drop(copy(), first, n);\n  return manage(res);\n}\n\nstat map_list::foreach(const std::function<stat(map)> &fn) const\n{\n  struct fn_data {\n    const std::function<stat(map)> *func;\n  } fn_data = { &fn };\n  auto fn_lambda = [](isl_map *arg_0, void *arg_1) -> isl_stat {\n    auto *data = static_cast<struct fn_data *>(arg_1);\n    stat ret = (*data->func)(manage(arg_0));\n    return ret.release();\n  };\n  auto res = isl_map_list_foreach(get(), fn_lambda, &fn_data);\n  return manage(res);\n}\n\nmap_list map_list::from_map(map el)\n{\n  auto res = isl_map_list_from_map(el.release());\n  return manage(res);\n}\n\nmap map_list::get_at(int index) const\n{\n  auto res = isl_map_list_get_at(get(), index);\n  return manage(res);\n}\n\nmap map_list::get_map(int index) const\n{\n  auto res = isl_map_list_get_map(get(), index);\n  return manage(res);\n}\n\nmap_list map_list::insert(unsigned int pos, map el) const\n{\n  auto res = isl_map_list_insert(copy(), pos, el.release());\n  return manage(res);\n}\n\nisl_size map_list::n_map() const\n{\n  auto res = isl_map_list_n_map(get());\n  return res;\n}\n\nmap_list map_list::reverse() const\n{\n  auto res = isl_map_list_reverse(copy());\n  return manage(res);\n}\n\nmap_list map_list::set_map(int index, map el) const\n{\n  auto res = isl_map_list_set_map(copy(), index, el.release());\n  return manage(res);\n}\n\nisl_size map_list::size() const\n{\n  auto res = isl_map_list_size(get());\n  return res;\n}\n\nmap_list map_list::swap(unsigned int pos1, unsigned int pos2) const\n{\n  auto res = isl_map_list_swap(copy(), pos1, pos2);\n  return manage(res);\n}\n\n// implementations for isl::mat\nmat manage(__isl_take isl_mat *ptr) {\n  return mat(ptr);\n}\nmat manage_copy(__isl_keep isl_mat *ptr) {\n  ptr = isl_mat_copy(ptr);\n  return mat(ptr);\n}\n\nmat::mat()\n    : ptr(nullptr) {}\n\nmat::mat(const mat &obj)\n    : ptr(nullptr)\n{\n  ptr = obj.copy();\n}\nmat::mat(std::nullptr_t)\n    : ptr(nullptr) {}\n\n\nmat::mat(__isl_take isl_mat *ptr)\n    : ptr(ptr) {}\n\n\nmat &mat::operator=(mat obj) {\n  std::swap(this->ptr, obj.ptr);\n  return *this;\n}\n\nmat::~mat() {\n  if (ptr)\n    isl_mat_free(ptr);\n}\n\n__isl_give isl_mat *mat::copy() const & {\n  return isl_mat_copy(ptr);\n}\n\n__isl_keep isl_mat *mat::get() const {\n  return ptr;\n}\n\n__isl_give isl_mat *mat::release() {\n  isl_mat *tmp = ptr;\n  ptr = nullptr;\n  return tmp;\n}\n\nbool mat::is_null() const {\n  return ptr == nullptr;\n}\nmat::operator bool() const {\n  return !is_null();\n}\n\n\nctx mat::get_ctx() const {\n  return ctx(isl_mat_get_ctx(ptr));\n}\n\nvoid mat::dump() const {\n  isl_mat_dump(get());\n}\n\n\nmat mat::add_rows(unsigned int n) const\n{\n  auto res = isl_mat_add_rows(copy(), n);\n  return manage(res);\n}\n\nmat mat::add_zero_cols(unsigned int n) const\n{\n  auto res = isl_mat_add_zero_cols(copy(), n);\n  return manage(res);\n}\n\nmat mat::add_zero_rows(unsigned int n) const\n{\n  auto res = isl_mat_add_zero_rows(copy(), n);\n  return manage(res);\n}\n\nmat mat::aff_direct_sum(mat right) const\n{\n  auto res = isl_mat_aff_direct_sum(copy(), right.release());\n  return manage(res);\n}\n\nmat mat::alloc(ctx ctx, unsigned int n_row, unsigned int n_col)\n{\n  auto res = isl_mat_alloc(ctx.release(), n_row, n_col);\n  return manage(res);\n}\n\nisl_size mat::cols() const\n{\n  auto res = isl_mat_cols(get());\n  return res;\n}\n\nmat mat::concat(mat bot) const\n{\n  auto res = isl_mat_concat(copy(), bot.release());\n  return manage(res);\n}\n\nmat mat::diagonal(mat mat2) const\n{\n  auto res = isl_mat_diagonal(copy(), mat2.release());\n  return manage(res);\n}\n\nmat mat::drop_cols(unsigned int col, unsigned int n) const\n{\n  auto res = isl_mat_drop_cols(copy(), col, n);\n  return manage(res);\n}\n\nmat mat::drop_rows(unsigned int row, unsigned int n) const\n{\n  auto res = isl_mat_drop_rows(copy(), row, n);\n  return manage(res);\n}\n\nmat mat::from_row_vec(vec vec)\n{\n  auto res = isl_mat_from_row_vec(vec.release());\n  return manage(res);\n}\n\nval mat::get_element_val(int row, int col) const\n{\n  auto res = isl_mat_get_element_val(get(), row, col);\n  return manage(res);\n}\n\nboolean mat::has_linearly_independent_rows(const mat &mat2) const\n{\n  auto res = isl_mat_has_linearly_independent_rows(get(), mat2.get());\n  return manage(res);\n}\n\nint mat::initial_non_zero_cols() const\n{\n  auto res = isl_mat_initial_non_zero_cols(get());\n  return res;\n}\n\nmat mat::insert_cols(unsigned int col, unsigned int n) const\n{\n  auto res = isl_mat_insert_cols(copy(), col, n);\n  return manage(res);\n}\n\nmat mat::insert_rows(unsigned int row, unsigned int n) const\n{\n  auto res = isl_mat_insert_rows(copy(), row, n);\n  return manage(res);\n}\n\nmat mat::insert_zero_cols(unsigned int first, unsigned int n) const\n{\n  auto res = isl_mat_insert_zero_cols(copy(), first, n);\n  return manage(res);\n}\n\nmat mat::insert_zero_rows(unsigned int row, unsigned int n) const\n{\n  auto res = isl_mat_insert_zero_rows(copy(), row, n);\n  return manage(res);\n}\n\nmat mat::inverse_product(mat right) const\n{\n  auto res = isl_mat_inverse_product(copy(), right.release());\n  return manage(res);\n}\n\nboolean mat::is_equal(const mat &mat2) const\n{\n  auto res = isl_mat_is_equal(get(), mat2.get());\n  return manage(res);\n}\n\nmat mat::lin_to_aff() const\n{\n  auto res = isl_mat_lin_to_aff(copy());\n  return manage(res);\n}\n\nmat mat::move_cols(unsigned int dst_col, unsigned int src_col, unsigned int n) const\n{\n  auto res = isl_mat_move_cols(copy(), dst_col, src_col, n);\n  return manage(res);\n}\n\nmat mat::normalize() const\n{\n  auto res = isl_mat_normalize(copy());\n  return manage(res);\n}\n\nmat mat::normalize_row(int row) const\n{\n  auto res = isl_mat_normalize_row(copy(), row);\n  return manage(res);\n}\n\nmat mat::product(mat right) const\n{\n  auto res = isl_mat_product(copy(), right.release());\n  return manage(res);\n}\n\nisl_size mat::rank() const\n{\n  auto res = isl_mat_rank(get());\n  return res;\n}\n\nmat mat::right_inverse() const\n{\n  auto res = isl_mat_right_inverse(copy());\n  return manage(res);\n}\n\nmat mat::right_kernel() const\n{\n  auto res = isl_mat_right_kernel(copy());\n  return manage(res);\n}\n\nmat mat::row_basis() const\n{\n  auto res = isl_mat_row_basis(copy());\n  return manage(res);\n}\n\nmat mat::row_basis_extension(mat mat2) const\n{\n  auto res = isl_mat_row_basis_extension(copy(), mat2.release());\n  return manage(res);\n}\n\nisl_size mat::rows() const\n{\n  auto res = isl_mat_rows(get());\n  return res;\n}\n\nmat mat::set_element_si(int row, int col, int v) const\n{\n  auto res = isl_mat_set_element_si(copy(), row, col, v);\n  return manage(res);\n}\n\nmat mat::set_element_val(int row, int col, val v) const\n{\n  auto res = isl_mat_set_element_val(copy(), row, col, v.release());\n  return manage(res);\n}\n\nmat mat::swap_cols(unsigned int i, unsigned int j) const\n{\n  auto res = isl_mat_swap_cols(copy(), i, j);\n  return manage(res);\n}\n\nmat mat::swap_rows(unsigned int i, unsigned int j) const\n{\n  auto res = isl_mat_swap_rows(copy(), i, j);\n  return manage(res);\n}\n\nmat mat::transpose() const\n{\n  auto res = isl_mat_transpose(copy());\n  return manage(res);\n}\n\nmat mat::unimodular_complete(int row) const\n{\n  auto res = isl_mat_unimodular_complete(copy(), row);\n  return manage(res);\n}\n\nmat mat::vec_concat(vec bot) const\n{\n  auto res = isl_mat_vec_concat(copy(), bot.release());\n  return manage(res);\n}\n\nvec mat::vec_inverse_product(vec vec) const\n{\n  auto res = isl_mat_vec_inverse_product(copy(), vec.release());\n  return manage(res);\n}\n\nvec mat::vec_product(vec vec) const\n{\n  auto res = isl_mat_vec_product(copy(), vec.release());\n  return manage(res);\n}\n\n// implementations for isl::multi_aff\nmulti_aff manage(__isl_take isl_multi_aff *ptr) {\n  return multi_aff(ptr);\n}\nmulti_aff manage_copy(__isl_keep isl_multi_aff *ptr) {\n  ptr = isl_multi_aff_copy(ptr);\n  return multi_aff(ptr);\n}\n\nmulti_aff::multi_aff()\n    : ptr(nullptr) {}\n\nmulti_aff::multi_aff(const multi_aff &obj)\n    : ptr(nullptr)\n{\n  ptr = obj.copy();\n}\nmulti_aff::multi_aff(std::nullptr_t)\n    : ptr(nullptr) {}\n\n\nmulti_aff::multi_aff(__isl_take isl_multi_aff *ptr)\n    : ptr(ptr) {}\n\nmulti_aff::multi_aff(aff aff)\n{\n  auto res = isl_multi_aff_from_aff(aff.release());\n  ptr = res;\n}\nmulti_aff::multi_aff(space space, aff_list list)\n{\n  auto res = isl_multi_aff_from_aff_list(space.release(), list.release());\n  ptr = res;\n}\nmulti_aff::multi_aff(ctx ctx, const std::string &str)\n{\n  auto res = isl_multi_aff_read_from_str(ctx.release(), str.c_str());\n  ptr = res;\n}\n\nmulti_aff &multi_aff::operator=(multi_aff obj) {\n  std::swap(this->ptr, obj.ptr);\n  return *this;\n}\n\nmulti_aff::~multi_aff() {\n  if (ptr)\n    isl_multi_aff_free(ptr);\n}\n\n__isl_give isl_multi_aff *multi_aff::copy() const & {\n  return isl_multi_aff_copy(ptr);\n}\n\n__isl_keep isl_multi_aff *multi_aff::get() const {\n  return ptr;\n}\n\n__isl_give isl_multi_aff *multi_aff::release() {\n  isl_multi_aff *tmp = ptr;\n  ptr = nullptr;\n  return tmp;\n}\n\nbool multi_aff::is_null() const {\n  return ptr == nullptr;\n}\nmulti_aff::operator bool() const {\n  return !is_null();\n}\n\n\nctx multi_aff::get_ctx() const {\n  return ctx(isl_multi_aff_get_ctx(ptr));\n}\nstd::string multi_aff::to_str() const {\n  char *Tmp = isl_multi_aff_to_str(get());\n  if (!Tmp)\n    return \"\";\n  std::string S(Tmp);\n  free(Tmp);\n  return S;\n}\n\n\nvoid multi_aff::dump() const {\n  isl_multi_aff_dump(get());\n}\n\n\nmulti_aff multi_aff::add(multi_aff multi2) const\n{\n  auto res = isl_multi_aff_add(copy(), multi2.release());\n  return manage(res);\n}\n\nmulti_aff multi_aff::add_constant(multi_val mv) const\n{\n  auto res = isl_multi_aff_add_constant_multi_val(copy(), mv.release());\n  return manage(res);\n}\n\nmulti_aff multi_aff::add_constant(val v) const\n{\n  auto res = isl_multi_aff_add_constant_val(copy(), v.release());\n  return manage(res);\n}\n\nmulti_aff multi_aff::add_dims(isl::dim type, unsigned int n) const\n{\n  auto res = isl_multi_aff_add_dims(copy(), static_cast<enum isl_dim_type>(type), n);\n  return manage(res);\n}\n\nmulti_aff multi_aff::align_params(space model) const\n{\n  auto res = isl_multi_aff_align_params(copy(), model.release());\n  return manage(res);\n}\n\nbasic_set multi_aff::bind(multi_id tuple) const\n{\n  auto res = isl_multi_aff_bind(copy(), tuple.release());\n  return manage(res);\n}\n\nmulti_aff multi_aff::bind_domain(multi_id tuple) const\n{\n  auto res = isl_multi_aff_bind_domain(copy(), tuple.release());\n  return manage(res);\n}\n\nmulti_aff multi_aff::bind_domain_wrapped_domain(multi_id tuple) const\n{\n  auto res = isl_multi_aff_bind_domain_wrapped_domain(copy(), tuple.release());\n  return manage(res);\n}\n\nisl_size multi_aff::dim(isl::dim type) const\n{\n  auto res = isl_multi_aff_dim(get(), static_cast<enum isl_dim_type>(type));\n  return res;\n}\n\nmulti_aff multi_aff::domain_map(space space)\n{\n  auto res = isl_multi_aff_domain_map(space.release());\n  return manage(res);\n}\n\nmulti_aff multi_aff::drop_dims(isl::dim type, unsigned int first, unsigned int n) const\n{\n  auto res = isl_multi_aff_drop_dims(copy(), static_cast<enum isl_dim_type>(type), first, n);\n  return manage(res);\n}\n\nmulti_aff multi_aff::factor_range() const\n{\n  auto res = isl_multi_aff_factor_range(copy());\n  return manage(res);\n}\n\nint multi_aff::find_dim_by_id(isl::dim type, const id &id) const\n{\n  auto res = isl_multi_aff_find_dim_by_id(get(), static_cast<enum isl_dim_type>(type), id.get());\n  return res;\n}\n\nint multi_aff::find_dim_by_name(isl::dim type, const std::string &name) const\n{\n  auto res = isl_multi_aff_find_dim_by_name(get(), static_cast<enum isl_dim_type>(type), name.c_str());\n  return res;\n}\n\nmulti_aff multi_aff::flat_range_product(multi_aff multi2) const\n{\n  auto res = isl_multi_aff_flat_range_product(copy(), multi2.release());\n  return manage(res);\n}\n\nmulti_aff multi_aff::flatten_domain() const\n{\n  auto res = isl_multi_aff_flatten_domain(copy());\n  return manage(res);\n}\n\nmulti_aff multi_aff::flatten_range() const\n{\n  auto res = isl_multi_aff_flatten_range(copy());\n  return manage(res);\n}\n\nmulti_aff multi_aff::floor() const\n{\n  auto res = isl_multi_aff_floor(copy());\n  return manage(res);\n}\n\nmulti_aff multi_aff::from_range() const\n{\n  auto res = isl_multi_aff_from_range(copy());\n  return manage(res);\n}\n\naff multi_aff::get_aff(int pos) const\n{\n  auto res = isl_multi_aff_get_aff(get(), pos);\n  return manage(res);\n}\n\naff multi_aff::get_at(int pos) const\n{\n  auto res = isl_multi_aff_get_at(get(), pos);\n  return manage(res);\n}\n\nmulti_val multi_aff::get_constant_multi_val() const\n{\n  auto res = isl_multi_aff_get_constant_multi_val(get());\n  return manage(res);\n}\n\nid multi_aff::get_dim_id(isl::dim type, unsigned int pos) const\n{\n  auto res = isl_multi_aff_get_dim_id(get(), static_cast<enum isl_dim_type>(type), pos);\n  return manage(res);\n}\n\nspace multi_aff::get_domain_space() const\n{\n  auto res = isl_multi_aff_get_domain_space(get());\n  return manage(res);\n}\n\naff_list multi_aff::get_list() const\n{\n  auto res = isl_multi_aff_get_list(get());\n  return manage(res);\n}\n\nspace multi_aff::get_space() const\n{\n  auto res = isl_multi_aff_get_space(get());\n  return manage(res);\n}\n\nid multi_aff::get_tuple_id(isl::dim type) const\n{\n  auto res = isl_multi_aff_get_tuple_id(get(), static_cast<enum isl_dim_type>(type));\n  return manage(res);\n}\n\nstd::string multi_aff::get_tuple_name(isl::dim type) const\n{\n  auto res = isl_multi_aff_get_tuple_name(get(), static_cast<enum isl_dim_type>(type));\n  std::string tmp(res);\n  return tmp;\n}\n\nmulti_aff multi_aff::gist(set context) const\n{\n  auto res = isl_multi_aff_gist(copy(), context.release());\n  return manage(res);\n}\n\nmulti_aff multi_aff::gist_params(set context) const\n{\n  auto res = isl_multi_aff_gist_params(copy(), context.release());\n  return manage(res);\n}\n\nboolean multi_aff::has_tuple_id(isl::dim type) const\n{\n  auto res = isl_multi_aff_has_tuple_id(get(), static_cast<enum isl_dim_type>(type));\n  return manage(res);\n}\n\nmulti_aff multi_aff::identity(space space)\n{\n  auto res = isl_multi_aff_identity(space.release());\n  return manage(res);\n}\n\nmulti_aff multi_aff::identity() const\n{\n  auto res = isl_multi_aff_identity_multi_aff(copy());\n  return manage(res);\n}\n\nmulti_aff multi_aff::identity_on_domain(space space)\n{\n  auto res = isl_multi_aff_identity_on_domain_space(space.release());\n  return manage(res);\n}\n\nmulti_aff multi_aff::insert_dims(isl::dim type, unsigned int first, unsigned int n) const\n{\n  auto res = isl_multi_aff_insert_dims(copy(), static_cast<enum isl_dim_type>(type), first, n);\n  return manage(res);\n}\n\nmulti_aff multi_aff::insert_domain(space domain) const\n{\n  auto res = isl_multi_aff_insert_domain(copy(), domain.release());\n  return manage(res);\n}\n\nboolean multi_aff::involves_dims(isl::dim type, unsigned int first, unsigned int n) const\n{\n  auto res = isl_multi_aff_involves_dims(get(), static_cast<enum isl_dim_type>(type), first, n);\n  return manage(res);\n}\n\nboolean multi_aff::involves_locals() const\n{\n  auto res = isl_multi_aff_involves_locals(get());\n  return manage(res);\n}\n\nboolean multi_aff::involves_nan() const\n{\n  auto res = isl_multi_aff_involves_nan(get());\n  return manage(res);\n}\n\nset multi_aff::lex_ge_set(multi_aff ma2) const\n{\n  auto res = isl_multi_aff_lex_ge_set(copy(), ma2.release());\n  return manage(res);\n}\n\nset multi_aff::lex_gt_set(multi_aff ma2) const\n{\n  auto res = isl_multi_aff_lex_gt_set(copy(), ma2.release());\n  return manage(res);\n}\n\nset multi_aff::lex_le_set(multi_aff ma2) const\n{\n  auto res = isl_multi_aff_lex_le_set(copy(), ma2.release());\n  return manage(res);\n}\n\nset multi_aff::lex_lt_set(multi_aff ma2) const\n{\n  auto res = isl_multi_aff_lex_lt_set(copy(), ma2.release());\n  return manage(res);\n}\n\nmulti_aff multi_aff::mod_multi_val(multi_val mv) const\n{\n  auto res = isl_multi_aff_mod_multi_val(copy(), mv.release());\n  return manage(res);\n}\n\nmulti_aff multi_aff::move_dims(isl::dim dst_type, unsigned int dst_pos, isl::dim src_type, unsigned int src_pos, unsigned int n) const\n{\n  auto res = isl_multi_aff_move_dims(copy(), static_cast<enum isl_dim_type>(dst_type), dst_pos, static_cast<enum isl_dim_type>(src_type), src_pos, n);\n  return manage(res);\n}\n\nmulti_aff multi_aff::multi_val_on_space(space space, multi_val mv)\n{\n  auto res = isl_multi_aff_multi_val_on_space(space.release(), mv.release());\n  return manage(res);\n}\n\nmulti_aff multi_aff::neg() const\n{\n  auto res = isl_multi_aff_neg(copy());\n  return manage(res);\n}\n\nint multi_aff::plain_cmp(const multi_aff &multi2) const\n{\n  auto res = isl_multi_aff_plain_cmp(get(), multi2.get());\n  return res;\n}\n\nboolean multi_aff::plain_is_equal(const multi_aff &multi2) const\n{\n  auto res = isl_multi_aff_plain_is_equal(get(), multi2.get());\n  return manage(res);\n}\n\nmulti_aff multi_aff::product(multi_aff multi2) const\n{\n  auto res = isl_multi_aff_product(copy(), multi2.release());\n  return manage(res);\n}\n\nmulti_aff multi_aff::project_domain_on_params() const\n{\n  auto res = isl_multi_aff_project_domain_on_params(copy());\n  return manage(res);\n}\n\nmulti_aff multi_aff::project_out_map(space space, isl::dim type, unsigned int first, unsigned int n)\n{\n  auto res = isl_multi_aff_project_out_map(space.release(), static_cast<enum isl_dim_type>(type), first, n);\n  return manage(res);\n}\n\nmulti_aff multi_aff::pullback(multi_aff ma2) const\n{\n  auto res = isl_multi_aff_pullback_multi_aff(copy(), ma2.release());\n  return manage(res);\n}\n\nmulti_aff multi_aff::range_factor_domain() const\n{\n  auto res = isl_multi_aff_range_factor_domain(copy());\n  return manage(res);\n}\n\nmulti_aff multi_aff::range_factor_range() const\n{\n  auto res = isl_multi_aff_range_factor_range(copy());\n  return manage(res);\n}\n\nboolean multi_aff::range_is_wrapping() const\n{\n  auto res = isl_multi_aff_range_is_wrapping(get());\n  return manage(res);\n}\n\nmulti_aff multi_aff::range_map(space space)\n{\n  auto res = isl_multi_aff_range_map(space.release());\n  return manage(res);\n}\n\nmulti_aff multi_aff::range_product(multi_aff multi2) const\n{\n  auto res = isl_multi_aff_range_product(copy(), multi2.release());\n  return manage(res);\n}\n\nmulti_aff multi_aff::range_splice(unsigned int pos, multi_aff multi2) const\n{\n  auto res = isl_multi_aff_range_splice(copy(), pos, multi2.release());\n  return manage(res);\n}\n\nmulti_aff multi_aff::reset_tuple_id(isl::dim type) const\n{\n  auto res = isl_multi_aff_reset_tuple_id(copy(), static_cast<enum isl_dim_type>(type));\n  return manage(res);\n}\n\nmulti_aff multi_aff::reset_user() const\n{\n  auto res = isl_multi_aff_reset_user(copy());\n  return manage(res);\n}\n\nmulti_aff multi_aff::scale(multi_val mv) const\n{\n  auto res = isl_multi_aff_scale_multi_val(copy(), mv.release());\n  return manage(res);\n}\n\nmulti_aff multi_aff::scale(val v) const\n{\n  auto res = isl_multi_aff_scale_val(copy(), v.release());\n  return manage(res);\n}\n\nmulti_aff multi_aff::scale_down(multi_val mv) const\n{\n  auto res = isl_multi_aff_scale_down_multi_val(copy(), mv.release());\n  return manage(res);\n}\n\nmulti_aff multi_aff::scale_down(val v) const\n{\n  auto res = isl_multi_aff_scale_down_val(copy(), v.release());\n  return manage(res);\n}\n\nmulti_aff multi_aff::set_aff(int pos, aff el) const\n{\n  auto res = isl_multi_aff_set_aff(copy(), pos, el.release());\n  return manage(res);\n}\n\nmulti_aff multi_aff::set_at(int pos, aff el) const\n{\n  auto res = isl_multi_aff_set_at(copy(), pos, el.release());\n  return manage(res);\n}\n\nmulti_aff multi_aff::set_dim_id(isl::dim type, unsigned int pos, id id) const\n{\n  auto res = isl_multi_aff_set_dim_id(copy(), static_cast<enum isl_dim_type>(type), pos, id.release());\n  return manage(res);\n}\n\nmulti_aff multi_aff::set_tuple_id(isl::dim type, id id) const\n{\n  auto res = isl_multi_aff_set_tuple_id(copy(), static_cast<enum isl_dim_type>(type), id.release());\n  return manage(res);\n}\n\nmulti_aff multi_aff::set_tuple_name(isl::dim type, const std::string &s) const\n{\n  auto res = isl_multi_aff_set_tuple_name(copy(), static_cast<enum isl_dim_type>(type), s.c_str());\n  return manage(res);\n}\n\nisl_size multi_aff::size() const\n{\n  auto res = isl_multi_aff_size(get());\n  return res;\n}\n\nmulti_aff multi_aff::splice(unsigned int in_pos, unsigned int out_pos, multi_aff multi2) const\n{\n  auto res = isl_multi_aff_splice(copy(), in_pos, out_pos, multi2.release());\n  return manage(res);\n}\n\nmulti_aff multi_aff::sub(multi_aff multi2) const\n{\n  auto res = isl_multi_aff_sub(copy(), multi2.release());\n  return manage(res);\n}\n\nmulti_aff multi_aff::unbind_params_insert_domain(multi_id domain) const\n{\n  auto res = isl_multi_aff_unbind_params_insert_domain(copy(), domain.release());\n  return manage(res);\n}\n\nmulti_aff multi_aff::zero(space space)\n{\n  auto res = isl_multi_aff_zero(space.release());\n  return manage(res);\n}\n\n// implementations for isl::multi_id\nmulti_id manage(__isl_take isl_multi_id *ptr) {\n  return multi_id(ptr);\n}\nmulti_id manage_copy(__isl_keep isl_multi_id *ptr) {\n  ptr = isl_multi_id_copy(ptr);\n  return multi_id(ptr);\n}\n\nmulti_id::multi_id()\n    : ptr(nullptr) {}\n\nmulti_id::multi_id(const multi_id &obj)\n    : ptr(nullptr)\n{\n  ptr = obj.copy();\n}\nmulti_id::multi_id(std::nullptr_t)\n    : ptr(nullptr) {}\n\n\nmulti_id::multi_id(__isl_take isl_multi_id *ptr)\n    : ptr(ptr) {}\n\nmulti_id::multi_id(space space, id_list list)\n{\n  auto res = isl_multi_id_from_id_list(space.release(), list.release());\n  ptr = res;\n}\nmulti_id::multi_id(ctx ctx, const std::string &str)\n{\n  auto res = isl_multi_id_read_from_str(ctx.release(), str.c_str());\n  ptr = res;\n}\n\nmulti_id &multi_id::operator=(multi_id obj) {\n  std::swap(this->ptr, obj.ptr);\n  return *this;\n}\n\nmulti_id::~multi_id() {\n  if (ptr)\n    isl_multi_id_free(ptr);\n}\n\n__isl_give isl_multi_id *multi_id::copy() const & {\n  return isl_multi_id_copy(ptr);\n}\n\n__isl_keep isl_multi_id *multi_id::get() const {\n  return ptr;\n}\n\n__isl_give isl_multi_id *multi_id::release() {\n  isl_multi_id *tmp = ptr;\n  ptr = nullptr;\n  return tmp;\n}\n\nbool multi_id::is_null() const {\n  return ptr == nullptr;\n}\nmulti_id::operator bool() const {\n  return !is_null();\n}\n\n\nctx multi_id::get_ctx() const {\n  return ctx(isl_multi_id_get_ctx(ptr));\n}\nstd::string multi_id::to_str() const {\n  char *Tmp = isl_multi_id_to_str(get());\n  if (!Tmp)\n    return \"\";\n  std::string S(Tmp);\n  free(Tmp);\n  return S;\n}\n\n\nvoid multi_id::dump() const {\n  isl_multi_id_dump(get());\n}\n\n\nmulti_id multi_id::align_params(space model) const\n{\n  auto res = isl_multi_id_align_params(copy(), model.release());\n  return manage(res);\n}\n\nmulti_id multi_id::factor_range() const\n{\n  auto res = isl_multi_id_factor_range(copy());\n  return manage(res);\n}\n\nmulti_id multi_id::flat_range_product(multi_id multi2) const\n{\n  auto res = isl_multi_id_flat_range_product(copy(), multi2.release());\n  return manage(res);\n}\n\nmulti_id multi_id::flatten_range() const\n{\n  auto res = isl_multi_id_flatten_range(copy());\n  return manage(res);\n}\n\nmulti_id multi_id::from_range() const\n{\n  auto res = isl_multi_id_from_range(copy());\n  return manage(res);\n}\n\nid multi_id::get_at(int pos) const\n{\n  auto res = isl_multi_id_get_at(get(), pos);\n  return manage(res);\n}\n\nspace multi_id::get_domain_space() const\n{\n  auto res = isl_multi_id_get_domain_space(get());\n  return manage(res);\n}\n\nid multi_id::get_id(int pos) const\n{\n  auto res = isl_multi_id_get_id(get(), pos);\n  return manage(res);\n}\n\nid_list multi_id::get_list() const\n{\n  auto res = isl_multi_id_get_list(get());\n  return manage(res);\n}\n\nspace multi_id::get_space() const\n{\n  auto res = isl_multi_id_get_space(get());\n  return manage(res);\n}\n\nboolean multi_id::plain_is_equal(const multi_id &multi2) const\n{\n  auto res = isl_multi_id_plain_is_equal(get(), multi2.get());\n  return manage(res);\n}\n\nmulti_id multi_id::range_factor_domain() const\n{\n  auto res = isl_multi_id_range_factor_domain(copy());\n  return manage(res);\n}\n\nmulti_id multi_id::range_factor_range() const\n{\n  auto res = isl_multi_id_range_factor_range(copy());\n  return manage(res);\n}\n\nboolean multi_id::range_is_wrapping() const\n{\n  auto res = isl_multi_id_range_is_wrapping(get());\n  return manage(res);\n}\n\nmulti_id multi_id::range_product(multi_id multi2) const\n{\n  auto res = isl_multi_id_range_product(copy(), multi2.release());\n  return manage(res);\n}\n\nmulti_id multi_id::range_splice(unsigned int pos, multi_id multi2) const\n{\n  auto res = isl_multi_id_range_splice(copy(), pos, multi2.release());\n  return manage(res);\n}\n\nmulti_id multi_id::reset_user() const\n{\n  auto res = isl_multi_id_reset_user(copy());\n  return manage(res);\n}\n\nmulti_id multi_id::set_at(int pos, id el) const\n{\n  auto res = isl_multi_id_set_at(copy(), pos, el.release());\n  return manage(res);\n}\n\nmulti_id multi_id::set_id(int pos, id el) const\n{\n  auto res = isl_multi_id_set_id(copy(), pos, el.release());\n  return manage(res);\n}\n\nisl_size multi_id::size() const\n{\n  auto res = isl_multi_id_size(get());\n  return res;\n}\n\n// implementations for isl::multi_pw_aff\nmulti_pw_aff manage(__isl_take isl_multi_pw_aff *ptr) {\n  return multi_pw_aff(ptr);\n}\nmulti_pw_aff manage_copy(__isl_keep isl_multi_pw_aff *ptr) {\n  ptr = isl_multi_pw_aff_copy(ptr);\n  return multi_pw_aff(ptr);\n}\n\nmulti_pw_aff::multi_pw_aff()\n    : ptr(nullptr) {}\n\nmulti_pw_aff::multi_pw_aff(const multi_pw_aff &obj)\n    : ptr(nullptr)\n{\n  ptr = obj.copy();\n}\nmulti_pw_aff::multi_pw_aff(std::nullptr_t)\n    : ptr(nullptr) {}\n\n\nmulti_pw_aff::multi_pw_aff(__isl_take isl_multi_pw_aff *ptr)\n    : ptr(ptr) {}\n\nmulti_pw_aff::multi_pw_aff(aff aff)\n{\n  auto res = isl_multi_pw_aff_from_aff(aff.release());\n  ptr = res;\n}\nmulti_pw_aff::multi_pw_aff(multi_aff ma)\n{\n  auto res = isl_multi_pw_aff_from_multi_aff(ma.release());\n  ptr = res;\n}\nmulti_pw_aff::multi_pw_aff(pw_aff pa)\n{\n  auto res = isl_multi_pw_aff_from_pw_aff(pa.release());\n  ptr = res;\n}\nmulti_pw_aff::multi_pw_aff(space space, pw_aff_list list)\n{\n  auto res = isl_multi_pw_aff_from_pw_aff_list(space.release(), list.release());\n  ptr = res;\n}\nmulti_pw_aff::multi_pw_aff(pw_multi_aff pma)\n{\n  auto res = isl_multi_pw_aff_from_pw_multi_aff(pma.release());\n  ptr = res;\n}\nmulti_pw_aff::multi_pw_aff(ctx ctx, const std::string &str)\n{\n  auto res = isl_multi_pw_aff_read_from_str(ctx.release(), str.c_str());\n  ptr = res;\n}\n\nmulti_pw_aff &multi_pw_aff::operator=(multi_pw_aff obj) {\n  std::swap(this->ptr, obj.ptr);\n  return *this;\n}\n\nmulti_pw_aff::~multi_pw_aff() {\n  if (ptr)\n    isl_multi_pw_aff_free(ptr);\n}\n\n__isl_give isl_multi_pw_aff *multi_pw_aff::copy() const & {\n  return isl_multi_pw_aff_copy(ptr);\n}\n\n__isl_keep isl_multi_pw_aff *multi_pw_aff::get() const {\n  return ptr;\n}\n\n__isl_give isl_multi_pw_aff *multi_pw_aff::release() {\n  isl_multi_pw_aff *tmp = ptr;\n  ptr = nullptr;\n  return tmp;\n}\n\nbool multi_pw_aff::is_null() const {\n  return ptr == nullptr;\n}\nmulti_pw_aff::operator bool() const {\n  return !is_null();\n}\n\n\nctx multi_pw_aff::get_ctx() const {\n  return ctx(isl_multi_pw_aff_get_ctx(ptr));\n}\nstd::string multi_pw_aff::to_str() const {\n  char *Tmp = isl_multi_pw_aff_to_str(get());\n  if (!Tmp)\n    return \"\";\n  std::string S(Tmp);\n  free(Tmp);\n  return S;\n}\n\n\nvoid multi_pw_aff::dump() const {\n  isl_multi_pw_aff_dump(get());\n}\n\n\nmulti_pw_aff multi_pw_aff::add(multi_pw_aff multi2) const\n{\n  auto res = isl_multi_pw_aff_add(copy(), multi2.release());\n  return manage(res);\n}\n\nmulti_pw_aff multi_pw_aff::add_constant(multi_val mv) const\n{\n  auto res = isl_multi_pw_aff_add_constant_multi_val(copy(), mv.release());\n  return manage(res);\n}\n\nmulti_pw_aff multi_pw_aff::add_constant(val v) const\n{\n  auto res = isl_multi_pw_aff_add_constant_val(copy(), v.release());\n  return manage(res);\n}\n\nmulti_pw_aff multi_pw_aff::add_dims(isl::dim type, unsigned int n) const\n{\n  auto res = isl_multi_pw_aff_add_dims(copy(), static_cast<enum isl_dim_type>(type), n);\n  return manage(res);\n}\n\nmulti_pw_aff multi_pw_aff::align_params(space model) const\n{\n  auto res = isl_multi_pw_aff_align_params(copy(), model.release());\n  return manage(res);\n}\n\nset multi_pw_aff::bind(multi_id tuple) const\n{\n  auto res = isl_multi_pw_aff_bind(copy(), tuple.release());\n  return manage(res);\n}\n\nmulti_pw_aff multi_pw_aff::bind_domain(multi_id tuple) const\n{\n  auto res = isl_multi_pw_aff_bind_domain(copy(), tuple.release());\n  return manage(res);\n}\n\nmulti_pw_aff multi_pw_aff::bind_domain_wrapped_domain(multi_id tuple) const\n{\n  auto res = isl_multi_pw_aff_bind_domain_wrapped_domain(copy(), tuple.release());\n  return manage(res);\n}\n\nmulti_pw_aff multi_pw_aff::coalesce() const\n{\n  auto res = isl_multi_pw_aff_coalesce(copy());\n  return manage(res);\n}\n\nisl_size multi_pw_aff::dim(isl::dim type) const\n{\n  auto res = isl_multi_pw_aff_dim(get(), static_cast<enum isl_dim_type>(type));\n  return res;\n}\n\nset multi_pw_aff::domain() const\n{\n  auto res = isl_multi_pw_aff_domain(copy());\n  return manage(res);\n}\n\nmulti_pw_aff multi_pw_aff::drop_dims(isl::dim type, unsigned int first, unsigned int n) const\n{\n  auto res = isl_multi_pw_aff_drop_dims(copy(), static_cast<enum isl_dim_type>(type), first, n);\n  return manage(res);\n}\n\nmap multi_pw_aff::eq_map(multi_pw_aff mpa2) const\n{\n  auto res = isl_multi_pw_aff_eq_map(copy(), mpa2.release());\n  return manage(res);\n}\n\nmulti_pw_aff multi_pw_aff::factor_range() const\n{\n  auto res = isl_multi_pw_aff_factor_range(copy());\n  return manage(res);\n}\n\nint multi_pw_aff::find_dim_by_id(isl::dim type, const id &id) const\n{\n  auto res = isl_multi_pw_aff_find_dim_by_id(get(), static_cast<enum isl_dim_type>(type), id.get());\n  return res;\n}\n\nint multi_pw_aff::find_dim_by_name(isl::dim type, const std::string &name) const\n{\n  auto res = isl_multi_pw_aff_find_dim_by_name(get(), static_cast<enum isl_dim_type>(type), name.c_str());\n  return res;\n}\n\nmulti_pw_aff multi_pw_aff::flat_range_product(multi_pw_aff multi2) const\n{\n  auto res = isl_multi_pw_aff_flat_range_product(copy(), multi2.release());\n  return manage(res);\n}\n\nmulti_pw_aff multi_pw_aff::flatten_range() const\n{\n  auto res = isl_multi_pw_aff_flatten_range(copy());\n  return manage(res);\n}\n\nmulti_pw_aff multi_pw_aff::from_range() const\n{\n  auto res = isl_multi_pw_aff_from_range(copy());\n  return manage(res);\n}\n\npw_aff multi_pw_aff::get_at(int pos) const\n{\n  auto res = isl_multi_pw_aff_get_at(get(), pos);\n  return manage(res);\n}\n\nid multi_pw_aff::get_dim_id(isl::dim type, unsigned int pos) const\n{\n  auto res = isl_multi_pw_aff_get_dim_id(get(), static_cast<enum isl_dim_type>(type), pos);\n  return manage(res);\n}\n\nspace multi_pw_aff::get_domain_space() const\n{\n  auto res = isl_multi_pw_aff_get_domain_space(get());\n  return manage(res);\n}\n\nuint32_t multi_pw_aff::get_hash() const\n{\n  auto res = isl_multi_pw_aff_get_hash(get());\n  return res;\n}\n\npw_aff_list multi_pw_aff::get_list() const\n{\n  auto res = isl_multi_pw_aff_get_list(get());\n  return manage(res);\n}\n\npw_aff multi_pw_aff::get_pw_aff(int pos) const\n{\n  auto res = isl_multi_pw_aff_get_pw_aff(get(), pos);\n  return manage(res);\n}\n\nspace multi_pw_aff::get_space() const\n{\n  auto res = isl_multi_pw_aff_get_space(get());\n  return manage(res);\n}\n\nid multi_pw_aff::get_tuple_id(isl::dim type) const\n{\n  auto res = isl_multi_pw_aff_get_tuple_id(get(), static_cast<enum isl_dim_type>(type));\n  return manage(res);\n}\n\nstd::string multi_pw_aff::get_tuple_name(isl::dim type) const\n{\n  auto res = isl_multi_pw_aff_get_tuple_name(get(), static_cast<enum isl_dim_type>(type));\n  std::string tmp(res);\n  return tmp;\n}\n\nmulti_pw_aff multi_pw_aff::gist(set set) const\n{\n  auto res = isl_multi_pw_aff_gist(copy(), set.release());\n  return manage(res);\n}\n\nmulti_pw_aff multi_pw_aff::gist_params(set set) const\n{\n  auto res = isl_multi_pw_aff_gist_params(copy(), set.release());\n  return manage(res);\n}\n\nboolean multi_pw_aff::has_tuple_id(isl::dim type) const\n{\n  auto res = isl_multi_pw_aff_has_tuple_id(get(), static_cast<enum isl_dim_type>(type));\n  return manage(res);\n}\n\nmulti_pw_aff multi_pw_aff::identity(space space)\n{\n  auto res = isl_multi_pw_aff_identity(space.release());\n  return manage(res);\n}\n\nmulti_pw_aff multi_pw_aff::identity() const\n{\n  auto res = isl_multi_pw_aff_identity_multi_pw_aff(copy());\n  return manage(res);\n}\n\nmulti_pw_aff multi_pw_aff::identity_on_domain(space space)\n{\n  auto res = isl_multi_pw_aff_identity_on_domain_space(space.release());\n  return manage(res);\n}\n\nmulti_pw_aff multi_pw_aff::insert_dims(isl::dim type, unsigned int first, unsigned int n) const\n{\n  auto res = isl_multi_pw_aff_insert_dims(copy(), static_cast<enum isl_dim_type>(type), first, n);\n  return manage(res);\n}\n\nmulti_pw_aff multi_pw_aff::insert_domain(space domain) const\n{\n  auto res = isl_multi_pw_aff_insert_domain(copy(), domain.release());\n  return manage(res);\n}\n\nmulti_pw_aff multi_pw_aff::intersect_domain(set domain) const\n{\n  auto res = isl_multi_pw_aff_intersect_domain(copy(), domain.release());\n  return manage(res);\n}\n\nmulti_pw_aff multi_pw_aff::intersect_params(set set) const\n{\n  auto res = isl_multi_pw_aff_intersect_params(copy(), set.release());\n  return manage(res);\n}\n\nboolean multi_pw_aff::involves_dims(isl::dim type, unsigned int first, unsigned int n) const\n{\n  auto res = isl_multi_pw_aff_involves_dims(get(), static_cast<enum isl_dim_type>(type), first, n);\n  return manage(res);\n}\n\nboolean multi_pw_aff::involves_nan() const\n{\n  auto res = isl_multi_pw_aff_involves_nan(get());\n  return manage(res);\n}\n\nboolean multi_pw_aff::involves_param(const id &id) const\n{\n  auto res = isl_multi_pw_aff_involves_param_id(get(), id.get());\n  return manage(res);\n}\n\nboolean multi_pw_aff::involves_param(const id_list &list) const\n{\n  auto res = isl_multi_pw_aff_involves_param_id_list(get(), list.get());\n  return manage(res);\n}\n\nboolean multi_pw_aff::is_cst() const\n{\n  auto res = isl_multi_pw_aff_is_cst(get());\n  return manage(res);\n}\n\nboolean multi_pw_aff::is_equal(const multi_pw_aff &mpa2) const\n{\n  auto res = isl_multi_pw_aff_is_equal(get(), mpa2.get());\n  return manage(res);\n}\n\nmap multi_pw_aff::lex_ge_map(multi_pw_aff mpa2) const\n{\n  auto res = isl_multi_pw_aff_lex_ge_map(copy(), mpa2.release());\n  return manage(res);\n}\n\nmap multi_pw_aff::lex_gt_map(multi_pw_aff mpa2) const\n{\n  auto res = isl_multi_pw_aff_lex_gt_map(copy(), mpa2.release());\n  return manage(res);\n}\n\nmap multi_pw_aff::lex_le_map(multi_pw_aff mpa2) const\n{\n  auto res = isl_multi_pw_aff_lex_le_map(copy(), mpa2.release());\n  return manage(res);\n}\n\nmap multi_pw_aff::lex_lt_map(multi_pw_aff mpa2) const\n{\n  auto res = isl_multi_pw_aff_lex_lt_map(copy(), mpa2.release());\n  return manage(res);\n}\n\nmulti_pw_aff multi_pw_aff::max(multi_pw_aff multi2) const\n{\n  auto res = isl_multi_pw_aff_max(copy(), multi2.release());\n  return manage(res);\n}\n\nmulti_val multi_pw_aff::max_multi_val() const\n{\n  auto res = isl_multi_pw_aff_max_multi_val(copy());\n  return manage(res);\n}\n\nmulti_pw_aff multi_pw_aff::min(multi_pw_aff multi2) const\n{\n  auto res = isl_multi_pw_aff_min(copy(), multi2.release());\n  return manage(res);\n}\n\nmulti_val multi_pw_aff::min_multi_val() const\n{\n  auto res = isl_multi_pw_aff_min_multi_val(copy());\n  return manage(res);\n}\n\nmulti_pw_aff multi_pw_aff::mod_multi_val(multi_val mv) const\n{\n  auto res = isl_multi_pw_aff_mod_multi_val(copy(), mv.release());\n  return manage(res);\n}\n\nmulti_pw_aff multi_pw_aff::move_dims(isl::dim dst_type, unsigned int dst_pos, isl::dim src_type, unsigned int src_pos, unsigned int n) const\n{\n  auto res = isl_multi_pw_aff_move_dims(copy(), static_cast<enum isl_dim_type>(dst_type), dst_pos, static_cast<enum isl_dim_type>(src_type), src_pos, n);\n  return manage(res);\n}\n\nmulti_pw_aff multi_pw_aff::neg() const\n{\n  auto res = isl_multi_pw_aff_neg(copy());\n  return manage(res);\n}\n\nboolean multi_pw_aff::plain_is_equal(const multi_pw_aff &multi2) const\n{\n  auto res = isl_multi_pw_aff_plain_is_equal(get(), multi2.get());\n  return manage(res);\n}\n\nmulti_pw_aff multi_pw_aff::product(multi_pw_aff multi2) const\n{\n  auto res = isl_multi_pw_aff_product(copy(), multi2.release());\n  return manage(res);\n}\n\nmulti_pw_aff multi_pw_aff::project_domain_on_params() const\n{\n  auto res = isl_multi_pw_aff_project_domain_on_params(copy());\n  return manage(res);\n}\n\nmulti_pw_aff multi_pw_aff::pullback(multi_aff ma) const\n{\n  auto res = isl_multi_pw_aff_pullback_multi_aff(copy(), ma.release());\n  return manage(res);\n}\n\nmulti_pw_aff multi_pw_aff::pullback(multi_pw_aff mpa2) const\n{\n  auto res = isl_multi_pw_aff_pullback_multi_pw_aff(copy(), mpa2.release());\n  return manage(res);\n}\n\nmulti_pw_aff multi_pw_aff::pullback(pw_multi_aff pma) const\n{\n  auto res = isl_multi_pw_aff_pullback_pw_multi_aff(copy(), pma.release());\n  return manage(res);\n}\n\nmulti_pw_aff multi_pw_aff::range_factor_domain() const\n{\n  auto res = isl_multi_pw_aff_range_factor_domain(copy());\n  return manage(res);\n}\n\nmulti_pw_aff multi_pw_aff::range_factor_range() const\n{\n  auto res = isl_multi_pw_aff_range_factor_range(copy());\n  return manage(res);\n}\n\nboolean multi_pw_aff::range_is_wrapping() const\n{\n  auto res = isl_multi_pw_aff_range_is_wrapping(get());\n  return manage(res);\n}\n\nmulti_pw_aff multi_pw_aff::range_product(multi_pw_aff multi2) const\n{\n  auto res = isl_multi_pw_aff_range_product(copy(), multi2.release());\n  return manage(res);\n}\n\nmulti_pw_aff multi_pw_aff::range_splice(unsigned int pos, multi_pw_aff multi2) const\n{\n  auto res = isl_multi_pw_aff_range_splice(copy(), pos, multi2.release());\n  return manage(res);\n}\n\nmulti_pw_aff multi_pw_aff::reset_tuple_id(isl::dim type) const\n{\n  auto res = isl_multi_pw_aff_reset_tuple_id(copy(), static_cast<enum isl_dim_type>(type));\n  return manage(res);\n}\n\nmulti_pw_aff multi_pw_aff::reset_user() const\n{\n  auto res = isl_multi_pw_aff_reset_user(copy());\n  return manage(res);\n}\n\nmulti_pw_aff multi_pw_aff::scale(multi_val mv) const\n{\n  auto res = isl_multi_pw_aff_scale_multi_val(copy(), mv.release());\n  return manage(res);\n}\n\nmulti_pw_aff multi_pw_aff::scale(val v) const\n{\n  auto res = isl_multi_pw_aff_scale_val(copy(), v.release());\n  return manage(res);\n}\n\nmulti_pw_aff multi_pw_aff::scale_down(multi_val mv) const\n{\n  auto res = isl_multi_pw_aff_scale_down_multi_val(copy(), mv.release());\n  return manage(res);\n}\n\nmulti_pw_aff multi_pw_aff::scale_down(val v) const\n{\n  auto res = isl_multi_pw_aff_scale_down_val(copy(), v.release());\n  return manage(res);\n}\n\nmulti_pw_aff multi_pw_aff::set_at(int pos, pw_aff el) const\n{\n  auto res = isl_multi_pw_aff_set_at(copy(), pos, el.release());\n  return manage(res);\n}\n\nmulti_pw_aff multi_pw_aff::set_dim_id(isl::dim type, unsigned int pos, id id) const\n{\n  auto res = isl_multi_pw_aff_set_dim_id(copy(), static_cast<enum isl_dim_type>(type), pos, id.release());\n  return manage(res);\n}\n\nmulti_pw_aff multi_pw_aff::set_pw_aff(int pos, pw_aff el) const\n{\n  auto res = isl_multi_pw_aff_set_pw_aff(copy(), pos, el.release());\n  return manage(res);\n}\n\nmulti_pw_aff multi_pw_aff::set_tuple_id(isl::dim type, id id) const\n{\n  auto res = isl_multi_pw_aff_set_tuple_id(copy(), static_cast<enum isl_dim_type>(type), id.release());\n  return manage(res);\n}\n\nmulti_pw_aff multi_pw_aff::set_tuple_name(isl::dim type, const std::string &s) const\n{\n  auto res = isl_multi_pw_aff_set_tuple_name(copy(), static_cast<enum isl_dim_type>(type), s.c_str());\n  return manage(res);\n}\n\nisl_size multi_pw_aff::size() const\n{\n  auto res = isl_multi_pw_aff_size(get());\n  return res;\n}\n\nmulti_pw_aff multi_pw_aff::splice(unsigned int in_pos, unsigned int out_pos, multi_pw_aff multi2) const\n{\n  auto res = isl_multi_pw_aff_splice(copy(), in_pos, out_pos, multi2.release());\n  return manage(res);\n}\n\nmulti_pw_aff multi_pw_aff::sub(multi_pw_aff multi2) const\n{\n  auto res = isl_multi_pw_aff_sub(copy(), multi2.release());\n  return manage(res);\n}\n\nmulti_pw_aff multi_pw_aff::unbind_params_insert_domain(multi_id domain) const\n{\n  auto res = isl_multi_pw_aff_unbind_params_insert_domain(copy(), domain.release());\n  return manage(res);\n}\n\nmulti_pw_aff multi_pw_aff::union_add(multi_pw_aff mpa2) const\n{\n  auto res = isl_multi_pw_aff_union_add(copy(), mpa2.release());\n  return manage(res);\n}\n\nmulti_pw_aff multi_pw_aff::zero(space space)\n{\n  auto res = isl_multi_pw_aff_zero(space.release());\n  return manage(res);\n}\n\n// implementations for isl::multi_union_pw_aff\nmulti_union_pw_aff manage(__isl_take isl_multi_union_pw_aff *ptr) {\n  return multi_union_pw_aff(ptr);\n}\nmulti_union_pw_aff manage_copy(__isl_keep isl_multi_union_pw_aff *ptr) {\n  ptr = isl_multi_union_pw_aff_copy(ptr);\n  return multi_union_pw_aff(ptr);\n}\n\nmulti_union_pw_aff::multi_union_pw_aff()\n    : ptr(nullptr) {}\n\nmulti_union_pw_aff::multi_union_pw_aff(const multi_union_pw_aff &obj)\n    : ptr(nullptr)\n{\n  ptr = obj.copy();\n}\nmulti_union_pw_aff::multi_union_pw_aff(std::nullptr_t)\n    : ptr(nullptr) {}\n\n\nmulti_union_pw_aff::multi_union_pw_aff(__isl_take isl_multi_union_pw_aff *ptr)\n    : ptr(ptr) {}\n\nmulti_union_pw_aff::multi_union_pw_aff(multi_pw_aff mpa)\n{\n  auto res = isl_multi_union_pw_aff_from_multi_pw_aff(mpa.release());\n  ptr = res;\n}\nmulti_union_pw_aff::multi_union_pw_aff(union_pw_aff upa)\n{\n  auto res = isl_multi_union_pw_aff_from_union_pw_aff(upa.release());\n  ptr = res;\n}\nmulti_union_pw_aff::multi_union_pw_aff(space space, union_pw_aff_list list)\n{\n  auto res = isl_multi_union_pw_aff_from_union_pw_aff_list(space.release(), list.release());\n  ptr = res;\n}\nmulti_union_pw_aff::multi_union_pw_aff(union_pw_multi_aff upma)\n{\n  auto res = isl_multi_union_pw_aff_from_union_pw_multi_aff(upma.release());\n  ptr = res;\n}\nmulti_union_pw_aff::multi_union_pw_aff(ctx ctx, const std::string &str)\n{\n  auto res = isl_multi_union_pw_aff_read_from_str(ctx.release(), str.c_str());\n  ptr = res;\n}\n\nmulti_union_pw_aff &multi_union_pw_aff::operator=(multi_union_pw_aff obj) {\n  std::swap(this->ptr, obj.ptr);\n  return *this;\n}\n\nmulti_union_pw_aff::~multi_union_pw_aff() {\n  if (ptr)\n    isl_multi_union_pw_aff_free(ptr);\n}\n\n__isl_give isl_multi_union_pw_aff *multi_union_pw_aff::copy() const & {\n  return isl_multi_union_pw_aff_copy(ptr);\n}\n\n__isl_keep isl_multi_union_pw_aff *multi_union_pw_aff::get() const {\n  return ptr;\n}\n\n__isl_give isl_multi_union_pw_aff *multi_union_pw_aff::release() {\n  isl_multi_union_pw_aff *tmp = ptr;\n  ptr = nullptr;\n  return tmp;\n}\n\nbool multi_union_pw_aff::is_null() const {\n  return ptr == nullptr;\n}\nmulti_union_pw_aff::operator bool() const {\n  return !is_null();\n}\n\n\nctx multi_union_pw_aff::get_ctx() const {\n  return ctx(isl_multi_union_pw_aff_get_ctx(ptr));\n}\nstd::string multi_union_pw_aff::to_str() const {\n  char *Tmp = isl_multi_union_pw_aff_to_str(get());\n  if (!Tmp)\n    return \"\";\n  std::string S(Tmp);\n  free(Tmp);\n  return S;\n}\n\n\nvoid multi_union_pw_aff::dump() const {\n  isl_multi_union_pw_aff_dump(get());\n}\n\n\nmulti_union_pw_aff multi_union_pw_aff::add(multi_union_pw_aff multi2) const\n{\n  auto res = isl_multi_union_pw_aff_add(copy(), multi2.release());\n  return manage(res);\n}\n\nmulti_union_pw_aff multi_union_pw_aff::align_params(space model) const\n{\n  auto res = isl_multi_union_pw_aff_align_params(copy(), model.release());\n  return manage(res);\n}\n\nunion_pw_aff multi_union_pw_aff::apply_aff(aff aff) const\n{\n  auto res = isl_multi_union_pw_aff_apply_aff(copy(), aff.release());\n  return manage(res);\n}\n\nunion_pw_aff multi_union_pw_aff::apply_pw_aff(pw_aff pa) const\n{\n  auto res = isl_multi_union_pw_aff_apply_pw_aff(copy(), pa.release());\n  return manage(res);\n}\n\nmulti_union_pw_aff multi_union_pw_aff::apply_pw_multi_aff(pw_multi_aff pma) const\n{\n  auto res = isl_multi_union_pw_aff_apply_pw_multi_aff(copy(), pma.release());\n  return manage(res);\n}\n\nunion_set multi_union_pw_aff::bind(multi_id tuple) const\n{\n  auto res = isl_multi_union_pw_aff_bind(copy(), tuple.release());\n  return manage(res);\n}\n\nmulti_union_pw_aff multi_union_pw_aff::coalesce() const\n{\n  auto res = isl_multi_union_pw_aff_coalesce(copy());\n  return manage(res);\n}\n\nisl_size multi_union_pw_aff::dim(isl::dim type) const\n{\n  auto res = isl_multi_union_pw_aff_dim(get(), static_cast<enum isl_dim_type>(type));\n  return res;\n}\n\nunion_set multi_union_pw_aff::domain() const\n{\n  auto res = isl_multi_union_pw_aff_domain(copy());\n  return manage(res);\n}\n\nmulti_union_pw_aff multi_union_pw_aff::drop_dims(isl::dim type, unsigned int first, unsigned int n) const\n{\n  auto res = isl_multi_union_pw_aff_drop_dims(copy(), static_cast<enum isl_dim_type>(type), first, n);\n  return manage(res);\n}\n\nmulti_pw_aff multi_union_pw_aff::extract_multi_pw_aff(space space) const\n{\n  auto res = isl_multi_union_pw_aff_extract_multi_pw_aff(get(), space.release());\n  return manage(res);\n}\n\nmulti_union_pw_aff multi_union_pw_aff::factor_range() const\n{\n  auto res = isl_multi_union_pw_aff_factor_range(copy());\n  return manage(res);\n}\n\nint multi_union_pw_aff::find_dim_by_id(isl::dim type, const id &id) const\n{\n  auto res = isl_multi_union_pw_aff_find_dim_by_id(get(), static_cast<enum isl_dim_type>(type), id.get());\n  return res;\n}\n\nint multi_union_pw_aff::find_dim_by_name(isl::dim type, const std::string &name) const\n{\n  auto res = isl_multi_union_pw_aff_find_dim_by_name(get(), static_cast<enum isl_dim_type>(type), name.c_str());\n  return res;\n}\n\nmulti_union_pw_aff multi_union_pw_aff::flat_range_product(multi_union_pw_aff multi2) const\n{\n  auto res = isl_multi_union_pw_aff_flat_range_product(copy(), multi2.release());\n  return manage(res);\n}\n\nmulti_union_pw_aff multi_union_pw_aff::flatten_range() const\n{\n  auto res = isl_multi_union_pw_aff_flatten_range(copy());\n  return manage(res);\n}\n\nmulti_union_pw_aff multi_union_pw_aff::floor() const\n{\n  auto res = isl_multi_union_pw_aff_floor(copy());\n  return manage(res);\n}\n\nmulti_union_pw_aff multi_union_pw_aff::from_multi_aff(multi_aff ma)\n{\n  auto res = isl_multi_union_pw_aff_from_multi_aff(ma.release());\n  return manage(res);\n}\n\nmulti_union_pw_aff multi_union_pw_aff::from_range() const\n{\n  auto res = isl_multi_union_pw_aff_from_range(copy());\n  return manage(res);\n}\n\nmulti_union_pw_aff multi_union_pw_aff::from_union_map(union_map umap)\n{\n  auto res = isl_multi_union_pw_aff_from_union_map(umap.release());\n  return manage(res);\n}\n\nunion_pw_aff multi_union_pw_aff::get_at(int pos) const\n{\n  auto res = isl_multi_union_pw_aff_get_at(get(), pos);\n  return manage(res);\n}\n\nid multi_union_pw_aff::get_dim_id(isl::dim type, unsigned int pos) const\n{\n  auto res = isl_multi_union_pw_aff_get_dim_id(get(), static_cast<enum isl_dim_type>(type), pos);\n  return manage(res);\n}\n\nspace multi_union_pw_aff::get_domain_space() const\n{\n  auto res = isl_multi_union_pw_aff_get_domain_space(get());\n  return manage(res);\n}\n\nunion_pw_aff_list multi_union_pw_aff::get_list() const\n{\n  auto res = isl_multi_union_pw_aff_get_list(get());\n  return manage(res);\n}\n\nspace multi_union_pw_aff::get_space() const\n{\n  auto res = isl_multi_union_pw_aff_get_space(get());\n  return manage(res);\n}\n\nid multi_union_pw_aff::get_tuple_id(isl::dim type) const\n{\n  auto res = isl_multi_union_pw_aff_get_tuple_id(get(), static_cast<enum isl_dim_type>(type));\n  return manage(res);\n}\n\nstd::string multi_union_pw_aff::get_tuple_name(isl::dim type) const\n{\n  auto res = isl_multi_union_pw_aff_get_tuple_name(get(), static_cast<enum isl_dim_type>(type));\n  std::string tmp(res);\n  return tmp;\n}\n\nunion_pw_aff multi_union_pw_aff::get_union_pw_aff(int pos) const\n{\n  auto res = isl_multi_union_pw_aff_get_union_pw_aff(get(), pos);\n  return manage(res);\n}\n\nmulti_union_pw_aff multi_union_pw_aff::gist(union_set context) const\n{\n  auto res = isl_multi_union_pw_aff_gist(copy(), context.release());\n  return manage(res);\n}\n\nmulti_union_pw_aff multi_union_pw_aff::gist_params(set context) const\n{\n  auto res = isl_multi_union_pw_aff_gist_params(copy(), context.release());\n  return manage(res);\n}\n\nboolean multi_union_pw_aff::has_tuple_id(isl::dim type) const\n{\n  auto res = isl_multi_union_pw_aff_has_tuple_id(get(), static_cast<enum isl_dim_type>(type));\n  return manage(res);\n}\n\nmulti_union_pw_aff multi_union_pw_aff::intersect_domain(union_set uset) const\n{\n  auto res = isl_multi_union_pw_aff_intersect_domain(copy(), uset.release());\n  return manage(res);\n}\n\nmulti_union_pw_aff multi_union_pw_aff::intersect_params(set params) const\n{\n  auto res = isl_multi_union_pw_aff_intersect_params(copy(), params.release());\n  return manage(res);\n}\n\nmulti_union_pw_aff multi_union_pw_aff::intersect_range(set set) const\n{\n  auto res = isl_multi_union_pw_aff_intersect_range(copy(), set.release());\n  return manage(res);\n}\n\nboolean multi_union_pw_aff::involves_nan() const\n{\n  auto res = isl_multi_union_pw_aff_involves_nan(get());\n  return manage(res);\n}\n\nmulti_val multi_union_pw_aff::max_multi_val() const\n{\n  auto res = isl_multi_union_pw_aff_max_multi_val(copy());\n  return manage(res);\n}\n\nmulti_val multi_union_pw_aff::min_multi_val() const\n{\n  auto res = isl_multi_union_pw_aff_min_multi_val(copy());\n  return manage(res);\n}\n\nmulti_union_pw_aff multi_union_pw_aff::mod_multi_val(multi_val mv) const\n{\n  auto res = isl_multi_union_pw_aff_mod_multi_val(copy(), mv.release());\n  return manage(res);\n}\n\nmulti_union_pw_aff multi_union_pw_aff::multi_aff_on_domain(union_set domain, multi_aff ma)\n{\n  auto res = isl_multi_union_pw_aff_multi_aff_on_domain(domain.release(), ma.release());\n  return manage(res);\n}\n\nmulti_union_pw_aff multi_union_pw_aff::multi_val_on_domain(union_set domain, multi_val mv)\n{\n  auto res = isl_multi_union_pw_aff_multi_val_on_domain(domain.release(), mv.release());\n  return manage(res);\n}\n\nmulti_union_pw_aff multi_union_pw_aff::neg() const\n{\n  auto res = isl_multi_union_pw_aff_neg(copy());\n  return manage(res);\n}\n\nboolean multi_union_pw_aff::plain_is_equal(const multi_union_pw_aff &multi2) const\n{\n  auto res = isl_multi_union_pw_aff_plain_is_equal(get(), multi2.get());\n  return manage(res);\n}\n\nmulti_union_pw_aff multi_union_pw_aff::pullback(union_pw_multi_aff upma) const\n{\n  auto res = isl_multi_union_pw_aff_pullback_union_pw_multi_aff(copy(), upma.release());\n  return manage(res);\n}\n\nmulti_union_pw_aff multi_union_pw_aff::pw_multi_aff_on_domain(union_set domain, pw_multi_aff pma)\n{\n  auto res = isl_multi_union_pw_aff_pw_multi_aff_on_domain(domain.release(), pma.release());\n  return manage(res);\n}\n\nmulti_union_pw_aff multi_union_pw_aff::range_factor_domain() const\n{\n  auto res = isl_multi_union_pw_aff_range_factor_domain(copy());\n  return manage(res);\n}\n\nmulti_union_pw_aff multi_union_pw_aff::range_factor_range() const\n{\n  auto res = isl_multi_union_pw_aff_range_factor_range(copy());\n  return manage(res);\n}\n\nboolean multi_union_pw_aff::range_is_wrapping() const\n{\n  auto res = isl_multi_union_pw_aff_range_is_wrapping(get());\n  return manage(res);\n}\n\nmulti_union_pw_aff multi_union_pw_aff::range_product(multi_union_pw_aff multi2) const\n{\n  auto res = isl_multi_union_pw_aff_range_product(copy(), multi2.release());\n  return manage(res);\n}\n\nmulti_union_pw_aff multi_union_pw_aff::range_splice(unsigned int pos, multi_union_pw_aff multi2) const\n{\n  auto res = isl_multi_union_pw_aff_range_splice(copy(), pos, multi2.release());\n  return manage(res);\n}\n\nmulti_union_pw_aff multi_union_pw_aff::reset_tuple_id(isl::dim type) const\n{\n  auto res = isl_multi_union_pw_aff_reset_tuple_id(copy(), static_cast<enum isl_dim_type>(type));\n  return manage(res);\n}\n\nmulti_union_pw_aff multi_union_pw_aff::reset_user() const\n{\n  auto res = isl_multi_union_pw_aff_reset_user(copy());\n  return manage(res);\n}\n\nmulti_union_pw_aff multi_union_pw_aff::scale(multi_val mv) const\n{\n  auto res = isl_multi_union_pw_aff_scale_multi_val(copy(), mv.release());\n  return manage(res);\n}\n\nmulti_union_pw_aff multi_union_pw_aff::scale(val v) const\n{\n  auto res = isl_multi_union_pw_aff_scale_val(copy(), v.release());\n  return manage(res);\n}\n\nmulti_union_pw_aff multi_union_pw_aff::scale_down(multi_val mv) const\n{\n  auto res = isl_multi_union_pw_aff_scale_down_multi_val(copy(), mv.release());\n  return manage(res);\n}\n\nmulti_union_pw_aff multi_union_pw_aff::scale_down(val v) const\n{\n  auto res = isl_multi_union_pw_aff_scale_down_val(copy(), v.release());\n  return manage(res);\n}\n\nmulti_union_pw_aff multi_union_pw_aff::set_at(int pos, union_pw_aff el) const\n{\n  auto res = isl_multi_union_pw_aff_set_at(copy(), pos, el.release());\n  return manage(res);\n}\n\nmulti_union_pw_aff multi_union_pw_aff::set_dim_id(isl::dim type, unsigned int pos, id id) const\n{\n  auto res = isl_multi_union_pw_aff_set_dim_id(copy(), static_cast<enum isl_dim_type>(type), pos, id.release());\n  return manage(res);\n}\n\nmulti_union_pw_aff multi_union_pw_aff::set_tuple_id(isl::dim type, id id) const\n{\n  auto res = isl_multi_union_pw_aff_set_tuple_id(copy(), static_cast<enum isl_dim_type>(type), id.release());\n  return manage(res);\n}\n\nmulti_union_pw_aff multi_union_pw_aff::set_tuple_name(isl::dim type, const std::string &s) const\n{\n  auto res = isl_multi_union_pw_aff_set_tuple_name(copy(), static_cast<enum isl_dim_type>(type), s.c_str());\n  return manage(res);\n}\n\nmulti_union_pw_aff multi_union_pw_aff::set_union_pw_aff(int pos, union_pw_aff el) const\n{\n  auto res = isl_multi_union_pw_aff_set_union_pw_aff(copy(), pos, el.release());\n  return manage(res);\n}\n\nisl_size multi_union_pw_aff::size() const\n{\n  auto res = isl_multi_union_pw_aff_size(get());\n  return res;\n}\n\nmulti_union_pw_aff multi_union_pw_aff::sub(multi_union_pw_aff multi2) const\n{\n  auto res = isl_multi_union_pw_aff_sub(copy(), multi2.release());\n  return manage(res);\n}\n\nmulti_union_pw_aff multi_union_pw_aff::union_add(multi_union_pw_aff mupa2) const\n{\n  auto res = isl_multi_union_pw_aff_union_add(copy(), mupa2.release());\n  return manage(res);\n}\n\nmulti_union_pw_aff multi_union_pw_aff::zero(space space)\n{\n  auto res = isl_multi_union_pw_aff_zero(space.release());\n  return manage(res);\n}\n\nunion_set multi_union_pw_aff::zero_union_set() const\n{\n  auto res = isl_multi_union_pw_aff_zero_union_set(copy());\n  return manage(res);\n}\n\n// implementations for isl::multi_val\nmulti_val manage(__isl_take isl_multi_val *ptr) {\n  return multi_val(ptr);\n}\nmulti_val manage_copy(__isl_keep isl_multi_val *ptr) {\n  ptr = isl_multi_val_copy(ptr);\n  return multi_val(ptr);\n}\n\nmulti_val::multi_val()\n    : ptr(nullptr) {}\n\nmulti_val::multi_val(const multi_val &obj)\n    : ptr(nullptr)\n{\n  ptr = obj.copy();\n}\nmulti_val::multi_val(std::nullptr_t)\n    : ptr(nullptr) {}\n\n\nmulti_val::multi_val(__isl_take isl_multi_val *ptr)\n    : ptr(ptr) {}\n\nmulti_val::multi_val(space space, val_list list)\n{\n  auto res = isl_multi_val_from_val_list(space.release(), list.release());\n  ptr = res;\n}\nmulti_val::multi_val(ctx ctx, const std::string &str)\n{\n  auto res = isl_multi_val_read_from_str(ctx.release(), str.c_str());\n  ptr = res;\n}\n\nmulti_val &multi_val::operator=(multi_val obj) {\n  std::swap(this->ptr, obj.ptr);\n  return *this;\n}\n\nmulti_val::~multi_val() {\n  if (ptr)\n    isl_multi_val_free(ptr);\n}\n\n__isl_give isl_multi_val *multi_val::copy() const & {\n  return isl_multi_val_copy(ptr);\n}\n\n__isl_keep isl_multi_val *multi_val::get() const {\n  return ptr;\n}\n\n__isl_give isl_multi_val *multi_val::release() {\n  isl_multi_val *tmp = ptr;\n  ptr = nullptr;\n  return tmp;\n}\n\nbool multi_val::is_null() const {\n  return ptr == nullptr;\n}\nmulti_val::operator bool() const {\n  return !is_null();\n}\n\n\nctx multi_val::get_ctx() const {\n  return ctx(isl_multi_val_get_ctx(ptr));\n}\nstd::string multi_val::to_str() const {\n  char *Tmp = isl_multi_val_to_str(get());\n  if (!Tmp)\n    return \"\";\n  std::string S(Tmp);\n  free(Tmp);\n  return S;\n}\n\n\nvoid multi_val::dump() const {\n  isl_multi_val_dump(get());\n}\n\n\nmulti_val multi_val::add(multi_val multi2) const\n{\n  auto res = isl_multi_val_add(copy(), multi2.release());\n  return manage(res);\n}\n\nmulti_val multi_val::add(val v) const\n{\n  auto res = isl_multi_val_add_val(copy(), v.release());\n  return manage(res);\n}\n\nmulti_val multi_val::add_dims(isl::dim type, unsigned int n) const\n{\n  auto res = isl_multi_val_add_dims(copy(), static_cast<enum isl_dim_type>(type), n);\n  return manage(res);\n}\n\nmulti_val multi_val::align_params(space model) const\n{\n  auto res = isl_multi_val_align_params(copy(), model.release());\n  return manage(res);\n}\n\nisl_size multi_val::dim(isl::dim type) const\n{\n  auto res = isl_multi_val_dim(get(), static_cast<enum isl_dim_type>(type));\n  return res;\n}\n\nmulti_val multi_val::drop_dims(isl::dim type, unsigned int first, unsigned int n) const\n{\n  auto res = isl_multi_val_drop_dims(copy(), static_cast<enum isl_dim_type>(type), first, n);\n  return manage(res);\n}\n\nmulti_val multi_val::factor_range() const\n{\n  auto res = isl_multi_val_factor_range(copy());\n  return manage(res);\n}\n\nint multi_val::find_dim_by_id(isl::dim type, const id &id) const\n{\n  auto res = isl_multi_val_find_dim_by_id(get(), static_cast<enum isl_dim_type>(type), id.get());\n  return res;\n}\n\nint multi_val::find_dim_by_name(isl::dim type, const std::string &name) const\n{\n  auto res = isl_multi_val_find_dim_by_name(get(), static_cast<enum isl_dim_type>(type), name.c_str());\n  return res;\n}\n\nmulti_val multi_val::flat_range_product(multi_val multi2) const\n{\n  auto res = isl_multi_val_flat_range_product(copy(), multi2.release());\n  return manage(res);\n}\n\nmulti_val multi_val::flatten_range() const\n{\n  auto res = isl_multi_val_flatten_range(copy());\n  return manage(res);\n}\n\nmulti_val multi_val::from_range() const\n{\n  auto res = isl_multi_val_from_range(copy());\n  return manage(res);\n}\n\nval multi_val::get_at(int pos) const\n{\n  auto res = isl_multi_val_get_at(get(), pos);\n  return manage(res);\n}\n\nid multi_val::get_dim_id(isl::dim type, unsigned int pos) const\n{\n  auto res = isl_multi_val_get_dim_id(get(), static_cast<enum isl_dim_type>(type), pos);\n  return manage(res);\n}\n\nspace multi_val::get_domain_space() const\n{\n  auto res = isl_multi_val_get_domain_space(get());\n  return manage(res);\n}\n\nval_list multi_val::get_list() const\n{\n  auto res = isl_multi_val_get_list(get());\n  return manage(res);\n}\n\nspace multi_val::get_space() const\n{\n  auto res = isl_multi_val_get_space(get());\n  return manage(res);\n}\n\nid multi_val::get_tuple_id(isl::dim type) const\n{\n  auto res = isl_multi_val_get_tuple_id(get(), static_cast<enum isl_dim_type>(type));\n  return manage(res);\n}\n\nstd::string multi_val::get_tuple_name(isl::dim type) const\n{\n  auto res = isl_multi_val_get_tuple_name(get(), static_cast<enum isl_dim_type>(type));\n  std::string tmp(res);\n  return tmp;\n}\n\nval multi_val::get_val(int pos) const\n{\n  auto res = isl_multi_val_get_val(get(), pos);\n  return manage(res);\n}\n\nboolean multi_val::has_tuple_id(isl::dim type) const\n{\n  auto res = isl_multi_val_has_tuple_id(get(), static_cast<enum isl_dim_type>(type));\n  return manage(res);\n}\n\nmulti_val multi_val::insert_dims(isl::dim type, unsigned int first, unsigned int n) const\n{\n  auto res = isl_multi_val_insert_dims(copy(), static_cast<enum isl_dim_type>(type), first, n);\n  return manage(res);\n}\n\nboolean multi_val::involves_dims(isl::dim type, unsigned int first, unsigned int n) const\n{\n  auto res = isl_multi_val_involves_dims(get(), static_cast<enum isl_dim_type>(type), first, n);\n  return manage(res);\n}\n\nboolean multi_val::involves_nan() const\n{\n  auto res = isl_multi_val_involves_nan(get());\n  return manage(res);\n}\n\nboolean multi_val::is_zero() const\n{\n  auto res = isl_multi_val_is_zero(get());\n  return manage(res);\n}\n\nmulti_val multi_val::max(multi_val multi2) const\n{\n  auto res = isl_multi_val_max(copy(), multi2.release());\n  return manage(res);\n}\n\nmulti_val multi_val::min(multi_val multi2) const\n{\n  auto res = isl_multi_val_min(copy(), multi2.release());\n  return manage(res);\n}\n\nmulti_val multi_val::mod_multi_val(multi_val mv) const\n{\n  auto res = isl_multi_val_mod_multi_val(copy(), mv.release());\n  return manage(res);\n}\n\nmulti_val multi_val::mod_val(val v) const\n{\n  auto res = isl_multi_val_mod_val(copy(), v.release());\n  return manage(res);\n}\n\nmulti_val multi_val::neg() const\n{\n  auto res = isl_multi_val_neg(copy());\n  return manage(res);\n}\n\nboolean multi_val::plain_is_equal(const multi_val &multi2) const\n{\n  auto res = isl_multi_val_plain_is_equal(get(), multi2.get());\n  return manage(res);\n}\n\nmulti_val multi_val::product(multi_val multi2) const\n{\n  auto res = isl_multi_val_product(copy(), multi2.release());\n  return manage(res);\n}\n\nmulti_val multi_val::project_domain_on_params() const\n{\n  auto res = isl_multi_val_project_domain_on_params(copy());\n  return manage(res);\n}\n\nmulti_val multi_val::range_factor_domain() const\n{\n  auto res = isl_multi_val_range_factor_domain(copy());\n  return manage(res);\n}\n\nmulti_val multi_val::range_factor_range() const\n{\n  auto res = isl_multi_val_range_factor_range(copy());\n  return manage(res);\n}\n\nboolean multi_val::range_is_wrapping() const\n{\n  auto res = isl_multi_val_range_is_wrapping(get());\n  return manage(res);\n}\n\nmulti_val multi_val::range_product(multi_val multi2) const\n{\n  auto res = isl_multi_val_range_product(copy(), multi2.release());\n  return manage(res);\n}\n\nmulti_val multi_val::range_splice(unsigned int pos, multi_val multi2) const\n{\n  auto res = isl_multi_val_range_splice(copy(), pos, multi2.release());\n  return manage(res);\n}\n\nmulti_val multi_val::reset_tuple_id(isl::dim type) const\n{\n  auto res = isl_multi_val_reset_tuple_id(copy(), static_cast<enum isl_dim_type>(type));\n  return manage(res);\n}\n\nmulti_val multi_val::reset_user() const\n{\n  auto res = isl_multi_val_reset_user(copy());\n  return manage(res);\n}\n\nmulti_val multi_val::scale(multi_val mv) const\n{\n  auto res = isl_multi_val_scale_multi_val(copy(), mv.release());\n  return manage(res);\n}\n\nmulti_val multi_val::scale(val v) const\n{\n  auto res = isl_multi_val_scale_val(copy(), v.release());\n  return manage(res);\n}\n\nmulti_val multi_val::scale_down(multi_val mv) const\n{\n  auto res = isl_multi_val_scale_down_multi_val(copy(), mv.release());\n  return manage(res);\n}\n\nmulti_val multi_val::scale_down(val v) const\n{\n  auto res = isl_multi_val_scale_down_val(copy(), v.release());\n  return manage(res);\n}\n\nmulti_val multi_val::set_at(int pos, val el) const\n{\n  auto res = isl_multi_val_set_at(copy(), pos, el.release());\n  return manage(res);\n}\n\nmulti_val multi_val::set_dim_id(isl::dim type, unsigned int pos, id id) const\n{\n  auto res = isl_multi_val_set_dim_id(copy(), static_cast<enum isl_dim_type>(type), pos, id.release());\n  return manage(res);\n}\n\nmulti_val multi_val::set_tuple_id(isl::dim type, id id) const\n{\n  auto res = isl_multi_val_set_tuple_id(copy(), static_cast<enum isl_dim_type>(type), id.release());\n  return manage(res);\n}\n\nmulti_val multi_val::set_tuple_name(isl::dim type, const std::string &s) const\n{\n  auto res = isl_multi_val_set_tuple_name(copy(), static_cast<enum isl_dim_type>(type), s.c_str());\n  return manage(res);\n}\n\nmulti_val multi_val::set_val(int pos, val el) const\n{\n  auto res = isl_multi_val_set_val(copy(), pos, el.release());\n  return manage(res);\n}\n\nisl_size multi_val::size() const\n{\n  auto res = isl_multi_val_size(get());\n  return res;\n}\n\nmulti_val multi_val::splice(unsigned int in_pos, unsigned int out_pos, multi_val multi2) const\n{\n  auto res = isl_multi_val_splice(copy(), in_pos, out_pos, multi2.release());\n  return manage(res);\n}\n\nmulti_val multi_val::sub(multi_val multi2) const\n{\n  auto res = isl_multi_val_sub(copy(), multi2.release());\n  return manage(res);\n}\n\nmulti_val multi_val::zero(space space)\n{\n  auto res = isl_multi_val_zero(space.release());\n  return manage(res);\n}\n\n// implementations for isl::point\npoint manage(__isl_take isl_point *ptr) {\n  return point(ptr);\n}\npoint manage_copy(__isl_keep isl_point *ptr) {\n  ptr = isl_point_copy(ptr);\n  return point(ptr);\n}\n\npoint::point()\n    : ptr(nullptr) {}\n\npoint::point(const point &obj)\n    : ptr(nullptr)\n{\n  ptr = obj.copy();\n}\npoint::point(std::nullptr_t)\n    : ptr(nullptr) {}\n\n\npoint::point(__isl_take isl_point *ptr)\n    : ptr(ptr) {}\n\npoint::point(space dim)\n{\n  auto res = isl_point_zero(dim.release());\n  ptr = res;\n}\n\npoint &point::operator=(point obj) {\n  std::swap(this->ptr, obj.ptr);\n  return *this;\n}\n\npoint::~point() {\n  if (ptr)\n    isl_point_free(ptr);\n}\n\n__isl_give isl_point *point::copy() const & {\n  return isl_point_copy(ptr);\n}\n\n__isl_keep isl_point *point::get() const {\n  return ptr;\n}\n\n__isl_give isl_point *point::release() {\n  isl_point *tmp = ptr;\n  ptr = nullptr;\n  return tmp;\n}\n\nbool point::is_null() const {\n  return ptr == nullptr;\n}\npoint::operator bool() const {\n  return !is_null();\n}\n\n\nctx point::get_ctx() const {\n  return ctx(isl_point_get_ctx(ptr));\n}\nstd::string point::to_str() const {\n  char *Tmp = isl_point_to_str(get());\n  if (!Tmp)\n    return \"\";\n  std::string S(Tmp);\n  free(Tmp);\n  return S;\n}\n\n\nvoid point::dump() const {\n  isl_point_dump(get());\n}\n\n\npoint point::add_ui(isl::dim type, int pos, unsigned int val) const\n{\n  auto res = isl_point_add_ui(copy(), static_cast<enum isl_dim_type>(type), pos, val);\n  return manage(res);\n}\n\nval point::get_coordinate_val(isl::dim type, int pos) const\n{\n  auto res = isl_point_get_coordinate_val(get(), static_cast<enum isl_dim_type>(type), pos);\n  return manage(res);\n}\n\nmulti_val point::get_multi_val() const\n{\n  auto res = isl_point_get_multi_val(get());\n  return manage(res);\n}\n\nspace point::get_space() const\n{\n  auto res = isl_point_get_space(get());\n  return manage(res);\n}\n\npoint point::set_coordinate_val(isl::dim type, int pos, val v) const\n{\n  auto res = isl_point_set_coordinate_val(copy(), static_cast<enum isl_dim_type>(type), pos, v.release());\n  return manage(res);\n}\n\npoint point::sub_ui(isl::dim type, int pos, unsigned int val) const\n{\n  auto res = isl_point_sub_ui(copy(), static_cast<enum isl_dim_type>(type), pos, val);\n  return manage(res);\n}\n\n// implementations for isl::pw_aff\npw_aff manage(__isl_take isl_pw_aff *ptr) {\n  return pw_aff(ptr);\n}\npw_aff manage_copy(__isl_keep isl_pw_aff *ptr) {\n  ptr = isl_pw_aff_copy(ptr);\n  return pw_aff(ptr);\n}\n\npw_aff::pw_aff()\n    : ptr(nullptr) {}\n\npw_aff::pw_aff(const pw_aff &obj)\n    : ptr(nullptr)\n{\n  ptr = obj.copy();\n}\npw_aff::pw_aff(std::nullptr_t)\n    : ptr(nullptr) {}\n\n\npw_aff::pw_aff(__isl_take isl_pw_aff *ptr)\n    : ptr(ptr) {}\n\npw_aff::pw_aff(aff aff)\n{\n  auto res = isl_pw_aff_from_aff(aff.release());\n  ptr = res;\n}\npw_aff::pw_aff(ctx ctx, const std::string &str)\n{\n  auto res = isl_pw_aff_read_from_str(ctx.release(), str.c_str());\n  ptr = res;\n}\npw_aff::pw_aff(set domain, val v)\n{\n  auto res = isl_pw_aff_val_on_domain(domain.release(), v.release());\n  ptr = res;\n}\npw_aff::pw_aff(local_space ls)\n{\n  auto res = isl_pw_aff_zero_on_domain(ls.release());\n  ptr = res;\n}\n\npw_aff &pw_aff::operator=(pw_aff obj) {\n  std::swap(this->ptr, obj.ptr);\n  return *this;\n}\n\npw_aff::~pw_aff() {\n  if (ptr)\n    isl_pw_aff_free(ptr);\n}\n\n__isl_give isl_pw_aff *pw_aff::copy() const & {\n  return isl_pw_aff_copy(ptr);\n}\n\n__isl_keep isl_pw_aff *pw_aff::get() const {\n  return ptr;\n}\n\n__isl_give isl_pw_aff *pw_aff::release() {\n  isl_pw_aff *tmp = ptr;\n  ptr = nullptr;\n  return tmp;\n}\n\nbool pw_aff::is_null() const {\n  return ptr == nullptr;\n}\npw_aff::operator bool() const {\n  return !is_null();\n}\n\n\nctx pw_aff::get_ctx() const {\n  return ctx(isl_pw_aff_get_ctx(ptr));\n}\nstd::string pw_aff::to_str() const {\n  char *Tmp = isl_pw_aff_to_str(get());\n  if (!Tmp)\n    return \"\";\n  std::string S(Tmp);\n  free(Tmp);\n  return S;\n}\n\n\nvoid pw_aff::dump() const {\n  isl_pw_aff_dump(get());\n}\n\n\npw_aff pw_aff::add(pw_aff pwaff2) const\n{\n  auto res = isl_pw_aff_add(copy(), pwaff2.release());\n  return manage(res);\n}\n\npw_aff pw_aff::add_constant(val v) const\n{\n  auto res = isl_pw_aff_add_constant_val(copy(), v.release());\n  return manage(res);\n}\n\npw_aff pw_aff::add_dims(isl::dim type, unsigned int n) const\n{\n  auto res = isl_pw_aff_add_dims(copy(), static_cast<enum isl_dim_type>(type), n);\n  return manage(res);\n}\n\npw_aff pw_aff::align_params(space model) const\n{\n  auto res = isl_pw_aff_align_params(copy(), model.release());\n  return manage(res);\n}\n\npw_aff pw_aff::alloc(set set, aff aff)\n{\n  auto res = isl_pw_aff_alloc(set.release(), aff.release());\n  return manage(res);\n}\n\naff pw_aff::as_aff() const\n{\n  auto res = isl_pw_aff_as_aff(copy());\n  return manage(res);\n}\n\nset pw_aff::bind(id id) const\n{\n  auto res = isl_pw_aff_bind_id(copy(), id.release());\n  return manage(res);\n}\n\npw_aff pw_aff::bind_domain(multi_id tuple) const\n{\n  auto res = isl_pw_aff_bind_domain(copy(), tuple.release());\n  return manage(res);\n}\n\npw_aff pw_aff::bind_domain_wrapped_domain(multi_id tuple) const\n{\n  auto res = isl_pw_aff_bind_domain_wrapped_domain(copy(), tuple.release());\n  return manage(res);\n}\n\npw_aff pw_aff::ceil() const\n{\n  auto res = isl_pw_aff_ceil(copy());\n  return manage(res);\n}\n\npw_aff pw_aff::coalesce() const\n{\n  auto res = isl_pw_aff_coalesce(copy());\n  return manage(res);\n}\n\npw_aff pw_aff::cond(pw_aff pwaff_true, pw_aff pwaff_false) const\n{\n  auto res = isl_pw_aff_cond(copy(), pwaff_true.release(), pwaff_false.release());\n  return manage(res);\n}\n\nisl_size pw_aff::dim(isl::dim type) const\n{\n  auto res = isl_pw_aff_dim(get(), static_cast<enum isl_dim_type>(type));\n  return res;\n}\n\npw_aff pw_aff::div(pw_aff pa2) const\n{\n  auto res = isl_pw_aff_div(copy(), pa2.release());\n  return manage(res);\n}\n\nset pw_aff::domain() const\n{\n  auto res = isl_pw_aff_domain(copy());\n  return manage(res);\n}\n\npw_aff pw_aff::drop_dims(isl::dim type, unsigned int first, unsigned int n) const\n{\n  auto res = isl_pw_aff_drop_dims(copy(), static_cast<enum isl_dim_type>(type), first, n);\n  return manage(res);\n}\n\npw_aff pw_aff::drop_unused_params() const\n{\n  auto res = isl_pw_aff_drop_unused_params(copy());\n  return manage(res);\n}\n\npw_aff pw_aff::empty(space space)\n{\n  auto res = isl_pw_aff_empty(space.release());\n  return manage(res);\n}\n\nmap pw_aff::eq_map(pw_aff pa2) const\n{\n  auto res = isl_pw_aff_eq_map(copy(), pa2.release());\n  return manage(res);\n}\n\nset pw_aff::eq_set(pw_aff pwaff2) const\n{\n  auto res = isl_pw_aff_eq_set(copy(), pwaff2.release());\n  return manage(res);\n}\n\nval pw_aff::eval(point pnt) const\n{\n  auto res = isl_pw_aff_eval(copy(), pnt.release());\n  return manage(res);\n}\n\nint pw_aff::find_dim_by_name(isl::dim type, const std::string &name) const\n{\n  auto res = isl_pw_aff_find_dim_by_name(get(), static_cast<enum isl_dim_type>(type), name.c_str());\n  return res;\n}\n\npw_aff pw_aff::floor() const\n{\n  auto res = isl_pw_aff_floor(copy());\n  return manage(res);\n}\n\nstat pw_aff::foreach_piece(const std::function<stat(set, aff)> &fn) const\n{\n  struct fn_data {\n    const std::function<stat(set, aff)> *func;\n  } fn_data = { &fn };\n  auto fn_lambda = [](isl_set *arg_0, isl_aff *arg_1, void *arg_2) -> isl_stat {\n    auto *data = static_cast<struct fn_data *>(arg_2);\n    stat ret = (*data->func)(manage(arg_0), manage(arg_1));\n    return ret.release();\n  };\n  auto res = isl_pw_aff_foreach_piece(get(), fn_lambda, &fn_data);\n  return manage(res);\n}\n\npw_aff pw_aff::from_range() const\n{\n  auto res = isl_pw_aff_from_range(copy());\n  return manage(res);\n}\n\nmap pw_aff::ge_map(pw_aff pa2) const\n{\n  auto res = isl_pw_aff_ge_map(copy(), pa2.release());\n  return manage(res);\n}\n\nset pw_aff::ge_set(pw_aff pwaff2) const\n{\n  auto res = isl_pw_aff_ge_set(copy(), pwaff2.release());\n  return manage(res);\n}\n\nid pw_aff::get_dim_id(isl::dim type, unsigned int pos) const\n{\n  auto res = isl_pw_aff_get_dim_id(get(), static_cast<enum isl_dim_type>(type), pos);\n  return manage(res);\n}\n\nstd::string pw_aff::get_dim_name(isl::dim type, unsigned int pos) const\n{\n  auto res = isl_pw_aff_get_dim_name(get(), static_cast<enum isl_dim_type>(type), pos);\n  std::string tmp(res);\n  return tmp;\n}\n\nspace pw_aff::get_domain_space() const\n{\n  auto res = isl_pw_aff_get_domain_space(get());\n  return manage(res);\n}\n\nuint32_t pw_aff::get_hash() const\n{\n  auto res = isl_pw_aff_get_hash(get());\n  return res;\n}\n\nspace pw_aff::get_space() const\n{\n  auto res = isl_pw_aff_get_space(get());\n  return manage(res);\n}\n\nid pw_aff::get_tuple_id(isl::dim type) const\n{\n  auto res = isl_pw_aff_get_tuple_id(get(), static_cast<enum isl_dim_type>(type));\n  return manage(res);\n}\n\npw_aff pw_aff::gist(set context) const\n{\n  auto res = isl_pw_aff_gist(copy(), context.release());\n  return manage(res);\n}\n\npw_aff pw_aff::gist_params(set context) const\n{\n  auto res = isl_pw_aff_gist_params(copy(), context.release());\n  return manage(res);\n}\n\nmap pw_aff::gt_map(pw_aff pa2) const\n{\n  auto res = isl_pw_aff_gt_map(copy(), pa2.release());\n  return manage(res);\n}\n\nset pw_aff::gt_set(pw_aff pwaff2) const\n{\n  auto res = isl_pw_aff_gt_set(copy(), pwaff2.release());\n  return manage(res);\n}\n\nboolean pw_aff::has_dim_id(isl::dim type, unsigned int pos) const\n{\n  auto res = isl_pw_aff_has_dim_id(get(), static_cast<enum isl_dim_type>(type), pos);\n  return manage(res);\n}\n\nboolean pw_aff::has_tuple_id(isl::dim type) const\n{\n  auto res = isl_pw_aff_has_tuple_id(get(), static_cast<enum isl_dim_type>(type));\n  return manage(res);\n}\n\npw_aff pw_aff::insert_dims(isl::dim type, unsigned int first, unsigned int n) const\n{\n  auto res = isl_pw_aff_insert_dims(copy(), static_cast<enum isl_dim_type>(type), first, n);\n  return manage(res);\n}\n\npw_aff pw_aff::insert_domain(space domain) const\n{\n  auto res = isl_pw_aff_insert_domain(copy(), domain.release());\n  return manage(res);\n}\n\npw_aff pw_aff::intersect_domain(set set) const\n{\n  auto res = isl_pw_aff_intersect_domain(copy(), set.release());\n  return manage(res);\n}\n\npw_aff pw_aff::intersect_domain_wrapped_domain(set set) const\n{\n  auto res = isl_pw_aff_intersect_domain_wrapped_domain(copy(), set.release());\n  return manage(res);\n}\n\npw_aff pw_aff::intersect_domain_wrapped_range(set set) const\n{\n  auto res = isl_pw_aff_intersect_domain_wrapped_range(copy(), set.release());\n  return manage(res);\n}\n\npw_aff pw_aff::intersect_params(set set) const\n{\n  auto res = isl_pw_aff_intersect_params(copy(), set.release());\n  return manage(res);\n}\n\nboolean pw_aff::involves_dims(isl::dim type, unsigned int first, unsigned int n) const\n{\n  auto res = isl_pw_aff_involves_dims(get(), static_cast<enum isl_dim_type>(type), first, n);\n  return manage(res);\n}\n\nboolean pw_aff::involves_nan() const\n{\n  auto res = isl_pw_aff_involves_nan(get());\n  return manage(res);\n}\n\nboolean pw_aff::involves_param_id(const id &id) const\n{\n  auto res = isl_pw_aff_involves_param_id(get(), id.get());\n  return manage(res);\n}\n\nboolean pw_aff::is_cst() const\n{\n  auto res = isl_pw_aff_is_cst(get());\n  return manage(res);\n}\n\nboolean pw_aff::is_empty() const\n{\n  auto res = isl_pw_aff_is_empty(get());\n  return manage(res);\n}\n\nboolean pw_aff::is_equal(const pw_aff &pa2) const\n{\n  auto res = isl_pw_aff_is_equal(get(), pa2.get());\n  return manage(res);\n}\n\nboolean pw_aff::isa_aff() const\n{\n  auto res = isl_pw_aff_isa_aff(get());\n  return manage(res);\n}\n\nmap pw_aff::le_map(pw_aff pa2) const\n{\n  auto res = isl_pw_aff_le_map(copy(), pa2.release());\n  return manage(res);\n}\n\nset pw_aff::le_set(pw_aff pwaff2) const\n{\n  auto res = isl_pw_aff_le_set(copy(), pwaff2.release());\n  return manage(res);\n}\n\nmap pw_aff::lt_map(pw_aff pa2) const\n{\n  auto res = isl_pw_aff_lt_map(copy(), pa2.release());\n  return manage(res);\n}\n\nset pw_aff::lt_set(pw_aff pwaff2) const\n{\n  auto res = isl_pw_aff_lt_set(copy(), pwaff2.release());\n  return manage(res);\n}\n\npw_aff pw_aff::max(pw_aff pwaff2) const\n{\n  auto res = isl_pw_aff_max(copy(), pwaff2.release());\n  return manage(res);\n}\n\npw_aff pw_aff::min(pw_aff pwaff2) const\n{\n  auto res = isl_pw_aff_min(copy(), pwaff2.release());\n  return manage(res);\n}\n\npw_aff pw_aff::mod(val mod) const\n{\n  auto res = isl_pw_aff_mod_val(copy(), mod.release());\n  return manage(res);\n}\n\npw_aff pw_aff::move_dims(isl::dim dst_type, unsigned int dst_pos, isl::dim src_type, unsigned int src_pos, unsigned int n) const\n{\n  auto res = isl_pw_aff_move_dims(copy(), static_cast<enum isl_dim_type>(dst_type), dst_pos, static_cast<enum isl_dim_type>(src_type), src_pos, n);\n  return manage(res);\n}\n\npw_aff pw_aff::mul(pw_aff pwaff2) const\n{\n  auto res = isl_pw_aff_mul(copy(), pwaff2.release());\n  return manage(res);\n}\n\nisl_size pw_aff::n_piece() const\n{\n  auto res = isl_pw_aff_n_piece(get());\n  return res;\n}\n\npw_aff pw_aff::nan_on_domain(local_space ls)\n{\n  auto res = isl_pw_aff_nan_on_domain(ls.release());\n  return manage(res);\n}\n\npw_aff pw_aff::nan_on_domain_space(space space)\n{\n  auto res = isl_pw_aff_nan_on_domain_space(space.release());\n  return manage(res);\n}\n\nset pw_aff::ne_set(pw_aff pwaff2) const\n{\n  auto res = isl_pw_aff_ne_set(copy(), pwaff2.release());\n  return manage(res);\n}\n\npw_aff pw_aff::neg() const\n{\n  auto res = isl_pw_aff_neg(copy());\n  return manage(res);\n}\n\nset pw_aff::non_zero_set() const\n{\n  auto res = isl_pw_aff_non_zero_set(copy());\n  return manage(res);\n}\n\nset pw_aff::nonneg_set() const\n{\n  auto res = isl_pw_aff_nonneg_set(copy());\n  return manage(res);\n}\n\npw_aff pw_aff::param_on_domain(set domain, id id)\n{\n  auto res = isl_pw_aff_param_on_domain_id(domain.release(), id.release());\n  return manage(res);\n}\n\nset pw_aff::params() const\n{\n  auto res = isl_pw_aff_params(copy());\n  return manage(res);\n}\n\nint pw_aff::plain_cmp(const pw_aff &pa2) const\n{\n  auto res = isl_pw_aff_plain_cmp(get(), pa2.get());\n  return res;\n}\n\nboolean pw_aff::plain_is_equal(const pw_aff &pwaff2) const\n{\n  auto res = isl_pw_aff_plain_is_equal(get(), pwaff2.get());\n  return manage(res);\n}\n\nset pw_aff::pos_set() const\n{\n  auto res = isl_pw_aff_pos_set(copy());\n  return manage(res);\n}\n\npw_aff pw_aff::project_domain_on_params() const\n{\n  auto res = isl_pw_aff_project_domain_on_params(copy());\n  return manage(res);\n}\n\npw_aff pw_aff::pullback(multi_aff ma) const\n{\n  auto res = isl_pw_aff_pullback_multi_aff(copy(), ma.release());\n  return manage(res);\n}\n\npw_aff pw_aff::pullback(multi_pw_aff mpa) const\n{\n  auto res = isl_pw_aff_pullback_multi_pw_aff(copy(), mpa.release());\n  return manage(res);\n}\n\npw_aff pw_aff::pullback(pw_multi_aff pma) const\n{\n  auto res = isl_pw_aff_pullback_pw_multi_aff(copy(), pma.release());\n  return manage(res);\n}\n\npw_aff pw_aff::reset_tuple_id(isl::dim type) const\n{\n  auto res = isl_pw_aff_reset_tuple_id(copy(), static_cast<enum isl_dim_type>(type));\n  return manage(res);\n}\n\npw_aff pw_aff::reset_user() const\n{\n  auto res = isl_pw_aff_reset_user(copy());\n  return manage(res);\n}\n\npw_aff pw_aff::scale(val v) const\n{\n  auto res = isl_pw_aff_scale_val(copy(), v.release());\n  return manage(res);\n}\n\npw_aff pw_aff::scale_down(val f) const\n{\n  auto res = isl_pw_aff_scale_down_val(copy(), f.release());\n  return manage(res);\n}\n\npw_aff pw_aff::set_dim_id(isl::dim type, unsigned int pos, id id) const\n{\n  auto res = isl_pw_aff_set_dim_id(copy(), static_cast<enum isl_dim_type>(type), pos, id.release());\n  return manage(res);\n}\n\npw_aff pw_aff::set_tuple_id(isl::dim type, id id) const\n{\n  auto res = isl_pw_aff_set_tuple_id(copy(), static_cast<enum isl_dim_type>(type), id.release());\n  return manage(res);\n}\n\npw_aff pw_aff::sub(pw_aff pwaff2) const\n{\n  auto res = isl_pw_aff_sub(copy(), pwaff2.release());\n  return manage(res);\n}\n\npw_aff pw_aff::subtract_domain(set set) const\n{\n  auto res = isl_pw_aff_subtract_domain(copy(), set.release());\n  return manage(res);\n}\n\npw_aff pw_aff::tdiv_q(pw_aff pa2) const\n{\n  auto res = isl_pw_aff_tdiv_q(copy(), pa2.release());\n  return manage(res);\n}\n\npw_aff pw_aff::tdiv_r(pw_aff pa2) const\n{\n  auto res = isl_pw_aff_tdiv_r(copy(), pa2.release());\n  return manage(res);\n}\n\npw_aff pw_aff::union_add(pw_aff pwaff2) const\n{\n  auto res = isl_pw_aff_union_add(copy(), pwaff2.release());\n  return manage(res);\n}\n\npw_aff pw_aff::union_max(pw_aff pwaff2) const\n{\n  auto res = isl_pw_aff_union_max(copy(), pwaff2.release());\n  return manage(res);\n}\n\npw_aff pw_aff::union_min(pw_aff pwaff2) const\n{\n  auto res = isl_pw_aff_union_min(copy(), pwaff2.release());\n  return manage(res);\n}\n\npw_aff pw_aff::var_on_domain(local_space ls, isl::dim type, unsigned int pos)\n{\n  auto res = isl_pw_aff_var_on_domain(ls.release(), static_cast<enum isl_dim_type>(type), pos);\n  return manage(res);\n}\n\nset pw_aff::zero_set() const\n{\n  auto res = isl_pw_aff_zero_set(copy());\n  return manage(res);\n}\n\n// implementations for isl::pw_aff_list\npw_aff_list manage(__isl_take isl_pw_aff_list *ptr) {\n  return pw_aff_list(ptr);\n}\npw_aff_list manage_copy(__isl_keep isl_pw_aff_list *ptr) {\n  ptr = isl_pw_aff_list_copy(ptr);\n  return pw_aff_list(ptr);\n}\n\npw_aff_list::pw_aff_list()\n    : ptr(nullptr) {}\n\npw_aff_list::pw_aff_list(const pw_aff_list &obj)\n    : ptr(nullptr)\n{\n  ptr = obj.copy();\n}\npw_aff_list::pw_aff_list(std::nullptr_t)\n    : ptr(nullptr) {}\n\n\npw_aff_list::pw_aff_list(__isl_take isl_pw_aff_list *ptr)\n    : ptr(ptr) {}\n\n\npw_aff_list &pw_aff_list::operator=(pw_aff_list obj) {\n  std::swap(this->ptr, obj.ptr);\n  return *this;\n}\n\npw_aff_list::~pw_aff_list() {\n  if (ptr)\n    isl_pw_aff_list_free(ptr);\n}\n\n__isl_give isl_pw_aff_list *pw_aff_list::copy() const & {\n  return isl_pw_aff_list_copy(ptr);\n}\n\n__isl_keep isl_pw_aff_list *pw_aff_list::get() const {\n  return ptr;\n}\n\n__isl_give isl_pw_aff_list *pw_aff_list::release() {\n  isl_pw_aff_list *tmp = ptr;\n  ptr = nullptr;\n  return tmp;\n}\n\nbool pw_aff_list::is_null() const {\n  return ptr == nullptr;\n}\npw_aff_list::operator bool() const {\n  return !is_null();\n}\n\n\nctx pw_aff_list::get_ctx() const {\n  return ctx(isl_pw_aff_list_get_ctx(ptr));\n}\nstd::string pw_aff_list::to_str() const {\n  char *Tmp = isl_pw_aff_list_to_str(get());\n  if (!Tmp)\n    return \"\";\n  std::string S(Tmp);\n  free(Tmp);\n  return S;\n}\n\n\nvoid pw_aff_list::dump() const {\n  isl_pw_aff_list_dump(get());\n}\n\n\npw_aff_list pw_aff_list::add(pw_aff el) const\n{\n  auto res = isl_pw_aff_list_add(copy(), el.release());\n  return manage(res);\n}\n\npw_aff_list pw_aff_list::alloc(ctx ctx, int n)\n{\n  auto res = isl_pw_aff_list_alloc(ctx.release(), n);\n  return manage(res);\n}\n\npw_aff_list pw_aff_list::clear() const\n{\n  auto res = isl_pw_aff_list_clear(copy());\n  return manage(res);\n}\n\npw_aff_list pw_aff_list::concat(pw_aff_list list2) const\n{\n  auto res = isl_pw_aff_list_concat(copy(), list2.release());\n  return manage(res);\n}\n\npw_aff_list pw_aff_list::drop(unsigned int first, unsigned int n) const\n{\n  auto res = isl_pw_aff_list_drop(copy(), first, n);\n  return manage(res);\n}\n\nset pw_aff_list::eq_set(pw_aff_list list2) const\n{\n  auto res = isl_pw_aff_list_eq_set(copy(), list2.release());\n  return manage(res);\n}\n\nstat pw_aff_list::foreach(const std::function<stat(pw_aff)> &fn) const\n{\n  struct fn_data {\n    const std::function<stat(pw_aff)> *func;\n  } fn_data = { &fn };\n  auto fn_lambda = [](isl_pw_aff *arg_0, void *arg_1) -> isl_stat {\n    auto *data = static_cast<struct fn_data *>(arg_1);\n    stat ret = (*data->func)(manage(arg_0));\n    return ret.release();\n  };\n  auto res = isl_pw_aff_list_foreach(get(), fn_lambda, &fn_data);\n  return manage(res);\n}\n\npw_aff_list pw_aff_list::from_pw_aff(pw_aff el)\n{\n  auto res = isl_pw_aff_list_from_pw_aff(el.release());\n  return manage(res);\n}\n\nset pw_aff_list::ge_set(pw_aff_list list2) const\n{\n  auto res = isl_pw_aff_list_ge_set(copy(), list2.release());\n  return manage(res);\n}\n\npw_aff pw_aff_list::get_at(int index) const\n{\n  auto res = isl_pw_aff_list_get_at(get(), index);\n  return manage(res);\n}\n\npw_aff pw_aff_list::get_pw_aff(int index) const\n{\n  auto res = isl_pw_aff_list_get_pw_aff(get(), index);\n  return manage(res);\n}\n\nset pw_aff_list::gt_set(pw_aff_list list2) const\n{\n  auto res = isl_pw_aff_list_gt_set(copy(), list2.release());\n  return manage(res);\n}\n\npw_aff_list pw_aff_list::insert(unsigned int pos, pw_aff el) const\n{\n  auto res = isl_pw_aff_list_insert(copy(), pos, el.release());\n  return manage(res);\n}\n\nset pw_aff_list::le_set(pw_aff_list list2) const\n{\n  auto res = isl_pw_aff_list_le_set(copy(), list2.release());\n  return manage(res);\n}\n\nset pw_aff_list::lt_set(pw_aff_list list2) const\n{\n  auto res = isl_pw_aff_list_lt_set(copy(), list2.release());\n  return manage(res);\n}\n\npw_aff pw_aff_list::max() const\n{\n  auto res = isl_pw_aff_list_max(copy());\n  return manage(res);\n}\n\npw_aff pw_aff_list::min() const\n{\n  auto res = isl_pw_aff_list_min(copy());\n  return manage(res);\n}\n\nisl_size pw_aff_list::n_pw_aff() const\n{\n  auto res = isl_pw_aff_list_n_pw_aff(get());\n  return res;\n}\n\nset pw_aff_list::ne_set(pw_aff_list list2) const\n{\n  auto res = isl_pw_aff_list_ne_set(copy(), list2.release());\n  return manage(res);\n}\n\npw_aff_list pw_aff_list::reverse() const\n{\n  auto res = isl_pw_aff_list_reverse(copy());\n  return manage(res);\n}\n\npw_aff_list pw_aff_list::set_pw_aff(int index, pw_aff el) const\n{\n  auto res = isl_pw_aff_list_set_pw_aff(copy(), index, el.release());\n  return manage(res);\n}\n\nisl_size pw_aff_list::size() const\n{\n  auto res = isl_pw_aff_list_size(get());\n  return res;\n}\n\npw_aff_list pw_aff_list::swap(unsigned int pos1, unsigned int pos2) const\n{\n  auto res = isl_pw_aff_list_swap(copy(), pos1, pos2);\n  return manage(res);\n}\n\n// implementations for isl::pw_multi_aff\npw_multi_aff manage(__isl_take isl_pw_multi_aff *ptr) {\n  return pw_multi_aff(ptr);\n}\npw_multi_aff manage_copy(__isl_keep isl_pw_multi_aff *ptr) {\n  ptr = isl_pw_multi_aff_copy(ptr);\n  return pw_multi_aff(ptr);\n}\n\npw_multi_aff::pw_multi_aff()\n    : ptr(nullptr) {}\n\npw_multi_aff::pw_multi_aff(const pw_multi_aff &obj)\n    : ptr(nullptr)\n{\n  ptr = obj.copy();\n}\npw_multi_aff::pw_multi_aff(std::nullptr_t)\n    : ptr(nullptr) {}\n\n\npw_multi_aff::pw_multi_aff(__isl_take isl_pw_multi_aff *ptr)\n    : ptr(ptr) {}\n\npw_multi_aff::pw_multi_aff(multi_aff ma)\n{\n  auto res = isl_pw_multi_aff_from_multi_aff(ma.release());\n  ptr = res;\n}\npw_multi_aff::pw_multi_aff(pw_aff pa)\n{\n  auto res = isl_pw_multi_aff_from_pw_aff(pa.release());\n  ptr = res;\n}\npw_multi_aff::pw_multi_aff(ctx ctx, const std::string &str)\n{\n  auto res = isl_pw_multi_aff_read_from_str(ctx.release(), str.c_str());\n  ptr = res;\n}\n\npw_multi_aff &pw_multi_aff::operator=(pw_multi_aff obj) {\n  std::swap(this->ptr, obj.ptr);\n  return *this;\n}\n\npw_multi_aff::~pw_multi_aff() {\n  if (ptr)\n    isl_pw_multi_aff_free(ptr);\n}\n\n__isl_give isl_pw_multi_aff *pw_multi_aff::copy() const & {\n  return isl_pw_multi_aff_copy(ptr);\n}\n\n__isl_keep isl_pw_multi_aff *pw_multi_aff::get() const {\n  return ptr;\n}\n\n__isl_give isl_pw_multi_aff *pw_multi_aff::release() {\n  isl_pw_multi_aff *tmp = ptr;\n  ptr = nullptr;\n  return tmp;\n}\n\nbool pw_multi_aff::is_null() const {\n  return ptr == nullptr;\n}\npw_multi_aff::operator bool() const {\n  return !is_null();\n}\n\n\nctx pw_multi_aff::get_ctx() const {\n  return ctx(isl_pw_multi_aff_get_ctx(ptr));\n}\nstd::string pw_multi_aff::to_str() const {\n  char *Tmp = isl_pw_multi_aff_to_str(get());\n  if (!Tmp)\n    return \"\";\n  std::string S(Tmp);\n  free(Tmp);\n  return S;\n}\n\n\nvoid pw_multi_aff::dump() const {\n  isl_pw_multi_aff_dump(get());\n}\n\n\npw_multi_aff pw_multi_aff::add(pw_multi_aff pma2) const\n{\n  auto res = isl_pw_multi_aff_add(copy(), pma2.release());\n  return manage(res);\n}\n\npw_multi_aff pw_multi_aff::add_constant(multi_val mv) const\n{\n  auto res = isl_pw_multi_aff_add_constant_multi_val(copy(), mv.release());\n  return manage(res);\n}\n\npw_multi_aff pw_multi_aff::add_constant(val v) const\n{\n  auto res = isl_pw_multi_aff_add_constant_val(copy(), v.release());\n  return manage(res);\n}\n\npw_multi_aff pw_multi_aff::align_params(space model) const\n{\n  auto res = isl_pw_multi_aff_align_params(copy(), model.release());\n  return manage(res);\n}\n\npw_multi_aff pw_multi_aff::alloc(set set, multi_aff maff)\n{\n  auto res = isl_pw_multi_aff_alloc(set.release(), maff.release());\n  return manage(res);\n}\n\nmulti_aff pw_multi_aff::as_multi_aff() const\n{\n  auto res = isl_pw_multi_aff_as_multi_aff(copy());\n  return manage(res);\n}\n\npw_multi_aff pw_multi_aff::bind_domain(multi_id tuple) const\n{\n  auto res = isl_pw_multi_aff_bind_domain(copy(), tuple.release());\n  return manage(res);\n}\n\npw_multi_aff pw_multi_aff::bind_domain_wrapped_domain(multi_id tuple) const\n{\n  auto res = isl_pw_multi_aff_bind_domain_wrapped_domain(copy(), tuple.release());\n  return manage(res);\n}\n\npw_multi_aff pw_multi_aff::coalesce() const\n{\n  auto res = isl_pw_multi_aff_coalesce(copy());\n  return manage(res);\n}\n\nisl_size pw_multi_aff::dim(isl::dim type) const\n{\n  auto res = isl_pw_multi_aff_dim(get(), static_cast<enum isl_dim_type>(type));\n  return res;\n}\n\nset pw_multi_aff::domain() const\n{\n  auto res = isl_pw_multi_aff_domain(copy());\n  return manage(res);\n}\n\npw_multi_aff pw_multi_aff::domain_map(space space)\n{\n  auto res = isl_pw_multi_aff_domain_map(space.release());\n  return manage(res);\n}\n\npw_multi_aff pw_multi_aff::drop_dims(isl::dim type, unsigned int first, unsigned int n) const\n{\n  auto res = isl_pw_multi_aff_drop_dims(copy(), static_cast<enum isl_dim_type>(type), first, n);\n  return manage(res);\n}\n\npw_multi_aff pw_multi_aff::drop_unused_params() const\n{\n  auto res = isl_pw_multi_aff_drop_unused_params(copy());\n  return manage(res);\n}\n\npw_multi_aff pw_multi_aff::empty(space space)\n{\n  auto res = isl_pw_multi_aff_empty(space.release());\n  return manage(res);\n}\n\nint pw_multi_aff::find_dim_by_name(isl::dim type, const std::string &name) const\n{\n  auto res = isl_pw_multi_aff_find_dim_by_name(get(), static_cast<enum isl_dim_type>(type), name.c_str());\n  return res;\n}\n\npw_multi_aff pw_multi_aff::fix_si(isl::dim type, unsigned int pos, int value) const\n{\n  auto res = isl_pw_multi_aff_fix_si(copy(), static_cast<enum isl_dim_type>(type), pos, value);\n  return manage(res);\n}\n\npw_multi_aff pw_multi_aff::flat_range_product(pw_multi_aff pma2) const\n{\n  auto res = isl_pw_multi_aff_flat_range_product(copy(), pma2.release());\n  return manage(res);\n}\n\nstat pw_multi_aff::foreach_piece(const std::function<stat(set, multi_aff)> &fn) const\n{\n  struct fn_data {\n    const std::function<stat(set, multi_aff)> *func;\n  } fn_data = { &fn };\n  auto fn_lambda = [](isl_set *arg_0, isl_multi_aff *arg_1, void *arg_2) -> isl_stat {\n    auto *data = static_cast<struct fn_data *>(arg_2);\n    stat ret = (*data->func)(manage(arg_0), manage(arg_1));\n    return ret.release();\n  };\n  auto res = isl_pw_multi_aff_foreach_piece(get(), fn_lambda, &fn_data);\n  return manage(res);\n}\n\npw_multi_aff pw_multi_aff::from_domain(set set)\n{\n  auto res = isl_pw_multi_aff_from_domain(set.release());\n  return manage(res);\n}\n\npw_multi_aff pw_multi_aff::from_map(map map)\n{\n  auto res = isl_pw_multi_aff_from_map(map.release());\n  return manage(res);\n}\n\npw_multi_aff pw_multi_aff::from_multi_pw_aff(multi_pw_aff mpa)\n{\n  auto res = isl_pw_multi_aff_from_multi_pw_aff(mpa.release());\n  return manage(res);\n}\n\npw_multi_aff pw_multi_aff::from_set(set set)\n{\n  auto res = isl_pw_multi_aff_from_set(set.release());\n  return manage(res);\n}\n\nid pw_multi_aff::get_dim_id(isl::dim type, unsigned int pos) const\n{\n  auto res = isl_pw_multi_aff_get_dim_id(get(), static_cast<enum isl_dim_type>(type), pos);\n  return manage(res);\n}\n\nstd::string pw_multi_aff::get_dim_name(isl::dim type, unsigned int pos) const\n{\n  auto res = isl_pw_multi_aff_get_dim_name(get(), static_cast<enum isl_dim_type>(type), pos);\n  std::string tmp(res);\n  return tmp;\n}\n\nspace pw_multi_aff::get_domain_space() const\n{\n  auto res = isl_pw_multi_aff_get_domain_space(get());\n  return manage(res);\n}\n\npw_aff pw_multi_aff::get_pw_aff(int pos) const\n{\n  auto res = isl_pw_multi_aff_get_pw_aff(get(), pos);\n  return manage(res);\n}\n\nspace pw_multi_aff::get_space() const\n{\n  auto res = isl_pw_multi_aff_get_space(get());\n  return manage(res);\n}\n\nid pw_multi_aff::get_tuple_id(isl::dim type) const\n{\n  auto res = isl_pw_multi_aff_get_tuple_id(get(), static_cast<enum isl_dim_type>(type));\n  return manage(res);\n}\n\nstd::string pw_multi_aff::get_tuple_name(isl::dim type) const\n{\n  auto res = isl_pw_multi_aff_get_tuple_name(get(), static_cast<enum isl_dim_type>(type));\n  std::string tmp(res);\n  return tmp;\n}\n\npw_multi_aff pw_multi_aff::gist(set set) const\n{\n  auto res = isl_pw_multi_aff_gist(copy(), set.release());\n  return manage(res);\n}\n\npw_multi_aff pw_multi_aff::gist_params(set set) const\n{\n  auto res = isl_pw_multi_aff_gist_params(copy(), set.release());\n  return manage(res);\n}\n\nboolean pw_multi_aff::has_tuple_id(isl::dim type) const\n{\n  auto res = isl_pw_multi_aff_has_tuple_id(get(), static_cast<enum isl_dim_type>(type));\n  return manage(res);\n}\n\nboolean pw_multi_aff::has_tuple_name(isl::dim type) const\n{\n  auto res = isl_pw_multi_aff_has_tuple_name(get(), static_cast<enum isl_dim_type>(type));\n  return manage(res);\n}\n\npw_multi_aff pw_multi_aff::identity(space space)\n{\n  auto res = isl_pw_multi_aff_identity(space.release());\n  return manage(res);\n}\n\npw_multi_aff pw_multi_aff::identity_on_domain(space space)\n{\n  auto res = isl_pw_multi_aff_identity_on_domain_space(space.release());\n  return manage(res);\n}\n\npw_multi_aff pw_multi_aff::insert_domain(space domain) const\n{\n  auto res = isl_pw_multi_aff_insert_domain(copy(), domain.release());\n  return manage(res);\n}\n\npw_multi_aff pw_multi_aff::intersect_domain(set set) const\n{\n  auto res = isl_pw_multi_aff_intersect_domain(copy(), set.release());\n  return manage(res);\n}\n\npw_multi_aff pw_multi_aff::intersect_domain_wrapped_domain(set set) const\n{\n  auto res = isl_pw_multi_aff_intersect_domain_wrapped_domain(copy(), set.release());\n  return manage(res);\n}\n\npw_multi_aff pw_multi_aff::intersect_domain_wrapped_range(set set) const\n{\n  auto res = isl_pw_multi_aff_intersect_domain_wrapped_range(copy(), set.release());\n  return manage(res);\n}\n\npw_multi_aff pw_multi_aff::intersect_params(set set) const\n{\n  auto res = isl_pw_multi_aff_intersect_params(copy(), set.release());\n  return manage(res);\n}\n\nboolean pw_multi_aff::involves_dims(isl::dim type, unsigned int first, unsigned int n) const\n{\n  auto res = isl_pw_multi_aff_involves_dims(get(), static_cast<enum isl_dim_type>(type), first, n);\n  return manage(res);\n}\n\nboolean pw_multi_aff::involves_locals() const\n{\n  auto res = isl_pw_multi_aff_involves_locals(get());\n  return manage(res);\n}\n\nboolean pw_multi_aff::involves_nan() const\n{\n  auto res = isl_pw_multi_aff_involves_nan(get());\n  return manage(res);\n}\n\nboolean pw_multi_aff::involves_param_id(const id &id) const\n{\n  auto res = isl_pw_multi_aff_involves_param_id(get(), id.get());\n  return manage(res);\n}\n\nboolean pw_multi_aff::is_equal(const pw_multi_aff &pma2) const\n{\n  auto res = isl_pw_multi_aff_is_equal(get(), pma2.get());\n  return manage(res);\n}\n\nboolean pw_multi_aff::isa_multi_aff() const\n{\n  auto res = isl_pw_multi_aff_isa_multi_aff(get());\n  return manage(res);\n}\n\nmulti_val pw_multi_aff::max_multi_val() const\n{\n  auto res = isl_pw_multi_aff_max_multi_val(copy());\n  return manage(res);\n}\n\nmulti_val pw_multi_aff::min_multi_val() const\n{\n  auto res = isl_pw_multi_aff_min_multi_val(copy());\n  return manage(res);\n}\n\npw_multi_aff pw_multi_aff::multi_val_on_domain(set domain, multi_val mv)\n{\n  auto res = isl_pw_multi_aff_multi_val_on_domain(domain.release(), mv.release());\n  return manage(res);\n}\n\nisl_size pw_multi_aff::n_piece() const\n{\n  auto res = isl_pw_multi_aff_n_piece(get());\n  return res;\n}\n\npw_multi_aff pw_multi_aff::neg() const\n{\n  auto res = isl_pw_multi_aff_neg(copy());\n  return manage(res);\n}\n\nboolean pw_multi_aff::plain_is_equal(const pw_multi_aff &pma2) const\n{\n  auto res = isl_pw_multi_aff_plain_is_equal(get(), pma2.get());\n  return manage(res);\n}\n\npw_multi_aff pw_multi_aff::preimage_domain_wrapped_domain(pw_multi_aff pma2) const\n{\n  auto res = isl_pw_multi_aff_preimage_domain_wrapped_domain_pw_multi_aff(copy(), pma2.release());\n  return manage(res);\n}\n\npw_multi_aff pw_multi_aff::product(pw_multi_aff pma2) const\n{\n  auto res = isl_pw_multi_aff_product(copy(), pma2.release());\n  return manage(res);\n}\n\npw_multi_aff pw_multi_aff::project_domain_on_params() const\n{\n  auto res = isl_pw_multi_aff_project_domain_on_params(copy());\n  return manage(res);\n}\n\npw_multi_aff pw_multi_aff::project_out_map(space space, isl::dim type, unsigned int first, unsigned int n)\n{\n  auto res = isl_pw_multi_aff_project_out_map(space.release(), static_cast<enum isl_dim_type>(type), first, n);\n  return manage(res);\n}\n\npw_multi_aff pw_multi_aff::pullback(multi_aff ma) const\n{\n  auto res = isl_pw_multi_aff_pullback_multi_aff(copy(), ma.release());\n  return manage(res);\n}\n\npw_multi_aff pw_multi_aff::pullback(pw_multi_aff pma2) const\n{\n  auto res = isl_pw_multi_aff_pullback_pw_multi_aff(copy(), pma2.release());\n  return manage(res);\n}\n\npw_multi_aff pw_multi_aff::range_factor_domain() const\n{\n  auto res = isl_pw_multi_aff_range_factor_domain(copy());\n  return manage(res);\n}\n\npw_multi_aff pw_multi_aff::range_factor_range() const\n{\n  auto res = isl_pw_multi_aff_range_factor_range(copy());\n  return manage(res);\n}\n\npw_multi_aff pw_multi_aff::range_map(space space)\n{\n  auto res = isl_pw_multi_aff_range_map(space.release());\n  return manage(res);\n}\n\npw_multi_aff pw_multi_aff::range_product(pw_multi_aff pma2) const\n{\n  auto res = isl_pw_multi_aff_range_product(copy(), pma2.release());\n  return manage(res);\n}\n\npw_multi_aff pw_multi_aff::reset_tuple_id(isl::dim type) const\n{\n  auto res = isl_pw_multi_aff_reset_tuple_id(copy(), static_cast<enum isl_dim_type>(type));\n  return manage(res);\n}\n\npw_multi_aff pw_multi_aff::reset_user() const\n{\n  auto res = isl_pw_multi_aff_reset_user(copy());\n  return manage(res);\n}\n\npw_multi_aff pw_multi_aff::scale(val v) const\n{\n  auto res = isl_pw_multi_aff_scale_val(copy(), v.release());\n  return manage(res);\n}\n\npw_multi_aff pw_multi_aff::scale_down(val v) const\n{\n  auto res = isl_pw_multi_aff_scale_down_val(copy(), v.release());\n  return manage(res);\n}\n\npw_multi_aff pw_multi_aff::scale_multi_val(multi_val mv) const\n{\n  auto res = isl_pw_multi_aff_scale_multi_val(copy(), mv.release());\n  return manage(res);\n}\n\npw_multi_aff pw_multi_aff::set_dim_id(isl::dim type, unsigned int pos, id id) const\n{\n  auto res = isl_pw_multi_aff_set_dim_id(copy(), static_cast<enum isl_dim_type>(type), pos, id.release());\n  return manage(res);\n}\n\npw_multi_aff pw_multi_aff::set_pw_aff(unsigned int pos, pw_aff pa) const\n{\n  auto res = isl_pw_multi_aff_set_pw_aff(copy(), pos, pa.release());\n  return manage(res);\n}\n\npw_multi_aff pw_multi_aff::set_tuple_id(isl::dim type, id id) const\n{\n  auto res = isl_pw_multi_aff_set_tuple_id(copy(), static_cast<enum isl_dim_type>(type), id.release());\n  return manage(res);\n}\n\npw_multi_aff pw_multi_aff::sub(pw_multi_aff pma2) const\n{\n  auto res = isl_pw_multi_aff_sub(copy(), pma2.release());\n  return manage(res);\n}\n\npw_multi_aff pw_multi_aff::subtract_domain(set set) const\n{\n  auto res = isl_pw_multi_aff_subtract_domain(copy(), set.release());\n  return manage(res);\n}\n\npw_multi_aff pw_multi_aff::union_add(pw_multi_aff pma2) const\n{\n  auto res = isl_pw_multi_aff_union_add(copy(), pma2.release());\n  return manage(res);\n}\n\npw_multi_aff pw_multi_aff::union_lexmax(pw_multi_aff pma2) const\n{\n  auto res = isl_pw_multi_aff_union_lexmax(copy(), pma2.release());\n  return manage(res);\n}\n\npw_multi_aff pw_multi_aff::union_lexmin(pw_multi_aff pma2) const\n{\n  auto res = isl_pw_multi_aff_union_lexmin(copy(), pma2.release());\n  return manage(res);\n}\n\npw_multi_aff pw_multi_aff::zero(space space)\n{\n  auto res = isl_pw_multi_aff_zero(space.release());\n  return manage(res);\n}\n\n// implementations for isl::pw_multi_aff_list\npw_multi_aff_list manage(__isl_take isl_pw_multi_aff_list *ptr) {\n  return pw_multi_aff_list(ptr);\n}\npw_multi_aff_list manage_copy(__isl_keep isl_pw_multi_aff_list *ptr) {\n  ptr = isl_pw_multi_aff_list_copy(ptr);\n  return pw_multi_aff_list(ptr);\n}\n\npw_multi_aff_list::pw_multi_aff_list()\n    : ptr(nullptr) {}\n\npw_multi_aff_list::pw_multi_aff_list(const pw_multi_aff_list &obj)\n    : ptr(nullptr)\n{\n  ptr = obj.copy();\n}\npw_multi_aff_list::pw_multi_aff_list(std::nullptr_t)\n    : ptr(nullptr) {}\n\n\npw_multi_aff_list::pw_multi_aff_list(__isl_take isl_pw_multi_aff_list *ptr)\n    : ptr(ptr) {}\n\n\npw_multi_aff_list &pw_multi_aff_list::operator=(pw_multi_aff_list obj) {\n  std::swap(this->ptr, obj.ptr);\n  return *this;\n}\n\npw_multi_aff_list::~pw_multi_aff_list() {\n  if (ptr)\n    isl_pw_multi_aff_list_free(ptr);\n}\n\n__isl_give isl_pw_multi_aff_list *pw_multi_aff_list::copy() const & {\n  return isl_pw_multi_aff_list_copy(ptr);\n}\n\n__isl_keep isl_pw_multi_aff_list *pw_multi_aff_list::get() const {\n  return ptr;\n}\n\n__isl_give isl_pw_multi_aff_list *pw_multi_aff_list::release() {\n  isl_pw_multi_aff_list *tmp = ptr;\n  ptr = nullptr;\n  return tmp;\n}\n\nbool pw_multi_aff_list::is_null() const {\n  return ptr == nullptr;\n}\npw_multi_aff_list::operator bool() const {\n  return !is_null();\n}\n\n\nctx pw_multi_aff_list::get_ctx() const {\n  return ctx(isl_pw_multi_aff_list_get_ctx(ptr));\n}\nstd::string pw_multi_aff_list::to_str() const {\n  char *Tmp = isl_pw_multi_aff_list_to_str(get());\n  if (!Tmp)\n    return \"\";\n  std::string S(Tmp);\n  free(Tmp);\n  return S;\n}\n\n\nvoid pw_multi_aff_list::dump() const {\n  isl_pw_multi_aff_list_dump(get());\n}\n\n\npw_multi_aff_list pw_multi_aff_list::add(pw_multi_aff el) const\n{\n  auto res = isl_pw_multi_aff_list_add(copy(), el.release());\n  return manage(res);\n}\n\npw_multi_aff_list pw_multi_aff_list::alloc(ctx ctx, int n)\n{\n  auto res = isl_pw_multi_aff_list_alloc(ctx.release(), n);\n  return manage(res);\n}\n\npw_multi_aff_list pw_multi_aff_list::clear() const\n{\n  auto res = isl_pw_multi_aff_list_clear(copy());\n  return manage(res);\n}\n\npw_multi_aff_list pw_multi_aff_list::concat(pw_multi_aff_list list2) const\n{\n  auto res = isl_pw_multi_aff_list_concat(copy(), list2.release());\n  return manage(res);\n}\n\npw_multi_aff_list pw_multi_aff_list::drop(unsigned int first, unsigned int n) const\n{\n  auto res = isl_pw_multi_aff_list_drop(copy(), first, n);\n  return manage(res);\n}\n\nstat pw_multi_aff_list::foreach(const std::function<stat(pw_multi_aff)> &fn) const\n{\n  struct fn_data {\n    const std::function<stat(pw_multi_aff)> *func;\n  } fn_data = { &fn };\n  auto fn_lambda = [](isl_pw_multi_aff *arg_0, void *arg_1) -> isl_stat {\n    auto *data = static_cast<struct fn_data *>(arg_1);\n    stat ret = (*data->func)(manage(arg_0));\n    return ret.release();\n  };\n  auto res = isl_pw_multi_aff_list_foreach(get(), fn_lambda, &fn_data);\n  return manage(res);\n}\n\npw_multi_aff_list pw_multi_aff_list::from_pw_multi_aff(pw_multi_aff el)\n{\n  auto res = isl_pw_multi_aff_list_from_pw_multi_aff(el.release());\n  return manage(res);\n}\n\npw_multi_aff pw_multi_aff_list::get_at(int index) const\n{\n  auto res = isl_pw_multi_aff_list_get_at(get(), index);\n  return manage(res);\n}\n\npw_multi_aff pw_multi_aff_list::get_pw_multi_aff(int index) const\n{\n  auto res = isl_pw_multi_aff_list_get_pw_multi_aff(get(), index);\n  return manage(res);\n}\n\npw_multi_aff_list pw_multi_aff_list::insert(unsigned int pos, pw_multi_aff el) const\n{\n  auto res = isl_pw_multi_aff_list_insert(copy(), pos, el.release());\n  return manage(res);\n}\n\nisl_size pw_multi_aff_list::n_pw_multi_aff() const\n{\n  auto res = isl_pw_multi_aff_list_n_pw_multi_aff(get());\n  return res;\n}\n\npw_multi_aff_list pw_multi_aff_list::reverse() const\n{\n  auto res = isl_pw_multi_aff_list_reverse(copy());\n  return manage(res);\n}\n\npw_multi_aff_list pw_multi_aff_list::set_pw_multi_aff(int index, pw_multi_aff el) const\n{\n  auto res = isl_pw_multi_aff_list_set_pw_multi_aff(copy(), index, el.release());\n  return manage(res);\n}\n\nisl_size pw_multi_aff_list::size() const\n{\n  auto res = isl_pw_multi_aff_list_size(get());\n  return res;\n}\n\npw_multi_aff_list pw_multi_aff_list::swap(unsigned int pos1, unsigned int pos2) const\n{\n  auto res = isl_pw_multi_aff_list_swap(copy(), pos1, pos2);\n  return manage(res);\n}\n\n// implementations for isl::pw_qpolynomial\npw_qpolynomial manage(__isl_take isl_pw_qpolynomial *ptr) {\n  return pw_qpolynomial(ptr);\n}\npw_qpolynomial manage_copy(__isl_keep isl_pw_qpolynomial *ptr) {\n  ptr = isl_pw_qpolynomial_copy(ptr);\n  return pw_qpolynomial(ptr);\n}\n\npw_qpolynomial::pw_qpolynomial()\n    : ptr(nullptr) {}\n\npw_qpolynomial::pw_qpolynomial(const pw_qpolynomial &obj)\n    : ptr(nullptr)\n{\n  ptr = obj.copy();\n}\npw_qpolynomial::pw_qpolynomial(std::nullptr_t)\n    : ptr(nullptr) {}\n\n\npw_qpolynomial::pw_qpolynomial(__isl_take isl_pw_qpolynomial *ptr)\n    : ptr(ptr) {}\n\npw_qpolynomial::pw_qpolynomial(ctx ctx, const std::string &str)\n{\n  auto res = isl_pw_qpolynomial_read_from_str(ctx.release(), str.c_str());\n  ptr = res;\n}\n\npw_qpolynomial &pw_qpolynomial::operator=(pw_qpolynomial obj) {\n  std::swap(this->ptr, obj.ptr);\n  return *this;\n}\n\npw_qpolynomial::~pw_qpolynomial() {\n  if (ptr)\n    isl_pw_qpolynomial_free(ptr);\n}\n\n__isl_give isl_pw_qpolynomial *pw_qpolynomial::copy() const & {\n  return isl_pw_qpolynomial_copy(ptr);\n}\n\n__isl_keep isl_pw_qpolynomial *pw_qpolynomial::get() const {\n  return ptr;\n}\n\n__isl_give isl_pw_qpolynomial *pw_qpolynomial::release() {\n  isl_pw_qpolynomial *tmp = ptr;\n  ptr = nullptr;\n  return tmp;\n}\n\nbool pw_qpolynomial::is_null() const {\n  return ptr == nullptr;\n}\npw_qpolynomial::operator bool() const {\n  return !is_null();\n}\n\n\nctx pw_qpolynomial::get_ctx() const {\n  return ctx(isl_pw_qpolynomial_get_ctx(ptr));\n}\nstd::string pw_qpolynomial::to_str() const {\n  char *Tmp = isl_pw_qpolynomial_to_str(get());\n  if (!Tmp)\n    return \"\";\n  std::string S(Tmp);\n  free(Tmp);\n  return S;\n}\n\n\nvoid pw_qpolynomial::dump() const {\n  isl_pw_qpolynomial_dump(get());\n}\n\n\npw_qpolynomial pw_qpolynomial::add(pw_qpolynomial pwqp2) const\n{\n  auto res = isl_pw_qpolynomial_add(copy(), pwqp2.release());\n  return manage(res);\n}\n\npw_qpolynomial pw_qpolynomial::add_dims(isl::dim type, unsigned int n) const\n{\n  auto res = isl_pw_qpolynomial_add_dims(copy(), static_cast<enum isl_dim_type>(type), n);\n  return manage(res);\n}\n\npw_qpolynomial pw_qpolynomial::alloc(set set, qpolynomial qp)\n{\n  auto res = isl_pw_qpolynomial_alloc(set.release(), qp.release());\n  return manage(res);\n}\n\nqpolynomial pw_qpolynomial::as_qpolynomial() const\n{\n  auto res = isl_pw_qpolynomial_as_qpolynomial(copy());\n  return manage(res);\n}\n\npw_qpolynomial pw_qpolynomial::coalesce() const\n{\n  auto res = isl_pw_qpolynomial_coalesce(copy());\n  return manage(res);\n}\n\nisl_size pw_qpolynomial::dim(isl::dim type) const\n{\n  auto res = isl_pw_qpolynomial_dim(get(), static_cast<enum isl_dim_type>(type));\n  return res;\n}\n\nset pw_qpolynomial::domain() const\n{\n  auto res = isl_pw_qpolynomial_domain(copy());\n  return manage(res);\n}\n\npw_qpolynomial pw_qpolynomial::drop_dims(isl::dim type, unsigned int first, unsigned int n) const\n{\n  auto res = isl_pw_qpolynomial_drop_dims(copy(), static_cast<enum isl_dim_type>(type), first, n);\n  return manage(res);\n}\n\npw_qpolynomial pw_qpolynomial::drop_unused_params() const\n{\n  auto res = isl_pw_qpolynomial_drop_unused_params(copy());\n  return manage(res);\n}\n\nval pw_qpolynomial::eval(point pnt) const\n{\n  auto res = isl_pw_qpolynomial_eval(copy(), pnt.release());\n  return manage(res);\n}\n\nint pw_qpolynomial::find_dim_by_name(isl::dim type, const std::string &name) const\n{\n  auto res = isl_pw_qpolynomial_find_dim_by_name(get(), static_cast<enum isl_dim_type>(type), name.c_str());\n  return res;\n}\n\npw_qpolynomial pw_qpolynomial::fix_val(isl::dim type, unsigned int n, val v) const\n{\n  auto res = isl_pw_qpolynomial_fix_val(copy(), static_cast<enum isl_dim_type>(type), n, v.release());\n  return manage(res);\n}\n\nstat pw_qpolynomial::foreach_piece(const std::function<stat(set, qpolynomial)> &fn) const\n{\n  struct fn_data {\n    const std::function<stat(set, qpolynomial)> *func;\n  } fn_data = { &fn };\n  auto fn_lambda = [](isl_set *arg_0, isl_qpolynomial *arg_1, void *arg_2) -> isl_stat {\n    auto *data = static_cast<struct fn_data *>(arg_2);\n    stat ret = (*data->func)(manage(arg_0), manage(arg_1));\n    return ret.release();\n  };\n  auto res = isl_pw_qpolynomial_foreach_piece(get(), fn_lambda, &fn_data);\n  return manage(res);\n}\n\npw_qpolynomial pw_qpolynomial::from_pw_aff(pw_aff pwaff)\n{\n  auto res = isl_pw_qpolynomial_from_pw_aff(pwaff.release());\n  return manage(res);\n}\n\npw_qpolynomial pw_qpolynomial::from_qpolynomial(qpolynomial qp)\n{\n  auto res = isl_pw_qpolynomial_from_qpolynomial(qp.release());\n  return manage(res);\n}\n\npw_qpolynomial pw_qpolynomial::from_range() const\n{\n  auto res = isl_pw_qpolynomial_from_range(copy());\n  return manage(res);\n}\n\nspace pw_qpolynomial::get_domain_space() const\n{\n  auto res = isl_pw_qpolynomial_get_domain_space(get());\n  return manage(res);\n}\n\nspace pw_qpolynomial::get_space() const\n{\n  auto res = isl_pw_qpolynomial_get_space(get());\n  return manage(res);\n}\n\npw_qpolynomial pw_qpolynomial::gist(set context) const\n{\n  auto res = isl_pw_qpolynomial_gist(copy(), context.release());\n  return manage(res);\n}\n\npw_qpolynomial pw_qpolynomial::gist_params(set context) const\n{\n  auto res = isl_pw_qpolynomial_gist_params(copy(), context.release());\n  return manage(res);\n}\n\nboolean pw_qpolynomial::has_equal_space(const pw_qpolynomial &pwqp2) const\n{\n  auto res = isl_pw_qpolynomial_has_equal_space(get(), pwqp2.get());\n  return manage(res);\n}\n\npw_qpolynomial pw_qpolynomial::insert_dims(isl::dim type, unsigned int first, unsigned int n) const\n{\n  auto res = isl_pw_qpolynomial_insert_dims(copy(), static_cast<enum isl_dim_type>(type), first, n);\n  return manage(res);\n}\n\npw_qpolynomial pw_qpolynomial::intersect_domain(set set) const\n{\n  auto res = isl_pw_qpolynomial_intersect_domain(copy(), set.release());\n  return manage(res);\n}\n\npw_qpolynomial pw_qpolynomial::intersect_domain_wrapped_domain(set set) const\n{\n  auto res = isl_pw_qpolynomial_intersect_domain_wrapped_domain(copy(), set.release());\n  return manage(res);\n}\n\npw_qpolynomial pw_qpolynomial::intersect_domain_wrapped_range(set set) const\n{\n  auto res = isl_pw_qpolynomial_intersect_domain_wrapped_range(copy(), set.release());\n  return manage(res);\n}\n\npw_qpolynomial pw_qpolynomial::intersect_params(set set) const\n{\n  auto res = isl_pw_qpolynomial_intersect_params(copy(), set.release());\n  return manage(res);\n}\n\nboolean pw_qpolynomial::involves_dims(isl::dim type, unsigned int first, unsigned int n) const\n{\n  auto res = isl_pw_qpolynomial_involves_dims(get(), static_cast<enum isl_dim_type>(type), first, n);\n  return manage(res);\n}\n\nboolean pw_qpolynomial::involves_nan() const\n{\n  auto res = isl_pw_qpolynomial_involves_nan(get());\n  return manage(res);\n}\n\nboolean pw_qpolynomial::involves_param_id(const id &id) const\n{\n  auto res = isl_pw_qpolynomial_involves_param_id(get(), id.get());\n  return manage(res);\n}\n\nboolean pw_qpolynomial::is_zero() const\n{\n  auto res = isl_pw_qpolynomial_is_zero(get());\n  return manage(res);\n}\n\nboolean pw_qpolynomial::isa_qpolynomial() const\n{\n  auto res = isl_pw_qpolynomial_isa_qpolynomial(get());\n  return manage(res);\n}\n\nval pw_qpolynomial::max() const\n{\n  auto res = isl_pw_qpolynomial_max(copy());\n  return manage(res);\n}\n\nval pw_qpolynomial::min() const\n{\n  auto res = isl_pw_qpolynomial_min(copy());\n  return manage(res);\n}\n\npw_qpolynomial pw_qpolynomial::move_dims(isl::dim dst_type, unsigned int dst_pos, isl::dim src_type, unsigned int src_pos, unsigned int n) const\n{\n  auto res = isl_pw_qpolynomial_move_dims(copy(), static_cast<enum isl_dim_type>(dst_type), dst_pos, static_cast<enum isl_dim_type>(src_type), src_pos, n);\n  return manage(res);\n}\n\npw_qpolynomial pw_qpolynomial::mul(pw_qpolynomial pwqp2) const\n{\n  auto res = isl_pw_qpolynomial_mul(copy(), pwqp2.release());\n  return manage(res);\n}\n\nisl_size pw_qpolynomial::n_piece() const\n{\n  auto res = isl_pw_qpolynomial_n_piece(get());\n  return res;\n}\n\npw_qpolynomial pw_qpolynomial::neg() const\n{\n  auto res = isl_pw_qpolynomial_neg(copy());\n  return manage(res);\n}\n\nboolean pw_qpolynomial::plain_is_equal(const pw_qpolynomial &pwqp2) const\n{\n  auto res = isl_pw_qpolynomial_plain_is_equal(get(), pwqp2.get());\n  return manage(res);\n}\n\npw_qpolynomial pw_qpolynomial::pow(unsigned int exponent) const\n{\n  auto res = isl_pw_qpolynomial_pow(copy(), exponent);\n  return manage(res);\n}\n\npw_qpolynomial pw_qpolynomial::project_domain_on_params() const\n{\n  auto res = isl_pw_qpolynomial_project_domain_on_params(copy());\n  return manage(res);\n}\n\npw_qpolynomial pw_qpolynomial::reset_domain_space(space space) const\n{\n  auto res = isl_pw_qpolynomial_reset_domain_space(copy(), space.release());\n  return manage(res);\n}\n\npw_qpolynomial pw_qpolynomial::reset_user() const\n{\n  auto res = isl_pw_qpolynomial_reset_user(copy());\n  return manage(res);\n}\n\npw_qpolynomial pw_qpolynomial::scale_down_val(val v) const\n{\n  auto res = isl_pw_qpolynomial_scale_down_val(copy(), v.release());\n  return manage(res);\n}\n\npw_qpolynomial pw_qpolynomial::scale_val(val v) const\n{\n  auto res = isl_pw_qpolynomial_scale_val(copy(), v.release());\n  return manage(res);\n}\n\npw_qpolynomial pw_qpolynomial::split_dims(isl::dim type, unsigned int first, unsigned int n) const\n{\n  auto res = isl_pw_qpolynomial_split_dims(copy(), static_cast<enum isl_dim_type>(type), first, n);\n  return manage(res);\n}\n\npw_qpolynomial pw_qpolynomial::split_periods(int max_periods) const\n{\n  auto res = isl_pw_qpolynomial_split_periods(copy(), max_periods);\n  return manage(res);\n}\n\npw_qpolynomial pw_qpolynomial::sub(pw_qpolynomial pwqp2) const\n{\n  auto res = isl_pw_qpolynomial_sub(copy(), pwqp2.release());\n  return manage(res);\n}\n\npw_qpolynomial pw_qpolynomial::subtract_domain(set set) const\n{\n  auto res = isl_pw_qpolynomial_subtract_domain(copy(), set.release());\n  return manage(res);\n}\n\npw_qpolynomial pw_qpolynomial::to_polynomial(int sign) const\n{\n  auto res = isl_pw_qpolynomial_to_polynomial(copy(), sign);\n  return manage(res);\n}\n\npw_qpolynomial pw_qpolynomial::zero(space space)\n{\n  auto res = isl_pw_qpolynomial_zero(space.release());\n  return manage(res);\n}\n\n// implementations for isl::pw_qpolynomial_fold_list\npw_qpolynomial_fold_list manage(__isl_take isl_pw_qpolynomial_fold_list *ptr) {\n  return pw_qpolynomial_fold_list(ptr);\n}\npw_qpolynomial_fold_list manage_copy(__isl_keep isl_pw_qpolynomial_fold_list *ptr) {\n  ptr = isl_pw_qpolynomial_fold_list_copy(ptr);\n  return pw_qpolynomial_fold_list(ptr);\n}\n\npw_qpolynomial_fold_list::pw_qpolynomial_fold_list()\n    : ptr(nullptr) {}\n\npw_qpolynomial_fold_list::pw_qpolynomial_fold_list(const pw_qpolynomial_fold_list &obj)\n    : ptr(nullptr)\n{\n  ptr = obj.copy();\n}\npw_qpolynomial_fold_list::pw_qpolynomial_fold_list(std::nullptr_t)\n    : ptr(nullptr) {}\n\n\npw_qpolynomial_fold_list::pw_qpolynomial_fold_list(__isl_take isl_pw_qpolynomial_fold_list *ptr)\n    : ptr(ptr) {}\n\n\npw_qpolynomial_fold_list &pw_qpolynomial_fold_list::operator=(pw_qpolynomial_fold_list obj) {\n  std::swap(this->ptr, obj.ptr);\n  return *this;\n}\n\npw_qpolynomial_fold_list::~pw_qpolynomial_fold_list() {\n  if (ptr)\n    isl_pw_qpolynomial_fold_list_free(ptr);\n}\n\n__isl_give isl_pw_qpolynomial_fold_list *pw_qpolynomial_fold_list::copy() const & {\n  return isl_pw_qpolynomial_fold_list_copy(ptr);\n}\n\n__isl_keep isl_pw_qpolynomial_fold_list *pw_qpolynomial_fold_list::get() const {\n  return ptr;\n}\n\n__isl_give isl_pw_qpolynomial_fold_list *pw_qpolynomial_fold_list::release() {\n  isl_pw_qpolynomial_fold_list *tmp = ptr;\n  ptr = nullptr;\n  return tmp;\n}\n\nbool pw_qpolynomial_fold_list::is_null() const {\n  return ptr == nullptr;\n}\npw_qpolynomial_fold_list::operator bool() const {\n  return !is_null();\n}\n\n\nctx pw_qpolynomial_fold_list::get_ctx() const {\n  return ctx(isl_pw_qpolynomial_fold_list_get_ctx(ptr));\n}\nstd::string pw_qpolynomial_fold_list::to_str() const {\n  char *Tmp = isl_pw_qpolynomial_fold_list_to_str(get());\n  if (!Tmp)\n    return \"\";\n  std::string S(Tmp);\n  free(Tmp);\n  return S;\n}\n\n\nvoid pw_qpolynomial_fold_list::dump() const {\n  isl_pw_qpolynomial_fold_list_dump(get());\n}\n\n\n\n// implementations for isl::pw_qpolynomial_list\npw_qpolynomial_list manage(__isl_take isl_pw_qpolynomial_list *ptr) {\n  return pw_qpolynomial_list(ptr);\n}\npw_qpolynomial_list manage_copy(__isl_keep isl_pw_qpolynomial_list *ptr) {\n  ptr = isl_pw_qpolynomial_list_copy(ptr);\n  return pw_qpolynomial_list(ptr);\n}\n\npw_qpolynomial_list::pw_qpolynomial_list()\n    : ptr(nullptr) {}\n\npw_qpolynomial_list::pw_qpolynomial_list(const pw_qpolynomial_list &obj)\n    : ptr(nullptr)\n{\n  ptr = obj.copy();\n}\npw_qpolynomial_list::pw_qpolynomial_list(std::nullptr_t)\n    : ptr(nullptr) {}\n\n\npw_qpolynomial_list::pw_qpolynomial_list(__isl_take isl_pw_qpolynomial_list *ptr)\n    : ptr(ptr) {}\n\n\npw_qpolynomial_list &pw_qpolynomial_list::operator=(pw_qpolynomial_list obj) {\n  std::swap(this->ptr, obj.ptr);\n  return *this;\n}\n\npw_qpolynomial_list::~pw_qpolynomial_list() {\n  if (ptr)\n    isl_pw_qpolynomial_list_free(ptr);\n}\n\n__isl_give isl_pw_qpolynomial_list *pw_qpolynomial_list::copy() const & {\n  return isl_pw_qpolynomial_list_copy(ptr);\n}\n\n__isl_keep isl_pw_qpolynomial_list *pw_qpolynomial_list::get() const {\n  return ptr;\n}\n\n__isl_give isl_pw_qpolynomial_list *pw_qpolynomial_list::release() {\n  isl_pw_qpolynomial_list *tmp = ptr;\n  ptr = nullptr;\n  return tmp;\n}\n\nbool pw_qpolynomial_list::is_null() const {\n  return ptr == nullptr;\n}\npw_qpolynomial_list::operator bool() const {\n  return !is_null();\n}\n\n\nctx pw_qpolynomial_list::get_ctx() const {\n  return ctx(isl_pw_qpolynomial_list_get_ctx(ptr));\n}\nstd::string pw_qpolynomial_list::to_str() const {\n  char *Tmp = isl_pw_qpolynomial_list_to_str(get());\n  if (!Tmp)\n    return \"\";\n  std::string S(Tmp);\n  free(Tmp);\n  return S;\n}\n\n\nvoid pw_qpolynomial_list::dump() const {\n  isl_pw_qpolynomial_list_dump(get());\n}\n\n\npw_qpolynomial_list pw_qpolynomial_list::add(pw_qpolynomial el) const\n{\n  auto res = isl_pw_qpolynomial_list_add(copy(), el.release());\n  return manage(res);\n}\n\npw_qpolynomial_list pw_qpolynomial_list::alloc(ctx ctx, int n)\n{\n  auto res = isl_pw_qpolynomial_list_alloc(ctx.release(), n);\n  return manage(res);\n}\n\npw_qpolynomial_list pw_qpolynomial_list::clear() const\n{\n  auto res = isl_pw_qpolynomial_list_clear(copy());\n  return manage(res);\n}\n\npw_qpolynomial_list pw_qpolynomial_list::concat(pw_qpolynomial_list list2) const\n{\n  auto res = isl_pw_qpolynomial_list_concat(copy(), list2.release());\n  return manage(res);\n}\n\npw_qpolynomial_list pw_qpolynomial_list::drop(unsigned int first, unsigned int n) const\n{\n  auto res = isl_pw_qpolynomial_list_drop(copy(), first, n);\n  return manage(res);\n}\n\nstat pw_qpolynomial_list::foreach(const std::function<stat(pw_qpolynomial)> &fn) const\n{\n  struct fn_data {\n    const std::function<stat(pw_qpolynomial)> *func;\n  } fn_data = { &fn };\n  auto fn_lambda = [](isl_pw_qpolynomial *arg_0, void *arg_1) -> isl_stat {\n    auto *data = static_cast<struct fn_data *>(arg_1);\n    stat ret = (*data->func)(manage(arg_0));\n    return ret.release();\n  };\n  auto res = isl_pw_qpolynomial_list_foreach(get(), fn_lambda, &fn_data);\n  return manage(res);\n}\n\npw_qpolynomial_list pw_qpolynomial_list::from_pw_qpolynomial(pw_qpolynomial el)\n{\n  auto res = isl_pw_qpolynomial_list_from_pw_qpolynomial(el.release());\n  return manage(res);\n}\n\npw_qpolynomial pw_qpolynomial_list::get_at(int index) const\n{\n  auto res = isl_pw_qpolynomial_list_get_at(get(), index);\n  return manage(res);\n}\n\npw_qpolynomial pw_qpolynomial_list::get_pw_qpolynomial(int index) const\n{\n  auto res = isl_pw_qpolynomial_list_get_pw_qpolynomial(get(), index);\n  return manage(res);\n}\n\npw_qpolynomial_list pw_qpolynomial_list::insert(unsigned int pos, pw_qpolynomial el) const\n{\n  auto res = isl_pw_qpolynomial_list_insert(copy(), pos, el.release());\n  return manage(res);\n}\n\nisl_size pw_qpolynomial_list::n_pw_qpolynomial() const\n{\n  auto res = isl_pw_qpolynomial_list_n_pw_qpolynomial(get());\n  return res;\n}\n\npw_qpolynomial_list pw_qpolynomial_list::reverse() const\n{\n  auto res = isl_pw_qpolynomial_list_reverse(copy());\n  return manage(res);\n}\n\npw_qpolynomial_list pw_qpolynomial_list::set_pw_qpolynomial(int index, pw_qpolynomial el) const\n{\n  auto res = isl_pw_qpolynomial_list_set_pw_qpolynomial(copy(), index, el.release());\n  return manage(res);\n}\n\nisl_size pw_qpolynomial_list::size() const\n{\n  auto res = isl_pw_qpolynomial_list_size(get());\n  return res;\n}\n\npw_qpolynomial_list pw_qpolynomial_list::swap(unsigned int pos1, unsigned int pos2) const\n{\n  auto res = isl_pw_qpolynomial_list_swap(copy(), pos1, pos2);\n  return manage(res);\n}\n\n// implementations for isl::qpolynomial\nqpolynomial manage(__isl_take isl_qpolynomial *ptr) {\n  return qpolynomial(ptr);\n}\nqpolynomial manage_copy(__isl_keep isl_qpolynomial *ptr) {\n  ptr = isl_qpolynomial_copy(ptr);\n  return qpolynomial(ptr);\n}\n\nqpolynomial::qpolynomial()\n    : ptr(nullptr) {}\n\nqpolynomial::qpolynomial(const qpolynomial &obj)\n    : ptr(nullptr)\n{\n  ptr = obj.copy();\n}\nqpolynomial::qpolynomial(std::nullptr_t)\n    : ptr(nullptr) {}\n\n\nqpolynomial::qpolynomial(__isl_take isl_qpolynomial *ptr)\n    : ptr(ptr) {}\n\n\nqpolynomial &qpolynomial::operator=(qpolynomial obj) {\n  std::swap(this->ptr, obj.ptr);\n  return *this;\n}\n\nqpolynomial::~qpolynomial() {\n  if (ptr)\n    isl_qpolynomial_free(ptr);\n}\n\n__isl_give isl_qpolynomial *qpolynomial::copy() const & {\n  return isl_qpolynomial_copy(ptr);\n}\n\n__isl_keep isl_qpolynomial *qpolynomial::get() const {\n  return ptr;\n}\n\n__isl_give isl_qpolynomial *qpolynomial::release() {\n  isl_qpolynomial *tmp = ptr;\n  ptr = nullptr;\n  return tmp;\n}\n\nbool qpolynomial::is_null() const {\n  return ptr == nullptr;\n}\nqpolynomial::operator bool() const {\n  return !is_null();\n}\n\n\nctx qpolynomial::get_ctx() const {\n  return ctx(isl_qpolynomial_get_ctx(ptr));\n}\n\nvoid qpolynomial::dump() const {\n  isl_qpolynomial_dump(get());\n}\n\n\nqpolynomial qpolynomial::add(qpolynomial qp2) const\n{\n  auto res = isl_qpolynomial_add(copy(), qp2.release());\n  return manage(res);\n}\n\nqpolynomial qpolynomial::add_dims(isl::dim type, unsigned int n) const\n{\n  auto res = isl_qpolynomial_add_dims(copy(), static_cast<enum isl_dim_type>(type), n);\n  return manage(res);\n}\n\nqpolynomial qpolynomial::align_params(space model) const\n{\n  auto res = isl_qpolynomial_align_params(copy(), model.release());\n  return manage(res);\n}\n\nstat qpolynomial::as_polynomial_on_domain(const basic_set &bset, const std::function<stat(basic_set, qpolynomial)> &fn) const\n{\n  struct fn_data {\n    const std::function<stat(basic_set, qpolynomial)> *func;\n  } fn_data = { &fn };\n  auto fn_lambda = [](isl_basic_set *arg_0, isl_qpolynomial *arg_1, void *arg_2) -> isl_stat {\n    auto *data = static_cast<struct fn_data *>(arg_2);\n    stat ret = (*data->func)(manage(arg_0), manage(arg_1));\n    return ret.release();\n  };\n  auto res = isl_qpolynomial_as_polynomial_on_domain(get(), bset.get(), fn_lambda, &fn_data);\n  return manage(res);\n}\n\nisl_size qpolynomial::dim(isl::dim type) const\n{\n  auto res = isl_qpolynomial_dim(get(), static_cast<enum isl_dim_type>(type));\n  return res;\n}\n\nqpolynomial qpolynomial::drop_dims(isl::dim type, unsigned int first, unsigned int n) const\n{\n  auto res = isl_qpolynomial_drop_dims(copy(), static_cast<enum isl_dim_type>(type), first, n);\n  return manage(res);\n}\n\nval qpolynomial::eval(point pnt) const\n{\n  auto res = isl_qpolynomial_eval(copy(), pnt.release());\n  return manage(res);\n}\n\nstat qpolynomial::foreach_term(const std::function<stat(term)> &fn) const\n{\n  struct fn_data {\n    const std::function<stat(term)> *func;\n  } fn_data = { &fn };\n  auto fn_lambda = [](isl_term *arg_0, void *arg_1) -> isl_stat {\n    auto *data = static_cast<struct fn_data *>(arg_1);\n    stat ret = (*data->func)(manage(arg_0));\n    return ret.release();\n  };\n  auto res = isl_qpolynomial_foreach_term(get(), fn_lambda, &fn_data);\n  return manage(res);\n}\n\nqpolynomial qpolynomial::from_aff(aff aff)\n{\n  auto res = isl_qpolynomial_from_aff(aff.release());\n  return manage(res);\n}\n\nqpolynomial qpolynomial::from_constraint(constraint c, isl::dim type, unsigned int pos)\n{\n  auto res = isl_qpolynomial_from_constraint(c.release(), static_cast<enum isl_dim_type>(type), pos);\n  return manage(res);\n}\n\nqpolynomial qpolynomial::from_term(term term)\n{\n  auto res = isl_qpolynomial_from_term(term.release());\n  return manage(res);\n}\n\nval qpolynomial::get_constant_val() const\n{\n  auto res = isl_qpolynomial_get_constant_val(get());\n  return manage(res);\n}\n\nspace qpolynomial::get_domain_space() const\n{\n  auto res = isl_qpolynomial_get_domain_space(get());\n  return manage(res);\n}\n\nspace qpolynomial::get_space() const\n{\n  auto res = isl_qpolynomial_get_space(get());\n  return manage(res);\n}\n\nqpolynomial qpolynomial::gist(set context) const\n{\n  auto res = isl_qpolynomial_gist(copy(), context.release());\n  return manage(res);\n}\n\nqpolynomial qpolynomial::gist_params(set context) const\n{\n  auto res = isl_qpolynomial_gist_params(copy(), context.release());\n  return manage(res);\n}\n\nqpolynomial qpolynomial::homogenize() const\n{\n  auto res = isl_qpolynomial_homogenize(copy());\n  return manage(res);\n}\n\nqpolynomial qpolynomial::infty_on_domain(space domain)\n{\n  auto res = isl_qpolynomial_infty_on_domain(domain.release());\n  return manage(res);\n}\n\nqpolynomial qpolynomial::insert_dims(isl::dim type, unsigned int first, unsigned int n) const\n{\n  auto res = isl_qpolynomial_insert_dims(copy(), static_cast<enum isl_dim_type>(type), first, n);\n  return manage(res);\n}\n\nboolean qpolynomial::involves_dims(isl::dim type, unsigned int first, unsigned int n) const\n{\n  auto res = isl_qpolynomial_involves_dims(get(), static_cast<enum isl_dim_type>(type), first, n);\n  return manage(res);\n}\n\nboolean qpolynomial::is_infty() const\n{\n  auto res = isl_qpolynomial_is_infty(get());\n  return manage(res);\n}\n\nboolean qpolynomial::is_nan() const\n{\n  auto res = isl_qpolynomial_is_nan(get());\n  return manage(res);\n}\n\nboolean qpolynomial::is_neginfty() const\n{\n  auto res = isl_qpolynomial_is_neginfty(get());\n  return manage(res);\n}\n\nboolean qpolynomial::is_zero() const\n{\n  auto res = isl_qpolynomial_is_zero(get());\n  return manage(res);\n}\n\nqpolynomial qpolynomial::move_dims(isl::dim dst_type, unsigned int dst_pos, isl::dim src_type, unsigned int src_pos, unsigned int n) const\n{\n  auto res = isl_qpolynomial_move_dims(copy(), static_cast<enum isl_dim_type>(dst_type), dst_pos, static_cast<enum isl_dim_type>(src_type), src_pos, n);\n  return manage(res);\n}\n\nqpolynomial qpolynomial::mul(qpolynomial qp2) const\n{\n  auto res = isl_qpolynomial_mul(copy(), qp2.release());\n  return manage(res);\n}\n\nqpolynomial qpolynomial::nan_on_domain(space domain)\n{\n  auto res = isl_qpolynomial_nan_on_domain(domain.release());\n  return manage(res);\n}\n\nqpolynomial qpolynomial::neg() const\n{\n  auto res = isl_qpolynomial_neg(copy());\n  return manage(res);\n}\n\nqpolynomial qpolynomial::neginfty_on_domain(space domain)\n{\n  auto res = isl_qpolynomial_neginfty_on_domain(domain.release());\n  return manage(res);\n}\n\nqpolynomial qpolynomial::one_on_domain(space domain)\n{\n  auto res = isl_qpolynomial_one_on_domain(domain.release());\n  return manage(res);\n}\n\nboolean qpolynomial::plain_is_equal(const qpolynomial &qp2) const\n{\n  auto res = isl_qpolynomial_plain_is_equal(get(), qp2.get());\n  return manage(res);\n}\n\nqpolynomial qpolynomial::pow(unsigned int power) const\n{\n  auto res = isl_qpolynomial_pow(copy(), power);\n  return manage(res);\n}\n\nqpolynomial qpolynomial::project_domain_on_params() const\n{\n  auto res = isl_qpolynomial_project_domain_on_params(copy());\n  return manage(res);\n}\n\nqpolynomial qpolynomial::scale_down_val(val v) const\n{\n  auto res = isl_qpolynomial_scale_down_val(copy(), v.release());\n  return manage(res);\n}\n\nqpolynomial qpolynomial::scale_val(val v) const\n{\n  auto res = isl_qpolynomial_scale_val(copy(), v.release());\n  return manage(res);\n}\n\nint qpolynomial::sgn() const\n{\n  auto res = isl_qpolynomial_sgn(get());\n  return res;\n}\n\nqpolynomial qpolynomial::sub(qpolynomial qp2) const\n{\n  auto res = isl_qpolynomial_sub(copy(), qp2.release());\n  return manage(res);\n}\n\nqpolynomial qpolynomial::val_on_domain(space space, val val)\n{\n  auto res = isl_qpolynomial_val_on_domain(space.release(), val.release());\n  return manage(res);\n}\n\nqpolynomial qpolynomial::var_on_domain(space domain, isl::dim type, unsigned int pos)\n{\n  auto res = isl_qpolynomial_var_on_domain(domain.release(), static_cast<enum isl_dim_type>(type), pos);\n  return manage(res);\n}\n\nqpolynomial qpolynomial::zero_on_domain(space domain)\n{\n  auto res = isl_qpolynomial_zero_on_domain(domain.release());\n  return manage(res);\n}\n\n// implementations for isl::qpolynomial_list\nqpolynomial_list manage(__isl_take isl_qpolynomial_list *ptr) {\n  return qpolynomial_list(ptr);\n}\nqpolynomial_list manage_copy(__isl_keep isl_qpolynomial_list *ptr) {\n  ptr = isl_qpolynomial_list_copy(ptr);\n  return qpolynomial_list(ptr);\n}\n\nqpolynomial_list::qpolynomial_list()\n    : ptr(nullptr) {}\n\nqpolynomial_list::qpolynomial_list(const qpolynomial_list &obj)\n    : ptr(nullptr)\n{\n  ptr = obj.copy();\n}\nqpolynomial_list::qpolynomial_list(std::nullptr_t)\n    : ptr(nullptr) {}\n\n\nqpolynomial_list::qpolynomial_list(__isl_take isl_qpolynomial_list *ptr)\n    : ptr(ptr) {}\n\n\nqpolynomial_list &qpolynomial_list::operator=(qpolynomial_list obj) {\n  std::swap(this->ptr, obj.ptr);\n  return *this;\n}\n\nqpolynomial_list::~qpolynomial_list() {\n  if (ptr)\n    isl_qpolynomial_list_free(ptr);\n}\n\n__isl_give isl_qpolynomial_list *qpolynomial_list::copy() const & {\n  return isl_qpolynomial_list_copy(ptr);\n}\n\n__isl_keep isl_qpolynomial_list *qpolynomial_list::get() const {\n  return ptr;\n}\n\n__isl_give isl_qpolynomial_list *qpolynomial_list::release() {\n  isl_qpolynomial_list *tmp = ptr;\n  ptr = nullptr;\n  return tmp;\n}\n\nbool qpolynomial_list::is_null() const {\n  return ptr == nullptr;\n}\nqpolynomial_list::operator bool() const {\n  return !is_null();\n}\n\n\nctx qpolynomial_list::get_ctx() const {\n  return ctx(isl_qpolynomial_list_get_ctx(ptr));\n}\nstd::string qpolynomial_list::to_str() const {\n  char *Tmp = isl_qpolynomial_list_to_str(get());\n  if (!Tmp)\n    return \"\";\n  std::string S(Tmp);\n  free(Tmp);\n  return S;\n}\n\n\nvoid qpolynomial_list::dump() const {\n  isl_qpolynomial_list_dump(get());\n}\n\n\nqpolynomial_list qpolynomial_list::add(qpolynomial el) const\n{\n  auto res = isl_qpolynomial_list_add(copy(), el.release());\n  return manage(res);\n}\n\nqpolynomial_list qpolynomial_list::alloc(ctx ctx, int n)\n{\n  auto res = isl_qpolynomial_list_alloc(ctx.release(), n);\n  return manage(res);\n}\n\nqpolynomial_list qpolynomial_list::clear() const\n{\n  auto res = isl_qpolynomial_list_clear(copy());\n  return manage(res);\n}\n\nqpolynomial_list qpolynomial_list::concat(qpolynomial_list list2) const\n{\n  auto res = isl_qpolynomial_list_concat(copy(), list2.release());\n  return manage(res);\n}\n\nqpolynomial_list qpolynomial_list::drop(unsigned int first, unsigned int n) const\n{\n  auto res = isl_qpolynomial_list_drop(copy(), first, n);\n  return manage(res);\n}\n\nstat qpolynomial_list::foreach(const std::function<stat(qpolynomial)> &fn) const\n{\n  struct fn_data {\n    const std::function<stat(qpolynomial)> *func;\n  } fn_data = { &fn };\n  auto fn_lambda = [](isl_qpolynomial *arg_0, void *arg_1) -> isl_stat {\n    auto *data = static_cast<struct fn_data *>(arg_1);\n    stat ret = (*data->func)(manage(arg_0));\n    return ret.release();\n  };\n  auto res = isl_qpolynomial_list_foreach(get(), fn_lambda, &fn_data);\n  return manage(res);\n}\n\nqpolynomial_list qpolynomial_list::from_qpolynomial(qpolynomial el)\n{\n  auto res = isl_qpolynomial_list_from_qpolynomial(el.release());\n  return manage(res);\n}\n\nqpolynomial qpolynomial_list::get_at(int index) const\n{\n  auto res = isl_qpolynomial_list_get_at(get(), index);\n  return manage(res);\n}\n\nqpolynomial qpolynomial_list::get_qpolynomial(int index) const\n{\n  auto res = isl_qpolynomial_list_get_qpolynomial(get(), index);\n  return manage(res);\n}\n\nqpolynomial_list qpolynomial_list::insert(unsigned int pos, qpolynomial el) const\n{\n  auto res = isl_qpolynomial_list_insert(copy(), pos, el.release());\n  return manage(res);\n}\n\nisl_size qpolynomial_list::n_qpolynomial() const\n{\n  auto res = isl_qpolynomial_list_n_qpolynomial(get());\n  return res;\n}\n\nqpolynomial_list qpolynomial_list::reverse() const\n{\n  auto res = isl_qpolynomial_list_reverse(copy());\n  return manage(res);\n}\n\nqpolynomial_list qpolynomial_list::set_qpolynomial(int index, qpolynomial el) const\n{\n  auto res = isl_qpolynomial_list_set_qpolynomial(copy(), index, el.release());\n  return manage(res);\n}\n\nisl_size qpolynomial_list::size() const\n{\n  auto res = isl_qpolynomial_list_size(get());\n  return res;\n}\n\nqpolynomial_list qpolynomial_list::swap(unsigned int pos1, unsigned int pos2) const\n{\n  auto res = isl_qpolynomial_list_swap(copy(), pos1, pos2);\n  return manage(res);\n}\n\n// implementations for isl::schedule\nschedule manage(__isl_take isl_schedule *ptr) {\n  return schedule(ptr);\n}\nschedule manage_copy(__isl_keep isl_schedule *ptr) {\n  ptr = isl_schedule_copy(ptr);\n  return schedule(ptr);\n}\n\nschedule::schedule()\n    : ptr(nullptr) {}\n\nschedule::schedule(const schedule &obj)\n    : ptr(nullptr)\n{\n  ptr = obj.copy();\n}\nschedule::schedule(std::nullptr_t)\n    : ptr(nullptr) {}\n\n\nschedule::schedule(__isl_take isl_schedule *ptr)\n    : ptr(ptr) {}\n\nschedule::schedule(ctx ctx, const std::string &str)\n{\n  auto res = isl_schedule_read_from_str(ctx.release(), str.c_str());\n  ptr = res;\n}\n\nschedule &schedule::operator=(schedule obj) {\n  std::swap(this->ptr, obj.ptr);\n  return *this;\n}\n\nschedule::~schedule() {\n  if (ptr)\n    isl_schedule_free(ptr);\n}\n\n__isl_give isl_schedule *schedule::copy() const & {\n  return isl_schedule_copy(ptr);\n}\n\n__isl_keep isl_schedule *schedule::get() const {\n  return ptr;\n}\n\n__isl_give isl_schedule *schedule::release() {\n  isl_schedule *tmp = ptr;\n  ptr = nullptr;\n  return tmp;\n}\n\nbool schedule::is_null() const {\n  return ptr == nullptr;\n}\nschedule::operator bool() const {\n  return !is_null();\n}\n\n\nctx schedule::get_ctx() const {\n  return ctx(isl_schedule_get_ctx(ptr));\n}\nstd::string schedule::to_str() const {\n  char *Tmp = isl_schedule_to_str(get());\n  if (!Tmp)\n    return \"\";\n  std::string S(Tmp);\n  free(Tmp);\n  return S;\n}\n\n\nvoid schedule::dump() const {\n  isl_schedule_dump(get());\n}\n\n\nschedule schedule::align_params(space space) const\n{\n  auto res = isl_schedule_align_params(copy(), space.release());\n  return manage(res);\n}\n\nschedule schedule::empty(space space)\n{\n  auto res = isl_schedule_empty(space.release());\n  return manage(res);\n}\n\nschedule schedule::from_domain(union_set domain)\n{\n  auto res = isl_schedule_from_domain(domain.release());\n  return manage(res);\n}\n\nunion_set schedule::get_domain() const\n{\n  auto res = isl_schedule_get_domain(get());\n  return manage(res);\n}\n\nunion_map schedule::get_map() const\n{\n  auto res = isl_schedule_get_map(get());\n  return manage(res);\n}\n\nschedule_node schedule::get_root() const\n{\n  auto res = isl_schedule_get_root(get());\n  return manage(res);\n}\n\nschedule schedule::gist_domain_params(set context) const\n{\n  auto res = isl_schedule_gist_domain_params(copy(), context.release());\n  return manage(res);\n}\n\nschedule schedule::insert_context(set context) const\n{\n  auto res = isl_schedule_insert_context(copy(), context.release());\n  return manage(res);\n}\n\nschedule schedule::insert_guard(set guard) const\n{\n  auto res = isl_schedule_insert_guard(copy(), guard.release());\n  return manage(res);\n}\n\nschedule schedule::insert_partial_schedule(multi_union_pw_aff partial) const\n{\n  auto res = isl_schedule_insert_partial_schedule(copy(), partial.release());\n  return manage(res);\n}\n\nschedule schedule::intersect_domain(union_set domain) const\n{\n  auto res = isl_schedule_intersect_domain(copy(), domain.release());\n  return manage(res);\n}\n\nboolean schedule::plain_is_equal(const schedule &schedule2) const\n{\n  auto res = isl_schedule_plain_is_equal(get(), schedule2.get());\n  return manage(res);\n}\n\nschedule schedule::pullback(union_pw_multi_aff upma) const\n{\n  auto res = isl_schedule_pullback_union_pw_multi_aff(copy(), upma.release());\n  return manage(res);\n}\n\nschedule schedule::reset_user() const\n{\n  auto res = isl_schedule_reset_user(copy());\n  return manage(res);\n}\n\nschedule schedule::sequence(schedule schedule2) const\n{\n  auto res = isl_schedule_sequence(copy(), schedule2.release());\n  return manage(res);\n}\n\n// implementations for isl::schedule_constraints\nschedule_constraints manage(__isl_take isl_schedule_constraints *ptr) {\n  return schedule_constraints(ptr);\n}\nschedule_constraints manage_copy(__isl_keep isl_schedule_constraints *ptr) {\n  ptr = isl_schedule_constraints_copy(ptr);\n  return schedule_constraints(ptr);\n}\n\nschedule_constraints::schedule_constraints()\n    : ptr(nullptr) {}\n\nschedule_constraints::schedule_constraints(const schedule_constraints &obj)\n    : ptr(nullptr)\n{\n  ptr = obj.copy();\n}\nschedule_constraints::schedule_constraints(std::nullptr_t)\n    : ptr(nullptr) {}\n\n\nschedule_constraints::schedule_constraints(__isl_take isl_schedule_constraints *ptr)\n    : ptr(ptr) {}\n\nschedule_constraints::schedule_constraints(ctx ctx, const std::string &str)\n{\n  auto res = isl_schedule_constraints_read_from_str(ctx.release(), str.c_str());\n  ptr = res;\n}\n\nschedule_constraints &schedule_constraints::operator=(schedule_constraints obj) {\n  std::swap(this->ptr, obj.ptr);\n  return *this;\n}\n\nschedule_constraints::~schedule_constraints() {\n  if (ptr)\n    isl_schedule_constraints_free(ptr);\n}\n\n__isl_give isl_schedule_constraints *schedule_constraints::copy() const & {\n  return isl_schedule_constraints_copy(ptr);\n}\n\n__isl_keep isl_schedule_constraints *schedule_constraints::get() const {\n  return ptr;\n}\n\n__isl_give isl_schedule_constraints *schedule_constraints::release() {\n  isl_schedule_constraints *tmp = ptr;\n  ptr = nullptr;\n  return tmp;\n}\n\nbool schedule_constraints::is_null() const {\n  return ptr == nullptr;\n}\nschedule_constraints::operator bool() const {\n  return !is_null();\n}\n\n\nctx schedule_constraints::get_ctx() const {\n  return ctx(isl_schedule_constraints_get_ctx(ptr));\n}\nstd::string schedule_constraints::to_str() const {\n  char *Tmp = isl_schedule_constraints_to_str(get());\n  if (!Tmp)\n    return \"\";\n  std::string S(Tmp);\n  free(Tmp);\n  return S;\n}\n\n\nvoid schedule_constraints::dump() const {\n  isl_schedule_constraints_dump(get());\n}\n\n\nschedule_constraints schedule_constraints::apply(union_map umap) const\n{\n  auto res = isl_schedule_constraints_apply(copy(), umap.release());\n  return manage(res);\n}\n\nschedule schedule_constraints::compute_schedule() const\n{\n  auto res = isl_schedule_constraints_compute_schedule(copy());\n  return manage(res);\n}\n\nunion_map schedule_constraints::get_coincidence() const\n{\n  auto res = isl_schedule_constraints_get_coincidence(get());\n  return manage(res);\n}\n\nunion_map schedule_constraints::get_conditional_validity() const\n{\n  auto res = isl_schedule_constraints_get_conditional_validity(get());\n  return manage(res);\n}\n\nunion_map schedule_constraints::get_conditional_validity_condition() const\n{\n  auto res = isl_schedule_constraints_get_conditional_validity_condition(get());\n  return manage(res);\n}\n\nset schedule_constraints::get_context() const\n{\n  auto res = isl_schedule_constraints_get_context(get());\n  return manage(res);\n}\n\nunion_set schedule_constraints::get_domain() const\n{\n  auto res = isl_schedule_constraints_get_domain(get());\n  return manage(res);\n}\n\nunion_map schedule_constraints::get_proximity() const\n{\n  auto res = isl_schedule_constraints_get_proximity(get());\n  return manage(res);\n}\n\nunion_map schedule_constraints::get_validity() const\n{\n  auto res = isl_schedule_constraints_get_validity(get());\n  return manage(res);\n}\n\nschedule_constraints schedule_constraints::on_domain(union_set domain)\n{\n  auto res = isl_schedule_constraints_on_domain(domain.release());\n  return manage(res);\n}\n\nschedule_constraints schedule_constraints::set_coincidence(union_map coincidence) const\n{\n  auto res = isl_schedule_constraints_set_coincidence(copy(), coincidence.release());\n  return manage(res);\n}\n\nschedule_constraints schedule_constraints::set_conditional_validity(union_map condition, union_map validity) const\n{\n  auto res = isl_schedule_constraints_set_conditional_validity(copy(), condition.release(), validity.release());\n  return manage(res);\n}\n\nschedule_constraints schedule_constraints::set_context(set context) const\n{\n  auto res = isl_schedule_constraints_set_context(copy(), context.release());\n  return manage(res);\n}\n\nschedule_constraints schedule_constraints::set_proximity(union_map proximity) const\n{\n  auto res = isl_schedule_constraints_set_proximity(copy(), proximity.release());\n  return manage(res);\n}\n\nschedule_constraints schedule_constraints::set_validity(union_map validity) const\n{\n  auto res = isl_schedule_constraints_set_validity(copy(), validity.release());\n  return manage(res);\n}\n\n// implementations for isl::schedule_node\nschedule_node manage(__isl_take isl_schedule_node *ptr) {\n  return schedule_node(ptr);\n}\nschedule_node manage_copy(__isl_keep isl_schedule_node *ptr) {\n  ptr = isl_schedule_node_copy(ptr);\n  return schedule_node(ptr);\n}\n\nschedule_node::schedule_node()\n    : ptr(nullptr) {}\n\nschedule_node::schedule_node(const schedule_node &obj)\n    : ptr(nullptr)\n{\n  ptr = obj.copy();\n}\nschedule_node::schedule_node(std::nullptr_t)\n    : ptr(nullptr) {}\n\n\nschedule_node::schedule_node(__isl_take isl_schedule_node *ptr)\n    : ptr(ptr) {}\n\n\nschedule_node &schedule_node::operator=(schedule_node obj) {\n  std::swap(this->ptr, obj.ptr);\n  return *this;\n}\n\nschedule_node::~schedule_node() {\n  if (ptr)\n    isl_schedule_node_free(ptr);\n}\n\n__isl_give isl_schedule_node *schedule_node::copy() const & {\n  return isl_schedule_node_copy(ptr);\n}\n\n__isl_keep isl_schedule_node *schedule_node::get() const {\n  return ptr;\n}\n\n__isl_give isl_schedule_node *schedule_node::release() {\n  isl_schedule_node *tmp = ptr;\n  ptr = nullptr;\n  return tmp;\n}\n\nbool schedule_node::is_null() const {\n  return ptr == nullptr;\n}\nschedule_node::operator bool() const {\n  return !is_null();\n}\n\n\nctx schedule_node::get_ctx() const {\n  return ctx(isl_schedule_node_get_ctx(ptr));\n}\nstd::string schedule_node::to_str() const {\n  char *Tmp = isl_schedule_node_to_str(get());\n  if (!Tmp)\n    return \"\";\n  std::string S(Tmp);\n  free(Tmp);\n  return S;\n}\n\n\nvoid schedule_node::dump() const {\n  isl_schedule_node_dump(get());\n}\n\n\nschedule_node schedule_node::align_params(space space) const\n{\n  auto res = isl_schedule_node_align_params(copy(), space.release());\n  return manage(res);\n}\n\nschedule_node schedule_node::ancestor(int generation) const\n{\n  auto res = isl_schedule_node_ancestor(copy(), generation);\n  return manage(res);\n}\n\nboolean schedule_node::band_member_get_coincident(int pos) const\n{\n  auto res = isl_schedule_node_band_member_get_coincident(get(), pos);\n  return manage(res);\n}\n\nschedule_node schedule_node::band_member_set_coincident(int pos, int coincident) const\n{\n  auto res = isl_schedule_node_band_member_set_coincident(copy(), pos, coincident);\n  return manage(res);\n}\n\nschedule_node schedule_node::band_set_ast_build_options(union_set options) const\n{\n  auto res = isl_schedule_node_band_set_ast_build_options(copy(), options.release());\n  return manage(res);\n}\n\nschedule_node schedule_node::child(int pos) const\n{\n  auto res = isl_schedule_node_child(copy(), pos);\n  return manage(res);\n}\n\nset schedule_node::context_get_context() const\n{\n  auto res = isl_schedule_node_context_get_context(get());\n  return manage(res);\n}\n\nschedule_node schedule_node::cut() const\n{\n  auto res = isl_schedule_node_cut(copy());\n  return manage(res);\n}\n\nunion_set schedule_node::domain_get_domain() const\n{\n  auto res = isl_schedule_node_domain_get_domain(get());\n  return manage(res);\n}\n\nunion_pw_multi_aff schedule_node::expansion_get_contraction() const\n{\n  auto res = isl_schedule_node_expansion_get_contraction(get());\n  return manage(res);\n}\n\nunion_map schedule_node::expansion_get_expansion() const\n{\n  auto res = isl_schedule_node_expansion_get_expansion(get());\n  return manage(res);\n}\n\nunion_map schedule_node::extension_get_extension() const\n{\n  auto res = isl_schedule_node_extension_get_extension(get());\n  return manage(res);\n}\n\nunion_set schedule_node::filter_get_filter() const\n{\n  auto res = isl_schedule_node_filter_get_filter(get());\n  return manage(res);\n}\n\nschedule_node schedule_node::first_child() const\n{\n  auto res = isl_schedule_node_first_child(copy());\n  return manage(res);\n}\n\nstat schedule_node::foreach_ancestor_top_down(const std::function<stat(schedule_node)> &fn) const\n{\n  struct fn_data {\n    const std::function<stat(schedule_node)> *func;\n  } fn_data = { &fn };\n  auto fn_lambda = [](isl_schedule_node *arg_0, void *arg_1) -> isl_stat {\n    auto *data = static_cast<struct fn_data *>(arg_1);\n    stat ret = (*data->func)(manage_copy(arg_0));\n    return ret.release();\n  };\n  auto res = isl_schedule_node_foreach_ancestor_top_down(get(), fn_lambda, &fn_data);\n  return manage(res);\n}\n\nschedule_node schedule_node::from_domain(union_set domain)\n{\n  auto res = isl_schedule_node_from_domain(domain.release());\n  return manage(res);\n}\n\nschedule_node schedule_node::from_extension(union_map extension)\n{\n  auto res = isl_schedule_node_from_extension(extension.release());\n  return manage(res);\n}\n\nisl_size schedule_node::get_ancestor_child_position(const schedule_node &ancestor) const\n{\n  auto res = isl_schedule_node_get_ancestor_child_position(get(), ancestor.get());\n  return res;\n}\n\nschedule_node schedule_node::get_child(int pos) const\n{\n  auto res = isl_schedule_node_get_child(get(), pos);\n  return manage(res);\n}\n\nisl_size schedule_node::get_child_position() const\n{\n  auto res = isl_schedule_node_get_child_position(get());\n  return res;\n}\n\nunion_set schedule_node::get_domain() const\n{\n  auto res = isl_schedule_node_get_domain(get());\n  return manage(res);\n}\n\nmulti_union_pw_aff schedule_node::get_prefix_schedule_multi_union_pw_aff() const\n{\n  auto res = isl_schedule_node_get_prefix_schedule_multi_union_pw_aff(get());\n  return manage(res);\n}\n\nunion_map schedule_node::get_prefix_schedule_relation() const\n{\n  auto res = isl_schedule_node_get_prefix_schedule_relation(get());\n  return manage(res);\n}\n\nunion_map schedule_node::get_prefix_schedule_union_map() const\n{\n  auto res = isl_schedule_node_get_prefix_schedule_union_map(get());\n  return manage(res);\n}\n\nunion_pw_multi_aff schedule_node::get_prefix_schedule_union_pw_multi_aff() const\n{\n  auto res = isl_schedule_node_get_prefix_schedule_union_pw_multi_aff(get());\n  return manage(res);\n}\n\nschedule schedule_node::get_schedule() const\n{\n  auto res = isl_schedule_node_get_schedule(get());\n  return manage(res);\n}\n\nisl_size schedule_node::get_schedule_depth() const\n{\n  auto res = isl_schedule_node_get_schedule_depth(get());\n  return res;\n}\n\nschedule_node schedule_node::get_shared_ancestor(const schedule_node &node2) const\n{\n  auto res = isl_schedule_node_get_shared_ancestor(get(), node2.get());\n  return manage(res);\n}\n\nunion_pw_multi_aff schedule_node::get_subtree_contraction() const\n{\n  auto res = isl_schedule_node_get_subtree_contraction(get());\n  return manage(res);\n}\n\nunion_map schedule_node::get_subtree_expansion() const\n{\n  auto res = isl_schedule_node_get_subtree_expansion(get());\n  return manage(res);\n}\n\nunion_map schedule_node::get_subtree_schedule_union_map() const\n{\n  auto res = isl_schedule_node_get_subtree_schedule_union_map(get());\n  return manage(res);\n}\n\nisl_size schedule_node::get_tree_depth() const\n{\n  auto res = isl_schedule_node_get_tree_depth(get());\n  return res;\n}\n\nunion_set schedule_node::get_universe_domain() const\n{\n  auto res = isl_schedule_node_get_universe_domain(get());\n  return manage(res);\n}\n\nschedule_node schedule_node::graft_after(schedule_node graft) const\n{\n  auto res = isl_schedule_node_graft_after(copy(), graft.release());\n  return manage(res);\n}\n\nschedule_node schedule_node::graft_before(schedule_node graft) const\n{\n  auto res = isl_schedule_node_graft_before(copy(), graft.release());\n  return manage(res);\n}\n\nschedule_node schedule_node::group(id group_id) const\n{\n  auto res = isl_schedule_node_group(copy(), group_id.release());\n  return manage(res);\n}\n\nset schedule_node::guard_get_guard() const\n{\n  auto res = isl_schedule_node_guard_get_guard(get());\n  return manage(res);\n}\n\nboolean schedule_node::has_children() const\n{\n  auto res = isl_schedule_node_has_children(get());\n  return manage(res);\n}\n\nboolean schedule_node::has_next_sibling() const\n{\n  auto res = isl_schedule_node_has_next_sibling(get());\n  return manage(res);\n}\n\nboolean schedule_node::has_parent() const\n{\n  auto res = isl_schedule_node_has_parent(get());\n  return manage(res);\n}\n\nboolean schedule_node::has_previous_sibling() const\n{\n  auto res = isl_schedule_node_has_previous_sibling(get());\n  return manage(res);\n}\n\nschedule_node schedule_node::insert_context(set context) const\n{\n  auto res = isl_schedule_node_insert_context(copy(), context.release());\n  return manage(res);\n}\n\nschedule_node schedule_node::insert_filter(union_set filter) const\n{\n  auto res = isl_schedule_node_insert_filter(copy(), filter.release());\n  return manage(res);\n}\n\nschedule_node schedule_node::insert_guard(set context) const\n{\n  auto res = isl_schedule_node_insert_guard(copy(), context.release());\n  return manage(res);\n}\n\nschedule_node schedule_node::insert_mark(id mark) const\n{\n  auto res = isl_schedule_node_insert_mark(copy(), mark.release());\n  return manage(res);\n}\n\nschedule_node schedule_node::insert_partial_schedule(multi_union_pw_aff schedule) const\n{\n  auto res = isl_schedule_node_insert_partial_schedule(copy(), schedule.release());\n  return manage(res);\n}\n\nschedule_node schedule_node::insert_sequence(union_set_list filters) const\n{\n  auto res = isl_schedule_node_insert_sequence(copy(), filters.release());\n  return manage(res);\n}\n\nschedule_node schedule_node::insert_set(union_set_list filters) const\n{\n  auto res = isl_schedule_node_insert_set(copy(), filters.release());\n  return manage(res);\n}\n\nboolean schedule_node::is_equal(const schedule_node &node2) const\n{\n  auto res = isl_schedule_node_is_equal(get(), node2.get());\n  return manage(res);\n}\n\nboolean schedule_node::is_subtree_anchored() const\n{\n  auto res = isl_schedule_node_is_subtree_anchored(get());\n  return manage(res);\n}\n\nid schedule_node::mark_get_id() const\n{\n  auto res = isl_schedule_node_mark_get_id(get());\n  return manage(res);\n}\n\nisl_size schedule_node::n_children() const\n{\n  auto res = isl_schedule_node_n_children(get());\n  return res;\n}\n\nschedule_node schedule_node::next_sibling() const\n{\n  auto res = isl_schedule_node_next_sibling(copy());\n  return manage(res);\n}\n\nschedule_node schedule_node::order_after(union_set filter) const\n{\n  auto res = isl_schedule_node_order_after(copy(), filter.release());\n  return manage(res);\n}\n\nschedule_node schedule_node::order_before(union_set filter) const\n{\n  auto res = isl_schedule_node_order_before(copy(), filter.release());\n  return manage(res);\n}\n\nschedule_node schedule_node::parent() const\n{\n  auto res = isl_schedule_node_parent(copy());\n  return manage(res);\n}\n\nschedule_node schedule_node::previous_sibling() const\n{\n  auto res = isl_schedule_node_previous_sibling(copy());\n  return manage(res);\n}\n\nschedule_node schedule_node::reset_user() const\n{\n  auto res = isl_schedule_node_reset_user(copy());\n  return manage(res);\n}\n\nschedule_node schedule_node::root() const\n{\n  auto res = isl_schedule_node_root(copy());\n  return manage(res);\n}\n\nschedule_node schedule_node::sequence_splice_child(int pos) const\n{\n  auto res = isl_schedule_node_sequence_splice_child(copy(), pos);\n  return manage(res);\n}\n\n// implementations for isl::set\nset manage(__isl_take isl_set *ptr) {\n  return set(ptr);\n}\nset manage_copy(__isl_keep isl_set *ptr) {\n  ptr = isl_set_copy(ptr);\n  return set(ptr);\n}\n\nset::set()\n    : ptr(nullptr) {}\n\nset::set(const set &obj)\n    : ptr(nullptr)\n{\n  ptr = obj.copy();\n}\nset::set(std::nullptr_t)\n    : ptr(nullptr) {}\n\n\nset::set(__isl_take isl_set *ptr)\n    : ptr(ptr) {}\n\nset::set(basic_set bset)\n{\n  auto res = isl_set_from_basic_set(bset.release());\n  ptr = res;\n}\nset::set(point pnt)\n{\n  auto res = isl_set_from_point(pnt.release());\n  ptr = res;\n}\nset::set(union_set uset)\n{\n  auto res = isl_set_from_union_set(uset.release());\n  ptr = res;\n}\nset::set(ctx ctx, const std::string &str)\n{\n  auto res = isl_set_read_from_str(ctx.release(), str.c_str());\n  ptr = res;\n}\n\nset &set::operator=(set obj) {\n  std::swap(this->ptr, obj.ptr);\n  return *this;\n}\n\nset::~set() {\n  if (ptr)\n    isl_set_free(ptr);\n}\n\n__isl_give isl_set *set::copy() const & {\n  return isl_set_copy(ptr);\n}\n\n__isl_keep isl_set *set::get() const {\n  return ptr;\n}\n\n__isl_give isl_set *set::release() {\n  isl_set *tmp = ptr;\n  ptr = nullptr;\n  return tmp;\n}\n\nbool set::is_null() const {\n  return ptr == nullptr;\n}\nset::operator bool() const {\n  return !is_null();\n}\n\n\nctx set::get_ctx() const {\n  return ctx(isl_set_get_ctx(ptr));\n}\nstd::string set::to_str() const {\n  char *Tmp = isl_set_to_str(get());\n  if (!Tmp)\n    return \"\";\n  std::string S(Tmp);\n  free(Tmp);\n  return S;\n}\n\n\nvoid set::dump() const {\n  isl_set_dump(get());\n}\n\n\nset set::add_constraint(constraint constraint) const\n{\n  auto res = isl_set_add_constraint(copy(), constraint.release());\n  return manage(res);\n}\n\nset set::add_dims(isl::dim type, unsigned int n) const\n{\n  auto res = isl_set_add_dims(copy(), static_cast<enum isl_dim_type>(type), n);\n  return manage(res);\n}\n\nbasic_set set::affine_hull() const\n{\n  auto res = isl_set_affine_hull(copy());\n  return manage(res);\n}\n\nset set::align_params(space model) const\n{\n  auto res = isl_set_align_params(copy(), model.release());\n  return manage(res);\n}\n\nset set::apply(map map) const\n{\n  auto res = isl_set_apply(copy(), map.release());\n  return manage(res);\n}\n\nset set::bind(multi_id tuple) const\n{\n  auto res = isl_set_bind(copy(), tuple.release());\n  return manage(res);\n}\n\nbasic_set set::bounded_simple_hull() const\n{\n  auto res = isl_set_bounded_simple_hull(copy());\n  return manage(res);\n}\n\nset set::box_from_points(point pnt1, point pnt2)\n{\n  auto res = isl_set_box_from_points(pnt1.release(), pnt2.release());\n  return manage(res);\n}\n\nset set::coalesce() const\n{\n  auto res = isl_set_coalesce(copy());\n  return manage(res);\n}\n\nbasic_set set::coefficients() const\n{\n  auto res = isl_set_coefficients(copy());\n  return manage(res);\n}\n\nset set::complement() const\n{\n  auto res = isl_set_complement(copy());\n  return manage(res);\n}\n\nbasic_set set::convex_hull() const\n{\n  auto res = isl_set_convex_hull(copy());\n  return manage(res);\n}\n\nval set::count_val() const\n{\n  auto res = isl_set_count_val(get());\n  return manage(res);\n}\n\nset set::detect_equalities() const\n{\n  auto res = isl_set_detect_equalities(copy());\n  return manage(res);\n}\n\nisl_size set::dim(isl::dim type) const\n{\n  auto res = isl_set_dim(get(), static_cast<enum isl_dim_type>(type));\n  return res;\n}\n\nboolean set::dim_has_any_lower_bound(isl::dim type, unsigned int pos) const\n{\n  auto res = isl_set_dim_has_any_lower_bound(get(), static_cast<enum isl_dim_type>(type), pos);\n  return manage(res);\n}\n\nboolean set::dim_has_any_upper_bound(isl::dim type, unsigned int pos) const\n{\n  auto res = isl_set_dim_has_any_upper_bound(get(), static_cast<enum isl_dim_type>(type), pos);\n  return manage(res);\n}\n\nboolean set::dim_has_lower_bound(isl::dim type, unsigned int pos) const\n{\n  auto res = isl_set_dim_has_lower_bound(get(), static_cast<enum isl_dim_type>(type), pos);\n  return manage(res);\n}\n\nboolean set::dim_has_upper_bound(isl::dim type, unsigned int pos) const\n{\n  auto res = isl_set_dim_has_upper_bound(get(), static_cast<enum isl_dim_type>(type), pos);\n  return manage(res);\n}\n\nboolean set::dim_is_bounded(isl::dim type, unsigned int pos) const\n{\n  auto res = isl_set_dim_is_bounded(get(), static_cast<enum isl_dim_type>(type), pos);\n  return manage(res);\n}\n\npw_aff set::dim_max(int pos) const\n{\n  auto res = isl_set_dim_max(copy(), pos);\n  return manage(res);\n}\n\nval set::dim_max_val(int pos) const\n{\n  auto res = isl_set_dim_max_val(copy(), pos);\n  return manage(res);\n}\n\npw_aff set::dim_min(int pos) const\n{\n  auto res = isl_set_dim_min(copy(), pos);\n  return manage(res);\n}\n\nval set::dim_min_val(int pos) const\n{\n  auto res = isl_set_dim_min_val(copy(), pos);\n  return manage(res);\n}\n\nset set::drop_constraints_involving_dims(isl::dim type, unsigned int first, unsigned int n) const\n{\n  auto res = isl_set_drop_constraints_involving_dims(copy(), static_cast<enum isl_dim_type>(type), first, n);\n  return manage(res);\n}\n\nset set::drop_constraints_not_involving_dims(isl::dim type, unsigned int first, unsigned int n) const\n{\n  auto res = isl_set_drop_constraints_not_involving_dims(copy(), static_cast<enum isl_dim_type>(type), first, n);\n  return manage(res);\n}\n\nset set::drop_unused_params() const\n{\n  auto res = isl_set_drop_unused_params(copy());\n  return manage(res);\n}\n\nset set::eliminate(isl::dim type, unsigned int first, unsigned int n) const\n{\n  auto res = isl_set_eliminate(copy(), static_cast<enum isl_dim_type>(type), first, n);\n  return manage(res);\n}\n\nset set::empty(space space)\n{\n  auto res = isl_set_empty(space.release());\n  return manage(res);\n}\n\nset set::equate(isl::dim type1, int pos1, isl::dim type2, int pos2) const\n{\n  auto res = isl_set_equate(copy(), static_cast<enum isl_dim_type>(type1), pos1, static_cast<enum isl_dim_type>(type2), pos2);\n  return manage(res);\n}\n\nint set::find_dim_by_id(isl::dim type, const id &id) const\n{\n  auto res = isl_set_find_dim_by_id(get(), static_cast<enum isl_dim_type>(type), id.get());\n  return res;\n}\n\nint set::find_dim_by_name(isl::dim type, const std::string &name) const\n{\n  auto res = isl_set_find_dim_by_name(get(), static_cast<enum isl_dim_type>(type), name.c_str());\n  return res;\n}\n\nset set::fix_si(isl::dim type, unsigned int pos, int value) const\n{\n  auto res = isl_set_fix_si(copy(), static_cast<enum isl_dim_type>(type), pos, value);\n  return manage(res);\n}\n\nset set::fix_val(isl::dim type, unsigned int pos, val v) const\n{\n  auto res = isl_set_fix_val(copy(), static_cast<enum isl_dim_type>(type), pos, v.release());\n  return manage(res);\n}\n\nset set::flat_product(set set2) const\n{\n  auto res = isl_set_flat_product(copy(), set2.release());\n  return manage(res);\n}\n\nset set::flatten() const\n{\n  auto res = isl_set_flatten(copy());\n  return manage(res);\n}\n\nmap set::flatten_map() const\n{\n  auto res = isl_set_flatten_map(copy());\n  return manage(res);\n}\n\nint set::follows_at(const set &set2, int pos) const\n{\n  auto res = isl_set_follows_at(get(), set2.get(), pos);\n  return res;\n}\n\nstat set::foreach_basic_set(const std::function<stat(basic_set)> &fn) const\n{\n  struct fn_data {\n    const std::function<stat(basic_set)> *func;\n  } fn_data = { &fn };\n  auto fn_lambda = [](isl_basic_set *arg_0, void *arg_1) -> isl_stat {\n    auto *data = static_cast<struct fn_data *>(arg_1);\n    stat ret = (*data->func)(manage(arg_0));\n    return ret.release();\n  };\n  auto res = isl_set_foreach_basic_set(get(), fn_lambda, &fn_data);\n  return manage(res);\n}\n\nstat set::foreach_point(const std::function<stat(point)> &fn) const\n{\n  struct fn_data {\n    const std::function<stat(point)> *func;\n  } fn_data = { &fn };\n  auto fn_lambda = [](isl_point *arg_0, void *arg_1) -> isl_stat {\n    auto *data = static_cast<struct fn_data *>(arg_1);\n    stat ret = (*data->func)(manage(arg_0));\n    return ret.release();\n  };\n  auto res = isl_set_foreach_point(get(), fn_lambda, &fn_data);\n  return manage(res);\n}\n\nset set::from_multi_aff(multi_aff ma)\n{\n  auto res = isl_set_from_multi_aff(ma.release());\n  return manage(res);\n}\n\nset set::from_multi_pw_aff(multi_pw_aff mpa)\n{\n  auto res = isl_set_from_multi_pw_aff(mpa.release());\n  return manage(res);\n}\n\nset set::from_params() const\n{\n  auto res = isl_set_from_params(copy());\n  return manage(res);\n}\n\nset set::from_pw_aff(pw_aff pwaff)\n{\n  auto res = isl_set_from_pw_aff(pwaff.release());\n  return manage(res);\n}\n\nset set::from_pw_multi_aff(pw_multi_aff pma)\n{\n  auto res = isl_set_from_pw_multi_aff(pma.release());\n  return manage(res);\n}\n\nbasic_set_list set::get_basic_set_list() const\n{\n  auto res = isl_set_get_basic_set_list(get());\n  return manage(res);\n}\n\nid set::get_dim_id(isl::dim type, unsigned int pos) const\n{\n  auto res = isl_set_get_dim_id(get(), static_cast<enum isl_dim_type>(type), pos);\n  return manage(res);\n}\n\nstd::string set::get_dim_name(isl::dim type, unsigned int pos) const\n{\n  auto res = isl_set_get_dim_name(get(), static_cast<enum isl_dim_type>(type), pos);\n  std::string tmp(res);\n  return tmp;\n}\n\nmulti_val set::get_plain_multi_val_if_fixed() const\n{\n  auto res = isl_set_get_plain_multi_val_if_fixed(get());\n  return manage(res);\n}\n\nfixed_box set::get_simple_fixed_box_hull() const\n{\n  auto res = isl_set_get_simple_fixed_box_hull(get());\n  return manage(res);\n}\n\nspace set::get_space() const\n{\n  auto res = isl_set_get_space(get());\n  return manage(res);\n}\n\nval set::get_stride(int pos) const\n{\n  auto res = isl_set_get_stride(get(), pos);\n  return manage(res);\n}\n\nid set::get_tuple_id() const\n{\n  auto res = isl_set_get_tuple_id(get());\n  return manage(res);\n}\n\nstd::string set::get_tuple_name() const\n{\n  auto res = isl_set_get_tuple_name(get());\n  std::string tmp(res);\n  return tmp;\n}\n\nset set::gist(set context) const\n{\n  auto res = isl_set_gist(copy(), context.release());\n  return manage(res);\n}\n\nset set::gist_basic_set(basic_set context) const\n{\n  auto res = isl_set_gist_basic_set(copy(), context.release());\n  return manage(res);\n}\n\nset set::gist_params(set context) const\n{\n  auto res = isl_set_gist_params(copy(), context.release());\n  return manage(res);\n}\n\nboolean set::has_dim_id(isl::dim type, unsigned int pos) const\n{\n  auto res = isl_set_has_dim_id(get(), static_cast<enum isl_dim_type>(type), pos);\n  return manage(res);\n}\n\nboolean set::has_dim_name(isl::dim type, unsigned int pos) const\n{\n  auto res = isl_set_has_dim_name(get(), static_cast<enum isl_dim_type>(type), pos);\n  return manage(res);\n}\n\nboolean set::has_equal_space(const set &set2) const\n{\n  auto res = isl_set_has_equal_space(get(), set2.get());\n  return manage(res);\n}\n\nboolean set::has_tuple_id() const\n{\n  auto res = isl_set_has_tuple_id(get());\n  return manage(res);\n}\n\nboolean set::has_tuple_name() const\n{\n  auto res = isl_set_has_tuple_name(get());\n  return manage(res);\n}\n\nmap set::identity() const\n{\n  auto res = isl_set_identity(copy());\n  return manage(res);\n}\n\npw_aff set::indicator_function() const\n{\n  auto res = isl_set_indicator_function(copy());\n  return manage(res);\n}\n\nset set::insert_dims(isl::dim type, unsigned int pos, unsigned int n) const\n{\n  auto res = isl_set_insert_dims(copy(), static_cast<enum isl_dim_type>(type), pos, n);\n  return manage(res);\n}\n\nmap set::insert_domain(space domain) const\n{\n  auto res = isl_set_insert_domain(copy(), domain.release());\n  return manage(res);\n}\n\nset set::intersect(set set2) const\n{\n  auto res = isl_set_intersect(copy(), set2.release());\n  return manage(res);\n}\n\nset set::intersect_factor_domain(set domain) const\n{\n  auto res = isl_set_intersect_factor_domain(copy(), domain.release());\n  return manage(res);\n}\n\nset set::intersect_factor_range(set range) const\n{\n  auto res = isl_set_intersect_factor_range(copy(), range.release());\n  return manage(res);\n}\n\nset set::intersect_params(set params) const\n{\n  auto res = isl_set_intersect_params(copy(), params.release());\n  return manage(res);\n}\n\nboolean set::involves_dims(isl::dim type, unsigned int first, unsigned int n) const\n{\n  auto res = isl_set_involves_dims(get(), static_cast<enum isl_dim_type>(type), first, n);\n  return manage(res);\n}\n\nboolean set::involves_locals() const\n{\n  auto res = isl_set_involves_locals(get());\n  return manage(res);\n}\n\nboolean set::is_bounded() const\n{\n  auto res = isl_set_is_bounded(get());\n  return manage(res);\n}\n\nboolean set::is_box() const\n{\n  auto res = isl_set_is_box(get());\n  return manage(res);\n}\n\nboolean set::is_disjoint(const set &set2) const\n{\n  auto res = isl_set_is_disjoint(get(), set2.get());\n  return manage(res);\n}\n\nboolean set::is_empty() const\n{\n  auto res = isl_set_is_empty(get());\n  return manage(res);\n}\n\nboolean set::is_equal(const set &set2) const\n{\n  auto res = isl_set_is_equal(get(), set2.get());\n  return manage(res);\n}\n\nboolean set::is_params() const\n{\n  auto res = isl_set_is_params(get());\n  return manage(res);\n}\n\nboolean set::is_singleton() const\n{\n  auto res = isl_set_is_singleton(get());\n  return manage(res);\n}\n\nboolean set::is_strict_subset(const set &set2) const\n{\n  auto res = isl_set_is_strict_subset(get(), set2.get());\n  return manage(res);\n}\n\nboolean set::is_subset(const set &set2) const\n{\n  auto res = isl_set_is_subset(get(), set2.get());\n  return manage(res);\n}\n\nboolean set::is_wrapping() const\n{\n  auto res = isl_set_is_wrapping(get());\n  return manage(res);\n}\n\nmap set::lex_ge_set(set set2) const\n{\n  auto res = isl_set_lex_ge_set(copy(), set2.release());\n  return manage(res);\n}\n\nmap set::lex_gt_set(set set2) const\n{\n  auto res = isl_set_lex_gt_set(copy(), set2.release());\n  return manage(res);\n}\n\nmap set::lex_le_set(set set2) const\n{\n  auto res = isl_set_lex_le_set(copy(), set2.release());\n  return manage(res);\n}\n\nmap set::lex_lt_set(set set2) const\n{\n  auto res = isl_set_lex_lt_set(copy(), set2.release());\n  return manage(res);\n}\n\nset set::lexmax() const\n{\n  auto res = isl_set_lexmax(copy());\n  return manage(res);\n}\n\npw_multi_aff set::lexmax_pw_multi_aff() const\n{\n  auto res = isl_set_lexmax_pw_multi_aff(copy());\n  return manage(res);\n}\n\nset set::lexmin() const\n{\n  auto res = isl_set_lexmin(copy());\n  return manage(res);\n}\n\npw_multi_aff set::lexmin_pw_multi_aff() const\n{\n  auto res = isl_set_lexmin_pw_multi_aff(copy());\n  return manage(res);\n}\n\nset set::lower_bound(multi_pw_aff lower) const\n{\n  auto res = isl_set_lower_bound_multi_pw_aff(copy(), lower.release());\n  return manage(res);\n}\n\nset set::lower_bound(multi_val lower) const\n{\n  auto res = isl_set_lower_bound_multi_val(copy(), lower.release());\n  return manage(res);\n}\n\nset set::lower_bound_si(isl::dim type, unsigned int pos, int value) const\n{\n  auto res = isl_set_lower_bound_si(copy(), static_cast<enum isl_dim_type>(type), pos, value);\n  return manage(res);\n}\n\nset set::lower_bound_val(isl::dim type, unsigned int pos, val value) const\n{\n  auto res = isl_set_lower_bound_val(copy(), static_cast<enum isl_dim_type>(type), pos, value.release());\n  return manage(res);\n}\n\nmulti_pw_aff set::max_multi_pw_aff() const\n{\n  auto res = isl_set_max_multi_pw_aff(copy());\n  return manage(res);\n}\n\nval set::max_val(const aff &obj) const\n{\n  auto res = isl_set_max_val(get(), obj.get());\n  return manage(res);\n}\n\nmulti_pw_aff set::min_multi_pw_aff() const\n{\n  auto res = isl_set_min_multi_pw_aff(copy());\n  return manage(res);\n}\n\nval set::min_val(const aff &obj) const\n{\n  auto res = isl_set_min_val(get(), obj.get());\n  return manage(res);\n}\n\nset set::move_dims(isl::dim dst_type, unsigned int dst_pos, isl::dim src_type, unsigned int src_pos, unsigned int n) const\n{\n  auto res = isl_set_move_dims(copy(), static_cast<enum isl_dim_type>(dst_type), dst_pos, static_cast<enum isl_dim_type>(src_type), src_pos, n);\n  return manage(res);\n}\n\nisl_size set::n_basic_set() const\n{\n  auto res = isl_set_n_basic_set(get());\n  return res;\n}\n\nisl_size set::n_dim() const\n{\n  auto res = isl_set_n_dim(get());\n  return res;\n}\n\nset set::nat_universe(space space)\n{\n  auto res = isl_set_nat_universe(space.release());\n  return manage(res);\n}\n\nset set::neg() const\n{\n  auto res = isl_set_neg(copy());\n  return manage(res);\n}\n\nset set::params() const\n{\n  auto res = isl_set_params(copy());\n  return manage(res);\n}\n\nint set::plain_cmp(const set &set2) const\n{\n  auto res = isl_set_plain_cmp(get(), set2.get());\n  return res;\n}\n\nval set::plain_get_val_if_fixed(isl::dim type, unsigned int pos) const\n{\n  auto res = isl_set_plain_get_val_if_fixed(get(), static_cast<enum isl_dim_type>(type), pos);\n  return manage(res);\n}\n\nboolean set::plain_is_disjoint(const set &set2) const\n{\n  auto res = isl_set_plain_is_disjoint(get(), set2.get());\n  return manage(res);\n}\n\nboolean set::plain_is_empty() const\n{\n  auto res = isl_set_plain_is_empty(get());\n  return manage(res);\n}\n\nboolean set::plain_is_equal(const set &set2) const\n{\n  auto res = isl_set_plain_is_equal(get(), set2.get());\n  return manage(res);\n}\n\nboolean set::plain_is_universe() const\n{\n  auto res = isl_set_plain_is_universe(get());\n  return manage(res);\n}\n\nbasic_set set::plain_unshifted_simple_hull() const\n{\n  auto res = isl_set_plain_unshifted_simple_hull(copy());\n  return manage(res);\n}\n\nbasic_set set::polyhedral_hull() const\n{\n  auto res = isl_set_polyhedral_hull(copy());\n  return manage(res);\n}\n\nset set::preimage(multi_aff ma) const\n{\n  auto res = isl_set_preimage_multi_aff(copy(), ma.release());\n  return manage(res);\n}\n\nset set::preimage(multi_pw_aff mpa) const\n{\n  auto res = isl_set_preimage_multi_pw_aff(copy(), mpa.release());\n  return manage(res);\n}\n\nset set::preimage(pw_multi_aff pma) const\n{\n  auto res = isl_set_preimage_pw_multi_aff(copy(), pma.release());\n  return manage(res);\n}\n\nset set::product(set set2) const\n{\n  auto res = isl_set_product(copy(), set2.release());\n  return manage(res);\n}\n\nmap set::project_onto_map(isl::dim type, unsigned int first, unsigned int n) const\n{\n  auto res = isl_set_project_onto_map(copy(), static_cast<enum isl_dim_type>(type), first, n);\n  return manage(res);\n}\n\nset set::project_out(isl::dim type, unsigned int first, unsigned int n) const\n{\n  auto res = isl_set_project_out(copy(), static_cast<enum isl_dim_type>(type), first, n);\n  return manage(res);\n}\n\nset set::project_out_all_params() const\n{\n  auto res = isl_set_project_out_all_params(copy());\n  return manage(res);\n}\n\nset set::project_out_param(id id) const\n{\n  auto res = isl_set_project_out_param_id(copy(), id.release());\n  return manage(res);\n}\n\nset set::project_out_param(id_list list) const\n{\n  auto res = isl_set_project_out_param_id_list(copy(), list.release());\n  return manage(res);\n}\n\nset set::remove_dims(isl::dim type, unsigned int first, unsigned int n) const\n{\n  auto res = isl_set_remove_dims(copy(), static_cast<enum isl_dim_type>(type), first, n);\n  return manage(res);\n}\n\nset set::remove_divs() const\n{\n  auto res = isl_set_remove_divs(copy());\n  return manage(res);\n}\n\nset set::remove_divs_involving_dims(isl::dim type, unsigned int first, unsigned int n) const\n{\n  auto res = isl_set_remove_divs_involving_dims(copy(), static_cast<enum isl_dim_type>(type), first, n);\n  return manage(res);\n}\n\nset set::remove_redundancies() const\n{\n  auto res = isl_set_remove_redundancies(copy());\n  return manage(res);\n}\n\nset set::remove_unknown_divs() const\n{\n  auto res = isl_set_remove_unknown_divs(copy());\n  return manage(res);\n}\n\nset set::reset_space(space space) const\n{\n  auto res = isl_set_reset_space(copy(), space.release());\n  return manage(res);\n}\n\nset set::reset_tuple_id() const\n{\n  auto res = isl_set_reset_tuple_id(copy());\n  return manage(res);\n}\n\nset set::reset_user() const\n{\n  auto res = isl_set_reset_user(copy());\n  return manage(res);\n}\n\nbasic_set set::sample() const\n{\n  auto res = isl_set_sample(copy());\n  return manage(res);\n}\n\npoint set::sample_point() const\n{\n  auto res = isl_set_sample_point(copy());\n  return manage(res);\n}\n\nset set::set_dim_id(isl::dim type, unsigned int pos, id id) const\n{\n  auto res = isl_set_set_dim_id(copy(), static_cast<enum isl_dim_type>(type), pos, id.release());\n  return manage(res);\n}\n\nset set::set_tuple_id(id id) const\n{\n  auto res = isl_set_set_tuple_id(copy(), id.release());\n  return manage(res);\n}\n\nset set::set_tuple_name(const std::string &s) const\n{\n  auto res = isl_set_set_tuple_name(copy(), s.c_str());\n  return manage(res);\n}\n\nbasic_set set::simple_hull() const\n{\n  auto res = isl_set_simple_hull(copy());\n  return manage(res);\n}\n\nint set::size() const\n{\n  auto res = isl_set_size(get());\n  return res;\n}\n\nbasic_set set::solutions() const\n{\n  auto res = isl_set_solutions(copy());\n  return manage(res);\n}\n\nset set::split_dims(isl::dim type, unsigned int first, unsigned int n) const\n{\n  auto res = isl_set_split_dims(copy(), static_cast<enum isl_dim_type>(type), first, n);\n  return manage(res);\n}\n\nset set::subtract(set set2) const\n{\n  auto res = isl_set_subtract(copy(), set2.release());\n  return manage(res);\n}\n\nset set::sum(set set2) const\n{\n  auto res = isl_set_sum(copy(), set2.release());\n  return manage(res);\n}\n\nmap set::translation() const\n{\n  auto res = isl_set_translation(copy());\n  return manage(res);\n}\n\nset set::unbind_params(multi_id tuple) const\n{\n  auto res = isl_set_unbind_params(copy(), tuple.release());\n  return manage(res);\n}\n\nmap set::unbind_params_insert_domain(multi_id domain) const\n{\n  auto res = isl_set_unbind_params_insert_domain(copy(), domain.release());\n  return manage(res);\n}\n\nset set::unite(set set2) const\n{\n  auto res = isl_set_union(copy(), set2.release());\n  return manage(res);\n}\n\nset set::universe(space space)\n{\n  auto res = isl_set_universe(space.release());\n  return manage(res);\n}\n\nbasic_set set::unshifted_simple_hull() const\n{\n  auto res = isl_set_unshifted_simple_hull(copy());\n  return manage(res);\n}\n\nbasic_set set::unshifted_simple_hull_from_set_list(set_list list) const\n{\n  auto res = isl_set_unshifted_simple_hull_from_set_list(copy(), list.release());\n  return manage(res);\n}\n\nmap set::unwrap() const\n{\n  auto res = isl_set_unwrap(copy());\n  return manage(res);\n}\n\nset set::upper_bound(multi_pw_aff upper) const\n{\n  auto res = isl_set_upper_bound_multi_pw_aff(copy(), upper.release());\n  return manage(res);\n}\n\nset set::upper_bound(multi_val upper) const\n{\n  auto res = isl_set_upper_bound_multi_val(copy(), upper.release());\n  return manage(res);\n}\n\nset set::upper_bound_si(isl::dim type, unsigned int pos, int value) const\n{\n  auto res = isl_set_upper_bound_si(copy(), static_cast<enum isl_dim_type>(type), pos, value);\n  return manage(res);\n}\n\nset set::upper_bound_val(isl::dim type, unsigned int pos, val value) const\n{\n  auto res = isl_set_upper_bound_val(copy(), static_cast<enum isl_dim_type>(type), pos, value.release());\n  return manage(res);\n}\n\nmap set::wrapped_domain_map() const\n{\n  auto res = isl_set_wrapped_domain_map(copy());\n  return manage(res);\n}\n\n// implementations for isl::set_list\nset_list manage(__isl_take isl_set_list *ptr) {\n  return set_list(ptr);\n}\nset_list manage_copy(__isl_keep isl_set_list *ptr) {\n  ptr = isl_set_list_copy(ptr);\n  return set_list(ptr);\n}\n\nset_list::set_list()\n    : ptr(nullptr) {}\n\nset_list::set_list(const set_list &obj)\n    : ptr(nullptr)\n{\n  ptr = obj.copy();\n}\nset_list::set_list(std::nullptr_t)\n    : ptr(nullptr) {}\n\n\nset_list::set_list(__isl_take isl_set_list *ptr)\n    : ptr(ptr) {}\n\n\nset_list &set_list::operator=(set_list obj) {\n  std::swap(this->ptr, obj.ptr);\n  return *this;\n}\n\nset_list::~set_list() {\n  if (ptr)\n    isl_set_list_free(ptr);\n}\n\n__isl_give isl_set_list *set_list::copy() const & {\n  return isl_set_list_copy(ptr);\n}\n\n__isl_keep isl_set_list *set_list::get() const {\n  return ptr;\n}\n\n__isl_give isl_set_list *set_list::release() {\n  isl_set_list *tmp = ptr;\n  ptr = nullptr;\n  return tmp;\n}\n\nbool set_list::is_null() const {\n  return ptr == nullptr;\n}\nset_list::operator bool() const {\n  return !is_null();\n}\n\n\nctx set_list::get_ctx() const {\n  return ctx(isl_set_list_get_ctx(ptr));\n}\nstd::string set_list::to_str() const {\n  char *Tmp = isl_set_list_to_str(get());\n  if (!Tmp)\n    return \"\";\n  std::string S(Tmp);\n  free(Tmp);\n  return S;\n}\n\n\nvoid set_list::dump() const {\n  isl_set_list_dump(get());\n}\n\n\nset_list set_list::add(set el) const\n{\n  auto res = isl_set_list_add(copy(), el.release());\n  return manage(res);\n}\n\nset_list set_list::alloc(ctx ctx, int n)\n{\n  auto res = isl_set_list_alloc(ctx.release(), n);\n  return manage(res);\n}\n\nset_list set_list::clear() const\n{\n  auto res = isl_set_list_clear(copy());\n  return manage(res);\n}\n\nset_list set_list::concat(set_list list2) const\n{\n  auto res = isl_set_list_concat(copy(), list2.release());\n  return manage(res);\n}\n\nset_list set_list::drop(unsigned int first, unsigned int n) const\n{\n  auto res = isl_set_list_drop(copy(), first, n);\n  return manage(res);\n}\n\nstat set_list::foreach(const std::function<stat(set)> &fn) const\n{\n  struct fn_data {\n    const std::function<stat(set)> *func;\n  } fn_data = { &fn };\n  auto fn_lambda = [](isl_set *arg_0, void *arg_1) -> isl_stat {\n    auto *data = static_cast<struct fn_data *>(arg_1);\n    stat ret = (*data->func)(manage(arg_0));\n    return ret.release();\n  };\n  auto res = isl_set_list_foreach(get(), fn_lambda, &fn_data);\n  return manage(res);\n}\n\nset_list set_list::from_set(set el)\n{\n  auto res = isl_set_list_from_set(el.release());\n  return manage(res);\n}\n\nset set_list::get_at(int index) const\n{\n  auto res = isl_set_list_get_at(get(), index);\n  return manage(res);\n}\n\nset set_list::get_set(int index) const\n{\n  auto res = isl_set_list_get_set(get(), index);\n  return manage(res);\n}\n\nset_list set_list::insert(unsigned int pos, set el) const\n{\n  auto res = isl_set_list_insert(copy(), pos, el.release());\n  return manage(res);\n}\n\nisl_size set_list::n_set() const\n{\n  auto res = isl_set_list_n_set(get());\n  return res;\n}\n\nset_list set_list::reverse() const\n{\n  auto res = isl_set_list_reverse(copy());\n  return manage(res);\n}\n\nset_list set_list::set_set(int index, set el) const\n{\n  auto res = isl_set_list_set_set(copy(), index, el.release());\n  return manage(res);\n}\n\nisl_size set_list::size() const\n{\n  auto res = isl_set_list_size(get());\n  return res;\n}\n\nset_list set_list::swap(unsigned int pos1, unsigned int pos2) const\n{\n  auto res = isl_set_list_swap(copy(), pos1, pos2);\n  return manage(res);\n}\n\nset set_list::unite() const\n{\n  auto res = isl_set_list_union(copy());\n  return manage(res);\n}\n\n// implementations for isl::space\nspace manage(__isl_take isl_space *ptr) {\n  return space(ptr);\n}\nspace manage_copy(__isl_keep isl_space *ptr) {\n  ptr = isl_space_copy(ptr);\n  return space(ptr);\n}\n\nspace::space()\n    : ptr(nullptr) {}\n\nspace::space(const space &obj)\n    : ptr(nullptr)\n{\n  ptr = obj.copy();\n}\nspace::space(std::nullptr_t)\n    : ptr(nullptr) {}\n\n\nspace::space(__isl_take isl_space *ptr)\n    : ptr(ptr) {}\n\nspace::space(ctx ctx, unsigned int nparam, unsigned int n_in, unsigned int n_out)\n{\n  auto res = isl_space_alloc(ctx.release(), nparam, n_in, n_out);\n  ptr = res;\n}\nspace::space(ctx ctx, unsigned int nparam, unsigned int dim)\n{\n  auto res = isl_space_set_alloc(ctx.release(), nparam, dim);\n  ptr = res;\n}\n\nspace &space::operator=(space obj) {\n  std::swap(this->ptr, obj.ptr);\n  return *this;\n}\n\nspace::~space() {\n  if (ptr)\n    isl_space_free(ptr);\n}\n\n__isl_give isl_space *space::copy() const & {\n  return isl_space_copy(ptr);\n}\n\n__isl_keep isl_space *space::get() const {\n  return ptr;\n}\n\n__isl_give isl_space *space::release() {\n  isl_space *tmp = ptr;\n  ptr = nullptr;\n  return tmp;\n}\n\nbool space::is_null() const {\n  return ptr == nullptr;\n}\nspace::operator bool() const {\n  return !is_null();\n}\n\n\nctx space::get_ctx() const {\n  return ctx(isl_space_get_ctx(ptr));\n}\nstd::string space::to_str() const {\n  char *Tmp = isl_space_to_str(get());\n  if (!Tmp)\n    return \"\";\n  std::string S(Tmp);\n  free(Tmp);\n  return S;\n}\n\n\nvoid space::dump() const {\n  isl_space_dump(get());\n}\n\n\nspace space::add_dims(isl::dim type, unsigned int n) const\n{\n  auto res = isl_space_add_dims(copy(), static_cast<enum isl_dim_type>(type), n);\n  return manage(res);\n}\n\nspace space::add_named_tuple(id tuple_id, unsigned int dim) const\n{\n  auto res = isl_space_add_named_tuple_id_ui(copy(), tuple_id.release(), dim);\n  return manage(res);\n}\n\nspace space::add_param_id(id id) const\n{\n  auto res = isl_space_add_param_id(copy(), id.release());\n  return manage(res);\n}\n\nspace space::add_unnamed_tuple(unsigned int dim) const\n{\n  auto res = isl_space_add_unnamed_tuple_ui(copy(), dim);\n  return manage(res);\n}\n\nspace space::align_params(space space2) const\n{\n  auto res = isl_space_align_params(copy(), space2.release());\n  return manage(res);\n}\n\nboolean space::can_curry() const\n{\n  auto res = isl_space_can_curry(get());\n  return manage(res);\n}\n\nboolean space::can_range_curry() const\n{\n  auto res = isl_space_can_range_curry(get());\n  return manage(res);\n}\n\nboolean space::can_uncurry() const\n{\n  auto res = isl_space_can_uncurry(get());\n  return manage(res);\n}\n\nboolean space::can_zip() const\n{\n  auto res = isl_space_can_zip(get());\n  return manage(res);\n}\n\nspace space::curry() const\n{\n  auto res = isl_space_curry(copy());\n  return manage(res);\n}\n\nisl_size space::dim(isl::dim type) const\n{\n  auto res = isl_space_dim(get(), static_cast<enum isl_dim_type>(type));\n  return res;\n}\n\nspace space::domain() const\n{\n  auto res = isl_space_domain(copy());\n  return manage(res);\n}\n\nspace space::domain_factor_domain() const\n{\n  auto res = isl_space_domain_factor_domain(copy());\n  return manage(res);\n}\n\nspace space::domain_factor_range() const\n{\n  auto res = isl_space_domain_factor_range(copy());\n  return manage(res);\n}\n\nboolean space::domain_is_wrapping() const\n{\n  auto res = isl_space_domain_is_wrapping(get());\n  return manage(res);\n}\n\nspace space::domain_map() const\n{\n  auto res = isl_space_domain_map(copy());\n  return manage(res);\n}\n\nspace space::domain_product(space right) const\n{\n  auto res = isl_space_domain_product(copy(), right.release());\n  return manage(res);\n}\n\nspace space::drop_all_params() const\n{\n  auto res = isl_space_drop_all_params(copy());\n  return manage(res);\n}\n\nspace space::drop_dims(isl::dim type, unsigned int first, unsigned int num) const\n{\n  auto res = isl_space_drop_dims(copy(), static_cast<enum isl_dim_type>(type), first, num);\n  return manage(res);\n}\n\nspace space::factor_domain() const\n{\n  auto res = isl_space_factor_domain(copy());\n  return manage(res);\n}\n\nspace space::factor_range() const\n{\n  auto res = isl_space_factor_range(copy());\n  return manage(res);\n}\n\nint space::find_dim_by_id(isl::dim type, const id &id) const\n{\n  auto res = isl_space_find_dim_by_id(get(), static_cast<enum isl_dim_type>(type), id.get());\n  return res;\n}\n\nint space::find_dim_by_name(isl::dim type, const std::string &name) const\n{\n  auto res = isl_space_find_dim_by_name(get(), static_cast<enum isl_dim_type>(type), name.c_str());\n  return res;\n}\n\nspace space::flatten_domain() const\n{\n  auto res = isl_space_flatten_domain(copy());\n  return manage(res);\n}\n\nspace space::flatten_range() const\n{\n  auto res = isl_space_flatten_range(copy());\n  return manage(res);\n}\n\nspace space::from_domain() const\n{\n  auto res = isl_space_from_domain(copy());\n  return manage(res);\n}\n\nspace space::from_range() const\n{\n  auto res = isl_space_from_range(copy());\n  return manage(res);\n}\n\nid space::get_dim_id(isl::dim type, unsigned int pos) const\n{\n  auto res = isl_space_get_dim_id(get(), static_cast<enum isl_dim_type>(type), pos);\n  return manage(res);\n}\n\nstd::string space::get_dim_name(isl::dim type, unsigned int pos) const\n{\n  auto res = isl_space_get_dim_name(get(), static_cast<enum isl_dim_type>(type), pos);\n  std::string tmp(res);\n  return tmp;\n}\n\nid space::get_tuple_id(isl::dim type) const\n{\n  auto res = isl_space_get_tuple_id(get(), static_cast<enum isl_dim_type>(type));\n  return manage(res);\n}\n\nstd::string space::get_tuple_name(isl::dim type) const\n{\n  auto res = isl_space_get_tuple_name(get(), static_cast<enum isl_dim_type>(type));\n  std::string tmp(res);\n  return tmp;\n}\n\nboolean space::has_dim_id(isl::dim type, unsigned int pos) const\n{\n  auto res = isl_space_has_dim_id(get(), static_cast<enum isl_dim_type>(type), pos);\n  return manage(res);\n}\n\nboolean space::has_dim_name(isl::dim type, unsigned int pos) const\n{\n  auto res = isl_space_has_dim_name(get(), static_cast<enum isl_dim_type>(type), pos);\n  return manage(res);\n}\n\nboolean space::has_equal_params(const space &space2) const\n{\n  auto res = isl_space_has_equal_params(get(), space2.get());\n  return manage(res);\n}\n\nboolean space::has_equal_tuples(const space &space2) const\n{\n  auto res = isl_space_has_equal_tuples(get(), space2.get());\n  return manage(res);\n}\n\nboolean space::has_tuple_id(isl::dim type) const\n{\n  auto res = isl_space_has_tuple_id(get(), static_cast<enum isl_dim_type>(type));\n  return manage(res);\n}\n\nboolean space::has_tuple_name(isl::dim type) const\n{\n  auto res = isl_space_has_tuple_name(get(), static_cast<enum isl_dim_type>(type));\n  return manage(res);\n}\n\nspace space::insert_dims(isl::dim type, unsigned int pos, unsigned int n) const\n{\n  auto res = isl_space_insert_dims(copy(), static_cast<enum isl_dim_type>(type), pos, n);\n  return manage(res);\n}\n\nboolean space::is_domain(const space &space2) const\n{\n  auto res = isl_space_is_domain(get(), space2.get());\n  return manage(res);\n}\n\nboolean space::is_equal(const space &space2) const\n{\n  auto res = isl_space_is_equal(get(), space2.get());\n  return manage(res);\n}\n\nboolean space::is_map() const\n{\n  auto res = isl_space_is_map(get());\n  return manage(res);\n}\n\nboolean space::is_params() const\n{\n  auto res = isl_space_is_params(get());\n  return manage(res);\n}\n\nboolean space::is_product() const\n{\n  auto res = isl_space_is_product(get());\n  return manage(res);\n}\n\nboolean space::is_range(const space &space2) const\n{\n  auto res = isl_space_is_range(get(), space2.get());\n  return manage(res);\n}\n\nboolean space::is_set() const\n{\n  auto res = isl_space_is_set(get());\n  return manage(res);\n}\n\nboolean space::is_wrapping() const\n{\n  auto res = isl_space_is_wrapping(get());\n  return manage(res);\n}\n\nspace space::join(space right) const\n{\n  auto res = isl_space_join(copy(), right.release());\n  return manage(res);\n}\n\nspace space::map_from_domain_and_range(space range) const\n{\n  auto res = isl_space_map_from_domain_and_range(copy(), range.release());\n  return manage(res);\n}\n\nspace space::map_from_set() const\n{\n  auto res = isl_space_map_from_set(copy());\n  return manage(res);\n}\n\nspace space::move_dims(isl::dim dst_type, unsigned int dst_pos, isl::dim src_type, unsigned int src_pos, unsigned int n) const\n{\n  auto res = isl_space_move_dims(copy(), static_cast<enum isl_dim_type>(dst_type), dst_pos, static_cast<enum isl_dim_type>(src_type), src_pos, n);\n  return manage(res);\n}\n\nspace space::params() const\n{\n  auto res = isl_space_params(copy());\n  return manage(res);\n}\n\nspace space::params_alloc(ctx ctx, unsigned int nparam)\n{\n  auto res = isl_space_params_alloc(ctx.release(), nparam);\n  return manage(res);\n}\n\nspace space::product(space right) const\n{\n  auto res = isl_space_product(copy(), right.release());\n  return manage(res);\n}\n\nspace space::range() const\n{\n  auto res = isl_space_range(copy());\n  return manage(res);\n}\n\nspace space::range_curry() const\n{\n  auto res = isl_space_range_curry(copy());\n  return manage(res);\n}\n\nspace space::range_factor_domain() const\n{\n  auto res = isl_space_range_factor_domain(copy());\n  return manage(res);\n}\n\nspace space::range_factor_range() const\n{\n  auto res = isl_space_range_factor_range(copy());\n  return manage(res);\n}\n\nboolean space::range_is_wrapping() const\n{\n  auto res = isl_space_range_is_wrapping(get());\n  return manage(res);\n}\n\nspace space::range_map() const\n{\n  auto res = isl_space_range_map(copy());\n  return manage(res);\n}\n\nspace space::range_product(space right) const\n{\n  auto res = isl_space_range_product(copy(), right.release());\n  return manage(res);\n}\n\nspace space::range_reverse() const\n{\n  auto res = isl_space_range_reverse(copy());\n  return manage(res);\n}\n\nspace space::reset_tuple_id(isl::dim type) const\n{\n  auto res = isl_space_reset_tuple_id(copy(), static_cast<enum isl_dim_type>(type));\n  return manage(res);\n}\n\nspace space::reset_user() const\n{\n  auto res = isl_space_reset_user(copy());\n  return manage(res);\n}\n\nspace space::reverse() const\n{\n  auto res = isl_space_reverse(copy());\n  return manage(res);\n}\n\nspace space::set_dim_id(isl::dim type, unsigned int pos, id id) const\n{\n  auto res = isl_space_set_dim_id(copy(), static_cast<enum isl_dim_type>(type), pos, id.release());\n  return manage(res);\n}\n\nspace space::set_from_params() const\n{\n  auto res = isl_space_set_from_params(copy());\n  return manage(res);\n}\n\nspace space::set_tuple_id(isl::dim type, id id) const\n{\n  auto res = isl_space_set_tuple_id(copy(), static_cast<enum isl_dim_type>(type), id.release());\n  return manage(res);\n}\n\nspace space::set_tuple_name(isl::dim type, const std::string &s) const\n{\n  auto res = isl_space_set_tuple_name(copy(), static_cast<enum isl_dim_type>(type), s.c_str());\n  return manage(res);\n}\n\nboolean space::tuple_is_equal(isl::dim type1, const space &space2, isl::dim type2) const\n{\n  auto res = isl_space_tuple_is_equal(get(), static_cast<enum isl_dim_type>(type1), space2.get(), static_cast<enum isl_dim_type>(type2));\n  return manage(res);\n}\n\nspace space::uncurry() const\n{\n  auto res = isl_space_uncurry(copy());\n  return manage(res);\n}\n\nspace space::unit(ctx ctx)\n{\n  auto res = isl_space_unit(ctx.release());\n  return manage(res);\n}\n\nspace space::unwrap() const\n{\n  auto res = isl_space_unwrap(copy());\n  return manage(res);\n}\n\nspace space::wrap() const\n{\n  auto res = isl_space_wrap(copy());\n  return manage(res);\n}\n\nspace space::zip() const\n{\n  auto res = isl_space_zip(copy());\n  return manage(res);\n}\n\n// implementations for isl::term\nterm manage(__isl_take isl_term *ptr) {\n  return term(ptr);\n}\nterm manage_copy(__isl_keep isl_term *ptr) {\n  ptr = isl_term_copy(ptr);\n  return term(ptr);\n}\n\nterm::term()\n    : ptr(nullptr) {}\n\nterm::term(const term &obj)\n    : ptr(nullptr)\n{\n  ptr = obj.copy();\n}\nterm::term(std::nullptr_t)\n    : ptr(nullptr) {}\n\n\nterm::term(__isl_take isl_term *ptr)\n    : ptr(ptr) {}\n\n\nterm &term::operator=(term obj) {\n  std::swap(this->ptr, obj.ptr);\n  return *this;\n}\n\nterm::~term() {\n  if (ptr)\n    isl_term_free(ptr);\n}\n\n__isl_give isl_term *term::copy() const & {\n  return isl_term_copy(ptr);\n}\n\n__isl_keep isl_term *term::get() const {\n  return ptr;\n}\n\n__isl_give isl_term *term::release() {\n  isl_term *tmp = ptr;\n  ptr = nullptr;\n  return tmp;\n}\n\nbool term::is_null() const {\n  return ptr == nullptr;\n}\nterm::operator bool() const {\n  return !is_null();\n}\n\n\nctx term::get_ctx() const {\n  return ctx(isl_term_get_ctx(ptr));\n}\n\n\nisl_size term::dim(isl::dim type) const\n{\n  auto res = isl_term_dim(get(), static_cast<enum isl_dim_type>(type));\n  return res;\n}\n\nval term::get_coefficient_val() const\n{\n  auto res = isl_term_get_coefficient_val(get());\n  return manage(res);\n}\n\naff term::get_div(unsigned int pos) const\n{\n  auto res = isl_term_get_div(get(), pos);\n  return manage(res);\n}\n\nisl_size term::get_exp(isl::dim type, unsigned int pos) const\n{\n  auto res = isl_term_get_exp(get(), static_cast<enum isl_dim_type>(type), pos);\n  return res;\n}\n\n// implementations for isl::union_access_info\nunion_access_info manage(__isl_take isl_union_access_info *ptr) {\n  return union_access_info(ptr);\n}\nunion_access_info manage_copy(__isl_keep isl_union_access_info *ptr) {\n  ptr = isl_union_access_info_copy(ptr);\n  return union_access_info(ptr);\n}\n\nunion_access_info::union_access_info()\n    : ptr(nullptr) {}\n\nunion_access_info::union_access_info(const union_access_info &obj)\n    : ptr(nullptr)\n{\n  ptr = obj.copy();\n}\nunion_access_info::union_access_info(std::nullptr_t)\n    : ptr(nullptr) {}\n\n\nunion_access_info::union_access_info(__isl_take isl_union_access_info *ptr)\n    : ptr(ptr) {}\n\nunion_access_info::union_access_info(union_map sink)\n{\n  auto res = isl_union_access_info_from_sink(sink.release());\n  ptr = res;\n}\n\nunion_access_info &union_access_info::operator=(union_access_info obj) {\n  std::swap(this->ptr, obj.ptr);\n  return *this;\n}\n\nunion_access_info::~union_access_info() {\n  if (ptr)\n    isl_union_access_info_free(ptr);\n}\n\n__isl_give isl_union_access_info *union_access_info::copy() const & {\n  return isl_union_access_info_copy(ptr);\n}\n\n__isl_keep isl_union_access_info *union_access_info::get() const {\n  return ptr;\n}\n\n__isl_give isl_union_access_info *union_access_info::release() {\n  isl_union_access_info *tmp = ptr;\n  ptr = nullptr;\n  return tmp;\n}\n\nbool union_access_info::is_null() const {\n  return ptr == nullptr;\n}\nunion_access_info::operator bool() const {\n  return !is_null();\n}\n\n\nctx union_access_info::get_ctx() const {\n  return ctx(isl_union_access_info_get_ctx(ptr));\n}\nstd::string union_access_info::to_str() const {\n  char *Tmp = isl_union_access_info_to_str(get());\n  if (!Tmp)\n    return \"\";\n  std::string S(Tmp);\n  free(Tmp);\n  return S;\n}\n\n\n\nunion_flow union_access_info::compute_flow() const\n{\n  auto res = isl_union_access_info_compute_flow(copy());\n  return manage(res);\n}\n\nunion_access_info union_access_info::set_kill(union_map kill) const\n{\n  auto res = isl_union_access_info_set_kill(copy(), kill.release());\n  return manage(res);\n}\n\nunion_access_info union_access_info::set_may_source(union_map may_source) const\n{\n  auto res = isl_union_access_info_set_may_source(copy(), may_source.release());\n  return manage(res);\n}\n\nunion_access_info union_access_info::set_must_source(union_map must_source) const\n{\n  auto res = isl_union_access_info_set_must_source(copy(), must_source.release());\n  return manage(res);\n}\n\nunion_access_info union_access_info::set_schedule(schedule schedule) const\n{\n  auto res = isl_union_access_info_set_schedule(copy(), schedule.release());\n  return manage(res);\n}\n\nunion_access_info union_access_info::set_schedule_map(union_map schedule_map) const\n{\n  auto res = isl_union_access_info_set_schedule_map(copy(), schedule_map.release());\n  return manage(res);\n}\n\n// implementations for isl::union_flow\nunion_flow manage(__isl_take isl_union_flow *ptr) {\n  return union_flow(ptr);\n}\nunion_flow manage_copy(__isl_keep isl_union_flow *ptr) {\n  ptr = isl_union_flow_copy(ptr);\n  return union_flow(ptr);\n}\n\nunion_flow::union_flow()\n    : ptr(nullptr) {}\n\nunion_flow::union_flow(const union_flow &obj)\n    : ptr(nullptr)\n{\n  ptr = obj.copy();\n}\nunion_flow::union_flow(std::nullptr_t)\n    : ptr(nullptr) {}\n\n\nunion_flow::union_flow(__isl_take isl_union_flow *ptr)\n    : ptr(ptr) {}\n\n\nunion_flow &union_flow::operator=(union_flow obj) {\n  std::swap(this->ptr, obj.ptr);\n  return *this;\n}\n\nunion_flow::~union_flow() {\n  if (ptr)\n    isl_union_flow_free(ptr);\n}\n\n__isl_give isl_union_flow *union_flow::copy() const & {\n  return isl_union_flow_copy(ptr);\n}\n\n__isl_keep isl_union_flow *union_flow::get() const {\n  return ptr;\n}\n\n__isl_give isl_union_flow *union_flow::release() {\n  isl_union_flow *tmp = ptr;\n  ptr = nullptr;\n  return tmp;\n}\n\nbool union_flow::is_null() const {\n  return ptr == nullptr;\n}\nunion_flow::operator bool() const {\n  return !is_null();\n}\n\n\nctx union_flow::get_ctx() const {\n  return ctx(isl_union_flow_get_ctx(ptr));\n}\nstd::string union_flow::to_str() const {\n  char *Tmp = isl_union_flow_to_str(get());\n  if (!Tmp)\n    return \"\";\n  std::string S(Tmp);\n  free(Tmp);\n  return S;\n}\n\n\n\nunion_map union_flow::get_full_may_dependence() const\n{\n  auto res = isl_union_flow_get_full_may_dependence(get());\n  return manage(res);\n}\n\nunion_map union_flow::get_full_must_dependence() const\n{\n  auto res = isl_union_flow_get_full_must_dependence(get());\n  return manage(res);\n}\n\nunion_map union_flow::get_may_dependence() const\n{\n  auto res = isl_union_flow_get_may_dependence(get());\n  return manage(res);\n}\n\nunion_map union_flow::get_may_no_source() const\n{\n  auto res = isl_union_flow_get_may_no_source(get());\n  return manage(res);\n}\n\nunion_map union_flow::get_must_dependence() const\n{\n  auto res = isl_union_flow_get_must_dependence(get());\n  return manage(res);\n}\n\nunion_map union_flow::get_must_no_source() const\n{\n  auto res = isl_union_flow_get_must_no_source(get());\n  return manage(res);\n}\n\n// implementations for isl::union_map\nunion_map manage(__isl_take isl_union_map *ptr) {\n  return union_map(ptr);\n}\nunion_map manage_copy(__isl_keep isl_union_map *ptr) {\n  ptr = isl_union_map_copy(ptr);\n  return union_map(ptr);\n}\n\nunion_map::union_map()\n    : ptr(nullptr) {}\n\nunion_map::union_map(const union_map &obj)\n    : ptr(nullptr)\n{\n  ptr = obj.copy();\n}\nunion_map::union_map(std::nullptr_t)\n    : ptr(nullptr) {}\n\n\nunion_map::union_map(__isl_take isl_union_map *ptr)\n    : ptr(ptr) {}\n\nunion_map::union_map(basic_map bmap)\n{\n  auto res = isl_union_map_from_basic_map(bmap.release());\n  ptr = res;\n}\nunion_map::union_map(map map)\n{\n  auto res = isl_union_map_from_map(map.release());\n  ptr = res;\n}\nunion_map::union_map(union_pw_multi_aff upma)\n{\n  auto res = isl_union_map_from_union_pw_multi_aff(upma.release());\n  ptr = res;\n}\nunion_map::union_map(ctx ctx, const std::string &str)\n{\n  auto res = isl_union_map_read_from_str(ctx.release(), str.c_str());\n  ptr = res;\n}\n\nunion_map &union_map::operator=(union_map obj) {\n  std::swap(this->ptr, obj.ptr);\n  return *this;\n}\n\nunion_map::~union_map() {\n  if (ptr)\n    isl_union_map_free(ptr);\n}\n\n__isl_give isl_union_map *union_map::copy() const & {\n  return isl_union_map_copy(ptr);\n}\n\n__isl_keep isl_union_map *union_map::get() const {\n  return ptr;\n}\n\n__isl_give isl_union_map *union_map::release() {\n  isl_union_map *tmp = ptr;\n  ptr = nullptr;\n  return tmp;\n}\n\nbool union_map::is_null() const {\n  return ptr == nullptr;\n}\nunion_map::operator bool() const {\n  return !is_null();\n}\n\n\nctx union_map::get_ctx() const {\n  return ctx(isl_union_map_get_ctx(ptr));\n}\nstd::string union_map::to_str() const {\n  char *Tmp = isl_union_map_to_str(get());\n  if (!Tmp)\n    return \"\";\n  std::string S(Tmp);\n  free(Tmp);\n  return S;\n}\n\n\nvoid union_map::dump() const {\n  isl_union_map_dump(get());\n}\n\n\nunion_map union_map::add_map(map map) const\n{\n  auto res = isl_union_map_add_map(copy(), map.release());\n  return manage(res);\n}\n\nunion_map union_map::affine_hull() const\n{\n  auto res = isl_union_map_affine_hull(copy());\n  return manage(res);\n}\n\nunion_map union_map::align_params(space model) const\n{\n  auto res = isl_union_map_align_params(copy(), model.release());\n  return manage(res);\n}\n\nunion_map union_map::apply_domain(union_map umap2) const\n{\n  auto res = isl_union_map_apply_domain(copy(), umap2.release());\n  return manage(res);\n}\n\nunion_map union_map::apply_range(union_map umap2) const\n{\n  auto res = isl_union_map_apply_range(copy(), umap2.release());\n  return manage(res);\n}\n\nunion_set union_map::bind_range(multi_id tuple) const\n{\n  auto res = isl_union_map_bind_range(copy(), tuple.release());\n  return manage(res);\n}\n\nunion_map union_map::coalesce() const\n{\n  auto res = isl_union_map_coalesce(copy());\n  return manage(res);\n}\n\nboolean union_map::contains(const space &space) const\n{\n  auto res = isl_union_map_contains(get(), space.get());\n  return manage(res);\n}\n\nunion_map union_map::curry() const\n{\n  auto res = isl_union_map_curry(copy());\n  return manage(res);\n}\n\nunion_set union_map::deltas() const\n{\n  auto res = isl_union_map_deltas(copy());\n  return manage(res);\n}\n\nunion_map union_map::deltas_map() const\n{\n  auto res = isl_union_map_deltas_map(copy());\n  return manage(res);\n}\n\nunion_map union_map::detect_equalities() const\n{\n  auto res = isl_union_map_detect_equalities(copy());\n  return manage(res);\n}\n\nisl_size union_map::dim(isl::dim type) const\n{\n  auto res = isl_union_map_dim(get(), static_cast<enum isl_dim_type>(type));\n  return res;\n}\n\nunion_set union_map::domain() const\n{\n  auto res = isl_union_map_domain(copy());\n  return manage(res);\n}\n\nunion_map union_map::domain_factor_domain() const\n{\n  auto res = isl_union_map_domain_factor_domain(copy());\n  return manage(res);\n}\n\nunion_map union_map::domain_factor_range() const\n{\n  auto res = isl_union_map_domain_factor_range(copy());\n  return manage(res);\n}\n\nunion_map union_map::domain_map() const\n{\n  auto res = isl_union_map_domain_map(copy());\n  return manage(res);\n}\n\nunion_pw_multi_aff union_map::domain_map_union_pw_multi_aff() const\n{\n  auto res = isl_union_map_domain_map_union_pw_multi_aff(copy());\n  return manage(res);\n}\n\nunion_map union_map::domain_product(union_map umap2) const\n{\n  auto res = isl_union_map_domain_product(copy(), umap2.release());\n  return manage(res);\n}\n\nunion_map union_map::empty(space space)\n{\n  auto res = isl_union_map_empty(space.release());\n  return manage(res);\n}\n\nunion_map union_map::empty(ctx ctx)\n{\n  auto res = isl_union_map_empty_ctx(ctx.release());\n  return manage(res);\n}\n\nunion_map union_map::empty_space(space space)\n{\n  auto res = isl_union_map_empty_space(space.release());\n  return manage(res);\n}\n\nunion_map union_map::eq_at(multi_union_pw_aff mupa) const\n{\n  auto res = isl_union_map_eq_at_multi_union_pw_aff(copy(), mupa.release());\n  return manage(res);\n}\n\nmap union_map::extract_map(space space) const\n{\n  auto res = isl_union_map_extract_map(get(), space.release());\n  return manage(res);\n}\n\nunion_map union_map::factor_domain() const\n{\n  auto res = isl_union_map_factor_domain(copy());\n  return manage(res);\n}\n\nunion_map union_map::factor_range() const\n{\n  auto res = isl_union_map_factor_range(copy());\n  return manage(res);\n}\n\nint union_map::find_dim_by_name(isl::dim type, const std::string &name) const\n{\n  auto res = isl_union_map_find_dim_by_name(get(), static_cast<enum isl_dim_type>(type), name.c_str());\n  return res;\n}\n\nunion_map union_map::fixed_power(val exp) const\n{\n  auto res = isl_union_map_fixed_power_val(copy(), exp.release());\n  return manage(res);\n}\n\nunion_map union_map::flat_domain_product(union_map umap2) const\n{\n  auto res = isl_union_map_flat_domain_product(copy(), umap2.release());\n  return manage(res);\n}\n\nunion_map union_map::flat_range_product(union_map umap2) const\n{\n  auto res = isl_union_map_flat_range_product(copy(), umap2.release());\n  return manage(res);\n}\n\nstat union_map::foreach_map(const std::function<stat(map)> &fn) const\n{\n  struct fn_data {\n    const std::function<stat(map)> *func;\n  } fn_data = { &fn };\n  auto fn_lambda = [](isl_map *arg_0, void *arg_1) -> isl_stat {\n    auto *data = static_cast<struct fn_data *>(arg_1);\n    stat ret = (*data->func)(manage(arg_0));\n    return ret.release();\n  };\n  auto res = isl_union_map_foreach_map(get(), fn_lambda, &fn_data);\n  return manage(res);\n}\n\nunion_map union_map::from(multi_union_pw_aff mupa)\n{\n  auto res = isl_union_map_from_multi_union_pw_aff(mupa.release());\n  return manage(res);\n}\n\nunion_map union_map::from_domain(union_set uset)\n{\n  auto res = isl_union_map_from_domain(uset.release());\n  return manage(res);\n}\n\nunion_map union_map::from_domain_and_range(union_set domain, union_set range)\n{\n  auto res = isl_union_map_from_domain_and_range(domain.release(), range.release());\n  return manage(res);\n}\n\nunion_map union_map::from_range(union_set uset)\n{\n  auto res = isl_union_map_from_range(uset.release());\n  return manage(res);\n}\n\nunion_map union_map::from_union_pw_aff(union_pw_aff upa)\n{\n  auto res = isl_union_map_from_union_pw_aff(upa.release());\n  return manage(res);\n}\n\nid union_map::get_dim_id(isl::dim type, unsigned int pos) const\n{\n  auto res = isl_union_map_get_dim_id(get(), static_cast<enum isl_dim_type>(type), pos);\n  return manage(res);\n}\n\nuint32_t union_map::get_hash() const\n{\n  auto res = isl_union_map_get_hash(get());\n  return res;\n}\n\nmap_list union_map::get_map_list() const\n{\n  auto res = isl_union_map_get_map_list(get());\n  return manage(res);\n}\n\nspace union_map::get_space() const\n{\n  auto res = isl_union_map_get_space(get());\n  return manage(res);\n}\n\nunion_map union_map::gist(union_map context) const\n{\n  auto res = isl_union_map_gist(copy(), context.release());\n  return manage(res);\n}\n\nunion_map union_map::gist_domain(union_set uset) const\n{\n  auto res = isl_union_map_gist_domain(copy(), uset.release());\n  return manage(res);\n}\n\nunion_map union_map::gist_params(set set) const\n{\n  auto res = isl_union_map_gist_params(copy(), set.release());\n  return manage(res);\n}\n\nunion_map union_map::gist_range(union_set uset) const\n{\n  auto res = isl_union_map_gist_range(copy(), uset.release());\n  return manage(res);\n}\n\nunion_map union_map::intersect(union_map umap2) const\n{\n  auto res = isl_union_map_intersect(copy(), umap2.release());\n  return manage(res);\n}\n\nunion_map union_map::intersect_domain(space space) const\n{\n  auto res = isl_union_map_intersect_domain_space(copy(), space.release());\n  return manage(res);\n}\n\nunion_map union_map::intersect_domain(union_set uset) const\n{\n  auto res = isl_union_map_intersect_domain_union_set(copy(), uset.release());\n  return manage(res);\n}\n\nunion_map union_map::intersect_domain_factor_domain(union_map factor) const\n{\n  auto res = isl_union_map_intersect_domain_factor_domain(copy(), factor.release());\n  return manage(res);\n}\n\nunion_map union_map::intersect_domain_factor_range(union_map factor) const\n{\n  auto res = isl_union_map_intersect_domain_factor_range(copy(), factor.release());\n  return manage(res);\n}\n\nunion_map union_map::intersect_params(set set) const\n{\n  auto res = isl_union_map_intersect_params(copy(), set.release());\n  return manage(res);\n}\n\nunion_map union_map::intersect_range(space space) const\n{\n  auto res = isl_union_map_intersect_range_space(copy(), space.release());\n  return manage(res);\n}\n\nunion_map union_map::intersect_range(union_set uset) const\n{\n  auto res = isl_union_map_intersect_range_union_set(copy(), uset.release());\n  return manage(res);\n}\n\nunion_map union_map::intersect_range_factor_domain(union_map factor) const\n{\n  auto res = isl_union_map_intersect_range_factor_domain(copy(), factor.release());\n  return manage(res);\n}\n\nunion_map union_map::intersect_range_factor_range(union_map factor) const\n{\n  auto res = isl_union_map_intersect_range_factor_range(copy(), factor.release());\n  return manage(res);\n}\n\nboolean union_map::involves_dims(isl::dim type, unsigned int first, unsigned int n) const\n{\n  auto res = isl_union_map_involves_dims(get(), static_cast<enum isl_dim_type>(type), first, n);\n  return manage(res);\n}\n\nboolean union_map::is_bijective() const\n{\n  auto res = isl_union_map_is_bijective(get());\n  return manage(res);\n}\n\nboolean union_map::is_disjoint(const union_map &umap2) const\n{\n  auto res = isl_union_map_is_disjoint(get(), umap2.get());\n  return manage(res);\n}\n\nboolean union_map::is_empty() const\n{\n  auto res = isl_union_map_is_empty(get());\n  return manage(res);\n}\n\nboolean union_map::is_equal(const union_map &umap2) const\n{\n  auto res = isl_union_map_is_equal(get(), umap2.get());\n  return manage(res);\n}\n\nboolean union_map::is_identity() const\n{\n  auto res = isl_union_map_is_identity(get());\n  return manage(res);\n}\n\nboolean union_map::is_injective() const\n{\n  auto res = isl_union_map_is_injective(get());\n  return manage(res);\n}\n\nboolean union_map::is_single_valued() const\n{\n  auto res = isl_union_map_is_single_valued(get());\n  return manage(res);\n}\n\nboolean union_map::is_strict_subset(const union_map &umap2) const\n{\n  auto res = isl_union_map_is_strict_subset(get(), umap2.get());\n  return manage(res);\n}\n\nboolean union_map::is_subset(const union_map &umap2) const\n{\n  auto res = isl_union_map_is_subset(get(), umap2.get());\n  return manage(res);\n}\n\nboolean union_map::isa_map() const\n{\n  auto res = isl_union_map_isa_map(get());\n  return manage(res);\n}\n\nunion_map union_map::lex_ge_at_multi_union_pw_aff(multi_union_pw_aff mupa) const\n{\n  auto res = isl_union_map_lex_ge_at_multi_union_pw_aff(copy(), mupa.release());\n  return manage(res);\n}\n\nunion_map union_map::lex_ge_union_map(union_map umap2) const\n{\n  auto res = isl_union_map_lex_ge_union_map(copy(), umap2.release());\n  return manage(res);\n}\n\nunion_map union_map::lex_gt_at_multi_union_pw_aff(multi_union_pw_aff mupa) const\n{\n  auto res = isl_union_map_lex_gt_at_multi_union_pw_aff(copy(), mupa.release());\n  return manage(res);\n}\n\nunion_map union_map::lex_gt_union_map(union_map umap2) const\n{\n  auto res = isl_union_map_lex_gt_union_map(copy(), umap2.release());\n  return manage(res);\n}\n\nunion_map union_map::lex_le_at_multi_union_pw_aff(multi_union_pw_aff mupa) const\n{\n  auto res = isl_union_map_lex_le_at_multi_union_pw_aff(copy(), mupa.release());\n  return manage(res);\n}\n\nunion_map union_map::lex_le_union_map(union_map umap2) const\n{\n  auto res = isl_union_map_lex_le_union_map(copy(), umap2.release());\n  return manage(res);\n}\n\nunion_map union_map::lex_lt_at_multi_union_pw_aff(multi_union_pw_aff mupa) const\n{\n  auto res = isl_union_map_lex_lt_at_multi_union_pw_aff(copy(), mupa.release());\n  return manage(res);\n}\n\nunion_map union_map::lex_lt_union_map(union_map umap2) const\n{\n  auto res = isl_union_map_lex_lt_union_map(copy(), umap2.release());\n  return manage(res);\n}\n\nunion_map union_map::lexmax() const\n{\n  auto res = isl_union_map_lexmax(copy());\n  return manage(res);\n}\n\nunion_map union_map::lexmin() const\n{\n  auto res = isl_union_map_lexmin(copy());\n  return manage(res);\n}\n\nisl_size union_map::n_map() const\n{\n  auto res = isl_union_map_n_map(get());\n  return res;\n}\n\nset union_map::params() const\n{\n  auto res = isl_union_map_params(copy());\n  return manage(res);\n}\n\nboolean union_map::plain_is_empty() const\n{\n  auto res = isl_union_map_plain_is_empty(get());\n  return manage(res);\n}\n\nboolean union_map::plain_is_injective() const\n{\n  auto res = isl_union_map_plain_is_injective(get());\n  return manage(res);\n}\n\nunion_map union_map::polyhedral_hull() const\n{\n  auto res = isl_union_map_polyhedral_hull(copy());\n  return manage(res);\n}\n\nunion_map union_map::preimage_domain(multi_aff ma) const\n{\n  auto res = isl_union_map_preimage_domain_multi_aff(copy(), ma.release());\n  return manage(res);\n}\n\nunion_map union_map::preimage_domain(multi_pw_aff mpa) const\n{\n  auto res = isl_union_map_preimage_domain_multi_pw_aff(copy(), mpa.release());\n  return manage(res);\n}\n\nunion_map union_map::preimage_domain(pw_multi_aff pma) const\n{\n  auto res = isl_union_map_preimage_domain_pw_multi_aff(copy(), pma.release());\n  return manage(res);\n}\n\nunion_map union_map::preimage_domain(union_pw_multi_aff upma) const\n{\n  auto res = isl_union_map_preimage_domain_union_pw_multi_aff(copy(), upma.release());\n  return manage(res);\n}\n\nunion_map union_map::preimage_range(multi_aff ma) const\n{\n  auto res = isl_union_map_preimage_range_multi_aff(copy(), ma.release());\n  return manage(res);\n}\n\nunion_map union_map::preimage_range(pw_multi_aff pma) const\n{\n  auto res = isl_union_map_preimage_range_pw_multi_aff(copy(), pma.release());\n  return manage(res);\n}\n\nunion_map union_map::preimage_range(union_pw_multi_aff upma) const\n{\n  auto res = isl_union_map_preimage_range_union_pw_multi_aff(copy(), upma.release());\n  return manage(res);\n}\n\nunion_map union_map::product(union_map umap2) const\n{\n  auto res = isl_union_map_product(copy(), umap2.release());\n  return manage(res);\n}\n\nunion_map union_map::project_out(isl::dim type, unsigned int first, unsigned int n) const\n{\n  auto res = isl_union_map_project_out(copy(), static_cast<enum isl_dim_type>(type), first, n);\n  return manage(res);\n}\n\nunion_map union_map::project_out_all_params() const\n{\n  auto res = isl_union_map_project_out_all_params(copy());\n  return manage(res);\n}\n\nunion_set union_map::range() const\n{\n  auto res = isl_union_map_range(copy());\n  return manage(res);\n}\n\nunion_map union_map::range_curry() const\n{\n  auto res = isl_union_map_range_curry(copy());\n  return manage(res);\n}\n\nunion_map union_map::range_factor_domain() const\n{\n  auto res = isl_union_map_range_factor_domain(copy());\n  return manage(res);\n}\n\nunion_map union_map::range_factor_range() const\n{\n  auto res = isl_union_map_range_factor_range(copy());\n  return manage(res);\n}\n\nunion_map union_map::range_map() const\n{\n  auto res = isl_union_map_range_map(copy());\n  return manage(res);\n}\n\nunion_map union_map::range_product(union_map umap2) const\n{\n  auto res = isl_union_map_range_product(copy(), umap2.release());\n  return manage(res);\n}\n\nunion_map union_map::range_reverse() const\n{\n  auto res = isl_union_map_range_reverse(copy());\n  return manage(res);\n}\n\nunion_map union_map::remove_divs() const\n{\n  auto res = isl_union_map_remove_divs(copy());\n  return manage(res);\n}\n\nunion_map union_map::remove_redundancies() const\n{\n  auto res = isl_union_map_remove_redundancies(copy());\n  return manage(res);\n}\n\nunion_map union_map::reset_user() const\n{\n  auto res = isl_union_map_reset_user(copy());\n  return manage(res);\n}\n\nunion_map union_map::reverse() const\n{\n  auto res = isl_union_map_reverse(copy());\n  return manage(res);\n}\n\nbasic_map union_map::sample() const\n{\n  auto res = isl_union_map_sample(copy());\n  return manage(res);\n}\n\nunion_map union_map::simple_hull() const\n{\n  auto res = isl_union_map_simple_hull(copy());\n  return manage(res);\n}\n\nunion_map union_map::subtract(union_map umap2) const\n{\n  auto res = isl_union_map_subtract(copy(), umap2.release());\n  return manage(res);\n}\n\nunion_map union_map::subtract_domain(union_set dom) const\n{\n  auto res = isl_union_map_subtract_domain(copy(), dom.release());\n  return manage(res);\n}\n\nunion_map union_map::subtract_range(union_set dom) const\n{\n  auto res = isl_union_map_subtract_range(copy(), dom.release());\n  return manage(res);\n}\n\nunion_map union_map::uncurry() const\n{\n  auto res = isl_union_map_uncurry(copy());\n  return manage(res);\n}\n\nunion_map union_map::unite(union_map umap2) const\n{\n  auto res = isl_union_map_union(copy(), umap2.release());\n  return manage(res);\n}\n\nunion_map union_map::universe() const\n{\n  auto res = isl_union_map_universe(copy());\n  return manage(res);\n}\n\nunion_set union_map::wrap() const\n{\n  auto res = isl_union_map_wrap(copy());\n  return manage(res);\n}\n\nunion_map union_map::zip() const\n{\n  auto res = isl_union_map_zip(copy());\n  return manage(res);\n}\n\n// implementations for isl::union_map_list\nunion_map_list manage(__isl_take isl_union_map_list *ptr) {\n  return union_map_list(ptr);\n}\nunion_map_list manage_copy(__isl_keep isl_union_map_list *ptr) {\n  ptr = isl_union_map_list_copy(ptr);\n  return union_map_list(ptr);\n}\n\nunion_map_list::union_map_list()\n    : ptr(nullptr) {}\n\nunion_map_list::union_map_list(const union_map_list &obj)\n    : ptr(nullptr)\n{\n  ptr = obj.copy();\n}\nunion_map_list::union_map_list(std::nullptr_t)\n    : ptr(nullptr) {}\n\n\nunion_map_list::union_map_list(__isl_take isl_union_map_list *ptr)\n    : ptr(ptr) {}\n\n\nunion_map_list &union_map_list::operator=(union_map_list obj) {\n  std::swap(this->ptr, obj.ptr);\n  return *this;\n}\n\nunion_map_list::~union_map_list() {\n  if (ptr)\n    isl_union_map_list_free(ptr);\n}\n\n__isl_give isl_union_map_list *union_map_list::copy() const & {\n  return isl_union_map_list_copy(ptr);\n}\n\n__isl_keep isl_union_map_list *union_map_list::get() const {\n  return ptr;\n}\n\n__isl_give isl_union_map_list *union_map_list::release() {\n  isl_union_map_list *tmp = ptr;\n  ptr = nullptr;\n  return tmp;\n}\n\nbool union_map_list::is_null() const {\n  return ptr == nullptr;\n}\nunion_map_list::operator bool() const {\n  return !is_null();\n}\n\n\nctx union_map_list::get_ctx() const {\n  return ctx(isl_union_map_list_get_ctx(ptr));\n}\nstd::string union_map_list::to_str() const {\n  char *Tmp = isl_union_map_list_to_str(get());\n  if (!Tmp)\n    return \"\";\n  std::string S(Tmp);\n  free(Tmp);\n  return S;\n}\n\n\nvoid union_map_list::dump() const {\n  isl_union_map_list_dump(get());\n}\n\n\nunion_map_list union_map_list::add(union_map el) const\n{\n  auto res = isl_union_map_list_add(copy(), el.release());\n  return manage(res);\n}\n\nunion_map_list union_map_list::alloc(ctx ctx, int n)\n{\n  auto res = isl_union_map_list_alloc(ctx.release(), n);\n  return manage(res);\n}\n\nunion_map_list union_map_list::clear() const\n{\n  auto res = isl_union_map_list_clear(copy());\n  return manage(res);\n}\n\nunion_map_list union_map_list::concat(union_map_list list2) const\n{\n  auto res = isl_union_map_list_concat(copy(), list2.release());\n  return manage(res);\n}\n\nunion_map_list union_map_list::drop(unsigned int first, unsigned int n) const\n{\n  auto res = isl_union_map_list_drop(copy(), first, n);\n  return manage(res);\n}\n\nstat union_map_list::foreach(const std::function<stat(union_map)> &fn) const\n{\n  struct fn_data {\n    const std::function<stat(union_map)> *func;\n  } fn_data = { &fn };\n  auto fn_lambda = [](isl_union_map *arg_0, void *arg_1) -> isl_stat {\n    auto *data = static_cast<struct fn_data *>(arg_1);\n    stat ret = (*data->func)(manage(arg_0));\n    return ret.release();\n  };\n  auto res = isl_union_map_list_foreach(get(), fn_lambda, &fn_data);\n  return manage(res);\n}\n\nunion_map_list union_map_list::from_union_map(union_map el)\n{\n  auto res = isl_union_map_list_from_union_map(el.release());\n  return manage(res);\n}\n\nunion_map union_map_list::get_at(int index) const\n{\n  auto res = isl_union_map_list_get_at(get(), index);\n  return manage(res);\n}\n\nunion_map union_map_list::get_union_map(int index) const\n{\n  auto res = isl_union_map_list_get_union_map(get(), index);\n  return manage(res);\n}\n\nunion_map_list union_map_list::insert(unsigned int pos, union_map el) const\n{\n  auto res = isl_union_map_list_insert(copy(), pos, el.release());\n  return manage(res);\n}\n\nisl_size union_map_list::n_union_map() const\n{\n  auto res = isl_union_map_list_n_union_map(get());\n  return res;\n}\n\nunion_map_list union_map_list::reverse() const\n{\n  auto res = isl_union_map_list_reverse(copy());\n  return manage(res);\n}\n\nunion_map_list union_map_list::set_union_map(int index, union_map el) const\n{\n  auto res = isl_union_map_list_set_union_map(copy(), index, el.release());\n  return manage(res);\n}\n\nisl_size union_map_list::size() const\n{\n  auto res = isl_union_map_list_size(get());\n  return res;\n}\n\nunion_map_list union_map_list::swap(unsigned int pos1, unsigned int pos2) const\n{\n  auto res = isl_union_map_list_swap(copy(), pos1, pos2);\n  return manage(res);\n}\n\n// implementations for isl::union_pw_aff\nunion_pw_aff manage(__isl_take isl_union_pw_aff *ptr) {\n  return union_pw_aff(ptr);\n}\nunion_pw_aff manage_copy(__isl_keep isl_union_pw_aff *ptr) {\n  ptr = isl_union_pw_aff_copy(ptr);\n  return union_pw_aff(ptr);\n}\n\nunion_pw_aff::union_pw_aff()\n    : ptr(nullptr) {}\n\nunion_pw_aff::union_pw_aff(const union_pw_aff &obj)\n    : ptr(nullptr)\n{\n  ptr = obj.copy();\n}\nunion_pw_aff::union_pw_aff(std::nullptr_t)\n    : ptr(nullptr) {}\n\n\nunion_pw_aff::union_pw_aff(__isl_take isl_union_pw_aff *ptr)\n    : ptr(ptr) {}\n\nunion_pw_aff::union_pw_aff(aff aff)\n{\n  auto res = isl_union_pw_aff_from_aff(aff.release());\n  ptr = res;\n}\nunion_pw_aff::union_pw_aff(pw_aff pa)\n{\n  auto res = isl_union_pw_aff_from_pw_aff(pa.release());\n  ptr = res;\n}\nunion_pw_aff::union_pw_aff(ctx ctx, const std::string &str)\n{\n  auto res = isl_union_pw_aff_read_from_str(ctx.release(), str.c_str());\n  ptr = res;\n}\nunion_pw_aff::union_pw_aff(union_set domain, val v)\n{\n  auto res = isl_union_pw_aff_val_on_domain(domain.release(), v.release());\n  ptr = res;\n}\n\nunion_pw_aff &union_pw_aff::operator=(union_pw_aff obj) {\n  std::swap(this->ptr, obj.ptr);\n  return *this;\n}\n\nunion_pw_aff::~union_pw_aff() {\n  if (ptr)\n    isl_union_pw_aff_free(ptr);\n}\n\n__isl_give isl_union_pw_aff *union_pw_aff::copy() const & {\n  return isl_union_pw_aff_copy(ptr);\n}\n\n__isl_keep isl_union_pw_aff *union_pw_aff::get() const {\n  return ptr;\n}\n\n__isl_give isl_union_pw_aff *union_pw_aff::release() {\n  isl_union_pw_aff *tmp = ptr;\n  ptr = nullptr;\n  return tmp;\n}\n\nbool union_pw_aff::is_null() const {\n  return ptr == nullptr;\n}\nunion_pw_aff::operator bool() const {\n  return !is_null();\n}\n\n\nctx union_pw_aff::get_ctx() const {\n  return ctx(isl_union_pw_aff_get_ctx(ptr));\n}\nstd::string union_pw_aff::to_str() const {\n  char *Tmp = isl_union_pw_aff_to_str(get());\n  if (!Tmp)\n    return \"\";\n  std::string S(Tmp);\n  free(Tmp);\n  return S;\n}\n\n\nvoid union_pw_aff::dump() const {\n  isl_union_pw_aff_dump(get());\n}\n\n\nunion_pw_aff union_pw_aff::add(union_pw_aff upa2) const\n{\n  auto res = isl_union_pw_aff_add(copy(), upa2.release());\n  return manage(res);\n}\n\nunion_pw_aff union_pw_aff::add_pw_aff(pw_aff pa) const\n{\n  auto res = isl_union_pw_aff_add_pw_aff(copy(), pa.release());\n  return manage(res);\n}\n\nunion_pw_aff union_pw_aff::aff_on_domain(union_set domain, aff aff)\n{\n  auto res = isl_union_pw_aff_aff_on_domain(domain.release(), aff.release());\n  return manage(res);\n}\n\nunion_pw_aff union_pw_aff::align_params(space model) const\n{\n  auto res = isl_union_pw_aff_align_params(copy(), model.release());\n  return manage(res);\n}\n\nunion_set union_pw_aff::bind(id id) const\n{\n  auto res = isl_union_pw_aff_bind_id(copy(), id.release());\n  return manage(res);\n}\n\nunion_pw_aff union_pw_aff::coalesce() const\n{\n  auto res = isl_union_pw_aff_coalesce(copy());\n  return manage(res);\n}\n\nisl_size union_pw_aff::dim(isl::dim type) const\n{\n  auto res = isl_union_pw_aff_dim(get(), static_cast<enum isl_dim_type>(type));\n  return res;\n}\n\nunion_set union_pw_aff::domain() const\n{\n  auto res = isl_union_pw_aff_domain(copy());\n  return manage(res);\n}\n\nunion_pw_aff union_pw_aff::drop_dims(isl::dim type, unsigned int first, unsigned int n) const\n{\n  auto res = isl_union_pw_aff_drop_dims(copy(), static_cast<enum isl_dim_type>(type), first, n);\n  return manage(res);\n}\n\nunion_pw_aff union_pw_aff::empty(space space)\n{\n  auto res = isl_union_pw_aff_empty(space.release());\n  return manage(res);\n}\n\nunion_pw_aff union_pw_aff::empty_ctx(ctx ctx)\n{\n  auto res = isl_union_pw_aff_empty_ctx(ctx.release());\n  return manage(res);\n}\n\nunion_pw_aff union_pw_aff::empty_space(space space)\n{\n  auto res = isl_union_pw_aff_empty_space(space.release());\n  return manage(res);\n}\n\npw_aff union_pw_aff::extract_pw_aff(space space) const\n{\n  auto res = isl_union_pw_aff_extract_pw_aff(get(), space.release());\n  return manage(res);\n}\n\nint union_pw_aff::find_dim_by_name(isl::dim type, const std::string &name) const\n{\n  auto res = isl_union_pw_aff_find_dim_by_name(get(), static_cast<enum isl_dim_type>(type), name.c_str());\n  return res;\n}\n\nunion_pw_aff union_pw_aff::floor() const\n{\n  auto res = isl_union_pw_aff_floor(copy());\n  return manage(res);\n}\n\nstat union_pw_aff::foreach_pw_aff(const std::function<stat(pw_aff)> &fn) const\n{\n  struct fn_data {\n    const std::function<stat(pw_aff)> *func;\n  } fn_data = { &fn };\n  auto fn_lambda = [](isl_pw_aff *arg_0, void *arg_1) -> isl_stat {\n    auto *data = static_cast<struct fn_data *>(arg_1);\n    stat ret = (*data->func)(manage(arg_0));\n    return ret.release();\n  };\n  auto res = isl_union_pw_aff_foreach_pw_aff(get(), fn_lambda, &fn_data);\n  return manage(res);\n}\n\npw_aff_list union_pw_aff::get_pw_aff_list() const\n{\n  auto res = isl_union_pw_aff_get_pw_aff_list(get());\n  return manage(res);\n}\n\nspace union_pw_aff::get_space() const\n{\n  auto res = isl_union_pw_aff_get_space(get());\n  return manage(res);\n}\n\nunion_pw_aff union_pw_aff::gist(union_set context) const\n{\n  auto res = isl_union_pw_aff_gist(copy(), context.release());\n  return manage(res);\n}\n\nunion_pw_aff union_pw_aff::gist_params(set context) const\n{\n  auto res = isl_union_pw_aff_gist_params(copy(), context.release());\n  return manage(res);\n}\n\nunion_pw_aff union_pw_aff::intersect_domain(space space) const\n{\n  auto res = isl_union_pw_aff_intersect_domain_space(copy(), space.release());\n  return manage(res);\n}\n\nunion_pw_aff union_pw_aff::intersect_domain(union_set uset) const\n{\n  auto res = isl_union_pw_aff_intersect_domain_union_set(copy(), uset.release());\n  return manage(res);\n}\n\nunion_pw_aff union_pw_aff::intersect_domain_wrapped_domain(union_set uset) const\n{\n  auto res = isl_union_pw_aff_intersect_domain_wrapped_domain(copy(), uset.release());\n  return manage(res);\n}\n\nunion_pw_aff union_pw_aff::intersect_domain_wrapped_range(union_set uset) const\n{\n  auto res = isl_union_pw_aff_intersect_domain_wrapped_range(copy(), uset.release());\n  return manage(res);\n}\n\nunion_pw_aff union_pw_aff::intersect_params(set set) const\n{\n  auto res = isl_union_pw_aff_intersect_params(copy(), set.release());\n  return manage(res);\n}\n\nboolean union_pw_aff::involves_nan() const\n{\n  auto res = isl_union_pw_aff_involves_nan(get());\n  return manage(res);\n}\n\nval union_pw_aff::max_val() const\n{\n  auto res = isl_union_pw_aff_max_val(copy());\n  return manage(res);\n}\n\nval union_pw_aff::min_val() const\n{\n  auto res = isl_union_pw_aff_min_val(copy());\n  return manage(res);\n}\n\nunion_pw_aff union_pw_aff::mod_val(val f) const\n{\n  auto res = isl_union_pw_aff_mod_val(copy(), f.release());\n  return manage(res);\n}\n\nisl_size union_pw_aff::n_pw_aff() const\n{\n  auto res = isl_union_pw_aff_n_pw_aff(get());\n  return res;\n}\n\nunion_pw_aff union_pw_aff::neg() const\n{\n  auto res = isl_union_pw_aff_neg(copy());\n  return manage(res);\n}\n\nunion_pw_aff union_pw_aff::param_on_domain_id(union_set domain, id id)\n{\n  auto res = isl_union_pw_aff_param_on_domain_id(domain.release(), id.release());\n  return manage(res);\n}\n\nboolean union_pw_aff::plain_is_equal(const union_pw_aff &upa2) const\n{\n  auto res = isl_union_pw_aff_plain_is_equal(get(), upa2.get());\n  return manage(res);\n}\n\nunion_pw_aff union_pw_aff::pullback(union_pw_multi_aff upma) const\n{\n  auto res = isl_union_pw_aff_pullback_union_pw_multi_aff(copy(), upma.release());\n  return manage(res);\n}\n\nunion_pw_aff union_pw_aff::pw_aff_on_domain(union_set domain, pw_aff pa)\n{\n  auto res = isl_union_pw_aff_pw_aff_on_domain(domain.release(), pa.release());\n  return manage(res);\n}\n\nunion_pw_aff union_pw_aff::reset_user() const\n{\n  auto res = isl_union_pw_aff_reset_user(copy());\n  return manage(res);\n}\n\nunion_pw_aff union_pw_aff::scale_down_val(val v) const\n{\n  auto res = isl_union_pw_aff_scale_down_val(copy(), v.release());\n  return manage(res);\n}\n\nunion_pw_aff union_pw_aff::scale_val(val v) const\n{\n  auto res = isl_union_pw_aff_scale_val(copy(), v.release());\n  return manage(res);\n}\n\nunion_pw_aff union_pw_aff::sub(union_pw_aff upa2) const\n{\n  auto res = isl_union_pw_aff_sub(copy(), upa2.release());\n  return manage(res);\n}\n\nunion_pw_aff union_pw_aff::subtract_domain(space space) const\n{\n  auto res = isl_union_pw_aff_subtract_domain_space(copy(), space.release());\n  return manage(res);\n}\n\nunion_pw_aff union_pw_aff::subtract_domain(union_set uset) const\n{\n  auto res = isl_union_pw_aff_subtract_domain_union_set(copy(), uset.release());\n  return manage(res);\n}\n\nunion_pw_aff union_pw_aff::union_add(union_pw_aff upa2) const\n{\n  auto res = isl_union_pw_aff_union_add(copy(), upa2.release());\n  return manage(res);\n}\n\nunion_set union_pw_aff::zero_union_set() const\n{\n  auto res = isl_union_pw_aff_zero_union_set(copy());\n  return manage(res);\n}\n\n// implementations for isl::union_pw_aff_list\nunion_pw_aff_list manage(__isl_take isl_union_pw_aff_list *ptr) {\n  return union_pw_aff_list(ptr);\n}\nunion_pw_aff_list manage_copy(__isl_keep isl_union_pw_aff_list *ptr) {\n  ptr = isl_union_pw_aff_list_copy(ptr);\n  return union_pw_aff_list(ptr);\n}\n\nunion_pw_aff_list::union_pw_aff_list()\n    : ptr(nullptr) {}\n\nunion_pw_aff_list::union_pw_aff_list(const union_pw_aff_list &obj)\n    : ptr(nullptr)\n{\n  ptr = obj.copy();\n}\nunion_pw_aff_list::union_pw_aff_list(std::nullptr_t)\n    : ptr(nullptr) {}\n\n\nunion_pw_aff_list::union_pw_aff_list(__isl_take isl_union_pw_aff_list *ptr)\n    : ptr(ptr) {}\n\n\nunion_pw_aff_list &union_pw_aff_list::operator=(union_pw_aff_list obj) {\n  std::swap(this->ptr, obj.ptr);\n  return *this;\n}\n\nunion_pw_aff_list::~union_pw_aff_list() {\n  if (ptr)\n    isl_union_pw_aff_list_free(ptr);\n}\n\n__isl_give isl_union_pw_aff_list *union_pw_aff_list::copy() const & {\n  return isl_union_pw_aff_list_copy(ptr);\n}\n\n__isl_keep isl_union_pw_aff_list *union_pw_aff_list::get() const {\n  return ptr;\n}\n\n__isl_give isl_union_pw_aff_list *union_pw_aff_list::release() {\n  isl_union_pw_aff_list *tmp = ptr;\n  ptr = nullptr;\n  return tmp;\n}\n\nbool union_pw_aff_list::is_null() const {\n  return ptr == nullptr;\n}\nunion_pw_aff_list::operator bool() const {\n  return !is_null();\n}\n\n\nctx union_pw_aff_list::get_ctx() const {\n  return ctx(isl_union_pw_aff_list_get_ctx(ptr));\n}\nstd::string union_pw_aff_list::to_str() const {\n  char *Tmp = isl_union_pw_aff_list_to_str(get());\n  if (!Tmp)\n    return \"\";\n  std::string S(Tmp);\n  free(Tmp);\n  return S;\n}\n\n\nvoid union_pw_aff_list::dump() const {\n  isl_union_pw_aff_list_dump(get());\n}\n\n\nunion_pw_aff_list union_pw_aff_list::add(union_pw_aff el) const\n{\n  auto res = isl_union_pw_aff_list_add(copy(), el.release());\n  return manage(res);\n}\n\nunion_pw_aff_list union_pw_aff_list::alloc(ctx ctx, int n)\n{\n  auto res = isl_union_pw_aff_list_alloc(ctx.release(), n);\n  return manage(res);\n}\n\nunion_pw_aff_list union_pw_aff_list::clear() const\n{\n  auto res = isl_union_pw_aff_list_clear(copy());\n  return manage(res);\n}\n\nunion_pw_aff_list union_pw_aff_list::concat(union_pw_aff_list list2) const\n{\n  auto res = isl_union_pw_aff_list_concat(copy(), list2.release());\n  return manage(res);\n}\n\nunion_pw_aff_list union_pw_aff_list::drop(unsigned int first, unsigned int n) const\n{\n  auto res = isl_union_pw_aff_list_drop(copy(), first, n);\n  return manage(res);\n}\n\nstat union_pw_aff_list::foreach(const std::function<stat(union_pw_aff)> &fn) const\n{\n  struct fn_data {\n    const std::function<stat(union_pw_aff)> *func;\n  } fn_data = { &fn };\n  auto fn_lambda = [](isl_union_pw_aff *arg_0, void *arg_1) -> isl_stat {\n    auto *data = static_cast<struct fn_data *>(arg_1);\n    stat ret = (*data->func)(manage(arg_0));\n    return ret.release();\n  };\n  auto res = isl_union_pw_aff_list_foreach(get(), fn_lambda, &fn_data);\n  return manage(res);\n}\n\nunion_pw_aff_list union_pw_aff_list::from_union_pw_aff(union_pw_aff el)\n{\n  auto res = isl_union_pw_aff_list_from_union_pw_aff(el.release());\n  return manage(res);\n}\n\nunion_pw_aff union_pw_aff_list::get_at(int index) const\n{\n  auto res = isl_union_pw_aff_list_get_at(get(), index);\n  return manage(res);\n}\n\nunion_pw_aff union_pw_aff_list::get_union_pw_aff(int index) const\n{\n  auto res = isl_union_pw_aff_list_get_union_pw_aff(get(), index);\n  return manage(res);\n}\n\nunion_pw_aff_list union_pw_aff_list::insert(unsigned int pos, union_pw_aff el) const\n{\n  auto res = isl_union_pw_aff_list_insert(copy(), pos, el.release());\n  return manage(res);\n}\n\nisl_size union_pw_aff_list::n_union_pw_aff() const\n{\n  auto res = isl_union_pw_aff_list_n_union_pw_aff(get());\n  return res;\n}\n\nunion_pw_aff_list union_pw_aff_list::reverse() const\n{\n  auto res = isl_union_pw_aff_list_reverse(copy());\n  return manage(res);\n}\n\nunion_pw_aff_list union_pw_aff_list::set_union_pw_aff(int index, union_pw_aff el) const\n{\n  auto res = isl_union_pw_aff_list_set_union_pw_aff(copy(), index, el.release());\n  return manage(res);\n}\n\nisl_size union_pw_aff_list::size() const\n{\n  auto res = isl_union_pw_aff_list_size(get());\n  return res;\n}\n\nunion_pw_aff_list union_pw_aff_list::swap(unsigned int pos1, unsigned int pos2) const\n{\n  auto res = isl_union_pw_aff_list_swap(copy(), pos1, pos2);\n  return manage(res);\n}\n\n// implementations for isl::union_pw_multi_aff\nunion_pw_multi_aff manage(__isl_take isl_union_pw_multi_aff *ptr) {\n  return union_pw_multi_aff(ptr);\n}\nunion_pw_multi_aff manage_copy(__isl_keep isl_union_pw_multi_aff *ptr) {\n  ptr = isl_union_pw_multi_aff_copy(ptr);\n  return union_pw_multi_aff(ptr);\n}\n\nunion_pw_multi_aff::union_pw_multi_aff()\n    : ptr(nullptr) {}\n\nunion_pw_multi_aff::union_pw_multi_aff(const union_pw_multi_aff &obj)\n    : ptr(nullptr)\n{\n  ptr = obj.copy();\n}\nunion_pw_multi_aff::union_pw_multi_aff(std::nullptr_t)\n    : ptr(nullptr) {}\n\n\nunion_pw_multi_aff::union_pw_multi_aff(__isl_take isl_union_pw_multi_aff *ptr)\n    : ptr(ptr) {}\n\nunion_pw_multi_aff::union_pw_multi_aff(aff aff)\n{\n  auto res = isl_union_pw_multi_aff_from_aff(aff.release());\n  ptr = res;\n}\nunion_pw_multi_aff::union_pw_multi_aff(union_set uset)\n{\n  auto res = isl_union_pw_multi_aff_from_domain(uset.release());\n  ptr = res;\n}\nunion_pw_multi_aff::union_pw_multi_aff(multi_aff ma)\n{\n  auto res = isl_union_pw_multi_aff_from_multi_aff(ma.release());\n  ptr = res;\n}\nunion_pw_multi_aff::union_pw_multi_aff(multi_union_pw_aff mupa)\n{\n  auto res = isl_union_pw_multi_aff_from_multi_union_pw_aff(mupa.release());\n  ptr = res;\n}\nunion_pw_multi_aff::union_pw_multi_aff(pw_multi_aff pma)\n{\n  auto res = isl_union_pw_multi_aff_from_pw_multi_aff(pma.release());\n  ptr = res;\n}\nunion_pw_multi_aff::union_pw_multi_aff(union_map umap)\n{\n  auto res = isl_union_pw_multi_aff_from_union_map(umap.release());\n  ptr = res;\n}\nunion_pw_multi_aff::union_pw_multi_aff(union_pw_aff upa)\n{\n  auto res = isl_union_pw_multi_aff_from_union_pw_aff(upa.release());\n  ptr = res;\n}\nunion_pw_multi_aff::union_pw_multi_aff(ctx ctx, const std::string &str)\n{\n  auto res = isl_union_pw_multi_aff_read_from_str(ctx.release(), str.c_str());\n  ptr = res;\n}\n\nunion_pw_multi_aff &union_pw_multi_aff::operator=(union_pw_multi_aff obj) {\n  std::swap(this->ptr, obj.ptr);\n  return *this;\n}\n\nunion_pw_multi_aff::~union_pw_multi_aff() {\n  if (ptr)\n    isl_union_pw_multi_aff_free(ptr);\n}\n\n__isl_give isl_union_pw_multi_aff *union_pw_multi_aff::copy() const & {\n  return isl_union_pw_multi_aff_copy(ptr);\n}\n\n__isl_keep isl_union_pw_multi_aff *union_pw_multi_aff::get() const {\n  return ptr;\n}\n\n__isl_give isl_union_pw_multi_aff *union_pw_multi_aff::release() {\n  isl_union_pw_multi_aff *tmp = ptr;\n  ptr = nullptr;\n  return tmp;\n}\n\nbool union_pw_multi_aff::is_null() const {\n  return ptr == nullptr;\n}\nunion_pw_multi_aff::operator bool() const {\n  return !is_null();\n}\n\n\nctx union_pw_multi_aff::get_ctx() const {\n  return ctx(isl_union_pw_multi_aff_get_ctx(ptr));\n}\nstd::string union_pw_multi_aff::to_str() const {\n  char *Tmp = isl_union_pw_multi_aff_to_str(get());\n  if (!Tmp)\n    return \"\";\n  std::string S(Tmp);\n  free(Tmp);\n  return S;\n}\n\n\nvoid union_pw_multi_aff::dump() const {\n  isl_union_pw_multi_aff_dump(get());\n}\n\n\nunion_pw_multi_aff union_pw_multi_aff::add(union_pw_multi_aff upma2) const\n{\n  auto res = isl_union_pw_multi_aff_add(copy(), upma2.release());\n  return manage(res);\n}\n\nunion_pw_multi_aff union_pw_multi_aff::add_pw_multi_aff(pw_multi_aff pma) const\n{\n  auto res = isl_union_pw_multi_aff_add_pw_multi_aff(copy(), pma.release());\n  return manage(res);\n}\n\nunion_pw_multi_aff union_pw_multi_aff::align_params(space model) const\n{\n  auto res = isl_union_pw_multi_aff_align_params(copy(), model.release());\n  return manage(res);\n}\n\nunion_pw_multi_aff union_pw_multi_aff::apply(union_pw_multi_aff upma2) const\n{\n  auto res = isl_union_pw_multi_aff_apply_union_pw_multi_aff(copy(), upma2.release());\n  return manage(res);\n}\n\npw_multi_aff union_pw_multi_aff::as_pw_multi_aff() const\n{\n  auto res = isl_union_pw_multi_aff_as_pw_multi_aff(copy());\n  return manage(res);\n}\n\nunion_pw_multi_aff union_pw_multi_aff::coalesce() const\n{\n  auto res = isl_union_pw_multi_aff_coalesce(copy());\n  return manage(res);\n}\n\nisl_size union_pw_multi_aff::dim(isl::dim type) const\n{\n  auto res = isl_union_pw_multi_aff_dim(get(), static_cast<enum isl_dim_type>(type));\n  return res;\n}\n\nunion_set union_pw_multi_aff::domain() const\n{\n  auto res = isl_union_pw_multi_aff_domain(copy());\n  return manage(res);\n}\n\nunion_pw_multi_aff union_pw_multi_aff::drop_dims(isl::dim type, unsigned int first, unsigned int n) const\n{\n  auto res = isl_union_pw_multi_aff_drop_dims(copy(), static_cast<enum isl_dim_type>(type), first, n);\n  return manage(res);\n}\n\nunion_pw_multi_aff union_pw_multi_aff::empty(space space)\n{\n  auto res = isl_union_pw_multi_aff_empty(space.release());\n  return manage(res);\n}\n\nunion_pw_multi_aff union_pw_multi_aff::empty(ctx ctx)\n{\n  auto res = isl_union_pw_multi_aff_empty_ctx(ctx.release());\n  return manage(res);\n}\n\nunion_pw_multi_aff union_pw_multi_aff::empty_space(space space)\n{\n  auto res = isl_union_pw_multi_aff_empty_space(space.release());\n  return manage(res);\n}\n\npw_multi_aff union_pw_multi_aff::extract_pw_multi_aff(space space) const\n{\n  auto res = isl_union_pw_multi_aff_extract_pw_multi_aff(get(), space.release());\n  return manage(res);\n}\n\nint union_pw_multi_aff::find_dim_by_name(isl::dim type, const std::string &name) const\n{\n  auto res = isl_union_pw_multi_aff_find_dim_by_name(get(), static_cast<enum isl_dim_type>(type), name.c_str());\n  return res;\n}\n\nunion_pw_multi_aff union_pw_multi_aff::flat_range_product(union_pw_multi_aff upma2) const\n{\n  auto res = isl_union_pw_multi_aff_flat_range_product(copy(), upma2.release());\n  return manage(res);\n}\n\nstat union_pw_multi_aff::foreach_pw_multi_aff(const std::function<stat(pw_multi_aff)> &fn) const\n{\n  struct fn_data {\n    const std::function<stat(pw_multi_aff)> *func;\n  } fn_data = { &fn };\n  auto fn_lambda = [](isl_pw_multi_aff *arg_0, void *arg_1) -> isl_stat {\n    auto *data = static_cast<struct fn_data *>(arg_1);\n    stat ret = (*data->func)(manage(arg_0));\n    return ret.release();\n  };\n  auto res = isl_union_pw_multi_aff_foreach_pw_multi_aff(get(), fn_lambda, &fn_data);\n  return manage(res);\n}\n\nunion_pw_multi_aff union_pw_multi_aff::from_union_set(union_set uset)\n{\n  auto res = isl_union_pw_multi_aff_from_union_set(uset.release());\n  return manage(res);\n}\n\npw_multi_aff_list union_pw_multi_aff::get_pw_multi_aff_list() const\n{\n  auto res = isl_union_pw_multi_aff_get_pw_multi_aff_list(get());\n  return manage(res);\n}\n\nspace union_pw_multi_aff::get_space() const\n{\n  auto res = isl_union_pw_multi_aff_get_space(get());\n  return manage(res);\n}\n\nunion_pw_aff union_pw_multi_aff::get_union_pw_aff(int pos) const\n{\n  auto res = isl_union_pw_multi_aff_get_union_pw_aff(get(), pos);\n  return manage(res);\n}\n\nunion_pw_multi_aff union_pw_multi_aff::gist(union_set context) const\n{\n  auto res = isl_union_pw_multi_aff_gist(copy(), context.release());\n  return manage(res);\n}\n\nunion_pw_multi_aff union_pw_multi_aff::gist_params(set context) const\n{\n  auto res = isl_union_pw_multi_aff_gist_params(copy(), context.release());\n  return manage(res);\n}\n\nunion_pw_multi_aff union_pw_multi_aff::intersect_domain(space space) const\n{\n  auto res = isl_union_pw_multi_aff_intersect_domain_space(copy(), space.release());\n  return manage(res);\n}\n\nunion_pw_multi_aff union_pw_multi_aff::intersect_domain(union_set uset) const\n{\n  auto res = isl_union_pw_multi_aff_intersect_domain_union_set(copy(), uset.release());\n  return manage(res);\n}\n\nunion_pw_multi_aff union_pw_multi_aff::intersect_domain_wrapped_domain(union_set uset) const\n{\n  auto res = isl_union_pw_multi_aff_intersect_domain_wrapped_domain(copy(), uset.release());\n  return manage(res);\n}\n\nunion_pw_multi_aff union_pw_multi_aff::intersect_domain_wrapped_range(union_set uset) const\n{\n  auto res = isl_union_pw_multi_aff_intersect_domain_wrapped_range(copy(), uset.release());\n  return manage(res);\n}\n\nunion_pw_multi_aff union_pw_multi_aff::intersect_params(set set) const\n{\n  auto res = isl_union_pw_multi_aff_intersect_params(copy(), set.release());\n  return manage(res);\n}\n\nboolean union_pw_multi_aff::involves_locals() const\n{\n  auto res = isl_union_pw_multi_aff_involves_locals(get());\n  return manage(res);\n}\n\nboolean union_pw_multi_aff::involves_nan() const\n{\n  auto res = isl_union_pw_multi_aff_involves_nan(get());\n  return manage(res);\n}\n\nboolean union_pw_multi_aff::isa_pw_multi_aff() const\n{\n  auto res = isl_union_pw_multi_aff_isa_pw_multi_aff(get());\n  return manage(res);\n}\n\nunion_pw_multi_aff union_pw_multi_aff::multi_val_on_domain(union_set domain, multi_val mv)\n{\n  auto res = isl_union_pw_multi_aff_multi_val_on_domain(domain.release(), mv.release());\n  return manage(res);\n}\n\nisl_size union_pw_multi_aff::n_pw_multi_aff() const\n{\n  auto res = isl_union_pw_multi_aff_n_pw_multi_aff(get());\n  return res;\n}\n\nunion_pw_multi_aff union_pw_multi_aff::neg() const\n{\n  auto res = isl_union_pw_multi_aff_neg(copy());\n  return manage(res);\n}\n\nboolean union_pw_multi_aff::plain_is_empty() const\n{\n  auto res = isl_union_pw_multi_aff_plain_is_empty(get());\n  return manage(res);\n}\n\nboolean union_pw_multi_aff::plain_is_equal(const union_pw_multi_aff &upma2) const\n{\n  auto res = isl_union_pw_multi_aff_plain_is_equal(get(), upma2.get());\n  return manage(res);\n}\n\nunion_pw_multi_aff union_pw_multi_aff::preimage_domain_wrapped_domain(union_pw_multi_aff upma2) const\n{\n  auto res = isl_union_pw_multi_aff_preimage_domain_wrapped_domain_union_pw_multi_aff(copy(), upma2.release());\n  return manage(res);\n}\n\nunion_pw_multi_aff union_pw_multi_aff::pullback(union_pw_multi_aff upma2) const\n{\n  auto res = isl_union_pw_multi_aff_pullback_union_pw_multi_aff(copy(), upma2.release());\n  return manage(res);\n}\n\nunion_pw_multi_aff union_pw_multi_aff::range_factor_domain() const\n{\n  auto res = isl_union_pw_multi_aff_range_factor_domain(copy());\n  return manage(res);\n}\n\nunion_pw_multi_aff union_pw_multi_aff::range_factor_range() const\n{\n  auto res = isl_union_pw_multi_aff_range_factor_range(copy());\n  return manage(res);\n}\n\nunion_pw_multi_aff union_pw_multi_aff::range_product(union_pw_multi_aff upma2) const\n{\n  auto res = isl_union_pw_multi_aff_range_product(copy(), upma2.release());\n  return manage(res);\n}\n\nunion_pw_multi_aff union_pw_multi_aff::reset_user() const\n{\n  auto res = isl_union_pw_multi_aff_reset_user(copy());\n  return manage(res);\n}\n\nunion_pw_multi_aff union_pw_multi_aff::scale_down_val(val val) const\n{\n  auto res = isl_union_pw_multi_aff_scale_down_val(copy(), val.release());\n  return manage(res);\n}\n\nunion_pw_multi_aff union_pw_multi_aff::scale_multi_val(multi_val mv) const\n{\n  auto res = isl_union_pw_multi_aff_scale_multi_val(copy(), mv.release());\n  return manage(res);\n}\n\nunion_pw_multi_aff union_pw_multi_aff::scale_val(val val) const\n{\n  auto res = isl_union_pw_multi_aff_scale_val(copy(), val.release());\n  return manage(res);\n}\n\nunion_pw_multi_aff union_pw_multi_aff::sub(union_pw_multi_aff upma2) const\n{\n  auto res = isl_union_pw_multi_aff_sub(copy(), upma2.release());\n  return manage(res);\n}\n\nunion_pw_multi_aff union_pw_multi_aff::subtract_domain(space space) const\n{\n  auto res = isl_union_pw_multi_aff_subtract_domain_space(copy(), space.release());\n  return manage(res);\n}\n\nunion_pw_multi_aff union_pw_multi_aff::subtract_domain(union_set uset) const\n{\n  auto res = isl_union_pw_multi_aff_subtract_domain_union_set(copy(), uset.release());\n  return manage(res);\n}\n\nunion_pw_multi_aff union_pw_multi_aff::union_add(union_pw_multi_aff upma2) const\n{\n  auto res = isl_union_pw_multi_aff_union_add(copy(), upma2.release());\n  return manage(res);\n}\n\n// implementations for isl::union_pw_multi_aff_list\nunion_pw_multi_aff_list manage(__isl_take isl_union_pw_multi_aff_list *ptr) {\n  return union_pw_multi_aff_list(ptr);\n}\nunion_pw_multi_aff_list manage_copy(__isl_keep isl_union_pw_multi_aff_list *ptr) {\n  ptr = isl_union_pw_multi_aff_list_copy(ptr);\n  return union_pw_multi_aff_list(ptr);\n}\n\nunion_pw_multi_aff_list::union_pw_multi_aff_list()\n    : ptr(nullptr) {}\n\nunion_pw_multi_aff_list::union_pw_multi_aff_list(const union_pw_multi_aff_list &obj)\n    : ptr(nullptr)\n{\n  ptr = obj.copy();\n}\nunion_pw_multi_aff_list::union_pw_multi_aff_list(std::nullptr_t)\n    : ptr(nullptr) {}\n\n\nunion_pw_multi_aff_list::union_pw_multi_aff_list(__isl_take isl_union_pw_multi_aff_list *ptr)\n    : ptr(ptr) {}\n\n\nunion_pw_multi_aff_list &union_pw_multi_aff_list::operator=(union_pw_multi_aff_list obj) {\n  std::swap(this->ptr, obj.ptr);\n  return *this;\n}\n\nunion_pw_multi_aff_list::~union_pw_multi_aff_list() {\n  if (ptr)\n    isl_union_pw_multi_aff_list_free(ptr);\n}\n\n__isl_give isl_union_pw_multi_aff_list *union_pw_multi_aff_list::copy() const & {\n  return isl_union_pw_multi_aff_list_copy(ptr);\n}\n\n__isl_keep isl_union_pw_multi_aff_list *union_pw_multi_aff_list::get() const {\n  return ptr;\n}\n\n__isl_give isl_union_pw_multi_aff_list *union_pw_multi_aff_list::release() {\n  isl_union_pw_multi_aff_list *tmp = ptr;\n  ptr = nullptr;\n  return tmp;\n}\n\nbool union_pw_multi_aff_list::is_null() const {\n  return ptr == nullptr;\n}\nunion_pw_multi_aff_list::operator bool() const {\n  return !is_null();\n}\n\n\nctx union_pw_multi_aff_list::get_ctx() const {\n  return ctx(isl_union_pw_multi_aff_list_get_ctx(ptr));\n}\nstd::string union_pw_multi_aff_list::to_str() const {\n  char *Tmp = isl_union_pw_multi_aff_list_to_str(get());\n  if (!Tmp)\n    return \"\";\n  std::string S(Tmp);\n  free(Tmp);\n  return S;\n}\n\n\nvoid union_pw_multi_aff_list::dump() const {\n  isl_union_pw_multi_aff_list_dump(get());\n}\n\n\nunion_pw_multi_aff_list union_pw_multi_aff_list::add(union_pw_multi_aff el) const\n{\n  auto res = isl_union_pw_multi_aff_list_add(copy(), el.release());\n  return manage(res);\n}\n\nunion_pw_multi_aff_list union_pw_multi_aff_list::alloc(ctx ctx, int n)\n{\n  auto res = isl_union_pw_multi_aff_list_alloc(ctx.release(), n);\n  return manage(res);\n}\n\nunion_pw_multi_aff_list union_pw_multi_aff_list::clear() const\n{\n  auto res = isl_union_pw_multi_aff_list_clear(copy());\n  return manage(res);\n}\n\nunion_pw_multi_aff_list union_pw_multi_aff_list::concat(union_pw_multi_aff_list list2) const\n{\n  auto res = isl_union_pw_multi_aff_list_concat(copy(), list2.release());\n  return manage(res);\n}\n\nunion_pw_multi_aff_list union_pw_multi_aff_list::drop(unsigned int first, unsigned int n) const\n{\n  auto res = isl_union_pw_multi_aff_list_drop(copy(), first, n);\n  return manage(res);\n}\n\nstat union_pw_multi_aff_list::foreach(const std::function<stat(union_pw_multi_aff)> &fn) const\n{\n  struct fn_data {\n    const std::function<stat(union_pw_multi_aff)> *func;\n  } fn_data = { &fn };\n  auto fn_lambda = [](isl_union_pw_multi_aff *arg_0, void *arg_1) -> isl_stat {\n    auto *data = static_cast<struct fn_data *>(arg_1);\n    stat ret = (*data->func)(manage(arg_0));\n    return ret.release();\n  };\n  auto res = isl_union_pw_multi_aff_list_foreach(get(), fn_lambda, &fn_data);\n  return manage(res);\n}\n\nunion_pw_multi_aff_list union_pw_multi_aff_list::from_union_pw_multi_aff(union_pw_multi_aff el)\n{\n  auto res = isl_union_pw_multi_aff_list_from_union_pw_multi_aff(el.release());\n  return manage(res);\n}\n\nunion_pw_multi_aff union_pw_multi_aff_list::get_at(int index) const\n{\n  auto res = isl_union_pw_multi_aff_list_get_at(get(), index);\n  return manage(res);\n}\n\nunion_pw_multi_aff union_pw_multi_aff_list::get_union_pw_multi_aff(int index) const\n{\n  auto res = isl_union_pw_multi_aff_list_get_union_pw_multi_aff(get(), index);\n  return manage(res);\n}\n\nunion_pw_multi_aff_list union_pw_multi_aff_list::insert(unsigned int pos, union_pw_multi_aff el) const\n{\n  auto res = isl_union_pw_multi_aff_list_insert(copy(), pos, el.release());\n  return manage(res);\n}\n\nisl_size union_pw_multi_aff_list::n_union_pw_multi_aff() const\n{\n  auto res = isl_union_pw_multi_aff_list_n_union_pw_multi_aff(get());\n  return res;\n}\n\nunion_pw_multi_aff_list union_pw_multi_aff_list::reverse() const\n{\n  auto res = isl_union_pw_multi_aff_list_reverse(copy());\n  return manage(res);\n}\n\nunion_pw_multi_aff_list union_pw_multi_aff_list::set_union_pw_multi_aff(int index, union_pw_multi_aff el) const\n{\n  auto res = isl_union_pw_multi_aff_list_set_union_pw_multi_aff(copy(), index, el.release());\n  return manage(res);\n}\n\nisl_size union_pw_multi_aff_list::size() const\n{\n  auto res = isl_union_pw_multi_aff_list_size(get());\n  return res;\n}\n\nunion_pw_multi_aff_list union_pw_multi_aff_list::swap(unsigned int pos1, unsigned int pos2) const\n{\n  auto res = isl_union_pw_multi_aff_list_swap(copy(), pos1, pos2);\n  return manage(res);\n}\n\n// implementations for isl::union_pw_qpolynomial\nunion_pw_qpolynomial manage(__isl_take isl_union_pw_qpolynomial *ptr) {\n  return union_pw_qpolynomial(ptr);\n}\nunion_pw_qpolynomial manage_copy(__isl_keep isl_union_pw_qpolynomial *ptr) {\n  ptr = isl_union_pw_qpolynomial_copy(ptr);\n  return union_pw_qpolynomial(ptr);\n}\n\nunion_pw_qpolynomial::union_pw_qpolynomial()\n    : ptr(nullptr) {}\n\nunion_pw_qpolynomial::union_pw_qpolynomial(const union_pw_qpolynomial &obj)\n    : ptr(nullptr)\n{\n  ptr = obj.copy();\n}\nunion_pw_qpolynomial::union_pw_qpolynomial(std::nullptr_t)\n    : ptr(nullptr) {}\n\n\nunion_pw_qpolynomial::union_pw_qpolynomial(__isl_take isl_union_pw_qpolynomial *ptr)\n    : ptr(ptr) {}\n\nunion_pw_qpolynomial::union_pw_qpolynomial(ctx ctx, const std::string &str)\n{\n  auto res = isl_union_pw_qpolynomial_read_from_str(ctx.release(), str.c_str());\n  ptr = res;\n}\n\nunion_pw_qpolynomial &union_pw_qpolynomial::operator=(union_pw_qpolynomial obj) {\n  std::swap(this->ptr, obj.ptr);\n  return *this;\n}\n\nunion_pw_qpolynomial::~union_pw_qpolynomial() {\n  if (ptr)\n    isl_union_pw_qpolynomial_free(ptr);\n}\n\n__isl_give isl_union_pw_qpolynomial *union_pw_qpolynomial::copy() const & {\n  return isl_union_pw_qpolynomial_copy(ptr);\n}\n\n__isl_keep isl_union_pw_qpolynomial *union_pw_qpolynomial::get() const {\n  return ptr;\n}\n\n__isl_give isl_union_pw_qpolynomial *union_pw_qpolynomial::release() {\n  isl_union_pw_qpolynomial *tmp = ptr;\n  ptr = nullptr;\n  return tmp;\n}\n\nbool union_pw_qpolynomial::is_null() const {\n  return ptr == nullptr;\n}\nunion_pw_qpolynomial::operator bool() const {\n  return !is_null();\n}\n\n\nctx union_pw_qpolynomial::get_ctx() const {\n  return ctx(isl_union_pw_qpolynomial_get_ctx(ptr));\n}\nstd::string union_pw_qpolynomial::to_str() const {\n  char *Tmp = isl_union_pw_qpolynomial_to_str(get());\n  if (!Tmp)\n    return \"\";\n  std::string S(Tmp);\n  free(Tmp);\n  return S;\n}\n\n\n\nunion_pw_qpolynomial union_pw_qpolynomial::add(union_pw_qpolynomial upwqp2) const\n{\n  auto res = isl_union_pw_qpolynomial_add(copy(), upwqp2.release());\n  return manage(res);\n}\n\nunion_pw_qpolynomial union_pw_qpolynomial::add_pw_qpolynomial(pw_qpolynomial pwqp) const\n{\n  auto res = isl_union_pw_qpolynomial_add_pw_qpolynomial(copy(), pwqp.release());\n  return manage(res);\n}\n\nunion_pw_qpolynomial union_pw_qpolynomial::align_params(space model) const\n{\n  auto res = isl_union_pw_qpolynomial_align_params(copy(), model.release());\n  return manage(res);\n}\n\nunion_pw_qpolynomial union_pw_qpolynomial::coalesce() const\n{\n  auto res = isl_union_pw_qpolynomial_coalesce(copy());\n  return manage(res);\n}\n\nisl_size union_pw_qpolynomial::dim(isl::dim type) const\n{\n  auto res = isl_union_pw_qpolynomial_dim(get(), static_cast<enum isl_dim_type>(type));\n  return res;\n}\n\nunion_set union_pw_qpolynomial::domain() const\n{\n  auto res = isl_union_pw_qpolynomial_domain(copy());\n  return manage(res);\n}\n\nunion_pw_qpolynomial union_pw_qpolynomial::drop_dims(isl::dim type, unsigned int first, unsigned int n) const\n{\n  auto res = isl_union_pw_qpolynomial_drop_dims(copy(), static_cast<enum isl_dim_type>(type), first, n);\n  return manage(res);\n}\n\nval union_pw_qpolynomial::eval(point pnt) const\n{\n  auto res = isl_union_pw_qpolynomial_eval(copy(), pnt.release());\n  return manage(res);\n}\n\npw_qpolynomial union_pw_qpolynomial::extract_pw_qpolynomial(space space) const\n{\n  auto res = isl_union_pw_qpolynomial_extract_pw_qpolynomial(get(), space.release());\n  return manage(res);\n}\n\nint union_pw_qpolynomial::find_dim_by_name(isl::dim type, const std::string &name) const\n{\n  auto res = isl_union_pw_qpolynomial_find_dim_by_name(get(), static_cast<enum isl_dim_type>(type), name.c_str());\n  return res;\n}\n\nstat union_pw_qpolynomial::foreach_pw_qpolynomial(const std::function<stat(pw_qpolynomial)> &fn) const\n{\n  struct fn_data {\n    const std::function<stat(pw_qpolynomial)> *func;\n  } fn_data = { &fn };\n  auto fn_lambda = [](isl_pw_qpolynomial *arg_0, void *arg_1) -> isl_stat {\n    auto *data = static_cast<struct fn_data *>(arg_1);\n    stat ret = (*data->func)(manage(arg_0));\n    return ret.release();\n  };\n  auto res = isl_union_pw_qpolynomial_foreach_pw_qpolynomial(get(), fn_lambda, &fn_data);\n  return manage(res);\n}\n\nunion_pw_qpolynomial union_pw_qpolynomial::from_pw_qpolynomial(pw_qpolynomial pwqp)\n{\n  auto res = isl_union_pw_qpolynomial_from_pw_qpolynomial(pwqp.release());\n  return manage(res);\n}\n\npw_qpolynomial_list union_pw_qpolynomial::get_pw_qpolynomial_list() const\n{\n  auto res = isl_union_pw_qpolynomial_get_pw_qpolynomial_list(get());\n  return manage(res);\n}\n\nspace union_pw_qpolynomial::get_space() const\n{\n  auto res = isl_union_pw_qpolynomial_get_space(get());\n  return manage(res);\n}\n\nunion_pw_qpolynomial union_pw_qpolynomial::gist(union_set context) const\n{\n  auto res = isl_union_pw_qpolynomial_gist(copy(), context.release());\n  return manage(res);\n}\n\nunion_pw_qpolynomial union_pw_qpolynomial::gist_params(set context) const\n{\n  auto res = isl_union_pw_qpolynomial_gist_params(copy(), context.release());\n  return manage(res);\n}\n\nunion_pw_qpolynomial union_pw_qpolynomial::intersect_domain(union_set uset) const\n{\n  auto res = isl_union_pw_qpolynomial_intersect_domain(copy(), uset.release());\n  return manage(res);\n}\n\nunion_pw_qpolynomial union_pw_qpolynomial::intersect_domain_space(space space) const\n{\n  auto res = isl_union_pw_qpolynomial_intersect_domain_space(copy(), space.release());\n  return manage(res);\n}\n\nunion_pw_qpolynomial union_pw_qpolynomial::intersect_domain_union_set(union_set uset) const\n{\n  auto res = isl_union_pw_qpolynomial_intersect_domain_union_set(copy(), uset.release());\n  return manage(res);\n}\n\nunion_pw_qpolynomial union_pw_qpolynomial::intersect_domain_wrapped_domain(union_set uset) const\n{\n  auto res = isl_union_pw_qpolynomial_intersect_domain_wrapped_domain(copy(), uset.release());\n  return manage(res);\n}\n\nunion_pw_qpolynomial union_pw_qpolynomial::intersect_domain_wrapped_range(union_set uset) const\n{\n  auto res = isl_union_pw_qpolynomial_intersect_domain_wrapped_range(copy(), uset.release());\n  return manage(res);\n}\n\nunion_pw_qpolynomial union_pw_qpolynomial::intersect_params(set set) const\n{\n  auto res = isl_union_pw_qpolynomial_intersect_params(copy(), set.release());\n  return manage(res);\n}\n\nboolean union_pw_qpolynomial::involves_nan() const\n{\n  auto res = isl_union_pw_qpolynomial_involves_nan(get());\n  return manage(res);\n}\n\nunion_pw_qpolynomial union_pw_qpolynomial::mul(union_pw_qpolynomial upwqp2) const\n{\n  auto res = isl_union_pw_qpolynomial_mul(copy(), upwqp2.release());\n  return manage(res);\n}\n\nisl_size union_pw_qpolynomial::n_pw_qpolynomial() const\n{\n  auto res = isl_union_pw_qpolynomial_n_pw_qpolynomial(get());\n  return res;\n}\n\nunion_pw_qpolynomial union_pw_qpolynomial::neg() const\n{\n  auto res = isl_union_pw_qpolynomial_neg(copy());\n  return manage(res);\n}\n\nboolean union_pw_qpolynomial::plain_is_equal(const union_pw_qpolynomial &upwqp2) const\n{\n  auto res = isl_union_pw_qpolynomial_plain_is_equal(get(), upwqp2.get());\n  return manage(res);\n}\n\nunion_pw_qpolynomial union_pw_qpolynomial::reset_user() const\n{\n  auto res = isl_union_pw_qpolynomial_reset_user(copy());\n  return manage(res);\n}\n\nunion_pw_qpolynomial union_pw_qpolynomial::scale_down_val(val v) const\n{\n  auto res = isl_union_pw_qpolynomial_scale_down_val(copy(), v.release());\n  return manage(res);\n}\n\nunion_pw_qpolynomial union_pw_qpolynomial::scale_val(val v) const\n{\n  auto res = isl_union_pw_qpolynomial_scale_val(copy(), v.release());\n  return manage(res);\n}\n\nunion_pw_qpolynomial union_pw_qpolynomial::sub(union_pw_qpolynomial upwqp2) const\n{\n  auto res = isl_union_pw_qpolynomial_sub(copy(), upwqp2.release());\n  return manage(res);\n}\n\nunion_pw_qpolynomial union_pw_qpolynomial::subtract_domain(union_set uset) const\n{\n  auto res = isl_union_pw_qpolynomial_subtract_domain(copy(), uset.release());\n  return manage(res);\n}\n\nunion_pw_qpolynomial union_pw_qpolynomial::subtract_domain_space(space space) const\n{\n  auto res = isl_union_pw_qpolynomial_subtract_domain_space(copy(), space.release());\n  return manage(res);\n}\n\nunion_pw_qpolynomial union_pw_qpolynomial::subtract_domain_union_set(union_set uset) const\n{\n  auto res = isl_union_pw_qpolynomial_subtract_domain_union_set(copy(), uset.release());\n  return manage(res);\n}\n\nunion_pw_qpolynomial union_pw_qpolynomial::to_polynomial(int sign) const\n{\n  auto res = isl_union_pw_qpolynomial_to_polynomial(copy(), sign);\n  return manage(res);\n}\n\nunion_pw_qpolynomial union_pw_qpolynomial::zero(space space)\n{\n  auto res = isl_union_pw_qpolynomial_zero(space.release());\n  return manage(res);\n}\n\nunion_pw_qpolynomial union_pw_qpolynomial::zero_ctx(ctx ctx)\n{\n  auto res = isl_union_pw_qpolynomial_zero_ctx(ctx.release());\n  return manage(res);\n}\n\nunion_pw_qpolynomial union_pw_qpolynomial::zero_space(space space)\n{\n  auto res = isl_union_pw_qpolynomial_zero_space(space.release());\n  return manage(res);\n}\n\n// implementations for isl::union_set\nunion_set manage(__isl_take isl_union_set *ptr) {\n  return union_set(ptr);\n}\nunion_set manage_copy(__isl_keep isl_union_set *ptr) {\n  ptr = isl_union_set_copy(ptr);\n  return union_set(ptr);\n}\n\nunion_set::union_set()\n    : ptr(nullptr) {}\n\nunion_set::union_set(const union_set &obj)\n    : ptr(nullptr)\n{\n  ptr = obj.copy();\n}\nunion_set::union_set(std::nullptr_t)\n    : ptr(nullptr) {}\n\n\nunion_set::union_set(__isl_take isl_union_set *ptr)\n    : ptr(ptr) {}\n\nunion_set::union_set(basic_set bset)\n{\n  auto res = isl_union_set_from_basic_set(bset.release());\n  ptr = res;\n}\nunion_set::union_set(point pnt)\n{\n  auto res = isl_union_set_from_point(pnt.release());\n  ptr = res;\n}\nunion_set::union_set(set set)\n{\n  auto res = isl_union_set_from_set(set.release());\n  ptr = res;\n}\nunion_set::union_set(ctx ctx, const std::string &str)\n{\n  auto res = isl_union_set_read_from_str(ctx.release(), str.c_str());\n  ptr = res;\n}\n\nunion_set &union_set::operator=(union_set obj) {\n  std::swap(this->ptr, obj.ptr);\n  return *this;\n}\n\nunion_set::~union_set() {\n  if (ptr)\n    isl_union_set_free(ptr);\n}\n\n__isl_give isl_union_set *union_set::copy() const & {\n  return isl_union_set_copy(ptr);\n}\n\n__isl_keep isl_union_set *union_set::get() const {\n  return ptr;\n}\n\n__isl_give isl_union_set *union_set::release() {\n  isl_union_set *tmp = ptr;\n  ptr = nullptr;\n  return tmp;\n}\n\nbool union_set::is_null() const {\n  return ptr == nullptr;\n}\nunion_set::operator bool() const {\n  return !is_null();\n}\n\n\nctx union_set::get_ctx() const {\n  return ctx(isl_union_set_get_ctx(ptr));\n}\nstd::string union_set::to_str() const {\n  char *Tmp = isl_union_set_to_str(get());\n  if (!Tmp)\n    return \"\";\n  std::string S(Tmp);\n  free(Tmp);\n  return S;\n}\n\n\nvoid union_set::dump() const {\n  isl_union_set_dump(get());\n}\n\n\nunion_set union_set::add_set(set set) const\n{\n  auto res = isl_union_set_add_set(copy(), set.release());\n  return manage(res);\n}\n\nunion_set union_set::affine_hull() const\n{\n  auto res = isl_union_set_affine_hull(copy());\n  return manage(res);\n}\n\nunion_set union_set::align_params(space model) const\n{\n  auto res = isl_union_set_align_params(copy(), model.release());\n  return manage(res);\n}\n\nunion_set union_set::apply(union_map umap) const\n{\n  auto res = isl_union_set_apply(copy(), umap.release());\n  return manage(res);\n}\n\nunion_set union_set::coalesce() const\n{\n  auto res = isl_union_set_coalesce(copy());\n  return manage(res);\n}\n\nunion_set union_set::coefficients() const\n{\n  auto res = isl_union_set_coefficients(copy());\n  return manage(res);\n}\n\nschedule union_set::compute_schedule(union_map validity, union_map proximity) const\n{\n  auto res = isl_union_set_compute_schedule(copy(), validity.release(), proximity.release());\n  return manage(res);\n}\n\nboolean union_set::contains(const space &space) const\n{\n  auto res = isl_union_set_contains(get(), space.get());\n  return manage(res);\n}\n\nunion_set union_set::detect_equalities() const\n{\n  auto res = isl_union_set_detect_equalities(copy());\n  return manage(res);\n}\n\nisl_size union_set::dim(isl::dim type) const\n{\n  auto res = isl_union_set_dim(get(), static_cast<enum isl_dim_type>(type));\n  return res;\n}\n\nunion_set union_set::empty(space space)\n{\n  auto res = isl_union_set_empty(space.release());\n  return manage(res);\n}\n\nunion_set union_set::empty(ctx ctx)\n{\n  auto res = isl_union_set_empty_ctx(ctx.release());\n  return manage(res);\n}\n\nunion_set union_set::empty_space(space space)\n{\n  auto res = isl_union_set_empty_space(space.release());\n  return manage(res);\n}\n\nset union_set::extract_set(space space) const\n{\n  auto res = isl_union_set_extract_set(get(), space.release());\n  return manage(res);\n}\n\nstat union_set::foreach_point(const std::function<stat(point)> &fn) const\n{\n  struct fn_data {\n    const std::function<stat(point)> *func;\n  } fn_data = { &fn };\n  auto fn_lambda = [](isl_point *arg_0, void *arg_1) -> isl_stat {\n    auto *data = static_cast<struct fn_data *>(arg_1);\n    stat ret = (*data->func)(manage(arg_0));\n    return ret.release();\n  };\n  auto res = isl_union_set_foreach_point(get(), fn_lambda, &fn_data);\n  return manage(res);\n}\n\nstat union_set::foreach_set(const std::function<stat(set)> &fn) const\n{\n  struct fn_data {\n    const std::function<stat(set)> *func;\n  } fn_data = { &fn };\n  auto fn_lambda = [](isl_set *arg_0, void *arg_1) -> isl_stat {\n    auto *data = static_cast<struct fn_data *>(arg_1);\n    stat ret = (*data->func)(manage(arg_0));\n    return ret.release();\n  };\n  auto res = isl_union_set_foreach_set(get(), fn_lambda, &fn_data);\n  return manage(res);\n}\n\nbasic_set_list union_set::get_basic_set_list() const\n{\n  auto res = isl_union_set_get_basic_set_list(get());\n  return manage(res);\n}\n\nuint32_t union_set::get_hash() const\n{\n  auto res = isl_union_set_get_hash(get());\n  return res;\n}\n\nset_list union_set::get_set_list() const\n{\n  auto res = isl_union_set_get_set_list(get());\n  return manage(res);\n}\n\nspace union_set::get_space() const\n{\n  auto res = isl_union_set_get_space(get());\n  return manage(res);\n}\n\nunion_set union_set::gist(union_set context) const\n{\n  auto res = isl_union_set_gist(copy(), context.release());\n  return manage(res);\n}\n\nunion_set union_set::gist_params(set set) const\n{\n  auto res = isl_union_set_gist_params(copy(), set.release());\n  return manage(res);\n}\n\nunion_map union_set::identity() const\n{\n  auto res = isl_union_set_identity(copy());\n  return manage(res);\n}\n\nunion_pw_multi_aff union_set::identity_union_pw_multi_aff() const\n{\n  auto res = isl_union_set_identity_union_pw_multi_aff(copy());\n  return manage(res);\n}\n\nunion_set union_set::intersect(union_set uset2) const\n{\n  auto res = isl_union_set_intersect(copy(), uset2.release());\n  return manage(res);\n}\n\nunion_set union_set::intersect_params(set set) const\n{\n  auto res = isl_union_set_intersect_params(copy(), set.release());\n  return manage(res);\n}\n\nboolean union_set::is_disjoint(const union_set &uset2) const\n{\n  auto res = isl_union_set_is_disjoint(get(), uset2.get());\n  return manage(res);\n}\n\nboolean union_set::is_empty() const\n{\n  auto res = isl_union_set_is_empty(get());\n  return manage(res);\n}\n\nboolean union_set::is_equal(const union_set &uset2) const\n{\n  auto res = isl_union_set_is_equal(get(), uset2.get());\n  return manage(res);\n}\n\nboolean union_set::is_params() const\n{\n  auto res = isl_union_set_is_params(get());\n  return manage(res);\n}\n\nboolean union_set::is_strict_subset(const union_set &uset2) const\n{\n  auto res = isl_union_set_is_strict_subset(get(), uset2.get());\n  return manage(res);\n}\n\nboolean union_set::is_subset(const union_set &uset2) const\n{\n  auto res = isl_union_set_is_subset(get(), uset2.get());\n  return manage(res);\n}\n\nboolean union_set::isa_set() const\n{\n  auto res = isl_union_set_isa_set(get());\n  return manage(res);\n}\n\nunion_map union_set::lex_ge_union_set(union_set uset2) const\n{\n  auto res = isl_union_set_lex_ge_union_set(copy(), uset2.release());\n  return manage(res);\n}\n\nunion_map union_set::lex_gt_union_set(union_set uset2) const\n{\n  auto res = isl_union_set_lex_gt_union_set(copy(), uset2.release());\n  return manage(res);\n}\n\nunion_map union_set::lex_le_union_set(union_set uset2) const\n{\n  auto res = isl_union_set_lex_le_union_set(copy(), uset2.release());\n  return manage(res);\n}\n\nunion_map union_set::lex_lt_union_set(union_set uset2) const\n{\n  auto res = isl_union_set_lex_lt_union_set(copy(), uset2.release());\n  return manage(res);\n}\n\nunion_set union_set::lexmax() const\n{\n  auto res = isl_union_set_lexmax(copy());\n  return manage(res);\n}\n\nunion_set union_set::lexmin() const\n{\n  auto res = isl_union_set_lexmin(copy());\n  return manage(res);\n}\n\nmulti_val union_set::min_multi_union_pw_aff(const multi_union_pw_aff &obj) const\n{\n  auto res = isl_union_set_min_multi_union_pw_aff(get(), obj.get());\n  return manage(res);\n}\n\nisl_size union_set::n_set() const\n{\n  auto res = isl_union_set_n_set(get());\n  return res;\n}\n\nset union_set::params() const\n{\n  auto res = isl_union_set_params(copy());\n  return manage(res);\n}\n\nunion_set union_set::polyhedral_hull() const\n{\n  auto res = isl_union_set_polyhedral_hull(copy());\n  return manage(res);\n}\n\nunion_set union_set::preimage(multi_aff ma) const\n{\n  auto res = isl_union_set_preimage_multi_aff(copy(), ma.release());\n  return manage(res);\n}\n\nunion_set union_set::preimage(pw_multi_aff pma) const\n{\n  auto res = isl_union_set_preimage_pw_multi_aff(copy(), pma.release());\n  return manage(res);\n}\n\nunion_set union_set::preimage(union_pw_multi_aff upma) const\n{\n  auto res = isl_union_set_preimage_union_pw_multi_aff(copy(), upma.release());\n  return manage(res);\n}\n\nunion_set union_set::product(union_set uset2) const\n{\n  auto res = isl_union_set_product(copy(), uset2.release());\n  return manage(res);\n}\n\nunion_set union_set::project_out(isl::dim type, unsigned int first, unsigned int n) const\n{\n  auto res = isl_union_set_project_out(copy(), static_cast<enum isl_dim_type>(type), first, n);\n  return manage(res);\n}\n\nunion_set union_set::project_out_all_params() const\n{\n  auto res = isl_union_set_project_out_all_params(copy());\n  return manage(res);\n}\n\nunion_set union_set::remove_divs() const\n{\n  auto res = isl_union_set_remove_divs(copy());\n  return manage(res);\n}\n\nunion_set union_set::remove_redundancies() const\n{\n  auto res = isl_union_set_remove_redundancies(copy());\n  return manage(res);\n}\n\nunion_set union_set::reset_user() const\n{\n  auto res = isl_union_set_reset_user(copy());\n  return manage(res);\n}\n\nbasic_set union_set::sample() const\n{\n  auto res = isl_union_set_sample(copy());\n  return manage(res);\n}\n\npoint union_set::sample_point() const\n{\n  auto res = isl_union_set_sample_point(copy());\n  return manage(res);\n}\n\nunion_set union_set::simple_hull() const\n{\n  auto res = isl_union_set_simple_hull(copy());\n  return manage(res);\n}\n\nunion_set union_set::solutions() const\n{\n  auto res = isl_union_set_solutions(copy());\n  return manage(res);\n}\n\nunion_set union_set::subtract(union_set uset2) const\n{\n  auto res = isl_union_set_subtract(copy(), uset2.release());\n  return manage(res);\n}\n\nunion_set union_set::unite(union_set uset2) const\n{\n  auto res = isl_union_set_union(copy(), uset2.release());\n  return manage(res);\n}\n\nunion_set union_set::universe() const\n{\n  auto res = isl_union_set_universe(copy());\n  return manage(res);\n}\n\nunion_map union_set::unwrap() const\n{\n  auto res = isl_union_set_unwrap(copy());\n  return manage(res);\n}\n\nunion_map union_set::wrapped_domain_map() const\n{\n  auto res = isl_union_set_wrapped_domain_map(copy());\n  return manage(res);\n}\n\n// implementations for isl::union_set_list\nunion_set_list manage(__isl_take isl_union_set_list *ptr) {\n  return union_set_list(ptr);\n}\nunion_set_list manage_copy(__isl_keep isl_union_set_list *ptr) {\n  ptr = isl_union_set_list_copy(ptr);\n  return union_set_list(ptr);\n}\n\nunion_set_list::union_set_list()\n    : ptr(nullptr) {}\n\nunion_set_list::union_set_list(const union_set_list &obj)\n    : ptr(nullptr)\n{\n  ptr = obj.copy();\n}\nunion_set_list::union_set_list(std::nullptr_t)\n    : ptr(nullptr) {}\n\n\nunion_set_list::union_set_list(__isl_take isl_union_set_list *ptr)\n    : ptr(ptr) {}\n\n\nunion_set_list &union_set_list::operator=(union_set_list obj) {\n  std::swap(this->ptr, obj.ptr);\n  return *this;\n}\n\nunion_set_list::~union_set_list() {\n  if (ptr)\n    isl_union_set_list_free(ptr);\n}\n\n__isl_give isl_union_set_list *union_set_list::copy() const & {\n  return isl_union_set_list_copy(ptr);\n}\n\n__isl_keep isl_union_set_list *union_set_list::get() const {\n  return ptr;\n}\n\n__isl_give isl_union_set_list *union_set_list::release() {\n  isl_union_set_list *tmp = ptr;\n  ptr = nullptr;\n  return tmp;\n}\n\nbool union_set_list::is_null() const {\n  return ptr == nullptr;\n}\nunion_set_list::operator bool() const {\n  return !is_null();\n}\n\n\nctx union_set_list::get_ctx() const {\n  return ctx(isl_union_set_list_get_ctx(ptr));\n}\nstd::string union_set_list::to_str() const {\n  char *Tmp = isl_union_set_list_to_str(get());\n  if (!Tmp)\n    return \"\";\n  std::string S(Tmp);\n  free(Tmp);\n  return S;\n}\n\n\nvoid union_set_list::dump() const {\n  isl_union_set_list_dump(get());\n}\n\n\nunion_set_list union_set_list::add(union_set el) const\n{\n  auto res = isl_union_set_list_add(copy(), el.release());\n  return manage(res);\n}\n\nunion_set_list union_set_list::alloc(ctx ctx, int n)\n{\n  auto res = isl_union_set_list_alloc(ctx.release(), n);\n  return manage(res);\n}\n\nunion_set_list union_set_list::clear() const\n{\n  auto res = isl_union_set_list_clear(copy());\n  return manage(res);\n}\n\nunion_set_list union_set_list::concat(union_set_list list2) const\n{\n  auto res = isl_union_set_list_concat(copy(), list2.release());\n  return manage(res);\n}\n\nunion_set_list union_set_list::drop(unsigned int first, unsigned int n) const\n{\n  auto res = isl_union_set_list_drop(copy(), first, n);\n  return manage(res);\n}\n\nstat union_set_list::foreach(const std::function<stat(union_set)> &fn) const\n{\n  struct fn_data {\n    const std::function<stat(union_set)> *func;\n  } fn_data = { &fn };\n  auto fn_lambda = [](isl_union_set *arg_0, void *arg_1) -> isl_stat {\n    auto *data = static_cast<struct fn_data *>(arg_1);\n    stat ret = (*data->func)(manage(arg_0));\n    return ret.release();\n  };\n  auto res = isl_union_set_list_foreach(get(), fn_lambda, &fn_data);\n  return manage(res);\n}\n\nunion_set_list union_set_list::from_union_set(union_set el)\n{\n  auto res = isl_union_set_list_from_union_set(el.release());\n  return manage(res);\n}\n\nunion_set union_set_list::get_at(int index) const\n{\n  auto res = isl_union_set_list_get_at(get(), index);\n  return manage(res);\n}\n\nunion_set union_set_list::get_union_set(int index) const\n{\n  auto res = isl_union_set_list_get_union_set(get(), index);\n  return manage(res);\n}\n\nunion_set_list union_set_list::insert(unsigned int pos, union_set el) const\n{\n  auto res = isl_union_set_list_insert(copy(), pos, el.release());\n  return manage(res);\n}\n\nisl_size union_set_list::n_union_set() const\n{\n  auto res = isl_union_set_list_n_union_set(get());\n  return res;\n}\n\nunion_set_list union_set_list::reverse() const\n{\n  auto res = isl_union_set_list_reverse(copy());\n  return manage(res);\n}\n\nunion_set_list union_set_list::set_union_set(int index, union_set el) const\n{\n  auto res = isl_union_set_list_set_union_set(copy(), index, el.release());\n  return manage(res);\n}\n\nisl_size union_set_list::size() const\n{\n  auto res = isl_union_set_list_size(get());\n  return res;\n}\n\nunion_set_list union_set_list::swap(unsigned int pos1, unsigned int pos2) const\n{\n  auto res = isl_union_set_list_swap(copy(), pos1, pos2);\n  return manage(res);\n}\n\nunion_set union_set_list::unite() const\n{\n  auto res = isl_union_set_list_union(copy());\n  return manage(res);\n}\n\n// implementations for isl::val\nval manage(__isl_take isl_val *ptr) {\n  return val(ptr);\n}\nval manage_copy(__isl_keep isl_val *ptr) {\n  ptr = isl_val_copy(ptr);\n  return val(ptr);\n}\n\nval::val()\n    : ptr(nullptr) {}\n\nval::val(const val &obj)\n    : ptr(nullptr)\n{\n  ptr = obj.copy();\n}\nval::val(std::nullptr_t)\n    : ptr(nullptr) {}\n\n\nval::val(__isl_take isl_val *ptr)\n    : ptr(ptr) {}\n\nval::val(ctx ctx, long i)\n{\n  auto res = isl_val_int_from_si(ctx.release(), i);\n  ptr = res;\n}\nval::val(ctx ctx, const std::string &str)\n{\n  auto res = isl_val_read_from_str(ctx.release(), str.c_str());\n  ptr = res;\n}\n\nval &val::operator=(val obj) {\n  std::swap(this->ptr, obj.ptr);\n  return *this;\n}\n\nval::~val() {\n  if (ptr)\n    isl_val_free(ptr);\n}\n\n__isl_give isl_val *val::copy() const & {\n  return isl_val_copy(ptr);\n}\n\n__isl_keep isl_val *val::get() const {\n  return ptr;\n}\n\n__isl_give isl_val *val::release() {\n  isl_val *tmp = ptr;\n  ptr = nullptr;\n  return tmp;\n}\n\nbool val::is_null() const {\n  return ptr == nullptr;\n}\nval::operator bool() const {\n  return !is_null();\n}\n\n\nctx val::get_ctx() const {\n  return ctx(isl_val_get_ctx(ptr));\n}\nstd::string val::to_str() const {\n  char *Tmp = isl_val_to_str(get());\n  if (!Tmp)\n    return \"\";\n  std::string S(Tmp);\n  free(Tmp);\n  return S;\n}\n\n\nvoid val::dump() const {\n  isl_val_dump(get());\n}\n\n\nval val::abs() const\n{\n  auto res = isl_val_abs(copy());\n  return manage(res);\n}\n\nboolean val::abs_eq(const val &v2) const\n{\n  auto res = isl_val_abs_eq(get(), v2.get());\n  return manage(res);\n}\n\nval val::add(val v2) const\n{\n  auto res = isl_val_add(copy(), v2.release());\n  return manage(res);\n}\n\nval val::add_ui(unsigned long v2) const\n{\n  auto res = isl_val_add_ui(copy(), v2);\n  return manage(res);\n}\n\nval val::ceil() const\n{\n  auto res = isl_val_ceil(copy());\n  return manage(res);\n}\n\nint val::cmp_si(long i) const\n{\n  auto res = isl_val_cmp_si(get(), i);\n  return res;\n}\n\nval val::div(val v2) const\n{\n  auto res = isl_val_div(copy(), v2.release());\n  return manage(res);\n}\n\nval val::div_ui(unsigned long v2) const\n{\n  auto res = isl_val_div_ui(copy(), v2);\n  return manage(res);\n}\n\nboolean val::eq(const val &v2) const\n{\n  auto res = isl_val_eq(get(), v2.get());\n  return manage(res);\n}\n\nboolean val::eq_si(long i) const\n{\n  auto res = isl_val_eq_si(get(), i);\n  return manage(res);\n}\n\nval val::floor() const\n{\n  auto res = isl_val_floor(copy());\n  return manage(res);\n}\n\nval val::gcd(val v2) const\n{\n  auto res = isl_val_gcd(copy(), v2.release());\n  return manage(res);\n}\n\nboolean val::ge(const val &v2) const\n{\n  auto res = isl_val_ge(get(), v2.get());\n  return manage(res);\n}\n\nuint32_t val::get_hash() const\n{\n  auto res = isl_val_get_hash(get());\n  return res;\n}\n\nlong val::get_num_si() const\n{\n  auto res = isl_val_get_num_si(get());\n  return res;\n}\n\nboolean val::gt(const val &v2) const\n{\n  auto res = isl_val_gt(get(), v2.get());\n  return manage(res);\n}\n\nboolean val::gt_si(long i) const\n{\n  auto res = isl_val_gt_si(get(), i);\n  return manage(res);\n}\n\nval val::infty(ctx ctx)\n{\n  auto res = isl_val_infty(ctx.release());\n  return manage(res);\n}\n\nval val::int_from_ui(ctx ctx, unsigned long u)\n{\n  auto res = isl_val_int_from_ui(ctx.release(), u);\n  return manage(res);\n}\n\nval val::inv() const\n{\n  auto res = isl_val_inv(copy());\n  return manage(res);\n}\n\nboolean val::is_divisible_by(const val &v2) const\n{\n  auto res = isl_val_is_divisible_by(get(), v2.get());\n  return manage(res);\n}\n\nboolean val::is_infty() const\n{\n  auto res = isl_val_is_infty(get());\n  return manage(res);\n}\n\nboolean val::is_int() const\n{\n  auto res = isl_val_is_int(get());\n  return manage(res);\n}\n\nboolean val::is_nan() const\n{\n  auto res = isl_val_is_nan(get());\n  return manage(res);\n}\n\nboolean val::is_neg() const\n{\n  auto res = isl_val_is_neg(get());\n  return manage(res);\n}\n\nboolean val::is_neginfty() const\n{\n  auto res = isl_val_is_neginfty(get());\n  return manage(res);\n}\n\nboolean val::is_negone() const\n{\n  auto res = isl_val_is_negone(get());\n  return manage(res);\n}\n\nboolean val::is_nonneg() const\n{\n  auto res = isl_val_is_nonneg(get());\n  return manage(res);\n}\n\nboolean val::is_nonpos() const\n{\n  auto res = isl_val_is_nonpos(get());\n  return manage(res);\n}\n\nboolean val::is_one() const\n{\n  auto res = isl_val_is_one(get());\n  return manage(res);\n}\n\nboolean val::is_pos() const\n{\n  auto res = isl_val_is_pos(get());\n  return manage(res);\n}\n\nboolean val::is_rat() const\n{\n  auto res = isl_val_is_rat(get());\n  return manage(res);\n}\n\nboolean val::is_zero() const\n{\n  auto res = isl_val_is_zero(get());\n  return manage(res);\n}\n\nboolean val::le(const val &v2) const\n{\n  auto res = isl_val_le(get(), v2.get());\n  return manage(res);\n}\n\nboolean val::lt(const val &v2) const\n{\n  auto res = isl_val_lt(get(), v2.get());\n  return manage(res);\n}\n\nval val::max(val v2) const\n{\n  auto res = isl_val_max(copy(), v2.release());\n  return manage(res);\n}\n\nval val::min(val v2) const\n{\n  auto res = isl_val_min(copy(), v2.release());\n  return manage(res);\n}\n\nval val::mod(val v2) const\n{\n  auto res = isl_val_mod(copy(), v2.release());\n  return manage(res);\n}\n\nval val::mul(val v2) const\n{\n  auto res = isl_val_mul(copy(), v2.release());\n  return manage(res);\n}\n\nval val::mul_ui(unsigned long v2) const\n{\n  auto res = isl_val_mul_ui(copy(), v2);\n  return manage(res);\n}\n\nisl_size val::n_abs_num_chunks(size_t size) const\n{\n  auto res = isl_val_n_abs_num_chunks(get(), size);\n  return res;\n}\n\nval val::nan(ctx ctx)\n{\n  auto res = isl_val_nan(ctx.release());\n  return manage(res);\n}\n\nboolean val::ne(const val &v2) const\n{\n  auto res = isl_val_ne(get(), v2.get());\n  return manage(res);\n}\n\nval val::neg() const\n{\n  auto res = isl_val_neg(copy());\n  return manage(res);\n}\n\nval val::neginfty(ctx ctx)\n{\n  auto res = isl_val_neginfty(ctx.release());\n  return manage(res);\n}\n\nval val::negone(ctx ctx)\n{\n  auto res = isl_val_negone(ctx.release());\n  return manage(res);\n}\n\nval val::one(ctx ctx)\n{\n  auto res = isl_val_one(ctx.release());\n  return manage(res);\n}\n\nval val::pow2() const\n{\n  auto res = isl_val_pow2(copy());\n  return manage(res);\n}\n\nval val::set_si(long i) const\n{\n  auto res = isl_val_set_si(copy(), i);\n  return manage(res);\n}\n\nint val::sgn() const\n{\n  auto res = isl_val_sgn(get());\n  return res;\n}\n\nval val::sub(val v2) const\n{\n  auto res = isl_val_sub(copy(), v2.release());\n  return manage(res);\n}\n\nval val::sub_ui(unsigned long v2) const\n{\n  auto res = isl_val_sub_ui(copy(), v2);\n  return manage(res);\n}\n\nval val::trunc() const\n{\n  auto res = isl_val_trunc(copy());\n  return manage(res);\n}\n\nval val::zero(ctx ctx)\n{\n  auto res = isl_val_zero(ctx.release());\n  return manage(res);\n}\n\n// implementations for isl::val_list\nval_list manage(__isl_take isl_val_list *ptr) {\n  return val_list(ptr);\n}\nval_list manage_copy(__isl_keep isl_val_list *ptr) {\n  ptr = isl_val_list_copy(ptr);\n  return val_list(ptr);\n}\n\nval_list::val_list()\n    : ptr(nullptr) {}\n\nval_list::val_list(const val_list &obj)\n    : ptr(nullptr)\n{\n  ptr = obj.copy();\n}\nval_list::val_list(std::nullptr_t)\n    : ptr(nullptr) {}\n\n\nval_list::val_list(__isl_take isl_val_list *ptr)\n    : ptr(ptr) {}\n\n\nval_list &val_list::operator=(val_list obj) {\n  std::swap(this->ptr, obj.ptr);\n  return *this;\n}\n\nval_list::~val_list() {\n  if (ptr)\n    isl_val_list_free(ptr);\n}\n\n__isl_give isl_val_list *val_list::copy() const & {\n  return isl_val_list_copy(ptr);\n}\n\n__isl_keep isl_val_list *val_list::get() const {\n  return ptr;\n}\n\n__isl_give isl_val_list *val_list::release() {\n  isl_val_list *tmp = ptr;\n  ptr = nullptr;\n  return tmp;\n}\n\nbool val_list::is_null() const {\n  return ptr == nullptr;\n}\nval_list::operator bool() const {\n  return !is_null();\n}\n\n\nctx val_list::get_ctx() const {\n  return ctx(isl_val_list_get_ctx(ptr));\n}\nstd::string val_list::to_str() const {\n  char *Tmp = isl_val_list_to_str(get());\n  if (!Tmp)\n    return \"\";\n  std::string S(Tmp);\n  free(Tmp);\n  return S;\n}\n\n\nvoid val_list::dump() const {\n  isl_val_list_dump(get());\n}\n\n\nval_list val_list::add(val el) const\n{\n  auto res = isl_val_list_add(copy(), el.release());\n  return manage(res);\n}\n\nval_list val_list::alloc(ctx ctx, int n)\n{\n  auto res = isl_val_list_alloc(ctx.release(), n);\n  return manage(res);\n}\n\nval_list val_list::clear() const\n{\n  auto res = isl_val_list_clear(copy());\n  return manage(res);\n}\n\nval_list val_list::concat(val_list list2) const\n{\n  auto res = isl_val_list_concat(copy(), list2.release());\n  return manage(res);\n}\n\nval_list val_list::drop(unsigned int first, unsigned int n) const\n{\n  auto res = isl_val_list_drop(copy(), first, n);\n  return manage(res);\n}\n\nstat val_list::foreach(const std::function<stat(val)> &fn) const\n{\n  struct fn_data {\n    const std::function<stat(val)> *func;\n  } fn_data = { &fn };\n  auto fn_lambda = [](isl_val *arg_0, void *arg_1) -> isl_stat {\n    auto *data = static_cast<struct fn_data *>(arg_1);\n    stat ret = (*data->func)(manage(arg_0));\n    return ret.release();\n  };\n  auto res = isl_val_list_foreach(get(), fn_lambda, &fn_data);\n  return manage(res);\n}\n\nval_list val_list::from_val(val el)\n{\n  auto res = isl_val_list_from_val(el.release());\n  return manage(res);\n}\n\nval val_list::get_at(int index) const\n{\n  auto res = isl_val_list_get_at(get(), index);\n  return manage(res);\n}\n\nval val_list::get_val(int index) const\n{\n  auto res = isl_val_list_get_val(get(), index);\n  return manage(res);\n}\n\nval_list val_list::insert(unsigned int pos, val el) const\n{\n  auto res = isl_val_list_insert(copy(), pos, el.release());\n  return manage(res);\n}\n\nisl_size val_list::n_val() const\n{\n  auto res = isl_val_list_n_val(get());\n  return res;\n}\n\nval_list val_list::reverse() const\n{\n  auto res = isl_val_list_reverse(copy());\n  return manage(res);\n}\n\nval_list val_list::set_val(int index, val el) const\n{\n  auto res = isl_val_list_set_val(copy(), index, el.release());\n  return manage(res);\n}\n\nisl_size val_list::size() const\n{\n  auto res = isl_val_list_size(get());\n  return res;\n}\n\nval_list val_list::swap(unsigned int pos1, unsigned int pos2) const\n{\n  auto res = isl_val_list_swap(copy(), pos1, pos2);\n  return manage(res);\n}\n\n// implementations for isl::vec\nvec manage(__isl_take isl_vec *ptr) {\n  return vec(ptr);\n}\nvec manage_copy(__isl_keep isl_vec *ptr) {\n  ptr = isl_vec_copy(ptr);\n  return vec(ptr);\n}\n\nvec::vec()\n    : ptr(nullptr) {}\n\nvec::vec(const vec &obj)\n    : ptr(nullptr)\n{\n  ptr = obj.copy();\n}\nvec::vec(std::nullptr_t)\n    : ptr(nullptr) {}\n\n\nvec::vec(__isl_take isl_vec *ptr)\n    : ptr(ptr) {}\n\n\nvec &vec::operator=(vec obj) {\n  std::swap(this->ptr, obj.ptr);\n  return *this;\n}\n\nvec::~vec() {\n  if (ptr)\n    isl_vec_free(ptr);\n}\n\n__isl_give isl_vec *vec::copy() const & {\n  return isl_vec_copy(ptr);\n}\n\n__isl_keep isl_vec *vec::get() const {\n  return ptr;\n}\n\n__isl_give isl_vec *vec::release() {\n  isl_vec *tmp = ptr;\n  ptr = nullptr;\n  return tmp;\n}\n\nbool vec::is_null() const {\n  return ptr == nullptr;\n}\nvec::operator bool() const {\n  return !is_null();\n}\n\n\nctx vec::get_ctx() const {\n  return ctx(isl_vec_get_ctx(ptr));\n}\n\nvoid vec::dump() const {\n  isl_vec_dump(get());\n}\n\n\nvec vec::add(vec vec2) const\n{\n  auto res = isl_vec_add(copy(), vec2.release());\n  return manage(res);\n}\n\nvec vec::add_els(unsigned int n) const\n{\n  auto res = isl_vec_add_els(copy(), n);\n  return manage(res);\n}\n\nvec vec::alloc(ctx ctx, unsigned int size)\n{\n  auto res = isl_vec_alloc(ctx.release(), size);\n  return manage(res);\n}\n\nvec vec::ceil() const\n{\n  auto res = isl_vec_ceil(copy());\n  return manage(res);\n}\n\nvec vec::clr() const\n{\n  auto res = isl_vec_clr(copy());\n  return manage(res);\n}\n\nint vec::cmp_element(const vec &vec2, int pos) const\n{\n  auto res = isl_vec_cmp_element(get(), vec2.get(), pos);\n  return res;\n}\n\nvec vec::concat(vec vec2) const\n{\n  auto res = isl_vec_concat(copy(), vec2.release());\n  return manage(res);\n}\n\nvec vec::drop_els(unsigned int pos, unsigned int n) const\n{\n  auto res = isl_vec_drop_els(copy(), pos, n);\n  return manage(res);\n}\n\nvec vec::extend(unsigned int size) const\n{\n  auto res = isl_vec_extend(copy(), size);\n  return manage(res);\n}\n\nval vec::get_element_val(int pos) const\n{\n  auto res = isl_vec_get_element_val(get(), pos);\n  return manage(res);\n}\n\nvec vec::insert_els(unsigned int pos, unsigned int n) const\n{\n  auto res = isl_vec_insert_els(copy(), pos, n);\n  return manage(res);\n}\n\nvec vec::insert_zero_els(unsigned int pos, unsigned int n) const\n{\n  auto res = isl_vec_insert_zero_els(copy(), pos, n);\n  return manage(res);\n}\n\nboolean vec::is_equal(const vec &vec2) const\n{\n  auto res = isl_vec_is_equal(get(), vec2.get());\n  return manage(res);\n}\n\nvec vec::mat_product(mat mat) const\n{\n  auto res = isl_vec_mat_product(copy(), mat.release());\n  return manage(res);\n}\n\nvec vec::move_els(unsigned int dst_col, unsigned int src_col, unsigned int n) const\n{\n  auto res = isl_vec_move_els(copy(), dst_col, src_col, n);\n  return manage(res);\n}\n\nvec vec::neg() const\n{\n  auto res = isl_vec_neg(copy());\n  return manage(res);\n}\n\nvec vec::set_element_si(int pos, int v) const\n{\n  auto res = isl_vec_set_element_si(copy(), pos, v);\n  return manage(res);\n}\n\nvec vec::set_element_val(int pos, val v) const\n{\n  auto res = isl_vec_set_element_val(copy(), pos, v.release());\n  return manage(res);\n}\n\nvec vec::set_si(int v) const\n{\n  auto res = isl_vec_set_si(copy(), v);\n  return manage(res);\n}\n\nvec vec::set_val(val v) const\n{\n  auto res = isl_vec_set_val(copy(), v.release());\n  return manage(res);\n}\n\nisl_size vec::size() const\n{\n  auto res = isl_vec_size(get());\n  return res;\n}\n\nvec vec::sort() const\n{\n  auto res = isl_vec_sort(copy());\n  return manage(res);\n}\n\nvec vec::zero(ctx ctx, unsigned int size)\n{\n  auto res = isl_vec_zero(ctx.release(), size);\n  return manage(res);\n}\n\nvec vec::zero_extend(unsigned int size) const\n{\n  auto res = isl_vec_zero_extend(copy(), size);\n  return manage(res);\n}\n} // namespace noexceptions \n} // namespace isl\n\n#endif /* ISL_CPP_CHECKED */\n"}}, "reports": [{"events": [{"location": {"col": 9, "file": 17, "line": 238}, "message": "destructor '~iterator' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Analysis/AliasSetTracker.h", "reportHash": "17a251d58b9080a7e2c7e8a738df9571", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 9, "file": 17, "line": 238}, "message": "move constructor 'iterator' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Analysis/AliasSetTracker.h", "reportHash": "432550165155583624aa36ec44cd84b6", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 21, "file": 18, "line": 1157}, "message": "destructor '~' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Analysis/LoopInfo.h", "reportHash": "3b12a589ed88be3f5b6df5f6594aeca1", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 21, "file": 18, "line": 1157}, "message": "move constructor '' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Analysis/LoopInfo.h", "reportHash": "e7e5dcc7a754129190ebe43c28400c78", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 19, "line": 65}, "message": "destructor '~LocationSize' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Analysis/MemoryLocation.h", "reportHash": "896b411c71a26cf6bbbee982cb64f045", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 19, "line": 65}, "message": "move assignment operator 'operator=' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Analysis/MemoryLocation.h", "reportHash": "7203952e80b83922d2559be947115c5c", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 19, "line": 65}, "message": "move constructor 'LocationSize' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Analysis/MemoryLocation.h", "reportHash": "e4d8969f7f54f001b4bceb3e1762ec57", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 19, "line": 209}, "message": "destructor '~MemoryLocation' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Analysis/MemoryLocation.h", "reportHash": "609cd6656b602f2f85937493d1543a44", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 19, "line": 209}, "message": "move constructor 'MemoryLocation' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Analysis/MemoryLocation.h", "reportHash": "d3b3e98aab8df54932f09ca15b2cab20", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 20, "line": 31}, "message": "destructor '~RegionPass' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Analysis/RegionPass.h", "reportHash": "52f7434a0de17daf65012d938bd9c76b", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 10, "file": 21, "line": 1481}, "message": "destructor '~LoopProperties' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h", "reportHash": "7439beee2a2d860b0ec9a5e9a2b07d2f", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 14, "file": 22, "line": 75}, "message": "'llvm/IR/Attributes.inc' file not found"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/IR/Attributes.h", "reportHash": "028601b7c3bb82de45631257f6da885e", "checkerName": "clang-diagnostic-error", "reviewStatus": null, "severity": "CRITICAL"}, {"events": [{"location": {"col": 22, "file": 24, "line": 47}, "message": "destructor '~ConstantRange' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/IR/ConstantRange.h", "reportHash": "dd9dae29ba30f02d96d84cc74e691fcf", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 28, "line": 131}, "message": "destructor '~DiagnosticInfoInlineAsm' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/IR/DiagnosticInfo.h", "reportHash": "ac39ffbd50360030ce86c5033f73a713", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 28, "line": 179}, "message": "destructor '~DiagnosticInfoResourceLimit' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/IR/DiagnosticInfo.h", "reportHash": "c0d4bc904a088e8388ab404d14c30e9b", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 28, "line": 217}, "message": "destructor '~DiagnosticInfoStackSize' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/IR/DiagnosticInfo.h", "reportHash": "a97099bad9fbc7a54b9c61f6d30a3cf8", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 28, "line": 236}, "message": "destructor '~DiagnosticInfoDebugMetadataVersion' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/IR/DiagnosticInfo.h", "reportHash": "c76aae9e489327170995f57bfe9bd91a", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 28, "line": 263}, "message": "destructor '~DiagnosticInfoIgnoringInvalidDebugMetadata' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/IR/DiagnosticInfo.h", "reportHash": "da516074e547eac60e6c2d117ff5d635", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 28, "line": 285}, "message": "destructor '~DiagnosticInfoSampleProfile' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/IR/DiagnosticInfo.h", "reportHash": "ef047164d01d077bf04a683c5e472355", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 28, "line": 324}, "message": "destructor '~DiagnosticInfoPGOProfile' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/IR/DiagnosticInfo.h", "reportHash": "9723f8d0554a4d155523e00acb46c57f", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 28, "line": 348}, "message": "destructor '~DiagnosticLocation' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/IR/DiagnosticInfo.h", "reportHash": "b11ebe362fd001b4e5b3f005cc8294ca", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 28, "line": 368}, "message": "destructor '~DiagnosticInfoWithLocationBase' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/IR/DiagnosticInfo.h", "reportHash": "d883578a17320bf18468b8bfafcac177", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 28, "line": 408}, "message": "destructor '~DiagnosticInfoOptimizationBase' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/IR/DiagnosticInfo.h", "reportHash": "f7e7ac8862dce56dc9ccbfb6c093e28f", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 10, "file": 28, "line": 421}, "message": "destructor '~Argument' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/IR/DiagnosticInfo.h", "reportHash": "e24362e39b3457d86808b5db766c0084", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 28, "line": 617}, "message": "destructor '~DiagnosticInfoIROptimization' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/IR/DiagnosticInfo.h", "reportHash": "f59cf08dacc22377e1c875ba57794900", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 28, "line": 684}, "message": "destructor '~OptimizationRemark' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/IR/DiagnosticInfo.h", "reportHash": "8df5830f5647aefece689b9400a39194", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 28, "line": 729}, "message": "destructor '~OptimizationRemarkMissed' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/IR/DiagnosticInfo.h", "reportHash": "0c7857f19d3f689894883cc9cc981b56", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 28, "line": 770}, "message": "destructor '~OptimizationRemarkAnalysis' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/IR/DiagnosticInfo.h", "reportHash": "f44f8aad694ad007059419d45872d047", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 28, "line": 838}, "message": "destructor '~OptimizationRemarkAnalysisFPCommute' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/IR/DiagnosticInfo.h", "reportHash": "9c28c770d99164a50c99b112c5e3d001", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 28, "line": 880}, "message": "destructor '~OptimizationRemarkAnalysisAliasing' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/IR/DiagnosticInfo.h", "reportHash": "92a5465678c32de9e8fc5400fe5e0eb1", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 28, "line": 921}, "message": "destructor '~DiagnosticInfoMIRParser' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/IR/DiagnosticInfo.h", "reportHash": "55f9343ab918617c2bfba9d508b0a3da", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 28, "line": 939}, "message": "destructor '~DiagnosticInfoISelFallback' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/IR/DiagnosticInfo.h", "reportHash": "e12e7b7fda00269f1f618f6122b0ad66", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 28, "line": 961}, "message": "destructor '~DiagnosticInfoOptimizationFailure' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/IR/DiagnosticInfo.h", "reportHash": "c993ea1eb6c74148a20a7b25b9ad8e39", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 28, "line": 993}, "message": "destructor '~DiagnosticInfoUnsupported' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/IR/DiagnosticInfo.h", "reportHash": "3d9d558648476c8fd0830e4e0e9ea9f0", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 28, "line": 1039}, "message": "destructor '~DiagnosticInfoSrcMgr' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/IR/DiagnosticInfo.h", "reportHash": "4b2f543bf7437b888b3f88dbcb2d7b60", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 31, "line": 1059}, "message": "move constructor 'OperandBundleUse' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/IR/InstrTypes.h", "reportHash": "8a911cf14e7ccbf57e4e049908a64af4", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 35, "file": 32, "line": 245}, "message": "destructor '~' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/IR/IntrinsicInst.h", "reportHash": "df02a5ab6a67ff10930f45ce725860fa", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 34, "line": 110}, "message": "destructor '~PassManagerPrettyStackEntry' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/IR/LegacyPassManagers.h", "reportHash": "353702c15ed8c3784da08c9a7b251c8a", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 25, "file": 34, "line": 259}, "message": "destructor '~' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/IR/LegacyPassManagers.h", "reportHash": "1792b553a0de6c228a1195aa6e155251", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 25, "file": 34, "line": 259}, "message": "move constructor '' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/IR/LegacyPassManagers.h", "reportHash": "2249320d757003e9ad5ad10defe2abad", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 34, "line": 460}, "message": "destructor '~FPPassManager' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/IR/LegacyPassManagers.h", "reportHash": "53d4eb4a2c7e340656abc2fa1924108c", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 35, "line": 647}, "message": "move assignment operator 'operator=' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/IR/Metadata.h", "reportHash": "8198e8c1576bb4a1b58fbf9ee258dfc3", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 37, "line": 160}, "message": "destructor '~FastMathFlags' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/IR/Operator.h", "reportHash": "71c3604ea519094b19c3197add01a16f", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 37, "line": 160}, "message": "move constructor 'FastMathFlags' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/IR/Operator.h", "reportHash": "068a0d1894fc98ee530888064b2e6bcf", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 42, "line": 47}, "message": "destructor '~AnalysisUsage' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/PassAnalysisSupport.h", "reportHash": "fdc0e4056f3cd189ad806414103836e1", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 44, "line": 462}, "message": "destructor '~cat' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/CommandLine.h", "reportHash": "bb6cb8522f602d2e13ec1df2352206ac", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 48, "line": 26}, "message": "destructor '~InstructionCost' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/InstructionCost.h", "reportHash": "7e1f069826c7751053e1e3ac0c91dcfa", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 48, "line": 26}, "message": "move assignment operator 'operator=' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/InstructionCost.h", "reportHash": "138e8b7466c668ce90239ad2498007bb", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 48, "line": 26}, "message": "move constructor 'InstructionCost' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/InstructionCost.h", "reportHash": "83afcc4686f78e1fa30e4700fa2ec594", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 60, "line": 221}, "message": "destructor '~DependenceInfo' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/include/polly/DependenceInfo.h", "reportHash": "c90494bf881c69926df550a444ddb207", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 60, "line": 262}, "message": "destructor '~DependenceInfoWrapperPass' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/include/polly/DependenceInfo.h", "reportHash": "8b128e0e87cc4861d15e119c9ccfb9f6", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 61, "line": 194}, "message": "destructor '~ReportCFG' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/include/polly/ScopDetectionDiagnostic.h", "reportHash": "67f8a2d3a04e9f6ba47ef7f0ceed610b", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 61, "line": 206}, "message": "destructor '~ReportInvalidTerminator' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/include/polly/ScopDetectionDiagnostic.h", "reportHash": "a1b606d2ca7d8f94676d0eafdc26b9b6", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 61, "line": 229}, "message": "destructor '~ReportIrreducibleRegion' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/include/polly/ScopDetectionDiagnostic.h", "reportHash": "331a20a24a98f811a50b8e17206aaf17", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 61, "line": 254}, "message": "destructor '~ReportUnreachableInExit' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/include/polly/ScopDetectionDiagnostic.h", "reportHash": "fdb2160f15885726e440b28b145e7dbb", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 61, "line": 283}, "message": "destructor '~ReportAffFunc' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/include/polly/ScopDetectionDiagnostic.h", "reportHash": "42f7c3ed33ff80028780d6f184d96fb2", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 61, "line": 304}, "message": "destructor '~ReportUndefCond' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/include/polly/ScopDetectionDiagnostic.h", "reportHash": "2127ebcbcc10b80b88465bc0e6693ca4", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 61, "line": 329}, "message": "destructor '~ReportInvalidCond' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/include/polly/ScopDetectionDiagnostic.h", "reportHash": "793c1ae3648be018eef8014da4912e45", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 61, "line": 352}, "message": "destructor '~ReportUndefOperand' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/include/polly/ScopDetectionDiagnostic.h", "reportHash": "2cb083635bccb7df47a6ab006faa18ec", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 61, "line": 375}, "message": "destructor '~ReportNonAffBranch' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/include/polly/ScopDetectionDiagnostic.h", "reportHash": "2f20b27282cad51be60eb0771b961e72", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 61, "line": 409}, "message": "destructor '~ReportNoBasePtr' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/include/polly/ScopDetectionDiagnostic.h", "reportHash": "e0f9613655c2114b9e95ca694ca41b87", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 61, "line": 429}, "message": "destructor '~ReportUndefBasePtr' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/include/polly/ScopDetectionDiagnostic.h", "reportHash": "19b8ddc865ea65dd64122a55c5d9b899", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 61, "line": 449}, "message": "destructor '~ReportVariantBasePtr' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/include/polly/ScopDetectionDiagnostic.h", "reportHash": "775d9583296c78b61c2038fc5fe2e449", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 61, "line": 474}, "message": "destructor '~ReportNonAffineAccess' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/include/polly/ScopDetectionDiagnostic.h", "reportHash": "62a38c2b1fb33bcf0ff67c16b66810f5", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 61, "line": 505}, "message": "destructor '~ReportDifferentArrayElementSize' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/include/polly/ScopDetectionDiagnostic.h", "reportHash": "b86f8985e29d709162c02c4bc1917aa5", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 61, "line": 562}, "message": "destructor '~ReportLoopHasNoExit' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/include/polly/ScopDetectionDiagnostic.h", "reportHash": "86e20961c03fef95c7f28761373cf0db", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 61, "line": 590}, "message": "destructor '~ReportLoopHasMultipleExits' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/include/polly/ScopDetectionDiagnostic.h", "reportHash": "f9194797914054c9ffdc1d5031bd507e", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 61, "line": 618}, "message": "destructor '~ReportLoopOnlySomeLatches' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/include/polly/ScopDetectionDiagnostic.h", "reportHash": "75592bc829e0c999164dc9a80c3aa0d9", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 62, "line": 161}, "message": "destructor '~ScopPass' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/include/polly/ScopPass.h", "reportHash": "d67f9ff7c21beed33a7d4c3f9627d13e", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 63, "line": 136}, "message": "destructor '~MemAccInst' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/include/polly/Support/ScopHelper.h", "reportHash": "40db4910ab30602dc04db4d915ef464d", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 64, "line": 91}, "message": "destructor '~ctx' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/lib/External/isl/include/isl/isl-noexceptions.h", "reportHash": "6d3616fd2c1fcba191ebc121e378e414", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 64, "line": 91}, "message": "move constructor 'ctx' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/lib/External/isl/include/isl/isl-noexceptions.h", "reportHash": "733d2312b8199786202af7b58d8b5031", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 20, "file": 64, "line": 4789}, "message": "destructor '~' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/lib/External/isl/include/isl/isl-noexceptions.h", "reportHash": "fa0000342223d0ea477ae9da7c15ed2f", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 20, "file": 64, "line": 4789}, "message": "move constructor '' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/lib/External/isl/include/isl/isl-noexceptions.h", "reportHash": "69b00616d29f9576e80fd3a8f2834acf", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 20, "file": 64, "line": 5358}, "message": "destructor '~' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/lib/External/isl/include/isl/isl-noexceptions.h", "reportHash": "410c0bbbcaee2fc2630e2d4f7734805f", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 20, "file": 64, "line": 5358}, "message": "move constructor '' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/lib/External/isl/include/isl/isl-noexceptions.h", "reportHash": "aacf5aa123729667c40d77bfcd7750ca", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 20, "file": 64, "line": 5734}, "message": "destructor '~' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/lib/External/isl/include/isl/isl-noexceptions.h", "reportHash": "55ebf45731062eb696d699f5112a1137", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 20, "file": 64, "line": 5734}, "message": "move constructor '' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/lib/External/isl/include/isl/isl-noexceptions.h", "reportHash": "ecf734102777546ed765ac5a0a158298", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 20, "file": 64, "line": 6080}, "message": "destructor '~' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/lib/External/isl/include/isl/isl-noexceptions.h", "reportHash": "88d185922cd86327adcdc7373a6873b6", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 20, "file": 64, "line": 6080}, "message": "move constructor '' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/lib/External/isl/include/isl/isl-noexceptions.h", "reportHash": "95686cb8c55780fcbc979d1c5373f188", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 20, "file": 64, "line": 6621}, "message": "destructor '~' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/lib/External/isl/include/isl/isl-noexceptions.h", "reportHash": "99a92c10f42f1455f0a87024f976db5b", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 20, "file": 64, "line": 6621}, "message": "move constructor '' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/lib/External/isl/include/isl/isl-noexceptions.h", "reportHash": "8df64a7a2d42e6cfc4d9df2e4c793b8b", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 20, "file": 64, "line": 6882}, "message": "destructor '~' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/lib/External/isl/include/isl/isl-noexceptions.h", "reportHash": "da6190b4e2b701af27f117ee9a235c83", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 20, "file": 64, "line": 6882}, "message": "move constructor '' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/lib/External/isl/include/isl/isl-noexceptions.h", "reportHash": "3c38243048f9f08160537bc283b51ec0", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 20, "file": 64, "line": 6896}, "message": "destructor '~' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/lib/External/isl/include/isl/isl-noexceptions.h", "reportHash": "88d185922cd86327adcdc7373a6873b6", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 20, "file": 64, "line": 6896}, "message": "move constructor '' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/lib/External/isl/include/isl/isl-noexceptions.h", "reportHash": "95686cb8c55780fcbc979d1c5373f188", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 20, "file": 64, "line": 7353}, "message": "destructor '~' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/lib/External/isl/include/isl/isl-noexceptions.h", "reportHash": "edf4aaf6fef0390a5124fccef2b58dda", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 20, "file": 64, "line": 7353}, "message": "move constructor '' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/lib/External/isl/include/isl/isl-noexceptions.h", "reportHash": "fbcbc6068aab53953f0d1c7fb2613320", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 20, "file": 64, "line": 7713}, "message": "destructor '~' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/lib/External/isl/include/isl/isl-noexceptions.h", "reportHash": "88d185922cd86327adcdc7373a6873b6", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 20, "file": 64, "line": 7713}, "message": "move constructor '' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/lib/External/isl/include/isl/isl-noexceptions.h", "reportHash": "95686cb8c55780fcbc979d1c5373f188", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 20, "file": 64, "line": 8090}, "message": "destructor '~' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/lib/External/isl/include/isl/isl-noexceptions.h", "reportHash": "fc9dc91adbb90185cf415dfb36b0fbf1", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 20, "file": 64, "line": 8090}, "message": "move constructor '' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/lib/External/isl/include/isl/isl-noexceptions.h", "reportHash": "708f26f450402281c9444347ff117f31", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 20, "file": 64, "line": 8236}, "message": "destructor '~' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/lib/External/isl/include/isl/isl-noexceptions.h", "reportHash": "03f0a1441240c2815094b3d7f885c254", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 20, "file": 64, "line": 8236}, "message": "move constructor '' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/lib/External/isl/include/isl/isl-noexceptions.h", "reportHash": "c23b8e5d19f9c305c0ba7153dfd98a6d", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 20, "file": 64, "line": 8863}, "message": "destructor '~' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/lib/External/isl/include/isl/isl-noexceptions.h", "reportHash": "99a92c10f42f1455f0a87024f976db5b", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 20, "file": 64, "line": 8863}, "message": "move constructor '' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/lib/External/isl/include/isl/isl-noexceptions.h", "reportHash": "8df64a7a2d42e6cfc4d9df2e4c793b8b", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 20, "file": 64, "line": 9794}, "message": "destructor '~' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/lib/External/isl/include/isl/isl-noexceptions.h", "reportHash": "731583c4d56998462af7c84064afcf60", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 20, "file": 64, "line": 9794}, "message": "move constructor '' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/lib/External/isl/include/isl/isl-noexceptions.h", "reportHash": "56f4a88eddf4854d5248bad0a4d7f5c9", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 20, "file": 64, "line": 12762}, "message": "destructor '~' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/lib/External/isl/include/isl/isl-noexceptions.h", "reportHash": "67b8973402652110a4eb779a938b33a5", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 20, "file": 64, "line": 12762}, "message": "move constructor '' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/lib/External/isl/include/isl/isl-noexceptions.h", "reportHash": "a5c543636aa0f3717ad5317ae9829986", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 20, "file": 64, "line": 13296}, "message": "destructor '~' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/lib/External/isl/include/isl/isl-noexceptions.h", "reportHash": "bb56075c4d8d498453f79f80c5efd06d", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 20, "file": 64, "line": 13296}, "message": "move constructor '' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/lib/External/isl/include/isl/isl-noexceptions.h", "reportHash": "473e6b43341fb9c15f78e366fdd8d953", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 20, "file": 64, "line": 13604}, "message": "destructor '~' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/lib/External/isl/include/isl/isl-noexceptions.h", "reportHash": "30a3833984f5fb49b235a7cc808c7773", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 20, "file": 64, "line": 13604}, "message": "move constructor '' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/lib/External/isl/include/isl/isl-noexceptions.h", "reportHash": "6047e61a0603ef3f7110b0fb678733e9", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 20, "file": 64, "line": 14073}, "message": "destructor '~' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/lib/External/isl/include/isl/isl-noexceptions.h", "reportHash": "1e03fa60688aaf3cbc05cbef5e4aedcd", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 20, "file": 64, "line": 14073}, "message": "move constructor '' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/lib/External/isl/include/isl/isl-noexceptions.h", "reportHash": "f22d95a30a9561776e99bc0c54cb61f4", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 20, "file": 64, "line": 14293}, "message": "destructor '~' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/lib/External/isl/include/isl/isl-noexceptions.h", "reportHash": "a3787ab558773a29e739f7f20b898820", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 20, "file": 64, "line": 14293}, "message": "move constructor '' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/lib/External/isl/include/isl/isl-noexceptions.h", "reportHash": "add5a895723f8bd806d2e85cab8351fb", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 20, "file": 64, "line": 14710}, "message": "destructor '~' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/lib/External/isl/include/isl/isl-noexceptions.h", "reportHash": "0d9fbadf816064a4c804e503584257d0", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 20, "file": 64, "line": 14710}, "message": "move constructor '' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/lib/External/isl/include/isl/isl-noexceptions.h", "reportHash": "b96d57ff6300781e68a6f8129cea89ea", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 20, "file": 64, "line": 14862}, "message": "destructor '~' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/lib/External/isl/include/isl/isl-noexceptions.h", "reportHash": "abd4d71273ba25c2b51661ac48edb8e8", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 20, "file": 64, "line": 14862}, "message": "move constructor '' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/lib/External/isl/include/isl/isl-noexceptions.h", "reportHash": "fc8c214b31e9a26a1f68415abd5f54dd", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 20, "file": 64, "line": 14894}, "message": "destructor '~' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/lib/External/isl/include/isl/isl-noexceptions.h", "reportHash": "05b222b993fdf046bc923e3317c9a080", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 20, "file": 64, "line": 14894}, "message": "move constructor '' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/lib/External/isl/include/isl/isl-noexceptions.h", "reportHash": "49adca02d629e46e8ac645ba451331d9", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 20, "file": 64, "line": 15205}, "message": "destructor '~' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/lib/External/isl/include/isl/isl-noexceptions.h", "reportHash": "fd5e8b93cd3542e29cc79393632917ce", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 20, "file": 64, "line": 15205}, "message": "move constructor '' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/lib/External/isl/include/isl/isl-noexceptions.h", "reportHash": "301709491cb1addcddf6e4c878cd1f22", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 20, "file": 64, "line": 15772}, "message": "destructor '~' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/lib/External/isl/include/isl/isl-noexceptions.h", "reportHash": "8a75127971c524dd74e4efa098b0f9f4", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 20, "file": 64, "line": 15772}, "message": "move constructor '' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/lib/External/isl/include/isl/isl-noexceptions.h", "reportHash": "de9b0f281ae4a564223ea8ee99dfe0b7", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 20, "file": 64, "line": 16379}, "message": "destructor '~' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/lib/External/isl/include/isl/isl-noexceptions.h", "reportHash": "edf4aaf6fef0390a5124fccef2b58dda", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 20, "file": 64, "line": 16379}, "message": "move constructor '' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/lib/External/isl/include/isl/isl-noexceptions.h", "reportHash": "fbcbc6068aab53953f0d1c7fb2613320", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 20, "file": 64, "line": 16393}, "message": "destructor '~' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/lib/External/isl/include/isl/isl-noexceptions.h", "reportHash": "bc69251c8f18771e3816b62979dddde5", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 20, "file": 64, "line": 16393}, "message": "move constructor '' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/lib/External/isl/include/isl/isl-noexceptions.h", "reportHash": "3ba76aab6e5c1865c4d3ec889b64059d", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 20, "file": 64, "line": 17192}, "message": "destructor '~' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/lib/External/isl/include/isl/isl-noexceptions.h", "reportHash": "2f1b9c75adbcad5b8e9136393ec96136", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 20, "file": 64, "line": 17192}, "message": "move constructor '' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/lib/External/isl/include/isl/isl-noexceptions.h", "reportHash": "cd1974891d750d8fb4ffc626cc610ce1", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 20, "file": 64, "line": 18377}, "message": "destructor '~' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/lib/External/isl/include/isl/isl-noexceptions.h", "reportHash": "731583c4d56998462af7c84064afcf60", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 20, "file": 64, "line": 18377}, "message": "move constructor '' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/lib/External/isl/include/isl/isl-noexceptions.h", "reportHash": "56f4a88eddf4854d5248bad0a4d7f5c9", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 20, "file": 64, "line": 18976}, "message": "destructor '~' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/lib/External/isl/include/isl/isl-noexceptions.h", "reportHash": "f05308697771c3ed9158d7b768e44426", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 20, "file": 64, "line": 18976}, "message": "move constructor '' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/lib/External/isl/include/isl/isl-noexceptions.h", "reportHash": "330ac9786e597f927ca7eb0f6b92002c", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 20, "file": 64, "line": 19229}, "message": "destructor '~' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/lib/External/isl/include/isl/isl-noexceptions.h", "reportHash": "bb56075c4d8d498453f79f80c5efd06d", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 20, "file": 64, "line": 19229}, "message": "move constructor '' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/lib/External/isl/include/isl/isl-noexceptions.h", "reportHash": "473e6b43341fb9c15f78e366fdd8d953", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 20, "file": 64, "line": 19510}, "message": "destructor '~' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/lib/External/isl/include/isl/isl-noexceptions.h", "reportHash": "804b5dc1ba9ece2e7a3e82dd333eb2f4", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 20, "file": 64, "line": 19510}, "message": "move constructor '' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/lib/External/isl/include/isl/isl-noexceptions.h", "reportHash": "fe8b7f0f646f96288a6bf384195738a9", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 20, "file": 64, "line": 19783}, "message": "destructor '~' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/lib/External/isl/include/isl/isl-noexceptions.h", "reportHash": "1e03fa60688aaf3cbc05cbef5e4aedcd", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 20, "file": 64, "line": 19783}, "message": "move constructor '' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/lib/External/isl/include/isl/isl-noexceptions.h", "reportHash": "f22d95a30a9561776e99bc0c54cb61f4", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 20, "file": 64, "line": 20094}, "message": "destructor '~' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/lib/External/isl/include/isl/isl-noexceptions.h", "reportHash": "7f08be48f948ed88c5ebc87a08ab4ece", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 20, "file": 64, "line": 20094}, "message": "move constructor '' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/lib/External/isl/include/isl/isl-noexceptions.h", "reportHash": "c4e0b0558068335d5fe7da355808ba17", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 20, "file": 64, "line": 20298}, "message": "destructor '~' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/lib/External/isl/include/isl/isl-noexceptions.h", "reportHash": "0d9fbadf816064a4c804e503584257d0", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 20, "file": 64, "line": 20298}, "message": "move constructor '' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/lib/External/isl/include/isl/isl-noexceptions.h", "reportHash": "b96d57ff6300781e68a6f8129cea89ea", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 20, "file": 64, "line": 20653}, "message": "destructor '~' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/lib/External/isl/include/isl/isl-noexceptions.h", "reportHash": "bc69251c8f18771e3816b62979dddde5", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 20, "file": 64, "line": 20653}, "message": "move constructor '' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/lib/External/isl/include/isl/isl-noexceptions.h", "reportHash": "3ba76aab6e5c1865c4d3ec889b64059d", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 20, "file": 64, "line": 20667}, "message": "destructor '~' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/lib/External/isl/include/isl/isl-noexceptions.h", "reportHash": "2f1b9c75adbcad5b8e9136393ec96136", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 20, "file": 64, "line": 20667}, "message": "move constructor '' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/lib/External/isl/include/isl/isl-noexceptions.h", "reportHash": "cd1974891d750d8fb4ffc626cc610ce1", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 20, "file": 64, "line": 21056}, "message": "destructor '~' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/lib/External/isl/include/isl/isl-noexceptions.h", "reportHash": "b6bf9198375c701ceea6cf869420cbb1", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 20, "file": 64, "line": 21056}, "message": "move constructor '' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/lib/External/isl/include/isl/isl-noexceptions.h", "reportHash": "b44826361f3962a357735eb50ebe2f76", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 20, "file": 64, "line": 21644}, "message": "destructor '~' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/lib/External/isl/include/isl/isl-noexceptions.h", "reportHash": "9c5327d97341285da06a41811187dcd3", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 20, "file": 64, "line": 21644}, "message": "move constructor '' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/lib/External/isl/include/isl/isl-noexceptions.h", "reportHash": "9061241216c1ee89810387e19c74a690", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}]};
      window.onload = function() {
        if (!browserCompatible) {
          setNonCompatibleBrowserMessage();
        } else {
          BugViewer.init(data.files, data.reports);
          BugViewer.create();
          BugViewer.initByUrl();
        }
      };
    </script>
  </head>
  <body>
  <div class="container">
    <div id="content">
      <div id="side-bar">
        <div class="header">
          <a href="index.html" class="button">&#8249; Return to List</a>
        </div>
        <div id="report-nav">
          <div class="header">Reports</div>
        </div>
      </div>
      <div id="editor-wrapper">
        <div class="header">
          <div id="file">
            <span class="label">File:</span>
            <span id="file-path"></span>
          </div>
          <div id="checker">
            <span class="label">Checker name:</span>
            <span id="checker-name"></span>
          </div>
          <div id="review-status-wrapper">
            <span class="label">Review status:</span>
            <span id="review-status"></span>
          </div>
        </div>
        <div id="editor"></div>
      </div>
    </div>
  </div>
  </body>
</html>
