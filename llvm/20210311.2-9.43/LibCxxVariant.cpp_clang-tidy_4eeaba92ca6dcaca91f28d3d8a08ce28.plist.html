<!DOCTYPE html>
<html>
  <head>
    <title>Plist HTML Viewer</title>

    <meta charset="UTF-8">

    <style type="text/css">
      .CodeMirror{font-family:monospace;height:300px;color:#000;direction:ltr}.CodeMirror-lines{padding:4px 0}.CodeMirror pre{padding:0 4px}.CodeMirror-gutter-filler,.CodeMirror-scrollbar-filler{background-color:#fff}.CodeMirror-gutters{border-right:1px solid #ddd;background-color:#f7f7f7;white-space:nowrap}.CodeMirror-linenumber{padding:0 3px 0 5px;min-width:20px;text-align:right;color:#999;white-space:nowrap}.CodeMirror-guttermarker{color:#000}.CodeMirror-guttermarker-subtle{color:#999}.CodeMirror-cursor{border-left:1px solid #000;border-right:none;width:0}.CodeMirror div.CodeMirror-secondarycursor{border-left:1px solid silver}.cm-fat-cursor .CodeMirror-cursor{width:auto;border:0!important;background:#7e7}.cm-fat-cursor div.CodeMirror-cursors{z-index:1}.cm-animate-fat-cursor{width:auto;border:0;-webkit-animation:blink 1.06s steps(1) infinite;-moz-animation:blink 1.06s steps(1) infinite;animation:blink 1.06s steps(1) infinite;background-color:#7e7}@-moz-keyframes blink{50%{background-color:transparent}}@-webkit-keyframes blink{50%{background-color:transparent}}@keyframes blink{50%{background-color:transparent}}.cm-tab{display:inline-block;text-decoration:inherit}.CodeMirror-rulers{position:absolute;left:0;right:0;top:-50px;bottom:-20px;overflow:hidden}.CodeMirror-ruler{border-left:1px solid #ccc;top:0;bottom:0;position:absolute}.cm-s-default .cm-header{color:#00f}.cm-s-default .cm-quote{color:#090}.cm-negative{color:#d44}.cm-positive{color:#292}.cm-header,.cm-strong{font-weight:700}.cm-em{font-style:italic}.cm-link{text-decoration:underline}.cm-strikethrough{text-decoration:line-through}.cm-s-default .cm-keyword{color:#708}.cm-s-default .cm-atom{color:#219}.cm-s-default .cm-number{color:#164}.cm-s-default .cm-def{color:#00f}.cm-s-default .cm-variable-2{color:#05a}.cm-s-default .cm-type,.cm-s-default .cm-variable-3{color:#085}.cm-s-default .cm-comment{color:#a50}.cm-s-default .cm-string{color:#a11}.cm-s-default .cm-string-2{color:#f50}.cm-s-default .cm-meta{color:#555}.cm-s-default .cm-qualifier{color:#555}.cm-s-default .cm-builtin{color:#30a}.cm-s-default .cm-bracket{color:#997}.cm-s-default .cm-tag{color:#170}.cm-s-default .cm-attribute{color:#00c}.cm-s-default .cm-hr{color:#999}.cm-s-default .cm-link{color:#00c}.cm-s-default .cm-error{color:red}.cm-invalidchar{color:red}.CodeMirror-composing{border-bottom:2px solid}div.CodeMirror span.CodeMirror-matchingbracket{color:#0f0}div.CodeMirror span.CodeMirror-nonmatchingbracket{color:#f22}.CodeMirror-matchingtag{background:rgba(255,150,0,.3)}.CodeMirror-activeline-background{background:#e8f2ff}.CodeMirror{position:relative;overflow:hidden;background:#fff}.CodeMirror-scroll{overflow:scroll!important;margin-bottom:-30px;margin-right:-30px;padding-bottom:30px;height:100%;outline:0;position:relative}.CodeMirror-sizer{position:relative;border-right:30px solid transparent}.CodeMirror-gutter-filler,.CodeMirror-hscrollbar,.CodeMirror-scrollbar-filler,.CodeMirror-vscrollbar{position:absolute;z-index:6;display:none}.CodeMirror-vscrollbar{right:0;top:0;overflow-x:hidden;overflow-y:scroll}.CodeMirror-hscrollbar{bottom:0;left:0;overflow-y:hidden;overflow-x:scroll}.CodeMirror-scrollbar-filler{right:0;bottom:0}.CodeMirror-gutter-filler{left:0;bottom:0}.CodeMirror-gutters{position:absolute;left:0;top:0;min-height:100%;z-index:3}.CodeMirror-gutter{white-space:normal;height:100%;display:inline-block;vertical-align:top;margin-bottom:-30px}.CodeMirror-gutter-wrapper{position:absolute;z-index:4;background:0 0!important;border:none!important}.CodeMirror-gutter-background{position:absolute;top:0;bottom:0;z-index:4}.CodeMirror-gutter-elt{position:absolute;cursor:default;z-index:4}.CodeMirror-gutter-wrapper ::selection{background-color:transparent}.CodeMirror-gutter-wrapper ::-moz-selection{background-color:transparent}.CodeMirror-lines{cursor:text;min-height:1px}.CodeMirror pre{-moz-border-radius:0;-webkit-border-radius:0;border-radius:0;border-width:0;background:0 0;font-family:inherit;font-size:inherit;margin:0;white-space:pre;word-wrap:normal;line-height:inherit;color:inherit;z-index:2;position:relative;overflow:visible;-webkit-tap-highlight-color:transparent;-webkit-font-variant-ligatures:contextual;font-variant-ligatures:contextual}.CodeMirror-wrap pre{word-wrap:break-word;white-space:pre-wrap;word-break:normal}.CodeMirror-linebackground{position:absolute;left:0;right:0;top:0;bottom:0;z-index:0}.CodeMirror-linewidget{position:relative;z-index:2;overflow:auto}.CodeMirror-rtl pre{direction:rtl}.CodeMirror-code{outline:0}.CodeMirror-gutter,.CodeMirror-gutters,.CodeMirror-linenumber,.CodeMirror-scroll,.CodeMirror-sizer{-moz-box-sizing:content-box;box-sizing:content-box}.CodeMirror-measure{position:absolute;width:100%;height:0;overflow:hidden;visibility:hidden}.CodeMirror-cursor{position:absolute;pointer-events:none}.CodeMirror-measure pre{position:static}div.CodeMirror-cursors{visibility:hidden;position:relative;z-index:3}div.CodeMirror-dragcursors{visibility:visible}.CodeMirror-focused div.CodeMirror-cursors{visibility:visible}.CodeMirror-selected{background:#d9d9d9}.CodeMirror-focused .CodeMirror-selected{background:#d7d4f0}.CodeMirror-crosshair{cursor:crosshair}.CodeMirror-line::selection,.CodeMirror-line>span::selection,.CodeMirror-line>span>span::selection{background:#d7d4f0}.CodeMirror-line::-moz-selection,.CodeMirror-line>span::-moz-selection,.CodeMirror-line>span>span::-moz-selection{background:#d7d4f0}.cm-searching{background-color:#ffa;background-color:rgba(255,255,0,.4)}.cm-force-border{padding-right:.1px}@media print{.CodeMirror div.CodeMirror-cursors{visibility:hidden}}.cm-tab-wrap-hack:after{content:''}span.CodeMirror-selectedtext{background:0 0}
/*# sourceMappingURL=codemirror.min.css.map */

      .severity-low {
  background-color: #669603;
}

.severity-low:after {
  content : 'L';
}

.severity-unspecified {
  background-color: #666666;
}

.severity-unspecified:after {
  content : 'U';
}

.severity-style {
  background-color: #9932cc;
}

.severity-style:after {
  content : 'S';
}

.severity-medium {
  background-color: #a9d323;
  color: black;
}

.severity-medium:after {
  content : 'M';
}

.severity-high {
  background-color: #ffa800;
}

.severity-high:after {
  content : 'H';
}

.severity-critical {
  background-color: #e92625;
}

.severity-critical:after {
  content : 'C';
}

i[class*="severity-"] {
  line-height: normal;
  text-transform: capitalize;
  font-size: 0.8em;
  font-weight: bold;
  color: white;
  display: inline-block;
  width: 16px;
  height: 16px;
  text-align: center;
  font-family: sans-serif;
}

      html, body {
  width: 100%;
  height: 100%;
  padding: 0px;
  margin: 0px;
}

div.container {
  padding: 10px;
}

#content {
  height: 100%;
  display: block;
  overflow: hidden;
}

#content > div {
  margin: 10px;
  overflow: hidden;
  border: 1px solid #ddd;
  border-radius: 3px;
  overflow: hidden;
  height: 97%;
}

.button {
  background-color: #f1f1f1;
  text-decoration: none;
  display: inline-block;
  padding: 8px 16px;
  color: black;
  cursor: pointer;
}

.button:hover {
  background-color: #ddd;
  color: black;
}

.review-status {
  color: white;
  text-align: center;
}

.review-status-confirmed {
  background-color: #e92625;
}

.review-status-false-positive {
  background-color: grey;
}

.review-status-intentional {
  background-color: #669603;
}

      div.container {
  width: 100%;
  height: 100%;
  padding: 0px;
}

#editor-wrapper {
  margin: 10px;
}

#side-bar {
  float: left;
  width: 260px;
  margin: 0px;
}

#report-nav ul {
  list-style-type: none;
  padding: 0;
  margin: 0;
  overflow-y: auto;
  height: 100%;
}

#report-nav ul > li {
  padding: .4em;
  background-color: #fff;
  border-bottom: 1px solid rgba(0,0,0,.125);
  text-align: left;
  overflow: hidden;
  white-space: nowrap;
  text-overflow: ellipsis;
}

#report-nav ul > li.active {
  background-color: #427ea9;
  color: white;
}

#report-nav ul > li:hover {
  background-color: #427ea9;
  color: white;
  cursor: pointer;
}

#report-nav ul a {
  text-decoration: none;
}

#report-nav i[class*="severity-"] {
  margin-right: 5px;
}

.header {
  border-bottom: 1px solid lightgrey;
  font-family: monospace;
  padding: 10px;
  background-color: #fafbfc;
  border-bottom: 1px solid #e1e4e8;
  border-top-left-radius: 2px;
  border-top-right-radius: 2px;
}

#report-nav .header {
  font-weight: bold;
}

#editor-wrapper .header > div {
  padding-top: 2px;
}

#file-path,
#checker-name {
  color: #195ea2;
}

#review-status {
  padding: 0px 5px;
}

#file-path {
  font-family: monospace;
}

.check-msg {
  display: inline-block;
  padding: 3px 6px;
  margin: 1px;
  -webkit-border-radius: 5px;
  -moz-border-radius: 5px;
  border-radius: 5px;
}

.check-msg.info {
  color: #00546f;
  background-color: #bfdfe9;
  border: 1px solid #87a8b3;
}

.check-msg.error {
  background-color: #f2dede;
  color: #a94442;
  border: 1px solid #ebcccc;
}

.check-msg.macro {
  background-color: #d7dac2;
  color: #4f5c6d;
  border: 1px solid #d7dac2;
}

.check-msg.note {
  background-color: #d7d7d7;
  color: #4f5c6d;
  border: 1px solid #bfbfbf;
}

.check-msg.current {
  border: 2px dashed #3692ff;
}

.check-msg .tag {
  padding: 1px 5px;
  text-align: center;
  border-radius: 2px;
  margin-right: 5px;
  text-decoration: inherit;
}

.check-msg .tag.macro {
  background-color: #83876a;
  color: white;
  text-transform: capitalize;
}

.check-msg .tag.note {
  background-color: #9299a1;
  color: white;
  text-transform: capitalize;
}

.checker-enum {
  color: white;
  padding: 1px 5px;
  text-align: center;
  border-radius: 25px;
  margin-right: 5px;
  text-decoration: inherit;
}

.checker-enum.info {
  background-color: #427ea9;
}

.checker-enum.error {
  background-color: #a94442;
}

.arrow {
  border: solid black;
  border-width: 0 3px 3px 0;
  display: inline-block;
  padding: 3px;
  cursor: pointer;
  margin: 0px 5px;
}

.arrow:hover {
  border: solid #437ea8;
  border-width: 0 3px 3px 0;
}

.left-arrow {
  transform: rotate(135deg);
  -webkit-transform: rotate(135deg);
}

.right-arrow {
  transform: rotate(-45deg);
  -webkit-transform: rotate(-45deg);
}

    </style>

    <script type="text/javascript">
      function setNonCompatibleBrowserMessage() {
  document.body.innerHTML =
    '<h2 style="margin-left: 20px;">Your browser is not compatible with CodeChecker Viewer!</h2> \
     <p style="margin-left: 20px;">The version required for the following browsers are:</p> \
     <ul style="margin-left: 20px;"> \
     <li>Internet Explorer: version 9 or newer</li> \
     <li>Firefox: version 22.0 or newer</li> \
     </ul>';
}

// http://stackoverflow.com/questions/5916900/how-can-you-detect-the-version-of-a-browser
var browserVersion = (function(){
  var ua = navigator.userAgent, tem,
    M = ua.match(/(opera|chrome|safari|firefox|msie|trident(?=\/))\/?\s*(\d+)/i) || [];

  if (/trident/i.test(M[1])) {
    tem = /\brv[ :]+(\d+)/g.exec(ua) || [];
    return 'IE ' + (tem[1] || '');
  }

  if (M[1] === 'Chrome') {
    tem = ua.match(/\b(OPR|Edge)\/(\d+)/);
    if (tem != null) return tem.slice(1).join(' ').replace('OPR', 'Opera');
  }

  M = M[2] ? [M[1], M[2]] : [navigator.appName, navigator.appVersion, '-?'];
  if ((tem = ua.match(/version\/(\d+)/i)) != null) M.splice(1, 1, tem[1]);
    return M.join(' ');
})();

var pos = browserVersion.indexOf(' ');
var browser = browserVersion.substr(0, pos);
var version = parseInt(browserVersion.substr(pos + 1));

var browserCompatible
  = browser === 'Firefox'
  ? version >= 22
  : browser === 'IE'
  ? version >= 9
  : true;


      /* MIT License

Copyright (C) 2017 by Marijn Haverbeke <marijnh@gmail.com> and others

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
 */
      !function(e,t){"object"==typeof exports&&"undefined"!=typeof module?module.exports=t():"function"==typeof define&&define.amd?define(t):e.CodeMirror=t()}(this,function(){"use strict";function e(e){return new RegExp("(^|\\s)"+e+"(?:$|\\s)\\s*")}function t(e){for(var t=e.childNodes.length;t>0;--t)e.removeChild(e.firstChild);return e}function r(e,r){return t(e).appendChild(r)}function n(e,t,r,n){var i=document.createElement(e);if(r&&(i.className=r),n&&(i.style.cssText=n),"string"==typeof t)i.appendChild(document.createTextNode(t));else if(t)for(var o=0;o<t.length;++o)i.appendChild(t[o]);return i}function i(e,t,r,i){var o=n(e,t,r,i);return o.setAttribute("role","presentation"),o}function o(e,t){if(3==t.nodeType&&(t=t.parentNode),e.contains)return e.contains(t);do{if(11==t.nodeType&&(t=t.host),t==e)return!0}while(t=t.parentNode)}function l(){var e;try{e=document.activeElement}catch(t){e=document.body||null}for(;e&&e.shadowRoot&&e.shadowRoot.activeElement;)e=e.shadowRoot.activeElement;return e}function s(t,r){var n=t.className;e(r).test(n)||(t.className+=(n?" ":"")+r)}function a(t,r){for(var n=t.split(" "),i=0;i<n.length;i++)n[i]&&!e(n[i]).test(r)&&(r+=" "+n[i]);return r}function u(e){var t=Array.prototype.slice.call(arguments,1);return function(){return e.apply(null,t)}}function c(e,t,r){t||(t={});for(var n in e)!e.hasOwnProperty(n)||!1===r&&t.hasOwnProperty(n)||(t[n]=e[n]);return t}function f(e,t,r,n,i){null==t&&-1==(t=e.search(/[^\s\u00a0]/))&&(t=e.length);for(var o=n||0,l=i||0;;){var s=e.indexOf("\t",o);if(s<0||s>=t)return l+(t-o);l+=s-o,l+=r-l%r,o=s+1}}function h(e,t){for(var r=0;r<e.length;++r)if(e[r]==t)return r;return-1}function d(e,t,r){for(var n=0,i=0;;){var o=e.indexOf("\t",n);-1==o&&(o=e.length);var l=o-n;if(o==e.length||i+l>=t)return n+Math.min(l,t-i);if(i+=o-n,i+=r-i%r,n=o+1,i>=t)return n}}function p(e){for(;Kl.length<=e;)Kl.push(g(Kl)+" ");return Kl[e]}function g(e){return e[e.length-1]}function v(e,t){for(var r=[],n=0;n<e.length;n++)r[n]=t(e[n],n);return r}function m(e,t,r){for(var n=0,i=r(t);n<e.length&&r(e[n])<=i;)n++;e.splice(n,0,t)}function y(){}function b(e,t){var r;return Object.create?r=Object.create(e):(y.prototype=e,r=new y),t&&c(t,r),r}function w(e){return/\w/.test(e)||e>""&&(e.toUpperCase()!=e.toLowerCase()||jl.test(e))}function x(e,t){return t?!!(t.source.indexOf("\\w")>-1&&w(e))||t.test(e):w(e)}function C(e){for(var t in e)if(e.hasOwnProperty(t)&&e[t])return!1;return!0}function S(e){return e.charCodeAt(0)>=768&&Xl.test(e)}function L(e,t,r){for(;(r<0?t>0:t<e.length)&&S(e.charAt(t));)t+=r;return t}function k(e,t,r){for(var n=t>r?-1:1;;){if(t==r)return t;var i=(t+r)/2,o=n<0?Math.ceil(i):Math.floor(i);if(o==t)return e(o)?t:r;e(o)?r=o:t=o+n}}function T(e,t,r){var o=this;this.input=r,o.scrollbarFiller=n("div",null,"CodeMirror-scrollbar-filler"),o.scrollbarFiller.setAttribute("cm-not-content","true"),o.gutterFiller=n("div",null,"CodeMirror-gutter-filler"),o.gutterFiller.setAttribute("cm-not-content","true"),o.lineDiv=i("div",null,"CodeMirror-code"),o.selectionDiv=n("div",null,null,"position: relative; z-index: 1"),o.cursorDiv=n("div",null,"CodeMirror-cursors"),o.measure=n("div",null,"CodeMirror-measure"),o.lineMeasure=n("div",null,"CodeMirror-measure"),o.lineSpace=i("div",[o.measure,o.lineMeasure,o.selectionDiv,o.cursorDiv,o.lineDiv],null,"position: relative; outline: none");var l=i("div",[o.lineSpace],"CodeMirror-lines");o.mover=n("div",[l],null,"position: relative"),o.sizer=n("div",[o.mover],"CodeMirror-sizer"),o.sizerWidth=null,o.heightForcer=n("div",null,null,"position: absolute; height: "+Rl+"px; width: 1px;"),o.gutters=n("div",null,"CodeMirror-gutters"),o.lineGutter=null,o.scroller=n("div",[o.sizer,o.heightForcer,o.gutters],"CodeMirror-scroll"),o.scroller.setAttribute("tabIndex","-1"),o.wrapper=n("div",[o.scrollbarFiller,o.gutterFiller,o.scroller],"CodeMirror"),gl&&vl<8&&(o.gutters.style.zIndex=-1,o.scroller.style.paddingRight=0),ml||fl&&Tl||(o.scroller.draggable=!0),e&&(e.appendChild?e.appendChild(o.wrapper):e(o.wrapper)),o.viewFrom=o.viewTo=t.first,o.reportedViewFrom=o.reportedViewTo=t.first,o.view=[],o.renderedView=null,o.externalMeasured=null,o.viewOffset=0,o.lastWrapHeight=o.lastWrapWidth=0,o.updateLineNumbers=null,o.nativeBarWidth=o.barHeight=o.barWidth=0,o.scrollbarsClipped=!1,o.lineNumWidth=o.lineNumInnerWidth=o.lineNumChars=null,o.alignWidgets=!1,o.cachedCharWidth=o.cachedTextHeight=o.cachedPaddingH=null,o.maxLine=null,o.maxLineLength=0,o.maxLineChanged=!1,o.wheelDX=o.wheelDY=o.wheelStartX=o.wheelStartY=null,o.shift=!1,o.selForContextMenu=null,o.activeTouch=null,r.init(o)}function M(e,t){if((t-=e.first)<0||t>=e.size)throw new Error("There is no line "+(t+e.first)+" in the document.");for(var r=e;!r.lines;)for(var n=0;;++n){var i=r.children[n],o=i.chunkSize();if(t<o){r=i;break}t-=o}return r.lines[t]}function N(e,t,r){var n=[],i=t.line;return e.iter(t.line,r.line+1,function(e){var o=e.text;i==r.line&&(o=o.slice(0,r.ch)),i==t.line&&(o=o.slice(t.ch)),n.push(o),++i}),n}function O(e,t,r){var n=[];return e.iter(t,r,function(e){n.push(e.text)}),n}function A(e,t){var r=t-e.height;if(r)for(var n=e;n;n=n.parent)n.height+=r}function W(e){if(null==e.parent)return null;for(var t=e.parent,r=h(t.lines,e),n=t.parent;n;t=n,n=n.parent)for(var i=0;n.children[i]!=t;++i)r+=n.children[i].chunkSize();return r+t.first}function D(e,t){var r=e.first;e:do{for(var n=0;n<e.children.length;++n){var i=e.children[n],o=i.height;if(t<o){e=i;continue e}t-=o,r+=i.chunkSize()}return r}while(!e.lines);for(var l=0;l<e.lines.length;++l){var s=e.lines[l].height;if(t<s)break;t-=s}return r+l}function H(e,t){return t>=e.first&&t<e.first+e.size}function F(e,t){return String(e.lineNumberFormatter(t+e.firstLineNumber))}function E(e,t,r){if(void 0===r&&(r=null),!(this instanceof E))return new E(e,t,r);this.line=e,this.ch=t,this.sticky=r}function P(e,t){return e.line-t.line||e.ch-t.ch}function I(e,t){return e.sticky==t.sticky&&0==P(e,t)}function z(e){return E(e.line,e.ch)}function R(e,t){return P(e,t)<0?t:e}function B(e,t){return P(e,t)<0?e:t}function G(e,t){return Math.max(e.first,Math.min(t,e.first+e.size-1))}function U(e,t){if(t.line<e.first)return E(e.first,0);var r=e.first+e.size-1;return t.line>r?E(r,M(e,r).text.length):V(t,M(e,t.line).text.length)}function V(e,t){var r=e.ch;return null==r||r>t?E(e.line,t):r<0?E(e.line,0):e}function K(e,t){for(var r=[],n=0;n<t.length;n++)r[n]=U(e,t[n]);return r}function j(){Yl=!0}function X(){_l=!0}function Y(e,t,r){this.marker=e,this.from=t,this.to=r}function _(e,t){if(e)for(var r=0;r<e.length;++r){var n=e[r];if(n.marker==t)return n}}function $(e,t){for(var r,n=0;n<e.length;++n)e[n]!=t&&(r||(r=[])).push(e[n]);return r}function q(e,t){e.markedSpans=e.markedSpans?e.markedSpans.concat([t]):[t],t.marker.attachLine(e)}function Z(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t)||o.from==t&&"bookmark"==l.type&&(!r||!o.marker.insertLeft)){var s=null==o.to||(l.inclusiveRight?o.to>=t:o.to>t);(n||(n=[])).push(new Y(l,o.from,s?null:o.to))}}return n}function Q(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.to||(l.inclusiveRight?o.to>=t:o.to>t)||o.from==t&&"bookmark"==l.type&&(!r||o.marker.insertLeft)){var s=null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t);(n||(n=[])).push(new Y(l,s?null:o.from-t,null==o.to?null:o.to-t))}}return n}function J(e,t){if(t.full)return null;var r=H(e,t.from.line)&&M(e,t.from.line).markedSpans,n=H(e,t.to.line)&&M(e,t.to.line).markedSpans;if(!r&&!n)return null;var i=t.from.ch,o=t.to.ch,l=0==P(t.from,t.to),s=Z(r,i,l),a=Q(n,o,l),u=1==t.text.length,c=g(t.text).length+(u?i:0);if(s)for(var f=0;f<s.length;++f){var h=s[f];if(null==h.to){var d=_(a,h.marker);d?u&&(h.to=null==d.to?null:d.to+c):h.to=i}}if(a)for(var p=0;p<a.length;++p){var v=a[p];null!=v.to&&(v.to+=c),null==v.from?_(s,v.marker)||(v.from=c,u&&(s||(s=[])).push(v)):(v.from+=c,u&&(s||(s=[])).push(v))}s&&(s=ee(s)),a&&a!=s&&(a=ee(a));var m=[s];if(!u){var y,b=t.text.length-2;if(b>0&&s)for(var w=0;w<s.length;++w)null==s[w].to&&(y||(y=[])).push(new Y(s[w].marker,null,null));for(var x=0;x<b;++x)m.push(y);m.push(a)}return m}function ee(e){for(var t=0;t<e.length;++t){var r=e[t];null!=r.from&&r.from==r.to&&!1!==r.marker.clearWhenEmpty&&e.splice(t--,1)}return e.length?e:null}function te(e,t,r){var n=null;if(e.iter(t.line,r.line+1,function(e){if(e.markedSpans)for(var t=0;t<e.markedSpans.length;++t){var r=e.markedSpans[t].marker;!r.readOnly||n&&-1!=h(n,r)||(n||(n=[])).push(r)}}),!n)return null;for(var i=[{from:t,to:r}],o=0;o<n.length;++o)for(var l=n[o],s=l.find(0),a=0;a<i.length;++a){var u=i[a];if(!(P(u.to,s.from)<0||P(u.from,s.to)>0)){var c=[a,1],f=P(u.from,s.from),d=P(u.to,s.to);(f<0||!l.inclusiveLeft&&!f)&&c.push({from:u.from,to:s.from}),(d>0||!l.inclusiveRight&&!d)&&c.push({from:s.to,to:u.to}),i.splice.apply(i,c),a+=c.length-3}}return i}function re(e){var t=e.markedSpans;if(t){for(var r=0;r<t.length;++r)t[r].marker.detachLine(e);e.markedSpans=null}}function ne(e,t){if(t){for(var r=0;r<t.length;++r)t[r].marker.attachLine(e);e.markedSpans=t}}function ie(e){return e.inclusiveLeft?-1:0}function oe(e){return e.inclusiveRight?1:0}function le(e,t){var r=e.lines.length-t.lines.length;if(0!=r)return r;var n=e.find(),i=t.find(),o=P(n.from,i.from)||ie(e)-ie(t);if(o)return-o;var l=P(n.to,i.to)||oe(e)-oe(t);return l||t.id-e.id}function se(e,t){var r,n=_l&&e.markedSpans;if(n)for(var i=void 0,o=0;o<n.length;++o)(i=n[o]).marker.collapsed&&null==(t?i.from:i.to)&&(!r||le(r,i.marker)<0)&&(r=i.marker);return r}function ae(e){return se(e,!0)}function ue(e){return se(e,!1)}function ce(e,t,r,n,i){var o=M(e,t),l=_l&&o.markedSpans;if(l)for(var s=0;s<l.length;++s){var a=l[s];if(a.marker.collapsed){var u=a.marker.find(0),c=P(u.from,r)||ie(a.marker)-ie(i),f=P(u.to,n)||oe(a.marker)-oe(i);if(!(c>=0&&f<=0||c<=0&&f>=0)&&(c<=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.to,r)>=0:P(u.to,r)>0)||c>=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.from,n)<=0:P(u.from,n)<0)))return!0}}}function fe(e){for(var t;t=ae(e);)e=t.find(-1,!0).line;return e}function he(e){for(var t;t=ue(e);)e=t.find(1,!0).line;return e}function de(e){for(var t,r;t=ue(e);)e=t.find(1,!0).line,(r||(r=[])).push(e);return r}function pe(e,t){var r=M(e,t),n=fe(r);return r==n?t:W(n)}function ge(e,t){if(t>e.lastLine())return t;var r,n=M(e,t);if(!ve(e,n))return t;for(;r=ue(n);)n=r.find(1,!0).line;return W(n)+1}function ve(e,t){var r=_l&&t.markedSpans;if(r)for(var n=void 0,i=0;i<r.length;++i)if((n=r[i]).marker.collapsed){if(null==n.from)return!0;if(!n.marker.widgetNode&&0==n.from&&n.marker.inclusiveLeft&&me(e,t,n))return!0}}function me(e,t,r){if(null==r.to){var n=r.marker.find(1,!0);return me(e,n.line,_(n.line.markedSpans,r.marker))}if(r.marker.inclusiveRight&&r.to==t.text.length)return!0;for(var i=void 0,o=0;o<t.markedSpans.length;++o)if((i=t.markedSpans[o]).marker.collapsed&&!i.marker.widgetNode&&i.from==r.to&&(null==i.to||i.to!=r.from)&&(i.marker.inclusiveLeft||r.marker.inclusiveRight)&&me(e,t,i))return!0}function ye(e){for(var t=0,r=(e=fe(e)).parent,n=0;n<r.lines.length;++n){var i=r.lines[n];if(i==e)break;t+=i.height}for(var o=r.parent;o;r=o,o=r.parent)for(var l=0;l<o.children.length;++l){var s=o.children[l];if(s==r)break;t+=s.height}return t}function be(e){if(0==e.height)return 0;for(var t,r=e.text.length,n=e;t=ae(n);){var i=t.find(0,!0);n=i.from.line,r+=i.from.ch-i.to.ch}for(n=e;t=ue(n);){var o=t.find(0,!0);r-=n.text.length-o.from.ch,r+=(n=o.to.line).text.length-o.to.ch}return r}function we(e){var t=e.display,r=e.doc;t.maxLine=M(r,r.first),t.maxLineLength=be(t.maxLine),t.maxLineChanged=!0,r.iter(function(e){var r=be(e);r>t.maxLineLength&&(t.maxLineLength=r,t.maxLine=e)})}function xe(e,t,r,n){if(!e)return n(t,r,"ltr",0);for(var i=!1,o=0;o<e.length;++o){var l=e[o];(l.from<r&&l.to>t||t==r&&l.to==t)&&(n(Math.max(l.from,t),Math.min(l.to,r),1==l.level?"rtl":"ltr",o),i=!0)}i||n(t,r,"ltr")}function Ce(e,t,r){var n;$l=null;for(var i=0;i<e.length;++i){var o=e[i];if(o.from<t&&o.to>t)return i;o.to==t&&(o.from!=o.to&&"before"==r?n=i:$l=i),o.from==t&&(o.from!=o.to&&"before"!=r?n=i:$l=i)}return null!=n?n:$l}function Se(e,t){var r=e.order;return null==r&&(r=e.order=ql(e.text,t)),r}function Le(e,t){return e._handlers&&e._handlers[t]||Zl}function ke(e,t,r){if(e.removeEventListener)e.removeEventListener(t,r,!1);else if(e.detachEvent)e.detachEvent("on"+t,r);else{var n=e._handlers,i=n&&n[t];if(i){var o=h(i,r);o>-1&&(n[t]=i.slice(0,o).concat(i.slice(o+1)))}}}function Te(e,t){var r=Le(e,t);if(r.length)for(var n=Array.prototype.slice.call(arguments,2),i=0;i<r.length;++i)r[i].apply(null,n)}function Me(e,t,r){return"string"==typeof t&&(t={type:t,preventDefault:function(){this.defaultPrevented=!0}}),Te(e,r||t.type,e,t),He(t)||t.codemirrorIgnore}function Ne(e){var t=e._handlers&&e._handlers.cursorActivity;if(t)for(var r=e.curOp.cursorActivityHandlers||(e.curOp.cursorActivityHandlers=[]),n=0;n<t.length;++n)-1==h(r,t[n])&&r.push(t[n])}function Oe(e,t){return Le(e,t).length>0}function Ae(e){e.prototype.on=function(e,t){Ql(this,e,t)},e.prototype.off=function(e,t){ke(this,e,t)}}function We(e){e.preventDefault?e.preventDefault():e.returnValue=!1}function De(e){e.stopPropagation?e.stopPropagation():e.cancelBubble=!0}function He(e){return null!=e.defaultPrevented?e.defaultPrevented:0==e.returnValue}function Fe(e){We(e),De(e)}function Ee(e){return e.target||e.srcElement}function Pe(e){var t=e.which;return null==t&&(1&e.button?t=1:2&e.button?t=3:4&e.button&&(t=2)),Ml&&e.ctrlKey&&1==t&&(t=3),t}function Ie(e){if(null==Il){var t=n("span","​");r(e,n("span",[t,document.createTextNode("x")])),0!=e.firstChild.offsetHeight&&(Il=t.offsetWidth<=1&&t.offsetHeight>2&&!(gl&&vl<8))}var i=Il?n("span","​"):n("span"," ",null,"display: inline-block; width: 1px; margin-right: -1px");return i.setAttribute("cm-text",""),i}function ze(e){if(null!=zl)return zl;var n=r(e,document.createTextNode("AخA")),i=Wl(n,0,1).getBoundingClientRect(),o=Wl(n,1,2).getBoundingClientRect();return t(e),!(!i||i.left==i.right)&&(zl=o.right-i.right<3)}function Re(e){if(null!=ns)return ns;var t=r(e,n("span","x")),i=t.getBoundingClientRect(),o=Wl(t,0,1).getBoundingClientRect();return ns=Math.abs(i.left-o.left)>1}function Be(e,t){arguments.length>2&&(t.dependencies=Array.prototype.slice.call(arguments,2)),is[e]=t}function Ge(e){if("string"==typeof e&&os.hasOwnProperty(e))e=os[e];else if(e&&"string"==typeof e.name&&os.hasOwnProperty(e.name)){var t=os[e.name];"string"==typeof t&&(t={name:t}),(e=b(t,e)).name=t.name}else{if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+xml$/.test(e))return Ge("application/xml");if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+json$/.test(e))return Ge("application/json")}return"string"==typeof e?{name:e}:e||{name:"null"}}function Ue(e,t){t=Ge(t);var r=is[t.name];if(!r)return Ue(e,"text/plain");var n=r(e,t);if(ls.hasOwnProperty(t.name)){var i=ls[t.name];for(var o in i)i.hasOwnProperty(o)&&(n.hasOwnProperty(o)&&(n["_"+o]=n[o]),n[o]=i[o])}if(n.name=t.name,t.helperType&&(n.helperType=t.helperType),t.modeProps)for(var l in t.modeProps)n[l]=t.modeProps[l];return n}function Ve(e,t){c(t,ls.hasOwnProperty(e)?ls[e]:ls[e]={})}function Ke(e,t){if(!0===t)return t;if(e.copyState)return e.copyState(t);var r={};for(var n in t){var i=t[n];i instanceof Array&&(i=i.concat([])),r[n]=i}return r}function je(e,t){for(var r;e.innerMode&&(r=e.innerMode(t))&&r.mode!=e;)t=r.state,e=r.mode;return r||{mode:e,state:t}}function Xe(e,t,r){return!e.startState||e.startState(t,r)}function Ye(e,t,r,n){var i=[e.state.modeGen],o={};tt(e,t.text,e.doc.mode,r,function(e,t){return i.push(e,t)},o,n);for(var l=r.state,s=0;s<e.state.overlays.length;++s)!function(n){var l=e.state.overlays[n],s=1,a=0;r.state=!0,tt(e,t.text,l.mode,r,function(e,t){for(var r=s;a<e;){var n=i[s];n>e&&i.splice(s,1,e,i[s+1],n),s+=2,a=Math.min(e,n)}if(t)if(l.opaque)i.splice(r,s-r,e,"overlay "+t),s=r+2;else for(;r<s;r+=2){var o=i[r+1];i[r+1]=(o?o+" ":"")+"overlay "+t}},o)}(s);return r.state=l,{styles:i,classes:o.bgClass||o.textClass?o:null}}function _e(e,t,r){if(!t.styles||t.styles[0]!=e.state.modeGen){var n=$e(e,W(t)),i=t.text.length>e.options.maxHighlightLength&&Ke(e.doc.mode,n.state),o=Ye(e,t,n);i&&(n.state=i),t.stateAfter=n.save(!i),t.styles=o.styles,o.classes?t.styleClasses=o.classes:t.styleClasses&&(t.styleClasses=null),r===e.doc.highlightFrontier&&(e.doc.modeFrontier=Math.max(e.doc.modeFrontier,++e.doc.highlightFrontier))}return t.styles}function $e(e,t,r){var n=e.doc,i=e.display;if(!n.mode.startState)return new us(n,!0,t);var o=rt(e,t,r),l=o>n.first&&M(n,o-1).stateAfter,s=l?us.fromSaved(n,l,o):new us(n,Xe(n.mode),o);return n.iter(o,t,function(r){qe(e,r.text,s);var n=s.line;r.stateAfter=n==t-1||n%5==0||n>=i.viewFrom&&n<i.viewTo?s.save():null,s.nextLine()}),r&&(n.modeFrontier=s.line),s}function qe(e,t,r,n){var i=e.doc.mode,o=new ss(t,e.options.tabSize,r);for(o.start=o.pos=n||0,""==t&&Ze(i,r.state);!o.eol();)Qe(i,o,r.state),o.start=o.pos}function Ze(e,t){if(e.blankLine)return e.blankLine(t);if(e.innerMode){var r=je(e,t);return r.mode.blankLine?r.mode.blankLine(r.state):void 0}}function Qe(e,t,r,n){for(var i=0;i<10;i++){n&&(n[0]=je(e,r).mode);var o=e.token(t,r);if(t.pos>t.start)return o}throw new Error("Mode "+e.name+" failed to advance stream.")}function Je(e,t,r,n){var i,o,l=e.doc,s=l.mode,a=M(l,(t=U(l,t)).line),u=$e(e,t.line,r),c=new ss(a.text,e.options.tabSize,u);for(n&&(o=[]);(n||c.pos<t.ch)&&!c.eol();)c.start=c.pos,i=Qe(s,c,u.state),n&&o.push(new cs(c,i,Ke(l.mode,u.state)));return n?o:new cs(c,i,u.state)}function et(e,t){if(e)for(;;){var r=e.match(/(?:^|\s+)line-(background-)?(\S+)/);if(!r)break;e=e.slice(0,r.index)+e.slice(r.index+r[0].length);var n=r[1]?"bgClass":"textClass";null==t[n]?t[n]=r[2]:new RegExp("(?:^|s)"+r[2]+"(?:$|s)").test(t[n])||(t[n]+=" "+r[2])}return e}function tt(e,t,r,n,i,o,l){var s=r.flattenSpans;null==s&&(s=e.options.flattenSpans);var a,u=0,c=null,f=new ss(t,e.options.tabSize,n),h=e.options.addModeClass&&[null];for(""==t&&et(Ze(r,n.state),o);!f.eol();){if(f.pos>e.options.maxHighlightLength?(s=!1,l&&qe(e,t,n,f.pos),f.pos=t.length,a=null):a=et(Qe(r,f,n.state,h),o),h){var d=h[0].name;d&&(a="m-"+(a?d+" "+a:d))}if(!s||c!=a){for(;u<f.start;)i(u=Math.min(f.start,u+5e3),c);c=a}f.start=f.pos}for(;u<f.pos;){var p=Math.min(f.pos,u+5e3);i(p,c),u=p}}function rt(e,t,r){for(var n,i,o=e.doc,l=r?-1:t-(e.doc.mode.innerMode?1e3:100),s=t;s>l;--s){if(s<=o.first)return o.first;var a=M(o,s-1),u=a.stateAfter;if(u&&(!r||s+(u instanceof as?u.lookAhead:0)<=o.modeFrontier))return s;var c=f(a.text,null,e.options.tabSize);(null==i||n>c)&&(i=s-1,n=c)}return i}function nt(e,t){if(e.modeFrontier=Math.min(e.modeFrontier,t),!(e.highlightFrontier<t-10)){for(var r=e.first,n=t-1;n>r;n--){var i=M(e,n).stateAfter;if(i&&(!(i instanceof as)||n+i.lookAhead<t)){r=n+1;break}}e.highlightFrontier=Math.min(e.highlightFrontier,r)}}function it(e,t,r,n){e.text=t,e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null),null!=e.order&&(e.order=null),re(e),ne(e,r);var i=n?n(e):1;i!=e.height&&A(e,i)}function ot(e){e.parent=null,re(e)}function lt(e,t){if(!e||/^\s*$/.test(e))return null;var r=t.addModeClass?ps:ds;return r[e]||(r[e]=e.replace(/\S+/g,"cm-$&"))}function st(e,t){var r=i("span",null,null,ml?"padding-right: .1px":null),n={pre:i("pre",[r],"CodeMirror-line"),content:r,col:0,pos:0,cm:e,trailingSpace:!1,splitSpaces:(gl||ml)&&e.getOption("lineWrapping")};t.measure={};for(var o=0;o<=(t.rest?t.rest.length:0);o++){var l=o?t.rest[o-1]:t.line,s=void 0;n.pos=0,n.addToken=ut,ze(e.display.measure)&&(s=Se(l,e.doc.direction))&&(n.addToken=ft(n.addToken,s)),n.map=[],dt(l,n,_e(e,l,t!=e.display.externalMeasured&&W(l))),l.styleClasses&&(l.styleClasses.bgClass&&(n.bgClass=a(l.styleClasses.bgClass,n.bgClass||"")),l.styleClasses.textClass&&(n.textClass=a(l.styleClasses.textClass,n.textClass||""))),0==n.map.length&&n.map.push(0,0,n.content.appendChild(Ie(e.display.measure))),0==o?(t.measure.map=n.map,t.measure.cache={}):((t.measure.maps||(t.measure.maps=[])).push(n.map),(t.measure.caches||(t.measure.caches=[])).push({}))}if(ml){var u=n.content.lastChild;(/\bcm-tab\b/.test(u.className)||u.querySelector&&u.querySelector(".cm-tab"))&&(n.content.className="cm-tab-wrap-hack")}return Te(e,"renderLine",e,t.line,n.pre),n.pre.className&&(n.textClass=a(n.pre.className,n.textClass||"")),n}function at(e){var t=n("span","•","cm-invalidchar");return t.title="\\u"+e.charCodeAt(0).toString(16),t.setAttribute("aria-label",t.title),t}function ut(e,t,r,i,o,l,s){if(t){var a,u=e.splitSpaces?ct(t,e.trailingSpace):t,c=e.cm.state.specialChars,f=!1;if(c.test(t)){a=document.createDocumentFragment();for(var h=0;;){c.lastIndex=h;var d=c.exec(t),g=d?d.index-h:t.length-h;if(g){var v=document.createTextNode(u.slice(h,h+g));gl&&vl<9?a.appendChild(n("span",[v])):a.appendChild(v),e.map.push(e.pos,e.pos+g,v),e.col+=g,e.pos+=g}if(!d)break;h+=g+1;var m=void 0;if("\t"==d[0]){var y=e.cm.options.tabSize,b=y-e.col%y;(m=a.appendChild(n("span",p(b),"cm-tab"))).setAttribute("role","presentation"),m.setAttribute("cm-text","\t"),e.col+=b}else"\r"==d[0]||"\n"==d[0]?((m=a.appendChild(n("span","\r"==d[0]?"␍":"␤","cm-invalidchar"))).setAttribute("cm-text",d[0]),e.col+=1):((m=e.cm.options.specialCharPlaceholder(d[0])).setAttribute("cm-text",d[0]),gl&&vl<9?a.appendChild(n("span",[m])):a.appendChild(m),e.col+=1);e.map.push(e.pos,e.pos+1,m),e.pos++}}else e.col+=t.length,a=document.createTextNode(u),e.map.push(e.pos,e.pos+t.length,a),gl&&vl<9&&(f=!0),e.pos+=t.length;if(e.trailingSpace=32==u.charCodeAt(t.length-1),r||i||o||f||s){var w=r||"";i&&(w+=i),o&&(w+=o);var x=n("span",[a],w,s);return l&&(x.title=l),e.content.appendChild(x)}e.content.appendChild(a)}}function ct(e,t){if(e.length>1&&!/  /.test(e))return e;for(var r=t,n="",i=0;i<e.length;i++){var o=e.charAt(i);" "!=o||!r||i!=e.length-1&&32!=e.charCodeAt(i+1)||(o=" "),n+=o,r=" "==o}return n}function ft(e,t){return function(r,n,i,o,l,s,a){i=i?i+" cm-force-border":"cm-force-border";for(var u=r.pos,c=u+n.length;;){for(var f=void 0,h=0;h<t.length&&!((f=t[h]).to>u&&f.from<=u);h++);if(f.to>=c)return e(r,n,i,o,l,s,a);e(r,n.slice(0,f.to-u),i,o,null,s,a),o=null,n=n.slice(f.to-u),u=f.to}}}function ht(e,t,r,n){var i=!n&&r.widgetNode;i&&e.map.push(e.pos,e.pos+t,i),!n&&e.cm.display.input.needsContentAttribute&&(i||(i=e.content.appendChild(document.createElement("span"))),i.setAttribute("cm-marker",r.id)),i&&(e.cm.display.input.setUneditable(i),e.content.appendChild(i)),e.pos+=t,e.trailingSpace=!1}function dt(e,t,r){var n=e.markedSpans,i=e.text,o=0;if(n)for(var l,s,a,u,c,f,h,d=i.length,p=0,g=1,v="",m=0;;){if(m==p){a=u=c=f=s="",h=null,m=1/0;for(var y=[],b=void 0,w=0;w<n.length;++w){var x=n[w],C=x.marker;"bookmark"==C.type&&x.from==p&&C.widgetNode?y.push(C):x.from<=p&&(null==x.to||x.to>p||C.collapsed&&x.to==p&&x.from==p)?(null!=x.to&&x.to!=p&&m>x.to&&(m=x.to,u=""),C.className&&(a+=" "+C.className),C.css&&(s=(s?s+";":"")+C.css),C.startStyle&&x.from==p&&(c+=" "+C.startStyle),C.endStyle&&x.to==m&&(b||(b=[])).push(C.endStyle,x.to),C.title&&!f&&(f=C.title),C.collapsed&&(!h||le(h.marker,C)<0)&&(h=x)):x.from>p&&m>x.from&&(m=x.from)}if(b)for(var S=0;S<b.length;S+=2)b[S+1]==m&&(u+=" "+b[S]);if(!h||h.from==p)for(var L=0;L<y.length;++L)ht(t,0,y[L]);if(h&&(h.from||0)==p){if(ht(t,(null==h.to?d+1:h.to)-p,h.marker,null==h.from),null==h.to)return;h.to==p&&(h=!1)}}if(p>=d)break;for(var k=Math.min(d,m);;){if(v){var T=p+v.length;if(!h){var M=T>k?v.slice(0,k-p):v;t.addToken(t,M,l?l+a:a,c,p+M.length==m?u:"",f,s)}if(T>=k){v=v.slice(k-p),p=k;break}p=T,c=""}v=i.slice(o,o=r[g++]),l=lt(r[g++],t.cm.options)}}else for(var N=1;N<r.length;N+=2)t.addToken(t,i.slice(o,o=r[N]),lt(r[N+1],t.cm.options))}function pt(e,t,r){this.line=t,this.rest=de(t),this.size=this.rest?W(g(this.rest))-r+1:1,this.node=this.text=null,this.hidden=ve(e,t)}function gt(e,t,r){for(var n,i=[],o=t;o<r;o=n){var l=new pt(e.doc,M(e.doc,o),o);n=o+l.size,i.push(l)}return i}function vt(e){gs?gs.ops.push(e):e.ownsGroup=gs={ops:[e],delayedCallbacks:[]}}function mt(e){var t=e.delayedCallbacks,r=0;do{for(;r<t.length;r++)t[r].call(null);for(var n=0;n<e.ops.length;n++){var i=e.ops[n];if(i.cursorActivityHandlers)for(;i.cursorActivityCalled<i.cursorActivityHandlers.length;)i.cursorActivityHandlers[i.cursorActivityCalled++].call(null,i.cm)}}while(r<t.length)}function yt(e,t){var r=e.ownsGroup;if(r)try{mt(r)}finally{gs=null,t(r)}}function bt(e,t){var r=Le(e,t);if(r.length){var n,i=Array.prototype.slice.call(arguments,2);gs?n=gs.delayedCallbacks:vs?n=vs:(n=vs=[],setTimeout(wt,0));for(var o=0;o<r.length;++o)!function(e){n.push(function(){return r[e].apply(null,i)})}(o)}}function wt(){var e=vs;vs=null;for(var t=0;t<e.length;++t)e[t]()}function xt(e,t,r,n){for(var i=0;i<t.changes.length;i++){var o=t.changes[i];"text"==o?kt(e,t):"gutter"==o?Mt(e,t,r,n):"class"==o?Tt(e,t):"widget"==o&&Nt(e,t,n)}t.changes=null}function Ct(e){return e.node==e.text&&(e.node=n("div",null,null,"position: relative"),e.text.parentNode&&e.text.parentNode.replaceChild(e.node,e.text),e.node.appendChild(e.text),gl&&vl<8&&(e.node.style.zIndex=2)),e.node}function St(e,t){var r=t.bgClass?t.bgClass+" "+(t.line.bgClass||""):t.line.bgClass;if(r&&(r+=" CodeMirror-linebackground"),t.background)r?t.background.className=r:(t.background.parentNode.removeChild(t.background),t.background=null);else if(r){var i=Ct(t);t.background=i.insertBefore(n("div",null,r),i.firstChild),e.display.input.setUneditable(t.background)}}function Lt(e,t){var r=e.display.externalMeasured;return r&&r.line==t.line?(e.display.externalMeasured=null,t.measure=r.measure,r.built):st(e,t)}function kt(e,t){var r=t.text.className,n=Lt(e,t);t.text==t.node&&(t.node=n.pre),t.text.parentNode.replaceChild(n.pre,t.text),t.text=n.pre,n.bgClass!=t.bgClass||n.textClass!=t.textClass?(t.bgClass=n.bgClass,t.textClass=n.textClass,Tt(e,t)):r&&(t.text.className=r)}function Tt(e,t){St(e,t),t.line.wrapClass?Ct(t).className=t.line.wrapClass:t.node!=t.text&&(t.node.className="");var r=t.textClass?t.textClass+" "+(t.line.textClass||""):t.line.textClass;t.text.className=r||""}function Mt(e,t,r,i){if(t.gutter&&(t.node.removeChild(t.gutter),t.gutter=null),t.gutterBackground&&(t.node.removeChild(t.gutterBackground),t.gutterBackground=null),t.line.gutterClass){var o=Ct(t);t.gutterBackground=n("div",null,"CodeMirror-gutter-background "+t.line.gutterClass,"left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px; width: "+i.gutterTotalWidth+"px"),e.display.input.setUneditable(t.gutterBackground),o.insertBefore(t.gutterBackground,t.text)}var l=t.line.gutterMarkers;if(e.options.lineNumbers||l){var s=Ct(t),a=t.gutter=n("div",null,"CodeMirror-gutter-wrapper","left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px");if(e.display.input.setUneditable(a),s.insertBefore(a,t.text),t.line.gutterClass&&(a.className+=" "+t.line.gutterClass),!e.options.lineNumbers||l&&l["CodeMirror-linenumbers"]||(t.lineNumber=a.appendChild(n("div",F(e.options,r),"CodeMirror-linenumber CodeMirror-gutter-elt","left: "+i.gutterLeft["CodeMirror-linenumbers"]+"px; width: "+e.display.lineNumInnerWidth+"px"))),l)for(var u=0;u<e.options.gutters.length;++u){var c=e.options.gutters[u],f=l.hasOwnProperty(c)&&l[c];f&&a.appendChild(n("div",[f],"CodeMirror-gutter-elt","left: "+i.gutterLeft[c]+"px; width: "+i.gutterWidth[c]+"px"))}}}function Nt(e,t,r){t.alignable&&(t.alignable=null);for(var n=t.node.firstChild,i=void 0;n;n=i)i=n.nextSibling,"CodeMirror-linewidget"==n.className&&t.node.removeChild(n);At(e,t,r)}function Ot(e,t,r,n){var i=Lt(e,t);return t.text=t.node=i.pre,i.bgClass&&(t.bgClass=i.bgClass),i.textClass&&(t.textClass=i.textClass),Tt(e,t),Mt(e,t,r,n),At(e,t,n),t.node}function At(e,t,r){if(Wt(e,t.line,t,r,!0),t.rest)for(var n=0;n<t.rest.length;n++)Wt(e,t.rest[n],t,r,!1)}function Wt(e,t,r,i,o){if(t.widgets)for(var l=Ct(r),s=0,a=t.widgets;s<a.length;++s){var u=a[s],c=n("div",[u.node],"CodeMirror-linewidget");u.handleMouseEvents||c.setAttribute("cm-ignore-events","true"),Dt(u,c,r,i),e.display.input.setUneditable(c),o&&u.above?l.insertBefore(c,r.gutter||r.text):l.appendChild(c),bt(u,"redraw")}}function Dt(e,t,r,n){if(e.noHScroll){(r.alignable||(r.alignable=[])).push(t);var i=n.wrapperWidth;t.style.left=n.fixedPos+"px",e.coverGutter||(i-=n.gutterTotalWidth,t.style.paddingLeft=n.gutterTotalWidth+"px"),t.style.width=i+"px"}e.coverGutter&&(t.style.zIndex=5,t.style.position="relative",e.noHScroll||(t.style.marginLeft=-n.gutterTotalWidth+"px"))}function Ht(e){if(null!=e.height)return e.height;var t=e.doc.cm;if(!t)return 0;if(!o(document.body,e.node)){var i="position: relative;";e.coverGutter&&(i+="margin-left: -"+t.display.gutters.offsetWidth+"px;"),e.noHScroll&&(i+="width: "+t.display.wrapper.clientWidth+"px;"),r(t.display.measure,n("div",[e.node],null,i))}return e.height=e.node.parentNode.offsetHeight}function Ft(e,t){for(var r=Ee(t);r!=e.wrapper;r=r.parentNode)if(!r||1==r.nodeType&&"true"==r.getAttribute("cm-ignore-events")||r.parentNode==e.sizer&&r!=e.mover)return!0}function Et(e){return e.lineSpace.offsetTop}function Pt(e){return e.mover.offsetHeight-e.lineSpace.offsetHeight}function It(e){if(e.cachedPaddingH)return e.cachedPaddingH;var t=r(e.measure,n("pre","x")),i=window.getComputedStyle?window.getComputedStyle(t):t.currentStyle,o={left:parseInt(i.paddingLeft),right:parseInt(i.paddingRight)};return isNaN(o.left)||isNaN(o.right)||(e.cachedPaddingH=o),o}function zt(e){return Rl-e.display.nativeBarWidth}function Rt(e){return e.display.scroller.clientWidth-zt(e)-e.display.barWidth}function Bt(e){return e.display.scroller.clientHeight-zt(e)-e.display.barHeight}function Gt(e,t,r){var n=e.options.lineWrapping,i=n&&Rt(e);if(!t.measure.heights||n&&t.measure.width!=i){var o=t.measure.heights=[];if(n){t.measure.width=i;for(var l=t.text.firstChild.getClientRects(),s=0;s<l.length-1;s++){var a=l[s],u=l[s+1];Math.abs(a.bottom-u.bottom)>2&&o.push((a.bottom+u.top)/2-r.top)}}o.push(r.bottom-r.top)}}function Ut(e,t,r){if(e.line==t)return{map:e.measure.map,cache:e.measure.cache};for(var n=0;n<e.rest.length;n++)if(e.rest[n]==t)return{map:e.measure.maps[n],cache:e.measure.caches[n]};for(var i=0;i<e.rest.length;i++)if(W(e.rest[i])>r)return{map:e.measure.maps[i],cache:e.measure.caches[i],before:!0}}function Vt(e,t){var n=W(t=fe(t)),i=e.display.externalMeasured=new pt(e.doc,t,n);i.lineN=n;var o=i.built=st(e,i);return i.text=o.pre,r(e.display.lineMeasure,o.pre),i}function Kt(e,t,r,n){return Yt(e,Xt(e,t),r,n)}function jt(e,t){if(t>=e.display.viewFrom&&t<e.display.viewTo)return e.display.view[Lr(e,t)];var r=e.display.externalMeasured;return r&&t>=r.lineN&&t<r.lineN+r.size?r:void 0}function Xt(e,t){var r=W(t),n=jt(e,r);n&&!n.text?n=null:n&&n.changes&&(xt(e,n,r,br(e)),e.curOp.forceUpdate=!0),n||(n=Vt(e,t));var i=Ut(n,t,r);return{line:t,view:n,rect:null,map:i.map,cache:i.cache,before:i.before,hasHeights:!1}}function Yt(e,t,r,n,i){t.before&&(r=-1);var o,l=r+(n||"");return t.cache.hasOwnProperty(l)?o=t.cache[l]:(t.rect||(t.rect=t.view.text.getBoundingClientRect()),t.hasHeights||(Gt(e,t.view,t.rect),t.hasHeights=!0),(o=qt(e,t,r,n)).bogus||(t.cache[l]=o)),{left:o.left,right:o.right,top:i?o.rtop:o.top,bottom:i?o.rbottom:o.bottom}}function _t(e,t,r){for(var n,i,o,l,s,a,u=0;u<e.length;u+=3)if(s=e[u],a=e[u+1],t<s?(i=0,o=1,l="left"):t<a?o=(i=t-s)+1:(u==e.length-3||t==a&&e[u+3]>t)&&(i=(o=a-s)-1,t>=a&&(l="right")),null!=i){if(n=e[u+2],s==a&&r==(n.insertLeft?"left":"right")&&(l=r),"left"==r&&0==i)for(;u&&e[u-2]==e[u-3]&&e[u-1].insertLeft;)n=e[2+(u-=3)],l="left";if("right"==r&&i==a-s)for(;u<e.length-3&&e[u+3]==e[u+4]&&!e[u+5].insertLeft;)n=e[(u+=3)+2],l="right";break}return{node:n,start:i,end:o,collapse:l,coverStart:s,coverEnd:a}}function $t(e,t){var r=ms;if("left"==t)for(var n=0;n<e.length&&(r=e[n]).left==r.right;n++);else for(var i=e.length-1;i>=0&&(r=e[i]).left==r.right;i--);return r}function qt(e,t,r,n){var i,o=_t(t.map,r,n),l=o.node,s=o.start,a=o.end,u=o.collapse;if(3==l.nodeType){for(var c=0;c<4;c++){for(;s&&S(t.line.text.charAt(o.coverStart+s));)--s;for(;o.coverStart+a<o.coverEnd&&S(t.line.text.charAt(o.coverStart+a));)++a;if((i=gl&&vl<9&&0==s&&a==o.coverEnd-o.coverStart?l.parentNode.getBoundingClientRect():$t(Wl(l,s,a).getClientRects(),n)).left||i.right||0==s)break;a=s,s-=1,u="right"}gl&&vl<11&&(i=Zt(e.display.measure,i))}else{s>0&&(u=n="right");var f;i=e.options.lineWrapping&&(f=l.getClientRects()).length>1?f["right"==n?f.length-1:0]:l.getBoundingClientRect()}if(gl&&vl<9&&!s&&(!i||!i.left&&!i.right)){var h=l.parentNode.getClientRects()[0];i=h?{left:h.left,right:h.left+yr(e.display),top:h.top,bottom:h.bottom}:ms}for(var d=i.top-t.rect.top,p=i.bottom-t.rect.top,g=(d+p)/2,v=t.view.measure.heights,m=0;m<v.length-1&&!(g<v[m]);m++);var y=m?v[m-1]:0,b=v[m],w={left:("right"==u?i.right:i.left)-t.rect.left,right:("left"==u?i.left:i.right)-t.rect.left,top:y,bottom:b};return i.left||i.right||(w.bogus=!0),e.options.singleCursorHeightPerLine||(w.rtop=d,w.rbottom=p),w}function Zt(e,t){if(!window.screen||null==screen.logicalXDPI||screen.logicalXDPI==screen.deviceXDPI||!Re(e))return t;var r=screen.logicalXDPI/screen.deviceXDPI,n=screen.logicalYDPI/screen.deviceYDPI;return{left:t.left*r,right:t.right*r,top:t.top*n,bottom:t.bottom*n}}function Qt(e){if(e.measure&&(e.measure.cache={},e.measure.heights=null,e.rest))for(var t=0;t<e.rest.length;t++)e.measure.caches[t]={}}function Jt(e){e.display.externalMeasure=null,t(e.display.lineMeasure);for(var r=0;r<e.display.view.length;r++)Qt(e.display.view[r])}function er(e){Jt(e),e.display.cachedCharWidth=e.display.cachedTextHeight=e.display.cachedPaddingH=null,e.options.lineWrapping||(e.display.maxLineChanged=!0),e.display.lineNumChars=null}function tr(){return bl&&kl?-(document.body.getBoundingClientRect().left-parseInt(getComputedStyle(document.body).marginLeft)):window.pageXOffset||(document.documentElement||document.body).scrollLeft}function rr(){return bl&&kl?-(document.body.getBoundingClientRect().top-parseInt(getComputedStyle(document.body).marginTop)):window.pageYOffset||(document.documentElement||document.body).scrollTop}function nr(e){var t=0;if(e.widgets)for(var r=0;r<e.widgets.length;++r)e.widgets[r].above&&(t+=Ht(e.widgets[r]));return t}function ir(e,t,r,n,i){if(!i){var o=nr(t);r.top+=o,r.bottom+=o}if("line"==n)return r;n||(n="local");var l=ye(t);if("local"==n?l+=Et(e.display):l-=e.display.viewOffset,"page"==n||"window"==n){var s=e.display.lineSpace.getBoundingClientRect();l+=s.top+("window"==n?0:rr());var a=s.left+("window"==n?0:tr());r.left+=a,r.right+=a}return r.top+=l,r.bottom+=l,r}function or(e,t,r){if("div"==r)return t;var n=t.left,i=t.top;if("page"==r)n-=tr(),i-=rr();else if("local"==r||!r){var o=e.display.sizer.getBoundingClientRect();n+=o.left,i+=o.top}var l=e.display.lineSpace.getBoundingClientRect();return{left:n-l.left,top:i-l.top}}function lr(e,t,r,n,i){return n||(n=M(e.doc,t.line)),ir(e,n,Kt(e,n,t.ch,i),r)}function sr(e,t,r,n,i,o){function l(t,l){var s=Yt(e,i,t,l?"right":"left",o);return l?s.left=s.right:s.right=s.left,ir(e,n,s,r)}function s(e,t,r){var n=1==a[t].level;return l(r?e-1:e,n!=r)}n=n||M(e.doc,t.line),i||(i=Xt(e,n));var a=Se(n,e.doc.direction),u=t.ch,c=t.sticky;if(u>=n.text.length?(u=n.text.length,c="before"):u<=0&&(u=0,c="after"),!a)return l("before"==c?u-1:u,"before"==c);var f=Ce(a,u,c),h=$l,d=s(u,f,"before"==c);return null!=h&&(d.other=s(u,h,"before"!=c)),d}function ar(e,t){var r=0;t=U(e.doc,t),e.options.lineWrapping||(r=yr(e.display)*t.ch);var n=M(e.doc,t.line),i=ye(n)+Et(e.display);return{left:r,right:r,top:i,bottom:i+n.height}}function ur(e,t,r,n,i){var o=E(e,t,r);return o.xRel=i,n&&(o.outside=!0),o}function cr(e,t,r){var n=e.doc;if((r+=e.display.viewOffset)<0)return ur(n.first,0,null,!0,-1);var i=D(n,r),o=n.first+n.size-1;if(i>o)return ur(n.first+n.size-1,M(n,o).text.length,null,!0,1);t<0&&(t=0);for(var l=M(n,i);;){var s=pr(e,l,i,t,r),a=ue(l),u=a&&a.find(0,!0);if(!a||!(s.ch>u.from.ch||s.ch==u.from.ch&&s.xRel>0))return s;i=W(l=u.to.line)}}function fr(e,t,r,n){n-=nr(t);var i=t.text.length,o=k(function(t){return Yt(e,r,t-1).bottom<=n},i,0);return i=k(function(t){return Yt(e,r,t).top>n},o,i),{begin:o,end:i}}function hr(e,t,r,n){return r||(r=Xt(e,t)),fr(e,t,r,ir(e,t,Yt(e,r,n),"line").top)}function dr(e,t,r,n){return!(e.bottom<=r)&&(e.top>r||(n?e.left:e.right)>t)}function pr(e,t,r,n,i){i-=ye(t);var o=Xt(e,t),l=nr(t),s=0,a=t.text.length,u=!0,c=Se(t,e.doc.direction);if(c){var f=(e.options.lineWrapping?vr:gr)(e,t,r,o,c,n,i);s=(u=1!=f.level)?f.from:f.to-1,a=u?f.to:f.from-1}var h,d,p=null,g=null,v=k(function(t){var r=Yt(e,o,t);return r.top+=l,r.bottom+=l,!!dr(r,n,i,!1)&&(r.top<=i&&r.left<=n&&(p=t,g=r),!0)},s,a),m=!1;if(g){var y=n-g.left<g.right-n,b=y==u;v=p+(b?0:1),d=b?"after":"before",h=y?g.left:g.right}else{u||v!=a&&v!=s||v++,d=0==v?"after":v==t.text.length?"before":Yt(e,o,v-(u?1:0)).bottom+l<=i==u?"after":"before";var w=sr(e,E(r,v,d),"line",t,o);h=w.left,m=i<w.top||i>=w.bottom}return v=L(t.text,v,1),ur(r,v,d,m,n-h)}function gr(e,t,r,n,i,o,l){var s=k(function(s){var a=i[s],u=1!=a.level;return dr(sr(e,E(r,u?a.to:a.from,u?"before":"after"),"line",t,n),o,l,!0)},0,i.length-1),a=i[s];if(s>0){var u=1!=a.level,c=sr(e,E(r,u?a.from:a.to,u?"after":"before"),"line",t,n);dr(c,o,l,!0)&&c.top>l&&(a=i[s-1])}return a}function vr(e,t,r,n,i,o,l){for(var s=fr(e,t,n,l),a=s.begin,u=s.end,c=null,f=null,h=0;h<i.length;h++){var d=i[h];if(!(d.from>=u||d.to<=a)){var p=Yt(e,n,1!=d.level?Math.min(u,d.to)-1:Math.max(a,d.from)).right,g=p<o?o-p+1e9:p-o;(!c||f>g)&&(c=d,f=g)}}return c||(c=i[i.length-1]),c.from<a&&(c={from:a,to:c.to,level:c.level}),c.to>u&&(c={from:c.from,to:u,level:c.level}),c}function mr(e){if(null!=e.cachedTextHeight)return e.cachedTextHeight;if(null==hs){hs=n("pre");for(var i=0;i<49;++i)hs.appendChild(document.createTextNode("x")),hs.appendChild(n("br"));hs.appendChild(document.createTextNode("x"))}r(e.measure,hs);var o=hs.offsetHeight/50;return o>3&&(e.cachedTextHeight=o),t(e.measure),o||1}function yr(e){if(null!=e.cachedCharWidth)return e.cachedCharWidth;var t=n("span","xxxxxxxxxx"),i=n("pre",[t]);r(e.measure,i);var o=t.getBoundingClientRect(),l=(o.right-o.left)/10;return l>2&&(e.cachedCharWidth=l),l||10}function br(e){for(var t=e.display,r={},n={},i=t.gutters.clientLeft,o=t.gutters.firstChild,l=0;o;o=o.nextSibling,++l)r[e.options.gutters[l]]=o.offsetLeft+o.clientLeft+i,n[e.options.gutters[l]]=o.clientWidth;return{fixedPos:wr(t),gutterTotalWidth:t.gutters.offsetWidth,gutterLeft:r,gutterWidth:n,wrapperWidth:t.wrapper.clientWidth}}function wr(e){return e.scroller.getBoundingClientRect().left-e.sizer.getBoundingClientRect().left}function xr(e){var t=mr(e.display),r=e.options.lineWrapping,n=r&&Math.max(5,e.display.scroller.clientWidth/yr(e.display)-3);return function(i){if(ve(e.doc,i))return 0;var o=0;if(i.widgets)for(var l=0;l<i.widgets.length;l++)i.widgets[l].height&&(o+=i.widgets[l].height);return r?o+(Math.ceil(i.text.length/n)||1)*t:o+t}}function Cr(e){var t=e.doc,r=xr(e);t.iter(function(e){var t=r(e);t!=e.height&&A(e,t)})}function Sr(e,t,r,n){var i=e.display;if(!r&&"true"==Ee(t).getAttribute("cm-not-content"))return null;var o,l,s=i.lineSpace.getBoundingClientRect();try{o=t.clientX-s.left,l=t.clientY-s.top}catch(t){return null}var a,u=cr(e,o,l);if(n&&1==u.xRel&&(a=M(e.doc,u.line).text).length==u.ch){var c=f(a,a.length,e.options.tabSize)-a.length;u=E(u.line,Math.max(0,Math.round((o-It(e.display).left)/yr(e.display))-c))}return u}function Lr(e,t){if(t>=e.display.viewTo)return null;if((t-=e.display.viewFrom)<0)return null;for(var r=e.display.view,n=0;n<r.length;n++)if((t-=r[n].size)<0)return n}function kr(e){e.display.input.showSelection(e.display.input.prepareSelection())}function Tr(e,t){void 0===t&&(t=!0);for(var r=e.doc,n={},i=n.cursors=document.createDocumentFragment(),o=n.selection=document.createDocumentFragment(),l=0;l<r.sel.ranges.length;l++)if(t||l!=r.sel.primIndex){var s=r.sel.ranges[l];if(!(s.from().line>=e.display.viewTo||s.to().line<e.display.viewFrom)){var a=s.empty();(a||e.options.showCursorWhenSelecting)&&Mr(e,s.head,i),a||Or(e,s,o)}}return n}function Mr(e,t,r){var i=sr(e,t,"div",null,null,!e.options.singleCursorHeightPerLine),o=r.appendChild(n("div"," ","CodeMirror-cursor"));if(o.style.left=i.left+"px",o.style.top=i.top+"px",o.style.height=Math.max(0,i.bottom-i.top)*e.options.cursorHeight+"px",i.other){var l=r.appendChild(n("div"," ","CodeMirror-cursor CodeMirror-secondarycursor"));l.style.display="",l.style.left=i.other.left+"px",l.style.top=i.other.top+"px",l.style.height=.85*(i.other.bottom-i.other.top)+"px"}}function Nr(e,t){return e.top-t.top||e.left-t.left}function Or(e,t,r){function i(e,t,r,i){t<0&&(t=0),t=Math.round(t),i=Math.round(i),a.appendChild(n("div",null,"CodeMirror-selected","position: absolute; left: "+e+"px;\n                             top: "+t+"px; width: "+(null==r?f-e:r)+"px;\n                             height: "+(i-t)+"px"))}function o(t,r,n){function o(r,n){return lr(e,E(t,r),"div",u,n)}var l,a,u=M(s,t),h=u.text.length,d=Se(u,s.direction);return xe(d,r||0,null==n?h:n,function(t,s,p,g){var v=o(t,"ltr"==p?"left":"right"),m=o(s-1,"ltr"==p?"right":"left");if("ltr"==p){var y=null==r&&0==t?c:v.left,b=null==n&&s==h?f:m.right;m.top-v.top<=3?i(y,m.top,b-y,m.bottom):(i(y,v.top,null,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top),i(c,m.top,m.right,m.bottom))}else if(t<s){var w=null==r&&0==t?f:v.right,x=null==n&&s==h?c:m.left;if(m.top-v.top<=3)i(x,m.top,w-x,m.bottom);else{var C=c;if(g){var S=hr(e,u,null,t).end;C=o(S-(/\s/.test(u.text.charAt(S-1))?2:1),"left").left}i(C,v.top,w-C,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top);var L=null;d.length,L=o(hr(e,u,null,s).begin,"right").right-x,i(x,m.top,L,m.bottom)}}(!l||Nr(v,l)<0)&&(l=v),Nr(m,l)<0&&(l=m),(!a||Nr(v,a)<0)&&(a=v),Nr(m,a)<0&&(a=m)}),{start:l,end:a}}var l=e.display,s=e.doc,a=document.createDocumentFragment(),u=It(e.display),c=u.left,f=Math.max(l.sizerWidth,Rt(e)-l.sizer.offsetLeft)-u.right,h=t.from(),d=t.to();if(h.line==d.line)o(h.line,h.ch,d.ch);else{var p=M(s,h.line),g=M(s,d.line),v=fe(p)==fe(g),m=o(h.line,h.ch,v?p.text.length+1:null).end,y=o(d.line,v?0:null,d.ch).start;v&&(m.top<y.top-2?(i(m.right,m.top,null,m.bottom),i(c,y.top,y.left,y.bottom)):i(m.right,m.top,y.left-m.right,m.bottom)),m.bottom<y.top&&i(c,m.bottom,null,y.top)}r.appendChild(a)}function Ar(e){if(e.state.focused){var t=e.display;clearInterval(t.blinker);var r=!0;t.cursorDiv.style.visibility="",e.options.cursorBlinkRate>0?t.blinker=setInterval(function(){return t.cursorDiv.style.visibility=(r=!r)?"":"hidden"},e.options.cursorBlinkRate):e.options.cursorBlinkRate<0&&(t.cursorDiv.style.visibility="hidden")}}function Wr(e){e.state.focused||(e.display.input.focus(),Hr(e))}function Dr(e){e.state.delayingBlurEvent=!0,setTimeout(function(){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1,Fr(e))},100)}function Hr(e,t){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1),"nocursor"!=e.options.readOnly&&(e.state.focused||(Te(e,"focus",e,t),e.state.focused=!0,s(e.display.wrapper,"CodeMirror-focused"),e.curOp||e.display.selForContextMenu==e.doc.sel||(e.display.input.reset(),ml&&setTimeout(function(){return e.display.input.reset(!0)},20)),e.display.input.receivedFocus()),Ar(e))}function Fr(e,t){e.state.delayingBlurEvent||(e.state.focused&&(Te(e,"blur",e,t),e.state.focused=!1,Fl(e.display.wrapper,"CodeMirror-focused")),clearInterval(e.display.blinker),setTimeout(function(){e.state.focused||(e.display.shift=!1)},150))}function Er(e){for(var t=e.display,r=t.lineDiv.offsetTop,n=0;n<t.view.length;n++){var i=t.view[n],o=void 0;if(!i.hidden){if(gl&&vl<8){var l=i.node.offsetTop+i.node.offsetHeight;o=l-r,r=l}else{var s=i.node.getBoundingClientRect();o=s.bottom-s.top}var a=i.line.height-o;if(o<2&&(o=mr(t)),(a>.005||a<-.005)&&(A(i.line,o),Pr(i.line),i.rest))for(var u=0;u<i.rest.length;u++)Pr(i.rest[u])}}}function Pr(e){if(e.widgets)for(var t=0;t<e.widgets.length;++t)e.widgets[t].height=e.widgets[t].node.parentNode.offsetHeight}function Ir(e,t,r){var n=r&&null!=r.top?Math.max(0,r.top):e.scroller.scrollTop;n=Math.floor(n-Et(e));var i=r&&null!=r.bottom?r.bottom:n+e.wrapper.clientHeight,o=D(t,n),l=D(t,i);if(r&&r.ensure){var s=r.ensure.from.line,a=r.ensure.to.line;s<o?(o=s,l=D(t,ye(M(t,s))+e.wrapper.clientHeight)):Math.min(a,t.lastLine())>=l&&(o=D(t,ye(M(t,a))-e.wrapper.clientHeight),l=a)}return{from:o,to:Math.max(l,o+1)}}function zr(e){var t=e.display,r=t.view;if(t.alignWidgets||t.gutters.firstChild&&e.options.fixedGutter){for(var n=wr(t)-t.scroller.scrollLeft+e.doc.scrollLeft,i=t.gutters.offsetWidth,o=n+"px",l=0;l<r.length;l++)if(!r[l].hidden){e.options.fixedGutter&&(r[l].gutter&&(r[l].gutter.style.left=o),r[l].gutterBackground&&(r[l].gutterBackground.style.left=o));var s=r[l].alignable;if(s)for(var a=0;a<s.length;a++)s[a].style.left=o}e.options.fixedGutter&&(t.gutters.style.left=n+i+"px")}}function Rr(e){if(!e.options.lineNumbers)return!1;var t=e.doc,r=F(e.options,t.first+t.size-1),i=e.display;if(r.length!=i.lineNumChars){var o=i.measure.appendChild(n("div",[n("div",r)],"CodeMirror-linenumber CodeMirror-gutter-elt")),l=o.firstChild.offsetWidth,s=o.offsetWidth-l;return i.lineGutter.style.width="",i.lineNumInnerWidth=Math.max(l,i.lineGutter.offsetWidth-s)+1,i.lineNumWidth=i.lineNumInnerWidth+s,i.lineNumChars=i.lineNumInnerWidth?r.length:-1,i.lineGutter.style.width=i.lineNumWidth+"px",Wn(e),!0}return!1}function Br(e,t){if(!Me(e,"scrollCursorIntoView")){var r=e.display,i=r.sizer.getBoundingClientRect(),o=null;if(t.top+i.top<0?o=!0:t.bottom+i.top>(window.innerHeight||document.documentElement.clientHeight)&&(o=!1),null!=o&&!Sl){var l=n("div","​",null,"position: absolute;\n                         top: "+(t.top-r.viewOffset-Et(e.display))+"px;\n                         height: "+(t.bottom-t.top+zt(e)+r.barHeight)+"px;\n                         left: "+t.left+"px; width: "+Math.max(2,t.right-t.left)+"px;");e.display.lineSpace.appendChild(l),l.scrollIntoView(o),e.display.lineSpace.removeChild(l)}}}function Gr(e,t,r,n){null==n&&(n=0);var i;e.options.lineWrapping||t!=r||(r="before"==(t=t.ch?E(t.line,"before"==t.sticky?t.ch-1:t.ch,"after"):t).sticky?E(t.line,t.ch+1,"before"):t);for(var o=0;o<5;o++){var l=!1,s=sr(e,t),a=r&&r!=t?sr(e,r):s,u=Vr(e,i={left:Math.min(s.left,a.left),top:Math.min(s.top,a.top)-n,right:Math.max(s.left,a.left),bottom:Math.max(s.bottom,a.bottom)+n}),c=e.doc.scrollTop,f=e.doc.scrollLeft;if(null!=u.scrollTop&&(qr(e,u.scrollTop),Math.abs(e.doc.scrollTop-c)>1&&(l=!0)),null!=u.scrollLeft&&(Qr(e,u.scrollLeft),Math.abs(e.doc.scrollLeft-f)>1&&(l=!0)),!l)break}return i}function Ur(e,t){var r=Vr(e,t);null!=r.scrollTop&&qr(e,r.scrollTop),null!=r.scrollLeft&&Qr(e,r.scrollLeft)}function Vr(e,t){var r=e.display,n=mr(e.display);t.top<0&&(t.top=0);var i=e.curOp&&null!=e.curOp.scrollTop?e.curOp.scrollTop:r.scroller.scrollTop,o=Bt(e),l={};t.bottom-t.top>o&&(t.bottom=t.top+o);var s=e.doc.height+Pt(r),a=t.top<n,u=t.bottom>s-n;if(t.top<i)l.scrollTop=a?0:t.top;else if(t.bottom>i+o){var c=Math.min(t.top,(u?s:t.bottom)-o);c!=i&&(l.scrollTop=c)}var f=e.curOp&&null!=e.curOp.scrollLeft?e.curOp.scrollLeft:r.scroller.scrollLeft,h=Rt(e)-(e.options.fixedGutter?r.gutters.offsetWidth:0),d=t.right-t.left>h;return d&&(t.right=t.left+h),t.left<10?l.scrollLeft=0:t.left<f?l.scrollLeft=Math.max(0,t.left-(d?0:10)):t.right>h+f-3&&(l.scrollLeft=t.right+(d?0:10)-h),l}function Kr(e,t){null!=t&&(_r(e),e.curOp.scrollTop=(null==e.curOp.scrollTop?e.doc.scrollTop:e.curOp.scrollTop)+t)}function jr(e){_r(e);var t=e.getCursor();e.curOp.scrollToPos={from:t,to:t,margin:e.options.cursorScrollMargin}}function Xr(e,t,r){null==t&&null==r||_r(e),null!=t&&(e.curOp.scrollLeft=t),null!=r&&(e.curOp.scrollTop=r)}function Yr(e,t){_r(e),e.curOp.scrollToPos=t}function _r(e){var t=e.curOp.scrollToPos;t&&(e.curOp.scrollToPos=null,$r(e,ar(e,t.from),ar(e,t.to),t.margin))}function $r(e,t,r,n){var i=Vr(e,{left:Math.min(t.left,r.left),top:Math.min(t.top,r.top)-n,right:Math.max(t.right,r.right),bottom:Math.max(t.bottom,r.bottom)+n});Xr(e,i.scrollLeft,i.scrollTop)}function qr(e,t){Math.abs(e.doc.scrollTop-t)<2||(fl||On(e,{top:t}),Zr(e,t,!0),fl&&On(e),Cn(e,100))}function Zr(e,t,r){t=Math.min(e.display.scroller.scrollHeight-e.display.scroller.clientHeight,t),(e.display.scroller.scrollTop!=t||r)&&(e.doc.scrollTop=t,e.display.scrollbars.setScrollTop(t),e.display.scroller.scrollTop!=t&&(e.display.scroller.scrollTop=t))}function Qr(e,t,r,n){t=Math.min(t,e.display.scroller.scrollWidth-e.display.scroller.clientWidth),(r?t==e.doc.scrollLeft:Math.abs(e.doc.scrollLeft-t)<2)&&!n||(e.doc.scrollLeft=t,zr(e),e.display.scroller.scrollLeft!=t&&(e.display.scroller.scrollLeft=t),e.display.scrollbars.setScrollLeft(t))}function Jr(e){var t=e.display,r=t.gutters.offsetWidth,n=Math.round(e.doc.height+Pt(e.display));return{clientHeight:t.scroller.clientHeight,viewHeight:t.wrapper.clientHeight,scrollWidth:t.scroller.scrollWidth,clientWidth:t.scroller.clientWidth,viewWidth:t.wrapper.clientWidth,barLeft:e.options.fixedGutter?r:0,docHeight:n,scrollHeight:n+zt(e)+t.barHeight,nativeBarWidth:t.nativeBarWidth,gutterWidth:r}}function en(e,t){t||(t=Jr(e));var r=e.display.barWidth,n=e.display.barHeight;tn(e,t);for(var i=0;i<4&&r!=e.display.barWidth||n!=e.display.barHeight;i++)r!=e.display.barWidth&&e.options.lineWrapping&&Er(e),tn(e,Jr(e)),r=e.display.barWidth,n=e.display.barHeight}function tn(e,t){var r=e.display,n=r.scrollbars.update(t);r.sizer.style.paddingRight=(r.barWidth=n.right)+"px",r.sizer.style.paddingBottom=(r.barHeight=n.bottom)+"px",r.heightForcer.style.borderBottom=n.bottom+"px solid transparent",n.right&&n.bottom?(r.scrollbarFiller.style.display="block",r.scrollbarFiller.style.height=n.bottom+"px",r.scrollbarFiller.style.width=n.right+"px"):r.scrollbarFiller.style.display="",n.bottom&&e.options.coverGutterNextToScrollbar&&e.options.fixedGutter?(r.gutterFiller.style.display="block",r.gutterFiller.style.height=n.bottom+"px",r.gutterFiller.style.width=t.gutterWidth+"px"):r.gutterFiller.style.display=""}function rn(e){e.display.scrollbars&&(e.display.scrollbars.clear(),e.display.scrollbars.addClass&&Fl(e.display.wrapper,e.display.scrollbars.addClass)),e.display.scrollbars=new ws[e.options.scrollbarStyle](function(t){e.display.wrapper.insertBefore(t,e.display.scrollbarFiller),Ql(t,"mousedown",function(){e.state.focused&&setTimeout(function(){return e.display.input.focus()},0)}),t.setAttribute("cm-not-content","true")},function(t,r){"horizontal"==r?Qr(e,t):qr(e,t)},e),e.display.scrollbars.addClass&&s(e.display.wrapper,e.display.scrollbars.addClass)}function nn(e){e.curOp={cm:e,viewChanged:!1,startHeight:e.doc.height,forceUpdate:!1,updateInput:null,typing:!1,changeObjs:null,cursorActivityHandlers:null,cursorActivityCalled:0,selectionChanged:!1,updateMaxLine:!1,scrollLeft:null,scrollTop:null,scrollToPos:null,focus:!1,id:++xs},vt(e.curOp)}function on(e){yt(e.curOp,function(e){for(var t=0;t<e.ops.length;t++)e.ops[t].cm.curOp=null;ln(e)})}function ln(e){for(var t=e.ops,r=0;r<t.length;r++)sn(t[r]);for(var n=0;n<t.length;n++)an(t[n]);for(var i=0;i<t.length;i++)un(t[i]);for(var o=0;o<t.length;o++)cn(t[o]);for(var l=0;l<t.length;l++)fn(t[l])}function sn(e){var t=e.cm,r=t.display;Ln(t),e.updateMaxLine&&we(t),e.mustUpdate=e.viewChanged||e.forceUpdate||null!=e.scrollTop||e.scrollToPos&&(e.scrollToPos.from.line<r.viewFrom||e.scrollToPos.to.line>=r.viewTo)||r.maxLineChanged&&t.options.lineWrapping,e.update=e.mustUpdate&&new Cs(t,e.mustUpdate&&{top:e.scrollTop,ensure:e.scrollToPos},e.forceUpdate)}function an(e){e.updatedDisplay=e.mustUpdate&&Mn(e.cm,e.update)}function un(e){var t=e.cm,r=t.display;e.updatedDisplay&&Er(t),e.barMeasure=Jr(t),r.maxLineChanged&&!t.options.lineWrapping&&(e.adjustWidthTo=Kt(t,r.maxLine,r.maxLine.text.length).left+3,t.display.sizerWidth=e.adjustWidthTo,e.barMeasure.scrollWidth=Math.max(r.scroller.clientWidth,r.sizer.offsetLeft+e.adjustWidthTo+zt(t)+t.display.barWidth),e.maxScrollLeft=Math.max(0,r.sizer.offsetLeft+e.adjustWidthTo-Rt(t))),(e.updatedDisplay||e.selectionChanged)&&(e.preparedSelection=r.input.prepareSelection())}function cn(e){var t=e.cm;null!=e.adjustWidthTo&&(t.display.sizer.style.minWidth=e.adjustWidthTo+"px",e.maxScrollLeft<t.doc.scrollLeft&&Qr(t,Math.min(t.display.scroller.scrollLeft,e.maxScrollLeft),!0),t.display.maxLineChanged=!1);var r=e.focus&&e.focus==l();e.preparedSelection&&t.display.input.showSelection(e.preparedSelection,r),(e.updatedDisplay||e.startHeight!=t.doc.height)&&en(t,e.barMeasure),e.updatedDisplay&&Dn(t,e.barMeasure),e.selectionChanged&&Ar(t),t.state.focused&&e.updateInput&&t.display.input.reset(e.typing),r&&Wr(e.cm)}function fn(e){var t=e.cm,r=t.display,n=t.doc;e.updatedDisplay&&Nn(t,e.update),null==r.wheelStartX||null==e.scrollTop&&null==e.scrollLeft&&!e.scrollToPos||(r.wheelStartX=r.wheelStartY=null),null!=e.scrollTop&&Zr(t,e.scrollTop,e.forceScroll),null!=e.scrollLeft&&Qr(t,e.scrollLeft,!0,!0),e.scrollToPos&&Br(t,Gr(t,U(n,e.scrollToPos.from),U(n,e.scrollToPos.to),e.scrollToPos.margin));var i=e.maybeHiddenMarkers,o=e.maybeUnhiddenMarkers;if(i)for(var l=0;l<i.length;++l)i[l].lines.length||Te(i[l],"hide");if(o)for(var s=0;s<o.length;++s)o[s].lines.length&&Te(o[s],"unhide");r.wrapper.offsetHeight&&(n.scrollTop=t.display.scroller.scrollTop),e.changeObjs&&Te(t,"changes",t,e.changeObjs),e.update&&e.update.finish()}function hn(e,t){if(e.curOp)return t();nn(e);try{return t()}finally{on(e)}}function dn(e,t){return function(){if(e.curOp)return t.apply(e,arguments);nn(e);try{return t.apply(e,arguments)}finally{on(e)}}}function pn(e){return function(){if(this.curOp)return e.apply(this,arguments);nn(this);try{return e.apply(this,arguments)}finally{on(this)}}}function gn(e){return function(){var t=this.cm;if(!t||t.curOp)return e.apply(this,arguments);nn(t);try{return e.apply(this,arguments)}finally{on(t)}}}function vn(e,t,r,n){null==t&&(t=e.doc.first),null==r&&(r=e.doc.first+e.doc.size),n||(n=0);var i=e.display;if(n&&r<i.viewTo&&(null==i.updateLineNumbers||i.updateLineNumbers>t)&&(i.updateLineNumbers=t),e.curOp.viewChanged=!0,t>=i.viewTo)_l&&pe(e.doc,t)<i.viewTo&&yn(e);else if(r<=i.viewFrom)_l&&ge(e.doc,r+n)>i.viewFrom?yn(e):(i.viewFrom+=n,i.viewTo+=n);else if(t<=i.viewFrom&&r>=i.viewTo)yn(e);else if(t<=i.viewFrom){var o=bn(e,r,r+n,1);o?(i.view=i.view.slice(o.index),i.viewFrom=o.lineN,i.viewTo+=n):yn(e)}else if(r>=i.viewTo){var l=bn(e,t,t,-1);l?(i.view=i.view.slice(0,l.index),i.viewTo=l.lineN):yn(e)}else{var s=bn(e,t,t,-1),a=bn(e,r,r+n,1);s&&a?(i.view=i.view.slice(0,s.index).concat(gt(e,s.lineN,a.lineN)).concat(i.view.slice(a.index)),i.viewTo+=n):yn(e)}var u=i.externalMeasured;u&&(r<u.lineN?u.lineN+=n:t<u.lineN+u.size&&(i.externalMeasured=null))}function mn(e,t,r){e.curOp.viewChanged=!0;var n=e.display,i=e.display.externalMeasured;if(i&&t>=i.lineN&&t<i.lineN+i.size&&(n.externalMeasured=null),!(t<n.viewFrom||t>=n.viewTo)){var o=n.view[Lr(e,t)];if(null!=o.node){var l=o.changes||(o.changes=[]);-1==h(l,r)&&l.push(r)}}}function yn(e){e.display.viewFrom=e.display.viewTo=e.doc.first,e.display.view=[],e.display.viewOffset=0}function bn(e,t,r,n){var i,o=Lr(e,t),l=e.display.view;if(!_l||r==e.doc.first+e.doc.size)return{index:o,lineN:r};for(var s=e.display.viewFrom,a=0;a<o;a++)s+=l[a].size;if(s!=t){if(n>0){if(o==l.length-1)return null;i=s+l[o].size-t,o++}else i=s-t;t+=i,r+=i}for(;pe(e.doc,r)!=r;){if(o==(n<0?0:l.length-1))return null;r+=n*l[o-(n<0?1:0)].size,o+=n}return{index:o,lineN:r}}function wn(e,t,r){var n=e.display;0==n.view.length||t>=n.viewTo||r<=n.viewFrom?(n.view=gt(e,t,r),n.viewFrom=t):(n.viewFrom>t?n.view=gt(e,t,n.viewFrom).concat(n.view):n.viewFrom<t&&(n.view=n.view.slice(Lr(e,t))),n.viewFrom=t,n.viewTo<r?n.view=n.view.concat(gt(e,n.viewTo,r)):n.viewTo>r&&(n.view=n.view.slice(0,Lr(e,r)))),n.viewTo=r}function xn(e){for(var t=e.display.view,r=0,n=0;n<t.length;n++){var i=t[n];i.hidden||i.node&&!i.changes||++r}return r}function Cn(e,t){e.doc.highlightFrontier<e.display.viewTo&&e.state.highlight.set(t,u(Sn,e))}function Sn(e){var t=e.doc;if(!(t.highlightFrontier>=e.display.viewTo)){var r=+new Date+e.options.workTime,n=$e(e,t.highlightFrontier),i=[];t.iter(n.line,Math.min(t.first+t.size,e.display.viewTo+500),function(o){if(n.line>=e.display.viewFrom){var l=o.styles,s=o.text.length>e.options.maxHighlightLength?Ke(t.mode,n.state):null,a=Ye(e,o,n,!0);s&&(n.state=s),o.styles=a.styles;var u=o.styleClasses,c=a.classes;c?o.styleClasses=c:u&&(o.styleClasses=null);for(var f=!l||l.length!=o.styles.length||u!=c&&(!u||!c||u.bgClass!=c.bgClass||u.textClass!=c.textClass),h=0;!f&&h<l.length;++h)f=l[h]!=o.styles[h];f&&i.push(n.line),o.stateAfter=n.save(),n.nextLine()}else o.text.length<=e.options.maxHighlightLength&&qe(e,o.text,n),o.stateAfter=n.line%5==0?n.save():null,n.nextLine();if(+new Date>r)return Cn(e,e.options.workDelay),!0}),t.highlightFrontier=n.line,t.modeFrontier=Math.max(t.modeFrontier,n.line),i.length&&hn(e,function(){for(var t=0;t<i.length;t++)mn(e,i[t],"text")})}}function Ln(e){var t=e.display;!t.scrollbarsClipped&&t.scroller.offsetWidth&&(t.nativeBarWidth=t.scroller.offsetWidth-t.scroller.clientWidth,t.heightForcer.style.height=zt(e)+"px",t.sizer.style.marginBottom=-t.nativeBarWidth+"px",t.sizer.style.borderRightWidth=zt(e)+"px",t.scrollbarsClipped=!0)}function kn(e){if(e.hasFocus())return null;var t=l();if(!t||!o(e.display.lineDiv,t))return null;var r={activeElt:t};if(window.getSelection){var n=window.getSelection();n.anchorNode&&n.extend&&o(e.display.lineDiv,n.anchorNode)&&(r.anchorNode=n.anchorNode,r.anchorOffset=n.anchorOffset,r.focusNode=n.focusNode,r.focusOffset=n.focusOffset)}return r}function Tn(e){if(e&&e.activeElt&&e.activeElt!=l()&&(e.activeElt.focus(),e.anchorNode&&o(document.body,e.anchorNode)&&o(document.body,e.focusNode))){var t=window.getSelection(),r=document.createRange();r.setEnd(e.anchorNode,e.anchorOffset),r.collapse(!1),t.removeAllRanges(),t.addRange(r),t.extend(e.focusNode,e.focusOffset)}}function Mn(e,r){var n=e.display,i=e.doc;if(r.editorIsHidden)return yn(e),!1;if(!r.force&&r.visible.from>=n.viewFrom&&r.visible.to<=n.viewTo&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo)&&n.renderedView==n.view&&0==xn(e))return!1;Rr(e)&&(yn(e),r.dims=br(e));var o=i.first+i.size,l=Math.max(r.visible.from-e.options.viewportMargin,i.first),s=Math.min(o,r.visible.to+e.options.viewportMargin);n.viewFrom<l&&l-n.viewFrom<20&&(l=Math.max(i.first,n.viewFrom)),n.viewTo>s&&n.viewTo-s<20&&(s=Math.min(o,n.viewTo)),_l&&(l=pe(e.doc,l),s=ge(e.doc,s));var a=l!=n.viewFrom||s!=n.viewTo||n.lastWrapHeight!=r.wrapperHeight||n.lastWrapWidth!=r.wrapperWidth;wn(e,l,s),n.viewOffset=ye(M(e.doc,n.viewFrom)),e.display.mover.style.top=n.viewOffset+"px";var u=xn(e);if(!a&&0==u&&!r.force&&n.renderedView==n.view&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo))return!1;var c=kn(e);return u>4&&(n.lineDiv.style.display="none"),An(e,n.updateLineNumbers,r.dims),u>4&&(n.lineDiv.style.display=""),n.renderedView=n.view,Tn(c),t(n.cursorDiv),t(n.selectionDiv),n.gutters.style.height=n.sizer.style.minHeight=0,a&&(n.lastWrapHeight=r.wrapperHeight,n.lastWrapWidth=r.wrapperWidth,Cn(e,400)),n.updateLineNumbers=null,!0}function Nn(e,t){for(var r=t.viewport,n=!0;(n&&e.options.lineWrapping&&t.oldDisplayWidth!=Rt(e)||(r&&null!=r.top&&(r={top:Math.min(e.doc.height+Pt(e.display)-Bt(e),r.top)}),t.visible=Ir(e.display,e.doc,r),!(t.visible.from>=e.display.viewFrom&&t.visible.to<=e.display.viewTo)))&&Mn(e,t);n=!1){Er(e);var i=Jr(e);kr(e),en(e,i),Dn(e,i),t.force=!1}t.signal(e,"update",e),e.display.viewFrom==e.display.reportedViewFrom&&e.display.viewTo==e.display.reportedViewTo||(t.signal(e,"viewportChange",e,e.display.viewFrom,e.display.viewTo),e.display.reportedViewFrom=e.display.viewFrom,e.display.reportedViewTo=e.display.viewTo)}function On(e,t){var r=new Cs(e,t);if(Mn(e,r)){Er(e),Nn(e,r);var n=Jr(e);kr(e),en(e,n),Dn(e,n),r.finish()}}function An(e,r,n){function i(t){var r=t.nextSibling;return ml&&Ml&&e.display.currentWheelTarget==t?t.style.display="none":t.parentNode.removeChild(t),r}for(var o=e.display,l=e.options.lineNumbers,s=o.lineDiv,a=s.firstChild,u=o.view,c=o.viewFrom,f=0;f<u.length;f++){var d=u[f];if(d.hidden);else if(d.node&&d.node.parentNode==s){for(;a!=d.node;)a=i(a);var p=l&&null!=r&&r<=c&&d.lineNumber;d.changes&&(h(d.changes,"gutter")>-1&&(p=!1),xt(e,d,c,n)),p&&(t(d.lineNumber),d.lineNumber.appendChild(document.createTextNode(F(e.options,c)))),a=d.node.nextSibling}else{var g=Ot(e,d,c,n);s.insertBefore(g,a)}c+=d.size}for(;a;)a=i(a)}function Wn(e){var t=e.display.gutters.offsetWidth;e.display.sizer.style.marginLeft=t+"px"}function Dn(e,t){e.display.sizer.style.minHeight=t.docHeight+"px",e.display.heightForcer.style.top=t.docHeight+"px",e.display.gutters.style.height=t.docHeight+e.display.barHeight+zt(e)+"px"}function Hn(e){var r=e.display.gutters,i=e.options.gutters;t(r);for(var o=0;o<i.length;++o){var l=i[o],s=r.appendChild(n("div",null,"CodeMirror-gutter "+l));"CodeMirror-linenumbers"==l&&(e.display.lineGutter=s,s.style.width=(e.display.lineNumWidth||1)+"px")}r.style.display=o?"":"none",Wn(e)}function Fn(e){var t=h(e.gutters,"CodeMirror-linenumbers");-1==t&&e.lineNumbers?e.gutters=e.gutters.concat(["CodeMirror-linenumbers"]):t>-1&&!e.lineNumbers&&(e.gutters=e.gutters.slice(0),e.gutters.splice(t,1))}function En(e){var t=e.wheelDeltaX,r=e.wheelDeltaY;return null==t&&e.detail&&e.axis==e.HORIZONTAL_AXIS&&(t=e.detail),null==r&&e.detail&&e.axis==e.VERTICAL_AXIS?r=e.detail:null==r&&(r=e.wheelDelta),{x:t,y:r}}function Pn(e){var t=En(e);return t.x*=Ls,t.y*=Ls,t}function In(e,t){var r=En(t),n=r.x,i=r.y,o=e.display,l=o.scroller,s=l.scrollWidth>l.clientWidth,a=l.scrollHeight>l.clientHeight;if(n&&s||i&&a){if(i&&Ml&&ml)e:for(var u=t.target,c=o.view;u!=l;u=u.parentNode)for(var f=0;f<c.length;f++)if(c[f].node==u){e.display.currentWheelTarget=u;break e}if(n&&!fl&&!wl&&null!=Ls)return i&&a&&qr(e,Math.max(0,l.scrollTop+i*Ls)),Qr(e,Math.max(0,l.scrollLeft+n*Ls)),(!i||i&&a)&&We(t),void(o.wheelStartX=null);if(i&&null!=Ls){var h=i*Ls,d=e.doc.scrollTop,p=d+o.wrapper.clientHeight;h<0?d=Math.max(0,d+h-50):p=Math.min(e.doc.height,p+h+50),On(e,{top:d,bottom:p})}Ss<20&&(null==o.wheelStartX?(o.wheelStartX=l.scrollLeft,o.wheelStartY=l.scrollTop,o.wheelDX=n,o.wheelDY=i,setTimeout(function(){if(null!=o.wheelStartX){var e=l.scrollLeft-o.wheelStartX,t=l.scrollTop-o.wheelStartY,r=t&&o.wheelDY&&t/o.wheelDY||e&&o.wheelDX&&e/o.wheelDX;o.wheelStartX=o.wheelStartY=null,r&&(Ls=(Ls*Ss+r)/(Ss+1),++Ss)}},200)):(o.wheelDX+=n,o.wheelDY+=i))}}function zn(e,t){var r=e[t];e.sort(function(e,t){return P(e.from(),t.from())}),t=h(e,r);for(var n=1;n<e.length;n++){var i=e[n],o=e[n-1];if(P(o.to(),i.from())>=0){var l=B(o.from(),i.from()),s=R(o.to(),i.to()),a=o.empty()?i.from()==i.head:o.from()==o.head;n<=t&&--t,e.splice(--n,2,new Ts(a?s:l,a?l:s))}}return new ks(e,t)}function Rn(e,t){return new ks([new Ts(e,t||e)],0)}function Bn(e){return e.text?E(e.from.line+e.text.length-1,g(e.text).length+(1==e.text.length?e.from.ch:0)):e.to}function Gn(e,t){if(P(e,t.from)<0)return e;if(P(e,t.to)<=0)return Bn(t);var r=e.line+t.text.length-(t.to.line-t.from.line)-1,n=e.ch;return e.line==t.to.line&&(n+=Bn(t).ch-t.to.ch),E(r,n)}function Un(e,t){for(var r=[],n=0;n<e.sel.ranges.length;n++){var i=e.sel.ranges[n];r.push(new Ts(Gn(i.anchor,t),Gn(i.head,t)))}return zn(r,e.sel.primIndex)}function Vn(e,t,r){return e.line==t.line?E(r.line,e.ch-t.ch+r.ch):E(r.line+(e.line-t.line),e.ch)}function Kn(e,t,r){for(var n=[],i=E(e.first,0),o=i,l=0;l<t.length;l++){var s=t[l],a=Vn(s.from,i,o),u=Vn(Bn(s),i,o);if(i=s.to,o=u,"around"==r){var c=e.sel.ranges[l],f=P(c.head,c.anchor)<0;n[l]=new Ts(f?u:a,f?a:u)}else n[l]=new Ts(a,a)}return new ks(n,e.sel.primIndex)}function jn(e){e.doc.mode=Ue(e.options,e.doc.modeOption),Xn(e)}function Xn(e){e.doc.iter(function(e){e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null)}),e.doc.modeFrontier=e.doc.highlightFrontier=e.doc.first,Cn(e,100),e.state.modeGen++,e.curOp&&vn(e)}function Yn(e,t){return 0==t.from.ch&&0==t.to.ch&&""==g(t.text)&&(!e.cm||e.cm.options.wholeLineUpdateBefore)}function _n(e,t,r,n){function i(e){return r?r[e]:null}function o(e,r,i){it(e,r,i,n),bt(e,"change",e,t)}function l(e,t){for(var r=[],o=e;o<t;++o)r.push(new fs(u[o],i(o),n));return r}var s=t.from,a=t.to,u=t.text,c=M(e,s.line),f=M(e,a.line),h=g(u),d=i(u.length-1),p=a.line-s.line;if(t.full)e.insert(0,l(0,u.length)),e.remove(u.length,e.size-u.length);else if(Yn(e,t)){var v=l(0,u.length-1);o(f,f.text,d),p&&e.remove(s.line,p),v.length&&e.insert(s.line,v)}else if(c==f)if(1==u.length)o(c,c.text.slice(0,s.ch)+h+c.text.slice(a.ch),d);else{var m=l(1,u.length-1);m.push(new fs(h+c.text.slice(a.ch),d,n)),o(c,c.text.slice(0,s.ch)+u[0],i(0)),e.insert(s.line+1,m)}else if(1==u.length)o(c,c.text.slice(0,s.ch)+u[0]+f.text.slice(a.ch),i(0)),e.remove(s.line+1,p);else{o(c,c.text.slice(0,s.ch)+u[0],i(0)),o(f,h+f.text.slice(a.ch),d);var y=l(1,u.length-1);p>1&&e.remove(s.line+1,p-1),e.insert(s.line+1,y)}bt(e,"change",e,t)}function $n(e,t,r){function n(e,i,o){if(e.linked)for(var l=0;l<e.linked.length;++l){var s=e.linked[l];if(s.doc!=i){var a=o&&s.sharedHist;r&&!a||(t(s.doc,a),n(s.doc,e,a))}}}n(e,null,!0)}function qn(e,t){if(t.cm)throw new Error("This document is already in use.");e.doc=t,t.cm=e,Cr(e),jn(e),Zn(e),e.options.lineWrapping||we(e),e.options.mode=t.modeOption,vn(e)}function Zn(e){("rtl"==e.doc.direction?s:Fl)(e.display.lineDiv,"CodeMirror-rtl")}function Qn(e){hn(e,function(){Zn(e),vn(e)})}function Jn(e){this.done=[],this.undone=[],this.undoDepth=1/0,this.lastModTime=this.lastSelTime=0,this.lastOp=this.lastSelOp=null,this.lastOrigin=this.lastSelOrigin=null,this.generation=this.maxGeneration=e||1}function ei(e,t){var r={from:z(t.from),to:Bn(t),text:N(e,t.from,t.to)};return si(e,r,t.from.line,t.to.line+1),$n(e,function(e){return si(e,r,t.from.line,t.to.line+1)},!0),r}function ti(e){for(;e.length&&g(e).ranges;)e.pop()}function ri(e,t){return t?(ti(e.done),g(e.done)):e.done.length&&!g(e.done).ranges?g(e.done):e.done.length>1&&!e.done[e.done.length-2].ranges?(e.done.pop(),g(e.done)):void 0}function ni(e,t,r,n){var i=e.history;i.undone.length=0;var o,l,s=+new Date;if((i.lastOp==n||i.lastOrigin==t.origin&&t.origin&&("+"==t.origin.charAt(0)&&e.cm&&i.lastModTime>s-e.cm.options.historyEventDelay||"*"==t.origin.charAt(0)))&&(o=ri(i,i.lastOp==n)))l=g(o.changes),0==P(t.from,t.to)&&0==P(t.from,l.to)?l.to=Bn(t):o.changes.push(ei(e,t));else{var a=g(i.done);for(a&&a.ranges||li(e.sel,i.done),o={changes:[ei(e,t)],generation:i.generation},i.done.push(o);i.done.length>i.undoDepth;)i.done.shift(),i.done[0].ranges||i.done.shift()}i.done.push(r),i.generation=++i.maxGeneration,i.lastModTime=i.lastSelTime=s,i.lastOp=i.lastSelOp=n,i.lastOrigin=i.lastSelOrigin=t.origin,l||Te(e,"historyAdded")}function ii(e,t,r,n){var i=t.charAt(0);return"*"==i||"+"==i&&r.ranges.length==n.ranges.length&&r.somethingSelected()==n.somethingSelected()&&new Date-e.history.lastSelTime<=(e.cm?e.cm.options.historyEventDelay:500)}function oi(e,t,r,n){var i=e.history,o=n&&n.origin;r==i.lastSelOp||o&&i.lastSelOrigin==o&&(i.lastModTime==i.lastSelTime&&i.lastOrigin==o||ii(e,o,g(i.done),t))?i.done[i.done.length-1]=t:li(t,i.done),i.lastSelTime=+new Date,i.lastSelOrigin=o,i.lastSelOp=r,n&&!1!==n.clearRedo&&ti(i.undone)}function li(e,t){var r=g(t);r&&r.ranges&&r.equals(e)||t.push(e)}function si(e,t,r,n){var i=t["spans_"+e.id],o=0;e.iter(Math.max(e.first,r),Math.min(e.first+e.size,n),function(r){r.markedSpans&&((i||(i=t["spans_"+e.id]={}))[o]=r.markedSpans),++o})}function ai(e){if(!e)return null;for(var t,r=0;r<e.length;++r)e[r].marker.explicitlyCleared?t||(t=e.slice(0,r)):t&&t.push(e[r]);return t?t.length?t:null:e}function ui(e,t){var r=t["spans_"+e.id];if(!r)return null;for(var n=[],i=0;i<t.text.length;++i)n.push(ai(r[i]));return n}function ci(e,t){var r=ui(e,t),n=J(e,t);if(!r)return n;if(!n)return r;for(var i=0;i<r.length;++i){var o=r[i],l=n[i];if(o&&l)e:for(var s=0;s<l.length;++s){for(var a=l[s],u=0;u<o.length;++u)if(o[u].marker==a.marker)continue e;o.push(a)}else l&&(r[i]=l)}return r}function fi(e,t,r){for(var n=[],i=0;i<e.length;++i){var o=e[i];if(o.ranges)n.push(r?ks.prototype.deepCopy.call(o):o);else{var l=o.changes,s=[];n.push({changes:s});for(var a=0;a<l.length;++a){var u=l[a],c=void 0;if(s.push({from:u.from,to:u.to,text:u.text}),t)for(var f in u)(c=f.match(/^spans_(\d+)$/))&&h(t,Number(c[1]))>-1&&(g(s)[f]=u[f],delete u[f])}}}return n}function hi(e,t,r,n){if(n){var i=e.anchor;if(r){var o=P(t,i)<0;o!=P(r,i)<0?(i=t,t=r):o!=P(t,r)<0&&(t=r)}return new Ts(i,t)}return new Ts(r||t,t)}function di(e,t,r,n,i){null==i&&(i=e.cm&&(e.cm.display.shift||e.extend)),bi(e,new ks([hi(e.sel.primary(),t,r,i)],0),n)}function pi(e,t,r){for(var n=[],i=e.cm&&(e.cm.display.shift||e.extend),o=0;o<e.sel.ranges.length;o++)n[o]=hi(e.sel.ranges[o],t[o],null,i);bi(e,zn(n,e.sel.primIndex),r)}function gi(e,t,r,n){var i=e.sel.ranges.slice(0);i[t]=r,bi(e,zn(i,e.sel.primIndex),n)}function vi(e,t,r,n){bi(e,Rn(t,r),n)}function mi(e,t,r){var n={ranges:t.ranges,update:function(t){var r=this;this.ranges=[];for(var n=0;n<t.length;n++)r.ranges[n]=new Ts(U(e,t[n].anchor),U(e,t[n].head))},origin:r&&r.origin};return Te(e,"beforeSelectionChange",e,n),e.cm&&Te(e.cm,"beforeSelectionChange",e.cm,n),n.ranges!=t.ranges?zn(n.ranges,n.ranges.length-1):t}function yi(e,t,r){var n=e.history.done,i=g(n);i&&i.ranges?(n[n.length-1]=t,wi(e,t,r)):bi(e,t,r)}function bi(e,t,r){wi(e,t,r),oi(e,e.sel,e.cm?e.cm.curOp.id:NaN,r)}function wi(e,t,r){(Oe(e,"beforeSelectionChange")||e.cm&&Oe(e.cm,"beforeSelectionChange"))&&(t=mi(e,t,r)),xi(e,Si(e,t,r&&r.bias||(P(t.primary().head,e.sel.primary().head)<0?-1:1),!0)),r&&!1===r.scroll||!e.cm||jr(e.cm)}function xi(e,t){t.equals(e.sel)||(e.sel=t,e.cm&&(e.cm.curOp.updateInput=e.cm.curOp.selectionChanged=!0,Ne(e.cm)),bt(e,"cursorActivity",e))}function Ci(e){xi(e,Si(e,e.sel,null,!1))}function Si(e,t,r,n){for(var i,o=0;o<t.ranges.length;o++){var l=t.ranges[o],s=t.ranges.length==e.sel.ranges.length&&e.sel.ranges[o],a=ki(e,l.anchor,s&&s.anchor,r,n),u=ki(e,l.head,s&&s.head,r,n);(i||a!=l.anchor||u!=l.head)&&(i||(i=t.ranges.slice(0,o)),i[o]=new Ts(a,u))}return i?zn(i,t.primIndex):t}function Li(e,t,r,n,i){var o=M(e,t.line);if(o.markedSpans)for(var l=0;l<o.markedSpans.length;++l){var s=o.markedSpans[l],a=s.marker;if((null==s.from||(a.inclusiveLeft?s.from<=t.ch:s.from<t.ch))&&(null==s.to||(a.inclusiveRight?s.to>=t.ch:s.to>t.ch))){if(i&&(Te(a,"beforeCursorEnter"),a.explicitlyCleared)){if(o.markedSpans){--l;continue}break}if(!a.atomic)continue;if(r){var u=a.find(n<0?1:-1),c=void 0;if((n<0?a.inclusiveRight:a.inclusiveLeft)&&(u=Ti(e,u,-n,u&&u.line==t.line?o:null)),u&&u.line==t.line&&(c=P(u,r))&&(n<0?c<0:c>0))return Li(e,u,t,n,i)}var f=a.find(n<0?-1:1);return(n<0?a.inclusiveLeft:a.inclusiveRight)&&(f=Ti(e,f,n,f.line==t.line?o:null)),f?Li(e,f,t,n,i):null}}return t}function ki(e,t,r,n,i){var o=n||1,l=Li(e,t,r,o,i)||!i&&Li(e,t,r,o,!0)||Li(e,t,r,-o,i)||!i&&Li(e,t,r,-o,!0);return l||(e.cantEdit=!0,E(e.first,0))}function Ti(e,t,r,n){return r<0&&0==t.ch?t.line>e.first?U(e,E(t.line-1)):null:r>0&&t.ch==(n||M(e,t.line)).text.length?t.line<e.first+e.size-1?E(t.line+1,0):null:new E(t.line,t.ch+r)}function Mi(e){e.setSelection(E(e.firstLine(),0),E(e.lastLine()),Gl)}function Ni(e,t,r){var n={canceled:!1,from:t.from,to:t.to,text:t.text,origin:t.origin,cancel:function(){return n.canceled=!0}};return r&&(n.update=function(t,r,i,o){t&&(n.from=U(e,t)),r&&(n.to=U(e,r)),i&&(n.text=i),void 0!==o&&(n.origin=o)}),Te(e,"beforeChange",e,n),e.cm&&Te(e.cm,"beforeChange",e.cm,n),n.canceled?null:{from:n.from,to:n.to,text:n.text,origin:n.origin}}function Oi(e,t,r){if(e.cm){if(!e.cm.curOp)return dn(e.cm,Oi)(e,t,r);if(e.cm.state.suppressEdits)return}if(!(Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"))||(t=Ni(e,t,!0))){var n=Yl&&!r&&te(e,t.from,t.to);if(n)for(var i=n.length-1;i>=0;--i)Ai(e,{from:n[i].from,to:n[i].to,text:i?[""]:t.text,origin:t.origin});else Ai(e,t)}}function Ai(e,t){if(1!=t.text.length||""!=t.text[0]||0!=P(t.from,t.to)){var r=Un(e,t);ni(e,t,r,e.cm?e.cm.curOp.id:NaN),Hi(e,t,r,J(e,t));var n=[];$n(e,function(e,r){r||-1!=h(n,e.history)||(zi(e.history,t),n.push(e.history)),Hi(e,t,null,J(e,t))})}}function Wi(e,t,r){if(!e.cm||!e.cm.state.suppressEdits||r){for(var n,i=e.history,o=e.sel,l="undo"==t?i.done:i.undone,s="undo"==t?i.undone:i.done,a=0;a<l.length&&(n=l[a],r?!n.ranges||n.equals(e.sel):n.ranges);a++);if(a!=l.length){for(i.lastOrigin=i.lastSelOrigin=null;(n=l.pop()).ranges;){if(li(n,s),r&&!n.equals(e.sel))return void bi(e,n,{clearRedo:!1});o=n}var u=[];li(o,s),s.push({changes:u,generation:i.generation}),i.generation=n.generation||++i.maxGeneration;for(var c=Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"),f=n.changes.length-1;f>=0;--f){var d=function(r){var i=n.changes[r];if(i.origin=t,c&&!Ni(e,i,!1))return l.length=0,{};u.push(ei(e,i));var o=r?Un(e,i):g(l);Hi(e,i,o,ci(e,i)),!r&&e.cm&&e.cm.scrollIntoView({from:i.from,to:Bn(i)});var s=[];$n(e,function(e,t){t||-1!=h(s,e.history)||(zi(e.history,i),s.push(e.history)),Hi(e,i,null,ci(e,i))})}(f);if(d)return d.v}}}}function Di(e,t){if(0!=t&&(e.first+=t,e.sel=new ks(v(e.sel.ranges,function(e){return new Ts(E(e.anchor.line+t,e.anchor.ch),E(e.head.line+t,e.head.ch))}),e.sel.primIndex),e.cm)){vn(e.cm,e.first,e.first-t,t);for(var r=e.cm.display,n=r.viewFrom;n<r.viewTo;n++)mn(e.cm,n,"gutter")}}function Hi(e,t,r,n){if(e.cm&&!e.cm.curOp)return dn(e.cm,Hi)(e,t,r,n);if(t.to.line<e.first)Di(e,t.text.length-1-(t.to.line-t.from.line));else if(!(t.from.line>e.lastLine())){if(t.from.line<e.first){var i=t.text.length-1-(e.first-t.from.line);Di(e,i),t={from:E(e.first,0),to:E(t.to.line+i,t.to.ch),text:[g(t.text)],origin:t.origin}}var o=e.lastLine();t.to.line>o&&(t={from:t.from,to:E(o,M(e,o).text.length),text:[t.text[0]],origin:t.origin}),t.removed=N(e,t.from,t.to),r||(r=Un(e,t)),e.cm?Fi(e.cm,t,n):_n(e,t,n),wi(e,r,Gl)}}function Fi(e,t,r){var n=e.doc,i=e.display,o=t.from,l=t.to,s=!1,a=o.line;e.options.lineWrapping||(a=W(fe(M(n,o.line))),n.iter(a,l.line+1,function(e){if(e==i.maxLine)return s=!0,!0})),n.sel.contains(t.from,t.to)>-1&&Ne(e),_n(n,t,r,xr(e)),e.options.lineWrapping||(n.iter(a,o.line+t.text.length,function(e){var t=be(e);t>i.maxLineLength&&(i.maxLine=e,i.maxLineLength=t,i.maxLineChanged=!0,s=!1)}),s&&(e.curOp.updateMaxLine=!0)),nt(n,o.line),Cn(e,400);var u=t.text.length-(l.line-o.line)-1;t.full?vn(e):o.line!=l.line||1!=t.text.length||Yn(e.doc,t)?vn(e,o.line,l.line+1,u):mn(e,o.line,"text");var c=Oe(e,"changes"),f=Oe(e,"change");if(f||c){var h={from:o,to:l,text:t.text,removed:t.removed,origin:t.origin};f&&bt(e,"change",e,h),c&&(e.curOp.changeObjs||(e.curOp.changeObjs=[])).push(h)}e.display.selForContextMenu=null}function Ei(e,t,r,n,i){if(n||(n=r),P(n,r)<0){var o;r=(o=[n,r])[0],n=o[1]}"string"==typeof t&&(t=e.splitLines(t)),Oi(e,{from:r,to:n,text:t,origin:i})}function Pi(e,t,r,n){r<e.line?e.line+=n:t<e.line&&(e.line=t,e.ch=0)}function Ii(e,t,r,n){for(var i=0;i<e.length;++i){var o=e[i],l=!0;if(o.ranges){o.copied||((o=e[i]=o.deepCopy()).copied=!0);for(var s=0;s<o.ranges.length;s++)Pi(o.ranges[s].anchor,t,r,n),Pi(o.ranges[s].head,t,r,n)}else{for(var a=0;a<o.changes.length;++a){var u=o.changes[a];if(r<u.from.line)u.from=E(u.from.line+n,u.from.ch),u.to=E(u.to.line+n,u.to.ch);else if(t<=u.to.line){l=!1;break}}l||(e.splice(0,i+1),i=0)}}}function zi(e,t){var r=t.from.line,n=t.to.line,i=t.text.length-(n-r)-1;Ii(e.done,r,n,i),Ii(e.undone,r,n,i)}function Ri(e,t,r,n){var i=t,o=t;return"number"==typeof t?o=M(e,G(e,t)):i=W(t),null==i?null:(n(o,i)&&e.cm&&mn(e.cm,i,r),o)}function Bi(e){var t=this;this.lines=e,this.parent=null;for(var r=0,n=0;n<e.length;++n)e[n].parent=t,r+=e[n].height;this.height=r}function Gi(e){var t=this;this.children=e;for(var r=0,n=0,i=0;i<e.length;++i){var o=e[i];r+=o.chunkSize(),n+=o.height,o.parent=t}this.size=r,this.height=n,this.parent=null}function Ui(e,t,r){ye(t)<(e.curOp&&e.curOp.scrollTop||e.doc.scrollTop)&&Kr(e,r)}function Vi(e,t,r,n){var i=new Ms(e,r,n),o=e.cm;return o&&i.noHScroll&&(o.display.alignWidgets=!0),Ri(e,t,"widget",function(t){var r=t.widgets||(t.widgets=[]);if(null==i.insertAt?r.push(i):r.splice(Math.min(r.length-1,Math.max(0,i.insertAt)),0,i),i.line=t,o&&!ve(e,t)){var n=ye(t)<e.scrollTop;A(t,t.height+Ht(i)),n&&Kr(o,i.height),o.curOp.forceUpdate=!0}return!0}),bt(o,"lineWidgetAdded",o,i,"number"==typeof t?t:W(t)),i}function Ki(e,t,r,n,o){if(n&&n.shared)return ji(e,t,r,n,o);if(e.cm&&!e.cm.curOp)return dn(e.cm,Ki)(e,t,r,n,o);var l=new Os(e,o),s=P(t,r);if(n&&c(n,l,!1),s>0||0==s&&!1!==l.clearWhenEmpty)return l;if(l.replacedWith&&(l.collapsed=!0,l.widgetNode=i("span",[l.replacedWith],"CodeMirror-widget"),n.handleMouseEvents||l.widgetNode.setAttribute("cm-ignore-events","true"),n.insertLeft&&(l.widgetNode.insertLeft=!0)),l.collapsed){if(ce(e,t.line,t,r,l)||t.line!=r.line&&ce(e,r.line,t,r,l))throw new Error("Inserting collapsed marker partially overlapping an existing one");X()}l.addToHistory&&ni(e,{from:t,to:r,origin:"markText"},e.sel,NaN);var a,u=t.line,f=e.cm;if(e.iter(u,r.line+1,function(e){f&&l.collapsed&&!f.options.lineWrapping&&fe(e)==f.display.maxLine&&(a=!0),l.collapsed&&u!=t.line&&A(e,0),q(e,new Y(l,u==t.line?t.ch:null,u==r.line?r.ch:null)),++u}),l.collapsed&&e.iter(t.line,r.line+1,function(t){ve(e,t)&&A(t,0)}),l.clearOnEnter&&Ql(l,"beforeCursorEnter",function(){return l.clear()}),l.readOnly&&(j(),(e.history.done.length||e.history.undone.length)&&e.clearHistory()),l.collapsed&&(l.id=++Ns,l.atomic=!0),f){if(a&&(f.curOp.updateMaxLine=!0),l.collapsed)vn(f,t.line,r.line+1);else if(l.className||l.title||l.startStyle||l.endStyle||l.css)for(var h=t.line;h<=r.line;h++)mn(f,h,"text");l.atomic&&Ci(f.doc),bt(f,"markerAdded",f,l)}return l}function ji(e,t,r,n,i){(n=c(n)).shared=!1;var o=[Ki(e,t,r,n,i)],l=o[0],s=n.widgetNode;return $n(e,function(e){s&&(n.widgetNode=s.cloneNode(!0)),o.push(Ki(e,U(e,t),U(e,r),n,i));for(var a=0;a<e.linked.length;++a)if(e.linked[a].isParent)return;l=g(o)}),new As(o,l)}function Xi(e){return e.findMarks(E(e.first,0),e.clipPos(E(e.lastLine())),function(e){return e.parent})}function Yi(e,t){for(var r=0;r<t.length;r++){var n=t[r],i=n.find(),o=e.clipPos(i.from),l=e.clipPos(i.to);if(P(o,l)){var s=Ki(e,o,l,n.primary,n.primary.type);n.markers.push(s),s.parent=n}}}function _i(e){for(var t=0;t<e.length;t++)!function(t){var r=e[t],n=[r.primary.doc];$n(r.primary.doc,function(e){return n.push(e)});for(var i=0;i<r.markers.length;i++){var o=r.markers[i];-1==h(n,o.doc)&&(o.parent=null,r.markers.splice(i--,1))}}(t)}function $i(e){var t=this;if(Qi(t),!Me(t,e)&&!Ft(t.display,e)){We(e),gl&&(Hs=+new Date);var r=Sr(t,e,!0),n=e.dataTransfer.files;if(r&&!t.isReadOnly())if(n&&n.length&&window.FileReader&&window.File)for(var i=n.length,o=Array(i),l=0,s=0;s<i;++s)!function(e,n){if(!t.options.allowDropFileTypes||-1!=h(t.options.allowDropFileTypes,e.type)){var s=new FileReader;s.onload=dn(t,function(){var e=s.result;if(/[\x00-\x08\x0e-\x1f]{2}/.test(e)&&(e=""),o[n]=e,++l==i){var a={from:r=U(t.doc,r),to:r,text:t.doc.splitLines(o.join(t.doc.lineSeparator())),origin:"paste"};Oi(t.doc,a),yi(t.doc,Rn(r,Bn(a)))}}),s.readAsText(e)}}(n[s],s);else{if(t.state.draggingText&&t.doc.sel.contains(r)>-1)return t.state.draggingText(e),void setTimeout(function(){return t.display.input.focus()},20);try{var a=e.dataTransfer.getData("Text");if(a){var u;if(t.state.draggingText&&!t.state.draggingText.copy&&(u=t.listSelections()),wi(t.doc,Rn(r,r)),u)for(var c=0;c<u.length;++c)Ei(t.doc,"",u[c].anchor,u[c].head,"drag");t.replaceSelection(a,"around","paste"),t.display.input.focus()}}catch(e){}}}}function qi(e,t){if(gl&&(!e.state.draggingText||+new Date-Hs<100))Fe(t);else if(!Me(e,t)&&!Ft(e.display,t)&&(t.dataTransfer.setData("Text",e.getSelection()),t.dataTransfer.effectAllowed="copyMove",t.dataTransfer.setDragImage&&!xl)){var r=n("img",null,null,"position: fixed; left: 0; top: 0;");r.src="data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==",wl&&(r.width=r.height=1,e.display.wrapper.appendChild(r),r._top=r.offsetTop),t.dataTransfer.setDragImage(r,0,0),wl&&r.parentNode.removeChild(r)}}function Zi(e,t){var i=Sr(e,t);if(i){var o=document.createDocumentFragment();Mr(e,i,o),e.display.dragCursor||(e.display.dragCursor=n("div",null,"CodeMirror-cursors CodeMirror-dragcursors"),e.display.lineSpace.insertBefore(e.display.dragCursor,e.display.cursorDiv)),r(e.display.dragCursor,o)}}function Qi(e){e.display.dragCursor&&(e.display.lineSpace.removeChild(e.display.dragCursor),e.display.dragCursor=null)}function Ji(e){if(document.getElementsByClassName)for(var t=document.getElementsByClassName("CodeMirror"),r=0;r<t.length;r++){var n=t[r].CodeMirror;n&&e(n)}}function eo(){Fs||(to(),Fs=!0)}function to(){var e;Ql(window,"resize",function(){null==e&&(e=setTimeout(function(){e=null,Ji(ro)},100))}),Ql(window,"blur",function(){return Ji(Fr)})}function ro(e){var t=e.display;t.lastWrapHeight==t.wrapper.clientHeight&&t.lastWrapWidth==t.wrapper.clientWidth||(t.cachedCharWidth=t.cachedTextHeight=t.cachedPaddingH=null,t.scrollbarsClipped=!1,e.setSize())}function no(e){var t=e.split(/-(?!$)/);e=t[t.length-1];for(var r,n,i,o,l=0;l<t.length-1;l++){var s=t[l];if(/^(cmd|meta|m)$/i.test(s))o=!0;else if(/^a(lt)?$/i.test(s))r=!0;else if(/^(c|ctrl|control)$/i.test(s))n=!0;else{if(!/^s(hift)?$/i.test(s))throw new Error("Unrecognized modifier name: "+s);i=!0}}return r&&(e="Alt-"+e),n&&(e="Ctrl-"+e),o&&(e="Cmd-"+e),i&&(e="Shift-"+e),e}function io(e){var t={};for(var r in e)if(e.hasOwnProperty(r)){var n=e[r];if(/^(name|fallthrough|(de|at)tach)$/.test(r))continue;if("..."==n){delete e[r];continue}for(var i=v(r.split(" "),no),o=0;o<i.length;o++){var l=void 0,s=void 0;o==i.length-1?(s=i.join(" "),l=n):(s=i.slice(0,o+1).join(" "),l="...");var a=t[s];if(a){if(a!=l)throw new Error("Inconsistent bindings for "+s)}else t[s]=l}delete e[r]}for(var u in t)e[u]=t[u];return e}function oo(e,t,r,n){var i=(t=uo(t)).call?t.call(e,n):t[e];if(!1===i)return"nothing";if("..."===i)return"multi";if(null!=i&&r(i))return"handled";if(t.fallthrough){if("[object Array]"!=Object.prototype.toString.call(t.fallthrough))return oo(e,t.fallthrough,r,n);for(var o=0;o<t.fallthrough.length;o++){var l=oo(e,t.fallthrough[o],r,n);if(l)return l}}}function lo(e){var t="string"==typeof e?e:Es[e.keyCode];return"Ctrl"==t||"Alt"==t||"Shift"==t||"Mod"==t}function so(e,t,r){var n=e;return t.altKey&&"Alt"!=n&&(e="Alt-"+e),(Dl?t.metaKey:t.ctrlKey)&&"Ctrl"!=n&&(e="Ctrl-"+e),(Dl?t.ctrlKey:t.metaKey)&&"Cmd"!=n&&(e="Cmd-"+e),!r&&t.shiftKey&&"Shift"!=n&&(e="Shift-"+e),e}function ao(e,t){if(wl&&34==e.keyCode&&e.char)return!1;var r=Es[e.keyCode];return null!=r&&!e.altGraphKey&&so(r,e,t)}function uo(e){return"string"==typeof e?Rs[e]:e}function co(e,t){for(var r=e.doc.sel.ranges,n=[],i=0;i<r.length;i++){for(var o=t(r[i]);n.length&&P(o.from,g(n).to)<=0;){var l=n.pop();if(P(l.from,o.from)<0){o.from=l.from;break}}n.push(o)}hn(e,function(){for(var t=n.length-1;t>=0;t--)Ei(e.doc,"",n[t].from,n[t].to,"+delete");jr(e)})}function fo(e,t,r){var n=L(e.text,t+r,r);return n<0||n>e.text.length?null:n}function ho(e,t,r){var n=fo(e,t.ch,r);return null==n?null:new E(t.line,n,r<0?"after":"before")}function po(e,t,r,n,i){if(e){var o=Se(r,t.doc.direction);if(o){var l,s=i<0?g(o):o[0],a=i<0==(1==s.level)?"after":"before";if(s.level>0){var u=Xt(t,r);l=i<0?r.text.length-1:0;var c=Yt(t,u,l).top;l=k(function(e){return Yt(t,u,e).top==c},i<0==(1==s.level)?s.from:s.to-1,l),"before"==a&&(l=fo(r,l,1))}else l=i<0?s.to:s.from;return new E(n,l,a)}}return new E(n,i<0?r.text.length:0,i<0?"before":"after")}function go(e,t,r,n){var i=Se(t,e.doc.direction);if(!i)return ho(t,r,n);r.ch>=t.text.length?(r.ch=t.text.length,r.sticky="before"):r.ch<=0&&(r.ch=0,r.sticky="after");var o=Ce(i,r.ch,r.sticky),l=i[o];if("ltr"==e.doc.direction&&l.level%2==0&&(n>0?l.to>r.ch:l.from<r.ch))return ho(t,r,n);var s,a=function(e,r){return fo(t,e instanceof E?e.ch:e,r)},u=function(r){return e.options.lineWrapping?(s=s||Xt(e,t),hr(e,t,s,r)):{begin:0,end:t.text.length}},c=u("before"==r.sticky?a(r,-1):r.ch);if("rtl"==e.doc.direction||1==l.level){var f=1==l.level==n<0,h=a(r,f?1:-1);if(null!=h&&(f?h<=l.to&&h<=c.end:h>=l.from&&h>=c.begin)){var d=f?"before":"after";return new E(r.line,h,d)}}var p=function(e,t,n){for(var o=function(e,t){return t?new E(r.line,a(e,1),"before"):new E(r.line,e,"after")};e>=0&&e<i.length;e+=t){var l=i[e],s=t>0==(1!=l.level),u=s?n.begin:a(n.end,-1);if(l.from<=u&&u<l.to)return o(u,s);if(u=s?l.from:a(l.to,-1),n.begin<=u&&u<n.end)return o(u,s)}},g=p(o+n,n,c);if(g)return g;var v=n>0?c.end:a(c.begin,-1);return null==v||n>0&&v==t.text.length||!(g=p(n>0?0:i.length-1,n,u(v)))?null:g}function vo(e,t){var r=M(e.doc,t),n=fe(r);return n!=r&&(t=W(n)),po(!0,e,n,t,1)}function mo(e,t){var r=M(e.doc,t),n=he(r);return n!=r&&(t=W(n)),po(!0,e,r,t,-1)}function yo(e,t){var r=vo(e,t.line),n=M(e.doc,r.line),i=Se(n,e.doc.direction);if(!i||0==i[0].level){var o=Math.max(0,n.text.search(/\S/)),l=t.line==r.line&&t.ch<=o&&t.ch;return E(r.line,l?0:o,r.sticky)}return r}function bo(e,t,r){if("string"==typeof t&&!(t=Bs[t]))return!1;e.display.input.ensurePolled();var n=e.display.shift,i=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),r&&(e.display.shift=!1),i=t(e)!=Bl}finally{e.display.shift=n,e.state.suppressEdits=!1}return i}function wo(e,t,r){for(var n=0;n<e.state.keyMaps.length;n++){var i=oo(t,e.state.keyMaps[n],r,e);if(i)return i}return e.options.extraKeys&&oo(t,e.options.extraKeys,r,e)||oo(t,e.options.keyMap,r,e)}function xo(e,t,r,n){var i=e.state.keySeq;if(i){if(lo(t))return"handled";Gs.set(50,function(){e.state.keySeq==i&&(e.state.keySeq=null,e.display.input.reset())}),t=i+" "+t}var o=wo(e,t,n);return"multi"==o&&(e.state.keySeq=t),"handled"==o&&bt(e,"keyHandled",e,t,r),"handled"!=o&&"multi"!=o||(We(r),Ar(e)),i&&!o&&/\'$/.test(t)?(We(r),!0):!!o}function Co(e,t){var r=ao(t,!0);return!!r&&(t.shiftKey&&!e.state.keySeq?xo(e,"Shift-"+r,t,function(t){return bo(e,t,!0)})||xo(e,r,t,function(t){if("string"==typeof t?/^go[A-Z]/.test(t):t.motion)return bo(e,t)}):xo(e,r,t,function(t){return bo(e,t)}))}function So(e,t,r){return xo(e,"'"+r+"'",t,function(t){return bo(e,t,!0)})}function Lo(e){var t=this;if(t.curOp.focus=l(),!Me(t,e)){gl&&vl<11&&27==e.keyCode&&(e.returnValue=!1);var r=e.keyCode;t.display.shift=16==r||e.shiftKey;var n=Co(t,e);wl&&(Us=n?r:null,!n&&88==r&&!rs&&(Ml?e.metaKey:e.ctrlKey)&&t.replaceSelection("",null,"cut")),18!=r||/\bCodeMirror-crosshair\b/.test(t.display.lineDiv.className)||ko(t)}}function ko(e){function t(e){18!=e.keyCode&&e.altKey||(Fl(r,"CodeMirror-crosshair"),ke(document,"keyup",t),ke(document,"mouseover",t))}var r=e.display.lineDiv;s(r,"CodeMirror-crosshair"),Ql(document,"keyup",t),Ql(document,"mouseover",t)}function To(e){16==e.keyCode&&(this.doc.sel.shift=!1),Me(this,e)}function Mo(e){var t=this;if(!(Ft(t.display,e)||Me(t,e)||e.ctrlKey&&!e.altKey||Ml&&e.metaKey)){var r=e.keyCode,n=e.charCode;if(wl&&r==Us)return Us=null,void We(e);if(!wl||e.which&&!(e.which<10)||!Co(t,e)){var i=String.fromCharCode(null==n?r:n);"\b"!=i&&(So(t,e,i)||t.display.input.onKeyPress(e))}}}function No(e,t){var r=+new Date;return js&&js.compare(r,e,t)?(Ks=js=null,"triple"):Ks&&Ks.compare(r,e,t)?(js=new Vs(r,e,t),Ks=null,"double"):(Ks=new Vs(r,e,t),js=null,"single")}function Oo(e){var t=this,r=t.display;if(!(Me(t,e)||r.activeTouch&&r.input.supportsTouch()))if(r.input.ensurePolled(),r.shift=e.shiftKey,Ft(r,e))ml||(r.scroller.draggable=!1,setTimeout(function(){return r.scroller.draggable=!0},100));else if(!zo(t,e)){var n=Sr(t,e),i=Pe(e),o=n?No(n,i):"single";window.focus(),1==i&&t.state.selectingText&&t.state.selectingText(e),n&&Ao(t,i,n,o,e)||(1==i?n?Do(t,n,o,e):Ee(e)==r.scroller&&We(e):2==i?(n&&di(t.doc,n),setTimeout(function(){return r.input.focus()},20)):3==i&&(Hl?Ro(t,e):Dr(t)))}}function Ao(e,t,r,n,i){var o="Click";return"double"==n?o="Double"+o:"triple"==n&&(o="Triple"+o),o=(1==t?"Left":2==t?"Middle":"Right")+o,xo(e,so(o,i),i,function(t){if("string"==typeof t&&(t=Bs[t]),!t)return!1;var n=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),n=t(e,r)!=Bl}finally{e.state.suppressEdits=!1}return n})}function Wo(e,t,r){var n=e.getOption("configureMouse"),i=n?n(e,t,r):{};if(null==i.unit){var o=Nl?r.shiftKey&&r.metaKey:r.altKey;i.unit=o?"rectangle":"single"==t?"char":"double"==t?"word":"line"}return(null==i.extend||e.doc.extend)&&(i.extend=e.doc.extend||r.shiftKey),null==i.addNew&&(i.addNew=Ml?r.metaKey:r.ctrlKey),null==i.moveOnDrag&&(i.moveOnDrag=!(Ml?r.altKey:r.ctrlKey)),i}function Do(e,t,r,n){gl?setTimeout(u(Wr,e),0):e.curOp.focus=l();var i,o=Wo(e,r,n),s=e.doc.sel;e.options.dragDrop&&Jl&&!e.isReadOnly()&&"single"==r&&(i=s.contains(t))>-1&&(P((i=s.ranges[i]).from(),t)<0||t.xRel>0)&&(P(i.to(),t)>0||t.xRel<0)?Ho(e,n,t,o):Eo(e,n,t,o)}function Ho(e,t,r,n){var i=e.display,o=!1,l=dn(e,function(t){ml&&(i.scroller.draggable=!1),e.state.draggingText=!1,ke(document,"mouseup",l),ke(document,"mousemove",s),ke(i.scroller,"dragstart",a),ke(i.scroller,"drop",l),o||(We(t),n.addNew||di(e.doc,r,null,null,n.extend),ml||gl&&9==vl?setTimeout(function(){document.body.focus(),i.input.focus()},20):i.input.focus())}),s=function(e){o=o||Math.abs(t.clientX-e.clientX)+Math.abs(t.clientY-e.clientY)>=10},a=function(){return o=!0};ml&&(i.scroller.draggable=!0),e.state.draggingText=l,l.copy=!n.moveOnDrag,i.scroller.dragDrop&&i.scroller.dragDrop(),Ql(document,"mouseup",l),Ql(document,"mousemove",s),Ql(i.scroller,"dragstart",a),Ql(i.scroller,"drop",l),Dr(e),setTimeout(function(){return i.input.focus()},20)}function Fo(e,t,r){if("char"==r)return new Ts(t,t);if("word"==r)return e.findWordAt(t);if("line"==r)return new Ts(E(t.line,0),U(e.doc,E(t.line+1,0)));var n=r(e,t);return new Ts(n.from,n.to)}function Eo(e,t,r,n){function i(t){if(0!=P(m,t))if(m=t,"rectangle"==n.unit){for(var i=[],o=e.options.tabSize,l=f(M(u,r.line).text,r.ch,o),s=f(M(u,t.line).text,t.ch,o),a=Math.min(l,s),g=Math.max(l,s),v=Math.min(r.line,t.line),y=Math.min(e.lastLine(),Math.max(r.line,t.line));v<=y;v++){var b=M(u,v).text,w=d(b,a,o);a==g?i.push(new Ts(E(v,w),E(v,w))):b.length>w&&i.push(new Ts(E(v,w),E(v,d(b,g,o))))}i.length||i.push(new Ts(r,r)),bi(u,zn(p.ranges.slice(0,h).concat(i),h),{origin:"*mouse",scroll:!1}),e.scrollIntoView(t)}else{var x,C=c,S=Fo(e,t,n.unit),L=C.anchor;P(S.anchor,L)>0?(x=S.head,L=B(C.from(),S.anchor)):(x=S.anchor,L=R(C.to(),S.head));var k=p.ranges.slice(0);k[h]=Po(e,new Ts(U(u,L),x)),bi(u,zn(k,h),Ul)}}function o(t){var r=++b,s=Sr(e,t,!0,"rectangle"==n.unit);if(s)if(0!=P(s,m)){e.curOp.focus=l(),i(s);var c=Ir(a,u);(s.line>=c.to||s.line<c.from)&&setTimeout(dn(e,function(){b==r&&o(t)}),150)}else{var f=t.clientY<y.top?-20:t.clientY>y.bottom?20:0;f&&setTimeout(dn(e,function(){b==r&&(a.scroller.scrollTop+=f,o(t))}),50)}}function s(t){e.state.selectingText=!1,b=1/0,We(t),a.input.focus(),ke(document,"mousemove",w),ke(document,"mouseup",x),u.history.lastSelOrigin=null}var a=e.display,u=e.doc;We(t);var c,h,p=u.sel,g=p.ranges;if(n.addNew&&!n.extend?(h=u.sel.contains(r),c=h>-1?g[h]:new Ts(r,r)):(c=u.sel.primary(),h=u.sel.primIndex),"rectangle"==n.unit)n.addNew||(c=new Ts(r,r)),r=Sr(e,t,!0,!0),h=-1;else{var v=Fo(e,r,n.unit);c=n.extend?hi(c,v.anchor,v.head,n.extend):v}n.addNew?-1==h?(h=g.length,bi(u,zn(g.concat([c]),h),{scroll:!1,origin:"*mouse"})):g.length>1&&g[h].empty()&&"char"==n.unit&&!n.extend?(bi(u,zn(g.slice(0,h).concat(g.slice(h+1)),0),{scroll:!1,origin:"*mouse"}),p=u.sel):gi(u,h,c,Ul):(h=0,bi(u,new ks([c],0),Ul),p=u.sel);var m=r,y=a.wrapper.getBoundingClientRect(),b=0,w=dn(e,function(e){Pe(e)?o(e):s(e)}),x=dn(e,s);e.state.selectingText=x,Ql(document,"mousemove",w),Ql(document,"mouseup",x)}function Po(e,t){var r=t.anchor,n=t.head,i=M(e.doc,r.line);if(0==P(r,n)&&r.sticky==n.sticky)return t;var o=Se(i);if(!o)return t;var l=Ce(o,r.ch,r.sticky),s=o[l];if(s.from!=r.ch&&s.to!=r.ch)return t;var a=l+(s.from==r.ch==(1!=s.level)?0:1);if(0==a||a==o.length)return t;var u;if(n.line!=r.line)u=(n.line-r.line)*("ltr"==e.doc.direction?1:-1)>0;else{var c=Ce(o,n.ch,n.sticky),f=c-l||(n.ch-r.ch)*(1==s.level?-1:1);u=c==a-1||c==a?f<0:f>0}var h=o[a+(u?-1:0)],d=u==(1==h.level),p=d?h.from:h.to,g=d?"after":"before";return r.ch==p&&r.sticky==g?t:new Ts(new E(r.line,p,g),n)}function Io(e,t,r,n){var i,o;if(t.touches)i=t.touches[0].clientX,o=t.touches[0].clientY;else try{i=t.clientX,o=t.clientY}catch(t){return!1}if(i>=Math.floor(e.display.gutters.getBoundingClientRect().right))return!1;n&&We(t);var l=e.display,s=l.lineDiv.getBoundingClientRect();if(o>s.bottom||!Oe(e,r))return He(t);o-=s.top-l.viewOffset;for(var a=0;a<e.options.gutters.length;++a){var u=l.gutters.childNodes[a];if(u&&u.getBoundingClientRect().right>=i)return Te(e,r,e,D(e.doc,o),e.options.gutters[a],t),He(t)}}function zo(e,t){return Io(e,t,"gutterClick",!0)}function Ro(e,t){Ft(e.display,t)||Bo(e,t)||Me(e,t,"contextmenu")||e.display.input.onContextMenu(t)}function Bo(e,t){return!!Oe(e,"gutterContextMenu")&&Io(e,t,"gutterContextMenu",!1)}function Go(e){e.display.wrapper.className=e.display.wrapper.className.replace(/\s*cm-s-\S+/g,"")+e.options.theme.replace(/(^|\s)\s*/g," cm-s-"),er(e)}function Uo(e){Hn(e),vn(e),zr(e)}function Vo(e,t,r){if(!t!=!(r&&r!=Xs)){var n=e.display.dragFunctions,i=t?Ql:ke;i(e.display.scroller,"dragstart",n.start),i(e.display.scroller,"dragenter",n.enter),i(e.display.scroller,"dragover",n.over),i(e.display.scroller,"dragleave",n.leave),i(e.display.scroller,"drop",n.drop)}}function Ko(e){e.options.lineWrapping?(s(e.display.wrapper,"CodeMirror-wrap"),e.display.sizer.style.minWidth="",e.display.sizerWidth=null):(Fl(e.display.wrapper,"CodeMirror-wrap"),we(e)),Cr(e),vn(e),er(e),setTimeout(function(){return en(e)},100)}function jo(e,t){var r=this;if(!(this instanceof jo))return new jo(e,t);this.options=t=t?c(t):{},c(Ys,t,!1),Fn(t);var n=t.value;"string"==typeof n&&(n=new Ds(n,t.mode,null,t.lineSeparator,t.direction)),this.doc=n;var i=new jo.inputStyles[t.inputStyle](this),o=this.display=new T(e,n,i);o.wrapper.CodeMirror=this,Hn(this),Go(this),t.lineWrapping&&(this.display.wrapper.className+=" CodeMirror-wrap"),rn(this),this.state={keyMaps:[],overlays:[],modeGen:0,overwrite:!1,delayingBlurEvent:!1,focused:!1,suppressEdits:!1,pasteIncoming:!1,cutIncoming:!1,selectingText:!1,draggingText:!1,highlight:new Pl,keySeq:null,specialChars:null},t.autofocus&&!Tl&&o.input.focus(),gl&&vl<11&&setTimeout(function(){return r.display.input.reset(!0)},20),Xo(this),eo(),nn(this),this.curOp.forceUpdate=!0,qn(this,n),t.autofocus&&!Tl||this.hasFocus()?setTimeout(u(Hr,this),20):Fr(this);for(var l in _s)_s.hasOwnProperty(l)&&_s[l](r,t[l],Xs);Rr(this),t.finishInit&&t.finishInit(this);for(var s=0;s<$s.length;++s)$s[s](r);on(this),ml&&t.lineWrapping&&"optimizelegibility"==getComputedStyle(o.lineDiv).textRendering&&(o.lineDiv.style.textRendering="auto")}function Xo(e){function t(){i.activeTouch&&(o=setTimeout(function(){return i.activeTouch=null},1e3),(l=i.activeTouch).end=+new Date)}function r(e){if(1!=e.touches.length)return!1;var t=e.touches[0];return t.radiusX<=1&&t.radiusY<=1}function n(e,t){if(null==t.left)return!0;var r=t.left-e.left,n=t.top-e.top;return r*r+n*n>400}var i=e.display;Ql(i.scroller,"mousedown",dn(e,Oo)),gl&&vl<11?Ql(i.scroller,"dblclick",dn(e,function(t){if(!Me(e,t)){var r=Sr(e,t);if(r&&!zo(e,t)&&!Ft(e.display,t)){We(t);var n=e.findWordAt(r);di(e.doc,n.anchor,n.head)}}})):Ql(i.scroller,"dblclick",function(t){return Me(e,t)||We(t)}),Hl||Ql(i.scroller,"contextmenu",function(t){return Ro(e,t)});var o,l={end:0};Ql(i.scroller,"touchstart",function(t){if(!Me(e,t)&&!r(t)&&!zo(e,t)){i.input.ensurePolled(),clearTimeout(o);var n=+new Date;i.activeTouch={start:n,moved:!1,prev:n-l.end<=300?l:null},1==t.touches.length&&(i.activeTouch.left=t.touches[0].pageX,i.activeTouch.top=t.touches[0].pageY)}}),Ql(i.scroller,"touchmove",function(){i.activeTouch&&(i.activeTouch.moved=!0)}),Ql(i.scroller,"touchend",function(r){var o=i.activeTouch;if(o&&!Ft(i,r)&&null!=o.left&&!o.moved&&new Date-o.start<300){var l,s=e.coordsChar(i.activeTouch,"page");l=!o.prev||n(o,o.prev)?new Ts(s,s):!o.prev.prev||n(o,o.prev.prev)?e.findWordAt(s):new Ts(E(s.line,0),U(e.doc,E(s.line+1,0))),e.setSelection(l.anchor,l.head),e.focus(),We(r)}t()}),Ql(i.scroller,"touchcancel",t),Ql(i.scroller,"scroll",function(){i.scroller.clientHeight&&(qr(e,i.scroller.scrollTop),Qr(e,i.scroller.scrollLeft,!0),Te(e,"scroll",e))}),Ql(i.scroller,"mousewheel",function(t){return In(e,t)}),Ql(i.scroller,"DOMMouseScroll",function(t){return In(e,t)}),Ql(i.wrapper,"scroll",function(){return i.wrapper.scrollTop=i.wrapper.scrollLeft=0}),i.dragFunctions={enter:function(t){Me(e,t)||Fe(t)},over:function(t){Me(e,t)||(Zi(e,t),Fe(t))},start:function(t){return qi(e,t)},drop:dn(e,$i),leave:function(t){Me(e,t)||Qi(e)}};var s=i.input.getField();Ql(s,"keyup",function(t){return To.call(e,t)}),Ql(s,"keydown",dn(e,Lo)),Ql(s,"keypress",dn(e,Mo)),Ql(s,"focus",function(t){return Hr(e,t)}),Ql(s,"blur",function(t){return Fr(e,t)})}function Yo(e,t,r,n){var i,o=e.doc;null==r&&(r="add"),"smart"==r&&(o.mode.indent?i=$e(e,t).state:r="prev");var l=e.options.tabSize,s=M(o,t),a=f(s.text,null,l);s.stateAfter&&(s.stateAfter=null);var u,c=s.text.match(/^\s*/)[0];if(n||/\S/.test(s.text)){if("smart"==r&&((u=o.mode.indent(i,s.text.slice(c.length),s.text))==Bl||u>150)){if(!n)return;r="prev"}}else u=0,r="not";"prev"==r?u=t>o.first?f(M(o,t-1).text,null,l):0:"add"==r?u=a+e.options.indentUnit:"subtract"==r?u=a-e.options.indentUnit:"number"==typeof r&&(u=a+r),u=Math.max(0,u);var h="",d=0;if(e.options.indentWithTabs)for(var g=Math.floor(u/l);g;--g)d+=l,h+="\t";if(d<u&&(h+=p(u-d)),h!=c)return Ei(o,h,E(t,0),E(t,c.length),"+input"),s.stateAfter=null,!0;for(var v=0;v<o.sel.ranges.length;v++){var m=o.sel.ranges[v];if(m.head.line==t&&m.head.ch<c.length){var y=E(t,c.length);gi(o,v,new Ts(y,y));break}}}function _o(e){qs=e}function $o(e,t,r,n,i){var o=e.doc;e.display.shift=!1,n||(n=o.sel);var l=e.state.pasteIncoming||"paste"==i,s=es(t),a=null;if(l&&n.ranges.length>1)if(qs&&qs.text.join("\n")==t){if(n.ranges.length%qs.text.length==0){a=[];for(var u=0;u<qs.text.length;u++)a.push(o.splitLines(qs.text[u]))}}else s.length==n.ranges.length&&e.options.pasteLinesPerSelection&&(a=v(s,function(e){return[e]}));for(var c,f=n.ranges.length-1;f>=0;f--){var h=n.ranges[f],d=h.from(),p=h.to();h.empty()&&(r&&r>0?d=E(d.line,d.ch-r):e.state.overwrite&&!l?p=E(p.line,Math.min(M(o,p.line).text.length,p.ch+g(s).length)):qs&&qs.lineWise&&qs.text.join("\n")==t&&(d=p=E(d.line,0))),c=e.curOp.updateInput;var m={from:d,to:p,text:a?a[f%a.length]:s,origin:i||(l?"paste":e.state.cutIncoming?"cut":"+input")};Oi(e.doc,m),bt(e,"inputRead",e,m)}t&&!l&&Zo(e,t),jr(e),e.curOp.updateInput=c,e.curOp.typing=!0,e.state.pasteIncoming=e.state.cutIncoming=!1}function qo(e,t){var r=e.clipboardData&&e.clipboardData.getData("Text");if(r)return e.preventDefault(),t.isReadOnly()||t.options.disableInput||hn(t,function(){return $o(t,r,0,null,"paste")}),!0}function Zo(e,t){if(e.options.electricChars&&e.options.smartIndent)for(var r=e.doc.sel,n=r.ranges.length-1;n>=0;n--){var i=r.ranges[n];if(!(i.head.ch>100||n&&r.ranges[n-1].head.line==i.head.line)){var o=e.getModeAt(i.head),l=!1;if(o.electricChars){for(var s=0;s<o.electricChars.length;s++)if(t.indexOf(o.electricChars.charAt(s))>-1){l=Yo(e,i.head.line,"smart");break}}else o.electricInput&&o.electricInput.test(M(e.doc,i.head.line).text.slice(0,i.head.ch))&&(l=Yo(e,i.head.line,"smart"));l&&bt(e,"electricInput",e,i.head.line)}}}function Qo(e){for(var t=[],r=[],n=0;n<e.doc.sel.ranges.length;n++){var i=e.doc.sel.ranges[n].head.line,o={anchor:E(i,0),head:E(i+1,0)};r.push(o),t.push(e.getRange(o.anchor,o.head))}return{text:t,ranges:r}}function Jo(e,t){e.setAttribute("autocorrect","off"),e.setAttribute("autocapitalize","off"),e.setAttribute("spellcheck",!!t)}function el(){var e=n("textarea",null,null,"position: absolute; bottom: -1em; padding: 0; width: 1px; height: 1em; outline: none"),t=n("div",[e],null,"overflow: hidden; position: relative; width: 3px; height: 0px;");return ml?e.style.width="1000px":e.setAttribute("wrap","off"),Ll&&(e.style.border="1px solid black"),Jo(e),t}function tl(e,t,r,n,i){function o(){var n=t.line+r;return!(n<e.first||n>=e.first+e.size)&&(t=new E(n,t.ch,t.sticky),u=M(e,n))}function l(n){var l;if(null==(l=i?go(e.cm,u,t,r):ho(u,t,r))){if(n||!o())return!1;t=po(i,e.cm,u,t.line,r)}else t=l;return!0}var s=t,a=r,u=M(e,t.line);if("char"==n)l();else if("column"==n)l(!0);else if("word"==n||"group"==n)for(var c=null,f="group"==n,h=e.cm&&e.cm.getHelper(t,"wordChars"),d=!0;!(r<0)||l(!d);d=!1){var p=u.text.charAt(t.ch)||"\n",g=x(p,h)?"w":f&&"\n"==p?"n":!f||/\s/.test(p)?null:"p";if(!f||d||g||(g="s"),c&&c!=g){r<0&&(r=1,l(),t.sticky="after");break}if(g&&(c=g),r>0&&!l(!d))break}var v=ki(e,t,s,a,!0);return I(s,v)&&(v.hitSide=!0),v}function rl(e,t,r,n){var i,o=e.doc,l=t.left;if("page"==n){var s=Math.min(e.display.wrapper.clientHeight,window.innerHeight||document.documentElement.clientHeight),a=Math.max(s-.5*mr(e.display),3);i=(r>0?t.bottom:t.top)+r*a}else"line"==n&&(i=r>0?t.bottom+3:t.top-3);for(var u;(u=cr(e,l,i)).outside;){if(r<0?i<=0:i>=o.height){u.hitSide=!0;break}i+=5*r}return u}function nl(e,t){var r=jt(e,t.line);if(!r||r.hidden)return null;var n=M(e.doc,t.line),i=Ut(r,n,t.line),o=Se(n,e.doc.direction),l="left";o&&(l=Ce(o,t.ch)%2?"right":"left");var s=_t(i.map,t.ch,l);return s.offset="right"==s.collapse?s.end:s.start,s}function il(e){for(var t=e;t;t=t.parentNode)if(/CodeMirror-gutter-wrapper/.test(t.className))return!0;return!1}function ol(e,t){return t&&(e.bad=!0),e}function ll(e,t,r,n,i){function o(e){return function(t){return t.id==e}}function l(){c&&(u+=f,c=!1)}function s(e){e&&(l(),u+=e)}function a(t){if(1==t.nodeType){var r=t.getAttribute("cm-text");if(null!=r)return void s(r||t.textContent.replace(/\u200b/g,""));var u,h=t.getAttribute("cm-marker");if(h){var d=e.findMarks(E(n,0),E(i+1,0),o(+h));return void(d.length&&(u=d[0].find(0))&&s(N(e.doc,u.from,u.to).join(f)))}if("false"==t.getAttribute("contenteditable"))return;var p=/^(pre|div|p)$/i.test(t.nodeName);p&&l();for(var g=0;g<t.childNodes.length;g++)a(t.childNodes[g]);p&&(c=!0)}else 3==t.nodeType&&s(t.nodeValue)}for(var u="",c=!1,f=e.doc.lineSeparator();a(t),t!=r;)t=t.nextSibling;return u}function sl(e,t,r){var n;if(t==e.display.lineDiv){if(!(n=e.display.lineDiv.childNodes[r]))return ol(e.clipPos(E(e.display.viewTo-1)),!0);t=null,r=0}else for(n=t;;n=n.parentNode){if(!n||n==e.display.lineDiv)return null;if(n.parentNode&&n.parentNode==e.display.lineDiv)break}for(var i=0;i<e.display.view.length;i++){var o=e.display.view[i];if(o.node==n)return al(o,t,r)}}function al(e,t,r){function n(t,r,n){for(var i=-1;i<(f?f.length:0);i++)for(var o=i<0?c.map:f[i],l=0;l<o.length;l+=3){var s=o[l+2];if(s==t||s==r){var a=W(i<0?e.line:e.rest[i]),u=o[l]+n;return(n<0||s!=t)&&(u=o[l+(n?1:0)]),E(a,u)}}}var i=e.text.firstChild,l=!1;if(!t||!o(i,t))return ol(E(W(e.line),0),!0);if(t==i&&(l=!0,t=i.childNodes[r],r=0,!t)){var s=e.rest?g(e.rest):e.line;return ol(E(W(s),s.text.length),l)}var a=3==t.nodeType?t:null,u=t;for(a||1!=t.childNodes.length||3!=t.firstChild.nodeType||(a=t.firstChild,r&&(r=a.nodeValue.length));u.parentNode!=i;)u=u.parentNode;var c=e.measure,f=c.maps,h=n(a,u,r);if(h)return ol(h,l);for(var d=u.nextSibling,p=a?a.nodeValue.length-r:0;d;d=d.nextSibling){if(h=n(d,d.firstChild,0))return ol(E(h.line,h.ch-p),l);p+=d.textContent.length}for(var v=u.previousSibling,m=r;v;v=v.previousSibling){if(h=n(v,v.firstChild,-1))return ol(E(h.line,h.ch+m),l);m+=v.textContent.length}}var ul=navigator.userAgent,cl=navigator.platform,fl=/gecko\/\d/i.test(ul),hl=/MSIE \d/.test(ul),dl=/Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(ul),pl=/Edge\/(\d+)/.exec(ul),gl=hl||dl||pl,vl=gl&&(hl?document.documentMode||6:+(pl||dl)[1]),ml=!pl&&/WebKit\//.test(ul),yl=ml&&/Qt\/\d+\.\d+/.test(ul),bl=!pl&&/Chrome\//.test(ul),wl=/Opera\//.test(ul),xl=/Apple Computer/.test(navigator.vendor),Cl=/Mac OS X 1\d\D([8-9]|\d\d)\D/.test(ul),Sl=/PhantomJS/.test(ul),Ll=!pl&&/AppleWebKit/.test(ul)&&/Mobile\/\w+/.test(ul),kl=/Android/.test(ul),Tl=Ll||kl||/webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(ul),Ml=Ll||/Mac/.test(cl),Nl=/\bCrOS\b/.test(ul),Ol=/win/i.test(cl),Al=wl&&ul.match(/Version\/(\d*\.\d*)/);Al&&(Al=Number(Al[1])),Al&&Al>=15&&(wl=!1,ml=!0);var Wl,Dl=Ml&&(yl||wl&&(null==Al||Al<12.11)),Hl=fl||gl&&vl>=9,Fl=function(t,r){var n=t.className,i=e(r).exec(n);if(i){var o=n.slice(i.index+i[0].length);t.className=n.slice(0,i.index)+(o?i[1]+o:"")}};Wl=document.createRange?function(e,t,r,n){var i=document.createRange();return i.setEnd(n||e,r),i.setStart(e,t),i}:function(e,t,r){var n=document.body.createTextRange();try{n.moveToElementText(e.parentNode)}catch(e){return n}return n.collapse(!0),n.moveEnd("character",r),n.moveStart("character",t),n};var El=function(e){e.select()};Ll?El=function(e){e.selectionStart=0,e.selectionEnd=e.value.length}:gl&&(El=function(e){try{e.select()}catch(e){}});var Pl=function(){this.id=null};Pl.prototype.set=function(e,t){clearTimeout(this.id),this.id=setTimeout(t,e)};var Il,zl,Rl=30,Bl={toString:function(){return"CodeMirror.Pass"}},Gl={scroll:!1},Ul={origin:"*mouse"},Vl={origin:"+move"},Kl=[""],jl=/[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/,Xl=/[\u0300-\u036f\u0483-\u0489\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u065e\u0670\u06d6-\u06dc\u06de-\u06e4\u06e7\u06e8\u06ea-\u06ed\u0711\u0730-\u074a\u07a6-\u07b0\u07eb-\u07f3\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0900-\u0902\u093c\u0941-\u0948\u094d\u0951-\u0955\u0962\u0963\u0981\u09bc\u09be\u09c1-\u09c4\u09cd\u09d7\u09e2\u09e3\u0a01\u0a02\u0a3c\u0a41\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a70\u0a71\u0a75\u0a81\u0a82\u0abc\u0ac1-\u0ac5\u0ac7\u0ac8\u0acd\u0ae2\u0ae3\u0b01\u0b3c\u0b3e\u0b3f\u0b41-\u0b44\u0b4d\u0b56\u0b57\u0b62\u0b63\u0b82\u0bbe\u0bc0\u0bcd\u0bd7\u0c3e-\u0c40\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0cbc\u0cbf\u0cc2\u0cc6\u0ccc\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0d3e\u0d41-\u0d44\u0d4d\u0d57\u0d62\u0d63\u0dca\u0dcf\u0dd2-\u0dd4\u0dd6\u0ddf\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0eb1\u0eb4-\u0eb9\u0ebb\u0ebc\u0ec8-\u0ecd\u0f18\u0f19\u0f35\u0f37\u0f39\u0f71-\u0f7e\u0f80-\u0f84\u0f86\u0f87\u0f90-\u0f97\u0f99-\u0fbc\u0fc6\u102d-\u1030\u1032-\u1037\u1039\u103a\u103d\u103e\u1058\u1059\u105e-\u1060\u1071-\u1074\u1082\u1085\u1086\u108d\u109d\u135f\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b7-\u17bd\u17c6\u17c9-\u17d3\u17dd\u180b-\u180d\u18a9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193b\u1a17\u1a18\u1a56\u1a58-\u1a5e\u1a60\u1a62\u1a65-\u1a6c\u1a73-\u1a7c\u1a7f\u1b00-\u1b03\u1b34\u1b36-\u1b3a\u1b3c\u1b42\u1b6b-\u1b73\u1b80\u1b81\u1ba2-\u1ba5\u1ba8\u1ba9\u1c2c-\u1c33\u1c36\u1c37\u1cd0-\u1cd2\u1cd4-\u1ce0\u1ce2-\u1ce8\u1ced\u1dc0-\u1de6\u1dfd-\u1dff\u200c\u200d\u20d0-\u20f0\u2cef-\u2cf1\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua66f-\ua672\ua67c\ua67d\ua6f0\ua6f1\ua802\ua806\ua80b\ua825\ua826\ua8c4\ua8e0-\ua8f1\ua926-\ua92d\ua947-\ua951\ua980-\ua982\ua9b3\ua9b6-\ua9b9\ua9bc\uaa29-\uaa2e\uaa31\uaa32\uaa35\uaa36\uaa43\uaa4c\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uabe5\uabe8\uabed\udc00-\udfff\ufb1e\ufe00-\ufe0f\ufe20-\ufe26\uff9e\uff9f]/,Yl=!1,_l=!1,$l=null,ql=function(){function e(e){return e<=247?r.charAt(e):1424<=e&&e<=1524?"R":1536<=e&&e<=1785?n.charAt(e-1536):1774<=e&&e<=2220?"r":8192<=e&&e<=8203?"w":8204==e?"b":"L"}function t(e,t,r){this.level=e,this.from=t,this.to=r}var r="bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLN",n="nnnnnnNNr%%r,rNNmmmmmmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmmmnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmnNmmmmmmrrmmNmmmmrr1111111111",i=/[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/,o=/[stwN]/,l=/[LRr]/,s=/[Lb1n]/,a=/[1n]/;return function(r,n){var u="ltr"==n?"L":"R";if(0==r.length||"ltr"==n&&!i.test(r))return!1;for(var c=r.length,f=[],h=0;h<c;++h)f.push(e(r.charCodeAt(h)));for(var d=0,p=u;d<c;++d){var v=f[d];"m"==v?f[d]=p:p=v}for(var m=0,y=u;m<c;++m){var b=f[m];"1"==b&&"r"==y?f[m]="n":l.test(b)&&(y=b,"r"==b&&(f[m]="R"))}for(var w=1,x=f[0];w<c-1;++w){var C=f[w];"+"==C&&"1"==x&&"1"==f[w+1]?f[w]="1":","!=C||x!=f[w+1]||"1"!=x&&"n"!=x||(f[w]=x),x=C}for(var S=0;S<c;++S){var L=f[S];if(","==L)f[S]="N";else if("%"==L){var k=void 0;for(k=S+1;k<c&&"%"==f[k];++k);for(var T=S&&"!"==f[S-1]||k<c&&"1"==f[k]?"1":"N",M=S;M<k;++M)f[M]=T;S=k-1}}for(var N=0,O=u;N<c;++N){var A=f[N];"L"==O&&"1"==A?f[N]="L":l.test(A)&&(O=A)}for(var W=0;W<c;++W)if(o.test(f[W])){var D=void 0;for(D=W+1;D<c&&o.test(f[D]);++D);for(var H="L"==(W?f[W-1]:u),F=H==("L"==(D<c?f[D]:u))?H?"L":"R":u,E=W;E<D;++E)f[E]=F;W=D-1}for(var P,I=[],z=0;z<c;)if(s.test(f[z])){var R=z;for(++z;z<c&&s.test(f[z]);++z);I.push(new t(0,R,z))}else{var B=z,G=I.length;for(++z;z<c&&"L"!=f[z];++z);for(var U=B;U<z;)if(a.test(f[U])){B<U&&I.splice(G,0,new t(1,B,U));var V=U;for(++U;U<z&&a.test(f[U]);++U);I.splice(G,0,new t(2,V,U)),B=U}else++U;B<z&&I.splice(G,0,new t(1,B,z))}return 1==I[0].level&&(P=r.match(/^\s+/))&&(I[0].from=P[0].length,I.unshift(new t(0,0,P[0].length))),1==g(I).level&&(P=r.match(/\s+$/))&&(g(I).to-=P[0].length,I.push(new t(0,c-P[0].length,c))),"rtl"==n?I.reverse():I}}(),Zl=[],Ql=function(e,t,r){if(e.addEventListener)e.addEventListener(t,r,!1);else if(e.attachEvent)e.attachEvent("on"+t,r);else{var n=e._handlers||(e._handlers={});n[t]=(n[t]||Zl).concat(r)}},Jl=function(){if(gl&&vl<9)return!1;var e=n("div");return"draggable"in e||"dragDrop"in e}(),es=3!="\n\nb".split(/\n/).length?function(e){for(var t=0,r=[],n=e.length;t<=n;){var i=e.indexOf("\n",t);-1==i&&(i=e.length);var o=e.slice(t,"\r"==e.charAt(i-1)?i-1:i),l=o.indexOf("\r");-1!=l?(r.push(o.slice(0,l)),t+=l+1):(r.push(o),t=i+1)}return r}:function(e){return e.split(/\r\n?|\n/)},ts=window.getSelection?function(e){try{return e.selectionStart!=e.selectionEnd}catch(e){return!1}}:function(e){var t;try{t=e.ownerDocument.selection.createRange()}catch(e){}return!(!t||t.parentElement()!=e)&&0!=t.compareEndPoints("StartToEnd",t)},rs=function(){var e=n("div");return"oncopy"in e||(e.setAttribute("oncopy","return;"),"function"==typeof e.oncopy)}(),ns=null,is={},os={},ls={},ss=function(e,t,r){this.pos=this.start=0,this.string=e,this.tabSize=t||8,this.lastColumnPos=this.lastColumnValue=0,this.lineStart=0,this.lineOracle=r};ss.prototype.eol=function(){return this.pos>=this.string.length},ss.prototype.sol=function(){return this.pos==this.lineStart},ss.prototype.peek=function(){return this.string.charAt(this.pos)||void 0},ss.prototype.next=function(){if(this.pos<this.string.length)return this.string.charAt(this.pos++)},ss.prototype.eat=function(e){var t=this.string.charAt(this.pos);if("string"==typeof e?t==e:t&&(e.test?e.test(t):e(t)))return++this.pos,t},ss.prototype.eatWhile=function(e){for(var t=this.pos;this.eat(e););return this.pos>t},ss.prototype.eatSpace=function(){for(var e=this,t=this.pos;/[\s\u00a0]/.test(this.string.charAt(this.pos));)++e.pos;return this.pos>t},ss.prototype.skipToEnd=function(){this.pos=this.string.length},ss.prototype.skipTo=function(e){var t=this.string.indexOf(e,this.pos);if(t>-1)return this.pos=t,!0},ss.prototype.backUp=function(e){this.pos-=e},ss.prototype.column=function(){return this.lastColumnPos<this.start&&(this.lastColumnValue=f(this.string,this.start,this.tabSize,this.lastColumnPos,this.lastColumnValue),this.lastColumnPos=this.start),this.lastColumnValue-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.indentation=function(){return f(this.string,null,this.tabSize)-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.match=function(e,t,r){if("string"!=typeof e){var n=this.string.slice(this.pos).match(e);return n&&n.index>0?null:(n&&!1!==t&&(this.pos+=n[0].length),n)}var i=function(e){return r?e.toLowerCase():e};if(i(this.string.substr(this.pos,e.length))==i(e))return!1!==t&&(this.pos+=e.length),!0},ss.prototype.current=function(){return this.string.slice(this.start,this.pos)},ss.prototype.hideFirstChars=function(e,t){this.lineStart+=e;try{return t()}finally{this.lineStart-=e}},ss.prototype.lookAhead=function(e){var t=this.lineOracle;return t&&t.lookAhead(e)};var as=function(e,t){this.state=e,this.lookAhead=t},us=function(e,t,r,n){this.state=t,this.doc=e,this.line=r,this.maxLookAhead=n||0};us.prototype.lookAhead=function(e){var t=this.doc.getLine(this.line+e);return null!=t&&e>this.maxLookAhead&&(this.maxLookAhead=e),t},us.prototype.nextLine=function(){this.line++,this.maxLookAhead>0&&this.maxLookAhead--},us.fromSaved=function(e,t,r){return t instanceof as?new us(e,Ke(e.mode,t.state),r,t.lookAhead):new us(e,Ke(e.mode,t),r)},us.prototype.save=function(e){var t=!1!==e?Ke(this.doc.mode,this.state):this.state;return this.maxLookAhead>0?new as(t,this.maxLookAhead):t};var cs=function(e,t,r){this.start=e.start,this.end=e.pos,this.string=e.current(),this.type=t||null,this.state=r},fs=function(e,t,r){this.text=e,ne(this,t),this.height=r?r(this):1};fs.prototype.lineNo=function(){return W(this)},Ae(fs);var hs,ds={},ps={},gs=null,vs=null,ms={left:0,right:0,top:0,bottom:0},ys=function(e,t,r){this.cm=r;var i=this.vert=n("div",[n("div",null,null,"min-width: 1px")],"CodeMirror-vscrollbar"),o=this.horiz=n("div",[n("div",null,null,"height: 100%; min-height: 1px")],"CodeMirror-hscrollbar");e(i),e(o),Ql(i,"scroll",function(){i.clientHeight&&t(i.scrollTop,"vertical")}),Ql(o,"scroll",function(){o.clientWidth&&t(o.scrollLeft,"horizontal")}),this.checkedZeroWidth=!1,gl&&vl<8&&(this.horiz.style.minHeight=this.vert.style.minWidth="18px")};ys.prototype.update=function(e){var t=e.scrollWidth>e.clientWidth+1,r=e.scrollHeight>e.clientHeight+1,n=e.nativeBarWidth;if(r){this.vert.style.display="block",this.vert.style.bottom=t?n+"px":"0";var i=e.viewHeight-(t?n:0);this.vert.firstChild.style.height=Math.max(0,e.scrollHeight-e.clientHeight+i)+"px"}else this.vert.style.display="",this.vert.firstChild.style.height="0";if(t){this.horiz.style.display="block",this.horiz.style.right=r?n+"px":"0",this.horiz.style.left=e.barLeft+"px";var o=e.viewWidth-e.barLeft-(r?n:0);this.horiz.firstChild.style.width=Math.max(0,e.scrollWidth-e.clientWidth+o)+"px"}else this.horiz.style.display="",this.horiz.firstChild.style.width="0";return!this.checkedZeroWidth&&e.clientHeight>0&&(0==n&&this.zeroWidthHack(),this.checkedZeroWidth=!0),{right:r?n:0,bottom:t?n:0}},ys.prototype.setScrollLeft=function(e){this.horiz.scrollLeft!=e&&(this.horiz.scrollLeft=e),this.disableHoriz&&this.enableZeroWidthBar(this.horiz,this.disableHoriz,"horiz")},ys.prototype.setScrollTop=function(e){this.vert.scrollTop!=e&&(this.vert.scrollTop=e),this.disableVert&&this.enableZeroWidthBar(this.vert,this.disableVert,"vert")},ys.prototype.zeroWidthHack=function(){var e=Ml&&!Cl?"12px":"18px";this.horiz.style.height=this.vert.style.width=e,this.horiz.style.pointerEvents=this.vert.style.pointerEvents="none",this.disableHoriz=new Pl,this.disableVert=new Pl},ys.prototype.enableZeroWidthBar=function(e,t,r){function n(){var i=e.getBoundingClientRect();("vert"==r?document.elementFromPoint(i.right-1,(i.top+i.bottom)/2):document.elementFromPoint((i.right+i.left)/2,i.bottom-1))!=e?e.style.pointerEvents="none":t.set(1e3,n)}e.style.pointerEvents="auto",t.set(1e3,n)},ys.prototype.clear=function(){var e=this.horiz.parentNode;e.removeChild(this.horiz),e.removeChild(this.vert)};var bs=function(){};bs.prototype.update=function(){return{bottom:0,right:0}},bs.prototype.setScrollLeft=function(){},bs.prototype.setScrollTop=function(){},bs.prototype.clear=function(){};var ws={native:ys,null:bs},xs=0,Cs=function(e,t,r){var n=e.display;this.viewport=t,this.visible=Ir(n,e.doc,t),this.editorIsHidden=!n.wrapper.offsetWidth,this.wrapperHeight=n.wrapper.clientHeight,this.wrapperWidth=n.wrapper.clientWidth,this.oldDisplayWidth=Rt(e),this.force=r,this.dims=br(e),this.events=[]};Cs.prototype.signal=function(e,t){Oe(e,t)&&this.events.push(arguments)},Cs.prototype.finish=function(){for(var e=this,t=0;t<this.events.length;t++)Te.apply(null,e.events[t])};var Ss=0,Ls=null;gl?Ls=-.53:fl?Ls=15:bl?Ls=-.7:xl&&(Ls=-1/3);var ks=function(e,t){this.ranges=e,this.primIndex=t};ks.prototype.primary=function(){return this.ranges[this.primIndex]},ks.prototype.equals=function(e){var t=this;if(e==this)return!0;if(e.primIndex!=this.primIndex||e.ranges.length!=this.ranges.length)return!1;for(var r=0;r<this.ranges.length;r++){var n=t.ranges[r],i=e.ranges[r];if(!I(n.anchor,i.anchor)||!I(n.head,i.head))return!1}return!0},ks.prototype.deepCopy=function(){for(var e=this,t=[],r=0;r<this.ranges.length;r++)t[r]=new Ts(z(e.ranges[r].anchor),z(e.ranges[r].head));return new ks(t,this.primIndex)},ks.prototype.somethingSelected=function(){for(var e=this,t=0;t<this.ranges.length;t++)if(!e.ranges[t].empty())return!0;return!1},ks.prototype.contains=function(e,t){var r=this;t||(t=e);for(var n=0;n<this.ranges.length;n++){var i=r.ranges[n];if(P(t,i.from())>=0&&P(e,i.to())<=0)return n}return-1};var Ts=function(e,t){this.anchor=e,this.head=t};Ts.prototype.from=function(){return B(this.anchor,this.head)},Ts.prototype.to=function(){return R(this.anchor,this.head)},Ts.prototype.empty=function(){return this.head.line==this.anchor.line&&this.head.ch==this.anchor.ch},Bi.prototype={chunkSize:function(){return this.lines.length},removeInner:function(e,t){for(var r=this,n=e,i=e+t;n<i;++n){var o=r.lines[n];r.height-=o.height,ot(o),bt(o,"delete")}this.lines.splice(e,t)},collapse:function(e){e.push.apply(e,this.lines)},insertInner:function(e,t,r){var n=this;this.height+=r,this.lines=this.lines.slice(0,e).concat(t).concat(this.lines.slice(e));for(var i=0;i<t.length;++i)t[i].parent=n},iterN:function(e,t,r){for(var n=this,i=e+t;e<i;++e)if(r(n.lines[e]))return!0}},Gi.prototype={chunkSize:function(){return this.size},removeInner:function(e,t){var r=this;this.size-=t;for(var n=0;n<this.children.length;++n){var i=r.children[n],o=i.chunkSize();if(e<o){var l=Math.min(t,o-e),s=i.height;if(i.removeInner(e,l),r.height-=s-i.height,o==l&&(r.children.splice(n--,1),i.parent=null),0==(t-=l))break;e=0}else e-=o}if(this.size-t<25&&(this.children.length>1||!(this.children[0]instanceof Bi))){var a=[];this.collapse(a),this.children=[new Bi(a)],this.children[0].parent=this}},collapse:function(e){for(var t=this,r=0;r<this.children.length;++r)t.children[r].collapse(e)},insertInner:function(e,t,r){var n=this;this.size+=t.length,this.height+=r;for(var i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<=l){if(o.insertInner(e,t,r),o.lines&&o.lines.length>50){for(var s=o.lines.length%25+25,a=s;a<o.lines.length;){var u=new Bi(o.lines.slice(a,a+=25));o.height-=u.height,n.children.splice(++i,0,u),u.parent=n}o.lines=o.lines.slice(0,s),n.maybeSpill()}break}e-=l}},maybeSpill:function(){if(!(this.children.length<=10)){var e=this;do{var t=new Gi(e.children.splice(e.children.length-5,5));if(e.parent){e.size-=t.size,e.height-=t.height;var r=h(e.parent.children,e);e.parent.children.splice(r+1,0,t)}else{var n=new Gi(e.children);n.parent=e,e.children=[n,t],e=n}t.parent=e.parent}while(e.children.length>10);e.parent.maybeSpill()}},iterN:function(e,t,r){for(var n=this,i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<l){var s=Math.min(t,l-e);if(o.iterN(e,s,r))return!0;if(0==(t-=s))break;e=0}else e-=l}}};var Ms=function(e,t,r){var n=this;if(r)for(var i in r)r.hasOwnProperty(i)&&(n[i]=r[i]);this.doc=e,this.node=t};Ms.prototype.clear=function(){var e=this,t=this.doc.cm,r=this.line.widgets,n=this.line,i=W(n);if(null!=i&&r){for(var o=0;o<r.length;++o)r[o]==e&&r.splice(o--,1);r.length||(n.widgets=null);var l=Ht(this);A(n,Math.max(0,n.height-l)),t&&(hn(t,function(){Ui(t,n,-l),mn(t,i,"widget")}),bt(t,"lineWidgetCleared",t,this,i))}},Ms.prototype.changed=function(){var e=this,t=this.height,r=this.doc.cm,n=this.line;this.height=null;var i=Ht(this)-t;i&&(A(n,n.height+i),r&&hn(r,function(){r.curOp.forceUpdate=!0,Ui(r,n,i),bt(r,"lineWidgetChanged",r,e,W(n))}))},Ae(Ms);var Ns=0,Os=function(e,t){this.lines=[],this.type=t,this.doc=e,this.id=++Ns};Os.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){var t=this.doc.cm,r=t&&!t.curOp;if(r&&nn(t),Oe(this,"clear")){var n=this.find();n&&bt(this,"clear",n.from,n.to)}for(var i=null,o=null,l=0;l<this.lines.length;++l){var s=e.lines[l],a=_(s.markedSpans,e);t&&!e.collapsed?mn(t,W(s),"text"):t&&(null!=a.to&&(o=W(s)),null!=a.from&&(i=W(s))),s.markedSpans=$(s.markedSpans,a),null==a.from&&e.collapsed&&!ve(e.doc,s)&&t&&A(s,mr(t.display))}if(t&&this.collapsed&&!t.options.lineWrapping)for(var u=0;u<this.lines.length;++u){var c=fe(e.lines[u]),f=be(c);f>t.display.maxLineLength&&(t.display.maxLine=c,t.display.maxLineLength=f,t.display.maxLineChanged=!0)}null!=i&&t&&this.collapsed&&vn(t,i,o+1),this.lines.length=0,this.explicitlyCleared=!0,this.atomic&&this.doc.cantEdit&&(this.doc.cantEdit=!1,t&&Ci(t.doc)),t&&bt(t,"markerCleared",t,this,i,o),r&&on(t),this.parent&&this.parent.clear()}},Os.prototype.find=function(e,t){var r=this;null==e&&"bookmark"==this.type&&(e=1);for(var n,i,o=0;o<this.lines.length;++o){var l=r.lines[o],s=_(l.markedSpans,r);if(null!=s.from&&(n=E(t?l:W(l),s.from),-1==e))return n;if(null!=s.to&&(i=E(t?l:W(l),s.to),1==e))return i}return n&&{from:n,to:i}},Os.prototype.changed=function(){var e=this,t=this.find(-1,!0),r=this,n=this.doc.cm;t&&n&&hn(n,function(){var i=t.line,o=W(t.line),l=jt(n,o);if(l&&(Qt(l),n.curOp.selectionChanged=n.curOp.forceUpdate=!0),n.curOp.updateMaxLine=!0,!ve(r.doc,i)&&null!=r.height){var s=r.height;r.height=null;var a=Ht(r)-s;a&&A(i,i.height+a)}bt(n,"markerChanged",n,e)})},Os.prototype.attachLine=function(e){if(!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;t.maybeHiddenMarkers&&-1!=h(t.maybeHiddenMarkers,this)||(t.maybeUnhiddenMarkers||(t.maybeUnhiddenMarkers=[])).push(this)}this.lines.push(e)},Os.prototype.detachLine=function(e){if(this.lines.splice(h(this.lines,e),1),!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;(t.maybeHiddenMarkers||(t.maybeHiddenMarkers=[])).push(this)}},Ae(Os);var As=function(e,t){var r=this;this.markers=e,this.primary=t;for(var n=0;n<e.length;++n)e[n].parent=r};As.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){this.explicitlyCleared=!0;for(var t=0;t<this.markers.length;++t)e.markers[t].clear();bt(this,"clear")}},As.prototype.find=function(e,t){return this.primary.find(e,t)},Ae(As);var Ws=0,Ds=function(e,t,r,n,i){if(!(this instanceof Ds))return new Ds(e,t,r,n,i);null==r&&(r=0),Gi.call(this,[new Bi([new fs("",null)])]),this.first=r,this.scrollTop=this.scrollLeft=0,this.cantEdit=!1,this.cleanGeneration=1,this.modeFrontier=this.highlightFrontier=r;var o=E(r,0);this.sel=Rn(o),this.history=new Jn(null),this.id=++Ws,this.modeOption=t,this.lineSep=n,this.direction="rtl"==i?"rtl":"ltr",this.extend=!1,"string"==typeof e&&(e=this.splitLines(e)),_n(this,{from:o,to:o,text:e}),bi(this,Rn(o),Gl)};Ds.prototype=b(Gi.prototype,{constructor:Ds,iter:function(e,t,r){r?this.iterN(e-this.first,t-e,r):this.iterN(this.first,this.first+this.size,e)},insert:function(e,t){for(var r=0,n=0;n<t.length;++n)r+=t[n].height;this.insertInner(e-this.first,t,r)},remove:function(e,t){this.removeInner(e-this.first,t)},getValue:function(e){var t=O(this,this.first,this.first+this.size);return!1===e?t:t.join(e||this.lineSeparator())},setValue:gn(function(e){var t=E(this.first,0),r=this.first+this.size-1;Oi(this,{from:t,to:E(r,M(this,r).text.length),text:this.splitLines(e),origin:"setValue",full:!0},!0),this.cm&&Xr(this.cm,0,0),bi(this,Rn(t),Gl)}),replaceRange:function(e,t,r,n){Ei(this,e,t=U(this,t),r=r?U(this,r):t,n)},getRange:function(e,t,r){var n=N(this,U(this,e),U(this,t));return!1===r?n:n.join(r||this.lineSeparator())},getLine:function(e){var t=this.getLineHandle(e);return t&&t.text},getLineHandle:function(e){if(H(this,e))return M(this,e)},getLineNumber:function(e){return W(e)},getLineHandleVisualStart:function(e){return"number"==typeof e&&(e=M(this,e)),fe(e)},lineCount:function(){return this.size},firstLine:function(){return this.first},lastLine:function(){return this.first+this.size-1},clipPos:function(e){return U(this,e)},getCursor:function(e){var t=this.sel.primary();return null==e||"head"==e?t.head:"anchor"==e?t.anchor:"end"==e||"to"==e||!1===e?t.to():t.from()},listSelections:function(){return this.sel.ranges},somethingSelected:function(){return this.sel.somethingSelected()},setCursor:gn(function(e,t,r){vi(this,U(this,"number"==typeof e?E(e,t||0):e),null,r)}),setSelection:gn(function(e,t,r){vi(this,U(this,e),U(this,t||e),r)}),extendSelection:gn(function(e,t,r){di(this,U(this,e),t&&U(this,t),r)}),extendSelections:gn(function(e,t){pi(this,K(this,e),t)}),extendSelectionsBy:gn(function(e,t){pi(this,K(this,v(this.sel.ranges,e)),t)}),setSelections:gn(function(e,t,r){var n=this;if(e.length){for(var i=[],o=0;o<e.length;o++)i[o]=new Ts(U(n,e[o].anchor),U(n,e[o].head));null==t&&(t=Math.min(e.length-1,this.sel.primIndex)),bi(this,zn(i,t),r)}}),addSelection:gn(function(e,t,r){var n=this.sel.ranges.slice(0);n.push(new Ts(U(this,e),U(this,t||e))),bi(this,zn(n,n.length-1),r)}),getSelection:function(e){for(var t,r=this,n=this.sel.ranges,i=0;i<n.length;i++){var o=N(r,n[i].from(),n[i].to());t=t?t.concat(o):o}return!1===e?t:t.join(e||this.lineSeparator())},getSelections:function(e){for(var t=this,r=[],n=this.sel.ranges,i=0;i<n.length;i++){var o=N(t,n[i].from(),n[i].to());!1!==e&&(o=o.join(e||t.lineSeparator())),r[i]=o}return r},replaceSelection:function(e,t,r){for(var n=[],i=0;i<this.sel.ranges.length;i++)n[i]=e;this.replaceSelections(n,t,r||"+input")},replaceSelections:gn(function(e,t,r){for(var n=this,i=[],o=this.sel,l=0;l<o.ranges.length;l++){var s=o.ranges[l];i[l]={from:s.from(),to:s.to(),text:n.splitLines(e[l]),origin:r}}for(var a=t&&"end"!=t&&Kn(this,i,t),u=i.length-1;u>=0;u--)Oi(n,i[u]);a?yi(this,a):this.cm&&jr(this.cm)}),undo:gn(function(){Wi(this,"undo")}),redo:gn(function(){Wi(this,"redo")}),undoSelection:gn(function(){Wi(this,"undo",!0)}),redoSelection:gn(function(){Wi(this,"redo",!0)}),setExtending:function(e){this.extend=e},getExtending:function(){return this.extend},historySize:function(){for(var e=this.history,t=0,r=0,n=0;n<e.done.length;n++)e.done[n].ranges||++t;for(var i=0;i<e.undone.length;i++)e.undone[i].ranges||++r;return{undo:t,redo:r}},clearHistory:function(){this.history=new Jn(this.history.maxGeneration)},markClean:function(){this.cleanGeneration=this.changeGeneration(!0)},changeGeneration:function(e){return e&&(this.history.lastOp=this.history.lastSelOp=this.history.lastOrigin=null),this.history.generation},isClean:function(e){return this.history.generation==(e||this.cleanGeneration)},getHistory:function(){return{done:fi(this.history.done),undone:fi(this.history.undone)}},setHistory:function(e){var t=this.history=new Jn(this.history.maxGeneration);t.done=fi(e.done.slice(0),null,!0),t.undone=fi(e.undone.slice(0),null,!0)},setGutterMarker:gn(function(e,t,r){return Ri(this,e,"gutter",function(e){var n=e.gutterMarkers||(e.gutterMarkers={});return n[t]=r,!r&&C(n)&&(e.gutterMarkers=null),!0})}),clearGutter:gn(function(e){var t=this;this.iter(function(r){r.gutterMarkers&&r.gutterMarkers[e]&&Ri(t,r,"gutter",function(){return r.gutterMarkers[e]=null,C(r.gutterMarkers)&&(r.gutterMarkers=null),!0})})}),lineInfo:function(e){var t;if("number"==typeof e){if(!H(this,e))return null;if(t=e,!(e=M(this,e)))return null}else if(null==(t=W(e)))return null;return{line:t,handle:e,text:e.text,gutterMarkers:e.gutterMarkers,textClass:e.textClass,bgClass:e.bgClass,wrapClass:e.wrapClass,widgets:e.widgets}},addLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass";if(t[i]){if(e(n).test(t[i]))return!1;t[i]+=" "+n}else t[i]=n;return!0})}),removeLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass",o=t[i];if(!o)return!1;if(null==n)t[i]=null;else{var l=o.match(e(n));if(!l)return!1;var s=l.index+l[0].length;t[i]=o.slice(0,l.index)+(l.index&&s!=o.length?" ":"")+o.slice(s)||null}return!0})}),addLineWidget:gn(function(e,t,r){return Vi(this,e,t,r)}),removeLineWidget:function(e){e.clear()},markText:function(e,t,r){return Ki(this,U(this,e),U(this,t),r,r&&r.type||"range")},setBookmark:function(e,t){var r={replacedWith:t&&(null==t.nodeType?t.widget:t),insertLeft:t&&t.insertLeft,clearWhenEmpty:!1,shared:t&&t.shared,handleMouseEvents:t&&t.handleMouseEvents};return e=U(this,e),Ki(this,e,e,r,"bookmark")},findMarksAt:function(e){var t=[],r=M(this,(e=U(this,e)).line).markedSpans;if(r)for(var n=0;n<r.length;++n){var i=r[n];(null==i.from||i.from<=e.ch)&&(null==i.to||i.to>=e.ch)&&t.push(i.marker.parent||i.marker)}return t},findMarks:function(e,t,r){e=U(this,e),t=U(this,t);var n=[],i=e.line;return this.iter(e.line,t.line+1,function(o){var l=o.markedSpans;if(l)for(var s=0;s<l.length;s++){var a=l[s];null!=a.to&&i==e.line&&e.ch>=a.to||null==a.from&&i!=e.line||null!=a.from&&i==t.line&&a.from>=t.ch||r&&!r(a.marker)||n.push(a.marker.parent||a.marker)}++i}),n},getAllMarks:function(){var e=[];return this.iter(function(t){var r=t.markedSpans;if(r)for(var n=0;n<r.length;++n)null!=r[n].from&&e.push(r[n].marker)}),e},posFromIndex:function(e){var t,r=this.first,n=this.lineSeparator().length;return this.iter(function(i){var o=i.text.length+n;if(o>e)return t=e,!0;e-=o,++r}),U(this,E(r,t))},indexFromPos:function(e){var t=(e=U(this,e)).ch;if(e.line<this.first||e.ch<0)return 0;var r=this.lineSeparator().length;return this.iter(this.first,e.line,function(e){t+=e.text.length+r}),t},copy:function(e){var t=new Ds(O(this,this.first,this.first+this.size),this.modeOption,this.first,this.lineSep,this.direction);return t.scrollTop=this.scrollTop,t.scrollLeft=this.scrollLeft,t.sel=this.sel,t.extend=!1,e&&(t.history.undoDepth=this.history.undoDepth,t.setHistory(this.getHistory())),t},linkedDoc:function(e){e||(e={});var t=this.first,r=this.first+this.size;null!=e.from&&e.from>t&&(t=e.from),null!=e.to&&e.to<r&&(r=e.to);var n=new Ds(O(this,t,r),e.mode||this.modeOption,t,this.lineSep,this.direction);return e.sharedHist&&(n.history=this.history),(this.linked||(this.linked=[])).push({doc:n,sharedHist:e.sharedHist}),n.linked=[{doc:this,isParent:!0,sharedHist:e.sharedHist}],Yi(n,Xi(this)),n},unlinkDoc:function(e){var t=this;if(e instanceof jo&&(e=e.doc),this.linked)for(var r=0;r<this.linked.length;++r)if(t.linked[r].doc==e){t.linked.splice(r,1),e.unlinkDoc(t),_i(Xi(t));break}if(e.history==this.history){var n=[e.id];$n(e,function(e){return n.push(e.id)},!0),e.history=new Jn(null),e.history.done=fi(this.history.done,n),e.history.undone=fi(this.history.undone,n)}},iterLinkedDocs:function(e){$n(this,e)},getMode:function(){return this.mode},getEditor:function(){return this.cm},splitLines:function(e){return this.lineSep?e.split(this.lineSep):es(e)},lineSeparator:function(){return this.lineSep||"\n"},setDirection:gn(function(e){"rtl"!=e&&(e="ltr"),e!=this.direction&&(this.direction=e,this.iter(function(e){return e.order=null}),this.cm&&Qn(this.cm))})}),Ds.prototype.eachLine=Ds.prototype.iter;for(var Hs=0,Fs=!1,Es={3:"Enter",8:"Backspace",9:"Tab",13:"Enter",16:"Shift",17:"Ctrl",18:"Alt",19:"Pause",20:"CapsLock",27:"Esc",32:"Space",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"Left",38:"Up",39:"Right",40:"Down",44:"PrintScrn",45:"Insert",46:"Delete",59:";",61:"=",91:"Mod",92:"Mod",93:"Mod",106:"*",107:"=",109:"-",110:".",111:"/",127:"Delete",173:"-",186:";",187:"=",188:",",189:"-",190:".",191:"/",192:"`",219:"[",220:"\\",221:"]",222:"'",63232:"Up",63233:"Down",63234:"Left",63235:"Right",63272:"Delete",63273:"Home",63275:"End",63276:"PageUp",63277:"PageDown",63302:"Insert"},Ps=0;Ps<10;Ps++)Es[Ps+48]=Es[Ps+96]=String(Ps);for(var Is=65;Is<=90;Is++)Es[Is]=String.fromCharCode(Is);for(var zs=1;zs<=12;zs++)Es[zs+111]=Es[zs+63235]="F"+zs;var Rs={};Rs.basic={Left:"goCharLeft",Right:"goCharRight",Up:"goLineUp",Down:"goLineDown",End:"goLineEnd",Home:"goLineStartSmart",PageUp:"goPageUp",PageDown:"goPageDown",Delete:"delCharAfter",Backspace:"delCharBefore","Shift-Backspace":"delCharBefore",Tab:"defaultTab","Shift-Tab":"indentAuto",Enter:"newlineAndIndent",Insert:"toggleOverwrite",Esc:"singleSelection"},Rs.pcDefault={"Ctrl-A":"selectAll","Ctrl-D":"deleteLine","Ctrl-Z":"undo","Shift-Ctrl-Z":"redo","Ctrl-Y":"redo","Ctrl-Home":"goDocStart","Ctrl-End":"goDocEnd","Ctrl-Up":"goLineUp","Ctrl-Down":"goLineDown","Ctrl-Left":"goGroupLeft","Ctrl-Right":"goGroupRight","Alt-Left":"goLineStart","Alt-Right":"goLineEnd","Ctrl-Backspace":"delGroupBefore","Ctrl-Delete":"delGroupAfter","Ctrl-S":"save","Ctrl-F":"find","Ctrl-G":"findNext","Shift-Ctrl-G":"findPrev","Shift-Ctrl-F":"replace","Shift-Ctrl-R":"replaceAll","Ctrl-[":"indentLess","Ctrl-]":"indentMore","Ctrl-U":"undoSelection","Shift-Ctrl-U":"redoSelection","Alt-U":"redoSelection",fallthrough:"basic"},Rs.emacsy={"Ctrl-F":"goCharRight","Ctrl-B":"goCharLeft","Ctrl-P":"goLineUp","Ctrl-N":"goLineDown","Alt-F":"goWordRight","Alt-B":"goWordLeft","Ctrl-A":"goLineStart","Ctrl-E":"goLineEnd","Ctrl-V":"goPageDown","Shift-Ctrl-V":"goPageUp","Ctrl-D":"delCharAfter","Ctrl-H":"delCharBefore","Alt-D":"delWordAfter","Alt-Backspace":"delWordBefore","Ctrl-K":"killLine","Ctrl-T":"transposeChars","Ctrl-O":"openLine"},Rs.macDefault={"Cmd-A":"selectAll","Cmd-D":"deleteLine","Cmd-Z":"undo","Shift-Cmd-Z":"redo","Cmd-Y":"redo","Cmd-Home":"goDocStart","Cmd-Up":"goDocStart","Cmd-End":"goDocEnd","Cmd-Down":"goDocEnd","Alt-Left":"goGroupLeft","Alt-Right":"goGroupRight","Cmd-Left":"goLineLeft","Cmd-Right":"goLineRight","Alt-Backspace":"delGroupBefore","Ctrl-Alt-Backspace":"delGroupAfter","Alt-Delete":"delGroupAfter","Cmd-S":"save","Cmd-F":"find","Cmd-G":"findNext","Shift-Cmd-G":"findPrev","Cmd-Alt-F":"replace","Shift-Cmd-Alt-F":"replaceAll","Cmd-[":"indentLess","Cmd-]":"indentMore","Cmd-Backspace":"delWrappedLineLeft","Cmd-Delete":"delWrappedLineRight","Cmd-U":"undoSelection","Shift-Cmd-U":"redoSelection","Ctrl-Up":"goDocStart","Ctrl-Down":"goDocEnd",fallthrough:["basic","emacsy"]},Rs.default=Ml?Rs.macDefault:Rs.pcDefault;var Bs={selectAll:Mi,singleSelection:function(e){return e.setSelection(e.getCursor("anchor"),e.getCursor("head"),Gl)},killLine:function(e){return co(e,function(t){if(t.empty()){var r=M(e.doc,t.head.line).text.length;return t.head.ch==r&&t.head.line<e.lastLine()?{from:t.head,to:E(t.head.line+1,0)}:{from:t.head,to:E(t.head.line,r)}}return{from:t.from(),to:t.to()}})},deleteLine:function(e){return co(e,function(t){return{from:E(t.from().line,0),to:U(e.doc,E(t.to().line+1,0))}})},delLineLeft:function(e){return co(e,function(e){return{from:E(e.from().line,0),to:e.from()}})},delWrappedLineLeft:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5;return{from:e.coordsChar({left:0,top:r},"div"),to:t.from()}})},delWrappedLineRight:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5,n=e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div");return{from:t.from(),to:n}})},undo:function(e){return e.undo()},redo:function(e){return e.redo()},undoSelection:function(e){return e.undoSelection()},redoSelection:function(e){return e.redoSelection()},goDocStart:function(e){return e.extendSelection(E(e.firstLine(),0))},goDocEnd:function(e){return e.extendSelection(E(e.lastLine()))},goLineStart:function(e){return e.extendSelectionsBy(function(t){return vo(e,t.head.line)},{origin:"+move",bias:1})},goLineStartSmart:function(e){return e.extendSelectionsBy(function(t){return yo(e,t.head)},{origin:"+move",bias:1})},goLineEnd:function(e){return e.extendSelectionsBy(function(t){return mo(e,t.head.line)},{origin:"+move",bias:-1})},goLineRight:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div")},Vl)},goLineLeft:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:0,top:r},"div")},Vl)},goLineLeftSmart:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5,n=e.coordsChar({left:0,top:r},"div");return n.ch<e.getLine(n.line).search(/\S/)?yo(e,t.head):n},Vl)},goLineUp:function(e){return e.moveV(-1,"line")},goLineDown:function(e){return e.moveV(1,"line")},goPageUp:function(e){return e.moveV(-1,"page")},goPageDown:function(e){return e.moveV(1,"page")},goCharLeft:function(e){return e.moveH(-1,"char")},goCharRight:function(e){return e.moveH(1,"char")},goColumnLeft:function(e){return e.moveH(-1,"column")},goColumnRight:function(e){return e.moveH(1,"column")},goWordLeft:function(e){return e.moveH(-1,"word")},goGroupRight:function(e){return e.moveH(1,"group")},goGroupLeft:function(e){return e.moveH(-1,"group")},goWordRight:function(e){return e.moveH(1,"word")},delCharBefore:function(e){return e.deleteH(-1,"char")},delCharAfter:function(e){return e.deleteH(1,"char")},delWordBefore:function(e){return e.deleteH(-1,"word")},delWordAfter:function(e){return e.deleteH(1,"word")},delGroupBefore:function(e){return e.deleteH(-1,"group")},delGroupAfter:function(e){return e.deleteH(1,"group")},indentAuto:function(e){return e.indentSelection("smart")},indentMore:function(e){return e.indentSelection("add")},indentLess:function(e){return e.indentSelection("subtract")},insertTab:function(e){return e.replaceSelection("\t")},insertSoftTab:function(e){for(var t=[],r=e.listSelections(),n=e.options.tabSize,i=0;i<r.length;i++){var o=r[i].from(),l=f(e.getLine(o.line),o.ch,n);t.push(p(n-l%n))}e.replaceSelections(t)},defaultTab:function(e){e.somethingSelected()?e.indentSelection("add"):e.execCommand("insertTab")},transposeChars:function(e){return hn(e,function(){for(var t=e.listSelections(),r=[],n=0;n<t.length;n++)if(t[n].empty()){var i=t[n].head,o=M(e.doc,i.line).text;if(o)if(i.ch==o.length&&(i=new E(i.line,i.ch-1)),i.ch>0)i=new E(i.line,i.ch+1),e.replaceRange(o.charAt(i.ch-1)+o.charAt(i.ch-2),E(i.line,i.ch-2),i,"+transpose");else if(i.line>e.doc.first){var l=M(e.doc,i.line-1).text;l&&(i=new E(i.line,1),e.replaceRange(o.charAt(0)+e.doc.lineSeparator()+l.charAt(l.length-1),E(i.line-1,l.length-1),i,"+transpose"))}r.push(new Ts(i,i))}e.setSelections(r)})},newlineAndIndent:function(e){return hn(e,function(){for(var t=e.listSelections(),r=t.length-1;r>=0;r--)e.replaceRange(e.doc.lineSeparator(),t[r].anchor,t[r].head,"+input");t=e.listSelections();for(var n=0;n<t.length;n++)e.indentLine(t[n].from().line,null,!0);jr(e)})},openLine:function(e){return e.replaceSelection("\n","start")},toggleOverwrite:function(e){return e.toggleOverwrite()}},Gs=new Pl,Us=null,Vs=function(e,t,r){this.time=e,this.pos=t,this.button=r};Vs.prototype.compare=function(e,t,r){return this.time+400>e&&0==P(t,this.pos)&&r==this.button};var Ks,js,Xs={toString:function(){return"CodeMirror.Init"}},Ys={},_s={};jo.defaults=Ys,jo.optionHandlers=_s;var $s=[];jo.defineInitHook=function(e){return $s.push(e)};var qs=null,Zs=function(e){this.cm=e,this.lastAnchorNode=this.lastAnchorOffset=this.lastFocusNode=this.lastFocusOffset=null,this.polling=new Pl,this.composing=null,this.gracePeriod=!1,this.readDOMTimeout=null};Zs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()}),"cut"==e.type&&i.replaceSelection("",null,"cut");else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type&&i.operation(function(){i.setSelections(t.ranges,0,Gl),i.replaceSelection("",null,"cut")})}if(e.clipboardData){e.clipboardData.clearData();var r=qs.text.join("\n");if(e.clipboardData.setData("Text",r),e.clipboardData.getData("Text")==r)return void e.preventDefault()}var l=el(),s=l.firstChild;i.display.lineSpace.insertBefore(l,i.display.lineSpace.firstChild),s.value=qs.text.join("\n");var a=document.activeElement;El(s),setTimeout(function(){i.display.lineSpace.removeChild(l),a.focus(),a==o&&n.showPrimarySelection()},50)}}var r=this,n=this,i=n.cm,o=n.div=e.lineDiv;Jo(o,i.options.spellcheck),Ql(o,"paste",function(e){Me(i,e)||qo(e,i)||vl<=11&&setTimeout(dn(i,function(){return r.updateFromDOM()}),20)}),Ql(o,"compositionstart",function(e){r.composing={data:e.data,done:!1}}),Ql(o,"compositionupdate",function(e){r.composing||(r.composing={data:e.data,done:!1})}),Ql(o,"compositionend",function(e){r.composing&&(e.data!=r.composing.data&&r.readFromDOMSoon(),r.composing.done=!0)}),Ql(o,"touchstart",function(){return n.forceCompositionEnd()}),Ql(o,"input",function(){r.composing||r.readFromDOMSoon()}),Ql(o,"copy",t),Ql(o,"cut",t)},Zs.prototype.prepareSelection=function(){var e=Tr(this.cm,!1);return e.focus=this.cm.state.focused,e},Zs.prototype.showSelection=function(e,t){e&&this.cm.display.view.length&&((e.focus||t)&&this.showPrimarySelection(),this.showMultipleSelections(e))},Zs.prototype.showPrimarySelection=function(){var e=window.getSelection(),t=this.cm,r=t.doc.sel.primary(),n=r.from(),i=r.to();if(t.display.viewTo==t.display.viewFrom||n.line>=t.display.viewTo||i.line<t.display.viewFrom)e.removeAllRanges();else{var o=sl(t,e.anchorNode,e.anchorOffset),l=sl(t,e.focusNode,e.focusOffset);if(!o||o.bad||!l||l.bad||0!=P(B(o,l),n)||0!=P(R(o,l),i)){var s=t.display.view,a=n.line>=t.display.viewFrom&&nl(t,n)||{node:s[0].measure.map[2],offset:0},u=i.line<t.display.viewTo&&nl(t,i);if(!u){var c=s[s.length-1].measure,f=c.maps?c.maps[c.maps.length-1]:c.map;u={node:f[f.length-1],offset:f[f.length-2]-f[f.length-3]}}if(a&&u){var h,d=e.rangeCount&&e.getRangeAt(0);try{h=Wl(a.node,a.offset,u.offset,u.node)}catch(e){}h&&(!fl&&t.state.focused?(e.collapse(a.node,a.offset),h.collapsed||(e.removeAllRanges(),e.addRange(h))):(e.removeAllRanges(),e.addRange(h)),d&&null==e.anchorNode?e.addRange(d):fl&&this.startGracePeriod()),this.rememberSelection()}else e.removeAllRanges()}}},Zs.prototype.startGracePeriod=function(){var e=this;clearTimeout(this.gracePeriod),this.gracePeriod=setTimeout(function(){e.gracePeriod=!1,e.selectionChanged()&&e.cm.operation(function(){return e.cm.curOp.selectionChanged=!0})},20)},Zs.prototype.showMultipleSelections=function(e){r(this.cm.display.cursorDiv,e.cursors),r(this.cm.display.selectionDiv,e.selection)},Zs.prototype.rememberSelection=function(){var e=window.getSelection();this.lastAnchorNode=e.anchorNode,this.lastAnchorOffset=e.anchorOffset,this.lastFocusNode=e.focusNode,this.lastFocusOffset=e.focusOffset},Zs.prototype.selectionInEditor=function(){var e=window.getSelection();if(!e.rangeCount)return!1;var t=e.getRangeAt(0).commonAncestorContainer;return o(this.div,t)},Zs.prototype.focus=function(){"nocursor"!=this.cm.options.readOnly&&(this.selectionInEditor()||this.showSelection(this.prepareSelection(),!0),this.div.focus())},Zs.prototype.blur=function(){this.div.blur()},Zs.prototype.getField=function(){return this.div},Zs.prototype.supportsTouch=function(){return!0},Zs.prototype.receivedFocus=function(){function e(){t.cm.state.focused&&(t.pollSelection(),t.polling.set(t.cm.options.pollInterval,e))}var t=this;this.selectionInEditor()?this.pollSelection():hn(this.cm,function(){return t.cm.curOp.selectionChanged=!0}),this.polling.set(this.cm.options.pollInterval,e)},Zs.prototype.selectionChanged=function(){var e=window.getSelection();return e.anchorNode!=this.lastAnchorNode||e.anchorOffset!=this.lastAnchorOffset||e.focusNode!=this.lastFocusNode||e.focusOffset!=this.lastFocusOffset},Zs.prototype.pollSelection=function(){if(null==this.readDOMTimeout&&!this.gracePeriod&&this.selectionChanged()){var e=window.getSelection(),t=this.cm;if(kl&&bl&&this.cm.options.gutters.length&&il(e.anchorNode))return this.cm.triggerOnKeyDown({type:"keydown",keyCode:8,preventDefault:Math.abs}),this.blur(),void this.focus();if(!this.composing){this.rememberSelection();var r=sl(t,e.anchorNode,e.anchorOffset),n=sl(t,e.focusNode,e.focusOffset);r&&n&&hn(t,function(){bi(t.doc,Rn(r,n),Gl),(r.bad||n.bad)&&(t.curOp.selectionChanged=!0)})}}},Zs.prototype.pollContent=function(){null!=this.readDOMTimeout&&(clearTimeout(this.readDOMTimeout),this.readDOMTimeout=null);var e=this.cm,t=e.display,r=e.doc.sel.primary(),n=r.from(),i=r.to();if(0==n.ch&&n.line>e.firstLine()&&(n=E(n.line-1,M(e.doc,n.line-1).length)),i.ch==M(e.doc,i.line).text.length&&i.line<e.lastLine()&&(i=E(i.line+1,0)),n.line<t.viewFrom||i.line>t.viewTo-1)return!1;var o,l,s;n.line==t.viewFrom||0==(o=Lr(e,n.line))?(l=W(t.view[0].line),s=t.view[0].node):(l=W(t.view[o].line),s=t.view[o-1].node.nextSibling);var a,u,c=Lr(e,i.line);if(c==t.view.length-1?(a=t.viewTo-1,u=t.lineDiv.lastChild):(a=W(t.view[c+1].line)-1,u=t.view[c+1].node.previousSibling),!s)return!1;for(var f=e.doc.splitLines(ll(e,s,u,l,a)),h=N(e.doc,E(l,0),E(a,M(e.doc,a).text.length));f.length>1&&h.length>1;)if(g(f)==g(h))f.pop(),h.pop(),a--;else{if(f[0]!=h[0])break;f.shift(),h.shift(),l++}for(var d=0,p=0,v=f[0],m=h[0],y=Math.min(v.length,m.length);d<y&&v.charCodeAt(d)==m.charCodeAt(d);)++d;for(var b=g(f),w=g(h),x=Math.min(b.length-(1==f.length?d:0),w.length-(1==h.length?d:0));p<x&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)++p;if(1==f.length&&1==h.length&&l==n.line)for(;d&&d>n.ch&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)d--,p++;f[f.length-1]=b.slice(0,b.length-p).replace(/^\u200b+/,""),f[0]=f[0].slice(d).replace(/\u200b+$/,"");var C=E(l,d),S=E(a,h.length?g(h).length-p:0);return f.length>1||f[0]||P(C,S)?(Ei(e.doc,f,C,S,"+input"),!0):void 0},Zs.prototype.ensurePolled=function(){this.forceCompositionEnd()},Zs.prototype.reset=function(){this.forceCompositionEnd()},Zs.prototype.forceCompositionEnd=function(){this.composing&&(clearTimeout(this.readDOMTimeout),this.composing=null,this.updateFromDOM(),this.div.blur(),this.div.focus())},Zs.prototype.readFromDOMSoon=function(){var e=this;null==this.readDOMTimeout&&(this.readDOMTimeout=setTimeout(function(){if(e.readDOMTimeout=null,e.composing){if(!e.composing.done)return;e.composing=null}e.updateFromDOM()},80))},Zs.prototype.updateFromDOM=function(){var e=this;!this.cm.isReadOnly()&&this.pollContent()||hn(this.cm,function(){return vn(e.cm)})},Zs.prototype.setUneditable=function(e){e.contentEditable="false"},Zs.prototype.onKeyPress=function(e){0!=e.charCode&&(e.preventDefault(),this.cm.isReadOnly()||dn(this.cm,$o)(this.cm,String.fromCharCode(null==e.charCode?e.keyCode:e.charCode),0))},Zs.prototype.readOnlyChanged=function(e){this.div.contentEditable=String("nocursor"!=e)},Zs.prototype.onContextMenu=function(){},Zs.prototype.resetPosition=function(){},Zs.prototype.needsContentAttribute=!0;var Qs=function(e){this.cm=e,this.prevInput="",this.pollingFast=!1,this.polling=new Pl,this.hasSelection=!1,this.composing=null};Qs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()});else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type?i.setSelections(t.ranges,null,Gl):(n.prevInput="",l.value=t.text.join("\n"),El(l))}"cut"==e.type&&(i.state.cutIncoming=!0)}}var r=this,n=this,i=this.cm,o=this.wrapper=el(),l=this.textarea=o.firstChild;e.wrapper.insertBefore(o,e.wrapper.firstChild),Ll&&(l.style.width="0px"),Ql(l,"input",function(){gl&&vl>=9&&r.hasSelection&&(r.hasSelection=null),n.poll()}),Ql(l,"paste",function(e){Me(i,e)||qo(e,i)||(i.state.pasteIncoming=!0,n.fastPoll())}),Ql(l,"cut",t),Ql(l,"copy",t),Ql(e.scroller,"paste",function(t){Ft(e,t)||Me(i,t)||(i.state.pasteIncoming=!0,n.focus())}),Ql(e.lineSpace,"selectstart",function(t){Ft(e,t)||We(t)}),Ql(l,"compositionstart",function(){var e=i.getCursor("from");n.composing&&n.composing.range.clear(),n.composing={start:e,range:i.markText(e,i.getCursor("to"),{className:"CodeMirror-composing"})}}),Ql(l,"compositionend",function(){n.composing&&(n.poll(),n.composing.range.clear(),n.composing=null)})},Qs.prototype.prepareSelection=function(){var e=this.cm,t=e.display,r=e.doc,n=Tr(e);if(e.options.moveInputWithCursor){var i=sr(e,r.sel.primary().head,"div"),o=t.wrapper.getBoundingClientRect(),l=t.lineDiv.getBoundingClientRect();n.teTop=Math.max(0,Math.min(t.wrapper.clientHeight-10,i.top+l.top-o.top)),n.teLeft=Math.max(0,Math.min(t.wrapper.clientWidth-10,i.left+l.left-o.left))}return n},Qs.prototype.showSelection=function(e){var t=this.cm.display;r(t.cursorDiv,e.cursors),r(t.selectionDiv,e.selection),null!=e.teTop&&(this.wrapper.style.top=e.teTop+"px",this.wrapper.style.left=e.teLeft+"px")},Qs.prototype.reset=function(e){if(!this.contextMenuPending&&!this.composing){var t=this.cm;if(t.somethingSelected()){this.prevInput="";var r=t.getSelection();this.textarea.value=r,t.state.focused&&El(this.textarea),gl&&vl>=9&&(this.hasSelection=r)}else e||(this.prevInput=this.textarea.value="",gl&&vl>=9&&(this.hasSelection=null))}},Qs.prototype.getField=function(){return this.textarea},Qs.prototype.supportsTouch=function(){return!1},Qs.prototype.focus=function(){if("nocursor"!=this.cm.options.readOnly&&(!Tl||l()!=this.textarea))try{this.textarea.focus()}catch(e){}},Qs.prototype.blur=function(){this.textarea.blur()},Qs.prototype.resetPosition=function(){this.wrapper.style.top=this.wrapper.style.left=0},Qs.prototype.receivedFocus=function(){this.slowPoll()},Qs.prototype.slowPoll=function(){var e=this;this.pollingFast||this.polling.set(this.cm.options.pollInterval,function(){e.poll(),e.cm.state.focused&&e.slowPoll()})},Qs.prototype.fastPoll=function(){function e(){r.poll()||t?(r.pollingFast=!1,r.slowPoll()):(t=!0,r.polling.set(60,e))}var t=!1,r=this;r.pollingFast=!0,r.polling.set(20,e)},Qs.prototype.poll=function(){var e=this,t=this.cm,r=this.textarea,n=this.prevInput;if(this.contextMenuPending||!t.state.focused||ts(r)&&!n&&!this.composing||t.isReadOnly()||t.options.disableInput||t.state.keySeq)return!1;var i=r.value;if(i==n&&!t.somethingSelected())return!1;if(gl&&vl>=9&&this.hasSelection===i||Ml&&/[\uf700-\uf7ff]/.test(i))return t.display.input.reset(),!1;if(t.doc.sel==t.display.selForContextMenu){var o=i.charCodeAt(0);if(8203!=o||n||(n="​"),8666==o)return this.reset(),this.cm.execCommand("undo")}for(var l=0,s=Math.min(n.length,i.length);l<s&&n.charCodeAt(l)==i.charCodeAt(l);)++l;return hn(t,function(){$o(t,i.slice(l),n.length-l,null,e.composing?"*compose":null),i.length>1e3||i.indexOf("\n")>-1?r.value=e.prevInput="":e.prevInput=i,e.composing&&(e.composing.range.clear(),e.composing.range=t.markText(e.composing.start,t.getCursor("to"),{className:"CodeMirror-composing"}))}),!0},Qs.prototype.ensurePolled=function(){this.pollingFast&&this.poll()&&(this.pollingFast=!1)},Qs.prototype.onKeyPress=function(){gl&&vl>=9&&(this.hasSelection=null),this.fastPoll()},Qs.prototype.onContextMenu=function(e){function t(){if(null!=l.selectionStart){var e=i.somethingSelected(),t="​"+(e?l.value:"");l.value="⇚",l.value=t,n.prevInput=e?"":"​",l.selectionStart=1,l.selectionEnd=t.length,o.selForContextMenu=i.doc.sel}}function r(){if(n.contextMenuPending=!1,n.wrapper.style.cssText=c,l.style.cssText=u,gl&&vl<9&&o.scrollbars.setScrollTop(o.scroller.scrollTop=a),null!=l.selectionStart){(!gl||gl&&vl<9)&&t();var e=0,r=function(){o.selForContextMenu==i.doc.sel&&0==l.selectionStart&&l.selectionEnd>0&&"​"==n.prevInput?dn(i,Mi)(i):e++<10?o.detectingSelectAll=setTimeout(r,500):(o.selForContextMenu=null,o.input.reset())};o.detectingSelectAll=setTimeout(r,200)}}var n=this,i=n.cm,o=i.display,l=n.textarea,s=Sr(i,e),a=o.scroller.scrollTop;if(s&&!wl){i.options.resetSelectionOnContextMenu&&-1==i.doc.sel.contains(s)&&dn(i,bi)(i.doc,Rn(s),Gl);var u=l.style.cssText,c=n.wrapper.style.cssText;n.wrapper.style.cssText="position: absolute";var f=n.wrapper.getBoundingClientRect();l.style.cssText="position: absolute; width: 30px; height: 30px;\n      top: "+(e.clientY-f.top-5)+"px; left: "+(e.clientX-f.left-5)+"px;\n      z-index: 1000; background: "+(gl?"rgba(255, 255, 255, .05)":"transparent")+";\n      outline: none; border-width: 0; outline: none; overflow: hidden; opacity: .05; filter: alpha(opacity=5);";var h;if(ml&&(h=window.scrollY),o.input.focus(),ml&&window.scrollTo(null,h),o.input.reset(),i.somethingSelected()||(l.value=n.prevInput=" "),n.contextMenuPending=!0,o.selForContextMenu=i.doc.sel,clearTimeout(o.detectingSelectAll),gl&&vl>=9&&t(),Hl){Fe(e);var d=function(){ke(window,"mouseup",d),setTimeout(r,20)};Ql(window,"mouseup",d)}else setTimeout(r,50)}},Qs.prototype.readOnlyChanged=function(e){e||this.reset(),this.textarea.disabled="nocursor"==e},Qs.prototype.setUneditable=function(){},Qs.prototype.needsContentAttribute=!1,function(e){function t(t,n,i,o){e.defaults[t]=n,i&&(r[t]=o?function(e,t,r){r!=Xs&&i(e,t,r)}:i)}var r=e.optionHandlers;e.defineOption=t,e.Init=Xs,t("value","",function(e,t){return e.setValue(t)},!0),t("mode",null,function(e,t){e.doc.modeOption=t,jn(e)},!0),t("indentUnit",2,jn,!0),t("indentWithTabs",!1),t("smartIndent",!0),t("tabSize",4,function(e){Xn(e),er(e),vn(e)},!0),t("lineSeparator",null,function(e,t){if(e.doc.lineSep=t,t){var r=[],n=e.doc.first;e.doc.iter(function(e){for(var i=0;;){var o=e.text.indexOf(t,i);if(-1==o)break;i=o+t.length,r.push(E(n,o))}n++});for(var i=r.length-1;i>=0;i--)Ei(e.doc,t,r[i],E(r[i].line,r[i].ch+t.length))}}),t("specialChars",/[\u0000-\u001f\u007f-\u009f\u00ad\u061c\u200b-\u200f\u2028\u2029\ufeff]/g,function(e,t,r){e.state.specialChars=new RegExp(t.source+(t.test("\t")?"":"|\t"),"g"),r!=Xs&&e.refresh()}),t("specialCharPlaceholder",at,function(e){return e.refresh()},!0),t("electricChars",!0),t("inputStyle",Tl?"contenteditable":"textarea",function(){throw new Error("inputStyle can not (yet) be changed in a running editor")},!0),t("spellcheck",!1,function(e,t){return e.getInputField().spellcheck=t},!0),t("rtlMoveVisually",!Ol),t("wholeLineUpdateBefore",!0),t("theme","default",function(e){Go(e),Uo(e)},!0),t("keyMap","default",function(e,t,r){var n=uo(t),i=r!=Xs&&uo(r);i&&i.detach&&i.detach(e,n),n.attach&&n.attach(e,i||null)}),t("extraKeys",null),t("configureMouse",null),t("lineWrapping",!1,Ko,!0),t("gutters",[],function(e){Fn(e.options),Uo(e)},!0),t("fixedGutter",!0,function(e,t){e.display.gutters.style.left=t?wr(e.display)+"px":"0",e.refresh()},!0),t("coverGutterNextToScrollbar",!1,function(e){return en(e)},!0),t("scrollbarStyle","native",function(e){rn(e),en(e),e.display.scrollbars.setScrollTop(e.doc.scrollTop),e.display.scrollbars.setScrollLeft(e.doc.scrollLeft)},!0),t("lineNumbers",!1,function(e){Fn(e.options),Uo(e)},!0),t("firstLineNumber",1,Uo,!0),t("lineNumberFormatter",function(e){return e},Uo,!0),t("showCursorWhenSelecting",!1,kr,!0),t("resetSelectionOnContextMenu",!0),t("lineWiseCopyCut",!0),t("pasteLinesPerSelection",!0),t("readOnly",!1,function(e,t){"nocursor"==t&&(Fr(e),e.display.input.blur()),e.display.input.readOnlyChanged(t)}),t("disableInput",!1,function(e,t){t||e.display.input.reset()},!0),t("dragDrop",!0,Vo),t("allowDropFileTypes",null),t("cursorBlinkRate",530),t("cursorScrollMargin",0),t("cursorHeight",1,kr,!0),t("singleCursorHeightPerLine",!0,kr,!0),t("workTime",100),t("workDelay",100),t("flattenSpans",!0,Xn,!0),t("addModeClass",!1,Xn,!0),t("pollInterval",100),t("undoDepth",200,function(e,t){return e.doc.history.undoDepth=t}),t("historyEventDelay",1250),t("viewportMargin",10,function(e){return e.refresh()},!0),t("maxHighlightLength",1e4,Xn,!0),t("moveInputWithCursor",!0,function(e,t){t||e.display.input.resetPosition()}),t("tabindex",null,function(e,t){return e.display.input.getField().tabIndex=t||""}),t("autofocus",null),t("direction","ltr",function(e,t){return e.doc.setDirection(t)},!0)}(jo),function(e){var t=e.optionHandlers,r=e.helpers={};e.prototype={constructor:e,focus:function(){window.focus(),this.display.input.focus()},setOption:function(e,r){var n=this.options,i=n[e];n[e]==r&&"mode"!=e||(n[e]=r,t.hasOwnProperty(e)&&dn(this,t[e])(this,r,i),Te(this,"optionChange",this,e))},getOption:function(e){return this.options[e]},getDoc:function(){return this.doc},addKeyMap:function(e,t){this.state.keyMaps[t?"push":"unshift"](uo(e))},removeKeyMap:function(e){for(var t=this.state.keyMaps,r=0;r<t.length;++r)if(t[r]==e||t[r].name==e)return t.splice(r,1),!0},addOverlay:pn(function(t,r){var n=t.token?t:e.getMode(this.options,t);if(n.startState)throw new Error("Overlays may not be stateful.");m(this.state.overlays,{mode:n,modeSpec:t,opaque:r&&r.opaque,priority:r&&r.priority||0},function(e){return e.priority}),this.state.modeGen++,vn(this)}),removeOverlay:pn(function(e){for(var t=this,r=this.state.overlays,n=0;n<r.length;++n){var i=r[n].modeSpec;if(i==e||"string"==typeof e&&i.name==e)return r.splice(n,1),t.state.modeGen++,void vn(t)}}),indentLine:pn(function(e,t,r){"string"!=typeof t&&"number"!=typeof t&&(t=null==t?this.options.smartIndent?"smart":"prev":t?"add":"subtract"),H(this.doc,e)&&Yo(this,e,t,r)}),indentSelection:pn(function(e){for(var t=this,r=this.doc.sel.ranges,n=-1,i=0;i<r.length;i++){var o=r[i];if(o.empty())o.head.line>n&&(Yo(t,o.head.line,e,!0),n=o.head.line,i==t.doc.sel.primIndex&&jr(t));else{var l=o.from(),s=o.to(),a=Math.max(n,l.line);n=Math.min(t.lastLine(),s.line-(s.ch?0:1))+1;for(var u=a;u<n;++u)Yo(t,u,e);var c=t.doc.sel.ranges;0==l.ch&&r.length==c.length&&c[i].from().ch>0&&gi(t.doc,i,new Ts(l,c[i].to()),Gl)}}}),getTokenAt:function(e,t){return Je(this,e,t)},getLineTokens:function(e,t){return Je(this,E(e),t,!0)},getTokenTypeAt:function(e){e=U(this.doc,e);var t,r=_e(this,M(this.doc,e.line)),n=0,i=(r.length-1)/2,o=e.ch;if(0==o)t=r[2];else for(;;){var l=n+i>>1;if((l?r[2*l-1]:0)>=o)i=l;else{if(!(r[2*l+1]<o)){t=r[2*l+2];break}n=l+1}}var s=t?t.indexOf("overlay "):-1;return s<0?t:0==s?null:t.slice(0,s-1)},getModeAt:function(t){var r=this.doc.mode;return r.innerMode?e.innerMode(r,this.getTokenAt(t).state).mode:r},getHelper:function(e,t){return this.getHelpers(e,t)[0]},getHelpers:function(e,t){var n=this,i=[];if(!r.hasOwnProperty(t))return i;var o=r[t],l=this.getModeAt(e);if("string"==typeof l[t])o[l[t]]&&i.push(o[l[t]]);else if(l[t])for(var s=0;s<l[t].length;s++){var a=o[l[t][s]];a&&i.push(a)}else l.helperType&&o[l.helperType]?i.push(o[l.helperType]):o[l.name]&&i.push(o[l.name]);for(var u=0;u<o._global.length;u++){var c=o._global[u];c.pred(l,n)&&-1==h(i,c.val)&&i.push(c.val)}return i},getStateAfter:function(e,t){var r=this.doc;return e=G(r,null==e?r.first+r.size-1:e),$e(this,e+1,t).state},cursorCoords:function(e,t){var r,n=this.doc.sel.primary();return r=null==e?n.head:"object"==typeof e?U(this.doc,e):e?n.from():n.to(),sr(this,r,t||"page")},charCoords:function(e,t){return lr(this,U(this.doc,e),t||"page")},coordsChar:function(e,t){return e=or(this,e,t||"page"),cr(this,e.left,e.top)},lineAtHeight:function(e,t){return e=or(this,{top:e,left:0},t||"page").top,D(this.doc,e+this.display.viewOffset)},heightAtLine:function(e,t,r){var n,i=!1;if("number"==typeof e){var o=this.doc.first+this.doc.size-1;e<this.doc.first?e=this.doc.first:e>o&&(e=o,i=!0),n=M(this.doc,e)}else n=e;return ir(this,n,{top:0,left:0},t||"page",r||i).top+(i?this.doc.height-ye(n):0)},defaultTextHeight:function(){return mr(this.display)},defaultCharWidth:function(){return yr(this.display)},getViewport:function(){return{from:this.display.viewFrom,to:this.display.viewTo}},addWidget:function(e,t,r,n,i){var o=this.display,l=(e=sr(this,U(this.doc,e))).bottom,s=e.left;if(t.style.position="absolute",t.setAttribute("cm-ignore-events","true"),this.display.input.setUneditable(t),o.sizer.appendChild(t),"over"==n)l=e.top;else if("above"==n||"near"==n){var a=Math.max(o.wrapper.clientHeight,this.doc.height),u=Math.max(o.sizer.clientWidth,o.lineSpace.clientWidth);("above"==n||e.bottom+t.offsetHeight>a)&&e.top>t.offsetHeight?l=e.top-t.offsetHeight:e.bottom+t.offsetHeight<=a&&(l=e.bottom),s+t.offsetWidth>u&&(s=u-t.offsetWidth)}t.style.top=l+"px",t.style.left=t.style.right="","right"==i?(s=o.sizer.clientWidth-t.offsetWidth,t.style.right="0px"):("left"==i?s=0:"middle"==i&&(s=(o.sizer.clientWidth-t.offsetWidth)/2),t.style.left=s+"px"),r&&Ur(this,{left:s,top:l,right:s+t.offsetWidth,bottom:l+t.offsetHeight})},triggerOnKeyDown:pn(Lo),triggerOnKeyPress:pn(Mo),triggerOnKeyUp:To,triggerOnMouseDown:pn(Oo),execCommand:function(e){if(Bs.hasOwnProperty(e))return Bs[e].call(null,this)},triggerElectric:pn(function(e){Zo(this,e)}),findPosH:function(e,t,r,n){var i=this,o=1;t<0&&(o=-1,t=-t);for(var l=U(this.doc,e),s=0;s<t&&!(l=tl(i.doc,l,o,r,n)).hitSide;++s);return l},moveH:pn(function(e,t){var r=this;this.extendSelectionsBy(function(n){return r.display.shift||r.doc.extend||n.empty()?tl(r.doc,n.head,e,t,r.options.rtlMoveVisually):e<0?n.from():n.to()},Vl)}),deleteH:pn(function(e,t){var r=this.doc.sel,n=this.doc;r.somethingSelected()?n.replaceSelection("",null,"+delete"):co(this,function(r){var i=tl(n,r.head,e,t,!1);return e<0?{from:i,to:r.head}:{from:r.head,to:i}})}),findPosV:function(e,t,r,n){var i=this,o=1,l=n;t<0&&(o=-1,t=-t);for(var s=U(this.doc,e),a=0;a<t;++a){var u=sr(i,s,"div");if(null==l?l=u.left:u.left=l,(s=rl(i,u,o,r)).hitSide)break}return s},moveV:pn(function(e,t){var r=this,n=this.doc,i=[],o=!this.display.shift&&!n.extend&&n.sel.somethingSelected();if(n.extendSelectionsBy(function(l){if(o)return e<0?l.from():l.to();var s=sr(r,l.head,"div");null!=l.goalColumn&&(s.left=l.goalColumn),i.push(s.left);var a=rl(r,s,e,t);return"page"==t&&l==n.sel.primary()&&Kr(r,lr(r,a,"div").top-s.top),a},Vl),i.length)for(var l=0;l<n.sel.ranges.length;l++)n.sel.ranges[l].goalColumn=i[l]}),findWordAt:function(e){var t=M(this.doc,e.line).text,r=e.ch,n=e.ch;if(t){var i=this.getHelper(e,"wordChars");"before"!=e.sticky&&n!=t.length||!r?++n:--r;for(var o=t.charAt(r),l=x(o,i)?function(e){return x(e,i)}:/\s/.test(o)?function(e){return/\s/.test(e)}:function(e){return!/\s/.test(e)&&!x(e)};r>0&&l(t.charAt(r-1));)--r;for(;n<t.length&&l(t.charAt(n));)++n}return new Ts(E(e.line,r),E(e.line,n))},toggleOverwrite:function(e){null!=e&&e==this.state.overwrite||((this.state.overwrite=!this.state.overwrite)?s(this.display.cursorDiv,"CodeMirror-overwrite"):Fl(this.display.cursorDiv,"CodeMirror-overwrite"),Te(this,"overwriteToggle",this,this.state.overwrite))},hasFocus:function(){return this.display.input.getField()==l()},isReadOnly:function(){return!(!this.options.readOnly&&!this.doc.cantEdit)},scrollTo:pn(function(e,t){Xr(this,e,t)}),getScrollInfo:function(){var e=this.display.scroller;return{left:e.scrollLeft,top:e.scrollTop,height:e.scrollHeight-zt(this)-this.display.barHeight,width:e.scrollWidth-zt(this)-this.display.barWidth,clientHeight:Bt(this),clientWidth:Rt(this)}},scrollIntoView:pn(function(e,t){null==e?(e={from:this.doc.sel.primary().head,to:null},null==t&&(t=this.options.cursorScrollMargin)):"number"==typeof e?e={from:E(e,0),to:null}:null==e.from&&(e={from:e,to:null}),e.to||(e.to=e.from),e.margin=t||0,null!=e.from.line?Yr(this,e):$r(this,e.from,e.to,e.margin)}),setSize:pn(function(e,t){var r=this,n=function(e){return"number"==typeof e||/^\d+$/.test(String(e))?e+"px":e};null!=e&&(this.display.wrapper.style.width=n(e)),null!=t&&(this.display.wrapper.style.height=n(t)),this.options.lineWrapping&&Jt(this);var i=this.display.viewFrom;this.doc.iter(i,this.display.viewTo,function(e){if(e.widgets)for(var t=0;t<e.widgets.length;t++)if(e.widgets[t].noHScroll){mn(r,i,"widget");break}++i}),this.curOp.forceUpdate=!0,Te(this,"refresh",this)}),operation:function(e){return hn(this,e)},startOperation:function(){return nn(this)},endOperation:function(){return on(this)},refresh:pn(function(){var e=this.display.cachedTextHeight;vn(this),this.curOp.forceUpdate=!0,er(this),Xr(this,this.doc.scrollLeft,this.doc.scrollTop),Wn(this),(null==e||Math.abs(e-mr(this.display))>.5)&&Cr(this),Te(this,"refresh",this)}),swapDoc:pn(function(e){var t=this.doc;return t.cm=null,qn(this,e),er(this),this.display.input.reset(),Xr(this,e.scrollLeft,e.scrollTop),this.curOp.forceScroll=!0,bt(this,"swapDoc",this,t),t}),getInputField:function(){return this.display.input.getField()},getWrapperElement:function(){return this.display.wrapper},getScrollerElement:function(){return this.display.scroller},getGutterElement:function(){return this.display.gutters}},Ae(e),e.registerHelper=function(t,n,i){r.hasOwnProperty(t)||(r[t]=e[t]={_global:[]}),r[t][n]=i},e.registerGlobalHelper=function(t,n,i,o){e.registerHelper(t,n,o),r[t]._global.push({pred:i,val:o})}}(jo);var Js="iter insert remove copy getEditor constructor".split(" ");for(var ea in Ds.prototype)Ds.prototype.hasOwnProperty(ea)&&h(Js,ea)<0&&(jo.prototype[ea]=function(e){return function(){return e.apply(this.doc,arguments)}}(Ds.prototype[ea]));return Ae(Ds),jo.inputStyles={textarea:Qs,contenteditable:Zs},jo.defineMode=function(e){jo.defaults.mode||"null"==e||(jo.defaults.mode=e),Be.apply(this,arguments)},jo.defineMIME=function(e,t){os[e]=t},jo.defineMode("null",function(){return{token:function(e){return e.skipToEnd()}}}),jo.defineMIME("text/plain","null"),jo.defineExtension=function(e,t){jo.prototype[e]=t},jo.defineDocExtension=function(e,t){Ds.prototype[e]=t},jo.fromTextArea=function(e,t){function r(){e.value=a.getValue()}if(t=t?c(t):{},t.value=e.value,!t.tabindex&&e.tabIndex&&(t.tabindex=e.tabIndex),!t.placeholder&&e.placeholder&&(t.placeholder=e.placeholder),null==t.autofocus){var n=l();t.autofocus=n==e||null!=e.getAttribute("autofocus")&&n==document.body}var i;if(e.form&&(Ql(e.form,"submit",r),!t.leaveSubmitMethodAlone)){var o=e.form;i=o.submit;try{var s=o.submit=function(){r(),o.submit=i,o.submit(),o.submit=s}}catch(e){}}t.finishInit=function(t){t.save=r,t.getTextArea=function(){return e},t.toTextArea=function(){t.toTextArea=isNaN,r(),e.parentNode.removeChild(t.getWrapperElement()),e.style.display="",e.form&&(ke(e.form,"submit",r),"function"==typeof e.form.submit&&(e.form.submit=i))}},e.style.display="none";var a=jo(function(t){return e.parentNode.insertBefore(t,e.nextSibling)},t);return a},function(e){e.off=ke,e.on=Ql,e.wheelEventPixels=Pn,e.Doc=Ds,e.splitLines=es,e.countColumn=f,e.findColumn=d,e.isWordChar=w,e.Pass=Bl,e.signal=Te,e.Line=fs,e.changeEnd=Bn,e.scrollbarModel=ws,e.Pos=E,e.cmpPos=P,e.modes=is,e.mimeModes=os,e.resolveMode=Ge,e.getMode=Ue,e.modeExtensions=ls,e.extendMode=Ve,e.copyState=Ke,e.startState=Xe,e.innerMode=je,e.commands=Bs,e.keyMap=Rs,e.keyName=ao,e.isModifierKey=lo,e.lookupKey=oo,e.normalizeKeyMap=io,e.StringStream=ss,e.SharedTextMarker=As,e.TextMarker=Os,e.LineWidget=Ms,e.e_preventDefault=We,e.e_stopPropagation=De,e.e_stop=Fe,e.addClass=s,e.contains=o,e.rmClass=Fl,e.keyNames=Es}(jo),jo.version="5.30.0",jo});
      !function(e){"object"==typeof exports&&"object"==typeof module?e(require("../../lib/codemirror")):"function"==typeof define&&define.amd?define(["../../lib/codemirror"],e):e(CodeMirror)}(function(e){"use strict";function t(e,t,n,r,o,a){this.indented=e,this.column=t,this.type=n,this.info=r,this.align=o,this.prev=a}function n(e,n,r,o){var a=e.indented;return e.context&&"statement"==e.context.type&&"statement"!=r&&(a=e.context.indented),e.context=new t(a,n,r,o,null,e.context)}function r(e){var t=e.context.type;return")"!=t&&"]"!=t&&"}"!=t||(e.indented=e.context.indented),e.context=e.context.prev}function o(e,t,n){return"variable"==t.prevToken||"type"==t.prevToken||(!!/\S(?:[^- ]>|[*\]])\s*$|\*$/.test(e.string.slice(0,n))||(!(!t.typeAtEndOfLine||e.column()!=e.indentation())||void 0))}function a(e){for(;;){if(!e||"top"==e.type)return!0;if("}"==e.type&&"namespace"!=e.prev.info)return!1;e=e.prev}}function i(e){for(var t={},n=e.split(" "),r=0;r<n.length;++r)t[n[r]]=!0;return t}function l(e,t){return"function"==typeof e?e(t):e.propertyIsEnumerable(t)}function s(e,t){if(!t.startOfLine)return!1;for(var n,r=null;n=e.peek();){if("\\"==n&&e.match(/^.$/)){r=s;break}if("/"==n&&e.match(/^\/[\/\*]/,!1))break;e.next()}return t.tokenize=r,"meta"}function c(e,t){return"type"==t.prevToken&&"type"}function u(e){return e.eatWhile(/[\w\.']/),"number"}function d(e,t){if(e.backUp(1),e.match(/(R|u8R|uR|UR|LR)/)){var n=e.match(/"([^\s\\()]{0,16})\(/);return!!n&&(t.cpp11RawStringDelim=n[1],t.tokenize=m,m(e,t))}return e.match(/(u8|u|U|L)/)?!!e.match(/["']/,!1)&&"string":(e.next(),!1)}function f(e){var t=/(\w+)::~?(\w+)$/.exec(e);return t&&t[1]==t[2]}function p(e,t){for(var n;null!=(n=e.next());)if('"'==n&&!e.eat('"')){t.tokenize=null;break}return"string"}function m(e,t){var n=t.cpp11RawStringDelim.replace(/[^\w\s]/g,"\\$&");return e.match(new RegExp(".*?\\)"+n+'"'))?t.tokenize=null:e.skipToEnd(),"string"}function h(t,n){function r(e){if(e)for(var t in e)e.hasOwnProperty(t)&&o.push(t)}"string"==typeof t&&(t=[t]);var o=[];r(n.keywords),r(n.types),r(n.builtin),r(n.atoms),o.length&&(n.helperType=t[0],e.registerHelper("hintWords",t[0],o));for(var a=0;a<t.length;++a)e.defineMIME(t[a],n)}function g(e,t){for(var n=!1;!e.eol();){if(!n&&e.match('"""')){t.tokenize=null;break}n="\\"==e.next()&&!n}return"string"}function y(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!e&&!o&&t.match('"')){a=!0;break}if(e&&t.match('"""')){a=!0;break}r=t.next(),!o&&"$"==r&&t.match("{")&&t.skipTo("}"),o=!o&&"\\"==r&&!e}return!a&&e||(n.tokenize=null),"string"}}function x(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!o&&t.match('"')&&("single"==e||t.match('""'))){a=!0;break}if(!o&&t.match("``")){w=x(e),a=!0;break}r=t.next(),o="single"==e&&!o&&"\\"==r}return a&&(n.tokenize=null),"string"}}e.defineMode("clike",function(i,s){function c(e,t){var n=e.next();if(S[n]){var r=S[n](e,t);if(!1!==r)return r}if('"'==n||"'"==n)return t.tokenize=u(n),t.tokenize(e,t);if(D.test(n))return p=n,null;if(L.test(n)){if(e.backUp(1),e.match(I))return"number";e.next()}if("/"==n){if(e.eat("*"))return t.tokenize=d,d(e,t);if(e.eat("/"))return e.skipToEnd(),"comment"}if(F.test(n)){for(;!e.match(/^\/[\/*]/,!1)&&e.eat(F););return"operator"}if(e.eatWhile(z),P)for(;e.match(P);)e.eatWhile(z);var o=e.current();return l(x,o)?(l(w,o)&&(p="newstatement"),l(v,o)&&(m=!0),"keyword"):l(b,o)?"type":l(k,o)?(l(w,o)&&(p="newstatement"),"builtin"):l(_,o)?"atom":"variable"}function u(e){return function(t,n){for(var r,o=!1,a=!1;null!=(r=t.next());){if(r==e&&!o){a=!0;break}o=!o&&"\\"==r}return(a||!o&&!C)&&(n.tokenize=null),"string"}}function d(e,t){for(var n,r=!1;n=e.next();){if("/"==n&&r){t.tokenize=null;break}r="*"==n}return"comment"}function f(e,t){s.typeFirstDefinitions&&e.eol()&&a(t.context)&&(t.typeAtEndOfLine=o(e,t,e.pos))}var p,m,h=i.indentUnit,g=s.statementIndentUnit||h,y=s.dontAlignCalls,x=s.keywords||{},b=s.types||{},k=s.builtin||{},w=s.blockKeywords||{},v=s.defKeywords||{},_=s.atoms||{},S=s.hooks||{},C=s.multiLineStrings,T=!1!==s.indentStatements,M=!1!==s.indentSwitch,P=s.namespaceSeparator,D=s.isPunctuationChar||/[\[\]{}\(\),;\:\.]/,L=s.numberStart||/[\d\.]/,I=s.number||/^(?:0x[a-f\d]+|0b[01]+|(?:\d+\.?\d*|\.\d+)(?:e[-+]?\d+)?)(u|ll?|l|f)?/i,F=s.isOperatorChar||/[+\-*&%=<>!?|\/]/,z=s.isIdentifierChar||/[\w\$_\xa1-\uffff]/;return{startState:function(e){return{tokenize:null,context:new t((e||0)-h,0,"top",null,!1),indented:0,startOfLine:!0,prevToken:null}},token:function(e,t){var i=t.context;if(e.sol()&&(null==i.align&&(i.align=!1),t.indented=e.indentation(),t.startOfLine=!0),e.eatSpace())return f(e,t),null;p=m=null;var l=(t.tokenize||c)(e,t);if("comment"==l||"meta"==l)return l;if(null==i.align&&(i.align=!0),";"==p||":"==p||","==p&&e.match(/^\s*(?:\/\/.*)?$/,!1))for(;"statement"==t.context.type;)r(t);else if("{"==p)n(t,e.column(),"}");else if("["==p)n(t,e.column(),"]");else if("("==p)n(t,e.column(),")");else if("}"==p){for(;"statement"==i.type;)i=r(t);for("}"==i.type&&(i=r(t));"statement"==i.type;)i=r(t)}else p==i.type?r(t):T&&(("}"==i.type||"top"==i.type)&&";"!=p||"statement"==i.type&&"newstatement"==p)&&n(t,e.column(),"statement",e.current());if("variable"==l&&("def"==t.prevToken||s.typeFirstDefinitions&&o(e,t,e.start)&&a(t.context)&&e.match(/^\s*\(/,!1))&&(l="def"),S.token){var u=S.token(e,t,l);void 0!==u&&(l=u)}return"def"==l&&!1===s.styleDefs&&(l="variable"),t.startOfLine=!1,t.prevToken=m?"def":l||p,f(e,t),l},indent:function(t,n){if(t.tokenize!=c&&null!=t.tokenize||t.typeAtEndOfLine)return e.Pass;var r=t.context,o=n&&n.charAt(0);if("statement"==r.type&&"}"==o&&(r=r.prev),s.dontIndentStatements)for(;"statement"==r.type&&s.dontIndentStatements.test(r.info);)r=r.prev;if(S.indent){var a=S.indent(t,r,n);if("number"==typeof a)return a}var i=o==r.type,l=r.prev&&"switch"==r.prev.info;if(s.allmanIndentation&&/[{(]/.test(o)){for(;"top"!=r.type&&"}"!=r.type;)r=r.prev;return r.indented}return"statement"==r.type?r.indented+("{"==o?0:g):!r.align||y&&")"==r.type?")"!=r.type||i?r.indented+(i?0:h)+(i||!l||/^(?:case|default)\b/.test(n)?0:h):r.indented+g:r.column+(i?0:1)},electricInput:M?/^\s*(?:case .*?:|default:|\{\}?|\})$/:/^\s*[{}]$/,blockCommentStart:"/*",blockCommentEnd:"*/",lineComment:"//",fold:"brace"}});var b="auto if break case register continue return default do sizeof static else struct switch extern typedef union for goto while enum const volatile",k="int long char short double float unsigned signed void size_t ptrdiff_t";h(["text/x-csrc","text/x-c","text/x-chdr"],{name:"clike",keywords:i(b),types:i(k+" bool _Complex _Bool float_t double_t intptr_t intmax_t int8_t int16_t int32_t int64_t uintptr_t uintmax_t uint8_t uint16_t uint32_t uint64_t"),blockKeywords:i("case do else for if switch while struct"),defKeywords:i("struct"),typeFirstDefinitions:!0,atoms:i("null true false"),hooks:{"#":s,"*":c},modeProps:{fold:["brace","include"]}}),h(["text/x-c++src","text/x-c++hdr"],{name:"clike",keywords:i(b+" asm dynamic_cast namespace reinterpret_cast try explicit new static_cast typeid catch operator template typename class friend private this using const_cast inline public throw virtual delete mutable protected alignas alignof constexpr decltype nullptr noexcept thread_local final static_assert override"),types:i(k+" bool wchar_t"),blockKeywords:i("catch class do else finally for if struct switch try while"),defKeywords:i("class namespace struct enum union"),typeFirstDefinitions:!0,atoms:i("true false null"),dontIndentStatements:/^template$/,isIdentifierChar:/[\w\$_~\xa1-\uffff]/,hooks:{"#":s,"*":c,u:d,U:d,L:d,R:d,0:u,1:u,2:u,3:u,4:u,5:u,6:u,7:u,8:u,9:u,token:function(e,t,n){if("variable"==n&&"("==e.peek()&&(";"==t.prevToken||null==t.prevToken||"}"==t.prevToken)&&f(e.current()))return"def"}},namespaceSeparator:"::",modeProps:{fold:["brace","include"]}}),h("text/x-java",{name:"clike",keywords:i("abstract assert break case catch class const continue default do else enum extends final finally float for goto if implements import instanceof interface native new package private protected public return static strictfp super switch synchronized this throw throws transient try volatile while @interface"),types:i("byte short int long float double boolean char void Boolean Byte Character Double Float Integer Long Number Object Short String StringBuffer StringBuilder Void"),blockKeywords:i("catch class do else finally for if switch try while"),defKeywords:i("class interface package enum @interface"),typeFirstDefinitions:!0,atoms:i("true false null"),number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,hooks:{"@":function(e){return!e.match("interface",!1)&&(e.eatWhile(/[\w\$_]/),"meta")}},modeProps:{fold:["brace","import"]}}),h("text/x-csharp",{name:"clike",keywords:i("abstract as async await base break case catch checked class const continue default delegate do else enum event explicit extern finally fixed for foreach goto if implicit in interface internal is lock namespace new operator out override params private protected public readonly ref return sealed sizeof stackalloc static struct switch this throw try typeof unchecked unsafe using virtual void volatile while add alias ascending descending dynamic from get global group into join let orderby partial remove select set value var yield"),types:i("Action Boolean Byte Char DateTime DateTimeOffset Decimal Double Func Guid Int16 Int32 Int64 Object SByte Single String Task TimeSpan UInt16 UInt32 UInt64 bool byte char decimal double short int long object sbyte float string ushort uint ulong"),blockKeywords:i("catch class do else finally for foreach if struct switch try while"),defKeywords:i("class interface namespace struct var"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"@":function(e,t){return e.eat('"')?(t.tokenize=p,p(e,t)):(e.eatWhile(/[\w\$_]/),"meta")}}}),h("text/x-scala",{name:"clike",keywords:i("abstract case catch class def do else extends final finally for forSome if implicit import lazy match new null object override package private protected return sealed super this throw trait try type val var while with yield _ assert assume require print println printf readLine readBoolean readByte readShort readChar readInt readLong readFloat readDouble"),types:i("AnyVal App Application Array BufferedIterator BigDecimal BigInt Char Console Either Enumeration Equiv Error Exception Fractional Function IndexedSeq Int Integral Iterable Iterator List Map Numeric Nil NotNull Option Ordered Ordering PartialFunction PartialOrdering Product Proxy Range Responder Seq Serializable Set Specializable Stream StringBuilder StringContext Symbol Throwable Traversable TraversableOnce Tuple Unit Vector Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),multiLineStrings:!0,blockKeywords:i("catch class enum do else finally for forSome if match switch try while"),defKeywords:i("class enum def object package trait type val var"),atoms:i("true false null"),indentStatements:!1,indentSwitch:!1,isOperatorChar:/[+\-*&%=<>!?|\/#:@]/,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return!!e.match('""')&&(t.tokenize=g,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},"=":function(e,n){var r=n.context;return!("}"!=r.type||!r.align||!e.eat(">"))&&(n.context=new t(r.indented,r.column,r.type,r.info,null,r.prev),"operator")}},modeProps:{closeBrackets:{triples:'"'}}}),h("text/x-kotlin",{name:"clike",keywords:i("package as typealias class interface this super val var fun for is in This throw return break continue object if else while do try when !in !is as? file import where by get set abstract enum open inner override private public internal protected catch finally out final vararg reified dynamic companion constructor init sealed field property receiver param sparam lateinit data inline noinline tailrec external annotation crossinline const operator infix suspend"),types:i("Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),intendSwitch:!1,indentStatements:!1,multiLineStrings:!0,number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,blockKeywords:i("catch class do else finally for if where try while enum"),defKeywords:i("class val var object package interface fun"),atoms:i("true false null this"),hooks:{'"':function(e,t){return t.tokenize=y(e.match('""')),t.tokenize(e,t)}},modeProps:{closeBrackets:{triples:'"'}}}),h(["x-shader/x-vertex","x-shader/x-fragment"],{name:"clike",keywords:i("sampler1D sampler2D sampler3D samplerCube sampler1DShadow sampler2DShadow const attribute uniform varying break continue discard return for while do if else struct in out inout"),types:i("float int bool void vec2 vec3 vec4 ivec2 ivec3 ivec4 bvec2 bvec3 bvec4 mat2 mat3 mat4"),blockKeywords:i("for while do if else struct"),builtin:i("radians degrees sin cos tan asin acos atan pow exp log exp2 sqrt inversesqrt abs sign floor ceil fract mod min max clamp mix step smoothstep length distance dot cross normalize ftransform faceforward reflect refract matrixCompMult lessThan lessThanEqual greaterThan greaterThanEqual equal notEqual any all not texture1D texture1DProj texture1DLod texture1DProjLod texture2D texture2DProj texture2DLod texture2DProjLod texture3D texture3DProj texture3DLod texture3DProjLod textureCube textureCubeLod shadow1D shadow2D shadow1DProj shadow2DProj shadow1DLod shadow2DLod shadow1DProjLod shadow2DProjLod dFdx dFdy fwidth noise1 noise2 noise3 noise4"),atoms:i("true false gl_FragColor gl_SecondaryColor gl_Normal gl_Vertex gl_MultiTexCoord0 gl_MultiTexCoord1 gl_MultiTexCoord2 gl_MultiTexCoord3 gl_MultiTexCoord4 gl_MultiTexCoord5 gl_MultiTexCoord6 gl_MultiTexCoord7 gl_FogCoord gl_PointCoord gl_Position gl_PointSize gl_ClipVertex gl_FrontColor gl_BackColor gl_FrontSecondaryColor gl_BackSecondaryColor gl_TexCoord gl_FogFragCoord gl_FragCoord gl_FrontFacing gl_FragData gl_FragDepth gl_ModelViewMatrix gl_ProjectionMatrix gl_ModelViewProjectionMatrix gl_TextureMatrix gl_NormalMatrix gl_ModelViewMatrixInverse gl_ProjectionMatrixInverse gl_ModelViewProjectionMatrixInverse gl_TexureMatrixTranspose gl_ModelViewMatrixInverseTranspose gl_ProjectionMatrixInverseTranspose gl_ModelViewProjectionMatrixInverseTranspose gl_TextureMatrixInverseTranspose gl_NormalScale gl_DepthRange gl_ClipPlane gl_Point gl_FrontMaterial gl_BackMaterial gl_LightSource gl_LightModel gl_FrontLightModelProduct gl_BackLightModelProduct gl_TextureColor gl_EyePlaneS gl_EyePlaneT gl_EyePlaneR gl_EyePlaneQ gl_FogParameters gl_MaxLights gl_MaxClipPlanes gl_MaxTextureUnits gl_MaxTextureCoords gl_MaxVertexAttribs gl_MaxVertexUniformComponents gl_MaxVaryingFloats gl_MaxVertexTextureImageUnits gl_MaxTextureImageUnits gl_MaxFragmentUniformComponents gl_MaxCombineTextureImageUnits gl_MaxDrawBuffers"),indentSwitch:!1,hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-nesc",{name:"clike",keywords:i(b+"as atomic async call command component components configuration event generic implementation includes interface module new norace nx_struct nx_union post provides signal task uses abstract extends"),types:i(k),blockKeywords:i("case do else for if switch while struct"),atoms:i("null true false"),hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-objectivec",{name:"clike",keywords:i(b+"inline restrict _Bool _Complex _Imaginary BOOL Class bycopy byref id IMP in inout nil oneway out Protocol SEL self super atomic nonatomic retain copy readwrite readonly"),types:i(k),atoms:i("YES NO NULL NILL ON OFF true false"),hooks:{"@":function(e){return e.eatWhile(/[\w\$]/),"keyword"},"#":s,indent:function(e,t,n){if("statement"==t.type&&/^@\w/.test(n))return t.indented}},modeProps:{fold:"brace"}}),h("text/x-squirrel",{name:"clike",keywords:i("base break clone continue const default delete enum extends function in class foreach local resume return this throw typeof yield constructor instanceof static"),types:i(k),blockKeywords:i("case catch class else for foreach if switch try while"),defKeywords:i("function local class"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"#":s},modeProps:{fold:["brace","include"]}});var w=null;h("text/x-ceylon",{name:"clike",keywords:i("abstracts alias assembly assert assign break case catch class continue dynamic else exists extends finally for function given if import in interface is let module new nonempty object of out outer package return satisfies super switch then this throw try value void while"),types:function(e){var t=e.charAt(0);return t===t.toUpperCase()&&t!==t.toLowerCase()},blockKeywords:i("case catch class dynamic else finally for function if interface module new object switch try while"),defKeywords:i("class dynamic function interface module object package value"),builtin:i("abstract actual aliased annotation by default deprecated doc final formal late license native optional sealed see serializable shared suppressWarnings tagged throws variable"),isPunctuationChar:/[\[\]{}\(\),;\:\.`]/,isOperatorChar:/[+\-*&%=<>!?|^~:\/]/,numberStart:/[\d#$]/,number:/^(?:#[\da-fA-F_]+|\$[01_]+|[\d_]+[kMGTPmunpf]?|[\d_]+\.[\d_]+(?:[eE][-+]?\d+|[kMGTPmunpf]|)|)/i,multiLineStrings:!0,typeFirstDefinitions:!0,atoms:i("true false null larger smaller equal empty finished"),indentSwitch:!1,styleDefs:!1,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return t.tokenize=x(e.match('""')?"triple":"single"),t.tokenize(e,t)},"`":function(e,t){return!(!w||!e.match("`"))&&(t.tokenize=w,w=null,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},token:function(e,t,n){if(("variable"==n||"type"==n)&&"."==t.prevToken)return"variable-2"}},modeProps:{fold:["brace","import"],closeBrackets:{triples:'"'}}})});
      // -------------------------------------------------------------------------
//  Part of the CodeChecker project, under the Apache License v2.0 with
//  LLVM Exceptions. See LICENSE for license information.
//  SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
// -------------------------------------------------------------------------

var BugViewer = {
  _files : [],
  _reports : [],
  _lineWidgets : [],
  _navigationMenuItems : [],
  _sourceFileData : null,
  _currentReport : null,
  _lastBugEvent  : null,

  init : function (files, reports) {
    this._files = files;
    this._reports = reports;

    this.initEscapeChars();
  },

  initEscapeChars : function () {
    this.escapeChars = {
      ' ' : 'nbsp',
      '<' : 'lt',
      '>' : 'gt',
      '"' : 'quot',
      '&' : 'amp'
    };

    var regexString = '[';
    for (var key in this.escapeChars) {
      regexString += key;
    }
    regexString += ']';

    this.escapeRegExp = new RegExp( regexString, 'g');
  },

  escapeHTML : function (str) {
    var that = this;

    return str.replace(this.escapeRegExp, function (m) {
      return '&' + that.escapeChars[m] + ';';
    });
  },

  initByUrl : function () {
    if (!this._reports) return;

    var state = {};
    window.location.hash.substr(1).split('&').forEach(function (s) {
      var parts = s.split('=');
      state[parts[0]] = parts[1];
    });

    for (var key in this._reports) {
      var report = this._reports[key];
      if (report.reportHash === state['reportHash']) {
        this.navigate(report);
        return;
      }
    }

    this.navigate(this._reports[0]);
  },

  create : function () {
    this._content = document.getElementById('editor-wrapper');
    this._filepath = document.getElementById('file-path');
    this._checkerName = document.getElementById('checker-name');
    this._reviewStatusWrapper =
      document.getElementById('review-status-wrapper');
    this._reviewStatus = document.getElementById('review-status');
    this._editor = document.getElementById('editor');

    this._codeMirror = CodeMirror(this._editor, {
      mode: 'text/x-c++src',
      matchBrackets : true,
      lineNumbers : true,
      readOnly : true,
      foldGutter : true,
      extraKeys : {},
      viewportMargin : 100
    });

    this._createNavigationMenu();
  },

  navigate : function (report, item) {
    if (!item) {
      var items = this._navigationMenuItems.filter(function (navItem) {
        return navItem.report.reportHash === report.reportHash;
      });

      if (!items.length) return;

      item = items[0].widget;
    }

    this._selectedReport.classList.remove('active');
    this._selectedReport = item;
    this._selectedReport.classList.add('active');
    this.setReport(report);
  },

  _createNavigationMenu : function () {
    var that = this;

    var nav = document.getElementById('report-nav');
    var list = document.createElement('ul');
    this._reports.forEach(function (report) {
      var events = report['events'];
      var lastBugEvent = events[events.length - 1];
      var item = document.createElement('li');

      var severity = document.createElement('i');
      severity.className = 'severity-' + report.severity.toLowerCase();

      item.appendChild(severity);
      item.appendChild(document.createTextNode(lastBugEvent.message));

      item.addEventListener('click', function () {
        that.navigate(report, item);
      })
      list.appendChild(item);
      that._navigationMenuItems.push({ report : report, widget : item });
    });

    if (!this._selectedReport && list.childNodes.length) {
      this._selectedReport = list.childNodes[0];
      this._selectedReport.classList.add('active');
    }

    nav.appendChild(list);
  },

  setReport : function (report) {
    this._currentReport = report;
    var events = report['events'];
    var lastBugEvent = events[events.length - 1];
    this.setCurrentBugEvent(lastBugEvent, events.length - 1);
    this.setCheckerName(report.checkerName);
    this.setReviewStatus(report.reviewStatus);

    window.location.hash = '#reportHash=' + report.reportHash;
  },

  setCurrentBugEvent : function (event, idx) {
    this._currentBugEvent = event;
    this.setSourceFileData(this._files[event.location.file]);
    this.drawBugPath();

    this.jumpTo(event.location.line, 0);
    this.highlightBugEvent(event, idx);
  },

  highlightBugEvent : function (event, idx) {
    this._lineWidgets.forEach(function (widget) {
      var lineIdx = widget.node.getAttribute('idx');
      if (parseInt(lineIdx) === idx) {
        widget.node.classList.add('current');
      }
    });
  },

  setCheckerName : function (checkerName) {
    this._checkerName.innerHTML = checkerName;
  },

  setReviewStatus : function (status) {
    if (status) {
      var className =
        'review-status-' + status.toLowerCase().split(' ').join('-');
      this._reviewStatus.className = "review-status " + className;

      this._reviewStatus.innerHTML = status;
      this._reviewStatusWrapper.style.display = 'block';
    } else {
      this._reviewStatusWrapper.style.display = 'none';
    }
  },

  setSourceFileData : function (file) {
    if (this._sourceFileData && file.id === this._sourceFileData.id) {
      return;
    }

    this._sourceFileData = file;
    this._filepath.innerHTML = file.path;
    this._codeMirror.doc.setValue(file.content);
    this._refresh();
  },

  _refresh : function () {
    var that = this;
    setTimeout(function () {
      var fullHeight = parseInt(that._content.clientHeight);
      var headerHeight = that._filepath.clientHeight;

      that._codeMirror.setSize('auto', fullHeight - headerHeight);
      that._codeMirror.refresh();
    }, 200);
  },

  clearBubbles : function () {
    this._lineWidgets.forEach(function (widget) { widget.clear(); });
    this._lineWidgets = [];
  },

  getMessage : function (event, kind) {
    if (kind === 'macro') {
      var name = 'macro expansion' + (event.name ? ': ' + event.name : '');

      return '<span class="tag macro">' + name + '</span>'
        + this.escapeHTML(event.expansion).replace(/(?:\r\n|\r|\n)/g, '<br>');
    } else if (kind === 'note') {
      return '<span class="tag note">note</span>'
        +  this.escapeHTML(event.message).replace(/(?:\r\n|\r|\n)/g, '<br>');
    }
  },

  addExtraPathEvents : function (events, kind) {
    var that = this;

    if (!events) {
      return;
    }

    events.forEach(function (event) {
      if (event.location.file !== that._currentBugEvent.location.file) {
        return;
      }

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + kind);

      var msg = document.createElement('span');
      msg.innerHTML = that.getMessage(event, kind);
      element.appendChild(msg);

      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  drawBugPath : function () {
    var that = this;

    this.clearBubbles();

    this.addExtraPathEvents(this._currentReport.macros, 'macro');
    this.addExtraPathEvents(this._currentReport.notes, 'note');

    // Processing bug path events.
    var currentEvents = this._currentReport.events;
    currentEvents.forEach(function (event, step) {
      if (event.location.file !== that._currentBugEvent.location.file)
        return;

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';
      var type = step === currentEvents.length - 1 ? 'error' : 'info';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + type);
      element.setAttribute('idx', step);

      var enumeration = document.createElement('span');
      enumeration.setAttribute('class', 'checker-enum ' + type);
      enumeration.innerHTML = step + 1;

      if (currentEvents.length > 1)
        element.appendChild(enumeration);

      var prevBugEvent = step - 1;
      if (step > 0) {
        var prevBug = document.createElement('span');
        prevBug.setAttribute('class', 'arrow left-arrow');
        prevBug.addEventListener('click', function () {
          var event = currentEvents[prevBugEvent];
          that.setCurrentBugEvent(event, prevBugEvent);
        });
        element.appendChild(prevBug);
      }

      var msg = document.createElement('span');
      msg.innerHTML = that.escapeHTML(event.message)
        .replace(/(?:\r\n|\r|\n)/g, '<br>');

      element.appendChild(msg);

      var nextBugEvent = step + 1;
      if (nextBugEvent < currentEvents.length) {
        var nextBug = document.createElement('span');
        nextBug.setAttribute('class', 'arrow right-arrow');
        nextBug.addEventListener('click', function () {
          var event = currentEvents[nextBugEvent];
          that.setCurrentBugEvent(event, nextBugEvent);
        });
        element.appendChild(nextBug);
      }


      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  jumpTo : function (line, column) {
    var that = this;

    setTimeout(function () {
      var selPosPixel
        = that._codeMirror.charCoords({ line : line, ch : column }, 'local');
      var editorSize = {
        width  : that._editor.clientWidth,
        height : that._editor.clientHeight
      };

      that._codeMirror.scrollIntoView({
        top    : selPosPixel.top - 100,
        bottom : selPosPixel.top + editorSize.height - 150,
        left   : selPosPixel.left < editorSize.width - 100
               ? 0
               : selPosPixel.left - 50,
        right  : selPosPixel.left < editorSize.width - 100
               ? 10
               : selPosPixel.left + editorSize.width - 100
      });
    }, 0);
  }
}


      var data = {"files": {"0": {"id": 0, "path": "/home/vsts/work/1/llvm-project/lldb/include/lldb/Breakpoint/BreakpointName.h", "content": "//===-- BreakpointName.h --------------------------------------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLDB_BREAKPOINT_BREAKPOINTNAME_H\n#define LLDB_BREAKPOINT_BREAKPOINTNAME_H\n\n#include <memory>\n#include <string>\n#include <unordered_set>\n#include <vector>\n\n#include \"lldb/Breakpoint/BreakpointID.h\"\n#include \"lldb/Breakpoint/BreakpointLocationCollection.h\"\n#include \"lldb/Breakpoint/BreakpointLocationList.h\"\n#include \"lldb/Breakpoint/BreakpointOptions.h\"\n#include \"lldb/Breakpoint/Stoppoint.h\"\n#include \"lldb/Core/SearchFilter.h\"\n#include \"lldb/Utility/Event.h\"\n#include \"lldb/Utility/Flags.h\"\n#include \"lldb/Utility/StringList.h\"\n#include \"lldb/Utility/StructuredData.h\"\n\nnamespace lldb_private {\n\nclass BreakpointName {\npublic:\n  class Permissions\n  {\n  public:\n  \n    enum PermissionKinds { listPerm = 0, disablePerm = 1, \n                       deletePerm = 2, allPerms = 3 };\n\n    Permissions(bool in_list, bool in_disable, bool in_delete) \n    {\n      m_permissions[listPerm]    = in_list;\n      m_permissions[disablePerm] = in_disable;\n      m_permissions[deletePerm]  = in_delete;\n      m_set_mask.Set(permissions_mask[allPerms]);\n    }\n    \n    Permissions(const Permissions &rhs)\n    {\n      m_permissions[listPerm]    = rhs.m_permissions[listPerm];\n      m_permissions[disablePerm] = rhs.m_permissions[disablePerm];\n      m_permissions[deletePerm]  = rhs.m_permissions[deletePerm];\n      m_set_mask = rhs.m_set_mask;\n    }\n    \n    Permissions() \n    {\n      m_permissions[listPerm]    = true;\n      m_permissions[disablePerm] = true;\n      m_permissions[deletePerm]  = true;\n      m_set_mask.Clear();\n    }\n    \n    const Permissions &operator= (const Permissions &rhs)\n    {\n      if (this != &rhs) {\n        m_permissions[listPerm]    = rhs.m_permissions[listPerm];\n        m_permissions[disablePerm] = rhs.m_permissions[disablePerm];\n        m_permissions[deletePerm]  = rhs.m_permissions[deletePerm];\n        m_set_mask = rhs.m_set_mask;\n      }\n      return *this;\n    }\n    \n    void Clear() {\n      *this = Permissions();\n    }\n    \n    // Merge the permissions from incoming into this set of permissions. Only\n    // merge set permissions, and most restrictive permission wins.\n    void MergeInto(const Permissions &incoming)\n    {\n      MergePermission(incoming, listPerm);\n      MergePermission(incoming, disablePerm);\n      MergePermission(incoming, deletePerm);\n    }\n\n    bool GetAllowList() const { return GetPermission(listPerm); }\n    bool SetAllowList(bool value) { return SetPermission(listPerm, value); }\n    \n    bool GetAllowDelete() const { return GetPermission(deletePerm); }\n    bool SetAllowDelete(bool value) { return SetPermission(deletePerm, value); }\n    \n    bool GetAllowDisable() const { return GetPermission(disablePerm); }\n    bool SetAllowDisable(bool value) { return SetPermission(disablePerm, \n                                                            value); }\n\n    bool GetPermission(enum PermissionKinds permission) const\n    {\n      return m_permissions[permission];\n    }\n\n    bool GetDescription(Stream *s, lldb::DescriptionLevel level);\n\n    bool IsSet(enum PermissionKinds permission) const\n    {\n      return m_set_mask.Test(permissions_mask[permission]);\n    }\n    \n    bool AnySet() {\n      return m_set_mask.AnySet(permissions_mask[allPerms]);\n    }\n    \n  private:\n    static const Flags::ValueType permissions_mask[allPerms + 1];\n    \n    bool m_permissions[allPerms];\n    Flags m_set_mask;\n    \n    bool SetPermission(enum PermissionKinds permission, bool value)\n    {\n      bool old_value = m_permissions[permission];\n      m_permissions[permission] = value;\n      m_set_mask.Set(permissions_mask[permission]);\n      return old_value;\n    }\n    \n    // If either side disallows the permission, the resultant disallows it.\n    void MergePermission(const Permissions &incoming, \n                         enum PermissionKinds permission)\n    {\n      if (incoming.IsSet(permission))\n      {\n        SetPermission(permission, !(m_permissions[permission] |\n            incoming.m_permissions[permission]));\n      }\n    }\n  };\n  \n  BreakpointName(ConstString name, const char *help = nullptr) :\n      m_name(name), m_options(false)\n   {\n     SetHelp(help);\n   }\n      \n  BreakpointName(ConstString name,\n                 BreakpointOptions &options,\n                 const Permissions &permissions = Permissions(),\n                 const char *help = nullptr) :\n      m_name(name), m_options(options), \n      m_permissions(permissions) {\n        SetHelp(help);\n  };\n  \n  BreakpointName(const BreakpointName &rhs) :\n      m_name(rhs.m_name), m_options(rhs.m_options),\n      m_permissions(rhs.m_permissions), m_help(rhs.m_help)\n  {}\n  \n  BreakpointName(ConstString name, const Breakpoint &bkpt,\n                 const char *help);\n      \n  ConstString GetName() const { return m_name; }\n  BreakpointOptions &GetOptions() { return m_options; }\n  const BreakpointOptions &GetOptions() const { return m_options; }\n  \n  void SetOptions(const BreakpointOptions &options) {\n    m_options = options;\n  }\n  \n  Permissions &GetPermissions() { return m_permissions; }\n  const Permissions &GetPermissions() const { return m_permissions; }\n  void SetPermissions(const Permissions &permissions) {\n    m_permissions = permissions;\n  }\n  \n  bool GetPermission(Permissions::PermissionKinds permission) const\n  {\n    return m_permissions.GetPermission(permission);\n  }\n  \n  void SetHelp(const char *description)\n  {\n    if (description)\n      m_help.assign(description);\n    else\n      m_help.clear();\n  }\n  \n  const char *GetHelp()\n  {\n    return m_help.c_str();\n  }\n  \n  // Returns true if any options were set in the name\n  bool GetDescription(Stream *s, lldb::DescriptionLevel level);\n  \n  void ConfigureBreakpoint(lldb::BreakpointSP bp_sp);\n  \nprivate:\n  ConstString        m_name;\n  BreakpointOptions  m_options;\n  Permissions        m_permissions;\n  std::string        m_help;\n};\n\n} // namespace lldb_private\n\n#endif // LLDB_BREAKPOINT_BREAKPOINTNAME_H\n"}, "1": {"id": 1, "path": "/home/vsts/work/1/llvm-project/lldb/include/lldb/Breakpoint/BreakpointOptions.h", "content": "//===-- BreakpointOptions.h -------------------------------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLDB_BREAKPOINT_BREAKPOINTOPTIONS_H\n#define LLDB_BREAKPOINT_BREAKPOINTOPTIONS_H\n\n#include <memory>\n#include <string>\n\n#include \"lldb/Utility/Baton.h\"\n#include \"lldb/Utility/Flags.h\"\n#include \"lldb/Utility/StringList.h\"\n#include \"lldb/Utility/StructuredData.h\"\n#include \"lldb/lldb-private.h\"\n\nnamespace lldb_private {\n\n/// \\class BreakpointOptions BreakpointOptions.h\n/// \"lldb/Breakpoint/BreakpointOptions.h\" Class that manages the options on a\n/// breakpoint or breakpoint location.\n\nclass BreakpointOptions {\nfriend class BreakpointLocation;\nfriend class BreakpointName;\nfriend class lldb_private::BreakpointOptionGroup;\nfriend class Breakpoint;\n\npublic:\n  enum OptionKind {\n    eCallback     = 1 << 0,\n    eEnabled      = 1 << 1,\n    eOneShot      = 1 << 2,\n    eIgnoreCount  = 1 << 3,\n    eThreadSpec   = 1 << 4,\n    eCondition    = 1 << 5,\n    eAutoContinue = 1 << 6,\n    eAllOptions   = (eCallback | eEnabled | eOneShot | eIgnoreCount | eThreadSpec\n                     | eCondition | eAutoContinue)\n  };\n  struct CommandData {\n    CommandData()\n        : user_source(), script_source(),\n          interpreter(lldb::eScriptLanguageNone), stop_on_error(true) {}\n\n    CommandData(const StringList &user_source, lldb::ScriptLanguage interp)\n        : user_source(user_source), script_source(), interpreter(interp),\n          stop_on_error(true) {}\n\n    virtual ~CommandData() = default;\n\n    static const char *GetSerializationKey() { return \"BKPTCMDData\"; }\n\n    StructuredData::ObjectSP SerializeToStructuredData();\n\n    static std::unique_ptr<CommandData>\n    CreateFromStructuredData(const StructuredData::Dictionary &options_dict,\n                             Status &error);\n\n    StringList user_source;\n    std::string script_source;\n    enum lldb::ScriptLanguage\n        interpreter; // eScriptLanguageNone means command interpreter.\n    bool stop_on_error;\n\n  private:\n    enum class OptionNames : uint32_t {\n      UserSource = 0,\n      Interpreter,\n      StopOnError,\n      LastOptionName\n    };\n\n    static const char\n        *g_option_names[static_cast<uint32_t>(OptionNames::LastOptionName)];\n\n    static const char *GetKey(OptionNames enum_value) {\n      return g_option_names[static_cast<uint32_t>(enum_value)];\n    }\n  };\n\n  class CommandBaton : public TypedBaton<CommandData> {\n  public:\n    explicit CommandBaton(std::unique_ptr<CommandData> Data)\n        : TypedBaton(std::move(Data)) {}\n\n    void GetDescription(llvm::raw_ostream &s, lldb::DescriptionLevel level,\n                        unsigned indentation) const override;\n  };\n\n  typedef std::shared_ptr<CommandBaton> CommandBatonSP;\n\n  // Constructors and Destructors\n\n  /// This constructor allows you to specify all the breakpoint options except\n  /// the callback.  That one is more complicated, and better to do by hand.\n  ///\n  /// \\param[in] condition\n  ///    The expression which if it evaluates to \\b true if we are to stop\n  ///\n  /// \\param[in] enabled\n  ///    Is this breakpoint enabled.\n  ///\n  /// \\param[in] ignore\n  ///    How many breakpoint hits we should ignore before stopping.\n  ///\n  /// \\param[in] one_shot\n  ///    Should this breakpoint delete itself after being hit once.\n  ///\n  /// \\param[in] auto_continue\n  ///    Should this breakpoint auto-continue after running its commands.\n  ///\n  BreakpointOptions(const char *condition, bool enabled = true,\n                    int32_t ignore = 0, bool one_shot = false,\n                    bool auto_continue = false);\n\n  /// Breakpoints make options with all flags set.  Locations and Names make\n  /// options with no flags set.\n  BreakpointOptions(bool all_flags_set);\n  BreakpointOptions(const BreakpointOptions &rhs);\n\n  virtual ~BreakpointOptions();\n\n  static std::unique_ptr<BreakpointOptions>\n  CreateFromStructuredData(Target &target,\n                           const StructuredData::Dictionary &data_dict,\n                           Status &error);\n\n  virtual StructuredData::ObjectSP SerializeToStructuredData();\n\n  static const char *GetSerializationKey() { return \"BKPTOptions\"; }\n\n  // Operators\n  const BreakpointOptions &operator=(const BreakpointOptions &rhs);\n\n  /// Copy over only the options set in the incoming BreakpointOptions.\n  void CopyOverSetOptions(const BreakpointOptions &rhs);\n\n  // Callbacks\n  //\n  // Breakpoint callbacks come in two forms, synchronous and asynchronous.\n  // Synchronous callbacks will get run before any of the thread plans are\n  // consulted, and if they return false the target will continue \"under the\n  // radar\" of the thread plans.  There are a couple of restrictions to\n  // synchronous callbacks:\n  // 1) They should NOT resume the target themselves.\n  //     Just return false if you want the target to restart.\n  // 2) Breakpoints with synchronous callbacks can't have conditions\n  //    (or rather, they can have them, but they won't do anything.\n  //    Ditto with ignore counts, etc...  You are supposed to control that all\n  //    through the callback.\n  // Asynchronous callbacks get run as part of the \"ShouldStop\" logic in the\n  // thread plan.  The logic there is:\n  //   a) If the breakpoint is thread specific and not for this thread, continue\n  //   w/o running the callback.\n  //      NB. This is actually enforced underneath the breakpoint system, the\n  //      Process plugin is expected to\n  //      call BreakpointSite::IsValidForThread, and set the thread's StopInfo\n  //      to \"no reason\".  That way,\n  //      thread displays won't show stops for breakpoints not for that\n  //      thread...\n  //   b) If the ignore count says we shouldn't stop, then ditto.\n  //   c) If the condition says we shouldn't stop, then ditto.\n  //   d) Otherwise, the callback will get run, and if it returns true we will\n  //      stop, and if false we won't.\n  //  The asynchronous callback can run the target itself, but at present that\n  //  should be the last action the callback does.  We will relax this condition\n  //  at some point, but it will take a bit of plumbing to get that to work.\n  //\n\n  /// Adds a callback to the breakpoint option set.\n  ///\n  /// \\param[in] callback\n  ///    The function to be called when the breakpoint gets hit.\n  ///\n  /// \\param[in] baton_sp\n  ///    A baton which will get passed back to the callback when it is invoked.\n  ///\n  /// \\param[in] synchronous\n  ///    Whether this is a synchronous or asynchronous callback.  See discussion\n  ///    above.\n  void SetCallback(BreakpointHitCallback callback,\n                   const lldb::BatonSP &baton_sp, bool synchronous = false);\n\n  void SetCallback(BreakpointHitCallback callback,\n                   const BreakpointOptions::CommandBatonSP &command_baton_sp,\n                   bool synchronous = false);\n\n  /// Returns the command line commands for the callback on this breakpoint.\n  ///\n  /// \\param[out] command_list\n  ///    The commands will be appended to this list.\n  ///\n  /// \\return\n  ///    \\btrue if the command callback is a command-line callback,\n  ///    \\bfalse otherwise.\n  bool GetCommandLineCallbacks(StringList &command_list);\n\n  /// Remove the callback from this option set.\n  void ClearCallback();\n\n  // The rest of these functions are meant to be used only within the\n  // breakpoint handling mechanism.\n\n  /// Use this function to invoke the callback for a specific stop.\n  ///\n  /// \\param[in] context\n  ///    The context in which the callback is to be invoked.  This includes the\n  ///    stop event, the\n  ///    execution context of the stop (since you might hit the same breakpoint\n  ///    on multiple threads) and\n  ///    whether we are currently executing synchronous or asynchronous\n  ///    callbacks.\n  ///\n  /// \\param[in] break_id\n  ///    The breakpoint ID that owns this option set.\n  ///\n  /// \\param[in] break_loc_id\n  ///    The breakpoint location ID that owns this option set.\n  ///\n  /// \\return\n  ///     The callback return value.\n  bool InvokeCallback(StoppointCallbackContext *context,\n                      lldb::user_id_t break_id, lldb::user_id_t break_loc_id);\n\n  /// Used in InvokeCallback to tell whether it is the right time to run this\n  /// kind of callback.\n  ///\n  /// \\return\n  ///     The synchronicity of our callback.\n  bool IsCallbackSynchronous() const { return m_callback_is_synchronous; }\n\n  /// Fetch the baton from the callback.\n  ///\n  /// \\return\n  ///     The baton.\n  Baton *GetBaton();\n\n  /// Fetch  a const version of the baton from the callback.\n  ///\n  /// \\return\n  ///     The baton.\n  const Baton *GetBaton() const;\n\n  // Condition\n  /// Set the breakpoint option's condition.\n  ///\n  /// \\param[in] condition\n  ///    The condition expression to evaluate when the breakpoint is hit.\n  void SetCondition(const char *condition);\n\n  /// Return a pointer to the text of the condition expression.\n  ///\n  /// \\return\n  ///    A pointer to the condition expression text, or nullptr if no\n  //     condition has been set.\n  const char *GetConditionText(size_t *hash = nullptr) const;\n\n  // Enabled/Ignore Count\n\n  /// Check the Enable/Disable state.\n  /// \\return\n  ///     \\b true if the breakpoint is enabled, \\b false if disabled.\n  bool IsEnabled() const { return m_enabled; }\n\n  /// If \\a enable is \\b true, enable the breakpoint, if \\b false disable it.\n  void SetEnabled(bool enabled) {\n    m_enabled = enabled;\n    m_set_flags.Set(eEnabled);\n  }\n\n  /// Check the auto-continue state.\n  /// \\return\n  ///     \\b true if the breakpoint is set to auto-continue, \\b false otherwise.\n  bool IsAutoContinue() const { return m_auto_continue; }\n\n  /// Set the auto-continue state.\n  void SetAutoContinue(bool auto_continue) {\n    m_auto_continue = auto_continue;\n    m_set_flags.Set(eAutoContinue);\n  }\n\n  /// Check the One-shot state.\n  /// \\return\n  ///     \\b true if the breakpoint is one-shot, \\b false otherwise.\n  bool IsOneShot() const { return m_one_shot; }\n\n  /// If \\a enable is \\b true, enable the breakpoint, if \\b false disable it.\n  void SetOneShot(bool one_shot) {\n    m_one_shot = one_shot;\n    m_set_flags.Set(eOneShot);\n  }\n\n  /// Set the breakpoint to ignore the next \\a count breakpoint hits.\n  /// \\param[in] n\n  ///    The number of breakpoint hits to ignore.\n  void SetIgnoreCount(uint32_t n) {\n    m_ignore_count = n;\n    m_set_flags.Set(eIgnoreCount);\n  }\n\n  /// Return the current Ignore Count.\n  /// \\return\n  ///     The number of breakpoint hits to be ignored.\n  uint32_t GetIgnoreCount() const { return m_ignore_count; }\n\n  /// Return the current thread spec for this option. This will return nullptr\n  /// if the no thread specifications have been set for this Option yet.\n  /// \\return\n  ///     The thread specification pointer for this option, or nullptr if none\n  ///     has\n  ///     been set yet.\n  const ThreadSpec *GetThreadSpecNoCreate() const;\n\n  /// Returns a pointer to the ThreadSpec for this option, creating it. if it\n  /// hasn't been created already.   This API is used for setting the\n  /// ThreadSpec items for this option.\n  ThreadSpec *GetThreadSpec();\n\n  void SetThreadID(lldb::tid_t thread_id);\n\n  void GetDescription(Stream *s, lldb::DescriptionLevel level) const;\n\n  /// Check if the breakpoint option has a callback set.\n  ///\n  /// \\return\n  ///    If the breakpoint option has a callback, \\b true otherwise \\b false.\n  bool HasCallback() const;\n\n  /// This is the default empty callback.\n  static bool NullCallback(void *baton, StoppointCallbackContext *context,\n                           lldb::user_id_t break_id,\n                           lldb::user_id_t break_loc_id);\n\n  /// Set a callback based on BreakpointOptions::CommandData. \\param[in]\n  /// cmd_data\n  ///     A UP holding the new'ed CommandData object.\n  ///     The breakpoint will take ownership of pointer held by this object.\n  void SetCommandDataCallback(std::unique_ptr<CommandData> &cmd_data);\n\n  void Clear();\n\n  bool AnySet() const {\n    return m_set_flags.AnySet(eAllOptions);\n  }\n\nprotected:\n  // Classes that inherit from BreakpointOptions can see and modify these\n  bool IsOptionSet(OptionKind kind)\n  {\n    return m_set_flags.Test(kind);\n  }\n\n  enum class OptionNames {\n    ConditionText = 0,\n    IgnoreCount,\n    EnabledState,\n    OneShotState,\n    AutoContinue,\n    LastOptionName\n  };\n  static const char *g_option_names[(size_t)OptionNames::LastOptionName];\n\n  static const char *GetKey(OptionNames enum_value) {\n    return g_option_names[(size_t)enum_value];\n  }\n\n  static bool BreakpointOptionsCallbackFunction(\n      void *baton, StoppointCallbackContext *context, lldb::user_id_t break_id,\n      lldb::user_id_t break_loc_id);\n\n  void SetThreadSpec(std::unique_ptr<ThreadSpec> &thread_spec_up);\n\nprivate:\n  /// For BreakpointOptions only\n\n  /// This is the callback function pointer\n  BreakpointHitCallback m_callback;\n  /// This is the client data for the callback\n  lldb::BatonSP m_callback_baton_sp;\n  bool m_baton_is_command_baton;\n  bool m_callback_is_synchronous;\n  bool m_enabled;\n  /// If set, the breakpoint delete itself after being hit once.\n  bool m_one_shot;\n  /// Number of times to ignore this breakpoint.\n  uint32_t m_ignore_count;\n  /// Thread for which this breakpoint will stop.\n  std::unique_ptr<ThreadSpec> m_thread_spec_up;\n  /// The condition to test.\n  std::string m_condition_text;\n  /// Its hash, so that locations know when the condition is updated.\n  size_t m_condition_text_hash;\n  /// If set, inject breakpoint condition into process.\n  bool m_inject_condition;\n  /// If set, auto-continue from breakpoint.\n  bool m_auto_continue;\n  /// Which options are set at this level.\n  /// Drawn from BreakpointOptions::SetOptionsFlags.\n  Flags m_set_flags;\n};\n\n} // namespace lldb_private\n\n#endif // LLDB_BREAKPOINT_BREAKPOINTOPTIONS_H\n"}, "2": {"id": 2, "path": "/home/vsts/work/1/llvm-project/lldb/include/lldb/Core/Address.h", "content": "//===-- Address.h -----------------------------------------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLDB_CORE_ADDRESS_H\n#define LLDB_CORE_ADDRESS_H\n\n#include \"lldb/lldb-defines.h\"\n#include \"lldb/lldb-forward.h\"\n#include \"lldb/lldb-private-enumerations.h\"\n#include \"lldb/lldb-types.h\"\n\n#include <stddef.h>\n#include <stdint.h>\n\nnamespace lldb_private {\nclass Block;\nclass CompileUnit;\nclass ExecutionContextScope;\nclass Function;\nclass SectionList;\nclass Stream;\nclass Symbol;\nclass SymbolContext;\nclass Target;\nstruct LineEntry;\n\n/// \\class Address Address.h \"lldb/Core/Address.h\"\n/// A section + offset based address class.\n///\n/// The Address class allows addresses to be relative to a section that can\n/// move during runtime due to images (executables, shared libraries, bundles,\n/// frameworks) being loaded at different addresses than the addresses found\n/// in the object file that represents them on disk. There are currently two\n/// types of addresses for a section:\n///     \\li file addresses\n///     \\li load addresses\n///\n/// File addresses represent the virtual addresses that are in the \"on disk\"\n/// object files. These virtual addresses are converted to be relative to\n/// unique sections scoped to the object file so that when/if the addresses\n/// slide when the images are loaded/unloaded in memory, we can easily track\n/// these changes without having to update every object (compile unit ranges,\n/// line tables, function address ranges, lexical block and inlined subroutine\n/// address ranges, global and static variables) each time an image is loaded\n/// or unloaded.\n///\n/// Load addresses represent the virtual addresses where each section ends up\n/// getting loaded at runtime. Before executing a program, it is common for\n/// all of the load addresses to be unresolved. When a DynamicLoader plug-in\n/// receives notification that shared libraries have been loaded/unloaded, the\n/// load addresses of the main executable and any images (shared libraries)\n/// will be  resolved/unresolved. When this happens, breakpoints that are in\n/// one of these sections can be set/cleared.\nclass Address {\npublic:\n  /// Dump styles allow the Address::Dump(Stream *,DumpStyle) const function\n  /// to display Address contents in a variety of ways.\n  enum DumpStyle {\n    /// Invalid dump style.\n    DumpStyleInvalid,\n    /// Display as the section name + offset.\n    /// \\code\n    /// // address for printf in libSystem.B.dylib as a section name + offset\n    /// libSystem.B.dylib.__TEXT.__text + 0x0005cfdf\n    /// \\endcode\n    DumpStyleSectionNameOffset,\n    /// Display as the section pointer + offset (debug output).\n    /// \\code\n    /// // address for printf in libSystem.B.dylib as a section pointer +\n    /// offset (lldb::Section *)0x35cc50 + 0x000000000005cfdf\n    /// \\endcode\n    DumpStyleSectionPointerOffset,\n    /// Display as the file address (if any).\n    /// \\code\n    /// // address for printf in libSystem.B.dylib as a file address\n    /// 0x000000000005dcff\n    /// \\endcode\n    ///\n    DumpStyleFileAddress,\n    /// Display as the file address with the module name prepended (if any).\n    /// \\code\n    /// // address for printf in libSystem.B.dylib as a file address\n    /// libSystem.B.dylib[0x000000000005dcff]\n    /// \\endcode\n    DumpStyleModuleWithFileAddress,\n    /// Display as the load address (if resolved).\n    /// \\code\n    /// // address for printf in libSystem.B.dylib as a load address\n    /// 0x00007fff8306bcff\n    /// \\endcode\n    DumpStyleLoadAddress,\n    /// Display the details about what an address resolves to. This can be\n    /// anything from a symbol context summary (module, function/symbol, and\n    /// file and line), to information about what the pointer points to if the\n    /// address is in a section (section of pointers, c strings, etc).\n    DumpStyleResolvedDescription,\n    DumpStyleResolvedDescriptionNoModule,\n    DumpStyleResolvedDescriptionNoFunctionArguments,\n    /// Elide the function name; display an offset into the current function.\n    /// Used primarily in disassembly symbolication\n    DumpStyleNoFunctionName,\n    /// Detailed symbol context information for an address for all symbol\n    /// context members.\n    DumpStyleDetailedSymbolContext,\n    /// Dereference a pointer at the current address and then lookup the\n    /// dereferenced address using DumpStyleResolvedDescription\n    DumpStyleResolvedPointerDescription\n  };\n\n  /// Default constructor.\n  ///\n  /// Initialize with a invalid section (NULL) and an invalid offset\n  /// (LLDB_INVALID_ADDRESS).\n  Address() : m_section_wp(), m_offset(LLDB_INVALID_ADDRESS) {}\n\n  /// Copy constructor\n  ///\n  /// Makes a copy of the another Address object \\a rhs.\n  ///\n  /// \\param[in] rhs\n  ///     A const Address object reference to copy.\n  Address(const Address &rhs)\n      : m_section_wp(rhs.m_section_wp), m_offset(rhs.m_offset) {}\n\n  /// Construct with a section pointer and offset.\n  ///\n  /// Initialize the address with the supplied \\a section and \\a offset.\n  ///\n  /// \\param[in] section_sp\n  ///     A section pointer to a valid lldb::Section, or NULL if the\n  ///     address doesn't have a section or will get resolved later.\n  ///\n  /// \\param[in] offset\n  ///     The offset in bytes into \\a section.\n  Address(const lldb::SectionSP &section_sp, lldb::addr_t offset)\n      : m_section_wp(), // Don't init with section_sp in case section_sp is\n                        // invalid (the weak_ptr will throw)\n        m_offset(offset) {\n    if (section_sp)\n      m_section_wp = section_sp;\n  }\n\n  /// Construct with a virtual address and section list.\n  ///\n  /// Initialize and resolve the address with the supplied virtual address \\a\n  /// file_addr.\n  ///\n  /// \\param[in] file_addr\n  ///     A virtual file address.\n  ///\n  /// \\param[in] section_list\n  ///     A list of sections, one of which may contain the \\a file_addr.\n  Address(lldb::addr_t file_addr, const SectionList *section_list);\n\n  Address(lldb::addr_t abs_addr);\n\n/// Assignment operator.\n///\n/// Copies the address value from another Address object \\a rhs into \\a this\n/// object.\n///\n/// \\param[in] rhs\n///     A const Address object reference to copy.\n///\n/// \\return\n///     A const Address object reference to \\a this.\n  const Address &operator=(const Address &rhs);\n\n  /// Clear the object's state.\n  ///\n  /// Sets the section to an invalid value (NULL) and an invalid offset\n  /// (LLDB_INVALID_ADDRESS).\n  void Clear() {\n    m_section_wp.reset();\n    m_offset = LLDB_INVALID_ADDRESS;\n  }\n\n  /// Compare two Address objects.\n  ///\n  /// \\param[in] lhs\n  ///     The Left Hand Side const Address object reference.\n  ///\n  /// \\param[in] rhs\n  ///     The Right Hand Side const Address object reference.\n  ///\n  /// \\return\n  ///     -1 if lhs < rhs\n  ///     0 if lhs == rhs\n  ///     1 if lhs > rhs\n  static int CompareFileAddress(const Address &lhs, const Address &rhs);\n\n  static int CompareLoadAddress(const Address &lhs, const Address &rhs,\n                                Target *target);\n\n  static int CompareModulePointerAndOffset(const Address &lhs,\n                                           const Address &rhs);\n\n  // For use with std::map, std::multi_map\n  class ModulePointerAndOffsetLessThanFunctionObject {\n  public:\n    ModulePointerAndOffsetLessThanFunctionObject() = default;\n\n    bool operator()(const Address &a, const Address &b) const {\n      return Address::CompareModulePointerAndOffset(a, b) < 0;\n    }\n  };\n\n  /// Dump a description of this object to a Stream.\n  ///\n  /// Dump a description of the contents of this object to the supplied stream\n  /// \\a s. There are many ways to display a section offset based address, and\n  /// \\a style lets the user choose.\n  ///\n  /// \\param[in] s\n  ///     The stream to which to dump the object description.\n  ///\n  /// \\param[in] style\n  ///     The display style for the address.\n  ///\n  /// \\param[in] fallback_style\n  ///     The display style for the address.\n  ///\n  /// \\return\n  ///     Returns \\b true if the address was able to be displayed.\n  ///     File and load addresses may be unresolved and it may not be\n  ///     possible to display a valid value, \\b false will be returned\n  ///     in such cases.\n  ///\n  /// \\see Address::DumpStyle\n  bool Dump(Stream *s, ExecutionContextScope *exe_scope, DumpStyle style,\n            DumpStyle fallback_style = DumpStyleInvalid,\n            uint32_t addr_byte_size = UINT32_MAX) const;\n\n  AddressClass GetAddressClass() const;\n\n  /// Get the file address.\n  ///\n  /// If an address comes from a file on disk that has section relative\n  /// addresses, then it has a virtual address that is relative to unique\n  /// section in the object file.\n  ///\n  /// \\return\n  ///     The valid file virtual address, or LLDB_INVALID_ADDRESS if\n  ///     the address doesn't have a file virtual address (image is\n  ///     from memory only with no representation on disk).\n  lldb::addr_t GetFileAddress() const;\n\n  /// Get the load address.\n  ///\n  /// If an address comes from a file on disk that has section relative\n  /// addresses, then it has a virtual address that is relative to unique\n  /// section in the object file. Sections get resolved at runtime by\n  /// DynamicLoader plug-ins as images (executables and shared libraries) get\n  /// loaded/unloaded. If a section is loaded, then the load address can be\n  /// resolved.\n  ///\n  /// \\return\n  ///     The valid load virtual address, or LLDB_INVALID_ADDRESS if\n  ///     the address is currently not loaded.\n  lldb::addr_t GetLoadAddress(Target *target) const;\n\n  /// Get the load address as a callable code load address.\n  ///\n  /// This function will first resolve its address to a load address. Then, if\n  /// the address turns out to be in code address, return the load address\n  /// that would be required to call or return to. The address might have\n  /// extra bits set (bit zero will be set to Thumb functions for an ARM\n  /// target) that are required when changing the program counter to setting a\n  /// return address.\n  ///\n  /// \\return\n  ///     The valid load virtual address, or LLDB_INVALID_ADDRESS if\n  ///     the address is currently not loaded.\n  lldb::addr_t GetCallableLoadAddress(Target *target,\n                                      bool is_indirect = false) const;\n\n  /// Get the load address as an opcode load address.\n  ///\n  /// This function will first resolve its address to a load address. Then, if\n  /// the address turns out to be in code address, return the load address for\n  /// an opcode. This address object might have extra bits set (bit zero will\n  /// be set to Thumb functions for an\n  /// ARM target) that are required for changing the program counter\n  /// and this function will remove any bits that are intended for these\n  /// special purposes. The result of this function can be used to safely\n  /// write a software breakpoint trap to memory.\n  ///\n  /// \\return\n  ///     The valid load virtual address with extra callable bits\n  ///     removed, or LLDB_INVALID_ADDRESS if the address is currently\n  ///     not loaded.\n  lldb::addr_t GetOpcodeLoadAddress(\n      Target *target,\n      AddressClass addr_class = AddressClass::eInvalid) const;\n\n  /// Get the section relative offset value.\n  ///\n  /// \\return\n  ///     The current offset, or LLDB_INVALID_ADDRESS if this address\n  ///     doesn't contain a valid offset.\n  lldb::addr_t GetOffset() const { return m_offset; }\n\n  /// Check if an address is section offset.\n  ///\n  /// When converting a virtual file or load address into a section offset\n  /// based address, we often need to know if, given a section list, if the\n  /// address was able to be converted to section offset. This function\n  /// returns true if the current value contained in this object is section\n  /// offset based.\n  ///\n  /// \\return\n  ///     Returns \\b true if the address has a valid section and\n  ///     offset, \\b false otherwise.\n  bool IsSectionOffset() const {\n    return IsValid() && (GetSection().get() != nullptr);\n  }\n\n  /// Check if the object state is valid.\n  ///\n  /// A valid Address object contains either a section pointer and\n  /// offset (for section offset based addresses), or just a valid offset\n  /// (for absolute addresses that have no section).\n  ///\n  /// \\return\n  ///     Returns \\b true if the offset is valid, \\b false\n  ///     otherwise.\n  bool IsValid() const { return m_offset != LLDB_INVALID_ADDRESS; }\n\n  /// Get the memory cost of this object.\n  ///\n  /// \\return\n  ///     The number of bytes that this object occupies in memory.\n  size_t MemorySize() const;\n\n  /// Resolve a file virtual address using a section list.\n  ///\n  /// Given a list of sections, attempt to resolve \\a addr as an offset into\n  /// one of the file sections.\n  ///\n  /// \\return\n  ///     Returns \\b true if \\a addr was able to be resolved, \\b false\n  ///     otherwise.\n  bool ResolveAddressUsingFileSections(lldb::addr_t addr,\n                                       const SectionList *sections);\n\n  /// Resolve this address to its containing function and optionally get\n  /// that function's address range.\n  ///\n  /// \\param[out] sym_ctx\n  ///     The symbol context describing the function in which this address lies\n  ///\n  /// \\parm[out] addr_range_ptr\n  ///     Pointer to the AddressRange to fill in with the function's address\n  ///     range.  Caller may pass null if they don't need the address range.\n  ///\n  /// \\return\n  ///     Returns \\b false if the function/symbol could not be resolved\n  ///     or if the address range was requested and could not be resolved;\n  ///     returns \\b true otherwise.\n  bool ResolveFunctionScope(lldb_private::SymbolContext &sym_ctx,\n                            lldb_private::AddressRange *addr_range_ptr = nullptr);\n\n  /// Set the address to represent \\a load_addr.\n  ///\n  /// The address will attempt to find a loaded section within \\a target that\n  /// contains \\a load_addr. If successful, this address object will have a\n  /// valid section and offset. Else this address object will have no section\n  /// (NULL) and the offset will be \\a load_addr.\n  ///\n  /// \\param[in] load_addr\n  ///     A load address from a current process.\n  ///\n  /// \\param[in] target\n  ///     The target to use when trying resolve the address into\n  ///     a section + offset. The Target's SectionLoadList object\n  ///     is used to resolve the address.\n  ///\n  /// \\param[in] allow_section_end\n  ///     If true, treat an address pointing to the end of the module as\n  ///     belonging to that module.\n  ///\n  /// \\return\n  ///     Returns \\b true if the load address was resolved to be\n  ///     section/offset, \\b false otherwise. It is often ok for an\n  ///     address to not resolve to a section in a module, this often\n  ///     happens for JIT'ed code, or any load addresses on the stack\n  ///     or heap.\n  bool SetLoadAddress(lldb::addr_t load_addr, Target *target,\n                      bool allow_section_end = false);\n\n  bool SetOpcodeLoadAddress(\n      lldb::addr_t load_addr, Target *target,\n      AddressClass addr_class = AddressClass::eInvalid,\n      bool allow_section_end = false);\n\n  bool SetCallableLoadAddress(lldb::addr_t load_addr, Target *target);\n\n  /// Get accessor for the module for this address.\n  ///\n  /// \\return\n  ///     Returns the Module pointer that this address is an offset\n  ///     in, or NULL if this address doesn't belong in a module, or\n  ///     isn't resolved yet.\n  lldb::ModuleSP GetModule() const;\n\n  /// Get const accessor for the section.\n  ///\n  /// \\return\n  ///     Returns the const lldb::Section pointer that this address is an\n  ///     offset in, or NULL if this address is absolute.\n  lldb::SectionSP GetSection() const { return m_section_wp.lock(); }\n\n  /// Set accessor for the offset.\n  ///\n  /// \\param[in] offset\n  ///     A new offset value for this object.\n  ///\n  /// \\return\n  ///     Returns \\b true if the offset changed, \\b false otherwise.\n  bool SetOffset(lldb::addr_t offset) {\n    bool changed = m_offset != offset;\n    m_offset = offset;\n    return changed;\n  }\n\n  void SetRawAddress(lldb::addr_t addr) {\n    m_section_wp.reset();\n    m_offset = addr;\n  }\n\n  bool Slide(int64_t offset) {\n    if (m_offset != LLDB_INVALID_ADDRESS) {\n      m_offset += offset;\n      return true;\n    }\n    return false;\n  }\n\n  /// Set accessor for the section.\n  ///\n  /// \\param[in] section_sp\n  ///     A new lldb::Section pointer to use as the section base. Can\n  ///     be NULL for absolute addresses that are not relative to\n  ///     any section.\n  void SetSection(const lldb::SectionSP &section_sp) {\n    m_section_wp = section_sp;\n  }\n\n  void ClearSection() { m_section_wp.reset(); }\n\n  /// Reconstruct a symbol context from an address.\n  ///\n  /// This class doesn't inherit from SymbolContextScope because many address\n  /// objects have short lifespans. Address objects that are section offset\n  /// can reconstruct their symbol context by looking up the address in the\n  /// module found in the section.\n  ///\n  /// \\see SymbolContextScope::CalculateSymbolContext(SymbolContext*)\n  uint32_t CalculateSymbolContext(SymbolContext *sc,\n                                  lldb::SymbolContextItem resolve_scope =\n                                      lldb::eSymbolContextEverything) const;\n\n  lldb::ModuleSP CalculateSymbolContextModule() const;\n\n  CompileUnit *CalculateSymbolContextCompileUnit() const;\n\n  Function *CalculateSymbolContextFunction() const;\n\n  Block *CalculateSymbolContextBlock() const;\n\n  Symbol *CalculateSymbolContextSymbol() const;\n\n  bool CalculateSymbolContextLineEntry(LineEntry &line_entry) const;\n\n  // Returns true if the section should be valid, but isn't because the shared\n  // pointer to the section can't be reconstructed from a weak pointer that\n  // contains a valid weak reference to a section. Returns false if the section\n  // weak pointer has no reference to a section, or if the section is still\n  // valid\n  bool SectionWasDeleted() const;\n\nprotected:\n  // Member variables.\n  lldb::SectionWP m_section_wp; ///< The section for the address, can be NULL.\n  lldb::addr_t m_offset; ///< Offset into section if \\a m_section_wp is valid...\n\n  // Returns true if the m_section_wp once had a reference to a valid section\n  // shared pointer, but no longer does. This can happen if we have an address\n  // from a module that gets unloaded and deleted. This function should only be\n  // called if GetSection() returns an empty shared pointer and you want to\n  // know if this address used to have a valid section.\n  bool SectionWasDeletedPrivate() const;\n};\n\n// NOTE: Be careful using this operator. It can correctly compare two\n// addresses from the same Module correctly. It can't compare two addresses\n// from different modules in any meaningful way, but it will compare the module\n// pointers.\n//\n// To sum things up:\n// - works great for addresses within the same module - it works for addresses\n// across multiple modules, but don't expect the\n//   address results to make much sense\n//\n// This basically lets Address objects be used in ordered collection classes.\nbool operator<(const Address &lhs, const Address &rhs);\nbool operator>(const Address &lhs, const Address &rhs);\nbool operator==(const Address &lhs, const Address &rhs);\nbool operator!=(const Address &lhs, const Address &rhs);\n\n} // namespace lldb_private\n\n#endif // LLDB_CORE_ADDRESS_H\n"}, "3": {"id": 3, "path": "/home/vsts/work/1/llvm-project/lldb/include/lldb/Core/Disassembler.h", "content": "//===-- Disassembler.h ------------------------------------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLDB_CORE_DISASSEMBLER_H\n#define LLDB_CORE_DISASSEMBLER_H\n\n#include \"lldb/Core/Address.h\"\n#include \"lldb/Core/EmulateInstruction.h\"\n#include \"lldb/Core/FormatEntity.h\"\n#include \"lldb/Core/Opcode.h\"\n#include \"lldb/Core/PluginInterface.h\"\n#include \"lldb/Interpreter/OptionValue.h\"\n#include \"lldb/Symbol/LineEntry.h\"\n#include \"lldb/Target/ExecutionContext.h\"\n#include \"lldb/Utility/ArchSpec.h\"\n#include \"lldb/Utility/ConstString.h\"\n#include \"lldb/Utility/FileSpec.h\"\n#include \"lldb/lldb-defines.h\"\n#include \"lldb/lldb-forward.h\"\n#include \"lldb/lldb-private-enumerations.h\"\n#include \"lldb/lldb-types.h\"\n\n#include \"llvm/ADT/StringRef.h\"\n\n#include <functional>\n#include <map>\n#include <memory>\n#include <set>\n#include <string>\n#include <vector>\n\n#include <stddef.h>\n#include <stdint.h>\n#include <stdio.h>\n\nnamespace llvm {\ntemplate <typename T> class SmallVectorImpl;\n}\n\nnamespace lldb_private {\nclass AddressRange;\nclass DataExtractor;\nclass Debugger;\nclass Disassembler;\nclass Module;\nclass StackFrame;\nclass Stream;\nclass SymbolContext;\nclass SymbolContextList;\nclass Target;\nstruct RegisterInfo;\n\nclass Instruction {\npublic:\n  Instruction(const Address &address,\n              AddressClass addr_class = AddressClass::eInvalid);\n\n  virtual ~Instruction();\n\n  const Address &GetAddress() const { return m_address; }\n\n  const char *GetMnemonic(const ExecutionContext *exe_ctx) {\n    CalculateMnemonicOperandsAndCommentIfNeeded(exe_ctx);\n    return m_opcode_name.c_str();\n  }\n\n  const char *GetOperands(const ExecutionContext *exe_ctx) {\n    CalculateMnemonicOperandsAndCommentIfNeeded(exe_ctx);\n    return m_mnemonics.c_str();\n  }\n\n  const char *GetComment(const ExecutionContext *exe_ctx) {\n    CalculateMnemonicOperandsAndCommentIfNeeded(exe_ctx);\n    return m_comment.c_str();\n  }\n\n  virtual void\n  CalculateMnemonicOperandsAndComment(const ExecutionContext *exe_ctx) = 0;\n\n  AddressClass GetAddressClass();\n\n  void SetAddress(const Address &addr) {\n    // Invalidate the address class to lazily discover it if we need to.\n    m_address_class = AddressClass::eInvalid;\n    m_address = addr;\n  }\n\n  /// Dump the text representation of this Instruction to a Stream\n  ///\n  /// Print the (optional) address, (optional) bytes, opcode,\n  /// operands, and instruction comments to a stream.\n  ///\n  /// \\param[in] s\n  ///     The Stream to add the text to.\n  ///\n  /// \\param[in] show_address\n  ///     Whether the address (using disassembly_addr_format_spec formatting)\n  ///     should be printed.\n  ///\n  /// \\param[in] show_bytes\n  ///     Whether the bytes of the assembly instruction should be printed.\n  ///\n  /// \\param[in] max_opcode_byte_size\n  ///     The size (in bytes) of the largest instruction in the list that\n  ///     we are printing (for text justification/alignment purposes)\n  ///     Only needed if show_bytes is true.\n  ///\n  /// \\param[in] exe_ctx\n  ///     The current execution context, if available.  May be used in\n  ///     the assembling of the operands+comments for this instruction.\n  ///     Pass NULL if not applicable.\n  ///\n  /// \\param[in] sym_ctx\n  ///     The SymbolContext for this instruction.\n  ///     Pass NULL if not available/computed.\n  ///     Only needed if show_address is true.\n  ///\n  /// \\param[in] prev_sym_ctx\n  ///     The SymbolContext for the previous instruction.  Depending on\n  ///     the disassembly address format specification, a change in\n  ///     Symbol / Function may mean that a line is printed with the new\n  ///     symbol/function name.\n  ///     Pass NULL if unavailable, or if this is the first instruction of\n  ///     the InstructionList.\n  ///     Only needed if show_address is true.\n  ///\n  /// \\param[in] disassembly_addr_format\n  ///     The format specification for how addresses are printed.\n  ///     Only needed if show_address is true.\n  ///\n  /// \\param[in] max_address_text_size\n  ///     The length of the longest address string at the start of the\n  ///     disassembly line that will be printed (the\n  ///     Debugger::FormatDisassemblerAddress() string)\n  ///     so this method can properly align the instruction opcodes.\n  ///     May be 0 to indicate no indentation/alignment of the opcodes.\n  virtual void Dump(Stream *s, uint32_t max_opcode_byte_size, bool show_address,\n                    bool show_bytes, const ExecutionContext *exe_ctx,\n                    const SymbolContext *sym_ctx,\n                    const SymbolContext *prev_sym_ctx,\n                    const FormatEntity::Entry *disassembly_addr_format,\n                    size_t max_address_text_size);\n\n  virtual bool DoesBranch() = 0;\n\n  virtual bool HasDelaySlot();\n\n  bool CanSetBreakpoint ();\n\n  virtual size_t Decode(const Disassembler &disassembler,\n                        const DataExtractor &data,\n                        lldb::offset_t data_offset) = 0;\n\n  virtual void SetDescription(llvm::StringRef) {\n  } // May be overridden in sub-classes that have descriptions.\n\n  lldb::OptionValueSP ReadArray(FILE *in_file, Stream *out_stream,\n                                OptionValue::Type data_type);\n\n  lldb::OptionValueSP ReadDictionary(FILE *in_file, Stream *out_stream);\n\n  bool DumpEmulation(const ArchSpec &arch);\n\n  virtual bool TestEmulation(Stream *stream, const char *test_file_name);\n\n  bool Emulate(const ArchSpec &arch, uint32_t evaluate_options, void *baton,\n               EmulateInstruction::ReadMemoryCallback read_mem_callback,\n               EmulateInstruction::WriteMemoryCallback write_mem_calback,\n               EmulateInstruction::ReadRegisterCallback read_reg_callback,\n               EmulateInstruction::WriteRegisterCallback write_reg_callback);\n\n  const Opcode &GetOpcode() const { return m_opcode; }\n\n  uint32_t GetData(DataExtractor &data);\n\n  struct Operand {\n    enum class Type {\n      Invalid = 0,\n      Register,\n      Immediate,\n      Dereference,\n      Sum,\n      Product\n    } m_type = Type::Invalid;\n    std::vector<Operand> m_children;\n    lldb::addr_t m_immediate = 0;\n    ConstString m_register;\n    bool m_negative = false;\n    bool m_clobbered = false;\n\n    bool IsValid() { return m_type != Type::Invalid; }\n\n    static Operand BuildRegister(ConstString &r);\n    static Operand BuildImmediate(lldb::addr_t imm, bool neg);\n    static Operand BuildImmediate(int64_t imm);\n    static Operand BuildDereference(const Operand &ref);\n    static Operand BuildSum(const Operand &lhs, const Operand &rhs);\n    static Operand BuildProduct(const Operand &lhs, const Operand &rhs);\n  };\n\n  virtual bool ParseOperands(llvm::SmallVectorImpl<Operand> &operands) {\n    return false;\n  }\n\n  virtual bool IsCall() { return false; }\n\nprotected:\n  Address m_address; // The section offset address of this instruction\n                     // We include an address class in the Instruction class to\n                     // allow the instruction specify the\n                     // AddressClass::eCodeAlternateISA (currently used for\n                     // thumb), and also to specify data (AddressClass::eData).\n                     // The usual value will be AddressClass::eCode, but often\n                     // when disassembling memory, you might run into data.\n                     // This can help us to disassemble appropriately.\nprivate:\n  AddressClass m_address_class; // Use GetAddressClass () accessor function!\n\nprotected:\n  Opcode m_opcode; // The opcode for this instruction\n  std::string m_opcode_name;\n  std::string m_mnemonics;\n  std::string m_comment;\n  bool m_calculated_strings;\n\n  void\n  CalculateMnemonicOperandsAndCommentIfNeeded(const ExecutionContext *exe_ctx) {\n    if (!m_calculated_strings) {\n      m_calculated_strings = true;\n      CalculateMnemonicOperandsAndComment(exe_ctx);\n    }\n  }\n};\n\nnamespace OperandMatchers {\nstd::function<bool(const Instruction::Operand &)>\nMatchBinaryOp(std::function<bool(const Instruction::Operand &)> base,\n              std::function<bool(const Instruction::Operand &)> left,\n              std::function<bool(const Instruction::Operand &)> right);\n\nstd::function<bool(const Instruction::Operand &)>\nMatchUnaryOp(std::function<bool(const Instruction::Operand &)> base,\n             std::function<bool(const Instruction::Operand &)> child);\n\nstd::function<bool(const Instruction::Operand &)>\nMatchRegOp(const RegisterInfo &info);\n\nstd::function<bool(const Instruction::Operand &)> FetchRegOp(ConstString &reg);\n\nstd::function<bool(const Instruction::Operand &)> MatchImmOp(int64_t imm);\n\nstd::function<bool(const Instruction::Operand &)> FetchImmOp(int64_t &imm);\n\nstd::function<bool(const Instruction::Operand &)>\nMatchOpType(Instruction::Operand::Type type);\n}\n\nclass InstructionList {\npublic:\n  InstructionList();\n  ~InstructionList();\n\n  size_t GetSize() const;\n\n  uint32_t GetMaxOpcocdeByteSize() const;\n\n  lldb::InstructionSP GetInstructionAtIndex(size_t idx) const;\n\n  /// Get the instruction at the given address.\n  ///\n  /// \\return\n  ///    A valid \\a InstructionSP if the address could be found, or null\n  ///    otherwise.\n  lldb::InstructionSP GetInstructionAtAddress(const Address &addr);\n\n  //------------------------------------------------------------------\n  /// Get the index of the next branch instruction.\n  ///\n  /// Given a list of instructions, find the next branch instruction\n  /// in the list by returning an index.\n  ///\n  /// @param[in] start\n  ///     The instruction index of the first instruction to check.\n  ///\n  /// @param[in] ignore_calls\n  ///     It true, then fine the first branch instruction that isn't\n  ///     a function call (a branch that calls and returns to the next\n  ///     instruction). If false, find the instruction index of any \n  ///     branch in the list.\n  ///     \n  /// @param[out] found_calls\n  ///     If non-null, this will be set to true if any calls were found in \n  ///     extending the range.\n  ///    \n  /// @return\n  ///     The instruction index of the first branch that is at or past\n  ///     \\a start. Returns UINT32_MAX if no matching branches are \n  ///     found.\n  //------------------------------------------------------------------\n  uint32_t GetIndexOfNextBranchInstruction(uint32_t start,\n                                           bool ignore_calls,\n                                           bool *found_calls) const;\n\n  uint32_t GetIndexOfInstructionAtLoadAddress(lldb::addr_t load_addr,\n                                              Target &target);\n\n  uint32_t GetIndexOfInstructionAtAddress(const Address &addr);\n\n  void Clear();\n\n  void Append(lldb::InstructionSP &inst_sp);\n\n  void Dump(Stream *s, bool show_address, bool show_bytes,\n            const ExecutionContext *exe_ctx);\n\nprivate:\n  typedef std::vector<lldb::InstructionSP> collection;\n  typedef collection::iterator iterator;\n  typedef collection::const_iterator const_iterator;\n\n  collection m_instructions;\n};\n\nclass PseudoInstruction : public Instruction {\npublic:\n  PseudoInstruction();\n\n  ~PseudoInstruction() override;\n\n  bool DoesBranch() override;\n\n  bool HasDelaySlot() override;\n\n  void CalculateMnemonicOperandsAndComment(\n      const ExecutionContext *exe_ctx) override {\n    // TODO: fill this in and put opcode name into Instruction::m_opcode_name,\n    // mnemonic into Instruction::m_mnemonics, and any comment into\n    // Instruction::m_comment\n  }\n\n  size_t Decode(const Disassembler &disassembler, const DataExtractor &data,\n                lldb::offset_t data_offset) override;\n\n  void SetOpcode(size_t opcode_size, void *opcode_data);\n\n  void SetDescription(llvm::StringRef description) override;\n\nprotected:\n  std::string m_description;\n\n  PseudoInstruction(const PseudoInstruction &) = delete;\n  const PseudoInstruction &operator=(const PseudoInstruction &) = delete;\n};\n\nclass Disassembler : public std::enable_shared_from_this<Disassembler>,\n                     public PluginInterface {\npublic:\n  enum {\n    eOptionNone = 0u,\n    eOptionShowBytes = (1u << 0),\n    eOptionRawOuput = (1u << 1),\n    eOptionMarkPCSourceLine = (1u << 2), // Mark the source line that contains\n                                         // the current PC (mixed mode only)\n    eOptionMarkPCAddress =\n        (1u << 3) // Mark the disassembly line the contains the PC\n  };\n\n  enum HexImmediateStyle {\n    eHexStyleC,\n    eHexStyleAsm,\n  };\n\n  // FindPlugin should be lax about the flavor string (it is too annoying to\n  // have various internal uses of the disassembler fail because the global\n  // flavor string gets set wrong. Instead, if you get a flavor string you\n  // don't understand, use the default.  Folks who care to check can use the\n  // FlavorValidForArchSpec method on the disassembler they got back.\n  static lldb::DisassemblerSP\n  FindPlugin(const ArchSpec &arch, const char *flavor, const char *plugin_name);\n\n  // This version will use the value in the Target settings if flavor is NULL;\n  static lldb::DisassemblerSP FindPluginForTarget(const Target &target,\n                                                  const ArchSpec &arch,\n                                                  const char *flavor,\n                                                  const char *plugin_name);\n\n  struct Limit {\n    enum { Bytes, Instructions } kind;\n    lldb::addr_t value;\n  };\n\n  static lldb::DisassemblerSP\n  DisassembleRange(const ArchSpec &arch, const char *plugin_name,\n                   const char *flavor, Target &target,\n                   const AddressRange &disasm_range, bool prefer_file_cache);\n\n  static lldb::DisassemblerSP\n  DisassembleBytes(const ArchSpec &arch, const char *plugin_name,\n                   const char *flavor, const Address &start, const void *bytes,\n                   size_t length, uint32_t max_num_instructions,\n                   bool data_from_file);\n\n  static bool Disassemble(Debugger &debugger, const ArchSpec &arch,\n                          const char *plugin_name, const char *flavor,\n                          const ExecutionContext &exe_ctx, const Address &start,\n                          Limit limit, bool mixed_source_and_assembly,\n                          uint32_t num_mixed_context_lines, uint32_t options,\n                          Stream &strm);\n\n  static bool Disassemble(Debugger &debugger, const ArchSpec &arch,\n                          StackFrame &frame, Stream &strm);\n\n  // Constructors and Destructors\n  Disassembler(const ArchSpec &arch, const char *flavor);\n  ~Disassembler() override;\n\n  void PrintInstructions(Debugger &debugger, const ArchSpec &arch,\n                         const ExecutionContext &exe_ctx,\n                         bool mixed_source_and_assembly,\n                         uint32_t num_mixed_context_lines, uint32_t options,\n                         Stream &strm);\n\n  size_t ParseInstructions(Target &target, Address address, Limit limit,\n                           Stream *error_strm_ptr, bool prefer_file_cache);\n\n  virtual size_t DecodeInstructions(const Address &base_addr,\n                                    const DataExtractor &data,\n                                    lldb::offset_t data_offset,\n                                    size_t num_instructions, bool append,\n                                    bool data_from_file) = 0;\n\n  InstructionList &GetInstructionList();\n\n  const InstructionList &GetInstructionList() const;\n\n  const ArchSpec &GetArchitecture() const { return m_arch; }\n\n  const char *GetFlavor() const { return m_flavor.c_str(); }\n\n  virtual bool FlavorValidForArchSpec(const lldb_private::ArchSpec &arch,\n                                      const char *flavor) = 0;\n\nprotected:\n  // SourceLine and SourceLinesToDisplay structures are only used in the mixed\n  // source and assembly display methods internal to this class.\n\n  struct SourceLine {\n    FileSpec file;\n    uint32_t line;\n    uint32_t column;\n\n    SourceLine() : file(), line(LLDB_INVALID_LINE_NUMBER), column(0) {}\n\n    bool operator==(const SourceLine &rhs) const {\n      return file == rhs.file && line == rhs.line && rhs.column == column;\n    }\n\n    bool operator!=(const SourceLine &rhs) const {\n      return file != rhs.file || line != rhs.line || column != rhs.column;\n    }\n\n    bool IsValid() const { return line != LLDB_INVALID_LINE_NUMBER; }\n  };\n\n  struct SourceLinesToDisplay {\n    std::vector<SourceLine> lines;\n\n    // index of the \"current\" source line, if we want to highlight that when\n    // displaying the source lines.  (as opposed to the surrounding source\n    // lines provided to give context)\n    size_t current_source_line;\n\n    // Whether to print a blank line at the end of the source lines.\n    bool print_source_context_end_eol;\n\n    SourceLinesToDisplay()\n        : lines(), current_source_line(-1), print_source_context_end_eol(true) {\n    }\n  };\n\n  // Get the function's declaration line number, hopefully a line number\n  // earlier than the opening curly brace at the start of the function body.\n  static SourceLine GetFunctionDeclLineEntry(const SymbolContext &sc);\n\n  // Add the provided SourceLine to the map of filenames-to-source-lines-seen.\n  static void AddLineToSourceLineTables(\n      SourceLine &line,\n      std::map<FileSpec, std::set<uint32_t>> &source_lines_seen);\n\n  // Given a source line, determine if we should print it when we're doing\n  // mixed source & assembly output. We're currently using the\n  // target.process.thread.step-avoid-regexp setting (which is used for\n  // stepping over inlined STL functions by default) to determine what source\n  // lines to avoid showing.\n  //\n  // Returns true if this source line should be elided (if the source line\n  // should not be displayed).\n  static bool\n  ElideMixedSourceAndDisassemblyLine(const ExecutionContext &exe_ctx,\n                                     const SymbolContext &sc, SourceLine &line);\n\n  static bool\n  ElideMixedSourceAndDisassemblyLine(const ExecutionContext &exe_ctx,\n                                     const SymbolContext &sc, LineEntry &line) {\n    SourceLine sl;\n    sl.file = line.file;\n    sl.line = line.line;\n    sl.column = line.column;\n    return ElideMixedSourceAndDisassemblyLine(exe_ctx, sc, sl);\n  };\n\n  // Classes that inherit from Disassembler can see and modify these\n  ArchSpec m_arch;\n  InstructionList m_instruction_list;\n  lldb::addr_t m_base_addr;\n  std::string m_flavor;\n\nprivate:\n  // For Disassembler only\n  Disassembler(const Disassembler &) = delete;\n  const Disassembler &operator=(const Disassembler &) = delete;\n};\n\n} // namespace lldb_private\n\n#endif // LLDB_CORE_DISASSEMBLER_H\n"}, "4": {"id": 4, "path": "/home/vsts/work/1/llvm-project/lldb/include/lldb/Core/EmulateInstruction.h", "content": "//===-- EmulateInstruction.h ------------------------------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLDB_CORE_EMULATEINSTRUCTION_H\n#define LLDB_CORE_EMULATEINSTRUCTION_H\n\n#include <string>\n\n#include \"lldb/Core/Address.h\"\n#include \"lldb/Core/Opcode.h\"\n#include \"lldb/Core/PluginInterface.h\"\n#include \"lldb/Utility/ArchSpec.h\"\n#include \"lldb/lldb-defines.h\"\n#include \"lldb/lldb-enumerations.h\"\n#include \"lldb/lldb-private-enumerations.h\"\n#include \"lldb/lldb-private-types.h\"\n#include \"lldb/lldb-types.h\"\n\n#include <stddef.h>\n#include <stdint.h>\n\nnamespace lldb_private {\nclass OptionValueDictionary;\nclass RegisterContext;\nclass RegisterValue;\nclass Stream;\nclass Target;\nclass UnwindPlan;\n\n/// \\class EmulateInstruction EmulateInstruction.h\n/// \"lldb/Core/EmulateInstruction.h\"\n/// A class that allows emulation of CPU opcodes.\n///\n/// This class is a plug-in interface that is accessed through the standard\n/// static FindPlugin function call in the EmulateInstruction class. The\n/// FindPlugin takes a target triple and returns a new object if there is a\n/// plug-in that supports the architecture and OS. Four callbacks and a baton\n/// are provided. The four callbacks are read register, write register, read\n/// memory and write memory.\n///\n/// This class is currently designed for these main use cases: - Auto\n/// generation of Call Frame Information (CFI) from assembly code - Predicting\n/// single step breakpoint locations - Emulating instructions for breakpoint\n/// traps\n///\n/// Objects can be asked to read an instruction which will cause a call to the\n/// read register callback to get the PC, followed by a read memory call to\n/// read the opcode. If ReadInstruction () returns true, then a call to\n/// EmulateInstruction::EvaluateInstruction () can be made. At this point the\n/// EmulateInstruction subclass will use all of the callbacks to emulate an\n/// instruction.\n///\n/// Clients that provide the callbacks can either do the read/write\n/// registers/memory to actually emulate the instruction on a real or virtual\n/// CPU, or watch for the EmulateInstruction::Context which is context for the\n/// read/write register/memory which explains why the callback is being\n/// called. Examples of a context are: \"pushing register 3 onto the stack at\n/// offset -12\", or \"adjusting stack pointer by -16\". This extra context\n/// allows the generation of\n/// CFI information from assembly code without having to actually do\n/// the read/write register/memory.\n///\n/// Clients must be prepared that not all instructions for an Instruction Set\n/// Architecture (ISA) will be emulated.\n///\n/// Subclasses at the very least should implement the instructions that save\n/// and restore registers onto the stack and adjustment to the stack pointer.\n/// By just implementing a few instructions for an ISA that are the typical\n/// prologue opcodes, you can then generate CFI using a class that will soon\n/// be available.\n///\n/// Implementing all of the instructions that affect the PC can then allow\n/// single step prediction support.\n///\n/// Implementing all of the instructions allows for emulation of opcodes for\n/// breakpoint traps and will pave the way for \"thread centric\" debugging. The\n/// current debugging model is \"process centric\" where all threads must be\n/// stopped when any thread is stopped; when hitting software breakpoints we\n/// must disable the breakpoint by restoring the original breakpoint opcode,\n/// single stepping and restoring the breakpoint trap. If all threads were\n/// allowed to run then other threads could miss the breakpoint.\n///\n/// This class centralizes the code that usually is done in separate code\n/// paths in a debugger (single step prediction, finding save restore\n/// locations of registers for unwinding stack frame variables) and emulating\n/// the instruction is just a bonus.\n\nclass EmulateInstruction : public PluginInterface {\npublic:\n  static EmulateInstruction *FindPlugin(const ArchSpec &arch,\n                                        InstructionType supported_inst_type,\n                                        const char *plugin_name);\n\n  enum ContextType {\n    eContextInvalid = 0,\n    // Read an instruction opcode from memory\n    eContextReadOpcode,\n\n    // Usually used for writing a register value whose source value is an\n    // immediate\n    eContextImmediate,\n\n    // Exclusively used when saving a register to the stack as part of the\n    // prologue\n    eContextPushRegisterOnStack,\n\n    // Exclusively used when restoring a register off the stack as part of the\n    // epilogue\n    eContextPopRegisterOffStack,\n\n    // Add or subtract a value from the stack\n    eContextAdjustStackPointer,\n\n    // Adjust the frame pointer for the current frame\n    eContextSetFramePointer,\n\n    // Typically in an epilogue sequence.  Copy the frame pointer back into the\n    // stack pointer, use SP for CFA calculations again.\n    eContextRestoreStackPointer,\n\n    // Add or subtract a value from a base address register (other than SP)\n    eContextAdjustBaseRegister,\n\n    // Add or subtract a value from the PC or store a value to the PC.\n    eContextAdjustPC,\n\n    // Used in WriteRegister callbacks to indicate where the\n    eContextRegisterPlusOffset,\n\n    // Used in WriteMemory callback to indicate where the data came from\n    eContextRegisterStore,\n\n    eContextRegisterLoad,\n\n    // Used when performing a PC-relative branch where the\n    eContextRelativeBranchImmediate,\n\n    // Used when performing an absolute branch where the\n    eContextAbsoluteBranchRegister,\n\n    // Used when performing a supervisor call to an operating system to provide\n    // a service:\n    eContextSupervisorCall,\n\n    // Used when performing a MemU operation to read the PC-relative offset\n    // from an address.\n    eContextTableBranchReadMemory,\n\n    // Used when random bits are written into a register\n    eContextWriteRegisterRandomBits,\n\n    // Used when random bits are written to memory\n    eContextWriteMemoryRandomBits,\n\n    eContextArithmetic,\n\n    eContextAdvancePC,\n\n    eContextReturnFromException\n  };\n\n  enum InfoType {\n    eInfoTypeRegisterPlusOffset,\n    eInfoTypeRegisterPlusIndirectOffset,\n    eInfoTypeRegisterToRegisterPlusOffset,\n    eInfoTypeRegisterToRegisterPlusIndirectOffset,\n    eInfoTypeRegisterRegisterOperands,\n    eInfoTypeOffset,\n    eInfoTypeRegister,\n    eInfoTypeImmediate,\n    eInfoTypeImmediateSigned,\n    eInfoTypeAddress,\n    eInfoTypeISAAndImmediate,\n    eInfoTypeISAAndImmediateSigned,\n    eInfoTypeISA,\n    eInfoTypeNoArgs\n  } InfoType;\n\n  struct Context {\n    ContextType type;\n    enum InfoType info_type;\n    union {\n      struct RegisterPlusOffset {\n        RegisterInfo reg;      // base register\n        int64_t signed_offset; // signed offset added to base register\n      } RegisterPlusOffset;\n\n      struct RegisterPlusIndirectOffset {\n        RegisterInfo base_reg;   // base register number\n        RegisterInfo offset_reg; // offset register kind\n      } RegisterPlusIndirectOffset;\n\n      struct RegisterToRegisterPlusOffset {\n        RegisterInfo data_reg; // source/target register for data\n        RegisterInfo base_reg; // base register for address calculation\n        int64_t offset;        // offset for address calculation\n      } RegisterToRegisterPlusOffset;\n\n      struct RegisterToRegisterPlusIndirectOffset {\n        RegisterInfo base_reg;   // base register for address calculation\n        RegisterInfo offset_reg; // offset register for address calculation\n        RegisterInfo data_reg;   // source/target register for data\n      } RegisterToRegisterPlusIndirectOffset;\n\n      struct RegisterRegisterOperands {\n        RegisterInfo\n            operand1; // register containing first operand for binary op\n        RegisterInfo\n            operand2; // register containing second operand for binary op\n      } RegisterRegisterOperands;\n\n      int64_t signed_offset; // signed offset by which to adjust self (for\n                             // registers only)\n\n      RegisterInfo reg; // plain register\n\n      uint64_t unsigned_immediate; // unsigned immediate value\n      int64_t signed_immediate;    // signed immediate value\n\n      lldb::addr_t address; // direct address\n\n      struct ISAAndImmediate {\n        uint32_t isa;\n        uint32_t unsigned_data32; // immediate data\n      } ISAAndImmediate;\n\n      struct ISAAndImmediateSigned {\n        uint32_t isa;\n        int32_t signed_data32; // signed immediate data\n      } ISAAndImmediateSigned;\n\n      uint32_t isa;\n    } info;\n\n    Context() : type(eContextInvalid), info_type(eInfoTypeNoArgs) {}\n\n    void SetRegisterPlusOffset(RegisterInfo base_reg, int64_t signed_offset) {\n      info_type = eInfoTypeRegisterPlusOffset;\n      info.RegisterPlusOffset.reg = base_reg;\n      info.RegisterPlusOffset.signed_offset = signed_offset;\n    }\n\n    void SetRegisterPlusIndirectOffset(RegisterInfo base_reg,\n                                       RegisterInfo offset_reg) {\n      info_type = eInfoTypeRegisterPlusIndirectOffset;\n      info.RegisterPlusIndirectOffset.base_reg = base_reg;\n      info.RegisterPlusIndirectOffset.offset_reg = offset_reg;\n    }\n\n    void SetRegisterToRegisterPlusOffset(RegisterInfo data_reg,\n                                         RegisterInfo base_reg,\n                                         int64_t offset) {\n      info_type = eInfoTypeRegisterToRegisterPlusOffset;\n      info.RegisterToRegisterPlusOffset.data_reg = data_reg;\n      info.RegisterToRegisterPlusOffset.base_reg = base_reg;\n      info.RegisterToRegisterPlusOffset.offset = offset;\n    }\n\n    void SetRegisterToRegisterPlusIndirectOffset(RegisterInfo base_reg,\n                                                 RegisterInfo offset_reg,\n                                                 RegisterInfo data_reg) {\n      info_type = eInfoTypeRegisterToRegisterPlusIndirectOffset;\n      info.RegisterToRegisterPlusIndirectOffset.base_reg = base_reg;\n      info.RegisterToRegisterPlusIndirectOffset.offset_reg = offset_reg;\n      info.RegisterToRegisterPlusIndirectOffset.data_reg = data_reg;\n    }\n\n    void SetRegisterRegisterOperands(RegisterInfo op1_reg,\n                                     RegisterInfo op2_reg) {\n      info_type = eInfoTypeRegisterRegisterOperands;\n      info.RegisterRegisterOperands.operand1 = op1_reg;\n      info.RegisterRegisterOperands.operand2 = op2_reg;\n    }\n\n    void SetOffset(int64_t signed_offset) {\n      info_type = eInfoTypeOffset;\n      info.signed_offset = signed_offset;\n    }\n\n    void SetRegister(RegisterInfo reg) {\n      info_type = eInfoTypeRegister;\n      info.reg = reg;\n    }\n\n    void SetImmediate(uint64_t immediate) {\n      info_type = eInfoTypeImmediate;\n      info.unsigned_immediate = immediate;\n    }\n\n    void SetImmediateSigned(int64_t signed_immediate) {\n      info_type = eInfoTypeImmediateSigned;\n      info.signed_immediate = signed_immediate;\n    }\n\n    void SetAddress(lldb::addr_t address) {\n      info_type = eInfoTypeAddress;\n      info.address = address;\n    }\n    void SetISAAndImmediate(uint32_t isa, uint32_t data) {\n      info_type = eInfoTypeISAAndImmediate;\n      info.ISAAndImmediate.isa = isa;\n      info.ISAAndImmediate.unsigned_data32 = data;\n    }\n\n    void SetISAAndImmediateSigned(uint32_t isa, int32_t data) {\n      info_type = eInfoTypeISAAndImmediateSigned;\n      info.ISAAndImmediateSigned.isa = isa;\n      info.ISAAndImmediateSigned.signed_data32 = data;\n    }\n\n    void SetISA(uint32_t isa) {\n      info_type = eInfoTypeISA;\n      info.isa = isa;\n    }\n\n    void SetNoArgs() { info_type = eInfoTypeNoArgs; }\n\n    void Dump(Stream &s, EmulateInstruction *instruction) const;\n  };\n\n  typedef size_t (*ReadMemoryCallback)(EmulateInstruction *instruction,\n                                       void *baton, const Context &context,\n                                       lldb::addr_t addr, void *dst,\n                                       size_t length);\n\n  typedef size_t (*WriteMemoryCallback)(EmulateInstruction *instruction,\n                                        void *baton, const Context &context,\n                                        lldb::addr_t addr, const void *dst,\n                                        size_t length);\n\n  typedef bool (*ReadRegisterCallback)(EmulateInstruction *instruction,\n                                       void *baton,\n                                       const RegisterInfo *reg_info,\n                                       RegisterValue &reg_value);\n\n  typedef bool (*WriteRegisterCallback)(EmulateInstruction *instruction,\n                                        void *baton, const Context &context,\n                                        const RegisterInfo *reg_info,\n                                        const RegisterValue &reg_value);\n\n  // Type to represent the condition of an instruction. The UINT32 value is\n  // reserved for the unconditional case and all other value can be used in an\n  // architecture dependent way.\n  typedef uint32_t InstructionCondition;\n  static const InstructionCondition UnconditionalCondition = UINT32_MAX;\n\n  EmulateInstruction(const ArchSpec &arch);\n\n  ~EmulateInstruction() override = default;\n\n  // Mandatory overrides\n  virtual bool\n  SupportsEmulatingInstructionsOfType(InstructionType inst_type) = 0;\n\n  virtual bool SetTargetTriple(const ArchSpec &arch) = 0;\n\n  virtual bool ReadInstruction() = 0;\n\n  virtual bool EvaluateInstruction(uint32_t evaluate_options) = 0;\n\n  virtual InstructionCondition GetInstructionCondition() {\n    return UnconditionalCondition;\n  }\n\n  virtual bool TestEmulation(Stream *out_stream, ArchSpec &arch,\n                             OptionValueDictionary *test_data) = 0;\n\n  virtual bool GetRegisterInfo(lldb::RegisterKind reg_kind, uint32_t reg_num,\n                               RegisterInfo &reg_info) = 0;\n\n  // Optional overrides\n  virtual bool SetInstruction(const Opcode &insn_opcode,\n                              const Address &inst_addr, Target *target);\n\n  virtual bool CreateFunctionEntryUnwind(UnwindPlan &unwind_plan);\n\n  static const char *TranslateRegister(lldb::RegisterKind reg_kind,\n                                       uint32_t reg_num, std::string &reg_name);\n\n  // RegisterInfo variants\n  bool ReadRegister(const RegisterInfo *reg_info, RegisterValue &reg_value);\n\n  uint64_t ReadRegisterUnsigned(const RegisterInfo *reg_info,\n                                uint64_t fail_value, bool *success_ptr);\n\n  bool WriteRegister(const Context &context, const RegisterInfo *ref_info,\n                     const RegisterValue &reg_value);\n\n  bool WriteRegisterUnsigned(const Context &context,\n                             const RegisterInfo *reg_info, uint64_t reg_value);\n\n  // Register kind and number variants\n  bool ReadRegister(lldb::RegisterKind reg_kind, uint32_t reg_num,\n                    RegisterValue &reg_value);\n\n  bool WriteRegister(const Context &context, lldb::RegisterKind reg_kind,\n                     uint32_t reg_num, const RegisterValue &reg_value);\n\n  uint64_t ReadRegisterUnsigned(lldb::RegisterKind reg_kind, uint32_t reg_num,\n                                uint64_t fail_value, bool *success_ptr);\n\n  bool WriteRegisterUnsigned(const Context &context,\n                             lldb::RegisterKind reg_kind, uint32_t reg_num,\n                             uint64_t reg_value);\n\n  size_t ReadMemory(const Context &context, lldb::addr_t addr, void *dst,\n                    size_t dst_len);\n\n  uint64_t ReadMemoryUnsigned(const Context &context, lldb::addr_t addr,\n                              size_t byte_size, uint64_t fail_value,\n                              bool *success_ptr);\n\n  bool WriteMemory(const Context &context, lldb::addr_t addr, const void *src,\n                   size_t src_len);\n\n  bool WriteMemoryUnsigned(const Context &context, lldb::addr_t addr,\n                           uint64_t uval, size_t uval_byte_size);\n\n  uint32_t GetAddressByteSize() const { return m_arch.GetAddressByteSize(); }\n\n  lldb::ByteOrder GetByteOrder() const { return m_arch.GetByteOrder(); }\n\n  const Opcode &GetOpcode() const { return m_opcode; }\n\n  lldb::addr_t GetAddress() const { return m_addr; }\n\n  const ArchSpec &GetArchitecture() const { return m_arch; }\n\n  static size_t ReadMemoryFrame(EmulateInstruction *instruction, void *baton,\n                                const Context &context, lldb::addr_t addr,\n                                void *dst, size_t length);\n\n  static size_t WriteMemoryFrame(EmulateInstruction *instruction, void *baton,\n                                 const Context &context, lldb::addr_t addr,\n                                 const void *dst, size_t length);\n\n  static bool ReadRegisterFrame(EmulateInstruction *instruction, void *baton,\n                                const RegisterInfo *reg_info,\n                                RegisterValue &reg_value);\n\n  static bool WriteRegisterFrame(EmulateInstruction *instruction, void *baton,\n                                 const Context &context,\n                                 const RegisterInfo *reg_info,\n                                 const RegisterValue &reg_value);\n\n  static size_t ReadMemoryDefault(EmulateInstruction *instruction, void *baton,\n                                  const Context &context, lldb::addr_t addr,\n                                  void *dst, size_t length);\n\n  static size_t WriteMemoryDefault(EmulateInstruction *instruction, void *baton,\n                                   const Context &context, lldb::addr_t addr,\n                                   const void *dst, size_t length);\n\n  static bool ReadRegisterDefault(EmulateInstruction *instruction, void *baton,\n                                  const RegisterInfo *reg_info,\n                                  RegisterValue &reg_value);\n\n  static bool WriteRegisterDefault(EmulateInstruction *instruction, void *baton,\n                                   const Context &context,\n                                   const RegisterInfo *reg_info,\n                                   const RegisterValue &reg_value);\n\n  void SetBaton(void *baton);\n\n  void SetCallbacks(ReadMemoryCallback read_mem_callback,\n                    WriteMemoryCallback write_mem_callback,\n                    ReadRegisterCallback read_reg_callback,\n                    WriteRegisterCallback write_reg_callback);\n\n  void SetReadMemCallback(ReadMemoryCallback read_mem_callback);\n\n  void SetWriteMemCallback(WriteMemoryCallback write_mem_callback);\n\n  void SetReadRegCallback(ReadRegisterCallback read_reg_callback);\n\n  void SetWriteRegCallback(WriteRegisterCallback write_reg_callback);\n\n  static bool GetBestRegisterKindAndNumber(const RegisterInfo *reg_info,\n                                           lldb::RegisterKind &reg_kind,\n                                           uint32_t &reg_num);\n\n  static uint32_t GetInternalRegisterNumber(RegisterContext *reg_ctx,\n                                            const RegisterInfo &reg_info);\n\nprotected:\n  ArchSpec m_arch;\n  void *m_baton = nullptr;\n  ReadMemoryCallback m_read_mem_callback = &ReadMemoryDefault;\n  WriteMemoryCallback m_write_mem_callback = &WriteMemoryDefault;\n  ReadRegisterCallback m_read_reg_callback = &ReadRegisterDefault;\n  WriteRegisterCallback m_write_reg_callback = &WriteRegisterDefault;\n  lldb::addr_t m_addr = LLDB_INVALID_ADDRESS;\n  Opcode m_opcode;\n\nprivate:\n  // For EmulateInstruction only\n  EmulateInstruction(const EmulateInstruction &) = delete;\n  const EmulateInstruction &operator=(const EmulateInstruction &) = delete;\n};\n\n} // namespace lldb_private\n\n#endif // LLDB_CORE_EMULATEINSTRUCTION_H\n"}, "5": {"id": 5, "path": "/home/vsts/work/1/llvm-project/lldb/include/lldb/Core/FormatEntity.h", "content": "//===-- FormatEntity.h ------------------------------------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLDB_CORE_FORMATENTITY_H\n#define LLDB_CORE_FORMATENTITY_H\n\n#include \"lldb/Utility/CompletionRequest.h\"\n#include \"lldb/Utility/FileSpec.h\"\n#include \"lldb/Utility/Status.h\"\n#include \"lldb/lldb-enumerations.h\"\n#include \"lldb/lldb-types.h\"\n#include <algorithm>\n#include <stddef.h>\n#include <stdint.h>\n\n#include <string>\n#include <vector>\n\nnamespace lldb_private {\nclass Address;\nclass ExecutionContext;\nclass Stream;\nclass StringList;\nclass SymbolContext;\nclass ValueObject;\n}\nnamespace llvm {\nclass StringRef;\n}\n\nnamespace lldb_private {\nclass FormatEntity {\npublic:\n  struct Entry {\n    enum class Type {\n      Invalid,\n      ParentNumber,\n      ParentString,\n      EscapeCode,\n      Root,\n      String,\n      Scope,\n      Variable,\n      VariableSynthetic,\n      ScriptVariable,\n      ScriptVariableSynthetic,\n      AddressLoad,\n      AddressFile,\n      AddressLoadOrFile,\n      ProcessID,\n      ProcessFile,\n      ScriptProcess,\n      ThreadID,\n      ThreadProtocolID,\n      ThreadIndexID,\n      ThreadName,\n      ThreadQueue,\n      ThreadStopReason,\n      ThreadStopReasonRaw,\n      ThreadReturnValue,\n      ThreadCompletedExpression,\n      ScriptThread,\n      ThreadInfo,\n      TargetArch,\n      ScriptTarget,\n      ModuleFile,\n      File,\n      Lang,\n      FrameIndex,\n      FrameNoDebug,\n      FrameRegisterPC,\n      FrameRegisterSP,\n      FrameRegisterFP,\n      FrameRegisterFlags,\n      FrameRegisterByName,\n      FrameIsArtificial,\n      ScriptFrame,\n      FunctionID,\n      FunctionDidChange,\n      FunctionInitialFunction,\n      FunctionName,\n      FunctionNameWithArgs,\n      FunctionNameNoArgs,\n      FunctionMangledName,\n      FunctionAddrOffset,\n      FunctionAddrOffsetConcrete,\n      FunctionLineOffset,\n      FunctionPCOffset,\n      FunctionInitial,\n      FunctionChanged,\n      FunctionIsOptimized,\n      LineEntryFile,\n      LineEntryLineNumber,\n      LineEntryColumn,\n      LineEntryStartAddress,\n      LineEntryEndAddress,\n      CurrentPCArrow\n    };\n\n    struct Definition {\n      const char *name;\n      const char *string; // Insert this exact string into the output\n      Entry::Type type;\n      uint64_t data;\n      uint32_t num_children;\n      Definition *children; // An array of \"num_children\" Definition entries,\n      bool keep_separator;\n    };\n\n    Entry(Type t = Type::Invalid, const char *s = nullptr,\n          const char *f = nullptr)\n        : string(s ? s : \"\"), printf_format(f ? f : \"\"), children(),\n          definition(nullptr), type(t), fmt(lldb::eFormatDefault), number(0),\n          deref(false) {}\n\n    Entry(llvm::StringRef s);\n    Entry(char ch);\n\n    void AppendChar(char ch);\n\n    void AppendText(const llvm::StringRef &s);\n\n    void AppendText(const char *cstr);\n\n    void AppendEntry(const Entry &&entry) { children.push_back(entry); }\n\n    void Clear() {\n      string.clear();\n      printf_format.clear();\n      children.clear();\n      definition = nullptr;\n      type = Type::Invalid;\n      fmt = lldb::eFormatDefault;\n      number = 0;\n      deref = false;\n    }\n\n    static const char *TypeToCString(Type t);\n\n    void Dump(Stream &s, int depth = 0) const;\n\n    bool operator==(const Entry &rhs) const {\n      if (string != rhs.string)\n        return false;\n      if (printf_format != rhs.printf_format)\n        return false;\n      const size_t n = children.size();\n      const size_t m = rhs.children.size();\n      for (size_t i = 0; i < std::min<size_t>(n, m); ++i) {\n        if (!(children[i] == rhs.children[i]))\n          return false;\n      }\n      if (children != rhs.children)\n        return false;\n      if (definition != rhs.definition)\n        return false;\n      if (type != rhs.type)\n        return false;\n      if (fmt != rhs.fmt)\n        return false;\n      if (deref != rhs.deref)\n        return false;\n      return true;\n    }\n\n    std::string string;\n    std::string printf_format;\n    std::vector<Entry> children;\n    Definition *definition;\n    Type type;\n    lldb::Format fmt;\n    lldb::addr_t number;\n    bool deref;\n  };\n\n  static bool Format(const Entry &entry, Stream &s, const SymbolContext *sc,\n                     const ExecutionContext *exe_ctx, const Address *addr,\n                     ValueObject *valobj, bool function_changed,\n                     bool initial_function);\n\n  static bool FormatStringRef(const llvm::StringRef &format, Stream &s,\n                              const SymbolContext *sc,\n                              const ExecutionContext *exe_ctx,\n                              const Address *addr, ValueObject *valobj,\n                              bool function_changed, bool initial_function);\n\n  static bool FormatCString(const char *format, Stream &s,\n                            const SymbolContext *sc,\n                            const ExecutionContext *exe_ctx,\n                            const Address *addr, ValueObject *valobj,\n                            bool function_changed, bool initial_function);\n\n  static Status Parse(const llvm::StringRef &format, Entry &entry);\n\n  static Status ExtractVariableInfo(llvm::StringRef &format_str,\n                                    llvm::StringRef &variable_name,\n                                    llvm::StringRef &variable_format);\n\n  static void AutoComplete(lldb_private::CompletionRequest &request);\n\n  // Format the current elements into the stream \\a s.\n  //\n  // The root element will be stripped off and the format str passed in will be\n  // either an empty string (print a description of this object), or contain a\n  // `.`-separated series like a domain name that identifies further\n  //  sub-elements to display.\n  static bool FormatFileSpec(const FileSpec &file, Stream &s,\n                             llvm::StringRef elements,\n                             llvm::StringRef element_format);\n\nprotected:\n  static Status ParseInternal(llvm::StringRef &format, Entry &parent_entry,\n                              uint32_t depth);\n};\n} // namespace lldb_private\n\n#endif // LLDB_CORE_FORMATENTITY_H\n"}, "6": {"id": 6, "path": "/home/vsts/work/1/llvm-project/lldb/include/lldb/Core/LoadedModuleInfoList.h", "content": "//===-- LoadedModuleInfoList.h ----------------------------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLDB_CORE_LOADEDMODULEINFOLIST_H\n#define LLDB_CORE_LOADEDMODULEINFOLIST_H\n\n#include <cassert>\n#include <string>\n#include <vector>\n\n#include \"lldb/lldb-defines.h\"\n#include \"lldb/lldb-private-forward.h\"\n#include \"lldb/lldb-types.h\"\n\nnamespace lldb_private {\nclass LoadedModuleInfoList {\npublic:\n  class LoadedModuleInfo {\n  public:\n    enum e_data_point {\n      e_has_name = 0,\n      e_has_base,\n      e_has_dynamic,\n      e_has_link_map,\n      e_num\n    };\n\n    LoadedModuleInfo() {\n      for (uint32_t i = 0; i < e_num; ++i)\n        m_has[i] = false;\n    };\n\n    void set_name(const std::string &name) {\n      m_name = name;\n      m_has[e_has_name] = true;\n    }\n    bool get_name(std::string &out) const {\n      out = m_name;\n      return m_has[e_has_name];\n    }\n\n    void set_base(const lldb::addr_t base) {\n      m_base = base;\n      m_has[e_has_base] = true;\n    }\n    bool get_base(lldb::addr_t &out) const {\n      out = m_base;\n      return m_has[e_has_base];\n    }\n\n    void set_base_is_offset(bool is_offset) { m_base_is_offset = is_offset; }\n    bool get_base_is_offset(bool &out) const {\n      out = m_base_is_offset;\n      return m_has[e_has_base];\n    }\n\n    void set_link_map(const lldb::addr_t addr) {\n      m_link_map = addr;\n      m_has[e_has_link_map] = true;\n    }\n    bool get_link_map(lldb::addr_t &out) const {\n      out = m_link_map;\n      return m_has[e_has_link_map];\n    }\n\n    void set_dynamic(const lldb::addr_t addr) {\n      m_dynamic = addr;\n      m_has[e_has_dynamic] = true;\n    }\n    bool get_dynamic(lldb::addr_t &out) const {\n      out = m_dynamic;\n      return m_has[e_has_dynamic];\n    }\n\n    bool has_info(e_data_point datum) const {\n      assert(datum < e_num);\n      return m_has[datum];\n    }\n\n    bool operator==(LoadedModuleInfo const &rhs) const {\n      for (size_t i = 0; i < e_num; ++i) {\n        if (m_has[i] != rhs.m_has[i])\n          return false;\n      }\n\n      return (m_base == rhs.m_base) && (m_link_map == rhs.m_link_map) &&\n             (m_dynamic == rhs.m_dynamic) && (m_name == rhs.m_name);\n    }\n\n  protected:\n    bool m_has[e_num];\n    std::string m_name;\n    lldb::addr_t m_link_map;\n    lldb::addr_t m_base;\n    bool m_base_is_offset;\n    lldb::addr_t m_dynamic;\n  };\n\n  LoadedModuleInfoList() : m_list(), m_link_map(LLDB_INVALID_ADDRESS) {}\n\n  void add(const LoadedModuleInfo &mod) { m_list.push_back(mod); }\n\n  void clear() { m_list.clear(); }\n\n  std::vector<LoadedModuleInfo> m_list;\n  lldb::addr_t m_link_map;\n};\n} // namespace lldb_private\n\n#endif // LLDB_CORE_LOADEDMODULEINFOLIST_H\n"}, "7": {"id": 7, "path": "/home/vsts/work/1/llvm-project/lldb/include/lldb/Core/Mangled.h", "content": "//===-- Mangled.h -----------------------------------------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLDB_CORE_MANGLED_H\n#define LLDB_CORE_MANGLED_H\n#if defined(__cplusplus)\n\n#include \"lldb/lldb-enumerations.h\"\n#include \"lldb/lldb-forward.h\"\n\n#include \"lldb/Utility/ConstString.h\"\n\n#include \"llvm/ADT/StringRef.h\"\n\n#include <memory>\n#include <stddef.h>\n\nnamespace lldb_private {\n\n/// \\class Mangled Mangled.h \"lldb/Core/Mangled.h\"\n/// A class that handles mangled names.\n///\n/// Designed to handle mangled names. The demangled version of any names will\n/// be computed when the demangled name is accessed through the Demangled()\n/// acccessor. This class can also tokenize the demangled version of the name\n/// for powerful searches. Functions and symbols could make instances of this\n/// class for their mangled names. Uniqued string pools are used for the\n/// mangled, demangled, and token string values to allow for faster\n/// comparisons and for efficient memory use.\nclass Mangled {\npublic:\n  enum NamePreference {\n    ePreferMangled,\n    ePreferDemangled,\n    ePreferDemangledWithoutArguments\n  };\n\n  enum ManglingScheme {\n    eManglingSchemeNone = 0,\n    eManglingSchemeMSVC,\n    eManglingSchemeItanium\n  };\n\n  /// Default constructor.\n  ///\n  /// Initialize with both mangled and demangled names empty.\n  Mangled() = default;\n\n  /// Construct with name.\n  ///\n  /// Constructor with an optional string and auto-detect if \\a name is\n  /// mangled or not.\n  ///\n  /// \\param[in] name\n  ///     The already const name to copy into this object.\n  explicit Mangled(ConstString name);\n\n  explicit Mangled(llvm::StringRef name);\n\n  /// Convert to pointer operator.\n  ///\n  /// This allows code to check a Mangled object to see if it contains a valid\n  /// mangled name using code such as:\n  ///\n  /// \\code\n  /// Mangled mangled(...);\n  /// if (mangled)\n  /// { ...\n  /// \\endcode\n  ///\n  /// \\return\n  ///     A pointer to this object if either the mangled or unmangled\n  ///     name is set, NULL otherwise.\n  operator void *() const;\n\n  /// Logical NOT operator.\n  ///\n  /// This allows code to check a Mangled object to see if it contains an\n  /// empty mangled name using code such as:\n  ///\n  /// \\code\n  /// Mangled mangled(...);\n  /// if (!mangled)\n  /// { ...\n  /// \\endcode\n  ///\n  /// \\return\n  ///     Returns \\b true if the object has an empty mangled and\n  ///     unmangled name, \\b false otherwise.\n  bool operator!() const;\n\n  /// Clear the mangled and demangled values.\n  void Clear();\n\n  /// Compare the mangled string values\n  ///\n  /// Compares the Mangled::GetName() string in \\a lhs and \\a rhs.\n  ///\n  /// \\param[in] lhs\n  ///     A const reference to the Left Hand Side object to compare.\n  ///\n  /// \\param[in] rhs\n  ///     A const reference to the Right Hand Side object to compare.\n  ///\n  /// \\return\n  ///     -1 if \\a lhs is less than \\a rhs\n  ///     0 if \\a lhs is equal to \\a rhs\n  ///     1 if \\a lhs is greater than \\a rhs\n  static int Compare(const Mangled &lhs, const Mangled &rhs);\n\n  /// Dump a description of this object to a Stream \\a s.\n  ///\n  /// Dump a Mangled object to stream \\a s. We don't force our demangled name\n  /// to be computed currently (we don't use the accessor).\n  ///\n  /// \\param[in] s\n  ///     The stream to which to dump the object description.\n  void Dump(Stream *s) const;\n\n  /// Dump a debug description of this object to a Stream \\a s.\n  ///\n  /// \\param[in] s\n  ///     The stream to which to dump the object description.\n  void DumpDebug(Stream *s) const;\n\n  /// Demangled name get accessor.\n  ///\n  /// \\return\n  ///     A const reference to the demangled name string object.\n  ConstString GetDemangledName() const;\n\n  /// Display demangled name get accessor.\n  ///\n  /// \\return\n  ///     A const reference to the display demangled name string object.\n  ConstString GetDisplayDemangledName() const;\n\n  void SetDemangledName(ConstString name) { m_demangled = name; }\n\n  void SetMangledName(ConstString name) { m_mangled = name; }\n\n  /// Mangled name get accessor.\n  ///\n  /// \\return\n  ///     A reference to the mangled name string object.\n  ConstString &GetMangledName() { return m_mangled; }\n\n  /// Mangled name get accessor.\n  ///\n  /// \\return\n  ///     A const reference to the mangled name string object.\n  ConstString GetMangledName() const { return m_mangled; }\n\n  /// Best name get accessor.\n  ///\n  /// \\param[in] preference\n  ///     Which name would you prefer to get?\n  ///\n  /// \\return\n  ///     A const reference to the preferred name string object if this\n  ///     object has a valid name of that kind, else a const reference to the\n  ///     other name is returned.\n  ConstString GetName(NamePreference preference = ePreferDemangled) const;\n\n  /// Check if \"name\" matches either the mangled or demangled name.\n  ///\n  /// \\param[in] name\n  ///     A name to match against both strings.\n  ///\n  /// \\return\n  ///     \\b True if \\a name matches either name, \\b false otherwise.\n  bool NameMatches(ConstString name) const {\n    if (m_mangled == name)\n      return true;\n    return GetDemangledName() == name;\n  }\n  bool NameMatches(const RegularExpression &regex) const;\n\n  /// Get the memory cost of this object.\n  ///\n  /// Return the size in bytes that this object takes in memory. This returns\n  /// the size in bytes of this object, not any shared string values it may\n  /// refer to.\n  ///\n  /// \\return\n  ///     The number of bytes that this object occupies in memory.\n  ///\n  /// \\see ConstString::StaticMemorySize ()\n  size_t MemorySize() const;\n\n  /// Set the string value in this object.\n  ///\n  /// If \\a is_mangled is \\b true, then the mangled named is set to \\a name,\n  /// else the demangled name is set to \\a name.\n  ///\n  /// \\param[in] name\n  ///     The already const version of the name for this object.\n  ///\n  /// \\param[in] is_mangled\n  ///     If \\b true then \\a name is a mangled name, if \\b false then\n  ///     \\a name is demangled.\n  void SetValue(ConstString name, bool is_mangled);\n\n  /// Set the string value in this object.\n  ///\n  /// This version auto detects if the string is mangled by inspecting the\n  /// string value and looking for common mangling prefixes.\n  ///\n  /// \\param[in] name\n  ///     The already const version of the name for this object.\n  void SetValue(ConstString name);\n\n  /// Try to guess the language from the mangling.\n  ///\n  /// For a mangled name to have a language it must have both a mangled and a\n  /// demangled name and it can be guessed from the mangling what the language\n  /// is.  Note: this will return C++ for any language that uses Itanium ABI\n  /// mangling.\n  ///\n  /// Standard C function names will return eLanguageTypeUnknown because they\n  /// aren't mangled and it isn't clear what language the name represents\n  /// (there will be no mangled name).\n  ///\n  /// \\return\n  ///     The language for the mangled/demangled name, eLanguageTypeUnknown\n  ///     if there is no mangled or demangled counterpart.\n  lldb::LanguageType GuessLanguage() const;\n\n  /// Function signature for filtering mangled names.\n  using SkipMangledNameFn = bool(llvm::StringRef, ManglingScheme);\n\n  /// Trigger explicit demangling to obtain rich mangling information. This is\n  /// optimized for batch processing while populating a name index. To get the\n  /// pure demangled name string for a single entity, use GetDemangledName()\n  /// instead.\n  ///\n  /// For names that match the Itanium mangling scheme, this uses LLVM's\n  /// ItaniumPartialDemangler. All other names fall back to LLDB's builtin\n  /// parser currently.\n  ///\n  /// This function is thread-safe when used with different \\a context\n  /// instances in different threads.\n  ///\n  /// \\param[in] context\n  ///     The context for this function. A single instance can be stack-\n  ///     allocated in the caller's frame and used for multiple calls.\n  ///\n  /// \\param[in] skip_mangled_name\n  ///     A filtering function for skipping entities based on name and mangling\n  ///     scheme. This can be null if unused.\n  ///\n  /// \\return\n  ///     True on success, false otherwise.\n  bool DemangleWithRichManglingInfo(RichManglingContext &context,\n                                    SkipMangledNameFn *skip_mangled_name);\n\n  /// Try to identify the mangling scheme used.\n  /// \\param[in] name\n  ///     The name we are attempting to identify the mangling scheme for.\n  ///\n  /// \\return\n  ///     eManglingSchemeNone if no known mangling scheme could be identified\n  ///     for s, otherwise the enumerator for the mangling scheme detected.\n  static Mangled::ManglingScheme GetManglingScheme(llvm::StringRef const name);\n\nprivate:\n  /// Mangled member variables.\n  ConstString m_mangled;           ///< The mangled version of the name\n  mutable ConstString m_demangled; ///< Mutable so we can get it on demand with\n                                   ///a const version of this object\n};\n\nStream &operator<<(Stream &s, const Mangled &obj);\n\n} // namespace lldb_private\n\n#endif // #if defined(__cplusplus)\n#endif // LLDB_CORE_MANGLED_H\n"}, "8": {"id": 8, "path": "/home/vsts/work/1/llvm-project/lldb/include/lldb/Core/ModuleSpec.h", "content": "//===-- ModuleSpec.h --------------------------------------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLDB_CORE_MODULESPEC_H\n#define LLDB_CORE_MODULESPEC_H\n\n#include \"lldb/Host/FileSystem.h\"\n#include \"lldb/Target/PathMappingList.h\"\n#include \"lldb/Utility/ArchSpec.h\"\n#include \"lldb/Utility/FileSpec.h\"\n#include \"lldb/Utility/Stream.h\"\n#include \"lldb/Utility/UUID.h\"\n\n#include \"llvm/Support/Chrono.h\"\n\n#include <mutex>\n#include <vector>\n\nnamespace lldb_private {\n\nclass ModuleSpec {\npublic:\n  ModuleSpec()\n      : m_file(), m_platform_file(), m_symbol_file(), m_arch(), m_uuid(),\n        m_object_name(), m_object_offset(0), m_object_size(0),\n        m_source_mappings() {}\n\n  /// If the \\param data argument is passed, its contents will be used\n  /// as the module contents instead of trying to read them from\n  /// \\param file_spec.\n  ModuleSpec(const FileSpec &file_spec, const UUID &uuid = UUID(),\n             lldb::DataBufferSP data = lldb::DataBufferSP())\n      : m_file(file_spec), m_platform_file(), m_symbol_file(), m_arch(),\n        m_uuid(uuid), m_object_name(), m_object_offset(0), m_source_mappings(),\n        m_data(data) {\n    if (data)\n      m_object_size = data->GetByteSize();\n    else if (m_file)\n      m_object_size = FileSystem::Instance().GetByteSize(file_spec);\n  }\n\n  ModuleSpec(const FileSpec &file_spec, const ArchSpec &arch)\n      : m_file(file_spec), m_platform_file(), m_symbol_file(), m_arch(arch),\n        m_uuid(), m_object_name(), m_object_offset(0),\n        m_object_size(FileSystem::Instance().GetByteSize(file_spec)),\n        m_source_mappings() {}\n\n  FileSpec *GetFileSpecPtr() { return (m_file ? &m_file : nullptr); }\n\n  const FileSpec *GetFileSpecPtr() const {\n    return (m_file ? &m_file : nullptr);\n  }\n\n  FileSpec &GetFileSpec() { return m_file; }\n\n  const FileSpec &GetFileSpec() const { return m_file; }\n\n  FileSpec *GetPlatformFileSpecPtr() {\n    return (m_platform_file ? &m_platform_file : nullptr);\n  }\n\n  const FileSpec *GetPlatformFileSpecPtr() const {\n    return (m_platform_file ? &m_platform_file : nullptr);\n  }\n\n  FileSpec &GetPlatformFileSpec() { return m_platform_file; }\n\n  const FileSpec &GetPlatformFileSpec() const { return m_platform_file; }\n\n  FileSpec *GetSymbolFileSpecPtr() {\n    return (m_symbol_file ? &m_symbol_file : nullptr);\n  }\n\n  const FileSpec *GetSymbolFileSpecPtr() const {\n    return (m_symbol_file ? &m_symbol_file : nullptr);\n  }\n\n  FileSpec &GetSymbolFileSpec() { return m_symbol_file; }\n\n  const FileSpec &GetSymbolFileSpec() const { return m_symbol_file; }\n\n  ArchSpec *GetArchitecturePtr() {\n    return (m_arch.IsValid() ? &m_arch : nullptr);\n  }\n\n  const ArchSpec *GetArchitecturePtr() const {\n    return (m_arch.IsValid() ? &m_arch : nullptr);\n  }\n\n  ArchSpec &GetArchitecture() { return m_arch; }\n\n  const ArchSpec &GetArchitecture() const { return m_arch; }\n\n  UUID *GetUUIDPtr() { return (m_uuid.IsValid() ? &m_uuid : nullptr); }\n\n  const UUID *GetUUIDPtr() const {\n    return (m_uuid.IsValid() ? &m_uuid : nullptr);\n  }\n\n  UUID &GetUUID() { return m_uuid; }\n\n  const UUID &GetUUID() const { return m_uuid; }\n\n  ConstString &GetObjectName() { return m_object_name; }\n\n  ConstString GetObjectName() const { return m_object_name; }\n\n  uint64_t GetObjectOffset() const { return m_object_offset; }\n\n  void SetObjectOffset(uint64_t object_offset) {\n    m_object_offset = object_offset;\n  }\n\n  uint64_t GetObjectSize() const { return m_object_size; }\n\n  void SetObjectSize(uint64_t object_size) { m_object_size = object_size; }\n\n  llvm::sys::TimePoint<> &GetObjectModificationTime() {\n    return m_object_mod_time;\n  }\n\n  const llvm::sys::TimePoint<> &GetObjectModificationTime() const {\n    return m_object_mod_time;\n  }\n\n  PathMappingList &GetSourceMappingList() const { return m_source_mappings; }\n\n  lldb::DataBufferSP GetData() const { return m_data; }\n\n  void Clear() {\n    m_file.Clear();\n    m_platform_file.Clear();\n    m_symbol_file.Clear();\n    m_arch.Clear();\n    m_uuid.Clear();\n    m_object_name.Clear();\n    m_object_offset = 0;\n    m_object_size = 0;\n    m_source_mappings.Clear(false);\n    m_object_mod_time = llvm::sys::TimePoint<>();\n  }\n\n  explicit operator bool() const {\n    if (m_file)\n      return true;\n    if (m_platform_file)\n      return true;\n    if (m_symbol_file)\n      return true;\n    if (m_arch.IsValid())\n      return true;\n    if (m_uuid.IsValid())\n      return true;\n    if (m_object_name)\n      return true;\n    if (m_object_size)\n      return true;\n    if (m_object_mod_time != llvm::sys::TimePoint<>())\n      return true;\n    return false;\n  }\n\n  void Dump(Stream &strm) const {\n    bool dumped_something = false;\n    if (m_file) {\n      strm.PutCString(\"file = '\");\n      strm << m_file;\n      strm.PutCString(\"'\");\n      dumped_something = true;\n    }\n    if (m_platform_file) {\n      if (dumped_something)\n        strm.PutCString(\", \");\n      strm.PutCString(\"platform_file = '\");\n      strm << m_platform_file;\n      strm.PutCString(\"'\");\n      dumped_something = true;\n    }\n    if (m_symbol_file) {\n      if (dumped_something)\n        strm.PutCString(\", \");\n      strm.PutCString(\"symbol_file = '\");\n      strm << m_symbol_file;\n      strm.PutCString(\"'\");\n      dumped_something = true;\n    }\n    if (m_arch.IsValid()) {\n      if (dumped_something)\n        strm.PutCString(\", \");\n      strm.Printf(\"arch = \");\n      m_arch.DumpTriple(strm.AsRawOstream());\n      dumped_something = true;\n    }\n    if (m_uuid.IsValid()) {\n      if (dumped_something)\n        strm.PutCString(\", \");\n      strm.PutCString(\"uuid = \");\n      m_uuid.Dump(&strm);\n      dumped_something = true;\n    }\n    if (m_object_name) {\n      if (dumped_something)\n        strm.PutCString(\", \");\n      strm.Printf(\"object_name = %s\", m_object_name.GetCString());\n      dumped_something = true;\n    }\n    if (m_object_offset > 0) {\n      if (dumped_something)\n        strm.PutCString(\", \");\n      strm.Printf(\"object_offset = %\" PRIu64, m_object_offset);\n      dumped_something = true;\n    }\n    if (m_object_size > 0) {\n      if (dumped_something)\n        strm.PutCString(\", \");\n      strm.Printf(\"object size = %\" PRIu64, m_object_size);\n      dumped_something = true;\n    }\n    if (m_object_mod_time != llvm::sys::TimePoint<>()) {\n      if (dumped_something)\n        strm.PutCString(\", \");\n      strm.Format(\"object_mod_time = {0:x+}\",\n                  uint64_t(llvm::sys::toTimeT(m_object_mod_time)));\n    }\n  }\n\n  bool Matches(const ModuleSpec &match_module_spec,\n               bool exact_arch_match) const {\n    if (match_module_spec.GetUUIDPtr() &&\n        match_module_spec.GetUUID() != GetUUID())\n      return false;\n    if (match_module_spec.GetObjectName() &&\n        match_module_spec.GetObjectName() != GetObjectName())\n      return false;\n    if (!FileSpec::Match(match_module_spec.GetFileSpec(), GetFileSpec()))\n      return false;\n    if (GetPlatformFileSpec() &&\n        !FileSpec::Match(match_module_spec.GetPlatformFileSpec(),\n                         GetPlatformFileSpec())) {\n      return false;\n    }\n    // Only match the symbol file spec if there is one in this ModuleSpec\n    if (GetSymbolFileSpec() &&\n        !FileSpec::Match(match_module_spec.GetSymbolFileSpec(),\n                         GetSymbolFileSpec())) {\n      return false;\n    }\n    if (match_module_spec.GetArchitecturePtr()) {\n      if (exact_arch_match) {\n        if (!GetArchitecture().IsExactMatch(\n                match_module_spec.GetArchitecture()))\n          return false;\n      } else {\n        if (!GetArchitecture().IsCompatibleMatch(\n                match_module_spec.GetArchitecture()))\n          return false;\n      }\n    }\n    return true;\n  }\n\nprotected:\n  FileSpec m_file;\n  FileSpec m_platform_file;\n  FileSpec m_symbol_file;\n  ArchSpec m_arch;\n  UUID m_uuid;\n  ConstString m_object_name;\n  uint64_t m_object_offset;\n  uint64_t m_object_size;\n  llvm::sys::TimePoint<> m_object_mod_time;\n  mutable PathMappingList m_source_mappings;\n  lldb::DataBufferSP m_data = {};\n};\n\nclass ModuleSpecList {\npublic:\n  ModuleSpecList() : m_specs(), m_mutex() {}\n\n  ModuleSpecList(const ModuleSpecList &rhs) : m_specs(), m_mutex() {\n    std::lock_guard<std::recursive_mutex> lhs_guard(m_mutex);\n    std::lock_guard<std::recursive_mutex> rhs_guard(rhs.m_mutex);\n    m_specs = rhs.m_specs;\n  }\n\n  ~ModuleSpecList() = default;\n\n  ModuleSpecList &operator=(const ModuleSpecList &rhs) {\n    if (this != &rhs) {\n      std::lock(m_mutex, rhs.m_mutex);\n      std::lock_guard<std::recursive_mutex> lhs_guard(m_mutex, std::adopt_lock);\n      std::lock_guard<std::recursive_mutex> rhs_guard(rhs.m_mutex, \n                                                      std::adopt_lock);\n      m_specs = rhs.m_specs;\n    }\n    return *this;\n  }\n\n  size_t GetSize() const {\n    std::lock_guard<std::recursive_mutex> guard(m_mutex);\n    return m_specs.size();\n  }\n\n  void Clear() {\n    std::lock_guard<std::recursive_mutex> guard(m_mutex);\n    m_specs.clear();\n  }\n\n  void Append(const ModuleSpec &spec) {\n    std::lock_guard<std::recursive_mutex> guard(m_mutex);\n    m_specs.push_back(spec);\n  }\n\n  void Append(const ModuleSpecList &rhs) {\n    std::lock_guard<std::recursive_mutex> lhs_guard(m_mutex);\n    std::lock_guard<std::recursive_mutex> rhs_guard(rhs.m_mutex);\n    m_specs.insert(m_specs.end(), rhs.m_specs.begin(), rhs.m_specs.end());\n  }\n\n  // The index \"i\" must be valid and this can't be used in multi-threaded code\n  // as no mutex lock is taken.\n  ModuleSpec &GetModuleSpecRefAtIndex(size_t i) { return m_specs[i]; }\n\n  bool GetModuleSpecAtIndex(size_t i, ModuleSpec &module_spec) const {\n    std::lock_guard<std::recursive_mutex> guard(m_mutex);\n    if (i < m_specs.size()) {\n      module_spec = m_specs[i];\n      return true;\n    }\n    module_spec.Clear();\n    return false;\n  }\n\n  bool FindMatchingModuleSpec(const ModuleSpec &module_spec,\n                              ModuleSpec &match_module_spec) const {\n    std::lock_guard<std::recursive_mutex> guard(m_mutex);\n    bool exact_arch_match = true;\n    for (auto spec : m_specs) {\n      if (spec.Matches(module_spec, exact_arch_match)) {\n        match_module_spec = spec;\n        return true;\n      }\n    }\n\n    // If there was an architecture, retry with a compatible arch\n    if (module_spec.GetArchitecturePtr()) {\n      exact_arch_match = false;\n      for (auto spec : m_specs) {\n        if (spec.Matches(module_spec, exact_arch_match)) {\n          match_module_spec = spec;\n          return true;\n        }\n      }\n    }\n    match_module_spec.Clear();\n    return false;\n  }\n\n  void FindMatchingModuleSpecs(const ModuleSpec &module_spec,\n                               ModuleSpecList &matching_list) const {\n    std::lock_guard<std::recursive_mutex> guard(m_mutex);\n    bool exact_arch_match = true;\n    const size_t initial_match_count = matching_list.GetSize();\n    for (auto spec : m_specs) {\n      if (spec.Matches(module_spec, exact_arch_match))\n        matching_list.Append(spec);\n    }\n\n    // If there was an architecture, retry with a compatible arch if no matches\n    // were found\n    if (module_spec.GetArchitecturePtr() &&\n        (initial_match_count == matching_list.GetSize())) {\n      exact_arch_match = false;\n      for (auto spec : m_specs) {\n        if (spec.Matches(module_spec, exact_arch_match))\n          matching_list.Append(spec);\n      }\n    }\n  }\n\n  void Dump(Stream &strm) {\n    std::lock_guard<std::recursive_mutex> guard(m_mutex);\n    uint32_t idx = 0;\n    for (auto spec : m_specs) {\n      strm.Printf(\"[%u] \", idx);\n      spec.Dump(strm);\n      strm.EOL();\n      ++idx;\n    }\n  }\n\nprotected:\n  typedef std::vector<ModuleSpec> collection; ///< The module collection type.\n  collection m_specs;                         ///< The collection of modules.\n  mutable std::recursive_mutex m_mutex;\n};\n\n} // namespace lldb_private\n\n#endif // LLDB_CORE_MODULESPEC_H\n"}, "9": {"id": 9, "path": "/home/vsts/work/1/llvm-project/lldb/include/lldb/Core/Opcode.h", "content": "//===-- Opcode.h ------------------------------------------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLDB_CORE_OPCODE_H\n#define LLDB_CORE_OPCODE_H\n\n#include \"lldb/Utility/Endian.h\"\n#include \"lldb/lldb-enumerations.h\"\n\n#include \"llvm/Support/SwapByteOrder.h\"\n\n#include <assert.h>\n#include <stdint.h>\n#include <string.h>\n\nnamespace lldb {\nclass SBInstruction;\n}\n\nnamespace lldb_private {\nclass DataExtractor;\nclass Stream;\n\nclass Opcode {\npublic:\n  enum Type {\n    eTypeInvalid,\n    eType8,\n    eType16,\n    eType16_2, // a 32-bit Thumb instruction, made up of two words\n    eType32,\n    eType64,\n    eTypeBytes\n  };\n\n  Opcode() : m_byte_order(lldb::eByteOrderInvalid), m_type(eTypeInvalid) {}\n\n  Opcode(uint8_t inst, lldb::ByteOrder order)\n      : m_byte_order(order), m_type(eType8) {\n    m_data.inst8 = inst;\n  }\n\n  Opcode(uint16_t inst, lldb::ByteOrder order)\n      : m_byte_order(order), m_type(eType16) {\n    m_data.inst16 = inst;\n  }\n\n  Opcode(uint32_t inst, lldb::ByteOrder order)\n      : m_byte_order(order), m_type(eType32) {\n    m_data.inst32 = inst;\n  }\n\n  Opcode(uint64_t inst, lldb::ByteOrder order)\n      : m_byte_order(order), m_type(eType64) {\n    m_data.inst64 = inst;\n  }\n\n  Opcode(uint8_t *bytes, size_t length)\n      : m_byte_order(lldb::eByteOrderInvalid) {\n    SetOpcodeBytes(bytes, length);\n  }\n\n  void Clear() {\n    m_byte_order = lldb::eByteOrderInvalid;\n    m_type = Opcode::eTypeInvalid;\n  }\n\n  Opcode::Type GetType() const { return m_type; }\n\n  uint8_t GetOpcode8(uint8_t invalid_opcode = UINT8_MAX) const {\n    switch (m_type) {\n    case Opcode::eTypeInvalid:\n      break;\n    case Opcode::eType8:\n      return m_data.inst8;\n    case Opcode::eType16:\n      break;\n    case Opcode::eType16_2:\n      break;\n    case Opcode::eType32:\n      break;\n    case Opcode::eType64:\n      break;\n    case Opcode::eTypeBytes:\n      break;\n    }\n    return invalid_opcode;\n  }\n\n  uint16_t GetOpcode16(uint16_t invalid_opcode = UINT16_MAX) const {\n    switch (m_type) {\n    case Opcode::eTypeInvalid:\n      break;\n    case Opcode::eType8:\n      return m_data.inst8;\n    case Opcode::eType16:\n      return GetEndianSwap() ? llvm::ByteSwap_16(m_data.inst16) : m_data.inst16;\n    case Opcode::eType16_2:\n      break;\n    case Opcode::eType32:\n      break;\n    case Opcode::eType64:\n      break;\n    case Opcode::eTypeBytes:\n      break;\n    }\n    return invalid_opcode;\n  }\n\n  uint32_t GetOpcode32(uint32_t invalid_opcode = UINT32_MAX) const {\n    switch (m_type) {\n    case Opcode::eTypeInvalid:\n      break;\n    case Opcode::eType8:\n      return m_data.inst8;\n    case Opcode::eType16:\n      return GetEndianSwap() ? llvm::ByteSwap_16(m_data.inst16) : m_data.inst16;\n    case Opcode::eType16_2: // passthrough\n    case Opcode::eType32:\n      return GetEndianSwap() ? llvm::ByteSwap_32(m_data.inst32) : m_data.inst32;\n    case Opcode::eType64:\n      break;\n    case Opcode::eTypeBytes:\n      break;\n    }\n    return invalid_opcode;\n  }\n\n  uint64_t GetOpcode64(uint64_t invalid_opcode = UINT64_MAX) const {\n    switch (m_type) {\n    case Opcode::eTypeInvalid:\n      break;\n    case Opcode::eType8:\n      return m_data.inst8;\n    case Opcode::eType16:\n      return GetEndianSwap() ? llvm::ByteSwap_16(m_data.inst16) : m_data.inst16;\n    case Opcode::eType16_2: // passthrough\n    case Opcode::eType32:\n      return GetEndianSwap() ? llvm::ByteSwap_32(m_data.inst32) : m_data.inst32;\n    case Opcode::eType64:\n      return GetEndianSwap() ? llvm::ByteSwap_64(m_data.inst64) : m_data.inst64;\n    case Opcode::eTypeBytes:\n      break;\n    }\n    return invalid_opcode;\n  }\n\n  void SetOpcode8(uint8_t inst, lldb::ByteOrder order) {\n    m_type = eType8;\n    m_data.inst8 = inst;\n    m_byte_order = order;\n  }\n\n  void SetOpcode16(uint16_t inst, lldb::ByteOrder order) {\n    m_type = eType16;\n    m_data.inst16 = inst;\n    m_byte_order = order;\n  }\n\n  void SetOpcode16_2(uint32_t inst, lldb::ByteOrder order) {\n    m_type = eType16_2;\n    m_data.inst32 = inst;\n    m_byte_order = order;\n  }\n\n  void SetOpcode32(uint32_t inst, lldb::ByteOrder order) {\n    m_type = eType32;\n    m_data.inst32 = inst;\n    m_byte_order = order;\n  }\n\n  void SetOpcode64(uint64_t inst, lldb::ByteOrder order) {\n    m_type = eType64;\n    m_data.inst64 = inst;\n    m_byte_order = order;\n  }\n\n  void SetOpcodeBytes(const void *bytes, size_t length) {\n    if (bytes != nullptr && length > 0) {\n      m_type = eTypeBytes;\n      m_data.inst.length = length;\n      assert(length < sizeof(m_data.inst.bytes));\n      memcpy(m_data.inst.bytes, bytes, length);\n      m_byte_order = lldb::eByteOrderInvalid;\n    } else {\n      m_type = eTypeInvalid;\n      m_data.inst.length = 0;\n    }\n  }\n\n  int Dump(Stream *s, uint32_t min_byte_width);\n\n  const void *GetOpcodeBytes() const {\n    return ((m_type == Opcode::eTypeBytes) ? m_data.inst.bytes : nullptr);\n  }\n\n  uint32_t GetByteSize() const {\n    switch (m_type) {\n    case Opcode::eTypeInvalid:\n      break;\n    case Opcode::eType8:\n      return sizeof(m_data.inst8);\n    case Opcode::eType16:\n      return sizeof(m_data.inst16);\n    case Opcode::eType16_2: // passthrough\n    case Opcode::eType32:\n      return sizeof(m_data.inst32);\n    case Opcode::eType64:\n      return sizeof(m_data.inst64);\n    case Opcode::eTypeBytes:\n      return m_data.inst.length;\n    }\n    return 0;\n  }\n\n  // Get the opcode exactly as it would be laid out in memory.\n  uint32_t GetData(DataExtractor &data) const;\n\nprotected:\n  friend class lldb::SBInstruction;\n\n  const void *GetOpcodeDataBytes() const {\n    switch (m_type) {\n    case Opcode::eTypeInvalid:\n      break;\n    case Opcode::eType8:\n      return &m_data.inst8;\n    case Opcode::eType16:\n      return &m_data.inst16;\n    case Opcode::eType16_2: // passthrough\n    case Opcode::eType32:\n      return &m_data.inst32;\n    case Opcode::eType64:\n      return &m_data.inst64;\n    case Opcode::eTypeBytes:\n      return m_data.inst.bytes;\n    }\n    return nullptr;\n  }\n\n  lldb::ByteOrder GetDataByteOrder() const;\n\n  bool GetEndianSwap() const {\n    return (m_byte_order == lldb::eByteOrderBig &&\n            endian::InlHostByteOrder() == lldb::eByteOrderLittle) ||\n           (m_byte_order == lldb::eByteOrderLittle &&\n            endian::InlHostByteOrder() == lldb::eByteOrderBig);\n  }\n\n  lldb::ByteOrder m_byte_order;\n\n  Opcode::Type m_type;\n  union {\n    uint8_t inst8;\n    uint16_t inst16;\n    uint32_t inst32;\n    uint64_t inst64;\n    struct {\n      uint8_t bytes[16]; // This must be big enough to handle any opcode for any\n                         // supported target.\n      uint8_t length;\n    } inst;\n  } m_data;\n};\n\n} // namespace lldb_private\n\n#endif // LLDB_CORE_OPCODE_H\n"}, "10": {"id": 10, "path": "/home/vsts/work/1/llvm-project/lldb/include/lldb/Core/Value.h", "content": "//===-- Value.h -------------------------------------------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLDB_CORE_VALUE_H\n#define LLDB_CORE_VALUE_H\n\n#include \"lldb/Symbol/CompilerType.h\"\n#include \"lldb/Utility/DataBufferHeap.h\"\n#include \"lldb/Utility/Scalar.h\"\n#include \"lldb/Utility/Status.h\"\n#include \"lldb/lldb-enumerations.h\"\n#include \"lldb/lldb-private-enumerations.h\"\n#include \"lldb/lldb-private-types.h\"\n\n#include \"llvm/ADT/APInt.h\"\n\n#include <vector>\n\n#include <stdint.h>\n#include <string.h>\n\nnamespace lldb_private {\nclass DataExtractor;\nclass ExecutionContext;\nclass Module;\nclass Stream;\nclass Type;\nclass Variable;\n}\n\nnamespace lldb_private {\n\nclass Value {\npublic:\n  /// Type that describes Value::m_value.\n  enum class ValueType {\n    Invalid = -1,\n    // m_value contains:\n    /// A raw scalar value.\n    Scalar = 0,\n    /// A file address value.\n    FileAddress,\n    /// A load address value.\n    LoadAddress,\n    /// A host address value (for memory in the process that < A is\n    /// using liblldb).\n    HostAddress\n  };\n\n  /// Type that describes Value::m_context.\n  enum class ContextType {\n    // m_context contains:\n    /// Undefined.\n    Invalid = -1,\n    /// RegisterInfo * (can be a scalar or a vector register).\n    RegisterInfo = 0,\n    /// lldb_private::Type *.\n    LLDBType,\n    /// lldb_private::Variable *.\n    Variable\n  };\n\n  Value();\n  Value(const Scalar &scalar);\n  Value(const void *bytes, int len);\n  Value(const Value &rhs);\n\n  void SetBytes(const void *bytes, int len);\n\n  void AppendBytes(const void *bytes, int len);\n\n  Value &operator=(const Value &rhs);\n\n  const CompilerType &GetCompilerType();\n\n  void SetCompilerType(const CompilerType &compiler_type);\n\n  ValueType GetValueType() const;\n\n  AddressType GetValueAddressType() const;\n\n  ContextType GetContextType() const { return m_context_type; }\n\n  void SetValueType(ValueType value_type) { m_value_type = value_type; }\n\n  void ClearContext() {\n    m_context = nullptr;\n    m_context_type = ContextType::Invalid;\n  }\n\n  void SetContext(ContextType context_type, void *p) {\n    m_context_type = context_type;\n    m_context = p;\n    if (m_context_type == ContextType::RegisterInfo) {\n      RegisterInfo *reg_info = GetRegisterInfo();\n      if (reg_info->encoding == lldb::eEncodingVector)\n        SetValueType(ValueType::Scalar);\n    }\n  }\n\n  RegisterInfo *GetRegisterInfo() const;\n\n  Type *GetType();\n\n  Scalar &ResolveValue(ExecutionContext *exe_ctx);\n\n  const Scalar &GetScalar() const { return m_value; }\n\n  Scalar &GetScalar() { return m_value; }\n\n  size_t ResizeData(size_t len);\n\n  size_t AppendDataToHostBuffer(const Value &rhs);\n\n  DataBufferHeap &GetBuffer() { return m_data_buffer; }\n\n  const DataBufferHeap &GetBuffer() const { return m_data_buffer; }\n\n  bool ValueOf(ExecutionContext *exe_ctx);\n\n  Variable *GetVariable();\n\n  void Dump(Stream *strm);\n\n  lldb::Format GetValueDefaultFormat();\n\n  uint64_t GetValueByteSize(Status *error_ptr, ExecutionContext *exe_ctx);\n\n  Status GetValueAsData(ExecutionContext *exe_ctx, DataExtractor &data,\n                        Module *module); // Can be nullptr\n\n  static const char *GetValueTypeAsCString(ValueType context_type);\n\n  static const char *GetContextTypeAsCString(ContextType context_type);\n\n  /// Convert this value's file address to a load address, if possible.\n  void ConvertToLoadAddress(Module *module, Target *target);\n\n  bool GetData(DataExtractor &data);\n\n  void Clear();\n\nprotected:\n  Scalar m_value;\n  CompilerType m_compiler_type;\n  void *m_context;\n  ValueType m_value_type;\n  ContextType m_context_type;\n  DataBufferHeap m_data_buffer;\n};\n\nclass ValueList {\npublic:\n  ValueList() : m_values() {}\n\n  ValueList(const ValueList &rhs);\n\n  ~ValueList() = default;\n\n  const ValueList &operator=(const ValueList &rhs);\n\n  // void InsertValue (Value *value, size_t idx);\n  void PushValue(const Value &value);\n\n  size_t GetSize();\n  Value *GetValueAtIndex(size_t idx);\n  void Clear();\n\nprivate:\n  typedef std::vector<Value> collection;\n\n  collection m_values;\n};\n\n} // namespace lldb_private\n\n#endif // LLDB_CORE_VALUE_H\n"}, "11": {"id": 11, "path": "/home/vsts/work/1/llvm-project/lldb/include/lldb/Core/ValueObject.h", "content": "//===-- ValueObject.h -------------------------------------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLDB_CORE_VALUEOBJECT_H\n#define LLDB_CORE_VALUEOBJECT_H\n\n#include \"lldb/Core/Value.h\"\n#include \"lldb/Symbol/CompilerType.h\"\n#include \"lldb/Symbol/Type.h\"\n#include \"lldb/Target/ExecutionContext.h\"\n#include \"lldb/Target/Process.h\"\n#include \"lldb/Utility/ConstString.h\"\n#include \"lldb/Utility/DataExtractor.h\"\n#include \"lldb/Utility/SharedCluster.h\"\n#include \"lldb/Utility/Status.h\"\n#include \"lldb/Utility/UserID.h\"\n#include \"lldb/lldb-defines.h\"\n#include \"lldb/lldb-enumerations.h\"\n#include \"lldb/lldb-forward.h\"\n#include \"lldb/lldb-private-enumerations.h\"\n#include \"lldb/lldb-types.h\"\n\n#include \"llvm/ADT/ArrayRef.h\"\n#include \"llvm/ADT/Optional.h\"\n#include \"llvm/ADT/SmallVector.h\"\n#include \"llvm/ADT/StringRef.h\"\n\n#include <functional>\n#include <initializer_list>\n#include <map>\n#include <mutex>\n#include <string>\n#include <utility>\n\n#include <stddef.h>\n#include <stdint.h>\n\nnamespace lldb_private {\nclass Declaration;\nclass DumpValueObjectOptions;\nclass EvaluateExpressionOptions;\nclass ExecutionContextScope;\nclass Log;\nclass Scalar;\nclass Stream;\nclass SymbolContextScope;\nclass TypeFormatImpl;\nclass TypeSummaryImpl;\nclass TypeSummaryOptions;\n\n/// ValueObject:\n///\n/// This abstract class provides an interface to a particular value, be it a\n/// register, a local or global variable,\n/// that is evaluated in some particular scope.  The ValueObject also has the\n/// capability of being the \"child\" of\n/// some other variable object, and in turn of having children.\n/// If a ValueObject is a root variable object - having no parent - then it must\n/// be constructed with respect to some\n/// particular ExecutionContextScope.  If it is a child, it inherits the\n/// ExecutionContextScope from its parent.\n/// The ValueObject will update itself if necessary before fetching its value,\n/// summary, object description, etc.\n/// But it will always update itself in the ExecutionContextScope with which it\n/// was originally created.\n\n/// A brief note on life cycle management for ValueObjects.  This is a little\n/// tricky because a ValueObject can contain\n/// various other ValueObjects - the Dynamic Value, its children, the\n/// dereference value, etc.  Any one of these can be\n/// handed out as a shared pointer, but for that contained value object to be\n/// valid, the root object and potentially other\n/// of the value objects need to stay around.\n/// We solve this problem by handing out shared pointers to the Value Object and\n/// any of its dependents using a shared\n/// ClusterManager.  This treats each shared pointer handed out for the entire\n/// cluster as a reference to the whole\n/// cluster.  The whole cluster will stay around until the last reference is\n/// released.\n///\n/// The ValueObject mostly handle this automatically, if a value object is made\n/// with a Parent ValueObject, then it adds\n/// itself to the ClusterManager of the parent.\n\n/// It does mean that external to the ValueObjects we should only ever make\n/// available ValueObjectSP's, never ValueObjects\n/// or pointers to them.  So all the \"Root level\" ValueObject derived\n/// constructors should be private, and\n/// should implement a Create function that new's up object and returns a Shared\n/// Pointer that it gets from the GetSP() method.\n///\n/// However, if you are making an derived ValueObject that will be contained in\n/// a parent value object, you should just\n/// hold onto a pointer to it internally, and by virtue of passing the parent\n/// ValueObject into its constructor, it will\n/// be added to the ClusterManager for the parent.  Then if you ever hand out a\n/// Shared Pointer to the contained ValueObject,\n/// just do so by calling GetSP() on the contained object.\n\nclass ValueObject {\npublic:\n  enum GetExpressionPathFormat {\n    eGetExpressionPathFormatDereferencePointers = 1,\n    eGetExpressionPathFormatHonorPointers\n  };\n\n  enum ValueObjectRepresentationStyle {\n    eValueObjectRepresentationStyleValue = 1,\n    eValueObjectRepresentationStyleSummary,\n    eValueObjectRepresentationStyleLanguageSpecific,\n    eValueObjectRepresentationStyleLocation,\n    eValueObjectRepresentationStyleChildrenCount,\n    eValueObjectRepresentationStyleType,\n    eValueObjectRepresentationStyleName,\n    eValueObjectRepresentationStyleExpressionPath\n  };\n\n  enum ExpressionPathScanEndReason {\n    /// Out of data to parse.\n    eExpressionPathScanEndReasonEndOfString = 1,\n    /// Child element not found.\n    eExpressionPathScanEndReasonNoSuchChild,\n    /// (Synthetic) child  element not found.\n    eExpressionPathScanEndReasonNoSuchSyntheticChild,\n    /// [] only allowed for arrays.\n    eExpressionPathScanEndReasonEmptyRangeNotAllowed,\n    /// . used when -> should be used.\n    eExpressionPathScanEndReasonDotInsteadOfArrow,\n    /// -> used when . should be used.\n    eExpressionPathScanEndReasonArrowInsteadOfDot,\n    /// ObjC ivar expansion not allowed.\n    eExpressionPathScanEndReasonFragileIVarNotAllowed,\n    /// [] not allowed by options.\n    eExpressionPathScanEndReasonRangeOperatorNotAllowed,\n    /// [] not valid on objects  other than scalars, pointers or arrays.\n    eExpressionPathScanEndReasonRangeOperatorInvalid,\n    /// [] is good for arrays,  but I cannot parse it.\n    eExpressionPathScanEndReasonArrayRangeOperatorMet,\n    /// [] is good for bitfields, but I cannot parse after it.\n    eExpressionPathScanEndReasonBitfieldRangeOperatorMet,\n    /// Something is malformed in he expression.\n    eExpressionPathScanEndReasonUnexpectedSymbol,\n    /// Impossible to apply &  operator.\n    eExpressionPathScanEndReasonTakingAddressFailed,\n    /// Impossible to apply *  operator.\n    eExpressionPathScanEndReasonDereferencingFailed,\n    /// [] was expanded into a  VOList.\n    eExpressionPathScanEndReasonRangeOperatorExpanded,\n    /// getting the synthetic children failed.\n    eExpressionPathScanEndReasonSyntheticValueMissing,\n    eExpressionPathScanEndReasonUnknown = 0xFFFF\n  };\n\n  enum ExpressionPathEndResultType {\n    /// Anything but...\n    eExpressionPathEndResultTypePlain = 1,\n    /// A bitfield.\n    eExpressionPathEndResultTypeBitfield,\n    /// A range [low-high].\n    eExpressionPathEndResultTypeBoundedRange,\n    /// A range [].\n    eExpressionPathEndResultTypeUnboundedRange,\n    /// Several items in a VOList.\n    eExpressionPathEndResultTypeValueObjectList,\n    eExpressionPathEndResultTypeInvalid = 0xFFFF\n  };\n\n  enum ExpressionPathAftermath {\n    /// Just return it.\n    eExpressionPathAftermathNothing = 1,\n    /// Dereference the target.\n    eExpressionPathAftermathDereference,\n    /// Take target's address.\n    eExpressionPathAftermathTakeAddress\n  };\n\n  enum ClearUserVisibleDataItems {\n    eClearUserVisibleDataItemsNothing = 1u << 0,\n    eClearUserVisibleDataItemsValue = 1u << 1,\n    eClearUserVisibleDataItemsSummary = 1u << 2,\n    eClearUserVisibleDataItemsLocation = 1u << 3,\n    eClearUserVisibleDataItemsDescription = 1u << 4,\n    eClearUserVisibleDataItemsSyntheticChildren = 1u << 5,\n    eClearUserVisibleDataItemsAllStrings =\n        eClearUserVisibleDataItemsValue | eClearUserVisibleDataItemsSummary |\n        eClearUserVisibleDataItemsLocation |\n        eClearUserVisibleDataItemsDescription,\n    eClearUserVisibleDataItemsAll = 0xFFFF\n  };\n\n  struct GetValueForExpressionPathOptions {\n    enum class SyntheticChildrenTraversal {\n      None,\n      ToSynthetic,\n      FromSynthetic,\n      Both\n    };\n\n    bool m_check_dot_vs_arrow_syntax;\n    bool m_no_fragile_ivar;\n    bool m_allow_bitfields_syntax;\n    SyntheticChildrenTraversal m_synthetic_children_traversal;\n\n    GetValueForExpressionPathOptions(\n        bool dot = false, bool no_ivar = false, bool bitfield = true,\n        SyntheticChildrenTraversal synth_traverse =\n            SyntheticChildrenTraversal::ToSynthetic)\n        : m_check_dot_vs_arrow_syntax(dot), m_no_fragile_ivar(no_ivar),\n          m_allow_bitfields_syntax(bitfield),\n          m_synthetic_children_traversal(synth_traverse) {}\n\n    GetValueForExpressionPathOptions &DoCheckDotVsArrowSyntax() {\n      m_check_dot_vs_arrow_syntax = true;\n      return *this;\n    }\n\n    GetValueForExpressionPathOptions &DontCheckDotVsArrowSyntax() {\n      m_check_dot_vs_arrow_syntax = false;\n      return *this;\n    }\n\n    GetValueForExpressionPathOptions &DoAllowFragileIVar() {\n      m_no_fragile_ivar = false;\n      return *this;\n    }\n\n    GetValueForExpressionPathOptions &DontAllowFragileIVar() {\n      m_no_fragile_ivar = true;\n      return *this;\n    }\n\n    GetValueForExpressionPathOptions &DoAllowBitfieldSyntax() {\n      m_allow_bitfields_syntax = true;\n      return *this;\n    }\n\n    GetValueForExpressionPathOptions &DontAllowBitfieldSyntax() {\n      m_allow_bitfields_syntax = false;\n      return *this;\n    }\n\n    GetValueForExpressionPathOptions &\n    SetSyntheticChildrenTraversal(SyntheticChildrenTraversal traverse) {\n      m_synthetic_children_traversal = traverse;\n      return *this;\n    }\n\n    static const GetValueForExpressionPathOptions DefaultOptions() {\n      static GetValueForExpressionPathOptions g_default_options;\n\n      return g_default_options;\n    }\n  };\n\n  class EvaluationPoint {\n  public:\n    EvaluationPoint();\n\n    EvaluationPoint(ExecutionContextScope *exe_scope,\n                    bool use_selected = false);\n\n    EvaluationPoint(const EvaluationPoint &rhs);\n\n    ~EvaluationPoint();\n\n    const ExecutionContextRef &GetExecutionContextRef() const {\n      return m_exe_ctx_ref;\n    }\n\n    void SetIsConstant() {\n      SetUpdated();\n      m_mod_id.SetInvalid();\n    }\n\n    bool IsConstant() const { return !m_mod_id.IsValid(); }\n\n    ProcessModID GetModID() const { return m_mod_id; }\n\n    void SetUpdateID(ProcessModID new_id) { m_mod_id = new_id; }\n\n    void SetNeedsUpdate() { m_needs_update = true; }\n\n    void SetUpdated();\n\n    bool NeedsUpdating(bool accept_invalid_exe_ctx) {\n      SyncWithProcessState(accept_invalid_exe_ctx);\n      return m_needs_update;\n    }\n\n    bool IsValid() {\n      const bool accept_invalid_exe_ctx = false;\n      if (!m_mod_id.IsValid())\n        return false;\n      else if (SyncWithProcessState(accept_invalid_exe_ctx)) {\n        if (!m_mod_id.IsValid())\n          return false;\n      }\n      return true;\n    }\n\n    void SetInvalid() {\n      // Use the stop id to mark us as invalid, leave the thread id and the\n      // stack id around for logging and history purposes.\n      m_mod_id.SetInvalid();\n\n      // Can't update an invalid state.\n      m_needs_update = false;\n    }\n\n  private:\n    bool SyncWithProcessState(bool accept_invalid_exe_ctx);\n\n    ProcessModID m_mod_id; // This is the stop id when this ValueObject was last\n                           // evaluated.\n    ExecutionContextRef m_exe_ctx_ref;\n    bool m_needs_update;\n  };\n\n  virtual ~ValueObject();\n\n  const EvaluationPoint &GetUpdatePoint() const { return m_update_point; }\n\n  EvaluationPoint &GetUpdatePoint() { return m_update_point; }\n\n  const ExecutionContextRef &GetExecutionContextRef() const {\n    return m_update_point.GetExecutionContextRef();\n  }\n\n  lldb::TargetSP GetTargetSP() const {\n    return m_update_point.GetExecutionContextRef().GetTargetSP();\n  }\n\n  lldb::ProcessSP GetProcessSP() const {\n    return m_update_point.GetExecutionContextRef().GetProcessSP();\n  }\n\n  lldb::ThreadSP GetThreadSP() const {\n    return m_update_point.GetExecutionContextRef().GetThreadSP();\n  }\n\n  lldb::StackFrameSP GetFrameSP() const {\n    return m_update_point.GetExecutionContextRef().GetFrameSP();\n  }\n\n  void SetNeedsUpdate();\n\n  CompilerType GetCompilerType() { return MaybeCalculateCompleteType(); }\n\n  // this vends a TypeImpl that is useful at the SB API layer\n  virtual TypeImpl GetTypeImpl() { return TypeImpl(GetCompilerType()); }\n\n  virtual bool CanProvideValue();\n\n  // Subclasses must implement the functions below.\n  virtual llvm::Optional<uint64_t> GetByteSize() = 0;\n\n  virtual lldb::ValueType GetValueType() const = 0;\n\n  // Subclasses can implement the functions below.\n  virtual ConstString GetTypeName() { return GetCompilerType().GetTypeName(); }\n\n  virtual ConstString GetDisplayTypeName() { return GetTypeName(); }\n\n  virtual ConstString GetQualifiedTypeName() {\n    return GetCompilerType().GetTypeName();\n  }\n\n  virtual lldb::LanguageType GetObjectRuntimeLanguage() {\n    return GetCompilerType().GetMinimumLanguage();\n  }\n\n  virtual uint32_t\n  GetTypeInfo(CompilerType *pointee_or_element_compiler_type = nullptr) {\n    return GetCompilerType().GetTypeInfo(pointee_or_element_compiler_type);\n  }\n\n  virtual bool IsPointerType() { return GetCompilerType().IsPointerType(); }\n\n  virtual bool IsArrayType() { return GetCompilerType().IsArrayType(); }\n\n  virtual bool IsScalarType() { return GetCompilerType().IsScalarType(); }\n\n  virtual bool IsPointerOrReferenceType() {\n    return GetCompilerType().IsPointerOrReferenceType();\n  }\n\n  virtual bool IsPossibleDynamicType();\n\n  bool IsNilReference();\n\n  bool IsUninitializedReference();\n\n  virtual bool IsBaseClass() { return false; }\n\n  bool IsBaseClass(uint32_t &depth);\n\n  virtual bool IsDereferenceOfParent() { return false; }\n\n  bool IsIntegerType(bool &is_signed) {\n    return GetCompilerType().IsIntegerType(is_signed);\n  }\n\n  virtual void GetExpressionPath(\n      Stream &s,\n      GetExpressionPathFormat = eGetExpressionPathFormatDereferencePointers);\n\n  lldb::ValueObjectSP GetValueForExpressionPath(\n      llvm::StringRef expression,\n      ExpressionPathScanEndReason *reason_to_stop = nullptr,\n      ExpressionPathEndResultType *final_value_type = nullptr,\n      const GetValueForExpressionPathOptions &options =\n          GetValueForExpressionPathOptions::DefaultOptions(),\n      ExpressionPathAftermath *final_task_on_target = nullptr);\n\n  virtual bool IsInScope() { return true; }\n\n  virtual lldb::offset_t GetByteOffset() { return 0; }\n\n  virtual uint32_t GetBitfieldBitSize() { return 0; }\n\n  virtual uint32_t GetBitfieldBitOffset() { return 0; }\n\n  bool IsBitfield() {\n    return (GetBitfieldBitSize() != 0) || (GetBitfieldBitOffset() != 0);\n  }\n\n  virtual bool IsArrayItemForPointer() {\n    return m_flags.m_is_array_item_for_pointer;\n  }\n\n  virtual const char *GetValueAsCString();\n\n  virtual bool GetValueAsCString(const lldb_private::TypeFormatImpl &format,\n                                 std::string &destination);\n\n  bool GetValueAsCString(lldb::Format format, std::string &destination);\n\n  virtual uint64_t GetValueAsUnsigned(uint64_t fail_value,\n                                      bool *success = nullptr);\n\n  virtual int64_t GetValueAsSigned(int64_t fail_value, bool *success = nullptr);\n\n  virtual bool SetValueFromCString(const char *value_str, Status &error);\n\n  /// Return the module associated with this value object in case the value is\n  /// from an executable file and might have its data in sections of the file.\n  /// This can be used for variables.\n  virtual lldb::ModuleSP GetModule();\n\n  ValueObject *GetRoot();\n\n  /// Given a ValueObject, loop over itself and its parent, and its parent's\n  /// parent, .. until either the given callback returns false, or you end up at\n  /// a null pointer\n  ValueObject *FollowParentChain(std::function<bool(ValueObject *)>);\n\n  virtual bool GetDeclaration(Declaration &decl);\n\n  // The functions below should NOT be modified by subclasses\n  const Status &GetError();\n\n  ConstString GetName() const { return m_name; }\n\n  /// Returns a unique id for this ValueObject.\n  lldb::user_id_t GetID() const { return m_id.GetID(); }\n\n  virtual lldb::ValueObjectSP GetChildAtIndex(size_t idx, bool can_create);\n\n  // this will always create the children if necessary\n  lldb::ValueObjectSP GetChildAtIndexPath(llvm::ArrayRef<size_t> idxs,\n                                          size_t *index_of_error = nullptr);\n\n  lldb::ValueObjectSP\n  GetChildAtIndexPath(llvm::ArrayRef<std::pair<size_t, bool>> idxs,\n                      size_t *index_of_error = nullptr);\n\n  // this will always create the children if necessary\n  lldb::ValueObjectSP GetChildAtNamePath(llvm::ArrayRef<ConstString> names,\n                                         ConstString *name_of_error = nullptr);\n\n  lldb::ValueObjectSP\n  GetChildAtNamePath(llvm::ArrayRef<std::pair<ConstString, bool>> names,\n                     ConstString *name_of_error = nullptr);\n\n  virtual lldb::ValueObjectSP GetChildMemberWithName(ConstString name,\n                                                     bool can_create);\n\n  virtual size_t GetIndexOfChildWithName(ConstString name);\n\n  size_t GetNumChildren(uint32_t max = UINT32_MAX);\n\n  const Value &GetValue() const { return m_value; }\n\n  Value &GetValue() { return m_value; }\n\n  virtual bool ResolveValue(Scalar &scalar);\n\n  // return 'false' whenever you set the error, otherwise callers may assume\n  // true means everything is OK - this will break breakpoint conditions among\n  // potentially a few others\n  virtual bool IsLogicalTrue(Status &error);\n\n  virtual const char *GetLocationAsCString() {\n    return GetLocationAsCStringImpl(m_value, m_data);\n  }\n\n  const char *\n  GetSummaryAsCString(lldb::LanguageType lang = lldb::eLanguageTypeUnknown);\n\n  bool\n  GetSummaryAsCString(TypeSummaryImpl *summary_ptr, std::string &destination,\n                      lldb::LanguageType lang = lldb::eLanguageTypeUnknown);\n\n  bool GetSummaryAsCString(std::string &destination,\n                           const TypeSummaryOptions &options);\n\n  bool GetSummaryAsCString(TypeSummaryImpl *summary_ptr,\n                           std::string &destination,\n                           const TypeSummaryOptions &options);\n\n  const char *GetObjectDescription();\n\n  bool HasSpecialPrintableRepresentation(\n      ValueObjectRepresentationStyle val_obj_display,\n      lldb::Format custom_format);\n\n  enum class PrintableRepresentationSpecialCases : bool {\n    eDisable = false,\n    eAllow = true\n  };\n\n  bool\n  DumpPrintableRepresentation(Stream &s,\n                              ValueObjectRepresentationStyle val_obj_display =\n                                  eValueObjectRepresentationStyleSummary,\n                              lldb::Format custom_format = lldb::eFormatInvalid,\n                              PrintableRepresentationSpecialCases special =\n                                  PrintableRepresentationSpecialCases::eAllow,\n                              bool do_dump_error = true);\n  bool GetValueIsValid() const { return m_flags.m_value_is_valid; }\n\n  // If you call this on a newly created ValueObject, it will always return\n  // false.\n  bool GetValueDidChange() { return m_flags.m_value_did_change; }\n\n  bool UpdateValueIfNeeded(bool update_format = true);\n\n  bool UpdateFormatsIfNeeded();\n\n  lldb::ValueObjectSP GetSP() { return m_manager->GetSharedPointer(this); }\n\n  /// Change the name of the current ValueObject. Should *not* be used from a\n  /// synthetic child provider as it would change the name of the non synthetic\n  /// child as well.\n  void SetName(ConstString name) { m_name = name; }\n\n  virtual lldb::addr_t GetAddressOf(bool scalar_is_load_address = true,\n                                    AddressType *address_type = nullptr);\n\n  lldb::addr_t GetPointerValue(AddressType *address_type = nullptr);\n\n  lldb::ValueObjectSP GetSyntheticChild(ConstString key) const;\n\n  lldb::ValueObjectSP GetSyntheticArrayMember(size_t index, bool can_create);\n\n  lldb::ValueObjectSP GetSyntheticBitFieldChild(uint32_t from, uint32_t to,\n                                                bool can_create);\n\n  lldb::ValueObjectSP GetSyntheticExpressionPathChild(const char *expression,\n                                                      bool can_create);\n\n  virtual lldb::ValueObjectSP\n  GetSyntheticChildAtOffset(uint32_t offset, const CompilerType &type,\n                            bool can_create,\n                            ConstString name_const_str = ConstString());\n\n  virtual lldb::ValueObjectSP\n  GetSyntheticBase(uint32_t offset, const CompilerType &type, bool can_create,\n                   ConstString name_const_str = ConstString());\n\n  virtual lldb::ValueObjectSP GetDynamicValue(lldb::DynamicValueType valueType);\n\n  lldb::DynamicValueType GetDynamicValueType();\n\n  virtual lldb::ValueObjectSP GetStaticValue() { return GetSP(); }\n\n  virtual lldb::ValueObjectSP GetNonSyntheticValue() { return GetSP(); }\n\n  lldb::ValueObjectSP GetSyntheticValue();\n\n  virtual bool HasSyntheticValue();\n\n  virtual bool IsSynthetic() { return false; }\n\n  lldb::ValueObjectSP\n  GetQualifiedRepresentationIfAvailable(lldb::DynamicValueType dynValue,\n                                        bool synthValue);\n\n  virtual lldb::ValueObjectSP CreateConstantValue(ConstString name);\n\n  virtual lldb::ValueObjectSP Dereference(Status &error);\n\n  /// Creates a copy of the ValueObject with a new name and setting the current\n  /// ValueObject as its parent. It should be used when we want to change the\n  /// name of a ValueObject without modifying the actual ValueObject itself\n  /// (e.g. sythetic child provider).\n  virtual lldb::ValueObjectSP Clone(ConstString new_name);\n\n  virtual lldb::ValueObjectSP AddressOf(Status &error);\n\n  virtual lldb::addr_t GetLiveAddress() { return LLDB_INVALID_ADDRESS; }\n\n  virtual void SetLiveAddress(lldb::addr_t addr = LLDB_INVALID_ADDRESS,\n                              AddressType address_type = eAddressTypeLoad) {}\n\n  virtual lldb::ValueObjectSP Cast(const CompilerType &compiler_type);\n\n  virtual lldb::ValueObjectSP CastPointerType(const char *name,\n                                              CompilerType &ast_type);\n\n  virtual lldb::ValueObjectSP CastPointerType(const char *name,\n                                              lldb::TypeSP &type_sp);\n\n  // The backing bits of this value object were updated, clear any descriptive\n  // string, so we know we have to refetch them.\n  virtual void ValueUpdated() {\n    ClearUserVisibleData(eClearUserVisibleDataItemsValue |\n                         eClearUserVisibleDataItemsSummary |\n                         eClearUserVisibleDataItemsDescription);\n  }\n\n  virtual bool IsDynamic() { return false; }\n\n  virtual bool DoesProvideSyntheticValue() { return false; }\n\n  virtual bool IsSyntheticChildrenGenerated() {\n    return m_flags.m_is_synthetic_children_generated;\n  }\n\n  virtual void SetSyntheticChildrenGenerated(bool b) {\n    m_flags.m_is_synthetic_children_generated = b;\n  }\n\n  virtual SymbolContextScope *GetSymbolContextScope();\n\n  void Dump(Stream &s);\n\n  void Dump(Stream &s, const DumpValueObjectOptions &options);\n\n  static lldb::ValueObjectSP\n  CreateValueObjectFromExpression(llvm::StringRef name,\n                                  llvm::StringRef expression,\n                                  const ExecutionContext &exe_ctx);\n\n  static lldb::ValueObjectSP\n  CreateValueObjectFromExpression(llvm::StringRef name,\n                                  llvm::StringRef expression,\n                                  const ExecutionContext &exe_ctx,\n                                  const EvaluateExpressionOptions &options);\n\n  static lldb::ValueObjectSP\n  CreateValueObjectFromAddress(llvm::StringRef name, uint64_t address,\n                               const ExecutionContext &exe_ctx,\n                               CompilerType type);\n\n  static lldb::ValueObjectSP\n  CreateValueObjectFromData(llvm::StringRef name, const DataExtractor &data,\n                            const ExecutionContext &exe_ctx, CompilerType type);\n\n  lldb::ValueObjectSP Persist();\n\n  /// Returns true if this is a char* or a char[] if it is a char* and\n  /// check_pointer is true, it also checks that the pointer is valid.\n  bool IsCStringContainer(bool check_pointer = false);\n\n  std::pair<size_t, bool>\n  ReadPointedString(lldb::DataBufferSP &buffer_sp, Status &error,\n                    uint32_t max_length = 0, bool honor_array = true,\n                    lldb::Format item_format = lldb::eFormatCharArray);\n\n  virtual size_t GetPointeeData(DataExtractor &data, uint32_t item_idx = 0,\n                                uint32_t item_count = 1);\n\n  virtual uint64_t GetData(DataExtractor &data, Status &error);\n\n  virtual bool SetData(DataExtractor &data, Status &error);\n\n  virtual bool GetIsConstant() const { return m_update_point.IsConstant(); }\n\n  bool NeedsUpdating() {\n    const bool accept_invalid_exe_ctx =\n        (CanUpdateWithInvalidExecutionContext() == eLazyBoolYes);\n    return m_update_point.NeedsUpdating(accept_invalid_exe_ctx);\n  }\n\n  void SetIsConstant() { m_update_point.SetIsConstant(); }\n\n  lldb::Format GetFormat() const;\n\n  virtual void SetFormat(lldb::Format format) {\n    if (format != m_format)\n      ClearUserVisibleData(eClearUserVisibleDataItemsValue);\n    m_format = format;\n  }\n\n  virtual lldb::LanguageType GetPreferredDisplayLanguage();\n\n  void SetPreferredDisplayLanguage(lldb::LanguageType lt) {\n    m_preferred_display_language = lt;\n  }\n\n  lldb::TypeSummaryImplSP GetSummaryFormat() {\n    UpdateFormatsIfNeeded();\n    return m_type_summary_sp;\n  }\n\n  void SetSummaryFormat(lldb::TypeSummaryImplSP format) {\n    m_type_summary_sp = std::move(format);\n    ClearUserVisibleData(eClearUserVisibleDataItemsSummary);\n  }\n\n  void SetValueFormat(lldb::TypeFormatImplSP format) {\n    m_type_format_sp = std::move(format);\n    ClearUserVisibleData(eClearUserVisibleDataItemsValue);\n  }\n\n  lldb::TypeFormatImplSP GetValueFormat() {\n    UpdateFormatsIfNeeded();\n    return m_type_format_sp;\n  }\n\n  void SetSyntheticChildren(const lldb::SyntheticChildrenSP &synth_sp) {\n    if (synth_sp.get() == m_synthetic_children_sp.get())\n      return;\n    ClearUserVisibleData(eClearUserVisibleDataItemsSyntheticChildren);\n    m_synthetic_children_sp = synth_sp;\n  }\n\n  lldb::SyntheticChildrenSP GetSyntheticChildren() {\n    UpdateFormatsIfNeeded();\n    return m_synthetic_children_sp;\n  }\n\n  // Use GetParent for display purposes, but if you want to tell the parent to\n  // update itself then use m_parent.  The ValueObjectDynamicValue's parent is\n  // not the correct parent for displaying, they are really siblings, so for\n  // display it needs to route through to its grandparent.\n  virtual ValueObject *GetParent() { return m_parent; }\n\n  virtual const ValueObject *GetParent() const { return m_parent; }\n\n  ValueObject *GetNonBaseClassParent();\n\n  void SetAddressTypeOfChildren(AddressType at) {\n    m_address_type_of_ptr_or_ref_children = at;\n  }\n\n  AddressType GetAddressTypeOfChildren();\n\n  void SetHasCompleteType() {\n    m_flags.m_did_calculate_complete_objc_class_type = true;\n  }\n\n  /// Find out if a ValueObject might have children.\n  ///\n  /// This call is much more efficient than CalculateNumChildren() as\n  /// it doesn't need to complete the underlying type. This is designed\n  /// to be used in a UI environment in order to detect if the\n  /// disclosure triangle should be displayed or not.\n  ///\n  /// This function returns true for class, union, structure,\n  /// pointers, references, arrays and more. Again, it does so without\n  /// doing any expensive type completion.\n  ///\n  /// \\return\n  ///     Returns \\b true if the ValueObject might have children, or \\b\n  ///     false otherwise.\n  virtual bool MightHaveChildren();\n\n  virtual lldb::VariableSP GetVariable() { return nullptr; }\n\n  virtual bool IsRuntimeSupportValue();\n\n  virtual uint64_t GetLanguageFlags() { return m_language_flags; }\n\n  virtual void SetLanguageFlags(uint64_t flags) { m_language_flags = flags; }\n\nprotected:\n  typedef ClusterManager<ValueObject> ValueObjectManager;\n\n  class ChildrenManager {\n  public:\n    ChildrenManager() : m_mutex(), m_children(), m_children_count(0) {}\n\n    bool HasChildAtIndex(size_t idx) {\n      std::lock_guard<std::recursive_mutex> guard(m_mutex);\n      return (m_children.find(idx) != m_children.end());\n    }\n\n    ValueObject *GetChildAtIndex(size_t idx) {\n      std::lock_guard<std::recursive_mutex> guard(m_mutex);\n      const auto iter = m_children.find(idx);\n      return ((iter == m_children.end()) ? nullptr : iter->second);\n    }\n\n    void SetChildAtIndex(size_t idx, ValueObject *valobj) {\n      // we do not need to be mutex-protected to make a pair\n      ChildrenPair pair(idx, valobj);\n      std::lock_guard<std::recursive_mutex> guard(m_mutex);\n      m_children.insert(pair);\n    }\n\n    void SetChildrenCount(size_t count) { Clear(count); }\n\n    size_t GetChildrenCount() { return m_children_count; }\n\n    void Clear(size_t new_count = 0) {\n      std::lock_guard<std::recursive_mutex> guard(m_mutex);\n      m_children_count = new_count;\n      m_children.clear();\n    }\n\n  private:\n    typedef std::map<size_t, ValueObject *> ChildrenMap;\n    typedef ChildrenMap::iterator ChildrenIterator;\n    typedef ChildrenMap::value_type ChildrenPair;\n    std::recursive_mutex m_mutex;\n    ChildrenMap m_children;\n    size_t m_children_count;\n  };\n\n  // Classes that inherit from ValueObject can see and modify these\n\n  /// The parent value object, or nullptr if this has no parent.\n  ValueObject *m_parent = nullptr;\n  /// The root of the hierarchy for this ValueObject (or nullptr if never\n  /// calculated).\n  ValueObject *m_root = nullptr;\n  /// Stores both the stop id and the full context at which this value was last\n  /// updated.  When we are asked to update the value object, we check whether\n  /// the context & stop id are the same before updating.\n  EvaluationPoint m_update_point;\n  /// The name of this object.\n  ConstString m_name;\n  /// A data extractor that can be used to extract the value.\n  DataExtractor m_data;\n  Value m_value;\n  /// An error object that can describe any errors that occur when updating\n  /// values.\n  Status m_error;\n  /// Cached value string that will get cleared if/when the value is updated.\n  std::string m_value_str;\n  /// Cached old value string from the last time the value was gotten\n  std::string m_old_value_str;\n  /// Cached location string that will get cleared if/when the value is updated.\n  std::string m_location_str;\n  /// Cached summary string that will get cleared if/when the value is updated.\n  std::string m_summary_str;\n  /// Cached result of the \"object printer\". This differs from the summary\n  /// in that the summary is consed up by us, the object_desc_string is builtin.\n  std::string m_object_desc_str;\n  /// If the type of the value object should be overridden, the type to impose.\n  CompilerType m_override_type;\n\n  /// This object is managed by the root object (any ValueObject that gets\n  /// created without a parent.) The manager gets passed through all the\n  /// generations of dependent objects, and will keep the whole cluster of\n  /// objects alive as long as a shared pointer to any of them has been handed\n  /// out. Shared pointers to value objects must always be made with the GetSP\n  /// method.\n  ValueObjectManager *m_manager = nullptr;\n\n  ChildrenManager m_children;\n  std::map<ConstString, ValueObject *> m_synthetic_children;\n\n  ValueObject *m_dynamic_value = nullptr;\n  ValueObject *m_synthetic_value = nullptr;\n  ValueObject *m_deref_valobj = nullptr;\n\n  /// We have to hold onto a shared  pointer to this one because it is created\n  /// as an independent ValueObjectConstResult, which isn't managed by us.\n  lldb::ValueObjectSP m_addr_of_valobj_sp;\n\n  lldb::Format m_format = lldb::eFormatDefault;\n  lldb::Format m_last_format = lldb::eFormatDefault;\n  uint32_t m_last_format_mgr_revision = 0;\n  lldb::TypeSummaryImplSP m_type_summary_sp;\n  lldb::TypeFormatImplSP m_type_format_sp;\n  lldb::SyntheticChildrenSP m_synthetic_children_sp;\n  ProcessModID m_user_id_of_forced_summary;\n  AddressType m_address_type_of_ptr_or_ref_children = eAddressTypeInvalid;\n\n  llvm::SmallVector<uint8_t, 16> m_value_checksum;\n\n  lldb::LanguageType m_preferred_display_language = lldb::eLanguageTypeUnknown;\n\n  uint64_t m_language_flags = 0;\n\n  /// Unique identifier for every value object.\n  UserID m_id;\n\n  // Utility class for initializing all bitfields in ValueObject's constructors.\n  // FIXME: This could be done via default initializers once we have C++20.\n  struct Bitflags {\n    bool m_value_is_valid : 1, m_value_did_change : 1,\n        m_children_count_valid : 1, m_old_value_valid : 1,\n        m_is_deref_of_parent : 1, m_is_array_item_for_pointer : 1,\n        m_is_bitfield_for_scalar : 1, m_is_child_at_offset : 1,\n        m_is_getting_summary : 1, m_did_calculate_complete_objc_class_type : 1,\n        m_is_synthetic_children_generated : 1;\n    Bitflags() {\n      m_value_is_valid = false;\n      m_value_did_change = false;\n      m_children_count_valid = false;\n      m_old_value_valid = false;\n      m_is_deref_of_parent = false;\n      m_is_array_item_for_pointer = false;\n      m_is_bitfield_for_scalar = false;\n      m_is_child_at_offset = false;\n      m_is_getting_summary = false;\n      m_did_calculate_complete_objc_class_type = false;\n      m_is_synthetic_children_generated = false;\n    }\n  } m_flags;\n\n  friend class ValueObjectChild;\n  friend class ExpressionVariable;     // For SetName\n  friend class Target;                 // For SetName\n  friend class ValueObjectConstResultImpl;\n  friend class ValueObjectSynthetic; // For ClearUserVisibleData\n\n  /// Use this constructor to create a \"root variable object\".  The ValueObject\n  /// will be locked to this context through-out its lifespan.\n  ValueObject(ExecutionContextScope *exe_scope, ValueObjectManager &manager,\n              AddressType child_ptr_or_ref_addr_type = eAddressTypeLoad);\n\n  /// Use this constructor to create a ValueObject owned by another ValueObject.\n  /// It will inherit the ExecutionContext of its parent.\n  ValueObject(ValueObject &parent);\n\n  ValueObjectManager *GetManager() { return m_manager; }\n\n  virtual bool UpdateValue() = 0;\n\n  virtual LazyBool CanUpdateWithInvalidExecutionContext() {\n    return eLazyBoolCalculate;\n  }\n\n  virtual void CalculateDynamicValue(lldb::DynamicValueType use_dynamic);\n\n  virtual lldb::DynamicValueType GetDynamicValueTypeImpl() {\n    return lldb::eNoDynamicValues;\n  }\n\n  virtual bool HasDynamicValueTypeInfo() { return false; }\n\n  virtual void CalculateSyntheticValue();\n\n  /// Should only be called by ValueObject::GetChildAtIndex().\n  ///\n  /// \\return A ValueObject managed by this ValueObject's manager.\n  virtual ValueObject *CreateChildAtIndex(size_t idx,\n                                          bool synthetic_array_member,\n                                          int32_t synthetic_index);\n\n  /// Should only be called by ValueObject::GetNumChildren().\n  virtual size_t CalculateNumChildren(uint32_t max = UINT32_MAX) = 0;\n\n  void SetNumChildren(size_t num_children);\n\n  void SetValueDidChange(bool value_changed) {\n    m_flags.m_value_did_change = value_changed;\n  }\n\n  void SetValueIsValid(bool valid) { m_flags.m_value_is_valid = valid; }\n\n  void ClearUserVisibleData(\n      uint32_t items = ValueObject::eClearUserVisibleDataItemsAllStrings);\n\n  void AddSyntheticChild(ConstString key, ValueObject *valobj);\n\n  DataExtractor &GetDataExtractor();\n\n  void ClearDynamicTypeInformation();\n\n  // Subclasses must implement the functions below.\n\n  virtual CompilerType GetCompilerTypeImpl() = 0;\n\n  const char *GetLocationAsCStringImpl(const Value &value,\n                                       const DataExtractor &data);\n\n  bool IsChecksumEmpty() { return m_value_checksum.empty(); }\n\n  void SetPreferredDisplayLanguageIfNeeded(lldb::LanguageType);\n\nprotected:\n  virtual void DoUpdateChildrenAddressType(ValueObject &valobj) { return; };\n\nprivate:\n  virtual CompilerType MaybeCalculateCompleteType();\n  void UpdateChildrenAddressType() {\n    GetRoot()->DoUpdateChildrenAddressType(*this);\n  }\n\n  lldb::ValueObjectSP GetValueForExpressionPath_Impl(\n      llvm::StringRef expression_cstr,\n      ExpressionPathScanEndReason *reason_to_stop,\n      ExpressionPathEndResultType *final_value_type,\n      const GetValueForExpressionPathOptions &options,\n      ExpressionPathAftermath *final_task_on_target);\n\n  ValueObject(const ValueObject &) = delete;\n  const ValueObject &operator=(const ValueObject &) = delete;\n};\n\n} // namespace lldb_private\n\n#endif // LLDB_CORE_VALUEOBJECT_H\n"}, "12": {"id": 12, "path": "/home/vsts/work/1/llvm-project/lldb/include/lldb/DataFormatters/FormatClasses.h", "content": "//===-- FormatClasses.h -----------------------------------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLDB_DATAFORMATTERS_FORMATCLASSES_H\n#define LLDB_DATAFORMATTERS_FORMATCLASSES_H\n\n#include <functional>\n#include <memory>\n#include <string>\n#include <vector>\n\n#include \"lldb/DataFormatters/TypeFormat.h\"\n#include \"lldb/DataFormatters/TypeSummary.h\"\n#include \"lldb/DataFormatters/TypeSynthetic.h\"\n#include \"lldb/Symbol/CompilerType.h\"\n#include \"lldb/Symbol/Type.h\"\n#include \"lldb/lldb-enumerations.h\"\n#include \"lldb/lldb-public.h\"\n\nnamespace lldb_private {\n\nclass HardcodedFormatters {\npublic:\n  template <typename FormatterType>\n  using HardcodedFormatterFinder =\n      std::function<typename FormatterType::SharedPointer(\n          lldb_private::ValueObject &, lldb::DynamicValueType,\n          FormatManager &)>;\n\n  template <typename FormatterType>\n  using HardcodedFormatterFinders =\n      std::vector<HardcodedFormatterFinder<FormatterType>>;\n\n  typedef HardcodedFormatterFinders<TypeFormatImpl> HardcodedFormatFinder;\n  typedef HardcodedFormatterFinders<TypeSummaryImpl> HardcodedSummaryFinder;\n  typedef HardcodedFormatterFinders<SyntheticChildren> HardcodedSyntheticFinder;\n};\n\nclass FormattersMatchCandidate {\npublic:\n  FormattersMatchCandidate(ConstString name, bool strip_ptr,\n                           bool strip_ref, bool strip_tydef)\n      : m_type_name(name), m_stripped_pointer(strip_ptr),\n        m_stripped_reference(strip_ref), m_stripped_typedef(strip_tydef) {}\n\n  ~FormattersMatchCandidate() = default;\n\n  ConstString GetTypeName() const { return m_type_name; }\n\n  bool DidStripPointer() const { return m_stripped_pointer; }\n\n  bool DidStripReference() const { return m_stripped_reference; }\n\n  bool DidStripTypedef() const { return m_stripped_typedef; }\n\n  template <class Formatter>\n  bool IsMatch(const std::shared_ptr<Formatter> &formatter_sp) const {\n    if (!formatter_sp)\n      return false;\n    if (formatter_sp->Cascades() == false && DidStripTypedef())\n      return false;\n    if (formatter_sp->SkipsPointers() && DidStripPointer())\n      return false;\n    if (formatter_sp->SkipsReferences() && DidStripReference())\n      return false;\n    return true;\n  }\n\nprivate:\n  ConstString m_type_name;\n  bool m_stripped_pointer;\n  bool m_stripped_reference;\n  bool m_stripped_typedef;\n};\n\ntypedef std::vector<FormattersMatchCandidate> FormattersMatchVector;\ntypedef std::vector<lldb::LanguageType> CandidateLanguagesVector;\n\nclass FormattersMatchData {\npublic:\n  FormattersMatchData(ValueObject &, lldb::DynamicValueType);\n\n  FormattersMatchVector GetMatchesVector();\n\n  ConstString GetTypeForCache();\n\n  CandidateLanguagesVector GetCandidateLanguages();\n\n  ValueObject &GetValueObject();\n\n  lldb::DynamicValueType GetDynamicValueType();\n\nprivate:\n  ValueObject &m_valobj;\n  lldb::DynamicValueType m_dynamic_value_type;\n  std::pair<FormattersMatchVector, bool> m_formatters_match_vector;\n  ConstString m_type_for_cache;\n  CandidateLanguagesVector m_candidate_languages;\n};\n\nclass TypeNameSpecifierImpl {\npublic:\n  TypeNameSpecifierImpl() : m_is_regex(false), m_type() {}\n\n  TypeNameSpecifierImpl(llvm::StringRef name, bool is_regex)\n      : m_is_regex(is_regex), m_type() {\n    m_type.m_type_name = std::string(name);\n  }\n\n  // if constructing with a given type, is_regex cannot be true since we are\n  // giving an exact type to match\n  TypeNameSpecifierImpl(lldb::TypeSP type) : m_is_regex(false), m_type() {\n    if (type) {\n      m_type.m_type_name = std::string(type->GetName().GetStringRef());\n      m_type.m_compiler_type = type->GetForwardCompilerType();\n    }\n  }\n\n  TypeNameSpecifierImpl(CompilerType type) : m_is_regex(false), m_type() {\n    if (type.IsValid()) {\n      m_type.m_type_name.assign(type.GetTypeName().GetCString());\n      m_type.m_compiler_type = type;\n    }\n  }\n\n  const char *GetName() {\n    if (m_type.m_type_name.size())\n      return m_type.m_type_name.c_str();\n    return nullptr;\n  }\n\n  CompilerType GetCompilerType() {\n    if (m_type.m_compiler_type.IsValid())\n      return m_type.m_compiler_type;\n    return CompilerType();\n  }\n\n  bool IsRegex() { return m_is_regex; }\n\nprivate:\n  bool m_is_regex;\n  // TODO: Replace this with TypeAndOrName.\n  struct TypeOrName {\n    std::string m_type_name;\n    CompilerType m_compiler_type;\n  };\n  TypeOrName m_type;\n\n  TypeNameSpecifierImpl(const TypeNameSpecifierImpl &) = delete;\n  const TypeNameSpecifierImpl &\n  operator=(const TypeNameSpecifierImpl &) = delete;\n};\n\n} // namespace lldb_private\n\n#endif // LLDB_DATAFORMATTERS_FORMATCLASSES_H\n"}, "13": {"id": 13, "path": "/home/vsts/work/1/llvm-project/lldb/include/lldb/DataFormatters/FormattersContainer.h", "content": "//===-- FormattersContainer.h -----------------------------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLDB_DATAFORMATTERS_FORMATTERSCONTAINER_H\n#define LLDB_DATAFORMATTERS_FORMATTERSCONTAINER_H\n\n#include <functional>\n#include <map>\n#include <memory>\n#include <mutex>\n#include <string>\n\n#include \"lldb/lldb-public.h\"\n\n#include \"lldb/Core/ValueObject.h\"\n#include \"lldb/DataFormatters/FormatClasses.h\"\n#include \"lldb/DataFormatters/TypeFormat.h\"\n#include \"lldb/DataFormatters/TypeSummary.h\"\n#include \"lldb/DataFormatters/TypeSynthetic.h\"\n#include \"lldb/Symbol/CompilerType.h\"\n#include \"lldb/Utility/RegularExpression.h\"\n#include \"lldb/Utility/StringLexer.h\"\n\nnamespace lldb_private {\n\nclass IFormatChangeListener {\npublic:\n  virtual ~IFormatChangeListener() = default;\n\n  virtual void Changed() = 0;\n\n  virtual uint32_t GetCurrentRevision() = 0;\n};\n\n/// Class for matching type names.\nclass TypeMatcher {\n  RegularExpression m_type_name_regex;\n  ConstString m_type_name;\n  /// False if m_type_name_regex should be used for matching. False if this is\n  /// just matching by comparing with m_type_name string.\n  bool m_is_regex;\n\n  // if the user tries to add formatters for, say, \"struct Foo\" those will not\n  // match any type because of the way we strip qualifiers from typenames this\n  // method looks for the case where the user is adding a\n  // \"class\",\"struct\",\"enum\" or \"union\" Foo and strips the unnecessary qualifier\n  static ConstString StripTypeName(ConstString type) {\n    if (type.IsEmpty())\n      return type;\n\n    std::string type_cstr(type.AsCString());\n    StringLexer type_lexer(type_cstr);\n\n    type_lexer.AdvanceIf(\"class \");\n    type_lexer.AdvanceIf(\"enum \");\n    type_lexer.AdvanceIf(\"struct \");\n    type_lexer.AdvanceIf(\"union \");\n\n    while (type_lexer.NextIf({' ', '\\t', '\\v', '\\f'}).first)\n      ;\n\n    return ConstString(type_lexer.GetUnlexed());\n  }\n\npublic:\n  TypeMatcher() = delete;\n  /// Creates a matcher that accepts any type with exactly the given type name.\n  TypeMatcher(ConstString type_name)\n      : m_type_name(type_name), m_is_regex(false) {}\n  /// Creates a matcher that accepts any type matching the given regex.\n  TypeMatcher(RegularExpression regex)\n      : m_type_name_regex(std::move(regex)), m_is_regex(true) {}\n\n  /// True iff this matches the given type name.\n  bool Matches(ConstString type_name) const {\n    if (m_is_regex)\n      return m_type_name_regex.Execute(type_name.GetStringRef());\n    return m_type_name == type_name ||\n           StripTypeName(m_type_name) == StripTypeName(type_name);\n  }\n\n  /// Returns the underlying match string for this TypeMatcher.\n  ConstString GetMatchString() const {\n    if (m_is_regex)\n      return ConstString(m_type_name_regex.GetText());\n    return StripTypeName(m_type_name);\n  }\n\n  /// Returns true if this TypeMatcher and the given one were most created by\n  /// the same match string.\n  /// The main purpose of this function is to find existing TypeMatcher\n  /// instances by the user input that created them. This is necessary as LLDB\n  /// allows referencing existing TypeMatchers in commands by the user input\n  /// that originally created them:\n  /// (lldb) type summary add --summary-string \\\"A\\\" -x TypeName\n  /// (lldb) type summary delete TypeName\n  bool CreatedBySameMatchString(TypeMatcher other) const {\n    return GetMatchString() == other.GetMatchString();\n  }\n};\n\ntemplate <typename ValueType> class FormattersContainer {\npublic:\n  typedef typename std::shared_ptr<ValueType> ValueSP;\n  typedef std::vector<std::pair<TypeMatcher, ValueSP>> MapType;\n  typedef std::function<bool(const TypeMatcher &, const ValueSP &)>\n      ForEachCallback;\n  typedef typename std::shared_ptr<FormattersContainer<ValueType>>\n      SharedPointer;\n\n  friend class TypeCategoryImpl;\n\n  FormattersContainer(IFormatChangeListener *lst) : listener(lst) {}\n\n  void Add(TypeMatcher matcher, const ValueSP &entry) {\n    if (listener)\n      entry->GetRevision() = listener->GetCurrentRevision();\n    else\n      entry->GetRevision() = 0;\n\n    std::lock_guard<std::recursive_mutex> guard(m_map_mutex);\n    Delete(matcher);\n    m_map.emplace_back(std::move(matcher), std::move(entry));\n    if (listener)\n      listener->Changed();\n  }\n\n  bool Delete(TypeMatcher matcher) {\n    std::lock_guard<std::recursive_mutex> guard(m_map_mutex);\n    for (auto iter = m_map.begin(); iter != m_map.end(); ++iter)\n      if (iter->first.CreatedBySameMatchString(matcher)) {\n        m_map.erase(iter);\n        if (listener)\n          listener->Changed();\n        return true;\n      }\n    return false;\n  }\n\n  bool Get(ConstString type, ValueSP &entry) {\n    std::lock_guard<std::recursive_mutex> guard(m_map_mutex);\n    for (auto &formatter : llvm::reverse(m_map)) {\n      if (formatter.first.Matches(type)) {\n        entry = formatter.second;\n        return true;\n      }\n    }\n    return false;\n  }\n\n  bool GetExact(TypeMatcher matcher, ValueSP &entry) {\n    std::lock_guard<std::recursive_mutex> guard(m_map_mutex);\n    for (const auto &pos : m_map)\n      if (pos.first.CreatedBySameMatchString(matcher)) {\n        entry = pos.second;\n        return true;\n      }\n    return false;\n  }\n\n  ValueSP GetAtIndex(size_t index) {\n    std::lock_guard<std::recursive_mutex> guard(m_map_mutex);\n    if (index >= m_map.size())\n      return ValueSP();\n    return m_map[index].second;\n  }\n\n  lldb::TypeNameSpecifierImplSP GetTypeNameSpecifierAtIndex(size_t index) {\n    std::lock_guard<std::recursive_mutex> guard(m_map_mutex);\n    if (index >= m_map.size())\n      return lldb::TypeNameSpecifierImplSP();\n    TypeMatcher type_matcher = m_map[index].first;\n    return std::make_shared<TypeNameSpecifierImpl>(\n        type_matcher.GetMatchString().GetStringRef(), true);\n  }\n\n  void Clear() {\n    std::lock_guard<std::recursive_mutex> guard(m_map_mutex);\n    m_map.clear();\n    if (listener)\n      listener->Changed();\n  }\n\n  void ForEach(ForEachCallback callback) {\n    if (callback) {\n      std::lock_guard<std::recursive_mutex> guard(m_map_mutex);\n      for (const auto &pos : m_map) {\n        const TypeMatcher &type = pos.first;\n        if (!callback(type, pos.second))\n          break;\n      }\n    }\n  }\n\n  uint32_t GetCount() {\n    std::lock_guard<std::recursive_mutex> guard(m_map_mutex);\n    return m_map.size();\n  }\n\n  void AutoComplete(CompletionRequest &request) {\n    ForEach([&request](const TypeMatcher &matcher, const ValueSP &value) {\n      request.TryCompleteCurrentArg(matcher.GetMatchString().GetStringRef());\n      return true;\n    });\n  }\n\nprotected:\n  FormattersContainer(const FormattersContainer &) = delete;\n  const FormattersContainer &operator=(const FormattersContainer &) = delete;\n\n  bool Get(const FormattersMatchVector &candidates, ValueSP &entry) {\n    for (const FormattersMatchCandidate &candidate : candidates) {\n      if (Get(candidate.GetTypeName(), entry)) {\n        if (candidate.IsMatch(entry) == false) {\n          entry.reset();\n          continue;\n        } else {\n          return true;\n        }\n      }\n    }\n    return false;\n  }\n\n  MapType m_map;\n  std::recursive_mutex m_map_mutex;\n  IFormatChangeListener *listener;\n};\n\n} // namespace lldb_private\n\n#endif // LLDB_DATAFORMATTERS_FORMATTERSCONTAINER_H\n"}, "14": {"id": 14, "path": "/home/vsts/work/1/llvm-project/lldb/include/lldb/DataFormatters/FormattersHelpers.h", "content": "//===-- FormattersHelpers.h --------------------------------------*- C++\n//-*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLDB_DATAFORMATTERS_FORMATTERSHELPERS_H\n#define LLDB_DATAFORMATTERS_FORMATTERSHELPERS_H\n\n#include \"lldb/lldb-enumerations.h\"\n#include \"lldb/lldb-forward.h\"\n\n#include \"lldb/DataFormatters/TypeCategory.h\"\n#include \"lldb/DataFormatters/TypeFormat.h\"\n#include \"lldb/DataFormatters/TypeSummary.h\"\n#include \"lldb/DataFormatters/TypeSynthetic.h\"\n\nnamespace lldb_private {\nnamespace formatters {\nvoid AddFormat(TypeCategoryImpl::SharedPointer category_sp, lldb::Format format,\n               ConstString type_name, TypeFormatImpl::Flags flags,\n               bool regex = false);\n\nvoid AddSummary(TypeCategoryImpl::SharedPointer category_sp,\n                lldb::TypeSummaryImplSP summary_sp, ConstString type_name,\n                bool regex = false);\n\nvoid AddStringSummary(TypeCategoryImpl::SharedPointer category_sp,\n                      const char *string, ConstString type_name,\n                      TypeSummaryImpl::Flags flags, bool regex = false);\n\nvoid AddOneLineSummary(TypeCategoryImpl::SharedPointer category_sp,\n                       ConstString type_name, TypeSummaryImpl::Flags flags,\n                       bool regex = false);\n\nvoid AddCXXSummary(TypeCategoryImpl::SharedPointer category_sp,\n                   CXXFunctionSummaryFormat::Callback funct,\n                   const char *description, ConstString type_name,\n                   TypeSummaryImpl::Flags flags, bool regex = false);\n\nvoid AddCXXSynthetic(TypeCategoryImpl::SharedPointer category_sp,\n                     CXXSyntheticChildren::CreateFrontEndCallback generator,\n                     const char *description, ConstString type_name,\n                     ScriptedSyntheticChildren::Flags flags,\n                     bool regex = false);\n\nvoid AddFilter(TypeCategoryImpl::SharedPointer category_sp,\n               std::vector<std::string> children, const char *description,\n               ConstString type_name, ScriptedSyntheticChildren::Flags flags,\n               bool regex = false);\n\nsize_t ExtractIndexFromString(const char *item_name);\n\nlldb::addr_t GetArrayAddressOrPointerValue(ValueObject &valobj);\n\nlldb::ValueObjectSP GetValueOfLibCXXCompressedPair(ValueObject &pair);\n\ntime_t GetOSXEpoch();\n\nstruct InferiorSizedWord {\n\n  InferiorSizedWord(const InferiorSizedWord &word) : ptr_size(word.ptr_size) {\n    if (ptr_size == 4)\n      thirty_two = word.thirty_two;\n    else\n      sixty_four = word.sixty_four;\n  }\n\n  InferiorSizedWord operator=(const InferiorSizedWord &word) {\n    ptr_size = word.ptr_size;\n    if (ptr_size == 4)\n      thirty_two = word.thirty_two;\n    else\n      sixty_four = word.sixty_four;\n    return *this;\n  }\n\n  InferiorSizedWord(uint64_t val, Process &process)\n      : ptr_size(process.GetAddressByteSize()) {\n    if (ptr_size == 4)\n      thirty_two = (uint32_t)val;\n    else if (ptr_size == 8)\n      sixty_four = val;\n    else\n      assert(false && \"new pointer size is unknown\");\n  }\n\n  bool IsNegative() const {\n    if (ptr_size == 4)\n      return ((int32_t)thirty_two) < 0;\n    else\n      return ((int64_t)sixty_four) < 0;\n  }\n\n  bool IsZero() const {\n    if (ptr_size == 4)\n      return thirty_two == 0;\n    else\n      return sixty_four == 0;\n  }\n\n  static InferiorSizedWord GetMaximum(Process &process) {\n    if (process.GetAddressByteSize() == 4)\n      return InferiorSizedWord(UINT32_MAX, 4);\n    else\n      return InferiorSizedWord(UINT64_MAX, 8);\n  }\n\n  InferiorSizedWord operator>>(int rhs) const {\n    if (ptr_size == 4)\n      return InferiorSizedWord(thirty_two >> rhs, 4);\n    return InferiorSizedWord(sixty_four >> rhs, 8);\n  }\n\n  InferiorSizedWord operator<<(int rhs) const {\n    if (ptr_size == 4)\n      return InferiorSizedWord(thirty_two << rhs, 4);\n    return InferiorSizedWord(sixty_four << rhs, 8);\n  }\n\n  InferiorSizedWord operator&(const InferiorSizedWord &word) const {\n    if (ptr_size != word.ptr_size)\n      return InferiorSizedWord(0, ptr_size);\n    if (ptr_size == 4)\n      return InferiorSizedWord(thirty_two & word.thirty_two, 4);\n    return InferiorSizedWord(sixty_four & word.sixty_four, 8);\n  }\n\n  InferiorSizedWord operator&(int x) const {\n    if (ptr_size == 4)\n      return InferiorSizedWord(thirty_two & x, 4);\n    return InferiorSizedWord(sixty_four & x, 8);\n  }\n\n  size_t GetBitSize() const { return ptr_size << 3; }\n\n  size_t GetByteSize() const { return ptr_size; }\n\n  uint64_t GetValue() const {\n    if (ptr_size == 4)\n      return (uint64_t)thirty_two;\n    return sixty_four;\n  }\n\n  InferiorSizedWord SignExtend() const {\n    if (ptr_size == 4)\n      return InferiorSizedWord((int32_t)thirty_two, 4);\n    return InferiorSizedWord((int64_t)sixty_four, 8);\n  }\n\n  uint8_t *CopyToBuffer(uint8_t *buffer) const {\n    if (ptr_size == 4) {\n      memcpy(buffer, &thirty_two, 4);\n      return buffer + 4;\n    } else {\n      memcpy(buffer, &sixty_four, 8);\n      return buffer + 8;\n    }\n  }\n\n  DataExtractor\n  GetAsData(lldb::ByteOrder byte_order = lldb::eByteOrderInvalid) const {\n    if (ptr_size == 4)\n      return DataExtractor(&thirty_two, 4, byte_order, 4);\n    else\n      return DataExtractor(&sixty_four, 8, byte_order, 8);\n  }\n\nprivate:\n  InferiorSizedWord(uint64_t val, size_t psz) : ptr_size(psz) {\n    if (ptr_size == 4)\n      thirty_two = (uint32_t)val;\n    else\n      sixty_four = val;\n  }\n\n  size_t ptr_size;\n  union {\n    uint32_t thirty_two;\n    uint64_t sixty_four;\n  };\n};\n} // namespace formatters\n} // namespace lldb_private\n\n#endif // LLDB_DATAFORMATTERS_FORMATTERSHELPERS_H\n"}, "15": {"id": 15, "path": "/home/vsts/work/1/llvm-project/lldb/include/lldb/DataFormatters/TypeFormat.h", "content": "//===-- TypeFormat.h ----------------------------------------------*- C++\n//-*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLDB_DATAFORMATTERS_TYPEFORMAT_H\n#define LLDB_DATAFORMATTERS_TYPEFORMAT_H\n\n#include <functional>\n#include <string>\n#include <unordered_map>\n\n\n#include \"lldb/lldb-enumerations.h\"\n#include \"lldb/lldb-public.h\"\n\n#include \"lldb/Core/ValueObject.h\"\n\nnamespace lldb_private {\nclass TypeFormatImpl {\npublic:\n  class Flags {\n  public:\n    Flags() : m_flags(lldb::eTypeOptionCascade) {}\n\n    Flags(const Flags &other) : m_flags(other.m_flags) {}\n\n    Flags(uint32_t value) : m_flags(value) {}\n\n    Flags &operator=(const Flags &rhs) {\n      if (&rhs != this)\n        m_flags = rhs.m_flags;\n\n      return *this;\n    }\n\n    Flags &operator=(const uint32_t &rhs) {\n      m_flags = rhs;\n      return *this;\n    }\n\n    Flags &Clear() {\n      m_flags = 0;\n      return *this;\n    }\n\n    bool GetCascades() const {\n      return (m_flags & lldb::eTypeOptionCascade) == lldb::eTypeOptionCascade;\n    }\n\n    Flags &SetCascades(bool value = true) {\n      if (value)\n        m_flags |= lldb::eTypeOptionCascade;\n      else\n        m_flags &= ~lldb::eTypeOptionCascade;\n      return *this;\n    }\n\n    bool GetSkipPointers() const {\n      return (m_flags & lldb::eTypeOptionSkipPointers) ==\n             lldb::eTypeOptionSkipPointers;\n    }\n\n    Flags &SetSkipPointers(bool value = true) {\n      if (value)\n        m_flags |= lldb::eTypeOptionSkipPointers;\n      else\n        m_flags &= ~lldb::eTypeOptionSkipPointers;\n      return *this;\n    }\n\n    bool GetSkipReferences() const {\n      return (m_flags & lldb::eTypeOptionSkipReferences) ==\n             lldb::eTypeOptionSkipReferences;\n    }\n\n    Flags &SetSkipReferences(bool value = true) {\n      if (value)\n        m_flags |= lldb::eTypeOptionSkipReferences;\n      else\n        m_flags &= ~lldb::eTypeOptionSkipReferences;\n      return *this;\n    }\n\n    bool GetNonCacheable() const {\n      return (m_flags & lldb::eTypeOptionNonCacheable) ==\n             lldb::eTypeOptionNonCacheable;\n    }\n\n    Flags &SetNonCacheable(bool value = true) {\n      if (value)\n        m_flags |= lldb::eTypeOptionNonCacheable;\n      else\n        m_flags &= ~lldb::eTypeOptionNonCacheable;\n      return *this;\n    }\n\n    uint32_t GetValue() { return m_flags; }\n\n    void SetValue(uint32_t value) { m_flags = value; }\n\n  private:\n    uint32_t m_flags;\n  };\n\n  TypeFormatImpl(const Flags &flags = Flags());\n\n  typedef std::shared_ptr<TypeFormatImpl> SharedPointer;\n\n  virtual ~TypeFormatImpl();\n\n  bool Cascades() const { return m_flags.GetCascades(); }\n\n  bool SkipsPointers() const { return m_flags.GetSkipPointers(); }\n\n  bool SkipsReferences() const { return m_flags.GetSkipReferences(); }\n\n  bool NonCacheable() const { return m_flags.GetNonCacheable(); }\n\n  void SetCascades(bool value) { m_flags.SetCascades(value); }\n\n  void SetSkipsPointers(bool value) { m_flags.SetSkipPointers(value); }\n\n  void SetSkipsReferences(bool value) { m_flags.SetSkipReferences(value); }\n\n  void SetNonCacheable(bool value) { m_flags.SetNonCacheable(value); }\n\n  uint32_t GetOptions() { return m_flags.GetValue(); }\n\n  void SetOptions(uint32_t value) { m_flags.SetValue(value); }\n\n  uint32_t &GetRevision() { return m_my_revision; }\n\n  enum class Type { eTypeUnknown, eTypeFormat, eTypeEnum };\n\n  virtual Type GetType() { return Type::eTypeUnknown; }\n\n  // we are using a ValueObject* instead of a ValueObjectSP because we do not\n  // need to hold on to this for extended periods of time and we trust the\n  // ValueObject to stay around for as long as it is required for us to\n  // generate its value\n  virtual bool FormatObject(ValueObject *valobj, std::string &dest) const = 0;\n\n  virtual std::string GetDescription() = 0;\n\nprotected:\n  Flags m_flags;\n  uint32_t m_my_revision;\n\nprivate:\n  TypeFormatImpl(const TypeFormatImpl &) = delete;\n  const TypeFormatImpl &operator=(const TypeFormatImpl &) = delete;\n};\n\nclass TypeFormatImpl_Format : public TypeFormatImpl {\npublic:\n  TypeFormatImpl_Format(lldb::Format f = lldb::eFormatInvalid,\n                        const TypeFormatImpl::Flags &flags = Flags());\n\n  typedef std::shared_ptr<TypeFormatImpl_Format> SharedPointer;\n\n  ~TypeFormatImpl_Format() override;\n\n  lldb::Format GetFormat() const { return m_format; }\n\n  void SetFormat(lldb::Format fmt) { m_format = fmt; }\n\n  TypeFormatImpl::Type GetType() override {\n    return TypeFormatImpl::Type::eTypeFormat;\n  }\n\n  bool FormatObject(ValueObject *valobj, std::string &dest) const override;\n\n  std::string GetDescription() override;\n\nprotected:\n  lldb::Format m_format;\n\nprivate:\n  TypeFormatImpl_Format(const TypeFormatImpl_Format &) = delete;\n  const TypeFormatImpl_Format &\n  operator=(const TypeFormatImpl_Format &) = delete;\n};\n\nclass TypeFormatImpl_EnumType : public TypeFormatImpl {\npublic:\n  TypeFormatImpl_EnumType(ConstString type_name = ConstString(\"\"),\n                          const TypeFormatImpl::Flags &flags = Flags());\n\n  typedef std::shared_ptr<TypeFormatImpl_EnumType> SharedPointer;\n\n  ~TypeFormatImpl_EnumType() override;\n\n  ConstString GetTypeName() { return m_enum_type; }\n\n  void SetTypeName(ConstString enum_type) { m_enum_type = enum_type; }\n\n  TypeFormatImpl::Type GetType() override {\n    return TypeFormatImpl::Type::eTypeEnum;\n  }\n\n  bool FormatObject(ValueObject *valobj, std::string &dest) const override;\n\n  std::string GetDescription() override;\n\nprotected:\n  ConstString m_enum_type;\n  mutable std::unordered_map<void *, CompilerType> m_types;\n\nprivate:\n  TypeFormatImpl_EnumType(const TypeFormatImpl_EnumType &) = delete;\n  const TypeFormatImpl_EnumType &\n  operator=(const TypeFormatImpl_EnumType &) = delete;\n};\n} // namespace lldb_private\n\n#endif // LLDB_DATAFORMATTERS_TYPEFORMAT_H\n"}, "16": {"id": 16, "path": "/home/vsts/work/1/llvm-project/lldb/include/lldb/DataFormatters/TypeSynthetic.h", "content": "//===-- TypeSynthetic.h -----------------------------------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLDB_DATAFORMATTERS_TYPESYNTHETIC_H\n#define LLDB_DATAFORMATTERS_TYPESYNTHETIC_H\n\n#include <stdint.h>\n\n#include <functional>\n#include <initializer_list>\n#include <memory>\n#include <string>\n#include <vector>\n\n#include \"lldb/lldb-enumerations.h\"\n#include \"lldb/lldb-public.h\"\n\n#include \"lldb/Core/ValueObject.h\"\n#include \"lldb/Utility/StructuredData.h\"\n\nnamespace lldb_private {\nclass SyntheticChildrenFrontEnd {\nprotected:\n  ValueObject &m_backend;\n\n  void SetValid(bool valid) { m_valid = valid; }\n\n  bool IsValid() { return m_valid; }\n\npublic:\n  SyntheticChildrenFrontEnd(ValueObject &backend)\n      : m_backend(backend), m_valid(true) {}\n\n  virtual ~SyntheticChildrenFrontEnd() = default;\n\n  virtual size_t CalculateNumChildren() = 0;\n\n  virtual size_t CalculateNumChildren(uint32_t max) {\n    auto count = CalculateNumChildren();\n    return count <= max ? count : max;\n  }\n\n  virtual lldb::ValueObjectSP GetChildAtIndex(size_t idx) = 0;\n\n  virtual size_t GetIndexOfChildWithName(ConstString name) = 0;\n\n  // this function is assumed to always succeed and it if fails, the front-end\n  // should know to deal with it in the correct way (most probably, by refusing\n  // to return any children) the return value of Update() should actually be\n  // interpreted as \"ValueObjectSyntheticFilter cache is good/bad\" if =true,\n  // ValueObjectSyntheticFilter is allowed to use the children it fetched\n  // previously and cached if =false, ValueObjectSyntheticFilter must throw\n  // away its cache, and query again for children\n  virtual bool Update() = 0;\n\n  // if this function returns false, then CalculateNumChildren() MUST return 0\n  // since UI frontends might validly decide not to inquire for children given\n  // a false return value from this call if it returns true, then\n  // CalculateNumChildren() can return any number >= 0 (0 being valid) it\n  // should if at all possible be more efficient than CalculateNumChildren()\n  virtual bool MightHaveChildren() = 0;\n\n  // if this function returns a non-null ValueObject, then the returned\n  // ValueObject will stand for this ValueObject whenever a \"value\" request is\n  // made to this ValueObject\n  virtual lldb::ValueObjectSP GetSyntheticValue() { return nullptr; }\n\n  // if this function returns a non-empty ConstString, then clients are\n  // expected to use the return as the name of the type of this ValueObject for\n  // display purposes\n  virtual ConstString GetSyntheticTypeName() { return ConstString(); }\n\n  typedef std::shared_ptr<SyntheticChildrenFrontEnd> SharedPointer;\n  typedef std::unique_ptr<SyntheticChildrenFrontEnd> AutoPointer;\n\nprotected:\n  lldb::ValueObjectSP\n  CreateValueObjectFromExpression(llvm::StringRef name,\n                                  llvm::StringRef expression,\n                                  const ExecutionContext &exe_ctx);\n\n  lldb::ValueObjectSP\n  CreateValueObjectFromAddress(llvm::StringRef name, uint64_t address,\n                               const ExecutionContext &exe_ctx,\n                               CompilerType type);\n\n  lldb::ValueObjectSP CreateValueObjectFromData(llvm::StringRef name,\n                                                const DataExtractor &data,\n                                                const ExecutionContext &exe_ctx,\n                                                CompilerType type);\n\nprivate:\n  bool m_valid;\n  SyntheticChildrenFrontEnd(const SyntheticChildrenFrontEnd &) = delete;\n  const SyntheticChildrenFrontEnd &\n  operator=(const SyntheticChildrenFrontEnd &) = delete;\n};\n\nclass SyntheticValueProviderFrontEnd : public SyntheticChildrenFrontEnd {\npublic:\n  SyntheticValueProviderFrontEnd(ValueObject &backend)\n      : SyntheticChildrenFrontEnd(backend) {}\n\n  ~SyntheticValueProviderFrontEnd() override = default;\n\n  size_t CalculateNumChildren() override { return 0; }\n\n  lldb::ValueObjectSP GetChildAtIndex(size_t idx) override { return nullptr; }\n\n  size_t GetIndexOfChildWithName(ConstString name) override {\n    return UINT32_MAX;\n  }\n\n  bool Update() override { return false; }\n\n  bool MightHaveChildren() override { return false; }\n\n  lldb::ValueObjectSP GetSyntheticValue() override = 0;\n\nprivate:\n  SyntheticValueProviderFrontEnd(const SyntheticValueProviderFrontEnd &) =\n      delete;\n  const SyntheticValueProviderFrontEnd &\n  operator=(const SyntheticValueProviderFrontEnd &) = delete;\n};\n\nclass SyntheticChildren {\npublic:\n  class Flags {\n  public:\n    Flags() : m_flags(lldb::eTypeOptionCascade) {}\n\n    Flags(const Flags &other) : m_flags(other.m_flags) {}\n\n    Flags(uint32_t value) : m_flags(value) {}\n\n    Flags &operator=(const Flags &rhs) {\n      if (&rhs != this)\n        m_flags = rhs.m_flags;\n\n      return *this;\n    }\n\n    Flags &operator=(const uint32_t &rhs) {\n      m_flags = rhs;\n      return *this;\n    }\n\n    Flags &Clear() {\n      m_flags = 0;\n      return *this;\n    }\n\n    bool GetCascades() const {\n      return (m_flags & lldb::eTypeOptionCascade) == lldb::eTypeOptionCascade;\n    }\n\n    Flags &SetCascades(bool value = true) {\n      if (value)\n        m_flags |= lldb::eTypeOptionCascade;\n      else\n        m_flags &= ~lldb::eTypeOptionCascade;\n      return *this;\n    }\n\n    bool GetSkipPointers() const {\n      return (m_flags & lldb::eTypeOptionSkipPointers) ==\n             lldb::eTypeOptionSkipPointers;\n    }\n\n    Flags &SetSkipPointers(bool value = true) {\n      if (value)\n        m_flags |= lldb::eTypeOptionSkipPointers;\n      else\n        m_flags &= ~lldb::eTypeOptionSkipPointers;\n      return *this;\n    }\n\n    bool GetSkipReferences() const {\n      return (m_flags & lldb::eTypeOptionSkipReferences) ==\n             lldb::eTypeOptionSkipReferences;\n    }\n\n    Flags &SetSkipReferences(bool value = true) {\n      if (value)\n        m_flags |= lldb::eTypeOptionSkipReferences;\n      else\n        m_flags &= ~lldb::eTypeOptionSkipReferences;\n      return *this;\n    }\n\n    bool GetNonCacheable() const {\n      return (m_flags & lldb::eTypeOptionNonCacheable) ==\n             lldb::eTypeOptionNonCacheable;\n    }\n\n    Flags &SetNonCacheable(bool value = true) {\n      if (value)\n        m_flags |= lldb::eTypeOptionNonCacheable;\n      else\n        m_flags &= ~lldb::eTypeOptionNonCacheable;\n      return *this;\n    }\n\n    bool GetFrontEndWantsDereference() const {\n      return (m_flags & lldb::eTypeOptionFrontEndWantsDereference) ==\n             lldb::eTypeOptionFrontEndWantsDereference;\n    }\n\n    Flags &SetFrontEndWantsDereference(bool value = true) {\n      if (value)\n        m_flags |= lldb::eTypeOptionFrontEndWantsDereference;\n      else\n        m_flags &= ~lldb::eTypeOptionFrontEndWantsDereference;\n      return *this;\n    }\n\n    uint32_t GetValue() { return m_flags; }\n\n    void SetValue(uint32_t value) { m_flags = value; }\n\n  private:\n    uint32_t m_flags;\n  };\n\n  SyntheticChildren(const Flags &flags) : m_flags(flags) {}\n\n  virtual ~SyntheticChildren() = default;\n\n  bool Cascades() const { return m_flags.GetCascades(); }\n\n  bool SkipsPointers() const { return m_flags.GetSkipPointers(); }\n\n  bool SkipsReferences() const { return m_flags.GetSkipReferences(); }\n\n  bool NonCacheable() const { return m_flags.GetNonCacheable(); }\n  \n  bool WantsDereference() const { return m_flags.GetFrontEndWantsDereference();} \n\n  void SetCascades(bool value) { m_flags.SetCascades(value); }\n\n  void SetSkipsPointers(bool value) { m_flags.SetSkipPointers(value); }\n\n  void SetSkipsReferences(bool value) { m_flags.SetSkipReferences(value); }\n\n  void SetNonCacheable(bool value) { m_flags.SetNonCacheable(value); }\n\n  uint32_t GetOptions() { return m_flags.GetValue(); }\n\n  void SetOptions(uint32_t value) { m_flags.SetValue(value); }\n\n  virtual bool IsScripted() = 0;\n\n  virtual std::string GetDescription() = 0;\n\n  virtual SyntheticChildrenFrontEnd::AutoPointer\n  GetFrontEnd(ValueObject &backend) = 0;\n\n  typedef std::shared_ptr<SyntheticChildren> SharedPointer;\n\n  uint32_t &GetRevision() { return m_my_revision; }\n\nprotected:\n  uint32_t m_my_revision;\n  Flags m_flags;\n\nprivate:\n  SyntheticChildren(const SyntheticChildren &) = delete;\n  const SyntheticChildren &operator=(const SyntheticChildren &) = delete;\n};\n\nclass TypeFilterImpl : public SyntheticChildren {\n  std::vector<std::string> m_expression_paths;\n\npublic:\n  TypeFilterImpl(const SyntheticChildren::Flags &flags)\n      : SyntheticChildren(flags), m_expression_paths() {}\n\n  TypeFilterImpl(const SyntheticChildren::Flags &flags,\n                 const std::initializer_list<const char *> items)\n      : SyntheticChildren(flags), m_expression_paths() {\n    for (auto path : items)\n      AddExpressionPath(path);\n  }\n\n  void AddExpressionPath(const char *path) {\n    AddExpressionPath(std::string(path));\n  }\n\n  void Clear() { m_expression_paths.clear(); }\n\n  size_t GetCount() const { return m_expression_paths.size(); }\n\n  const char *GetExpressionPathAtIndex(size_t i) const {\n    return m_expression_paths[i].c_str();\n  }\n\n  bool SetExpressionPathAtIndex(size_t i, const char *path) {\n    return SetExpressionPathAtIndex(i, std::string(path));\n  }\n\n  void AddExpressionPath(const std::string &path);\n\n  bool SetExpressionPathAtIndex(size_t i, const std::string &path);\n\n  bool IsScripted() override { return false; }\n\n  std::string GetDescription() override;\n\n  class FrontEnd : public SyntheticChildrenFrontEnd {\n  public:\n    FrontEnd(TypeFilterImpl *flt, ValueObject &backend)\n        : SyntheticChildrenFrontEnd(backend), filter(flt) {}\n\n    ~FrontEnd() override = default;\n\n    size_t CalculateNumChildren() override { return filter->GetCount(); }\n\n    lldb::ValueObjectSP GetChildAtIndex(size_t idx) override {\n      if (idx >= filter->GetCount())\n        return lldb::ValueObjectSP();\n      return m_backend.GetSyntheticExpressionPathChild(\n          filter->GetExpressionPathAtIndex(idx), true);\n    }\n\n    bool Update() override { return false; }\n\n    bool MightHaveChildren() override { return filter->GetCount() > 0; }\n\n    size_t GetIndexOfChildWithName(ConstString name) override;\n\n    typedef std::shared_ptr<SyntheticChildrenFrontEnd> SharedPointer;\n\n  private:\n    TypeFilterImpl *filter;\n\n    FrontEnd(const FrontEnd &) = delete;\n    const FrontEnd &operator=(const FrontEnd &) = delete;\n  };\n\n  SyntheticChildrenFrontEnd::AutoPointer\n  GetFrontEnd(ValueObject &backend) override {\n    return SyntheticChildrenFrontEnd::AutoPointer(new FrontEnd(this, backend));\n  }\n\n  typedef std::shared_ptr<TypeFilterImpl> SharedPointer;\n\nprivate:\n  TypeFilterImpl(const TypeFilterImpl &) = delete;\n  const TypeFilterImpl &operator=(const TypeFilterImpl &) = delete;\n};\n\nclass CXXSyntheticChildren : public SyntheticChildren {\npublic:\n  typedef std::function<SyntheticChildrenFrontEnd *(CXXSyntheticChildren *,\n                                                    lldb::ValueObjectSP)>\n      CreateFrontEndCallback;\n  CXXSyntheticChildren(const SyntheticChildren::Flags &flags,\n                       const char *description, CreateFrontEndCallback callback)\n      : SyntheticChildren(flags), m_create_callback(std::move(callback)),\n        m_description(description ? description : \"\") {}\n\n  bool IsScripted() override { return false; }\n\n  std::string GetDescription() override;\n\n  SyntheticChildrenFrontEnd::AutoPointer\n  GetFrontEnd(ValueObject &backend) override {\n    return SyntheticChildrenFrontEnd::AutoPointer(\n        m_create_callback(this, backend.GetSP()));\n  }\n\nprotected:\n  CreateFrontEndCallback m_create_callback;\n  std::string m_description;\n\nprivate:\n  CXXSyntheticChildren(const CXXSyntheticChildren &) = delete;\n  const CXXSyntheticChildren &operator=(const CXXSyntheticChildren &) = delete;\n};\n\nclass ScriptedSyntheticChildren : public SyntheticChildren {\n  std::string m_python_class;\n  std::string m_python_code;\n\npublic:\n  ScriptedSyntheticChildren(const SyntheticChildren::Flags &flags,\n                            const char *pclass, const char *pcode = nullptr)\n      : SyntheticChildren(flags), m_python_class(), m_python_code() {\n    if (pclass)\n      m_python_class = pclass;\n    if (pcode)\n      m_python_code = pcode;\n  }\n\n  const char *GetPythonClassName() { return m_python_class.c_str(); }\n\n  const char *GetPythonCode() { return m_python_code.c_str(); }\n\n  void SetPythonClassName(const char *fname) {\n    m_python_class.assign(fname);\n    m_python_code.clear();\n  }\n\n  void SetPythonCode(const char *script) { m_python_code.assign(script); }\n\n  std::string GetDescription() override;\n\n  bool IsScripted() override { return true; }\n\n  class FrontEnd : public SyntheticChildrenFrontEnd {\n  public:\n    FrontEnd(std::string pclass, ValueObject &backend);\n\n    ~FrontEnd() override;\n\n    bool IsValid();\n\n    size_t CalculateNumChildren() override;\n\n    size_t CalculateNumChildren(uint32_t max) override;\n\n    lldb::ValueObjectSP GetChildAtIndex(size_t idx) override;\n\n    bool Update() override;\n\n    bool MightHaveChildren() override;\n\n    size_t GetIndexOfChildWithName(ConstString name) override;\n\n    lldb::ValueObjectSP GetSyntheticValue() override;\n\n    ConstString GetSyntheticTypeName() override;\n\n    typedef std::shared_ptr<SyntheticChildrenFrontEnd> SharedPointer;\n\n  private:\n    std::string m_python_class;\n    StructuredData::ObjectSP m_wrapper_sp;\n    ScriptInterpreter *m_interpreter;\n\n    FrontEnd(const FrontEnd &) = delete;\n    const FrontEnd &operator=(const FrontEnd &) = delete;\n  };\n\n  SyntheticChildrenFrontEnd::AutoPointer\n  GetFrontEnd(ValueObject &backend) override {\n    auto synth_ptr = SyntheticChildrenFrontEnd::AutoPointer(\n        new FrontEnd(m_python_class, backend));\n    if (synth_ptr && ((FrontEnd *)synth_ptr.get())->IsValid())\n      return synth_ptr;\n    return nullptr;\n  }\n\nprivate:\n  ScriptedSyntheticChildren(const ScriptedSyntheticChildren &) = delete;\n  const ScriptedSyntheticChildren &\n  operator=(const ScriptedSyntheticChildren &) = delete;\n};\n} // namespace lldb_private\n\n#endif // LLDB_DATAFORMATTERS_TYPESYNTHETIC_H\n"}, "17": {"id": 17, "path": "/home/vsts/work/1/llvm-project/lldb/include/lldb/Host/File.h", "content": "//===-- File.h --------------------------------------------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLDB_HOST_FILE_H\n#define LLDB_HOST_FILE_H\n\n#include \"lldb/Host/PosixApi.h\"\n#include \"lldb/Utility/IOObject.h\"\n#include \"lldb/Utility/Status.h\"\n#include \"lldb/lldb-private.h\"\n#include \"llvm/ADT/BitmaskEnum.h\"\n\n#include <mutex>\n#include <stdarg.h>\n#include <stdio.h>\n#include <sys/types.h>\n\nnamespace lldb_private {\n\nLLVM_ENABLE_BITMASK_ENUMS_IN_NAMESPACE();\n\n/// \\class File File.h \"lldb/Host/File.h\"\n/// An abstract base class for files.\n///\n/// Files will often be NativeFiles, which provides a wrapper\n/// around host OS file functionality.   But it\n/// is also possible to subclass file to provide objects that have file\n/// or stream functionality but are not backed by any host OS file.\nclass File : public IOObject {\npublic:\n  static int kInvalidDescriptor;\n  static FILE *kInvalidStream;\n\n  // NB this enum is used in the lldb platform gdb-remote packet\n  // vFile:open: and existing values cannot be modified.\n  //\n  // FIXME\n  // These values do not match the values used by GDB\n  // * https://sourceware.org/gdb/onlinedocs/gdb/Open-Flags.html#Open-Flags\n  // * rdar://problem/46788934\n  enum OpenOptions : uint32_t {\n    eOpenOptionRead = (1u << 0),  // Open file for reading\n    eOpenOptionWrite = (1u << 1), // Open file for writing\n    eOpenOptionAppend =\n        (1u << 2), // Don't truncate file when opening, append to end of file\n    eOpenOptionTruncate = (1u << 3),    // Truncate file when opening\n    eOpenOptionNonBlocking = (1u << 4), // File reads\n    eOpenOptionCanCreate = (1u << 5),   // Create file if doesn't already exist\n    eOpenOptionCanCreateNewOnly =\n        (1u << 6), // Can create file only if it doesn't already exist\n    eOpenOptionDontFollowSymlinks = (1u << 7),\n    eOpenOptionCloseOnExec =\n        (1u << 8), // Close the file when executing a new process\n    LLVM_MARK_AS_BITMASK_ENUM(/* largest_value= */ eOpenOptionCloseOnExec)\n  };\n\n  static mode_t ConvertOpenOptionsForPOSIXOpen(OpenOptions open_options);\n  static llvm::Expected<OpenOptions> GetOptionsFromMode(llvm::StringRef mode);\n  static bool DescriptorIsValid(int descriptor) { return descriptor >= 0; };\n  static llvm::Expected<const char *>\n  GetStreamOpenModeFromOptions(OpenOptions options);\n\n  File()\n      : IOObject(eFDTypeFile), m_is_interactive(eLazyBoolCalculate),\n        m_is_real_terminal(eLazyBoolCalculate),\n        m_supports_colors(eLazyBoolCalculate){};\n\n  /// Read bytes from a file from the current file position into buf.\n  ///\n  /// NOTE: This function is NOT thread safe. Use the read function\n  /// that takes an \"off_t &offset\" to ensure correct operation in multi-\n  /// threaded environments.\n  ///\n  /// \\param[in,out] num_bytes\n  ///    Pass in the size of buf.  Read will pass out the number\n  ///    of bytes read.   Zero bytes read with no error indicates\n  ///    EOF.\n  ///\n  /// \\return\n  ///    success, ENOTSUP, or another error.\n  Status Read(void *buf, size_t &num_bytes) override;\n\n  /// Write bytes from buf to a file at the current file position.\n  ///\n  /// NOTE: This function is NOT thread safe. Use the write function\n  /// that takes an \"off_t &offset\" to ensure correct operation in multi-\n  /// threaded environments.\n  ///\n  /// \\param[in,out] num_bytes\n  ///    Pass in the size of buf.  Write will pass out the number\n  ///    of bytes written.   Write will attempt write the full number\n  ///    of bytes and will not return early except on error.\n  ///\n  /// \\return\n  ///    success, ENOTSUP, or another error.\n  Status Write(const void *buf, size_t &num_bytes) override;\n\n  /// IsValid\n  ///\n  /// \\return\n  ///    true iff the file is valid.\n  bool IsValid() const override;\n\n  /// Flush any buffers and release any resources owned by the file.\n  /// After Close() the file will be invalid.\n  ///\n  /// \\return\n  ///     success or an error.\n  Status Close() override;\n\n  /// Get a handle that can be used for OS polling interfaces, such\n  /// as WaitForMultipleObjects, select, or epoll.   This may return\n  /// IOObject::kInvalidHandleValue if none is available.   This will\n  /// generally be the same as the file descriptor, this function\n  /// is not interchangeable with GetDescriptor().   A WaitableHandle\n  /// must only be used for polling, not actual I/O.\n  ///\n  /// \\return\n  ///     a valid handle or IOObject::kInvalidHandleValue\n  WaitableHandle GetWaitableHandle() override;\n\n  /// Get the file specification for this file, if possible.\n  ///\n  /// \\param[out] file_spec\n  ///     the file specification.\n  /// \\return\n  ///     ENOTSUP, success, or another error.\n  virtual Status GetFileSpec(FileSpec &file_spec) const;\n\n  /// Get underlying OS file descriptor for this file, or kInvalidDescriptor.\n  /// If the descriptor is valid, then it may be used directly for I/O\n  /// However, the File may also perform it's own buffering, so avoid using\n  /// this if it is not necessary, or use Flush() appropriately.\n  ///\n  /// \\return\n  ///    a valid file descriptor for this file or kInvalidDescriptor\n  virtual int GetDescriptor() const;\n\n  /// Get the underlying libc stream for this file, or NULL.\n  ///\n  /// Not all valid files will have a FILE* stream.   This should only be\n  /// used if absolutely necessary, such as to interact with 3rd party\n  /// libraries that need FILE* streams.\n  ///\n  /// \\return\n  ///    a valid stream or NULL;\n  virtual FILE *GetStream();\n\n  /// Seek to an offset relative to the beginning of the file.\n  ///\n  /// NOTE: This function is NOT thread safe, other threads that\n  /// access this object might also change the current file position. For\n  /// thread safe reads and writes see the following functions: @see\n  /// File::Read (void *, size_t, off_t &) \\see File::Write (const void *,\n  /// size_t, off_t &)\n  ///\n  /// \\param[in] offset\n  ///     The offset to seek to within the file relative to the\n  ///     beginning of the file.\n  ///\n  /// \\param[in] error_ptr\n  ///     A pointer to a lldb_private::Status object that will be\n  ///     filled in if non-nullptr.\n  ///\n  /// \\return\n  ///     The resulting seek offset, or -1 on error.\n  virtual off_t SeekFromStart(off_t offset, Status *error_ptr = nullptr);\n\n  /// Seek to an offset relative to the current file position.\n  ///\n  /// NOTE: This function is NOT thread safe, other threads that\n  /// access this object might also change the current file position. For\n  /// thread safe reads and writes see the following functions: @see\n  /// File::Read (void *, size_t, off_t &) \\see File::Write (const void *,\n  /// size_t, off_t &)\n  ///\n  /// \\param[in] offset\n  ///     The offset to seek to within the file relative to the\n  ///     current file position.\n  ///\n  /// \\param[in] error_ptr\n  ///     A pointer to a lldb_private::Status object that will be\n  ///     filled in if non-nullptr.\n  ///\n  /// \\return\n  ///     The resulting seek offset, or -1 on error.\n  virtual off_t SeekFromCurrent(off_t offset, Status *error_ptr = nullptr);\n\n  /// Seek to an offset relative to the end of the file.\n  ///\n  /// NOTE: This function is NOT thread safe, other threads that\n  /// access this object might also change the current file position. For\n  /// thread safe reads and writes see the following functions: @see\n  /// File::Read (void *, size_t, off_t &) \\see File::Write (const void *,\n  /// size_t, off_t &)\n  ///\n  /// \\param[in,out] offset\n  ///     The offset to seek to within the file relative to the\n  ///     end of the file which gets filled in with the resulting\n  ///     absolute file offset.\n  ///\n  /// \\param[in] error_ptr\n  ///     A pointer to a lldb_private::Status object that will be\n  ///     filled in if non-nullptr.\n  ///\n  /// \\return\n  ///     The resulting seek offset, or -1 on error.\n  virtual off_t SeekFromEnd(off_t offset, Status *error_ptr = nullptr);\n\n  /// Read bytes from a file from the specified file offset.\n  ///\n  /// NOTE: This function is thread safe in that clients manager their\n  /// own file position markers and reads on other threads won't mess up the\n  /// current read.\n  ///\n  /// \\param[in] dst\n  ///     A buffer where to put the bytes that are read.\n  ///\n  /// \\param[in,out] num_bytes\n  ///     The number of bytes to read form the current file position\n  ///     which gets modified with the number of bytes that were read.\n  ///\n  /// \\param[in,out] offset\n  ///     The offset within the file from which to read \\a num_bytes\n  ///     bytes. This offset gets incremented by the number of bytes\n  ///     that were read.\n  ///\n  /// \\return\n  ///     An error object that indicates success or the reason for\n  ///     failure.\n  virtual Status Read(void *dst, size_t &num_bytes, off_t &offset);\n\n  /// Write bytes to a file at the specified file offset.\n  ///\n  /// NOTE: This function is thread safe in that clients manager their\n  /// own file position markers, though clients will need to implement their\n  /// own locking externally to avoid multiple people writing to the file at\n  /// the same time.\n  ///\n  /// \\param[in] src\n  ///     A buffer containing the bytes to write.\n  ///\n  /// \\param[in,out] num_bytes\n  ///     The number of bytes to write to the file at offset \\a offset.\n  ///     \\a num_bytes gets modified with the number of bytes that\n  ///     were read.\n  ///\n  /// \\param[in,out] offset\n  ///     The offset within the file at which to write \\a num_bytes\n  ///     bytes. This offset gets incremented by the number of bytes\n  ///     that were written.\n  ///\n  /// \\return\n  ///     An error object that indicates success or the reason for\n  ///     failure.\n  virtual Status Write(const void *src, size_t &num_bytes, off_t &offset);\n\n  /// Flush the current stream\n  ///\n  /// \\return\n  ///     An error object that indicates success or the reason for\n  ///     failure.\n  virtual Status Flush();\n\n  /// Sync to disk.\n  ///\n  /// \\return\n  ///     An error object that indicates success or the reason for\n  ///     failure.\n  virtual Status Sync();\n\n  /// Output printf formatted output to the stream.\n  ///\n  /// NOTE: this is not virtual, because it just calls the va_list\n  /// version of the function.\n  ///\n  /// Print some formatted output to the stream.\n  ///\n  /// \\param[in] format\n  ///     A printf style format string.\n  ///\n  /// \\param[in] ...\n  ///     Variable arguments that are needed for the printf style\n  ///     format string \\a format.\n  size_t Printf(const char *format, ...) __attribute__((format(printf, 2, 3)));\n\n  /// Output printf formatted output to the stream.\n  ///\n  /// Print some formatted output to the stream.\n  ///\n  /// \\param[in] format\n  ///     A printf style format string.\n  ///\n  /// \\param[in] args\n  ///     Variable arguments that are needed for the printf style\n  ///     format string \\a format.\n  virtual size_t PrintfVarArg(const char *format, va_list args);\n\n  /// Return the OpenOptions for this file.\n  ///\n  /// Some options like eOpenOptionDontFollowSymlinks only make\n  /// sense when a file is being opened (or not at all)\n  /// and may not be preserved for this method.  But any valid\n  /// File should return either or both of eOpenOptionRead and\n  /// eOpenOptionWrite here.\n  ///\n  /// \\return\n  ///    OpenOptions flags for this file, or an error.\n  virtual llvm::Expected<OpenOptions> GetOptions() const;\n\n  llvm::Expected<const char *> GetOpenMode() const {\n    auto opts = GetOptions();\n    if (!opts)\n      return opts.takeError();\n    return GetStreamOpenModeFromOptions(opts.get());\n  }\n\n  /// Get the permissions for a this file.\n  ///\n  /// \\return\n  ///     Bits logical OR'ed together from the permission bits defined\n  ///     in lldb_private::File::Permissions.\n  uint32_t GetPermissions(Status &error) const;\n\n  /// Return true if this file is interactive.\n  ///\n  /// \\return\n  ///     True if this file is a terminal (tty or pty), false\n  ///     otherwise.\n  bool GetIsInteractive();\n\n  /// Return true if this file from a real terminal.\n  ///\n  /// Just knowing a file is a interactive isn't enough, we also need to know\n  /// if the terminal has a width and height so we can do cursor movement and\n  /// other terminal manipulations by sending escape sequences.\n  ///\n  /// \\return\n  ///     True if this file is a terminal (tty, not a pty) that has\n  ///     a non-zero width and height, false otherwise.\n  bool GetIsRealTerminal();\n\n  /// Return true if this file is a terminal which supports colors.\n  ///\n  /// \\return\n  ///    True iff this is a terminal and it supports colors.\n  bool GetIsTerminalWithColors();\n\n  operator bool() const { return IsValid(); };\n\n  bool operator!() const { return !IsValid(); };\n\n  static char ID;\n  virtual bool isA(const void *classID) const { return classID == &ID; }\n  static bool classof(const File *file) { return file->isA(&ID); }\n\nprotected:\n  LazyBool m_is_interactive;\n  LazyBool m_is_real_terminal;\n  LazyBool m_supports_colors;\n\n  void CalculateInteractiveAndTerminal();\n\nprivate:\n  File(const File &) = delete;\n  const File &operator=(const File &) = delete;\n};\n\nclass NativeFile : public File {\npublic:\n  NativeFile()\n      : m_descriptor(kInvalidDescriptor), m_own_descriptor(false),\n        m_stream(kInvalidStream), m_options(), m_own_stream(false) {}\n\n  NativeFile(FILE *fh, bool transfer_ownership)\n      : m_descriptor(kInvalidDescriptor), m_own_descriptor(false), m_stream(fh),\n        m_options(), m_own_stream(transfer_ownership) {}\n\n  NativeFile(int fd, OpenOptions options, bool transfer_ownership)\n      : m_descriptor(fd), m_own_descriptor(transfer_ownership),\n        m_stream(kInvalidStream), m_options(options), m_own_stream(false) {}\n\n  ~NativeFile() override { Close(); }\n\n  bool IsValid() const override {\n    return DescriptorIsValid() || StreamIsValid();\n  }\n\n  Status Read(void *buf, size_t &num_bytes) override;\n  Status Write(const void *buf, size_t &num_bytes) override;\n  Status Close() override;\n  WaitableHandle GetWaitableHandle() override;\n  Status GetFileSpec(FileSpec &file_spec) const override;\n  int GetDescriptor() const override;\n  FILE *GetStream() override;\n  off_t SeekFromStart(off_t offset, Status *error_ptr = nullptr) override;\n  off_t SeekFromCurrent(off_t offset, Status *error_ptr = nullptr) override;\n  off_t SeekFromEnd(off_t offset, Status *error_ptr = nullptr) override;\n  Status Read(void *dst, size_t &num_bytes, off_t &offset) override;\n  Status Write(const void *src, size_t &num_bytes, off_t &offset) override;\n  Status Flush() override;\n  Status Sync() override;\n  size_t PrintfVarArg(const char *format, va_list args) override;\n  llvm::Expected<OpenOptions> GetOptions() const override;\n\n  static char ID;\n  virtual bool isA(const void *classID) const override {\n    return classID == &ID || File::isA(classID);\n  }\n  static bool classof(const File *file) { return file->isA(&ID); }\n\nprotected:\n  bool DescriptorIsValid() const {\n    return File::DescriptorIsValid(m_descriptor);\n  }\n  bool StreamIsValid() const { return m_stream != kInvalidStream; }\n\n  // Member variables\n  int m_descriptor;\n  bool m_own_descriptor;\n  FILE *m_stream;\n  OpenOptions m_options;\n  bool m_own_stream;\n  std::mutex offset_access_mutex;\n\nprivate:\n  NativeFile(const NativeFile &) = delete;\n  const NativeFile &operator=(const NativeFile &) = delete;\n};\n\n} // namespace lldb_private\n\n#endif // LLDB_HOST_FILE_H\n"}, "18": {"id": 18, "path": "/home/vsts/work/1/llvm-project/lldb/include/lldb/Host/FileAction.h", "content": "//===-- FileAction.h --------------------------------------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLDB_HOST_FILEACTION_H\n#define LLDB_HOST_FILEACTION_H\n\n#include \"lldb/Utility/FileSpec.h\"\n#include <string>\n\nnamespace lldb_private {\n\nclass FileAction {\npublic:\n  enum Action {\n    eFileActionNone,\n    eFileActionClose,\n    eFileActionDuplicate,\n    eFileActionOpen\n  };\n\n  FileAction();\n\n  void Clear();\n\n  bool Close(int fd);\n\n  bool Duplicate(int fd, int dup_fd);\n\n  bool Open(int fd, const FileSpec &file_spec, bool read, bool write);\n\n  int GetFD() const { return m_fd; }\n\n  Action GetAction() const { return m_action; }\n\n  int GetActionArgument() const { return m_arg; }\n\n  llvm::StringRef GetPath() const;\n\n  const FileSpec &GetFileSpec() const;\n\n  void Dump(Stream &stream) const;\n\nprotected:\n  Action m_action; // The action for this file\n  int m_fd;        // An existing file descriptor\n  int m_arg; // oflag for eFileActionOpen*, dup_fd for eFileActionDuplicate\n  FileSpec\n      m_file_spec; // A file spec to use for opening after fork or posix_spawn\n};\n\n} // namespace lldb_private\n\n#endif\n"}, "19": {"id": 19, "path": "/home/vsts/work/1/llvm-project/lldb/include/lldb/Host/Host.h", "content": "//===-- Host.h --------------------------------------------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLDB_HOST_HOST_H\n#define LLDB_HOST_HOST_H\n\n#include \"lldb/Host/File.h\"\n#include \"lldb/Host/HostThread.h\"\n#include \"lldb/Utility/Environment.h\"\n#include \"lldb/Utility/FileSpec.h\"\n#include \"lldb/Utility/Timeout.h\"\n#include \"lldb/lldb-private-forward.h\"\n#include \"lldb/lldb-private.h\"\n#include <cerrno>\n#include <map>\n#include <stdarg.h>\n#include <string>\n#include <type_traits>\n\nnamespace lldb_private {\n\nclass FileAction;\nclass ProcessLaunchInfo;\nclass ProcessInstanceInfo;\nclass ProcessInstanceInfoMatch;\ntypedef std::vector<ProcessInstanceInfo> ProcessInstanceInfoList;\n\n// Exit Type for inferior processes\nstruct WaitStatus {\n  enum Type : uint8_t {\n    Exit,   // The status represents the return code from normal\n            // program exit (i.e. WIFEXITED() was true)\n    Signal, // The status represents the signal number that caused\n            // the program to exit (i.e. WIFSIGNALED() was true)\n    Stop,   // The status represents the signal number that caused the\n            // program to stop (i.e. WIFSTOPPED() was true)\n  };\n\n  Type type;\n  uint8_t status;\n\n  WaitStatus(Type type, uint8_t status) : type(type), status(status) {}\n\n  static WaitStatus Decode(int wstatus);\n};\n\ninline bool operator==(WaitStatus a, WaitStatus b) {\n  return a.type == b.type && a.status == b.status;\n}\n\ninline bool operator!=(WaitStatus a, WaitStatus b) { return !(a == b); }\n\n/// \\class Host Host.h \"lldb/Host/Host.h\"\n/// A class that provides host computer information.\n///\n/// Host is a class that answers information about the host operating system.\nclass Host {\npublic:\n  typedef std::function<bool(\n      lldb::pid_t pid, bool exited,\n      int signal,  // Zero for no signal\n      int status)> // Exit value of process if signal is zero\n      MonitorChildProcessCallback;\n\n  /// Start monitoring a child process.\n  ///\n  /// Allows easy monitoring of child processes. \\a callback will be called\n  /// when the child process exits or if it gets a signal. The callback will\n  /// only be called with signals if \\a monitor_signals is \\b true. \\a\n  /// callback will usually be called from another thread so the callback\n  /// function must be thread safe.\n  ///\n  /// When the callback gets called, the return value indicates if monitoring\n  /// should stop. If \\b true is returned from \\a callback the information\n  /// will be removed. If \\b false is returned then monitoring will continue.\n  /// If the child process exits, the monitoring will automatically stop after\n  /// the callback returned regardless of the callback return value.\n  ///\n  /// \\param[in] callback\n  ///     A function callback to call when a child receives a signal\n  ///     (if \\a monitor_signals is true) or a child exits.\n  ///\n  /// \\param[in] pid\n  ///     The process ID of a child process to monitor, -1 for all\n  ///     processes.\n  ///\n  /// \\param[in] monitor_signals\n  ///     If \\b true the callback will get called when the child\n  ///     process gets a signal. If \\b false, the callback will only\n  ///     get called if the child process exits.\n  ///\n  /// \\return\n  ///     A thread handle that can be used to cancel the thread that\n  ///     was spawned to monitor \\a pid.\n  ///\n  /// \\see static void Host::StopMonitoringChildProcess (uint32_t)\n  static llvm::Expected<HostThread>\n  StartMonitoringChildProcess(const MonitorChildProcessCallback &callback,\n                              lldb::pid_t pid, bool monitor_signals);\n\n  enum SystemLogType { eSystemLogWarning, eSystemLogError };\n\n  static void SystemLog(SystemLogType type, const char *format, ...)\n      __attribute__((format(printf, 2, 3)));\n\n  static void SystemLog(SystemLogType type, const char *format, va_list args);\n\n  /// Get the process ID for the calling process.\n  ///\n  /// \\return\n  ///     The process ID for the current process.\n  static lldb::pid_t GetCurrentProcessID();\n\n  static void Kill(lldb::pid_t pid, int signo);\n\n  /// Get the thread token (the one returned by ThreadCreate when the thread\n  /// was created) for the calling thread in the current process.\n  ///\n  /// \\return\n  ///     The thread token for the calling thread in the current process.\n  static lldb::thread_t GetCurrentThread();\n\n  static const char *GetSignalAsCString(int signo);\n\n  /// Given an address in the current process (the process that is running the\n  /// LLDB code), return the name of the module that it comes from. This can\n  /// be useful when you need to know the path to the shared library that your\n  /// code is running in for loading resources that are relative to your\n  /// binary.\n  ///\n  /// \\param[in] host_addr\n  ///     The pointer to some code in the current process.\n  ///\n  /// \\return\n  ///     \\b A file spec with the module that contains \\a host_addr,\n  ///     which may be invalid if \\a host_addr doesn't fall into\n  ///     any valid module address range.\n  static FileSpec GetModuleFileSpecForHostAddress(const void *host_addr);\n\n  /// If you have an executable that is in a bundle and want to get back to\n  /// the bundle directory from the path itself, this function will change a\n  /// path to a file within a bundle to the bundle directory itself.\n  ///\n  /// \\param[in] file\n  ///     A file spec that might point to a file in a bundle.\n  ///\n  /// \\param[out] bundle_directory\n  ///     An object will be filled in with the bundle directory for\n  ///     the bundle when \\b true is returned. Otherwise \\a file is\n  ///     left untouched and \\b false is returned.\n  ///\n  /// \\return\n  ///     \\b true if \\a file was resolved in \\a bundle_directory,\n  ///     \\b false otherwise.\n  static bool GetBundleDirectory(const FileSpec &file,\n                                 FileSpec &bundle_directory);\n\n  /// When executable files may live within a directory, where the directory\n  /// represents an executable bundle (like the MacOSX app bundles), then\n  /// locate the executable within the containing bundle.\n  ///\n  /// \\param[in,out] file\n  ///     A file spec that currently points to the bundle that will\n  ///     be filled in with the executable path within the bundle\n  ///     if \\b true is returned. Otherwise \\a file is left untouched.\n  ///\n  /// \\return\n  ///     \\b true if \\a file was resolved, \\b false if this function\n  ///     was not able to resolve the path.\n  static bool ResolveExecutableInBundle(FileSpec &file);\n\n  static uint32_t FindProcesses(const ProcessInstanceInfoMatch &match_info,\n                                ProcessInstanceInfoList &proc_infos);\n\n  typedef std::map<lldb::pid_t, bool> TidMap;\n  typedef std::pair<lldb::pid_t, bool> TidPair;\n  static bool FindProcessThreads(const lldb::pid_t pid, TidMap &tids_to_attach);\n\n  static bool GetProcessInfo(lldb::pid_t pid, ProcessInstanceInfo &proc_info);\n\n  /// Launch the process specified in launch_info. The monitoring callback in\n  /// launch_info must be set, and it will be called when the process\n  /// terminates.\n  static Status LaunchProcess(ProcessLaunchInfo &launch_info);\n\n  /// Perform expansion of the command-line for this launch info This can\n  /// potentially involve wildcard expansion\n  /// environment variable replacement, and whatever other\n  /// argument magic the platform defines as part of its typical\n  /// user experience\n  static Status ShellExpandArguments(ProcessLaunchInfo &launch_info);\n\n  /// Run a shell command.\n  /// \\arg command  shouldn't be empty\n  /// \\arg working_dir Pass empty FileSpec to use the current working directory\n  /// \\arg status_ptr  Pass NULL if you don't want the process exit status\n  /// \\arg signo_ptr   Pass NULL if you don't want the signal that caused the\n  ///                  process to exit\n  /// \\arg command_output  Pass NULL if you don't want the command output\n  /// \\arg hide_stderr if this is false, redirect stderr to stdout\n  static Status RunShellCommand(llvm::StringRef command,\n                                const FileSpec &working_dir, int *status_ptr,\n                                int *signo_ptr, std::string *command_output,\n                                const Timeout<std::micro> &timeout,\n                                bool run_in_shell = true,\n                                bool hide_stderr = false);\n\n  /// Run a shell command.\n  /// \\arg shell  Pass an empty string if you want to use the default shell\n  /// interpreter \\arg command \\arg working_dir  Pass empty FileSpec to use the\n  /// current working directory \\arg status_ptr   Pass NULL if you don't want\n  /// the process exit status \\arg signo_ptr    Pass NULL if you don't want the\n  /// signal that caused\n  ///                   the process to exit\n  /// \\arg command_output  Pass NULL if you don't want the command output\n  /// \\arg hide_stderr  If this is \\b false, redirect stderr to stdout\n  static Status RunShellCommand(llvm::StringRef shell, llvm::StringRef command,\n                                const FileSpec &working_dir, int *status_ptr,\n                                int *signo_ptr, std::string *command_output,\n                                const Timeout<std::micro> &timeout,\n                                bool run_in_shell = true,\n                                bool hide_stderr = false);\n\n  /// Run a shell command.\n  /// \\arg working_dir Pass empty FileSpec to use the current working directory\n  /// \\arg status_ptr  Pass NULL if you don't want the process exit status\n  /// \\arg signo_ptr   Pass NULL if you don't want the signal that caused the\n  ///                  process to exit\n  /// \\arg command_output  Pass NULL if you don't want the command output\n  /// \\arg hide_stderr if this is false, redirect stderr to stdout\n  static Status RunShellCommand(const Args &args, const FileSpec &working_dir,\n                                int *status_ptr, int *signo_ptr,\n                                std::string *command_output,\n                                const Timeout<std::micro> &timeout,\n                                bool run_in_shell = true,\n                                bool hide_stderr = false);\n\n  /// Run a shell command.\n  /// \\arg shell            Pass an empty string if you want to use the default\n  /// shell interpreter \\arg command \\arg working_dir Pass empty FileSpec to use\n  /// the current working directory \\arg status_ptr    Pass NULL if you don't\n  /// want the process exit status \\arg signo_ptr     Pass NULL if you don't\n  /// want the signal that caused the\n  ///               process to exit\n  /// \\arg command_output  Pass NULL if you don't want the command output\n  /// \\arg hide_stderr If this is \\b false, redirect stderr to stdout\n  static Status RunShellCommand(llvm::StringRef shell, const Args &args,\n                                const FileSpec &working_dir, int *status_ptr,\n                                int *signo_ptr, std::string *command_output,\n                                const Timeout<std::micro> &timeout,\n                                bool run_in_shell = true,\n                                bool hide_stderr = false);\n\n  static bool OpenFileInExternalEditor(const FileSpec &file_spec,\n                                       uint32_t line_no);\n\n  static Environment GetEnvironment();\n\n  static std::unique_ptr<Connection>\n  CreateDefaultConnection(llvm::StringRef url);\n\nprotected:\n  static uint32_t FindProcessesImpl(const ProcessInstanceInfoMatch &match_info,\n                                    ProcessInstanceInfoList &proc_infos);\n};\n\n} // namespace lldb_private\n\nnamespace llvm {\ntemplate <> struct format_provider<lldb_private::WaitStatus> {\n  /// Options = \"\" gives a human readable description of the status Options =\n  /// \"g\" gives a gdb-remote protocol status (e.g., X09)\n  static void format(const lldb_private::WaitStatus &WS, raw_ostream &OS,\n                     llvm::StringRef Options);\n};\n} // namespace llvm\n\n#endif // LLDB_HOST_HOST_H\n"}, "20": {"id": 20, "path": "/home/vsts/work/1/llvm-project/lldb/include/lldb/Symbol/CompilerType.h", "content": "//===-- CompilerType.h ------------------------------------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLDB_SYMBOL_COMPILERTYPE_H\n#define LLDB_SYMBOL_COMPILERTYPE_H\n\n#include <functional>\n#include <string>\n#include <vector>\n\n#include \"lldb/lldb-private.h\"\n#include \"llvm/ADT/APSInt.h\"\n\nnamespace lldb_private {\n\nclass DataExtractor;\n\n/// Generic representation of a type in a programming language.\n///\n/// This class serves as an abstraction for a type inside one of the TypeSystems\n/// implemented by the language plugins. It does not have any actual logic in it\n/// but only stores an opaque pointer and a pointer to the TypeSystem that\n/// gives meaning to this opaque pointer. All methods of this class should call\n/// their respective method in the TypeSystem interface and pass the opaque\n/// pointer along.\n///\n/// \\see lldb_private::TypeSystem\nclass CompilerType {\npublic:\n  /// Creates a CompilerType with the given TypeSystem and opaque compiler type.\n  ///\n  /// This constructor should only be called from the respective TypeSystem\n  /// implementation.\n  ///\n  /// \\see lldb_private::TypeSystemClang::GetType(clang::QualType)\n  CompilerType(TypeSystem *type_system, lldb::opaque_compiler_type_t type)\n      : m_type(type), m_type_system(type_system) {\n    assert(Verify() && \"verification failed\");\n  }\n\n  CompilerType(const CompilerType &rhs)\n      : m_type(rhs.m_type), m_type_system(rhs.m_type_system) {}\n\n  CompilerType() = default;\n\n  /// Operators.\n  /// \\{\n  const CompilerType &operator=(const CompilerType &rhs) {\n    m_type = rhs.m_type;\n    m_type_system = rhs.m_type_system;\n    return *this;\n  }\n\n  bool operator<(const CompilerType &rhs) const {\n    if (m_type_system == rhs.m_type_system)\n      return m_type < rhs.m_type;\n    return m_type_system < rhs.m_type_system;\n  }\n  /// \\}\n\n  /// Tests.\n  /// \\{\n  explicit operator bool() const {\n    return m_type != nullptr && m_type_system != nullptr;\n  }\n\n  bool IsValid() const { return m_type != nullptr && m_type_system != nullptr; }\n\n  bool IsArrayType(CompilerType *element_type = nullptr,\n                   uint64_t *size = nullptr,\n                   bool *is_incomplete = nullptr) const;\n\n  bool IsVectorType(CompilerType *element_type = nullptr,\n                    uint64_t *size = nullptr) const;\n\n  bool IsArrayOfScalarType() const;\n\n  bool IsAggregateType() const;\n\n  bool IsAnonymousType() const;\n\n  bool IsScopedEnumerationType() const;\n\n  bool IsBeingDefined() const;\n\n  bool IsCharType() const;\n\n  bool IsCompleteType() const;\n\n  bool IsConst() const;\n\n  bool IsCStringType(uint32_t &length) const;\n\n  bool IsDefined() const;\n\n  bool IsFloatingPointType(uint32_t &count, bool &is_complex) const;\n\n  bool IsFunctionType() const;\n\n  uint32_t IsHomogeneousAggregate(CompilerType *base_type_ptr) const;\n\n  size_t GetNumberOfFunctionArguments() const;\n\n  CompilerType GetFunctionArgumentAtIndex(const size_t index) const;\n\n  bool IsVariadicFunctionType() const;\n\n  bool IsFunctionPointerType() const;\n\n  bool\n  IsBlockPointerType(CompilerType *function_pointer_type_ptr = nullptr) const;\n\n  bool IsIntegerType(bool &is_signed) const;\n\n  bool IsEnumerationType(bool &is_signed) const;\n\n  bool IsIntegerOrEnumerationType(bool &is_signed) const;\n\n  bool IsPolymorphicClass() const;\n\n  /// \\param target_type    Can pass nullptr.\n  bool IsPossibleDynamicType(CompilerType *target_type, bool check_cplusplus,\n                             bool check_objc) const;\n\n  bool IsPointerToScalarType() const;\n\n  bool IsRuntimeGeneratedType() const;\n\n  bool IsPointerType(CompilerType *pointee_type = nullptr) const;\n\n  bool IsPointerOrReferenceType(CompilerType *pointee_type = nullptr) const;\n\n  bool IsReferenceType(CompilerType *pointee_type = nullptr,\n                       bool *is_rvalue = nullptr) const;\n\n  bool ShouldTreatScalarValueAsAddress() const;\n\n  bool IsScalarType() const;\n\n  bool IsTypedefType() const;\n\n  bool IsVoidType() const;\n  /// \\}\n\n  /// Type Completion.\n  /// \\{\n  bool GetCompleteType() const;\n  /// \\}\n\n  /// AST related queries.\n  /// \\{\n  size_t GetPointerByteSize() const;\n  /// \\}\n\n  /// Accessors.\n  /// \\{\n  TypeSystem *GetTypeSystem() const { return m_type_system; }\n\n  ConstString GetTypeName() const;\n\n  ConstString GetDisplayTypeName() const;\n\n  uint32_t\n  GetTypeInfo(CompilerType *pointee_or_element_compiler_type = nullptr) const;\n\n  lldb::LanguageType GetMinimumLanguage();\n\n  lldb::opaque_compiler_type_t GetOpaqueQualType() const { return m_type; }\n\n  lldb::TypeClass GetTypeClass() const;\n\n  void SetCompilerType(TypeSystem *type_system,\n                       lldb::opaque_compiler_type_t type);\n\n  unsigned GetTypeQualifiers() const;\n  /// \\}\n\n  /// Creating related types.\n  /// \\{\n  CompilerType GetArrayElementType(ExecutionContextScope *exe_scope) const;\n\n  CompilerType GetArrayType(uint64_t size) const;\n\n  CompilerType GetCanonicalType() const;\n\n  CompilerType GetFullyUnqualifiedType() const;\n\n  CompilerType GetEnumerationIntegerType() const;\n\n  /// Returns -1 if this isn't a function of if the function doesn't\n  /// have a prototype Returns a value >= 0 if there is a prototype.\n  int GetFunctionArgumentCount() const;\n\n  CompilerType GetFunctionArgumentTypeAtIndex(size_t idx) const;\n\n  CompilerType GetFunctionReturnType() const;\n\n  size_t GetNumMemberFunctions() const;\n\n  TypeMemberFunctionImpl GetMemberFunctionAtIndex(size_t idx);\n\n  /// If this type is a reference to a type (L value or R value reference),\n  /// return a new type with the reference removed, else return the current type\n  /// itself.\n  CompilerType GetNonReferenceType() const;\n\n  /// If this type is a pointer type, return the type that the pointer points\n  /// to, else return an invalid type.\n  CompilerType GetPointeeType() const;\n\n  /// Return a new CompilerType that is a pointer to this type\n  CompilerType GetPointerType() const;\n\n  /// Return a new CompilerType that is a L value reference to this type if this\n  /// type is valid and the type system supports L value references, else return\n  /// an invalid type.\n  CompilerType GetLValueReferenceType() const;\n\n  /// Return a new CompilerType that is a R value reference to this type if this\n  /// type is valid and the type system supports R value references, else return\n  /// an invalid type.\n  CompilerType GetRValueReferenceType() const;\n\n  /// Return a new CompilerType adds a const modifier to this type if this type\n  /// is valid and the type system supports const modifiers, else return an\n  /// invalid type.\n  CompilerType AddConstModifier() const;\n\n  /// Return a new CompilerType adds a volatile modifier to this type if this\n  /// type is valid and the type system supports volatile modifiers, else return\n  /// an invalid type.\n  CompilerType AddVolatileModifier() const;\n\n  /// Return a new CompilerType that is the atomic type of this type. If this\n  /// type is not valid or the type system doesn't support atomic types, this\n  /// returns an invalid type.\n  CompilerType GetAtomicType() const;\n\n  /// Return a new CompilerType adds a restrict modifier to this type if this\n  /// type is valid and the type system supports restrict modifiers, else return\n  /// an invalid type.\n  CompilerType AddRestrictModifier() const;\n\n  /// Create a typedef to this type using \"name\" as the name of the typedef this\n  /// type is valid and the type system supports typedefs, else return an\n  /// invalid type.\n  /// \\param payload   The typesystem-specific \\p lldb::Type payload.\n  CompilerType CreateTypedef(const char *name,\n                             const CompilerDeclContext &decl_ctx,\n                             uint32_t payload) const;\n\n  /// If the current object represents a typedef type, get the underlying type\n  CompilerType GetTypedefedType() const;\n\n  /// Create related types using the current type's AST\n  CompilerType GetBasicTypeFromAST(lldb::BasicType basic_type) const;\n  /// \\}\n\n  /// Exploring the type.\n  /// \\{\n  struct IntegralTemplateArgument;\n\n  /// Return the size of the type in bytes.\n  llvm::Optional<uint64_t> GetByteSize(ExecutionContextScope *exe_scope) const;\n  /// Return the size of the type in bits.\n  llvm::Optional<uint64_t> GetBitSize(ExecutionContextScope *exe_scope) const;\n\n  lldb::Encoding GetEncoding(uint64_t &count) const;\n\n  lldb::Format GetFormat() const;\n\n  llvm::Optional<size_t>\n  GetTypeBitAlign(ExecutionContextScope *exe_scope) const;\n\n  uint32_t GetNumChildren(bool omit_empty_base_classes,\n                          const ExecutionContext *exe_ctx) const;\n\n  lldb::BasicType GetBasicTypeEnumeration() const;\n\n  static lldb::BasicType GetBasicTypeEnumeration(ConstString name);\n\n  /// If this type is an enumeration, iterate through all of its enumerators\n  /// using a callback. If the callback returns true, keep iterating, else abort\n  /// the iteration.\n  void ForEachEnumerator(\n      std::function<bool(const CompilerType &integer_type, ConstString name,\n                         const llvm::APSInt &value)> const &callback) const;\n\n  uint32_t GetNumFields() const;\n\n  CompilerType GetFieldAtIndex(size_t idx, std::string &name,\n                               uint64_t *bit_offset_ptr,\n                               uint32_t *bitfield_bit_size_ptr,\n                               bool *is_bitfield_ptr) const;\n\n  uint32_t GetNumDirectBaseClasses() const;\n\n  uint32_t GetNumVirtualBaseClasses() const;\n\n  CompilerType GetDirectBaseClassAtIndex(size_t idx,\n                                         uint32_t *bit_offset_ptr) const;\n\n  CompilerType GetVirtualBaseClassAtIndex(size_t idx,\n                                          uint32_t *bit_offset_ptr) const;\n\n  uint32_t GetIndexOfFieldWithName(const char *name,\n                                   CompilerType *field_compiler_type = nullptr,\n                                   uint64_t *bit_offset_ptr = nullptr,\n                                   uint32_t *bitfield_bit_size_ptr = nullptr,\n                                   bool *is_bitfield_ptr = nullptr) const;\n\n  CompilerType GetChildCompilerTypeAtIndex(\n      ExecutionContext *exe_ctx, size_t idx, bool transparent_pointers,\n      bool omit_empty_base_classes, bool ignore_array_bounds,\n      std::string &child_name, uint32_t &child_byte_size,\n      int32_t &child_byte_offset, uint32_t &child_bitfield_bit_size,\n      uint32_t &child_bitfield_bit_offset, bool &child_is_base_class,\n      bool &child_is_deref_of_parent, ValueObject *valobj,\n      uint64_t &language_flags) const;\n\n  /// Lookup a child given a name. This function will match base class names and\n  /// member member names in \"clang_type\" only, not descendants.\n  uint32_t GetIndexOfChildWithName(const char *name,\n                                   bool omit_empty_base_classes) const;\n\n  /// Lookup a child member given a name. This function will match member names\n  /// only and will descend into \"clang_type\" children in search for the first\n  /// member in this class, or any base class that matches \"name\".\n  /// TODO: Return all matches for a given name by returning a\n  /// vector<vector<uint32_t>>\n  /// so we catch all names that match a given child name, not just the first.\n  size_t\n  GetIndexOfChildMemberWithName(const char *name, bool omit_empty_base_classes,\n                                std::vector<uint32_t> &child_indexes) const;\n\n  size_t GetNumTemplateArguments() const;\n\n  lldb::TemplateArgumentKind GetTemplateArgumentKind(size_t idx) const;\n  CompilerType GetTypeTemplateArgument(size_t idx) const;\n\n  /// Returns the value of the template argument and its type.\n  llvm::Optional<IntegralTemplateArgument>\n  GetIntegralTemplateArgument(size_t idx) const;\n\n  CompilerType GetTypeForFormatters() const;\n\n  LazyBool ShouldPrintAsOneLiner(ValueObject *valobj) const;\n\n  bool IsMeaninglessWithoutDynamicResolution() const;\n  /// \\}\n\n  /// Dumping types.\n  /// \\{\n#ifndef NDEBUG\n  /// Convenience LLVM-style dump method for use in the debugger only.\n  /// Don't call this function from actual code.\n  LLVM_DUMP_METHOD void dump() const;\n#endif\n\n  void DumpValue(ExecutionContext *exe_ctx, Stream *s, lldb::Format format,\n                 const DataExtractor &data, lldb::offset_t data_offset,\n                 size_t data_byte_size, uint32_t bitfield_bit_size,\n                 uint32_t bitfield_bit_offset, bool show_types,\n                 bool show_summary, bool verbose, uint32_t depth);\n\n  bool DumpTypeValue(Stream *s, lldb::Format format, const DataExtractor &data,\n                     lldb::offset_t data_offset, size_t data_byte_size,\n                     uint32_t bitfield_bit_size, uint32_t bitfield_bit_offset,\n                     ExecutionContextScope *exe_scope);\n\n  void DumpSummary(ExecutionContext *exe_ctx, Stream *s,\n                   const DataExtractor &data, lldb::offset_t data_offset,\n                   size_t data_byte_size);\n\n  /// Dump to stdout.\n  void DumpTypeDescription(lldb::DescriptionLevel level =\n                           lldb::eDescriptionLevelFull) const;\n\n  /// Print a description of the type to a stream. The exact implementation\n  /// varies, but the expectation is that eDescriptionLevelFull returns a\n  /// source-like representation of the type, whereas eDescriptionLevelVerbose\n  /// does a dump of the underlying AST if applicable.\n  void DumpTypeDescription(Stream *s, lldb::DescriptionLevel level =\n                                          lldb::eDescriptionLevelFull) const;\n  /// \\}\n\n  bool GetValueAsScalar(const DataExtractor &data, lldb::offset_t data_offset,\n                        size_t data_byte_size, Scalar &value,\n                        ExecutionContextScope *exe_scope) const;\n  void Clear() {\n    m_type = nullptr;\n    m_type_system = nullptr;\n  }\n\nprivate:\n#ifndef NDEBUG\n  /// If the type is valid, ask the TypeSystem to verify the integrity\n  /// of the type to catch CompilerTypes that mix and match invalid\n  /// TypeSystem/Opaque type pairs.\n  bool Verify() const;\n#endif\n\n  lldb::opaque_compiler_type_t m_type = nullptr;\n  TypeSystem *m_type_system = nullptr;\n};\n\nbool operator==(const CompilerType &lhs, const CompilerType &rhs);\nbool operator!=(const CompilerType &lhs, const CompilerType &rhs);\n\nstruct CompilerType::IntegralTemplateArgument {\n  llvm::APSInt value;\n  CompilerType type;\n};\n\n} // namespace lldb_private\n\n#endif // LLDB_SYMBOL_COMPILERTYPE_H\n"}, "21": {"id": 21, "path": "/home/vsts/work/1/llvm-project/lldb/include/lldb/Symbol/LineEntry.h", "content": "//===-- LineEntry.h ---------------------------------------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLDB_SYMBOL_LINEENTRY_H\n#define LLDB_SYMBOL_LINEENTRY_H\n\n#include \"lldb/Core/AddressRange.h\"\n#include \"lldb/Utility/FileSpec.h\"\n#include \"lldb/lldb-private.h\"\n\nnamespace lldb_private {\n\n/// \\class LineEntry LineEntry.h \"lldb/Symbol/LineEntry.h\"\n/// A line table entry class.\nstruct LineEntry {\n  /// Default constructor.\n  ///\n  /// Initialize all member variables to invalid values.\n  LineEntry();\n\n  LineEntry(const lldb::SectionSP &section_sp, lldb::addr_t section_offset,\n            lldb::addr_t byte_size, const FileSpec &file, uint32_t _line,\n            uint16_t _column, bool _is_start_of_statement,\n            bool _is_start_of_basic_block, bool _is_prologue_end,\n            bool _is_epilogue_begin, bool _is_terminal_entry);\n\n  /// Clear the object's state.\n  ///\n  /// Clears all member variables to invalid values.\n  void Clear();\n\n  /// Dump a description of this object to a Stream.\n  ///\n  /// Dump a description of the contents of this object to the supplied stream\n  /// \\a s.\n  ///\n  /// \\param[in] s\n  ///     The stream to which to dump the object description.\n  ///\n  /// \\param[in] show_file\n  ///     If \\b true, display the filename with the line entry which\n  ///     requires that the compile unit object \\a comp_unit be a\n  ///     valid pointer.\n  ///\n  /// \\param[in] style\n  ///     The display style for the section offset address.\n  ///\n  /// \\return\n  ///     Returns \\b true if the address was able to be displayed\n  ///     using \\a style. File and load addresses may be unresolved\n  ///     and it may not be possible to display a valid address value.\n  ///     Returns \\b false if the address was not able to be properly\n  ///     dumped.\n  ///\n  /// \\see Address::DumpStyle\n  bool Dump(Stream *s, Target *target, bool show_file, Address::DumpStyle style,\n            Address::DumpStyle fallback_style, bool show_range) const;\n\n  bool GetDescription(Stream *s, lldb::DescriptionLevel level, CompileUnit *cu,\n                      Target *target, bool show_address_only) const;\n\n  /// Dumps information specific to a process that stops at this line entry to\n  /// the supplied stream \\a s.\n  ///\n  /// \\param[in] s\n  ///     The stream to which to dump the object description.\n  ///\n  /// \\return\n  ///     Returns \\b true if the file and line were properly dumped,\n  ///     \\b false otherwise.\n  bool DumpStopContext(Stream *s, bool show_fullpaths) const;\n\n  /// Check if a line entry object is valid.\n  ///\n  /// \\return\n  ///     Returns \\b true if the line entry contains a valid section\n  ///     offset address, file index, and line number, \\b false\n  ///     otherwise.\n  bool IsValid() const;\n\n  /// Compare two LineEntry objects.\n  ///\n  /// \\param[in] lhs\n  ///     The Left Hand Side const LineEntry object reference.\n  ///\n  /// \\param[in] rhs\n  ///     The Right Hand Side const LineEntry object reference.\n  ///\n  /// \\return\n  ///     -1 if lhs < rhs\n  ///     0 if lhs == rhs\n  ///     1 if lhs > rhs\n  static int Compare(const LineEntry &lhs, const LineEntry &rhs);\n\n  /// Give the range for this LineEntry + any additional LineEntries for this\n  /// same source line that are contiguous.\n  ///\n  /// A compiler may emit multiple line entries for a single source line,\n  /// e.g. to indicate subexpressions at different columns.  This method will\n  /// get the AddressRange for all of the LineEntries for this source line\n  /// that are contiguous.\n  //\n  /// Line entries with a line number of 0 are treated specially - these are\n  /// compiler-generated line table entries that the user did not write in\n  /// their source code, and we want to skip past in the debugger. If this\n  /// LineEntry is for line 32, and the following LineEntry is for line 0, we\n  /// will extend the range to include the AddressRange of the line 0\n  /// LineEntry (and it will include the range of the following LineEntries\n  /// that match either 32 or 0.)\n  ///\n  /// When \\b include_inlined_functions is \\b true inlined functions with\n  /// a call site at this LineEntry will also be included in the complete\n  /// range.\n  ///\n  /// If the initial LineEntry this method is called on is a line #0, only the\n  /// range of continuous LineEntries with line #0 will be included in the\n  /// complete range.\n  ///\n  /// @param[in] include_inlined_functions\n  ///     Whether to include inlined functions at the same line or not.\n  ///\n  /// \\return\n  ///     The contiguous AddressRange for this source line.\n  AddressRange\n  GetSameLineContiguousAddressRange(bool include_inlined_functions) const;\n\n  /// Apply file mappings from target.source-map to the LineEntry's file.\n  ///\n  /// \\param[in] target_sp\n  ///     Shared pointer to the target this LineEntry belongs to.\n  void ApplyFileMappings(lldb::TargetSP target_sp);\n\n  // Member variables.\n  AddressRange range; ///< The section offset address range for this line entry.\n  FileSpec file; ///< The source file, possibly mapped by the target.source-map\n                 ///setting\n  FileSpec original_file; ///< The original source file, from debug info.\n  uint32_t line; ///< The source line number, or zero if there is no line number\n                 ///information.\n  uint16_t column; ///< The column number of the source line, or zero if there\n                   ///is no column information.\n  uint16_t is_start_of_statement : 1, ///< Indicates this entry is the beginning\n                                      ///of a statement.\n      is_start_of_basic_block : 1, ///< Indicates this entry is the beginning of\n                                   ///a basic block.\n      is_prologue_end : 1,   ///< Indicates this entry is one (of possibly many)\n                             ///where execution should be suspended for an entry\n                             ///breakpoint of a function.\n      is_epilogue_begin : 1, ///< Indicates this entry is one (of possibly many)\n                             ///where execution should be suspended for an exit\n                             ///breakpoint of a function.\n      is_terminal_entry : 1; ///< Indicates this entry is that of the first byte\n                             ///after the end of a sequence of target machine\n                             ///instructions.\n};\n\n/// Less than operator.\n///\n/// \\param[in] lhs\n///     The Left Hand Side const LineEntry object reference.\n///\n/// \\param[in] rhs\n///     The Right Hand Side const LineEntry object reference.\n///\n/// \\return\n///     Returns \\b true if lhs < rhs, false otherwise.\nbool operator<(const LineEntry &lhs, const LineEntry &rhs);\n\n} // namespace lldb_private\n\n#endif // LLDB_SYMBOL_LINEENTRY_H\n"}, "22": {"id": 22, "path": "/home/vsts/work/1/llvm-project/lldb/include/lldb/Symbol/Symbol.h", "content": "//===-- Symbol.h ------------------------------------------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLDB_SYMBOL_SYMBOL_H\n#define LLDB_SYMBOL_SYMBOL_H\n\n#include \"lldb/Core/AddressRange.h\"\n#include \"lldb/Core/Mangled.h\"\n#include \"lldb/Symbol/SymbolContextScope.h\"\n#include \"lldb/Utility/UserID.h\"\n#include \"lldb/lldb-private.h\"\n\nnamespace lldb_private {\n\nclass Symbol : public SymbolContextScope {\npublic:\n  // ObjectFile readers can classify their symbol table entries and searches\n  // can be made on specific types where the symbol values will have\n  // drastically different meanings and sorting requirements.\n  Symbol();\n\n  Symbol(uint32_t symID, llvm::StringRef name, lldb::SymbolType type,\n         bool external, bool is_debug, bool is_trampoline, bool is_artificial,\n         const lldb::SectionSP &section_sp, lldb::addr_t value,\n         lldb::addr_t size, bool size_is_valid,\n         bool contains_linker_annotations, uint32_t flags);\n\n  Symbol(uint32_t symID, const Mangled &mangled, lldb::SymbolType type,\n         bool external, bool is_debug, bool is_trampoline, bool is_artificial,\n         const AddressRange &range, bool size_is_valid,\n         bool contains_linker_annotations, uint32_t flags);\n\n  Symbol(const Symbol &rhs);\n\n  const Symbol &operator=(const Symbol &rhs);\n\n  void Clear();\n\n  bool Compare(ConstString name, lldb::SymbolType type) const;\n\n  void Dump(Stream *s, Target *target, uint32_t index,\n            Mangled::NamePreference name_preference =\n                Mangled::ePreferDemangled) const;\n\n  bool ValueIsAddress() const;\n\n  // The GetAddressRef() accessor functions should only be called if you\n  // previously call ValueIsAddress() otherwise you might get an reference to\n  // an Address object that contains an constant integer value in\n  // m_addr_range.m_base_addr.m_offset which could be incorrectly used to\n  // represent an absolute address since it has no section.\n  Address &GetAddressRef() { return m_addr_range.GetBaseAddress(); }\n\n  const Address &GetAddressRef() const { return m_addr_range.GetBaseAddress(); }\n\n  // Makes sure the symbol's value is an address and returns the file address.\n  // Returns LLDB_INVALID_ADDRESS if the symbol's value isn't an address.\n  lldb::addr_t GetFileAddress() const;\n\n  // Makes sure the symbol's value is an address and gets the load address\n  // using \\a target if it is. Returns LLDB_INVALID_ADDRESS if the symbol's\n  // value isn't an address or if the section isn't loaded in \\a target.\n  lldb::addr_t GetLoadAddress(Target *target) const;\n\n  // Access the address value. Do NOT hand out the AddressRange as an object as\n  // the byte size of the address range may not be filled in and it should be\n  // accessed via GetByteSize().\n  Address GetAddress() const {\n    // Make sure the our value is an address before we hand a copy out. We use\n    // the Address inside m_addr_range to contain the value for symbols that\n    // are not address based symbols so we are using it for more than just\n    // addresses. For example undefined symbols on MacOSX have a nlist.n_value\n    // of 0 (zero) and this will get placed into\n    // m_addr_range.m_base_addr.m_offset and it will have no section. So in the\n    // GetAddress() accessor, we need to hand out an invalid address if the\n    // symbol's value isn't an address.\n    if (ValueIsAddress())\n      return m_addr_range.GetBaseAddress();\n    else\n      return Address();\n  }\n\n  // When a symbol's value isn't an address, we need to access the raw value.\n  // This function will ensure this symbol's value isn't an address and return\n  // the integer value if this checks out, otherwise it will return\n  // \"fail_value\" if the symbol is an address value.\n  uint64_t GetIntegerValue(uint64_t fail_value = 0) const {\n    if (ValueIsAddress()) {\n      // This symbol's value is an address. Use Symbol::GetAddress() to get the\n      // address.\n      return fail_value;\n    } else {\n      // The value is stored in the base address' offset\n      return m_addr_range.GetBaseAddress().GetOffset();\n    }\n  }\n\n  lldb::addr_t ResolveCallableAddress(Target &target) const;\n\n  ConstString GetName() const;\n\n  ConstString GetNameNoArguments() const;\n\n  ConstString GetDisplayName() const;\n\n  uint32_t GetID() const { return m_uid; }\n\n  lldb::LanguageType GetLanguage() const {\n    // TODO: See if there is a way to determine the language for a symbol\n    // somehow, for now just return our best guess\n    return m_mangled.GuessLanguage();\n  }\n\n  void SetID(uint32_t uid) { m_uid = uid; }\n\n  Mangled &GetMangled() { return m_mangled; }\n\n  const Mangled &GetMangled() const { return m_mangled; }\n\n  ConstString GetReExportedSymbolName() const;\n\n  FileSpec GetReExportedSymbolSharedLibrary() const;\n\n  void SetReExportedSymbolName(ConstString name);\n\n  bool SetReExportedSymbolSharedLibrary(const FileSpec &fspec);\n\n  Symbol *ResolveReExportedSymbol(Target &target) const;\n\n  uint32_t GetSiblingIndex() const;\n\n  lldb::SymbolType GetType() const { return (lldb::SymbolType)m_type; }\n\n  void SetType(lldb::SymbolType type) { m_type = (lldb::SymbolType)type; }\n\n  const char *GetTypeAsString() const;\n\n  uint32_t GetFlags() const { return m_flags; }\n\n  void SetFlags(uint32_t flags) { m_flags = flags; }\n\n  void GetDescription(Stream *s, lldb::DescriptionLevel level,\n                      Target *target) const;\n\n  bool IsSynthetic() const { return m_is_synthetic; }\n\n  void SetIsSynthetic(bool b) { m_is_synthetic = b; }\n\n  bool GetSizeIsSynthesized() const { return m_size_is_synthesized; }\n\n  void SetSizeIsSynthesized(bool b) { m_size_is_synthesized = b; }\n\n  bool IsDebug() const { return m_is_debug; }\n\n  void SetDebug(bool b) { m_is_debug = b; }\n\n  bool IsExternal() const { return m_is_external; }\n\n  void SetExternal(bool b) { m_is_external = b; }\n\n  bool IsTrampoline() const;\n\n  bool IsIndirect() const;\n  \n  bool IsWeak() const { return m_is_weak; }\n  \n  void SetIsWeak (bool b) { m_is_weak = b; }\n\n  bool GetByteSizeIsValid() const { return m_size_is_valid; }\n\n  lldb::addr_t GetByteSize() const;\n\n  void SetByteSize(lldb::addr_t size) {\n    m_size_is_valid = size > 0;\n    m_addr_range.SetByteSize(size);\n  }\n\n  bool GetSizeIsSibling() const { return m_size_is_sibling; }\n\n  void SetSizeIsSibling(bool b) { m_size_is_sibling = b; }\n\n  // If m_type is \"Code\" or \"Function\" then this will return the prologue size\n  // in bytes, else it will return zero.\n  uint32_t GetPrologueByteSize();\n\n  bool GetDemangledNameIsSynthesized() const {\n    return m_demangled_is_synthesized;\n  }\n\n  void SetDemangledNameIsSynthesized(bool b) { m_demangled_is_synthesized = b; }\n\n  bool ContainsLinkerAnnotations() const {\n    return m_contains_linker_annotations;\n  }\n  void SetContainsLinkerAnnotations(bool b) {\n    m_contains_linker_annotations = b;\n  }\n  /// \\copydoc SymbolContextScope::CalculateSymbolContext(SymbolContext*)\n  ///\n  /// \\see SymbolContextScope\n  void CalculateSymbolContext(SymbolContext *sc) override;\n\n  lldb::ModuleSP CalculateSymbolContextModule() override;\n\n  Symbol *CalculateSymbolContextSymbol() override;\n\n  /// \\copydoc SymbolContextScope::DumpSymbolContext(Stream*)\n  ///\n  /// \\see SymbolContextScope\n  void DumpSymbolContext(Stream *s) override;\n\n  lldb::DisassemblerSP GetInstructions(const ExecutionContext &exe_ctx,\n                                       const char *flavor,\n                                       bool prefer_file_cache);\n\n  bool GetDisassembly(const ExecutionContext &exe_ctx, const char *flavor,\n                      bool prefer_file_cache, Stream &strm);\n\n  bool ContainsFileAddress(lldb::addr_t file_addr) const;\n\nprotected:\n  // This is the internal guts of ResolveReExportedSymbol, it assumes\n  // reexport_name is not null, and that module_spec is valid.  We track the\n  // modules we've already seen to make sure we don't get caught in a cycle.\n\n  Symbol *ResolveReExportedSymbolInModuleSpec(\n      Target &target, ConstString &reexport_name,\n      lldb_private::ModuleSpec &module_spec,\n      lldb_private::ModuleList &seen_modules) const;\n\n  uint32_t m_uid;       // User ID (usually the original symbol table index)\n  uint16_t m_type_data; // data specific to m_type\n  uint16_t m_type_data_resolved : 1, // True if the data in m_type_data has\n                                     // already been calculated\n      m_is_synthetic : 1, // non-zero if this symbol is not actually in the\n                          // symbol table, but synthesized from other info in\n                          // the object file.\n      m_is_debug : 1,     // non-zero if this symbol is debug information in a\n                          // symbol\n      m_is_external : 1,  // non-zero if this symbol is globally visible\n      m_size_is_sibling : 1,     // m_size contains the index of this symbol's\n                                 // sibling\n      m_size_is_synthesized : 1, // non-zero if this symbol's size was\n                                 // calculated using a delta between this\n                                 // symbol and the next\n      m_size_is_valid : 1,\n      m_demangled_is_synthesized : 1, // The demangled name was created should\n                                      // not be used for expressions or other\n                                      // lookups\n      m_contains_linker_annotations : 1, // The symbol name contains linker\n                                         // annotations, which are optional when\n                                         // doing name lookups\n      m_is_weak : 1,\n      m_type : 6;            // Values from the lldb::SymbolType enum.\n  Mangled m_mangled;         // uniqued symbol name/mangled name pair\n  AddressRange m_addr_range; // Contains the value, or the section offset\n                             // address when the value is an address in a\n                             // section, and the size (if any)\n  uint32_t m_flags; // A copy of the flags from the original symbol table, the\n                    // ObjectFile plug-in can interpret these\n};\n\n} // namespace lldb_private\n\n#endif // LLDB_SYMBOL_SYMBOL_H\n"}, "23": {"id": 23, "path": "/home/vsts/work/1/llvm-project/lldb/include/lldb/Target/InstrumentationRuntime.h", "content": "//===-- InstrumentationRuntime.h --------------------------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLDB_TARGET_INSTRUMENTATIONRUNTIME_H\n#define LLDB_TARGET_INSTRUMENTATIONRUNTIME_H\n\n#include <map>\n#include <vector>\n\n#include \"lldb/Core/PluginInterface.h\"\n#include \"lldb/Utility/StructuredData.h\"\n#include \"lldb/lldb-forward.h\"\n#include \"lldb/lldb-private.h\"\n#include \"lldb/lldb-types.h\"\n\nnamespace lldb_private {\n\ntypedef std::map<lldb::InstrumentationRuntimeType,\n                 lldb::InstrumentationRuntimeSP>\n    InstrumentationRuntimeCollection;\n\nclass InstrumentationRuntime\n    : public std::enable_shared_from_this<InstrumentationRuntime>,\n      public PluginInterface {\n  /// The instrumented process.\n  lldb::ProcessWP m_process_wp;\n\n  /// The module containing the instrumentation runtime.\n  lldb::ModuleSP m_runtime_module;\n\n  /// The breakpoint in the instrumentation runtime.\n  lldb::user_id_t m_breakpoint_id;\n\n  /// Indicates whether or not breakpoints have been registered in the\n  /// instrumentation runtime.\n  bool m_is_active;\n\nprotected:\n  InstrumentationRuntime(const lldb::ProcessSP &process_sp)\n      : m_process_wp(), m_runtime_module(), m_breakpoint_id(0),\n        m_is_active(false) {\n    if (process_sp)\n      m_process_wp = process_sp;\n  }\n\n  lldb::ProcessSP GetProcessSP() { return m_process_wp.lock(); }\n\n  lldb::ModuleSP GetRuntimeModuleSP() { return m_runtime_module; }\n\n  void SetRuntimeModuleSP(lldb::ModuleSP module_sp) {\n    m_runtime_module = std::move(module_sp);\n  }\n\n  lldb::user_id_t GetBreakpointID() const { return m_breakpoint_id; }\n\n  void SetBreakpointID(lldb::user_id_t ID) { m_breakpoint_id = ID; }\n\n  void SetActive(bool IsActive) { m_is_active = IsActive; }\n\n  /// Return a regular expression which can be used to identify a valid version\n  /// of the runtime library.\n  virtual const RegularExpression &GetPatternForRuntimeLibrary() = 0;\n\n  /// Check whether \\p module_sp corresponds to a valid runtime library.\n  virtual bool CheckIfRuntimeIsValid(const lldb::ModuleSP module_sp) = 0;\n\n  /// Register a breakpoint in the runtime library and perform any other\n  /// necessary initialization. The runtime library\n  /// is guaranteed to be loaded.\n  virtual void Activate() = 0;\n\npublic:\n  static void ModulesDidLoad(lldb_private::ModuleList &module_list,\n                             Process *process,\n                             InstrumentationRuntimeCollection &runtimes);\n\n  /// Look for the instrumentation runtime in \\p module_list. Register and\n  /// activate the runtime if this hasn't already\n  /// been done.\n  void ModulesDidLoad(lldb_private::ModuleList &module_list);\n\n  bool IsActive() const { return m_is_active; }\n\n  virtual lldb::ThreadCollectionSP\n  GetBacktracesFromExtendedStopInfo(StructuredData::ObjectSP info);\n};\n\n} // namespace lldb_private\n\n#endif // LLDB_TARGET_INSTRUMENTATIONRUNTIME_H\n"}, "24": {"id": 24, "path": "/home/vsts/work/1/llvm-project/lldb/include/lldb/Target/Target.h", "content": "//===-- Target.h ------------------------------------------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLDB_TARGET_TARGET_H\n#define LLDB_TARGET_TARGET_H\n\n#include <list>\n#include <map>\n#include <memory>\n#include <string>\n#include <vector>\n\n#include \"lldb/Breakpoint/BreakpointList.h\"\n#include \"lldb/Breakpoint/BreakpointName.h\"\n#include \"lldb/Breakpoint/WatchpointList.h\"\n#include \"lldb/Core/Architecture.h\"\n#include \"lldb/Core/Disassembler.h\"\n#include \"lldb/Core/ModuleList.h\"\n#include \"lldb/Core/UserSettingsController.h\"\n#include \"lldb/Expression/Expression.h\"\n#include \"lldb/Host/ProcessLaunchInfo.h\"\n#include \"lldb/Symbol/TypeSystem.h\"\n#include \"lldb/Target/ExecutionContextScope.h\"\n#include \"lldb/Target/PathMappingList.h\"\n#include \"lldb/Target/SectionLoadHistory.h\"\n#include \"lldb/Target/ThreadSpec.h\"\n#include \"lldb/Utility/ArchSpec.h\"\n#include \"lldb/Utility/Broadcaster.h\"\n#include \"lldb/Utility/LLDBAssert.h\"\n#include \"lldb/Utility/Timeout.h\"\n#include \"lldb/lldb-public.h\"\n\nnamespace lldb_private {\n\nclass ClangModulesDeclVendor;\n\nOptionEnumValues GetDynamicValueTypes();\n\nenum InlineStrategy {\n  eInlineBreakpointsNever = 0,\n  eInlineBreakpointsHeaders,\n  eInlineBreakpointsAlways\n};\n\nenum LoadScriptFromSymFile {\n  eLoadScriptFromSymFileTrue,\n  eLoadScriptFromSymFileFalse,\n  eLoadScriptFromSymFileWarn\n};\n\nenum LoadCWDlldbinitFile {\n  eLoadCWDlldbinitTrue,\n  eLoadCWDlldbinitFalse,\n  eLoadCWDlldbinitWarn\n};\n\nenum LoadDependentFiles {\n  eLoadDependentsDefault,\n  eLoadDependentsYes,\n  eLoadDependentsNo,\n};\n\nenum ImportStdModule {\n  eImportStdModuleFalse,\n  eImportStdModuleFallback,\n  eImportStdModuleTrue,\n};\n\nclass TargetExperimentalProperties : public Properties {\npublic:\n  TargetExperimentalProperties();\n};\n\nclass TargetProperties : public Properties {\npublic:\n  TargetProperties(Target *target);\n\n  ~TargetProperties() override;\n\n  ArchSpec GetDefaultArchitecture() const;\n\n  void SetDefaultArchitecture(const ArchSpec &arch);\n\n  bool GetMoveToNearestCode() const;\n\n  lldb::DynamicValueType GetPreferDynamicValue() const;\n\n  bool SetPreferDynamicValue(lldb::DynamicValueType d);\n\n  bool GetPreloadSymbols() const;\n\n  void SetPreloadSymbols(bool b);\n\n  bool GetDisableASLR() const;\n\n  void SetDisableASLR(bool b);\n\n  bool GetInheritTCC() const;\n\n  void SetInheritTCC(bool b);\n\n  bool GetDetachOnError() const;\n\n  void SetDetachOnError(bool b);\n\n  bool GetDisableSTDIO() const;\n\n  void SetDisableSTDIO(bool b);\n\n  const char *GetDisassemblyFlavor() const;\n\n  InlineStrategy GetInlineStrategy() const;\n\n  llvm::StringRef GetArg0() const;\n\n  void SetArg0(llvm::StringRef arg);\n\n  bool GetRunArguments(Args &args) const;\n\n  void SetRunArguments(const Args &args);\n\n  Environment GetEnvironment() const;\n  void SetEnvironment(Environment env);\n\n  bool GetSkipPrologue() const;\n\n  PathMappingList &GetSourcePathMap() const;\n\n  FileSpecList GetExecutableSearchPaths();\n\n  void AppendExecutableSearchPaths(const FileSpec &);\n\n  FileSpecList GetDebugFileSearchPaths();\n\n  FileSpecList GetClangModuleSearchPaths();\n\n  bool GetEnableAutoImportClangModules() const;\n\n  ImportStdModule GetImportStdModule() const;\n\n  bool GetEnableAutoApplyFixIts() const;\n\n  uint64_t GetNumberOfRetriesWithFixits() const;\n\n  bool GetEnableNotifyAboutFixIts() const;\n\n  bool GetEnableSaveObjects() const;\n\n  bool GetEnableSyntheticValue() const;\n\n  uint32_t GetMaxZeroPaddingInFloatFormat() const;\n\n  uint32_t GetMaximumNumberOfChildrenToDisplay() const;\n\n  uint32_t GetMaximumSizeOfStringSummary() const;\n\n  uint32_t GetMaximumMemReadSize() const;\n\n  FileSpec GetStandardInputPath() const;\n  FileSpec GetStandardErrorPath() const;\n  FileSpec GetStandardOutputPath() const;\n\n  void SetStandardInputPath(llvm::StringRef path);\n  void SetStandardOutputPath(llvm::StringRef path);\n  void SetStandardErrorPath(llvm::StringRef path);\n\n  void SetStandardInputPath(const char *path) = delete;\n  void SetStandardOutputPath(const char *path) = delete;\n  void SetStandardErrorPath(const char *path) = delete;\n\n  bool GetBreakpointsConsultPlatformAvoidList();\n\n  lldb::LanguageType GetLanguage() const;\n\n  llvm::StringRef GetExpressionPrefixContents();\n\n  uint64_t GetExprErrorLimit() const;\n\n  bool GetUseHexImmediates() const;\n\n  bool GetUseFastStepping() const;\n\n  bool GetDisplayExpressionsInCrashlogs() const;\n\n  LoadScriptFromSymFile GetLoadScriptFromSymbolFile() const;\n\n  LoadCWDlldbinitFile GetLoadCWDlldbinitFile() const;\n\n  Disassembler::HexImmediateStyle GetHexImmediateStyle() const;\n\n  MemoryModuleLoadLevel GetMemoryModuleLoadLevel() const;\n\n  bool GetUserSpecifiedTrapHandlerNames(Args &args) const;\n\n  void SetUserSpecifiedTrapHandlerNames(const Args &args);\n\n  bool GetNonStopModeEnabled() const;\n\n  void SetNonStopModeEnabled(bool b);\n\n  bool GetDisplayRuntimeSupportValues() const;\n\n  void SetDisplayRuntimeSupportValues(bool b);\n\n  bool GetDisplayRecognizedArguments() const;\n\n  void SetDisplayRecognizedArguments(bool b);\n\n  const ProcessLaunchInfo &GetProcessLaunchInfo() const;\n\n  void SetProcessLaunchInfo(const ProcessLaunchInfo &launch_info);\n\n  bool GetInjectLocalVariables(ExecutionContext *exe_ctx) const;\n\n  void SetInjectLocalVariables(ExecutionContext *exe_ctx, bool b);\n\n  void SetRequireHardwareBreakpoints(bool b);\n\n  bool GetRequireHardwareBreakpoints() const;\n\n  bool GetAutoInstallMainExecutable() const;\n\n  void UpdateLaunchInfoFromProperties();\n\n  void SetDebugUtilityExpression(bool debug);\n\n  bool GetDebugUtilityExpression() const;\n\nprivate:\n  // Callbacks for m_launch_info.\n  void Arg0ValueChangedCallback();\n  void RunArgsValueChangedCallback();\n  void EnvVarsValueChangedCallback();\n  void InputPathValueChangedCallback();\n  void OutputPathValueChangedCallback();\n  void ErrorPathValueChangedCallback();\n  void DetachOnErrorValueChangedCallback();\n  void DisableASLRValueChangedCallback();\n  void InheritTCCValueChangedCallback();\n  void DisableSTDIOValueChangedCallback();\n\n  Environment ComputeEnvironment() const;\n\n  // Member variables.\n  ProcessLaunchInfo m_launch_info;\n  std::unique_ptr<TargetExperimentalProperties> m_experimental_properties_up;\n  Target *m_target;\n};\n\nclass EvaluateExpressionOptions {\npublic:\n// MSVC has a bug here that reports C4268: 'const' static/global data\n// initialized with compiler generated default constructor fills the object\n// with zeros. Confirmed that MSVC is *not* zero-initializing, it's just a\n// bogus warning.\n#if defined(_MSC_VER)\n#pragma warning(push)\n#pragma warning(disable : 4268)\n#endif\n  static constexpr std::chrono::milliseconds default_timeout{500};\n#if defined(_MSC_VER)\n#pragma warning(pop)\n#endif\n\n  static constexpr ExecutionPolicy default_execution_policy =\n      eExecutionPolicyOnlyWhenNeeded;\n\n  EvaluateExpressionOptions() = default;\n\n  ExecutionPolicy GetExecutionPolicy() const { return m_execution_policy; }\n\n  void SetExecutionPolicy(ExecutionPolicy policy = eExecutionPolicyAlways) {\n    m_execution_policy = policy;\n  }\n\n  lldb::LanguageType GetLanguage() const { return m_language; }\n\n  void SetLanguage(lldb::LanguageType language) { m_language = language; }\n\n  bool DoesCoerceToId() const { return m_coerce_to_id; }\n\n  const char *GetPrefix() const {\n    return (m_prefix.empty() ? nullptr : m_prefix.c_str());\n  }\n\n  void SetPrefix(const char *prefix) {\n    if (prefix && prefix[0])\n      m_prefix = prefix;\n    else\n      m_prefix.clear();\n  }\n\n  void SetCoerceToId(bool coerce = true) { m_coerce_to_id = coerce; }\n\n  bool DoesUnwindOnError() const { return m_unwind_on_error; }\n\n  void SetUnwindOnError(bool unwind = false) { m_unwind_on_error = unwind; }\n\n  bool DoesIgnoreBreakpoints() const { return m_ignore_breakpoints; }\n\n  void SetIgnoreBreakpoints(bool ignore = false) {\n    m_ignore_breakpoints = ignore;\n  }\n\n  bool DoesKeepInMemory() const { return m_keep_in_memory; }\n\n  void SetKeepInMemory(bool keep = true) { m_keep_in_memory = keep; }\n\n  lldb::DynamicValueType GetUseDynamic() const { return m_use_dynamic; }\n\n  void\n  SetUseDynamic(lldb::DynamicValueType dynamic = lldb::eDynamicCanRunTarget) {\n    m_use_dynamic = dynamic;\n  }\n\n  const Timeout<std::micro> &GetTimeout() const { return m_timeout; }\n\n  void SetTimeout(const Timeout<std::micro> &timeout) { m_timeout = timeout; }\n\n  const Timeout<std::micro> &GetOneThreadTimeout() const {\n    return m_one_thread_timeout;\n  }\n\n  void SetOneThreadTimeout(const Timeout<std::micro> &timeout) {\n    m_one_thread_timeout = timeout;\n  }\n\n  bool GetTryAllThreads() const { return m_try_others; }\n\n  void SetTryAllThreads(bool try_others = true) { m_try_others = try_others; }\n\n  bool GetStopOthers() const { return m_stop_others; }\n\n  void SetStopOthers(bool stop_others = true) { m_stop_others = stop_others; }\n\n  bool GetDebug() const { return m_debug; }\n\n  void SetDebug(bool b) {\n    m_debug = b;\n    if (m_debug)\n      m_generate_debug_info = true;\n  }\n\n  bool GetGenerateDebugInfo() const { return m_generate_debug_info; }\n\n  void SetGenerateDebugInfo(bool b) { m_generate_debug_info = b; }\n\n  bool GetColorizeErrors() const { return m_ansi_color_errors; }\n\n  void SetColorizeErrors(bool b) { m_ansi_color_errors = b; }\n\n  bool GetTrapExceptions() const { return m_trap_exceptions; }\n\n  void SetTrapExceptions(bool b) { m_trap_exceptions = b; }\n\n  bool GetREPLEnabled() const { return m_repl; }\n\n  void SetREPLEnabled(bool b) { m_repl = b; }\n\n  void SetCancelCallback(lldb::ExpressionCancelCallback callback, void *baton) {\n    m_cancel_callback_baton = baton;\n    m_cancel_callback = callback;\n  }\n\n  bool InvokeCancelCallback(lldb::ExpressionEvaluationPhase phase) const {\n    return ((m_cancel_callback != nullptr)\n                ? m_cancel_callback(phase, m_cancel_callback_baton)\n                : false);\n  }\n\n  // Allows the expression contents to be remapped to point to the specified\n  // file and line using #line directives.\n  void SetPoundLine(const char *path, uint32_t line) const {\n    if (path && path[0]) {\n      m_pound_line_file = path;\n      m_pound_line_line = line;\n    } else {\n      m_pound_line_file.clear();\n      m_pound_line_line = 0;\n    }\n  }\n\n  const char *GetPoundLineFilePath() const {\n    return (m_pound_line_file.empty() ? nullptr : m_pound_line_file.c_str());\n  }\n\n  uint32_t GetPoundLineLine() const { return m_pound_line_line; }\n\n  void SetResultIsInternal(bool b) { m_result_is_internal = b; }\n\n  bool GetResultIsInternal() const { return m_result_is_internal; }\n\n  void SetAutoApplyFixIts(bool b) { m_auto_apply_fixits = b; }\n\n  bool GetAutoApplyFixIts() const { return m_auto_apply_fixits; }\n\n  void SetRetriesWithFixIts(uint64_t number_of_retries) {\n    m_retries_with_fixits = number_of_retries;\n  }\n\n  uint64_t GetRetriesWithFixIts() const { return m_retries_with_fixits; }\n\n  bool IsForUtilityExpr() const { return m_running_utility_expression; }\n\n  void SetIsForUtilityExpr(bool b) { m_running_utility_expression = b; }\n\nprivate:\n  ExecutionPolicy m_execution_policy = default_execution_policy;\n  lldb::LanguageType m_language = lldb::eLanguageTypeUnknown;\n  std::string m_prefix;\n  bool m_coerce_to_id = false;\n  bool m_unwind_on_error = true;\n  bool m_ignore_breakpoints = false;\n  bool m_keep_in_memory = false;\n  bool m_try_others = true;\n  bool m_stop_others = true;\n  bool m_debug = false;\n  bool m_trap_exceptions = true;\n  bool m_repl = false;\n  bool m_generate_debug_info = false;\n  bool m_ansi_color_errors = false;\n  bool m_result_is_internal = false;\n  bool m_auto_apply_fixits = true;\n  uint64_t m_retries_with_fixits = 1;\n  /// True if the executed code should be treated as utility code that is only\n  /// used by LLDB internally.\n  bool m_running_utility_expression = false;\n\n  lldb::DynamicValueType m_use_dynamic = lldb::eNoDynamicValues;\n  Timeout<std::micro> m_timeout = default_timeout;\n  Timeout<std::micro> m_one_thread_timeout = llvm::None;\n  lldb::ExpressionCancelCallback m_cancel_callback = nullptr;\n  void *m_cancel_callback_baton = nullptr;\n  // If m_pound_line_file is not empty and m_pound_line_line is non-zero, use\n  // #line %u \"%s\" before the expression content to remap where the source\n  // originates\n  mutable std::string m_pound_line_file;\n  mutable uint32_t m_pound_line_line;\n};\n\n// Target\nclass Target : public std::enable_shared_from_this<Target>,\n               public TargetProperties,\n               public Broadcaster,\n               public ExecutionContextScope,\n               public ModuleList::Notifier {\npublic:\n  friend class TargetList;\n  friend class Debugger;\n\n  /// Broadcaster event bits definitions.\n  enum {\n    eBroadcastBitBreakpointChanged = (1 << 0),\n    eBroadcastBitModulesLoaded = (1 << 1),\n    eBroadcastBitModulesUnloaded = (1 << 2),\n    eBroadcastBitWatchpointChanged = (1 << 3),\n    eBroadcastBitSymbolsLoaded = (1 << 4)\n  };\n\n  // These two functions fill out the Broadcaster interface:\n\n  static ConstString &GetStaticBroadcasterClass();\n\n  ConstString &GetBroadcasterClass() const override {\n    return GetStaticBroadcasterClass();\n  }\n\n  // This event data class is for use by the TargetList to broadcast new target\n  // notifications.\n  class TargetEventData : public EventData {\n  public:\n    TargetEventData(const lldb::TargetSP &target_sp);\n\n    TargetEventData(const lldb::TargetSP &target_sp,\n                    const ModuleList &module_list);\n\n    ~TargetEventData() override;\n\n    static ConstString GetFlavorString();\n\n    ConstString GetFlavor() const override {\n      return TargetEventData::GetFlavorString();\n    }\n\n    void Dump(Stream *s) const override;\n\n    static const TargetEventData *GetEventDataFromEvent(const Event *event_ptr);\n\n    static lldb::TargetSP GetTargetFromEvent(const Event *event_ptr);\n\n    static ModuleList GetModuleListFromEvent(const Event *event_ptr);\n\n    const lldb::TargetSP &GetTarget() const { return m_target_sp; }\n\n    const ModuleList &GetModuleList() const { return m_module_list; }\n\n  private:\n    lldb::TargetSP m_target_sp;\n    ModuleList m_module_list;\n\n    TargetEventData(const TargetEventData &) = delete;\n    const TargetEventData &operator=(const TargetEventData &) = delete;\n  };\n\n  ~Target() override;\n\n  static void SettingsInitialize();\n\n  static void SettingsTerminate();\n\n  static FileSpecList GetDefaultExecutableSearchPaths();\n\n  static FileSpecList GetDefaultDebugFileSearchPaths();\n\n  static ArchSpec GetDefaultArchitecture();\n\n  static void SetDefaultArchitecture(const ArchSpec &arch);\n\n  bool IsDummyTarget() const { return m_is_dummy_target; }\n\n  /// Find a binary on the system and return its Module,\n  /// or return an existing Module that is already in the Target.\n  ///\n  /// Given a ModuleSpec, find a binary satisifying that specification,\n  /// or identify a matching Module already present in the Target,\n  /// and return a shared pointer to it.\n  ///\n  /// \\param[in] module_spec\n  ///     The criteria that must be matched for the binary being loaded.\n  ///     e.g. UUID, architecture, file path.\n  ///\n  /// \\param[in] notify\n  ///     If notify is true, and the Module is new to this Target,\n  ///     Target::ModulesDidLoad will be called.\n  ///     If notify is false, it is assumed that the caller is adding\n  ///     multiple Modules and will call ModulesDidLoad with the\n  ///     full list at the end.\n  ///     ModulesDidLoad must be called when a Module/Modules have\n  ///     been added to the target, one way or the other.\n  ///\n  /// \\param[out] error_ptr\n  ///     Optional argument, pointing to a Status object to fill in\n  ///     with any results / messages while attempting to find/load\n  ///     this binary.  Many callers will be internal functions that\n  ///     will handle / summarize the failures in a custom way and\n  ///     don't use these messages.\n  ///\n  /// \\return\n  ///     An empty ModuleSP will be returned if no matching file\n  ///     was found.  If error_ptr was non-nullptr, an error message\n  ///     will likely be provided.\n  lldb::ModuleSP GetOrCreateModule(const ModuleSpec &module_spec, bool notify,\n                                   Status *error_ptr = nullptr);\n\n  // Settings accessors\n\n  static const lldb::TargetPropertiesSP &GetGlobalProperties();\n\n  std::recursive_mutex &GetAPIMutex();\n\n  void DeleteCurrentProcess();\n\n  void CleanupProcess();\n\n  /// Dump a description of this object to a Stream.\n  ///\n  /// Dump a description of the contents of this object to the\n  /// supplied stream \\a s. The dumped content will be only what has\n  /// been loaded or parsed up to this point at which this function\n  /// is called, so this is a good way to see what has been parsed\n  /// in a target.\n  ///\n  /// \\param[in] s\n  ///     The stream to which to dump the object description.\n  void Dump(Stream *s, lldb::DescriptionLevel description_level);\n\n  // If listener_sp is null, the listener of the owning Debugger object will be\n  // used.\n  const lldb::ProcessSP &CreateProcess(lldb::ListenerSP listener_sp,\n                                       llvm::StringRef plugin_name,\n                                       const FileSpec *crash_file,\n                                       bool can_connect);\n\n  const lldb::ProcessSP &GetProcessSP() const;\n\n  bool IsValid() { return m_valid; }\n\n  void Destroy();\n\n  Status Launch(ProcessLaunchInfo &launch_info,\n                Stream *stream); // Optional stream to receive first stop info\n\n  Status Attach(ProcessAttachInfo &attach_info,\n                Stream *stream); // Optional stream to receive first stop info\n\n  // This part handles the breakpoints.\n\n  BreakpointList &GetBreakpointList(bool internal = false);\n\n  const BreakpointList &GetBreakpointList(bool internal = false) const;\n\n  lldb::BreakpointSP GetLastCreatedBreakpoint() {\n    return m_last_created_breakpoint;\n  }\n\n  lldb::BreakpointSP GetBreakpointByID(lldb::break_id_t break_id);\n\n  // Use this to create a file and line breakpoint to a given module or all\n  // module it is nullptr\n  lldb::BreakpointSP CreateBreakpoint(const FileSpecList *containingModules,\n                                      const FileSpec &file, uint32_t line_no,\n                                      uint32_t column, lldb::addr_t offset,\n                                      LazyBool check_inlines,\n                                      LazyBool skip_prologue, bool internal,\n                                      bool request_hardware,\n                                      LazyBool move_to_nearest_code);\n\n  // Use this to create breakpoint that matches regex against the source lines\n  // in files given in source_file_list: If function_names is non-empty, also\n  // filter by function after the matches are made.\n  lldb::BreakpointSP CreateSourceRegexBreakpoint(\n      const FileSpecList *containingModules,\n      const FileSpecList *source_file_list,\n      const std::unordered_set<std::string> &function_names,\n      RegularExpression source_regex, bool internal, bool request_hardware,\n      LazyBool move_to_nearest_code);\n\n  // Use this to create a breakpoint from a load address\n  lldb::BreakpointSP CreateBreakpoint(lldb::addr_t load_addr, bool internal,\n                                      bool request_hardware);\n\n  // Use this to create a breakpoint from a load address and a module file spec\n  lldb::BreakpointSP CreateAddressInModuleBreakpoint(lldb::addr_t file_addr,\n                                                     bool internal,\n                                                     const FileSpec *file_spec,\n                                                     bool request_hardware);\n\n  // Use this to create Address breakpoints:\n  lldb::BreakpointSP CreateBreakpoint(const Address &addr, bool internal,\n                                      bool request_hardware);\n\n  // Use this to create a function breakpoint by regexp in\n  // containingModule/containingSourceFiles, or all modules if it is nullptr\n  // When \"skip_prologue is set to eLazyBoolCalculate, we use the current\n  // target setting, else we use the values passed in\n  lldb::BreakpointSP CreateFuncRegexBreakpoint(\n      const FileSpecList *containingModules,\n      const FileSpecList *containingSourceFiles, RegularExpression func_regexp,\n      lldb::LanguageType requested_language, LazyBool skip_prologue,\n      bool internal, bool request_hardware);\n\n  // Use this to create a function breakpoint by name in containingModule, or\n  // all modules if it is nullptr When \"skip_prologue is set to\n  // eLazyBoolCalculate, we use the current target setting, else we use the\n  // values passed in. func_name_type_mask is or'ed values from the\n  // FunctionNameType enum.\n  lldb::BreakpointSP CreateBreakpoint(\n      const FileSpecList *containingModules,\n      const FileSpecList *containingSourceFiles, const char *func_name,\n      lldb::FunctionNameType func_name_type_mask, lldb::LanguageType language,\n      lldb::addr_t offset, LazyBool skip_prologue, bool internal,\n      bool request_hardware);\n\n  lldb::BreakpointSP\n  CreateExceptionBreakpoint(enum lldb::LanguageType language, bool catch_bp,\n                            bool throw_bp, bool internal,\n                            Args *additional_args = nullptr,\n                            Status *additional_args_error = nullptr);\n\n  lldb::BreakpointSP CreateScriptedBreakpoint(\n      const llvm::StringRef class_name, const FileSpecList *containingModules,\n      const FileSpecList *containingSourceFiles, bool internal,\n      bool request_hardware, StructuredData::ObjectSP extra_args_sp,\n      Status *creation_error = nullptr);\n\n  // This is the same as the func_name breakpoint except that you can specify a\n  // vector of names.  This is cheaper than a regular expression breakpoint in\n  // the case where you just want to set a breakpoint on a set of names you\n  // already know. func_name_type_mask is or'ed values from the\n  // FunctionNameType enum.\n  lldb::BreakpointSP CreateBreakpoint(\n      const FileSpecList *containingModules,\n      const FileSpecList *containingSourceFiles, const char *func_names[],\n      size_t num_names, lldb::FunctionNameType func_name_type_mask,\n      lldb::LanguageType language, lldb::addr_t offset, LazyBool skip_prologue,\n      bool internal, bool request_hardware);\n\n  lldb::BreakpointSP\n  CreateBreakpoint(const FileSpecList *containingModules,\n                   const FileSpecList *containingSourceFiles,\n                   const std::vector<std::string> &func_names,\n                   lldb::FunctionNameType func_name_type_mask,\n                   lldb::LanguageType language, lldb::addr_t m_offset,\n                   LazyBool skip_prologue, bool internal,\n                   bool request_hardware);\n\n  // Use this to create a general breakpoint:\n  lldb::BreakpointSP CreateBreakpoint(lldb::SearchFilterSP &filter_sp,\n                                      lldb::BreakpointResolverSP &resolver_sp,\n                                      bool internal, bool request_hardware,\n                                      bool resolve_indirect_symbols);\n\n  // Use this to create a watchpoint:\n  lldb::WatchpointSP CreateWatchpoint(lldb::addr_t addr, size_t size,\n                                      const CompilerType *type, uint32_t kind,\n                                      Status &error);\n\n  lldb::WatchpointSP GetLastCreatedWatchpoint() {\n    return m_last_created_watchpoint;\n  }\n\n  WatchpointList &GetWatchpointList() { return m_watchpoint_list; }\n\n  // Manages breakpoint names:\n  void AddNameToBreakpoint(BreakpointID &id, const char *name, Status &error);\n\n  void AddNameToBreakpoint(lldb::BreakpointSP &bp_sp, const char *name,\n                           Status &error);\n\n  void RemoveNameFromBreakpoint(lldb::BreakpointSP &bp_sp, ConstString name);\n\n  BreakpointName *FindBreakpointName(ConstString name, bool can_create,\n                                     Status &error);\n\n  void DeleteBreakpointName(ConstString name);\n\n  void ConfigureBreakpointName(BreakpointName &bp_name,\n                               const BreakpointOptions &options,\n                               const BreakpointName::Permissions &permissions);\n  void ApplyNameToBreakpoints(BreakpointName &bp_name);\n\n  // This takes ownership of the name obj passed in.\n  void AddBreakpointName(BreakpointName *bp_name);\n\n  void GetBreakpointNames(std::vector<std::string> &names);\n\n  // This call removes ALL breakpoints regardless of permission.\n  void RemoveAllBreakpoints(bool internal_also = false);\n\n  // This removes all the breakpoints, but obeys the ePermDelete on them.\n  void RemoveAllowedBreakpoints();\n\n  void DisableAllBreakpoints(bool internal_also = false);\n\n  void DisableAllowedBreakpoints();\n\n  void EnableAllBreakpoints(bool internal_also = false);\n\n  void EnableAllowedBreakpoints();\n\n  bool DisableBreakpointByID(lldb::break_id_t break_id);\n\n  bool EnableBreakpointByID(lldb::break_id_t break_id);\n\n  bool RemoveBreakpointByID(lldb::break_id_t break_id);\n\n  // The flag 'end_to_end', default to true, signifies that the operation is\n  // performed end to end, for both the debugger and the debuggee.\n\n  bool RemoveAllWatchpoints(bool end_to_end = true);\n\n  bool DisableAllWatchpoints(bool end_to_end = true);\n\n  bool EnableAllWatchpoints(bool end_to_end = true);\n\n  bool ClearAllWatchpointHitCounts();\n\n  bool ClearAllWatchpointHistoricValues();\n\n  bool IgnoreAllWatchpoints(uint32_t ignore_count);\n\n  bool DisableWatchpointByID(lldb::watch_id_t watch_id);\n\n  bool EnableWatchpointByID(lldb::watch_id_t watch_id);\n\n  bool RemoveWatchpointByID(lldb::watch_id_t watch_id);\n\n  bool IgnoreWatchpointByID(lldb::watch_id_t watch_id, uint32_t ignore_count);\n\n  Status SerializeBreakpointsToFile(const FileSpec &file,\n                                    const BreakpointIDList &bp_ids,\n                                    bool append);\n\n  Status CreateBreakpointsFromFile(const FileSpec &file,\n                                   BreakpointIDList &new_bps);\n\n  Status CreateBreakpointsFromFile(const FileSpec &file,\n                                   std::vector<std::string> &names,\n                                   BreakpointIDList &new_bps);\n\n  /// Get \\a load_addr as a callable code load address for this target\n  ///\n  /// Take \\a load_addr and potentially add any address bits that are\n  /// needed to make the address callable. For ARM this can set bit\n  /// zero (if it already isn't) if \\a load_addr is a thumb function.\n  /// If \\a addr_class is set to AddressClass::eInvalid, then the address\n  /// adjustment will always happen. If it is set to an address class\n  /// that doesn't have code in it, LLDB_INVALID_ADDRESS will be\n  /// returned.\n  lldb::addr_t GetCallableLoadAddress(\n      lldb::addr_t load_addr,\n      AddressClass addr_class = AddressClass::eInvalid) const;\n\n  /// Get \\a load_addr as an opcode for this target.\n  ///\n  /// Take \\a load_addr and potentially strip any address bits that are\n  /// needed to make the address point to an opcode. For ARM this can\n  /// clear bit zero (if it already isn't) if \\a load_addr is a\n  /// thumb function and load_addr is in code.\n  /// If \\a addr_class is set to AddressClass::eInvalid, then the address\n  /// adjustment will always happen. If it is set to an address class\n  /// that doesn't have code in it, LLDB_INVALID_ADDRESS will be\n  /// returned.\n  lldb::addr_t\n  GetOpcodeLoadAddress(lldb::addr_t load_addr,\n                       AddressClass addr_class = AddressClass::eInvalid) const;\n\n  // Get load_addr as breakable load address for this target. Take a addr and\n  // check if for any reason there is a better address than this to put a\n  // breakpoint on. If there is then return that address. For MIPS, if\n  // instruction at addr is a delay slot instruction then this method will find\n  // the address of its previous instruction and return that address.\n  lldb::addr_t GetBreakableLoadAddress(lldb::addr_t addr);\n\n  void ModulesDidLoad(ModuleList &module_list);\n\n  void ModulesDidUnload(ModuleList &module_list, bool delete_locations);\n\n  void SymbolsDidLoad(ModuleList &module_list);\n\n  void ClearModules(bool delete_locations);\n\n  /// Called as the last function in Process::DidExec().\n  ///\n  /// Process::DidExec() will clear a lot of state in the process,\n  /// then try to reload a dynamic loader plugin to discover what\n  /// binaries are currently available and then this function should\n  /// be called to allow the target to do any cleanup after everything\n  /// has been figured out. It can remove breakpoints that no longer\n  /// make sense as the exec might have changed the target\n  /// architecture, and unloaded some modules that might get deleted.\n  void DidExec();\n\n  /// Gets the module for the main executable.\n  ///\n  /// Each process has a notion of a main executable that is the file\n  /// that will be executed or attached to. Executable files can have\n  /// dependent modules that are discovered from the object files, or\n  /// discovered at runtime as things are dynamically loaded.\n  ///\n  /// \\return\n  ///     The shared pointer to the executable module which can\n  ///     contains a nullptr Module object if no executable has been\n  ///     set.\n  ///\n  /// \\see DynamicLoader\n  /// \\see ObjectFile::GetDependentModules (FileSpecList&)\n  /// \\see Process::SetExecutableModule(lldb::ModuleSP&)\n  lldb::ModuleSP GetExecutableModule();\n\n  Module *GetExecutableModulePointer();\n\n  /// Set the main executable module.\n  ///\n  /// Each process has a notion of a main executable that is the file\n  /// that will be executed or attached to. Executable files can have\n  /// dependent modules that are discovered from the object files, or\n  /// discovered at runtime as things are dynamically loaded.\n  ///\n  /// Setting the executable causes any of the current dependent\n  /// image information to be cleared and replaced with the static\n  /// dependent image information found by calling\n  /// ObjectFile::GetDependentModules (FileSpecList&) on the main\n  /// executable and any modules on which it depends. Calling\n  /// Process::GetImages() will return the newly found images that\n  /// were obtained from all of the object files.\n  ///\n  /// \\param[in] module_sp\n  ///     A shared pointer reference to the module that will become\n  ///     the main executable for this process.\n  ///\n  /// \\param[in] load_dependent_files\n  ///     If \\b true then ask the object files to track down any\n  ///     known dependent files.\n  ///\n  /// \\see ObjectFile::GetDependentModules (FileSpecList&)\n  /// \\see Process::GetImages()\n  void SetExecutableModule(\n      lldb::ModuleSP &module_sp,\n      LoadDependentFiles load_dependent_files = eLoadDependentsDefault);\n\n  bool LoadScriptingResources(std::list<Status> &errors,\n                              Stream *feedback_stream = nullptr,\n                              bool continue_on_error = true) {\n    return m_images.LoadScriptingResourcesInTarget(\n        this, errors, feedback_stream, continue_on_error);\n  }\n\n  /// Get accessor for the images for this process.\n  ///\n  /// Each process has a notion of a main executable that is the file\n  /// that will be executed or attached to. Executable files can have\n  /// dependent modules that are discovered from the object files, or\n  /// discovered at runtime as things are dynamically loaded. After\n  /// a main executable has been set, the images will contain a list\n  /// of all the files that the executable depends upon as far as the\n  /// object files know. These images will usually contain valid file\n  /// virtual addresses only. When the process is launched or attached\n  /// to, the DynamicLoader plug-in will discover where these images\n  /// were loaded in memory and will resolve the load virtual\n  /// addresses is each image, and also in images that are loaded by\n  /// code.\n  ///\n  /// \\return\n  ///     A list of Module objects in a module list.\n  const ModuleList &GetImages() const { return m_images; }\n\n  ModuleList &GetImages() { return m_images; }\n\n  /// Return whether this FileSpec corresponds to a module that should be\n  /// considered for general searches.\n  ///\n  /// This API will be consulted by the SearchFilterForUnconstrainedSearches\n  /// and any module that returns \\b true will not be searched.  Note the\n  /// SearchFilterForUnconstrainedSearches is the search filter that\n  /// gets used in the CreateBreakpoint calls when no modules is provided.\n  ///\n  /// The target call at present just consults the Platform's call of the\n  /// same name.\n  ///\n  /// \\param[in] module_spec\n  ///     Path to the module.\n  ///\n  /// \\return \\b true if the module should be excluded, \\b false otherwise.\n  bool ModuleIsExcludedForUnconstrainedSearches(const FileSpec &module_spec);\n\n  /// Return whether this module should be considered for general searches.\n  ///\n  /// This API will be consulted by the SearchFilterForUnconstrainedSearches\n  /// and any module that returns \\b true will not be searched.  Note the\n  /// SearchFilterForUnconstrainedSearches is the search filter that\n  /// gets used in the CreateBreakpoint calls when no modules is provided.\n  ///\n  /// The target call at present just consults the Platform's call of the\n  /// same name.\n  ///\n  /// FIXME: When we get time we should add a way for the user to set modules\n  /// that they\n  /// don't want searched, in addition to or instead of the platform ones.\n  ///\n  /// \\param[in] module_sp\n  ///     A shared pointer reference to the module that checked.\n  ///\n  /// \\return \\b true if the module should be excluded, \\b false otherwise.\n  bool\n  ModuleIsExcludedForUnconstrainedSearches(const lldb::ModuleSP &module_sp);\n\n  const ArchSpec &GetArchitecture() const { return m_arch.GetSpec(); }\n\n  /// Set the architecture for this target.\n  ///\n  /// If the current target has no Images read in, then this just sets the\n  /// architecture, which will be used to select the architecture of the\n  /// ExecutableModule when that is set. If the current target has an\n  /// ExecutableModule, then calling SetArchitecture with a different\n  /// architecture from the currently selected one will reset the\n  /// ExecutableModule to that slice of the file backing the ExecutableModule.\n  /// If the file backing the ExecutableModule does not contain a fork of this\n  /// architecture, then this code will return false, and the architecture\n  /// won't be changed. If the input arch_spec is the same as the already set\n  /// architecture, this is a no-op.\n  ///\n  /// \\param[in] arch_spec\n  ///     The new architecture.\n  ///\n  /// \\param[in] set_platform\n  ///     If \\b true, then the platform will be adjusted if the currently\n  ///     selected platform is not compatible with the architecture being set.\n  ///     If \\b false, then just the architecture will be set even if the\n  ///     currently selected platform isn't compatible (in case it might be\n  ///     manually set following this function call).\n  ///\n  /// \\return\n  ///     \\b true if the architecture was successfully set, \\bfalse otherwise.\n  bool SetArchitecture(const ArchSpec &arch_spec, bool set_platform = false);\n\n  bool MergeArchitecture(const ArchSpec &arch_spec);\n\n  Architecture *GetArchitecturePlugin() const { return m_arch.GetPlugin(); }\n\n  Debugger &GetDebugger() { return m_debugger; }\n\n  size_t ReadMemoryFromFileCache(const Address &addr, void *dst, size_t dst_len,\n                                 Status &error);\n\n  // Reading memory through the target allows us to skip going to the process\n  // for reading memory if possible and it allows us to try and read from any\n  // constant sections in our object files on disk. If you always want live\n  // program memory, read straight from the process. If you possibly want to\n  // read from const sections in object files, read from the target. This\n  // version of ReadMemory will try and read memory from the process if the\n  // process is alive. The order is:\n  // 1 - if (prefer_file_cache == true) then read from object file cache\n  // 2 - if there is a valid process, try and read from its memory\n  // 3 - if (prefer_file_cache == false) then read from object file cache\n  size_t ReadMemory(const Address &addr, bool prefer_file_cache, void *dst,\n                    size_t dst_len, Status &error,\n                    lldb::addr_t *load_addr_ptr = nullptr);\n\n  size_t ReadCStringFromMemory(const Address &addr, std::string &out_str,\n                               Status &error);\n\n  size_t ReadCStringFromMemory(const Address &addr, char *dst,\n                               size_t dst_max_len, Status &result_error);\n\n  size_t ReadScalarIntegerFromMemory(const Address &addr,\n                                     bool prefer_file_cache, uint32_t byte_size,\n                                     bool is_signed, Scalar &scalar,\n                                     Status &error);\n\n  uint64_t ReadUnsignedIntegerFromMemory(const Address &addr,\n                                         bool prefer_file_cache,\n                                         size_t integer_byte_size,\n                                         uint64_t fail_value, Status &error);\n\n  bool ReadPointerFromMemory(const Address &addr, bool prefer_file_cache,\n                             Status &error, Address &pointer_addr);\n\n  SectionLoadList &GetSectionLoadList() {\n    return m_section_load_history.GetCurrentSectionLoadList();\n  }\n\n  static Target *GetTargetFromContexts(const ExecutionContext *exe_ctx_ptr,\n                                       const SymbolContext *sc_ptr);\n\n  // lldb::ExecutionContextScope pure virtual functions\n  lldb::TargetSP CalculateTarget() override;\n\n  lldb::ProcessSP CalculateProcess() override;\n\n  lldb::ThreadSP CalculateThread() override;\n\n  lldb::StackFrameSP CalculateStackFrame() override;\n\n  void CalculateExecutionContext(ExecutionContext &exe_ctx) override;\n\n  PathMappingList &GetImageSearchPathList();\n\n  llvm::Expected<TypeSystem &>\n  GetScratchTypeSystemForLanguage(lldb::LanguageType language,\n                                  bool create_on_demand = true);\n\n  std::vector<TypeSystem *> GetScratchTypeSystems(bool create_on_demand = true);\n\n  PersistentExpressionState *\n  GetPersistentExpressionStateForLanguage(lldb::LanguageType language);\n\n  // Creates a UserExpression for the given language, the rest of the\n  // parameters have the same meaning as for the UserExpression constructor.\n  // Returns a new-ed object which the caller owns.\n\n  UserExpression *\n  GetUserExpressionForLanguage(llvm::StringRef expr, llvm::StringRef prefix,\n                               lldb::LanguageType language,\n                               Expression::ResultType desired_type,\n                               const EvaluateExpressionOptions &options,\n                               ValueObject *ctx_obj, Status &error);\n\n  // Creates a FunctionCaller for the given language, the rest of the\n  // parameters have the same meaning as for the FunctionCaller constructor.\n  // Since a FunctionCaller can't be\n  // IR Interpreted, it makes no sense to call this with an\n  // ExecutionContextScope that lacks\n  // a Process.\n  // Returns a new-ed object which the caller owns.\n\n  FunctionCaller *GetFunctionCallerForLanguage(lldb::LanguageType language,\n                                               const CompilerType &return_type,\n                                               const Address &function_address,\n                                               const ValueList &arg_value_list,\n                                               const char *name, Status &error);\n\n  /// Creates and installs a UtilityFunction for the given language.\n  llvm::Expected<std::unique_ptr<UtilityFunction>>\n  CreateUtilityFunction(std::string expression, std::string name,\n                        lldb::LanguageType language, ExecutionContext &exe_ctx);\n\n  // Install any files through the platform that need be to installed prior to\n  // launching or attaching.\n  Status Install(ProcessLaunchInfo *launch_info);\n\n  bool ResolveFileAddress(lldb::addr_t load_addr, Address &so_addr);\n\n  bool ResolveLoadAddress(lldb::addr_t load_addr, Address &so_addr,\n                          uint32_t stop_id = SectionLoadHistory::eStopIDNow);\n\n  bool SetSectionLoadAddress(const lldb::SectionSP &section,\n                             lldb::addr_t load_addr,\n                             bool warn_multiple = false);\n\n  size_t UnloadModuleSections(const lldb::ModuleSP &module_sp);\n\n  size_t UnloadModuleSections(const ModuleList &module_list);\n\n  bool SetSectionUnloaded(const lldb::SectionSP &section_sp);\n\n  bool SetSectionUnloaded(const lldb::SectionSP &section_sp,\n                          lldb::addr_t load_addr);\n\n  void ClearAllLoadedSections();\n\n  /// Set the \\a Trace object containing processor trace information of this\n  /// target.\n  ///\n  /// \\param[in] trace_sp\n  ///   The trace object.\n  void SetTrace(const lldb::TraceSP &trace_sp);\n\n  /// Get the \\a Trace object containing processor trace information of this\n  /// target.\n  ///\n  /// \\return\n  ///   The trace object. It might be undefined.\n  const lldb::TraceSP &GetTrace();\n\n  // Since expressions results can persist beyond the lifetime of a process,\n  // and the const expression results are available after a process is gone, we\n  // provide a way for expressions to be evaluated from the Target itself. If\n  // an expression is going to be run, then it should have a frame filled in in\n  // the execution context.\n  lldb::ExpressionResults EvaluateExpression(\n      llvm::StringRef expression, ExecutionContextScope *exe_scope,\n      lldb::ValueObjectSP &result_valobj_sp,\n      const EvaluateExpressionOptions &options = EvaluateExpressionOptions(),\n      std::string *fixed_expression = nullptr, ValueObject *ctx_obj = nullptr);\n\n  lldb::ExpressionVariableSP GetPersistentVariable(ConstString name);\n\n  lldb::addr_t GetPersistentSymbol(ConstString name);\n\n  /// This method will return the address of the starting function for\n  /// this binary, e.g. main() or its equivalent.  This can be used as\n  /// an address of a function that is not called once a binary has\n  /// started running - e.g. as a return address for inferior function\n  /// calls that are unambiguous completion of the function call, not\n  /// called during the course of the inferior function code running.\n  ///\n  /// If no entry point can be found, an invalid address is returned.\n  ///\n  /// \\param [out] err\n  ///     This object will be set to failure if no entry address could\n  ///     be found, and may contain a helpful error message.\n  //\n  /// \\return\n  ///     Returns the entry address for this program, or an error\n  ///     if none can be found.\n  llvm::Expected<lldb_private::Address> GetEntryPointAddress();\n\n  // Target Stop Hooks\n  class StopHook : public UserID {\n  public:\n    StopHook(const StopHook &rhs);\n    virtual ~StopHook() = default;\n\n    enum class StopHookKind  : uint32_t { CommandBased = 0, ScriptBased };\n    enum class StopHookResult : uint32_t {\n      KeepStopped = 0,\n      RequestContinue,\n      AlreadyContinued\n    };\n\n    lldb::TargetSP &GetTarget() { return m_target_sp; }\n\n    // Set the specifier.  The stop hook will own the specifier, and is\n    // responsible for deleting it when we're done.\n    void SetSpecifier(SymbolContextSpecifier *specifier);\n\n    SymbolContextSpecifier *GetSpecifier() { return m_specifier_sp.get(); }\n\n    bool ExecutionContextPasses(const ExecutionContext &exe_ctx);\n\n    // Called on stop, this gets passed the ExecutionContext for each \"stop\n    // with a reason\" thread.  It should add to the stream whatever text it\n    // wants to show the user, and return False to indicate it wants the target\n    // not to stop.\n    virtual StopHookResult HandleStop(ExecutionContext &exe_ctx,\n                                      lldb::StreamSP output) = 0;\n\n    // Set the Thread Specifier.  The stop hook will own the thread specifier,\n    // and is responsible for deleting it when we're done.\n    void SetThreadSpecifier(ThreadSpec *specifier);\n\n    ThreadSpec *GetThreadSpecifier() { return m_thread_spec_up.get(); }\n\n    bool IsActive() { return m_active; }\n\n    void SetIsActive(bool is_active) { m_active = is_active; }\n\n    void SetAutoContinue(bool auto_continue) {\n      m_auto_continue = auto_continue;\n    }\n\n    bool GetAutoContinue() const { return m_auto_continue; }\n\n    void GetDescription(Stream *s, lldb::DescriptionLevel level) const;\n    virtual void GetSubclassDescription(Stream *s,\n                                        lldb::DescriptionLevel level) const = 0;\n\n  protected:\n    lldb::TargetSP m_target_sp;\n    lldb::SymbolContextSpecifierSP m_specifier_sp;\n    std::unique_ptr<ThreadSpec> m_thread_spec_up;\n    bool m_active = true;\n    bool m_auto_continue = false;\n\n    StopHook(lldb::TargetSP target_sp, lldb::user_id_t uid);\n  };\n\n  class StopHookCommandLine : public StopHook {\n  public:\n    virtual ~StopHookCommandLine() = default;\n\n    StringList &GetCommands() { return m_commands; }\n    void SetActionFromString(const std::string &strings);\n    void SetActionFromStrings(const std::vector<std::string> &strings);\n\n    StopHookResult HandleStop(ExecutionContext &exc_ctx,\n                              lldb::StreamSP output_sp) override;\n    void GetSubclassDescription(Stream *s,\n                                lldb::DescriptionLevel level) const override;\n\n  private:\n    StringList m_commands;\n    // Use CreateStopHook to make a new empty stop hook. The GetCommandPointer\n    // and fill it with commands, and SetSpecifier to set the specifier shared\n    // pointer (can be null, that will match anything.)\n    StopHookCommandLine(lldb::TargetSP target_sp, lldb::user_id_t uid)\n        : StopHook(target_sp, uid) {}\n    friend class Target;\n  };\n\n  class StopHookScripted : public StopHook {\n  public:\n    virtual ~StopHookScripted() = default;\n    StopHookResult HandleStop(ExecutionContext &exc_ctx,\n                              lldb::StreamSP output) override;\n\n    Status SetScriptCallback(std::string class_name,\n                             StructuredData::ObjectSP extra_args_sp);\n\n    void GetSubclassDescription(Stream *s,\n                                lldb::DescriptionLevel level) const override;\n\n  private:\n    std::string m_class_name;\n    /// This holds the dictionary of keys & values that can be used to\n    /// parametrize any given callback's behavior.\n    StructuredDataImpl *m_extra_args; // We own this structured data,\n                                      // but the SD itself manages the UP.\n    /// This holds the python callback object.\n    StructuredData::GenericSP m_implementation_sp;\n\n    /// Use CreateStopHook to make a new empty stop hook. The GetCommandPointer\n    /// and fill it with commands, and SetSpecifier to set the specifier shared\n    /// pointer (can be null, that will match anything.)\n    StopHookScripted(lldb::TargetSP target_sp, lldb::user_id_t uid)\n        : StopHook(target_sp, uid) {}\n    friend class Target;\n  };\n\n  typedef std::shared_ptr<StopHook> StopHookSP;\n\n  /// Add an empty stop hook to the Target's stop hook list, and returns a\n  /// shared pointer to it in new_hook. Returns the id of the new hook.\n  StopHookSP CreateStopHook(StopHook::StopHookKind kind);\n\n  /// If you tried to create a stop hook, and that failed, call this to\n  /// remove the stop hook, as it will also reset the stop hook counter.\n  void UndoCreateStopHook(lldb::user_id_t uid);\n\n  // Runs the stop hooks that have been registered for this target.\n  // Returns true if the stop hooks cause the target to resume.\n  bool RunStopHooks();\n\n  size_t GetStopHookSize();\n\n  bool SetSuppresStopHooks(bool suppress) {\n    bool old_value = m_suppress_stop_hooks;\n    m_suppress_stop_hooks = suppress;\n    return old_value;\n  }\n\n  bool GetSuppressStopHooks() { return m_suppress_stop_hooks; }\n\n  bool RemoveStopHookByID(lldb::user_id_t uid);\n\n  void RemoveAllStopHooks();\n\n  StopHookSP GetStopHookByID(lldb::user_id_t uid);\n\n  bool SetStopHookActiveStateByID(lldb::user_id_t uid, bool active_state);\n\n  void SetAllStopHooksActiveState(bool active_state);\n\n  size_t GetNumStopHooks() const { return m_stop_hooks.size(); }\n\n  StopHookSP GetStopHookAtIndex(size_t index) {\n    if (index >= GetNumStopHooks())\n      return StopHookSP();\n    StopHookCollection::iterator pos = m_stop_hooks.begin();\n\n    while (index > 0) {\n      pos++;\n      index--;\n    }\n    return (*pos).second;\n  }\n\n  lldb::PlatformSP GetPlatform() { return m_platform_sp; }\n\n  void SetPlatform(const lldb::PlatformSP &platform_sp) {\n    m_platform_sp = platform_sp;\n  }\n\n  SourceManager &GetSourceManager();\n\n  ClangModulesDeclVendor *GetClangModulesDeclVendor();\n\n  // Methods.\n  lldb::SearchFilterSP\n  GetSearchFilterForModule(const FileSpec *containingModule);\n\n  lldb::SearchFilterSP\n  GetSearchFilterForModuleList(const FileSpecList *containingModuleList);\n\n  lldb::SearchFilterSP\n  GetSearchFilterForModuleAndCUList(const FileSpecList *containingModules,\n                                    const FileSpecList *containingSourceFiles);\n\n  lldb::REPLSP GetREPL(Status &err, lldb::LanguageType language,\n                       const char *repl_options, bool can_create);\n\n  void SetREPL(lldb::LanguageType language, lldb::REPLSP repl_sp);\n\n  StackFrameRecognizerManager &GetFrameRecognizerManager() {\n    return *m_frame_recognizer_manager_up;\n  }\n\nprotected:\n  /// Implementing of ModuleList::Notifier.\n\n  void NotifyModuleAdded(const ModuleList &module_list,\n                         const lldb::ModuleSP &module_sp) override;\n\n  void NotifyModuleRemoved(const ModuleList &module_list,\n                           const lldb::ModuleSP &module_sp) override;\n\n  void NotifyModuleUpdated(const ModuleList &module_list,\n                           const lldb::ModuleSP &old_module_sp,\n                           const lldb::ModuleSP &new_module_sp) override;\n\n  void NotifyWillClearList(const ModuleList &module_list) override;\n\n  void NotifyModulesRemoved(lldb_private::ModuleList &module_list) override;\n\n  class Arch {\n  public:\n    explicit Arch(const ArchSpec &spec);\n    const Arch &operator=(const ArchSpec &spec);\n\n    const ArchSpec &GetSpec() const { return m_spec; }\n    Architecture *GetPlugin() const { return m_plugin_up.get(); }\n\n  private:\n    ArchSpec m_spec;\n    std::unique_ptr<Architecture> m_plugin_up;\n  };\n  // Member variables.\n  Debugger &m_debugger;\n  lldb::PlatformSP m_platform_sp; ///< The platform for this target.\n  std::recursive_mutex m_mutex; ///< An API mutex that is used by the lldb::SB*\n                                /// classes make the SB interface thread safe\n  /// When the private state thread calls SB API's - usually because it is\n  /// running OS plugin or Python ThreadPlan code - it should not block on the\n  /// API mutex that is held by the code that kicked off the sequence of events\n  /// that led us to run the code.  We hand out this mutex instead when we\n  /// detect that code is running on the private state thread.\n  std::recursive_mutex m_private_mutex;\n  Arch m_arch;\n  ModuleList m_images; ///< The list of images for this process (shared\n                       /// libraries and anything dynamically loaded).\n  SectionLoadHistory m_section_load_history;\n  BreakpointList m_breakpoint_list;\n  BreakpointList m_internal_breakpoint_list;\n  using BreakpointNameList = std::map<ConstString, BreakpointName *>;\n  BreakpointNameList m_breakpoint_names;\n\n  lldb::BreakpointSP m_last_created_breakpoint;\n  WatchpointList m_watchpoint_list;\n  lldb::WatchpointSP m_last_created_watchpoint;\n  // We want to tightly control the process destruction process so we can\n  // correctly tear down everything that we need to, so the only class that\n  // knows about the process lifespan is this target class.\n  lldb::ProcessSP m_process_sp;\n  lldb::SearchFilterSP m_search_filter_sp;\n  PathMappingList m_image_search_paths;\n  TypeSystemMap m_scratch_type_system_map;\n\n  typedef std::map<lldb::LanguageType, lldb::REPLSP> REPLMap;\n  REPLMap m_repl_map;\n\n  std::unique_ptr<ClangModulesDeclVendor> m_clang_modules_decl_vendor_up;\n\n  lldb::SourceManagerUP m_source_manager_up;\n\n  typedef std::map<lldb::user_id_t, StopHookSP> StopHookCollection;\n  StopHookCollection m_stop_hooks;\n  lldb::user_id_t m_stop_hook_next_id;\n  bool m_valid;\n  bool m_suppress_stop_hooks;\n  bool m_is_dummy_target;\n  unsigned m_next_persistent_variable_index = 0;\n  /// An optional \\a lldb_private::Trace object containing processor trace\n  /// information of this target.\n  lldb::TraceSP m_trace_sp;\n  /// Stores the frame recognizers of this target.\n  lldb::StackFrameRecognizerManagerUP m_frame_recognizer_manager_up;\n\n  static void ImageSearchPathsChanged(const PathMappingList &path_list,\n                                      void *baton);\n\n  // Utilities for `statistics` command.\nprivate:\n  std::vector<uint32_t> m_stats_storage;\n  bool m_collecting_stats = false;\n\npublic:\n  void SetCollectingStats(bool v) { m_collecting_stats = v; }\n\n  bool GetCollectingStats() { return m_collecting_stats; }\n\n  void IncrementStats(lldb_private::StatisticKind key) {\n    if (!GetCollectingStats())\n      return;\n    lldbassert(key < lldb_private::StatisticKind::StatisticMax &&\n               \"invalid statistics!\");\n    m_stats_storage[key] += 1;\n  }\n\n  std::vector<uint32_t> GetStatistics() { return m_stats_storage; }\n\nprivate:\n  /// Construct with optional file and arch.\n  ///\n  /// This member is private. Clients must use\n  /// TargetList::CreateTarget(const FileSpec*, const ArchSpec*)\n  /// so all targets can be tracked from the central target list.\n  ///\n  /// \\see TargetList::CreateTarget(const FileSpec*, const ArchSpec*)\n  Target(Debugger &debugger, const ArchSpec &target_arch,\n         const lldb::PlatformSP &platform_sp, bool is_dummy_target);\n\n  // Helper function.\n  bool ProcessIsValid();\n\n  // Copy breakpoints, stop hooks and so forth from the dummy target:\n  void PrimeFromDummyTarget(Target &target);\n\n  void AddBreakpoint(lldb::BreakpointSP breakpoint_sp, bool internal);\n\n  void FinalizeFileActions(ProcessLaunchInfo &info);\n\n  Target(const Target &) = delete;\n  const Target &operator=(const Target &) = delete;\n};\n\n} // namespace lldb_private\n\n#endif // LLDB_TARGET_TARGET_H\n"}, "25": {"id": 25, "path": "/home/vsts/work/1/llvm-project/lldb/include/lldb/Target/ThreadSpec.h", "content": "//===-- ThreadSpec.h --------------------------------------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLDB_TARGET_THREADSPEC_H\n#define LLDB_TARGET_THREADSPEC_H\n\n#include \"lldb/Utility/StructuredData.h\"\n#include \"lldb/lldb-private.h\"\n#include <string>\n\nnamespace lldb_private {\n\n// Note: For now the thread spec has only fixed elements -\n//   Thread ID\n//   Thread Index\n//   Thread Name\n//   Thread Queue Name\n//\n//  But if we need more generality, we can hang a key/value map off of this\n//  structure.\n//  That's why the thread matches spec test is done as a virtual method in\n//  Thread::MatchesSpec,\n//  since it is the native thread that would know how to interpret the keys.\n//  I was going to do the Queue Name this way out of sheer orneriness, but that\n//  seems a\n//  sufficiently general concept, so I put it in here on its own.\n\nclass ThreadSpec {\npublic:\n  ThreadSpec();\n\n  static std::unique_ptr<ThreadSpec>\n  CreateFromStructuredData(const StructuredData::Dictionary &data_dict,\n                           Status &error);\n\n  StructuredData::ObjectSP SerializeToStructuredData();\n\n  static const char *GetSerializationKey() { return \"ThreadSpec\"; }\n\n  void SetIndex(uint32_t index) { m_index = index; }\n\n  void SetTID(lldb::tid_t tid) { m_tid = tid; }\n\n  void SetName(llvm::StringRef name) { m_name = std::string(name); }\n\n  void SetQueueName(llvm::StringRef queue_name) {\n    m_queue_name = std::string(queue_name);\n  }\n\n  uint32_t GetIndex() const { return m_index; }\n\n  lldb::tid_t GetTID() const { return m_tid; }\n\n  const char *GetName() const;\n\n  const char *GetQueueName() const;\n\n  bool TIDMatches(lldb::tid_t thread_id) const {\n    if (m_tid == LLDB_INVALID_THREAD_ID || thread_id == LLDB_INVALID_THREAD_ID)\n      return true;\n    else\n      return thread_id == m_tid;\n  }\n\n  bool TIDMatches(Thread &thread) const;\n\n  bool IndexMatches(uint32_t index) const {\n    if (m_index == UINT32_MAX || index == UINT32_MAX)\n      return true;\n    else\n      return index == m_index;\n  }\n\n  bool IndexMatches(Thread &thread) const;\n\n  bool NameMatches(const char *name) const {\n    if (m_name.empty())\n      return true;\n    else if (name == nullptr)\n      return false;\n    else\n      return m_name == name;\n  }\n\n  bool NameMatches(Thread &thread) const;\n\n  bool QueueNameMatches(const char *queue_name) const {\n    if (m_queue_name.empty())\n      return true;\n    else if (queue_name == nullptr)\n      return false;\n    else\n      return m_queue_name == queue_name;\n  }\n\n  bool QueueNameMatches(Thread &thread) const;\n\n  bool ThreadPassesBasicTests(Thread &thread) const;\n\n  bool HasSpecification() const;\n\n  void GetDescription(Stream *s, lldb::DescriptionLevel level) const;\n\nprivate:\n  enum class OptionNames {\n    ThreadIndex = 0,\n    ThreadID,\n    ThreadName,\n    QueueName,\n    LastOptionName\n  };\n  static const char *g_option_names[(size_t)OptionNames::LastOptionName];\n\n  static const char *GetKey(OptionNames enum_value) {\n    return g_option_names[(size_t) enum_value];\n  }\n\n  uint32_t m_index;\n  lldb::tid_t m_tid;\n  std::string m_name;\n  std::string m_queue_name;\n};\n\n} // namespace lldb_private\n\n#endif // LLDB_TARGET_THREADSPEC_H\n"}, "26": {"id": 26, "path": "/home/vsts/work/1/llvm-project/lldb/include/lldb/Utility/Args.h", "content": "//===-- Args.h --------------------------------------------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLDB_UTILITY_ARGS_H\n#define LLDB_UTILITY_ARGS_H\n\n#include \"lldb/Utility/Environment.h\"\n#include \"lldb/lldb-private-types.h\"\n#include \"lldb/lldb-types.h\"\n#include \"llvm/ADT/ArrayRef.h\"\n#include \"llvm/ADT/StringRef.h\"\n#include \"llvm/Support/YAMLTraits.h\"\n#include <string>\n#include <utility>\n#include <vector>\n\nnamespace lldb_private {\n\n/// \\class Args Args.h \"lldb/Utility/Args.h\"\n/// A command line argument class.\n///\n/// The Args class is designed to be fed a command line. The command line is\n/// copied into an internal buffer and then split up into arguments. Arguments\n/// are space delimited if there are no quotes (single, double, or backtick\n/// quotes) surrounding the argument. Spaces can be escaped using a \\\n/// character to avoid having to surround an argument that contains a space\n/// with quotes.\nclass Args {\npublic:\n  struct ArgEntry {\n  private:\n    friend class Args;\n    friend struct llvm::yaml::MappingTraits<Args>;\n    friend struct llvm::yaml::MappingTraits<Args::ArgEntry>;\n\n    std::unique_ptr<char[]> ptr;\n    char quote;\n\n    char *data() { return ptr.get(); }\n\n  public:\n    ArgEntry() = default;\n    ArgEntry(llvm::StringRef str, char quote);\n\n    llvm::StringRef ref() const { return c_str(); }\n    const char *c_str() const { return ptr.get(); }\n\n    /// Returns true if this argument was quoted in any way.\n    bool IsQuoted() const { return quote != '\\0'; }\n    char GetQuoteChar() const { return quote; }\n  };\n\n  /// Construct with an option command string.\n  ///\n  /// \\param[in] command\n  ///     A NULL terminated command that will be copied and split up\n  ///     into arguments.\n  ///\n  /// \\see Args::SetCommandString(llvm::StringRef)\n  Args(llvm::StringRef command = llvm::StringRef());\n\n  Args(const Args &rhs);\n  explicit Args(const StringList &list);\n  explicit Args(llvm::ArrayRef<llvm::StringRef> args);\n\n  Args &operator=(const Args &rhs);\n\n  /// Destructor.\n  ~Args();\n\n  explicit Args(const Environment &env) : Args() {\n    SetArguments(const_cast<const char **>(env.getEnvp().get()));\n  }\n\n  explicit operator Environment() const { return GetConstArgumentVector(); }\n\n  /// Dump all entries to the stream \\a s using label \\a label_name.\n  ///\n  /// If label_name is nullptr, the dump operation is skipped.\n  ///\n  /// \\param[in] s\n  ///     The stream to which to dump all arguments in the argument\n  ///     vector.\n  /// \\param[in] label_name\n  ///     The label_name to use as the label printed for each\n  ///     entry of the args like so:\n  ///       {label_name}[{index}]={value}\n  void Dump(Stream &s, const char *label_name = \"argv\") const;\n\n  /// Sets the command string contained by this object.\n  ///\n  /// The command string will be copied and split up into arguments that can\n  /// be accessed via the accessor functions.\n  ///\n  /// \\param[in] command\n  ///     A command StringRef that will be copied and split up\n  ///     into arguments.\n  ///\n  /// \\see Args::GetArgumentCount() const\n  /// \\see Args::GetArgumentAtIndex (size_t) const @see\n  /// Args::GetArgumentVector () \\see Args::Shift () \\see Args::Unshift (const\n  /// char *)\n  void SetCommandString(llvm::StringRef command);\n\n  bool GetCommandString(std::string &command) const;\n\n  bool GetQuotedCommandString(std::string &command) const;\n\n  /// Gets the number of arguments left in this command object.\n  ///\n  /// \\return\n  ///     The number or arguments in this object.\n  size_t GetArgumentCount() const { return m_entries.size(); }\n\n  bool empty() const { return GetArgumentCount() == 0; }\n\n  /// Gets the NULL terminated C string argument pointer for the argument at\n  /// index \\a idx.\n  ///\n  /// \\return\n  ///     The NULL terminated C string argument pointer if \\a idx is a\n  ///     valid argument index, NULL otherwise.\n  const char *GetArgumentAtIndex(size_t idx) const;\n\n  llvm::ArrayRef<ArgEntry> entries() const { return m_entries; }\n\n  using const_iterator = std::vector<ArgEntry>::const_iterator;\n\n  const_iterator begin() const { return m_entries.begin(); }\n  const_iterator end() const { return m_entries.end(); }\n\n  size_t size() const { return GetArgumentCount(); }\n  const ArgEntry &operator[](size_t n) const { return m_entries[n]; }\n\n  /// Gets the argument vector.\n  ///\n  /// The value returned by this function can be used by any function that\n  /// takes and vector. The return value is just like \\a argv in the standard\n  /// C entry point function:\n  ///     \\code\n  ///         int main (int argc, const char **argv);\n  ///     \\endcode\n  ///\n  /// \\return\n  ///     An array of NULL terminated C string argument pointers that\n  ///     also has a terminating NULL C string pointer\n  char **GetArgumentVector();\n\n  /// Gets the argument vector.\n  ///\n  /// The value returned by this function can be used by any function that\n  /// takes and vector. The return value is just like \\a argv in the standard\n  /// C entry point function:\n  ///     \\code\n  ///         int main (int argc, const char **argv);\n  ///     \\endcode\n  ///\n  /// \\return\n  ///     An array of NULL terminate C string argument pointers that\n  ///     also has a terminating NULL C string pointer\n  const char **GetConstArgumentVector() const;\n\n  /// Gets the argument as an ArrayRef. Note that the return value does *not*\n  /// have a nullptr const char * at the end, as the size of the list is\n  /// embedded in the ArrayRef object.\n  llvm::ArrayRef<const char *> GetArgumentArrayRef() const {\n    return llvm::makeArrayRef(m_argv).drop_back();\n  }\n\n  /// Appends a new argument to the end of the list argument list.\n  ///\n  /// \\param[in] arg_str\n  ///     The new argument.\n  ///\n  /// \\param[in] quote_char\n  ///     If the argument was originally quoted, put in the quote char here.\n  void AppendArgument(llvm::StringRef arg_str, char quote_char = '\\0');\n\n  void AppendArguments(const Args &rhs);\n\n  void AppendArguments(const char **argv);\n\n  /// Insert the argument value at index \\a idx to \\a arg_str.\n  ///\n  /// \\param[in] idx\n  ///     The index of where to insert the argument.\n  ///\n  /// \\param[in] arg_str\n  ///     The new argument.\n  ///\n  /// \\param[in] quote_char\n  ///     If the argument was originally quoted, put in the quote char here.\n  void InsertArgumentAtIndex(size_t idx, llvm::StringRef arg_str,\n                             char quote_char = '\\0');\n\n  /// Replaces the argument value at index \\a idx to \\a arg_str if \\a idx is\n  /// a valid argument index.\n  ///\n  /// \\param[in] idx\n  ///     The index of the argument that will have its value replaced.\n  ///\n  /// \\param[in] arg_str\n  ///     The new argument.\n  ///\n  /// \\param[in] quote_char\n  ///     If the argument was originally quoted, put in the quote char here.\n  void ReplaceArgumentAtIndex(size_t idx, llvm::StringRef arg_str,\n                              char quote_char = '\\0');\n\n  /// Deletes the argument value at index\n  /// if \\a idx is a valid argument index.\n  ///\n  /// \\param[in] idx\n  ///     The index of the argument that will have its value replaced.\n  ///\n  void DeleteArgumentAtIndex(size_t idx);\n\n  /// Sets the argument vector value, optionally copying all arguments into an\n  /// internal buffer.\n  ///\n  /// Sets the arguments to match those found in \\a argv. All argument strings\n  /// will be copied into an internal buffers.\n  //\n  //  FIXME: Handle the quote character somehow.\n  void SetArguments(size_t argc, const char **argv);\n\n  void SetArguments(const char **argv);\n\n  /// Shifts the first argument C string value of the array off the argument\n  /// array.\n  ///\n  /// The string value will be freed, so a copy of the string should be made\n  /// by calling Args::GetArgumentAtIndex (size_t) const first and copying the\n  /// returned value before calling Args::Shift().\n  ///\n  /// \\see Args::GetArgumentAtIndex (size_t) const\n  void Shift();\n\n  /// Inserts a class owned copy of \\a arg_str at the beginning of the\n  /// argument vector.\n  ///\n  /// A copy \\a arg_str will be made.\n  ///\n  /// \\param[in] arg_str\n  ///     The argument to push on the front of the argument stack.\n  ///\n  /// \\param[in] quote_char\n  ///     If the argument was originally quoted, put in the quote char here.\n  void Unshift(llvm::StringRef arg_str, char quote_char = '\\0');\n\n  /// Clear the arguments.\n  ///\n  /// For re-setting or blanking out the list of arguments.\n  void Clear();\n\n  static lldb::Encoding\n  StringToEncoding(llvm::StringRef s,\n                   lldb::Encoding fail_value = lldb::eEncodingInvalid);\n\n  static uint32_t StringToGenericRegister(llvm::StringRef s);\n\n  static std::string GetShellSafeArgument(const FileSpec &shell,\n                                          llvm::StringRef unsafe_arg);\n\n  /// EncodeEscapeSequences will change the textual representation of common\n  /// escape sequences like \"\\n\" (two characters) into a single '\\n'. It does\n  /// this for all of the supported escaped sequences and for the \\0ooo (octal)\n  /// and \\xXX (hex). The resulting \"dst\" string will contain the character\n  /// versions of all supported escape sequences. The common supported escape\n  /// sequences are: \"\\a\", \"\\b\", \"\\f\", \"\\n\", \"\\r\", \"\\t\", \"\\v\", \"\\'\", \"\\\"\", \"\\\\\".\n  static void EncodeEscapeSequences(const char *src, std::string &dst);\n\n  /// ExpandEscapeSequences will change a string of possibly non-printable\n  /// characters and expand them into text. So '\\n' will turn into two\n  /// characters like \"\\n\" which is suitable for human reading. When a character\n  /// is not printable and isn't one of the common in escape sequences listed in\n  /// the help for EncodeEscapeSequences, then it will be encoded as octal.\n  /// Printable characters are left alone.\n  static void ExpandEscapedCharacters(const char *src, std::string &dst);\n\n  static std::string EscapeLLDBCommandArgument(const std::string &arg,\n                                               char quote_char);\n\nprivate:\n  friend struct llvm::yaml::MappingTraits<Args>;\n\n  std::vector<ArgEntry> m_entries;\n  /// The arguments as C strings with a trailing nullptr element.\n  ///\n  /// These strings are owned by the ArgEntry object in m_entries with the\n  /// same index.\n  std::vector<char *> m_argv;\n};\n\n/// \\class OptionsWithRaw Args.h \"lldb/Utility/Args.h\"\n/// A pair of an option list with a 'raw' string as a suffix.\n///\n/// This class works similar to Args, but handles the case where we have a\n/// trailing string that shouldn't be interpreted as a list of arguments but\n/// preserved as is. It is also only useful for handling command line options\n/// (e.g. '-foo bar -i0') that start with a dash.\n///\n/// The leading option list is optional. If the first non-space character\n/// in the string starts with a dash, and the string contains an argument\n/// that is an unquoted double dash (' -- '), then everything up to the double\n/// dash is parsed as a list of arguments. Everything after the double dash\n/// is interpreted as the raw suffix string. Note that the space behind the\n/// double dash is not part of the raw suffix.\n///\n/// All strings not matching the above format as considered to be just a raw\n/// string without any options.\n///\n/// \\see Args\nclass OptionsWithRaw {\npublic:\n  /// Parse the given string as a list of optional arguments with a raw suffix.\n  ///\n  /// See the class description for a description of the input format.\n  ///\n  /// \\param[in] argument_string\n  ///     The string that should be parsed.\n  explicit OptionsWithRaw(llvm::StringRef argument_string);\n\n  /// Returns true if there are any arguments before the raw suffix.\n  bool HasArgs() const { return m_has_args; }\n\n  /// Returns the list of arguments.\n  ///\n  /// You can only call this method if HasArgs returns true.\n  Args &GetArgs() {\n    assert(m_has_args);\n    return m_args;\n  }\n\n  /// Returns the list of arguments.\n  ///\n  /// You can only call this method if HasArgs returns true.\n  const Args &GetArgs() const {\n    assert(m_has_args);\n    return m_args;\n  }\n\n  /// Returns the part of the input string that was used for parsing the\n  /// argument list. This string also includes the double dash that is used\n  /// for separating the argument list from the suffix.\n  ///\n  /// You can only call this method if HasArgs returns true.\n  llvm::StringRef GetArgStringWithDelimiter() const {\n    assert(m_has_args);\n    return m_arg_string_with_delimiter;\n  }\n\n  /// Returns the part of the input string that was used for parsing the\n  /// argument list.\n  ///\n  /// You can only call this method if HasArgs returns true.\n  llvm::StringRef GetArgString() const {\n    assert(m_has_args);\n    return m_arg_string;\n  }\n\n  /// Returns the raw suffix part of the parsed string.\n  const std::string &GetRawPart() const { return m_suffix; }\n\nprivate:\n  void SetFromString(llvm::StringRef arg_string);\n\n  /// Keeps track if we have parsed and stored any arguments.\n  bool m_has_args = false;\n  Args m_args;\n  llvm::StringRef m_arg_string;\n  llvm::StringRef m_arg_string_with_delimiter;\n\n  // FIXME: This should be a StringRef, but some of the calling code expect a\n  // C string here so only a real std::string is possible.\n  std::string m_suffix;\n};\n\n} // namespace lldb_private\n\nnamespace llvm {\nnamespace yaml {\ntemplate <> struct MappingTraits<lldb_private::Args::ArgEntry> {\n  class NormalizedArgEntry {\n  public:\n    NormalizedArgEntry(IO &) {}\n    NormalizedArgEntry(IO &, lldb_private::Args::ArgEntry &entry)\n        : value(entry.ref()), quote(entry.quote) {}\n    lldb_private::Args::ArgEntry denormalize(IO &) {\n      return lldb_private::Args::ArgEntry(value, quote);\n    }\n    StringRef value;\n    uint8_t quote;\n  };\n  static void mapping(IO &io, lldb_private::Args::ArgEntry &v);\n};\ntemplate <> struct MappingTraits<lldb_private::Args> {\n  static void mapping(IO &io, lldb_private::Args &v);\n};\n} // namespace yaml\n} // namespace llvm\n\nLLVM_YAML_IS_SEQUENCE_VECTOR(lldb_private::Args::ArgEntry)\n\n#endif // LLDB_UTILITY_ARGS_H\n"}, "27": {"id": 27, "path": "/home/vsts/work/1/llvm-project/lldb/include/lldb/Utility/Baton.h", "content": "//===-- Baton.h -------------------------------------------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLDB_UTILITY_BATON_H\n#define LLDB_UTILITY_BATON_H\n\n#include \"lldb/lldb-enumerations.h\"\n#include \"lldb/lldb-public.h\"\n\n#include \"llvm/Support/raw_ostream.h\"\n\n#include <memory>\n\nnamespace lldb_private {\nclass Stream;\n}\n\nnamespace lldb_private {\n\n/// \\class Baton Baton.h \"lldb/Core/Baton.h\"\n/// A class designed to wrap callback batons so they can cleanup\n///        any acquired resources\n///\n/// This class is designed to be used by any objects that have a callback\n/// function that takes a baton where the baton might need to\n/// free/delete/close itself.\n///\n/// The default behavior is to not free anything. Subclasses can free any\n/// needed resources in their destructors.\nclass Baton {\npublic:\n  Baton() {}\n  virtual ~Baton() {}\n\n  virtual void *data() = 0;\n\n  virtual void GetDescription(llvm::raw_ostream &s,\n                              lldb::DescriptionLevel level,\n                              unsigned indentation) const = 0;\n};\n\nclass UntypedBaton : public Baton {\npublic:\n  UntypedBaton(void *Data) : m_data(Data) {}\n  ~UntypedBaton() override {\n    // The default destructor for an untyped baton does NOT attempt to clean up\n    // anything in m_data.\n  }\n\n  void *data() override { return m_data; }\n  void GetDescription(llvm::raw_ostream &s, lldb::DescriptionLevel level,\n                      unsigned indentation) const override;\n\n  void *m_data; // Leave baton public for easy access\n};\n\ntemplate <typename T> class TypedBaton : public Baton {\npublic:\n  explicit TypedBaton(std::unique_ptr<T> Item) : Item(std::move(Item)) {}\n\n  T *getItem() { return Item.get(); }\n  const T *getItem() const { return Item.get(); }\n\n  void *data() override { return Item.get(); }\n  void GetDescription(llvm::raw_ostream &s, lldb::DescriptionLevel level,\n                      unsigned indentation) const override {}\n\nprotected:\n  std::unique_ptr<T> Item;\n};\n\n} // namespace lldb_private\n\n#endif // LLDB_UTILITY_BATON_H\n"}, "28": {"id": 28, "path": "/home/vsts/work/1/llvm-project/lldb/include/lldb/Utility/ConstString.h", "content": "//===-- ConstString.h -------------------------------------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLDB_UTILITY_CONSTSTRING_H\n#define LLDB_UTILITY_CONSTSTRING_H\n\n#include \"llvm/ADT/DenseMapInfo.h\"\n#include \"llvm/ADT/StringRef.h\"\n#include \"llvm/Support/FormatVariadic.h\"\n#include \"llvm/Support/YAMLTraits.h\"\n\n#include <stddef.h>\n\nnamespace lldb_private {\nclass Stream;\n}\nnamespace llvm {\nclass raw_ostream;\n}\n\nnamespace lldb_private {\n\n/// \\class ConstString ConstString.h \"lldb/Utility/ConstString.h\"\n/// A uniqued constant string class.\n///\n/// Provides an efficient way to store strings as uniqued strings. After the\n/// strings are uniqued, finding strings that are equal to one another is very\n/// fast as just the pointers need to be compared. It also allows for many\n/// common strings from many different sources to be shared to keep the memory\n/// footprint low.\n///\n/// No reference counting is done on strings that are added to the string\n/// pool, once strings are added they are in the string pool for the life of\n/// the program.\nclass ConstString {\npublic:\n  /// Default constructor\n  ///\n  /// Initializes the string to an empty string.\n  ConstString() = default;\n\n  explicit ConstString(const llvm::StringRef &s);\n\n  /// Construct with C String value\n  ///\n  /// Constructs this object with a C string by looking to see if the\n  /// C string already exists in the global string pool. If it doesn't\n  /// exist, it is added to the string pool.\n  ///\n  /// \\param[in] cstr\n  ///     A NULL terminated C string to add to the string pool.\n  explicit ConstString(const char *cstr);\n\n  /// Construct with C String value with max length\n  ///\n  /// Constructs this object with a C string with a length. If \\a max_cstr_len\n  /// is greater than the actual length of the string, the string length will\n  /// be truncated. This allows substrings to be created without the need to\n  /// NULL terminate the string as it is passed into this function.\n  ///\n  /// \\param[in] cstr\n  ///     A pointer to the first character in the C string. The C\n  ///     string can be NULL terminated in a buffer that contains\n  ///     more characters than the length of the string, or the\n  ///     string can be part of another string and a new substring\n  ///     can be created.\n  ///\n  /// \\param[in] max_cstr_len\n  ///     The max length of \\a cstr. If the string length of \\a cstr\n  ///     is less than \\a max_cstr_len, then the string will be\n  ///     truncated. If the string length of \\a cstr is greater than\n  ///     \\a max_cstr_len, then only max_cstr_len bytes will be used\n  ///     from \\a cstr.\n  explicit ConstString(const char *cstr, size_t max_cstr_len);\n\n  /// C string equality binary predicate function object for ConstString\n  /// objects.\n  struct StringIsEqual {\n    /// C equality test.\n    ///\n    /// Two C strings are equal when they are contained in ConstString objects\n    /// when their pointer values are equal to each other.\n    ///\n    /// \\return\n    ///     Returns \\b true if the C string in \\a lhs is equal to\n    ///     the C string value in \\a rhs, \\b false otherwise.\n    bool operator()(const char *lhs, const char *rhs) const {\n      return lhs == rhs;\n    }\n  };\n\n  /// Convert to bool operator.\n  ///\n  /// This allows code to check a ConstString object to see if it contains a\n  /// valid string using code such as:\n  ///\n  /// \\code\n  /// ConstString str(...);\n  /// if (str)\n  /// { ...\n  /// \\endcode\n  ///\n  /// \\return\n  ///     /b True this object contains a valid non-empty C string, \\b\n  ///     false otherwise.\n  explicit operator bool() const { return !IsEmpty(); }\n\n  /// Equal to operator\n  ///\n  /// Returns true if this string is equal to the string in \\a rhs. This\n  /// operation is very fast as it results in a pointer comparison since all\n  /// strings are in a uniqued in a global string pool.\n  ///\n  /// \\param[in] rhs\n  ///     Another string object to compare this object to.\n  ///\n  /// \\return\n  ///     true if this object is equal to \\a rhs.\n  ///     false if this object is not equal to \\a rhs.\n  bool operator==(ConstString rhs) const {\n    // We can do a pointer compare to compare these strings since they must\n    // come from the same pool in order to be equal.\n    return m_string == rhs.m_string;\n  }\n\n  /// Equal to operator against a non-ConstString value.\n  ///\n  /// Returns true if this string is equal to the string in \\a rhs. This\n  /// overload is usually slower than comparing against a ConstString value.\n  /// However, if the rhs string not already a ConstString and it is impractical\n  /// to turn it into a non-temporary variable, then this overload is faster.\n  ///\n  /// \\param[in] rhs\n  ///     Another string object to compare this object to.\n  ///\n  /// \\return\n  ///     \\b true if this object is equal to \\a rhs.\n  ///     \\b false if this object is not equal to \\a rhs.\n  bool operator==(const char *rhs) const {\n    // ConstString differentiates between empty strings and nullptr strings, but\n    // StringRef doesn't. Therefore we have to do this check manually now.\n    if (m_string == nullptr && rhs != nullptr)\n      return false;\n    if (m_string != nullptr && rhs == nullptr)\n      return false;\n\n    return GetStringRef() == rhs;\n  }\n\n  /// Not equal to operator\n  ///\n  /// Returns true if this string is not equal to the string in \\a rhs. This\n  /// operation is very fast as it results in a pointer comparison since all\n  /// strings are in a uniqued in a global string pool.\n  ///\n  /// \\param[in] rhs\n  ///     Another string object to compare this object to.\n  ///\n  /// \\return\n  ///     \\b true if this object is not equal to \\a rhs.\n  ///     \\b false if this object is equal to \\a rhs.\n  bool operator!=(ConstString rhs) const { return m_string != rhs.m_string; }\n\n  /// Not equal to operator against a non-ConstString value.\n  ///\n  /// Returns true if this string is not equal to the string in \\a rhs. This\n  /// overload is usually slower than comparing against a ConstString value.\n  /// However, if the rhs string not already a ConstString and it is impractical\n  /// to turn it into a non-temporary variable, then this overload is faster.\n  ///\n  /// \\param[in] rhs\n  ///     Another string object to compare this object to.\n  ///\n  /// \\return \\b true if this object is not equal to \\a rhs, false otherwise.\n  bool operator!=(const char *rhs) const { return !(*this == rhs); }\n\n  bool operator<(ConstString rhs) const;\n\n  /// Get the string value as a C string.\n  ///\n  /// Get the value of the contained string as a NULL terminated C string\n  /// value.\n  ///\n  /// If \\a value_if_empty is nullptr, then nullptr will be returned.\n  ///\n  /// \\return Returns \\a value_if_empty if the string is empty, otherwise\n  ///     the C string value contained in this object.\n  const char *AsCString(const char *value_if_empty = nullptr) const {\n    return (IsEmpty() ? value_if_empty : m_string);\n  }\n\n  /// Get the string value as a llvm::StringRef\n  ///\n  /// \\return\n  ///     Returns a new llvm::StringRef object filled in with the\n  ///     needed data.\n  llvm::StringRef GetStringRef() const {\n    return llvm::StringRef(m_string, GetLength());\n  }\n\n  /// Get the string value as a C string.\n  ///\n  /// Get the value of the contained string as a NULL terminated C string\n  /// value. Similar to the ConstString::AsCString() function, yet this\n  /// function will always return nullptr if the string is not valid. So this\n  /// function is a direct accessor to the string pointer value.\n  ///\n  /// \\return\n  ///     Returns nullptr the string is invalid, otherwise the C string\n  ///     value contained in this object.\n  const char *GetCString() const { return m_string; }\n\n  /// Get the length in bytes of string value.\n  ///\n  /// The string pool stores the length of the string, so we can avoid calling\n  /// strlen() on the pointer value with this function.\n  ///\n  /// \\return\n  ///     Returns the number of bytes that this string occupies in\n  ///     memory, not including the NULL termination byte.\n  size_t GetLength() const;\n\n  /// Clear this object's state.\n  ///\n  /// Clear any contained string and reset the value to the empty string\n  /// value.\n  void Clear() { m_string = nullptr; }\n\n  /// Equal to operator\n  ///\n  /// Returns true if this string is equal to the string in \\a rhs. If case\n  /// sensitive equality is tested, this operation is very fast as it results\n  /// in a pointer comparison since all strings are in a uniqued in a global\n  /// string pool.\n  ///\n  /// \\param[in] lhs\n  ///     The Left Hand Side const ConstString object reference.\n  ///\n  /// \\param[in] rhs\n  ///     The Right Hand Side const ConstString object reference.\n  ///\n  /// \\param[in] case_sensitive\n  ///     Case sensitivity. If true, case sensitive equality\n  ///     will be tested, otherwise character case will be ignored\n  ///\n  /// \\return \\b true if this object is equal to \\a rhs, \\b false otherwise.\n  static bool Equals(ConstString lhs, ConstString rhs,\n                     const bool case_sensitive = true);\n\n  /// Compare two string objects.\n  ///\n  /// Compares the C string values contained in \\a lhs and \\a rhs and returns\n  /// an integer result.\n  ///\n  /// NOTE: only call this function when you want a true string\n  /// comparison. If you want string equality use the, use the == operator as\n  /// it is much more efficient. Also if you want string inequality, use the\n  /// != operator for the same reasons.\n  ///\n  /// \\param[in] lhs\n  ///     The Left Hand Side const ConstString object reference.\n  ///\n  /// \\param[in] rhs\n  ///     The Right Hand Side const ConstString object reference.\n  ///\n  /// \\param[in] case_sensitive\n  ///     Case sensitivity of compare. If true, case sensitive compare\n  ///     will be performed, otherwise character case will be ignored\n  ///\n  /// \\return -1 if lhs < rhs, 0 if lhs == rhs, 1 if lhs > rhs\n  static int Compare(ConstString lhs, ConstString rhs,\n                     const bool case_sensitive = true);\n\n  /// Dump the object description to a stream.\n  ///\n  /// Dump the string value to the stream \\a s. If the contained string is\n  /// empty, print \\a value_if_empty to the stream instead. If \\a\n  /// value_if_empty is nullptr, then nothing will be dumped to the stream.\n  ///\n  /// \\param[in] s\n  ///     The stream that will be used to dump the object description.\n  ///\n  /// \\param[in] value_if_empty\n  ///     The value to dump if the string is empty. If nullptr, nothing\n  ///     will be output to the stream.\n  void Dump(Stream *s, const char *value_if_empty = nullptr) const;\n\n  /// Dump the object debug description to a stream.\n  ///\n  /// \\param[in] s\n  ///     The stream that will be used to dump the object description.\n  void DumpDebug(Stream *s) const;\n\n  /// Test for empty string.\n  ///\n  /// \\return\n  ///     \\b true if the contained string is empty.\n  ///     \\b false if the contained string is not empty.\n  bool IsEmpty() const { return m_string == nullptr || m_string[0] == '\\0'; }\n\n  /// Test for null string.\n  ///\n  /// \\return\n  ///     \\b true if there is no string associated with this instance.\n  ///     \\b false if there is a string associated with this instance.\n  bool IsNull() const { return m_string == nullptr; }\n\n  /// Set the C string value.\n  ///\n  /// Set the string value in the object by uniquing the \\a cstr string value\n  /// in our global string pool.\n  ///\n  /// If the C string already exists in the global string pool, it finds the\n  /// current entry and returns the existing value. If it doesn't exist, it is\n  /// added to the string pool.\n  ///\n  /// \\param[in] cstr\n  ///     A NULL terminated C string to add to the string pool.\n  void SetCString(const char *cstr);\n\n  void SetString(const llvm::StringRef &s);\n\n  /// Set the C string value and its mangled counterpart.\n  ///\n  /// Object files and debug symbols often use mangled string to represent the\n  /// linkage name for a symbol, function or global. The string pool can\n  /// efficiently store these values and their counterparts so when we run\n  /// into another instance of a mangled name, we can avoid calling the name\n  /// demangler over and over on the same strings and then trying to unique\n  /// them.\n  ///\n  /// \\param[in] demangled\n  ///     The demangled string to correlate with the \\a mangled name.\n  ///\n  /// \\param[in] mangled\n  ///     The already uniqued mangled ConstString to correlate the\n  ///     soon to be uniqued version of \\a demangled.\n  void SetStringWithMangledCounterpart(llvm::StringRef demangled,\n                                       ConstString mangled);\n\n  /// Retrieve the mangled or demangled counterpart for a mangled or demangled\n  /// ConstString.\n  ///\n  /// Object files and debug symbols often use mangled string to represent the\n  /// linkage name for a symbol, function or global. The string pool can\n  /// efficiently store these values and their counterparts so when we run\n  /// into another instance of a mangled name, we can avoid calling the name\n  /// demangler over and over on the same strings and then trying to unique\n  /// them.\n  ///\n  /// \\param[in] counterpart\n  ///     A reference to a ConstString object that might get filled in\n  ///     with the demangled/mangled counterpart.\n  ///\n  /// \\return\n  ///     /b True if \\a counterpart was filled in with the counterpart\n  ///     /b false otherwise.\n  bool GetMangledCounterpart(ConstString &counterpart) const;\n\n  /// Set the C string value with length.\n  ///\n  /// Set the string value in the object by uniquing \\a cstr_len bytes\n  /// starting at the \\a cstr string value in our global string pool. If trim\n  /// is true, then \\a cstr_len indicates a maximum length of the CString and\n  /// if the actual length of the string is less, then it will be trimmed.\n  ///\n  /// If the C string already exists in the global string pool, it finds the\n  /// current entry and returns the existing value. If it doesn't exist, it is\n  /// added to the string pool.\n  ///\n  /// \\param[in] cstr\n  ///     A NULL terminated C string to add to the string pool.\n  ///\n  /// \\param[in] cstr_len\n  ///     The maximum length of the C string.\n  void SetCStringWithLength(const char *cstr, size_t cstr_len);\n\n  /// Set the C string value with the minimum length between \\a fixed_cstr_len\n  /// and the actual length of the C string. This can be used for data\n  /// structures that have a fixed length to store a C string where the string\n  /// might not be NULL terminated if the string takes the entire buffer.\n  void SetTrimmedCStringWithLength(const char *cstr, size_t fixed_cstr_len);\n\n  /// Get the memory cost of this object.\n  ///\n  /// Return the size in bytes that this object takes in memory. This returns\n  /// the size in bytes of this object, which does not include any the shared\n  /// string values it may refer to.\n  ///\n  /// \\return\n  ///     The number of bytes that this object occupies in memory.\n  ///\n  /// \\see ConstString::StaticMemorySize ()\n  size_t MemorySize() const { return sizeof(ConstString); }\n\n  /// Get the size in bytes of the current global string pool.\n  ///\n  /// Reports the size in bytes of all shared C string values, containers and\n  /// any other values as a byte size for the entire string pool.\n  ///\n  /// \\return\n  ///     The number of bytes that the global string pool occupies\n  ///     in memory.\n  static size_t StaticMemorySize();\n\nprotected:\n  template <typename T> friend struct ::llvm::DenseMapInfo;\n  /// Only used by DenseMapInfo.\n  static ConstString FromStringPoolPointer(const char *ptr) {\n    ConstString s;\n    s.m_string = ptr;\n    return s;\n  };\n\n  const char *m_string = nullptr;\n};\n\n/// Stream the string value \\a str to the stream \\a s\nStream &operator<<(Stream &s, ConstString str);\n\n} // namespace lldb_private\n\nnamespace llvm {\ntemplate <> struct format_provider<lldb_private::ConstString> {\n  static void format(const lldb_private::ConstString &CS, llvm::raw_ostream &OS,\n                     llvm::StringRef Options);\n};\n\n/// DenseMapInfo implementation.\n/// \\{\ntemplate <> struct DenseMapInfo<lldb_private::ConstString> {\n  static inline lldb_private::ConstString getEmptyKey() {\n    return lldb_private::ConstString::FromStringPoolPointer(\n        DenseMapInfo<const char *>::getEmptyKey());\n  }\n  static inline lldb_private::ConstString getTombstoneKey() {\n    return lldb_private::ConstString::FromStringPoolPointer(\n        DenseMapInfo<const char *>::getTombstoneKey());\n  }\n  static unsigned getHashValue(lldb_private::ConstString val) {\n    return DenseMapInfo<const char *>::getHashValue(val.m_string);\n  }\n  static bool isEqual(lldb_private::ConstString LHS,\n                      lldb_private::ConstString RHS) {\n    return LHS == RHS;\n  }\n};\n/// \\}\n\nnamespace yaml {\ntemplate <> struct ScalarTraits<lldb_private::ConstString> {\n  static void output(const lldb_private::ConstString &, void *, raw_ostream &);\n  static StringRef input(StringRef, void *, lldb_private::ConstString &);\n  static QuotingType mustQuote(StringRef S) { return QuotingType::Double; }\n};\n} // namespace yaml\n\ninline raw_ostream &operator<<(raw_ostream &os, lldb_private::ConstString s) {\n  os << s.GetStringRef();\n  return os;\n}\n} // namespace llvm\n\nLLVM_YAML_IS_SEQUENCE_VECTOR(lldb_private::ConstString)\n\n#endif // LLDB_UTILITY_CONSTSTRING_H\n"}, "29": {"id": 29, "path": "/home/vsts/work/1/llvm-project/lldb/include/lldb/Utility/DataBuffer.h", "content": "//===-- DataBuffer.h --------------------------------------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLDB_UTILITY_DATABUFFER_H\n#define LLDB_UTILITY_DATABUFFER_H\n#if defined(__cplusplus)\n\n#include <stdint.h>\n#include <string.h>\n\n#include \"lldb/lldb-types.h\"\n\n#include \"llvm/ADT/ArrayRef.h\"\n\nnamespace lldb_private {\n\n/// \\class DataBuffer DataBuffer.h \"lldb/Core/DataBuffer.h\"\n/// A pure virtual protocol class for abstracted data buffers.\n///\n/// DataBuffer is an abstract class that gets packaged into a shared pointer\n/// that can use to implement various ways to store data (on the heap, memory\n/// mapped, cached inferior memory). It gets used by DataExtractor so many\n/// DataExtractor objects can share the same data and sub-ranges of that\n/// shared data, and the last object that contains a reference to the shared\n/// data will free it.\n///\n/// Subclasses can implement as many different constructors or member\n/// functions that allow data to be stored in the object's buffer prior to\n/// handing the shared data to clients that use these buffers.\n///\n/// All subclasses must override all of the pure virtual functions as they are\n/// used by clients to access the data. Having a common interface allows\n/// different ways of storing data, yet using it in one common way.\n///\n/// This class currently expects all data to be available without any extra\n/// calls being made, but we can modify it to optionally get data on demand\n/// with some extra function calls to load the data before it gets accessed.\nclass DataBuffer {\npublic:\n  /// Destructor\n  ///\n  /// The destructor is virtual as other classes will inherit from this class\n  /// and be downcast to the DataBuffer pure virtual interface. The virtual\n  /// destructor ensures that destructing the base class will destruct the\n  /// class that inherited from it correctly.\n  virtual ~DataBuffer() {}\n\n  /// Get a pointer to the data.\n  ///\n  /// \\return\n  ///     A pointer to the bytes owned by this object, or NULL if the\n  ///     object contains no bytes.\n  virtual uint8_t *GetBytes() = 0;\n\n  /// Get a const pointer to the data.\n  ///\n  /// \\return\n  ///     A const pointer to the bytes owned by this object, or NULL\n  ///     if the object contains no bytes.\n  virtual const uint8_t *GetBytes() const = 0;\n\n  /// Get the number of bytes in the data buffer.\n  ///\n  /// \\return\n  ///     The number of bytes this object currently contains.\n  virtual lldb::offset_t GetByteSize() const = 0;\n\n  llvm::ArrayRef<uint8_t> GetData() const {\n    return llvm::ArrayRef<uint8_t>(GetBytes(), GetByteSize());\n  }\n\n  llvm::MutableArrayRef<uint8_t> GetData() {\n    return llvm::MutableArrayRef<uint8_t>(GetBytes(), GetByteSize());\n  }\n};\n\nclass DataBufferUnowned : public DataBuffer {\npublic:\n  DataBufferUnowned(uint8_t *bytes, lldb::offset_t size)\n      : m_bytes(bytes), m_size(size) {}\n\n  uint8_t *GetBytes() override { return m_bytes; }\n  const uint8_t *GetBytes() const override { return m_bytes; }\n  lldb::offset_t GetByteSize() const override { return m_size; }\n\nprivate:\n  uint8_t *m_bytes;\n  lldb::offset_t m_size;\n};\n\n} // namespace lldb_private\n\n#endif /// #if defined(__cplusplus)\n#endif // LLDB_UTILITY_DATABUFFER_H\n"}, "30": {"id": 30, "path": "/home/vsts/work/1/llvm-project/lldb/include/lldb/Utility/Environment.h", "content": "//===-- Environment.h -------------------------------------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLDB_UTILITY_ENVIRONMENT_H\n#define LLDB_UTILITY_ENVIRONMENT_H\n\n#include \"llvm/ADT/StringMap.h\"\n#include \"llvm/Support/Allocator.h\"\n#include \"llvm/Support/FormatProviders.h\"\n\nnamespace lldb_private {\n\nclass Environment : private llvm::StringMap<std::string> {\n  using Base = llvm::StringMap<std::string>;\n\npublic:\n  class Envp {\n  public:\n    Envp(Envp &&RHS) = default;\n    Envp &operator=(Envp &&RHS) = default;\n\n    char *const *get() const { return Data; }\n    operator char *const *() const { return get(); }\n\n  private:\n    explicit Envp(const Environment &Env);\n    char *make_entry(llvm::StringRef Key, llvm::StringRef Value);\n    Envp(const Envp &) = delete;\n    Envp &operator=(const Envp &) = delete;\n    friend class Environment;\n\n    llvm::BumpPtrAllocator Allocator;\n    char **Data;\n  };\n\n  using Base::const_iterator;\n  using Base::iterator;\n  using Base::value_type;\n\n  using Base::begin;\n  using Base::clear;\n  using Base::count;\n  using Base::empty;\n  using Base::end;\n  using Base::erase;\n  using Base::find;\n  using Base::insert;\n  using Base::insert_or_assign;\n  using Base::lookup;\n  using Base::size;\n  using Base::try_emplace;\n  using Base::operator[];\n\n  Environment() : Base() {}\n  Environment(const Environment &RHS) : Base(RHS) {}\n  Environment(Environment &&RHS) : Base(std::move(RHS)) {}\n  Environment(char *const *Env)\n      : Environment(const_cast<const char *const *>(Env)) {}\n  Environment(const char *const *Env);\n\n  Environment &operator=(Environment RHS) {\n    Base::operator=(std::move(RHS));\n    return *this;\n  }\n\n  std::pair<iterator, bool> insert(llvm::StringRef KeyEqValue) {\n    auto Split = KeyEqValue.split('=');\n    return insert(std::make_pair(Split.first, std::string(Split.second)));\n  }\n\n  void insert(const_iterator first, const_iterator last);\n\n  Envp getEnvp() const { return Envp(*this); }\n\n  static std::string compose(const value_type &KeyValue) {\n    return (KeyValue.first() + \"=\" + KeyValue.second).str();\n  }\n};\n\n} // namespace lldb_private\n\nnamespace llvm {\ntemplate <> struct format_provider<lldb_private::Environment> {\n  static void format(const lldb_private::Environment &Env, raw_ostream &Stream,\n                     StringRef Style) {\n    for (const auto &KV : Env)\n      Stream << \"env[\" << KV.first() << \"] = \" << KV.second << \"\\n\";\n  }\n};\n} // namespace llvm\n\n#endif // LLDB_UTILITY_ENVIRONMENT_H\n"}, "31": {"id": 31, "path": "/home/vsts/work/1/llvm-project/lldb/include/lldb/Utility/FileSpec.h", "content": "//===-- FileSpec.h ----------------------------------------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLDB_UTILITY_FILESPEC_H\n#define LLDB_UTILITY_FILESPEC_H\n\n#include <functional>\n#include <string>\n\n#include \"lldb/Utility/ConstString.h\"\n\n#include \"llvm/ADT/StringRef.h\"\n#include \"llvm/Support/FileSystem.h\"\n#include \"llvm/Support/FormatVariadic.h\"\n#include \"llvm/Support/Path.h\"\n#include \"llvm/Support/YAMLTraits.h\"\n\n#include <stddef.h>\n#include <stdint.h>\n\nnamespace lldb_private {\nclass Stream;\n}\nnamespace llvm {\nclass Triple;\n}\nnamespace llvm {\nclass raw_ostream;\n}\nnamespace llvm {\ntemplate <typename T> class SmallVectorImpl;\n}\n\nnamespace lldb_private {\n\n/// \\class FileSpec FileSpec.h \"lldb/Host/FileSpec.h\"\n/// A file utility class.\n///\n/// A file specification class that divides paths up into a directory\n/// and basename. These string values of the paths are put into uniqued string\n/// pools for fast comparisons and efficient memory usage.\n///\n/// Another reason the paths are split into the directory and basename is to\n/// allow efficient debugger searching. Often in a debugger the user types in\n/// the basename of the file, for example setting a breakpoint by file and\n/// line, or specifying a module (shared library) to limit the scope in which\n/// to execute a command. The user rarely types in a full path. When the paths\n/// are already split up, it makes it easy for us to compare only the\n/// basenames of a lot of file specifications without having to split up the\n/// file path each time to get to the basename.\nclass FileSpec {\npublic:\n  using Style = llvm::sys::path::Style;\n\n  FileSpec();\n\n  /// Constructor with path.\n  ///\n  /// Takes a path to a file which can be just a filename, or a full path. If\n  /// \\a path is not nullptr or empty, this function will call\n  /// FileSpec::SetFile (const char *path).\n  ///\n  /// \\param[in] path\n  ///     The full or partial path to a file.\n  ///\n  /// \\param[in] style\n  ///     The style of the path\n  ///\n  /// \\see FileSpec::SetFile (const char *path)\n  explicit FileSpec(llvm::StringRef path, Style style = Style::native);\n\n  explicit FileSpec(llvm::StringRef path, const llvm::Triple &triple);\n\n  bool DirectoryEquals(const FileSpec &other) const;\n\n  bool FileEquals(const FileSpec &other) const;\n\n  /// Equal to operator\n  ///\n  /// Tests if this object is equal to \\a rhs.\n  ///\n  /// \\param[in] rhs\n  ///     A const FileSpec object reference to compare this object\n  ///     to.\n  ///\n  /// \\return\n  ///     \\b true if this object is equal to \\a rhs, \\b false\n  ///     otherwise.\n  bool operator==(const FileSpec &rhs) const;\n\n  /// Not equal to operator\n  ///\n  /// Tests if this object is not equal to \\a rhs.\n  ///\n  /// \\param[in] rhs\n  ///     A const FileSpec object reference to compare this object\n  ///     to.\n  ///\n  /// \\return\n  ///     \\b true if this object is equal to \\a rhs, \\b false\n  ///     otherwise.\n  bool operator!=(const FileSpec &rhs) const;\n\n  /// Less than to operator\n  ///\n  /// Tests if this object is less than \\a rhs.\n  ///\n  /// \\param[in] rhs\n  ///     A const FileSpec object reference to compare this object\n  ///     to.\n  ///\n  /// \\return\n  ///     \\b true if this object is less than \\a rhs, \\b false\n  ///     otherwise.\n  bool operator<(const FileSpec &rhs) const;\n\n  /// Convert to pointer operator.\n  ///\n  /// This allows code to check a FileSpec object to see if it contains\n  /// anything valid using code such as:\n  ///\n  /// \\code\n  /// FileSpec file_spec(...);\n  /// if (file_spec)\n  /// { ...\n  /// \\endcode\n  ///\n  /// \\return\n  ///     A pointer to this object if either the directory or filename\n  ///     is valid, nullptr otherwise.\n  explicit operator bool() const;\n\n  /// Logical NOT operator.\n  ///\n  /// This allows code to check a FileSpec object to see if it is invalid\n  /// using code such as:\n  ///\n  /// \\code\n  /// FileSpec file_spec(...);\n  /// if (!file_spec)\n  /// { ...\n  /// \\endcode\n  ///\n  /// \\return\n  ///     Returns \\b true if the object has an empty directory and\n  ///     filename, \\b false otherwise.\n  bool operator!() const;\n\n  /// Clears the object state.\n  ///\n  /// Clear this object by releasing both the directory and filename string\n  /// values and reverting them to empty strings.\n  void Clear();\n\n  /// Compare two FileSpec objects.\n  ///\n  /// If \\a full is true, then both the directory and the filename must match.\n  /// If \\a full is false, then the directory names for \\a lhs and \\a rhs are\n  /// only compared if they are both not empty. This allows a FileSpec object\n  /// to only contain a filename and it can match FileSpec objects that have\n  /// matching filenames with different paths.\n  ///\n  /// \\param[in] lhs\n  ///     A const reference to the Left Hand Side object to compare.\n  ///\n  /// \\param[in] rhs\n  ///     A const reference to the Right Hand Side object to compare.\n  ///\n  /// \\param[in] full\n  ///     If true, then both the directory and filenames will have to\n  ///     match for a compare to return zero (equal to). If false\n  ///     and either directory from \\a lhs or \\a rhs is empty, then\n  ///     only the filename will be compared, else a full comparison\n  ///     is done.\n  ///\n  /// \\return -1 if \\a lhs is less than \\a rhs, 0 if \\a lhs is equal to \\a rhs,\n  ///     1 if \\a lhs is greater than \\a rhs\n  static int Compare(const FileSpec &lhs, const FileSpec &rhs, bool full);\n\n  static bool Equal(const FileSpec &a, const FileSpec &b, bool full);\n\n  /// Match FileSpec \\a pattern against FileSpec \\a file. If \\a pattern has a\n  /// directory component, then the \\a file must have the same directory\n  /// component. Otherwise, just it matches just the filename. An empty \\a\n  /// pattern matches everything.\n  static bool Match(const FileSpec &pattern, const FileSpec &file);\n\n  /// Attempt to guess path style for a given path string. It returns a style,\n  /// if it was able to make a reasonable guess, or None if it wasn't. The guess\n  /// will be correct if the input path was a valid absolute path on the system\n  /// which produced it. On other paths the result of this function is\n  /// unreliable (e.g. \"c:\\foo.txt\" is a valid relative posix path).\n  static llvm::Optional<Style> GuessPathStyle(llvm::StringRef absolute_path);\n\n  /// Case sensitivity of path.\n  ///\n  /// \\return\n  ///     \\b true if the file path is case sensitive (POSIX), false\n  ///\t\tif case insensitive (Windows).\n  bool IsCaseSensitive() const { return m_style != Style::windows; }\n\n  /// Dump this object to a Stream.\n  ///\n  /// Dump the object to the supplied stream \\a s. If the object contains a\n  /// valid directory name, it will be displayed followed by a directory\n  /// delimiter, and the filename.\n  ///\n  /// \\param[in] s\n  ///     The stream to which to dump the object description.\n  void Dump(llvm::raw_ostream &s) const;\n\n  Style GetPathStyle() const;\n\n  /// Directory string get accessor.\n  ///\n  /// \\return\n  ///     A reference to the directory string object.\n  ConstString &GetDirectory();\n\n  /// Directory string const get accessor.\n  ///\n  /// \\return\n  ///     A const reference to the directory string object.\n  ConstString GetDirectory() const;\n\n  /// Filename string get accessor.\n  ///\n  /// \\return\n  ///     A reference to the filename string object.\n  ConstString &GetFilename();\n\n  /// Filename string const get accessor.\n  ///\n  /// \\return\n  ///     A const reference to the filename string object.\n  ConstString GetFilename() const;\n\n  /// Returns true if the filespec represents an implementation source file\n  /// (files with a \".c\", \".cpp\", \".m\", \".mm\" (many more) extension).\n  ///\n  /// \\return\n  ///     \\b true if the filespec represents an implementation source\n  ///     file, \\b false otherwise.\n  bool IsSourceImplementationFile() const;\n\n  /// Returns true if the filespec represents a relative path.\n  ///\n  /// \\return\n  ///     \\b true if the filespec represents a relative path,\n  ///     \\b false otherwise.\n  bool IsRelative() const;\n\n  /// Returns true if the filespec represents an absolute path.\n  ///\n  /// \\return\n  ///     \\b true if the filespec represents an absolute path,\n  ///     \\b false otherwise.\n  bool IsAbsolute() const;\n\n  /// Make the FileSpec absolute by treating it relative to \\a dir. Absolute\n  /// FileSpecs are never changed by this function.\n  void MakeAbsolute(const FileSpec &dir);\n\n  /// Temporary helper for FileSystem change.\n  void SetPath(llvm::StringRef p) { SetFile(p); }\n\n  /// Extract the full path to the file.\n  ///\n  /// Extract the directory and path into a fixed buffer. This is needed as\n  /// the directory and path are stored in separate string values.\n  ///\n  /// \\param[out] path\n  ///     The buffer in which to place the extracted full path.\n  ///\n  /// \\param[in] max_path_length\n  ///     The maximum length of \\a path.\n  ///\n  /// \\return\n  ///     Returns the number of characters that would be needed to\n  ///     properly copy the full path into \\a path. If the returned\n  ///     number is less than \\a max_path_length, then the path is\n  ///     properly copied and terminated. If the return value is\n  ///     >= \\a max_path_length, then the path was truncated (but is\n  ///     still NULL terminated).\n  size_t GetPath(char *path, size_t max_path_length,\n                 bool denormalize = true) const;\n\n  /// Extract the full path to the file.\n  ///\n  /// Extract the directory and path into a std::string, which is returned.\n  ///\n  /// \\return\n  ///     Returns a std::string with the directory and filename\n  ///     concatenated.\n  std::string GetPath(bool denormalize = true) const;\n\n  const char *GetCString(bool denormalize = true) const;\n\n  /// Extract the full path to the file.\n  ///\n  /// Extract the directory and path into an llvm::SmallVectorImpl<>\n  void GetPath(llvm::SmallVectorImpl<char> &path,\n               bool denormalize = true) const;\n\n  /// Extract the extension of the file.\n  ///\n  /// Returns a ConstString that represents the extension of the filename for\n  /// this FileSpec object. If this object does not represent a file, or the\n  /// filename has no extension, ConstString(nullptr) is returned. The dot\n  /// ('.') character is not returned as part of the extension\n  ///\n  /// \\return Returns the extension of the file as a ConstString object.\n  ConstString GetFileNameExtension() const;\n\n  /// Return the filename without the extension part\n  ///\n  /// Returns a ConstString that represents the filename of this object\n  /// without the extension part (e.g. for a file named \"foo.bar\", \"foo\" is\n  /// returned)\n  ///\n  /// \\return Returns the filename without extension as a ConstString object.\n  ConstString GetFileNameStrippingExtension() const;\n\n  /// Get the memory cost of this object.\n  ///\n  /// Return the size in bytes that this object takes in memory. This returns\n  /// the size in bytes of this object, not any shared string values it may\n  /// refer to.\n  ///\n  /// \\return\n  ///     The number of bytes that this object occupies in memory.\n  ///\n  /// \\see ConstString::StaticMemorySize ()\n  size_t MemorySize() const;\n\n  /// Change the file specified with a new path.\n  ///\n  /// Update the contents of this object with a new path. The path will be\n  /// split up into a directory and filename and stored as uniqued string\n  /// values for quick comparison and efficient memory usage.\n  ///\n  /// \\param[in] path\n  ///     A full, partial, or relative path to a file.\n  ///\n  /// \\param[in] style\n  ///     The style for the given path.\n  void SetFile(llvm::StringRef path, Style style);\n\n  /// Change the file specified with a new path.\n  ///\n  /// Update the contents of this object with a new path. The path will be\n  /// split up into a directory and filename and stored as uniqued string\n  /// values for quick comparison and efficient memory usage.\n  ///\n  /// \\param[in] path\n  ///     A full, partial, or relative path to a file.\n  ///\n  /// \\param[in] triple\n  ///     The triple which is used to set the Path style.\n  void SetFile(llvm::StringRef path, const llvm::Triple &triple);\n\n  bool IsResolved() const { return m_is_resolved; }\n\n  /// Set if the file path has been resolved or not.\n  ///\n  /// If you know a file path is already resolved and avoided passing a \\b\n  /// true parameter for any functions that take a \"bool resolve_path\"\n  /// parameter, you can set the value manually using this call to make sure\n  /// we don't try and resolve it later, or try and resolve a path that has\n  /// already been resolved.\n  ///\n  /// \\param[in] is_resolved\n  ///     A boolean value that will replace the current value that\n  ///     indicates if the paths in this object have been resolved.\n  void SetIsResolved(bool is_resolved) { m_is_resolved = is_resolved; }\n\n  FileSpec CopyByAppendingPathComponent(llvm::StringRef component) const;\n  FileSpec CopyByRemovingLastPathComponent() const;\n\n  void PrependPathComponent(llvm::StringRef component);\n  void PrependPathComponent(const FileSpec &new_path);\n\n  void AppendPathComponent(llvm::StringRef component);\n  void AppendPathComponent(const FileSpec &new_path);\n\n  /// Removes the last path component by replacing the current path with its\n  /// parent. When the current path has no parent, this is a no-op.\n  ///\n  /// \\return\n  ///     A boolean value indicating whether the path was updated.\n  bool RemoveLastPathComponent();\n\n  ConstString GetLastPathComponent() const;\n\nprotected:\n  friend struct llvm::yaml::MappingTraits<FileSpec>;\n\n  // Convenience method for setting the file without changing the style.\n  void SetFile(llvm::StringRef path);\n\n  // Member variables\n  ConstString m_directory;            ///< The uniqued directory path\n  ConstString m_filename;             ///< The uniqued filename path\n  mutable bool m_is_resolved = false; ///< True if this path has been resolved.\n  Style m_style; ///< The syntax that this path uses (e.g. Windows / Posix)\n};\n\n/// Dump a FileSpec object to a stream\nStream &operator<<(Stream &s, const FileSpec &f);\n\n/// Prevent ODR violations with traits for llvm::sys::path::Style.\nLLVM_YAML_STRONG_TYPEDEF(FileSpec::Style, FileSpecStyle)\n} // namespace lldb_private\n\nnamespace llvm {\n\n/// Implementation of format_provider<T> for FileSpec.\n///\n/// The options string of a FileSpec has the grammar:\n///\n///   file_spec_options   :: (empty) | F | D\n///\n///   =======================================================\n///   |  style  |     Meaning          |      Example       |\n///   -------------------------------------------------------\n///   |         |                      |  Input   |  Output |\n///   =======================================================\n///   |    F    | Only print filename  | /foo/bar |   bar   |\n///   |    D    | Only print directory | /foo/bar |  /foo/  |\n///   | (empty) | Print file and dir   |          |         |\n///   =======================================================\n///\n/// Any other value is considered an invalid format string.\n///\ntemplate <> struct format_provider<lldb_private::FileSpec> {\n  static void format(const lldb_private::FileSpec &F, llvm::raw_ostream &Stream,\n                     StringRef Style);\n};\n\nnamespace yaml {\ntemplate <> struct ScalarEnumerationTraits<lldb_private::FileSpecStyle> {\n  static void enumeration(IO &io, lldb_private::FileSpecStyle &style);\n};\n\ntemplate <> struct MappingTraits<lldb_private::FileSpec> {\n  static void mapping(IO &io, lldb_private::FileSpec &f);\n};\n} // namespace yaml\n} // namespace llvm\n\n#endif // LLDB_UTILITY_FILESPEC_H\n"}, "33": {"id": 33, "path": "/home/vsts/work/1/llvm-project/lldb/include/lldb/Utility/Iterable.h", "content": "//===-- Iterable.h ----------------------------------------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLDB_UTILITY_ITERABLE_H\n#define LLDB_UTILITY_ITERABLE_H\n\n#include <utility>\n\n\nnamespace lldb_private {\n\ntemplate <typename I, typename E> E map_adapter(I &iter) {\n  return iter->second;\n}\n\ntemplate <typename I, typename E> E vector_adapter(I &iter) { return *iter; }\n\ntemplate <typename I, typename E> E list_adapter(I &iter) { return *iter; }\n\ntemplate <typename C, typename E, E (*A)(typename C::const_iterator &)>\nclass AdaptedConstIterator {\npublic:\n  typedef typename C::const_iterator BackingIterator;\n\n  // Wrapping constructor\n  AdaptedConstIterator(BackingIterator backing_iterator)\n      : m_iter(backing_iterator) {}\n\n  // Default-constructible\n  AdaptedConstIterator() : m_iter() {}\n\n  // Copy-constructible\n  AdaptedConstIterator(const AdaptedConstIterator &rhs) : m_iter(rhs.m_iter) {}\n\n  // Copy-assignable\n  AdaptedConstIterator &operator=(const AdaptedConstIterator &rhs) {\n    m_iter = rhs.m_iter;\n    return *this;\n  }\n\n  // Destructible\n  ~AdaptedConstIterator() = default;\n\n  // Comparable\n  bool operator==(const AdaptedConstIterator &rhs) {\n    return m_iter == rhs.m_iter;\n  }\n\n  bool operator!=(const AdaptedConstIterator &rhs) {\n    return m_iter != rhs.m_iter;\n  }\n\n  // Rvalue dereferenceable\n  E operator*() { return (*A)(m_iter); }\n\n  E operator->() { return (*A)(m_iter); }\n\n  // Offset dereferenceable\n  E operator[](typename BackingIterator::difference_type offset) {\n    return AdaptedConstIterator(m_iter + offset);\n  }\n\n  // Incrementable\n  AdaptedConstIterator &operator++() {\n    m_iter++;\n    return *this;\n  }\n\n  // Decrementable\n  AdaptedConstIterator &operator--() {\n    m_iter--;\n    return *this;\n  }\n\n  // Compound assignment\n  AdaptedConstIterator &\n  operator+=(typename BackingIterator::difference_type offset) {\n    m_iter += offset;\n    return *this;\n  }\n\n  AdaptedConstIterator &\n  operator-=(typename BackingIterator::difference_type offset) {\n    m_iter -= offset;\n    return *this;\n  }\n\n  // Arithmetic\n  AdaptedConstIterator\n  operator+(typename BackingIterator::difference_type offset) {\n    return AdaptedConstIterator(m_iter + offset);\n  }\n\n  AdaptedConstIterator\n  operator-(typename BackingIterator::difference_type offset) {\n    return AdaptedConstIterator(m_iter - offset);\n  }\n\n  // Comparable\n  bool operator<(AdaptedConstIterator &rhs) { return m_iter < rhs.m_iter; }\n\n  bool operator<=(AdaptedConstIterator &rhs) { return m_iter <= rhs.m_iter; }\n\n  bool operator>(AdaptedConstIterator &rhs) { return m_iter > rhs.m_iter; }\n\n  bool operator>=(AdaptedConstIterator &rhs) { return m_iter >= rhs.m_iter; }\n\n  template <typename C1, typename E1, E1 (*A1)(typename C1::const_iterator &)>\n  friend AdaptedConstIterator<C1, E1, A1>\n  operator+(typename C1::const_iterator::difference_type,\n            AdaptedConstIterator<C1, E1, A1> &);\n\n  template <typename C1, typename E1, E1 (*A1)(typename C1::const_iterator &)>\n  friend typename C1::const_iterator::difference_type\n  operator-(AdaptedConstIterator<C1, E1, A1> &,\n            AdaptedConstIterator<C1, E1, A1> &);\n\n  template <typename C1, typename E1, E1 (*A1)(typename C1::const_iterator &)>\n  friend void swap(AdaptedConstIterator<C1, E1, A1> &,\n                   AdaptedConstIterator<C1, E1, A1> &);\n\nprivate:\n  BackingIterator m_iter;\n};\n\ntemplate <typename C, typename E, E (*A)(typename C::const_iterator &)>\nAdaptedConstIterator<C, E, A> operator+(\n    typename AdaptedConstIterator<C, E, A>::BackingIterator::difference_type\n        offset,\n    AdaptedConstIterator<C, E, A> &rhs) {\n  return rhs.operator+(offset);\n}\n\ntemplate <typename C, typename E, E (*A)(typename C::const_iterator &)>\ntypename AdaptedConstIterator<C, E, A>::BackingIterator::difference_type\noperator-(AdaptedConstIterator<C, E, A> &lhs,\n          AdaptedConstIterator<C, E, A> &rhs) {\n  return (lhs.m_iter - rhs.m_iter);\n}\n\ntemplate <typename C, typename E, E (*A)(typename C::const_iterator &)>\nvoid swap(AdaptedConstIterator<C, E, A> &lhs,\n          AdaptedConstIterator<C, E, A> &rhs) {\n  std::swap(lhs.m_iter, rhs.m_iter);\n}\n\ntemplate <typename C, typename E, E (*A)(typename C::const_iterator &)>\nclass AdaptedIterable {\nprivate:\n  const C &m_container;\n\npublic:\n  AdaptedIterable(const C &container) : m_container(container) {}\n\n  AdaptedConstIterator<C, E, A> begin() {\n    return AdaptedConstIterator<C, E, A>(m_container.begin());\n  }\n\n  AdaptedConstIterator<C, E, A> end() {\n    return AdaptedConstIterator<C, E, A>(m_container.end());\n  }\n};\n\ntemplate <typename C, typename E, E (*A)(typename C::const_iterator &),\n          typename MutexType>\nclass LockingAdaptedIterable : public AdaptedIterable<C, E, A> {\npublic:\n  LockingAdaptedIterable(const C &container, MutexType &mutex)\n      : AdaptedIterable<C, E, A>(container), m_mutex(&mutex) {\n    m_mutex->lock();\n  }\n\n  LockingAdaptedIterable(LockingAdaptedIterable &&rhs)\n      : AdaptedIterable<C, E, A>(rhs), m_mutex(rhs.m_mutex) {\n    rhs.m_mutex = nullptr;\n  }\n\n  ~LockingAdaptedIterable() {\n    if (m_mutex)\n      m_mutex->unlock();\n  }\n\nprivate:\n  MutexType *m_mutex = nullptr;\n\n  LockingAdaptedIterable(const LockingAdaptedIterable &) = delete;\n  LockingAdaptedIterable &operator=(const LockingAdaptedIterable &) = delete;\n};\n\n} // namespace lldb_private\n\n#endif // LLDB_UTILITY_ITERABLE_H\n"}, "34": {"id": 34, "path": "/home/vsts/work/1/llvm-project/lldb/include/lldb/Utility/Predicate.h", "content": "//===-- Predicate.h ---------------------------------------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLDB_UTILITY_PREDICATE_H\n#define LLDB_UTILITY_PREDICATE_H\n\n#include <stdint.h>\n#include <time.h>\n\n#include <condition_variable>\n#include <mutex>\n\n#include \"lldb/Utility/Timeout.h\"\n#include \"lldb/lldb-defines.h\"\n\n//#define DB_PTHREAD_LOG_EVENTS\n\n/// Enumerations for broadcasting.\nnamespace lldb_private {\n\nenum PredicateBroadcastType {\n  eBroadcastNever,   ///< No broadcast will be sent when the value is modified.\n  eBroadcastAlways,  ///< Always send a broadcast when the value is modified.\n  eBroadcastOnChange ///< Only broadcast if the value changes when the value is\n                     /// modified.\n};\n\n/// \\class Predicate Predicate.h \"lldb/Utility/Predicate.h\"\n/// A C++ wrapper class for providing threaded access to a value of\n/// type T.\n///\n/// A templatized class that provides multi-threaded access to a value\n/// of type T. Threads can efficiently wait for bits within T to be set\n/// or reset, or wait for T to be set to be equal/not equal to a\n/// specified values.\ntemplate <class T> class Predicate {\npublic:\n  /// Default constructor.\n  ///\n  /// Initializes the mutex, condition and value with their default\n  /// constructors.\n  Predicate() : m_value(), m_mutex(), m_condition() {}\n\n  /// Construct with initial T value \\a initial_value.\n  ///\n  /// Initializes the mutex and condition with their default\n  /// constructors, and initializes the value with \\a initial_value.\n  ///\n  /// \\param[in] initial_value\n  ///     The initial value for our T object.\n  Predicate(T initial_value)\n      : m_value(initial_value), m_mutex(), m_condition() {}\n\n  /// Destructor.\n  ///\n  /// Destroy the condition, mutex, and T objects.\n  ~Predicate() = default;\n\n  /// Value get accessor.\n  ///\n  /// Copies the current \\a m_value in a thread safe manor and returns\n  /// the copied value.\n  ///\n  /// \\return\n  ///     A copy of the current value.\n  T GetValue() const {\n    std::lock_guard<std::mutex> guard(m_mutex);\n    T value = m_value;\n    return value;\n  }\n\n  /// Value set accessor.\n  ///\n  /// Set the contained \\a m_value to \\a new_value in a thread safe\n  /// way and broadcast if needed.\n  ///\n  /// \\param[in] value\n  ///     The new value to set.\n  ///\n  /// \\param[in] broadcast_type\n  ///     A value indicating when and if to broadcast. See the\n  ///     PredicateBroadcastType enumeration for details.\n  ///\n  /// \\see Predicate::Broadcast()\n  void SetValue(T value, PredicateBroadcastType broadcast_type) {\n    std::lock_guard<std::mutex> guard(m_mutex);\n#ifdef DB_PTHREAD_LOG_EVENTS\n    printf(\"%s (value = 0x%8.8x, broadcast_type = %i)\\n\", __FUNCTION__, value,\n           broadcast_type);\n#endif\n    const T old_value = m_value;\n    m_value = value;\n\n    Broadcast(old_value, broadcast_type);\n  }\n\n  /// Wait for Cond(m_value) to be true.\n  ///\n  /// Waits in a thread safe way for Cond(m_value) to be true. If Cond(m_value)\n  /// is already true, this function will return without waiting.\n  ///\n  /// It is possible for the value to be changed between the time the value is\n  /// set and the time the waiting thread wakes up. If the value no longer\n  /// satisfies the condition when the waiting thread wakes up, it will go back\n  /// into a wait state. It may be necessary for the calling code to use\n  /// additional thread synchronization methods to detect transitory states.\n  ///\n  /// \\param[in] Cond\n  ///     The condition we want \\a m_value satisfy.\n  ///\n  /// \\param[in] timeout\n  ///     How long to wait for the condition to hold.\n  ///\n  /// \\return\n  ///     m_value if Cond(m_value) is true, None otherwise (timeout occurred).\n  template <typename C>\n  llvm::Optional<T> WaitFor(C Cond, const Timeout<std::micro> &timeout) {\n    std::unique_lock<std::mutex> lock(m_mutex);\n    auto RealCond = [&] { return Cond(m_value); };\n    if (!timeout) {\n      m_condition.wait(lock, RealCond);\n      return m_value;\n    }\n    if (m_condition.wait_for(lock, *timeout, RealCond))\n      return m_value;\n    return llvm::None;\n  }\n  /// Wait for \\a m_value to be equal to \\a value.\n  ///\n  /// Waits in a thread safe way for \\a m_value to be equal to \\a\n  /// value. If \\a m_value is already equal to \\a value, this\n  /// function will return without waiting.\n  ///\n  /// It is possible for the value to be changed between the time\n  /// the value is set and the time the waiting thread wakes up.\n  /// If the value no longer matches the requested value when the\n  /// waiting thread wakes up, it will go back into a wait state.  It\n  /// may be necessary for the calling code to use additional thread\n  /// synchronization methods to detect transitory states.\n  ///\n  /// \\param[in] value\n  ///     The value we want \\a m_value to be equal to.\n  ///\n  /// \\param[in] timeout\n  ///     How long to wait for the condition to hold.\n  ///\n  /// \\return\n  ///     true if the \\a m_value is equal to \\a value, false otherwise (timeout\n  ///     occurred).\n  bool WaitForValueEqualTo(T value,\n                           const Timeout<std::micro> &timeout = llvm::None) {\n    return WaitFor([&value](T current) { return value == current; }, timeout) !=\n           llvm::None;\n  }\n\n  /// Wait for \\a m_value to not be equal to \\a value.\n  ///\n  /// Waits in a thread safe way for \\a m_value to not be equal to \\a\n  /// value. If \\a m_value is already not equal to \\a value, this\n  /// function will return without waiting.\n  ///\n  /// It is possible for the value to be changed between the time\n  /// the value is set and the time the waiting thread wakes up.\n  /// If the value is equal to the test value when the waiting thread\n  /// wakes up, it will go back into a wait state.  It may be\n  /// necessary for the calling code to use additional thread\n  /// synchronization methods to detect transitory states.\n  ///\n  /// \\param[in] value\n  ///     The value we want \\a m_value to not be equal to.\n  ///\n  /// \\param[in] timeout\n  ///     How long to wait for the condition to hold.\n  ///\n  /// \\return\n  ///     m_value if m_value != value, None otherwise (timeout occurred).\n  llvm::Optional<T>\n  WaitForValueNotEqualTo(T value,\n                         const Timeout<std::micro> &timeout = llvm::None) {\n    return WaitFor([&value](T current) { return value != current; }, timeout);\n  }\n\nprotected:\n  // pthread condition and mutex variable to control access and allow blocking\n  // between the main thread and the spotlight index thread.\n  T m_value; ///< The templatized value T that we are protecting access to\n  mutable std::mutex m_mutex; ///< The mutex to use when accessing the data\n  std::condition_variable m_condition; ///< The pthread condition variable to\n                                       /// use for signaling that data available\n                                       /// or changed.\n\nprivate:\n  /// Broadcast if needed.\n  ///\n  /// Check to see if we need to broadcast to our condition variable\n  /// depending on the \\a old_value and on the \\a broadcast_type.\n  ///\n  /// If \\a broadcast_type is eBroadcastNever, no broadcast will be\n  /// sent.\n  ///\n  /// If \\a broadcast_type is eBroadcastAlways, the condition variable\n  /// will always be broadcast.\n  ///\n  /// If \\a broadcast_type is eBroadcastOnChange, the condition\n  /// variable be broadcast if the owned value changes.\n  void Broadcast(T old_value, PredicateBroadcastType broadcast_type) {\n    bool broadcast =\n        (broadcast_type == eBroadcastAlways) ||\n        ((broadcast_type == eBroadcastOnChange) && old_value != m_value);\n#ifdef DB_PTHREAD_LOG_EVENTS\n    printf(\"%s (old_value = 0x%8.8x, broadcast_type = %i) m_value = 0x%8.8x, \"\n           \"broadcast = %u\\n\",\n           __FUNCTION__, old_value, broadcast_type, m_value, broadcast);\n#endif\n    if (broadcast)\n      m_condition.notify_all();\n  }\n\n  Predicate(const Predicate &) = delete;\n  const Predicate &operator=(const Predicate &) = delete;\n};\n\n} // namespace lldb_private\n\n#endif // LLDB_UTILITY_PREDICATE_H\n"}, "35": {"id": 35, "path": "/home/vsts/work/1/llvm-project/lldb/include/lldb/Utility/ProcessInfo.h", "content": "//===-- ProcessInfo.h -------------------------------------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLDB_UTILITY_PROCESSINFO_H\n#define LLDB_UTILITY_PROCESSINFO_H\n\n#include \"lldb/Utility/ArchSpec.h\"\n#include \"lldb/Utility/Args.h\"\n#include \"lldb/Utility/Environment.h\"\n#include \"lldb/Utility/FileSpec.h\"\n#include \"lldb/Utility/NameMatches.h\"\n#include \"llvm/Support/YAMLTraits.h\"\n#include <vector>\n\nnamespace lldb_private {\n\nclass UserIDResolver;\n\n// ProcessInfo\n//\n// A base class for information for a process. This can be used to fill\n// out information for a process prior to launching it, or it can be used for\n// an instance of a process and can be filled in with the existing values for\n// that process.\nclass ProcessInfo {\npublic:\n  ProcessInfo();\n\n  ProcessInfo(const char *name, const ArchSpec &arch, lldb::pid_t pid);\n\n  void Clear();\n\n  const char *GetName() const;\n\n  llvm::StringRef GetNameAsStringRef() const;\n\n  FileSpec &GetExecutableFile() { return m_executable; }\n\n  void SetExecutableFile(const FileSpec &exe_file,\n                         bool add_exe_file_as_first_arg);\n\n  const FileSpec &GetExecutableFile() const { return m_executable; }\n\n  uint32_t GetUserID() const { return m_uid; }\n\n  uint32_t GetGroupID() const { return m_gid; }\n\n  bool UserIDIsValid() const { return m_uid != UINT32_MAX; }\n\n  bool GroupIDIsValid() const { return m_gid != UINT32_MAX; }\n\n  void SetUserID(uint32_t uid) { m_uid = uid; }\n\n  void SetGroupID(uint32_t gid) { m_gid = gid; }\n\n  ArchSpec &GetArchitecture() { return m_arch; }\n\n  const ArchSpec &GetArchitecture() const { return m_arch; }\n\n  void SetArchitecture(const ArchSpec &arch) { m_arch = arch; }\n\n  lldb::pid_t GetProcessID() const { return m_pid; }\n\n  void SetProcessID(lldb::pid_t pid) { m_pid = pid; }\n\n  bool ProcessIDIsValid() const { return m_pid != LLDB_INVALID_PROCESS_ID; }\n\n  void Dump(Stream &s, Platform *platform) const;\n\n  Args &GetArguments() { return m_arguments; }\n\n  const Args &GetArguments() const { return m_arguments; }\n\n  llvm::StringRef GetArg0() const;\n\n  void SetArg0(llvm::StringRef arg);\n\n  void SetArguments(const Args &args, bool first_arg_is_executable);\n\n  void SetArguments(char const **argv, bool first_arg_is_executable);\n\n  Environment &GetEnvironment() { return m_environment; }\n  const Environment &GetEnvironment() const { return m_environment; }\n\nprotected:\n  template <class T> friend struct llvm::yaml::MappingTraits;\n  FileSpec m_executable;\n  std::string m_arg0; // argv[0] if supported. If empty, then use m_executable.\n  // Not all process plug-ins support specifying an argv[0] that differs from\n  // the resolved platform executable (which is in m_executable)\n  Args m_arguments; // All program arguments except argv[0]\n  Environment m_environment;\n  uint32_t m_uid;\n  uint32_t m_gid;\n  ArchSpec m_arch;\n  lldb::pid_t m_pid;\n};\n\n// ProcessInstanceInfo\n//\n// Describes an existing process and any discoverable information that pertains\n// to that process.\nclass ProcessInstanceInfo : public ProcessInfo {\npublic:\n  ProcessInstanceInfo()\n      : ProcessInfo(), m_euid(UINT32_MAX), m_egid(UINT32_MAX),\n        m_parent_pid(LLDB_INVALID_PROCESS_ID) {}\n\n  ProcessInstanceInfo(const char *name, const ArchSpec &arch, lldb::pid_t pid)\n      : ProcessInfo(name, arch, pid), m_euid(UINT32_MAX), m_egid(UINT32_MAX),\n        m_parent_pid(LLDB_INVALID_PROCESS_ID) {}\n\n  void Clear() {\n    ProcessInfo::Clear();\n    m_euid = UINT32_MAX;\n    m_egid = UINT32_MAX;\n    m_parent_pid = LLDB_INVALID_PROCESS_ID;\n  }\n\n  uint32_t GetEffectiveUserID() const { return m_euid; }\n\n  uint32_t GetEffectiveGroupID() const { return m_egid; }\n\n  bool EffectiveUserIDIsValid() const { return m_euid != UINT32_MAX; }\n\n  bool EffectiveGroupIDIsValid() const { return m_egid != UINT32_MAX; }\n\n  void SetEffectiveUserID(uint32_t uid) { m_euid = uid; }\n\n  void SetEffectiveGroupID(uint32_t gid) { m_egid = gid; }\n\n  lldb::pid_t GetParentProcessID() const { return m_parent_pid; }\n\n  void SetParentProcessID(lldb::pid_t pid) { m_parent_pid = pid; }\n\n  bool ParentProcessIDIsValid() const {\n    return m_parent_pid != LLDB_INVALID_PROCESS_ID;\n  }\n\n  void Dump(Stream &s, UserIDResolver &resolver) const;\n\n  static void DumpTableHeader(Stream &s, bool show_args, bool verbose);\n\n  void DumpAsTableRow(Stream &s, UserIDResolver &resolver, bool show_args,\n                      bool verbose) const;\n\nprotected:\n  friend struct llvm::yaml::MappingTraits<ProcessInstanceInfo>;\n  uint32_t m_euid;\n  uint32_t m_egid;\n  lldb::pid_t m_parent_pid;\n};\n\ntypedef std::vector<ProcessInstanceInfo> ProcessInstanceInfoList;\n\n// ProcessInstanceInfoMatch\n//\n// A class to help matching one ProcessInstanceInfo to another.\n\nclass ProcessInstanceInfoMatch {\npublic:\n  ProcessInstanceInfoMatch()\n      : m_match_info(), m_name_match_type(NameMatch::Ignore),\n        m_match_all_users(false) {}\n\n  ProcessInstanceInfoMatch(const char *process_name,\n                           NameMatch process_name_match_type)\n      : m_match_info(), m_name_match_type(process_name_match_type),\n        m_match_all_users(false) {\n    m_match_info.GetExecutableFile().SetFile(process_name,\n                                             FileSpec::Style::native);\n  }\n\n  ProcessInstanceInfo &GetProcessInfo() { return m_match_info; }\n\n  const ProcessInstanceInfo &GetProcessInfo() const { return m_match_info; }\n\n  bool GetMatchAllUsers() const { return m_match_all_users; }\n\n  void SetMatchAllUsers(bool b) { m_match_all_users = b; }\n\n  NameMatch GetNameMatchType() const { return m_name_match_type; }\n\n  void SetNameMatchType(NameMatch name_match_type) {\n    m_name_match_type = name_match_type;\n  }\n\n  /// Return true iff the architecture in this object matches arch_spec.\n  bool ArchitectureMatches(const ArchSpec &arch_spec) const;\n\n  /// Return true iff the process name in this object matches process_name.\n  bool NameMatches(const char *process_name) const;\n\n  /// Return true iff the process ID and parent process IDs in this object match\n  /// the ones in proc_info.\n  bool ProcessIDsMatch(const ProcessInstanceInfo &proc_info) const;\n\n  /// Return true iff the (both effective and real) user and group IDs in this\n  /// object match the ones in proc_info.\n  bool UserIDsMatch(const ProcessInstanceInfo &proc_info) const;\n\n  bool Matches(const ProcessInstanceInfo &proc_info) const;\n\n  bool MatchAllProcesses() const;\n  void Clear();\n\nprotected:\n  ProcessInstanceInfo m_match_info;\n  NameMatch m_name_match_type;\n  bool m_match_all_users;\n};\n\nnamespace repro {\nllvm::Optional<ProcessInstanceInfoList> GetReplayProcessInstanceInfoList();\n} // namespace repro\n} // namespace lldb_private\n\nLLVM_YAML_IS_SEQUENCE_VECTOR(lldb_private::ProcessInstanceInfo)\n\nnamespace llvm {\nnamespace yaml {\ntemplate <> struct MappingTraits<lldb_private::ProcessInstanceInfo> {\n  static void mapping(IO &io, lldb_private::ProcessInstanceInfo &PII);\n};\n} // namespace yaml\n} // namespace llvm\n\n#endif // LLDB_UTILITY_PROCESSINFO_H\n"}, "36": {"id": 36, "path": "/home/vsts/work/1/llvm-project/lldb/include/lldb/Utility/RangeMap.h", "content": "//===-- RangeMap.h ----------------------------------------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLDB_UTILITY_RANGEMAP_H\n#define LLDB_UTILITY_RANGEMAP_H\n\n#include <algorithm>\n#include <vector>\n\n#include \"llvm/ADT/SmallVector.h\"\n\n#include \"lldb/lldb-private.h\"\n\n// Uncomment to make sure all Range objects are sorted when needed\n//#define ASSERT_RANGEMAP_ARE_SORTED\n\nnamespace lldb_private {\n\n// Templatized classes for dealing with generic ranges and also collections of\n// ranges, or collections of ranges that have associated data.\n\n// A simple range class where you get to define the type of the range\n// base \"B\", and the type used for the range byte size \"S\".\ntemplate <typename B, typename S> struct Range {\n  typedef B BaseType;\n  typedef S SizeType;\n\n  BaseType base;\n  SizeType size;\n\n  Range() : base(0), size(0) {}\n\n  Range(BaseType b, SizeType s) : base(b), size(s) {}\n\n  void Clear(BaseType b = 0) {\n    base = b;\n    size = 0;\n  }\n\n  // Set the start value for the range, and keep the same size\n  BaseType GetRangeBase() const { return base; }\n\n  void SetRangeBase(BaseType b) { base = b; }\n\n  void Slide(BaseType slide) { base += slide; }\n\n  bool Union(const Range &rhs) {\n    if (DoesAdjoinOrIntersect(rhs)) {\n      auto new_end = std::max<BaseType>(GetRangeEnd(), rhs.GetRangeEnd());\n      base = std::min<BaseType>(base, rhs.base);\n      size = new_end - base;\n      return true;\n    }\n    return false;\n  }\n\n  BaseType GetRangeEnd() const { return base + size; }\n\n  void SetRangeEnd(BaseType end) {\n    if (end > base)\n      size = end - base;\n    else\n      size = 0;\n  }\n\n  SizeType GetByteSize() const { return size; }\n\n  void SetByteSize(SizeType s) { size = s; }\n\n  bool IsValid() const { return size > 0; }\n\n  bool Contains(BaseType r) const {\n    return (GetRangeBase() <= r) && (r < GetRangeEnd());\n  }\n\n  bool ContainsEndInclusive(BaseType r) const {\n    return (GetRangeBase() <= r) && (r <= GetRangeEnd());\n  }\n\n  bool Contains(const Range &range) const {\n    return Contains(range.GetRangeBase()) &&\n           ContainsEndInclusive(range.GetRangeEnd());\n  }\n\n  // Returns true if the two ranges adjoing or intersect\n  bool DoesAdjoinOrIntersect(const Range &rhs) const {\n    const BaseType lhs_base = this->GetRangeBase();\n    const BaseType rhs_base = rhs.GetRangeBase();\n    const BaseType lhs_end = this->GetRangeEnd();\n    const BaseType rhs_end = rhs.GetRangeEnd();\n    bool result = (lhs_base <= rhs_end) && (lhs_end >= rhs_base);\n    return result;\n  }\n\n  // Returns true if the two ranges intersect\n  bool DoesIntersect(const Range &rhs) const {\n    const BaseType lhs_base = this->GetRangeBase();\n    const BaseType rhs_base = rhs.GetRangeBase();\n    const BaseType lhs_end = this->GetRangeEnd();\n    const BaseType rhs_end = rhs.GetRangeEnd();\n    bool result = (lhs_base < rhs_end) && (lhs_end > rhs_base);\n    return result;\n  }\n\n  bool operator<(const Range &rhs) const {\n    if (base == rhs.base)\n      return size < rhs.size;\n    return base < rhs.base;\n  }\n\n  bool operator==(const Range &rhs) const {\n    return base == rhs.base && size == rhs.size;\n  }\n\n  bool operator!=(const Range &rhs) const {\n    return base != rhs.base || size != rhs.size;\n  }\n};\n\ntemplate <typename B, typename S, unsigned N = 0> class RangeVector {\npublic:\n  typedef B BaseType;\n  typedef S SizeType;\n  typedef Range<B, S> Entry;\n  typedef llvm::SmallVector<Entry, N> Collection;\n\n  RangeVector() = default;\n\n  ~RangeVector() = default;\n\n  void Append(const Entry &entry) { m_entries.push_back(entry); }\n\n  void Append(B base, S size) { m_entries.emplace_back(base, size); }\n\n  // Insert an item into a sorted list and optionally combine it with any\n  // adjacent blocks if requested.\n  void Insert(const Entry &entry, bool combine) {\n    if (m_entries.empty()) {\n      m_entries.push_back(entry);\n      return;\n    }\n    auto begin = m_entries.begin();\n    auto end = m_entries.end();\n    auto pos = std::lower_bound(begin, end, entry);\n    if (combine) {\n      if (pos != end && pos->Union(entry)) {\n        CombinePrevAndNext(pos);\n        return;\n      }\n      if (pos != begin) {\n        auto prev = pos - 1;\n        if (prev->Union(entry)) {\n          CombinePrevAndNext(prev);\n          return;\n        }\n      }\n    }\n    m_entries.insert(pos, entry);\n  }\n\n  bool RemoveEntryAtIndex(uint32_t idx) {\n    if (idx < m_entries.size()) {\n      m_entries.erase(m_entries.begin() + idx);\n      return true;\n    }\n    return false;\n  }\n\n  void Sort() {\n    if (m_entries.size() > 1)\n      std::stable_sort(m_entries.begin(), m_entries.end());\n  }\n\n#ifdef ASSERT_RANGEMAP_ARE_SORTED\n  bool IsSorted() const {\n    typename Collection::const_iterator pos, end, prev;\n    // First we determine if we can combine any of the Entry objects so we\n    // don't end up allocating and making a new collection for no reason\n    for (pos = m_entries.begin(), end = m_entries.end(), prev = end; pos != end;\n         prev = pos++) {\n      if (prev != end && *pos < *prev)\n        return false;\n    }\n    return true;\n  }\n#endif\n\n  void CombineConsecutiveRanges() {\n#ifdef ASSERT_RANGEMAP_ARE_SORTED\n    assert(IsSorted());\n#endif\n    auto first_intersect = std::adjacent_find(\n        m_entries.begin(), m_entries.end(), [](const Entry &a, const Entry &b) {\n          return a.DoesAdjoinOrIntersect(b);\n        });\n    if (first_intersect == m_entries.end())\n      return;\n\n    // We we can combine at least one entry, then we make a new collection and\n    // populate it accordingly, and then swap it into place.\n    auto pos = std::next(first_intersect);\n    Collection minimal_ranges(m_entries.begin(), pos);\n    for (; pos != m_entries.end(); ++pos) {\n      Entry &back = minimal_ranges.back();\n      if (back.DoesAdjoinOrIntersect(*pos))\n        back.SetRangeEnd(std::max(back.GetRangeEnd(), pos->GetRangeEnd()));\n      else\n        minimal_ranges.push_back(*pos);\n    }\n    m_entries.swap(minimal_ranges);\n  }\n\n  BaseType GetMinRangeBase(BaseType fail_value) const {\n#ifdef ASSERT_RANGEMAP_ARE_SORTED\n    assert(IsSorted());\n#endif\n    if (m_entries.empty())\n      return fail_value;\n    // m_entries must be sorted, so if we aren't empty, we grab the first\n    // range's base\n    return m_entries.front().GetRangeBase();\n  }\n\n  BaseType GetMaxRangeEnd(BaseType fail_value) const {\n#ifdef ASSERT_RANGEMAP_ARE_SORTED\n    assert(IsSorted());\n#endif\n    if (m_entries.empty())\n      return fail_value;\n    // m_entries must be sorted, so if we aren't empty, we grab the last\n    // range's end\n    return m_entries.back().GetRangeEnd();\n  }\n\n  void Slide(BaseType slide) {\n    typename Collection::iterator pos, end;\n    for (pos = m_entries.begin(), end = m_entries.end(); pos != end; ++pos)\n      pos->Slide(slide);\n  }\n\n  void Clear() { m_entries.clear(); }\n\n  void Reserve(typename Collection::size_type size) { m_entries.reserve(size); }\n\n  bool IsEmpty() const { return m_entries.empty(); }\n\n  size_t GetSize() const { return m_entries.size(); }\n\n  const Entry *GetEntryAtIndex(size_t i) const {\n    return ((i < m_entries.size()) ? &m_entries[i] : nullptr);\n  }\n\n  // Clients must ensure that \"i\" is a valid index prior to calling this\n  // function\n  Entry &GetEntryRef(size_t i) { return m_entries[i]; }\n  const Entry &GetEntryRef(size_t i) const { return m_entries[i]; }\n\n  Entry *Back() { return (m_entries.empty() ? nullptr : &m_entries.back()); }\n\n  const Entry *Back() const {\n    return (m_entries.empty() ? nullptr : &m_entries.back());\n  }\n\n  static bool BaseLessThan(const Entry &lhs, const Entry &rhs) {\n    return lhs.GetRangeBase() < rhs.GetRangeBase();\n  }\n\n  uint32_t FindEntryIndexThatContains(B addr) const {\n#ifdef ASSERT_RANGEMAP_ARE_SORTED\n    assert(IsSorted());\n#endif\n    if (!m_entries.empty()) {\n      Entry entry(addr, 1);\n      typename Collection::const_iterator begin = m_entries.begin();\n      typename Collection::const_iterator end = m_entries.end();\n      typename Collection::const_iterator pos =\n          std::lower_bound(begin, end, entry, BaseLessThan);\n\n      if (pos != end && pos->Contains(addr)) {\n        return std::distance(begin, pos);\n      } else if (pos != begin) {\n        --pos;\n        if (pos->Contains(addr))\n          return std::distance(begin, pos);\n      }\n    }\n    return UINT32_MAX;\n  }\n\n  const Entry *FindEntryThatContains(B addr) const {\n#ifdef ASSERT_RANGEMAP_ARE_SORTED\n    assert(IsSorted());\n#endif\n    if (!m_entries.empty()) {\n      Entry entry(addr, 1);\n      typename Collection::const_iterator begin = m_entries.begin();\n      typename Collection::const_iterator end = m_entries.end();\n      typename Collection::const_iterator pos =\n          std::lower_bound(begin, end, entry, BaseLessThan);\n\n      if (pos != end && pos->Contains(addr)) {\n        return &(*pos);\n      } else if (pos != begin) {\n        --pos;\n        if (pos->Contains(addr)) {\n          return &(*pos);\n        }\n      }\n    }\n    return nullptr;\n  }\n\n  const Entry *FindEntryThatContains(const Entry &range) const {\n#ifdef ASSERT_RANGEMAP_ARE_SORTED\n    assert(IsSorted());\n#endif\n    if (!m_entries.empty()) {\n      typename Collection::const_iterator begin = m_entries.begin();\n      typename Collection::const_iterator end = m_entries.end();\n      typename Collection::const_iterator pos =\n          std::lower_bound(begin, end, range, BaseLessThan);\n\n      if (pos != end && pos->Contains(range)) {\n        return &(*pos);\n      } else if (pos != begin) {\n        --pos;\n        if (pos->Contains(range)) {\n          return &(*pos);\n        }\n      }\n    }\n    return nullptr;\n  }\n\n  using const_iterator = typename Collection::const_iterator;\n  const_iterator begin() const { return m_entries.begin(); }\n  const_iterator end() const { return m_entries.end(); }\n\nprotected:\n  void CombinePrevAndNext(typename Collection::iterator pos) {\n    // Check if the prev or next entries in case they need to be unioned with\n    // the entry pointed to by \"pos\".\n    if (pos != m_entries.begin()) {\n      auto prev = pos - 1;\n      if (prev->Union(*pos))\n        m_entries.erase(pos);\n      pos = prev;\n    }\n\n    auto end = m_entries.end();\n    if (pos != end) {\n      auto next = pos + 1;\n      if (next != end) {\n        if (pos->Union(*next))\n          m_entries.erase(next);\n      }\n    }\n    return;\n  }\n\n  Collection m_entries;\n};\n\n// A simple range  with data class where you get to define the type of\n// the range base \"B\", the type used for the range byte size \"S\", and the type\n// for the associated data \"T\".\ntemplate <typename B, typename S, typename T>\nstruct RangeData : public Range<B, S> {\n  typedef T DataType;\n\n  DataType data;\n\n  RangeData() : Range<B, S>(), data() {}\n\n  RangeData(B base, S size) : Range<B, S>(base, size), data() {}\n\n  RangeData(B base, S size, DataType d) : Range<B, S>(base, size), data(d) {}\n};\n\n// We can treat the vector as a flattened Binary Search Tree, augmenting it\n// with upper bounds (max of range endpoints) for every index allows us to\n// query for range containment quicker.\ntemplate <typename B, typename S, typename T>\nstruct AugmentedRangeData : public RangeData<B, S, T> {\n  B upper_bound;\n\n  AugmentedRangeData(const RangeData<B, S, T> &rd)\n      : RangeData<B, S, T>(rd), upper_bound() {}\n};\n\ntemplate <typename B, typename S, typename T, unsigned N = 0,\n          class Compare = std::less<T>>\nclass RangeDataVector {\npublic:\n  typedef lldb_private::Range<B, S> Range;\n  typedef RangeData<B, S, T> Entry;\n  typedef AugmentedRangeData<B, S, T> AugmentedEntry;\n  typedef llvm::SmallVector<AugmentedEntry, N> Collection;\n\n  RangeDataVector(Compare compare = Compare()) : m_compare(compare) {}\n\n  ~RangeDataVector() = default;\n\n  void Append(const Entry &entry) { m_entries.emplace_back(entry); }\n\n  void Sort() {\n    if (m_entries.size() > 1)\n      std::stable_sort(m_entries.begin(), m_entries.end(),\n                       [&compare = m_compare](const Entry &a, const Entry &b) {\n                         if (a.base != b.base)\n                           return a.base < b.base;\n                         if (a.size != b.size)\n                           return a.size < b.size;\n                         return compare(a.data, b.data);\n                       });\n    if (!m_entries.empty())\n      ComputeUpperBounds(0, m_entries.size());\n  }\n\n#ifdef ASSERT_RANGEMAP_ARE_SORTED\n  bool IsSorted() const {\n    typename Collection::const_iterator pos, end, prev;\n    for (pos = m_entries.begin(), end = m_entries.end(), prev = end; pos != end;\n         prev = pos++) {\n      if (prev != end && *pos < *prev)\n        return false;\n    }\n    return true;\n  }\n#endif\n\n  void CombineConsecutiveEntriesWithEqualData() {\n#ifdef ASSERT_RANGEMAP_ARE_SORTED\n    assert(IsSorted());\n#endif\n    typename Collection::iterator pos;\n    typename Collection::iterator end;\n    typename Collection::iterator prev;\n    bool can_combine = false;\n    // First we determine if we can combine any of the Entry objects so we\n    // don't end up allocating and making a new collection for no reason\n    for (pos = m_entries.begin(), end = m_entries.end(), prev = end; pos != end;\n         prev = pos++) {\n      if (prev != end && prev->data == pos->data) {\n        can_combine = true;\n        break;\n      }\n    }\n\n    // We we can combine at least one entry, then we make a new collection and\n    // populate it accordingly, and then swap it into place.\n    if (can_combine) {\n      Collection minimal_ranges;\n      for (pos = m_entries.begin(), end = m_entries.end(), prev = end;\n           pos != end; prev = pos++) {\n        if (prev != end && prev->data == pos->data)\n          minimal_ranges.back().SetRangeEnd(pos->GetRangeEnd());\n        else\n          minimal_ranges.push_back(*pos);\n      }\n      // Use the swap technique in case our new vector is much smaller. We must\n      // swap when using the STL because std::vector objects never release or\n      // reduce the memory once it has been allocated/reserved.\n      m_entries.swap(minimal_ranges);\n    }\n  }\n\n  void Clear() { m_entries.clear(); }\n\n  bool IsEmpty() const { return m_entries.empty(); }\n\n  size_t GetSize() const { return m_entries.size(); }\n\n  const Entry *GetEntryAtIndex(size_t i) const {\n    return ((i < m_entries.size()) ? &m_entries[i] : nullptr);\n  }\n\n  Entry *GetMutableEntryAtIndex(size_t i) {\n    return ((i < m_entries.size()) ? &m_entries[i] : nullptr);\n  }\n\n  // Clients must ensure that \"i\" is a valid index prior to calling this\n  // function\n  Entry &GetEntryRef(size_t i) { return m_entries[i]; }\n  const Entry &GetEntryRef(size_t i) const { return m_entries[i]; }\n\n  static bool BaseLessThan(const Entry &lhs, const Entry &rhs) {\n    return lhs.GetRangeBase() < rhs.GetRangeBase();\n  }\n\n  uint32_t FindEntryIndexThatContains(B addr) const {\n    const AugmentedEntry *entry =\n        static_cast<const AugmentedEntry *>(FindEntryThatContains(addr));\n    if (entry)\n      return std::distance(m_entries.begin(), entry);\n    return UINT32_MAX;\n  }\n\n  uint32_t FindEntryIndexesThatContain(B addr, std::vector<uint32_t> &indexes) {\n#ifdef ASSERT_RANGEMAP_ARE_SORTED\n    assert(IsSorted());\n#endif\n    if (!m_entries.empty())\n      FindEntryIndexesThatContain(addr, 0, m_entries.size(), indexes);\n\n    return indexes.size();\n  }\n\n  Entry *FindEntryThatContains(B addr) {\n    return const_cast<Entry *>(\n        static_cast<const RangeDataVector *>(this)->FindEntryThatContains(\n            addr));\n  }\n\n  const Entry *FindEntryThatContains(B addr) const {\n    return FindEntryThatContains(Entry(addr, 1));\n  }\n\n  const Entry *FindEntryThatContains(const Entry &range) const {\n#ifdef ASSERT_RANGEMAP_ARE_SORTED\n    assert(IsSorted());\n#endif\n    if (!m_entries.empty()) {\n      typename Collection::const_iterator begin = m_entries.begin();\n      typename Collection::const_iterator end = m_entries.end();\n      typename Collection::const_iterator pos =\n          std::lower_bound(begin, end, range, BaseLessThan);\n\n      while (pos != begin && pos[-1].Contains(range))\n        --pos;\n\n      if (pos != end && pos->Contains(range))\n        return &(*pos);\n    }\n    return nullptr;\n  }\n\n  const Entry *FindEntryStartsAt(B addr) const {\n#ifdef ASSERT_RANGEMAP_ARE_SORTED\n    assert(IsSorted());\n#endif\n    if (!m_entries.empty()) {\n      auto begin = m_entries.begin(), end = m_entries.end();\n      auto pos = std::lower_bound(begin, end, Entry(addr, 1), BaseLessThan);\n      if (pos != end && pos->base == addr)\n        return &(*pos);\n    }\n    return nullptr;\n  }\n\n  // This method will return the entry that contains the given address, or the\n  // entry following that address.  If you give it an address of 0 and the\n  // first entry starts at address 0x100, you will get the entry at 0x100.\n  //\n  // For most uses, FindEntryThatContains is the correct one to use, this is a\n  // less commonly needed behavior.  It was added for core file memory regions,\n  // where we want to present a gap in the memory regions as a distinct region,\n  // so we need to know the start address of the next memory section that\n  // exists.\n  const Entry *FindEntryThatContainsOrFollows(B addr) const {\n#ifdef ASSERT_RANGEMAP_ARE_SORTED\n    assert(IsSorted());\n#endif\n    if (!m_entries.empty()) {\n      typename Collection::const_iterator begin = m_entries.begin();\n      typename Collection::const_iterator end = m_entries.end();\n      typename Collection::const_iterator pos =\n          std::lower_bound(m_entries.begin(), end, addr,\n                           [](const Entry &lhs, B rhs_base) -> bool {\n                             return lhs.GetRangeEnd() <= rhs_base;\n                           });\n\n      while (pos != begin && pos[-1].Contains(addr))\n        --pos;\n\n      if (pos != end)\n        return &(*pos);\n    }\n    return nullptr;\n  }\n\n  Entry *Back() { return (m_entries.empty() ? nullptr : &m_entries.back()); }\n\n  const Entry *Back() const {\n    return (m_entries.empty() ? nullptr : &m_entries.back());\n  }\n\nprotected:\n  Collection m_entries;\n  Compare m_compare;\n\nprivate:\n  // Compute extra information needed for search\n  B ComputeUpperBounds(size_t lo, size_t hi) {\n    size_t mid = (lo + hi) / 2;\n    AugmentedEntry &entry = m_entries[mid];\n\n    entry.upper_bound = entry.base + entry.size;\n\n    if (lo < mid)\n      entry.upper_bound =\n          std::max(entry.upper_bound, ComputeUpperBounds(lo, mid));\n\n    if (mid + 1 < hi)\n      entry.upper_bound =\n          std::max(entry.upper_bound, ComputeUpperBounds(mid + 1, hi));\n\n    return entry.upper_bound;\n  }\n\n  // This is based on the augmented tree implementation found at\n  // https://en.wikipedia.org/wiki/Interval_tree#Augmented_tree\n  void FindEntryIndexesThatContain(B addr, size_t lo, size_t hi,\n                                   std::vector<uint32_t> &indexes) {\n    size_t mid = (lo + hi) / 2;\n    const AugmentedEntry &entry = m_entries[mid];\n\n    // addr is greater than the rightmost point of any interval below mid\n    // so there are cannot be any matches.\n    if (addr > entry.upper_bound)\n      return;\n\n    // Recursively search left subtree\n    if (lo < mid)\n      FindEntryIndexesThatContain(addr, lo, mid, indexes);\n\n    // If addr is smaller than the start of the current interval it\n    // cannot contain it nor can any of its right subtree.\n    if (addr < entry.base)\n      return;\n\n    if (entry.Contains(addr))\n      indexes.push_back(entry.data);\n\n    // Recursively search right subtree\n    if (mid + 1 < hi)\n      FindEntryIndexesThatContain(addr, mid + 1, hi, indexes);\n  }\n};\n\n// A simple range  with data class where you get to define the type of\n// the range base \"B\", the type used for the range byte size \"S\", and the type\n// for the associated data \"T\".\ntemplate <typename B, typename T> struct AddressData {\n  typedef B BaseType;\n  typedef T DataType;\n\n  BaseType addr;\n  DataType data;\n\n  AddressData() : addr(), data() {}\n\n  AddressData(B a, DataType d) : addr(a), data(d) {}\n\n  bool operator<(const AddressData &rhs) const {\n    if (this->addr == rhs.addr)\n      return this->data < rhs.data;\n    return this->addr < rhs.addr;\n  }\n\n  bool operator==(const AddressData &rhs) const {\n    return this->addr == rhs.addr && this->data == rhs.data;\n  }\n\n  bool operator!=(const AddressData &rhs) const {\n    return this->addr != rhs.addr || this->data == rhs.data;\n  }\n};\n\ntemplate <typename B, typename T, unsigned N> class AddressDataArray {\npublic:\n  typedef AddressData<B, T> Entry;\n  typedef llvm::SmallVector<Entry, N> Collection;\n\n  AddressDataArray() = default;\n\n  ~AddressDataArray() = default;\n\n  void Append(const Entry &entry) { m_entries.push_back(entry); }\n\n  void Sort() {\n    if (m_entries.size() > 1)\n      std::stable_sort(m_entries.begin(), m_entries.end());\n  }\n\n#ifdef ASSERT_RANGEMAP_ARE_SORTED\n  bool IsSorted() const {\n    typename Collection::const_iterator pos, end, prev;\n    // First we determine if we can combine any of the Entry objects so we\n    // don't end up allocating and making a new collection for no reason\n    for (pos = m_entries.begin(), end = m_entries.end(), prev = end; pos != end;\n         prev = pos++) {\n      if (prev != end && *pos < *prev)\n        return false;\n    }\n    return true;\n  }\n#endif\n\n  void Clear() { m_entries.clear(); }\n\n  bool IsEmpty() const { return m_entries.empty(); }\n\n  size_t GetSize() const { return m_entries.size(); }\n\n  const Entry *GetEntryAtIndex(size_t i) const {\n    return ((i < m_entries.size()) ? &m_entries[i] : nullptr);\n  }\n\n  // Clients must ensure that \"i\" is a valid index prior to calling this\n  // function\n  const Entry &GetEntryRef(size_t i) const { return m_entries[i]; }\n\n  static bool BaseLessThan(const Entry &lhs, const Entry &rhs) {\n    return lhs.addr < rhs.addr;\n  }\n\n  Entry *FindEntry(B addr, bool exact_match_only) {\n#ifdef ASSERT_RANGEMAP_ARE_SORTED\n    assert(IsSorted());\n#endif\n    if (!m_entries.empty()) {\n      Entry entry;\n      entry.addr = addr;\n      typename Collection::iterator begin = m_entries.begin();\n      typename Collection::iterator end = m_entries.end();\n      typename Collection::iterator pos =\n          std::lower_bound(begin, end, entry, BaseLessThan);\n\n      while (pos != begin && pos[-1].addr == addr)\n        --pos;\n\n      if (pos != end) {\n        if (pos->addr == addr || !exact_match_only)\n          return &(*pos);\n      }\n    }\n    return nullptr;\n  }\n\n  const Entry *FindNextEntry(const Entry *entry) {\n    if (entry >= &*m_entries.begin() && entry + 1 < &*m_entries.end())\n      return entry + 1;\n    return nullptr;\n  }\n\n  Entry *Back() { return (m_entries.empty() ? nullptr : &m_entries.back()); }\n\n  const Entry *Back() const {\n    return (m_entries.empty() ? nullptr : &m_entries.back());\n  }\n\nprotected:\n  Collection m_entries;\n};\n\n} // namespace lldb_private\n\n#endif // LLDB_UTILITY_RANGEMAP_H\n"}, "37": {"id": 37, "path": "/home/vsts/work/1/llvm-project/lldb/include/lldb/Utility/Scalar.h", "content": "//===-- Scalar.h ------------------------------------------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLDB_UTILITY_SCALAR_H\n#define LLDB_UTILITY_SCALAR_H\n\n#include \"lldb/Utility/LLDBAssert.h\"\n#include \"lldb/Utility/Status.h\"\n#include \"lldb/lldb-enumerations.h\"\n#include \"lldb/lldb-private-types.h\"\n#include \"llvm/ADT/APFloat.h\"\n#include \"llvm/ADT/APSInt.h\"\n#include <cstddef>\n#include <cstdint>\n#include <utility>\n\nnamespace lldb_private {\n\nclass DataExtractor;\nclass Stream;\n\n#define NUM_OF_WORDS_INT128 2\n#define BITWIDTH_INT128 128\n\n// A class designed to hold onto values and their corresponding types.\n// Operators are defined and Scalar objects will correctly promote their types\n// and values before performing these operations. Type promotion currently\n// follows the ANSI C type promotion rules.\nclass Scalar {\n  template<typename T>\n  static llvm::APSInt MakeAPSInt(T v) {\n    static_assert(std::is_integral<T>::value, \"\");\n    static_assert(sizeof(T) <= sizeof(uint64_t), \"Conversion loses precision!\");\n    return llvm::APSInt(\n        llvm::APInt(sizeof(T) * 8, uint64_t(v), std::is_signed<T>::value),\n        std::is_unsigned<T>::value);\n  }\n\npublic:\n  enum Type {\n    e_void = 0,\n    e_int,\n    e_float,\n  };\n\n  // Constructors and Destructors\n  Scalar() : m_type(e_void), m_float(0.0f) {}\n  Scalar(int v) : m_type(e_int), m_integer(MakeAPSInt(v)), m_float(0.0f) {}\n  Scalar(unsigned int v)\n      : m_type(e_int), m_integer(MakeAPSInt(v)), m_float(0.0f) {}\n  Scalar(long v) : m_type(e_int), m_integer(MakeAPSInt(v)), m_float(0.0f) {}\n  Scalar(unsigned long v)\n      : m_type(e_int), m_integer(MakeAPSInt(v)), m_float(0.0f) {}\n  Scalar(long long v)\n      : m_type(e_int), m_integer(MakeAPSInt(v)), m_float(0.0f) {}\n  Scalar(unsigned long long v)\n      : m_type(e_int), m_integer(MakeAPSInt(v)), m_float(0.0f) {}\n  Scalar(float v) : m_type(e_float), m_float(v) {}\n  Scalar(double v) : m_type(e_float), m_float(v) {}\n  Scalar(long double v) : m_type(e_float), m_float(double(v)) {\n    bool ignore;\n    m_float.convert(llvm::APFloat::x87DoubleExtended(),\n                    llvm::APFloat::rmNearestTiesToEven, &ignore);\n  }\n  Scalar(llvm::APInt v)\n      : m_type(e_int), m_integer(std::move(v), false), m_float(0.0f) {}\n  Scalar(llvm::APSInt v)\n      : m_type(e_int), m_integer(std::move(v)), m_float(0.0f) {}\n\n  bool SignExtend(uint32_t bit_pos);\n\n  bool ExtractBitfield(uint32_t bit_size, uint32_t bit_offset);\n\n  bool SetBit(uint32_t bit);\n\n  bool ClearBit(uint32_t bit);\n\n  /// Store the binary representation of this value into the given storage.\n  /// Exactly GetByteSize() bytes will be stored, and the buffer must be large\n  /// enough to hold this data.\n  void GetBytes(llvm::MutableArrayRef<uint8_t> storage) const;\n\n  size_t GetByteSize() const;\n\n  bool GetData(DataExtractor &data, size_t limit_byte_size = UINT32_MAX) const;\n\n  size_t GetAsMemoryData(void *dst, size_t dst_len,\n                         lldb::ByteOrder dst_byte_order, Status &error) const;\n\n  bool IsZero() const;\n\n  void Clear() {\n    m_type = e_void;\n    m_integer.clearAllBits();\n  }\n\n  const char *GetTypeAsCString() const { return GetValueTypeAsCString(m_type); }\n\n  void GetValue(Stream *s, bool show_type) const;\n\n  bool IsValid() const { return (m_type >= e_int) && (m_type <= e_float); }\n\n  /// Convert to an integer with \\p bits and the given signedness.\n  void TruncOrExtendTo(uint16_t bits, bool sign);\n\n  bool IntegralPromote(uint16_t bits, bool sign);\n  bool FloatPromote(const llvm::fltSemantics &semantics);\n\n  bool IsSigned() const;\n  bool MakeSigned();\n\n  bool MakeUnsigned();\n\n  static const char *GetValueTypeAsCString(Scalar::Type value_type);\n\n  // All operators can benefits from the implicit conversions that will happen\n  // automagically by the compiler, so no temporary objects will need to be\n  // created. As a result, we currently don't need a variety of overloaded set\n  // value accessors.\n  Scalar &operator+=(Scalar rhs);\n  Scalar &operator<<=(const Scalar &rhs); // Shift left\n  Scalar &operator>>=(const Scalar &rhs); // Shift right (arithmetic)\n  Scalar &operator&=(const Scalar &rhs);\n\n  // Shifts the current value to the right without maintaining the current sign\n  // of the value (if it is signed).\n  bool ShiftRightLogical(const Scalar &rhs); // Returns true on success\n\n  // Takes the absolute value of the current value if it is signed, else the\n  // value remains unchanged. Returns false if the contained value has a void\n  // type.\n  bool AbsoluteValue(); // Returns true on success\n  // Negates the current value (even for unsigned values). Returns false if the\n  // contained value has a void type.\n  bool UnaryNegate(); // Returns true on success\n  // Inverts all bits in the current value as long as it isn't void or a\n  // float/double/long double type. Returns false if the contained value has a\n  // void/float/double/long double type, else the value is inverted and true is\n  // returned.\n  bool OnesComplement(); // Returns true on success\n\n  // Access the type of the current value.\n  Scalar::Type GetType() const { return m_type; }\n\n  // Returns a casted value of the current contained data without modifying the\n  // current value. FAIL_VALUE will be returned if the type of the value is\n  // void or invalid.\n  int SInt(int fail_value = 0) const;\n\n  unsigned char UChar(unsigned char fail_value = 0) const;\n\n  signed char SChar(signed char fail_value = 0) const;\n\n  unsigned short UShort(unsigned short fail_value = 0) const;\n\n  short SShort(short fail_value = 0) const;\n\n  unsigned int UInt(unsigned int fail_value = 0) const;\n\n  long SLong(long fail_value = 0) const;\n\n  unsigned long ULong(unsigned long fail_value = 0) const;\n\n  long long SLongLong(long long fail_value = 0) const;\n\n  unsigned long long ULongLong(unsigned long long fail_value = 0) const;\n\n  llvm::APInt SInt128(const llvm::APInt &fail_value) const;\n\n  llvm::APInt UInt128(const llvm::APInt &fail_value) const;\n\n  float Float(float fail_value = 0.0f) const;\n\n  double Double(double fail_value = 0.0) const;\n\n  long double LongDouble(long double fail_value = 0.0) const;\n\n  Status SetValueFromCString(const char *s, lldb::Encoding encoding,\n                             size_t byte_size);\n\n  Status SetValueFromData(const DataExtractor &data, lldb::Encoding encoding,\n                          size_t byte_size);\n\nprotected:\n  Scalar::Type m_type;\n  llvm::APSInt m_integer;\n  llvm::APFloat m_float;\n\n  template <typename T> T GetAs(T fail_value) const;\n\n  static Type PromoteToMaxType(Scalar &lhs, Scalar &rhs);\n\n  using PromotionKey = std::tuple<Type, unsigned, bool>;\n  PromotionKey GetPromoKey() const;\n\n  static PromotionKey GetFloatPromoKey(const llvm::fltSemantics &semantics);\n\nprivate:\n  friend const Scalar operator+(const Scalar &lhs, const Scalar &rhs);\n  friend const Scalar operator-(Scalar lhs, Scalar rhs);\n  friend const Scalar operator/(Scalar lhs, Scalar rhs);\n  friend const Scalar operator*(Scalar lhs, Scalar rhs);\n  friend const Scalar operator&(Scalar lhs, Scalar rhs);\n  friend const Scalar operator|(Scalar lhs, Scalar rhs);\n  friend const Scalar operator%(Scalar lhs, Scalar rhs);\n  friend const Scalar operator^(Scalar lhs, Scalar rhs);\n  friend const Scalar operator<<(const Scalar &lhs, const Scalar &rhs);\n  friend const Scalar operator>>(const Scalar &lhs, const Scalar &rhs);\n  friend bool operator==(Scalar lhs, Scalar rhs);\n  friend bool operator!=(const Scalar &lhs, const Scalar &rhs);\n  friend bool operator<(Scalar lhs, Scalar rhs);\n  friend bool operator<=(const Scalar &lhs, const Scalar &rhs);\n  friend bool operator>(const Scalar &lhs, const Scalar &rhs);\n  friend bool operator>=(const Scalar &lhs, const Scalar &rhs);\n};\n\n// Split out the operators into a format where the compiler will be able to\n// implicitly convert numbers into Scalar objects.\n//\n// This allows code like:\n//      Scalar two(2);\n//      Scalar four = two * 2;\n//      Scalar eight = 2 * four;    // This would cause an error if the\n//                                  // operator* was implemented as a\n//                                  // member function.\n// SEE:\n//  Item 19 of \"Effective C++ Second Edition\" by Scott Meyers\n//  Differentiate among members functions, non-member functions, and\n//  friend functions\nconst Scalar operator+(const Scalar &lhs, const Scalar &rhs);\nconst Scalar operator-(Scalar lhs, Scalar rhs);\nconst Scalar operator/(Scalar lhs, Scalar rhs);\nconst Scalar operator*(Scalar lhs, Scalar rhs);\nconst Scalar operator&(Scalar lhs, Scalar rhs);\nconst Scalar operator|(Scalar lhs, Scalar rhs);\nconst Scalar operator%(Scalar lhs, Scalar rhs);\nconst Scalar operator^(Scalar lhs, Scalar rhs);\nconst Scalar operator<<(const Scalar &lhs, const Scalar &rhs);\nconst Scalar operator>>(const Scalar &lhs, const Scalar &rhs);\nbool operator==(Scalar lhs, Scalar rhs);\nbool operator!=(const Scalar &lhs, const Scalar &rhs);\nbool operator<(Scalar lhs, Scalar rhs);\nbool operator<=(const Scalar &lhs, const Scalar &rhs);\nbool operator>(const Scalar &lhs, const Scalar &rhs);\nbool operator>=(const Scalar &lhs, const Scalar &rhs);\n\nllvm::raw_ostream &operator<<(llvm::raw_ostream &os, const Scalar &scalar);\n\n} // namespace lldb_private\n\n#endif // LLDB_UTILITY_SCALAR_H\n"}, "39": {"id": 39, "path": "/home/vsts/work/1/llvm-project/lldb/include/lldb/Utility/StringLexer.h", "content": "//===-- StringLexer.h -------------------------------------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLDB_UTILITY_STRINGLEXER_H\n#define LLDB_UTILITY_STRINGLEXER_H\n\n#include <initializer_list>\n#include <string>\n#include <utility>\n\nnamespace lldb_private {\n\nclass StringLexer {\npublic:\n  typedef std::string::size_type Position;\n  typedef std::string::size_type Size;\n\n  typedef std::string::value_type Character;\n\n  StringLexer(std::string s);\n\n  // These APIs are not bounds-checked.  Use HasAtLeast() if you're not sure.\n  Character Peek();\n\n  bool NextIf(Character c);\n\n  std::pair<bool, Character> NextIf(std::initializer_list<Character> cs);\n\n  bool AdvanceIf(const std::string &token);\n\n  Character Next();\n\n  bool HasAtLeast(Size s);\n\n  std::string GetUnlexed();\n\n  // This will assert if there are less than s characters preceding the cursor.\n  void PutBack(Size s);\n\n  StringLexer &operator=(const StringLexer &rhs);\n\nprivate:\n  std::string m_data;\n  Position m_position;\n\n  void Consume();\n};\n\n} // namespace lldb_private\n\n#endif // LLDB_UTILITY_STRINGLEXER_H\n"}, "40": {"id": 40, "path": "/home/vsts/work/1/llvm-project/lldb/include/lldb/Utility/StructuredData.h", "content": "//===-- StructuredData.h ----------------------------------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLDB_UTILITY_STRUCTUREDDATA_H\n#define LLDB_UTILITY_STRUCTUREDDATA_H\n\n#include \"llvm/ADT/StringRef.h\"\n#include \"llvm/Support/JSON.h\"\n\n#include \"lldb/Utility/ConstString.h\"\n#include \"lldb/Utility/FileSpec.h\"\n#include \"lldb/Utility/Stream.h\"\n#include \"lldb/lldb-enumerations.h\"\n\n#include <cassert>\n#include <cstddef>\n#include <cstdint>\n#include <functional>\n#include <map>\n#include <memory>\n#include <string>\n#include <type_traits>\n#include <utility>\n#include <vector>\n\nnamespace lldb_private {\nclass Status;\n}\n\nnamespace lldb_private {\n\n/// \\class StructuredData StructuredData.h \"lldb/Utility/StructuredData.h\"\n/// A class which can hold structured data\n///\n/// The StructuredData class is designed to hold the data from a JSON or plist\n/// style file -- a serialized data structure with dictionaries (maps,\n/// hashes), arrays, and concrete values like integers, floating point\n/// numbers, strings, booleans.\n///\n/// StructuredData does not presuppose any knowledge of the schema for the\n/// data it is holding; it can parse JSON data, for instance, and other parts\n/// of lldb can iterate through the parsed data set to find keys and values\n/// that may be present.\n\nclass StructuredData {\npublic:\n  class Object;\n  class Array;\n  class Integer;\n  class Float;\n  class Boolean;\n  class String;\n  class Dictionary;\n  class Generic;\n\n  typedef std::shared_ptr<Object> ObjectSP;\n  typedef std::shared_ptr<Array> ArraySP;\n  typedef std::shared_ptr<Integer> IntegerSP;\n  typedef std::shared_ptr<Float> FloatSP;\n  typedef std::shared_ptr<Boolean> BooleanSP;\n  typedef std::shared_ptr<String> StringSP;\n  typedef std::shared_ptr<Dictionary> DictionarySP;\n  typedef std::shared_ptr<Generic> GenericSP;\n\n  class Object : public std::enable_shared_from_this<Object> {\n  public:\n    Object(lldb::StructuredDataType t = lldb::eStructuredDataTypeInvalid)\n        : m_type(t) {}\n\n    virtual ~Object() = default;\n\n    virtual bool IsValid() const { return true; }\n\n    virtual void Clear() { m_type = lldb::eStructuredDataTypeInvalid; }\n\n    lldb::StructuredDataType GetType() const { return m_type; }\n\n    void SetType(lldb::StructuredDataType t) { m_type = t; }\n\n    Array *GetAsArray() {\n      return ((m_type == lldb::eStructuredDataTypeArray)\n                  ? static_cast<Array *>(this)\n                  : nullptr);\n    }\n\n    Dictionary *GetAsDictionary() {\n      return ((m_type == lldb::eStructuredDataTypeDictionary)\n                  ? static_cast<Dictionary *>(this)\n                  : nullptr);\n    }\n\n    Integer *GetAsInteger() {\n      return ((m_type == lldb::eStructuredDataTypeInteger)\n                  ? static_cast<Integer *>(this)\n                  : nullptr);\n    }\n\n    uint64_t GetIntegerValue(uint64_t fail_value = 0) {\n      Integer *integer = GetAsInteger();\n      return ((integer != nullptr) ? integer->GetValue() : fail_value);\n    }\n\n    Float *GetAsFloat() {\n      return ((m_type == lldb::eStructuredDataTypeFloat)\n                  ? static_cast<Float *>(this)\n                  : nullptr);\n    }\n\n    double GetFloatValue(double fail_value = 0.0) {\n      Float *f = GetAsFloat();\n      return ((f != nullptr) ? f->GetValue() : fail_value);\n    }\n\n    Boolean *GetAsBoolean() {\n      return ((m_type == lldb::eStructuredDataTypeBoolean)\n                  ? static_cast<Boolean *>(this)\n                  : nullptr);\n    }\n\n    bool GetBooleanValue(bool fail_value = false) {\n      Boolean *b = GetAsBoolean();\n      return ((b != nullptr) ? b->GetValue() : fail_value);\n    }\n\n    String *GetAsString() {\n      return ((m_type == lldb::eStructuredDataTypeString)\n                  ? static_cast<String *>(this)\n                  : nullptr);\n    }\n\n    llvm::StringRef GetStringValue(const char *fail_value = nullptr) {\n      String *s = GetAsString();\n      if (s)\n        return s->GetValue();\n\n      return fail_value;\n    }\n\n    Generic *GetAsGeneric() {\n      return ((m_type == lldb::eStructuredDataTypeGeneric)\n                  ? static_cast<Generic *>(this)\n                  : nullptr);\n    }\n\n    ObjectSP GetObjectForDotSeparatedPath(llvm::StringRef path);\n\n    void DumpToStdout(bool pretty_print = true) const;\n\n    virtual void Serialize(llvm::json::OStream &s) const = 0;\n\n    void Dump(lldb_private::Stream &s, bool pretty_print = true) const {\n      llvm::json::OStream jso(s.AsRawOstream(), pretty_print ? 2 : 0);\n      Serialize(jso);\n    }\n\n  private:\n    lldb::StructuredDataType m_type;\n  };\n\n  class Array : public Object {\n  public:\n    Array() : Object(lldb::eStructuredDataTypeArray) {}\n\n    ~Array() override = default;\n\n    bool\n    ForEach(std::function<bool(Object *object)> const &foreach_callback) const {\n      for (const auto &object_sp : m_items) {\n        if (!foreach_callback(object_sp.get()))\n          return false;\n      }\n      return true;\n    }\n\n    size_t GetSize() const { return m_items.size(); }\n\n    ObjectSP operator[](size_t idx) {\n      if (idx < m_items.size())\n        return m_items[idx];\n      return ObjectSP();\n    }\n\n    ObjectSP GetItemAtIndex(size_t idx) const {\n      assert(idx < GetSize());\n      if (idx < m_items.size())\n        return m_items[idx];\n      return ObjectSP();\n    }\n\n    template <class IntType>\n    bool GetItemAtIndexAsInteger(size_t idx, IntType &result) const {\n      ObjectSP value_sp = GetItemAtIndex(idx);\n      if (value_sp.get()) {\n        if (auto int_value = value_sp->GetAsInteger()) {\n          result = static_cast<IntType>(int_value->GetValue());\n          return true;\n        }\n      }\n      return false;\n    }\n\n    template <class IntType>\n    bool GetItemAtIndexAsInteger(size_t idx, IntType &result,\n                                 IntType default_val) const {\n      bool success = GetItemAtIndexAsInteger(idx, result);\n      if (!success)\n        result = default_val;\n      return success;\n    }\n\n    bool GetItemAtIndexAsString(size_t idx, llvm::StringRef &result) const {\n      ObjectSP value_sp = GetItemAtIndex(idx);\n      if (value_sp.get()) {\n        if (auto string_value = value_sp->GetAsString()) {\n          result = string_value->GetValue();\n          return true;\n        }\n      }\n      return false;\n    }\n\n    bool GetItemAtIndexAsString(size_t idx, llvm::StringRef &result,\n                                llvm::StringRef default_val) const {\n      bool success = GetItemAtIndexAsString(idx, result);\n      if (!success)\n        result = default_val;\n      return success;\n    }\n\n    bool GetItemAtIndexAsString(size_t idx, ConstString &result) const {\n      ObjectSP value_sp = GetItemAtIndex(idx);\n      if (value_sp.get()) {\n        if (auto string_value = value_sp->GetAsString()) {\n          result = ConstString(string_value->GetValue());\n          return true;\n        }\n      }\n      return false;\n    }\n\n    bool GetItemAtIndexAsString(size_t idx, ConstString &result,\n                                const char *default_val) const {\n      bool success = GetItemAtIndexAsString(idx, result);\n      if (!success)\n        result.SetCString(default_val);\n      return success;\n    }\n\n    bool GetItemAtIndexAsDictionary(size_t idx, Dictionary *&result) const {\n      result = nullptr;\n      ObjectSP value_sp = GetItemAtIndex(idx);\n      if (value_sp.get()) {\n        result = value_sp->GetAsDictionary();\n        return (result != nullptr);\n      }\n      return false;\n    }\n\n    bool GetItemAtIndexAsArray(size_t idx, Array *&result) const {\n      result = nullptr;\n      ObjectSP value_sp = GetItemAtIndex(idx);\n      if (value_sp.get()) {\n        result = value_sp->GetAsArray();\n        return (result != nullptr);\n      }\n      return false;\n    }\n\n    void Push(const ObjectSP &item) { m_items.push_back(item); }\n\n    void AddItem(const ObjectSP &item) { m_items.push_back(item); }\n\n    void Serialize(llvm::json::OStream &s) const override;\n\n  protected:\n    typedef std::vector<ObjectSP> collection;\n    collection m_items;\n  };\n\n  class Integer : public Object {\n  public:\n    Integer(uint64_t i = 0)\n        : Object(lldb::eStructuredDataTypeInteger), m_value(i) {}\n\n    ~Integer() override = default;\n\n    void SetValue(uint64_t value) { m_value = value; }\n\n    uint64_t GetValue() { return m_value; }\n\n    void Serialize(llvm::json::OStream &s) const override;\n\n  protected:\n    uint64_t m_value;\n  };\n\n  class Float : public Object {\n  public:\n    Float(double d = 0.0)\n        : Object(lldb::eStructuredDataTypeFloat), m_value(d) {}\n\n    ~Float() override = default;\n\n    void SetValue(double value) { m_value = value; }\n\n    double GetValue() { return m_value; }\n\n    void Serialize(llvm::json::OStream &s) const override;\n\n  protected:\n    double m_value;\n  };\n\n  class Boolean : public Object {\n  public:\n    Boolean(bool b = false)\n        : Object(lldb::eStructuredDataTypeBoolean), m_value(b) {}\n\n    ~Boolean() override = default;\n\n    void SetValue(bool value) { m_value = value; }\n\n    bool GetValue() { return m_value; }\n\n    void Serialize(llvm::json::OStream &s) const override;\n\n  protected:\n    bool m_value;\n  };\n\n  class String : public Object {\n  public:\n    String() : Object(lldb::eStructuredDataTypeString) {}\n    explicit String(llvm::StringRef S)\n        : Object(lldb::eStructuredDataTypeString), m_value(S) {}\n\n    void SetValue(llvm::StringRef S) { m_value = std::string(S); }\n\n    llvm::StringRef GetValue() { return m_value; }\n\n    void Serialize(llvm::json::OStream &s) const override;\n\n  protected:\n    std::string m_value;\n  };\n\n  class Dictionary : public Object {\n  public:\n    Dictionary() : Object(lldb::eStructuredDataTypeDictionary), m_dict() {}\n\n    ~Dictionary() override = default;\n\n    size_t GetSize() const { return m_dict.size(); }\n\n    void ForEach(std::function<bool(ConstString key, Object *object)> const\n                     &callback) const {\n      for (const auto &pair : m_dict) {\n        if (!callback(pair.first, pair.second.get()))\n          break;\n      }\n    }\n\n    ObjectSP GetKeys() const {\n      auto object_sp = std::make_shared<Array>();\n      collection::const_iterator iter;\n      for (iter = m_dict.begin(); iter != m_dict.end(); ++iter) {\n        auto key_object_sp = std::make_shared<String>();\n        key_object_sp->SetValue(iter->first.AsCString());\n        object_sp->Push(key_object_sp);\n      }\n      return object_sp;\n    }\n\n    ObjectSP GetValueForKey(llvm::StringRef key) const {\n      ObjectSP value_sp;\n      if (!key.empty()) {\n        ConstString key_cs(key);\n        collection::const_iterator iter = m_dict.find(key_cs);\n        if (iter != m_dict.end())\n          value_sp = iter->second;\n      }\n      return value_sp;\n    }\n\n    bool GetValueForKeyAsBoolean(llvm::StringRef key, bool &result) const {\n      bool success = false;\n      ObjectSP value_sp = GetValueForKey(key);\n      if (value_sp.get()) {\n        Boolean *result_ptr = value_sp->GetAsBoolean();\n        if (result_ptr) {\n          result = result_ptr->GetValue();\n          success = true;\n        }\n      }\n      return success;\n    }\n    template <class IntType>\n    bool GetValueForKeyAsInteger(llvm::StringRef key, IntType &result) const {\n      ObjectSP value_sp = GetValueForKey(key);\n      if (value_sp) {\n        if (auto int_value = value_sp->GetAsInteger()) {\n          result = static_cast<IntType>(int_value->GetValue());\n          return true;\n        }\n      }\n      return false;\n    }\n\n    template <class IntType>\n    bool GetValueForKeyAsInteger(llvm::StringRef key, IntType &result,\n                                 IntType default_val) const {\n      bool success = GetValueForKeyAsInteger<IntType>(key, result);\n      if (!success)\n        result = default_val;\n      return success;\n    }\n\n    bool GetValueForKeyAsString(llvm::StringRef key,\n                                llvm::StringRef &result) const {\n      ObjectSP value_sp = GetValueForKey(key);\n      if (value_sp.get()) {\n        if (auto string_value = value_sp->GetAsString()) {\n          result = string_value->GetValue();\n          return true;\n        }\n      }\n      return false;\n    }\n\n    bool GetValueForKeyAsString(llvm::StringRef key, llvm::StringRef &result,\n                                const char *default_val) const {\n      bool success = GetValueForKeyAsString(key, result);\n      if (!success) {\n        if (default_val)\n          result = default_val;\n        else\n          result = llvm::StringRef();\n      }\n      return success;\n    }\n\n    bool GetValueForKeyAsString(llvm::StringRef key,\n                                ConstString &result) const {\n      ObjectSP value_sp = GetValueForKey(key);\n      if (value_sp.get()) {\n        if (auto string_value = value_sp->GetAsString()) {\n          result = ConstString(string_value->GetValue());\n          return true;\n        }\n      }\n      return false;\n    }\n\n    bool GetValueForKeyAsString(llvm::StringRef key, ConstString &result,\n                                const char *default_val) const {\n      bool success = GetValueForKeyAsString(key, result);\n      if (!success)\n        result.SetCString(default_val);\n      return success;\n    }\n\n    bool GetValueForKeyAsDictionary(llvm::StringRef key,\n                                    Dictionary *&result) const {\n      result = nullptr;\n      ObjectSP value_sp = GetValueForKey(key);\n      if (value_sp.get()) {\n        result = value_sp->GetAsDictionary();\n        return (result != nullptr);\n      }\n      return false;\n    }\n\n    bool GetValueForKeyAsArray(llvm::StringRef key, Array *&result) const {\n      result = nullptr;\n      ObjectSP value_sp = GetValueForKey(key);\n      if (value_sp.get()) {\n        result = value_sp->GetAsArray();\n        return (result != nullptr);\n      }\n      return false;\n    }\n\n    bool HasKey(llvm::StringRef key) const {\n      ConstString key_cs(key);\n      collection::const_iterator search = m_dict.find(key_cs);\n      return search != m_dict.end();\n    }\n\n    void AddItem(llvm::StringRef key, ObjectSP value_sp) {\n      ConstString key_cs(key);\n      m_dict[key_cs] = std::move(value_sp);\n    }\n\n    void AddIntegerItem(llvm::StringRef key, uint64_t value) {\n      AddItem(key, std::make_shared<Integer>(value));\n    }\n\n    void AddFloatItem(llvm::StringRef key, double value) {\n      AddItem(key, std::make_shared<Float>(value));\n    }\n\n    void AddStringItem(llvm::StringRef key, llvm::StringRef value) {\n      AddItem(key, std::make_shared<String>(std::move(value)));\n    }\n\n    void AddBooleanItem(llvm::StringRef key, bool value) {\n      AddItem(key, std::make_shared<Boolean>(value));\n    }\n\n    void Serialize(llvm::json::OStream &s) const override;\n\n  protected:\n    typedef std::map<ConstString, ObjectSP> collection;\n    collection m_dict;\n  };\n\n  class Null : public Object {\n  public:\n    Null() : Object(lldb::eStructuredDataTypeNull) {}\n\n    ~Null() override = default;\n\n    bool IsValid() const override { return false; }\n\n    void Serialize(llvm::json::OStream &s) const override;\n  };\n\n  class Generic : public Object {\n  public:\n    explicit Generic(void *object = nullptr)\n        : Object(lldb::eStructuredDataTypeGeneric), m_object(object) {}\n\n    void SetValue(void *value) { m_object = value; }\n\n    void *GetValue() const { return m_object; }\n\n    bool IsValid() const override { return m_object != nullptr; }\n\n    void Serialize(llvm::json::OStream &s) const override;\n\n  private:\n    void *m_object;\n  };\n\n  static ObjectSP ParseJSON(const std::string &json_text);\n  static ObjectSP ParseJSONFromFile(const FileSpec &file, Status &error);\n};\n\n} // namespace lldb_private\n\n#endif // LLDB_UTILITY_STRUCTUREDDATA_H\n"}, "41": {"id": 41, "path": "/home/vsts/work/1/llvm-project/lldb/include/lldb/Utility/Timeout.h", "content": "//===-- Timeout.h -----------------------------------------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLDB_UTILITY_TIMEOUT_H\n#define LLDB_UTILITY_TIMEOUT_H\n\n#include \"llvm/ADT/Optional.h\"\n#include \"llvm/Support/Chrono.h\"\n#include \"llvm/Support/FormatProviders.h\"\n\nnamespace lldb_private {\n\n// A general purpose class for representing timeouts for various APIs. It's\n// basically an llvm::Optional<std::chrono::duration<int64_t, Ratio>>, but we\n// customize it a bit to enable the standard chrono implicit conversions (e.g.\n// from Timeout<std::milli> to Timeout<std::micro>.\n//\n// The intended meaning of the values is:\n// - llvm::None - no timeout, the call should wait forever - 0 - poll, only\n// complete the call if it will not block - >0 - wait for a given number of\n// units for the result\ntemplate <typename Ratio>\nclass Timeout : public llvm::Optional<std::chrono::duration<int64_t, Ratio>> {\nprivate:\n  template <typename Ratio2> using Dur = std::chrono::duration<int64_t, Ratio2>;\n  template <typename Rep2, typename Ratio2>\n  using EnableIf = std::enable_if<\n      std::is_convertible<std::chrono::duration<Rep2, Ratio2>,\n                          std::chrono::duration<int64_t, Ratio>>::value>;\n\n  using Base = llvm::Optional<Dur<Ratio>>;\n\npublic:\n  Timeout(llvm::NoneType none) : Base(none) {}\n  Timeout(const Timeout &other) = default;\n\n  template <typename Ratio2,\n            typename = typename EnableIf<int64_t, Ratio2>::type>\n  Timeout(const Timeout<Ratio2> &other)\n      : Base(other ? Base(Dur<Ratio>(*other)) : llvm::None) {}\n\n  template <typename Rep2, typename Ratio2,\n            typename = typename EnableIf<Rep2, Ratio2>::type>\n  Timeout(const std::chrono::duration<Rep2, Ratio2> &other)\n      : Base(Dur<Ratio>(other)) {}\n};\n\n} // namespace lldb_private\n\nnamespace llvm {\ntemplate<typename Ratio>\nstruct format_provider<lldb_private::Timeout<Ratio>, void> {\n  static void format(const lldb_private::Timeout<Ratio> &timeout,\n                     raw_ostream &OS, StringRef Options) {\n    typedef typename lldb_private::Timeout<Ratio>::value_type Dur;\n\n    if (!timeout)\n      OS << \"<infinite>\";\n    else\n      format_provider<Dur>::format(*timeout, OS, Options);\n  }\n};\n}\n\n#endif // LLDB_UTILITY_TIMEOUT_H\n"}, "42": {"id": 42, "path": "/home/vsts/work/1/llvm-project/lldb/include/lldb/Utility/UUID.h", "content": "//===-- UUID.h --------------------------------------------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLDB_UTILITY_UUID_H\n#define LLDB_UTILITY_UUID_H\n\n#include \"llvm/ADT/ArrayRef.h\"\n#include \"llvm/ADT/StringRef.h\"\n#include \"llvm/Support/Endian.h\"\n#include <stddef.h>\n#include <stdint.h>\n#include <string>\n\nnamespace lldb_private {\n\n  class Stream;\n\nclass UUID {\npublic:\n  UUID() = default;\n\n  // Reference:\n  // https://crashpad.chromium.org/doxygen/structcrashpad_1_1CodeViewRecordPDB70.html\n  struct CvRecordPdb70 {\n    struct {\n      llvm::support::ulittle32_t Data1;\n      llvm::support::ulittle16_t Data2;\n      llvm::support::ulittle16_t Data3;\n      uint8_t Data4[8];\n    } Uuid;\n    llvm::support::ulittle32_t Age;\n    // char PDBFileName[];\n  };\n\n  /// Create a UUID from CvRecordPdb70.\n  static UUID fromCvRecord(CvRecordPdb70 debug_info);\n\n  /// Creates a UUID from the data pointed to by the bytes argument. No special\n  /// significance is attached to any of the values.\n  static UUID fromData(const void *bytes, uint32_t num_bytes) {\n    if (bytes)\n      return fromData({reinterpret_cast<const uint8_t *>(bytes), num_bytes});\n    return UUID();\n  }\n\n  /// Creates a uuid from the data pointed to by the bytes argument. No special\n  /// significance is attached to any of the values.\n  static UUID fromData(llvm::ArrayRef<uint8_t> bytes) { return UUID(bytes); }\n\n  /// Creates a UUID from the data pointed to by the bytes argument. Data\n  /// consisting purely of zero bytes is treated as an invalid UUID.\n  static UUID fromOptionalData(const void *bytes, uint32_t num_bytes) {\n    if (bytes)\n      return fromOptionalData(\n          {reinterpret_cast<const uint8_t *>(bytes), num_bytes});\n    return UUID();\n  }\n\n  /// Creates a UUID from the data pointed to by the bytes argument. Data\n  /// consisting purely of zero bytes is treated as an invalid UUID.\n  static UUID fromOptionalData(llvm::ArrayRef<uint8_t> bytes) {\n    if (llvm::all_of(bytes, [](uint8_t b) { return b == 0; }))\n      return UUID();\n    return UUID(bytes);\n  }\n\n  void Clear() { m_bytes.clear(); }\n\n  void Dump(Stream *s) const;\n\n  llvm::ArrayRef<uint8_t> GetBytes() const { return m_bytes; }\n\n  explicit operator bool() const { return IsValid(); }\n  bool IsValid() const { return !m_bytes.empty(); }\n\n  std::string GetAsString(llvm::StringRef separator = \"-\") const;\n\n  bool SetFromStringRef(llvm::StringRef str);\n\n  // Same as SetFromStringRef, but if the resultant UUID is all 0 bytes, set the\n  // UUID to invalid.\n  bool SetFromOptionalStringRef(llvm::StringRef str);\n\n  /// Decode as many UUID bytes as possible from the C string \\a cstr.\n  ///\n  /// \\param[in] str\n  ///     An llvm::StringRef that points at a UUID string value (no leading\n  ///     spaces). The string must contain only hex characters and optionally\n  ///     can contain the '-' sepearators.\n  ///\n  /// \\param[in] uuid_bytes\n  ///     A buffer of bytes that will contain a full or partially decoded UUID.\n  ///\n  /// \\return\n  ///     The original string, with all decoded bytes removed.\n  static llvm::StringRef\n  DecodeUUIDBytesFromString(llvm::StringRef str,\n                            llvm::SmallVectorImpl<uint8_t> &uuid_bytes);\n\nprivate:\n  UUID(llvm::ArrayRef<uint8_t> bytes) : m_bytes(bytes.begin(), bytes.end()) {}\n\n  // GNU ld generates 20-byte build-ids. Size chosen to avoid heap allocations\n  // for this case.\n  llvm::SmallVector<uint8_t, 20> m_bytes;\n\n  friend bool operator==(const UUID &LHS, const UUID &RHS) {\n    return LHS.m_bytes == RHS.m_bytes;\n  }\n  friend bool operator!=(const UUID &LHS, const UUID &RHS) {\n    return !(LHS == RHS);\n  }\n  friend bool operator<(const UUID &LHS, const UUID &RHS) {\n    return LHS.m_bytes < RHS.m_bytes;\n  }\n  friend bool operator<=(const UUID &LHS, const UUID &RHS) {\n    return !(RHS < LHS);\n  }\n  friend bool operator>(const UUID &LHS, const UUID &RHS) { return RHS < LHS; }\n  friend bool operator>=(const UUID &LHS, const UUID &RHS) {\n    return !(LHS < RHS);\n  }\n};\n} // namespace lldb_private\n\n#endif // LLDB_UTILITY_UUID_H\n"}, "43": {"id": 43, "path": "/home/vsts/work/1/llvm-project/lldb/include/lldb/Utility/UnimplementedError.h", "content": "//===-- UnimplementedError.h ------------------------------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLDB_UTILITY_UNIMPLEMENTEDERROR_H\n#define LLDB_UTILITY_UNIMPLEMENTEDERROR_H\n\n#include \"llvm/Support/Errc.h\"\n#include \"llvm/Support/Error.h\"\n\nnamespace lldb_private {\nclass UnimplementedError : public llvm::ErrorInfo<UnimplementedError> {\npublic:\n  static char ID;\n\n  void log(llvm::raw_ostream &OS) const override { OS << \"Not implemented\"; }\n\n  std::error_code convertToErrorCode() const override {\n    return llvm::errc::not_supported;\n  };\n};\n} // namespace lldb_private\n\n#endif // LLDB_UTILITY_UNIMPLEMENTEDERROR_H\n"}, "44": {"id": 44, "path": "/home/vsts/work/1/llvm-project/lldb/include/lldb/lldb-private-types.h", "content": "//===-- lldb-private-types.h ------------------------------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLDB_LLDB_PRIVATE_TYPES_H\n#define LLDB_LLDB_PRIVATE_TYPES_H\n\n#if defined(__cplusplus)\n\n#include \"lldb/lldb-private.h\"\n\n#include \"llvm/ADT/ArrayRef.h\"\n\nnamespace llvm {\nnamespace sys {\nclass DynamicLibrary;\n}\n}\n\nnamespace lldb_private {\nclass Platform;\nclass ExecutionContext;\n\ntypedef llvm::sys::DynamicLibrary (*LoadPluginCallbackType)(\n    const lldb::DebuggerSP &debugger_sp, const FileSpec &spec, Status &error);\n\n/// Every register is described in detail including its name, alternate name\n/// (optional), encoding, size in bytes and the default display format.\nstruct RegisterInfo {\n  /// Name of this register, can't be NULL.\n  const char *name;\n  /// Alternate name of this register, can be NULL.\n  const char *alt_name;\n  /// Size in bytes of the register.\n  uint32_t byte_size;\n  /// The byte offset in the register context data where this register's\n  /// value is found.\n  /// This is optional, and can be 0 if a particular RegisterContext does not\n  /// need to address its registers by byte offset.\n  uint32_t byte_offset;\n  /// Encoding of the register bits.\n  lldb::Encoding encoding;\n  /// Default display format.\n  lldb::Format format;\n  /// Holds all of the various register numbers for all register kinds.\n  uint32_t kinds[lldb::kNumRegisterKinds]; //\n  /// List of registers (terminated with LLDB_INVALID_REGNUM). If this value is\n  /// not null, all registers in this list will be read first, at which point\n  /// the value for this register will be valid. For example, the value list\n  /// for ah would be eax (x86) or rax (x64).\n  uint32_t *value_regs; //\n  /// List of registers (terminated with LLDB_INVALID_REGNUM). If this value is\n  /// not null, all registers in this list will be invalidated when the value of\n  /// this register changes. For example, the invalidate list for eax would be\n  /// rax ax, ah, and al.\n  uint32_t *invalidate_regs;\n  /// A DWARF expression that when evaluated gives the byte size of this\n  /// register.\n  const uint8_t *dynamic_size_dwarf_expr_bytes;\n  /// The length of the DWARF expression in bytes in the\n  /// dynamic_size_dwarf_expr_bytes member.\n  size_t dynamic_size_dwarf_len;\n\n  llvm::ArrayRef<uint8_t> data(const uint8_t *context_base) const {\n    return llvm::ArrayRef<uint8_t>(context_base + byte_offset, byte_size);\n  }\n\n  llvm::MutableArrayRef<uint8_t> mutable_data(uint8_t *context_base) const {\n    return llvm::MutableArrayRef<uint8_t>(context_base + byte_offset,\n                                          byte_size);\n  }\n};\n\n/// Registers are grouped into register sets\nstruct RegisterSet {\n  /// Name of this register set.\n  const char *name;\n  /// A short name for this register set.\n  const char *short_name;\n  /// The number of registers in REGISTERS array below.\n  size_t num_registers;\n  /// An array of register indices in this set. The values in this array are\n  /// *indices* (not register numbers) into a particular RegisterContext's\n  /// register array.  For example, if eax is defined at index 4 for a\n  /// particular RegisterContext, eax would be included in this RegisterSet by\n  /// adding the value 4.  Not by adding the value lldb_eax_i386.\n  const uint32_t *registers;\n};\n\nstruct OptionEnumValueElement {\n  int64_t value;\n  const char *string_value;\n  const char *usage;\n};\n\nusing OptionEnumValues = llvm::ArrayRef<OptionEnumValueElement>;\n\nstruct OptionValidator {\n  virtual ~OptionValidator() {}\n  virtual bool IsValid(Platform &platform,\n                       const ExecutionContext &target) const = 0;\n  virtual const char *ShortConditionString() const = 0;\n  virtual const char *LongConditionString() const = 0;\n};\n\ntypedef struct type128 { uint64_t x[2]; } type128;\ntypedef struct type256 { uint64_t x[4]; } type256;\n\n} // namespace lldb_private\n\n#endif // #if defined(__cplusplus)\n\n#endif // LLDB_LLDB_PRIVATE_TYPES_H\n"}, "45": {"id": 45, "path": "/home/vsts/work/1/llvm-project/lldb/source/Plugins/Language/CPlusPlus/LibCxxVariant.cpp", "content": "//===-- LibCxxVariant.cpp -------------------------------------------------===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#include \"LibCxxVariant.h\"\n#include \"lldb/DataFormatters/FormattersHelpers.h\"\n\n#include \"llvm/ADT/Optional.h\"\n#include \"llvm/ADT/ScopeExit.h\"\n\nusing namespace lldb;\nusing namespace lldb_private;\n\n// libc++ variant implementation contains two members that we care about both\n// are contained in the __impl member.\n// - __index which tells us which of the variadic template types is the active\n//   type for the variant\n// - __data is a variadic union which recursively contains itself as member\n//   which refers to the tailing variadic types.\n//   - __head which refers to the leading non pack type\n//     - __value refers to the actual value contained\n//   - __tail which refers to the remaining pack types\n//\n// e.g. given std::variant<int,double,char> v1\n//\n// (lldb) frame var -R v1.__impl.__data\n//(... __union<... 0, int, double, char>) v1.__impl.__data = {\n// ...\n//  __head = {\n//    __value = ...\n//  }\n//  __tail = {\n//  ...\n//    __head = {\n//      __value = ...\n//    }\n//    __tail = {\n//    ...\n//      __head = {\n//        __value = ...\n//  ...\n//\n// So given\n// - __index equal to 0 the active value is contained in\n//\n//     __data.__head.__value\n//\n// - __index equal to 1 the active value is contained in\n//\n//     __data.__tail.__head.__value\n//\n// - __index equal to 2 the active value is contained in\n//\n//      __data.__tail.__tail.__head.__value\n//\n\nnamespace {\n// libc++ std::variant index could have one of three states\n// 1) Valid, we can obtain it and its not variant_npos\n// 2) Invalid, we can't obtain it or it is not a type we expect\n// 3) NPos, its value is variant_npos which means the variant has no value\nenum class LibcxxVariantIndexValidity { Valid, Invalid, NPos };\n\nLibcxxVariantIndexValidity\nLibcxxVariantGetIndexValidity(ValueObjectSP &impl_sp) {\n  ValueObjectSP index_sp(\n      impl_sp->GetChildMemberWithName(ConstString(\"__index\"), true));\n\n  if (!index_sp)\n    return LibcxxVariantIndexValidity::Invalid;\n\n  int64_t index_value = index_sp->GetValueAsSigned(0);\n\n  if (index_value == -1)\n    return LibcxxVariantIndexValidity::NPos;\n\n  return LibcxxVariantIndexValidity::Valid;\n}\n\nllvm::Optional<uint64_t> LibcxxVariantIndexValue(ValueObjectSP &impl_sp) {\n  ValueObjectSP index_sp(\n      impl_sp->GetChildMemberWithName(ConstString(\"__index\"), true));\n\n  if (!index_sp)\n    return {};\n\n  return {index_sp->GetValueAsUnsigned(0)};\n}\n\nValueObjectSP LibcxxVariantGetNthHead(ValueObjectSP &impl_sp, uint64_t index) {\n  ValueObjectSP data_sp(\n      impl_sp->GetChildMemberWithName(ConstString(\"__data\"), true));\n\n  if (!data_sp)\n    return ValueObjectSP{};\n\n  ValueObjectSP current_level = data_sp;\n  for (uint64_t n = index; n != 0; --n) {\n    ValueObjectSP tail_sp(\n        current_level->GetChildMemberWithName(ConstString(\"__tail\"), true));\n\n    if (!tail_sp)\n      return ValueObjectSP{};\n\n    current_level = tail_sp;\n  }\n\n  return current_level->GetChildMemberWithName(ConstString(\"__head\"), true);\n}\n} // namespace\n\nnamespace lldb_private {\nnamespace formatters {\nbool LibcxxVariantSummaryProvider(ValueObject &valobj, Stream &stream,\n                                  const TypeSummaryOptions &options) {\n  ValueObjectSP valobj_sp(valobj.GetNonSyntheticValue());\n  if (!valobj_sp)\n    return false;\n\n  ValueObjectSP impl_sp(\n      valobj_sp->GetChildMemberWithName(ConstString(\"__impl\"), true));\n\n  if (!impl_sp)\n    return false;\n\n  LibcxxVariantIndexValidity validity = LibcxxVariantGetIndexValidity(impl_sp);\n\n  if (validity == LibcxxVariantIndexValidity::Invalid)\n    return false;\n\n  if (validity == LibcxxVariantIndexValidity::NPos) {\n    stream.Printf(\" No Value\");\n    return true;\n  }\n\n  auto optional_index_value = LibcxxVariantIndexValue(impl_sp);\n\n  if (!optional_index_value)\n    return false;\n\n  uint64_t index_value = *optional_index_value;\n\n  ValueObjectSP nth_head = LibcxxVariantGetNthHead(impl_sp, index_value);\n\n  if (!nth_head)\n    return false;\n\n  CompilerType head_type = nth_head->GetCompilerType();\n\n  if (!head_type)\n    return false;\n\n  CompilerType template_type = head_type.GetTypeTemplateArgument(1);\n\n  if (!template_type)\n    return false;\n\n  stream << \" Active Type = \" << template_type.GetDisplayTypeName() << \" \";\n\n  return true;\n}\n} // namespace formatters\n} // namespace lldb_private\n\nnamespace {\nclass VariantFrontEnd : public SyntheticChildrenFrontEnd {\npublic:\n  VariantFrontEnd(ValueObject &valobj) : SyntheticChildrenFrontEnd(valobj) {\n    Update();\n  }\n\n  size_t GetIndexOfChildWithName(ConstString name) override {\n    return formatters::ExtractIndexFromString(name.GetCString());\n  }\n\n  bool MightHaveChildren() override { return true; }\n  bool Update() override;\n  size_t CalculateNumChildren() override { return m_size; }\n  ValueObjectSP GetChildAtIndex(size_t idx) override;\n\nprivate:\n  size_t m_size = 0;\n};\n} // namespace\n\nbool VariantFrontEnd::Update() {\n  m_size = 0;\n  ValueObjectSP impl_sp(\n      m_backend.GetChildMemberWithName(ConstString(\"__impl\"), true));\n  if (!impl_sp)\n    return false;\n\n  LibcxxVariantIndexValidity validity = LibcxxVariantGetIndexValidity(impl_sp);\n\n  if (validity == LibcxxVariantIndexValidity::Invalid)\n    return false;\n\n  if (validity == LibcxxVariantIndexValidity::NPos)\n    return true;\n\n  m_size = 1;\n\n  return false;\n}\n\nValueObjectSP VariantFrontEnd::GetChildAtIndex(size_t idx) {\n  if (idx >= m_size)\n    return ValueObjectSP();\n\n  ValueObjectSP impl_sp(\n      m_backend.GetChildMemberWithName(ConstString(\"__impl\"), true));\n\n  auto optional_index_value = LibcxxVariantIndexValue(impl_sp);\n\n  if (!optional_index_value)\n    return ValueObjectSP();\n\n  uint64_t index_value = *optional_index_value;\n\n  ValueObjectSP nth_head = LibcxxVariantGetNthHead(impl_sp, index_value);\n\n  if (!nth_head)\n    return ValueObjectSP();\n\n  CompilerType head_type = nth_head->GetCompilerType();\n\n  if (!head_type)\n    return ValueObjectSP();\n\n  CompilerType template_type = head_type.GetTypeTemplateArgument(1);\n\n  if (!template_type)\n    return ValueObjectSP();\n\n  ValueObjectSP head_value(\n      nth_head->GetChildMemberWithName(ConstString(\"__value\"), true));\n\n  if (!head_value)\n    return ValueObjectSP();\n\n  return head_value->Clone(ConstString(\"Value\"));\n}\n\nSyntheticChildrenFrontEnd *\nformatters::LibcxxVariantFrontEndCreator(CXXSyntheticChildren *,\n                                         lldb::ValueObjectSP valobj_sp) {\n  if (valobj_sp)\n    return new VariantFrontEnd(*valobj_sp);\n  return nullptr;\n}\n"}, "46": {"id": 46, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/APFloat.h", "content": "//===- llvm/ADT/APFloat.h - Arbitrary Precision Floating Point ---*- C++ -*-==//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n///\n/// \\file\n/// \\brief\n/// This file declares a class to represent arbitrary precision floating point\n/// values and provide a variety of arithmetic operations on them.\n///\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_ADT_APFLOAT_H\n#define LLVM_ADT_APFLOAT_H\n\n#include \"llvm/ADT/APInt.h\"\n#include \"llvm/ADT/ArrayRef.h\"\n#include \"llvm/ADT/FloatingPointMode.h\"\n#include \"llvm/Support/ErrorHandling.h\"\n#include <memory>\n\n#define APFLOAT_DISPATCH_ON_SEMANTICS(METHOD_CALL)                             \\\n  do {                                                                         \\\n    if (usesLayout<IEEEFloat>(getSemantics()))                                 \\\n      return U.IEEE.METHOD_CALL;                                               \\\n    if (usesLayout<DoubleAPFloat>(getSemantics()))                             \\\n      return U.Double.METHOD_CALL;                                             \\\n    llvm_unreachable(\"Unexpected semantics\");                                  \\\n  } while (false)\n\nnamespace llvm {\n\nstruct fltSemantics;\nclass APSInt;\nclass StringRef;\nclass APFloat;\nclass raw_ostream;\n\ntemplate <typename T> class Expected;\ntemplate <typename T> class SmallVectorImpl;\n\n/// Enum that represents what fraction of the LSB truncated bits of an fp number\n/// represent.\n///\n/// This essentially combines the roles of guard and sticky bits.\nenum lostFraction { // Example of truncated bits:\n  lfExactlyZero,    // 000000\n  lfLessThanHalf,   // 0xxxxx  x's not all zero\n  lfExactlyHalf,    // 100000\n  lfMoreThanHalf    // 1xxxxx  x's not all zero\n};\n\n/// A self-contained host- and target-independent arbitrary-precision\n/// floating-point software implementation.\n///\n/// APFloat uses bignum integer arithmetic as provided by static functions in\n/// the APInt class.  The library will work with bignum integers whose parts are\n/// any unsigned type at least 16 bits wide, but 64 bits is recommended.\n///\n/// Written for clarity rather than speed, in particular with a view to use in\n/// the front-end of a cross compiler so that target arithmetic can be correctly\n/// performed on the host.  Performance should nonetheless be reasonable,\n/// particularly for its intended use.  It may be useful as a base\n/// implementation for a run-time library during development of a faster\n/// target-specific one.\n///\n/// All 5 rounding modes in the IEEE-754R draft are handled correctly for all\n/// implemented operations.  Currently implemented operations are add, subtract,\n/// multiply, divide, fused-multiply-add, conversion-to-float,\n/// conversion-to-integer and conversion-from-integer.  New rounding modes\n/// (e.g. away from zero) can be added with three or four lines of code.\n///\n/// Four formats are built-in: IEEE single precision, double precision,\n/// quadruple precision, and x87 80-bit extended double (when operating with\n/// full extended precision).  Adding a new format that obeys IEEE semantics\n/// only requires adding two lines of code: a declaration and definition of the\n/// format.\n///\n/// All operations return the status of that operation as an exception bit-mask,\n/// so multiple operations can be done consecutively with their results or-ed\n/// together.  The returned status can be useful for compiler diagnostics; e.g.,\n/// inexact, underflow and overflow can be easily diagnosed on constant folding,\n/// and compiler optimizers can determine what exceptions would be raised by\n/// folding operations and optimize, or perhaps not optimize, accordingly.\n///\n/// At present, underflow tininess is detected after rounding; it should be\n/// straight forward to add support for the before-rounding case too.\n///\n/// The library reads hexadecimal floating point numbers as per C99, and\n/// correctly rounds if necessary according to the specified rounding mode.\n/// Syntax is required to have been validated by the caller.  It also converts\n/// floating point numbers to hexadecimal text as per the C99 %a and %A\n/// conversions.  The output precision (or alternatively the natural minimal\n/// precision) can be specified; if the requested precision is less than the\n/// natural precision the output is correctly rounded for the specified rounding\n/// mode.\n///\n/// It also reads decimal floating point numbers and correctly rounds according\n/// to the specified rounding mode.\n///\n/// Conversion to decimal text is not currently implemented.\n///\n/// Non-zero finite numbers are represented internally as a sign bit, a 16-bit\n/// signed exponent, and the significand as an array of integer parts.  After\n/// normalization of a number of precision P the exponent is within the range of\n/// the format, and if the number is not denormal the P-th bit of the\n/// significand is set as an explicit integer bit.  For denormals the most\n/// significant bit is shifted right so that the exponent is maintained at the\n/// format's minimum, so that the smallest denormal has just the least\n/// significant bit of the significand set.  The sign of zeroes and infinities\n/// is significant; the exponent and significand of such numbers is not stored,\n/// but has a known implicit (deterministic) value: 0 for the significands, 0\n/// for zero exponent, all 1 bits for infinity exponent.  For NaNs the sign and\n/// significand are deterministic, although not really meaningful, and preserved\n/// in non-conversion operations.  The exponent is implicitly all 1 bits.\n///\n/// APFloat does not provide any exception handling beyond default exception\n/// handling. We represent Signaling NaNs via IEEE-754R 2008 6.2.1 should clause\n/// by encoding Signaling NaNs with the first bit of its trailing significand as\n/// 0.\n///\n/// TODO\n/// ====\n///\n/// Some features that may or may not be worth adding:\n///\n/// Binary to decimal conversion (hard).\n///\n/// Optional ability to detect underflow tininess before rounding.\n///\n/// New formats: x87 in single and double precision mode (IEEE apart from\n/// extended exponent range) (hard).\n///\n/// New operations: sqrt, IEEE remainder, C90 fmod, nexttoward.\n///\n\n// This is the common type definitions shared by APFloat and its internal\n// implementation classes. This struct should not define any non-static data\n// members.\nstruct APFloatBase {\n  typedef APInt::WordType integerPart;\n  static constexpr unsigned integerPartWidth = APInt::APINT_BITS_PER_WORD;\n\n  /// A signed type to represent a floating point numbers unbiased exponent.\n  typedef int32_t ExponentType;\n\n  /// \\name Floating Point Semantics.\n  /// @{\n  enum Semantics {\n    S_IEEEhalf,\n    S_BFloat,\n    S_IEEEsingle,\n    S_IEEEdouble,\n    S_x87DoubleExtended,\n    S_IEEEquad,\n    S_PPCDoubleDouble\n  };\n\n  static const llvm::fltSemantics &EnumToSemantics(Semantics S);\n  static Semantics SemanticsToEnum(const llvm::fltSemantics &Sem);\n\n  static const fltSemantics &IEEEhalf() LLVM_READNONE;\n  static const fltSemantics &BFloat() LLVM_READNONE;\n  static const fltSemantics &IEEEsingle() LLVM_READNONE;\n  static const fltSemantics &IEEEdouble() LLVM_READNONE;\n  static const fltSemantics &IEEEquad() LLVM_READNONE;\n  static const fltSemantics &PPCDoubleDouble() LLVM_READNONE;\n  static const fltSemantics &x87DoubleExtended() LLVM_READNONE;\n\n  /// A Pseudo fltsemantic used to construct APFloats that cannot conflict with\n  /// anything real.\n  static const fltSemantics &Bogus() LLVM_READNONE;\n\n  /// @}\n\n  /// IEEE-754R 5.11: Floating Point Comparison Relations.\n  enum cmpResult {\n    cmpLessThan,\n    cmpEqual,\n    cmpGreaterThan,\n    cmpUnordered\n  };\n\n  /// IEEE-754R 4.3: Rounding-direction attributes.\n  using roundingMode = llvm::RoundingMode;\n\n  static constexpr roundingMode rmNearestTiesToEven =\n                                                RoundingMode::NearestTiesToEven;\n  static constexpr roundingMode rmTowardPositive = RoundingMode::TowardPositive;\n  static constexpr roundingMode rmTowardNegative = RoundingMode::TowardNegative;\n  static constexpr roundingMode rmTowardZero     = RoundingMode::TowardZero;\n  static constexpr roundingMode rmNearestTiesToAway =\n                                                RoundingMode::NearestTiesToAway;\n\n  /// IEEE-754R 7: Default exception handling.\n  ///\n  /// opUnderflow or opOverflow are always returned or-ed with opInexact.\n  ///\n  /// APFloat models this behavior specified by IEEE-754:\n  ///   \"For operations producing results in floating-point format, the default\n  ///    result of an operation that signals the invalid operation exception\n  ///    shall be a quiet NaN.\"\n  enum opStatus {\n    opOK = 0x00,\n    opInvalidOp = 0x01,\n    opDivByZero = 0x02,\n    opOverflow = 0x04,\n    opUnderflow = 0x08,\n    opInexact = 0x10\n  };\n\n  /// Category of internally-represented number.\n  enum fltCategory {\n    fcInfinity,\n    fcNaN,\n    fcNormal,\n    fcZero\n  };\n\n  /// Convenience enum used to construct an uninitialized APFloat.\n  enum uninitializedTag {\n    uninitialized\n  };\n\n  /// Enumeration of \\c ilogb error results.\n  enum IlogbErrorKinds {\n    IEK_Zero = INT_MIN + 1,\n    IEK_NaN = INT_MIN,\n    IEK_Inf = INT_MAX\n  };\n\n  static unsigned int semanticsPrecision(const fltSemantics &);\n  static ExponentType semanticsMinExponent(const fltSemantics &);\n  static ExponentType semanticsMaxExponent(const fltSemantics &);\n  static unsigned int semanticsSizeInBits(const fltSemantics &);\n\n  /// Returns the size of the floating point number (in bits) in the given\n  /// semantics.\n  static unsigned getSizeInBits(const fltSemantics &Sem);\n};\n\nnamespace detail {\n\nclass IEEEFloat final : public APFloatBase {\npublic:\n  /// \\name Constructors\n  /// @{\n\n  IEEEFloat(const fltSemantics &); // Default construct to +0.0\n  IEEEFloat(const fltSemantics &, integerPart);\n  IEEEFloat(const fltSemantics &, uninitializedTag);\n  IEEEFloat(const fltSemantics &, const APInt &);\n  explicit IEEEFloat(double d);\n  explicit IEEEFloat(float f);\n  IEEEFloat(const IEEEFloat &);\n  IEEEFloat(IEEEFloat &&);\n  ~IEEEFloat();\n\n  /// @}\n\n  /// Returns whether this instance allocated memory.\n  bool needsCleanup() const { return partCount() > 1; }\n\n  /// \\name Convenience \"constructors\"\n  /// @{\n\n  /// @}\n\n  /// \\name Arithmetic\n  /// @{\n\n  opStatus add(const IEEEFloat &, roundingMode);\n  opStatus subtract(const IEEEFloat &, roundingMode);\n  opStatus multiply(const IEEEFloat &, roundingMode);\n  opStatus divide(const IEEEFloat &, roundingMode);\n  /// IEEE remainder.\n  opStatus remainder(const IEEEFloat &);\n  /// C fmod, or llvm frem.\n  opStatus mod(const IEEEFloat &);\n  opStatus fusedMultiplyAdd(const IEEEFloat &, const IEEEFloat &, roundingMode);\n  opStatus roundToIntegral(roundingMode);\n  /// IEEE-754R 5.3.1: nextUp/nextDown.\n  opStatus next(bool nextDown);\n\n  /// @}\n\n  /// \\name Sign operations.\n  /// @{\n\n  void changeSign();\n\n  /// @}\n\n  /// \\name Conversions\n  /// @{\n\n  opStatus convert(const fltSemantics &, roundingMode, bool *);\n  opStatus convertToInteger(MutableArrayRef<integerPart>, unsigned int, bool,\n                            roundingMode, bool *) const;\n  opStatus convertFromAPInt(const APInt &, bool, roundingMode);\n  opStatus convertFromSignExtendedInteger(const integerPart *, unsigned int,\n                                          bool, roundingMode);\n  opStatus convertFromZeroExtendedInteger(const integerPart *, unsigned int,\n                                          bool, roundingMode);\n  Expected<opStatus> convertFromString(StringRef, roundingMode);\n  APInt bitcastToAPInt() const;\n  double convertToDouble() const;\n  float convertToFloat() const;\n\n  /// @}\n\n  /// The definition of equality is not straightforward for floating point, so\n  /// we won't use operator==.  Use one of the following, or write whatever it\n  /// is you really mean.\n  bool operator==(const IEEEFloat &) const = delete;\n\n  /// IEEE comparison with another floating point number (NaNs compare\n  /// unordered, 0==-0).\n  cmpResult compare(const IEEEFloat &) const;\n\n  /// Bitwise comparison for equality (QNaNs compare equal, 0!=-0).\n  bool bitwiseIsEqual(const IEEEFloat &) const;\n\n  /// Write out a hexadecimal representation of the floating point value to DST,\n  /// which must be of sufficient size, in the C99 form [-]0xh.hhhhp[+-]d.\n  /// Return the number of characters written, excluding the terminating NUL.\n  unsigned int convertToHexString(char *dst, unsigned int hexDigits,\n                                  bool upperCase, roundingMode) const;\n\n  /// \\name IEEE-754R 5.7.2 General operations.\n  /// @{\n\n  /// IEEE-754R isSignMinus: Returns true if and only if the current value is\n  /// negative.\n  ///\n  /// This applies to zeros and NaNs as well.\n  bool isNegative() const { return sign; }\n\n  /// IEEE-754R isNormal: Returns true if and only if the current value is normal.\n  ///\n  /// This implies that the current value of the float is not zero, subnormal,\n  /// infinite, or NaN following the definition of normality from IEEE-754R.\n  bool isNormal() const { return !isDenormal() && isFiniteNonZero(); }\n\n  /// Returns true if and only if the current value is zero, subnormal, or\n  /// normal.\n  ///\n  /// This means that the value is not infinite or NaN.\n  bool isFinite() const { return !isNaN() && !isInfinity(); }\n\n  /// Returns true if and only if the float is plus or minus zero.\n  bool isZero() const { return category == fcZero; }\n\n  /// IEEE-754R isSubnormal(): Returns true if and only if the float is a\n  /// denormal.\n  bool isDenormal() const;\n\n  /// IEEE-754R isInfinite(): Returns true if and only if the float is infinity.\n  bool isInfinity() const { return category == fcInfinity; }\n\n  /// Returns true if and only if the float is a quiet or signaling NaN.\n  bool isNaN() const { return category == fcNaN; }\n\n  /// Returns true if and only if the float is a signaling NaN.\n  bool isSignaling() const;\n\n  /// @}\n\n  /// \\name Simple Queries\n  /// @{\n\n  fltCategory getCategory() const { return category; }\n  const fltSemantics &getSemantics() const { return *semantics; }\n  bool isNonZero() const { return category != fcZero; }\n  bool isFiniteNonZero() const { return isFinite() && !isZero(); }\n  bool isPosZero() const { return isZero() && !isNegative(); }\n  bool isNegZero() const { return isZero() && isNegative(); }\n\n  /// Returns true if and only if the number has the smallest possible non-zero\n  /// magnitude in the current semantics.\n  bool isSmallest() const;\n\n  /// Returns true if and only if the number has the largest possible finite\n  /// magnitude in the current semantics.\n  bool isLargest() const;\n\n  /// Returns true if and only if the number is an exact integer.\n  bool isInteger() const;\n\n  /// @}\n\n  IEEEFloat &operator=(const IEEEFloat &);\n  IEEEFloat &operator=(IEEEFloat &&);\n\n  /// Overload to compute a hash code for an APFloat value.\n  ///\n  /// Note that the use of hash codes for floating point values is in general\n  /// frought with peril. Equality is hard to define for these values. For\n  /// example, should negative and positive zero hash to different codes? Are\n  /// they equal or not? This hash value implementation specifically\n  /// emphasizes producing different codes for different inputs in order to\n  /// be used in canonicalization and memoization. As such, equality is\n  /// bitwiseIsEqual, and 0 != -0.\n  friend hash_code hash_value(const IEEEFloat &Arg);\n\n  /// Converts this value into a decimal string.\n  ///\n  /// \\param FormatPrecision The maximum number of digits of\n  ///   precision to output.  If there are fewer digits available,\n  ///   zero padding will not be used unless the value is\n  ///   integral and small enough to be expressed in\n  ///   FormatPrecision digits.  0 means to use the natural\n  ///   precision of the number.\n  /// \\param FormatMaxPadding The maximum number of zeros to\n  ///   consider inserting before falling back to scientific\n  ///   notation.  0 means to always use scientific notation.\n  ///\n  /// \\param TruncateZero Indicate whether to remove the trailing zero in\n  ///   fraction part or not. Also setting this parameter to false forcing\n  ///   producing of output more similar to default printf behavior.\n  ///   Specifically the lower e is used as exponent delimiter and exponent\n  ///   always contains no less than two digits.\n  ///\n  /// Number       Precision    MaxPadding      Result\n  /// ------       ---------    ----------      ------\n  /// 1.01E+4              5             2       10100\n  /// 1.01E+4              4             2       1.01E+4\n  /// 1.01E+4              5             1       1.01E+4\n  /// 1.01E-2              5             2       0.0101\n  /// 1.01E-2              4             2       0.0101\n  /// 1.01E-2              4             1       1.01E-2\n  void toString(SmallVectorImpl<char> &Str, unsigned FormatPrecision = 0,\n                unsigned FormatMaxPadding = 3, bool TruncateZero = true) const;\n\n  /// If this value has an exact multiplicative inverse, store it in inv and\n  /// return true.\n  bool getExactInverse(APFloat *inv) const;\n\n  /// Returns the exponent of the internal representation of the APFloat.\n  ///\n  /// Because the radix of APFloat is 2, this is equivalent to floor(log2(x)).\n  /// For special APFloat values, this returns special error codes:\n  ///\n  ///   NaN -> \\c IEK_NaN\n  ///   0   -> \\c IEK_Zero\n  ///   Inf -> \\c IEK_Inf\n  ///\n  friend int ilogb(const IEEEFloat &Arg);\n\n  /// Returns: X * 2^Exp for integral exponents.\n  friend IEEEFloat scalbn(IEEEFloat X, int Exp, roundingMode);\n\n  friend IEEEFloat frexp(const IEEEFloat &X, int &Exp, roundingMode);\n\n  /// \\name Special value setters.\n  /// @{\n\n  void makeLargest(bool Neg = false);\n  void makeSmallest(bool Neg = false);\n  void makeNaN(bool SNaN = false, bool Neg = false,\n               const APInt *fill = nullptr);\n  void makeInf(bool Neg = false);\n  void makeZero(bool Neg = false);\n  void makeQuiet();\n\n  /// Returns the smallest (by magnitude) normalized finite number in the given\n  /// semantics.\n  ///\n  /// \\param Negative - True iff the number should be negative\n  void makeSmallestNormalized(bool Negative = false);\n\n  /// @}\n\n  cmpResult compareAbsoluteValue(const IEEEFloat &) const;\n\nprivate:\n  /// \\name Simple Queries\n  /// @{\n\n  integerPart *significandParts();\n  const integerPart *significandParts() const;\n  unsigned int partCount() const;\n\n  /// @}\n\n  /// \\name Significand operations.\n  /// @{\n\n  integerPart addSignificand(const IEEEFloat &);\n  integerPart subtractSignificand(const IEEEFloat &, integerPart);\n  lostFraction addOrSubtractSignificand(const IEEEFloat &, bool subtract);\n  lostFraction multiplySignificand(const IEEEFloat &, IEEEFloat);\n  lostFraction multiplySignificand(const IEEEFloat&);\n  lostFraction divideSignificand(const IEEEFloat &);\n  void incrementSignificand();\n  void initialize(const fltSemantics *);\n  void shiftSignificandLeft(unsigned int);\n  lostFraction shiftSignificandRight(unsigned int);\n  unsigned int significandLSB() const;\n  unsigned int significandMSB() const;\n  void zeroSignificand();\n  /// Return true if the significand excluding the integral bit is all ones.\n  bool isSignificandAllOnes() const;\n  /// Return true if the significand excluding the integral bit is all zeros.\n  bool isSignificandAllZeros() const;\n\n  /// @}\n\n  /// \\name Arithmetic on special values.\n  /// @{\n\n  opStatus addOrSubtractSpecials(const IEEEFloat &, bool subtract);\n  opStatus divideSpecials(const IEEEFloat &);\n  opStatus multiplySpecials(const IEEEFloat &);\n  opStatus modSpecials(const IEEEFloat &);\n  opStatus remainderSpecials(const IEEEFloat&);\n\n  /// @}\n\n  /// \\name Miscellany\n  /// @{\n\n  bool convertFromStringSpecials(StringRef str);\n  opStatus normalize(roundingMode, lostFraction);\n  opStatus addOrSubtract(const IEEEFloat &, roundingMode, bool subtract);\n  opStatus handleOverflow(roundingMode);\n  bool roundAwayFromZero(roundingMode, lostFraction, unsigned int) const;\n  opStatus convertToSignExtendedInteger(MutableArrayRef<integerPart>,\n                                        unsigned int, bool, roundingMode,\n                                        bool *) const;\n  opStatus convertFromUnsignedParts(const integerPart *, unsigned int,\n                                    roundingMode);\n  Expected<opStatus> convertFromHexadecimalString(StringRef, roundingMode);\n  Expected<opStatus> convertFromDecimalString(StringRef, roundingMode);\n  char *convertNormalToHexString(char *, unsigned int, bool,\n                                 roundingMode) const;\n  opStatus roundSignificandWithExponent(const integerPart *, unsigned int, int,\n                                        roundingMode);\n  ExponentType exponentNaN() const;\n  ExponentType exponentInf() const;\n  ExponentType exponentZero() const;\n\n  /// @}\n\n  APInt convertHalfAPFloatToAPInt() const;\n  APInt convertBFloatAPFloatToAPInt() const;\n  APInt convertFloatAPFloatToAPInt() const;\n  APInt convertDoubleAPFloatToAPInt() const;\n  APInt convertQuadrupleAPFloatToAPInt() const;\n  APInt convertF80LongDoubleAPFloatToAPInt() const;\n  APInt convertPPCDoubleDoubleAPFloatToAPInt() const;\n  void initFromAPInt(const fltSemantics *Sem, const APInt &api);\n  void initFromHalfAPInt(const APInt &api);\n  void initFromBFloatAPInt(const APInt &api);\n  void initFromFloatAPInt(const APInt &api);\n  void initFromDoubleAPInt(const APInt &api);\n  void initFromQuadrupleAPInt(const APInt &api);\n  void initFromF80LongDoubleAPInt(const APInt &api);\n  void initFromPPCDoubleDoubleAPInt(const APInt &api);\n\n  void assign(const IEEEFloat &);\n  void copySignificand(const IEEEFloat &);\n  void freeSignificand();\n\n  /// Note: this must be the first data member.\n  /// The semantics that this value obeys.\n  const fltSemantics *semantics;\n\n  /// A binary fraction with an explicit integer bit.\n  ///\n  /// The significand must be at least one bit wider than the target precision.\n  union Significand {\n    integerPart part;\n    integerPart *parts;\n  } significand;\n\n  /// The signed unbiased exponent of the value.\n  ExponentType exponent;\n\n  /// What kind of floating point number this is.\n  ///\n  /// Only 2 bits are required, but VisualStudio incorrectly sign extends it.\n  /// Using the extra bit keeps it from failing under VisualStudio.\n  fltCategory category : 3;\n\n  /// Sign bit of the number.\n  unsigned int sign : 1;\n};\n\nhash_code hash_value(const IEEEFloat &Arg);\nint ilogb(const IEEEFloat &Arg);\nIEEEFloat scalbn(IEEEFloat X, int Exp, IEEEFloat::roundingMode);\nIEEEFloat frexp(const IEEEFloat &Val, int &Exp, IEEEFloat::roundingMode RM);\n\n// This mode implements more precise float in terms of two APFloats.\n// The interface and layout is designed for arbitrary underlying semantics,\n// though currently only PPCDoubleDouble semantics are supported, whose\n// corresponding underlying semantics are IEEEdouble.\nclass DoubleAPFloat final : public APFloatBase {\n  // Note: this must be the first data member.\n  const fltSemantics *Semantics;\n  std::unique_ptr<APFloat[]> Floats;\n\n  opStatus addImpl(const APFloat &a, const APFloat &aa, const APFloat &c,\n                   const APFloat &cc, roundingMode RM);\n\n  opStatus addWithSpecial(const DoubleAPFloat &LHS, const DoubleAPFloat &RHS,\n                          DoubleAPFloat &Out, roundingMode RM);\n\npublic:\n  DoubleAPFloat(const fltSemantics &S);\n  DoubleAPFloat(const fltSemantics &S, uninitializedTag);\n  DoubleAPFloat(const fltSemantics &S, integerPart);\n  DoubleAPFloat(const fltSemantics &S, const APInt &I);\n  DoubleAPFloat(const fltSemantics &S, APFloat &&First, APFloat &&Second);\n  DoubleAPFloat(const DoubleAPFloat &RHS);\n  DoubleAPFloat(DoubleAPFloat &&RHS);\n\n  DoubleAPFloat &operator=(const DoubleAPFloat &RHS);\n\n  DoubleAPFloat &operator=(DoubleAPFloat &&RHS) {\n    if (this != &RHS) {\n      this->~DoubleAPFloat();\n      new (this) DoubleAPFloat(std::move(RHS));\n    }\n    return *this;\n  }\n\n  bool needsCleanup() const { return Floats != nullptr; }\n\n  APFloat &getFirst() { return Floats[0]; }\n  const APFloat &getFirst() const { return Floats[0]; }\n  APFloat &getSecond() { return Floats[1]; }\n  const APFloat &getSecond() const { return Floats[1]; }\n\n  opStatus add(const DoubleAPFloat &RHS, roundingMode RM);\n  opStatus subtract(const DoubleAPFloat &RHS, roundingMode RM);\n  opStatus multiply(const DoubleAPFloat &RHS, roundingMode RM);\n  opStatus divide(const DoubleAPFloat &RHS, roundingMode RM);\n  opStatus remainder(const DoubleAPFloat &RHS);\n  opStatus mod(const DoubleAPFloat &RHS);\n  opStatus fusedMultiplyAdd(const DoubleAPFloat &Multiplicand,\n                            const DoubleAPFloat &Addend, roundingMode RM);\n  opStatus roundToIntegral(roundingMode RM);\n  void changeSign();\n  cmpResult compareAbsoluteValue(const DoubleAPFloat &RHS) const;\n\n  fltCategory getCategory() const;\n  bool isNegative() const;\n\n  void makeInf(bool Neg);\n  void makeZero(bool Neg);\n  void makeLargest(bool Neg);\n  void makeSmallest(bool Neg);\n  void makeSmallestNormalized(bool Neg);\n  void makeNaN(bool SNaN, bool Neg, const APInt *fill);\n\n  cmpResult compare(const DoubleAPFloat &RHS) const;\n  bool bitwiseIsEqual(const DoubleAPFloat &RHS) const;\n  APInt bitcastToAPInt() const;\n  Expected<opStatus> convertFromString(StringRef, roundingMode);\n  opStatus next(bool nextDown);\n\n  opStatus convertToInteger(MutableArrayRef<integerPart> Input,\n                            unsigned int Width, bool IsSigned, roundingMode RM,\n                            bool *IsExact) const;\n  opStatus convertFromAPInt(const APInt &Input, bool IsSigned, roundingMode RM);\n  opStatus convertFromSignExtendedInteger(const integerPart *Input,\n                                          unsigned int InputSize, bool IsSigned,\n                                          roundingMode RM);\n  opStatus convertFromZeroExtendedInteger(const integerPart *Input,\n                                          unsigned int InputSize, bool IsSigned,\n                                          roundingMode RM);\n  unsigned int convertToHexString(char *DST, unsigned int HexDigits,\n                                  bool UpperCase, roundingMode RM) const;\n\n  bool isDenormal() const;\n  bool isSmallest() const;\n  bool isLargest() const;\n  bool isInteger() const;\n\n  void toString(SmallVectorImpl<char> &Str, unsigned FormatPrecision,\n                unsigned FormatMaxPadding, bool TruncateZero = true) const;\n\n  bool getExactInverse(APFloat *inv) const;\n\n  friend DoubleAPFloat scalbn(const DoubleAPFloat &X, int Exp, roundingMode);\n  friend DoubleAPFloat frexp(const DoubleAPFloat &X, int &Exp, roundingMode);\n  friend hash_code hash_value(const DoubleAPFloat &Arg);\n};\n\nhash_code hash_value(const DoubleAPFloat &Arg);\n\n} // End detail namespace\n\n// This is a interface class that is currently forwarding functionalities from\n// detail::IEEEFloat.\nclass APFloat : public APFloatBase {\n  typedef detail::IEEEFloat IEEEFloat;\n  typedef detail::DoubleAPFloat DoubleAPFloat;\n\n  static_assert(std::is_standard_layout<IEEEFloat>::value, \"\");\n\n  union Storage {\n    const fltSemantics *semantics;\n    IEEEFloat IEEE;\n    DoubleAPFloat Double;\n\n    explicit Storage(IEEEFloat F, const fltSemantics &S);\n    explicit Storage(DoubleAPFloat F, const fltSemantics &S)\n        : Double(std::move(F)) {\n      assert(&S == &PPCDoubleDouble());\n    }\n\n    template <typename... ArgTypes>\n    Storage(const fltSemantics &Semantics, ArgTypes &&... Args) {\n      if (usesLayout<IEEEFloat>(Semantics)) {\n        new (&IEEE) IEEEFloat(Semantics, std::forward<ArgTypes>(Args)...);\n        return;\n      }\n      if (usesLayout<DoubleAPFloat>(Semantics)) {\n        new (&Double) DoubleAPFloat(Semantics, std::forward<ArgTypes>(Args)...);\n        return;\n      }\n      llvm_unreachable(\"Unexpected semantics\");\n    }\n\n    ~Storage() {\n      if (usesLayout<IEEEFloat>(*semantics)) {\n        IEEE.~IEEEFloat();\n        return;\n      }\n      if (usesLayout<DoubleAPFloat>(*semantics)) {\n        Double.~DoubleAPFloat();\n        return;\n      }\n      llvm_unreachable(\"Unexpected semantics\");\n    }\n\n    Storage(const Storage &RHS) {\n      if (usesLayout<IEEEFloat>(*RHS.semantics)) {\n        new (this) IEEEFloat(RHS.IEEE);\n        return;\n      }\n      if (usesLayout<DoubleAPFloat>(*RHS.semantics)) {\n        new (this) DoubleAPFloat(RHS.Double);\n        return;\n      }\n      llvm_unreachable(\"Unexpected semantics\");\n    }\n\n    Storage(Storage &&RHS) {\n      if (usesLayout<IEEEFloat>(*RHS.semantics)) {\n        new (this) IEEEFloat(std::move(RHS.IEEE));\n        return;\n      }\n      if (usesLayout<DoubleAPFloat>(*RHS.semantics)) {\n        new (this) DoubleAPFloat(std::move(RHS.Double));\n        return;\n      }\n      llvm_unreachable(\"Unexpected semantics\");\n    }\n\n    Storage &operator=(const Storage &RHS) {\n      if (usesLayout<IEEEFloat>(*semantics) &&\n          usesLayout<IEEEFloat>(*RHS.semantics)) {\n        IEEE = RHS.IEEE;\n      } else if (usesLayout<DoubleAPFloat>(*semantics) &&\n                 usesLayout<DoubleAPFloat>(*RHS.semantics)) {\n        Double = RHS.Double;\n      } else if (this != &RHS) {\n        this->~Storage();\n        new (this) Storage(RHS);\n      }\n      return *this;\n    }\n\n    Storage &operator=(Storage &&RHS) {\n      if (usesLayout<IEEEFloat>(*semantics) &&\n          usesLayout<IEEEFloat>(*RHS.semantics)) {\n        IEEE = std::move(RHS.IEEE);\n      } else if (usesLayout<DoubleAPFloat>(*semantics) &&\n                 usesLayout<DoubleAPFloat>(*RHS.semantics)) {\n        Double = std::move(RHS.Double);\n      } else if (this != &RHS) {\n        this->~Storage();\n        new (this) Storage(std::move(RHS));\n      }\n      return *this;\n    }\n  } U;\n\n  template <typename T> static bool usesLayout(const fltSemantics &Semantics) {\n    static_assert(std::is_same<T, IEEEFloat>::value ||\n                  std::is_same<T, DoubleAPFloat>::value, \"\");\n    if (std::is_same<T, DoubleAPFloat>::value) {\n      return &Semantics == &PPCDoubleDouble();\n    }\n    return &Semantics != &PPCDoubleDouble();\n  }\n\n  IEEEFloat &getIEEE() {\n    if (usesLayout<IEEEFloat>(*U.semantics))\n      return U.IEEE;\n    if (usesLayout<DoubleAPFloat>(*U.semantics))\n      return U.Double.getFirst().U.IEEE;\n    llvm_unreachable(\"Unexpected semantics\");\n  }\n\n  const IEEEFloat &getIEEE() const {\n    if (usesLayout<IEEEFloat>(*U.semantics))\n      return U.IEEE;\n    if (usesLayout<DoubleAPFloat>(*U.semantics))\n      return U.Double.getFirst().U.IEEE;\n    llvm_unreachable(\"Unexpected semantics\");\n  }\n\n  void makeZero(bool Neg) { APFLOAT_DISPATCH_ON_SEMANTICS(makeZero(Neg)); }\n\n  void makeInf(bool Neg) { APFLOAT_DISPATCH_ON_SEMANTICS(makeInf(Neg)); }\n\n  void makeNaN(bool SNaN, bool Neg, const APInt *fill) {\n    APFLOAT_DISPATCH_ON_SEMANTICS(makeNaN(SNaN, Neg, fill));\n  }\n\n  void makeLargest(bool Neg) {\n    APFLOAT_DISPATCH_ON_SEMANTICS(makeLargest(Neg));\n  }\n\n  void makeSmallest(bool Neg) {\n    APFLOAT_DISPATCH_ON_SEMANTICS(makeSmallest(Neg));\n  }\n\n  void makeSmallestNormalized(bool Neg) {\n    APFLOAT_DISPATCH_ON_SEMANTICS(makeSmallestNormalized(Neg));\n  }\n\n  // FIXME: This is due to clang 3.3 (or older version) always checks for the\n  // default constructor in an array aggregate initialization, even if no\n  // elements in the array is default initialized.\n  APFloat() : U(IEEEdouble()) {\n    llvm_unreachable(\"This is a workaround for old clang.\");\n  }\n\n  explicit APFloat(IEEEFloat F, const fltSemantics &S) : U(std::move(F), S) {}\n  explicit APFloat(DoubleAPFloat F, const fltSemantics &S)\n      : U(std::move(F), S) {}\n\n  cmpResult compareAbsoluteValue(const APFloat &RHS) const {\n    assert(&getSemantics() == &RHS.getSemantics() &&\n           \"Should only compare APFloats with the same semantics\");\n    if (usesLayout<IEEEFloat>(getSemantics()))\n      return U.IEEE.compareAbsoluteValue(RHS.U.IEEE);\n    if (usesLayout<DoubleAPFloat>(getSemantics()))\n      return U.Double.compareAbsoluteValue(RHS.U.Double);\n    llvm_unreachable(\"Unexpected semantics\");\n  }\n\npublic:\n  APFloat(const fltSemantics &Semantics) : U(Semantics) {}\n  APFloat(const fltSemantics &Semantics, StringRef S);\n  APFloat(const fltSemantics &Semantics, integerPart I) : U(Semantics, I) {}\n  template <typename T,\n            typename = std::enable_if_t<std::is_floating_point<T>::value>>\n  APFloat(const fltSemantics &Semantics, T V) = delete;\n  // TODO: Remove this constructor. This isn't faster than the first one.\n  APFloat(const fltSemantics &Semantics, uninitializedTag)\n      : U(Semantics, uninitialized) {}\n  APFloat(const fltSemantics &Semantics, const APInt &I) : U(Semantics, I) {}\n  explicit APFloat(double d) : U(IEEEFloat(d), IEEEdouble()) {}\n  explicit APFloat(float f) : U(IEEEFloat(f), IEEEsingle()) {}\n  APFloat(const APFloat &RHS) = default;\n  APFloat(APFloat &&RHS) = default;\n\n  ~APFloat() = default;\n\n  bool needsCleanup() const { APFLOAT_DISPATCH_ON_SEMANTICS(needsCleanup()); }\n\n  /// Factory for Positive and Negative Zero.\n  ///\n  /// \\param Negative True iff the number should be negative.\n  static APFloat getZero(const fltSemantics &Sem, bool Negative = false) {\n    APFloat Val(Sem, uninitialized);\n    Val.makeZero(Negative);\n    return Val;\n  }\n\n  /// Factory for Positive and Negative Infinity.\n  ///\n  /// \\param Negative True iff the number should be negative.\n  static APFloat getInf(const fltSemantics &Sem, bool Negative = false) {\n    APFloat Val(Sem, uninitialized);\n    Val.makeInf(Negative);\n    return Val;\n  }\n\n  /// Factory for NaN values.\n  ///\n  /// \\param Negative - True iff the NaN generated should be negative.\n  /// \\param payload - The unspecified fill bits for creating the NaN, 0 by\n  /// default.  The value is truncated as necessary.\n  static APFloat getNaN(const fltSemantics &Sem, bool Negative = false,\n                        uint64_t payload = 0) {\n    if (payload) {\n      APInt intPayload(64, payload);\n      return getQNaN(Sem, Negative, &intPayload);\n    } else {\n      return getQNaN(Sem, Negative, nullptr);\n    }\n  }\n\n  /// Factory for QNaN values.\n  static APFloat getQNaN(const fltSemantics &Sem, bool Negative = false,\n                         const APInt *payload = nullptr) {\n    APFloat Val(Sem, uninitialized);\n    Val.makeNaN(false, Negative, payload);\n    return Val;\n  }\n\n  /// Factory for SNaN values.\n  static APFloat getSNaN(const fltSemantics &Sem, bool Negative = false,\n                         const APInt *payload = nullptr) {\n    APFloat Val(Sem, uninitialized);\n    Val.makeNaN(true, Negative, payload);\n    return Val;\n  }\n\n  /// Returns the largest finite number in the given semantics.\n  ///\n  /// \\param Negative - True iff the number should be negative\n  static APFloat getLargest(const fltSemantics &Sem, bool Negative = false) {\n    APFloat Val(Sem, uninitialized);\n    Val.makeLargest(Negative);\n    return Val;\n  }\n\n  /// Returns the smallest (by magnitude) finite number in the given semantics.\n  /// Might be denormalized, which implies a relative loss of precision.\n  ///\n  /// \\param Negative - True iff the number should be negative\n  static APFloat getSmallest(const fltSemantics &Sem, bool Negative = false) {\n    APFloat Val(Sem, uninitialized);\n    Val.makeSmallest(Negative);\n    return Val;\n  }\n\n  /// Returns the smallest (by magnitude) normalized finite number in the given\n  /// semantics.\n  ///\n  /// \\param Negative - True iff the number should be negative\n  static APFloat getSmallestNormalized(const fltSemantics &Sem,\n                                       bool Negative = false) {\n    APFloat Val(Sem, uninitialized);\n    Val.makeSmallestNormalized(Negative);\n    return Val;\n  }\n\n  /// Returns a float which is bitcasted from an all one value int.\n  ///\n  /// \\param Semantics - type float semantics\n  /// \\param BitWidth - Select float type\n  static APFloat getAllOnesValue(const fltSemantics &Semantics,\n                                 unsigned BitWidth);\n\n  /// Used to insert APFloat objects, or objects that contain APFloat objects,\n  /// into FoldingSets.\n  void Profile(FoldingSetNodeID &NID) const;\n\n  opStatus add(const APFloat &RHS, roundingMode RM) {\n    assert(&getSemantics() == &RHS.getSemantics() &&\n           \"Should only call on two APFloats with the same semantics\");\n    if (usesLayout<IEEEFloat>(getSemantics()))\n      return U.IEEE.add(RHS.U.IEEE, RM);\n    if (usesLayout<DoubleAPFloat>(getSemantics()))\n      return U.Double.add(RHS.U.Double, RM);\n    llvm_unreachable(\"Unexpected semantics\");\n  }\n  opStatus subtract(const APFloat &RHS, roundingMode RM) {\n    assert(&getSemantics() == &RHS.getSemantics() &&\n           \"Should only call on two APFloats with the same semantics\");\n    if (usesLayout<IEEEFloat>(getSemantics()))\n      return U.IEEE.subtract(RHS.U.IEEE, RM);\n    if (usesLayout<DoubleAPFloat>(getSemantics()))\n      return U.Double.subtract(RHS.U.Double, RM);\n    llvm_unreachable(\"Unexpected semantics\");\n  }\n  opStatus multiply(const APFloat &RHS, roundingMode RM) {\n    assert(&getSemantics() == &RHS.getSemantics() &&\n           \"Should only call on two APFloats with the same semantics\");\n    if (usesLayout<IEEEFloat>(getSemantics()))\n      return U.IEEE.multiply(RHS.U.IEEE, RM);\n    if (usesLayout<DoubleAPFloat>(getSemantics()))\n      return U.Double.multiply(RHS.U.Double, RM);\n    llvm_unreachable(\"Unexpected semantics\");\n  }\n  opStatus divide(const APFloat &RHS, roundingMode RM) {\n    assert(&getSemantics() == &RHS.getSemantics() &&\n           \"Should only call on two APFloats with the same semantics\");\n    if (usesLayout<IEEEFloat>(getSemantics()))\n      return U.IEEE.divide(RHS.U.IEEE, RM);\n    if (usesLayout<DoubleAPFloat>(getSemantics()))\n      return U.Double.divide(RHS.U.Double, RM);\n    llvm_unreachable(\"Unexpected semantics\");\n  }\n  opStatus remainder(const APFloat &RHS) {\n    assert(&getSemantics() == &RHS.getSemantics() &&\n           \"Should only call on two APFloats with the same semantics\");\n    if (usesLayout<IEEEFloat>(getSemantics()))\n      return U.IEEE.remainder(RHS.U.IEEE);\n    if (usesLayout<DoubleAPFloat>(getSemantics()))\n      return U.Double.remainder(RHS.U.Double);\n    llvm_unreachable(\"Unexpected semantics\");\n  }\n  opStatus mod(const APFloat &RHS) {\n    assert(&getSemantics() == &RHS.getSemantics() &&\n           \"Should only call on two APFloats with the same semantics\");\n    if (usesLayout<IEEEFloat>(getSemantics()))\n      return U.IEEE.mod(RHS.U.IEEE);\n    if (usesLayout<DoubleAPFloat>(getSemantics()))\n      return U.Double.mod(RHS.U.Double);\n    llvm_unreachable(\"Unexpected semantics\");\n  }\n  opStatus fusedMultiplyAdd(const APFloat &Multiplicand, const APFloat &Addend,\n                            roundingMode RM) {\n    assert(&getSemantics() == &Multiplicand.getSemantics() &&\n           \"Should only call on APFloats with the same semantics\");\n    assert(&getSemantics() == &Addend.getSemantics() &&\n           \"Should only call on APFloats with the same semantics\");\n    if (usesLayout<IEEEFloat>(getSemantics()))\n      return U.IEEE.fusedMultiplyAdd(Multiplicand.U.IEEE, Addend.U.IEEE, RM);\n    if (usesLayout<DoubleAPFloat>(getSemantics()))\n      return U.Double.fusedMultiplyAdd(Multiplicand.U.Double, Addend.U.Double,\n                                       RM);\n    llvm_unreachable(\"Unexpected semantics\");\n  }\n  opStatus roundToIntegral(roundingMode RM) {\n    APFLOAT_DISPATCH_ON_SEMANTICS(roundToIntegral(RM));\n  }\n\n  // TODO: bool parameters are not readable and a source of bugs.\n  // Do something.\n  opStatus next(bool nextDown) {\n    APFLOAT_DISPATCH_ON_SEMANTICS(next(nextDown));\n  }\n\n  /// Negate an APFloat.\n  APFloat operator-() const {\n    APFloat Result(*this);\n    Result.changeSign();\n    return Result;\n  }\n\n  /// Add two APFloats, rounding ties to the nearest even.\n  /// No error checking.\n  APFloat operator+(const APFloat &RHS) const {\n    APFloat Result(*this);\n    (void)Result.add(RHS, rmNearestTiesToEven);\n    return Result;\n  }\n\n  /// Subtract two APFloats, rounding ties to the nearest even.\n  /// No error checking.\n  APFloat operator-(const APFloat &RHS) const {\n    APFloat Result(*this);\n    (void)Result.subtract(RHS, rmNearestTiesToEven);\n    return Result;\n  }\n\n  /// Multiply two APFloats, rounding ties to the nearest even.\n  /// No error checking.\n  APFloat operator*(const APFloat &RHS) const {\n    APFloat Result(*this);\n    (void)Result.multiply(RHS, rmNearestTiesToEven);\n    return Result;\n  }\n\n  /// Divide the first APFloat by the second, rounding ties to the nearest even.\n  /// No error checking.\n  APFloat operator/(const APFloat &RHS) const {\n    APFloat Result(*this);\n    (void)Result.divide(RHS, rmNearestTiesToEven);\n    return Result;\n  }\n\n  void changeSign() { APFLOAT_DISPATCH_ON_SEMANTICS(changeSign()); }\n  void clearSign() {\n    if (isNegative())\n      changeSign();\n  }\n  void copySign(const APFloat &RHS) {\n    if (isNegative() != RHS.isNegative())\n      changeSign();\n  }\n\n  /// A static helper to produce a copy of an APFloat value with its sign\n  /// copied from some other APFloat.\n  static APFloat copySign(APFloat Value, const APFloat &Sign) {\n    Value.copySign(Sign);\n    return Value;\n  }\n\n  opStatus convert(const fltSemantics &ToSemantics, roundingMode RM,\n                   bool *losesInfo);\n  opStatus convertToInteger(MutableArrayRef<integerPart> Input,\n                            unsigned int Width, bool IsSigned, roundingMode RM,\n                            bool *IsExact) const {\n    APFLOAT_DISPATCH_ON_SEMANTICS(\n        convertToInteger(Input, Width, IsSigned, RM, IsExact));\n  }\n  opStatus convertToInteger(APSInt &Result, roundingMode RM,\n                            bool *IsExact) const;\n  opStatus convertFromAPInt(const APInt &Input, bool IsSigned,\n                            roundingMode RM) {\n    APFLOAT_DISPATCH_ON_SEMANTICS(convertFromAPInt(Input, IsSigned, RM));\n  }\n  opStatus convertFromSignExtendedInteger(const integerPart *Input,\n                                          unsigned int InputSize, bool IsSigned,\n                                          roundingMode RM) {\n    APFLOAT_DISPATCH_ON_SEMANTICS(\n        convertFromSignExtendedInteger(Input, InputSize, IsSigned, RM));\n  }\n  opStatus convertFromZeroExtendedInteger(const integerPart *Input,\n                                          unsigned int InputSize, bool IsSigned,\n                                          roundingMode RM) {\n    APFLOAT_DISPATCH_ON_SEMANTICS(\n        convertFromZeroExtendedInteger(Input, InputSize, IsSigned, RM));\n  }\n  Expected<opStatus> convertFromString(StringRef, roundingMode);\n  APInt bitcastToAPInt() const {\n    APFLOAT_DISPATCH_ON_SEMANTICS(bitcastToAPInt());\n  }\n  double convertToDouble() const { return getIEEE().convertToDouble(); }\n  float convertToFloat() const { return getIEEE().convertToFloat(); }\n\n  bool operator==(const APFloat &RHS) const { return compare(RHS) == cmpEqual; }\n\n  bool operator!=(const APFloat &RHS) const { return compare(RHS) != cmpEqual; }\n\n  bool operator<(const APFloat &RHS) const {\n    return compare(RHS) == cmpLessThan;\n  }\n\n  bool operator>(const APFloat &RHS) const {\n    return compare(RHS) == cmpGreaterThan;\n  }\n\n  bool operator<=(const APFloat &RHS) const {\n    cmpResult Res = compare(RHS);\n    return Res == cmpLessThan || Res == cmpEqual;\n  }\n\n  bool operator>=(const APFloat &RHS) const {\n    cmpResult Res = compare(RHS);\n    return Res == cmpGreaterThan || Res == cmpEqual;\n  }\n\n  cmpResult compare(const APFloat &RHS) const {\n    assert(&getSemantics() == &RHS.getSemantics() &&\n           \"Should only compare APFloats with the same semantics\");\n    if (usesLayout<IEEEFloat>(getSemantics()))\n      return U.IEEE.compare(RHS.U.IEEE);\n    if (usesLayout<DoubleAPFloat>(getSemantics()))\n      return U.Double.compare(RHS.U.Double);\n    llvm_unreachable(\"Unexpected semantics\");\n  }\n\n  bool bitwiseIsEqual(const APFloat &RHS) const {\n    if (&getSemantics() != &RHS.getSemantics())\n      return false;\n    if (usesLayout<IEEEFloat>(getSemantics()))\n      return U.IEEE.bitwiseIsEqual(RHS.U.IEEE);\n    if (usesLayout<DoubleAPFloat>(getSemantics()))\n      return U.Double.bitwiseIsEqual(RHS.U.Double);\n    llvm_unreachable(\"Unexpected semantics\");\n  }\n\n  /// We don't rely on operator== working on double values, as\n  /// it returns true for things that are clearly not equal, like -0.0 and 0.0.\n  /// As such, this method can be used to do an exact bit-for-bit comparison of\n  /// two floating point values.\n  ///\n  /// We leave the version with the double argument here because it's just so\n  /// convenient to write \"2.0\" and the like.  Without this function we'd\n  /// have to duplicate its logic everywhere it's called.\n  bool isExactlyValue(double V) const {\n    bool ignored;\n    APFloat Tmp(V);\n    Tmp.convert(getSemantics(), APFloat::rmNearestTiesToEven, &ignored);\n    return bitwiseIsEqual(Tmp);\n  }\n\n  unsigned int convertToHexString(char *DST, unsigned int HexDigits,\n                                  bool UpperCase, roundingMode RM) const {\n    APFLOAT_DISPATCH_ON_SEMANTICS(\n        convertToHexString(DST, HexDigits, UpperCase, RM));\n  }\n\n  bool isZero() const { return getCategory() == fcZero; }\n  bool isInfinity() const { return getCategory() == fcInfinity; }\n  bool isNaN() const { return getCategory() == fcNaN; }\n\n  bool isNegative() const { return getIEEE().isNegative(); }\n  bool isDenormal() const { APFLOAT_DISPATCH_ON_SEMANTICS(isDenormal()); }\n  bool isSignaling() const { return getIEEE().isSignaling(); }\n\n  bool isNormal() const { return !isDenormal() && isFiniteNonZero(); }\n  bool isFinite() const { return !isNaN() && !isInfinity(); }\n\n  fltCategory getCategory() const { return getIEEE().getCategory(); }\n  const fltSemantics &getSemantics() const { return *U.semantics; }\n  bool isNonZero() const { return !isZero(); }\n  bool isFiniteNonZero() const { return isFinite() && !isZero(); }\n  bool isPosZero() const { return isZero() && !isNegative(); }\n  bool isNegZero() const { return isZero() && isNegative(); }\n  bool isSmallest() const { APFLOAT_DISPATCH_ON_SEMANTICS(isSmallest()); }\n  bool isLargest() const { APFLOAT_DISPATCH_ON_SEMANTICS(isLargest()); }\n  bool isInteger() const { APFLOAT_DISPATCH_ON_SEMANTICS(isInteger()); }\n  bool isIEEE() const { return usesLayout<IEEEFloat>(getSemantics()); }\n\n  APFloat &operator=(const APFloat &RHS) = default;\n  APFloat &operator=(APFloat &&RHS) = default;\n\n  void toString(SmallVectorImpl<char> &Str, unsigned FormatPrecision = 0,\n                unsigned FormatMaxPadding = 3, bool TruncateZero = true) const {\n    APFLOAT_DISPATCH_ON_SEMANTICS(\n        toString(Str, FormatPrecision, FormatMaxPadding, TruncateZero));\n  }\n\n  void print(raw_ostream &) const;\n  void dump() const;\n\n  bool getExactInverse(APFloat *inv) const {\n    APFLOAT_DISPATCH_ON_SEMANTICS(getExactInverse(inv));\n  }\n\n  friend hash_code hash_value(const APFloat &Arg);\n  friend int ilogb(const APFloat &Arg) { return ilogb(Arg.getIEEE()); }\n  friend APFloat scalbn(APFloat X, int Exp, roundingMode RM);\n  friend APFloat frexp(const APFloat &X, int &Exp, roundingMode RM);\n  friend IEEEFloat;\n  friend DoubleAPFloat;\n};\n\n/// See friend declarations above.\n///\n/// These additional declarations are required in order to compile LLVM with IBM\n/// xlC compiler.\nhash_code hash_value(const APFloat &Arg);\ninline APFloat scalbn(APFloat X, int Exp, APFloat::roundingMode RM) {\n  if (APFloat::usesLayout<detail::IEEEFloat>(X.getSemantics()))\n    return APFloat(scalbn(X.U.IEEE, Exp, RM), X.getSemantics());\n  if (APFloat::usesLayout<detail::DoubleAPFloat>(X.getSemantics()))\n    return APFloat(scalbn(X.U.Double, Exp, RM), X.getSemantics());\n  llvm_unreachable(\"Unexpected semantics\");\n}\n\n/// Equivalent of C standard library function.\n///\n/// While the C standard says Exp is an unspecified value for infinity and nan,\n/// this returns INT_MAX for infinities, and INT_MIN for NaNs.\ninline APFloat frexp(const APFloat &X, int &Exp, APFloat::roundingMode RM) {\n  if (APFloat::usesLayout<detail::IEEEFloat>(X.getSemantics()))\n    return APFloat(frexp(X.U.IEEE, Exp, RM), X.getSemantics());\n  if (APFloat::usesLayout<detail::DoubleAPFloat>(X.getSemantics()))\n    return APFloat(frexp(X.U.Double, Exp, RM), X.getSemantics());\n  llvm_unreachable(\"Unexpected semantics\");\n}\n/// Returns the absolute value of the argument.\ninline APFloat abs(APFloat X) {\n  X.clearSign();\n  return X;\n}\n\n/// Returns the negated value of the argument.\ninline APFloat neg(APFloat X) {\n  X.changeSign();\n  return X;\n}\n\n/// Implements IEEE minNum semantics. Returns the smaller of the 2 arguments if\n/// both are not NaN. If either argument is a NaN, returns the other argument.\nLLVM_READONLY\ninline APFloat minnum(const APFloat &A, const APFloat &B) {\n  if (A.isNaN())\n    return B;\n  if (B.isNaN())\n    return A;\n  return B < A ? B : A;\n}\n\n/// Implements IEEE maxNum semantics. Returns the larger of the 2 arguments if\n/// both are not NaN. If either argument is a NaN, returns the other argument.\nLLVM_READONLY\ninline APFloat maxnum(const APFloat &A, const APFloat &B) {\n  if (A.isNaN())\n    return B;\n  if (B.isNaN())\n    return A;\n  return A < B ? B : A;\n}\n\n/// Implements IEEE 754-2018 minimum semantics. Returns the smaller of 2\n/// arguments, propagating NaNs and treating -0 as less than +0.\nLLVM_READONLY\ninline APFloat minimum(const APFloat &A, const APFloat &B) {\n  if (A.isNaN())\n    return A;\n  if (B.isNaN())\n    return B;\n  if (A.isZero() && B.isZero() && (A.isNegative() != B.isNegative()))\n    return A.isNegative() ? A : B;\n  return B < A ? B : A;\n}\n\n/// Implements IEEE 754-2018 maximum semantics. Returns the larger of 2\n/// arguments, propagating NaNs and treating -0 as less than +0.\nLLVM_READONLY\ninline APFloat maximum(const APFloat &A, const APFloat &B) {\n  if (A.isNaN())\n    return A;\n  if (B.isNaN())\n    return B;\n  if (A.isZero() && B.isZero() && (A.isNegative() != B.isNegative()))\n    return A.isNegative() ? B : A;\n  return A < B ? B : A;\n}\n\n} // namespace llvm\n\n#undef APFLOAT_DISPATCH_ON_SEMANTICS\n#endif // LLVM_ADT_APFLOAT_H\n"}, "51": {"id": 51, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/DenseMap.h", "content": "//===- llvm/ADT/DenseMap.h - Dense probed hash table ------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// This file defines the DenseMap class.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_ADT_DENSEMAP_H\n#define LLVM_ADT_DENSEMAP_H\n\n#include \"llvm/ADT/DenseMapInfo.h\"\n#include \"llvm/ADT/EpochTracker.h\"\n#include \"llvm/Support/AlignOf.h\"\n#include \"llvm/Support/Compiler.h\"\n#include \"llvm/Support/MathExtras.h\"\n#include \"llvm/Support/MemAlloc.h\"\n#include \"llvm/Support/ReverseIteration.h\"\n#include \"llvm/Support/type_traits.h\"\n#include <algorithm>\n#include <cassert>\n#include <cstddef>\n#include <cstring>\n#include <initializer_list>\n#include <iterator>\n#include <new>\n#include <type_traits>\n#include <utility>\n\nnamespace llvm {\n\nnamespace detail {\n\n// We extend a pair to allow users to override the bucket type with their own\n// implementation without requiring two members.\ntemplate <typename KeyT, typename ValueT>\nstruct DenseMapPair : public std::pair<KeyT, ValueT> {\n  using std::pair<KeyT, ValueT>::pair;\n\n  KeyT &getFirst() { return std::pair<KeyT, ValueT>::first; }\n  const KeyT &getFirst() const { return std::pair<KeyT, ValueT>::first; }\n  ValueT &getSecond() { return std::pair<KeyT, ValueT>::second; }\n  const ValueT &getSecond() const { return std::pair<KeyT, ValueT>::second; }\n};\n\n} // end namespace detail\n\ntemplate <typename KeyT, typename ValueT,\n          typename KeyInfoT = DenseMapInfo<KeyT>,\n          typename Bucket = llvm::detail::DenseMapPair<KeyT, ValueT>,\n          bool IsConst = false>\nclass DenseMapIterator;\n\ntemplate <typename DerivedT, typename KeyT, typename ValueT, typename KeyInfoT,\n          typename BucketT>\nclass DenseMapBase : public DebugEpochBase {\n  template <typename T>\n  using const_arg_type_t = typename const_pointer_or_const_ref<T>::type;\n\npublic:\n  using size_type = unsigned;\n  using key_type = KeyT;\n  using mapped_type = ValueT;\n  using value_type = BucketT;\n\n  using iterator = DenseMapIterator<KeyT, ValueT, KeyInfoT, BucketT>;\n  using const_iterator =\n      DenseMapIterator<KeyT, ValueT, KeyInfoT, BucketT, true>;\n\n  inline iterator begin() {\n    // When the map is empty, avoid the overhead of advancing/retreating past\n    // empty buckets.\n    if (empty())\n      return end();\n    if (shouldReverseIterate<KeyT>())\n      return makeIterator(getBucketsEnd() - 1, getBuckets(), *this);\n    return makeIterator(getBuckets(), getBucketsEnd(), *this);\n  }\n  inline iterator end() {\n    return makeIterator(getBucketsEnd(), getBucketsEnd(), *this, true);\n  }\n  inline const_iterator begin() const {\n    if (empty())\n      return end();\n    if (shouldReverseIterate<KeyT>())\n      return makeConstIterator(getBucketsEnd() - 1, getBuckets(), *this);\n    return makeConstIterator(getBuckets(), getBucketsEnd(), *this);\n  }\n  inline const_iterator end() const {\n    return makeConstIterator(getBucketsEnd(), getBucketsEnd(), *this, true);\n  }\n\n  LLVM_NODISCARD bool empty() const {\n    return getNumEntries() == 0;\n  }\n  unsigned size() const { return getNumEntries(); }\n\n  /// Grow the densemap so that it can contain at least \\p NumEntries items\n  /// before resizing again.\n  void reserve(size_type NumEntries) {\n    auto NumBuckets = getMinBucketToReserveForEntries(NumEntries);\n    incrementEpoch();\n    if (NumBuckets > getNumBuckets())\n      grow(NumBuckets);\n  }\n\n  void clear() {\n    incrementEpoch();\n    if (getNumEntries() == 0 && getNumTombstones() == 0) return;\n\n    // If the capacity of the array is huge, and the # elements used is small,\n    // shrink the array.\n    if (getNumEntries() * 4 < getNumBuckets() && getNumBuckets() > 64) {\n      shrink_and_clear();\n      return;\n    }\n\n    const KeyT EmptyKey = getEmptyKey(), TombstoneKey = getTombstoneKey();\n    if (std::is_trivially_destructible<ValueT>::value) {\n      // Use a simpler loop when values don't need destruction.\n      for (BucketT *P = getBuckets(), *E = getBucketsEnd(); P != E; ++P)\n        P->getFirst() = EmptyKey;\n    } else {\n      unsigned NumEntries = getNumEntries();\n      for (BucketT *P = getBuckets(), *E = getBucketsEnd(); P != E; ++P) {\n        if (!KeyInfoT::isEqual(P->getFirst(), EmptyKey)) {\n          if (!KeyInfoT::isEqual(P->getFirst(), TombstoneKey)) {\n            P->getSecond().~ValueT();\n            --NumEntries;\n          }\n          P->getFirst() = EmptyKey;\n        }\n      }\n      assert(NumEntries == 0 && \"Node count imbalance!\");\n    }\n    setNumEntries(0);\n    setNumTombstones(0);\n  }\n\n  /// Return 1 if the specified key is in the map, 0 otherwise.\n  size_type count(const_arg_type_t<KeyT> Val) const {\n    const BucketT *TheBucket;\n    return LookupBucketFor(Val, TheBucket) ? 1 : 0;\n  }\n\n  iterator find(const_arg_type_t<KeyT> Val) {\n    BucketT *TheBucket;\n    if (LookupBucketFor(Val, TheBucket))\n      return makeIterator(TheBucket,\n                          shouldReverseIterate<KeyT>() ? getBuckets()\n                                                       : getBucketsEnd(),\n                          *this, true);\n    return end();\n  }\n  const_iterator find(const_arg_type_t<KeyT> Val) const {\n    const BucketT *TheBucket;\n    if (LookupBucketFor(Val, TheBucket))\n      return makeConstIterator(TheBucket,\n                               shouldReverseIterate<KeyT>() ? getBuckets()\n                                                            : getBucketsEnd(),\n                               *this, true);\n    return end();\n  }\n\n  /// Alternate version of find() which allows a different, and possibly\n  /// less expensive, key type.\n  /// The DenseMapInfo is responsible for supplying methods\n  /// getHashValue(LookupKeyT) and isEqual(LookupKeyT, KeyT) for each key\n  /// type used.\n  template<class LookupKeyT>\n  iterator find_as(const LookupKeyT &Val) {\n    BucketT *TheBucket;\n    if (LookupBucketFor(Val, TheBucket))\n      return makeIterator(TheBucket,\n                          shouldReverseIterate<KeyT>() ? getBuckets()\n                                                       : getBucketsEnd(),\n                          *this, true);\n    return end();\n  }\n  template<class LookupKeyT>\n  const_iterator find_as(const LookupKeyT &Val) const {\n    const BucketT *TheBucket;\n    if (LookupBucketFor(Val, TheBucket))\n      return makeConstIterator(TheBucket,\n                               shouldReverseIterate<KeyT>() ? getBuckets()\n                                                            : getBucketsEnd(),\n                               *this, true);\n    return end();\n  }\n\n  /// lookup - Return the entry for the specified key, or a default\n  /// constructed value if no such entry exists.\n  ValueT lookup(const_arg_type_t<KeyT> Val) const {\n    const BucketT *TheBucket;\n    if (LookupBucketFor(Val, TheBucket))\n      return TheBucket->getSecond();\n    return ValueT();\n  }\n\n  // Inserts key,value pair into the map if the key isn't already in the map.\n  // If the key is already in the map, it returns false and doesn't update the\n  // value.\n  std::pair<iterator, bool> insert(const std::pair<KeyT, ValueT> &KV) {\n    return try_emplace(KV.first, KV.second);\n  }\n\n  // Inserts key,value pair into the map if the key isn't already in the map.\n  // If the key is already in the map, it returns false and doesn't update the\n  // value.\n  std::pair<iterator, bool> insert(std::pair<KeyT, ValueT> &&KV) {\n    return try_emplace(std::move(KV.first), std::move(KV.second));\n  }\n\n  // Inserts key,value pair into the map if the key isn't already in the map.\n  // The value is constructed in-place if the key is not in the map, otherwise\n  // it is not moved.\n  template <typename... Ts>\n  std::pair<iterator, bool> try_emplace(KeyT &&Key, Ts &&... Args) {\n    BucketT *TheBucket;\n    if (LookupBucketFor(Key, TheBucket))\n      return std::make_pair(makeIterator(TheBucket,\n                                         shouldReverseIterate<KeyT>()\n                                             ? getBuckets()\n                                             : getBucketsEnd(),\n                                         *this, true),\n                            false); // Already in map.\n\n    // Otherwise, insert the new element.\n    TheBucket =\n        InsertIntoBucket(TheBucket, std::move(Key), std::forward<Ts>(Args)...);\n    return std::make_pair(makeIterator(TheBucket,\n                                       shouldReverseIterate<KeyT>()\n                                           ? getBuckets()\n                                           : getBucketsEnd(),\n                                       *this, true),\n                          true);\n  }\n\n  // Inserts key,value pair into the map if the key isn't already in the map.\n  // The value is constructed in-place if the key is not in the map, otherwise\n  // it is not moved.\n  template <typename... Ts>\n  std::pair<iterator, bool> try_emplace(const KeyT &Key, Ts &&... Args) {\n    BucketT *TheBucket;\n    if (LookupBucketFor(Key, TheBucket))\n      return std::make_pair(makeIterator(TheBucket,\n                                         shouldReverseIterate<KeyT>()\n                                             ? getBuckets()\n                                             : getBucketsEnd(),\n                                         *this, true),\n                            false); // Already in map.\n\n    // Otherwise, insert the new element.\n    TheBucket = InsertIntoBucket(TheBucket, Key, std::forward<Ts>(Args)...);\n    return std::make_pair(makeIterator(TheBucket,\n                                       shouldReverseIterate<KeyT>()\n                                           ? getBuckets()\n                                           : getBucketsEnd(),\n                                       *this, true),\n                          true);\n  }\n\n  /// Alternate version of insert() which allows a different, and possibly\n  /// less expensive, key type.\n  /// The DenseMapInfo is responsible for supplying methods\n  /// getHashValue(LookupKeyT) and isEqual(LookupKeyT, KeyT) for each key\n  /// type used.\n  template <typename LookupKeyT>\n  std::pair<iterator, bool> insert_as(std::pair<KeyT, ValueT> &&KV,\n                                      const LookupKeyT &Val) {\n    BucketT *TheBucket;\n    if (LookupBucketFor(Val, TheBucket))\n      return std::make_pair(makeIterator(TheBucket,\n                                         shouldReverseIterate<KeyT>()\n                                             ? getBuckets()\n                                             : getBucketsEnd(),\n                                         *this, true),\n                            false); // Already in map.\n\n    // Otherwise, insert the new element.\n    TheBucket = InsertIntoBucketWithLookup(TheBucket, std::move(KV.first),\n                                           std::move(KV.second), Val);\n    return std::make_pair(makeIterator(TheBucket,\n                                       shouldReverseIterate<KeyT>()\n                                           ? getBuckets()\n                                           : getBucketsEnd(),\n                                       *this, true),\n                          true);\n  }\n\n  /// insert - Range insertion of pairs.\n  template<typename InputIt>\n  void insert(InputIt I, InputIt E) {\n    for (; I != E; ++I)\n      insert(*I);\n  }\n\n  bool erase(const KeyT &Val) {\n    BucketT *TheBucket;\n    if (!LookupBucketFor(Val, TheBucket))\n      return false; // not in map.\n\n    TheBucket->getSecond().~ValueT();\n    TheBucket->getFirst() = getTombstoneKey();\n    decrementNumEntries();\n    incrementNumTombstones();\n    return true;\n  }\n  void erase(iterator I) {\n    BucketT *TheBucket = &*I;\n    TheBucket->getSecond().~ValueT();\n    TheBucket->getFirst() = getTombstoneKey();\n    decrementNumEntries();\n    incrementNumTombstones();\n  }\n\n  value_type& FindAndConstruct(const KeyT &Key) {\n    BucketT *TheBucket;\n    if (LookupBucketFor(Key, TheBucket))\n      return *TheBucket;\n\n    return *InsertIntoBucket(TheBucket, Key);\n  }\n\n  ValueT &operator[](const KeyT &Key) {\n    return FindAndConstruct(Key).second;\n  }\n\n  value_type& FindAndConstruct(KeyT &&Key) {\n    BucketT *TheBucket;\n    if (LookupBucketFor(Key, TheBucket))\n      return *TheBucket;\n\n    return *InsertIntoBucket(TheBucket, std::move(Key));\n  }\n\n  ValueT &operator[](KeyT &&Key) {\n    return FindAndConstruct(std::move(Key)).second;\n  }\n\n  /// isPointerIntoBucketsArray - Return true if the specified pointer points\n  /// somewhere into the DenseMap's array of buckets (i.e. either to a key or\n  /// value in the DenseMap).\n  bool isPointerIntoBucketsArray(const void *Ptr) const {\n    return Ptr >= getBuckets() && Ptr < getBucketsEnd();\n  }\n\n  /// getPointerIntoBucketsArray() - Return an opaque pointer into the buckets\n  /// array.  In conjunction with the previous method, this can be used to\n  /// determine whether an insertion caused the DenseMap to reallocate.\n  const void *getPointerIntoBucketsArray() const { return getBuckets(); }\n\nprotected:\n  DenseMapBase() = default;\n\n  void destroyAll() {\n    if (getNumBuckets() == 0) // Nothing to do.\n      return;\n\n    const KeyT EmptyKey = getEmptyKey(), TombstoneKey = getTombstoneKey();\n    for (BucketT *P = getBuckets(), *E = getBucketsEnd(); P != E; ++P) {\n      if (!KeyInfoT::isEqual(P->getFirst(), EmptyKey) &&\n          !KeyInfoT::isEqual(P->getFirst(), TombstoneKey))\n        P->getSecond().~ValueT();\n      P->getFirst().~KeyT();\n    }\n  }\n\n  void initEmpty() {\n    setNumEntries(0);\n    setNumTombstones(0);\n\n    assert((getNumBuckets() & (getNumBuckets()-1)) == 0 &&\n           \"# initial buckets must be a power of two!\");\n    const KeyT EmptyKey = getEmptyKey();\n    for (BucketT *B = getBuckets(), *E = getBucketsEnd(); B != E; ++B)\n      ::new (&B->getFirst()) KeyT(EmptyKey);\n  }\n\n  /// Returns the number of buckets to allocate to ensure that the DenseMap can\n  /// accommodate \\p NumEntries without need to grow().\n  unsigned getMinBucketToReserveForEntries(unsigned NumEntries) {\n    // Ensure that \"NumEntries * 4 < NumBuckets * 3\"\n    if (NumEntries == 0)\n      return 0;\n    // +1 is required because of the strict equality.\n    // For example if NumEntries is 48, we need to return 401.\n    return NextPowerOf2(NumEntries * 4 / 3 + 1);\n  }\n\n  void moveFromOldBuckets(BucketT *OldBucketsBegin, BucketT *OldBucketsEnd) {\n    initEmpty();\n\n    // Insert all the old elements.\n    const KeyT EmptyKey = getEmptyKey();\n    const KeyT TombstoneKey = getTombstoneKey();\n    for (BucketT *B = OldBucketsBegin, *E = OldBucketsEnd; B != E; ++B) {\n      if (!KeyInfoT::isEqual(B->getFirst(), EmptyKey) &&\n          !KeyInfoT::isEqual(B->getFirst(), TombstoneKey)) {\n        // Insert the key/value into the new table.\n        BucketT *DestBucket;\n        bool FoundVal = LookupBucketFor(B->getFirst(), DestBucket);\n        (void)FoundVal; // silence warning.\n        assert(!FoundVal && \"Key already in new map?\");\n        DestBucket->getFirst() = std::move(B->getFirst());\n        ::new (&DestBucket->getSecond()) ValueT(std::move(B->getSecond()));\n        incrementNumEntries();\n\n        // Free the value.\n        B->getSecond().~ValueT();\n      }\n      B->getFirst().~KeyT();\n    }\n  }\n\n  template <typename OtherBaseT>\n  void copyFrom(\n      const DenseMapBase<OtherBaseT, KeyT, ValueT, KeyInfoT, BucketT> &other) {\n    assert(&other != this);\n    assert(getNumBuckets() == other.getNumBuckets());\n\n    setNumEntries(other.getNumEntries());\n    setNumTombstones(other.getNumTombstones());\n\n    if (std::is_trivially_copyable<KeyT>::value &&\n        std::is_trivially_copyable<ValueT>::value)\n      memcpy(reinterpret_cast<void *>(getBuckets()), other.getBuckets(),\n             getNumBuckets() * sizeof(BucketT));\n    else\n      for (size_t i = 0; i < getNumBuckets(); ++i) {\n        ::new (&getBuckets()[i].getFirst())\n            KeyT(other.getBuckets()[i].getFirst());\n        if (!KeyInfoT::isEqual(getBuckets()[i].getFirst(), getEmptyKey()) &&\n            !KeyInfoT::isEqual(getBuckets()[i].getFirst(), getTombstoneKey()))\n          ::new (&getBuckets()[i].getSecond())\n              ValueT(other.getBuckets()[i].getSecond());\n      }\n  }\n\n  static unsigned getHashValue(const KeyT &Val) {\n    return KeyInfoT::getHashValue(Val);\n  }\n\n  template<typename LookupKeyT>\n  static unsigned getHashValue(const LookupKeyT &Val) {\n    return KeyInfoT::getHashValue(Val);\n  }\n\n  static const KeyT getEmptyKey() {\n    static_assert(std::is_base_of<DenseMapBase, DerivedT>::value,\n                  \"Must pass the derived type to this template!\");\n    return KeyInfoT::getEmptyKey();\n  }\n\n  static const KeyT getTombstoneKey() {\n    return KeyInfoT::getTombstoneKey();\n  }\n\nprivate:\n  iterator makeIterator(BucketT *P, BucketT *E,\n                        DebugEpochBase &Epoch,\n                        bool NoAdvance=false) {\n    if (shouldReverseIterate<KeyT>()) {\n      BucketT *B = P == getBucketsEnd() ? getBuckets() : P + 1;\n      return iterator(B, E, Epoch, NoAdvance);\n    }\n    return iterator(P, E, Epoch, NoAdvance);\n  }\n\n  const_iterator makeConstIterator(const BucketT *P, const BucketT *E,\n                                   const DebugEpochBase &Epoch,\n                                   const bool NoAdvance=false) const {\n    if (shouldReverseIterate<KeyT>()) {\n      const BucketT *B = P == getBucketsEnd() ? getBuckets() : P + 1;\n      return const_iterator(B, E, Epoch, NoAdvance);\n    }\n    return const_iterator(P, E, Epoch, NoAdvance);\n  }\n\n  unsigned getNumEntries() const {\n    return static_cast<const DerivedT *>(this)->getNumEntries();\n  }\n\n  void setNumEntries(unsigned Num) {\n    static_cast<DerivedT *>(this)->setNumEntries(Num);\n  }\n\n  void incrementNumEntries() {\n    setNumEntries(getNumEntries() + 1);\n  }\n\n  void decrementNumEntries() {\n    setNumEntries(getNumEntries() - 1);\n  }\n\n  unsigned getNumTombstones() const {\n    return static_cast<const DerivedT *>(this)->getNumTombstones();\n  }\n\n  void setNumTombstones(unsigned Num) {\n    static_cast<DerivedT *>(this)->setNumTombstones(Num);\n  }\n\n  void incrementNumTombstones() {\n    setNumTombstones(getNumTombstones() + 1);\n  }\n\n  void decrementNumTombstones() {\n    setNumTombstones(getNumTombstones() - 1);\n  }\n\n  const BucketT *getBuckets() const {\n    return static_cast<const DerivedT *>(this)->getBuckets();\n  }\n\n  BucketT *getBuckets() {\n    return static_cast<DerivedT *>(this)->getBuckets();\n  }\n\n  unsigned getNumBuckets() const {\n    return static_cast<const DerivedT *>(this)->getNumBuckets();\n  }\n\n  BucketT *getBucketsEnd() {\n    return getBuckets() + getNumBuckets();\n  }\n\n  const BucketT *getBucketsEnd() const {\n    return getBuckets() + getNumBuckets();\n  }\n\n  void grow(unsigned AtLeast) {\n    static_cast<DerivedT *>(this)->grow(AtLeast);\n  }\n\n  void shrink_and_clear() {\n    static_cast<DerivedT *>(this)->shrink_and_clear();\n  }\n\n  template <typename KeyArg, typename... ValueArgs>\n  BucketT *InsertIntoBucket(BucketT *TheBucket, KeyArg &&Key,\n                            ValueArgs &&... Values) {\n    TheBucket = InsertIntoBucketImpl(Key, Key, TheBucket);\n\n    TheBucket->getFirst() = std::forward<KeyArg>(Key);\n    ::new (&TheBucket->getSecond()) ValueT(std::forward<ValueArgs>(Values)...);\n    return TheBucket;\n  }\n\n  template <typename LookupKeyT>\n  BucketT *InsertIntoBucketWithLookup(BucketT *TheBucket, KeyT &&Key,\n                                      ValueT &&Value, LookupKeyT &Lookup) {\n    TheBucket = InsertIntoBucketImpl(Key, Lookup, TheBucket);\n\n    TheBucket->getFirst() = std::move(Key);\n    ::new (&TheBucket->getSecond()) ValueT(std::move(Value));\n    return TheBucket;\n  }\n\n  template <typename LookupKeyT>\n  BucketT *InsertIntoBucketImpl(const KeyT &Key, const LookupKeyT &Lookup,\n                                BucketT *TheBucket) {\n    incrementEpoch();\n\n    // If the load of the hash table is more than 3/4, or if fewer than 1/8 of\n    // the buckets are empty (meaning that many are filled with tombstones),\n    // grow the table.\n    //\n    // The later case is tricky.  For example, if we had one empty bucket with\n    // tons of tombstones, failing lookups (e.g. for insertion) would have to\n    // probe almost the entire table until it found the empty bucket.  If the\n    // table completely filled with tombstones, no lookup would ever succeed,\n    // causing infinite loops in lookup.\n    unsigned NewNumEntries = getNumEntries() + 1;\n    unsigned NumBuckets = getNumBuckets();\n    if (LLVM_UNLIKELY(NewNumEntries * 4 >= NumBuckets * 3)) {\n      this->grow(NumBuckets * 2);\n      LookupBucketFor(Lookup, TheBucket);\n      NumBuckets = getNumBuckets();\n    } else if (LLVM_UNLIKELY(NumBuckets-(NewNumEntries+getNumTombstones()) <=\n                             NumBuckets/8)) {\n      this->grow(NumBuckets);\n      LookupBucketFor(Lookup, TheBucket);\n    }\n    assert(TheBucket);\n\n    // Only update the state after we've grown our bucket space appropriately\n    // so that when growing buckets we have self-consistent entry count.\n    incrementNumEntries();\n\n    // If we are writing over a tombstone, remember this.\n    const KeyT EmptyKey = getEmptyKey();\n    if (!KeyInfoT::isEqual(TheBucket->getFirst(), EmptyKey))\n      decrementNumTombstones();\n\n    return TheBucket;\n  }\n\n  /// LookupBucketFor - Lookup the appropriate bucket for Val, returning it in\n  /// FoundBucket.  If the bucket contains the key and a value, this returns\n  /// true, otherwise it returns a bucket with an empty marker or tombstone and\n  /// returns false.\n  template<typename LookupKeyT>\n  bool LookupBucketFor(const LookupKeyT &Val,\n                       const BucketT *&FoundBucket) const {\n    const BucketT *BucketsPtr = getBuckets();\n    const unsigned NumBuckets = getNumBuckets();\n\n    if (NumBuckets == 0) {\n      FoundBucket = nullptr;\n      return false;\n    }\n\n    // FoundTombstone - Keep track of whether we find a tombstone while probing.\n    const BucketT *FoundTombstone = nullptr;\n    const KeyT EmptyKey = getEmptyKey();\n    const KeyT TombstoneKey = getTombstoneKey();\n    assert(!KeyInfoT::isEqual(Val, EmptyKey) &&\n           !KeyInfoT::isEqual(Val, TombstoneKey) &&\n           \"Empty/Tombstone value shouldn't be inserted into map!\");\n\n    unsigned BucketNo = getHashValue(Val) & (NumBuckets-1);\n    unsigned ProbeAmt = 1;\n    while (true) {\n      const BucketT *ThisBucket = BucketsPtr + BucketNo;\n      // Found Val's bucket?  If so, return it.\n      if (LLVM_LIKELY(KeyInfoT::isEqual(Val, ThisBucket->getFirst()))) {\n        FoundBucket = ThisBucket;\n        return true;\n      }\n\n      // If we found an empty bucket, the key doesn't exist in the set.\n      // Insert it and return the default value.\n      if (LLVM_LIKELY(KeyInfoT::isEqual(ThisBucket->getFirst(), EmptyKey))) {\n        // If we've already seen a tombstone while probing, fill it in instead\n        // of the empty bucket we eventually probed to.\n        FoundBucket = FoundTombstone ? FoundTombstone : ThisBucket;\n        return false;\n      }\n\n      // If this is a tombstone, remember it.  If Val ends up not in the map, we\n      // prefer to return it than something that would require more probing.\n      if (KeyInfoT::isEqual(ThisBucket->getFirst(), TombstoneKey) &&\n          !FoundTombstone)\n        FoundTombstone = ThisBucket;  // Remember the first tombstone found.\n\n      // Otherwise, it's a hash collision or a tombstone, continue quadratic\n      // probing.\n      BucketNo += ProbeAmt++;\n      BucketNo &= (NumBuckets-1);\n    }\n  }\n\n  template <typename LookupKeyT>\n  bool LookupBucketFor(const LookupKeyT &Val, BucketT *&FoundBucket) {\n    const BucketT *ConstFoundBucket;\n    bool Result = const_cast<const DenseMapBase *>(this)\n      ->LookupBucketFor(Val, ConstFoundBucket);\n    FoundBucket = const_cast<BucketT *>(ConstFoundBucket);\n    return Result;\n  }\n\npublic:\n  /// Return the approximate size (in bytes) of the actual map.\n  /// This is just the raw memory used by DenseMap.\n  /// If entries are pointers to objects, the size of the referenced objects\n  /// are not included.\n  size_t getMemorySize() const {\n    return getNumBuckets() * sizeof(BucketT);\n  }\n};\n\n/// Equality comparison for DenseMap.\n///\n/// Iterates over elements of LHS confirming that each (key, value) pair in LHS\n/// is also in RHS, and that no additional pairs are in RHS.\n/// Equivalent to N calls to RHS.find and N value comparisons. Amortized\n/// complexity is linear, worst case is O(N^2) (if every hash collides).\ntemplate <typename DerivedT, typename KeyT, typename ValueT, typename KeyInfoT,\n          typename BucketT>\nbool operator==(\n    const DenseMapBase<DerivedT, KeyT, ValueT, KeyInfoT, BucketT> &LHS,\n    const DenseMapBase<DerivedT, KeyT, ValueT, KeyInfoT, BucketT> &RHS) {\n  if (LHS.size() != RHS.size())\n    return false;\n\n  for (auto &KV : LHS) {\n    auto I = RHS.find(KV.first);\n    if (I == RHS.end() || I->second != KV.second)\n      return false;\n  }\n\n  return true;\n}\n\n/// Inequality comparison for DenseMap.\n///\n/// Equivalent to !(LHS == RHS). See operator== for performance notes.\ntemplate <typename DerivedT, typename KeyT, typename ValueT, typename KeyInfoT,\n          typename BucketT>\nbool operator!=(\n    const DenseMapBase<DerivedT, KeyT, ValueT, KeyInfoT, BucketT> &LHS,\n    const DenseMapBase<DerivedT, KeyT, ValueT, KeyInfoT, BucketT> &RHS) {\n  return !(LHS == RHS);\n}\n\ntemplate <typename KeyT, typename ValueT,\n          typename KeyInfoT = DenseMapInfo<KeyT>,\n          typename BucketT = llvm::detail::DenseMapPair<KeyT, ValueT>>\nclass DenseMap : public DenseMapBase<DenseMap<KeyT, ValueT, KeyInfoT, BucketT>,\n                                     KeyT, ValueT, KeyInfoT, BucketT> {\n  friend class DenseMapBase<DenseMap, KeyT, ValueT, KeyInfoT, BucketT>;\n\n  // Lift some types from the dependent base class into this class for\n  // simplicity of referring to them.\n  using BaseT = DenseMapBase<DenseMap, KeyT, ValueT, KeyInfoT, BucketT>;\n\n  BucketT *Buckets;\n  unsigned NumEntries;\n  unsigned NumTombstones;\n  unsigned NumBuckets;\n\npublic:\n  /// Create a DenseMap with an optional \\p InitialReserve that guarantee that\n  /// this number of elements can be inserted in the map without grow()\n  explicit DenseMap(unsigned InitialReserve = 0) { init(InitialReserve); }\n\n  DenseMap(const DenseMap &other) : BaseT() {\n    init(0);\n    copyFrom(other);\n  }\n\n  DenseMap(DenseMap &&other) : BaseT() {\n    init(0);\n    swap(other);\n  }\n\n  template<typename InputIt>\n  DenseMap(const InputIt &I, const InputIt &E) {\n    init(std::distance(I, E));\n    this->insert(I, E);\n  }\n\n  DenseMap(std::initializer_list<typename BaseT::value_type> Vals) {\n    init(Vals.size());\n    this->insert(Vals.begin(), Vals.end());\n  }\n\n  ~DenseMap() {\n    this->destroyAll();\n    deallocate_buffer(Buckets, sizeof(BucketT) * NumBuckets, alignof(BucketT));\n  }\n\n  void swap(DenseMap& RHS) {\n    this->incrementEpoch();\n    RHS.incrementEpoch();\n    std::swap(Buckets, RHS.Buckets);\n    std::swap(NumEntries, RHS.NumEntries);\n    std::swap(NumTombstones, RHS.NumTombstones);\n    std::swap(NumBuckets, RHS.NumBuckets);\n  }\n\n  DenseMap& operator=(const DenseMap& other) {\n    if (&other != this)\n      copyFrom(other);\n    return *this;\n  }\n\n  DenseMap& operator=(DenseMap &&other) {\n    this->destroyAll();\n    deallocate_buffer(Buckets, sizeof(BucketT) * NumBuckets, alignof(BucketT));\n    init(0);\n    swap(other);\n    return *this;\n  }\n\n  void copyFrom(const DenseMap& other) {\n    this->destroyAll();\n    deallocate_buffer(Buckets, sizeof(BucketT) * NumBuckets, alignof(BucketT));\n    if (allocateBuckets(other.NumBuckets)) {\n      this->BaseT::copyFrom(other);\n    } else {\n      NumEntries = 0;\n      NumTombstones = 0;\n    }\n  }\n\n  void init(unsigned InitNumEntries) {\n    auto InitBuckets = BaseT::getMinBucketToReserveForEntries(InitNumEntries);\n    if (allocateBuckets(InitBuckets)) {\n      this->BaseT::initEmpty();\n    } else {\n      NumEntries = 0;\n      NumTombstones = 0;\n    }\n  }\n\n  void grow(unsigned AtLeast) {\n    unsigned OldNumBuckets = NumBuckets;\n    BucketT *OldBuckets = Buckets;\n\n    allocateBuckets(std::max<unsigned>(64, static_cast<unsigned>(NextPowerOf2(AtLeast-1))));\n    assert(Buckets);\n    if (!OldBuckets) {\n      this->BaseT::initEmpty();\n      return;\n    }\n\n    this->moveFromOldBuckets(OldBuckets, OldBuckets+OldNumBuckets);\n\n    // Free the old table.\n    deallocate_buffer(OldBuckets, sizeof(BucketT) * OldNumBuckets,\n                      alignof(BucketT));\n  }\n\n  void shrink_and_clear() {\n    unsigned OldNumBuckets = NumBuckets;\n    unsigned OldNumEntries = NumEntries;\n    this->destroyAll();\n\n    // Reduce the number of buckets.\n    unsigned NewNumBuckets = 0;\n    if (OldNumEntries)\n      NewNumBuckets = std::max(64, 1 << (Log2_32_Ceil(OldNumEntries) + 1));\n    if (NewNumBuckets == NumBuckets) {\n      this->BaseT::initEmpty();\n      return;\n    }\n\n    deallocate_buffer(Buckets, sizeof(BucketT) * OldNumBuckets,\n                      alignof(BucketT));\n    init(NewNumBuckets);\n  }\n\nprivate:\n  unsigned getNumEntries() const {\n    return NumEntries;\n  }\n\n  void setNumEntries(unsigned Num) {\n    NumEntries = Num;\n  }\n\n  unsigned getNumTombstones() const {\n    return NumTombstones;\n  }\n\n  void setNumTombstones(unsigned Num) {\n    NumTombstones = Num;\n  }\n\n  BucketT *getBuckets() const {\n    return Buckets;\n  }\n\n  unsigned getNumBuckets() const {\n    return NumBuckets;\n  }\n\n  bool allocateBuckets(unsigned Num) {\n    NumBuckets = Num;\n    if (NumBuckets == 0) {\n      Buckets = nullptr;\n      return false;\n    }\n\n    Buckets = static_cast<BucketT *>(\n        allocate_buffer(sizeof(BucketT) * NumBuckets, alignof(BucketT)));\n    return true;\n  }\n};\n\ntemplate <typename KeyT, typename ValueT, unsigned InlineBuckets = 4,\n          typename KeyInfoT = DenseMapInfo<KeyT>,\n          typename BucketT = llvm::detail::DenseMapPair<KeyT, ValueT>>\nclass SmallDenseMap\n    : public DenseMapBase<\n          SmallDenseMap<KeyT, ValueT, InlineBuckets, KeyInfoT, BucketT>, KeyT,\n          ValueT, KeyInfoT, BucketT> {\n  friend class DenseMapBase<SmallDenseMap, KeyT, ValueT, KeyInfoT, BucketT>;\n\n  // Lift some types from the dependent base class into this class for\n  // simplicity of referring to them.\n  using BaseT = DenseMapBase<SmallDenseMap, KeyT, ValueT, KeyInfoT, BucketT>;\n\n  static_assert(isPowerOf2_64(InlineBuckets),\n                \"InlineBuckets must be a power of 2.\");\n\n  unsigned Small : 1;\n  unsigned NumEntries : 31;\n  unsigned NumTombstones;\n\n  struct LargeRep {\n    BucketT *Buckets;\n    unsigned NumBuckets;\n  };\n\n  /// A \"union\" of an inline bucket array and the struct representing\n  /// a large bucket. This union will be discriminated by the 'Small' bit.\n  AlignedCharArrayUnion<BucketT[InlineBuckets], LargeRep> storage;\n\npublic:\n  explicit SmallDenseMap(unsigned NumInitBuckets = 0) {\n    init(NumInitBuckets);\n  }\n\n  SmallDenseMap(const SmallDenseMap &other) : BaseT() {\n    init(0);\n    copyFrom(other);\n  }\n\n  SmallDenseMap(SmallDenseMap &&other) : BaseT() {\n    init(0);\n    swap(other);\n  }\n\n  template<typename InputIt>\n  SmallDenseMap(const InputIt &I, const InputIt &E) {\n    init(NextPowerOf2(std::distance(I, E)));\n    this->insert(I, E);\n  }\n\n  ~SmallDenseMap() {\n    this->destroyAll();\n    deallocateBuckets();\n  }\n\n  void swap(SmallDenseMap& RHS) {\n    unsigned TmpNumEntries = RHS.NumEntries;\n    RHS.NumEntries = NumEntries;\n    NumEntries = TmpNumEntries;\n    std::swap(NumTombstones, RHS.NumTombstones);\n\n    const KeyT EmptyKey = this->getEmptyKey();\n    const KeyT TombstoneKey = this->getTombstoneKey();\n    if (Small && RHS.Small) {\n      // If we're swapping inline bucket arrays, we have to cope with some of\n      // the tricky bits of DenseMap's storage system: the buckets are not\n      // fully initialized. Thus we swap every key, but we may have\n      // a one-directional move of the value.\n      for (unsigned i = 0, e = InlineBuckets; i != e; ++i) {\n        BucketT *LHSB = &getInlineBuckets()[i],\n                *RHSB = &RHS.getInlineBuckets()[i];\n        bool hasLHSValue = (!KeyInfoT::isEqual(LHSB->getFirst(), EmptyKey) &&\n                            !KeyInfoT::isEqual(LHSB->getFirst(), TombstoneKey));\n        bool hasRHSValue = (!KeyInfoT::isEqual(RHSB->getFirst(), EmptyKey) &&\n                            !KeyInfoT::isEqual(RHSB->getFirst(), TombstoneKey));\n        if (hasLHSValue && hasRHSValue) {\n          // Swap together if we can...\n          std::swap(*LHSB, *RHSB);\n          continue;\n        }\n        // Swap separately and handle any asymmetry.\n        std::swap(LHSB->getFirst(), RHSB->getFirst());\n        if (hasLHSValue) {\n          ::new (&RHSB->getSecond()) ValueT(std::move(LHSB->getSecond()));\n          LHSB->getSecond().~ValueT();\n        } else if (hasRHSValue) {\n          ::new (&LHSB->getSecond()) ValueT(std::move(RHSB->getSecond()));\n          RHSB->getSecond().~ValueT();\n        }\n      }\n      return;\n    }\n    if (!Small && !RHS.Small) {\n      std::swap(getLargeRep()->Buckets, RHS.getLargeRep()->Buckets);\n      std::swap(getLargeRep()->NumBuckets, RHS.getLargeRep()->NumBuckets);\n      return;\n    }\n\n    SmallDenseMap &SmallSide = Small ? *this : RHS;\n    SmallDenseMap &LargeSide = Small ? RHS : *this;\n\n    // First stash the large side's rep and move the small side across.\n    LargeRep TmpRep = std::move(*LargeSide.getLargeRep());\n    LargeSide.getLargeRep()->~LargeRep();\n    LargeSide.Small = true;\n    // This is similar to the standard move-from-old-buckets, but the bucket\n    // count hasn't actually rotated in this case. So we have to carefully\n    // move construct the keys and values into their new locations, but there\n    // is no need to re-hash things.\n    for (unsigned i = 0, e = InlineBuckets; i != e; ++i) {\n      BucketT *NewB = &LargeSide.getInlineBuckets()[i],\n              *OldB = &SmallSide.getInlineBuckets()[i];\n      ::new (&NewB->getFirst()) KeyT(std::move(OldB->getFirst()));\n      OldB->getFirst().~KeyT();\n      if (!KeyInfoT::isEqual(NewB->getFirst(), EmptyKey) &&\n          !KeyInfoT::isEqual(NewB->getFirst(), TombstoneKey)) {\n        ::new (&NewB->getSecond()) ValueT(std::move(OldB->getSecond()));\n        OldB->getSecond().~ValueT();\n      }\n    }\n\n    // The hard part of moving the small buckets across is done, just move\n    // the TmpRep into its new home.\n    SmallSide.Small = false;\n    new (SmallSide.getLargeRep()) LargeRep(std::move(TmpRep));\n  }\n\n  SmallDenseMap& operator=(const SmallDenseMap& other) {\n    if (&other != this)\n      copyFrom(other);\n    return *this;\n  }\n\n  SmallDenseMap& operator=(SmallDenseMap &&other) {\n    this->destroyAll();\n    deallocateBuckets();\n    init(0);\n    swap(other);\n    return *this;\n  }\n\n  void copyFrom(const SmallDenseMap& other) {\n    this->destroyAll();\n    deallocateBuckets();\n    Small = true;\n    if (other.getNumBuckets() > InlineBuckets) {\n      Small = false;\n      new (getLargeRep()) LargeRep(allocateBuckets(other.getNumBuckets()));\n    }\n    this->BaseT::copyFrom(other);\n  }\n\n  void init(unsigned InitBuckets) {\n    Small = true;\n    if (InitBuckets > InlineBuckets) {\n      Small = false;\n      new (getLargeRep()) LargeRep(allocateBuckets(InitBuckets));\n    }\n    this->BaseT::initEmpty();\n  }\n\n  void grow(unsigned AtLeast) {\n    if (AtLeast > InlineBuckets)\n      AtLeast = std::max<unsigned>(64, NextPowerOf2(AtLeast-1));\n\n    if (Small) {\n      // First move the inline buckets into a temporary storage.\n      AlignedCharArrayUnion<BucketT[InlineBuckets]> TmpStorage;\n      BucketT *TmpBegin = reinterpret_cast<BucketT *>(&TmpStorage);\n      BucketT *TmpEnd = TmpBegin;\n\n      // Loop over the buckets, moving non-empty, non-tombstones into the\n      // temporary storage. Have the loop move the TmpEnd forward as it goes.\n      const KeyT EmptyKey = this->getEmptyKey();\n      const KeyT TombstoneKey = this->getTombstoneKey();\n      for (BucketT *P = getBuckets(), *E = P + InlineBuckets; P != E; ++P) {\n        if (!KeyInfoT::isEqual(P->getFirst(), EmptyKey) &&\n            !KeyInfoT::isEqual(P->getFirst(), TombstoneKey)) {\n          assert(size_t(TmpEnd - TmpBegin) < InlineBuckets &&\n                 \"Too many inline buckets!\");\n          ::new (&TmpEnd->getFirst()) KeyT(std::move(P->getFirst()));\n          ::new (&TmpEnd->getSecond()) ValueT(std::move(P->getSecond()));\n          ++TmpEnd;\n          P->getSecond().~ValueT();\n        }\n        P->getFirst().~KeyT();\n      }\n\n      // AtLeast == InlineBuckets can happen if there are many tombstones,\n      // and grow() is used to remove them. Usually we always switch to the\n      // large rep here.\n      if (AtLeast > InlineBuckets) {\n        Small = false;\n        new (getLargeRep()) LargeRep(allocateBuckets(AtLeast));\n      }\n      this->moveFromOldBuckets(TmpBegin, TmpEnd);\n      return;\n    }\n\n    LargeRep OldRep = std::move(*getLargeRep());\n    getLargeRep()->~LargeRep();\n    if (AtLeast <= InlineBuckets) {\n      Small = true;\n    } else {\n      new (getLargeRep()) LargeRep(allocateBuckets(AtLeast));\n    }\n\n    this->moveFromOldBuckets(OldRep.Buckets, OldRep.Buckets+OldRep.NumBuckets);\n\n    // Free the old table.\n    deallocate_buffer(OldRep.Buckets, sizeof(BucketT) * OldRep.NumBuckets,\n                      alignof(BucketT));\n  }\n\n  void shrink_and_clear() {\n    unsigned OldSize = this->size();\n    this->destroyAll();\n\n    // Reduce the number of buckets.\n    unsigned NewNumBuckets = 0;\n    if (OldSize) {\n      NewNumBuckets = 1 << (Log2_32_Ceil(OldSize) + 1);\n      if (NewNumBuckets > InlineBuckets && NewNumBuckets < 64u)\n        NewNumBuckets = 64;\n    }\n    if ((Small && NewNumBuckets <= InlineBuckets) ||\n        (!Small && NewNumBuckets == getLargeRep()->NumBuckets)) {\n      this->BaseT::initEmpty();\n      return;\n    }\n\n    deallocateBuckets();\n    init(NewNumBuckets);\n  }\n\nprivate:\n  unsigned getNumEntries() const {\n    return NumEntries;\n  }\n\n  void setNumEntries(unsigned Num) {\n    // NumEntries is hardcoded to be 31 bits wide.\n    assert(Num < (1U << 31) && \"Cannot support more than 1<<31 entries\");\n    NumEntries = Num;\n  }\n\n  unsigned getNumTombstones() const {\n    return NumTombstones;\n  }\n\n  void setNumTombstones(unsigned Num) {\n    NumTombstones = Num;\n  }\n\n  const BucketT *getInlineBuckets() const {\n    assert(Small);\n    // Note that this cast does not violate aliasing rules as we assert that\n    // the memory's dynamic type is the small, inline bucket buffer, and the\n    // 'storage' is a POD containing a char buffer.\n    return reinterpret_cast<const BucketT *>(&storage);\n  }\n\n  BucketT *getInlineBuckets() {\n    return const_cast<BucketT *>(\n      const_cast<const SmallDenseMap *>(this)->getInlineBuckets());\n  }\n\n  const LargeRep *getLargeRep() const {\n    assert(!Small);\n    // Note, same rule about aliasing as with getInlineBuckets.\n    return reinterpret_cast<const LargeRep *>(&storage);\n  }\n\n  LargeRep *getLargeRep() {\n    return const_cast<LargeRep *>(\n      const_cast<const SmallDenseMap *>(this)->getLargeRep());\n  }\n\n  const BucketT *getBuckets() const {\n    return Small ? getInlineBuckets() : getLargeRep()->Buckets;\n  }\n\n  BucketT *getBuckets() {\n    return const_cast<BucketT *>(\n      const_cast<const SmallDenseMap *>(this)->getBuckets());\n  }\n\n  unsigned getNumBuckets() const {\n    return Small ? InlineBuckets : getLargeRep()->NumBuckets;\n  }\n\n  void deallocateBuckets() {\n    if (Small)\n      return;\n\n    deallocate_buffer(getLargeRep()->Buckets,\n                      sizeof(BucketT) * getLargeRep()->NumBuckets,\n                      alignof(BucketT));\n    getLargeRep()->~LargeRep();\n  }\n\n  LargeRep allocateBuckets(unsigned Num) {\n    assert(Num > InlineBuckets && \"Must allocate more buckets than are inline\");\n    LargeRep Rep = {static_cast<BucketT *>(allocate_buffer(\n                        sizeof(BucketT) * Num, alignof(BucketT))),\n                    Num};\n    return Rep;\n  }\n};\n\ntemplate <typename KeyT, typename ValueT, typename KeyInfoT, typename Bucket,\n          bool IsConst>\nclass DenseMapIterator : DebugEpochBase::HandleBase {\n  friend class DenseMapIterator<KeyT, ValueT, KeyInfoT, Bucket, true>;\n  friend class DenseMapIterator<KeyT, ValueT, KeyInfoT, Bucket, false>;\n\npublic:\n  using difference_type = ptrdiff_t;\n  using value_type =\n      typename std::conditional<IsConst, const Bucket, Bucket>::type;\n  using pointer = value_type *;\n  using reference = value_type &;\n  using iterator_category = std::forward_iterator_tag;\n\nprivate:\n  pointer Ptr = nullptr;\n  pointer End = nullptr;\n\npublic:\n  DenseMapIterator() = default;\n\n  DenseMapIterator(pointer Pos, pointer E, const DebugEpochBase &Epoch,\n                   bool NoAdvance = false)\n      : DebugEpochBase::HandleBase(&Epoch), Ptr(Pos), End(E) {\n    assert(isHandleInSync() && \"invalid construction!\");\n\n    if (NoAdvance) return;\n    if (shouldReverseIterate<KeyT>()) {\n      RetreatPastEmptyBuckets();\n      return;\n    }\n    AdvancePastEmptyBuckets();\n  }\n\n  // Converting ctor from non-const iterators to const iterators. SFINAE'd out\n  // for const iterator destinations so it doesn't end up as a user defined copy\n  // constructor.\n  template <bool IsConstSrc,\n            typename = std::enable_if_t<!IsConstSrc && IsConst>>\n  DenseMapIterator(\n      const DenseMapIterator<KeyT, ValueT, KeyInfoT, Bucket, IsConstSrc> &I)\n      : DebugEpochBase::HandleBase(I), Ptr(I.Ptr), End(I.End) {}\n\n  reference operator*() const {\n    assert(isHandleInSync() && \"invalid iterator access!\");\n    assert(Ptr != End && \"dereferencing end() iterator\");\n    if (shouldReverseIterate<KeyT>())\n      return Ptr[-1];\n    return *Ptr;\n  }\n  pointer operator->() const {\n    assert(isHandleInSync() && \"invalid iterator access!\");\n    assert(Ptr != End && \"dereferencing end() iterator\");\n    if (shouldReverseIterate<KeyT>())\n      return &(Ptr[-1]);\n    return Ptr;\n  }\n\n  friend bool operator==(const DenseMapIterator &LHS,\n                         const DenseMapIterator &RHS) {\n    assert((!LHS.Ptr || LHS.isHandleInSync()) && \"handle not in sync!\");\n    assert((!RHS.Ptr || RHS.isHandleInSync()) && \"handle not in sync!\");\n    assert(LHS.getEpochAddress() == RHS.getEpochAddress() &&\n           \"comparing incomparable iterators!\");\n    return LHS.Ptr == RHS.Ptr;\n  }\n\n  friend bool operator!=(const DenseMapIterator &LHS,\n                         const DenseMapIterator &RHS) {\n    return !(LHS == RHS);\n  }\n\n  inline DenseMapIterator& operator++() {  // Preincrement\n    assert(isHandleInSync() && \"invalid iterator access!\");\n    assert(Ptr != End && \"incrementing end() iterator\");\n    if (shouldReverseIterate<KeyT>()) {\n      --Ptr;\n      RetreatPastEmptyBuckets();\n      return *this;\n    }\n    ++Ptr;\n    AdvancePastEmptyBuckets();\n    return *this;\n  }\n  DenseMapIterator operator++(int) {  // Postincrement\n    assert(isHandleInSync() && \"invalid iterator access!\");\n    DenseMapIterator tmp = *this; ++*this; return tmp;\n  }\n\nprivate:\n  void AdvancePastEmptyBuckets() {\n    assert(Ptr <= End);\n    const KeyT Empty = KeyInfoT::getEmptyKey();\n    const KeyT Tombstone = KeyInfoT::getTombstoneKey();\n\n    while (Ptr != End && (KeyInfoT::isEqual(Ptr->getFirst(), Empty) ||\n                          KeyInfoT::isEqual(Ptr->getFirst(), Tombstone)))\n      ++Ptr;\n  }\n\n  void RetreatPastEmptyBuckets() {\n    assert(Ptr >= End);\n    const KeyT Empty = KeyInfoT::getEmptyKey();\n    const KeyT Tombstone = KeyInfoT::getTombstoneKey();\n\n    while (Ptr != End && (KeyInfoT::isEqual(Ptr[-1].getFirst(), Empty) ||\n                          KeyInfoT::isEqual(Ptr[-1].getFirst(), Tombstone)))\n      --Ptr;\n  }\n};\n\ntemplate <typename KeyT, typename ValueT, typename KeyInfoT>\ninline size_t capacity_in_bytes(const DenseMap<KeyT, ValueT, KeyInfoT> &X) {\n  return X.getMemorySize();\n}\n\n} // end namespace llvm\n\n#endif // LLVM_ADT_DENSEMAP_H\n"}, "58": {"id": 58, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/STLExtras.h", "content": "//===- llvm/ADT/STLExtras.h - Useful STL related functions ------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// This file contains some templates that are useful if you are working with the\n// STL at all.\n//\n// No library is required when using these functions.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_ADT_STLEXTRAS_H\n#define LLVM_ADT_STLEXTRAS_H\n\n#include \"llvm/ADT/Optional.h\"\n#include \"llvm/ADT/iterator.h\"\n#include \"llvm/ADT/iterator_range.h\"\n#include \"llvm/Config/abi-breaking.h\"\n#include \"llvm/Support/ErrorHandling.h\"\n#include <algorithm>\n#include <cassert>\n#include <cstddef>\n#include <cstdint>\n#include <cstdlib>\n#include <functional>\n#include <initializer_list>\n#include <iterator>\n#include <limits>\n#include <memory>\n#include <tuple>\n#include <type_traits>\n#include <utility>\n\n#ifdef EXPENSIVE_CHECKS\n#include <random> // for std::mt19937\n#endif\n\nnamespace llvm {\n\n// Only used by compiler if both template types are the same.  Useful when\n// using SFINAE to test for the existence of member functions.\ntemplate <typename T, T> struct SameType;\n\nnamespace detail {\n\ntemplate <typename RangeT>\nusing IterOfRange = decltype(std::begin(std::declval<RangeT &>()));\n\ntemplate <typename RangeT>\nusing ValueOfRange = typename std::remove_reference<decltype(\n    *std::begin(std::declval<RangeT &>()))>::type;\n\n} // end namespace detail\n\n//===----------------------------------------------------------------------===//\n//     Extra additions to <type_traits>\n//===----------------------------------------------------------------------===//\n\ntemplate <typename T>\nstruct negation : std::integral_constant<bool, !bool(T::value)> {};\n\ntemplate <typename...> struct conjunction : std::true_type {};\ntemplate <typename B1> struct conjunction<B1> : B1 {};\ntemplate <typename B1, typename... Bn>\nstruct conjunction<B1, Bn...>\n    : std::conditional<bool(B1::value), conjunction<Bn...>, B1>::type {};\n\ntemplate <typename T> struct make_const_ptr {\n  using type =\n      typename std::add_pointer<typename std::add_const<T>::type>::type;\n};\n\ntemplate <typename T> struct make_const_ref {\n  using type = typename std::add_lvalue_reference<\n      typename std::add_const<T>::type>::type;\n};\n\n/// Utilities for detecting if a given trait holds for some set of arguments\n/// 'Args'. For example, the given trait could be used to detect if a given type\n/// has a copy assignment operator:\n///   template<class T>\n///   using has_copy_assign_t = decltype(std::declval<T&>()\n///                                                 = std::declval<const T&>());\n///   bool fooHasCopyAssign = is_detected<has_copy_assign_t, FooClass>::value;\nnamespace detail {\ntemplate <typename...> using void_t = void;\ntemplate <class, template <class...> class Op, class... Args> struct detector {\n  using value_t = std::false_type;\n};\ntemplate <template <class...> class Op, class... Args>\nstruct detector<void_t<Op<Args...>>, Op, Args...> {\n  using value_t = std::true_type;\n};\n} // end namespace detail\n\ntemplate <template <class...> class Op, class... Args>\nusing is_detected = typename detail::detector<void, Op, Args...>::value_t;\n\n/// Check if a Callable type can be invoked with the given set of arg types.\nnamespace detail {\ntemplate <typename Callable, typename... Args>\nusing is_invocable =\n    decltype(std::declval<Callable &>()(std::declval<Args>()...));\n} // namespace detail\n\ntemplate <typename Callable, typename... Args>\nusing is_invocable = is_detected<detail::is_invocable, Callable, Args...>;\n\n/// This class provides various trait information about a callable object.\n///   * To access the number of arguments: Traits::num_args\n///   * To access the type of an argument: Traits::arg_t<Index>\n///   * To access the type of the result:  Traits::result_t\ntemplate <typename T, bool isClass = std::is_class<T>::value>\nstruct function_traits : public function_traits<decltype(&T::operator())> {};\n\n/// Overload for class function types.\ntemplate <typename ClassType, typename ReturnType, typename... Args>\nstruct function_traits<ReturnType (ClassType::*)(Args...) const, false> {\n  /// The number of arguments to this function.\n  enum { num_args = sizeof...(Args) };\n\n  /// The result type of this function.\n  using result_t = ReturnType;\n\n  /// The type of an argument to this function.\n  template <size_t Index>\n  using arg_t = typename std::tuple_element<Index, std::tuple<Args...>>::type;\n};\n/// Overload for class function types.\ntemplate <typename ClassType, typename ReturnType, typename... Args>\nstruct function_traits<ReturnType (ClassType::*)(Args...), false>\n    : function_traits<ReturnType (ClassType::*)(Args...) const> {};\n/// Overload for non-class function types.\ntemplate <typename ReturnType, typename... Args>\nstruct function_traits<ReturnType (*)(Args...), false> {\n  /// The number of arguments to this function.\n  enum { num_args = sizeof...(Args) };\n\n  /// The result type of this function.\n  using result_t = ReturnType;\n\n  /// The type of an argument to this function.\n  template <size_t i>\n  using arg_t = typename std::tuple_element<i, std::tuple<Args...>>::type;\n};\n/// Overload for non-class function type references.\ntemplate <typename ReturnType, typename... Args>\nstruct function_traits<ReturnType (&)(Args...), false>\n    : public function_traits<ReturnType (*)(Args...)> {};\n\n//===----------------------------------------------------------------------===//\n//     Extra additions to <functional>\n//===----------------------------------------------------------------------===//\n\ntemplate <class Ty> struct identity {\n  using argument_type = Ty;\n\n  Ty &operator()(Ty &self) const {\n    return self;\n  }\n  const Ty &operator()(const Ty &self) const {\n    return self;\n  }\n};\n\n/// An efficient, type-erasing, non-owning reference to a callable. This is\n/// intended for use as the type of a function parameter that is not used\n/// after the function in question returns.\n///\n/// This class does not own the callable, so it is not in general safe to store\n/// a function_ref.\ntemplate<typename Fn> class function_ref;\n\ntemplate<typename Ret, typename ...Params>\nclass function_ref<Ret(Params...)> {\n  Ret (*callback)(intptr_t callable, Params ...params) = nullptr;\n  intptr_t callable;\n\n  template<typename Callable>\n  static Ret callback_fn(intptr_t callable, Params ...params) {\n    return (*reinterpret_cast<Callable*>(callable))(\n        std::forward<Params>(params)...);\n  }\n\npublic:\n  function_ref() = default;\n  function_ref(std::nullptr_t) {}\n\n  template <typename Callable>\n  function_ref(\n      Callable &&callable,\n      // This is not the copy-constructor.\n      std::enable_if_t<\n          !std::is_same<std::remove_cv_t<std::remove_reference_t<Callable>>,\n                        function_ref>::value> * = nullptr,\n      // Functor must be callable and return a suitable type.\n      std::enable_if_t<std::is_void<Ret>::value ||\n                       std::is_convertible<decltype(std::declval<Callable>()(\n                                               std::declval<Params>()...)),\n                                           Ret>::value> * = nullptr)\n      : callback(callback_fn<typename std::remove_reference<Callable>::type>),\n        callable(reinterpret_cast<intptr_t>(&callable)) {}\n\n  Ret operator()(Params ...params) const {\n    return callback(callable, std::forward<Params>(params)...);\n  }\n\n  explicit operator bool() const { return callback; }\n};\n\n//===----------------------------------------------------------------------===//\n//     Extra additions to <iterator>\n//===----------------------------------------------------------------------===//\n\nnamespace adl_detail {\n\nusing std::begin;\n\ntemplate <typename ContainerTy>\ndecltype(auto) adl_begin(ContainerTy &&container) {\n  return begin(std::forward<ContainerTy>(container));\n}\n\nusing std::end;\n\ntemplate <typename ContainerTy>\ndecltype(auto) adl_end(ContainerTy &&container) {\n  return end(std::forward<ContainerTy>(container));\n}\n\nusing std::swap;\n\ntemplate <typename T>\nvoid adl_swap(T &&lhs, T &&rhs) noexcept(noexcept(swap(std::declval<T>(),\n                                                       std::declval<T>()))) {\n  swap(std::forward<T>(lhs), std::forward<T>(rhs));\n}\n\n} // end namespace adl_detail\n\ntemplate <typename ContainerTy>\ndecltype(auto) adl_begin(ContainerTy &&container) {\n  return adl_detail::adl_begin(std::forward<ContainerTy>(container));\n}\n\ntemplate <typename ContainerTy>\ndecltype(auto) adl_end(ContainerTy &&container) {\n  return adl_detail::adl_end(std::forward<ContainerTy>(container));\n}\n\ntemplate <typename T>\nvoid adl_swap(T &&lhs, T &&rhs) noexcept(\n    noexcept(adl_detail::adl_swap(std::declval<T>(), std::declval<T>()))) {\n  adl_detail::adl_swap(std::forward<T>(lhs), std::forward<T>(rhs));\n}\n\n/// Test whether \\p RangeOrContainer is empty. Similar to C++17 std::empty.\ntemplate <typename T>\nconstexpr bool empty(const T &RangeOrContainer) {\n  return adl_begin(RangeOrContainer) == adl_end(RangeOrContainer);\n}\n\n/// Returns true if the given container only contains a single element.\ntemplate <typename ContainerTy> bool hasSingleElement(ContainerTy &&C) {\n  auto B = std::begin(C), E = std::end(C);\n  return B != E && std::next(B) == E;\n}\n\n/// Return a range covering \\p RangeOrContainer with the first N elements\n/// excluded.\ntemplate <typename T> auto drop_begin(T &&RangeOrContainer, size_t N = 1) {\n  return make_range(std::next(adl_begin(RangeOrContainer), N),\n                    adl_end(RangeOrContainer));\n}\n\n// mapped_iterator - This is a simple iterator adapter that causes a function to\n// be applied whenever operator* is invoked on the iterator.\n\ntemplate <typename ItTy, typename FuncTy,\n          typename FuncReturnTy =\n            decltype(std::declval<FuncTy>()(*std::declval<ItTy>()))>\nclass mapped_iterator\n    : public iterator_adaptor_base<\n             mapped_iterator<ItTy, FuncTy>, ItTy,\n             typename std::iterator_traits<ItTy>::iterator_category,\n             typename std::remove_reference<FuncReturnTy>::type> {\npublic:\n  mapped_iterator(ItTy U, FuncTy F)\n    : mapped_iterator::iterator_adaptor_base(std::move(U)), F(std::move(F)) {}\n\n  ItTy getCurrent() { return this->I; }\n\n  FuncReturnTy operator*() const { return F(*this->I); }\n\nprivate:\n  FuncTy F;\n};\n\n// map_iterator - Provide a convenient way to create mapped_iterators, just like\n// make_pair is useful for creating pairs...\ntemplate <class ItTy, class FuncTy>\ninline mapped_iterator<ItTy, FuncTy> map_iterator(ItTy I, FuncTy F) {\n  return mapped_iterator<ItTy, FuncTy>(std::move(I), std::move(F));\n}\n\ntemplate <class ContainerTy, class FuncTy>\nauto map_range(ContainerTy &&C, FuncTy F) {\n  return make_range(map_iterator(C.begin(), F), map_iterator(C.end(), F));\n}\n\n/// Helper to determine if type T has a member called rbegin().\ntemplate <typename Ty> class has_rbegin_impl {\n  using yes = char[1];\n  using no = char[2];\n\n  template <typename Inner>\n  static yes& test(Inner *I, decltype(I->rbegin()) * = nullptr);\n\n  template <typename>\n  static no& test(...);\n\npublic:\n  static const bool value = sizeof(test<Ty>(nullptr)) == sizeof(yes);\n};\n\n/// Metafunction to determine if T& or T has a member called rbegin().\ntemplate <typename Ty>\nstruct has_rbegin : has_rbegin_impl<typename std::remove_reference<Ty>::type> {\n};\n\n// Returns an iterator_range over the given container which iterates in reverse.\n// Note that the container must have rbegin()/rend() methods for this to work.\ntemplate <typename ContainerTy>\nauto reverse(ContainerTy &&C,\n             std::enable_if_t<has_rbegin<ContainerTy>::value> * = nullptr) {\n  return make_range(C.rbegin(), C.rend());\n}\n\n// Returns a std::reverse_iterator wrapped around the given iterator.\ntemplate <typename IteratorTy>\nstd::reverse_iterator<IteratorTy> make_reverse_iterator(IteratorTy It) {\n  return std::reverse_iterator<IteratorTy>(It);\n}\n\n// Returns an iterator_range over the given container which iterates in reverse.\n// Note that the container must have begin()/end() methods which return\n// bidirectional iterators for this to work.\ntemplate <typename ContainerTy>\nauto reverse(ContainerTy &&C,\n             std::enable_if_t<!has_rbegin<ContainerTy>::value> * = nullptr) {\n  return make_range(llvm::make_reverse_iterator(std::end(C)),\n                    llvm::make_reverse_iterator(std::begin(C)));\n}\n\n/// An iterator adaptor that filters the elements of given inner iterators.\n///\n/// The predicate parameter should be a callable object that accepts the wrapped\n/// iterator's reference type and returns a bool. When incrementing or\n/// decrementing the iterator, it will call the predicate on each element and\n/// skip any where it returns false.\n///\n/// \\code\n///   int A[] = { 1, 2, 3, 4 };\n///   auto R = make_filter_range(A, [](int N) { return N % 2 == 1; });\n///   // R contains { 1, 3 }.\n/// \\endcode\n///\n/// Note: filter_iterator_base implements support for forward iteration.\n/// filter_iterator_impl exists to provide support for bidirectional iteration,\n/// conditional on whether the wrapped iterator supports it.\ntemplate <typename WrappedIteratorT, typename PredicateT, typename IterTag>\nclass filter_iterator_base\n    : public iterator_adaptor_base<\n          filter_iterator_base<WrappedIteratorT, PredicateT, IterTag>,\n          WrappedIteratorT,\n          typename std::common_type<\n              IterTag, typename std::iterator_traits<\n                           WrappedIteratorT>::iterator_category>::type> {\n  using BaseT = iterator_adaptor_base<\n      filter_iterator_base<WrappedIteratorT, PredicateT, IterTag>,\n      WrappedIteratorT,\n      typename std::common_type<\n          IterTag, typename std::iterator_traits<\n                       WrappedIteratorT>::iterator_category>::type>;\n\nprotected:\n  WrappedIteratorT End;\n  PredicateT Pred;\n\n  void findNextValid() {\n    while (this->I != End && !Pred(*this->I))\n      BaseT::operator++();\n  }\n\n  // Construct the iterator. The begin iterator needs to know where the end\n  // is, so that it can properly stop when it gets there. The end iterator only\n  // needs the predicate to support bidirectional iteration.\n  filter_iterator_base(WrappedIteratorT Begin, WrappedIteratorT End,\n                       PredicateT Pred)\n      : BaseT(Begin), End(End), Pred(Pred) {\n    findNextValid();\n  }\n\npublic:\n  using BaseT::operator++;\n\n  filter_iterator_base &operator++() {\n    BaseT::operator++();\n    findNextValid();\n    return *this;\n  }\n};\n\n/// Specialization of filter_iterator_base for forward iteration only.\ntemplate <typename WrappedIteratorT, typename PredicateT,\n          typename IterTag = std::forward_iterator_tag>\nclass filter_iterator_impl\n    : public filter_iterator_base<WrappedIteratorT, PredicateT, IterTag> {\n  using BaseT = filter_iterator_base<WrappedIteratorT, PredicateT, IterTag>;\n\npublic:\n  filter_iterator_impl(WrappedIteratorT Begin, WrappedIteratorT End,\n                       PredicateT Pred)\n      : BaseT(Begin, End, Pred) {}\n};\n\n/// Specialization of filter_iterator_base for bidirectional iteration.\ntemplate <typename WrappedIteratorT, typename PredicateT>\nclass filter_iterator_impl<WrappedIteratorT, PredicateT,\n                           std::bidirectional_iterator_tag>\n    : public filter_iterator_base<WrappedIteratorT, PredicateT,\n                                  std::bidirectional_iterator_tag> {\n  using BaseT = filter_iterator_base<WrappedIteratorT, PredicateT,\n                                     std::bidirectional_iterator_tag>;\n  void findPrevValid() {\n    while (!this->Pred(*this->I))\n      BaseT::operator--();\n  }\n\npublic:\n  using BaseT::operator--;\n\n  filter_iterator_impl(WrappedIteratorT Begin, WrappedIteratorT End,\n                       PredicateT Pred)\n      : BaseT(Begin, End, Pred) {}\n\n  filter_iterator_impl &operator--() {\n    BaseT::operator--();\n    findPrevValid();\n    return *this;\n  }\n};\n\nnamespace detail {\n\ntemplate <bool is_bidirectional> struct fwd_or_bidi_tag_impl {\n  using type = std::forward_iterator_tag;\n};\n\ntemplate <> struct fwd_or_bidi_tag_impl<true> {\n  using type = std::bidirectional_iterator_tag;\n};\n\n/// Helper which sets its type member to forward_iterator_tag if the category\n/// of \\p IterT does not derive from bidirectional_iterator_tag, and to\n/// bidirectional_iterator_tag otherwise.\ntemplate <typename IterT> struct fwd_or_bidi_tag {\n  using type = typename fwd_or_bidi_tag_impl<std::is_base_of<\n      std::bidirectional_iterator_tag,\n      typename std::iterator_traits<IterT>::iterator_category>::value>::type;\n};\n\n} // namespace detail\n\n/// Defines filter_iterator to a suitable specialization of\n/// filter_iterator_impl, based on the underlying iterator's category.\ntemplate <typename WrappedIteratorT, typename PredicateT>\nusing filter_iterator = filter_iterator_impl<\n    WrappedIteratorT, PredicateT,\n    typename detail::fwd_or_bidi_tag<WrappedIteratorT>::type>;\n\n/// Convenience function that takes a range of elements and a predicate,\n/// and return a new filter_iterator range.\n///\n/// FIXME: Currently if RangeT && is a rvalue reference to a temporary, the\n/// lifetime of that temporary is not kept by the returned range object, and the\n/// temporary is going to be dropped on the floor after the make_iterator_range\n/// full expression that contains this function call.\ntemplate <typename RangeT, typename PredicateT>\niterator_range<filter_iterator<detail::IterOfRange<RangeT>, PredicateT>>\nmake_filter_range(RangeT &&Range, PredicateT Pred) {\n  using FilterIteratorT =\n      filter_iterator<detail::IterOfRange<RangeT>, PredicateT>;\n  return make_range(\n      FilterIteratorT(std::begin(std::forward<RangeT>(Range)),\n                      std::end(std::forward<RangeT>(Range)), Pred),\n      FilterIteratorT(std::end(std::forward<RangeT>(Range)),\n                      std::end(std::forward<RangeT>(Range)), Pred));\n}\n\n/// A pseudo-iterator adaptor that is designed to implement \"early increment\"\n/// style loops.\n///\n/// This is *not a normal iterator* and should almost never be used directly. It\n/// is intended primarily to be used with range based for loops and some range\n/// algorithms.\n///\n/// The iterator isn't quite an `OutputIterator` or an `InputIterator` but\n/// somewhere between them. The constraints of these iterators are:\n///\n/// - On construction or after being incremented, it is comparable and\n///   dereferencable. It is *not* incrementable.\n/// - After being dereferenced, it is neither comparable nor dereferencable, it\n///   is only incrementable.\n///\n/// This means you can only dereference the iterator once, and you can only\n/// increment it once between dereferences.\ntemplate <typename WrappedIteratorT>\nclass early_inc_iterator_impl\n    : public iterator_adaptor_base<early_inc_iterator_impl<WrappedIteratorT>,\n                                   WrappedIteratorT, std::input_iterator_tag> {\n  using BaseT =\n      iterator_adaptor_base<early_inc_iterator_impl<WrappedIteratorT>,\n                            WrappedIteratorT, std::input_iterator_tag>;\n\n  using PointerT = typename std::iterator_traits<WrappedIteratorT>::pointer;\n\nprotected:\n#if LLVM_ENABLE_ABI_BREAKING_CHECKS\n  bool IsEarlyIncremented = false;\n#endif\n\npublic:\n  early_inc_iterator_impl(WrappedIteratorT I) : BaseT(I) {}\n\n  using BaseT::operator*;\n  decltype(*std::declval<WrappedIteratorT>()) operator*() {\n#if LLVM_ENABLE_ABI_BREAKING_CHECKS\n    assert(!IsEarlyIncremented && \"Cannot dereference twice!\");\n    IsEarlyIncremented = true;\n#endif\n    return *(this->I)++;\n  }\n\n  using BaseT::operator++;\n  early_inc_iterator_impl &operator++() {\n#if LLVM_ENABLE_ABI_BREAKING_CHECKS\n    assert(IsEarlyIncremented && \"Cannot increment before dereferencing!\");\n    IsEarlyIncremented = false;\n#endif\n    return *this;\n  }\n\n  friend bool operator==(const early_inc_iterator_impl &LHS,\n                         const early_inc_iterator_impl &RHS) {\n#if LLVM_ENABLE_ABI_BREAKING_CHECKS\n    assert(!LHS.IsEarlyIncremented && \"Cannot compare after dereferencing!\");\n#endif\n    return (const BaseT &)LHS == (const BaseT &)RHS;\n  }\n};\n\n/// Make a range that does early increment to allow mutation of the underlying\n/// range without disrupting iteration.\n///\n/// The underlying iterator will be incremented immediately after it is\n/// dereferenced, allowing deletion of the current node or insertion of nodes to\n/// not disrupt iteration provided they do not invalidate the *next* iterator --\n/// the current iterator can be invalidated.\n///\n/// This requires a very exact pattern of use that is only really suitable to\n/// range based for loops and other range algorithms that explicitly guarantee\n/// to dereference exactly once each element, and to increment exactly once each\n/// element.\ntemplate <typename RangeT>\niterator_range<early_inc_iterator_impl<detail::IterOfRange<RangeT>>>\nmake_early_inc_range(RangeT &&Range) {\n  using EarlyIncIteratorT =\n      early_inc_iterator_impl<detail::IterOfRange<RangeT>>;\n  return make_range(EarlyIncIteratorT(std::begin(std::forward<RangeT>(Range))),\n                    EarlyIncIteratorT(std::end(std::forward<RangeT>(Range))));\n}\n\n// forward declarations required by zip_shortest/zip_first/zip_longest\ntemplate <typename R, typename UnaryPredicate>\nbool all_of(R &&range, UnaryPredicate P);\ntemplate <typename R, typename UnaryPredicate>\nbool any_of(R &&range, UnaryPredicate P);\n\nnamespace detail {\n\nusing std::declval;\n\n// We have to alias this since inlining the actual type at the usage site\n// in the parameter list of iterator_facade_base<> below ICEs MSVC 2017.\ntemplate<typename... Iters> struct ZipTupleType {\n  using type = std::tuple<decltype(*declval<Iters>())...>;\n};\n\ntemplate <typename ZipType, typename... Iters>\nusing zip_traits = iterator_facade_base<\n    ZipType, typename std::common_type<std::bidirectional_iterator_tag,\n                                       typename std::iterator_traits<\n                                           Iters>::iterator_category...>::type,\n    // ^ TODO: Implement random access methods.\n    typename ZipTupleType<Iters...>::type,\n    typename std::iterator_traits<typename std::tuple_element<\n        0, std::tuple<Iters...>>::type>::difference_type,\n    // ^ FIXME: This follows boost::make_zip_iterator's assumption that all\n    // inner iterators have the same difference_type. It would fail if, for\n    // instance, the second field's difference_type were non-numeric while the\n    // first is.\n    typename ZipTupleType<Iters...>::type *,\n    typename ZipTupleType<Iters...>::type>;\n\ntemplate <typename ZipType, typename... Iters>\nstruct zip_common : public zip_traits<ZipType, Iters...> {\n  using Base = zip_traits<ZipType, Iters...>;\n  using value_type = typename Base::value_type;\n\n  std::tuple<Iters...> iterators;\n\nprotected:\n  template <size_t... Ns> value_type deref(std::index_sequence<Ns...>) const {\n    return value_type(*std::get<Ns>(iterators)...);\n  }\n\n  template <size_t... Ns>\n  decltype(iterators) tup_inc(std::index_sequence<Ns...>) const {\n    return std::tuple<Iters...>(std::next(std::get<Ns>(iterators))...);\n  }\n\n  template <size_t... Ns>\n  decltype(iterators) tup_dec(std::index_sequence<Ns...>) const {\n    return std::tuple<Iters...>(std::prev(std::get<Ns>(iterators))...);\n  }\n\npublic:\n  zip_common(Iters &&... ts) : iterators(std::forward<Iters>(ts)...) {}\n\n  value_type operator*() { return deref(std::index_sequence_for<Iters...>{}); }\n\n  const value_type operator*() const {\n    return deref(std::index_sequence_for<Iters...>{});\n  }\n\n  ZipType &operator++() {\n    iterators = tup_inc(std::index_sequence_for<Iters...>{});\n    return *reinterpret_cast<ZipType *>(this);\n  }\n\n  ZipType &operator--() {\n    static_assert(Base::IsBidirectional,\n                  \"All inner iterators must be at least bidirectional.\");\n    iterators = tup_dec(std::index_sequence_for<Iters...>{});\n    return *reinterpret_cast<ZipType *>(this);\n  }\n};\n\ntemplate <typename... Iters>\nstruct zip_first : public zip_common<zip_first<Iters...>, Iters...> {\n  using Base = zip_common<zip_first<Iters...>, Iters...>;\n\n  bool operator==(const zip_first<Iters...> &other) const {\n    return std::get<0>(this->iterators) == std::get<0>(other.iterators);\n  }\n\n  zip_first(Iters &&... ts) : Base(std::forward<Iters>(ts)...) {}\n};\n\ntemplate <typename... Iters>\nclass zip_shortest : public zip_common<zip_shortest<Iters...>, Iters...> {\n  template <size_t... Ns>\n  bool test(const zip_shortest<Iters...> &other,\n            std::index_sequence<Ns...>) const {\n    return all_of(std::initializer_list<bool>{std::get<Ns>(this->iterators) !=\n                                              std::get<Ns>(other.iterators)...},\n                  identity<bool>{});\n  }\n\npublic:\n  using Base = zip_common<zip_shortest<Iters...>, Iters...>;\n\n  zip_shortest(Iters &&... ts) : Base(std::forward<Iters>(ts)...) {}\n\n  bool operator==(const zip_shortest<Iters...> &other) const {\n    return !test(other, std::index_sequence_for<Iters...>{});\n  }\n};\n\ntemplate <template <typename...> class ItType, typename... Args> class zippy {\npublic:\n  using iterator = ItType<decltype(std::begin(std::declval<Args>()))...>;\n  using iterator_category = typename iterator::iterator_category;\n  using value_type = typename iterator::value_type;\n  using difference_type = typename iterator::difference_type;\n  using pointer = typename iterator::pointer;\n  using reference = typename iterator::reference;\n\nprivate:\n  std::tuple<Args...> ts;\n\n  template <size_t... Ns>\n  iterator begin_impl(std::index_sequence<Ns...>) const {\n    return iterator(std::begin(std::get<Ns>(ts))...);\n  }\n  template <size_t... Ns> iterator end_impl(std::index_sequence<Ns...>) const {\n    return iterator(std::end(std::get<Ns>(ts))...);\n  }\n\npublic:\n  zippy(Args &&... ts_) : ts(std::forward<Args>(ts_)...) {}\n\n  iterator begin() const {\n    return begin_impl(std::index_sequence_for<Args...>{});\n  }\n  iterator end() const { return end_impl(std::index_sequence_for<Args...>{}); }\n};\n\n} // end namespace detail\n\n/// zip iterator for two or more iteratable types.\ntemplate <typename T, typename U, typename... Args>\ndetail::zippy<detail::zip_shortest, T, U, Args...> zip(T &&t, U &&u,\n                                                       Args &&... args) {\n  return detail::zippy<detail::zip_shortest, T, U, Args...>(\n      std::forward<T>(t), std::forward<U>(u), std::forward<Args>(args)...);\n}\n\n/// zip iterator that, for the sake of efficiency, assumes the first iteratee to\n/// be the shortest.\ntemplate <typename T, typename U, typename... Args>\ndetail::zippy<detail::zip_first, T, U, Args...> zip_first(T &&t, U &&u,\n                                                          Args &&... args) {\n  return detail::zippy<detail::zip_first, T, U, Args...>(\n      std::forward<T>(t), std::forward<U>(u), std::forward<Args>(args)...);\n}\n\nnamespace detail {\ntemplate <typename Iter>\nIter next_or_end(const Iter &I, const Iter &End) {\n  if (I == End)\n    return End;\n  return std::next(I);\n}\n\ntemplate <typename Iter>\nauto deref_or_none(const Iter &I, const Iter &End) -> llvm::Optional<\n    std::remove_const_t<std::remove_reference_t<decltype(*I)>>> {\n  if (I == End)\n    return None;\n  return *I;\n}\n\ntemplate <typename Iter> struct ZipLongestItemType {\n  using type =\n      llvm::Optional<typename std::remove_const<typename std::remove_reference<\n          decltype(*std::declval<Iter>())>::type>::type>;\n};\n\ntemplate <typename... Iters> struct ZipLongestTupleType {\n  using type = std::tuple<typename ZipLongestItemType<Iters>::type...>;\n};\n\ntemplate <typename... Iters>\nclass zip_longest_iterator\n    : public iterator_facade_base<\n          zip_longest_iterator<Iters...>,\n          typename std::common_type<\n              std::forward_iterator_tag,\n              typename std::iterator_traits<Iters>::iterator_category...>::type,\n          typename ZipLongestTupleType<Iters...>::type,\n          typename std::iterator_traits<typename std::tuple_element<\n              0, std::tuple<Iters...>>::type>::difference_type,\n          typename ZipLongestTupleType<Iters...>::type *,\n          typename ZipLongestTupleType<Iters...>::type> {\npublic:\n  using value_type = typename ZipLongestTupleType<Iters...>::type;\n\nprivate:\n  std::tuple<Iters...> iterators;\n  std::tuple<Iters...> end_iterators;\n\n  template <size_t... Ns>\n  bool test(const zip_longest_iterator<Iters...> &other,\n            std::index_sequence<Ns...>) const {\n    return llvm::any_of(\n        std::initializer_list<bool>{std::get<Ns>(this->iterators) !=\n                                    std::get<Ns>(other.iterators)...},\n        identity<bool>{});\n  }\n\n  template <size_t... Ns> value_type deref(std::index_sequence<Ns...>) const {\n    return value_type(\n        deref_or_none(std::get<Ns>(iterators), std::get<Ns>(end_iterators))...);\n  }\n\n  template <size_t... Ns>\n  decltype(iterators) tup_inc(std::index_sequence<Ns...>) const {\n    return std::tuple<Iters...>(\n        next_or_end(std::get<Ns>(iterators), std::get<Ns>(end_iterators))...);\n  }\n\npublic:\n  zip_longest_iterator(std::pair<Iters &&, Iters &&>... ts)\n      : iterators(std::forward<Iters>(ts.first)...),\n        end_iterators(std::forward<Iters>(ts.second)...) {}\n\n  value_type operator*() { return deref(std::index_sequence_for<Iters...>{}); }\n\n  value_type operator*() const {\n    return deref(std::index_sequence_for<Iters...>{});\n  }\n\n  zip_longest_iterator<Iters...> &operator++() {\n    iterators = tup_inc(std::index_sequence_for<Iters...>{});\n    return *this;\n  }\n\n  bool operator==(const zip_longest_iterator<Iters...> &other) const {\n    return !test(other, std::index_sequence_for<Iters...>{});\n  }\n};\n\ntemplate <typename... Args> class zip_longest_range {\npublic:\n  using iterator =\n      zip_longest_iterator<decltype(adl_begin(std::declval<Args>()))...>;\n  using iterator_category = typename iterator::iterator_category;\n  using value_type = typename iterator::value_type;\n  using difference_type = typename iterator::difference_type;\n  using pointer = typename iterator::pointer;\n  using reference = typename iterator::reference;\n\nprivate:\n  std::tuple<Args...> ts;\n\n  template <size_t... Ns>\n  iterator begin_impl(std::index_sequence<Ns...>) const {\n    return iterator(std::make_pair(adl_begin(std::get<Ns>(ts)),\n                                   adl_end(std::get<Ns>(ts)))...);\n  }\n\n  template <size_t... Ns> iterator end_impl(std::index_sequence<Ns...>) const {\n    return iterator(std::make_pair(adl_end(std::get<Ns>(ts)),\n                                   adl_end(std::get<Ns>(ts)))...);\n  }\n\npublic:\n  zip_longest_range(Args &&... ts_) : ts(std::forward<Args>(ts_)...) {}\n\n  iterator begin() const {\n    return begin_impl(std::index_sequence_for<Args...>{});\n  }\n  iterator end() const { return end_impl(std::index_sequence_for<Args...>{}); }\n};\n} // namespace detail\n\n/// Iterate over two or more iterators at the same time. Iteration continues\n/// until all iterators reach the end. The llvm::Optional only contains a value\n/// if the iterator has not reached the end.\ntemplate <typename T, typename U, typename... Args>\ndetail::zip_longest_range<T, U, Args...> zip_longest(T &&t, U &&u,\n                                                     Args &&... args) {\n  return detail::zip_longest_range<T, U, Args...>(\n      std::forward<T>(t), std::forward<U>(u), std::forward<Args>(args)...);\n}\n\n/// Iterator wrapper that concatenates sequences together.\n///\n/// This can concatenate different iterators, even with different types, into\n/// a single iterator provided the value types of all the concatenated\n/// iterators expose `reference` and `pointer` types that can be converted to\n/// `ValueT &` and `ValueT *` respectively. It doesn't support more\n/// interesting/customized pointer or reference types.\n///\n/// Currently this only supports forward or higher iterator categories as\n/// inputs and always exposes a forward iterator interface.\ntemplate <typename ValueT, typename... IterTs>\nclass concat_iterator\n    : public iterator_facade_base<concat_iterator<ValueT, IterTs...>,\n                                  std::forward_iterator_tag, ValueT> {\n  using BaseT = typename concat_iterator::iterator_facade_base;\n\n  /// We store both the current and end iterators for each concatenated\n  /// sequence in a tuple of pairs.\n  ///\n  /// Note that something like iterator_range seems nice at first here, but the\n  /// range properties are of little benefit and end up getting in the way\n  /// because we need to do mutation on the current iterators.\n  std::tuple<IterTs...> Begins;\n  std::tuple<IterTs...> Ends;\n\n  /// Attempts to increment a specific iterator.\n  ///\n  /// Returns true if it was able to increment the iterator. Returns false if\n  /// the iterator is already at the end iterator.\n  template <size_t Index> bool incrementHelper() {\n    auto &Begin = std::get<Index>(Begins);\n    auto &End = std::get<Index>(Ends);\n    if (Begin == End)\n      return false;\n\n    ++Begin;\n    return true;\n  }\n\n  /// Increments the first non-end iterator.\n  ///\n  /// It is an error to call this with all iterators at the end.\n  template <size_t... Ns> void increment(std::index_sequence<Ns...>) {\n    // Build a sequence of functions to increment each iterator if possible.\n    bool (concat_iterator::*IncrementHelperFns[])() = {\n        &concat_iterator::incrementHelper<Ns>...};\n\n    // Loop over them, and stop as soon as we succeed at incrementing one.\n    for (auto &IncrementHelperFn : IncrementHelperFns)\n      if ((this->*IncrementHelperFn)())\n        return;\n\n    llvm_unreachable(\"Attempted to increment an end concat iterator!\");\n  }\n\n  /// Returns null if the specified iterator is at the end. Otherwise,\n  /// dereferences the iterator and returns the address of the resulting\n  /// reference.\n  template <size_t Index> ValueT *getHelper() const {\n    auto &Begin = std::get<Index>(Begins);\n    auto &End = std::get<Index>(Ends);\n    if (Begin == End)\n      return nullptr;\n\n    return &*Begin;\n  }\n\n  /// Finds the first non-end iterator, dereferences, and returns the resulting\n  /// reference.\n  ///\n  /// It is an error to call this with all iterators at the end.\n  template <size_t... Ns> ValueT &get(std::index_sequence<Ns...>) const {\n    // Build a sequence of functions to get from iterator if possible.\n    ValueT *(concat_iterator::*GetHelperFns[])() const = {\n        &concat_iterator::getHelper<Ns>...};\n\n    // Loop over them, and return the first result we find.\n    for (auto &GetHelperFn : GetHelperFns)\n      if (ValueT *P = (this->*GetHelperFn)())\n        return *P;\n\n    llvm_unreachable(\"Attempted to get a pointer from an end concat iterator!\");\n  }\n\npublic:\n  /// Constructs an iterator from a sequence of ranges.\n  ///\n  /// We need the full range to know how to switch between each of the\n  /// iterators.\n  template <typename... RangeTs>\n  explicit concat_iterator(RangeTs &&... Ranges)\n      : Begins(std::begin(Ranges)...), Ends(std::end(Ranges)...) {}\n\n  using BaseT::operator++;\n\n  concat_iterator &operator++() {\n    increment(std::index_sequence_for<IterTs...>());\n    return *this;\n  }\n\n  ValueT &operator*() const {\n    return get(std::index_sequence_for<IterTs...>());\n  }\n\n  bool operator==(const concat_iterator &RHS) const {\n    return Begins == RHS.Begins && Ends == RHS.Ends;\n  }\n};\n\nnamespace detail {\n\n/// Helper to store a sequence of ranges being concatenated and access them.\n///\n/// This is designed to facilitate providing actual storage when temporaries\n/// are passed into the constructor such that we can use it as part of range\n/// based for loops.\ntemplate <typename ValueT, typename... RangeTs> class concat_range {\npublic:\n  using iterator =\n      concat_iterator<ValueT,\n                      decltype(std::begin(std::declval<RangeTs &>()))...>;\n\nprivate:\n  std::tuple<RangeTs...> Ranges;\n\n  template <size_t... Ns> iterator begin_impl(std::index_sequence<Ns...>) {\n    return iterator(std::get<Ns>(Ranges)...);\n  }\n  template <size_t... Ns> iterator end_impl(std::index_sequence<Ns...>) {\n    return iterator(make_range(std::end(std::get<Ns>(Ranges)),\n                               std::end(std::get<Ns>(Ranges)))...);\n  }\n\npublic:\n  concat_range(RangeTs &&... Ranges)\n      : Ranges(std::forward<RangeTs>(Ranges)...) {}\n\n  iterator begin() { return begin_impl(std::index_sequence_for<RangeTs...>{}); }\n  iterator end() { return end_impl(std::index_sequence_for<RangeTs...>{}); }\n};\n\n} // end namespace detail\n\n/// Concatenated range across two or more ranges.\n///\n/// The desired value type must be explicitly specified.\ntemplate <typename ValueT, typename... RangeTs>\ndetail::concat_range<ValueT, RangeTs...> concat(RangeTs &&... Ranges) {\n  static_assert(sizeof...(RangeTs) > 1,\n                \"Need more than one range to concatenate!\");\n  return detail::concat_range<ValueT, RangeTs...>(\n      std::forward<RangeTs>(Ranges)...);\n}\n\n/// A utility class used to implement an iterator that contains some base object\n/// and an index. The iterator moves the index but keeps the base constant.\ntemplate <typename DerivedT, typename BaseT, typename T,\n          typename PointerT = T *, typename ReferenceT = T &>\nclass indexed_accessor_iterator\n    : public llvm::iterator_facade_base<DerivedT,\n                                        std::random_access_iterator_tag, T,\n                                        std::ptrdiff_t, PointerT, ReferenceT> {\npublic:\n  ptrdiff_t operator-(const indexed_accessor_iterator &rhs) const {\n    assert(base == rhs.base && \"incompatible iterators\");\n    return index - rhs.index;\n  }\n  bool operator==(const indexed_accessor_iterator &rhs) const {\n    return base == rhs.base && index == rhs.index;\n  }\n  bool operator<(const indexed_accessor_iterator &rhs) const {\n    assert(base == rhs.base && \"incompatible iterators\");\n    return index < rhs.index;\n  }\n\n  DerivedT &operator+=(ptrdiff_t offset) {\n    this->index += offset;\n    return static_cast<DerivedT &>(*this);\n  }\n  DerivedT &operator-=(ptrdiff_t offset) {\n    this->index -= offset;\n    return static_cast<DerivedT &>(*this);\n  }\n\n  /// Returns the current index of the iterator.\n  ptrdiff_t getIndex() const { return index; }\n\n  /// Returns the current base of the iterator.\n  const BaseT &getBase() const { return base; }\n\nprotected:\n  indexed_accessor_iterator(BaseT base, ptrdiff_t index)\n      : base(base), index(index) {}\n  BaseT base;\n  ptrdiff_t index;\n};\n\nnamespace detail {\n/// The class represents the base of a range of indexed_accessor_iterators. It\n/// provides support for many different range functionalities, e.g.\n/// drop_front/slice/etc.. Derived range classes must implement the following\n/// static methods:\n///   * ReferenceT dereference_iterator(const BaseT &base, ptrdiff_t index)\n///     - Dereference an iterator pointing to the base object at the given\n///       index.\n///   * BaseT offset_base(const BaseT &base, ptrdiff_t index)\n///     - Return a new base that is offset from the provide base by 'index'\n///       elements.\ntemplate <typename DerivedT, typename BaseT, typename T,\n          typename PointerT = T *, typename ReferenceT = T &>\nclass indexed_accessor_range_base {\npublic:\n  using RangeBaseT =\n      indexed_accessor_range_base<DerivedT, BaseT, T, PointerT, ReferenceT>;\n\n  /// An iterator element of this range.\n  class iterator : public indexed_accessor_iterator<iterator, BaseT, T,\n                                                    PointerT, ReferenceT> {\n  public:\n    // Index into this iterator, invoking a static method on the derived type.\n    ReferenceT operator*() const {\n      return DerivedT::dereference_iterator(this->getBase(), this->getIndex());\n    }\n\n  private:\n    iterator(BaseT owner, ptrdiff_t curIndex)\n        : indexed_accessor_iterator<iterator, BaseT, T, PointerT, ReferenceT>(\n              owner, curIndex) {}\n\n    /// Allow access to the constructor.\n    friend indexed_accessor_range_base<DerivedT, BaseT, T, PointerT,\n                                       ReferenceT>;\n  };\n\n  indexed_accessor_range_base(iterator begin, iterator end)\n      : base(offset_base(begin.getBase(), begin.getIndex())),\n        count(end.getIndex() - begin.getIndex()) {}\n  indexed_accessor_range_base(const iterator_range<iterator> &range)\n      : indexed_accessor_range_base(range.begin(), range.end()) {}\n  indexed_accessor_range_base(BaseT base, ptrdiff_t count)\n      : base(base), count(count) {}\n\n  iterator begin() const { return iterator(base, 0); }\n  iterator end() const { return iterator(base, count); }\n  ReferenceT operator[](size_t Index) const {\n    assert(Index < size() && \"invalid index for value range\");\n    return DerivedT::dereference_iterator(base, static_cast<ptrdiff_t>(Index));\n  }\n  ReferenceT front() const {\n    assert(!empty() && \"expected non-empty range\");\n    return (*this)[0];\n  }\n  ReferenceT back() const {\n    assert(!empty() && \"expected non-empty range\");\n    return (*this)[size() - 1];\n  }\n\n  /// Compare this range with another.\n  template <typename OtherT> bool operator==(const OtherT &other) const {\n    return size() ==\n               static_cast<size_t>(std::distance(other.begin(), other.end())) &&\n           std::equal(begin(), end(), other.begin());\n  }\n  template <typename OtherT> bool operator!=(const OtherT &other) const {\n    return !(*this == other);\n  }\n\n  /// Return the size of this range.\n  size_t size() const { return count; }\n\n  /// Return if the range is empty.\n  bool empty() const { return size() == 0; }\n\n  /// Drop the first N elements, and keep M elements.\n  DerivedT slice(size_t n, size_t m) const {\n    assert(n + m <= size() && \"invalid size specifiers\");\n    return DerivedT(offset_base(base, n), m);\n  }\n\n  /// Drop the first n elements.\n  DerivedT drop_front(size_t n = 1) const {\n    assert(size() >= n && \"Dropping more elements than exist\");\n    return slice(n, size() - n);\n  }\n  /// Drop the last n elements.\n  DerivedT drop_back(size_t n = 1) const {\n    assert(size() >= n && \"Dropping more elements than exist\");\n    return DerivedT(base, size() - n);\n  }\n\n  /// Take the first n elements.\n  DerivedT take_front(size_t n = 1) const {\n    return n < size() ? drop_back(size() - n)\n                      : static_cast<const DerivedT &>(*this);\n  }\n\n  /// Take the last n elements.\n  DerivedT take_back(size_t n = 1) const {\n    return n < size() ? drop_front(size() - n)\n                      : static_cast<const DerivedT &>(*this);\n  }\n\n  /// Allow conversion to any type accepting an iterator_range.\n  template <typename RangeT, typename = std::enable_if_t<std::is_constructible<\n                                 RangeT, iterator_range<iterator>>::value>>\n  operator RangeT() const {\n    return RangeT(iterator_range<iterator>(*this));\n  }\n\n  /// Returns the base of this range.\n  const BaseT &getBase() const { return base; }\n\nprivate:\n  /// Offset the given base by the given amount.\n  static BaseT offset_base(const BaseT &base, size_t n) {\n    return n == 0 ? base : DerivedT::offset_base(base, n);\n  }\n\nprotected:\n  indexed_accessor_range_base(const indexed_accessor_range_base &) = default;\n  indexed_accessor_range_base(indexed_accessor_range_base &&) = default;\n  indexed_accessor_range_base &\n  operator=(const indexed_accessor_range_base &) = default;\n\n  /// The base that owns the provided range of values.\n  BaseT base;\n  /// The size from the owning range.\n  ptrdiff_t count;\n};\n} // end namespace detail\n\n/// This class provides an implementation of a range of\n/// indexed_accessor_iterators where the base is not indexable. Ranges with\n/// bases that are offsetable should derive from indexed_accessor_range_base\n/// instead. Derived range classes are expected to implement the following\n/// static method:\n///   * ReferenceT dereference(const BaseT &base, ptrdiff_t index)\n///     - Dereference an iterator pointing to a parent base at the given index.\ntemplate <typename DerivedT, typename BaseT, typename T,\n          typename PointerT = T *, typename ReferenceT = T &>\nclass indexed_accessor_range\n    : public detail::indexed_accessor_range_base<\n          DerivedT, std::pair<BaseT, ptrdiff_t>, T, PointerT, ReferenceT> {\npublic:\n  indexed_accessor_range(BaseT base, ptrdiff_t startIndex, ptrdiff_t count)\n      : detail::indexed_accessor_range_base<\n            DerivedT, std::pair<BaseT, ptrdiff_t>, T, PointerT, ReferenceT>(\n            std::make_pair(base, startIndex), count) {}\n  using detail::indexed_accessor_range_base<\n      DerivedT, std::pair<BaseT, ptrdiff_t>, T, PointerT,\n      ReferenceT>::indexed_accessor_range_base;\n\n  /// Returns the current base of the range.\n  const BaseT &getBase() const { return this->base.first; }\n\n  /// Returns the current start index of the range.\n  ptrdiff_t getStartIndex() const { return this->base.second; }\n\n  /// See `detail::indexed_accessor_range_base` for details.\n  static std::pair<BaseT, ptrdiff_t>\n  offset_base(const std::pair<BaseT, ptrdiff_t> &base, ptrdiff_t index) {\n    // We encode the internal base as a pair of the derived base and a start\n    // index into the derived base.\n    return std::make_pair(base.first, base.second + index);\n  }\n  /// See `detail::indexed_accessor_range_base` for details.\n  static ReferenceT\n  dereference_iterator(const std::pair<BaseT, ptrdiff_t> &base,\n                       ptrdiff_t index) {\n    return DerivedT::dereference(base.first, base.second + index);\n  }\n};\n\n/// Given a container of pairs, return a range over the first elements.\ntemplate <typename ContainerTy> auto make_first_range(ContainerTy &&c) {\n  return llvm::map_range(\n      std::forward<ContainerTy>(c),\n      [](decltype((*std::begin(c))) elt) -> decltype((elt.first)) {\n        return elt.first;\n      });\n}\n\n/// Given a container of pairs, return a range over the second elements.\ntemplate <typename ContainerTy> auto make_second_range(ContainerTy &&c) {\n  return llvm::map_range(\n      std::forward<ContainerTy>(c),\n      [](decltype((*std::begin(c))) elt) -> decltype((elt.second)) {\n        return elt.second;\n      });\n}\n\n//===----------------------------------------------------------------------===//\n//     Extra additions to <utility>\n//===----------------------------------------------------------------------===//\n\n/// Function object to check whether the first component of a std::pair\n/// compares less than the first component of another std::pair.\nstruct less_first {\n  template <typename T> bool operator()(const T &lhs, const T &rhs) const {\n    return lhs.first < rhs.first;\n  }\n};\n\n/// Function object to check whether the second component of a std::pair\n/// compares less than the second component of another std::pair.\nstruct less_second {\n  template <typename T> bool operator()(const T &lhs, const T &rhs) const {\n    return lhs.second < rhs.second;\n  }\n};\n\n/// \\brief Function object to apply a binary function to the first component of\n/// a std::pair.\ntemplate<typename FuncTy>\nstruct on_first {\n  FuncTy func;\n\n  template <typename T>\n  decltype(auto) operator()(const T &lhs, const T &rhs) const {\n    return func(lhs.first, rhs.first);\n  }\n};\n\n/// Utility type to build an inheritance chain that makes it easy to rank\n/// overload candidates.\ntemplate <int N> struct rank : rank<N - 1> {};\ntemplate <> struct rank<0> {};\n\n/// traits class for checking whether type T is one of any of the given\n/// types in the variadic list.\ntemplate <typename T, typename... Ts> struct is_one_of {\n  static const bool value = false;\n};\n\ntemplate <typename T, typename U, typename... Ts>\nstruct is_one_of<T, U, Ts...> {\n  static const bool value =\n      std::is_same<T, U>::value || is_one_of<T, Ts...>::value;\n};\n\n/// traits class for checking whether type T is a base class for all\n///  the given types in the variadic list.\ntemplate <typename T, typename... Ts> struct are_base_of {\n  static const bool value = true;\n};\n\ntemplate <typename T, typename U, typename... Ts>\nstruct are_base_of<T, U, Ts...> {\n  static const bool value =\n      std::is_base_of<T, U>::value && are_base_of<T, Ts...>::value;\n};\n\n//===----------------------------------------------------------------------===//\n//     Extra additions for arrays\n//===----------------------------------------------------------------------===//\n\n// We have a copy here so that LLVM behaves the same when using different\n// standard libraries.\ntemplate <class Iterator, class RNG>\nvoid shuffle(Iterator first, Iterator last, RNG &&g) {\n  // It would be better to use a std::uniform_int_distribution,\n  // but that would be stdlib dependent.\n  typedef\n      typename std::iterator_traits<Iterator>::difference_type difference_type;\n  for (auto size = last - first; size > 1; ++first, (void)--size) {\n    difference_type offset = g() % size;\n    // Avoid self-assignment due to incorrect assertions in libstdc++\n    // containers (https://gcc.gnu.org/bugzilla/show_bug.cgi?id=85828).\n    if (offset != difference_type(0))\n      std::iter_swap(first, first + offset);\n  }\n}\n\n/// Find the length of an array.\ntemplate <class T, std::size_t N>\nconstexpr inline size_t array_lengthof(T (&)[N]) {\n  return N;\n}\n\n/// Adapt std::less<T> for array_pod_sort.\ntemplate<typename T>\ninline int array_pod_sort_comparator(const void *P1, const void *P2) {\n  if (std::less<T>()(*reinterpret_cast<const T*>(P1),\n                     *reinterpret_cast<const T*>(P2)))\n    return -1;\n  if (std::less<T>()(*reinterpret_cast<const T*>(P2),\n                     *reinterpret_cast<const T*>(P1)))\n    return 1;\n  return 0;\n}\n\n/// get_array_pod_sort_comparator - This is an internal helper function used to\n/// get type deduction of T right.\ntemplate<typename T>\ninline int (*get_array_pod_sort_comparator(const T &))\n             (const void*, const void*) {\n  return array_pod_sort_comparator<T>;\n}\n\n#ifdef EXPENSIVE_CHECKS\nnamespace detail {\n\ninline unsigned presortShuffleEntropy() {\n  static unsigned Result(std::random_device{}());\n  return Result;\n}\n\ntemplate <class IteratorTy>\ninline void presortShuffle(IteratorTy Start, IteratorTy End) {\n  std::mt19937 Generator(presortShuffleEntropy());\n  llvm::shuffle(Start, End, Generator);\n}\n\n} // end namespace detail\n#endif\n\n/// array_pod_sort - This sorts an array with the specified start and end\n/// extent.  This is just like std::sort, except that it calls qsort instead of\n/// using an inlined template.  qsort is slightly slower than std::sort, but\n/// most sorts are not performance critical in LLVM and std::sort has to be\n/// template instantiated for each type, leading to significant measured code\n/// bloat.  This function should generally be used instead of std::sort where\n/// possible.\n///\n/// This function assumes that you have simple POD-like types that can be\n/// compared with std::less and can be moved with memcpy.  If this isn't true,\n/// you should use std::sort.\n///\n/// NOTE: If qsort_r were portable, we could allow a custom comparator and\n/// default to std::less.\ntemplate<class IteratorTy>\ninline void array_pod_sort(IteratorTy Start, IteratorTy End) {\n  // Don't inefficiently call qsort with one element or trigger undefined\n  // behavior with an empty sequence.\n  auto NElts = End - Start;\n  if (NElts <= 1) return;\n#ifdef EXPENSIVE_CHECKS\n  detail::presortShuffle<IteratorTy>(Start, End);\n#endif\n  qsort(&*Start, NElts, sizeof(*Start), get_array_pod_sort_comparator(*Start));\n}\n\ntemplate <class IteratorTy>\ninline void array_pod_sort(\n    IteratorTy Start, IteratorTy End,\n    int (*Compare)(\n        const typename std::iterator_traits<IteratorTy>::value_type *,\n        const typename std::iterator_traits<IteratorTy>::value_type *)) {\n  // Don't inefficiently call qsort with one element or trigger undefined\n  // behavior with an empty sequence.\n  auto NElts = End - Start;\n  if (NElts <= 1) return;\n#ifdef EXPENSIVE_CHECKS\n  detail::presortShuffle<IteratorTy>(Start, End);\n#endif\n  qsort(&*Start, NElts, sizeof(*Start),\n        reinterpret_cast<int (*)(const void *, const void *)>(Compare));\n}\n\nnamespace detail {\ntemplate <typename T>\n// We can use qsort if the iterator type is a pointer and the underlying value\n// is trivially copyable.\nusing sort_trivially_copyable = conjunction<\n    std::is_pointer<T>,\n    std::is_trivially_copyable<typename std::iterator_traits<T>::value_type>>;\n} // namespace detail\n\n// Provide wrappers to std::sort which shuffle the elements before sorting\n// to help uncover non-deterministic behavior (PR35135).\ntemplate <typename IteratorTy,\n          std::enable_if_t<!detail::sort_trivially_copyable<IteratorTy>::value,\n                           int> = 0>\ninline void sort(IteratorTy Start, IteratorTy End) {\n#ifdef EXPENSIVE_CHECKS\n  detail::presortShuffle<IteratorTy>(Start, End);\n#endif\n  std::sort(Start, End);\n}\n\n// Forward trivially copyable types to array_pod_sort. This avoids a large\n// amount of code bloat for a minor performance hit.\ntemplate <typename IteratorTy,\n          std::enable_if_t<detail::sort_trivially_copyable<IteratorTy>::value,\n                           int> = 0>\ninline void sort(IteratorTy Start, IteratorTy End) {\n  array_pod_sort(Start, End);\n}\n\ntemplate <typename Container> inline void sort(Container &&C) {\n  llvm::sort(adl_begin(C), adl_end(C));\n}\n\ntemplate <typename IteratorTy, typename Compare>\ninline void sort(IteratorTy Start, IteratorTy End, Compare Comp) {\n#ifdef EXPENSIVE_CHECKS\n  detail::presortShuffle<IteratorTy>(Start, End);\n#endif\n  std::sort(Start, End, Comp);\n}\n\ntemplate <typename Container, typename Compare>\ninline void sort(Container &&C, Compare Comp) {\n  llvm::sort(adl_begin(C), adl_end(C), Comp);\n}\n\n//===----------------------------------------------------------------------===//\n//     Extra additions to <algorithm>\n//===----------------------------------------------------------------------===//\n\n/// Get the size of a range. This is a wrapper function around std::distance\n/// which is only enabled when the operation is O(1).\ntemplate <typename R>\nauto size(R &&Range,\n          std::enable_if_t<\n              std::is_base_of<std::random_access_iterator_tag,\n                              typename std::iterator_traits<decltype(\n                                  Range.begin())>::iterator_category>::value,\n              void> * = nullptr) {\n  return std::distance(Range.begin(), Range.end());\n}\n\n/// Provide wrappers to std::for_each which take ranges instead of having to\n/// pass begin/end explicitly.\ntemplate <typename R, typename UnaryFunction>\nUnaryFunction for_each(R &&Range, UnaryFunction F) {\n  return std::for_each(adl_begin(Range), adl_end(Range), F);\n}\n\n/// Provide wrappers to std::all_of which take ranges instead of having to pass\n/// begin/end explicitly.\ntemplate <typename R, typename UnaryPredicate>\nbool all_of(R &&Range, UnaryPredicate P) {\n  return std::all_of(adl_begin(Range), adl_end(Range), P);\n}\n\n/// Provide wrappers to std::any_of which take ranges instead of having to pass\n/// begin/end explicitly.\ntemplate <typename R, typename UnaryPredicate>\nbool any_of(R &&Range, UnaryPredicate P) {\n  return std::any_of(adl_begin(Range), adl_end(Range), P);\n}\n\n/// Provide wrappers to std::none_of which take ranges instead of having to pass\n/// begin/end explicitly.\ntemplate <typename R, typename UnaryPredicate>\nbool none_of(R &&Range, UnaryPredicate P) {\n  return std::none_of(adl_begin(Range), adl_end(Range), P);\n}\n\n/// Provide wrappers to std::find which take ranges instead of having to pass\n/// begin/end explicitly.\ntemplate <typename R, typename T> auto find(R &&Range, const T &Val) {\n  return std::find(adl_begin(Range), adl_end(Range), Val);\n}\n\n/// Provide wrappers to std::find_if which take ranges instead of having to pass\n/// begin/end explicitly.\ntemplate <typename R, typename UnaryPredicate>\nauto find_if(R &&Range, UnaryPredicate P) {\n  return std::find_if(adl_begin(Range), adl_end(Range), P);\n}\n\ntemplate <typename R, typename UnaryPredicate>\nauto find_if_not(R &&Range, UnaryPredicate P) {\n  return std::find_if_not(adl_begin(Range), adl_end(Range), P);\n}\n\n/// Provide wrappers to std::remove_if which take ranges instead of having to\n/// pass begin/end explicitly.\ntemplate <typename R, typename UnaryPredicate>\nauto remove_if(R &&Range, UnaryPredicate P) {\n  return std::remove_if(adl_begin(Range), adl_end(Range), P);\n}\n\n/// Provide wrappers to std::copy_if which take ranges instead of having to\n/// pass begin/end explicitly.\ntemplate <typename R, typename OutputIt, typename UnaryPredicate>\nOutputIt copy_if(R &&Range, OutputIt Out, UnaryPredicate P) {\n  return std::copy_if(adl_begin(Range), adl_end(Range), Out, P);\n}\n\ntemplate <typename R, typename OutputIt>\nOutputIt copy(R &&Range, OutputIt Out) {\n  return std::copy(adl_begin(Range), adl_end(Range), Out);\n}\n\n/// Provide wrappers to std::move which take ranges instead of having to\n/// pass begin/end explicitly.\ntemplate <typename R, typename OutputIt>\nOutputIt move(R &&Range, OutputIt Out) {\n  return std::move(adl_begin(Range), adl_end(Range), Out);\n}\n\n/// Wrapper function around std::find to detect if an element exists\n/// in a container.\ntemplate <typename R, typename E>\nbool is_contained(R &&Range, const E &Element) {\n  return std::find(adl_begin(Range), adl_end(Range), Element) != adl_end(Range);\n}\n\n/// Wrapper function around std::is_sorted to check if elements in a range \\p R\n/// are sorted with respect to a comparator \\p C.\ntemplate <typename R, typename Compare> bool is_sorted(R &&Range, Compare C) {\n  return std::is_sorted(adl_begin(Range), adl_end(Range), C);\n}\n\n/// Wrapper function around std::is_sorted to check if elements in a range \\p R\n/// are sorted in non-descending order.\ntemplate <typename R> bool is_sorted(R &&Range) {\n  return std::is_sorted(adl_begin(Range), adl_end(Range));\n}\n\n/// Wrapper function around std::count to count the number of times an element\n/// \\p Element occurs in the given range \\p Range.\ntemplate <typename R, typename E> auto count(R &&Range, const E &Element) {\n  return std::count(adl_begin(Range), adl_end(Range), Element);\n}\n\n/// Wrapper function around std::count_if to count the number of times an\n/// element satisfying a given predicate occurs in a range.\ntemplate <typename R, typename UnaryPredicate>\nauto count_if(R &&Range, UnaryPredicate P) {\n  return std::count_if(adl_begin(Range), adl_end(Range), P);\n}\n\n/// Wrapper function around std::transform to apply a function to a range and\n/// store the result elsewhere.\ntemplate <typename R, typename OutputIt, typename UnaryFunction>\nOutputIt transform(R &&Range, OutputIt d_first, UnaryFunction F) {\n  return std::transform(adl_begin(Range), adl_end(Range), d_first, F);\n}\n\n/// Provide wrappers to std::partition which take ranges instead of having to\n/// pass begin/end explicitly.\ntemplate <typename R, typename UnaryPredicate>\nauto partition(R &&Range, UnaryPredicate P) {\n  return std::partition(adl_begin(Range), adl_end(Range), P);\n}\n\n/// Provide wrappers to std::lower_bound which take ranges instead of having to\n/// pass begin/end explicitly.\ntemplate <typename R, typename T> auto lower_bound(R &&Range, T &&Value) {\n  return std::lower_bound(adl_begin(Range), adl_end(Range),\n                          std::forward<T>(Value));\n}\n\ntemplate <typename R, typename T, typename Compare>\nauto lower_bound(R &&Range, T &&Value, Compare C) {\n  return std::lower_bound(adl_begin(Range), adl_end(Range),\n                          std::forward<T>(Value), C);\n}\n\n/// Provide wrappers to std::upper_bound which take ranges instead of having to\n/// pass begin/end explicitly.\ntemplate <typename R, typename T> auto upper_bound(R &&Range, T &&Value) {\n  return std::upper_bound(adl_begin(Range), adl_end(Range),\n                          std::forward<T>(Value));\n}\n\ntemplate <typename R, typename T, typename Compare>\nauto upper_bound(R &&Range, T &&Value, Compare C) {\n  return std::upper_bound(adl_begin(Range), adl_end(Range),\n                          std::forward<T>(Value), C);\n}\n\ntemplate <typename R>\nvoid stable_sort(R &&Range) {\n  std::stable_sort(adl_begin(Range), adl_end(Range));\n}\n\ntemplate <typename R, typename Compare>\nvoid stable_sort(R &&Range, Compare C) {\n  std::stable_sort(adl_begin(Range), adl_end(Range), C);\n}\n\n/// Binary search for the first iterator in a range where a predicate is false.\n/// Requires that C is always true below some limit, and always false above it.\ntemplate <typename R, typename Predicate,\n          typename Val = decltype(*adl_begin(std::declval<R>()))>\nauto partition_point(R &&Range, Predicate P) {\n  return std::partition_point(adl_begin(Range), adl_end(Range), P);\n}\n\n/// Wrapper function around std::equal to detect if all elements\n/// in a container are same.\ntemplate <typename R>\nbool is_splat(R &&Range) {\n  size_t range_size = size(Range);\n  return range_size != 0 && (range_size == 1 ||\n         std::equal(adl_begin(Range) + 1, adl_end(Range), adl_begin(Range)));\n}\n\n/// Provide a container algorithm similar to C++ Library Fundamentals v2's\n/// `erase_if` which is equivalent to:\n///\n///   C.erase(remove_if(C, pred), C.end());\n///\n/// This version works for any container with an erase method call accepting\n/// two iterators.\ntemplate <typename Container, typename UnaryPredicate>\nvoid erase_if(Container &C, UnaryPredicate P) {\n  C.erase(remove_if(C, P), C.end());\n}\n\n/// Wrapper function to remove a value from a container:\n///\n/// C.erase(remove(C.begin(), C.end(), V), C.end());\ntemplate <typename Container, typename ValueType>\nvoid erase_value(Container &C, ValueType V) {\n  C.erase(std::remove(C.begin(), C.end(), V), C.end());\n}\n\n/// Wrapper function to append a range to a container.\n///\n/// C.insert(C.end(), R.begin(), R.end());\ntemplate <typename Container, typename Range>\ninline void append_range(Container &C, Range &&R) {\n  C.insert(C.end(), R.begin(), R.end());\n}\n\n/// Given a sequence container Cont, replace the range [ContIt, ContEnd) with\n/// the range [ValIt, ValEnd) (which is not from the same container).\ntemplate<typename Container, typename RandomAccessIterator>\nvoid replace(Container &Cont, typename Container::iterator ContIt,\n             typename Container::iterator ContEnd, RandomAccessIterator ValIt,\n             RandomAccessIterator ValEnd) {\n  while (true) {\n    if (ValIt == ValEnd) {\n      Cont.erase(ContIt, ContEnd);\n      return;\n    } else if (ContIt == ContEnd) {\n      Cont.insert(ContIt, ValIt, ValEnd);\n      return;\n    }\n    *ContIt++ = *ValIt++;\n  }\n}\n\n/// Given a sequence container Cont, replace the range [ContIt, ContEnd) with\n/// the range R.\ntemplate<typename Container, typename Range = std::initializer_list<\n                                 typename Container::value_type>>\nvoid replace(Container &Cont, typename Container::iterator ContIt,\n             typename Container::iterator ContEnd, Range R) {\n  replace(Cont, ContIt, ContEnd, R.begin(), R.end());\n}\n\n/// An STL-style algorithm similar to std::for_each that applies a second\n/// functor between every pair of elements.\n///\n/// This provides the control flow logic to, for example, print a\n/// comma-separated list:\n/// \\code\n///   interleave(names.begin(), names.end(),\n///              [&](StringRef name) { os << name; },\n///              [&] { os << \", \"; });\n/// \\endcode\ntemplate <typename ForwardIterator, typename UnaryFunctor,\n          typename NullaryFunctor,\n          typename = typename std::enable_if<\n              !std::is_constructible<StringRef, UnaryFunctor>::value &&\n              !std::is_constructible<StringRef, NullaryFunctor>::value>::type>\ninline void interleave(ForwardIterator begin, ForwardIterator end,\n                       UnaryFunctor each_fn, NullaryFunctor between_fn) {\n  if (begin == end)\n    return;\n  each_fn(*begin);\n  ++begin;\n  for (; begin != end; ++begin) {\n    between_fn();\n    each_fn(*begin);\n  }\n}\n\ntemplate <typename Container, typename UnaryFunctor, typename NullaryFunctor,\n          typename = typename std::enable_if<\n              !std::is_constructible<StringRef, UnaryFunctor>::value &&\n              !std::is_constructible<StringRef, NullaryFunctor>::value>::type>\ninline void interleave(const Container &c, UnaryFunctor each_fn,\n                       NullaryFunctor between_fn) {\n  interleave(c.begin(), c.end(), each_fn, between_fn);\n}\n\n/// Overload of interleave for the common case of string separator.\ntemplate <typename Container, typename UnaryFunctor, typename StreamT,\n          typename T = detail::ValueOfRange<Container>>\ninline void interleave(const Container &c, StreamT &os, UnaryFunctor each_fn,\n                       const StringRef &separator) {\n  interleave(c.begin(), c.end(), each_fn, [&] { os << separator; });\n}\ntemplate <typename Container, typename StreamT,\n          typename T = detail::ValueOfRange<Container>>\ninline void interleave(const Container &c, StreamT &os,\n                       const StringRef &separator) {\n  interleave(\n      c, os, [&](const T &a) { os << a; }, separator);\n}\n\ntemplate <typename Container, typename UnaryFunctor, typename StreamT,\n          typename T = detail::ValueOfRange<Container>>\ninline void interleaveComma(const Container &c, StreamT &os,\n                            UnaryFunctor each_fn) {\n  interleave(c, os, each_fn, \", \");\n}\ntemplate <typename Container, typename StreamT,\n          typename T = detail::ValueOfRange<Container>>\ninline void interleaveComma(const Container &c, StreamT &os) {\n  interleaveComma(c, os, [&](const T &a) { os << a; });\n}\n\n//===----------------------------------------------------------------------===//\n//     Extra additions to <memory>\n//===----------------------------------------------------------------------===//\n\nstruct FreeDeleter {\n  void operator()(void* v) {\n    ::free(v);\n  }\n};\n\ntemplate<typename First, typename Second>\nstruct pair_hash {\n  size_t operator()(const std::pair<First, Second> &P) const {\n    return std::hash<First>()(P.first) * 31 + std::hash<Second>()(P.second);\n  }\n};\n\n/// Binary functor that adapts to any other binary functor after dereferencing\n/// operands.\ntemplate <typename T> struct deref {\n  T func;\n\n  // Could be further improved to cope with non-derivable functors and\n  // non-binary functors (should be a variadic template member function\n  // operator()).\n  template <typename A, typename B> auto operator()(A &lhs, B &rhs) const {\n    assert(lhs);\n    assert(rhs);\n    return func(*lhs, *rhs);\n  }\n};\n\nnamespace detail {\n\ntemplate <typename R> class enumerator_iter;\n\ntemplate <typename R> struct result_pair {\n  using value_reference =\n      typename std::iterator_traits<IterOfRange<R>>::reference;\n\n  friend class enumerator_iter<R>;\n\n  result_pair() = default;\n  result_pair(std::size_t Index, IterOfRange<R> Iter)\n      : Index(Index), Iter(Iter) {}\n\n  result_pair(const result_pair<R> &Other)\n      : Index(Other.Index), Iter(Other.Iter) {}\n  result_pair &operator=(const result_pair &Other) {\n    Index = Other.Index;\n    Iter = Other.Iter;\n    return *this;\n  }\n\n  std::size_t index() const { return Index; }\n  const value_reference value() const { return *Iter; }\n  value_reference value() { return *Iter; }\n\nprivate:\n  std::size_t Index = std::numeric_limits<std::size_t>::max();\n  IterOfRange<R> Iter;\n};\n\ntemplate <typename R>\nclass enumerator_iter\n    : public iterator_facade_base<\n          enumerator_iter<R>, std::forward_iterator_tag, result_pair<R>,\n          typename std::iterator_traits<IterOfRange<R>>::difference_type,\n          typename std::iterator_traits<IterOfRange<R>>::pointer,\n          typename std::iterator_traits<IterOfRange<R>>::reference> {\n  using result_type = result_pair<R>;\n\npublic:\n  explicit enumerator_iter(IterOfRange<R> EndIter)\n      : Result(std::numeric_limits<size_t>::max(), EndIter) {}\n\n  enumerator_iter(std::size_t Index, IterOfRange<R> Iter)\n      : Result(Index, Iter) {}\n\n  result_type &operator*() { return Result; }\n  const result_type &operator*() const { return Result; }\n\n  enumerator_iter &operator++() {\n    assert(Result.Index != std::numeric_limits<size_t>::max());\n    ++Result.Iter;\n    ++Result.Index;\n    return *this;\n  }\n\n  bool operator==(const enumerator_iter &RHS) const {\n    // Don't compare indices here, only iterators.  It's possible for an end\n    // iterator to have different indices depending on whether it was created\n    // by calling std::end() versus incrementing a valid iterator.\n    return Result.Iter == RHS.Result.Iter;\n  }\n\n  enumerator_iter(const enumerator_iter &Other) : Result(Other.Result) {}\n  enumerator_iter &operator=(const enumerator_iter &Other) {\n    Result = Other.Result;\n    return *this;\n  }\n\nprivate:\n  result_type Result;\n};\n\ntemplate <typename R> class enumerator {\npublic:\n  explicit enumerator(R &&Range) : TheRange(std::forward<R>(Range)) {}\n\n  enumerator_iter<R> begin() {\n    return enumerator_iter<R>(0, std::begin(TheRange));\n  }\n\n  enumerator_iter<R> end() {\n    return enumerator_iter<R>(std::end(TheRange));\n  }\n\nprivate:\n  R TheRange;\n};\n\n} // end namespace detail\n\n/// Given an input range, returns a new range whose values are are pair (A,B)\n/// such that A is the 0-based index of the item in the sequence, and B is\n/// the value from the original sequence.  Example:\n///\n/// std::vector<char> Items = {'A', 'B', 'C', 'D'};\n/// for (auto X : enumerate(Items)) {\n///   printf(\"Item %d - %c\\n\", X.index(), X.value());\n/// }\n///\n/// Output:\n///   Item 0 - A\n///   Item 1 - B\n///   Item 2 - C\n///   Item 3 - D\n///\ntemplate <typename R> detail::enumerator<R> enumerate(R &&TheRange) {\n  return detail::enumerator<R>(std::forward<R>(TheRange));\n}\n\nnamespace detail {\n\ntemplate <typename F, typename Tuple, std::size_t... I>\ndecltype(auto) apply_tuple_impl(F &&f, Tuple &&t, std::index_sequence<I...>) {\n  return std::forward<F>(f)(std::get<I>(std::forward<Tuple>(t))...);\n}\n\n} // end namespace detail\n\n/// Given an input tuple (a1, a2, ..., an), pass the arguments of the\n/// tuple variadically to f as if by calling f(a1, a2, ..., an) and\n/// return the result.\ntemplate <typename F, typename Tuple>\ndecltype(auto) apply_tuple(F &&f, Tuple &&t) {\n  using Indices = std::make_index_sequence<\n      std::tuple_size<typename std::decay<Tuple>::type>::value>;\n\n  return detail::apply_tuple_impl(std::forward<F>(f), std::forward<Tuple>(t),\n                                  Indices{});\n}\n\n/// Return true if the sequence [Begin, End) has exactly N items. Runs in O(N)\n/// time. Not meant for use with random-access iterators.\n/// Can optionally take a predicate to filter lazily some items.\ntemplate <typename IterTy,\n          typename Pred = bool (*)(const decltype(*std::declval<IterTy>()) &)>\nbool hasNItems(\n    IterTy &&Begin, IterTy &&End, unsigned N,\n    Pred &&ShouldBeCounted =\n        [](const decltype(*std::declval<IterTy>()) &) { return true; },\n    std::enable_if_t<\n        !std::is_base_of<std::random_access_iterator_tag,\n                         typename std::iterator_traits<std::remove_reference_t<\n                             decltype(Begin)>>::iterator_category>::value,\n        void> * = nullptr) {\n  for (; N; ++Begin) {\n    if (Begin == End)\n      return false; // Too few.\n    N -= ShouldBeCounted(*Begin);\n  }\n  for (; Begin != End; ++Begin)\n    if (ShouldBeCounted(*Begin))\n      return false; // Too many.\n  return true;\n}\n\n/// Return true if the sequence [Begin, End) has N or more items. Runs in O(N)\n/// time. Not meant for use with random-access iterators.\n/// Can optionally take a predicate to lazily filter some items.\ntemplate <typename IterTy,\n          typename Pred = bool (*)(const decltype(*std::declval<IterTy>()) &)>\nbool hasNItemsOrMore(\n    IterTy &&Begin, IterTy &&End, unsigned N,\n    Pred &&ShouldBeCounted =\n        [](const decltype(*std::declval<IterTy>()) &) { return true; },\n    std::enable_if_t<\n        !std::is_base_of<std::random_access_iterator_tag,\n                         typename std::iterator_traits<std::remove_reference_t<\n                             decltype(Begin)>>::iterator_category>::value,\n        void> * = nullptr) {\n  for (; N; ++Begin) {\n    if (Begin == End)\n      return false; // Too few.\n    N -= ShouldBeCounted(*Begin);\n  }\n  return true;\n}\n\n/// Returns true if the sequence [Begin, End) has N or less items. Can\n/// optionally take a predicate to lazily filter some items.\ntemplate <typename IterTy,\n          typename Pred = bool (*)(const decltype(*std::declval<IterTy>()) &)>\nbool hasNItemsOrLess(\n    IterTy &&Begin, IterTy &&End, unsigned N,\n    Pred &&ShouldBeCounted = [](const decltype(*std::declval<IterTy>()) &) {\n      return true;\n    }) {\n  assert(N != std::numeric_limits<unsigned>::max());\n  return !hasNItemsOrMore(Begin, End, N + 1, ShouldBeCounted);\n}\n\n/// Returns true if the given container has exactly N items\ntemplate <typename ContainerTy> bool hasNItems(ContainerTy &&C, unsigned N) {\n  return hasNItems(std::begin(C), std::end(C), N);\n}\n\n/// Returns true if the given container has N or more items\ntemplate <typename ContainerTy>\nbool hasNItemsOrMore(ContainerTy &&C, unsigned N) {\n  return hasNItemsOrMore(std::begin(C), std::end(C), N);\n}\n\n/// Returns true if the given container has N or less items\ntemplate <typename ContainerTy>\nbool hasNItemsOrLess(ContainerTy &&C, unsigned N) {\n  return hasNItemsOrLess(std::begin(C), std::end(C), N);\n}\n\n/// Returns a raw pointer that represents the same address as the argument.\n///\n/// This implementation can be removed once we move to C++20 where it's defined\n/// as std::to_address().\n///\n/// The std::pointer_traits<>::to_address(p) variations of these overloads has\n/// not been implemented.\ntemplate <class Ptr> auto to_address(const Ptr &P) { return P.operator->(); }\ntemplate <class T> constexpr T *to_address(T *P) { return P; }\n\n} // end namespace llvm\n\n#endif // LLVM_ADT_STLEXTRAS_H\n"}, "59": {"id": 59, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/SmallBitVector.h", "content": "//===- llvm/ADT/SmallBitVector.h - 'Normally small' bit vectors -*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// This file implements the SmallBitVector class.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_ADT_SMALLBITVECTOR_H\n#define LLVM_ADT_SMALLBITVECTOR_H\n\n#include \"llvm/ADT/BitVector.h\"\n#include \"llvm/ADT/iterator_range.h\"\n#include \"llvm/Support/MathExtras.h\"\n#include <algorithm>\n#include <cassert>\n#include <climits>\n#include <cstddef>\n#include <cstdint>\n#include <limits>\n#include <utility>\n\nnamespace llvm {\n\n/// This is a 'bitvector' (really, a variable-sized bit array), optimized for\n/// the case when the array is small. It contains one pointer-sized field, which\n/// is directly used as a plain collection of bits when possible, or as a\n/// pointer to a larger heap-allocated array when necessary. This allows normal\n/// \"small\" cases to be fast without losing generality for large inputs.\nclass SmallBitVector {\n  // TODO: In \"large\" mode, a pointer to a BitVector is used, leading to an\n  // unnecessary level of indirection. It would be more efficient to use a\n  // pointer to memory containing size, allocation size, and the array of bits.\n  uintptr_t X = 1;\n\n  enum {\n    // The number of bits in this class.\n    NumBaseBits = sizeof(uintptr_t) * CHAR_BIT,\n\n    // One bit is used to discriminate between small and large mode. The\n    // remaining bits are used for the small-mode representation.\n    SmallNumRawBits = NumBaseBits - 1,\n\n    // A few more bits are used to store the size of the bit set in small mode.\n    // Theoretically this is a ceil-log2. These bits are encoded in the most\n    // significant bits of the raw bits.\n    SmallNumSizeBits = (NumBaseBits == 32 ? 5 :\n                        NumBaseBits == 64 ? 6 :\n                        SmallNumRawBits),\n\n    // The remaining bits are used to store the actual set in small mode.\n    SmallNumDataBits = SmallNumRawBits - SmallNumSizeBits\n  };\n\n  static_assert(NumBaseBits == 64 || NumBaseBits == 32,\n                \"Unsupported word size\");\n\npublic:\n  using size_type = unsigned;\n\n  // Encapsulation of a single bit.\n  class reference {\n    SmallBitVector &TheVector;\n    unsigned BitPos;\n\n  public:\n    reference(SmallBitVector &b, unsigned Idx) : TheVector(b), BitPos(Idx) {}\n\n    reference(const reference&) = default;\n\n    reference& operator=(reference t) {\n      *this = bool(t);\n      return *this;\n    }\n\n    reference& operator=(bool t) {\n      if (t)\n        TheVector.set(BitPos);\n      else\n        TheVector.reset(BitPos);\n      return *this;\n    }\n\n    operator bool() const {\n      return const_cast<const SmallBitVector &>(TheVector).operator[](BitPos);\n    }\n  };\n\nprivate:\n  BitVector *getPointer() const {\n    assert(!isSmall());\n    return reinterpret_cast<BitVector *>(X);\n  }\n\n  void switchToSmall(uintptr_t NewSmallBits, size_t NewSize) {\n    X = 1;\n    setSmallSize(NewSize);\n    setSmallBits(NewSmallBits);\n  }\n\n  void switchToLarge(BitVector *BV) {\n    X = reinterpret_cast<uintptr_t>(BV);\n    assert(!isSmall() && \"Tried to use an unaligned pointer\");\n  }\n\n  // Return all the bits used for the \"small\" representation; this includes\n  // bits for the size as well as the element bits.\n  uintptr_t getSmallRawBits() const {\n    assert(isSmall());\n    return X >> 1;\n  }\n\n  void setSmallRawBits(uintptr_t NewRawBits) {\n    assert(isSmall());\n    X = (NewRawBits << 1) | uintptr_t(1);\n  }\n\n  // Return the size.\n  size_t getSmallSize() const { return getSmallRawBits() >> SmallNumDataBits; }\n\n  void setSmallSize(size_t Size) {\n    setSmallRawBits(getSmallBits() | (Size << SmallNumDataBits));\n  }\n\n  // Return the element bits.\n  uintptr_t getSmallBits() const {\n    return getSmallRawBits() & ~(~uintptr_t(0) << getSmallSize());\n  }\n\n  void setSmallBits(uintptr_t NewBits) {\n    setSmallRawBits((NewBits & ~(~uintptr_t(0) << getSmallSize())) |\n                    (getSmallSize() << SmallNumDataBits));\n  }\n\npublic:\n  /// Creates an empty bitvector.\n  SmallBitVector() = default;\n\n  /// Creates a bitvector of specified number of bits. All bits are initialized\n  /// to the specified value.\n  explicit SmallBitVector(unsigned s, bool t = false) {\n    if (s <= SmallNumDataBits)\n      switchToSmall(t ? ~uintptr_t(0) : 0, s);\n    else\n      switchToLarge(new BitVector(s, t));\n  }\n\n  /// SmallBitVector copy ctor.\n  SmallBitVector(const SmallBitVector &RHS) {\n    if (RHS.isSmall())\n      X = RHS.X;\n    else\n      switchToLarge(new BitVector(*RHS.getPointer()));\n  }\n\n  SmallBitVector(SmallBitVector &&RHS) : X(RHS.X) {\n    RHS.X = 1;\n  }\n\n  ~SmallBitVector() {\n    if (!isSmall())\n      delete getPointer();\n  }\n\n  using const_set_bits_iterator = const_set_bits_iterator_impl<SmallBitVector>;\n  using set_iterator = const_set_bits_iterator;\n\n  const_set_bits_iterator set_bits_begin() const {\n    return const_set_bits_iterator(*this);\n  }\n\n  const_set_bits_iterator set_bits_end() const {\n    return const_set_bits_iterator(*this, -1);\n  }\n\n  iterator_range<const_set_bits_iterator> set_bits() const {\n    return make_range(set_bits_begin(), set_bits_end());\n  }\n\n  bool isSmall() const { return X & uintptr_t(1); }\n\n  /// Tests whether there are no bits in this bitvector.\n  bool empty() const {\n    return isSmall() ? getSmallSize() == 0 : getPointer()->empty();\n  }\n\n  /// Returns the number of bits in this bitvector.\n  size_t size() const {\n    return isSmall() ? getSmallSize() : getPointer()->size();\n  }\n\n  /// Returns the number of bits which are set.\n  size_type count() const {\n    if (isSmall()) {\n      uintptr_t Bits = getSmallBits();\n      return countPopulation(Bits);\n    }\n    return getPointer()->count();\n  }\n\n  /// Returns true if any bit is set.\n  bool any() const {\n    if (isSmall())\n      return getSmallBits() != 0;\n    return getPointer()->any();\n  }\n\n  /// Returns true if all bits are set.\n  bool all() const {\n    if (isSmall())\n      return getSmallBits() == (uintptr_t(1) << getSmallSize()) - 1;\n    return getPointer()->all();\n  }\n\n  /// Returns true if none of the bits are set.\n  bool none() const {\n    if (isSmall())\n      return getSmallBits() == 0;\n    return getPointer()->none();\n  }\n\n  /// Returns the index of the first set bit, -1 if none of the bits are set.\n  int find_first() const {\n    if (isSmall()) {\n      uintptr_t Bits = getSmallBits();\n      if (Bits == 0)\n        return -1;\n      return countTrailingZeros(Bits);\n    }\n    return getPointer()->find_first();\n  }\n\n  int find_last() const {\n    if (isSmall()) {\n      uintptr_t Bits = getSmallBits();\n      if (Bits == 0)\n        return -1;\n      return NumBaseBits - countLeadingZeros(Bits) - 1;\n    }\n    return getPointer()->find_last();\n  }\n\n  /// Returns the index of the first unset bit, -1 if all of the bits are set.\n  int find_first_unset() const {\n    if (isSmall()) {\n      if (count() == getSmallSize())\n        return -1;\n\n      uintptr_t Bits = getSmallBits();\n      return countTrailingOnes(Bits);\n    }\n    return getPointer()->find_first_unset();\n  }\n\n  int find_last_unset() const {\n    if (isSmall()) {\n      if (count() == getSmallSize())\n        return -1;\n\n      uintptr_t Bits = getSmallBits();\n      // Set unused bits.\n      Bits |= ~uintptr_t(0) << getSmallSize();\n      return NumBaseBits - countLeadingOnes(Bits) - 1;\n    }\n    return getPointer()->find_last_unset();\n  }\n\n  /// Returns the index of the next set bit following the \"Prev\" bit.\n  /// Returns -1 if the next set bit is not found.\n  int find_next(unsigned Prev) const {\n    if (isSmall()) {\n      uintptr_t Bits = getSmallBits();\n      // Mask off previous bits.\n      Bits &= ~uintptr_t(0) << (Prev + 1);\n      if (Bits == 0 || Prev + 1 >= getSmallSize())\n        return -1;\n      return countTrailingZeros(Bits);\n    }\n    return getPointer()->find_next(Prev);\n  }\n\n  /// Returns the index of the next unset bit following the \"Prev\" bit.\n  /// Returns -1 if the next unset bit is not found.\n  int find_next_unset(unsigned Prev) const {\n    if (isSmall()) {\n      uintptr_t Bits = getSmallBits();\n      // Mask in previous bits.\n      Bits |= (uintptr_t(1) << (Prev + 1)) - 1;\n      // Mask in unused bits.\n      Bits |= ~uintptr_t(0) << getSmallSize();\n\n      if (Bits == ~uintptr_t(0) || Prev + 1 >= getSmallSize())\n        return -1;\n      return countTrailingOnes(Bits);\n    }\n    return getPointer()->find_next_unset(Prev);\n  }\n\n  /// find_prev - Returns the index of the first set bit that precedes the\n  /// the bit at \\p PriorTo.  Returns -1 if all previous bits are unset.\n  int find_prev(unsigned PriorTo) const {\n    if (isSmall()) {\n      if (PriorTo == 0)\n        return -1;\n\n      --PriorTo;\n      uintptr_t Bits = getSmallBits();\n      Bits &= maskTrailingOnes<uintptr_t>(PriorTo + 1);\n      if (Bits == 0)\n        return -1;\n\n      return NumBaseBits - countLeadingZeros(Bits) - 1;\n    }\n    return getPointer()->find_prev(PriorTo);\n  }\n\n  /// Clear all bits.\n  void clear() {\n    if (!isSmall())\n      delete getPointer();\n    switchToSmall(0, 0);\n  }\n\n  /// Grow or shrink the bitvector.\n  void resize(unsigned N, bool t = false) {\n    if (!isSmall()) {\n      getPointer()->resize(N, t);\n    } else if (SmallNumDataBits >= N) {\n      uintptr_t NewBits = t ? ~uintptr_t(0) << getSmallSize() : 0;\n      setSmallSize(N);\n      setSmallBits(NewBits | getSmallBits());\n    } else {\n      BitVector *BV = new BitVector(N, t);\n      uintptr_t OldBits = getSmallBits();\n      for (size_t i = 0, e = getSmallSize(); i != e; ++i)\n        (*BV)[i] = (OldBits >> i) & 1;\n      switchToLarge(BV);\n    }\n  }\n\n  void reserve(unsigned N) {\n    if (isSmall()) {\n      if (N > SmallNumDataBits) {\n        uintptr_t OldBits = getSmallRawBits();\n        size_t SmallSize = getSmallSize();\n        BitVector *BV = new BitVector(SmallSize);\n        for (size_t i = 0; i < SmallSize; ++i)\n          if ((OldBits >> i) & 1)\n            BV->set(i);\n        BV->reserve(N);\n        switchToLarge(BV);\n      }\n    } else {\n      getPointer()->reserve(N);\n    }\n  }\n\n  // Set, reset, flip\n  SmallBitVector &set() {\n    if (isSmall())\n      setSmallBits(~uintptr_t(0));\n    else\n      getPointer()->set();\n    return *this;\n  }\n\n  SmallBitVector &set(unsigned Idx) {\n    if (isSmall()) {\n      assert(Idx <= static_cast<unsigned>(\n                        std::numeric_limits<uintptr_t>::digits) &&\n             \"undefined behavior\");\n      setSmallBits(getSmallBits() | (uintptr_t(1) << Idx));\n    }\n    else\n      getPointer()->set(Idx);\n    return *this;\n  }\n\n  /// Efficiently set a range of bits in [I, E)\n  SmallBitVector &set(unsigned I, unsigned E) {\n    assert(I <= E && \"Attempted to set backwards range!\");\n    assert(E <= size() && \"Attempted to set out-of-bounds range!\");\n    if (I == E) return *this;\n    if (isSmall()) {\n      uintptr_t EMask = ((uintptr_t)1) << E;\n      uintptr_t IMask = ((uintptr_t)1) << I;\n      uintptr_t Mask = EMask - IMask;\n      setSmallBits(getSmallBits() | Mask);\n    } else\n      getPointer()->set(I, E);\n    return *this;\n  }\n\n  SmallBitVector &reset() {\n    if (isSmall())\n      setSmallBits(0);\n    else\n      getPointer()->reset();\n    return *this;\n  }\n\n  SmallBitVector &reset(unsigned Idx) {\n    if (isSmall())\n      setSmallBits(getSmallBits() & ~(uintptr_t(1) << Idx));\n    else\n      getPointer()->reset(Idx);\n    return *this;\n  }\n\n  /// Efficiently reset a range of bits in [I, E)\n  SmallBitVector &reset(unsigned I, unsigned E) {\n    assert(I <= E && \"Attempted to reset backwards range!\");\n    assert(E <= size() && \"Attempted to reset out-of-bounds range!\");\n    if (I == E) return *this;\n    if (isSmall()) {\n      uintptr_t EMask = ((uintptr_t)1) << E;\n      uintptr_t IMask = ((uintptr_t)1) << I;\n      uintptr_t Mask = EMask - IMask;\n      setSmallBits(getSmallBits() & ~Mask);\n    } else\n      getPointer()->reset(I, E);\n    return *this;\n  }\n\n  SmallBitVector &flip() {\n    if (isSmall())\n      setSmallBits(~getSmallBits());\n    else\n      getPointer()->flip();\n    return *this;\n  }\n\n  SmallBitVector &flip(unsigned Idx) {\n    if (isSmall())\n      setSmallBits(getSmallBits() ^ (uintptr_t(1) << Idx));\n    else\n      getPointer()->flip(Idx);\n    return *this;\n  }\n\n  // No argument flip.\n  SmallBitVector operator~() const {\n    return SmallBitVector(*this).flip();\n  }\n\n  // Indexing.\n  reference operator[](unsigned Idx) {\n    assert(Idx < size() && \"Out-of-bounds Bit access.\");\n    return reference(*this, Idx);\n  }\n\n  bool operator[](unsigned Idx) const {\n    assert(Idx < size() && \"Out-of-bounds Bit access.\");\n    if (isSmall())\n      return ((getSmallBits() >> Idx) & 1) != 0;\n    return getPointer()->operator[](Idx);\n  }\n\n  bool test(unsigned Idx) const {\n    return (*this)[Idx];\n  }\n\n  // Push single bit to end of vector.\n  void push_back(bool Val) {\n    resize(size() + 1, Val);\n  }\n\n  /// Test if any common bits are set.\n  bool anyCommon(const SmallBitVector &RHS) const {\n    if (isSmall() && RHS.isSmall())\n      return (getSmallBits() & RHS.getSmallBits()) != 0;\n    if (!isSmall() && !RHS.isSmall())\n      return getPointer()->anyCommon(*RHS.getPointer());\n\n    for (unsigned i = 0, e = std::min(size(), RHS.size()); i != e; ++i)\n      if (test(i) && RHS.test(i))\n        return true;\n    return false;\n  }\n\n  // Comparison operators.\n  bool operator==(const SmallBitVector &RHS) const {\n    if (size() != RHS.size())\n      return false;\n    if (isSmall() && RHS.isSmall())\n      return getSmallBits() == RHS.getSmallBits();\n    else if (!isSmall() && !RHS.isSmall())\n      return *getPointer() == *RHS.getPointer();\n    else {\n      for (size_t i = 0, e = size(); i != e; ++i) {\n        if ((*this)[i] != RHS[i])\n          return false;\n      }\n      return true;\n    }\n  }\n\n  bool operator!=(const SmallBitVector &RHS) const {\n    return !(*this == RHS);\n  }\n\n  // Intersection, union, disjoint union.\n  // FIXME BitVector::operator&= does not resize the LHS but this does\n  SmallBitVector &operator&=(const SmallBitVector &RHS) {\n    resize(std::max(size(), RHS.size()));\n    if (isSmall() && RHS.isSmall())\n      setSmallBits(getSmallBits() & RHS.getSmallBits());\n    else if (!isSmall() && !RHS.isSmall())\n      getPointer()->operator&=(*RHS.getPointer());\n    else {\n      size_t i, e;\n      for (i = 0, e = std::min(size(), RHS.size()); i != e; ++i)\n        (*this)[i] = test(i) && RHS.test(i);\n      for (e = size(); i != e; ++i)\n        reset(i);\n    }\n    return *this;\n  }\n\n  /// Reset bits that are set in RHS. Same as *this &= ~RHS.\n  SmallBitVector &reset(const SmallBitVector &RHS) {\n    if (isSmall() && RHS.isSmall())\n      setSmallBits(getSmallBits() & ~RHS.getSmallBits());\n    else if (!isSmall() && !RHS.isSmall())\n      getPointer()->reset(*RHS.getPointer());\n    else\n      for (unsigned i = 0, e = std::min(size(), RHS.size()); i != e; ++i)\n        if (RHS.test(i))\n          reset(i);\n\n    return *this;\n  }\n\n  /// Check if (This - RHS) is zero. This is the same as reset(RHS) and any().\n  bool test(const SmallBitVector &RHS) const {\n    if (isSmall() && RHS.isSmall())\n      return (getSmallBits() & ~RHS.getSmallBits()) != 0;\n    if (!isSmall() && !RHS.isSmall())\n      return getPointer()->test(*RHS.getPointer());\n\n    unsigned i, e;\n    for (i = 0, e = std::min(size(), RHS.size()); i != e; ++i)\n      if (test(i) && !RHS.test(i))\n        return true;\n\n    for (e = size(); i != e; ++i)\n      if (test(i))\n        return true;\n\n    return false;\n  }\n\n  SmallBitVector &operator|=(const SmallBitVector &RHS) {\n    resize(std::max(size(), RHS.size()));\n    if (isSmall() && RHS.isSmall())\n      setSmallBits(getSmallBits() | RHS.getSmallBits());\n    else if (!isSmall() && !RHS.isSmall())\n      getPointer()->operator|=(*RHS.getPointer());\n    else {\n      for (size_t i = 0, e = RHS.size(); i != e; ++i)\n        (*this)[i] = test(i) || RHS.test(i);\n    }\n    return *this;\n  }\n\n  SmallBitVector &operator^=(const SmallBitVector &RHS) {\n    resize(std::max(size(), RHS.size()));\n    if (isSmall() && RHS.isSmall())\n      setSmallBits(getSmallBits() ^ RHS.getSmallBits());\n    else if (!isSmall() && !RHS.isSmall())\n      getPointer()->operator^=(*RHS.getPointer());\n    else {\n      for (size_t i = 0, e = RHS.size(); i != e; ++i)\n        (*this)[i] = test(i) != RHS.test(i);\n    }\n    return *this;\n  }\n\n  SmallBitVector &operator<<=(unsigned N) {\n    if (isSmall())\n      setSmallBits(getSmallBits() << N);\n    else\n      getPointer()->operator<<=(N);\n    return *this;\n  }\n\n  SmallBitVector &operator>>=(unsigned N) {\n    if (isSmall())\n      setSmallBits(getSmallBits() >> N);\n    else\n      getPointer()->operator>>=(N);\n    return *this;\n  }\n\n  // Assignment operator.\n  const SmallBitVector &operator=(const SmallBitVector &RHS) {\n    if (isSmall()) {\n      if (RHS.isSmall())\n        X = RHS.X;\n      else\n        switchToLarge(new BitVector(*RHS.getPointer()));\n    } else {\n      if (!RHS.isSmall())\n        *getPointer() = *RHS.getPointer();\n      else {\n        delete getPointer();\n        X = RHS.X;\n      }\n    }\n    return *this;\n  }\n\n  const SmallBitVector &operator=(SmallBitVector &&RHS) {\n    if (this != &RHS) {\n      clear();\n      swap(RHS);\n    }\n    return *this;\n  }\n\n  void swap(SmallBitVector &RHS) {\n    std::swap(X, RHS.X);\n  }\n\n  /// Add '1' bits from Mask to this vector. Don't resize.\n  /// This computes \"*this |= Mask\".\n  void setBitsInMask(const uint32_t *Mask, unsigned MaskWords = ~0u) {\n    if (isSmall())\n      applyMask<true, false>(Mask, MaskWords);\n    else\n      getPointer()->setBitsInMask(Mask, MaskWords);\n  }\n\n  /// Clear any bits in this vector that are set in Mask. Don't resize.\n  /// This computes \"*this &= ~Mask\".\n  void clearBitsInMask(const uint32_t *Mask, unsigned MaskWords = ~0u) {\n    if (isSmall())\n      applyMask<false, false>(Mask, MaskWords);\n    else\n      getPointer()->clearBitsInMask(Mask, MaskWords);\n  }\n\n  /// Add a bit to this vector for every '0' bit in Mask. Don't resize.\n  /// This computes \"*this |= ~Mask\".\n  void setBitsNotInMask(const uint32_t *Mask, unsigned MaskWords = ~0u) {\n    if (isSmall())\n      applyMask<true, true>(Mask, MaskWords);\n    else\n      getPointer()->setBitsNotInMask(Mask, MaskWords);\n  }\n\n  /// Clear a bit in this vector for every '0' bit in Mask. Don't resize.\n  /// This computes \"*this &= Mask\".\n  void clearBitsNotInMask(const uint32_t *Mask, unsigned MaskWords = ~0u) {\n    if (isSmall())\n      applyMask<false, true>(Mask, MaskWords);\n    else\n      getPointer()->clearBitsNotInMask(Mask, MaskWords);\n  }\n\n  void invalid() {\n    assert(empty());\n    X = (uintptr_t)-1;\n  }\n  bool isInvalid() const { return X == (uintptr_t)-1; }\n\n  ArrayRef<uintptr_t> getData(uintptr_t &Store) const {\n    if (!isSmall())\n      return getPointer()->getData();\n    Store = getSmallBits();\n    return makeArrayRef(Store);\n  }\n\nprivate:\n  template <bool AddBits, bool InvertMask>\n  void applyMask(const uint32_t *Mask, unsigned MaskWords) {\n    assert(MaskWords <= sizeof(uintptr_t) && \"Mask is larger than base!\");\n    uintptr_t M = Mask[0];\n    if (NumBaseBits == 64)\n      M |= uint64_t(Mask[1]) << 32;\n    if (InvertMask)\n      M = ~M;\n    if (AddBits)\n      setSmallBits(getSmallBits() | M);\n    else\n      setSmallBits(getSmallBits() & ~M);\n  }\n};\n\ninline SmallBitVector\noperator&(const SmallBitVector &LHS, const SmallBitVector &RHS) {\n  SmallBitVector Result(LHS);\n  Result &= RHS;\n  return Result;\n}\n\ninline SmallBitVector\noperator|(const SmallBitVector &LHS, const SmallBitVector &RHS) {\n  SmallBitVector Result(LHS);\n  Result |= RHS;\n  return Result;\n}\n\ninline SmallBitVector\noperator^(const SmallBitVector &LHS, const SmallBitVector &RHS) {\n  SmallBitVector Result(LHS);\n  Result ^= RHS;\n  return Result;\n}\n\ntemplate <> struct DenseMapInfo<SmallBitVector> {\n  static inline SmallBitVector getEmptyKey() { return SmallBitVector(); }\n  static inline SmallBitVector getTombstoneKey() {\n    SmallBitVector V;\n    V.invalid();\n    return V;\n  }\n  static unsigned getHashValue(const SmallBitVector &V) {\n    uintptr_t Store;\n    return DenseMapInfo<std::pair<unsigned, ArrayRef<uintptr_t>>>::getHashValue(\n        std::make_pair(V.size(), V.getData(Store)));\n  }\n  static bool isEqual(const SmallBitVector &LHS, const SmallBitVector &RHS) {\n    if (LHS.isInvalid() || RHS.isInvalid())\n      return LHS.isInvalid() == RHS.isInvalid();\n    return LHS == RHS;\n  }\n};\n} // end namespace llvm\n\nnamespace std {\n\n/// Implement std::swap in terms of BitVector swap.\ninline void\nswap(llvm::SmallBitVector &LHS, llvm::SmallBitVector &RHS) {\n  LHS.swap(RHS);\n}\n\n} // end namespace std\n\n#endif // LLVM_ADT_SMALLBITVECTOR_H\n"}, "62": {"id": 62, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/StringMap.h", "content": "//===- StringMap.h - String Hash table map interface ------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// This file defines the StringMap class.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_ADT_STRINGMAP_H\n#define LLVM_ADT_STRINGMAP_H\n\n#include \"llvm/ADT/StringMapEntry.h\"\n#include \"llvm/Support/AllocatorBase.h\"\n#include \"llvm/Support/PointerLikeTypeTraits.h\"\n#include <initializer_list>\n#include <iterator>\n\nnamespace llvm {\n\ntemplate <typename ValueTy> class StringMapConstIterator;\ntemplate <typename ValueTy> class StringMapIterator;\ntemplate <typename ValueTy> class StringMapKeyIterator;\n\n/// StringMapImpl - This is the base class of StringMap that is shared among\n/// all of its instantiations.\nclass StringMapImpl {\nprotected:\n  // Array of NumBuckets pointers to entries, null pointers are holes.\n  // TheTable[NumBuckets] contains a sentinel value for easy iteration. Followed\n  // by an array of the actual hash values as unsigned integers.\n  StringMapEntryBase **TheTable = nullptr;\n  unsigned NumBuckets = 0;\n  unsigned NumItems = 0;\n  unsigned NumTombstones = 0;\n  unsigned ItemSize;\n\nprotected:\n  explicit StringMapImpl(unsigned itemSize) : ItemSize(itemSize) {}\n  StringMapImpl(StringMapImpl &&RHS)\n      : TheTable(RHS.TheTable), NumBuckets(RHS.NumBuckets),\n        NumItems(RHS.NumItems), NumTombstones(RHS.NumTombstones),\n        ItemSize(RHS.ItemSize) {\n    RHS.TheTable = nullptr;\n    RHS.NumBuckets = 0;\n    RHS.NumItems = 0;\n    RHS.NumTombstones = 0;\n  }\n\n  StringMapImpl(unsigned InitSize, unsigned ItemSize);\n  unsigned RehashTable(unsigned BucketNo = 0);\n\n  /// LookupBucketFor - Look up the bucket that the specified string should end\n  /// up in.  If it already exists as a key in the map, the Item pointer for the\n  /// specified bucket will be non-null.  Otherwise, it will be null.  In either\n  /// case, the FullHashValue field of the bucket will be set to the hash value\n  /// of the string.\n  unsigned LookupBucketFor(StringRef Key);\n\n  /// FindKey - Look up the bucket that contains the specified key. If it exists\n  /// in the map, return the bucket number of the key.  Otherwise return -1.\n  /// This does not modify the map.\n  int FindKey(StringRef Key) const;\n\n  /// RemoveKey - Remove the specified StringMapEntry from the table, but do not\n  /// delete it.  This aborts if the value isn't in the table.\n  void RemoveKey(StringMapEntryBase *V);\n\n  /// RemoveKey - Remove the StringMapEntry for the specified key from the\n  /// table, returning it.  If the key is not in the table, this returns null.\n  StringMapEntryBase *RemoveKey(StringRef Key);\n\n  /// Allocate the table with the specified number of buckets and otherwise\n  /// setup the map as empty.\n  void init(unsigned Size);\n\npublic:\n  static constexpr uintptr_t TombstoneIntVal =\n      static_cast<uintptr_t>(-1)\n      << PointerLikeTypeTraits<StringMapEntryBase *>::NumLowBitsAvailable;\n\n  static StringMapEntryBase *getTombstoneVal() {\n    return reinterpret_cast<StringMapEntryBase *>(TombstoneIntVal);\n  }\n\n  unsigned getNumBuckets() const { return NumBuckets; }\n  unsigned getNumItems() const { return NumItems; }\n\n  bool empty() const { return NumItems == 0; }\n  unsigned size() const { return NumItems; }\n\n  void swap(StringMapImpl &Other) {\n    std::swap(TheTable, Other.TheTable);\n    std::swap(NumBuckets, Other.NumBuckets);\n    std::swap(NumItems, Other.NumItems);\n    std::swap(NumTombstones, Other.NumTombstones);\n  }\n};\n\n/// StringMap - This is an unconventional map that is specialized for handling\n/// keys that are \"strings\", which are basically ranges of bytes. This does some\n/// funky memory allocation and hashing things to make it extremely efficient,\n/// storing the string data *after* the value in the map.\ntemplate <typename ValueTy, typename AllocatorTy = MallocAllocator>\nclass StringMap : public StringMapImpl {\n  AllocatorTy Allocator;\n\npublic:\n  using MapEntryTy = StringMapEntry<ValueTy>;\n\n  StringMap() : StringMapImpl(static_cast<unsigned>(sizeof(MapEntryTy))) {}\n\n  explicit StringMap(unsigned InitialSize)\n      : StringMapImpl(InitialSize, static_cast<unsigned>(sizeof(MapEntryTy))) {}\n\n  explicit StringMap(AllocatorTy A)\n      : StringMapImpl(static_cast<unsigned>(sizeof(MapEntryTy))), Allocator(A) {\n  }\n\n  StringMap(unsigned InitialSize, AllocatorTy A)\n      : StringMapImpl(InitialSize, static_cast<unsigned>(sizeof(MapEntryTy))),\n        Allocator(A) {}\n\n  StringMap(std::initializer_list<std::pair<StringRef, ValueTy>> List)\n      : StringMapImpl(List.size(), static_cast<unsigned>(sizeof(MapEntryTy))) {\n    for (const auto &P : List) {\n      insert(P);\n    }\n  }\n\n  StringMap(StringMap &&RHS)\n      : StringMapImpl(std::move(RHS)), Allocator(std::move(RHS.Allocator)) {}\n\n  StringMap(const StringMap &RHS)\n      : StringMapImpl(static_cast<unsigned>(sizeof(MapEntryTy))),\n        Allocator(RHS.Allocator) {\n    if (RHS.empty())\n      return;\n\n    // Allocate TheTable of the same size as RHS's TheTable, and set the\n    // sentinel appropriately (and NumBuckets).\n    init(RHS.NumBuckets);\n    unsigned *HashTable = (unsigned *)(TheTable + NumBuckets + 1),\n             *RHSHashTable = (unsigned *)(RHS.TheTable + NumBuckets + 1);\n\n    NumItems = RHS.NumItems;\n    NumTombstones = RHS.NumTombstones;\n    for (unsigned I = 0, E = NumBuckets; I != E; ++I) {\n      StringMapEntryBase *Bucket = RHS.TheTable[I];\n      if (!Bucket || Bucket == getTombstoneVal()) {\n        TheTable[I] = Bucket;\n        continue;\n      }\n\n      TheTable[I] = MapEntryTy::Create(\n          static_cast<MapEntryTy *>(Bucket)->getKey(), Allocator,\n          static_cast<MapEntryTy *>(Bucket)->getValue());\n      HashTable[I] = RHSHashTable[I];\n    }\n\n    // Note that here we've copied everything from the RHS into this object,\n    // tombstones included. We could, instead, have re-probed for each key to\n    // instantiate this new object without any tombstone buckets. The\n    // assumption here is that items are rarely deleted from most StringMaps,\n    // and so tombstones are rare, so the cost of re-probing for all inputs is\n    // not worthwhile.\n  }\n\n  StringMap &operator=(StringMap RHS) {\n    StringMapImpl::swap(RHS);\n    std::swap(Allocator, RHS.Allocator);\n    return *this;\n  }\n\n  ~StringMap() {\n    // Delete all the elements in the map, but don't reset the elements\n    // to default values.  This is a copy of clear(), but avoids unnecessary\n    // work not required in the destructor.\n    if (!empty()) {\n      for (unsigned I = 0, E = NumBuckets; I != E; ++I) {\n        StringMapEntryBase *Bucket = TheTable[I];\n        if (Bucket && Bucket != getTombstoneVal()) {\n          static_cast<MapEntryTy *>(Bucket)->Destroy(Allocator);\n        }\n      }\n    }\n    free(TheTable);\n  }\n\n  AllocatorTy &getAllocator() { return Allocator; }\n  const AllocatorTy &getAllocator() const { return Allocator; }\n\n  using key_type = const char *;\n  using mapped_type = ValueTy;\n  using value_type = StringMapEntry<ValueTy>;\n  using size_type = size_t;\n\n  using const_iterator = StringMapConstIterator<ValueTy>;\n  using iterator = StringMapIterator<ValueTy>;\n\n  iterator begin() { return iterator(TheTable, NumBuckets == 0); }\n  iterator end() { return iterator(TheTable + NumBuckets, true); }\n  const_iterator begin() const {\n    return const_iterator(TheTable, NumBuckets == 0);\n  }\n  const_iterator end() const {\n    return const_iterator(TheTable + NumBuckets, true);\n  }\n\n  iterator_range<StringMapKeyIterator<ValueTy>> keys() const {\n    return make_range(StringMapKeyIterator<ValueTy>(begin()),\n                      StringMapKeyIterator<ValueTy>(end()));\n  }\n\n  iterator find(StringRef Key) {\n    int Bucket = FindKey(Key);\n    if (Bucket == -1)\n      return end();\n    return iterator(TheTable + Bucket, true);\n  }\n\n  const_iterator find(StringRef Key) const {\n    int Bucket = FindKey(Key);\n    if (Bucket == -1)\n      return end();\n    return const_iterator(TheTable + Bucket, true);\n  }\n\n  /// lookup - Return the entry for the specified key, or a default\n  /// constructed value if no such entry exists.\n  ValueTy lookup(StringRef Key) const {\n    const_iterator it = find(Key);\n    if (it != end())\n      return it->second;\n    return ValueTy();\n  }\n\n  /// Lookup the ValueTy for the \\p Key, or create a default constructed value\n  /// if the key is not in the map.\n  ValueTy &operator[](StringRef Key) { return try_emplace(Key).first->second; }\n\n  /// count - Return 1 if the element is in the map, 0 otherwise.\n  size_type count(StringRef Key) const { return find(Key) == end() ? 0 : 1; }\n\n  template <typename InputTy>\n  size_type count(const StringMapEntry<InputTy> &MapEntry) const {\n    return count(MapEntry.getKey());\n  }\n\n  /// equal - check whether both of the containers are equal.\n  bool operator==(const StringMap &RHS) const {\n    if (size() != RHS.size())\n      return false;\n\n    for (const auto &KeyValue : *this) {\n      auto FindInRHS = RHS.find(KeyValue.getKey());\n\n      if (FindInRHS == RHS.end())\n        return false;\n\n      if (!(KeyValue.getValue() == FindInRHS->getValue()))\n        return false;\n    }\n\n    return true;\n  }\n\n  bool operator!=(const StringMap &RHS) const { return !(*this == RHS); }\n\n  /// insert - Insert the specified key/value pair into the map.  If the key\n  /// already exists in the map, return false and ignore the request, otherwise\n  /// insert it and return true.\n  bool insert(MapEntryTy *KeyValue) {\n    unsigned BucketNo = LookupBucketFor(KeyValue->getKey());\n    StringMapEntryBase *&Bucket = TheTable[BucketNo];\n    if (Bucket && Bucket != getTombstoneVal())\n      return false; // Already exists in map.\n\n    if (Bucket == getTombstoneVal())\n      --NumTombstones;\n    Bucket = KeyValue;\n    ++NumItems;\n    assert(NumItems + NumTombstones <= NumBuckets);\n\n    RehashTable();\n    return true;\n  }\n\n  /// insert - Inserts the specified key/value pair into the map if the key\n  /// isn't already in the map. The bool component of the returned pair is true\n  /// if and only if the insertion takes place, and the iterator component of\n  /// the pair points to the element with key equivalent to the key of the pair.\n  std::pair<iterator, bool> insert(std::pair<StringRef, ValueTy> KV) {\n    return try_emplace(KV.first, std::move(KV.second));\n  }\n\n  /// Inserts an element or assigns to the current element if the key already\n  /// exists. The return type is the same as try_emplace.\n  template <typename V>\n  std::pair<iterator, bool> insert_or_assign(StringRef Key, V &&Val) {\n    auto Ret = try_emplace(Key, std::forward<V>(Val));\n    if (!Ret.second)\n      Ret.first->second = std::forward<V>(Val);\n    return Ret;\n  }\n\n  /// Emplace a new element for the specified key into the map if the key isn't\n  /// already in the map. The bool component of the returned pair is true\n  /// if and only if the insertion takes place, and the iterator component of\n  /// the pair points to the element with key equivalent to the key of the pair.\n  template <typename... ArgsTy>\n  std::pair<iterator, bool> try_emplace(StringRef Key, ArgsTy &&... Args) {\n    unsigned BucketNo = LookupBucketFor(Key);\n    StringMapEntryBase *&Bucket = TheTable[BucketNo];\n    if (Bucket && Bucket != getTombstoneVal())\n      return std::make_pair(iterator(TheTable + BucketNo, false),\n                            false); // Already exists in map.\n\n    if (Bucket == getTombstoneVal())\n      --NumTombstones;\n    Bucket = MapEntryTy::Create(Key, Allocator, std::forward<ArgsTy>(Args)...);\n    ++NumItems;\n    assert(NumItems + NumTombstones <= NumBuckets);\n\n    BucketNo = RehashTable(BucketNo);\n    return std::make_pair(iterator(TheTable + BucketNo, false), true);\n  }\n\n  // clear - Empties out the StringMap\n  void clear() {\n    if (empty())\n      return;\n\n    // Zap all values, resetting the keys back to non-present (not tombstone),\n    // which is safe because we're removing all elements.\n    for (unsigned I = 0, E = NumBuckets; I != E; ++I) {\n      StringMapEntryBase *&Bucket = TheTable[I];\n      if (Bucket && Bucket != getTombstoneVal()) {\n        static_cast<MapEntryTy *>(Bucket)->Destroy(Allocator);\n      }\n      Bucket = nullptr;\n    }\n\n    NumItems = 0;\n    NumTombstones = 0;\n  }\n\n  /// remove - Remove the specified key/value pair from the map, but do not\n  /// erase it.  This aborts if the key is not in the map.\n  void remove(MapEntryTy *KeyValue) { RemoveKey(KeyValue); }\n\n  void erase(iterator I) {\n    MapEntryTy &V = *I;\n    remove(&V);\n    V.Destroy(Allocator);\n  }\n\n  bool erase(StringRef Key) {\n    iterator I = find(Key);\n    if (I == end())\n      return false;\n    erase(I);\n    return true;\n  }\n};\n\ntemplate <typename DerivedTy, typename ValueTy>\nclass StringMapIterBase\n    : public iterator_facade_base<DerivedTy, std::forward_iterator_tag,\n                                  ValueTy> {\nprotected:\n  StringMapEntryBase **Ptr = nullptr;\n\npublic:\n  StringMapIterBase() = default;\n\n  explicit StringMapIterBase(StringMapEntryBase **Bucket,\n                             bool NoAdvance = false)\n      : Ptr(Bucket) {\n    if (!NoAdvance)\n      AdvancePastEmptyBuckets();\n  }\n\n  DerivedTy &operator=(const DerivedTy &Other) {\n    Ptr = Other.Ptr;\n    return static_cast<DerivedTy &>(*this);\n  }\n\n  friend bool operator==(const DerivedTy &LHS, const DerivedTy &RHS) {\n    return LHS.Ptr == RHS.Ptr;\n  }\n\n  DerivedTy &operator++() { // Preincrement\n    ++Ptr;\n    AdvancePastEmptyBuckets();\n    return static_cast<DerivedTy &>(*this);\n  }\n\n  DerivedTy operator++(int) { // Post-increment\n    DerivedTy Tmp(Ptr);\n    ++*this;\n    return Tmp;\n  }\n\nprivate:\n  void AdvancePastEmptyBuckets() {\n    while (*Ptr == nullptr || *Ptr == StringMapImpl::getTombstoneVal())\n      ++Ptr;\n  }\n};\n\ntemplate <typename ValueTy>\nclass StringMapConstIterator\n    : public StringMapIterBase<StringMapConstIterator<ValueTy>,\n                               const StringMapEntry<ValueTy>> {\n  using base = StringMapIterBase<StringMapConstIterator<ValueTy>,\n                                 const StringMapEntry<ValueTy>>;\n\npublic:\n  StringMapConstIterator() = default;\n  explicit StringMapConstIterator(StringMapEntryBase **Bucket,\n                                  bool NoAdvance = false)\n      : base(Bucket, NoAdvance) {}\n\n  const StringMapEntry<ValueTy> &operator*() const {\n    return *static_cast<const StringMapEntry<ValueTy> *>(*this->Ptr);\n  }\n};\n\ntemplate <typename ValueTy>\nclass StringMapIterator : public StringMapIterBase<StringMapIterator<ValueTy>,\n                                                   StringMapEntry<ValueTy>> {\n  using base =\n      StringMapIterBase<StringMapIterator<ValueTy>, StringMapEntry<ValueTy>>;\n\npublic:\n  StringMapIterator() = default;\n  explicit StringMapIterator(StringMapEntryBase **Bucket,\n                             bool NoAdvance = false)\n      : base(Bucket, NoAdvance) {}\n\n  StringMapEntry<ValueTy> &operator*() const {\n    return *static_cast<StringMapEntry<ValueTy> *>(*this->Ptr);\n  }\n\n  operator StringMapConstIterator<ValueTy>() const {\n    return StringMapConstIterator<ValueTy>(this->Ptr, true);\n  }\n};\n\ntemplate <typename ValueTy>\nclass StringMapKeyIterator\n    : public iterator_adaptor_base<StringMapKeyIterator<ValueTy>,\n                                   StringMapConstIterator<ValueTy>,\n                                   std::forward_iterator_tag, StringRef> {\n  using base = iterator_adaptor_base<StringMapKeyIterator<ValueTy>,\n                                     StringMapConstIterator<ValueTy>,\n                                     std::forward_iterator_tag, StringRef>;\n\npublic:\n  StringMapKeyIterator() = default;\n  explicit StringMapKeyIterator(StringMapConstIterator<ValueTy> Iter)\n      : base(std::move(Iter)) {}\n\n  StringRef &operator*() {\n    Key = this->wrapped()->getKey();\n    return Key;\n  }\n\nprivate:\n  StringRef Key;\n};\n\n} // end namespace llvm\n\n#endif // LLVM_ADT_STRINGMAP_H\n"}, "65": {"id": 65, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/Triple.h", "content": "//===-- llvm/ADT/Triple.h - Target triple helper class ----------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_ADT_TRIPLE_H\n#define LLVM_ADT_TRIPLE_H\n\n#include \"llvm/ADT/Twine.h\"\n\n// Some system headers or GCC predefined macros conflict with identifiers in\n// this file.  Undefine them here.\n#undef NetBSD\n#undef mips\n#undef sparc\n\nnamespace llvm {\n\nclass VersionTuple;\n\n/// Triple - Helper class for working with autoconf configuration names. For\n/// historical reasons, we also call these 'triples' (they used to contain\n/// exactly three fields).\n///\n/// Configuration names are strings in the canonical form:\n///   ARCHITECTURE-VENDOR-OPERATING_SYSTEM\n/// or\n///   ARCHITECTURE-VENDOR-OPERATING_SYSTEM-ENVIRONMENT\n///\n/// This class is used for clients which want to support arbitrary\n/// configuration names, but also want to implement certain special\n/// behavior for particular configurations. This class isolates the mapping\n/// from the components of the configuration name to well known IDs.\n///\n/// At its core the Triple class is designed to be a wrapper for a triple\n/// string; the constructor does not change or normalize the triple string.\n/// Clients that need to handle the non-canonical triples that users often\n/// specify should use the normalize method.\n///\n/// See autoconf/config.guess for a glimpse into what configuration names\n/// look like in practice.\nclass Triple {\npublic:\n  enum ArchType {\n    UnknownArch,\n\n    arm,            // ARM (little endian): arm, armv.*, xscale\n    armeb,          // ARM (big endian): armeb\n    aarch64,        // AArch64 (little endian): aarch64\n    aarch64_be,     // AArch64 (big endian): aarch64_be\n    aarch64_32,     // AArch64 (little endian) ILP32: aarch64_32\n    arc,            // ARC: Synopsys ARC\n    avr,            // AVR: Atmel AVR microcontroller\n    bpfel,          // eBPF or extended BPF or 64-bit BPF (little endian)\n    bpfeb,          // eBPF or extended BPF or 64-bit BPF (big endian)\n    csky,           // CSKY: csky\n    hexagon,        // Hexagon: hexagon\n    m68k,           // M68k: Motorola 680x0 family\n    mips,           // MIPS: mips, mipsallegrex, mipsr6\n    mipsel,         // MIPSEL: mipsel, mipsallegrexe, mipsr6el\n    mips64,         // MIPS64: mips64, mips64r6, mipsn32, mipsn32r6\n    mips64el,       // MIPS64EL: mips64el, mips64r6el, mipsn32el, mipsn32r6el\n    msp430,         // MSP430: msp430\n    ppc,            // PPC: powerpc\n    ppcle,          // PPCLE: powerpc (little endian)\n    ppc64,          // PPC64: powerpc64, ppu\n    ppc64le,        // PPC64LE: powerpc64le\n    r600,           // R600: AMD GPUs HD2XXX - HD6XXX\n    amdgcn,         // AMDGCN: AMD GCN GPUs\n    riscv32,        // RISC-V (32-bit): riscv32\n    riscv64,        // RISC-V (64-bit): riscv64\n    sparc,          // Sparc: sparc\n    sparcv9,        // Sparcv9: Sparcv9\n    sparcel,        // Sparc: (endianness = little). NB: 'Sparcle' is a CPU variant\n    systemz,        // SystemZ: s390x\n    tce,            // TCE (http://tce.cs.tut.fi/): tce\n    tcele,          // TCE little endian (http://tce.cs.tut.fi/): tcele\n    thumb,          // Thumb (little endian): thumb, thumbv.*\n    thumbeb,        // Thumb (big endian): thumbeb\n    x86,            // X86: i[3-9]86\n    x86_64,         // X86-64: amd64, x86_64\n    xcore,          // XCore: xcore\n    nvptx,          // NVPTX: 32-bit\n    nvptx64,        // NVPTX: 64-bit\n    le32,           // le32: generic little-endian 32-bit CPU (PNaCl)\n    le64,           // le64: generic little-endian 64-bit CPU (PNaCl)\n    amdil,          // AMDIL\n    amdil64,        // AMDIL with 64-bit pointers\n    hsail,          // AMD HSAIL\n    hsail64,        // AMD HSAIL with 64-bit pointers\n    spir,           // SPIR: standard portable IR for OpenCL 32-bit version\n    spir64,         // SPIR: standard portable IR for OpenCL 64-bit version\n    kalimba,        // Kalimba: generic kalimba\n    shave,          // SHAVE: Movidius vector VLIW processors\n    lanai,          // Lanai: Lanai 32-bit\n    wasm32,         // WebAssembly with 32-bit pointers\n    wasm64,         // WebAssembly with 64-bit pointers\n    renderscript32, // 32-bit RenderScript\n    renderscript64, // 64-bit RenderScript\n    ve,             // NEC SX-Aurora Vector Engine\n    LastArchType = ve\n  };\n  enum SubArchType {\n    NoSubArch,\n\n    ARMSubArch_v8_7a,\n    ARMSubArch_v8_6a,\n    ARMSubArch_v8_5a,\n    ARMSubArch_v8_4a,\n    ARMSubArch_v8_3a,\n    ARMSubArch_v8_2a,\n    ARMSubArch_v8_1a,\n    ARMSubArch_v8,\n    ARMSubArch_v8r,\n    ARMSubArch_v8m_baseline,\n    ARMSubArch_v8m_mainline,\n    ARMSubArch_v8_1m_mainline,\n    ARMSubArch_v7,\n    ARMSubArch_v7em,\n    ARMSubArch_v7m,\n    ARMSubArch_v7s,\n    ARMSubArch_v7k,\n    ARMSubArch_v7ve,\n    ARMSubArch_v6,\n    ARMSubArch_v6m,\n    ARMSubArch_v6k,\n    ARMSubArch_v6t2,\n    ARMSubArch_v5,\n    ARMSubArch_v5te,\n    ARMSubArch_v4t,\n\n    AArch64SubArch_arm64e,\n\n    KalimbaSubArch_v3,\n    KalimbaSubArch_v4,\n    KalimbaSubArch_v5,\n\n    MipsSubArch_r6,\n\n    PPCSubArch_spe\n  };\n  enum VendorType {\n    UnknownVendor,\n\n    Apple,\n    PC,\n    SCEI,\n    Freescale,\n    IBM,\n    ImaginationTechnologies,\n    MipsTechnologies,\n    NVIDIA,\n    CSR,\n    Myriad,\n    AMD,\n    Mesa,\n    SUSE,\n    OpenEmbedded,\n    LastVendorType = OpenEmbedded\n  };\n  enum OSType {\n    UnknownOS,\n\n    Ananas,\n    CloudABI,\n    Darwin,\n    DragonFly,\n    FreeBSD,\n    Fuchsia,\n    IOS,\n    KFreeBSD,\n    Linux,\n    Lv2,        // PS3\n    MacOSX,\n    NetBSD,\n    OpenBSD,\n    Solaris,\n    Win32,\n    ZOS,\n    Haiku,\n    Minix,\n    RTEMS,\n    NaCl,       // Native Client\n    AIX,\n    CUDA,       // NVIDIA CUDA\n    NVCL,       // NVIDIA OpenCL\n    AMDHSA,     // AMD HSA Runtime\n    PS4,\n    ELFIAMCU,\n    TvOS,       // Apple tvOS\n    WatchOS,    // Apple watchOS\n    Mesa3D,\n    Contiki,\n    AMDPAL,     // AMD PAL Runtime\n    HermitCore, // HermitCore Unikernel/Multikernel\n    Hurd,       // GNU/Hurd\n    WASI,       // Experimental WebAssembly OS\n    Emscripten,\n    LastOSType = Emscripten\n  };\n  enum EnvironmentType {\n    UnknownEnvironment,\n\n    GNU,\n    GNUABIN32,\n    GNUABI64,\n    GNUEABI,\n    GNUEABIHF,\n    GNUX32,\n    GNUILP32,\n    CODE16,\n    EABI,\n    EABIHF,\n    Android,\n    Musl,\n    MuslEABI,\n    MuslEABIHF,\n\n    MSVC,\n    Itanium,\n    Cygnus,\n    CoreCLR,\n    Simulator, // Simulator variants of other systems, e.g., Apple's iOS\n    MacABI, // Mac Catalyst variant of Apple's iOS deployment target.\n    LastEnvironmentType = MacABI\n  };\n  enum ObjectFormatType {\n    UnknownObjectFormat,\n\n    COFF,\n    ELF,\n    GOFF,\n    MachO,\n    Wasm,\n    XCOFF,\n  };\n\nprivate:\n  std::string Data;\n\n  /// The parsed arch type.\n  ArchType Arch;\n\n  /// The parsed subarchitecture type.\n  SubArchType SubArch;\n\n  /// The parsed vendor type.\n  VendorType Vendor;\n\n  /// The parsed OS type.\n  OSType OS;\n\n  /// The parsed Environment type.\n  EnvironmentType Environment;\n\n  /// The object format type.\n  ObjectFormatType ObjectFormat;\n\npublic:\n  /// @name Constructors\n  /// @{\n\n  /// Default constructor is the same as an empty string and leaves all\n  /// triple fields unknown.\n  Triple()\n      : Data(), Arch(), SubArch(), Vendor(), OS(), Environment(),\n        ObjectFormat() {}\n\n  explicit Triple(const Twine &Str);\n  Triple(const Twine &ArchStr, const Twine &VendorStr, const Twine &OSStr);\n  Triple(const Twine &ArchStr, const Twine &VendorStr, const Twine &OSStr,\n         const Twine &EnvironmentStr);\n\n  bool operator==(const Triple &Other) const {\n    return Arch == Other.Arch && SubArch == Other.SubArch &&\n           Vendor == Other.Vendor && OS == Other.OS &&\n           Environment == Other.Environment &&\n           ObjectFormat == Other.ObjectFormat;\n  }\n\n  bool operator!=(const Triple &Other) const {\n    return !(*this == Other);\n  }\n\n  /// @}\n  /// @name Normalization\n  /// @{\n\n  /// normalize - Turn an arbitrary machine specification into the canonical\n  /// triple form (or something sensible that the Triple class understands if\n  /// nothing better can reasonably be done).  In particular, it handles the\n  /// common case in which otherwise valid components are in the wrong order.\n  static std::string normalize(StringRef Str);\n\n  /// Return the normalized form of this triple's string.\n  std::string normalize() const { return normalize(Data); }\n\n  /// @}\n  /// @name Typed Component Access\n  /// @{\n\n  /// getArch - Get the parsed architecture type of this triple.\n  ArchType getArch() const { return Arch; }\n\n  /// getSubArch - get the parsed subarchitecture type for this triple.\n  SubArchType getSubArch() const { return SubArch; }\n\n  /// getVendor - Get the parsed vendor type of this triple.\n  VendorType getVendor() const { return Vendor; }\n\n  /// getOS - Get the parsed operating system type of this triple.\n  OSType getOS() const { return OS; }\n\n  /// hasEnvironment - Does this triple have the optional environment\n  /// (fourth) component?\n  bool hasEnvironment() const {\n    return getEnvironmentName() != \"\";\n  }\n\n  /// getEnvironment - Get the parsed environment type of this triple.\n  EnvironmentType getEnvironment() const { return Environment; }\n\n  /// Parse the version number from the OS name component of the\n  /// triple, if present.\n  ///\n  /// For example, \"fooos1.2.3\" would return (1, 2, 3).\n  ///\n  /// If an entry is not defined, it will be returned as 0.\n  void getEnvironmentVersion(unsigned &Major, unsigned &Minor,\n                             unsigned &Micro) const;\n\n  /// getFormat - Get the object format for this triple.\n  ObjectFormatType getObjectFormat() const { return ObjectFormat; }\n\n  /// getOSVersion - Parse the version number from the OS name component of the\n  /// triple, if present.\n  ///\n  /// For example, \"fooos1.2.3\" would return (1, 2, 3).\n  ///\n  /// If an entry is not defined, it will be returned as 0.\n  void getOSVersion(unsigned &Major, unsigned &Minor, unsigned &Micro) const;\n\n  /// getOSMajorVersion - Return just the major version number, this is\n  /// specialized because it is a common query.\n  unsigned getOSMajorVersion() const {\n    unsigned Maj, Min, Micro;\n    getOSVersion(Maj, Min, Micro);\n    return Maj;\n  }\n\n  /// getMacOSXVersion - Parse the version number as with getOSVersion and then\n  /// translate generic \"darwin\" versions to the corresponding OS X versions.\n  /// This may also be called with IOS triples but the OS X version number is\n  /// just set to a constant 10.4.0 in that case.  Returns true if successful.\n  bool getMacOSXVersion(unsigned &Major, unsigned &Minor,\n                        unsigned &Micro) const;\n\n  /// getiOSVersion - Parse the version number as with getOSVersion.  This should\n  /// only be called with IOS or generic triples.\n  void getiOSVersion(unsigned &Major, unsigned &Minor,\n                     unsigned &Micro) const;\n\n  /// getWatchOSVersion - Parse the version number as with getOSVersion.  This\n  /// should only be called with WatchOS or generic triples.\n  void getWatchOSVersion(unsigned &Major, unsigned &Minor,\n                         unsigned &Micro) const;\n\n  /// @}\n  /// @name Direct Component Access\n  /// @{\n\n  const std::string &str() const { return Data; }\n\n  const std::string &getTriple() const { return Data; }\n\n  /// getArchName - Get the architecture (first) component of the\n  /// triple.\n  StringRef getArchName() const;\n\n  /// getVendorName - Get the vendor (second) component of the triple.\n  StringRef getVendorName() const;\n\n  /// getOSName - Get the operating system (third) component of the\n  /// triple.\n  StringRef getOSName() const;\n\n  /// getEnvironmentName - Get the optional environment (fourth)\n  /// component of the triple, or \"\" if empty.\n  StringRef getEnvironmentName() const;\n\n  /// getOSAndEnvironmentName - Get the operating system and optional\n  /// environment components as a single string (separated by a '-'\n  /// if the environment component is present).\n  StringRef getOSAndEnvironmentName() const;\n\n  /// @}\n  /// @name Convenience Predicates\n  /// @{\n\n  /// Test whether the architecture is 64-bit\n  ///\n  /// Note that this tests for 64-bit pointer width, and nothing else. Note\n  /// that we intentionally expose only three predicates, 64-bit, 32-bit, and\n  /// 16-bit. The inner details of pointer width for particular architectures\n  /// is not summed up in the triple, and so only a coarse grained predicate\n  /// system is provided.\n  bool isArch64Bit() const;\n\n  /// Test whether the architecture is 32-bit\n  ///\n  /// Note that this tests for 32-bit pointer width, and nothing else.\n  bool isArch32Bit() const;\n\n  /// Test whether the architecture is 16-bit\n  ///\n  /// Note that this tests for 16-bit pointer width, and nothing else.\n  bool isArch16Bit() const;\n\n  /// isOSVersionLT - Helper function for doing comparisons against version\n  /// numbers included in the target triple.\n  bool isOSVersionLT(unsigned Major, unsigned Minor = 0,\n                     unsigned Micro = 0) const {\n    unsigned LHS[3];\n    getOSVersion(LHS[0], LHS[1], LHS[2]);\n\n    if (LHS[0] != Major)\n      return LHS[0] < Major;\n    if (LHS[1] != Minor)\n      return LHS[1] < Minor;\n    if (LHS[2] != Micro)\n      return LHS[2] < Micro;\n\n    return false;\n  }\n\n  bool isOSVersionLT(const Triple &Other) const {\n    unsigned RHS[3];\n    Other.getOSVersion(RHS[0], RHS[1], RHS[2]);\n    return isOSVersionLT(RHS[0], RHS[1], RHS[2]);\n  }\n\n  /// isMacOSXVersionLT - Comparison function for checking OS X version\n  /// compatibility, which handles supporting skewed version numbering schemes\n  /// used by the \"darwin\" triples.\n  bool isMacOSXVersionLT(unsigned Major, unsigned Minor = 0,\n                         unsigned Micro = 0) const;\n\n  /// isMacOSX - Is this a Mac OS X triple. For legacy reasons, we support both\n  /// \"darwin\" and \"osx\" as OS X triples.\n  bool isMacOSX() const {\n    return getOS() == Triple::Darwin || getOS() == Triple::MacOSX;\n  }\n\n  /// Is this an iOS triple.\n  /// Note: This identifies tvOS as a variant of iOS. If that ever\n  /// changes, i.e., if the two operating systems diverge or their version\n  /// numbers get out of sync, that will need to be changed.\n  /// watchOS has completely different version numbers so it is not included.\n  bool isiOS() const {\n    return getOS() == Triple::IOS || isTvOS();\n  }\n\n  /// Is this an Apple tvOS triple.\n  bool isTvOS() const {\n    return getOS() == Triple::TvOS;\n  }\n\n  /// Is this an Apple watchOS triple.\n  bool isWatchOS() const {\n    return getOS() == Triple::WatchOS;\n  }\n\n  bool isWatchABI() const {\n    return getSubArch() == Triple::ARMSubArch_v7k;\n  }\n\n  bool isOSzOS() const { return getOS() == Triple::ZOS; }\n\n  /// isOSDarwin - Is this a \"Darwin\" OS (macOS, iOS, tvOS or watchOS).\n  bool isOSDarwin() const {\n    return isMacOSX() || isiOS() || isWatchOS();\n  }\n\n  bool isSimulatorEnvironment() const {\n    return getEnvironment() == Triple::Simulator;\n  }\n\n  bool isMacCatalystEnvironment() const {\n    return getEnvironment() == Triple::MacABI;\n  }\n\n  /// Returns true for targets that run on a macOS machine.\n  bool isTargetMachineMac() const {\n    return isMacOSX() || (isOSDarwin() && (isSimulatorEnvironment() ||\n                                           isMacCatalystEnvironment()));\n  }\n\n  bool isOSNetBSD() const {\n    return getOS() == Triple::NetBSD;\n  }\n\n  bool isOSOpenBSD() const {\n    return getOS() == Triple::OpenBSD;\n  }\n\n  bool isOSFreeBSD() const {\n    return getOS() == Triple::FreeBSD;\n  }\n\n  bool isOSFuchsia() const {\n    return getOS() == Triple::Fuchsia;\n  }\n\n  bool isOSDragonFly() const { return getOS() == Triple::DragonFly; }\n\n  bool isOSSolaris() const {\n    return getOS() == Triple::Solaris;\n  }\n\n  bool isOSIAMCU() const {\n    return getOS() == Triple::ELFIAMCU;\n  }\n\n  bool isOSUnknown() const { return getOS() == Triple::UnknownOS; }\n\n  bool isGNUEnvironment() const {\n    EnvironmentType Env = getEnvironment();\n    return Env == Triple::GNU || Env == Triple::GNUABIN32 ||\n           Env == Triple::GNUABI64 || Env == Triple::GNUEABI ||\n           Env == Triple::GNUEABIHF || Env == Triple::GNUX32;\n  }\n\n  bool isOSContiki() const {\n    return getOS() == Triple::Contiki;\n  }\n\n  /// Tests whether the OS is Haiku.\n  bool isOSHaiku() const {\n    return getOS() == Triple::Haiku;\n  }\n\n  /// Tests whether the OS is Windows.\n  bool isOSWindows() const {\n    return getOS() == Triple::Win32;\n  }\n\n  /// Checks if the environment is MSVC.\n  bool isKnownWindowsMSVCEnvironment() const {\n    return isOSWindows() && getEnvironment() == Triple::MSVC;\n  }\n\n  /// Checks if the environment could be MSVC.\n  bool isWindowsMSVCEnvironment() const {\n    return isKnownWindowsMSVCEnvironment() ||\n           (isOSWindows() && getEnvironment() == Triple::UnknownEnvironment);\n  }\n\n  bool isWindowsCoreCLREnvironment() const {\n    return isOSWindows() && getEnvironment() == Triple::CoreCLR;\n  }\n\n  bool isWindowsItaniumEnvironment() const {\n    return isOSWindows() && getEnvironment() == Triple::Itanium;\n  }\n\n  bool isWindowsCygwinEnvironment() const {\n    return isOSWindows() && getEnvironment() == Triple::Cygnus;\n  }\n\n  bool isWindowsGNUEnvironment() const {\n    return isOSWindows() && getEnvironment() == Triple::GNU;\n  }\n\n  /// Tests for either Cygwin or MinGW OS\n  bool isOSCygMing() const {\n    return isWindowsCygwinEnvironment() || isWindowsGNUEnvironment();\n  }\n\n  /// Is this a \"Windows\" OS targeting a \"MSVCRT.dll\" environment.\n  bool isOSMSVCRT() const {\n    return isWindowsMSVCEnvironment() || isWindowsGNUEnvironment() ||\n           isWindowsItaniumEnvironment();\n  }\n\n  /// Tests whether the OS is NaCl (Native Client)\n  bool isOSNaCl() const {\n    return getOS() == Triple::NaCl;\n  }\n\n  /// Tests whether the OS is Linux.\n  bool isOSLinux() const {\n    return getOS() == Triple::Linux;\n  }\n\n  /// Tests whether the OS is kFreeBSD.\n  bool isOSKFreeBSD() const {\n    return getOS() == Triple::KFreeBSD;\n  }\n\n  /// Tests whether the OS is Hurd.\n  bool isOSHurd() const {\n    return getOS() == Triple::Hurd;\n  }\n\n  /// Tests whether the OS is WASI.\n  bool isOSWASI() const {\n    return getOS() == Triple::WASI;\n  }\n\n  /// Tests whether the OS is Emscripten.\n  bool isOSEmscripten() const {\n    return getOS() == Triple::Emscripten;\n  }\n\n  /// Tests whether the OS uses glibc.\n  bool isOSGlibc() const {\n    return (getOS() == Triple::Linux || getOS() == Triple::KFreeBSD ||\n            getOS() == Triple::Hurd) &&\n           !isAndroid();\n  }\n\n  /// Tests whether the OS is AIX.\n  bool isOSAIX() const {\n    return getOS() == Triple::AIX;\n  }\n\n  /// Tests whether the OS uses the ELF binary format.\n  bool isOSBinFormatELF() const {\n    return getObjectFormat() == Triple::ELF;\n  }\n\n  /// Tests whether the OS uses the COFF binary format.\n  bool isOSBinFormatCOFF() const {\n    return getObjectFormat() == Triple::COFF;\n  }\n\n  /// Tests whether the OS uses the GOFF binary format.\n  bool isOSBinFormatGOFF() const { return getObjectFormat() == Triple::GOFF; }\n\n  /// Tests whether the environment is MachO.\n  bool isOSBinFormatMachO() const {\n    return getObjectFormat() == Triple::MachO;\n  }\n\n  /// Tests whether the OS uses the Wasm binary format.\n  bool isOSBinFormatWasm() const {\n    return getObjectFormat() == Triple::Wasm;\n  }\n\n  /// Tests whether the OS uses the XCOFF binary format.\n  bool isOSBinFormatXCOFF() const {\n    return getObjectFormat() == Triple::XCOFF;\n  }\n\n  /// Tests whether the target is the PS4 CPU\n  bool isPS4CPU() const {\n    return getArch() == Triple::x86_64 &&\n           getVendor() == Triple::SCEI &&\n           getOS() == Triple::PS4;\n  }\n\n  /// Tests whether the target is the PS4 platform\n  bool isPS4() const {\n    return getVendor() == Triple::SCEI &&\n           getOS() == Triple::PS4;\n  }\n\n  /// Tests whether the target is Android\n  bool isAndroid() const { return getEnvironment() == Triple::Android; }\n\n  bool isAndroidVersionLT(unsigned Major) const {\n    assert(isAndroid() && \"Not an Android triple!\");\n\n    unsigned Env[3];\n    getEnvironmentVersion(Env[0], Env[1], Env[2]);\n\n    // 64-bit targets did not exist before API level 21 (Lollipop).\n    if (isArch64Bit() && Env[0] < 21)\n      Env[0] = 21;\n\n    return Env[0] < Major;\n  }\n\n  /// Tests whether the environment is musl-libc\n  bool isMusl() const {\n    return getEnvironment() == Triple::Musl ||\n           getEnvironment() == Triple::MuslEABI ||\n           getEnvironment() == Triple::MuslEABIHF;\n  }\n\n  /// Tests whether the target is SPIR (32- or 64-bit).\n  bool isSPIR() const {\n    return getArch() == Triple::spir || getArch() == Triple::spir64;\n  }\n\n  /// Tests whether the target is NVPTX (32- or 64-bit).\n  bool isNVPTX() const {\n    return getArch() == Triple::nvptx || getArch() == Triple::nvptx64;\n  }\n\n  /// Tests whether the target is AMDGCN\n  bool isAMDGCN() const { return getArch() == Triple::amdgcn; }\n\n  bool isAMDGPU() const {\n    return getArch() == Triple::r600 || getArch() == Triple::amdgcn;\n  }\n\n  /// Tests whether the target is Thumb (little and big endian).\n  bool isThumb() const {\n    return getArch() == Triple::thumb || getArch() == Triple::thumbeb;\n  }\n\n  /// Tests whether the target is ARM (little and big endian).\n  bool isARM() const {\n    return getArch() == Triple::arm || getArch() == Triple::armeb;\n  }\n\n  /// Tests whether the target is AArch64 (little and big endian).\n  bool isAArch64() const {\n    return getArch() == Triple::aarch64 || getArch() == Triple::aarch64_be ||\n           getArch() == Triple::aarch64_32;\n  }\n\n  /// Tests whether the target is AArch64 and pointers are the size specified by\n  /// \\p PointerWidth.\n  bool isAArch64(int PointerWidth) const {\n    assert(PointerWidth == 64 || PointerWidth == 32);\n    if (!isAArch64())\n      return false;\n    return getArch() == Triple::aarch64_32 ||\n                   getEnvironment() == Triple::GNUILP32\n               ? PointerWidth == 32\n               : PointerWidth == 64;\n  }\n\n  /// Tests whether the target is MIPS 32-bit (little and big endian).\n  bool isMIPS32() const {\n    return getArch() == Triple::mips || getArch() == Triple::mipsel;\n  }\n\n  /// Tests whether the target is MIPS 64-bit (little and big endian).\n  bool isMIPS64() const {\n    return getArch() == Triple::mips64 || getArch() == Triple::mips64el;\n  }\n\n  /// Tests whether the target is MIPS (little and big endian, 32- or 64-bit).\n  bool isMIPS() const {\n    return isMIPS32() || isMIPS64();\n  }\n\n  /// Tests whether the target is PowerPC (32- or 64-bit LE or BE).\n  bool isPPC() const {\n    return getArch() == Triple::ppc || getArch() == Triple::ppc64 ||\n           getArch() == Triple::ppcle || getArch() == Triple::ppc64le;\n  }\n\n  /// Tests whether the target is 32-bit PowerPC (little and big endian).\n  bool isPPC32() const {\n    return getArch() == Triple::ppc || getArch() == Triple::ppcle;\n  }\n\n  /// Tests whether the target is 64-bit PowerPC (little and big endian).\n  bool isPPC64() const {\n    return getArch() == Triple::ppc64 || getArch() == Triple::ppc64le;\n  }\n\n  /// Tests whether the target is RISC-V (32- and 64-bit).\n  bool isRISCV() const {\n    return getArch() == Triple::riscv32 || getArch() == Triple::riscv64;\n  }\n\n  /// Tests whether the target is SystemZ.\n  bool isSystemZ() const {\n    return getArch() == Triple::systemz;\n  }\n\n  /// Tests whether the target is x86 (32- or 64-bit).\n  bool isX86() const {\n    return getArch() == Triple::x86 || getArch() == Triple::x86_64;\n  }\n\n  /// Tests whether the target is VE\n  bool isVE() const {\n    return getArch() == Triple::ve;\n  }\n\n  /// Tests whether the target is wasm (32- and 64-bit).\n  bool isWasm() const {\n    return getArch() == Triple::wasm32 || getArch() == Triple::wasm64;\n  }\n\n  // Tests whether the target is CSKY\n  bool isCSKY() const {\n    return getArch() == Triple::csky;\n  }\n\n  /// Tests whether the target is the Apple \"arm64e\" AArch64 subarch.\n  bool isArm64e() const {\n    return getArch() == Triple::aarch64 &&\n           getSubArch() == Triple::AArch64SubArch_arm64e;\n  }\n\n  /// Tests whether the target supports comdat\n  bool supportsCOMDAT() const {\n    return !(isOSBinFormatMachO() || isOSBinFormatXCOFF());\n  }\n\n  /// Tests whether the target uses emulated TLS as default.\n  bool hasDefaultEmulatedTLS() const {\n    return isAndroid() || isOSOpenBSD() || isWindowsCygwinEnvironment();\n  }\n\n  /// Tests whether the target uses -data-sections as default.\n  bool hasDefaultDataSections() const {\n    return isOSBinFormatXCOFF() || isWasm();\n  }\n\n  /// Tests if the environment supports dllimport/export annotations.\n  bool hasDLLImportExport() const { return isOSWindows() || isPS4CPU(); }\n\n  /// @}\n  /// @name Mutators\n  /// @{\n\n  /// setArch - Set the architecture (first) component of the triple\n  /// to a known type.\n  void setArch(ArchType Kind);\n\n  /// setVendor - Set the vendor (second) component of the triple to a\n  /// known type.\n  void setVendor(VendorType Kind);\n\n  /// setOS - Set the operating system (third) component of the triple\n  /// to a known type.\n  void setOS(OSType Kind);\n\n  /// setEnvironment - Set the environment (fourth) component of the triple\n  /// to a known type.\n  void setEnvironment(EnvironmentType Kind);\n\n  /// setObjectFormat - Set the object file format\n  void setObjectFormat(ObjectFormatType Kind);\n\n  /// setTriple - Set all components to the new triple \\p Str.\n  void setTriple(const Twine &Str);\n\n  /// setArchName - Set the architecture (first) component of the\n  /// triple by name.\n  void setArchName(StringRef Str);\n\n  /// setVendorName - Set the vendor (second) component of the triple\n  /// by name.\n  void setVendorName(StringRef Str);\n\n  /// setOSName - Set the operating system (third) component of the\n  /// triple by name.\n  void setOSName(StringRef Str);\n\n  /// setEnvironmentName - Set the optional environment (fourth)\n  /// component of the triple by name.\n  void setEnvironmentName(StringRef Str);\n\n  /// setOSAndEnvironmentName - Set the operating system and optional\n  /// environment components with a single string.\n  void setOSAndEnvironmentName(StringRef Str);\n\n  /// @}\n  /// @name Helpers to build variants of a particular triple.\n  /// @{\n\n  /// Form a triple with a 32-bit variant of the current architecture.\n  ///\n  /// This can be used to move across \"families\" of architectures where useful.\n  ///\n  /// \\returns A new triple with a 32-bit architecture or an unknown\n  ///          architecture if no such variant can be found.\n  llvm::Triple get32BitArchVariant() const;\n\n  /// Form a triple with a 64-bit variant of the current architecture.\n  ///\n  /// This can be used to move across \"families\" of architectures where useful.\n  ///\n  /// \\returns A new triple with a 64-bit architecture or an unknown\n  ///          architecture if no such variant can be found.\n  llvm::Triple get64BitArchVariant() const;\n\n  /// Form a triple with a big endian variant of the current architecture.\n  ///\n  /// This can be used to move across \"families\" of architectures where useful.\n  ///\n  /// \\returns A new triple with a big endian architecture or an unknown\n  ///          architecture if no such variant can be found.\n  llvm::Triple getBigEndianArchVariant() const;\n\n  /// Form a triple with a little endian variant of the current architecture.\n  ///\n  /// This can be used to move across \"families\" of architectures where useful.\n  ///\n  /// \\returns A new triple with a little endian architecture or an unknown\n  ///          architecture if no such variant can be found.\n  llvm::Triple getLittleEndianArchVariant() const;\n\n  /// Get the (LLVM) name of the minimum ARM CPU for the arch we are targeting.\n  ///\n  /// \\param Arch the architecture name (e.g., \"armv7s\"). If it is an empty\n  /// string then the triple's arch name is used.\n  StringRef getARMCPUForArch(StringRef Arch = StringRef()) const;\n\n  /// Tests whether the target triple is little endian.\n  ///\n  /// \\returns true if the triple is little endian, false otherwise.\n  bool isLittleEndian() const;\n\n  /// Test whether target triples are compatible.\n  bool isCompatibleWith(const Triple &Other) const;\n\n  /// Merge target triples.\n  std::string merge(const Triple &Other) const;\n\n  /// Some platforms have different minimum supported OS versions that\n  /// varies by the architecture specified in the triple. This function\n  /// returns the minimum supported OS version for this triple if one an exists,\n  /// or an invalid version tuple if this triple doesn't have one.\n  VersionTuple getMinimumSupportedOSVersion() const;\n\n  /// @}\n  /// @name Static helpers for IDs.\n  /// @{\n\n  /// getArchTypeName - Get the canonical name for the \\p Kind architecture.\n  static StringRef getArchTypeName(ArchType Kind);\n\n  /// getArchTypePrefix - Get the \"prefix\" canonical name for the \\p Kind\n  /// architecture. This is the prefix used by the architecture specific\n  /// builtins, and is suitable for passing to \\see\n  /// Intrinsic::getIntrinsicForGCCBuiltin().\n  ///\n  /// \\return - The architecture prefix, or 0 if none is defined.\n  static StringRef getArchTypePrefix(ArchType Kind);\n\n  /// getVendorTypeName - Get the canonical name for the \\p Kind vendor.\n  static StringRef getVendorTypeName(VendorType Kind);\n\n  /// getOSTypeName - Get the canonical name for the \\p Kind operating system.\n  static StringRef getOSTypeName(OSType Kind);\n\n  /// getEnvironmentTypeName - Get the canonical name for the \\p Kind\n  /// environment.\n  static StringRef getEnvironmentTypeName(EnvironmentType Kind);\n\n  /// @}\n  /// @name Static helpers for converting alternate architecture names.\n  /// @{\n\n  /// getArchTypeForLLVMName - The canonical type for the given LLVM\n  /// architecture name (e.g., \"x86\").\n  static ArchType getArchTypeForLLVMName(StringRef Str);\n\n  /// @}\n\n  /// Returns a canonicalized OS version number for the specified OS.\n  static VersionTuple getCanonicalVersionForOS(OSType OSKind,\n                                               const VersionTuple &Version);\n};\n\n} // End llvm namespace\n\n\n#endif\n"}, "67": {"id": 67, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/iterator.h", "content": "//===- iterator.h - Utilities for using and defining iterators --*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_ADT_ITERATOR_H\n#define LLVM_ADT_ITERATOR_H\n\n#include \"llvm/ADT/iterator_range.h\"\n#include <algorithm>\n#include <cstddef>\n#include <iterator>\n#include <type_traits>\n#include <utility>\n\nnamespace llvm {\n\n/// CRTP base class which implements the entire standard iterator facade\n/// in terms of a minimal subset of the interface.\n///\n/// Use this when it is reasonable to implement most of the iterator\n/// functionality in terms of a core subset. If you need special behavior or\n/// there are performance implications for this, you may want to override the\n/// relevant members instead.\n///\n/// Note, one abstraction that this does *not* provide is implementing\n/// subtraction in terms of addition by negating the difference. Negation isn't\n/// always information preserving, and I can see very reasonable iterator\n/// designs where this doesn't work well. It doesn't really force much added\n/// boilerplate anyways.\n///\n/// Another abstraction that this doesn't provide is implementing increment in\n/// terms of addition of one. These aren't equivalent for all iterator\n/// categories, and respecting that adds a lot of complexity for little gain.\n///\n/// Classes wishing to use `iterator_facade_base` should implement the following\n/// methods:\n///\n/// Forward Iterators:\n///   (All of the following methods)\n///   - DerivedT &operator=(const DerivedT &R);\n///   - bool operator==(const DerivedT &R) const;\n///   - const T &operator*() const;\n///   - T &operator*();\n///   - DerivedT &operator++();\n///\n/// Bidirectional Iterators:\n///   (All methods of forward iterators, plus the following)\n///   - DerivedT &operator--();\n///\n/// Random-access Iterators:\n///   (All methods of bidirectional iterators excluding the following)\n///   - DerivedT &operator++();\n///   - DerivedT &operator--();\n///   (and plus the following)\n///   - bool operator<(const DerivedT &RHS) const;\n///   - DifferenceTypeT operator-(const DerivedT &R) const;\n///   - DerivedT &operator+=(DifferenceTypeT N);\n///   - DerivedT &operator-=(DifferenceTypeT N);\n///\ntemplate <typename DerivedT, typename IteratorCategoryT, typename T,\n          typename DifferenceTypeT = std::ptrdiff_t, typename PointerT = T *,\n          typename ReferenceT = T &>\nclass iterator_facade_base\n    : public std::iterator<IteratorCategoryT, T, DifferenceTypeT, PointerT,\n                           ReferenceT> {\nprotected:\n  enum {\n    IsRandomAccess = std::is_base_of<std::random_access_iterator_tag,\n                                     IteratorCategoryT>::value,\n    IsBidirectional = std::is_base_of<std::bidirectional_iterator_tag,\n                                      IteratorCategoryT>::value,\n  };\n\n  /// A proxy object for computing a reference via indirecting a copy of an\n  /// iterator. This is used in APIs which need to produce a reference via\n  /// indirection but for which the iterator object might be a temporary. The\n  /// proxy preserves the iterator internally and exposes the indirected\n  /// reference via a conversion operator.\n  class ReferenceProxy {\n    friend iterator_facade_base;\n\n    DerivedT I;\n\n    ReferenceProxy(DerivedT I) : I(std::move(I)) {}\n\n  public:\n    operator ReferenceT() const { return *I; }\n  };\n\npublic:\n  DerivedT operator+(DifferenceTypeT n) const {\n    static_assert(std::is_base_of<iterator_facade_base, DerivedT>::value,\n                  \"Must pass the derived type to this template!\");\n    static_assert(\n        IsRandomAccess,\n        \"The '+' operator is only defined for random access iterators.\");\n    DerivedT tmp = *static_cast<const DerivedT *>(this);\n    tmp += n;\n    return tmp;\n  }\n  friend DerivedT operator+(DifferenceTypeT n, const DerivedT &i) {\n    static_assert(\n        IsRandomAccess,\n        \"The '+' operator is only defined for random access iterators.\");\n    return i + n;\n  }\n  DerivedT operator-(DifferenceTypeT n) const {\n    static_assert(\n        IsRandomAccess,\n        \"The '-' operator is only defined for random access iterators.\");\n    DerivedT tmp = *static_cast<const DerivedT *>(this);\n    tmp -= n;\n    return tmp;\n  }\n\n  DerivedT &operator++() {\n    static_assert(std::is_base_of<iterator_facade_base, DerivedT>::value,\n                  \"Must pass the derived type to this template!\");\n    return static_cast<DerivedT *>(this)->operator+=(1);\n  }\n  DerivedT operator++(int) {\n    DerivedT tmp = *static_cast<DerivedT *>(this);\n    ++*static_cast<DerivedT *>(this);\n    return tmp;\n  }\n  DerivedT &operator--() {\n    static_assert(\n        IsBidirectional,\n        \"The decrement operator is only defined for bidirectional iterators.\");\n    return static_cast<DerivedT *>(this)->operator-=(1);\n  }\n  DerivedT operator--(int) {\n    static_assert(\n        IsBidirectional,\n        \"The decrement operator is only defined for bidirectional iterators.\");\n    DerivedT tmp = *static_cast<DerivedT *>(this);\n    --*static_cast<DerivedT *>(this);\n    return tmp;\n  }\n\n#ifndef __cpp_impl_three_way_comparison\n  bool operator!=(const DerivedT &RHS) const {\n    return !(static_cast<const DerivedT &>(*this) == RHS);\n  }\n#endif\n\n  bool operator>(const DerivedT &RHS) const {\n    static_assert(\n        IsRandomAccess,\n        \"Relational operators are only defined for random access iterators.\");\n    return !(static_cast<const DerivedT &>(*this) < RHS) &&\n           !(static_cast<const DerivedT &>(*this) == RHS);\n  }\n  bool operator<=(const DerivedT &RHS) const {\n    static_assert(\n        IsRandomAccess,\n        \"Relational operators are only defined for random access iterators.\");\n    return !(static_cast<const DerivedT &>(*this) > RHS);\n  }\n  bool operator>=(const DerivedT &RHS) const {\n    static_assert(\n        IsRandomAccess,\n        \"Relational operators are only defined for random access iterators.\");\n    return !(static_cast<const DerivedT &>(*this) < RHS);\n  }\n\n  PointerT operator->() { return &static_cast<DerivedT *>(this)->operator*(); }\n  PointerT operator->() const {\n    return &static_cast<const DerivedT *>(this)->operator*();\n  }\n  ReferenceProxy operator[](DifferenceTypeT n) {\n    static_assert(IsRandomAccess,\n                  \"Subscripting is only defined for random access iterators.\");\n    return ReferenceProxy(static_cast<DerivedT *>(this)->operator+(n));\n  }\n  ReferenceProxy operator[](DifferenceTypeT n) const {\n    static_assert(IsRandomAccess,\n                  \"Subscripting is only defined for random access iterators.\");\n    return ReferenceProxy(static_cast<const DerivedT *>(this)->operator+(n));\n  }\n};\n\n/// CRTP base class for adapting an iterator to a different type.\n///\n/// This class can be used through CRTP to adapt one iterator into another.\n/// Typically this is done through providing in the derived class a custom \\c\n/// operator* implementation. Other methods can be overridden as well.\ntemplate <\n    typename DerivedT, typename WrappedIteratorT,\n    typename IteratorCategoryT =\n        typename std::iterator_traits<WrappedIteratorT>::iterator_category,\n    typename T = typename std::iterator_traits<WrappedIteratorT>::value_type,\n    typename DifferenceTypeT =\n        typename std::iterator_traits<WrappedIteratorT>::difference_type,\n    typename PointerT = std::conditional_t<\n        std::is_same<T, typename std::iterator_traits<\n                            WrappedIteratorT>::value_type>::value,\n        typename std::iterator_traits<WrappedIteratorT>::pointer, T *>,\n    typename ReferenceT = std::conditional_t<\n        std::is_same<T, typename std::iterator_traits<\n                            WrappedIteratorT>::value_type>::value,\n        typename std::iterator_traits<WrappedIteratorT>::reference, T &>>\nclass iterator_adaptor_base\n    : public iterator_facade_base<DerivedT, IteratorCategoryT, T,\n                                  DifferenceTypeT, PointerT, ReferenceT> {\n  using BaseT = typename iterator_adaptor_base::iterator_facade_base;\n\nprotected:\n  WrappedIteratorT I;\n\n  iterator_adaptor_base() = default;\n\n  explicit iterator_adaptor_base(WrappedIteratorT u) : I(std::move(u)) {\n    static_assert(std::is_base_of<iterator_adaptor_base, DerivedT>::value,\n                  \"Must pass the derived type to this template!\");\n  }\n\n  const WrappedIteratorT &wrapped() const { return I; }\n\npublic:\n  using difference_type = DifferenceTypeT;\n\n  DerivedT &operator+=(difference_type n) {\n    static_assert(\n        BaseT::IsRandomAccess,\n        \"The '+=' operator is only defined for random access iterators.\");\n    I += n;\n    return *static_cast<DerivedT *>(this);\n  }\n  DerivedT &operator-=(difference_type n) {\n    static_assert(\n        BaseT::IsRandomAccess,\n        \"The '-=' operator is only defined for random access iterators.\");\n    I -= n;\n    return *static_cast<DerivedT *>(this);\n  }\n  using BaseT::operator-;\n  difference_type operator-(const DerivedT &RHS) const {\n    static_assert(\n        BaseT::IsRandomAccess,\n        \"The '-' operator is only defined for random access iterators.\");\n    return I - RHS.I;\n  }\n\n  // We have to explicitly provide ++ and -- rather than letting the facade\n  // forward to += because WrappedIteratorT might not support +=.\n  using BaseT::operator++;\n  DerivedT &operator++() {\n    ++I;\n    return *static_cast<DerivedT *>(this);\n  }\n  using BaseT::operator--;\n  DerivedT &operator--() {\n    static_assert(\n        BaseT::IsBidirectional,\n        \"The decrement operator is only defined for bidirectional iterators.\");\n    --I;\n    return *static_cast<DerivedT *>(this);\n  }\n\n  friend bool operator==(const iterator_adaptor_base &LHS,\n                         const iterator_adaptor_base &RHS) {\n    return LHS.I == RHS.I;\n  }\n  friend bool operator<(const iterator_adaptor_base &LHS,\n                        const iterator_adaptor_base &RHS) {\n    static_assert(\n        BaseT::IsRandomAccess,\n        \"Relational operators are only defined for random access iterators.\");\n    return LHS.I < RHS.I;\n  }\n\n  ReferenceT operator*() const { return *I; }\n};\n\n/// An iterator type that allows iterating over the pointees via some\n/// other iterator.\n///\n/// The typical usage of this is to expose a type that iterates over Ts, but\n/// which is implemented with some iterator over T*s:\n///\n/// \\code\n///   using iterator = pointee_iterator<SmallVectorImpl<T *>::iterator>;\n/// \\endcode\ntemplate <typename WrappedIteratorT,\n          typename T = std::remove_reference_t<decltype(\n              **std::declval<WrappedIteratorT>())>>\nstruct pointee_iterator\n    : iterator_adaptor_base<\n          pointee_iterator<WrappedIteratorT, T>, WrappedIteratorT,\n          typename std::iterator_traits<WrappedIteratorT>::iterator_category,\n          T> {\n  pointee_iterator() = default;\n  template <typename U>\n  pointee_iterator(U &&u)\n      : pointee_iterator::iterator_adaptor_base(std::forward<U &&>(u)) {}\n\n  T &operator*() const { return **this->I; }\n};\n\ntemplate <typename RangeT, typename WrappedIteratorT =\n                               decltype(std::begin(std::declval<RangeT>()))>\niterator_range<pointee_iterator<WrappedIteratorT>>\nmake_pointee_range(RangeT &&Range) {\n  using PointeeIteratorT = pointee_iterator<WrappedIteratorT>;\n  return make_range(PointeeIteratorT(std::begin(std::forward<RangeT>(Range))),\n                    PointeeIteratorT(std::end(std::forward<RangeT>(Range))));\n}\n\ntemplate <typename WrappedIteratorT,\n          typename T = decltype(&*std::declval<WrappedIteratorT>())>\nclass pointer_iterator\n    : public iterator_adaptor_base<\n          pointer_iterator<WrappedIteratorT, T>, WrappedIteratorT,\n          typename std::iterator_traits<WrappedIteratorT>::iterator_category,\n          T> {\n  mutable T Ptr;\n\npublic:\n  pointer_iterator() = default;\n\n  explicit pointer_iterator(WrappedIteratorT u)\n      : pointer_iterator::iterator_adaptor_base(std::move(u)) {}\n\n  T &operator*() { return Ptr = &*this->I; }\n  const T &operator*() const { return Ptr = &*this->I; }\n};\n\ntemplate <typename RangeT, typename WrappedIteratorT =\n                               decltype(std::begin(std::declval<RangeT>()))>\niterator_range<pointer_iterator<WrappedIteratorT>>\nmake_pointer_range(RangeT &&Range) {\n  using PointerIteratorT = pointer_iterator<WrappedIteratorT>;\n  return make_range(PointerIteratorT(std::begin(std::forward<RangeT>(Range))),\n                    PointerIteratorT(std::end(std::forward<RangeT>(Range))));\n}\n\ntemplate <typename WrappedIteratorT,\n          typename T1 = std::remove_reference_t<decltype(\n              **std::declval<WrappedIteratorT>())>,\n          typename T2 = std::add_pointer_t<T1>>\nusing raw_pointer_iterator =\n    pointer_iterator<pointee_iterator<WrappedIteratorT, T1>, T2>;\n\n// Wrapper iterator over iterator ItType, adding DataRef to the type of ItType,\n// to create NodeRef = std::pair<InnerTypeOfItType, DataRef>.\ntemplate <typename ItType, typename NodeRef, typename DataRef>\nclass WrappedPairNodeDataIterator\n    : public iterator_adaptor_base<\n          WrappedPairNodeDataIterator<ItType, NodeRef, DataRef>, ItType,\n          typename std::iterator_traits<ItType>::iterator_category, NodeRef,\n          std::ptrdiff_t, NodeRef *, NodeRef &> {\n  using BaseT = iterator_adaptor_base<\n      WrappedPairNodeDataIterator, ItType,\n      typename std::iterator_traits<ItType>::iterator_category, NodeRef,\n      std::ptrdiff_t, NodeRef *, NodeRef &>;\n\n  const DataRef DR;\n  mutable NodeRef NR;\n\npublic:\n  WrappedPairNodeDataIterator(ItType Begin, const DataRef DR)\n      : BaseT(Begin), DR(DR) {\n    NR.first = DR;\n  }\n\n  NodeRef &operator*() const {\n    NR.second = *this->I;\n    return NR;\n  }\n};\n\n} // end namespace llvm\n\n#endif // LLVM_ADT_ITERATOR_H\n"}, "69": {"id": 69, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/AlignOf.h", "content": "//===--- AlignOf.h - Portable calculation of type alignment -----*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// This file defines the AlignedCharArrayUnion class.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_SUPPORT_ALIGNOF_H\n#define LLVM_SUPPORT_ALIGNOF_H\n\n#include <type_traits>\n\nnamespace llvm {\n\n/// A suitably aligned and sized character array member which can hold elements\n/// of any type.\n///\n/// This template is equivalent to std::aligned_union_t<1, ...>, but we cannot\n/// use it due to a bug in the MSVC x86 compiler:\n/// https://github.com/microsoft/STL/issues/1533\n/// Using `alignas` here works around the bug.\ntemplate <typename T, typename... Ts> struct AlignedCharArrayUnion {\n  using AlignedUnion = std::aligned_union_t<1, T, Ts...>;\n  alignas(alignof(AlignedUnion)) char buffer[sizeof(AlignedUnion)];\n};\n\n} // end namespace llvm\n\n#endif // LLVM_SUPPORT_ALIGNOF_H\n"}, "71": {"id": 71, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/AllocatorBase.h", "content": "//===- AllocatorBase.h - Simple memory allocation abstraction ---*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n/// \\file\n///\n/// This file defines MallocAllocator. MallocAllocator conforms to the LLVM\n/// \"Allocator\" concept which consists of an Allocate method accepting a size\n/// and alignment, and a Deallocate accepting a pointer and size. Further, the\n/// LLVM \"Allocator\" concept has overloads of Allocate and Deallocate for\n/// setting size and alignment based on the final type. These overloads are\n/// typically provided by a base class template \\c AllocatorBase.\n///\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_SUPPORT_ALLOCATORBASE_H\n#define LLVM_SUPPORT_ALLOCATORBASE_H\n\n#include \"llvm/Support/Compiler.h\"\n#include \"llvm/Support/MemAlloc.h\"\n\nnamespace llvm {\n\n/// CRTP base class providing obvious overloads for the core \\c\n/// Allocate() methods of LLVM-style allocators.\n///\n/// This base class both documents the full public interface exposed by all\n/// LLVM-style allocators, and redirects all of the overloads to a single core\n/// set of methods which the derived class must define.\ntemplate <typename DerivedT> class AllocatorBase {\npublic:\n  /// Allocate \\a Size bytes of \\a Alignment aligned memory. This method\n  /// must be implemented by \\c DerivedT.\n  void *Allocate(size_t Size, size_t Alignment) {\n#ifdef __clang__\n    static_assert(static_cast<void *(AllocatorBase::*)(size_t, size_t)>(\n                      &AllocatorBase::Allocate) !=\n                      static_cast<void *(DerivedT::*)(size_t, size_t)>(\n                          &DerivedT::Allocate),\n                  \"Class derives from AllocatorBase without implementing the \"\n                  \"core Allocate(size_t, size_t) overload!\");\n#endif\n    return static_cast<DerivedT *>(this)->Allocate(Size, Alignment);\n  }\n\n  /// Deallocate \\a Ptr to \\a Size bytes of memory allocated by this\n  /// allocator.\n  void Deallocate(const void *Ptr, size_t Size, size_t Alignment) {\n#ifdef __clang__\n    static_assert(\n        static_cast<void (AllocatorBase::*)(const void *, size_t, size_t)>(\n            &AllocatorBase::Deallocate) !=\n            static_cast<void (DerivedT::*)(const void *, size_t, size_t)>(\n                &DerivedT::Deallocate),\n        \"Class derives from AllocatorBase without implementing the \"\n        \"core Deallocate(void *) overload!\");\n#endif\n    return static_cast<DerivedT *>(this)->Deallocate(Ptr, Size, Alignment);\n  }\n\n  // The rest of these methods are helpers that redirect to one of the above\n  // core methods.\n\n  /// Allocate space for a sequence of objects without constructing them.\n  template <typename T> T *Allocate(size_t Num = 1) {\n    return static_cast<T *>(Allocate(Num * sizeof(T), alignof(T)));\n  }\n\n  /// Deallocate space for a sequence of objects without constructing them.\n  template <typename T>\n  std::enable_if_t<!std::is_same<std::remove_cv_t<T>, void>::value, void>\n  Deallocate(T *Ptr, size_t Num = 1) {\n    Deallocate(static_cast<const void *>(Ptr), Num * sizeof(T), alignof(T));\n  }\n};\n\nclass MallocAllocator : public AllocatorBase<MallocAllocator> {\npublic:\n  void Reset() {}\n\n  LLVM_ATTRIBUTE_RETURNS_NONNULL void *Allocate(size_t Size, size_t Alignment) {\n    return allocate_buffer(Size, Alignment);\n  }\n\n  // Pull in base class overloads.\n  using AllocatorBase<MallocAllocator>::Allocate;\n\n  void Deallocate(const void *Ptr, size_t Size, size_t Alignment) {\n    deallocate_buffer(const_cast<void *>(Ptr), Size, Alignment);\n  }\n\n  // Pull in base class overloads.\n  using AllocatorBase<MallocAllocator>::Deallocate;\n\n  void PrintStats() const {}\n};\n\n} // namespace llvm\n\n#endif // LLVM_SUPPORT_ALLOCATORBASE_H\n"}, "80": {"id": 80, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/JSON.h", "content": "//===--- JSON.h - JSON values, parsing and serialization -------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===---------------------------------------------------------------------===//\n///\n/// \\file\n/// This file supports working with JSON data.\n///\n/// It comprises:\n///\n/// - classes which hold dynamically-typed parsed JSON structures\n///   These are value types that can be composed, inspected, and modified.\n///   See json::Value, and the related types json::Object and json::Array.\n///\n/// - functions to parse JSON text into Values, and to serialize Values to text.\n///   See parse(), operator<<, and format_provider.\n///\n/// - a convention and helpers for mapping between json::Value and user-defined\n///   types. See fromJSON(), ObjectMapper, and the class comment on Value.\n///\n/// - an output API json::OStream which can emit JSON without materializing\n///   all structures as json::Value.\n///\n/// Typically, JSON data would be read from an external source, parsed into\n/// a Value, and then converted into some native data structure before doing\n/// real work on it. (And vice versa when writing).\n///\n/// Other serialization mechanisms you may consider:\n///\n/// - YAML is also text-based, and more human-readable than JSON. It's a more\n///   complex format and data model, and YAML parsers aren't ubiquitous.\n///   YAMLParser.h is a streaming parser suitable for parsing large documents\n///   (including JSON, as YAML is a superset). It can be awkward to use\n///   directly. YAML I/O (YAMLTraits.h) provides data mapping that is more\n///   declarative than the toJSON/fromJSON conventions here.\n///\n/// - LLVM bitstream is a space- and CPU- efficient binary format. Typically it\n///   encodes LLVM IR (\"bitcode\"), but it can be a container for other data.\n///   Low-level reader/writer libraries are in Bitstream/Bitstream*.h\n///\n//===---------------------------------------------------------------------===//\n\n#ifndef LLVM_SUPPORT_JSON_H\n#define LLVM_SUPPORT_JSON_H\n\n#include \"llvm/ADT/DenseMap.h\"\n#include \"llvm/ADT/SmallVector.h\"\n#include \"llvm/ADT/StringRef.h\"\n#include \"llvm/Support/Error.h\"\n#include \"llvm/Support/FormatVariadic.h\"\n#include \"llvm/Support/raw_ostream.h\"\n#include <map>\n\nnamespace llvm {\nnamespace json {\n\n// === String encodings ===\n//\n// JSON strings are character sequences (not byte sequences like std::string).\n// We need to know the encoding, and for simplicity only support UTF-8.\n//\n//   - When parsing, invalid UTF-8 is a syntax error like any other\n//\n//   - When creating Values from strings, callers must ensure they are UTF-8.\n//        with asserts on, invalid UTF-8 will crash the program\n//        with asserts off, we'll substitute the replacement character (U+FFFD)\n//     Callers can use json::isUTF8() and json::fixUTF8() for validation.\n//\n//   - When retrieving strings from Values (e.g. asString()), the result will\n//     always be valid UTF-8.\n\n/// Returns true if \\p S is valid UTF-8, which is required for use as JSON.\n/// If it returns false, \\p Offset is set to a byte offset near the first error.\nbool isUTF8(llvm::StringRef S, size_t *ErrOffset = nullptr);\n/// Replaces invalid UTF-8 sequences in \\p S with the replacement character\n/// (U+FFFD). The returned string is valid UTF-8.\n/// This is much slower than isUTF8, so test that first.\nstd::string fixUTF8(llvm::StringRef S);\n\nclass Array;\nclass ObjectKey;\nclass Value;\ntemplate <typename T> Value toJSON(const llvm::Optional<T> &Opt);\n\n/// An Object is a JSON object, which maps strings to heterogenous JSON values.\n/// It simulates DenseMap<ObjectKey, Value>. ObjectKey is a maybe-owned string.\nclass Object {\n  using Storage = DenseMap<ObjectKey, Value, llvm::DenseMapInfo<StringRef>>;\n  Storage M;\n\npublic:\n  using key_type = ObjectKey;\n  using mapped_type = Value;\n  using value_type = Storage::value_type;\n  using iterator = Storage::iterator;\n  using const_iterator = Storage::const_iterator;\n\n  Object() = default;\n  // KV is a trivial key-value struct for list-initialization.\n  // (using std::pair forces extra copies).\n  struct KV;\n  explicit Object(std::initializer_list<KV> Properties);\n\n  iterator begin() { return M.begin(); }\n  const_iterator begin() const { return M.begin(); }\n  iterator end() { return M.end(); }\n  const_iterator end() const { return M.end(); }\n\n  bool empty() const { return M.empty(); }\n  size_t size() const { return M.size(); }\n\n  void clear() { M.clear(); }\n  std::pair<iterator, bool> insert(KV E);\n  template <typename... Ts>\n  std::pair<iterator, bool> try_emplace(const ObjectKey &K, Ts &&... Args) {\n    return M.try_emplace(K, std::forward<Ts>(Args)...);\n  }\n  template <typename... Ts>\n  std::pair<iterator, bool> try_emplace(ObjectKey &&K, Ts &&... Args) {\n    return M.try_emplace(std::move(K), std::forward<Ts>(Args)...);\n  }\n  bool erase(StringRef K);\n  void erase(iterator I) { M.erase(I); }\n\n  iterator find(StringRef K) { return M.find_as(K); }\n  const_iterator find(StringRef K) const { return M.find_as(K); }\n  // operator[] acts as if Value was default-constructible as null.\n  Value &operator[](const ObjectKey &K);\n  Value &operator[](ObjectKey &&K);\n  // Look up a property, returning nullptr if it doesn't exist.\n  Value *get(StringRef K);\n  const Value *get(StringRef K) const;\n  // Typed accessors return None/nullptr if\n  //   - the property doesn't exist\n  //   - or it has the wrong type\n  llvm::Optional<std::nullptr_t> getNull(StringRef K) const;\n  llvm::Optional<bool> getBoolean(StringRef K) const;\n  llvm::Optional<double> getNumber(StringRef K) const;\n  llvm::Optional<int64_t> getInteger(StringRef K) const;\n  llvm::Optional<llvm::StringRef> getString(StringRef K) const;\n  const json::Object *getObject(StringRef K) const;\n  json::Object *getObject(StringRef K);\n  const json::Array *getArray(StringRef K) const;\n  json::Array *getArray(StringRef K);\n};\nbool operator==(const Object &LHS, const Object &RHS);\ninline bool operator!=(const Object &LHS, const Object &RHS) {\n  return !(LHS == RHS);\n}\n\n/// An Array is a JSON array, which contains heterogeneous JSON values.\n/// It simulates std::vector<Value>.\nclass Array {\n  std::vector<Value> V;\n\npublic:\n  using value_type = Value;\n  using iterator = std::vector<Value>::iterator;\n  using const_iterator = std::vector<Value>::const_iterator;\n\n  Array() = default;\n  explicit Array(std::initializer_list<Value> Elements);\n  template <typename Collection> explicit Array(const Collection &C) {\n    for (const auto &V : C)\n      emplace_back(V);\n  }\n\n  Value &operator[](size_t I) { return V[I]; }\n  const Value &operator[](size_t I) const { return V[I]; }\n  Value &front() { return V.front(); }\n  const Value &front() const { return V.front(); }\n  Value &back() { return V.back(); }\n  const Value &back() const { return V.back(); }\n  Value *data() { return V.data(); }\n  const Value *data() const { return V.data(); }\n\n  iterator begin() { return V.begin(); }\n  const_iterator begin() const { return V.begin(); }\n  iterator end() { return V.end(); }\n  const_iterator end() const { return V.end(); }\n\n  bool empty() const { return V.empty(); }\n  size_t size() const { return V.size(); }\n  void reserve(size_t S) { V.reserve(S); }\n\n  void clear() { V.clear(); }\n  void push_back(const Value &E) { V.push_back(E); }\n  void push_back(Value &&E) { V.push_back(std::move(E)); }\n  template <typename... Args> void emplace_back(Args &&... A) {\n    V.emplace_back(std::forward<Args>(A)...);\n  }\n  void pop_back() { V.pop_back(); }\n  // FIXME: insert() takes const_iterator since C++11, old libstdc++ disagrees.\n  iterator insert(iterator P, const Value &E) { return V.insert(P, E); }\n  iterator insert(iterator P, Value &&E) {\n    return V.insert(P, std::move(E));\n  }\n  template <typename It> iterator insert(iterator P, It A, It Z) {\n    return V.insert(P, A, Z);\n  }\n  template <typename... Args> iterator emplace(const_iterator P, Args &&... A) {\n    return V.emplace(P, std::forward<Args>(A)...);\n  }\n\n  friend bool operator==(const Array &L, const Array &R) { return L.V == R.V; }\n};\ninline bool operator!=(const Array &L, const Array &R) { return !(L == R); }\n\n/// A Value is an JSON value of unknown type.\n/// They can be copied, but should generally be moved.\n///\n/// === Composing values ===\n///\n/// You can implicitly construct Values from:\n///   - strings: std::string, SmallString, formatv, StringRef, char*\n///              (char*, and StringRef are references, not copies!)\n///   - numbers\n///   - booleans\n///   - null: nullptr\n///   - arrays: {\"foo\", 42.0, false}\n///   - serializable things: types with toJSON(const T&)->Value, found by ADL\n///\n/// They can also be constructed from object/array helpers:\n///   - json::Object is a type like map<ObjectKey, Value>\n///   - json::Array is a type like vector<Value>\n/// These can be list-initialized, or used to build up collections in a loop.\n/// json::ary(Collection) converts all items in a collection to Values.\n///\n/// === Inspecting values ===\n///\n/// Each Value is one of the JSON kinds:\n///   null    (nullptr_t)\n///   boolean (bool)\n///   number  (double or int64)\n///   string  (StringRef)\n///   array   (json::Array)\n///   object  (json::Object)\n///\n/// The kind can be queried directly, or implicitly via the typed accessors:\n///   if (Optional<StringRef> S = E.getAsString()\n///     assert(E.kind() == Value::String);\n///\n/// Array and Object also have typed indexing accessors for easy traversal:\n///   Expected<Value> E = parse(R\"( {\"options\": {\"font\": \"sans-serif\"}} )\");\n///   if (Object* O = E->getAsObject())\n///     if (Object* Opts = O->getObject(\"options\"))\n///       if (Optional<StringRef> Font = Opts->getString(\"font\"))\n///         assert(Opts->at(\"font\").kind() == Value::String);\n///\n/// === Converting JSON values to C++ types ===\n///\n/// The convention is to have a deserializer function findable via ADL:\n///     fromJSON(const json::Value&, T&, Path) -> bool\n///\n/// The return value indicates overall success, and Path is used for precise\n/// error reporting. (The Path::Root passed in at the top level fromJSON call\n/// captures any nested error and can render it in context).\n/// If conversion fails, fromJSON calls Path::report() and immediately returns.\n/// This ensures that the first fatal error survives.\n///\n/// Deserializers are provided for:\n///   - bool\n///   - int and int64_t\n///   - double\n///   - std::string\n///   - vector<T>, where T is deserializable\n///   - map<string, T>, where T is deserializable\n///   - Optional<T>, where T is deserializable\n/// ObjectMapper can help writing fromJSON() functions for object types.\n///\n/// For conversion in the other direction, the serializer function is:\n///    toJSON(const T&) -> json::Value\n/// If this exists, then it also allows constructing Value from T, and can\n/// be used to serialize vector<T>, map<string, T>, and Optional<T>.\n///\n/// === Serialization ===\n///\n/// Values can be serialized to JSON:\n///   1) raw_ostream << Value                    // Basic formatting.\n///   2) raw_ostream << formatv(\"{0}\", Value)    // Basic formatting.\n///   3) raw_ostream << formatv(\"{0:2}\", Value)  // Pretty-print with indent 2.\n///\n/// And parsed:\n///   Expected<Value> E = json::parse(\"[1, 2, null]\");\n///   assert(E && E->kind() == Value::Array);\nclass Value {\npublic:\n  enum Kind {\n    Null,\n    Boolean,\n    /// Number values can store both int64s and doubles at full precision,\n    /// depending on what they were constructed/parsed from.\n    Number,\n    String,\n    Array,\n    Object,\n  };\n\n  // It would be nice to have Value() be null. But that would make {} null too.\n  Value(const Value &M) { copyFrom(M); }\n  Value(Value &&M) { moveFrom(std::move(M)); }\n  Value(std::initializer_list<Value> Elements);\n  Value(json::Array &&Elements) : Type(T_Array) {\n    create<json::Array>(std::move(Elements));\n  }\n  template <typename Elt>\n  Value(const std::vector<Elt> &C) : Value(json::Array(C)) {}\n  Value(json::Object &&Properties) : Type(T_Object) {\n    create<json::Object>(std::move(Properties));\n  }\n  template <typename Elt>\n  Value(const std::map<std::string, Elt> &C) : Value(json::Object(C)) {}\n  // Strings: types with value semantics. Must be valid UTF-8.\n  Value(std::string V) : Type(T_String) {\n    if (LLVM_UNLIKELY(!isUTF8(V))) {\n      assert(false && \"Invalid UTF-8 in value used as JSON\");\n      V = fixUTF8(std::move(V));\n    }\n    create<std::string>(std::move(V));\n  }\n  Value(const llvm::SmallVectorImpl<char> &V)\n      : Value(std::string(V.begin(), V.end())) {}\n  Value(const llvm::formatv_object_base &V) : Value(V.str()) {}\n  // Strings: types with reference semantics. Must be valid UTF-8.\n  Value(StringRef V) : Type(T_StringRef) {\n    create<llvm::StringRef>(V);\n    if (LLVM_UNLIKELY(!isUTF8(V))) {\n      assert(false && \"Invalid UTF-8 in value used as JSON\");\n      *this = Value(fixUTF8(V));\n    }\n  }\n  Value(const char *V) : Value(StringRef(V)) {}\n  Value(std::nullptr_t) : Type(T_Null) {}\n  // Boolean (disallow implicit conversions).\n  // (The last template parameter is a dummy to keep templates distinct.)\n  template <typename T,\n            typename = std::enable_if_t<std::is_same<T, bool>::value>,\n            bool = false>\n  Value(T B) : Type(T_Boolean) {\n    create<bool>(B);\n  }\n  // Integers (except boolean). Must be non-narrowing convertible to int64_t.\n  template <typename T, typename = std::enable_if_t<std::is_integral<T>::value>,\n            typename = std::enable_if_t<!std::is_same<T, bool>::value>>\n  Value(T I) : Type(T_Integer) {\n    create<int64_t>(int64_t{I});\n  }\n  // Floating point. Must be non-narrowing convertible to double.\n  template <typename T,\n            typename = std::enable_if_t<std::is_floating_point<T>::value>,\n            double * = nullptr>\n  Value(T D) : Type(T_Double) {\n    create<double>(double{D});\n  }\n  // Serializable types: with a toJSON(const T&)->Value function, found by ADL.\n  template <typename T,\n            typename = std::enable_if_t<std::is_same<\n                Value, decltype(toJSON(*(const T *)nullptr))>::value>,\n            Value * = nullptr>\n  Value(const T &V) : Value(toJSON(V)) {}\n\n  Value &operator=(const Value &M) {\n    destroy();\n    copyFrom(M);\n    return *this;\n  }\n  Value &operator=(Value &&M) {\n    destroy();\n    moveFrom(std::move(M));\n    return *this;\n  }\n  ~Value() { destroy(); }\n\n  Kind kind() const {\n    switch (Type) {\n    case T_Null:\n      return Null;\n    case T_Boolean:\n      return Boolean;\n    case T_Double:\n    case T_Integer:\n      return Number;\n    case T_String:\n    case T_StringRef:\n      return String;\n    case T_Object:\n      return Object;\n    case T_Array:\n      return Array;\n    }\n    llvm_unreachable(\"Unknown kind\");\n  }\n\n  // Typed accessors return None/nullptr if the Value is not of this type.\n  llvm::Optional<std::nullptr_t> getAsNull() const {\n    if (LLVM_LIKELY(Type == T_Null))\n      return nullptr;\n    return llvm::None;\n  }\n  llvm::Optional<bool> getAsBoolean() const {\n    if (LLVM_LIKELY(Type == T_Boolean))\n      return as<bool>();\n    return llvm::None;\n  }\n  llvm::Optional<double> getAsNumber() const {\n    if (LLVM_LIKELY(Type == T_Double))\n      return as<double>();\n    if (LLVM_LIKELY(Type == T_Integer))\n      return as<int64_t>();\n    return llvm::None;\n  }\n  // Succeeds if the Value is a Number, and exactly representable as int64_t.\n  llvm::Optional<int64_t> getAsInteger() const {\n    if (LLVM_LIKELY(Type == T_Integer))\n      return as<int64_t>();\n    if (LLVM_LIKELY(Type == T_Double)) {\n      double D = as<double>();\n      if (LLVM_LIKELY(std::modf(D, &D) == 0.0 &&\n                      D >= double(std::numeric_limits<int64_t>::min()) &&\n                      D <= double(std::numeric_limits<int64_t>::max())))\n        return D;\n    }\n    return llvm::None;\n  }\n  llvm::Optional<llvm::StringRef> getAsString() const {\n    if (Type == T_String)\n      return llvm::StringRef(as<std::string>());\n    if (LLVM_LIKELY(Type == T_StringRef))\n      return as<llvm::StringRef>();\n    return llvm::None;\n  }\n  const json::Object *getAsObject() const {\n    return LLVM_LIKELY(Type == T_Object) ? &as<json::Object>() : nullptr;\n  }\n  json::Object *getAsObject() {\n    return LLVM_LIKELY(Type == T_Object) ? &as<json::Object>() : nullptr;\n  }\n  const json::Array *getAsArray() const {\n    return LLVM_LIKELY(Type == T_Array) ? &as<json::Array>() : nullptr;\n  }\n  json::Array *getAsArray() {\n    return LLVM_LIKELY(Type == T_Array) ? &as<json::Array>() : nullptr;\n  }\n\nprivate:\n  void destroy();\n  void copyFrom(const Value &M);\n  // We allow moving from *const* Values, by marking all members as mutable!\n  // This hack is needed to support initializer-list syntax efficiently.\n  // (std::initializer_list<T> is a container of const T).\n  void moveFrom(const Value &&M);\n  friend class Array;\n  friend class Object;\n\n  template <typename T, typename... U> void create(U &&... V) {\n    new (reinterpret_cast<T *>(&Union)) T(std::forward<U>(V)...);\n  }\n  template <typename T> T &as() const {\n    // Using this two-step static_cast via void * instead of reinterpret_cast\n    // silences a -Wstrict-aliasing false positive from GCC6 and earlier.\n    void *Storage = static_cast<void *>(&Union);\n    return *static_cast<T *>(Storage);\n  }\n\n  friend class OStream;\n\n  enum ValueType : char {\n    T_Null,\n    T_Boolean,\n    T_Double,\n    T_Integer,\n    T_StringRef,\n    T_String,\n    T_Object,\n    T_Array,\n  };\n  // All members mutable, see moveFrom().\n  mutable ValueType Type;\n  mutable llvm::AlignedCharArrayUnion<bool, double, int64_t, llvm::StringRef,\n                                      std::string, json::Array, json::Object>\n      Union;\n  friend bool operator==(const Value &, const Value &);\n};\n\nbool operator==(const Value &, const Value &);\ninline bool operator!=(const Value &L, const Value &R) { return !(L == R); }\n\n/// ObjectKey is a used to capture keys in Object. Like Value but:\n///   - only strings are allowed\n///   - it's optimized for the string literal case (Owned == nullptr)\n/// Like Value, strings must be UTF-8. See isUTF8 documentation for details.\nclass ObjectKey {\npublic:\n  ObjectKey(const char *S) : ObjectKey(StringRef(S)) {}\n  ObjectKey(std::string S) : Owned(new std::string(std::move(S))) {\n    if (LLVM_UNLIKELY(!isUTF8(*Owned))) {\n      assert(false && \"Invalid UTF-8 in value used as JSON\");\n      *Owned = fixUTF8(std::move(*Owned));\n    }\n    Data = *Owned;\n  }\n  ObjectKey(llvm::StringRef S) : Data(S) {\n    if (LLVM_UNLIKELY(!isUTF8(Data))) {\n      assert(false && \"Invalid UTF-8 in value used as JSON\");\n      *this = ObjectKey(fixUTF8(S));\n    }\n  }\n  ObjectKey(const llvm::SmallVectorImpl<char> &V)\n      : ObjectKey(std::string(V.begin(), V.end())) {}\n  ObjectKey(const llvm::formatv_object_base &V) : ObjectKey(V.str()) {}\n\n  ObjectKey(const ObjectKey &C) { *this = C; }\n  ObjectKey(ObjectKey &&C) : ObjectKey(static_cast<const ObjectKey &&>(C)) {}\n  ObjectKey &operator=(const ObjectKey &C) {\n    if (C.Owned) {\n      Owned.reset(new std::string(*C.Owned));\n      Data = *Owned;\n    } else {\n      Data = C.Data;\n    }\n    return *this;\n  }\n  ObjectKey &operator=(ObjectKey &&) = default;\n\n  operator llvm::StringRef() const { return Data; }\n  std::string str() const { return Data.str(); }\n\nprivate:\n  // FIXME: this is unneccesarily large (3 pointers). Pointer + length + owned\n  // could be 2 pointers at most.\n  std::unique_ptr<std::string> Owned;\n  llvm::StringRef Data;\n};\n\ninline bool operator==(const ObjectKey &L, const ObjectKey &R) {\n  return llvm::StringRef(L) == llvm::StringRef(R);\n}\ninline bool operator!=(const ObjectKey &L, const ObjectKey &R) {\n  return !(L == R);\n}\ninline bool operator<(const ObjectKey &L, const ObjectKey &R) {\n  return StringRef(L) < StringRef(R);\n}\n\nstruct Object::KV {\n  ObjectKey K;\n  Value V;\n};\n\ninline Object::Object(std::initializer_list<KV> Properties) {\n  for (const auto &P : Properties) {\n    auto R = try_emplace(P.K, nullptr);\n    if (R.second)\n      R.first->getSecond().moveFrom(std::move(P.V));\n  }\n}\ninline std::pair<Object::iterator, bool> Object::insert(KV E) {\n  return try_emplace(std::move(E.K), std::move(E.V));\n}\ninline bool Object::erase(StringRef K) {\n  return M.erase(ObjectKey(K));\n}\n\n/// A \"cursor\" marking a position within a Value.\n/// The Value is a tree, and this is the path from the root to the current node.\n/// This is used to associate errors with particular subobjects.\nclass Path {\npublic:\n  class Root;\n\n  /// Records that the value at the current path is invalid.\n  /// Message is e.g. \"expected number\" and becomes part of the final error.\n  /// This overwrites any previously written error message in the root.\n  void report(llvm::StringLiteral Message);\n\n  /// The root may be treated as a Path.\n  Path(Root &R) : Parent(nullptr), Seg(&R) {}\n  /// Derives a path for an array element: this[Index]\n  Path index(unsigned Index) const { return Path(this, Segment(Index)); }\n  /// Derives a path for an object field: this.Field\n  Path field(StringRef Field) const { return Path(this, Segment(Field)); }\n\nprivate:\n  /// One element in a JSON path: an object field (.foo) or array index [27].\n  /// Exception: the root Path encodes a pointer to the Path::Root.\n  class Segment {\n    uintptr_t Pointer;\n    unsigned Offset;\n\n  public:\n    Segment() = default;\n    Segment(Root *R) : Pointer(reinterpret_cast<uintptr_t>(R)) {}\n    Segment(llvm::StringRef Field)\n        : Pointer(reinterpret_cast<uintptr_t>(Field.data())),\n          Offset(static_cast<unsigned>(Field.size())) {}\n    Segment(unsigned Index) : Pointer(0), Offset(Index) {}\n\n    bool isField() const { return Pointer != 0; }\n    StringRef field() const {\n      return StringRef(reinterpret_cast<const char *>(Pointer), Offset);\n    }\n    unsigned index() const { return Offset; }\n    Root *root() const { return reinterpret_cast<Root *>(Pointer); }\n  };\n\n  const Path *Parent;\n  Segment Seg;\n\n  Path(const Path *Parent, Segment S) : Parent(Parent), Seg(S) {}\n};\n\n/// The root is the trivial Path to the root value.\n/// It also stores the latest reported error and the path where it occurred.\nclass Path::Root {\n  llvm::StringRef Name;\n  llvm::StringLiteral ErrorMessage;\n  std::vector<Path::Segment> ErrorPath; // Only valid in error state. Reversed.\n\n  friend void Path::report(llvm::StringLiteral Message);\n\npublic:\n  Root(llvm::StringRef Name = \"\") : Name(Name), ErrorMessage(\"\") {}\n  // No copy/move allowed as there are incoming pointers.\n  Root(Root &&) = delete;\n  Root &operator=(Root &&) = delete;\n  Root(const Root &) = delete;\n  Root &operator=(const Root &) = delete;\n\n  /// Returns the last error reported, or else a generic error.\n  Error getError() const;\n  /// Print the root value with the error shown inline as a comment.\n  /// Unrelated parts of the value are elided for brevity, e.g.\n  ///   {\n  ///      \"id\": 42,\n  ///      \"name\": /* expected string */ null,\n  ///      \"properties\": { ... }\n  ///   }\n  void printErrorContext(const Value &, llvm::raw_ostream &) const;\n};\n\n// Standard deserializers are provided for primitive types.\n// See comments on Value.\ninline bool fromJSON(const Value &E, std::string &Out, Path P) {\n  if (auto S = E.getAsString()) {\n    Out = std::string(*S);\n    return true;\n  }\n  P.report(\"expected string\");\n  return false;\n}\ninline bool fromJSON(const Value &E, int &Out, Path P) {\n  if (auto S = E.getAsInteger()) {\n    Out = *S;\n    return true;\n  }\n  P.report(\"expected integer\");\n  return false;\n}\ninline bool fromJSON(const Value &E, int64_t &Out, Path P) {\n  if (auto S = E.getAsInteger()) {\n    Out = *S;\n    return true;\n  }\n  P.report(\"expected integer\");\n  return false;\n}\ninline bool fromJSON(const Value &E, double &Out, Path P) {\n  if (auto S = E.getAsNumber()) {\n    Out = *S;\n    return true;\n  }\n  P.report(\"expected number\");\n  return false;\n}\ninline bool fromJSON(const Value &E, bool &Out, Path P) {\n  if (auto S = E.getAsBoolean()) {\n    Out = *S;\n    return true;\n  }\n  P.report(\"expected boolean\");\n  return false;\n}\ninline bool fromJSON(const Value &E, std::nullptr_t &Out, Path P) {\n  if (auto S = E.getAsNull()) {\n    Out = *S;\n    return true;\n  }\n  P.report(\"expected null\");\n  return false;\n}\ntemplate <typename T>\nbool fromJSON(const Value &E, llvm::Optional<T> &Out, Path P) {\n  if (E.getAsNull()) {\n    Out = llvm::None;\n    return true;\n  }\n  T Result;\n  if (!fromJSON(E, Result, P))\n    return false;\n  Out = std::move(Result);\n  return true;\n}\ntemplate <typename T>\nbool fromJSON(const Value &E, std::vector<T> &Out, Path P) {\n  if (auto *A = E.getAsArray()) {\n    Out.clear();\n    Out.resize(A->size());\n    for (size_t I = 0; I < A->size(); ++I)\n      if (!fromJSON((*A)[I], Out[I], P.index(I)))\n        return false;\n    return true;\n  }\n  P.report(\"expected array\");\n  return false;\n}\ntemplate <typename T>\nbool fromJSON(const Value &E, std::map<std::string, T> &Out, Path P) {\n  if (auto *O = E.getAsObject()) {\n    Out.clear();\n    for (const auto &KV : *O)\n      if (!fromJSON(KV.second, Out[std::string(llvm::StringRef(KV.first))],\n                    P.field(KV.first)))\n        return false;\n    return true;\n  }\n  P.report(\"expected object\");\n  return false;\n}\n\n// Allow serialization of Optional<T> for supported T.\ntemplate <typename T> Value toJSON(const llvm::Optional<T> &Opt) {\n  return Opt ? Value(*Opt) : Value(nullptr);\n}\n\n/// Helper for mapping JSON objects onto protocol structs.\n///\n/// Example:\n/// \\code\n///   bool fromJSON(const Value &E, MyStruct &R, Path P) {\n///     ObjectMapper O(E, P);\n///     // When returning false, error details were already reported.\n///     return O && O.map(\"mandatory_field\", R.MandatoryField) &&\n///         O.mapOptional(\"optional_field\", R.OptionalField);\n///   }\n/// \\endcode\nclass ObjectMapper {\npublic:\n  /// If O is not an object, this mapper is invalid and an error is reported.\n  ObjectMapper(const Value &E, Path P) : O(E.getAsObject()), P(P) {\n    if (!O)\n      P.report(\"expected object\");\n  }\n\n  /// True if the expression is an object.\n  /// Must be checked before calling map().\n  operator bool() const { return O; }\n\n  /// Maps a property to a field.\n  /// If the property is missing or invalid, reports an error.\n  template <typename T> bool map(StringLiteral Prop, T &Out) {\n    assert(*this && \"Must check this is an object before calling map()\");\n    if (const Value *E = O->get(Prop))\n      return fromJSON(*E, Out, P.field(Prop));\n    P.field(Prop).report(\"missing value\");\n    return false;\n  }\n\n  /// Maps a property to a field, if it exists.\n  /// If the property exists and is invalid, reports an error.\n  /// (Optional requires special handling, because missing keys are OK).\n  template <typename T> bool map(StringLiteral Prop, llvm::Optional<T> &Out) {\n    assert(*this && \"Must check this is an object before calling map()\");\n    if (const Value *E = O->get(Prop))\n      return fromJSON(*E, Out, P.field(Prop));\n    Out = llvm::None;\n    return true;\n  }\n\n  /// Maps a property to a field, if it exists.\n  /// If the property exists and is invalid, reports an error.\n  /// If the property does not exist, Out is unchanged.\n  template <typename T> bool mapOptional(StringLiteral Prop, T &Out) {\n    assert(*this && \"Must check this is an object before calling map()\");\n    if (const Value *E = O->get(Prop))\n      return fromJSON(*E, Out, P.field(Prop));\n    return true;\n  }\n\nprivate:\n  const Object *O;\n  Path P;\n};\n\n/// Parses the provided JSON source, or returns a ParseError.\n/// The returned Value is self-contained and owns its strings (they do not refer\n/// to the original source).\nllvm::Expected<Value> parse(llvm::StringRef JSON);\n\nclass ParseError : public llvm::ErrorInfo<ParseError> {\n  const char *Msg;\n  unsigned Line, Column, Offset;\n\npublic:\n  static char ID;\n  ParseError(const char *Msg, unsigned Line, unsigned Column, unsigned Offset)\n      : Msg(Msg), Line(Line), Column(Column), Offset(Offset) {}\n  void log(llvm::raw_ostream &OS) const override {\n    OS << llvm::formatv(\"[{0}:{1}, byte={2}]: {3}\", Line, Column, Offset, Msg);\n  }\n  std::error_code convertToErrorCode() const override {\n    return llvm::inconvertibleErrorCode();\n  }\n};\n\n/// Version of parse() that converts the parsed value to the type T.\n/// RootName describes the root object and is used in error messages.\ntemplate <typename T>\nExpected<T> parse(const llvm::StringRef &JSON, const char *RootName = \"\") {\n  auto V = parse(JSON);\n  if (!V)\n    return V.takeError();\n  Path::Root R(RootName);\n  T Result;\n  if (fromJSON(*V, Result, R))\n    return std::move(Result);\n  return R.getError();\n}\n\n/// json::OStream allows writing well-formed JSON without materializing\n/// all structures as json::Value ahead of time.\n/// It's faster, lower-level, and less safe than OS << json::Value.\n/// It also allows emitting more constructs, such as comments.\n///\n/// Only one \"top-level\" object can be written to a stream.\n/// Simplest usage involves passing lambdas (Blocks) to fill in containers:\n///\n///   json::OStream J(OS);\n///   J.array([&]{\n///     for (const Event &E : Events)\n///       J.object([&] {\n///         J.attribute(\"timestamp\", int64_t(E.Time));\n///         J.attributeArray(\"participants\", [&] {\n///           for (const Participant &P : E.Participants)\n///             J.value(P.toString());\n///         });\n///       });\n///   });\n///\n/// This would produce JSON like:\n///\n///   [\n///     {\n///       \"timestamp\": 19287398741,\n///       \"participants\": [\n///         \"King Kong\",\n///         \"Miley Cyrus\",\n///         \"Cleopatra\"\n///       ]\n///     },\n///     ...\n///   ]\n///\n/// The lower level begin/end methods (arrayBegin()) are more flexible but\n/// care must be taken to pair them correctly:\n///\n///   json::OStream J(OS);\n//    J.arrayBegin();\n///   for (const Event &E : Events) {\n///     J.objectBegin();\n///     J.attribute(\"timestamp\", int64_t(E.Time));\n///     J.attributeBegin(\"participants\");\n///     for (const Participant &P : E.Participants)\n///       J.value(P.toString());\n///     J.attributeEnd();\n///     J.objectEnd();\n///   }\n///   J.arrayEnd();\n///\n/// If the call sequence isn't valid JSON, asserts will fire in debug mode.\n/// This can be mismatched begin()/end() pairs, trying to emit attributes inside\n/// an array, and so on.\n/// With asserts disabled, this is undefined behavior.\nclass OStream {\n public:\n  using Block = llvm::function_ref<void()>;\n  // If IndentSize is nonzero, output is pretty-printed.\n  explicit OStream(llvm::raw_ostream &OS, unsigned IndentSize = 0)\n      : OS(OS), IndentSize(IndentSize) {\n    Stack.emplace_back();\n  }\n  ~OStream() {\n    assert(Stack.size() == 1 && \"Unmatched begin()/end()\");\n    assert(Stack.back().Ctx == Singleton);\n    assert(Stack.back().HasValue && \"Did not write top-level value\");\n  }\n\n  /// Flushes the underlying ostream. OStream does not buffer internally.\n  void flush() { OS.flush(); }\n\n  // High level functions to output a value.\n  // Valid at top-level (exactly once), in an attribute value (exactly once),\n  // or in an array (any number of times).\n\n  /// Emit a self-contained value (number, string, vector<string> etc).\n  void value(const Value &V);\n  /// Emit an array whose elements are emitted in the provided Block.\n  void array(Block Contents) {\n    arrayBegin();\n    Contents();\n    arrayEnd();\n  }\n  /// Emit an object whose elements are emitted in the provided Block.\n  void object(Block Contents) {\n    objectBegin();\n    Contents();\n    objectEnd();\n  }\n  /// Emit an externally-serialized value.\n  /// The caller must write exactly one valid JSON value to the provided stream.\n  /// No validation or formatting of this value occurs.\n  void rawValue(llvm::function_ref<void(raw_ostream &)> Contents) {\n    rawValueBegin();\n    Contents(OS);\n    rawValueEnd();\n  }\n  void rawValue(llvm::StringRef Contents) {\n    rawValue([&](raw_ostream &OS) { OS << Contents; });\n  }\n  /// Emit a JavaScript comment associated with the next printed value.\n  /// The string must be valid until the next attribute or value is emitted.\n  /// Comments are not part of standard JSON, and many parsers reject them!\n  void comment(llvm::StringRef);\n\n  // High level functions to output object attributes.\n  // Valid only within an object (any number of times).\n\n  /// Emit an attribute whose value is self-contained (number, vector<int> etc).\n  void attribute(llvm::StringRef Key, const Value& Contents) {\n    attributeImpl(Key, [&] { value(Contents); });\n  }\n  /// Emit an attribute whose value is an array with elements from the Block.\n  void attributeArray(llvm::StringRef Key, Block Contents) {\n    attributeImpl(Key, [&] { array(Contents); });\n  }\n  /// Emit an attribute whose value is an object with attributes from the Block.\n  void attributeObject(llvm::StringRef Key, Block Contents) {\n    attributeImpl(Key, [&] { object(Contents); });\n  }\n\n  // Low-level begin/end functions to output arrays, objects, and attributes.\n  // Must be correctly paired. Allowed contexts are as above.\n\n  void arrayBegin();\n  void arrayEnd();\n  void objectBegin();\n  void objectEnd();\n  void attributeBegin(llvm::StringRef Key);\n  void attributeEnd();\n  raw_ostream &rawValueBegin();\n  void rawValueEnd();\n\nprivate:\n  void attributeImpl(llvm::StringRef Key, Block Contents) {\n    attributeBegin(Key);\n    Contents();\n    attributeEnd();\n  }\n\n  void valueBegin();\n  void flushComment();\n  void newline();\n\n  enum Context {\n    Singleton, // Top level, or object attribute.\n    Array,\n    Object,\n    RawValue, // External code writing a value to OS directly.\n  };\n  struct State {\n    Context Ctx = Singleton;\n    bool HasValue = false;\n  };\n  llvm::SmallVector<State, 16> Stack; // Never empty.\n  llvm::StringRef PendingComment;\n  llvm::raw_ostream &OS;\n  unsigned IndentSize;\n  unsigned Indent = 0;\n};\n\n/// Serializes this Value to JSON, writing it to the provided stream.\n/// The formatting is compact (no extra whitespace) and deterministic.\n/// For pretty-printing, use the formatv() format_provider below.\ninline llvm::raw_ostream &operator<<(llvm::raw_ostream &OS, const Value &V) {\n  OStream(OS).value(V);\n  return OS;\n}\n} // namespace json\n\n/// Allow printing json::Value with formatv().\n/// The default style is basic/compact formatting, like operator<<.\n/// A format string like formatv(\"{0:2}\", Value) pretty-prints with indent 2.\ntemplate <> struct format_provider<llvm::json::Value> {\n  static void format(const llvm::json::Value &, raw_ostream &, StringRef);\n};\n} // namespace llvm\n\n#endif\n"}, "88": {"id": 88, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/YAMLParser.h", "content": "//===- YAMLParser.h - Simple YAML parser ------------------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n//  This is a YAML 1.2 parser.\n//\n//  See http://www.yaml.org/spec/1.2/spec.html for the full standard.\n//\n//  This currently does not implement the following:\n//    * Multi-line literal folding.\n//    * Tag resolution.\n//    * UTF-16.\n//    * BOMs anywhere other than the first Unicode scalar value in the file.\n//\n//  The most important class here is Stream. This represents a YAML stream with\n//  0, 1, or many documents.\n//\n//  SourceMgr sm;\n//  StringRef input = getInput();\n//  yaml::Stream stream(input, sm);\n//\n//  for (yaml::document_iterator di = stream.begin(), de = stream.end();\n//       di != de; ++di) {\n//    yaml::Node *n = di->getRoot();\n//    if (n) {\n//      // Do something with n...\n//    } else\n//      break;\n//  }\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_SUPPORT_YAMLPARSER_H\n#define LLVM_SUPPORT_YAMLPARSER_H\n\n#include \"llvm/ADT/StringRef.h\"\n#include \"llvm/Support/Allocator.h\"\n#include \"llvm/Support/SMLoc.h\"\n#include \"llvm/Support/SourceMgr.h\"\n#include <cassert>\n#include <cstddef>\n#include <iterator>\n#include <map>\n#include <memory>\n#include <string>\n#include <system_error>\n\nnamespace llvm {\n\nclass MemoryBufferRef;\nclass raw_ostream;\nclass Twine;\n\nnamespace yaml {\n\nclass Document;\nclass document_iterator;\nclass Node;\nclass Scanner;\nstruct Token;\n\n/// Dump all the tokens in this stream to OS.\n/// \\returns true if there was an error, false otherwise.\nbool dumpTokens(StringRef Input, raw_ostream &);\n\n/// Scans all tokens in input without outputting anything. This is used\n///        for benchmarking the tokenizer.\n/// \\returns true if there was an error, false otherwise.\nbool scanTokens(StringRef Input);\n\n/// Escape \\a Input for a double quoted scalar; if \\p EscapePrintable\n/// is true, all UTF8 sequences will be escaped, if \\p EscapePrintable is\n/// false, those UTF8 sequences encoding printable unicode scalars will not be\n/// escaped, but emitted verbatim.\nstd::string escape(StringRef Input, bool EscapePrintable = true);\n\n/// Parse \\p S as a bool according to https://yaml.org/type/bool.html.\nllvm::Optional<bool> parseBool(StringRef S);\n\n/// This class represents a YAML stream potentially containing multiple\n///        documents.\nclass Stream {\npublic:\n  /// This keeps a reference to the string referenced by \\p Input.\n  Stream(StringRef Input, SourceMgr &, bool ShowColors = true,\n         std::error_code *EC = nullptr);\n\n  Stream(MemoryBufferRef InputBuffer, SourceMgr &, bool ShowColors = true,\n         std::error_code *EC = nullptr);\n  ~Stream();\n\n  document_iterator begin();\n  document_iterator end();\n  void skip();\n  bool failed();\n\n  bool validate() {\n    skip();\n    return !failed();\n  }\n\n  void printError(Node *N, const Twine &Msg,\n                  SourceMgr::DiagKind Kind = SourceMgr::DK_Error);\n  void printError(const SMRange &Range, const Twine &Msg,\n                  SourceMgr::DiagKind Kind = SourceMgr::DK_Error);\n\nprivate:\n  friend class Document;\n\n  std::unique_ptr<Scanner> scanner;\n  std::unique_ptr<Document> CurrentDoc;\n};\n\n/// Abstract base class for all Nodes.\nclass Node {\n  virtual void anchor();\n\npublic:\n  enum NodeKind {\n    NK_Null,\n    NK_Scalar,\n    NK_BlockScalar,\n    NK_KeyValue,\n    NK_Mapping,\n    NK_Sequence,\n    NK_Alias\n  };\n\n  Node(unsigned int Type, std::unique_ptr<Document> &, StringRef Anchor,\n       StringRef Tag);\n\n  // It's not safe to copy YAML nodes; the document is streamed and the position\n  // is part of the state.\n  Node(const Node &) = delete;\n  void operator=(const Node &) = delete;\n\n  void *operator new(size_t Size, BumpPtrAllocator &Alloc,\n                     size_t Alignment = 16) noexcept {\n    return Alloc.Allocate(Size, Alignment);\n  }\n\n  void operator delete(void *Ptr, BumpPtrAllocator &Alloc,\n                       size_t Size) noexcept {\n    Alloc.Deallocate(Ptr, Size, 0);\n  }\n\n  void operator delete(void *) noexcept = delete;\n\n  /// Get the value of the anchor attached to this node. If it does not\n  ///        have one, getAnchor().size() will be 0.\n  StringRef getAnchor() const { return Anchor; }\n\n  /// Get the tag as it was written in the document. This does not\n  ///   perform tag resolution.\n  StringRef getRawTag() const { return Tag; }\n\n  /// Get the verbatium tag for a given Node. This performs tag resoluton\n  ///   and substitution.\n  std::string getVerbatimTag() const;\n\n  SMRange getSourceRange() const { return SourceRange; }\n  void setSourceRange(SMRange SR) { SourceRange = SR; }\n\n  // These functions forward to Document and Scanner.\n  Token &peekNext();\n  Token getNext();\n  Node *parseBlockNode();\n  BumpPtrAllocator &getAllocator();\n  void setError(const Twine &Message, Token &Location) const;\n  bool failed() const;\n\n  virtual void skip() {}\n\n  unsigned int getType() const { return TypeID; }\n\nprotected:\n  std::unique_ptr<Document> &Doc;\n  SMRange SourceRange;\n\n  ~Node() = default;\n\nprivate:\n  unsigned int TypeID;\n  StringRef Anchor;\n  /// The tag as typed in the document.\n  StringRef Tag;\n};\n\n/// A null value.\n///\n/// Example:\n///   !!null null\nclass NullNode final : public Node {\n  void anchor() override;\n\npublic:\n  NullNode(std::unique_ptr<Document> &D)\n      : Node(NK_Null, D, StringRef(), StringRef()) {}\n\n  static bool classof(const Node *N) { return N->getType() == NK_Null; }\n};\n\n/// A scalar node is an opaque datum that can be presented as a\n///        series of zero or more Unicode scalar values.\n///\n/// Example:\n///   Adena\nclass ScalarNode final : public Node {\n  void anchor() override;\n\npublic:\n  ScalarNode(std::unique_ptr<Document> &D, StringRef Anchor, StringRef Tag,\n             StringRef Val)\n      : Node(NK_Scalar, D, Anchor, Tag), Value(Val) {\n    SMLoc Start = SMLoc::getFromPointer(Val.begin());\n    SMLoc End = SMLoc::getFromPointer(Val.end());\n    SourceRange = SMRange(Start, End);\n  }\n\n  // Return Value without any escaping or folding or other fun YAML stuff. This\n  // is the exact bytes that are contained in the file (after conversion to\n  // utf8).\n  StringRef getRawValue() const { return Value; }\n\n  /// Gets the value of this node as a StringRef.\n  ///\n  /// \\param Storage is used to store the content of the returned StringRef if\n  ///        it requires any modification from how it appeared in the source.\n  ///        This happens with escaped characters and multi-line literals.\n  StringRef getValue(SmallVectorImpl<char> &Storage) const;\n\n  static bool classof(const Node *N) {\n    return N->getType() == NK_Scalar;\n  }\n\nprivate:\n  StringRef Value;\n\n  StringRef unescapeDoubleQuoted(StringRef UnquotedValue,\n                                 StringRef::size_type Start,\n                                 SmallVectorImpl<char> &Storage) const;\n};\n\n/// A block scalar node is an opaque datum that can be presented as a\n///        series of zero or more Unicode scalar values.\n///\n/// Example:\n///   |\n///     Hello\n///     World\nclass BlockScalarNode final : public Node {\n  void anchor() override;\n\npublic:\n  BlockScalarNode(std::unique_ptr<Document> &D, StringRef Anchor, StringRef Tag,\n                  StringRef Value, StringRef RawVal)\n      : Node(NK_BlockScalar, D, Anchor, Tag), Value(Value) {\n    SMLoc Start = SMLoc::getFromPointer(RawVal.begin());\n    SMLoc End = SMLoc::getFromPointer(RawVal.end());\n    SourceRange = SMRange(Start, End);\n  }\n\n  /// Gets the value of this node as a StringRef.\n  StringRef getValue() const { return Value; }\n\n  static bool classof(const Node *N) {\n    return N->getType() == NK_BlockScalar;\n  }\n\nprivate:\n  StringRef Value;\n};\n\n/// A key and value pair. While not technically a Node under the YAML\n///        representation graph, it is easier to treat them this way.\n///\n/// TODO: Consider making this not a child of Node.\n///\n/// Example:\n///   Section: .text\nclass KeyValueNode final : public Node {\n  void anchor() override;\n\npublic:\n  KeyValueNode(std::unique_ptr<Document> &D)\n      : Node(NK_KeyValue, D, StringRef(), StringRef()) {}\n\n  /// Parse and return the key.\n  ///\n  /// This may be called multiple times.\n  ///\n  /// \\returns The key, or nullptr if failed() == true.\n  Node *getKey();\n\n  /// Parse and return the value.\n  ///\n  /// This may be called multiple times.\n  ///\n  /// \\returns The value, or nullptr if failed() == true.\n  Node *getValue();\n\n  void skip() override {\n    if (Node *Key = getKey()) {\n      Key->skip();\n      if (Node *Val = getValue())\n        Val->skip();\n    }\n  }\n\n  static bool classof(const Node *N) {\n    return N->getType() == NK_KeyValue;\n  }\n\nprivate:\n  Node *Key = nullptr;\n  Node *Value = nullptr;\n};\n\n/// This is an iterator abstraction over YAML collections shared by both\n///        sequences and maps.\n///\n/// BaseT must have a ValueT* member named CurrentEntry and a member function\n/// increment() which must set CurrentEntry to 0 to create an end iterator.\ntemplate <class BaseT, class ValueT>\nclass basic_collection_iterator\n    : public std::iterator<std::input_iterator_tag, ValueT> {\npublic:\n  basic_collection_iterator() = default;\n  basic_collection_iterator(BaseT *B) : Base(B) {}\n\n  ValueT *operator->() const {\n    assert(Base && Base->CurrentEntry && \"Attempted to access end iterator!\");\n    return Base->CurrentEntry;\n  }\n\n  ValueT &operator*() const {\n    assert(Base && Base->CurrentEntry &&\n           \"Attempted to dereference end iterator!\");\n    return *Base->CurrentEntry;\n  }\n\n  operator ValueT *() const {\n    assert(Base && Base->CurrentEntry && \"Attempted to access end iterator!\");\n    return Base->CurrentEntry;\n  }\n\n  /// Note on EqualityComparable:\n  ///\n  /// The iterator is not re-entrant,\n  /// it is meant to be used for parsing YAML on-demand\n  /// Once iteration started - it can point only to one entry at a time\n  /// hence Base.CurrentEntry and Other.Base.CurrentEntry are equal\n  /// iff Base and Other.Base are equal.\n  bool operator==(const basic_collection_iterator &Other) const {\n    if (Base && (Base == Other.Base)) {\n      assert((Base->CurrentEntry == Other.Base->CurrentEntry)\n             && \"Equal Bases expected to point to equal Entries\");\n    }\n\n    return Base == Other.Base;\n  }\n\n  bool operator!=(const basic_collection_iterator &Other) const {\n    return !(Base == Other.Base);\n  }\n\n  basic_collection_iterator &operator++() {\n    assert(Base && \"Attempted to advance iterator past end!\");\n    Base->increment();\n    // Create an end iterator.\n    if (!Base->CurrentEntry)\n      Base = nullptr;\n    return *this;\n  }\n\nprivate:\n  BaseT *Base = nullptr;\n};\n\n// The following two templates are used for both MappingNode and Sequence Node.\ntemplate <class CollectionType>\ntypename CollectionType::iterator begin(CollectionType &C) {\n  assert(C.IsAtBeginning && \"You may only iterate over a collection once!\");\n  C.IsAtBeginning = false;\n  typename CollectionType::iterator ret(&C);\n  ++ret;\n  return ret;\n}\n\ntemplate <class CollectionType> void skip(CollectionType &C) {\n  // TODO: support skipping from the middle of a parsed collection ;/\n  assert((C.IsAtBeginning || C.IsAtEnd) && \"Cannot skip mid parse!\");\n  if (C.IsAtBeginning)\n    for (typename CollectionType::iterator i = begin(C), e = C.end(); i != e;\n         ++i)\n      i->skip();\n}\n\n/// Represents a YAML map created from either a block map for a flow map.\n///\n/// This parses the YAML stream as increment() is called.\n///\n/// Example:\n///   Name: _main\n///   Scope: Global\nclass MappingNode final : public Node {\n  void anchor() override;\n\npublic:\n  enum MappingType {\n    MT_Block,\n    MT_Flow,\n    MT_Inline ///< An inline mapping node is used for \"[key: value]\".\n  };\n\n  MappingNode(std::unique_ptr<Document> &D, StringRef Anchor, StringRef Tag,\n              MappingType MT)\n      : Node(NK_Mapping, D, Anchor, Tag), Type(MT) {}\n\n  friend class basic_collection_iterator<MappingNode, KeyValueNode>;\n\n  using iterator = basic_collection_iterator<MappingNode, KeyValueNode>;\n\n  template <class T> friend typename T::iterator yaml::begin(T &);\n  template <class T> friend void yaml::skip(T &);\n\n  iterator begin() { return yaml::begin(*this); }\n\n  iterator end() { return iterator(); }\n\n  void skip() override { yaml::skip(*this); }\n\n  static bool classof(const Node *N) {\n    return N->getType() == NK_Mapping;\n  }\n\nprivate:\n  MappingType Type;\n  bool IsAtBeginning = true;\n  bool IsAtEnd = false;\n  KeyValueNode *CurrentEntry = nullptr;\n\n  void increment();\n};\n\n/// Represents a YAML sequence created from either a block sequence for a\n///        flow sequence.\n///\n/// This parses the YAML stream as increment() is called.\n///\n/// Example:\n///   - Hello\n///   - World\nclass SequenceNode final : public Node {\n  void anchor() override;\n\npublic:\n  enum SequenceType {\n    ST_Block,\n    ST_Flow,\n    // Use for:\n    //\n    // key:\n    // - val1\n    // - val2\n    //\n    // As a BlockMappingEntry and BlockEnd are not created in this case.\n    ST_Indentless\n  };\n\n  SequenceNode(std::unique_ptr<Document> &D, StringRef Anchor, StringRef Tag,\n               SequenceType ST)\n      : Node(NK_Sequence, D, Anchor, Tag), SeqType(ST) {}\n\n  friend class basic_collection_iterator<SequenceNode, Node>;\n\n  using iterator = basic_collection_iterator<SequenceNode, Node>;\n\n  template <class T> friend typename T::iterator yaml::begin(T &);\n  template <class T> friend void yaml::skip(T &);\n\n  void increment();\n\n  iterator begin() { return yaml::begin(*this); }\n\n  iterator end() { return iterator(); }\n\n  void skip() override { yaml::skip(*this); }\n\n  static bool classof(const Node *N) {\n    return N->getType() == NK_Sequence;\n  }\n\nprivate:\n  SequenceType SeqType;\n  bool IsAtBeginning = true;\n  bool IsAtEnd = false;\n  bool WasPreviousTokenFlowEntry = true; // Start with an imaginary ','.\n  Node *CurrentEntry = nullptr;\n};\n\n/// Represents an alias to a Node with an anchor.\n///\n/// Example:\n///   *AnchorName\nclass AliasNode final : public Node {\n  void anchor() override;\n\npublic:\n  AliasNode(std::unique_ptr<Document> &D, StringRef Val)\n      : Node(NK_Alias, D, StringRef(), StringRef()), Name(Val) {}\n\n  StringRef getName() const { return Name; }\n\n  static bool classof(const Node *N) { return N->getType() == NK_Alias; }\n\nprivate:\n  StringRef Name;\n};\n\n/// A YAML Stream is a sequence of Documents. A document contains a root\n///        node.\nclass Document {\npublic:\n  Document(Stream &ParentStream);\n\n  /// Root for parsing a node. Returns a single node.\n  Node *parseBlockNode();\n\n  /// Finish parsing the current document and return true if there are\n  ///        more. Return false otherwise.\n  bool skip();\n\n  /// Parse and return the root level node.\n  Node *getRoot() {\n    if (Root)\n      return Root;\n    return Root = parseBlockNode();\n  }\n\n  const std::map<StringRef, StringRef> &getTagMap() const { return TagMap; }\n\nprivate:\n  friend class Node;\n  friend class document_iterator;\n\n  /// Stream to read tokens from.\n  Stream &stream;\n\n  /// Used to allocate nodes to. All are destroyed without calling their\n  ///        destructor when the document is destroyed.\n  BumpPtrAllocator NodeAllocator;\n\n  /// The root node. Used to support skipping a partially parsed\n  ///        document.\n  Node *Root;\n\n  /// Maps tag prefixes to their expansion.\n  std::map<StringRef, StringRef> TagMap;\n\n  Token &peekNext();\n  Token getNext();\n  void setError(const Twine &Message, Token &Location) const;\n  bool failed() const;\n\n  /// Parse %BLAH directives and return true if any were encountered.\n  bool parseDirectives();\n\n  /// Parse %YAML\n  void parseYAMLDirective();\n\n  /// Parse %TAG\n  void parseTAGDirective();\n\n  /// Consume the next token and error if it is not \\a TK.\n  bool expectToken(int TK);\n};\n\n/// Iterator abstraction for Documents over a Stream.\nclass document_iterator {\npublic:\n  document_iterator() = default;\n  document_iterator(std::unique_ptr<Document> &D) : Doc(&D) {}\n\n  bool operator==(const document_iterator &Other) const {\n    if (isAtEnd() || Other.isAtEnd())\n      return isAtEnd() && Other.isAtEnd();\n\n    return Doc == Other.Doc;\n  }\n  bool operator!=(const document_iterator &Other) const {\n    return !(*this == Other);\n  }\n\n  document_iterator operator++() {\n    assert(Doc && \"incrementing iterator past the end.\");\n    if (!(*Doc)->skip()) {\n      Doc->reset(nullptr);\n    } else {\n      Stream &S = (*Doc)->stream;\n      Doc->reset(new Document(S));\n    }\n    return *this;\n  }\n\n  Document &operator*() { return *Doc->get(); }\n\n  std::unique_ptr<Document> &operator->() { return *Doc; }\n\nprivate:\n  bool isAtEnd() const { return !Doc || !*Doc; }\n\n  std::unique_ptr<Document> *Doc = nullptr;\n};\n\n} // end namespace yaml\n\n} // end namespace llvm\n\n#endif // LLVM_SUPPORT_YAMLPARSER_H\n"}, "89": {"id": 89, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/YAMLTraits.h", "content": "//===- llvm/Support/YAMLTraits.h --------------------------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_SUPPORT_YAMLTRAITS_H\n#define LLVM_SUPPORT_YAMLTRAITS_H\n\n#include \"llvm/ADT/Optional.h\"\n#include \"llvm/ADT/SmallVector.h\"\n#include \"llvm/ADT/StringExtras.h\"\n#include \"llvm/ADT/StringMap.h\"\n#include \"llvm/ADT/StringRef.h\"\n#include \"llvm/ADT/Twine.h\"\n#include \"llvm/Support/AlignOf.h\"\n#include \"llvm/Support/Allocator.h\"\n#include \"llvm/Support/Endian.h\"\n#include \"llvm/Support/Regex.h\"\n#include \"llvm/Support/SMLoc.h\"\n#include \"llvm/Support/SourceMgr.h\"\n#include \"llvm/Support/VersionTuple.h\"\n#include \"llvm/Support/YAMLParser.h\"\n#include \"llvm/Support/raw_ostream.h\"\n#include <cassert>\n#include <cctype>\n#include <cstddef>\n#include <cstdint>\n#include <iterator>\n#include <map>\n#include <memory>\n#include <new>\n#include <string>\n#include <system_error>\n#include <type_traits>\n#include <vector>\n\nnamespace llvm {\nnamespace yaml {\n\nenum class NodeKind : uint8_t {\n  Scalar,\n  Map,\n  Sequence,\n};\n\nstruct EmptyContext {};\n\n/// This class should be specialized by any type that needs to be converted\n/// to/from a YAML mapping.  For example:\n///\n///     struct MappingTraits<MyStruct> {\n///       static void mapping(IO &io, MyStruct &s) {\n///         io.mapRequired(\"name\", s.name);\n///         io.mapRequired(\"size\", s.size);\n///         io.mapOptional(\"age\",  s.age);\n///       }\n///     };\ntemplate<class T>\nstruct MappingTraits {\n  // Must provide:\n  // static void mapping(IO &io, T &fields);\n  // Optionally may provide:\n  // static std::string validate(IO &io, T &fields);\n  //\n  // The optional flow flag will cause generated YAML to use a flow mapping\n  // (e.g. { a: 0, b: 1 }):\n  // static const bool flow = true;\n};\n\n/// This class is similar to MappingTraits<T> but allows you to pass in\n/// additional context for each map operation.  For example:\n///\n///     struct MappingContextTraits<MyStruct, MyContext> {\n///       static void mapping(IO &io, MyStruct &s, MyContext &c) {\n///         io.mapRequired(\"name\", s.name);\n///         io.mapRequired(\"size\", s.size);\n///         io.mapOptional(\"age\",  s.age);\n///         ++c.TimesMapped;\n///       }\n///     };\ntemplate <class T, class Context> struct MappingContextTraits {\n  // Must provide:\n  // static void mapping(IO &io, T &fields, Context &Ctx);\n  // Optionally may provide:\n  // static std::string validate(IO &io, T &fields, Context &Ctx);\n  //\n  // The optional flow flag will cause generated YAML to use a flow mapping\n  // (e.g. { a: 0, b: 1 }):\n  // static const bool flow = true;\n};\n\n/// This class should be specialized by any integral type that converts\n/// to/from a YAML scalar where there is a one-to-one mapping between\n/// in-memory values and a string in YAML.  For example:\n///\n///     struct ScalarEnumerationTraits<Colors> {\n///         static void enumeration(IO &io, Colors &value) {\n///           io.enumCase(value, \"red\",   cRed);\n///           io.enumCase(value, \"blue\",  cBlue);\n///           io.enumCase(value, \"green\", cGreen);\n///         }\n///       };\ntemplate <typename T, typename Enable = void> struct ScalarEnumerationTraits {\n  // Must provide:\n  // static void enumeration(IO &io, T &value);\n};\n\n/// This class should be specialized by any integer type that is a union\n/// of bit values and the YAML representation is a flow sequence of\n/// strings.  For example:\n///\n///      struct ScalarBitSetTraits<MyFlags> {\n///        static void bitset(IO &io, MyFlags &value) {\n///          io.bitSetCase(value, \"big\",   flagBig);\n///          io.bitSetCase(value, \"flat\",  flagFlat);\n///          io.bitSetCase(value, \"round\", flagRound);\n///        }\n///      };\ntemplate <typename T, typename Enable = void> struct ScalarBitSetTraits {\n  // Must provide:\n  // static void bitset(IO &io, T &value);\n};\n\n/// Describe which type of quotes should be used when quoting is necessary.\n/// Some non-printable characters need to be double-quoted, while some others\n/// are fine with simple-quoting, and some don't need any quoting.\nenum class QuotingType { None, Single, Double };\n\n/// This class should be specialized by type that requires custom conversion\n/// to/from a yaml scalar.  For example:\n///\n///    template<>\n///    struct ScalarTraits<MyType> {\n///      static void output(const MyType &val, void*, llvm::raw_ostream &out) {\n///        // stream out custom formatting\n///        out << llvm::format(\"%x\", val);\n///      }\n///      static StringRef input(StringRef scalar, void*, MyType &value) {\n///        // parse scalar and set `value`\n///        // return empty string on success, or error string\n///        return StringRef();\n///      }\n///      static QuotingType mustQuote(StringRef) { return QuotingType::Single; }\n///    };\ntemplate <typename T, typename Enable = void> struct ScalarTraits {\n  // Must provide:\n  //\n  // Function to write the value as a string:\n  // static void output(const T &value, void *ctxt, llvm::raw_ostream &out);\n  //\n  // Function to convert a string to a value.  Returns the empty\n  // StringRef on success or an error string if string is malformed:\n  // static StringRef input(StringRef scalar, void *ctxt, T &value);\n  //\n  // Function to determine if the value should be quoted.\n  // static QuotingType mustQuote(StringRef);\n};\n\n/// This class should be specialized by type that requires custom conversion\n/// to/from a YAML literal block scalar. For example:\n///\n///    template <>\n///    struct BlockScalarTraits<MyType> {\n///      static void output(const MyType &Value, void*, llvm::raw_ostream &Out)\n///      {\n///        // stream out custom formatting\n///        Out << Value;\n///      }\n///      static StringRef input(StringRef Scalar, void*, MyType &Value) {\n///        // parse scalar and set `value`\n///        // return empty string on success, or error string\n///        return StringRef();\n///      }\n///    };\ntemplate <typename T>\nstruct BlockScalarTraits {\n  // Must provide:\n  //\n  // Function to write the value as a string:\n  // static void output(const T &Value, void *ctx, llvm::raw_ostream &Out);\n  //\n  // Function to convert a string to a value.  Returns the empty\n  // StringRef on success or an error string if string is malformed:\n  // static StringRef input(StringRef Scalar, void *ctxt, T &Value);\n  //\n  // Optional:\n  // static StringRef inputTag(T &Val, std::string Tag)\n  // static void outputTag(const T &Val, raw_ostream &Out)\n};\n\n/// This class should be specialized by type that requires custom conversion\n/// to/from a YAML scalar with optional tags. For example:\n///\n///    template <>\n///    struct TaggedScalarTraits<MyType> {\n///      static void output(const MyType &Value, void*, llvm::raw_ostream\n///      &ScalarOut, llvm::raw_ostream &TagOut)\n///      {\n///        // stream out custom formatting including optional Tag\n///        Out << Value;\n///      }\n///      static StringRef input(StringRef Scalar, StringRef Tag, void*, MyType\n///      &Value) {\n///        // parse scalar and set `value`\n///        // return empty string on success, or error string\n///        return StringRef();\n///      }\n///      static QuotingType mustQuote(const MyType &Value, StringRef) {\n///        return QuotingType::Single;\n///      }\n///    };\ntemplate <typename T> struct TaggedScalarTraits {\n  // Must provide:\n  //\n  // Function to write the value and tag as strings:\n  // static void output(const T &Value, void *ctx, llvm::raw_ostream &ScalarOut,\n  // llvm::raw_ostream &TagOut);\n  //\n  // Function to convert a string to a value.  Returns the empty\n  // StringRef on success or an error string if string is malformed:\n  // static StringRef input(StringRef Scalar, StringRef Tag, void *ctxt, T\n  // &Value);\n  //\n  // Function to determine if the value should be quoted.\n  // static QuotingType mustQuote(const T &Value, StringRef Scalar);\n};\n\n/// This class should be specialized by any type that needs to be converted\n/// to/from a YAML sequence.  For example:\n///\n///    template<>\n///    struct SequenceTraits<MyContainer> {\n///      static size_t size(IO &io, MyContainer &seq) {\n///        return seq.size();\n///      }\n///      static MyType& element(IO &, MyContainer &seq, size_t index) {\n///        if ( index >= seq.size() )\n///          seq.resize(index+1);\n///        return seq[index];\n///      }\n///    };\ntemplate<typename T, typename EnableIf = void>\nstruct SequenceTraits {\n  // Must provide:\n  // static size_t size(IO &io, T &seq);\n  // static T::value_type& element(IO &io, T &seq, size_t index);\n  //\n  // The following is option and will cause generated YAML to use\n  // a flow sequence (e.g. [a,b,c]).\n  // static const bool flow = true;\n};\n\n/// This class should be specialized by any type for which vectors of that\n/// type need to be converted to/from a YAML sequence.\ntemplate<typename T, typename EnableIf = void>\nstruct SequenceElementTraits {\n  // Must provide:\n  // static const bool flow;\n};\n\n/// This class should be specialized by any type that needs to be converted\n/// to/from a list of YAML documents.\ntemplate<typename T>\nstruct DocumentListTraits {\n  // Must provide:\n  // static size_t size(IO &io, T &seq);\n  // static T::value_type& element(IO &io, T &seq, size_t index);\n};\n\n/// This class should be specialized by any type that needs to be converted\n/// to/from a YAML mapping in the case where the names of the keys are not known\n/// in advance, e.g. a string map.\ntemplate <typename T>\nstruct CustomMappingTraits {\n  // static void inputOne(IO &io, StringRef key, T &elem);\n  // static void output(IO &io, T &elem);\n};\n\n/// This class should be specialized by any type that can be represented as\n/// a scalar, map, or sequence, decided dynamically. For example:\n///\n///    typedef std::unique_ptr<MyBase> MyPoly;\n///\n///    template<>\n///    struct PolymorphicTraits<MyPoly> {\n///      static NodeKind getKind(const MyPoly &poly) {\n///        return poly->getKind();\n///      }\n///      static MyScalar& getAsScalar(MyPoly &poly) {\n///        if (!poly || !isa<MyScalar>(poly))\n///          poly.reset(new MyScalar());\n///        return *cast<MyScalar>(poly.get());\n///      }\n///      // ...\n///    };\ntemplate <typename T> struct PolymorphicTraits {\n  // Must provide:\n  // static NodeKind getKind(const T &poly);\n  // static scalar_type &getAsScalar(T &poly);\n  // static map_type &getAsMap(T &poly);\n  // static sequence_type &getAsSequence(T &poly);\n};\n\n// Only used for better diagnostics of missing traits\ntemplate <typename T>\nstruct MissingTrait;\n\n// Test if ScalarEnumerationTraits<T> is defined on type T.\ntemplate <class T>\nstruct has_ScalarEnumerationTraits\n{\n  using Signature_enumeration = void (*)(class IO&, T&);\n\n  template <typename U>\n  static char test(SameType<Signature_enumeration, &U::enumeration>*);\n\n  template <typename U>\n  static double test(...);\n\n  static bool const value =\n    (sizeof(test<ScalarEnumerationTraits<T>>(nullptr)) == 1);\n};\n\n// Test if ScalarBitSetTraits<T> is defined on type T.\ntemplate <class T>\nstruct has_ScalarBitSetTraits\n{\n  using Signature_bitset = void (*)(class IO&, T&);\n\n  template <typename U>\n  static char test(SameType<Signature_bitset, &U::bitset>*);\n\n  template <typename U>\n  static double test(...);\n\n  static bool const value = (sizeof(test<ScalarBitSetTraits<T>>(nullptr)) == 1);\n};\n\n// Test if ScalarTraits<T> is defined on type T.\ntemplate <class T>\nstruct has_ScalarTraits\n{\n  using Signature_input = StringRef (*)(StringRef, void*, T&);\n  using Signature_output = void (*)(const T&, void*, raw_ostream&);\n  using Signature_mustQuote = QuotingType (*)(StringRef);\n\n  template <typename U>\n  static char test(SameType<Signature_input, &U::input> *,\n                   SameType<Signature_output, &U::output> *,\n                   SameType<Signature_mustQuote, &U::mustQuote> *);\n\n  template <typename U>\n  static double test(...);\n\n  static bool const value =\n      (sizeof(test<ScalarTraits<T>>(nullptr, nullptr, nullptr)) == 1);\n};\n\n// Test if BlockScalarTraits<T> is defined on type T.\ntemplate <class T>\nstruct has_BlockScalarTraits\n{\n  using Signature_input = StringRef (*)(StringRef, void *, T &);\n  using Signature_output = void (*)(const T &, void *, raw_ostream &);\n\n  template <typename U>\n  static char test(SameType<Signature_input, &U::input> *,\n                   SameType<Signature_output, &U::output> *);\n\n  template <typename U>\n  static double test(...);\n\n  static bool const value =\n      (sizeof(test<BlockScalarTraits<T>>(nullptr, nullptr)) == 1);\n};\n\n// Test if TaggedScalarTraits<T> is defined on type T.\ntemplate <class T> struct has_TaggedScalarTraits {\n  using Signature_input = StringRef (*)(StringRef, StringRef, void *, T &);\n  using Signature_output = void (*)(const T &, void *, raw_ostream &,\n                                    raw_ostream &);\n  using Signature_mustQuote = QuotingType (*)(const T &, StringRef);\n\n  template <typename U>\n  static char test(SameType<Signature_input, &U::input> *,\n                   SameType<Signature_output, &U::output> *,\n                   SameType<Signature_mustQuote, &U::mustQuote> *);\n\n  template <typename U> static double test(...);\n\n  static bool const value =\n      (sizeof(test<TaggedScalarTraits<T>>(nullptr, nullptr, nullptr)) == 1);\n};\n\n// Test if MappingContextTraits<T> is defined on type T.\ntemplate <class T, class Context> struct has_MappingTraits {\n  using Signature_mapping = void (*)(class IO &, T &, Context &);\n\n  template <typename U>\n  static char test(SameType<Signature_mapping, &U::mapping>*);\n\n  template <typename U>\n  static double test(...);\n\n  static bool const value =\n      (sizeof(test<MappingContextTraits<T, Context>>(nullptr)) == 1);\n};\n\n// Test if MappingTraits<T> is defined on type T.\ntemplate <class T> struct has_MappingTraits<T, EmptyContext> {\n  using Signature_mapping = void (*)(class IO &, T &);\n\n  template <typename U>\n  static char test(SameType<Signature_mapping, &U::mapping> *);\n\n  template <typename U> static double test(...);\n\n  static bool const value = (sizeof(test<MappingTraits<T>>(nullptr)) == 1);\n};\n\n// Test if MappingContextTraits<T>::validate() is defined on type T.\ntemplate <class T, class Context> struct has_MappingValidateTraits {\n  using Signature_validate = std::string (*)(class IO &, T &, Context &);\n\n  template <typename U>\n  static char test(SameType<Signature_validate, &U::validate>*);\n\n  template <typename U>\n  static double test(...);\n\n  static bool const value =\n      (sizeof(test<MappingContextTraits<T, Context>>(nullptr)) == 1);\n};\n\n// Test if MappingTraits<T>::validate() is defined on type T.\ntemplate <class T> struct has_MappingValidateTraits<T, EmptyContext> {\n  using Signature_validate = std::string (*)(class IO &, T &);\n\n  template <typename U>\n  static char test(SameType<Signature_validate, &U::validate> *);\n\n  template <typename U> static double test(...);\n\n  static bool const value = (sizeof(test<MappingTraits<T>>(nullptr)) == 1);\n};\n\n// Test if SequenceTraits<T> is defined on type T.\ntemplate <class T>\nstruct has_SequenceMethodTraits\n{\n  using Signature_size = size_t (*)(class IO&, T&);\n\n  template <typename U>\n  static char test(SameType<Signature_size, &U::size>*);\n\n  template <typename U>\n  static double test(...);\n\n  static bool const value =  (sizeof(test<SequenceTraits<T>>(nullptr)) == 1);\n};\n\n// Test if CustomMappingTraits<T> is defined on type T.\ntemplate <class T>\nstruct has_CustomMappingTraits\n{\n  using Signature_input = void (*)(IO &io, StringRef key, T &v);\n\n  template <typename U>\n  static char test(SameType<Signature_input, &U::inputOne>*);\n\n  template <typename U>\n  static double test(...);\n\n  static bool const value =\n      (sizeof(test<CustomMappingTraits<T>>(nullptr)) == 1);\n};\n\n// has_FlowTraits<int> will cause an error with some compilers because\n// it subclasses int.  Using this wrapper only instantiates the\n// real has_FlowTraits only if the template type is a class.\ntemplate <typename T, bool Enabled = std::is_class<T>::value>\nclass has_FlowTraits\n{\npublic:\n   static const bool value = false;\n};\n\n// Some older gcc compilers don't support straight forward tests\n// for members, so test for ambiguity cause by the base and derived\n// classes both defining the member.\ntemplate <class T>\nstruct has_FlowTraits<T, true>\n{\n  struct Fallback { bool flow; };\n  struct Derived : T, Fallback { };\n\n  template<typename C>\n  static char (&f(SameType<bool Fallback::*, &C::flow>*))[1];\n\n  template<typename C>\n  static char (&f(...))[2];\n\n  static bool const value = sizeof(f<Derived>(nullptr)) == 2;\n};\n\n// Test if SequenceTraits<T> is defined on type T\ntemplate<typename T>\nstruct has_SequenceTraits : public std::integral_constant<bool,\n                                      has_SequenceMethodTraits<T>::value > { };\n\n// Test if DocumentListTraits<T> is defined on type T\ntemplate <class T>\nstruct has_DocumentListTraits\n{\n  using Signature_size = size_t (*)(class IO &, T &);\n\n  template <typename U>\n  static char test(SameType<Signature_size, &U::size>*);\n\n  template <typename U>\n  static double test(...);\n\n  static bool const value = (sizeof(test<DocumentListTraits<T>>(nullptr))==1);\n};\n\ntemplate <class T> struct has_PolymorphicTraits {\n  using Signature_getKind = NodeKind (*)(const T &);\n\n  template <typename U>\n  static char test(SameType<Signature_getKind, &U::getKind> *);\n\n  template <typename U> static double test(...);\n\n  static bool const value = (sizeof(test<PolymorphicTraits<T>>(nullptr)) == 1);\n};\n\ninline bool isNumeric(StringRef S) {\n  const static auto skipDigits = [](StringRef Input) {\n    return Input.drop_front(\n        std::min(Input.find_first_not_of(\"0123456789\"), Input.size()));\n  };\n\n  // Make S.front() and S.drop_front().front() (if S.front() is [+-]) calls\n  // safe.\n  if (S.empty() || S.equals(\"+\") || S.equals(\"-\"))\n    return false;\n\n  if (S.equals(\".nan\") || S.equals(\".NaN\") || S.equals(\".NAN\"))\n    return true;\n\n  // Infinity and decimal numbers can be prefixed with sign.\n  StringRef Tail = (S.front() == '-' || S.front() == '+') ? S.drop_front() : S;\n\n  // Check for infinity first, because checking for hex and oct numbers is more\n  // expensive.\n  if (Tail.equals(\".inf\") || Tail.equals(\".Inf\") || Tail.equals(\".INF\"))\n    return true;\n\n  // Section 10.3.2 Tag Resolution\n  // YAML 1.2 Specification prohibits Base 8 and Base 16 numbers prefixed with\n  // [-+], so S should be used instead of Tail.\n  if (S.startswith(\"0o\"))\n    return S.size() > 2 &&\n           S.drop_front(2).find_first_not_of(\"01234567\") == StringRef::npos;\n\n  if (S.startswith(\"0x\"))\n    return S.size() > 2 && S.drop_front(2).find_first_not_of(\n                               \"0123456789abcdefABCDEF\") == StringRef::npos;\n\n  // Parse float: [-+]? (\\. [0-9]+ | [0-9]+ (\\. [0-9]* )?) ([eE] [-+]? [0-9]+)?\n  S = Tail;\n\n  // Handle cases when the number starts with '.' and hence needs at least one\n  // digit after dot (as opposed by number which has digits before the dot), but\n  // doesn't have one.\n  if (S.startswith(\".\") &&\n      (S.equals(\".\") ||\n       (S.size() > 1 && std::strchr(\"0123456789\", S[1]) == nullptr)))\n    return false;\n\n  if (S.startswith(\"E\") || S.startswith(\"e\"))\n    return false;\n\n  enum ParseState {\n    Default,\n    FoundDot,\n    FoundExponent,\n  };\n  ParseState State = Default;\n\n  S = skipDigits(S);\n\n  // Accept decimal integer.\n  if (S.empty())\n    return true;\n\n  if (S.front() == '.') {\n    State = FoundDot;\n    S = S.drop_front();\n  } else if (S.front() == 'e' || S.front() == 'E') {\n    State = FoundExponent;\n    S = S.drop_front();\n  } else {\n    return false;\n  }\n\n  if (State == FoundDot) {\n    S = skipDigits(S);\n    if (S.empty())\n      return true;\n\n    if (S.front() == 'e' || S.front() == 'E') {\n      State = FoundExponent;\n      S = S.drop_front();\n    } else {\n      return false;\n    }\n  }\n\n  assert(State == FoundExponent && \"Should have found exponent at this point.\");\n  if (S.empty())\n    return false;\n\n  if (S.front() == '+' || S.front() == '-') {\n    S = S.drop_front();\n    if (S.empty())\n      return false;\n  }\n\n  return skipDigits(S).empty();\n}\n\ninline bool isNull(StringRef S) {\n  return S.equals(\"null\") || S.equals(\"Null\") || S.equals(\"NULL\") ||\n         S.equals(\"~\");\n}\n\ninline bool isBool(StringRef S) {\n  // FIXME: using parseBool is causing multiple tests to fail.\n  return S.equals(\"true\") || S.equals(\"True\") || S.equals(\"TRUE\") ||\n         S.equals(\"false\") || S.equals(\"False\") || S.equals(\"FALSE\");\n}\n\n// 5.1. Character Set\n// The allowed character range explicitly excludes the C0 control block #x0-#x1F\n// (except for TAB #x9, LF #xA, and CR #xD which are allowed), DEL #x7F, the C1\n// control block #x80-#x9F (except for NEL #x85 which is allowed), the surrogate\n// block #xD800-#xDFFF, #xFFFE, and #xFFFF.\ninline QuotingType needsQuotes(StringRef S) {\n  if (S.empty())\n    return QuotingType::Single;\n\n  QuotingType MaxQuotingNeeded = QuotingType::None;\n  if (isSpace(static_cast<unsigned char>(S.front())) ||\n      isSpace(static_cast<unsigned char>(S.back())))\n    MaxQuotingNeeded = QuotingType::Single;\n  if (isNull(S))\n    MaxQuotingNeeded = QuotingType::Single;\n  if (isBool(S))\n    MaxQuotingNeeded = QuotingType::Single;\n  if (isNumeric(S))\n    MaxQuotingNeeded = QuotingType::Single;\n\n  // 7.3.3 Plain Style\n  // Plain scalars must not begin with most indicators, as this would cause\n  // ambiguity with other YAML constructs.\n  static constexpr char Indicators[] = R\"(-?:\\,[]{}#&*!|>'\"%@`)\";\n  if (S.find_first_of(Indicators) == 0)\n    MaxQuotingNeeded = QuotingType::Single;\n\n  for (unsigned char C : S) {\n    // Alphanum is safe.\n    if (isAlnum(C))\n      continue;\n\n    switch (C) {\n    // Safe scalar characters.\n    case '_':\n    case '-':\n    case '^':\n    case '.':\n    case ',':\n    case ' ':\n    // TAB (0x9) is allowed in unquoted strings.\n    case 0x9:\n      continue;\n    // LF(0xA) and CR(0xD) may delimit values and so require at least single\n    // quotes. LLVM YAML parser cannot handle single quoted multiline so use\n    // double quoting to produce valid YAML.\n    case 0xA:\n    case 0xD:\n      return QuotingType::Double;\n    // DEL (0x7F) are excluded from the allowed character range.\n    case 0x7F:\n      return QuotingType::Double;\n    // Forward slash is allowed to be unquoted, but we quote it anyway.  We have\n    // many tests that use FileCheck against YAML output, and this output often\n    // contains paths.  If we quote backslashes but not forward slashes then\n    // paths will come out either quoted or unquoted depending on which platform\n    // the test is run on, making FileCheck comparisons difficult.\n    case '/':\n    default: {\n      // C0 control block (0x0 - 0x1F) is excluded from the allowed character\n      // range.\n      if (C <= 0x1F)\n        return QuotingType::Double;\n\n      // Always double quote UTF-8.\n      if ((C & 0x80) != 0)\n        return QuotingType::Double;\n\n      // The character is not safe, at least simple quoting needed.\n      MaxQuotingNeeded = QuotingType::Single;\n    }\n    }\n  }\n\n  return MaxQuotingNeeded;\n}\n\ntemplate <typename T, typename Context>\nstruct missingTraits\n    : public std::integral_constant<bool,\n                                    !has_ScalarEnumerationTraits<T>::value &&\n                                        !has_ScalarBitSetTraits<T>::value &&\n                                        !has_ScalarTraits<T>::value &&\n                                        !has_BlockScalarTraits<T>::value &&\n                                        !has_TaggedScalarTraits<T>::value &&\n                                        !has_MappingTraits<T, Context>::value &&\n                                        !has_SequenceTraits<T>::value &&\n                                        !has_CustomMappingTraits<T>::value &&\n                                        !has_DocumentListTraits<T>::value &&\n                                        !has_PolymorphicTraits<T>::value> {};\n\ntemplate <typename T, typename Context>\nstruct validatedMappingTraits\n    : public std::integral_constant<\n          bool, has_MappingTraits<T, Context>::value &&\n                    has_MappingValidateTraits<T, Context>::value> {};\n\ntemplate <typename T, typename Context>\nstruct unvalidatedMappingTraits\n    : public std::integral_constant<\n          bool, has_MappingTraits<T, Context>::value &&\n                    !has_MappingValidateTraits<T, Context>::value> {};\n\n// Base class for Input and Output.\nclass IO {\npublic:\n  IO(void *Ctxt = nullptr);\n  virtual ~IO();\n\n  virtual bool outputting() const = 0;\n\n  virtual unsigned beginSequence() = 0;\n  virtual bool preflightElement(unsigned, void *&) = 0;\n  virtual void postflightElement(void*) = 0;\n  virtual void endSequence() = 0;\n  virtual bool canElideEmptySequence() = 0;\n\n  virtual unsigned beginFlowSequence() = 0;\n  virtual bool preflightFlowElement(unsigned, void *&) = 0;\n  virtual void postflightFlowElement(void*) = 0;\n  virtual void endFlowSequence() = 0;\n\n  virtual bool mapTag(StringRef Tag, bool Default=false) = 0;\n  virtual void beginMapping() = 0;\n  virtual void endMapping() = 0;\n  virtual bool preflightKey(const char*, bool, bool, bool &, void *&) = 0;\n  virtual void postflightKey(void*) = 0;\n  virtual std::vector<StringRef> keys() = 0;\n\n  virtual void beginFlowMapping() = 0;\n  virtual void endFlowMapping() = 0;\n\n  virtual void beginEnumScalar() = 0;\n  virtual bool matchEnumScalar(const char*, bool) = 0;\n  virtual bool matchEnumFallback() = 0;\n  virtual void endEnumScalar() = 0;\n\n  virtual bool beginBitSetScalar(bool &) = 0;\n  virtual bool bitSetMatch(const char*, bool) = 0;\n  virtual void endBitSetScalar() = 0;\n\n  virtual void scalarString(StringRef &, QuotingType) = 0;\n  virtual void blockScalarString(StringRef &) = 0;\n  virtual void scalarTag(std::string &) = 0;\n\n  virtual NodeKind getNodeKind() = 0;\n\n  virtual void setError(const Twine &) = 0;\n  virtual void setAllowUnknownKeys(bool Allow);\n\n  template <typename T>\n  void enumCase(T &Val, const char* Str, const T ConstVal) {\n    if ( matchEnumScalar(Str, outputting() && Val == ConstVal) ) {\n      Val = ConstVal;\n    }\n  }\n\n  // allow anonymous enum values to be used with LLVM_YAML_STRONG_TYPEDEF\n  template <typename T>\n  void enumCase(T &Val, const char* Str, const uint32_t ConstVal) {\n    if ( matchEnumScalar(Str, outputting() && Val == static_cast<T>(ConstVal)) ) {\n      Val = ConstVal;\n    }\n  }\n\n  template <typename FBT, typename T>\n  void enumFallback(T &Val) {\n    if (matchEnumFallback()) {\n      EmptyContext Context;\n      // FIXME: Force integral conversion to allow strong typedefs to convert.\n      FBT Res = static_cast<typename FBT::BaseType>(Val);\n      yamlize(*this, Res, true, Context);\n      Val = static_cast<T>(static_cast<typename FBT::BaseType>(Res));\n    }\n  }\n\n  template <typename T>\n  void bitSetCase(T &Val, const char* Str, const T ConstVal) {\n    if ( bitSetMatch(Str, outputting() && (Val & ConstVal) == ConstVal) ) {\n      Val = static_cast<T>(Val | ConstVal);\n    }\n  }\n\n  // allow anonymous enum values to be used with LLVM_YAML_STRONG_TYPEDEF\n  template <typename T>\n  void bitSetCase(T &Val, const char* Str, const uint32_t ConstVal) {\n    if ( bitSetMatch(Str, outputting() && (Val & ConstVal) == ConstVal) ) {\n      Val = static_cast<T>(Val | ConstVal);\n    }\n  }\n\n  template <typename T>\n  void maskedBitSetCase(T &Val, const char *Str, T ConstVal, T Mask) {\n    if (bitSetMatch(Str, outputting() && (Val & Mask) == ConstVal))\n      Val = Val | ConstVal;\n  }\n\n  template <typename T>\n  void maskedBitSetCase(T &Val, const char *Str, uint32_t ConstVal,\n                        uint32_t Mask) {\n    if (bitSetMatch(Str, outputting() && (Val & Mask) == ConstVal))\n      Val = Val | ConstVal;\n  }\n\n  void *getContext() const;\n  void setContext(void *);\n\n  template <typename T> void mapRequired(const char *Key, T &Val) {\n    EmptyContext Ctx;\n    this->processKey(Key, Val, true, Ctx);\n  }\n\n  template <typename T, typename Context>\n  void mapRequired(const char *Key, T &Val, Context &Ctx) {\n    this->processKey(Key, Val, true, Ctx);\n  }\n\n  template <typename T> void mapOptional(const char *Key, T &Val) {\n    EmptyContext Ctx;\n    mapOptionalWithContext(Key, Val, Ctx);\n  }\n\n  template <typename T, typename DefaultT>\n  void mapOptional(const char *Key, T &Val, const DefaultT &Default) {\n    EmptyContext Ctx;\n    mapOptionalWithContext(Key, Val, Default, Ctx);\n  }\n\n  template <typename T, typename Context>\n  std::enable_if_t<has_SequenceTraits<T>::value, void>\n  mapOptionalWithContext(const char *Key, T &Val, Context &Ctx) {\n    // omit key/value instead of outputting empty sequence\n    if (this->canElideEmptySequence() && !(Val.begin() != Val.end()))\n      return;\n    this->processKey(Key, Val, false, Ctx);\n  }\n\n  template <typename T, typename Context>\n  void mapOptionalWithContext(const char *Key, Optional<T> &Val, Context &Ctx) {\n    this->processKeyWithDefault(Key, Val, Optional<T>(), /*Required=*/false,\n                                Ctx);\n  }\n\n  template <typename T, typename Context>\n  std::enable_if_t<!has_SequenceTraits<T>::value, void>\n  mapOptionalWithContext(const char *Key, T &Val, Context &Ctx) {\n    this->processKey(Key, Val, false, Ctx);\n  }\n\n  template <typename T, typename Context, typename DefaultT>\n  void mapOptionalWithContext(const char *Key, T &Val, const DefaultT &Default,\n                              Context &Ctx) {\n    static_assert(std::is_convertible<DefaultT, T>::value,\n                  \"Default type must be implicitly convertible to value type!\");\n    this->processKeyWithDefault(Key, Val, static_cast<const T &>(Default),\n                                false, Ctx);\n  }\n\nprivate:\n  template <typename T, typename Context>\n  void processKeyWithDefault(const char *Key, Optional<T> &Val,\n                             const Optional<T> &DefaultValue, bool Required,\n                             Context &Ctx);\n\n  template <typename T, typename Context>\n  void processKeyWithDefault(const char *Key, T &Val, const T &DefaultValue,\n                             bool Required, Context &Ctx) {\n    void *SaveInfo;\n    bool UseDefault;\n    const bool sameAsDefault = outputting() && Val == DefaultValue;\n    if ( this->preflightKey(Key, Required, sameAsDefault, UseDefault,\n                                                                  SaveInfo) ) {\n      yamlize(*this, Val, Required, Ctx);\n      this->postflightKey(SaveInfo);\n    }\n    else {\n      if ( UseDefault )\n        Val = DefaultValue;\n    }\n  }\n\n  template <typename T, typename Context>\n  void processKey(const char *Key, T &Val, bool Required, Context &Ctx) {\n    void *SaveInfo;\n    bool UseDefault;\n    if ( this->preflightKey(Key, Required, false, UseDefault, SaveInfo) ) {\n      yamlize(*this, Val, Required, Ctx);\n      this->postflightKey(SaveInfo);\n    }\n  }\n\nprivate:\n  void *Ctxt;\n};\n\nnamespace detail {\n\ntemplate <typename T, typename Context>\nvoid doMapping(IO &io, T &Val, Context &Ctx) {\n  MappingContextTraits<T, Context>::mapping(io, Val, Ctx);\n}\n\ntemplate <typename T> void doMapping(IO &io, T &Val, EmptyContext &Ctx) {\n  MappingTraits<T>::mapping(io, Val);\n}\n\n} // end namespace detail\n\ntemplate <typename T>\nstd::enable_if_t<has_ScalarEnumerationTraits<T>::value, void>\nyamlize(IO &io, T &Val, bool, EmptyContext &Ctx) {\n  io.beginEnumScalar();\n  ScalarEnumerationTraits<T>::enumeration(io, Val);\n  io.endEnumScalar();\n}\n\ntemplate <typename T>\nstd::enable_if_t<has_ScalarBitSetTraits<T>::value, void>\nyamlize(IO &io, T &Val, bool, EmptyContext &Ctx) {\n  bool DoClear;\n  if ( io.beginBitSetScalar(DoClear) ) {\n    if ( DoClear )\n      Val = T();\n    ScalarBitSetTraits<T>::bitset(io, Val);\n    io.endBitSetScalar();\n  }\n}\n\ntemplate <typename T>\nstd::enable_if_t<has_ScalarTraits<T>::value, void> yamlize(IO &io, T &Val, bool,\n                                                           EmptyContext &Ctx) {\n  if ( io.outputting() ) {\n    std::string Storage;\n    raw_string_ostream Buffer(Storage);\n    ScalarTraits<T>::output(Val, io.getContext(), Buffer);\n    StringRef Str = Buffer.str();\n    io.scalarString(Str, ScalarTraits<T>::mustQuote(Str));\n  }\n  else {\n    StringRef Str;\n    io.scalarString(Str, ScalarTraits<T>::mustQuote(Str));\n    StringRef Result = ScalarTraits<T>::input(Str, io.getContext(), Val);\n    if ( !Result.empty() ) {\n      io.setError(Twine(Result));\n    }\n  }\n}\n\ntemplate <typename T>\nstd::enable_if_t<has_BlockScalarTraits<T>::value, void>\nyamlize(IO &YamlIO, T &Val, bool, EmptyContext &Ctx) {\n  if (YamlIO.outputting()) {\n    std::string Storage;\n    raw_string_ostream Buffer(Storage);\n    BlockScalarTraits<T>::output(Val, YamlIO.getContext(), Buffer);\n    StringRef Str = Buffer.str();\n    YamlIO.blockScalarString(Str);\n  } else {\n    StringRef Str;\n    YamlIO.blockScalarString(Str);\n    StringRef Result =\n        BlockScalarTraits<T>::input(Str, YamlIO.getContext(), Val);\n    if (!Result.empty())\n      YamlIO.setError(Twine(Result));\n  }\n}\n\ntemplate <typename T>\nstd::enable_if_t<has_TaggedScalarTraits<T>::value, void>\nyamlize(IO &io, T &Val, bool, EmptyContext &Ctx) {\n  if (io.outputting()) {\n    std::string ScalarStorage, TagStorage;\n    raw_string_ostream ScalarBuffer(ScalarStorage), TagBuffer(TagStorage);\n    TaggedScalarTraits<T>::output(Val, io.getContext(), ScalarBuffer,\n                                  TagBuffer);\n    io.scalarTag(TagBuffer.str());\n    StringRef ScalarStr = ScalarBuffer.str();\n    io.scalarString(ScalarStr,\n                    TaggedScalarTraits<T>::mustQuote(Val, ScalarStr));\n  } else {\n    std::string Tag;\n    io.scalarTag(Tag);\n    StringRef Str;\n    io.scalarString(Str, QuotingType::None);\n    StringRef Result =\n        TaggedScalarTraits<T>::input(Str, Tag, io.getContext(), Val);\n    if (!Result.empty()) {\n      io.setError(Twine(Result));\n    }\n  }\n}\n\ntemplate <typename T, typename Context>\nstd::enable_if_t<validatedMappingTraits<T, Context>::value, void>\nyamlize(IO &io, T &Val, bool, Context &Ctx) {\n  if (has_FlowTraits<MappingTraits<T>>::value)\n    io.beginFlowMapping();\n  else\n    io.beginMapping();\n  if (io.outputting()) {\n    std::string Err = MappingTraits<T>::validate(io, Val);\n    if (!Err.empty()) {\n      errs() << Err << \"\\n\";\n      assert(Err.empty() && \"invalid struct trying to be written as yaml\");\n    }\n  }\n  detail::doMapping(io, Val, Ctx);\n  if (!io.outputting()) {\n    std::string Err = MappingTraits<T>::validate(io, Val);\n    if (!Err.empty())\n      io.setError(Err);\n  }\n  if (has_FlowTraits<MappingTraits<T>>::value)\n    io.endFlowMapping();\n  else\n    io.endMapping();\n}\n\ntemplate <typename T, typename Context>\nstd::enable_if_t<unvalidatedMappingTraits<T, Context>::value, void>\nyamlize(IO &io, T &Val, bool, Context &Ctx) {\n  if (has_FlowTraits<MappingTraits<T>>::value) {\n    io.beginFlowMapping();\n    detail::doMapping(io, Val, Ctx);\n    io.endFlowMapping();\n  } else {\n    io.beginMapping();\n    detail::doMapping(io, Val, Ctx);\n    io.endMapping();\n  }\n}\n\ntemplate <typename T>\nstd::enable_if_t<has_CustomMappingTraits<T>::value, void>\nyamlize(IO &io, T &Val, bool, EmptyContext &Ctx) {\n  if ( io.outputting() ) {\n    io.beginMapping();\n    CustomMappingTraits<T>::output(io, Val);\n    io.endMapping();\n  } else {\n    io.beginMapping();\n    for (StringRef key : io.keys())\n      CustomMappingTraits<T>::inputOne(io, key, Val);\n    io.endMapping();\n  }\n}\n\ntemplate <typename T>\nstd::enable_if_t<has_PolymorphicTraits<T>::value, void>\nyamlize(IO &io, T &Val, bool, EmptyContext &Ctx) {\n  switch (io.outputting() ? PolymorphicTraits<T>::getKind(Val)\n                          : io.getNodeKind()) {\n  case NodeKind::Scalar:\n    return yamlize(io, PolymorphicTraits<T>::getAsScalar(Val), true, Ctx);\n  case NodeKind::Map:\n    return yamlize(io, PolymorphicTraits<T>::getAsMap(Val), true, Ctx);\n  case NodeKind::Sequence:\n    return yamlize(io, PolymorphicTraits<T>::getAsSequence(Val), true, Ctx);\n  }\n}\n\ntemplate <typename T>\nstd::enable_if_t<missingTraits<T, EmptyContext>::value, void>\nyamlize(IO &io, T &Val, bool, EmptyContext &Ctx) {\n  char missing_yaml_trait_for_type[sizeof(MissingTrait<T>)];\n}\n\ntemplate <typename T, typename Context>\nstd::enable_if_t<has_SequenceTraits<T>::value, void>\nyamlize(IO &io, T &Seq, bool, Context &Ctx) {\n  if ( has_FlowTraits< SequenceTraits<T>>::value ) {\n    unsigned incnt = io.beginFlowSequence();\n    unsigned count = io.outputting() ? SequenceTraits<T>::size(io, Seq) : incnt;\n    for(unsigned i=0; i < count; ++i) {\n      void *SaveInfo;\n      if ( io.preflightFlowElement(i, SaveInfo) ) {\n        yamlize(io, SequenceTraits<T>::element(io, Seq, i), true, Ctx);\n        io.postflightFlowElement(SaveInfo);\n      }\n    }\n    io.endFlowSequence();\n  }\n  else {\n    unsigned incnt = io.beginSequence();\n    unsigned count = io.outputting() ? SequenceTraits<T>::size(io, Seq) : incnt;\n    for(unsigned i=0; i < count; ++i) {\n      void *SaveInfo;\n      if ( io.preflightElement(i, SaveInfo) ) {\n        yamlize(io, SequenceTraits<T>::element(io, Seq, i), true, Ctx);\n        io.postflightElement(SaveInfo);\n      }\n    }\n    io.endSequence();\n  }\n}\n\ntemplate<>\nstruct ScalarTraits<bool> {\n  static void output(const bool &, void* , raw_ostream &);\n  static StringRef input(StringRef, void *, bool &);\n  static QuotingType mustQuote(StringRef) { return QuotingType::None; }\n};\n\ntemplate<>\nstruct ScalarTraits<StringRef> {\n  static void output(const StringRef &, void *, raw_ostream &);\n  static StringRef input(StringRef, void *, StringRef &);\n  static QuotingType mustQuote(StringRef S) { return needsQuotes(S); }\n};\n\ntemplate<>\nstruct ScalarTraits<std::string> {\n  static void output(const std::string &, void *, raw_ostream &);\n  static StringRef input(StringRef, void *, std::string &);\n  static QuotingType mustQuote(StringRef S) { return needsQuotes(S); }\n};\n\ntemplate<>\nstruct ScalarTraits<uint8_t> {\n  static void output(const uint8_t &, void *, raw_ostream &);\n  static StringRef input(StringRef, void *, uint8_t &);\n  static QuotingType mustQuote(StringRef) { return QuotingType::None; }\n};\n\ntemplate<>\nstruct ScalarTraits<uint16_t> {\n  static void output(const uint16_t &, void *, raw_ostream &);\n  static StringRef input(StringRef, void *, uint16_t &);\n  static QuotingType mustQuote(StringRef) { return QuotingType::None; }\n};\n\ntemplate<>\nstruct ScalarTraits<uint32_t> {\n  static void output(const uint32_t &, void *, raw_ostream &);\n  static StringRef input(StringRef, void *, uint32_t &);\n  static QuotingType mustQuote(StringRef) { return QuotingType::None; }\n};\n\ntemplate<>\nstruct ScalarTraits<uint64_t> {\n  static void output(const uint64_t &, void *, raw_ostream &);\n  static StringRef input(StringRef, void *, uint64_t &);\n  static QuotingType mustQuote(StringRef) { return QuotingType::None; }\n};\n\ntemplate<>\nstruct ScalarTraits<int8_t> {\n  static void output(const int8_t &, void *, raw_ostream &);\n  static StringRef input(StringRef, void *, int8_t &);\n  static QuotingType mustQuote(StringRef) { return QuotingType::None; }\n};\n\ntemplate<>\nstruct ScalarTraits<int16_t> {\n  static void output(const int16_t &, void *, raw_ostream &);\n  static StringRef input(StringRef, void *, int16_t &);\n  static QuotingType mustQuote(StringRef) { return QuotingType::None; }\n};\n\ntemplate<>\nstruct ScalarTraits<int32_t> {\n  static void output(const int32_t &, void *, raw_ostream &);\n  static StringRef input(StringRef, void *, int32_t &);\n  static QuotingType mustQuote(StringRef) { return QuotingType::None; }\n};\n\ntemplate<>\nstruct ScalarTraits<int64_t> {\n  static void output(const int64_t &, void *, raw_ostream &);\n  static StringRef input(StringRef, void *, int64_t &);\n  static QuotingType mustQuote(StringRef) { return QuotingType::None; }\n};\n\ntemplate<>\nstruct ScalarTraits<float> {\n  static void output(const float &, void *, raw_ostream &);\n  static StringRef input(StringRef, void *, float &);\n  static QuotingType mustQuote(StringRef) { return QuotingType::None; }\n};\n\ntemplate<>\nstruct ScalarTraits<double> {\n  static void output(const double &, void *, raw_ostream &);\n  static StringRef input(StringRef, void *, double &);\n  static QuotingType mustQuote(StringRef) { return QuotingType::None; }\n};\n\n// For endian types, we use existing scalar Traits class for the underlying\n// type.  This way endian aware types are supported whenever the traits are\n// defined for the underlying type.\ntemplate <typename value_type, support::endianness endian, size_t alignment>\nstruct ScalarTraits<support::detail::packed_endian_specific_integral<\n                        value_type, endian, alignment>,\n                    std::enable_if_t<has_ScalarTraits<value_type>::value>> {\n  using endian_type =\n      support::detail::packed_endian_specific_integral<value_type, endian,\n                                                       alignment>;\n\n  static void output(const endian_type &E, void *Ctx, raw_ostream &Stream) {\n    ScalarTraits<value_type>::output(static_cast<value_type>(E), Ctx, Stream);\n  }\n\n  static StringRef input(StringRef Str, void *Ctx, endian_type &E) {\n    value_type V;\n    auto R = ScalarTraits<value_type>::input(Str, Ctx, V);\n    E = static_cast<endian_type>(V);\n    return R;\n  }\n\n  static QuotingType mustQuote(StringRef Str) {\n    return ScalarTraits<value_type>::mustQuote(Str);\n  }\n};\n\ntemplate <typename value_type, support::endianness endian, size_t alignment>\nstruct ScalarEnumerationTraits<\n    support::detail::packed_endian_specific_integral<value_type, endian,\n                                                     alignment>,\n    std::enable_if_t<has_ScalarEnumerationTraits<value_type>::value>> {\n  using endian_type =\n      support::detail::packed_endian_specific_integral<value_type, endian,\n                                                       alignment>;\n\n  static void enumeration(IO &io, endian_type &E) {\n    value_type V = E;\n    ScalarEnumerationTraits<value_type>::enumeration(io, V);\n    E = V;\n  }\n};\n\ntemplate <typename value_type, support::endianness endian, size_t alignment>\nstruct ScalarBitSetTraits<\n    support::detail::packed_endian_specific_integral<value_type, endian,\n                                                     alignment>,\n    std::enable_if_t<has_ScalarBitSetTraits<value_type>::value>> {\n  using endian_type =\n      support::detail::packed_endian_specific_integral<value_type, endian,\n                                                       alignment>;\n  static void bitset(IO &io, endian_type &E) {\n    value_type V = E;\n    ScalarBitSetTraits<value_type>::bitset(io, V);\n    E = V;\n  }\n};\n\n// Utility for use within MappingTraits<>::mapping() method\n// to [de]normalize an object for use with YAML conversion.\ntemplate <typename TNorm, typename TFinal>\nstruct MappingNormalization {\n  MappingNormalization(IO &i_o, TFinal &Obj)\n      : io(i_o), BufPtr(nullptr), Result(Obj) {\n    if ( io.outputting() ) {\n      BufPtr = new (&Buffer) TNorm(io, Obj);\n    }\n    else {\n      BufPtr = new (&Buffer) TNorm(io);\n    }\n  }\n\n  ~MappingNormalization() {\n    if ( ! io.outputting() ) {\n      Result = BufPtr->denormalize(io);\n    }\n    BufPtr->~TNorm();\n  }\n\n  TNorm* operator->() { return BufPtr; }\n\nprivate:\n  using Storage = AlignedCharArrayUnion<TNorm>;\n\n  Storage       Buffer;\n  IO           &io;\n  TNorm        *BufPtr;\n  TFinal       &Result;\n};\n\n// Utility for use within MappingTraits<>::mapping() method\n// to [de]normalize an object for use with YAML conversion.\ntemplate <typename TNorm, typename TFinal>\nstruct MappingNormalizationHeap {\n  MappingNormalizationHeap(IO &i_o, TFinal &Obj, BumpPtrAllocator *allocator)\n    : io(i_o), Result(Obj) {\n    if ( io.outputting() ) {\n      BufPtr = new (&Buffer) TNorm(io, Obj);\n    }\n    else if (allocator) {\n      BufPtr = allocator->Allocate<TNorm>();\n      new (BufPtr) TNorm(io);\n    } else {\n      BufPtr = new TNorm(io);\n    }\n  }\n\n  ~MappingNormalizationHeap() {\n    if ( io.outputting() ) {\n      BufPtr->~TNorm();\n    }\n    else {\n      Result = BufPtr->denormalize(io);\n    }\n  }\n\n  TNorm* operator->() { return BufPtr; }\n\nprivate:\n  using Storage = AlignedCharArrayUnion<TNorm>;\n\n  Storage       Buffer;\n  IO           &io;\n  TNorm        *BufPtr = nullptr;\n  TFinal       &Result;\n};\n\n///\n/// The Input class is used to parse a yaml document into in-memory structs\n/// and vectors.\n///\n/// It works by using YAMLParser to do a syntax parse of the entire yaml\n/// document, then the Input class builds a graph of HNodes which wraps\n/// each yaml Node.  The extra layer is buffering.  The low level yaml\n/// parser only lets you look at each node once.  The buffering layer lets\n/// you search and interate multiple times.  This is necessary because\n/// the mapRequired() method calls may not be in the same order\n/// as the keys in the document.\n///\nclass Input : public IO {\npublic:\n  // Construct a yaml Input object from a StringRef and optional\n  // user-data. The DiagHandler can be specified to provide\n  // alternative error reporting.\n  Input(StringRef InputContent,\n        void *Ctxt = nullptr,\n        SourceMgr::DiagHandlerTy DiagHandler = nullptr,\n        void *DiagHandlerCtxt = nullptr);\n  Input(MemoryBufferRef Input,\n        void *Ctxt = nullptr,\n        SourceMgr::DiagHandlerTy DiagHandler = nullptr,\n        void *DiagHandlerCtxt = nullptr);\n  ~Input() override;\n\n  // Check if there was an syntax or semantic error during parsing.\n  std::error_code error();\n\nprivate:\n  bool outputting() const override;\n  bool mapTag(StringRef, bool) override;\n  void beginMapping() override;\n  void endMapping() override;\n  bool preflightKey(const char *, bool, bool, bool &, void *&) override;\n  void postflightKey(void *) override;\n  std::vector<StringRef> keys() override;\n  void beginFlowMapping() override;\n  void endFlowMapping() override;\n  unsigned beginSequence() override;\n  void endSequence() override;\n  bool preflightElement(unsigned index, void *&) override;\n  void postflightElement(void *) override;\n  unsigned beginFlowSequence() override;\n  bool preflightFlowElement(unsigned , void *&) override;\n  void postflightFlowElement(void *) override;\n  void endFlowSequence() override;\n  void beginEnumScalar() override;\n  bool matchEnumScalar(const char*, bool) override;\n  bool matchEnumFallback() override;\n  void endEnumScalar() override;\n  bool beginBitSetScalar(bool &) override;\n  bool bitSetMatch(const char *, bool ) override;\n  void endBitSetScalar() override;\n  void scalarString(StringRef &, QuotingType) override;\n  void blockScalarString(StringRef &) override;\n  void scalarTag(std::string &) override;\n  NodeKind getNodeKind() override;\n  void setError(const Twine &message) override;\n  bool canElideEmptySequence() override;\n\n  class HNode {\n    virtual void anchor();\n\n  public:\n    HNode(Node *n) : _node(n) { }\n    virtual ~HNode() = default;\n\n    static bool classof(const HNode *) { return true; }\n\n    Node *_node;\n  };\n\n  class EmptyHNode : public HNode {\n    void anchor() override;\n\n  public:\n    EmptyHNode(Node *n) : HNode(n) { }\n\n    static bool classof(const HNode *n) { return NullNode::classof(n->_node); }\n\n    static bool classof(const EmptyHNode *) { return true; }\n  };\n\n  class ScalarHNode : public HNode {\n    void anchor() override;\n\n  public:\n    ScalarHNode(Node *n, StringRef s) : HNode(n), _value(s) { }\n\n    StringRef value() const { return _value; }\n\n    static bool classof(const HNode *n) {\n      return ScalarNode::classof(n->_node) ||\n             BlockScalarNode::classof(n->_node);\n    }\n\n    static bool classof(const ScalarHNode *) { return true; }\n\n  protected:\n    StringRef _value;\n  };\n\n  class MapHNode : public HNode {\n    void anchor() override;\n\n  public:\n    MapHNode(Node *n) : HNode(n) { }\n\n    static bool classof(const HNode *n) {\n      return MappingNode::classof(n->_node);\n    }\n\n    static bool classof(const MapHNode *) { return true; }\n\n    using NameToNodeAndLoc =\n        StringMap<std::pair<std::unique_ptr<HNode>, SMRange>>;\n\n    NameToNodeAndLoc Mapping;\n    SmallVector<std::string, 6> ValidKeys;\n  };\n\n  class SequenceHNode : public HNode {\n    void anchor() override;\n\n  public:\n    SequenceHNode(Node *n) : HNode(n) { }\n\n    static bool classof(const HNode *n) {\n      return SequenceNode::classof(n->_node);\n    }\n\n    static bool classof(const SequenceHNode *) { return true; }\n\n    std::vector<std::unique_ptr<HNode>> Entries;\n  };\n\n  std::unique_ptr<Input::HNode> createHNodes(Node *node);\n  void setError(HNode *hnode, const Twine &message);\n  void setError(Node *node, const Twine &message);\n  void setError(const SMRange &Range, const Twine &message);\n\n  void reportWarning(HNode *hnode, const Twine &message);\n  void reportWarning(Node *hnode, const Twine &message);\n  void reportWarning(const SMRange &Range, const Twine &message);\n\npublic:\n  // These are only used by operator>>. They could be private\n  // if those templated things could be made friends.\n  bool setCurrentDocument();\n  bool nextDocument();\n\n  /// Returns the current node that's being parsed by the YAML Parser.\n  const Node *getCurrentNode() const;\n\n  void setAllowUnknownKeys(bool Allow) override;\n\nprivate:\n  SourceMgr                           SrcMgr; // must be before Strm\n  std::unique_ptr<llvm::yaml::Stream> Strm;\n  std::unique_ptr<HNode>              TopNode;\n  std::error_code                     EC;\n  BumpPtrAllocator                    StringAllocator;\n  document_iterator                   DocIterator;\n  std::vector<bool>                   BitValuesUsed;\n  HNode *CurrentNode = nullptr;\n  bool                                ScalarMatchFound = false;\n  bool AllowUnknownKeys = false;\n};\n\n///\n/// The Output class is used to generate a yaml document from in-memory structs\n/// and vectors.\n///\nclass Output : public IO {\npublic:\n  Output(raw_ostream &, void *Ctxt = nullptr, int WrapColumn = 70);\n  ~Output() override;\n\n  /// Set whether or not to output optional values which are equal\n  /// to the default value.  By default, when outputting if you attempt\n  /// to write a value that is equal to the default, the value gets ignored.\n  /// Sometimes, it is useful to be able to see these in the resulting YAML\n  /// anyway.\n  void setWriteDefaultValues(bool Write) { WriteDefaultValues = Write; }\n\n  bool outputting() const override;\n  bool mapTag(StringRef, bool) override;\n  void beginMapping() override;\n  void endMapping() override;\n  bool preflightKey(const char *key, bool, bool, bool &, void *&) override;\n  void postflightKey(void *) override;\n  std::vector<StringRef> keys() override;\n  void beginFlowMapping() override;\n  void endFlowMapping() override;\n  unsigned beginSequence() override;\n  void endSequence() override;\n  bool preflightElement(unsigned, void *&) override;\n  void postflightElement(void *) override;\n  unsigned beginFlowSequence() override;\n  bool preflightFlowElement(unsigned, void *&) override;\n  void postflightFlowElement(void *) override;\n  void endFlowSequence() override;\n  void beginEnumScalar() override;\n  bool matchEnumScalar(const char*, bool) override;\n  bool matchEnumFallback() override;\n  void endEnumScalar() override;\n  bool beginBitSetScalar(bool &) override;\n  bool bitSetMatch(const char *, bool ) override;\n  void endBitSetScalar() override;\n  void scalarString(StringRef &, QuotingType) override;\n  void blockScalarString(StringRef &) override;\n  void scalarTag(std::string &) override;\n  NodeKind getNodeKind() override;\n  void setError(const Twine &message) override;\n  bool canElideEmptySequence() override;\n\n  // These are only used by operator<<. They could be private\n  // if that templated operator could be made a friend.\n  void beginDocuments();\n  bool preflightDocument(unsigned);\n  void postflightDocument();\n  void endDocuments();\n\nprivate:\n  void output(StringRef s);\n  void outputUpToEndOfLine(StringRef s);\n  void newLineCheck(bool EmptySequence = false);\n  void outputNewLine();\n  void paddedKey(StringRef key);\n  void flowKey(StringRef Key);\n\n  enum InState {\n    inSeqFirstElement,\n    inSeqOtherElement,\n    inFlowSeqFirstElement,\n    inFlowSeqOtherElement,\n    inMapFirstKey,\n    inMapOtherKey,\n    inFlowMapFirstKey,\n    inFlowMapOtherKey\n  };\n\n  static bool inSeqAnyElement(InState State);\n  static bool inFlowSeqAnyElement(InState State);\n  static bool inMapAnyKey(InState State);\n  static bool inFlowMapAnyKey(InState State);\n\n  raw_ostream &Out;\n  int WrapColumn;\n  SmallVector<InState, 8> StateStack;\n  int Column = 0;\n  int ColumnAtFlowStart = 0;\n  int ColumnAtMapFlowStart = 0;\n  bool NeedBitValueComma = false;\n  bool NeedFlowSequenceComma = false;\n  bool EnumerationMatchFound = false;\n  bool WriteDefaultValues = false;\n  StringRef Padding;\n  StringRef PaddingBeforeContainer;\n};\n\ntemplate <typename T, typename Context>\nvoid IO::processKeyWithDefault(const char *Key, Optional<T> &Val,\n                               const Optional<T> &DefaultValue, bool Required,\n                               Context &Ctx) {\n  assert(DefaultValue.hasValue() == false &&\n         \"Optional<T> shouldn't have a value!\");\n  void *SaveInfo;\n  bool UseDefault = true;\n  const bool sameAsDefault = outputting() && !Val.hasValue();\n  if (!outputting() && !Val.hasValue())\n    Val = T();\n  if (Val.hasValue() &&\n      this->preflightKey(Key, Required, sameAsDefault, UseDefault, SaveInfo)) {\n\n    // When reading an Optional<X> key from a YAML description, we allow the\n    // special \"<none>\" value, which can be used to specify that no value was\n    // requested, i.e. the DefaultValue will be assigned. The DefaultValue is\n    // usually None.\n    bool IsNone = false;\n    if (!outputting())\n      if (auto *Node = dyn_cast<ScalarNode>(((Input *)this)->getCurrentNode()))\n        // We use rtrim to ignore possible white spaces that might exist when a\n        // comment is present on the same line.\n        IsNone = Node->getRawValue().rtrim(' ') == \"<none>\";\n\n    if (IsNone)\n      Val = DefaultValue;\n    else\n      yamlize(*this, Val.getValue(), Required, Ctx);\n    this->postflightKey(SaveInfo);\n  } else {\n    if (UseDefault)\n      Val = DefaultValue;\n  }\n}\n\n/// YAML I/O does conversion based on types. But often native data types\n/// are just a typedef of built in intergral types (e.g. int).  But the C++\n/// type matching system sees through the typedef and all the typedefed types\n/// look like a built in type. This will cause the generic YAML I/O conversion\n/// to be used. To provide better control over the YAML conversion, you can\n/// use this macro instead of typedef.  It will create a class with one field\n/// and automatic conversion operators to and from the base type.\n/// Based on BOOST_STRONG_TYPEDEF\n#define LLVM_YAML_STRONG_TYPEDEF(_base, _type)                                 \\\n    struct _type {                                                             \\\n        _type() = default;                                                     \\\n        _type(const _base v) : value(v) {}                                     \\\n        _type(const _type &v) = default;                                       \\\n        _type &operator=(const _type &rhs) = default;                          \\\n        _type &operator=(const _base &rhs) { value = rhs; return *this; }      \\\n        operator const _base & () const { return value; }                      \\\n        bool operator==(const _type &rhs) const { return value == rhs.value; } \\\n        bool operator==(const _base &rhs) const { return value == rhs; }       \\\n        bool operator<(const _type &rhs) const { return value < rhs.value; }   \\\n        _base value;                                                           \\\n        using BaseType = _base;                                                \\\n    };\n\n///\n/// Use these types instead of uintXX_t in any mapping to have\n/// its yaml output formatted as hexadecimal.\n///\nLLVM_YAML_STRONG_TYPEDEF(uint8_t, Hex8)\nLLVM_YAML_STRONG_TYPEDEF(uint16_t, Hex16)\nLLVM_YAML_STRONG_TYPEDEF(uint32_t, Hex32)\nLLVM_YAML_STRONG_TYPEDEF(uint64_t, Hex64)\n\ntemplate<>\nstruct ScalarTraits<Hex8> {\n  static void output(const Hex8 &, void *, raw_ostream &);\n  static StringRef input(StringRef, void *, Hex8 &);\n  static QuotingType mustQuote(StringRef) { return QuotingType::None; }\n};\n\ntemplate<>\nstruct ScalarTraits<Hex16> {\n  static void output(const Hex16 &, void *, raw_ostream &);\n  static StringRef input(StringRef, void *, Hex16 &);\n  static QuotingType mustQuote(StringRef) { return QuotingType::None; }\n};\n\ntemplate<>\nstruct ScalarTraits<Hex32> {\n  static void output(const Hex32 &, void *, raw_ostream &);\n  static StringRef input(StringRef, void *, Hex32 &);\n  static QuotingType mustQuote(StringRef) { return QuotingType::None; }\n};\n\ntemplate<>\nstruct ScalarTraits<Hex64> {\n  static void output(const Hex64 &, void *, raw_ostream &);\n  static StringRef input(StringRef, void *, Hex64 &);\n  static QuotingType mustQuote(StringRef) { return QuotingType::None; }\n};\n\ntemplate <> struct ScalarTraits<VersionTuple> {\n  static void output(const VersionTuple &Value, void *, llvm::raw_ostream &Out);\n  static StringRef input(StringRef, void *, VersionTuple &);\n  static QuotingType mustQuote(StringRef) { return QuotingType::None; }\n};\n\n// Define non-member operator>> so that Input can stream in a document list.\ntemplate <typename T>\ninline std::enable_if_t<has_DocumentListTraits<T>::value, Input &>\noperator>>(Input &yin, T &docList) {\n  int i = 0;\n  EmptyContext Ctx;\n  while ( yin.setCurrentDocument() ) {\n    yamlize(yin, DocumentListTraits<T>::element(yin, docList, i), true, Ctx);\n    if ( yin.error() )\n      return yin;\n    yin.nextDocument();\n    ++i;\n  }\n  return yin;\n}\n\n// Define non-member operator>> so that Input can stream in a map as a document.\ntemplate <typename T>\ninline std::enable_if_t<has_MappingTraits<T, EmptyContext>::value, Input &>\noperator>>(Input &yin, T &docMap) {\n  EmptyContext Ctx;\n  yin.setCurrentDocument();\n  yamlize(yin, docMap, true, Ctx);\n  return yin;\n}\n\n// Define non-member operator>> so that Input can stream in a sequence as\n// a document.\ntemplate <typename T>\ninline std::enable_if_t<has_SequenceTraits<T>::value, Input &>\noperator>>(Input &yin, T &docSeq) {\n  EmptyContext Ctx;\n  if (yin.setCurrentDocument())\n    yamlize(yin, docSeq, true, Ctx);\n  return yin;\n}\n\n// Define non-member operator>> so that Input can stream in a block scalar.\ntemplate <typename T>\ninline std::enable_if_t<has_BlockScalarTraits<T>::value, Input &>\noperator>>(Input &In, T &Val) {\n  EmptyContext Ctx;\n  if (In.setCurrentDocument())\n    yamlize(In, Val, true, Ctx);\n  return In;\n}\n\n// Define non-member operator>> so that Input can stream in a string map.\ntemplate <typename T>\ninline std::enable_if_t<has_CustomMappingTraits<T>::value, Input &>\noperator>>(Input &In, T &Val) {\n  EmptyContext Ctx;\n  if (In.setCurrentDocument())\n    yamlize(In, Val, true, Ctx);\n  return In;\n}\n\n// Define non-member operator>> so that Input can stream in a polymorphic type.\ntemplate <typename T>\ninline std::enable_if_t<has_PolymorphicTraits<T>::value, Input &>\noperator>>(Input &In, T &Val) {\n  EmptyContext Ctx;\n  if (In.setCurrentDocument())\n    yamlize(In, Val, true, Ctx);\n  return In;\n}\n\n// Provide better error message about types missing a trait specialization\ntemplate <typename T>\ninline std::enable_if_t<missingTraits<T, EmptyContext>::value, Input &>\noperator>>(Input &yin, T &docSeq) {\n  char missing_yaml_trait_for_type[sizeof(MissingTrait<T>)];\n  return yin;\n}\n\n// Define non-member operator<< so that Output can stream out document list.\ntemplate <typename T>\ninline std::enable_if_t<has_DocumentListTraits<T>::value, Output &>\noperator<<(Output &yout, T &docList) {\n  EmptyContext Ctx;\n  yout.beginDocuments();\n  const size_t count = DocumentListTraits<T>::size(yout, docList);\n  for(size_t i=0; i < count; ++i) {\n    if ( yout.preflightDocument(i) ) {\n      yamlize(yout, DocumentListTraits<T>::element(yout, docList, i), true,\n              Ctx);\n      yout.postflightDocument();\n    }\n  }\n  yout.endDocuments();\n  return yout;\n}\n\n// Define non-member operator<< so that Output can stream out a map.\ntemplate <typename T>\ninline std::enable_if_t<has_MappingTraits<T, EmptyContext>::value, Output &>\noperator<<(Output &yout, T &map) {\n  EmptyContext Ctx;\n  yout.beginDocuments();\n  if ( yout.preflightDocument(0) ) {\n    yamlize(yout, map, true, Ctx);\n    yout.postflightDocument();\n  }\n  yout.endDocuments();\n  return yout;\n}\n\n// Define non-member operator<< so that Output can stream out a sequence.\ntemplate <typename T>\ninline std::enable_if_t<has_SequenceTraits<T>::value, Output &>\noperator<<(Output &yout, T &seq) {\n  EmptyContext Ctx;\n  yout.beginDocuments();\n  if ( yout.preflightDocument(0) ) {\n    yamlize(yout, seq, true, Ctx);\n    yout.postflightDocument();\n  }\n  yout.endDocuments();\n  return yout;\n}\n\n// Define non-member operator<< so that Output can stream out a block scalar.\ntemplate <typename T>\ninline std::enable_if_t<has_BlockScalarTraits<T>::value, Output &>\noperator<<(Output &Out, T &Val) {\n  EmptyContext Ctx;\n  Out.beginDocuments();\n  if (Out.preflightDocument(0)) {\n    yamlize(Out, Val, true, Ctx);\n    Out.postflightDocument();\n  }\n  Out.endDocuments();\n  return Out;\n}\n\n// Define non-member operator<< so that Output can stream out a string map.\ntemplate <typename T>\ninline std::enable_if_t<has_CustomMappingTraits<T>::value, Output &>\noperator<<(Output &Out, T &Val) {\n  EmptyContext Ctx;\n  Out.beginDocuments();\n  if (Out.preflightDocument(0)) {\n    yamlize(Out, Val, true, Ctx);\n    Out.postflightDocument();\n  }\n  Out.endDocuments();\n  return Out;\n}\n\n// Define non-member operator<< so that Output can stream out a polymorphic\n// type.\ntemplate <typename T>\ninline std::enable_if_t<has_PolymorphicTraits<T>::value, Output &>\noperator<<(Output &Out, T &Val) {\n  EmptyContext Ctx;\n  Out.beginDocuments();\n  if (Out.preflightDocument(0)) {\n    // FIXME: The parser does not support explicit documents terminated with a\n    // plain scalar; the end-marker is included as part of the scalar token.\n    assert(PolymorphicTraits<T>::getKind(Val) != NodeKind::Scalar && \"plain scalar documents are not supported\");\n    yamlize(Out, Val, true, Ctx);\n    Out.postflightDocument();\n  }\n  Out.endDocuments();\n  return Out;\n}\n\n// Provide better error message about types missing a trait specialization\ntemplate <typename T>\ninline std::enable_if_t<missingTraits<T, EmptyContext>::value, Output &>\noperator<<(Output &yout, T &seq) {\n  char missing_yaml_trait_for_type[sizeof(MissingTrait<T>)];\n  return yout;\n}\n\ntemplate <bool B> struct IsFlowSequenceBase {};\ntemplate <> struct IsFlowSequenceBase<true> { static const bool flow = true; };\n\ntemplate <typename T, bool Flow>\nstruct SequenceTraitsImpl : IsFlowSequenceBase<Flow> {\nprivate:\n  using type = typename T::value_type;\n\npublic:\n  static size_t size(IO &io, T &seq) { return seq.size(); }\n\n  static type &element(IO &io, T &seq, size_t index) {\n    if (index >= seq.size())\n      seq.resize(index + 1);\n    return seq[index];\n  }\n};\n\n// Simple helper to check an expression can be used as a bool-valued template\n// argument.\ntemplate <bool> struct CheckIsBool { static const bool value = true; };\n\n// If T has SequenceElementTraits, then vector<T> and SmallVector<T, N> have\n// SequenceTraits that do the obvious thing.\ntemplate <typename T>\nstruct SequenceTraits<\n    std::vector<T>,\n    std::enable_if_t<CheckIsBool<SequenceElementTraits<T>::flow>::value>>\n    : SequenceTraitsImpl<std::vector<T>, SequenceElementTraits<T>::flow> {};\ntemplate <typename T, unsigned N>\nstruct SequenceTraits<\n    SmallVector<T, N>,\n    std::enable_if_t<CheckIsBool<SequenceElementTraits<T>::flow>::value>>\n    : SequenceTraitsImpl<SmallVector<T, N>, SequenceElementTraits<T>::flow> {};\ntemplate <typename T>\nstruct SequenceTraits<\n    SmallVectorImpl<T>,\n    std::enable_if_t<CheckIsBool<SequenceElementTraits<T>::flow>::value>>\n    : SequenceTraitsImpl<SmallVectorImpl<T>, SequenceElementTraits<T>::flow> {};\n\n// Sequences of fundamental types use flow formatting.\ntemplate <typename T>\nstruct SequenceElementTraits<T,\n                             std::enable_if_t<std::is_fundamental<T>::value>> {\n  static const bool flow = true;\n};\n\n// Sequences of strings use block formatting.\ntemplate<> struct SequenceElementTraits<std::string> {\n  static const bool flow = false;\n};\ntemplate<> struct SequenceElementTraits<StringRef> {\n  static const bool flow = false;\n};\ntemplate<> struct SequenceElementTraits<std::pair<std::string, std::string>> {\n  static const bool flow = false;\n};\n\n/// Implementation of CustomMappingTraits for std::map<std::string, T>.\ntemplate <typename T> struct StdMapStringCustomMappingTraitsImpl {\n  using map_type = std::map<std::string, T>;\n\n  static void inputOne(IO &io, StringRef key, map_type &v) {\n    io.mapRequired(key.str().c_str(), v[std::string(key)]);\n  }\n\n  static void output(IO &io, map_type &v) {\n    for (auto &p : v)\n      io.mapRequired(p.first.c_str(), p.second);\n  }\n};\n\n} // end namespace yaml\n} // end namespace llvm\n\n#define LLVM_YAML_IS_SEQUENCE_VECTOR_IMPL(TYPE, FLOW)                          \\\n  namespace llvm {                                                             \\\n  namespace yaml {                                                             \\\n  static_assert(                                                               \\\n      !std::is_fundamental<TYPE>::value &&                                     \\\n      !std::is_same<TYPE, std::string>::value &&                               \\\n      !std::is_same<TYPE, llvm::StringRef>::value,                             \\\n      \"only use LLVM_YAML_IS_SEQUENCE_VECTOR for types you control\");          \\\n  template <> struct SequenceElementTraits<TYPE> {                             \\\n    static const bool flow = FLOW;                                             \\\n  };                                                                           \\\n  }                                                                            \\\n  }\n\n/// Utility for declaring that a std::vector of a particular type\n/// should be considered a YAML sequence.\n#define LLVM_YAML_IS_SEQUENCE_VECTOR(type)                                     \\\n  LLVM_YAML_IS_SEQUENCE_VECTOR_IMPL(type, false)\n\n/// Utility for declaring that a std::vector of a particular type\n/// should be considered a YAML flow sequence.\n#define LLVM_YAML_IS_FLOW_SEQUENCE_VECTOR(type)                                \\\n  LLVM_YAML_IS_SEQUENCE_VECTOR_IMPL(type, true)\n\n#define LLVM_YAML_DECLARE_MAPPING_TRAITS(Type)                                 \\\n  namespace llvm {                                                             \\\n  namespace yaml {                                                             \\\n  template <> struct MappingTraits<Type> {                                     \\\n    static void mapping(IO &IO, Type &Obj);                                    \\\n  };                                                                           \\\n  }                                                                            \\\n  }\n\n#define LLVM_YAML_DECLARE_ENUM_TRAITS(Type)                                    \\\n  namespace llvm {                                                             \\\n  namespace yaml {                                                             \\\n  template <> struct ScalarEnumerationTraits<Type> {                           \\\n    static void enumeration(IO &io, Type &Value);                              \\\n  };                                                                           \\\n  }                                                                            \\\n  }\n\n#define LLVM_YAML_DECLARE_BITSET_TRAITS(Type)                                  \\\n  namespace llvm {                                                             \\\n  namespace yaml {                                                             \\\n  template <> struct ScalarBitSetTraits<Type> {                                \\\n    static void bitset(IO &IO, Type &Options);                                 \\\n  };                                                                           \\\n  }                                                                            \\\n  }\n\n#define LLVM_YAML_DECLARE_SCALAR_TRAITS(Type, MustQuote)                       \\\n  namespace llvm {                                                             \\\n  namespace yaml {                                                             \\\n  template <> struct ScalarTraits<Type> {                                      \\\n    static void output(const Type &Value, void *ctx, raw_ostream &Out);        \\\n    static StringRef input(StringRef Scalar, void *ctxt, Type &Value);         \\\n    static QuotingType mustQuote(StringRef) { return MustQuote; }              \\\n  };                                                                           \\\n  }                                                                            \\\n  }\n\n/// Utility for declaring that a std::vector of a particular type\n/// should be considered a YAML document list.\n#define LLVM_YAML_IS_DOCUMENT_LIST_VECTOR(_type)                               \\\n  namespace llvm {                                                             \\\n  namespace yaml {                                                             \\\n  template <unsigned N>                                                        \\\n  struct DocumentListTraits<SmallVector<_type, N>>                             \\\n      : public SequenceTraitsImpl<SmallVector<_type, N>, false> {};            \\\n  template <>                                                                  \\\n  struct DocumentListTraits<std::vector<_type>>                                \\\n      : public SequenceTraitsImpl<std::vector<_type>, false> {};               \\\n  }                                                                            \\\n  }\n\n/// Utility for declaring that std::map<std::string, _type> should be considered\n/// a YAML map.\n#define LLVM_YAML_IS_STRING_MAP(_type)                                         \\\n  namespace llvm {                                                             \\\n  namespace yaml {                                                             \\\n  template <>                                                                  \\\n  struct CustomMappingTraits<std::map<std::string, _type>>                     \\\n      : public StdMapStringCustomMappingTraitsImpl<_type> {};                  \\\n  }                                                                            \\\n  }\n\nLLVM_YAML_IS_FLOW_SEQUENCE_VECTOR(llvm::yaml::Hex64)\nLLVM_YAML_IS_FLOW_SEQUENCE_VECTOR(llvm::yaml::Hex32)\nLLVM_YAML_IS_FLOW_SEQUENCE_VECTOR(llvm::yaml::Hex16)\nLLVM_YAML_IS_FLOW_SEQUENCE_VECTOR(llvm::yaml::Hex8)\n\n#endif // LLVM_SUPPORT_YAMLTRAITS_H\n"}}, "reports": [{"events": [{"location": {"col": 9, "file": 0, "line": 32}, "message": "destructor '~Permissions' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/lldb/include/lldb/Breakpoint/BreakpointName.h", "reportHash": "10c2aeb801b4f96a2242b5573ec2b2eb", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 9, "file": 1, "line": 86}, "message": "destructor '~CommandBaton' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/lldb/include/lldb/Breakpoint/BreakpointOptions.h", "reportHash": "1d5e9c32c37ccc4ff4438c4162c6fa87", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 2, "line": 59}, "message": "destructor '~Address' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/lldb/include/lldb/Core/Address.h", "reportHash": "1e6e71514ab70e2bfd43a96c207dbb5d", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 10, "file": 3, "line": 452}, "message": "destructor '~SourceLine' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/lldb/include/lldb/Core/Disassembler.h", "reportHash": "5c3408b4555e3ac2e59b22b83c81bd54", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 5, "file": 4, "line": 187}, "message": "default constructor '' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/lldb/include/lldb/Core/EmulateInstruction.h", "reportHash": "d70578c65577b080576703531c9a2f99", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 14, "file": 4, "line": 188}, "message": "default constructor 'RegisterPlusOffset' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/lldb/include/lldb/Core/EmulateInstruction.h", "reportHash": "a4dec4f37b66739afc7c6fb8ed46c4f9", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 14, "file": 4, "line": 193}, "message": "default constructor 'RegisterPlusIndirectOffset' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/lldb/include/lldb/Core/EmulateInstruction.h", "reportHash": "8460b2bab2888b4362795722d133c92c", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 14, "file": 4, "line": 198}, "message": "default constructor 'RegisterToRegisterPlusOffset' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/lldb/include/lldb/Core/EmulateInstruction.h", "reportHash": "7d498a0f029a7f147c67a3aaa3aa30ac", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 14, "file": 4, "line": 204}, "message": "default constructor 'RegisterToRegisterPlusIndirectOffset' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/lldb/include/lldb/Core/EmulateInstruction.h", "reportHash": "ca48015845d8f316121cb429880cf5e8", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 14, "file": 4, "line": 210}, "message": "default constructor 'RegisterRegisterOperands' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/lldb/include/lldb/Core/EmulateInstruction.h", "reportHash": "2cc95168972ec38a452a8c8e47ff7ac8", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 14, "file": 4, "line": 227}, "message": "default constructor 'ISAAndImmediate' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/lldb/include/lldb/Core/EmulateInstruction.h", "reportHash": "d543d6603777a0c9467bff3e16d579b2", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 14, "file": 4, "line": 232}, "message": "default constructor 'ISAAndImmediateSigned' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/lldb/include/lldb/Core/EmulateInstruction.h", "reportHash": "ea9d9755ea49b218d275e468279d0473", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 10, "file": 5, "line": 39}, "message": "destructor '~Entry' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/lldb/include/lldb/Core/FormatEntity.h", "reportHash": "02c6bebf50fdbad2931f04d382fc9fbc", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 10, "file": 5, "line": 39}, "message": "move assignment operator 'operator=' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/lldb/include/lldb/Core/FormatEntity.h", "reportHash": "3db27349f855d89aec95088cbf2e89e6", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 10, "file": 5, "line": 39}, "message": "move constructor 'Entry' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/lldb/include/lldb/Core/FormatEntity.h", "reportHash": "d2eaaf0694b38abd470ed5954ae204b0", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 6, "line": 21}, "message": "destructor '~LoadedModuleInfoList' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/lldb/include/lldb/Core/LoadedModuleInfoList.h", "reportHash": "68a143aa2f632f5e61fb7ba7fd74a250", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 6, "line": 21}, "message": "move constructor 'LoadedModuleInfoList' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/lldb/include/lldb/Core/LoadedModuleInfoList.h", "reportHash": "e4200a778c3925d31d1d9ab26ec283e2", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 9, "file": 6, "line": 23}, "message": "destructor '~LoadedModuleInfo' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/lldb/include/lldb/Core/LoadedModuleInfoList.h", "reportHash": "dd9a2dc675870642bd5cc3a1cfbc96db", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 9, "file": 6, "line": 23}, "message": "move assignment operator 'operator=' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/lldb/include/lldb/Core/LoadedModuleInfoList.h", "reportHash": "390ff9bac38b537f31e050654eea5854", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 9, "file": 6, "line": 23}, "message": "move constructor 'LoadedModuleInfo' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/lldb/include/lldb/Core/LoadedModuleInfoList.h", "reportHash": "b6cae00f2df267013e3d54a4b1def3fe", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 7, "line": 35}, "message": "destructor '~Mangled' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/lldb/include/lldb/Core/Mangled.h", "reportHash": "b5a37ee2e62efd64bb12f0cd2d66240e", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 8, "line": 26}, "message": "destructor '~ModuleSpec' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/lldb/include/lldb/Core/ModuleSpec.h", "reportHash": "d6a791df7aff0406c4238e6cf6d152b1", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 9, "line": 258}, "message": "default constructor '' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/lldb/include/lldb/Core/Opcode.h", "reportHash": "d866454e5cdc64d48d2eb4a844b97cbf", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 5, "file": 9, "line": 263}, "message": "default constructor '' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/lldb/include/lldb/Core/Opcode.h", "reportHash": "6e2ce32a5e0d6702d28cfdb10d918c00", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 10, "line": 38}, "message": "destructor '~Value' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/lldb/include/lldb/Core/Value.h", "reportHash": "57cf27095e7fe55b9c7654ded5ec6080", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 10, "file": 11, "line": 196}, "message": "destructor '~GetValueForExpressionPathOptions' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/lldb/include/lldb/Core/ValueObject.h", "reportHash": "be6ee5686874b7b1ca78a81f7580f670", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 10, "file": 12, "line": 148}, "message": "default constructor 'TypeOrName' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/lldb/include/lldb/DataFormatters/FormatClasses.h", "reportHash": "6dc2ffaf41c69f6e7a03b3fcb99cd53e", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 10, "file": 12, "line": 148}, "message": "destructor '~TypeOrName' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/lldb/include/lldb/DataFormatters/FormatClasses.h", "reportHash": "9a5063429020e5b550eca70625ee1638", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 13, "line": 41}, "message": "destructor '~TypeMatcher' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/lldb/include/lldb/DataFormatters/FormattersContainer.h", "reportHash": "772ebd671fb1c4a3d752cb662ecc5352", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 14, "line": 63}, "message": "destructor '~InferiorSizedWord' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/lldb/include/lldb/DataFormatters/FormattersHelpers.h", "reportHash": "984c66b2a17e02243cb4c6cecf083714", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 14, "line": 181}, "message": "destructor '~' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/lldb/include/lldb/DataFormatters/FormattersHelpers.h", "reportHash": "2a20b18308955eaab93c38c5008c77c4", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 9, "file": 15, "line": 26}, "message": "destructor '~Flags' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/lldb/include/lldb/DataFormatters/TypeFormat.h", "reportHash": "b88f0126462035bf3f688c7119a81625", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 9, "file": 16, "line": 134}, "message": "destructor '~Flags' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/lldb/include/lldb/DataFormatters/TypeSynthetic.h", "reportHash": "c66f87cf47dc71a674243c01f343d76c", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 16, "line": 277}, "message": "destructor '~TypeFilterImpl' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/lldb/include/lldb/DataFormatters/TypeSynthetic.h", "reportHash": "4c9dc5445a9c508e681ec31fd4e878fe", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 16, "line": 358}, "message": "destructor '~CXXSyntheticChildren' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/lldb/include/lldb/DataFormatters/TypeSynthetic.h", "reportHash": "9e92e13a3c5ebea9984b8fbb6a997b76", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 16, "line": 387}, "message": "destructor '~ScriptedSyntheticChildren' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/lldb/include/lldb/DataFormatters/TypeSynthetic.h", "reportHash": "99cb905c84d937a0b97d48d72bdbb1a3", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 17, "line": 34}, "message": "destructor '~File' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/lldb/include/lldb/Host/File.h", "reportHash": "9c51b3610435a0f3f14ed9511c04c914", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 18, "line": 17}, "message": "destructor '~FileAction' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/lldb/include/lldb/Host/FileAction.h", "reportHash": "ad1f4d08f055e15ac4a27ccfbad93ee4", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 18, "line": 17}, "message": "move assignment operator 'operator=' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/lldb/include/lldb/Host/FileAction.h", "reportHash": "3d6b5c25856b8ea58256b065dd5123c8", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 18, "line": 17}, "message": "move constructor 'FileAction' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/lldb/include/lldb/Host/FileAction.h", "reportHash": "fb59f9158fdba0fc088716a22558d4dc", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 19, "line": 34}, "message": "destructor '~WaitStatus' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/lldb/include/lldb/Host/Host.h", "reportHash": "0669d6a7d75dba2d40f4497c409fbebf", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 20, "line": 33}, "message": "destructor '~CompilerType' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/lldb/include/lldb/Symbol/CompilerType.h", "reportHash": "66ea30ea1943c0190ee18c27c7b19d5c", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 21, "line": 20}, "message": "destructor '~LineEntry' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/lldb/include/lldb/Symbol/LineEntry.h", "reportHash": "a7800d5041f803bc8a8bdd1ce085a3cd", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 22, "line": 20}, "message": "destructor '~Symbol' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/lldb/include/lldb/Symbol/Symbol.h", "reportHash": "cf53d050ca2257657a7cad7ec3499c1a", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 23, "line": 27}, "message": "destructor '~InstrumentationRuntime' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/lldb/include/lldb/Target/InstrumentationRuntime.h", "reportHash": "4a1ef3425ebd305184e7bd8bb8ae7144", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 24, "line": 255}, "message": "destructor '~EvaluateExpressionOptions' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/lldb/include/lldb/Target/Target.h", "reportHash": "04a1b6e417029f3feaaddb2e6da81b25", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 25, "line": 33}, "message": "destructor '~ThreadSpec' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/lldb/include/lldb/Target/ThreadSpec.h", "reportHash": "a77caf24b7daa15abe6952e8ac7d6912", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 10, "file": 26, "line": 35}, "message": "destructor '~ArgEntry' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/lldb/include/lldb/Utility/Args.h", "reportHash": "be5a4b7a905808610f7affe6ea9627e1", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 10, "file": 26, "line": 35}, "message": "move constructor 'ArgEntry' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/lldb/include/lldb/Utility/Args.h", "reportHash": "77bd2d10b1a5d1827d34037380a44df2", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 29, "file": 27, "line": 62}, "message": "destructor '~TypedBaton' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/lldb/include/lldb/Utility/Baton.h", "reportHash": "590b20f052b0927ce8e15e29d7301f68", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 28, "line": 40}, "message": "destructor '~ConstString' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/lldb/include/lldb/Utility/ConstString.h", "reportHash": "bcba46ffba59fa6b90703ec39f9d105c", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 28, "line": 40}, "message": "move assignment operator 'operator=' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/lldb/include/lldb/Utility/ConstString.h", "reportHash": "be2359feb8ba36b236d439e5fa430542", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 28, "line": 40}, "message": "move constructor 'ConstString' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/lldb/include/lldb/Utility/ConstString.h", "reportHash": "801082c8f583bd520579b0108edbe122", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 29, "line": 43}, "message": "default constructor 'DataBuffer' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/lldb/include/lldb/Utility/DataBuffer.h", "reportHash": "c9e1c7c5da4e40bb03a482ffe6cc952d", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 29, "line": 82}, "message": "destructor '~DataBufferUnowned' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/lldb/include/lldb/Utility/DataBuffer.h", "reportHash": "9ea6eeae775d9d709eb060dafb9763cb", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 30, "line": 18}, "message": "destructor '~Environment' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/lldb/include/lldb/Utility/Environment.h", "reportHash": "bc9291431b24e1facab24af30904f3b5", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 9, "file": 30, "line": 22}, "message": "destructor '~Envp' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/lldb/include/lldb/Utility/Environment.h", "reportHash": "a29baa0792784f8a925eafecc5a31c49", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 31, "line": 56}, "message": "destructor '~FileSpec' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/lldb/include/lldb/Utility/FileSpec.h", "reportHash": "fac3f75f8b0b540e91b65a612d9efb50", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 31, "line": 56}, "message": "move assignment operator 'operator=' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/lldb/include/lldb/Utility/FileSpec.h", "reportHash": "cf89eaa517b0e8d08fdbbeafc6b4509e", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 31, "line": 56}, "message": "move constructor 'FileSpec' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/lldb/include/lldb/Utility/FileSpec.h", "reportHash": "9d441beaf72a73e92a1b62a4e6de57b6", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 33, "line": 153}, "message": "destructor '~AdaptedIterable' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/lldb/include/lldb/Utility/Iterable.h", "reportHash": "818fd53f52f66600c55b4c01ada41eb6", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 33, "line": 153}, "message": "move constructor 'AdaptedIterable' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/lldb/include/lldb/Utility/Iterable.h", "reportHash": "4b65f30533050d7890a19e09c2ddaa6b", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 21, "file": 34, "line": 124}, "message": "destructor '~' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/lldb/include/lldb/Utility/Predicate.h", "reportHash": "46c80b39fba2f72acf60ff26364003a5", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 21, "file": 34, "line": 124}, "message": "move constructor '' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/lldb/include/lldb/Utility/Predicate.h", "reportHash": "6a929bb6250a8ac8760c5013c1495a24", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 20, "file": 34, "line": 157}, "message": "destructor '~' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/lldb/include/lldb/Utility/Predicate.h", "reportHash": "6348cba4b5d2c190db20648f93479d54", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 20, "file": 34, "line": 157}, "message": "move constructor '' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/lldb/include/lldb/Utility/Predicate.h", "reportHash": "a06eb1d8c2ce3c60f77f45e2ab746947", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 35, "line": 30}, "message": "destructor '~ProcessInfo' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/lldb/include/lldb/Utility/ProcessInfo.h", "reportHash": "ddfbbfeb9c9b9cae43e83bcd3a00abdc", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 35, "line": 108}, "message": "destructor '~ProcessInstanceInfo' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/lldb/include/lldb/Utility/ProcessInfo.h", "reportHash": "51c87a2973bd4a4523613937865dad62", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 42, "file": 36, "line": 29}, "message": "destructor '~Range' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/lldb/include/lldb/Utility/RangeMap.h", "reportHash": "3f0bede38e72fd4918e10dd523bafba9", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 42, "file": 36, "line": 29}, "message": "move constructor 'Range' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/lldb/include/lldb/Utility/RangeMap.h", "reportHash": "2d4a356f8fba24e685607709c6340847", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 36, "line": 373}, "message": "destructor '~RangeData' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/lldb/include/lldb/Utility/RangeMap.h", "reportHash": "9c4b6634f67c924019b5a96c07c78890", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 36, "line": 373}, "message": "move constructor 'RangeData' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/lldb/include/lldb/Utility/RangeMap.h", "reportHash": "d47b0494d4ea1e38ce3957006ed9a1dd", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 36, "line": 389}, "message": "destructor '~AugmentedRangeData' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/lldb/include/lldb/Utility/RangeMap.h", "reportHash": "a41e6fa0f21a7aac10db449233e54e53", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 36, "line": 389}, "message": "move constructor 'AugmentedRangeData' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/lldb/include/lldb/Utility/RangeMap.h", "reportHash": "ec25bdfa2e978c91eaa8bbde6aa3c015", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 37, "line": 34}, "message": "destructor '~Scalar' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/lldb/include/lldb/Utility/Scalar.h", "reportHash": "58d19223e9d3376e035c9b88fb4435b0", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 39, "line": 18}, "message": "destructor '~StringLexer' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/lldb/include/lldb/Utility/StringLexer.h", "reportHash": "386f9fd0268b781062a412e7031d7101", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 9, "file": 40, "line": 336}, "message": "destructor '~String' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/lldb/include/lldb/Utility/StructuredData.h", "reportHash": "a3b97384b4192b228b0759c32a406532", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 9, "file": 40, "line": 533}, "message": "destructor '~Generic' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/lldb/include/lldb/Utility/StructuredData.h", "reportHash": "edcdbe9f926d1ddae20c1a14ddddede0", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 41, "line": 28}, "message": "destructor '~Timeout' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/lldb/include/lldb/Utility/Timeout.h", "reportHash": "6618ccefb269e157d9a1bb1070871385", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 42, "line": 23}, "message": "destructor '~UUID' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/lldb/include/lldb/Utility/UUID.h", "reportHash": "2c65efa86ce90836621fb07c9c9e8ba0", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 29, "file": 42, "line": 67}, "message": "destructor '~' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/lldb/include/lldb/Utility/UUID.h", "reportHash": "6ac911fa2f835199c961e5efe2a5e6f7", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 29, "file": 42, "line": 67}, "message": "move constructor '' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/lldb/include/lldb/Utility/UUID.h", "reportHash": "93a4a011b94c0841eb7dcb36513d84bd", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 43, "line": 16}, "message": "default constructor 'UnimplementedError' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/lldb/include/lldb/Utility/UnimplementedError.h", "reportHash": "402e9b203fab2e0b00b40967d4b418be", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 43, "line": 16}, "message": "destructor '~UnimplementedError' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/lldb/include/lldb/Utility/UnimplementedError.h", "reportHash": "67c97157c093cad4e032cdfd16244d68", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 44, "line": 33}, "message": "default constructor 'RegisterInfo' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/lldb/include/lldb/lldb-private-types.h", "reportHash": "0ddd5fbd15511178c1cf3d1090c7628a", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 45, "line": 170}, "message": "destructor '~VariantFrontEnd' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/lldb/source/Plugins/Language/CPlusPlus/LibCxxVariant.cpp", "reportHash": "10a3a7a6e7764a9b41251bb5263a3b97", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 46, "line": 143}, "message": "default constructor 'APFloatBase' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/APFloat.h", "reportHash": "2537f08c97f11488d796c689253aa151", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 51, "line": 1189}, "message": "destructor '~DenseMapIterator' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/DenseMap.h", "reportHash": "2f6e17031439bcc4a01aca008941d21c", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 51, "line": 1189}, "message": "move assignment operator 'operator=' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/DenseMap.h", "reportHash": "4e3e6bb0cd24af9f2fd0cccbbd81ece4", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 51, "line": 1189}, "message": "move constructor 'DenseMapIterator' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/DenseMap.h", "reportHash": "a27766cc9122dbe74815a89dcf8908c4", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 58, "line": 179}, "message": "move assignment operator 'operator=' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/STLExtras.h", "reportHash": "4db8734b9a3e0d42e86b3471753da52c", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 9, "file": 59, "line": 66}, "message": "destructor '~reference' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/SmallBitVector.h", "reportHash": "f13e90ca272b98ce5d3ce880641b22a7", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 62, "line": 371}, "message": "destructor '~StringMapIterBase' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/StringMap.h", "reportHash": "583313c5339021c4a0119d8d8743b3e8", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 62, "line": 371}, "message": "move assignment operator 'operator=' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/StringMap.h", "reportHash": "48d4db1c65fdee1456e1661ce9703922", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 62, "line": 371}, "message": "move constructor 'StringMapIterBase' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/StringMap.h", "reportHash": "5da1099e13ae8c6cb7567f4f6c5e7a48", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 62, "line": 416}, "message": "destructor '~StringMapConstIterator' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/StringMap.h", "reportHash": "ca81a610f629cdcb6d5eeb2fe8691085", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 62, "line": 416}, "message": "move constructor 'StringMapConstIterator' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/StringMap.h", "reportHash": "05c8a5887bcada25b1bea9088f9ba41d", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 62, "line": 434}, "message": "destructor '~StringMapIterator' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/StringMap.h", "reportHash": "acc389597a85e5eeacd75b518cbf6b2e", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 62, "line": 434}, "message": "move assignment operator 'operator=' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/StringMap.h", "reportHash": "ef4550bd3824d3d91b9fc49646f8eeca", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 62, "line": 434}, "message": "move constructor 'StringMapIterator' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/StringMap.h", "reportHash": "7f539a09eae420d7d4ef1e1db76e7183", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 65, "line": 45}, "message": "destructor '~Triple' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/Triple.h", "reportHash": "85774516e5fc4d034c2988a99fd7731c", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 67, "line": 67}, "message": "move assignment operator 'operator=' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/iterator.h", "reportHash": "21d515b9f3b6a6f9c24ba5a791c9a2ae", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 46, "file": 69, "line": 27}, "message": "default constructor 'AlignedCharArrayUnion' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/AlignOf.h", "reportHash": "21c5647463f56c57a677057851258f39", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 36, "file": 71, "line": 33}, "message": "move assignment operator 'operator=' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/AllocatorBase.h", "reportHash": "f60461422303bb8ce6e83951838d49b6", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 36, "file": 71, "line": 33}, "message": "move constructor 'AllocatorBase' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/AllocatorBase.h", "reportHash": "0bbf109cc598ffc81a09d84ff7eac239", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 71, "line": 80}, "message": "move assignment operator 'operator=' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/AllocatorBase.h", "reportHash": "0d5c82586c5db40f9298f5e1ec0173fe", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 71, "line": 80}, "message": "move constructor 'MallocAllocator' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/AllocatorBase.h", "reportHash": "76ebcec446f62d9465989047022aa8fc", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 80, "line": 156}, "message": "move constructor 'Array' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/JSON.h", "reportHash": "1894214e821f24dc063e892db66f6e84", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 80, "line": 495}, "message": "destructor '~ObjectKey' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/JSON.h", "reportHash": "db694bf7e8d20ae344813816536818fe", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 80, "line": 570}, "message": "destructor '~Path' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/JSON.h", "reportHash": "e6957a85f782c08dc765ea3fb48d7189", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 80, "line": 570}, "message": "move constructor 'Path' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/JSON.h", "reportHash": "e6489bb33319dfab847c358f24eef723", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 9, "file": 80, "line": 589}, "message": "destructor '~Segment' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/JSON.h", "reportHash": "1544ed1b30226f5f22df80314a27c7fc", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 9, "file": 80, "line": 589}, "message": "move constructor 'Segment' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/JSON.h", "reportHash": "f70317aafa0537c5a7d1f912482fdd25", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 13, "file": 80, "line": 617}, "message": "destructor '~Root' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/JSON.h", "reportHash": "b1844079fc85cf2da49569a8e457f3b8", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 80, "line": 802}, "message": "destructor '~ParseError' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/JSON.h", "reportHash": "f67c097e7891a33a43100ba10885c4fb", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 14, "file": 80, "line": 930}, "message": "destructor '~' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/JSON.h", "reportHash": "48291d2db252faff6268b003d0be8e3b", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 24, "file": 80, "line": 942}, "message": "destructor '~' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/JSON.h", "reportHash": "0224b21f6725925e93cae34662e330c2", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 24, "file": 80, "line": 946}, "message": "destructor '~' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/JSON.h", "reportHash": "ae117299954742739d3eb2b70bab6963", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 24, "file": 80, "line": 950}, "message": "destructor '~' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/JSON.h", "reportHash": "03ab3b1641c38738fe870ddc37226806", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 10, "file": 80, "line": 982}, "message": "default constructor 'State' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/JSON.h", "reportHash": "1845f470c05ba3eb9c3e4305032822f1", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 10, "file": 80, "line": 982}, "message": "destructor '~State' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/JSON.h", "reportHash": "94df10c0fae09499c6476cbaa7e0cf8e", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 10, "file": 80, "line": 982}, "message": "move constructor 'State' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/JSON.h", "reportHash": "c0e28025faa8ca5702ec7bc50a04b4c8", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 88, "line": 329}, "message": "destructor '~basic_collection_iterator' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/YAMLParser.h", "reportHash": "9f944873243469edcfd66ae688992ad3", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 88, "line": 329}, "message": "move constructor 'basic_collection_iterator' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/YAMLParser.h", "reportHash": "a40f08feb3897fe8c62e150e522adfaa", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 88, "line": 527}, "message": "destructor '~Document' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/YAMLParser.h", "reportHash": "65e1e315f968fb51891edc7d8901f627", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 89, "line": 49}, "message": "default constructor 'EmptyContext' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/YAMLTraits.h", "reportHash": "3b1d5d087ce4dee2a8bbc1f74f16c0a2", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 34, "file": 89, "line": 541}, "message": "destructor '~' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/YAMLTraits.h", "reportHash": "07a0e302dd873260b2aca2f0e57fb569", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 34, "file": 89, "line": 541}, "message": "move constructor '' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/YAMLTraits.h", "reportHash": "5eac3d270687a4d9aa120135051d40c0", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 9, "file": 89, "line": 1435}, "message": "destructor '~EmptyHNode' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/YAMLTraits.h", "reportHash": "4469ba3678f189c5ac23c99ee8f307a2", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 9, "file": 89, "line": 1446}, "message": "destructor '~ScalarHNode' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/YAMLTraits.h", "reportHash": "233833abd59df25a56bc4d9eb15b3be0", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 9, "file": 89, "line": 1465}, "message": "destructor '~MapHNode' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/YAMLTraits.h", "reportHash": "11bc39de7395b0d27f0cbb752422912b", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 9, "file": 89, "line": 1484}, "message": "destructor '~SequenceHNode' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/YAMLTraits.h", "reportHash": "de27c7d29500613c5882e5ab52c92cab", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}]};
      window.onload = function() {
        if (!browserCompatible) {
          setNonCompatibleBrowserMessage();
        } else {
          BugViewer.init(data.files, data.reports);
          BugViewer.create();
          BugViewer.initByUrl();
        }
      };
    </script>
  </head>
  <body>
  <div class="container">
    <div id="content">
      <div id="side-bar">
        <div class="header">
          <a href="index.html" class="button">&#8249; Return to List</a>
        </div>
        <div id="report-nav">
          <div class="header">Reports</div>
        </div>
      </div>
      <div id="editor-wrapper">
        <div class="header">
          <div id="file">
            <span class="label">File:</span>
            <span id="file-path"></span>
          </div>
          <div id="checker">
            <span class="label">Checker name:</span>
            <span id="checker-name"></span>
          </div>
          <div id="review-status-wrapper">
            <span class="label">Review status:</span>
            <span id="review-status"></span>
          </div>
        </div>
        <div id="editor"></div>
      </div>
    </div>
  </div>
  </body>
</html>
