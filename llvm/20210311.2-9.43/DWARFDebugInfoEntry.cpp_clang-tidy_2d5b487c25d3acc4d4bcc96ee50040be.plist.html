<!DOCTYPE html>
<html>
  <head>
    <title>Plist HTML Viewer</title>

    <meta charset="UTF-8">

    <style type="text/css">
      .CodeMirror{font-family:monospace;height:300px;color:#000;direction:ltr}.CodeMirror-lines{padding:4px 0}.CodeMirror pre{padding:0 4px}.CodeMirror-gutter-filler,.CodeMirror-scrollbar-filler{background-color:#fff}.CodeMirror-gutters{border-right:1px solid #ddd;background-color:#f7f7f7;white-space:nowrap}.CodeMirror-linenumber{padding:0 3px 0 5px;min-width:20px;text-align:right;color:#999;white-space:nowrap}.CodeMirror-guttermarker{color:#000}.CodeMirror-guttermarker-subtle{color:#999}.CodeMirror-cursor{border-left:1px solid #000;border-right:none;width:0}.CodeMirror div.CodeMirror-secondarycursor{border-left:1px solid silver}.cm-fat-cursor .CodeMirror-cursor{width:auto;border:0!important;background:#7e7}.cm-fat-cursor div.CodeMirror-cursors{z-index:1}.cm-animate-fat-cursor{width:auto;border:0;-webkit-animation:blink 1.06s steps(1) infinite;-moz-animation:blink 1.06s steps(1) infinite;animation:blink 1.06s steps(1) infinite;background-color:#7e7}@-moz-keyframes blink{50%{background-color:transparent}}@-webkit-keyframes blink{50%{background-color:transparent}}@keyframes blink{50%{background-color:transparent}}.cm-tab{display:inline-block;text-decoration:inherit}.CodeMirror-rulers{position:absolute;left:0;right:0;top:-50px;bottom:-20px;overflow:hidden}.CodeMirror-ruler{border-left:1px solid #ccc;top:0;bottom:0;position:absolute}.cm-s-default .cm-header{color:#00f}.cm-s-default .cm-quote{color:#090}.cm-negative{color:#d44}.cm-positive{color:#292}.cm-header,.cm-strong{font-weight:700}.cm-em{font-style:italic}.cm-link{text-decoration:underline}.cm-strikethrough{text-decoration:line-through}.cm-s-default .cm-keyword{color:#708}.cm-s-default .cm-atom{color:#219}.cm-s-default .cm-number{color:#164}.cm-s-default .cm-def{color:#00f}.cm-s-default .cm-variable-2{color:#05a}.cm-s-default .cm-type,.cm-s-default .cm-variable-3{color:#085}.cm-s-default .cm-comment{color:#a50}.cm-s-default .cm-string{color:#a11}.cm-s-default .cm-string-2{color:#f50}.cm-s-default .cm-meta{color:#555}.cm-s-default .cm-qualifier{color:#555}.cm-s-default .cm-builtin{color:#30a}.cm-s-default .cm-bracket{color:#997}.cm-s-default .cm-tag{color:#170}.cm-s-default .cm-attribute{color:#00c}.cm-s-default .cm-hr{color:#999}.cm-s-default .cm-link{color:#00c}.cm-s-default .cm-error{color:red}.cm-invalidchar{color:red}.CodeMirror-composing{border-bottom:2px solid}div.CodeMirror span.CodeMirror-matchingbracket{color:#0f0}div.CodeMirror span.CodeMirror-nonmatchingbracket{color:#f22}.CodeMirror-matchingtag{background:rgba(255,150,0,.3)}.CodeMirror-activeline-background{background:#e8f2ff}.CodeMirror{position:relative;overflow:hidden;background:#fff}.CodeMirror-scroll{overflow:scroll!important;margin-bottom:-30px;margin-right:-30px;padding-bottom:30px;height:100%;outline:0;position:relative}.CodeMirror-sizer{position:relative;border-right:30px solid transparent}.CodeMirror-gutter-filler,.CodeMirror-hscrollbar,.CodeMirror-scrollbar-filler,.CodeMirror-vscrollbar{position:absolute;z-index:6;display:none}.CodeMirror-vscrollbar{right:0;top:0;overflow-x:hidden;overflow-y:scroll}.CodeMirror-hscrollbar{bottom:0;left:0;overflow-y:hidden;overflow-x:scroll}.CodeMirror-scrollbar-filler{right:0;bottom:0}.CodeMirror-gutter-filler{left:0;bottom:0}.CodeMirror-gutters{position:absolute;left:0;top:0;min-height:100%;z-index:3}.CodeMirror-gutter{white-space:normal;height:100%;display:inline-block;vertical-align:top;margin-bottom:-30px}.CodeMirror-gutter-wrapper{position:absolute;z-index:4;background:0 0!important;border:none!important}.CodeMirror-gutter-background{position:absolute;top:0;bottom:0;z-index:4}.CodeMirror-gutter-elt{position:absolute;cursor:default;z-index:4}.CodeMirror-gutter-wrapper ::selection{background-color:transparent}.CodeMirror-gutter-wrapper ::-moz-selection{background-color:transparent}.CodeMirror-lines{cursor:text;min-height:1px}.CodeMirror pre{-moz-border-radius:0;-webkit-border-radius:0;border-radius:0;border-width:0;background:0 0;font-family:inherit;font-size:inherit;margin:0;white-space:pre;word-wrap:normal;line-height:inherit;color:inherit;z-index:2;position:relative;overflow:visible;-webkit-tap-highlight-color:transparent;-webkit-font-variant-ligatures:contextual;font-variant-ligatures:contextual}.CodeMirror-wrap pre{word-wrap:break-word;white-space:pre-wrap;word-break:normal}.CodeMirror-linebackground{position:absolute;left:0;right:0;top:0;bottom:0;z-index:0}.CodeMirror-linewidget{position:relative;z-index:2;overflow:auto}.CodeMirror-rtl pre{direction:rtl}.CodeMirror-code{outline:0}.CodeMirror-gutter,.CodeMirror-gutters,.CodeMirror-linenumber,.CodeMirror-scroll,.CodeMirror-sizer{-moz-box-sizing:content-box;box-sizing:content-box}.CodeMirror-measure{position:absolute;width:100%;height:0;overflow:hidden;visibility:hidden}.CodeMirror-cursor{position:absolute;pointer-events:none}.CodeMirror-measure pre{position:static}div.CodeMirror-cursors{visibility:hidden;position:relative;z-index:3}div.CodeMirror-dragcursors{visibility:visible}.CodeMirror-focused div.CodeMirror-cursors{visibility:visible}.CodeMirror-selected{background:#d9d9d9}.CodeMirror-focused .CodeMirror-selected{background:#d7d4f0}.CodeMirror-crosshair{cursor:crosshair}.CodeMirror-line::selection,.CodeMirror-line>span::selection,.CodeMirror-line>span>span::selection{background:#d7d4f0}.CodeMirror-line::-moz-selection,.CodeMirror-line>span::-moz-selection,.CodeMirror-line>span>span::-moz-selection{background:#d7d4f0}.cm-searching{background-color:#ffa;background-color:rgba(255,255,0,.4)}.cm-force-border{padding-right:.1px}@media print{.CodeMirror div.CodeMirror-cursors{visibility:hidden}}.cm-tab-wrap-hack:after{content:''}span.CodeMirror-selectedtext{background:0 0}
/*# sourceMappingURL=codemirror.min.css.map */

      .severity-low {
  background-color: #669603;
}

.severity-low:after {
  content : 'L';
}

.severity-unspecified {
  background-color: #666666;
}

.severity-unspecified:after {
  content : 'U';
}

.severity-style {
  background-color: #9932cc;
}

.severity-style:after {
  content : 'S';
}

.severity-medium {
  background-color: #a9d323;
  color: black;
}

.severity-medium:after {
  content : 'M';
}

.severity-high {
  background-color: #ffa800;
}

.severity-high:after {
  content : 'H';
}

.severity-critical {
  background-color: #e92625;
}

.severity-critical:after {
  content : 'C';
}

i[class*="severity-"] {
  line-height: normal;
  text-transform: capitalize;
  font-size: 0.8em;
  font-weight: bold;
  color: white;
  display: inline-block;
  width: 16px;
  height: 16px;
  text-align: center;
  font-family: sans-serif;
}

      html, body {
  width: 100%;
  height: 100%;
  padding: 0px;
  margin: 0px;
}

div.container {
  padding: 10px;
}

#content {
  height: 100%;
  display: block;
  overflow: hidden;
}

#content > div {
  margin: 10px;
  overflow: hidden;
  border: 1px solid #ddd;
  border-radius: 3px;
  overflow: hidden;
  height: 97%;
}

.button {
  background-color: #f1f1f1;
  text-decoration: none;
  display: inline-block;
  padding: 8px 16px;
  color: black;
  cursor: pointer;
}

.button:hover {
  background-color: #ddd;
  color: black;
}

.review-status {
  color: white;
  text-align: center;
}

.review-status-confirmed {
  background-color: #e92625;
}

.review-status-false-positive {
  background-color: grey;
}

.review-status-intentional {
  background-color: #669603;
}

      div.container {
  width: 100%;
  height: 100%;
  padding: 0px;
}

#editor-wrapper {
  margin: 10px;
}

#side-bar {
  float: left;
  width: 260px;
  margin: 0px;
}

#report-nav ul {
  list-style-type: none;
  padding: 0;
  margin: 0;
  overflow-y: auto;
  height: 100%;
}

#report-nav ul > li {
  padding: .4em;
  background-color: #fff;
  border-bottom: 1px solid rgba(0,0,0,.125);
  text-align: left;
  overflow: hidden;
  white-space: nowrap;
  text-overflow: ellipsis;
}

#report-nav ul > li.active {
  background-color: #427ea9;
  color: white;
}

#report-nav ul > li:hover {
  background-color: #427ea9;
  color: white;
  cursor: pointer;
}

#report-nav ul a {
  text-decoration: none;
}

#report-nav i[class*="severity-"] {
  margin-right: 5px;
}

.header {
  border-bottom: 1px solid lightgrey;
  font-family: monospace;
  padding: 10px;
  background-color: #fafbfc;
  border-bottom: 1px solid #e1e4e8;
  border-top-left-radius: 2px;
  border-top-right-radius: 2px;
}

#report-nav .header {
  font-weight: bold;
}

#editor-wrapper .header > div {
  padding-top: 2px;
}

#file-path,
#checker-name {
  color: #195ea2;
}

#review-status {
  padding: 0px 5px;
}

#file-path {
  font-family: monospace;
}

.check-msg {
  display: inline-block;
  padding: 3px 6px;
  margin: 1px;
  -webkit-border-radius: 5px;
  -moz-border-radius: 5px;
  border-radius: 5px;
}

.check-msg.info {
  color: #00546f;
  background-color: #bfdfe9;
  border: 1px solid #87a8b3;
}

.check-msg.error {
  background-color: #f2dede;
  color: #a94442;
  border: 1px solid #ebcccc;
}

.check-msg.macro {
  background-color: #d7dac2;
  color: #4f5c6d;
  border: 1px solid #d7dac2;
}

.check-msg.note {
  background-color: #d7d7d7;
  color: #4f5c6d;
  border: 1px solid #bfbfbf;
}

.check-msg.current {
  border: 2px dashed #3692ff;
}

.check-msg .tag {
  padding: 1px 5px;
  text-align: center;
  border-radius: 2px;
  margin-right: 5px;
  text-decoration: inherit;
}

.check-msg .tag.macro {
  background-color: #83876a;
  color: white;
  text-transform: capitalize;
}

.check-msg .tag.note {
  background-color: #9299a1;
  color: white;
  text-transform: capitalize;
}

.checker-enum {
  color: white;
  padding: 1px 5px;
  text-align: center;
  border-radius: 25px;
  margin-right: 5px;
  text-decoration: inherit;
}

.checker-enum.info {
  background-color: #427ea9;
}

.checker-enum.error {
  background-color: #a94442;
}

.arrow {
  border: solid black;
  border-width: 0 3px 3px 0;
  display: inline-block;
  padding: 3px;
  cursor: pointer;
  margin: 0px 5px;
}

.arrow:hover {
  border: solid #437ea8;
  border-width: 0 3px 3px 0;
}

.left-arrow {
  transform: rotate(135deg);
  -webkit-transform: rotate(135deg);
}

.right-arrow {
  transform: rotate(-45deg);
  -webkit-transform: rotate(-45deg);
}

    </style>

    <script type="text/javascript">
      function setNonCompatibleBrowserMessage() {
  document.body.innerHTML =
    '<h2 style="margin-left: 20px;">Your browser is not compatible with CodeChecker Viewer!</h2> \
     <p style="margin-left: 20px;">The version required for the following browsers are:</p> \
     <ul style="margin-left: 20px;"> \
     <li>Internet Explorer: version 9 or newer</li> \
     <li>Firefox: version 22.0 or newer</li> \
     </ul>';
}

// http://stackoverflow.com/questions/5916900/how-can-you-detect-the-version-of-a-browser
var browserVersion = (function(){
  var ua = navigator.userAgent, tem,
    M = ua.match(/(opera|chrome|safari|firefox|msie|trident(?=\/))\/?\s*(\d+)/i) || [];

  if (/trident/i.test(M[1])) {
    tem = /\brv[ :]+(\d+)/g.exec(ua) || [];
    return 'IE ' + (tem[1] || '');
  }

  if (M[1] === 'Chrome') {
    tem = ua.match(/\b(OPR|Edge)\/(\d+)/);
    if (tem != null) return tem.slice(1).join(' ').replace('OPR', 'Opera');
  }

  M = M[2] ? [M[1], M[2]] : [navigator.appName, navigator.appVersion, '-?'];
  if ((tem = ua.match(/version\/(\d+)/i)) != null) M.splice(1, 1, tem[1]);
    return M.join(' ');
})();

var pos = browserVersion.indexOf(' ');
var browser = browserVersion.substr(0, pos);
var version = parseInt(browserVersion.substr(pos + 1));

var browserCompatible
  = browser === 'Firefox'
  ? version >= 22
  : browser === 'IE'
  ? version >= 9
  : true;


      /* MIT License

Copyright (C) 2017 by Marijn Haverbeke <marijnh@gmail.com> and others

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
 */
      !function(e,t){"object"==typeof exports&&"undefined"!=typeof module?module.exports=t():"function"==typeof define&&define.amd?define(t):e.CodeMirror=t()}(this,function(){"use strict";function e(e){return new RegExp("(^|\\s)"+e+"(?:$|\\s)\\s*")}function t(e){for(var t=e.childNodes.length;t>0;--t)e.removeChild(e.firstChild);return e}function r(e,r){return t(e).appendChild(r)}function n(e,t,r,n){var i=document.createElement(e);if(r&&(i.className=r),n&&(i.style.cssText=n),"string"==typeof t)i.appendChild(document.createTextNode(t));else if(t)for(var o=0;o<t.length;++o)i.appendChild(t[o]);return i}function i(e,t,r,i){var o=n(e,t,r,i);return o.setAttribute("role","presentation"),o}function o(e,t){if(3==t.nodeType&&(t=t.parentNode),e.contains)return e.contains(t);do{if(11==t.nodeType&&(t=t.host),t==e)return!0}while(t=t.parentNode)}function l(){var e;try{e=document.activeElement}catch(t){e=document.body||null}for(;e&&e.shadowRoot&&e.shadowRoot.activeElement;)e=e.shadowRoot.activeElement;return e}function s(t,r){var n=t.className;e(r).test(n)||(t.className+=(n?" ":"")+r)}function a(t,r){for(var n=t.split(" "),i=0;i<n.length;i++)n[i]&&!e(n[i]).test(r)&&(r+=" "+n[i]);return r}function u(e){var t=Array.prototype.slice.call(arguments,1);return function(){return e.apply(null,t)}}function c(e,t,r){t||(t={});for(var n in e)!e.hasOwnProperty(n)||!1===r&&t.hasOwnProperty(n)||(t[n]=e[n]);return t}function f(e,t,r,n,i){null==t&&-1==(t=e.search(/[^\s\u00a0]/))&&(t=e.length);for(var o=n||0,l=i||0;;){var s=e.indexOf("\t",o);if(s<0||s>=t)return l+(t-o);l+=s-o,l+=r-l%r,o=s+1}}function h(e,t){for(var r=0;r<e.length;++r)if(e[r]==t)return r;return-1}function d(e,t,r){for(var n=0,i=0;;){var o=e.indexOf("\t",n);-1==o&&(o=e.length);var l=o-n;if(o==e.length||i+l>=t)return n+Math.min(l,t-i);if(i+=o-n,i+=r-i%r,n=o+1,i>=t)return n}}function p(e){for(;Kl.length<=e;)Kl.push(g(Kl)+" ");return Kl[e]}function g(e){return e[e.length-1]}function v(e,t){for(var r=[],n=0;n<e.length;n++)r[n]=t(e[n],n);return r}function m(e,t,r){for(var n=0,i=r(t);n<e.length&&r(e[n])<=i;)n++;e.splice(n,0,t)}function y(){}function b(e,t){var r;return Object.create?r=Object.create(e):(y.prototype=e,r=new y),t&&c(t,r),r}function w(e){return/\w/.test(e)||e>""&&(e.toUpperCase()!=e.toLowerCase()||jl.test(e))}function x(e,t){return t?!!(t.source.indexOf("\\w")>-1&&w(e))||t.test(e):w(e)}function C(e){for(var t in e)if(e.hasOwnProperty(t)&&e[t])return!1;return!0}function S(e){return e.charCodeAt(0)>=768&&Xl.test(e)}function L(e,t,r){for(;(r<0?t>0:t<e.length)&&S(e.charAt(t));)t+=r;return t}function k(e,t,r){for(var n=t>r?-1:1;;){if(t==r)return t;var i=(t+r)/2,o=n<0?Math.ceil(i):Math.floor(i);if(o==t)return e(o)?t:r;e(o)?r=o:t=o+n}}function T(e,t,r){var o=this;this.input=r,o.scrollbarFiller=n("div",null,"CodeMirror-scrollbar-filler"),o.scrollbarFiller.setAttribute("cm-not-content","true"),o.gutterFiller=n("div",null,"CodeMirror-gutter-filler"),o.gutterFiller.setAttribute("cm-not-content","true"),o.lineDiv=i("div",null,"CodeMirror-code"),o.selectionDiv=n("div",null,null,"position: relative; z-index: 1"),o.cursorDiv=n("div",null,"CodeMirror-cursors"),o.measure=n("div",null,"CodeMirror-measure"),o.lineMeasure=n("div",null,"CodeMirror-measure"),o.lineSpace=i("div",[o.measure,o.lineMeasure,o.selectionDiv,o.cursorDiv,o.lineDiv],null,"position: relative; outline: none");var l=i("div",[o.lineSpace],"CodeMirror-lines");o.mover=n("div",[l],null,"position: relative"),o.sizer=n("div",[o.mover],"CodeMirror-sizer"),o.sizerWidth=null,o.heightForcer=n("div",null,null,"position: absolute; height: "+Rl+"px; width: 1px;"),o.gutters=n("div",null,"CodeMirror-gutters"),o.lineGutter=null,o.scroller=n("div",[o.sizer,o.heightForcer,o.gutters],"CodeMirror-scroll"),o.scroller.setAttribute("tabIndex","-1"),o.wrapper=n("div",[o.scrollbarFiller,o.gutterFiller,o.scroller],"CodeMirror"),gl&&vl<8&&(o.gutters.style.zIndex=-1,o.scroller.style.paddingRight=0),ml||fl&&Tl||(o.scroller.draggable=!0),e&&(e.appendChild?e.appendChild(o.wrapper):e(o.wrapper)),o.viewFrom=o.viewTo=t.first,o.reportedViewFrom=o.reportedViewTo=t.first,o.view=[],o.renderedView=null,o.externalMeasured=null,o.viewOffset=0,o.lastWrapHeight=o.lastWrapWidth=0,o.updateLineNumbers=null,o.nativeBarWidth=o.barHeight=o.barWidth=0,o.scrollbarsClipped=!1,o.lineNumWidth=o.lineNumInnerWidth=o.lineNumChars=null,o.alignWidgets=!1,o.cachedCharWidth=o.cachedTextHeight=o.cachedPaddingH=null,o.maxLine=null,o.maxLineLength=0,o.maxLineChanged=!1,o.wheelDX=o.wheelDY=o.wheelStartX=o.wheelStartY=null,o.shift=!1,o.selForContextMenu=null,o.activeTouch=null,r.init(o)}function M(e,t){if((t-=e.first)<0||t>=e.size)throw new Error("There is no line "+(t+e.first)+" in the document.");for(var r=e;!r.lines;)for(var n=0;;++n){var i=r.children[n],o=i.chunkSize();if(t<o){r=i;break}t-=o}return r.lines[t]}function N(e,t,r){var n=[],i=t.line;return e.iter(t.line,r.line+1,function(e){var o=e.text;i==r.line&&(o=o.slice(0,r.ch)),i==t.line&&(o=o.slice(t.ch)),n.push(o),++i}),n}function O(e,t,r){var n=[];return e.iter(t,r,function(e){n.push(e.text)}),n}function A(e,t){var r=t-e.height;if(r)for(var n=e;n;n=n.parent)n.height+=r}function W(e){if(null==e.parent)return null;for(var t=e.parent,r=h(t.lines,e),n=t.parent;n;t=n,n=n.parent)for(var i=0;n.children[i]!=t;++i)r+=n.children[i].chunkSize();return r+t.first}function D(e,t){var r=e.first;e:do{for(var n=0;n<e.children.length;++n){var i=e.children[n],o=i.height;if(t<o){e=i;continue e}t-=o,r+=i.chunkSize()}return r}while(!e.lines);for(var l=0;l<e.lines.length;++l){var s=e.lines[l].height;if(t<s)break;t-=s}return r+l}function H(e,t){return t>=e.first&&t<e.first+e.size}function F(e,t){return String(e.lineNumberFormatter(t+e.firstLineNumber))}function E(e,t,r){if(void 0===r&&(r=null),!(this instanceof E))return new E(e,t,r);this.line=e,this.ch=t,this.sticky=r}function P(e,t){return e.line-t.line||e.ch-t.ch}function I(e,t){return e.sticky==t.sticky&&0==P(e,t)}function z(e){return E(e.line,e.ch)}function R(e,t){return P(e,t)<0?t:e}function B(e,t){return P(e,t)<0?e:t}function G(e,t){return Math.max(e.first,Math.min(t,e.first+e.size-1))}function U(e,t){if(t.line<e.first)return E(e.first,0);var r=e.first+e.size-1;return t.line>r?E(r,M(e,r).text.length):V(t,M(e,t.line).text.length)}function V(e,t){var r=e.ch;return null==r||r>t?E(e.line,t):r<0?E(e.line,0):e}function K(e,t){for(var r=[],n=0;n<t.length;n++)r[n]=U(e,t[n]);return r}function j(){Yl=!0}function X(){_l=!0}function Y(e,t,r){this.marker=e,this.from=t,this.to=r}function _(e,t){if(e)for(var r=0;r<e.length;++r){var n=e[r];if(n.marker==t)return n}}function $(e,t){for(var r,n=0;n<e.length;++n)e[n]!=t&&(r||(r=[])).push(e[n]);return r}function q(e,t){e.markedSpans=e.markedSpans?e.markedSpans.concat([t]):[t],t.marker.attachLine(e)}function Z(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t)||o.from==t&&"bookmark"==l.type&&(!r||!o.marker.insertLeft)){var s=null==o.to||(l.inclusiveRight?o.to>=t:o.to>t);(n||(n=[])).push(new Y(l,o.from,s?null:o.to))}}return n}function Q(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.to||(l.inclusiveRight?o.to>=t:o.to>t)||o.from==t&&"bookmark"==l.type&&(!r||o.marker.insertLeft)){var s=null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t);(n||(n=[])).push(new Y(l,s?null:o.from-t,null==o.to?null:o.to-t))}}return n}function J(e,t){if(t.full)return null;var r=H(e,t.from.line)&&M(e,t.from.line).markedSpans,n=H(e,t.to.line)&&M(e,t.to.line).markedSpans;if(!r&&!n)return null;var i=t.from.ch,o=t.to.ch,l=0==P(t.from,t.to),s=Z(r,i,l),a=Q(n,o,l),u=1==t.text.length,c=g(t.text).length+(u?i:0);if(s)for(var f=0;f<s.length;++f){var h=s[f];if(null==h.to){var d=_(a,h.marker);d?u&&(h.to=null==d.to?null:d.to+c):h.to=i}}if(a)for(var p=0;p<a.length;++p){var v=a[p];null!=v.to&&(v.to+=c),null==v.from?_(s,v.marker)||(v.from=c,u&&(s||(s=[])).push(v)):(v.from+=c,u&&(s||(s=[])).push(v))}s&&(s=ee(s)),a&&a!=s&&(a=ee(a));var m=[s];if(!u){var y,b=t.text.length-2;if(b>0&&s)for(var w=0;w<s.length;++w)null==s[w].to&&(y||(y=[])).push(new Y(s[w].marker,null,null));for(var x=0;x<b;++x)m.push(y);m.push(a)}return m}function ee(e){for(var t=0;t<e.length;++t){var r=e[t];null!=r.from&&r.from==r.to&&!1!==r.marker.clearWhenEmpty&&e.splice(t--,1)}return e.length?e:null}function te(e,t,r){var n=null;if(e.iter(t.line,r.line+1,function(e){if(e.markedSpans)for(var t=0;t<e.markedSpans.length;++t){var r=e.markedSpans[t].marker;!r.readOnly||n&&-1!=h(n,r)||(n||(n=[])).push(r)}}),!n)return null;for(var i=[{from:t,to:r}],o=0;o<n.length;++o)for(var l=n[o],s=l.find(0),a=0;a<i.length;++a){var u=i[a];if(!(P(u.to,s.from)<0||P(u.from,s.to)>0)){var c=[a,1],f=P(u.from,s.from),d=P(u.to,s.to);(f<0||!l.inclusiveLeft&&!f)&&c.push({from:u.from,to:s.from}),(d>0||!l.inclusiveRight&&!d)&&c.push({from:s.to,to:u.to}),i.splice.apply(i,c),a+=c.length-3}}return i}function re(e){var t=e.markedSpans;if(t){for(var r=0;r<t.length;++r)t[r].marker.detachLine(e);e.markedSpans=null}}function ne(e,t){if(t){for(var r=0;r<t.length;++r)t[r].marker.attachLine(e);e.markedSpans=t}}function ie(e){return e.inclusiveLeft?-1:0}function oe(e){return e.inclusiveRight?1:0}function le(e,t){var r=e.lines.length-t.lines.length;if(0!=r)return r;var n=e.find(),i=t.find(),o=P(n.from,i.from)||ie(e)-ie(t);if(o)return-o;var l=P(n.to,i.to)||oe(e)-oe(t);return l||t.id-e.id}function se(e,t){var r,n=_l&&e.markedSpans;if(n)for(var i=void 0,o=0;o<n.length;++o)(i=n[o]).marker.collapsed&&null==(t?i.from:i.to)&&(!r||le(r,i.marker)<0)&&(r=i.marker);return r}function ae(e){return se(e,!0)}function ue(e){return se(e,!1)}function ce(e,t,r,n,i){var o=M(e,t),l=_l&&o.markedSpans;if(l)for(var s=0;s<l.length;++s){var a=l[s];if(a.marker.collapsed){var u=a.marker.find(0),c=P(u.from,r)||ie(a.marker)-ie(i),f=P(u.to,n)||oe(a.marker)-oe(i);if(!(c>=0&&f<=0||c<=0&&f>=0)&&(c<=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.to,r)>=0:P(u.to,r)>0)||c>=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.from,n)<=0:P(u.from,n)<0)))return!0}}}function fe(e){for(var t;t=ae(e);)e=t.find(-1,!0).line;return e}function he(e){for(var t;t=ue(e);)e=t.find(1,!0).line;return e}function de(e){for(var t,r;t=ue(e);)e=t.find(1,!0).line,(r||(r=[])).push(e);return r}function pe(e,t){var r=M(e,t),n=fe(r);return r==n?t:W(n)}function ge(e,t){if(t>e.lastLine())return t;var r,n=M(e,t);if(!ve(e,n))return t;for(;r=ue(n);)n=r.find(1,!0).line;return W(n)+1}function ve(e,t){var r=_l&&t.markedSpans;if(r)for(var n=void 0,i=0;i<r.length;++i)if((n=r[i]).marker.collapsed){if(null==n.from)return!0;if(!n.marker.widgetNode&&0==n.from&&n.marker.inclusiveLeft&&me(e,t,n))return!0}}function me(e,t,r){if(null==r.to){var n=r.marker.find(1,!0);return me(e,n.line,_(n.line.markedSpans,r.marker))}if(r.marker.inclusiveRight&&r.to==t.text.length)return!0;for(var i=void 0,o=0;o<t.markedSpans.length;++o)if((i=t.markedSpans[o]).marker.collapsed&&!i.marker.widgetNode&&i.from==r.to&&(null==i.to||i.to!=r.from)&&(i.marker.inclusiveLeft||r.marker.inclusiveRight)&&me(e,t,i))return!0}function ye(e){for(var t=0,r=(e=fe(e)).parent,n=0;n<r.lines.length;++n){var i=r.lines[n];if(i==e)break;t+=i.height}for(var o=r.parent;o;r=o,o=r.parent)for(var l=0;l<o.children.length;++l){var s=o.children[l];if(s==r)break;t+=s.height}return t}function be(e){if(0==e.height)return 0;for(var t,r=e.text.length,n=e;t=ae(n);){var i=t.find(0,!0);n=i.from.line,r+=i.from.ch-i.to.ch}for(n=e;t=ue(n);){var o=t.find(0,!0);r-=n.text.length-o.from.ch,r+=(n=o.to.line).text.length-o.to.ch}return r}function we(e){var t=e.display,r=e.doc;t.maxLine=M(r,r.first),t.maxLineLength=be(t.maxLine),t.maxLineChanged=!0,r.iter(function(e){var r=be(e);r>t.maxLineLength&&(t.maxLineLength=r,t.maxLine=e)})}function xe(e,t,r,n){if(!e)return n(t,r,"ltr",0);for(var i=!1,o=0;o<e.length;++o){var l=e[o];(l.from<r&&l.to>t||t==r&&l.to==t)&&(n(Math.max(l.from,t),Math.min(l.to,r),1==l.level?"rtl":"ltr",o),i=!0)}i||n(t,r,"ltr")}function Ce(e,t,r){var n;$l=null;for(var i=0;i<e.length;++i){var o=e[i];if(o.from<t&&o.to>t)return i;o.to==t&&(o.from!=o.to&&"before"==r?n=i:$l=i),o.from==t&&(o.from!=o.to&&"before"!=r?n=i:$l=i)}return null!=n?n:$l}function Se(e,t){var r=e.order;return null==r&&(r=e.order=ql(e.text,t)),r}function Le(e,t){return e._handlers&&e._handlers[t]||Zl}function ke(e,t,r){if(e.removeEventListener)e.removeEventListener(t,r,!1);else if(e.detachEvent)e.detachEvent("on"+t,r);else{var n=e._handlers,i=n&&n[t];if(i){var o=h(i,r);o>-1&&(n[t]=i.slice(0,o).concat(i.slice(o+1)))}}}function Te(e,t){var r=Le(e,t);if(r.length)for(var n=Array.prototype.slice.call(arguments,2),i=0;i<r.length;++i)r[i].apply(null,n)}function Me(e,t,r){return"string"==typeof t&&(t={type:t,preventDefault:function(){this.defaultPrevented=!0}}),Te(e,r||t.type,e,t),He(t)||t.codemirrorIgnore}function Ne(e){var t=e._handlers&&e._handlers.cursorActivity;if(t)for(var r=e.curOp.cursorActivityHandlers||(e.curOp.cursorActivityHandlers=[]),n=0;n<t.length;++n)-1==h(r,t[n])&&r.push(t[n])}function Oe(e,t){return Le(e,t).length>0}function Ae(e){e.prototype.on=function(e,t){Ql(this,e,t)},e.prototype.off=function(e,t){ke(this,e,t)}}function We(e){e.preventDefault?e.preventDefault():e.returnValue=!1}function De(e){e.stopPropagation?e.stopPropagation():e.cancelBubble=!0}function He(e){return null!=e.defaultPrevented?e.defaultPrevented:0==e.returnValue}function Fe(e){We(e),De(e)}function Ee(e){return e.target||e.srcElement}function Pe(e){var t=e.which;return null==t&&(1&e.button?t=1:2&e.button?t=3:4&e.button&&(t=2)),Ml&&e.ctrlKey&&1==t&&(t=3),t}function Ie(e){if(null==Il){var t=n("span","​");r(e,n("span",[t,document.createTextNode("x")])),0!=e.firstChild.offsetHeight&&(Il=t.offsetWidth<=1&&t.offsetHeight>2&&!(gl&&vl<8))}var i=Il?n("span","​"):n("span"," ",null,"display: inline-block; width: 1px; margin-right: -1px");return i.setAttribute("cm-text",""),i}function ze(e){if(null!=zl)return zl;var n=r(e,document.createTextNode("AخA")),i=Wl(n,0,1).getBoundingClientRect(),o=Wl(n,1,2).getBoundingClientRect();return t(e),!(!i||i.left==i.right)&&(zl=o.right-i.right<3)}function Re(e){if(null!=ns)return ns;var t=r(e,n("span","x")),i=t.getBoundingClientRect(),o=Wl(t,0,1).getBoundingClientRect();return ns=Math.abs(i.left-o.left)>1}function Be(e,t){arguments.length>2&&(t.dependencies=Array.prototype.slice.call(arguments,2)),is[e]=t}function Ge(e){if("string"==typeof e&&os.hasOwnProperty(e))e=os[e];else if(e&&"string"==typeof e.name&&os.hasOwnProperty(e.name)){var t=os[e.name];"string"==typeof t&&(t={name:t}),(e=b(t,e)).name=t.name}else{if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+xml$/.test(e))return Ge("application/xml");if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+json$/.test(e))return Ge("application/json")}return"string"==typeof e?{name:e}:e||{name:"null"}}function Ue(e,t){t=Ge(t);var r=is[t.name];if(!r)return Ue(e,"text/plain");var n=r(e,t);if(ls.hasOwnProperty(t.name)){var i=ls[t.name];for(var o in i)i.hasOwnProperty(o)&&(n.hasOwnProperty(o)&&(n["_"+o]=n[o]),n[o]=i[o])}if(n.name=t.name,t.helperType&&(n.helperType=t.helperType),t.modeProps)for(var l in t.modeProps)n[l]=t.modeProps[l];return n}function Ve(e,t){c(t,ls.hasOwnProperty(e)?ls[e]:ls[e]={})}function Ke(e,t){if(!0===t)return t;if(e.copyState)return e.copyState(t);var r={};for(var n in t){var i=t[n];i instanceof Array&&(i=i.concat([])),r[n]=i}return r}function je(e,t){for(var r;e.innerMode&&(r=e.innerMode(t))&&r.mode!=e;)t=r.state,e=r.mode;return r||{mode:e,state:t}}function Xe(e,t,r){return!e.startState||e.startState(t,r)}function Ye(e,t,r,n){var i=[e.state.modeGen],o={};tt(e,t.text,e.doc.mode,r,function(e,t){return i.push(e,t)},o,n);for(var l=r.state,s=0;s<e.state.overlays.length;++s)!function(n){var l=e.state.overlays[n],s=1,a=0;r.state=!0,tt(e,t.text,l.mode,r,function(e,t){for(var r=s;a<e;){var n=i[s];n>e&&i.splice(s,1,e,i[s+1],n),s+=2,a=Math.min(e,n)}if(t)if(l.opaque)i.splice(r,s-r,e,"overlay "+t),s=r+2;else for(;r<s;r+=2){var o=i[r+1];i[r+1]=(o?o+" ":"")+"overlay "+t}},o)}(s);return r.state=l,{styles:i,classes:o.bgClass||o.textClass?o:null}}function _e(e,t,r){if(!t.styles||t.styles[0]!=e.state.modeGen){var n=$e(e,W(t)),i=t.text.length>e.options.maxHighlightLength&&Ke(e.doc.mode,n.state),o=Ye(e,t,n);i&&(n.state=i),t.stateAfter=n.save(!i),t.styles=o.styles,o.classes?t.styleClasses=o.classes:t.styleClasses&&(t.styleClasses=null),r===e.doc.highlightFrontier&&(e.doc.modeFrontier=Math.max(e.doc.modeFrontier,++e.doc.highlightFrontier))}return t.styles}function $e(e,t,r){var n=e.doc,i=e.display;if(!n.mode.startState)return new us(n,!0,t);var o=rt(e,t,r),l=o>n.first&&M(n,o-1).stateAfter,s=l?us.fromSaved(n,l,o):new us(n,Xe(n.mode),o);return n.iter(o,t,function(r){qe(e,r.text,s);var n=s.line;r.stateAfter=n==t-1||n%5==0||n>=i.viewFrom&&n<i.viewTo?s.save():null,s.nextLine()}),r&&(n.modeFrontier=s.line),s}function qe(e,t,r,n){var i=e.doc.mode,o=new ss(t,e.options.tabSize,r);for(o.start=o.pos=n||0,""==t&&Ze(i,r.state);!o.eol();)Qe(i,o,r.state),o.start=o.pos}function Ze(e,t){if(e.blankLine)return e.blankLine(t);if(e.innerMode){var r=je(e,t);return r.mode.blankLine?r.mode.blankLine(r.state):void 0}}function Qe(e,t,r,n){for(var i=0;i<10;i++){n&&(n[0]=je(e,r).mode);var o=e.token(t,r);if(t.pos>t.start)return o}throw new Error("Mode "+e.name+" failed to advance stream.")}function Je(e,t,r,n){var i,o,l=e.doc,s=l.mode,a=M(l,(t=U(l,t)).line),u=$e(e,t.line,r),c=new ss(a.text,e.options.tabSize,u);for(n&&(o=[]);(n||c.pos<t.ch)&&!c.eol();)c.start=c.pos,i=Qe(s,c,u.state),n&&o.push(new cs(c,i,Ke(l.mode,u.state)));return n?o:new cs(c,i,u.state)}function et(e,t){if(e)for(;;){var r=e.match(/(?:^|\s+)line-(background-)?(\S+)/);if(!r)break;e=e.slice(0,r.index)+e.slice(r.index+r[0].length);var n=r[1]?"bgClass":"textClass";null==t[n]?t[n]=r[2]:new RegExp("(?:^|s)"+r[2]+"(?:$|s)").test(t[n])||(t[n]+=" "+r[2])}return e}function tt(e,t,r,n,i,o,l){var s=r.flattenSpans;null==s&&(s=e.options.flattenSpans);var a,u=0,c=null,f=new ss(t,e.options.tabSize,n),h=e.options.addModeClass&&[null];for(""==t&&et(Ze(r,n.state),o);!f.eol();){if(f.pos>e.options.maxHighlightLength?(s=!1,l&&qe(e,t,n,f.pos),f.pos=t.length,a=null):a=et(Qe(r,f,n.state,h),o),h){var d=h[0].name;d&&(a="m-"+(a?d+" "+a:d))}if(!s||c!=a){for(;u<f.start;)i(u=Math.min(f.start,u+5e3),c);c=a}f.start=f.pos}for(;u<f.pos;){var p=Math.min(f.pos,u+5e3);i(p,c),u=p}}function rt(e,t,r){for(var n,i,o=e.doc,l=r?-1:t-(e.doc.mode.innerMode?1e3:100),s=t;s>l;--s){if(s<=o.first)return o.first;var a=M(o,s-1),u=a.stateAfter;if(u&&(!r||s+(u instanceof as?u.lookAhead:0)<=o.modeFrontier))return s;var c=f(a.text,null,e.options.tabSize);(null==i||n>c)&&(i=s-1,n=c)}return i}function nt(e,t){if(e.modeFrontier=Math.min(e.modeFrontier,t),!(e.highlightFrontier<t-10)){for(var r=e.first,n=t-1;n>r;n--){var i=M(e,n).stateAfter;if(i&&(!(i instanceof as)||n+i.lookAhead<t)){r=n+1;break}}e.highlightFrontier=Math.min(e.highlightFrontier,r)}}function it(e,t,r,n){e.text=t,e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null),null!=e.order&&(e.order=null),re(e),ne(e,r);var i=n?n(e):1;i!=e.height&&A(e,i)}function ot(e){e.parent=null,re(e)}function lt(e,t){if(!e||/^\s*$/.test(e))return null;var r=t.addModeClass?ps:ds;return r[e]||(r[e]=e.replace(/\S+/g,"cm-$&"))}function st(e,t){var r=i("span",null,null,ml?"padding-right: .1px":null),n={pre:i("pre",[r],"CodeMirror-line"),content:r,col:0,pos:0,cm:e,trailingSpace:!1,splitSpaces:(gl||ml)&&e.getOption("lineWrapping")};t.measure={};for(var o=0;o<=(t.rest?t.rest.length:0);o++){var l=o?t.rest[o-1]:t.line,s=void 0;n.pos=0,n.addToken=ut,ze(e.display.measure)&&(s=Se(l,e.doc.direction))&&(n.addToken=ft(n.addToken,s)),n.map=[],dt(l,n,_e(e,l,t!=e.display.externalMeasured&&W(l))),l.styleClasses&&(l.styleClasses.bgClass&&(n.bgClass=a(l.styleClasses.bgClass,n.bgClass||"")),l.styleClasses.textClass&&(n.textClass=a(l.styleClasses.textClass,n.textClass||""))),0==n.map.length&&n.map.push(0,0,n.content.appendChild(Ie(e.display.measure))),0==o?(t.measure.map=n.map,t.measure.cache={}):((t.measure.maps||(t.measure.maps=[])).push(n.map),(t.measure.caches||(t.measure.caches=[])).push({}))}if(ml){var u=n.content.lastChild;(/\bcm-tab\b/.test(u.className)||u.querySelector&&u.querySelector(".cm-tab"))&&(n.content.className="cm-tab-wrap-hack")}return Te(e,"renderLine",e,t.line,n.pre),n.pre.className&&(n.textClass=a(n.pre.className,n.textClass||"")),n}function at(e){var t=n("span","•","cm-invalidchar");return t.title="\\u"+e.charCodeAt(0).toString(16),t.setAttribute("aria-label",t.title),t}function ut(e,t,r,i,o,l,s){if(t){var a,u=e.splitSpaces?ct(t,e.trailingSpace):t,c=e.cm.state.specialChars,f=!1;if(c.test(t)){a=document.createDocumentFragment();for(var h=0;;){c.lastIndex=h;var d=c.exec(t),g=d?d.index-h:t.length-h;if(g){var v=document.createTextNode(u.slice(h,h+g));gl&&vl<9?a.appendChild(n("span",[v])):a.appendChild(v),e.map.push(e.pos,e.pos+g,v),e.col+=g,e.pos+=g}if(!d)break;h+=g+1;var m=void 0;if("\t"==d[0]){var y=e.cm.options.tabSize,b=y-e.col%y;(m=a.appendChild(n("span",p(b),"cm-tab"))).setAttribute("role","presentation"),m.setAttribute("cm-text","\t"),e.col+=b}else"\r"==d[0]||"\n"==d[0]?((m=a.appendChild(n("span","\r"==d[0]?"␍":"␤","cm-invalidchar"))).setAttribute("cm-text",d[0]),e.col+=1):((m=e.cm.options.specialCharPlaceholder(d[0])).setAttribute("cm-text",d[0]),gl&&vl<9?a.appendChild(n("span",[m])):a.appendChild(m),e.col+=1);e.map.push(e.pos,e.pos+1,m),e.pos++}}else e.col+=t.length,a=document.createTextNode(u),e.map.push(e.pos,e.pos+t.length,a),gl&&vl<9&&(f=!0),e.pos+=t.length;if(e.trailingSpace=32==u.charCodeAt(t.length-1),r||i||o||f||s){var w=r||"";i&&(w+=i),o&&(w+=o);var x=n("span",[a],w,s);return l&&(x.title=l),e.content.appendChild(x)}e.content.appendChild(a)}}function ct(e,t){if(e.length>1&&!/  /.test(e))return e;for(var r=t,n="",i=0;i<e.length;i++){var o=e.charAt(i);" "!=o||!r||i!=e.length-1&&32!=e.charCodeAt(i+1)||(o=" "),n+=o,r=" "==o}return n}function ft(e,t){return function(r,n,i,o,l,s,a){i=i?i+" cm-force-border":"cm-force-border";for(var u=r.pos,c=u+n.length;;){for(var f=void 0,h=0;h<t.length&&!((f=t[h]).to>u&&f.from<=u);h++);if(f.to>=c)return e(r,n,i,o,l,s,a);e(r,n.slice(0,f.to-u),i,o,null,s,a),o=null,n=n.slice(f.to-u),u=f.to}}}function ht(e,t,r,n){var i=!n&&r.widgetNode;i&&e.map.push(e.pos,e.pos+t,i),!n&&e.cm.display.input.needsContentAttribute&&(i||(i=e.content.appendChild(document.createElement("span"))),i.setAttribute("cm-marker",r.id)),i&&(e.cm.display.input.setUneditable(i),e.content.appendChild(i)),e.pos+=t,e.trailingSpace=!1}function dt(e,t,r){var n=e.markedSpans,i=e.text,o=0;if(n)for(var l,s,a,u,c,f,h,d=i.length,p=0,g=1,v="",m=0;;){if(m==p){a=u=c=f=s="",h=null,m=1/0;for(var y=[],b=void 0,w=0;w<n.length;++w){var x=n[w],C=x.marker;"bookmark"==C.type&&x.from==p&&C.widgetNode?y.push(C):x.from<=p&&(null==x.to||x.to>p||C.collapsed&&x.to==p&&x.from==p)?(null!=x.to&&x.to!=p&&m>x.to&&(m=x.to,u=""),C.className&&(a+=" "+C.className),C.css&&(s=(s?s+";":"")+C.css),C.startStyle&&x.from==p&&(c+=" "+C.startStyle),C.endStyle&&x.to==m&&(b||(b=[])).push(C.endStyle,x.to),C.title&&!f&&(f=C.title),C.collapsed&&(!h||le(h.marker,C)<0)&&(h=x)):x.from>p&&m>x.from&&(m=x.from)}if(b)for(var S=0;S<b.length;S+=2)b[S+1]==m&&(u+=" "+b[S]);if(!h||h.from==p)for(var L=0;L<y.length;++L)ht(t,0,y[L]);if(h&&(h.from||0)==p){if(ht(t,(null==h.to?d+1:h.to)-p,h.marker,null==h.from),null==h.to)return;h.to==p&&(h=!1)}}if(p>=d)break;for(var k=Math.min(d,m);;){if(v){var T=p+v.length;if(!h){var M=T>k?v.slice(0,k-p):v;t.addToken(t,M,l?l+a:a,c,p+M.length==m?u:"",f,s)}if(T>=k){v=v.slice(k-p),p=k;break}p=T,c=""}v=i.slice(o,o=r[g++]),l=lt(r[g++],t.cm.options)}}else for(var N=1;N<r.length;N+=2)t.addToken(t,i.slice(o,o=r[N]),lt(r[N+1],t.cm.options))}function pt(e,t,r){this.line=t,this.rest=de(t),this.size=this.rest?W(g(this.rest))-r+1:1,this.node=this.text=null,this.hidden=ve(e,t)}function gt(e,t,r){for(var n,i=[],o=t;o<r;o=n){var l=new pt(e.doc,M(e.doc,o),o);n=o+l.size,i.push(l)}return i}function vt(e){gs?gs.ops.push(e):e.ownsGroup=gs={ops:[e],delayedCallbacks:[]}}function mt(e){var t=e.delayedCallbacks,r=0;do{for(;r<t.length;r++)t[r].call(null);for(var n=0;n<e.ops.length;n++){var i=e.ops[n];if(i.cursorActivityHandlers)for(;i.cursorActivityCalled<i.cursorActivityHandlers.length;)i.cursorActivityHandlers[i.cursorActivityCalled++].call(null,i.cm)}}while(r<t.length)}function yt(e,t){var r=e.ownsGroup;if(r)try{mt(r)}finally{gs=null,t(r)}}function bt(e,t){var r=Le(e,t);if(r.length){var n,i=Array.prototype.slice.call(arguments,2);gs?n=gs.delayedCallbacks:vs?n=vs:(n=vs=[],setTimeout(wt,0));for(var o=0;o<r.length;++o)!function(e){n.push(function(){return r[e].apply(null,i)})}(o)}}function wt(){var e=vs;vs=null;for(var t=0;t<e.length;++t)e[t]()}function xt(e,t,r,n){for(var i=0;i<t.changes.length;i++){var o=t.changes[i];"text"==o?kt(e,t):"gutter"==o?Mt(e,t,r,n):"class"==o?Tt(e,t):"widget"==o&&Nt(e,t,n)}t.changes=null}function Ct(e){return e.node==e.text&&(e.node=n("div",null,null,"position: relative"),e.text.parentNode&&e.text.parentNode.replaceChild(e.node,e.text),e.node.appendChild(e.text),gl&&vl<8&&(e.node.style.zIndex=2)),e.node}function St(e,t){var r=t.bgClass?t.bgClass+" "+(t.line.bgClass||""):t.line.bgClass;if(r&&(r+=" CodeMirror-linebackground"),t.background)r?t.background.className=r:(t.background.parentNode.removeChild(t.background),t.background=null);else if(r){var i=Ct(t);t.background=i.insertBefore(n("div",null,r),i.firstChild),e.display.input.setUneditable(t.background)}}function Lt(e,t){var r=e.display.externalMeasured;return r&&r.line==t.line?(e.display.externalMeasured=null,t.measure=r.measure,r.built):st(e,t)}function kt(e,t){var r=t.text.className,n=Lt(e,t);t.text==t.node&&(t.node=n.pre),t.text.parentNode.replaceChild(n.pre,t.text),t.text=n.pre,n.bgClass!=t.bgClass||n.textClass!=t.textClass?(t.bgClass=n.bgClass,t.textClass=n.textClass,Tt(e,t)):r&&(t.text.className=r)}function Tt(e,t){St(e,t),t.line.wrapClass?Ct(t).className=t.line.wrapClass:t.node!=t.text&&(t.node.className="");var r=t.textClass?t.textClass+" "+(t.line.textClass||""):t.line.textClass;t.text.className=r||""}function Mt(e,t,r,i){if(t.gutter&&(t.node.removeChild(t.gutter),t.gutter=null),t.gutterBackground&&(t.node.removeChild(t.gutterBackground),t.gutterBackground=null),t.line.gutterClass){var o=Ct(t);t.gutterBackground=n("div",null,"CodeMirror-gutter-background "+t.line.gutterClass,"left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px; width: "+i.gutterTotalWidth+"px"),e.display.input.setUneditable(t.gutterBackground),o.insertBefore(t.gutterBackground,t.text)}var l=t.line.gutterMarkers;if(e.options.lineNumbers||l){var s=Ct(t),a=t.gutter=n("div",null,"CodeMirror-gutter-wrapper","left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px");if(e.display.input.setUneditable(a),s.insertBefore(a,t.text),t.line.gutterClass&&(a.className+=" "+t.line.gutterClass),!e.options.lineNumbers||l&&l["CodeMirror-linenumbers"]||(t.lineNumber=a.appendChild(n("div",F(e.options,r),"CodeMirror-linenumber CodeMirror-gutter-elt","left: "+i.gutterLeft["CodeMirror-linenumbers"]+"px; width: "+e.display.lineNumInnerWidth+"px"))),l)for(var u=0;u<e.options.gutters.length;++u){var c=e.options.gutters[u],f=l.hasOwnProperty(c)&&l[c];f&&a.appendChild(n("div",[f],"CodeMirror-gutter-elt","left: "+i.gutterLeft[c]+"px; width: "+i.gutterWidth[c]+"px"))}}}function Nt(e,t,r){t.alignable&&(t.alignable=null);for(var n=t.node.firstChild,i=void 0;n;n=i)i=n.nextSibling,"CodeMirror-linewidget"==n.className&&t.node.removeChild(n);At(e,t,r)}function Ot(e,t,r,n){var i=Lt(e,t);return t.text=t.node=i.pre,i.bgClass&&(t.bgClass=i.bgClass),i.textClass&&(t.textClass=i.textClass),Tt(e,t),Mt(e,t,r,n),At(e,t,n),t.node}function At(e,t,r){if(Wt(e,t.line,t,r,!0),t.rest)for(var n=0;n<t.rest.length;n++)Wt(e,t.rest[n],t,r,!1)}function Wt(e,t,r,i,o){if(t.widgets)for(var l=Ct(r),s=0,a=t.widgets;s<a.length;++s){var u=a[s],c=n("div",[u.node],"CodeMirror-linewidget");u.handleMouseEvents||c.setAttribute("cm-ignore-events","true"),Dt(u,c,r,i),e.display.input.setUneditable(c),o&&u.above?l.insertBefore(c,r.gutter||r.text):l.appendChild(c),bt(u,"redraw")}}function Dt(e,t,r,n){if(e.noHScroll){(r.alignable||(r.alignable=[])).push(t);var i=n.wrapperWidth;t.style.left=n.fixedPos+"px",e.coverGutter||(i-=n.gutterTotalWidth,t.style.paddingLeft=n.gutterTotalWidth+"px"),t.style.width=i+"px"}e.coverGutter&&(t.style.zIndex=5,t.style.position="relative",e.noHScroll||(t.style.marginLeft=-n.gutterTotalWidth+"px"))}function Ht(e){if(null!=e.height)return e.height;var t=e.doc.cm;if(!t)return 0;if(!o(document.body,e.node)){var i="position: relative;";e.coverGutter&&(i+="margin-left: -"+t.display.gutters.offsetWidth+"px;"),e.noHScroll&&(i+="width: "+t.display.wrapper.clientWidth+"px;"),r(t.display.measure,n("div",[e.node],null,i))}return e.height=e.node.parentNode.offsetHeight}function Ft(e,t){for(var r=Ee(t);r!=e.wrapper;r=r.parentNode)if(!r||1==r.nodeType&&"true"==r.getAttribute("cm-ignore-events")||r.parentNode==e.sizer&&r!=e.mover)return!0}function Et(e){return e.lineSpace.offsetTop}function Pt(e){return e.mover.offsetHeight-e.lineSpace.offsetHeight}function It(e){if(e.cachedPaddingH)return e.cachedPaddingH;var t=r(e.measure,n("pre","x")),i=window.getComputedStyle?window.getComputedStyle(t):t.currentStyle,o={left:parseInt(i.paddingLeft),right:parseInt(i.paddingRight)};return isNaN(o.left)||isNaN(o.right)||(e.cachedPaddingH=o),o}function zt(e){return Rl-e.display.nativeBarWidth}function Rt(e){return e.display.scroller.clientWidth-zt(e)-e.display.barWidth}function Bt(e){return e.display.scroller.clientHeight-zt(e)-e.display.barHeight}function Gt(e,t,r){var n=e.options.lineWrapping,i=n&&Rt(e);if(!t.measure.heights||n&&t.measure.width!=i){var o=t.measure.heights=[];if(n){t.measure.width=i;for(var l=t.text.firstChild.getClientRects(),s=0;s<l.length-1;s++){var a=l[s],u=l[s+1];Math.abs(a.bottom-u.bottom)>2&&o.push((a.bottom+u.top)/2-r.top)}}o.push(r.bottom-r.top)}}function Ut(e,t,r){if(e.line==t)return{map:e.measure.map,cache:e.measure.cache};for(var n=0;n<e.rest.length;n++)if(e.rest[n]==t)return{map:e.measure.maps[n],cache:e.measure.caches[n]};for(var i=0;i<e.rest.length;i++)if(W(e.rest[i])>r)return{map:e.measure.maps[i],cache:e.measure.caches[i],before:!0}}function Vt(e,t){var n=W(t=fe(t)),i=e.display.externalMeasured=new pt(e.doc,t,n);i.lineN=n;var o=i.built=st(e,i);return i.text=o.pre,r(e.display.lineMeasure,o.pre),i}function Kt(e,t,r,n){return Yt(e,Xt(e,t),r,n)}function jt(e,t){if(t>=e.display.viewFrom&&t<e.display.viewTo)return e.display.view[Lr(e,t)];var r=e.display.externalMeasured;return r&&t>=r.lineN&&t<r.lineN+r.size?r:void 0}function Xt(e,t){var r=W(t),n=jt(e,r);n&&!n.text?n=null:n&&n.changes&&(xt(e,n,r,br(e)),e.curOp.forceUpdate=!0),n||(n=Vt(e,t));var i=Ut(n,t,r);return{line:t,view:n,rect:null,map:i.map,cache:i.cache,before:i.before,hasHeights:!1}}function Yt(e,t,r,n,i){t.before&&(r=-1);var o,l=r+(n||"");return t.cache.hasOwnProperty(l)?o=t.cache[l]:(t.rect||(t.rect=t.view.text.getBoundingClientRect()),t.hasHeights||(Gt(e,t.view,t.rect),t.hasHeights=!0),(o=qt(e,t,r,n)).bogus||(t.cache[l]=o)),{left:o.left,right:o.right,top:i?o.rtop:o.top,bottom:i?o.rbottom:o.bottom}}function _t(e,t,r){for(var n,i,o,l,s,a,u=0;u<e.length;u+=3)if(s=e[u],a=e[u+1],t<s?(i=0,o=1,l="left"):t<a?o=(i=t-s)+1:(u==e.length-3||t==a&&e[u+3]>t)&&(i=(o=a-s)-1,t>=a&&(l="right")),null!=i){if(n=e[u+2],s==a&&r==(n.insertLeft?"left":"right")&&(l=r),"left"==r&&0==i)for(;u&&e[u-2]==e[u-3]&&e[u-1].insertLeft;)n=e[2+(u-=3)],l="left";if("right"==r&&i==a-s)for(;u<e.length-3&&e[u+3]==e[u+4]&&!e[u+5].insertLeft;)n=e[(u+=3)+2],l="right";break}return{node:n,start:i,end:o,collapse:l,coverStart:s,coverEnd:a}}function $t(e,t){var r=ms;if("left"==t)for(var n=0;n<e.length&&(r=e[n]).left==r.right;n++);else for(var i=e.length-1;i>=0&&(r=e[i]).left==r.right;i--);return r}function qt(e,t,r,n){var i,o=_t(t.map,r,n),l=o.node,s=o.start,a=o.end,u=o.collapse;if(3==l.nodeType){for(var c=0;c<4;c++){for(;s&&S(t.line.text.charAt(o.coverStart+s));)--s;for(;o.coverStart+a<o.coverEnd&&S(t.line.text.charAt(o.coverStart+a));)++a;if((i=gl&&vl<9&&0==s&&a==o.coverEnd-o.coverStart?l.parentNode.getBoundingClientRect():$t(Wl(l,s,a).getClientRects(),n)).left||i.right||0==s)break;a=s,s-=1,u="right"}gl&&vl<11&&(i=Zt(e.display.measure,i))}else{s>0&&(u=n="right");var f;i=e.options.lineWrapping&&(f=l.getClientRects()).length>1?f["right"==n?f.length-1:0]:l.getBoundingClientRect()}if(gl&&vl<9&&!s&&(!i||!i.left&&!i.right)){var h=l.parentNode.getClientRects()[0];i=h?{left:h.left,right:h.left+yr(e.display),top:h.top,bottom:h.bottom}:ms}for(var d=i.top-t.rect.top,p=i.bottom-t.rect.top,g=(d+p)/2,v=t.view.measure.heights,m=0;m<v.length-1&&!(g<v[m]);m++);var y=m?v[m-1]:0,b=v[m],w={left:("right"==u?i.right:i.left)-t.rect.left,right:("left"==u?i.left:i.right)-t.rect.left,top:y,bottom:b};return i.left||i.right||(w.bogus=!0),e.options.singleCursorHeightPerLine||(w.rtop=d,w.rbottom=p),w}function Zt(e,t){if(!window.screen||null==screen.logicalXDPI||screen.logicalXDPI==screen.deviceXDPI||!Re(e))return t;var r=screen.logicalXDPI/screen.deviceXDPI,n=screen.logicalYDPI/screen.deviceYDPI;return{left:t.left*r,right:t.right*r,top:t.top*n,bottom:t.bottom*n}}function Qt(e){if(e.measure&&(e.measure.cache={},e.measure.heights=null,e.rest))for(var t=0;t<e.rest.length;t++)e.measure.caches[t]={}}function Jt(e){e.display.externalMeasure=null,t(e.display.lineMeasure);for(var r=0;r<e.display.view.length;r++)Qt(e.display.view[r])}function er(e){Jt(e),e.display.cachedCharWidth=e.display.cachedTextHeight=e.display.cachedPaddingH=null,e.options.lineWrapping||(e.display.maxLineChanged=!0),e.display.lineNumChars=null}function tr(){return bl&&kl?-(document.body.getBoundingClientRect().left-parseInt(getComputedStyle(document.body).marginLeft)):window.pageXOffset||(document.documentElement||document.body).scrollLeft}function rr(){return bl&&kl?-(document.body.getBoundingClientRect().top-parseInt(getComputedStyle(document.body).marginTop)):window.pageYOffset||(document.documentElement||document.body).scrollTop}function nr(e){var t=0;if(e.widgets)for(var r=0;r<e.widgets.length;++r)e.widgets[r].above&&(t+=Ht(e.widgets[r]));return t}function ir(e,t,r,n,i){if(!i){var o=nr(t);r.top+=o,r.bottom+=o}if("line"==n)return r;n||(n="local");var l=ye(t);if("local"==n?l+=Et(e.display):l-=e.display.viewOffset,"page"==n||"window"==n){var s=e.display.lineSpace.getBoundingClientRect();l+=s.top+("window"==n?0:rr());var a=s.left+("window"==n?0:tr());r.left+=a,r.right+=a}return r.top+=l,r.bottom+=l,r}function or(e,t,r){if("div"==r)return t;var n=t.left,i=t.top;if("page"==r)n-=tr(),i-=rr();else if("local"==r||!r){var o=e.display.sizer.getBoundingClientRect();n+=o.left,i+=o.top}var l=e.display.lineSpace.getBoundingClientRect();return{left:n-l.left,top:i-l.top}}function lr(e,t,r,n,i){return n||(n=M(e.doc,t.line)),ir(e,n,Kt(e,n,t.ch,i),r)}function sr(e,t,r,n,i,o){function l(t,l){var s=Yt(e,i,t,l?"right":"left",o);return l?s.left=s.right:s.right=s.left,ir(e,n,s,r)}function s(e,t,r){var n=1==a[t].level;return l(r?e-1:e,n!=r)}n=n||M(e.doc,t.line),i||(i=Xt(e,n));var a=Se(n,e.doc.direction),u=t.ch,c=t.sticky;if(u>=n.text.length?(u=n.text.length,c="before"):u<=0&&(u=0,c="after"),!a)return l("before"==c?u-1:u,"before"==c);var f=Ce(a,u,c),h=$l,d=s(u,f,"before"==c);return null!=h&&(d.other=s(u,h,"before"!=c)),d}function ar(e,t){var r=0;t=U(e.doc,t),e.options.lineWrapping||(r=yr(e.display)*t.ch);var n=M(e.doc,t.line),i=ye(n)+Et(e.display);return{left:r,right:r,top:i,bottom:i+n.height}}function ur(e,t,r,n,i){var o=E(e,t,r);return o.xRel=i,n&&(o.outside=!0),o}function cr(e,t,r){var n=e.doc;if((r+=e.display.viewOffset)<0)return ur(n.first,0,null,!0,-1);var i=D(n,r),o=n.first+n.size-1;if(i>o)return ur(n.first+n.size-1,M(n,o).text.length,null,!0,1);t<0&&(t=0);for(var l=M(n,i);;){var s=pr(e,l,i,t,r),a=ue(l),u=a&&a.find(0,!0);if(!a||!(s.ch>u.from.ch||s.ch==u.from.ch&&s.xRel>0))return s;i=W(l=u.to.line)}}function fr(e,t,r,n){n-=nr(t);var i=t.text.length,o=k(function(t){return Yt(e,r,t-1).bottom<=n},i,0);return i=k(function(t){return Yt(e,r,t).top>n},o,i),{begin:o,end:i}}function hr(e,t,r,n){return r||(r=Xt(e,t)),fr(e,t,r,ir(e,t,Yt(e,r,n),"line").top)}function dr(e,t,r,n){return!(e.bottom<=r)&&(e.top>r||(n?e.left:e.right)>t)}function pr(e,t,r,n,i){i-=ye(t);var o=Xt(e,t),l=nr(t),s=0,a=t.text.length,u=!0,c=Se(t,e.doc.direction);if(c){var f=(e.options.lineWrapping?vr:gr)(e,t,r,o,c,n,i);s=(u=1!=f.level)?f.from:f.to-1,a=u?f.to:f.from-1}var h,d,p=null,g=null,v=k(function(t){var r=Yt(e,o,t);return r.top+=l,r.bottom+=l,!!dr(r,n,i,!1)&&(r.top<=i&&r.left<=n&&(p=t,g=r),!0)},s,a),m=!1;if(g){var y=n-g.left<g.right-n,b=y==u;v=p+(b?0:1),d=b?"after":"before",h=y?g.left:g.right}else{u||v!=a&&v!=s||v++,d=0==v?"after":v==t.text.length?"before":Yt(e,o,v-(u?1:0)).bottom+l<=i==u?"after":"before";var w=sr(e,E(r,v,d),"line",t,o);h=w.left,m=i<w.top||i>=w.bottom}return v=L(t.text,v,1),ur(r,v,d,m,n-h)}function gr(e,t,r,n,i,o,l){var s=k(function(s){var a=i[s],u=1!=a.level;return dr(sr(e,E(r,u?a.to:a.from,u?"before":"after"),"line",t,n),o,l,!0)},0,i.length-1),a=i[s];if(s>0){var u=1!=a.level,c=sr(e,E(r,u?a.from:a.to,u?"after":"before"),"line",t,n);dr(c,o,l,!0)&&c.top>l&&(a=i[s-1])}return a}function vr(e,t,r,n,i,o,l){for(var s=fr(e,t,n,l),a=s.begin,u=s.end,c=null,f=null,h=0;h<i.length;h++){var d=i[h];if(!(d.from>=u||d.to<=a)){var p=Yt(e,n,1!=d.level?Math.min(u,d.to)-1:Math.max(a,d.from)).right,g=p<o?o-p+1e9:p-o;(!c||f>g)&&(c=d,f=g)}}return c||(c=i[i.length-1]),c.from<a&&(c={from:a,to:c.to,level:c.level}),c.to>u&&(c={from:c.from,to:u,level:c.level}),c}function mr(e){if(null!=e.cachedTextHeight)return e.cachedTextHeight;if(null==hs){hs=n("pre");for(var i=0;i<49;++i)hs.appendChild(document.createTextNode("x")),hs.appendChild(n("br"));hs.appendChild(document.createTextNode("x"))}r(e.measure,hs);var o=hs.offsetHeight/50;return o>3&&(e.cachedTextHeight=o),t(e.measure),o||1}function yr(e){if(null!=e.cachedCharWidth)return e.cachedCharWidth;var t=n("span","xxxxxxxxxx"),i=n("pre",[t]);r(e.measure,i);var o=t.getBoundingClientRect(),l=(o.right-o.left)/10;return l>2&&(e.cachedCharWidth=l),l||10}function br(e){for(var t=e.display,r={},n={},i=t.gutters.clientLeft,o=t.gutters.firstChild,l=0;o;o=o.nextSibling,++l)r[e.options.gutters[l]]=o.offsetLeft+o.clientLeft+i,n[e.options.gutters[l]]=o.clientWidth;return{fixedPos:wr(t),gutterTotalWidth:t.gutters.offsetWidth,gutterLeft:r,gutterWidth:n,wrapperWidth:t.wrapper.clientWidth}}function wr(e){return e.scroller.getBoundingClientRect().left-e.sizer.getBoundingClientRect().left}function xr(e){var t=mr(e.display),r=e.options.lineWrapping,n=r&&Math.max(5,e.display.scroller.clientWidth/yr(e.display)-3);return function(i){if(ve(e.doc,i))return 0;var o=0;if(i.widgets)for(var l=0;l<i.widgets.length;l++)i.widgets[l].height&&(o+=i.widgets[l].height);return r?o+(Math.ceil(i.text.length/n)||1)*t:o+t}}function Cr(e){var t=e.doc,r=xr(e);t.iter(function(e){var t=r(e);t!=e.height&&A(e,t)})}function Sr(e,t,r,n){var i=e.display;if(!r&&"true"==Ee(t).getAttribute("cm-not-content"))return null;var o,l,s=i.lineSpace.getBoundingClientRect();try{o=t.clientX-s.left,l=t.clientY-s.top}catch(t){return null}var a,u=cr(e,o,l);if(n&&1==u.xRel&&(a=M(e.doc,u.line).text).length==u.ch){var c=f(a,a.length,e.options.tabSize)-a.length;u=E(u.line,Math.max(0,Math.round((o-It(e.display).left)/yr(e.display))-c))}return u}function Lr(e,t){if(t>=e.display.viewTo)return null;if((t-=e.display.viewFrom)<0)return null;for(var r=e.display.view,n=0;n<r.length;n++)if((t-=r[n].size)<0)return n}function kr(e){e.display.input.showSelection(e.display.input.prepareSelection())}function Tr(e,t){void 0===t&&(t=!0);for(var r=e.doc,n={},i=n.cursors=document.createDocumentFragment(),o=n.selection=document.createDocumentFragment(),l=0;l<r.sel.ranges.length;l++)if(t||l!=r.sel.primIndex){var s=r.sel.ranges[l];if(!(s.from().line>=e.display.viewTo||s.to().line<e.display.viewFrom)){var a=s.empty();(a||e.options.showCursorWhenSelecting)&&Mr(e,s.head,i),a||Or(e,s,o)}}return n}function Mr(e,t,r){var i=sr(e,t,"div",null,null,!e.options.singleCursorHeightPerLine),o=r.appendChild(n("div"," ","CodeMirror-cursor"));if(o.style.left=i.left+"px",o.style.top=i.top+"px",o.style.height=Math.max(0,i.bottom-i.top)*e.options.cursorHeight+"px",i.other){var l=r.appendChild(n("div"," ","CodeMirror-cursor CodeMirror-secondarycursor"));l.style.display="",l.style.left=i.other.left+"px",l.style.top=i.other.top+"px",l.style.height=.85*(i.other.bottom-i.other.top)+"px"}}function Nr(e,t){return e.top-t.top||e.left-t.left}function Or(e,t,r){function i(e,t,r,i){t<0&&(t=0),t=Math.round(t),i=Math.round(i),a.appendChild(n("div",null,"CodeMirror-selected","position: absolute; left: "+e+"px;\n                             top: "+t+"px; width: "+(null==r?f-e:r)+"px;\n                             height: "+(i-t)+"px"))}function o(t,r,n){function o(r,n){return lr(e,E(t,r),"div",u,n)}var l,a,u=M(s,t),h=u.text.length,d=Se(u,s.direction);return xe(d,r||0,null==n?h:n,function(t,s,p,g){var v=o(t,"ltr"==p?"left":"right"),m=o(s-1,"ltr"==p?"right":"left");if("ltr"==p){var y=null==r&&0==t?c:v.left,b=null==n&&s==h?f:m.right;m.top-v.top<=3?i(y,m.top,b-y,m.bottom):(i(y,v.top,null,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top),i(c,m.top,m.right,m.bottom))}else if(t<s){var w=null==r&&0==t?f:v.right,x=null==n&&s==h?c:m.left;if(m.top-v.top<=3)i(x,m.top,w-x,m.bottom);else{var C=c;if(g){var S=hr(e,u,null,t).end;C=o(S-(/\s/.test(u.text.charAt(S-1))?2:1),"left").left}i(C,v.top,w-C,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top);var L=null;d.length,L=o(hr(e,u,null,s).begin,"right").right-x,i(x,m.top,L,m.bottom)}}(!l||Nr(v,l)<0)&&(l=v),Nr(m,l)<0&&(l=m),(!a||Nr(v,a)<0)&&(a=v),Nr(m,a)<0&&(a=m)}),{start:l,end:a}}var l=e.display,s=e.doc,a=document.createDocumentFragment(),u=It(e.display),c=u.left,f=Math.max(l.sizerWidth,Rt(e)-l.sizer.offsetLeft)-u.right,h=t.from(),d=t.to();if(h.line==d.line)o(h.line,h.ch,d.ch);else{var p=M(s,h.line),g=M(s,d.line),v=fe(p)==fe(g),m=o(h.line,h.ch,v?p.text.length+1:null).end,y=o(d.line,v?0:null,d.ch).start;v&&(m.top<y.top-2?(i(m.right,m.top,null,m.bottom),i(c,y.top,y.left,y.bottom)):i(m.right,m.top,y.left-m.right,m.bottom)),m.bottom<y.top&&i(c,m.bottom,null,y.top)}r.appendChild(a)}function Ar(e){if(e.state.focused){var t=e.display;clearInterval(t.blinker);var r=!0;t.cursorDiv.style.visibility="",e.options.cursorBlinkRate>0?t.blinker=setInterval(function(){return t.cursorDiv.style.visibility=(r=!r)?"":"hidden"},e.options.cursorBlinkRate):e.options.cursorBlinkRate<0&&(t.cursorDiv.style.visibility="hidden")}}function Wr(e){e.state.focused||(e.display.input.focus(),Hr(e))}function Dr(e){e.state.delayingBlurEvent=!0,setTimeout(function(){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1,Fr(e))},100)}function Hr(e,t){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1),"nocursor"!=e.options.readOnly&&(e.state.focused||(Te(e,"focus",e,t),e.state.focused=!0,s(e.display.wrapper,"CodeMirror-focused"),e.curOp||e.display.selForContextMenu==e.doc.sel||(e.display.input.reset(),ml&&setTimeout(function(){return e.display.input.reset(!0)},20)),e.display.input.receivedFocus()),Ar(e))}function Fr(e,t){e.state.delayingBlurEvent||(e.state.focused&&(Te(e,"blur",e,t),e.state.focused=!1,Fl(e.display.wrapper,"CodeMirror-focused")),clearInterval(e.display.blinker),setTimeout(function(){e.state.focused||(e.display.shift=!1)},150))}function Er(e){for(var t=e.display,r=t.lineDiv.offsetTop,n=0;n<t.view.length;n++){var i=t.view[n],o=void 0;if(!i.hidden){if(gl&&vl<8){var l=i.node.offsetTop+i.node.offsetHeight;o=l-r,r=l}else{var s=i.node.getBoundingClientRect();o=s.bottom-s.top}var a=i.line.height-o;if(o<2&&(o=mr(t)),(a>.005||a<-.005)&&(A(i.line,o),Pr(i.line),i.rest))for(var u=0;u<i.rest.length;u++)Pr(i.rest[u])}}}function Pr(e){if(e.widgets)for(var t=0;t<e.widgets.length;++t)e.widgets[t].height=e.widgets[t].node.parentNode.offsetHeight}function Ir(e,t,r){var n=r&&null!=r.top?Math.max(0,r.top):e.scroller.scrollTop;n=Math.floor(n-Et(e));var i=r&&null!=r.bottom?r.bottom:n+e.wrapper.clientHeight,o=D(t,n),l=D(t,i);if(r&&r.ensure){var s=r.ensure.from.line,a=r.ensure.to.line;s<o?(o=s,l=D(t,ye(M(t,s))+e.wrapper.clientHeight)):Math.min(a,t.lastLine())>=l&&(o=D(t,ye(M(t,a))-e.wrapper.clientHeight),l=a)}return{from:o,to:Math.max(l,o+1)}}function zr(e){var t=e.display,r=t.view;if(t.alignWidgets||t.gutters.firstChild&&e.options.fixedGutter){for(var n=wr(t)-t.scroller.scrollLeft+e.doc.scrollLeft,i=t.gutters.offsetWidth,o=n+"px",l=0;l<r.length;l++)if(!r[l].hidden){e.options.fixedGutter&&(r[l].gutter&&(r[l].gutter.style.left=o),r[l].gutterBackground&&(r[l].gutterBackground.style.left=o));var s=r[l].alignable;if(s)for(var a=0;a<s.length;a++)s[a].style.left=o}e.options.fixedGutter&&(t.gutters.style.left=n+i+"px")}}function Rr(e){if(!e.options.lineNumbers)return!1;var t=e.doc,r=F(e.options,t.first+t.size-1),i=e.display;if(r.length!=i.lineNumChars){var o=i.measure.appendChild(n("div",[n("div",r)],"CodeMirror-linenumber CodeMirror-gutter-elt")),l=o.firstChild.offsetWidth,s=o.offsetWidth-l;return i.lineGutter.style.width="",i.lineNumInnerWidth=Math.max(l,i.lineGutter.offsetWidth-s)+1,i.lineNumWidth=i.lineNumInnerWidth+s,i.lineNumChars=i.lineNumInnerWidth?r.length:-1,i.lineGutter.style.width=i.lineNumWidth+"px",Wn(e),!0}return!1}function Br(e,t){if(!Me(e,"scrollCursorIntoView")){var r=e.display,i=r.sizer.getBoundingClientRect(),o=null;if(t.top+i.top<0?o=!0:t.bottom+i.top>(window.innerHeight||document.documentElement.clientHeight)&&(o=!1),null!=o&&!Sl){var l=n("div","​",null,"position: absolute;\n                         top: "+(t.top-r.viewOffset-Et(e.display))+"px;\n                         height: "+(t.bottom-t.top+zt(e)+r.barHeight)+"px;\n                         left: "+t.left+"px; width: "+Math.max(2,t.right-t.left)+"px;");e.display.lineSpace.appendChild(l),l.scrollIntoView(o),e.display.lineSpace.removeChild(l)}}}function Gr(e,t,r,n){null==n&&(n=0);var i;e.options.lineWrapping||t!=r||(r="before"==(t=t.ch?E(t.line,"before"==t.sticky?t.ch-1:t.ch,"after"):t).sticky?E(t.line,t.ch+1,"before"):t);for(var o=0;o<5;o++){var l=!1,s=sr(e,t),a=r&&r!=t?sr(e,r):s,u=Vr(e,i={left:Math.min(s.left,a.left),top:Math.min(s.top,a.top)-n,right:Math.max(s.left,a.left),bottom:Math.max(s.bottom,a.bottom)+n}),c=e.doc.scrollTop,f=e.doc.scrollLeft;if(null!=u.scrollTop&&(qr(e,u.scrollTop),Math.abs(e.doc.scrollTop-c)>1&&(l=!0)),null!=u.scrollLeft&&(Qr(e,u.scrollLeft),Math.abs(e.doc.scrollLeft-f)>1&&(l=!0)),!l)break}return i}function Ur(e,t){var r=Vr(e,t);null!=r.scrollTop&&qr(e,r.scrollTop),null!=r.scrollLeft&&Qr(e,r.scrollLeft)}function Vr(e,t){var r=e.display,n=mr(e.display);t.top<0&&(t.top=0);var i=e.curOp&&null!=e.curOp.scrollTop?e.curOp.scrollTop:r.scroller.scrollTop,o=Bt(e),l={};t.bottom-t.top>o&&(t.bottom=t.top+o);var s=e.doc.height+Pt(r),a=t.top<n,u=t.bottom>s-n;if(t.top<i)l.scrollTop=a?0:t.top;else if(t.bottom>i+o){var c=Math.min(t.top,(u?s:t.bottom)-o);c!=i&&(l.scrollTop=c)}var f=e.curOp&&null!=e.curOp.scrollLeft?e.curOp.scrollLeft:r.scroller.scrollLeft,h=Rt(e)-(e.options.fixedGutter?r.gutters.offsetWidth:0),d=t.right-t.left>h;return d&&(t.right=t.left+h),t.left<10?l.scrollLeft=0:t.left<f?l.scrollLeft=Math.max(0,t.left-(d?0:10)):t.right>h+f-3&&(l.scrollLeft=t.right+(d?0:10)-h),l}function Kr(e,t){null!=t&&(_r(e),e.curOp.scrollTop=(null==e.curOp.scrollTop?e.doc.scrollTop:e.curOp.scrollTop)+t)}function jr(e){_r(e);var t=e.getCursor();e.curOp.scrollToPos={from:t,to:t,margin:e.options.cursorScrollMargin}}function Xr(e,t,r){null==t&&null==r||_r(e),null!=t&&(e.curOp.scrollLeft=t),null!=r&&(e.curOp.scrollTop=r)}function Yr(e,t){_r(e),e.curOp.scrollToPos=t}function _r(e){var t=e.curOp.scrollToPos;t&&(e.curOp.scrollToPos=null,$r(e,ar(e,t.from),ar(e,t.to),t.margin))}function $r(e,t,r,n){var i=Vr(e,{left:Math.min(t.left,r.left),top:Math.min(t.top,r.top)-n,right:Math.max(t.right,r.right),bottom:Math.max(t.bottom,r.bottom)+n});Xr(e,i.scrollLeft,i.scrollTop)}function qr(e,t){Math.abs(e.doc.scrollTop-t)<2||(fl||On(e,{top:t}),Zr(e,t,!0),fl&&On(e),Cn(e,100))}function Zr(e,t,r){t=Math.min(e.display.scroller.scrollHeight-e.display.scroller.clientHeight,t),(e.display.scroller.scrollTop!=t||r)&&(e.doc.scrollTop=t,e.display.scrollbars.setScrollTop(t),e.display.scroller.scrollTop!=t&&(e.display.scroller.scrollTop=t))}function Qr(e,t,r,n){t=Math.min(t,e.display.scroller.scrollWidth-e.display.scroller.clientWidth),(r?t==e.doc.scrollLeft:Math.abs(e.doc.scrollLeft-t)<2)&&!n||(e.doc.scrollLeft=t,zr(e),e.display.scroller.scrollLeft!=t&&(e.display.scroller.scrollLeft=t),e.display.scrollbars.setScrollLeft(t))}function Jr(e){var t=e.display,r=t.gutters.offsetWidth,n=Math.round(e.doc.height+Pt(e.display));return{clientHeight:t.scroller.clientHeight,viewHeight:t.wrapper.clientHeight,scrollWidth:t.scroller.scrollWidth,clientWidth:t.scroller.clientWidth,viewWidth:t.wrapper.clientWidth,barLeft:e.options.fixedGutter?r:0,docHeight:n,scrollHeight:n+zt(e)+t.barHeight,nativeBarWidth:t.nativeBarWidth,gutterWidth:r}}function en(e,t){t||(t=Jr(e));var r=e.display.barWidth,n=e.display.barHeight;tn(e,t);for(var i=0;i<4&&r!=e.display.barWidth||n!=e.display.barHeight;i++)r!=e.display.barWidth&&e.options.lineWrapping&&Er(e),tn(e,Jr(e)),r=e.display.barWidth,n=e.display.barHeight}function tn(e,t){var r=e.display,n=r.scrollbars.update(t);r.sizer.style.paddingRight=(r.barWidth=n.right)+"px",r.sizer.style.paddingBottom=(r.barHeight=n.bottom)+"px",r.heightForcer.style.borderBottom=n.bottom+"px solid transparent",n.right&&n.bottom?(r.scrollbarFiller.style.display="block",r.scrollbarFiller.style.height=n.bottom+"px",r.scrollbarFiller.style.width=n.right+"px"):r.scrollbarFiller.style.display="",n.bottom&&e.options.coverGutterNextToScrollbar&&e.options.fixedGutter?(r.gutterFiller.style.display="block",r.gutterFiller.style.height=n.bottom+"px",r.gutterFiller.style.width=t.gutterWidth+"px"):r.gutterFiller.style.display=""}function rn(e){e.display.scrollbars&&(e.display.scrollbars.clear(),e.display.scrollbars.addClass&&Fl(e.display.wrapper,e.display.scrollbars.addClass)),e.display.scrollbars=new ws[e.options.scrollbarStyle](function(t){e.display.wrapper.insertBefore(t,e.display.scrollbarFiller),Ql(t,"mousedown",function(){e.state.focused&&setTimeout(function(){return e.display.input.focus()},0)}),t.setAttribute("cm-not-content","true")},function(t,r){"horizontal"==r?Qr(e,t):qr(e,t)},e),e.display.scrollbars.addClass&&s(e.display.wrapper,e.display.scrollbars.addClass)}function nn(e){e.curOp={cm:e,viewChanged:!1,startHeight:e.doc.height,forceUpdate:!1,updateInput:null,typing:!1,changeObjs:null,cursorActivityHandlers:null,cursorActivityCalled:0,selectionChanged:!1,updateMaxLine:!1,scrollLeft:null,scrollTop:null,scrollToPos:null,focus:!1,id:++xs},vt(e.curOp)}function on(e){yt(e.curOp,function(e){for(var t=0;t<e.ops.length;t++)e.ops[t].cm.curOp=null;ln(e)})}function ln(e){for(var t=e.ops,r=0;r<t.length;r++)sn(t[r]);for(var n=0;n<t.length;n++)an(t[n]);for(var i=0;i<t.length;i++)un(t[i]);for(var o=0;o<t.length;o++)cn(t[o]);for(var l=0;l<t.length;l++)fn(t[l])}function sn(e){var t=e.cm,r=t.display;Ln(t),e.updateMaxLine&&we(t),e.mustUpdate=e.viewChanged||e.forceUpdate||null!=e.scrollTop||e.scrollToPos&&(e.scrollToPos.from.line<r.viewFrom||e.scrollToPos.to.line>=r.viewTo)||r.maxLineChanged&&t.options.lineWrapping,e.update=e.mustUpdate&&new Cs(t,e.mustUpdate&&{top:e.scrollTop,ensure:e.scrollToPos},e.forceUpdate)}function an(e){e.updatedDisplay=e.mustUpdate&&Mn(e.cm,e.update)}function un(e){var t=e.cm,r=t.display;e.updatedDisplay&&Er(t),e.barMeasure=Jr(t),r.maxLineChanged&&!t.options.lineWrapping&&(e.adjustWidthTo=Kt(t,r.maxLine,r.maxLine.text.length).left+3,t.display.sizerWidth=e.adjustWidthTo,e.barMeasure.scrollWidth=Math.max(r.scroller.clientWidth,r.sizer.offsetLeft+e.adjustWidthTo+zt(t)+t.display.barWidth),e.maxScrollLeft=Math.max(0,r.sizer.offsetLeft+e.adjustWidthTo-Rt(t))),(e.updatedDisplay||e.selectionChanged)&&(e.preparedSelection=r.input.prepareSelection())}function cn(e){var t=e.cm;null!=e.adjustWidthTo&&(t.display.sizer.style.minWidth=e.adjustWidthTo+"px",e.maxScrollLeft<t.doc.scrollLeft&&Qr(t,Math.min(t.display.scroller.scrollLeft,e.maxScrollLeft),!0),t.display.maxLineChanged=!1);var r=e.focus&&e.focus==l();e.preparedSelection&&t.display.input.showSelection(e.preparedSelection,r),(e.updatedDisplay||e.startHeight!=t.doc.height)&&en(t,e.barMeasure),e.updatedDisplay&&Dn(t,e.barMeasure),e.selectionChanged&&Ar(t),t.state.focused&&e.updateInput&&t.display.input.reset(e.typing),r&&Wr(e.cm)}function fn(e){var t=e.cm,r=t.display,n=t.doc;e.updatedDisplay&&Nn(t,e.update),null==r.wheelStartX||null==e.scrollTop&&null==e.scrollLeft&&!e.scrollToPos||(r.wheelStartX=r.wheelStartY=null),null!=e.scrollTop&&Zr(t,e.scrollTop,e.forceScroll),null!=e.scrollLeft&&Qr(t,e.scrollLeft,!0,!0),e.scrollToPos&&Br(t,Gr(t,U(n,e.scrollToPos.from),U(n,e.scrollToPos.to),e.scrollToPos.margin));var i=e.maybeHiddenMarkers,o=e.maybeUnhiddenMarkers;if(i)for(var l=0;l<i.length;++l)i[l].lines.length||Te(i[l],"hide");if(o)for(var s=0;s<o.length;++s)o[s].lines.length&&Te(o[s],"unhide");r.wrapper.offsetHeight&&(n.scrollTop=t.display.scroller.scrollTop),e.changeObjs&&Te(t,"changes",t,e.changeObjs),e.update&&e.update.finish()}function hn(e,t){if(e.curOp)return t();nn(e);try{return t()}finally{on(e)}}function dn(e,t){return function(){if(e.curOp)return t.apply(e,arguments);nn(e);try{return t.apply(e,arguments)}finally{on(e)}}}function pn(e){return function(){if(this.curOp)return e.apply(this,arguments);nn(this);try{return e.apply(this,arguments)}finally{on(this)}}}function gn(e){return function(){var t=this.cm;if(!t||t.curOp)return e.apply(this,arguments);nn(t);try{return e.apply(this,arguments)}finally{on(t)}}}function vn(e,t,r,n){null==t&&(t=e.doc.first),null==r&&(r=e.doc.first+e.doc.size),n||(n=0);var i=e.display;if(n&&r<i.viewTo&&(null==i.updateLineNumbers||i.updateLineNumbers>t)&&(i.updateLineNumbers=t),e.curOp.viewChanged=!0,t>=i.viewTo)_l&&pe(e.doc,t)<i.viewTo&&yn(e);else if(r<=i.viewFrom)_l&&ge(e.doc,r+n)>i.viewFrom?yn(e):(i.viewFrom+=n,i.viewTo+=n);else if(t<=i.viewFrom&&r>=i.viewTo)yn(e);else if(t<=i.viewFrom){var o=bn(e,r,r+n,1);o?(i.view=i.view.slice(o.index),i.viewFrom=o.lineN,i.viewTo+=n):yn(e)}else if(r>=i.viewTo){var l=bn(e,t,t,-1);l?(i.view=i.view.slice(0,l.index),i.viewTo=l.lineN):yn(e)}else{var s=bn(e,t,t,-1),a=bn(e,r,r+n,1);s&&a?(i.view=i.view.slice(0,s.index).concat(gt(e,s.lineN,a.lineN)).concat(i.view.slice(a.index)),i.viewTo+=n):yn(e)}var u=i.externalMeasured;u&&(r<u.lineN?u.lineN+=n:t<u.lineN+u.size&&(i.externalMeasured=null))}function mn(e,t,r){e.curOp.viewChanged=!0;var n=e.display,i=e.display.externalMeasured;if(i&&t>=i.lineN&&t<i.lineN+i.size&&(n.externalMeasured=null),!(t<n.viewFrom||t>=n.viewTo)){var o=n.view[Lr(e,t)];if(null!=o.node){var l=o.changes||(o.changes=[]);-1==h(l,r)&&l.push(r)}}}function yn(e){e.display.viewFrom=e.display.viewTo=e.doc.first,e.display.view=[],e.display.viewOffset=0}function bn(e,t,r,n){var i,o=Lr(e,t),l=e.display.view;if(!_l||r==e.doc.first+e.doc.size)return{index:o,lineN:r};for(var s=e.display.viewFrom,a=0;a<o;a++)s+=l[a].size;if(s!=t){if(n>0){if(o==l.length-1)return null;i=s+l[o].size-t,o++}else i=s-t;t+=i,r+=i}for(;pe(e.doc,r)!=r;){if(o==(n<0?0:l.length-1))return null;r+=n*l[o-(n<0?1:0)].size,o+=n}return{index:o,lineN:r}}function wn(e,t,r){var n=e.display;0==n.view.length||t>=n.viewTo||r<=n.viewFrom?(n.view=gt(e,t,r),n.viewFrom=t):(n.viewFrom>t?n.view=gt(e,t,n.viewFrom).concat(n.view):n.viewFrom<t&&(n.view=n.view.slice(Lr(e,t))),n.viewFrom=t,n.viewTo<r?n.view=n.view.concat(gt(e,n.viewTo,r)):n.viewTo>r&&(n.view=n.view.slice(0,Lr(e,r)))),n.viewTo=r}function xn(e){for(var t=e.display.view,r=0,n=0;n<t.length;n++){var i=t[n];i.hidden||i.node&&!i.changes||++r}return r}function Cn(e,t){e.doc.highlightFrontier<e.display.viewTo&&e.state.highlight.set(t,u(Sn,e))}function Sn(e){var t=e.doc;if(!(t.highlightFrontier>=e.display.viewTo)){var r=+new Date+e.options.workTime,n=$e(e,t.highlightFrontier),i=[];t.iter(n.line,Math.min(t.first+t.size,e.display.viewTo+500),function(o){if(n.line>=e.display.viewFrom){var l=o.styles,s=o.text.length>e.options.maxHighlightLength?Ke(t.mode,n.state):null,a=Ye(e,o,n,!0);s&&(n.state=s),o.styles=a.styles;var u=o.styleClasses,c=a.classes;c?o.styleClasses=c:u&&(o.styleClasses=null);for(var f=!l||l.length!=o.styles.length||u!=c&&(!u||!c||u.bgClass!=c.bgClass||u.textClass!=c.textClass),h=0;!f&&h<l.length;++h)f=l[h]!=o.styles[h];f&&i.push(n.line),o.stateAfter=n.save(),n.nextLine()}else o.text.length<=e.options.maxHighlightLength&&qe(e,o.text,n),o.stateAfter=n.line%5==0?n.save():null,n.nextLine();if(+new Date>r)return Cn(e,e.options.workDelay),!0}),t.highlightFrontier=n.line,t.modeFrontier=Math.max(t.modeFrontier,n.line),i.length&&hn(e,function(){for(var t=0;t<i.length;t++)mn(e,i[t],"text")})}}function Ln(e){var t=e.display;!t.scrollbarsClipped&&t.scroller.offsetWidth&&(t.nativeBarWidth=t.scroller.offsetWidth-t.scroller.clientWidth,t.heightForcer.style.height=zt(e)+"px",t.sizer.style.marginBottom=-t.nativeBarWidth+"px",t.sizer.style.borderRightWidth=zt(e)+"px",t.scrollbarsClipped=!0)}function kn(e){if(e.hasFocus())return null;var t=l();if(!t||!o(e.display.lineDiv,t))return null;var r={activeElt:t};if(window.getSelection){var n=window.getSelection();n.anchorNode&&n.extend&&o(e.display.lineDiv,n.anchorNode)&&(r.anchorNode=n.anchorNode,r.anchorOffset=n.anchorOffset,r.focusNode=n.focusNode,r.focusOffset=n.focusOffset)}return r}function Tn(e){if(e&&e.activeElt&&e.activeElt!=l()&&(e.activeElt.focus(),e.anchorNode&&o(document.body,e.anchorNode)&&o(document.body,e.focusNode))){var t=window.getSelection(),r=document.createRange();r.setEnd(e.anchorNode,e.anchorOffset),r.collapse(!1),t.removeAllRanges(),t.addRange(r),t.extend(e.focusNode,e.focusOffset)}}function Mn(e,r){var n=e.display,i=e.doc;if(r.editorIsHidden)return yn(e),!1;if(!r.force&&r.visible.from>=n.viewFrom&&r.visible.to<=n.viewTo&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo)&&n.renderedView==n.view&&0==xn(e))return!1;Rr(e)&&(yn(e),r.dims=br(e));var o=i.first+i.size,l=Math.max(r.visible.from-e.options.viewportMargin,i.first),s=Math.min(o,r.visible.to+e.options.viewportMargin);n.viewFrom<l&&l-n.viewFrom<20&&(l=Math.max(i.first,n.viewFrom)),n.viewTo>s&&n.viewTo-s<20&&(s=Math.min(o,n.viewTo)),_l&&(l=pe(e.doc,l),s=ge(e.doc,s));var a=l!=n.viewFrom||s!=n.viewTo||n.lastWrapHeight!=r.wrapperHeight||n.lastWrapWidth!=r.wrapperWidth;wn(e,l,s),n.viewOffset=ye(M(e.doc,n.viewFrom)),e.display.mover.style.top=n.viewOffset+"px";var u=xn(e);if(!a&&0==u&&!r.force&&n.renderedView==n.view&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo))return!1;var c=kn(e);return u>4&&(n.lineDiv.style.display="none"),An(e,n.updateLineNumbers,r.dims),u>4&&(n.lineDiv.style.display=""),n.renderedView=n.view,Tn(c),t(n.cursorDiv),t(n.selectionDiv),n.gutters.style.height=n.sizer.style.minHeight=0,a&&(n.lastWrapHeight=r.wrapperHeight,n.lastWrapWidth=r.wrapperWidth,Cn(e,400)),n.updateLineNumbers=null,!0}function Nn(e,t){for(var r=t.viewport,n=!0;(n&&e.options.lineWrapping&&t.oldDisplayWidth!=Rt(e)||(r&&null!=r.top&&(r={top:Math.min(e.doc.height+Pt(e.display)-Bt(e),r.top)}),t.visible=Ir(e.display,e.doc,r),!(t.visible.from>=e.display.viewFrom&&t.visible.to<=e.display.viewTo)))&&Mn(e,t);n=!1){Er(e);var i=Jr(e);kr(e),en(e,i),Dn(e,i),t.force=!1}t.signal(e,"update",e),e.display.viewFrom==e.display.reportedViewFrom&&e.display.viewTo==e.display.reportedViewTo||(t.signal(e,"viewportChange",e,e.display.viewFrom,e.display.viewTo),e.display.reportedViewFrom=e.display.viewFrom,e.display.reportedViewTo=e.display.viewTo)}function On(e,t){var r=new Cs(e,t);if(Mn(e,r)){Er(e),Nn(e,r);var n=Jr(e);kr(e),en(e,n),Dn(e,n),r.finish()}}function An(e,r,n){function i(t){var r=t.nextSibling;return ml&&Ml&&e.display.currentWheelTarget==t?t.style.display="none":t.parentNode.removeChild(t),r}for(var o=e.display,l=e.options.lineNumbers,s=o.lineDiv,a=s.firstChild,u=o.view,c=o.viewFrom,f=0;f<u.length;f++){var d=u[f];if(d.hidden);else if(d.node&&d.node.parentNode==s){for(;a!=d.node;)a=i(a);var p=l&&null!=r&&r<=c&&d.lineNumber;d.changes&&(h(d.changes,"gutter")>-1&&(p=!1),xt(e,d,c,n)),p&&(t(d.lineNumber),d.lineNumber.appendChild(document.createTextNode(F(e.options,c)))),a=d.node.nextSibling}else{var g=Ot(e,d,c,n);s.insertBefore(g,a)}c+=d.size}for(;a;)a=i(a)}function Wn(e){var t=e.display.gutters.offsetWidth;e.display.sizer.style.marginLeft=t+"px"}function Dn(e,t){e.display.sizer.style.minHeight=t.docHeight+"px",e.display.heightForcer.style.top=t.docHeight+"px",e.display.gutters.style.height=t.docHeight+e.display.barHeight+zt(e)+"px"}function Hn(e){var r=e.display.gutters,i=e.options.gutters;t(r);for(var o=0;o<i.length;++o){var l=i[o],s=r.appendChild(n("div",null,"CodeMirror-gutter "+l));"CodeMirror-linenumbers"==l&&(e.display.lineGutter=s,s.style.width=(e.display.lineNumWidth||1)+"px")}r.style.display=o?"":"none",Wn(e)}function Fn(e){var t=h(e.gutters,"CodeMirror-linenumbers");-1==t&&e.lineNumbers?e.gutters=e.gutters.concat(["CodeMirror-linenumbers"]):t>-1&&!e.lineNumbers&&(e.gutters=e.gutters.slice(0),e.gutters.splice(t,1))}function En(e){var t=e.wheelDeltaX,r=e.wheelDeltaY;return null==t&&e.detail&&e.axis==e.HORIZONTAL_AXIS&&(t=e.detail),null==r&&e.detail&&e.axis==e.VERTICAL_AXIS?r=e.detail:null==r&&(r=e.wheelDelta),{x:t,y:r}}function Pn(e){var t=En(e);return t.x*=Ls,t.y*=Ls,t}function In(e,t){var r=En(t),n=r.x,i=r.y,o=e.display,l=o.scroller,s=l.scrollWidth>l.clientWidth,a=l.scrollHeight>l.clientHeight;if(n&&s||i&&a){if(i&&Ml&&ml)e:for(var u=t.target,c=o.view;u!=l;u=u.parentNode)for(var f=0;f<c.length;f++)if(c[f].node==u){e.display.currentWheelTarget=u;break e}if(n&&!fl&&!wl&&null!=Ls)return i&&a&&qr(e,Math.max(0,l.scrollTop+i*Ls)),Qr(e,Math.max(0,l.scrollLeft+n*Ls)),(!i||i&&a)&&We(t),void(o.wheelStartX=null);if(i&&null!=Ls){var h=i*Ls,d=e.doc.scrollTop,p=d+o.wrapper.clientHeight;h<0?d=Math.max(0,d+h-50):p=Math.min(e.doc.height,p+h+50),On(e,{top:d,bottom:p})}Ss<20&&(null==o.wheelStartX?(o.wheelStartX=l.scrollLeft,o.wheelStartY=l.scrollTop,o.wheelDX=n,o.wheelDY=i,setTimeout(function(){if(null!=o.wheelStartX){var e=l.scrollLeft-o.wheelStartX,t=l.scrollTop-o.wheelStartY,r=t&&o.wheelDY&&t/o.wheelDY||e&&o.wheelDX&&e/o.wheelDX;o.wheelStartX=o.wheelStartY=null,r&&(Ls=(Ls*Ss+r)/(Ss+1),++Ss)}},200)):(o.wheelDX+=n,o.wheelDY+=i))}}function zn(e,t){var r=e[t];e.sort(function(e,t){return P(e.from(),t.from())}),t=h(e,r);for(var n=1;n<e.length;n++){var i=e[n],o=e[n-1];if(P(o.to(),i.from())>=0){var l=B(o.from(),i.from()),s=R(o.to(),i.to()),a=o.empty()?i.from()==i.head:o.from()==o.head;n<=t&&--t,e.splice(--n,2,new Ts(a?s:l,a?l:s))}}return new ks(e,t)}function Rn(e,t){return new ks([new Ts(e,t||e)],0)}function Bn(e){return e.text?E(e.from.line+e.text.length-1,g(e.text).length+(1==e.text.length?e.from.ch:0)):e.to}function Gn(e,t){if(P(e,t.from)<0)return e;if(P(e,t.to)<=0)return Bn(t);var r=e.line+t.text.length-(t.to.line-t.from.line)-1,n=e.ch;return e.line==t.to.line&&(n+=Bn(t).ch-t.to.ch),E(r,n)}function Un(e,t){for(var r=[],n=0;n<e.sel.ranges.length;n++){var i=e.sel.ranges[n];r.push(new Ts(Gn(i.anchor,t),Gn(i.head,t)))}return zn(r,e.sel.primIndex)}function Vn(e,t,r){return e.line==t.line?E(r.line,e.ch-t.ch+r.ch):E(r.line+(e.line-t.line),e.ch)}function Kn(e,t,r){for(var n=[],i=E(e.first,0),o=i,l=0;l<t.length;l++){var s=t[l],a=Vn(s.from,i,o),u=Vn(Bn(s),i,o);if(i=s.to,o=u,"around"==r){var c=e.sel.ranges[l],f=P(c.head,c.anchor)<0;n[l]=new Ts(f?u:a,f?a:u)}else n[l]=new Ts(a,a)}return new ks(n,e.sel.primIndex)}function jn(e){e.doc.mode=Ue(e.options,e.doc.modeOption),Xn(e)}function Xn(e){e.doc.iter(function(e){e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null)}),e.doc.modeFrontier=e.doc.highlightFrontier=e.doc.first,Cn(e,100),e.state.modeGen++,e.curOp&&vn(e)}function Yn(e,t){return 0==t.from.ch&&0==t.to.ch&&""==g(t.text)&&(!e.cm||e.cm.options.wholeLineUpdateBefore)}function _n(e,t,r,n){function i(e){return r?r[e]:null}function o(e,r,i){it(e,r,i,n),bt(e,"change",e,t)}function l(e,t){for(var r=[],o=e;o<t;++o)r.push(new fs(u[o],i(o),n));return r}var s=t.from,a=t.to,u=t.text,c=M(e,s.line),f=M(e,a.line),h=g(u),d=i(u.length-1),p=a.line-s.line;if(t.full)e.insert(0,l(0,u.length)),e.remove(u.length,e.size-u.length);else if(Yn(e,t)){var v=l(0,u.length-1);o(f,f.text,d),p&&e.remove(s.line,p),v.length&&e.insert(s.line,v)}else if(c==f)if(1==u.length)o(c,c.text.slice(0,s.ch)+h+c.text.slice(a.ch),d);else{var m=l(1,u.length-1);m.push(new fs(h+c.text.slice(a.ch),d,n)),o(c,c.text.slice(0,s.ch)+u[0],i(0)),e.insert(s.line+1,m)}else if(1==u.length)o(c,c.text.slice(0,s.ch)+u[0]+f.text.slice(a.ch),i(0)),e.remove(s.line+1,p);else{o(c,c.text.slice(0,s.ch)+u[0],i(0)),o(f,h+f.text.slice(a.ch),d);var y=l(1,u.length-1);p>1&&e.remove(s.line+1,p-1),e.insert(s.line+1,y)}bt(e,"change",e,t)}function $n(e,t,r){function n(e,i,o){if(e.linked)for(var l=0;l<e.linked.length;++l){var s=e.linked[l];if(s.doc!=i){var a=o&&s.sharedHist;r&&!a||(t(s.doc,a),n(s.doc,e,a))}}}n(e,null,!0)}function qn(e,t){if(t.cm)throw new Error("This document is already in use.");e.doc=t,t.cm=e,Cr(e),jn(e),Zn(e),e.options.lineWrapping||we(e),e.options.mode=t.modeOption,vn(e)}function Zn(e){("rtl"==e.doc.direction?s:Fl)(e.display.lineDiv,"CodeMirror-rtl")}function Qn(e){hn(e,function(){Zn(e),vn(e)})}function Jn(e){this.done=[],this.undone=[],this.undoDepth=1/0,this.lastModTime=this.lastSelTime=0,this.lastOp=this.lastSelOp=null,this.lastOrigin=this.lastSelOrigin=null,this.generation=this.maxGeneration=e||1}function ei(e,t){var r={from:z(t.from),to:Bn(t),text:N(e,t.from,t.to)};return si(e,r,t.from.line,t.to.line+1),$n(e,function(e){return si(e,r,t.from.line,t.to.line+1)},!0),r}function ti(e){for(;e.length&&g(e).ranges;)e.pop()}function ri(e,t){return t?(ti(e.done),g(e.done)):e.done.length&&!g(e.done).ranges?g(e.done):e.done.length>1&&!e.done[e.done.length-2].ranges?(e.done.pop(),g(e.done)):void 0}function ni(e,t,r,n){var i=e.history;i.undone.length=0;var o,l,s=+new Date;if((i.lastOp==n||i.lastOrigin==t.origin&&t.origin&&("+"==t.origin.charAt(0)&&e.cm&&i.lastModTime>s-e.cm.options.historyEventDelay||"*"==t.origin.charAt(0)))&&(o=ri(i,i.lastOp==n)))l=g(o.changes),0==P(t.from,t.to)&&0==P(t.from,l.to)?l.to=Bn(t):o.changes.push(ei(e,t));else{var a=g(i.done);for(a&&a.ranges||li(e.sel,i.done),o={changes:[ei(e,t)],generation:i.generation},i.done.push(o);i.done.length>i.undoDepth;)i.done.shift(),i.done[0].ranges||i.done.shift()}i.done.push(r),i.generation=++i.maxGeneration,i.lastModTime=i.lastSelTime=s,i.lastOp=i.lastSelOp=n,i.lastOrigin=i.lastSelOrigin=t.origin,l||Te(e,"historyAdded")}function ii(e,t,r,n){var i=t.charAt(0);return"*"==i||"+"==i&&r.ranges.length==n.ranges.length&&r.somethingSelected()==n.somethingSelected()&&new Date-e.history.lastSelTime<=(e.cm?e.cm.options.historyEventDelay:500)}function oi(e,t,r,n){var i=e.history,o=n&&n.origin;r==i.lastSelOp||o&&i.lastSelOrigin==o&&(i.lastModTime==i.lastSelTime&&i.lastOrigin==o||ii(e,o,g(i.done),t))?i.done[i.done.length-1]=t:li(t,i.done),i.lastSelTime=+new Date,i.lastSelOrigin=o,i.lastSelOp=r,n&&!1!==n.clearRedo&&ti(i.undone)}function li(e,t){var r=g(t);r&&r.ranges&&r.equals(e)||t.push(e)}function si(e,t,r,n){var i=t["spans_"+e.id],o=0;e.iter(Math.max(e.first,r),Math.min(e.first+e.size,n),function(r){r.markedSpans&&((i||(i=t["spans_"+e.id]={}))[o]=r.markedSpans),++o})}function ai(e){if(!e)return null;for(var t,r=0;r<e.length;++r)e[r].marker.explicitlyCleared?t||(t=e.slice(0,r)):t&&t.push(e[r]);return t?t.length?t:null:e}function ui(e,t){var r=t["spans_"+e.id];if(!r)return null;for(var n=[],i=0;i<t.text.length;++i)n.push(ai(r[i]));return n}function ci(e,t){var r=ui(e,t),n=J(e,t);if(!r)return n;if(!n)return r;for(var i=0;i<r.length;++i){var o=r[i],l=n[i];if(o&&l)e:for(var s=0;s<l.length;++s){for(var a=l[s],u=0;u<o.length;++u)if(o[u].marker==a.marker)continue e;o.push(a)}else l&&(r[i]=l)}return r}function fi(e,t,r){for(var n=[],i=0;i<e.length;++i){var o=e[i];if(o.ranges)n.push(r?ks.prototype.deepCopy.call(o):o);else{var l=o.changes,s=[];n.push({changes:s});for(var a=0;a<l.length;++a){var u=l[a],c=void 0;if(s.push({from:u.from,to:u.to,text:u.text}),t)for(var f in u)(c=f.match(/^spans_(\d+)$/))&&h(t,Number(c[1]))>-1&&(g(s)[f]=u[f],delete u[f])}}}return n}function hi(e,t,r,n){if(n){var i=e.anchor;if(r){var o=P(t,i)<0;o!=P(r,i)<0?(i=t,t=r):o!=P(t,r)<0&&(t=r)}return new Ts(i,t)}return new Ts(r||t,t)}function di(e,t,r,n,i){null==i&&(i=e.cm&&(e.cm.display.shift||e.extend)),bi(e,new ks([hi(e.sel.primary(),t,r,i)],0),n)}function pi(e,t,r){for(var n=[],i=e.cm&&(e.cm.display.shift||e.extend),o=0;o<e.sel.ranges.length;o++)n[o]=hi(e.sel.ranges[o],t[o],null,i);bi(e,zn(n,e.sel.primIndex),r)}function gi(e,t,r,n){var i=e.sel.ranges.slice(0);i[t]=r,bi(e,zn(i,e.sel.primIndex),n)}function vi(e,t,r,n){bi(e,Rn(t,r),n)}function mi(e,t,r){var n={ranges:t.ranges,update:function(t){var r=this;this.ranges=[];for(var n=0;n<t.length;n++)r.ranges[n]=new Ts(U(e,t[n].anchor),U(e,t[n].head))},origin:r&&r.origin};return Te(e,"beforeSelectionChange",e,n),e.cm&&Te(e.cm,"beforeSelectionChange",e.cm,n),n.ranges!=t.ranges?zn(n.ranges,n.ranges.length-1):t}function yi(e,t,r){var n=e.history.done,i=g(n);i&&i.ranges?(n[n.length-1]=t,wi(e,t,r)):bi(e,t,r)}function bi(e,t,r){wi(e,t,r),oi(e,e.sel,e.cm?e.cm.curOp.id:NaN,r)}function wi(e,t,r){(Oe(e,"beforeSelectionChange")||e.cm&&Oe(e.cm,"beforeSelectionChange"))&&(t=mi(e,t,r)),xi(e,Si(e,t,r&&r.bias||(P(t.primary().head,e.sel.primary().head)<0?-1:1),!0)),r&&!1===r.scroll||!e.cm||jr(e.cm)}function xi(e,t){t.equals(e.sel)||(e.sel=t,e.cm&&(e.cm.curOp.updateInput=e.cm.curOp.selectionChanged=!0,Ne(e.cm)),bt(e,"cursorActivity",e))}function Ci(e){xi(e,Si(e,e.sel,null,!1))}function Si(e,t,r,n){for(var i,o=0;o<t.ranges.length;o++){var l=t.ranges[o],s=t.ranges.length==e.sel.ranges.length&&e.sel.ranges[o],a=ki(e,l.anchor,s&&s.anchor,r,n),u=ki(e,l.head,s&&s.head,r,n);(i||a!=l.anchor||u!=l.head)&&(i||(i=t.ranges.slice(0,o)),i[o]=new Ts(a,u))}return i?zn(i,t.primIndex):t}function Li(e,t,r,n,i){var o=M(e,t.line);if(o.markedSpans)for(var l=0;l<o.markedSpans.length;++l){var s=o.markedSpans[l],a=s.marker;if((null==s.from||(a.inclusiveLeft?s.from<=t.ch:s.from<t.ch))&&(null==s.to||(a.inclusiveRight?s.to>=t.ch:s.to>t.ch))){if(i&&(Te(a,"beforeCursorEnter"),a.explicitlyCleared)){if(o.markedSpans){--l;continue}break}if(!a.atomic)continue;if(r){var u=a.find(n<0?1:-1),c=void 0;if((n<0?a.inclusiveRight:a.inclusiveLeft)&&(u=Ti(e,u,-n,u&&u.line==t.line?o:null)),u&&u.line==t.line&&(c=P(u,r))&&(n<0?c<0:c>0))return Li(e,u,t,n,i)}var f=a.find(n<0?-1:1);return(n<0?a.inclusiveLeft:a.inclusiveRight)&&(f=Ti(e,f,n,f.line==t.line?o:null)),f?Li(e,f,t,n,i):null}}return t}function ki(e,t,r,n,i){var o=n||1,l=Li(e,t,r,o,i)||!i&&Li(e,t,r,o,!0)||Li(e,t,r,-o,i)||!i&&Li(e,t,r,-o,!0);return l||(e.cantEdit=!0,E(e.first,0))}function Ti(e,t,r,n){return r<0&&0==t.ch?t.line>e.first?U(e,E(t.line-1)):null:r>0&&t.ch==(n||M(e,t.line)).text.length?t.line<e.first+e.size-1?E(t.line+1,0):null:new E(t.line,t.ch+r)}function Mi(e){e.setSelection(E(e.firstLine(),0),E(e.lastLine()),Gl)}function Ni(e,t,r){var n={canceled:!1,from:t.from,to:t.to,text:t.text,origin:t.origin,cancel:function(){return n.canceled=!0}};return r&&(n.update=function(t,r,i,o){t&&(n.from=U(e,t)),r&&(n.to=U(e,r)),i&&(n.text=i),void 0!==o&&(n.origin=o)}),Te(e,"beforeChange",e,n),e.cm&&Te(e.cm,"beforeChange",e.cm,n),n.canceled?null:{from:n.from,to:n.to,text:n.text,origin:n.origin}}function Oi(e,t,r){if(e.cm){if(!e.cm.curOp)return dn(e.cm,Oi)(e,t,r);if(e.cm.state.suppressEdits)return}if(!(Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"))||(t=Ni(e,t,!0))){var n=Yl&&!r&&te(e,t.from,t.to);if(n)for(var i=n.length-1;i>=0;--i)Ai(e,{from:n[i].from,to:n[i].to,text:i?[""]:t.text,origin:t.origin});else Ai(e,t)}}function Ai(e,t){if(1!=t.text.length||""!=t.text[0]||0!=P(t.from,t.to)){var r=Un(e,t);ni(e,t,r,e.cm?e.cm.curOp.id:NaN),Hi(e,t,r,J(e,t));var n=[];$n(e,function(e,r){r||-1!=h(n,e.history)||(zi(e.history,t),n.push(e.history)),Hi(e,t,null,J(e,t))})}}function Wi(e,t,r){if(!e.cm||!e.cm.state.suppressEdits||r){for(var n,i=e.history,o=e.sel,l="undo"==t?i.done:i.undone,s="undo"==t?i.undone:i.done,a=0;a<l.length&&(n=l[a],r?!n.ranges||n.equals(e.sel):n.ranges);a++);if(a!=l.length){for(i.lastOrigin=i.lastSelOrigin=null;(n=l.pop()).ranges;){if(li(n,s),r&&!n.equals(e.sel))return void bi(e,n,{clearRedo:!1});o=n}var u=[];li(o,s),s.push({changes:u,generation:i.generation}),i.generation=n.generation||++i.maxGeneration;for(var c=Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"),f=n.changes.length-1;f>=0;--f){var d=function(r){var i=n.changes[r];if(i.origin=t,c&&!Ni(e,i,!1))return l.length=0,{};u.push(ei(e,i));var o=r?Un(e,i):g(l);Hi(e,i,o,ci(e,i)),!r&&e.cm&&e.cm.scrollIntoView({from:i.from,to:Bn(i)});var s=[];$n(e,function(e,t){t||-1!=h(s,e.history)||(zi(e.history,i),s.push(e.history)),Hi(e,i,null,ci(e,i))})}(f);if(d)return d.v}}}}function Di(e,t){if(0!=t&&(e.first+=t,e.sel=new ks(v(e.sel.ranges,function(e){return new Ts(E(e.anchor.line+t,e.anchor.ch),E(e.head.line+t,e.head.ch))}),e.sel.primIndex),e.cm)){vn(e.cm,e.first,e.first-t,t);for(var r=e.cm.display,n=r.viewFrom;n<r.viewTo;n++)mn(e.cm,n,"gutter")}}function Hi(e,t,r,n){if(e.cm&&!e.cm.curOp)return dn(e.cm,Hi)(e,t,r,n);if(t.to.line<e.first)Di(e,t.text.length-1-(t.to.line-t.from.line));else if(!(t.from.line>e.lastLine())){if(t.from.line<e.first){var i=t.text.length-1-(e.first-t.from.line);Di(e,i),t={from:E(e.first,0),to:E(t.to.line+i,t.to.ch),text:[g(t.text)],origin:t.origin}}var o=e.lastLine();t.to.line>o&&(t={from:t.from,to:E(o,M(e,o).text.length),text:[t.text[0]],origin:t.origin}),t.removed=N(e,t.from,t.to),r||(r=Un(e,t)),e.cm?Fi(e.cm,t,n):_n(e,t,n),wi(e,r,Gl)}}function Fi(e,t,r){var n=e.doc,i=e.display,o=t.from,l=t.to,s=!1,a=o.line;e.options.lineWrapping||(a=W(fe(M(n,o.line))),n.iter(a,l.line+1,function(e){if(e==i.maxLine)return s=!0,!0})),n.sel.contains(t.from,t.to)>-1&&Ne(e),_n(n,t,r,xr(e)),e.options.lineWrapping||(n.iter(a,o.line+t.text.length,function(e){var t=be(e);t>i.maxLineLength&&(i.maxLine=e,i.maxLineLength=t,i.maxLineChanged=!0,s=!1)}),s&&(e.curOp.updateMaxLine=!0)),nt(n,o.line),Cn(e,400);var u=t.text.length-(l.line-o.line)-1;t.full?vn(e):o.line!=l.line||1!=t.text.length||Yn(e.doc,t)?vn(e,o.line,l.line+1,u):mn(e,o.line,"text");var c=Oe(e,"changes"),f=Oe(e,"change");if(f||c){var h={from:o,to:l,text:t.text,removed:t.removed,origin:t.origin};f&&bt(e,"change",e,h),c&&(e.curOp.changeObjs||(e.curOp.changeObjs=[])).push(h)}e.display.selForContextMenu=null}function Ei(e,t,r,n,i){if(n||(n=r),P(n,r)<0){var o;r=(o=[n,r])[0],n=o[1]}"string"==typeof t&&(t=e.splitLines(t)),Oi(e,{from:r,to:n,text:t,origin:i})}function Pi(e,t,r,n){r<e.line?e.line+=n:t<e.line&&(e.line=t,e.ch=0)}function Ii(e,t,r,n){for(var i=0;i<e.length;++i){var o=e[i],l=!0;if(o.ranges){o.copied||((o=e[i]=o.deepCopy()).copied=!0);for(var s=0;s<o.ranges.length;s++)Pi(o.ranges[s].anchor,t,r,n),Pi(o.ranges[s].head,t,r,n)}else{for(var a=0;a<o.changes.length;++a){var u=o.changes[a];if(r<u.from.line)u.from=E(u.from.line+n,u.from.ch),u.to=E(u.to.line+n,u.to.ch);else if(t<=u.to.line){l=!1;break}}l||(e.splice(0,i+1),i=0)}}}function zi(e,t){var r=t.from.line,n=t.to.line,i=t.text.length-(n-r)-1;Ii(e.done,r,n,i),Ii(e.undone,r,n,i)}function Ri(e,t,r,n){var i=t,o=t;return"number"==typeof t?o=M(e,G(e,t)):i=W(t),null==i?null:(n(o,i)&&e.cm&&mn(e.cm,i,r),o)}function Bi(e){var t=this;this.lines=e,this.parent=null;for(var r=0,n=0;n<e.length;++n)e[n].parent=t,r+=e[n].height;this.height=r}function Gi(e){var t=this;this.children=e;for(var r=0,n=0,i=0;i<e.length;++i){var o=e[i];r+=o.chunkSize(),n+=o.height,o.parent=t}this.size=r,this.height=n,this.parent=null}function Ui(e,t,r){ye(t)<(e.curOp&&e.curOp.scrollTop||e.doc.scrollTop)&&Kr(e,r)}function Vi(e,t,r,n){var i=new Ms(e,r,n),o=e.cm;return o&&i.noHScroll&&(o.display.alignWidgets=!0),Ri(e,t,"widget",function(t){var r=t.widgets||(t.widgets=[]);if(null==i.insertAt?r.push(i):r.splice(Math.min(r.length-1,Math.max(0,i.insertAt)),0,i),i.line=t,o&&!ve(e,t)){var n=ye(t)<e.scrollTop;A(t,t.height+Ht(i)),n&&Kr(o,i.height),o.curOp.forceUpdate=!0}return!0}),bt(o,"lineWidgetAdded",o,i,"number"==typeof t?t:W(t)),i}function Ki(e,t,r,n,o){if(n&&n.shared)return ji(e,t,r,n,o);if(e.cm&&!e.cm.curOp)return dn(e.cm,Ki)(e,t,r,n,o);var l=new Os(e,o),s=P(t,r);if(n&&c(n,l,!1),s>0||0==s&&!1!==l.clearWhenEmpty)return l;if(l.replacedWith&&(l.collapsed=!0,l.widgetNode=i("span",[l.replacedWith],"CodeMirror-widget"),n.handleMouseEvents||l.widgetNode.setAttribute("cm-ignore-events","true"),n.insertLeft&&(l.widgetNode.insertLeft=!0)),l.collapsed){if(ce(e,t.line,t,r,l)||t.line!=r.line&&ce(e,r.line,t,r,l))throw new Error("Inserting collapsed marker partially overlapping an existing one");X()}l.addToHistory&&ni(e,{from:t,to:r,origin:"markText"},e.sel,NaN);var a,u=t.line,f=e.cm;if(e.iter(u,r.line+1,function(e){f&&l.collapsed&&!f.options.lineWrapping&&fe(e)==f.display.maxLine&&(a=!0),l.collapsed&&u!=t.line&&A(e,0),q(e,new Y(l,u==t.line?t.ch:null,u==r.line?r.ch:null)),++u}),l.collapsed&&e.iter(t.line,r.line+1,function(t){ve(e,t)&&A(t,0)}),l.clearOnEnter&&Ql(l,"beforeCursorEnter",function(){return l.clear()}),l.readOnly&&(j(),(e.history.done.length||e.history.undone.length)&&e.clearHistory()),l.collapsed&&(l.id=++Ns,l.atomic=!0),f){if(a&&(f.curOp.updateMaxLine=!0),l.collapsed)vn(f,t.line,r.line+1);else if(l.className||l.title||l.startStyle||l.endStyle||l.css)for(var h=t.line;h<=r.line;h++)mn(f,h,"text");l.atomic&&Ci(f.doc),bt(f,"markerAdded",f,l)}return l}function ji(e,t,r,n,i){(n=c(n)).shared=!1;var o=[Ki(e,t,r,n,i)],l=o[0],s=n.widgetNode;return $n(e,function(e){s&&(n.widgetNode=s.cloneNode(!0)),o.push(Ki(e,U(e,t),U(e,r),n,i));for(var a=0;a<e.linked.length;++a)if(e.linked[a].isParent)return;l=g(o)}),new As(o,l)}function Xi(e){return e.findMarks(E(e.first,0),e.clipPos(E(e.lastLine())),function(e){return e.parent})}function Yi(e,t){for(var r=0;r<t.length;r++){var n=t[r],i=n.find(),o=e.clipPos(i.from),l=e.clipPos(i.to);if(P(o,l)){var s=Ki(e,o,l,n.primary,n.primary.type);n.markers.push(s),s.parent=n}}}function _i(e){for(var t=0;t<e.length;t++)!function(t){var r=e[t],n=[r.primary.doc];$n(r.primary.doc,function(e){return n.push(e)});for(var i=0;i<r.markers.length;i++){var o=r.markers[i];-1==h(n,o.doc)&&(o.parent=null,r.markers.splice(i--,1))}}(t)}function $i(e){var t=this;if(Qi(t),!Me(t,e)&&!Ft(t.display,e)){We(e),gl&&(Hs=+new Date);var r=Sr(t,e,!0),n=e.dataTransfer.files;if(r&&!t.isReadOnly())if(n&&n.length&&window.FileReader&&window.File)for(var i=n.length,o=Array(i),l=0,s=0;s<i;++s)!function(e,n){if(!t.options.allowDropFileTypes||-1!=h(t.options.allowDropFileTypes,e.type)){var s=new FileReader;s.onload=dn(t,function(){var e=s.result;if(/[\x00-\x08\x0e-\x1f]{2}/.test(e)&&(e=""),o[n]=e,++l==i){var a={from:r=U(t.doc,r),to:r,text:t.doc.splitLines(o.join(t.doc.lineSeparator())),origin:"paste"};Oi(t.doc,a),yi(t.doc,Rn(r,Bn(a)))}}),s.readAsText(e)}}(n[s],s);else{if(t.state.draggingText&&t.doc.sel.contains(r)>-1)return t.state.draggingText(e),void setTimeout(function(){return t.display.input.focus()},20);try{var a=e.dataTransfer.getData("Text");if(a){var u;if(t.state.draggingText&&!t.state.draggingText.copy&&(u=t.listSelections()),wi(t.doc,Rn(r,r)),u)for(var c=0;c<u.length;++c)Ei(t.doc,"",u[c].anchor,u[c].head,"drag");t.replaceSelection(a,"around","paste"),t.display.input.focus()}}catch(e){}}}}function qi(e,t){if(gl&&(!e.state.draggingText||+new Date-Hs<100))Fe(t);else if(!Me(e,t)&&!Ft(e.display,t)&&(t.dataTransfer.setData("Text",e.getSelection()),t.dataTransfer.effectAllowed="copyMove",t.dataTransfer.setDragImage&&!xl)){var r=n("img",null,null,"position: fixed; left: 0; top: 0;");r.src="data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==",wl&&(r.width=r.height=1,e.display.wrapper.appendChild(r),r._top=r.offsetTop),t.dataTransfer.setDragImage(r,0,0),wl&&r.parentNode.removeChild(r)}}function Zi(e,t){var i=Sr(e,t);if(i){var o=document.createDocumentFragment();Mr(e,i,o),e.display.dragCursor||(e.display.dragCursor=n("div",null,"CodeMirror-cursors CodeMirror-dragcursors"),e.display.lineSpace.insertBefore(e.display.dragCursor,e.display.cursorDiv)),r(e.display.dragCursor,o)}}function Qi(e){e.display.dragCursor&&(e.display.lineSpace.removeChild(e.display.dragCursor),e.display.dragCursor=null)}function Ji(e){if(document.getElementsByClassName)for(var t=document.getElementsByClassName("CodeMirror"),r=0;r<t.length;r++){var n=t[r].CodeMirror;n&&e(n)}}function eo(){Fs||(to(),Fs=!0)}function to(){var e;Ql(window,"resize",function(){null==e&&(e=setTimeout(function(){e=null,Ji(ro)},100))}),Ql(window,"blur",function(){return Ji(Fr)})}function ro(e){var t=e.display;t.lastWrapHeight==t.wrapper.clientHeight&&t.lastWrapWidth==t.wrapper.clientWidth||(t.cachedCharWidth=t.cachedTextHeight=t.cachedPaddingH=null,t.scrollbarsClipped=!1,e.setSize())}function no(e){var t=e.split(/-(?!$)/);e=t[t.length-1];for(var r,n,i,o,l=0;l<t.length-1;l++){var s=t[l];if(/^(cmd|meta|m)$/i.test(s))o=!0;else if(/^a(lt)?$/i.test(s))r=!0;else if(/^(c|ctrl|control)$/i.test(s))n=!0;else{if(!/^s(hift)?$/i.test(s))throw new Error("Unrecognized modifier name: "+s);i=!0}}return r&&(e="Alt-"+e),n&&(e="Ctrl-"+e),o&&(e="Cmd-"+e),i&&(e="Shift-"+e),e}function io(e){var t={};for(var r in e)if(e.hasOwnProperty(r)){var n=e[r];if(/^(name|fallthrough|(de|at)tach)$/.test(r))continue;if("..."==n){delete e[r];continue}for(var i=v(r.split(" "),no),o=0;o<i.length;o++){var l=void 0,s=void 0;o==i.length-1?(s=i.join(" "),l=n):(s=i.slice(0,o+1).join(" "),l="...");var a=t[s];if(a){if(a!=l)throw new Error("Inconsistent bindings for "+s)}else t[s]=l}delete e[r]}for(var u in t)e[u]=t[u];return e}function oo(e,t,r,n){var i=(t=uo(t)).call?t.call(e,n):t[e];if(!1===i)return"nothing";if("..."===i)return"multi";if(null!=i&&r(i))return"handled";if(t.fallthrough){if("[object Array]"!=Object.prototype.toString.call(t.fallthrough))return oo(e,t.fallthrough,r,n);for(var o=0;o<t.fallthrough.length;o++){var l=oo(e,t.fallthrough[o],r,n);if(l)return l}}}function lo(e){var t="string"==typeof e?e:Es[e.keyCode];return"Ctrl"==t||"Alt"==t||"Shift"==t||"Mod"==t}function so(e,t,r){var n=e;return t.altKey&&"Alt"!=n&&(e="Alt-"+e),(Dl?t.metaKey:t.ctrlKey)&&"Ctrl"!=n&&(e="Ctrl-"+e),(Dl?t.ctrlKey:t.metaKey)&&"Cmd"!=n&&(e="Cmd-"+e),!r&&t.shiftKey&&"Shift"!=n&&(e="Shift-"+e),e}function ao(e,t){if(wl&&34==e.keyCode&&e.char)return!1;var r=Es[e.keyCode];return null!=r&&!e.altGraphKey&&so(r,e,t)}function uo(e){return"string"==typeof e?Rs[e]:e}function co(e,t){for(var r=e.doc.sel.ranges,n=[],i=0;i<r.length;i++){for(var o=t(r[i]);n.length&&P(o.from,g(n).to)<=0;){var l=n.pop();if(P(l.from,o.from)<0){o.from=l.from;break}}n.push(o)}hn(e,function(){for(var t=n.length-1;t>=0;t--)Ei(e.doc,"",n[t].from,n[t].to,"+delete");jr(e)})}function fo(e,t,r){var n=L(e.text,t+r,r);return n<0||n>e.text.length?null:n}function ho(e,t,r){var n=fo(e,t.ch,r);return null==n?null:new E(t.line,n,r<0?"after":"before")}function po(e,t,r,n,i){if(e){var o=Se(r,t.doc.direction);if(o){var l,s=i<0?g(o):o[0],a=i<0==(1==s.level)?"after":"before";if(s.level>0){var u=Xt(t,r);l=i<0?r.text.length-1:0;var c=Yt(t,u,l).top;l=k(function(e){return Yt(t,u,e).top==c},i<0==(1==s.level)?s.from:s.to-1,l),"before"==a&&(l=fo(r,l,1))}else l=i<0?s.to:s.from;return new E(n,l,a)}}return new E(n,i<0?r.text.length:0,i<0?"before":"after")}function go(e,t,r,n){var i=Se(t,e.doc.direction);if(!i)return ho(t,r,n);r.ch>=t.text.length?(r.ch=t.text.length,r.sticky="before"):r.ch<=0&&(r.ch=0,r.sticky="after");var o=Ce(i,r.ch,r.sticky),l=i[o];if("ltr"==e.doc.direction&&l.level%2==0&&(n>0?l.to>r.ch:l.from<r.ch))return ho(t,r,n);var s,a=function(e,r){return fo(t,e instanceof E?e.ch:e,r)},u=function(r){return e.options.lineWrapping?(s=s||Xt(e,t),hr(e,t,s,r)):{begin:0,end:t.text.length}},c=u("before"==r.sticky?a(r,-1):r.ch);if("rtl"==e.doc.direction||1==l.level){var f=1==l.level==n<0,h=a(r,f?1:-1);if(null!=h&&(f?h<=l.to&&h<=c.end:h>=l.from&&h>=c.begin)){var d=f?"before":"after";return new E(r.line,h,d)}}var p=function(e,t,n){for(var o=function(e,t){return t?new E(r.line,a(e,1),"before"):new E(r.line,e,"after")};e>=0&&e<i.length;e+=t){var l=i[e],s=t>0==(1!=l.level),u=s?n.begin:a(n.end,-1);if(l.from<=u&&u<l.to)return o(u,s);if(u=s?l.from:a(l.to,-1),n.begin<=u&&u<n.end)return o(u,s)}},g=p(o+n,n,c);if(g)return g;var v=n>0?c.end:a(c.begin,-1);return null==v||n>0&&v==t.text.length||!(g=p(n>0?0:i.length-1,n,u(v)))?null:g}function vo(e,t){var r=M(e.doc,t),n=fe(r);return n!=r&&(t=W(n)),po(!0,e,n,t,1)}function mo(e,t){var r=M(e.doc,t),n=he(r);return n!=r&&(t=W(n)),po(!0,e,r,t,-1)}function yo(e,t){var r=vo(e,t.line),n=M(e.doc,r.line),i=Se(n,e.doc.direction);if(!i||0==i[0].level){var o=Math.max(0,n.text.search(/\S/)),l=t.line==r.line&&t.ch<=o&&t.ch;return E(r.line,l?0:o,r.sticky)}return r}function bo(e,t,r){if("string"==typeof t&&!(t=Bs[t]))return!1;e.display.input.ensurePolled();var n=e.display.shift,i=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),r&&(e.display.shift=!1),i=t(e)!=Bl}finally{e.display.shift=n,e.state.suppressEdits=!1}return i}function wo(e,t,r){for(var n=0;n<e.state.keyMaps.length;n++){var i=oo(t,e.state.keyMaps[n],r,e);if(i)return i}return e.options.extraKeys&&oo(t,e.options.extraKeys,r,e)||oo(t,e.options.keyMap,r,e)}function xo(e,t,r,n){var i=e.state.keySeq;if(i){if(lo(t))return"handled";Gs.set(50,function(){e.state.keySeq==i&&(e.state.keySeq=null,e.display.input.reset())}),t=i+" "+t}var o=wo(e,t,n);return"multi"==o&&(e.state.keySeq=t),"handled"==o&&bt(e,"keyHandled",e,t,r),"handled"!=o&&"multi"!=o||(We(r),Ar(e)),i&&!o&&/\'$/.test(t)?(We(r),!0):!!o}function Co(e,t){var r=ao(t,!0);return!!r&&(t.shiftKey&&!e.state.keySeq?xo(e,"Shift-"+r,t,function(t){return bo(e,t,!0)})||xo(e,r,t,function(t){if("string"==typeof t?/^go[A-Z]/.test(t):t.motion)return bo(e,t)}):xo(e,r,t,function(t){return bo(e,t)}))}function So(e,t,r){return xo(e,"'"+r+"'",t,function(t){return bo(e,t,!0)})}function Lo(e){var t=this;if(t.curOp.focus=l(),!Me(t,e)){gl&&vl<11&&27==e.keyCode&&(e.returnValue=!1);var r=e.keyCode;t.display.shift=16==r||e.shiftKey;var n=Co(t,e);wl&&(Us=n?r:null,!n&&88==r&&!rs&&(Ml?e.metaKey:e.ctrlKey)&&t.replaceSelection("",null,"cut")),18!=r||/\bCodeMirror-crosshair\b/.test(t.display.lineDiv.className)||ko(t)}}function ko(e){function t(e){18!=e.keyCode&&e.altKey||(Fl(r,"CodeMirror-crosshair"),ke(document,"keyup",t),ke(document,"mouseover",t))}var r=e.display.lineDiv;s(r,"CodeMirror-crosshair"),Ql(document,"keyup",t),Ql(document,"mouseover",t)}function To(e){16==e.keyCode&&(this.doc.sel.shift=!1),Me(this,e)}function Mo(e){var t=this;if(!(Ft(t.display,e)||Me(t,e)||e.ctrlKey&&!e.altKey||Ml&&e.metaKey)){var r=e.keyCode,n=e.charCode;if(wl&&r==Us)return Us=null,void We(e);if(!wl||e.which&&!(e.which<10)||!Co(t,e)){var i=String.fromCharCode(null==n?r:n);"\b"!=i&&(So(t,e,i)||t.display.input.onKeyPress(e))}}}function No(e,t){var r=+new Date;return js&&js.compare(r,e,t)?(Ks=js=null,"triple"):Ks&&Ks.compare(r,e,t)?(js=new Vs(r,e,t),Ks=null,"double"):(Ks=new Vs(r,e,t),js=null,"single")}function Oo(e){var t=this,r=t.display;if(!(Me(t,e)||r.activeTouch&&r.input.supportsTouch()))if(r.input.ensurePolled(),r.shift=e.shiftKey,Ft(r,e))ml||(r.scroller.draggable=!1,setTimeout(function(){return r.scroller.draggable=!0},100));else if(!zo(t,e)){var n=Sr(t,e),i=Pe(e),o=n?No(n,i):"single";window.focus(),1==i&&t.state.selectingText&&t.state.selectingText(e),n&&Ao(t,i,n,o,e)||(1==i?n?Do(t,n,o,e):Ee(e)==r.scroller&&We(e):2==i?(n&&di(t.doc,n),setTimeout(function(){return r.input.focus()},20)):3==i&&(Hl?Ro(t,e):Dr(t)))}}function Ao(e,t,r,n,i){var o="Click";return"double"==n?o="Double"+o:"triple"==n&&(o="Triple"+o),o=(1==t?"Left":2==t?"Middle":"Right")+o,xo(e,so(o,i),i,function(t){if("string"==typeof t&&(t=Bs[t]),!t)return!1;var n=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),n=t(e,r)!=Bl}finally{e.state.suppressEdits=!1}return n})}function Wo(e,t,r){var n=e.getOption("configureMouse"),i=n?n(e,t,r):{};if(null==i.unit){var o=Nl?r.shiftKey&&r.metaKey:r.altKey;i.unit=o?"rectangle":"single"==t?"char":"double"==t?"word":"line"}return(null==i.extend||e.doc.extend)&&(i.extend=e.doc.extend||r.shiftKey),null==i.addNew&&(i.addNew=Ml?r.metaKey:r.ctrlKey),null==i.moveOnDrag&&(i.moveOnDrag=!(Ml?r.altKey:r.ctrlKey)),i}function Do(e,t,r,n){gl?setTimeout(u(Wr,e),0):e.curOp.focus=l();var i,o=Wo(e,r,n),s=e.doc.sel;e.options.dragDrop&&Jl&&!e.isReadOnly()&&"single"==r&&(i=s.contains(t))>-1&&(P((i=s.ranges[i]).from(),t)<0||t.xRel>0)&&(P(i.to(),t)>0||t.xRel<0)?Ho(e,n,t,o):Eo(e,n,t,o)}function Ho(e,t,r,n){var i=e.display,o=!1,l=dn(e,function(t){ml&&(i.scroller.draggable=!1),e.state.draggingText=!1,ke(document,"mouseup",l),ke(document,"mousemove",s),ke(i.scroller,"dragstart",a),ke(i.scroller,"drop",l),o||(We(t),n.addNew||di(e.doc,r,null,null,n.extend),ml||gl&&9==vl?setTimeout(function(){document.body.focus(),i.input.focus()},20):i.input.focus())}),s=function(e){o=o||Math.abs(t.clientX-e.clientX)+Math.abs(t.clientY-e.clientY)>=10},a=function(){return o=!0};ml&&(i.scroller.draggable=!0),e.state.draggingText=l,l.copy=!n.moveOnDrag,i.scroller.dragDrop&&i.scroller.dragDrop(),Ql(document,"mouseup",l),Ql(document,"mousemove",s),Ql(i.scroller,"dragstart",a),Ql(i.scroller,"drop",l),Dr(e),setTimeout(function(){return i.input.focus()},20)}function Fo(e,t,r){if("char"==r)return new Ts(t,t);if("word"==r)return e.findWordAt(t);if("line"==r)return new Ts(E(t.line,0),U(e.doc,E(t.line+1,0)));var n=r(e,t);return new Ts(n.from,n.to)}function Eo(e,t,r,n){function i(t){if(0!=P(m,t))if(m=t,"rectangle"==n.unit){for(var i=[],o=e.options.tabSize,l=f(M(u,r.line).text,r.ch,o),s=f(M(u,t.line).text,t.ch,o),a=Math.min(l,s),g=Math.max(l,s),v=Math.min(r.line,t.line),y=Math.min(e.lastLine(),Math.max(r.line,t.line));v<=y;v++){var b=M(u,v).text,w=d(b,a,o);a==g?i.push(new Ts(E(v,w),E(v,w))):b.length>w&&i.push(new Ts(E(v,w),E(v,d(b,g,o))))}i.length||i.push(new Ts(r,r)),bi(u,zn(p.ranges.slice(0,h).concat(i),h),{origin:"*mouse",scroll:!1}),e.scrollIntoView(t)}else{var x,C=c,S=Fo(e,t,n.unit),L=C.anchor;P(S.anchor,L)>0?(x=S.head,L=B(C.from(),S.anchor)):(x=S.anchor,L=R(C.to(),S.head));var k=p.ranges.slice(0);k[h]=Po(e,new Ts(U(u,L),x)),bi(u,zn(k,h),Ul)}}function o(t){var r=++b,s=Sr(e,t,!0,"rectangle"==n.unit);if(s)if(0!=P(s,m)){e.curOp.focus=l(),i(s);var c=Ir(a,u);(s.line>=c.to||s.line<c.from)&&setTimeout(dn(e,function(){b==r&&o(t)}),150)}else{var f=t.clientY<y.top?-20:t.clientY>y.bottom?20:0;f&&setTimeout(dn(e,function(){b==r&&(a.scroller.scrollTop+=f,o(t))}),50)}}function s(t){e.state.selectingText=!1,b=1/0,We(t),a.input.focus(),ke(document,"mousemove",w),ke(document,"mouseup",x),u.history.lastSelOrigin=null}var a=e.display,u=e.doc;We(t);var c,h,p=u.sel,g=p.ranges;if(n.addNew&&!n.extend?(h=u.sel.contains(r),c=h>-1?g[h]:new Ts(r,r)):(c=u.sel.primary(),h=u.sel.primIndex),"rectangle"==n.unit)n.addNew||(c=new Ts(r,r)),r=Sr(e,t,!0,!0),h=-1;else{var v=Fo(e,r,n.unit);c=n.extend?hi(c,v.anchor,v.head,n.extend):v}n.addNew?-1==h?(h=g.length,bi(u,zn(g.concat([c]),h),{scroll:!1,origin:"*mouse"})):g.length>1&&g[h].empty()&&"char"==n.unit&&!n.extend?(bi(u,zn(g.slice(0,h).concat(g.slice(h+1)),0),{scroll:!1,origin:"*mouse"}),p=u.sel):gi(u,h,c,Ul):(h=0,bi(u,new ks([c],0),Ul),p=u.sel);var m=r,y=a.wrapper.getBoundingClientRect(),b=0,w=dn(e,function(e){Pe(e)?o(e):s(e)}),x=dn(e,s);e.state.selectingText=x,Ql(document,"mousemove",w),Ql(document,"mouseup",x)}function Po(e,t){var r=t.anchor,n=t.head,i=M(e.doc,r.line);if(0==P(r,n)&&r.sticky==n.sticky)return t;var o=Se(i);if(!o)return t;var l=Ce(o,r.ch,r.sticky),s=o[l];if(s.from!=r.ch&&s.to!=r.ch)return t;var a=l+(s.from==r.ch==(1!=s.level)?0:1);if(0==a||a==o.length)return t;var u;if(n.line!=r.line)u=(n.line-r.line)*("ltr"==e.doc.direction?1:-1)>0;else{var c=Ce(o,n.ch,n.sticky),f=c-l||(n.ch-r.ch)*(1==s.level?-1:1);u=c==a-1||c==a?f<0:f>0}var h=o[a+(u?-1:0)],d=u==(1==h.level),p=d?h.from:h.to,g=d?"after":"before";return r.ch==p&&r.sticky==g?t:new Ts(new E(r.line,p,g),n)}function Io(e,t,r,n){var i,o;if(t.touches)i=t.touches[0].clientX,o=t.touches[0].clientY;else try{i=t.clientX,o=t.clientY}catch(t){return!1}if(i>=Math.floor(e.display.gutters.getBoundingClientRect().right))return!1;n&&We(t);var l=e.display,s=l.lineDiv.getBoundingClientRect();if(o>s.bottom||!Oe(e,r))return He(t);o-=s.top-l.viewOffset;for(var a=0;a<e.options.gutters.length;++a){var u=l.gutters.childNodes[a];if(u&&u.getBoundingClientRect().right>=i)return Te(e,r,e,D(e.doc,o),e.options.gutters[a],t),He(t)}}function zo(e,t){return Io(e,t,"gutterClick",!0)}function Ro(e,t){Ft(e.display,t)||Bo(e,t)||Me(e,t,"contextmenu")||e.display.input.onContextMenu(t)}function Bo(e,t){return!!Oe(e,"gutterContextMenu")&&Io(e,t,"gutterContextMenu",!1)}function Go(e){e.display.wrapper.className=e.display.wrapper.className.replace(/\s*cm-s-\S+/g,"")+e.options.theme.replace(/(^|\s)\s*/g," cm-s-"),er(e)}function Uo(e){Hn(e),vn(e),zr(e)}function Vo(e,t,r){if(!t!=!(r&&r!=Xs)){var n=e.display.dragFunctions,i=t?Ql:ke;i(e.display.scroller,"dragstart",n.start),i(e.display.scroller,"dragenter",n.enter),i(e.display.scroller,"dragover",n.over),i(e.display.scroller,"dragleave",n.leave),i(e.display.scroller,"drop",n.drop)}}function Ko(e){e.options.lineWrapping?(s(e.display.wrapper,"CodeMirror-wrap"),e.display.sizer.style.minWidth="",e.display.sizerWidth=null):(Fl(e.display.wrapper,"CodeMirror-wrap"),we(e)),Cr(e),vn(e),er(e),setTimeout(function(){return en(e)},100)}function jo(e,t){var r=this;if(!(this instanceof jo))return new jo(e,t);this.options=t=t?c(t):{},c(Ys,t,!1),Fn(t);var n=t.value;"string"==typeof n&&(n=new Ds(n,t.mode,null,t.lineSeparator,t.direction)),this.doc=n;var i=new jo.inputStyles[t.inputStyle](this),o=this.display=new T(e,n,i);o.wrapper.CodeMirror=this,Hn(this),Go(this),t.lineWrapping&&(this.display.wrapper.className+=" CodeMirror-wrap"),rn(this),this.state={keyMaps:[],overlays:[],modeGen:0,overwrite:!1,delayingBlurEvent:!1,focused:!1,suppressEdits:!1,pasteIncoming:!1,cutIncoming:!1,selectingText:!1,draggingText:!1,highlight:new Pl,keySeq:null,specialChars:null},t.autofocus&&!Tl&&o.input.focus(),gl&&vl<11&&setTimeout(function(){return r.display.input.reset(!0)},20),Xo(this),eo(),nn(this),this.curOp.forceUpdate=!0,qn(this,n),t.autofocus&&!Tl||this.hasFocus()?setTimeout(u(Hr,this),20):Fr(this);for(var l in _s)_s.hasOwnProperty(l)&&_s[l](r,t[l],Xs);Rr(this),t.finishInit&&t.finishInit(this);for(var s=0;s<$s.length;++s)$s[s](r);on(this),ml&&t.lineWrapping&&"optimizelegibility"==getComputedStyle(o.lineDiv).textRendering&&(o.lineDiv.style.textRendering="auto")}function Xo(e){function t(){i.activeTouch&&(o=setTimeout(function(){return i.activeTouch=null},1e3),(l=i.activeTouch).end=+new Date)}function r(e){if(1!=e.touches.length)return!1;var t=e.touches[0];return t.radiusX<=1&&t.radiusY<=1}function n(e,t){if(null==t.left)return!0;var r=t.left-e.left,n=t.top-e.top;return r*r+n*n>400}var i=e.display;Ql(i.scroller,"mousedown",dn(e,Oo)),gl&&vl<11?Ql(i.scroller,"dblclick",dn(e,function(t){if(!Me(e,t)){var r=Sr(e,t);if(r&&!zo(e,t)&&!Ft(e.display,t)){We(t);var n=e.findWordAt(r);di(e.doc,n.anchor,n.head)}}})):Ql(i.scroller,"dblclick",function(t){return Me(e,t)||We(t)}),Hl||Ql(i.scroller,"contextmenu",function(t){return Ro(e,t)});var o,l={end:0};Ql(i.scroller,"touchstart",function(t){if(!Me(e,t)&&!r(t)&&!zo(e,t)){i.input.ensurePolled(),clearTimeout(o);var n=+new Date;i.activeTouch={start:n,moved:!1,prev:n-l.end<=300?l:null},1==t.touches.length&&(i.activeTouch.left=t.touches[0].pageX,i.activeTouch.top=t.touches[0].pageY)}}),Ql(i.scroller,"touchmove",function(){i.activeTouch&&(i.activeTouch.moved=!0)}),Ql(i.scroller,"touchend",function(r){var o=i.activeTouch;if(o&&!Ft(i,r)&&null!=o.left&&!o.moved&&new Date-o.start<300){var l,s=e.coordsChar(i.activeTouch,"page");l=!o.prev||n(o,o.prev)?new Ts(s,s):!o.prev.prev||n(o,o.prev.prev)?e.findWordAt(s):new Ts(E(s.line,0),U(e.doc,E(s.line+1,0))),e.setSelection(l.anchor,l.head),e.focus(),We(r)}t()}),Ql(i.scroller,"touchcancel",t),Ql(i.scroller,"scroll",function(){i.scroller.clientHeight&&(qr(e,i.scroller.scrollTop),Qr(e,i.scroller.scrollLeft,!0),Te(e,"scroll",e))}),Ql(i.scroller,"mousewheel",function(t){return In(e,t)}),Ql(i.scroller,"DOMMouseScroll",function(t){return In(e,t)}),Ql(i.wrapper,"scroll",function(){return i.wrapper.scrollTop=i.wrapper.scrollLeft=0}),i.dragFunctions={enter:function(t){Me(e,t)||Fe(t)},over:function(t){Me(e,t)||(Zi(e,t),Fe(t))},start:function(t){return qi(e,t)},drop:dn(e,$i),leave:function(t){Me(e,t)||Qi(e)}};var s=i.input.getField();Ql(s,"keyup",function(t){return To.call(e,t)}),Ql(s,"keydown",dn(e,Lo)),Ql(s,"keypress",dn(e,Mo)),Ql(s,"focus",function(t){return Hr(e,t)}),Ql(s,"blur",function(t){return Fr(e,t)})}function Yo(e,t,r,n){var i,o=e.doc;null==r&&(r="add"),"smart"==r&&(o.mode.indent?i=$e(e,t).state:r="prev");var l=e.options.tabSize,s=M(o,t),a=f(s.text,null,l);s.stateAfter&&(s.stateAfter=null);var u,c=s.text.match(/^\s*/)[0];if(n||/\S/.test(s.text)){if("smart"==r&&((u=o.mode.indent(i,s.text.slice(c.length),s.text))==Bl||u>150)){if(!n)return;r="prev"}}else u=0,r="not";"prev"==r?u=t>o.first?f(M(o,t-1).text,null,l):0:"add"==r?u=a+e.options.indentUnit:"subtract"==r?u=a-e.options.indentUnit:"number"==typeof r&&(u=a+r),u=Math.max(0,u);var h="",d=0;if(e.options.indentWithTabs)for(var g=Math.floor(u/l);g;--g)d+=l,h+="\t";if(d<u&&(h+=p(u-d)),h!=c)return Ei(o,h,E(t,0),E(t,c.length),"+input"),s.stateAfter=null,!0;for(var v=0;v<o.sel.ranges.length;v++){var m=o.sel.ranges[v];if(m.head.line==t&&m.head.ch<c.length){var y=E(t,c.length);gi(o,v,new Ts(y,y));break}}}function _o(e){qs=e}function $o(e,t,r,n,i){var o=e.doc;e.display.shift=!1,n||(n=o.sel);var l=e.state.pasteIncoming||"paste"==i,s=es(t),a=null;if(l&&n.ranges.length>1)if(qs&&qs.text.join("\n")==t){if(n.ranges.length%qs.text.length==0){a=[];for(var u=0;u<qs.text.length;u++)a.push(o.splitLines(qs.text[u]))}}else s.length==n.ranges.length&&e.options.pasteLinesPerSelection&&(a=v(s,function(e){return[e]}));for(var c,f=n.ranges.length-1;f>=0;f--){var h=n.ranges[f],d=h.from(),p=h.to();h.empty()&&(r&&r>0?d=E(d.line,d.ch-r):e.state.overwrite&&!l?p=E(p.line,Math.min(M(o,p.line).text.length,p.ch+g(s).length)):qs&&qs.lineWise&&qs.text.join("\n")==t&&(d=p=E(d.line,0))),c=e.curOp.updateInput;var m={from:d,to:p,text:a?a[f%a.length]:s,origin:i||(l?"paste":e.state.cutIncoming?"cut":"+input")};Oi(e.doc,m),bt(e,"inputRead",e,m)}t&&!l&&Zo(e,t),jr(e),e.curOp.updateInput=c,e.curOp.typing=!0,e.state.pasteIncoming=e.state.cutIncoming=!1}function qo(e,t){var r=e.clipboardData&&e.clipboardData.getData("Text");if(r)return e.preventDefault(),t.isReadOnly()||t.options.disableInput||hn(t,function(){return $o(t,r,0,null,"paste")}),!0}function Zo(e,t){if(e.options.electricChars&&e.options.smartIndent)for(var r=e.doc.sel,n=r.ranges.length-1;n>=0;n--){var i=r.ranges[n];if(!(i.head.ch>100||n&&r.ranges[n-1].head.line==i.head.line)){var o=e.getModeAt(i.head),l=!1;if(o.electricChars){for(var s=0;s<o.electricChars.length;s++)if(t.indexOf(o.electricChars.charAt(s))>-1){l=Yo(e,i.head.line,"smart");break}}else o.electricInput&&o.electricInput.test(M(e.doc,i.head.line).text.slice(0,i.head.ch))&&(l=Yo(e,i.head.line,"smart"));l&&bt(e,"electricInput",e,i.head.line)}}}function Qo(e){for(var t=[],r=[],n=0;n<e.doc.sel.ranges.length;n++){var i=e.doc.sel.ranges[n].head.line,o={anchor:E(i,0),head:E(i+1,0)};r.push(o),t.push(e.getRange(o.anchor,o.head))}return{text:t,ranges:r}}function Jo(e,t){e.setAttribute("autocorrect","off"),e.setAttribute("autocapitalize","off"),e.setAttribute("spellcheck",!!t)}function el(){var e=n("textarea",null,null,"position: absolute; bottom: -1em; padding: 0; width: 1px; height: 1em; outline: none"),t=n("div",[e],null,"overflow: hidden; position: relative; width: 3px; height: 0px;");return ml?e.style.width="1000px":e.setAttribute("wrap","off"),Ll&&(e.style.border="1px solid black"),Jo(e),t}function tl(e,t,r,n,i){function o(){var n=t.line+r;return!(n<e.first||n>=e.first+e.size)&&(t=new E(n,t.ch,t.sticky),u=M(e,n))}function l(n){var l;if(null==(l=i?go(e.cm,u,t,r):ho(u,t,r))){if(n||!o())return!1;t=po(i,e.cm,u,t.line,r)}else t=l;return!0}var s=t,a=r,u=M(e,t.line);if("char"==n)l();else if("column"==n)l(!0);else if("word"==n||"group"==n)for(var c=null,f="group"==n,h=e.cm&&e.cm.getHelper(t,"wordChars"),d=!0;!(r<0)||l(!d);d=!1){var p=u.text.charAt(t.ch)||"\n",g=x(p,h)?"w":f&&"\n"==p?"n":!f||/\s/.test(p)?null:"p";if(!f||d||g||(g="s"),c&&c!=g){r<0&&(r=1,l(),t.sticky="after");break}if(g&&(c=g),r>0&&!l(!d))break}var v=ki(e,t,s,a,!0);return I(s,v)&&(v.hitSide=!0),v}function rl(e,t,r,n){var i,o=e.doc,l=t.left;if("page"==n){var s=Math.min(e.display.wrapper.clientHeight,window.innerHeight||document.documentElement.clientHeight),a=Math.max(s-.5*mr(e.display),3);i=(r>0?t.bottom:t.top)+r*a}else"line"==n&&(i=r>0?t.bottom+3:t.top-3);for(var u;(u=cr(e,l,i)).outside;){if(r<0?i<=0:i>=o.height){u.hitSide=!0;break}i+=5*r}return u}function nl(e,t){var r=jt(e,t.line);if(!r||r.hidden)return null;var n=M(e.doc,t.line),i=Ut(r,n,t.line),o=Se(n,e.doc.direction),l="left";o&&(l=Ce(o,t.ch)%2?"right":"left");var s=_t(i.map,t.ch,l);return s.offset="right"==s.collapse?s.end:s.start,s}function il(e){for(var t=e;t;t=t.parentNode)if(/CodeMirror-gutter-wrapper/.test(t.className))return!0;return!1}function ol(e,t){return t&&(e.bad=!0),e}function ll(e,t,r,n,i){function o(e){return function(t){return t.id==e}}function l(){c&&(u+=f,c=!1)}function s(e){e&&(l(),u+=e)}function a(t){if(1==t.nodeType){var r=t.getAttribute("cm-text");if(null!=r)return void s(r||t.textContent.replace(/\u200b/g,""));var u,h=t.getAttribute("cm-marker");if(h){var d=e.findMarks(E(n,0),E(i+1,0),o(+h));return void(d.length&&(u=d[0].find(0))&&s(N(e.doc,u.from,u.to).join(f)))}if("false"==t.getAttribute("contenteditable"))return;var p=/^(pre|div|p)$/i.test(t.nodeName);p&&l();for(var g=0;g<t.childNodes.length;g++)a(t.childNodes[g]);p&&(c=!0)}else 3==t.nodeType&&s(t.nodeValue)}for(var u="",c=!1,f=e.doc.lineSeparator();a(t),t!=r;)t=t.nextSibling;return u}function sl(e,t,r){var n;if(t==e.display.lineDiv){if(!(n=e.display.lineDiv.childNodes[r]))return ol(e.clipPos(E(e.display.viewTo-1)),!0);t=null,r=0}else for(n=t;;n=n.parentNode){if(!n||n==e.display.lineDiv)return null;if(n.parentNode&&n.parentNode==e.display.lineDiv)break}for(var i=0;i<e.display.view.length;i++){var o=e.display.view[i];if(o.node==n)return al(o,t,r)}}function al(e,t,r){function n(t,r,n){for(var i=-1;i<(f?f.length:0);i++)for(var o=i<0?c.map:f[i],l=0;l<o.length;l+=3){var s=o[l+2];if(s==t||s==r){var a=W(i<0?e.line:e.rest[i]),u=o[l]+n;return(n<0||s!=t)&&(u=o[l+(n?1:0)]),E(a,u)}}}var i=e.text.firstChild,l=!1;if(!t||!o(i,t))return ol(E(W(e.line),0),!0);if(t==i&&(l=!0,t=i.childNodes[r],r=0,!t)){var s=e.rest?g(e.rest):e.line;return ol(E(W(s),s.text.length),l)}var a=3==t.nodeType?t:null,u=t;for(a||1!=t.childNodes.length||3!=t.firstChild.nodeType||(a=t.firstChild,r&&(r=a.nodeValue.length));u.parentNode!=i;)u=u.parentNode;var c=e.measure,f=c.maps,h=n(a,u,r);if(h)return ol(h,l);for(var d=u.nextSibling,p=a?a.nodeValue.length-r:0;d;d=d.nextSibling){if(h=n(d,d.firstChild,0))return ol(E(h.line,h.ch-p),l);p+=d.textContent.length}for(var v=u.previousSibling,m=r;v;v=v.previousSibling){if(h=n(v,v.firstChild,-1))return ol(E(h.line,h.ch+m),l);m+=v.textContent.length}}var ul=navigator.userAgent,cl=navigator.platform,fl=/gecko\/\d/i.test(ul),hl=/MSIE \d/.test(ul),dl=/Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(ul),pl=/Edge\/(\d+)/.exec(ul),gl=hl||dl||pl,vl=gl&&(hl?document.documentMode||6:+(pl||dl)[1]),ml=!pl&&/WebKit\//.test(ul),yl=ml&&/Qt\/\d+\.\d+/.test(ul),bl=!pl&&/Chrome\//.test(ul),wl=/Opera\//.test(ul),xl=/Apple Computer/.test(navigator.vendor),Cl=/Mac OS X 1\d\D([8-9]|\d\d)\D/.test(ul),Sl=/PhantomJS/.test(ul),Ll=!pl&&/AppleWebKit/.test(ul)&&/Mobile\/\w+/.test(ul),kl=/Android/.test(ul),Tl=Ll||kl||/webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(ul),Ml=Ll||/Mac/.test(cl),Nl=/\bCrOS\b/.test(ul),Ol=/win/i.test(cl),Al=wl&&ul.match(/Version\/(\d*\.\d*)/);Al&&(Al=Number(Al[1])),Al&&Al>=15&&(wl=!1,ml=!0);var Wl,Dl=Ml&&(yl||wl&&(null==Al||Al<12.11)),Hl=fl||gl&&vl>=9,Fl=function(t,r){var n=t.className,i=e(r).exec(n);if(i){var o=n.slice(i.index+i[0].length);t.className=n.slice(0,i.index)+(o?i[1]+o:"")}};Wl=document.createRange?function(e,t,r,n){var i=document.createRange();return i.setEnd(n||e,r),i.setStart(e,t),i}:function(e,t,r){var n=document.body.createTextRange();try{n.moveToElementText(e.parentNode)}catch(e){return n}return n.collapse(!0),n.moveEnd("character",r),n.moveStart("character",t),n};var El=function(e){e.select()};Ll?El=function(e){e.selectionStart=0,e.selectionEnd=e.value.length}:gl&&(El=function(e){try{e.select()}catch(e){}});var Pl=function(){this.id=null};Pl.prototype.set=function(e,t){clearTimeout(this.id),this.id=setTimeout(t,e)};var Il,zl,Rl=30,Bl={toString:function(){return"CodeMirror.Pass"}},Gl={scroll:!1},Ul={origin:"*mouse"},Vl={origin:"+move"},Kl=[""],jl=/[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/,Xl=/[\u0300-\u036f\u0483-\u0489\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u065e\u0670\u06d6-\u06dc\u06de-\u06e4\u06e7\u06e8\u06ea-\u06ed\u0711\u0730-\u074a\u07a6-\u07b0\u07eb-\u07f3\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0900-\u0902\u093c\u0941-\u0948\u094d\u0951-\u0955\u0962\u0963\u0981\u09bc\u09be\u09c1-\u09c4\u09cd\u09d7\u09e2\u09e3\u0a01\u0a02\u0a3c\u0a41\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a70\u0a71\u0a75\u0a81\u0a82\u0abc\u0ac1-\u0ac5\u0ac7\u0ac8\u0acd\u0ae2\u0ae3\u0b01\u0b3c\u0b3e\u0b3f\u0b41-\u0b44\u0b4d\u0b56\u0b57\u0b62\u0b63\u0b82\u0bbe\u0bc0\u0bcd\u0bd7\u0c3e-\u0c40\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0cbc\u0cbf\u0cc2\u0cc6\u0ccc\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0d3e\u0d41-\u0d44\u0d4d\u0d57\u0d62\u0d63\u0dca\u0dcf\u0dd2-\u0dd4\u0dd6\u0ddf\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0eb1\u0eb4-\u0eb9\u0ebb\u0ebc\u0ec8-\u0ecd\u0f18\u0f19\u0f35\u0f37\u0f39\u0f71-\u0f7e\u0f80-\u0f84\u0f86\u0f87\u0f90-\u0f97\u0f99-\u0fbc\u0fc6\u102d-\u1030\u1032-\u1037\u1039\u103a\u103d\u103e\u1058\u1059\u105e-\u1060\u1071-\u1074\u1082\u1085\u1086\u108d\u109d\u135f\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b7-\u17bd\u17c6\u17c9-\u17d3\u17dd\u180b-\u180d\u18a9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193b\u1a17\u1a18\u1a56\u1a58-\u1a5e\u1a60\u1a62\u1a65-\u1a6c\u1a73-\u1a7c\u1a7f\u1b00-\u1b03\u1b34\u1b36-\u1b3a\u1b3c\u1b42\u1b6b-\u1b73\u1b80\u1b81\u1ba2-\u1ba5\u1ba8\u1ba9\u1c2c-\u1c33\u1c36\u1c37\u1cd0-\u1cd2\u1cd4-\u1ce0\u1ce2-\u1ce8\u1ced\u1dc0-\u1de6\u1dfd-\u1dff\u200c\u200d\u20d0-\u20f0\u2cef-\u2cf1\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua66f-\ua672\ua67c\ua67d\ua6f0\ua6f1\ua802\ua806\ua80b\ua825\ua826\ua8c4\ua8e0-\ua8f1\ua926-\ua92d\ua947-\ua951\ua980-\ua982\ua9b3\ua9b6-\ua9b9\ua9bc\uaa29-\uaa2e\uaa31\uaa32\uaa35\uaa36\uaa43\uaa4c\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uabe5\uabe8\uabed\udc00-\udfff\ufb1e\ufe00-\ufe0f\ufe20-\ufe26\uff9e\uff9f]/,Yl=!1,_l=!1,$l=null,ql=function(){function e(e){return e<=247?r.charAt(e):1424<=e&&e<=1524?"R":1536<=e&&e<=1785?n.charAt(e-1536):1774<=e&&e<=2220?"r":8192<=e&&e<=8203?"w":8204==e?"b":"L"}function t(e,t,r){this.level=e,this.from=t,this.to=r}var r="bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLN",n="nnnnnnNNr%%r,rNNmmmmmmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmmmnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmnNmmmmmmrrmmNmmmmrr1111111111",i=/[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/,o=/[stwN]/,l=/[LRr]/,s=/[Lb1n]/,a=/[1n]/;return function(r,n){var u="ltr"==n?"L":"R";if(0==r.length||"ltr"==n&&!i.test(r))return!1;for(var c=r.length,f=[],h=0;h<c;++h)f.push(e(r.charCodeAt(h)));for(var d=0,p=u;d<c;++d){var v=f[d];"m"==v?f[d]=p:p=v}for(var m=0,y=u;m<c;++m){var b=f[m];"1"==b&&"r"==y?f[m]="n":l.test(b)&&(y=b,"r"==b&&(f[m]="R"))}for(var w=1,x=f[0];w<c-1;++w){var C=f[w];"+"==C&&"1"==x&&"1"==f[w+1]?f[w]="1":","!=C||x!=f[w+1]||"1"!=x&&"n"!=x||(f[w]=x),x=C}for(var S=0;S<c;++S){var L=f[S];if(","==L)f[S]="N";else if("%"==L){var k=void 0;for(k=S+1;k<c&&"%"==f[k];++k);for(var T=S&&"!"==f[S-1]||k<c&&"1"==f[k]?"1":"N",M=S;M<k;++M)f[M]=T;S=k-1}}for(var N=0,O=u;N<c;++N){var A=f[N];"L"==O&&"1"==A?f[N]="L":l.test(A)&&(O=A)}for(var W=0;W<c;++W)if(o.test(f[W])){var D=void 0;for(D=W+1;D<c&&o.test(f[D]);++D);for(var H="L"==(W?f[W-1]:u),F=H==("L"==(D<c?f[D]:u))?H?"L":"R":u,E=W;E<D;++E)f[E]=F;W=D-1}for(var P,I=[],z=0;z<c;)if(s.test(f[z])){var R=z;for(++z;z<c&&s.test(f[z]);++z);I.push(new t(0,R,z))}else{var B=z,G=I.length;for(++z;z<c&&"L"!=f[z];++z);for(var U=B;U<z;)if(a.test(f[U])){B<U&&I.splice(G,0,new t(1,B,U));var V=U;for(++U;U<z&&a.test(f[U]);++U);I.splice(G,0,new t(2,V,U)),B=U}else++U;B<z&&I.splice(G,0,new t(1,B,z))}return 1==I[0].level&&(P=r.match(/^\s+/))&&(I[0].from=P[0].length,I.unshift(new t(0,0,P[0].length))),1==g(I).level&&(P=r.match(/\s+$/))&&(g(I).to-=P[0].length,I.push(new t(0,c-P[0].length,c))),"rtl"==n?I.reverse():I}}(),Zl=[],Ql=function(e,t,r){if(e.addEventListener)e.addEventListener(t,r,!1);else if(e.attachEvent)e.attachEvent("on"+t,r);else{var n=e._handlers||(e._handlers={});n[t]=(n[t]||Zl).concat(r)}},Jl=function(){if(gl&&vl<9)return!1;var e=n("div");return"draggable"in e||"dragDrop"in e}(),es=3!="\n\nb".split(/\n/).length?function(e){for(var t=0,r=[],n=e.length;t<=n;){var i=e.indexOf("\n",t);-1==i&&(i=e.length);var o=e.slice(t,"\r"==e.charAt(i-1)?i-1:i),l=o.indexOf("\r");-1!=l?(r.push(o.slice(0,l)),t+=l+1):(r.push(o),t=i+1)}return r}:function(e){return e.split(/\r\n?|\n/)},ts=window.getSelection?function(e){try{return e.selectionStart!=e.selectionEnd}catch(e){return!1}}:function(e){var t;try{t=e.ownerDocument.selection.createRange()}catch(e){}return!(!t||t.parentElement()!=e)&&0!=t.compareEndPoints("StartToEnd",t)},rs=function(){var e=n("div");return"oncopy"in e||(e.setAttribute("oncopy","return;"),"function"==typeof e.oncopy)}(),ns=null,is={},os={},ls={},ss=function(e,t,r){this.pos=this.start=0,this.string=e,this.tabSize=t||8,this.lastColumnPos=this.lastColumnValue=0,this.lineStart=0,this.lineOracle=r};ss.prototype.eol=function(){return this.pos>=this.string.length},ss.prototype.sol=function(){return this.pos==this.lineStart},ss.prototype.peek=function(){return this.string.charAt(this.pos)||void 0},ss.prototype.next=function(){if(this.pos<this.string.length)return this.string.charAt(this.pos++)},ss.prototype.eat=function(e){var t=this.string.charAt(this.pos);if("string"==typeof e?t==e:t&&(e.test?e.test(t):e(t)))return++this.pos,t},ss.prototype.eatWhile=function(e){for(var t=this.pos;this.eat(e););return this.pos>t},ss.prototype.eatSpace=function(){for(var e=this,t=this.pos;/[\s\u00a0]/.test(this.string.charAt(this.pos));)++e.pos;return this.pos>t},ss.prototype.skipToEnd=function(){this.pos=this.string.length},ss.prototype.skipTo=function(e){var t=this.string.indexOf(e,this.pos);if(t>-1)return this.pos=t,!0},ss.prototype.backUp=function(e){this.pos-=e},ss.prototype.column=function(){return this.lastColumnPos<this.start&&(this.lastColumnValue=f(this.string,this.start,this.tabSize,this.lastColumnPos,this.lastColumnValue),this.lastColumnPos=this.start),this.lastColumnValue-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.indentation=function(){return f(this.string,null,this.tabSize)-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.match=function(e,t,r){if("string"!=typeof e){var n=this.string.slice(this.pos).match(e);return n&&n.index>0?null:(n&&!1!==t&&(this.pos+=n[0].length),n)}var i=function(e){return r?e.toLowerCase():e};if(i(this.string.substr(this.pos,e.length))==i(e))return!1!==t&&(this.pos+=e.length),!0},ss.prototype.current=function(){return this.string.slice(this.start,this.pos)},ss.prototype.hideFirstChars=function(e,t){this.lineStart+=e;try{return t()}finally{this.lineStart-=e}},ss.prototype.lookAhead=function(e){var t=this.lineOracle;return t&&t.lookAhead(e)};var as=function(e,t){this.state=e,this.lookAhead=t},us=function(e,t,r,n){this.state=t,this.doc=e,this.line=r,this.maxLookAhead=n||0};us.prototype.lookAhead=function(e){var t=this.doc.getLine(this.line+e);return null!=t&&e>this.maxLookAhead&&(this.maxLookAhead=e),t},us.prototype.nextLine=function(){this.line++,this.maxLookAhead>0&&this.maxLookAhead--},us.fromSaved=function(e,t,r){return t instanceof as?new us(e,Ke(e.mode,t.state),r,t.lookAhead):new us(e,Ke(e.mode,t),r)},us.prototype.save=function(e){var t=!1!==e?Ke(this.doc.mode,this.state):this.state;return this.maxLookAhead>0?new as(t,this.maxLookAhead):t};var cs=function(e,t,r){this.start=e.start,this.end=e.pos,this.string=e.current(),this.type=t||null,this.state=r},fs=function(e,t,r){this.text=e,ne(this,t),this.height=r?r(this):1};fs.prototype.lineNo=function(){return W(this)},Ae(fs);var hs,ds={},ps={},gs=null,vs=null,ms={left:0,right:0,top:0,bottom:0},ys=function(e,t,r){this.cm=r;var i=this.vert=n("div",[n("div",null,null,"min-width: 1px")],"CodeMirror-vscrollbar"),o=this.horiz=n("div",[n("div",null,null,"height: 100%; min-height: 1px")],"CodeMirror-hscrollbar");e(i),e(o),Ql(i,"scroll",function(){i.clientHeight&&t(i.scrollTop,"vertical")}),Ql(o,"scroll",function(){o.clientWidth&&t(o.scrollLeft,"horizontal")}),this.checkedZeroWidth=!1,gl&&vl<8&&(this.horiz.style.minHeight=this.vert.style.minWidth="18px")};ys.prototype.update=function(e){var t=e.scrollWidth>e.clientWidth+1,r=e.scrollHeight>e.clientHeight+1,n=e.nativeBarWidth;if(r){this.vert.style.display="block",this.vert.style.bottom=t?n+"px":"0";var i=e.viewHeight-(t?n:0);this.vert.firstChild.style.height=Math.max(0,e.scrollHeight-e.clientHeight+i)+"px"}else this.vert.style.display="",this.vert.firstChild.style.height="0";if(t){this.horiz.style.display="block",this.horiz.style.right=r?n+"px":"0",this.horiz.style.left=e.barLeft+"px";var o=e.viewWidth-e.barLeft-(r?n:0);this.horiz.firstChild.style.width=Math.max(0,e.scrollWidth-e.clientWidth+o)+"px"}else this.horiz.style.display="",this.horiz.firstChild.style.width="0";return!this.checkedZeroWidth&&e.clientHeight>0&&(0==n&&this.zeroWidthHack(),this.checkedZeroWidth=!0),{right:r?n:0,bottom:t?n:0}},ys.prototype.setScrollLeft=function(e){this.horiz.scrollLeft!=e&&(this.horiz.scrollLeft=e),this.disableHoriz&&this.enableZeroWidthBar(this.horiz,this.disableHoriz,"horiz")},ys.prototype.setScrollTop=function(e){this.vert.scrollTop!=e&&(this.vert.scrollTop=e),this.disableVert&&this.enableZeroWidthBar(this.vert,this.disableVert,"vert")},ys.prototype.zeroWidthHack=function(){var e=Ml&&!Cl?"12px":"18px";this.horiz.style.height=this.vert.style.width=e,this.horiz.style.pointerEvents=this.vert.style.pointerEvents="none",this.disableHoriz=new Pl,this.disableVert=new Pl},ys.prototype.enableZeroWidthBar=function(e,t,r){function n(){var i=e.getBoundingClientRect();("vert"==r?document.elementFromPoint(i.right-1,(i.top+i.bottom)/2):document.elementFromPoint((i.right+i.left)/2,i.bottom-1))!=e?e.style.pointerEvents="none":t.set(1e3,n)}e.style.pointerEvents="auto",t.set(1e3,n)},ys.prototype.clear=function(){var e=this.horiz.parentNode;e.removeChild(this.horiz),e.removeChild(this.vert)};var bs=function(){};bs.prototype.update=function(){return{bottom:0,right:0}},bs.prototype.setScrollLeft=function(){},bs.prototype.setScrollTop=function(){},bs.prototype.clear=function(){};var ws={native:ys,null:bs},xs=0,Cs=function(e,t,r){var n=e.display;this.viewport=t,this.visible=Ir(n,e.doc,t),this.editorIsHidden=!n.wrapper.offsetWidth,this.wrapperHeight=n.wrapper.clientHeight,this.wrapperWidth=n.wrapper.clientWidth,this.oldDisplayWidth=Rt(e),this.force=r,this.dims=br(e),this.events=[]};Cs.prototype.signal=function(e,t){Oe(e,t)&&this.events.push(arguments)},Cs.prototype.finish=function(){for(var e=this,t=0;t<this.events.length;t++)Te.apply(null,e.events[t])};var Ss=0,Ls=null;gl?Ls=-.53:fl?Ls=15:bl?Ls=-.7:xl&&(Ls=-1/3);var ks=function(e,t){this.ranges=e,this.primIndex=t};ks.prototype.primary=function(){return this.ranges[this.primIndex]},ks.prototype.equals=function(e){var t=this;if(e==this)return!0;if(e.primIndex!=this.primIndex||e.ranges.length!=this.ranges.length)return!1;for(var r=0;r<this.ranges.length;r++){var n=t.ranges[r],i=e.ranges[r];if(!I(n.anchor,i.anchor)||!I(n.head,i.head))return!1}return!0},ks.prototype.deepCopy=function(){for(var e=this,t=[],r=0;r<this.ranges.length;r++)t[r]=new Ts(z(e.ranges[r].anchor),z(e.ranges[r].head));return new ks(t,this.primIndex)},ks.prototype.somethingSelected=function(){for(var e=this,t=0;t<this.ranges.length;t++)if(!e.ranges[t].empty())return!0;return!1},ks.prototype.contains=function(e,t){var r=this;t||(t=e);for(var n=0;n<this.ranges.length;n++){var i=r.ranges[n];if(P(t,i.from())>=0&&P(e,i.to())<=0)return n}return-1};var Ts=function(e,t){this.anchor=e,this.head=t};Ts.prototype.from=function(){return B(this.anchor,this.head)},Ts.prototype.to=function(){return R(this.anchor,this.head)},Ts.prototype.empty=function(){return this.head.line==this.anchor.line&&this.head.ch==this.anchor.ch},Bi.prototype={chunkSize:function(){return this.lines.length},removeInner:function(e,t){for(var r=this,n=e,i=e+t;n<i;++n){var o=r.lines[n];r.height-=o.height,ot(o),bt(o,"delete")}this.lines.splice(e,t)},collapse:function(e){e.push.apply(e,this.lines)},insertInner:function(e,t,r){var n=this;this.height+=r,this.lines=this.lines.slice(0,e).concat(t).concat(this.lines.slice(e));for(var i=0;i<t.length;++i)t[i].parent=n},iterN:function(e,t,r){for(var n=this,i=e+t;e<i;++e)if(r(n.lines[e]))return!0}},Gi.prototype={chunkSize:function(){return this.size},removeInner:function(e,t){var r=this;this.size-=t;for(var n=0;n<this.children.length;++n){var i=r.children[n],o=i.chunkSize();if(e<o){var l=Math.min(t,o-e),s=i.height;if(i.removeInner(e,l),r.height-=s-i.height,o==l&&(r.children.splice(n--,1),i.parent=null),0==(t-=l))break;e=0}else e-=o}if(this.size-t<25&&(this.children.length>1||!(this.children[0]instanceof Bi))){var a=[];this.collapse(a),this.children=[new Bi(a)],this.children[0].parent=this}},collapse:function(e){for(var t=this,r=0;r<this.children.length;++r)t.children[r].collapse(e)},insertInner:function(e,t,r){var n=this;this.size+=t.length,this.height+=r;for(var i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<=l){if(o.insertInner(e,t,r),o.lines&&o.lines.length>50){for(var s=o.lines.length%25+25,a=s;a<o.lines.length;){var u=new Bi(o.lines.slice(a,a+=25));o.height-=u.height,n.children.splice(++i,0,u),u.parent=n}o.lines=o.lines.slice(0,s),n.maybeSpill()}break}e-=l}},maybeSpill:function(){if(!(this.children.length<=10)){var e=this;do{var t=new Gi(e.children.splice(e.children.length-5,5));if(e.parent){e.size-=t.size,e.height-=t.height;var r=h(e.parent.children,e);e.parent.children.splice(r+1,0,t)}else{var n=new Gi(e.children);n.parent=e,e.children=[n,t],e=n}t.parent=e.parent}while(e.children.length>10);e.parent.maybeSpill()}},iterN:function(e,t,r){for(var n=this,i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<l){var s=Math.min(t,l-e);if(o.iterN(e,s,r))return!0;if(0==(t-=s))break;e=0}else e-=l}}};var Ms=function(e,t,r){var n=this;if(r)for(var i in r)r.hasOwnProperty(i)&&(n[i]=r[i]);this.doc=e,this.node=t};Ms.prototype.clear=function(){var e=this,t=this.doc.cm,r=this.line.widgets,n=this.line,i=W(n);if(null!=i&&r){for(var o=0;o<r.length;++o)r[o]==e&&r.splice(o--,1);r.length||(n.widgets=null);var l=Ht(this);A(n,Math.max(0,n.height-l)),t&&(hn(t,function(){Ui(t,n,-l),mn(t,i,"widget")}),bt(t,"lineWidgetCleared",t,this,i))}},Ms.prototype.changed=function(){var e=this,t=this.height,r=this.doc.cm,n=this.line;this.height=null;var i=Ht(this)-t;i&&(A(n,n.height+i),r&&hn(r,function(){r.curOp.forceUpdate=!0,Ui(r,n,i),bt(r,"lineWidgetChanged",r,e,W(n))}))},Ae(Ms);var Ns=0,Os=function(e,t){this.lines=[],this.type=t,this.doc=e,this.id=++Ns};Os.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){var t=this.doc.cm,r=t&&!t.curOp;if(r&&nn(t),Oe(this,"clear")){var n=this.find();n&&bt(this,"clear",n.from,n.to)}for(var i=null,o=null,l=0;l<this.lines.length;++l){var s=e.lines[l],a=_(s.markedSpans,e);t&&!e.collapsed?mn(t,W(s),"text"):t&&(null!=a.to&&(o=W(s)),null!=a.from&&(i=W(s))),s.markedSpans=$(s.markedSpans,a),null==a.from&&e.collapsed&&!ve(e.doc,s)&&t&&A(s,mr(t.display))}if(t&&this.collapsed&&!t.options.lineWrapping)for(var u=0;u<this.lines.length;++u){var c=fe(e.lines[u]),f=be(c);f>t.display.maxLineLength&&(t.display.maxLine=c,t.display.maxLineLength=f,t.display.maxLineChanged=!0)}null!=i&&t&&this.collapsed&&vn(t,i,o+1),this.lines.length=0,this.explicitlyCleared=!0,this.atomic&&this.doc.cantEdit&&(this.doc.cantEdit=!1,t&&Ci(t.doc)),t&&bt(t,"markerCleared",t,this,i,o),r&&on(t),this.parent&&this.parent.clear()}},Os.prototype.find=function(e,t){var r=this;null==e&&"bookmark"==this.type&&(e=1);for(var n,i,o=0;o<this.lines.length;++o){var l=r.lines[o],s=_(l.markedSpans,r);if(null!=s.from&&(n=E(t?l:W(l),s.from),-1==e))return n;if(null!=s.to&&(i=E(t?l:W(l),s.to),1==e))return i}return n&&{from:n,to:i}},Os.prototype.changed=function(){var e=this,t=this.find(-1,!0),r=this,n=this.doc.cm;t&&n&&hn(n,function(){var i=t.line,o=W(t.line),l=jt(n,o);if(l&&(Qt(l),n.curOp.selectionChanged=n.curOp.forceUpdate=!0),n.curOp.updateMaxLine=!0,!ve(r.doc,i)&&null!=r.height){var s=r.height;r.height=null;var a=Ht(r)-s;a&&A(i,i.height+a)}bt(n,"markerChanged",n,e)})},Os.prototype.attachLine=function(e){if(!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;t.maybeHiddenMarkers&&-1!=h(t.maybeHiddenMarkers,this)||(t.maybeUnhiddenMarkers||(t.maybeUnhiddenMarkers=[])).push(this)}this.lines.push(e)},Os.prototype.detachLine=function(e){if(this.lines.splice(h(this.lines,e),1),!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;(t.maybeHiddenMarkers||(t.maybeHiddenMarkers=[])).push(this)}},Ae(Os);var As=function(e,t){var r=this;this.markers=e,this.primary=t;for(var n=0;n<e.length;++n)e[n].parent=r};As.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){this.explicitlyCleared=!0;for(var t=0;t<this.markers.length;++t)e.markers[t].clear();bt(this,"clear")}},As.prototype.find=function(e,t){return this.primary.find(e,t)},Ae(As);var Ws=0,Ds=function(e,t,r,n,i){if(!(this instanceof Ds))return new Ds(e,t,r,n,i);null==r&&(r=0),Gi.call(this,[new Bi([new fs("",null)])]),this.first=r,this.scrollTop=this.scrollLeft=0,this.cantEdit=!1,this.cleanGeneration=1,this.modeFrontier=this.highlightFrontier=r;var o=E(r,0);this.sel=Rn(o),this.history=new Jn(null),this.id=++Ws,this.modeOption=t,this.lineSep=n,this.direction="rtl"==i?"rtl":"ltr",this.extend=!1,"string"==typeof e&&(e=this.splitLines(e)),_n(this,{from:o,to:o,text:e}),bi(this,Rn(o),Gl)};Ds.prototype=b(Gi.prototype,{constructor:Ds,iter:function(e,t,r){r?this.iterN(e-this.first,t-e,r):this.iterN(this.first,this.first+this.size,e)},insert:function(e,t){for(var r=0,n=0;n<t.length;++n)r+=t[n].height;this.insertInner(e-this.first,t,r)},remove:function(e,t){this.removeInner(e-this.first,t)},getValue:function(e){var t=O(this,this.first,this.first+this.size);return!1===e?t:t.join(e||this.lineSeparator())},setValue:gn(function(e){var t=E(this.first,0),r=this.first+this.size-1;Oi(this,{from:t,to:E(r,M(this,r).text.length),text:this.splitLines(e),origin:"setValue",full:!0},!0),this.cm&&Xr(this.cm,0,0),bi(this,Rn(t),Gl)}),replaceRange:function(e,t,r,n){Ei(this,e,t=U(this,t),r=r?U(this,r):t,n)},getRange:function(e,t,r){var n=N(this,U(this,e),U(this,t));return!1===r?n:n.join(r||this.lineSeparator())},getLine:function(e){var t=this.getLineHandle(e);return t&&t.text},getLineHandle:function(e){if(H(this,e))return M(this,e)},getLineNumber:function(e){return W(e)},getLineHandleVisualStart:function(e){return"number"==typeof e&&(e=M(this,e)),fe(e)},lineCount:function(){return this.size},firstLine:function(){return this.first},lastLine:function(){return this.first+this.size-1},clipPos:function(e){return U(this,e)},getCursor:function(e){var t=this.sel.primary();return null==e||"head"==e?t.head:"anchor"==e?t.anchor:"end"==e||"to"==e||!1===e?t.to():t.from()},listSelections:function(){return this.sel.ranges},somethingSelected:function(){return this.sel.somethingSelected()},setCursor:gn(function(e,t,r){vi(this,U(this,"number"==typeof e?E(e,t||0):e),null,r)}),setSelection:gn(function(e,t,r){vi(this,U(this,e),U(this,t||e),r)}),extendSelection:gn(function(e,t,r){di(this,U(this,e),t&&U(this,t),r)}),extendSelections:gn(function(e,t){pi(this,K(this,e),t)}),extendSelectionsBy:gn(function(e,t){pi(this,K(this,v(this.sel.ranges,e)),t)}),setSelections:gn(function(e,t,r){var n=this;if(e.length){for(var i=[],o=0;o<e.length;o++)i[o]=new Ts(U(n,e[o].anchor),U(n,e[o].head));null==t&&(t=Math.min(e.length-1,this.sel.primIndex)),bi(this,zn(i,t),r)}}),addSelection:gn(function(e,t,r){var n=this.sel.ranges.slice(0);n.push(new Ts(U(this,e),U(this,t||e))),bi(this,zn(n,n.length-1),r)}),getSelection:function(e){for(var t,r=this,n=this.sel.ranges,i=0;i<n.length;i++){var o=N(r,n[i].from(),n[i].to());t=t?t.concat(o):o}return!1===e?t:t.join(e||this.lineSeparator())},getSelections:function(e){for(var t=this,r=[],n=this.sel.ranges,i=0;i<n.length;i++){var o=N(t,n[i].from(),n[i].to());!1!==e&&(o=o.join(e||t.lineSeparator())),r[i]=o}return r},replaceSelection:function(e,t,r){for(var n=[],i=0;i<this.sel.ranges.length;i++)n[i]=e;this.replaceSelections(n,t,r||"+input")},replaceSelections:gn(function(e,t,r){for(var n=this,i=[],o=this.sel,l=0;l<o.ranges.length;l++){var s=o.ranges[l];i[l]={from:s.from(),to:s.to(),text:n.splitLines(e[l]),origin:r}}for(var a=t&&"end"!=t&&Kn(this,i,t),u=i.length-1;u>=0;u--)Oi(n,i[u]);a?yi(this,a):this.cm&&jr(this.cm)}),undo:gn(function(){Wi(this,"undo")}),redo:gn(function(){Wi(this,"redo")}),undoSelection:gn(function(){Wi(this,"undo",!0)}),redoSelection:gn(function(){Wi(this,"redo",!0)}),setExtending:function(e){this.extend=e},getExtending:function(){return this.extend},historySize:function(){for(var e=this.history,t=0,r=0,n=0;n<e.done.length;n++)e.done[n].ranges||++t;for(var i=0;i<e.undone.length;i++)e.undone[i].ranges||++r;return{undo:t,redo:r}},clearHistory:function(){this.history=new Jn(this.history.maxGeneration)},markClean:function(){this.cleanGeneration=this.changeGeneration(!0)},changeGeneration:function(e){return e&&(this.history.lastOp=this.history.lastSelOp=this.history.lastOrigin=null),this.history.generation},isClean:function(e){return this.history.generation==(e||this.cleanGeneration)},getHistory:function(){return{done:fi(this.history.done),undone:fi(this.history.undone)}},setHistory:function(e){var t=this.history=new Jn(this.history.maxGeneration);t.done=fi(e.done.slice(0),null,!0),t.undone=fi(e.undone.slice(0),null,!0)},setGutterMarker:gn(function(e,t,r){return Ri(this,e,"gutter",function(e){var n=e.gutterMarkers||(e.gutterMarkers={});return n[t]=r,!r&&C(n)&&(e.gutterMarkers=null),!0})}),clearGutter:gn(function(e){var t=this;this.iter(function(r){r.gutterMarkers&&r.gutterMarkers[e]&&Ri(t,r,"gutter",function(){return r.gutterMarkers[e]=null,C(r.gutterMarkers)&&(r.gutterMarkers=null),!0})})}),lineInfo:function(e){var t;if("number"==typeof e){if(!H(this,e))return null;if(t=e,!(e=M(this,e)))return null}else if(null==(t=W(e)))return null;return{line:t,handle:e,text:e.text,gutterMarkers:e.gutterMarkers,textClass:e.textClass,bgClass:e.bgClass,wrapClass:e.wrapClass,widgets:e.widgets}},addLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass";if(t[i]){if(e(n).test(t[i]))return!1;t[i]+=" "+n}else t[i]=n;return!0})}),removeLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass",o=t[i];if(!o)return!1;if(null==n)t[i]=null;else{var l=o.match(e(n));if(!l)return!1;var s=l.index+l[0].length;t[i]=o.slice(0,l.index)+(l.index&&s!=o.length?" ":"")+o.slice(s)||null}return!0})}),addLineWidget:gn(function(e,t,r){return Vi(this,e,t,r)}),removeLineWidget:function(e){e.clear()},markText:function(e,t,r){return Ki(this,U(this,e),U(this,t),r,r&&r.type||"range")},setBookmark:function(e,t){var r={replacedWith:t&&(null==t.nodeType?t.widget:t),insertLeft:t&&t.insertLeft,clearWhenEmpty:!1,shared:t&&t.shared,handleMouseEvents:t&&t.handleMouseEvents};return e=U(this,e),Ki(this,e,e,r,"bookmark")},findMarksAt:function(e){var t=[],r=M(this,(e=U(this,e)).line).markedSpans;if(r)for(var n=0;n<r.length;++n){var i=r[n];(null==i.from||i.from<=e.ch)&&(null==i.to||i.to>=e.ch)&&t.push(i.marker.parent||i.marker)}return t},findMarks:function(e,t,r){e=U(this,e),t=U(this,t);var n=[],i=e.line;return this.iter(e.line,t.line+1,function(o){var l=o.markedSpans;if(l)for(var s=0;s<l.length;s++){var a=l[s];null!=a.to&&i==e.line&&e.ch>=a.to||null==a.from&&i!=e.line||null!=a.from&&i==t.line&&a.from>=t.ch||r&&!r(a.marker)||n.push(a.marker.parent||a.marker)}++i}),n},getAllMarks:function(){var e=[];return this.iter(function(t){var r=t.markedSpans;if(r)for(var n=0;n<r.length;++n)null!=r[n].from&&e.push(r[n].marker)}),e},posFromIndex:function(e){var t,r=this.first,n=this.lineSeparator().length;return this.iter(function(i){var o=i.text.length+n;if(o>e)return t=e,!0;e-=o,++r}),U(this,E(r,t))},indexFromPos:function(e){var t=(e=U(this,e)).ch;if(e.line<this.first||e.ch<0)return 0;var r=this.lineSeparator().length;return this.iter(this.first,e.line,function(e){t+=e.text.length+r}),t},copy:function(e){var t=new Ds(O(this,this.first,this.first+this.size),this.modeOption,this.first,this.lineSep,this.direction);return t.scrollTop=this.scrollTop,t.scrollLeft=this.scrollLeft,t.sel=this.sel,t.extend=!1,e&&(t.history.undoDepth=this.history.undoDepth,t.setHistory(this.getHistory())),t},linkedDoc:function(e){e||(e={});var t=this.first,r=this.first+this.size;null!=e.from&&e.from>t&&(t=e.from),null!=e.to&&e.to<r&&(r=e.to);var n=new Ds(O(this,t,r),e.mode||this.modeOption,t,this.lineSep,this.direction);return e.sharedHist&&(n.history=this.history),(this.linked||(this.linked=[])).push({doc:n,sharedHist:e.sharedHist}),n.linked=[{doc:this,isParent:!0,sharedHist:e.sharedHist}],Yi(n,Xi(this)),n},unlinkDoc:function(e){var t=this;if(e instanceof jo&&(e=e.doc),this.linked)for(var r=0;r<this.linked.length;++r)if(t.linked[r].doc==e){t.linked.splice(r,1),e.unlinkDoc(t),_i(Xi(t));break}if(e.history==this.history){var n=[e.id];$n(e,function(e){return n.push(e.id)},!0),e.history=new Jn(null),e.history.done=fi(this.history.done,n),e.history.undone=fi(this.history.undone,n)}},iterLinkedDocs:function(e){$n(this,e)},getMode:function(){return this.mode},getEditor:function(){return this.cm},splitLines:function(e){return this.lineSep?e.split(this.lineSep):es(e)},lineSeparator:function(){return this.lineSep||"\n"},setDirection:gn(function(e){"rtl"!=e&&(e="ltr"),e!=this.direction&&(this.direction=e,this.iter(function(e){return e.order=null}),this.cm&&Qn(this.cm))})}),Ds.prototype.eachLine=Ds.prototype.iter;for(var Hs=0,Fs=!1,Es={3:"Enter",8:"Backspace",9:"Tab",13:"Enter",16:"Shift",17:"Ctrl",18:"Alt",19:"Pause",20:"CapsLock",27:"Esc",32:"Space",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"Left",38:"Up",39:"Right",40:"Down",44:"PrintScrn",45:"Insert",46:"Delete",59:";",61:"=",91:"Mod",92:"Mod",93:"Mod",106:"*",107:"=",109:"-",110:".",111:"/",127:"Delete",173:"-",186:";",187:"=",188:",",189:"-",190:".",191:"/",192:"`",219:"[",220:"\\",221:"]",222:"'",63232:"Up",63233:"Down",63234:"Left",63235:"Right",63272:"Delete",63273:"Home",63275:"End",63276:"PageUp",63277:"PageDown",63302:"Insert"},Ps=0;Ps<10;Ps++)Es[Ps+48]=Es[Ps+96]=String(Ps);for(var Is=65;Is<=90;Is++)Es[Is]=String.fromCharCode(Is);for(var zs=1;zs<=12;zs++)Es[zs+111]=Es[zs+63235]="F"+zs;var Rs={};Rs.basic={Left:"goCharLeft",Right:"goCharRight",Up:"goLineUp",Down:"goLineDown",End:"goLineEnd",Home:"goLineStartSmart",PageUp:"goPageUp",PageDown:"goPageDown",Delete:"delCharAfter",Backspace:"delCharBefore","Shift-Backspace":"delCharBefore",Tab:"defaultTab","Shift-Tab":"indentAuto",Enter:"newlineAndIndent",Insert:"toggleOverwrite",Esc:"singleSelection"},Rs.pcDefault={"Ctrl-A":"selectAll","Ctrl-D":"deleteLine","Ctrl-Z":"undo","Shift-Ctrl-Z":"redo","Ctrl-Y":"redo","Ctrl-Home":"goDocStart","Ctrl-End":"goDocEnd","Ctrl-Up":"goLineUp","Ctrl-Down":"goLineDown","Ctrl-Left":"goGroupLeft","Ctrl-Right":"goGroupRight","Alt-Left":"goLineStart","Alt-Right":"goLineEnd","Ctrl-Backspace":"delGroupBefore","Ctrl-Delete":"delGroupAfter","Ctrl-S":"save","Ctrl-F":"find","Ctrl-G":"findNext","Shift-Ctrl-G":"findPrev","Shift-Ctrl-F":"replace","Shift-Ctrl-R":"replaceAll","Ctrl-[":"indentLess","Ctrl-]":"indentMore","Ctrl-U":"undoSelection","Shift-Ctrl-U":"redoSelection","Alt-U":"redoSelection",fallthrough:"basic"},Rs.emacsy={"Ctrl-F":"goCharRight","Ctrl-B":"goCharLeft","Ctrl-P":"goLineUp","Ctrl-N":"goLineDown","Alt-F":"goWordRight","Alt-B":"goWordLeft","Ctrl-A":"goLineStart","Ctrl-E":"goLineEnd","Ctrl-V":"goPageDown","Shift-Ctrl-V":"goPageUp","Ctrl-D":"delCharAfter","Ctrl-H":"delCharBefore","Alt-D":"delWordAfter","Alt-Backspace":"delWordBefore","Ctrl-K":"killLine","Ctrl-T":"transposeChars","Ctrl-O":"openLine"},Rs.macDefault={"Cmd-A":"selectAll","Cmd-D":"deleteLine","Cmd-Z":"undo","Shift-Cmd-Z":"redo","Cmd-Y":"redo","Cmd-Home":"goDocStart","Cmd-Up":"goDocStart","Cmd-End":"goDocEnd","Cmd-Down":"goDocEnd","Alt-Left":"goGroupLeft","Alt-Right":"goGroupRight","Cmd-Left":"goLineLeft","Cmd-Right":"goLineRight","Alt-Backspace":"delGroupBefore","Ctrl-Alt-Backspace":"delGroupAfter","Alt-Delete":"delGroupAfter","Cmd-S":"save","Cmd-F":"find","Cmd-G":"findNext","Shift-Cmd-G":"findPrev","Cmd-Alt-F":"replace","Shift-Cmd-Alt-F":"replaceAll","Cmd-[":"indentLess","Cmd-]":"indentMore","Cmd-Backspace":"delWrappedLineLeft","Cmd-Delete":"delWrappedLineRight","Cmd-U":"undoSelection","Shift-Cmd-U":"redoSelection","Ctrl-Up":"goDocStart","Ctrl-Down":"goDocEnd",fallthrough:["basic","emacsy"]},Rs.default=Ml?Rs.macDefault:Rs.pcDefault;var Bs={selectAll:Mi,singleSelection:function(e){return e.setSelection(e.getCursor("anchor"),e.getCursor("head"),Gl)},killLine:function(e){return co(e,function(t){if(t.empty()){var r=M(e.doc,t.head.line).text.length;return t.head.ch==r&&t.head.line<e.lastLine()?{from:t.head,to:E(t.head.line+1,0)}:{from:t.head,to:E(t.head.line,r)}}return{from:t.from(),to:t.to()}})},deleteLine:function(e){return co(e,function(t){return{from:E(t.from().line,0),to:U(e.doc,E(t.to().line+1,0))}})},delLineLeft:function(e){return co(e,function(e){return{from:E(e.from().line,0),to:e.from()}})},delWrappedLineLeft:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5;return{from:e.coordsChar({left:0,top:r},"div"),to:t.from()}})},delWrappedLineRight:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5,n=e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div");return{from:t.from(),to:n}})},undo:function(e){return e.undo()},redo:function(e){return e.redo()},undoSelection:function(e){return e.undoSelection()},redoSelection:function(e){return e.redoSelection()},goDocStart:function(e){return e.extendSelection(E(e.firstLine(),0))},goDocEnd:function(e){return e.extendSelection(E(e.lastLine()))},goLineStart:function(e){return e.extendSelectionsBy(function(t){return vo(e,t.head.line)},{origin:"+move",bias:1})},goLineStartSmart:function(e){return e.extendSelectionsBy(function(t){return yo(e,t.head)},{origin:"+move",bias:1})},goLineEnd:function(e){return e.extendSelectionsBy(function(t){return mo(e,t.head.line)},{origin:"+move",bias:-1})},goLineRight:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div")},Vl)},goLineLeft:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:0,top:r},"div")},Vl)},goLineLeftSmart:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5,n=e.coordsChar({left:0,top:r},"div");return n.ch<e.getLine(n.line).search(/\S/)?yo(e,t.head):n},Vl)},goLineUp:function(e){return e.moveV(-1,"line")},goLineDown:function(e){return e.moveV(1,"line")},goPageUp:function(e){return e.moveV(-1,"page")},goPageDown:function(e){return e.moveV(1,"page")},goCharLeft:function(e){return e.moveH(-1,"char")},goCharRight:function(e){return e.moveH(1,"char")},goColumnLeft:function(e){return e.moveH(-1,"column")},goColumnRight:function(e){return e.moveH(1,"column")},goWordLeft:function(e){return e.moveH(-1,"word")},goGroupRight:function(e){return e.moveH(1,"group")},goGroupLeft:function(e){return e.moveH(-1,"group")},goWordRight:function(e){return e.moveH(1,"word")},delCharBefore:function(e){return e.deleteH(-1,"char")},delCharAfter:function(e){return e.deleteH(1,"char")},delWordBefore:function(e){return e.deleteH(-1,"word")},delWordAfter:function(e){return e.deleteH(1,"word")},delGroupBefore:function(e){return e.deleteH(-1,"group")},delGroupAfter:function(e){return e.deleteH(1,"group")},indentAuto:function(e){return e.indentSelection("smart")},indentMore:function(e){return e.indentSelection("add")},indentLess:function(e){return e.indentSelection("subtract")},insertTab:function(e){return e.replaceSelection("\t")},insertSoftTab:function(e){for(var t=[],r=e.listSelections(),n=e.options.tabSize,i=0;i<r.length;i++){var o=r[i].from(),l=f(e.getLine(o.line),o.ch,n);t.push(p(n-l%n))}e.replaceSelections(t)},defaultTab:function(e){e.somethingSelected()?e.indentSelection("add"):e.execCommand("insertTab")},transposeChars:function(e){return hn(e,function(){for(var t=e.listSelections(),r=[],n=0;n<t.length;n++)if(t[n].empty()){var i=t[n].head,o=M(e.doc,i.line).text;if(o)if(i.ch==o.length&&(i=new E(i.line,i.ch-1)),i.ch>0)i=new E(i.line,i.ch+1),e.replaceRange(o.charAt(i.ch-1)+o.charAt(i.ch-2),E(i.line,i.ch-2),i,"+transpose");else if(i.line>e.doc.first){var l=M(e.doc,i.line-1).text;l&&(i=new E(i.line,1),e.replaceRange(o.charAt(0)+e.doc.lineSeparator()+l.charAt(l.length-1),E(i.line-1,l.length-1),i,"+transpose"))}r.push(new Ts(i,i))}e.setSelections(r)})},newlineAndIndent:function(e){return hn(e,function(){for(var t=e.listSelections(),r=t.length-1;r>=0;r--)e.replaceRange(e.doc.lineSeparator(),t[r].anchor,t[r].head,"+input");t=e.listSelections();for(var n=0;n<t.length;n++)e.indentLine(t[n].from().line,null,!0);jr(e)})},openLine:function(e){return e.replaceSelection("\n","start")},toggleOverwrite:function(e){return e.toggleOverwrite()}},Gs=new Pl,Us=null,Vs=function(e,t,r){this.time=e,this.pos=t,this.button=r};Vs.prototype.compare=function(e,t,r){return this.time+400>e&&0==P(t,this.pos)&&r==this.button};var Ks,js,Xs={toString:function(){return"CodeMirror.Init"}},Ys={},_s={};jo.defaults=Ys,jo.optionHandlers=_s;var $s=[];jo.defineInitHook=function(e){return $s.push(e)};var qs=null,Zs=function(e){this.cm=e,this.lastAnchorNode=this.lastAnchorOffset=this.lastFocusNode=this.lastFocusOffset=null,this.polling=new Pl,this.composing=null,this.gracePeriod=!1,this.readDOMTimeout=null};Zs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()}),"cut"==e.type&&i.replaceSelection("",null,"cut");else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type&&i.operation(function(){i.setSelections(t.ranges,0,Gl),i.replaceSelection("",null,"cut")})}if(e.clipboardData){e.clipboardData.clearData();var r=qs.text.join("\n");if(e.clipboardData.setData("Text",r),e.clipboardData.getData("Text")==r)return void e.preventDefault()}var l=el(),s=l.firstChild;i.display.lineSpace.insertBefore(l,i.display.lineSpace.firstChild),s.value=qs.text.join("\n");var a=document.activeElement;El(s),setTimeout(function(){i.display.lineSpace.removeChild(l),a.focus(),a==o&&n.showPrimarySelection()},50)}}var r=this,n=this,i=n.cm,o=n.div=e.lineDiv;Jo(o,i.options.spellcheck),Ql(o,"paste",function(e){Me(i,e)||qo(e,i)||vl<=11&&setTimeout(dn(i,function(){return r.updateFromDOM()}),20)}),Ql(o,"compositionstart",function(e){r.composing={data:e.data,done:!1}}),Ql(o,"compositionupdate",function(e){r.composing||(r.composing={data:e.data,done:!1})}),Ql(o,"compositionend",function(e){r.composing&&(e.data!=r.composing.data&&r.readFromDOMSoon(),r.composing.done=!0)}),Ql(o,"touchstart",function(){return n.forceCompositionEnd()}),Ql(o,"input",function(){r.composing||r.readFromDOMSoon()}),Ql(o,"copy",t),Ql(o,"cut",t)},Zs.prototype.prepareSelection=function(){var e=Tr(this.cm,!1);return e.focus=this.cm.state.focused,e},Zs.prototype.showSelection=function(e,t){e&&this.cm.display.view.length&&((e.focus||t)&&this.showPrimarySelection(),this.showMultipleSelections(e))},Zs.prototype.showPrimarySelection=function(){var e=window.getSelection(),t=this.cm,r=t.doc.sel.primary(),n=r.from(),i=r.to();if(t.display.viewTo==t.display.viewFrom||n.line>=t.display.viewTo||i.line<t.display.viewFrom)e.removeAllRanges();else{var o=sl(t,e.anchorNode,e.anchorOffset),l=sl(t,e.focusNode,e.focusOffset);if(!o||o.bad||!l||l.bad||0!=P(B(o,l),n)||0!=P(R(o,l),i)){var s=t.display.view,a=n.line>=t.display.viewFrom&&nl(t,n)||{node:s[0].measure.map[2],offset:0},u=i.line<t.display.viewTo&&nl(t,i);if(!u){var c=s[s.length-1].measure,f=c.maps?c.maps[c.maps.length-1]:c.map;u={node:f[f.length-1],offset:f[f.length-2]-f[f.length-3]}}if(a&&u){var h,d=e.rangeCount&&e.getRangeAt(0);try{h=Wl(a.node,a.offset,u.offset,u.node)}catch(e){}h&&(!fl&&t.state.focused?(e.collapse(a.node,a.offset),h.collapsed||(e.removeAllRanges(),e.addRange(h))):(e.removeAllRanges(),e.addRange(h)),d&&null==e.anchorNode?e.addRange(d):fl&&this.startGracePeriod()),this.rememberSelection()}else e.removeAllRanges()}}},Zs.prototype.startGracePeriod=function(){var e=this;clearTimeout(this.gracePeriod),this.gracePeriod=setTimeout(function(){e.gracePeriod=!1,e.selectionChanged()&&e.cm.operation(function(){return e.cm.curOp.selectionChanged=!0})},20)},Zs.prototype.showMultipleSelections=function(e){r(this.cm.display.cursorDiv,e.cursors),r(this.cm.display.selectionDiv,e.selection)},Zs.prototype.rememberSelection=function(){var e=window.getSelection();this.lastAnchorNode=e.anchorNode,this.lastAnchorOffset=e.anchorOffset,this.lastFocusNode=e.focusNode,this.lastFocusOffset=e.focusOffset},Zs.prototype.selectionInEditor=function(){var e=window.getSelection();if(!e.rangeCount)return!1;var t=e.getRangeAt(0).commonAncestorContainer;return o(this.div,t)},Zs.prototype.focus=function(){"nocursor"!=this.cm.options.readOnly&&(this.selectionInEditor()||this.showSelection(this.prepareSelection(),!0),this.div.focus())},Zs.prototype.blur=function(){this.div.blur()},Zs.prototype.getField=function(){return this.div},Zs.prototype.supportsTouch=function(){return!0},Zs.prototype.receivedFocus=function(){function e(){t.cm.state.focused&&(t.pollSelection(),t.polling.set(t.cm.options.pollInterval,e))}var t=this;this.selectionInEditor()?this.pollSelection():hn(this.cm,function(){return t.cm.curOp.selectionChanged=!0}),this.polling.set(this.cm.options.pollInterval,e)},Zs.prototype.selectionChanged=function(){var e=window.getSelection();return e.anchorNode!=this.lastAnchorNode||e.anchorOffset!=this.lastAnchorOffset||e.focusNode!=this.lastFocusNode||e.focusOffset!=this.lastFocusOffset},Zs.prototype.pollSelection=function(){if(null==this.readDOMTimeout&&!this.gracePeriod&&this.selectionChanged()){var e=window.getSelection(),t=this.cm;if(kl&&bl&&this.cm.options.gutters.length&&il(e.anchorNode))return this.cm.triggerOnKeyDown({type:"keydown",keyCode:8,preventDefault:Math.abs}),this.blur(),void this.focus();if(!this.composing){this.rememberSelection();var r=sl(t,e.anchorNode,e.anchorOffset),n=sl(t,e.focusNode,e.focusOffset);r&&n&&hn(t,function(){bi(t.doc,Rn(r,n),Gl),(r.bad||n.bad)&&(t.curOp.selectionChanged=!0)})}}},Zs.prototype.pollContent=function(){null!=this.readDOMTimeout&&(clearTimeout(this.readDOMTimeout),this.readDOMTimeout=null);var e=this.cm,t=e.display,r=e.doc.sel.primary(),n=r.from(),i=r.to();if(0==n.ch&&n.line>e.firstLine()&&(n=E(n.line-1,M(e.doc,n.line-1).length)),i.ch==M(e.doc,i.line).text.length&&i.line<e.lastLine()&&(i=E(i.line+1,0)),n.line<t.viewFrom||i.line>t.viewTo-1)return!1;var o,l,s;n.line==t.viewFrom||0==(o=Lr(e,n.line))?(l=W(t.view[0].line),s=t.view[0].node):(l=W(t.view[o].line),s=t.view[o-1].node.nextSibling);var a,u,c=Lr(e,i.line);if(c==t.view.length-1?(a=t.viewTo-1,u=t.lineDiv.lastChild):(a=W(t.view[c+1].line)-1,u=t.view[c+1].node.previousSibling),!s)return!1;for(var f=e.doc.splitLines(ll(e,s,u,l,a)),h=N(e.doc,E(l,0),E(a,M(e.doc,a).text.length));f.length>1&&h.length>1;)if(g(f)==g(h))f.pop(),h.pop(),a--;else{if(f[0]!=h[0])break;f.shift(),h.shift(),l++}for(var d=0,p=0,v=f[0],m=h[0],y=Math.min(v.length,m.length);d<y&&v.charCodeAt(d)==m.charCodeAt(d);)++d;for(var b=g(f),w=g(h),x=Math.min(b.length-(1==f.length?d:0),w.length-(1==h.length?d:0));p<x&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)++p;if(1==f.length&&1==h.length&&l==n.line)for(;d&&d>n.ch&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)d--,p++;f[f.length-1]=b.slice(0,b.length-p).replace(/^\u200b+/,""),f[0]=f[0].slice(d).replace(/\u200b+$/,"");var C=E(l,d),S=E(a,h.length?g(h).length-p:0);return f.length>1||f[0]||P(C,S)?(Ei(e.doc,f,C,S,"+input"),!0):void 0},Zs.prototype.ensurePolled=function(){this.forceCompositionEnd()},Zs.prototype.reset=function(){this.forceCompositionEnd()},Zs.prototype.forceCompositionEnd=function(){this.composing&&(clearTimeout(this.readDOMTimeout),this.composing=null,this.updateFromDOM(),this.div.blur(),this.div.focus())},Zs.prototype.readFromDOMSoon=function(){var e=this;null==this.readDOMTimeout&&(this.readDOMTimeout=setTimeout(function(){if(e.readDOMTimeout=null,e.composing){if(!e.composing.done)return;e.composing=null}e.updateFromDOM()},80))},Zs.prototype.updateFromDOM=function(){var e=this;!this.cm.isReadOnly()&&this.pollContent()||hn(this.cm,function(){return vn(e.cm)})},Zs.prototype.setUneditable=function(e){e.contentEditable="false"},Zs.prototype.onKeyPress=function(e){0!=e.charCode&&(e.preventDefault(),this.cm.isReadOnly()||dn(this.cm,$o)(this.cm,String.fromCharCode(null==e.charCode?e.keyCode:e.charCode),0))},Zs.prototype.readOnlyChanged=function(e){this.div.contentEditable=String("nocursor"!=e)},Zs.prototype.onContextMenu=function(){},Zs.prototype.resetPosition=function(){},Zs.prototype.needsContentAttribute=!0;var Qs=function(e){this.cm=e,this.prevInput="",this.pollingFast=!1,this.polling=new Pl,this.hasSelection=!1,this.composing=null};Qs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()});else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type?i.setSelections(t.ranges,null,Gl):(n.prevInput="",l.value=t.text.join("\n"),El(l))}"cut"==e.type&&(i.state.cutIncoming=!0)}}var r=this,n=this,i=this.cm,o=this.wrapper=el(),l=this.textarea=o.firstChild;e.wrapper.insertBefore(o,e.wrapper.firstChild),Ll&&(l.style.width="0px"),Ql(l,"input",function(){gl&&vl>=9&&r.hasSelection&&(r.hasSelection=null),n.poll()}),Ql(l,"paste",function(e){Me(i,e)||qo(e,i)||(i.state.pasteIncoming=!0,n.fastPoll())}),Ql(l,"cut",t),Ql(l,"copy",t),Ql(e.scroller,"paste",function(t){Ft(e,t)||Me(i,t)||(i.state.pasteIncoming=!0,n.focus())}),Ql(e.lineSpace,"selectstart",function(t){Ft(e,t)||We(t)}),Ql(l,"compositionstart",function(){var e=i.getCursor("from");n.composing&&n.composing.range.clear(),n.composing={start:e,range:i.markText(e,i.getCursor("to"),{className:"CodeMirror-composing"})}}),Ql(l,"compositionend",function(){n.composing&&(n.poll(),n.composing.range.clear(),n.composing=null)})},Qs.prototype.prepareSelection=function(){var e=this.cm,t=e.display,r=e.doc,n=Tr(e);if(e.options.moveInputWithCursor){var i=sr(e,r.sel.primary().head,"div"),o=t.wrapper.getBoundingClientRect(),l=t.lineDiv.getBoundingClientRect();n.teTop=Math.max(0,Math.min(t.wrapper.clientHeight-10,i.top+l.top-o.top)),n.teLeft=Math.max(0,Math.min(t.wrapper.clientWidth-10,i.left+l.left-o.left))}return n},Qs.prototype.showSelection=function(e){var t=this.cm.display;r(t.cursorDiv,e.cursors),r(t.selectionDiv,e.selection),null!=e.teTop&&(this.wrapper.style.top=e.teTop+"px",this.wrapper.style.left=e.teLeft+"px")},Qs.prototype.reset=function(e){if(!this.contextMenuPending&&!this.composing){var t=this.cm;if(t.somethingSelected()){this.prevInput="";var r=t.getSelection();this.textarea.value=r,t.state.focused&&El(this.textarea),gl&&vl>=9&&(this.hasSelection=r)}else e||(this.prevInput=this.textarea.value="",gl&&vl>=9&&(this.hasSelection=null))}},Qs.prototype.getField=function(){return this.textarea},Qs.prototype.supportsTouch=function(){return!1},Qs.prototype.focus=function(){if("nocursor"!=this.cm.options.readOnly&&(!Tl||l()!=this.textarea))try{this.textarea.focus()}catch(e){}},Qs.prototype.blur=function(){this.textarea.blur()},Qs.prototype.resetPosition=function(){this.wrapper.style.top=this.wrapper.style.left=0},Qs.prototype.receivedFocus=function(){this.slowPoll()},Qs.prototype.slowPoll=function(){var e=this;this.pollingFast||this.polling.set(this.cm.options.pollInterval,function(){e.poll(),e.cm.state.focused&&e.slowPoll()})},Qs.prototype.fastPoll=function(){function e(){r.poll()||t?(r.pollingFast=!1,r.slowPoll()):(t=!0,r.polling.set(60,e))}var t=!1,r=this;r.pollingFast=!0,r.polling.set(20,e)},Qs.prototype.poll=function(){var e=this,t=this.cm,r=this.textarea,n=this.prevInput;if(this.contextMenuPending||!t.state.focused||ts(r)&&!n&&!this.composing||t.isReadOnly()||t.options.disableInput||t.state.keySeq)return!1;var i=r.value;if(i==n&&!t.somethingSelected())return!1;if(gl&&vl>=9&&this.hasSelection===i||Ml&&/[\uf700-\uf7ff]/.test(i))return t.display.input.reset(),!1;if(t.doc.sel==t.display.selForContextMenu){var o=i.charCodeAt(0);if(8203!=o||n||(n="​"),8666==o)return this.reset(),this.cm.execCommand("undo")}for(var l=0,s=Math.min(n.length,i.length);l<s&&n.charCodeAt(l)==i.charCodeAt(l);)++l;return hn(t,function(){$o(t,i.slice(l),n.length-l,null,e.composing?"*compose":null),i.length>1e3||i.indexOf("\n")>-1?r.value=e.prevInput="":e.prevInput=i,e.composing&&(e.composing.range.clear(),e.composing.range=t.markText(e.composing.start,t.getCursor("to"),{className:"CodeMirror-composing"}))}),!0},Qs.prototype.ensurePolled=function(){this.pollingFast&&this.poll()&&(this.pollingFast=!1)},Qs.prototype.onKeyPress=function(){gl&&vl>=9&&(this.hasSelection=null),this.fastPoll()},Qs.prototype.onContextMenu=function(e){function t(){if(null!=l.selectionStart){var e=i.somethingSelected(),t="​"+(e?l.value:"");l.value="⇚",l.value=t,n.prevInput=e?"":"​",l.selectionStart=1,l.selectionEnd=t.length,o.selForContextMenu=i.doc.sel}}function r(){if(n.contextMenuPending=!1,n.wrapper.style.cssText=c,l.style.cssText=u,gl&&vl<9&&o.scrollbars.setScrollTop(o.scroller.scrollTop=a),null!=l.selectionStart){(!gl||gl&&vl<9)&&t();var e=0,r=function(){o.selForContextMenu==i.doc.sel&&0==l.selectionStart&&l.selectionEnd>0&&"​"==n.prevInput?dn(i,Mi)(i):e++<10?o.detectingSelectAll=setTimeout(r,500):(o.selForContextMenu=null,o.input.reset())};o.detectingSelectAll=setTimeout(r,200)}}var n=this,i=n.cm,o=i.display,l=n.textarea,s=Sr(i,e),a=o.scroller.scrollTop;if(s&&!wl){i.options.resetSelectionOnContextMenu&&-1==i.doc.sel.contains(s)&&dn(i,bi)(i.doc,Rn(s),Gl);var u=l.style.cssText,c=n.wrapper.style.cssText;n.wrapper.style.cssText="position: absolute";var f=n.wrapper.getBoundingClientRect();l.style.cssText="position: absolute; width: 30px; height: 30px;\n      top: "+(e.clientY-f.top-5)+"px; left: "+(e.clientX-f.left-5)+"px;\n      z-index: 1000; background: "+(gl?"rgba(255, 255, 255, .05)":"transparent")+";\n      outline: none; border-width: 0; outline: none; overflow: hidden; opacity: .05; filter: alpha(opacity=5);";var h;if(ml&&(h=window.scrollY),o.input.focus(),ml&&window.scrollTo(null,h),o.input.reset(),i.somethingSelected()||(l.value=n.prevInput=" "),n.contextMenuPending=!0,o.selForContextMenu=i.doc.sel,clearTimeout(o.detectingSelectAll),gl&&vl>=9&&t(),Hl){Fe(e);var d=function(){ke(window,"mouseup",d),setTimeout(r,20)};Ql(window,"mouseup",d)}else setTimeout(r,50)}},Qs.prototype.readOnlyChanged=function(e){e||this.reset(),this.textarea.disabled="nocursor"==e},Qs.prototype.setUneditable=function(){},Qs.prototype.needsContentAttribute=!1,function(e){function t(t,n,i,o){e.defaults[t]=n,i&&(r[t]=o?function(e,t,r){r!=Xs&&i(e,t,r)}:i)}var r=e.optionHandlers;e.defineOption=t,e.Init=Xs,t("value","",function(e,t){return e.setValue(t)},!0),t("mode",null,function(e,t){e.doc.modeOption=t,jn(e)},!0),t("indentUnit",2,jn,!0),t("indentWithTabs",!1),t("smartIndent",!0),t("tabSize",4,function(e){Xn(e),er(e),vn(e)},!0),t("lineSeparator",null,function(e,t){if(e.doc.lineSep=t,t){var r=[],n=e.doc.first;e.doc.iter(function(e){for(var i=0;;){var o=e.text.indexOf(t,i);if(-1==o)break;i=o+t.length,r.push(E(n,o))}n++});for(var i=r.length-1;i>=0;i--)Ei(e.doc,t,r[i],E(r[i].line,r[i].ch+t.length))}}),t("specialChars",/[\u0000-\u001f\u007f-\u009f\u00ad\u061c\u200b-\u200f\u2028\u2029\ufeff]/g,function(e,t,r){e.state.specialChars=new RegExp(t.source+(t.test("\t")?"":"|\t"),"g"),r!=Xs&&e.refresh()}),t("specialCharPlaceholder",at,function(e){return e.refresh()},!0),t("electricChars",!0),t("inputStyle",Tl?"contenteditable":"textarea",function(){throw new Error("inputStyle can not (yet) be changed in a running editor")},!0),t("spellcheck",!1,function(e,t){return e.getInputField().spellcheck=t},!0),t("rtlMoveVisually",!Ol),t("wholeLineUpdateBefore",!0),t("theme","default",function(e){Go(e),Uo(e)},!0),t("keyMap","default",function(e,t,r){var n=uo(t),i=r!=Xs&&uo(r);i&&i.detach&&i.detach(e,n),n.attach&&n.attach(e,i||null)}),t("extraKeys",null),t("configureMouse",null),t("lineWrapping",!1,Ko,!0),t("gutters",[],function(e){Fn(e.options),Uo(e)},!0),t("fixedGutter",!0,function(e,t){e.display.gutters.style.left=t?wr(e.display)+"px":"0",e.refresh()},!0),t("coverGutterNextToScrollbar",!1,function(e){return en(e)},!0),t("scrollbarStyle","native",function(e){rn(e),en(e),e.display.scrollbars.setScrollTop(e.doc.scrollTop),e.display.scrollbars.setScrollLeft(e.doc.scrollLeft)},!0),t("lineNumbers",!1,function(e){Fn(e.options),Uo(e)},!0),t("firstLineNumber",1,Uo,!0),t("lineNumberFormatter",function(e){return e},Uo,!0),t("showCursorWhenSelecting",!1,kr,!0),t("resetSelectionOnContextMenu",!0),t("lineWiseCopyCut",!0),t("pasteLinesPerSelection",!0),t("readOnly",!1,function(e,t){"nocursor"==t&&(Fr(e),e.display.input.blur()),e.display.input.readOnlyChanged(t)}),t("disableInput",!1,function(e,t){t||e.display.input.reset()},!0),t("dragDrop",!0,Vo),t("allowDropFileTypes",null),t("cursorBlinkRate",530),t("cursorScrollMargin",0),t("cursorHeight",1,kr,!0),t("singleCursorHeightPerLine",!0,kr,!0),t("workTime",100),t("workDelay",100),t("flattenSpans",!0,Xn,!0),t("addModeClass",!1,Xn,!0),t("pollInterval",100),t("undoDepth",200,function(e,t){return e.doc.history.undoDepth=t}),t("historyEventDelay",1250),t("viewportMargin",10,function(e){return e.refresh()},!0),t("maxHighlightLength",1e4,Xn,!0),t("moveInputWithCursor",!0,function(e,t){t||e.display.input.resetPosition()}),t("tabindex",null,function(e,t){return e.display.input.getField().tabIndex=t||""}),t("autofocus",null),t("direction","ltr",function(e,t){return e.doc.setDirection(t)},!0)}(jo),function(e){var t=e.optionHandlers,r=e.helpers={};e.prototype={constructor:e,focus:function(){window.focus(),this.display.input.focus()},setOption:function(e,r){var n=this.options,i=n[e];n[e]==r&&"mode"!=e||(n[e]=r,t.hasOwnProperty(e)&&dn(this,t[e])(this,r,i),Te(this,"optionChange",this,e))},getOption:function(e){return this.options[e]},getDoc:function(){return this.doc},addKeyMap:function(e,t){this.state.keyMaps[t?"push":"unshift"](uo(e))},removeKeyMap:function(e){for(var t=this.state.keyMaps,r=0;r<t.length;++r)if(t[r]==e||t[r].name==e)return t.splice(r,1),!0},addOverlay:pn(function(t,r){var n=t.token?t:e.getMode(this.options,t);if(n.startState)throw new Error("Overlays may not be stateful.");m(this.state.overlays,{mode:n,modeSpec:t,opaque:r&&r.opaque,priority:r&&r.priority||0},function(e){return e.priority}),this.state.modeGen++,vn(this)}),removeOverlay:pn(function(e){for(var t=this,r=this.state.overlays,n=0;n<r.length;++n){var i=r[n].modeSpec;if(i==e||"string"==typeof e&&i.name==e)return r.splice(n,1),t.state.modeGen++,void vn(t)}}),indentLine:pn(function(e,t,r){"string"!=typeof t&&"number"!=typeof t&&(t=null==t?this.options.smartIndent?"smart":"prev":t?"add":"subtract"),H(this.doc,e)&&Yo(this,e,t,r)}),indentSelection:pn(function(e){for(var t=this,r=this.doc.sel.ranges,n=-1,i=0;i<r.length;i++){var o=r[i];if(o.empty())o.head.line>n&&(Yo(t,o.head.line,e,!0),n=o.head.line,i==t.doc.sel.primIndex&&jr(t));else{var l=o.from(),s=o.to(),a=Math.max(n,l.line);n=Math.min(t.lastLine(),s.line-(s.ch?0:1))+1;for(var u=a;u<n;++u)Yo(t,u,e);var c=t.doc.sel.ranges;0==l.ch&&r.length==c.length&&c[i].from().ch>0&&gi(t.doc,i,new Ts(l,c[i].to()),Gl)}}}),getTokenAt:function(e,t){return Je(this,e,t)},getLineTokens:function(e,t){return Je(this,E(e),t,!0)},getTokenTypeAt:function(e){e=U(this.doc,e);var t,r=_e(this,M(this.doc,e.line)),n=0,i=(r.length-1)/2,o=e.ch;if(0==o)t=r[2];else for(;;){var l=n+i>>1;if((l?r[2*l-1]:0)>=o)i=l;else{if(!(r[2*l+1]<o)){t=r[2*l+2];break}n=l+1}}var s=t?t.indexOf("overlay "):-1;return s<0?t:0==s?null:t.slice(0,s-1)},getModeAt:function(t){var r=this.doc.mode;return r.innerMode?e.innerMode(r,this.getTokenAt(t).state).mode:r},getHelper:function(e,t){return this.getHelpers(e,t)[0]},getHelpers:function(e,t){var n=this,i=[];if(!r.hasOwnProperty(t))return i;var o=r[t],l=this.getModeAt(e);if("string"==typeof l[t])o[l[t]]&&i.push(o[l[t]]);else if(l[t])for(var s=0;s<l[t].length;s++){var a=o[l[t][s]];a&&i.push(a)}else l.helperType&&o[l.helperType]?i.push(o[l.helperType]):o[l.name]&&i.push(o[l.name]);for(var u=0;u<o._global.length;u++){var c=o._global[u];c.pred(l,n)&&-1==h(i,c.val)&&i.push(c.val)}return i},getStateAfter:function(e,t){var r=this.doc;return e=G(r,null==e?r.first+r.size-1:e),$e(this,e+1,t).state},cursorCoords:function(e,t){var r,n=this.doc.sel.primary();return r=null==e?n.head:"object"==typeof e?U(this.doc,e):e?n.from():n.to(),sr(this,r,t||"page")},charCoords:function(e,t){return lr(this,U(this.doc,e),t||"page")},coordsChar:function(e,t){return e=or(this,e,t||"page"),cr(this,e.left,e.top)},lineAtHeight:function(e,t){return e=or(this,{top:e,left:0},t||"page").top,D(this.doc,e+this.display.viewOffset)},heightAtLine:function(e,t,r){var n,i=!1;if("number"==typeof e){var o=this.doc.first+this.doc.size-1;e<this.doc.first?e=this.doc.first:e>o&&(e=o,i=!0),n=M(this.doc,e)}else n=e;return ir(this,n,{top:0,left:0},t||"page",r||i).top+(i?this.doc.height-ye(n):0)},defaultTextHeight:function(){return mr(this.display)},defaultCharWidth:function(){return yr(this.display)},getViewport:function(){return{from:this.display.viewFrom,to:this.display.viewTo}},addWidget:function(e,t,r,n,i){var o=this.display,l=(e=sr(this,U(this.doc,e))).bottom,s=e.left;if(t.style.position="absolute",t.setAttribute("cm-ignore-events","true"),this.display.input.setUneditable(t),o.sizer.appendChild(t),"over"==n)l=e.top;else if("above"==n||"near"==n){var a=Math.max(o.wrapper.clientHeight,this.doc.height),u=Math.max(o.sizer.clientWidth,o.lineSpace.clientWidth);("above"==n||e.bottom+t.offsetHeight>a)&&e.top>t.offsetHeight?l=e.top-t.offsetHeight:e.bottom+t.offsetHeight<=a&&(l=e.bottom),s+t.offsetWidth>u&&(s=u-t.offsetWidth)}t.style.top=l+"px",t.style.left=t.style.right="","right"==i?(s=o.sizer.clientWidth-t.offsetWidth,t.style.right="0px"):("left"==i?s=0:"middle"==i&&(s=(o.sizer.clientWidth-t.offsetWidth)/2),t.style.left=s+"px"),r&&Ur(this,{left:s,top:l,right:s+t.offsetWidth,bottom:l+t.offsetHeight})},triggerOnKeyDown:pn(Lo),triggerOnKeyPress:pn(Mo),triggerOnKeyUp:To,triggerOnMouseDown:pn(Oo),execCommand:function(e){if(Bs.hasOwnProperty(e))return Bs[e].call(null,this)},triggerElectric:pn(function(e){Zo(this,e)}),findPosH:function(e,t,r,n){var i=this,o=1;t<0&&(o=-1,t=-t);for(var l=U(this.doc,e),s=0;s<t&&!(l=tl(i.doc,l,o,r,n)).hitSide;++s);return l},moveH:pn(function(e,t){var r=this;this.extendSelectionsBy(function(n){return r.display.shift||r.doc.extend||n.empty()?tl(r.doc,n.head,e,t,r.options.rtlMoveVisually):e<0?n.from():n.to()},Vl)}),deleteH:pn(function(e,t){var r=this.doc.sel,n=this.doc;r.somethingSelected()?n.replaceSelection("",null,"+delete"):co(this,function(r){var i=tl(n,r.head,e,t,!1);return e<0?{from:i,to:r.head}:{from:r.head,to:i}})}),findPosV:function(e,t,r,n){var i=this,o=1,l=n;t<0&&(o=-1,t=-t);for(var s=U(this.doc,e),a=0;a<t;++a){var u=sr(i,s,"div");if(null==l?l=u.left:u.left=l,(s=rl(i,u,o,r)).hitSide)break}return s},moveV:pn(function(e,t){var r=this,n=this.doc,i=[],o=!this.display.shift&&!n.extend&&n.sel.somethingSelected();if(n.extendSelectionsBy(function(l){if(o)return e<0?l.from():l.to();var s=sr(r,l.head,"div");null!=l.goalColumn&&(s.left=l.goalColumn),i.push(s.left);var a=rl(r,s,e,t);return"page"==t&&l==n.sel.primary()&&Kr(r,lr(r,a,"div").top-s.top),a},Vl),i.length)for(var l=0;l<n.sel.ranges.length;l++)n.sel.ranges[l].goalColumn=i[l]}),findWordAt:function(e){var t=M(this.doc,e.line).text,r=e.ch,n=e.ch;if(t){var i=this.getHelper(e,"wordChars");"before"!=e.sticky&&n!=t.length||!r?++n:--r;for(var o=t.charAt(r),l=x(o,i)?function(e){return x(e,i)}:/\s/.test(o)?function(e){return/\s/.test(e)}:function(e){return!/\s/.test(e)&&!x(e)};r>0&&l(t.charAt(r-1));)--r;for(;n<t.length&&l(t.charAt(n));)++n}return new Ts(E(e.line,r),E(e.line,n))},toggleOverwrite:function(e){null!=e&&e==this.state.overwrite||((this.state.overwrite=!this.state.overwrite)?s(this.display.cursorDiv,"CodeMirror-overwrite"):Fl(this.display.cursorDiv,"CodeMirror-overwrite"),Te(this,"overwriteToggle",this,this.state.overwrite))},hasFocus:function(){return this.display.input.getField()==l()},isReadOnly:function(){return!(!this.options.readOnly&&!this.doc.cantEdit)},scrollTo:pn(function(e,t){Xr(this,e,t)}),getScrollInfo:function(){var e=this.display.scroller;return{left:e.scrollLeft,top:e.scrollTop,height:e.scrollHeight-zt(this)-this.display.barHeight,width:e.scrollWidth-zt(this)-this.display.barWidth,clientHeight:Bt(this),clientWidth:Rt(this)}},scrollIntoView:pn(function(e,t){null==e?(e={from:this.doc.sel.primary().head,to:null},null==t&&(t=this.options.cursorScrollMargin)):"number"==typeof e?e={from:E(e,0),to:null}:null==e.from&&(e={from:e,to:null}),e.to||(e.to=e.from),e.margin=t||0,null!=e.from.line?Yr(this,e):$r(this,e.from,e.to,e.margin)}),setSize:pn(function(e,t){var r=this,n=function(e){return"number"==typeof e||/^\d+$/.test(String(e))?e+"px":e};null!=e&&(this.display.wrapper.style.width=n(e)),null!=t&&(this.display.wrapper.style.height=n(t)),this.options.lineWrapping&&Jt(this);var i=this.display.viewFrom;this.doc.iter(i,this.display.viewTo,function(e){if(e.widgets)for(var t=0;t<e.widgets.length;t++)if(e.widgets[t].noHScroll){mn(r,i,"widget");break}++i}),this.curOp.forceUpdate=!0,Te(this,"refresh",this)}),operation:function(e){return hn(this,e)},startOperation:function(){return nn(this)},endOperation:function(){return on(this)},refresh:pn(function(){var e=this.display.cachedTextHeight;vn(this),this.curOp.forceUpdate=!0,er(this),Xr(this,this.doc.scrollLeft,this.doc.scrollTop),Wn(this),(null==e||Math.abs(e-mr(this.display))>.5)&&Cr(this),Te(this,"refresh",this)}),swapDoc:pn(function(e){var t=this.doc;return t.cm=null,qn(this,e),er(this),this.display.input.reset(),Xr(this,e.scrollLeft,e.scrollTop),this.curOp.forceScroll=!0,bt(this,"swapDoc",this,t),t}),getInputField:function(){return this.display.input.getField()},getWrapperElement:function(){return this.display.wrapper},getScrollerElement:function(){return this.display.scroller},getGutterElement:function(){return this.display.gutters}},Ae(e),e.registerHelper=function(t,n,i){r.hasOwnProperty(t)||(r[t]=e[t]={_global:[]}),r[t][n]=i},e.registerGlobalHelper=function(t,n,i,o){e.registerHelper(t,n,o),r[t]._global.push({pred:i,val:o})}}(jo);var Js="iter insert remove copy getEditor constructor".split(" ");for(var ea in Ds.prototype)Ds.prototype.hasOwnProperty(ea)&&h(Js,ea)<0&&(jo.prototype[ea]=function(e){return function(){return e.apply(this.doc,arguments)}}(Ds.prototype[ea]));return Ae(Ds),jo.inputStyles={textarea:Qs,contenteditable:Zs},jo.defineMode=function(e){jo.defaults.mode||"null"==e||(jo.defaults.mode=e),Be.apply(this,arguments)},jo.defineMIME=function(e,t){os[e]=t},jo.defineMode("null",function(){return{token:function(e){return e.skipToEnd()}}}),jo.defineMIME("text/plain","null"),jo.defineExtension=function(e,t){jo.prototype[e]=t},jo.defineDocExtension=function(e,t){Ds.prototype[e]=t},jo.fromTextArea=function(e,t){function r(){e.value=a.getValue()}if(t=t?c(t):{},t.value=e.value,!t.tabindex&&e.tabIndex&&(t.tabindex=e.tabIndex),!t.placeholder&&e.placeholder&&(t.placeholder=e.placeholder),null==t.autofocus){var n=l();t.autofocus=n==e||null!=e.getAttribute("autofocus")&&n==document.body}var i;if(e.form&&(Ql(e.form,"submit",r),!t.leaveSubmitMethodAlone)){var o=e.form;i=o.submit;try{var s=o.submit=function(){r(),o.submit=i,o.submit(),o.submit=s}}catch(e){}}t.finishInit=function(t){t.save=r,t.getTextArea=function(){return e},t.toTextArea=function(){t.toTextArea=isNaN,r(),e.parentNode.removeChild(t.getWrapperElement()),e.style.display="",e.form&&(ke(e.form,"submit",r),"function"==typeof e.form.submit&&(e.form.submit=i))}},e.style.display="none";var a=jo(function(t){return e.parentNode.insertBefore(t,e.nextSibling)},t);return a},function(e){e.off=ke,e.on=Ql,e.wheelEventPixels=Pn,e.Doc=Ds,e.splitLines=es,e.countColumn=f,e.findColumn=d,e.isWordChar=w,e.Pass=Bl,e.signal=Te,e.Line=fs,e.changeEnd=Bn,e.scrollbarModel=ws,e.Pos=E,e.cmpPos=P,e.modes=is,e.mimeModes=os,e.resolveMode=Ge,e.getMode=Ue,e.modeExtensions=ls,e.extendMode=Ve,e.copyState=Ke,e.startState=Xe,e.innerMode=je,e.commands=Bs,e.keyMap=Rs,e.keyName=ao,e.isModifierKey=lo,e.lookupKey=oo,e.normalizeKeyMap=io,e.StringStream=ss,e.SharedTextMarker=As,e.TextMarker=Os,e.LineWidget=Ms,e.e_preventDefault=We,e.e_stopPropagation=De,e.e_stop=Fe,e.addClass=s,e.contains=o,e.rmClass=Fl,e.keyNames=Es}(jo),jo.version="5.30.0",jo});
      !function(e){"object"==typeof exports&&"object"==typeof module?e(require("../../lib/codemirror")):"function"==typeof define&&define.amd?define(["../../lib/codemirror"],e):e(CodeMirror)}(function(e){"use strict";function t(e,t,n,r,o,a){this.indented=e,this.column=t,this.type=n,this.info=r,this.align=o,this.prev=a}function n(e,n,r,o){var a=e.indented;return e.context&&"statement"==e.context.type&&"statement"!=r&&(a=e.context.indented),e.context=new t(a,n,r,o,null,e.context)}function r(e){var t=e.context.type;return")"!=t&&"]"!=t&&"}"!=t||(e.indented=e.context.indented),e.context=e.context.prev}function o(e,t,n){return"variable"==t.prevToken||"type"==t.prevToken||(!!/\S(?:[^- ]>|[*\]])\s*$|\*$/.test(e.string.slice(0,n))||(!(!t.typeAtEndOfLine||e.column()!=e.indentation())||void 0))}function a(e){for(;;){if(!e||"top"==e.type)return!0;if("}"==e.type&&"namespace"!=e.prev.info)return!1;e=e.prev}}function i(e){for(var t={},n=e.split(" "),r=0;r<n.length;++r)t[n[r]]=!0;return t}function l(e,t){return"function"==typeof e?e(t):e.propertyIsEnumerable(t)}function s(e,t){if(!t.startOfLine)return!1;for(var n,r=null;n=e.peek();){if("\\"==n&&e.match(/^.$/)){r=s;break}if("/"==n&&e.match(/^\/[\/\*]/,!1))break;e.next()}return t.tokenize=r,"meta"}function c(e,t){return"type"==t.prevToken&&"type"}function u(e){return e.eatWhile(/[\w\.']/),"number"}function d(e,t){if(e.backUp(1),e.match(/(R|u8R|uR|UR|LR)/)){var n=e.match(/"([^\s\\()]{0,16})\(/);return!!n&&(t.cpp11RawStringDelim=n[1],t.tokenize=m,m(e,t))}return e.match(/(u8|u|U|L)/)?!!e.match(/["']/,!1)&&"string":(e.next(),!1)}function f(e){var t=/(\w+)::~?(\w+)$/.exec(e);return t&&t[1]==t[2]}function p(e,t){for(var n;null!=(n=e.next());)if('"'==n&&!e.eat('"')){t.tokenize=null;break}return"string"}function m(e,t){var n=t.cpp11RawStringDelim.replace(/[^\w\s]/g,"\\$&");return e.match(new RegExp(".*?\\)"+n+'"'))?t.tokenize=null:e.skipToEnd(),"string"}function h(t,n){function r(e){if(e)for(var t in e)e.hasOwnProperty(t)&&o.push(t)}"string"==typeof t&&(t=[t]);var o=[];r(n.keywords),r(n.types),r(n.builtin),r(n.atoms),o.length&&(n.helperType=t[0],e.registerHelper("hintWords",t[0],o));for(var a=0;a<t.length;++a)e.defineMIME(t[a],n)}function g(e,t){for(var n=!1;!e.eol();){if(!n&&e.match('"""')){t.tokenize=null;break}n="\\"==e.next()&&!n}return"string"}function y(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!e&&!o&&t.match('"')){a=!0;break}if(e&&t.match('"""')){a=!0;break}r=t.next(),!o&&"$"==r&&t.match("{")&&t.skipTo("}"),o=!o&&"\\"==r&&!e}return!a&&e||(n.tokenize=null),"string"}}function x(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!o&&t.match('"')&&("single"==e||t.match('""'))){a=!0;break}if(!o&&t.match("``")){w=x(e),a=!0;break}r=t.next(),o="single"==e&&!o&&"\\"==r}return a&&(n.tokenize=null),"string"}}e.defineMode("clike",function(i,s){function c(e,t){var n=e.next();if(S[n]){var r=S[n](e,t);if(!1!==r)return r}if('"'==n||"'"==n)return t.tokenize=u(n),t.tokenize(e,t);if(D.test(n))return p=n,null;if(L.test(n)){if(e.backUp(1),e.match(I))return"number";e.next()}if("/"==n){if(e.eat("*"))return t.tokenize=d,d(e,t);if(e.eat("/"))return e.skipToEnd(),"comment"}if(F.test(n)){for(;!e.match(/^\/[\/*]/,!1)&&e.eat(F););return"operator"}if(e.eatWhile(z),P)for(;e.match(P);)e.eatWhile(z);var o=e.current();return l(x,o)?(l(w,o)&&(p="newstatement"),l(v,o)&&(m=!0),"keyword"):l(b,o)?"type":l(k,o)?(l(w,o)&&(p="newstatement"),"builtin"):l(_,o)?"atom":"variable"}function u(e){return function(t,n){for(var r,o=!1,a=!1;null!=(r=t.next());){if(r==e&&!o){a=!0;break}o=!o&&"\\"==r}return(a||!o&&!C)&&(n.tokenize=null),"string"}}function d(e,t){for(var n,r=!1;n=e.next();){if("/"==n&&r){t.tokenize=null;break}r="*"==n}return"comment"}function f(e,t){s.typeFirstDefinitions&&e.eol()&&a(t.context)&&(t.typeAtEndOfLine=o(e,t,e.pos))}var p,m,h=i.indentUnit,g=s.statementIndentUnit||h,y=s.dontAlignCalls,x=s.keywords||{},b=s.types||{},k=s.builtin||{},w=s.blockKeywords||{},v=s.defKeywords||{},_=s.atoms||{},S=s.hooks||{},C=s.multiLineStrings,T=!1!==s.indentStatements,M=!1!==s.indentSwitch,P=s.namespaceSeparator,D=s.isPunctuationChar||/[\[\]{}\(\),;\:\.]/,L=s.numberStart||/[\d\.]/,I=s.number||/^(?:0x[a-f\d]+|0b[01]+|(?:\d+\.?\d*|\.\d+)(?:e[-+]?\d+)?)(u|ll?|l|f)?/i,F=s.isOperatorChar||/[+\-*&%=<>!?|\/]/,z=s.isIdentifierChar||/[\w\$_\xa1-\uffff]/;return{startState:function(e){return{tokenize:null,context:new t((e||0)-h,0,"top",null,!1),indented:0,startOfLine:!0,prevToken:null}},token:function(e,t){var i=t.context;if(e.sol()&&(null==i.align&&(i.align=!1),t.indented=e.indentation(),t.startOfLine=!0),e.eatSpace())return f(e,t),null;p=m=null;var l=(t.tokenize||c)(e,t);if("comment"==l||"meta"==l)return l;if(null==i.align&&(i.align=!0),";"==p||":"==p||","==p&&e.match(/^\s*(?:\/\/.*)?$/,!1))for(;"statement"==t.context.type;)r(t);else if("{"==p)n(t,e.column(),"}");else if("["==p)n(t,e.column(),"]");else if("("==p)n(t,e.column(),")");else if("}"==p){for(;"statement"==i.type;)i=r(t);for("}"==i.type&&(i=r(t));"statement"==i.type;)i=r(t)}else p==i.type?r(t):T&&(("}"==i.type||"top"==i.type)&&";"!=p||"statement"==i.type&&"newstatement"==p)&&n(t,e.column(),"statement",e.current());if("variable"==l&&("def"==t.prevToken||s.typeFirstDefinitions&&o(e,t,e.start)&&a(t.context)&&e.match(/^\s*\(/,!1))&&(l="def"),S.token){var u=S.token(e,t,l);void 0!==u&&(l=u)}return"def"==l&&!1===s.styleDefs&&(l="variable"),t.startOfLine=!1,t.prevToken=m?"def":l||p,f(e,t),l},indent:function(t,n){if(t.tokenize!=c&&null!=t.tokenize||t.typeAtEndOfLine)return e.Pass;var r=t.context,o=n&&n.charAt(0);if("statement"==r.type&&"}"==o&&(r=r.prev),s.dontIndentStatements)for(;"statement"==r.type&&s.dontIndentStatements.test(r.info);)r=r.prev;if(S.indent){var a=S.indent(t,r,n);if("number"==typeof a)return a}var i=o==r.type,l=r.prev&&"switch"==r.prev.info;if(s.allmanIndentation&&/[{(]/.test(o)){for(;"top"!=r.type&&"}"!=r.type;)r=r.prev;return r.indented}return"statement"==r.type?r.indented+("{"==o?0:g):!r.align||y&&")"==r.type?")"!=r.type||i?r.indented+(i?0:h)+(i||!l||/^(?:case|default)\b/.test(n)?0:h):r.indented+g:r.column+(i?0:1)},electricInput:M?/^\s*(?:case .*?:|default:|\{\}?|\})$/:/^\s*[{}]$/,blockCommentStart:"/*",blockCommentEnd:"*/",lineComment:"//",fold:"brace"}});var b="auto if break case register continue return default do sizeof static else struct switch extern typedef union for goto while enum const volatile",k="int long char short double float unsigned signed void size_t ptrdiff_t";h(["text/x-csrc","text/x-c","text/x-chdr"],{name:"clike",keywords:i(b),types:i(k+" bool _Complex _Bool float_t double_t intptr_t intmax_t int8_t int16_t int32_t int64_t uintptr_t uintmax_t uint8_t uint16_t uint32_t uint64_t"),blockKeywords:i("case do else for if switch while struct"),defKeywords:i("struct"),typeFirstDefinitions:!0,atoms:i("null true false"),hooks:{"#":s,"*":c},modeProps:{fold:["brace","include"]}}),h(["text/x-c++src","text/x-c++hdr"],{name:"clike",keywords:i(b+" asm dynamic_cast namespace reinterpret_cast try explicit new static_cast typeid catch operator template typename class friend private this using const_cast inline public throw virtual delete mutable protected alignas alignof constexpr decltype nullptr noexcept thread_local final static_assert override"),types:i(k+" bool wchar_t"),blockKeywords:i("catch class do else finally for if struct switch try while"),defKeywords:i("class namespace struct enum union"),typeFirstDefinitions:!0,atoms:i("true false null"),dontIndentStatements:/^template$/,isIdentifierChar:/[\w\$_~\xa1-\uffff]/,hooks:{"#":s,"*":c,u:d,U:d,L:d,R:d,0:u,1:u,2:u,3:u,4:u,5:u,6:u,7:u,8:u,9:u,token:function(e,t,n){if("variable"==n&&"("==e.peek()&&(";"==t.prevToken||null==t.prevToken||"}"==t.prevToken)&&f(e.current()))return"def"}},namespaceSeparator:"::",modeProps:{fold:["brace","include"]}}),h("text/x-java",{name:"clike",keywords:i("abstract assert break case catch class const continue default do else enum extends final finally float for goto if implements import instanceof interface native new package private protected public return static strictfp super switch synchronized this throw throws transient try volatile while @interface"),types:i("byte short int long float double boolean char void Boolean Byte Character Double Float Integer Long Number Object Short String StringBuffer StringBuilder Void"),blockKeywords:i("catch class do else finally for if switch try while"),defKeywords:i("class interface package enum @interface"),typeFirstDefinitions:!0,atoms:i("true false null"),number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,hooks:{"@":function(e){return!e.match("interface",!1)&&(e.eatWhile(/[\w\$_]/),"meta")}},modeProps:{fold:["brace","import"]}}),h("text/x-csharp",{name:"clike",keywords:i("abstract as async await base break case catch checked class const continue default delegate do else enum event explicit extern finally fixed for foreach goto if implicit in interface internal is lock namespace new operator out override params private protected public readonly ref return sealed sizeof stackalloc static struct switch this throw try typeof unchecked unsafe using virtual void volatile while add alias ascending descending dynamic from get global group into join let orderby partial remove select set value var yield"),types:i("Action Boolean Byte Char DateTime DateTimeOffset Decimal Double Func Guid Int16 Int32 Int64 Object SByte Single String Task TimeSpan UInt16 UInt32 UInt64 bool byte char decimal double short int long object sbyte float string ushort uint ulong"),blockKeywords:i("catch class do else finally for foreach if struct switch try while"),defKeywords:i("class interface namespace struct var"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"@":function(e,t){return e.eat('"')?(t.tokenize=p,p(e,t)):(e.eatWhile(/[\w\$_]/),"meta")}}}),h("text/x-scala",{name:"clike",keywords:i("abstract case catch class def do else extends final finally for forSome if implicit import lazy match new null object override package private protected return sealed super this throw trait try type val var while with yield _ assert assume require print println printf readLine readBoolean readByte readShort readChar readInt readLong readFloat readDouble"),types:i("AnyVal App Application Array BufferedIterator BigDecimal BigInt Char Console Either Enumeration Equiv Error Exception Fractional Function IndexedSeq Int Integral Iterable Iterator List Map Numeric Nil NotNull Option Ordered Ordering PartialFunction PartialOrdering Product Proxy Range Responder Seq Serializable Set Specializable Stream StringBuilder StringContext Symbol Throwable Traversable TraversableOnce Tuple Unit Vector Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),multiLineStrings:!0,blockKeywords:i("catch class enum do else finally for forSome if match switch try while"),defKeywords:i("class enum def object package trait type val var"),atoms:i("true false null"),indentStatements:!1,indentSwitch:!1,isOperatorChar:/[+\-*&%=<>!?|\/#:@]/,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return!!e.match('""')&&(t.tokenize=g,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},"=":function(e,n){var r=n.context;return!("}"!=r.type||!r.align||!e.eat(">"))&&(n.context=new t(r.indented,r.column,r.type,r.info,null,r.prev),"operator")}},modeProps:{closeBrackets:{triples:'"'}}}),h("text/x-kotlin",{name:"clike",keywords:i("package as typealias class interface this super val var fun for is in This throw return break continue object if else while do try when !in !is as? file import where by get set abstract enum open inner override private public internal protected catch finally out final vararg reified dynamic companion constructor init sealed field property receiver param sparam lateinit data inline noinline tailrec external annotation crossinline const operator infix suspend"),types:i("Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),intendSwitch:!1,indentStatements:!1,multiLineStrings:!0,number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,blockKeywords:i("catch class do else finally for if where try while enum"),defKeywords:i("class val var object package interface fun"),atoms:i("true false null this"),hooks:{'"':function(e,t){return t.tokenize=y(e.match('""')),t.tokenize(e,t)}},modeProps:{closeBrackets:{triples:'"'}}}),h(["x-shader/x-vertex","x-shader/x-fragment"],{name:"clike",keywords:i("sampler1D sampler2D sampler3D samplerCube sampler1DShadow sampler2DShadow const attribute uniform varying break continue discard return for while do if else struct in out inout"),types:i("float int bool void vec2 vec3 vec4 ivec2 ivec3 ivec4 bvec2 bvec3 bvec4 mat2 mat3 mat4"),blockKeywords:i("for while do if else struct"),builtin:i("radians degrees sin cos tan asin acos atan pow exp log exp2 sqrt inversesqrt abs sign floor ceil fract mod min max clamp mix step smoothstep length distance dot cross normalize ftransform faceforward reflect refract matrixCompMult lessThan lessThanEqual greaterThan greaterThanEqual equal notEqual any all not texture1D texture1DProj texture1DLod texture1DProjLod texture2D texture2DProj texture2DLod texture2DProjLod texture3D texture3DProj texture3DLod texture3DProjLod textureCube textureCubeLod shadow1D shadow2D shadow1DProj shadow2DProj shadow1DLod shadow2DLod shadow1DProjLod shadow2DProjLod dFdx dFdy fwidth noise1 noise2 noise3 noise4"),atoms:i("true false gl_FragColor gl_SecondaryColor gl_Normal gl_Vertex gl_MultiTexCoord0 gl_MultiTexCoord1 gl_MultiTexCoord2 gl_MultiTexCoord3 gl_MultiTexCoord4 gl_MultiTexCoord5 gl_MultiTexCoord6 gl_MultiTexCoord7 gl_FogCoord gl_PointCoord gl_Position gl_PointSize gl_ClipVertex gl_FrontColor gl_BackColor gl_FrontSecondaryColor gl_BackSecondaryColor gl_TexCoord gl_FogFragCoord gl_FragCoord gl_FrontFacing gl_FragData gl_FragDepth gl_ModelViewMatrix gl_ProjectionMatrix gl_ModelViewProjectionMatrix gl_TextureMatrix gl_NormalMatrix gl_ModelViewMatrixInverse gl_ProjectionMatrixInverse gl_ModelViewProjectionMatrixInverse gl_TexureMatrixTranspose gl_ModelViewMatrixInverseTranspose gl_ProjectionMatrixInverseTranspose gl_ModelViewProjectionMatrixInverseTranspose gl_TextureMatrixInverseTranspose gl_NormalScale gl_DepthRange gl_ClipPlane gl_Point gl_FrontMaterial gl_BackMaterial gl_LightSource gl_LightModel gl_FrontLightModelProduct gl_BackLightModelProduct gl_TextureColor gl_EyePlaneS gl_EyePlaneT gl_EyePlaneR gl_EyePlaneQ gl_FogParameters gl_MaxLights gl_MaxClipPlanes gl_MaxTextureUnits gl_MaxTextureCoords gl_MaxVertexAttribs gl_MaxVertexUniformComponents gl_MaxVaryingFloats gl_MaxVertexTextureImageUnits gl_MaxTextureImageUnits gl_MaxFragmentUniformComponents gl_MaxCombineTextureImageUnits gl_MaxDrawBuffers"),indentSwitch:!1,hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-nesc",{name:"clike",keywords:i(b+"as atomic async call command component components configuration event generic implementation includes interface module new norace nx_struct nx_union post provides signal task uses abstract extends"),types:i(k),blockKeywords:i("case do else for if switch while struct"),atoms:i("null true false"),hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-objectivec",{name:"clike",keywords:i(b+"inline restrict _Bool _Complex _Imaginary BOOL Class bycopy byref id IMP in inout nil oneway out Protocol SEL self super atomic nonatomic retain copy readwrite readonly"),types:i(k),atoms:i("YES NO NULL NILL ON OFF true false"),hooks:{"@":function(e){return e.eatWhile(/[\w\$]/),"keyword"},"#":s,indent:function(e,t,n){if("statement"==t.type&&/^@\w/.test(n))return t.indented}},modeProps:{fold:"brace"}}),h("text/x-squirrel",{name:"clike",keywords:i("base break clone continue const default delete enum extends function in class foreach local resume return this throw typeof yield constructor instanceof static"),types:i(k),blockKeywords:i("case catch class else for foreach if switch try while"),defKeywords:i("function local class"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"#":s},modeProps:{fold:["brace","include"]}});var w=null;h("text/x-ceylon",{name:"clike",keywords:i("abstracts alias assembly assert assign break case catch class continue dynamic else exists extends finally for function given if import in interface is let module new nonempty object of out outer package return satisfies super switch then this throw try value void while"),types:function(e){var t=e.charAt(0);return t===t.toUpperCase()&&t!==t.toLowerCase()},blockKeywords:i("case catch class dynamic else finally for function if interface module new object switch try while"),defKeywords:i("class dynamic function interface module object package value"),builtin:i("abstract actual aliased annotation by default deprecated doc final formal late license native optional sealed see serializable shared suppressWarnings tagged throws variable"),isPunctuationChar:/[\[\]{}\(\),;\:\.`]/,isOperatorChar:/[+\-*&%=<>!?|^~:\/]/,numberStart:/[\d#$]/,number:/^(?:#[\da-fA-F_]+|\$[01_]+|[\d_]+[kMGTPmunpf]?|[\d_]+\.[\d_]+(?:[eE][-+]?\d+|[kMGTPmunpf]|)|)/i,multiLineStrings:!0,typeFirstDefinitions:!0,atoms:i("true false null larger smaller equal empty finished"),indentSwitch:!1,styleDefs:!1,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return t.tokenize=x(e.match('""')?"triple":"single"),t.tokenize(e,t)},"`":function(e,t){return!(!w||!e.match("`"))&&(t.tokenize=w,w=null,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},token:function(e,t,n){if(("variable"==n||"type"==n)&&"."==t.prevToken)return"variable-2"}},modeProps:{fold:["brace","import"],closeBrackets:{triples:'"'}}})});
      // -------------------------------------------------------------------------
//  Part of the CodeChecker project, under the Apache License v2.0 with
//  LLVM Exceptions. See LICENSE for license information.
//  SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
// -------------------------------------------------------------------------

var BugViewer = {
  _files : [],
  _reports : [],
  _lineWidgets : [],
  _navigationMenuItems : [],
  _sourceFileData : null,
  _currentReport : null,
  _lastBugEvent  : null,

  init : function (files, reports) {
    this._files = files;
    this._reports = reports;

    this.initEscapeChars();
  },

  initEscapeChars : function () {
    this.escapeChars = {
      ' ' : 'nbsp',
      '<' : 'lt',
      '>' : 'gt',
      '"' : 'quot',
      '&' : 'amp'
    };

    var regexString = '[';
    for (var key in this.escapeChars) {
      regexString += key;
    }
    regexString += ']';

    this.escapeRegExp = new RegExp( regexString, 'g');
  },

  escapeHTML : function (str) {
    var that = this;

    return str.replace(this.escapeRegExp, function (m) {
      return '&' + that.escapeChars[m] + ';';
    });
  },

  initByUrl : function () {
    if (!this._reports) return;

    var state = {};
    window.location.hash.substr(1).split('&').forEach(function (s) {
      var parts = s.split('=');
      state[parts[0]] = parts[1];
    });

    for (var key in this._reports) {
      var report = this._reports[key];
      if (report.reportHash === state['reportHash']) {
        this.navigate(report);
        return;
      }
    }

    this.navigate(this._reports[0]);
  },

  create : function () {
    this._content = document.getElementById('editor-wrapper');
    this._filepath = document.getElementById('file-path');
    this._checkerName = document.getElementById('checker-name');
    this._reviewStatusWrapper =
      document.getElementById('review-status-wrapper');
    this._reviewStatus = document.getElementById('review-status');
    this._editor = document.getElementById('editor');

    this._codeMirror = CodeMirror(this._editor, {
      mode: 'text/x-c++src',
      matchBrackets : true,
      lineNumbers : true,
      readOnly : true,
      foldGutter : true,
      extraKeys : {},
      viewportMargin : 100
    });

    this._createNavigationMenu();
  },

  navigate : function (report, item) {
    if (!item) {
      var items = this._navigationMenuItems.filter(function (navItem) {
        return navItem.report.reportHash === report.reportHash;
      });

      if (!items.length) return;

      item = items[0].widget;
    }

    this._selectedReport.classList.remove('active');
    this._selectedReport = item;
    this._selectedReport.classList.add('active');
    this.setReport(report);
  },

  _createNavigationMenu : function () {
    var that = this;

    var nav = document.getElementById('report-nav');
    var list = document.createElement('ul');
    this._reports.forEach(function (report) {
      var events = report['events'];
      var lastBugEvent = events[events.length - 1];
      var item = document.createElement('li');

      var severity = document.createElement('i');
      severity.className = 'severity-' + report.severity.toLowerCase();

      item.appendChild(severity);
      item.appendChild(document.createTextNode(lastBugEvent.message));

      item.addEventListener('click', function () {
        that.navigate(report, item);
      })
      list.appendChild(item);
      that._navigationMenuItems.push({ report : report, widget : item });
    });

    if (!this._selectedReport && list.childNodes.length) {
      this._selectedReport = list.childNodes[0];
      this._selectedReport.classList.add('active');
    }

    nav.appendChild(list);
  },

  setReport : function (report) {
    this._currentReport = report;
    var events = report['events'];
    var lastBugEvent = events[events.length - 1];
    this.setCurrentBugEvent(lastBugEvent, events.length - 1);
    this.setCheckerName(report.checkerName);
    this.setReviewStatus(report.reviewStatus);

    window.location.hash = '#reportHash=' + report.reportHash;
  },

  setCurrentBugEvent : function (event, idx) {
    this._currentBugEvent = event;
    this.setSourceFileData(this._files[event.location.file]);
    this.drawBugPath();

    this.jumpTo(event.location.line, 0);
    this.highlightBugEvent(event, idx);
  },

  highlightBugEvent : function (event, idx) {
    this._lineWidgets.forEach(function (widget) {
      var lineIdx = widget.node.getAttribute('idx');
      if (parseInt(lineIdx) === idx) {
        widget.node.classList.add('current');
      }
    });
  },

  setCheckerName : function (checkerName) {
    this._checkerName.innerHTML = checkerName;
  },

  setReviewStatus : function (status) {
    if (status) {
      var className =
        'review-status-' + status.toLowerCase().split(' ').join('-');
      this._reviewStatus.className = "review-status " + className;

      this._reviewStatus.innerHTML = status;
      this._reviewStatusWrapper.style.display = 'block';
    } else {
      this._reviewStatusWrapper.style.display = 'none';
    }
  },

  setSourceFileData : function (file) {
    if (this._sourceFileData && file.id === this._sourceFileData.id) {
      return;
    }

    this._sourceFileData = file;
    this._filepath.innerHTML = file.path;
    this._codeMirror.doc.setValue(file.content);
    this._refresh();
  },

  _refresh : function () {
    var that = this;
    setTimeout(function () {
      var fullHeight = parseInt(that._content.clientHeight);
      var headerHeight = that._filepath.clientHeight;

      that._codeMirror.setSize('auto', fullHeight - headerHeight);
      that._codeMirror.refresh();
    }, 200);
  },

  clearBubbles : function () {
    this._lineWidgets.forEach(function (widget) { widget.clear(); });
    this._lineWidgets = [];
  },

  getMessage : function (event, kind) {
    if (kind === 'macro') {
      var name = 'macro expansion' + (event.name ? ': ' + event.name : '');

      return '<span class="tag macro">' + name + '</span>'
        + this.escapeHTML(event.expansion).replace(/(?:\r\n|\r|\n)/g, '<br>');
    } else if (kind === 'note') {
      return '<span class="tag note">note</span>'
        +  this.escapeHTML(event.message).replace(/(?:\r\n|\r|\n)/g, '<br>');
    }
  },

  addExtraPathEvents : function (events, kind) {
    var that = this;

    if (!events) {
      return;
    }

    events.forEach(function (event) {
      if (event.location.file !== that._currentBugEvent.location.file) {
        return;
      }

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + kind);

      var msg = document.createElement('span');
      msg.innerHTML = that.getMessage(event, kind);
      element.appendChild(msg);

      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  drawBugPath : function () {
    var that = this;

    this.clearBubbles();

    this.addExtraPathEvents(this._currentReport.macros, 'macro');
    this.addExtraPathEvents(this._currentReport.notes, 'note');

    // Processing bug path events.
    var currentEvents = this._currentReport.events;
    currentEvents.forEach(function (event, step) {
      if (event.location.file !== that._currentBugEvent.location.file)
        return;

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';
      var type = step === currentEvents.length - 1 ? 'error' : 'info';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + type);
      element.setAttribute('idx', step);

      var enumeration = document.createElement('span');
      enumeration.setAttribute('class', 'checker-enum ' + type);
      enumeration.innerHTML = step + 1;

      if (currentEvents.length > 1)
        element.appendChild(enumeration);

      var prevBugEvent = step - 1;
      if (step > 0) {
        var prevBug = document.createElement('span');
        prevBug.setAttribute('class', 'arrow left-arrow');
        prevBug.addEventListener('click', function () {
          var event = currentEvents[prevBugEvent];
          that.setCurrentBugEvent(event, prevBugEvent);
        });
        element.appendChild(prevBug);
      }

      var msg = document.createElement('span');
      msg.innerHTML = that.escapeHTML(event.message)
        .replace(/(?:\r\n|\r|\n)/g, '<br>');

      element.appendChild(msg);

      var nextBugEvent = step + 1;
      if (nextBugEvent < currentEvents.length) {
        var nextBug = document.createElement('span');
        nextBug.setAttribute('class', 'arrow right-arrow');
        nextBug.addEventListener('click', function () {
          var event = currentEvents[nextBugEvent];
          that.setCurrentBugEvent(event, nextBugEvent);
        });
        element.appendChild(nextBug);
      }


      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  jumpTo : function (line, column) {
    var that = this;

    setTimeout(function () {
      var selPosPixel
        = that._codeMirror.charCoords({ line : line, ch : column }, 'local');
      var editorSize = {
        width  : that._editor.clientWidth,
        height : that._editor.clientHeight
      };

      that._codeMirror.scrollIntoView({
        top    : selPosPixel.top - 100,
        bottom : selPosPixel.top + editorSize.height - 150,
        left   : selPosPixel.left < editorSize.width - 100
               ? 0
               : selPosPixel.left - 50,
        right  : selPosPixel.left < editorSize.width - 100
               ? 10
               : selPosPixel.left + editorSize.width - 100
      });
    }, 0);
  }
}


      var data = {"files": {"10": {"id": 10, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/ilist_node.h", "content": "//===- llvm/ADT/ilist_node.h - Intrusive Linked List Helper -----*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// This file defines the ilist_node class template, which is a convenient\n// base class for creating classes that can be used with ilists.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_ADT_ILIST_NODE_H\n#define LLVM_ADT_ILIST_NODE_H\n\n#include \"llvm/ADT/ilist_node_base.h\"\n#include \"llvm/ADT/ilist_node_options.h\"\n\nnamespace llvm {\n\nnamespace ilist_detail {\n\nstruct NodeAccess;\n\n} // end namespace ilist_detail\n\ntemplate <class OptionsT, bool IsReverse, bool IsConst> class ilist_iterator;\ntemplate <class OptionsT> class ilist_sentinel;\n\n/// Implementation for an ilist node.\n///\n/// Templated on an appropriate \\a ilist_detail::node_options, usually computed\n/// by \\a ilist_detail::compute_node_options.\n///\n/// This is a wrapper around \\a ilist_node_base whose main purpose is to\n/// provide type safety: you can't insert nodes of \\a ilist_node_impl into the\n/// wrong \\a simple_ilist or \\a iplist.\ntemplate <class OptionsT> class ilist_node_impl : OptionsT::node_base_type {\n  using value_type = typename OptionsT::value_type;\n  using node_base_type = typename OptionsT::node_base_type;\n  using list_base_type = typename OptionsT::list_base_type;\n\n  friend typename OptionsT::list_base_type;\n  friend struct ilist_detail::NodeAccess;\n  friend class ilist_sentinel<OptionsT>;\n  friend class ilist_iterator<OptionsT, false, false>;\n  friend class ilist_iterator<OptionsT, false, true>;\n  friend class ilist_iterator<OptionsT, true, false>;\n  friend class ilist_iterator<OptionsT, true, true>;\n\nprotected:\n  using self_iterator = ilist_iterator<OptionsT, false, false>;\n  using const_self_iterator = ilist_iterator<OptionsT, false, true>;\n  using reverse_self_iterator = ilist_iterator<OptionsT, true, false>;\n  using const_reverse_self_iterator = ilist_iterator<OptionsT, true, true>;\n\n  ilist_node_impl() = default;\n\nprivate:\n  ilist_node_impl *getPrev() {\n    return static_cast<ilist_node_impl *>(node_base_type::getPrev());\n  }\n\n  ilist_node_impl *getNext() {\n    return static_cast<ilist_node_impl *>(node_base_type::getNext());\n  }\n\n  const ilist_node_impl *getPrev() const {\n    return static_cast<ilist_node_impl *>(node_base_type::getPrev());\n  }\n\n  const ilist_node_impl *getNext() const {\n    return static_cast<ilist_node_impl *>(node_base_type::getNext());\n  }\n\n  void setPrev(ilist_node_impl *N) { node_base_type::setPrev(N); }\n  void setNext(ilist_node_impl *N) { node_base_type::setNext(N); }\n\npublic:\n  self_iterator getIterator() { return self_iterator(*this); }\n  const_self_iterator getIterator() const { return const_self_iterator(*this); }\n\n  reverse_self_iterator getReverseIterator() {\n    return reverse_self_iterator(*this);\n  }\n\n  const_reverse_self_iterator getReverseIterator() const {\n    return const_reverse_self_iterator(*this);\n  }\n\n  // Under-approximation, but always available for assertions.\n  using node_base_type::isKnownSentinel;\n\n  /// Check whether this is the sentinel node.\n  ///\n  /// This requires sentinel tracking to be explicitly enabled.  Use the\n  /// ilist_sentinel_tracking<true> option to get this API.\n  bool isSentinel() const {\n    static_assert(OptionsT::is_sentinel_tracking_explicit,\n                  \"Use ilist_sentinel_tracking<true> to enable isSentinel()\");\n    return node_base_type::isSentinel();\n  }\n};\n\n/// An intrusive list node.\n///\n/// A base class to enable membership in intrusive lists, including \\a\n/// simple_ilist, \\a iplist, and \\a ilist.  The first template parameter is the\n/// \\a value_type for the list.\n///\n/// An ilist node can be configured with compile-time options to change\n/// behaviour and/or add API.\n///\n/// By default, an \\a ilist_node knows whether it is the list sentinel (an\n/// instance of \\a ilist_sentinel) if and only if\n/// LLVM_ENABLE_ABI_BREAKING_CHECKS.  The function \\a isKnownSentinel() always\n/// returns \\c false tracking is off.  Sentinel tracking steals a bit from the\n/// \"prev\" link, which adds a mask operation when decrementing an iterator, but\n/// enables bug-finding assertions in \\a ilist_iterator.\n///\n/// To turn sentinel tracking on all the time, pass in the\n/// ilist_sentinel_tracking<true> template parameter.  This also enables the \\a\n/// isSentinel() function.  The same option must be passed to the intrusive\n/// list.  (ilist_sentinel_tracking<false> turns sentinel tracking off all the\n/// time.)\n///\n/// A type can inherit from ilist_node multiple times by passing in different\n/// \\a ilist_tag options.  This allows a single instance to be inserted into\n/// multiple lists simultaneously, where each list is given the same tag.\n///\n/// \\example\n/// struct A {};\n/// struct B {};\n/// struct N : ilist_node<N, ilist_tag<A>>, ilist_node<N, ilist_tag<B>> {};\n///\n/// void foo() {\n///   simple_ilist<N, ilist_tag<A>> ListA;\n///   simple_ilist<N, ilist_tag<B>> ListB;\n///   N N1;\n///   ListA.push_back(N1);\n///   ListB.push_back(N1);\n/// }\n/// \\endexample\n///\n/// See \\a is_valid_option for steps on adding a new option.\ntemplate <class T, class... Options>\nclass ilist_node\n    : public ilist_node_impl<\n          typename ilist_detail::compute_node_options<T, Options...>::type> {\n  static_assert(ilist_detail::check_options<Options...>::value,\n                \"Unrecognized node option!\");\n};\n\nnamespace ilist_detail {\n\n/// An access class for ilist_node private API.\n///\n/// This gives access to the private parts of ilist nodes.  Nodes for an ilist\n/// should friend this class if they inherit privately from ilist_node.\n///\n/// Using this class outside of the ilist implementation is unsupported.\nstruct NodeAccess {\nprotected:\n  template <class OptionsT>\n  static ilist_node_impl<OptionsT> *getNodePtr(typename OptionsT::pointer N) {\n    return N;\n  }\n\n  template <class OptionsT>\n  static const ilist_node_impl<OptionsT> *\n  getNodePtr(typename OptionsT::const_pointer N) {\n    return N;\n  }\n\n  template <class OptionsT>\n  static typename OptionsT::pointer getValuePtr(ilist_node_impl<OptionsT> *N) {\n    return static_cast<typename OptionsT::pointer>(N);\n  }\n\n  template <class OptionsT>\n  static typename OptionsT::const_pointer\n  getValuePtr(const ilist_node_impl<OptionsT> *N) {\n    return static_cast<typename OptionsT::const_pointer>(N);\n  }\n\n  template <class OptionsT>\n  static ilist_node_impl<OptionsT> *getPrev(ilist_node_impl<OptionsT> &N) {\n    return N.getPrev();\n  }\n\n  template <class OptionsT>\n  static ilist_node_impl<OptionsT> *getNext(ilist_node_impl<OptionsT> &N) {\n    return N.getNext();\n  }\n\n  template <class OptionsT>\n  static const ilist_node_impl<OptionsT> *\n  getPrev(const ilist_node_impl<OptionsT> &N) {\n    return N.getPrev();\n  }\n\n  template <class OptionsT>\n  static const ilist_node_impl<OptionsT> *\n  getNext(const ilist_node_impl<OptionsT> &N) {\n    return N.getNext();\n  }\n};\n\ntemplate <class OptionsT> struct SpecificNodeAccess : NodeAccess {\nprotected:\n  using pointer = typename OptionsT::pointer;\n  using const_pointer = typename OptionsT::const_pointer;\n  using node_type = ilist_node_impl<OptionsT>;\n\n  static node_type *getNodePtr(pointer N) {\n    return NodeAccess::getNodePtr<OptionsT>(N);\n  }\n\n  static const node_type *getNodePtr(const_pointer N) {\n    return NodeAccess::getNodePtr<OptionsT>(N);\n  }\n\n  static pointer getValuePtr(node_type *N) {\n    return NodeAccess::getValuePtr<OptionsT>(N);\n  }\n\n  static const_pointer getValuePtr(const node_type *N) {\n    return NodeAccess::getValuePtr<OptionsT>(N);\n  }\n};\n\n} // end namespace ilist_detail\n\ntemplate <class OptionsT>\nclass ilist_sentinel : public ilist_node_impl<OptionsT> {\npublic:\n  ilist_sentinel() {\n    this->initializeSentinel();\n    reset();\n  }\n\n  void reset() {\n    this->setPrev(this);\n    this->setNext(this);\n  }\n\n  bool empty() const { return this == this->getPrev(); }\n};\n\n/// An ilist node that can access its parent list.\n///\n/// Requires \\c NodeTy to have \\a getParent() to find the parent node, and the\n/// \\c ParentTy to have \\a getSublistAccess() to get a reference to the list.\ntemplate <typename NodeTy, typename ParentTy, class... Options>\nclass ilist_node_with_parent : public ilist_node<NodeTy, Options...> {\nprotected:\n  ilist_node_with_parent() = default;\n\nprivate:\n  /// Forward to NodeTy::getParent().\n  ///\n  /// Note: do not use the name \"getParent()\".  We want a compile error\n  /// (instead of recursion) when the subclass fails to implement \\a\n  /// getParent().\n  const ParentTy *getNodeParent() const {\n    return static_cast<const NodeTy *>(this)->getParent();\n  }\n\npublic:\n  /// @name Adjacent Node Accessors\n  /// @{\n  /// Get the previous node, or \\c nullptr for the list head.\n  NodeTy *getPrevNode() {\n    // Should be separated to a reused function, but then we couldn't use auto\n    // (and would need the type of the list).\n    const auto &List =\n        getNodeParent()->*(ParentTy::getSublistAccess((NodeTy *)nullptr));\n    return List.getPrevNode(*static_cast<NodeTy *>(this));\n  }\n\n  /// Get the previous node, or \\c nullptr for the list head.\n  const NodeTy *getPrevNode() const {\n    return const_cast<ilist_node_with_parent *>(this)->getPrevNode();\n  }\n\n  /// Get the next node, or \\c nullptr for the list tail.\n  NodeTy *getNextNode() {\n    // Should be separated to a reused function, but then we couldn't use auto\n    // (and would need the type of the list).\n    const auto &List =\n        getNodeParent()->*(ParentTy::getSublistAccess((NodeTy *)nullptr));\n    return List.getNextNode(*static_cast<NodeTy *>(this));\n  }\n\n  /// Get the next node, or \\c nullptr for the list tail.\n  const NodeTy *getNextNode() const {\n    return const_cast<ilist_node_with_parent *>(this)->getNextNode();\n  }\n  /// @}\n};\n\n} // end namespace llvm\n\n#endif // LLVM_ADT_ILIST_NODE_H\n"}, "11": {"id": 11, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/ilist_node_base.h", "content": "//===- llvm/ADT/ilist_node_base.h - Intrusive List Node Base -----*- C++ -*-==//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_ADT_ILIST_NODE_BASE_H\n#define LLVM_ADT_ILIST_NODE_BASE_H\n\n#include \"llvm/ADT/PointerIntPair.h\"\n\nnamespace llvm {\n\n/// Base class for ilist nodes.\n///\n/// Optionally tracks whether this node is the sentinel.\ntemplate <bool EnableSentinelTracking> class ilist_node_base;\n\ntemplate <> class ilist_node_base<false> {\n  ilist_node_base *Prev = nullptr;\n  ilist_node_base *Next = nullptr;\n\npublic:\n  void setPrev(ilist_node_base *Prev) { this->Prev = Prev; }\n  void setNext(ilist_node_base *Next) { this->Next = Next; }\n  ilist_node_base *getPrev() const { return Prev; }\n  ilist_node_base *getNext() const { return Next; }\n\n  bool isKnownSentinel() const { return false; }\n  void initializeSentinel() {}\n};\n\ntemplate <> class ilist_node_base<true> {\n  PointerIntPair<ilist_node_base *, 1> PrevAndSentinel;\n  ilist_node_base *Next = nullptr;\n\npublic:\n  void setPrev(ilist_node_base *Prev) { PrevAndSentinel.setPointer(Prev); }\n  void setNext(ilist_node_base *Next) { this->Next = Next; }\n  ilist_node_base *getPrev() const { return PrevAndSentinel.getPointer(); }\n  ilist_node_base *getNext() const { return Next; }\n\n  bool isSentinel() const { return PrevAndSentinel.getInt(); }\n  bool isKnownSentinel() const { return isSentinel(); }\n  void initializeSentinel() { PrevAndSentinel.setInt(true); }\n};\n\n} // end namespace llvm\n\n#endif // LLVM_ADT_ILIST_NODE_BASE_H\n"}, "12": {"id": 12, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/iterator.h", "content": "//===- iterator.h - Utilities for using and defining iterators --*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_ADT_ITERATOR_H\n#define LLVM_ADT_ITERATOR_H\n\n#include \"llvm/ADT/iterator_range.h\"\n#include <algorithm>\n#include <cstddef>\n#include <iterator>\n#include <type_traits>\n#include <utility>\n\nnamespace llvm {\n\n/// CRTP base class which implements the entire standard iterator facade\n/// in terms of a minimal subset of the interface.\n///\n/// Use this when it is reasonable to implement most of the iterator\n/// functionality in terms of a core subset. If you need special behavior or\n/// there are performance implications for this, you may want to override the\n/// relevant members instead.\n///\n/// Note, one abstraction that this does *not* provide is implementing\n/// subtraction in terms of addition by negating the difference. Negation isn't\n/// always information preserving, and I can see very reasonable iterator\n/// designs where this doesn't work well. It doesn't really force much added\n/// boilerplate anyways.\n///\n/// Another abstraction that this doesn't provide is implementing increment in\n/// terms of addition of one. These aren't equivalent for all iterator\n/// categories, and respecting that adds a lot of complexity for little gain.\n///\n/// Classes wishing to use `iterator_facade_base` should implement the following\n/// methods:\n///\n/// Forward Iterators:\n///   (All of the following methods)\n///   - DerivedT &operator=(const DerivedT &R);\n///   - bool operator==(const DerivedT &R) const;\n///   - const T &operator*() const;\n///   - T &operator*();\n///   - DerivedT &operator++();\n///\n/// Bidirectional Iterators:\n///   (All methods of forward iterators, plus the following)\n///   - DerivedT &operator--();\n///\n/// Random-access Iterators:\n///   (All methods of bidirectional iterators excluding the following)\n///   - DerivedT &operator++();\n///   - DerivedT &operator--();\n///   (and plus the following)\n///   - bool operator<(const DerivedT &RHS) const;\n///   - DifferenceTypeT operator-(const DerivedT &R) const;\n///   - DerivedT &operator+=(DifferenceTypeT N);\n///   - DerivedT &operator-=(DifferenceTypeT N);\n///\ntemplate <typename DerivedT, typename IteratorCategoryT, typename T,\n          typename DifferenceTypeT = std::ptrdiff_t, typename PointerT = T *,\n          typename ReferenceT = T &>\nclass iterator_facade_base\n    : public std::iterator<IteratorCategoryT, T, DifferenceTypeT, PointerT,\n                           ReferenceT> {\nprotected:\n  enum {\n    IsRandomAccess = std::is_base_of<std::random_access_iterator_tag,\n                                     IteratorCategoryT>::value,\n    IsBidirectional = std::is_base_of<std::bidirectional_iterator_tag,\n                                      IteratorCategoryT>::value,\n  };\n\n  /// A proxy object for computing a reference via indirecting a copy of an\n  /// iterator. This is used in APIs which need to produce a reference via\n  /// indirection but for which the iterator object might be a temporary. The\n  /// proxy preserves the iterator internally and exposes the indirected\n  /// reference via a conversion operator.\n  class ReferenceProxy {\n    friend iterator_facade_base;\n\n    DerivedT I;\n\n    ReferenceProxy(DerivedT I) : I(std::move(I)) {}\n\n  public:\n    operator ReferenceT() const { return *I; }\n  };\n\npublic:\n  DerivedT operator+(DifferenceTypeT n) const {\n    static_assert(std::is_base_of<iterator_facade_base, DerivedT>::value,\n                  \"Must pass the derived type to this template!\");\n    static_assert(\n        IsRandomAccess,\n        \"The '+' operator is only defined for random access iterators.\");\n    DerivedT tmp = *static_cast<const DerivedT *>(this);\n    tmp += n;\n    return tmp;\n  }\n  friend DerivedT operator+(DifferenceTypeT n, const DerivedT &i) {\n    static_assert(\n        IsRandomAccess,\n        \"The '+' operator is only defined for random access iterators.\");\n    return i + n;\n  }\n  DerivedT operator-(DifferenceTypeT n) const {\n    static_assert(\n        IsRandomAccess,\n        \"The '-' operator is only defined for random access iterators.\");\n    DerivedT tmp = *static_cast<const DerivedT *>(this);\n    tmp -= n;\n    return tmp;\n  }\n\n  DerivedT &operator++() {\n    static_assert(std::is_base_of<iterator_facade_base, DerivedT>::value,\n                  \"Must pass the derived type to this template!\");\n    return static_cast<DerivedT *>(this)->operator+=(1);\n  }\n  DerivedT operator++(int) {\n    DerivedT tmp = *static_cast<DerivedT *>(this);\n    ++*static_cast<DerivedT *>(this);\n    return tmp;\n  }\n  DerivedT &operator--() {\n    static_assert(\n        IsBidirectional,\n        \"The decrement operator is only defined for bidirectional iterators.\");\n    return static_cast<DerivedT *>(this)->operator-=(1);\n  }\n  DerivedT operator--(int) {\n    static_assert(\n        IsBidirectional,\n        \"The decrement operator is only defined for bidirectional iterators.\");\n    DerivedT tmp = *static_cast<DerivedT *>(this);\n    --*static_cast<DerivedT *>(this);\n    return tmp;\n  }\n\n#ifndef __cpp_impl_three_way_comparison\n  bool operator!=(const DerivedT &RHS) const {\n    return !(static_cast<const DerivedT &>(*this) == RHS);\n  }\n#endif\n\n  bool operator>(const DerivedT &RHS) const {\n    static_assert(\n        IsRandomAccess,\n        \"Relational operators are only defined for random access iterators.\");\n    return !(static_cast<const DerivedT &>(*this) < RHS) &&\n           !(static_cast<const DerivedT &>(*this) == RHS);\n  }\n  bool operator<=(const DerivedT &RHS) const {\n    static_assert(\n        IsRandomAccess,\n        \"Relational operators are only defined for random access iterators.\");\n    return !(static_cast<const DerivedT &>(*this) > RHS);\n  }\n  bool operator>=(const DerivedT &RHS) const {\n    static_assert(\n        IsRandomAccess,\n        \"Relational operators are only defined for random access iterators.\");\n    return !(static_cast<const DerivedT &>(*this) < RHS);\n  }\n\n  PointerT operator->() { return &static_cast<DerivedT *>(this)->operator*(); }\n  PointerT operator->() const {\n    return &static_cast<const DerivedT *>(this)->operator*();\n  }\n  ReferenceProxy operator[](DifferenceTypeT n) {\n    static_assert(IsRandomAccess,\n                  \"Subscripting is only defined for random access iterators.\");\n    return ReferenceProxy(static_cast<DerivedT *>(this)->operator+(n));\n  }\n  ReferenceProxy operator[](DifferenceTypeT n) const {\n    static_assert(IsRandomAccess,\n                  \"Subscripting is only defined for random access iterators.\");\n    return ReferenceProxy(static_cast<const DerivedT *>(this)->operator+(n));\n  }\n};\n\n/// CRTP base class for adapting an iterator to a different type.\n///\n/// This class can be used through CRTP to adapt one iterator into another.\n/// Typically this is done through providing in the derived class a custom \\c\n/// operator* implementation. Other methods can be overridden as well.\ntemplate <\n    typename DerivedT, typename WrappedIteratorT,\n    typename IteratorCategoryT =\n        typename std::iterator_traits<WrappedIteratorT>::iterator_category,\n    typename T = typename std::iterator_traits<WrappedIteratorT>::value_type,\n    typename DifferenceTypeT =\n        typename std::iterator_traits<WrappedIteratorT>::difference_type,\n    typename PointerT = std::conditional_t<\n        std::is_same<T, typename std::iterator_traits<\n                            WrappedIteratorT>::value_type>::value,\n        typename std::iterator_traits<WrappedIteratorT>::pointer, T *>,\n    typename ReferenceT = std::conditional_t<\n        std::is_same<T, typename std::iterator_traits<\n                            WrappedIteratorT>::value_type>::value,\n        typename std::iterator_traits<WrappedIteratorT>::reference, T &>>\nclass iterator_adaptor_base\n    : public iterator_facade_base<DerivedT, IteratorCategoryT, T,\n                                  DifferenceTypeT, PointerT, ReferenceT> {\n  using BaseT = typename iterator_adaptor_base::iterator_facade_base;\n\nprotected:\n  WrappedIteratorT I;\n\n  iterator_adaptor_base() = default;\n\n  explicit iterator_adaptor_base(WrappedIteratorT u) : I(std::move(u)) {\n    static_assert(std::is_base_of<iterator_adaptor_base, DerivedT>::value,\n                  \"Must pass the derived type to this template!\");\n  }\n\n  const WrappedIteratorT &wrapped() const { return I; }\n\npublic:\n  using difference_type = DifferenceTypeT;\n\n  DerivedT &operator+=(difference_type n) {\n    static_assert(\n        BaseT::IsRandomAccess,\n        \"The '+=' operator is only defined for random access iterators.\");\n    I += n;\n    return *static_cast<DerivedT *>(this);\n  }\n  DerivedT &operator-=(difference_type n) {\n    static_assert(\n        BaseT::IsRandomAccess,\n        \"The '-=' operator is only defined for random access iterators.\");\n    I -= n;\n    return *static_cast<DerivedT *>(this);\n  }\n  using BaseT::operator-;\n  difference_type operator-(const DerivedT &RHS) const {\n    static_assert(\n        BaseT::IsRandomAccess,\n        \"The '-' operator is only defined for random access iterators.\");\n    return I - RHS.I;\n  }\n\n  // We have to explicitly provide ++ and -- rather than letting the facade\n  // forward to += because WrappedIteratorT might not support +=.\n  using BaseT::operator++;\n  DerivedT &operator++() {\n    ++I;\n    return *static_cast<DerivedT *>(this);\n  }\n  using BaseT::operator--;\n  DerivedT &operator--() {\n    static_assert(\n        BaseT::IsBidirectional,\n        \"The decrement operator is only defined for bidirectional iterators.\");\n    --I;\n    return *static_cast<DerivedT *>(this);\n  }\n\n  friend bool operator==(const iterator_adaptor_base &LHS,\n                         const iterator_adaptor_base &RHS) {\n    return LHS.I == RHS.I;\n  }\n  friend bool operator<(const iterator_adaptor_base &LHS,\n                        const iterator_adaptor_base &RHS) {\n    static_assert(\n        BaseT::IsRandomAccess,\n        \"Relational operators are only defined for random access iterators.\");\n    return LHS.I < RHS.I;\n  }\n\n  ReferenceT operator*() const { return *I; }\n};\n\n/// An iterator type that allows iterating over the pointees via some\n/// other iterator.\n///\n/// The typical usage of this is to expose a type that iterates over Ts, but\n/// which is implemented with some iterator over T*s:\n///\n/// \\code\n///   using iterator = pointee_iterator<SmallVectorImpl<T *>::iterator>;\n/// \\endcode\ntemplate <typename WrappedIteratorT,\n          typename T = std::remove_reference_t<decltype(\n              **std::declval<WrappedIteratorT>())>>\nstruct pointee_iterator\n    : iterator_adaptor_base<\n          pointee_iterator<WrappedIteratorT, T>, WrappedIteratorT,\n          typename std::iterator_traits<WrappedIteratorT>::iterator_category,\n          T> {\n  pointee_iterator() = default;\n  template <typename U>\n  pointee_iterator(U &&u)\n      : pointee_iterator::iterator_adaptor_base(std::forward<U &&>(u)) {}\n\n  T &operator*() const { return **this->I; }\n};\n\ntemplate <typename RangeT, typename WrappedIteratorT =\n                               decltype(std::begin(std::declval<RangeT>()))>\niterator_range<pointee_iterator<WrappedIteratorT>>\nmake_pointee_range(RangeT &&Range) {\n  using PointeeIteratorT = pointee_iterator<WrappedIteratorT>;\n  return make_range(PointeeIteratorT(std::begin(std::forward<RangeT>(Range))),\n                    PointeeIteratorT(std::end(std::forward<RangeT>(Range))));\n}\n\ntemplate <typename WrappedIteratorT,\n          typename T = decltype(&*std::declval<WrappedIteratorT>())>\nclass pointer_iterator\n    : public iterator_adaptor_base<\n          pointer_iterator<WrappedIteratorT, T>, WrappedIteratorT,\n          typename std::iterator_traits<WrappedIteratorT>::iterator_category,\n          T> {\n  mutable T Ptr;\n\npublic:\n  pointer_iterator() = default;\n\n  explicit pointer_iterator(WrappedIteratorT u)\n      : pointer_iterator::iterator_adaptor_base(std::move(u)) {}\n\n  T &operator*() { return Ptr = &*this->I; }\n  const T &operator*() const { return Ptr = &*this->I; }\n};\n\ntemplate <typename RangeT, typename WrappedIteratorT =\n                               decltype(std::begin(std::declval<RangeT>()))>\niterator_range<pointer_iterator<WrappedIteratorT>>\nmake_pointer_range(RangeT &&Range) {\n  using PointerIteratorT = pointer_iterator<WrappedIteratorT>;\n  return make_range(PointerIteratorT(std::begin(std::forward<RangeT>(Range))),\n                    PointerIteratorT(std::end(std::forward<RangeT>(Range))));\n}\n\ntemplate <typename WrappedIteratorT,\n          typename T1 = std::remove_reference_t<decltype(\n              **std::declval<WrappedIteratorT>())>,\n          typename T2 = std::add_pointer_t<T1>>\nusing raw_pointer_iterator =\n    pointer_iterator<pointee_iterator<WrappedIteratorT, T1>, T2>;\n\n// Wrapper iterator over iterator ItType, adding DataRef to the type of ItType,\n// to create NodeRef = std::pair<InnerTypeOfItType, DataRef>.\ntemplate <typename ItType, typename NodeRef, typename DataRef>\nclass WrappedPairNodeDataIterator\n    : public iterator_adaptor_base<\n          WrappedPairNodeDataIterator<ItType, NodeRef, DataRef>, ItType,\n          typename std::iterator_traits<ItType>::iterator_category, NodeRef,\n          std::ptrdiff_t, NodeRef *, NodeRef &> {\n  using BaseT = iterator_adaptor_base<\n      WrappedPairNodeDataIterator, ItType,\n      typename std::iterator_traits<ItType>::iterator_category, NodeRef,\n      std::ptrdiff_t, NodeRef *, NodeRef &>;\n\n  const DataRef DR;\n  mutable NodeRef NR;\n\npublic:\n  WrappedPairNodeDataIterator(ItType Begin, const DataRef DR)\n      : BaseT(Begin), DR(DR) {\n    NR.first = DR;\n  }\n\n  NodeRef &operator*() const {\n    NR.second = *this->I;\n    return NR;\n  }\n};\n\n} // end namespace llvm\n\n#endif // LLVM_ADT_ITERATOR_H\n"}, "14": {"id": 14, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/BinaryFormat/Dwarf.h", "content": "//===-- llvm/BinaryFormat/Dwarf.h ---Dwarf Constants-------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n/// \\file\n/// This file contains constants used for implementing Dwarf\n/// debug support.\n///\n/// For details on the Dwarf specfication see the latest DWARF Debugging\n/// Information Format standard document on http://www.dwarfstd.org. This\n/// file often includes support for non-released standard features.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_BINARYFORMAT_DWARF_H\n#define LLVM_BINARYFORMAT_DWARF_H\n\n#include \"llvm/ADT/Optional.h\"\n#include \"llvm/Support/Compiler.h\"\n#include \"llvm/Support/DataTypes.h\"\n#include \"llvm/Support/ErrorHandling.h\"\n#include \"llvm/Support/Format.h\"\n#include \"llvm/Support/FormatVariadicDetails.h\"\n#include \"llvm/ADT/Triple.h\"\n\n#include <limits>\n\nnamespace llvm {\nclass StringRef;\n\nnamespace dwarf {\n\n//===----------------------------------------------------------------------===//\n// DWARF constants as gleaned from the DWARF Debugging Information Format V.5\n// reference manual http://www.dwarfstd.org/.\n//\n\n// Do not mix the following two enumerations sets.  DW_TAG_invalid changes the\n// enumeration base type.\n\nenum LLVMConstants : uint32_t {\n  /// LLVM mock tags (see also llvm/BinaryFormat/Dwarf.def).\n  /// \\{\n  DW_TAG_invalid = ~0U,        ///< Tag for invalid results.\n  DW_VIRTUALITY_invalid = ~0U, ///< Virtuality for invalid results.\n  DW_MACINFO_invalid = ~0U,    ///< Macinfo type for invalid results.\n  /// \\}\n\n  /// Special values for an initial length field.\n  /// \\{\n  DW_LENGTH_lo_reserved = 0xfffffff0, ///< Lower bound of the reserved range.\n  DW_LENGTH_DWARF64 = 0xffffffff,     ///< Indicator of 64-bit DWARF format.\n  DW_LENGTH_hi_reserved = 0xffffffff, ///< Upper bound of the reserved range.\n  /// \\}\n\n  /// Other constants.\n  /// \\{\n  DWARF_VERSION = 4,       ///< Default dwarf version we output.\n  DW_PUBTYPES_VERSION = 2, ///< Section version number for .debug_pubtypes.\n  DW_PUBNAMES_VERSION = 2, ///< Section version number for .debug_pubnames.\n  DW_ARANGES_VERSION = 2,  ///< Section version number for .debug_aranges.\n  /// \\}\n\n  /// Identifiers we use to distinguish vendor extensions.\n  /// \\{\n  DWARF_VENDOR_DWARF = 0, ///< Defined in v2 or later of the DWARF standard.\n  DWARF_VENDOR_APPLE = 1,\n  DWARF_VENDOR_BORLAND = 2,\n  DWARF_VENDOR_GNU = 3,\n  DWARF_VENDOR_GOOGLE = 4,\n  DWARF_VENDOR_LLVM = 5,\n  DWARF_VENDOR_MIPS = 6,\n  DWARF_VENDOR_WASM = 7,\n  DWARF_VENDOR_ALTIUM,\n  DWARF_VENDOR_COMPAQ,\n  DWARF_VENDOR_GHS,\n  DWARF_VENDOR_GO,\n  DWARF_VENDOR_HP,\n  DWARF_VENDOR_IBM,\n  DWARF_VENDOR_INTEL,\n  DWARF_VENDOR_PGI,\n  DWARF_VENDOR_SUN,\n  DWARF_VENDOR_UPC,\n  ///\\}\n};\n\n/// Constants that define the DWARF format as 32 or 64 bit.\nenum DwarfFormat : uint8_t { DWARF32, DWARF64 };\n\n/// Special ID values that distinguish a CIE from a FDE in DWARF CFI.\n/// Not inside an enum because a 64-bit value is needed.\n/// @{\nconst uint32_t DW_CIE_ID = UINT32_MAX;\nconst uint64_t DW64_CIE_ID = UINT64_MAX;\n/// @}\n\n/// Identifier of an invalid DIE offset in the .debug_info section.\nconst uint32_t DW_INVALID_OFFSET = UINT32_MAX;\n\nenum Tag : uint16_t {\n#define HANDLE_DW_TAG(ID, NAME, VERSION, VENDOR, KIND) DW_TAG_##NAME = ID,\n#include \"llvm/BinaryFormat/Dwarf.def\"\n  DW_TAG_lo_user = 0x4080,\n  DW_TAG_hi_user = 0xffff,\n  DW_TAG_user_base = 0x1000 ///< Recommended base for user tags.\n};\n\ninline bool isType(Tag T) {\n  switch (T) {\n  default:\n    return false;\n#define HANDLE_DW_TAG(ID, NAME, VERSION, VENDOR, KIND)                         \\\n  case DW_TAG_##NAME:                                                          \\\n    return (KIND == DW_KIND_TYPE);\n#include \"llvm/BinaryFormat/Dwarf.def\"\n  }\n}\n\n/// Attributes.\nenum Attribute : uint16_t {\n#define HANDLE_DW_AT(ID, NAME, VERSION, VENDOR) DW_AT_##NAME = ID,\n#include \"llvm/BinaryFormat/Dwarf.def\"\n  DW_AT_lo_user = 0x2000,\n  DW_AT_hi_user = 0x3fff,\n};\n\nenum Form : uint16_t {\n#define HANDLE_DW_FORM(ID, NAME, VERSION, VENDOR) DW_FORM_##NAME = ID,\n#include \"llvm/BinaryFormat/Dwarf.def\"\n  DW_FORM_lo_user = 0x1f00, ///< Not specified by DWARF.\n};\n\nenum LocationAtom {\n#define HANDLE_DW_OP(ID, NAME, VERSION, VENDOR) DW_OP_##NAME = ID,\n#include \"llvm/BinaryFormat/Dwarf.def\"\n  DW_OP_lo_user = 0xe0,\n  DW_OP_hi_user = 0xff,\n  DW_OP_LLVM_fragment = 0x1000,         ///< Only used in LLVM metadata.\n  DW_OP_LLVM_convert = 0x1001,          ///< Only used in LLVM metadata.\n  DW_OP_LLVM_tag_offset = 0x1002,       ///< Only used in LLVM metadata.\n  DW_OP_LLVM_entry_value = 0x1003,      ///< Only used in LLVM metadata.\n  DW_OP_LLVM_implicit_pointer = 0x1004, ///< Only used in LLVM metadata.\n  DW_OP_LLVM_arg = 0x1005,              ///< Only used in LLVM metadata.\n};\n\nenum TypeKind : uint8_t {\n#define HANDLE_DW_ATE(ID, NAME, VERSION, VENDOR) DW_ATE_##NAME = ID,\n#include \"llvm/BinaryFormat/Dwarf.def\"\n  DW_ATE_lo_user = 0x80,\n  DW_ATE_hi_user = 0xff\n};\n\nenum DecimalSignEncoding {\n  // Decimal sign attribute values\n  DW_DS_unsigned = 0x01,\n  DW_DS_leading_overpunch = 0x02,\n  DW_DS_trailing_overpunch = 0x03,\n  DW_DS_leading_separate = 0x04,\n  DW_DS_trailing_separate = 0x05\n};\n\nenum EndianityEncoding {\n  // Endianity attribute values\n#define HANDLE_DW_END(ID, NAME) DW_END_##NAME = ID,\n#include \"llvm/BinaryFormat/Dwarf.def\"\n  DW_END_lo_user = 0x40,\n  DW_END_hi_user = 0xff\n};\n\nenum AccessAttribute {\n  // Accessibility codes\n  DW_ACCESS_public = 0x01,\n  DW_ACCESS_protected = 0x02,\n  DW_ACCESS_private = 0x03\n};\n\nenum VisibilityAttribute {\n  // Visibility codes\n  DW_VIS_local = 0x01,\n  DW_VIS_exported = 0x02,\n  DW_VIS_qualified = 0x03\n};\n\nenum VirtualityAttribute {\n#define HANDLE_DW_VIRTUALITY(ID, NAME) DW_VIRTUALITY_##NAME = ID,\n#include \"llvm/BinaryFormat/Dwarf.def\"\n  DW_VIRTUALITY_max = 0x02\n};\n\nenum DefaultedMemberAttribute {\n#define HANDLE_DW_DEFAULTED(ID, NAME) DW_DEFAULTED_##NAME = ID,\n#include \"llvm/BinaryFormat/Dwarf.def\"\n  DW_DEFAULTED_max = 0x02\n};\n\nenum SourceLanguage {\n#define HANDLE_DW_LANG(ID, NAME, LOWER_BOUND, VERSION, VENDOR)                 \\\n  DW_LANG_##NAME = ID,\n#include \"llvm/BinaryFormat/Dwarf.def\"\n  DW_LANG_lo_user = 0x8000,\n  DW_LANG_hi_user = 0xffff\n};\n\ninline bool isCPlusPlus(SourceLanguage S) {\n  bool result = false;\n  // Deliberately enumerate all the language options so we get a warning when\n  // new language options are added (-Wswitch) that'll hopefully help keep this\n  // switch up-to-date when new C++ versions are added.\n  switch (S) {\n  case DW_LANG_C_plus_plus:\n  case DW_LANG_C_plus_plus_03:\n  case DW_LANG_C_plus_plus_11:\n  case DW_LANG_C_plus_plus_14:\n    result = true;\n    break;\n  case DW_LANG_C89:\n  case DW_LANG_C:\n  case DW_LANG_Ada83:\n  case DW_LANG_Cobol74:\n  case DW_LANG_Cobol85:\n  case DW_LANG_Fortran77:\n  case DW_LANG_Fortran90:\n  case DW_LANG_Pascal83:\n  case DW_LANG_Modula2:\n  case DW_LANG_Java:\n  case DW_LANG_C99:\n  case DW_LANG_Ada95:\n  case DW_LANG_Fortran95:\n  case DW_LANG_PLI:\n  case DW_LANG_ObjC:\n  case DW_LANG_ObjC_plus_plus:\n  case DW_LANG_UPC:\n  case DW_LANG_D:\n  case DW_LANG_Python:\n  case DW_LANG_OpenCL:\n  case DW_LANG_Go:\n  case DW_LANG_Modula3:\n  case DW_LANG_Haskell:\n  case DW_LANG_OCaml:\n  case DW_LANG_Rust:\n  case DW_LANG_C11:\n  case DW_LANG_Swift:\n  case DW_LANG_Julia:\n  case DW_LANG_Dylan:\n  case DW_LANG_Fortran03:\n  case DW_LANG_Fortran08:\n  case DW_LANG_RenderScript:\n  case DW_LANG_BLISS:\n  case DW_LANG_Mips_Assembler:\n  case DW_LANG_GOOGLE_RenderScript:\n  case DW_LANG_BORLAND_Delphi:\n  case DW_LANG_lo_user:\n  case DW_LANG_hi_user:\n    result = false;\n    break;\n  }\n\n  return result;\n}\n\ninline bool isFortran(SourceLanguage S) {\n  bool result = false;\n  // Deliberately enumerate all the language options so we get a warning when\n  // new language options are added (-Wswitch) that'll hopefully help keep this\n  // switch up-to-date when new Fortran versions are added.\n  switch (S) {\n  case DW_LANG_Fortran77:\n  case DW_LANG_Fortran90:\n  case DW_LANG_Fortran95:\n  case DW_LANG_Fortran03:\n  case DW_LANG_Fortran08:\n    result = true;\n    break;\n  case DW_LANG_C89:\n  case DW_LANG_C:\n  case DW_LANG_Ada83:\n  case DW_LANG_C_plus_plus:\n  case DW_LANG_Cobol74:\n  case DW_LANG_Cobol85:\n  case DW_LANG_Pascal83:\n  case DW_LANG_Modula2:\n  case DW_LANG_Java:\n  case DW_LANG_C99:\n  case DW_LANG_Ada95:\n  case DW_LANG_PLI:\n  case DW_LANG_ObjC:\n  case DW_LANG_ObjC_plus_plus:\n  case DW_LANG_UPC:\n  case DW_LANG_D:\n  case DW_LANG_Python:\n  case DW_LANG_OpenCL:\n  case DW_LANG_Go:\n  case DW_LANG_Modula3:\n  case DW_LANG_Haskell:\n  case DW_LANG_C_plus_plus_03:\n  case DW_LANG_C_plus_plus_11:\n  case DW_LANG_OCaml:\n  case DW_LANG_Rust:\n  case DW_LANG_C11:\n  case DW_LANG_Swift:\n  case DW_LANG_Julia:\n  case DW_LANG_Dylan:\n  case DW_LANG_C_plus_plus_14:\n  case DW_LANG_RenderScript:\n  case DW_LANG_BLISS:\n  case DW_LANG_Mips_Assembler:\n  case DW_LANG_GOOGLE_RenderScript:\n  case DW_LANG_BORLAND_Delphi:\n  case DW_LANG_lo_user:\n  case DW_LANG_hi_user:\n    result = false;\n    break;\n  }\n\n  return result;\n}\n\nenum CaseSensitivity {\n  // Identifier case codes\n  DW_ID_case_sensitive = 0x00,\n  DW_ID_up_case = 0x01,\n  DW_ID_down_case = 0x02,\n  DW_ID_case_insensitive = 0x03\n};\n\nenum CallingConvention {\n// Calling convention codes\n#define HANDLE_DW_CC(ID, NAME) DW_CC_##NAME = ID,\n#include \"llvm/BinaryFormat/Dwarf.def\"\n  DW_CC_lo_user = 0x40,\n  DW_CC_hi_user = 0xff\n};\n\nenum InlineAttribute {\n  // Inline codes\n  DW_INL_not_inlined = 0x00,\n  DW_INL_inlined = 0x01,\n  DW_INL_declared_not_inlined = 0x02,\n  DW_INL_declared_inlined = 0x03\n};\n\nenum ArrayDimensionOrdering {\n  // Array ordering\n  DW_ORD_row_major = 0x00,\n  DW_ORD_col_major = 0x01\n};\n\nenum DiscriminantList {\n  // Discriminant descriptor values\n  DW_DSC_label = 0x00,\n  DW_DSC_range = 0x01\n};\n\n/// Line Number Standard Opcode Encodings.\nenum LineNumberOps : uint8_t {\n#define HANDLE_DW_LNS(ID, NAME) DW_LNS_##NAME = ID,\n#include \"llvm/BinaryFormat/Dwarf.def\"\n};\n\n/// Line Number Extended Opcode Encodings.\nenum LineNumberExtendedOps {\n#define HANDLE_DW_LNE(ID, NAME) DW_LNE_##NAME = ID,\n#include \"llvm/BinaryFormat/Dwarf.def\"\n  DW_LNE_lo_user = 0x80,\n  DW_LNE_hi_user = 0xff\n};\n\nenum LineNumberEntryFormat {\n#define HANDLE_DW_LNCT(ID, NAME) DW_LNCT_##NAME = ID,\n#include \"llvm/BinaryFormat/Dwarf.def\"\n  DW_LNCT_lo_user = 0x2000,\n  DW_LNCT_hi_user = 0x3fff,\n};\n\nenum MacinfoRecordType {\n  // Macinfo Type Encodings\n  DW_MACINFO_define = 0x01,\n  DW_MACINFO_undef = 0x02,\n  DW_MACINFO_start_file = 0x03,\n  DW_MACINFO_end_file = 0x04,\n  DW_MACINFO_vendor_ext = 0xff\n};\n\n/// DWARF v5 macro information entry type encodings.\nenum MacroEntryType {\n#define HANDLE_DW_MACRO(ID, NAME) DW_MACRO_##NAME = ID,\n#include \"llvm/BinaryFormat/Dwarf.def\"\n  DW_MACRO_lo_user = 0xe0,\n  DW_MACRO_hi_user = 0xff\n};\n\n/// GNU .debug_macro macro information entry type encodings.\nenum GnuMacroEntryType {\n#define HANDLE_DW_MACRO_GNU(ID, NAME) DW_MACRO_GNU_##NAME = ID,\n#include \"llvm/BinaryFormat/Dwarf.def\"\n  DW_MACRO_GNU_lo_user = 0xe0,\n  DW_MACRO_GNU_hi_user = 0xff\n};\n\n/// DWARF v5 range list entry encoding values.\nenum RnglistEntries {\n#define HANDLE_DW_RLE(ID, NAME) DW_RLE_##NAME = ID,\n#include \"llvm/BinaryFormat/Dwarf.def\"\n};\n\n/// DWARF v5 loc list entry encoding values.\nenum LoclistEntries {\n#define HANDLE_DW_LLE(ID, NAME) DW_LLE_##NAME = ID,\n#include \"llvm/BinaryFormat/Dwarf.def\"\n};\n\n/// Call frame instruction encodings.\nenum CallFrameInfo {\n#define HANDLE_DW_CFA(ID, NAME) DW_CFA_##NAME = ID,\n#define HANDLE_DW_CFA_PRED(ID, NAME, ARCH) DW_CFA_##NAME = ID,\n#include \"llvm/BinaryFormat/Dwarf.def\"\n  DW_CFA_extended = 0x00,\n\n  DW_CFA_lo_user = 0x1c,\n  DW_CFA_hi_user = 0x3f\n};\n\nenum Constants {\n  // Children flag\n  DW_CHILDREN_no = 0x00,\n  DW_CHILDREN_yes = 0x01,\n\n  DW_EH_PE_absptr = 0x00,\n  DW_EH_PE_omit = 0xff,\n  DW_EH_PE_uleb128 = 0x01,\n  DW_EH_PE_udata2 = 0x02,\n  DW_EH_PE_udata4 = 0x03,\n  DW_EH_PE_udata8 = 0x04,\n  DW_EH_PE_sleb128 = 0x09,\n  DW_EH_PE_sdata2 = 0x0A,\n  DW_EH_PE_sdata4 = 0x0B,\n  DW_EH_PE_sdata8 = 0x0C,\n  DW_EH_PE_signed = 0x08,\n  DW_EH_PE_pcrel = 0x10,\n  DW_EH_PE_textrel = 0x20,\n  DW_EH_PE_datarel = 0x30,\n  DW_EH_PE_funcrel = 0x40,\n  DW_EH_PE_aligned = 0x50,\n  DW_EH_PE_indirect = 0x80\n};\n\n/// Constants for the DW_APPLE_PROPERTY_attributes attribute.\n/// Keep this list in sync with clang's DeclObjCCommon.h\n/// ObjCPropertyAttribute::Kind!\nenum ApplePropertyAttributes {\n#define HANDLE_DW_APPLE_PROPERTY(ID, NAME) DW_APPLE_PROPERTY_##NAME = ID,\n#include \"llvm/BinaryFormat/Dwarf.def\"\n};\n\n/// Constants for unit types in DWARF v5.\nenum UnitType : unsigned char {\n#define HANDLE_DW_UT(ID, NAME) DW_UT_##NAME = ID,\n#include \"llvm/BinaryFormat/Dwarf.def\"\n  DW_UT_lo_user = 0x80,\n  DW_UT_hi_user = 0xff\n};\n\nenum Index {\n#define HANDLE_DW_IDX(ID, NAME) DW_IDX_##NAME = ID,\n#include \"llvm/BinaryFormat/Dwarf.def\"\n  DW_IDX_lo_user = 0x2000,\n  DW_IDX_hi_user = 0x3fff\n};\n\ninline bool isUnitType(uint8_t UnitType) {\n  switch (UnitType) {\n  case DW_UT_compile:\n  case DW_UT_type:\n  case DW_UT_partial:\n  case DW_UT_skeleton:\n  case DW_UT_split_compile:\n  case DW_UT_split_type:\n    return true;\n  default:\n    return false;\n  }\n}\n\ninline bool isUnitType(dwarf::Tag T) {\n  switch (T) {\n  case DW_TAG_compile_unit:\n  case DW_TAG_type_unit:\n  case DW_TAG_partial_unit:\n  case DW_TAG_skeleton_unit:\n    return true;\n  default:\n    return false;\n  }\n}\n\n// Constants for the DWARF v5 Accelerator Table Proposal\nenum AcceleratorTable {\n  // Data layout descriptors.\n  DW_ATOM_null = 0u,       ///  Marker as the end of a list of atoms.\n  DW_ATOM_die_offset = 1u, // DIE offset in the debug_info section.\n  DW_ATOM_cu_offset = 2u, // Offset of the compile unit header that contains the\n                          // item in question.\n  DW_ATOM_die_tag = 3u,   // A tag entry.\n  DW_ATOM_type_flags = 4u, // Set of flags for a type.\n\n  DW_ATOM_type_type_flags = 5u, // Dsymutil type extension.\n  DW_ATOM_qual_name_hash = 6u,  // Dsymutil qualified hash extension.\n\n  // DW_ATOM_type_flags values.\n\n  // Always set for C++, only set for ObjC if this is the @implementation for a\n  // class.\n  DW_FLAG_type_implementation = 2u,\n\n  // Hash functions.\n\n  // Daniel J. Bernstein hash.\n  DW_hash_function_djb = 0u\n};\n\n// Constants for the GNU pubnames/pubtypes extensions supporting gdb index.\nenum GDBIndexEntryKind {\n  GIEK_NONE,\n  GIEK_TYPE,\n  GIEK_VARIABLE,\n  GIEK_FUNCTION,\n  GIEK_OTHER,\n  GIEK_UNUSED5,\n  GIEK_UNUSED6,\n  GIEK_UNUSED7\n};\n\nenum GDBIndexEntryLinkage { GIEL_EXTERNAL, GIEL_STATIC };\n\n/// \\defgroup DwarfConstantsDumping Dwarf constants dumping functions\n///\n/// All these functions map their argument's value back to the\n/// corresponding enumerator name or return an empty StringRef if the value\n/// isn't known.\n///\n/// @{\nStringRef TagString(unsigned Tag);\nStringRef ChildrenString(unsigned Children);\nStringRef AttributeString(unsigned Attribute);\nStringRef FormEncodingString(unsigned Encoding);\nStringRef OperationEncodingString(unsigned Encoding);\nStringRef AttributeEncodingString(unsigned Encoding);\nStringRef DecimalSignString(unsigned Sign);\nStringRef EndianityString(unsigned Endian);\nStringRef AccessibilityString(unsigned Access);\nStringRef DefaultedMemberString(unsigned DefaultedEncodings);\nStringRef VisibilityString(unsigned Visibility);\nStringRef VirtualityString(unsigned Virtuality);\nStringRef LanguageString(unsigned Language);\nStringRef CaseString(unsigned Case);\nStringRef ConventionString(unsigned Convention);\nStringRef InlineCodeString(unsigned Code);\nStringRef ArrayOrderString(unsigned Order);\nStringRef LNStandardString(unsigned Standard);\nStringRef LNExtendedString(unsigned Encoding);\nStringRef MacinfoString(unsigned Encoding);\nStringRef MacroString(unsigned Encoding);\nStringRef GnuMacroString(unsigned Encoding);\nStringRef RangeListEncodingString(unsigned Encoding);\nStringRef LocListEncodingString(unsigned Encoding);\nStringRef CallFrameString(unsigned Encoding, Triple::ArchType Arch);\nStringRef ApplePropertyString(unsigned);\nStringRef UnitTypeString(unsigned);\nStringRef AtomTypeString(unsigned Atom);\nStringRef GDBIndexEntryKindString(GDBIndexEntryKind Kind);\nStringRef GDBIndexEntryLinkageString(GDBIndexEntryLinkage Linkage);\nStringRef IndexString(unsigned Idx);\nStringRef FormatString(DwarfFormat Format);\nStringRef FormatString(bool IsDWARF64);\nStringRef RLEString(unsigned RLE);\n/// @}\n\n/// \\defgroup DwarfConstantsParsing Dwarf constants parsing functions\n///\n/// These functions map their strings back to the corresponding enumeration\n/// value or return 0 if there is none, except for these exceptions:\n///\n/// \\li \\a getTag() returns \\a DW_TAG_invalid on invalid input.\n/// \\li \\a getVirtuality() returns \\a DW_VIRTUALITY_invalid on invalid input.\n/// \\li \\a getMacinfo() returns \\a DW_MACINFO_invalid on invalid input.\n///\n/// @{\nunsigned getTag(StringRef TagString);\nunsigned getOperationEncoding(StringRef OperationEncodingString);\nunsigned getVirtuality(StringRef VirtualityString);\nunsigned getLanguage(StringRef LanguageString);\nunsigned getCallingConvention(StringRef LanguageString);\nunsigned getAttributeEncoding(StringRef EncodingString);\nunsigned getMacinfo(StringRef MacinfoString);\nunsigned getMacro(StringRef MacroString);\n/// @}\n\n/// \\defgroup DwarfConstantsVersioning Dwarf version for constants\n///\n/// For constants defined by DWARF, returns the DWARF version when the constant\n/// was first defined. For vendor extensions, if there is a version-related\n/// policy for when to emit it, returns a version number for that policy.\n/// Otherwise returns 0.\n///\n/// @{\nunsigned TagVersion(Tag T);\nunsigned AttributeVersion(Attribute A);\nunsigned FormVersion(Form F);\nunsigned OperationVersion(LocationAtom O);\nunsigned AttributeEncodingVersion(TypeKind E);\nunsigned LanguageVersion(SourceLanguage L);\n/// @}\n\n/// \\defgroup DwarfConstantsVendor Dwarf \"vendor\" for constants\n///\n/// These functions return an identifier describing \"who\" defined the constant,\n/// either the DWARF standard itself or the vendor who defined the extension.\n///\n/// @{\nunsigned TagVendor(Tag T);\nunsigned AttributeVendor(Attribute A);\nunsigned FormVendor(Form F);\nunsigned OperationVendor(LocationAtom O);\nunsigned AttributeEncodingVendor(TypeKind E);\nunsigned LanguageVendor(SourceLanguage L);\n/// @}\n\nOptional<unsigned> LanguageLowerBound(SourceLanguage L);\n\n/// The size of a reference determined by the DWARF 32/64-bit format.\ninline uint8_t getDwarfOffsetByteSize(DwarfFormat Format) {\n  switch (Format) {\n  case DwarfFormat::DWARF32:\n    return 4;\n  case DwarfFormat::DWARF64:\n    return 8;\n  }\n  llvm_unreachable(\"Invalid Format value\");\n}\n\n/// A helper struct providing information about the byte size of DW_FORM\n/// values that vary in size depending on the DWARF version, address byte\n/// size, or DWARF32/DWARF64.\nstruct FormParams {\n  uint16_t Version;\n  uint8_t AddrSize;\n  DwarfFormat Format;\n\n  /// The definition of the size of form DW_FORM_ref_addr depends on the\n  /// version. In DWARF v2 it's the size of an address; after that, it's the\n  /// size of a reference.\n  uint8_t getRefAddrByteSize() const {\n    if (Version == 2)\n      return AddrSize;\n    return getDwarfOffsetByteSize();\n  }\n\n  /// The size of a reference is determined by the DWARF 32/64-bit format.\n  uint8_t getDwarfOffsetByteSize() const {\n    return dwarf::getDwarfOffsetByteSize(Format);\n  }\n\n  explicit operator bool() const { return Version && AddrSize; }\n};\n\n/// Get the byte size of the unit length field depending on the DWARF format.\ninline uint8_t getUnitLengthFieldByteSize(DwarfFormat Format) {\n  switch (Format) {\n  case DwarfFormat::DWARF32:\n    return 4;\n  case DwarfFormat::DWARF64:\n    return 12;\n  }\n  llvm_unreachable(\"Invalid Format value\");\n}\n\n/// Get the fixed byte size for a given form.\n///\n/// If the form has a fixed byte size, then an Optional with a value will be\n/// returned. If the form is always encoded using a variable length storage\n/// format (ULEB or SLEB numbers or blocks) then None will be returned.\n///\n/// \\param Form DWARF form to get the fixed byte size for.\n/// \\param Params DWARF parameters to help interpret forms.\n/// \\returns Optional<uint8_t> value with the fixed byte size or None if\n/// \\p Form doesn't have a fixed byte size.\nOptional<uint8_t> getFixedFormByteSize(dwarf::Form Form, FormParams Params);\n\n/// Tells whether the specified form is defined in the specified version,\n/// or is an extension if extensions are allowed.\nbool isValidFormForVersion(Form F, unsigned Version, bool ExtensionsOk = true);\n\n/// Returns the symbolic string representing Val when used as a value\n/// for attribute Attr.\nStringRef AttributeValueString(uint16_t Attr, unsigned Val);\n\n/// Returns the symbolic string representing Val when used as a value\n/// for atom Atom.\nStringRef AtomValueString(uint16_t Atom, unsigned Val);\n\n/// Describes an entry of the various gnu_pub* debug sections.\n///\n/// The gnu_pub* kind looks like:\n///\n/// 0-3  reserved\n/// 4-6  symbol kind\n/// 7    0 == global, 1 == static\n///\n/// A gdb_index descriptor includes the above kind, shifted 24 bits up with the\n/// offset of the cu within the debug_info section stored in those 24 bits.\nstruct PubIndexEntryDescriptor {\n  GDBIndexEntryKind Kind;\n  GDBIndexEntryLinkage Linkage;\n  PubIndexEntryDescriptor(GDBIndexEntryKind Kind, GDBIndexEntryLinkage Linkage)\n      : Kind(Kind), Linkage(Linkage) {}\n  /* implicit */ PubIndexEntryDescriptor(GDBIndexEntryKind Kind)\n      : Kind(Kind), Linkage(GIEL_EXTERNAL) {}\n  explicit PubIndexEntryDescriptor(uint8_t Value)\n      : Kind(\n            static_cast<GDBIndexEntryKind>((Value & KIND_MASK) >> KIND_OFFSET)),\n        Linkage(static_cast<GDBIndexEntryLinkage>((Value & LINKAGE_MASK) >>\n                                                  LINKAGE_OFFSET)) {}\n  uint8_t toBits() const {\n    return Kind << KIND_OFFSET | Linkage << LINKAGE_OFFSET;\n  }\n\nprivate:\n  enum {\n    KIND_OFFSET = 4,\n    KIND_MASK = 7 << KIND_OFFSET,\n    LINKAGE_OFFSET = 7,\n    LINKAGE_MASK = 1 << LINKAGE_OFFSET\n  };\n};\n\ntemplate <typename Enum> struct EnumTraits : public std::false_type {};\n\ntemplate <> struct EnumTraits<Attribute> : public std::true_type {\n  static constexpr char Type[3] = \"AT\";\n  static constexpr StringRef (*StringFn)(unsigned) = &AttributeString;\n};\n\ntemplate <> struct EnumTraits<Form> : public std::true_type {\n  static constexpr char Type[5] = \"FORM\";\n  static constexpr StringRef (*StringFn)(unsigned) = &FormEncodingString;\n};\n\ntemplate <> struct EnumTraits<Index> : public std::true_type {\n  static constexpr char Type[4] = \"IDX\";\n  static constexpr StringRef (*StringFn)(unsigned) = &IndexString;\n};\n\ntemplate <> struct EnumTraits<Tag> : public std::true_type {\n  static constexpr char Type[4] = \"TAG\";\n  static constexpr StringRef (*StringFn)(unsigned) = &TagString;\n};\n\ntemplate <> struct EnumTraits<LineNumberOps> : public std::true_type {\n  static constexpr char Type[4] = \"LNS\";\n  static constexpr StringRef (*StringFn)(unsigned) = &LNStandardString;\n};\n\ntemplate <> struct EnumTraits<LocationAtom> : public std::true_type {\n  static constexpr char Type[3] = \"OP\";\n  static constexpr StringRef (*StringFn)(unsigned) = &OperationEncodingString;\n};\n\ninline uint64_t computeTombstoneAddress(uint8_t AddressByteSize) {\n  return std::numeric_limits<uint64_t>::max() >> (8 - AddressByteSize) * 8;\n}\n\n} // End of namespace dwarf\n\n/// Dwarf constants format_provider\n///\n/// Specialization of the format_provider template for dwarf enums. Unlike the\n/// dumping functions above, these format unknown enumerator values as\n/// DW_TYPE_unknown_1234 (e.g. DW_TAG_unknown_ffff).\ntemplate <typename Enum>\nstruct format_provider<Enum, std::enable_if_t<dwarf::EnumTraits<Enum>::value>> {\n  static void format(const Enum &E, raw_ostream &OS, StringRef Style) {\n    StringRef Str = dwarf::EnumTraits<Enum>::StringFn(E);\n    if (Str.empty()) {\n      OS << \"DW_\" << dwarf::EnumTraits<Enum>::Type << \"_unknown_\"\n         << llvm::format(\"%x\", E);\n    } else\n      OS << Str;\n  }\n};\n} // End of namespace llvm\n\n#endif\n"}, "15": {"id": 15, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/BinaryFormat/MachO.h", "content": "//===-- llvm/BinaryFormat/MachO.h - The MachO file format -------*- C++/-*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// This file defines manifest constants for the MachO object file format.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_BINARYFORMAT_MACHO_H\n#define LLVM_BINARYFORMAT_MACHO_H\n\n#include \"llvm/Support/Compiler.h\"\n#include \"llvm/Support/DataTypes.h\"\n#include \"llvm/Support/Error.h\"\n#include \"llvm/Support/SwapByteOrder.h\"\n\nnamespace llvm {\n\nclass Triple;\n\nnamespace MachO {\n// Enums from <mach-o/loader.h>\nenum : uint32_t {\n  // Constants for the \"magic\" field in llvm::MachO::mach_header and\n  // llvm::MachO::mach_header_64\n  MH_MAGIC = 0xFEEDFACEu,\n  MH_CIGAM = 0xCEFAEDFEu,\n  MH_MAGIC_64 = 0xFEEDFACFu,\n  MH_CIGAM_64 = 0xCFFAEDFEu,\n  FAT_MAGIC = 0xCAFEBABEu,\n  FAT_CIGAM = 0xBEBAFECAu,\n  FAT_MAGIC_64 = 0xCAFEBABFu,\n  FAT_CIGAM_64 = 0xBFBAFECAu\n};\n\nenum HeaderFileType {\n  // Constants for the \"filetype\" field in llvm::MachO::mach_header and\n  // llvm::MachO::mach_header_64\n  MH_OBJECT = 0x1u,\n  MH_EXECUTE = 0x2u,\n  MH_FVMLIB = 0x3u,\n  MH_CORE = 0x4u,\n  MH_PRELOAD = 0x5u,\n  MH_DYLIB = 0x6u,\n  MH_DYLINKER = 0x7u,\n  MH_BUNDLE = 0x8u,\n  MH_DYLIB_STUB = 0x9u,\n  MH_DSYM = 0xAu,\n  MH_KEXT_BUNDLE = 0xBu\n};\n\nenum {\n  // Constant bits for the \"flags\" field in llvm::MachO::mach_header and\n  // llvm::MachO::mach_header_64\n  MH_NOUNDEFS = 0x00000001u,\n  MH_INCRLINK = 0x00000002u,\n  MH_DYLDLINK = 0x00000004u,\n  MH_BINDATLOAD = 0x00000008u,\n  MH_PREBOUND = 0x00000010u,\n  MH_SPLIT_SEGS = 0x00000020u,\n  MH_LAZY_INIT = 0x00000040u,\n  MH_TWOLEVEL = 0x00000080u,\n  MH_FORCE_FLAT = 0x00000100u,\n  MH_NOMULTIDEFS = 0x00000200u,\n  MH_NOFIXPREBINDING = 0x00000400u,\n  MH_PREBINDABLE = 0x00000800u,\n  MH_ALLMODSBOUND = 0x00001000u,\n  MH_SUBSECTIONS_VIA_SYMBOLS = 0x00002000u,\n  MH_CANONICAL = 0x00004000u,\n  MH_WEAK_DEFINES = 0x00008000u,\n  MH_BINDS_TO_WEAK = 0x00010000u,\n  MH_ALLOW_STACK_EXECUTION = 0x00020000u,\n  MH_ROOT_SAFE = 0x00040000u,\n  MH_SETUID_SAFE = 0x00080000u,\n  MH_NO_REEXPORTED_DYLIBS = 0x00100000u,\n  MH_PIE = 0x00200000u,\n  MH_DEAD_STRIPPABLE_DYLIB = 0x00400000u,\n  MH_HAS_TLV_DESCRIPTORS = 0x00800000u,\n  MH_NO_HEAP_EXECUTION = 0x01000000u,\n  MH_APP_EXTENSION_SAFE = 0x02000000u,\n  MH_NLIST_OUTOFSYNC_WITH_DYLDINFO = 0x04000000u,\n  MH_SIM_SUPPORT = 0x08000000u,\n  MH_DYLIB_IN_CACHE = 0x80000000u,\n};\n\nenum : uint32_t {\n  // Flags for the \"cmd\" field in llvm::MachO::load_command\n  LC_REQ_DYLD = 0x80000000u\n};\n\n#define HANDLE_LOAD_COMMAND(LCName, LCValue, LCStruct) LCName = LCValue,\n\nenum LoadCommandType : uint32_t {\n#include \"llvm/BinaryFormat/MachO.def\"\n};\n\n#undef HANDLE_LOAD_COMMAND\n\nenum : uint32_t {\n  // Constant bits for the \"flags\" field in llvm::MachO::segment_command\n  SG_HIGHVM = 0x1u,\n  SG_FVMLIB = 0x2u,\n  SG_NORELOC = 0x4u,\n  SG_PROTECTED_VERSION_1 = 0x8u,\n\n  // Constant masks for the \"flags\" field in llvm::MachO::section and\n  // llvm::MachO::section_64\n  SECTION_TYPE = 0x000000ffu,           // SECTION_TYPE\n  SECTION_ATTRIBUTES = 0xffffff00u,     // SECTION_ATTRIBUTES\n  SECTION_ATTRIBUTES_USR = 0xff000000u, // SECTION_ATTRIBUTES_USR\n  SECTION_ATTRIBUTES_SYS = 0x00ffff00u  // SECTION_ATTRIBUTES_SYS\n};\n\n/// These are the section type and attributes fields.  A MachO section can\n/// have only one Type, but can have any of the attributes specified.\nenum SectionType : uint32_t {\n  // Constant masks for the \"flags[7:0]\" field in llvm::MachO::section and\n  // llvm::MachO::section_64 (mask \"flags\" with SECTION_TYPE)\n\n  /// S_REGULAR - Regular section.\n  S_REGULAR = 0x00u,\n  /// S_ZEROFILL - Zero fill on demand section.\n  S_ZEROFILL = 0x01u,\n  /// S_CSTRING_LITERALS - Section with literal C strings.\n  S_CSTRING_LITERALS = 0x02u,\n  /// S_4BYTE_LITERALS - Section with 4 byte literals.\n  S_4BYTE_LITERALS = 0x03u,\n  /// S_8BYTE_LITERALS - Section with 8 byte literals.\n  S_8BYTE_LITERALS = 0x04u,\n  /// S_LITERAL_POINTERS - Section with pointers to literals.\n  S_LITERAL_POINTERS = 0x05u,\n  /// S_NON_LAZY_SYMBOL_POINTERS - Section with non-lazy symbol pointers.\n  S_NON_LAZY_SYMBOL_POINTERS = 0x06u,\n  /// S_LAZY_SYMBOL_POINTERS - Section with lazy symbol pointers.\n  S_LAZY_SYMBOL_POINTERS = 0x07u,\n  /// S_SYMBOL_STUBS - Section with symbol stubs, byte size of stub in\n  /// the Reserved2 field.\n  S_SYMBOL_STUBS = 0x08u,\n  /// S_MOD_INIT_FUNC_POINTERS - Section with only function pointers for\n  /// initialization.\n  S_MOD_INIT_FUNC_POINTERS = 0x09u,\n  /// S_MOD_TERM_FUNC_POINTERS - Section with only function pointers for\n  /// termination.\n  S_MOD_TERM_FUNC_POINTERS = 0x0au,\n  /// S_COALESCED - Section contains symbols that are to be coalesced.\n  S_COALESCED = 0x0bu,\n  /// S_GB_ZEROFILL - Zero fill on demand section (that can be larger than 4\n  /// gigabytes).\n  S_GB_ZEROFILL = 0x0cu,\n  /// S_INTERPOSING - Section with only pairs of function pointers for\n  /// interposing.\n  S_INTERPOSING = 0x0du,\n  /// S_16BYTE_LITERALS - Section with only 16 byte literals.\n  S_16BYTE_LITERALS = 0x0eu,\n  /// S_DTRACE_DOF - Section contains DTrace Object Format.\n  S_DTRACE_DOF = 0x0fu,\n  /// S_LAZY_DYLIB_SYMBOL_POINTERS - Section with lazy symbol pointers to\n  /// lazy loaded dylibs.\n  S_LAZY_DYLIB_SYMBOL_POINTERS = 0x10u,\n  /// S_THREAD_LOCAL_REGULAR - Thread local data section.\n  S_THREAD_LOCAL_REGULAR = 0x11u,\n  /// S_THREAD_LOCAL_ZEROFILL - Thread local zerofill section.\n  S_THREAD_LOCAL_ZEROFILL = 0x12u,\n  /// S_THREAD_LOCAL_VARIABLES - Section with thread local variable\n  /// structure data.\n  S_THREAD_LOCAL_VARIABLES = 0x13u,\n  /// S_THREAD_LOCAL_VARIABLE_POINTERS - Section with pointers to thread\n  /// local structures.\n  S_THREAD_LOCAL_VARIABLE_POINTERS = 0x14u,\n  /// S_THREAD_LOCAL_INIT_FUNCTION_POINTERS - Section with thread local\n  /// variable initialization pointers to functions.\n  S_THREAD_LOCAL_INIT_FUNCTION_POINTERS = 0x15u,\n\n  LAST_KNOWN_SECTION_TYPE = S_THREAD_LOCAL_INIT_FUNCTION_POINTERS\n};\n\nenum : uint32_t {\n  // Constant masks for the \"flags[31:24]\" field in llvm::MachO::section and\n  // llvm::MachO::section_64 (mask \"flags\" with SECTION_ATTRIBUTES_USR)\n\n  /// S_ATTR_PURE_INSTRUCTIONS - Section contains only true machine\n  /// instructions.\n  S_ATTR_PURE_INSTRUCTIONS = 0x80000000u,\n  /// S_ATTR_NO_TOC - Section contains coalesced symbols that are not to be\n  /// in a ranlib table of contents.\n  S_ATTR_NO_TOC = 0x40000000u,\n  /// S_ATTR_STRIP_STATIC_SYMS - Ok to strip static symbols in this section\n  /// in files with the MY_DYLDLINK flag.\n  S_ATTR_STRIP_STATIC_SYMS = 0x20000000u,\n  /// S_ATTR_NO_DEAD_STRIP - No dead stripping.\n  S_ATTR_NO_DEAD_STRIP = 0x10000000u,\n  /// S_ATTR_LIVE_SUPPORT - Blocks are live if they reference live blocks.\n  S_ATTR_LIVE_SUPPORT = 0x08000000u,\n  /// S_ATTR_SELF_MODIFYING_CODE - Used with i386 code stubs written on by\n  /// dyld.\n  S_ATTR_SELF_MODIFYING_CODE = 0x04000000u,\n  /// S_ATTR_DEBUG - A debug section.\n  S_ATTR_DEBUG = 0x02000000u,\n\n  // Constant masks for the \"flags[23:8]\" field in llvm::MachO::section and\n  // llvm::MachO::section_64 (mask \"flags\" with SECTION_ATTRIBUTES_SYS)\n\n  /// S_ATTR_SOME_INSTRUCTIONS - Section contains some machine instructions.\n  S_ATTR_SOME_INSTRUCTIONS = 0x00000400u,\n  /// S_ATTR_EXT_RELOC - Section has external relocation entries.\n  S_ATTR_EXT_RELOC = 0x00000200u,\n  /// S_ATTR_LOC_RELOC - Section has local relocation entries.\n  S_ATTR_LOC_RELOC = 0x00000100u,\n\n  // Constant masks for the value of an indirect symbol in an indirect\n  // symbol table\n  INDIRECT_SYMBOL_LOCAL = 0x80000000u,\n  INDIRECT_SYMBOL_ABS = 0x40000000u\n};\n\nenum DataRegionType {\n  // Constants for the \"kind\" field in a data_in_code_entry structure\n  DICE_KIND_DATA = 1u,\n  DICE_KIND_JUMP_TABLE8 = 2u,\n  DICE_KIND_JUMP_TABLE16 = 3u,\n  DICE_KIND_JUMP_TABLE32 = 4u,\n  DICE_KIND_ABS_JUMP_TABLE32 = 5u\n};\n\nenum RebaseType {\n  REBASE_TYPE_POINTER = 1u,\n  REBASE_TYPE_TEXT_ABSOLUTE32 = 2u,\n  REBASE_TYPE_TEXT_PCREL32 = 3u\n};\n\nenum { REBASE_OPCODE_MASK = 0xF0u, REBASE_IMMEDIATE_MASK = 0x0Fu };\n\nenum RebaseOpcode {\n  REBASE_OPCODE_DONE = 0x00u,\n  REBASE_OPCODE_SET_TYPE_IMM = 0x10u,\n  REBASE_OPCODE_SET_SEGMENT_AND_OFFSET_ULEB = 0x20u,\n  REBASE_OPCODE_ADD_ADDR_ULEB = 0x30u,\n  REBASE_OPCODE_ADD_ADDR_IMM_SCALED = 0x40u,\n  REBASE_OPCODE_DO_REBASE_IMM_TIMES = 0x50u,\n  REBASE_OPCODE_DO_REBASE_ULEB_TIMES = 0x60u,\n  REBASE_OPCODE_DO_REBASE_ADD_ADDR_ULEB = 0x70u,\n  REBASE_OPCODE_DO_REBASE_ULEB_TIMES_SKIPPING_ULEB = 0x80u\n};\n\nenum BindType {\n  BIND_TYPE_POINTER = 1u,\n  BIND_TYPE_TEXT_ABSOLUTE32 = 2u,\n  BIND_TYPE_TEXT_PCREL32 = 3u\n};\n\nenum BindSpecialDylib {\n  BIND_SPECIAL_DYLIB_SELF = 0,\n  BIND_SPECIAL_DYLIB_MAIN_EXECUTABLE = -1,\n  BIND_SPECIAL_DYLIB_FLAT_LOOKUP = -2\n};\n\nenum {\n  BIND_SYMBOL_FLAGS_WEAK_IMPORT = 0x1u,\n  BIND_SYMBOL_FLAGS_NON_WEAK_DEFINITION = 0x8u,\n\n  BIND_OPCODE_MASK = 0xF0u,\n  BIND_IMMEDIATE_MASK = 0x0Fu\n};\n\nenum BindOpcode {\n  BIND_OPCODE_DONE = 0x00u,\n  BIND_OPCODE_SET_DYLIB_ORDINAL_IMM = 0x10u,\n  BIND_OPCODE_SET_DYLIB_ORDINAL_ULEB = 0x20u,\n  BIND_OPCODE_SET_DYLIB_SPECIAL_IMM = 0x30u,\n  BIND_OPCODE_SET_SYMBOL_TRAILING_FLAGS_IMM = 0x40u,\n  BIND_OPCODE_SET_TYPE_IMM = 0x50u,\n  BIND_OPCODE_SET_ADDEND_SLEB = 0x60u,\n  BIND_OPCODE_SET_SEGMENT_AND_OFFSET_ULEB = 0x70u,\n  BIND_OPCODE_ADD_ADDR_ULEB = 0x80u,\n  BIND_OPCODE_DO_BIND = 0x90u,\n  BIND_OPCODE_DO_BIND_ADD_ADDR_ULEB = 0xA0u,\n  BIND_OPCODE_DO_BIND_ADD_ADDR_IMM_SCALED = 0xB0u,\n  BIND_OPCODE_DO_BIND_ULEB_TIMES_SKIPPING_ULEB = 0xC0u\n};\n\nenum {\n  EXPORT_SYMBOL_FLAGS_KIND_MASK = 0x03u,\n  EXPORT_SYMBOL_FLAGS_WEAK_DEFINITION = 0x04u,\n  EXPORT_SYMBOL_FLAGS_REEXPORT = 0x08u,\n  EXPORT_SYMBOL_FLAGS_STUB_AND_RESOLVER = 0x10u\n};\n\nenum ExportSymbolKind {\n  EXPORT_SYMBOL_FLAGS_KIND_REGULAR = 0x00u,\n  EXPORT_SYMBOL_FLAGS_KIND_THREAD_LOCAL = 0x01u,\n  EXPORT_SYMBOL_FLAGS_KIND_ABSOLUTE = 0x02u\n};\n\nenum {\n  // Constant masks for the \"n_type\" field in llvm::MachO::nlist and\n  // llvm::MachO::nlist_64\n  N_STAB = 0xe0,\n  N_PEXT = 0x10,\n  N_TYPE = 0x0e,\n  N_EXT = 0x01\n};\n\nenum NListType : uint8_t {\n  // Constants for the \"n_type & N_TYPE\" llvm::MachO::nlist and\n  // llvm::MachO::nlist_64\n  N_UNDF = 0x0u,\n  N_ABS = 0x2u,\n  N_SECT = 0xeu,\n  N_PBUD = 0xcu,\n  N_INDR = 0xau\n};\n\nenum SectionOrdinal {\n  // Constants for the \"n_sect\" field in llvm::MachO::nlist and\n  // llvm::MachO::nlist_64\n  NO_SECT = 0u,\n  MAX_SECT = 0xffu\n};\n\nenum {\n  // Constant masks for the \"n_desc\" field in llvm::MachO::nlist and\n  // llvm::MachO::nlist_64\n  // The low 3 bits are the for the REFERENCE_TYPE.\n  REFERENCE_TYPE = 0x7,\n  REFERENCE_FLAG_UNDEFINED_NON_LAZY = 0,\n  REFERENCE_FLAG_UNDEFINED_LAZY = 1,\n  REFERENCE_FLAG_DEFINED = 2,\n  REFERENCE_FLAG_PRIVATE_DEFINED = 3,\n  REFERENCE_FLAG_PRIVATE_UNDEFINED_NON_LAZY = 4,\n  REFERENCE_FLAG_PRIVATE_UNDEFINED_LAZY = 5,\n  // Flag bits (some overlap with the library ordinal bits).\n  N_ARM_THUMB_DEF = 0x0008u,\n  REFERENCED_DYNAMICALLY = 0x0010u,\n  N_NO_DEAD_STRIP = 0x0020u,\n  N_WEAK_REF = 0x0040u,\n  N_WEAK_DEF = 0x0080u,\n  N_SYMBOL_RESOLVER = 0x0100u,\n  N_ALT_ENTRY = 0x0200u,\n  N_COLD_FUNC = 0x0400u,\n  // For undefined symbols coming from libraries, see GET_LIBRARY_ORDINAL()\n  // as these are in the top 8 bits.\n  SELF_LIBRARY_ORDINAL = 0x0,\n  MAX_LIBRARY_ORDINAL = 0xfd,\n  DYNAMIC_LOOKUP_ORDINAL = 0xfe,\n  EXECUTABLE_ORDINAL = 0xff\n};\n\nenum StabType {\n  // Constant values for the \"n_type\" field in llvm::MachO::nlist and\n  // llvm::MachO::nlist_64 when \"(n_type & N_STAB) != 0\"\n  N_GSYM = 0x20u,\n  N_FNAME = 0x22u,\n  N_FUN = 0x24u,\n  N_STSYM = 0x26u,\n  N_LCSYM = 0x28u,\n  N_BNSYM = 0x2Eu,\n  N_PC = 0x30u,\n  N_AST = 0x32u,\n  N_OPT = 0x3Cu,\n  N_RSYM = 0x40u,\n  N_SLINE = 0x44u,\n  N_ENSYM = 0x4Eu,\n  N_SSYM = 0x60u,\n  N_SO = 0x64u,\n  N_OSO = 0x66u,\n  N_LSYM = 0x80u,\n  N_BINCL = 0x82u,\n  N_SOL = 0x84u,\n  N_PARAMS = 0x86u,\n  N_VERSION = 0x88u,\n  N_OLEVEL = 0x8Au,\n  N_PSYM = 0xA0u,\n  N_EINCL = 0xA2u,\n  N_ENTRY = 0xA4u,\n  N_LBRAC = 0xC0u,\n  N_EXCL = 0xC2u,\n  N_RBRAC = 0xE0u,\n  N_BCOMM = 0xE2u,\n  N_ECOMM = 0xE4u,\n  N_ECOML = 0xE8u,\n  N_LENG = 0xFEu\n};\n\nenum : uint32_t {\n  // Constant values for the r_symbolnum field in an\n  // llvm::MachO::relocation_info structure when r_extern is 0.\n  R_ABS = 0,\n\n  // Constant bits for the r_address field in an\n  // llvm::MachO::relocation_info structure.\n  R_SCATTERED = 0x80000000\n};\n\nenum RelocationInfoType {\n  // Constant values for the r_type field in an\n  // llvm::MachO::relocation_info or llvm::MachO::scattered_relocation_info\n  // structure.\n  GENERIC_RELOC_INVALID = 0xff,\n  GENERIC_RELOC_VANILLA = 0,\n  GENERIC_RELOC_PAIR = 1,\n  GENERIC_RELOC_SECTDIFF = 2,\n  GENERIC_RELOC_PB_LA_PTR = 3,\n  GENERIC_RELOC_LOCAL_SECTDIFF = 4,\n  GENERIC_RELOC_TLV = 5,\n\n  // Constant values for the r_type field in a PowerPC architecture\n  // llvm::MachO::relocation_info or llvm::MachO::scattered_relocation_info\n  // structure.\n  PPC_RELOC_VANILLA = GENERIC_RELOC_VANILLA,\n  PPC_RELOC_PAIR = GENERIC_RELOC_PAIR,\n  PPC_RELOC_BR14 = 2,\n  PPC_RELOC_BR24 = 3,\n  PPC_RELOC_HI16 = 4,\n  PPC_RELOC_LO16 = 5,\n  PPC_RELOC_HA16 = 6,\n  PPC_RELOC_LO14 = 7,\n  PPC_RELOC_SECTDIFF = 8,\n  PPC_RELOC_PB_LA_PTR = 9,\n  PPC_RELOC_HI16_SECTDIFF = 10,\n  PPC_RELOC_LO16_SECTDIFF = 11,\n  PPC_RELOC_HA16_SECTDIFF = 12,\n  PPC_RELOC_JBSR = 13,\n  PPC_RELOC_LO14_SECTDIFF = 14,\n  PPC_RELOC_LOCAL_SECTDIFF = 15,\n\n  // Constant values for the r_type field in an ARM architecture\n  // llvm::MachO::relocation_info or llvm::MachO::scattered_relocation_info\n  // structure.\n  ARM_RELOC_VANILLA = GENERIC_RELOC_VANILLA,\n  ARM_RELOC_PAIR = GENERIC_RELOC_PAIR,\n  ARM_RELOC_SECTDIFF = GENERIC_RELOC_SECTDIFF,\n  ARM_RELOC_LOCAL_SECTDIFF = 3,\n  ARM_RELOC_PB_LA_PTR = 4,\n  ARM_RELOC_BR24 = 5,\n  ARM_THUMB_RELOC_BR22 = 6,\n  ARM_THUMB_32BIT_BRANCH = 7, // obsolete\n  ARM_RELOC_HALF = 8,\n  ARM_RELOC_HALF_SECTDIFF = 9,\n\n  // Constant values for the r_type field in an ARM64 architecture\n  // llvm::MachO::relocation_info or llvm::MachO::scattered_relocation_info\n  // structure.\n\n  // For pointers.\n  ARM64_RELOC_UNSIGNED = 0,\n  // Must be followed by an ARM64_RELOC_UNSIGNED\n  ARM64_RELOC_SUBTRACTOR = 1,\n  // A B/BL instruction with 26-bit displacement.\n  ARM64_RELOC_BRANCH26 = 2,\n  // PC-rel distance to page of target.\n  ARM64_RELOC_PAGE21 = 3,\n  // Offset within page, scaled by r_length.\n  ARM64_RELOC_PAGEOFF12 = 4,\n  // PC-rel distance to page of GOT slot.\n  ARM64_RELOC_GOT_LOAD_PAGE21 = 5,\n  // Offset within page of GOT slot, scaled by r_length.\n  ARM64_RELOC_GOT_LOAD_PAGEOFF12 = 6,\n  // For pointers to GOT slots.\n  ARM64_RELOC_POINTER_TO_GOT = 7,\n  // PC-rel distance to page of TLVP slot.\n  ARM64_RELOC_TLVP_LOAD_PAGE21 = 8,\n  // Offset within page of TLVP slot, scaled by r_length.\n  ARM64_RELOC_TLVP_LOAD_PAGEOFF12 = 9,\n  // Must be followed by ARM64_RELOC_PAGE21 or ARM64_RELOC_PAGEOFF12.\n  ARM64_RELOC_ADDEND = 10,\n\n  // Constant values for the r_type field in an x86_64 architecture\n  // llvm::MachO::relocation_info or llvm::MachO::scattered_relocation_info\n  // structure\n  X86_64_RELOC_UNSIGNED = 0,\n  X86_64_RELOC_SIGNED = 1,\n  X86_64_RELOC_BRANCH = 2,\n  X86_64_RELOC_GOT_LOAD = 3,\n  X86_64_RELOC_GOT = 4,\n  X86_64_RELOC_SUBTRACTOR = 5,\n  X86_64_RELOC_SIGNED_1 = 6,\n  X86_64_RELOC_SIGNED_2 = 7,\n  X86_64_RELOC_SIGNED_4 = 8,\n  X86_64_RELOC_TLV = 9\n};\n\n// Values for segment_command.initprot.\n// From <mach/vm_prot.h>\nenum { VM_PROT_READ = 0x1, VM_PROT_WRITE = 0x2, VM_PROT_EXECUTE = 0x4 };\n\n// Values for platform field in build_version_command.\nenum PlatformType {\n  PLATFORM_MACOS = 1,\n  PLATFORM_IOS = 2,\n  PLATFORM_TVOS = 3,\n  PLATFORM_WATCHOS = 4,\n  PLATFORM_BRIDGEOS = 5,\n  PLATFORM_MACCATALYST = 6,\n  PLATFORM_IOSSIMULATOR = 7,\n  PLATFORM_TVOSSIMULATOR = 8,\n  PLATFORM_WATCHOSSIMULATOR = 9,\n  PLATFORM_DRIVERKIT = 10,\n};\n\n// Values for tools enum in build_tool_version.\nenum { TOOL_CLANG = 1, TOOL_SWIFT = 2, TOOL_LD = 3 };\n\n// Structs from <mach-o/loader.h>\n\nstruct mach_header {\n  uint32_t magic;\n  uint32_t cputype;\n  uint32_t cpusubtype;\n  uint32_t filetype;\n  uint32_t ncmds;\n  uint32_t sizeofcmds;\n  uint32_t flags;\n};\n\nstruct mach_header_64 {\n  uint32_t magic;\n  uint32_t cputype;\n  uint32_t cpusubtype;\n  uint32_t filetype;\n  uint32_t ncmds;\n  uint32_t sizeofcmds;\n  uint32_t flags;\n  uint32_t reserved;\n};\n\nstruct load_command {\n  uint32_t cmd;\n  uint32_t cmdsize;\n};\n\nstruct segment_command {\n  uint32_t cmd;\n  uint32_t cmdsize;\n  char segname[16];\n  uint32_t vmaddr;\n  uint32_t vmsize;\n  uint32_t fileoff;\n  uint32_t filesize;\n  uint32_t maxprot;\n  uint32_t initprot;\n  uint32_t nsects;\n  uint32_t flags;\n};\n\nstruct segment_command_64 {\n  uint32_t cmd;\n  uint32_t cmdsize;\n  char segname[16];\n  uint64_t vmaddr;\n  uint64_t vmsize;\n  uint64_t fileoff;\n  uint64_t filesize;\n  uint32_t maxprot;\n  uint32_t initprot;\n  uint32_t nsects;\n  uint32_t flags;\n};\n\nstruct section {\n  char sectname[16];\n  char segname[16];\n  uint32_t addr;\n  uint32_t size;\n  uint32_t offset;\n  uint32_t align;\n  uint32_t reloff;\n  uint32_t nreloc;\n  uint32_t flags;\n  uint32_t reserved1;\n  uint32_t reserved2;\n};\n\nstruct section_64 {\n  char sectname[16];\n  char segname[16];\n  uint64_t addr;\n  uint64_t size;\n  uint32_t offset;\n  uint32_t align;\n  uint32_t reloff;\n  uint32_t nreloc;\n  uint32_t flags;\n  uint32_t reserved1;\n  uint32_t reserved2;\n  uint32_t reserved3;\n};\n\ninline bool isVirtualSection(uint8_t type) {\n  return (type == MachO::S_ZEROFILL || type == MachO::S_GB_ZEROFILL ||\n          type == MachO::S_THREAD_LOCAL_ZEROFILL);\n}\n\nstruct fvmlib {\n  uint32_t name;\n  uint32_t minor_version;\n  uint32_t header_addr;\n};\n\n// The fvmlib_command is obsolete and no longer supported.\nstruct fvmlib_command {\n  uint32_t cmd;\n  uint32_t cmdsize;\n  struct fvmlib fvmlib;\n};\n\nstruct dylib {\n  uint32_t name;\n  uint32_t timestamp;\n  uint32_t current_version;\n  uint32_t compatibility_version;\n};\n\nstruct dylib_command {\n  uint32_t cmd;\n  uint32_t cmdsize;\n  struct dylib dylib;\n};\n\nstruct sub_framework_command {\n  uint32_t cmd;\n  uint32_t cmdsize;\n  uint32_t umbrella;\n};\n\nstruct sub_client_command {\n  uint32_t cmd;\n  uint32_t cmdsize;\n  uint32_t client;\n};\n\nstruct sub_umbrella_command {\n  uint32_t cmd;\n  uint32_t cmdsize;\n  uint32_t sub_umbrella;\n};\n\nstruct sub_library_command {\n  uint32_t cmd;\n  uint32_t cmdsize;\n  uint32_t sub_library;\n};\n\n// The prebound_dylib_command is obsolete and no longer supported.\nstruct prebound_dylib_command {\n  uint32_t cmd;\n  uint32_t cmdsize;\n  uint32_t name;\n  uint32_t nmodules;\n  uint32_t linked_modules;\n};\n\nstruct dylinker_command {\n  uint32_t cmd;\n  uint32_t cmdsize;\n  uint32_t name;\n};\n\nstruct thread_command {\n  uint32_t cmd;\n  uint32_t cmdsize;\n};\n\nstruct routines_command {\n  uint32_t cmd;\n  uint32_t cmdsize;\n  uint32_t init_address;\n  uint32_t init_module;\n  uint32_t reserved1;\n  uint32_t reserved2;\n  uint32_t reserved3;\n  uint32_t reserved4;\n  uint32_t reserved5;\n  uint32_t reserved6;\n};\n\nstruct routines_command_64 {\n  uint32_t cmd;\n  uint32_t cmdsize;\n  uint64_t init_address;\n  uint64_t init_module;\n  uint64_t reserved1;\n  uint64_t reserved2;\n  uint64_t reserved3;\n  uint64_t reserved4;\n  uint64_t reserved5;\n  uint64_t reserved6;\n};\n\nstruct symtab_command {\n  uint32_t cmd;\n  uint32_t cmdsize;\n  uint32_t symoff;\n  uint32_t nsyms;\n  uint32_t stroff;\n  uint32_t strsize;\n};\n\nstruct dysymtab_command {\n  uint32_t cmd;\n  uint32_t cmdsize;\n  uint32_t ilocalsym;\n  uint32_t nlocalsym;\n  uint32_t iextdefsym;\n  uint32_t nextdefsym;\n  uint32_t iundefsym;\n  uint32_t nundefsym;\n  uint32_t tocoff;\n  uint32_t ntoc;\n  uint32_t modtaboff;\n  uint32_t nmodtab;\n  uint32_t extrefsymoff;\n  uint32_t nextrefsyms;\n  uint32_t indirectsymoff;\n  uint32_t nindirectsyms;\n  uint32_t extreloff;\n  uint32_t nextrel;\n  uint32_t locreloff;\n  uint32_t nlocrel;\n};\n\nstruct dylib_table_of_contents {\n  uint32_t symbol_index;\n  uint32_t module_index;\n};\n\nstruct dylib_module {\n  uint32_t module_name;\n  uint32_t iextdefsym;\n  uint32_t nextdefsym;\n  uint32_t irefsym;\n  uint32_t nrefsym;\n  uint32_t ilocalsym;\n  uint32_t nlocalsym;\n  uint32_t iextrel;\n  uint32_t nextrel;\n  uint32_t iinit_iterm;\n  uint32_t ninit_nterm;\n  uint32_t objc_module_info_addr;\n  uint32_t objc_module_info_size;\n};\n\nstruct dylib_module_64 {\n  uint32_t module_name;\n  uint32_t iextdefsym;\n  uint32_t nextdefsym;\n  uint32_t irefsym;\n  uint32_t nrefsym;\n  uint32_t ilocalsym;\n  uint32_t nlocalsym;\n  uint32_t iextrel;\n  uint32_t nextrel;\n  uint32_t iinit_iterm;\n  uint32_t ninit_nterm;\n  uint32_t objc_module_info_size;\n  uint64_t objc_module_info_addr;\n};\n\nstruct dylib_reference {\n  uint32_t isym : 24, flags : 8;\n};\n\n// The twolevel_hints_command is obsolete and no longer supported.\nstruct twolevel_hints_command {\n  uint32_t cmd;\n  uint32_t cmdsize;\n  uint32_t offset;\n  uint32_t nhints;\n};\n\n// The twolevel_hints_command is obsolete and no longer supported.\nstruct twolevel_hint {\n  uint32_t isub_image : 8, itoc : 24;\n};\n\n// The prebind_cksum_command is obsolete and no longer supported.\nstruct prebind_cksum_command {\n  uint32_t cmd;\n  uint32_t cmdsize;\n  uint32_t cksum;\n};\n\nstruct uuid_command {\n  uint32_t cmd;\n  uint32_t cmdsize;\n  uint8_t uuid[16];\n};\n\nstruct rpath_command {\n  uint32_t cmd;\n  uint32_t cmdsize;\n  uint32_t path;\n};\n\nstruct linkedit_data_command {\n  uint32_t cmd;\n  uint32_t cmdsize;\n  uint32_t dataoff;\n  uint32_t datasize;\n};\n\nstruct data_in_code_entry {\n  uint32_t offset;\n  uint16_t length;\n  uint16_t kind;\n};\n\nstruct source_version_command {\n  uint32_t cmd;\n  uint32_t cmdsize;\n  uint64_t version;\n};\n\nstruct encryption_info_command {\n  uint32_t cmd;\n  uint32_t cmdsize;\n  uint32_t cryptoff;\n  uint32_t cryptsize;\n  uint32_t cryptid;\n};\n\nstruct encryption_info_command_64 {\n  uint32_t cmd;\n  uint32_t cmdsize;\n  uint32_t cryptoff;\n  uint32_t cryptsize;\n  uint32_t cryptid;\n  uint32_t pad;\n};\n\nstruct version_min_command {\n  uint32_t cmd;     // LC_VERSION_MIN_MACOSX or\n                    // LC_VERSION_MIN_IPHONEOS\n  uint32_t cmdsize; // sizeof(struct version_min_command)\n  uint32_t version; // X.Y.Z is encoded in nibbles xxxx.yy.zz\n  uint32_t sdk;     // X.Y.Z is encoded in nibbles xxxx.yy.zz\n};\n\nstruct note_command {\n  uint32_t cmd;        // LC_NOTE\n  uint32_t cmdsize;    // sizeof(struct note_command)\n  char data_owner[16]; // owner name for this LC_NOTE\n  uint64_t offset;     // file offset of this data\n  uint64_t size;       // length of data region\n};\n\nstruct build_tool_version {\n  uint32_t tool;    // enum for the tool\n  uint32_t version; // version of the tool\n};\n\nstruct build_version_command {\n  uint32_t cmd;      // LC_BUILD_VERSION\n  uint32_t cmdsize;  // sizeof(struct build_version_command) +\n                     // ntools * sizeof(struct build_tool_version)\n  uint32_t platform; // platform\n  uint32_t minos;    // X.Y.Z is encoded in nibbles xxxx.yy.zz\n  uint32_t sdk;      // X.Y.Z is encoded in nibbles xxxx.yy.zz\n  uint32_t ntools;   // number of tool entries following this\n};\n\nstruct dyld_info_command {\n  uint32_t cmd;\n  uint32_t cmdsize;\n  uint32_t rebase_off;\n  uint32_t rebase_size;\n  uint32_t bind_off;\n  uint32_t bind_size;\n  uint32_t weak_bind_off;\n  uint32_t weak_bind_size;\n  uint32_t lazy_bind_off;\n  uint32_t lazy_bind_size;\n  uint32_t export_off;\n  uint32_t export_size;\n};\n\nstruct linker_option_command {\n  uint32_t cmd;\n  uint32_t cmdsize;\n  uint32_t count;\n};\n\n// The symseg_command is obsolete and no longer supported.\nstruct symseg_command {\n  uint32_t cmd;\n  uint32_t cmdsize;\n  uint32_t offset;\n  uint32_t size;\n};\n\n// The ident_command is obsolete and no longer supported.\nstruct ident_command {\n  uint32_t cmd;\n  uint32_t cmdsize;\n};\n\n// The fvmfile_command is obsolete and no longer supported.\nstruct fvmfile_command {\n  uint32_t cmd;\n  uint32_t cmdsize;\n  uint32_t name;\n  uint32_t header_addr;\n};\n\nstruct tlv_descriptor_32 {\n  uint32_t thunk;\n  uint32_t key;\n  uint32_t offset;\n};\n\nstruct tlv_descriptor_64 {\n  uint64_t thunk;\n  uint64_t key;\n  uint64_t offset;\n};\n\nstruct tlv_descriptor {\n  uintptr_t thunk;\n  uintptr_t key;\n  uintptr_t offset;\n};\n\nstruct entry_point_command {\n  uint32_t cmd;\n  uint32_t cmdsize;\n  uint64_t entryoff;\n  uint64_t stacksize;\n};\n\n// Structs from <mach-o/fat.h>\nstruct fat_header {\n  uint32_t magic;\n  uint32_t nfat_arch;\n};\n\nstruct fat_arch {\n  uint32_t cputype;\n  uint32_t cpusubtype;\n  uint32_t offset;\n  uint32_t size;\n  uint32_t align;\n};\n\nstruct fat_arch_64 {\n  uint32_t cputype;\n  uint32_t cpusubtype;\n  uint64_t offset;\n  uint64_t size;\n  uint32_t align;\n  uint32_t reserved;\n};\n\n// Structs from <mach-o/reloc.h>\nstruct relocation_info {\n  int32_t r_address;\n  uint32_t r_symbolnum : 24, r_pcrel : 1, r_length : 2, r_extern : 1,\n      r_type : 4;\n};\n\nstruct scattered_relocation_info {\n#if defined(BYTE_ORDER) && defined(BIG_ENDIAN) && (BYTE_ORDER == BIG_ENDIAN)\n  uint32_t r_scattered : 1, r_pcrel : 1, r_length : 2, r_type : 4,\n      r_address : 24;\n#else\n  uint32_t r_address : 24, r_type : 4, r_length : 2, r_pcrel : 1,\n      r_scattered : 1;\n#endif\n  int32_t r_value;\n};\n\n// Structs NOT from <mach-o/reloc.h>, but that make LLVM's life easier\nstruct any_relocation_info {\n  uint32_t r_word0, r_word1;\n};\n\n// Structs from <mach-o/nlist.h>\nstruct nlist_base {\n  uint32_t n_strx;\n  uint8_t n_type;\n  uint8_t n_sect;\n  uint16_t n_desc;\n};\n\nstruct nlist {\n  uint32_t n_strx;\n  uint8_t n_type;\n  uint8_t n_sect;\n  int16_t n_desc;\n  uint32_t n_value;\n};\n\nstruct nlist_64 {\n  uint32_t n_strx;\n  uint8_t n_type;\n  uint8_t n_sect;\n  uint16_t n_desc;\n  uint64_t n_value;\n};\n\n// Byte order swapping functions for MachO structs\n\ninline void swapStruct(fat_header &mh) {\n  sys::swapByteOrder(mh.magic);\n  sys::swapByteOrder(mh.nfat_arch);\n}\n\ninline void swapStruct(fat_arch &mh) {\n  sys::swapByteOrder(mh.cputype);\n  sys::swapByteOrder(mh.cpusubtype);\n  sys::swapByteOrder(mh.offset);\n  sys::swapByteOrder(mh.size);\n  sys::swapByteOrder(mh.align);\n}\n\ninline void swapStruct(fat_arch_64 &mh) {\n  sys::swapByteOrder(mh.cputype);\n  sys::swapByteOrder(mh.cpusubtype);\n  sys::swapByteOrder(mh.offset);\n  sys::swapByteOrder(mh.size);\n  sys::swapByteOrder(mh.align);\n  sys::swapByteOrder(mh.reserved);\n}\n\ninline void swapStruct(mach_header &mh) {\n  sys::swapByteOrder(mh.magic);\n  sys::swapByteOrder(mh.cputype);\n  sys::swapByteOrder(mh.cpusubtype);\n  sys::swapByteOrder(mh.filetype);\n  sys::swapByteOrder(mh.ncmds);\n  sys::swapByteOrder(mh.sizeofcmds);\n  sys::swapByteOrder(mh.flags);\n}\n\ninline void swapStruct(mach_header_64 &H) {\n  sys::swapByteOrder(H.magic);\n  sys::swapByteOrder(H.cputype);\n  sys::swapByteOrder(H.cpusubtype);\n  sys::swapByteOrder(H.filetype);\n  sys::swapByteOrder(H.ncmds);\n  sys::swapByteOrder(H.sizeofcmds);\n  sys::swapByteOrder(H.flags);\n  sys::swapByteOrder(H.reserved);\n}\n\ninline void swapStruct(load_command &lc) {\n  sys::swapByteOrder(lc.cmd);\n  sys::swapByteOrder(lc.cmdsize);\n}\n\ninline void swapStruct(symtab_command &lc) {\n  sys::swapByteOrder(lc.cmd);\n  sys::swapByteOrder(lc.cmdsize);\n  sys::swapByteOrder(lc.symoff);\n  sys::swapByteOrder(lc.nsyms);\n  sys::swapByteOrder(lc.stroff);\n  sys::swapByteOrder(lc.strsize);\n}\n\ninline void swapStruct(segment_command_64 &seg) {\n  sys::swapByteOrder(seg.cmd);\n  sys::swapByteOrder(seg.cmdsize);\n  sys::swapByteOrder(seg.vmaddr);\n  sys::swapByteOrder(seg.vmsize);\n  sys::swapByteOrder(seg.fileoff);\n  sys::swapByteOrder(seg.filesize);\n  sys::swapByteOrder(seg.maxprot);\n  sys::swapByteOrder(seg.initprot);\n  sys::swapByteOrder(seg.nsects);\n  sys::swapByteOrder(seg.flags);\n}\n\ninline void swapStruct(segment_command &seg) {\n  sys::swapByteOrder(seg.cmd);\n  sys::swapByteOrder(seg.cmdsize);\n  sys::swapByteOrder(seg.vmaddr);\n  sys::swapByteOrder(seg.vmsize);\n  sys::swapByteOrder(seg.fileoff);\n  sys::swapByteOrder(seg.filesize);\n  sys::swapByteOrder(seg.maxprot);\n  sys::swapByteOrder(seg.initprot);\n  sys::swapByteOrder(seg.nsects);\n  sys::swapByteOrder(seg.flags);\n}\n\ninline void swapStruct(section_64 &sect) {\n  sys::swapByteOrder(sect.addr);\n  sys::swapByteOrder(sect.size);\n  sys::swapByteOrder(sect.offset);\n  sys::swapByteOrder(sect.align);\n  sys::swapByteOrder(sect.reloff);\n  sys::swapByteOrder(sect.nreloc);\n  sys::swapByteOrder(sect.flags);\n  sys::swapByteOrder(sect.reserved1);\n  sys::swapByteOrder(sect.reserved2);\n}\n\ninline void swapStruct(section &sect) {\n  sys::swapByteOrder(sect.addr);\n  sys::swapByteOrder(sect.size);\n  sys::swapByteOrder(sect.offset);\n  sys::swapByteOrder(sect.align);\n  sys::swapByteOrder(sect.reloff);\n  sys::swapByteOrder(sect.nreloc);\n  sys::swapByteOrder(sect.flags);\n  sys::swapByteOrder(sect.reserved1);\n  sys::swapByteOrder(sect.reserved2);\n}\n\ninline void swapStruct(dyld_info_command &info) {\n  sys::swapByteOrder(info.cmd);\n  sys::swapByteOrder(info.cmdsize);\n  sys::swapByteOrder(info.rebase_off);\n  sys::swapByteOrder(info.rebase_size);\n  sys::swapByteOrder(info.bind_off);\n  sys::swapByteOrder(info.bind_size);\n  sys::swapByteOrder(info.weak_bind_off);\n  sys::swapByteOrder(info.weak_bind_size);\n  sys::swapByteOrder(info.lazy_bind_off);\n  sys::swapByteOrder(info.lazy_bind_size);\n  sys::swapByteOrder(info.export_off);\n  sys::swapByteOrder(info.export_size);\n}\n\ninline void swapStruct(dylib_command &d) {\n  sys::swapByteOrder(d.cmd);\n  sys::swapByteOrder(d.cmdsize);\n  sys::swapByteOrder(d.dylib.name);\n  sys::swapByteOrder(d.dylib.timestamp);\n  sys::swapByteOrder(d.dylib.current_version);\n  sys::swapByteOrder(d.dylib.compatibility_version);\n}\n\ninline void swapStruct(sub_framework_command &s) {\n  sys::swapByteOrder(s.cmd);\n  sys::swapByteOrder(s.cmdsize);\n  sys::swapByteOrder(s.umbrella);\n}\n\ninline void swapStruct(sub_umbrella_command &s) {\n  sys::swapByteOrder(s.cmd);\n  sys::swapByteOrder(s.cmdsize);\n  sys::swapByteOrder(s.sub_umbrella);\n}\n\ninline void swapStruct(sub_library_command &s) {\n  sys::swapByteOrder(s.cmd);\n  sys::swapByteOrder(s.cmdsize);\n  sys::swapByteOrder(s.sub_library);\n}\n\ninline void swapStruct(sub_client_command &s) {\n  sys::swapByteOrder(s.cmd);\n  sys::swapByteOrder(s.cmdsize);\n  sys::swapByteOrder(s.client);\n}\n\ninline void swapStruct(routines_command &r) {\n  sys::swapByteOrder(r.cmd);\n  sys::swapByteOrder(r.cmdsize);\n  sys::swapByteOrder(r.init_address);\n  sys::swapByteOrder(r.init_module);\n  sys::swapByteOrder(r.reserved1);\n  sys::swapByteOrder(r.reserved2);\n  sys::swapByteOrder(r.reserved3);\n  sys::swapByteOrder(r.reserved4);\n  sys::swapByteOrder(r.reserved5);\n  sys::swapByteOrder(r.reserved6);\n}\n\ninline void swapStruct(routines_command_64 &r) {\n  sys::swapByteOrder(r.cmd);\n  sys::swapByteOrder(r.cmdsize);\n  sys::swapByteOrder(r.init_address);\n  sys::swapByteOrder(r.init_module);\n  sys::swapByteOrder(r.reserved1);\n  sys::swapByteOrder(r.reserved2);\n  sys::swapByteOrder(r.reserved3);\n  sys::swapByteOrder(r.reserved4);\n  sys::swapByteOrder(r.reserved5);\n  sys::swapByteOrder(r.reserved6);\n}\n\ninline void swapStruct(thread_command &t) {\n  sys::swapByteOrder(t.cmd);\n  sys::swapByteOrder(t.cmdsize);\n}\n\ninline void swapStruct(dylinker_command &d) {\n  sys::swapByteOrder(d.cmd);\n  sys::swapByteOrder(d.cmdsize);\n  sys::swapByteOrder(d.name);\n}\n\ninline void swapStruct(uuid_command &u) {\n  sys::swapByteOrder(u.cmd);\n  sys::swapByteOrder(u.cmdsize);\n}\n\ninline void swapStruct(rpath_command &r) {\n  sys::swapByteOrder(r.cmd);\n  sys::swapByteOrder(r.cmdsize);\n  sys::swapByteOrder(r.path);\n}\n\ninline void swapStruct(source_version_command &s) {\n  sys::swapByteOrder(s.cmd);\n  sys::swapByteOrder(s.cmdsize);\n  sys::swapByteOrder(s.version);\n}\n\ninline void swapStruct(entry_point_command &e) {\n  sys::swapByteOrder(e.cmd);\n  sys::swapByteOrder(e.cmdsize);\n  sys::swapByteOrder(e.entryoff);\n  sys::swapByteOrder(e.stacksize);\n}\n\ninline void swapStruct(encryption_info_command &e) {\n  sys::swapByteOrder(e.cmd);\n  sys::swapByteOrder(e.cmdsize);\n  sys::swapByteOrder(e.cryptoff);\n  sys::swapByteOrder(e.cryptsize);\n  sys::swapByteOrder(e.cryptid);\n}\n\ninline void swapStruct(encryption_info_command_64 &e) {\n  sys::swapByteOrder(e.cmd);\n  sys::swapByteOrder(e.cmdsize);\n  sys::swapByteOrder(e.cryptoff);\n  sys::swapByteOrder(e.cryptsize);\n  sys::swapByteOrder(e.cryptid);\n  sys::swapByteOrder(e.pad);\n}\n\ninline void swapStruct(dysymtab_command &dst) {\n  sys::swapByteOrder(dst.cmd);\n  sys::swapByteOrder(dst.cmdsize);\n  sys::swapByteOrder(dst.ilocalsym);\n  sys::swapByteOrder(dst.nlocalsym);\n  sys::swapByteOrder(dst.iextdefsym);\n  sys::swapByteOrder(dst.nextdefsym);\n  sys::swapByteOrder(dst.iundefsym);\n  sys::swapByteOrder(dst.nundefsym);\n  sys::swapByteOrder(dst.tocoff);\n  sys::swapByteOrder(dst.ntoc);\n  sys::swapByteOrder(dst.modtaboff);\n  sys::swapByteOrder(dst.nmodtab);\n  sys::swapByteOrder(dst.extrefsymoff);\n  sys::swapByteOrder(dst.nextrefsyms);\n  sys::swapByteOrder(dst.indirectsymoff);\n  sys::swapByteOrder(dst.nindirectsyms);\n  sys::swapByteOrder(dst.extreloff);\n  sys::swapByteOrder(dst.nextrel);\n  sys::swapByteOrder(dst.locreloff);\n  sys::swapByteOrder(dst.nlocrel);\n}\n\ninline void swapStruct(any_relocation_info &reloc) {\n  sys::swapByteOrder(reloc.r_word0);\n  sys::swapByteOrder(reloc.r_word1);\n}\n\ninline void swapStruct(nlist_base &S) {\n  sys::swapByteOrder(S.n_strx);\n  sys::swapByteOrder(S.n_desc);\n}\n\ninline void swapStruct(nlist &sym) {\n  sys::swapByteOrder(sym.n_strx);\n  sys::swapByteOrder(sym.n_desc);\n  sys::swapByteOrder(sym.n_value);\n}\n\ninline void swapStruct(nlist_64 &sym) {\n  sys::swapByteOrder(sym.n_strx);\n  sys::swapByteOrder(sym.n_desc);\n  sys::swapByteOrder(sym.n_value);\n}\n\ninline void swapStruct(linkedit_data_command &C) {\n  sys::swapByteOrder(C.cmd);\n  sys::swapByteOrder(C.cmdsize);\n  sys::swapByteOrder(C.dataoff);\n  sys::swapByteOrder(C.datasize);\n}\n\ninline void swapStruct(linker_option_command &C) {\n  sys::swapByteOrder(C.cmd);\n  sys::swapByteOrder(C.cmdsize);\n  sys::swapByteOrder(C.count);\n}\n\ninline void swapStruct(version_min_command &C) {\n  sys::swapByteOrder(C.cmd);\n  sys::swapByteOrder(C.cmdsize);\n  sys::swapByteOrder(C.version);\n  sys::swapByteOrder(C.sdk);\n}\n\ninline void swapStruct(note_command &C) {\n  sys::swapByteOrder(C.cmd);\n  sys::swapByteOrder(C.cmdsize);\n  sys::swapByteOrder(C.offset);\n  sys::swapByteOrder(C.size);\n}\n\ninline void swapStruct(build_version_command &C) {\n  sys::swapByteOrder(C.cmd);\n  sys::swapByteOrder(C.cmdsize);\n  sys::swapByteOrder(C.platform);\n  sys::swapByteOrder(C.minos);\n  sys::swapByteOrder(C.sdk);\n  sys::swapByteOrder(C.ntools);\n}\n\ninline void swapStruct(build_tool_version &C) {\n  sys::swapByteOrder(C.tool);\n  sys::swapByteOrder(C.version);\n}\n\ninline void swapStruct(data_in_code_entry &C) {\n  sys::swapByteOrder(C.offset);\n  sys::swapByteOrder(C.length);\n  sys::swapByteOrder(C.kind);\n}\n\ninline void swapStruct(uint32_t &C) { sys::swapByteOrder(C); }\n\n// The prebind_cksum_command is obsolete and no longer supported.\ninline void swapStruct(prebind_cksum_command &C) {\n  sys::swapByteOrder(C.cmd);\n  sys::swapByteOrder(C.cmdsize);\n  sys::swapByteOrder(C.cksum);\n}\n\n// The twolevel_hints_command is obsolete and no longer supported.\ninline void swapStruct(twolevel_hints_command &C) {\n  sys::swapByteOrder(C.cmd);\n  sys::swapByteOrder(C.cmdsize);\n  sys::swapByteOrder(C.offset);\n  sys::swapByteOrder(C.nhints);\n}\n\n// The prebound_dylib_command is obsolete and no longer supported.\ninline void swapStruct(prebound_dylib_command &C) {\n  sys::swapByteOrder(C.cmd);\n  sys::swapByteOrder(C.cmdsize);\n  sys::swapByteOrder(C.name);\n  sys::swapByteOrder(C.nmodules);\n  sys::swapByteOrder(C.linked_modules);\n}\n\n// The fvmfile_command is obsolete and no longer supported.\ninline void swapStruct(fvmfile_command &C) {\n  sys::swapByteOrder(C.cmd);\n  sys::swapByteOrder(C.cmdsize);\n  sys::swapByteOrder(C.name);\n  sys::swapByteOrder(C.header_addr);\n}\n\n// The symseg_command is obsolete and no longer supported.\ninline void swapStruct(symseg_command &C) {\n  sys::swapByteOrder(C.cmd);\n  sys::swapByteOrder(C.cmdsize);\n  sys::swapByteOrder(C.offset);\n  sys::swapByteOrder(C.size);\n}\n\n// The ident_command is obsolete and no longer supported.\ninline void swapStruct(ident_command &C) {\n  sys::swapByteOrder(C.cmd);\n  sys::swapByteOrder(C.cmdsize);\n}\n\ninline void swapStruct(fvmlib &C) {\n  sys::swapByteOrder(C.name);\n  sys::swapByteOrder(C.minor_version);\n  sys::swapByteOrder(C.header_addr);\n}\n\n// The fvmlib_command is obsolete and no longer supported.\ninline void swapStruct(fvmlib_command &C) {\n  sys::swapByteOrder(C.cmd);\n  sys::swapByteOrder(C.cmdsize);\n  swapStruct(C.fvmlib);\n}\n\n// Get/Set functions from <mach-o/nlist.h>\n\ninline uint16_t GET_LIBRARY_ORDINAL(uint16_t n_desc) {\n  return (((n_desc) >> 8u) & 0xffu);\n}\n\ninline void SET_LIBRARY_ORDINAL(uint16_t &n_desc, uint8_t ordinal) {\n  n_desc = (((n_desc)&0x00ff) | (((ordinal)&0xff) << 8));\n}\n\ninline uint8_t GET_COMM_ALIGN(uint16_t n_desc) {\n  return (n_desc >> 8u) & 0x0fu;\n}\n\ninline void SET_COMM_ALIGN(uint16_t &n_desc, uint8_t align) {\n  n_desc = ((n_desc & 0xf0ffu) | ((align & 0x0fu) << 8u));\n}\n\n// Enums from <mach/machine.h>\nenum : uint32_t {\n  // Capability bits used in the definition of cpu_type.\n  CPU_ARCH_MASK = 0xff000000, // Mask for architecture bits\n  CPU_ARCH_ABI64 = 0x01000000, // 64 bit ABI\n  CPU_ARCH_ABI64_32 = 0x02000000, // ILP32 ABI on 64-bit hardware\n};\n\n// Constants for the cputype field.\nenum CPUType {\n  CPU_TYPE_ANY = -1,\n  CPU_TYPE_X86 = 7,\n  CPU_TYPE_I386 = CPU_TYPE_X86,\n  CPU_TYPE_X86_64 = CPU_TYPE_X86 | CPU_ARCH_ABI64,\n  /* CPU_TYPE_MIPS      = 8, */\n  CPU_TYPE_MC98000 = 10, // Old Motorola PowerPC\n  CPU_TYPE_ARM = 12,\n  CPU_TYPE_ARM64 = CPU_TYPE_ARM | CPU_ARCH_ABI64,\n  CPU_TYPE_ARM64_32 = CPU_TYPE_ARM | CPU_ARCH_ABI64_32,\n  CPU_TYPE_SPARC = 14,\n  CPU_TYPE_POWERPC = 18,\n  CPU_TYPE_POWERPC64 = CPU_TYPE_POWERPC | CPU_ARCH_ABI64\n};\n\nenum : uint32_t {\n  // Capability bits used in the definition of cpusubtype.\n  CPU_SUBTYPE_MASK = 0xff000000,  // Mask for architecture bits\n  CPU_SUBTYPE_LIB64 = 0x80000000, // 64 bit libraries\n\n  // Special CPU subtype constants.\n  CPU_SUBTYPE_MULTIPLE = ~0u\n};\n\n// Constants for the cpusubtype field.\nenum CPUSubTypeX86 {\n  CPU_SUBTYPE_I386_ALL = 3,\n  CPU_SUBTYPE_386 = 3,\n  CPU_SUBTYPE_486 = 4,\n  CPU_SUBTYPE_486SX = 0x84,\n  CPU_SUBTYPE_586 = 5,\n  CPU_SUBTYPE_PENT = CPU_SUBTYPE_586,\n  CPU_SUBTYPE_PENTPRO = 0x16,\n  CPU_SUBTYPE_PENTII_M3 = 0x36,\n  CPU_SUBTYPE_PENTII_M5 = 0x56,\n  CPU_SUBTYPE_CELERON = 0x67,\n  CPU_SUBTYPE_CELERON_MOBILE = 0x77,\n  CPU_SUBTYPE_PENTIUM_3 = 0x08,\n  CPU_SUBTYPE_PENTIUM_3_M = 0x18,\n  CPU_SUBTYPE_PENTIUM_3_XEON = 0x28,\n  CPU_SUBTYPE_PENTIUM_M = 0x09,\n  CPU_SUBTYPE_PENTIUM_4 = 0x0a,\n  CPU_SUBTYPE_PENTIUM_4_M = 0x1a,\n  CPU_SUBTYPE_ITANIUM = 0x0b,\n  CPU_SUBTYPE_ITANIUM_2 = 0x1b,\n  CPU_SUBTYPE_XEON = 0x0c,\n  CPU_SUBTYPE_XEON_MP = 0x1c,\n\n  CPU_SUBTYPE_X86_ALL = 3,\n  CPU_SUBTYPE_X86_64_ALL = 3,\n  CPU_SUBTYPE_X86_ARCH1 = 4,\n  CPU_SUBTYPE_X86_64_H = 8\n};\ninline int CPU_SUBTYPE_INTEL(int Family, int Model) {\n  return Family | (Model << 4);\n}\ninline int CPU_SUBTYPE_INTEL_FAMILY(CPUSubTypeX86 ST) {\n  return ((int)ST) & 0x0f;\n}\ninline int CPU_SUBTYPE_INTEL_MODEL(CPUSubTypeX86 ST) { return ((int)ST) >> 4; }\nenum { CPU_SUBTYPE_INTEL_FAMILY_MAX = 15, CPU_SUBTYPE_INTEL_MODEL_ALL = 0 };\n\nenum CPUSubTypeARM {\n  CPU_SUBTYPE_ARM_ALL = 0,\n  CPU_SUBTYPE_ARM_V4T = 5,\n  CPU_SUBTYPE_ARM_V6 = 6,\n  CPU_SUBTYPE_ARM_V5 = 7,\n  CPU_SUBTYPE_ARM_V5TEJ = 7,\n  CPU_SUBTYPE_ARM_XSCALE = 8,\n  CPU_SUBTYPE_ARM_V7 = 9,\n  //  unused  ARM_V7F     = 10,\n  CPU_SUBTYPE_ARM_V7S = 11,\n  CPU_SUBTYPE_ARM_V7K = 12,\n  CPU_SUBTYPE_ARM_V6M = 14,\n  CPU_SUBTYPE_ARM_V7M = 15,\n  CPU_SUBTYPE_ARM_V7EM = 16\n};\n\nenum CPUSubTypeARM64 {\n  CPU_SUBTYPE_ARM64_ALL = 0,\n  CPU_SUBTYPE_ARM64_V8 = 1,\n  CPU_SUBTYPE_ARM64E = 2,\n};\n\nenum CPUSubTypeARM64_32 { CPU_SUBTYPE_ARM64_32_V8 = 1 };\n\nenum CPUSubTypeSPARC { CPU_SUBTYPE_SPARC_ALL = 0 };\n\nenum CPUSubTypePowerPC {\n  CPU_SUBTYPE_POWERPC_ALL = 0,\n  CPU_SUBTYPE_POWERPC_601 = 1,\n  CPU_SUBTYPE_POWERPC_602 = 2,\n  CPU_SUBTYPE_POWERPC_603 = 3,\n  CPU_SUBTYPE_POWERPC_603e = 4,\n  CPU_SUBTYPE_POWERPC_603ev = 5,\n  CPU_SUBTYPE_POWERPC_604 = 6,\n  CPU_SUBTYPE_POWERPC_604e = 7,\n  CPU_SUBTYPE_POWERPC_620 = 8,\n  CPU_SUBTYPE_POWERPC_750 = 9,\n  CPU_SUBTYPE_POWERPC_7400 = 10,\n  CPU_SUBTYPE_POWERPC_7450 = 11,\n  CPU_SUBTYPE_POWERPC_970 = 100,\n\n  CPU_SUBTYPE_MC980000_ALL = CPU_SUBTYPE_POWERPC_ALL,\n  CPU_SUBTYPE_MC98601 = CPU_SUBTYPE_POWERPC_601\n};\n\nExpected<uint32_t> getCPUType(const Triple &T);\nExpected<uint32_t> getCPUSubType(const Triple &T);\n\nstruct x86_thread_state32_t {\n  uint32_t eax;\n  uint32_t ebx;\n  uint32_t ecx;\n  uint32_t edx;\n  uint32_t edi;\n  uint32_t esi;\n  uint32_t ebp;\n  uint32_t esp;\n  uint32_t ss;\n  uint32_t eflags;\n  uint32_t eip;\n  uint32_t cs;\n  uint32_t ds;\n  uint32_t es;\n  uint32_t fs;\n  uint32_t gs;\n};\n\nstruct x86_thread_state64_t {\n  uint64_t rax;\n  uint64_t rbx;\n  uint64_t rcx;\n  uint64_t rdx;\n  uint64_t rdi;\n  uint64_t rsi;\n  uint64_t rbp;\n  uint64_t rsp;\n  uint64_t r8;\n  uint64_t r9;\n  uint64_t r10;\n  uint64_t r11;\n  uint64_t r12;\n  uint64_t r13;\n  uint64_t r14;\n  uint64_t r15;\n  uint64_t rip;\n  uint64_t rflags;\n  uint64_t cs;\n  uint64_t fs;\n  uint64_t gs;\n};\n\nenum x86_fp_control_precis {\n  x86_FP_PREC_24B = 0,\n  x86_FP_PREC_53B = 2,\n  x86_FP_PREC_64B = 3\n};\n\nenum x86_fp_control_rc {\n  x86_FP_RND_NEAR = 0,\n  x86_FP_RND_DOWN = 1,\n  x86_FP_RND_UP = 2,\n  x86_FP_CHOP = 3\n};\n\nstruct fp_control_t {\n  unsigned short invalid : 1, denorm : 1, zdiv : 1, ovrfl : 1, undfl : 1,\n      precis : 1, : 2, pc : 2, rc : 2, : 1, : 3;\n};\n\nstruct fp_status_t {\n  unsigned short invalid : 1, denorm : 1, zdiv : 1, ovrfl : 1, undfl : 1,\n      precis : 1, stkflt : 1, errsumm : 1, c0 : 1, c1 : 1, c2 : 1, tos : 3,\n      c3 : 1, busy : 1;\n};\n\nstruct mmst_reg_t {\n  char mmst_reg[10];\n  char mmst_rsrv[6];\n};\n\nstruct xmm_reg_t {\n  char xmm_reg[16];\n};\n\nstruct x86_float_state64_t {\n  int32_t fpu_reserved[2];\n  fp_control_t fpu_fcw;\n  fp_status_t fpu_fsw;\n  uint8_t fpu_ftw;\n  uint8_t fpu_rsrv1;\n  uint16_t fpu_fop;\n  uint32_t fpu_ip;\n  uint16_t fpu_cs;\n  uint16_t fpu_rsrv2;\n  uint32_t fpu_dp;\n  uint16_t fpu_ds;\n  uint16_t fpu_rsrv3;\n  uint32_t fpu_mxcsr;\n  uint32_t fpu_mxcsrmask;\n  mmst_reg_t fpu_stmm0;\n  mmst_reg_t fpu_stmm1;\n  mmst_reg_t fpu_stmm2;\n  mmst_reg_t fpu_stmm3;\n  mmst_reg_t fpu_stmm4;\n  mmst_reg_t fpu_stmm5;\n  mmst_reg_t fpu_stmm6;\n  mmst_reg_t fpu_stmm7;\n  xmm_reg_t fpu_xmm0;\n  xmm_reg_t fpu_xmm1;\n  xmm_reg_t fpu_xmm2;\n  xmm_reg_t fpu_xmm3;\n  xmm_reg_t fpu_xmm4;\n  xmm_reg_t fpu_xmm5;\n  xmm_reg_t fpu_xmm6;\n  xmm_reg_t fpu_xmm7;\n  xmm_reg_t fpu_xmm8;\n  xmm_reg_t fpu_xmm9;\n  xmm_reg_t fpu_xmm10;\n  xmm_reg_t fpu_xmm11;\n  xmm_reg_t fpu_xmm12;\n  xmm_reg_t fpu_xmm13;\n  xmm_reg_t fpu_xmm14;\n  xmm_reg_t fpu_xmm15;\n  char fpu_rsrv4[6 * 16];\n  uint32_t fpu_reserved1;\n};\n\nstruct x86_exception_state64_t {\n  uint16_t trapno;\n  uint16_t cpu;\n  uint32_t err;\n  uint64_t faultvaddr;\n};\n\ninline void swapStruct(x86_thread_state32_t &x) {\n  sys::swapByteOrder(x.eax);\n  sys::swapByteOrder(x.ebx);\n  sys::swapByteOrder(x.ecx);\n  sys::swapByteOrder(x.edx);\n  sys::swapByteOrder(x.edi);\n  sys::swapByteOrder(x.esi);\n  sys::swapByteOrder(x.ebp);\n  sys::swapByteOrder(x.esp);\n  sys::swapByteOrder(x.ss);\n  sys::swapByteOrder(x.eflags);\n  sys::swapByteOrder(x.eip);\n  sys::swapByteOrder(x.cs);\n  sys::swapByteOrder(x.ds);\n  sys::swapByteOrder(x.es);\n  sys::swapByteOrder(x.fs);\n  sys::swapByteOrder(x.gs);\n}\n\ninline void swapStruct(x86_thread_state64_t &x) {\n  sys::swapByteOrder(x.rax);\n  sys::swapByteOrder(x.rbx);\n  sys::swapByteOrder(x.rcx);\n  sys::swapByteOrder(x.rdx);\n  sys::swapByteOrder(x.rdi);\n  sys::swapByteOrder(x.rsi);\n  sys::swapByteOrder(x.rbp);\n  sys::swapByteOrder(x.rsp);\n  sys::swapByteOrder(x.r8);\n  sys::swapByteOrder(x.r9);\n  sys::swapByteOrder(x.r10);\n  sys::swapByteOrder(x.r11);\n  sys::swapByteOrder(x.r12);\n  sys::swapByteOrder(x.r13);\n  sys::swapByteOrder(x.r14);\n  sys::swapByteOrder(x.r15);\n  sys::swapByteOrder(x.rip);\n  sys::swapByteOrder(x.rflags);\n  sys::swapByteOrder(x.cs);\n  sys::swapByteOrder(x.fs);\n  sys::swapByteOrder(x.gs);\n}\n\ninline void swapStruct(x86_float_state64_t &x) {\n  sys::swapByteOrder(x.fpu_reserved[0]);\n  sys::swapByteOrder(x.fpu_reserved[1]);\n  // TODO swap: fp_control_t fpu_fcw;\n  // TODO swap: fp_status_t fpu_fsw;\n  sys::swapByteOrder(x.fpu_fop);\n  sys::swapByteOrder(x.fpu_ip);\n  sys::swapByteOrder(x.fpu_cs);\n  sys::swapByteOrder(x.fpu_rsrv2);\n  sys::swapByteOrder(x.fpu_dp);\n  sys::swapByteOrder(x.fpu_ds);\n  sys::swapByteOrder(x.fpu_rsrv3);\n  sys::swapByteOrder(x.fpu_mxcsr);\n  sys::swapByteOrder(x.fpu_mxcsrmask);\n  sys::swapByteOrder(x.fpu_reserved1);\n}\n\ninline void swapStruct(x86_exception_state64_t &x) {\n  sys::swapByteOrder(x.trapno);\n  sys::swapByteOrder(x.cpu);\n  sys::swapByteOrder(x.err);\n  sys::swapByteOrder(x.faultvaddr);\n}\n\nstruct x86_state_hdr_t {\n  uint32_t flavor;\n  uint32_t count;\n};\n\nstruct x86_thread_state_t {\n  x86_state_hdr_t tsh;\n  union {\n    x86_thread_state64_t ts64;\n    x86_thread_state32_t ts32;\n  } uts;\n};\n\nstruct x86_float_state_t {\n  x86_state_hdr_t fsh;\n  union {\n    x86_float_state64_t fs64;\n  } ufs;\n};\n\nstruct x86_exception_state_t {\n  x86_state_hdr_t esh;\n  union {\n    x86_exception_state64_t es64;\n  } ues;\n};\n\ninline void swapStruct(x86_state_hdr_t &x) {\n  sys::swapByteOrder(x.flavor);\n  sys::swapByteOrder(x.count);\n}\n\nenum X86ThreadFlavors {\n  x86_THREAD_STATE32 = 1,\n  x86_FLOAT_STATE32 = 2,\n  x86_EXCEPTION_STATE32 = 3,\n  x86_THREAD_STATE64 = 4,\n  x86_FLOAT_STATE64 = 5,\n  x86_EXCEPTION_STATE64 = 6,\n  x86_THREAD_STATE = 7,\n  x86_FLOAT_STATE = 8,\n  x86_EXCEPTION_STATE = 9,\n  x86_DEBUG_STATE32 = 10,\n  x86_DEBUG_STATE64 = 11,\n  x86_DEBUG_STATE = 12\n};\n\ninline void swapStruct(x86_thread_state_t &x) {\n  swapStruct(x.tsh);\n  if (x.tsh.flavor == x86_THREAD_STATE64)\n    swapStruct(x.uts.ts64);\n}\n\ninline void swapStruct(x86_float_state_t &x) {\n  swapStruct(x.fsh);\n  if (x.fsh.flavor == x86_FLOAT_STATE64)\n    swapStruct(x.ufs.fs64);\n}\n\ninline void swapStruct(x86_exception_state_t &x) {\n  swapStruct(x.esh);\n  if (x.esh.flavor == x86_EXCEPTION_STATE64)\n    swapStruct(x.ues.es64);\n}\n\nconst uint32_t x86_THREAD_STATE32_COUNT =\n    sizeof(x86_thread_state32_t) / sizeof(uint32_t);\n\nconst uint32_t x86_THREAD_STATE64_COUNT =\n    sizeof(x86_thread_state64_t) / sizeof(uint32_t);\nconst uint32_t x86_FLOAT_STATE64_COUNT =\n    sizeof(x86_float_state64_t) / sizeof(uint32_t);\nconst uint32_t x86_EXCEPTION_STATE64_COUNT =\n    sizeof(x86_exception_state64_t) / sizeof(uint32_t);\n\nconst uint32_t x86_THREAD_STATE_COUNT =\n    sizeof(x86_thread_state_t) / sizeof(uint32_t);\nconst uint32_t x86_FLOAT_STATE_COUNT =\n    sizeof(x86_float_state_t) / sizeof(uint32_t);\nconst uint32_t x86_EXCEPTION_STATE_COUNT =\n    sizeof(x86_exception_state_t) / sizeof(uint32_t);\n\nstruct arm_thread_state32_t {\n  uint32_t r[13];\n  uint32_t sp;\n  uint32_t lr;\n  uint32_t pc;\n  uint32_t cpsr;\n};\n\ninline void swapStruct(arm_thread_state32_t &x) {\n  for (int i = 0; i < 13; i++)\n    sys::swapByteOrder(x.r[i]);\n  sys::swapByteOrder(x.sp);\n  sys::swapByteOrder(x.lr);\n  sys::swapByteOrder(x.pc);\n  sys::swapByteOrder(x.cpsr);\n}\n\nstruct arm_thread_state64_t {\n  uint64_t x[29];\n  uint64_t fp;\n  uint64_t lr;\n  uint64_t sp;\n  uint64_t pc;\n  uint32_t cpsr;\n  uint32_t pad;\n};\n\ninline void swapStruct(arm_thread_state64_t &x) {\n  for (int i = 0; i < 29; i++)\n    sys::swapByteOrder(x.x[i]);\n  sys::swapByteOrder(x.fp);\n  sys::swapByteOrder(x.lr);\n  sys::swapByteOrder(x.sp);\n  sys::swapByteOrder(x.pc);\n  sys::swapByteOrder(x.cpsr);\n}\n\nstruct arm_state_hdr_t {\n  uint32_t flavor;\n  uint32_t count;\n};\n\nstruct arm_thread_state_t {\n  arm_state_hdr_t tsh;\n  union {\n    arm_thread_state32_t ts32;\n  } uts;\n};\n\ninline void swapStruct(arm_state_hdr_t &x) {\n  sys::swapByteOrder(x.flavor);\n  sys::swapByteOrder(x.count);\n}\n\nenum ARMThreadFlavors {\n  ARM_THREAD_STATE = 1,\n  ARM_VFP_STATE = 2,\n  ARM_EXCEPTION_STATE = 3,\n  ARM_DEBUG_STATE = 4,\n  ARN_THREAD_STATE_NONE = 5,\n  ARM_THREAD_STATE64 = 6,\n  ARM_EXCEPTION_STATE64 = 7\n};\n\ninline void swapStruct(arm_thread_state_t &x) {\n  swapStruct(x.tsh);\n  if (x.tsh.flavor == ARM_THREAD_STATE)\n    swapStruct(x.uts.ts32);\n}\n\nconst uint32_t ARM_THREAD_STATE_COUNT =\n    sizeof(arm_thread_state32_t) / sizeof(uint32_t);\n\nconst uint32_t ARM_THREAD_STATE64_COUNT =\n    sizeof(arm_thread_state64_t) / sizeof(uint32_t);\n\nstruct ppc_thread_state32_t {\n  uint32_t srr0;\n  uint32_t srr1;\n  uint32_t r0;\n  uint32_t r1;\n  uint32_t r2;\n  uint32_t r3;\n  uint32_t r4;\n  uint32_t r5;\n  uint32_t r6;\n  uint32_t r7;\n  uint32_t r8;\n  uint32_t r9;\n  uint32_t r10;\n  uint32_t r11;\n  uint32_t r12;\n  uint32_t r13;\n  uint32_t r14;\n  uint32_t r15;\n  uint32_t r16;\n  uint32_t r17;\n  uint32_t r18;\n  uint32_t r19;\n  uint32_t r20;\n  uint32_t r21;\n  uint32_t r22;\n  uint32_t r23;\n  uint32_t r24;\n  uint32_t r25;\n  uint32_t r26;\n  uint32_t r27;\n  uint32_t r28;\n  uint32_t r29;\n  uint32_t r30;\n  uint32_t r31;\n  uint32_t ct;\n  uint32_t xer;\n  uint32_t lr;\n  uint32_t ctr;\n  uint32_t mq;\n  uint32_t vrsave;\n};\n\ninline void swapStruct(ppc_thread_state32_t &x) {\n  sys::swapByteOrder(x.srr0);\n  sys::swapByteOrder(x.srr1);\n  sys::swapByteOrder(x.r0);\n  sys::swapByteOrder(x.r1);\n  sys::swapByteOrder(x.r2);\n  sys::swapByteOrder(x.r3);\n  sys::swapByteOrder(x.r4);\n  sys::swapByteOrder(x.r5);\n  sys::swapByteOrder(x.r6);\n  sys::swapByteOrder(x.r7);\n  sys::swapByteOrder(x.r8);\n  sys::swapByteOrder(x.r9);\n  sys::swapByteOrder(x.r10);\n  sys::swapByteOrder(x.r11);\n  sys::swapByteOrder(x.r12);\n  sys::swapByteOrder(x.r13);\n  sys::swapByteOrder(x.r14);\n  sys::swapByteOrder(x.r15);\n  sys::swapByteOrder(x.r16);\n  sys::swapByteOrder(x.r17);\n  sys::swapByteOrder(x.r18);\n  sys::swapByteOrder(x.r19);\n  sys::swapByteOrder(x.r20);\n  sys::swapByteOrder(x.r21);\n  sys::swapByteOrder(x.r22);\n  sys::swapByteOrder(x.r23);\n  sys::swapByteOrder(x.r24);\n  sys::swapByteOrder(x.r25);\n  sys::swapByteOrder(x.r26);\n  sys::swapByteOrder(x.r27);\n  sys::swapByteOrder(x.r28);\n  sys::swapByteOrder(x.r29);\n  sys::swapByteOrder(x.r30);\n  sys::swapByteOrder(x.r31);\n  sys::swapByteOrder(x.ct);\n  sys::swapByteOrder(x.xer);\n  sys::swapByteOrder(x.lr);\n  sys::swapByteOrder(x.ctr);\n  sys::swapByteOrder(x.mq);\n  sys::swapByteOrder(x.vrsave);\n}\n\nstruct ppc_state_hdr_t {\n  uint32_t flavor;\n  uint32_t count;\n};\n\nstruct ppc_thread_state_t {\n  ppc_state_hdr_t tsh;\n  union {\n    ppc_thread_state32_t ts32;\n  } uts;\n};\n\ninline void swapStruct(ppc_state_hdr_t &x) {\n  sys::swapByteOrder(x.flavor);\n  sys::swapByteOrder(x.count);\n}\n\nenum PPCThreadFlavors {\n  PPC_THREAD_STATE = 1,\n  PPC_FLOAT_STATE = 2,\n  PPC_EXCEPTION_STATE = 3,\n  PPC_VECTOR_STATE = 4,\n  PPC_THREAD_STATE64 = 5,\n  PPC_EXCEPTION_STATE64 = 6,\n  PPC_THREAD_STATE_NONE = 7\n};\n\ninline void swapStruct(ppc_thread_state_t &x) {\n  swapStruct(x.tsh);\n  if (x.tsh.flavor == PPC_THREAD_STATE)\n    swapStruct(x.uts.ts32);\n}\n\nconst uint32_t PPC_THREAD_STATE_COUNT =\n    sizeof(ppc_thread_state32_t) / sizeof(uint32_t);\n\n// Define a union of all load command structs\n#define LOAD_COMMAND_STRUCT(LCStruct) LCStruct LCStruct##_data;\n\nLLVM_PACKED_START\nunion alignas(4) macho_load_command {\n#include \"llvm/BinaryFormat/MachO.def\"\n};\nLLVM_PACKED_END\n\n/* code signing attributes of a process */\n\nenum CodeSignAttrs {\n  CS_VALID = 0x00000001,          /* dynamically valid */\n  CS_ADHOC = 0x00000002,          /* ad hoc signed */\n  CS_GET_TASK_ALLOW = 0x00000004, /* has get-task-allow entitlement */\n  CS_INSTALLER = 0x00000008,      /* has installer entitlement */\n\n  CS_FORCED_LV =\n      0x00000010, /* Library Validation required by Hardened System Policy */\n  CS_INVALID_ALLOWED = 0x00000020, /* (macOS Only) Page invalidation allowed by\n                                      task port policy */\n\n  CS_HARD = 0x00000100,             /* don't load invalid pages */\n  CS_KILL = 0x00000200,             /* kill process if it becomes invalid */\n  CS_CHECK_EXPIRATION = 0x00000400, /* force expiration checking */\n  CS_RESTRICT = 0x00000800,         /* tell dyld to treat restricted */\n\n  CS_ENFORCEMENT = 0x00001000, /* require enforcement */\n  CS_REQUIRE_LV = 0x00002000,  /* require library validation */\n  CS_ENTITLEMENTS_VALIDATED =\n      0x00004000, /* code signature permits restricted entitlements */\n  CS_NVRAM_UNRESTRICTED =\n      0x00008000, /* has com.apple.rootless.restricted-nvram-variables.heritable\n                     entitlement */\n\n  CS_RUNTIME = 0x00010000,       /* Apply hardened runtime policies */\n  CS_LINKER_SIGNED = 0x00020000, /* Automatically signed by the linker */\n\n  CS_ALLOWED_MACHO =\n      (CS_ADHOC | CS_HARD | CS_KILL | CS_CHECK_EXPIRATION | CS_RESTRICT |\n       CS_ENFORCEMENT | CS_REQUIRE_LV | CS_RUNTIME | CS_LINKER_SIGNED),\n\n  CS_EXEC_SET_HARD = 0x00100000, /* set CS_HARD on any exec'ed process */\n  CS_EXEC_SET_KILL = 0x00200000, /* set CS_KILL on any exec'ed process */\n  CS_EXEC_SET_ENFORCEMENT =\n      0x00400000, /* set CS_ENFORCEMENT on any exec'ed process */\n  CS_EXEC_INHERIT_SIP =\n      0x00800000, /* set CS_INSTALLER on any exec'ed process */\n\n  CS_KILLED = 0x01000000, /* was killed by kernel for invalidity */\n  CS_DYLD_PLATFORM =\n      0x02000000, /* dyld used to load this is a platform binary */\n  CS_PLATFORM_BINARY = 0x04000000, /* this is a platform binary */\n  CS_PLATFORM_PATH =\n      0x08000000, /* platform binary by the fact of path (osx only) */\n\n  CS_DEBUGGED = 0x10000000, /* process is currently or has previously been\n                debugged and allowed to run with invalid pages */\n  CS_SIGNED = 0x20000000, /* process has a signature (may have gone invalid) */\n  CS_DEV_CODE =\n      0x40000000, /* code is dev signed, cannot be loaded into prod signed code\n                     (will go away with rdar://problem/28322552) */\n  CS_DATAVAULT_CONTROLLER =\n      0x80000000, /* has Data Vault controller entitlement */\n\n  CS_ENTITLEMENT_FLAGS = (CS_GET_TASK_ALLOW | CS_INSTALLER |\n                          CS_DATAVAULT_CONTROLLER | CS_NVRAM_UNRESTRICTED),\n};\n\n/* executable segment flags */\n\nenum CodeSignExecSegFlags {\n\n  CS_EXECSEG_MAIN_BINARY = 0x1,     /* executable segment denotes main binary */\n  CS_EXECSEG_ALLOW_UNSIGNED = 0x10, /* allow unsigned pages (for debugging) */\n  CS_EXECSEG_DEBUGGER = 0x20,       /* main binary is debugger */\n  CS_EXECSEG_JIT = 0x40,            /* JIT enabled */\n  CS_EXECSEG_SKIP_LV = 0x80,        /* OBSOLETE: skip library validation */\n  CS_EXECSEG_CAN_LOAD_CDHASH = 0x100, /* can bless cdhash for execution */\n  CS_EXECSEG_CAN_EXEC_CDHASH = 0x200, /* can execute blessed cdhash */\n\n};\n\n/* Magic numbers used by Code Signing */\n\nenum CodeSignMagic {\n  CSMAGIC_REQUIREMENT = 0xfade0c00, /* single Requirement blob */\n  CSMAGIC_REQUIREMENTS =\n      0xfade0c01, /* Requirements vector (internal requirements) */\n  CSMAGIC_CODEDIRECTORY = 0xfade0c02,      /* CodeDirectory blob */\n  CSMAGIC_EMBEDDED_SIGNATURE = 0xfade0cc0, /* embedded form of signature data */\n  CSMAGIC_EMBEDDED_SIGNATURE_OLD = 0xfade0b02, /* XXX */\n  CSMAGIC_EMBEDDED_ENTITLEMENTS = 0xfade7171,  /* embedded entitlements */\n  CSMAGIC_DETACHED_SIGNATURE =\n      0xfade0cc1, /* multi-arch collection of embedded signatures */\n  CSMAGIC_BLOBWRAPPER = 0xfade0b01, /* CMS Signature, among other things */\n\n  CS_SUPPORTSSCATTER = 0x20100,\n  CS_SUPPORTSTEAMID = 0x20200,\n  CS_SUPPORTSCODELIMIT64 = 0x20300,\n  CS_SUPPORTSEXECSEG = 0x20400,\n  CS_SUPPORTSRUNTIME = 0x20500,\n  CS_SUPPORTSLINKAGE = 0x20600,\n\n  CSSLOT_CODEDIRECTORY = 0, /* slot index for CodeDirectory */\n  CSSLOT_INFOSLOT = 1,\n  CSSLOT_REQUIREMENTS = 2,\n  CSSLOT_RESOURCEDIR = 3,\n  CSSLOT_APPLICATION = 4,\n  CSSLOT_ENTITLEMENTS = 5,\n\n  CSSLOT_ALTERNATE_CODEDIRECTORIES =\n      0x1000, /* first alternate CodeDirectory, if any */\n  CSSLOT_ALTERNATE_CODEDIRECTORY_MAX = 5, /* max number of alternate CD slots */\n  CSSLOT_ALTERNATE_CODEDIRECTORY_LIMIT =\n      CSSLOT_ALTERNATE_CODEDIRECTORIES +\n      CSSLOT_ALTERNATE_CODEDIRECTORY_MAX, /* one past the last */\n\n  CSSLOT_SIGNATURESLOT = 0x10000, /* CMS Signature */\n  CSSLOT_IDENTIFICATIONSLOT = 0x10001,\n  CSSLOT_TICKETSLOT = 0x10002,\n\n  CSTYPE_INDEX_REQUIREMENTS = 0x00000002, /* compat with amfi */\n  CSTYPE_INDEX_ENTITLEMENTS = 0x00000005, /* compat with amfi */\n\n  CS_HASHTYPE_SHA1 = 1,\n  CS_HASHTYPE_SHA256 = 2,\n  CS_HASHTYPE_SHA256_TRUNCATED = 3,\n  CS_HASHTYPE_SHA384 = 4,\n\n  CS_SHA1_LEN = 20,\n  CS_SHA256_LEN = 32,\n  CS_SHA256_TRUNCATED_LEN = 20,\n\n  CS_CDHASH_LEN = 20,    /* always - larger hashes are truncated */\n  CS_HASH_MAX_SIZE = 48, /* max size of the hash we'll support */\n\n  /*\n   * Currently only to support Legacy VPN plugins, and Mac App Store\n   * but intended to replace all the various platform code, dev code etc. bits.\n   */\n  CS_SIGNER_TYPE_UNKNOWN = 0,\n  CS_SIGNER_TYPE_LEGACYVPN = 5,\n  CS_SIGNER_TYPE_MAC_APP_STORE = 6,\n\n  CS_SUPPL_SIGNER_TYPE_UNKNOWN = 0,\n  CS_SUPPL_SIGNER_TYPE_TRUSTCACHE = 7,\n  CS_SUPPL_SIGNER_TYPE_LOCAL = 8,\n};\n\nstruct CS_CodeDirectory {\n  uint32_t magic;         /* magic number (CSMAGIC_CODEDIRECTORY) */\n  uint32_t length;        /* total length of CodeDirectory blob */\n  uint32_t version;       /* compatibility version */\n  uint32_t flags;         /* setup and mode flags */\n  uint32_t hashOffset;    /* offset of hash slot element at index zero */\n  uint32_t identOffset;   /* offset of identifier string */\n  uint32_t nSpecialSlots; /* number of special hash slots */\n  uint32_t nCodeSlots;    /* number of ordinary (code) hash slots */\n  uint32_t codeLimit;     /* limit to main image signature range */\n  uint8_t hashSize;       /* size of each hash in bytes */\n  uint8_t hashType;       /* type of hash (cdHashType* constants) */\n  uint8_t platform;       /* platform identifier; zero if not platform binary */\n  uint8_t pageSize;       /* log2(page size in bytes); 0 => infinite */\n  uint32_t spare2;        /* unused (must be zero) */\n\n  /* Version 0x20100 */\n  uint32_t scatterOffset; /* offset of optional scatter vector */\n\n  /* Version 0x20200 */\n  uint32_t teamOffset; /* offset of optional team identifier */\n\n  /* Version 0x20300 */\n  uint32_t spare3;      /* unused (must be zero) */\n  uint64_t codeLimit64; /* limit to main image signature range, 64 bits */\n\n  /* Version 0x20400 */\n  uint64_t execSegBase;  /* offset of executable segment */\n  uint64_t execSegLimit; /* limit of executable segment */\n  uint64_t execSegFlags; /* executable segment flags */\n};\n\nstatic_assert(sizeof(CS_CodeDirectory) == 88, \"\");\n\nstruct CS_BlobIndex {\n  uint32_t type;   /* type of entry */\n  uint32_t offset; /* offset of entry */\n};\n\nstruct CS_SuperBlob {\n  uint32_t magic;  /* magic number */\n  uint32_t length; /* total length of SuperBlob */\n  uint32_t count;  /* number of index entries following */\n  /* followed by Blobs in no particular order as indicated by index offsets */\n};\n\nenum SecCSDigestAlgorithm {\n  kSecCodeSignatureNoHash = 0,     /* null value */\n  kSecCodeSignatureHashSHA1 = 1,   /* SHA-1 */\n  kSecCodeSignatureHashSHA256 = 2, /* SHA-256 */\n  kSecCodeSignatureHashSHA256Truncated =\n      3,                           /* SHA-256 truncated to first 20 bytes */\n  kSecCodeSignatureHashSHA384 = 4, /* SHA-384 */\n  kSecCodeSignatureHashSHA512 = 5, /* SHA-512 */\n};\n\n} // end namespace MachO\n} // end namespace llvm\n\n#endif\n"}, "16": {"id": 16, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/BinaryFormat/Magic.h", "content": "//===- llvm/BinaryFormat/Magic.h - File magic identification ----*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_BINARYFORMAT_MAGIC_H\n#define LLVM_BINARYFORMAT_MAGIC_H\n\n#include <system_error>\n\nnamespace llvm {\nclass StringRef;\nclass Twine;\n\n/// file_magic - An \"enum class\" enumeration of file types based on magic (the\n/// first N bytes of the file).\nstruct file_magic {\n  enum Impl {\n    unknown = 0,       ///< Unrecognized file\n    bitcode,           ///< Bitcode file\n    archive,           ///< ar style archive file\n    elf,               ///< ELF Unknown type\n    elf_relocatable,   ///< ELF Relocatable object file\n    elf_executable,    ///< ELF Executable image\n    elf_shared_object, ///< ELF dynamically linked shared lib\n    elf_core,          ///< ELF core image\n    macho_object,      ///< Mach-O Object file\n    macho_executable,  ///< Mach-O Executable\n    macho_fixed_virtual_memory_shared_lib,    ///< Mach-O Shared Lib, FVM\n    macho_core,                               ///< Mach-O Core File\n    macho_preload_executable,                 ///< Mach-O Preloaded Executable\n    macho_dynamically_linked_shared_lib,      ///< Mach-O dynlinked shared lib\n    macho_dynamic_linker,                     ///< The Mach-O dynamic linker\n    macho_bundle,                             ///< Mach-O Bundle file\n    macho_dynamically_linked_shared_lib_stub, ///< Mach-O Shared lib stub\n    macho_dsym_companion,                     ///< Mach-O dSYM companion file\n    macho_kext_bundle,                        ///< Mach-O kext bundle file\n    macho_universal_binary,                   ///< Mach-O universal binary\n    minidump,                                 ///< Windows minidump file\n    coff_cl_gl_object,   ///< Microsoft cl.exe's intermediate code file\n    coff_object,         ///< COFF object file\n    coff_import_library, ///< COFF import library\n    pecoff_executable,   ///< PECOFF executable file\n    windows_resource,    ///< Windows compiled resource file (.res)\n    xcoff_object_32,     ///< 32-bit XCOFF object file\n    xcoff_object_64,     ///< 64-bit XCOFF object file\n    wasm_object,         ///< WebAssembly Object file\n    pdb,                 ///< Windows PDB debug info file\n    tapi_file,           ///< Text-based Dynamic Library Stub file\n  };\n\n  bool is_object() const { return V != unknown; }\n\n  file_magic() = default;\n  file_magic(Impl V) : V(V) {}\n  operator Impl() const { return V; }\n\nprivate:\n  Impl V = unknown;\n};\n\n/// Identify the type of a binary file based on how magical it is.\nfile_magic identify_magic(StringRef magic);\n\n/// Get and identify \\a path's type based on its content.\n///\n/// @param path Input path.\n/// @param result Set to the type of file, or file_magic::unknown.\n/// @returns errc::success if result has been successfully set, otherwise a\n///          platform-specific error_code.\nstd::error_code identify_magic(const Twine &path, file_magic &result);\n} // namespace llvm\n\n#endif\n"}, "17": {"id": 17, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/BinaryFormat/Wasm.h", "content": "//===- Wasm.h - Wasm object file format -------------------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// This file defines manifest constants for the wasm object file format.\n// See: https://github.com/WebAssembly/design/blob/master/BinaryEncoding.md\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_BINARYFORMAT_WASM_H\n#define LLVM_BINARYFORMAT_WASM_H\n\n#include \"llvm/ADT/ArrayRef.h\"\n#include \"llvm/ADT/Optional.h\"\n#include \"llvm/ADT/SmallVector.h\"\n#include \"llvm/ADT/StringRef.h\"\n\nnamespace llvm {\nnamespace wasm {\n\n// Object file magic string.\nconst char WasmMagic[] = {'\\0', 'a', 's', 'm'};\n// Wasm binary format version\nconst uint32_t WasmVersion = 0x1;\n// Wasm linking metadata version\nconst uint32_t WasmMetadataVersion = 0x2;\n// Wasm uses a 64k page size\nconst uint32_t WasmPageSize = 65536;\n\nstruct WasmObjectHeader {\n  StringRef Magic;\n  uint32_t Version;\n};\n\nstruct WasmDylinkInfo {\n  uint32_t MemorySize; // Memory size in bytes\n  uint32_t MemoryAlignment;  // P2 alignment of memory\n  uint32_t TableSize;  // Table size in elements\n  uint32_t TableAlignment;  // P2 alignment of table\n  std::vector<StringRef> Needed; // Shared library dependencies\n};\n\nstruct WasmProducerInfo {\n  std::vector<std::pair<std::string, std::string>> Languages;\n  std::vector<std::pair<std::string, std::string>> Tools;\n  std::vector<std::pair<std::string, std::string>> SDKs;\n};\n\nstruct WasmFeatureEntry {\n  uint8_t Prefix;\n  std::string Name;\n};\n\nstruct WasmExport {\n  StringRef Name;\n  uint8_t Kind;\n  uint32_t Index;\n};\n\nstruct WasmLimits {\n  uint8_t Flags;\n  uint64_t Initial;\n  uint64_t Maximum;\n};\n\nstruct WasmTableType {\n  uint8_t ElemType;\n  WasmLimits Limits;\n};\n\nstruct WasmTable {\n  uint32_t Index;\n  WasmTableType Type;\n  StringRef SymbolName; // from the \"linking\" section\n};\n\nstruct WasmInitExpr {\n  uint8_t Opcode;\n  union {\n    int32_t Int32;\n    int64_t Int64;\n    uint32_t Float32;\n    uint64_t Float64;\n    uint32_t Global;\n  } Value;\n};\n\nstruct WasmGlobalType {\n  uint8_t Type;\n  bool Mutable;\n};\n\nstruct WasmGlobal {\n  uint32_t Index;\n  WasmGlobalType Type;\n  WasmInitExpr InitExpr;\n  StringRef SymbolName; // from the \"linking\" section\n};\n\nstruct WasmEventType {\n  // Kind of event. Currently only WASM_EVENT_ATTRIBUTE_EXCEPTION is possible.\n  uint32_t Attribute;\n  uint32_t SigIndex;\n};\n\nstruct WasmEvent {\n  uint32_t Index;\n  WasmEventType Type;\n  StringRef SymbolName; // from the \"linking\" section\n};\n\nstruct WasmImport {\n  StringRef Module;\n  StringRef Field;\n  uint8_t Kind;\n  union {\n    uint32_t SigIndex;\n    WasmGlobalType Global;\n    WasmTableType Table;\n    WasmLimits Memory;\n    WasmEventType Event;\n  };\n};\n\nstruct WasmLocalDecl {\n  uint8_t Type;\n  uint32_t Count;\n};\n\nstruct WasmFunction {\n  uint32_t Index;\n  std::vector<WasmLocalDecl> Locals;\n  ArrayRef<uint8_t> Body;\n  uint32_t CodeSectionOffset;\n  uint32_t Size;\n  uint32_t CodeOffset;  // start of Locals and Body\n  Optional<StringRef> ExportName; // from the \"export\" section\n  StringRef SymbolName; // from the \"linking\" section\n  StringRef DebugName;  // from the \"name\" section\n  uint32_t Comdat;      // from the \"comdat info\" section\n};\n\nstruct WasmDataSegment {\n  uint32_t InitFlags;\n  // Present if InitFlags & WASM_DATA_SEGMENT_HAS_MEMINDEX.\n  uint32_t MemoryIndex;\n  // Present if InitFlags & WASM_DATA_SEGMENT_IS_PASSIVE == 0.\n  WasmInitExpr Offset;\n\n  ArrayRef<uint8_t> Content;\n  StringRef Name; // from the \"segment info\" section\n  uint32_t Alignment;\n  uint32_t LinkerFlags;\n  uint32_t Comdat; // from the \"comdat info\" section\n};\n\nstruct WasmElemSegment {\n  uint32_t Flags;\n  uint32_t TableNumber;\n  uint8_t ElemKind;\n  WasmInitExpr Offset;\n  std::vector<uint32_t> Functions;\n};\n\n// Represents the location of a Wasm data symbol within a WasmDataSegment, as\n// the index of the segment, and the offset and size within the segment.\nstruct WasmDataReference {\n  uint32_t Segment;\n  uint64_t Offset;\n  uint64_t Size;\n};\n\nstruct WasmRelocation {\n  uint8_t Type;    // The type of the relocation.\n  uint32_t Index;  // Index into either symbol or type index space.\n  uint64_t Offset; // Offset from the start of the section.\n  int64_t Addend;  // A value to add to the symbol.\n};\n\nstruct WasmInitFunc {\n  uint32_t Priority;\n  uint32_t Symbol;\n};\n\nstruct WasmSymbolInfo {\n  StringRef Name;\n  uint8_t Kind;\n  uint32_t Flags;\n  // For undefined symbols the module of the import\n  Optional<StringRef> ImportModule;\n  // For undefined symbols the name of the import\n  Optional<StringRef> ImportName;\n  // For symbols to be exported from the final module\n  Optional<StringRef> ExportName;\n  union {\n    // For function, table, or global symbols, the index in function, table, or\n    // global index space.\n    uint32_t ElementIndex;\n    // For a data symbols, the address of the data relative to segment.\n    WasmDataReference DataRef;\n  };\n};\n\nenum class NameType {\n  FUNCTION,\n  GLOBAL,\n  DATA_SEGMENT,\n};\n\nstruct WasmDebugName {\n  NameType Type;\n  uint32_t Index;\n  StringRef Name;\n};\n\nstruct WasmLinkingData {\n  uint32_t Version;\n  std::vector<WasmInitFunc> InitFunctions;\n  std::vector<StringRef> Comdats;\n  std::vector<WasmSymbolInfo> SymbolTable;\n};\n\nenum : unsigned {\n  WASM_SEC_CUSTOM = 0,     // Custom / User-defined section\n  WASM_SEC_TYPE = 1,       // Function signature declarations\n  WASM_SEC_IMPORT = 2,     // Import declarations\n  WASM_SEC_FUNCTION = 3,   // Function declarations\n  WASM_SEC_TABLE = 4,      // Indirect function table and other tables\n  WASM_SEC_MEMORY = 5,     // Memory attributes\n  WASM_SEC_GLOBAL = 6,     // Global declarations\n  WASM_SEC_EXPORT = 7,     // Exports\n  WASM_SEC_START = 8,      // Start function declaration\n  WASM_SEC_ELEM = 9,       // Elements section\n  WASM_SEC_CODE = 10,      // Function bodies (code)\n  WASM_SEC_DATA = 11,      // Data segments\n  WASM_SEC_DATACOUNT = 12, // Data segment count\n  WASM_SEC_EVENT = 13      // Event declarations\n};\n\n// Type immediate encodings used in various contexts.\nenum : unsigned {\n  WASM_TYPE_I32 = 0x7F,\n  WASM_TYPE_I64 = 0x7E,\n  WASM_TYPE_F32 = 0x7D,\n  WASM_TYPE_F64 = 0x7C,\n  WASM_TYPE_V128 = 0x7B,\n  WASM_TYPE_FUNCREF = 0x70,\n  WASM_TYPE_EXTERNREF = 0x6F,\n  WASM_TYPE_FUNC = 0x60,\n  WASM_TYPE_NORESULT = 0x40, // for blocks with no result values\n};\n\n// Kinds of externals (for imports and exports).\nenum : unsigned {\n  WASM_EXTERNAL_FUNCTION = 0x0,\n  WASM_EXTERNAL_TABLE = 0x1,\n  WASM_EXTERNAL_MEMORY = 0x2,\n  WASM_EXTERNAL_GLOBAL = 0x3,\n  WASM_EXTERNAL_EVENT = 0x4,\n};\n\n// Opcodes used in initializer expressions.\nenum : unsigned {\n  WASM_OPCODE_END = 0x0b,\n  WASM_OPCODE_CALL = 0x10,\n  WASM_OPCODE_LOCAL_GET = 0x20,\n  WASM_OPCODE_LOCAL_SET = 0x21,\n  WASM_OPCODE_GLOBAL_GET = 0x23,\n  WASM_OPCODE_GLOBAL_SET = 0x24,\n  WASM_OPCODE_I32_STORE = 0x36,\n  WASM_OPCODE_I64_STORE = 0x37,\n  WASM_OPCODE_I32_CONST = 0x41,\n  WASM_OPCODE_I64_CONST = 0x42,\n  WASM_OPCODE_F32_CONST = 0x43,\n  WASM_OPCODE_F64_CONST = 0x44,\n  WASM_OPCODE_I32_ADD = 0x6a,\n  WASM_OPCODE_I64_ADD = 0x7c,\n  WASM_OPCODE_REF_NULL = 0xd0,\n};\n\n// Opcodes used in synthetic functions.\nenum : unsigned {\n  WASM_OPCODE_IF = 0x04,\n  WASM_OPCODE_ELSE = 0x05,\n  WASM_OPCODE_DROP = 0x1a,\n  WASM_OPCODE_MISC_PREFIX = 0xfc,\n  WASM_OPCODE_MEMORY_INIT = 0x08,\n  WASM_OPCODE_DATA_DROP = 0x09,\n  WASM_OPCODE_ATOMICS_PREFIX = 0xfe,\n  WASM_OPCODE_ATOMIC_NOTIFY = 0x00,\n  WASM_OPCODE_I32_ATOMIC_WAIT = 0x01,\n  WASM_OPCODE_I32_ATOMIC_STORE = 0x17,\n  WASM_OPCODE_I32_RMW_CMPXCHG = 0x48,\n};\n\nenum : unsigned {\n  WASM_LIMITS_FLAG_NONE = 0x0,\n  WASM_LIMITS_FLAG_HAS_MAX = 0x1,\n  WASM_LIMITS_FLAG_IS_SHARED = 0x2,\n  WASM_LIMITS_FLAG_IS_64 = 0x4,\n};\n\nenum : unsigned {\n  WASM_DATA_SEGMENT_IS_PASSIVE = 0x01,\n  WASM_DATA_SEGMENT_HAS_MEMINDEX = 0x02,\n};\n\nenum : unsigned {\n  WASM_ELEM_SEGMENT_IS_PASSIVE = 0x01,\n  WASM_ELEM_SEGMENT_HAS_TABLE_NUMBER = 0x02,\n  WASM_ELEM_SEGMENT_HAS_INIT_EXPRS = 0x04,\n};\nconst unsigned WASM_ELEM_SEGMENT_MASK_HAS_ELEM_KIND = 0x3;\n\n// Feature policy prefixes used in the custom \"target_features\" section\nenum : uint8_t {\n  WASM_FEATURE_PREFIX_USED = '+',\n  WASM_FEATURE_PREFIX_REQUIRED = '=',\n  WASM_FEATURE_PREFIX_DISALLOWED = '-',\n};\n\n// Kind codes used in the custom \"name\" section\nenum : unsigned {\n  WASM_NAMES_FUNCTION = 1,\n  WASM_NAMES_LOCAL = 2,\n  WASM_NAMES_GLOBAL = 7,\n  WASM_NAMES_DATA_SEGMENT = 9,\n};\n\n// Kind codes used in the custom \"linking\" section\nenum : unsigned {\n  WASM_SEGMENT_INFO = 0x5,\n  WASM_INIT_FUNCS = 0x6,\n  WASM_COMDAT_INFO = 0x7,\n  WASM_SYMBOL_TABLE = 0x8,\n};\n\n// Kind codes used in the custom \"linking\" section in the WASM_COMDAT_INFO\nenum : unsigned {\n  WASM_COMDAT_DATA = 0x0,\n  WASM_COMDAT_FUNCTION = 0x1,\n  // GLOBAL, EVENT, and TABLE are in here but LLVM doesn't use them yet.\n  WASM_COMDAT_SECTION = 0x5,\n};\n\n// Kind codes used in the custom \"linking\" section in the WASM_SYMBOL_TABLE\nenum WasmSymbolType : unsigned {\n  WASM_SYMBOL_TYPE_FUNCTION = 0x0,\n  WASM_SYMBOL_TYPE_DATA = 0x1,\n  WASM_SYMBOL_TYPE_GLOBAL = 0x2,\n  WASM_SYMBOL_TYPE_SECTION = 0x3,\n  WASM_SYMBOL_TYPE_EVENT = 0x4,\n  WASM_SYMBOL_TYPE_TABLE = 0x5,\n};\n\n// Kinds of event attributes.\nenum WasmEventAttribute : unsigned {\n  WASM_EVENT_ATTRIBUTE_EXCEPTION = 0x0,\n};\n\nconst unsigned WASM_SYMBOL_BINDING_MASK = 0x3;\nconst unsigned WASM_SYMBOL_VISIBILITY_MASK = 0xc;\n\nconst unsigned WASM_SYMBOL_BINDING_GLOBAL = 0x0;\nconst unsigned WASM_SYMBOL_BINDING_WEAK = 0x1;\nconst unsigned WASM_SYMBOL_BINDING_LOCAL = 0x2;\nconst unsigned WASM_SYMBOL_VISIBILITY_DEFAULT = 0x0;\nconst unsigned WASM_SYMBOL_VISIBILITY_HIDDEN = 0x4;\nconst unsigned WASM_SYMBOL_UNDEFINED = 0x10;\nconst unsigned WASM_SYMBOL_EXPORTED = 0x20;\nconst unsigned WASM_SYMBOL_EXPLICIT_NAME = 0x40;\nconst unsigned WASM_SYMBOL_NO_STRIP = 0x80;\n\n#define WASM_RELOC(name, value) name = value,\n\nenum : unsigned {\n#include \"WasmRelocs.def\"\n};\n\n#undef WASM_RELOC\n\n// Subset of types that a value can have\nenum class ValType {\n  I32 = WASM_TYPE_I32,\n  I64 = WASM_TYPE_I64,\n  F32 = WASM_TYPE_F32,\n  F64 = WASM_TYPE_F64,\n  V128 = WASM_TYPE_V128,\n  FUNCREF = WASM_TYPE_FUNCREF,\n  EXTERNREF = WASM_TYPE_EXTERNREF,\n};\n\nstruct WasmSignature {\n  SmallVector<ValType, 1> Returns;\n  SmallVector<ValType, 4> Params;\n  // Support empty and tombstone instances, needed by DenseMap.\n  enum { Plain, Empty, Tombstone } State = Plain;\n\n  WasmSignature(SmallVector<ValType, 1> &&InReturns,\n                SmallVector<ValType, 4> &&InParams)\n      : Returns(InReturns), Params(InParams) {}\n  WasmSignature() = default;\n};\n\n// Useful comparison operators\ninline bool operator==(const WasmSignature &LHS, const WasmSignature &RHS) {\n  return LHS.State == RHS.State && LHS.Returns == RHS.Returns &&\n         LHS.Params == RHS.Params;\n}\n\ninline bool operator!=(const WasmSignature &LHS, const WasmSignature &RHS) {\n  return !(LHS == RHS);\n}\n\ninline bool operator==(const WasmGlobalType &LHS, const WasmGlobalType &RHS) {\n  return LHS.Type == RHS.Type && LHS.Mutable == RHS.Mutable;\n}\n\ninline bool operator!=(const WasmGlobalType &LHS, const WasmGlobalType &RHS) {\n  return !(LHS == RHS);\n}\n\nstd::string toString(WasmSymbolType type);\nstd::string relocTypetoString(uint32_t type);\nbool relocTypeHasAddend(uint32_t type);\n\n} // end namespace wasm\n} // end namespace llvm\n\n#endif\n"}, "18": {"id": 18, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/DebugInfo/DIContext.h", "content": "//===- DIContext.h ----------------------------------------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// This file defines DIContext, an abstract data structure that holds\n// debug information data.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_DEBUGINFO_DICONTEXT_H\n#define LLVM_DEBUGINFO_DICONTEXT_H\n\n#include \"llvm/ADT/SmallVector.h\"\n#include \"llvm/Object/ObjectFile.h\"\n#include \"llvm/Support/WithColor.h\"\n#include \"llvm/Support/raw_ostream.h\"\n#include <cassert>\n#include <cstdint>\n#include <memory>\n#include <string>\n#include <tuple>\n#include <utility>\n\nnamespace llvm {\n\n/// A format-neutral container for source line information.\nstruct DILineInfo {\n  // DILineInfo contains \"<invalid>\" for function/filename it cannot fetch.\n  static constexpr const char *const BadString = \"<invalid>\";\n  // Use \"??\" instead of \"<invalid>\" to make our output closer to addr2line.\n  static constexpr const char *const Addr2LineBadString = \"??\";\n  std::string FileName;\n  std::string FunctionName;\n  std::string StartFileName;\n  Optional<StringRef> Source;\n  uint32_t Line = 0;\n  uint32_t Column = 0;\n  uint32_t StartLine = 0;\n\n  // DWARF-specific.\n  uint32_t Discriminator = 0;\n\n  DILineInfo()\n      : FileName(BadString), FunctionName(BadString), StartFileName(BadString) {\n  }\n\n  bool operator==(const DILineInfo &RHS) const {\n    return Line == RHS.Line && Column == RHS.Column &&\n           FileName == RHS.FileName && FunctionName == RHS.FunctionName &&\n           StartFileName == RHS.StartFileName && StartLine == RHS.StartLine &&\n           Discriminator == RHS.Discriminator;\n  }\n\n  bool operator!=(const DILineInfo &RHS) const {\n    return !(*this == RHS);\n  }\n\n  bool operator<(const DILineInfo &RHS) const {\n    return std::tie(FileName, FunctionName, StartFileName, Line, Column,\n                    StartLine, Discriminator) <\n           std::tie(RHS.FileName, RHS.FunctionName, RHS.StartFileName, RHS.Line,\n                    RHS.Column, RHS.StartLine, RHS.Discriminator);\n  }\n\n  explicit operator bool() const { return *this != DILineInfo(); }\n\n  void dump(raw_ostream &OS) {\n    OS << \"Line info: \";\n    if (FileName != BadString)\n      OS << \"file '\" << FileName << \"', \";\n    if (FunctionName != BadString)\n      OS << \"function '\" << FunctionName << \"', \";\n    OS << \"line \" << Line << \", \";\n    OS << \"column \" << Column << \", \";\n    if (StartFileName != BadString)\n      OS << \"start file '\" << StartFileName << \"', \";\n    OS << \"start line \" << StartLine << '\\n';\n  }\n};\n\nusing DILineInfoTable = SmallVector<std::pair<uint64_t, DILineInfo>, 16>;\n\n/// A format-neutral container for inlined code description.\nclass DIInliningInfo {\n  SmallVector<DILineInfo, 4> Frames;\n\npublic:\n  DIInliningInfo() = default;\n\n  const DILineInfo & getFrame(unsigned Index) const {\n    assert(Index < Frames.size());\n    return Frames[Index];\n  }\n\n  DILineInfo *getMutableFrame(unsigned Index) {\n    assert(Index < Frames.size());\n    return &Frames[Index];\n  }\n\n  uint32_t getNumberOfFrames() const {\n    return Frames.size();\n  }\n\n  void addFrame(const DILineInfo &Frame) {\n    Frames.push_back(Frame);\n  }\n\n  void resize(unsigned i) {\n    Frames.resize(i);\n  }\n};\n\n/// Container for description of a global variable.\nstruct DIGlobal {\n  std::string Name;\n  uint64_t Start = 0;\n  uint64_t Size = 0;\n\n  DIGlobal() : Name(DILineInfo::BadString) {}\n};\n\nstruct DILocal {\n  std::string FunctionName;\n  std::string Name;\n  std::string DeclFile;\n  uint64_t DeclLine = 0;\n  Optional<int64_t> FrameOffset;\n  Optional<uint64_t> Size;\n  Optional<uint64_t> TagOffset;\n};\n\n/// A DINameKind is passed to name search methods to specify a\n/// preference regarding the type of name resolution the caller wants.\nenum class DINameKind { None, ShortName, LinkageName };\n\n/// Controls which fields of DILineInfo container should be filled\n/// with data.\nstruct DILineInfoSpecifier {\n  enum class FileLineInfoKind {\n    None,\n    // RawValue is whatever the compiler stored in the filename table.  Could be\n    // a full path, could be something else.\n    RawValue,\n    BaseNameOnly,\n    // Relative to the compilation directory.\n    RelativeFilePath,\n    AbsoluteFilePath\n  };\n  using FunctionNameKind = DINameKind;\n\n  FileLineInfoKind FLIKind;\n  FunctionNameKind FNKind;\n\n  DILineInfoSpecifier(FileLineInfoKind FLIKind = FileLineInfoKind::RawValue,\n                      FunctionNameKind FNKind = FunctionNameKind::None)\n      : FLIKind(FLIKind), FNKind(FNKind) {}\n};\n\n/// This is just a helper to programmatically construct DIDumpType.\nenum DIDumpTypeCounter {\n#define HANDLE_DWARF_SECTION(ENUM_NAME, ELF_NAME, CMDLINE_NAME, OPTION)        \\\n  DIDT_ID_##ENUM_NAME,\n#include \"llvm/BinaryFormat/Dwarf.def\"\n#undef HANDLE_DWARF_SECTION\n  DIDT_ID_UUID,\n  DIDT_ID_Count\n};\nstatic_assert(DIDT_ID_Count <= 32, \"section types overflow storage\");\n\n/// Selects which debug sections get dumped.\nenum DIDumpType : unsigned {\n  DIDT_Null,\n  DIDT_All             = ~0U,\n#define HANDLE_DWARF_SECTION(ENUM_NAME, ELF_NAME, CMDLINE_NAME, OPTION)        \\\n  DIDT_##ENUM_NAME = 1U << DIDT_ID_##ENUM_NAME,\n#include \"llvm/BinaryFormat/Dwarf.def\"\n#undef HANDLE_DWARF_SECTION\n  DIDT_UUID = 1 << DIDT_ID_UUID,\n};\n\n/// Container for dump options that control which debug information will be\n/// dumped.\nstruct DIDumpOptions {\n  unsigned DumpType = DIDT_All;\n  unsigned ChildRecurseDepth = -1U;\n  unsigned ParentRecurseDepth = -1U;\n  uint16_t Version = 0; // DWARF version to assume when extracting.\n  uint8_t AddrSize = 4; // Address byte size to assume when extracting.\n  bool ShowAddresses = true;\n  bool ShowChildren = false;\n  bool ShowParents = false;\n  bool ShowForm = false;\n  bool SummarizeTypes = false;\n  bool Verbose = false;\n  bool DisplayRawContents = false;\n\n  /// Return default option set for printing a single DIE without children.\n  static DIDumpOptions getForSingleDIE() {\n    DIDumpOptions Opts;\n    Opts.ChildRecurseDepth = 0;\n    Opts.ParentRecurseDepth = 0;\n    return Opts;\n  }\n\n  /// Return the options with RecurseDepth set to 0 unless explicitly required.\n  DIDumpOptions noImplicitRecursion() const {\n    DIDumpOptions Opts = *this;\n    if (ChildRecurseDepth == -1U && !ShowChildren)\n      Opts.ChildRecurseDepth = 0;\n    if (ParentRecurseDepth == -1U && !ShowParents)\n      Opts.ParentRecurseDepth = 0;\n    return Opts;\n  }\n\n  std::function<void(Error)> RecoverableErrorHandler =\n      WithColor::defaultErrorHandler;\n  std::function<void(Error)> WarningHandler = WithColor::defaultWarningHandler;\n};\n\nclass DIContext {\npublic:\n  enum DIContextKind {\n    CK_DWARF,\n    CK_PDB\n  };\n\n  DIContext(DIContextKind K) : Kind(K) {}\n  virtual ~DIContext() = default;\n\n  DIContextKind getKind() const { return Kind; }\n\n  virtual void dump(raw_ostream &OS, DIDumpOptions DumpOpts) = 0;\n\n  virtual bool verify(raw_ostream &OS, DIDumpOptions DumpOpts = {}) {\n    // No verifier? Just say things went well.\n    return true;\n  }\n\n  virtual DILineInfo getLineInfoForAddress(\n      object::SectionedAddress Address,\n      DILineInfoSpecifier Specifier = DILineInfoSpecifier()) = 0;\n  virtual DILineInfoTable getLineInfoForAddressRange(\n      object::SectionedAddress Address, uint64_t Size,\n      DILineInfoSpecifier Specifier = DILineInfoSpecifier()) = 0;\n  virtual DIInliningInfo getInliningInfoForAddress(\n      object::SectionedAddress Address,\n      DILineInfoSpecifier Specifier = DILineInfoSpecifier()) = 0;\n\n  virtual std::vector<DILocal>\n  getLocalsForAddress(object::SectionedAddress Address) = 0;\n\nprivate:\n  const DIContextKind Kind;\n};\n\n/// An inferface for inquiring the load address of a loaded object file\n/// to be used by the DIContext implementations when applying relocations\n/// on the fly.\nclass LoadedObjectInfo {\nprotected:\n  LoadedObjectInfo() = default;\n  LoadedObjectInfo(const LoadedObjectInfo &) = default;\n\npublic:\n  virtual ~LoadedObjectInfo() = default;\n\n  /// Obtain the Load Address of a section by SectionRef.\n  ///\n  /// Calculate the address of the given section.\n  /// The section need not be present in the local address space. The addresses\n  /// need to be consistent with the addresses used to query the DIContext and\n  /// the output of this function should be deterministic, i.e. repeated calls\n  /// with the same Sec should give the same address.\n  virtual uint64_t getSectionLoadAddress(const object::SectionRef &Sec) const {\n    return 0;\n  }\n\n  /// If conveniently available, return the content of the given Section.\n  ///\n  /// When the section is available in the local address space, in relocated\n  /// (loaded) form, e.g. because it was relocated by a JIT for execution, this\n  /// function should provide the contents of said section in `Data`. If the\n  /// loaded section is not available, or the cost of retrieving it would be\n  /// prohibitive, this function should return false. In that case, relocations\n  /// will be read from the local (unrelocated) object file and applied on the\n  /// fly. Note that this method is used purely for optimzation purposes in the\n  /// common case of JITting in the local address space, so returning false\n  /// should always be correct.\n  virtual bool getLoadedSectionContents(const object::SectionRef &Sec,\n                                        StringRef &Data) const {\n    return false;\n  }\n\n  // FIXME: This is untested and unused anywhere in the LLVM project, it's\n  // used/needed by Julia (an external project). It should have some coverage\n  // (at least tests, but ideally example functionality).\n  /// Obtain a copy of this LoadedObjectInfo.\n  virtual std::unique_ptr<LoadedObjectInfo> clone() const = 0;\n};\n\ntemplate <typename Derived, typename Base = LoadedObjectInfo>\nstruct LoadedObjectInfoHelper : Base {\nprotected:\n  LoadedObjectInfoHelper(const LoadedObjectInfoHelper &) = default;\n  LoadedObjectInfoHelper() = default;\n\npublic:\n  template <typename... Ts>\n  LoadedObjectInfoHelper(Ts &&... Args) : Base(std::forward<Ts>(Args)...) {}\n\n  std::unique_ptr<llvm::LoadedObjectInfo> clone() const override {\n    return std::make_unique<Derived>(static_cast<const Derived &>(*this));\n  }\n};\n\n} // end namespace llvm\n\n#endif // LLVM_DEBUGINFO_DICONTEXT_H\n"}, "19": {"id": 19, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/DebugInfo/DWARF/DWARFAbbreviationDeclaration.h", "content": "//===- DWARFAbbreviationDeclaration.h ---------------------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_DEBUGINFO_DWARF_DWARFABBREVIATIONDECLARATION_H\n#define LLVM_DEBUGINFO_DWARF_DWARFABBREVIATIONDECLARATION_H\n\n#include \"llvm/ADT/Optional.h\"\n#include \"llvm/ADT/SmallVector.h\"\n#include \"llvm/ADT/iterator_range.h\"\n#include \"llvm/BinaryFormat/Dwarf.h\"\n#include \"llvm/Support/DataExtractor.h\"\n#include <cassert>\n#include <cstddef>\n#include <cstdint>\n\nnamespace llvm {\n\nclass DWARFFormValue;\nclass DWARFUnit;\nclass raw_ostream;\n\nclass DWARFAbbreviationDeclaration {\npublic:\n  struct AttributeSpec {\n    AttributeSpec(dwarf::Attribute A, dwarf::Form F, int64_t Value)\n        : Attr(A), Form(F), Value(Value) {\n      assert(isImplicitConst());\n    }\n    AttributeSpec(dwarf::Attribute A, dwarf::Form F, Optional<uint8_t> ByteSize)\n        : Attr(A), Form(F) {\n      assert(!isImplicitConst());\n      this->ByteSize.HasByteSize = ByteSize.hasValue();\n      if (this->ByteSize.HasByteSize)\n        this->ByteSize.ByteSize = *ByteSize;\n    }\n\n    dwarf::Attribute Attr;\n    dwarf::Form Form;\n\n  private:\n    /// The following field is used for ByteSize for non-implicit_const\n    /// attributes and as value for implicit_const ones, indicated by\n    /// Form == DW_FORM_implicit_const.\n    /// The following cases are distinguished:\n    /// * Form != DW_FORM_implicit_const and HasByteSize is true:\n    ///     ByteSize contains the fixed size in bytes for the Form in this\n    ///     object.\n    /// * Form != DW_FORM_implicit_const and HasByteSize is false:\n    ///     byte size of Form either varies according to the DWARFUnit\n    ///     that it is contained in or the value size varies and must be\n    ///     decoded from the debug information in order to determine its size.\n    /// * Form == DW_FORM_implicit_const:\n    ///     Value contains value for the implicit_const attribute.\n    struct ByteSizeStorage {\n      bool HasByteSize;\n      uint8_t ByteSize;\n    };\n    union {\n      ByteSizeStorage ByteSize;\n      int64_t Value;\n    };\n\n  public:\n    bool isImplicitConst() const {\n      return Form == dwarf::DW_FORM_implicit_const;\n    }\n\n    int64_t getImplicitConstValue() const {\n      assert(isImplicitConst());\n      return Value;\n    }\n\n    /// Get the fixed byte size of this Form if possible. This function might\n    /// use the DWARFUnit to calculate the size of the Form, like for\n    /// DW_AT_address and DW_AT_ref_addr, so this isn't just an accessor for\n    /// the ByteSize member.\n    Optional<int64_t> getByteSize(const DWARFUnit &U) const;\n  };\n  using AttributeSpecVector = SmallVector<AttributeSpec, 8>;\n\n  DWARFAbbreviationDeclaration();\n\n  uint32_t getCode() const { return Code; }\n  uint8_t getCodeByteSize() const { return CodeByteSize; }\n  dwarf::Tag getTag() const { return Tag; }\n  bool hasChildren() const { return HasChildren; }\n\n  using attr_iterator_range =\n      iterator_range<AttributeSpecVector::const_iterator>;\n\n  attr_iterator_range attributes() const {\n    return attr_iterator_range(AttributeSpecs.begin(), AttributeSpecs.end());\n  }\n\n  dwarf::Form getFormByIndex(uint32_t idx) const {\n    assert(idx < AttributeSpecs.size());\n    return AttributeSpecs[idx].Form;\n  }\n\n  size_t getNumAttributes() const {\n    return AttributeSpecs.size();\n  }\n\n  dwarf::Attribute getAttrByIndex(uint32_t idx) const {\n    assert(idx < AttributeSpecs.size());\n    return AttributeSpecs[idx].Attr;\n  }\n\n  bool getAttrIsImplicitConstByIndex(uint32_t idx) const {\n    assert(idx < AttributeSpecs.size());\n    return AttributeSpecs[idx].isImplicitConst();\n  }\n\n  int64_t getAttrImplicitConstValueByIndex(uint32_t idx) const {\n    assert(idx < AttributeSpecs.size());\n    return AttributeSpecs[idx].getImplicitConstValue();\n  }\n\n  /// Get the index of the specified attribute.\n  ///\n  /// Searches the this abbreviation declaration for the index of the specified\n  /// attribute.\n  ///\n  /// \\param attr DWARF attribute to search for.\n  /// \\returns Optional index of the attribute if found, None otherwise.\n  Optional<uint32_t> findAttributeIndex(dwarf::Attribute attr) const;\n\n  /// Extract a DWARF form value from a DIE specified by DIE offset.\n  ///\n  /// Extract an attribute value for a DWARFUnit given the DIE offset and the\n  /// attribute.\n  ///\n  /// \\param DIEOffset the DIE offset that points to the ULEB128 abbreviation\n  /// code in the .debug_info data.\n  /// \\param Attr DWARF attribute to search for.\n  /// \\param U the DWARFUnit the contains the DIE.\n  /// \\returns Optional DWARF form value if the attribute was extracted.\n  Optional<DWARFFormValue> getAttributeValue(const uint64_t DIEOffset,\n                                             const dwarf::Attribute Attr,\n                                             const DWARFUnit &U) const;\n\n  bool extract(DataExtractor Data, uint64_t* OffsetPtr);\n  void dump(raw_ostream &OS) const;\n\n  // Return an optional byte size of all attribute data in this abbreviation\n  // if a constant byte size can be calculated given a DWARFUnit. This allows\n  // DWARF parsing to be faster as many DWARF DIEs have a fixed byte size.\n  Optional<size_t> getFixedAttributesByteSize(const DWARFUnit &U) const;\n\nprivate:\n  void clear();\n\n  /// A helper structure that can quickly determine the size in bytes of an\n  /// abbreviation declaration.\n  struct FixedSizeInfo {\n    /// The fixed byte size for fixed size forms.\n    uint16_t NumBytes = 0;\n    /// Number of DW_FORM_address forms in this abbrevation declaration.\n    uint8_t NumAddrs = 0;\n    /// Number of DW_FORM_ref_addr forms in this abbrevation declaration.\n    uint8_t NumRefAddrs = 0;\n    /// Number of 4 byte in DWARF32 and 8 byte in DWARF64 forms.\n    uint8_t NumDwarfOffsets = 0;\n\n    FixedSizeInfo() = default;\n\n    /// Calculate the fixed size in bytes given a DWARFUnit.\n    ///\n    /// \\param U the DWARFUnit to use when determing the byte size.\n    /// \\returns the size in bytes for all attribute data in this abbreviation.\n    /// The returned size does not include bytes for the  ULEB128 abbreviation\n    /// code\n    size_t getByteSize(const DWARFUnit &U) const;\n  };\n\n  uint32_t Code;\n  dwarf::Tag Tag;\n  uint8_t CodeByteSize;\n  bool HasChildren;\n  AttributeSpecVector AttributeSpecs;\n  /// If this abbreviation has a fixed byte size then FixedAttributeSize member\n  /// variable below will have a value.\n  Optional<FixedSizeInfo> FixedAttributeSize;\n};\n\n} // end namespace llvm\n\n#endif // LLVM_DEBUGINFO_DWARF_DWARFABBREVIATIONDECLARATION_H\n"}, "20": {"id": 20, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/DebugInfo/DWARF/DWARFAddressRange.h", "content": "//===- DWARFAddressRange.h --------------------------------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_DEBUGINFO_DWARF_DWARFADDRESSRANGE_H\n#define LLVM_DEBUGINFO_DWARF_DWARFADDRESSRANGE_H\n\n#include \"llvm/DebugInfo/DIContext.h\"\n#include <cstdint>\n#include <tuple>\n#include <vector>\n\nnamespace llvm {\n\nclass raw_ostream;\nclass DWARFObject;\n\nstruct DWARFAddressRange {\n  uint64_t LowPC;\n  uint64_t HighPC;\n  uint64_t SectionIndex;\n\n  DWARFAddressRange() = default;\n\n  /// Used for unit testing.\n  DWARFAddressRange(\n      uint64_t LowPC, uint64_t HighPC,\n      uint64_t SectionIndex = object::SectionedAddress::UndefSection)\n      : LowPC(LowPC), HighPC(HighPC), SectionIndex(SectionIndex) {}\n\n  /// Returns true if LowPC is smaller or equal to HighPC. This accounts for\n  /// dead-stripped ranges.\n  bool valid() const { return LowPC <= HighPC; }\n\n  /// Returns true if [LowPC, HighPC) intersects with [RHS.LowPC, RHS.HighPC).\n  bool intersects(const DWARFAddressRange &RHS) const {\n    assert(valid() && RHS.valid());\n    // Empty ranges can't intersect.\n    if (LowPC == HighPC || RHS.LowPC == RHS.HighPC)\n      return false;\n    return LowPC < RHS.HighPC && RHS.LowPC < HighPC;\n  }\n\n  /// Union two address ranges if they intersect.\n  ///\n  /// This function will union two address ranges if they intersect by\n  /// modifying this range to be the union of both ranges. If the two ranges\n  /// don't intersect this range will be left alone.\n  ///\n  /// \\param RHS Another address range to combine with.\n  ///\n  /// \\returns false if the ranges don't intersect, true if they do and the\n  /// ranges were combined.\n  bool merge(const DWARFAddressRange &RHS) {\n    if (!intersects(RHS))\n      return false;\n    LowPC = std::min<uint64_t>(LowPC, RHS.LowPC);\n    HighPC = std::max<uint64_t>(HighPC, RHS.HighPC);\n    return true;\n  }\n\n  void dump(raw_ostream &OS, uint32_t AddressSize, DIDumpOptions DumpOpts = {},\n            const DWARFObject *Obj = nullptr) const;\n};\n\ninline bool operator<(const DWARFAddressRange &LHS,\n                      const DWARFAddressRange &RHS) {\n  return std::tie(LHS.LowPC, LHS.HighPC) < std::tie(RHS.LowPC, RHS.HighPC);\n}\n\ninline bool operator==(const DWARFAddressRange &LHS,\n                       const DWARFAddressRange &RHS) {\n  return std::tie(LHS.LowPC, LHS.HighPC) == std::tie(RHS.LowPC, RHS.HighPC);\n}\n\nraw_ostream &operator<<(raw_ostream &OS, const DWARFAddressRange &R);\n\n/// DWARFAddressRangesVector - represents a set of absolute address ranges.\nusing DWARFAddressRangesVector = std::vector<DWARFAddressRange>;\n\n} // end namespace llvm\n\n#endif // LLVM_DEBUGINFO_DWARF_DWARFADDRESSRANGE_H\n"}, "21": {"id": 21, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/DebugInfo/DWARF/DWARFDataExtractor.h", "content": "//===- DWARFDataExtractor.h -------------------------------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_DEBUGINFO_DWARF_DWARFDATAEXTRACTOR_H\n#define LLVM_DEBUGINFO_DWARF_DWARFDATAEXTRACTOR_H\n\n#include \"llvm/BinaryFormat/Dwarf.h\"\n#include \"llvm/DebugInfo/DWARF/DWARFSection.h\"\n#include \"llvm/Support/DataExtractor.h\"\n\nnamespace llvm {\nclass DWARFObject;\n\n/// A DataExtractor (typically for an in-memory copy of an object-file section)\n/// plus a relocation map for that section, if there is one.\nclass DWARFDataExtractor : public DataExtractor {\n  const DWARFObject *Obj = nullptr;\n  const DWARFSection *Section = nullptr;\n\npublic:\n  /// Constructor for the normal case of extracting data from a DWARF section.\n  /// The DWARFSection's lifetime must be at least as long as the extractor's.\n  DWARFDataExtractor(const DWARFObject &Obj, const DWARFSection &Section,\n                     bool IsLittleEndian, uint8_t AddressSize)\n      : DataExtractor(Section.Data, IsLittleEndian, AddressSize), Obj(&Obj),\n        Section(&Section) {}\n\n  /// Constructor for cases when there are no relocations.\n  DWARFDataExtractor(StringRef Data, bool IsLittleEndian, uint8_t AddressSize)\n    : DataExtractor(Data, IsLittleEndian, AddressSize) {}\n  DWARFDataExtractor(ArrayRef<uint8_t> Data, bool IsLittleEndian,\n                     uint8_t AddressSize)\n      : DataExtractor(\n            StringRef(reinterpret_cast<const char *>(Data.data()), Data.size()),\n            IsLittleEndian, AddressSize) {}\n\n  /// Truncating constructor\n  DWARFDataExtractor(const DWARFDataExtractor &Other, size_t Length)\n      : DataExtractor(Other.getData().substr(0, Length), Other.isLittleEndian(),\n                      Other.getAddressSize()),\n        Obj(Other.Obj), Section(Other.Section) {}\n\n  /// Extracts the DWARF \"initial length\" field, which can either be a 32-bit\n  /// value smaller than 0xfffffff0, or the value 0xffffffff followed by a\n  /// 64-bit length. Returns the actual length, and the DWARF format which is\n  /// encoded in the field. In case of errors, it returns {0, DWARF32} and\n  /// leaves the offset unchanged.\n  std::pair<uint64_t, dwarf::DwarfFormat>\n  getInitialLength(uint64_t *Off, Error *Err = nullptr) const;\n\n  std::pair<uint64_t, dwarf::DwarfFormat> getInitialLength(Cursor &C) const {\n    return getInitialLength(&getOffset(C), &getError(C));\n  }\n\n  /// Extracts a value and applies a relocation to the result if\n  /// one exists for the given offset.\n  uint64_t getRelocatedValue(uint32_t Size, uint64_t *Off,\n                             uint64_t *SectionIndex = nullptr,\n                             Error *Err = nullptr) const;\n  uint64_t getRelocatedValue(Cursor &C, uint32_t Size,\n                             uint64_t *SectionIndex = nullptr) const {\n    return getRelocatedValue(Size, &getOffset(C), SectionIndex, &getError(C));\n  }\n\n  /// Extracts an address-sized value and applies a relocation to the result if\n  /// one exists for the given offset.\n  uint64_t getRelocatedAddress(uint64_t *Off, uint64_t *SecIx = nullptr) const {\n    return getRelocatedValue(getAddressSize(), Off, SecIx);\n  }\n  uint64_t getRelocatedAddress(Cursor &C, uint64_t *SecIx = nullptr) const {\n    return getRelocatedValue(getAddressSize(), &getOffset(C), SecIx,\n                             &getError(C));\n  }\n\n  /// Extracts a DWARF-encoded pointer in \\p Offset using \\p Encoding.\n  /// There is a DWARF encoding that uses a PC-relative adjustment.\n  /// For these values, \\p AbsPosOffset is used to fix them, which should\n  /// reflect the absolute address of this pointer.\n  Optional<uint64_t> getEncodedPointer(uint64_t *Offset, uint8_t Encoding,\n                                       uint64_t AbsPosOffset = 0) const;\n};\n\n} // end namespace llvm\n\n#endif // LLVM_DEBUGINFO_DWARF_DWARFDATAEXTRACTOR_H\n"}, "22": {"id": 22, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/DebugInfo/DWARF/DWARFDebugLoc.h", "content": "//===- DWARFDebugLoc.h ------------------------------------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_DEBUGINFO_DWARF_DWARFDEBUGLOC_H\n#define LLVM_DEBUGINFO_DWARF_DWARFDEBUGLOC_H\n\n#include \"llvm/ADT/Optional.h\"\n#include \"llvm/ADT/SmallVector.h\"\n#include \"llvm/DebugInfo/DIContext.h\"\n#include \"llvm/DebugInfo/DWARF/DWARFDataExtractor.h\"\n#include \"llvm/DebugInfo/DWARF/DWARFLocationExpression.h\"\n#include \"llvm/DebugInfo/DWARF/DWARFRelocMap.h\"\n#include <cstdint>\n\nnamespace llvm {\nclass DWARFUnit;\nclass MCRegisterInfo;\nclass raw_ostream;\n\n/// A single location within a location list. Entries are stored in the DWARF5\n/// form even if they originally come from a DWARF<=4 location list.\nstruct DWARFLocationEntry {\n  /// The entry kind (DW_LLE_***).\n  uint8_t Kind;\n\n  /// The first value of the location entry (if applicable).\n  uint64_t Value0;\n\n  /// The second value of the location entry (if applicable).\n  uint64_t Value1;\n\n  /// The index of the section this entry is relative to (if applicable).\n  uint64_t SectionIndex;\n\n  /// The location expression itself (if applicable).\n  SmallVector<uint8_t, 4> Loc;\n};\n\n/// An abstract base class for various kinds of location tables (.debug_loc,\n/// .debug_loclists, and their dwo variants).\nclass DWARFLocationTable {\npublic:\n  DWARFLocationTable(DWARFDataExtractor Data) : Data(std::move(Data)) {}\n  virtual ~DWARFLocationTable() = default;\n\n  /// Call the user-provided callback for each entry (including the end-of-list\n  /// entry) in the location list starting at \\p Offset. The callback can return\n  /// false to terminate the iteration early. Returns an error if it was unable\n  /// to parse the entire location list correctly. Upon successful termination\n  /// \\p Offset will be updated point past the end of the list.\n  virtual Error visitLocationList(\n      uint64_t *Offset,\n      function_ref<bool(const DWARFLocationEntry &)> Callback) const = 0;\n\n  /// Dump the location list at the given \\p Offset. The function returns true\n  /// iff it has successfully reched the end of the list. This means that one\n  /// can attempt to parse another list after the current one (\\p Offset will be\n  /// updated to point past the end of the current list).\n  bool dumpLocationList(uint64_t *Offset, raw_ostream &OS,\n                        Optional<object::SectionedAddress> BaseAddr,\n                        const MCRegisterInfo *MRI, const DWARFObject &Obj,\n                        DWARFUnit *U, DIDumpOptions DumpOpts,\n                        unsigned Indent) const;\n\n  Error visitAbsoluteLocationList(\n      uint64_t Offset, Optional<object::SectionedAddress> BaseAddr,\n      std::function<Optional<object::SectionedAddress>(uint32_t)> LookupAddr,\n      function_ref<bool(Expected<DWARFLocationExpression>)> Callback) const;\n\n  const DWARFDataExtractor &getData() { return Data; }\n\nprotected:\n  DWARFDataExtractor Data;\n\n  virtual void dumpRawEntry(const DWARFLocationEntry &Entry, raw_ostream &OS,\n                            unsigned Indent, DIDumpOptions DumpOpts,\n                            const DWARFObject &Obj) const = 0;\n};\n\nclass DWARFDebugLoc final : public DWARFLocationTable {\npublic:\n  /// A list of locations that contain one variable.\n  struct LocationList {\n    /// The beginning offset where this location list is stored in the debug_loc\n    /// section.\n    uint64_t Offset;\n    /// All the locations in which the variable is stored.\n    SmallVector<DWARFLocationEntry, 2> Entries;\n  };\n\nprivate:\n  using LocationLists = SmallVector<LocationList, 4>;\n\n  /// A list of all the variables in the debug_loc section, each one describing\n  /// the locations in which the variable is stored.\n  LocationLists Locations;\n\npublic:\n  DWARFDebugLoc(DWARFDataExtractor Data)\n      : DWARFLocationTable(std::move(Data)) {}\n\n  /// Print the location lists found within the debug_loc section.\n  void dump(raw_ostream &OS, const MCRegisterInfo *RegInfo,\n            const DWARFObject &Obj, DIDumpOptions DumpOpts,\n            Optional<uint64_t> Offset) const;\n\n  Error visitLocationList(\n      uint64_t *Offset,\n      function_ref<bool(const DWARFLocationEntry &)> Callback) const override;\n\nprotected:\n  void dumpRawEntry(const DWARFLocationEntry &Entry, raw_ostream &OS,\n                    unsigned Indent, DIDumpOptions DumpOpts,\n                    const DWARFObject &Obj) const override;\n};\n\nclass DWARFDebugLoclists final : public DWARFLocationTable {\npublic:\n  DWARFDebugLoclists(DWARFDataExtractor Data, uint16_t Version)\n      : DWARFLocationTable(std::move(Data)), Version(Version) {}\n\n  Error visitLocationList(\n      uint64_t *Offset,\n      function_ref<bool(const DWARFLocationEntry &)> Callback) const override;\n\n  /// Dump all location lists within the given range.\n  void dumpRange(uint64_t StartOffset, uint64_t Size, raw_ostream &OS,\n                 const MCRegisterInfo *MRI, const DWARFObject &Obj,\n                 DIDumpOptions DumpOpts);\n\nprotected:\n  void dumpRawEntry(const DWARFLocationEntry &Entry, raw_ostream &OS,\n                    unsigned Indent, DIDumpOptions DumpOpts,\n                    const DWARFObject &Obj) const override;\n\nprivate:\n  uint16_t Version;\n};\n\n} // end namespace llvm\n\n#endif // LLVM_DEBUGINFO_DWARF_DWARFDEBUGLOC_H\n"}, "23": {"id": 23, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/DebugInfo/DWARF/DWARFDebugRangeList.h", "content": "//===- DWARFDebugRangeList.h ------------------------------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_DEBUGINFO_DWARF_DWARFDEBUGRANGELIST_H\n#define LLVM_DEBUGINFO_DWARF_DWARFDEBUGRANGELIST_H\n\n#include \"llvm/DebugInfo/DWARF/DWARFAddressRange.h\"\n#include \"llvm/DebugInfo/DWARF/DWARFDataExtractor.h\"\n#include <cassert>\n#include <cstdint>\n#include <vector>\n\nnamespace llvm {\n\nclass raw_ostream;\n\nclass DWARFDebugRangeList {\npublic:\n  struct RangeListEntry {\n    /// A beginning address offset. This address offset has the size of an\n    /// address and is relative to the applicable base address of the\n    /// compilation unit referencing this range list. It marks the beginning\n    /// of an address range.\n    uint64_t StartAddress;\n    /// An ending address offset. This address offset again has the size of\n    /// an address and is relative to the applicable base address of the\n    /// compilation unit referencing this range list. It marks the first\n    /// address past the end of the address range. The ending address must\n    /// be greater than or equal to the beginning address.\n    uint64_t EndAddress;\n    /// A section index this range belongs to.\n    uint64_t SectionIndex;\n\n    /// The end of any given range list is marked by an end of list entry,\n    /// which consists of a 0 for the beginning address offset\n    /// and a 0 for the ending address offset.\n    bool isEndOfListEntry() const {\n      return (StartAddress == 0) && (EndAddress == 0);\n    }\n\n    /// A base address selection entry consists of:\n    /// 1. The value of the largest representable address offset\n    /// (for example, 0xffffffff when the size of an address is 32 bits).\n    /// 2. An address, which defines the appropriate base address for\n    /// use in interpreting the beginning and ending address offsets of\n    /// subsequent entries of the location list.\n    bool isBaseAddressSelectionEntry(uint8_t AddressSize) const {\n      assert(AddressSize == 4 || AddressSize == 8);\n      if (AddressSize == 4)\n        return StartAddress == -1U;\n      return StartAddress == -1ULL;\n    }\n  };\n\nprivate:\n  /// Offset in .debug_ranges section.\n  uint64_t Offset;\n  uint8_t AddressSize;\n  std::vector<RangeListEntry> Entries;\n\npublic:\n  DWARFDebugRangeList() { clear(); }\n\n  void clear();\n  void dump(raw_ostream &OS) const;\n  Error extract(const DWARFDataExtractor &data, uint64_t *offset_ptr);\n  const std::vector<RangeListEntry> &getEntries() { return Entries; }\n\n  /// getAbsoluteRanges - Returns absolute address ranges defined by this range\n  /// list. Has to be passed base address of the compile unit referencing this\n  /// range list.\n  DWARFAddressRangesVector\n  getAbsoluteRanges(llvm::Optional<object::SectionedAddress> BaseAddr) const;\n};\n\n} // end namespace llvm\n\n#endif // LLVM_DEBUGINFO_DWARF_DWARFDEBUGRANGELIST_H\n"}, "24": {"id": 24, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/DebugInfo/DWARF/DWARFDebugRnglists.h", "content": "//===- DWARFDebugRnglists.h -------------------------------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_DEBUGINFO_DWARF_DWARFDEBUGRNGLISTS_H\n#define LLVM_DEBUGINFO_DWARF_DWARFDEBUGRNGLISTS_H\n\n#include \"llvm/ADT/Optional.h\"\n#include \"llvm/ADT/STLExtras.h\"\n#include \"llvm/BinaryFormat/Dwarf.h\"\n#include \"llvm/DebugInfo/DIContext.h\"\n#include \"llvm/DebugInfo/DWARF/DWARFDataExtractor.h\"\n#include \"llvm/DebugInfo/DWARF/DWARFDebugRangeList.h\"\n#include \"llvm/DebugInfo/DWARF/DWARFListTable.h\"\n#include <cstdint>\n\nnamespace llvm {\n\nclass Error;\nclass raw_ostream;\nclass DWARFUnit;\n\n/// A class representing a single range list entry.\nstruct RangeListEntry : public DWARFListEntryBase {\n  /// The values making up the range list entry. Most represent a range with\n  /// a start and end address or a start address and a length. Others are\n  /// single value base addresses or end-of-list with no values. The unneeded\n  /// values are semantically undefined, but initialized to 0.\n  uint64_t Value0;\n  uint64_t Value1;\n\n  Error extract(DWARFDataExtractor Data, uint64_t *OffsetPtr);\n  void dump(raw_ostream &OS, uint8_t AddrSize, uint8_t MaxEncodingStringLength,\n            uint64_t &CurrentBase, DIDumpOptions DumpOpts,\n            llvm::function_ref<Optional<object::SectionedAddress>(uint32_t)>\n                LookupPooledAddress) const;\n  bool isSentinel() const { return EntryKind == dwarf::DW_RLE_end_of_list; }\n};\n\n/// A class representing a single rangelist.\nclass DWARFDebugRnglist : public DWARFListType<RangeListEntry> {\npublic:\n  /// Build a DWARFAddressRangesVector from a rangelist.\n  DWARFAddressRangesVector\n  getAbsoluteRanges(Optional<object::SectionedAddress> BaseAddr,\n                    uint8_t AddressByteSize,\n                    function_ref<Optional<object::SectionedAddress>(uint32_t)>\n                        LookupPooledAddress) const;\n\n  /// Build a DWARFAddressRangesVector from a rangelist.\n  DWARFAddressRangesVector\n  getAbsoluteRanges(llvm::Optional<object::SectionedAddress> BaseAddr,\n                    DWARFUnit &U) const;\n};\n\nclass DWARFDebugRnglistTable : public DWARFListTableBase<DWARFDebugRnglist> {\npublic:\n  DWARFDebugRnglistTable()\n      : DWARFListTableBase(/* SectionName    = */ \".debug_rnglists\",\n                           /* HeaderString   = */ \"ranges:\",\n                           /* ListTypeString = */ \"range\") {}\n};\n\n} // end namespace llvm\n\n#endif // LLVM_DEBUGINFO_DWARF_DWARFDEBUGRNGLISTS_H\n"}, "25": {"id": 25, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/DebugInfo/DWARF/DWARFDie.h", "content": "//===- DWARFDie.h -----------------------------------------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_DEBUGINFO_DWARF_DWARFDIE_H\n#define LLVM_DEBUGINFO_DWARF_DWARFDIE_H\n\n#include \"llvm/ADT/ArrayRef.h\"\n#include \"llvm/ADT/Optional.h\"\n#include \"llvm/ADT/iterator.h\"\n#include \"llvm/ADT/iterator_range.h\"\n#include \"llvm/BinaryFormat/Dwarf.h\"\n#include \"llvm/DebugInfo/DIContext.h\"\n#include \"llvm/DebugInfo/DWARF/DWARFAddressRange.h\"\n#include \"llvm/DebugInfo/DWARF/DWARFAttribute.h\"\n#include \"llvm/DebugInfo/DWARF/DWARFDebugInfoEntry.h\"\n#include \"llvm/DebugInfo/DWARF/DWARFDebugLoc.h\"\n#include <cassert>\n#include <cstdint>\n#include <iterator>\n\nnamespace llvm {\n\nclass DWARFUnit;\nclass raw_ostream;\n\n//===----------------------------------------------------------------------===//\n/// Utility class that carries the DWARF compile/type unit and the debug info\n/// entry in an object.\n///\n/// When accessing information from a debug info entry we always need to DWARF\n/// compile/type unit in order to extract the info correctly as some information\n/// is relative to the compile/type unit. Prior to this class the DWARFUnit and\n/// the DWARFDebugInfoEntry was passed around separately and there was the\n/// possibility for error if the wrong DWARFUnit was used to extract a unit\n/// relative offset. This class helps to ensure that this doesn't happen and\n/// also simplifies the attribute extraction calls by not having to specify the\n/// DWARFUnit for each call.\nclass DWARFDie {\n  DWARFUnit *U = nullptr;\n  const DWARFDebugInfoEntry *Die = nullptr;\n\npublic:\n  DWARFDie() = default;\n  DWARFDie(DWARFUnit *Unit, const DWARFDebugInfoEntry *D) : U(Unit), Die(D) {}\n\n  bool isValid() const { return U && Die; }\n  explicit operator bool() const { return isValid(); }\n  const DWARFDebugInfoEntry *getDebugInfoEntry() const { return Die; }\n  DWARFUnit *getDwarfUnit() const { return U; }\n\n  /// Get the abbreviation declaration for this DIE.\n  ///\n  /// \\returns the abbreviation declaration or NULL for null tags.\n  const DWARFAbbreviationDeclaration *getAbbreviationDeclarationPtr() const {\n    assert(isValid() && \"must check validity prior to calling\");\n    return Die->getAbbreviationDeclarationPtr();\n  }\n\n  /// Get the absolute offset into the debug info or types section.\n  ///\n  /// \\returns the DIE offset or -1U if invalid.\n  uint64_t getOffset() const {\n    assert(isValid() && \"must check validity prior to calling\");\n    return Die->getOffset();\n  }\n\n  dwarf::Tag getTag() const {\n    auto AbbrevDecl = getAbbreviationDeclarationPtr();\n    if (AbbrevDecl)\n      return AbbrevDecl->getTag();\n    return dwarf::DW_TAG_null;\n  }\n\n  bool hasChildren() const {\n    assert(isValid() && \"must check validity prior to calling\");\n    return Die->hasChildren();\n  }\n\n  /// Returns true for a valid DIE that terminates a sibling chain.\n  bool isNULL() const { return getAbbreviationDeclarationPtr() == nullptr; }\n\n  /// Returns true if DIE represents a subprogram (not inlined).\n  bool isSubprogramDIE() const;\n\n  /// Returns true if DIE represents a subprogram or an inlined subroutine.\n  bool isSubroutineDIE() const;\n\n  /// Get the parent of this DIE object.\n  ///\n  /// \\returns a valid DWARFDie instance if this object has a parent or an\n  /// invalid DWARFDie instance if it doesn't.\n  DWARFDie getParent() const;\n\n  /// Get the sibling of this DIE object.\n  ///\n  /// \\returns a valid DWARFDie instance if this object has a sibling or an\n  /// invalid DWARFDie instance if it doesn't.\n  DWARFDie getSibling() const;\n\n  /// Get the previous sibling of this DIE object.\n  ///\n  /// \\returns a valid DWARFDie instance if this object has a sibling or an\n  /// invalid DWARFDie instance if it doesn't.\n  DWARFDie getPreviousSibling() const;\n\n  /// Get the first child of this DIE object.\n  ///\n  /// \\returns a valid DWARFDie instance if this object has children or an\n  /// invalid DWARFDie instance if it doesn't.\n  DWARFDie getFirstChild() const;\n\n  /// Get the last child of this DIE object.\n  ///\n  /// \\returns a valid null DWARFDie instance if this object has children or an\n  /// invalid DWARFDie instance if it doesn't.\n  DWARFDie getLastChild() const;\n\n  /// Dump the DIE and all of its attributes to the supplied stream.\n  ///\n  /// \\param OS the stream to use for output.\n  /// \\param indent the number of characters to indent each line that is output.\n  void dump(raw_ostream &OS, unsigned indent = 0,\n            DIDumpOptions DumpOpts = DIDumpOptions()) const;\n\n  /// Convenience zero-argument overload for debugging.\n  LLVM_DUMP_METHOD void dump() const;\n\n  /// Extract the specified attribute from this DIE.\n  ///\n  /// Extract an attribute value from this DIE only. This call doesn't look\n  /// for the attribute value in any DW_AT_specification or\n  /// DW_AT_abstract_origin referenced DIEs.\n  ///\n  /// \\param Attr the attribute to extract.\n  /// \\returns an optional DWARFFormValue that will have the form value if the\n  /// attribute was successfully extracted.\n  Optional<DWARFFormValue> find(dwarf::Attribute Attr) const;\n\n  /// Extract the first value of any attribute in Attrs from this DIE.\n  ///\n  /// Extract the first attribute that matches from this DIE only. This call\n  /// doesn't look for the attribute value in any DW_AT_specification or\n  /// DW_AT_abstract_origin referenced DIEs. The attributes will be searched\n  /// linearly in the order they are specified within Attrs.\n  ///\n  /// \\param Attrs an array of DWARF attribute to look for.\n  /// \\returns an optional that has a valid DWARFFormValue for the first\n  /// matching attribute in Attrs, or None if none of the attributes in Attrs\n  /// exist in this DIE.\n  Optional<DWARFFormValue> find(ArrayRef<dwarf::Attribute> Attrs) const;\n\n  /// Extract the first value of any attribute in Attrs from this DIE and\n  /// recurse into any DW_AT_specification or DW_AT_abstract_origin referenced\n  /// DIEs.\n  ///\n  /// \\param Attrs an array of DWARF attribute to look for.\n  /// \\returns an optional that has a valid DWARFFormValue for the first\n  /// matching attribute in Attrs, or None if none of the attributes in Attrs\n  /// exist in this DIE or in any DW_AT_specification or DW_AT_abstract_origin\n  /// DIEs.\n  Optional<DWARFFormValue>\n  findRecursively(ArrayRef<dwarf::Attribute> Attrs) const;\n\n  /// Extract the specified attribute from this DIE as the referenced DIE.\n  ///\n  /// Regardless of the reference type, return the correct DWARFDie instance if\n  /// the attribute exists. The returned DWARFDie object might be from another\n  /// DWARFUnit, but that is all encapsulated in the new DWARFDie object.\n  ///\n  /// Extract an attribute value from this DIE only. This call doesn't look\n  /// for the attribute value in any DW_AT_specification or\n  /// DW_AT_abstract_origin referenced DIEs.\n  ///\n  /// \\param Attr the attribute to extract.\n  /// \\returns a valid DWARFDie instance if the attribute exists, or an invalid\n  /// DWARFDie object if it doesn't.\n  DWARFDie getAttributeValueAsReferencedDie(dwarf::Attribute Attr) const;\n  DWARFDie getAttributeValueAsReferencedDie(const DWARFFormValue &V) const;\n\n  /// Extract the range base attribute from this DIE as absolute section offset.\n  ///\n  /// This is a utility function that checks for either the DW_AT_rnglists_base\n  /// or DW_AT_GNU_ranges_base attribute.\n  ///\n  /// \\returns anm optional absolute section offset value for the attribute.\n  Optional<uint64_t> getRangesBaseAttribute() const;\n  Optional<uint64_t> getLocBaseAttribute() const;\n\n  /// Get the DW_AT_high_pc attribute value as an address.\n  ///\n  /// In DWARF version 4 and later the high PC can be encoded as an offset from\n  /// the DW_AT_low_pc. This function takes care of extracting the value as an\n  /// address or offset and adds it to the low PC if needed and returns the\n  /// value as an optional in case the DIE doesn't have a DW_AT_high_pc\n  /// attribute.\n  ///\n  /// \\param LowPC the low PC that might be needed to calculate the high PC.\n  /// \\returns an optional address value for the attribute.\n  Optional<uint64_t> getHighPC(uint64_t LowPC) const;\n\n  /// Retrieves DW_AT_low_pc and DW_AT_high_pc from CU.\n  /// Returns true if both attributes are present.\n  bool getLowAndHighPC(uint64_t &LowPC, uint64_t &HighPC,\n                       uint64_t &SectionIndex) const;\n\n  /// Get the address ranges for this DIE.\n  ///\n  /// Get the hi/low PC range if both attributes are available or exrtracts the\n  /// non-contiguous address ranges from the DW_AT_ranges attribute.\n  ///\n  /// Extracts the range information from this DIE only. This call doesn't look\n  /// for the range in any DW_AT_specification or DW_AT_abstract_origin DIEs.\n  ///\n  /// \\returns a address range vector that might be empty if no address range\n  /// information is available.\n  Expected<DWARFAddressRangesVector> getAddressRanges() const;\n\n  /// Get all address ranges for any DW_TAG_subprogram DIEs in this DIE or any\n  /// of its children.\n  ///\n  /// Get the hi/low PC range if both attributes are available or exrtracts the\n  /// non-contiguous address ranges from the DW_AT_ranges attribute for this DIE\n  /// and all children.\n  ///\n  /// \\param Ranges the addres range vector to fill in.\n  void collectChildrenAddressRanges(DWARFAddressRangesVector &Ranges) const;\n\n  bool addressRangeContainsAddress(const uint64_t Address) const;\n\n  Expected<DWARFLocationExpressionsVector>\n  getLocations(dwarf::Attribute Attr) const;\n\n  /// If a DIE represents a subprogram (or inlined subroutine), returns its\n  /// mangled name (or short name, if mangled is missing). This name may be\n  /// fetched from specification or abstract origin for this subprogram.\n  /// Returns null if no name is found.\n  const char *getSubroutineName(DINameKind Kind) const;\n\n  /// Return the DIE name resolving DW_AT_specification or DW_AT_abstract_origin\n  /// references if necessary. For the LinkageName case it additionaly searches\n  /// for ShortName if LinkageName is not found.\n  /// Returns null if no name is found.\n  const char *getName(DINameKind Kind) const;\n\n  /// Return the DIE short name resolving DW_AT_specification or\n  /// DW_AT_abstract_origin references if necessary. Returns null if no name\n  /// is found.\n  const char *getShortName() const;\n\n  /// Return the DIE linkage name resolving DW_AT_specification or\n  /// DW_AT_abstract_origin references if necessary. Returns null if no name\n  /// is found.\n  const char *getLinkageName() const;\n\n  /// Returns the declaration line (start line) for a DIE, assuming it specifies\n  /// a subprogram. This may be fetched from specification or abstract origin\n  /// for this subprogram by resolving DW_AT_sepcification or\n  /// DW_AT_abstract_origin references if necessary.\n  uint64_t getDeclLine() const;\n  std::string getDeclFile(DILineInfoSpecifier::FileLineInfoKind Kind) const;\n\n  /// Retrieves values of DW_AT_call_file, DW_AT_call_line and DW_AT_call_column\n  /// from DIE (or zeroes if they are missing). This function looks for\n  /// DW_AT_call attributes in this DIE only, it will not resolve the attribute\n  /// values in any DW_AT_specification or DW_AT_abstract_origin DIEs.\n  /// \\param CallFile filled in with non-zero if successful, zero if there is no\n  /// DW_AT_call_file attribute in this DIE.\n  /// \\param CallLine filled in with non-zero if successful, zero if there is no\n  /// DW_AT_call_line attribute in this DIE.\n  /// \\param CallColumn filled in with non-zero if successful, zero if there is\n  /// no DW_AT_call_column attribute in this DIE.\n  /// \\param CallDiscriminator filled in with non-zero if successful, zero if\n  /// there is no DW_AT_GNU_discriminator attribute in this DIE.\n  void getCallerFrame(uint32_t &CallFile, uint32_t &CallLine,\n                      uint32_t &CallColumn, uint32_t &CallDiscriminator) const;\n\n  class attribute_iterator;\n\n  /// Get an iterator range to all attributes in the current DIE only.\n  ///\n  /// \\returns an iterator range for the attributes of the current DIE.\n  iterator_range<attribute_iterator> attributes() const;\n\n  class iterator;\n\n  iterator begin() const;\n  iterator end() const;\n\n  std::reverse_iterator<iterator> rbegin() const;\n  std::reverse_iterator<iterator> rend() const;\n\n  iterator_range<iterator> children() const;\n};\n\nclass DWARFDie::attribute_iterator\n    : public iterator_facade_base<attribute_iterator, std::forward_iterator_tag,\n                                  const DWARFAttribute> {\n  /// The DWARF DIE we are extracting attributes from.\n  DWARFDie Die;\n  /// The value vended to clients via the operator*() or operator->().\n  DWARFAttribute AttrValue;\n  /// The attribute index within the abbreviation declaration in Die.\n  uint32_t Index;\n\n  friend bool operator==(const attribute_iterator &LHS,\n                         const attribute_iterator &RHS);\n\n  /// Update the attribute index and attempt to read the attribute value. If the\n  /// attribute is able to be read, update AttrValue and the Index member\n  /// variable. If the attribute value is not able to be read, an appropriate\n  /// error will be set if the Err member variable is non-NULL and the iterator\n  /// will be set to the end value so iteration stops.\n  void updateForIndex(const DWARFAbbreviationDeclaration &AbbrDecl, uint32_t I);\n\npublic:\n  attribute_iterator() = delete;\n  explicit attribute_iterator(DWARFDie D, bool End);\n\n  attribute_iterator &operator++();\n  attribute_iterator &operator--();\n  explicit operator bool() const { return AttrValue.isValid(); }\n  const DWARFAttribute &operator*() const { return AttrValue; }\n};\n\ninline bool operator==(const DWARFDie::attribute_iterator &LHS,\n                       const DWARFDie::attribute_iterator &RHS) {\n  return LHS.Index == RHS.Index;\n}\n\ninline bool operator!=(const DWARFDie::attribute_iterator &LHS,\n                       const DWARFDie::attribute_iterator &RHS) {\n  return !(LHS == RHS);\n}\n\ninline bool operator==(const DWARFDie &LHS, const DWARFDie &RHS) {\n  return LHS.getDebugInfoEntry() == RHS.getDebugInfoEntry() &&\n         LHS.getDwarfUnit() == RHS.getDwarfUnit();\n}\n\ninline bool operator!=(const DWARFDie &LHS, const DWARFDie &RHS) {\n  return !(LHS == RHS);\n}\n\ninline bool operator<(const DWARFDie &LHS, const DWARFDie &RHS) {\n  return LHS.getOffset() < RHS.getOffset();\n}\n\nclass DWARFDie::iterator\n    : public iterator_facade_base<iterator, std::bidirectional_iterator_tag,\n                                  const DWARFDie> {\n  DWARFDie Die;\n\n  friend std::reverse_iterator<llvm::DWARFDie::iterator>;\n  friend bool operator==(const DWARFDie::iterator &LHS,\n                         const DWARFDie::iterator &RHS);\n\npublic:\n  iterator() = default;\n\n  explicit iterator(DWARFDie D) : Die(D) {}\n\n  iterator &operator++() {\n    Die = Die.getSibling();\n    return *this;\n  }\n\n  iterator &operator--() {\n    Die = Die.getPreviousSibling();\n    return *this;\n  }\n\n  const DWARFDie &operator*() const { return Die; }\n};\n\ninline bool operator==(const DWARFDie::iterator &LHS,\n                       const DWARFDie::iterator &RHS) {\n  return LHS.Die == RHS.Die;\n}\n\n// These inline functions must follow the DWARFDie::iterator definition above\n// as they use functions from that class.\ninline DWARFDie::iterator DWARFDie::begin() const {\n  return iterator(getFirstChild());\n}\n\ninline DWARFDie::iterator DWARFDie::end() const {\n  return iterator(getLastChild());\n}\n\ninline iterator_range<DWARFDie::iterator> DWARFDie::children() const {\n  return make_range(begin(), end());\n}\n\n} // end namespace llvm\n\nnamespace std {\n\ntemplate <>\nclass reverse_iterator<llvm::DWARFDie::iterator>\n    : public llvm::iterator_facade_base<\n          reverse_iterator<llvm::DWARFDie::iterator>,\n          bidirectional_iterator_tag, const llvm::DWARFDie> {\n\nprivate:\n  llvm::DWARFDie Die;\n  bool AtEnd;\n\npublic:\n  reverse_iterator(llvm::DWARFDie::iterator It)\n      : Die(It.Die), AtEnd(!It.Die.getPreviousSibling()) {\n    if (!AtEnd)\n      Die = Die.getPreviousSibling();\n  }\n\n  llvm::DWARFDie::iterator base() const {\n    return llvm::DWARFDie::iterator(AtEnd ? Die : Die.getSibling());\n  }\n\n  reverse_iterator<llvm::DWARFDie::iterator> &operator++() {\n    assert(!AtEnd && \"Incrementing rend\");\n    llvm::DWARFDie D = Die.getPreviousSibling();\n    if (D)\n      Die = D;\n    else\n      AtEnd = true;\n    return *this;\n  }\n\n  reverse_iterator<llvm::DWARFDie::iterator> &operator--() {\n    if (AtEnd) {\n      AtEnd = false;\n      return *this;\n    }\n    Die = Die.getSibling();\n    assert(!Die.isNULL() && \"Decrementing rbegin\");\n    return *this;\n  }\n\n  const llvm::DWARFDie &operator*() const {\n    assert(Die.isValid());\n    return Die;\n  }\n\n  // FIXME: We should be able to specify the equals operator as a friend, but\n  //        that causes the compiler to think the operator overload is ambiguous\n  //        with the friend declaration and the actual definition as candidates.\n  bool equals(const reverse_iterator<llvm::DWARFDie::iterator> &RHS) const {\n    return Die == RHS.Die && AtEnd == RHS.AtEnd;\n  }\n};\n\n} // namespace std\n\nnamespace llvm {\n\ninline bool operator==(const std::reverse_iterator<DWARFDie::iterator> &LHS,\n                       const std::reverse_iterator<DWARFDie::iterator> &RHS) {\n  return LHS.equals(RHS);\n}\n\ninline bool operator!=(const std::reverse_iterator<DWARFDie::iterator> &LHS,\n                       const std::reverse_iterator<DWARFDie::iterator> &RHS) {\n  return !(LHS == RHS);\n}\n\ninline std::reverse_iterator<DWARFDie::iterator> DWARFDie::rbegin() const {\n  return llvm::make_reverse_iterator(end());\n}\n\ninline std::reverse_iterator<DWARFDie::iterator> DWARFDie::rend() const {\n  return llvm::make_reverse_iterator(begin());\n}\n\n} // end namespace llvm\n\n#endif // LLVM_DEBUGINFO_DWARF_DWARFDIE_H\n"}, "26": {"id": 26, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/DebugInfo/DWARF/DWARFFormValue.h", "content": "//===- DWARFFormValue.h -----------------------------------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_DEBUGINFO_DWARF_DWARFFORMVALUE_H\n#define LLVM_DEBUGINFO_DWARF_DWARFFORMVALUE_H\n\n#include \"llvm/ADT/ArrayRef.h\"\n#include \"llvm/ADT/None.h\"\n#include \"llvm/ADT/Optional.h\"\n#include \"llvm/BinaryFormat/Dwarf.h\"\n#include \"llvm/DebugInfo/DIContext.h\"\n#include \"llvm/DebugInfo/DWARF/DWARFDataExtractor.h\"\n#include <cstdint>\n\nnamespace llvm {\n\nclass DWARFContext;\nclass DWARFUnit;\nclass raw_ostream;\n\nclass DWARFFormValue {\npublic:\n  enum FormClass {\n    FC_Unknown,\n    FC_Address,\n    FC_Block,\n    FC_Constant,\n    FC_String,\n    FC_Flag,\n    FC_Reference,\n    FC_Indirect,\n    FC_SectionOffset,\n    FC_Exprloc\n  };\n\nprivate:\n  struct ValueType {\n    ValueType() { uval = 0; }\n    ValueType(int64_t V) : sval(V) {}\n    ValueType(uint64_t V) : uval(V) {}\n    ValueType(const char *V) : cstr(V) {}\n\n    union {\n      uint64_t uval;\n      int64_t sval;\n      const char *cstr;\n    };\n    const uint8_t *data = nullptr;\n    uint64_t SectionIndex;      /// Section index for reference forms.\n  };\n\n  dwarf::Form Form;             /// Form for this value.\n  dwarf::DwarfFormat Format =\n      dwarf::DWARF32;           /// Remember the DWARF format at extract time.\n  ValueType Value;              /// Contains all data for the form.\n  const DWARFUnit *U = nullptr; /// Remember the DWARFUnit at extract time.\n  const DWARFContext *C = nullptr; /// Context for extract time.\n\n  DWARFFormValue(dwarf::Form F, ValueType V) : Form(F), Value(V) {}\n\npublic:\n  DWARFFormValue(dwarf::Form F = dwarf::Form(0)) : Form(F) {}\n\n  static DWARFFormValue createFromSValue(dwarf::Form F, int64_t V);\n  static DWARFFormValue createFromUValue(dwarf::Form F, uint64_t V);\n  static DWARFFormValue createFromPValue(dwarf::Form F, const char *V);\n  static DWARFFormValue createFromBlockValue(dwarf::Form F,\n                                             ArrayRef<uint8_t> D);\n  static DWARFFormValue createFromUnit(dwarf::Form F, const DWARFUnit *Unit,\n                                       uint64_t *OffsetPtr);\n\n  dwarf::Form getForm() const { return Form; }\n  uint64_t getRawUValue() const { return Value.uval; }\n\n  bool isFormClass(FormClass FC) const;\n  const DWARFUnit *getUnit() const { return U; }\n  void dump(raw_ostream &OS, DIDumpOptions DumpOpts = DIDumpOptions()) const;\n  void dumpSectionedAddress(raw_ostream &OS, DIDumpOptions DumpOpts,\n                            object::SectionedAddress SA) const;\n  void dumpAddress(raw_ostream &OS, uint64_t Address) const;\n  static void dumpAddress(raw_ostream &OS, uint8_t AddressSize,\n                          uint64_t Address);\n  static void dumpAddressSection(const DWARFObject &Obj, raw_ostream &OS,\n                                 DIDumpOptions DumpOpts, uint64_t SectionIndex);\n\n  /// Extracts a value in \\p Data at offset \\p *OffsetPtr. The information\n  /// in \\p FormParams is needed to interpret some forms. The optional\n  /// \\p Context and \\p Unit allows extracting information if the form refers\n  /// to other sections (e.g., .debug_str).\n  bool extractValue(const DWARFDataExtractor &Data, uint64_t *OffsetPtr,\n                    dwarf::FormParams FormParams,\n                    const DWARFContext *Context = nullptr,\n                    const DWARFUnit *Unit = nullptr);\n\n  bool extractValue(const DWARFDataExtractor &Data, uint64_t *OffsetPtr,\n                    dwarf::FormParams FormParams, const DWARFUnit *U) {\n    return extractValue(Data, OffsetPtr, FormParams, nullptr, U);\n  }\n\n  bool isInlinedCStr() const {\n    return Value.data != nullptr && Value.data == (const uint8_t *)Value.cstr;\n  }\n\n  /// getAsFoo functions below return the extracted value as Foo if only\n  /// DWARFFormValue has form class is suitable for representing Foo.\n  Optional<uint64_t> getAsReference() const;\n  struct UnitOffset {\n    DWARFUnit *Unit;\n    uint64_t Offset;\n  };\n  Optional<UnitOffset> getAsRelativeReference() const;\n  Optional<uint64_t> getAsUnsignedConstant() const;\n  Optional<int64_t> getAsSignedConstant() const;\n  Optional<const char *> getAsCString() const;\n  Optional<uint64_t> getAsAddress() const;\n  Optional<object::SectionedAddress> getAsSectionedAddress() const;\n  Optional<uint64_t> getAsSectionOffset() const;\n  Optional<ArrayRef<uint8_t>> getAsBlock() const;\n  Optional<uint64_t> getAsCStringOffset() const;\n  Optional<uint64_t> getAsReferenceUVal() const;\n\n  /// Skip a form's value in \\p DebugInfoData at the offset specified by\n  /// \\p OffsetPtr.\n  ///\n  /// Skips the bytes for the current form and updates the offset.\n  ///\n  /// \\param DebugInfoData The data where we want to skip the value.\n  /// \\param OffsetPtr A reference to the offset that will be updated.\n  /// \\param Params DWARF parameters to help interpret forms.\n  /// \\returns true on success, false if the form was not skipped.\n  bool skipValue(DataExtractor DebugInfoData, uint64_t *OffsetPtr,\n                 const dwarf::FormParams Params) const {\n    return DWARFFormValue::skipValue(Form, DebugInfoData, OffsetPtr, Params);\n  }\n\n  /// Skip a form's value in \\p DebugInfoData at the offset specified by\n  /// \\p OffsetPtr.\n  ///\n  /// Skips the bytes for the specified form and updates the offset.\n  ///\n  /// \\param Form The DW_FORM enumeration that indicates the form to skip.\n  /// \\param DebugInfoData The data where we want to skip the value.\n  /// \\param OffsetPtr A reference to the offset that will be updated.\n  /// \\param FormParams DWARF parameters to help interpret forms.\n  /// \\returns true on success, false if the form was not skipped.\n  static bool skipValue(dwarf::Form Form, DataExtractor DebugInfoData,\n                        uint64_t *OffsetPtr,\n                        const dwarf::FormParams FormParams);\n\nprivate:\n  void dumpString(raw_ostream &OS) const;\n};\n\nnamespace dwarf {\n\n/// Take an optional DWARFFormValue and try to extract a string value from it.\n///\n/// \\param V and optional DWARFFormValue to attempt to extract the value from.\n/// \\returns an optional value that contains a value if the form value\n/// was valid and was a string.\ninline Optional<const char *> toString(const Optional<DWARFFormValue> &V) {\n  if (V)\n    return V->getAsCString();\n  return None;\n}\n\n/// Take an optional DWARFFormValue and try to extract a string value from it.\n///\n/// \\param V and optional DWARFFormValue to attempt to extract the value from.\n/// \\returns an optional value that contains a value if the form value\n/// was valid and was a string.\ninline StringRef toStringRef(const Optional<DWARFFormValue> &V,\n                             StringRef Default = {}) {\n  if (V)\n    if (auto S = V->getAsCString())\n      return *S;\n  return Default;\n}\n\n/// Take an optional DWARFFormValue and extract a string value from it.\n///\n/// \\param V and optional DWARFFormValue to attempt to extract the value from.\n/// \\param Default the default value to return in case of failure.\n/// \\returns the string value or Default if the V doesn't have a value or the\n/// form value's encoding wasn't a string.\ninline const char *toString(const Optional<DWARFFormValue> &V,\n                            const char *Default) {\n  return toString(V).getValueOr(Default);\n}\n\n/// Take an optional DWARFFormValue and try to extract an unsigned constant.\n///\n/// \\param V and optional DWARFFormValue to attempt to extract the value from.\n/// \\returns an optional value that contains a value if the form value\n/// was valid and has a unsigned constant form.\ninline Optional<uint64_t> toUnsigned(const Optional<DWARFFormValue> &V) {\n  if (V)\n    return V->getAsUnsignedConstant();\n  return None;\n}\n\n/// Take an optional DWARFFormValue and extract a unsigned constant.\n///\n/// \\param V and optional DWARFFormValue to attempt to extract the value from.\n/// \\param Default the default value to return in case of failure.\n/// \\returns the extracted unsigned value or Default if the V doesn't have a\n/// value or the form value's encoding wasn't an unsigned constant form.\ninline uint64_t toUnsigned(const Optional<DWARFFormValue> &V,\n                           uint64_t Default) {\n  return toUnsigned(V).getValueOr(Default);\n}\n\n/// Take an optional DWARFFormValue and try to extract an reference.\n///\n/// \\param V and optional DWARFFormValue to attempt to extract the value from.\n/// \\returns an optional value that contains a value if the form value\n/// was valid and has a reference form.\ninline Optional<uint64_t> toReference(const Optional<DWARFFormValue> &V) {\n  if (V)\n    return V->getAsReference();\n  return None;\n}\n\n/// Take an optional DWARFFormValue and extract a reference.\n///\n/// \\param V and optional DWARFFormValue to attempt to extract the value from.\n/// \\param Default the default value to return in case of failure.\n/// \\returns the extracted reference value or Default if the V doesn't have a\n/// value or the form value's encoding wasn't a reference form.\ninline uint64_t toReference(const Optional<DWARFFormValue> &V,\n                            uint64_t Default) {\n  return toReference(V).getValueOr(Default);\n}\n\n/// Take an optional DWARFFormValue and try to extract an signed constant.\n///\n/// \\param V and optional DWARFFormValue to attempt to extract the value from.\n/// \\returns an optional value that contains a value if the form value\n/// was valid and has a signed constant form.\ninline Optional<int64_t> toSigned(const Optional<DWARFFormValue> &V) {\n  if (V)\n    return V->getAsSignedConstant();\n  return None;\n}\n\n/// Take an optional DWARFFormValue and extract a signed integer.\n///\n/// \\param V and optional DWARFFormValue to attempt to extract the value from.\n/// \\param Default the default value to return in case of failure.\n/// \\returns the extracted signed integer value or Default if the V doesn't\n/// have a value or the form value's encoding wasn't a signed integer form.\ninline int64_t toSigned(const Optional<DWARFFormValue> &V, int64_t Default) {\n  return toSigned(V).getValueOr(Default);\n}\n\n/// Take an optional DWARFFormValue and try to extract an address.\n///\n/// \\param V and optional DWARFFormValue to attempt to extract the value from.\n/// \\returns an optional value that contains a value if the form value\n/// was valid and has a address form.\ninline Optional<uint64_t> toAddress(const Optional<DWARFFormValue> &V) {\n  if (V)\n    return V->getAsAddress();\n  return None;\n}\n\ninline Optional<object::SectionedAddress>\ntoSectionedAddress(const Optional<DWARFFormValue> &V) {\n  if (V)\n    return V->getAsSectionedAddress();\n  return None;\n}\n\n/// Take an optional DWARFFormValue and extract a address.\n///\n/// \\param V and optional DWARFFormValue to attempt to extract the value from.\n/// \\param Default the default value to return in case of failure.\n/// \\returns the extracted address value or Default if the V doesn't have a\n/// value or the form value's encoding wasn't an address form.\ninline uint64_t toAddress(const Optional<DWARFFormValue> &V, uint64_t Default) {\n  return toAddress(V).getValueOr(Default);\n}\n\n/// Take an optional DWARFFormValue and try to extract an section offset.\n///\n/// \\param V and optional DWARFFormValue to attempt to extract the value from.\n/// \\returns an optional value that contains a value if the form value\n/// was valid and has a section offset form.\ninline Optional<uint64_t> toSectionOffset(const Optional<DWARFFormValue> &V) {\n  if (V)\n    return V->getAsSectionOffset();\n  return None;\n}\n\n/// Take an optional DWARFFormValue and extract a section offset.\n///\n/// \\param V and optional DWARFFormValue to attempt to extract the value from.\n/// \\param Default the default value to return in case of failure.\n/// \\returns the extracted section offset value or Default if the V doesn't\n/// have a value or the form value's encoding wasn't a section offset form.\ninline uint64_t toSectionOffset(const Optional<DWARFFormValue> &V,\n                                uint64_t Default) {\n  return toSectionOffset(V).getValueOr(Default);\n}\n\n/// Take an optional DWARFFormValue and try to extract block data.\n///\n/// \\param V and optional DWARFFormValue to attempt to extract the value from.\n/// \\returns an optional value that contains a value if the form value\n/// was valid and has a block form.\ninline Optional<ArrayRef<uint8_t>> toBlock(const Optional<DWARFFormValue> &V) {\n  if (V)\n    return V->getAsBlock();\n  return None;\n}\n\n} // end namespace dwarf\n\n} // end namespace llvm\n\n#endif // LLVM_DEBUGINFO_DWARF_DWARFFORMVALUE_H\n"}, "27": {"id": 27, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/DebugInfo/DWARF/DWARFListTable.h", "content": "//===- DWARFListTable.h -----------------------------------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_DEBUGINFO_DWARF_DWARFLISTTABLE_H\n#define LLVM_DEBUGINFO_DWARF_DWARFLISTTABLE_H\n\n#include \"llvm/BinaryFormat/Dwarf.h\"\n#include \"llvm/DebugInfo/DIContext.h\"\n#include \"llvm/DebugInfo/DWARF/DWARFDataExtractor.h\"\n#include \"llvm/Support/Errc.h\"\n#include \"llvm/Support/Error.h\"\n#include \"llvm/Support/Format.h\"\n#include \"llvm/Support/raw_ostream.h\"\n#include <cstdint>\n#include <map>\n#include <vector>\n\nnamespace llvm {\n\n/// A base class for DWARF list entries, such as range or location list\n/// entries.\nstruct DWARFListEntryBase {\n  /// The offset at which the entry is located in the section.\n  uint64_t Offset;\n  /// The DWARF encoding (DW_RLE_* or DW_LLE_*).\n  uint8_t EntryKind;\n  /// The index of the section this entry belongs to.\n  uint64_t SectionIndex;\n};\n\n/// A base class for lists of entries that are extracted from a particular\n/// section, such as range lists or location lists.\ntemplate <typename ListEntryType> class DWARFListType {\n  using EntryType = ListEntryType;\n  using ListEntries = std::vector<EntryType>;\n\nprotected:\n  ListEntries Entries;\n\npublic:\n  const ListEntries &getEntries() const { return Entries; }\n  bool empty() const { return Entries.empty(); }\n  void clear() { Entries.clear(); }\n  Error extract(DWARFDataExtractor Data, uint64_t HeaderOffset,\n                uint64_t *OffsetPtr, StringRef SectionName,\n                StringRef ListStringName);\n};\n\n/// A class representing the header of a list table such as the range list\n/// table in the .debug_rnglists section.\nclass DWARFListTableHeader {\n  struct Header {\n    /// The total length of the entries for this table, not including the length\n    /// field itself.\n    uint64_t Length = 0;\n    /// The DWARF version number.\n    uint16_t Version;\n    /// The size in bytes of an address on the target architecture. For\n    /// segmented addressing, this is the size of the offset portion of the\n    /// address.\n    uint8_t AddrSize;\n    /// The size in bytes of a segment selector on the target architecture.\n    /// If the target system uses a flat address space, this value is 0.\n    uint8_t SegSize;\n    /// The number of offsets that follow the header before the range lists.\n    uint32_t OffsetEntryCount;\n  };\n\n  Header HeaderData;\n  /// The table's format, either DWARF32 or DWARF64.\n  dwarf::DwarfFormat Format;\n  /// The offset at which the header (and hence the table) is located within\n  /// its section.\n  uint64_t HeaderOffset;\n  /// The name of the section the list is located in.\n  StringRef SectionName;\n  /// A characterization of the list for dumping purposes, e.g. \"range\" or\n  /// \"location\".\n  StringRef ListTypeString;\n\npublic:\n  DWARFListTableHeader(StringRef SectionName, StringRef ListTypeString)\n      : SectionName(SectionName), ListTypeString(ListTypeString) {}\n\n  void clear() {\n    HeaderData = {};\n  }\n  uint64_t getHeaderOffset() const { return HeaderOffset; }\n  uint8_t getAddrSize() const { return HeaderData.AddrSize; }\n  uint64_t getLength() const { return HeaderData.Length; }\n  uint16_t getVersion() const { return HeaderData.Version; }\n  StringRef getSectionName() const { return SectionName; }\n  StringRef getListTypeString() const { return ListTypeString; }\n  dwarf::DwarfFormat getFormat() const { return Format; }\n\n  /// Return the size of the table header including the length but not including\n  /// the offsets.\n  static uint8_t getHeaderSize(dwarf::DwarfFormat Format) {\n    switch (Format) {\n    case dwarf::DwarfFormat::DWARF32:\n      return 12;\n    case dwarf::DwarfFormat::DWARF64:\n      return 20;\n    }\n    llvm_unreachable(\"Invalid DWARF format (expected DWARF32 or DWARF64\");\n  }\n\n  void dump(DataExtractor Data, raw_ostream &OS,\n            DIDumpOptions DumpOpts = {}) const;\n  Optional<uint64_t> getOffsetEntry(DataExtractor Data, uint32_t Index) const {\n    if (Index > HeaderData.OffsetEntryCount)\n      return None;\n\n    return getOffsetEntry(Data, getHeaderOffset() + getHeaderSize(Format), Format, Index);\n  }\n\n  static Optional<uint64_t> getOffsetEntry(DataExtractor Data,\n                                           uint64_t OffsetTableOffset,\n                                           dwarf::DwarfFormat Format,\n                                           uint32_t Index) {\n    uint8_t OffsetByteSize = Format == dwarf::DWARF64 ? 8 : 4;\n    uint64_t Offset = OffsetTableOffset + OffsetByteSize * Index;\n    auto R = Data.getUnsigned(&Offset, OffsetByteSize);\n    return R;\n  }\n\n  /// Extract the table header and the array of offsets.\n  Error extract(DWARFDataExtractor Data, uint64_t *OffsetPtr);\n\n  /// Returns the length of the table, including the length field, or 0 if the\n  /// length has not been determined (e.g. because the table has not yet been\n  /// parsed, or there was a problem in parsing).\n  uint64_t length() const;\n};\n\n/// A class representing a table of lists as specified in the DWARF v5\n/// standard for location lists and range lists. The table consists of a header\n/// followed by an array of offsets into a DWARF section, followed by zero or\n/// more list entries. The list entries are kept in a map where the keys are\n/// the lists' section offsets.\ntemplate <typename DWARFListType> class DWARFListTableBase {\n  DWARFListTableHeader Header;\n  /// A mapping between file offsets and lists. It is used to find a particular\n  /// list based on an offset (obtained from DW_AT_ranges, for example).\n  std::map<uint64_t, DWARFListType> ListMap;\n  /// This string is displayed as a heading before the list is dumped\n  /// (e.g. \"ranges:\").\n  StringRef HeaderString;\n\nprotected:\n  DWARFListTableBase(StringRef SectionName, StringRef HeaderString,\n                     StringRef ListTypeString)\n      : Header(SectionName, ListTypeString), HeaderString(HeaderString) {}\n\npublic:\n  void clear() {\n    Header.clear();\n    ListMap.clear();\n  }\n  /// Extract the table header and the array of offsets.\n  Error extractHeaderAndOffsets(DWARFDataExtractor Data, uint64_t *OffsetPtr) {\n    return Header.extract(Data, OffsetPtr);\n  }\n  /// Extract an entire table, including all list entries.\n  Error extract(DWARFDataExtractor Data, uint64_t *OffsetPtr);\n  /// Look up a list based on a given offset. Extract it and enter it into the\n  /// list map if necessary.\n  Expected<DWARFListType> findList(DWARFDataExtractor Data, uint64_t Offset);\n\n  uint64_t getHeaderOffset() const { return Header.getHeaderOffset(); }\n  uint8_t getAddrSize() const { return Header.getAddrSize(); }\n  dwarf::DwarfFormat getFormat() const { return Header.getFormat(); }\n\n  void dump(DWARFDataExtractor Data, raw_ostream &OS,\n            llvm::function_ref<Optional<object::SectionedAddress>(uint32_t)>\n                LookupPooledAddress,\n            DIDumpOptions DumpOpts = {}) const;\n\n  /// Return the contents of the offset entry designated by a given index.\n  Optional<uint64_t> getOffsetEntry(DataExtractor Data, uint32_t Index) const {\n    return Header.getOffsetEntry(Data, Index);\n  }\n  /// Return the size of the table header including the length but not including\n  /// the offsets. This is dependent on the table format, which is unambiguously\n  /// derived from parsing the table.\n  uint8_t getHeaderSize() const {\n    return DWARFListTableHeader::getHeaderSize(getFormat());\n  }\n\n  uint64_t length() { return Header.length(); }\n};\n\ntemplate <typename DWARFListType>\nError DWARFListTableBase<DWARFListType>::extract(DWARFDataExtractor Data,\n                                                 uint64_t *OffsetPtr) {\n  clear();\n  if (Error E = extractHeaderAndOffsets(Data, OffsetPtr))\n    return E;\n\n  Data.setAddressSize(Header.getAddrSize());\n  Data = DWARFDataExtractor(Data, getHeaderOffset() + Header.length());\n  while (Data.isValidOffset(*OffsetPtr)) {\n    DWARFListType CurrentList;\n    uint64_t Off = *OffsetPtr;\n    if (Error E = CurrentList.extract(Data, getHeaderOffset(), OffsetPtr,\n                                      Header.getSectionName(),\n                                      Header.getListTypeString()))\n      return E;\n    ListMap[Off] = CurrentList;\n  }\n\n  assert(*OffsetPtr == Data.size() &&\n         \"mismatch between expected length of table and length \"\n         \"of extracted data\");\n  return Error::success();\n}\n\ntemplate <typename ListEntryType>\nError DWARFListType<ListEntryType>::extract(DWARFDataExtractor Data,\n                                            uint64_t HeaderOffset,\n                                            uint64_t *OffsetPtr,\n                                            StringRef SectionName,\n                                            StringRef ListTypeString) {\n  if (*OffsetPtr < HeaderOffset || *OffsetPtr >= Data.size())\n    return createStringError(errc::invalid_argument,\n                       \"invalid %s list offset 0x%\" PRIx64,\n                       ListTypeString.data(), *OffsetPtr);\n  Entries.clear();\n  while (Data.isValidOffset(*OffsetPtr)) {\n    ListEntryType Entry;\n    if (Error E = Entry.extract(Data, OffsetPtr))\n      return E;\n    Entries.push_back(Entry);\n    if (Entry.isSentinel())\n      return Error::success();\n  }\n  return createStringError(errc::illegal_byte_sequence,\n                     \"no end of list marker detected at end of %s table \"\n                     \"starting at offset 0x%\" PRIx64,\n                     SectionName.data(), HeaderOffset);\n}\n\ntemplate <typename DWARFListType>\nvoid DWARFListTableBase<DWARFListType>::dump(\n    DWARFDataExtractor Data, raw_ostream &OS,\n    llvm::function_ref<Optional<object::SectionedAddress>(uint32_t)>\n        LookupPooledAddress,\n    DIDumpOptions DumpOpts) const {\n  Header.dump(Data, OS, DumpOpts);\n  OS << HeaderString << \"\\n\";\n\n  // Determine the length of the longest encoding string we have in the table,\n  // so we can align the output properly. We only need this in verbose mode.\n  size_t MaxEncodingStringLength = 0;\n  if (DumpOpts.Verbose) {\n    for (const auto &List : ListMap)\n      for (const auto &Entry : List.second.getEntries())\n        MaxEncodingStringLength =\n            std::max(MaxEncodingStringLength,\n                     dwarf::RangeListEncodingString(Entry.EntryKind).size());\n  }\n\n  uint64_t CurrentBase = 0;\n  for (const auto &List : ListMap)\n    for (const auto &Entry : List.second.getEntries())\n      Entry.dump(OS, getAddrSize(), MaxEncodingStringLength, CurrentBase,\n                 DumpOpts, LookupPooledAddress);\n}\n\ntemplate <typename DWARFListType>\nExpected<DWARFListType>\nDWARFListTableBase<DWARFListType>::findList(DWARFDataExtractor Data,\n                                            uint64_t Offset) {\n  // Extract the list from the section and enter it into the list map.\n  DWARFListType List;\n  if (Header.length())\n    Data = DWARFDataExtractor(Data, getHeaderOffset() + Header.length());\n  if (Error E =\n          List.extract(Data, Header.length() ? getHeaderOffset() : 0, &Offset,\n                       Header.getSectionName(), Header.getListTypeString()))\n    return std::move(E);\n  return List;\n}\n\n} // end namespace llvm\n\n#endif // LLVM_DEBUGINFO_DWARF_DWARFLISTTABLE_H\n"}, "28": {"id": 28, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/DebugInfo/DWARF/DWARFUnit.h", "content": "//===- DWARFUnit.h ----------------------------------------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_DEBUGINFO_DWARF_DWARFUNIT_H\n#define LLVM_DEBUGINFO_DWARF_DWARFUNIT_H\n\n#include \"llvm/ADT/Optional.h\"\n#include \"llvm/ADT/STLExtras.h\"\n#include \"llvm/ADT/SmallVector.h\"\n#include \"llvm/ADT/StringRef.h\"\n#include \"llvm/ADT/iterator_range.h\"\n#include \"llvm/BinaryFormat/Dwarf.h\"\n#include \"llvm/DebugInfo/DWARF/DWARFDebugInfoEntry.h\"\n#include \"llvm/DebugInfo/DWARF/DWARFDebugLoc.h\"\n#include \"llvm/DebugInfo/DWARF/DWARFDebugRangeList.h\"\n#include \"llvm/DebugInfo/DWARF/DWARFDebugRnglists.h\"\n#include \"llvm/DebugInfo/DWARF/DWARFDie.h\"\n#include \"llvm/DebugInfo/DWARF/DWARFFormValue.h\"\n#include \"llvm/DebugInfo/DWARF/DWARFRelocMap.h\"\n#include \"llvm/DebugInfo/DWARF/DWARFSection.h\"\n#include \"llvm/DebugInfo/DWARF/DWARFUnitIndex.h\"\n#include \"llvm/Support/DataExtractor.h\"\n#include <algorithm>\n#include <cassert>\n#include <cstddef>\n#include <cstdint>\n#include <map>\n#include <memory>\n#include <utility>\n#include <vector>\n\nnamespace llvm {\n\nclass DWARFAbbreviationDeclarationSet;\nclass DWARFContext;\nclass DWARFDebugAbbrev;\nclass DWARFUnit;\n\n/// Base class describing the header of any kind of \"unit.\"  Some information\n/// is specific to certain unit types.  We separate this class out so we can\n/// parse the header before deciding what specific kind of unit to construct.\nclass DWARFUnitHeader {\n  // Offset within section.\n  uint64_t Offset = 0;\n  // Version, address size, and DWARF format.\n  dwarf::FormParams FormParams;\n  uint64_t Length = 0;\n  uint64_t AbbrOffset = 0;\n\n  // For DWO units only.\n  const DWARFUnitIndex::Entry *IndexEntry = nullptr;\n\n  // For type units only.\n  uint64_t TypeHash = 0;\n  uint64_t TypeOffset = 0;\n\n  // For v5 split or skeleton compile units only.\n  Optional<uint64_t> DWOId;\n\n  // Unit type as parsed, or derived from the section kind.\n  uint8_t UnitType = 0;\n\n  // Size as parsed. uint8_t for compactness.\n  uint8_t Size = 0;\n\npublic:\n  /// Parse a unit header from \\p debug_info starting at \\p offset_ptr.\n  /// Note that \\p SectionKind is used as a hint to guess the unit type\n  /// for DWARF formats prior to DWARFv5. In DWARFv5 the unit type is\n  /// explicitly defined in the header and the hint is ignored.\n  bool extract(DWARFContext &Context, const DWARFDataExtractor &debug_info,\n               uint64_t *offset_ptr, DWARFSectionKind SectionKind);\n  // For units in DWARF Package File, remember the index entry and update\n  // the abbreviation offset read by extract().\n  bool applyIndexEntry(const DWARFUnitIndex::Entry *Entry);\n  uint64_t getOffset() const { return Offset; }\n  const dwarf::FormParams &getFormParams() const { return FormParams; }\n  uint16_t getVersion() const { return FormParams.Version; }\n  dwarf::DwarfFormat getFormat() const { return FormParams.Format; }\n  uint8_t getAddressByteSize() const { return FormParams.AddrSize; }\n  uint8_t getRefAddrByteSize() const { return FormParams.getRefAddrByteSize(); }\n  uint8_t getDwarfOffsetByteSize() const {\n    return FormParams.getDwarfOffsetByteSize();\n  }\n  uint64_t getLength() const { return Length; }\n  uint64_t getAbbrOffset() const { return AbbrOffset; }\n  Optional<uint64_t> getDWOId() const { return DWOId; }\n  void setDWOId(uint64_t Id) {\n    assert((!DWOId || *DWOId == Id) && \"setting DWOId to a different value\");\n    DWOId = Id;\n  }\n  const DWARFUnitIndex::Entry *getIndexEntry() const { return IndexEntry; }\n  uint64_t getTypeHash() const { return TypeHash; }\n  uint64_t getTypeOffset() const { return TypeOffset; }\n  uint8_t getUnitType() const { return UnitType; }\n  bool isTypeUnit() const {\n    return UnitType == dwarf::DW_UT_type || UnitType == dwarf::DW_UT_split_type;\n  }\n  uint8_t getSize() const { return Size; }\n  uint8_t getUnitLengthFieldByteSize() const {\n    return dwarf::getUnitLengthFieldByteSize(FormParams.Format);\n  }\n  uint64_t getNextUnitOffset() const {\n    return Offset + Length + getUnitLengthFieldByteSize();\n  }\n};\n\nconst DWARFUnitIndex &getDWARFUnitIndex(DWARFContext &Context,\n                                        DWARFSectionKind Kind);\n\nbool isCompileUnit(const std::unique_ptr<DWARFUnit> &U);\n\n/// Describe a collection of units. Intended to hold all units either from\n/// .debug_info and .debug_types, or from .debug_info.dwo and .debug_types.dwo.\nclass DWARFUnitVector final : public SmallVector<std::unique_ptr<DWARFUnit>, 1> {\n  std::function<std::unique_ptr<DWARFUnit>(uint64_t, DWARFSectionKind,\n                                           const DWARFSection *,\n                                           const DWARFUnitIndex::Entry *)>\n      Parser;\n  int NumInfoUnits = -1;\n\npublic:\n  using UnitVector = SmallVectorImpl<std::unique_ptr<DWARFUnit>>;\n  using iterator = typename UnitVector::iterator;\n  using iterator_range = llvm::iterator_range<typename UnitVector::iterator>;\n\n  using compile_unit_range =\n      decltype(make_filter_range(std::declval<iterator_range>(), isCompileUnit));\n\n  DWARFUnit *getUnitForOffset(uint64_t Offset) const;\n  DWARFUnit *getUnitForIndexEntry(const DWARFUnitIndex::Entry &E);\n\n  /// Read units from a .debug_info or .debug_types section.  Calls made\n  /// before finishedInfoUnits() are assumed to be for .debug_info sections,\n  /// calls after finishedInfoUnits() are for .debug_types sections.  Caller\n  /// must not mix calls to addUnitsForSection and addUnitsForDWOSection.\n  void addUnitsForSection(DWARFContext &C, const DWARFSection &Section,\n                          DWARFSectionKind SectionKind);\n  /// Read units from a .debug_info.dwo or .debug_types.dwo section.  Calls\n  /// made before finishedInfoUnits() are assumed to be for .debug_info.dwo\n  /// sections, calls after finishedInfoUnits() are for .debug_types.dwo\n  /// sections.  Caller must not mix calls to addUnitsForSection and\n  /// addUnitsForDWOSection.\n  void addUnitsForDWOSection(DWARFContext &C, const DWARFSection &DWOSection,\n                             DWARFSectionKind SectionKind, bool Lazy = false);\n\n  /// Add an existing DWARFUnit to this UnitVector. This is used by the DWARF\n  /// verifier to process unit separately.\n  DWARFUnit *addUnit(std::unique_ptr<DWARFUnit> Unit);\n\n  /// Returns number of all units held by this instance.\n  unsigned getNumUnits() const { return size(); }\n  /// Returns number of units from all .debug_info[.dwo] sections.\n  unsigned getNumInfoUnits() const {\n    return NumInfoUnits == -1 ? size() : NumInfoUnits;\n  }\n  /// Returns number of units from all .debug_types[.dwo] sections.\n  unsigned getNumTypesUnits() const { return size() - NumInfoUnits; }\n  /// Indicate that parsing .debug_info[.dwo] is done, and remaining units\n  /// will be from .debug_types[.dwo].\n  void finishedInfoUnits() { NumInfoUnits = size(); }\n\nprivate:\n  void addUnitsImpl(DWARFContext &Context, const DWARFObject &Obj,\n                    const DWARFSection &Section, const DWARFDebugAbbrev *DA,\n                    const DWARFSection *RS, const DWARFSection *LocSection,\n                    StringRef SS, const DWARFSection &SOS,\n                    const DWARFSection *AOS, const DWARFSection &LS, bool LE,\n                    bool IsDWO, bool Lazy, DWARFSectionKind SectionKind);\n};\n\n/// Represents base address of the CU.\n/// Represents a unit's contribution to the string offsets table.\nstruct StrOffsetsContributionDescriptor {\n  uint64_t Base = 0;\n  /// The contribution size not including the header.\n  uint64_t Size = 0;\n  /// Format and version.\n  dwarf::FormParams FormParams = {0, 0, dwarf::DwarfFormat::DWARF32};\n\n  StrOffsetsContributionDescriptor(uint64_t Base, uint64_t Size,\n                                   uint8_t Version, dwarf::DwarfFormat Format)\n      : Base(Base), Size(Size), FormParams({Version, 0, Format}) {}\n  StrOffsetsContributionDescriptor() = default;\n\n  uint8_t getVersion() const { return FormParams.Version; }\n  dwarf::DwarfFormat getFormat() const { return FormParams.Format; }\n  uint8_t getDwarfOffsetByteSize() const {\n    return FormParams.getDwarfOffsetByteSize();\n  }\n  /// Determine whether a contribution to the string offsets table is\n  /// consistent with the relevant section size and that its length is\n  /// a multiple of the size of one of its entries.\n  Expected<StrOffsetsContributionDescriptor>\n  validateContributionSize(DWARFDataExtractor &DA);\n};\n\nclass DWARFUnit {\n  DWARFContext &Context;\n  /// Section containing this DWARFUnit.\n  const DWARFSection &InfoSection;\n\n  DWARFUnitHeader Header;\n  const DWARFDebugAbbrev *Abbrev;\n  const DWARFSection *RangeSection;\n  uint64_t RangeSectionBase;\n  uint64_t LocSectionBase;\n\n  /// Location table of this unit.\n  std::unique_ptr<DWARFLocationTable> LocTable;\n\n  const DWARFSection &LineSection;\n  StringRef StringSection;\n  const DWARFSection &StringOffsetSection;\n  const DWARFSection *AddrOffsetSection;\n  Optional<uint64_t> AddrOffsetSectionBase;\n  bool isLittleEndian;\n  bool IsDWO;\n  const DWARFUnitVector &UnitVector;\n\n  /// Start, length, and DWARF format of the unit's contribution to the string\n  /// offsets table (DWARF v5).\n  Optional<StrOffsetsContributionDescriptor> StringOffsetsTableContribution;\n\n  mutable const DWARFAbbreviationDeclarationSet *Abbrevs;\n  llvm::Optional<object::SectionedAddress> BaseAddr;\n  /// The compile unit debug information entry items.\n  std::vector<DWARFDebugInfoEntry> DieArray;\n\n  /// Map from range's start address to end address and corresponding DIE.\n  /// IntervalMap does not support range removal, as a result, we use the\n  /// std::map::upper_bound for address range lookup.\n  std::map<uint64_t, std::pair<uint64_t, DWARFDie>> AddrDieMap;\n\n  using die_iterator_range =\n      iterator_range<std::vector<DWARFDebugInfoEntry>::iterator>;\n\n  std::shared_ptr<DWARFUnit> DWO;\n\n  uint32_t getDIEIndex(const DWARFDebugInfoEntry *Die) {\n    auto First = DieArray.data();\n    assert(Die >= First && Die < First + DieArray.size());\n    return Die - First;\n  }\n\nprotected:\n  const DWARFUnitHeader &getHeader() const { return Header; }\n\n  /// Size in bytes of the parsed unit header.\n  uint32_t getHeaderSize() const { return Header.getSize(); }\n\n  /// Find the unit's contribution to the string offsets table and determine its\n  /// length and form. The given offset is expected to be derived from the unit\n  /// DIE's DW_AT_str_offsets_base attribute.\n  Expected<Optional<StrOffsetsContributionDescriptor>>\n  determineStringOffsetsTableContribution(DWARFDataExtractor &DA);\n\n  /// Find the unit's contribution to the string offsets table and determine its\n  /// length and form. The given offset is expected to be 0 in a dwo file or,\n  /// in a dwp file, the start of the unit's contribution to the string offsets\n  /// table section (as determined by the index table).\n  Expected<Optional<StrOffsetsContributionDescriptor>>\n  determineStringOffsetsTableContributionDWO(DWARFDataExtractor &DA);\n\npublic:\n  DWARFUnit(DWARFContext &Context, const DWARFSection &Section,\n            const DWARFUnitHeader &Header, const DWARFDebugAbbrev *DA,\n            const DWARFSection *RS, const DWARFSection *LocSection,\n            StringRef SS, const DWARFSection &SOS, const DWARFSection *AOS,\n            const DWARFSection &LS, bool LE, bool IsDWO,\n            const DWARFUnitVector &UnitVector);\n\n  virtual ~DWARFUnit();\n\n  bool isDWOUnit() const { return IsDWO; }\n  DWARFContext& getContext() const { return Context; }\n  const DWARFSection &getInfoSection() const { return InfoSection; }\n  uint64_t getOffset() const { return Header.getOffset(); }\n  const dwarf::FormParams &getFormParams() const {\n    return Header.getFormParams();\n  }\n  uint16_t getVersion() const { return Header.getVersion(); }\n  uint8_t getAddressByteSize() const { return Header.getAddressByteSize(); }\n  uint8_t getRefAddrByteSize() const { return Header.getRefAddrByteSize(); }\n  uint8_t getDwarfOffsetByteSize() const {\n    return Header.getDwarfOffsetByteSize();\n  }\n  uint64_t getLength() const { return Header.getLength(); }\n  dwarf::DwarfFormat getFormat() const { return Header.getFormat(); }\n  uint8_t getUnitType() const { return Header.getUnitType(); }\n  bool isTypeUnit() const { return Header.isTypeUnit(); }\n  uint64_t getAbbrOffset() const { return Header.getAbbrOffset(); }\n  uint64_t getNextUnitOffset() const { return Header.getNextUnitOffset(); }\n  const DWARFSection &getLineSection() const { return LineSection; }\n  StringRef getStringSection() const { return StringSection; }\n  const DWARFSection &getStringOffsetSection() const {\n    return StringOffsetSection;\n  }\n\n  void setAddrOffsetSection(const DWARFSection *AOS, uint64_t Base) {\n    AddrOffsetSection = AOS;\n    AddrOffsetSectionBase = Base;\n  }\n\n  Optional<uint64_t> getAddrOffsetSectionBase() const {\n    return AddrOffsetSectionBase;\n  }\n\n  /// Recursively update address to Die map.\n  void updateAddressDieMap(DWARFDie Die);\n\n  void setRangesSection(const DWARFSection *RS, uint64_t Base) {\n    RangeSection = RS;\n    RangeSectionBase = Base;\n  }\n\n  uint64_t getLocSectionBase() const {\n    return LocSectionBase;\n  }\n\n  Optional<object::SectionedAddress>\n  getAddrOffsetSectionItem(uint32_t Index) const;\n  Optional<uint64_t> getStringOffsetSectionItem(uint32_t Index) const;\n\n  DWARFDataExtractor getDebugInfoExtractor() const;\n\n  DataExtractor getStringExtractor() const {\n    return DataExtractor(StringSection, false, 0);\n  }\n\n  const DWARFLocationTable &getLocationTable() { return *LocTable; }\n\n  /// Extract the range list referenced by this compile unit from the\n  /// .debug_ranges section. If the extraction is unsuccessful, an error\n  /// is returned. Successful extraction requires that the compile unit\n  /// has already been extracted.\n  Error extractRangeList(uint64_t RangeListOffset,\n                         DWARFDebugRangeList &RangeList) const;\n  void clear();\n\n  const Optional<StrOffsetsContributionDescriptor> &\n  getStringOffsetsTableContribution() const {\n    return StringOffsetsTableContribution;\n  }\n\n  uint8_t getDwarfStringOffsetsByteSize() const {\n    assert(StringOffsetsTableContribution);\n    return StringOffsetsTableContribution->getDwarfOffsetByteSize();\n  }\n\n  uint64_t getStringOffsetsBase() const {\n    assert(StringOffsetsTableContribution);\n    return StringOffsetsTableContribution->Base;\n  }\n\n  const DWARFAbbreviationDeclarationSet *getAbbreviations() const;\n\n  static bool isMatchingUnitTypeAndTag(uint8_t UnitType, dwarf::Tag Tag) {\n    switch (UnitType) {\n    case dwarf::DW_UT_compile:\n      return Tag == dwarf::DW_TAG_compile_unit;\n    case dwarf::DW_UT_type:\n      return Tag == dwarf::DW_TAG_type_unit;\n    case dwarf::DW_UT_partial:\n      return Tag == dwarf::DW_TAG_partial_unit;\n    case dwarf::DW_UT_skeleton:\n      return Tag == dwarf::DW_TAG_skeleton_unit;\n    case dwarf::DW_UT_split_compile:\n    case dwarf::DW_UT_split_type:\n      return dwarf::isUnitType(Tag);\n    }\n    return false;\n  }\n\n  llvm::Optional<object::SectionedAddress> getBaseAddress();\n\n  DWARFDie getUnitDIE(bool ExtractUnitDIEOnly = true) {\n    extractDIEsIfNeeded(ExtractUnitDIEOnly);\n    if (DieArray.empty())\n      return DWARFDie();\n    return DWARFDie(this, &DieArray[0]);\n  }\n\n  DWARFDie getNonSkeletonUnitDIE(bool ExtractUnitDIEOnly = true) {\n    parseDWO();\n    if (DWO)\n      return DWO->getUnitDIE(ExtractUnitDIEOnly);\n    return getUnitDIE(ExtractUnitDIEOnly);\n  }\n\n  const char *getCompilationDir();\n  Optional<uint64_t> getDWOId() {\n    extractDIEsIfNeeded(/*CUDieOnly*/ true);\n    return getHeader().getDWOId();\n  }\n  void setDWOId(uint64_t NewID) { Header.setDWOId(NewID); }\n\n  /// Return a vector of address ranges resulting from a (possibly encoded)\n  /// range list starting at a given offset in the appropriate ranges section.\n  Expected<DWARFAddressRangesVector> findRnglistFromOffset(uint64_t Offset);\n\n  /// Return a vector of address ranges retrieved from an encoded range\n  /// list whose offset is found via a table lookup given an index (DWARF v5\n  /// and later).\n  Expected<DWARFAddressRangesVector> findRnglistFromIndex(uint32_t Index);\n\n  /// Return a rangelist's offset based on an index. The index designates\n  /// an entry in the rangelist table's offset array and is supplied by\n  /// DW_FORM_rnglistx.\n  Optional<uint64_t> getRnglistOffset(uint32_t Index);\n\n  Optional<uint64_t> getLoclistOffset(uint32_t Index);\n\n  Expected<DWARFAddressRangesVector> collectAddressRanges();\n\n  Expected<DWARFLocationExpressionsVector>\n  findLoclistFromOffset(uint64_t Offset);\n\n  /// Returns subprogram DIE with address range encompassing the provided\n  /// address. The pointer is alive as long as parsed compile unit DIEs are not\n  /// cleared.\n  DWARFDie getSubroutineForAddress(uint64_t Address);\n\n  /// getInlinedChainForAddress - fetches inlined chain for a given address.\n  /// Returns empty chain if there is no subprogram containing address. The\n  /// chain is valid as long as parsed compile unit DIEs are not cleared.\n  void getInlinedChainForAddress(uint64_t Address,\n                                 SmallVectorImpl<DWARFDie> &InlinedChain);\n\n  /// Return the DWARFUnitVector containing this unit.\n  const DWARFUnitVector &getUnitVector() const { return UnitVector; }\n\n  /// Returns the number of DIEs in the unit. Parses the unit\n  /// if necessary.\n  unsigned getNumDIEs() {\n    extractDIEsIfNeeded(false);\n    return DieArray.size();\n  }\n\n  /// Return the index of a DIE inside the unit's DIE vector.\n  ///\n  /// It is illegal to call this method with a DIE that hasn't be\n  /// created by this unit. In other word, it's illegal to call this\n  /// method on a DIE that isn't accessible by following\n  /// children/sibling links starting from this unit's getUnitDIE().\n  uint32_t getDIEIndex(const DWARFDie &D) {\n    return getDIEIndex(D.getDebugInfoEntry());\n  }\n\n  /// Return the DIE object at the given index.\n  DWARFDie getDIEAtIndex(unsigned Index) {\n    assert(Index < DieArray.size());\n    return DWARFDie(this, &DieArray[Index]);\n  }\n\n  DWARFDie getParent(const DWARFDebugInfoEntry *Die);\n  DWARFDie getSibling(const DWARFDebugInfoEntry *Die);\n  DWARFDie getPreviousSibling(const DWARFDebugInfoEntry *Die);\n  DWARFDie getFirstChild(const DWARFDebugInfoEntry *Die);\n  DWARFDie getLastChild(const DWARFDebugInfoEntry *Die);\n\n  /// Return the DIE object for a given offset inside the\n  /// unit's DIE vector.\n  ///\n  /// The unit needs to have its DIEs extracted for this method to work.\n  DWARFDie getDIEForOffset(uint64_t Offset) {\n    extractDIEsIfNeeded(false);\n    auto It =\n        llvm::partition_point(DieArray, [=](const DWARFDebugInfoEntry &DIE) {\n          return DIE.getOffset() < Offset;\n        });\n    if (It != DieArray.end() && It->getOffset() == Offset)\n      return DWARFDie(this, &*It);\n    return DWARFDie();\n  }\n\n  uint32_t getLineTableOffset() const {\n    if (auto IndexEntry = Header.getIndexEntry())\n      if (const auto *Contrib = IndexEntry->getContribution(DW_SECT_LINE))\n        return Contrib->Offset;\n    return 0;\n  }\n\n  die_iterator_range dies() {\n    extractDIEsIfNeeded(false);\n    return die_iterator_range(DieArray.begin(), DieArray.end());\n  }\n\n  virtual void dump(raw_ostream &OS, DIDumpOptions DumpOpts) = 0;\n\n  Error tryExtractDIEsIfNeeded(bool CUDieOnly);\n\nprivate:\n  /// Size in bytes of the .debug_info data associated with this compile unit.\n  size_t getDebugInfoSize() const {\n    return Header.getLength() + Header.getUnitLengthFieldByteSize() -\n           getHeaderSize();\n  }\n\n  /// extractDIEsIfNeeded - Parses a compile unit and indexes its DIEs if it\n  /// hasn't already been done\n  void extractDIEsIfNeeded(bool CUDieOnly);\n\n  /// extractDIEsToVector - Appends all parsed DIEs to a vector.\n  void extractDIEsToVector(bool AppendCUDie, bool AppendNonCUDIEs,\n                           std::vector<DWARFDebugInfoEntry> &DIEs) const;\n\n  /// clearDIEs - Clear parsed DIEs to keep memory usage low.\n  void clearDIEs(bool KeepCUDie);\n\n  /// parseDWO - Parses .dwo file for current compile unit. Returns true if\n  /// it was actually constructed.\n  bool parseDWO();\n};\n\ninline bool isCompileUnit(const std::unique_ptr<DWARFUnit> &U) {\n  return !U->isTypeUnit();\n}\n\n} // end namespace llvm\n\n#endif // LLVM_DEBUGINFO_DWARF_DWARFUNIT_H\n"}, "29": {"id": 29, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/DebugInfo/DWARF/DWARFUnitIndex.h", "content": "//===- DWARFUnitIndex.h -----------------------------------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_DEBUGINFO_DWARF_DWARFUNITINDEX_H\n#define LLVM_DEBUGINFO_DWARF_DWARFUNITINDEX_H\n\n#include \"llvm/ADT/ArrayRef.h\"\n#include \"llvm/ADT/StringRef.h\"\n#include \"llvm/Support/DataExtractor.h\"\n#include <cstdint>\n#include <memory>\n\nnamespace llvm {\n\nclass raw_ostream;\n\n/// The enum of section identifiers to be used in internal interfaces.\n///\n/// Pre-standard implementation of package files defined a number of section\n/// identifiers with values that clash definitions in the DWARFv5 standard.\n/// See https://gcc.gnu.org/wiki/DebugFissionDWP and Section 7.3.5.3 in DWARFv5.\n///\n/// The following identifiers are the same in the proposal and in DWARFv5:\n/// - DW_SECT_INFO         = 1 (.debug_info.dwo)\n/// - DW_SECT_ABBREV       = 3 (.debug_abbrev.dwo)\n/// - DW_SECT_LINE         = 4 (.debug_line.dwo)\n/// - DW_SECT_STR_OFFSETS  = 6 (.debug_str_offsets.dwo)\n///\n/// The following identifiers are defined only in DWARFv5:\n/// - DW_SECT_LOCLISTS     = 5 (.debug_loclists.dwo)\n/// - DW_SECT_RNGLISTS     = 8 (.debug_rnglists.dwo)\n///\n/// The following identifiers are defined only in the GNU proposal:\n/// - DW_SECT_TYPES        = 2 (.debug_types.dwo)\n/// - DW_SECT_LOC          = 5 (.debug_loc.dwo)\n/// - DW_SECT_MACINFO      = 7 (.debug_macinfo.dwo)\n///\n/// DW_SECT_MACRO for the .debug_macro.dwo section is defined in both standards,\n/// but with different values, 8 in GNU and 7 in DWARFv5.\n///\n/// This enum defines constants to represent the identifiers of both sets.\n/// For DWARFv5 ones, the values are the same as defined in the standard.\n/// For pre-standard ones that correspond to sections being deprecated in\n/// DWARFv5, the values are chosen arbitrary and a tag \"_EXT_\" is added to\n/// the names.\n///\n/// The enum is for internal use only. The user should not expect the values\n/// to correspond to any input/output constants. Special conversion functions,\n/// serializeSectionKind() and deserializeSectionKind(), should be used for\n/// the translation.\nenum DWARFSectionKind {\n  /// Denotes a value read from an index section that does not correspond\n  /// to any of the supported standards.\n  DW_SECT_EXT_unknown = 0,\n#define HANDLE_DW_SECT(ID, NAME) DW_SECT_##NAME = ID,\n#include \"llvm/BinaryFormat/Dwarf.def\"\n  DW_SECT_EXT_TYPES = 2,\n  DW_SECT_EXT_LOC = 9,\n  DW_SECT_EXT_MACINFO = 10,\n};\n\n/// Convert the internal value for a section kind to an on-disk value.\n///\n/// The conversion depends on the version of the index section.\n/// IndexVersion is expected to be either 2 for pre-standard GNU proposal\n/// or 5 for DWARFv5 package file.\nuint32_t serializeSectionKind(DWARFSectionKind Kind, unsigned IndexVersion);\n\n/// Convert a value read from an index section to the internal representation.\n///\n/// The conversion depends on the index section version, which is expected\n/// to be either 2 for pre-standard GNU proposal or 5 for DWARFv5 package file.\nDWARFSectionKind deserializeSectionKind(uint32_t Value, unsigned IndexVersion);\n\nclass DWARFUnitIndex {\n  struct Header {\n    uint32_t Version;\n    uint32_t NumColumns;\n    uint32_t NumUnits;\n    uint32_t NumBuckets = 0;\n\n    bool parse(DataExtractor IndexData, uint64_t *OffsetPtr);\n    void dump(raw_ostream &OS) const;\n  };\n\npublic:\n  class Entry {\n  public:\n    struct SectionContribution {\n      uint32_t Offset;\n      uint32_t Length;\n    };\n\n  private:\n    const DWARFUnitIndex *Index;\n    uint64_t Signature;\n    std::unique_ptr<SectionContribution[]> Contributions;\n    friend class DWARFUnitIndex;\n\n  public:\n    const SectionContribution *getContribution(DWARFSectionKind Sec) const;\n    const SectionContribution *getContribution() const;\n\n    const SectionContribution *getContributions() const {\n      return Contributions.get();\n    }\n\n    uint64_t getSignature() const { return Signature; }\n  };\n\nprivate:\n  struct Header Header;\n\n  DWARFSectionKind InfoColumnKind;\n  int InfoColumn = -1;\n  std::unique_ptr<DWARFSectionKind[]> ColumnKinds;\n  // This is a parallel array of section identifiers as they read from the input\n  // file. The mapping from raw values to DWARFSectionKind is not revertable in\n  // case of unknown identifiers, so we keep them here.\n  std::unique_ptr<uint32_t[]> RawSectionIds;\n  std::unique_ptr<Entry[]> Rows;\n  mutable std::vector<Entry *> OffsetLookup;\n\n  static StringRef getColumnHeader(DWARFSectionKind DS);\n\n  bool parseImpl(DataExtractor IndexData);\n\npublic:\n  DWARFUnitIndex(DWARFSectionKind InfoColumnKind)\n      : InfoColumnKind(InfoColumnKind) {}\n\n  explicit operator bool() const { return Header.NumBuckets; }\n\n  bool parse(DataExtractor IndexData);\n  void dump(raw_ostream &OS) const;\n\n  uint32_t getVersion() const { return Header.Version; }\n\n  const Entry *getFromOffset(uint32_t Offset) const;\n  const Entry *getFromHash(uint64_t Offset) const;\n\n  ArrayRef<DWARFSectionKind> getColumnKinds() const {\n    return makeArrayRef(ColumnKinds.get(), Header.NumColumns);\n  }\n\n  ArrayRef<Entry> getRows() const {\n    return makeArrayRef(Rows.get(), Header.NumBuckets);\n  }\n};\n\n} // end namespace llvm\n\n#endif // LLVM_DEBUGINFO_DWARF_DWARFUNITINDEX_H\n"}, "30": {"id": 30, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/MC/MCExpr.h", "content": "//===- MCExpr.h - Assembly Level Expressions --------------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_MC_MCEXPR_H\n#define LLVM_MC_MCEXPR_H\n\n#include \"llvm/ADT/DenseMap.h\"\n#include \"llvm/Support/SMLoc.h\"\n#include <cstdint>\n\nnamespace llvm {\n\nclass MCAsmInfo;\nclass MCAsmLayout;\nclass MCAssembler;\nclass MCContext;\nclass MCFixup;\nclass MCFragment;\nclass MCSection;\nclass MCStreamer;\nclass MCSymbol;\nclass MCValue;\nclass raw_ostream;\nclass StringRef;\n\nusing SectionAddrMap = DenseMap<const MCSection *, uint64_t>;\n\n/// Base class for the full range of assembler expressions which are\n/// needed for parsing.\nclass MCExpr {\npublic:\n  enum ExprKind : uint8_t {\n    Binary,    ///< Binary expressions.\n    Constant,  ///< Constant expressions.\n    SymbolRef, ///< References to labels and assigned expressions.\n    Unary,     ///< Unary expressions.\n    Target     ///< Target specific expression.\n  };\n\nprivate:\n  static const unsigned NumSubclassDataBits = 24;\n  static_assert(\n      NumSubclassDataBits == CHAR_BIT * (sizeof(unsigned) - sizeof(ExprKind)),\n      \"ExprKind and SubclassData together should take up one word\");\n\n  ExprKind Kind;\n  /// Field reserved for use by MCExpr subclasses.\n  unsigned SubclassData : NumSubclassDataBits;\n  SMLoc Loc;\n\n  bool evaluateAsAbsolute(int64_t &Res, const MCAssembler *Asm,\n                          const MCAsmLayout *Layout,\n                          const SectionAddrMap *Addrs, bool InSet) const;\n\nprotected:\n  explicit MCExpr(ExprKind Kind, SMLoc Loc, unsigned SubclassData = 0)\n      : Kind(Kind), SubclassData(SubclassData), Loc(Loc) {\n    assert(SubclassData < (1 << NumSubclassDataBits) &&\n           \"Subclass data too large\");\n  }\n\n  bool evaluateAsRelocatableImpl(MCValue &Res, const MCAssembler *Asm,\n                                 const MCAsmLayout *Layout,\n                                 const MCFixup *Fixup,\n                                 const SectionAddrMap *Addrs, bool InSet) const;\n\n  unsigned getSubclassData() const { return SubclassData; }\n\npublic:\n  MCExpr(const MCExpr &) = delete;\n  MCExpr &operator=(const MCExpr &) = delete;\n\n  /// \\name Accessors\n  /// @{\n\n  ExprKind getKind() const { return Kind; }\n  SMLoc getLoc() const { return Loc; }\n\n  /// @}\n  /// \\name Utility Methods\n  /// @{\n\n  void print(raw_ostream &OS, const MCAsmInfo *MAI,\n             bool InParens = false) const;\n  void dump() const;\n\n  /// @}\n  /// \\name Expression Evaluation\n  /// @{\n\n  /// Try to evaluate the expression to an absolute value.\n  ///\n  /// \\param Res - The absolute value, if evaluation succeeds.\n  /// \\param Layout - The assembler layout object to use for evaluating symbol\n  /// values. If not given, then only non-symbolic expressions will be\n  /// evaluated.\n  /// \\return - True on success.\n  bool evaluateAsAbsolute(int64_t &Res, const MCAsmLayout &Layout,\n                          const SectionAddrMap &Addrs) const;\n  bool evaluateAsAbsolute(int64_t &Res) const;\n  bool evaluateAsAbsolute(int64_t &Res, const MCAssembler &Asm) const;\n  bool evaluateAsAbsolute(int64_t &Res, const MCAssembler *Asm) const;\n  bool evaluateAsAbsolute(int64_t &Res, const MCAsmLayout &Layout) const;\n\n  bool evaluateKnownAbsolute(int64_t &Res, const MCAsmLayout &Layout) const;\n\n  /// Try to evaluate the expression to a relocatable value, i.e. an\n  /// expression of the fixed form (a - b + constant).\n  ///\n  /// \\param Res - The relocatable value, if evaluation succeeds.\n  /// \\param Layout - The assembler layout object to use for evaluating values.\n  /// \\param Fixup - The Fixup object if available.\n  /// \\return - True on success.\n  bool evaluateAsRelocatable(MCValue &Res, const MCAsmLayout *Layout,\n                             const MCFixup *Fixup) const;\n\n  /// Try to evaluate the expression to the form (a - b + constant) where\n  /// neither a nor b are variables.\n  ///\n  /// This is a more aggressive variant of evaluateAsRelocatable. The intended\n  /// use is for when relocations are not available, like the .size directive.\n  bool evaluateAsValue(MCValue &Res, const MCAsmLayout &Layout) const;\n\n  /// Find the \"associated section\" for this expression, which is\n  /// currently defined as the absolute section for constants, or\n  /// otherwise the section associated with the first defined symbol in the\n  /// expression.\n  MCFragment *findAssociatedFragment() const;\n\n  /// @}\n};\n\ninline raw_ostream &operator<<(raw_ostream &OS, const MCExpr &E) {\n  E.print(OS, nullptr);\n  return OS;\n}\n\n////  Represent a constant integer expression.\nclass MCConstantExpr : public MCExpr {\n  int64_t Value;\n\n  // Subclass data stores SizeInBytes in bits 0..7 and PrintInHex in bit 8.\n  static const unsigned SizeInBytesBits = 8;\n  static const unsigned SizeInBytesMask = (1 << SizeInBytesBits) - 1;\n  static const unsigned PrintInHexBit = 1 << SizeInBytesBits;\n\n  static unsigned encodeSubclassData(bool PrintInHex, unsigned SizeInBytes) {\n    assert(SizeInBytes <= sizeof(int64_t) && \"Excessive size\");\n    return SizeInBytes | (PrintInHex ? PrintInHexBit : 0);\n  }\n\n  MCConstantExpr(int64_t Value, bool PrintInHex, unsigned SizeInBytes)\n      : MCExpr(MCExpr::Constant, SMLoc(),\n               encodeSubclassData(PrintInHex, SizeInBytes)), Value(Value) {}\n\npublic:\n  /// \\name Construction\n  /// @{\n\n  static const MCConstantExpr *create(int64_t Value, MCContext &Ctx,\n                                      bool PrintInHex = false,\n                                      unsigned SizeInBytes = 0);\n\n  /// @}\n  /// \\name Accessors\n  /// @{\n\n  int64_t getValue() const { return Value; }\n  unsigned getSizeInBytes() const {\n    return getSubclassData() & SizeInBytesMask;\n  }\n\n  bool useHexFormat() const { return (getSubclassData() & PrintInHexBit) != 0; }\n\n  /// @}\n\n  static bool classof(const MCExpr *E) {\n    return E->getKind() == MCExpr::Constant;\n  }\n};\n\n///  Represent a reference to a symbol from inside an expression.\n///\n/// A symbol reference in an expression may be a use of a label, a use of an\n/// assembler variable (defined constant), or constitute an implicit definition\n/// of the symbol as external.\nclass MCSymbolRefExpr : public MCExpr {\npublic:\n  enum VariantKind : uint16_t {\n    VK_None,\n    VK_Invalid,\n\n    VK_GOT,\n    VK_GOTOFF,\n    VK_GOTREL,\n    VK_PCREL,\n    VK_GOTPCREL,\n    VK_GOTTPOFF,\n    VK_INDNTPOFF,\n    VK_NTPOFF,\n    VK_GOTNTPOFF,\n    VK_PLT,\n    VK_TLSGD,\n    VK_TLSLD,\n    VK_TLSLDM,\n    VK_TPOFF,\n    VK_DTPOFF,\n    VK_TLSCALL, // symbol(tlscall)\n    VK_TLSDESC, // symbol(tlsdesc)\n    VK_TLVP,    // Mach-O thread local variable relocations\n    VK_TLVPPAGE,\n    VK_TLVPPAGEOFF,\n    VK_PAGE,\n    VK_PAGEOFF,\n    VK_GOTPAGE,\n    VK_GOTPAGEOFF,\n    VK_SECREL,\n    VK_SIZE,    // symbol@SIZE\n    VK_WEAKREF, // The link between the symbols in .weakref foo, bar\n\n    VK_X86_ABS8,\n    VK_X86_PLTOFF,\n\n    VK_ARM_NONE,\n    VK_ARM_GOT_PREL,\n    VK_ARM_TARGET1,\n    VK_ARM_TARGET2,\n    VK_ARM_PREL31,\n    VK_ARM_SBREL,  // symbol(sbrel)\n    VK_ARM_TLSLDO, // symbol(tlsldo)\n    VK_ARM_TLSDESCSEQ,\n\n    VK_AVR_NONE,\n    VK_AVR_LO8,\n    VK_AVR_HI8,\n    VK_AVR_HLO8,\n    VK_AVR_DIFF8,\n    VK_AVR_DIFF16,\n    VK_AVR_DIFF32,\n    VK_AVR_PM,\n\n    VK_PPC_LO,              // symbol@l\n    VK_PPC_HI,              // symbol@h\n    VK_PPC_HA,              // symbol@ha\n    VK_PPC_HIGH,            // symbol@high\n    VK_PPC_HIGHA,           // symbol@higha\n    VK_PPC_HIGHER,          // symbol@higher\n    VK_PPC_HIGHERA,         // symbol@highera\n    VK_PPC_HIGHEST,         // symbol@highest\n    VK_PPC_HIGHESTA,        // symbol@highesta\n    VK_PPC_GOT_LO,          // symbol@got@l\n    VK_PPC_GOT_HI,          // symbol@got@h\n    VK_PPC_GOT_HA,          // symbol@got@ha\n    VK_PPC_TOCBASE,         // symbol@tocbase\n    VK_PPC_TOC,             // symbol@toc\n    VK_PPC_TOC_LO,          // symbol@toc@l\n    VK_PPC_TOC_HI,          // symbol@toc@h\n    VK_PPC_TOC_HA,          // symbol@toc@ha\n    VK_PPC_U,               // symbol@u\n    VK_PPC_L,               // symbol@l\n    VK_PPC_DTPMOD,          // symbol@dtpmod\n    VK_PPC_TPREL_LO,        // symbol@tprel@l\n    VK_PPC_TPREL_HI,        // symbol@tprel@h\n    VK_PPC_TPREL_HA,        // symbol@tprel@ha\n    VK_PPC_TPREL_HIGH,      // symbol@tprel@high\n    VK_PPC_TPREL_HIGHA,     // symbol@tprel@higha\n    VK_PPC_TPREL_HIGHER,    // symbol@tprel@higher\n    VK_PPC_TPREL_HIGHERA,   // symbol@tprel@highera\n    VK_PPC_TPREL_HIGHEST,   // symbol@tprel@highest\n    VK_PPC_TPREL_HIGHESTA,  // symbol@tprel@highesta\n    VK_PPC_DTPREL_LO,       // symbol@dtprel@l\n    VK_PPC_DTPREL_HI,       // symbol@dtprel@h\n    VK_PPC_DTPREL_HA,       // symbol@dtprel@ha\n    VK_PPC_DTPREL_HIGH,     // symbol@dtprel@high\n    VK_PPC_DTPREL_HIGHA,    // symbol@dtprel@higha\n    VK_PPC_DTPREL_HIGHER,   // symbol@dtprel@higher\n    VK_PPC_DTPREL_HIGHERA,  // symbol@dtprel@highera\n    VK_PPC_DTPREL_HIGHEST,  // symbol@dtprel@highest\n    VK_PPC_DTPREL_HIGHESTA, // symbol@dtprel@highesta\n    VK_PPC_GOT_TPREL,       // symbol@got@tprel\n    VK_PPC_GOT_TPREL_LO,    // symbol@got@tprel@l\n    VK_PPC_GOT_TPREL_HI,    // symbol@got@tprel@h\n    VK_PPC_GOT_TPREL_HA,    // symbol@got@tprel@ha\n    VK_PPC_GOT_DTPREL,      // symbol@got@dtprel\n    VK_PPC_GOT_DTPREL_LO,   // symbol@got@dtprel@l\n    VK_PPC_GOT_DTPREL_HI,   // symbol@got@dtprel@h\n    VK_PPC_GOT_DTPREL_HA,   // symbol@got@dtprel@ha\n    VK_PPC_TLS,             // symbol@tls\n    VK_PPC_GOT_TLSGD,       // symbol@got@tlsgd\n    VK_PPC_GOT_TLSGD_LO,    // symbol@got@tlsgd@l\n    VK_PPC_GOT_TLSGD_HI,    // symbol@got@tlsgd@h\n    VK_PPC_GOT_TLSGD_HA,    // symbol@got@tlsgd@ha\n    VK_PPC_TLSGD,           // symbol@tlsgd\n    VK_PPC_GOT_TLSLD,       // symbol@got@tlsld\n    VK_PPC_GOT_TLSLD_LO,    // symbol@got@tlsld@l\n    VK_PPC_GOT_TLSLD_HI,    // symbol@got@tlsld@h\n    VK_PPC_GOT_TLSLD_HA,    // symbol@got@tlsld@ha\n    VK_PPC_GOT_PCREL,       // symbol@got@pcrel\n    VK_PPC_GOT_TLSGD_PCREL, // symbol@got@tlsgd@pcrel\n    VK_PPC_GOT_TLSLD_PCREL, // symbol@got@tlsld@pcrel\n    VK_PPC_GOT_TPREL_PCREL, // symbol@got@tprel@pcrel\n    VK_PPC_TLS_PCREL,       // symbol@tls@pcrel\n    VK_PPC_TLSLD,           // symbol@tlsld\n    VK_PPC_LOCAL,           // symbol@local\n    VK_PPC_NOTOC,           // symbol@notoc\n    VK_PPC_PCREL_OPT,       // .reloc expr, R_PPC64_PCREL_OPT, expr\n\n    VK_COFF_IMGREL32, // symbol@imgrel (image-relative)\n\n    VK_Hexagon_LO16,\n    VK_Hexagon_HI16,\n    VK_Hexagon_GPREL,\n    VK_Hexagon_GD_GOT,\n    VK_Hexagon_LD_GOT,\n    VK_Hexagon_GD_PLT,\n    VK_Hexagon_LD_PLT,\n    VK_Hexagon_IE,\n    VK_Hexagon_IE_GOT,\n\n    VK_WASM_TYPEINDEX, // Reference to a symbol's type (signature)\n    VK_WASM_TLSREL,    // Memory address relative to __tls_base\n    VK_WASM_MBREL,     // Memory address relative to __memory_base\n    VK_WASM_TBREL,     // Table index relative to __table_base\n\n    VK_AMDGPU_GOTPCREL32_LO, // symbol@gotpcrel32@lo\n    VK_AMDGPU_GOTPCREL32_HI, // symbol@gotpcrel32@hi\n    VK_AMDGPU_REL32_LO,      // symbol@rel32@lo\n    VK_AMDGPU_REL32_HI,      // symbol@rel32@hi\n    VK_AMDGPU_REL64,         // symbol@rel64\n    VK_AMDGPU_ABS32_LO,      // symbol@abs32@lo\n    VK_AMDGPU_ABS32_HI,      // symbol@abs32@hi\n\n    VK_VE_HI32,        // symbol@hi\n    VK_VE_LO32,        // symbol@lo\n    VK_VE_PC_HI32,     // symbol@pc_hi\n    VK_VE_PC_LO32,     // symbol@pc_lo\n    VK_VE_GOT_HI32,    // symbol@got_hi\n    VK_VE_GOT_LO32,    // symbol@got_lo\n    VK_VE_GOTOFF_HI32, // symbol@gotoff_hi\n    VK_VE_GOTOFF_LO32, // symbol@gotoff_lo\n    VK_VE_PLT_HI32,    // symbol@plt_hi\n    VK_VE_PLT_LO32,    // symbol@plt_lo\n    VK_VE_TLS_GD_HI32, // symbol@tls_gd_hi\n    VK_VE_TLS_GD_LO32, // symbol@tls_gd_lo\n    VK_VE_TPOFF_HI32,  // symbol@tpoff_hi\n    VK_VE_TPOFF_LO32,  // symbol@tpoff_lo\n\n    VK_TPREL,\n    VK_DTPREL\n  };\n\nprivate:\n  /// The symbol being referenced.\n  const MCSymbol *Symbol;\n\n  // Subclass data stores VariantKind in bits 0..15 and HasSubsectionsViaSymbols\n  // in bit 16.\n  static const unsigned VariantKindBits = 16;\n  static const unsigned VariantKindMask = (1 << VariantKindBits) - 1;\n\n  // FIXME: Remove this bit.\n  static const unsigned HasSubsectionsViaSymbolsBit = 1 << VariantKindBits;\n\n  static unsigned encodeSubclassData(VariantKind Kind,\n                                     bool HasSubsectionsViaSymbols) {\n    return (unsigned)Kind |\n           (HasSubsectionsViaSymbols ? HasSubsectionsViaSymbolsBit : 0);\n  }\n\n  explicit MCSymbolRefExpr(const MCSymbol *Symbol, VariantKind Kind,\n                           const MCAsmInfo *MAI, SMLoc Loc = SMLoc());\n\npublic:\n  /// \\name Construction\n  /// @{\n\n  static const MCSymbolRefExpr *create(const MCSymbol *Symbol, MCContext &Ctx) {\n    return MCSymbolRefExpr::create(Symbol, VK_None, Ctx);\n  }\n\n  static const MCSymbolRefExpr *create(const MCSymbol *Symbol, VariantKind Kind,\n                                       MCContext &Ctx, SMLoc Loc = SMLoc());\n  static const MCSymbolRefExpr *create(StringRef Name, VariantKind Kind,\n                                       MCContext &Ctx);\n\n  /// @}\n  /// \\name Accessors\n  /// @{\n\n  const MCSymbol &getSymbol() const { return *Symbol; }\n\n  VariantKind getKind() const {\n    return (VariantKind)(getSubclassData() & VariantKindMask);\n  }\n\n  bool hasSubsectionsViaSymbols() const {\n    return (getSubclassData() & HasSubsectionsViaSymbolsBit) != 0;\n  }\n\n  /// @}\n  /// \\name Static Utility Functions\n  /// @{\n\n  static StringRef getVariantKindName(VariantKind Kind);\n\n  static VariantKind getVariantKindForName(StringRef Name);\n\n  /// @}\n\n  static bool classof(const MCExpr *E) {\n    return E->getKind() == MCExpr::SymbolRef;\n  }\n};\n\n/// Unary assembler expressions.\nclass MCUnaryExpr : public MCExpr {\npublic:\n  enum Opcode {\n    LNot,  ///< Logical negation.\n    Minus, ///< Unary minus.\n    Not,   ///< Bitwise negation.\n    Plus   ///< Unary plus.\n  };\n\nprivate:\n  const MCExpr *Expr;\n\n  MCUnaryExpr(Opcode Op, const MCExpr *Expr, SMLoc Loc)\n      : MCExpr(MCExpr::Unary, Loc, Op), Expr(Expr) {}\n\npublic:\n  /// \\name Construction\n  /// @{\n\n  static const MCUnaryExpr *create(Opcode Op, const MCExpr *Expr,\n                                   MCContext &Ctx, SMLoc Loc = SMLoc());\n\n  static const MCUnaryExpr *createLNot(const MCExpr *Expr, MCContext &Ctx, SMLoc Loc = SMLoc()) {\n    return create(LNot, Expr, Ctx, Loc);\n  }\n\n  static const MCUnaryExpr *createMinus(const MCExpr *Expr, MCContext &Ctx, SMLoc Loc = SMLoc()) {\n    return create(Minus, Expr, Ctx, Loc);\n  }\n\n  static const MCUnaryExpr *createNot(const MCExpr *Expr, MCContext &Ctx, SMLoc Loc = SMLoc()) {\n    return create(Not, Expr, Ctx, Loc);\n  }\n\n  static const MCUnaryExpr *createPlus(const MCExpr *Expr, MCContext &Ctx, SMLoc Loc = SMLoc()) {\n    return create(Plus, Expr, Ctx, Loc);\n  }\n\n  /// @}\n  /// \\name Accessors\n  /// @{\n\n  /// Get the kind of this unary expression.\n  Opcode getOpcode() const { return (Opcode)getSubclassData(); }\n\n  /// Get the child of this unary expression.\n  const MCExpr *getSubExpr() const { return Expr; }\n\n  /// @}\n\n  static bool classof(const MCExpr *E) {\n    return E->getKind() == MCExpr::Unary;\n  }\n};\n\n/// Binary assembler expressions.\nclass MCBinaryExpr : public MCExpr {\npublic:\n  enum Opcode {\n    Add,  ///< Addition.\n    And,  ///< Bitwise and.\n    Div,  ///< Signed division.\n    EQ,   ///< Equality comparison.\n    GT,   ///< Signed greater than comparison (result is either 0 or some\n          ///< target-specific non-zero value)\n    GTE,  ///< Signed greater than or equal comparison (result is either 0 or\n          ///< some target-specific non-zero value).\n    LAnd, ///< Logical and.\n    LOr,  ///< Logical or.\n    LT,   ///< Signed less than comparison (result is either 0 or\n          ///< some target-specific non-zero value).\n    LTE,  ///< Signed less than or equal comparison (result is either 0 or\n          ///< some target-specific non-zero value).\n    Mod,  ///< Signed remainder.\n    Mul,  ///< Multiplication.\n    NE,   ///< Inequality comparison.\n    Or,   ///< Bitwise or.\n    OrNot, ///< Bitwise or not.\n    Shl,  ///< Shift left.\n    AShr, ///< Arithmetic shift right.\n    LShr, ///< Logical shift right.\n    Sub,  ///< Subtraction.\n    Xor   ///< Bitwise exclusive or.\n  };\n\nprivate:\n  const MCExpr *LHS, *RHS;\n\n  MCBinaryExpr(Opcode Op, const MCExpr *LHS, const MCExpr *RHS,\n               SMLoc Loc = SMLoc())\n      : MCExpr(MCExpr::Binary, Loc, Op), LHS(LHS), RHS(RHS) {}\n\npublic:\n  /// \\name Construction\n  /// @{\n\n  static const MCBinaryExpr *create(Opcode Op, const MCExpr *LHS,\n                                    const MCExpr *RHS, MCContext &Ctx,\n                                    SMLoc Loc = SMLoc());\n\n  static const MCBinaryExpr *createAdd(const MCExpr *LHS, const MCExpr *RHS,\n                                       MCContext &Ctx) {\n    return create(Add, LHS, RHS, Ctx);\n  }\n\n  static const MCBinaryExpr *createAnd(const MCExpr *LHS, const MCExpr *RHS,\n                                       MCContext &Ctx) {\n    return create(And, LHS, RHS, Ctx);\n  }\n\n  static const MCBinaryExpr *createDiv(const MCExpr *LHS, const MCExpr *RHS,\n                                       MCContext &Ctx) {\n    return create(Div, LHS, RHS, Ctx);\n  }\n\n  static const MCBinaryExpr *createEQ(const MCExpr *LHS, const MCExpr *RHS,\n                                      MCContext &Ctx) {\n    return create(EQ, LHS, RHS, Ctx);\n  }\n\n  static const MCBinaryExpr *createGT(const MCExpr *LHS, const MCExpr *RHS,\n                                      MCContext &Ctx) {\n    return create(GT, LHS, RHS, Ctx);\n  }\n\n  static const MCBinaryExpr *createGTE(const MCExpr *LHS, const MCExpr *RHS,\n                                       MCContext &Ctx) {\n    return create(GTE, LHS, RHS, Ctx);\n  }\n\n  static const MCBinaryExpr *createLAnd(const MCExpr *LHS, const MCExpr *RHS,\n                                        MCContext &Ctx) {\n    return create(LAnd, LHS, RHS, Ctx);\n  }\n\n  static const MCBinaryExpr *createLOr(const MCExpr *LHS, const MCExpr *RHS,\n                                       MCContext &Ctx) {\n    return create(LOr, LHS, RHS, Ctx);\n  }\n\n  static const MCBinaryExpr *createLT(const MCExpr *LHS, const MCExpr *RHS,\n                                      MCContext &Ctx) {\n    return create(LT, LHS, RHS, Ctx);\n  }\n\n  static const MCBinaryExpr *createLTE(const MCExpr *LHS, const MCExpr *RHS,\n                                       MCContext &Ctx) {\n    return create(LTE, LHS, RHS, Ctx);\n  }\n\n  static const MCBinaryExpr *createMod(const MCExpr *LHS, const MCExpr *RHS,\n                                       MCContext &Ctx) {\n    return create(Mod, LHS, RHS, Ctx);\n  }\n\n  static const MCBinaryExpr *createMul(const MCExpr *LHS, const MCExpr *RHS,\n                                       MCContext &Ctx) {\n    return create(Mul, LHS, RHS, Ctx);\n  }\n\n  static const MCBinaryExpr *createNE(const MCExpr *LHS, const MCExpr *RHS,\n                                      MCContext &Ctx) {\n    return create(NE, LHS, RHS, Ctx);\n  }\n\n  static const MCBinaryExpr *createOr(const MCExpr *LHS, const MCExpr *RHS,\n                                      MCContext &Ctx) {\n    return create(Or, LHS, RHS, Ctx);\n  }\n\n  static const MCBinaryExpr *createShl(const MCExpr *LHS, const MCExpr *RHS,\n                                       MCContext &Ctx) {\n    return create(Shl, LHS, RHS, Ctx);\n  }\n\n  static const MCBinaryExpr *createAShr(const MCExpr *LHS, const MCExpr *RHS,\n                                       MCContext &Ctx) {\n    return create(AShr, LHS, RHS, Ctx);\n  }\n\n  static const MCBinaryExpr *createLShr(const MCExpr *LHS, const MCExpr *RHS,\n                                       MCContext &Ctx) {\n    return create(LShr, LHS, RHS, Ctx);\n  }\n\n  static const MCBinaryExpr *createSub(const MCExpr *LHS, const MCExpr *RHS,\n                                       MCContext &Ctx) {\n    return create(Sub, LHS, RHS, Ctx);\n  }\n\n  static const MCBinaryExpr *createXor(const MCExpr *LHS, const MCExpr *RHS,\n                                       MCContext &Ctx) {\n    return create(Xor, LHS, RHS, Ctx);\n  }\n\n  /// @}\n  /// \\name Accessors\n  /// @{\n\n  /// Get the kind of this binary expression.\n  Opcode getOpcode() const { return (Opcode)getSubclassData(); }\n\n  /// Get the left-hand side expression of the binary operator.\n  const MCExpr *getLHS() const { return LHS; }\n\n  /// Get the right-hand side expression of the binary operator.\n  const MCExpr *getRHS() const { return RHS; }\n\n  /// @}\n\n  static bool classof(const MCExpr *E) {\n    return E->getKind() == MCExpr::Binary;\n  }\n};\n\n/// This is an extension point for target-specific MCExpr subclasses to\n/// implement.\n///\n/// NOTE: All subclasses are required to have trivial destructors because\n/// MCExprs are bump pointer allocated and not destructed.\nclass MCTargetExpr : public MCExpr {\n  virtual void anchor();\n\nprotected:\n  MCTargetExpr() : MCExpr(Target, SMLoc()) {}\n  virtual ~MCTargetExpr() = default;\n\npublic:\n  virtual void printImpl(raw_ostream &OS, const MCAsmInfo *MAI) const = 0;\n  virtual bool evaluateAsRelocatableImpl(MCValue &Res,\n                                         const MCAsmLayout *Layout,\n                                         const MCFixup *Fixup) const = 0;\n  // allow Target Expressions to be checked for equality\n  virtual bool isEqualTo(const MCExpr *x) const { return false; }\n  // This should be set when assigned expressions are not valid \".set\"\n  // expressions, e.g. registers, and must be inlined.\n  virtual bool inlineAssignedExpr() const { return false; }\n  virtual void visitUsedExpr(MCStreamer& Streamer) const = 0;\n  virtual MCFragment *findAssociatedFragment() const = 0;\n\n  virtual void fixELFSymbolsInTLSFixups(MCAssembler &) const = 0;\n\n  static bool classof(const MCExpr *E) {\n    return E->getKind() == MCExpr::Target;\n  }\n};\n\n} // end namespace llvm\n\n#endif // LLVM_MC_MCEXPR_H\n"}, "31": {"id": 31, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/MC/MCFixup.h", "content": "//===-- llvm/MC/MCFixup.h - Instruction Relocation and Patching -*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_MC_MCFIXUP_H\n#define LLVM_MC_MCFIXUP_H\n\n#include \"llvm/Support/DataTypes.h\"\n#include \"llvm/Support/ErrorHandling.h\"\n#include \"llvm/Support/SMLoc.h\"\n#include <cassert>\n\nnamespace llvm {\nclass MCExpr;\n\n/// Extensible enumeration to represent the type of a fixup.\nenum MCFixupKind {\n  FK_NONE = 0,    ///< A no-op fixup.\n  FK_Data_1,      ///< A one-byte fixup.\n  FK_Data_2,      ///< A two-byte fixup.\n  FK_Data_4,      ///< A four-byte fixup.\n  FK_Data_8,      ///< A eight-byte fixup.\n  FK_Data_6b,     ///< A six-bits fixup.\n  FK_PCRel_1,     ///< A one-byte pc relative fixup.\n  FK_PCRel_2,     ///< A two-byte pc relative fixup.\n  FK_PCRel_4,     ///< A four-byte pc relative fixup.\n  FK_PCRel_8,     ///< A eight-byte pc relative fixup.\n  FK_GPRel_1,     ///< A one-byte gp relative fixup.\n  FK_GPRel_2,     ///< A two-byte gp relative fixup.\n  FK_GPRel_4,     ///< A four-byte gp relative fixup.\n  FK_GPRel_8,     ///< A eight-byte gp relative fixup.\n  FK_DTPRel_4,    ///< A four-byte dtp relative fixup.\n  FK_DTPRel_8,    ///< A eight-byte dtp relative fixup.\n  FK_TPRel_4,     ///< A four-byte tp relative fixup.\n  FK_TPRel_8,     ///< A eight-byte tp relative fixup.\n  FK_SecRel_1,    ///< A one-byte section relative fixup.\n  FK_SecRel_2,    ///< A two-byte section relative fixup.\n  FK_SecRel_4,    ///< A four-byte section relative fixup.\n  FK_SecRel_8,    ///< A eight-byte section relative fixup.\n  FK_Data_Add_1,  ///< A one-byte add fixup.\n  FK_Data_Add_2,  ///< A two-byte add fixup.\n  FK_Data_Add_4,  ///< A four-byte add fixup.\n  FK_Data_Add_8,  ///< A eight-byte add fixup.\n  FK_Data_Add_6b, ///< A six-bits add fixup.\n  FK_Data_Sub_1,  ///< A one-byte sub fixup.\n  FK_Data_Sub_2,  ///< A two-byte sub fixup.\n  FK_Data_Sub_4,  ///< A four-byte sub fixup.\n  FK_Data_Sub_8,  ///< A eight-byte sub fixup.\n  FK_Data_Sub_6b, ///< A six-bits sub fixup.\n\n  FirstTargetFixupKind = 128,\n\n  /// The range [FirstLiteralRelocationKind, MaxTargetFixupKind) is used for\n  /// relocations coming from .reloc directive. Fixup kind\n  /// FirstLiteralRelocationKind+V represents the relocation type with number V.\n  FirstLiteralRelocationKind = 256,\n\n  /// Set limit to accommodate the highest reloc type in use for all Targets,\n  /// currently R_AARCH64_IRELATIVE at 1032, including room for expansion.\n  MaxFixupKind = FirstLiteralRelocationKind + 1032 + 32,\n};\n\n/// Encode information on a single operation to perform on a byte\n/// sequence (e.g., an encoded instruction) which requires assemble- or run-\n/// time patching.\n///\n/// Fixups are used any time the target instruction encoder needs to represent\n/// some value in an instruction which is not yet concrete. The encoder will\n/// encode the instruction assuming the value is 0, and emit a fixup which\n/// communicates to the assembler backend how it should rewrite the encoded\n/// value.\n///\n/// During the process of relaxation, the assembler will apply fixups as\n/// symbolic values become concrete. When relaxation is complete, any remaining\n/// fixups become relocations in the object file (or errors, if the fixup cannot\n/// be encoded on the target).\nclass MCFixup {\n  /// The value to put into the fixup location. The exact interpretation of the\n  /// expression is target dependent, usually it will be one of the operands to\n  /// an instruction or an assembler directive.\n  const MCExpr *Value = nullptr;\n\n  /// The byte index of start of the relocation inside the MCFragment.\n  uint32_t Offset = 0;\n\n  /// The target dependent kind of fixup item this is. The kind is used to\n  /// determine how the operand value should be encoded into the instruction.\n  MCFixupKind Kind = FK_NONE;\n\n  /// The source location which gave rise to the fixup, if any.\n  SMLoc Loc;\npublic:\n  static MCFixup create(uint32_t Offset, const MCExpr *Value,\n                        MCFixupKind Kind, SMLoc Loc = SMLoc()) {\n    assert(Kind <= MaxFixupKind && \"Kind out of range!\");\n    MCFixup FI;\n    FI.Value = Value;\n    FI.Offset = Offset;\n    FI.Kind = Kind;\n    FI.Loc = Loc;\n    return FI;\n  }\n\n  /// Return a fixup corresponding to the add half of a add/sub fixup pair for\n  /// the given Fixup.\n  static MCFixup createAddFor(const MCFixup &Fixup) {\n    MCFixup FI;\n    FI.Value = Fixup.getValue();\n    FI.Offset = Fixup.getOffset();\n    FI.Kind = getAddKindForKind(Fixup.getKind());\n    FI.Loc = Fixup.getLoc();\n    return FI;\n  }\n\n  /// Return a fixup corresponding to the sub half of a add/sub fixup pair for\n  /// the given Fixup.\n  static MCFixup createSubFor(const MCFixup &Fixup) {\n    MCFixup FI;\n    FI.Value = Fixup.getValue();\n    FI.Offset = Fixup.getOffset();\n    FI.Kind = getSubKindForKind(Fixup.getKind());\n    FI.Loc = Fixup.getLoc();\n    return FI;\n  }\n\n  MCFixupKind getKind() const { return Kind; }\n\n  unsigned getTargetKind() const { return Kind; }\n\n  uint32_t getOffset() const { return Offset; }\n  void setOffset(uint32_t Value) { Offset = Value; }\n\n  const MCExpr *getValue() const { return Value; }\n\n  /// Return the generic fixup kind for a value with the given size. It\n  /// is an error to pass an unsupported size.\n  static MCFixupKind getKindForSize(unsigned Size, bool IsPCRel) {\n    switch (Size) {\n    default: llvm_unreachable(\"Invalid generic fixup size!\");\n    case 1:\n      return IsPCRel ? FK_PCRel_1 : FK_Data_1;\n    case 2:\n      return IsPCRel ? FK_PCRel_2 : FK_Data_2;\n    case 4:\n      return IsPCRel ? FK_PCRel_4 : FK_Data_4;\n    case 8:\n      return IsPCRel ? FK_PCRel_8 : FK_Data_8;\n    }\n  }\n\n  /// Return the generic fixup kind for a value with the given size in bits.\n  /// It is an error to pass an unsupported size.\n  static MCFixupKind getKindForSizeInBits(unsigned Size, bool IsPCRel) {\n    switch (Size) {\n    default:\n      llvm_unreachable(\"Invalid generic fixup size!\");\n    case 6:\n      assert(!IsPCRel && \"Invalid pc-relative fixup size!\");\n      return FK_Data_6b;\n    case 8:\n      return IsPCRel ? FK_PCRel_1 : FK_Data_1;\n    case 16:\n      return IsPCRel ? FK_PCRel_2 : FK_Data_2;\n    case 32:\n      return IsPCRel ? FK_PCRel_4 : FK_Data_4;\n    case 64:\n      return IsPCRel ? FK_PCRel_8 : FK_Data_8;\n    }\n  }\n\n  /// Return the generic fixup kind for an addition with a given size. It\n  /// is an error to pass an unsupported size.\n  static MCFixupKind getAddKindForKind(MCFixupKind Kind) {\n    switch (Kind) {\n    default: llvm_unreachable(\"Unknown type to convert!\");\n    case FK_Data_1: return FK_Data_Add_1;\n    case FK_Data_2: return FK_Data_Add_2;\n    case FK_Data_4: return FK_Data_Add_4;\n    case FK_Data_8: return FK_Data_Add_8;\n    case FK_Data_6b: return FK_Data_Add_6b;\n    }\n  }\n\n  /// Return the generic fixup kind for an subtraction with a given size. It\n  /// is an error to pass an unsupported size.\n  static MCFixupKind getSubKindForKind(MCFixupKind Kind) {\n    switch (Kind) {\n    default: llvm_unreachable(\"Unknown type to convert!\");\n    case FK_Data_1: return FK_Data_Sub_1;\n    case FK_Data_2: return FK_Data_Sub_2;\n    case FK_Data_4: return FK_Data_Sub_4;\n    case FK_Data_8: return FK_Data_Sub_8;\n    case FK_Data_6b: return FK_Data_Sub_6b;\n    }\n  }\n\n  SMLoc getLoc() const { return Loc; }\n};\n\n} // End llvm namespace\n\n#endif\n"}, "32": {"id": 32, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/MC/MCFragment.h", "content": "//===- MCFragment.h - Fragment type hierarchy -------------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_MC_MCFRAGMENT_H\n#define LLVM_MC_MCFRAGMENT_H\n\n#include \"llvm/ADT/ArrayRef.h\"\n#include \"llvm/ADT/SmallString.h\"\n#include \"llvm/ADT/SmallVector.h\"\n#include \"llvm/ADT/StringRef.h\"\n#include \"llvm/ADT/ilist_node.h\"\n#include \"llvm/MC/MCFixup.h\"\n#include \"llvm/MC/MCInst.h\"\n#include \"llvm/Support/Alignment.h\"\n#include \"llvm/Support/Casting.h\"\n#include \"llvm/Support/SMLoc.h\"\n#include <cstdint>\n#include <utility>\n\nnamespace llvm {\n\nclass MCSection;\nclass MCSubtargetInfo;\nclass MCSymbol;\n\nclass MCFragment : public ilist_node_with_parent<MCFragment, MCSection> {\n  friend class MCAsmLayout;\n\npublic:\n  enum FragmentType : uint8_t {\n    FT_Align,\n    FT_Data,\n    FT_CompactEncodedInst,\n    FT_Fill,\n    FT_Nops,\n    FT_Relaxable,\n    FT_Org,\n    FT_Dwarf,\n    FT_DwarfFrame,\n    FT_LEB,\n    FT_BoundaryAlign,\n    FT_SymbolId,\n    FT_CVInlineLines,\n    FT_CVDefRange,\n    FT_PseudoProbe,\n    FT_Dummy\n  };\n\nprivate:\n  /// The data for the section this fragment is in.\n  MCSection *Parent;\n\n  /// The atom this fragment is in, as represented by its defining symbol.\n  const MCSymbol *Atom;\n\n  /// The offset of this fragment in its section. This is ~0 until\n  /// initialized.\n  uint64_t Offset;\n\n  /// The layout order of this fragment.\n  unsigned LayoutOrder;\n\n  /// The subsection this fragment belongs to. This is 0 if the fragment is not\n  // in any subsection.\n  unsigned SubsectionNumber = 0;\n\n  FragmentType Kind;\n\n  /// Whether fragment is being laid out.\n  bool IsBeingLaidOut;\n\nprotected:\n  bool HasInstructions;\n\n  MCFragment(FragmentType Kind, bool HasInstructions,\n             MCSection *Parent = nullptr);\n\npublic:\n  MCFragment() = delete;\n  MCFragment(const MCFragment &) = delete;\n  MCFragment &operator=(const MCFragment &) = delete;\n\n  /// Destroys the current fragment.\n  ///\n  /// This must be used instead of delete as MCFragment is non-virtual.\n  /// This method will dispatch to the appropriate subclass.\n  void destroy();\n\n  FragmentType getKind() const { return Kind; }\n\n  MCSection *getParent() const { return Parent; }\n  void setParent(MCSection *Value) { Parent = Value; }\n\n  const MCSymbol *getAtom() const { return Atom; }\n  void setAtom(const MCSymbol *Value) { Atom = Value; }\n\n  unsigned getLayoutOrder() const { return LayoutOrder; }\n  void setLayoutOrder(unsigned Value) { LayoutOrder = Value; }\n\n  /// Does this fragment have instructions emitted into it? By default\n  /// this is false, but specific fragment types may set it to true.\n  bool hasInstructions() const { return HasInstructions; }\n\n  void dump() const;\n\n  void setSubsectionNumber(unsigned Value) { SubsectionNumber = Value; }\n  unsigned getSubsectionNumber() const { return SubsectionNumber; }\n};\n\nclass MCDummyFragment : public MCFragment {\npublic:\n  explicit MCDummyFragment(MCSection *Sec) : MCFragment(FT_Dummy, false, Sec) {}\n\n  static bool classof(const MCFragment *F) { return F->getKind() == FT_Dummy; }\n};\n\n/// Interface implemented by fragments that contain encoded instructions and/or\n/// data.\n///\nclass MCEncodedFragment : public MCFragment {\n  /// Should this fragment be aligned to the end of a bundle?\n  bool AlignToBundleEnd = false;\n\n  uint8_t BundlePadding = 0;\n\nprotected:\n  MCEncodedFragment(MCFragment::FragmentType FType, bool HasInstructions,\n                    MCSection *Sec)\n      : MCFragment(FType, HasInstructions, Sec) {}\n\n  /// The MCSubtargetInfo in effect when the instruction was encoded.\n  /// It must be non-null for instructions.\n  const MCSubtargetInfo *STI = nullptr;\n\npublic:\n  static bool classof(const MCFragment *F) {\n    MCFragment::FragmentType Kind = F->getKind();\n    switch (Kind) {\n    default:\n      return false;\n    case MCFragment::FT_Relaxable:\n    case MCFragment::FT_CompactEncodedInst:\n    case MCFragment::FT_Data:\n    case MCFragment::FT_Dwarf:\n    case MCFragment::FT_DwarfFrame:\n    case MCFragment::FT_PseudoProbe:\n      return true;\n    }\n  }\n\n  /// Should this fragment be placed at the end of an aligned bundle?\n  bool alignToBundleEnd() const { return AlignToBundleEnd; }\n  void setAlignToBundleEnd(bool V) { AlignToBundleEnd = V; }\n\n  /// Get the padding size that must be inserted before this fragment.\n  /// Used for bundling. By default, no padding is inserted.\n  /// Note that padding size is restricted to 8 bits. This is an optimization\n  /// to reduce the amount of space used for each fragment. In practice, larger\n  /// padding should never be required.\n  uint8_t getBundlePadding() const { return BundlePadding; }\n\n  /// Set the padding size for this fragment. By default it's a no-op,\n  /// and only some fragments have a meaningful implementation.\n  void setBundlePadding(uint8_t N) { BundlePadding = N; }\n\n  /// Retrieve the MCSubTargetInfo in effect when the instruction was encoded.\n  /// Guaranteed to be non-null if hasInstructions() == true\n  const MCSubtargetInfo *getSubtargetInfo() const { return STI; }\n\n  /// Record that the fragment contains instructions with the MCSubtargetInfo in\n  /// effect when the instruction was encoded.\n  void setHasInstructions(const MCSubtargetInfo &STI) {\n    HasInstructions = true;\n    this->STI = &STI;\n  }\n};\n\n/// Interface implemented by fragments that contain encoded instructions and/or\n/// data.\n///\ntemplate<unsigned ContentsSize>\nclass MCEncodedFragmentWithContents : public MCEncodedFragment {\n  SmallVector<char, ContentsSize> Contents;\n\nprotected:\n  MCEncodedFragmentWithContents(MCFragment::FragmentType FType,\n                                bool HasInstructions,\n                                MCSection *Sec)\n      : MCEncodedFragment(FType, HasInstructions, Sec) {}\n\npublic:\n  SmallVectorImpl<char> &getContents() { return Contents; }\n  const SmallVectorImpl<char> &getContents() const { return Contents; }\n};\n\n/// Interface implemented by fragments that contain encoded instructions and/or\n/// data and also have fixups registered.\n///\ntemplate<unsigned ContentsSize, unsigned FixupsSize>\nclass MCEncodedFragmentWithFixups :\n  public MCEncodedFragmentWithContents<ContentsSize> {\n\n  /// The list of fixups in this fragment.\n  SmallVector<MCFixup, FixupsSize> Fixups;\n\nprotected:\n  MCEncodedFragmentWithFixups(MCFragment::FragmentType FType,\n                              bool HasInstructions,\n                              MCSection *Sec)\n      : MCEncodedFragmentWithContents<ContentsSize>(FType, HasInstructions,\n                                                    Sec) {}\n\npublic:\n\n  using const_fixup_iterator = SmallVectorImpl<MCFixup>::const_iterator;\n  using fixup_iterator = SmallVectorImpl<MCFixup>::iterator;\n\n  SmallVectorImpl<MCFixup> &getFixups() { return Fixups; }\n  const SmallVectorImpl<MCFixup> &getFixups() const { return Fixups; }\n\n  fixup_iterator fixup_begin() { return Fixups.begin(); }\n  const_fixup_iterator fixup_begin() const { return Fixups.begin(); }\n\n  fixup_iterator fixup_end() { return Fixups.end(); }\n  const_fixup_iterator fixup_end() const { return Fixups.end(); }\n\n  static bool classof(const MCFragment *F) {\n    MCFragment::FragmentType Kind = F->getKind();\n    return Kind == MCFragment::FT_Relaxable || Kind == MCFragment::FT_Data ||\n           Kind == MCFragment::FT_CVDefRange || Kind == MCFragment::FT_Dwarf ||\n           Kind == MCFragment::FT_DwarfFrame;\n  }\n};\n\n/// Fragment for data and encoded instructions.\n///\nclass MCDataFragment : public MCEncodedFragmentWithFixups<32, 4> {\npublic:\n  MCDataFragment(MCSection *Sec = nullptr)\n      : MCEncodedFragmentWithFixups<32, 4>(FT_Data, false, Sec) {}\n\n  static bool classof(const MCFragment *F) {\n    return F->getKind() == MCFragment::FT_Data;\n  }\n};\n\n/// This is a compact (memory-size-wise) fragment for holding an encoded\n/// instruction (non-relaxable) that has no fixups registered. When applicable,\n/// it can be used instead of MCDataFragment and lead to lower memory\n/// consumption.\n///\nclass MCCompactEncodedInstFragment : public MCEncodedFragmentWithContents<4> {\npublic:\n  MCCompactEncodedInstFragment(MCSection *Sec = nullptr)\n      : MCEncodedFragmentWithContents(FT_CompactEncodedInst, true, Sec) {\n  }\n\n  static bool classof(const MCFragment *F) {\n    return F->getKind() == MCFragment::FT_CompactEncodedInst;\n  }\n};\n\n/// A relaxable fragment holds on to its MCInst, since it may need to be\n/// relaxed during the assembler layout and relaxation stage.\n///\nclass MCRelaxableFragment : public MCEncodedFragmentWithFixups<8, 1> {\n\n  /// The instruction this is a fragment for.\n  MCInst Inst;\n  /// Can we auto pad the instruction?\n  bool AllowAutoPadding = false;\n\npublic:\n  MCRelaxableFragment(const MCInst &Inst, const MCSubtargetInfo &STI,\n                      MCSection *Sec = nullptr)\n      : MCEncodedFragmentWithFixups(FT_Relaxable, true, Sec),\n        Inst(Inst) { this->STI = &STI; }\n\n  const MCInst &getInst() const { return Inst; }\n  void setInst(const MCInst &Value) { Inst = Value; }\n\n  bool getAllowAutoPadding() const { return AllowAutoPadding; }\n  void setAllowAutoPadding(bool V) { AllowAutoPadding = V; }\n\n  static bool classof(const MCFragment *F) {\n    return F->getKind() == MCFragment::FT_Relaxable;\n  }\n};\n\nclass MCAlignFragment : public MCFragment {\n  /// The alignment to ensure, in bytes.\n  unsigned Alignment;\n\n  /// Flag to indicate that (optimal) NOPs should be emitted instead\n  /// of using the provided value. The exact interpretation of this flag is\n  /// target dependent.\n  bool EmitNops : 1;\n\n  /// Value to use for filling padding bytes.\n  int64_t Value;\n\n  /// The size of the integer (in bytes) of \\p Value.\n  unsigned ValueSize;\n\n  /// The maximum number of bytes to emit; if the alignment\n  /// cannot be satisfied in this width then this fragment is ignored.\n  unsigned MaxBytesToEmit;\n\npublic:\n  MCAlignFragment(unsigned Alignment, int64_t Value, unsigned ValueSize,\n                  unsigned MaxBytesToEmit, MCSection *Sec = nullptr)\n      : MCFragment(FT_Align, false, Sec), Alignment(Alignment), EmitNops(false),\n        Value(Value), ValueSize(ValueSize), MaxBytesToEmit(MaxBytesToEmit) {}\n\n  unsigned getAlignment() const { return Alignment; }\n\n  int64_t getValue() const { return Value; }\n\n  unsigned getValueSize() const { return ValueSize; }\n\n  unsigned getMaxBytesToEmit() const { return MaxBytesToEmit; }\n\n  bool hasEmitNops() const { return EmitNops; }\n  void setEmitNops(bool Value) { EmitNops = Value; }\n\n  static bool classof(const MCFragment *F) {\n    return F->getKind() == MCFragment::FT_Align;\n  }\n};\n\nclass MCFillFragment : public MCFragment {\n  uint8_t ValueSize;\n  /// Value to use for filling bytes.\n  uint64_t Value;\n  /// The number of bytes to insert.\n  const MCExpr &NumValues;\n\n  /// Source location of the directive that this fragment was created for.\n  SMLoc Loc;\n\npublic:\n  MCFillFragment(uint64_t Value, uint8_t VSize, const MCExpr &NumValues,\n                 SMLoc Loc, MCSection *Sec = nullptr)\n      : MCFragment(FT_Fill, false, Sec), ValueSize(VSize), Value(Value),\n        NumValues(NumValues), Loc(Loc) {}\n\n  uint64_t getValue() const { return Value; }\n  uint8_t getValueSize() const { return ValueSize; }\n  const MCExpr &getNumValues() const { return NumValues; }\n\n  SMLoc getLoc() const { return Loc; }\n\n  static bool classof(const MCFragment *F) {\n    return F->getKind() == MCFragment::FT_Fill;\n  }\n};\n\nclass MCNopsFragment : public MCFragment {\n  /// The number of bytes to insert.\n  int64_t Size;\n  /// Maximum number of bytes allowed in each NOP instruction.\n  int64_t ControlledNopLength;\n\n  /// Source location of the directive that this fragment was created for.\n  SMLoc Loc;\n\npublic:\n  MCNopsFragment(int64_t NumBytes, int64_t ControlledNopLength, SMLoc L,\n                 MCSection *Sec = nullptr)\n      : MCFragment(FT_Nops, false, Sec), Size(NumBytes),\n        ControlledNopLength(ControlledNopLength), Loc(L) {}\n\n  int64_t getNumBytes() const { return Size; }\n  int64_t getControlledNopLength() const { return ControlledNopLength; }\n\n  SMLoc getLoc() const { return Loc; }\n\n  static bool classof(const MCFragment *F) {\n    return F->getKind() == MCFragment::FT_Nops;\n  }\n};\n\nclass MCOrgFragment : public MCFragment {\n  /// Value to use for filling bytes.\n  int8_t Value;\n\n  /// The offset this fragment should start at.\n  const MCExpr *Offset;\n\n  /// Source location of the directive that this fragment was created for.\n  SMLoc Loc;\n\npublic:\n  MCOrgFragment(const MCExpr &Offset, int8_t Value, SMLoc Loc,\n                MCSection *Sec = nullptr)\n      : MCFragment(FT_Org, false, Sec), Value(Value), Offset(&Offset),\n        Loc(Loc) {}\n\n  const MCExpr &getOffset() const { return *Offset; }\n\n  uint8_t getValue() const { return Value; }\n\n  SMLoc getLoc() const { return Loc; }\n\n  static bool classof(const MCFragment *F) {\n    return F->getKind() == MCFragment::FT_Org;\n  }\n};\n\nclass MCLEBFragment : public MCFragment {\n  /// True if this is a sleb128, false if uleb128.\n  bool IsSigned;\n\n  /// The value this fragment should contain.\n  const MCExpr *Value;\n\n  SmallString<8> Contents;\n\npublic:\n  MCLEBFragment(const MCExpr &Value_, bool IsSigned_, MCSection *Sec = nullptr)\n      : MCFragment(FT_LEB, false, Sec), IsSigned(IsSigned_), Value(&Value_) {\n    Contents.push_back(0);\n  }\n\n  const MCExpr &getValue() const { return *Value; }\n\n  bool isSigned() const { return IsSigned; }\n\n  SmallString<8> &getContents() { return Contents; }\n  const SmallString<8> &getContents() const { return Contents; }\n\n  /// @}\n\n  static bool classof(const MCFragment *F) {\n    return F->getKind() == MCFragment::FT_LEB;\n  }\n};\n\nclass MCDwarfLineAddrFragment : public MCEncodedFragmentWithFixups<8, 1> {\n  /// The value of the difference between the two line numbers\n  /// between two .loc dwarf directives.\n  int64_t LineDelta;\n\n  /// The expression for the difference of the two symbols that\n  /// make up the address delta between two .loc dwarf directives.\n  const MCExpr *AddrDelta;\n\npublic:\n  MCDwarfLineAddrFragment(int64_t LineDelta, const MCExpr &AddrDelta,\n                          MCSection *Sec = nullptr)\n      : MCEncodedFragmentWithFixups<8, 1>(FT_Dwarf, false, Sec),\n        LineDelta(LineDelta), AddrDelta(&AddrDelta) {}\n\n  int64_t getLineDelta() const { return LineDelta; }\n\n  const MCExpr &getAddrDelta() const { return *AddrDelta; }\n\n  static bool classof(const MCFragment *F) {\n    return F->getKind() == MCFragment::FT_Dwarf;\n  }\n};\n\nclass MCDwarfCallFrameFragment : public MCEncodedFragmentWithFixups<8, 1> {\n  /// The expression for the difference of the two symbols that\n  /// make up the address delta between two .cfi_* dwarf directives.\n  const MCExpr *AddrDelta;\n\npublic:\n  MCDwarfCallFrameFragment(const MCExpr &AddrDelta, MCSection *Sec = nullptr)\n      : MCEncodedFragmentWithFixups<8, 1>(FT_DwarfFrame, false, Sec),\n        AddrDelta(&AddrDelta) {}\n\n  const MCExpr &getAddrDelta() const { return *AddrDelta; }\n\n  static bool classof(const MCFragment *F) {\n    return F->getKind() == MCFragment::FT_DwarfFrame;\n  }\n};\n\n/// Represents a symbol table index fragment.\nclass MCSymbolIdFragment : public MCFragment {\n  const MCSymbol *Sym;\n\npublic:\n  MCSymbolIdFragment(const MCSymbol *Sym, MCSection *Sec = nullptr)\n      : MCFragment(FT_SymbolId, false, Sec), Sym(Sym) {}\n\n  const MCSymbol *getSymbol() { return Sym; }\n  const MCSymbol *getSymbol() const { return Sym; }\n\n  static bool classof(const MCFragment *F) {\n    return F->getKind() == MCFragment::FT_SymbolId;\n  }\n};\n\n/// Fragment representing the binary annotations produced by the\n/// .cv_inline_linetable directive.\nclass MCCVInlineLineTableFragment : public MCFragment {\n  unsigned SiteFuncId;\n  unsigned StartFileId;\n  unsigned StartLineNum;\n  const MCSymbol *FnStartSym;\n  const MCSymbol *FnEndSym;\n  SmallString<8> Contents;\n\n  /// CodeViewContext has the real knowledge about this format, so let it access\n  /// our members.\n  friend class CodeViewContext;\n\npublic:\n  MCCVInlineLineTableFragment(unsigned SiteFuncId, unsigned StartFileId,\n                              unsigned StartLineNum, const MCSymbol *FnStartSym,\n                              const MCSymbol *FnEndSym,\n                              MCSection *Sec = nullptr)\n      : MCFragment(FT_CVInlineLines, false, Sec), SiteFuncId(SiteFuncId),\n        StartFileId(StartFileId), StartLineNum(StartLineNum),\n        FnStartSym(FnStartSym), FnEndSym(FnEndSym) {}\n\n  const MCSymbol *getFnStartSym() const { return FnStartSym; }\n  const MCSymbol *getFnEndSym() const { return FnEndSym; }\n\n  SmallString<8> &getContents() { return Contents; }\n  const SmallString<8> &getContents() const { return Contents; }\n\n  static bool classof(const MCFragment *F) {\n    return F->getKind() == MCFragment::FT_CVInlineLines;\n  }\n};\n\n/// Fragment representing the .cv_def_range directive.\nclass MCCVDefRangeFragment : public MCEncodedFragmentWithFixups<32, 4> {\n  SmallVector<std::pair<const MCSymbol *, const MCSymbol *>, 2> Ranges;\n  SmallString<32> FixedSizePortion;\n\n  /// CodeViewContext has the real knowledge about this format, so let it access\n  /// our members.\n  friend class CodeViewContext;\n\npublic:\n  MCCVDefRangeFragment(\n      ArrayRef<std::pair<const MCSymbol *, const MCSymbol *>> Ranges,\n      StringRef FixedSizePortion, MCSection *Sec = nullptr)\n      : MCEncodedFragmentWithFixups<32, 4>(FT_CVDefRange, false, Sec),\n        Ranges(Ranges.begin(), Ranges.end()),\n        FixedSizePortion(FixedSizePortion) {}\n\n  ArrayRef<std::pair<const MCSymbol *, const MCSymbol *>> getRanges() const {\n    return Ranges;\n  }\n\n  StringRef getFixedSizePortion() const { return FixedSizePortion; }\n\n  static bool classof(const MCFragment *F) {\n    return F->getKind() == MCFragment::FT_CVDefRange;\n  }\n};\n\n/// Represents required padding such that a particular other set of fragments\n/// does not cross a particular power-of-two boundary. The other fragments must\n/// follow this one within the same section.\nclass MCBoundaryAlignFragment : public MCFragment {\n  /// The alignment requirement of the branch to be aligned.\n  Align AlignBoundary;\n  /// The last fragment in the set of fragments to be aligned.\n  const MCFragment *LastFragment = nullptr;\n  /// The size of the fragment.  The size is lazily set during relaxation, and\n  /// is not meaningful before that.\n  uint64_t Size = 0;\n\npublic:\n  MCBoundaryAlignFragment(Align AlignBoundary, MCSection *Sec = nullptr)\n      : MCFragment(FT_BoundaryAlign, false, Sec), AlignBoundary(AlignBoundary) {\n  }\n\n  uint64_t getSize() const { return Size; }\n  void setSize(uint64_t Value) { Size = Value; }\n\n  Align getAlignment() const { return AlignBoundary; }\n  void setAlignment(Align Value) { AlignBoundary = Value; }\n\n  const MCFragment *getLastFragment() const { return LastFragment; }\n  void setLastFragment(const MCFragment *F) {\n    assert(!F || getParent() == F->getParent());\n    LastFragment = F;\n  }\n\n  static bool classof(const MCFragment *F) {\n    return F->getKind() == MCFragment::FT_BoundaryAlign;\n  }\n};\n\nclass MCPseudoProbeAddrFragment : public MCEncodedFragmentWithFixups<8, 1> {\n  /// The expression for the difference of the two symbols that\n  /// make up the address delta between two .pseudoprobe directives.\n  const MCExpr *AddrDelta;\n\npublic:\n  MCPseudoProbeAddrFragment(const MCExpr *AddrDelta, MCSection *Sec = nullptr)\n      : MCEncodedFragmentWithFixups<8, 1>(FT_PseudoProbe, false, Sec),\n        AddrDelta(AddrDelta) {}\n\n  const MCExpr &getAddrDelta() const { return *AddrDelta; }\n\n  static bool classof(const MCFragment *F) {\n    return F->getKind() == MCFragment::FT_PseudoProbe;\n  }\n};\n} // end namespace llvm\n\n#endif // LLVM_MC_MCFRAGMENT_H\n"}, "33": {"id": 33, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/MC/MCInst.h", "content": "//===- llvm/MC/MCInst.h - MCInst class --------------------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// This file contains the declaration of the MCInst and MCOperand classes, which\n// is the basic representation used to represent low-level machine code\n// instructions.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_MC_MCINST_H\n#define LLVM_MC_MCINST_H\n\n#include \"llvm/ADT/SmallVector.h\"\n#include \"llvm/ADT/StringRef.h\"\n#include \"llvm/ADT/bit.h\"\n#include \"llvm/Support/SMLoc.h\"\n#include <cassert>\n#include <cstddef>\n#include <cstdint>\n\nnamespace llvm {\n\nclass MCExpr;\nclass MCInst;\nclass MCInstPrinter;\nclass raw_ostream;\n\n/// Instances of this class represent operands of the MCInst class.\n/// This is a simple discriminated union.\nclass MCOperand {\n  enum MachineOperandType : unsigned char {\n    kInvalid,      ///< Uninitialized.\n    kRegister,     ///< Register operand.\n    kImmediate,    ///< Immediate operand.\n    kSFPImmediate, ///< Single-floating-point immediate operand.\n    kDFPImmediate, ///< Double-Floating-point immediate operand.\n    kExpr,         ///< Relocatable immediate operand.\n    kInst          ///< Sub-instruction operand.\n  };\n  MachineOperandType Kind = kInvalid;\n\n  union {\n    unsigned RegVal;\n    int64_t ImmVal;\n    uint32_t SFPImmVal;\n    uint64_t FPImmVal;\n    const MCExpr *ExprVal;\n    const MCInst *InstVal;\n  };\n\npublic:\n  MCOperand() : FPImmVal(0) {}\n\n  bool isValid() const { return Kind != kInvalid; }\n  bool isReg() const { return Kind == kRegister; }\n  bool isImm() const { return Kind == kImmediate; }\n  bool isSFPImm() const { return Kind == kSFPImmediate; }\n  bool isDFPImm() const { return Kind == kDFPImmediate; }\n  bool isFPImm() const { return Kind == kDFPImmediate; }\n  bool isExpr() const { return Kind == kExpr; }\n  bool isInst() const { return Kind == kInst; }\n\n  /// Returns the register number.\n  unsigned getReg() const {\n    assert(isReg() && \"This is not a register operand!\");\n    return RegVal;\n  }\n\n  /// Set the register number.\n  void setReg(unsigned Reg) {\n    assert(isReg() && \"This is not a register operand!\");\n    RegVal = Reg;\n  }\n\n  int64_t getImm() const {\n    assert(isImm() && \"This is not an immediate\");\n    return ImmVal;\n  }\n\n  void setImm(int64_t Val) {\n    assert(isImm() && \"This is not an immediate\");\n    ImmVal = Val;\n  }\n\n  uint32_t getSFPImm() const {\n    assert(isSFPImm() && \"This is not an SFP immediate\");\n    return SFPImmVal;\n  }\n\n  void setSFPImm(uint32_t Val) {\n    assert(isSFPImm() && \"This is not an SFP immediate\");\n    SFPImmVal = Val;\n  }\n\n  uint64_t getDFPImm() const {\n    assert(isDFPImm() && \"This is not an FP immediate\");\n    return FPImmVal;\n  }\n  double getFPImm() const {\n    assert(isDFPImm() && \"This is not an FP immediate\");\n    return bit_cast<double>(FPImmVal);\n  }\n\n  void setDFPImm(uint64_t Val) {\n    assert(isDFPImm() && \"This is not an FP immediate\");\n    FPImmVal = Val;\n  }\n  void setFPImm(double Val) {\n    assert(isDFPImm() && \"This is not an FP immediate\");\n    FPImmVal = bit_cast<uint64_t>(Val);\n  }\n\n  const MCExpr *getExpr() const {\n    assert(isExpr() && \"This is not an expression\");\n    return ExprVal;\n  }\n\n  void setExpr(const MCExpr *Val) {\n    assert(isExpr() && \"This is not an expression\");\n    ExprVal = Val;\n  }\n\n  const MCInst *getInst() const {\n    assert(isInst() && \"This is not a sub-instruction\");\n    return InstVal;\n  }\n\n  void setInst(const MCInst *Val) {\n    assert(isInst() && \"This is not a sub-instruction\");\n    InstVal = Val;\n  }\n\n  static MCOperand createReg(unsigned Reg) {\n    MCOperand Op;\n    Op.Kind = kRegister;\n    Op.RegVal = Reg;\n    return Op;\n  }\n\n  static MCOperand createImm(int64_t Val) {\n    MCOperand Op;\n    Op.Kind = kImmediate;\n    Op.ImmVal = Val;\n    return Op;\n  }\n\n  static MCOperand createSFPImm(uint32_t Val) {\n    MCOperand Op;\n    Op.Kind = kSFPImmediate;\n    Op.SFPImmVal = Val;\n    return Op;\n  }\n\n  static MCOperand createDFPImm(uint64_t Val) {\n    MCOperand Op;\n    Op.Kind = kDFPImmediate;\n    Op.FPImmVal = Val;\n    return Op;\n  }\n  static MCOperand createFPImm(double Val) {\n    MCOperand Op;\n    Op.Kind = kDFPImmediate;\n    Op.FPImmVal = bit_cast<uint64_t>(Val);\n    return Op;\n  }\n\n  static MCOperand createExpr(const MCExpr *Val) {\n    MCOperand Op;\n    Op.Kind = kExpr;\n    Op.ExprVal = Val;\n    return Op;\n  }\n\n  static MCOperand createInst(const MCInst *Val) {\n    MCOperand Op;\n    Op.Kind = kInst;\n    Op.InstVal = Val;\n    return Op;\n  }\n\n  void print(raw_ostream &OS) const;\n  void dump() const;\n  bool isBareSymbolRef() const;\n  bool evaluateAsConstantImm(int64_t &Imm) const;\n};\n\n/// Instances of this class represent a single low-level machine\n/// instruction.\nclass MCInst {\n  unsigned Opcode = 0;\n  // These flags could be used to pass some info from one target subcomponent\n  // to another, for example, from disassembler to asm printer. The values of\n  // the flags have any sense on target level only (e.g. prefixes on x86).\n  unsigned Flags = 0;\n\n  SMLoc Loc;\n  SmallVector<MCOperand, 8> Operands;\n\npublic:\n  MCInst() = default;\n\n  void setOpcode(unsigned Op) { Opcode = Op; }\n  unsigned getOpcode() const { return Opcode; }\n\n  void setFlags(unsigned F) { Flags = F; }\n  unsigned getFlags() const { return Flags; }\n\n  void setLoc(SMLoc loc) { Loc = loc; }\n  SMLoc getLoc() const { return Loc; }\n\n  const MCOperand &getOperand(unsigned i) const { return Operands[i]; }\n  MCOperand &getOperand(unsigned i) { return Operands[i]; }\n  unsigned getNumOperands() const { return Operands.size(); }\n\n  void addOperand(const MCOperand Op) { Operands.push_back(Op); }\n\n  using iterator = SmallVectorImpl<MCOperand>::iterator;\n  using const_iterator = SmallVectorImpl<MCOperand>::const_iterator;\n\n  void clear() { Operands.clear(); }\n  void erase(iterator I) { Operands.erase(I); }\n  void erase(iterator First, iterator Last) { Operands.erase(First, Last); }\n  size_t size() const { return Operands.size(); }\n  iterator begin() { return Operands.begin(); }\n  const_iterator begin() const { return Operands.begin(); }\n  iterator end() { return Operands.end(); }\n  const_iterator end() const { return Operands.end(); }\n\n  iterator insert(iterator I, const MCOperand &Op) {\n    return Operands.insert(I, Op);\n  }\n\n  void print(raw_ostream &OS) const;\n  void dump() const;\n\n  /// Dump the MCInst as prettily as possible using the additional MC\n  /// structures, if given. Operators are separated by the \\p Separator\n  /// string.\n  void dump_pretty(raw_ostream &OS, const MCInstPrinter *Printer = nullptr,\n                   StringRef Separator = \" \") const;\n  void dump_pretty(raw_ostream &OS, StringRef Name,\n                   StringRef Separator = \" \") const;\n};\n\ninline raw_ostream& operator<<(raw_ostream &OS, const MCOperand &MO) {\n  MO.print(OS);\n  return OS;\n}\n\ninline raw_ostream& operator<<(raw_ostream &OS, const MCInst &MI) {\n  MI.print(OS);\n  return OS;\n}\n\n} // end namespace llvm\n\n#endif // LLVM_MC_MCINST_H\n"}, "34": {"id": 34, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/MC/SubtargetFeature.h", "content": "//===- llvm/MC/SubtargetFeature.h - CPU characteristics ---------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n/// \\file Defines and manages user or tool specified CPU characteristics.\n/// The intent is to be able to package specific features that should or should\n/// not be used on a specific target processor.  A tool, such as llc, could, as\n/// as example, gather chip info from the command line, a long with features\n/// that should be used on that chip.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_MC_SUBTARGETFEATURE_H\n#define LLVM_MC_SUBTARGETFEATURE_H\n\n#include \"llvm/ADT/StringRef.h\"\n#include \"llvm/Support/MathExtras.h\"\n#include <array>\n#include <bitset>\n#include <initializer_list>\n#include <string>\n#include <vector>\n\nnamespace llvm {\n\nclass raw_ostream;\nclass Triple;\n\nconst unsigned MAX_SUBTARGET_WORDS = 4;\nconst unsigned MAX_SUBTARGET_FEATURES = MAX_SUBTARGET_WORDS * 64;\n\n/// Container class for subtarget features.\n/// This is a constexpr reimplementation of a subset of std::bitset. It would be\n/// nice to use std::bitset directly, but it doesn't support constant\n/// initialization.\nclass FeatureBitset {\n  static_assert((MAX_SUBTARGET_FEATURES % 64) == 0,\n                \"Should be a multiple of 64!\");\n  // This cannot be a std::array, operator[] is not constexpr until C++17.\n  uint64_t Bits[MAX_SUBTARGET_WORDS] = {};\n\nprotected:\n  constexpr FeatureBitset(const std::array<uint64_t, MAX_SUBTARGET_WORDS> &B) {\n    for (unsigned I = 0; I != B.size(); ++I)\n      Bits[I] = B[I];\n  }\n\npublic:\n  constexpr FeatureBitset() = default;\n  constexpr FeatureBitset(std::initializer_list<unsigned> Init) {\n    for (auto I : Init)\n      set(I);\n  }\n\n  FeatureBitset &set() {\n    std::fill(std::begin(Bits), std::end(Bits), -1ULL);\n    return *this;\n  }\n\n  constexpr FeatureBitset &set(unsigned I) {\n    // GCC <6.2 crashes if this is written in a single statement.\n    uint64_t NewBits = Bits[I / 64] | (uint64_t(1) << (I % 64));\n    Bits[I / 64] = NewBits;\n    return *this;\n  }\n\n  constexpr FeatureBitset &reset(unsigned I) {\n    // GCC <6.2 crashes if this is written in a single statement.\n    uint64_t NewBits = Bits[I / 64] & ~(uint64_t(1) << (I % 64));\n    Bits[I / 64] = NewBits;\n    return *this;\n  }\n\n  constexpr FeatureBitset &flip(unsigned I) {\n    // GCC <6.2 crashes if this is written in a single statement.\n    uint64_t NewBits = Bits[I / 64] ^ (uint64_t(1) << (I % 64));\n    Bits[I / 64] = NewBits;\n    return *this;\n  }\n\n  constexpr bool operator[](unsigned I) const {\n    uint64_t Mask = uint64_t(1) << (I % 64);\n    return (Bits[I / 64] & Mask) != 0;\n  }\n\n  constexpr bool test(unsigned I) const { return (*this)[I]; }\n\n  constexpr size_t size() const { return MAX_SUBTARGET_FEATURES; }\n\n  bool any() const {\n    return llvm::any_of(Bits, [](uint64_t I) { return I != 0; });\n  }\n  bool none() const { return !any(); }\n  size_t count() const {\n    size_t Count = 0;\n    for (auto B : Bits)\n      Count += countPopulation(B);\n    return Count;\n  }\n\n  constexpr FeatureBitset &operator^=(const FeatureBitset &RHS) {\n    for (unsigned I = 0, E = array_lengthof(Bits); I != E; ++I) {\n      Bits[I] ^= RHS.Bits[I];\n    }\n    return *this;\n  }\n  constexpr FeatureBitset operator^(const FeatureBitset &RHS) const {\n    FeatureBitset Result = *this;\n    Result ^= RHS;\n    return Result;\n  }\n\n  constexpr FeatureBitset &operator&=(const FeatureBitset &RHS) {\n    for (unsigned I = 0, E = array_lengthof(Bits); I != E; ++I) {\n      Bits[I] &= RHS.Bits[I];\n    }\n    return *this;\n  }\n  constexpr FeatureBitset operator&(const FeatureBitset &RHS) const {\n    FeatureBitset Result = *this;\n    Result &= RHS;\n    return Result;\n  }\n\n  constexpr FeatureBitset &operator|=(const FeatureBitset &RHS) {\n    for (unsigned I = 0, E = array_lengthof(Bits); I != E; ++I) {\n      Bits[I] |= RHS.Bits[I];\n    }\n    return *this;\n  }\n  constexpr FeatureBitset operator|(const FeatureBitset &RHS) const {\n    FeatureBitset Result = *this;\n    Result |= RHS;\n    return Result;\n  }\n\n  constexpr FeatureBitset operator~() const {\n    FeatureBitset Result = *this;\n    for (auto &B : Result.Bits)\n      B = ~B;\n    return Result;\n  }\n\n  bool operator==(const FeatureBitset &RHS) const {\n    return std::equal(std::begin(Bits), std::end(Bits), std::begin(RHS.Bits));\n  }\n\n  bool operator!=(const FeatureBitset &RHS) const { return !(*this == RHS); }\n\n  bool operator < (const FeatureBitset &Other) const {\n    for (unsigned I = 0, E = size(); I != E; ++I) {\n      bool LHS = test(I), RHS = Other.test(I);\n      if (LHS != RHS)\n        return LHS < RHS;\n    }\n    return false;\n  }\n};\n\n/// Class used to store the subtarget bits in the tables created by tablegen.\nclass FeatureBitArray : public FeatureBitset {\npublic:\n  constexpr FeatureBitArray(const std::array<uint64_t, MAX_SUBTARGET_WORDS> &B)\n      : FeatureBitset(B) {}\n\n  const FeatureBitset &getAsBitset() const { return *this; }\n};\n\n//===----------------------------------------------------------------------===//\n\n/// Manages the enabling and disabling of subtarget specific features.\n///\n/// Features are encoded as a string of the form\n///   \"+attr1,+attr2,-attr3,...,+attrN\"\n/// A comma separates each feature from the next (all lowercase.)\n/// Each of the remaining features is prefixed with + or - indicating whether\n/// that feature should be enabled or disabled contrary to the cpu\n/// specification.\nclass SubtargetFeatures {\n  std::vector<std::string> Features;    ///< Subtarget features as a vector\n\npublic:\n  explicit SubtargetFeatures(StringRef Initial = \"\");\n\n  /// Returns features as a string.\n  std::string getString() const;\n\n  /// Adds Features.\n  void AddFeature(StringRef String, bool Enable = true);\n\n  /// Returns the vector of individual subtarget features.\n  const std::vector<std::string> &getFeatures() const { return Features; }\n\n  /// Prints feature string.\n  void print(raw_ostream &OS) const;\n\n  // Dumps feature info.\n  void dump() const;\n\n  /// Adds the default features for the specified target triple.\n  void getDefaultSubtargetFeatures(const Triple& Triple);\n\n  /// Determine if a feature has a flag; '+' or '-'\n  static bool hasFlag(StringRef Feature) {\n    assert(!Feature.empty() && \"Empty string\");\n    // Get first character\n    char Ch = Feature[0];\n    // Check if first character is '+' or '-' flag\n    return Ch == '+' || Ch =='-';\n  }\n\n  /// Return string stripped of flag.\n  static StringRef StripFlag(StringRef Feature) {\n    return hasFlag(Feature) ? Feature.substr(1) : Feature;\n  }\n\n  /// Return true if enable flag; '+'.\n  static inline bool isEnabled(StringRef Feature) {\n    assert(!Feature.empty() && \"Empty string\");\n    // Get first character\n    char Ch = Feature[0];\n    // Check if first character is '+' for enabled\n    return Ch == '+';\n  }\n\n  /// Splits a string of comma separated items in to a vector of strings.\n  static void Split(std::vector<std::string> &V, StringRef S);\n};\n\n} // end namespace llvm\n\n#endif // LLVM_MC_SUBTARGETFEATURE_H\n"}, "35": {"id": 35, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Object/COFF.h", "content": "//===- COFF.h - COFF object file implementation -----------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// This file declares the COFFObjectFile class.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_OBJECT_COFF_H\n#define LLVM_OBJECT_COFF_H\n\n#include \"llvm/ADT/iterator_range.h\"\n#include \"llvm/BinaryFormat/COFF.h\"\n#include \"llvm/MC/SubtargetFeature.h\"\n#include \"llvm/Object/Binary.h\"\n#include \"llvm/Object/CVDebugRecord.h\"\n#include \"llvm/Object/Error.h\"\n#include \"llvm/Object/ObjectFile.h\"\n#include \"llvm/Support/BinaryByteStream.h\"\n#include \"llvm/Support/ConvertUTF.h\"\n#include \"llvm/Support/Endian.h\"\n#include \"llvm/Support/ErrorHandling.h\"\n#include <cassert>\n#include <cstddef>\n#include <cstdint>\n#include <system_error>\n\nnamespace llvm {\n\ntemplate <typename T> class ArrayRef;\n\nnamespace object {\n\nclass BaseRelocRef;\nclass DelayImportDirectoryEntryRef;\nclass ExportDirectoryEntryRef;\nclass ImportDirectoryEntryRef;\nclass ImportedSymbolRef;\nclass ResourceSectionRef;\n\nusing import_directory_iterator = content_iterator<ImportDirectoryEntryRef>;\nusing delay_import_directory_iterator =\n    content_iterator<DelayImportDirectoryEntryRef>;\nusing export_directory_iterator = content_iterator<ExportDirectoryEntryRef>;\nusing imported_symbol_iterator = content_iterator<ImportedSymbolRef>;\nusing base_reloc_iterator = content_iterator<BaseRelocRef>;\n\n/// The DOS compatible header at the front of all PE/COFF executables.\nstruct dos_header {\n  char                 Magic[2];\n  support::ulittle16_t UsedBytesInTheLastPage;\n  support::ulittle16_t FileSizeInPages;\n  support::ulittle16_t NumberOfRelocationItems;\n  support::ulittle16_t HeaderSizeInParagraphs;\n  support::ulittle16_t MinimumExtraParagraphs;\n  support::ulittle16_t MaximumExtraParagraphs;\n  support::ulittle16_t InitialRelativeSS;\n  support::ulittle16_t InitialSP;\n  support::ulittle16_t Checksum;\n  support::ulittle16_t InitialIP;\n  support::ulittle16_t InitialRelativeCS;\n  support::ulittle16_t AddressOfRelocationTable;\n  support::ulittle16_t OverlayNumber;\n  support::ulittle16_t Reserved[4];\n  support::ulittle16_t OEMid;\n  support::ulittle16_t OEMinfo;\n  support::ulittle16_t Reserved2[10];\n  support::ulittle32_t AddressOfNewExeHeader;\n};\n\nstruct coff_file_header {\n  support::ulittle16_t Machine;\n  support::ulittle16_t NumberOfSections;\n  support::ulittle32_t TimeDateStamp;\n  support::ulittle32_t PointerToSymbolTable;\n  support::ulittle32_t NumberOfSymbols;\n  support::ulittle16_t SizeOfOptionalHeader;\n  support::ulittle16_t Characteristics;\n\n  bool isImportLibrary() const { return NumberOfSections == 0xffff; }\n};\n\nstruct coff_bigobj_file_header {\n  support::ulittle16_t Sig1;\n  support::ulittle16_t Sig2;\n  support::ulittle16_t Version;\n  support::ulittle16_t Machine;\n  support::ulittle32_t TimeDateStamp;\n  uint8_t              UUID[16];\n  support::ulittle32_t unused1;\n  support::ulittle32_t unused2;\n  support::ulittle32_t unused3;\n  support::ulittle32_t unused4;\n  support::ulittle32_t NumberOfSections;\n  support::ulittle32_t PointerToSymbolTable;\n  support::ulittle32_t NumberOfSymbols;\n};\n\n/// The 32-bit PE header that follows the COFF header.\nstruct pe32_header {\n  support::ulittle16_t Magic;\n  uint8_t MajorLinkerVersion;\n  uint8_t MinorLinkerVersion;\n  support::ulittle32_t SizeOfCode;\n  support::ulittle32_t SizeOfInitializedData;\n  support::ulittle32_t SizeOfUninitializedData;\n  support::ulittle32_t AddressOfEntryPoint;\n  support::ulittle32_t BaseOfCode;\n  support::ulittle32_t BaseOfData;\n  support::ulittle32_t ImageBase;\n  support::ulittle32_t SectionAlignment;\n  support::ulittle32_t FileAlignment;\n  support::ulittle16_t MajorOperatingSystemVersion;\n  support::ulittle16_t MinorOperatingSystemVersion;\n  support::ulittle16_t MajorImageVersion;\n  support::ulittle16_t MinorImageVersion;\n  support::ulittle16_t MajorSubsystemVersion;\n  support::ulittle16_t MinorSubsystemVersion;\n  support::ulittle32_t Win32VersionValue;\n  support::ulittle32_t SizeOfImage;\n  support::ulittle32_t SizeOfHeaders;\n  support::ulittle32_t CheckSum;\n  support::ulittle16_t Subsystem;\n  // FIXME: This should be DllCharacteristics.\n  support::ulittle16_t DLLCharacteristics;\n  support::ulittle32_t SizeOfStackReserve;\n  support::ulittle32_t SizeOfStackCommit;\n  support::ulittle32_t SizeOfHeapReserve;\n  support::ulittle32_t SizeOfHeapCommit;\n  support::ulittle32_t LoaderFlags;\n  // FIXME: This should be NumberOfRvaAndSizes.\n  support::ulittle32_t NumberOfRvaAndSize;\n};\n\n/// The 64-bit PE header that follows the COFF header.\nstruct pe32plus_header {\n  support::ulittle16_t Magic;\n  uint8_t MajorLinkerVersion;\n  uint8_t MinorLinkerVersion;\n  support::ulittle32_t SizeOfCode;\n  support::ulittle32_t SizeOfInitializedData;\n  support::ulittle32_t SizeOfUninitializedData;\n  support::ulittle32_t AddressOfEntryPoint;\n  support::ulittle32_t BaseOfCode;\n  support::ulittle64_t ImageBase;\n  support::ulittle32_t SectionAlignment;\n  support::ulittle32_t FileAlignment;\n  support::ulittle16_t MajorOperatingSystemVersion;\n  support::ulittle16_t MinorOperatingSystemVersion;\n  support::ulittle16_t MajorImageVersion;\n  support::ulittle16_t MinorImageVersion;\n  support::ulittle16_t MajorSubsystemVersion;\n  support::ulittle16_t MinorSubsystemVersion;\n  support::ulittle32_t Win32VersionValue;\n  support::ulittle32_t SizeOfImage;\n  support::ulittle32_t SizeOfHeaders;\n  support::ulittle32_t CheckSum;\n  support::ulittle16_t Subsystem;\n  support::ulittle16_t DLLCharacteristics;\n  support::ulittle64_t SizeOfStackReserve;\n  support::ulittle64_t SizeOfStackCommit;\n  support::ulittle64_t SizeOfHeapReserve;\n  support::ulittle64_t SizeOfHeapCommit;\n  support::ulittle32_t LoaderFlags;\n  support::ulittle32_t NumberOfRvaAndSize;\n};\n\nstruct data_directory {\n  support::ulittle32_t RelativeVirtualAddress;\n  support::ulittle32_t Size;\n};\n\nstruct debug_directory {\n  support::ulittle32_t Characteristics;\n  support::ulittle32_t TimeDateStamp;\n  support::ulittle16_t MajorVersion;\n  support::ulittle16_t MinorVersion;\n  support::ulittle32_t Type;\n  support::ulittle32_t SizeOfData;\n  support::ulittle32_t AddressOfRawData;\n  support::ulittle32_t PointerToRawData;\n};\n\ntemplate <typename IntTy>\nstruct import_lookup_table_entry {\n  IntTy Data;\n\n  bool isOrdinal() const { return Data < 0; }\n\n  uint16_t getOrdinal() const {\n    assert(isOrdinal() && \"ILT entry is not an ordinal!\");\n    return Data & 0xFFFF;\n  }\n\n  uint32_t getHintNameRVA() const {\n    assert(!isOrdinal() && \"ILT entry is not a Hint/Name RVA!\");\n    return Data & 0xFFFFFFFF;\n  }\n};\n\nusing import_lookup_table_entry32 =\n    import_lookup_table_entry<support::little32_t>;\nusing import_lookup_table_entry64 =\n    import_lookup_table_entry<support::little64_t>;\n\nstruct delay_import_directory_table_entry {\n  // dumpbin reports this field as \"Characteristics\" instead of \"Attributes\".\n  support::ulittle32_t Attributes;\n  support::ulittle32_t Name;\n  support::ulittle32_t ModuleHandle;\n  support::ulittle32_t DelayImportAddressTable;\n  support::ulittle32_t DelayImportNameTable;\n  support::ulittle32_t BoundDelayImportTable;\n  support::ulittle32_t UnloadDelayImportTable;\n  support::ulittle32_t TimeStamp;\n};\n\nstruct export_directory_table_entry {\n  support::ulittle32_t ExportFlags;\n  support::ulittle32_t TimeDateStamp;\n  support::ulittle16_t MajorVersion;\n  support::ulittle16_t MinorVersion;\n  support::ulittle32_t NameRVA;\n  support::ulittle32_t OrdinalBase;\n  support::ulittle32_t AddressTableEntries;\n  support::ulittle32_t NumberOfNamePointers;\n  support::ulittle32_t ExportAddressTableRVA;\n  support::ulittle32_t NamePointerRVA;\n  support::ulittle32_t OrdinalTableRVA;\n};\n\nunion export_address_table_entry {\n  support::ulittle32_t ExportRVA;\n  support::ulittle32_t ForwarderRVA;\n};\n\nusing export_name_pointer_table_entry = support::ulittle32_t;\nusing export_ordinal_table_entry = support::ulittle16_t;\n\nstruct StringTableOffset {\n  support::ulittle32_t Zeroes;\n  support::ulittle32_t Offset;\n};\n\ntemplate <typename SectionNumberType>\nstruct coff_symbol {\n  union {\n    char ShortName[COFF::NameSize];\n    StringTableOffset Offset;\n  } Name;\n\n  support::ulittle32_t Value;\n  SectionNumberType SectionNumber;\n\n  support::ulittle16_t Type;\n\n  uint8_t StorageClass;\n  uint8_t NumberOfAuxSymbols;\n};\n\nusing coff_symbol16 = coff_symbol<support::ulittle16_t>;\nusing coff_symbol32 = coff_symbol<support::ulittle32_t>;\n\n// Contains only common parts of coff_symbol16 and coff_symbol32.\nstruct coff_symbol_generic {\n  union {\n    char ShortName[COFF::NameSize];\n    StringTableOffset Offset;\n  } Name;\n  support::ulittle32_t Value;\n};\n\nstruct coff_aux_section_definition;\nstruct coff_aux_weak_external;\n\nclass COFFSymbolRef {\npublic:\n  COFFSymbolRef() = default;\n  COFFSymbolRef(const coff_symbol16 *CS) : CS16(CS) {}\n  COFFSymbolRef(const coff_symbol32 *CS) : CS32(CS) {}\n\n  const void *getRawPtr() const {\n    return CS16 ? static_cast<const void *>(CS16) : CS32;\n  }\n\n  const coff_symbol_generic *getGeneric() const {\n    if (CS16)\n      return reinterpret_cast<const coff_symbol_generic *>(CS16);\n    return reinterpret_cast<const coff_symbol_generic *>(CS32);\n  }\n\n  friend bool operator<(COFFSymbolRef A, COFFSymbolRef B) {\n    return A.getRawPtr() < B.getRawPtr();\n  }\n\n  bool isBigObj() const {\n    if (CS16)\n      return false;\n    if (CS32)\n      return true;\n    llvm_unreachable(\"COFFSymbolRef points to nothing!\");\n  }\n\n  const char *getShortName() const {\n    return CS16 ? CS16->Name.ShortName : CS32->Name.ShortName;\n  }\n\n  const StringTableOffset &getStringTableOffset() const {\n    assert(isSet() && \"COFFSymbolRef points to nothing!\");\n    return CS16 ? CS16->Name.Offset : CS32->Name.Offset;\n  }\n\n  uint32_t getValue() const {\n    assert(isSet() && \"COFFSymbolRef points to nothing!\");\n    return CS16 ? CS16->Value : CS32->Value;\n  }\n\n  int32_t getSectionNumber() const {\n    assert(isSet() && \"COFFSymbolRef points to nothing!\");\n    if (CS16) {\n      // Reserved sections are returned as negative numbers.\n      if (CS16->SectionNumber <= COFF::MaxNumberOfSections16)\n        return CS16->SectionNumber;\n      return static_cast<int16_t>(CS16->SectionNumber);\n    }\n    return static_cast<int32_t>(CS32->SectionNumber);\n  }\n\n  uint16_t getType() const {\n    assert(isSet() && \"COFFSymbolRef points to nothing!\");\n    return CS16 ? CS16->Type : CS32->Type;\n  }\n\n  uint8_t getStorageClass() const {\n    assert(isSet() && \"COFFSymbolRef points to nothing!\");\n    return CS16 ? CS16->StorageClass : CS32->StorageClass;\n  }\n\n  uint8_t getNumberOfAuxSymbols() const {\n    assert(isSet() && \"COFFSymbolRef points to nothing!\");\n    return CS16 ? CS16->NumberOfAuxSymbols : CS32->NumberOfAuxSymbols;\n  }\n\n  uint8_t getBaseType() const { return getType() & 0x0F; }\n\n  uint8_t getComplexType() const {\n    return (getType() & 0xF0) >> COFF::SCT_COMPLEX_TYPE_SHIFT;\n  }\n\n  template <typename T> const T *getAux() const {\n    return CS16 ? reinterpret_cast<const T *>(CS16 + 1)\n                : reinterpret_cast<const T *>(CS32 + 1);\n  }\n\n  const coff_aux_section_definition *getSectionDefinition() const {\n    if (!getNumberOfAuxSymbols() ||\n        getStorageClass() != COFF::IMAGE_SYM_CLASS_STATIC)\n      return nullptr;\n    return getAux<coff_aux_section_definition>();\n  }\n\n  const coff_aux_weak_external *getWeakExternal() const {\n    if (!getNumberOfAuxSymbols() ||\n        getStorageClass() != COFF::IMAGE_SYM_CLASS_WEAK_EXTERNAL)\n      return nullptr;\n    return getAux<coff_aux_weak_external>();\n  }\n\n  bool isAbsolute() const {\n    return getSectionNumber() == -1;\n  }\n\n  bool isExternal() const {\n    return getStorageClass() == COFF::IMAGE_SYM_CLASS_EXTERNAL;\n  }\n\n  bool isCommon() const {\n    return isExternal() && getSectionNumber() == COFF::IMAGE_SYM_UNDEFINED &&\n           getValue() != 0;\n  }\n\n  bool isUndefined() const {\n    return isExternal() && getSectionNumber() == COFF::IMAGE_SYM_UNDEFINED &&\n           getValue() == 0;\n  }\n\n  bool isWeakExternal() const {\n    return getStorageClass() == COFF::IMAGE_SYM_CLASS_WEAK_EXTERNAL;\n  }\n\n  bool isFunctionDefinition() const {\n    return isExternal() && getBaseType() == COFF::IMAGE_SYM_TYPE_NULL &&\n           getComplexType() == COFF::IMAGE_SYM_DTYPE_FUNCTION &&\n           !COFF::isReservedSectionNumber(getSectionNumber());\n  }\n\n  bool isFunctionLineInfo() const {\n    return getStorageClass() == COFF::IMAGE_SYM_CLASS_FUNCTION;\n  }\n\n  bool isAnyUndefined() const {\n    return isUndefined() || isWeakExternal();\n  }\n\n  bool isFileRecord() const {\n    return getStorageClass() == COFF::IMAGE_SYM_CLASS_FILE;\n  }\n\n  bool isSection() const {\n    return getStorageClass() == COFF::IMAGE_SYM_CLASS_SECTION;\n  }\n\n  bool isSectionDefinition() const {\n    // C++/CLI creates external ABS symbols for non-const appdomain globals.\n    // These are also followed by an auxiliary section definition.\n    bool isAppdomainGlobal =\n        getStorageClass() == COFF::IMAGE_SYM_CLASS_EXTERNAL &&\n        getSectionNumber() == COFF::IMAGE_SYM_ABSOLUTE;\n    bool isOrdinarySection = getStorageClass() == COFF::IMAGE_SYM_CLASS_STATIC;\n    if (!getNumberOfAuxSymbols())\n      return false;\n    return isAppdomainGlobal || isOrdinarySection;\n  }\n\n  bool isCLRToken() const {\n    return getStorageClass() == COFF::IMAGE_SYM_CLASS_CLR_TOKEN;\n  }\n\nprivate:\n  bool isSet() const { return CS16 || CS32; }\n\n  const coff_symbol16 *CS16 = nullptr;\n  const coff_symbol32 *CS32 = nullptr;\n};\n\nstruct coff_section {\n  char Name[COFF::NameSize];\n  support::ulittle32_t VirtualSize;\n  support::ulittle32_t VirtualAddress;\n  support::ulittle32_t SizeOfRawData;\n  support::ulittle32_t PointerToRawData;\n  support::ulittle32_t PointerToRelocations;\n  support::ulittle32_t PointerToLinenumbers;\n  support::ulittle16_t NumberOfRelocations;\n  support::ulittle16_t NumberOfLinenumbers;\n  support::ulittle32_t Characteristics;\n\n  // Returns true if the actual number of relocations is stored in\n  // VirtualAddress field of the first relocation table entry.\n  bool hasExtendedRelocations() const {\n    return (Characteristics & COFF::IMAGE_SCN_LNK_NRELOC_OVFL) &&\n           NumberOfRelocations == UINT16_MAX;\n  }\n\n  uint32_t getAlignment() const {\n    // The IMAGE_SCN_TYPE_NO_PAD bit is a legacy way of getting to\n    // IMAGE_SCN_ALIGN_1BYTES.\n    if (Characteristics & COFF::IMAGE_SCN_TYPE_NO_PAD)\n      return 1;\n\n    // Bit [20:24] contains section alignment. 0 means use a default alignment\n    // of 16.\n    uint32_t Shift = (Characteristics >> 20) & 0xF;\n    if (Shift > 0)\n      return 1U << (Shift - 1);\n    return 16;\n  }\n};\n\nstruct coff_relocation {\n  support::ulittle32_t VirtualAddress;\n  support::ulittle32_t SymbolTableIndex;\n  support::ulittle16_t Type;\n};\n\nstruct coff_aux_function_definition {\n  support::ulittle32_t TagIndex;\n  support::ulittle32_t TotalSize;\n  support::ulittle32_t PointerToLinenumber;\n  support::ulittle32_t PointerToNextFunction;\n  char Unused1[2];\n};\n\nstatic_assert(sizeof(coff_aux_function_definition) == 18,\n              \"auxiliary entry must be 18 bytes\");\n\nstruct coff_aux_bf_and_ef_symbol {\n  char Unused1[4];\n  support::ulittle16_t Linenumber;\n  char Unused2[6];\n  support::ulittle32_t PointerToNextFunction;\n  char Unused3[2];\n};\n\nstatic_assert(sizeof(coff_aux_bf_and_ef_symbol) == 18,\n              \"auxiliary entry must be 18 bytes\");\n\nstruct coff_aux_weak_external {\n  support::ulittle32_t TagIndex;\n  support::ulittle32_t Characteristics;\n  char Unused1[10];\n};\n\nstatic_assert(sizeof(coff_aux_weak_external) == 18,\n              \"auxiliary entry must be 18 bytes\");\n\nstruct coff_aux_section_definition {\n  support::ulittle32_t Length;\n  support::ulittle16_t NumberOfRelocations;\n  support::ulittle16_t NumberOfLinenumbers;\n  support::ulittle32_t CheckSum;\n  support::ulittle16_t NumberLowPart;\n  uint8_t              Selection;\n  uint8_t              Unused;\n  support::ulittle16_t NumberHighPart;\n  int32_t getNumber(bool IsBigObj) const {\n    uint32_t Number = static_cast<uint32_t>(NumberLowPart);\n    if (IsBigObj)\n      Number |= static_cast<uint32_t>(NumberHighPart) << 16;\n    return static_cast<int32_t>(Number);\n  }\n};\n\nstatic_assert(sizeof(coff_aux_section_definition) == 18,\n              \"auxiliary entry must be 18 bytes\");\n\nstruct coff_aux_clr_token {\n  uint8_t              AuxType;\n  uint8_t              Reserved;\n  support::ulittle32_t SymbolTableIndex;\n  char                 MBZ[12];\n};\n\nstatic_assert(sizeof(coff_aux_clr_token) == 18,\n              \"auxiliary entry must be 18 bytes\");\n\nstruct coff_import_header {\n  support::ulittle16_t Sig1;\n  support::ulittle16_t Sig2;\n  support::ulittle16_t Version;\n  support::ulittle16_t Machine;\n  support::ulittle32_t TimeDateStamp;\n  support::ulittle32_t SizeOfData;\n  support::ulittle16_t OrdinalHint;\n  support::ulittle16_t TypeInfo;\n\n  int getType() const { return TypeInfo & 0x3; }\n  int getNameType() const { return (TypeInfo >> 2) & 0x7; }\n};\n\nstruct coff_import_directory_table_entry {\n  support::ulittle32_t ImportLookupTableRVA;\n  support::ulittle32_t TimeDateStamp;\n  support::ulittle32_t ForwarderChain;\n  support::ulittle32_t NameRVA;\n  support::ulittle32_t ImportAddressTableRVA;\n\n  bool isNull() const {\n    return ImportLookupTableRVA == 0 && TimeDateStamp == 0 &&\n           ForwarderChain == 0 && NameRVA == 0 && ImportAddressTableRVA == 0;\n  }\n};\n\ntemplate <typename IntTy>\nstruct coff_tls_directory {\n  IntTy StartAddressOfRawData;\n  IntTy EndAddressOfRawData;\n  IntTy AddressOfIndex;\n  IntTy AddressOfCallBacks;\n  support::ulittle32_t SizeOfZeroFill;\n  support::ulittle32_t Characteristics;\n\n  uint32_t getAlignment() const {\n    // Bit [20:24] contains section alignment.\n    uint32_t Shift = (Characteristics & COFF::IMAGE_SCN_ALIGN_MASK) >> 20;\n    if (Shift > 0)\n      return 1U << (Shift - 1);\n    return 0;\n  }\n\n  void setAlignment(uint32_t Align) {\n    uint32_t AlignBits = 0;\n    if (Align) {\n      assert(llvm::isPowerOf2_32(Align) && \"alignment is not a power of 2\");\n      assert(llvm::Log2_32(Align) <= 13 && \"alignment requested is too large\");\n      AlignBits = (llvm::Log2_32(Align) + 1) << 20;\n    }\n    Characteristics =\n        (Characteristics & ~COFF::IMAGE_SCN_ALIGN_MASK) | AlignBits;\n  }\n};\n\nusing coff_tls_directory32 = coff_tls_directory<support::little32_t>;\nusing coff_tls_directory64 = coff_tls_directory<support::little64_t>;\n\n/// Bits in control flow guard flags as we understand them.\nenum class coff_guard_flags : uint32_t {\n  CFInstrumented = 0x00000100,\n  HasFidTable = 0x00000400,\n  ProtectDelayLoadIAT = 0x00001000,\n  DelayLoadIATSection = 0x00002000, // Delay load in separate section\n  HasLongJmpTable = 0x00010000,\n  FidTableHasFlags = 0x10000000, // Indicates that fid tables are 5 bytes\n};\n\nenum class frame_type : uint16_t { Fpo = 0, Trap = 1, Tss = 2, NonFpo = 3 };\n\nstruct coff_load_config_code_integrity {\n  support::ulittle16_t Flags;\n  support::ulittle16_t Catalog;\n  support::ulittle32_t CatalogOffset;\n  support::ulittle32_t Reserved;\n};\n\n/// 32-bit load config (IMAGE_LOAD_CONFIG_DIRECTORY32)\nstruct coff_load_configuration32 {\n  support::ulittle32_t Size;\n  support::ulittle32_t TimeDateStamp;\n  support::ulittle16_t MajorVersion;\n  support::ulittle16_t MinorVersion;\n  support::ulittle32_t GlobalFlagsClear;\n  support::ulittle32_t GlobalFlagsSet;\n  support::ulittle32_t CriticalSectionDefaultTimeout;\n  support::ulittle32_t DeCommitFreeBlockThreshold;\n  support::ulittle32_t DeCommitTotalFreeThreshold;\n  support::ulittle32_t LockPrefixTable;\n  support::ulittle32_t MaximumAllocationSize;\n  support::ulittle32_t VirtualMemoryThreshold;\n  support::ulittle32_t ProcessAffinityMask;\n  support::ulittle32_t ProcessHeapFlags;\n  support::ulittle16_t CSDVersion;\n  support::ulittle16_t DependentLoadFlags;\n  support::ulittle32_t EditList;\n  support::ulittle32_t SecurityCookie;\n  support::ulittle32_t SEHandlerTable;\n  support::ulittle32_t SEHandlerCount;\n\n  // Added in MSVC 2015 for /guard:cf.\n  support::ulittle32_t GuardCFCheckFunction;\n  support::ulittle32_t GuardCFCheckDispatch;\n  support::ulittle32_t GuardCFFunctionTable;\n  support::ulittle32_t GuardCFFunctionCount;\n  support::ulittle32_t GuardFlags; // coff_guard_flags\n\n  // Added in MSVC 2017\n  coff_load_config_code_integrity CodeIntegrity;\n  support::ulittle32_t GuardAddressTakenIatEntryTable;\n  support::ulittle32_t GuardAddressTakenIatEntryCount;\n  support::ulittle32_t GuardLongJumpTargetTable;\n  support::ulittle32_t GuardLongJumpTargetCount;\n  support::ulittle32_t DynamicValueRelocTable;\n  support::ulittle32_t CHPEMetadataPointer;\n  support::ulittle32_t GuardRFFailureRoutine;\n  support::ulittle32_t GuardRFFailureRoutineFunctionPointer;\n  support::ulittle32_t DynamicValueRelocTableOffset;\n  support::ulittle16_t DynamicValueRelocTableSection;\n  support::ulittle16_t Reserved2;\n  support::ulittle32_t GuardRFVerifyStackPointerFunctionPointer;\n  support::ulittle32_t HotPatchTableOffset;\n};\n\n/// 64-bit load config (IMAGE_LOAD_CONFIG_DIRECTORY64)\nstruct coff_load_configuration64 {\n  support::ulittle32_t Size;\n  support::ulittle32_t TimeDateStamp;\n  support::ulittle16_t MajorVersion;\n  support::ulittle16_t MinorVersion;\n  support::ulittle32_t GlobalFlagsClear;\n  support::ulittle32_t GlobalFlagsSet;\n  support::ulittle32_t CriticalSectionDefaultTimeout;\n  support::ulittle64_t DeCommitFreeBlockThreshold;\n  support::ulittle64_t DeCommitTotalFreeThreshold;\n  support::ulittle64_t LockPrefixTable;\n  support::ulittle64_t MaximumAllocationSize;\n  support::ulittle64_t VirtualMemoryThreshold;\n  support::ulittle64_t ProcessAffinityMask;\n  support::ulittle32_t ProcessHeapFlags;\n  support::ulittle16_t CSDVersion;\n  support::ulittle16_t DependentLoadFlags;\n  support::ulittle64_t EditList;\n  support::ulittle64_t SecurityCookie;\n  support::ulittle64_t SEHandlerTable;\n  support::ulittle64_t SEHandlerCount;\n\n  // Added in MSVC 2015 for /guard:cf.\n  support::ulittle64_t GuardCFCheckFunction;\n  support::ulittle64_t GuardCFCheckDispatch;\n  support::ulittle64_t GuardCFFunctionTable;\n  support::ulittle64_t GuardCFFunctionCount;\n  support::ulittle32_t GuardFlags;\n\n  // Added in MSVC 2017\n  coff_load_config_code_integrity CodeIntegrity;\n  support::ulittle64_t GuardAddressTakenIatEntryTable;\n  support::ulittle64_t GuardAddressTakenIatEntryCount;\n  support::ulittle64_t GuardLongJumpTargetTable;\n  support::ulittle64_t GuardLongJumpTargetCount;\n  support::ulittle64_t DynamicValueRelocTable;\n  support::ulittle64_t CHPEMetadataPointer;\n  support::ulittle64_t GuardRFFailureRoutine;\n  support::ulittle64_t GuardRFFailureRoutineFunctionPointer;\n  support::ulittle32_t DynamicValueRelocTableOffset;\n  support::ulittle16_t DynamicValueRelocTableSection;\n  support::ulittle16_t Reserved2;\n  support::ulittle64_t GuardRFVerifyStackPointerFunctionPointer;\n  support::ulittle32_t HotPatchTableOffset;\n};\n\nstruct coff_runtime_function_x64 {\n  support::ulittle32_t BeginAddress;\n  support::ulittle32_t EndAddress;\n  support::ulittle32_t UnwindInformation;\n};\n\nstruct coff_base_reloc_block_header {\n  support::ulittle32_t PageRVA;\n  support::ulittle32_t BlockSize;\n};\n\nstruct coff_base_reloc_block_entry {\n  support::ulittle16_t Data;\n\n  int getType() const { return Data >> 12; }\n  int getOffset() const { return Data & ((1 << 12) - 1); }\n};\n\nstruct coff_resource_dir_entry {\n  union {\n    support::ulittle32_t NameOffset;\n    support::ulittle32_t ID;\n    uint32_t getNameOffset() const {\n      return maskTrailingOnes<uint32_t>(31) & NameOffset;\n    }\n    // Even though the PE/COFF spec doesn't mention this, the high bit of a name\n    // offset is set.\n    void setNameOffset(uint32_t Offset) { NameOffset = Offset | (1 << 31); }\n  } Identifier;\n  union {\n    support::ulittle32_t DataEntryOffset;\n    support::ulittle32_t SubdirOffset;\n\n    bool isSubDir() const { return SubdirOffset >> 31; }\n    uint32_t value() const {\n      return maskTrailingOnes<uint32_t>(31) & SubdirOffset;\n    }\n\n  } Offset;\n};\n\nstruct coff_resource_data_entry {\n  support::ulittle32_t DataRVA;\n  support::ulittle32_t DataSize;\n  support::ulittle32_t Codepage;\n  support::ulittle32_t Reserved;\n};\n\nstruct coff_resource_dir_table {\n  support::ulittle32_t Characteristics;\n  support::ulittle32_t TimeDateStamp;\n  support::ulittle16_t MajorVersion;\n  support::ulittle16_t MinorVersion;\n  support::ulittle16_t NumberOfNameEntries;\n  support::ulittle16_t NumberOfIDEntries;\n};\n\nstruct debug_h_header {\n  support::ulittle32_t Magic;\n  support::ulittle16_t Version;\n  support::ulittle16_t HashAlgorithm;\n};\n\nclass COFFObjectFile : public ObjectFile {\nprivate:\n  COFFObjectFile(MemoryBufferRef Object);\n\n  friend class ImportDirectoryEntryRef;\n  friend class ExportDirectoryEntryRef;\n  const coff_file_header *COFFHeader;\n  const coff_bigobj_file_header *COFFBigObjHeader;\n  const pe32_header *PE32Header;\n  const pe32plus_header *PE32PlusHeader;\n  const data_directory *DataDirectory;\n  const coff_section *SectionTable;\n  const coff_symbol16 *SymbolTable16;\n  const coff_symbol32 *SymbolTable32;\n  const char *StringTable;\n  uint32_t StringTableSize;\n  const coff_import_directory_table_entry *ImportDirectory;\n  const delay_import_directory_table_entry *DelayImportDirectory;\n  uint32_t NumberOfDelayImportDirectory;\n  const export_directory_table_entry *ExportDirectory;\n  const coff_base_reloc_block_header *BaseRelocHeader;\n  const coff_base_reloc_block_header *BaseRelocEnd;\n  const debug_directory *DebugDirectoryBegin;\n  const debug_directory *DebugDirectoryEnd;\n  const coff_tls_directory32 *TLSDirectory32;\n  const coff_tls_directory64 *TLSDirectory64;\n  // Either coff_load_configuration32 or coff_load_configuration64.\n  const void *LoadConfig = nullptr;\n\n  Expected<StringRef> getString(uint32_t offset) const;\n\n  template <typename coff_symbol_type>\n  const coff_symbol_type *toSymb(DataRefImpl Symb) const;\n  const coff_section *toSec(DataRefImpl Sec) const;\n  const coff_relocation *toRel(DataRefImpl Rel) const;\n\n  // Finish initializing the object and return success or an error.\n  Error initialize();\n\n  Error initSymbolTablePtr();\n  Error initImportTablePtr();\n  Error initDelayImportTablePtr();\n  Error initExportTablePtr();\n  Error initBaseRelocPtr();\n  Error initDebugDirectoryPtr();\n  Error initTLSDirectoryPtr();\n  Error initLoadConfigPtr();\n\npublic:\n  static Expected<std::unique_ptr<COFFObjectFile>>\n  create(MemoryBufferRef Object);\n\n  uintptr_t getSymbolTable() const {\n    if (SymbolTable16)\n      return reinterpret_cast<uintptr_t>(SymbolTable16);\n    if (SymbolTable32)\n      return reinterpret_cast<uintptr_t>(SymbolTable32);\n    return uintptr_t(0);\n  }\n\n  uint16_t getMachine() const {\n    if (COFFHeader)\n      return COFFHeader->Machine;\n    if (COFFBigObjHeader)\n      return COFFBigObjHeader->Machine;\n    llvm_unreachable(\"no COFF header!\");\n  }\n\n  uint16_t getSizeOfOptionalHeader() const {\n    if (COFFHeader)\n      return COFFHeader->isImportLibrary() ? 0\n                                           : COFFHeader->SizeOfOptionalHeader;\n    // bigobj doesn't have this field.\n    if (COFFBigObjHeader)\n      return 0;\n    llvm_unreachable(\"no COFF header!\");\n  }\n\n  uint16_t getCharacteristics() const {\n    if (COFFHeader)\n      return COFFHeader->isImportLibrary() ? 0 : COFFHeader->Characteristics;\n    // bigobj doesn't have characteristics to speak of,\n    // editbin will silently lie to you if you attempt to set any.\n    if (COFFBigObjHeader)\n      return 0;\n    llvm_unreachable(\"no COFF header!\");\n  }\n\n  uint32_t getTimeDateStamp() const {\n    if (COFFHeader)\n      return COFFHeader->TimeDateStamp;\n    if (COFFBigObjHeader)\n      return COFFBigObjHeader->TimeDateStamp;\n    llvm_unreachable(\"no COFF header!\");\n  }\n\n  uint32_t getNumberOfSections() const {\n    if (COFFHeader)\n      return COFFHeader->isImportLibrary() ? 0 : COFFHeader->NumberOfSections;\n    if (COFFBigObjHeader)\n      return COFFBigObjHeader->NumberOfSections;\n    llvm_unreachable(\"no COFF header!\");\n  }\n\n  uint32_t getPointerToSymbolTable() const {\n    if (COFFHeader)\n      return COFFHeader->isImportLibrary() ? 0\n                                           : COFFHeader->PointerToSymbolTable;\n    if (COFFBigObjHeader)\n      return COFFBigObjHeader->PointerToSymbolTable;\n    llvm_unreachable(\"no COFF header!\");\n  }\n\n  uint32_t getRawNumberOfSymbols() const {\n    if (COFFHeader)\n      return COFFHeader->isImportLibrary() ? 0 : COFFHeader->NumberOfSymbols;\n    if (COFFBigObjHeader)\n      return COFFBigObjHeader->NumberOfSymbols;\n    llvm_unreachable(\"no COFF header!\");\n  }\n\n  uint32_t getNumberOfSymbols() const {\n    if (!SymbolTable16 && !SymbolTable32)\n      return 0;\n    return getRawNumberOfSymbols();\n  }\n\n  uint32_t getStringTableSize() const { return StringTableSize; }\n\n  const coff_load_configuration32 *getLoadConfig32() const {\n    assert(!is64());\n    return reinterpret_cast<const coff_load_configuration32 *>(LoadConfig);\n  }\n\n  const coff_load_configuration64 *getLoadConfig64() const {\n    assert(is64());\n    return reinterpret_cast<const coff_load_configuration64 *>(LoadConfig);\n  }\n  StringRef getRelocationTypeName(uint16_t Type) const;\n\nprotected:\n  void moveSymbolNext(DataRefImpl &Symb) const override;\n  Expected<StringRef> getSymbolName(DataRefImpl Symb) const override;\n  Expected<uint64_t> getSymbolAddress(DataRefImpl Symb) const override;\n  uint32_t getSymbolAlignment(DataRefImpl Symb) const override;\n  uint64_t getSymbolValueImpl(DataRefImpl Symb) const override;\n  uint64_t getCommonSymbolSizeImpl(DataRefImpl Symb) const override;\n  Expected<uint32_t> getSymbolFlags(DataRefImpl Symb) const override;\n  Expected<SymbolRef::Type> getSymbolType(DataRefImpl Symb) const override;\n  Expected<section_iterator> getSymbolSection(DataRefImpl Symb) const override;\n  void moveSectionNext(DataRefImpl &Sec) const override;\n  Expected<StringRef> getSectionName(DataRefImpl Sec) const override;\n  uint64_t getSectionAddress(DataRefImpl Sec) const override;\n  uint64_t getSectionIndex(DataRefImpl Sec) const override;\n  uint64_t getSectionSize(DataRefImpl Sec) const override;\n  Expected<ArrayRef<uint8_t>>\n  getSectionContents(DataRefImpl Sec) const override;\n  uint64_t getSectionAlignment(DataRefImpl Sec) const override;\n  bool isSectionCompressed(DataRefImpl Sec) const override;\n  bool isSectionText(DataRefImpl Sec) const override;\n  bool isSectionData(DataRefImpl Sec) const override;\n  bool isSectionBSS(DataRefImpl Sec) const override;\n  bool isSectionVirtual(DataRefImpl Sec) const override;\n  bool isDebugSection(StringRef SectionName) const override;\n  relocation_iterator section_rel_begin(DataRefImpl Sec) const override;\n  relocation_iterator section_rel_end(DataRefImpl Sec) const override;\n\n  void moveRelocationNext(DataRefImpl &Rel) const override;\n  uint64_t getRelocationOffset(DataRefImpl Rel) const override;\n  symbol_iterator getRelocationSymbol(DataRefImpl Rel) const override;\n  uint64_t getRelocationType(DataRefImpl Rel) const override;\n  void getRelocationTypeName(DataRefImpl Rel,\n                             SmallVectorImpl<char> &Result) const override;\n\npublic:\n  basic_symbol_iterator symbol_begin() const override;\n  basic_symbol_iterator symbol_end() const override;\n  section_iterator section_begin() const override;\n  section_iterator section_end() const override;\n\n  const coff_section *getCOFFSection(const SectionRef &Section) const;\n  COFFSymbolRef getCOFFSymbol(const DataRefImpl &Ref) const;\n  COFFSymbolRef getCOFFSymbol(const SymbolRef &Symbol) const;\n  const coff_relocation *getCOFFRelocation(const RelocationRef &Reloc) const;\n  unsigned getSectionID(SectionRef Sec) const;\n  unsigned getSymbolSectionID(SymbolRef Sym) const;\n\n  uint8_t getBytesInAddress() const override;\n  StringRef getFileFormatName() const override;\n  Triple::ArchType getArch() const override;\n  Expected<uint64_t> getStartAddress() const override;\n  SubtargetFeatures getFeatures() const override { return SubtargetFeatures(); }\n\n  import_directory_iterator import_directory_begin() const;\n  import_directory_iterator import_directory_end() const;\n  delay_import_directory_iterator delay_import_directory_begin() const;\n  delay_import_directory_iterator delay_import_directory_end() const;\n  export_directory_iterator export_directory_begin() const;\n  export_directory_iterator export_directory_end() const;\n  base_reloc_iterator base_reloc_begin() const;\n  base_reloc_iterator base_reloc_end() const;\n  const debug_directory *debug_directory_begin() const {\n    return DebugDirectoryBegin;\n  }\n  const debug_directory *debug_directory_end() const {\n    return DebugDirectoryEnd;\n  }\n\n  iterator_range<import_directory_iterator> import_directories() const;\n  iterator_range<delay_import_directory_iterator>\n      delay_import_directories() const;\n  iterator_range<export_directory_iterator> export_directories() const;\n  iterator_range<base_reloc_iterator> base_relocs() const;\n  iterator_range<const debug_directory *> debug_directories() const {\n    return make_range(debug_directory_begin(), debug_directory_end());\n  }\n\n  const coff_tls_directory32 *getTLSDirectory32() const {\n    return TLSDirectory32;\n  }\n  const coff_tls_directory64 *getTLSDirectory64() const {\n    return TLSDirectory64;\n  }\n\n  const dos_header *getDOSHeader() const {\n    if (!PE32Header && !PE32PlusHeader)\n      return nullptr;\n    return reinterpret_cast<const dos_header *>(base());\n  }\n\n  const coff_file_header *getCOFFHeader() const { return COFFHeader; }\n  const coff_bigobj_file_header *getCOFFBigObjHeader() const {\n    return COFFBigObjHeader;\n  }\n  const pe32_header *getPE32Header() const { return PE32Header; }\n  const pe32plus_header *getPE32PlusHeader() const { return PE32PlusHeader; }\n\n  const data_directory *getDataDirectory(uint32_t index) const;\n  Expected<const coff_section *> getSection(int32_t index) const;\n\n  Expected<COFFSymbolRef> getSymbol(uint32_t index) const {\n    if (index >= getNumberOfSymbols())\n      return errorCodeToError(object_error::parse_failed);\n    if (SymbolTable16)\n      return COFFSymbolRef(SymbolTable16 + index);\n    if (SymbolTable32)\n      return COFFSymbolRef(SymbolTable32 + index);\n    return errorCodeToError(object_error::parse_failed);\n  }\n\n  template <typename T>\n  Error getAuxSymbol(uint32_t index, const T *&Res) const {\n    Expected<COFFSymbolRef> S = getSymbol(index);\n    if (Error E = S.takeError())\n      return E;\n    Res = reinterpret_cast<const T *>(S->getRawPtr());\n    return Error::success();\n  }\n\n  Expected<StringRef> getSymbolName(COFFSymbolRef Symbol) const;\n  Expected<StringRef> getSymbolName(const coff_symbol_generic *Symbol) const;\n\n  ArrayRef<uint8_t> getSymbolAuxData(COFFSymbolRef Symbol) const;\n\n  uint32_t getSymbolIndex(COFFSymbolRef Symbol) const;\n\n  size_t getSymbolTableEntrySize() const {\n    if (COFFHeader)\n      return sizeof(coff_symbol16);\n    if (COFFBigObjHeader)\n      return sizeof(coff_symbol32);\n    llvm_unreachable(\"null symbol table pointer!\");\n  }\n\n  ArrayRef<coff_relocation> getRelocations(const coff_section *Sec) const;\n\n  Expected<StringRef> getSectionName(const coff_section *Sec) const;\n  uint64_t getSectionSize(const coff_section *Sec) const;\n  Error getSectionContents(const coff_section *Sec,\n                           ArrayRef<uint8_t> &Res) const;\n\n  uint64_t getImageBase() const;\n  Error getVaPtr(uint64_t VA, uintptr_t &Res) const;\n  Error getRvaPtr(uint32_t Rva, uintptr_t &Res) const;\n\n  /// Given an RVA base and size, returns a valid array of bytes or an error\n  /// code if the RVA and size is not contained completely within a valid\n  /// section.\n  Error getRvaAndSizeAsBytes(uint32_t RVA, uint32_t Size,\n                             ArrayRef<uint8_t> &Contents) const;\n\n  Error getHintName(uint32_t Rva, uint16_t &Hint,\n                              StringRef &Name) const;\n\n  /// Get PDB information out of a codeview debug directory entry.\n  Error getDebugPDBInfo(const debug_directory *DebugDir,\n                        const codeview::DebugInfo *&Info,\n                        StringRef &PDBFileName) const;\n\n  /// Get PDB information from an executable. If the information is not present,\n  /// Info will be set to nullptr and PDBFileName will be empty. An error is\n  /// returned only on corrupt object files. Convenience accessor that can be\n  /// used if the debug directory is not already handy.\n  Error getDebugPDBInfo(const codeview::DebugInfo *&Info,\n                        StringRef &PDBFileName) const;\n\n  bool isRelocatableObject() const override;\n  bool is64() const { return PE32PlusHeader; }\n\n  StringRef mapDebugSectionName(StringRef Name) const override;\n\n  static bool classof(const Binary *v) { return v->isCOFF(); }\n};\n\n// The iterator for the import directory table.\nclass ImportDirectoryEntryRef {\npublic:\n  ImportDirectoryEntryRef() = default;\n  ImportDirectoryEntryRef(const coff_import_directory_table_entry *Table,\n                          uint32_t I, const COFFObjectFile *Owner)\n      : ImportTable(Table), Index(I), OwningObject(Owner) {}\n\n  bool operator==(const ImportDirectoryEntryRef &Other) const;\n  void moveNext();\n\n  imported_symbol_iterator imported_symbol_begin() const;\n  imported_symbol_iterator imported_symbol_end() const;\n  iterator_range<imported_symbol_iterator> imported_symbols() const;\n\n  imported_symbol_iterator lookup_table_begin() const;\n  imported_symbol_iterator lookup_table_end() const;\n  iterator_range<imported_symbol_iterator> lookup_table_symbols() const;\n\n  Error getName(StringRef &Result) const;\n  Error getImportLookupTableRVA(uint32_t &Result) const;\n  Error getImportAddressTableRVA(uint32_t &Result) const;\n\n  Error\n  getImportTableEntry(const coff_import_directory_table_entry *&Result) const;\n\nprivate:\n  const coff_import_directory_table_entry *ImportTable;\n  uint32_t Index;\n  const COFFObjectFile *OwningObject = nullptr;\n};\n\nclass DelayImportDirectoryEntryRef {\npublic:\n  DelayImportDirectoryEntryRef() = default;\n  DelayImportDirectoryEntryRef(const delay_import_directory_table_entry *T,\n                               uint32_t I, const COFFObjectFile *Owner)\n      : Table(T), Index(I), OwningObject(Owner) {}\n\n  bool operator==(const DelayImportDirectoryEntryRef &Other) const;\n  void moveNext();\n\n  imported_symbol_iterator imported_symbol_begin() const;\n  imported_symbol_iterator imported_symbol_end() const;\n  iterator_range<imported_symbol_iterator> imported_symbols() const;\n\n  Error getName(StringRef &Result) const;\n  Error getDelayImportTable(\n      const delay_import_directory_table_entry *&Result) const;\n  Error getImportAddress(int AddrIndex, uint64_t &Result) const;\n\nprivate:\n  const delay_import_directory_table_entry *Table;\n  uint32_t Index;\n  const COFFObjectFile *OwningObject = nullptr;\n};\n\n// The iterator for the export directory table entry.\nclass ExportDirectoryEntryRef {\npublic:\n  ExportDirectoryEntryRef() = default;\n  ExportDirectoryEntryRef(const export_directory_table_entry *Table, uint32_t I,\n                          const COFFObjectFile *Owner)\n      : ExportTable(Table), Index(I), OwningObject(Owner) {}\n\n  bool operator==(const ExportDirectoryEntryRef &Other) const;\n  void moveNext();\n\n  Error getDllName(StringRef &Result) const;\n  Error getOrdinalBase(uint32_t &Result) const;\n  Error getOrdinal(uint32_t &Result) const;\n  Error getExportRVA(uint32_t &Result) const;\n  Error getSymbolName(StringRef &Result) const;\n\n  Error isForwarder(bool &Result) const;\n  Error getForwardTo(StringRef &Result) const;\n\nprivate:\n  const export_directory_table_entry *ExportTable;\n  uint32_t Index;\n  const COFFObjectFile *OwningObject = nullptr;\n};\n\nclass ImportedSymbolRef {\npublic:\n  ImportedSymbolRef() = default;\n  ImportedSymbolRef(const import_lookup_table_entry32 *Entry, uint32_t I,\n                    const COFFObjectFile *Owner)\n      : Entry32(Entry), Entry64(nullptr), Index(I), OwningObject(Owner) {}\n  ImportedSymbolRef(const import_lookup_table_entry64 *Entry, uint32_t I,\n                    const COFFObjectFile *Owner)\n      : Entry32(nullptr), Entry64(Entry), Index(I), OwningObject(Owner) {}\n\n  bool operator==(const ImportedSymbolRef &Other) const;\n  void moveNext();\n\n  Error getSymbolName(StringRef &Result) const;\n  Error isOrdinal(bool &Result) const;\n  Error getOrdinal(uint16_t &Result) const;\n  Error getHintNameRVA(uint32_t &Result) const;\n\nprivate:\n  const import_lookup_table_entry32 *Entry32;\n  const import_lookup_table_entry64 *Entry64;\n  uint32_t Index;\n  const COFFObjectFile *OwningObject = nullptr;\n};\n\nclass BaseRelocRef {\npublic:\n  BaseRelocRef() = default;\n  BaseRelocRef(const coff_base_reloc_block_header *Header,\n               const COFFObjectFile *Owner)\n      : Header(Header), Index(0) {}\n\n  bool operator==(const BaseRelocRef &Other) const;\n  void moveNext();\n\n  Error getType(uint8_t &Type) const;\n  Error getRVA(uint32_t &Result) const;\n\nprivate:\n  const coff_base_reloc_block_header *Header;\n  uint32_t Index;\n};\n\nclass ResourceSectionRef {\npublic:\n  ResourceSectionRef() = default;\n  explicit ResourceSectionRef(StringRef Ref) : BBS(Ref, support::little) {}\n\n  Error load(const COFFObjectFile *O);\n  Error load(const COFFObjectFile *O, const SectionRef &S);\n\n  Expected<ArrayRef<UTF16>>\n  getEntryNameString(const coff_resource_dir_entry &Entry);\n  Expected<const coff_resource_dir_table &>\n  getEntrySubDir(const coff_resource_dir_entry &Entry);\n  Expected<const coff_resource_data_entry &>\n  getEntryData(const coff_resource_dir_entry &Entry);\n  Expected<const coff_resource_dir_table &> getBaseTable();\n  Expected<const coff_resource_dir_entry &>\n  getTableEntry(const coff_resource_dir_table &Table, uint32_t Index);\n\n  Expected<StringRef> getContents(const coff_resource_data_entry &Entry);\n\nprivate:\n  BinaryByteStream BBS;\n\n  SectionRef Section;\n  const COFFObjectFile *Obj;\n\n  std::vector<const coff_relocation *> Relocs;\n\n  Expected<const coff_resource_dir_table &> getTableAtOffset(uint32_t Offset);\n  Expected<const coff_resource_dir_entry &>\n  getTableEntryAtOffset(uint32_t Offset);\n  Expected<const coff_resource_data_entry &>\n  getDataEntryAtOffset(uint32_t Offset);\n  Expected<ArrayRef<UTF16>> getDirStringAtOffset(uint32_t Offset);\n};\n\n// Corresponds to `_FPO_DATA` structure in the PE/COFF spec.\nstruct FpoData {\n  support::ulittle32_t Offset; // ulOffStart: Offset 1st byte of function code\n  support::ulittle32_t Size;   // cbProcSize: # bytes in function\n  support::ulittle32_t NumLocals; // cdwLocals: # bytes in locals/4\n  support::ulittle16_t NumParams; // cdwParams: # bytes in params/4\n  support::ulittle16_t Attributes;\n\n  // cbProlog: # bytes in prolog\n  int getPrologSize() const { return Attributes & 0xF; }\n\n  // cbRegs: # regs saved\n  int getNumSavedRegs() const { return (Attributes >> 8) & 0x7; }\n\n  // fHasSEH: true if seh is func\n  bool hasSEH() const { return (Attributes >> 9) & 1; }\n\n  // fUseBP: true if EBP has been allocated\n  bool useBP() const { return (Attributes >> 10) & 1; }\n\n  // cbFrame: frame pointer\n  frame_type getFP() const { return static_cast<frame_type>(Attributes >> 14); }\n};\n\n} // end namespace object\n\n} // end namespace llvm\n\n#endif // LLVM_OBJECT_COFF_H\n"}, "36": {"id": 36, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Object/ELF.h", "content": "//===- ELF.h - ELF object file implementation -------------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// This file declares the ELFFile template class.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_OBJECT_ELF_H\n#define LLVM_OBJECT_ELF_H\n\n#include \"llvm/ADT/ArrayRef.h\"\n#include \"llvm/ADT/SmallVector.h\"\n#include \"llvm/ADT/StringRef.h\"\n#include \"llvm/BinaryFormat/ELF.h\"\n#include \"llvm/Object/ELFTypes.h\"\n#include \"llvm/Object/Error.h\"\n#include \"llvm/Support/Endian.h\"\n#include \"llvm/Support/Error.h\"\n#include <cassert>\n#include <cstddef>\n#include <cstdint>\n#include <limits>\n#include <utility>\n\nnamespace llvm {\nnamespace object {\n\nstruct VerdAux {\n  unsigned Offset;\n  std::string Name;\n};\n\nstruct VerDef {\n  unsigned Offset;\n  unsigned Version;\n  unsigned Flags;\n  unsigned Ndx;\n  unsigned Cnt;\n  unsigned Hash;\n  std::string Name;\n  std::vector<VerdAux> AuxV;\n};\n\nstruct VernAux {\n  unsigned Hash;\n  unsigned Flags;\n  unsigned Other;\n  unsigned Offset;\n  std::string Name;\n};\n\nstruct VerNeed {\n  unsigned Version;\n  unsigned Cnt;\n  unsigned Offset;\n  std::string File;\n  std::vector<VernAux> AuxV;\n};\n\nstruct VersionEntry {\n  std::string Name;\n  bool IsVerDef;\n};\n\nStringRef getELFRelocationTypeName(uint32_t Machine, uint32_t Type);\nuint32_t getELFRelativeRelocationType(uint32_t Machine);\nStringRef getELFSectionTypeName(uint32_t Machine, uint32_t Type);\n\n// Subclasses of ELFFile may need this for template instantiation\ninline std::pair<unsigned char, unsigned char>\ngetElfArchType(StringRef Object) {\n  if (Object.size() < ELF::EI_NIDENT)\n    return std::make_pair((uint8_t)ELF::ELFCLASSNONE,\n                          (uint8_t)ELF::ELFDATANONE);\n  return std::make_pair((uint8_t)Object[ELF::EI_CLASS],\n                        (uint8_t)Object[ELF::EI_DATA]);\n}\n\nstatic inline Error createError(const Twine &Err) {\n  return make_error<StringError>(Err, object_error::parse_failed);\n}\n\nenum PPCInstrMasks : uint64_t {\n  PADDI_R12_NO_DISP = 0x0610000039800000,\n  ADDIS_R12_TO_R2_NO_DISP = 0x3D820000,\n  ADDI_R12_TO_R2_NO_DISP = 0x39820000,\n  ADDI_R12_TO_R12_NO_DISP = 0x398C0000,\n  PLD_R12_NO_DISP = 0x04100000E5800000,\n  MTCTR_R12 = 0x7D8903A6,\n  BCTR = 0x4E800420,\n};\n\ntemplate <class ELFT> class ELFFile;\n\ntemplate <class T> struct DataRegion {\n  // This constructor is used when we know the start and the size of a data\n  // region. We assume that Arr does not go past the end of the file.\n  DataRegion(ArrayRef<T> Arr) : First(Arr.data()), Size(Arr.size()) {}\n\n  // Sometimes we only know the start of a data region. We still don't want to\n  // read past the end of the file, so we provide the end of a buffer.\n  DataRegion(const T *Data, const uint8_t *BufferEnd)\n      : First(Data), BufEnd(BufferEnd) {}\n\n  Expected<T> operator[](uint64_t N) {\n    assert(Size || BufEnd);\n    if (Size) {\n      if (N >= *Size)\n        return createError(\n            \"the index is greater than or equal to the number of entries (\" +\n            Twine(*Size) + \")\");\n    } else {\n      const uint8_t *EntryStart = (const uint8_t *)First + N * sizeof(T);\n      if (EntryStart + sizeof(T) > BufEnd)\n        return createError(\"can't read past the end of the file\");\n    }\n    return *(First + N);\n  }\n\n  const T *First;\n  Optional<uint64_t> Size = None;\n  const uint8_t *BufEnd = nullptr;\n};\n\ntemplate <class ELFT>\nstd::string getSecIndexForError(const ELFFile<ELFT> &Obj,\n                                const typename ELFT::Shdr &Sec) {\n  auto TableOrErr = Obj.sections();\n  if (TableOrErr)\n    return \"[index \" + std::to_string(&Sec - &TableOrErr->front()) + \"]\";\n  // To make this helper be more convenient for error reporting purposes we\n  // drop the error. But really it should never be triggered. Before this point,\n  // our code should have called 'sections()' and reported a proper error on\n  // failure.\n  llvm::consumeError(TableOrErr.takeError());\n  return \"[unknown index]\";\n}\n\ntemplate <class ELFT>\nstatic std::string describe(const ELFFile<ELFT> &Obj,\n                            const typename ELFT::Shdr &Sec) {\n  unsigned SecNdx = &Sec - &cantFail(Obj.sections()).front();\n  return (object::getELFSectionTypeName(Obj.getHeader().e_machine,\n                                        Sec.sh_type) +\n          \" section with index \" + Twine(SecNdx))\n      .str();\n}\n\ntemplate <class ELFT>\nstd::string getPhdrIndexForError(const ELFFile<ELFT> &Obj,\n                                 const typename ELFT::Phdr &Phdr) {\n  auto Headers = Obj.program_headers();\n  if (Headers)\n    return (\"[index \" + Twine(&Phdr - &Headers->front()) + \"]\").str();\n  // See comment in the getSecIndexForError() above.\n  llvm::consumeError(Headers.takeError());\n  return \"[unknown index]\";\n}\n\nstatic inline Error defaultWarningHandler(const Twine &Msg) {\n  return createError(Msg);\n}\n\ntemplate <class ELFT>\nclass ELFFile {\npublic:\n  LLVM_ELF_IMPORT_TYPES_ELFT(ELFT)\n\n  // This is a callback that can be passed to a number of functions.\n  // It can be used to ignore non-critical errors (warnings), which is\n  // useful for dumpers, like llvm-readobj.\n  // It accepts a warning message string and returns a success\n  // when the warning should be ignored or an error otherwise.\n  using WarningHandler = llvm::function_ref<Error(const Twine &Msg)>;\n\n  const uint8_t *base() const { return Buf.bytes_begin(); }\n  const uint8_t *end() const { return base() + getBufSize(); }\n\n  size_t getBufSize() const { return Buf.size(); }\n\nprivate:\n  StringRef Buf;\n\n  ELFFile(StringRef Object);\n\npublic:\n  const Elf_Ehdr &getHeader() const {\n    return *reinterpret_cast<const Elf_Ehdr *>(base());\n  }\n\n  template <typename T>\n  Expected<const T *> getEntry(uint32_t Section, uint32_t Entry) const;\n  template <typename T>\n  Expected<const T *> getEntry(const Elf_Shdr &Section, uint32_t Entry) const;\n\n  Expected<std::vector<VerDef>>\n  getVersionDefinitions(const Elf_Shdr &Sec) const;\n  Expected<std::vector<VerNeed>> getVersionDependencies(\n      const Elf_Shdr &Sec,\n      WarningHandler WarnHandler = &defaultWarningHandler) const;\n  Expected<StringRef>\n  getSymbolVersionByIndex(uint32_t SymbolVersionIndex, bool &IsDefault,\n                          SmallVector<Optional<VersionEntry>, 0> &VersionMap,\n                          Optional<bool> IsSymHidden) const;\n\n  Expected<StringRef>\n  getStringTable(const Elf_Shdr &Section,\n                 WarningHandler WarnHandler = &defaultWarningHandler) const;\n  Expected<StringRef> getStringTableForSymtab(const Elf_Shdr &Section) const;\n  Expected<StringRef> getStringTableForSymtab(const Elf_Shdr &Section,\n                                              Elf_Shdr_Range Sections) const;\n  Expected<StringRef> getLinkAsStrtab(const typename ELFT::Shdr &Sec) const;\n\n  Expected<ArrayRef<Elf_Word>> getSHNDXTable(const Elf_Shdr &Section) const;\n  Expected<ArrayRef<Elf_Word>> getSHNDXTable(const Elf_Shdr &Section,\n                                             Elf_Shdr_Range Sections) const;\n\n  Expected<uint64_t> getDynSymtabSize() const;\n\n  StringRef getRelocationTypeName(uint32_t Type) const;\n  void getRelocationTypeName(uint32_t Type,\n                             SmallVectorImpl<char> &Result) const;\n  uint32_t getRelativeRelocationType() const;\n\n  std::string getDynamicTagAsString(unsigned Arch, uint64_t Type) const;\n  std::string getDynamicTagAsString(uint64_t Type) const;\n\n  /// Get the symbol for a given relocation.\n  Expected<const Elf_Sym *> getRelocationSymbol(const Elf_Rel &Rel,\n                                                const Elf_Shdr *SymTab) const;\n\n  Expected<SmallVector<Optional<VersionEntry>, 0>>\n  loadVersionMap(const Elf_Shdr *VerNeedSec, const Elf_Shdr *VerDefSec) const;\n\n  static Expected<ELFFile> create(StringRef Object);\n\n  bool isLE() const {\n    return getHeader().getDataEncoding() == ELF::ELFDATA2LSB;\n  }\n\n  bool isMipsELF64() const {\n    return getHeader().e_machine == ELF::EM_MIPS &&\n           getHeader().getFileClass() == ELF::ELFCLASS64;\n  }\n\n  bool isMips64EL() const { return isMipsELF64() && isLE(); }\n\n  Expected<Elf_Shdr_Range> sections() const;\n\n  Expected<Elf_Dyn_Range> dynamicEntries() const;\n\n  Expected<const uint8_t *>\n  toMappedAddr(uint64_t VAddr,\n               WarningHandler WarnHandler = &defaultWarningHandler) const;\n\n  Expected<Elf_Sym_Range> symbols(const Elf_Shdr *Sec) const {\n    if (!Sec)\n      return makeArrayRef<Elf_Sym>(nullptr, nullptr);\n    return getSectionContentsAsArray<Elf_Sym>(*Sec);\n  }\n\n  Expected<Elf_Rela_Range> relas(const Elf_Shdr &Sec) const {\n    return getSectionContentsAsArray<Elf_Rela>(Sec);\n  }\n\n  Expected<Elf_Rel_Range> rels(const Elf_Shdr &Sec) const {\n    return getSectionContentsAsArray<Elf_Rel>(Sec);\n  }\n\n  Expected<Elf_Relr_Range> relrs(const Elf_Shdr &Sec) const {\n    return getSectionContentsAsArray<Elf_Relr>(Sec);\n  }\n\n  std::vector<Elf_Rel> decode_relrs(Elf_Relr_Range relrs) const;\n\n  Expected<std::vector<Elf_Rela>> android_relas(const Elf_Shdr &Sec) const;\n\n  /// Iterate over program header table.\n  Expected<Elf_Phdr_Range> program_headers() const {\n    if (getHeader().e_phnum && getHeader().e_phentsize != sizeof(Elf_Phdr))\n      return createError(\"invalid e_phentsize: \" +\n                         Twine(getHeader().e_phentsize));\n\n    uint64_t HeadersSize =\n        (uint64_t)getHeader().e_phnum * getHeader().e_phentsize;\n    uint64_t PhOff = getHeader().e_phoff;\n    if (PhOff + HeadersSize < PhOff || PhOff + HeadersSize > getBufSize())\n      return createError(\"program headers are longer than binary of size \" +\n                         Twine(getBufSize()) + \": e_phoff = 0x\" +\n                         Twine::utohexstr(getHeader().e_phoff) +\n                         \", e_phnum = \" + Twine(getHeader().e_phnum) +\n                         \", e_phentsize = \" + Twine(getHeader().e_phentsize));\n\n    auto *Begin = reinterpret_cast<const Elf_Phdr *>(base() + PhOff);\n    return makeArrayRef(Begin, Begin + getHeader().e_phnum);\n  }\n\n  /// Get an iterator over notes in a program header.\n  ///\n  /// The program header must be of type \\c PT_NOTE.\n  ///\n  /// \\param Phdr the program header to iterate over.\n  /// \\param Err [out] an error to support fallible iteration, which should\n  ///  be checked after iteration ends.\n  Elf_Note_Iterator notes_begin(const Elf_Phdr &Phdr, Error &Err) const {\n    assert(Phdr.p_type == ELF::PT_NOTE && \"Phdr is not of type PT_NOTE\");\n    ErrorAsOutParameter ErrAsOutParam(&Err);\n    if (Phdr.p_offset + Phdr.p_filesz > getBufSize()) {\n      Err =\n          createError(\"invalid offset (0x\" + Twine::utohexstr(Phdr.p_offset) +\n                      \") or size (0x\" + Twine::utohexstr(Phdr.p_filesz) + \")\");\n      return Elf_Note_Iterator(Err);\n    }\n    return Elf_Note_Iterator(base() + Phdr.p_offset, Phdr.p_filesz, Err);\n  }\n\n  /// Get an iterator over notes in a section.\n  ///\n  /// The section must be of type \\c SHT_NOTE.\n  ///\n  /// \\param Shdr the section to iterate over.\n  /// \\param Err [out] an error to support fallible iteration, which should\n  ///  be checked after iteration ends.\n  Elf_Note_Iterator notes_begin(const Elf_Shdr &Shdr, Error &Err) const {\n    assert(Shdr.sh_type == ELF::SHT_NOTE && \"Shdr is not of type SHT_NOTE\");\n    ErrorAsOutParameter ErrAsOutParam(&Err);\n    if (Shdr.sh_offset + Shdr.sh_size > getBufSize()) {\n      Err =\n          createError(\"invalid offset (0x\" + Twine::utohexstr(Shdr.sh_offset) +\n                      \") or size (0x\" + Twine::utohexstr(Shdr.sh_size) + \")\");\n      return Elf_Note_Iterator(Err);\n    }\n    return Elf_Note_Iterator(base() + Shdr.sh_offset, Shdr.sh_size, Err);\n  }\n\n  /// Get the end iterator for notes.\n  Elf_Note_Iterator notes_end() const {\n    return Elf_Note_Iterator();\n  }\n\n  /// Get an iterator range over notes of a program header.\n  ///\n  /// The program header must be of type \\c PT_NOTE.\n  ///\n  /// \\param Phdr the program header to iterate over.\n  /// \\param Err [out] an error to support fallible iteration, which should\n  ///  be checked after iteration ends.\n  iterator_range<Elf_Note_Iterator> notes(const Elf_Phdr &Phdr,\n                                          Error &Err) const {\n    return make_range(notes_begin(Phdr, Err), notes_end());\n  }\n\n  /// Get an iterator range over notes of a section.\n  ///\n  /// The section must be of type \\c SHT_NOTE.\n  ///\n  /// \\param Shdr the section to iterate over.\n  /// \\param Err [out] an error to support fallible iteration, which should\n  ///  be checked after iteration ends.\n  iterator_range<Elf_Note_Iterator> notes(const Elf_Shdr &Shdr,\n                                          Error &Err) const {\n    return make_range(notes_begin(Shdr, Err), notes_end());\n  }\n\n  Expected<StringRef> getSectionStringTable(\n      Elf_Shdr_Range Sections,\n      WarningHandler WarnHandler = &defaultWarningHandler) const;\n  Expected<uint32_t> getSectionIndex(const Elf_Sym &Sym, Elf_Sym_Range Syms,\n                                     DataRegion<Elf_Word> ShndxTable) const;\n  Expected<const Elf_Shdr *> getSection(const Elf_Sym &Sym,\n                                        const Elf_Shdr *SymTab,\n                                        DataRegion<Elf_Word> ShndxTable) const;\n  Expected<const Elf_Shdr *> getSection(const Elf_Sym &Sym,\n                                        Elf_Sym_Range Symtab,\n                                        DataRegion<Elf_Word> ShndxTable) const;\n  Expected<const Elf_Shdr *> getSection(uint32_t Index) const;\n\n  Expected<const Elf_Sym *> getSymbol(const Elf_Shdr *Sec,\n                                      uint32_t Index) const;\n\n  Expected<StringRef>\n  getSectionName(const Elf_Shdr &Section,\n                 WarningHandler WarnHandler = &defaultWarningHandler) const;\n  Expected<StringRef> getSectionName(const Elf_Shdr &Section,\n                                     StringRef DotShstrtab) const;\n  template <typename T>\n  Expected<ArrayRef<T>> getSectionContentsAsArray(const Elf_Shdr &Sec) const;\n  Expected<ArrayRef<uint8_t>> getSectionContents(const Elf_Shdr &Sec) const;\n  Expected<ArrayRef<uint8_t>> getSegmentContents(const Elf_Phdr &Phdr) const;\n  Expected<std::vector<Elf_BBAddrMap>>\n  decodeBBAddrMap(const Elf_Shdr &Sec) const;\n};\n\nusing ELF32LEFile = ELFFile<ELF32LE>;\nusing ELF64LEFile = ELFFile<ELF64LE>;\nusing ELF32BEFile = ELFFile<ELF32BE>;\nusing ELF64BEFile = ELFFile<ELF64BE>;\n\ntemplate <class ELFT>\ninline Expected<const typename ELFT::Shdr *>\ngetSection(typename ELFT::ShdrRange Sections, uint32_t Index) {\n  if (Index >= Sections.size())\n    return createError(\"invalid section index: \" + Twine(Index));\n  return &Sections[Index];\n}\n\ntemplate <class ELFT>\ninline Expected<uint32_t>\ngetExtendedSymbolTableIndex(const typename ELFT::Sym &Sym, unsigned SymIndex,\n                            DataRegion<typename ELFT::Word> ShndxTable) {\n  assert(Sym.st_shndx == ELF::SHN_XINDEX);\n  if (!ShndxTable.First)\n    return createError(\n        \"found an extended symbol index (\" + Twine(SymIndex) +\n        \"), but unable to locate the extended symbol index table\");\n\n  Expected<typename ELFT::Word> TableOrErr = ShndxTable[SymIndex];\n  if (!TableOrErr)\n    return createError(\"unable to read an extended symbol table at index \" +\n                       Twine(SymIndex) + \": \" +\n                       toString(TableOrErr.takeError()));\n  return *TableOrErr;\n}\n\ntemplate <class ELFT>\nExpected<uint32_t>\nELFFile<ELFT>::getSectionIndex(const Elf_Sym &Sym, Elf_Sym_Range Syms,\n                               DataRegion<Elf_Word> ShndxTable) const {\n  uint32_t Index = Sym.st_shndx;\n  if (Index == ELF::SHN_XINDEX) {\n    Expected<uint32_t> ErrorOrIndex =\n        getExtendedSymbolTableIndex<ELFT>(Sym, &Sym - Syms.begin(), ShndxTable);\n    if (!ErrorOrIndex)\n      return ErrorOrIndex.takeError();\n    return *ErrorOrIndex;\n  }\n  if (Index == ELF::SHN_UNDEF || Index >= ELF::SHN_LORESERVE)\n    return 0;\n  return Index;\n}\n\ntemplate <class ELFT>\nExpected<const typename ELFT::Shdr *>\nELFFile<ELFT>::getSection(const Elf_Sym &Sym, const Elf_Shdr *SymTab,\n                          DataRegion<Elf_Word> ShndxTable) const {\n  auto SymsOrErr = symbols(SymTab);\n  if (!SymsOrErr)\n    return SymsOrErr.takeError();\n  return getSection(Sym, *SymsOrErr, ShndxTable);\n}\n\ntemplate <class ELFT>\nExpected<const typename ELFT::Shdr *>\nELFFile<ELFT>::getSection(const Elf_Sym &Sym, Elf_Sym_Range Symbols,\n                          DataRegion<Elf_Word> ShndxTable) const {\n  auto IndexOrErr = getSectionIndex(Sym, Symbols, ShndxTable);\n  if (!IndexOrErr)\n    return IndexOrErr.takeError();\n  uint32_t Index = *IndexOrErr;\n  if (Index == 0)\n    return nullptr;\n  return getSection(Index);\n}\n\ntemplate <class ELFT>\nExpected<const typename ELFT::Sym *>\nELFFile<ELFT>::getSymbol(const Elf_Shdr *Sec, uint32_t Index) const {\n  auto SymsOrErr = symbols(Sec);\n  if (!SymsOrErr)\n    return SymsOrErr.takeError();\n\n  Elf_Sym_Range Symbols = *SymsOrErr;\n  if (Index >= Symbols.size())\n    return createError(\"unable to get symbol from section \" +\n                       getSecIndexForError(*this, *Sec) +\n                       \": invalid symbol index (\" + Twine(Index) + \")\");\n  return &Symbols[Index];\n}\n\ntemplate <class ELFT>\ntemplate <typename T>\nExpected<ArrayRef<T>>\nELFFile<ELFT>::getSectionContentsAsArray(const Elf_Shdr &Sec) const {\n  if (Sec.sh_entsize != sizeof(T) && sizeof(T) != 1)\n    return createError(\"section \" + getSecIndexForError(*this, Sec) +\n                       \" has invalid sh_entsize: expected \" + Twine(sizeof(T)) +\n                       \", but got \" + Twine(Sec.sh_entsize));\n\n  uintX_t Offset = Sec.sh_offset;\n  uintX_t Size = Sec.sh_size;\n\n  if (Size % sizeof(T))\n    return createError(\"section \" + getSecIndexForError(*this, Sec) +\n                       \" has an invalid sh_size (\" + Twine(Size) +\n                       \") which is not a multiple of its sh_entsize (\" +\n                       Twine(Sec.sh_entsize) + \")\");\n  if (std::numeric_limits<uintX_t>::max() - Offset < Size)\n    return createError(\"section \" + getSecIndexForError(*this, Sec) +\n                       \" has a sh_offset (0x\" + Twine::utohexstr(Offset) +\n                       \") + sh_size (0x\" + Twine::utohexstr(Size) +\n                       \") that cannot be represented\");\n  if (Offset + Size > Buf.size())\n    return createError(\"section \" + getSecIndexForError(*this, Sec) +\n                       \" has a sh_offset (0x\" + Twine::utohexstr(Offset) +\n                       \") + sh_size (0x\" + Twine::utohexstr(Size) +\n                       \") that is greater than the file size (0x\" +\n                       Twine::utohexstr(Buf.size()) + \")\");\n\n  if (Offset % alignof(T))\n    // TODO: this error is untested.\n    return createError(\"unaligned data\");\n\n  const T *Start = reinterpret_cast<const T *>(base() + Offset);\n  return makeArrayRef(Start, Size / sizeof(T));\n}\n\ntemplate <class ELFT>\nExpected<ArrayRef<uint8_t>>\nELFFile<ELFT>::getSegmentContents(const Elf_Phdr &Phdr) const {\n  uintX_t Offset = Phdr.p_offset;\n  uintX_t Size = Phdr.p_filesz;\n\n  if (std::numeric_limits<uintX_t>::max() - Offset < Size)\n    return createError(\"program header \" + getPhdrIndexForError(*this, Phdr) +\n                       \" has a p_offset (0x\" + Twine::utohexstr(Offset) +\n                       \") + p_filesz (0x\" + Twine::utohexstr(Size) +\n                       \") that cannot be represented\");\n  if (Offset + Size > Buf.size())\n    return createError(\"program header  \" + getPhdrIndexForError(*this, Phdr) +\n                       \" has a p_offset (0x\" + Twine::utohexstr(Offset) +\n                       \") + p_filesz (0x\" + Twine::utohexstr(Size) +\n                       \") that is greater than the file size (0x\" +\n                       Twine::utohexstr(Buf.size()) + \")\");\n  return makeArrayRef(base() + Offset, Size);\n}\n\ntemplate <class ELFT>\nExpected<ArrayRef<uint8_t>>\nELFFile<ELFT>::getSectionContents(const Elf_Shdr &Sec) const {\n  return getSectionContentsAsArray<uint8_t>(Sec);\n}\n\ntemplate <class ELFT>\nStringRef ELFFile<ELFT>::getRelocationTypeName(uint32_t Type) const {\n  return getELFRelocationTypeName(getHeader().e_machine, Type);\n}\n\ntemplate <class ELFT>\nvoid ELFFile<ELFT>::getRelocationTypeName(uint32_t Type,\n                                          SmallVectorImpl<char> &Result) const {\n  if (!isMipsELF64()) {\n    StringRef Name = getRelocationTypeName(Type);\n    Result.append(Name.begin(), Name.end());\n  } else {\n    // The Mips N64 ABI allows up to three operations to be specified per\n    // relocation record. Unfortunately there's no easy way to test for the\n    // presence of N64 ELFs as they have no special flag that identifies them\n    // as being N64. We can safely assume at the moment that all Mips\n    // ELFCLASS64 ELFs are N64. New Mips64 ABIs should provide enough\n    // information to disambiguate between old vs new ABIs.\n    uint8_t Type1 = (Type >> 0) & 0xFF;\n    uint8_t Type2 = (Type >> 8) & 0xFF;\n    uint8_t Type3 = (Type >> 16) & 0xFF;\n\n    // Concat all three relocation type names.\n    StringRef Name = getRelocationTypeName(Type1);\n    Result.append(Name.begin(), Name.end());\n\n    Name = getRelocationTypeName(Type2);\n    Result.append(1, '/');\n    Result.append(Name.begin(), Name.end());\n\n    Name = getRelocationTypeName(Type3);\n    Result.append(1, '/');\n    Result.append(Name.begin(), Name.end());\n  }\n}\n\ntemplate <class ELFT>\nuint32_t ELFFile<ELFT>::getRelativeRelocationType() const {\n  return getELFRelativeRelocationType(getHeader().e_machine);\n}\n\ntemplate <class ELFT>\nExpected<SmallVector<Optional<VersionEntry>, 0>>\nELFFile<ELFT>::loadVersionMap(const Elf_Shdr *VerNeedSec,\n                              const Elf_Shdr *VerDefSec) const {\n  SmallVector<Optional<VersionEntry>, 0> VersionMap;\n\n  // The first two version indexes are reserved.\n  // Index 0 is VER_NDX_LOCAL, index 1 is VER_NDX_GLOBAL.\n  VersionMap.push_back(VersionEntry());\n  VersionMap.push_back(VersionEntry());\n\n  auto InsertEntry = [&](unsigned N, StringRef Version, bool IsVerdef) {\n    if (N >= VersionMap.size())\n      VersionMap.resize(N + 1);\n    VersionMap[N] = {std::string(Version), IsVerdef};\n  };\n\n  if (VerDefSec) {\n    Expected<std::vector<VerDef>> Defs = getVersionDefinitions(*VerDefSec);\n    if (!Defs)\n      return Defs.takeError();\n    for (const VerDef &Def : *Defs)\n      InsertEntry(Def.Ndx & ELF::VERSYM_VERSION, Def.Name, true);\n  }\n\n  if (VerNeedSec) {\n    Expected<std::vector<VerNeed>> Deps = getVersionDependencies(*VerNeedSec);\n    if (!Deps)\n      return Deps.takeError();\n    for (const VerNeed &Dep : *Deps)\n      for (const VernAux &Aux : Dep.AuxV)\n        InsertEntry(Aux.Other & ELF::VERSYM_VERSION, Aux.Name, false);\n  }\n\n  return VersionMap;\n}\n\ntemplate <class ELFT>\nExpected<const typename ELFT::Sym *>\nELFFile<ELFT>::getRelocationSymbol(const Elf_Rel &Rel,\n                                   const Elf_Shdr *SymTab) const {\n  uint32_t Index = Rel.getSymbol(isMips64EL());\n  if (Index == 0)\n    return nullptr;\n  return getEntry<Elf_Sym>(*SymTab, Index);\n}\n\ntemplate <class ELFT>\nExpected<StringRef>\nELFFile<ELFT>::getSectionStringTable(Elf_Shdr_Range Sections,\n                                     WarningHandler WarnHandler) const {\n  uint32_t Index = getHeader().e_shstrndx;\n  if (Index == ELF::SHN_XINDEX) {\n    // If the section name string table section index is greater than\n    // or equal to SHN_LORESERVE, then the actual index of the section name\n    // string table section is contained in the sh_link field of the section\n    // header at index 0.\n    if (Sections.empty())\n      return createError(\n          \"e_shstrndx == SHN_XINDEX, but the section header table is empty\");\n\n    Index = Sections[0].sh_link;\n  }\n\n  if (!Index) // no section string table.\n    return \"\";\n  if (Index >= Sections.size())\n    return createError(\"section header string table index \" + Twine(Index) +\n                       \" does not exist\");\n  return getStringTable(Sections[Index], WarnHandler);\n}\n\n/// This function finds the number of dynamic symbols using a GNU hash table.\n///\n/// @param Table The GNU hash table for .dynsym.\ntemplate <class ELFT>\nstatic Expected<uint64_t>\ngetDynSymtabSizeFromGnuHash(const typename ELFT::GnuHash &Table,\n                            const void *BufEnd) {\n  using Elf_Word = typename ELFT::Word;\n  if (Table.nbuckets == 0)\n    return Table.symndx + 1;\n  uint64_t LastSymIdx = 0;\n  // Find the index of the first symbol in the last chain.\n  for (Elf_Word Val : Table.buckets())\n    LastSymIdx = std::max(LastSymIdx, (uint64_t)Val);\n  const Elf_Word *It =\n      reinterpret_cast<const Elf_Word *>(Table.values(LastSymIdx).end());\n  // Locate the end of the chain to find the last symbol index.\n  while (It < BufEnd && (*It & 1) == 0) {\n    ++LastSymIdx;\n    ++It;\n  }\n  if (It >= BufEnd) {\n    return createStringError(\n        object_error::parse_failed,\n        \"no terminator found for GNU hash section before buffer end\");\n  }\n  return LastSymIdx + 1;\n}\n\n/// This function determines the number of dynamic symbols. It reads section\n/// headers first. If section headers are not available, the number of\n/// symbols will be inferred by parsing dynamic hash tables.\ntemplate <class ELFT>\nExpected<uint64_t> ELFFile<ELFT>::getDynSymtabSize() const {\n  // Read .dynsym section header first if available.\n  Expected<Elf_Shdr_Range> SectionsOrError = sections();\n  if (!SectionsOrError)\n    return SectionsOrError.takeError();\n  for (const Elf_Shdr &Sec : *SectionsOrError) {\n    if (Sec.sh_type == ELF::SHT_DYNSYM) {\n      if (Sec.sh_size % Sec.sh_entsize != 0) {\n        return createStringError(object_error::parse_failed,\n                                 \"SHT_DYNSYM section has sh_size (\" +\n                                     Twine(Sec.sh_size) + \") % sh_entsize (\" +\n                                     Twine(Sec.sh_entsize) + \") that is not 0\");\n      }\n      return Sec.sh_size / Sec.sh_entsize;\n    }\n  }\n\n  if (!SectionsOrError->empty()) {\n    // Section headers are available but .dynsym header is not found.\n    // Return 0 as .dynsym does not exist.\n    return 0;\n  }\n\n  // Section headers do not exist. Falling back to infer\n  // upper bound of .dynsym from .gnu.hash and .hash.\n  Expected<Elf_Dyn_Range> DynTable = dynamicEntries();\n  if (!DynTable)\n    return DynTable.takeError();\n  llvm::Optional<uint64_t> ElfHash;\n  llvm::Optional<uint64_t> ElfGnuHash;\n  for (const Elf_Dyn &Entry : *DynTable) {\n    switch (Entry.d_tag) {\n    case ELF::DT_HASH:\n      ElfHash = Entry.d_un.d_ptr;\n      break;\n    case ELF::DT_GNU_HASH:\n      ElfGnuHash = Entry.d_un.d_ptr;\n      break;\n    }\n  }\n  if (ElfGnuHash) {\n    Expected<const uint8_t *> TablePtr = toMappedAddr(*ElfGnuHash);\n    if (!TablePtr)\n      return TablePtr.takeError();\n    const Elf_GnuHash *Table =\n        reinterpret_cast<const Elf_GnuHash *>(TablePtr.get());\n    return getDynSymtabSizeFromGnuHash<ELFT>(*Table, this->Buf.bytes_end());\n  }\n\n  // Search SYSV hash table to try to find the upper bound of dynsym.\n  if (ElfHash) {\n    Expected<const uint8_t *> TablePtr = toMappedAddr(*ElfHash);\n    if (!TablePtr)\n      return TablePtr.takeError();\n    const Elf_Hash *Table = reinterpret_cast<const Elf_Hash *>(TablePtr.get());\n    return Table->nchain;\n  }\n  return 0;\n}\n\ntemplate <class ELFT> ELFFile<ELFT>::ELFFile(StringRef Object) : Buf(Object) {}\n\ntemplate <class ELFT>\nExpected<ELFFile<ELFT>> ELFFile<ELFT>::create(StringRef Object) {\n  if (sizeof(Elf_Ehdr) > Object.size())\n    return createError(\"invalid buffer: the size (\" + Twine(Object.size()) +\n                       \") is smaller than an ELF header (\" +\n                       Twine(sizeof(Elf_Ehdr)) + \")\");\n  return ELFFile(Object);\n}\n\ntemplate <class ELFT>\nExpected<typename ELFT::ShdrRange> ELFFile<ELFT>::sections() const {\n  const uintX_t SectionTableOffset = getHeader().e_shoff;\n  if (SectionTableOffset == 0)\n    return ArrayRef<Elf_Shdr>();\n\n  if (getHeader().e_shentsize != sizeof(Elf_Shdr))\n    return createError(\"invalid e_shentsize in ELF header: \" +\n                       Twine(getHeader().e_shentsize));\n\n  const uint64_t FileSize = Buf.size();\n  if (SectionTableOffset + sizeof(Elf_Shdr) > FileSize ||\n      SectionTableOffset + (uintX_t)sizeof(Elf_Shdr) < SectionTableOffset)\n    return createError(\n        \"section header table goes past the end of the file: e_shoff = 0x\" +\n        Twine::utohexstr(SectionTableOffset));\n\n  // Invalid address alignment of section headers\n  if (SectionTableOffset & (alignof(Elf_Shdr) - 1))\n    // TODO: this error is untested.\n    return createError(\"invalid alignment of section headers\");\n\n  const Elf_Shdr *First =\n      reinterpret_cast<const Elf_Shdr *>(base() + SectionTableOffset);\n\n  uintX_t NumSections = getHeader().e_shnum;\n  if (NumSections == 0)\n    NumSections = First->sh_size;\n\n  if (NumSections > UINT64_MAX / sizeof(Elf_Shdr))\n    return createError(\"invalid number of sections specified in the NULL \"\n                       \"section's sh_size field (\" +\n                       Twine(NumSections) + \")\");\n\n  const uint64_t SectionTableSize = NumSections * sizeof(Elf_Shdr);\n  if (SectionTableOffset + SectionTableSize < SectionTableOffset)\n    return createError(\n        \"invalid section header table offset (e_shoff = 0x\" +\n        Twine::utohexstr(SectionTableOffset) +\n        \") or invalid number of sections specified in the first section \"\n        \"header's sh_size field (0x\" +\n        Twine::utohexstr(NumSections) + \")\");\n\n  // Section table goes past end of file!\n  if (SectionTableOffset + SectionTableSize > FileSize)\n    return createError(\"section table goes past the end of file\");\n  return makeArrayRef(First, NumSections);\n}\n\ntemplate <class ELFT>\ntemplate <typename T>\nExpected<const T *> ELFFile<ELFT>::getEntry(uint32_t Section,\n                                            uint32_t Entry) const {\n  auto SecOrErr = getSection(Section);\n  if (!SecOrErr)\n    return SecOrErr.takeError();\n  return getEntry<T>(**SecOrErr, Entry);\n}\n\ntemplate <class ELFT>\ntemplate <typename T>\nExpected<const T *> ELFFile<ELFT>::getEntry(const Elf_Shdr &Section,\n                                            uint32_t Entry) const {\n  Expected<ArrayRef<T>> EntriesOrErr = getSectionContentsAsArray<T>(Section);\n  if (!EntriesOrErr)\n    return EntriesOrErr.takeError();\n\n  ArrayRef<T> Arr = *EntriesOrErr;\n  if (Entry >= Arr.size())\n    return createError(\n        \"can't read an entry at 0x\" +\n        Twine::utohexstr(Entry * static_cast<uint64_t>(sizeof(T))) +\n        \": it goes past the end of the section (0x\" +\n        Twine::utohexstr(Section.sh_size) + \")\");\n  return &Arr[Entry];\n}\n\ntemplate <typename ELFT>\nExpected<StringRef> ELFFile<ELFT>::getSymbolVersionByIndex(\n    uint32_t SymbolVersionIndex, bool &IsDefault,\n    SmallVector<Optional<VersionEntry>, 0> &VersionMap,\n    Optional<bool> IsSymHidden) const {\n  size_t VersionIndex = SymbolVersionIndex & llvm::ELF::VERSYM_VERSION;\n\n  // Special markers for unversioned symbols.\n  if (VersionIndex == llvm::ELF::VER_NDX_LOCAL ||\n      VersionIndex == llvm::ELF::VER_NDX_GLOBAL) {\n    IsDefault = false;\n    return \"\";\n  }\n\n  // Lookup this symbol in the version table.\n  if (VersionIndex >= VersionMap.size() || !VersionMap[VersionIndex])\n    return createError(\"SHT_GNU_versym section refers to a version index \" +\n                       Twine(VersionIndex) + \" which is missing\");\n\n  const VersionEntry &Entry = *VersionMap[VersionIndex];\n  // A default version (@@) is only available for defined symbols.\n  if (!Entry.IsVerDef || IsSymHidden.getValueOr(false))\n    IsDefault = false;\n  else\n    IsDefault = !(SymbolVersionIndex & llvm::ELF::VERSYM_HIDDEN);\n  return Entry.Name.c_str();\n}\n\ntemplate <class ELFT>\nExpected<std::vector<VerDef>>\nELFFile<ELFT>::getVersionDefinitions(const Elf_Shdr &Sec) const {\n  Expected<StringRef> StrTabOrErr = getLinkAsStrtab(Sec);\n  if (!StrTabOrErr)\n    return StrTabOrErr.takeError();\n\n  Expected<ArrayRef<uint8_t>> ContentsOrErr = getSectionContents(Sec);\n  if (!ContentsOrErr)\n    return createError(\"cannot read content of \" + describe(*this, Sec) + \": \" +\n                       toString(ContentsOrErr.takeError()));\n\n  const uint8_t *Start = ContentsOrErr->data();\n  const uint8_t *End = Start + ContentsOrErr->size();\n\n  auto ExtractNextAux = [&](const uint8_t *&VerdauxBuf,\n                            unsigned VerDefNdx) -> Expected<VerdAux> {\n    if (VerdauxBuf + sizeof(Elf_Verdaux) > End)\n      return createError(\"invalid \" + describe(*this, Sec) +\n                         \": version definition \" + Twine(VerDefNdx) +\n                         \" refers to an auxiliary entry that goes past the end \"\n                         \"of the section\");\n\n    auto *Verdaux = reinterpret_cast<const Elf_Verdaux *>(VerdauxBuf);\n    VerdauxBuf += Verdaux->vda_next;\n\n    VerdAux Aux;\n    Aux.Offset = VerdauxBuf - Start;\n    if (Verdaux->vda_name <= StrTabOrErr->size())\n      Aux.Name = std::string(StrTabOrErr->drop_front(Verdaux->vda_name));\n    else\n      Aux.Name = (\"<invalid vda_name: \" + Twine(Verdaux->vda_name) + \">\").str();\n    return Aux;\n  };\n\n  std::vector<VerDef> Ret;\n  const uint8_t *VerdefBuf = Start;\n  for (unsigned I = 1; I <= /*VerDefsNum=*/Sec.sh_info; ++I) {\n    if (VerdefBuf + sizeof(Elf_Verdef) > End)\n      return createError(\"invalid \" + describe(*this, Sec) +\n                         \": version definition \" + Twine(I) +\n                         \" goes past the end of the section\");\n\n    if (reinterpret_cast<uintptr_t>(VerdefBuf) % sizeof(uint32_t) != 0)\n      return createError(\n          \"invalid \" + describe(*this, Sec) +\n          \": found a misaligned version definition entry at offset 0x\" +\n          Twine::utohexstr(VerdefBuf - Start));\n\n    unsigned Version = *reinterpret_cast<const Elf_Half *>(VerdefBuf);\n    if (Version != 1)\n      return createError(\"unable to dump \" + describe(*this, Sec) +\n                         \": version \" + Twine(Version) +\n                         \" is not yet supported\");\n\n    const Elf_Verdef *D = reinterpret_cast<const Elf_Verdef *>(VerdefBuf);\n    VerDef &VD = *Ret.emplace(Ret.end());\n    VD.Offset = VerdefBuf - Start;\n    VD.Version = D->vd_version;\n    VD.Flags = D->vd_flags;\n    VD.Ndx = D->vd_ndx;\n    VD.Cnt = D->vd_cnt;\n    VD.Hash = D->vd_hash;\n\n    const uint8_t *VerdauxBuf = VerdefBuf + D->vd_aux;\n    for (unsigned J = 0; J < D->vd_cnt; ++J) {\n      if (reinterpret_cast<uintptr_t>(VerdauxBuf) % sizeof(uint32_t) != 0)\n        return createError(\"invalid \" + describe(*this, Sec) +\n                           \": found a misaligned auxiliary entry at offset 0x\" +\n                           Twine::utohexstr(VerdauxBuf - Start));\n\n      Expected<VerdAux> AuxOrErr = ExtractNextAux(VerdauxBuf, I);\n      if (!AuxOrErr)\n        return AuxOrErr.takeError();\n\n      if (J == 0)\n        VD.Name = AuxOrErr->Name;\n      else\n        VD.AuxV.push_back(*AuxOrErr);\n    }\n\n    VerdefBuf += D->vd_next;\n  }\n\n  return Ret;\n}\n\ntemplate <class ELFT>\nExpected<std::vector<VerNeed>>\nELFFile<ELFT>::getVersionDependencies(const Elf_Shdr &Sec,\n                                      WarningHandler WarnHandler) const {\n  StringRef StrTab;\n  Expected<StringRef> StrTabOrErr = getLinkAsStrtab(Sec);\n  if (!StrTabOrErr) {\n    if (Error E = WarnHandler(toString(StrTabOrErr.takeError())))\n      return std::move(E);\n  } else {\n    StrTab = *StrTabOrErr;\n  }\n\n  Expected<ArrayRef<uint8_t>> ContentsOrErr = getSectionContents(Sec);\n  if (!ContentsOrErr)\n    return createError(\"cannot read content of \" + describe(*this, Sec) + \": \" +\n                       toString(ContentsOrErr.takeError()));\n\n  const uint8_t *Start = ContentsOrErr->data();\n  const uint8_t *End = Start + ContentsOrErr->size();\n  const uint8_t *VerneedBuf = Start;\n\n  std::vector<VerNeed> Ret;\n  for (unsigned I = 1; I <= /*VerneedNum=*/Sec.sh_info; ++I) {\n    if (VerneedBuf + sizeof(Elf_Verdef) > End)\n      return createError(\"invalid \" + describe(*this, Sec) +\n                         \": version dependency \" + Twine(I) +\n                         \" goes past the end of the section\");\n\n    if (reinterpret_cast<uintptr_t>(VerneedBuf) % sizeof(uint32_t) != 0)\n      return createError(\n          \"invalid \" + describe(*this, Sec) +\n          \": found a misaligned version dependency entry at offset 0x\" +\n          Twine::utohexstr(VerneedBuf - Start));\n\n    unsigned Version = *reinterpret_cast<const Elf_Half *>(VerneedBuf);\n    if (Version != 1)\n      return createError(\"unable to dump \" + describe(*this, Sec) +\n                         \": version \" + Twine(Version) +\n                         \" is not yet supported\");\n\n    const Elf_Verneed *Verneed =\n        reinterpret_cast<const Elf_Verneed *>(VerneedBuf);\n\n    VerNeed &VN = *Ret.emplace(Ret.end());\n    VN.Version = Verneed->vn_version;\n    VN.Cnt = Verneed->vn_cnt;\n    VN.Offset = VerneedBuf - Start;\n\n    if (Verneed->vn_file < StrTab.size())\n      VN.File = std::string(StrTab.drop_front(Verneed->vn_file));\n    else\n      VN.File = (\"<corrupt vn_file: \" + Twine(Verneed->vn_file) + \">\").str();\n\n    const uint8_t *VernauxBuf = VerneedBuf + Verneed->vn_aux;\n    for (unsigned J = 0; J < Verneed->vn_cnt; ++J) {\n      if (reinterpret_cast<uintptr_t>(VernauxBuf) % sizeof(uint32_t) != 0)\n        return createError(\"invalid \" + describe(*this, Sec) +\n                           \": found a misaligned auxiliary entry at offset 0x\" +\n                           Twine::utohexstr(VernauxBuf - Start));\n\n      if (VernauxBuf + sizeof(Elf_Vernaux) > End)\n        return createError(\n            \"invalid \" + describe(*this, Sec) + \": version dependency \" +\n            Twine(I) +\n            \" refers to an auxiliary entry that goes past the end \"\n            \"of the section\");\n\n      const Elf_Vernaux *Vernaux =\n          reinterpret_cast<const Elf_Vernaux *>(VernauxBuf);\n\n      VernAux &Aux = *VN.AuxV.emplace(VN.AuxV.end());\n      Aux.Hash = Vernaux->vna_hash;\n      Aux.Flags = Vernaux->vna_flags;\n      Aux.Other = Vernaux->vna_other;\n      Aux.Offset = VernauxBuf - Start;\n      if (StrTab.size() <= Vernaux->vna_name)\n        Aux.Name = \"<corrupt>\";\n      else\n        Aux.Name = std::string(StrTab.drop_front(Vernaux->vna_name));\n\n      VernauxBuf += Vernaux->vna_next;\n    }\n    VerneedBuf += Verneed->vn_next;\n  }\n  return Ret;\n}\n\ntemplate <class ELFT>\nExpected<const typename ELFT::Shdr *>\nELFFile<ELFT>::getSection(uint32_t Index) const {\n  auto TableOrErr = sections();\n  if (!TableOrErr)\n    return TableOrErr.takeError();\n  return object::getSection<ELFT>(*TableOrErr, Index);\n}\n\ntemplate <class ELFT>\nExpected<StringRef>\nELFFile<ELFT>::getStringTable(const Elf_Shdr &Section,\n                              WarningHandler WarnHandler) const {\n  if (Section.sh_type != ELF::SHT_STRTAB)\n    if (Error E = WarnHandler(\"invalid sh_type for string table section \" +\n                              getSecIndexForError(*this, Section) +\n                              \": expected SHT_STRTAB, but got \" +\n                              object::getELFSectionTypeName(\n                                  getHeader().e_machine, Section.sh_type)))\n      return std::move(E);\n\n  auto V = getSectionContentsAsArray<char>(Section);\n  if (!V)\n    return V.takeError();\n  ArrayRef<char> Data = *V;\n  if (Data.empty())\n    return createError(\"SHT_STRTAB string table section \" +\n                       getSecIndexForError(*this, Section) + \" is empty\");\n  if (Data.back() != '\\0')\n    return createError(\"SHT_STRTAB string table section \" +\n                       getSecIndexForError(*this, Section) +\n                       \" is non-null terminated\");\n  return StringRef(Data.begin(), Data.size());\n}\n\ntemplate <class ELFT>\nExpected<ArrayRef<typename ELFT::Word>>\nELFFile<ELFT>::getSHNDXTable(const Elf_Shdr &Section) const {\n  auto SectionsOrErr = sections();\n  if (!SectionsOrErr)\n    return SectionsOrErr.takeError();\n  return getSHNDXTable(Section, *SectionsOrErr);\n}\n\ntemplate <class ELFT>\nExpected<ArrayRef<typename ELFT::Word>>\nELFFile<ELFT>::getSHNDXTable(const Elf_Shdr &Section,\n                             Elf_Shdr_Range Sections) const {\n  assert(Section.sh_type == ELF::SHT_SYMTAB_SHNDX);\n  auto VOrErr = getSectionContentsAsArray<Elf_Word>(Section);\n  if (!VOrErr)\n    return VOrErr.takeError();\n  ArrayRef<Elf_Word> V = *VOrErr;\n  auto SymTableOrErr = object::getSection<ELFT>(Sections, Section.sh_link);\n  if (!SymTableOrErr)\n    return SymTableOrErr.takeError();\n  const Elf_Shdr &SymTable = **SymTableOrErr;\n  if (SymTable.sh_type != ELF::SHT_SYMTAB &&\n      SymTable.sh_type != ELF::SHT_DYNSYM)\n    return createError(\n        \"SHT_SYMTAB_SHNDX section is linked with \" +\n        object::getELFSectionTypeName(getHeader().e_machine, SymTable.sh_type) +\n        \" section (expected SHT_SYMTAB/SHT_DYNSYM)\");\n\n  uint64_t Syms = SymTable.sh_size / sizeof(Elf_Sym);\n  if (V.size() != Syms)\n    return createError(\"SHT_SYMTAB_SHNDX has \" + Twine(V.size()) +\n                       \" entries, but the symbol table associated has \" +\n                       Twine(Syms));\n\n  return V;\n}\n\ntemplate <class ELFT>\nExpected<StringRef>\nELFFile<ELFT>::getStringTableForSymtab(const Elf_Shdr &Sec) const {\n  auto SectionsOrErr = sections();\n  if (!SectionsOrErr)\n    return SectionsOrErr.takeError();\n  return getStringTableForSymtab(Sec, *SectionsOrErr);\n}\n\ntemplate <class ELFT>\nExpected<StringRef>\nELFFile<ELFT>::getStringTableForSymtab(const Elf_Shdr &Sec,\n                                       Elf_Shdr_Range Sections) const {\n\n  if (Sec.sh_type != ELF::SHT_SYMTAB && Sec.sh_type != ELF::SHT_DYNSYM)\n    return createError(\n        \"invalid sh_type for symbol table, expected SHT_SYMTAB or SHT_DYNSYM\");\n  Expected<const Elf_Shdr *> SectionOrErr =\n      object::getSection<ELFT>(Sections, Sec.sh_link);\n  if (!SectionOrErr)\n    return SectionOrErr.takeError();\n  return getStringTable(**SectionOrErr);\n}\n\ntemplate <class ELFT>\nExpected<StringRef>\nELFFile<ELFT>::getLinkAsStrtab(const typename ELFT::Shdr &Sec) const {\n  Expected<const typename ELFT::Shdr *> StrTabSecOrErr =\n      getSection(Sec.sh_link);\n  if (!StrTabSecOrErr)\n    return createError(\"invalid section linked to \" + describe(*this, Sec) +\n                       \": \" + toString(StrTabSecOrErr.takeError()));\n\n  Expected<StringRef> StrTabOrErr = getStringTable(**StrTabSecOrErr);\n  if (!StrTabOrErr)\n    return createError(\"invalid string table linked to \" +\n                       describe(*this, Sec) + \": \" +\n                       toString(StrTabOrErr.takeError()));\n  return *StrTabOrErr;\n}\n\ntemplate <class ELFT>\nExpected<StringRef>\nELFFile<ELFT>::getSectionName(const Elf_Shdr &Section,\n                              WarningHandler WarnHandler) const {\n  auto SectionsOrErr = sections();\n  if (!SectionsOrErr)\n    return SectionsOrErr.takeError();\n  auto Table = getSectionStringTable(*SectionsOrErr, WarnHandler);\n  if (!Table)\n    return Table.takeError();\n  return getSectionName(Section, *Table);\n}\n\ntemplate <class ELFT>\nExpected<StringRef> ELFFile<ELFT>::getSectionName(const Elf_Shdr &Section,\n                                                  StringRef DotShstrtab) const {\n  uint32_t Offset = Section.sh_name;\n  if (Offset == 0)\n    return StringRef();\n  if (Offset >= DotShstrtab.size())\n    return createError(\"a section \" + getSecIndexForError(*this, Section) +\n                       \" has an invalid sh_name (0x\" +\n                       Twine::utohexstr(Offset) +\n                       \") offset which goes past the end of the \"\n                       \"section name string table\");\n  return StringRef(DotShstrtab.data() + Offset);\n}\n\n/// This function returns the hash value for a symbol in the .dynsym section\n/// Name of the API remains consistent as specified in the libelf\n/// REF : http://www.sco.com/developers/gabi/latest/ch5.dynamic.html#hash\ninline unsigned hashSysV(StringRef SymbolName) {\n  unsigned h = 0, g;\n  for (char C : SymbolName) {\n    h = (h << 4) + C;\n    g = h & 0xf0000000L;\n    if (g != 0)\n      h ^= g >> 24;\n    h &= ~g;\n  }\n  return h;\n}\n\n} // end namespace object\n} // end namespace llvm\n\n#endif // LLVM_OBJECT_ELF_H\n"}, "37": {"id": 37, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Object/ELFObjectFile.h", "content": "//===- ELFObjectFile.h - ELF object file implementation ---------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// This file declares the ELFObjectFile template class.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_OBJECT_ELFOBJECTFILE_H\n#define LLVM_OBJECT_ELFOBJECTFILE_H\n\n#include \"llvm/ADT/ArrayRef.h\"\n#include \"llvm/ADT/STLExtras.h\"\n#include \"llvm/ADT/SmallVector.h\"\n#include \"llvm/ADT/StringRef.h\"\n#include \"llvm/ADT/Triple.h\"\n#include \"llvm/ADT/iterator_range.h\"\n#include \"llvm/BinaryFormat/ELF.h\"\n#include \"llvm/MC/SubtargetFeature.h\"\n#include \"llvm/Object/Binary.h\"\n#include \"llvm/Object/ELF.h\"\n#include \"llvm/Object/ELFTypes.h\"\n#include \"llvm/Object/Error.h\"\n#include \"llvm/Object/ObjectFile.h\"\n#include \"llvm/Object/SymbolicFile.h\"\n#include \"llvm/Support/ARMAttributeParser.h\"\n#include \"llvm/Support/Casting.h\"\n#include \"llvm/Support/ELFAttributes.h\"\n#include \"llvm/Support/Endian.h\"\n#include \"llvm/Support/Error.h\"\n#include \"llvm/Support/ErrorHandling.h\"\n#include \"llvm/Support/MemoryBuffer.h\"\n#include <cassert>\n#include <cstdint>\n#include <system_error>\n\nnamespace llvm {\nnamespace object {\n\nconstexpr int NumElfSymbolTypes = 16;\nextern const llvm::EnumEntry<unsigned> ElfSymbolTypes[NumElfSymbolTypes];\n\nclass elf_symbol_iterator;\n\nclass ELFObjectFileBase : public ObjectFile {\n  friend class ELFRelocationRef;\n  friend class ELFSectionRef;\n  friend class ELFSymbolRef;\n\n  SubtargetFeatures getMIPSFeatures() const;\n  SubtargetFeatures getARMFeatures() const;\n  SubtargetFeatures getRISCVFeatures() const;\n\n  StringRef getAMDGPUCPUName() const;\n\nprotected:\n  ELFObjectFileBase(unsigned int Type, MemoryBufferRef Source);\n\n  virtual uint64_t getSymbolSize(DataRefImpl Symb) const = 0;\n  virtual uint8_t getSymbolBinding(DataRefImpl Symb) const = 0;\n  virtual uint8_t getSymbolOther(DataRefImpl Symb) const = 0;\n  virtual uint8_t getSymbolELFType(DataRefImpl Symb) const = 0;\n\n  virtual uint32_t getSectionType(DataRefImpl Sec) const = 0;\n  virtual uint64_t getSectionFlags(DataRefImpl Sec) const = 0;\n  virtual uint64_t getSectionOffset(DataRefImpl Sec) const = 0;\n\n  virtual Expected<int64_t> getRelocationAddend(DataRefImpl Rel) const = 0;\n  virtual Error getBuildAttributes(ELFAttributeParser &Attributes) const = 0;\n\npublic:\n  using elf_symbol_iterator_range = iterator_range<elf_symbol_iterator>;\n\n  virtual elf_symbol_iterator_range getDynamicSymbolIterators() const = 0;\n\n  /// Returns platform-specific object flags, if any.\n  virtual unsigned getPlatformFlags() const = 0;\n\n  elf_symbol_iterator_range symbols() const;\n\n  static bool classof(const Binary *v) { return v->isELF(); }\n\n  SubtargetFeatures getFeatures() const override;\n\n  Optional<StringRef> tryGetCPUName() const override;\n\n  void setARMSubArch(Triple &TheTriple) const override;\n\n  virtual uint16_t getEType() const = 0;\n\n  virtual uint16_t getEMachine() const = 0;\n\n  std::vector<std::pair<Optional<DataRefImpl>, uint64_t>>\n  getPltAddresses() const;\n};\n\nclass ELFSectionRef : public SectionRef {\npublic:\n  ELFSectionRef(const SectionRef &B) : SectionRef(B) {\n    assert(isa<ELFObjectFileBase>(SectionRef::getObject()));\n  }\n\n  const ELFObjectFileBase *getObject() const {\n    return cast<ELFObjectFileBase>(SectionRef::getObject());\n  }\n\n  uint32_t getType() const {\n    return getObject()->getSectionType(getRawDataRefImpl());\n  }\n\n  uint64_t getFlags() const {\n    return getObject()->getSectionFlags(getRawDataRefImpl());\n  }\n\n  uint64_t getOffset() const {\n    return getObject()->getSectionOffset(getRawDataRefImpl());\n  }\n};\n\nclass elf_section_iterator : public section_iterator {\npublic:\n  elf_section_iterator(const section_iterator &B) : section_iterator(B) {\n    assert(isa<ELFObjectFileBase>(B->getObject()));\n  }\n\n  const ELFSectionRef *operator->() const {\n    return static_cast<const ELFSectionRef *>(section_iterator::operator->());\n  }\n\n  const ELFSectionRef &operator*() const {\n    return static_cast<const ELFSectionRef &>(section_iterator::operator*());\n  }\n};\n\nclass ELFSymbolRef : public SymbolRef {\npublic:\n  ELFSymbolRef(const SymbolRef &B) : SymbolRef(B) {\n    assert(isa<ELFObjectFileBase>(SymbolRef::getObject()));\n  }\n\n  const ELFObjectFileBase *getObject() const {\n    return cast<ELFObjectFileBase>(BasicSymbolRef::getObject());\n  }\n\n  uint64_t getSize() const {\n    return getObject()->getSymbolSize(getRawDataRefImpl());\n  }\n\n  uint8_t getBinding() const {\n    return getObject()->getSymbolBinding(getRawDataRefImpl());\n  }\n\n  uint8_t getOther() const {\n    return getObject()->getSymbolOther(getRawDataRefImpl());\n  }\n\n  uint8_t getELFType() const {\n    return getObject()->getSymbolELFType(getRawDataRefImpl());\n  }\n\n  StringRef getELFTypeName() const {\n    uint8_t Type = getELFType();\n    for (auto &EE : ElfSymbolTypes) {\n      if (EE.Value == Type) {\n        return EE.AltName;\n      }\n    }\n    return \"\";\n  }\n};\n\nclass elf_symbol_iterator : public symbol_iterator {\npublic:\n  elf_symbol_iterator(const basic_symbol_iterator &B)\n      : symbol_iterator(SymbolRef(B->getRawDataRefImpl(),\n                                  cast<ELFObjectFileBase>(B->getObject()))) {}\n\n  const ELFSymbolRef *operator->() const {\n    return static_cast<const ELFSymbolRef *>(symbol_iterator::operator->());\n  }\n\n  const ELFSymbolRef &operator*() const {\n    return static_cast<const ELFSymbolRef &>(symbol_iterator::operator*());\n  }\n};\n\nclass ELFRelocationRef : public RelocationRef {\npublic:\n  ELFRelocationRef(const RelocationRef &B) : RelocationRef(B) {\n    assert(isa<ELFObjectFileBase>(RelocationRef::getObject()));\n  }\n\n  const ELFObjectFileBase *getObject() const {\n    return cast<ELFObjectFileBase>(RelocationRef::getObject());\n  }\n\n  Expected<int64_t> getAddend() const {\n    return getObject()->getRelocationAddend(getRawDataRefImpl());\n  }\n};\n\nclass elf_relocation_iterator : public relocation_iterator {\npublic:\n  elf_relocation_iterator(const relocation_iterator &B)\n      : relocation_iterator(RelocationRef(\n            B->getRawDataRefImpl(), cast<ELFObjectFileBase>(B->getObject()))) {}\n\n  const ELFRelocationRef *operator->() const {\n    return static_cast<const ELFRelocationRef *>(\n        relocation_iterator::operator->());\n  }\n\n  const ELFRelocationRef &operator*() const {\n    return static_cast<const ELFRelocationRef &>(\n        relocation_iterator::operator*());\n  }\n};\n\ninline ELFObjectFileBase::elf_symbol_iterator_range\nELFObjectFileBase::symbols() const {\n  return elf_symbol_iterator_range(symbol_begin(), symbol_end());\n}\n\ntemplate <class ELFT> class ELFObjectFile : public ELFObjectFileBase {\n  uint16_t getEMachine() const override;\n  uint16_t getEType() const override;\n  uint64_t getSymbolSize(DataRefImpl Sym) const override;\n\npublic:\n  LLVM_ELF_IMPORT_TYPES_ELFT(ELFT)\n\n  SectionRef toSectionRef(const Elf_Shdr *Sec) const {\n    return SectionRef(toDRI(Sec), this);\n  }\n\n  ELFSymbolRef toSymbolRef(const Elf_Shdr *SymTable, unsigned SymbolNum) const {\n    return ELFSymbolRef({toDRI(SymTable, SymbolNum), this});\n  }\n\n  bool IsContentValid() const { return ContentValid; }\n\nprivate:\n  ELFObjectFile(MemoryBufferRef Object, ELFFile<ELFT> EF,\n                const Elf_Shdr *DotDynSymSec, const Elf_Shdr *DotSymtabSec,\n                const Elf_Shdr *DotSymtabShndxSec);\n\n  bool ContentValid = false;\n\nprotected:\n  ELFFile<ELFT> EF;\n\n  const Elf_Shdr *DotDynSymSec = nullptr; // Dynamic symbol table section.\n  const Elf_Shdr *DotSymtabSec = nullptr; // Symbol table section.\n  const Elf_Shdr *DotSymtabShndxSec = nullptr; // SHT_SYMTAB_SHNDX section.\n\n  Error initContent() override;\n\n  void moveSymbolNext(DataRefImpl &Symb) const override;\n  Expected<StringRef> getSymbolName(DataRefImpl Symb) const override;\n  Expected<uint64_t> getSymbolAddress(DataRefImpl Symb) const override;\n  uint64_t getSymbolValueImpl(DataRefImpl Symb) const override;\n  uint32_t getSymbolAlignment(DataRefImpl Symb) const override;\n  uint64_t getCommonSymbolSizeImpl(DataRefImpl Symb) const override;\n  Expected<uint32_t> getSymbolFlags(DataRefImpl Symb) const override;\n  uint8_t getSymbolBinding(DataRefImpl Symb) const override;\n  uint8_t getSymbolOther(DataRefImpl Symb) const override;\n  uint8_t getSymbolELFType(DataRefImpl Symb) const override;\n  Expected<SymbolRef::Type> getSymbolType(DataRefImpl Symb) const override;\n  Expected<section_iterator> getSymbolSection(const Elf_Sym *Symb,\n                                              const Elf_Shdr *SymTab) const;\n  Expected<section_iterator> getSymbolSection(DataRefImpl Symb) const override;\n\n  void moveSectionNext(DataRefImpl &Sec) const override;\n  Expected<StringRef> getSectionName(DataRefImpl Sec) const override;\n  uint64_t getSectionAddress(DataRefImpl Sec) const override;\n  uint64_t getSectionIndex(DataRefImpl Sec) const override;\n  uint64_t getSectionSize(DataRefImpl Sec) const override;\n  Expected<ArrayRef<uint8_t>>\n  getSectionContents(DataRefImpl Sec) const override;\n  uint64_t getSectionAlignment(DataRefImpl Sec) const override;\n  bool isSectionCompressed(DataRefImpl Sec) const override;\n  bool isSectionText(DataRefImpl Sec) const override;\n  bool isSectionData(DataRefImpl Sec) const override;\n  bool isSectionBSS(DataRefImpl Sec) const override;\n  bool isSectionVirtual(DataRefImpl Sec) const override;\n  bool isBerkeleyText(DataRefImpl Sec) const override;\n  bool isBerkeleyData(DataRefImpl Sec) const override;\n  bool isDebugSection(StringRef SectionName) const override;\n  relocation_iterator section_rel_begin(DataRefImpl Sec) const override;\n  relocation_iterator section_rel_end(DataRefImpl Sec) const override;\n  std::vector<SectionRef> dynamic_relocation_sections() const override;\n  Expected<section_iterator>\n  getRelocatedSection(DataRefImpl Sec) const override;\n\n  void moveRelocationNext(DataRefImpl &Rel) const override;\n  uint64_t getRelocationOffset(DataRefImpl Rel) const override;\n  symbol_iterator getRelocationSymbol(DataRefImpl Rel) const override;\n  uint64_t getRelocationType(DataRefImpl Rel) const override;\n  void getRelocationTypeName(DataRefImpl Rel,\n                             SmallVectorImpl<char> &Result) const override;\n\n  uint32_t getSectionType(DataRefImpl Sec) const override;\n  uint64_t getSectionFlags(DataRefImpl Sec) const override;\n  uint64_t getSectionOffset(DataRefImpl Sec) const override;\n  StringRef getRelocationTypeName(uint32_t Type) const;\n\n  DataRefImpl toDRI(const Elf_Shdr *SymTable, unsigned SymbolNum) const {\n    DataRefImpl DRI;\n    if (!SymTable) {\n      DRI.d.a = 0;\n      DRI.d.b = 0;\n      return DRI;\n    }\n    assert(SymTable->sh_type == ELF::SHT_SYMTAB ||\n           SymTable->sh_type == ELF::SHT_DYNSYM);\n\n    auto SectionsOrErr = EF.sections();\n    if (!SectionsOrErr) {\n      DRI.d.a = 0;\n      DRI.d.b = 0;\n      return DRI;\n    }\n    uintptr_t SHT = reinterpret_cast<uintptr_t>((*SectionsOrErr).begin());\n    unsigned SymTableIndex =\n        (reinterpret_cast<uintptr_t>(SymTable) - SHT) / sizeof(Elf_Shdr);\n\n    DRI.d.a = SymTableIndex;\n    DRI.d.b = SymbolNum;\n    return DRI;\n  }\n\n  const Elf_Shdr *toELFShdrIter(DataRefImpl Sec) const {\n    return reinterpret_cast<const Elf_Shdr *>(Sec.p);\n  }\n\n  DataRefImpl toDRI(const Elf_Shdr *Sec) const {\n    DataRefImpl DRI;\n    DRI.p = reinterpret_cast<uintptr_t>(Sec);\n    return DRI;\n  }\n\n  DataRefImpl toDRI(const Elf_Dyn *Dyn) const {\n    DataRefImpl DRI;\n    DRI.p = reinterpret_cast<uintptr_t>(Dyn);\n    return DRI;\n  }\n\n  bool isExportedToOtherDSO(const Elf_Sym *ESym) const {\n    unsigned char Binding = ESym->getBinding();\n    unsigned char Visibility = ESym->getVisibility();\n\n    // A symbol is exported if its binding is either GLOBAL or WEAK, and its\n    // visibility is either DEFAULT or PROTECTED. All other symbols are not\n    // exported.\n    return (\n        (Binding == ELF::STB_GLOBAL || Binding == ELF::STB_WEAK ||\n         Binding == ELF::STB_GNU_UNIQUE) &&\n        (Visibility == ELF::STV_DEFAULT || Visibility == ELF::STV_PROTECTED));\n  }\n\n  Error getBuildAttributes(ELFAttributeParser &Attributes) const override {\n    auto SectionsOrErr = EF.sections();\n    if (!SectionsOrErr)\n      return SectionsOrErr.takeError();\n\n    for (const Elf_Shdr &Sec : *SectionsOrErr) {\n      if (Sec.sh_type == ELF::SHT_ARM_ATTRIBUTES ||\n          Sec.sh_type == ELF::SHT_RISCV_ATTRIBUTES) {\n        auto ErrorOrContents = EF.getSectionContents(Sec);\n        if (!ErrorOrContents)\n          return ErrorOrContents.takeError();\n\n        auto Contents = ErrorOrContents.get();\n        if (Contents[0] != ELFAttrs::Format_Version || Contents.size() == 1)\n          return Error::success();\n\n        if (Error E = Attributes.parse(Contents, ELFT::TargetEndianness))\n          return E;\n        break;\n      }\n    }\n    return Error::success();\n  }\n\n  // This flag is used for classof, to distinguish ELFObjectFile from\n  // its subclass. If more subclasses will be created, this flag will\n  // have to become an enum.\n  bool isDyldELFObject;\n\npublic:\n  ELFObjectFile(ELFObjectFile<ELFT> &&Other);\n  static Expected<ELFObjectFile<ELFT>> create(MemoryBufferRef Object,\n                                              bool InitContent = true);\n\n  const Elf_Rel *getRel(DataRefImpl Rel) const;\n  const Elf_Rela *getRela(DataRefImpl Rela) const;\n\n  Expected<const Elf_Sym *> getSymbol(DataRefImpl Sym) const {\n    return EF.template getEntry<Elf_Sym>(Sym.d.a, Sym.d.b);\n  }\n\n  /// Get the relocation section that contains \\a Rel.\n  const Elf_Shdr *getRelSection(DataRefImpl Rel) const {\n    auto RelSecOrErr = EF.getSection(Rel.d.a);\n    if (!RelSecOrErr)\n      report_fatal_error(errorToErrorCode(RelSecOrErr.takeError()).message());\n    return *RelSecOrErr;\n  }\n\n  const Elf_Shdr *getSection(DataRefImpl Sec) const {\n    return reinterpret_cast<const Elf_Shdr *>(Sec.p);\n  }\n\n  basic_symbol_iterator symbol_begin() const override;\n  basic_symbol_iterator symbol_end() const override;\n\n  elf_symbol_iterator dynamic_symbol_begin() const;\n  elf_symbol_iterator dynamic_symbol_end() const;\n\n  section_iterator section_begin() const override;\n  section_iterator section_end() const override;\n\n  Expected<int64_t> getRelocationAddend(DataRefImpl Rel) const override;\n\n  uint8_t getBytesInAddress() const override;\n  StringRef getFileFormatName() const override;\n  Triple::ArchType getArch() const override;\n  Expected<uint64_t> getStartAddress() const override;\n\n  unsigned getPlatformFlags() const override { return EF.getHeader().e_flags; }\n\n  const ELFFile<ELFT> &getELFFile() const { return EF; }\n\n  bool isDyldType() const { return isDyldELFObject; }\n  static bool classof(const Binary *v) {\n    return v->getType() == getELFType(ELFT::TargetEndianness == support::little,\n                                      ELFT::Is64Bits);\n  }\n\n  elf_symbol_iterator_range getDynamicSymbolIterators() const override;\n\n  bool isRelocatableObject() const override;\n};\n\nusing ELF32LEObjectFile = ELFObjectFile<ELF32LE>;\nusing ELF64LEObjectFile = ELFObjectFile<ELF64LE>;\nusing ELF32BEObjectFile = ELFObjectFile<ELF32BE>;\nusing ELF64BEObjectFile = ELFObjectFile<ELF64BE>;\n\ntemplate <class ELFT>\nvoid ELFObjectFile<ELFT>::moveSymbolNext(DataRefImpl &Sym) const {\n  ++Sym.d.b;\n}\n\ntemplate <class ELFT> Error ELFObjectFile<ELFT>::initContent() {\n  auto SectionsOrErr = EF.sections();\n  if (!SectionsOrErr)\n    return SectionsOrErr.takeError();\n\n  for (const Elf_Shdr &Sec : *SectionsOrErr) {\n    switch (Sec.sh_type) {\n    case ELF::SHT_DYNSYM: {\n      if (!DotDynSymSec)\n        DotDynSymSec = &Sec;\n      break;\n    }\n    case ELF::SHT_SYMTAB: {\n      if (!DotSymtabSec)\n        DotSymtabSec = &Sec;\n      break;\n    }\n    case ELF::SHT_SYMTAB_SHNDX: {\n      if (!DotSymtabShndxSec)\n        DotSymtabShndxSec = &Sec;\n      break;\n    }\n    }\n  }\n\n  ContentValid = true;\n  return Error::success();\n}\n\ntemplate <class ELFT>\nExpected<StringRef> ELFObjectFile<ELFT>::getSymbolName(DataRefImpl Sym) const {\n  Expected<const Elf_Sym *> SymOrErr = getSymbol(Sym);\n  if (!SymOrErr)\n    return SymOrErr.takeError();\n  auto SymTabOrErr = EF.getSection(Sym.d.a);\n  if (!SymTabOrErr)\n    return SymTabOrErr.takeError();\n  const Elf_Shdr *SymTableSec = *SymTabOrErr;\n  auto StrTabOrErr = EF.getSection(SymTableSec->sh_link);\n  if (!StrTabOrErr)\n    return StrTabOrErr.takeError();\n  const Elf_Shdr *StringTableSec = *StrTabOrErr;\n  auto SymStrTabOrErr = EF.getStringTable(*StringTableSec);\n  if (!SymStrTabOrErr)\n    return SymStrTabOrErr.takeError();\n  Expected<StringRef> Name = (*SymOrErr)->getName(*SymStrTabOrErr);\n  if (Name && !Name->empty())\n    return Name;\n\n  // If the symbol name is empty use the section name.\n  if ((*SymOrErr)->getType() == ELF::STT_SECTION) {\n    if (Expected<section_iterator> SecOrErr = getSymbolSection(Sym)) {\n      consumeError(Name.takeError());\n      return (*SecOrErr)->getName();\n    }\n  }\n  return Name;\n}\n\ntemplate <class ELFT>\nuint64_t ELFObjectFile<ELFT>::getSectionFlags(DataRefImpl Sec) const {\n  return getSection(Sec)->sh_flags;\n}\n\ntemplate <class ELFT>\nuint32_t ELFObjectFile<ELFT>::getSectionType(DataRefImpl Sec) const {\n  return getSection(Sec)->sh_type;\n}\n\ntemplate <class ELFT>\nuint64_t ELFObjectFile<ELFT>::getSectionOffset(DataRefImpl Sec) const {\n  return getSection(Sec)->sh_offset;\n}\n\ntemplate <class ELFT>\nuint64_t ELFObjectFile<ELFT>::getSymbolValueImpl(DataRefImpl Symb) const {\n  Expected<const Elf_Sym *> SymOrErr = getSymbol(Symb);\n  if (!SymOrErr)\n    report_fatal_error(SymOrErr.takeError());\n\n  uint64_t Ret = (*SymOrErr)->st_value;\n  if ((*SymOrErr)->st_shndx == ELF::SHN_ABS)\n    return Ret;\n\n  const Elf_Ehdr &Header = EF.getHeader();\n  // Clear the ARM/Thumb or microMIPS indicator flag.\n  if ((Header.e_machine == ELF::EM_ARM || Header.e_machine == ELF::EM_MIPS) &&\n      (*SymOrErr)->getType() == ELF::STT_FUNC)\n    Ret &= ~1;\n\n  return Ret;\n}\n\ntemplate <class ELFT>\nExpected<uint64_t>\nELFObjectFile<ELFT>::getSymbolAddress(DataRefImpl Symb) const {\n  Expected<uint64_t> SymbolValueOrErr = getSymbolValue(Symb);\n  if (!SymbolValueOrErr)\n    // TODO: Test this error.\n    return SymbolValueOrErr.takeError();\n\n  uint64_t Result = *SymbolValueOrErr;\n  Expected<const Elf_Sym *> SymOrErr = getSymbol(Symb);\n  if (!SymOrErr)\n    return SymOrErr.takeError();\n\n  switch ((*SymOrErr)->st_shndx) {\n  case ELF::SHN_COMMON:\n  case ELF::SHN_UNDEF:\n  case ELF::SHN_ABS:\n    return Result;\n  }\n\n  auto SymTabOrErr = EF.getSection(Symb.d.a);\n  if (!SymTabOrErr)\n    return SymTabOrErr.takeError();\n\n  if (EF.getHeader().e_type == ELF::ET_REL) {\n    ArrayRef<Elf_Word> ShndxTable;\n    if (DotSymtabShndxSec) {\n      // TODO: Test this error.\n      if (Expected<ArrayRef<Elf_Word>> ShndxTableOrErr =\n              EF.getSHNDXTable(*DotSymtabShndxSec))\n        ShndxTable = *ShndxTableOrErr;\n      else\n        return ShndxTableOrErr.takeError();\n    }\n\n    Expected<const Elf_Shdr *> SectionOrErr =\n        EF.getSection(**SymOrErr, *SymTabOrErr, ShndxTable);\n    if (!SectionOrErr)\n      return SectionOrErr.takeError();\n    const Elf_Shdr *Section = *SectionOrErr;\n    if (Section)\n      Result += Section->sh_addr;\n  }\n\n  return Result;\n}\n\ntemplate <class ELFT>\nuint32_t ELFObjectFile<ELFT>::getSymbolAlignment(DataRefImpl Symb) const {\n  Expected<const Elf_Sym *> SymOrErr = getSymbol(Symb);\n  if (!SymOrErr)\n    report_fatal_error(SymOrErr.takeError());\n  if ((*SymOrErr)->st_shndx == ELF::SHN_COMMON)\n    return (*SymOrErr)->st_value;\n  return 0;\n}\n\ntemplate <class ELFT>\nuint16_t ELFObjectFile<ELFT>::getEMachine() const {\n  return EF.getHeader().e_machine;\n}\n\ntemplate <class ELFT> uint16_t ELFObjectFile<ELFT>::getEType() const {\n  return EF.getHeader().e_type;\n}\n\ntemplate <class ELFT>\nuint64_t ELFObjectFile<ELFT>::getSymbolSize(DataRefImpl Sym) const {\n  Expected<const Elf_Sym *> SymOrErr = getSymbol(Sym);\n  if (!SymOrErr)\n    report_fatal_error(SymOrErr.takeError());\n  return (*SymOrErr)->st_size;\n}\n\ntemplate <class ELFT>\nuint64_t ELFObjectFile<ELFT>::getCommonSymbolSizeImpl(DataRefImpl Symb) const {\n  return getSymbolSize(Symb);\n}\n\ntemplate <class ELFT>\nuint8_t ELFObjectFile<ELFT>::getSymbolBinding(DataRefImpl Symb) const {\n  Expected<const Elf_Sym *> SymOrErr = getSymbol(Symb);\n  if (!SymOrErr)\n    report_fatal_error(SymOrErr.takeError());\n  return (*SymOrErr)->getBinding();\n}\n\ntemplate <class ELFT>\nuint8_t ELFObjectFile<ELFT>::getSymbolOther(DataRefImpl Symb) const {\n  Expected<const Elf_Sym *> SymOrErr = getSymbol(Symb);\n  if (!SymOrErr)\n    report_fatal_error(SymOrErr.takeError());\n  return (*SymOrErr)->st_other;\n}\n\ntemplate <class ELFT>\nuint8_t ELFObjectFile<ELFT>::getSymbolELFType(DataRefImpl Symb) const {\n  Expected<const Elf_Sym *> SymOrErr = getSymbol(Symb);\n  if (!SymOrErr)\n    report_fatal_error(SymOrErr.takeError());\n  return (*SymOrErr)->getType();\n}\n\ntemplate <class ELFT>\nExpected<SymbolRef::Type>\nELFObjectFile<ELFT>::getSymbolType(DataRefImpl Symb) const {\n  Expected<const Elf_Sym *> SymOrErr = getSymbol(Symb);\n  if (!SymOrErr)\n    return SymOrErr.takeError();\n\n  switch ((*SymOrErr)->getType()) {\n  case ELF::STT_NOTYPE:\n    return SymbolRef::ST_Unknown;\n  case ELF::STT_SECTION:\n    return SymbolRef::ST_Debug;\n  case ELF::STT_FILE:\n    return SymbolRef::ST_File;\n  case ELF::STT_FUNC:\n    return SymbolRef::ST_Function;\n  case ELF::STT_OBJECT:\n  case ELF::STT_COMMON:\n    return SymbolRef::ST_Data;\n  case ELF::STT_TLS:\n  default:\n    return SymbolRef::ST_Other;\n  }\n}\n\ntemplate <class ELFT>\nExpected<uint32_t> ELFObjectFile<ELFT>::getSymbolFlags(DataRefImpl Sym) const {\n  Expected<const Elf_Sym *> SymOrErr = getSymbol(Sym);\n  if (!SymOrErr)\n    return SymOrErr.takeError();\n\n  const Elf_Sym *ESym = *SymOrErr;\n  uint32_t Result = SymbolRef::SF_None;\n\n  if (ESym->getBinding() != ELF::STB_LOCAL)\n    Result |= SymbolRef::SF_Global;\n\n  if (ESym->getBinding() == ELF::STB_WEAK)\n    Result |= SymbolRef::SF_Weak;\n\n  if (ESym->st_shndx == ELF::SHN_ABS)\n    Result |= SymbolRef::SF_Absolute;\n\n  if (ESym->getType() == ELF::STT_FILE || ESym->getType() == ELF::STT_SECTION)\n    Result |= SymbolRef::SF_FormatSpecific;\n\n  if (Expected<typename ELFT::SymRange> SymbolsOrErr =\n          EF.symbols(DotSymtabSec)) {\n    // Set the SF_FormatSpecific flag for the 0-index null symbol.\n    if (ESym == SymbolsOrErr->begin())\n      Result |= SymbolRef::SF_FormatSpecific;\n  } else\n    // TODO: Test this error.\n    return SymbolsOrErr.takeError();\n\n  if (Expected<typename ELFT::SymRange> SymbolsOrErr =\n          EF.symbols(DotDynSymSec)) {\n    // Set the SF_FormatSpecific flag for the 0-index null symbol.\n    if (ESym == SymbolsOrErr->begin())\n      Result |= SymbolRef::SF_FormatSpecific;\n  } else\n    // TODO: Test this error.\n    return SymbolsOrErr.takeError();\n\n  if (EF.getHeader().e_machine == ELF::EM_ARM) {\n    if (Expected<StringRef> NameOrErr = getSymbolName(Sym)) {\n      StringRef Name = *NameOrErr;\n      if (Name.startswith(\"$d\") || Name.startswith(\"$t\") ||\n          Name.startswith(\"$a\"))\n        Result |= SymbolRef::SF_FormatSpecific;\n    } else {\n      // TODO: Actually report errors helpfully.\n      consumeError(NameOrErr.takeError());\n    }\n    if (ESym->getType() == ELF::STT_FUNC && (ESym->st_value & 1) == 1)\n      Result |= SymbolRef::SF_Thumb;\n  }\n\n  if (ESym->st_shndx == ELF::SHN_UNDEF)\n    Result |= SymbolRef::SF_Undefined;\n\n  if (ESym->getType() == ELF::STT_COMMON || ESym->st_shndx == ELF::SHN_COMMON)\n    Result |= SymbolRef::SF_Common;\n\n  if (isExportedToOtherDSO(ESym))\n    Result |= SymbolRef::SF_Exported;\n\n  if (ESym->getVisibility() == ELF::STV_HIDDEN)\n    Result |= SymbolRef::SF_Hidden;\n\n  return Result;\n}\n\ntemplate <class ELFT>\nExpected<section_iterator>\nELFObjectFile<ELFT>::getSymbolSection(const Elf_Sym *ESym,\n                                      const Elf_Shdr *SymTab) const {\n  ArrayRef<Elf_Word> ShndxTable;\n  if (DotSymtabShndxSec) {\n    // TODO: Test this error.\n    Expected<ArrayRef<Elf_Word>> ShndxTableOrErr =\n        EF.getSHNDXTable(*DotSymtabShndxSec);\n    if (!ShndxTableOrErr)\n      return ShndxTableOrErr.takeError();\n    ShndxTable = *ShndxTableOrErr;\n  }\n\n  auto ESecOrErr = EF.getSection(*ESym, SymTab, ShndxTable);\n  if (!ESecOrErr)\n    return ESecOrErr.takeError();\n\n  const Elf_Shdr *ESec = *ESecOrErr;\n  if (!ESec)\n    return section_end();\n\n  DataRefImpl Sec;\n  Sec.p = reinterpret_cast<intptr_t>(ESec);\n  return section_iterator(SectionRef(Sec, this));\n}\n\ntemplate <class ELFT>\nExpected<section_iterator>\nELFObjectFile<ELFT>::getSymbolSection(DataRefImpl Symb) const {\n  Expected<const Elf_Sym *> SymOrErr = getSymbol(Symb);\n  if (!SymOrErr)\n    return SymOrErr.takeError();\n\n  auto SymTabOrErr = EF.getSection(Symb.d.a);\n  if (!SymTabOrErr)\n    return SymTabOrErr.takeError();\n  return getSymbolSection(*SymOrErr, *SymTabOrErr);\n}\n\ntemplate <class ELFT>\nvoid ELFObjectFile<ELFT>::moveSectionNext(DataRefImpl &Sec) const {\n  const Elf_Shdr *ESec = getSection(Sec);\n  Sec = toDRI(++ESec);\n}\n\ntemplate <class ELFT>\nExpected<StringRef> ELFObjectFile<ELFT>::getSectionName(DataRefImpl Sec) const {\n  return EF.getSectionName(*getSection(Sec));\n}\n\ntemplate <class ELFT>\nuint64_t ELFObjectFile<ELFT>::getSectionAddress(DataRefImpl Sec) const {\n  return getSection(Sec)->sh_addr;\n}\n\ntemplate <class ELFT>\nuint64_t ELFObjectFile<ELFT>::getSectionIndex(DataRefImpl Sec) const {\n  auto SectionsOrErr = EF.sections();\n  handleAllErrors(std::move(SectionsOrErr.takeError()),\n                  [](const ErrorInfoBase &) {\n                    llvm_unreachable(\"unable to get section index\");\n                  });\n  const Elf_Shdr *First = SectionsOrErr->begin();\n  return getSection(Sec) - First;\n}\n\ntemplate <class ELFT>\nuint64_t ELFObjectFile<ELFT>::getSectionSize(DataRefImpl Sec) const {\n  return getSection(Sec)->sh_size;\n}\n\ntemplate <class ELFT>\nExpected<ArrayRef<uint8_t>>\nELFObjectFile<ELFT>::getSectionContents(DataRefImpl Sec) const {\n  const Elf_Shdr *EShdr = getSection(Sec);\n  if (EShdr->sh_type == ELF::SHT_NOBITS)\n    return makeArrayRef((const uint8_t *)base(), 0);\n  if (Error E =\n          checkOffset(getMemoryBufferRef(),\n                      (uintptr_t)base() + EShdr->sh_offset, EShdr->sh_size))\n    return std::move(E);\n  return makeArrayRef((const uint8_t *)base() + EShdr->sh_offset,\n                      EShdr->sh_size);\n}\n\ntemplate <class ELFT>\nuint64_t ELFObjectFile<ELFT>::getSectionAlignment(DataRefImpl Sec) const {\n  return getSection(Sec)->sh_addralign;\n}\n\ntemplate <class ELFT>\nbool ELFObjectFile<ELFT>::isSectionCompressed(DataRefImpl Sec) const {\n  return getSection(Sec)->sh_flags & ELF::SHF_COMPRESSED;\n}\n\ntemplate <class ELFT>\nbool ELFObjectFile<ELFT>::isSectionText(DataRefImpl Sec) const {\n  return getSection(Sec)->sh_flags & ELF::SHF_EXECINSTR;\n}\n\ntemplate <class ELFT>\nbool ELFObjectFile<ELFT>::isSectionData(DataRefImpl Sec) const {\n  const Elf_Shdr *EShdr = getSection(Sec);\n  return EShdr->sh_type == ELF::SHT_PROGBITS &&\n         EShdr->sh_flags & ELF::SHF_ALLOC &&\n         !(EShdr->sh_flags & ELF::SHF_EXECINSTR);\n}\n\ntemplate <class ELFT>\nbool ELFObjectFile<ELFT>::isSectionBSS(DataRefImpl Sec) const {\n  const Elf_Shdr *EShdr = getSection(Sec);\n  return EShdr->sh_flags & (ELF::SHF_ALLOC | ELF::SHF_WRITE) &&\n         EShdr->sh_type == ELF::SHT_NOBITS;\n}\n\ntemplate <class ELFT>\nstd::vector<SectionRef>\nELFObjectFile<ELFT>::dynamic_relocation_sections() const {\n  std::vector<SectionRef> Res;\n  std::vector<uintptr_t> Offsets;\n\n  auto SectionsOrErr = EF.sections();\n  if (!SectionsOrErr)\n    return Res;\n\n  for (const Elf_Shdr &Sec : *SectionsOrErr) {\n    if (Sec.sh_type != ELF::SHT_DYNAMIC)\n      continue;\n    Elf_Dyn *Dynamic =\n        reinterpret_cast<Elf_Dyn *>((uintptr_t)base() + Sec.sh_offset);\n    for (; Dynamic->d_tag != ELF::DT_NULL; Dynamic++) {\n      if (Dynamic->d_tag == ELF::DT_REL || Dynamic->d_tag == ELF::DT_RELA ||\n          Dynamic->d_tag == ELF::DT_JMPREL) {\n        Offsets.push_back(Dynamic->d_un.d_val);\n      }\n    }\n  }\n  for (const Elf_Shdr &Sec : *SectionsOrErr) {\n    if (is_contained(Offsets, Sec.sh_addr))\n      Res.emplace_back(toDRI(&Sec), this);\n  }\n  return Res;\n}\n\ntemplate <class ELFT>\nbool ELFObjectFile<ELFT>::isSectionVirtual(DataRefImpl Sec) const {\n  return getSection(Sec)->sh_type == ELF::SHT_NOBITS;\n}\n\ntemplate <class ELFT>\nbool ELFObjectFile<ELFT>::isBerkeleyText(DataRefImpl Sec) const {\n  return getSection(Sec)->sh_flags & ELF::SHF_ALLOC &&\n         (getSection(Sec)->sh_flags & ELF::SHF_EXECINSTR ||\n          !(getSection(Sec)->sh_flags & ELF::SHF_WRITE));\n}\n\ntemplate <class ELFT>\nbool ELFObjectFile<ELFT>::isBerkeleyData(DataRefImpl Sec) const {\n  const Elf_Shdr *EShdr = getSection(Sec);\n  return !isBerkeleyText(Sec) && EShdr->sh_type != ELF::SHT_NOBITS &&\n         EShdr->sh_flags & ELF::SHF_ALLOC;\n}\n\ntemplate <class ELFT>\nbool ELFObjectFile<ELFT>::isDebugSection(StringRef SectionName) const {\n  return SectionName.startswith(\".debug\") ||\n         SectionName.startswith(\".zdebug\") || SectionName == \".gdb_index\";\n}\n\ntemplate <class ELFT>\nrelocation_iterator\nELFObjectFile<ELFT>::section_rel_begin(DataRefImpl Sec) const {\n  DataRefImpl RelData;\n  auto SectionsOrErr = EF.sections();\n  if (!SectionsOrErr)\n    return relocation_iterator(RelocationRef());\n  uintptr_t SHT = reinterpret_cast<uintptr_t>((*SectionsOrErr).begin());\n  RelData.d.a = (Sec.p - SHT) / EF.getHeader().e_shentsize;\n  RelData.d.b = 0;\n  return relocation_iterator(RelocationRef(RelData, this));\n}\n\ntemplate <class ELFT>\nrelocation_iterator\nELFObjectFile<ELFT>::section_rel_end(DataRefImpl Sec) const {\n  const Elf_Shdr *S = reinterpret_cast<const Elf_Shdr *>(Sec.p);\n  relocation_iterator Begin = section_rel_begin(Sec);\n  if (S->sh_type != ELF::SHT_RELA && S->sh_type != ELF::SHT_REL)\n    return Begin;\n  DataRefImpl RelData = Begin->getRawDataRefImpl();\n  const Elf_Shdr *RelSec = getRelSection(RelData);\n\n  // Error check sh_link here so that getRelocationSymbol can just use it.\n  auto SymSecOrErr = EF.getSection(RelSec->sh_link);\n  if (!SymSecOrErr)\n    report_fatal_error(errorToErrorCode(SymSecOrErr.takeError()).message());\n\n  RelData.d.b += S->sh_size / S->sh_entsize;\n  return relocation_iterator(RelocationRef(RelData, this));\n}\n\ntemplate <class ELFT>\nExpected<section_iterator>\nELFObjectFile<ELFT>::getRelocatedSection(DataRefImpl Sec) const {\n  if (EF.getHeader().e_type != ELF::ET_REL)\n    return section_end();\n\n  const Elf_Shdr *EShdr = getSection(Sec);\n  uintX_t Type = EShdr->sh_type;\n  if (Type != ELF::SHT_REL && Type != ELF::SHT_RELA)\n    return section_end();\n\n  Expected<const Elf_Shdr *> SecOrErr = EF.getSection(EShdr->sh_info);\n  if (!SecOrErr)\n    return SecOrErr.takeError();\n  return section_iterator(SectionRef(toDRI(*SecOrErr), this));\n}\n\n// Relocations\ntemplate <class ELFT>\nvoid ELFObjectFile<ELFT>::moveRelocationNext(DataRefImpl &Rel) const {\n  ++Rel.d.b;\n}\n\ntemplate <class ELFT>\nsymbol_iterator\nELFObjectFile<ELFT>::getRelocationSymbol(DataRefImpl Rel) const {\n  uint32_t symbolIdx;\n  const Elf_Shdr *sec = getRelSection(Rel);\n  if (sec->sh_type == ELF::SHT_REL)\n    symbolIdx = getRel(Rel)->getSymbol(EF.isMips64EL());\n  else\n    symbolIdx = getRela(Rel)->getSymbol(EF.isMips64EL());\n  if (!symbolIdx)\n    return symbol_end();\n\n  // FIXME: error check symbolIdx\n  DataRefImpl SymbolData;\n  SymbolData.d.a = sec->sh_link;\n  SymbolData.d.b = symbolIdx;\n  return symbol_iterator(SymbolRef(SymbolData, this));\n}\n\ntemplate <class ELFT>\nuint64_t ELFObjectFile<ELFT>::getRelocationOffset(DataRefImpl Rel) const {\n  const Elf_Shdr *sec = getRelSection(Rel);\n  if (sec->sh_type == ELF::SHT_REL)\n    return getRel(Rel)->r_offset;\n\n  return getRela(Rel)->r_offset;\n}\n\ntemplate <class ELFT>\nuint64_t ELFObjectFile<ELFT>::getRelocationType(DataRefImpl Rel) const {\n  const Elf_Shdr *sec = getRelSection(Rel);\n  if (sec->sh_type == ELF::SHT_REL)\n    return getRel(Rel)->getType(EF.isMips64EL());\n  else\n    return getRela(Rel)->getType(EF.isMips64EL());\n}\n\ntemplate <class ELFT>\nStringRef ELFObjectFile<ELFT>::getRelocationTypeName(uint32_t Type) const {\n  return getELFRelocationTypeName(EF.getHeader().e_machine, Type);\n}\n\ntemplate <class ELFT>\nvoid ELFObjectFile<ELFT>::getRelocationTypeName(\n    DataRefImpl Rel, SmallVectorImpl<char> &Result) const {\n  uint32_t type = getRelocationType(Rel);\n  EF.getRelocationTypeName(type, Result);\n}\n\ntemplate <class ELFT>\nExpected<int64_t>\nELFObjectFile<ELFT>::getRelocationAddend(DataRefImpl Rel) const {\n  if (getRelSection(Rel)->sh_type != ELF::SHT_RELA)\n    return createError(\"Section is not SHT_RELA\");\n  return (int64_t)getRela(Rel)->r_addend;\n}\n\ntemplate <class ELFT>\nconst typename ELFObjectFile<ELFT>::Elf_Rel *\nELFObjectFile<ELFT>::getRel(DataRefImpl Rel) const {\n  assert(getRelSection(Rel)->sh_type == ELF::SHT_REL);\n  auto Ret = EF.template getEntry<Elf_Rel>(Rel.d.a, Rel.d.b);\n  if (!Ret)\n    report_fatal_error(errorToErrorCode(Ret.takeError()).message());\n  return *Ret;\n}\n\ntemplate <class ELFT>\nconst typename ELFObjectFile<ELFT>::Elf_Rela *\nELFObjectFile<ELFT>::getRela(DataRefImpl Rela) const {\n  assert(getRelSection(Rela)->sh_type == ELF::SHT_RELA);\n  auto Ret = EF.template getEntry<Elf_Rela>(Rela.d.a, Rela.d.b);\n  if (!Ret)\n    report_fatal_error(errorToErrorCode(Ret.takeError()).message());\n  return *Ret;\n}\n\ntemplate <class ELFT>\nExpected<ELFObjectFile<ELFT>>\nELFObjectFile<ELFT>::create(MemoryBufferRef Object, bool InitContent) {\n  auto EFOrErr = ELFFile<ELFT>::create(Object.getBuffer());\n  if (Error E = EFOrErr.takeError())\n    return std::move(E);\n\n  ELFObjectFile<ELFT> Obj = {Object, std::move(*EFOrErr), nullptr, nullptr,\n                             nullptr};\n  if (InitContent)\n    if (Error E = Obj.initContent())\n      return std::move(E);\n  return std::move(Obj);\n}\n\ntemplate <class ELFT>\nELFObjectFile<ELFT>::ELFObjectFile(MemoryBufferRef Object, ELFFile<ELFT> EF,\n                                   const Elf_Shdr *DotDynSymSec,\n                                   const Elf_Shdr *DotSymtabSec,\n                                   const Elf_Shdr *DotSymtabShndx)\n    : ELFObjectFileBase(\n          getELFType(ELFT::TargetEndianness == support::little, ELFT::Is64Bits),\n          Object),\n      EF(EF), DotDynSymSec(DotDynSymSec), DotSymtabSec(DotSymtabSec),\n      DotSymtabShndxSec(DotSymtabShndx) {}\n\ntemplate <class ELFT>\nELFObjectFile<ELFT>::ELFObjectFile(ELFObjectFile<ELFT> &&Other)\n    : ELFObjectFile(Other.Data, Other.EF, Other.DotDynSymSec,\n                    Other.DotSymtabSec, Other.DotSymtabShndxSec) {}\n\ntemplate <class ELFT>\nbasic_symbol_iterator ELFObjectFile<ELFT>::symbol_begin() const {\n  DataRefImpl Sym =\n      toDRI(DotSymtabSec,\n            DotSymtabSec && DotSymtabSec->sh_size >= sizeof(Elf_Sym) ? 1 : 0);\n  return basic_symbol_iterator(SymbolRef(Sym, this));\n}\n\ntemplate <class ELFT>\nbasic_symbol_iterator ELFObjectFile<ELFT>::symbol_end() const {\n  const Elf_Shdr *SymTab = DotSymtabSec;\n  if (!SymTab)\n    return symbol_begin();\n  DataRefImpl Sym = toDRI(SymTab, SymTab->sh_size / sizeof(Elf_Sym));\n  return basic_symbol_iterator(SymbolRef(Sym, this));\n}\n\ntemplate <class ELFT>\nelf_symbol_iterator ELFObjectFile<ELFT>::dynamic_symbol_begin() const {\n  if (!DotDynSymSec || DotDynSymSec->sh_size < sizeof(Elf_Sym))\n    // Ignore errors here where the dynsym is empty or sh_size less than the\n    // size of one symbol. These should be handled elsewhere.\n    return symbol_iterator(SymbolRef(toDRI(DotDynSymSec, 0), this));\n  // Skip 0-index NULL symbol.\n  return symbol_iterator(SymbolRef(toDRI(DotDynSymSec, 1), this));\n}\n\ntemplate <class ELFT>\nelf_symbol_iterator ELFObjectFile<ELFT>::dynamic_symbol_end() const {\n  const Elf_Shdr *SymTab = DotDynSymSec;\n  if (!SymTab)\n    return dynamic_symbol_begin();\n  DataRefImpl Sym = toDRI(SymTab, SymTab->sh_size / sizeof(Elf_Sym));\n  return basic_symbol_iterator(SymbolRef(Sym, this));\n}\n\ntemplate <class ELFT>\nsection_iterator ELFObjectFile<ELFT>::section_begin() const {\n  auto SectionsOrErr = EF.sections();\n  if (!SectionsOrErr)\n    return section_iterator(SectionRef());\n  return section_iterator(SectionRef(toDRI((*SectionsOrErr).begin()), this));\n}\n\ntemplate <class ELFT>\nsection_iterator ELFObjectFile<ELFT>::section_end() const {\n  auto SectionsOrErr = EF.sections();\n  if (!SectionsOrErr)\n    return section_iterator(SectionRef());\n  return section_iterator(SectionRef(toDRI((*SectionsOrErr).end()), this));\n}\n\ntemplate <class ELFT>\nuint8_t ELFObjectFile<ELFT>::getBytesInAddress() const {\n  return ELFT::Is64Bits ? 8 : 4;\n}\n\ntemplate <class ELFT>\nStringRef ELFObjectFile<ELFT>::getFileFormatName() const {\n  bool IsLittleEndian = ELFT::TargetEndianness == support::little;\n  switch (EF.getHeader().e_ident[ELF::EI_CLASS]) {\n  case ELF::ELFCLASS32:\n    switch (EF.getHeader().e_machine) {\n    case ELF::EM_68K:\n      return \"elf32-m68k\";\n    case ELF::EM_386:\n      return \"elf32-i386\";\n    case ELF::EM_IAMCU:\n      return \"elf32-iamcu\";\n    case ELF::EM_X86_64:\n      return \"elf32-x86-64\";\n    case ELF::EM_ARM:\n      return (IsLittleEndian ? \"elf32-littlearm\" : \"elf32-bigarm\");\n    case ELF::EM_AVR:\n      return \"elf32-avr\";\n    case ELF::EM_HEXAGON:\n      return \"elf32-hexagon\";\n    case ELF::EM_LANAI:\n      return \"elf32-lanai\";\n    case ELF::EM_MIPS:\n      return \"elf32-mips\";\n    case ELF::EM_MSP430:\n      return \"elf32-msp430\";\n    case ELF::EM_PPC:\n      return (IsLittleEndian ? \"elf32-powerpcle\" : \"elf32-powerpc\");\n    case ELF::EM_RISCV:\n      return \"elf32-littleriscv\";\n    case ELF::EM_CSKY:\n      return \"elf32-csky\";\n    case ELF::EM_SPARC:\n    case ELF::EM_SPARC32PLUS:\n      return \"elf32-sparc\";\n    case ELF::EM_AMDGPU:\n      return \"elf32-amdgpu\";\n    default:\n      return \"elf32-unknown\";\n    }\n  case ELF::ELFCLASS64:\n    switch (EF.getHeader().e_machine) {\n    case ELF::EM_386:\n      return \"elf64-i386\";\n    case ELF::EM_X86_64:\n      return \"elf64-x86-64\";\n    case ELF::EM_AARCH64:\n      return (IsLittleEndian ? \"elf64-littleaarch64\" : \"elf64-bigaarch64\");\n    case ELF::EM_PPC64:\n      return (IsLittleEndian ? \"elf64-powerpcle\" : \"elf64-powerpc\");\n    case ELF::EM_RISCV:\n      return \"elf64-littleriscv\";\n    case ELF::EM_S390:\n      return \"elf64-s390\";\n    case ELF::EM_SPARCV9:\n      return \"elf64-sparc\";\n    case ELF::EM_MIPS:\n      return \"elf64-mips\";\n    case ELF::EM_AMDGPU:\n      return \"elf64-amdgpu\";\n    case ELF::EM_BPF:\n      return \"elf64-bpf\";\n    case ELF::EM_VE:\n      return \"elf64-ve\";\n    default:\n      return \"elf64-unknown\";\n    }\n  default:\n    // FIXME: Proper error handling.\n    report_fatal_error(\"Invalid ELFCLASS!\");\n  }\n}\n\ntemplate <class ELFT> Triple::ArchType ELFObjectFile<ELFT>::getArch() const {\n  bool IsLittleEndian = ELFT::TargetEndianness == support::little;\n  switch (EF.getHeader().e_machine) {\n  case ELF::EM_68K:\n    return Triple::m68k;\n  case ELF::EM_386:\n  case ELF::EM_IAMCU:\n    return Triple::x86;\n  case ELF::EM_X86_64:\n    return Triple::x86_64;\n  case ELF::EM_AARCH64:\n    return IsLittleEndian ? Triple::aarch64 : Triple::aarch64_be;\n  case ELF::EM_ARM:\n    return Triple::arm;\n  case ELF::EM_AVR:\n    return Triple::avr;\n  case ELF::EM_HEXAGON:\n    return Triple::hexagon;\n  case ELF::EM_LANAI:\n    return Triple::lanai;\n  case ELF::EM_MIPS:\n    switch (EF.getHeader().e_ident[ELF::EI_CLASS]) {\n    case ELF::ELFCLASS32:\n      return IsLittleEndian ? Triple::mipsel : Triple::mips;\n    case ELF::ELFCLASS64:\n      return IsLittleEndian ? Triple::mips64el : Triple::mips64;\n    default:\n      report_fatal_error(\"Invalid ELFCLASS!\");\n    }\n  case ELF::EM_MSP430:\n    return Triple::msp430;\n  case ELF::EM_PPC:\n    return IsLittleEndian ? Triple::ppcle : Triple::ppc;\n  case ELF::EM_PPC64:\n    return IsLittleEndian ? Triple::ppc64le : Triple::ppc64;\n  case ELF::EM_RISCV:\n    switch (EF.getHeader().e_ident[ELF::EI_CLASS]) {\n    case ELF::ELFCLASS32:\n      return Triple::riscv32;\n    case ELF::ELFCLASS64:\n      return Triple::riscv64;\n    default:\n      report_fatal_error(\"Invalid ELFCLASS!\");\n    }\n  case ELF::EM_S390:\n    return Triple::systemz;\n\n  case ELF::EM_SPARC:\n  case ELF::EM_SPARC32PLUS:\n    return IsLittleEndian ? Triple::sparcel : Triple::sparc;\n  case ELF::EM_SPARCV9:\n    return Triple::sparcv9;\n\n  case ELF::EM_AMDGPU: {\n    if (!IsLittleEndian)\n      return Triple::UnknownArch;\n\n    unsigned MACH = EF.getHeader().e_flags & ELF::EF_AMDGPU_MACH;\n    if (MACH >= ELF::EF_AMDGPU_MACH_R600_FIRST &&\n        MACH <= ELF::EF_AMDGPU_MACH_R600_LAST)\n      return Triple::r600;\n    if (MACH >= ELF::EF_AMDGPU_MACH_AMDGCN_FIRST &&\n        MACH <= ELF::EF_AMDGPU_MACH_AMDGCN_LAST)\n      return Triple::amdgcn;\n\n    return Triple::UnknownArch;\n  }\n\n  case ELF::EM_BPF:\n    return IsLittleEndian ? Triple::bpfel : Triple::bpfeb;\n\n  case ELF::EM_VE:\n    return Triple::ve;\n  case ELF::EM_CSKY:\n    return Triple::csky;\n  default:\n    return Triple::UnknownArch;\n  }\n}\n\ntemplate <class ELFT>\nExpected<uint64_t> ELFObjectFile<ELFT>::getStartAddress() const {\n  return EF.getHeader().e_entry;\n}\n\ntemplate <class ELFT>\nELFObjectFileBase::elf_symbol_iterator_range\nELFObjectFile<ELFT>::getDynamicSymbolIterators() const {\n  return make_range(dynamic_symbol_begin(), dynamic_symbol_end());\n}\n\ntemplate <class ELFT> bool ELFObjectFile<ELFT>::isRelocatableObject() const {\n  return EF.getHeader().e_type == ELF::ET_REL;\n}\n\n} // end namespace object\n} // end namespace llvm\n\n#endif // LLVM_OBJECT_ELFOBJECTFILE_H\n"}, "38": {"id": 38, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Object/Error.h", "content": "//===- Error.h - system_error extensions for Object -------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// This declares a new error_category for the Object library.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_OBJECT_ERROR_H\n#define LLVM_OBJECT_ERROR_H\n\n#include \"llvm/Support/Error.h\"\n#include <system_error>\n\nnamespace llvm {\n\nclass Twine;\n\nnamespace object {\n\nclass Binary;\n\nconst std::error_category &object_category();\n\nenum class object_error {\n  // Error code 0 is absent. Use std::error_code() instead.\n  arch_not_found = 1,\n  invalid_file_type,\n  parse_failed,\n  unexpected_eof,\n  string_table_non_null_end,\n  invalid_section_index,\n  bitcode_section_not_found,\n  invalid_symbol_index,\n};\n\ninline std::error_code make_error_code(object_error e) {\n  return std::error_code(static_cast<int>(e), object_category());\n}\n\n/// Base class for all errors indicating malformed binary files.\n///\n/// Having a subclass for all malformed binary files allows archive-walking\n/// code to skip malformed files without having to understand every possible\n/// way that a binary file might be malformed.\n///\n/// Currently inherits from ECError for easy interoperability with\n/// std::error_code, but this will be removed in the future.\nclass BinaryError : public ErrorInfo<BinaryError, ECError> {\n  void anchor() override;\npublic:\n  static char ID;\n  BinaryError() {\n    // Default to parse_failed, can be overridden with setErrorCode.\n    setErrorCode(make_error_code(object_error::parse_failed));\n  }\n};\n\n/// Generic binary error.\n///\n/// For errors that don't require their own specific sub-error (most errors)\n/// this class can be used to describe the error via a string message.\nclass GenericBinaryError : public ErrorInfo<GenericBinaryError, BinaryError> {\npublic:\n  static char ID;\n  GenericBinaryError(const Twine &Msg);\n  GenericBinaryError(const Twine &Msg, object_error ECOverride);\n  const std::string &getMessage() const { return Msg; }\n  void log(raw_ostream &OS) const override;\nprivate:\n  std::string Msg;\n};\n\n/// isNotObjectErrorInvalidFileType() is used when looping through the children\n/// of an archive after calling getAsBinary() on the child and it returns an\n/// llvm::Error.  In the cases we want to loop through the children and ignore the\n/// non-objects in the archive this is used to test the error to see if an\n/// error() function needs to called on the llvm::Error.\nError isNotObjectErrorInvalidFileType(llvm::Error Err);\n\n} // end namespace object.\n\n} // end namespace llvm.\n\nnamespace std {\ntemplate <>\nstruct is_error_code_enum<llvm::object::object_error> : std::true_type {};\n}\n\n#endif\n"}, "39": {"id": 39, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Object/MachO.h", "content": "//===- MachO.h - MachO object file implementation ---------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// This file declares the MachOObjectFile class, which implement the ObjectFile\n// interface for MachO files.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_OBJECT_MACHO_H\n#define LLVM_OBJECT_MACHO_H\n\n#include \"llvm/ADT/ArrayRef.h\"\n#include \"llvm/ADT/SmallString.h\"\n#include \"llvm/ADT/SmallVector.h\"\n#include \"llvm/ADT/StringExtras.h\"\n#include \"llvm/ADT/StringRef.h\"\n#include \"llvm/ADT/Triple.h\"\n#include \"llvm/ADT/iterator_range.h\"\n#include \"llvm/BinaryFormat/MachO.h\"\n#include \"llvm/MC/SubtargetFeature.h\"\n#include \"llvm/Object/Binary.h\"\n#include \"llvm/Object/ObjectFile.h\"\n#include \"llvm/Object/SymbolicFile.h\"\n#include \"llvm/Support/Error.h\"\n#include \"llvm/Support/Format.h\"\n#include \"llvm/Support/MemoryBuffer.h\"\n#include \"llvm/Support/raw_ostream.h\"\n#include <cstdint>\n#include <memory>\n#include <string>\n#include <system_error>\n\nnamespace llvm {\nnamespace object {\n\n/// DiceRef - This is a value type class that represents a single\n/// data in code entry in the table in a Mach-O object file.\nclass DiceRef {\n  DataRefImpl DicePimpl;\n  const ObjectFile *OwningObject = nullptr;\n\npublic:\n  DiceRef() = default;\n  DiceRef(DataRefImpl DiceP, const ObjectFile *Owner);\n\n  bool operator==(const DiceRef &Other) const;\n  bool operator<(const DiceRef &Other) const;\n\n  void moveNext();\n\n  std::error_code getOffset(uint32_t &Result) const;\n  std::error_code getLength(uint16_t &Result) const;\n  std::error_code getKind(uint16_t &Result) const;\n\n  DataRefImpl getRawDataRefImpl() const;\n  const ObjectFile *getObjectFile() const;\n};\nusing dice_iterator = content_iterator<DiceRef>;\n\n/// ExportEntry encapsulates the current-state-of-the-walk used when doing a\n/// non-recursive walk of the trie data structure.  This allows you to iterate\n/// across all exported symbols using:\n///      Error Err = Error::success();\n///      for (const llvm::object::ExportEntry &AnExport : Obj->exports(&Err)) {\n///      }\n///      if (Err) { report error ...\nclass ExportEntry {\npublic:\n  ExportEntry(Error *Err, const MachOObjectFile *O, ArrayRef<uint8_t> Trie);\n\n  StringRef name() const;\n  uint64_t flags() const;\n  uint64_t address() const;\n  uint64_t other() const;\n  StringRef otherName() const;\n  uint32_t nodeOffset() const;\n\n  bool operator==(const ExportEntry &) const;\n\n  void moveNext();\n\nprivate:\n  friend class MachOObjectFile;\n\n  void moveToFirst();\n  void moveToEnd();\n  uint64_t readULEB128(const uint8_t *&p, const char **error);\n  void pushDownUntilBottom();\n  void pushNode(uint64_t Offset);\n\n  // Represents a node in the mach-o exports trie.\n  struct NodeState {\n    NodeState(const uint8_t *Ptr);\n\n    const uint8_t *Start;\n    const uint8_t *Current;\n    uint64_t Flags = 0;\n    uint64_t Address = 0;\n    uint64_t Other = 0;\n    const char *ImportName = nullptr;\n    unsigned ChildCount = 0;\n    unsigned NextChildIndex = 0;\n    unsigned ParentStringLength = 0;\n    bool IsExportNode = false;\n  };\n  using NodeList = SmallVector<NodeState, 16>;\n  using node_iterator = NodeList::const_iterator;\n\n  Error *E;\n  const MachOObjectFile *O;\n  ArrayRef<uint8_t> Trie;\n  SmallString<256> CumulativeString;\n  NodeList Stack;\n  bool Done = false;\n\n  iterator_range<node_iterator> nodes() const {\n    return make_range(Stack.begin(), Stack.end());\n  }\n};\nusing export_iterator = content_iterator<ExportEntry>;\n\n// Segment info so SegIndex/SegOffset pairs in a Mach-O Bind or Rebase entry\n// can be checked and translated.  Only the SegIndex/SegOffset pairs from\n// checked entries are to be used with the segmentName(), sectionName() and\n// address() methods below.\nclass BindRebaseSegInfo {\npublic:\n  BindRebaseSegInfo(const MachOObjectFile *Obj);\n\n  // Used to check a Mach-O Bind or Rebase entry for errors when iterating.\n  const char* checkSegAndOffsets(int32_t SegIndex, uint64_t SegOffset,\n                                 uint8_t PointerSize, uint32_t Count=1,\n                                 uint32_t Skip=0);\n  // Used with valid SegIndex/SegOffset values from checked entries.\n  StringRef segmentName(int32_t SegIndex);\n  StringRef sectionName(int32_t SegIndex, uint64_t SegOffset);\n  uint64_t address(uint32_t SegIndex, uint64_t SegOffset);\n\nprivate:\n  struct SectionInfo {\n    uint64_t Address;\n    uint64_t Size;\n    StringRef SectionName;\n    StringRef SegmentName;\n    uint64_t OffsetInSegment;\n    uint64_t SegmentStartAddress;\n    int32_t SegmentIndex;\n  };\n  const SectionInfo &findSection(int32_t SegIndex, uint64_t SegOffset);\n\n  SmallVector<SectionInfo, 32> Sections;\n  int32_t MaxSegIndex;\n};\n\n/// MachORebaseEntry encapsulates the current state in the decompression of\n/// rebasing opcodes. This allows you to iterate through the compressed table of\n/// rebasing using:\n///    Error Err = Error::success();\n///    for (const llvm::object::MachORebaseEntry &Entry : Obj->rebaseTable(&Err)) {\n///    }\n///    if (Err) { report error ...\nclass MachORebaseEntry {\npublic:\n  MachORebaseEntry(Error *Err, const MachOObjectFile *O,\n                   ArrayRef<uint8_t> opcodes, bool is64Bit);\n\n  int32_t segmentIndex() const;\n  uint64_t segmentOffset() const;\n  StringRef typeName() const;\n  StringRef segmentName() const;\n  StringRef sectionName() const;\n  uint64_t address() const;\n\n  bool operator==(const MachORebaseEntry &) const;\n\n  void moveNext();\n\nprivate:\n  friend class MachOObjectFile;\n\n  void moveToFirst();\n  void moveToEnd();\n  uint64_t readULEB128(const char **error);\n\n  Error *E;\n  const MachOObjectFile *O;\n  ArrayRef<uint8_t> Opcodes;\n  const uint8_t *Ptr;\n  uint64_t SegmentOffset = 0;\n  int32_t SegmentIndex = -1;\n  uint64_t RemainingLoopCount = 0;\n  uint64_t AdvanceAmount = 0;\n  uint8_t  RebaseType = 0;\n  uint8_t  PointerSize;\n  bool     Done = false;\n};\nusing rebase_iterator = content_iterator<MachORebaseEntry>;\n\n/// MachOBindEntry encapsulates the current state in the decompression of\n/// binding opcodes. This allows you to iterate through the compressed table of\n/// bindings using:\n///    Error Err = Error::success();\n///    for (const llvm::object::MachOBindEntry &Entry : Obj->bindTable(&Err)) {\n///    }\n///    if (Err) { report error ...\nclass MachOBindEntry {\npublic:\n  enum class Kind { Regular, Lazy, Weak };\n\n  MachOBindEntry(Error *Err, const MachOObjectFile *O,\n                 ArrayRef<uint8_t> Opcodes, bool is64Bit, MachOBindEntry::Kind);\n\n  int32_t segmentIndex() const;\n  uint64_t segmentOffset() const;\n  StringRef typeName() const;\n  StringRef symbolName() const;\n  uint32_t flags() const;\n  int64_t addend() const;\n  int ordinal() const;\n\n  StringRef segmentName() const;\n  StringRef sectionName() const;\n  uint64_t address() const;\n\n  bool operator==(const MachOBindEntry &) const;\n\n  void moveNext();\n\nprivate:\n  friend class MachOObjectFile;\n\n  void moveToFirst();\n  void moveToEnd();\n  uint64_t readULEB128(const char **error);\n  int64_t readSLEB128(const char **error);\n\n  Error *E;\n  const MachOObjectFile *O;\n  ArrayRef<uint8_t> Opcodes;\n  const uint8_t *Ptr;\n  uint64_t SegmentOffset = 0;\n  int32_t  SegmentIndex = -1;\n  StringRef SymbolName;\n  bool     LibraryOrdinalSet = false;\n  int      Ordinal = 0;\n  uint32_t Flags = 0;\n  int64_t  Addend = 0;\n  uint64_t RemainingLoopCount = 0;\n  uint64_t AdvanceAmount = 0;\n  uint8_t  BindType = 0;\n  uint8_t  PointerSize;\n  Kind     TableKind;\n  bool     Done = false;\n};\nusing bind_iterator = content_iterator<MachOBindEntry>;\n\nclass MachOObjectFile : public ObjectFile {\npublic:\n  struct LoadCommandInfo {\n    const char *Ptr;      // Where in memory the load command is.\n    MachO::load_command C; // The command itself.\n  };\n  using LoadCommandList = SmallVector<LoadCommandInfo, 4>;\n  using load_command_iterator = LoadCommandList::const_iterator;\n\n  static Expected<std::unique_ptr<MachOObjectFile>>\n  create(MemoryBufferRef Object, bool IsLittleEndian, bool Is64Bits,\n         uint32_t UniversalCputype = 0, uint32_t UniversalIndex = 0);\n\n  void moveSymbolNext(DataRefImpl &Symb) const override;\n\n  uint64_t getNValue(DataRefImpl Sym) const;\n  Expected<StringRef> getSymbolName(DataRefImpl Symb) const override;\n\n  // MachO specific.\n  Error checkSymbolTable() const;\n\n  std::error_code getIndirectName(DataRefImpl Symb, StringRef &Res) const;\n  unsigned getSectionType(SectionRef Sec) const;\n\n  Expected<uint64_t> getSymbolAddress(DataRefImpl Symb) const override;\n  uint32_t getSymbolAlignment(DataRefImpl Symb) const override;\n  uint64_t getCommonSymbolSizeImpl(DataRefImpl Symb) const override;\n  Expected<SymbolRef::Type> getSymbolType(DataRefImpl Symb) const override;\n  Expected<uint32_t> getSymbolFlags(DataRefImpl Symb) const override;\n  Expected<section_iterator> getSymbolSection(DataRefImpl Symb) const override;\n  unsigned getSymbolSectionID(SymbolRef Symb) const;\n  unsigned getSectionID(SectionRef Sec) const;\n\n  void moveSectionNext(DataRefImpl &Sec) const override;\n  Expected<StringRef> getSectionName(DataRefImpl Sec) const override;\n  uint64_t getSectionAddress(DataRefImpl Sec) const override;\n  uint64_t getSectionIndex(DataRefImpl Sec) const override;\n  uint64_t getSectionSize(DataRefImpl Sec) const override;\n  ArrayRef<uint8_t> getSectionContents(uint32_t Offset, uint64_t Size) const;\n  Expected<ArrayRef<uint8_t>>\n  getSectionContents(DataRefImpl Sec) const override;\n  uint64_t getSectionAlignment(DataRefImpl Sec) const override;\n  Expected<SectionRef> getSection(unsigned SectionIndex) const;\n  Expected<SectionRef> getSection(StringRef SectionName) const;\n  bool isSectionCompressed(DataRefImpl Sec) const override;\n  bool isSectionText(DataRefImpl Sec) const override;\n  bool isSectionData(DataRefImpl Sec) const override;\n  bool isSectionBSS(DataRefImpl Sec) const override;\n  bool isSectionVirtual(DataRefImpl Sec) const override;\n  bool isSectionBitcode(DataRefImpl Sec) const override;\n  bool isDebugSection(StringRef SectionName) const override;\n\n  /// When dsymutil generates the companion file, it strips all unnecessary\n  /// sections (e.g. everything in the _TEXT segment) by omitting their body\n  /// and setting the offset in their corresponding load command to zero.\n  ///\n  /// While the load command itself is valid, reading the section corresponds\n  /// to reading the number of bytes specified in the load command, starting\n  /// from offset 0 (i.e. the Mach-O header at the beginning of the file).\n  bool isSectionStripped(DataRefImpl Sec) const override;\n\n  relocation_iterator section_rel_begin(DataRefImpl Sec) const override;\n  relocation_iterator section_rel_end(DataRefImpl Sec) const override;\n\n  relocation_iterator extrel_begin() const;\n  relocation_iterator extrel_end() const;\n  iterator_range<relocation_iterator> external_relocations() const {\n    return make_range(extrel_begin(), extrel_end());\n  }\n\n  relocation_iterator locrel_begin() const;\n  relocation_iterator locrel_end() const;\n\n  void moveRelocationNext(DataRefImpl &Rel) const override;\n  uint64_t getRelocationOffset(DataRefImpl Rel) const override;\n  symbol_iterator getRelocationSymbol(DataRefImpl Rel) const override;\n  section_iterator getRelocationSection(DataRefImpl Rel) const;\n  uint64_t getRelocationType(DataRefImpl Rel) const override;\n  void getRelocationTypeName(DataRefImpl Rel,\n                             SmallVectorImpl<char> &Result) const override;\n  uint8_t getRelocationLength(DataRefImpl Rel) const;\n\n  // MachO specific.\n  std::error_code getLibraryShortNameByIndex(unsigned Index, StringRef &) const;\n  uint32_t getLibraryCount() const;\n\n  section_iterator getRelocationRelocatedSection(relocation_iterator Rel) const;\n\n  // TODO: Would be useful to have an iterator based version\n  // of the load command interface too.\n\n  basic_symbol_iterator symbol_begin() const override;\n  basic_symbol_iterator symbol_end() const override;\n\n  // MachO specific.\n  symbol_iterator getSymbolByIndex(unsigned Index) const;\n  uint64_t getSymbolIndex(DataRefImpl Symb) const;\n\n  section_iterator section_begin() const override;\n  section_iterator section_end() const override;\n\n  uint8_t getBytesInAddress() const override;\n\n  StringRef getFileFormatName() const override;\n  Triple::ArchType getArch() const override;\n  SubtargetFeatures getFeatures() const override { return SubtargetFeatures(); }\n  Triple getArchTriple(const char **McpuDefault = nullptr) const;\n\n  relocation_iterator section_rel_begin(unsigned Index) const;\n  relocation_iterator section_rel_end(unsigned Index) const;\n\n  dice_iterator begin_dices() const;\n  dice_iterator end_dices() const;\n\n  load_command_iterator begin_load_commands() const;\n  load_command_iterator end_load_commands() const;\n  iterator_range<load_command_iterator> load_commands() const;\n\n  /// For use iterating over all exported symbols.\n  iterator_range<export_iterator> exports(Error &Err) const;\n\n  /// For use examining a trie not in a MachOObjectFile.\n  static iterator_range<export_iterator> exports(Error &Err,\n                                                 ArrayRef<uint8_t> Trie,\n                                                 const MachOObjectFile *O =\n                                                                      nullptr);\n\n  /// For use iterating over all rebase table entries.\n  iterator_range<rebase_iterator> rebaseTable(Error &Err);\n\n  /// For use examining rebase opcodes in a MachOObjectFile.\n  static iterator_range<rebase_iterator> rebaseTable(Error &Err,\n                                                     MachOObjectFile *O,\n                                                     ArrayRef<uint8_t> Opcodes,\n                                                     bool is64);\n\n  /// For use iterating over all bind table entries.\n  iterator_range<bind_iterator> bindTable(Error &Err);\n\n  /// For use iterating over all lazy bind table entries.\n  iterator_range<bind_iterator> lazyBindTable(Error &Err);\n\n  /// For use iterating over all weak bind table entries.\n  iterator_range<bind_iterator> weakBindTable(Error &Err);\n\n  /// For use examining bind opcodes in a MachOObjectFile.\n  static iterator_range<bind_iterator> bindTable(Error &Err,\n                                                 MachOObjectFile *O,\n                                                 ArrayRef<uint8_t> Opcodes,\n                                                 bool is64,\n                                                 MachOBindEntry::Kind);\n\n  // Given a SegIndex, SegOffset, and PointerSize, verify a valid section exists\n  // that fully contains a pointer at that location. Multiple fixups in a bind\n  // (such as with the BIND_OPCODE_DO_BIND_ULEB_TIMES_SKIPPING_ULEB opcode) can\n  // be tested via the Count and Skip parameters.\n  //\n  // This is used by MachOBindEntry::moveNext() to validate a MachOBindEntry.\n  const char *BindEntryCheckSegAndOffsets(int32_t SegIndex, uint64_t SegOffset,\n                                         uint8_t PointerSize, uint32_t Count=1,\n                                          uint32_t Skip=0) const {\n    return BindRebaseSectionTable->checkSegAndOffsets(SegIndex, SegOffset,\n                                                     PointerSize, Count, Skip);\n  }\n\n  // Given a SegIndex, SegOffset, and PointerSize, verify a valid section exists\n  // that fully contains a pointer at that location. Multiple fixups in a rebase\n  // (such as with the REBASE_OPCODE_DO_*_TIMES* opcodes) can be tested via the\n  // Count and Skip parameters.\n  //\n  // This is used by MachORebaseEntry::moveNext() to validate a MachORebaseEntry\n  const char *RebaseEntryCheckSegAndOffsets(int32_t SegIndex,\n                                            uint64_t SegOffset,\n                                            uint8_t PointerSize,\n                                            uint32_t Count=1,\n                                            uint32_t Skip=0) const {\n    return BindRebaseSectionTable->checkSegAndOffsets(SegIndex, SegOffset,\n                                                      PointerSize, Count, Skip);\n  }\n\n  /// For use with the SegIndex of a checked Mach-O Bind or Rebase entry to\n  /// get the segment name.\n  StringRef BindRebaseSegmentName(int32_t SegIndex) const {\n    return BindRebaseSectionTable->segmentName(SegIndex);\n  }\n\n  /// For use with a SegIndex,SegOffset pair from a checked Mach-O Bind or\n  /// Rebase entry to get the section name.\n  StringRef BindRebaseSectionName(uint32_t SegIndex, uint64_t SegOffset) const {\n    return BindRebaseSectionTable->sectionName(SegIndex, SegOffset);\n  }\n\n  /// For use with a SegIndex,SegOffset pair from a checked Mach-O Bind or\n  /// Rebase entry to get the address.\n  uint64_t BindRebaseAddress(uint32_t SegIndex, uint64_t SegOffset) const {\n    return BindRebaseSectionTable->address(SegIndex, SegOffset);\n  }\n\n  // In a MachO file, sections have a segment name. This is used in the .o\n  // files. They have a single segment, but this field specifies which segment\n  // a section should be put in the final object.\n  StringRef getSectionFinalSegmentName(DataRefImpl Sec) const;\n\n  // Names are stored as 16 bytes. These returns the raw 16 bytes without\n  // interpreting them as a C string.\n  ArrayRef<char> getSectionRawName(DataRefImpl Sec) const;\n  ArrayRef<char> getSectionRawFinalSegmentName(DataRefImpl Sec) const;\n\n  // MachO specific Info about relocations.\n  bool isRelocationScattered(const MachO::any_relocation_info &RE) const;\n  unsigned getPlainRelocationSymbolNum(\n                                    const MachO::any_relocation_info &RE) const;\n  bool getPlainRelocationExternal(const MachO::any_relocation_info &RE) const;\n  bool getScatteredRelocationScattered(\n                                    const MachO::any_relocation_info &RE) const;\n  uint32_t getScatteredRelocationValue(\n                                    const MachO::any_relocation_info &RE) const;\n  uint32_t getScatteredRelocationType(\n                                    const MachO::any_relocation_info &RE) const;\n  unsigned getAnyRelocationAddress(const MachO::any_relocation_info &RE) const;\n  unsigned getAnyRelocationPCRel(const MachO::any_relocation_info &RE) const;\n  unsigned getAnyRelocationLength(const MachO::any_relocation_info &RE) const;\n  unsigned getAnyRelocationType(const MachO::any_relocation_info &RE) const;\n  SectionRef getAnyRelocationSection(const MachO::any_relocation_info &RE) const;\n\n  // MachO specific structures.\n  MachO::section getSection(DataRefImpl DRI) const;\n  MachO::section_64 getSection64(DataRefImpl DRI) const;\n  MachO::section getSection(const LoadCommandInfo &L, unsigned Index) const;\n  MachO::section_64 getSection64(const LoadCommandInfo &L,unsigned Index) const;\n  MachO::nlist getSymbolTableEntry(DataRefImpl DRI) const;\n  MachO::nlist_64 getSymbol64TableEntry(DataRefImpl DRI) const;\n\n  MachO::linkedit_data_command\n  getLinkeditDataLoadCommand(const LoadCommandInfo &L) const;\n  MachO::segment_command\n  getSegmentLoadCommand(const LoadCommandInfo &L) const;\n  MachO::segment_command_64\n  getSegment64LoadCommand(const LoadCommandInfo &L) const;\n  MachO::linker_option_command\n  getLinkerOptionLoadCommand(const LoadCommandInfo &L) const;\n  MachO::version_min_command\n  getVersionMinLoadCommand(const LoadCommandInfo &L) const;\n  MachO::note_command\n  getNoteLoadCommand(const LoadCommandInfo &L) const;\n  MachO::build_version_command\n  getBuildVersionLoadCommand(const LoadCommandInfo &L) const;\n  MachO::build_tool_version\n  getBuildToolVersion(unsigned index) const;\n  MachO::dylib_command\n  getDylibIDLoadCommand(const LoadCommandInfo &L) const;\n  MachO::dyld_info_command\n  getDyldInfoLoadCommand(const LoadCommandInfo &L) const;\n  MachO::dylinker_command\n  getDylinkerCommand(const LoadCommandInfo &L) const;\n  MachO::uuid_command\n  getUuidCommand(const LoadCommandInfo &L) const;\n  MachO::rpath_command\n  getRpathCommand(const LoadCommandInfo &L) const;\n  MachO::source_version_command\n  getSourceVersionCommand(const LoadCommandInfo &L) const;\n  MachO::entry_point_command\n  getEntryPointCommand(const LoadCommandInfo &L) const;\n  MachO::encryption_info_command\n  getEncryptionInfoCommand(const LoadCommandInfo &L) const;\n  MachO::encryption_info_command_64\n  getEncryptionInfoCommand64(const LoadCommandInfo &L) const;\n  MachO::sub_framework_command\n  getSubFrameworkCommand(const LoadCommandInfo &L) const;\n  MachO::sub_umbrella_command\n  getSubUmbrellaCommand(const LoadCommandInfo &L) const;\n  MachO::sub_library_command\n  getSubLibraryCommand(const LoadCommandInfo &L) const;\n  MachO::sub_client_command\n  getSubClientCommand(const LoadCommandInfo &L) const;\n  MachO::routines_command\n  getRoutinesCommand(const LoadCommandInfo &L) const;\n  MachO::routines_command_64\n  getRoutinesCommand64(const LoadCommandInfo &L) const;\n  MachO::thread_command\n  getThreadCommand(const LoadCommandInfo &L) const;\n\n  MachO::any_relocation_info getRelocation(DataRefImpl Rel) const;\n  MachO::data_in_code_entry getDice(DataRefImpl Rel) const;\n  const MachO::mach_header &getHeader() const;\n  const MachO::mach_header_64 &getHeader64() const;\n  uint32_t\n  getIndirectSymbolTableEntry(const MachO::dysymtab_command &DLC,\n                              unsigned Index) const;\n  MachO::data_in_code_entry getDataInCodeTableEntry(uint32_t DataOffset,\n                                                    unsigned Index) const;\n  MachO::symtab_command getSymtabLoadCommand() const;\n  MachO::dysymtab_command getDysymtabLoadCommand() const;\n  MachO::linkedit_data_command getDataInCodeLoadCommand() const;\n  MachO::linkedit_data_command getLinkOptHintsLoadCommand() const;\n  ArrayRef<uint8_t> getDyldInfoRebaseOpcodes() const;\n  ArrayRef<uint8_t> getDyldInfoBindOpcodes() const;\n  ArrayRef<uint8_t> getDyldInfoWeakBindOpcodes() const;\n  ArrayRef<uint8_t> getDyldInfoLazyBindOpcodes() const;\n  ArrayRef<uint8_t> getDyldInfoExportsTrie() const;\n  ArrayRef<uint8_t> getUuid() const;\n\n  StringRef getStringTableData() const;\n  bool is64Bit() const;\n  void ReadULEB128s(uint64_t Index, SmallVectorImpl<uint64_t> &Out) const;\n\n  static StringRef guessLibraryShortName(StringRef Name, bool &isFramework,\n                                         StringRef &Suffix);\n\n  static Triple::ArchType getArch(uint32_t CPUType, uint32_t CPUSubType);\n  static Triple getArchTriple(uint32_t CPUType, uint32_t CPUSubType,\n                              const char **McpuDefault = nullptr,\n                              const char **ArchFlag = nullptr);\n  static bool isValidArch(StringRef ArchFlag);\n  static ArrayRef<StringRef> getValidArchs();\n  static Triple getHostArch();\n\n  bool isRelocatableObject() const override;\n\n  StringRef mapDebugSectionName(StringRef Name) const override;\n\n  bool hasPageZeroSegment() const { return HasPageZeroSegment; }\n\n  static bool classof(const Binary *v) {\n    return v->isMachO();\n  }\n\n  static uint32_t\n  getVersionMinMajor(MachO::version_min_command &C, bool SDK) {\n    uint32_t VersionOrSDK = (SDK) ? C.sdk : C.version;\n    return (VersionOrSDK >> 16) & 0xffff;\n  }\n\n  static uint32_t\n  getVersionMinMinor(MachO::version_min_command &C, bool SDK) {\n    uint32_t VersionOrSDK = (SDK) ? C.sdk : C.version;\n    return (VersionOrSDK >> 8) & 0xff;\n  }\n\n  static uint32_t\n  getVersionMinUpdate(MachO::version_min_command &C, bool SDK) {\n    uint32_t VersionOrSDK = (SDK) ? C.sdk : C.version;\n    return VersionOrSDK & 0xff;\n  }\n\n  static std::string getBuildPlatform(uint32_t platform) {\n    switch (platform) {\n    case MachO::PLATFORM_MACOS: return \"macos\";\n    case MachO::PLATFORM_IOS: return \"ios\";\n    case MachO::PLATFORM_TVOS: return \"tvos\";\n    case MachO::PLATFORM_WATCHOS: return \"watchos\";\n    case MachO::PLATFORM_BRIDGEOS: return \"bridgeos\";\n    case MachO::PLATFORM_MACCATALYST: return \"macCatalyst\";\n    case MachO::PLATFORM_IOSSIMULATOR: return \"iossimulator\";\n    case MachO::PLATFORM_TVOSSIMULATOR: return \"tvossimulator\";\n    case MachO::PLATFORM_WATCHOSSIMULATOR: return \"watchossimulator\";\n    case MachO::PLATFORM_DRIVERKIT: return \"driverkit\";\n    default:\n      std::string ret;\n      raw_string_ostream ss(ret);\n      ss << format_hex(platform, 8, true);\n      return ss.str();\n    }\n  }\n\n  static std::string getBuildTool(uint32_t tools) {\n    switch (tools) {\n    case MachO::TOOL_CLANG: return \"clang\";\n    case MachO::TOOL_SWIFT: return \"swift\";\n    case MachO::TOOL_LD: return \"ld\";\n    default:\n      std::string ret;\n      raw_string_ostream ss(ret);\n      ss << format_hex(tools, 8, true);\n      return ss.str();\n    }\n  }\n\n  static std::string getVersionString(uint32_t version) {\n    uint32_t major = (version >> 16) & 0xffff;\n    uint32_t minor = (version >> 8) & 0xff;\n    uint32_t update = version & 0xff;\n\n    SmallString<32> Version;\n    Version = utostr(major) + \".\" + utostr(minor);\n    if (update != 0)\n      Version += \".\" + utostr(update);\n    return std::string(std::string(Version.str()));\n  }\n\nprivate:\n  MachOObjectFile(MemoryBufferRef Object, bool IsLittleEndian, bool Is64Bits,\n                  Error &Err, uint32_t UniversalCputype = 0,\n                  uint32_t UniversalIndex = 0);\n\n  uint64_t getSymbolValueImpl(DataRefImpl Symb) const override;\n\n  union {\n    MachO::mach_header_64 Header64;\n    MachO::mach_header Header;\n  };\n  using SectionList = SmallVector<const char*, 1>;\n  SectionList Sections;\n  using LibraryList = SmallVector<const char*, 1>;\n  LibraryList Libraries;\n  LoadCommandList LoadCommands;\n  using LibraryShortName = SmallVector<StringRef, 1>;\n  using BuildToolList = SmallVector<const char*, 1>;\n  BuildToolList BuildTools;\n  mutable LibraryShortName LibrariesShortNames;\n  std::unique_ptr<BindRebaseSegInfo> BindRebaseSectionTable;\n  const char *SymtabLoadCmd = nullptr;\n  const char *DysymtabLoadCmd = nullptr;\n  const char *DataInCodeLoadCmd = nullptr;\n  const char *LinkOptHintsLoadCmd = nullptr;\n  const char *DyldInfoLoadCmd = nullptr;\n  const char *UuidLoadCmd = nullptr;\n  bool HasPageZeroSegment = false;\n};\n\n/// DiceRef\ninline DiceRef::DiceRef(DataRefImpl DiceP, const ObjectFile *Owner)\n  : DicePimpl(DiceP) , OwningObject(Owner) {}\n\ninline bool DiceRef::operator==(const DiceRef &Other) const {\n  return DicePimpl == Other.DicePimpl;\n}\n\ninline bool DiceRef::operator<(const DiceRef &Other) const {\n  return DicePimpl < Other.DicePimpl;\n}\n\ninline void DiceRef::moveNext() {\n  const MachO::data_in_code_entry *P =\n    reinterpret_cast<const MachO::data_in_code_entry *>(DicePimpl.p);\n  DicePimpl.p = reinterpret_cast<uintptr_t>(P + 1);\n}\n\n// Since a Mach-O data in code reference, a DiceRef, can only be created when\n// the OwningObject ObjectFile is a MachOObjectFile a static_cast<> is used for\n// the methods that get the values of the fields of the reference.\n\ninline std::error_code DiceRef::getOffset(uint32_t &Result) const {\n  const MachOObjectFile *MachOOF =\n    static_cast<const MachOObjectFile *>(OwningObject);\n  MachO::data_in_code_entry Dice = MachOOF->getDice(DicePimpl);\n  Result = Dice.offset;\n  return std::error_code();\n}\n\ninline std::error_code DiceRef::getLength(uint16_t &Result) const {\n  const MachOObjectFile *MachOOF =\n    static_cast<const MachOObjectFile *>(OwningObject);\n  MachO::data_in_code_entry Dice = MachOOF->getDice(DicePimpl);\n  Result = Dice.length;\n  return std::error_code();\n}\n\ninline std::error_code DiceRef::getKind(uint16_t &Result) const {\n  const MachOObjectFile *MachOOF =\n    static_cast<const MachOObjectFile *>(OwningObject);\n  MachO::data_in_code_entry Dice = MachOOF->getDice(DicePimpl);\n  Result = Dice.kind;\n  return std::error_code();\n}\n\ninline DataRefImpl DiceRef::getRawDataRefImpl() const {\n  return DicePimpl;\n}\n\ninline const ObjectFile *DiceRef::getObjectFile() const {\n  return OwningObject;\n}\n\n} // end namespace object\n} // end namespace llvm\n\n#endif // LLVM_OBJECT_MACHO_H\n"}, "40": {"id": 40, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Object/ObjectFile.h", "content": "//===- ObjectFile.h - File format independent object file -------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// This file declares a file format independent ObjectFile class.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_OBJECT_OBJECTFILE_H\n#define LLVM_OBJECT_OBJECTFILE_H\n\n#include \"llvm/ADT/DenseMapInfo.h\"\n#include \"llvm/ADT/StringRef.h\"\n#include \"llvm/ADT/Triple.h\"\n#include \"llvm/ADT/iterator_range.h\"\n#include \"llvm/BinaryFormat/Magic.h\"\n#include \"llvm/Object/Binary.h\"\n#include \"llvm/Object/Error.h\"\n#include \"llvm/Object/SymbolicFile.h\"\n#include \"llvm/Support/Casting.h\"\n#include \"llvm/Support/Error.h\"\n#include \"llvm/Support/MemoryBuffer.h\"\n#include <cassert>\n#include <cstdint>\n#include <memory>\n#include <system_error>\n\nnamespace llvm {\n\nclass ARMAttributeParser;\nclass SubtargetFeatures;\n\nnamespace object {\n\nclass COFFObjectFile;\nclass MachOObjectFile;\nclass ObjectFile;\nclass SectionRef;\nclass SymbolRef;\nclass symbol_iterator;\nclass WasmObjectFile;\n\nusing section_iterator = content_iterator<SectionRef>;\n\n/// This is a value type class that represents a single relocation in the list\n/// of relocations in the object file.\nclass RelocationRef {\n  DataRefImpl RelocationPimpl;\n  const ObjectFile *OwningObject = nullptr;\n\npublic:\n  RelocationRef() = default;\n  RelocationRef(DataRefImpl RelocationP, const ObjectFile *Owner);\n\n  bool operator==(const RelocationRef &Other) const;\n\n  void moveNext();\n\n  uint64_t getOffset() const;\n  symbol_iterator getSymbol() const;\n  uint64_t getType() const;\n\n  /// Get a string that represents the type of this relocation.\n  ///\n  /// This is for display purposes only.\n  void getTypeName(SmallVectorImpl<char> &Result) const;\n\n  DataRefImpl getRawDataRefImpl() const;\n  const ObjectFile *getObject() const;\n};\n\nusing relocation_iterator = content_iterator<RelocationRef>;\n\n/// This is a value type class that represents a single section in the list of\n/// sections in the object file.\nclass SectionRef {\n  friend class SymbolRef;\n\n  DataRefImpl SectionPimpl;\n  const ObjectFile *OwningObject = nullptr;\n\npublic:\n  SectionRef() = default;\n  SectionRef(DataRefImpl SectionP, const ObjectFile *Owner);\n\n  bool operator==(const SectionRef &Other) const;\n  bool operator!=(const SectionRef &Other) const;\n  bool operator<(const SectionRef &Other) const;\n\n  void moveNext();\n\n  Expected<StringRef> getName() const;\n  uint64_t getAddress() const;\n  uint64_t getIndex() const;\n  uint64_t getSize() const;\n  Expected<StringRef> getContents() const;\n\n  /// Get the alignment of this section as the actual value (not log 2).\n  uint64_t getAlignment() const;\n\n  bool isCompressed() const;\n  /// Whether this section contains instructions.\n  bool isText() const;\n  /// Whether this section contains data, not instructions.\n  bool isData() const;\n  /// Whether this section contains BSS uninitialized data.\n  bool isBSS() const;\n  bool isVirtual() const;\n  bool isBitcode() const;\n  bool isStripped() const;\n\n  /// Whether this section will be placed in the text segment, according to the\n  /// Berkeley size format. This is true if the section is allocatable, and\n  /// contains either code or readonly data.\n  bool isBerkeleyText() const;\n  /// Whether this section will be placed in the data segment, according to the\n  /// Berkeley size format. This is true if the section is allocatable and\n  /// contains data (e.g. PROGBITS), but is not text.\n  bool isBerkeleyData() const;\n\n  /// Whether this section is a debug section.\n  bool isDebugSection(StringRef SectionName) const;\n\n  bool containsSymbol(SymbolRef S) const;\n\n  relocation_iterator relocation_begin() const;\n  relocation_iterator relocation_end() const;\n  iterator_range<relocation_iterator> relocations() const {\n    return make_range(relocation_begin(), relocation_end());\n  }\n  Expected<section_iterator> getRelocatedSection() const;\n\n  DataRefImpl getRawDataRefImpl() const;\n  const ObjectFile *getObject() const;\n};\n\nstruct SectionedAddress {\n  const static uint64_t UndefSection = UINT64_MAX;\n\n  uint64_t Address = 0;\n  uint64_t SectionIndex = UndefSection;\n};\n\ninline bool operator<(const SectionedAddress &LHS,\n                      const SectionedAddress &RHS) {\n  return std::tie(LHS.SectionIndex, LHS.Address) <\n         std::tie(RHS.SectionIndex, RHS.Address);\n}\n\ninline bool operator==(const SectionedAddress &LHS,\n                       const SectionedAddress &RHS) {\n  return std::tie(LHS.SectionIndex, LHS.Address) ==\n         std::tie(RHS.SectionIndex, RHS.Address);\n}\n\nraw_ostream &operator<<(raw_ostream &OS, const SectionedAddress &Addr);\n\n/// This is a value type class that represents a single symbol in the list of\n/// symbols in the object file.\nclass SymbolRef : public BasicSymbolRef {\n  friend class SectionRef;\n\npublic:\n  enum Type {\n    ST_Unknown, // Type not specified\n    ST_Data,\n    ST_Debug,\n    ST_File,\n    ST_Function,\n    ST_Other\n  };\n\n  SymbolRef() = default;\n  SymbolRef(DataRefImpl SymbolP, const ObjectFile *Owner);\n  SymbolRef(const BasicSymbolRef &B) : BasicSymbolRef(B) {\n    assert(isa<ObjectFile>(BasicSymbolRef::getObject()));\n  }\n\n  Expected<StringRef> getName() const;\n  /// Returns the symbol virtual address (i.e. address at which it will be\n  /// mapped).\n  Expected<uint64_t> getAddress() const;\n\n  /// Return the value of the symbol depending on the object this can be an\n  /// offset or a virtual address.\n  Expected<uint64_t> getValue() const;\n\n  /// Get the alignment of this symbol as the actual value (not log 2).\n  uint32_t getAlignment() const;\n  uint64_t getCommonSize() const;\n  Expected<SymbolRef::Type> getType() const;\n\n  /// Get section this symbol is defined in reference to. Result is\n  /// end_sections() if it is undefined or is an absolute symbol.\n  Expected<section_iterator> getSection() const;\n\n  const ObjectFile *getObject() const;\n};\n\nclass symbol_iterator : public basic_symbol_iterator {\npublic:\n  symbol_iterator(SymbolRef Sym) : basic_symbol_iterator(Sym) {}\n  symbol_iterator(const basic_symbol_iterator &B)\n      : basic_symbol_iterator(SymbolRef(B->getRawDataRefImpl(),\n                                        cast<ObjectFile>(B->getObject()))) {}\n\n  const SymbolRef *operator->() const {\n    const BasicSymbolRef &P = basic_symbol_iterator::operator *();\n    return static_cast<const SymbolRef*>(&P);\n  }\n\n  const SymbolRef &operator*() const {\n    const BasicSymbolRef &P = basic_symbol_iterator::operator *();\n    return static_cast<const SymbolRef&>(P);\n  }\n};\n\n/// This class is the base class for all object file types. Concrete instances\n/// of this object are created by createObjectFile, which figures out which type\n/// to create.\nclass ObjectFile : public SymbolicFile {\n  virtual void anchor();\n\nprotected:\n  ObjectFile(unsigned int Type, MemoryBufferRef Source);\n\n  const uint8_t *base() const {\n    return reinterpret_cast<const uint8_t *>(Data.getBufferStart());\n  }\n\n  // These functions are for SymbolRef to call internally. The main goal of\n  // this is to allow SymbolRef::SymbolPimpl to point directly to the symbol\n  // entry in the memory mapped object file. SymbolPimpl cannot contain any\n  // virtual functions because then it could not point into the memory mapped\n  // file.\n  //\n  // Implementations assume that the DataRefImpl is valid and has not been\n  // modified externally. It's UB otherwise.\n  friend class SymbolRef;\n\n  virtual Expected<StringRef> getSymbolName(DataRefImpl Symb) const = 0;\n  Error printSymbolName(raw_ostream &OS,\n                                  DataRefImpl Symb) const override;\n  virtual Expected<uint64_t> getSymbolAddress(DataRefImpl Symb) const = 0;\n  virtual uint64_t getSymbolValueImpl(DataRefImpl Symb) const = 0;\n  virtual uint32_t getSymbolAlignment(DataRefImpl Symb) const;\n  virtual uint64_t getCommonSymbolSizeImpl(DataRefImpl Symb) const = 0;\n  virtual Expected<SymbolRef::Type> getSymbolType(DataRefImpl Symb) const = 0;\n  virtual Expected<section_iterator>\n  getSymbolSection(DataRefImpl Symb) const = 0;\n\n  // Same as above for SectionRef.\n  friend class SectionRef;\n\n  virtual void moveSectionNext(DataRefImpl &Sec) const = 0;\n  virtual Expected<StringRef> getSectionName(DataRefImpl Sec) const = 0;\n  virtual uint64_t getSectionAddress(DataRefImpl Sec) const = 0;\n  virtual uint64_t getSectionIndex(DataRefImpl Sec) const = 0;\n  virtual uint64_t getSectionSize(DataRefImpl Sec) const = 0;\n  virtual Expected<ArrayRef<uint8_t>>\n  getSectionContents(DataRefImpl Sec) const = 0;\n  virtual uint64_t getSectionAlignment(DataRefImpl Sec) const = 0;\n  virtual bool isSectionCompressed(DataRefImpl Sec) const = 0;\n  virtual bool isSectionText(DataRefImpl Sec) const = 0;\n  virtual bool isSectionData(DataRefImpl Sec) const = 0;\n  virtual bool isSectionBSS(DataRefImpl Sec) const = 0;\n  // A section is 'virtual' if its contents aren't present in the object image.\n  virtual bool isSectionVirtual(DataRefImpl Sec) const = 0;\n  virtual bool isSectionBitcode(DataRefImpl Sec) const;\n  virtual bool isSectionStripped(DataRefImpl Sec) const;\n  virtual bool isBerkeleyText(DataRefImpl Sec) const;\n  virtual bool isBerkeleyData(DataRefImpl Sec) const;\n  virtual bool isDebugSection(StringRef SectionName) const;\n  virtual relocation_iterator section_rel_begin(DataRefImpl Sec) const = 0;\n  virtual relocation_iterator section_rel_end(DataRefImpl Sec) const = 0;\n  virtual Expected<section_iterator> getRelocatedSection(DataRefImpl Sec) const;\n\n  // Same as above for RelocationRef.\n  friend class RelocationRef;\n  virtual void moveRelocationNext(DataRefImpl &Rel) const = 0;\n  virtual uint64_t getRelocationOffset(DataRefImpl Rel) const = 0;\n  virtual symbol_iterator getRelocationSymbol(DataRefImpl Rel) const = 0;\n  virtual uint64_t getRelocationType(DataRefImpl Rel) const = 0;\n  virtual void getRelocationTypeName(DataRefImpl Rel,\n                                     SmallVectorImpl<char> &Result) const = 0;\n\n  Expected<uint64_t> getSymbolValue(DataRefImpl Symb) const;\n\npublic:\n  ObjectFile() = delete;\n  ObjectFile(const ObjectFile &other) = delete;\n\n  uint64_t getCommonSymbolSize(DataRefImpl Symb) const {\n    Expected<uint32_t> SymbolFlagsOrErr = getSymbolFlags(Symb);\n    if (!SymbolFlagsOrErr)\n      // TODO: Actually report errors helpfully.\n      report_fatal_error(SymbolFlagsOrErr.takeError());\n    assert(*SymbolFlagsOrErr & SymbolRef::SF_Common);\n    return getCommonSymbolSizeImpl(Symb);\n  }\n\n  virtual std::vector<SectionRef> dynamic_relocation_sections() const {\n    return std::vector<SectionRef>();\n  }\n\n  using symbol_iterator_range = iterator_range<symbol_iterator>;\n  symbol_iterator_range symbols() const {\n    return symbol_iterator_range(symbol_begin(), symbol_end());\n  }\n\n  virtual section_iterator section_begin() const = 0;\n  virtual section_iterator section_end() const = 0;\n\n  using section_iterator_range = iterator_range<section_iterator>;\n  section_iterator_range sections() const {\n    return section_iterator_range(section_begin(), section_end());\n  }\n\n  /// The number of bytes used to represent an address in this object\n  ///        file format.\n  virtual uint8_t getBytesInAddress() const = 0;\n\n  virtual StringRef getFileFormatName() const = 0;\n  virtual Triple::ArchType getArch() const = 0;\n  virtual SubtargetFeatures getFeatures() const = 0;\n  virtual Optional<StringRef> tryGetCPUName() const { return None; };\n  virtual void setARMSubArch(Triple &TheTriple) const { }\n  virtual Expected<uint64_t> getStartAddress() const {\n    return errorCodeToError(object_error::parse_failed);\n  };\n\n  /// Create a triple from the data in this object file.\n  Triple makeTriple() const;\n\n  /// Maps a debug section name to a standard DWARF section name.\n  virtual StringRef mapDebugSectionName(StringRef Name) const { return Name; }\n\n  /// True if this is a relocatable object (.o/.obj).\n  virtual bool isRelocatableObject() const = 0;\n\n  /// @returns Pointer to ObjectFile subclass to handle this type of object.\n  /// @param ObjectPath The path to the object file. ObjectPath.isObject must\n  ///        return true.\n  /// Create ObjectFile from path.\n  static Expected<OwningBinary<ObjectFile>>\n  createObjectFile(StringRef ObjectPath);\n\n  static Expected<std::unique_ptr<ObjectFile>>\n  createObjectFile(MemoryBufferRef Object, llvm::file_magic Type,\n                   bool InitContent = true);\n  static Expected<std::unique_ptr<ObjectFile>>\n  createObjectFile(MemoryBufferRef Object) {\n    return createObjectFile(Object, llvm::file_magic::unknown);\n  }\n\n  static bool classof(const Binary *v) {\n    return v->isObject();\n  }\n\n  static Expected<std::unique_ptr<COFFObjectFile>>\n  createCOFFObjectFile(MemoryBufferRef Object);\n\n  static Expected<std::unique_ptr<ObjectFile>>\n  createXCOFFObjectFile(MemoryBufferRef Object, unsigned FileType);\n\n  static Expected<std::unique_ptr<ObjectFile>>\n  createELFObjectFile(MemoryBufferRef Object, bool InitContent = true);\n\n  static Expected<std::unique_ptr<MachOObjectFile>>\n  createMachOObjectFile(MemoryBufferRef Object,\n                        uint32_t UniversalCputype = 0,\n                        uint32_t UniversalIndex = 0);\n\n  static Expected<std::unique_ptr<WasmObjectFile>>\n  createWasmObjectFile(MemoryBufferRef Object);\n};\n\n// Inline function definitions.\ninline SymbolRef::SymbolRef(DataRefImpl SymbolP, const ObjectFile *Owner)\n    : BasicSymbolRef(SymbolP, Owner) {}\n\ninline Expected<StringRef> SymbolRef::getName() const {\n  return getObject()->getSymbolName(getRawDataRefImpl());\n}\n\ninline Expected<uint64_t> SymbolRef::getAddress() const {\n  return getObject()->getSymbolAddress(getRawDataRefImpl());\n}\n\ninline Expected<uint64_t> SymbolRef::getValue() const {\n  return getObject()->getSymbolValue(getRawDataRefImpl());\n}\n\ninline uint32_t SymbolRef::getAlignment() const {\n  return getObject()->getSymbolAlignment(getRawDataRefImpl());\n}\n\ninline uint64_t SymbolRef::getCommonSize() const {\n  return getObject()->getCommonSymbolSize(getRawDataRefImpl());\n}\n\ninline Expected<section_iterator> SymbolRef::getSection() const {\n  return getObject()->getSymbolSection(getRawDataRefImpl());\n}\n\ninline Expected<SymbolRef::Type> SymbolRef::getType() const {\n  return getObject()->getSymbolType(getRawDataRefImpl());\n}\n\ninline const ObjectFile *SymbolRef::getObject() const {\n  const SymbolicFile *O = BasicSymbolRef::getObject();\n  return cast<ObjectFile>(O);\n}\n\n/// SectionRef\ninline SectionRef::SectionRef(DataRefImpl SectionP,\n                              const ObjectFile *Owner)\n  : SectionPimpl(SectionP)\n  , OwningObject(Owner) {}\n\ninline bool SectionRef::operator==(const SectionRef &Other) const {\n  return OwningObject == Other.OwningObject &&\n         SectionPimpl == Other.SectionPimpl;\n}\n\ninline bool SectionRef::operator!=(const SectionRef &Other) const {\n  return !(*this == Other);\n}\n\ninline bool SectionRef::operator<(const SectionRef &Other) const {\n  assert(OwningObject == Other.OwningObject);\n  return SectionPimpl < Other.SectionPimpl;\n}\n\ninline void SectionRef::moveNext() {\n  return OwningObject->moveSectionNext(SectionPimpl);\n}\n\ninline Expected<StringRef> SectionRef::getName() const {\n  return OwningObject->getSectionName(SectionPimpl);\n}\n\ninline uint64_t SectionRef::getAddress() const {\n  return OwningObject->getSectionAddress(SectionPimpl);\n}\n\ninline uint64_t SectionRef::getIndex() const {\n  return OwningObject->getSectionIndex(SectionPimpl);\n}\n\ninline uint64_t SectionRef::getSize() const {\n  return OwningObject->getSectionSize(SectionPimpl);\n}\n\ninline Expected<StringRef> SectionRef::getContents() const {\n  Expected<ArrayRef<uint8_t>> Res =\n      OwningObject->getSectionContents(SectionPimpl);\n  if (!Res)\n    return Res.takeError();\n  return StringRef(reinterpret_cast<const char *>(Res->data()), Res->size());\n}\n\ninline uint64_t SectionRef::getAlignment() const {\n  return OwningObject->getSectionAlignment(SectionPimpl);\n}\n\ninline bool SectionRef::isCompressed() const {\n  return OwningObject->isSectionCompressed(SectionPimpl);\n}\n\ninline bool SectionRef::isText() const {\n  return OwningObject->isSectionText(SectionPimpl);\n}\n\ninline bool SectionRef::isData() const {\n  return OwningObject->isSectionData(SectionPimpl);\n}\n\ninline bool SectionRef::isBSS() const {\n  return OwningObject->isSectionBSS(SectionPimpl);\n}\n\ninline bool SectionRef::isVirtual() const {\n  return OwningObject->isSectionVirtual(SectionPimpl);\n}\n\ninline bool SectionRef::isBitcode() const {\n  return OwningObject->isSectionBitcode(SectionPimpl);\n}\n\ninline bool SectionRef::isStripped() const {\n  return OwningObject->isSectionStripped(SectionPimpl);\n}\n\ninline bool SectionRef::isBerkeleyText() const {\n  return OwningObject->isBerkeleyText(SectionPimpl);\n}\n\ninline bool SectionRef::isBerkeleyData() const {\n  return OwningObject->isBerkeleyData(SectionPimpl);\n}\n\ninline bool SectionRef::isDebugSection(StringRef SectionName) const {\n  return OwningObject->isDebugSection(SectionName);\n}\n\ninline relocation_iterator SectionRef::relocation_begin() const {\n  return OwningObject->section_rel_begin(SectionPimpl);\n}\n\ninline relocation_iterator SectionRef::relocation_end() const {\n  return OwningObject->section_rel_end(SectionPimpl);\n}\n\ninline Expected<section_iterator> SectionRef::getRelocatedSection() const {\n  return OwningObject->getRelocatedSection(SectionPimpl);\n}\n\ninline DataRefImpl SectionRef::getRawDataRefImpl() const {\n  return SectionPimpl;\n}\n\ninline const ObjectFile *SectionRef::getObject() const {\n  return OwningObject;\n}\n\n/// RelocationRef\ninline RelocationRef::RelocationRef(DataRefImpl RelocationP,\n                              const ObjectFile *Owner)\n  : RelocationPimpl(RelocationP)\n  , OwningObject(Owner) {}\n\ninline bool RelocationRef::operator==(const RelocationRef &Other) const {\n  return RelocationPimpl == Other.RelocationPimpl;\n}\n\ninline void RelocationRef::moveNext() {\n  return OwningObject->moveRelocationNext(RelocationPimpl);\n}\n\ninline uint64_t RelocationRef::getOffset() const {\n  return OwningObject->getRelocationOffset(RelocationPimpl);\n}\n\ninline symbol_iterator RelocationRef::getSymbol() const {\n  return OwningObject->getRelocationSymbol(RelocationPimpl);\n}\n\ninline uint64_t RelocationRef::getType() const {\n  return OwningObject->getRelocationType(RelocationPimpl);\n}\n\ninline void RelocationRef::getTypeName(SmallVectorImpl<char> &Result) const {\n  return OwningObject->getRelocationTypeName(RelocationPimpl, Result);\n}\n\ninline DataRefImpl RelocationRef::getRawDataRefImpl() const {\n  return RelocationPimpl;\n}\n\ninline const ObjectFile *RelocationRef::getObject() const {\n  return OwningObject;\n}\n\n} // end namespace object\n\ntemplate <> struct DenseMapInfo<object::SectionRef> {\n  static bool isEqual(const object::SectionRef &A,\n                      const object::SectionRef &B) {\n    return A == B;\n  }\n  static object::SectionRef getEmptyKey() {\n    return object::SectionRef({}, nullptr);\n  }\n  static object::SectionRef getTombstoneKey() {\n    object::DataRefImpl TS;\n    TS.p = (uintptr_t)-1;\n    return object::SectionRef(TS, nullptr);\n  }\n  static unsigned getHashValue(const object::SectionRef &Sec) {\n    object::DataRefImpl Raw = Sec.getRawDataRefImpl();\n    return hash_combine(Raw.p, Raw.d.a, Raw.d.b);\n  }\n};\n\n} // end namespace llvm\n\n#endif // LLVM_OBJECT_OBJECTFILE_H\n"}, "41": {"id": 41, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Object/SymbolicFile.h", "content": "//===- SymbolicFile.h - Interface that only provides symbols ----*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// This file declares the SymbolicFile interface.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_OBJECT_SYMBOLICFILE_H\n#define LLVM_OBJECT_SYMBOLICFILE_H\n\n#include \"llvm/ADT/StringRef.h\"\n#include \"llvm/ADT/iterator_range.h\"\n#include \"llvm/BinaryFormat/Magic.h\"\n#include \"llvm/Object/Binary.h\"\n#include \"llvm/Support/Error.h\"\n#include \"llvm/Support/Format.h\"\n#include \"llvm/Support/MemoryBuffer.h\"\n#include <cinttypes>\n#include <cstdint>\n#include <cstring>\n#include <iterator>\n#include <memory>\n#include <system_error>\n\nnamespace llvm {\nnamespace object {\n\nunion DataRefImpl {\n  // This entire union should probably be a\n  // char[max(8, sizeof(uintptr_t))] and require the impl to cast.\n  struct {\n    uint32_t a, b;\n  } d;\n  uintptr_t p;\n\n  DataRefImpl() { std::memset(this, 0, sizeof(DataRefImpl)); }\n};\n\ntemplate <typename OStream>\nOStream& operator<<(OStream &OS, const DataRefImpl &D) {\n  OS << \"(\" << format(\"0x%08\" PRIxPTR, D.p) << \" (\" << format(\"0x%08x\", D.d.a)\n     << \", \" << format(\"0x%08x\", D.d.b) << \"))\";\n  return OS;\n}\n\ninline bool operator==(const DataRefImpl &a, const DataRefImpl &b) {\n  // Check bitwise identical. This is the only legal way to compare a union w/o\n  // knowing which member is in use.\n  return std::memcmp(&a, &b, sizeof(DataRefImpl)) == 0;\n}\n\ninline bool operator!=(const DataRefImpl &a, const DataRefImpl &b) {\n  return !operator==(a, b);\n}\n\ninline bool operator<(const DataRefImpl &a, const DataRefImpl &b) {\n  // Check bitwise identical. This is the only legal way to compare a union w/o\n  // knowing which member is in use.\n  return std::memcmp(&a, &b, sizeof(DataRefImpl)) < 0;\n}\n\ntemplate <class content_type>\nclass content_iterator\n    : public std::iterator<std::forward_iterator_tag, content_type> {\n  content_type Current;\n\npublic:\n  content_iterator(content_type symb) : Current(std::move(symb)) {}\n\n  const content_type *operator->() const { return &Current; }\n\n  const content_type &operator*() const { return Current; }\n\n  bool operator==(const content_iterator &other) const {\n    return Current == other.Current;\n  }\n\n  bool operator!=(const content_iterator &other) const {\n    return !(*this == other);\n  }\n\n  content_iterator &operator++() { // preincrement\n    Current.moveNext();\n    return *this;\n  }\n};\n\nclass SymbolicFile;\n\n/// This is a value type class that represents a single symbol in the list of\n/// symbols in the object file.\nclass BasicSymbolRef {\n  DataRefImpl SymbolPimpl;\n  const SymbolicFile *OwningObject = nullptr;\n\npublic:\n  enum Flags : unsigned {\n    SF_None = 0,\n    SF_Undefined = 1U << 0,      // Symbol is defined in another object file\n    SF_Global = 1U << 1,         // Global symbol\n    SF_Weak = 1U << 2,           // Weak symbol\n    SF_Absolute = 1U << 3,       // Absolute symbol\n    SF_Common = 1U << 4,         // Symbol has common linkage\n    SF_Indirect = 1U << 5,       // Symbol is an alias to another symbol\n    SF_Exported = 1U << 6,       // Symbol is visible to other DSOs\n    SF_FormatSpecific = 1U << 7, // Specific to the object file format\n                                 // (e.g. section symbols)\n    SF_Thumb = 1U << 8,          // Thumb symbol in a 32-bit ARM binary\n    SF_Hidden = 1U << 9,         // Symbol has hidden visibility\n    SF_Const = 1U << 10,         // Symbol value is constant\n    SF_Executable = 1U << 11,    // Symbol points to an executable section\n                                 // (IR only)\n  };\n\n  BasicSymbolRef() = default;\n  BasicSymbolRef(DataRefImpl SymbolP, const SymbolicFile *Owner);\n\n  bool operator==(const BasicSymbolRef &Other) const;\n  bool operator<(const BasicSymbolRef &Other) const;\n\n  void moveNext();\n\n  Error printName(raw_ostream &OS) const;\n\n  /// Get symbol flags (bitwise OR of SymbolRef::Flags)\n  Expected<uint32_t> getFlags() const;\n\n  DataRefImpl getRawDataRefImpl() const;\n  const SymbolicFile *getObject() const;\n};\n\nusing basic_symbol_iterator = content_iterator<BasicSymbolRef>;\n\nclass SymbolicFile : public Binary {\npublic:\n  SymbolicFile(unsigned int Type, MemoryBufferRef Source);\n  ~SymbolicFile() override;\n\n  // virtual interface.\n  virtual void moveSymbolNext(DataRefImpl &Symb) const = 0;\n\n  virtual Error printSymbolName(raw_ostream &OS, DataRefImpl Symb) const = 0;\n\n  virtual Expected<uint32_t> getSymbolFlags(DataRefImpl Symb) const = 0;\n\n  virtual basic_symbol_iterator symbol_begin() const = 0;\n\n  virtual basic_symbol_iterator symbol_end() const = 0;\n\n  // convenience wrappers.\n  using basic_symbol_iterator_range = iterator_range<basic_symbol_iterator>;\n  basic_symbol_iterator_range symbols() const {\n    return basic_symbol_iterator_range(symbol_begin(), symbol_end());\n  }\n\n  // construction aux.\n  static Expected<std::unique_ptr<SymbolicFile>>\n  createSymbolicFile(MemoryBufferRef Object, llvm::file_magic Type,\n                     LLVMContext *Context, bool InitContent = true);\n\n  static Expected<std::unique_ptr<SymbolicFile>>\n  createSymbolicFile(MemoryBufferRef Object) {\n    return createSymbolicFile(Object, llvm::file_magic::unknown, nullptr);\n  }\n\n  static bool classof(const Binary *v) {\n    return v->isSymbolic();\n  }\n\n  static bool isSymbolicFile(file_magic Type, const LLVMContext *Context);\n};\n\ninline BasicSymbolRef::BasicSymbolRef(DataRefImpl SymbolP,\n                                      const SymbolicFile *Owner)\n    : SymbolPimpl(SymbolP), OwningObject(Owner) {}\n\ninline bool BasicSymbolRef::operator==(const BasicSymbolRef &Other) const {\n  return SymbolPimpl == Other.SymbolPimpl;\n}\n\ninline bool BasicSymbolRef::operator<(const BasicSymbolRef &Other) const {\n  return SymbolPimpl < Other.SymbolPimpl;\n}\n\ninline void BasicSymbolRef::moveNext() {\n  return OwningObject->moveSymbolNext(SymbolPimpl);\n}\n\ninline Error BasicSymbolRef::printName(raw_ostream &OS) const {\n  return OwningObject->printSymbolName(OS, SymbolPimpl);\n}\n\ninline Expected<uint32_t> BasicSymbolRef::getFlags() const {\n  return OwningObject->getSymbolFlags(SymbolPimpl);\n}\n\ninline DataRefImpl BasicSymbolRef::getRawDataRefImpl() const {\n  return SymbolPimpl;\n}\n\ninline const SymbolicFile *BasicSymbolRef::getObject() const {\n  return OwningObject;\n}\n\n} // end namespace object\n} // end namespace llvm\n\n#endif // LLVM_OBJECT_SYMBOLICFILE_H\n"}, "42": {"id": 42, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/ARMAttributeParser.h", "content": "//===- ARMAttributeParser.h - ARM Attribute Information Printer -*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_SUPPORT_ARMATTRIBUTEPARSER_H\n#define LLVM_SUPPORT_ARMATTRIBUTEPARSER_H\n\n#include \"ARMBuildAttributes.h\"\n#include \"ELFAttributeParser.h\"\n#include \"ScopedPrinter.h\"\n#include \"llvm/ADT/ArrayRef.h\"\n#include \"llvm/Support/DataExtractor.h\"\n#include \"llvm/Support/Endian.h\"\n#include \"llvm/Support/Error.h\"\n\nnamespace llvm {\nclass StringRef;\n\nclass ARMAttributeParser : public ELFAttributeParser {\n  struct DisplayHandler {\n    ARMBuildAttrs::AttrType attribute;\n    Error (ARMAttributeParser::*routine)(ARMBuildAttrs::AttrType);\n  };\n  static const DisplayHandler displayRoutines[];\n\n  Error handler(uint64_t tag, bool &handled) override;\n\n  Error stringAttribute(ARMBuildAttrs::AttrType tag);\n\n  Error CPU_arch(ARMBuildAttrs::AttrType tag);\n  Error CPU_arch_profile(ARMBuildAttrs::AttrType tag);\n  Error ARM_ISA_use(ARMBuildAttrs::AttrType tag);\n  Error THUMB_ISA_use(ARMBuildAttrs::AttrType tag);\n  Error FP_arch(ARMBuildAttrs::AttrType tag);\n  Error WMMX_arch(ARMBuildAttrs::AttrType tag);\n  Error Advanced_SIMD_arch(ARMBuildAttrs::AttrType tag);\n  Error MVE_arch(ARMBuildAttrs::AttrType tag);\n  Error PCS_config(ARMBuildAttrs::AttrType tag);\n  Error ABI_PCS_R9_use(ARMBuildAttrs::AttrType tag);\n  Error ABI_PCS_RW_data(ARMBuildAttrs::AttrType tag);\n  Error ABI_PCS_RO_data(ARMBuildAttrs::AttrType tag);\n  Error ABI_PCS_GOT_use(ARMBuildAttrs::AttrType tag);\n  Error ABI_PCS_wchar_t(ARMBuildAttrs::AttrType tag);\n  Error ABI_FP_rounding(ARMBuildAttrs::AttrType tag);\n  Error ABI_FP_denormal(ARMBuildAttrs::AttrType tag);\n  Error ABI_FP_exceptions(ARMBuildAttrs::AttrType tag);\n  Error ABI_FP_user_exceptions(ARMBuildAttrs::AttrType tag);\n  Error ABI_FP_number_model(ARMBuildAttrs::AttrType tag);\n  Error ABI_align_needed(ARMBuildAttrs::AttrType tag);\n  Error ABI_align_preserved(ARMBuildAttrs::AttrType tag);\n  Error ABI_enum_size(ARMBuildAttrs::AttrType tag);\n  Error ABI_HardFP_use(ARMBuildAttrs::AttrType tag);\n  Error ABI_VFP_args(ARMBuildAttrs::AttrType tag);\n  Error ABI_WMMX_args(ARMBuildAttrs::AttrType tag);\n  Error ABI_optimization_goals(ARMBuildAttrs::AttrType tag);\n  Error ABI_FP_optimization_goals(ARMBuildAttrs::AttrType tag);\n  Error compatibility(ARMBuildAttrs::AttrType tag);\n  Error CPU_unaligned_access(ARMBuildAttrs::AttrType tag);\n  Error FP_HP_extension(ARMBuildAttrs::AttrType tag);\n  Error ABI_FP_16bit_format(ARMBuildAttrs::AttrType tag);\n  Error MPextension_use(ARMBuildAttrs::AttrType tag);\n  Error DIV_use(ARMBuildAttrs::AttrType tag);\n  Error DSP_extension(ARMBuildAttrs::AttrType tag);\n  Error T2EE_use(ARMBuildAttrs::AttrType tag);\n  Error Virtualization_use(ARMBuildAttrs::AttrType tag);\n  Error nodefaults(ARMBuildAttrs::AttrType tag);\n\npublic:\n  ARMAttributeParser(ScopedPrinter *sw)\n      : ELFAttributeParser(sw, ARMBuildAttrs::ARMAttributeTags, \"aeabi\") {}\n  ARMAttributeParser()\n      : ELFAttributeParser(ARMBuildAttrs::ARMAttributeTags, \"aeabi\") {}\n};\n}\n\n#endif\n"}, "45": {"id": 45, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/BinaryByteStream.h", "content": "//===- BinaryByteStream.h ---------------------------------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//===----------------------------------------------------------------------===//\n// A BinaryStream which stores data in a single continguous memory buffer.\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_SUPPORT_BINARYBYTESTREAM_H\n#define LLVM_SUPPORT_BINARYBYTESTREAM_H\n\n#include \"llvm/ADT/ArrayRef.h\"\n#include \"llvm/ADT/StringRef.h\"\n#include \"llvm/Support/BinaryStream.h\"\n#include \"llvm/Support/BinaryStreamError.h\"\n#include \"llvm/Support/Error.h\"\n#include \"llvm/Support/FileOutputBuffer.h\"\n#include \"llvm/Support/MemoryBuffer.h\"\n#include <algorithm>\n#include <cstdint>\n#include <cstring>\n#include <memory>\n\nnamespace llvm {\n\n/// An implementation of BinaryStream which holds its entire data set\n/// in a single contiguous buffer.  BinaryByteStream guarantees that no read\n/// operation will ever incur a copy.  Note that BinaryByteStream does not\n/// own the underlying buffer.\nclass BinaryByteStream : public BinaryStream {\npublic:\n  BinaryByteStream() = default;\n  BinaryByteStream(ArrayRef<uint8_t> Data, llvm::support::endianness Endian)\n      : Endian(Endian), Data(Data) {}\n  BinaryByteStream(StringRef Data, llvm::support::endianness Endian)\n      : Endian(Endian), Data(Data.bytes_begin(), Data.bytes_end()) {}\n\n  llvm::support::endianness getEndian() const override { return Endian; }\n\n  Error readBytes(uint32_t Offset, uint32_t Size,\n                  ArrayRef<uint8_t> &Buffer) override {\n    if (auto EC = checkOffsetForRead(Offset, Size))\n      return EC;\n    Buffer = Data.slice(Offset, Size);\n    return Error::success();\n  }\n\n  Error readLongestContiguousChunk(uint32_t Offset,\n                                   ArrayRef<uint8_t> &Buffer) override {\n    if (auto EC = checkOffsetForRead(Offset, 1))\n      return EC;\n    Buffer = Data.slice(Offset);\n    return Error::success();\n  }\n\n  uint32_t getLength() override { return Data.size(); }\n\n  ArrayRef<uint8_t> data() const { return Data; }\n\n  StringRef str() const {\n    const char *CharData = reinterpret_cast<const char *>(Data.data());\n    return StringRef(CharData, Data.size());\n  }\n\nprotected:\n  llvm::support::endianness Endian;\n  ArrayRef<uint8_t> Data;\n};\n\n/// An implementation of BinaryStream whose data is backed by an llvm\n/// MemoryBuffer object.  MemoryBufferByteStream owns the MemoryBuffer in\n/// question.  As with BinaryByteStream, reading from a MemoryBufferByteStream\n/// will never cause a copy.\nclass MemoryBufferByteStream : public BinaryByteStream {\npublic:\n  MemoryBufferByteStream(std::unique_ptr<MemoryBuffer> Buffer,\n                         llvm::support::endianness Endian)\n      : BinaryByteStream(Buffer->getBuffer(), Endian),\n        MemBuffer(std::move(Buffer)) {}\n\n  std::unique_ptr<MemoryBuffer> MemBuffer;\n};\n\n/// An implementation of BinaryStream which holds its entire data set\n/// in a single contiguous buffer.  As with BinaryByteStream, the mutable\n/// version also guarantees that no read operation will ever incur a copy,\n/// and similarly it does not own the underlying buffer.\nclass MutableBinaryByteStream : public WritableBinaryStream {\npublic:\n  MutableBinaryByteStream() = default;\n  MutableBinaryByteStream(MutableArrayRef<uint8_t> Data,\n                          llvm::support::endianness Endian)\n      : Data(Data), ImmutableStream(Data, Endian) {}\n\n  llvm::support::endianness getEndian() const override {\n    return ImmutableStream.getEndian();\n  }\n\n  Error readBytes(uint32_t Offset, uint32_t Size,\n                  ArrayRef<uint8_t> &Buffer) override {\n    return ImmutableStream.readBytes(Offset, Size, Buffer);\n  }\n\n  Error readLongestContiguousChunk(uint32_t Offset,\n                                   ArrayRef<uint8_t> &Buffer) override {\n    return ImmutableStream.readLongestContiguousChunk(Offset, Buffer);\n  }\n\n  uint32_t getLength() override { return ImmutableStream.getLength(); }\n\n  Error writeBytes(uint32_t Offset, ArrayRef<uint8_t> Buffer) override {\n    if (Buffer.empty())\n      return Error::success();\n\n    if (auto EC = checkOffsetForWrite(Offset, Buffer.size()))\n      return EC;\n\n    uint8_t *DataPtr = const_cast<uint8_t *>(Data.data());\n    ::memcpy(DataPtr + Offset, Buffer.data(), Buffer.size());\n    return Error::success();\n  }\n\n  Error commit() override { return Error::success(); }\n\n  MutableArrayRef<uint8_t> data() const { return Data; }\n\nprivate:\n  MutableArrayRef<uint8_t> Data;\n  BinaryByteStream ImmutableStream;\n};\n\n/// An implementation of WritableBinaryStream which can write at its end\n/// causing the underlying data to grow.  This class owns the underlying data.\nclass AppendingBinaryByteStream : public WritableBinaryStream {\n  std::vector<uint8_t> Data;\n  llvm::support::endianness Endian = llvm::support::little;\n\npublic:\n  AppendingBinaryByteStream() = default;\n  AppendingBinaryByteStream(llvm::support::endianness Endian)\n      : Endian(Endian) {}\n\n  void clear() { Data.clear(); }\n\n  llvm::support::endianness getEndian() const override { return Endian; }\n\n  Error readBytes(uint32_t Offset, uint32_t Size,\n                  ArrayRef<uint8_t> &Buffer) override {\n    if (auto EC = checkOffsetForWrite(Offset, Buffer.size()))\n      return EC;\n\n    Buffer = makeArrayRef(Data).slice(Offset, Size);\n    return Error::success();\n  }\n\n  void insert(uint32_t Offset, ArrayRef<uint8_t> Bytes) {\n    Data.insert(Data.begin() + Offset, Bytes.begin(), Bytes.end());\n  }\n\n  Error readLongestContiguousChunk(uint32_t Offset,\n                                   ArrayRef<uint8_t> &Buffer) override {\n    if (auto EC = checkOffsetForWrite(Offset, 1))\n      return EC;\n\n    Buffer = makeArrayRef(Data).slice(Offset);\n    return Error::success();\n  }\n\n  uint32_t getLength() override { return Data.size(); }\n\n  Error writeBytes(uint32_t Offset, ArrayRef<uint8_t> Buffer) override {\n    if (Buffer.empty())\n      return Error::success();\n\n    // This is well-defined for any case except where offset is strictly\n    // greater than the current length.  If offset is equal to the current\n    // length, we can still grow.  If offset is beyond the current length, we\n    // would have to decide how to deal with the intermediate uninitialized\n    // bytes.  So we punt on that case for simplicity and just say it's an\n    // error.\n    if (Offset > getLength())\n      return make_error<BinaryStreamError>(stream_error_code::invalid_offset);\n\n    uint32_t RequiredSize = Offset + Buffer.size();\n    if (RequiredSize > Data.size())\n      Data.resize(RequiredSize);\n\n    ::memcpy(Data.data() + Offset, Buffer.data(), Buffer.size());\n    return Error::success();\n  }\n\n  Error commit() override { return Error::success(); }\n\n  /// Return the properties of this stream.\n  virtual BinaryStreamFlags getFlags() const override {\n    return BSF_Write | BSF_Append;\n  }\n\n  MutableArrayRef<uint8_t> data() { return Data; }\n};\n\n/// An implementation of WritableBinaryStream backed by an llvm\n/// FileOutputBuffer.\nclass FileBufferByteStream : public WritableBinaryStream {\nprivate:\n  class StreamImpl : public MutableBinaryByteStream {\n  public:\n    StreamImpl(std::unique_ptr<FileOutputBuffer> Buffer,\n               llvm::support::endianness Endian)\n        : MutableBinaryByteStream(\n              MutableArrayRef<uint8_t>(Buffer->getBufferStart(),\n                                       Buffer->getBufferEnd()),\n              Endian),\n          FileBuffer(std::move(Buffer)) {}\n\n    Error commit() override {\n      if (FileBuffer->commit())\n        return make_error<BinaryStreamError>(\n            stream_error_code::filesystem_error);\n      return Error::success();\n    }\n\n    /// Returns a pointer to the start of the buffer.\n    uint8_t *getBufferStart() const { return FileBuffer->getBufferStart(); }\n\n    /// Returns a pointer to the end of the buffer.\n    uint8_t *getBufferEnd() const { return FileBuffer->getBufferEnd(); }\n\n  private:\n    std::unique_ptr<FileOutputBuffer> FileBuffer;\n  };\n\npublic:\n  FileBufferByteStream(std::unique_ptr<FileOutputBuffer> Buffer,\n                       llvm::support::endianness Endian)\n      : Impl(std::move(Buffer), Endian) {}\n\n  llvm::support::endianness getEndian() const override {\n    return Impl.getEndian();\n  }\n\n  Error readBytes(uint32_t Offset, uint32_t Size,\n                  ArrayRef<uint8_t> &Buffer) override {\n    return Impl.readBytes(Offset, Size, Buffer);\n  }\n\n  Error readLongestContiguousChunk(uint32_t Offset,\n                                   ArrayRef<uint8_t> &Buffer) override {\n    return Impl.readLongestContiguousChunk(Offset, Buffer);\n  }\n\n  uint32_t getLength() override { return Impl.getLength(); }\n\n  Error writeBytes(uint32_t Offset, ArrayRef<uint8_t> Data) override {\n    return Impl.writeBytes(Offset, Data);\n  }\n\n  Error commit() override { return Impl.commit(); }\n\n  /// Returns a pointer to the start of the buffer.\n  uint8_t *getBufferStart() const { return Impl.getBufferStart(); }\n\n  /// Returns a pointer to the end of the buffer.\n  uint8_t *getBufferEnd() const { return Impl.getBufferEnd(); }\n\nprivate:\n  StreamImpl Impl;\n};\n\n} // end namespace llvm\n\n#endif // LLVM_SUPPORT_BINARYBYTESTREAM_H\n"}, "46": {"id": 46, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/BinaryStream.h", "content": "//===- BinaryStream.h - Base interface for a stream of data -----*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_SUPPORT_BINARYSTREAM_H\n#define LLVM_SUPPORT_BINARYSTREAM_H\n\n#include \"llvm/ADT/ArrayRef.h\"\n#include \"llvm/ADT/BitmaskEnum.h\"\n#include \"llvm/Support/BinaryStreamError.h\"\n#include \"llvm/Support/Endian.h\"\n#include \"llvm/Support/Error.h\"\n#include <cstdint>\n\nnamespace llvm {\n\nenum BinaryStreamFlags {\n  BSF_None = 0,\n  BSF_Write = 1,  // Stream supports writing.\n  BSF_Append = 2, // Writing can occur at offset == length.\n  LLVM_MARK_AS_BITMASK_ENUM(/* LargestValue = */ BSF_Append)\n};\n\n/// An interface for accessing data in a stream-like format, but which\n/// discourages copying.  Instead of specifying a buffer in which to copy\n/// data on a read, the API returns an ArrayRef to data owned by the stream's\n/// implementation.  Since implementations may not necessarily store data in a\n/// single contiguous buffer (or even in memory at all), in such cases a it may\n/// be necessary for an implementation to cache such a buffer so that it can\n/// return it.\nclass BinaryStream {\npublic:\n  virtual ~BinaryStream() = default;\n\n  virtual llvm::support::endianness getEndian() const = 0;\n\n  /// Given an offset into the stream and a number of bytes, attempt to\n  /// read the bytes and set the output ArrayRef to point to data owned by the\n  /// stream.\n  virtual Error readBytes(uint32_t Offset, uint32_t Size,\n                          ArrayRef<uint8_t> &Buffer) = 0;\n\n  /// Given an offset into the stream, read as much as possible without\n  /// copying any data.\n  virtual Error readLongestContiguousChunk(uint32_t Offset,\n                                           ArrayRef<uint8_t> &Buffer) = 0;\n\n  /// Return the number of bytes of data in this stream.\n  virtual uint32_t getLength() = 0;\n\n  /// Return the properties of this stream.\n  virtual BinaryStreamFlags getFlags() const { return BSF_None; }\n\nprotected:\n  Error checkOffsetForRead(uint32_t Offset, uint32_t DataSize) {\n    if (Offset > getLength())\n      return make_error<BinaryStreamError>(stream_error_code::invalid_offset);\n    if (getLength() < DataSize + Offset)\n      return make_error<BinaryStreamError>(stream_error_code::stream_too_short);\n    return Error::success();\n  }\n};\n\n/// A BinaryStream which can be read from as well as written to.  Note\n/// that writing to a BinaryStream always necessitates copying from the input\n/// buffer to the stream's backing store.  Streams are assumed to be buffered\n/// so that to be portable it is necessary to call commit() on the stream when\n/// all data has been written.\nclass WritableBinaryStream : public BinaryStream {\npublic:\n  ~WritableBinaryStream() override = default;\n\n  /// Attempt to write the given bytes into the stream at the desired\n  /// offset. This will always necessitate a copy.  Cannot shrink or grow the\n  /// stream, only writes into existing allocated space.\n  virtual Error writeBytes(uint32_t Offset, ArrayRef<uint8_t> Data) = 0;\n\n  /// For buffered streams, commits changes to the backing store.\n  virtual Error commit() = 0;\n\n  /// Return the properties of this stream.\n  BinaryStreamFlags getFlags() const override { return BSF_Write; }\n\nprotected:\n  Error checkOffsetForWrite(uint32_t Offset, uint32_t DataSize) {\n    if (!(getFlags() & BSF_Append))\n      return checkOffsetForRead(Offset, DataSize);\n\n    if (Offset > getLength())\n      return make_error<BinaryStreamError>(stream_error_code::invalid_offset);\n    return Error::success();\n  }\n};\n\n} // end namespace llvm\n\n#endif // LLVM_SUPPORT_BINARYSTREAM_H\n"}, "47": {"id": 47, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/BinaryStreamError.h", "content": "//===- BinaryStreamError.h - Error extensions for Binary Streams *- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_SUPPORT_BINARYSTREAMERROR_H\n#define LLVM_SUPPORT_BINARYSTREAMERROR_H\n\n#include \"llvm/ADT/StringRef.h\"\n#include \"llvm/Support/Error.h\"\n\n#include <string>\n\nnamespace llvm {\nenum class stream_error_code {\n  unspecified,\n  stream_too_short,\n  invalid_array_size,\n  invalid_offset,\n  filesystem_error\n};\n\n/// Base class for errors originating when parsing raw PDB files\nclass BinaryStreamError : public ErrorInfo<BinaryStreamError> {\npublic:\n  static char ID;\n  explicit BinaryStreamError(stream_error_code C);\n  explicit BinaryStreamError(StringRef Context);\n  BinaryStreamError(stream_error_code C, StringRef Context);\n\n  void log(raw_ostream &OS) const override;\n  std::error_code convertToErrorCode() const override;\n\n  StringRef getErrorMessage() const;\n\n  stream_error_code getErrorCode() const { return Code; }\n\nprivate:\n  std::string ErrMsg;\n  stream_error_code Code;\n};\n} // namespace llvm\n\n#endif // LLVM_SUPPORT_BINARYSTREAMERROR_H\n"}, "48": {"id": 48, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/DataExtractor.h", "content": "//===-- DataExtractor.h -----------------------------------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_SUPPORT_DATAEXTRACTOR_H\n#define LLVM_SUPPORT_DATAEXTRACTOR_H\n\n#include \"llvm/ADT/StringRef.h\"\n#include \"llvm/Support/DataTypes.h\"\n#include \"llvm/Support/Error.h\"\n\nnamespace llvm {\n\n/// An auxiliary type to facilitate extraction of 3-byte entities.\nstruct Uint24 {\n  uint8_t Bytes[3];\n  Uint24(uint8_t U) {\n    Bytes[0] = Bytes[1] = Bytes[2] = U;\n  }\n  Uint24(uint8_t U0, uint8_t U1, uint8_t U2) {\n    Bytes[0] = U0; Bytes[1] = U1; Bytes[2] = U2;\n  }\n  uint32_t getAsUint32(bool IsLittleEndian) const {\n    int LoIx = IsLittleEndian ? 0 : 2;\n    return Bytes[LoIx] + (Bytes[1] << 8) + (Bytes[2-LoIx] << 16);\n  }\n};\n\nusing uint24_t = Uint24;\nstatic_assert(sizeof(uint24_t) == 3, \"sizeof(uint24_t) != 3\");\n\n/// Needed by swapByteOrder().\ninline uint24_t getSwappedBytes(uint24_t C) {\n  return uint24_t(C.Bytes[2], C.Bytes[1], C.Bytes[0]);\n}\n\nclass DataExtractor {\n  StringRef Data;\n  uint8_t IsLittleEndian;\n  uint8_t AddressSize;\npublic:\n  /// A class representing a position in a DataExtractor, as well as any error\n  /// encountered during extraction. It enables one to extract a sequence of\n  /// values without error-checking and then checking for errors in bulk at the\n  /// end. The class holds an Error object, so failing to check the result of\n  /// the parse will result in a runtime error. The error flag is sticky and\n  /// will cause all subsequent extraction functions to fail without even\n  /// attempting to parse and without updating the Cursor offset. After clearing\n  /// the error flag, one can again use the Cursor object for parsing.\n  class Cursor {\n    uint64_t Offset;\n    Error Err;\n\n    friend class DataExtractor;\n\n  public:\n    /// Construct a cursor for extraction from the given offset.\n    explicit Cursor(uint64_t Offset) : Offset(Offset), Err(Error::success()) {}\n\n    /// Checks whether the cursor is valid (i.e. no errors were encountered). In\n    /// case of errors, this does not clear the error flag -- one must call\n    /// takeError() instead.\n    explicit operator bool() { return !Err; }\n\n    /// Return the current position of this Cursor. In the error state this is\n    /// the position of the Cursor before the first error was encountered.\n    uint64_t tell() const { return Offset; }\n\n    /// Return error contained inside this Cursor, if any. Clears the internal\n    /// Cursor state.\n    Error takeError() { return std::move(Err); }\n  };\n\n  /// Construct with a buffer that is owned by the caller.\n  ///\n  /// This constructor allows us to use data that is owned by the\n  /// caller. The data must stay around as long as this object is\n  /// valid.\n  DataExtractor(StringRef Data, bool IsLittleEndian, uint8_t AddressSize)\n    : Data(Data), IsLittleEndian(IsLittleEndian), AddressSize(AddressSize) {}\n  DataExtractor(ArrayRef<uint8_t> Data, bool IsLittleEndian,\n                uint8_t AddressSize)\n      : Data(StringRef(reinterpret_cast<const char *>(Data.data()),\n                       Data.size())),\n        IsLittleEndian(IsLittleEndian), AddressSize(AddressSize) {}\n\n  /// Get the data pointed to by this extractor.\n  StringRef getData() const { return Data; }\n  /// Get the endianness for this extractor.\n  bool isLittleEndian() const { return IsLittleEndian; }\n  /// Get the address size for this extractor.\n  uint8_t getAddressSize() const { return AddressSize; }\n  /// Set the address size for this extractor.\n  void setAddressSize(uint8_t Size) { AddressSize = Size; }\n\n  /// Extract a C string from \\a *offset_ptr.\n  ///\n  /// Returns a pointer to a C String from the data at the offset\n  /// pointed to by \\a offset_ptr. A variable length NULL terminated C\n  /// string will be extracted and the \\a offset_ptr will be\n  /// updated with the offset of the byte that follows the NULL\n  /// terminator byte.\n  ///\n  /// @param[in,out] OffsetPtr\n  ///     A pointer to an offset within the data that will be advanced\n  ///     by the appropriate number of bytes if the value is extracted\n  ///     correctly. If the offset is out of bounds or there are not\n  ///     enough bytes to extract this value, the offset will be left\n  ///     unmodified.\n  ///\n  /// @param[in,out] Err\n  ///     A pointer to an Error object. Upon return the Error object is set to\n  ///     indicate the result (success/failure) of the function. If the Error\n  ///     object is already set when calling this function, no extraction is\n  ///     performed.\n  ///\n  /// @return\n  ///     A pointer to the C string value in the data. If the offset\n  ///     pointed to by \\a offset_ptr is out of bounds, or if the\n  ///     offset plus the length of the C string is out of bounds,\n  ///     NULL will be returned.\n  const char *getCStr(uint64_t *OffsetPtr, Error *Err = nullptr) const {\n    return getCStrRef(OffsetPtr, Err).data();\n  }\n\n  /// Extract a C string from the location given by the cursor. In case of an\n  /// extraction error, or if the cursor is already in an error state, a\n  /// nullptr is returned.\n  const char *getCStr(Cursor &C) const { return getCStrRef(C).data(); }\n\n  /// Extract a C string from \\a *offset_ptr.\n  ///\n  /// Returns a StringRef for the C String from the data at the offset\n  /// pointed to by \\a offset_ptr. A variable length NULL terminated C\n  /// string will be extracted and the \\a offset_ptr will be\n  /// updated with the offset of the byte that follows the NULL\n  /// terminator byte.\n  ///\n  /// \\param[in,out] OffsetPtr\n  ///     A pointer to an offset within the data that will be advanced\n  ///     by the appropriate number of bytes if the value is extracted\n  ///     correctly. If the offset is out of bounds or there are not\n  ///     enough bytes to extract this value, the offset will be left\n  ///     unmodified.\n  ///\n  /// @param[in,out] Err\n  ///     A pointer to an Error object. Upon return the Error object is set to\n  ///     indicate the result (success/failure) of the function. If the Error\n  ///     object is already set when calling this function, no extraction is\n  ///     performed.\n  ///\n  /// \\return\n  ///     A StringRef for the C string value in the data. If the offset\n  ///     pointed to by \\a offset_ptr is out of bounds, or if the\n  ///     offset plus the length of the C string is out of bounds,\n  ///     a default-initialized StringRef will be returned.\n  StringRef getCStrRef(uint64_t *OffsetPtr, Error *Err = nullptr) const;\n\n  /// Extract a C string (as a StringRef) from the location given by the cursor.\n  /// In case of an extraction error, or if the cursor is already in an error\n  /// state, a default-initialized StringRef is returned.\n  StringRef getCStrRef(Cursor &C) const {\n    return getCStrRef(&C.Offset, &C.Err);\n  }\n\n  /// Extract a fixed length string from \\a *OffsetPtr and consume \\a Length\n  /// bytes.\n  ///\n  /// Returns a StringRef for the string from the data at the offset\n  /// pointed to by \\a OffsetPtr. A fixed length C string will be extracted\n  /// and the \\a OffsetPtr will be advanced by \\a Length bytes.\n  ///\n  /// \\param[in,out] OffsetPtr\n  ///     A pointer to an offset within the data that will be advanced\n  ///     by the appropriate number of bytes if the value is extracted\n  ///     correctly. If the offset is out of bounds or there are not\n  ///     enough bytes to extract this value, the offset will be left\n  ///     unmodified.\n  ///\n  /// \\param[in] Length\n  ///     The length of the fixed length string to extract. If there are not\n  ///     enough bytes in the data to extract the full string, the offset will\n  ///     be left unmodified.\n  ///\n  /// \\param[in] TrimChars\n  ///     A set of characters to trim from the end of the string. Fixed length\n  ///     strings are commonly either NULL terminated by one or more zero\n  ///     bytes. Some clients have one or more spaces at the end of the string,\n  ///     but a good default is to trim the NULL characters.\n  ///\n  /// \\return\n  ///     A StringRef for the C string value in the data. If the offset\n  ///     pointed to by \\a OffsetPtr is out of bounds, or if the\n  ///     offset plus the length of the C string is out of bounds,\n  ///     a default-initialized StringRef will be returned.\n  StringRef getFixedLengthString(uint64_t *OffsetPtr,\n      uint64_t Length, StringRef TrimChars = {\"\\0\", 1}) const;\n\n  /// Extract a fixed number of bytes from the specified offset.\n  ///\n  /// Returns a StringRef for the bytes from the data at the offset\n  /// pointed to by \\a OffsetPtr. A fixed length C string will be extracted\n  /// and the \\a OffsetPtr will be advanced by \\a Length bytes.\n  ///\n  /// \\param[in,out] OffsetPtr\n  ///     A pointer to an offset within the data that will be advanced\n  ///     by the appropriate number of bytes if the value is extracted\n  ///     correctly. If the offset is out of bounds or there are not\n  ///     enough bytes to extract this value, the offset will be left\n  ///     unmodified.\n  ///\n  /// \\param[in] Length\n  ///     The number of bytes to extract. If there are not enough bytes in the\n  ///     data to extract all of the bytes, the offset will be left unmodified.\n  ///\n  /// @param[in,out] Err\n  ///     A pointer to an Error object. Upon return the Error object is set to\n  ///     indicate the result (success/failure) of the function. If the Error\n  ///     object is already set when calling this function, no extraction is\n  ///     performed.\n  ///\n  /// \\return\n  ///     A StringRef for the extracted bytes. If the offset pointed to by\n  ///     \\a OffsetPtr is out of bounds, or if the offset plus the length\n  ///     is out of bounds, a default-initialized StringRef will be returned.\n  StringRef getBytes(uint64_t *OffsetPtr, uint64_t Length,\n                     Error *Err = nullptr) const;\n\n  /// Extract a fixed number of bytes from the location given by the cursor. In\n  /// case of an extraction error, or if the cursor is already in an error\n  /// state, a default-initialized StringRef is returned.\n  StringRef getBytes(Cursor &C, uint64_t Length) {\n    return getBytes(&C.Offset, Length, &C.Err);\n  }\n\n  /// Extract an unsigned integer of size \\a byte_size from \\a\n  /// *offset_ptr.\n  ///\n  /// Extract a single unsigned integer value and update the offset\n  /// pointed to by \\a offset_ptr. The size of the extracted integer\n  /// is specified by the \\a byte_size argument. \\a byte_size should\n  /// have a value greater than or equal to one and less than or equal\n  /// to eight since the return value is 64 bits wide. Any\n  /// \\a byte_size values less than 1 or greater than 8 will result in\n  /// nothing being extracted, and zero being returned.\n  ///\n  /// @param[in,out] offset_ptr\n  ///     A pointer to an offset within the data that will be advanced\n  ///     by the appropriate number of bytes if the value is extracted\n  ///     correctly. If the offset is out of bounds or there are not\n  ///     enough bytes to extract this value, the offset will be left\n  ///     unmodified.\n  ///\n  /// @param[in] byte_size\n  ///     The size in byte of the integer to extract.\n  ///\n  /// @param[in,out] Err\n  ///     A pointer to an Error object. Upon return the Error object is set to\n  ///     indicate the result (success/failure) of the function. If the Error\n  ///     object is already set when calling this function, no extraction is\n  ///     performed.\n  ///\n  /// @return\n  ///     The unsigned integer value that was extracted, or zero on\n  ///     failure.\n  uint64_t getUnsigned(uint64_t *offset_ptr, uint32_t byte_size,\n                       Error *Err = nullptr) const;\n\n  /// Extract an unsigned integer of the given size from the location given by\n  /// the cursor. In case of an extraction error, or if the cursor is already in\n  /// an error state, zero is returned.\n  uint64_t getUnsigned(Cursor &C, uint32_t Size) const {\n    return getUnsigned(&C.Offset, Size, &C.Err);\n  }\n\n  /// Extract an signed integer of size \\a byte_size from \\a *offset_ptr.\n  ///\n  /// Extract a single signed integer value (sign extending if required)\n  /// and update the offset pointed to by \\a offset_ptr. The size of\n  /// the extracted integer is specified by the \\a byte_size argument.\n  /// \\a byte_size should have a value greater than or equal to one\n  /// and less than or equal to eight since the return value is 64\n  /// bits wide. Any \\a byte_size values less than 1 or greater than\n  /// 8 will result in nothing being extracted, and zero being returned.\n  ///\n  /// @param[in,out] offset_ptr\n  ///     A pointer to an offset within the data that will be advanced\n  ///     by the appropriate number of bytes if the value is extracted\n  ///     correctly. If the offset is out of bounds or there are not\n  ///     enough bytes to extract this value, the offset will be left\n  ///     unmodified.\n  ///\n  /// @param[in] size\n  ///     The size in bytes of the integer to extract.\n  ///\n  /// @return\n  ///     The sign extended signed integer value that was extracted,\n  ///     or zero on failure.\n  int64_t getSigned(uint64_t *offset_ptr, uint32_t size) const;\n\n  //------------------------------------------------------------------\n  /// Extract an pointer from \\a *offset_ptr.\n  ///\n  /// Extract a single pointer from the data and update the offset\n  /// pointed to by \\a offset_ptr. The size of the extracted pointer\n  /// is \\a getAddressSize(), so the address size has to be\n  /// set correctly prior to extracting any pointer values.\n  ///\n  /// @param[in,out] offset_ptr\n  ///     A pointer to an offset within the data that will be advanced\n  ///     by the appropriate number of bytes if the value is extracted\n  ///     correctly. If the offset is out of bounds or there are not\n  ///     enough bytes to extract this value, the offset will be left\n  ///     unmodified.\n  ///\n  /// @return\n  ///     The extracted pointer value as a 64 integer.\n  uint64_t getAddress(uint64_t *offset_ptr) const {\n    return getUnsigned(offset_ptr, AddressSize);\n  }\n\n  /// Extract a pointer-sized unsigned integer from the location given by the\n  /// cursor. In case of an extraction error, or if the cursor is already in\n  /// an error state, zero is returned.\n  uint64_t getAddress(Cursor &C) const { return getUnsigned(C, AddressSize); }\n\n  /// Extract a uint8_t value from \\a *offset_ptr.\n  ///\n  /// Extract a single uint8_t from the binary data at the offset\n  /// pointed to by \\a offset_ptr, and advance the offset on success.\n  ///\n  /// @param[in,out] offset_ptr\n  ///     A pointer to an offset within the data that will be advanced\n  ///     by the appropriate number of bytes if the value is extracted\n  ///     correctly. If the offset is out of bounds or there are not\n  ///     enough bytes to extract this value, the offset will be left\n  ///     unmodified.\n  ///\n  /// @param[in,out] Err\n  ///     A pointer to an Error object. Upon return the Error object is set to\n  ///     indicate the result (success/failure) of the function. If the Error\n  ///     object is already set when calling this function, no extraction is\n  ///     performed.\n  ///\n  /// @return\n  ///     The extracted uint8_t value.\n  uint8_t getU8(uint64_t *offset_ptr, Error *Err = nullptr) const;\n\n  /// Extract a single uint8_t value from the location given by the cursor. In\n  /// case of an extraction error, or if the cursor is already in an error\n  /// state, zero is returned.\n  uint8_t getU8(Cursor &C) const { return getU8(&C.Offset, &C.Err); }\n\n  /// Extract \\a count uint8_t values from \\a *offset_ptr.\n  ///\n  /// Extract \\a count uint8_t values from the binary data at the\n  /// offset pointed to by \\a offset_ptr, and advance the offset on\n  /// success. The extracted values are copied into \\a dst.\n  ///\n  /// @param[in,out] offset_ptr\n  ///     A pointer to an offset within the data that will be advanced\n  ///     by the appropriate number of bytes if the value is extracted\n  ///     correctly. If the offset is out of bounds or there are not\n  ///     enough bytes to extract this value, the offset will be left\n  ///     unmodified.\n  ///\n  /// @param[out] dst\n  ///     A buffer to copy \\a count uint8_t values into. \\a dst must\n  ///     be large enough to hold all requested data.\n  ///\n  /// @param[in] count\n  ///     The number of uint8_t values to extract.\n  ///\n  /// @return\n  ///     \\a dst if all values were properly extracted and copied,\n  ///     NULL otherise.\n  uint8_t *getU8(uint64_t *offset_ptr, uint8_t *dst, uint32_t count) const;\n\n  /// Extract \\a Count uint8_t values from the location given by the cursor and\n  /// store them into the destination buffer. In case of an extraction error, or\n  /// if the cursor is already in an error state, a nullptr is returned and the\n  /// destination buffer is left unchanged.\n  uint8_t *getU8(Cursor &C, uint8_t *Dst, uint32_t Count) const;\n\n  /// Extract \\a Count uint8_t values from the location given by the cursor and\n  /// store them into the destination vector. The vector is resized to fit the\n  /// extracted data. In case of an extraction error, or if the cursor is\n  /// already in an error state, the destination vector is left unchanged and\n  /// cursor is placed into an error state.\n  void getU8(Cursor &C, SmallVectorImpl<uint8_t> &Dst, uint32_t Count) const {\n    if (isValidOffsetForDataOfSize(C.Offset, Count))\n      Dst.resize(Count);\n\n    // This relies on the fact that getU8 will not attempt to write to the\n    // buffer if isValidOffsetForDataOfSize(C.Offset, Count) is false.\n    getU8(C, Dst.data(), Count);\n  }\n\n  //------------------------------------------------------------------\n  /// Extract a uint16_t value from \\a *offset_ptr.\n  ///\n  /// Extract a single uint16_t from the binary data at the offset\n  /// pointed to by \\a offset_ptr, and update the offset on success.\n  ///\n  /// @param[in,out] offset_ptr\n  ///     A pointer to an offset within the data that will be advanced\n  ///     by the appropriate number of bytes if the value is extracted\n  ///     correctly. If the offset is out of bounds or there are not\n  ///     enough bytes to extract this value, the offset will be left\n  ///     unmodified.\n  ///\n  /// @param[in,out] Err\n  ///     A pointer to an Error object. Upon return the Error object is set to\n  ///     indicate the result (success/failure) of the function. If the Error\n  ///     object is already set when calling this function, no extraction is\n  ///     performed.\n  ///\n  /// @return\n  ///     The extracted uint16_t value.\n  //------------------------------------------------------------------\n  uint16_t getU16(uint64_t *offset_ptr, Error *Err = nullptr) const;\n\n  /// Extract a single uint16_t value from the location given by the cursor. In\n  /// case of an extraction error, or if the cursor is already in an error\n  /// state, zero is returned.\n  uint16_t getU16(Cursor &C) const { return getU16(&C.Offset, &C.Err); }\n\n  /// Extract \\a count uint16_t values from \\a *offset_ptr.\n  ///\n  /// Extract \\a count uint16_t values from the binary data at the\n  /// offset pointed to by \\a offset_ptr, and advance the offset on\n  /// success. The extracted values are copied into \\a dst.\n  ///\n  /// @param[in,out] offset_ptr\n  ///     A pointer to an offset within the data that will be advanced\n  ///     by the appropriate number of bytes if the value is extracted\n  ///     correctly. If the offset is out of bounds or there are not\n  ///     enough bytes to extract this value, the offset will be left\n  ///     unmodified.\n  ///\n  /// @param[out] dst\n  ///     A buffer to copy \\a count uint16_t values into. \\a dst must\n  ///     be large enough to hold all requested data.\n  ///\n  /// @param[in] count\n  ///     The number of uint16_t values to extract.\n  ///\n  /// @return\n  ///     \\a dst if all values were properly extracted and copied,\n  ///     NULL otherise.\n  uint16_t *getU16(uint64_t *offset_ptr, uint16_t *dst, uint32_t count) const;\n\n  /// Extract a 24-bit unsigned value from \\a *offset_ptr and return it\n  /// in a uint32_t.\n  ///\n  /// Extract 3 bytes from the binary data at the offset pointed to by\n  /// \\a offset_ptr, construct a uint32_t from them and update the offset\n  /// on success.\n  ///\n  /// @param[in,out] OffsetPtr\n  ///     A pointer to an offset within the data that will be advanced\n  ///     by the 3 bytes if the value is extracted correctly. If the offset\n  ///     is out of bounds or there are not enough bytes to extract this value,\n  ///     the offset will be left unmodified.\n  ///\n  /// @param[in,out] Err\n  ///     A pointer to an Error object. Upon return the Error object is set to\n  ///     indicate the result (success/failure) of the function. If the Error\n  ///     object is already set when calling this function, no extraction is\n  ///     performed.\n  ///\n  /// @return\n  ///     The extracted 24-bit value represented in a uint32_t.\n  uint32_t getU24(uint64_t *OffsetPtr, Error *Err = nullptr) const;\n\n  /// Extract a single 24-bit unsigned value from the location given by the\n  /// cursor. In case of an extraction error, or if the cursor is already in an\n  /// error state, zero is returned.\n  uint32_t getU24(Cursor &C) const { return getU24(&C.Offset, &C.Err); }\n\n  /// Extract a uint32_t value from \\a *offset_ptr.\n  ///\n  /// Extract a single uint32_t from the binary data at the offset\n  /// pointed to by \\a offset_ptr, and update the offset on success.\n  ///\n  /// @param[in,out] offset_ptr\n  ///     A pointer to an offset within the data that will be advanced\n  ///     by the appropriate number of bytes if the value is extracted\n  ///     correctly. If the offset is out of bounds or there are not\n  ///     enough bytes to extract this value, the offset will be left\n  ///     unmodified.\n  ///\n  /// @param[in,out] Err\n  ///     A pointer to an Error object. Upon return the Error object is set to\n  ///     indicate the result (success/failure) of the function. If the Error\n  ///     object is already set when calling this function, no extraction is\n  ///     performed.\n  ///\n  /// @return\n  ///     The extracted uint32_t value.\n  uint32_t getU32(uint64_t *offset_ptr, Error *Err = nullptr) const;\n\n  /// Extract a single uint32_t value from the location given by the cursor. In\n  /// case of an extraction error, or if the cursor is already in an error\n  /// state, zero is returned.\n  uint32_t getU32(Cursor &C) const { return getU32(&C.Offset, &C.Err); }\n\n  /// Extract \\a count uint32_t values from \\a *offset_ptr.\n  ///\n  /// Extract \\a count uint32_t values from the binary data at the\n  /// offset pointed to by \\a offset_ptr, and advance the offset on\n  /// success. The extracted values are copied into \\a dst.\n  ///\n  /// @param[in,out] offset_ptr\n  ///     A pointer to an offset within the data that will be advanced\n  ///     by the appropriate number of bytes if the value is extracted\n  ///     correctly. If the offset is out of bounds or there are not\n  ///     enough bytes to extract this value, the offset will be left\n  ///     unmodified.\n  ///\n  /// @param[out] dst\n  ///     A buffer to copy \\a count uint32_t values into. \\a dst must\n  ///     be large enough to hold all requested data.\n  ///\n  /// @param[in] count\n  ///     The number of uint32_t values to extract.\n  ///\n  /// @return\n  ///     \\a dst if all values were properly extracted and copied,\n  ///     NULL otherise.\n  uint32_t *getU32(uint64_t *offset_ptr, uint32_t *dst, uint32_t count) const;\n\n  /// Extract a uint64_t value from \\a *offset_ptr.\n  ///\n  /// Extract a single uint64_t from the binary data at the offset\n  /// pointed to by \\a offset_ptr, and update the offset on success.\n  ///\n  /// @param[in,out] offset_ptr\n  ///     A pointer to an offset within the data that will be advanced\n  ///     by the appropriate number of bytes if the value is extracted\n  ///     correctly. If the offset is out of bounds or there are not\n  ///     enough bytes to extract this value, the offset will be left\n  ///     unmodified.\n  ///\n  /// @param[in,out] Err\n  ///     A pointer to an Error object. Upon return the Error object is set to\n  ///     indicate the result (success/failure) of the function. If the Error\n  ///     object is already set when calling this function, no extraction is\n  ///     performed.\n  ///\n  /// @return\n  ///     The extracted uint64_t value.\n  uint64_t getU64(uint64_t *offset_ptr, Error *Err = nullptr) const;\n\n  /// Extract a single uint64_t value from the location given by the cursor. In\n  /// case of an extraction error, or if the cursor is already in an error\n  /// state, zero is returned.\n  uint64_t getU64(Cursor &C) const { return getU64(&C.Offset, &C.Err); }\n\n  /// Extract \\a count uint64_t values from \\a *offset_ptr.\n  ///\n  /// Extract \\a count uint64_t values from the binary data at the\n  /// offset pointed to by \\a offset_ptr, and advance the offset on\n  /// success. The extracted values are copied into \\a dst.\n  ///\n  /// @param[in,out] offset_ptr\n  ///     A pointer to an offset within the data that will be advanced\n  ///     by the appropriate number of bytes if the value is extracted\n  ///     correctly. If the offset is out of bounds or there are not\n  ///     enough bytes to extract this value, the offset will be left\n  ///     unmodified.\n  ///\n  /// @param[out] dst\n  ///     A buffer to copy \\a count uint64_t values into. \\a dst must\n  ///     be large enough to hold all requested data.\n  ///\n  /// @param[in] count\n  ///     The number of uint64_t values to extract.\n  ///\n  /// @return\n  ///     \\a dst if all values were properly extracted and copied,\n  ///     NULL otherise.\n  uint64_t *getU64(uint64_t *offset_ptr, uint64_t *dst, uint32_t count) const;\n\n  /// Extract a signed LEB128 value from \\a *offset_ptr.\n  ///\n  /// Extracts an signed LEB128 number from this object's data\n  /// starting at the offset pointed to by \\a offset_ptr. The offset\n  /// pointed to by \\a offset_ptr will be updated with the offset of\n  /// the byte following the last extracted byte.\n  ///\n  /// @param[in,out] OffsetPtr\n  ///     A pointer to an offset within the data that will be advanced\n  ///     by the appropriate number of bytes if the value is extracted\n  ///     correctly. If the offset is out of bounds or there are not\n  ///     enough bytes to extract this value, the offset will be left\n  ///     unmodified.\n  ///\n  /// @param[in,out] Err\n  ///     A pointer to an Error object. Upon return the Error object is set to\n  ///     indicate the result (success/failure) of the function. If the Error\n  ///     object is already set when calling this function, no extraction is\n  ///     performed.\n  ///\n  /// @return\n  ///     The extracted signed integer value.\n  int64_t getSLEB128(uint64_t *OffsetPtr, Error *Err = nullptr) const;\n\n  /// Extract an signed LEB128 value from the location given by the cursor.\n  /// In case of an extraction error, or if the cursor is already in an error\n  /// state, zero is returned.\n  int64_t getSLEB128(Cursor &C) const { return getSLEB128(&C.Offset, &C.Err); }\n\n  /// Extract a unsigned LEB128 value from \\a *offset_ptr.\n  ///\n  /// Extracts an unsigned LEB128 number from this object's data\n  /// starting at the offset pointed to by \\a offset_ptr. The offset\n  /// pointed to by \\a offset_ptr will be updated with the offset of\n  /// the byte following the last extracted byte.\n  ///\n  /// @param[in,out] offset_ptr\n  ///     A pointer to an offset within the data that will be advanced\n  ///     by the appropriate number of bytes if the value is extracted\n  ///     correctly. If the offset is out of bounds or there are not\n  ///     enough bytes to extract this value, the offset will be left\n  ///     unmodified.\n  ///\n  /// @param[in,out] Err\n  ///     A pointer to an Error object. Upon return the Error object is set to\n  ///     indicate the result (success/failure) of the function. If the Error\n  ///     object is already set when calling this function, no extraction is\n  ///     performed.\n  ///\n  /// @return\n  ///     The extracted unsigned integer value.\n  uint64_t getULEB128(uint64_t *offset_ptr, llvm::Error *Err = nullptr) const;\n\n  /// Extract an unsigned LEB128 value from the location given by the cursor.\n  /// In case of an extraction error, or if the cursor is already in an error\n  /// state, zero is returned.\n  uint64_t getULEB128(Cursor &C) const { return getULEB128(&C.Offset, &C.Err); }\n\n  /// Advance the Cursor position by the given number of bytes. No-op if the\n  /// cursor is in an error state.\n  void skip(Cursor &C, uint64_t Length) const;\n\n  /// Return true iff the cursor is at the end of the buffer, regardless of the\n  /// error state of the cursor. The only way both eof and error states can be\n  /// true is if one attempts a read while the cursor is at the very end of the\n  /// data buffer.\n  bool eof(const Cursor &C) const { return size() == C.Offset; }\n\n  /// Test the validity of \\a offset.\n  ///\n  /// @return\n  ///     \\b true if \\a offset is a valid offset into the data in this\n  ///     object, \\b false otherwise.\n  bool isValidOffset(uint64_t offset) const { return size() > offset; }\n\n  /// Test the availability of \\a length bytes of data from \\a offset.\n  ///\n  /// @return\n  ///     \\b true if \\a offset is a valid offset and there are \\a\n  ///     length bytes available at that offset, \\b false otherwise.\n  bool isValidOffsetForDataOfSize(uint64_t offset, uint64_t length) const {\n    return offset + length >= offset && isValidOffset(offset + length - 1);\n  }\n\n  /// Test the availability of enough bytes of data for a pointer from\n  /// \\a offset. The size of a pointer is \\a getAddressSize().\n  ///\n  /// @return\n  ///     \\b true if \\a offset is a valid offset and there are enough\n  ///     bytes for a pointer available at that offset, \\b false\n  ///     otherwise.\n  bool isValidOffsetForAddress(uint64_t offset) const {\n    return isValidOffsetForDataOfSize(offset, AddressSize);\n  }\n\n  /// Return the number of bytes in the underlying buffer.\n  size_t size() const { return Data.size(); }\n\nprotected:\n  // Make it possible for subclasses to access these fields without making them\n  // public.\n  static uint64_t &getOffset(Cursor &C) { return C.Offset; }\n  static Error &getError(Cursor &C) { return C.Err; }\n\nprivate:\n  /// If it is possible to read \\a Size bytes at offset \\a Offset, returns \\b\n  /// true. Otherwise, returns \\b false. If \\a E is not nullptr, also sets the\n  /// error object to indicate an error.\n  bool prepareRead(uint64_t Offset, uint64_t Size, Error *E) const;\n\n  template <typename T> T getU(uint64_t *OffsetPtr, Error *Err) const;\n  template <typename T>\n  T *getUs(uint64_t *OffsetPtr, T *Dst, uint32_t Count, Error *Err) const;\n};\n\n} // namespace llvm\n\n#endif\n"}, "49": {"id": 49, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/Endian.h", "content": "//===- Endian.h - Utilities for IO with endian specific data ----*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// This file declares generic functions to read and write endian specific data.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_SUPPORT_ENDIAN_H\n#define LLVM_SUPPORT_ENDIAN_H\n\n#include \"llvm/Support/Compiler.h\"\n#include \"llvm/Support/SwapByteOrder.h\"\n#include <cassert>\n#include <cstddef>\n#include <cstdint>\n#include <cstring>\n#include <type_traits>\n\nnamespace llvm {\nnamespace support {\n\nenum endianness {big, little, native};\n\n// These are named values for common alignments.\nenum {aligned = 0, unaligned = 1};\n\nnamespace detail {\n\n/// ::value is either alignment, or alignof(T) if alignment is 0.\ntemplate<class T, int alignment>\nstruct PickAlignment {\n enum { value = alignment == 0 ? alignof(T) : alignment };\n};\n\n} // end namespace detail\n\nnamespace endian {\n\nconstexpr endianness system_endianness() {\n  return sys::IsBigEndianHost ? big : little;\n}\n\ntemplate <typename value_type>\ninline value_type byte_swap(value_type value, endianness endian) {\n  if ((endian != native) && (endian != system_endianness()))\n    sys::swapByteOrder(value);\n  return value;\n}\n\n/// Swap the bytes of value to match the given endianness.\ntemplate<typename value_type, endianness endian>\ninline value_type byte_swap(value_type value) {\n  return byte_swap(value, endian);\n}\n\n/// Read a value of a particular endianness from memory.\ntemplate <typename value_type, std::size_t alignment>\ninline value_type read(const void *memory, endianness endian) {\n  value_type ret;\n\n  memcpy(&ret,\n         LLVM_ASSUME_ALIGNED(\n             memory, (detail::PickAlignment<value_type, alignment>::value)),\n         sizeof(value_type));\n  return byte_swap<value_type>(ret, endian);\n}\n\ntemplate<typename value_type,\n         endianness endian,\n         std::size_t alignment>\ninline value_type read(const void *memory) {\n  return read<value_type, alignment>(memory, endian);\n}\n\n/// Read a value of a particular endianness from a buffer, and increment the\n/// buffer past that value.\ntemplate <typename value_type, std::size_t alignment, typename CharT>\ninline value_type readNext(const CharT *&memory, endianness endian) {\n  value_type ret = read<value_type, alignment>(memory, endian);\n  memory += sizeof(value_type);\n  return ret;\n}\n\ntemplate<typename value_type, endianness endian, std::size_t alignment,\n         typename CharT>\ninline value_type readNext(const CharT *&memory) {\n  return readNext<value_type, alignment, CharT>(memory, endian);\n}\n\n/// Write a value to memory with a particular endianness.\ntemplate <typename value_type, std::size_t alignment>\ninline void write(void *memory, value_type value, endianness endian) {\n  value = byte_swap<value_type>(value, endian);\n  memcpy(LLVM_ASSUME_ALIGNED(\n             memory, (detail::PickAlignment<value_type, alignment>::value)),\n         &value, sizeof(value_type));\n}\n\ntemplate<typename value_type,\n         endianness endian,\n         std::size_t alignment>\ninline void write(void *memory, value_type value) {\n  write<value_type, alignment>(memory, value, endian);\n}\n\ntemplate <typename value_type>\nusing make_unsigned_t = std::make_unsigned_t<value_type>;\n\n/// Read a value of a particular endianness from memory, for a location\n/// that starts at the given bit offset within the first byte.\ntemplate <typename value_type, endianness endian, std::size_t alignment>\ninline value_type readAtBitAlignment(const void *memory, uint64_t startBit) {\n  assert(startBit < 8);\n  if (startBit == 0)\n    return read<value_type, endian, alignment>(memory);\n  else {\n    // Read two values and compose the result from them.\n    value_type val[2];\n    memcpy(&val[0],\n           LLVM_ASSUME_ALIGNED(\n               memory, (detail::PickAlignment<value_type, alignment>::value)),\n           sizeof(value_type) * 2);\n    val[0] = byte_swap<value_type, endian>(val[0]);\n    val[1] = byte_swap<value_type, endian>(val[1]);\n\n    // Shift bits from the lower value into place.\n    make_unsigned_t<value_type> lowerVal = val[0] >> startBit;\n    // Mask off upper bits after right shift in case of signed type.\n    make_unsigned_t<value_type> numBitsFirstVal =\n        (sizeof(value_type) * 8) - startBit;\n    lowerVal &= ((make_unsigned_t<value_type>)1 << numBitsFirstVal) - 1;\n\n    // Get the bits from the upper value.\n    make_unsigned_t<value_type> upperVal =\n        val[1] & (((make_unsigned_t<value_type>)1 << startBit) - 1);\n    // Shift them in to place.\n    upperVal <<= numBitsFirstVal;\n\n    return lowerVal | upperVal;\n  }\n}\n\n/// Write a value to memory with a particular endianness, for a location\n/// that starts at the given bit offset within the first byte.\ntemplate <typename value_type, endianness endian, std::size_t alignment>\ninline void writeAtBitAlignment(void *memory, value_type value,\n                                uint64_t startBit) {\n  assert(startBit < 8);\n  if (startBit == 0)\n    write<value_type, endian, alignment>(memory, value);\n  else {\n    // Read two values and shift the result into them.\n    value_type val[2];\n    memcpy(&val[0],\n           LLVM_ASSUME_ALIGNED(\n               memory, (detail::PickAlignment<value_type, alignment>::value)),\n           sizeof(value_type) * 2);\n    val[0] = byte_swap<value_type, endian>(val[0]);\n    val[1] = byte_swap<value_type, endian>(val[1]);\n\n    // Mask off any existing bits in the upper part of the lower value that\n    // we want to replace.\n    val[0] &= ((make_unsigned_t<value_type>)1 << startBit) - 1;\n    make_unsigned_t<value_type> numBitsFirstVal =\n        (sizeof(value_type) * 8) - startBit;\n    make_unsigned_t<value_type> lowerVal = value;\n    if (startBit > 0) {\n      // Mask off the upper bits in the new value that are not going to go into\n      // the lower value. This avoids a left shift of a negative value, which\n      // is undefined behavior.\n      lowerVal &= (((make_unsigned_t<value_type>)1 << numBitsFirstVal) - 1);\n      // Now shift the new bits into place\n      lowerVal <<= startBit;\n    }\n    val[0] |= lowerVal;\n\n    // Mask off any existing bits in the lower part of the upper value that\n    // we want to replace.\n    val[1] &= ~(((make_unsigned_t<value_type>)1 << startBit) - 1);\n    // Next shift the bits that go into the upper value into position.\n    make_unsigned_t<value_type> upperVal = value >> numBitsFirstVal;\n    // Mask off upper bits after right shift in case of signed type.\n    upperVal &= ((make_unsigned_t<value_type>)1 << startBit) - 1;\n    val[1] |= upperVal;\n\n    // Finally, rewrite values.\n    val[0] = byte_swap<value_type, endian>(val[0]);\n    val[1] = byte_swap<value_type, endian>(val[1]);\n    memcpy(LLVM_ASSUME_ALIGNED(\n               memory, (detail::PickAlignment<value_type, alignment>::value)),\n           &val[0], sizeof(value_type) * 2);\n  }\n}\n\n} // end namespace endian\n\nnamespace detail {\n\ntemplate <typename ValueType, endianness Endian, std::size_t Alignment,\n          std::size_t ALIGN = PickAlignment<ValueType, Alignment>::value>\nstruct packed_endian_specific_integral {\n  using value_type = ValueType;\n  static constexpr endianness endian = Endian;\n  static constexpr std::size_t alignment = Alignment;\n\n  packed_endian_specific_integral() = default;\n\n  explicit packed_endian_specific_integral(value_type val) { *this = val; }\n\n  operator value_type() const {\n    return endian::read<value_type, endian, alignment>(\n      (const void*)Value.buffer);\n  }\n\n  void operator=(value_type newValue) {\n    endian::write<value_type, endian, alignment>(\n      (void*)Value.buffer, newValue);\n  }\n\n  packed_endian_specific_integral &operator+=(value_type newValue) {\n    *this = *this + newValue;\n    return *this;\n  }\n\n  packed_endian_specific_integral &operator-=(value_type newValue) {\n    *this = *this - newValue;\n    return *this;\n  }\n\n  packed_endian_specific_integral &operator|=(value_type newValue) {\n    *this = *this | newValue;\n    return *this;\n  }\n\n  packed_endian_specific_integral &operator&=(value_type newValue) {\n    *this = *this & newValue;\n    return *this;\n  }\n\nprivate:\n  struct {\n    alignas(ALIGN) char buffer[sizeof(value_type)];\n  } Value;\n\npublic:\n  struct ref {\n    explicit ref(void *Ptr) : Ptr(Ptr) {}\n\n    operator value_type() const {\n      return endian::read<value_type, endian, alignment>(Ptr);\n    }\n\n    void operator=(value_type NewValue) {\n      endian::write<value_type, endian, alignment>(Ptr, NewValue);\n    }\n\n  private:\n    void *Ptr;\n  };\n};\n\n} // end namespace detail\n\nusing ulittle16_t =\n    detail::packed_endian_specific_integral<uint16_t, little, unaligned>;\nusing ulittle32_t =\n    detail::packed_endian_specific_integral<uint32_t, little, unaligned>;\nusing ulittle64_t =\n    detail::packed_endian_specific_integral<uint64_t, little, unaligned>;\n\nusing little16_t =\n    detail::packed_endian_specific_integral<int16_t, little, unaligned>;\nusing little32_t =\n    detail::packed_endian_specific_integral<int32_t, little, unaligned>;\nusing little64_t =\n    detail::packed_endian_specific_integral<int64_t, little, unaligned>;\n\nusing aligned_ulittle16_t =\n    detail::packed_endian_specific_integral<uint16_t, little, aligned>;\nusing aligned_ulittle32_t =\n    detail::packed_endian_specific_integral<uint32_t, little, aligned>;\nusing aligned_ulittle64_t =\n    detail::packed_endian_specific_integral<uint64_t, little, aligned>;\n\nusing aligned_little16_t =\n    detail::packed_endian_specific_integral<int16_t, little, aligned>;\nusing aligned_little32_t =\n    detail::packed_endian_specific_integral<int32_t, little, aligned>;\nusing aligned_little64_t =\n    detail::packed_endian_specific_integral<int64_t, little, aligned>;\n\nusing ubig16_t =\n    detail::packed_endian_specific_integral<uint16_t, big, unaligned>;\nusing ubig32_t =\n    detail::packed_endian_specific_integral<uint32_t, big, unaligned>;\nusing ubig64_t =\n    detail::packed_endian_specific_integral<uint64_t, big, unaligned>;\n\nusing big16_t =\n    detail::packed_endian_specific_integral<int16_t, big, unaligned>;\nusing big32_t =\n    detail::packed_endian_specific_integral<int32_t, big, unaligned>;\nusing big64_t =\n    detail::packed_endian_specific_integral<int64_t, big, unaligned>;\n\nusing aligned_ubig16_t =\n    detail::packed_endian_specific_integral<uint16_t, big, aligned>;\nusing aligned_ubig32_t =\n    detail::packed_endian_specific_integral<uint32_t, big, aligned>;\nusing aligned_ubig64_t =\n    detail::packed_endian_specific_integral<uint64_t, big, aligned>;\n\nusing aligned_big16_t =\n    detail::packed_endian_specific_integral<int16_t, big, aligned>;\nusing aligned_big32_t =\n    detail::packed_endian_specific_integral<int32_t, big, aligned>;\nusing aligned_big64_t =\n    detail::packed_endian_specific_integral<int64_t, big, aligned>;\n\nusing unaligned_uint16_t =\n    detail::packed_endian_specific_integral<uint16_t, native, unaligned>;\nusing unaligned_uint32_t =\n    detail::packed_endian_specific_integral<uint32_t, native, unaligned>;\nusing unaligned_uint64_t =\n    detail::packed_endian_specific_integral<uint64_t, native, unaligned>;\n\nusing unaligned_int16_t =\n    detail::packed_endian_specific_integral<int16_t, native, unaligned>;\nusing unaligned_int32_t =\n    detail::packed_endian_specific_integral<int32_t, native, unaligned>;\nusing unaligned_int64_t =\n    detail::packed_endian_specific_integral<int64_t, native, unaligned>;\n\ntemplate <typename T>\nusing little_t = detail::packed_endian_specific_integral<T, little, unaligned>;\ntemplate <typename T>\nusing big_t = detail::packed_endian_specific_integral<T, big, unaligned>;\n\ntemplate <typename T>\nusing aligned_little_t =\n    detail::packed_endian_specific_integral<T, little, aligned>;\ntemplate <typename T>\nusing aligned_big_t = detail::packed_endian_specific_integral<T, big, aligned>;\n\nnamespace endian {\n\ntemplate <typename T> inline T read(const void *P, endianness E) {\n  return read<T, unaligned>(P, E);\n}\n\ntemplate <typename T, endianness E> inline T read(const void *P) {\n  return *(const detail::packed_endian_specific_integral<T, E, unaligned> *)P;\n}\n\ninline uint16_t read16(const void *P, endianness E) {\n  return read<uint16_t>(P, E);\n}\ninline uint32_t read32(const void *P, endianness E) {\n  return read<uint32_t>(P, E);\n}\ninline uint64_t read64(const void *P, endianness E) {\n  return read<uint64_t>(P, E);\n}\n\ntemplate <endianness E> inline uint16_t read16(const void *P) {\n  return read<uint16_t, E>(P);\n}\ntemplate <endianness E> inline uint32_t read32(const void *P) {\n  return read<uint32_t, E>(P);\n}\ntemplate <endianness E> inline uint64_t read64(const void *P) {\n  return read<uint64_t, E>(P);\n}\n\ninline uint16_t read16le(const void *P) { return read16<little>(P); }\ninline uint32_t read32le(const void *P) { return read32<little>(P); }\ninline uint64_t read64le(const void *P) { return read64<little>(P); }\ninline uint16_t read16be(const void *P) { return read16<big>(P); }\ninline uint32_t read32be(const void *P) { return read32<big>(P); }\ninline uint64_t read64be(const void *P) { return read64<big>(P); }\n\ntemplate <typename T> inline void write(void *P, T V, endianness E) {\n  write<T, unaligned>(P, V, E);\n}\n\ntemplate <typename T, endianness E> inline void write(void *P, T V) {\n  *(detail::packed_endian_specific_integral<T, E, unaligned> *)P = V;\n}\n\ninline void write16(void *P, uint16_t V, endianness E) {\n  write<uint16_t>(P, V, E);\n}\ninline void write32(void *P, uint32_t V, endianness E) {\n  write<uint32_t>(P, V, E);\n}\ninline void write64(void *P, uint64_t V, endianness E) {\n  write<uint64_t>(P, V, E);\n}\n\ntemplate <endianness E> inline void write16(void *P, uint16_t V) {\n  write<uint16_t, E>(P, V);\n}\ntemplate <endianness E> inline void write32(void *P, uint32_t V) {\n  write<uint32_t, E>(P, V);\n}\ntemplate <endianness E> inline void write64(void *P, uint64_t V) {\n  write<uint64_t, E>(P, V);\n}\n\ninline void write16le(void *P, uint16_t V) { write16<little>(P, V); }\ninline void write32le(void *P, uint32_t V) { write32<little>(P, V); }\ninline void write64le(void *P, uint64_t V) { write64<little>(P, V); }\ninline void write16be(void *P, uint16_t V) { write16<big>(P, V); }\ninline void write32be(void *P, uint32_t V) { write32<big>(P, V); }\ninline void write64be(void *P, uint64_t V) { write64<big>(P, V); }\n\n} // end namespace endian\n\n} // end namespace support\n} // end namespace llvm\n\n#endif // LLVM_SUPPORT_ENDIAN_H\n"}, "50": {"id": 50, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/Error.h", "content": "//===- llvm/Support/Error.h - Recoverable error handling --------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// This file defines an API used to report recoverable errors.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_SUPPORT_ERROR_H\n#define LLVM_SUPPORT_ERROR_H\n\n#include \"llvm-c/Error.h\"\n#include \"llvm/ADT/STLExtras.h\"\n#include \"llvm/ADT/SmallVector.h\"\n#include \"llvm/ADT/StringExtras.h\"\n#include \"llvm/ADT/Twine.h\"\n#include \"llvm/Config/abi-breaking.h\"\n#include \"llvm/Support/AlignOf.h\"\n#include \"llvm/Support/Compiler.h\"\n#include \"llvm/Support/Debug.h\"\n#include \"llvm/Support/ErrorHandling.h\"\n#include \"llvm/Support/ErrorOr.h\"\n#include \"llvm/Support/Format.h\"\n#include \"llvm/Support/raw_ostream.h\"\n#include <algorithm>\n#include <cassert>\n#include <cstdint>\n#include <cstdlib>\n#include <functional>\n#include <memory>\n#include <new>\n#include <string>\n#include <system_error>\n#include <type_traits>\n#include <utility>\n#include <vector>\n\nnamespace llvm {\n\nclass ErrorSuccess;\n\n/// Base class for error info classes. Do not extend this directly: Extend\n/// the ErrorInfo template subclass instead.\nclass ErrorInfoBase {\npublic:\n  virtual ~ErrorInfoBase() = default;\n\n  /// Print an error message to an output stream.\n  virtual void log(raw_ostream &OS) const = 0;\n\n  /// Return the error message as a string.\n  virtual std::string message() const {\n    std::string Msg;\n    raw_string_ostream OS(Msg);\n    log(OS);\n    return OS.str();\n  }\n\n  /// Convert this error to a std::error_code.\n  ///\n  /// This is a temporary crutch to enable interaction with code still\n  /// using std::error_code. It will be removed in the future.\n  virtual std::error_code convertToErrorCode() const = 0;\n\n  // Returns the class ID for this type.\n  static const void *classID() { return &ID; }\n\n  // Returns the class ID for the dynamic type of this ErrorInfoBase instance.\n  virtual const void *dynamicClassID() const = 0;\n\n  // Check whether this instance is a subclass of the class identified by\n  // ClassID.\n  virtual bool isA(const void *const ClassID) const {\n    return ClassID == classID();\n  }\n\n  // Check whether this instance is a subclass of ErrorInfoT.\n  template <typename ErrorInfoT> bool isA() const {\n    return isA(ErrorInfoT::classID());\n  }\n\nprivate:\n  virtual void anchor();\n\n  static char ID;\n};\n\n/// Lightweight error class with error context and mandatory checking.\n///\n/// Instances of this class wrap a ErrorInfoBase pointer. Failure states\n/// are represented by setting the pointer to a ErrorInfoBase subclass\n/// instance containing information describing the failure. Success is\n/// represented by a null pointer value.\n///\n/// Instances of Error also contains a 'Checked' flag, which must be set\n/// before the destructor is called, otherwise the destructor will trigger a\n/// runtime error. This enforces at runtime the requirement that all Error\n/// instances be checked or returned to the caller.\n///\n/// There are two ways to set the checked flag, depending on what state the\n/// Error instance is in. For Error instances indicating success, it\n/// is sufficient to invoke the boolean conversion operator. E.g.:\n///\n///   @code{.cpp}\n///   Error foo(<...>);\n///\n///   if (auto E = foo(<...>))\n///     return E; // <- Return E if it is in the error state.\n///   // We have verified that E was in the success state. It can now be safely\n///   // destroyed.\n///   @endcode\n///\n/// A success value *can not* be dropped. For example, just calling 'foo(<...>)'\n/// without testing the return value will raise a runtime error, even if foo\n/// returns success.\n///\n/// For Error instances representing failure, you must use either the\n/// handleErrors or handleAllErrors function with a typed handler. E.g.:\n///\n///   @code{.cpp}\n///   class MyErrorInfo : public ErrorInfo<MyErrorInfo> {\n///     // Custom error info.\n///   };\n///\n///   Error foo(<...>) { return make_error<MyErrorInfo>(...); }\n///\n///   auto E = foo(<...>); // <- foo returns failure with MyErrorInfo.\n///   auto NewE =\n///     handleErrors(E,\n///       [](const MyErrorInfo &M) {\n///         // Deal with the error.\n///       },\n///       [](std::unique_ptr<OtherError> M) -> Error {\n///         if (canHandle(*M)) {\n///           // handle error.\n///           return Error::success();\n///         }\n///         // Couldn't handle this error instance. Pass it up the stack.\n///         return Error(std::move(M));\n///       );\n///   // Note - we must check or return NewE in case any of the handlers\n///   // returned a new error.\n///   @endcode\n///\n/// The handleAllErrors function is identical to handleErrors, except\n/// that it has a void return type, and requires all errors to be handled and\n/// no new errors be returned. It prevents errors (assuming they can all be\n/// handled) from having to be bubbled all the way to the top-level.\n///\n/// *All* Error instances must be checked before destruction, even if\n/// they're moved-assigned or constructed from Success values that have already\n/// been checked. This enforces checking through all levels of the call stack.\nclass LLVM_NODISCARD Error {\n  // ErrorList needs to be able to yank ErrorInfoBase pointers out of Errors\n  // to add to the error list. It can't rely on handleErrors for this, since\n  // handleErrors does not support ErrorList handlers.\n  friend class ErrorList;\n\n  // handleErrors needs to be able to set the Checked flag.\n  template <typename... HandlerTs>\n  friend Error handleErrors(Error E, HandlerTs &&... Handlers);\n\n  // Expected<T> needs to be able to steal the payload when constructed from an\n  // error.\n  template <typename T> friend class Expected;\n\n  // wrap needs to be able to steal the payload.\n  friend LLVMErrorRef wrap(Error);\n\nprotected:\n  /// Create a success value. Prefer using 'Error::success()' for readability\n  Error() {\n    setPtr(nullptr);\n    setChecked(false);\n  }\n\npublic:\n  /// Create a success value.\n  static ErrorSuccess success();\n\n  // Errors are not copy-constructable.\n  Error(const Error &Other) = delete;\n\n  /// Move-construct an error value. The newly constructed error is considered\n  /// unchecked, even if the source error had been checked. The original error\n  /// becomes a checked Success value, regardless of its original state.\n  Error(Error &&Other) {\n    setChecked(true);\n    *this = std::move(Other);\n  }\n\n  /// Create an error value. Prefer using the 'make_error' function, but\n  /// this constructor can be useful when \"re-throwing\" errors from handlers.\n  Error(std::unique_ptr<ErrorInfoBase> Payload) {\n    setPtr(Payload.release());\n    setChecked(false);\n  }\n\n  // Errors are not copy-assignable.\n  Error &operator=(const Error &Other) = delete;\n\n  /// Move-assign an error value. The current error must represent success, you\n  /// you cannot overwrite an unhandled error. The current error is then\n  /// considered unchecked. The source error becomes a checked success value,\n  /// regardless of its original state.\n  Error &operator=(Error &&Other) {\n    // Don't allow overwriting of unchecked values.\n    assertIsChecked();\n    setPtr(Other.getPtr());\n\n    // This Error is unchecked, even if the source error was checked.\n    setChecked(false);\n\n    // Null out Other's payload and set its checked bit.\n    Other.setPtr(nullptr);\n    Other.setChecked(true);\n\n    return *this;\n  }\n\n  /// Destroy a Error. Fails with a call to abort() if the error is\n  /// unchecked.\n  ~Error() {\n    assertIsChecked();\n    delete getPtr();\n  }\n\n  /// Bool conversion. Returns true if this Error is in a failure state,\n  /// and false if it is in an accept state. If the error is in a Success state\n  /// it will be considered checked.\n  explicit operator bool() {\n    setChecked(getPtr() == nullptr);\n    return getPtr() != nullptr;\n  }\n\n  /// Check whether one error is a subclass of another.\n  template <typename ErrT> bool isA() const {\n    return getPtr() && getPtr()->isA(ErrT::classID());\n  }\n\n  /// Returns the dynamic class id of this error, or null if this is a success\n  /// value.\n  const void* dynamicClassID() const {\n    if (!getPtr())\n      return nullptr;\n    return getPtr()->dynamicClassID();\n  }\n\nprivate:\n#if LLVM_ENABLE_ABI_BREAKING_CHECKS\n  // assertIsChecked() happens very frequently, but under normal circumstances\n  // is supposed to be a no-op.  So we want it to be inlined, but having a bunch\n  // of debug prints can cause the function to be too large for inlining.  So\n  // it's important that we define this function out of line so that it can't be\n  // inlined.\n  LLVM_ATTRIBUTE_NORETURN\n  void fatalUncheckedError() const;\n#endif\n\n  void assertIsChecked() {\n#if LLVM_ENABLE_ABI_BREAKING_CHECKS\n    if (LLVM_UNLIKELY(!getChecked() || getPtr()))\n      fatalUncheckedError();\n#endif\n  }\n\n  ErrorInfoBase *getPtr() const {\n#if LLVM_ENABLE_ABI_BREAKING_CHECKS\n    return reinterpret_cast<ErrorInfoBase*>(\n             reinterpret_cast<uintptr_t>(Payload) &\n             ~static_cast<uintptr_t>(0x1));\n#else\n    return Payload;\n#endif\n  }\n\n  void setPtr(ErrorInfoBase *EI) {\n#if LLVM_ENABLE_ABI_BREAKING_CHECKS\n    Payload = reinterpret_cast<ErrorInfoBase*>(\n                (reinterpret_cast<uintptr_t>(EI) &\n                 ~static_cast<uintptr_t>(0x1)) |\n                (reinterpret_cast<uintptr_t>(Payload) & 0x1));\n#else\n    Payload = EI;\n#endif\n  }\n\n  bool getChecked() const {\n#if LLVM_ENABLE_ABI_BREAKING_CHECKS\n    return (reinterpret_cast<uintptr_t>(Payload) & 0x1) == 0;\n#else\n    return true;\n#endif\n  }\n\n  void setChecked(bool V) {\n#if LLVM_ENABLE_ABI_BREAKING_CHECKS\n    Payload = reinterpret_cast<ErrorInfoBase*>(\n                (reinterpret_cast<uintptr_t>(Payload) &\n                  ~static_cast<uintptr_t>(0x1)) |\n                  (V ? 0 : 1));\n#endif\n  }\n\n  std::unique_ptr<ErrorInfoBase> takePayload() {\n    std::unique_ptr<ErrorInfoBase> Tmp(getPtr());\n    setPtr(nullptr);\n    setChecked(true);\n    return Tmp;\n  }\n\n  friend raw_ostream &operator<<(raw_ostream &OS, const Error &E) {\n    if (auto P = E.getPtr())\n      P->log(OS);\n    else\n      OS << \"success\";\n    return OS;\n  }\n\n  ErrorInfoBase *Payload = nullptr;\n};\n\n/// Subclass of Error for the sole purpose of identifying the success path in\n/// the type system. This allows to catch invalid conversion to Expected<T> at\n/// compile time.\nclass ErrorSuccess final : public Error {};\n\ninline ErrorSuccess Error::success() { return ErrorSuccess(); }\n\n/// Make a Error instance representing failure using the given error info\n/// type.\ntemplate <typename ErrT, typename... ArgTs> Error make_error(ArgTs &&... Args) {\n  return Error(std::make_unique<ErrT>(std::forward<ArgTs>(Args)...));\n}\n\n/// Base class for user error types. Users should declare their error types\n/// like:\n///\n/// class MyError : public ErrorInfo<MyError> {\n///   ....\n/// };\n///\n/// This class provides an implementation of the ErrorInfoBase::kind\n/// method, which is used by the Error RTTI system.\ntemplate <typename ThisErrT, typename ParentErrT = ErrorInfoBase>\nclass ErrorInfo : public ParentErrT {\npublic:\n  using ParentErrT::ParentErrT; // inherit constructors\n\n  static const void *classID() { return &ThisErrT::ID; }\n\n  const void *dynamicClassID() const override { return &ThisErrT::ID; }\n\n  bool isA(const void *const ClassID) const override {\n    return ClassID == classID() || ParentErrT::isA(ClassID);\n  }\n};\n\n/// Special ErrorInfo subclass representing a list of ErrorInfos.\n/// Instances of this class are constructed by joinError.\nclass ErrorList final : public ErrorInfo<ErrorList> {\n  // handleErrors needs to be able to iterate the payload list of an\n  // ErrorList.\n  template <typename... HandlerTs>\n  friend Error handleErrors(Error E, HandlerTs &&... Handlers);\n\n  // joinErrors is implemented in terms of join.\n  friend Error joinErrors(Error, Error);\n\npublic:\n  void log(raw_ostream &OS) const override {\n    OS << \"Multiple errors:\\n\";\n    for (auto &ErrPayload : Payloads) {\n      ErrPayload->log(OS);\n      OS << \"\\n\";\n    }\n  }\n\n  std::error_code convertToErrorCode() const override;\n\n  // Used by ErrorInfo::classID.\n  static char ID;\n\nprivate:\n  ErrorList(std::unique_ptr<ErrorInfoBase> Payload1,\n            std::unique_ptr<ErrorInfoBase> Payload2) {\n    assert(!Payload1->isA<ErrorList>() && !Payload2->isA<ErrorList>() &&\n           \"ErrorList constructor payloads should be singleton errors\");\n    Payloads.push_back(std::move(Payload1));\n    Payloads.push_back(std::move(Payload2));\n  }\n\n  static Error join(Error E1, Error E2) {\n    if (!E1)\n      return E2;\n    if (!E2)\n      return E1;\n    if (E1.isA<ErrorList>()) {\n      auto &E1List = static_cast<ErrorList &>(*E1.getPtr());\n      if (E2.isA<ErrorList>()) {\n        auto E2Payload = E2.takePayload();\n        auto &E2List = static_cast<ErrorList &>(*E2Payload);\n        for (auto &Payload : E2List.Payloads)\n          E1List.Payloads.push_back(std::move(Payload));\n      } else\n        E1List.Payloads.push_back(E2.takePayload());\n\n      return E1;\n    }\n    if (E2.isA<ErrorList>()) {\n      auto &E2List = static_cast<ErrorList &>(*E2.getPtr());\n      E2List.Payloads.insert(E2List.Payloads.begin(), E1.takePayload());\n      return E2;\n    }\n    return Error(std::unique_ptr<ErrorList>(\n        new ErrorList(E1.takePayload(), E2.takePayload())));\n  }\n\n  std::vector<std::unique_ptr<ErrorInfoBase>> Payloads;\n};\n\n/// Concatenate errors. The resulting Error is unchecked, and contains the\n/// ErrorInfo(s), if any, contained in E1, followed by the\n/// ErrorInfo(s), if any, contained in E2.\ninline Error joinErrors(Error E1, Error E2) {\n  return ErrorList::join(std::move(E1), std::move(E2));\n}\n\n/// Tagged union holding either a T or a Error.\n///\n/// This class parallels ErrorOr, but replaces error_code with Error. Since\n/// Error cannot be copied, this class replaces getError() with\n/// takeError(). It also adds an bool errorIsA<ErrT>() method for testing the\n/// error class type.\ntemplate <class T> class LLVM_NODISCARD Expected {\n  template <class T1> friend class ExpectedAsOutParameter;\n  template <class OtherT> friend class Expected;\n\n  static constexpr bool isRef = std::is_reference<T>::value;\n\n  using wrap = std::reference_wrapper<std::remove_reference_t<T>>;\n\n  using error_type = std::unique_ptr<ErrorInfoBase>;\n\npublic:\n  using storage_type = std::conditional_t<isRef, wrap, T>;\n  using value_type = T;\n\nprivate:\n  using reference = std::remove_reference_t<T> &;\n  using const_reference = const std::remove_reference_t<T> &;\n  using pointer = std::remove_reference_t<T> *;\n  using const_pointer = const std::remove_reference_t<T> *;\n\npublic:\n  /// Create an Expected<T> error value from the given Error.\n  Expected(Error Err)\n      : HasError(true)\n#if LLVM_ENABLE_ABI_BREAKING_CHECKS\n        // Expected is unchecked upon construction in Debug builds.\n        , Unchecked(true)\n#endif\n  {\n    assert(Err && \"Cannot create Expected<T> from Error success value.\");\n    new (getErrorStorage()) error_type(Err.takePayload());\n  }\n\n  /// Forbid to convert from Error::success() implicitly, this avoids having\n  /// Expected<T> foo() { return Error::success(); } which compiles otherwise\n  /// but triggers the assertion above.\n  Expected(ErrorSuccess) = delete;\n\n  /// Create an Expected<T> success value from the given OtherT value, which\n  /// must be convertible to T.\n  template <typename OtherT>\n  Expected(OtherT &&Val,\n           std::enable_if_t<std::is_convertible<OtherT, T>::value> * = nullptr)\n      : HasError(false)\n#if LLVM_ENABLE_ABI_BREAKING_CHECKS\n        // Expected is unchecked upon construction in Debug builds.\n        ,\n        Unchecked(true)\n#endif\n  {\n    new (getStorage()) storage_type(std::forward<OtherT>(Val));\n  }\n\n  /// Move construct an Expected<T> value.\n  Expected(Expected &&Other) { moveConstruct(std::move(Other)); }\n\n  /// Move construct an Expected<T> value from an Expected<OtherT>, where OtherT\n  /// must be convertible to T.\n  template <class OtherT>\n  Expected(\n      Expected<OtherT> &&Other,\n      std::enable_if_t<std::is_convertible<OtherT, T>::value> * = nullptr) {\n    moveConstruct(std::move(Other));\n  }\n\n  /// Move construct an Expected<T> value from an Expected<OtherT>, where OtherT\n  /// isn't convertible to T.\n  template <class OtherT>\n  explicit Expected(\n      Expected<OtherT> &&Other,\n      std::enable_if_t<!std::is_convertible<OtherT, T>::value> * = nullptr) {\n    moveConstruct(std::move(Other));\n  }\n\n  /// Move-assign from another Expected<T>.\n  Expected &operator=(Expected &&Other) {\n    moveAssign(std::move(Other));\n    return *this;\n  }\n\n  /// Destroy an Expected<T>.\n  ~Expected() {\n    assertIsChecked();\n    if (!HasError)\n      getStorage()->~storage_type();\n    else\n      getErrorStorage()->~error_type();\n  }\n\n  /// Return false if there is an error.\n  explicit operator bool() {\n#if LLVM_ENABLE_ABI_BREAKING_CHECKS\n    Unchecked = HasError;\n#endif\n    return !HasError;\n  }\n\n  /// Returns a reference to the stored T value.\n  reference get() {\n    assertIsChecked();\n    return *getStorage();\n  }\n\n  /// Returns a const reference to the stored T value.\n  const_reference get() const {\n    assertIsChecked();\n    return const_cast<Expected<T> *>(this)->get();\n  }\n\n  /// Check that this Expected<T> is an error of type ErrT.\n  template <typename ErrT> bool errorIsA() const {\n    return HasError && (*getErrorStorage())->template isA<ErrT>();\n  }\n\n  /// Take ownership of the stored error.\n  /// After calling this the Expected<T> is in an indeterminate state that can\n  /// only be safely destructed. No further calls (beside the destructor) should\n  /// be made on the Expected<T> value.\n  Error takeError() {\n#if LLVM_ENABLE_ABI_BREAKING_CHECKS\n    Unchecked = false;\n#endif\n    return HasError ? Error(std::move(*getErrorStorage())) : Error::success();\n  }\n\n  /// Returns a pointer to the stored T value.\n  pointer operator->() {\n    assertIsChecked();\n    return toPointer(getStorage());\n  }\n\n  /// Returns a const pointer to the stored T value.\n  const_pointer operator->() const {\n    assertIsChecked();\n    return toPointer(getStorage());\n  }\n\n  /// Returns a reference to the stored T value.\n  reference operator*() {\n    assertIsChecked();\n    return *getStorage();\n  }\n\n  /// Returns a const reference to the stored T value.\n  const_reference operator*() const {\n    assertIsChecked();\n    return *getStorage();\n  }\n\nprivate:\n  template <class T1>\n  static bool compareThisIfSameType(const T1 &a, const T1 &b) {\n    return &a == &b;\n  }\n\n  template <class T1, class T2>\n  static bool compareThisIfSameType(const T1 &a, const T2 &b) {\n    return false;\n  }\n\n  template <class OtherT> void moveConstruct(Expected<OtherT> &&Other) {\n    HasError = Other.HasError;\n#if LLVM_ENABLE_ABI_BREAKING_CHECKS\n    Unchecked = true;\n    Other.Unchecked = false;\n#endif\n\n    if (!HasError)\n      new (getStorage()) storage_type(std::move(*Other.getStorage()));\n    else\n      new (getErrorStorage()) error_type(std::move(*Other.getErrorStorage()));\n  }\n\n  template <class OtherT> void moveAssign(Expected<OtherT> &&Other) {\n    assertIsChecked();\n\n    if (compareThisIfSameType(*this, Other))\n      return;\n\n    this->~Expected();\n    new (this) Expected(std::move(Other));\n  }\n\n  pointer toPointer(pointer Val) { return Val; }\n\n  const_pointer toPointer(const_pointer Val) const { return Val; }\n\n  pointer toPointer(wrap *Val) { return &Val->get(); }\n\n  const_pointer toPointer(const wrap *Val) const { return &Val->get(); }\n\n  storage_type *getStorage() {\n    assert(!HasError && \"Cannot get value when an error exists!\");\n    return reinterpret_cast<storage_type *>(&TStorage);\n  }\n\n  const storage_type *getStorage() const {\n    assert(!HasError && \"Cannot get value when an error exists!\");\n    return reinterpret_cast<const storage_type *>(&TStorage);\n  }\n\n  error_type *getErrorStorage() {\n    assert(HasError && \"Cannot get error when a value exists!\");\n    return reinterpret_cast<error_type *>(&ErrorStorage);\n  }\n\n  const error_type *getErrorStorage() const {\n    assert(HasError && \"Cannot get error when a value exists!\");\n    return reinterpret_cast<const error_type *>(&ErrorStorage);\n  }\n\n  // Used by ExpectedAsOutParameter to reset the checked flag.\n  void setUnchecked() {\n#if LLVM_ENABLE_ABI_BREAKING_CHECKS\n    Unchecked = true;\n#endif\n  }\n\n#if LLVM_ENABLE_ABI_BREAKING_CHECKS\n  LLVM_ATTRIBUTE_NORETURN\n  LLVM_ATTRIBUTE_NOINLINE\n  void fatalUncheckedExpected() const {\n    dbgs() << \"Expected<T> must be checked before access or destruction.\\n\";\n    if (HasError) {\n      dbgs() << \"Unchecked Expected<T> contained error:\\n\";\n      (*getErrorStorage())->log(dbgs());\n    } else\n      dbgs() << \"Expected<T> value was in success state. (Note: Expected<T> \"\n                \"values in success mode must still be checked prior to being \"\n                \"destroyed).\\n\";\n    abort();\n  }\n#endif\n\n  void assertIsChecked() {\n#if LLVM_ENABLE_ABI_BREAKING_CHECKS\n    if (LLVM_UNLIKELY(Unchecked))\n      fatalUncheckedExpected();\n#endif\n  }\n\n  union {\n    AlignedCharArrayUnion<storage_type> TStorage;\n    AlignedCharArrayUnion<error_type> ErrorStorage;\n  };\n  bool HasError : 1;\n#if LLVM_ENABLE_ABI_BREAKING_CHECKS\n  bool Unchecked : 1;\n#endif\n};\n\n/// Report a serious error, calling any installed error handler. See\n/// ErrorHandling.h.\nLLVM_ATTRIBUTE_NORETURN void report_fatal_error(Error Err,\n                                                bool gen_crash_diag = true);\n\n/// Report a fatal error if Err is a failure value.\n///\n/// This function can be used to wrap calls to fallible functions ONLY when it\n/// is known that the Error will always be a success value. E.g.\n///\n///   @code{.cpp}\n///   // foo only attempts the fallible operation if DoFallibleOperation is\n///   // true. If DoFallibleOperation is false then foo always returns\n///   // Error::success().\n///   Error foo(bool DoFallibleOperation);\n///\n///   cantFail(foo(false));\n///   @endcode\ninline void cantFail(Error Err, const char *Msg = nullptr) {\n  if (Err) {\n    if (!Msg)\n      Msg = \"Failure value returned from cantFail wrapped call\";\n#ifndef NDEBUG\n    std::string Str;\n    raw_string_ostream OS(Str);\n    OS << Msg << \"\\n\" << Err;\n    Msg = OS.str().c_str();\n#endif\n    llvm_unreachable(Msg);\n  }\n}\n\n/// Report a fatal error if ValOrErr is a failure value, otherwise unwraps and\n/// returns the contained value.\n///\n/// This function can be used to wrap calls to fallible functions ONLY when it\n/// is known that the Error will always be a success value. E.g.\n///\n///   @code{.cpp}\n///   // foo only attempts the fallible operation if DoFallibleOperation is\n///   // true. If DoFallibleOperation is false then foo always returns an int.\n///   Expected<int> foo(bool DoFallibleOperation);\n///\n///   int X = cantFail(foo(false));\n///   @endcode\ntemplate <typename T>\nT cantFail(Expected<T> ValOrErr, const char *Msg = nullptr) {\n  if (ValOrErr)\n    return std::move(*ValOrErr);\n  else {\n    if (!Msg)\n      Msg = \"Failure value returned from cantFail wrapped call\";\n#ifndef NDEBUG\n    std::string Str;\n    raw_string_ostream OS(Str);\n    auto E = ValOrErr.takeError();\n    OS << Msg << \"\\n\" << E;\n    Msg = OS.str().c_str();\n#endif\n    llvm_unreachable(Msg);\n  }\n}\n\n/// Report a fatal error if ValOrErr is a failure value, otherwise unwraps and\n/// returns the contained reference.\n///\n/// This function can be used to wrap calls to fallible functions ONLY when it\n/// is known that the Error will always be a success value. E.g.\n///\n///   @code{.cpp}\n///   // foo only attempts the fallible operation if DoFallibleOperation is\n///   // true. If DoFallibleOperation is false then foo always returns a Bar&.\n///   Expected<Bar&> foo(bool DoFallibleOperation);\n///\n///   Bar &X = cantFail(foo(false));\n///   @endcode\ntemplate <typename T>\nT& cantFail(Expected<T&> ValOrErr, const char *Msg = nullptr) {\n  if (ValOrErr)\n    return *ValOrErr;\n  else {\n    if (!Msg)\n      Msg = \"Failure value returned from cantFail wrapped call\";\n#ifndef NDEBUG\n    std::string Str;\n    raw_string_ostream OS(Str);\n    auto E = ValOrErr.takeError();\n    OS << Msg << \"\\n\" << E;\n    Msg = OS.str().c_str();\n#endif\n    llvm_unreachable(Msg);\n  }\n}\n\n/// Helper for testing applicability of, and applying, handlers for\n/// ErrorInfo types.\ntemplate <typename HandlerT>\nclass ErrorHandlerTraits\n    : public ErrorHandlerTraits<decltype(\n          &std::remove_reference<HandlerT>::type::operator())> {};\n\n// Specialization functions of the form 'Error (const ErrT&)'.\ntemplate <typename ErrT> class ErrorHandlerTraits<Error (&)(ErrT &)> {\npublic:\n  static bool appliesTo(const ErrorInfoBase &E) {\n    return E.template isA<ErrT>();\n  }\n\n  template <typename HandlerT>\n  static Error apply(HandlerT &&H, std::unique_ptr<ErrorInfoBase> E) {\n    assert(appliesTo(*E) && \"Applying incorrect handler\");\n    return H(static_cast<ErrT &>(*E));\n  }\n};\n\n// Specialization functions of the form 'void (const ErrT&)'.\ntemplate <typename ErrT> class ErrorHandlerTraits<void (&)(ErrT &)> {\npublic:\n  static bool appliesTo(const ErrorInfoBase &E) {\n    return E.template isA<ErrT>();\n  }\n\n  template <typename HandlerT>\n  static Error apply(HandlerT &&H, std::unique_ptr<ErrorInfoBase> E) {\n    assert(appliesTo(*E) && \"Applying incorrect handler\");\n    H(static_cast<ErrT &>(*E));\n    return Error::success();\n  }\n};\n\n/// Specialization for functions of the form 'Error (std::unique_ptr<ErrT>)'.\ntemplate <typename ErrT>\nclass ErrorHandlerTraits<Error (&)(std::unique_ptr<ErrT>)> {\npublic:\n  static bool appliesTo(const ErrorInfoBase &E) {\n    return E.template isA<ErrT>();\n  }\n\n  template <typename HandlerT>\n  static Error apply(HandlerT &&H, std::unique_ptr<ErrorInfoBase> E) {\n    assert(appliesTo(*E) && \"Applying incorrect handler\");\n    std::unique_ptr<ErrT> SubE(static_cast<ErrT *>(E.release()));\n    return H(std::move(SubE));\n  }\n};\n\n/// Specialization for functions of the form 'void (std::unique_ptr<ErrT>)'.\ntemplate <typename ErrT>\nclass ErrorHandlerTraits<void (&)(std::unique_ptr<ErrT>)> {\npublic:\n  static bool appliesTo(const ErrorInfoBase &E) {\n    return E.template isA<ErrT>();\n  }\n\n  template <typename HandlerT>\n  static Error apply(HandlerT &&H, std::unique_ptr<ErrorInfoBase> E) {\n    assert(appliesTo(*E) && \"Applying incorrect handler\");\n    std::unique_ptr<ErrT> SubE(static_cast<ErrT *>(E.release()));\n    H(std::move(SubE));\n    return Error::success();\n  }\n};\n\n// Specialization for member functions of the form 'RetT (const ErrT&)'.\ntemplate <typename C, typename RetT, typename ErrT>\nclass ErrorHandlerTraits<RetT (C::*)(ErrT &)>\n    : public ErrorHandlerTraits<RetT (&)(ErrT &)> {};\n\n// Specialization for member functions of the form 'RetT (const ErrT&) const'.\ntemplate <typename C, typename RetT, typename ErrT>\nclass ErrorHandlerTraits<RetT (C::*)(ErrT &) const>\n    : public ErrorHandlerTraits<RetT (&)(ErrT &)> {};\n\n// Specialization for member functions of the form 'RetT (const ErrT&)'.\ntemplate <typename C, typename RetT, typename ErrT>\nclass ErrorHandlerTraits<RetT (C::*)(const ErrT &)>\n    : public ErrorHandlerTraits<RetT (&)(ErrT &)> {};\n\n// Specialization for member functions of the form 'RetT (const ErrT&) const'.\ntemplate <typename C, typename RetT, typename ErrT>\nclass ErrorHandlerTraits<RetT (C::*)(const ErrT &) const>\n    : public ErrorHandlerTraits<RetT (&)(ErrT &)> {};\n\n/// Specialization for member functions of the form\n/// 'RetT (std::unique_ptr<ErrT>)'.\ntemplate <typename C, typename RetT, typename ErrT>\nclass ErrorHandlerTraits<RetT (C::*)(std::unique_ptr<ErrT>)>\n    : public ErrorHandlerTraits<RetT (&)(std::unique_ptr<ErrT>)> {};\n\n/// Specialization for member functions of the form\n/// 'RetT (std::unique_ptr<ErrT>) const'.\ntemplate <typename C, typename RetT, typename ErrT>\nclass ErrorHandlerTraits<RetT (C::*)(std::unique_ptr<ErrT>) const>\n    : public ErrorHandlerTraits<RetT (&)(std::unique_ptr<ErrT>)> {};\n\ninline Error handleErrorImpl(std::unique_ptr<ErrorInfoBase> Payload) {\n  return Error(std::move(Payload));\n}\n\ntemplate <typename HandlerT, typename... HandlerTs>\nError handleErrorImpl(std::unique_ptr<ErrorInfoBase> Payload,\n                      HandlerT &&Handler, HandlerTs &&... Handlers) {\n  if (ErrorHandlerTraits<HandlerT>::appliesTo(*Payload))\n    return ErrorHandlerTraits<HandlerT>::apply(std::forward<HandlerT>(Handler),\n                                               std::move(Payload));\n  return handleErrorImpl(std::move(Payload),\n                         std::forward<HandlerTs>(Handlers)...);\n}\n\n/// Pass the ErrorInfo(s) contained in E to their respective handlers. Any\n/// unhandled errors (or Errors returned by handlers) are re-concatenated and\n/// returned.\n/// Because this function returns an error, its result must also be checked\n/// or returned. If you intend to handle all errors use handleAllErrors\n/// (which returns void, and will abort() on unhandled errors) instead.\ntemplate <typename... HandlerTs>\nError handleErrors(Error E, HandlerTs &&... Hs) {\n  if (!E)\n    return Error::success();\n\n  std::unique_ptr<ErrorInfoBase> Payload = E.takePayload();\n\n  if (Payload->isA<ErrorList>()) {\n    ErrorList &List = static_cast<ErrorList &>(*Payload);\n    Error R;\n    for (auto &P : List.Payloads)\n      R = ErrorList::join(\n          std::move(R),\n          handleErrorImpl(std::move(P), std::forward<HandlerTs>(Hs)...));\n    return R;\n  }\n\n  return handleErrorImpl(std::move(Payload), std::forward<HandlerTs>(Hs)...);\n}\n\n/// Behaves the same as handleErrors, except that by contract all errors\n/// *must* be handled by the given handlers (i.e. there must be no remaining\n/// errors after running the handlers, or llvm_unreachable is called).\ntemplate <typename... HandlerTs>\nvoid handleAllErrors(Error E, HandlerTs &&... Handlers) {\n  cantFail(handleErrors(std::move(E), std::forward<HandlerTs>(Handlers)...));\n}\n\n/// Check that E is a non-error, then drop it.\n/// If E is an error, llvm_unreachable will be called.\ninline void handleAllErrors(Error E) {\n  cantFail(std::move(E));\n}\n\n/// Handle any errors (if present) in an Expected<T>, then try a recovery path.\n///\n/// If the incoming value is a success value it is returned unmodified. If it\n/// is a failure value then it the contained error is passed to handleErrors.\n/// If handleErrors is able to handle the error then the RecoveryPath functor\n/// is called to supply the final result. If handleErrors is not able to\n/// handle all errors then the unhandled errors are returned.\n///\n/// This utility enables the follow pattern:\n///\n///   @code{.cpp}\n///   enum FooStrategy { Aggressive, Conservative };\n///   Expected<Foo> foo(FooStrategy S);\n///\n///   auto ResultOrErr =\n///     handleExpected(\n///       foo(Aggressive),\n///       []() { return foo(Conservative); },\n///       [](AggressiveStrategyError&) {\n///         // Implicitly conusme this - we'll recover by using a conservative\n///         // strategy.\n///       });\n///\n///   @endcode\ntemplate <typename T, typename RecoveryFtor, typename... HandlerTs>\nExpected<T> handleExpected(Expected<T> ValOrErr, RecoveryFtor &&RecoveryPath,\n                           HandlerTs &&... Handlers) {\n  if (ValOrErr)\n    return ValOrErr;\n\n  if (auto Err = handleErrors(ValOrErr.takeError(),\n                              std::forward<HandlerTs>(Handlers)...))\n    return std::move(Err);\n\n  return RecoveryPath();\n}\n\n/// Log all errors (if any) in E to OS. If there are any errors, ErrorBanner\n/// will be printed before the first one is logged. A newline will be printed\n/// after each error.\n///\n/// This function is compatible with the helpers from Support/WithColor.h. You\n/// can pass any of them as the OS. Please consider using them instead of\n/// including 'error: ' in the ErrorBanner.\n///\n/// This is useful in the base level of your program to allow clean termination\n/// (allowing clean deallocation of resources, etc.), while reporting error\n/// information to the user.\nvoid logAllUnhandledErrors(Error E, raw_ostream &OS, Twine ErrorBanner = {});\n\n/// Write all error messages (if any) in E to a string. The newline character\n/// is used to separate error messages.\ninline std::string toString(Error E) {\n  SmallVector<std::string, 2> Errors;\n  handleAllErrors(std::move(E), [&Errors](const ErrorInfoBase &EI) {\n    Errors.push_back(EI.message());\n  });\n  return join(Errors.begin(), Errors.end(), \"\\n\");\n}\n\n/// Consume a Error without doing anything. This method should be used\n/// only where an error can be considered a reasonable and expected return\n/// value.\n///\n/// Uses of this method are potentially indicative of design problems: If it's\n/// legitimate to do nothing while processing an \"error\", the error-producer\n/// might be more clearly refactored to return an Optional<T>.\ninline void consumeError(Error Err) {\n  handleAllErrors(std::move(Err), [](const ErrorInfoBase &) {});\n}\n\n/// Convert an Expected to an Optional without doing anything. This method\n/// should be used only where an error can be considered a reasonable and\n/// expected return value.\n///\n/// Uses of this method are potentially indicative of problems: perhaps the\n/// error should be propagated further, or the error-producer should just\n/// return an Optional in the first place.\ntemplate <typename T> Optional<T> expectedToOptional(Expected<T> &&E) {\n  if (E)\n    return std::move(*E);\n  consumeError(E.takeError());\n  return None;\n}\n\n/// Helper for converting an Error to a bool.\n///\n/// This method returns true if Err is in an error state, or false if it is\n/// in a success state.  Puts Err in a checked state in both cases (unlike\n/// Error::operator bool(), which only does this for success states).\ninline bool errorToBool(Error Err) {\n  bool IsError = static_cast<bool>(Err);\n  if (IsError)\n    consumeError(std::move(Err));\n  return IsError;\n}\n\n/// Helper for Errors used as out-parameters.\n///\n/// This helper is for use with the Error-as-out-parameter idiom, where an error\n/// is passed to a function or method by reference, rather than being returned.\n/// In such cases it is helpful to set the checked bit on entry to the function\n/// so that the error can be written to (unchecked Errors abort on assignment)\n/// and clear the checked bit on exit so that clients cannot accidentally forget\n/// to check the result. This helper performs these actions automatically using\n/// RAII:\n///\n///   @code{.cpp}\n///   Result foo(Error &Err) {\n///     ErrorAsOutParameter ErrAsOutParam(&Err); // 'Checked' flag set\n///     // <body of foo>\n///     // <- 'Checked' flag auto-cleared when ErrAsOutParam is destructed.\n///   }\n///   @endcode\n///\n/// ErrorAsOutParameter takes an Error* rather than Error& so that it can be\n/// used with optional Errors (Error pointers that are allowed to be null). If\n/// ErrorAsOutParameter took an Error reference, an instance would have to be\n/// created inside every condition that verified that Error was non-null. By\n/// taking an Error pointer we can just create one instance at the top of the\n/// function.\nclass ErrorAsOutParameter {\npublic:\n  ErrorAsOutParameter(Error *Err) : Err(Err) {\n    // Raise the checked bit if Err is success.\n    if (Err)\n      (void)!!*Err;\n  }\n\n  ~ErrorAsOutParameter() {\n    // Clear the checked bit.\n    if (Err && !*Err)\n      *Err = Error::success();\n  }\n\nprivate:\n  Error *Err;\n};\n\n/// Helper for Expected<T>s used as out-parameters.\n///\n/// See ErrorAsOutParameter.\ntemplate <typename T>\nclass ExpectedAsOutParameter {\npublic:\n  ExpectedAsOutParameter(Expected<T> *ValOrErr)\n    : ValOrErr(ValOrErr) {\n    if (ValOrErr)\n      (void)!!*ValOrErr;\n  }\n\n  ~ExpectedAsOutParameter() {\n    if (ValOrErr)\n      ValOrErr->setUnchecked();\n  }\n\nprivate:\n  Expected<T> *ValOrErr;\n};\n\n/// This class wraps a std::error_code in a Error.\n///\n/// This is useful if you're writing an interface that returns a Error\n/// (or Expected) and you want to call code that still returns\n/// std::error_codes.\nclass ECError : public ErrorInfo<ECError> {\n  friend Error errorCodeToError(std::error_code);\n\n  virtual void anchor() override;\n\npublic:\n  void setErrorCode(std::error_code EC) { this->EC = EC; }\n  std::error_code convertToErrorCode() const override { return EC; }\n  void log(raw_ostream &OS) const override { OS << EC.message(); }\n\n  // Used by ErrorInfo::classID.\n  static char ID;\n\nprotected:\n  ECError() = default;\n  ECError(std::error_code EC) : EC(EC) {}\n\n  std::error_code EC;\n};\n\n/// The value returned by this function can be returned from convertToErrorCode\n/// for Error values where no sensible translation to std::error_code exists.\n/// It should only be used in this situation, and should never be used where a\n/// sensible conversion to std::error_code is available, as attempts to convert\n/// to/from this error will result in a fatal error. (i.e. it is a programmatic\n///error to try to convert such a value).\nstd::error_code inconvertibleErrorCode();\n\n/// Helper for converting an std::error_code to a Error.\nError errorCodeToError(std::error_code EC);\n\n/// Helper for converting an ECError to a std::error_code.\n///\n/// This method requires that Err be Error() or an ECError, otherwise it\n/// will trigger a call to abort().\nstd::error_code errorToErrorCode(Error Err);\n\n/// Convert an ErrorOr<T> to an Expected<T>.\ntemplate <typename T> Expected<T> errorOrToExpected(ErrorOr<T> &&EO) {\n  if (auto EC = EO.getError())\n    return errorCodeToError(EC);\n  return std::move(*EO);\n}\n\n/// Convert an Expected<T> to an ErrorOr<T>.\ntemplate <typename T> ErrorOr<T> expectedToErrorOr(Expected<T> &&E) {\n  if (auto Err = E.takeError())\n    return errorToErrorCode(std::move(Err));\n  return std::move(*E);\n}\n\n/// This class wraps a string in an Error.\n///\n/// StringError is useful in cases where the client is not expected to be able\n/// to consume the specific error message programmatically (for example, if the\n/// error message is to be presented to the user).\n///\n/// StringError can also be used when additional information is to be printed\n/// along with a error_code message. Depending on the constructor called, this\n/// class can either display:\n///    1. the error_code message (ECError behavior)\n///    2. a string\n///    3. the error_code message and a string\n///\n/// These behaviors are useful when subtyping is required; for example, when a\n/// specific library needs an explicit error type. In the example below,\n/// PDBError is derived from StringError:\n///\n///   @code{.cpp}\n///   Expected<int> foo() {\n///      return llvm::make_error<PDBError>(pdb_error_code::dia_failed_loading,\n///                                        \"Additional information\");\n///   }\n///   @endcode\n///\nclass StringError : public ErrorInfo<StringError> {\npublic:\n  static char ID;\n\n  // Prints EC + S and converts to EC\n  StringError(std::error_code EC, const Twine &S = Twine());\n\n  // Prints S and converts to EC\n  StringError(const Twine &S, std::error_code EC);\n\n  void log(raw_ostream &OS) const override;\n  std::error_code convertToErrorCode() const override;\n\n  const std::string &getMessage() const { return Msg; }\n\nprivate:\n  std::string Msg;\n  std::error_code EC;\n  const bool PrintMsgOnly = false;\n};\n\n/// Create formatted StringError object.\ntemplate <typename... Ts>\ninline Error createStringError(std::error_code EC, char const *Fmt,\n                               const Ts &... Vals) {\n  std::string Buffer;\n  raw_string_ostream Stream(Buffer);\n  Stream << format(Fmt, Vals...);\n  return make_error<StringError>(Stream.str(), EC);\n}\n\nError createStringError(std::error_code EC, char const *Msg);\n\ninline Error createStringError(std::error_code EC, const Twine &S) {\n  return createStringError(EC, S.str().c_str());\n}\n\ntemplate <typename... Ts>\ninline Error createStringError(std::errc EC, char const *Fmt,\n                               const Ts &... Vals) {\n  return createStringError(std::make_error_code(EC), Fmt, Vals...);\n}\n\n/// This class wraps a filename and another Error.\n///\n/// In some cases, an error needs to live along a 'source' name, in order to\n/// show more detailed information to the user.\nclass FileError final : public ErrorInfo<FileError> {\n\n  friend Error createFileError(const Twine &, Error);\n  friend Error createFileError(const Twine &, size_t, Error);\n\npublic:\n  void log(raw_ostream &OS) const override {\n    assert(Err && !FileName.empty() && \"Trying to log after takeError().\");\n    OS << \"'\" << FileName << \"': \";\n    if (Line.hasValue())\n      OS << \"line \" << Line.getValue() << \": \";\n    Err->log(OS);\n  }\n\n  StringRef getFileName() { return FileName; }\n\n  Error takeError() { return Error(std::move(Err)); }\n\n  std::error_code convertToErrorCode() const override;\n\n  // Used by ErrorInfo::classID.\n  static char ID;\n\nprivate:\n  FileError(const Twine &F, Optional<size_t> LineNum,\n            std::unique_ptr<ErrorInfoBase> E) {\n    assert(E && \"Cannot create FileError from Error success value.\");\n    assert(!F.isTriviallyEmpty() &&\n           \"The file name provided to FileError must not be empty.\");\n    FileName = F.str();\n    Err = std::move(E);\n    Line = std::move(LineNum);\n  }\n\n  static Error build(const Twine &F, Optional<size_t> Line, Error E) {\n    std::unique_ptr<ErrorInfoBase> Payload;\n    handleAllErrors(std::move(E),\n                    [&](std::unique_ptr<ErrorInfoBase> EIB) -> Error {\n                      Payload = std::move(EIB);\n                      return Error::success();\n                    });\n    return Error(\n        std::unique_ptr<FileError>(new FileError(F, Line, std::move(Payload))));\n  }\n\n  std::string FileName;\n  Optional<size_t> Line;\n  std::unique_ptr<ErrorInfoBase> Err;\n};\n\n/// Concatenate a source file path and/or name with an Error. The resulting\n/// Error is unchecked.\ninline Error createFileError(const Twine &F, Error E) {\n  return FileError::build(F, Optional<size_t>(), std::move(E));\n}\n\n/// Concatenate a source file path and/or name with line number and an Error.\n/// The resulting Error is unchecked.\ninline Error createFileError(const Twine &F, size_t Line, Error E) {\n  return FileError::build(F, Optional<size_t>(Line), std::move(E));\n}\n\n/// Concatenate a source file path and/or name with a std::error_code \n/// to form an Error object.\ninline Error createFileError(const Twine &F, std::error_code EC) {\n  return createFileError(F, errorCodeToError(EC));\n}\n\n/// Concatenate a source file path and/or name with line number and\n/// std::error_code to form an Error object.\ninline Error createFileError(const Twine &F, size_t Line, std::error_code EC) {\n  return createFileError(F, Line, errorCodeToError(EC));\n}\n\nError createFileError(const Twine &F, ErrorSuccess) = delete;\n\n/// Helper for check-and-exit error handling.\n///\n/// For tool use only. NOT FOR USE IN LIBRARY CODE.\n///\nclass ExitOnError {\npublic:\n  /// Create an error on exit helper.\n  ExitOnError(std::string Banner = \"\", int DefaultErrorExitCode = 1)\n      : Banner(std::move(Banner)),\n        GetExitCode([=](const Error &) { return DefaultErrorExitCode; }) {}\n\n  /// Set the banner string for any errors caught by operator().\n  void setBanner(std::string Banner) { this->Banner = std::move(Banner); }\n\n  /// Set the exit-code mapper function.\n  void setExitCodeMapper(std::function<int(const Error &)> GetExitCode) {\n    this->GetExitCode = std::move(GetExitCode);\n  }\n\n  /// Check Err. If it's in a failure state log the error(s) and exit.\n  void operator()(Error Err) const { checkError(std::move(Err)); }\n\n  /// Check E. If it's in a success state then return the contained value. If\n  /// it's in a failure state log the error(s) and exit.\n  template <typename T> T operator()(Expected<T> &&E) const {\n    checkError(E.takeError());\n    return std::move(*E);\n  }\n\n  /// Check E. If it's in a success state then return the contained reference. If\n  /// it's in a failure state log the error(s) and exit.\n  template <typename T> T& operator()(Expected<T&> &&E) const {\n    checkError(E.takeError());\n    return *E;\n  }\n\nprivate:\n  void checkError(Error Err) const {\n    if (Err) {\n      int ExitCode = GetExitCode(Err);\n      logAllUnhandledErrors(std::move(Err), errs(), Banner);\n      exit(ExitCode);\n    }\n  }\n\n  std::string Banner;\n  std::function<int(const Error &)> GetExitCode;\n};\n\n/// Conversion from Error to LLVMErrorRef for C error bindings.\ninline LLVMErrorRef wrap(Error Err) {\n  return reinterpret_cast<LLVMErrorRef>(Err.takePayload().release());\n}\n\n/// Conversion from LLVMErrorRef to Error for C error bindings.\ninline Error unwrap(LLVMErrorRef ErrRef) {\n  return Error(std::unique_ptr<ErrorInfoBase>(\n      reinterpret_cast<ErrorInfoBase *>(ErrRef)));\n}\n\n} // end namespace llvm\n\n#endif // LLVM_SUPPORT_ERROR_H\n"}, "51": {"id": 51, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/Format.h", "content": "//===- Format.h - Efficient printf-style formatting for streams -*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// This file implements the format() function, which can be used with other\n// LLVM subsystems to provide printf-style formatting.  This gives all the power\n// and risk of printf.  This can be used like this (with raw_ostreams as an\n// example):\n//\n//    OS << \"mynumber: \" << format(\"%4.5f\", 1234.412) << '\\n';\n//\n// Or if you prefer:\n//\n//  OS << format(\"mynumber: %4.5f\\n\", 1234.412);\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_SUPPORT_FORMAT_H\n#define LLVM_SUPPORT_FORMAT_H\n\n#include \"llvm/ADT/ArrayRef.h\"\n#include \"llvm/ADT/STLExtras.h\"\n#include \"llvm/ADT/StringRef.h\"\n#include \"llvm/Support/DataTypes.h\"\n#include <cassert>\n#include <cstdio>\n#include <tuple>\n#include <utility>\n\nnamespace llvm {\n\n/// This is a helper class used for handling formatted output.  It is the\n/// abstract base class of a templated derived class.\nclass format_object_base {\nprotected:\n  const char *Fmt;\n  ~format_object_base() = default; // Disallow polymorphic deletion.\n  format_object_base(const format_object_base &) = default;\n  virtual void home(); // Out of line virtual method.\n\n  /// Call snprintf() for this object, on the given buffer and size.\n  virtual int snprint(char *Buffer, unsigned BufferSize) const = 0;\n\npublic:\n  format_object_base(const char *fmt) : Fmt(fmt) {}\n\n  /// Format the object into the specified buffer.  On success, this returns\n  /// the length of the formatted string.  If the buffer is too small, this\n  /// returns a length to retry with, which will be larger than BufferSize.\n  unsigned print(char *Buffer, unsigned BufferSize) const {\n    assert(BufferSize && \"Invalid buffer size!\");\n\n    // Print the string, leaving room for the terminating null.\n    int N = snprint(Buffer, BufferSize);\n\n    // VC++ and old GlibC return negative on overflow, just double the size.\n    if (N < 0)\n      return BufferSize * 2;\n\n    // Other implementations yield number of bytes needed, not including the\n    // final '\\0'.\n    if (unsigned(N) >= BufferSize)\n      return N + 1;\n\n    // Otherwise N is the length of output (not including the final '\\0').\n    return N;\n  }\n};\n\n/// These are templated helper classes used by the format function that\n/// capture the object to be formatted and the format string. When actually\n/// printed, this synthesizes the string into a temporary buffer provided and\n/// returns whether or not it is big enough.\n\n// Helper to validate that format() parameters are scalars or pointers.\ntemplate <typename... Args> struct validate_format_parameters;\ntemplate <typename Arg, typename... Args>\nstruct validate_format_parameters<Arg, Args...> {\n  static_assert(std::is_scalar<Arg>::value,\n                \"format can't be used with non fundamental / non pointer type\");\n  validate_format_parameters() { validate_format_parameters<Args...>(); }\n};\ntemplate <> struct validate_format_parameters<> {};\n\ntemplate <typename... Ts>\nclass format_object final : public format_object_base {\n  std::tuple<Ts...> Vals;\n\n  template <std::size_t... Is>\n  int snprint_tuple(char *Buffer, unsigned BufferSize,\n                    std::index_sequence<Is...>) const {\n#ifdef _MSC_VER\n    return _snprintf(Buffer, BufferSize, Fmt, std::get<Is>(Vals)...);\n#else\n    return snprintf(Buffer, BufferSize, Fmt, std::get<Is>(Vals)...);\n#endif\n  }\n\npublic:\n  format_object(const char *fmt, const Ts &... vals)\n      : format_object_base(fmt), Vals(vals...) {\n    validate_format_parameters<Ts...>();\n  }\n\n  int snprint(char *Buffer, unsigned BufferSize) const override {\n    return snprint_tuple(Buffer, BufferSize, std::index_sequence_for<Ts...>());\n  }\n};\n\n/// These are helper functions used to produce formatted output.  They use\n/// template type deduction to construct the appropriate instance of the\n/// format_object class to simplify their construction.\n///\n/// This is typically used like:\n/// \\code\n///   OS << format(\"%0.4f\", myfloat) << '\\n';\n/// \\endcode\n\ntemplate <typename... Ts>\ninline format_object<Ts...> format(const char *Fmt, const Ts &... Vals) {\n  return format_object<Ts...>(Fmt, Vals...);\n}\n\n/// This is a helper class for left_justify, right_justify, and center_justify.\nclass FormattedString {\npublic:\n  enum Justification { JustifyNone, JustifyLeft, JustifyRight, JustifyCenter };\n  FormattedString(StringRef S, unsigned W, Justification J)\n      : Str(S), Width(W), Justify(J) {}\n\nprivate:\n  StringRef Str;\n  unsigned Width;\n  Justification Justify;\n  friend class raw_ostream;\n};\n\n/// left_justify - append spaces after string so total output is\n/// \\p Width characters.  If \\p Str is larger that \\p Width, full string\n/// is written with no padding.\ninline FormattedString left_justify(StringRef Str, unsigned Width) {\n  return FormattedString(Str, Width, FormattedString::JustifyLeft);\n}\n\n/// right_justify - add spaces before string so total output is\n/// \\p Width characters.  If \\p Str is larger that \\p Width, full string\n/// is written with no padding.\ninline FormattedString right_justify(StringRef Str, unsigned Width) {\n  return FormattedString(Str, Width, FormattedString::JustifyRight);\n}\n\n/// center_justify - add spaces before and after string so total output is\n/// \\p Width characters.  If \\p Str is larger that \\p Width, full string\n/// is written with no padding.\ninline FormattedString center_justify(StringRef Str, unsigned Width) {\n  return FormattedString(Str, Width, FormattedString::JustifyCenter);\n}\n\n/// This is a helper class used for format_hex() and format_decimal().\nclass FormattedNumber {\n  uint64_t HexValue;\n  int64_t DecValue;\n  unsigned Width;\n  bool Hex;\n  bool Upper;\n  bool HexPrefix;\n  friend class raw_ostream;\n\npublic:\n  FormattedNumber(uint64_t HV, int64_t DV, unsigned W, bool H, bool U,\n                  bool Prefix)\n      : HexValue(HV), DecValue(DV), Width(W), Hex(H), Upper(U),\n        HexPrefix(Prefix) {}\n};\n\n/// format_hex - Output \\p N as a fixed width hexadecimal. If number will not\n/// fit in width, full number is still printed.  Examples:\n///   OS << format_hex(255, 4)              => 0xff\n///   OS << format_hex(255, 4, true)        => 0xFF\n///   OS << format_hex(255, 6)              => 0x00ff\n///   OS << format_hex(255, 2)              => 0xff\ninline FormattedNumber format_hex(uint64_t N, unsigned Width,\n                                  bool Upper = false) {\n  assert(Width <= 18 && \"hex width must be <= 18\");\n  return FormattedNumber(N, 0, Width, true, Upper, true);\n}\n\n/// format_hex_no_prefix - Output \\p N as a fixed width hexadecimal. Does not\n/// prepend '0x' to the outputted string.  If number will not fit in width,\n/// full number is still printed.  Examples:\n///   OS << format_hex_no_prefix(255, 2)              => ff\n///   OS << format_hex_no_prefix(255, 2, true)        => FF\n///   OS << format_hex_no_prefix(255, 4)              => 00ff\n///   OS << format_hex_no_prefix(255, 1)              => ff\ninline FormattedNumber format_hex_no_prefix(uint64_t N, unsigned Width,\n                                            bool Upper = false) {\n  assert(Width <= 16 && \"hex width must be <= 16\");\n  return FormattedNumber(N, 0, Width, true, Upper, false);\n}\n\n/// format_decimal - Output \\p N as a right justified, fixed-width decimal. If\n/// number will not fit in width, full number is still printed.  Examples:\n///   OS << format_decimal(0, 5)     => \"    0\"\n///   OS << format_decimal(255, 5)   => \"  255\"\n///   OS << format_decimal(-1, 3)    => \" -1\"\n///   OS << format_decimal(12345, 3) => \"12345\"\ninline FormattedNumber format_decimal(int64_t N, unsigned Width) {\n  return FormattedNumber(0, N, Width, false, false, false);\n}\n\nclass FormattedBytes {\n  ArrayRef<uint8_t> Bytes;\n\n  // If not None, display offsets for each line relative to starting value.\n  Optional<uint64_t> FirstByteOffset;\n  uint32_t IndentLevel;  // Number of characters to indent each line.\n  uint32_t NumPerLine;   // Number of bytes to show per line.\n  uint8_t ByteGroupSize; // How many hex bytes are grouped without spaces\n  bool Upper;            // Show offset and hex bytes as upper case.\n  bool ASCII;            // Show the ASCII bytes for the hex bytes to the right.\n  friend class raw_ostream;\n\npublic:\n  FormattedBytes(ArrayRef<uint8_t> B, uint32_t IL, Optional<uint64_t> O,\n                 uint32_t NPL, uint8_t BGS, bool U, bool A)\n      : Bytes(B), FirstByteOffset(O), IndentLevel(IL), NumPerLine(NPL),\n        ByteGroupSize(BGS), Upper(U), ASCII(A) {\n\n    if (ByteGroupSize > NumPerLine)\n      ByteGroupSize = NumPerLine;\n  }\n};\n\ninline FormattedBytes\nformat_bytes(ArrayRef<uint8_t> Bytes, Optional<uint64_t> FirstByteOffset = None,\n             uint32_t NumPerLine = 16, uint8_t ByteGroupSize = 4,\n             uint32_t IndentLevel = 0, bool Upper = false) {\n  return FormattedBytes(Bytes, IndentLevel, FirstByteOffset, NumPerLine,\n                        ByteGroupSize, Upper, false);\n}\n\ninline FormattedBytes\nformat_bytes_with_ascii(ArrayRef<uint8_t> Bytes,\n                        Optional<uint64_t> FirstByteOffset = None,\n                        uint32_t NumPerLine = 16, uint8_t ByteGroupSize = 4,\n                        uint32_t IndentLevel = 0, bool Upper = false) {\n  return FormattedBytes(Bytes, IndentLevel, FirstByteOffset, NumPerLine,\n                        ByteGroupSize, Upper, true);\n}\n\n} // end namespace llvm\n\n#endif\n"}, "52": {"id": 52, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/MemoryBufferRef.h", "content": "//===- MemoryBufferRef.h - Memory Buffer Reference --------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n//  This file defines the MemoryBuffer interface.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_SUPPORT_MEMORYBUFFERREF_H\n#define LLVM_SUPPORT_MEMORYBUFFERREF_H\n\n#include \"llvm/ADT/StringRef.h\"\n\nnamespace llvm {\n\nclass MemoryBuffer;\n\nclass MemoryBufferRef {\n  StringRef Buffer;\n  StringRef Identifier;\n\npublic:\n  MemoryBufferRef() = default;\n  MemoryBufferRef(const MemoryBuffer &Buffer);\n  MemoryBufferRef(StringRef Buffer, StringRef Identifier)\n      : Buffer(Buffer), Identifier(Identifier) {}\n\n  StringRef getBuffer() const { return Buffer; }\n  StringRef getBufferIdentifier() const { return Identifier; }\n\n  const char *getBufferStart() const { return Buffer.begin(); }\n  const char *getBufferEnd() const { return Buffer.end(); }\n  size_t getBufferSize() const { return Buffer.size(); }\n\n  /// Check pointer identity (not value) of identifier and data.\n  friend bool operator==(const MemoryBufferRef &LHS,\n                         const MemoryBufferRef &RHS) {\n    return LHS.Buffer.begin() == RHS.Buffer.begin() &&\n           LHS.Buffer.end() == RHS.Buffer.end() &&\n           LHS.Identifier.begin() == RHS.Identifier.begin() &&\n           LHS.Identifier.end() == RHS.Identifier.end();\n  }\n\n  friend bool operator!=(const MemoryBufferRef &LHS,\n                         const MemoryBufferRef &RHS) {\n    return !(LHS == RHS);\n  }\n};\n\n} // namespace llvm\n\n#endif // LLVM_SUPPORT_MEMORYBUFFERREF_H\n"}, "54": {"id": 54, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/ScopedPrinter.h", "content": "//===-- ScopedPrinter.h ----------------------------------------*- C++ -*--===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_SUPPORT_SCOPEDPRINTER_H\n#define LLVM_SUPPORT_SCOPEDPRINTER_H\n\n#include \"llvm/ADT/APSInt.h\"\n#include \"llvm/ADT/ArrayRef.h\"\n#include \"llvm/ADT/SmallVector.h\"\n#include \"llvm/ADT/StringExtras.h\"\n#include \"llvm/ADT/StringRef.h\"\n#include \"llvm/Support/DataTypes.h\"\n#include \"llvm/Support/Endian.h\"\n#include \"llvm/Support/raw_ostream.h\"\n#include <algorithm>\n\nnamespace llvm {\n\ntemplate <typename T> struct EnumEntry {\n  StringRef Name;\n  // While Name suffices in most of the cases, in certain cases\n  // GNU style and LLVM style of ELFDumper do not\n  // display same string for same enum. The AltName if initialized appropriately\n  // will hold the string that GNU style emits.\n  // Example:\n  // \"EM_X86_64\" string on LLVM style for Elf_Ehdr->e_machine corresponds to\n  // \"Advanced Micro Devices X86-64\" on GNU style\n  StringRef AltName;\n  T Value;\n  EnumEntry(StringRef N, StringRef A, T V) : Name(N), AltName(A), Value(V) {}\n  EnumEntry(StringRef N, T V) : Name(N), AltName(N), Value(V) {}\n};\n\nstruct HexNumber {\n  // To avoid sign-extension we have to explicitly cast to the appropriate\n  // unsigned type. The overloads are here so that every type that is implicitly\n  // convertible to an integer (including enums and endian helpers) can be used\n  // without requiring type traits or call-site changes.\n  HexNumber(char Value) : Value(static_cast<unsigned char>(Value)) {}\n  HexNumber(signed char Value) : Value(static_cast<unsigned char>(Value)) {}\n  HexNumber(signed short Value) : Value(static_cast<unsigned short>(Value)) {}\n  HexNumber(signed int Value) : Value(static_cast<unsigned int>(Value)) {}\n  HexNumber(signed long Value) : Value(static_cast<unsigned long>(Value)) {}\n  HexNumber(signed long long Value)\n      : Value(static_cast<unsigned long long>(Value)) {}\n  HexNumber(unsigned char Value) : Value(Value) {}\n  HexNumber(unsigned short Value) : Value(Value) {}\n  HexNumber(unsigned int Value) : Value(Value) {}\n  HexNumber(unsigned long Value) : Value(Value) {}\n  HexNumber(unsigned long long Value) : Value(Value) {}\n  uint64_t Value;\n};\n\nraw_ostream &operator<<(raw_ostream &OS, const HexNumber &Value);\nstd::string to_hexString(uint64_t Value, bool UpperCase = true);\n\ntemplate <class T> std::string to_string(const T &Value) {\n  std::string number;\n  llvm::raw_string_ostream stream(number);\n  stream << Value;\n  return stream.str();\n}\n\nclass ScopedPrinter {\npublic:\n  ScopedPrinter(raw_ostream &OS) : OS(OS), IndentLevel(0) {}\n\n  void flush() { OS.flush(); }\n\n  void indent(int Levels = 1) { IndentLevel += Levels; }\n\n  void unindent(int Levels = 1) {\n    IndentLevel = std::max(0, IndentLevel - Levels);\n  }\n\n  void resetIndent() { IndentLevel = 0; }\n\n  int getIndentLevel() { return IndentLevel; }\n\n  void setPrefix(StringRef P) { Prefix = P; }\n\n  void printIndent() {\n    OS << Prefix;\n    for (int i = 0; i < IndentLevel; ++i)\n      OS << \"  \";\n  }\n\n  template <typename T> HexNumber hex(T Value) { return HexNumber(Value); }\n\n  template <typename T, typename TEnum>\n  void printEnum(StringRef Label, T Value,\n                 ArrayRef<EnumEntry<TEnum>> EnumValues) {\n    StringRef Name;\n    bool Found = false;\n    for (const auto &EnumItem : EnumValues) {\n      if (EnumItem.Value == Value) {\n        Name = EnumItem.Name;\n        Found = true;\n        break;\n      }\n    }\n\n    if (Found) {\n      startLine() << Label << \": \" << Name << \" (\" << hex(Value) << \")\\n\";\n    } else {\n      startLine() << Label << \": \" << hex(Value) << \"\\n\";\n    }\n  }\n\n  template <typename T, typename TFlag>\n  void printFlags(StringRef Label, T Value, ArrayRef<EnumEntry<TFlag>> Flags,\n                  TFlag EnumMask1 = {}, TFlag EnumMask2 = {},\n                  TFlag EnumMask3 = {}) {\n    typedef EnumEntry<TFlag> FlagEntry;\n    typedef SmallVector<FlagEntry, 10> FlagVector;\n    FlagVector SetFlags;\n\n    for (const auto &Flag : Flags) {\n      if (Flag.Value == 0)\n        continue;\n\n      TFlag EnumMask{};\n      if (Flag.Value & EnumMask1)\n        EnumMask = EnumMask1;\n      else if (Flag.Value & EnumMask2)\n        EnumMask = EnumMask2;\n      else if (Flag.Value & EnumMask3)\n        EnumMask = EnumMask3;\n      bool IsEnum = (Flag.Value & EnumMask) != 0;\n      if ((!IsEnum && (Value & Flag.Value) == Flag.Value) ||\n          (IsEnum && (Value & EnumMask) == Flag.Value)) {\n        SetFlags.push_back(Flag);\n      }\n    }\n\n    llvm::sort(SetFlags, &flagName<TFlag>);\n\n    startLine() << Label << \" [ (\" << hex(Value) << \")\\n\";\n    for (const auto &Flag : SetFlags) {\n      startLine() << \"  \" << Flag.Name << \" (\" << hex(Flag.Value) << \")\\n\";\n    }\n    startLine() << \"]\\n\";\n  }\n\n  template <typename T> void printFlags(StringRef Label, T Value) {\n    startLine() << Label << \" [ (\" << hex(Value) << \")\\n\";\n    uint64_t Flag = 1;\n    uint64_t Curr = Value;\n    while (Curr > 0) {\n      if (Curr & 1)\n        startLine() << \"  \" << hex(Flag) << \"\\n\";\n      Curr >>= 1;\n      Flag <<= 1;\n    }\n    startLine() << \"]\\n\";\n  }\n\n  void printNumber(StringRef Label, uint64_t Value) {\n    startLine() << Label << \": \" << Value << \"\\n\";\n  }\n\n  void printNumber(StringRef Label, uint32_t Value) {\n    startLine() << Label << \": \" << Value << \"\\n\";\n  }\n\n  void printNumber(StringRef Label, uint16_t Value) {\n    startLine() << Label << \": \" << Value << \"\\n\";\n  }\n\n  void printNumber(StringRef Label, uint8_t Value) {\n    startLine() << Label << \": \" << unsigned(Value) << \"\\n\";\n  }\n\n  void printNumber(StringRef Label, int64_t Value) {\n    startLine() << Label << \": \" << Value << \"\\n\";\n  }\n\n  void printNumber(StringRef Label, int32_t Value) {\n    startLine() << Label << \": \" << Value << \"\\n\";\n  }\n\n  void printNumber(StringRef Label, int16_t Value) {\n    startLine() << Label << \": \" << Value << \"\\n\";\n  }\n\n  void printNumber(StringRef Label, int8_t Value) {\n    startLine() << Label << \": \" << int(Value) << \"\\n\";\n  }\n\n  void printNumber(StringRef Label, const APSInt &Value) {\n    startLine() << Label << \": \" << Value << \"\\n\";\n  }\n\n  void printBoolean(StringRef Label, bool Value) {\n    startLine() << Label << \": \" << (Value ? \"Yes\" : \"No\") << '\\n';\n  }\n\n  template <typename... T> void printVersion(StringRef Label, T... Version) {\n    startLine() << Label << \": \";\n    printVersionInternal(Version...);\n    getOStream() << \"\\n\";\n  }\n\n  template <typename T> void printList(StringRef Label, const T &List) {\n    startLine() << Label << \": [\";\n    ListSeparator LS;\n    for (const auto &Item : List)\n      OS << LS << Item;\n    OS << \"]\\n\";\n  }\n\n  template <typename T, typename U>\n  void printList(StringRef Label, const T &List, const U &Printer) {\n    startLine() << Label << \": [\";\n    ListSeparator LS;\n    for (const auto &Item : List) {\n      OS << LS;\n      Printer(OS, Item);\n    }\n    OS << \"]\\n\";\n  }\n\n  template <typename T> void printHexList(StringRef Label, const T &List) {\n    startLine() << Label << \": [\";\n    ListSeparator LS;\n    for (const auto &Item : List)\n      OS << LS << hex(Item);\n    OS << \"]\\n\";\n  }\n\n  template <typename T> void printHex(StringRef Label, T Value) {\n    startLine() << Label << \": \" << hex(Value) << \"\\n\";\n  }\n\n  template <typename T> void printHex(StringRef Label, StringRef Str, T Value) {\n    startLine() << Label << \": \" << Str << \" (\" << hex(Value) << \")\\n\";\n  }\n\n  template <typename T>\n  void printSymbolOffset(StringRef Label, StringRef Symbol, T Value) {\n    startLine() << Label << \": \" << Symbol << '+' << hex(Value) << '\\n';\n  }\n\n  void printString(StringRef Value) { startLine() << Value << \"\\n\"; }\n\n  void printString(StringRef Label, StringRef Value) {\n    startLine() << Label << \": \" << Value << \"\\n\";\n  }\n\n  void printString(StringRef Label, const std::string &Value) {\n    printString(Label, StringRef(Value));\n  }\n\n  void printString(StringRef Label, const char* Value) {\n    printString(Label, StringRef(Value));\n  }\n\n  template <typename T>\n  void printNumber(StringRef Label, StringRef Str, T Value) {\n    startLine() << Label << \": \" << Str << \" (\" << Value << \")\\n\";\n  }\n\n  void printBinary(StringRef Label, StringRef Str, ArrayRef<uint8_t> Value) {\n    printBinaryImpl(Label, Str, Value, false);\n  }\n\n  void printBinary(StringRef Label, StringRef Str, ArrayRef<char> Value) {\n    auto V = makeArrayRef(reinterpret_cast<const uint8_t *>(Value.data()),\n                          Value.size());\n    printBinaryImpl(Label, Str, V, false);\n  }\n\n  void printBinary(StringRef Label, ArrayRef<uint8_t> Value) {\n    printBinaryImpl(Label, StringRef(), Value, false);\n  }\n\n  void printBinary(StringRef Label, ArrayRef<char> Value) {\n    auto V = makeArrayRef(reinterpret_cast<const uint8_t *>(Value.data()),\n                          Value.size());\n    printBinaryImpl(Label, StringRef(), V, false);\n  }\n\n  void printBinary(StringRef Label, StringRef Value) {\n    auto V = makeArrayRef(reinterpret_cast<const uint8_t *>(Value.data()),\n                          Value.size());\n    printBinaryImpl(Label, StringRef(), V, false);\n  }\n\n  void printBinaryBlock(StringRef Label, ArrayRef<uint8_t> Value,\n                        uint32_t StartOffset) {\n    printBinaryImpl(Label, StringRef(), Value, true, StartOffset);\n  }\n\n  void printBinaryBlock(StringRef Label, ArrayRef<uint8_t> Value) {\n    printBinaryImpl(Label, StringRef(), Value, true);\n  }\n\n  void printBinaryBlock(StringRef Label, StringRef Value) {\n    auto V = makeArrayRef(reinterpret_cast<const uint8_t *>(Value.data()),\n                          Value.size());\n    printBinaryImpl(Label, StringRef(), V, true);\n  }\n\n  template <typename T> void printObject(StringRef Label, const T &Value) {\n    startLine() << Label << \": \" << Value << \"\\n\";\n  }\n\n  raw_ostream &startLine() {\n    printIndent();\n    return OS;\n  }\n\n  raw_ostream &getOStream() { return OS; }\n\nprivate:\n  template <typename T> void printVersionInternal(T Value) {\n    getOStream() << Value;\n  }\n\n  template <typename S, typename T, typename... TArgs>\n  void printVersionInternal(S Value, T Value2, TArgs... Args) {\n    getOStream() << Value << \".\";\n    printVersionInternal(Value2, Args...);\n  }\n\n  template <typename T>\n  static bool flagName(const EnumEntry<T> &lhs, const EnumEntry<T> &rhs) {\n    return lhs.Name < rhs.Name;\n  }\n\n  void printBinaryImpl(StringRef Label, StringRef Str, ArrayRef<uint8_t> Value,\n                       bool Block, uint32_t StartOffset = 0);\n\n  raw_ostream &OS;\n  int IndentLevel;\n  StringRef Prefix;\n};\n\ntemplate <>\ninline void\nScopedPrinter::printHex<support::ulittle16_t>(StringRef Label,\n                                              support::ulittle16_t Value) {\n  startLine() << Label << \": \" << hex(Value) << \"\\n\";\n}\n\ntemplate<char Open, char Close>\nstruct DelimitedScope {\n  explicit DelimitedScope(ScopedPrinter &W) : W(W) {\n    W.startLine() << Open << '\\n';\n    W.indent();\n  }\n\n  DelimitedScope(ScopedPrinter &W, StringRef N) : W(W) {\n    W.startLine() << N;\n    if (!N.empty())\n      W.getOStream() << ' ';\n    W.getOStream() << Open << '\\n';\n    W.indent();\n  }\n\n  ~DelimitedScope() {\n    W.unindent();\n    W.startLine() << Close << '\\n';\n  }\n\n  ScopedPrinter &W;\n};\n\nusing DictScope = DelimitedScope<'{', '}'>;\nusing ListScope = DelimitedScope<'[', ']'>;\n\n} // namespace llvm\n\n#endif\n"}}, "reports": [{"events": [{"location": {"col": 33, "file": 10, "line": 39}, "message": "destructor '~ilist_node_impl' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/ilist_node.h", "reportHash": "6a25b035ab3e69051cbe475016431060", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 10, "line": 148}, "message": "destructor '~ilist_node' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/ilist_node.h", "reportHash": "ed1bcc413a64fbebe1f630aefc48b022", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 10, "line": 256}, "message": "destructor '~ilist_node_with_parent' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/ilist_node.h", "reportHash": "556f5307ef95f8fcf4862e6fba53ff4a", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 19, "file": 11, "line": 21}, "message": "destructor '~ilist_node_base' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/ilist_node_base.h", "reportHash": "c6c3cff27c803dd031ab0c97d6d5b2b4", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 12, "line": 67}, "message": "default constructor 'iterator_facade_base' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/iterator.h", "reportHash": "c32d83bdbea1b008dc97394e249ddc28", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 12, "line": 67}, "message": "destructor '~iterator_facade_base' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/iterator.h", "reportHash": "898648c59dc1fc9cdbc7450dc4f97a12", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 12, "line": 67}, "message": "move constructor 'iterator_facade_base' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/iterator.h", "reportHash": "8806462d3286b7348dab209c1707ae44", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 14, "line": 648}, "message": "destructor '~FormParams' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/BinaryFormat/Dwarf.h", "reportHash": "dfba947681949705d8412ccc221ae4d5", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 14, "line": 648}, "message": "move assignment operator 'operator=' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/BinaryFormat/Dwarf.h", "reportHash": "5117ede9e183ffc92aba968fb193c352", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 14, "line": 648}, "message": "move constructor 'FormParams' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/BinaryFormat/Dwarf.h", "reportHash": "d92a27a9715a12bbd2ceb406d6172594", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 15, "line": 530}, "message": "destructor '~load_command' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/BinaryFormat/MachO.h", "reportHash": "54f67d80dc9c9c27b6c537e65004df89", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 15, "line": 530}, "message": "move constructor 'load_command' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/BinaryFormat/MachO.h", "reportHash": "cf871bfa5a82837f8fa0e5dd448820b4", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 15, "line": 805}, "message": "destructor '~data_in_code_entry' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/BinaryFormat/MachO.h", "reportHash": "5c069a6d9dc5d28d897a84848f3548b6", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 15, "line": 805}, "message": "move constructor 'data_in_code_entry' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/BinaryFormat/MachO.h", "reportHash": "916c0c82004e6c4a098d78866191345b", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 16, "line": 20}, "message": "destructor '~file_magic' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/BinaryFormat/Magic.h", "reportHash": "f653fd751c4c7039691122c804d2348a", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 16, "line": 20}, "message": "move constructor 'file_magic' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/BinaryFormat/Magic.h", "reportHash": "1c4f882f9a3fb78b0223dcfc40208dfa", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 17, "line": 92}, "message": "destructor '~WasmGlobalType' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/BinaryFormat/Wasm.h", "reportHash": "0e01c1ff4b6f708355cb3043a0d4bbfa", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 17, "line": 92}, "message": "move assignment operator 'operator=' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/BinaryFormat/Wasm.h", "reportHash": "6462ff992ba258be80ae704d919372f7", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 17, "line": 92}, "message": "move constructor 'WasmGlobalType' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/BinaryFormat/Wasm.h", "reportHash": "67756ae31940dae3812e4bf0d915e303", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 17, "line": 104}, "message": "destructor '~WasmEventType' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/BinaryFormat/Wasm.h", "reportHash": "c511275a938396ed7d7bbd95b8df27e9", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 17, "line": 104}, "message": "move assignment operator 'operator=' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/BinaryFormat/Wasm.h", "reportHash": "0d8e20bc513889aa00d12cd7c628a6e7", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 17, "line": 104}, "message": "move constructor 'WasmEventType' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/BinaryFormat/Wasm.h", "reportHash": "5e4b8ace7a8074e16612e891688e2447", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 18, "line": 31}, "message": "destructor '~DILineInfo' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/DebugInfo/DIContext.h", "reportHash": "5437d63967a6fda16a3e6b54dc2537bb", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 18, "line": 31}, "message": "move assignment operator 'operator=' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/DebugInfo/DIContext.h", "reportHash": "afe1bd108c27c5d8037293ecec7c13be", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 18, "line": 31}, "message": "move constructor 'DILineInfo' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/DebugInfo/DIContext.h", "reportHash": "6e292c2f4a42dc405a16e88a2aa954e5", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 18, "line": 142}, "message": "destructor '~DILineInfoSpecifier' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/DebugInfo/DIContext.h", "reportHash": "6396268d11a71fb098eeb1059667522d", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 18, "line": 142}, "message": "move constructor 'DILineInfoSpecifier' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/DebugInfo/DIContext.h", "reportHash": "5da22e21e60c3477d9bf23a8fe247462", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 18, "line": 187}, "message": "destructor '~DIDumpOptions' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/DebugInfo/DIContext.h", "reportHash": "0ee8073dd346596aaf57d43cffb218e9", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 18, "line": 187}, "message": "move constructor 'DIDumpOptions' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/DebugInfo/DIContext.h", "reportHash": "7b7f6bf8f96b93dad4ef337c843c8c38", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 10, "file": 19, "line": 29}, "message": "destructor '~AttributeSpec' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/DebugInfo/DWARF/DWARFAbbreviationDeclaration.h", "reportHash": "02e11c0e8ceccef9b89456b75a9981dc", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 10, "file": 19, "line": 29}, "message": "move constructor 'AttributeSpec' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/DebugInfo/DWARF/DWARFAbbreviationDeclaration.h", "reportHash": "736e95b1403216df0882bb42e11498b6", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 12, "file": 19, "line": 59}, "message": "destructor '~ByteSizeStorage' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/DebugInfo/DWARF/DWARFAbbreviationDeclaration.h", "reportHash": "2cd8357880bebf1c6441848236fb7750", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 12, "file": 19, "line": 59}, "message": "move constructor 'ByteSizeStorage' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/DebugInfo/DWARF/DWARFAbbreviationDeclaration.h", "reportHash": "119f69729f546de882a052a79d2a6618", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 5, "file": 19, "line": 63}, "message": "destructor '~' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/DebugInfo/DWARF/DWARFAbbreviationDeclaration.h", "reportHash": "bdb4e55ad3c19a33523e537e818ec207", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 5, "file": 19, "line": 63}, "message": "move constructor '' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/DebugInfo/DWARF/DWARFAbbreviationDeclaration.h", "reportHash": "b13f7f518140666820997598fc7571ce", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 10, "file": 19, "line": 160}, "message": "destructor '~FixedSizeInfo' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/DebugInfo/DWARF/DWARFAbbreviationDeclaration.h", "reportHash": "d50df97bcd50c64c59978ef82a6938ad", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 10, "file": 19, "line": 160}, "message": "move assignment operator 'operator=' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/DebugInfo/DWARF/DWARFAbbreviationDeclaration.h", "reportHash": "44fce1b96bd89220166c2208faccfda9", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 10, "file": 19, "line": 160}, "message": "move constructor 'FixedSizeInfo' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/DebugInfo/DWARF/DWARFAbbreviationDeclaration.h", "reportHash": "283130269f3c9b18b86171eb7dd5936e", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 20, "line": 22}, "message": "destructor '~DWARFAddressRange' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/DebugInfo/DWARF/DWARFAddressRange.h", "reportHash": "b7ef5b831d8ee2a981e7eff5a055ed72", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 20, "line": 22}, "message": "move assignment operator 'operator=' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/DebugInfo/DWARF/DWARFAddressRange.h", "reportHash": "36a917f12212d6c27cee804dcbbec660", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 20, "line": 22}, "message": "move constructor 'DWARFAddressRange' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/DebugInfo/DWARF/DWARFAddressRange.h", "reportHash": "3030e17c1c54c193fbe62f545c47005a", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 21, "line": 21}, "message": "destructor '~DWARFDataExtractor' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/DebugInfo/DWARF/DWARFDataExtractor.h", "reportHash": "d6939376d4ac45b20c0b326b18bda5f6", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 21, "line": 21}, "message": "move assignment operator 'operator=' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/DebugInfo/DWARF/DWARFDataExtractor.h", "reportHash": "eb9b1b6ab90da0fa9514a4e3855805cd", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 21, "line": 21}, "message": "move constructor 'DWARFDataExtractor' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/DebugInfo/DWARF/DWARFDataExtractor.h", "reportHash": "08a05894a0151618822af7c59ef0a9c7", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 22, "line": 27}, "message": "destructor '~DWARFLocationEntry' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/DebugInfo/DWARF/DWARFDebugLoc.h", "reportHash": "655ad3e4a7b35df5fe234f85c7b39a07", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 22, "line": 85}, "message": "destructor '~DWARFDebugLoc' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/DebugInfo/DWARF/DWARFDebugLoc.h", "reportHash": "bd4b5fc196c736c744f37dc3aabbfe2a", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 10, "file": 22, "line": 88}, "message": "destructor '~LocationList' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/DebugInfo/DWARF/DWARFDebugLoc.h", "reportHash": "ef0de39e68d0716fe72520e3a0c181a3", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 22, "line": 122}, "message": "destructor '~DWARFDebugLoclists' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/DebugInfo/DWARF/DWARFDebugLoc.h", "reportHash": "6f50faf118749ad77c477beac48a24cc", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 10, "file": 23, "line": 24}, "message": "destructor '~RangeListEntry' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/DebugInfo/DWARF/DWARFDebugRangeList.h", "reportHash": "5c4f902962f6e49f8a6ba52895ef7ebc", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 24, "line": 28}, "message": "destructor '~RangeListEntry' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/DebugInfo/DWARF/DWARFDebugRnglists.h", "reportHash": "82f3e73c96262c02784b45afdef121f5", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 24, "line": 45}, "message": "destructor '~DWARFDebugRnglist' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/DebugInfo/DWARF/DWARFDebugRnglists.h", "reportHash": "131058acf69d90088b5a856e00935ecc", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 25, "line": 43}, "message": "destructor '~DWARFDie' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/DebugInfo/DWARF/DWARFDie.h", "reportHash": "337a817bc508c11e8223d3518419e36e", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 25, "line": 43}, "message": "move assignment operator 'operator=' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/DebugInfo/DWARF/DWARFDie.h", "reportHash": "074463b5a34f9373789ccca48ffc3e03", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 25, "line": 43}, "message": "move constructor 'DWARFDie' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/DebugInfo/DWARF/DWARFDie.h", "reportHash": "d23a4148ffa65c194124392b199faecc", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 17, "file": 25, "line": 353}, "message": "destructor '~iterator' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/DebugInfo/DWARF/DWARFDie.h", "reportHash": "5b63b9a900a6f75376ca796b907c261a", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 17, "file": 25, "line": 353}, "message": "move constructor 'iterator' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/DebugInfo/DWARF/DWARFDie.h", "reportHash": "05a9b661c861b3021f5bbbc26c383f5f", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 25, "line": 404}, "message": "destructor '~reverse_iterator' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/DebugInfo/DWARF/DWARFDie.h", "reportHash": "7f466abe5bf40cced8c5b2a0ece0615d", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 25, "line": 404}, "message": "move constructor 'reverse_iterator' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/DebugInfo/DWARF/DWARFDie.h", "reportHash": "c7e0a55c39232caae2292759a151eef7", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 26, "line": 26}, "message": "destructor '~DWARFFormValue' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/DebugInfo/DWARF/DWARFFormValue.h", "reportHash": "b08cad51d49c34cc8dc94081d6421d97", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 26, "line": 26}, "message": "move assignment operator 'operator=' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/DebugInfo/DWARF/DWARFFormValue.h", "reportHash": "a92a499965ec4566d5c46863b3c50bee", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 26, "line": 26}, "message": "move constructor 'DWARFFormValue' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/DebugInfo/DWARF/DWARFFormValue.h", "reportHash": "2c1659e0513f2c4778344df810cb63f4", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 10, "file": 26, "line": 42}, "message": "destructor '~ValueType' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/DebugInfo/DWARF/DWARFFormValue.h", "reportHash": "31094f3b03efd60564257d57b1aabc26", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 10, "file": 26, "line": 42}, "message": "move assignment operator 'operator=' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/DebugInfo/DWARF/DWARFFormValue.h", "reportHash": "39fbffb24600650c1a32637a2af1312c", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 10, "file": 26, "line": 42}, "message": "move constructor 'ValueType' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/DebugInfo/DWARF/DWARFFormValue.h", "reportHash": "474779694aa54df982814d8e6ab0bc01", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 5, "file": 26, "line": 48}, "message": "destructor '~' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/DebugInfo/DWARF/DWARFFormValue.h", "reportHash": "2817bfee82c319f27530160ef96b5b2c", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 5, "file": 26, "line": 48}, "message": "move assignment operator 'operator=' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/DebugInfo/DWARF/DWARFFormValue.h", "reportHash": "38214e093aa15cf3d1f5ce86ea19be6d", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 5, "file": 26, "line": 48}, "message": "move constructor '' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/DebugInfo/DWARF/DWARFFormValue.h", "reportHash": "7c29c8c776fc6580d1ba71ff6d6fff93", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 27, "line": 27}, "message": "destructor '~DWARFListEntryBase' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/DebugInfo/DWARF/DWARFListTable.h", "reportHash": "16ed2e19ec0cad5097e89210b3c41815", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 41, "file": 27, "line": 38}, "message": "destructor '~DWARFListType' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/DebugInfo/DWARF/DWARFListTable.h", "reportHash": "211a6914a79fb0ca544d98aec919cc52", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 27, "line": 56}, "message": "destructor '~DWARFListTableHeader' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/DebugInfo/DWARF/DWARFListTable.h", "reportHash": "5ac9881de654a0409c8ff062d65954e0", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 10, "file": 27, "line": 57}, "message": "default constructor 'Header' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/DebugInfo/DWARF/DWARFListTable.h", "reportHash": "b99ac245c73067f73ccba2b7fdd91626", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 10, "file": 27, "line": 57}, "message": "destructor '~Header' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/DebugInfo/DWARF/DWARFListTable.h", "reportHash": "71c35543b5f5004addd1be8e18db225d", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 10, "file": 27, "line": 57}, "message": "move assignment operator 'operator=' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/DebugInfo/DWARF/DWARFListTable.h", "reportHash": "262751fcc0f249ee28f8fd564044a8c5", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 41, "file": 27, "line": 146}, "message": "destructor '~DWARFListTableBase' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/DebugInfo/DWARF/DWARFListTable.h", "reportHash": "2fc8352cd807567e3ee788dda43911a1", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 28, "line": 179}, "message": "destructor '~StrOffsetsContributionDescriptor' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/DebugInfo/DWARF/DWARFUnit.h", "reportHash": "c616df52eb14708d0c727e1c17328bd4", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 28, "line": 179}, "message": "move assignment operator 'operator=' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/DebugInfo/DWARF/DWARFUnit.h", "reportHash": "86e6d77e5a379809377c728a0a83ff4c", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 28, "line": 179}, "message": "move constructor 'StrOffsetsContributionDescriptor' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/DebugInfo/DWARF/DWARFUnit.h", "reportHash": "26caab728d58f60102aea5635b2ca7ff", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 41, "file": 28, "line": 474}, "message": "destructor '~' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/DebugInfo/DWARF/DWARFUnit.h", "reportHash": "64fb768b33586b136549688b58b7b50f", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 41, "file": 28, "line": 474}, "message": "move constructor '' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/DebugInfo/DWARF/DWARFUnit.h", "reportHash": "8a2123b34327e8f969c8f682dc06b9b3", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 10, "file": 29, "line": 81}, "message": "default constructor 'Header' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/DebugInfo/DWARF/DWARFUnitIndex.h", "reportHash": "01724b2bf47e5620765d6e1ce0264d8c", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 9, "file": 29, "line": 92}, "message": "destructor '~Entry' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/DebugInfo/DWARF/DWARFUnitIndex.h", "reportHash": "13a4ecd66864411e4c5e08469997447e", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 30, "line": 35}, "message": "destructor '~MCExpr' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/MC/MCExpr.h", "reportHash": "adf66ce3cd53b21c8850bd3d5003e97c", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 31, "line": 81}, "message": "default constructor 'MCFixup' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/MC/MCFixup.h", "reportHash": "302d2c59bb813478a3691f236a6440d1", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 31, "line": 81}, "message": "destructor '~MCFixup' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/MC/MCFixup.h", "reportHash": "93937f363bcf062350cf90a1635b8d8e", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 31, "line": 81}, "message": "move constructor 'MCFixup' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/MC/MCFixup.h", "reportHash": "0b84653974490324238379c6524bfd59", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 32, "line": 31}, "message": "destructor '~MCFragment' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/MC/MCFragment.h", "reportHash": "5dcfd20c6a871cbb0e4493b13a53b01d", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 32, "line": 125}, "message": "destructor '~MCEncodedFragment' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/MC/MCFragment.h", "reportHash": "e106888d77e05e9a6bdcb21fd41daaa0", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 32, "line": 187}, "message": "destructor '~MCEncodedFragmentWithContents' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/MC/MCFragment.h", "reportHash": "0c870e7dc8d22bf6b08911d68ac879a6", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 32, "line": 205}, "message": "destructor '~MCEncodedFragmentWithFixups' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/MC/MCFragment.h", "reportHash": "a9378442711389564425014ec9dc8392", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 33, "line": 35}, "message": "destructor '~MCOperand' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/MC/MCInst.h", "reportHash": "615dd80dea88c45ec21beb220500c73e", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 33, "line": 35}, "message": "move assignment operator 'operator=' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/MC/MCInst.h", "reportHash": "0443e5e110cd2519a63e182025e63cc8", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 33, "line": 35}, "message": "move constructor 'MCOperand' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/MC/MCInst.h", "reportHash": "adf8a36a1abb7e0ec8b58c0c17bf67f4", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 33, "line": 47}, "message": "destructor '~' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/MC/MCInst.h", "reportHash": "7f3194615de92d556e1e707850e7bf08", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 33, "line": 47}, "message": "move assignment operator 'operator=' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/MC/MCInst.h", "reportHash": "b4d0c9f94b4cf78bfe056e098dae1a9b", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 33, "line": 47}, "message": "move constructor '' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/MC/MCInst.h", "reportHash": "5a1400b7f040982e3c2914dd14ed1045", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 33, "line": 194}, "message": "destructor '~MCInst' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/MC/MCInst.h", "reportHash": "a4e08dcacff1e4c6fd661393574f2b93", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 34, "line": 40}, "message": "move constructor 'FeatureBitset' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/MC/SubtargetFeature.h", "reportHash": "db92ccfa7f3879145cf5af977871ccf7", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 31, "file": 34, "line": 95}, "message": "destructor '~' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/MC/SubtargetFeature.h", "reportHash": "23a4b6bd28460001bb0019434e59b173", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 31, "file": 34, "line": 95}, "message": "move constructor '' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/MC/SubtargetFeature.h", "reportHash": "70a8d2f60128e2ec0cc899b8921d6dfd", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 34, "line": 183}, "message": "destructor '~SubtargetFeatures' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/MC/SubtargetFeature.h", "reportHash": "41cd779801b6264b2fa5ab0a3e4277b4", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 34, "line": 183}, "message": "move constructor 'SubtargetFeatures' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/MC/SubtargetFeature.h", "reportHash": "c210773433e0e203d780688376ef5546", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 35, "line": 280}, "message": "destructor '~COFFSymbolRef' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Object/COFF.h", "reportHash": "8b94b5519de239a8cfbb430315250351", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 35, "line": 280}, "message": "move constructor 'COFFSymbolRef' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Object/COFF.h", "reportHash": "3241875dd619bbef86e194defe90eb42", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 36, "line": 33}, "message": "default constructor 'VerdAux' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Object/ELF.h", "reportHash": "e69201a6cddaecb00f4e2a7fee8037b4", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 36, "line": 33}, "message": "destructor '~VerdAux' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Object/ELF.h", "reportHash": "40b4bcd454275e6fdb29e15ebeddf4d5", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 36, "line": 33}, "message": "move constructor 'VerdAux' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Object/ELF.h", "reportHash": "6e71f33f4f9b9918935e3f7cff02cd6d", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 36, "line": 65}, "message": "default constructor 'VersionEntry' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Object/ELF.h", "reportHash": "42574fa9cb64e92d72fa800a8c910686", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 36, "line": 65}, "message": "destructor '~VersionEntry' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Object/ELF.h", "reportHash": "9ff28fb437a643eb19ae8fd3b6325810", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 36, "line": 65}, "message": "move assignment operator 'operator=' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Object/ELF.h", "reportHash": "c4a55bf501d0a66aefbf8b9b176cfe90", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 36, "line": 65}, "message": "move constructor 'VersionEntry' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Object/ELF.h", "reportHash": "cb946c037f1e9894d0edb3b5b15c26ba", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 37, "line": 139}, "message": "move constructor 'ELFSymbolRef' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Object/ELFObjectFile.h", "reportHash": "d1a35c4c0b459f72b88ff7bb1de84d84", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 37, "line": 176}, "message": "destructor '~elf_symbol_iterator' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Object/ELFObjectFile.h", "reportHash": "89d1104a7d93ce9b059827869af6650b", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 37, "line": 176}, "message": "move constructor 'elf_symbol_iterator' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Object/ELFObjectFile.h", "reportHash": "e3e33a3f93ea7c7b7a20f91f2ba423ad", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 38, "line": 53}, "message": "destructor '~BinaryError' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Object/Error.h", "reportHash": "42c6f211718a7a7211ca9c632f46f1f5", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 10, "file": 39, "line": 97}, "message": "destructor '~NodeState' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Object/MachO.h", "reportHash": "633cea0c2408b6215d2d3fefd674e8bd", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 10, "file": 39, "line": 97}, "message": "move constructor 'NodeState' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Object/MachO.h", "reportHash": "c94ba730112ec21a48fd0306528dec49", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 10, "file": 39, "line": 145}, "message": "destructor '~SectionInfo' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Object/MachO.h", "reportHash": "ce798724a7f2564e675b56a81fd4fbc6", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 10, "file": 39, "line": 145}, "message": "move constructor 'SectionInfo' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Object/MachO.h", "reportHash": "32144efd0773a01e4011be2fd87a3810", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 10, "file": 39, "line": 264}, "message": "destructor '~LoadCommandInfo' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Object/MachO.h", "reportHash": "0f042093b08859daff48e047cabc0922", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 10, "file": 39, "line": 264}, "message": "move constructor 'LoadCommandInfo' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Object/MachO.h", "reportHash": "63ddd7e6b25bc5b0ce137e6c12e350db", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 40, "line": 51}, "message": "destructor '~RelocationRef' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Object/ObjectFile.h", "reportHash": "002e6c386cd659e7a5a5e9650cf0ba84", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 40, "line": 51}, "message": "move assignment operator 'operator=' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Object/ObjectFile.h", "reportHash": "66471cc8289102d6820731652caebf26", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 40, "line": 51}, "message": "move constructor 'RelocationRef' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Object/ObjectFile.h", "reportHash": "efac2ca394a67ef7764777455361a7f4", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 40, "line": 80}, "message": "destructor '~SectionRef' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Object/ObjectFile.h", "reportHash": "0201c5353e75a15810e8b469579c2026", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 40, "line": 80}, "message": "move constructor 'SectionRef' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Object/ObjectFile.h", "reportHash": "9d415b3acf5519c631d56b48b573fac5", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 40, "line": 141}, "message": "destructor '~SectionedAddress' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Object/ObjectFile.h", "reportHash": "723843f4925bebeb7722748debf6b332", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 40, "line": 141}, "message": "move assignment operator 'operator=' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Object/ObjectFile.h", "reportHash": "d3eeef80d8c2bd8809e8901d33b9ac39", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 40, "line": 141}, "message": "move constructor 'SectionedAddress' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Object/ObjectFile.h", "reportHash": "8243d879262b3be50814f0eb008daabd", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 40, "line": 164}, "message": "destructor '~SymbolRef' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Object/ObjectFile.h", "reportHash": "72181715cf1927dd04af8f992376865f", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 40, "line": 164}, "message": "move constructor 'SymbolRef' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Object/ObjectFile.h", "reportHash": "6c5310c08ba1e8b064460c4dd0c225f5", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 40, "line": 204}, "message": "destructor '~symbol_iterator' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Object/ObjectFile.h", "reportHash": "5819a547b7d7dcf448d29d0f6673030d", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 40, "line": 204}, "message": "move constructor 'symbol_iterator' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Object/ObjectFile.h", "reportHash": "e19e2a8c9225151481cab7d067851b99", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 40, "line": 225}, "message": "destructor '~ObjectFile' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Object/ObjectFile.h", "reportHash": "0ddc1c4245bbef13cd7756a3a278e2fa", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 41, "line": 33}, "message": "destructor '~DataRefImpl' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Object/SymbolicFile.h", "reportHash": "aa2c94bd8af9c168e9f3022c85150508", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 41, "line": 33}, "message": "move assignment operator 'operator=' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Object/SymbolicFile.h", "reportHash": "cfef4db60f734a6bc457a7bbf1020772", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 41, "line": 33}, "message": "move constructor 'DataRefImpl' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Object/SymbolicFile.h", "reportHash": "47894bd647efcc730ba7505c633b057f", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 41, "line": 36}, "message": "destructor '~' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Object/SymbolicFile.h", "reportHash": "f33dc989cf7a5140bad54c0a6a8d6ceb", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 41, "line": 36}, "message": "move assignment operator 'operator=' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Object/SymbolicFile.h", "reportHash": "f3fd07bcbbaca2e4ff0dd3bedb1cecbd", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 41, "line": 36}, "message": "move constructor '' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Object/SymbolicFile.h", "reportHash": "7df6572d9b04aa703116780db1007d32", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 41, "line": 68}, "message": "destructor '~content_iterator' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Object/SymbolicFile.h", "reportHash": "2ff8dfd0d0043ae3a051af24ee2056ea", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 41, "line": 68}, "message": "move constructor 'content_iterator' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Object/SymbolicFile.h", "reportHash": "deb782b7fb69e13016ec6fb774554e07", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 41, "line": 97}, "message": "destructor '~BasicSymbolRef' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Object/SymbolicFile.h", "reportHash": "b62e13d392c79729f6bd6aff630d19b1", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 41, "line": 97}, "message": "move constructor 'BasicSymbolRef' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Object/SymbolicFile.h", "reportHash": "986d08e9cca038d196e03db077f4be4d", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 42, "line": 23}, "message": "destructor '~ARMAttributeParser' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/ARMAttributeParser.h", "reportHash": "6137f3cad8b7da366b4fc1c966418e52", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 45, "line": 31}, "message": "destructor '~BinaryByteStream' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/BinaryByteStream.h", "reportHash": "16bcd9fdeab2735f1ec1ae22fbe094f5", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 45, "line": 75}, "message": "destructor '~MemoryBufferByteStream' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/BinaryByteStream.h", "reportHash": "ab456f7cce36ddbab8456ea299131b34", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 45, "line": 89}, "message": "destructor '~MutableBinaryByteStream' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/BinaryByteStream.h", "reportHash": "d90da2d9396febaa39b11a0d949e0d14", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 45, "line": 135}, "message": "destructor '~AppendingBinaryByteStream' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/BinaryByteStream.h", "reportHash": "aaf6d080d80f722c04cb3b55b7bec97e", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 45, "line": 205}, "message": "destructor '~FileBufferByteStream' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/BinaryByteStream.h", "reportHash": "dc65705650a924add225bdbbfc6da082", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 9, "file": 45, "line": 207}, "message": "destructor '~StreamImpl' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/BinaryByteStream.h", "reportHash": "67cf2398231a7ced30752190eae73c3b", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 46, "line": 35}, "message": "default constructor 'BinaryStream' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/BinaryStream.h", "reportHash": "a8b454ddd460fb19b17a94bef6c41857", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 46, "line": 73}, "message": "default constructor 'WritableBinaryStream' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/BinaryStream.h", "reportHash": "08a3818121c1784e045c920630ce938f", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 47, "line": 27}, "message": "destructor '~BinaryStreamError' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/BinaryStreamError.h", "reportHash": "3d2be27809c5507214a2fc6594dadfb7", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 48, "line": 19}, "message": "destructor '~Uint24' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/DataExtractor.h", "reportHash": "9ea3ed73444ee5742bf1b2775ee47be6", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 48, "line": 19}, "message": "move constructor 'Uint24' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/DataExtractor.h", "reportHash": "9a2912080fee263506bec8efcf9d216e", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 48, "line": 41}, "message": "destructor '~DataExtractor' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/DataExtractor.h", "reportHash": "aa10557a1ebec4d461c4bba4f66e54d7", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 48, "line": 41}, "message": "move assignment operator 'operator=' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/DataExtractor.h", "reportHash": "13eba316438d36576b6c91557b088425", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 48, "line": 41}, "message": "move constructor 'DataExtractor' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/DataExtractor.h", "reportHash": "66da573c878a354f00ffc836c599760c", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 9, "file": 48, "line": 54}, "message": "destructor '~Cursor' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/DataExtractor.h", "reportHash": "1d91c0446905059168506de0c99e3ed5", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 49, "line": 206}, "message": "destructor '~packed_endian_specific_integral' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/Endian.h", "reportHash": "3411ede0a676fda6ec7591a8a4d7a8dd", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 49, "line": 246}, "message": "destructor '~' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/Endian.h", "reportHash": "40bc30fa90d879970c98f136868172dc", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 50, "line": 1179}, "message": "destructor '~StringError' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/Error.h", "reportHash": "ec079d3ca2fc7b302b55dd87253c6591", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 51, "line": 90}, "message": "destructor '~format_object' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/Format.h", "reportHash": "5e3d97ef2291366ff936656b0a3992df", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 52, "line": 22}, "message": "destructor '~MemoryBufferRef' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/MemoryBufferRef.h", "reportHash": "c025260fc04adca3616037590012acc1", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 54, "line": 39}, "message": "destructor '~HexNumber' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/ScopedPrinter.h", "reportHash": "15c43deac8f8a54b4eadac58e4c09fd7", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 54, "line": 39}, "message": "move constructor 'HexNumber' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/ScopedPrinter.h", "reportHash": "a8a9835ad6aeb9ac557d954f72981778", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}]};
      window.onload = function() {
        if (!browserCompatible) {
          setNonCompatibleBrowserMessage();
        } else {
          BugViewer.init(data.files, data.reports);
          BugViewer.create();
          BugViewer.initByUrl();
        }
      };
    </script>
  </head>
  <body>
  <div class="container">
    <div id="content">
      <div id="side-bar">
        <div class="header">
          <a href="index.html" class="button">&#8249; Return to List</a>
        </div>
        <div id="report-nav">
          <div class="header">Reports</div>
        </div>
      </div>
      <div id="editor-wrapper">
        <div class="header">
          <div id="file">
            <span class="label">File:</span>
            <span id="file-path"></span>
          </div>
          <div id="checker">
            <span class="label">Checker name:</span>
            <span id="checker-name"></span>
          </div>
          <div id="review-status-wrapper">
            <span class="label">Review status:</span>
            <span id="review-status"></span>
          </div>
        </div>
        <div id="editor"></div>
      </div>
    </div>
  </div>
  </body>
</html>
