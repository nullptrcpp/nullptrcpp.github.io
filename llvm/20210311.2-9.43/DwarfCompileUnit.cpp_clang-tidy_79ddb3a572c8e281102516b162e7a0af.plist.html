<!DOCTYPE html>
<html>
  <head>
    <title>Plist HTML Viewer</title>

    <meta charset="UTF-8">

    <style type="text/css">
      .CodeMirror{font-family:monospace;height:300px;color:#000;direction:ltr}.CodeMirror-lines{padding:4px 0}.CodeMirror pre{padding:0 4px}.CodeMirror-gutter-filler,.CodeMirror-scrollbar-filler{background-color:#fff}.CodeMirror-gutters{border-right:1px solid #ddd;background-color:#f7f7f7;white-space:nowrap}.CodeMirror-linenumber{padding:0 3px 0 5px;min-width:20px;text-align:right;color:#999;white-space:nowrap}.CodeMirror-guttermarker{color:#000}.CodeMirror-guttermarker-subtle{color:#999}.CodeMirror-cursor{border-left:1px solid #000;border-right:none;width:0}.CodeMirror div.CodeMirror-secondarycursor{border-left:1px solid silver}.cm-fat-cursor .CodeMirror-cursor{width:auto;border:0!important;background:#7e7}.cm-fat-cursor div.CodeMirror-cursors{z-index:1}.cm-animate-fat-cursor{width:auto;border:0;-webkit-animation:blink 1.06s steps(1) infinite;-moz-animation:blink 1.06s steps(1) infinite;animation:blink 1.06s steps(1) infinite;background-color:#7e7}@-moz-keyframes blink{50%{background-color:transparent}}@-webkit-keyframes blink{50%{background-color:transparent}}@keyframes blink{50%{background-color:transparent}}.cm-tab{display:inline-block;text-decoration:inherit}.CodeMirror-rulers{position:absolute;left:0;right:0;top:-50px;bottom:-20px;overflow:hidden}.CodeMirror-ruler{border-left:1px solid #ccc;top:0;bottom:0;position:absolute}.cm-s-default .cm-header{color:#00f}.cm-s-default .cm-quote{color:#090}.cm-negative{color:#d44}.cm-positive{color:#292}.cm-header,.cm-strong{font-weight:700}.cm-em{font-style:italic}.cm-link{text-decoration:underline}.cm-strikethrough{text-decoration:line-through}.cm-s-default .cm-keyword{color:#708}.cm-s-default .cm-atom{color:#219}.cm-s-default .cm-number{color:#164}.cm-s-default .cm-def{color:#00f}.cm-s-default .cm-variable-2{color:#05a}.cm-s-default .cm-type,.cm-s-default .cm-variable-3{color:#085}.cm-s-default .cm-comment{color:#a50}.cm-s-default .cm-string{color:#a11}.cm-s-default .cm-string-2{color:#f50}.cm-s-default .cm-meta{color:#555}.cm-s-default .cm-qualifier{color:#555}.cm-s-default .cm-builtin{color:#30a}.cm-s-default .cm-bracket{color:#997}.cm-s-default .cm-tag{color:#170}.cm-s-default .cm-attribute{color:#00c}.cm-s-default .cm-hr{color:#999}.cm-s-default .cm-link{color:#00c}.cm-s-default .cm-error{color:red}.cm-invalidchar{color:red}.CodeMirror-composing{border-bottom:2px solid}div.CodeMirror span.CodeMirror-matchingbracket{color:#0f0}div.CodeMirror span.CodeMirror-nonmatchingbracket{color:#f22}.CodeMirror-matchingtag{background:rgba(255,150,0,.3)}.CodeMirror-activeline-background{background:#e8f2ff}.CodeMirror{position:relative;overflow:hidden;background:#fff}.CodeMirror-scroll{overflow:scroll!important;margin-bottom:-30px;margin-right:-30px;padding-bottom:30px;height:100%;outline:0;position:relative}.CodeMirror-sizer{position:relative;border-right:30px solid transparent}.CodeMirror-gutter-filler,.CodeMirror-hscrollbar,.CodeMirror-scrollbar-filler,.CodeMirror-vscrollbar{position:absolute;z-index:6;display:none}.CodeMirror-vscrollbar{right:0;top:0;overflow-x:hidden;overflow-y:scroll}.CodeMirror-hscrollbar{bottom:0;left:0;overflow-y:hidden;overflow-x:scroll}.CodeMirror-scrollbar-filler{right:0;bottom:0}.CodeMirror-gutter-filler{left:0;bottom:0}.CodeMirror-gutters{position:absolute;left:0;top:0;min-height:100%;z-index:3}.CodeMirror-gutter{white-space:normal;height:100%;display:inline-block;vertical-align:top;margin-bottom:-30px}.CodeMirror-gutter-wrapper{position:absolute;z-index:4;background:0 0!important;border:none!important}.CodeMirror-gutter-background{position:absolute;top:0;bottom:0;z-index:4}.CodeMirror-gutter-elt{position:absolute;cursor:default;z-index:4}.CodeMirror-gutter-wrapper ::selection{background-color:transparent}.CodeMirror-gutter-wrapper ::-moz-selection{background-color:transparent}.CodeMirror-lines{cursor:text;min-height:1px}.CodeMirror pre{-moz-border-radius:0;-webkit-border-radius:0;border-radius:0;border-width:0;background:0 0;font-family:inherit;font-size:inherit;margin:0;white-space:pre;word-wrap:normal;line-height:inherit;color:inherit;z-index:2;position:relative;overflow:visible;-webkit-tap-highlight-color:transparent;-webkit-font-variant-ligatures:contextual;font-variant-ligatures:contextual}.CodeMirror-wrap pre{word-wrap:break-word;white-space:pre-wrap;word-break:normal}.CodeMirror-linebackground{position:absolute;left:0;right:0;top:0;bottom:0;z-index:0}.CodeMirror-linewidget{position:relative;z-index:2;overflow:auto}.CodeMirror-rtl pre{direction:rtl}.CodeMirror-code{outline:0}.CodeMirror-gutter,.CodeMirror-gutters,.CodeMirror-linenumber,.CodeMirror-scroll,.CodeMirror-sizer{-moz-box-sizing:content-box;box-sizing:content-box}.CodeMirror-measure{position:absolute;width:100%;height:0;overflow:hidden;visibility:hidden}.CodeMirror-cursor{position:absolute;pointer-events:none}.CodeMirror-measure pre{position:static}div.CodeMirror-cursors{visibility:hidden;position:relative;z-index:3}div.CodeMirror-dragcursors{visibility:visible}.CodeMirror-focused div.CodeMirror-cursors{visibility:visible}.CodeMirror-selected{background:#d9d9d9}.CodeMirror-focused .CodeMirror-selected{background:#d7d4f0}.CodeMirror-crosshair{cursor:crosshair}.CodeMirror-line::selection,.CodeMirror-line>span::selection,.CodeMirror-line>span>span::selection{background:#d7d4f0}.CodeMirror-line::-moz-selection,.CodeMirror-line>span::-moz-selection,.CodeMirror-line>span>span::-moz-selection{background:#d7d4f0}.cm-searching{background-color:#ffa;background-color:rgba(255,255,0,.4)}.cm-force-border{padding-right:.1px}@media print{.CodeMirror div.CodeMirror-cursors{visibility:hidden}}.cm-tab-wrap-hack:after{content:''}span.CodeMirror-selectedtext{background:0 0}
/*# sourceMappingURL=codemirror.min.css.map */

      .severity-low {
  background-color: #669603;
}

.severity-low:after {
  content : 'L';
}

.severity-unspecified {
  background-color: #666666;
}

.severity-unspecified:after {
  content : 'U';
}

.severity-style {
  background-color: #9932cc;
}

.severity-style:after {
  content : 'S';
}

.severity-medium {
  background-color: #a9d323;
  color: black;
}

.severity-medium:after {
  content : 'M';
}

.severity-high {
  background-color: #ffa800;
}

.severity-high:after {
  content : 'H';
}

.severity-critical {
  background-color: #e92625;
}

.severity-critical:after {
  content : 'C';
}

i[class*="severity-"] {
  line-height: normal;
  text-transform: capitalize;
  font-size: 0.8em;
  font-weight: bold;
  color: white;
  display: inline-block;
  width: 16px;
  height: 16px;
  text-align: center;
  font-family: sans-serif;
}

      html, body {
  width: 100%;
  height: 100%;
  padding: 0px;
  margin: 0px;
}

div.container {
  padding: 10px;
}

#content {
  height: 100%;
  display: block;
  overflow: hidden;
}

#content > div {
  margin: 10px;
  overflow: hidden;
  border: 1px solid #ddd;
  border-radius: 3px;
  overflow: hidden;
  height: 97%;
}

.button {
  background-color: #f1f1f1;
  text-decoration: none;
  display: inline-block;
  padding: 8px 16px;
  color: black;
  cursor: pointer;
}

.button:hover {
  background-color: #ddd;
  color: black;
}

.review-status {
  color: white;
  text-align: center;
}

.review-status-confirmed {
  background-color: #e92625;
}

.review-status-false-positive {
  background-color: grey;
}

.review-status-intentional {
  background-color: #669603;
}

      div.container {
  width: 100%;
  height: 100%;
  padding: 0px;
}

#editor-wrapper {
  margin: 10px;
}

#side-bar {
  float: left;
  width: 260px;
  margin: 0px;
}

#report-nav ul {
  list-style-type: none;
  padding: 0;
  margin: 0;
  overflow-y: auto;
  height: 100%;
}

#report-nav ul > li {
  padding: .4em;
  background-color: #fff;
  border-bottom: 1px solid rgba(0,0,0,.125);
  text-align: left;
  overflow: hidden;
  white-space: nowrap;
  text-overflow: ellipsis;
}

#report-nav ul > li.active {
  background-color: #427ea9;
  color: white;
}

#report-nav ul > li:hover {
  background-color: #427ea9;
  color: white;
  cursor: pointer;
}

#report-nav ul a {
  text-decoration: none;
}

#report-nav i[class*="severity-"] {
  margin-right: 5px;
}

.header {
  border-bottom: 1px solid lightgrey;
  font-family: monospace;
  padding: 10px;
  background-color: #fafbfc;
  border-bottom: 1px solid #e1e4e8;
  border-top-left-radius: 2px;
  border-top-right-radius: 2px;
}

#report-nav .header {
  font-weight: bold;
}

#editor-wrapper .header > div {
  padding-top: 2px;
}

#file-path,
#checker-name {
  color: #195ea2;
}

#review-status {
  padding: 0px 5px;
}

#file-path {
  font-family: monospace;
}

.check-msg {
  display: inline-block;
  padding: 3px 6px;
  margin: 1px;
  -webkit-border-radius: 5px;
  -moz-border-radius: 5px;
  border-radius: 5px;
}

.check-msg.info {
  color: #00546f;
  background-color: #bfdfe9;
  border: 1px solid #87a8b3;
}

.check-msg.error {
  background-color: #f2dede;
  color: #a94442;
  border: 1px solid #ebcccc;
}

.check-msg.macro {
  background-color: #d7dac2;
  color: #4f5c6d;
  border: 1px solid #d7dac2;
}

.check-msg.note {
  background-color: #d7d7d7;
  color: #4f5c6d;
  border: 1px solid #bfbfbf;
}

.check-msg.current {
  border: 2px dashed #3692ff;
}

.check-msg .tag {
  padding: 1px 5px;
  text-align: center;
  border-radius: 2px;
  margin-right: 5px;
  text-decoration: inherit;
}

.check-msg .tag.macro {
  background-color: #83876a;
  color: white;
  text-transform: capitalize;
}

.check-msg .tag.note {
  background-color: #9299a1;
  color: white;
  text-transform: capitalize;
}

.checker-enum {
  color: white;
  padding: 1px 5px;
  text-align: center;
  border-radius: 25px;
  margin-right: 5px;
  text-decoration: inherit;
}

.checker-enum.info {
  background-color: #427ea9;
}

.checker-enum.error {
  background-color: #a94442;
}

.arrow {
  border: solid black;
  border-width: 0 3px 3px 0;
  display: inline-block;
  padding: 3px;
  cursor: pointer;
  margin: 0px 5px;
}

.arrow:hover {
  border: solid #437ea8;
  border-width: 0 3px 3px 0;
}

.left-arrow {
  transform: rotate(135deg);
  -webkit-transform: rotate(135deg);
}

.right-arrow {
  transform: rotate(-45deg);
  -webkit-transform: rotate(-45deg);
}

    </style>

    <script type="text/javascript">
      function setNonCompatibleBrowserMessage() {
  document.body.innerHTML =
    '<h2 style="margin-left: 20px;">Your browser is not compatible with CodeChecker Viewer!</h2> \
     <p style="margin-left: 20px;">The version required for the following browsers are:</p> \
     <ul style="margin-left: 20px;"> \
     <li>Internet Explorer: version 9 or newer</li> \
     <li>Firefox: version 22.0 or newer</li> \
     </ul>';
}

// http://stackoverflow.com/questions/5916900/how-can-you-detect-the-version-of-a-browser
var browserVersion = (function(){
  var ua = navigator.userAgent, tem,
    M = ua.match(/(opera|chrome|safari|firefox|msie|trident(?=\/))\/?\s*(\d+)/i) || [];

  if (/trident/i.test(M[1])) {
    tem = /\brv[ :]+(\d+)/g.exec(ua) || [];
    return 'IE ' + (tem[1] || '');
  }

  if (M[1] === 'Chrome') {
    tem = ua.match(/\b(OPR|Edge)\/(\d+)/);
    if (tem != null) return tem.slice(1).join(' ').replace('OPR', 'Opera');
  }

  M = M[2] ? [M[1], M[2]] : [navigator.appName, navigator.appVersion, '-?'];
  if ((tem = ua.match(/version\/(\d+)/i)) != null) M.splice(1, 1, tem[1]);
    return M.join(' ');
})();

var pos = browserVersion.indexOf(' ');
var browser = browserVersion.substr(0, pos);
var version = parseInt(browserVersion.substr(pos + 1));

var browserCompatible
  = browser === 'Firefox'
  ? version >= 22
  : browser === 'IE'
  ? version >= 9
  : true;


      /* MIT License

Copyright (C) 2017 by Marijn Haverbeke <marijnh@gmail.com> and others

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
 */
      !function(e,t){"object"==typeof exports&&"undefined"!=typeof module?module.exports=t():"function"==typeof define&&define.amd?define(t):e.CodeMirror=t()}(this,function(){"use strict";function e(e){return new RegExp("(^|\\s)"+e+"(?:$|\\s)\\s*")}function t(e){for(var t=e.childNodes.length;t>0;--t)e.removeChild(e.firstChild);return e}function r(e,r){return t(e).appendChild(r)}function n(e,t,r,n){var i=document.createElement(e);if(r&&(i.className=r),n&&(i.style.cssText=n),"string"==typeof t)i.appendChild(document.createTextNode(t));else if(t)for(var o=0;o<t.length;++o)i.appendChild(t[o]);return i}function i(e,t,r,i){var o=n(e,t,r,i);return o.setAttribute("role","presentation"),o}function o(e,t){if(3==t.nodeType&&(t=t.parentNode),e.contains)return e.contains(t);do{if(11==t.nodeType&&(t=t.host),t==e)return!0}while(t=t.parentNode)}function l(){var e;try{e=document.activeElement}catch(t){e=document.body||null}for(;e&&e.shadowRoot&&e.shadowRoot.activeElement;)e=e.shadowRoot.activeElement;return e}function s(t,r){var n=t.className;e(r).test(n)||(t.className+=(n?" ":"")+r)}function a(t,r){for(var n=t.split(" "),i=0;i<n.length;i++)n[i]&&!e(n[i]).test(r)&&(r+=" "+n[i]);return r}function u(e){var t=Array.prototype.slice.call(arguments,1);return function(){return e.apply(null,t)}}function c(e,t,r){t||(t={});for(var n in e)!e.hasOwnProperty(n)||!1===r&&t.hasOwnProperty(n)||(t[n]=e[n]);return t}function f(e,t,r,n,i){null==t&&-1==(t=e.search(/[^\s\u00a0]/))&&(t=e.length);for(var o=n||0,l=i||0;;){var s=e.indexOf("\t",o);if(s<0||s>=t)return l+(t-o);l+=s-o,l+=r-l%r,o=s+1}}function h(e,t){for(var r=0;r<e.length;++r)if(e[r]==t)return r;return-1}function d(e,t,r){for(var n=0,i=0;;){var o=e.indexOf("\t",n);-1==o&&(o=e.length);var l=o-n;if(o==e.length||i+l>=t)return n+Math.min(l,t-i);if(i+=o-n,i+=r-i%r,n=o+1,i>=t)return n}}function p(e){for(;Kl.length<=e;)Kl.push(g(Kl)+" ");return Kl[e]}function g(e){return e[e.length-1]}function v(e,t){for(var r=[],n=0;n<e.length;n++)r[n]=t(e[n],n);return r}function m(e,t,r){for(var n=0,i=r(t);n<e.length&&r(e[n])<=i;)n++;e.splice(n,0,t)}function y(){}function b(e,t){var r;return Object.create?r=Object.create(e):(y.prototype=e,r=new y),t&&c(t,r),r}function w(e){return/\w/.test(e)||e>""&&(e.toUpperCase()!=e.toLowerCase()||jl.test(e))}function x(e,t){return t?!!(t.source.indexOf("\\w")>-1&&w(e))||t.test(e):w(e)}function C(e){for(var t in e)if(e.hasOwnProperty(t)&&e[t])return!1;return!0}function S(e){return e.charCodeAt(0)>=768&&Xl.test(e)}function L(e,t,r){for(;(r<0?t>0:t<e.length)&&S(e.charAt(t));)t+=r;return t}function k(e,t,r){for(var n=t>r?-1:1;;){if(t==r)return t;var i=(t+r)/2,o=n<0?Math.ceil(i):Math.floor(i);if(o==t)return e(o)?t:r;e(o)?r=o:t=o+n}}function T(e,t,r){var o=this;this.input=r,o.scrollbarFiller=n("div",null,"CodeMirror-scrollbar-filler"),o.scrollbarFiller.setAttribute("cm-not-content","true"),o.gutterFiller=n("div",null,"CodeMirror-gutter-filler"),o.gutterFiller.setAttribute("cm-not-content","true"),o.lineDiv=i("div",null,"CodeMirror-code"),o.selectionDiv=n("div",null,null,"position: relative; z-index: 1"),o.cursorDiv=n("div",null,"CodeMirror-cursors"),o.measure=n("div",null,"CodeMirror-measure"),o.lineMeasure=n("div",null,"CodeMirror-measure"),o.lineSpace=i("div",[o.measure,o.lineMeasure,o.selectionDiv,o.cursorDiv,o.lineDiv],null,"position: relative; outline: none");var l=i("div",[o.lineSpace],"CodeMirror-lines");o.mover=n("div",[l],null,"position: relative"),o.sizer=n("div",[o.mover],"CodeMirror-sizer"),o.sizerWidth=null,o.heightForcer=n("div",null,null,"position: absolute; height: "+Rl+"px; width: 1px;"),o.gutters=n("div",null,"CodeMirror-gutters"),o.lineGutter=null,o.scroller=n("div",[o.sizer,o.heightForcer,o.gutters],"CodeMirror-scroll"),o.scroller.setAttribute("tabIndex","-1"),o.wrapper=n("div",[o.scrollbarFiller,o.gutterFiller,o.scroller],"CodeMirror"),gl&&vl<8&&(o.gutters.style.zIndex=-1,o.scroller.style.paddingRight=0),ml||fl&&Tl||(o.scroller.draggable=!0),e&&(e.appendChild?e.appendChild(o.wrapper):e(o.wrapper)),o.viewFrom=o.viewTo=t.first,o.reportedViewFrom=o.reportedViewTo=t.first,o.view=[],o.renderedView=null,o.externalMeasured=null,o.viewOffset=0,o.lastWrapHeight=o.lastWrapWidth=0,o.updateLineNumbers=null,o.nativeBarWidth=o.barHeight=o.barWidth=0,o.scrollbarsClipped=!1,o.lineNumWidth=o.lineNumInnerWidth=o.lineNumChars=null,o.alignWidgets=!1,o.cachedCharWidth=o.cachedTextHeight=o.cachedPaddingH=null,o.maxLine=null,o.maxLineLength=0,o.maxLineChanged=!1,o.wheelDX=o.wheelDY=o.wheelStartX=o.wheelStartY=null,o.shift=!1,o.selForContextMenu=null,o.activeTouch=null,r.init(o)}function M(e,t){if((t-=e.first)<0||t>=e.size)throw new Error("There is no line "+(t+e.first)+" in the document.");for(var r=e;!r.lines;)for(var n=0;;++n){var i=r.children[n],o=i.chunkSize();if(t<o){r=i;break}t-=o}return r.lines[t]}function N(e,t,r){var n=[],i=t.line;return e.iter(t.line,r.line+1,function(e){var o=e.text;i==r.line&&(o=o.slice(0,r.ch)),i==t.line&&(o=o.slice(t.ch)),n.push(o),++i}),n}function O(e,t,r){var n=[];return e.iter(t,r,function(e){n.push(e.text)}),n}function A(e,t){var r=t-e.height;if(r)for(var n=e;n;n=n.parent)n.height+=r}function W(e){if(null==e.parent)return null;for(var t=e.parent,r=h(t.lines,e),n=t.parent;n;t=n,n=n.parent)for(var i=0;n.children[i]!=t;++i)r+=n.children[i].chunkSize();return r+t.first}function D(e,t){var r=e.first;e:do{for(var n=0;n<e.children.length;++n){var i=e.children[n],o=i.height;if(t<o){e=i;continue e}t-=o,r+=i.chunkSize()}return r}while(!e.lines);for(var l=0;l<e.lines.length;++l){var s=e.lines[l].height;if(t<s)break;t-=s}return r+l}function H(e,t){return t>=e.first&&t<e.first+e.size}function F(e,t){return String(e.lineNumberFormatter(t+e.firstLineNumber))}function E(e,t,r){if(void 0===r&&(r=null),!(this instanceof E))return new E(e,t,r);this.line=e,this.ch=t,this.sticky=r}function P(e,t){return e.line-t.line||e.ch-t.ch}function I(e,t){return e.sticky==t.sticky&&0==P(e,t)}function z(e){return E(e.line,e.ch)}function R(e,t){return P(e,t)<0?t:e}function B(e,t){return P(e,t)<0?e:t}function G(e,t){return Math.max(e.first,Math.min(t,e.first+e.size-1))}function U(e,t){if(t.line<e.first)return E(e.first,0);var r=e.first+e.size-1;return t.line>r?E(r,M(e,r).text.length):V(t,M(e,t.line).text.length)}function V(e,t){var r=e.ch;return null==r||r>t?E(e.line,t):r<0?E(e.line,0):e}function K(e,t){for(var r=[],n=0;n<t.length;n++)r[n]=U(e,t[n]);return r}function j(){Yl=!0}function X(){_l=!0}function Y(e,t,r){this.marker=e,this.from=t,this.to=r}function _(e,t){if(e)for(var r=0;r<e.length;++r){var n=e[r];if(n.marker==t)return n}}function $(e,t){for(var r,n=0;n<e.length;++n)e[n]!=t&&(r||(r=[])).push(e[n]);return r}function q(e,t){e.markedSpans=e.markedSpans?e.markedSpans.concat([t]):[t],t.marker.attachLine(e)}function Z(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t)||o.from==t&&"bookmark"==l.type&&(!r||!o.marker.insertLeft)){var s=null==o.to||(l.inclusiveRight?o.to>=t:o.to>t);(n||(n=[])).push(new Y(l,o.from,s?null:o.to))}}return n}function Q(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.to||(l.inclusiveRight?o.to>=t:o.to>t)||o.from==t&&"bookmark"==l.type&&(!r||o.marker.insertLeft)){var s=null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t);(n||(n=[])).push(new Y(l,s?null:o.from-t,null==o.to?null:o.to-t))}}return n}function J(e,t){if(t.full)return null;var r=H(e,t.from.line)&&M(e,t.from.line).markedSpans,n=H(e,t.to.line)&&M(e,t.to.line).markedSpans;if(!r&&!n)return null;var i=t.from.ch,o=t.to.ch,l=0==P(t.from,t.to),s=Z(r,i,l),a=Q(n,o,l),u=1==t.text.length,c=g(t.text).length+(u?i:0);if(s)for(var f=0;f<s.length;++f){var h=s[f];if(null==h.to){var d=_(a,h.marker);d?u&&(h.to=null==d.to?null:d.to+c):h.to=i}}if(a)for(var p=0;p<a.length;++p){var v=a[p];null!=v.to&&(v.to+=c),null==v.from?_(s,v.marker)||(v.from=c,u&&(s||(s=[])).push(v)):(v.from+=c,u&&(s||(s=[])).push(v))}s&&(s=ee(s)),a&&a!=s&&(a=ee(a));var m=[s];if(!u){var y,b=t.text.length-2;if(b>0&&s)for(var w=0;w<s.length;++w)null==s[w].to&&(y||(y=[])).push(new Y(s[w].marker,null,null));for(var x=0;x<b;++x)m.push(y);m.push(a)}return m}function ee(e){for(var t=0;t<e.length;++t){var r=e[t];null!=r.from&&r.from==r.to&&!1!==r.marker.clearWhenEmpty&&e.splice(t--,1)}return e.length?e:null}function te(e,t,r){var n=null;if(e.iter(t.line,r.line+1,function(e){if(e.markedSpans)for(var t=0;t<e.markedSpans.length;++t){var r=e.markedSpans[t].marker;!r.readOnly||n&&-1!=h(n,r)||(n||(n=[])).push(r)}}),!n)return null;for(var i=[{from:t,to:r}],o=0;o<n.length;++o)for(var l=n[o],s=l.find(0),a=0;a<i.length;++a){var u=i[a];if(!(P(u.to,s.from)<0||P(u.from,s.to)>0)){var c=[a,1],f=P(u.from,s.from),d=P(u.to,s.to);(f<0||!l.inclusiveLeft&&!f)&&c.push({from:u.from,to:s.from}),(d>0||!l.inclusiveRight&&!d)&&c.push({from:s.to,to:u.to}),i.splice.apply(i,c),a+=c.length-3}}return i}function re(e){var t=e.markedSpans;if(t){for(var r=0;r<t.length;++r)t[r].marker.detachLine(e);e.markedSpans=null}}function ne(e,t){if(t){for(var r=0;r<t.length;++r)t[r].marker.attachLine(e);e.markedSpans=t}}function ie(e){return e.inclusiveLeft?-1:0}function oe(e){return e.inclusiveRight?1:0}function le(e,t){var r=e.lines.length-t.lines.length;if(0!=r)return r;var n=e.find(),i=t.find(),o=P(n.from,i.from)||ie(e)-ie(t);if(o)return-o;var l=P(n.to,i.to)||oe(e)-oe(t);return l||t.id-e.id}function se(e,t){var r,n=_l&&e.markedSpans;if(n)for(var i=void 0,o=0;o<n.length;++o)(i=n[o]).marker.collapsed&&null==(t?i.from:i.to)&&(!r||le(r,i.marker)<0)&&(r=i.marker);return r}function ae(e){return se(e,!0)}function ue(e){return se(e,!1)}function ce(e,t,r,n,i){var o=M(e,t),l=_l&&o.markedSpans;if(l)for(var s=0;s<l.length;++s){var a=l[s];if(a.marker.collapsed){var u=a.marker.find(0),c=P(u.from,r)||ie(a.marker)-ie(i),f=P(u.to,n)||oe(a.marker)-oe(i);if(!(c>=0&&f<=0||c<=0&&f>=0)&&(c<=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.to,r)>=0:P(u.to,r)>0)||c>=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.from,n)<=0:P(u.from,n)<0)))return!0}}}function fe(e){for(var t;t=ae(e);)e=t.find(-1,!0).line;return e}function he(e){for(var t;t=ue(e);)e=t.find(1,!0).line;return e}function de(e){for(var t,r;t=ue(e);)e=t.find(1,!0).line,(r||(r=[])).push(e);return r}function pe(e,t){var r=M(e,t),n=fe(r);return r==n?t:W(n)}function ge(e,t){if(t>e.lastLine())return t;var r,n=M(e,t);if(!ve(e,n))return t;for(;r=ue(n);)n=r.find(1,!0).line;return W(n)+1}function ve(e,t){var r=_l&&t.markedSpans;if(r)for(var n=void 0,i=0;i<r.length;++i)if((n=r[i]).marker.collapsed){if(null==n.from)return!0;if(!n.marker.widgetNode&&0==n.from&&n.marker.inclusiveLeft&&me(e,t,n))return!0}}function me(e,t,r){if(null==r.to){var n=r.marker.find(1,!0);return me(e,n.line,_(n.line.markedSpans,r.marker))}if(r.marker.inclusiveRight&&r.to==t.text.length)return!0;for(var i=void 0,o=0;o<t.markedSpans.length;++o)if((i=t.markedSpans[o]).marker.collapsed&&!i.marker.widgetNode&&i.from==r.to&&(null==i.to||i.to!=r.from)&&(i.marker.inclusiveLeft||r.marker.inclusiveRight)&&me(e,t,i))return!0}function ye(e){for(var t=0,r=(e=fe(e)).parent,n=0;n<r.lines.length;++n){var i=r.lines[n];if(i==e)break;t+=i.height}for(var o=r.parent;o;r=o,o=r.parent)for(var l=0;l<o.children.length;++l){var s=o.children[l];if(s==r)break;t+=s.height}return t}function be(e){if(0==e.height)return 0;for(var t,r=e.text.length,n=e;t=ae(n);){var i=t.find(0,!0);n=i.from.line,r+=i.from.ch-i.to.ch}for(n=e;t=ue(n);){var o=t.find(0,!0);r-=n.text.length-o.from.ch,r+=(n=o.to.line).text.length-o.to.ch}return r}function we(e){var t=e.display,r=e.doc;t.maxLine=M(r,r.first),t.maxLineLength=be(t.maxLine),t.maxLineChanged=!0,r.iter(function(e){var r=be(e);r>t.maxLineLength&&(t.maxLineLength=r,t.maxLine=e)})}function xe(e,t,r,n){if(!e)return n(t,r,"ltr",0);for(var i=!1,o=0;o<e.length;++o){var l=e[o];(l.from<r&&l.to>t||t==r&&l.to==t)&&(n(Math.max(l.from,t),Math.min(l.to,r),1==l.level?"rtl":"ltr",o),i=!0)}i||n(t,r,"ltr")}function Ce(e,t,r){var n;$l=null;for(var i=0;i<e.length;++i){var o=e[i];if(o.from<t&&o.to>t)return i;o.to==t&&(o.from!=o.to&&"before"==r?n=i:$l=i),o.from==t&&(o.from!=o.to&&"before"!=r?n=i:$l=i)}return null!=n?n:$l}function Se(e,t){var r=e.order;return null==r&&(r=e.order=ql(e.text,t)),r}function Le(e,t){return e._handlers&&e._handlers[t]||Zl}function ke(e,t,r){if(e.removeEventListener)e.removeEventListener(t,r,!1);else if(e.detachEvent)e.detachEvent("on"+t,r);else{var n=e._handlers,i=n&&n[t];if(i){var o=h(i,r);o>-1&&(n[t]=i.slice(0,o).concat(i.slice(o+1)))}}}function Te(e,t){var r=Le(e,t);if(r.length)for(var n=Array.prototype.slice.call(arguments,2),i=0;i<r.length;++i)r[i].apply(null,n)}function Me(e,t,r){return"string"==typeof t&&(t={type:t,preventDefault:function(){this.defaultPrevented=!0}}),Te(e,r||t.type,e,t),He(t)||t.codemirrorIgnore}function Ne(e){var t=e._handlers&&e._handlers.cursorActivity;if(t)for(var r=e.curOp.cursorActivityHandlers||(e.curOp.cursorActivityHandlers=[]),n=0;n<t.length;++n)-1==h(r,t[n])&&r.push(t[n])}function Oe(e,t){return Le(e,t).length>0}function Ae(e){e.prototype.on=function(e,t){Ql(this,e,t)},e.prototype.off=function(e,t){ke(this,e,t)}}function We(e){e.preventDefault?e.preventDefault():e.returnValue=!1}function De(e){e.stopPropagation?e.stopPropagation():e.cancelBubble=!0}function He(e){return null!=e.defaultPrevented?e.defaultPrevented:0==e.returnValue}function Fe(e){We(e),De(e)}function Ee(e){return e.target||e.srcElement}function Pe(e){var t=e.which;return null==t&&(1&e.button?t=1:2&e.button?t=3:4&e.button&&(t=2)),Ml&&e.ctrlKey&&1==t&&(t=3),t}function Ie(e){if(null==Il){var t=n("span","​");r(e,n("span",[t,document.createTextNode("x")])),0!=e.firstChild.offsetHeight&&(Il=t.offsetWidth<=1&&t.offsetHeight>2&&!(gl&&vl<8))}var i=Il?n("span","​"):n("span"," ",null,"display: inline-block; width: 1px; margin-right: -1px");return i.setAttribute("cm-text",""),i}function ze(e){if(null!=zl)return zl;var n=r(e,document.createTextNode("AخA")),i=Wl(n,0,1).getBoundingClientRect(),o=Wl(n,1,2).getBoundingClientRect();return t(e),!(!i||i.left==i.right)&&(zl=o.right-i.right<3)}function Re(e){if(null!=ns)return ns;var t=r(e,n("span","x")),i=t.getBoundingClientRect(),o=Wl(t,0,1).getBoundingClientRect();return ns=Math.abs(i.left-o.left)>1}function Be(e,t){arguments.length>2&&(t.dependencies=Array.prototype.slice.call(arguments,2)),is[e]=t}function Ge(e){if("string"==typeof e&&os.hasOwnProperty(e))e=os[e];else if(e&&"string"==typeof e.name&&os.hasOwnProperty(e.name)){var t=os[e.name];"string"==typeof t&&(t={name:t}),(e=b(t,e)).name=t.name}else{if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+xml$/.test(e))return Ge("application/xml");if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+json$/.test(e))return Ge("application/json")}return"string"==typeof e?{name:e}:e||{name:"null"}}function Ue(e,t){t=Ge(t);var r=is[t.name];if(!r)return Ue(e,"text/plain");var n=r(e,t);if(ls.hasOwnProperty(t.name)){var i=ls[t.name];for(var o in i)i.hasOwnProperty(o)&&(n.hasOwnProperty(o)&&(n["_"+o]=n[o]),n[o]=i[o])}if(n.name=t.name,t.helperType&&(n.helperType=t.helperType),t.modeProps)for(var l in t.modeProps)n[l]=t.modeProps[l];return n}function Ve(e,t){c(t,ls.hasOwnProperty(e)?ls[e]:ls[e]={})}function Ke(e,t){if(!0===t)return t;if(e.copyState)return e.copyState(t);var r={};for(var n in t){var i=t[n];i instanceof Array&&(i=i.concat([])),r[n]=i}return r}function je(e,t){for(var r;e.innerMode&&(r=e.innerMode(t))&&r.mode!=e;)t=r.state,e=r.mode;return r||{mode:e,state:t}}function Xe(e,t,r){return!e.startState||e.startState(t,r)}function Ye(e,t,r,n){var i=[e.state.modeGen],o={};tt(e,t.text,e.doc.mode,r,function(e,t){return i.push(e,t)},o,n);for(var l=r.state,s=0;s<e.state.overlays.length;++s)!function(n){var l=e.state.overlays[n],s=1,a=0;r.state=!0,tt(e,t.text,l.mode,r,function(e,t){for(var r=s;a<e;){var n=i[s];n>e&&i.splice(s,1,e,i[s+1],n),s+=2,a=Math.min(e,n)}if(t)if(l.opaque)i.splice(r,s-r,e,"overlay "+t),s=r+2;else for(;r<s;r+=2){var o=i[r+1];i[r+1]=(o?o+" ":"")+"overlay "+t}},o)}(s);return r.state=l,{styles:i,classes:o.bgClass||o.textClass?o:null}}function _e(e,t,r){if(!t.styles||t.styles[0]!=e.state.modeGen){var n=$e(e,W(t)),i=t.text.length>e.options.maxHighlightLength&&Ke(e.doc.mode,n.state),o=Ye(e,t,n);i&&(n.state=i),t.stateAfter=n.save(!i),t.styles=o.styles,o.classes?t.styleClasses=o.classes:t.styleClasses&&(t.styleClasses=null),r===e.doc.highlightFrontier&&(e.doc.modeFrontier=Math.max(e.doc.modeFrontier,++e.doc.highlightFrontier))}return t.styles}function $e(e,t,r){var n=e.doc,i=e.display;if(!n.mode.startState)return new us(n,!0,t);var o=rt(e,t,r),l=o>n.first&&M(n,o-1).stateAfter,s=l?us.fromSaved(n,l,o):new us(n,Xe(n.mode),o);return n.iter(o,t,function(r){qe(e,r.text,s);var n=s.line;r.stateAfter=n==t-1||n%5==0||n>=i.viewFrom&&n<i.viewTo?s.save():null,s.nextLine()}),r&&(n.modeFrontier=s.line),s}function qe(e,t,r,n){var i=e.doc.mode,o=new ss(t,e.options.tabSize,r);for(o.start=o.pos=n||0,""==t&&Ze(i,r.state);!o.eol();)Qe(i,o,r.state),o.start=o.pos}function Ze(e,t){if(e.blankLine)return e.blankLine(t);if(e.innerMode){var r=je(e,t);return r.mode.blankLine?r.mode.blankLine(r.state):void 0}}function Qe(e,t,r,n){for(var i=0;i<10;i++){n&&(n[0]=je(e,r).mode);var o=e.token(t,r);if(t.pos>t.start)return o}throw new Error("Mode "+e.name+" failed to advance stream.")}function Je(e,t,r,n){var i,o,l=e.doc,s=l.mode,a=M(l,(t=U(l,t)).line),u=$e(e,t.line,r),c=new ss(a.text,e.options.tabSize,u);for(n&&(o=[]);(n||c.pos<t.ch)&&!c.eol();)c.start=c.pos,i=Qe(s,c,u.state),n&&o.push(new cs(c,i,Ke(l.mode,u.state)));return n?o:new cs(c,i,u.state)}function et(e,t){if(e)for(;;){var r=e.match(/(?:^|\s+)line-(background-)?(\S+)/);if(!r)break;e=e.slice(0,r.index)+e.slice(r.index+r[0].length);var n=r[1]?"bgClass":"textClass";null==t[n]?t[n]=r[2]:new RegExp("(?:^|s)"+r[2]+"(?:$|s)").test(t[n])||(t[n]+=" "+r[2])}return e}function tt(e,t,r,n,i,o,l){var s=r.flattenSpans;null==s&&(s=e.options.flattenSpans);var a,u=0,c=null,f=new ss(t,e.options.tabSize,n),h=e.options.addModeClass&&[null];for(""==t&&et(Ze(r,n.state),o);!f.eol();){if(f.pos>e.options.maxHighlightLength?(s=!1,l&&qe(e,t,n,f.pos),f.pos=t.length,a=null):a=et(Qe(r,f,n.state,h),o),h){var d=h[0].name;d&&(a="m-"+(a?d+" "+a:d))}if(!s||c!=a){for(;u<f.start;)i(u=Math.min(f.start,u+5e3),c);c=a}f.start=f.pos}for(;u<f.pos;){var p=Math.min(f.pos,u+5e3);i(p,c),u=p}}function rt(e,t,r){for(var n,i,o=e.doc,l=r?-1:t-(e.doc.mode.innerMode?1e3:100),s=t;s>l;--s){if(s<=o.first)return o.first;var a=M(o,s-1),u=a.stateAfter;if(u&&(!r||s+(u instanceof as?u.lookAhead:0)<=o.modeFrontier))return s;var c=f(a.text,null,e.options.tabSize);(null==i||n>c)&&(i=s-1,n=c)}return i}function nt(e,t){if(e.modeFrontier=Math.min(e.modeFrontier,t),!(e.highlightFrontier<t-10)){for(var r=e.first,n=t-1;n>r;n--){var i=M(e,n).stateAfter;if(i&&(!(i instanceof as)||n+i.lookAhead<t)){r=n+1;break}}e.highlightFrontier=Math.min(e.highlightFrontier,r)}}function it(e,t,r,n){e.text=t,e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null),null!=e.order&&(e.order=null),re(e),ne(e,r);var i=n?n(e):1;i!=e.height&&A(e,i)}function ot(e){e.parent=null,re(e)}function lt(e,t){if(!e||/^\s*$/.test(e))return null;var r=t.addModeClass?ps:ds;return r[e]||(r[e]=e.replace(/\S+/g,"cm-$&"))}function st(e,t){var r=i("span",null,null,ml?"padding-right: .1px":null),n={pre:i("pre",[r],"CodeMirror-line"),content:r,col:0,pos:0,cm:e,trailingSpace:!1,splitSpaces:(gl||ml)&&e.getOption("lineWrapping")};t.measure={};for(var o=0;o<=(t.rest?t.rest.length:0);o++){var l=o?t.rest[o-1]:t.line,s=void 0;n.pos=0,n.addToken=ut,ze(e.display.measure)&&(s=Se(l,e.doc.direction))&&(n.addToken=ft(n.addToken,s)),n.map=[],dt(l,n,_e(e,l,t!=e.display.externalMeasured&&W(l))),l.styleClasses&&(l.styleClasses.bgClass&&(n.bgClass=a(l.styleClasses.bgClass,n.bgClass||"")),l.styleClasses.textClass&&(n.textClass=a(l.styleClasses.textClass,n.textClass||""))),0==n.map.length&&n.map.push(0,0,n.content.appendChild(Ie(e.display.measure))),0==o?(t.measure.map=n.map,t.measure.cache={}):((t.measure.maps||(t.measure.maps=[])).push(n.map),(t.measure.caches||(t.measure.caches=[])).push({}))}if(ml){var u=n.content.lastChild;(/\bcm-tab\b/.test(u.className)||u.querySelector&&u.querySelector(".cm-tab"))&&(n.content.className="cm-tab-wrap-hack")}return Te(e,"renderLine",e,t.line,n.pre),n.pre.className&&(n.textClass=a(n.pre.className,n.textClass||"")),n}function at(e){var t=n("span","•","cm-invalidchar");return t.title="\\u"+e.charCodeAt(0).toString(16),t.setAttribute("aria-label",t.title),t}function ut(e,t,r,i,o,l,s){if(t){var a,u=e.splitSpaces?ct(t,e.trailingSpace):t,c=e.cm.state.specialChars,f=!1;if(c.test(t)){a=document.createDocumentFragment();for(var h=0;;){c.lastIndex=h;var d=c.exec(t),g=d?d.index-h:t.length-h;if(g){var v=document.createTextNode(u.slice(h,h+g));gl&&vl<9?a.appendChild(n("span",[v])):a.appendChild(v),e.map.push(e.pos,e.pos+g,v),e.col+=g,e.pos+=g}if(!d)break;h+=g+1;var m=void 0;if("\t"==d[0]){var y=e.cm.options.tabSize,b=y-e.col%y;(m=a.appendChild(n("span",p(b),"cm-tab"))).setAttribute("role","presentation"),m.setAttribute("cm-text","\t"),e.col+=b}else"\r"==d[0]||"\n"==d[0]?((m=a.appendChild(n("span","\r"==d[0]?"␍":"␤","cm-invalidchar"))).setAttribute("cm-text",d[0]),e.col+=1):((m=e.cm.options.specialCharPlaceholder(d[0])).setAttribute("cm-text",d[0]),gl&&vl<9?a.appendChild(n("span",[m])):a.appendChild(m),e.col+=1);e.map.push(e.pos,e.pos+1,m),e.pos++}}else e.col+=t.length,a=document.createTextNode(u),e.map.push(e.pos,e.pos+t.length,a),gl&&vl<9&&(f=!0),e.pos+=t.length;if(e.trailingSpace=32==u.charCodeAt(t.length-1),r||i||o||f||s){var w=r||"";i&&(w+=i),o&&(w+=o);var x=n("span",[a],w,s);return l&&(x.title=l),e.content.appendChild(x)}e.content.appendChild(a)}}function ct(e,t){if(e.length>1&&!/  /.test(e))return e;for(var r=t,n="",i=0;i<e.length;i++){var o=e.charAt(i);" "!=o||!r||i!=e.length-1&&32!=e.charCodeAt(i+1)||(o=" "),n+=o,r=" "==o}return n}function ft(e,t){return function(r,n,i,o,l,s,a){i=i?i+" cm-force-border":"cm-force-border";for(var u=r.pos,c=u+n.length;;){for(var f=void 0,h=0;h<t.length&&!((f=t[h]).to>u&&f.from<=u);h++);if(f.to>=c)return e(r,n,i,o,l,s,a);e(r,n.slice(0,f.to-u),i,o,null,s,a),o=null,n=n.slice(f.to-u),u=f.to}}}function ht(e,t,r,n){var i=!n&&r.widgetNode;i&&e.map.push(e.pos,e.pos+t,i),!n&&e.cm.display.input.needsContentAttribute&&(i||(i=e.content.appendChild(document.createElement("span"))),i.setAttribute("cm-marker",r.id)),i&&(e.cm.display.input.setUneditable(i),e.content.appendChild(i)),e.pos+=t,e.trailingSpace=!1}function dt(e,t,r){var n=e.markedSpans,i=e.text,o=0;if(n)for(var l,s,a,u,c,f,h,d=i.length,p=0,g=1,v="",m=0;;){if(m==p){a=u=c=f=s="",h=null,m=1/0;for(var y=[],b=void 0,w=0;w<n.length;++w){var x=n[w],C=x.marker;"bookmark"==C.type&&x.from==p&&C.widgetNode?y.push(C):x.from<=p&&(null==x.to||x.to>p||C.collapsed&&x.to==p&&x.from==p)?(null!=x.to&&x.to!=p&&m>x.to&&(m=x.to,u=""),C.className&&(a+=" "+C.className),C.css&&(s=(s?s+";":"")+C.css),C.startStyle&&x.from==p&&(c+=" "+C.startStyle),C.endStyle&&x.to==m&&(b||(b=[])).push(C.endStyle,x.to),C.title&&!f&&(f=C.title),C.collapsed&&(!h||le(h.marker,C)<0)&&(h=x)):x.from>p&&m>x.from&&(m=x.from)}if(b)for(var S=0;S<b.length;S+=2)b[S+1]==m&&(u+=" "+b[S]);if(!h||h.from==p)for(var L=0;L<y.length;++L)ht(t,0,y[L]);if(h&&(h.from||0)==p){if(ht(t,(null==h.to?d+1:h.to)-p,h.marker,null==h.from),null==h.to)return;h.to==p&&(h=!1)}}if(p>=d)break;for(var k=Math.min(d,m);;){if(v){var T=p+v.length;if(!h){var M=T>k?v.slice(0,k-p):v;t.addToken(t,M,l?l+a:a,c,p+M.length==m?u:"",f,s)}if(T>=k){v=v.slice(k-p),p=k;break}p=T,c=""}v=i.slice(o,o=r[g++]),l=lt(r[g++],t.cm.options)}}else for(var N=1;N<r.length;N+=2)t.addToken(t,i.slice(o,o=r[N]),lt(r[N+1],t.cm.options))}function pt(e,t,r){this.line=t,this.rest=de(t),this.size=this.rest?W(g(this.rest))-r+1:1,this.node=this.text=null,this.hidden=ve(e,t)}function gt(e,t,r){for(var n,i=[],o=t;o<r;o=n){var l=new pt(e.doc,M(e.doc,o),o);n=o+l.size,i.push(l)}return i}function vt(e){gs?gs.ops.push(e):e.ownsGroup=gs={ops:[e],delayedCallbacks:[]}}function mt(e){var t=e.delayedCallbacks,r=0;do{for(;r<t.length;r++)t[r].call(null);for(var n=0;n<e.ops.length;n++){var i=e.ops[n];if(i.cursorActivityHandlers)for(;i.cursorActivityCalled<i.cursorActivityHandlers.length;)i.cursorActivityHandlers[i.cursorActivityCalled++].call(null,i.cm)}}while(r<t.length)}function yt(e,t){var r=e.ownsGroup;if(r)try{mt(r)}finally{gs=null,t(r)}}function bt(e,t){var r=Le(e,t);if(r.length){var n,i=Array.prototype.slice.call(arguments,2);gs?n=gs.delayedCallbacks:vs?n=vs:(n=vs=[],setTimeout(wt,0));for(var o=0;o<r.length;++o)!function(e){n.push(function(){return r[e].apply(null,i)})}(o)}}function wt(){var e=vs;vs=null;for(var t=0;t<e.length;++t)e[t]()}function xt(e,t,r,n){for(var i=0;i<t.changes.length;i++){var o=t.changes[i];"text"==o?kt(e,t):"gutter"==o?Mt(e,t,r,n):"class"==o?Tt(e,t):"widget"==o&&Nt(e,t,n)}t.changes=null}function Ct(e){return e.node==e.text&&(e.node=n("div",null,null,"position: relative"),e.text.parentNode&&e.text.parentNode.replaceChild(e.node,e.text),e.node.appendChild(e.text),gl&&vl<8&&(e.node.style.zIndex=2)),e.node}function St(e,t){var r=t.bgClass?t.bgClass+" "+(t.line.bgClass||""):t.line.bgClass;if(r&&(r+=" CodeMirror-linebackground"),t.background)r?t.background.className=r:(t.background.parentNode.removeChild(t.background),t.background=null);else if(r){var i=Ct(t);t.background=i.insertBefore(n("div",null,r),i.firstChild),e.display.input.setUneditable(t.background)}}function Lt(e,t){var r=e.display.externalMeasured;return r&&r.line==t.line?(e.display.externalMeasured=null,t.measure=r.measure,r.built):st(e,t)}function kt(e,t){var r=t.text.className,n=Lt(e,t);t.text==t.node&&(t.node=n.pre),t.text.parentNode.replaceChild(n.pre,t.text),t.text=n.pre,n.bgClass!=t.bgClass||n.textClass!=t.textClass?(t.bgClass=n.bgClass,t.textClass=n.textClass,Tt(e,t)):r&&(t.text.className=r)}function Tt(e,t){St(e,t),t.line.wrapClass?Ct(t).className=t.line.wrapClass:t.node!=t.text&&(t.node.className="");var r=t.textClass?t.textClass+" "+(t.line.textClass||""):t.line.textClass;t.text.className=r||""}function Mt(e,t,r,i){if(t.gutter&&(t.node.removeChild(t.gutter),t.gutter=null),t.gutterBackground&&(t.node.removeChild(t.gutterBackground),t.gutterBackground=null),t.line.gutterClass){var o=Ct(t);t.gutterBackground=n("div",null,"CodeMirror-gutter-background "+t.line.gutterClass,"left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px; width: "+i.gutterTotalWidth+"px"),e.display.input.setUneditable(t.gutterBackground),o.insertBefore(t.gutterBackground,t.text)}var l=t.line.gutterMarkers;if(e.options.lineNumbers||l){var s=Ct(t),a=t.gutter=n("div",null,"CodeMirror-gutter-wrapper","left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px");if(e.display.input.setUneditable(a),s.insertBefore(a,t.text),t.line.gutterClass&&(a.className+=" "+t.line.gutterClass),!e.options.lineNumbers||l&&l["CodeMirror-linenumbers"]||(t.lineNumber=a.appendChild(n("div",F(e.options,r),"CodeMirror-linenumber CodeMirror-gutter-elt","left: "+i.gutterLeft["CodeMirror-linenumbers"]+"px; width: "+e.display.lineNumInnerWidth+"px"))),l)for(var u=0;u<e.options.gutters.length;++u){var c=e.options.gutters[u],f=l.hasOwnProperty(c)&&l[c];f&&a.appendChild(n("div",[f],"CodeMirror-gutter-elt","left: "+i.gutterLeft[c]+"px; width: "+i.gutterWidth[c]+"px"))}}}function Nt(e,t,r){t.alignable&&(t.alignable=null);for(var n=t.node.firstChild,i=void 0;n;n=i)i=n.nextSibling,"CodeMirror-linewidget"==n.className&&t.node.removeChild(n);At(e,t,r)}function Ot(e,t,r,n){var i=Lt(e,t);return t.text=t.node=i.pre,i.bgClass&&(t.bgClass=i.bgClass),i.textClass&&(t.textClass=i.textClass),Tt(e,t),Mt(e,t,r,n),At(e,t,n),t.node}function At(e,t,r){if(Wt(e,t.line,t,r,!0),t.rest)for(var n=0;n<t.rest.length;n++)Wt(e,t.rest[n],t,r,!1)}function Wt(e,t,r,i,o){if(t.widgets)for(var l=Ct(r),s=0,a=t.widgets;s<a.length;++s){var u=a[s],c=n("div",[u.node],"CodeMirror-linewidget");u.handleMouseEvents||c.setAttribute("cm-ignore-events","true"),Dt(u,c,r,i),e.display.input.setUneditable(c),o&&u.above?l.insertBefore(c,r.gutter||r.text):l.appendChild(c),bt(u,"redraw")}}function Dt(e,t,r,n){if(e.noHScroll){(r.alignable||(r.alignable=[])).push(t);var i=n.wrapperWidth;t.style.left=n.fixedPos+"px",e.coverGutter||(i-=n.gutterTotalWidth,t.style.paddingLeft=n.gutterTotalWidth+"px"),t.style.width=i+"px"}e.coverGutter&&(t.style.zIndex=5,t.style.position="relative",e.noHScroll||(t.style.marginLeft=-n.gutterTotalWidth+"px"))}function Ht(e){if(null!=e.height)return e.height;var t=e.doc.cm;if(!t)return 0;if(!o(document.body,e.node)){var i="position: relative;";e.coverGutter&&(i+="margin-left: -"+t.display.gutters.offsetWidth+"px;"),e.noHScroll&&(i+="width: "+t.display.wrapper.clientWidth+"px;"),r(t.display.measure,n("div",[e.node],null,i))}return e.height=e.node.parentNode.offsetHeight}function Ft(e,t){for(var r=Ee(t);r!=e.wrapper;r=r.parentNode)if(!r||1==r.nodeType&&"true"==r.getAttribute("cm-ignore-events")||r.parentNode==e.sizer&&r!=e.mover)return!0}function Et(e){return e.lineSpace.offsetTop}function Pt(e){return e.mover.offsetHeight-e.lineSpace.offsetHeight}function It(e){if(e.cachedPaddingH)return e.cachedPaddingH;var t=r(e.measure,n("pre","x")),i=window.getComputedStyle?window.getComputedStyle(t):t.currentStyle,o={left:parseInt(i.paddingLeft),right:parseInt(i.paddingRight)};return isNaN(o.left)||isNaN(o.right)||(e.cachedPaddingH=o),o}function zt(e){return Rl-e.display.nativeBarWidth}function Rt(e){return e.display.scroller.clientWidth-zt(e)-e.display.barWidth}function Bt(e){return e.display.scroller.clientHeight-zt(e)-e.display.barHeight}function Gt(e,t,r){var n=e.options.lineWrapping,i=n&&Rt(e);if(!t.measure.heights||n&&t.measure.width!=i){var o=t.measure.heights=[];if(n){t.measure.width=i;for(var l=t.text.firstChild.getClientRects(),s=0;s<l.length-1;s++){var a=l[s],u=l[s+1];Math.abs(a.bottom-u.bottom)>2&&o.push((a.bottom+u.top)/2-r.top)}}o.push(r.bottom-r.top)}}function Ut(e,t,r){if(e.line==t)return{map:e.measure.map,cache:e.measure.cache};for(var n=0;n<e.rest.length;n++)if(e.rest[n]==t)return{map:e.measure.maps[n],cache:e.measure.caches[n]};for(var i=0;i<e.rest.length;i++)if(W(e.rest[i])>r)return{map:e.measure.maps[i],cache:e.measure.caches[i],before:!0}}function Vt(e,t){var n=W(t=fe(t)),i=e.display.externalMeasured=new pt(e.doc,t,n);i.lineN=n;var o=i.built=st(e,i);return i.text=o.pre,r(e.display.lineMeasure,o.pre),i}function Kt(e,t,r,n){return Yt(e,Xt(e,t),r,n)}function jt(e,t){if(t>=e.display.viewFrom&&t<e.display.viewTo)return e.display.view[Lr(e,t)];var r=e.display.externalMeasured;return r&&t>=r.lineN&&t<r.lineN+r.size?r:void 0}function Xt(e,t){var r=W(t),n=jt(e,r);n&&!n.text?n=null:n&&n.changes&&(xt(e,n,r,br(e)),e.curOp.forceUpdate=!0),n||(n=Vt(e,t));var i=Ut(n,t,r);return{line:t,view:n,rect:null,map:i.map,cache:i.cache,before:i.before,hasHeights:!1}}function Yt(e,t,r,n,i){t.before&&(r=-1);var o,l=r+(n||"");return t.cache.hasOwnProperty(l)?o=t.cache[l]:(t.rect||(t.rect=t.view.text.getBoundingClientRect()),t.hasHeights||(Gt(e,t.view,t.rect),t.hasHeights=!0),(o=qt(e,t,r,n)).bogus||(t.cache[l]=o)),{left:o.left,right:o.right,top:i?o.rtop:o.top,bottom:i?o.rbottom:o.bottom}}function _t(e,t,r){for(var n,i,o,l,s,a,u=0;u<e.length;u+=3)if(s=e[u],a=e[u+1],t<s?(i=0,o=1,l="left"):t<a?o=(i=t-s)+1:(u==e.length-3||t==a&&e[u+3]>t)&&(i=(o=a-s)-1,t>=a&&(l="right")),null!=i){if(n=e[u+2],s==a&&r==(n.insertLeft?"left":"right")&&(l=r),"left"==r&&0==i)for(;u&&e[u-2]==e[u-3]&&e[u-1].insertLeft;)n=e[2+(u-=3)],l="left";if("right"==r&&i==a-s)for(;u<e.length-3&&e[u+3]==e[u+4]&&!e[u+5].insertLeft;)n=e[(u+=3)+2],l="right";break}return{node:n,start:i,end:o,collapse:l,coverStart:s,coverEnd:a}}function $t(e,t){var r=ms;if("left"==t)for(var n=0;n<e.length&&(r=e[n]).left==r.right;n++);else for(var i=e.length-1;i>=0&&(r=e[i]).left==r.right;i--);return r}function qt(e,t,r,n){var i,o=_t(t.map,r,n),l=o.node,s=o.start,a=o.end,u=o.collapse;if(3==l.nodeType){for(var c=0;c<4;c++){for(;s&&S(t.line.text.charAt(o.coverStart+s));)--s;for(;o.coverStart+a<o.coverEnd&&S(t.line.text.charAt(o.coverStart+a));)++a;if((i=gl&&vl<9&&0==s&&a==o.coverEnd-o.coverStart?l.parentNode.getBoundingClientRect():$t(Wl(l,s,a).getClientRects(),n)).left||i.right||0==s)break;a=s,s-=1,u="right"}gl&&vl<11&&(i=Zt(e.display.measure,i))}else{s>0&&(u=n="right");var f;i=e.options.lineWrapping&&(f=l.getClientRects()).length>1?f["right"==n?f.length-1:0]:l.getBoundingClientRect()}if(gl&&vl<9&&!s&&(!i||!i.left&&!i.right)){var h=l.parentNode.getClientRects()[0];i=h?{left:h.left,right:h.left+yr(e.display),top:h.top,bottom:h.bottom}:ms}for(var d=i.top-t.rect.top,p=i.bottom-t.rect.top,g=(d+p)/2,v=t.view.measure.heights,m=0;m<v.length-1&&!(g<v[m]);m++);var y=m?v[m-1]:0,b=v[m],w={left:("right"==u?i.right:i.left)-t.rect.left,right:("left"==u?i.left:i.right)-t.rect.left,top:y,bottom:b};return i.left||i.right||(w.bogus=!0),e.options.singleCursorHeightPerLine||(w.rtop=d,w.rbottom=p),w}function Zt(e,t){if(!window.screen||null==screen.logicalXDPI||screen.logicalXDPI==screen.deviceXDPI||!Re(e))return t;var r=screen.logicalXDPI/screen.deviceXDPI,n=screen.logicalYDPI/screen.deviceYDPI;return{left:t.left*r,right:t.right*r,top:t.top*n,bottom:t.bottom*n}}function Qt(e){if(e.measure&&(e.measure.cache={},e.measure.heights=null,e.rest))for(var t=0;t<e.rest.length;t++)e.measure.caches[t]={}}function Jt(e){e.display.externalMeasure=null,t(e.display.lineMeasure);for(var r=0;r<e.display.view.length;r++)Qt(e.display.view[r])}function er(e){Jt(e),e.display.cachedCharWidth=e.display.cachedTextHeight=e.display.cachedPaddingH=null,e.options.lineWrapping||(e.display.maxLineChanged=!0),e.display.lineNumChars=null}function tr(){return bl&&kl?-(document.body.getBoundingClientRect().left-parseInt(getComputedStyle(document.body).marginLeft)):window.pageXOffset||(document.documentElement||document.body).scrollLeft}function rr(){return bl&&kl?-(document.body.getBoundingClientRect().top-parseInt(getComputedStyle(document.body).marginTop)):window.pageYOffset||(document.documentElement||document.body).scrollTop}function nr(e){var t=0;if(e.widgets)for(var r=0;r<e.widgets.length;++r)e.widgets[r].above&&(t+=Ht(e.widgets[r]));return t}function ir(e,t,r,n,i){if(!i){var o=nr(t);r.top+=o,r.bottom+=o}if("line"==n)return r;n||(n="local");var l=ye(t);if("local"==n?l+=Et(e.display):l-=e.display.viewOffset,"page"==n||"window"==n){var s=e.display.lineSpace.getBoundingClientRect();l+=s.top+("window"==n?0:rr());var a=s.left+("window"==n?0:tr());r.left+=a,r.right+=a}return r.top+=l,r.bottom+=l,r}function or(e,t,r){if("div"==r)return t;var n=t.left,i=t.top;if("page"==r)n-=tr(),i-=rr();else if("local"==r||!r){var o=e.display.sizer.getBoundingClientRect();n+=o.left,i+=o.top}var l=e.display.lineSpace.getBoundingClientRect();return{left:n-l.left,top:i-l.top}}function lr(e,t,r,n,i){return n||(n=M(e.doc,t.line)),ir(e,n,Kt(e,n,t.ch,i),r)}function sr(e,t,r,n,i,o){function l(t,l){var s=Yt(e,i,t,l?"right":"left",o);return l?s.left=s.right:s.right=s.left,ir(e,n,s,r)}function s(e,t,r){var n=1==a[t].level;return l(r?e-1:e,n!=r)}n=n||M(e.doc,t.line),i||(i=Xt(e,n));var a=Se(n,e.doc.direction),u=t.ch,c=t.sticky;if(u>=n.text.length?(u=n.text.length,c="before"):u<=0&&(u=0,c="after"),!a)return l("before"==c?u-1:u,"before"==c);var f=Ce(a,u,c),h=$l,d=s(u,f,"before"==c);return null!=h&&(d.other=s(u,h,"before"!=c)),d}function ar(e,t){var r=0;t=U(e.doc,t),e.options.lineWrapping||(r=yr(e.display)*t.ch);var n=M(e.doc,t.line),i=ye(n)+Et(e.display);return{left:r,right:r,top:i,bottom:i+n.height}}function ur(e,t,r,n,i){var o=E(e,t,r);return o.xRel=i,n&&(o.outside=!0),o}function cr(e,t,r){var n=e.doc;if((r+=e.display.viewOffset)<0)return ur(n.first,0,null,!0,-1);var i=D(n,r),o=n.first+n.size-1;if(i>o)return ur(n.first+n.size-1,M(n,o).text.length,null,!0,1);t<0&&(t=0);for(var l=M(n,i);;){var s=pr(e,l,i,t,r),a=ue(l),u=a&&a.find(0,!0);if(!a||!(s.ch>u.from.ch||s.ch==u.from.ch&&s.xRel>0))return s;i=W(l=u.to.line)}}function fr(e,t,r,n){n-=nr(t);var i=t.text.length,o=k(function(t){return Yt(e,r,t-1).bottom<=n},i,0);return i=k(function(t){return Yt(e,r,t).top>n},o,i),{begin:o,end:i}}function hr(e,t,r,n){return r||(r=Xt(e,t)),fr(e,t,r,ir(e,t,Yt(e,r,n),"line").top)}function dr(e,t,r,n){return!(e.bottom<=r)&&(e.top>r||(n?e.left:e.right)>t)}function pr(e,t,r,n,i){i-=ye(t);var o=Xt(e,t),l=nr(t),s=0,a=t.text.length,u=!0,c=Se(t,e.doc.direction);if(c){var f=(e.options.lineWrapping?vr:gr)(e,t,r,o,c,n,i);s=(u=1!=f.level)?f.from:f.to-1,a=u?f.to:f.from-1}var h,d,p=null,g=null,v=k(function(t){var r=Yt(e,o,t);return r.top+=l,r.bottom+=l,!!dr(r,n,i,!1)&&(r.top<=i&&r.left<=n&&(p=t,g=r),!0)},s,a),m=!1;if(g){var y=n-g.left<g.right-n,b=y==u;v=p+(b?0:1),d=b?"after":"before",h=y?g.left:g.right}else{u||v!=a&&v!=s||v++,d=0==v?"after":v==t.text.length?"before":Yt(e,o,v-(u?1:0)).bottom+l<=i==u?"after":"before";var w=sr(e,E(r,v,d),"line",t,o);h=w.left,m=i<w.top||i>=w.bottom}return v=L(t.text,v,1),ur(r,v,d,m,n-h)}function gr(e,t,r,n,i,o,l){var s=k(function(s){var a=i[s],u=1!=a.level;return dr(sr(e,E(r,u?a.to:a.from,u?"before":"after"),"line",t,n),o,l,!0)},0,i.length-1),a=i[s];if(s>0){var u=1!=a.level,c=sr(e,E(r,u?a.from:a.to,u?"after":"before"),"line",t,n);dr(c,o,l,!0)&&c.top>l&&(a=i[s-1])}return a}function vr(e,t,r,n,i,o,l){for(var s=fr(e,t,n,l),a=s.begin,u=s.end,c=null,f=null,h=0;h<i.length;h++){var d=i[h];if(!(d.from>=u||d.to<=a)){var p=Yt(e,n,1!=d.level?Math.min(u,d.to)-1:Math.max(a,d.from)).right,g=p<o?o-p+1e9:p-o;(!c||f>g)&&(c=d,f=g)}}return c||(c=i[i.length-1]),c.from<a&&(c={from:a,to:c.to,level:c.level}),c.to>u&&(c={from:c.from,to:u,level:c.level}),c}function mr(e){if(null!=e.cachedTextHeight)return e.cachedTextHeight;if(null==hs){hs=n("pre");for(var i=0;i<49;++i)hs.appendChild(document.createTextNode("x")),hs.appendChild(n("br"));hs.appendChild(document.createTextNode("x"))}r(e.measure,hs);var o=hs.offsetHeight/50;return o>3&&(e.cachedTextHeight=o),t(e.measure),o||1}function yr(e){if(null!=e.cachedCharWidth)return e.cachedCharWidth;var t=n("span","xxxxxxxxxx"),i=n("pre",[t]);r(e.measure,i);var o=t.getBoundingClientRect(),l=(o.right-o.left)/10;return l>2&&(e.cachedCharWidth=l),l||10}function br(e){for(var t=e.display,r={},n={},i=t.gutters.clientLeft,o=t.gutters.firstChild,l=0;o;o=o.nextSibling,++l)r[e.options.gutters[l]]=o.offsetLeft+o.clientLeft+i,n[e.options.gutters[l]]=o.clientWidth;return{fixedPos:wr(t),gutterTotalWidth:t.gutters.offsetWidth,gutterLeft:r,gutterWidth:n,wrapperWidth:t.wrapper.clientWidth}}function wr(e){return e.scroller.getBoundingClientRect().left-e.sizer.getBoundingClientRect().left}function xr(e){var t=mr(e.display),r=e.options.lineWrapping,n=r&&Math.max(5,e.display.scroller.clientWidth/yr(e.display)-3);return function(i){if(ve(e.doc,i))return 0;var o=0;if(i.widgets)for(var l=0;l<i.widgets.length;l++)i.widgets[l].height&&(o+=i.widgets[l].height);return r?o+(Math.ceil(i.text.length/n)||1)*t:o+t}}function Cr(e){var t=e.doc,r=xr(e);t.iter(function(e){var t=r(e);t!=e.height&&A(e,t)})}function Sr(e,t,r,n){var i=e.display;if(!r&&"true"==Ee(t).getAttribute("cm-not-content"))return null;var o,l,s=i.lineSpace.getBoundingClientRect();try{o=t.clientX-s.left,l=t.clientY-s.top}catch(t){return null}var a,u=cr(e,o,l);if(n&&1==u.xRel&&(a=M(e.doc,u.line).text).length==u.ch){var c=f(a,a.length,e.options.tabSize)-a.length;u=E(u.line,Math.max(0,Math.round((o-It(e.display).left)/yr(e.display))-c))}return u}function Lr(e,t){if(t>=e.display.viewTo)return null;if((t-=e.display.viewFrom)<0)return null;for(var r=e.display.view,n=0;n<r.length;n++)if((t-=r[n].size)<0)return n}function kr(e){e.display.input.showSelection(e.display.input.prepareSelection())}function Tr(e,t){void 0===t&&(t=!0);for(var r=e.doc,n={},i=n.cursors=document.createDocumentFragment(),o=n.selection=document.createDocumentFragment(),l=0;l<r.sel.ranges.length;l++)if(t||l!=r.sel.primIndex){var s=r.sel.ranges[l];if(!(s.from().line>=e.display.viewTo||s.to().line<e.display.viewFrom)){var a=s.empty();(a||e.options.showCursorWhenSelecting)&&Mr(e,s.head,i),a||Or(e,s,o)}}return n}function Mr(e,t,r){var i=sr(e,t,"div",null,null,!e.options.singleCursorHeightPerLine),o=r.appendChild(n("div"," ","CodeMirror-cursor"));if(o.style.left=i.left+"px",o.style.top=i.top+"px",o.style.height=Math.max(0,i.bottom-i.top)*e.options.cursorHeight+"px",i.other){var l=r.appendChild(n("div"," ","CodeMirror-cursor CodeMirror-secondarycursor"));l.style.display="",l.style.left=i.other.left+"px",l.style.top=i.other.top+"px",l.style.height=.85*(i.other.bottom-i.other.top)+"px"}}function Nr(e,t){return e.top-t.top||e.left-t.left}function Or(e,t,r){function i(e,t,r,i){t<0&&(t=0),t=Math.round(t),i=Math.round(i),a.appendChild(n("div",null,"CodeMirror-selected","position: absolute; left: "+e+"px;\n                             top: "+t+"px; width: "+(null==r?f-e:r)+"px;\n                             height: "+(i-t)+"px"))}function o(t,r,n){function o(r,n){return lr(e,E(t,r),"div",u,n)}var l,a,u=M(s,t),h=u.text.length,d=Se(u,s.direction);return xe(d,r||0,null==n?h:n,function(t,s,p,g){var v=o(t,"ltr"==p?"left":"right"),m=o(s-1,"ltr"==p?"right":"left");if("ltr"==p){var y=null==r&&0==t?c:v.left,b=null==n&&s==h?f:m.right;m.top-v.top<=3?i(y,m.top,b-y,m.bottom):(i(y,v.top,null,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top),i(c,m.top,m.right,m.bottom))}else if(t<s){var w=null==r&&0==t?f:v.right,x=null==n&&s==h?c:m.left;if(m.top-v.top<=3)i(x,m.top,w-x,m.bottom);else{var C=c;if(g){var S=hr(e,u,null,t).end;C=o(S-(/\s/.test(u.text.charAt(S-1))?2:1),"left").left}i(C,v.top,w-C,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top);var L=null;d.length,L=o(hr(e,u,null,s).begin,"right").right-x,i(x,m.top,L,m.bottom)}}(!l||Nr(v,l)<0)&&(l=v),Nr(m,l)<0&&(l=m),(!a||Nr(v,a)<0)&&(a=v),Nr(m,a)<0&&(a=m)}),{start:l,end:a}}var l=e.display,s=e.doc,a=document.createDocumentFragment(),u=It(e.display),c=u.left,f=Math.max(l.sizerWidth,Rt(e)-l.sizer.offsetLeft)-u.right,h=t.from(),d=t.to();if(h.line==d.line)o(h.line,h.ch,d.ch);else{var p=M(s,h.line),g=M(s,d.line),v=fe(p)==fe(g),m=o(h.line,h.ch,v?p.text.length+1:null).end,y=o(d.line,v?0:null,d.ch).start;v&&(m.top<y.top-2?(i(m.right,m.top,null,m.bottom),i(c,y.top,y.left,y.bottom)):i(m.right,m.top,y.left-m.right,m.bottom)),m.bottom<y.top&&i(c,m.bottom,null,y.top)}r.appendChild(a)}function Ar(e){if(e.state.focused){var t=e.display;clearInterval(t.blinker);var r=!0;t.cursorDiv.style.visibility="",e.options.cursorBlinkRate>0?t.blinker=setInterval(function(){return t.cursorDiv.style.visibility=(r=!r)?"":"hidden"},e.options.cursorBlinkRate):e.options.cursorBlinkRate<0&&(t.cursorDiv.style.visibility="hidden")}}function Wr(e){e.state.focused||(e.display.input.focus(),Hr(e))}function Dr(e){e.state.delayingBlurEvent=!0,setTimeout(function(){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1,Fr(e))},100)}function Hr(e,t){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1),"nocursor"!=e.options.readOnly&&(e.state.focused||(Te(e,"focus",e,t),e.state.focused=!0,s(e.display.wrapper,"CodeMirror-focused"),e.curOp||e.display.selForContextMenu==e.doc.sel||(e.display.input.reset(),ml&&setTimeout(function(){return e.display.input.reset(!0)},20)),e.display.input.receivedFocus()),Ar(e))}function Fr(e,t){e.state.delayingBlurEvent||(e.state.focused&&(Te(e,"blur",e,t),e.state.focused=!1,Fl(e.display.wrapper,"CodeMirror-focused")),clearInterval(e.display.blinker),setTimeout(function(){e.state.focused||(e.display.shift=!1)},150))}function Er(e){for(var t=e.display,r=t.lineDiv.offsetTop,n=0;n<t.view.length;n++){var i=t.view[n],o=void 0;if(!i.hidden){if(gl&&vl<8){var l=i.node.offsetTop+i.node.offsetHeight;o=l-r,r=l}else{var s=i.node.getBoundingClientRect();o=s.bottom-s.top}var a=i.line.height-o;if(o<2&&(o=mr(t)),(a>.005||a<-.005)&&(A(i.line,o),Pr(i.line),i.rest))for(var u=0;u<i.rest.length;u++)Pr(i.rest[u])}}}function Pr(e){if(e.widgets)for(var t=0;t<e.widgets.length;++t)e.widgets[t].height=e.widgets[t].node.parentNode.offsetHeight}function Ir(e,t,r){var n=r&&null!=r.top?Math.max(0,r.top):e.scroller.scrollTop;n=Math.floor(n-Et(e));var i=r&&null!=r.bottom?r.bottom:n+e.wrapper.clientHeight,o=D(t,n),l=D(t,i);if(r&&r.ensure){var s=r.ensure.from.line,a=r.ensure.to.line;s<o?(o=s,l=D(t,ye(M(t,s))+e.wrapper.clientHeight)):Math.min(a,t.lastLine())>=l&&(o=D(t,ye(M(t,a))-e.wrapper.clientHeight),l=a)}return{from:o,to:Math.max(l,o+1)}}function zr(e){var t=e.display,r=t.view;if(t.alignWidgets||t.gutters.firstChild&&e.options.fixedGutter){for(var n=wr(t)-t.scroller.scrollLeft+e.doc.scrollLeft,i=t.gutters.offsetWidth,o=n+"px",l=0;l<r.length;l++)if(!r[l].hidden){e.options.fixedGutter&&(r[l].gutter&&(r[l].gutter.style.left=o),r[l].gutterBackground&&(r[l].gutterBackground.style.left=o));var s=r[l].alignable;if(s)for(var a=0;a<s.length;a++)s[a].style.left=o}e.options.fixedGutter&&(t.gutters.style.left=n+i+"px")}}function Rr(e){if(!e.options.lineNumbers)return!1;var t=e.doc,r=F(e.options,t.first+t.size-1),i=e.display;if(r.length!=i.lineNumChars){var o=i.measure.appendChild(n("div",[n("div",r)],"CodeMirror-linenumber CodeMirror-gutter-elt")),l=o.firstChild.offsetWidth,s=o.offsetWidth-l;return i.lineGutter.style.width="",i.lineNumInnerWidth=Math.max(l,i.lineGutter.offsetWidth-s)+1,i.lineNumWidth=i.lineNumInnerWidth+s,i.lineNumChars=i.lineNumInnerWidth?r.length:-1,i.lineGutter.style.width=i.lineNumWidth+"px",Wn(e),!0}return!1}function Br(e,t){if(!Me(e,"scrollCursorIntoView")){var r=e.display,i=r.sizer.getBoundingClientRect(),o=null;if(t.top+i.top<0?o=!0:t.bottom+i.top>(window.innerHeight||document.documentElement.clientHeight)&&(o=!1),null!=o&&!Sl){var l=n("div","​",null,"position: absolute;\n                         top: "+(t.top-r.viewOffset-Et(e.display))+"px;\n                         height: "+(t.bottom-t.top+zt(e)+r.barHeight)+"px;\n                         left: "+t.left+"px; width: "+Math.max(2,t.right-t.left)+"px;");e.display.lineSpace.appendChild(l),l.scrollIntoView(o),e.display.lineSpace.removeChild(l)}}}function Gr(e,t,r,n){null==n&&(n=0);var i;e.options.lineWrapping||t!=r||(r="before"==(t=t.ch?E(t.line,"before"==t.sticky?t.ch-1:t.ch,"after"):t).sticky?E(t.line,t.ch+1,"before"):t);for(var o=0;o<5;o++){var l=!1,s=sr(e,t),a=r&&r!=t?sr(e,r):s,u=Vr(e,i={left:Math.min(s.left,a.left),top:Math.min(s.top,a.top)-n,right:Math.max(s.left,a.left),bottom:Math.max(s.bottom,a.bottom)+n}),c=e.doc.scrollTop,f=e.doc.scrollLeft;if(null!=u.scrollTop&&(qr(e,u.scrollTop),Math.abs(e.doc.scrollTop-c)>1&&(l=!0)),null!=u.scrollLeft&&(Qr(e,u.scrollLeft),Math.abs(e.doc.scrollLeft-f)>1&&(l=!0)),!l)break}return i}function Ur(e,t){var r=Vr(e,t);null!=r.scrollTop&&qr(e,r.scrollTop),null!=r.scrollLeft&&Qr(e,r.scrollLeft)}function Vr(e,t){var r=e.display,n=mr(e.display);t.top<0&&(t.top=0);var i=e.curOp&&null!=e.curOp.scrollTop?e.curOp.scrollTop:r.scroller.scrollTop,o=Bt(e),l={};t.bottom-t.top>o&&(t.bottom=t.top+o);var s=e.doc.height+Pt(r),a=t.top<n,u=t.bottom>s-n;if(t.top<i)l.scrollTop=a?0:t.top;else if(t.bottom>i+o){var c=Math.min(t.top,(u?s:t.bottom)-o);c!=i&&(l.scrollTop=c)}var f=e.curOp&&null!=e.curOp.scrollLeft?e.curOp.scrollLeft:r.scroller.scrollLeft,h=Rt(e)-(e.options.fixedGutter?r.gutters.offsetWidth:0),d=t.right-t.left>h;return d&&(t.right=t.left+h),t.left<10?l.scrollLeft=0:t.left<f?l.scrollLeft=Math.max(0,t.left-(d?0:10)):t.right>h+f-3&&(l.scrollLeft=t.right+(d?0:10)-h),l}function Kr(e,t){null!=t&&(_r(e),e.curOp.scrollTop=(null==e.curOp.scrollTop?e.doc.scrollTop:e.curOp.scrollTop)+t)}function jr(e){_r(e);var t=e.getCursor();e.curOp.scrollToPos={from:t,to:t,margin:e.options.cursorScrollMargin}}function Xr(e,t,r){null==t&&null==r||_r(e),null!=t&&(e.curOp.scrollLeft=t),null!=r&&(e.curOp.scrollTop=r)}function Yr(e,t){_r(e),e.curOp.scrollToPos=t}function _r(e){var t=e.curOp.scrollToPos;t&&(e.curOp.scrollToPos=null,$r(e,ar(e,t.from),ar(e,t.to),t.margin))}function $r(e,t,r,n){var i=Vr(e,{left:Math.min(t.left,r.left),top:Math.min(t.top,r.top)-n,right:Math.max(t.right,r.right),bottom:Math.max(t.bottom,r.bottom)+n});Xr(e,i.scrollLeft,i.scrollTop)}function qr(e,t){Math.abs(e.doc.scrollTop-t)<2||(fl||On(e,{top:t}),Zr(e,t,!0),fl&&On(e),Cn(e,100))}function Zr(e,t,r){t=Math.min(e.display.scroller.scrollHeight-e.display.scroller.clientHeight,t),(e.display.scroller.scrollTop!=t||r)&&(e.doc.scrollTop=t,e.display.scrollbars.setScrollTop(t),e.display.scroller.scrollTop!=t&&(e.display.scroller.scrollTop=t))}function Qr(e,t,r,n){t=Math.min(t,e.display.scroller.scrollWidth-e.display.scroller.clientWidth),(r?t==e.doc.scrollLeft:Math.abs(e.doc.scrollLeft-t)<2)&&!n||(e.doc.scrollLeft=t,zr(e),e.display.scroller.scrollLeft!=t&&(e.display.scroller.scrollLeft=t),e.display.scrollbars.setScrollLeft(t))}function Jr(e){var t=e.display,r=t.gutters.offsetWidth,n=Math.round(e.doc.height+Pt(e.display));return{clientHeight:t.scroller.clientHeight,viewHeight:t.wrapper.clientHeight,scrollWidth:t.scroller.scrollWidth,clientWidth:t.scroller.clientWidth,viewWidth:t.wrapper.clientWidth,barLeft:e.options.fixedGutter?r:0,docHeight:n,scrollHeight:n+zt(e)+t.barHeight,nativeBarWidth:t.nativeBarWidth,gutterWidth:r}}function en(e,t){t||(t=Jr(e));var r=e.display.barWidth,n=e.display.barHeight;tn(e,t);for(var i=0;i<4&&r!=e.display.barWidth||n!=e.display.barHeight;i++)r!=e.display.barWidth&&e.options.lineWrapping&&Er(e),tn(e,Jr(e)),r=e.display.barWidth,n=e.display.barHeight}function tn(e,t){var r=e.display,n=r.scrollbars.update(t);r.sizer.style.paddingRight=(r.barWidth=n.right)+"px",r.sizer.style.paddingBottom=(r.barHeight=n.bottom)+"px",r.heightForcer.style.borderBottom=n.bottom+"px solid transparent",n.right&&n.bottom?(r.scrollbarFiller.style.display="block",r.scrollbarFiller.style.height=n.bottom+"px",r.scrollbarFiller.style.width=n.right+"px"):r.scrollbarFiller.style.display="",n.bottom&&e.options.coverGutterNextToScrollbar&&e.options.fixedGutter?(r.gutterFiller.style.display="block",r.gutterFiller.style.height=n.bottom+"px",r.gutterFiller.style.width=t.gutterWidth+"px"):r.gutterFiller.style.display=""}function rn(e){e.display.scrollbars&&(e.display.scrollbars.clear(),e.display.scrollbars.addClass&&Fl(e.display.wrapper,e.display.scrollbars.addClass)),e.display.scrollbars=new ws[e.options.scrollbarStyle](function(t){e.display.wrapper.insertBefore(t,e.display.scrollbarFiller),Ql(t,"mousedown",function(){e.state.focused&&setTimeout(function(){return e.display.input.focus()},0)}),t.setAttribute("cm-not-content","true")},function(t,r){"horizontal"==r?Qr(e,t):qr(e,t)},e),e.display.scrollbars.addClass&&s(e.display.wrapper,e.display.scrollbars.addClass)}function nn(e){e.curOp={cm:e,viewChanged:!1,startHeight:e.doc.height,forceUpdate:!1,updateInput:null,typing:!1,changeObjs:null,cursorActivityHandlers:null,cursorActivityCalled:0,selectionChanged:!1,updateMaxLine:!1,scrollLeft:null,scrollTop:null,scrollToPos:null,focus:!1,id:++xs},vt(e.curOp)}function on(e){yt(e.curOp,function(e){for(var t=0;t<e.ops.length;t++)e.ops[t].cm.curOp=null;ln(e)})}function ln(e){for(var t=e.ops,r=0;r<t.length;r++)sn(t[r]);for(var n=0;n<t.length;n++)an(t[n]);for(var i=0;i<t.length;i++)un(t[i]);for(var o=0;o<t.length;o++)cn(t[o]);for(var l=0;l<t.length;l++)fn(t[l])}function sn(e){var t=e.cm,r=t.display;Ln(t),e.updateMaxLine&&we(t),e.mustUpdate=e.viewChanged||e.forceUpdate||null!=e.scrollTop||e.scrollToPos&&(e.scrollToPos.from.line<r.viewFrom||e.scrollToPos.to.line>=r.viewTo)||r.maxLineChanged&&t.options.lineWrapping,e.update=e.mustUpdate&&new Cs(t,e.mustUpdate&&{top:e.scrollTop,ensure:e.scrollToPos},e.forceUpdate)}function an(e){e.updatedDisplay=e.mustUpdate&&Mn(e.cm,e.update)}function un(e){var t=e.cm,r=t.display;e.updatedDisplay&&Er(t),e.barMeasure=Jr(t),r.maxLineChanged&&!t.options.lineWrapping&&(e.adjustWidthTo=Kt(t,r.maxLine,r.maxLine.text.length).left+3,t.display.sizerWidth=e.adjustWidthTo,e.barMeasure.scrollWidth=Math.max(r.scroller.clientWidth,r.sizer.offsetLeft+e.adjustWidthTo+zt(t)+t.display.barWidth),e.maxScrollLeft=Math.max(0,r.sizer.offsetLeft+e.adjustWidthTo-Rt(t))),(e.updatedDisplay||e.selectionChanged)&&(e.preparedSelection=r.input.prepareSelection())}function cn(e){var t=e.cm;null!=e.adjustWidthTo&&(t.display.sizer.style.minWidth=e.adjustWidthTo+"px",e.maxScrollLeft<t.doc.scrollLeft&&Qr(t,Math.min(t.display.scroller.scrollLeft,e.maxScrollLeft),!0),t.display.maxLineChanged=!1);var r=e.focus&&e.focus==l();e.preparedSelection&&t.display.input.showSelection(e.preparedSelection,r),(e.updatedDisplay||e.startHeight!=t.doc.height)&&en(t,e.barMeasure),e.updatedDisplay&&Dn(t,e.barMeasure),e.selectionChanged&&Ar(t),t.state.focused&&e.updateInput&&t.display.input.reset(e.typing),r&&Wr(e.cm)}function fn(e){var t=e.cm,r=t.display,n=t.doc;e.updatedDisplay&&Nn(t,e.update),null==r.wheelStartX||null==e.scrollTop&&null==e.scrollLeft&&!e.scrollToPos||(r.wheelStartX=r.wheelStartY=null),null!=e.scrollTop&&Zr(t,e.scrollTop,e.forceScroll),null!=e.scrollLeft&&Qr(t,e.scrollLeft,!0,!0),e.scrollToPos&&Br(t,Gr(t,U(n,e.scrollToPos.from),U(n,e.scrollToPos.to),e.scrollToPos.margin));var i=e.maybeHiddenMarkers,o=e.maybeUnhiddenMarkers;if(i)for(var l=0;l<i.length;++l)i[l].lines.length||Te(i[l],"hide");if(o)for(var s=0;s<o.length;++s)o[s].lines.length&&Te(o[s],"unhide");r.wrapper.offsetHeight&&(n.scrollTop=t.display.scroller.scrollTop),e.changeObjs&&Te(t,"changes",t,e.changeObjs),e.update&&e.update.finish()}function hn(e,t){if(e.curOp)return t();nn(e);try{return t()}finally{on(e)}}function dn(e,t){return function(){if(e.curOp)return t.apply(e,arguments);nn(e);try{return t.apply(e,arguments)}finally{on(e)}}}function pn(e){return function(){if(this.curOp)return e.apply(this,arguments);nn(this);try{return e.apply(this,arguments)}finally{on(this)}}}function gn(e){return function(){var t=this.cm;if(!t||t.curOp)return e.apply(this,arguments);nn(t);try{return e.apply(this,arguments)}finally{on(t)}}}function vn(e,t,r,n){null==t&&(t=e.doc.first),null==r&&(r=e.doc.first+e.doc.size),n||(n=0);var i=e.display;if(n&&r<i.viewTo&&(null==i.updateLineNumbers||i.updateLineNumbers>t)&&(i.updateLineNumbers=t),e.curOp.viewChanged=!0,t>=i.viewTo)_l&&pe(e.doc,t)<i.viewTo&&yn(e);else if(r<=i.viewFrom)_l&&ge(e.doc,r+n)>i.viewFrom?yn(e):(i.viewFrom+=n,i.viewTo+=n);else if(t<=i.viewFrom&&r>=i.viewTo)yn(e);else if(t<=i.viewFrom){var o=bn(e,r,r+n,1);o?(i.view=i.view.slice(o.index),i.viewFrom=o.lineN,i.viewTo+=n):yn(e)}else if(r>=i.viewTo){var l=bn(e,t,t,-1);l?(i.view=i.view.slice(0,l.index),i.viewTo=l.lineN):yn(e)}else{var s=bn(e,t,t,-1),a=bn(e,r,r+n,1);s&&a?(i.view=i.view.slice(0,s.index).concat(gt(e,s.lineN,a.lineN)).concat(i.view.slice(a.index)),i.viewTo+=n):yn(e)}var u=i.externalMeasured;u&&(r<u.lineN?u.lineN+=n:t<u.lineN+u.size&&(i.externalMeasured=null))}function mn(e,t,r){e.curOp.viewChanged=!0;var n=e.display,i=e.display.externalMeasured;if(i&&t>=i.lineN&&t<i.lineN+i.size&&(n.externalMeasured=null),!(t<n.viewFrom||t>=n.viewTo)){var o=n.view[Lr(e,t)];if(null!=o.node){var l=o.changes||(o.changes=[]);-1==h(l,r)&&l.push(r)}}}function yn(e){e.display.viewFrom=e.display.viewTo=e.doc.first,e.display.view=[],e.display.viewOffset=0}function bn(e,t,r,n){var i,o=Lr(e,t),l=e.display.view;if(!_l||r==e.doc.first+e.doc.size)return{index:o,lineN:r};for(var s=e.display.viewFrom,a=0;a<o;a++)s+=l[a].size;if(s!=t){if(n>0){if(o==l.length-1)return null;i=s+l[o].size-t,o++}else i=s-t;t+=i,r+=i}for(;pe(e.doc,r)!=r;){if(o==(n<0?0:l.length-1))return null;r+=n*l[o-(n<0?1:0)].size,o+=n}return{index:o,lineN:r}}function wn(e,t,r){var n=e.display;0==n.view.length||t>=n.viewTo||r<=n.viewFrom?(n.view=gt(e,t,r),n.viewFrom=t):(n.viewFrom>t?n.view=gt(e,t,n.viewFrom).concat(n.view):n.viewFrom<t&&(n.view=n.view.slice(Lr(e,t))),n.viewFrom=t,n.viewTo<r?n.view=n.view.concat(gt(e,n.viewTo,r)):n.viewTo>r&&(n.view=n.view.slice(0,Lr(e,r)))),n.viewTo=r}function xn(e){for(var t=e.display.view,r=0,n=0;n<t.length;n++){var i=t[n];i.hidden||i.node&&!i.changes||++r}return r}function Cn(e,t){e.doc.highlightFrontier<e.display.viewTo&&e.state.highlight.set(t,u(Sn,e))}function Sn(e){var t=e.doc;if(!(t.highlightFrontier>=e.display.viewTo)){var r=+new Date+e.options.workTime,n=$e(e,t.highlightFrontier),i=[];t.iter(n.line,Math.min(t.first+t.size,e.display.viewTo+500),function(o){if(n.line>=e.display.viewFrom){var l=o.styles,s=o.text.length>e.options.maxHighlightLength?Ke(t.mode,n.state):null,a=Ye(e,o,n,!0);s&&(n.state=s),o.styles=a.styles;var u=o.styleClasses,c=a.classes;c?o.styleClasses=c:u&&(o.styleClasses=null);for(var f=!l||l.length!=o.styles.length||u!=c&&(!u||!c||u.bgClass!=c.bgClass||u.textClass!=c.textClass),h=0;!f&&h<l.length;++h)f=l[h]!=o.styles[h];f&&i.push(n.line),o.stateAfter=n.save(),n.nextLine()}else o.text.length<=e.options.maxHighlightLength&&qe(e,o.text,n),o.stateAfter=n.line%5==0?n.save():null,n.nextLine();if(+new Date>r)return Cn(e,e.options.workDelay),!0}),t.highlightFrontier=n.line,t.modeFrontier=Math.max(t.modeFrontier,n.line),i.length&&hn(e,function(){for(var t=0;t<i.length;t++)mn(e,i[t],"text")})}}function Ln(e){var t=e.display;!t.scrollbarsClipped&&t.scroller.offsetWidth&&(t.nativeBarWidth=t.scroller.offsetWidth-t.scroller.clientWidth,t.heightForcer.style.height=zt(e)+"px",t.sizer.style.marginBottom=-t.nativeBarWidth+"px",t.sizer.style.borderRightWidth=zt(e)+"px",t.scrollbarsClipped=!0)}function kn(e){if(e.hasFocus())return null;var t=l();if(!t||!o(e.display.lineDiv,t))return null;var r={activeElt:t};if(window.getSelection){var n=window.getSelection();n.anchorNode&&n.extend&&o(e.display.lineDiv,n.anchorNode)&&(r.anchorNode=n.anchorNode,r.anchorOffset=n.anchorOffset,r.focusNode=n.focusNode,r.focusOffset=n.focusOffset)}return r}function Tn(e){if(e&&e.activeElt&&e.activeElt!=l()&&(e.activeElt.focus(),e.anchorNode&&o(document.body,e.anchorNode)&&o(document.body,e.focusNode))){var t=window.getSelection(),r=document.createRange();r.setEnd(e.anchorNode,e.anchorOffset),r.collapse(!1),t.removeAllRanges(),t.addRange(r),t.extend(e.focusNode,e.focusOffset)}}function Mn(e,r){var n=e.display,i=e.doc;if(r.editorIsHidden)return yn(e),!1;if(!r.force&&r.visible.from>=n.viewFrom&&r.visible.to<=n.viewTo&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo)&&n.renderedView==n.view&&0==xn(e))return!1;Rr(e)&&(yn(e),r.dims=br(e));var o=i.first+i.size,l=Math.max(r.visible.from-e.options.viewportMargin,i.first),s=Math.min(o,r.visible.to+e.options.viewportMargin);n.viewFrom<l&&l-n.viewFrom<20&&(l=Math.max(i.first,n.viewFrom)),n.viewTo>s&&n.viewTo-s<20&&(s=Math.min(o,n.viewTo)),_l&&(l=pe(e.doc,l),s=ge(e.doc,s));var a=l!=n.viewFrom||s!=n.viewTo||n.lastWrapHeight!=r.wrapperHeight||n.lastWrapWidth!=r.wrapperWidth;wn(e,l,s),n.viewOffset=ye(M(e.doc,n.viewFrom)),e.display.mover.style.top=n.viewOffset+"px";var u=xn(e);if(!a&&0==u&&!r.force&&n.renderedView==n.view&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo))return!1;var c=kn(e);return u>4&&(n.lineDiv.style.display="none"),An(e,n.updateLineNumbers,r.dims),u>4&&(n.lineDiv.style.display=""),n.renderedView=n.view,Tn(c),t(n.cursorDiv),t(n.selectionDiv),n.gutters.style.height=n.sizer.style.minHeight=0,a&&(n.lastWrapHeight=r.wrapperHeight,n.lastWrapWidth=r.wrapperWidth,Cn(e,400)),n.updateLineNumbers=null,!0}function Nn(e,t){for(var r=t.viewport,n=!0;(n&&e.options.lineWrapping&&t.oldDisplayWidth!=Rt(e)||(r&&null!=r.top&&(r={top:Math.min(e.doc.height+Pt(e.display)-Bt(e),r.top)}),t.visible=Ir(e.display,e.doc,r),!(t.visible.from>=e.display.viewFrom&&t.visible.to<=e.display.viewTo)))&&Mn(e,t);n=!1){Er(e);var i=Jr(e);kr(e),en(e,i),Dn(e,i),t.force=!1}t.signal(e,"update",e),e.display.viewFrom==e.display.reportedViewFrom&&e.display.viewTo==e.display.reportedViewTo||(t.signal(e,"viewportChange",e,e.display.viewFrom,e.display.viewTo),e.display.reportedViewFrom=e.display.viewFrom,e.display.reportedViewTo=e.display.viewTo)}function On(e,t){var r=new Cs(e,t);if(Mn(e,r)){Er(e),Nn(e,r);var n=Jr(e);kr(e),en(e,n),Dn(e,n),r.finish()}}function An(e,r,n){function i(t){var r=t.nextSibling;return ml&&Ml&&e.display.currentWheelTarget==t?t.style.display="none":t.parentNode.removeChild(t),r}for(var o=e.display,l=e.options.lineNumbers,s=o.lineDiv,a=s.firstChild,u=o.view,c=o.viewFrom,f=0;f<u.length;f++){var d=u[f];if(d.hidden);else if(d.node&&d.node.parentNode==s){for(;a!=d.node;)a=i(a);var p=l&&null!=r&&r<=c&&d.lineNumber;d.changes&&(h(d.changes,"gutter")>-1&&(p=!1),xt(e,d,c,n)),p&&(t(d.lineNumber),d.lineNumber.appendChild(document.createTextNode(F(e.options,c)))),a=d.node.nextSibling}else{var g=Ot(e,d,c,n);s.insertBefore(g,a)}c+=d.size}for(;a;)a=i(a)}function Wn(e){var t=e.display.gutters.offsetWidth;e.display.sizer.style.marginLeft=t+"px"}function Dn(e,t){e.display.sizer.style.minHeight=t.docHeight+"px",e.display.heightForcer.style.top=t.docHeight+"px",e.display.gutters.style.height=t.docHeight+e.display.barHeight+zt(e)+"px"}function Hn(e){var r=e.display.gutters,i=e.options.gutters;t(r);for(var o=0;o<i.length;++o){var l=i[o],s=r.appendChild(n("div",null,"CodeMirror-gutter "+l));"CodeMirror-linenumbers"==l&&(e.display.lineGutter=s,s.style.width=(e.display.lineNumWidth||1)+"px")}r.style.display=o?"":"none",Wn(e)}function Fn(e){var t=h(e.gutters,"CodeMirror-linenumbers");-1==t&&e.lineNumbers?e.gutters=e.gutters.concat(["CodeMirror-linenumbers"]):t>-1&&!e.lineNumbers&&(e.gutters=e.gutters.slice(0),e.gutters.splice(t,1))}function En(e){var t=e.wheelDeltaX,r=e.wheelDeltaY;return null==t&&e.detail&&e.axis==e.HORIZONTAL_AXIS&&(t=e.detail),null==r&&e.detail&&e.axis==e.VERTICAL_AXIS?r=e.detail:null==r&&(r=e.wheelDelta),{x:t,y:r}}function Pn(e){var t=En(e);return t.x*=Ls,t.y*=Ls,t}function In(e,t){var r=En(t),n=r.x,i=r.y,o=e.display,l=o.scroller,s=l.scrollWidth>l.clientWidth,a=l.scrollHeight>l.clientHeight;if(n&&s||i&&a){if(i&&Ml&&ml)e:for(var u=t.target,c=o.view;u!=l;u=u.parentNode)for(var f=0;f<c.length;f++)if(c[f].node==u){e.display.currentWheelTarget=u;break e}if(n&&!fl&&!wl&&null!=Ls)return i&&a&&qr(e,Math.max(0,l.scrollTop+i*Ls)),Qr(e,Math.max(0,l.scrollLeft+n*Ls)),(!i||i&&a)&&We(t),void(o.wheelStartX=null);if(i&&null!=Ls){var h=i*Ls,d=e.doc.scrollTop,p=d+o.wrapper.clientHeight;h<0?d=Math.max(0,d+h-50):p=Math.min(e.doc.height,p+h+50),On(e,{top:d,bottom:p})}Ss<20&&(null==o.wheelStartX?(o.wheelStartX=l.scrollLeft,o.wheelStartY=l.scrollTop,o.wheelDX=n,o.wheelDY=i,setTimeout(function(){if(null!=o.wheelStartX){var e=l.scrollLeft-o.wheelStartX,t=l.scrollTop-o.wheelStartY,r=t&&o.wheelDY&&t/o.wheelDY||e&&o.wheelDX&&e/o.wheelDX;o.wheelStartX=o.wheelStartY=null,r&&(Ls=(Ls*Ss+r)/(Ss+1),++Ss)}},200)):(o.wheelDX+=n,o.wheelDY+=i))}}function zn(e,t){var r=e[t];e.sort(function(e,t){return P(e.from(),t.from())}),t=h(e,r);for(var n=1;n<e.length;n++){var i=e[n],o=e[n-1];if(P(o.to(),i.from())>=0){var l=B(o.from(),i.from()),s=R(o.to(),i.to()),a=o.empty()?i.from()==i.head:o.from()==o.head;n<=t&&--t,e.splice(--n,2,new Ts(a?s:l,a?l:s))}}return new ks(e,t)}function Rn(e,t){return new ks([new Ts(e,t||e)],0)}function Bn(e){return e.text?E(e.from.line+e.text.length-1,g(e.text).length+(1==e.text.length?e.from.ch:0)):e.to}function Gn(e,t){if(P(e,t.from)<0)return e;if(P(e,t.to)<=0)return Bn(t);var r=e.line+t.text.length-(t.to.line-t.from.line)-1,n=e.ch;return e.line==t.to.line&&(n+=Bn(t).ch-t.to.ch),E(r,n)}function Un(e,t){for(var r=[],n=0;n<e.sel.ranges.length;n++){var i=e.sel.ranges[n];r.push(new Ts(Gn(i.anchor,t),Gn(i.head,t)))}return zn(r,e.sel.primIndex)}function Vn(e,t,r){return e.line==t.line?E(r.line,e.ch-t.ch+r.ch):E(r.line+(e.line-t.line),e.ch)}function Kn(e,t,r){for(var n=[],i=E(e.first,0),o=i,l=0;l<t.length;l++){var s=t[l],a=Vn(s.from,i,o),u=Vn(Bn(s),i,o);if(i=s.to,o=u,"around"==r){var c=e.sel.ranges[l],f=P(c.head,c.anchor)<0;n[l]=new Ts(f?u:a,f?a:u)}else n[l]=new Ts(a,a)}return new ks(n,e.sel.primIndex)}function jn(e){e.doc.mode=Ue(e.options,e.doc.modeOption),Xn(e)}function Xn(e){e.doc.iter(function(e){e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null)}),e.doc.modeFrontier=e.doc.highlightFrontier=e.doc.first,Cn(e,100),e.state.modeGen++,e.curOp&&vn(e)}function Yn(e,t){return 0==t.from.ch&&0==t.to.ch&&""==g(t.text)&&(!e.cm||e.cm.options.wholeLineUpdateBefore)}function _n(e,t,r,n){function i(e){return r?r[e]:null}function o(e,r,i){it(e,r,i,n),bt(e,"change",e,t)}function l(e,t){for(var r=[],o=e;o<t;++o)r.push(new fs(u[o],i(o),n));return r}var s=t.from,a=t.to,u=t.text,c=M(e,s.line),f=M(e,a.line),h=g(u),d=i(u.length-1),p=a.line-s.line;if(t.full)e.insert(0,l(0,u.length)),e.remove(u.length,e.size-u.length);else if(Yn(e,t)){var v=l(0,u.length-1);o(f,f.text,d),p&&e.remove(s.line,p),v.length&&e.insert(s.line,v)}else if(c==f)if(1==u.length)o(c,c.text.slice(0,s.ch)+h+c.text.slice(a.ch),d);else{var m=l(1,u.length-1);m.push(new fs(h+c.text.slice(a.ch),d,n)),o(c,c.text.slice(0,s.ch)+u[0],i(0)),e.insert(s.line+1,m)}else if(1==u.length)o(c,c.text.slice(0,s.ch)+u[0]+f.text.slice(a.ch),i(0)),e.remove(s.line+1,p);else{o(c,c.text.slice(0,s.ch)+u[0],i(0)),o(f,h+f.text.slice(a.ch),d);var y=l(1,u.length-1);p>1&&e.remove(s.line+1,p-1),e.insert(s.line+1,y)}bt(e,"change",e,t)}function $n(e,t,r){function n(e,i,o){if(e.linked)for(var l=0;l<e.linked.length;++l){var s=e.linked[l];if(s.doc!=i){var a=o&&s.sharedHist;r&&!a||(t(s.doc,a),n(s.doc,e,a))}}}n(e,null,!0)}function qn(e,t){if(t.cm)throw new Error("This document is already in use.");e.doc=t,t.cm=e,Cr(e),jn(e),Zn(e),e.options.lineWrapping||we(e),e.options.mode=t.modeOption,vn(e)}function Zn(e){("rtl"==e.doc.direction?s:Fl)(e.display.lineDiv,"CodeMirror-rtl")}function Qn(e){hn(e,function(){Zn(e),vn(e)})}function Jn(e){this.done=[],this.undone=[],this.undoDepth=1/0,this.lastModTime=this.lastSelTime=0,this.lastOp=this.lastSelOp=null,this.lastOrigin=this.lastSelOrigin=null,this.generation=this.maxGeneration=e||1}function ei(e,t){var r={from:z(t.from),to:Bn(t),text:N(e,t.from,t.to)};return si(e,r,t.from.line,t.to.line+1),$n(e,function(e){return si(e,r,t.from.line,t.to.line+1)},!0),r}function ti(e){for(;e.length&&g(e).ranges;)e.pop()}function ri(e,t){return t?(ti(e.done),g(e.done)):e.done.length&&!g(e.done).ranges?g(e.done):e.done.length>1&&!e.done[e.done.length-2].ranges?(e.done.pop(),g(e.done)):void 0}function ni(e,t,r,n){var i=e.history;i.undone.length=0;var o,l,s=+new Date;if((i.lastOp==n||i.lastOrigin==t.origin&&t.origin&&("+"==t.origin.charAt(0)&&e.cm&&i.lastModTime>s-e.cm.options.historyEventDelay||"*"==t.origin.charAt(0)))&&(o=ri(i,i.lastOp==n)))l=g(o.changes),0==P(t.from,t.to)&&0==P(t.from,l.to)?l.to=Bn(t):o.changes.push(ei(e,t));else{var a=g(i.done);for(a&&a.ranges||li(e.sel,i.done),o={changes:[ei(e,t)],generation:i.generation},i.done.push(o);i.done.length>i.undoDepth;)i.done.shift(),i.done[0].ranges||i.done.shift()}i.done.push(r),i.generation=++i.maxGeneration,i.lastModTime=i.lastSelTime=s,i.lastOp=i.lastSelOp=n,i.lastOrigin=i.lastSelOrigin=t.origin,l||Te(e,"historyAdded")}function ii(e,t,r,n){var i=t.charAt(0);return"*"==i||"+"==i&&r.ranges.length==n.ranges.length&&r.somethingSelected()==n.somethingSelected()&&new Date-e.history.lastSelTime<=(e.cm?e.cm.options.historyEventDelay:500)}function oi(e,t,r,n){var i=e.history,o=n&&n.origin;r==i.lastSelOp||o&&i.lastSelOrigin==o&&(i.lastModTime==i.lastSelTime&&i.lastOrigin==o||ii(e,o,g(i.done),t))?i.done[i.done.length-1]=t:li(t,i.done),i.lastSelTime=+new Date,i.lastSelOrigin=o,i.lastSelOp=r,n&&!1!==n.clearRedo&&ti(i.undone)}function li(e,t){var r=g(t);r&&r.ranges&&r.equals(e)||t.push(e)}function si(e,t,r,n){var i=t["spans_"+e.id],o=0;e.iter(Math.max(e.first,r),Math.min(e.first+e.size,n),function(r){r.markedSpans&&((i||(i=t["spans_"+e.id]={}))[o]=r.markedSpans),++o})}function ai(e){if(!e)return null;for(var t,r=0;r<e.length;++r)e[r].marker.explicitlyCleared?t||(t=e.slice(0,r)):t&&t.push(e[r]);return t?t.length?t:null:e}function ui(e,t){var r=t["spans_"+e.id];if(!r)return null;for(var n=[],i=0;i<t.text.length;++i)n.push(ai(r[i]));return n}function ci(e,t){var r=ui(e,t),n=J(e,t);if(!r)return n;if(!n)return r;for(var i=0;i<r.length;++i){var o=r[i],l=n[i];if(o&&l)e:for(var s=0;s<l.length;++s){for(var a=l[s],u=0;u<o.length;++u)if(o[u].marker==a.marker)continue e;o.push(a)}else l&&(r[i]=l)}return r}function fi(e,t,r){for(var n=[],i=0;i<e.length;++i){var o=e[i];if(o.ranges)n.push(r?ks.prototype.deepCopy.call(o):o);else{var l=o.changes,s=[];n.push({changes:s});for(var a=0;a<l.length;++a){var u=l[a],c=void 0;if(s.push({from:u.from,to:u.to,text:u.text}),t)for(var f in u)(c=f.match(/^spans_(\d+)$/))&&h(t,Number(c[1]))>-1&&(g(s)[f]=u[f],delete u[f])}}}return n}function hi(e,t,r,n){if(n){var i=e.anchor;if(r){var o=P(t,i)<0;o!=P(r,i)<0?(i=t,t=r):o!=P(t,r)<0&&(t=r)}return new Ts(i,t)}return new Ts(r||t,t)}function di(e,t,r,n,i){null==i&&(i=e.cm&&(e.cm.display.shift||e.extend)),bi(e,new ks([hi(e.sel.primary(),t,r,i)],0),n)}function pi(e,t,r){for(var n=[],i=e.cm&&(e.cm.display.shift||e.extend),o=0;o<e.sel.ranges.length;o++)n[o]=hi(e.sel.ranges[o],t[o],null,i);bi(e,zn(n,e.sel.primIndex),r)}function gi(e,t,r,n){var i=e.sel.ranges.slice(0);i[t]=r,bi(e,zn(i,e.sel.primIndex),n)}function vi(e,t,r,n){bi(e,Rn(t,r),n)}function mi(e,t,r){var n={ranges:t.ranges,update:function(t){var r=this;this.ranges=[];for(var n=0;n<t.length;n++)r.ranges[n]=new Ts(U(e,t[n].anchor),U(e,t[n].head))},origin:r&&r.origin};return Te(e,"beforeSelectionChange",e,n),e.cm&&Te(e.cm,"beforeSelectionChange",e.cm,n),n.ranges!=t.ranges?zn(n.ranges,n.ranges.length-1):t}function yi(e,t,r){var n=e.history.done,i=g(n);i&&i.ranges?(n[n.length-1]=t,wi(e,t,r)):bi(e,t,r)}function bi(e,t,r){wi(e,t,r),oi(e,e.sel,e.cm?e.cm.curOp.id:NaN,r)}function wi(e,t,r){(Oe(e,"beforeSelectionChange")||e.cm&&Oe(e.cm,"beforeSelectionChange"))&&(t=mi(e,t,r)),xi(e,Si(e,t,r&&r.bias||(P(t.primary().head,e.sel.primary().head)<0?-1:1),!0)),r&&!1===r.scroll||!e.cm||jr(e.cm)}function xi(e,t){t.equals(e.sel)||(e.sel=t,e.cm&&(e.cm.curOp.updateInput=e.cm.curOp.selectionChanged=!0,Ne(e.cm)),bt(e,"cursorActivity",e))}function Ci(e){xi(e,Si(e,e.sel,null,!1))}function Si(e,t,r,n){for(var i,o=0;o<t.ranges.length;o++){var l=t.ranges[o],s=t.ranges.length==e.sel.ranges.length&&e.sel.ranges[o],a=ki(e,l.anchor,s&&s.anchor,r,n),u=ki(e,l.head,s&&s.head,r,n);(i||a!=l.anchor||u!=l.head)&&(i||(i=t.ranges.slice(0,o)),i[o]=new Ts(a,u))}return i?zn(i,t.primIndex):t}function Li(e,t,r,n,i){var o=M(e,t.line);if(o.markedSpans)for(var l=0;l<o.markedSpans.length;++l){var s=o.markedSpans[l],a=s.marker;if((null==s.from||(a.inclusiveLeft?s.from<=t.ch:s.from<t.ch))&&(null==s.to||(a.inclusiveRight?s.to>=t.ch:s.to>t.ch))){if(i&&(Te(a,"beforeCursorEnter"),a.explicitlyCleared)){if(o.markedSpans){--l;continue}break}if(!a.atomic)continue;if(r){var u=a.find(n<0?1:-1),c=void 0;if((n<0?a.inclusiveRight:a.inclusiveLeft)&&(u=Ti(e,u,-n,u&&u.line==t.line?o:null)),u&&u.line==t.line&&(c=P(u,r))&&(n<0?c<0:c>0))return Li(e,u,t,n,i)}var f=a.find(n<0?-1:1);return(n<0?a.inclusiveLeft:a.inclusiveRight)&&(f=Ti(e,f,n,f.line==t.line?o:null)),f?Li(e,f,t,n,i):null}}return t}function ki(e,t,r,n,i){var o=n||1,l=Li(e,t,r,o,i)||!i&&Li(e,t,r,o,!0)||Li(e,t,r,-o,i)||!i&&Li(e,t,r,-o,!0);return l||(e.cantEdit=!0,E(e.first,0))}function Ti(e,t,r,n){return r<0&&0==t.ch?t.line>e.first?U(e,E(t.line-1)):null:r>0&&t.ch==(n||M(e,t.line)).text.length?t.line<e.first+e.size-1?E(t.line+1,0):null:new E(t.line,t.ch+r)}function Mi(e){e.setSelection(E(e.firstLine(),0),E(e.lastLine()),Gl)}function Ni(e,t,r){var n={canceled:!1,from:t.from,to:t.to,text:t.text,origin:t.origin,cancel:function(){return n.canceled=!0}};return r&&(n.update=function(t,r,i,o){t&&(n.from=U(e,t)),r&&(n.to=U(e,r)),i&&(n.text=i),void 0!==o&&(n.origin=o)}),Te(e,"beforeChange",e,n),e.cm&&Te(e.cm,"beforeChange",e.cm,n),n.canceled?null:{from:n.from,to:n.to,text:n.text,origin:n.origin}}function Oi(e,t,r){if(e.cm){if(!e.cm.curOp)return dn(e.cm,Oi)(e,t,r);if(e.cm.state.suppressEdits)return}if(!(Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"))||(t=Ni(e,t,!0))){var n=Yl&&!r&&te(e,t.from,t.to);if(n)for(var i=n.length-1;i>=0;--i)Ai(e,{from:n[i].from,to:n[i].to,text:i?[""]:t.text,origin:t.origin});else Ai(e,t)}}function Ai(e,t){if(1!=t.text.length||""!=t.text[0]||0!=P(t.from,t.to)){var r=Un(e,t);ni(e,t,r,e.cm?e.cm.curOp.id:NaN),Hi(e,t,r,J(e,t));var n=[];$n(e,function(e,r){r||-1!=h(n,e.history)||(zi(e.history,t),n.push(e.history)),Hi(e,t,null,J(e,t))})}}function Wi(e,t,r){if(!e.cm||!e.cm.state.suppressEdits||r){for(var n,i=e.history,o=e.sel,l="undo"==t?i.done:i.undone,s="undo"==t?i.undone:i.done,a=0;a<l.length&&(n=l[a],r?!n.ranges||n.equals(e.sel):n.ranges);a++);if(a!=l.length){for(i.lastOrigin=i.lastSelOrigin=null;(n=l.pop()).ranges;){if(li(n,s),r&&!n.equals(e.sel))return void bi(e,n,{clearRedo:!1});o=n}var u=[];li(o,s),s.push({changes:u,generation:i.generation}),i.generation=n.generation||++i.maxGeneration;for(var c=Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"),f=n.changes.length-1;f>=0;--f){var d=function(r){var i=n.changes[r];if(i.origin=t,c&&!Ni(e,i,!1))return l.length=0,{};u.push(ei(e,i));var o=r?Un(e,i):g(l);Hi(e,i,o,ci(e,i)),!r&&e.cm&&e.cm.scrollIntoView({from:i.from,to:Bn(i)});var s=[];$n(e,function(e,t){t||-1!=h(s,e.history)||(zi(e.history,i),s.push(e.history)),Hi(e,i,null,ci(e,i))})}(f);if(d)return d.v}}}}function Di(e,t){if(0!=t&&(e.first+=t,e.sel=new ks(v(e.sel.ranges,function(e){return new Ts(E(e.anchor.line+t,e.anchor.ch),E(e.head.line+t,e.head.ch))}),e.sel.primIndex),e.cm)){vn(e.cm,e.first,e.first-t,t);for(var r=e.cm.display,n=r.viewFrom;n<r.viewTo;n++)mn(e.cm,n,"gutter")}}function Hi(e,t,r,n){if(e.cm&&!e.cm.curOp)return dn(e.cm,Hi)(e,t,r,n);if(t.to.line<e.first)Di(e,t.text.length-1-(t.to.line-t.from.line));else if(!(t.from.line>e.lastLine())){if(t.from.line<e.first){var i=t.text.length-1-(e.first-t.from.line);Di(e,i),t={from:E(e.first,0),to:E(t.to.line+i,t.to.ch),text:[g(t.text)],origin:t.origin}}var o=e.lastLine();t.to.line>o&&(t={from:t.from,to:E(o,M(e,o).text.length),text:[t.text[0]],origin:t.origin}),t.removed=N(e,t.from,t.to),r||(r=Un(e,t)),e.cm?Fi(e.cm,t,n):_n(e,t,n),wi(e,r,Gl)}}function Fi(e,t,r){var n=e.doc,i=e.display,o=t.from,l=t.to,s=!1,a=o.line;e.options.lineWrapping||(a=W(fe(M(n,o.line))),n.iter(a,l.line+1,function(e){if(e==i.maxLine)return s=!0,!0})),n.sel.contains(t.from,t.to)>-1&&Ne(e),_n(n,t,r,xr(e)),e.options.lineWrapping||(n.iter(a,o.line+t.text.length,function(e){var t=be(e);t>i.maxLineLength&&(i.maxLine=e,i.maxLineLength=t,i.maxLineChanged=!0,s=!1)}),s&&(e.curOp.updateMaxLine=!0)),nt(n,o.line),Cn(e,400);var u=t.text.length-(l.line-o.line)-1;t.full?vn(e):o.line!=l.line||1!=t.text.length||Yn(e.doc,t)?vn(e,o.line,l.line+1,u):mn(e,o.line,"text");var c=Oe(e,"changes"),f=Oe(e,"change");if(f||c){var h={from:o,to:l,text:t.text,removed:t.removed,origin:t.origin};f&&bt(e,"change",e,h),c&&(e.curOp.changeObjs||(e.curOp.changeObjs=[])).push(h)}e.display.selForContextMenu=null}function Ei(e,t,r,n,i){if(n||(n=r),P(n,r)<0){var o;r=(o=[n,r])[0],n=o[1]}"string"==typeof t&&(t=e.splitLines(t)),Oi(e,{from:r,to:n,text:t,origin:i})}function Pi(e,t,r,n){r<e.line?e.line+=n:t<e.line&&(e.line=t,e.ch=0)}function Ii(e,t,r,n){for(var i=0;i<e.length;++i){var o=e[i],l=!0;if(o.ranges){o.copied||((o=e[i]=o.deepCopy()).copied=!0);for(var s=0;s<o.ranges.length;s++)Pi(o.ranges[s].anchor,t,r,n),Pi(o.ranges[s].head,t,r,n)}else{for(var a=0;a<o.changes.length;++a){var u=o.changes[a];if(r<u.from.line)u.from=E(u.from.line+n,u.from.ch),u.to=E(u.to.line+n,u.to.ch);else if(t<=u.to.line){l=!1;break}}l||(e.splice(0,i+1),i=0)}}}function zi(e,t){var r=t.from.line,n=t.to.line,i=t.text.length-(n-r)-1;Ii(e.done,r,n,i),Ii(e.undone,r,n,i)}function Ri(e,t,r,n){var i=t,o=t;return"number"==typeof t?o=M(e,G(e,t)):i=W(t),null==i?null:(n(o,i)&&e.cm&&mn(e.cm,i,r),o)}function Bi(e){var t=this;this.lines=e,this.parent=null;for(var r=0,n=0;n<e.length;++n)e[n].parent=t,r+=e[n].height;this.height=r}function Gi(e){var t=this;this.children=e;for(var r=0,n=0,i=0;i<e.length;++i){var o=e[i];r+=o.chunkSize(),n+=o.height,o.parent=t}this.size=r,this.height=n,this.parent=null}function Ui(e,t,r){ye(t)<(e.curOp&&e.curOp.scrollTop||e.doc.scrollTop)&&Kr(e,r)}function Vi(e,t,r,n){var i=new Ms(e,r,n),o=e.cm;return o&&i.noHScroll&&(o.display.alignWidgets=!0),Ri(e,t,"widget",function(t){var r=t.widgets||(t.widgets=[]);if(null==i.insertAt?r.push(i):r.splice(Math.min(r.length-1,Math.max(0,i.insertAt)),0,i),i.line=t,o&&!ve(e,t)){var n=ye(t)<e.scrollTop;A(t,t.height+Ht(i)),n&&Kr(o,i.height),o.curOp.forceUpdate=!0}return!0}),bt(o,"lineWidgetAdded",o,i,"number"==typeof t?t:W(t)),i}function Ki(e,t,r,n,o){if(n&&n.shared)return ji(e,t,r,n,o);if(e.cm&&!e.cm.curOp)return dn(e.cm,Ki)(e,t,r,n,o);var l=new Os(e,o),s=P(t,r);if(n&&c(n,l,!1),s>0||0==s&&!1!==l.clearWhenEmpty)return l;if(l.replacedWith&&(l.collapsed=!0,l.widgetNode=i("span",[l.replacedWith],"CodeMirror-widget"),n.handleMouseEvents||l.widgetNode.setAttribute("cm-ignore-events","true"),n.insertLeft&&(l.widgetNode.insertLeft=!0)),l.collapsed){if(ce(e,t.line,t,r,l)||t.line!=r.line&&ce(e,r.line,t,r,l))throw new Error("Inserting collapsed marker partially overlapping an existing one");X()}l.addToHistory&&ni(e,{from:t,to:r,origin:"markText"},e.sel,NaN);var a,u=t.line,f=e.cm;if(e.iter(u,r.line+1,function(e){f&&l.collapsed&&!f.options.lineWrapping&&fe(e)==f.display.maxLine&&(a=!0),l.collapsed&&u!=t.line&&A(e,0),q(e,new Y(l,u==t.line?t.ch:null,u==r.line?r.ch:null)),++u}),l.collapsed&&e.iter(t.line,r.line+1,function(t){ve(e,t)&&A(t,0)}),l.clearOnEnter&&Ql(l,"beforeCursorEnter",function(){return l.clear()}),l.readOnly&&(j(),(e.history.done.length||e.history.undone.length)&&e.clearHistory()),l.collapsed&&(l.id=++Ns,l.atomic=!0),f){if(a&&(f.curOp.updateMaxLine=!0),l.collapsed)vn(f,t.line,r.line+1);else if(l.className||l.title||l.startStyle||l.endStyle||l.css)for(var h=t.line;h<=r.line;h++)mn(f,h,"text");l.atomic&&Ci(f.doc),bt(f,"markerAdded",f,l)}return l}function ji(e,t,r,n,i){(n=c(n)).shared=!1;var o=[Ki(e,t,r,n,i)],l=o[0],s=n.widgetNode;return $n(e,function(e){s&&(n.widgetNode=s.cloneNode(!0)),o.push(Ki(e,U(e,t),U(e,r),n,i));for(var a=0;a<e.linked.length;++a)if(e.linked[a].isParent)return;l=g(o)}),new As(o,l)}function Xi(e){return e.findMarks(E(e.first,0),e.clipPos(E(e.lastLine())),function(e){return e.parent})}function Yi(e,t){for(var r=0;r<t.length;r++){var n=t[r],i=n.find(),o=e.clipPos(i.from),l=e.clipPos(i.to);if(P(o,l)){var s=Ki(e,o,l,n.primary,n.primary.type);n.markers.push(s),s.parent=n}}}function _i(e){for(var t=0;t<e.length;t++)!function(t){var r=e[t],n=[r.primary.doc];$n(r.primary.doc,function(e){return n.push(e)});for(var i=0;i<r.markers.length;i++){var o=r.markers[i];-1==h(n,o.doc)&&(o.parent=null,r.markers.splice(i--,1))}}(t)}function $i(e){var t=this;if(Qi(t),!Me(t,e)&&!Ft(t.display,e)){We(e),gl&&(Hs=+new Date);var r=Sr(t,e,!0),n=e.dataTransfer.files;if(r&&!t.isReadOnly())if(n&&n.length&&window.FileReader&&window.File)for(var i=n.length,o=Array(i),l=0,s=0;s<i;++s)!function(e,n){if(!t.options.allowDropFileTypes||-1!=h(t.options.allowDropFileTypes,e.type)){var s=new FileReader;s.onload=dn(t,function(){var e=s.result;if(/[\x00-\x08\x0e-\x1f]{2}/.test(e)&&(e=""),o[n]=e,++l==i){var a={from:r=U(t.doc,r),to:r,text:t.doc.splitLines(o.join(t.doc.lineSeparator())),origin:"paste"};Oi(t.doc,a),yi(t.doc,Rn(r,Bn(a)))}}),s.readAsText(e)}}(n[s],s);else{if(t.state.draggingText&&t.doc.sel.contains(r)>-1)return t.state.draggingText(e),void setTimeout(function(){return t.display.input.focus()},20);try{var a=e.dataTransfer.getData("Text");if(a){var u;if(t.state.draggingText&&!t.state.draggingText.copy&&(u=t.listSelections()),wi(t.doc,Rn(r,r)),u)for(var c=0;c<u.length;++c)Ei(t.doc,"",u[c].anchor,u[c].head,"drag");t.replaceSelection(a,"around","paste"),t.display.input.focus()}}catch(e){}}}}function qi(e,t){if(gl&&(!e.state.draggingText||+new Date-Hs<100))Fe(t);else if(!Me(e,t)&&!Ft(e.display,t)&&(t.dataTransfer.setData("Text",e.getSelection()),t.dataTransfer.effectAllowed="copyMove",t.dataTransfer.setDragImage&&!xl)){var r=n("img",null,null,"position: fixed; left: 0; top: 0;");r.src="data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==",wl&&(r.width=r.height=1,e.display.wrapper.appendChild(r),r._top=r.offsetTop),t.dataTransfer.setDragImage(r,0,0),wl&&r.parentNode.removeChild(r)}}function Zi(e,t){var i=Sr(e,t);if(i){var o=document.createDocumentFragment();Mr(e,i,o),e.display.dragCursor||(e.display.dragCursor=n("div",null,"CodeMirror-cursors CodeMirror-dragcursors"),e.display.lineSpace.insertBefore(e.display.dragCursor,e.display.cursorDiv)),r(e.display.dragCursor,o)}}function Qi(e){e.display.dragCursor&&(e.display.lineSpace.removeChild(e.display.dragCursor),e.display.dragCursor=null)}function Ji(e){if(document.getElementsByClassName)for(var t=document.getElementsByClassName("CodeMirror"),r=0;r<t.length;r++){var n=t[r].CodeMirror;n&&e(n)}}function eo(){Fs||(to(),Fs=!0)}function to(){var e;Ql(window,"resize",function(){null==e&&(e=setTimeout(function(){e=null,Ji(ro)},100))}),Ql(window,"blur",function(){return Ji(Fr)})}function ro(e){var t=e.display;t.lastWrapHeight==t.wrapper.clientHeight&&t.lastWrapWidth==t.wrapper.clientWidth||(t.cachedCharWidth=t.cachedTextHeight=t.cachedPaddingH=null,t.scrollbarsClipped=!1,e.setSize())}function no(e){var t=e.split(/-(?!$)/);e=t[t.length-1];for(var r,n,i,o,l=0;l<t.length-1;l++){var s=t[l];if(/^(cmd|meta|m)$/i.test(s))o=!0;else if(/^a(lt)?$/i.test(s))r=!0;else if(/^(c|ctrl|control)$/i.test(s))n=!0;else{if(!/^s(hift)?$/i.test(s))throw new Error("Unrecognized modifier name: "+s);i=!0}}return r&&(e="Alt-"+e),n&&(e="Ctrl-"+e),o&&(e="Cmd-"+e),i&&(e="Shift-"+e),e}function io(e){var t={};for(var r in e)if(e.hasOwnProperty(r)){var n=e[r];if(/^(name|fallthrough|(de|at)tach)$/.test(r))continue;if("..."==n){delete e[r];continue}for(var i=v(r.split(" "),no),o=0;o<i.length;o++){var l=void 0,s=void 0;o==i.length-1?(s=i.join(" "),l=n):(s=i.slice(0,o+1).join(" "),l="...");var a=t[s];if(a){if(a!=l)throw new Error("Inconsistent bindings for "+s)}else t[s]=l}delete e[r]}for(var u in t)e[u]=t[u];return e}function oo(e,t,r,n){var i=(t=uo(t)).call?t.call(e,n):t[e];if(!1===i)return"nothing";if("..."===i)return"multi";if(null!=i&&r(i))return"handled";if(t.fallthrough){if("[object Array]"!=Object.prototype.toString.call(t.fallthrough))return oo(e,t.fallthrough,r,n);for(var o=0;o<t.fallthrough.length;o++){var l=oo(e,t.fallthrough[o],r,n);if(l)return l}}}function lo(e){var t="string"==typeof e?e:Es[e.keyCode];return"Ctrl"==t||"Alt"==t||"Shift"==t||"Mod"==t}function so(e,t,r){var n=e;return t.altKey&&"Alt"!=n&&(e="Alt-"+e),(Dl?t.metaKey:t.ctrlKey)&&"Ctrl"!=n&&(e="Ctrl-"+e),(Dl?t.ctrlKey:t.metaKey)&&"Cmd"!=n&&(e="Cmd-"+e),!r&&t.shiftKey&&"Shift"!=n&&(e="Shift-"+e),e}function ao(e,t){if(wl&&34==e.keyCode&&e.char)return!1;var r=Es[e.keyCode];return null!=r&&!e.altGraphKey&&so(r,e,t)}function uo(e){return"string"==typeof e?Rs[e]:e}function co(e,t){for(var r=e.doc.sel.ranges,n=[],i=0;i<r.length;i++){for(var o=t(r[i]);n.length&&P(o.from,g(n).to)<=0;){var l=n.pop();if(P(l.from,o.from)<0){o.from=l.from;break}}n.push(o)}hn(e,function(){for(var t=n.length-1;t>=0;t--)Ei(e.doc,"",n[t].from,n[t].to,"+delete");jr(e)})}function fo(e,t,r){var n=L(e.text,t+r,r);return n<0||n>e.text.length?null:n}function ho(e,t,r){var n=fo(e,t.ch,r);return null==n?null:new E(t.line,n,r<0?"after":"before")}function po(e,t,r,n,i){if(e){var o=Se(r,t.doc.direction);if(o){var l,s=i<0?g(o):o[0],a=i<0==(1==s.level)?"after":"before";if(s.level>0){var u=Xt(t,r);l=i<0?r.text.length-1:0;var c=Yt(t,u,l).top;l=k(function(e){return Yt(t,u,e).top==c},i<0==(1==s.level)?s.from:s.to-1,l),"before"==a&&(l=fo(r,l,1))}else l=i<0?s.to:s.from;return new E(n,l,a)}}return new E(n,i<0?r.text.length:0,i<0?"before":"after")}function go(e,t,r,n){var i=Se(t,e.doc.direction);if(!i)return ho(t,r,n);r.ch>=t.text.length?(r.ch=t.text.length,r.sticky="before"):r.ch<=0&&(r.ch=0,r.sticky="after");var o=Ce(i,r.ch,r.sticky),l=i[o];if("ltr"==e.doc.direction&&l.level%2==0&&(n>0?l.to>r.ch:l.from<r.ch))return ho(t,r,n);var s,a=function(e,r){return fo(t,e instanceof E?e.ch:e,r)},u=function(r){return e.options.lineWrapping?(s=s||Xt(e,t),hr(e,t,s,r)):{begin:0,end:t.text.length}},c=u("before"==r.sticky?a(r,-1):r.ch);if("rtl"==e.doc.direction||1==l.level){var f=1==l.level==n<0,h=a(r,f?1:-1);if(null!=h&&(f?h<=l.to&&h<=c.end:h>=l.from&&h>=c.begin)){var d=f?"before":"after";return new E(r.line,h,d)}}var p=function(e,t,n){for(var o=function(e,t){return t?new E(r.line,a(e,1),"before"):new E(r.line,e,"after")};e>=0&&e<i.length;e+=t){var l=i[e],s=t>0==(1!=l.level),u=s?n.begin:a(n.end,-1);if(l.from<=u&&u<l.to)return o(u,s);if(u=s?l.from:a(l.to,-1),n.begin<=u&&u<n.end)return o(u,s)}},g=p(o+n,n,c);if(g)return g;var v=n>0?c.end:a(c.begin,-1);return null==v||n>0&&v==t.text.length||!(g=p(n>0?0:i.length-1,n,u(v)))?null:g}function vo(e,t){var r=M(e.doc,t),n=fe(r);return n!=r&&(t=W(n)),po(!0,e,n,t,1)}function mo(e,t){var r=M(e.doc,t),n=he(r);return n!=r&&(t=W(n)),po(!0,e,r,t,-1)}function yo(e,t){var r=vo(e,t.line),n=M(e.doc,r.line),i=Se(n,e.doc.direction);if(!i||0==i[0].level){var o=Math.max(0,n.text.search(/\S/)),l=t.line==r.line&&t.ch<=o&&t.ch;return E(r.line,l?0:o,r.sticky)}return r}function bo(e,t,r){if("string"==typeof t&&!(t=Bs[t]))return!1;e.display.input.ensurePolled();var n=e.display.shift,i=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),r&&(e.display.shift=!1),i=t(e)!=Bl}finally{e.display.shift=n,e.state.suppressEdits=!1}return i}function wo(e,t,r){for(var n=0;n<e.state.keyMaps.length;n++){var i=oo(t,e.state.keyMaps[n],r,e);if(i)return i}return e.options.extraKeys&&oo(t,e.options.extraKeys,r,e)||oo(t,e.options.keyMap,r,e)}function xo(e,t,r,n){var i=e.state.keySeq;if(i){if(lo(t))return"handled";Gs.set(50,function(){e.state.keySeq==i&&(e.state.keySeq=null,e.display.input.reset())}),t=i+" "+t}var o=wo(e,t,n);return"multi"==o&&(e.state.keySeq=t),"handled"==o&&bt(e,"keyHandled",e,t,r),"handled"!=o&&"multi"!=o||(We(r),Ar(e)),i&&!o&&/\'$/.test(t)?(We(r),!0):!!o}function Co(e,t){var r=ao(t,!0);return!!r&&(t.shiftKey&&!e.state.keySeq?xo(e,"Shift-"+r,t,function(t){return bo(e,t,!0)})||xo(e,r,t,function(t){if("string"==typeof t?/^go[A-Z]/.test(t):t.motion)return bo(e,t)}):xo(e,r,t,function(t){return bo(e,t)}))}function So(e,t,r){return xo(e,"'"+r+"'",t,function(t){return bo(e,t,!0)})}function Lo(e){var t=this;if(t.curOp.focus=l(),!Me(t,e)){gl&&vl<11&&27==e.keyCode&&(e.returnValue=!1);var r=e.keyCode;t.display.shift=16==r||e.shiftKey;var n=Co(t,e);wl&&(Us=n?r:null,!n&&88==r&&!rs&&(Ml?e.metaKey:e.ctrlKey)&&t.replaceSelection("",null,"cut")),18!=r||/\bCodeMirror-crosshair\b/.test(t.display.lineDiv.className)||ko(t)}}function ko(e){function t(e){18!=e.keyCode&&e.altKey||(Fl(r,"CodeMirror-crosshair"),ke(document,"keyup",t),ke(document,"mouseover",t))}var r=e.display.lineDiv;s(r,"CodeMirror-crosshair"),Ql(document,"keyup",t),Ql(document,"mouseover",t)}function To(e){16==e.keyCode&&(this.doc.sel.shift=!1),Me(this,e)}function Mo(e){var t=this;if(!(Ft(t.display,e)||Me(t,e)||e.ctrlKey&&!e.altKey||Ml&&e.metaKey)){var r=e.keyCode,n=e.charCode;if(wl&&r==Us)return Us=null,void We(e);if(!wl||e.which&&!(e.which<10)||!Co(t,e)){var i=String.fromCharCode(null==n?r:n);"\b"!=i&&(So(t,e,i)||t.display.input.onKeyPress(e))}}}function No(e,t){var r=+new Date;return js&&js.compare(r,e,t)?(Ks=js=null,"triple"):Ks&&Ks.compare(r,e,t)?(js=new Vs(r,e,t),Ks=null,"double"):(Ks=new Vs(r,e,t),js=null,"single")}function Oo(e){var t=this,r=t.display;if(!(Me(t,e)||r.activeTouch&&r.input.supportsTouch()))if(r.input.ensurePolled(),r.shift=e.shiftKey,Ft(r,e))ml||(r.scroller.draggable=!1,setTimeout(function(){return r.scroller.draggable=!0},100));else if(!zo(t,e)){var n=Sr(t,e),i=Pe(e),o=n?No(n,i):"single";window.focus(),1==i&&t.state.selectingText&&t.state.selectingText(e),n&&Ao(t,i,n,o,e)||(1==i?n?Do(t,n,o,e):Ee(e)==r.scroller&&We(e):2==i?(n&&di(t.doc,n),setTimeout(function(){return r.input.focus()},20)):3==i&&(Hl?Ro(t,e):Dr(t)))}}function Ao(e,t,r,n,i){var o="Click";return"double"==n?o="Double"+o:"triple"==n&&(o="Triple"+o),o=(1==t?"Left":2==t?"Middle":"Right")+o,xo(e,so(o,i),i,function(t){if("string"==typeof t&&(t=Bs[t]),!t)return!1;var n=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),n=t(e,r)!=Bl}finally{e.state.suppressEdits=!1}return n})}function Wo(e,t,r){var n=e.getOption("configureMouse"),i=n?n(e,t,r):{};if(null==i.unit){var o=Nl?r.shiftKey&&r.metaKey:r.altKey;i.unit=o?"rectangle":"single"==t?"char":"double"==t?"word":"line"}return(null==i.extend||e.doc.extend)&&(i.extend=e.doc.extend||r.shiftKey),null==i.addNew&&(i.addNew=Ml?r.metaKey:r.ctrlKey),null==i.moveOnDrag&&(i.moveOnDrag=!(Ml?r.altKey:r.ctrlKey)),i}function Do(e,t,r,n){gl?setTimeout(u(Wr,e),0):e.curOp.focus=l();var i,o=Wo(e,r,n),s=e.doc.sel;e.options.dragDrop&&Jl&&!e.isReadOnly()&&"single"==r&&(i=s.contains(t))>-1&&(P((i=s.ranges[i]).from(),t)<0||t.xRel>0)&&(P(i.to(),t)>0||t.xRel<0)?Ho(e,n,t,o):Eo(e,n,t,o)}function Ho(e,t,r,n){var i=e.display,o=!1,l=dn(e,function(t){ml&&(i.scroller.draggable=!1),e.state.draggingText=!1,ke(document,"mouseup",l),ke(document,"mousemove",s),ke(i.scroller,"dragstart",a),ke(i.scroller,"drop",l),o||(We(t),n.addNew||di(e.doc,r,null,null,n.extend),ml||gl&&9==vl?setTimeout(function(){document.body.focus(),i.input.focus()},20):i.input.focus())}),s=function(e){o=o||Math.abs(t.clientX-e.clientX)+Math.abs(t.clientY-e.clientY)>=10},a=function(){return o=!0};ml&&(i.scroller.draggable=!0),e.state.draggingText=l,l.copy=!n.moveOnDrag,i.scroller.dragDrop&&i.scroller.dragDrop(),Ql(document,"mouseup",l),Ql(document,"mousemove",s),Ql(i.scroller,"dragstart",a),Ql(i.scroller,"drop",l),Dr(e),setTimeout(function(){return i.input.focus()},20)}function Fo(e,t,r){if("char"==r)return new Ts(t,t);if("word"==r)return e.findWordAt(t);if("line"==r)return new Ts(E(t.line,0),U(e.doc,E(t.line+1,0)));var n=r(e,t);return new Ts(n.from,n.to)}function Eo(e,t,r,n){function i(t){if(0!=P(m,t))if(m=t,"rectangle"==n.unit){for(var i=[],o=e.options.tabSize,l=f(M(u,r.line).text,r.ch,o),s=f(M(u,t.line).text,t.ch,o),a=Math.min(l,s),g=Math.max(l,s),v=Math.min(r.line,t.line),y=Math.min(e.lastLine(),Math.max(r.line,t.line));v<=y;v++){var b=M(u,v).text,w=d(b,a,o);a==g?i.push(new Ts(E(v,w),E(v,w))):b.length>w&&i.push(new Ts(E(v,w),E(v,d(b,g,o))))}i.length||i.push(new Ts(r,r)),bi(u,zn(p.ranges.slice(0,h).concat(i),h),{origin:"*mouse",scroll:!1}),e.scrollIntoView(t)}else{var x,C=c,S=Fo(e,t,n.unit),L=C.anchor;P(S.anchor,L)>0?(x=S.head,L=B(C.from(),S.anchor)):(x=S.anchor,L=R(C.to(),S.head));var k=p.ranges.slice(0);k[h]=Po(e,new Ts(U(u,L),x)),bi(u,zn(k,h),Ul)}}function o(t){var r=++b,s=Sr(e,t,!0,"rectangle"==n.unit);if(s)if(0!=P(s,m)){e.curOp.focus=l(),i(s);var c=Ir(a,u);(s.line>=c.to||s.line<c.from)&&setTimeout(dn(e,function(){b==r&&o(t)}),150)}else{var f=t.clientY<y.top?-20:t.clientY>y.bottom?20:0;f&&setTimeout(dn(e,function(){b==r&&(a.scroller.scrollTop+=f,o(t))}),50)}}function s(t){e.state.selectingText=!1,b=1/0,We(t),a.input.focus(),ke(document,"mousemove",w),ke(document,"mouseup",x),u.history.lastSelOrigin=null}var a=e.display,u=e.doc;We(t);var c,h,p=u.sel,g=p.ranges;if(n.addNew&&!n.extend?(h=u.sel.contains(r),c=h>-1?g[h]:new Ts(r,r)):(c=u.sel.primary(),h=u.sel.primIndex),"rectangle"==n.unit)n.addNew||(c=new Ts(r,r)),r=Sr(e,t,!0,!0),h=-1;else{var v=Fo(e,r,n.unit);c=n.extend?hi(c,v.anchor,v.head,n.extend):v}n.addNew?-1==h?(h=g.length,bi(u,zn(g.concat([c]),h),{scroll:!1,origin:"*mouse"})):g.length>1&&g[h].empty()&&"char"==n.unit&&!n.extend?(bi(u,zn(g.slice(0,h).concat(g.slice(h+1)),0),{scroll:!1,origin:"*mouse"}),p=u.sel):gi(u,h,c,Ul):(h=0,bi(u,new ks([c],0),Ul),p=u.sel);var m=r,y=a.wrapper.getBoundingClientRect(),b=0,w=dn(e,function(e){Pe(e)?o(e):s(e)}),x=dn(e,s);e.state.selectingText=x,Ql(document,"mousemove",w),Ql(document,"mouseup",x)}function Po(e,t){var r=t.anchor,n=t.head,i=M(e.doc,r.line);if(0==P(r,n)&&r.sticky==n.sticky)return t;var o=Se(i);if(!o)return t;var l=Ce(o,r.ch,r.sticky),s=o[l];if(s.from!=r.ch&&s.to!=r.ch)return t;var a=l+(s.from==r.ch==(1!=s.level)?0:1);if(0==a||a==o.length)return t;var u;if(n.line!=r.line)u=(n.line-r.line)*("ltr"==e.doc.direction?1:-1)>0;else{var c=Ce(o,n.ch,n.sticky),f=c-l||(n.ch-r.ch)*(1==s.level?-1:1);u=c==a-1||c==a?f<0:f>0}var h=o[a+(u?-1:0)],d=u==(1==h.level),p=d?h.from:h.to,g=d?"after":"before";return r.ch==p&&r.sticky==g?t:new Ts(new E(r.line,p,g),n)}function Io(e,t,r,n){var i,o;if(t.touches)i=t.touches[0].clientX,o=t.touches[0].clientY;else try{i=t.clientX,o=t.clientY}catch(t){return!1}if(i>=Math.floor(e.display.gutters.getBoundingClientRect().right))return!1;n&&We(t);var l=e.display,s=l.lineDiv.getBoundingClientRect();if(o>s.bottom||!Oe(e,r))return He(t);o-=s.top-l.viewOffset;for(var a=0;a<e.options.gutters.length;++a){var u=l.gutters.childNodes[a];if(u&&u.getBoundingClientRect().right>=i)return Te(e,r,e,D(e.doc,o),e.options.gutters[a],t),He(t)}}function zo(e,t){return Io(e,t,"gutterClick",!0)}function Ro(e,t){Ft(e.display,t)||Bo(e,t)||Me(e,t,"contextmenu")||e.display.input.onContextMenu(t)}function Bo(e,t){return!!Oe(e,"gutterContextMenu")&&Io(e,t,"gutterContextMenu",!1)}function Go(e){e.display.wrapper.className=e.display.wrapper.className.replace(/\s*cm-s-\S+/g,"")+e.options.theme.replace(/(^|\s)\s*/g," cm-s-"),er(e)}function Uo(e){Hn(e),vn(e),zr(e)}function Vo(e,t,r){if(!t!=!(r&&r!=Xs)){var n=e.display.dragFunctions,i=t?Ql:ke;i(e.display.scroller,"dragstart",n.start),i(e.display.scroller,"dragenter",n.enter),i(e.display.scroller,"dragover",n.over),i(e.display.scroller,"dragleave",n.leave),i(e.display.scroller,"drop",n.drop)}}function Ko(e){e.options.lineWrapping?(s(e.display.wrapper,"CodeMirror-wrap"),e.display.sizer.style.minWidth="",e.display.sizerWidth=null):(Fl(e.display.wrapper,"CodeMirror-wrap"),we(e)),Cr(e),vn(e),er(e),setTimeout(function(){return en(e)},100)}function jo(e,t){var r=this;if(!(this instanceof jo))return new jo(e,t);this.options=t=t?c(t):{},c(Ys,t,!1),Fn(t);var n=t.value;"string"==typeof n&&(n=new Ds(n,t.mode,null,t.lineSeparator,t.direction)),this.doc=n;var i=new jo.inputStyles[t.inputStyle](this),o=this.display=new T(e,n,i);o.wrapper.CodeMirror=this,Hn(this),Go(this),t.lineWrapping&&(this.display.wrapper.className+=" CodeMirror-wrap"),rn(this),this.state={keyMaps:[],overlays:[],modeGen:0,overwrite:!1,delayingBlurEvent:!1,focused:!1,suppressEdits:!1,pasteIncoming:!1,cutIncoming:!1,selectingText:!1,draggingText:!1,highlight:new Pl,keySeq:null,specialChars:null},t.autofocus&&!Tl&&o.input.focus(),gl&&vl<11&&setTimeout(function(){return r.display.input.reset(!0)},20),Xo(this),eo(),nn(this),this.curOp.forceUpdate=!0,qn(this,n),t.autofocus&&!Tl||this.hasFocus()?setTimeout(u(Hr,this),20):Fr(this);for(var l in _s)_s.hasOwnProperty(l)&&_s[l](r,t[l],Xs);Rr(this),t.finishInit&&t.finishInit(this);for(var s=0;s<$s.length;++s)$s[s](r);on(this),ml&&t.lineWrapping&&"optimizelegibility"==getComputedStyle(o.lineDiv).textRendering&&(o.lineDiv.style.textRendering="auto")}function Xo(e){function t(){i.activeTouch&&(o=setTimeout(function(){return i.activeTouch=null},1e3),(l=i.activeTouch).end=+new Date)}function r(e){if(1!=e.touches.length)return!1;var t=e.touches[0];return t.radiusX<=1&&t.radiusY<=1}function n(e,t){if(null==t.left)return!0;var r=t.left-e.left,n=t.top-e.top;return r*r+n*n>400}var i=e.display;Ql(i.scroller,"mousedown",dn(e,Oo)),gl&&vl<11?Ql(i.scroller,"dblclick",dn(e,function(t){if(!Me(e,t)){var r=Sr(e,t);if(r&&!zo(e,t)&&!Ft(e.display,t)){We(t);var n=e.findWordAt(r);di(e.doc,n.anchor,n.head)}}})):Ql(i.scroller,"dblclick",function(t){return Me(e,t)||We(t)}),Hl||Ql(i.scroller,"contextmenu",function(t){return Ro(e,t)});var o,l={end:0};Ql(i.scroller,"touchstart",function(t){if(!Me(e,t)&&!r(t)&&!zo(e,t)){i.input.ensurePolled(),clearTimeout(o);var n=+new Date;i.activeTouch={start:n,moved:!1,prev:n-l.end<=300?l:null},1==t.touches.length&&(i.activeTouch.left=t.touches[0].pageX,i.activeTouch.top=t.touches[0].pageY)}}),Ql(i.scroller,"touchmove",function(){i.activeTouch&&(i.activeTouch.moved=!0)}),Ql(i.scroller,"touchend",function(r){var o=i.activeTouch;if(o&&!Ft(i,r)&&null!=o.left&&!o.moved&&new Date-o.start<300){var l,s=e.coordsChar(i.activeTouch,"page");l=!o.prev||n(o,o.prev)?new Ts(s,s):!o.prev.prev||n(o,o.prev.prev)?e.findWordAt(s):new Ts(E(s.line,0),U(e.doc,E(s.line+1,0))),e.setSelection(l.anchor,l.head),e.focus(),We(r)}t()}),Ql(i.scroller,"touchcancel",t),Ql(i.scroller,"scroll",function(){i.scroller.clientHeight&&(qr(e,i.scroller.scrollTop),Qr(e,i.scroller.scrollLeft,!0),Te(e,"scroll",e))}),Ql(i.scroller,"mousewheel",function(t){return In(e,t)}),Ql(i.scroller,"DOMMouseScroll",function(t){return In(e,t)}),Ql(i.wrapper,"scroll",function(){return i.wrapper.scrollTop=i.wrapper.scrollLeft=0}),i.dragFunctions={enter:function(t){Me(e,t)||Fe(t)},over:function(t){Me(e,t)||(Zi(e,t),Fe(t))},start:function(t){return qi(e,t)},drop:dn(e,$i),leave:function(t){Me(e,t)||Qi(e)}};var s=i.input.getField();Ql(s,"keyup",function(t){return To.call(e,t)}),Ql(s,"keydown",dn(e,Lo)),Ql(s,"keypress",dn(e,Mo)),Ql(s,"focus",function(t){return Hr(e,t)}),Ql(s,"blur",function(t){return Fr(e,t)})}function Yo(e,t,r,n){var i,o=e.doc;null==r&&(r="add"),"smart"==r&&(o.mode.indent?i=$e(e,t).state:r="prev");var l=e.options.tabSize,s=M(o,t),a=f(s.text,null,l);s.stateAfter&&(s.stateAfter=null);var u,c=s.text.match(/^\s*/)[0];if(n||/\S/.test(s.text)){if("smart"==r&&((u=o.mode.indent(i,s.text.slice(c.length),s.text))==Bl||u>150)){if(!n)return;r="prev"}}else u=0,r="not";"prev"==r?u=t>o.first?f(M(o,t-1).text,null,l):0:"add"==r?u=a+e.options.indentUnit:"subtract"==r?u=a-e.options.indentUnit:"number"==typeof r&&(u=a+r),u=Math.max(0,u);var h="",d=0;if(e.options.indentWithTabs)for(var g=Math.floor(u/l);g;--g)d+=l,h+="\t";if(d<u&&(h+=p(u-d)),h!=c)return Ei(o,h,E(t,0),E(t,c.length),"+input"),s.stateAfter=null,!0;for(var v=0;v<o.sel.ranges.length;v++){var m=o.sel.ranges[v];if(m.head.line==t&&m.head.ch<c.length){var y=E(t,c.length);gi(o,v,new Ts(y,y));break}}}function _o(e){qs=e}function $o(e,t,r,n,i){var o=e.doc;e.display.shift=!1,n||(n=o.sel);var l=e.state.pasteIncoming||"paste"==i,s=es(t),a=null;if(l&&n.ranges.length>1)if(qs&&qs.text.join("\n")==t){if(n.ranges.length%qs.text.length==0){a=[];for(var u=0;u<qs.text.length;u++)a.push(o.splitLines(qs.text[u]))}}else s.length==n.ranges.length&&e.options.pasteLinesPerSelection&&(a=v(s,function(e){return[e]}));for(var c,f=n.ranges.length-1;f>=0;f--){var h=n.ranges[f],d=h.from(),p=h.to();h.empty()&&(r&&r>0?d=E(d.line,d.ch-r):e.state.overwrite&&!l?p=E(p.line,Math.min(M(o,p.line).text.length,p.ch+g(s).length)):qs&&qs.lineWise&&qs.text.join("\n")==t&&(d=p=E(d.line,0))),c=e.curOp.updateInput;var m={from:d,to:p,text:a?a[f%a.length]:s,origin:i||(l?"paste":e.state.cutIncoming?"cut":"+input")};Oi(e.doc,m),bt(e,"inputRead",e,m)}t&&!l&&Zo(e,t),jr(e),e.curOp.updateInput=c,e.curOp.typing=!0,e.state.pasteIncoming=e.state.cutIncoming=!1}function qo(e,t){var r=e.clipboardData&&e.clipboardData.getData("Text");if(r)return e.preventDefault(),t.isReadOnly()||t.options.disableInput||hn(t,function(){return $o(t,r,0,null,"paste")}),!0}function Zo(e,t){if(e.options.electricChars&&e.options.smartIndent)for(var r=e.doc.sel,n=r.ranges.length-1;n>=0;n--){var i=r.ranges[n];if(!(i.head.ch>100||n&&r.ranges[n-1].head.line==i.head.line)){var o=e.getModeAt(i.head),l=!1;if(o.electricChars){for(var s=0;s<o.electricChars.length;s++)if(t.indexOf(o.electricChars.charAt(s))>-1){l=Yo(e,i.head.line,"smart");break}}else o.electricInput&&o.electricInput.test(M(e.doc,i.head.line).text.slice(0,i.head.ch))&&(l=Yo(e,i.head.line,"smart"));l&&bt(e,"electricInput",e,i.head.line)}}}function Qo(e){for(var t=[],r=[],n=0;n<e.doc.sel.ranges.length;n++){var i=e.doc.sel.ranges[n].head.line,o={anchor:E(i,0),head:E(i+1,0)};r.push(o),t.push(e.getRange(o.anchor,o.head))}return{text:t,ranges:r}}function Jo(e,t){e.setAttribute("autocorrect","off"),e.setAttribute("autocapitalize","off"),e.setAttribute("spellcheck",!!t)}function el(){var e=n("textarea",null,null,"position: absolute; bottom: -1em; padding: 0; width: 1px; height: 1em; outline: none"),t=n("div",[e],null,"overflow: hidden; position: relative; width: 3px; height: 0px;");return ml?e.style.width="1000px":e.setAttribute("wrap","off"),Ll&&(e.style.border="1px solid black"),Jo(e),t}function tl(e,t,r,n,i){function o(){var n=t.line+r;return!(n<e.first||n>=e.first+e.size)&&(t=new E(n,t.ch,t.sticky),u=M(e,n))}function l(n){var l;if(null==(l=i?go(e.cm,u,t,r):ho(u,t,r))){if(n||!o())return!1;t=po(i,e.cm,u,t.line,r)}else t=l;return!0}var s=t,a=r,u=M(e,t.line);if("char"==n)l();else if("column"==n)l(!0);else if("word"==n||"group"==n)for(var c=null,f="group"==n,h=e.cm&&e.cm.getHelper(t,"wordChars"),d=!0;!(r<0)||l(!d);d=!1){var p=u.text.charAt(t.ch)||"\n",g=x(p,h)?"w":f&&"\n"==p?"n":!f||/\s/.test(p)?null:"p";if(!f||d||g||(g="s"),c&&c!=g){r<0&&(r=1,l(),t.sticky="after");break}if(g&&(c=g),r>0&&!l(!d))break}var v=ki(e,t,s,a,!0);return I(s,v)&&(v.hitSide=!0),v}function rl(e,t,r,n){var i,o=e.doc,l=t.left;if("page"==n){var s=Math.min(e.display.wrapper.clientHeight,window.innerHeight||document.documentElement.clientHeight),a=Math.max(s-.5*mr(e.display),3);i=(r>0?t.bottom:t.top)+r*a}else"line"==n&&(i=r>0?t.bottom+3:t.top-3);for(var u;(u=cr(e,l,i)).outside;){if(r<0?i<=0:i>=o.height){u.hitSide=!0;break}i+=5*r}return u}function nl(e,t){var r=jt(e,t.line);if(!r||r.hidden)return null;var n=M(e.doc,t.line),i=Ut(r,n,t.line),o=Se(n,e.doc.direction),l="left";o&&(l=Ce(o,t.ch)%2?"right":"left");var s=_t(i.map,t.ch,l);return s.offset="right"==s.collapse?s.end:s.start,s}function il(e){for(var t=e;t;t=t.parentNode)if(/CodeMirror-gutter-wrapper/.test(t.className))return!0;return!1}function ol(e,t){return t&&(e.bad=!0),e}function ll(e,t,r,n,i){function o(e){return function(t){return t.id==e}}function l(){c&&(u+=f,c=!1)}function s(e){e&&(l(),u+=e)}function a(t){if(1==t.nodeType){var r=t.getAttribute("cm-text");if(null!=r)return void s(r||t.textContent.replace(/\u200b/g,""));var u,h=t.getAttribute("cm-marker");if(h){var d=e.findMarks(E(n,0),E(i+1,0),o(+h));return void(d.length&&(u=d[0].find(0))&&s(N(e.doc,u.from,u.to).join(f)))}if("false"==t.getAttribute("contenteditable"))return;var p=/^(pre|div|p)$/i.test(t.nodeName);p&&l();for(var g=0;g<t.childNodes.length;g++)a(t.childNodes[g]);p&&(c=!0)}else 3==t.nodeType&&s(t.nodeValue)}for(var u="",c=!1,f=e.doc.lineSeparator();a(t),t!=r;)t=t.nextSibling;return u}function sl(e,t,r){var n;if(t==e.display.lineDiv){if(!(n=e.display.lineDiv.childNodes[r]))return ol(e.clipPos(E(e.display.viewTo-1)),!0);t=null,r=0}else for(n=t;;n=n.parentNode){if(!n||n==e.display.lineDiv)return null;if(n.parentNode&&n.parentNode==e.display.lineDiv)break}for(var i=0;i<e.display.view.length;i++){var o=e.display.view[i];if(o.node==n)return al(o,t,r)}}function al(e,t,r){function n(t,r,n){for(var i=-1;i<(f?f.length:0);i++)for(var o=i<0?c.map:f[i],l=0;l<o.length;l+=3){var s=o[l+2];if(s==t||s==r){var a=W(i<0?e.line:e.rest[i]),u=o[l]+n;return(n<0||s!=t)&&(u=o[l+(n?1:0)]),E(a,u)}}}var i=e.text.firstChild,l=!1;if(!t||!o(i,t))return ol(E(W(e.line),0),!0);if(t==i&&(l=!0,t=i.childNodes[r],r=0,!t)){var s=e.rest?g(e.rest):e.line;return ol(E(W(s),s.text.length),l)}var a=3==t.nodeType?t:null,u=t;for(a||1!=t.childNodes.length||3!=t.firstChild.nodeType||(a=t.firstChild,r&&(r=a.nodeValue.length));u.parentNode!=i;)u=u.parentNode;var c=e.measure,f=c.maps,h=n(a,u,r);if(h)return ol(h,l);for(var d=u.nextSibling,p=a?a.nodeValue.length-r:0;d;d=d.nextSibling){if(h=n(d,d.firstChild,0))return ol(E(h.line,h.ch-p),l);p+=d.textContent.length}for(var v=u.previousSibling,m=r;v;v=v.previousSibling){if(h=n(v,v.firstChild,-1))return ol(E(h.line,h.ch+m),l);m+=v.textContent.length}}var ul=navigator.userAgent,cl=navigator.platform,fl=/gecko\/\d/i.test(ul),hl=/MSIE \d/.test(ul),dl=/Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(ul),pl=/Edge\/(\d+)/.exec(ul),gl=hl||dl||pl,vl=gl&&(hl?document.documentMode||6:+(pl||dl)[1]),ml=!pl&&/WebKit\//.test(ul),yl=ml&&/Qt\/\d+\.\d+/.test(ul),bl=!pl&&/Chrome\//.test(ul),wl=/Opera\//.test(ul),xl=/Apple Computer/.test(navigator.vendor),Cl=/Mac OS X 1\d\D([8-9]|\d\d)\D/.test(ul),Sl=/PhantomJS/.test(ul),Ll=!pl&&/AppleWebKit/.test(ul)&&/Mobile\/\w+/.test(ul),kl=/Android/.test(ul),Tl=Ll||kl||/webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(ul),Ml=Ll||/Mac/.test(cl),Nl=/\bCrOS\b/.test(ul),Ol=/win/i.test(cl),Al=wl&&ul.match(/Version\/(\d*\.\d*)/);Al&&(Al=Number(Al[1])),Al&&Al>=15&&(wl=!1,ml=!0);var Wl,Dl=Ml&&(yl||wl&&(null==Al||Al<12.11)),Hl=fl||gl&&vl>=9,Fl=function(t,r){var n=t.className,i=e(r).exec(n);if(i){var o=n.slice(i.index+i[0].length);t.className=n.slice(0,i.index)+(o?i[1]+o:"")}};Wl=document.createRange?function(e,t,r,n){var i=document.createRange();return i.setEnd(n||e,r),i.setStart(e,t),i}:function(e,t,r){var n=document.body.createTextRange();try{n.moveToElementText(e.parentNode)}catch(e){return n}return n.collapse(!0),n.moveEnd("character",r),n.moveStart("character",t),n};var El=function(e){e.select()};Ll?El=function(e){e.selectionStart=0,e.selectionEnd=e.value.length}:gl&&(El=function(e){try{e.select()}catch(e){}});var Pl=function(){this.id=null};Pl.prototype.set=function(e,t){clearTimeout(this.id),this.id=setTimeout(t,e)};var Il,zl,Rl=30,Bl={toString:function(){return"CodeMirror.Pass"}},Gl={scroll:!1},Ul={origin:"*mouse"},Vl={origin:"+move"},Kl=[""],jl=/[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/,Xl=/[\u0300-\u036f\u0483-\u0489\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u065e\u0670\u06d6-\u06dc\u06de-\u06e4\u06e7\u06e8\u06ea-\u06ed\u0711\u0730-\u074a\u07a6-\u07b0\u07eb-\u07f3\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0900-\u0902\u093c\u0941-\u0948\u094d\u0951-\u0955\u0962\u0963\u0981\u09bc\u09be\u09c1-\u09c4\u09cd\u09d7\u09e2\u09e3\u0a01\u0a02\u0a3c\u0a41\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a70\u0a71\u0a75\u0a81\u0a82\u0abc\u0ac1-\u0ac5\u0ac7\u0ac8\u0acd\u0ae2\u0ae3\u0b01\u0b3c\u0b3e\u0b3f\u0b41-\u0b44\u0b4d\u0b56\u0b57\u0b62\u0b63\u0b82\u0bbe\u0bc0\u0bcd\u0bd7\u0c3e-\u0c40\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0cbc\u0cbf\u0cc2\u0cc6\u0ccc\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0d3e\u0d41-\u0d44\u0d4d\u0d57\u0d62\u0d63\u0dca\u0dcf\u0dd2-\u0dd4\u0dd6\u0ddf\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0eb1\u0eb4-\u0eb9\u0ebb\u0ebc\u0ec8-\u0ecd\u0f18\u0f19\u0f35\u0f37\u0f39\u0f71-\u0f7e\u0f80-\u0f84\u0f86\u0f87\u0f90-\u0f97\u0f99-\u0fbc\u0fc6\u102d-\u1030\u1032-\u1037\u1039\u103a\u103d\u103e\u1058\u1059\u105e-\u1060\u1071-\u1074\u1082\u1085\u1086\u108d\u109d\u135f\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b7-\u17bd\u17c6\u17c9-\u17d3\u17dd\u180b-\u180d\u18a9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193b\u1a17\u1a18\u1a56\u1a58-\u1a5e\u1a60\u1a62\u1a65-\u1a6c\u1a73-\u1a7c\u1a7f\u1b00-\u1b03\u1b34\u1b36-\u1b3a\u1b3c\u1b42\u1b6b-\u1b73\u1b80\u1b81\u1ba2-\u1ba5\u1ba8\u1ba9\u1c2c-\u1c33\u1c36\u1c37\u1cd0-\u1cd2\u1cd4-\u1ce0\u1ce2-\u1ce8\u1ced\u1dc0-\u1de6\u1dfd-\u1dff\u200c\u200d\u20d0-\u20f0\u2cef-\u2cf1\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua66f-\ua672\ua67c\ua67d\ua6f0\ua6f1\ua802\ua806\ua80b\ua825\ua826\ua8c4\ua8e0-\ua8f1\ua926-\ua92d\ua947-\ua951\ua980-\ua982\ua9b3\ua9b6-\ua9b9\ua9bc\uaa29-\uaa2e\uaa31\uaa32\uaa35\uaa36\uaa43\uaa4c\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uabe5\uabe8\uabed\udc00-\udfff\ufb1e\ufe00-\ufe0f\ufe20-\ufe26\uff9e\uff9f]/,Yl=!1,_l=!1,$l=null,ql=function(){function e(e){return e<=247?r.charAt(e):1424<=e&&e<=1524?"R":1536<=e&&e<=1785?n.charAt(e-1536):1774<=e&&e<=2220?"r":8192<=e&&e<=8203?"w":8204==e?"b":"L"}function t(e,t,r){this.level=e,this.from=t,this.to=r}var r="bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLN",n="nnnnnnNNr%%r,rNNmmmmmmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmmmnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmnNmmmmmmrrmmNmmmmrr1111111111",i=/[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/,o=/[stwN]/,l=/[LRr]/,s=/[Lb1n]/,a=/[1n]/;return function(r,n){var u="ltr"==n?"L":"R";if(0==r.length||"ltr"==n&&!i.test(r))return!1;for(var c=r.length,f=[],h=0;h<c;++h)f.push(e(r.charCodeAt(h)));for(var d=0,p=u;d<c;++d){var v=f[d];"m"==v?f[d]=p:p=v}for(var m=0,y=u;m<c;++m){var b=f[m];"1"==b&&"r"==y?f[m]="n":l.test(b)&&(y=b,"r"==b&&(f[m]="R"))}for(var w=1,x=f[0];w<c-1;++w){var C=f[w];"+"==C&&"1"==x&&"1"==f[w+1]?f[w]="1":","!=C||x!=f[w+1]||"1"!=x&&"n"!=x||(f[w]=x),x=C}for(var S=0;S<c;++S){var L=f[S];if(","==L)f[S]="N";else if("%"==L){var k=void 0;for(k=S+1;k<c&&"%"==f[k];++k);for(var T=S&&"!"==f[S-1]||k<c&&"1"==f[k]?"1":"N",M=S;M<k;++M)f[M]=T;S=k-1}}for(var N=0,O=u;N<c;++N){var A=f[N];"L"==O&&"1"==A?f[N]="L":l.test(A)&&(O=A)}for(var W=0;W<c;++W)if(o.test(f[W])){var D=void 0;for(D=W+1;D<c&&o.test(f[D]);++D);for(var H="L"==(W?f[W-1]:u),F=H==("L"==(D<c?f[D]:u))?H?"L":"R":u,E=W;E<D;++E)f[E]=F;W=D-1}for(var P,I=[],z=0;z<c;)if(s.test(f[z])){var R=z;for(++z;z<c&&s.test(f[z]);++z);I.push(new t(0,R,z))}else{var B=z,G=I.length;for(++z;z<c&&"L"!=f[z];++z);for(var U=B;U<z;)if(a.test(f[U])){B<U&&I.splice(G,0,new t(1,B,U));var V=U;for(++U;U<z&&a.test(f[U]);++U);I.splice(G,0,new t(2,V,U)),B=U}else++U;B<z&&I.splice(G,0,new t(1,B,z))}return 1==I[0].level&&(P=r.match(/^\s+/))&&(I[0].from=P[0].length,I.unshift(new t(0,0,P[0].length))),1==g(I).level&&(P=r.match(/\s+$/))&&(g(I).to-=P[0].length,I.push(new t(0,c-P[0].length,c))),"rtl"==n?I.reverse():I}}(),Zl=[],Ql=function(e,t,r){if(e.addEventListener)e.addEventListener(t,r,!1);else if(e.attachEvent)e.attachEvent("on"+t,r);else{var n=e._handlers||(e._handlers={});n[t]=(n[t]||Zl).concat(r)}},Jl=function(){if(gl&&vl<9)return!1;var e=n("div");return"draggable"in e||"dragDrop"in e}(),es=3!="\n\nb".split(/\n/).length?function(e){for(var t=0,r=[],n=e.length;t<=n;){var i=e.indexOf("\n",t);-1==i&&(i=e.length);var o=e.slice(t,"\r"==e.charAt(i-1)?i-1:i),l=o.indexOf("\r");-1!=l?(r.push(o.slice(0,l)),t+=l+1):(r.push(o),t=i+1)}return r}:function(e){return e.split(/\r\n?|\n/)},ts=window.getSelection?function(e){try{return e.selectionStart!=e.selectionEnd}catch(e){return!1}}:function(e){var t;try{t=e.ownerDocument.selection.createRange()}catch(e){}return!(!t||t.parentElement()!=e)&&0!=t.compareEndPoints("StartToEnd",t)},rs=function(){var e=n("div");return"oncopy"in e||(e.setAttribute("oncopy","return;"),"function"==typeof e.oncopy)}(),ns=null,is={},os={},ls={},ss=function(e,t,r){this.pos=this.start=0,this.string=e,this.tabSize=t||8,this.lastColumnPos=this.lastColumnValue=0,this.lineStart=0,this.lineOracle=r};ss.prototype.eol=function(){return this.pos>=this.string.length},ss.prototype.sol=function(){return this.pos==this.lineStart},ss.prototype.peek=function(){return this.string.charAt(this.pos)||void 0},ss.prototype.next=function(){if(this.pos<this.string.length)return this.string.charAt(this.pos++)},ss.prototype.eat=function(e){var t=this.string.charAt(this.pos);if("string"==typeof e?t==e:t&&(e.test?e.test(t):e(t)))return++this.pos,t},ss.prototype.eatWhile=function(e){for(var t=this.pos;this.eat(e););return this.pos>t},ss.prototype.eatSpace=function(){for(var e=this,t=this.pos;/[\s\u00a0]/.test(this.string.charAt(this.pos));)++e.pos;return this.pos>t},ss.prototype.skipToEnd=function(){this.pos=this.string.length},ss.prototype.skipTo=function(e){var t=this.string.indexOf(e,this.pos);if(t>-1)return this.pos=t,!0},ss.prototype.backUp=function(e){this.pos-=e},ss.prototype.column=function(){return this.lastColumnPos<this.start&&(this.lastColumnValue=f(this.string,this.start,this.tabSize,this.lastColumnPos,this.lastColumnValue),this.lastColumnPos=this.start),this.lastColumnValue-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.indentation=function(){return f(this.string,null,this.tabSize)-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.match=function(e,t,r){if("string"!=typeof e){var n=this.string.slice(this.pos).match(e);return n&&n.index>0?null:(n&&!1!==t&&(this.pos+=n[0].length),n)}var i=function(e){return r?e.toLowerCase():e};if(i(this.string.substr(this.pos,e.length))==i(e))return!1!==t&&(this.pos+=e.length),!0},ss.prototype.current=function(){return this.string.slice(this.start,this.pos)},ss.prototype.hideFirstChars=function(e,t){this.lineStart+=e;try{return t()}finally{this.lineStart-=e}},ss.prototype.lookAhead=function(e){var t=this.lineOracle;return t&&t.lookAhead(e)};var as=function(e,t){this.state=e,this.lookAhead=t},us=function(e,t,r,n){this.state=t,this.doc=e,this.line=r,this.maxLookAhead=n||0};us.prototype.lookAhead=function(e){var t=this.doc.getLine(this.line+e);return null!=t&&e>this.maxLookAhead&&(this.maxLookAhead=e),t},us.prototype.nextLine=function(){this.line++,this.maxLookAhead>0&&this.maxLookAhead--},us.fromSaved=function(e,t,r){return t instanceof as?new us(e,Ke(e.mode,t.state),r,t.lookAhead):new us(e,Ke(e.mode,t),r)},us.prototype.save=function(e){var t=!1!==e?Ke(this.doc.mode,this.state):this.state;return this.maxLookAhead>0?new as(t,this.maxLookAhead):t};var cs=function(e,t,r){this.start=e.start,this.end=e.pos,this.string=e.current(),this.type=t||null,this.state=r},fs=function(e,t,r){this.text=e,ne(this,t),this.height=r?r(this):1};fs.prototype.lineNo=function(){return W(this)},Ae(fs);var hs,ds={},ps={},gs=null,vs=null,ms={left:0,right:0,top:0,bottom:0},ys=function(e,t,r){this.cm=r;var i=this.vert=n("div",[n("div",null,null,"min-width: 1px")],"CodeMirror-vscrollbar"),o=this.horiz=n("div",[n("div",null,null,"height: 100%; min-height: 1px")],"CodeMirror-hscrollbar");e(i),e(o),Ql(i,"scroll",function(){i.clientHeight&&t(i.scrollTop,"vertical")}),Ql(o,"scroll",function(){o.clientWidth&&t(o.scrollLeft,"horizontal")}),this.checkedZeroWidth=!1,gl&&vl<8&&(this.horiz.style.minHeight=this.vert.style.minWidth="18px")};ys.prototype.update=function(e){var t=e.scrollWidth>e.clientWidth+1,r=e.scrollHeight>e.clientHeight+1,n=e.nativeBarWidth;if(r){this.vert.style.display="block",this.vert.style.bottom=t?n+"px":"0";var i=e.viewHeight-(t?n:0);this.vert.firstChild.style.height=Math.max(0,e.scrollHeight-e.clientHeight+i)+"px"}else this.vert.style.display="",this.vert.firstChild.style.height="0";if(t){this.horiz.style.display="block",this.horiz.style.right=r?n+"px":"0",this.horiz.style.left=e.barLeft+"px";var o=e.viewWidth-e.barLeft-(r?n:0);this.horiz.firstChild.style.width=Math.max(0,e.scrollWidth-e.clientWidth+o)+"px"}else this.horiz.style.display="",this.horiz.firstChild.style.width="0";return!this.checkedZeroWidth&&e.clientHeight>0&&(0==n&&this.zeroWidthHack(),this.checkedZeroWidth=!0),{right:r?n:0,bottom:t?n:0}},ys.prototype.setScrollLeft=function(e){this.horiz.scrollLeft!=e&&(this.horiz.scrollLeft=e),this.disableHoriz&&this.enableZeroWidthBar(this.horiz,this.disableHoriz,"horiz")},ys.prototype.setScrollTop=function(e){this.vert.scrollTop!=e&&(this.vert.scrollTop=e),this.disableVert&&this.enableZeroWidthBar(this.vert,this.disableVert,"vert")},ys.prototype.zeroWidthHack=function(){var e=Ml&&!Cl?"12px":"18px";this.horiz.style.height=this.vert.style.width=e,this.horiz.style.pointerEvents=this.vert.style.pointerEvents="none",this.disableHoriz=new Pl,this.disableVert=new Pl},ys.prototype.enableZeroWidthBar=function(e,t,r){function n(){var i=e.getBoundingClientRect();("vert"==r?document.elementFromPoint(i.right-1,(i.top+i.bottom)/2):document.elementFromPoint((i.right+i.left)/2,i.bottom-1))!=e?e.style.pointerEvents="none":t.set(1e3,n)}e.style.pointerEvents="auto",t.set(1e3,n)},ys.prototype.clear=function(){var e=this.horiz.parentNode;e.removeChild(this.horiz),e.removeChild(this.vert)};var bs=function(){};bs.prototype.update=function(){return{bottom:0,right:0}},bs.prototype.setScrollLeft=function(){},bs.prototype.setScrollTop=function(){},bs.prototype.clear=function(){};var ws={native:ys,null:bs},xs=0,Cs=function(e,t,r){var n=e.display;this.viewport=t,this.visible=Ir(n,e.doc,t),this.editorIsHidden=!n.wrapper.offsetWidth,this.wrapperHeight=n.wrapper.clientHeight,this.wrapperWidth=n.wrapper.clientWidth,this.oldDisplayWidth=Rt(e),this.force=r,this.dims=br(e),this.events=[]};Cs.prototype.signal=function(e,t){Oe(e,t)&&this.events.push(arguments)},Cs.prototype.finish=function(){for(var e=this,t=0;t<this.events.length;t++)Te.apply(null,e.events[t])};var Ss=0,Ls=null;gl?Ls=-.53:fl?Ls=15:bl?Ls=-.7:xl&&(Ls=-1/3);var ks=function(e,t){this.ranges=e,this.primIndex=t};ks.prototype.primary=function(){return this.ranges[this.primIndex]},ks.prototype.equals=function(e){var t=this;if(e==this)return!0;if(e.primIndex!=this.primIndex||e.ranges.length!=this.ranges.length)return!1;for(var r=0;r<this.ranges.length;r++){var n=t.ranges[r],i=e.ranges[r];if(!I(n.anchor,i.anchor)||!I(n.head,i.head))return!1}return!0},ks.prototype.deepCopy=function(){for(var e=this,t=[],r=0;r<this.ranges.length;r++)t[r]=new Ts(z(e.ranges[r].anchor),z(e.ranges[r].head));return new ks(t,this.primIndex)},ks.prototype.somethingSelected=function(){for(var e=this,t=0;t<this.ranges.length;t++)if(!e.ranges[t].empty())return!0;return!1},ks.prototype.contains=function(e,t){var r=this;t||(t=e);for(var n=0;n<this.ranges.length;n++){var i=r.ranges[n];if(P(t,i.from())>=0&&P(e,i.to())<=0)return n}return-1};var Ts=function(e,t){this.anchor=e,this.head=t};Ts.prototype.from=function(){return B(this.anchor,this.head)},Ts.prototype.to=function(){return R(this.anchor,this.head)},Ts.prototype.empty=function(){return this.head.line==this.anchor.line&&this.head.ch==this.anchor.ch},Bi.prototype={chunkSize:function(){return this.lines.length},removeInner:function(e,t){for(var r=this,n=e,i=e+t;n<i;++n){var o=r.lines[n];r.height-=o.height,ot(o),bt(o,"delete")}this.lines.splice(e,t)},collapse:function(e){e.push.apply(e,this.lines)},insertInner:function(e,t,r){var n=this;this.height+=r,this.lines=this.lines.slice(0,e).concat(t).concat(this.lines.slice(e));for(var i=0;i<t.length;++i)t[i].parent=n},iterN:function(e,t,r){for(var n=this,i=e+t;e<i;++e)if(r(n.lines[e]))return!0}},Gi.prototype={chunkSize:function(){return this.size},removeInner:function(e,t){var r=this;this.size-=t;for(var n=0;n<this.children.length;++n){var i=r.children[n],o=i.chunkSize();if(e<o){var l=Math.min(t,o-e),s=i.height;if(i.removeInner(e,l),r.height-=s-i.height,o==l&&(r.children.splice(n--,1),i.parent=null),0==(t-=l))break;e=0}else e-=o}if(this.size-t<25&&(this.children.length>1||!(this.children[0]instanceof Bi))){var a=[];this.collapse(a),this.children=[new Bi(a)],this.children[0].parent=this}},collapse:function(e){for(var t=this,r=0;r<this.children.length;++r)t.children[r].collapse(e)},insertInner:function(e,t,r){var n=this;this.size+=t.length,this.height+=r;for(var i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<=l){if(o.insertInner(e,t,r),o.lines&&o.lines.length>50){for(var s=o.lines.length%25+25,a=s;a<o.lines.length;){var u=new Bi(o.lines.slice(a,a+=25));o.height-=u.height,n.children.splice(++i,0,u),u.parent=n}o.lines=o.lines.slice(0,s),n.maybeSpill()}break}e-=l}},maybeSpill:function(){if(!(this.children.length<=10)){var e=this;do{var t=new Gi(e.children.splice(e.children.length-5,5));if(e.parent){e.size-=t.size,e.height-=t.height;var r=h(e.parent.children,e);e.parent.children.splice(r+1,0,t)}else{var n=new Gi(e.children);n.parent=e,e.children=[n,t],e=n}t.parent=e.parent}while(e.children.length>10);e.parent.maybeSpill()}},iterN:function(e,t,r){for(var n=this,i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<l){var s=Math.min(t,l-e);if(o.iterN(e,s,r))return!0;if(0==(t-=s))break;e=0}else e-=l}}};var Ms=function(e,t,r){var n=this;if(r)for(var i in r)r.hasOwnProperty(i)&&(n[i]=r[i]);this.doc=e,this.node=t};Ms.prototype.clear=function(){var e=this,t=this.doc.cm,r=this.line.widgets,n=this.line,i=W(n);if(null!=i&&r){for(var o=0;o<r.length;++o)r[o]==e&&r.splice(o--,1);r.length||(n.widgets=null);var l=Ht(this);A(n,Math.max(0,n.height-l)),t&&(hn(t,function(){Ui(t,n,-l),mn(t,i,"widget")}),bt(t,"lineWidgetCleared",t,this,i))}},Ms.prototype.changed=function(){var e=this,t=this.height,r=this.doc.cm,n=this.line;this.height=null;var i=Ht(this)-t;i&&(A(n,n.height+i),r&&hn(r,function(){r.curOp.forceUpdate=!0,Ui(r,n,i),bt(r,"lineWidgetChanged",r,e,W(n))}))},Ae(Ms);var Ns=0,Os=function(e,t){this.lines=[],this.type=t,this.doc=e,this.id=++Ns};Os.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){var t=this.doc.cm,r=t&&!t.curOp;if(r&&nn(t),Oe(this,"clear")){var n=this.find();n&&bt(this,"clear",n.from,n.to)}for(var i=null,o=null,l=0;l<this.lines.length;++l){var s=e.lines[l],a=_(s.markedSpans,e);t&&!e.collapsed?mn(t,W(s),"text"):t&&(null!=a.to&&(o=W(s)),null!=a.from&&(i=W(s))),s.markedSpans=$(s.markedSpans,a),null==a.from&&e.collapsed&&!ve(e.doc,s)&&t&&A(s,mr(t.display))}if(t&&this.collapsed&&!t.options.lineWrapping)for(var u=0;u<this.lines.length;++u){var c=fe(e.lines[u]),f=be(c);f>t.display.maxLineLength&&(t.display.maxLine=c,t.display.maxLineLength=f,t.display.maxLineChanged=!0)}null!=i&&t&&this.collapsed&&vn(t,i,o+1),this.lines.length=0,this.explicitlyCleared=!0,this.atomic&&this.doc.cantEdit&&(this.doc.cantEdit=!1,t&&Ci(t.doc)),t&&bt(t,"markerCleared",t,this,i,o),r&&on(t),this.parent&&this.parent.clear()}},Os.prototype.find=function(e,t){var r=this;null==e&&"bookmark"==this.type&&(e=1);for(var n,i,o=0;o<this.lines.length;++o){var l=r.lines[o],s=_(l.markedSpans,r);if(null!=s.from&&(n=E(t?l:W(l),s.from),-1==e))return n;if(null!=s.to&&(i=E(t?l:W(l),s.to),1==e))return i}return n&&{from:n,to:i}},Os.prototype.changed=function(){var e=this,t=this.find(-1,!0),r=this,n=this.doc.cm;t&&n&&hn(n,function(){var i=t.line,o=W(t.line),l=jt(n,o);if(l&&(Qt(l),n.curOp.selectionChanged=n.curOp.forceUpdate=!0),n.curOp.updateMaxLine=!0,!ve(r.doc,i)&&null!=r.height){var s=r.height;r.height=null;var a=Ht(r)-s;a&&A(i,i.height+a)}bt(n,"markerChanged",n,e)})},Os.prototype.attachLine=function(e){if(!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;t.maybeHiddenMarkers&&-1!=h(t.maybeHiddenMarkers,this)||(t.maybeUnhiddenMarkers||(t.maybeUnhiddenMarkers=[])).push(this)}this.lines.push(e)},Os.prototype.detachLine=function(e){if(this.lines.splice(h(this.lines,e),1),!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;(t.maybeHiddenMarkers||(t.maybeHiddenMarkers=[])).push(this)}},Ae(Os);var As=function(e,t){var r=this;this.markers=e,this.primary=t;for(var n=0;n<e.length;++n)e[n].parent=r};As.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){this.explicitlyCleared=!0;for(var t=0;t<this.markers.length;++t)e.markers[t].clear();bt(this,"clear")}},As.prototype.find=function(e,t){return this.primary.find(e,t)},Ae(As);var Ws=0,Ds=function(e,t,r,n,i){if(!(this instanceof Ds))return new Ds(e,t,r,n,i);null==r&&(r=0),Gi.call(this,[new Bi([new fs("",null)])]),this.first=r,this.scrollTop=this.scrollLeft=0,this.cantEdit=!1,this.cleanGeneration=1,this.modeFrontier=this.highlightFrontier=r;var o=E(r,0);this.sel=Rn(o),this.history=new Jn(null),this.id=++Ws,this.modeOption=t,this.lineSep=n,this.direction="rtl"==i?"rtl":"ltr",this.extend=!1,"string"==typeof e&&(e=this.splitLines(e)),_n(this,{from:o,to:o,text:e}),bi(this,Rn(o),Gl)};Ds.prototype=b(Gi.prototype,{constructor:Ds,iter:function(e,t,r){r?this.iterN(e-this.first,t-e,r):this.iterN(this.first,this.first+this.size,e)},insert:function(e,t){for(var r=0,n=0;n<t.length;++n)r+=t[n].height;this.insertInner(e-this.first,t,r)},remove:function(e,t){this.removeInner(e-this.first,t)},getValue:function(e){var t=O(this,this.first,this.first+this.size);return!1===e?t:t.join(e||this.lineSeparator())},setValue:gn(function(e){var t=E(this.first,0),r=this.first+this.size-1;Oi(this,{from:t,to:E(r,M(this,r).text.length),text:this.splitLines(e),origin:"setValue",full:!0},!0),this.cm&&Xr(this.cm,0,0),bi(this,Rn(t),Gl)}),replaceRange:function(e,t,r,n){Ei(this,e,t=U(this,t),r=r?U(this,r):t,n)},getRange:function(e,t,r){var n=N(this,U(this,e),U(this,t));return!1===r?n:n.join(r||this.lineSeparator())},getLine:function(e){var t=this.getLineHandle(e);return t&&t.text},getLineHandle:function(e){if(H(this,e))return M(this,e)},getLineNumber:function(e){return W(e)},getLineHandleVisualStart:function(e){return"number"==typeof e&&(e=M(this,e)),fe(e)},lineCount:function(){return this.size},firstLine:function(){return this.first},lastLine:function(){return this.first+this.size-1},clipPos:function(e){return U(this,e)},getCursor:function(e){var t=this.sel.primary();return null==e||"head"==e?t.head:"anchor"==e?t.anchor:"end"==e||"to"==e||!1===e?t.to():t.from()},listSelections:function(){return this.sel.ranges},somethingSelected:function(){return this.sel.somethingSelected()},setCursor:gn(function(e,t,r){vi(this,U(this,"number"==typeof e?E(e,t||0):e),null,r)}),setSelection:gn(function(e,t,r){vi(this,U(this,e),U(this,t||e),r)}),extendSelection:gn(function(e,t,r){di(this,U(this,e),t&&U(this,t),r)}),extendSelections:gn(function(e,t){pi(this,K(this,e),t)}),extendSelectionsBy:gn(function(e,t){pi(this,K(this,v(this.sel.ranges,e)),t)}),setSelections:gn(function(e,t,r){var n=this;if(e.length){for(var i=[],o=0;o<e.length;o++)i[o]=new Ts(U(n,e[o].anchor),U(n,e[o].head));null==t&&(t=Math.min(e.length-1,this.sel.primIndex)),bi(this,zn(i,t),r)}}),addSelection:gn(function(e,t,r){var n=this.sel.ranges.slice(0);n.push(new Ts(U(this,e),U(this,t||e))),bi(this,zn(n,n.length-1),r)}),getSelection:function(e){for(var t,r=this,n=this.sel.ranges,i=0;i<n.length;i++){var o=N(r,n[i].from(),n[i].to());t=t?t.concat(o):o}return!1===e?t:t.join(e||this.lineSeparator())},getSelections:function(e){for(var t=this,r=[],n=this.sel.ranges,i=0;i<n.length;i++){var o=N(t,n[i].from(),n[i].to());!1!==e&&(o=o.join(e||t.lineSeparator())),r[i]=o}return r},replaceSelection:function(e,t,r){for(var n=[],i=0;i<this.sel.ranges.length;i++)n[i]=e;this.replaceSelections(n,t,r||"+input")},replaceSelections:gn(function(e,t,r){for(var n=this,i=[],o=this.sel,l=0;l<o.ranges.length;l++){var s=o.ranges[l];i[l]={from:s.from(),to:s.to(),text:n.splitLines(e[l]),origin:r}}for(var a=t&&"end"!=t&&Kn(this,i,t),u=i.length-1;u>=0;u--)Oi(n,i[u]);a?yi(this,a):this.cm&&jr(this.cm)}),undo:gn(function(){Wi(this,"undo")}),redo:gn(function(){Wi(this,"redo")}),undoSelection:gn(function(){Wi(this,"undo",!0)}),redoSelection:gn(function(){Wi(this,"redo",!0)}),setExtending:function(e){this.extend=e},getExtending:function(){return this.extend},historySize:function(){for(var e=this.history,t=0,r=0,n=0;n<e.done.length;n++)e.done[n].ranges||++t;for(var i=0;i<e.undone.length;i++)e.undone[i].ranges||++r;return{undo:t,redo:r}},clearHistory:function(){this.history=new Jn(this.history.maxGeneration)},markClean:function(){this.cleanGeneration=this.changeGeneration(!0)},changeGeneration:function(e){return e&&(this.history.lastOp=this.history.lastSelOp=this.history.lastOrigin=null),this.history.generation},isClean:function(e){return this.history.generation==(e||this.cleanGeneration)},getHistory:function(){return{done:fi(this.history.done),undone:fi(this.history.undone)}},setHistory:function(e){var t=this.history=new Jn(this.history.maxGeneration);t.done=fi(e.done.slice(0),null,!0),t.undone=fi(e.undone.slice(0),null,!0)},setGutterMarker:gn(function(e,t,r){return Ri(this,e,"gutter",function(e){var n=e.gutterMarkers||(e.gutterMarkers={});return n[t]=r,!r&&C(n)&&(e.gutterMarkers=null),!0})}),clearGutter:gn(function(e){var t=this;this.iter(function(r){r.gutterMarkers&&r.gutterMarkers[e]&&Ri(t,r,"gutter",function(){return r.gutterMarkers[e]=null,C(r.gutterMarkers)&&(r.gutterMarkers=null),!0})})}),lineInfo:function(e){var t;if("number"==typeof e){if(!H(this,e))return null;if(t=e,!(e=M(this,e)))return null}else if(null==(t=W(e)))return null;return{line:t,handle:e,text:e.text,gutterMarkers:e.gutterMarkers,textClass:e.textClass,bgClass:e.bgClass,wrapClass:e.wrapClass,widgets:e.widgets}},addLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass";if(t[i]){if(e(n).test(t[i]))return!1;t[i]+=" "+n}else t[i]=n;return!0})}),removeLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass",o=t[i];if(!o)return!1;if(null==n)t[i]=null;else{var l=o.match(e(n));if(!l)return!1;var s=l.index+l[0].length;t[i]=o.slice(0,l.index)+(l.index&&s!=o.length?" ":"")+o.slice(s)||null}return!0})}),addLineWidget:gn(function(e,t,r){return Vi(this,e,t,r)}),removeLineWidget:function(e){e.clear()},markText:function(e,t,r){return Ki(this,U(this,e),U(this,t),r,r&&r.type||"range")},setBookmark:function(e,t){var r={replacedWith:t&&(null==t.nodeType?t.widget:t),insertLeft:t&&t.insertLeft,clearWhenEmpty:!1,shared:t&&t.shared,handleMouseEvents:t&&t.handleMouseEvents};return e=U(this,e),Ki(this,e,e,r,"bookmark")},findMarksAt:function(e){var t=[],r=M(this,(e=U(this,e)).line).markedSpans;if(r)for(var n=0;n<r.length;++n){var i=r[n];(null==i.from||i.from<=e.ch)&&(null==i.to||i.to>=e.ch)&&t.push(i.marker.parent||i.marker)}return t},findMarks:function(e,t,r){e=U(this,e),t=U(this,t);var n=[],i=e.line;return this.iter(e.line,t.line+1,function(o){var l=o.markedSpans;if(l)for(var s=0;s<l.length;s++){var a=l[s];null!=a.to&&i==e.line&&e.ch>=a.to||null==a.from&&i!=e.line||null!=a.from&&i==t.line&&a.from>=t.ch||r&&!r(a.marker)||n.push(a.marker.parent||a.marker)}++i}),n},getAllMarks:function(){var e=[];return this.iter(function(t){var r=t.markedSpans;if(r)for(var n=0;n<r.length;++n)null!=r[n].from&&e.push(r[n].marker)}),e},posFromIndex:function(e){var t,r=this.first,n=this.lineSeparator().length;return this.iter(function(i){var o=i.text.length+n;if(o>e)return t=e,!0;e-=o,++r}),U(this,E(r,t))},indexFromPos:function(e){var t=(e=U(this,e)).ch;if(e.line<this.first||e.ch<0)return 0;var r=this.lineSeparator().length;return this.iter(this.first,e.line,function(e){t+=e.text.length+r}),t},copy:function(e){var t=new Ds(O(this,this.first,this.first+this.size),this.modeOption,this.first,this.lineSep,this.direction);return t.scrollTop=this.scrollTop,t.scrollLeft=this.scrollLeft,t.sel=this.sel,t.extend=!1,e&&(t.history.undoDepth=this.history.undoDepth,t.setHistory(this.getHistory())),t},linkedDoc:function(e){e||(e={});var t=this.first,r=this.first+this.size;null!=e.from&&e.from>t&&(t=e.from),null!=e.to&&e.to<r&&(r=e.to);var n=new Ds(O(this,t,r),e.mode||this.modeOption,t,this.lineSep,this.direction);return e.sharedHist&&(n.history=this.history),(this.linked||(this.linked=[])).push({doc:n,sharedHist:e.sharedHist}),n.linked=[{doc:this,isParent:!0,sharedHist:e.sharedHist}],Yi(n,Xi(this)),n},unlinkDoc:function(e){var t=this;if(e instanceof jo&&(e=e.doc),this.linked)for(var r=0;r<this.linked.length;++r)if(t.linked[r].doc==e){t.linked.splice(r,1),e.unlinkDoc(t),_i(Xi(t));break}if(e.history==this.history){var n=[e.id];$n(e,function(e){return n.push(e.id)},!0),e.history=new Jn(null),e.history.done=fi(this.history.done,n),e.history.undone=fi(this.history.undone,n)}},iterLinkedDocs:function(e){$n(this,e)},getMode:function(){return this.mode},getEditor:function(){return this.cm},splitLines:function(e){return this.lineSep?e.split(this.lineSep):es(e)},lineSeparator:function(){return this.lineSep||"\n"},setDirection:gn(function(e){"rtl"!=e&&(e="ltr"),e!=this.direction&&(this.direction=e,this.iter(function(e){return e.order=null}),this.cm&&Qn(this.cm))})}),Ds.prototype.eachLine=Ds.prototype.iter;for(var Hs=0,Fs=!1,Es={3:"Enter",8:"Backspace",9:"Tab",13:"Enter",16:"Shift",17:"Ctrl",18:"Alt",19:"Pause",20:"CapsLock",27:"Esc",32:"Space",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"Left",38:"Up",39:"Right",40:"Down",44:"PrintScrn",45:"Insert",46:"Delete",59:";",61:"=",91:"Mod",92:"Mod",93:"Mod",106:"*",107:"=",109:"-",110:".",111:"/",127:"Delete",173:"-",186:";",187:"=",188:",",189:"-",190:".",191:"/",192:"`",219:"[",220:"\\",221:"]",222:"'",63232:"Up",63233:"Down",63234:"Left",63235:"Right",63272:"Delete",63273:"Home",63275:"End",63276:"PageUp",63277:"PageDown",63302:"Insert"},Ps=0;Ps<10;Ps++)Es[Ps+48]=Es[Ps+96]=String(Ps);for(var Is=65;Is<=90;Is++)Es[Is]=String.fromCharCode(Is);for(var zs=1;zs<=12;zs++)Es[zs+111]=Es[zs+63235]="F"+zs;var Rs={};Rs.basic={Left:"goCharLeft",Right:"goCharRight",Up:"goLineUp",Down:"goLineDown",End:"goLineEnd",Home:"goLineStartSmart",PageUp:"goPageUp",PageDown:"goPageDown",Delete:"delCharAfter",Backspace:"delCharBefore","Shift-Backspace":"delCharBefore",Tab:"defaultTab","Shift-Tab":"indentAuto",Enter:"newlineAndIndent",Insert:"toggleOverwrite",Esc:"singleSelection"},Rs.pcDefault={"Ctrl-A":"selectAll","Ctrl-D":"deleteLine","Ctrl-Z":"undo","Shift-Ctrl-Z":"redo","Ctrl-Y":"redo","Ctrl-Home":"goDocStart","Ctrl-End":"goDocEnd","Ctrl-Up":"goLineUp","Ctrl-Down":"goLineDown","Ctrl-Left":"goGroupLeft","Ctrl-Right":"goGroupRight","Alt-Left":"goLineStart","Alt-Right":"goLineEnd","Ctrl-Backspace":"delGroupBefore","Ctrl-Delete":"delGroupAfter","Ctrl-S":"save","Ctrl-F":"find","Ctrl-G":"findNext","Shift-Ctrl-G":"findPrev","Shift-Ctrl-F":"replace","Shift-Ctrl-R":"replaceAll","Ctrl-[":"indentLess","Ctrl-]":"indentMore","Ctrl-U":"undoSelection","Shift-Ctrl-U":"redoSelection","Alt-U":"redoSelection",fallthrough:"basic"},Rs.emacsy={"Ctrl-F":"goCharRight","Ctrl-B":"goCharLeft","Ctrl-P":"goLineUp","Ctrl-N":"goLineDown","Alt-F":"goWordRight","Alt-B":"goWordLeft","Ctrl-A":"goLineStart","Ctrl-E":"goLineEnd","Ctrl-V":"goPageDown","Shift-Ctrl-V":"goPageUp","Ctrl-D":"delCharAfter","Ctrl-H":"delCharBefore","Alt-D":"delWordAfter","Alt-Backspace":"delWordBefore","Ctrl-K":"killLine","Ctrl-T":"transposeChars","Ctrl-O":"openLine"},Rs.macDefault={"Cmd-A":"selectAll","Cmd-D":"deleteLine","Cmd-Z":"undo","Shift-Cmd-Z":"redo","Cmd-Y":"redo","Cmd-Home":"goDocStart","Cmd-Up":"goDocStart","Cmd-End":"goDocEnd","Cmd-Down":"goDocEnd","Alt-Left":"goGroupLeft","Alt-Right":"goGroupRight","Cmd-Left":"goLineLeft","Cmd-Right":"goLineRight","Alt-Backspace":"delGroupBefore","Ctrl-Alt-Backspace":"delGroupAfter","Alt-Delete":"delGroupAfter","Cmd-S":"save","Cmd-F":"find","Cmd-G":"findNext","Shift-Cmd-G":"findPrev","Cmd-Alt-F":"replace","Shift-Cmd-Alt-F":"replaceAll","Cmd-[":"indentLess","Cmd-]":"indentMore","Cmd-Backspace":"delWrappedLineLeft","Cmd-Delete":"delWrappedLineRight","Cmd-U":"undoSelection","Shift-Cmd-U":"redoSelection","Ctrl-Up":"goDocStart","Ctrl-Down":"goDocEnd",fallthrough:["basic","emacsy"]},Rs.default=Ml?Rs.macDefault:Rs.pcDefault;var Bs={selectAll:Mi,singleSelection:function(e){return e.setSelection(e.getCursor("anchor"),e.getCursor("head"),Gl)},killLine:function(e){return co(e,function(t){if(t.empty()){var r=M(e.doc,t.head.line).text.length;return t.head.ch==r&&t.head.line<e.lastLine()?{from:t.head,to:E(t.head.line+1,0)}:{from:t.head,to:E(t.head.line,r)}}return{from:t.from(),to:t.to()}})},deleteLine:function(e){return co(e,function(t){return{from:E(t.from().line,0),to:U(e.doc,E(t.to().line+1,0))}})},delLineLeft:function(e){return co(e,function(e){return{from:E(e.from().line,0),to:e.from()}})},delWrappedLineLeft:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5;return{from:e.coordsChar({left:0,top:r},"div"),to:t.from()}})},delWrappedLineRight:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5,n=e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div");return{from:t.from(),to:n}})},undo:function(e){return e.undo()},redo:function(e){return e.redo()},undoSelection:function(e){return e.undoSelection()},redoSelection:function(e){return e.redoSelection()},goDocStart:function(e){return e.extendSelection(E(e.firstLine(),0))},goDocEnd:function(e){return e.extendSelection(E(e.lastLine()))},goLineStart:function(e){return e.extendSelectionsBy(function(t){return vo(e,t.head.line)},{origin:"+move",bias:1})},goLineStartSmart:function(e){return e.extendSelectionsBy(function(t){return yo(e,t.head)},{origin:"+move",bias:1})},goLineEnd:function(e){return e.extendSelectionsBy(function(t){return mo(e,t.head.line)},{origin:"+move",bias:-1})},goLineRight:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div")},Vl)},goLineLeft:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:0,top:r},"div")},Vl)},goLineLeftSmart:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5,n=e.coordsChar({left:0,top:r},"div");return n.ch<e.getLine(n.line).search(/\S/)?yo(e,t.head):n},Vl)},goLineUp:function(e){return e.moveV(-1,"line")},goLineDown:function(e){return e.moveV(1,"line")},goPageUp:function(e){return e.moveV(-1,"page")},goPageDown:function(e){return e.moveV(1,"page")},goCharLeft:function(e){return e.moveH(-1,"char")},goCharRight:function(e){return e.moveH(1,"char")},goColumnLeft:function(e){return e.moveH(-1,"column")},goColumnRight:function(e){return e.moveH(1,"column")},goWordLeft:function(e){return e.moveH(-1,"word")},goGroupRight:function(e){return e.moveH(1,"group")},goGroupLeft:function(e){return e.moveH(-1,"group")},goWordRight:function(e){return e.moveH(1,"word")},delCharBefore:function(e){return e.deleteH(-1,"char")},delCharAfter:function(e){return e.deleteH(1,"char")},delWordBefore:function(e){return e.deleteH(-1,"word")},delWordAfter:function(e){return e.deleteH(1,"word")},delGroupBefore:function(e){return e.deleteH(-1,"group")},delGroupAfter:function(e){return e.deleteH(1,"group")},indentAuto:function(e){return e.indentSelection("smart")},indentMore:function(e){return e.indentSelection("add")},indentLess:function(e){return e.indentSelection("subtract")},insertTab:function(e){return e.replaceSelection("\t")},insertSoftTab:function(e){for(var t=[],r=e.listSelections(),n=e.options.tabSize,i=0;i<r.length;i++){var o=r[i].from(),l=f(e.getLine(o.line),o.ch,n);t.push(p(n-l%n))}e.replaceSelections(t)},defaultTab:function(e){e.somethingSelected()?e.indentSelection("add"):e.execCommand("insertTab")},transposeChars:function(e){return hn(e,function(){for(var t=e.listSelections(),r=[],n=0;n<t.length;n++)if(t[n].empty()){var i=t[n].head,o=M(e.doc,i.line).text;if(o)if(i.ch==o.length&&(i=new E(i.line,i.ch-1)),i.ch>0)i=new E(i.line,i.ch+1),e.replaceRange(o.charAt(i.ch-1)+o.charAt(i.ch-2),E(i.line,i.ch-2),i,"+transpose");else if(i.line>e.doc.first){var l=M(e.doc,i.line-1).text;l&&(i=new E(i.line,1),e.replaceRange(o.charAt(0)+e.doc.lineSeparator()+l.charAt(l.length-1),E(i.line-1,l.length-1),i,"+transpose"))}r.push(new Ts(i,i))}e.setSelections(r)})},newlineAndIndent:function(e){return hn(e,function(){for(var t=e.listSelections(),r=t.length-1;r>=0;r--)e.replaceRange(e.doc.lineSeparator(),t[r].anchor,t[r].head,"+input");t=e.listSelections();for(var n=0;n<t.length;n++)e.indentLine(t[n].from().line,null,!0);jr(e)})},openLine:function(e){return e.replaceSelection("\n","start")},toggleOverwrite:function(e){return e.toggleOverwrite()}},Gs=new Pl,Us=null,Vs=function(e,t,r){this.time=e,this.pos=t,this.button=r};Vs.prototype.compare=function(e,t,r){return this.time+400>e&&0==P(t,this.pos)&&r==this.button};var Ks,js,Xs={toString:function(){return"CodeMirror.Init"}},Ys={},_s={};jo.defaults=Ys,jo.optionHandlers=_s;var $s=[];jo.defineInitHook=function(e){return $s.push(e)};var qs=null,Zs=function(e){this.cm=e,this.lastAnchorNode=this.lastAnchorOffset=this.lastFocusNode=this.lastFocusOffset=null,this.polling=new Pl,this.composing=null,this.gracePeriod=!1,this.readDOMTimeout=null};Zs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()}),"cut"==e.type&&i.replaceSelection("",null,"cut");else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type&&i.operation(function(){i.setSelections(t.ranges,0,Gl),i.replaceSelection("",null,"cut")})}if(e.clipboardData){e.clipboardData.clearData();var r=qs.text.join("\n");if(e.clipboardData.setData("Text",r),e.clipboardData.getData("Text")==r)return void e.preventDefault()}var l=el(),s=l.firstChild;i.display.lineSpace.insertBefore(l,i.display.lineSpace.firstChild),s.value=qs.text.join("\n");var a=document.activeElement;El(s),setTimeout(function(){i.display.lineSpace.removeChild(l),a.focus(),a==o&&n.showPrimarySelection()},50)}}var r=this,n=this,i=n.cm,o=n.div=e.lineDiv;Jo(o,i.options.spellcheck),Ql(o,"paste",function(e){Me(i,e)||qo(e,i)||vl<=11&&setTimeout(dn(i,function(){return r.updateFromDOM()}),20)}),Ql(o,"compositionstart",function(e){r.composing={data:e.data,done:!1}}),Ql(o,"compositionupdate",function(e){r.composing||(r.composing={data:e.data,done:!1})}),Ql(o,"compositionend",function(e){r.composing&&(e.data!=r.composing.data&&r.readFromDOMSoon(),r.composing.done=!0)}),Ql(o,"touchstart",function(){return n.forceCompositionEnd()}),Ql(o,"input",function(){r.composing||r.readFromDOMSoon()}),Ql(o,"copy",t),Ql(o,"cut",t)},Zs.prototype.prepareSelection=function(){var e=Tr(this.cm,!1);return e.focus=this.cm.state.focused,e},Zs.prototype.showSelection=function(e,t){e&&this.cm.display.view.length&&((e.focus||t)&&this.showPrimarySelection(),this.showMultipleSelections(e))},Zs.prototype.showPrimarySelection=function(){var e=window.getSelection(),t=this.cm,r=t.doc.sel.primary(),n=r.from(),i=r.to();if(t.display.viewTo==t.display.viewFrom||n.line>=t.display.viewTo||i.line<t.display.viewFrom)e.removeAllRanges();else{var o=sl(t,e.anchorNode,e.anchorOffset),l=sl(t,e.focusNode,e.focusOffset);if(!o||o.bad||!l||l.bad||0!=P(B(o,l),n)||0!=P(R(o,l),i)){var s=t.display.view,a=n.line>=t.display.viewFrom&&nl(t,n)||{node:s[0].measure.map[2],offset:0},u=i.line<t.display.viewTo&&nl(t,i);if(!u){var c=s[s.length-1].measure,f=c.maps?c.maps[c.maps.length-1]:c.map;u={node:f[f.length-1],offset:f[f.length-2]-f[f.length-3]}}if(a&&u){var h,d=e.rangeCount&&e.getRangeAt(0);try{h=Wl(a.node,a.offset,u.offset,u.node)}catch(e){}h&&(!fl&&t.state.focused?(e.collapse(a.node,a.offset),h.collapsed||(e.removeAllRanges(),e.addRange(h))):(e.removeAllRanges(),e.addRange(h)),d&&null==e.anchorNode?e.addRange(d):fl&&this.startGracePeriod()),this.rememberSelection()}else e.removeAllRanges()}}},Zs.prototype.startGracePeriod=function(){var e=this;clearTimeout(this.gracePeriod),this.gracePeriod=setTimeout(function(){e.gracePeriod=!1,e.selectionChanged()&&e.cm.operation(function(){return e.cm.curOp.selectionChanged=!0})},20)},Zs.prototype.showMultipleSelections=function(e){r(this.cm.display.cursorDiv,e.cursors),r(this.cm.display.selectionDiv,e.selection)},Zs.prototype.rememberSelection=function(){var e=window.getSelection();this.lastAnchorNode=e.anchorNode,this.lastAnchorOffset=e.anchorOffset,this.lastFocusNode=e.focusNode,this.lastFocusOffset=e.focusOffset},Zs.prototype.selectionInEditor=function(){var e=window.getSelection();if(!e.rangeCount)return!1;var t=e.getRangeAt(0).commonAncestorContainer;return o(this.div,t)},Zs.prototype.focus=function(){"nocursor"!=this.cm.options.readOnly&&(this.selectionInEditor()||this.showSelection(this.prepareSelection(),!0),this.div.focus())},Zs.prototype.blur=function(){this.div.blur()},Zs.prototype.getField=function(){return this.div},Zs.prototype.supportsTouch=function(){return!0},Zs.prototype.receivedFocus=function(){function e(){t.cm.state.focused&&(t.pollSelection(),t.polling.set(t.cm.options.pollInterval,e))}var t=this;this.selectionInEditor()?this.pollSelection():hn(this.cm,function(){return t.cm.curOp.selectionChanged=!0}),this.polling.set(this.cm.options.pollInterval,e)},Zs.prototype.selectionChanged=function(){var e=window.getSelection();return e.anchorNode!=this.lastAnchorNode||e.anchorOffset!=this.lastAnchorOffset||e.focusNode!=this.lastFocusNode||e.focusOffset!=this.lastFocusOffset},Zs.prototype.pollSelection=function(){if(null==this.readDOMTimeout&&!this.gracePeriod&&this.selectionChanged()){var e=window.getSelection(),t=this.cm;if(kl&&bl&&this.cm.options.gutters.length&&il(e.anchorNode))return this.cm.triggerOnKeyDown({type:"keydown",keyCode:8,preventDefault:Math.abs}),this.blur(),void this.focus();if(!this.composing){this.rememberSelection();var r=sl(t,e.anchorNode,e.anchorOffset),n=sl(t,e.focusNode,e.focusOffset);r&&n&&hn(t,function(){bi(t.doc,Rn(r,n),Gl),(r.bad||n.bad)&&(t.curOp.selectionChanged=!0)})}}},Zs.prototype.pollContent=function(){null!=this.readDOMTimeout&&(clearTimeout(this.readDOMTimeout),this.readDOMTimeout=null);var e=this.cm,t=e.display,r=e.doc.sel.primary(),n=r.from(),i=r.to();if(0==n.ch&&n.line>e.firstLine()&&(n=E(n.line-1,M(e.doc,n.line-1).length)),i.ch==M(e.doc,i.line).text.length&&i.line<e.lastLine()&&(i=E(i.line+1,0)),n.line<t.viewFrom||i.line>t.viewTo-1)return!1;var o,l,s;n.line==t.viewFrom||0==(o=Lr(e,n.line))?(l=W(t.view[0].line),s=t.view[0].node):(l=W(t.view[o].line),s=t.view[o-1].node.nextSibling);var a,u,c=Lr(e,i.line);if(c==t.view.length-1?(a=t.viewTo-1,u=t.lineDiv.lastChild):(a=W(t.view[c+1].line)-1,u=t.view[c+1].node.previousSibling),!s)return!1;for(var f=e.doc.splitLines(ll(e,s,u,l,a)),h=N(e.doc,E(l,0),E(a,M(e.doc,a).text.length));f.length>1&&h.length>1;)if(g(f)==g(h))f.pop(),h.pop(),a--;else{if(f[0]!=h[0])break;f.shift(),h.shift(),l++}for(var d=0,p=0,v=f[0],m=h[0],y=Math.min(v.length,m.length);d<y&&v.charCodeAt(d)==m.charCodeAt(d);)++d;for(var b=g(f),w=g(h),x=Math.min(b.length-(1==f.length?d:0),w.length-(1==h.length?d:0));p<x&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)++p;if(1==f.length&&1==h.length&&l==n.line)for(;d&&d>n.ch&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)d--,p++;f[f.length-1]=b.slice(0,b.length-p).replace(/^\u200b+/,""),f[0]=f[0].slice(d).replace(/\u200b+$/,"");var C=E(l,d),S=E(a,h.length?g(h).length-p:0);return f.length>1||f[0]||P(C,S)?(Ei(e.doc,f,C,S,"+input"),!0):void 0},Zs.prototype.ensurePolled=function(){this.forceCompositionEnd()},Zs.prototype.reset=function(){this.forceCompositionEnd()},Zs.prototype.forceCompositionEnd=function(){this.composing&&(clearTimeout(this.readDOMTimeout),this.composing=null,this.updateFromDOM(),this.div.blur(),this.div.focus())},Zs.prototype.readFromDOMSoon=function(){var e=this;null==this.readDOMTimeout&&(this.readDOMTimeout=setTimeout(function(){if(e.readDOMTimeout=null,e.composing){if(!e.composing.done)return;e.composing=null}e.updateFromDOM()},80))},Zs.prototype.updateFromDOM=function(){var e=this;!this.cm.isReadOnly()&&this.pollContent()||hn(this.cm,function(){return vn(e.cm)})},Zs.prototype.setUneditable=function(e){e.contentEditable="false"},Zs.prototype.onKeyPress=function(e){0!=e.charCode&&(e.preventDefault(),this.cm.isReadOnly()||dn(this.cm,$o)(this.cm,String.fromCharCode(null==e.charCode?e.keyCode:e.charCode),0))},Zs.prototype.readOnlyChanged=function(e){this.div.contentEditable=String("nocursor"!=e)},Zs.prototype.onContextMenu=function(){},Zs.prototype.resetPosition=function(){},Zs.prototype.needsContentAttribute=!0;var Qs=function(e){this.cm=e,this.prevInput="",this.pollingFast=!1,this.polling=new Pl,this.hasSelection=!1,this.composing=null};Qs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()});else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type?i.setSelections(t.ranges,null,Gl):(n.prevInput="",l.value=t.text.join("\n"),El(l))}"cut"==e.type&&(i.state.cutIncoming=!0)}}var r=this,n=this,i=this.cm,o=this.wrapper=el(),l=this.textarea=o.firstChild;e.wrapper.insertBefore(o,e.wrapper.firstChild),Ll&&(l.style.width="0px"),Ql(l,"input",function(){gl&&vl>=9&&r.hasSelection&&(r.hasSelection=null),n.poll()}),Ql(l,"paste",function(e){Me(i,e)||qo(e,i)||(i.state.pasteIncoming=!0,n.fastPoll())}),Ql(l,"cut",t),Ql(l,"copy",t),Ql(e.scroller,"paste",function(t){Ft(e,t)||Me(i,t)||(i.state.pasteIncoming=!0,n.focus())}),Ql(e.lineSpace,"selectstart",function(t){Ft(e,t)||We(t)}),Ql(l,"compositionstart",function(){var e=i.getCursor("from");n.composing&&n.composing.range.clear(),n.composing={start:e,range:i.markText(e,i.getCursor("to"),{className:"CodeMirror-composing"})}}),Ql(l,"compositionend",function(){n.composing&&(n.poll(),n.composing.range.clear(),n.composing=null)})},Qs.prototype.prepareSelection=function(){var e=this.cm,t=e.display,r=e.doc,n=Tr(e);if(e.options.moveInputWithCursor){var i=sr(e,r.sel.primary().head,"div"),o=t.wrapper.getBoundingClientRect(),l=t.lineDiv.getBoundingClientRect();n.teTop=Math.max(0,Math.min(t.wrapper.clientHeight-10,i.top+l.top-o.top)),n.teLeft=Math.max(0,Math.min(t.wrapper.clientWidth-10,i.left+l.left-o.left))}return n},Qs.prototype.showSelection=function(e){var t=this.cm.display;r(t.cursorDiv,e.cursors),r(t.selectionDiv,e.selection),null!=e.teTop&&(this.wrapper.style.top=e.teTop+"px",this.wrapper.style.left=e.teLeft+"px")},Qs.prototype.reset=function(e){if(!this.contextMenuPending&&!this.composing){var t=this.cm;if(t.somethingSelected()){this.prevInput="";var r=t.getSelection();this.textarea.value=r,t.state.focused&&El(this.textarea),gl&&vl>=9&&(this.hasSelection=r)}else e||(this.prevInput=this.textarea.value="",gl&&vl>=9&&(this.hasSelection=null))}},Qs.prototype.getField=function(){return this.textarea},Qs.prototype.supportsTouch=function(){return!1},Qs.prototype.focus=function(){if("nocursor"!=this.cm.options.readOnly&&(!Tl||l()!=this.textarea))try{this.textarea.focus()}catch(e){}},Qs.prototype.blur=function(){this.textarea.blur()},Qs.prototype.resetPosition=function(){this.wrapper.style.top=this.wrapper.style.left=0},Qs.prototype.receivedFocus=function(){this.slowPoll()},Qs.prototype.slowPoll=function(){var e=this;this.pollingFast||this.polling.set(this.cm.options.pollInterval,function(){e.poll(),e.cm.state.focused&&e.slowPoll()})},Qs.prototype.fastPoll=function(){function e(){r.poll()||t?(r.pollingFast=!1,r.slowPoll()):(t=!0,r.polling.set(60,e))}var t=!1,r=this;r.pollingFast=!0,r.polling.set(20,e)},Qs.prototype.poll=function(){var e=this,t=this.cm,r=this.textarea,n=this.prevInput;if(this.contextMenuPending||!t.state.focused||ts(r)&&!n&&!this.composing||t.isReadOnly()||t.options.disableInput||t.state.keySeq)return!1;var i=r.value;if(i==n&&!t.somethingSelected())return!1;if(gl&&vl>=9&&this.hasSelection===i||Ml&&/[\uf700-\uf7ff]/.test(i))return t.display.input.reset(),!1;if(t.doc.sel==t.display.selForContextMenu){var o=i.charCodeAt(0);if(8203!=o||n||(n="​"),8666==o)return this.reset(),this.cm.execCommand("undo")}for(var l=0,s=Math.min(n.length,i.length);l<s&&n.charCodeAt(l)==i.charCodeAt(l);)++l;return hn(t,function(){$o(t,i.slice(l),n.length-l,null,e.composing?"*compose":null),i.length>1e3||i.indexOf("\n")>-1?r.value=e.prevInput="":e.prevInput=i,e.composing&&(e.composing.range.clear(),e.composing.range=t.markText(e.composing.start,t.getCursor("to"),{className:"CodeMirror-composing"}))}),!0},Qs.prototype.ensurePolled=function(){this.pollingFast&&this.poll()&&(this.pollingFast=!1)},Qs.prototype.onKeyPress=function(){gl&&vl>=9&&(this.hasSelection=null),this.fastPoll()},Qs.prototype.onContextMenu=function(e){function t(){if(null!=l.selectionStart){var e=i.somethingSelected(),t="​"+(e?l.value:"");l.value="⇚",l.value=t,n.prevInput=e?"":"​",l.selectionStart=1,l.selectionEnd=t.length,o.selForContextMenu=i.doc.sel}}function r(){if(n.contextMenuPending=!1,n.wrapper.style.cssText=c,l.style.cssText=u,gl&&vl<9&&o.scrollbars.setScrollTop(o.scroller.scrollTop=a),null!=l.selectionStart){(!gl||gl&&vl<9)&&t();var e=0,r=function(){o.selForContextMenu==i.doc.sel&&0==l.selectionStart&&l.selectionEnd>0&&"​"==n.prevInput?dn(i,Mi)(i):e++<10?o.detectingSelectAll=setTimeout(r,500):(o.selForContextMenu=null,o.input.reset())};o.detectingSelectAll=setTimeout(r,200)}}var n=this,i=n.cm,o=i.display,l=n.textarea,s=Sr(i,e),a=o.scroller.scrollTop;if(s&&!wl){i.options.resetSelectionOnContextMenu&&-1==i.doc.sel.contains(s)&&dn(i,bi)(i.doc,Rn(s),Gl);var u=l.style.cssText,c=n.wrapper.style.cssText;n.wrapper.style.cssText="position: absolute";var f=n.wrapper.getBoundingClientRect();l.style.cssText="position: absolute; width: 30px; height: 30px;\n      top: "+(e.clientY-f.top-5)+"px; left: "+(e.clientX-f.left-5)+"px;\n      z-index: 1000; background: "+(gl?"rgba(255, 255, 255, .05)":"transparent")+";\n      outline: none; border-width: 0; outline: none; overflow: hidden; opacity: .05; filter: alpha(opacity=5);";var h;if(ml&&(h=window.scrollY),o.input.focus(),ml&&window.scrollTo(null,h),o.input.reset(),i.somethingSelected()||(l.value=n.prevInput=" "),n.contextMenuPending=!0,o.selForContextMenu=i.doc.sel,clearTimeout(o.detectingSelectAll),gl&&vl>=9&&t(),Hl){Fe(e);var d=function(){ke(window,"mouseup",d),setTimeout(r,20)};Ql(window,"mouseup",d)}else setTimeout(r,50)}},Qs.prototype.readOnlyChanged=function(e){e||this.reset(),this.textarea.disabled="nocursor"==e},Qs.prototype.setUneditable=function(){},Qs.prototype.needsContentAttribute=!1,function(e){function t(t,n,i,o){e.defaults[t]=n,i&&(r[t]=o?function(e,t,r){r!=Xs&&i(e,t,r)}:i)}var r=e.optionHandlers;e.defineOption=t,e.Init=Xs,t("value","",function(e,t){return e.setValue(t)},!0),t("mode",null,function(e,t){e.doc.modeOption=t,jn(e)},!0),t("indentUnit",2,jn,!0),t("indentWithTabs",!1),t("smartIndent",!0),t("tabSize",4,function(e){Xn(e),er(e),vn(e)},!0),t("lineSeparator",null,function(e,t){if(e.doc.lineSep=t,t){var r=[],n=e.doc.first;e.doc.iter(function(e){for(var i=0;;){var o=e.text.indexOf(t,i);if(-1==o)break;i=o+t.length,r.push(E(n,o))}n++});for(var i=r.length-1;i>=0;i--)Ei(e.doc,t,r[i],E(r[i].line,r[i].ch+t.length))}}),t("specialChars",/[\u0000-\u001f\u007f-\u009f\u00ad\u061c\u200b-\u200f\u2028\u2029\ufeff]/g,function(e,t,r){e.state.specialChars=new RegExp(t.source+(t.test("\t")?"":"|\t"),"g"),r!=Xs&&e.refresh()}),t("specialCharPlaceholder",at,function(e){return e.refresh()},!0),t("electricChars",!0),t("inputStyle",Tl?"contenteditable":"textarea",function(){throw new Error("inputStyle can not (yet) be changed in a running editor")},!0),t("spellcheck",!1,function(e,t){return e.getInputField().spellcheck=t},!0),t("rtlMoveVisually",!Ol),t("wholeLineUpdateBefore",!0),t("theme","default",function(e){Go(e),Uo(e)},!0),t("keyMap","default",function(e,t,r){var n=uo(t),i=r!=Xs&&uo(r);i&&i.detach&&i.detach(e,n),n.attach&&n.attach(e,i||null)}),t("extraKeys",null),t("configureMouse",null),t("lineWrapping",!1,Ko,!0),t("gutters",[],function(e){Fn(e.options),Uo(e)},!0),t("fixedGutter",!0,function(e,t){e.display.gutters.style.left=t?wr(e.display)+"px":"0",e.refresh()},!0),t("coverGutterNextToScrollbar",!1,function(e){return en(e)},!0),t("scrollbarStyle","native",function(e){rn(e),en(e),e.display.scrollbars.setScrollTop(e.doc.scrollTop),e.display.scrollbars.setScrollLeft(e.doc.scrollLeft)},!0),t("lineNumbers",!1,function(e){Fn(e.options),Uo(e)},!0),t("firstLineNumber",1,Uo,!0),t("lineNumberFormatter",function(e){return e},Uo,!0),t("showCursorWhenSelecting",!1,kr,!0),t("resetSelectionOnContextMenu",!0),t("lineWiseCopyCut",!0),t("pasteLinesPerSelection",!0),t("readOnly",!1,function(e,t){"nocursor"==t&&(Fr(e),e.display.input.blur()),e.display.input.readOnlyChanged(t)}),t("disableInput",!1,function(e,t){t||e.display.input.reset()},!0),t("dragDrop",!0,Vo),t("allowDropFileTypes",null),t("cursorBlinkRate",530),t("cursorScrollMargin",0),t("cursorHeight",1,kr,!0),t("singleCursorHeightPerLine",!0,kr,!0),t("workTime",100),t("workDelay",100),t("flattenSpans",!0,Xn,!0),t("addModeClass",!1,Xn,!0),t("pollInterval",100),t("undoDepth",200,function(e,t){return e.doc.history.undoDepth=t}),t("historyEventDelay",1250),t("viewportMargin",10,function(e){return e.refresh()},!0),t("maxHighlightLength",1e4,Xn,!0),t("moveInputWithCursor",!0,function(e,t){t||e.display.input.resetPosition()}),t("tabindex",null,function(e,t){return e.display.input.getField().tabIndex=t||""}),t("autofocus",null),t("direction","ltr",function(e,t){return e.doc.setDirection(t)},!0)}(jo),function(e){var t=e.optionHandlers,r=e.helpers={};e.prototype={constructor:e,focus:function(){window.focus(),this.display.input.focus()},setOption:function(e,r){var n=this.options,i=n[e];n[e]==r&&"mode"!=e||(n[e]=r,t.hasOwnProperty(e)&&dn(this,t[e])(this,r,i),Te(this,"optionChange",this,e))},getOption:function(e){return this.options[e]},getDoc:function(){return this.doc},addKeyMap:function(e,t){this.state.keyMaps[t?"push":"unshift"](uo(e))},removeKeyMap:function(e){for(var t=this.state.keyMaps,r=0;r<t.length;++r)if(t[r]==e||t[r].name==e)return t.splice(r,1),!0},addOverlay:pn(function(t,r){var n=t.token?t:e.getMode(this.options,t);if(n.startState)throw new Error("Overlays may not be stateful.");m(this.state.overlays,{mode:n,modeSpec:t,opaque:r&&r.opaque,priority:r&&r.priority||0},function(e){return e.priority}),this.state.modeGen++,vn(this)}),removeOverlay:pn(function(e){for(var t=this,r=this.state.overlays,n=0;n<r.length;++n){var i=r[n].modeSpec;if(i==e||"string"==typeof e&&i.name==e)return r.splice(n,1),t.state.modeGen++,void vn(t)}}),indentLine:pn(function(e,t,r){"string"!=typeof t&&"number"!=typeof t&&(t=null==t?this.options.smartIndent?"smart":"prev":t?"add":"subtract"),H(this.doc,e)&&Yo(this,e,t,r)}),indentSelection:pn(function(e){for(var t=this,r=this.doc.sel.ranges,n=-1,i=0;i<r.length;i++){var o=r[i];if(o.empty())o.head.line>n&&(Yo(t,o.head.line,e,!0),n=o.head.line,i==t.doc.sel.primIndex&&jr(t));else{var l=o.from(),s=o.to(),a=Math.max(n,l.line);n=Math.min(t.lastLine(),s.line-(s.ch?0:1))+1;for(var u=a;u<n;++u)Yo(t,u,e);var c=t.doc.sel.ranges;0==l.ch&&r.length==c.length&&c[i].from().ch>0&&gi(t.doc,i,new Ts(l,c[i].to()),Gl)}}}),getTokenAt:function(e,t){return Je(this,e,t)},getLineTokens:function(e,t){return Je(this,E(e),t,!0)},getTokenTypeAt:function(e){e=U(this.doc,e);var t,r=_e(this,M(this.doc,e.line)),n=0,i=(r.length-1)/2,o=e.ch;if(0==o)t=r[2];else for(;;){var l=n+i>>1;if((l?r[2*l-1]:0)>=o)i=l;else{if(!(r[2*l+1]<o)){t=r[2*l+2];break}n=l+1}}var s=t?t.indexOf("overlay "):-1;return s<0?t:0==s?null:t.slice(0,s-1)},getModeAt:function(t){var r=this.doc.mode;return r.innerMode?e.innerMode(r,this.getTokenAt(t).state).mode:r},getHelper:function(e,t){return this.getHelpers(e,t)[0]},getHelpers:function(e,t){var n=this,i=[];if(!r.hasOwnProperty(t))return i;var o=r[t],l=this.getModeAt(e);if("string"==typeof l[t])o[l[t]]&&i.push(o[l[t]]);else if(l[t])for(var s=0;s<l[t].length;s++){var a=o[l[t][s]];a&&i.push(a)}else l.helperType&&o[l.helperType]?i.push(o[l.helperType]):o[l.name]&&i.push(o[l.name]);for(var u=0;u<o._global.length;u++){var c=o._global[u];c.pred(l,n)&&-1==h(i,c.val)&&i.push(c.val)}return i},getStateAfter:function(e,t){var r=this.doc;return e=G(r,null==e?r.first+r.size-1:e),$e(this,e+1,t).state},cursorCoords:function(e,t){var r,n=this.doc.sel.primary();return r=null==e?n.head:"object"==typeof e?U(this.doc,e):e?n.from():n.to(),sr(this,r,t||"page")},charCoords:function(e,t){return lr(this,U(this.doc,e),t||"page")},coordsChar:function(e,t){return e=or(this,e,t||"page"),cr(this,e.left,e.top)},lineAtHeight:function(e,t){return e=or(this,{top:e,left:0},t||"page").top,D(this.doc,e+this.display.viewOffset)},heightAtLine:function(e,t,r){var n,i=!1;if("number"==typeof e){var o=this.doc.first+this.doc.size-1;e<this.doc.first?e=this.doc.first:e>o&&(e=o,i=!0),n=M(this.doc,e)}else n=e;return ir(this,n,{top:0,left:0},t||"page",r||i).top+(i?this.doc.height-ye(n):0)},defaultTextHeight:function(){return mr(this.display)},defaultCharWidth:function(){return yr(this.display)},getViewport:function(){return{from:this.display.viewFrom,to:this.display.viewTo}},addWidget:function(e,t,r,n,i){var o=this.display,l=(e=sr(this,U(this.doc,e))).bottom,s=e.left;if(t.style.position="absolute",t.setAttribute("cm-ignore-events","true"),this.display.input.setUneditable(t),o.sizer.appendChild(t),"over"==n)l=e.top;else if("above"==n||"near"==n){var a=Math.max(o.wrapper.clientHeight,this.doc.height),u=Math.max(o.sizer.clientWidth,o.lineSpace.clientWidth);("above"==n||e.bottom+t.offsetHeight>a)&&e.top>t.offsetHeight?l=e.top-t.offsetHeight:e.bottom+t.offsetHeight<=a&&(l=e.bottom),s+t.offsetWidth>u&&(s=u-t.offsetWidth)}t.style.top=l+"px",t.style.left=t.style.right="","right"==i?(s=o.sizer.clientWidth-t.offsetWidth,t.style.right="0px"):("left"==i?s=0:"middle"==i&&(s=(o.sizer.clientWidth-t.offsetWidth)/2),t.style.left=s+"px"),r&&Ur(this,{left:s,top:l,right:s+t.offsetWidth,bottom:l+t.offsetHeight})},triggerOnKeyDown:pn(Lo),triggerOnKeyPress:pn(Mo),triggerOnKeyUp:To,triggerOnMouseDown:pn(Oo),execCommand:function(e){if(Bs.hasOwnProperty(e))return Bs[e].call(null,this)},triggerElectric:pn(function(e){Zo(this,e)}),findPosH:function(e,t,r,n){var i=this,o=1;t<0&&(o=-1,t=-t);for(var l=U(this.doc,e),s=0;s<t&&!(l=tl(i.doc,l,o,r,n)).hitSide;++s);return l},moveH:pn(function(e,t){var r=this;this.extendSelectionsBy(function(n){return r.display.shift||r.doc.extend||n.empty()?tl(r.doc,n.head,e,t,r.options.rtlMoveVisually):e<0?n.from():n.to()},Vl)}),deleteH:pn(function(e,t){var r=this.doc.sel,n=this.doc;r.somethingSelected()?n.replaceSelection("",null,"+delete"):co(this,function(r){var i=tl(n,r.head,e,t,!1);return e<0?{from:i,to:r.head}:{from:r.head,to:i}})}),findPosV:function(e,t,r,n){var i=this,o=1,l=n;t<0&&(o=-1,t=-t);for(var s=U(this.doc,e),a=0;a<t;++a){var u=sr(i,s,"div");if(null==l?l=u.left:u.left=l,(s=rl(i,u,o,r)).hitSide)break}return s},moveV:pn(function(e,t){var r=this,n=this.doc,i=[],o=!this.display.shift&&!n.extend&&n.sel.somethingSelected();if(n.extendSelectionsBy(function(l){if(o)return e<0?l.from():l.to();var s=sr(r,l.head,"div");null!=l.goalColumn&&(s.left=l.goalColumn),i.push(s.left);var a=rl(r,s,e,t);return"page"==t&&l==n.sel.primary()&&Kr(r,lr(r,a,"div").top-s.top),a},Vl),i.length)for(var l=0;l<n.sel.ranges.length;l++)n.sel.ranges[l].goalColumn=i[l]}),findWordAt:function(e){var t=M(this.doc,e.line).text,r=e.ch,n=e.ch;if(t){var i=this.getHelper(e,"wordChars");"before"!=e.sticky&&n!=t.length||!r?++n:--r;for(var o=t.charAt(r),l=x(o,i)?function(e){return x(e,i)}:/\s/.test(o)?function(e){return/\s/.test(e)}:function(e){return!/\s/.test(e)&&!x(e)};r>0&&l(t.charAt(r-1));)--r;for(;n<t.length&&l(t.charAt(n));)++n}return new Ts(E(e.line,r),E(e.line,n))},toggleOverwrite:function(e){null!=e&&e==this.state.overwrite||((this.state.overwrite=!this.state.overwrite)?s(this.display.cursorDiv,"CodeMirror-overwrite"):Fl(this.display.cursorDiv,"CodeMirror-overwrite"),Te(this,"overwriteToggle",this,this.state.overwrite))},hasFocus:function(){return this.display.input.getField()==l()},isReadOnly:function(){return!(!this.options.readOnly&&!this.doc.cantEdit)},scrollTo:pn(function(e,t){Xr(this,e,t)}),getScrollInfo:function(){var e=this.display.scroller;return{left:e.scrollLeft,top:e.scrollTop,height:e.scrollHeight-zt(this)-this.display.barHeight,width:e.scrollWidth-zt(this)-this.display.barWidth,clientHeight:Bt(this),clientWidth:Rt(this)}},scrollIntoView:pn(function(e,t){null==e?(e={from:this.doc.sel.primary().head,to:null},null==t&&(t=this.options.cursorScrollMargin)):"number"==typeof e?e={from:E(e,0),to:null}:null==e.from&&(e={from:e,to:null}),e.to||(e.to=e.from),e.margin=t||0,null!=e.from.line?Yr(this,e):$r(this,e.from,e.to,e.margin)}),setSize:pn(function(e,t){var r=this,n=function(e){return"number"==typeof e||/^\d+$/.test(String(e))?e+"px":e};null!=e&&(this.display.wrapper.style.width=n(e)),null!=t&&(this.display.wrapper.style.height=n(t)),this.options.lineWrapping&&Jt(this);var i=this.display.viewFrom;this.doc.iter(i,this.display.viewTo,function(e){if(e.widgets)for(var t=0;t<e.widgets.length;t++)if(e.widgets[t].noHScroll){mn(r,i,"widget");break}++i}),this.curOp.forceUpdate=!0,Te(this,"refresh",this)}),operation:function(e){return hn(this,e)},startOperation:function(){return nn(this)},endOperation:function(){return on(this)},refresh:pn(function(){var e=this.display.cachedTextHeight;vn(this),this.curOp.forceUpdate=!0,er(this),Xr(this,this.doc.scrollLeft,this.doc.scrollTop),Wn(this),(null==e||Math.abs(e-mr(this.display))>.5)&&Cr(this),Te(this,"refresh",this)}),swapDoc:pn(function(e){var t=this.doc;return t.cm=null,qn(this,e),er(this),this.display.input.reset(),Xr(this,e.scrollLeft,e.scrollTop),this.curOp.forceScroll=!0,bt(this,"swapDoc",this,t),t}),getInputField:function(){return this.display.input.getField()},getWrapperElement:function(){return this.display.wrapper},getScrollerElement:function(){return this.display.scroller},getGutterElement:function(){return this.display.gutters}},Ae(e),e.registerHelper=function(t,n,i){r.hasOwnProperty(t)||(r[t]=e[t]={_global:[]}),r[t][n]=i},e.registerGlobalHelper=function(t,n,i,o){e.registerHelper(t,n,o),r[t]._global.push({pred:i,val:o})}}(jo);var Js="iter insert remove copy getEditor constructor".split(" ");for(var ea in Ds.prototype)Ds.prototype.hasOwnProperty(ea)&&h(Js,ea)<0&&(jo.prototype[ea]=function(e){return function(){return e.apply(this.doc,arguments)}}(Ds.prototype[ea]));return Ae(Ds),jo.inputStyles={textarea:Qs,contenteditable:Zs},jo.defineMode=function(e){jo.defaults.mode||"null"==e||(jo.defaults.mode=e),Be.apply(this,arguments)},jo.defineMIME=function(e,t){os[e]=t},jo.defineMode("null",function(){return{token:function(e){return e.skipToEnd()}}}),jo.defineMIME("text/plain","null"),jo.defineExtension=function(e,t){jo.prototype[e]=t},jo.defineDocExtension=function(e,t){Ds.prototype[e]=t},jo.fromTextArea=function(e,t){function r(){e.value=a.getValue()}if(t=t?c(t):{},t.value=e.value,!t.tabindex&&e.tabIndex&&(t.tabindex=e.tabIndex),!t.placeholder&&e.placeholder&&(t.placeholder=e.placeholder),null==t.autofocus){var n=l();t.autofocus=n==e||null!=e.getAttribute("autofocus")&&n==document.body}var i;if(e.form&&(Ql(e.form,"submit",r),!t.leaveSubmitMethodAlone)){var o=e.form;i=o.submit;try{var s=o.submit=function(){r(),o.submit=i,o.submit(),o.submit=s}}catch(e){}}t.finishInit=function(t){t.save=r,t.getTextArea=function(){return e},t.toTextArea=function(){t.toTextArea=isNaN,r(),e.parentNode.removeChild(t.getWrapperElement()),e.style.display="",e.form&&(ke(e.form,"submit",r),"function"==typeof e.form.submit&&(e.form.submit=i))}},e.style.display="none";var a=jo(function(t){return e.parentNode.insertBefore(t,e.nextSibling)},t);return a},function(e){e.off=ke,e.on=Ql,e.wheelEventPixels=Pn,e.Doc=Ds,e.splitLines=es,e.countColumn=f,e.findColumn=d,e.isWordChar=w,e.Pass=Bl,e.signal=Te,e.Line=fs,e.changeEnd=Bn,e.scrollbarModel=ws,e.Pos=E,e.cmpPos=P,e.modes=is,e.mimeModes=os,e.resolveMode=Ge,e.getMode=Ue,e.modeExtensions=ls,e.extendMode=Ve,e.copyState=Ke,e.startState=Xe,e.innerMode=je,e.commands=Bs,e.keyMap=Rs,e.keyName=ao,e.isModifierKey=lo,e.lookupKey=oo,e.normalizeKeyMap=io,e.StringStream=ss,e.SharedTextMarker=As,e.TextMarker=Os,e.LineWidget=Ms,e.e_preventDefault=We,e.e_stopPropagation=De,e.e_stop=Fe,e.addClass=s,e.contains=o,e.rmClass=Fl,e.keyNames=Es}(jo),jo.version="5.30.0",jo});
      !function(e){"object"==typeof exports&&"object"==typeof module?e(require("../../lib/codemirror")):"function"==typeof define&&define.amd?define(["../../lib/codemirror"],e):e(CodeMirror)}(function(e){"use strict";function t(e,t,n,r,o,a){this.indented=e,this.column=t,this.type=n,this.info=r,this.align=o,this.prev=a}function n(e,n,r,o){var a=e.indented;return e.context&&"statement"==e.context.type&&"statement"!=r&&(a=e.context.indented),e.context=new t(a,n,r,o,null,e.context)}function r(e){var t=e.context.type;return")"!=t&&"]"!=t&&"}"!=t||(e.indented=e.context.indented),e.context=e.context.prev}function o(e,t,n){return"variable"==t.prevToken||"type"==t.prevToken||(!!/\S(?:[^- ]>|[*\]])\s*$|\*$/.test(e.string.slice(0,n))||(!(!t.typeAtEndOfLine||e.column()!=e.indentation())||void 0))}function a(e){for(;;){if(!e||"top"==e.type)return!0;if("}"==e.type&&"namespace"!=e.prev.info)return!1;e=e.prev}}function i(e){for(var t={},n=e.split(" "),r=0;r<n.length;++r)t[n[r]]=!0;return t}function l(e,t){return"function"==typeof e?e(t):e.propertyIsEnumerable(t)}function s(e,t){if(!t.startOfLine)return!1;for(var n,r=null;n=e.peek();){if("\\"==n&&e.match(/^.$/)){r=s;break}if("/"==n&&e.match(/^\/[\/\*]/,!1))break;e.next()}return t.tokenize=r,"meta"}function c(e,t){return"type"==t.prevToken&&"type"}function u(e){return e.eatWhile(/[\w\.']/),"number"}function d(e,t){if(e.backUp(1),e.match(/(R|u8R|uR|UR|LR)/)){var n=e.match(/"([^\s\\()]{0,16})\(/);return!!n&&(t.cpp11RawStringDelim=n[1],t.tokenize=m,m(e,t))}return e.match(/(u8|u|U|L)/)?!!e.match(/["']/,!1)&&"string":(e.next(),!1)}function f(e){var t=/(\w+)::~?(\w+)$/.exec(e);return t&&t[1]==t[2]}function p(e,t){for(var n;null!=(n=e.next());)if('"'==n&&!e.eat('"')){t.tokenize=null;break}return"string"}function m(e,t){var n=t.cpp11RawStringDelim.replace(/[^\w\s]/g,"\\$&");return e.match(new RegExp(".*?\\)"+n+'"'))?t.tokenize=null:e.skipToEnd(),"string"}function h(t,n){function r(e){if(e)for(var t in e)e.hasOwnProperty(t)&&o.push(t)}"string"==typeof t&&(t=[t]);var o=[];r(n.keywords),r(n.types),r(n.builtin),r(n.atoms),o.length&&(n.helperType=t[0],e.registerHelper("hintWords",t[0],o));for(var a=0;a<t.length;++a)e.defineMIME(t[a],n)}function g(e,t){for(var n=!1;!e.eol();){if(!n&&e.match('"""')){t.tokenize=null;break}n="\\"==e.next()&&!n}return"string"}function y(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!e&&!o&&t.match('"')){a=!0;break}if(e&&t.match('"""')){a=!0;break}r=t.next(),!o&&"$"==r&&t.match("{")&&t.skipTo("}"),o=!o&&"\\"==r&&!e}return!a&&e||(n.tokenize=null),"string"}}function x(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!o&&t.match('"')&&("single"==e||t.match('""'))){a=!0;break}if(!o&&t.match("``")){w=x(e),a=!0;break}r=t.next(),o="single"==e&&!o&&"\\"==r}return a&&(n.tokenize=null),"string"}}e.defineMode("clike",function(i,s){function c(e,t){var n=e.next();if(S[n]){var r=S[n](e,t);if(!1!==r)return r}if('"'==n||"'"==n)return t.tokenize=u(n),t.tokenize(e,t);if(D.test(n))return p=n,null;if(L.test(n)){if(e.backUp(1),e.match(I))return"number";e.next()}if("/"==n){if(e.eat("*"))return t.tokenize=d,d(e,t);if(e.eat("/"))return e.skipToEnd(),"comment"}if(F.test(n)){for(;!e.match(/^\/[\/*]/,!1)&&e.eat(F););return"operator"}if(e.eatWhile(z),P)for(;e.match(P);)e.eatWhile(z);var o=e.current();return l(x,o)?(l(w,o)&&(p="newstatement"),l(v,o)&&(m=!0),"keyword"):l(b,o)?"type":l(k,o)?(l(w,o)&&(p="newstatement"),"builtin"):l(_,o)?"atom":"variable"}function u(e){return function(t,n){for(var r,o=!1,a=!1;null!=(r=t.next());){if(r==e&&!o){a=!0;break}o=!o&&"\\"==r}return(a||!o&&!C)&&(n.tokenize=null),"string"}}function d(e,t){for(var n,r=!1;n=e.next();){if("/"==n&&r){t.tokenize=null;break}r="*"==n}return"comment"}function f(e,t){s.typeFirstDefinitions&&e.eol()&&a(t.context)&&(t.typeAtEndOfLine=o(e,t,e.pos))}var p,m,h=i.indentUnit,g=s.statementIndentUnit||h,y=s.dontAlignCalls,x=s.keywords||{},b=s.types||{},k=s.builtin||{},w=s.blockKeywords||{},v=s.defKeywords||{},_=s.atoms||{},S=s.hooks||{},C=s.multiLineStrings,T=!1!==s.indentStatements,M=!1!==s.indentSwitch,P=s.namespaceSeparator,D=s.isPunctuationChar||/[\[\]{}\(\),;\:\.]/,L=s.numberStart||/[\d\.]/,I=s.number||/^(?:0x[a-f\d]+|0b[01]+|(?:\d+\.?\d*|\.\d+)(?:e[-+]?\d+)?)(u|ll?|l|f)?/i,F=s.isOperatorChar||/[+\-*&%=<>!?|\/]/,z=s.isIdentifierChar||/[\w\$_\xa1-\uffff]/;return{startState:function(e){return{tokenize:null,context:new t((e||0)-h,0,"top",null,!1),indented:0,startOfLine:!0,prevToken:null}},token:function(e,t){var i=t.context;if(e.sol()&&(null==i.align&&(i.align=!1),t.indented=e.indentation(),t.startOfLine=!0),e.eatSpace())return f(e,t),null;p=m=null;var l=(t.tokenize||c)(e,t);if("comment"==l||"meta"==l)return l;if(null==i.align&&(i.align=!0),";"==p||":"==p||","==p&&e.match(/^\s*(?:\/\/.*)?$/,!1))for(;"statement"==t.context.type;)r(t);else if("{"==p)n(t,e.column(),"}");else if("["==p)n(t,e.column(),"]");else if("("==p)n(t,e.column(),")");else if("}"==p){for(;"statement"==i.type;)i=r(t);for("}"==i.type&&(i=r(t));"statement"==i.type;)i=r(t)}else p==i.type?r(t):T&&(("}"==i.type||"top"==i.type)&&";"!=p||"statement"==i.type&&"newstatement"==p)&&n(t,e.column(),"statement",e.current());if("variable"==l&&("def"==t.prevToken||s.typeFirstDefinitions&&o(e,t,e.start)&&a(t.context)&&e.match(/^\s*\(/,!1))&&(l="def"),S.token){var u=S.token(e,t,l);void 0!==u&&(l=u)}return"def"==l&&!1===s.styleDefs&&(l="variable"),t.startOfLine=!1,t.prevToken=m?"def":l||p,f(e,t),l},indent:function(t,n){if(t.tokenize!=c&&null!=t.tokenize||t.typeAtEndOfLine)return e.Pass;var r=t.context,o=n&&n.charAt(0);if("statement"==r.type&&"}"==o&&(r=r.prev),s.dontIndentStatements)for(;"statement"==r.type&&s.dontIndentStatements.test(r.info);)r=r.prev;if(S.indent){var a=S.indent(t,r,n);if("number"==typeof a)return a}var i=o==r.type,l=r.prev&&"switch"==r.prev.info;if(s.allmanIndentation&&/[{(]/.test(o)){for(;"top"!=r.type&&"}"!=r.type;)r=r.prev;return r.indented}return"statement"==r.type?r.indented+("{"==o?0:g):!r.align||y&&")"==r.type?")"!=r.type||i?r.indented+(i?0:h)+(i||!l||/^(?:case|default)\b/.test(n)?0:h):r.indented+g:r.column+(i?0:1)},electricInput:M?/^\s*(?:case .*?:|default:|\{\}?|\})$/:/^\s*[{}]$/,blockCommentStart:"/*",blockCommentEnd:"*/",lineComment:"//",fold:"brace"}});var b="auto if break case register continue return default do sizeof static else struct switch extern typedef union for goto while enum const volatile",k="int long char short double float unsigned signed void size_t ptrdiff_t";h(["text/x-csrc","text/x-c","text/x-chdr"],{name:"clike",keywords:i(b),types:i(k+" bool _Complex _Bool float_t double_t intptr_t intmax_t int8_t int16_t int32_t int64_t uintptr_t uintmax_t uint8_t uint16_t uint32_t uint64_t"),blockKeywords:i("case do else for if switch while struct"),defKeywords:i("struct"),typeFirstDefinitions:!0,atoms:i("null true false"),hooks:{"#":s,"*":c},modeProps:{fold:["brace","include"]}}),h(["text/x-c++src","text/x-c++hdr"],{name:"clike",keywords:i(b+" asm dynamic_cast namespace reinterpret_cast try explicit new static_cast typeid catch operator template typename class friend private this using const_cast inline public throw virtual delete mutable protected alignas alignof constexpr decltype nullptr noexcept thread_local final static_assert override"),types:i(k+" bool wchar_t"),blockKeywords:i("catch class do else finally for if struct switch try while"),defKeywords:i("class namespace struct enum union"),typeFirstDefinitions:!0,atoms:i("true false null"),dontIndentStatements:/^template$/,isIdentifierChar:/[\w\$_~\xa1-\uffff]/,hooks:{"#":s,"*":c,u:d,U:d,L:d,R:d,0:u,1:u,2:u,3:u,4:u,5:u,6:u,7:u,8:u,9:u,token:function(e,t,n){if("variable"==n&&"("==e.peek()&&(";"==t.prevToken||null==t.prevToken||"}"==t.prevToken)&&f(e.current()))return"def"}},namespaceSeparator:"::",modeProps:{fold:["brace","include"]}}),h("text/x-java",{name:"clike",keywords:i("abstract assert break case catch class const continue default do else enum extends final finally float for goto if implements import instanceof interface native new package private protected public return static strictfp super switch synchronized this throw throws transient try volatile while @interface"),types:i("byte short int long float double boolean char void Boolean Byte Character Double Float Integer Long Number Object Short String StringBuffer StringBuilder Void"),blockKeywords:i("catch class do else finally for if switch try while"),defKeywords:i("class interface package enum @interface"),typeFirstDefinitions:!0,atoms:i("true false null"),number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,hooks:{"@":function(e){return!e.match("interface",!1)&&(e.eatWhile(/[\w\$_]/),"meta")}},modeProps:{fold:["brace","import"]}}),h("text/x-csharp",{name:"clike",keywords:i("abstract as async await base break case catch checked class const continue default delegate do else enum event explicit extern finally fixed for foreach goto if implicit in interface internal is lock namespace new operator out override params private protected public readonly ref return sealed sizeof stackalloc static struct switch this throw try typeof unchecked unsafe using virtual void volatile while add alias ascending descending dynamic from get global group into join let orderby partial remove select set value var yield"),types:i("Action Boolean Byte Char DateTime DateTimeOffset Decimal Double Func Guid Int16 Int32 Int64 Object SByte Single String Task TimeSpan UInt16 UInt32 UInt64 bool byte char decimal double short int long object sbyte float string ushort uint ulong"),blockKeywords:i("catch class do else finally for foreach if struct switch try while"),defKeywords:i("class interface namespace struct var"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"@":function(e,t){return e.eat('"')?(t.tokenize=p,p(e,t)):(e.eatWhile(/[\w\$_]/),"meta")}}}),h("text/x-scala",{name:"clike",keywords:i("abstract case catch class def do else extends final finally for forSome if implicit import lazy match new null object override package private protected return sealed super this throw trait try type val var while with yield _ assert assume require print println printf readLine readBoolean readByte readShort readChar readInt readLong readFloat readDouble"),types:i("AnyVal App Application Array BufferedIterator BigDecimal BigInt Char Console Either Enumeration Equiv Error Exception Fractional Function IndexedSeq Int Integral Iterable Iterator List Map Numeric Nil NotNull Option Ordered Ordering PartialFunction PartialOrdering Product Proxy Range Responder Seq Serializable Set Specializable Stream StringBuilder StringContext Symbol Throwable Traversable TraversableOnce Tuple Unit Vector Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),multiLineStrings:!0,blockKeywords:i("catch class enum do else finally for forSome if match switch try while"),defKeywords:i("class enum def object package trait type val var"),atoms:i("true false null"),indentStatements:!1,indentSwitch:!1,isOperatorChar:/[+\-*&%=<>!?|\/#:@]/,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return!!e.match('""')&&(t.tokenize=g,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},"=":function(e,n){var r=n.context;return!("}"!=r.type||!r.align||!e.eat(">"))&&(n.context=new t(r.indented,r.column,r.type,r.info,null,r.prev),"operator")}},modeProps:{closeBrackets:{triples:'"'}}}),h("text/x-kotlin",{name:"clike",keywords:i("package as typealias class interface this super val var fun for is in This throw return break continue object if else while do try when !in !is as? file import where by get set abstract enum open inner override private public internal protected catch finally out final vararg reified dynamic companion constructor init sealed field property receiver param sparam lateinit data inline noinline tailrec external annotation crossinline const operator infix suspend"),types:i("Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),intendSwitch:!1,indentStatements:!1,multiLineStrings:!0,number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,blockKeywords:i("catch class do else finally for if where try while enum"),defKeywords:i("class val var object package interface fun"),atoms:i("true false null this"),hooks:{'"':function(e,t){return t.tokenize=y(e.match('""')),t.tokenize(e,t)}},modeProps:{closeBrackets:{triples:'"'}}}),h(["x-shader/x-vertex","x-shader/x-fragment"],{name:"clike",keywords:i("sampler1D sampler2D sampler3D samplerCube sampler1DShadow sampler2DShadow const attribute uniform varying break continue discard return for while do if else struct in out inout"),types:i("float int bool void vec2 vec3 vec4 ivec2 ivec3 ivec4 bvec2 bvec3 bvec4 mat2 mat3 mat4"),blockKeywords:i("for while do if else struct"),builtin:i("radians degrees sin cos tan asin acos atan pow exp log exp2 sqrt inversesqrt abs sign floor ceil fract mod min max clamp mix step smoothstep length distance dot cross normalize ftransform faceforward reflect refract matrixCompMult lessThan lessThanEqual greaterThan greaterThanEqual equal notEqual any all not texture1D texture1DProj texture1DLod texture1DProjLod texture2D texture2DProj texture2DLod texture2DProjLod texture3D texture3DProj texture3DLod texture3DProjLod textureCube textureCubeLod shadow1D shadow2D shadow1DProj shadow2DProj shadow1DLod shadow2DLod shadow1DProjLod shadow2DProjLod dFdx dFdy fwidth noise1 noise2 noise3 noise4"),atoms:i("true false gl_FragColor gl_SecondaryColor gl_Normal gl_Vertex gl_MultiTexCoord0 gl_MultiTexCoord1 gl_MultiTexCoord2 gl_MultiTexCoord3 gl_MultiTexCoord4 gl_MultiTexCoord5 gl_MultiTexCoord6 gl_MultiTexCoord7 gl_FogCoord gl_PointCoord gl_Position gl_PointSize gl_ClipVertex gl_FrontColor gl_BackColor gl_FrontSecondaryColor gl_BackSecondaryColor gl_TexCoord gl_FogFragCoord gl_FragCoord gl_FrontFacing gl_FragData gl_FragDepth gl_ModelViewMatrix gl_ProjectionMatrix gl_ModelViewProjectionMatrix gl_TextureMatrix gl_NormalMatrix gl_ModelViewMatrixInverse gl_ProjectionMatrixInverse gl_ModelViewProjectionMatrixInverse gl_TexureMatrixTranspose gl_ModelViewMatrixInverseTranspose gl_ProjectionMatrixInverseTranspose gl_ModelViewProjectionMatrixInverseTranspose gl_TextureMatrixInverseTranspose gl_NormalScale gl_DepthRange gl_ClipPlane gl_Point gl_FrontMaterial gl_BackMaterial gl_LightSource gl_LightModel gl_FrontLightModelProduct gl_BackLightModelProduct gl_TextureColor gl_EyePlaneS gl_EyePlaneT gl_EyePlaneR gl_EyePlaneQ gl_FogParameters gl_MaxLights gl_MaxClipPlanes gl_MaxTextureUnits gl_MaxTextureCoords gl_MaxVertexAttribs gl_MaxVertexUniformComponents gl_MaxVaryingFloats gl_MaxVertexTextureImageUnits gl_MaxTextureImageUnits gl_MaxFragmentUniformComponents gl_MaxCombineTextureImageUnits gl_MaxDrawBuffers"),indentSwitch:!1,hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-nesc",{name:"clike",keywords:i(b+"as atomic async call command component components configuration event generic implementation includes interface module new norace nx_struct nx_union post provides signal task uses abstract extends"),types:i(k),blockKeywords:i("case do else for if switch while struct"),atoms:i("null true false"),hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-objectivec",{name:"clike",keywords:i(b+"inline restrict _Bool _Complex _Imaginary BOOL Class bycopy byref id IMP in inout nil oneway out Protocol SEL self super atomic nonatomic retain copy readwrite readonly"),types:i(k),atoms:i("YES NO NULL NILL ON OFF true false"),hooks:{"@":function(e){return e.eatWhile(/[\w\$]/),"keyword"},"#":s,indent:function(e,t,n){if("statement"==t.type&&/^@\w/.test(n))return t.indented}},modeProps:{fold:"brace"}}),h("text/x-squirrel",{name:"clike",keywords:i("base break clone continue const default delete enum extends function in class foreach local resume return this throw typeof yield constructor instanceof static"),types:i(k),blockKeywords:i("case catch class else for foreach if switch try while"),defKeywords:i("function local class"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"#":s},modeProps:{fold:["brace","include"]}});var w=null;h("text/x-ceylon",{name:"clike",keywords:i("abstracts alias assembly assert assign break case catch class continue dynamic else exists extends finally for function given if import in interface is let module new nonempty object of out outer package return satisfies super switch then this throw try value void while"),types:function(e){var t=e.charAt(0);return t===t.toUpperCase()&&t!==t.toLowerCase()},blockKeywords:i("case catch class dynamic else finally for function if interface module new object switch try while"),defKeywords:i("class dynamic function interface module object package value"),builtin:i("abstract actual aliased annotation by default deprecated doc final formal late license native optional sealed see serializable shared suppressWarnings tagged throws variable"),isPunctuationChar:/[\[\]{}\(\),;\:\.`]/,isOperatorChar:/[+\-*&%=<>!?|^~:\/]/,numberStart:/[\d#$]/,number:/^(?:#[\da-fA-F_]+|\$[01_]+|[\d_]+[kMGTPmunpf]?|[\d_]+\.[\d_]+(?:[eE][-+]?\d+|[kMGTPmunpf]|)|)/i,multiLineStrings:!0,typeFirstDefinitions:!0,atoms:i("true false null larger smaller equal empty finished"),indentSwitch:!1,styleDefs:!1,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return t.tokenize=x(e.match('""')?"triple":"single"),t.tokenize(e,t)},"`":function(e,t){return!(!w||!e.match("`"))&&(t.tokenize=w,w=null,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},token:function(e,t,n){if(("variable"==n||"type"==n)&&"."==t.prevToken)return"variable-2"}},modeProps:{fold:["brace","import"],closeBrackets:{triples:'"'}}})});
      // -------------------------------------------------------------------------
//  Part of the CodeChecker project, under the Apache License v2.0 with
//  LLVM Exceptions. See LICENSE for license information.
//  SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
// -------------------------------------------------------------------------

var BugViewer = {
  _files : [],
  _reports : [],
  _lineWidgets : [],
  _navigationMenuItems : [],
  _sourceFileData : null,
  _currentReport : null,
  _lastBugEvent  : null,

  init : function (files, reports) {
    this._files = files;
    this._reports = reports;

    this.initEscapeChars();
  },

  initEscapeChars : function () {
    this.escapeChars = {
      ' ' : 'nbsp',
      '<' : 'lt',
      '>' : 'gt',
      '"' : 'quot',
      '&' : 'amp'
    };

    var regexString = '[';
    for (var key in this.escapeChars) {
      regexString += key;
    }
    regexString += ']';

    this.escapeRegExp = new RegExp( regexString, 'g');
  },

  escapeHTML : function (str) {
    var that = this;

    return str.replace(this.escapeRegExp, function (m) {
      return '&' + that.escapeChars[m] + ';';
    });
  },

  initByUrl : function () {
    if (!this._reports) return;

    var state = {};
    window.location.hash.substr(1).split('&').forEach(function (s) {
      var parts = s.split('=');
      state[parts[0]] = parts[1];
    });

    for (var key in this._reports) {
      var report = this._reports[key];
      if (report.reportHash === state['reportHash']) {
        this.navigate(report);
        return;
      }
    }

    this.navigate(this._reports[0]);
  },

  create : function () {
    this._content = document.getElementById('editor-wrapper');
    this._filepath = document.getElementById('file-path');
    this._checkerName = document.getElementById('checker-name');
    this._reviewStatusWrapper =
      document.getElementById('review-status-wrapper');
    this._reviewStatus = document.getElementById('review-status');
    this._editor = document.getElementById('editor');

    this._codeMirror = CodeMirror(this._editor, {
      mode: 'text/x-c++src',
      matchBrackets : true,
      lineNumbers : true,
      readOnly : true,
      foldGutter : true,
      extraKeys : {},
      viewportMargin : 100
    });

    this._createNavigationMenu();
  },

  navigate : function (report, item) {
    if (!item) {
      var items = this._navigationMenuItems.filter(function (navItem) {
        return navItem.report.reportHash === report.reportHash;
      });

      if (!items.length) return;

      item = items[0].widget;
    }

    this._selectedReport.classList.remove('active');
    this._selectedReport = item;
    this._selectedReport.classList.add('active');
    this.setReport(report);
  },

  _createNavigationMenu : function () {
    var that = this;

    var nav = document.getElementById('report-nav');
    var list = document.createElement('ul');
    this._reports.forEach(function (report) {
      var events = report['events'];
      var lastBugEvent = events[events.length - 1];
      var item = document.createElement('li');

      var severity = document.createElement('i');
      severity.className = 'severity-' + report.severity.toLowerCase();

      item.appendChild(severity);
      item.appendChild(document.createTextNode(lastBugEvent.message));

      item.addEventListener('click', function () {
        that.navigate(report, item);
      })
      list.appendChild(item);
      that._navigationMenuItems.push({ report : report, widget : item });
    });

    if (!this._selectedReport && list.childNodes.length) {
      this._selectedReport = list.childNodes[0];
      this._selectedReport.classList.add('active');
    }

    nav.appendChild(list);
  },

  setReport : function (report) {
    this._currentReport = report;
    var events = report['events'];
    var lastBugEvent = events[events.length - 1];
    this.setCurrentBugEvent(lastBugEvent, events.length - 1);
    this.setCheckerName(report.checkerName);
    this.setReviewStatus(report.reviewStatus);

    window.location.hash = '#reportHash=' + report.reportHash;
  },

  setCurrentBugEvent : function (event, idx) {
    this._currentBugEvent = event;
    this.setSourceFileData(this._files[event.location.file]);
    this.drawBugPath();

    this.jumpTo(event.location.line, 0);
    this.highlightBugEvent(event, idx);
  },

  highlightBugEvent : function (event, idx) {
    this._lineWidgets.forEach(function (widget) {
      var lineIdx = widget.node.getAttribute('idx');
      if (parseInt(lineIdx) === idx) {
        widget.node.classList.add('current');
      }
    });
  },

  setCheckerName : function (checkerName) {
    this._checkerName.innerHTML = checkerName;
  },

  setReviewStatus : function (status) {
    if (status) {
      var className =
        'review-status-' + status.toLowerCase().split(' ').join('-');
      this._reviewStatus.className = "review-status " + className;

      this._reviewStatus.innerHTML = status;
      this._reviewStatusWrapper.style.display = 'block';
    } else {
      this._reviewStatusWrapper.style.display = 'none';
    }
  },

  setSourceFileData : function (file) {
    if (this._sourceFileData && file.id === this._sourceFileData.id) {
      return;
    }

    this._sourceFileData = file;
    this._filepath.innerHTML = file.path;
    this._codeMirror.doc.setValue(file.content);
    this._refresh();
  },

  _refresh : function () {
    var that = this;
    setTimeout(function () {
      var fullHeight = parseInt(that._content.clientHeight);
      var headerHeight = that._filepath.clientHeight;

      that._codeMirror.setSize('auto', fullHeight - headerHeight);
      that._codeMirror.refresh();
    }, 200);
  },

  clearBubbles : function () {
    this._lineWidgets.forEach(function (widget) { widget.clear(); });
    this._lineWidgets = [];
  },

  getMessage : function (event, kind) {
    if (kind === 'macro') {
      var name = 'macro expansion' + (event.name ? ': ' + event.name : '');

      return '<span class="tag macro">' + name + '</span>'
        + this.escapeHTML(event.expansion).replace(/(?:\r\n|\r|\n)/g, '<br>');
    } else if (kind === 'note') {
      return '<span class="tag note">note</span>'
        +  this.escapeHTML(event.message).replace(/(?:\r\n|\r|\n)/g, '<br>');
    }
  },

  addExtraPathEvents : function (events, kind) {
    var that = this;

    if (!events) {
      return;
    }

    events.forEach(function (event) {
      if (event.location.file !== that._currentBugEvent.location.file) {
        return;
      }

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + kind);

      var msg = document.createElement('span');
      msg.innerHTML = that.getMessage(event, kind);
      element.appendChild(msg);

      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  drawBugPath : function () {
    var that = this;

    this.clearBubbles();

    this.addExtraPathEvents(this._currentReport.macros, 'macro');
    this.addExtraPathEvents(this._currentReport.notes, 'note');

    // Processing bug path events.
    var currentEvents = this._currentReport.events;
    currentEvents.forEach(function (event, step) {
      if (event.location.file !== that._currentBugEvent.location.file)
        return;

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';
      var type = step === currentEvents.length - 1 ? 'error' : 'info';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + type);
      element.setAttribute('idx', step);

      var enumeration = document.createElement('span');
      enumeration.setAttribute('class', 'checker-enum ' + type);
      enumeration.innerHTML = step + 1;

      if (currentEvents.length > 1)
        element.appendChild(enumeration);

      var prevBugEvent = step - 1;
      if (step > 0) {
        var prevBug = document.createElement('span');
        prevBug.setAttribute('class', 'arrow left-arrow');
        prevBug.addEventListener('click', function () {
          var event = currentEvents[prevBugEvent];
          that.setCurrentBugEvent(event, prevBugEvent);
        });
        element.appendChild(prevBug);
      }

      var msg = document.createElement('span');
      msg.innerHTML = that.escapeHTML(event.message)
        .replace(/(?:\r\n|\r|\n)/g, '<br>');

      element.appendChild(msg);

      var nextBugEvent = step + 1;
      if (nextBugEvent < currentEvents.length) {
        var nextBug = document.createElement('span');
        nextBug.setAttribute('class', 'arrow right-arrow');
        nextBug.addEventListener('click', function () {
          var event = currentEvents[nextBugEvent];
          that.setCurrentBugEvent(event, nextBugEvent);
        });
        element.appendChild(nextBug);
      }


      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  jumpTo : function (line, column) {
    var that = this;

    setTimeout(function () {
      var selPosPixel
        = that._codeMirror.charCoords({ line : line, ch : column }, 'local');
      var editorSize = {
        width  : that._editor.clientWidth,
        height : that._editor.clientHeight
      };

      that._codeMirror.scrollIntoView({
        top    : selPosPixel.top - 100,
        bottom : selPosPixel.top + editorSize.height - 150,
        left   : selPosPixel.left < editorSize.width - 100
               ? 0
               : selPosPixel.left - 50,
        right  : selPosPixel.left < editorSize.width - 100
               ? 10
               : selPosPixel.left + editorSize.width - 100
      });
    }, 0);
  }
}


      var data = {"files": {"9": {"id": 9, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/FoldingSet.h", "content": "//===- llvm/ADT/FoldingSet.h - Uniquing Hash Set ----------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// This file defines a hash set that can be used to remove duplication of nodes\n// in a graph.  This code was originally created by Chris Lattner for use with\n// SelectionDAGCSEMap, but was isolated to provide use across the llvm code set.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_ADT_FOLDINGSET_H\n#define LLVM_ADT_FOLDINGSET_H\n\n#include \"llvm/ADT/SmallVector.h\"\n#include \"llvm/ADT/iterator.h\"\n#include \"llvm/Support/Allocator.h\"\n#include <cassert>\n#include <cstddef>\n#include <cstdint>\n#include <utility>\n\nnamespace llvm {\n\n/// This folding set used for two purposes:\n///   1. Given information about a node we want to create, look up the unique\n///      instance of the node in the set.  If the node already exists, return\n///      it, otherwise return the bucket it should be inserted into.\n///   2. Given a node that has already been created, remove it from the set.\n///\n/// This class is implemented as a single-link chained hash table, where the\n/// \"buckets\" are actually the nodes themselves (the next pointer is in the\n/// node).  The last node points back to the bucket to simplify node removal.\n///\n/// Any node that is to be included in the folding set must be a subclass of\n/// FoldingSetNode.  The node class must also define a Profile method used to\n/// establish the unique bits of data for the node.  The Profile method is\n/// passed a FoldingSetNodeID object which is used to gather the bits.  Just\n/// call one of the Add* functions defined in the FoldingSetBase::NodeID class.\n/// NOTE: That the folding set does not own the nodes and it is the\n/// responsibility of the user to dispose of the nodes.\n///\n/// Eg.\n///    class MyNode : public FoldingSetNode {\n///    private:\n///      std::string Name;\n///      unsigned Value;\n///    public:\n///      MyNode(const char *N, unsigned V) : Name(N), Value(V) {}\n///       ...\n///      void Profile(FoldingSetNodeID &ID) const {\n///        ID.AddString(Name);\n///        ID.AddInteger(Value);\n///      }\n///      ...\n///    };\n///\n/// To define the folding set itself use the FoldingSet template;\n///\n/// Eg.\n///    FoldingSet<MyNode> MyFoldingSet;\n///\n/// Four public methods are available to manipulate the folding set;\n///\n/// 1) If you have an existing node that you want add to the set but unsure\n/// that the node might already exist then call;\n///\n///    MyNode *M = MyFoldingSet.GetOrInsertNode(N);\n///\n/// If The result is equal to the input then the node has been inserted.\n/// Otherwise, the result is the node existing in the folding set, and the\n/// input can be discarded (use the result instead.)\n///\n/// 2) If you are ready to construct a node but want to check if it already\n/// exists, then call FindNodeOrInsertPos with a FoldingSetNodeID of the bits to\n/// check;\n///\n///   FoldingSetNodeID ID;\n///   ID.AddString(Name);\n///   ID.AddInteger(Value);\n///   void *InsertPoint;\n///\n///    MyNode *M = MyFoldingSet.FindNodeOrInsertPos(ID, InsertPoint);\n///\n/// If found then M will be non-NULL, else InsertPoint will point to where it\n/// should be inserted using InsertNode.\n///\n/// 3) If you get a NULL result from FindNodeOrInsertPos then you can insert a\n/// new node with InsertNode;\n///\n///    MyFoldingSet.InsertNode(M, InsertPoint);\n///\n/// 4) Finally, if you want to remove a node from the folding set call;\n///\n///    bool WasRemoved = MyFoldingSet.RemoveNode(M);\n///\n/// The result indicates whether the node existed in the folding set.\n\nclass FoldingSetNodeID;\nclass StringRef;\n\n//===----------------------------------------------------------------------===//\n/// FoldingSetBase - Implements the folding set functionality.  The main\n/// structure is an array of buckets.  Each bucket is indexed by the hash of\n/// the nodes it contains.  The bucket itself points to the nodes contained\n/// in the bucket via a singly linked list.  The last node in the list points\n/// back to the bucket to facilitate node removal.\n///\nclass FoldingSetBase {\nprotected:\n  /// Buckets - Array of bucket chains.\n  void **Buckets;\n\n  /// NumBuckets - Length of the Buckets array.  Always a power of 2.\n  unsigned NumBuckets;\n\n  /// NumNodes - Number of nodes in the folding set. Growth occurs when NumNodes\n  /// is greater than twice the number of buckets.\n  unsigned NumNodes;\n\n  explicit FoldingSetBase(unsigned Log2InitSize = 6);\n  FoldingSetBase(FoldingSetBase &&Arg);\n  FoldingSetBase &operator=(FoldingSetBase &&RHS);\n  ~FoldingSetBase();\n\npublic:\n  //===--------------------------------------------------------------------===//\n  /// Node - This class is used to maintain the singly linked bucket list in\n  /// a folding set.\n  class Node {\n  private:\n    // NextInFoldingSetBucket - next link in the bucket list.\n    void *NextInFoldingSetBucket = nullptr;\n\n  public:\n    Node() = default;\n\n    // Accessors\n    void *getNextInBucket() const { return NextInFoldingSetBucket; }\n    void SetNextInBucket(void *N) { NextInFoldingSetBucket = N; }\n  };\n\n  /// clear - Remove all nodes from the folding set.\n  void clear();\n\n  /// size - Returns the number of nodes in the folding set.\n  unsigned size() const { return NumNodes; }\n\n  /// empty - Returns true if there are no nodes in the folding set.\n  bool empty() const { return NumNodes == 0; }\n\n  /// capacity - Returns the number of nodes permitted in the folding set\n  /// before a rebucket operation is performed.\n  unsigned capacity() {\n    // We allow a load factor of up to 2.0,\n    // so that means our capacity is NumBuckets * 2\n    return NumBuckets * 2;\n  }\n\nprotected:\n  /// Functions provided by the derived class to compute folding properties.\n  /// This is effectively a vtable for FoldingSetBase, except that we don't\n  /// actually store a pointer to it in the object.\n  struct FoldingSetInfo {\n    /// GetNodeProfile - Instantiations of the FoldingSet template implement\n    /// this function to gather data bits for the given node.\n    void (*GetNodeProfile)(const FoldingSetBase *Self, Node *N,\n                           FoldingSetNodeID &ID);\n\n    /// NodeEquals - Instantiations of the FoldingSet template implement\n    /// this function to compare the given node with the given ID.\n    bool (*NodeEquals)(const FoldingSetBase *Self, Node *N,\n                       const FoldingSetNodeID &ID, unsigned IDHash,\n                       FoldingSetNodeID &TempID);\n\n    /// ComputeNodeHash - Instantiations of the FoldingSet template implement\n    /// this function to compute a hash value for the given node.\n    unsigned (*ComputeNodeHash)(const FoldingSetBase *Self, Node *N,\n                                FoldingSetNodeID &TempID);\n  };\n\nprivate:\n  /// GrowHashTable - Double the size of the hash table and rehash everything.\n  void GrowHashTable(const FoldingSetInfo &Info);\n\n  /// GrowBucketCount - resize the hash table and rehash everything.\n  /// NewBucketCount must be a power of two, and must be greater than the old\n  /// bucket count.\n  void GrowBucketCount(unsigned NewBucketCount, const FoldingSetInfo &Info);\n\nprotected:\n  // The below methods are protected to encourage subclasses to provide a more\n  // type-safe API.\n\n  /// reserve - Increase the number of buckets such that adding the\n  /// EltCount-th node won't cause a rebucket operation. reserve is permitted\n  /// to allocate more space than requested by EltCount.\n  void reserve(unsigned EltCount, const FoldingSetInfo &Info);\n\n  /// RemoveNode - Remove a node from the folding set, returning true if one\n  /// was removed or false if the node was not in the folding set.\n  bool RemoveNode(Node *N);\n\n  /// GetOrInsertNode - If there is an existing simple Node exactly\n  /// equal to the specified node, return it.  Otherwise, insert 'N' and return\n  /// it instead.\n  Node *GetOrInsertNode(Node *N, const FoldingSetInfo &Info);\n\n  /// FindNodeOrInsertPos - Look up the node specified by ID.  If it exists,\n  /// return it.  If not, return the insertion token that will make insertion\n  /// faster.\n  Node *FindNodeOrInsertPos(const FoldingSetNodeID &ID, void *&InsertPos,\n                            const FoldingSetInfo &Info);\n\n  /// InsertNode - Insert the specified node into the folding set, knowing that\n  /// it is not already in the folding set.  InsertPos must be obtained from\n  /// FindNodeOrInsertPos.\n  void InsertNode(Node *N, void *InsertPos, const FoldingSetInfo &Info);\n};\n\n//===----------------------------------------------------------------------===//\n\n/// DefaultFoldingSetTrait - This class provides default implementations\n/// for FoldingSetTrait implementations.\ntemplate<typename T> struct DefaultFoldingSetTrait {\n  static void Profile(const T &X, FoldingSetNodeID &ID) {\n    X.Profile(ID);\n  }\n  static void Profile(T &X, FoldingSetNodeID &ID) {\n    X.Profile(ID);\n  }\n\n  // Equals - Test if the profile for X would match ID, using TempID\n  // to compute a temporary ID if necessary. The default implementation\n  // just calls Profile and does a regular comparison. Implementations\n  // can override this to provide more efficient implementations.\n  static inline bool Equals(T &X, const FoldingSetNodeID &ID, unsigned IDHash,\n                            FoldingSetNodeID &TempID);\n\n  // ComputeHash - Compute a hash value for X, using TempID to\n  // compute a temporary ID if necessary. The default implementation\n  // just calls Profile and does a regular hash computation.\n  // Implementations can override this to provide more efficient\n  // implementations.\n  static inline unsigned ComputeHash(T &X, FoldingSetNodeID &TempID);\n};\n\n/// FoldingSetTrait - This trait class is used to define behavior of how\n/// to \"profile\" (in the FoldingSet parlance) an object of a given type.\n/// The default behavior is to invoke a 'Profile' method on an object, but\n/// through template specialization the behavior can be tailored for specific\n/// types.  Combined with the FoldingSetNodeWrapper class, one can add objects\n/// to FoldingSets that were not originally designed to have that behavior.\ntemplate<typename T> struct FoldingSetTrait\n  : public DefaultFoldingSetTrait<T> {};\n\n/// DefaultContextualFoldingSetTrait - Like DefaultFoldingSetTrait, but\n/// for ContextualFoldingSets.\ntemplate<typename T, typename Ctx>\nstruct DefaultContextualFoldingSetTrait {\n  static void Profile(T &X, FoldingSetNodeID &ID, Ctx Context) {\n    X.Profile(ID, Context);\n  }\n\n  static inline bool Equals(T &X, const FoldingSetNodeID &ID, unsigned IDHash,\n                            FoldingSetNodeID &TempID, Ctx Context);\n  static inline unsigned ComputeHash(T &X, FoldingSetNodeID &TempID,\n                                     Ctx Context);\n};\n\n/// ContextualFoldingSetTrait - Like FoldingSetTrait, but for\n/// ContextualFoldingSets.\ntemplate<typename T, typename Ctx> struct ContextualFoldingSetTrait\n  : public DefaultContextualFoldingSetTrait<T, Ctx> {};\n\n//===--------------------------------------------------------------------===//\n/// FoldingSetNodeIDRef - This class describes a reference to an interned\n/// FoldingSetNodeID, which can be a useful to store node id data rather\n/// than using plain FoldingSetNodeIDs, since the 32-element SmallVector\n/// is often much larger than necessary, and the possibility of heap\n/// allocation means it requires a non-trivial destructor call.\nclass FoldingSetNodeIDRef {\n  const unsigned *Data = nullptr;\n  size_t Size = 0;\n\npublic:\n  FoldingSetNodeIDRef() = default;\n  FoldingSetNodeIDRef(const unsigned *D, size_t S) : Data(D), Size(S) {}\n\n  /// ComputeHash - Compute a strong hash value for this FoldingSetNodeIDRef,\n  /// used to lookup the node in the FoldingSetBase.\n  unsigned ComputeHash() const;\n\n  bool operator==(FoldingSetNodeIDRef) const;\n\n  bool operator!=(FoldingSetNodeIDRef RHS) const { return !(*this == RHS); }\n\n  /// Used to compare the \"ordering\" of two nodes as defined by the\n  /// profiled bits and their ordering defined by memcmp().\n  bool operator<(FoldingSetNodeIDRef) const;\n\n  const unsigned *getData() const { return Data; }\n  size_t getSize() const { return Size; }\n};\n\n//===--------------------------------------------------------------------===//\n/// FoldingSetNodeID - This class is used to gather all the unique data bits of\n/// a node.  When all the bits are gathered this class is used to produce a\n/// hash value for the node.\nclass FoldingSetNodeID {\n  /// Bits - Vector of all the data bits that make the node unique.\n  /// Use a SmallVector to avoid a heap allocation in the common case.\n  SmallVector<unsigned, 32> Bits;\n\npublic:\n  FoldingSetNodeID() = default;\n\n  FoldingSetNodeID(FoldingSetNodeIDRef Ref)\n    : Bits(Ref.getData(), Ref.getData() + Ref.getSize()) {}\n\n  /// Add* - Add various data types to Bit data.\n  void AddPointer(const void *Ptr);\n  void AddInteger(signed I);\n  void AddInteger(unsigned I);\n  void AddInteger(long I);\n  void AddInteger(unsigned long I);\n  void AddInteger(long long I);\n  void AddInteger(unsigned long long I);\n  void AddBoolean(bool B) { AddInteger(B ? 1U : 0U); }\n  void AddString(StringRef String);\n  void AddNodeID(const FoldingSetNodeID &ID);\n\n  template <typename T>\n  inline void Add(const T &x) { FoldingSetTrait<T>::Profile(x, *this); }\n\n  /// clear - Clear the accumulated profile, allowing this FoldingSetNodeID\n  /// object to be used to compute a new profile.\n  inline void clear() { Bits.clear(); }\n\n  /// ComputeHash - Compute a strong hash value for this FoldingSetNodeID, used\n  /// to lookup the node in the FoldingSetBase.\n  unsigned ComputeHash() const;\n\n  /// operator== - Used to compare two nodes to each other.\n  bool operator==(const FoldingSetNodeID &RHS) const;\n  bool operator==(const FoldingSetNodeIDRef RHS) const;\n\n  bool operator!=(const FoldingSetNodeID &RHS) const { return !(*this == RHS); }\n  bool operator!=(const FoldingSetNodeIDRef RHS) const { return !(*this ==RHS);}\n\n  /// Used to compare the \"ordering\" of two nodes as defined by the\n  /// profiled bits and their ordering defined by memcmp().\n  bool operator<(const FoldingSetNodeID &RHS) const;\n  bool operator<(const FoldingSetNodeIDRef RHS) const;\n\n  /// Intern - Copy this node's data to a memory region allocated from the\n  /// given allocator and return a FoldingSetNodeIDRef describing the\n  /// interned data.\n  FoldingSetNodeIDRef Intern(BumpPtrAllocator &Allocator) const;\n};\n\n// Convenience type to hide the implementation of the folding set.\nusing FoldingSetNode = FoldingSetBase::Node;\ntemplate<class T> class FoldingSetIterator;\ntemplate<class T> class FoldingSetBucketIterator;\n\n// Definitions of FoldingSetTrait and ContextualFoldingSetTrait functions, which\n// require the definition of FoldingSetNodeID.\ntemplate<typename T>\ninline bool\nDefaultFoldingSetTrait<T>::Equals(T &X, const FoldingSetNodeID &ID,\n                                  unsigned /*IDHash*/,\n                                  FoldingSetNodeID &TempID) {\n  FoldingSetTrait<T>::Profile(X, TempID);\n  return TempID == ID;\n}\ntemplate<typename T>\ninline unsigned\nDefaultFoldingSetTrait<T>::ComputeHash(T &X, FoldingSetNodeID &TempID) {\n  FoldingSetTrait<T>::Profile(X, TempID);\n  return TempID.ComputeHash();\n}\ntemplate<typename T, typename Ctx>\ninline bool\nDefaultContextualFoldingSetTrait<T, Ctx>::Equals(T &X,\n                                                 const FoldingSetNodeID &ID,\n                                                 unsigned /*IDHash*/,\n                                                 FoldingSetNodeID &TempID,\n                                                 Ctx Context) {\n  ContextualFoldingSetTrait<T, Ctx>::Profile(X, TempID, Context);\n  return TempID == ID;\n}\ntemplate<typename T, typename Ctx>\ninline unsigned\nDefaultContextualFoldingSetTrait<T, Ctx>::ComputeHash(T &X,\n                                                      FoldingSetNodeID &TempID,\n                                                      Ctx Context) {\n  ContextualFoldingSetTrait<T, Ctx>::Profile(X, TempID, Context);\n  return TempID.ComputeHash();\n}\n\n//===----------------------------------------------------------------------===//\n/// FoldingSetImpl - An implementation detail that lets us share code between\n/// FoldingSet and ContextualFoldingSet.\ntemplate <class Derived, class T> class FoldingSetImpl : public FoldingSetBase {\nprotected:\n  explicit FoldingSetImpl(unsigned Log2InitSize)\n      : FoldingSetBase(Log2InitSize) {}\n\n  FoldingSetImpl(FoldingSetImpl &&Arg) = default;\n  FoldingSetImpl &operator=(FoldingSetImpl &&RHS) = default;\n  ~FoldingSetImpl() = default;\n\npublic:\n  using iterator = FoldingSetIterator<T>;\n\n  iterator begin() { return iterator(Buckets); }\n  iterator end() { return iterator(Buckets+NumBuckets); }\n\n  using const_iterator = FoldingSetIterator<const T>;\n\n  const_iterator begin() const { return const_iterator(Buckets); }\n  const_iterator end() const { return const_iterator(Buckets+NumBuckets); }\n\n  using bucket_iterator = FoldingSetBucketIterator<T>;\n\n  bucket_iterator bucket_begin(unsigned hash) {\n    return bucket_iterator(Buckets + (hash & (NumBuckets-1)));\n  }\n\n  bucket_iterator bucket_end(unsigned hash) {\n    return bucket_iterator(Buckets + (hash & (NumBuckets-1)), true);\n  }\n\n  /// reserve - Increase the number of buckets such that adding the\n  /// EltCount-th node won't cause a rebucket operation. reserve is permitted\n  /// to allocate more space than requested by EltCount.\n  void reserve(unsigned EltCount) {\n    return FoldingSetBase::reserve(EltCount, Derived::getFoldingSetInfo());\n  }\n\n  /// RemoveNode - Remove a node from the folding set, returning true if one\n  /// was removed or false if the node was not in the folding set.\n  bool RemoveNode(T *N) {\n    return FoldingSetBase::RemoveNode(N);\n  }\n\n  /// GetOrInsertNode - If there is an existing simple Node exactly\n  /// equal to the specified node, return it.  Otherwise, insert 'N' and\n  /// return it instead.\n  T *GetOrInsertNode(T *N) {\n    return static_cast<T *>(\n        FoldingSetBase::GetOrInsertNode(N, Derived::getFoldingSetInfo()));\n  }\n\n  /// FindNodeOrInsertPos - Look up the node specified by ID.  If it exists,\n  /// return it.  If not, return the insertion token that will make insertion\n  /// faster.\n  T *FindNodeOrInsertPos(const FoldingSetNodeID &ID, void *&InsertPos) {\n    return static_cast<T *>(FoldingSetBase::FindNodeOrInsertPos(\n        ID, InsertPos, Derived::getFoldingSetInfo()));\n  }\n\n  /// InsertNode - Insert the specified node into the folding set, knowing that\n  /// it is not already in the folding set.  InsertPos must be obtained from\n  /// FindNodeOrInsertPos.\n  void InsertNode(T *N, void *InsertPos) {\n    FoldingSetBase::InsertNode(N, InsertPos, Derived::getFoldingSetInfo());\n  }\n\n  /// InsertNode - Insert the specified node into the folding set, knowing that\n  /// it is not already in the folding set.\n  void InsertNode(T *N) {\n    T *Inserted = GetOrInsertNode(N);\n    (void)Inserted;\n    assert(Inserted == N && \"Node already inserted!\");\n  }\n};\n\n//===----------------------------------------------------------------------===//\n/// FoldingSet - This template class is used to instantiate a specialized\n/// implementation of the folding set to the node class T.  T must be a\n/// subclass of FoldingSetNode and implement a Profile function.\n///\n/// Note that this set type is movable and move-assignable. However, its\n/// moved-from state is not a valid state for anything other than\n/// move-assigning and destroying. This is primarily to enable movable APIs\n/// that incorporate these objects.\ntemplate <class T>\nclass FoldingSet : public FoldingSetImpl<FoldingSet<T>, T> {\n  using Super = FoldingSetImpl<FoldingSet, T>;\n  using Node = typename Super::Node;\n\n  /// GetNodeProfile - Each instantiation of the FoldingSet needs to provide a\n  /// way to convert nodes into a unique specifier.\n  static void GetNodeProfile(const FoldingSetBase *, Node *N,\n                             FoldingSetNodeID &ID) {\n    T *TN = static_cast<T *>(N);\n    FoldingSetTrait<T>::Profile(*TN, ID);\n  }\n\n  /// NodeEquals - Instantiations may optionally provide a way to compare a\n  /// node with a specified ID.\n  static bool NodeEquals(const FoldingSetBase *, Node *N,\n                         const FoldingSetNodeID &ID, unsigned IDHash,\n                         FoldingSetNodeID &TempID) {\n    T *TN = static_cast<T *>(N);\n    return FoldingSetTrait<T>::Equals(*TN, ID, IDHash, TempID);\n  }\n\n  /// ComputeNodeHash - Instantiations may optionally provide a way to compute a\n  /// hash value directly from a node.\n  static unsigned ComputeNodeHash(const FoldingSetBase *, Node *N,\n                                  FoldingSetNodeID &TempID) {\n    T *TN = static_cast<T *>(N);\n    return FoldingSetTrait<T>::ComputeHash(*TN, TempID);\n  }\n\n  static const FoldingSetBase::FoldingSetInfo &getFoldingSetInfo() {\n    static constexpr FoldingSetBase::FoldingSetInfo Info = {\n        GetNodeProfile, NodeEquals, ComputeNodeHash};\n    return Info;\n  }\n  friend Super;\n\npublic:\n  explicit FoldingSet(unsigned Log2InitSize = 6) : Super(Log2InitSize) {}\n  FoldingSet(FoldingSet &&Arg) = default;\n  FoldingSet &operator=(FoldingSet &&RHS) = default;\n};\n\n//===----------------------------------------------------------------------===//\n/// ContextualFoldingSet - This template class is a further refinement\n/// of FoldingSet which provides a context argument when calling\n/// Profile on its nodes.  Currently, that argument is fixed at\n/// initialization time.\n///\n/// T must be a subclass of FoldingSetNode and implement a Profile\n/// function with signature\n///   void Profile(FoldingSetNodeID &, Ctx);\ntemplate <class T, class Ctx>\nclass ContextualFoldingSet\n    : public FoldingSetImpl<ContextualFoldingSet<T, Ctx>, T> {\n  // Unfortunately, this can't derive from FoldingSet<T> because the\n  // construction of the vtable for FoldingSet<T> requires\n  // FoldingSet<T>::GetNodeProfile to be instantiated, which in turn\n  // requires a single-argument T::Profile().\n\n  using Super = FoldingSetImpl<ContextualFoldingSet, T>;\n  using Node = typename Super::Node;\n\n  Ctx Context;\n\n  static const Ctx &getContext(const FoldingSetBase *Base) {\n    return static_cast<const ContextualFoldingSet*>(Base)->Context;\n  }\n\n  /// GetNodeProfile - Each instantiatation of the FoldingSet needs to provide a\n  /// way to convert nodes into a unique specifier.\n  static void GetNodeProfile(const FoldingSetBase *Base, Node *N,\n                             FoldingSetNodeID &ID) {\n    T *TN = static_cast<T *>(N);\n    ContextualFoldingSetTrait<T, Ctx>::Profile(*TN, ID, getContext(Base));\n  }\n\n  static bool NodeEquals(const FoldingSetBase *Base, Node *N,\n                         const FoldingSetNodeID &ID, unsigned IDHash,\n                         FoldingSetNodeID &TempID) {\n    T *TN = static_cast<T *>(N);\n    return ContextualFoldingSetTrait<T, Ctx>::Equals(*TN, ID, IDHash, TempID,\n                                                     getContext(Base));\n  }\n\n  static unsigned ComputeNodeHash(const FoldingSetBase *Base, Node *N,\n                                  FoldingSetNodeID &TempID) {\n    T *TN = static_cast<T *>(N);\n    return ContextualFoldingSetTrait<T, Ctx>::ComputeHash(*TN, TempID,\n                                                          getContext(Base));\n  }\n\n  static const FoldingSetBase::FoldingSetInfo &getFoldingSetInfo() {\n    static constexpr FoldingSetBase::FoldingSetInfo Info = {\n        GetNodeProfile, NodeEquals, ComputeNodeHash};\n    return Info;\n  }\n  friend Super;\n\npublic:\n  explicit ContextualFoldingSet(Ctx Context, unsigned Log2InitSize = 6)\n      : Super(Log2InitSize), Context(Context) {}\n\n  Ctx getContext() const { return Context; }\n};\n\n//===----------------------------------------------------------------------===//\n/// FoldingSetVector - This template class combines a FoldingSet and a vector\n/// to provide the interface of FoldingSet but with deterministic iteration\n/// order based on the insertion order. T must be a subclass of FoldingSetNode\n/// and implement a Profile function.\ntemplate <class T, class VectorT = SmallVector<T*, 8>>\nclass FoldingSetVector {\n  FoldingSet<T> Set;\n  VectorT Vector;\n\npublic:\n  explicit FoldingSetVector(unsigned Log2InitSize = 6) : Set(Log2InitSize) {}\n\n  using iterator = pointee_iterator<typename VectorT::iterator>;\n\n  iterator begin() { return Vector.begin(); }\n  iterator end()   { return Vector.end(); }\n\n  using const_iterator = pointee_iterator<typename VectorT::const_iterator>;\n\n  const_iterator begin() const { return Vector.begin(); }\n  const_iterator end()   const { return Vector.end(); }\n\n  /// clear - Remove all nodes from the folding set.\n  void clear() { Set.clear(); Vector.clear(); }\n\n  /// FindNodeOrInsertPos - Look up the node specified by ID.  If it exists,\n  /// return it.  If not, return the insertion token that will make insertion\n  /// faster.\n  T *FindNodeOrInsertPos(const FoldingSetNodeID &ID, void *&InsertPos) {\n    return Set.FindNodeOrInsertPos(ID, InsertPos);\n  }\n\n  /// GetOrInsertNode - If there is an existing simple Node exactly\n  /// equal to the specified node, return it.  Otherwise, insert 'N' and\n  /// return it instead.\n  T *GetOrInsertNode(T *N) {\n    T *Result = Set.GetOrInsertNode(N);\n    if (Result == N) Vector.push_back(N);\n    return Result;\n  }\n\n  /// InsertNode - Insert the specified node into the folding set, knowing that\n  /// it is not already in the folding set.  InsertPos must be obtained from\n  /// FindNodeOrInsertPos.\n  void InsertNode(T *N, void *InsertPos) {\n    Set.InsertNode(N, InsertPos);\n    Vector.push_back(N);\n  }\n\n  /// InsertNode - Insert the specified node into the folding set, knowing that\n  /// it is not already in the folding set.\n  void InsertNode(T *N) {\n    Set.InsertNode(N);\n    Vector.push_back(N);\n  }\n\n  /// size - Returns the number of nodes in the folding set.\n  unsigned size() const { return Set.size(); }\n\n  /// empty - Returns true if there are no nodes in the folding set.\n  bool empty() const { return Set.empty(); }\n};\n\n//===----------------------------------------------------------------------===//\n/// FoldingSetIteratorImpl - This is the common iterator support shared by all\n/// folding sets, which knows how to walk the folding set hash table.\nclass FoldingSetIteratorImpl {\nprotected:\n  FoldingSetNode *NodePtr;\n\n  FoldingSetIteratorImpl(void **Bucket);\n\n  void advance();\n\npublic:\n  bool operator==(const FoldingSetIteratorImpl &RHS) const {\n    return NodePtr == RHS.NodePtr;\n  }\n  bool operator!=(const FoldingSetIteratorImpl &RHS) const {\n    return NodePtr != RHS.NodePtr;\n  }\n};\n\ntemplate <class T> class FoldingSetIterator : public FoldingSetIteratorImpl {\npublic:\n  explicit FoldingSetIterator(void **Bucket) : FoldingSetIteratorImpl(Bucket) {}\n\n  T &operator*() const {\n    return *static_cast<T*>(NodePtr);\n  }\n\n  T *operator->() const {\n    return static_cast<T*>(NodePtr);\n  }\n\n  inline FoldingSetIterator &operator++() {          // Preincrement\n    advance();\n    return *this;\n  }\n  FoldingSetIterator operator++(int) {        // Postincrement\n    FoldingSetIterator tmp = *this; ++*this; return tmp;\n  }\n};\n\n//===----------------------------------------------------------------------===//\n/// FoldingSetBucketIteratorImpl - This is the common bucket iterator support\n/// shared by all folding sets, which knows how to walk a particular bucket\n/// of a folding set hash table.\nclass FoldingSetBucketIteratorImpl {\nprotected:\n  void *Ptr;\n\n  explicit FoldingSetBucketIteratorImpl(void **Bucket);\n\n  FoldingSetBucketIteratorImpl(void **Bucket, bool) : Ptr(Bucket) {}\n\n  void advance() {\n    void *Probe = static_cast<FoldingSetNode*>(Ptr)->getNextInBucket();\n    uintptr_t x = reinterpret_cast<uintptr_t>(Probe) & ~0x1;\n    Ptr = reinterpret_cast<void*>(x);\n  }\n\npublic:\n  bool operator==(const FoldingSetBucketIteratorImpl &RHS) const {\n    return Ptr == RHS.Ptr;\n  }\n  bool operator!=(const FoldingSetBucketIteratorImpl &RHS) const {\n    return Ptr != RHS.Ptr;\n  }\n};\n\ntemplate <class T>\nclass FoldingSetBucketIterator : public FoldingSetBucketIteratorImpl {\npublic:\n  explicit FoldingSetBucketIterator(void **Bucket) :\n    FoldingSetBucketIteratorImpl(Bucket) {}\n\n  FoldingSetBucketIterator(void **Bucket, bool) :\n    FoldingSetBucketIteratorImpl(Bucket, true) {}\n\n  T &operator*() const { return *static_cast<T*>(Ptr); }\n  T *operator->() const { return static_cast<T*>(Ptr); }\n\n  inline FoldingSetBucketIterator &operator++() { // Preincrement\n    advance();\n    return *this;\n  }\n  FoldingSetBucketIterator operator++(int) {      // Postincrement\n    FoldingSetBucketIterator tmp = *this; ++*this; return tmp;\n  }\n};\n\n//===----------------------------------------------------------------------===//\n/// FoldingSetNodeWrapper - This template class is used to \"wrap\" arbitrary\n/// types in an enclosing object so that they can be inserted into FoldingSets.\ntemplate <typename T>\nclass FoldingSetNodeWrapper : public FoldingSetNode {\n  T data;\n\npublic:\n  template <typename... Ts>\n  explicit FoldingSetNodeWrapper(Ts &&... Args)\n      : data(std::forward<Ts>(Args)...) {}\n\n  void Profile(FoldingSetNodeID &ID) { FoldingSetTrait<T>::Profile(data, ID); }\n\n  T &getValue() { return data; }\n  const T &getValue() const { return data; }\n\n  operator T&() { return data; }\n  operator const T&() const { return data; }\n};\n\n//===----------------------------------------------------------------------===//\n/// FastFoldingSetNode - This is a subclass of FoldingSetNode which stores\n/// a FoldingSetNodeID value rather than requiring the node to recompute it\n/// each time it is needed. This trades space for speed (which can be\n/// significant if the ID is long), and it also permits nodes to drop\n/// information that would otherwise only be required for recomputing an ID.\nclass FastFoldingSetNode : public FoldingSetNode {\n  FoldingSetNodeID FastID;\n\nprotected:\n  explicit FastFoldingSetNode(const FoldingSetNodeID &ID) : FastID(ID) {}\n\npublic:\n  void Profile(FoldingSetNodeID &ID) const { ID.AddNodeID(FastID); }\n};\n\n//===----------------------------------------------------------------------===//\n// Partial specializations of FoldingSetTrait.\n\ntemplate<typename T> struct FoldingSetTrait<T*> {\n  static inline void Profile(T *X, FoldingSetNodeID &ID) {\n    ID.AddPointer(X);\n  }\n};\ntemplate <typename T1, typename T2>\nstruct FoldingSetTrait<std::pair<T1, T2>> {\n  static inline void Profile(const std::pair<T1, T2> &P,\n                             FoldingSetNodeID &ID) {\n    ID.Add(P.first);\n    ID.Add(P.second);\n  }\n};\n\n} // end namespace llvm\n\n#endif // LLVM_ADT_FOLDINGSET_H\n"}, "13": {"id": 13, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/PointerIntPair.h", "content": "//===- llvm/ADT/PointerIntPair.h - Pair for pointer and int -----*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// This file defines the PointerIntPair class.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_ADT_POINTERINTPAIR_H\n#define LLVM_ADT_POINTERINTPAIR_H\n\n#include \"llvm/Support/Compiler.h\"\n#include \"llvm/Support/PointerLikeTypeTraits.h\"\n#include \"llvm/Support/type_traits.h\"\n#include <cassert>\n#include <cstdint>\n#include <limits>\n\nnamespace llvm {\n\ntemplate <typename T> struct DenseMapInfo;\ntemplate <typename PointerT, unsigned IntBits, typename PtrTraits>\nstruct PointerIntPairInfo;\n\n/// PointerIntPair - This class implements a pair of a pointer and small\n/// integer.  It is designed to represent this in the space required by one\n/// pointer by bitmangling the integer into the low part of the pointer.  This\n/// can only be done for small integers: typically up to 3 bits, but it depends\n/// on the number of bits available according to PointerLikeTypeTraits for the\n/// type.\n///\n/// Note that PointerIntPair always puts the IntVal part in the highest bits\n/// possible.  For example, PointerIntPair<void*, 1, bool> will put the bit for\n/// the bool into bit #2, not bit #0, which allows the low two bits to be used\n/// for something else.  For example, this allows:\n///   PointerIntPair<PointerIntPair<void*, 1, bool>, 1, bool>\n/// ... and the two bools will land in different bits.\ntemplate <typename PointerTy, unsigned IntBits, typename IntType = unsigned,\n          typename PtrTraits = PointerLikeTypeTraits<PointerTy>,\n          typename Info = PointerIntPairInfo<PointerTy, IntBits, PtrTraits>>\nclass PointerIntPair {\n  // Used by MSVC visualizer and generally helpful for debugging/visualizing.\n  using InfoTy = Info;\n  intptr_t Value = 0;\n\npublic:\n  constexpr PointerIntPair() = default;\n\n  PointerIntPair(PointerTy PtrVal, IntType IntVal) {\n    setPointerAndInt(PtrVal, IntVal);\n  }\n\n  explicit PointerIntPair(PointerTy PtrVal) { initWithPointer(PtrVal); }\n\n  PointerTy getPointer() const { return Info::getPointer(Value); }\n\n  IntType getInt() const { return (IntType)Info::getInt(Value); }\n\n  void setPointer(PointerTy PtrVal) LLVM_LVALUE_FUNCTION {\n    Value = Info::updatePointer(Value, PtrVal);\n  }\n\n  void setInt(IntType IntVal) LLVM_LVALUE_FUNCTION {\n    Value = Info::updateInt(Value, static_cast<intptr_t>(IntVal));\n  }\n\n  void initWithPointer(PointerTy PtrVal) LLVM_LVALUE_FUNCTION {\n    Value = Info::updatePointer(0, PtrVal);\n  }\n\n  void setPointerAndInt(PointerTy PtrVal, IntType IntVal) LLVM_LVALUE_FUNCTION {\n    Value = Info::updateInt(Info::updatePointer(0, PtrVal),\n                            static_cast<intptr_t>(IntVal));\n  }\n\n  PointerTy const *getAddrOfPointer() const {\n    return const_cast<PointerIntPair *>(this)->getAddrOfPointer();\n  }\n\n  PointerTy *getAddrOfPointer() {\n    assert(Value == reinterpret_cast<intptr_t>(getPointer()) &&\n           \"Can only return the address if IntBits is cleared and \"\n           \"PtrTraits doesn't change the pointer\");\n    return reinterpret_cast<PointerTy *>(&Value);\n  }\n\n  void *getOpaqueValue() const { return reinterpret_cast<void *>(Value); }\n\n  void setFromOpaqueValue(void *Val) LLVM_LVALUE_FUNCTION {\n    Value = reinterpret_cast<intptr_t>(Val);\n  }\n\n  static PointerIntPair getFromOpaqueValue(void *V) {\n    PointerIntPair P;\n    P.setFromOpaqueValue(V);\n    return P;\n  }\n\n  // Allow PointerIntPairs to be created from const void * if and only if the\n  // pointer type could be created from a const void *.\n  static PointerIntPair getFromOpaqueValue(const void *V) {\n    (void)PtrTraits::getFromVoidPointer(V);\n    return getFromOpaqueValue(const_cast<void *>(V));\n  }\n\n  bool operator==(const PointerIntPair &RHS) const {\n    return Value == RHS.Value;\n  }\n\n  bool operator!=(const PointerIntPair &RHS) const {\n    return Value != RHS.Value;\n  }\n\n  bool operator<(const PointerIntPair &RHS) const { return Value < RHS.Value; }\n  bool operator>(const PointerIntPair &RHS) const { return Value > RHS.Value; }\n\n  bool operator<=(const PointerIntPair &RHS) const {\n    return Value <= RHS.Value;\n  }\n\n  bool operator>=(const PointerIntPair &RHS) const {\n    return Value >= RHS.Value;\n  }\n};\n\n// Specialize is_trivially_copyable to avoid limitation of llvm::is_trivially_copyable\n// when compiled with gcc 4.9.\ntemplate <typename PointerTy, unsigned IntBits, typename IntType,\n          typename PtrTraits,\n          typename Info>\nstruct is_trivially_copyable<PointerIntPair<PointerTy, IntBits, IntType, PtrTraits, Info>> : std::true_type {\n#ifdef HAVE_STD_IS_TRIVIALLY_COPYABLE\n  static_assert(std::is_trivially_copyable<PointerIntPair<PointerTy, IntBits, IntType, PtrTraits, Info>>::value,\n                \"inconsistent behavior between llvm:: and std:: implementation of is_trivially_copyable\");\n#endif\n};\n\n\ntemplate <typename PointerT, unsigned IntBits, typename PtrTraits>\nstruct PointerIntPairInfo {\n  static_assert(PtrTraits::NumLowBitsAvailable <\n                    std::numeric_limits<uintptr_t>::digits,\n                \"cannot use a pointer type that has all bits free\");\n  static_assert(IntBits <= PtrTraits::NumLowBitsAvailable,\n                \"PointerIntPair with integer size too large for pointer\");\n  enum MaskAndShiftConstants : uintptr_t {\n    /// PointerBitMask - The bits that come from the pointer.\n    PointerBitMask =\n        ~(uintptr_t)(((intptr_t)1 << PtrTraits::NumLowBitsAvailable) - 1),\n\n    /// IntShift - The number of low bits that we reserve for other uses, and\n    /// keep zero.\n    IntShift = (uintptr_t)PtrTraits::NumLowBitsAvailable - IntBits,\n\n    /// IntMask - This is the unshifted mask for valid bits of the int type.\n    IntMask = (uintptr_t)(((intptr_t)1 << IntBits) - 1),\n\n    // ShiftedIntMask - This is the bits for the integer shifted in place.\n    ShiftedIntMask = (uintptr_t)(IntMask << IntShift)\n  };\n\n  static PointerT getPointer(intptr_t Value) {\n    return PtrTraits::getFromVoidPointer(\n        reinterpret_cast<void *>(Value & PointerBitMask));\n  }\n\n  static intptr_t getInt(intptr_t Value) {\n    return (Value >> IntShift) & IntMask;\n  }\n\n  static intptr_t updatePointer(intptr_t OrigValue, PointerT Ptr) {\n    intptr_t PtrWord =\n        reinterpret_cast<intptr_t>(PtrTraits::getAsVoidPointer(Ptr));\n    assert((PtrWord & ~PointerBitMask) == 0 &&\n           \"Pointer is not sufficiently aligned\");\n    // Preserve all low bits, just update the pointer.\n    return PtrWord | (OrigValue & ~PointerBitMask);\n  }\n\n  static intptr_t updateInt(intptr_t OrigValue, intptr_t Int) {\n    intptr_t IntWord = static_cast<intptr_t>(Int);\n    assert((IntWord & ~IntMask) == 0 && \"Integer too large for field\");\n\n    // Preserve all bits other than the ones we are updating.\n    return (OrigValue & ~ShiftedIntMask) | IntWord << IntShift;\n  }\n};\n\n// Provide specialization of DenseMapInfo for PointerIntPair.\ntemplate <typename PointerTy, unsigned IntBits, typename IntType>\nstruct DenseMapInfo<PointerIntPair<PointerTy, IntBits, IntType>> {\n  using Ty = PointerIntPair<PointerTy, IntBits, IntType>;\n\n  static Ty getEmptyKey() {\n    uintptr_t Val = static_cast<uintptr_t>(-1);\n    Val <<= PointerLikeTypeTraits<Ty>::NumLowBitsAvailable;\n    return Ty::getFromOpaqueValue(reinterpret_cast<void *>(Val));\n  }\n\n  static Ty getTombstoneKey() {\n    uintptr_t Val = static_cast<uintptr_t>(-2);\n    Val <<= PointerLikeTypeTraits<PointerTy>::NumLowBitsAvailable;\n    return Ty::getFromOpaqueValue(reinterpret_cast<void *>(Val));\n  }\n\n  static unsigned getHashValue(Ty V) {\n    uintptr_t IV = reinterpret_cast<uintptr_t>(V.getOpaqueValue());\n    return unsigned(IV) ^ unsigned(IV >> 9);\n  }\n\n  static bool isEqual(const Ty &LHS, const Ty &RHS) { return LHS == RHS; }\n};\n\n// Teach SmallPtrSet that PointerIntPair is \"basically a pointer\".\ntemplate <typename PointerTy, unsigned IntBits, typename IntType,\n          typename PtrTraits>\nstruct PointerLikeTypeTraits<\n    PointerIntPair<PointerTy, IntBits, IntType, PtrTraits>> {\n  static inline void *\n  getAsVoidPointer(const PointerIntPair<PointerTy, IntBits, IntType> &P) {\n    return P.getOpaqueValue();\n  }\n\n  static inline PointerIntPair<PointerTy, IntBits, IntType>\n  getFromVoidPointer(void *P) {\n    return PointerIntPair<PointerTy, IntBits, IntType>::getFromOpaqueValue(P);\n  }\n\n  static inline PointerIntPair<PointerTy, IntBits, IntType>\n  getFromVoidPointer(const void *P) {\n    return PointerIntPair<PointerTy, IntBits, IntType>::getFromOpaqueValue(P);\n  }\n\n  static constexpr int NumLowBitsAvailable =\n      PtrTraits::NumLowBitsAvailable - IntBits;\n};\n\n} // end namespace llvm\n\n#endif // LLVM_ADT_POINTERINTPAIR_H\n"}, "14": {"id": 14, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/PointerUnion.h", "content": "//===- llvm/ADT/PointerUnion.h - Discriminated Union of 2 Ptrs --*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// This file defines the PointerUnion class, which is a discriminated union of\n// pointer types.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_ADT_POINTERUNION_H\n#define LLVM_ADT_POINTERUNION_H\n\n#include \"llvm/ADT/DenseMapInfo.h\"\n#include \"llvm/ADT/PointerIntPair.h\"\n#include \"llvm/Support/PointerLikeTypeTraits.h\"\n#include <cassert>\n#include <cstddef>\n#include <cstdint>\n\nnamespace llvm {\n\ntemplate <typename T> struct PointerUnionTypeSelectorReturn {\n  using Return = T;\n};\n\n/// Get a type based on whether two types are the same or not.\n///\n/// For:\n///\n/// \\code\n///   using Ret = typename PointerUnionTypeSelector<T1, T2, EQ, NE>::Return;\n/// \\endcode\n///\n/// Ret will be EQ type if T1 is same as T2 or NE type otherwise.\ntemplate <typename T1, typename T2, typename RET_EQ, typename RET_NE>\nstruct PointerUnionTypeSelector {\n  using Return = typename PointerUnionTypeSelectorReturn<RET_NE>::Return;\n};\n\ntemplate <typename T, typename RET_EQ, typename RET_NE>\nstruct PointerUnionTypeSelector<T, T, RET_EQ, RET_NE> {\n  using Return = typename PointerUnionTypeSelectorReturn<RET_EQ>::Return;\n};\n\ntemplate <typename T1, typename T2, typename RET_EQ, typename RET_NE>\nstruct PointerUnionTypeSelectorReturn<\n    PointerUnionTypeSelector<T1, T2, RET_EQ, RET_NE>> {\n  using Return =\n      typename PointerUnionTypeSelector<T1, T2, RET_EQ, RET_NE>::Return;\n};\n\nnamespace pointer_union_detail {\n  /// Determine the number of bits required to store integers with values < n.\n  /// This is ceil(log2(n)).\n  constexpr int bitsRequired(unsigned n) {\n    return n > 1 ? 1 + bitsRequired((n + 1) / 2) : 0;\n  }\n\n  template <typename... Ts> constexpr int lowBitsAvailable() {\n    return std::min<int>({PointerLikeTypeTraits<Ts>::NumLowBitsAvailable...});\n  }\n\n  /// Find the index of a type in a list of types. TypeIndex<T, Us...>::Index\n  /// is the index of T in Us, or sizeof...(Us) if T does not appear in the\n  /// list.\n  template <typename T, typename ...Us> struct TypeIndex;\n  template <typename T, typename ...Us> struct TypeIndex<T, T, Us...> {\n    static constexpr int Index = 0;\n  };\n  template <typename T, typename U, typename... Us>\n  struct TypeIndex<T, U, Us...> {\n    static constexpr int Index = 1 + TypeIndex<T, Us...>::Index;\n  };\n  template <typename T> struct TypeIndex<T> {\n    static constexpr int Index = 0;\n  };\n\n  /// Find the first type in a list of types.\n  template <typename T, typename...> struct GetFirstType {\n    using type = T;\n  };\n\n  /// Provide PointerLikeTypeTraits for void* that is used by PointerUnion\n  /// for the template arguments.\n  template <typename ...PTs> class PointerUnionUIntTraits {\n  public:\n    static inline void *getAsVoidPointer(void *P) { return P; }\n    static inline void *getFromVoidPointer(void *P) { return P; }\n    static constexpr int NumLowBitsAvailable = lowBitsAvailable<PTs...>();\n  };\n\n  template <typename Derived, typename ValTy, int I, typename ...Types>\n  class PointerUnionMembers;\n\n  template <typename Derived, typename ValTy, int I>\n  class PointerUnionMembers<Derived, ValTy, I> {\n  protected:\n    ValTy Val;\n    PointerUnionMembers() = default;\n    PointerUnionMembers(ValTy Val) : Val(Val) {}\n\n    friend struct PointerLikeTypeTraits<Derived>;\n  };\n\n  template <typename Derived, typename ValTy, int I, typename Type,\n            typename ...Types>\n  class PointerUnionMembers<Derived, ValTy, I, Type, Types...>\n      : public PointerUnionMembers<Derived, ValTy, I + 1, Types...> {\n    using Base = PointerUnionMembers<Derived, ValTy, I + 1, Types...>;\n  public:\n    using Base::Base;\n    PointerUnionMembers() = default;\n    PointerUnionMembers(Type V)\n        : Base(ValTy(const_cast<void *>(\n                         PointerLikeTypeTraits<Type>::getAsVoidPointer(V)),\n                     I)) {}\n\n    using Base::operator=;\n    Derived &operator=(Type V) {\n      this->Val = ValTy(\n          const_cast<void *>(PointerLikeTypeTraits<Type>::getAsVoidPointer(V)),\n          I);\n      return static_cast<Derived &>(*this);\n    };\n  };\n}\n\n/// A discriminated union of two or more pointer types, with the discriminator\n/// in the low bit of the pointer.\n///\n/// This implementation is extremely efficient in space due to leveraging the\n/// low bits of the pointer, while exposing a natural and type-safe API.\n///\n/// Common use patterns would be something like this:\n///    PointerUnion<int*, float*> P;\n///    P = (int*)0;\n///    printf(\"%d %d\", P.is<int*>(), P.is<float*>());  // prints \"1 0\"\n///    X = P.get<int*>();     // ok.\n///    Y = P.get<float*>();   // runtime assertion failure.\n///    Z = P.get<double*>();  // compile time failure.\n///    P = (float*)0;\n///    Y = P.get<float*>();   // ok.\n///    X = P.get<int*>();     // runtime assertion failure.\ntemplate <typename... PTs>\nclass PointerUnion\n    : public pointer_union_detail::PointerUnionMembers<\n          PointerUnion<PTs...>,\n          PointerIntPair<\n              void *, pointer_union_detail::bitsRequired(sizeof...(PTs)), int,\n              pointer_union_detail::PointerUnionUIntTraits<PTs...>>,\n          0, PTs...> {\n  // The first type is special because we want to directly cast a pointer to a\n  // default-initialized union to a pointer to the first type. But we don't\n  // want PointerUnion to be a 'template <typename First, typename ...Rest>'\n  // because it's much more convenient to have a name for the whole pack. So\n  // split off the first type here.\n  using First = typename pointer_union_detail::GetFirstType<PTs...>::type;\n  using Base = typename PointerUnion::PointerUnionMembers;\n\npublic:\n  PointerUnion() = default;\n\n  PointerUnion(std::nullptr_t) : PointerUnion() {}\n  using Base::Base;\n\n  /// Test if the pointer held in the union is null, regardless of\n  /// which type it is.\n  bool isNull() const { return !this->Val.getPointer(); }\n\n  explicit operator bool() const { return !isNull(); }\n\n  /// Test if the Union currently holds the type matching T.\n  template <typename T> bool is() const {\n    constexpr int Index = pointer_union_detail::TypeIndex<T, PTs...>::Index;\n    static_assert(Index < sizeof...(PTs),\n                  \"PointerUnion::is<T> given type not in the union\");\n    return this->Val.getInt() == Index;\n  }\n\n  /// Returns the value of the specified pointer type.\n  ///\n  /// If the specified pointer type is incorrect, assert.\n  template <typename T> T get() const {\n    assert(is<T>() && \"Invalid accessor called\");\n    return PointerLikeTypeTraits<T>::getFromVoidPointer(this->Val.getPointer());\n  }\n\n  /// Returns the current pointer if it is of the specified pointer type,\n  /// otherwise returns null.\n  template <typename T> T dyn_cast() const {\n    if (is<T>())\n      return get<T>();\n    return T();\n  }\n\n  /// If the union is set to the first pointer type get an address pointing to\n  /// it.\n  First const *getAddrOfPtr1() const {\n    return const_cast<PointerUnion *>(this)->getAddrOfPtr1();\n  }\n\n  /// If the union is set to the first pointer type get an address pointing to\n  /// it.\n  First *getAddrOfPtr1() {\n    assert(is<First>() && \"Val is not the first pointer\");\n    assert(\n        PointerLikeTypeTraits<First>::getAsVoidPointer(get<First>()) ==\n            this->Val.getPointer() &&\n        \"Can't get the address because PointerLikeTypeTraits changes the ptr\");\n    return const_cast<First *>(\n        reinterpret_cast<const First *>(this->Val.getAddrOfPointer()));\n  }\n\n  /// Assignment from nullptr which just clears the union.\n  const PointerUnion &operator=(std::nullptr_t) {\n    this->Val.initWithPointer(nullptr);\n    return *this;\n  }\n\n  /// Assignment from elements of the union.\n  using Base::operator=;\n\n  void *getOpaqueValue() const { return this->Val.getOpaqueValue(); }\n  static inline PointerUnion getFromOpaqueValue(void *VP) {\n    PointerUnion V;\n    V.Val = decltype(V.Val)::getFromOpaqueValue(VP);\n    return V;\n  }\n};\n\ntemplate <typename ...PTs>\nbool operator==(PointerUnion<PTs...> lhs, PointerUnion<PTs...> rhs) {\n  return lhs.getOpaqueValue() == rhs.getOpaqueValue();\n}\n\ntemplate <typename ...PTs>\nbool operator!=(PointerUnion<PTs...> lhs, PointerUnion<PTs...> rhs) {\n  return lhs.getOpaqueValue() != rhs.getOpaqueValue();\n}\n\ntemplate <typename ...PTs>\nbool operator<(PointerUnion<PTs...> lhs, PointerUnion<PTs...> rhs) {\n  return lhs.getOpaqueValue() < rhs.getOpaqueValue();\n}\n\n// Teach SmallPtrSet that PointerUnion is \"basically a pointer\", that has\n// # low bits available = min(PT1bits,PT2bits)-1.\ntemplate <typename ...PTs>\nstruct PointerLikeTypeTraits<PointerUnion<PTs...>> {\n  static inline void *getAsVoidPointer(const PointerUnion<PTs...> &P) {\n    return P.getOpaqueValue();\n  }\n\n  static inline PointerUnion<PTs...> getFromVoidPointer(void *P) {\n    return PointerUnion<PTs...>::getFromOpaqueValue(P);\n  }\n\n  // The number of bits available are the min of the pointer types minus the\n  // bits needed for the discriminator.\n  static constexpr int NumLowBitsAvailable = PointerLikeTypeTraits<decltype(\n      PointerUnion<PTs...>::Val)>::NumLowBitsAvailable;\n};\n\n// Teach DenseMap how to use PointerUnions as keys.\ntemplate <typename ...PTs> struct DenseMapInfo<PointerUnion<PTs...>> {\n  using Union = PointerUnion<PTs...>;\n  using FirstInfo =\n      DenseMapInfo<typename pointer_union_detail::GetFirstType<PTs...>::type>;\n\n  static inline Union getEmptyKey() { return Union(FirstInfo::getEmptyKey()); }\n\n  static inline Union getTombstoneKey() {\n    return Union(FirstInfo::getTombstoneKey());\n  }\n\n  static unsigned getHashValue(const Union &UnionVal) {\n    intptr_t key = (intptr_t)UnionVal.getOpaqueValue();\n    return DenseMapInfo<intptr_t>::getHashValue(key);\n  }\n\n  static bool isEqual(const Union &LHS, const Union &RHS) {\n    return LHS == RHS;\n  }\n};\n\n} // end namespace llvm\n\n#endif // LLVM_ADT_POINTERUNION_H\n"}, "19": {"id": 19, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/iterator.h", "content": "//===- iterator.h - Utilities for using and defining iterators --*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_ADT_ITERATOR_H\n#define LLVM_ADT_ITERATOR_H\n\n#include \"llvm/ADT/iterator_range.h\"\n#include <algorithm>\n#include <cstddef>\n#include <iterator>\n#include <type_traits>\n#include <utility>\n\nnamespace llvm {\n\n/// CRTP base class which implements the entire standard iterator facade\n/// in terms of a minimal subset of the interface.\n///\n/// Use this when it is reasonable to implement most of the iterator\n/// functionality in terms of a core subset. If you need special behavior or\n/// there are performance implications for this, you may want to override the\n/// relevant members instead.\n///\n/// Note, one abstraction that this does *not* provide is implementing\n/// subtraction in terms of addition by negating the difference. Negation isn't\n/// always information preserving, and I can see very reasonable iterator\n/// designs where this doesn't work well. It doesn't really force much added\n/// boilerplate anyways.\n///\n/// Another abstraction that this doesn't provide is implementing increment in\n/// terms of addition of one. These aren't equivalent for all iterator\n/// categories, and respecting that adds a lot of complexity for little gain.\n///\n/// Classes wishing to use `iterator_facade_base` should implement the following\n/// methods:\n///\n/// Forward Iterators:\n///   (All of the following methods)\n///   - DerivedT &operator=(const DerivedT &R);\n///   - bool operator==(const DerivedT &R) const;\n///   - const T &operator*() const;\n///   - T &operator*();\n///   - DerivedT &operator++();\n///\n/// Bidirectional Iterators:\n///   (All methods of forward iterators, plus the following)\n///   - DerivedT &operator--();\n///\n/// Random-access Iterators:\n///   (All methods of bidirectional iterators excluding the following)\n///   - DerivedT &operator++();\n///   - DerivedT &operator--();\n///   (and plus the following)\n///   - bool operator<(const DerivedT &RHS) const;\n///   - DifferenceTypeT operator-(const DerivedT &R) const;\n///   - DerivedT &operator+=(DifferenceTypeT N);\n///   - DerivedT &operator-=(DifferenceTypeT N);\n///\ntemplate <typename DerivedT, typename IteratorCategoryT, typename T,\n          typename DifferenceTypeT = std::ptrdiff_t, typename PointerT = T *,\n          typename ReferenceT = T &>\nclass iterator_facade_base\n    : public std::iterator<IteratorCategoryT, T, DifferenceTypeT, PointerT,\n                           ReferenceT> {\nprotected:\n  enum {\n    IsRandomAccess = std::is_base_of<std::random_access_iterator_tag,\n                                     IteratorCategoryT>::value,\n    IsBidirectional = std::is_base_of<std::bidirectional_iterator_tag,\n                                      IteratorCategoryT>::value,\n  };\n\n  /// A proxy object for computing a reference via indirecting a copy of an\n  /// iterator. This is used in APIs which need to produce a reference via\n  /// indirection but for which the iterator object might be a temporary. The\n  /// proxy preserves the iterator internally and exposes the indirected\n  /// reference via a conversion operator.\n  class ReferenceProxy {\n    friend iterator_facade_base;\n\n    DerivedT I;\n\n    ReferenceProxy(DerivedT I) : I(std::move(I)) {}\n\n  public:\n    operator ReferenceT() const { return *I; }\n  };\n\npublic:\n  DerivedT operator+(DifferenceTypeT n) const {\n    static_assert(std::is_base_of<iterator_facade_base, DerivedT>::value,\n                  \"Must pass the derived type to this template!\");\n    static_assert(\n        IsRandomAccess,\n        \"The '+' operator is only defined for random access iterators.\");\n    DerivedT tmp = *static_cast<const DerivedT *>(this);\n    tmp += n;\n    return tmp;\n  }\n  friend DerivedT operator+(DifferenceTypeT n, const DerivedT &i) {\n    static_assert(\n        IsRandomAccess,\n        \"The '+' operator is only defined for random access iterators.\");\n    return i + n;\n  }\n  DerivedT operator-(DifferenceTypeT n) const {\n    static_assert(\n        IsRandomAccess,\n        \"The '-' operator is only defined for random access iterators.\");\n    DerivedT tmp = *static_cast<const DerivedT *>(this);\n    tmp -= n;\n    return tmp;\n  }\n\n  DerivedT &operator++() {\n    static_assert(std::is_base_of<iterator_facade_base, DerivedT>::value,\n                  \"Must pass the derived type to this template!\");\n    return static_cast<DerivedT *>(this)->operator+=(1);\n  }\n  DerivedT operator++(int) {\n    DerivedT tmp = *static_cast<DerivedT *>(this);\n    ++*static_cast<DerivedT *>(this);\n    return tmp;\n  }\n  DerivedT &operator--() {\n    static_assert(\n        IsBidirectional,\n        \"The decrement operator is only defined for bidirectional iterators.\");\n    return static_cast<DerivedT *>(this)->operator-=(1);\n  }\n  DerivedT operator--(int) {\n    static_assert(\n        IsBidirectional,\n        \"The decrement operator is only defined for bidirectional iterators.\");\n    DerivedT tmp = *static_cast<DerivedT *>(this);\n    --*static_cast<DerivedT *>(this);\n    return tmp;\n  }\n\n#ifndef __cpp_impl_three_way_comparison\n  bool operator!=(const DerivedT &RHS) const {\n    return !(static_cast<const DerivedT &>(*this) == RHS);\n  }\n#endif\n\n  bool operator>(const DerivedT &RHS) const {\n    static_assert(\n        IsRandomAccess,\n        \"Relational operators are only defined for random access iterators.\");\n    return !(static_cast<const DerivedT &>(*this) < RHS) &&\n           !(static_cast<const DerivedT &>(*this) == RHS);\n  }\n  bool operator<=(const DerivedT &RHS) const {\n    static_assert(\n        IsRandomAccess,\n        \"Relational operators are only defined for random access iterators.\");\n    return !(static_cast<const DerivedT &>(*this) > RHS);\n  }\n  bool operator>=(const DerivedT &RHS) const {\n    static_assert(\n        IsRandomAccess,\n        \"Relational operators are only defined for random access iterators.\");\n    return !(static_cast<const DerivedT &>(*this) < RHS);\n  }\n\n  PointerT operator->() { return &static_cast<DerivedT *>(this)->operator*(); }\n  PointerT operator->() const {\n    return &static_cast<const DerivedT *>(this)->operator*();\n  }\n  ReferenceProxy operator[](DifferenceTypeT n) {\n    static_assert(IsRandomAccess,\n                  \"Subscripting is only defined for random access iterators.\");\n    return ReferenceProxy(static_cast<DerivedT *>(this)->operator+(n));\n  }\n  ReferenceProxy operator[](DifferenceTypeT n) const {\n    static_assert(IsRandomAccess,\n                  \"Subscripting is only defined for random access iterators.\");\n    return ReferenceProxy(static_cast<const DerivedT *>(this)->operator+(n));\n  }\n};\n\n/// CRTP base class for adapting an iterator to a different type.\n///\n/// This class can be used through CRTP to adapt one iterator into another.\n/// Typically this is done through providing in the derived class a custom \\c\n/// operator* implementation. Other methods can be overridden as well.\ntemplate <\n    typename DerivedT, typename WrappedIteratorT,\n    typename IteratorCategoryT =\n        typename std::iterator_traits<WrappedIteratorT>::iterator_category,\n    typename T = typename std::iterator_traits<WrappedIteratorT>::value_type,\n    typename DifferenceTypeT =\n        typename std::iterator_traits<WrappedIteratorT>::difference_type,\n    typename PointerT = std::conditional_t<\n        std::is_same<T, typename std::iterator_traits<\n                            WrappedIteratorT>::value_type>::value,\n        typename std::iterator_traits<WrappedIteratorT>::pointer, T *>,\n    typename ReferenceT = std::conditional_t<\n        std::is_same<T, typename std::iterator_traits<\n                            WrappedIteratorT>::value_type>::value,\n        typename std::iterator_traits<WrappedIteratorT>::reference, T &>>\nclass iterator_adaptor_base\n    : public iterator_facade_base<DerivedT, IteratorCategoryT, T,\n                                  DifferenceTypeT, PointerT, ReferenceT> {\n  using BaseT = typename iterator_adaptor_base::iterator_facade_base;\n\nprotected:\n  WrappedIteratorT I;\n\n  iterator_adaptor_base() = default;\n\n  explicit iterator_adaptor_base(WrappedIteratorT u) : I(std::move(u)) {\n    static_assert(std::is_base_of<iterator_adaptor_base, DerivedT>::value,\n                  \"Must pass the derived type to this template!\");\n  }\n\n  const WrappedIteratorT &wrapped() const { return I; }\n\npublic:\n  using difference_type = DifferenceTypeT;\n\n  DerivedT &operator+=(difference_type n) {\n    static_assert(\n        BaseT::IsRandomAccess,\n        \"The '+=' operator is only defined for random access iterators.\");\n    I += n;\n    return *static_cast<DerivedT *>(this);\n  }\n  DerivedT &operator-=(difference_type n) {\n    static_assert(\n        BaseT::IsRandomAccess,\n        \"The '-=' operator is only defined for random access iterators.\");\n    I -= n;\n    return *static_cast<DerivedT *>(this);\n  }\n  using BaseT::operator-;\n  difference_type operator-(const DerivedT &RHS) const {\n    static_assert(\n        BaseT::IsRandomAccess,\n        \"The '-' operator is only defined for random access iterators.\");\n    return I - RHS.I;\n  }\n\n  // We have to explicitly provide ++ and -- rather than letting the facade\n  // forward to += because WrappedIteratorT might not support +=.\n  using BaseT::operator++;\n  DerivedT &operator++() {\n    ++I;\n    return *static_cast<DerivedT *>(this);\n  }\n  using BaseT::operator--;\n  DerivedT &operator--() {\n    static_assert(\n        BaseT::IsBidirectional,\n        \"The decrement operator is only defined for bidirectional iterators.\");\n    --I;\n    return *static_cast<DerivedT *>(this);\n  }\n\n  friend bool operator==(const iterator_adaptor_base &LHS,\n                         const iterator_adaptor_base &RHS) {\n    return LHS.I == RHS.I;\n  }\n  friend bool operator<(const iterator_adaptor_base &LHS,\n                        const iterator_adaptor_base &RHS) {\n    static_assert(\n        BaseT::IsRandomAccess,\n        \"Relational operators are only defined for random access iterators.\");\n    return LHS.I < RHS.I;\n  }\n\n  ReferenceT operator*() const { return *I; }\n};\n\n/// An iterator type that allows iterating over the pointees via some\n/// other iterator.\n///\n/// The typical usage of this is to expose a type that iterates over Ts, but\n/// which is implemented with some iterator over T*s:\n///\n/// \\code\n///   using iterator = pointee_iterator<SmallVectorImpl<T *>::iterator>;\n/// \\endcode\ntemplate <typename WrappedIteratorT,\n          typename T = std::remove_reference_t<decltype(\n              **std::declval<WrappedIteratorT>())>>\nstruct pointee_iterator\n    : iterator_adaptor_base<\n          pointee_iterator<WrappedIteratorT, T>, WrappedIteratorT,\n          typename std::iterator_traits<WrappedIteratorT>::iterator_category,\n          T> {\n  pointee_iterator() = default;\n  template <typename U>\n  pointee_iterator(U &&u)\n      : pointee_iterator::iterator_adaptor_base(std::forward<U &&>(u)) {}\n\n  T &operator*() const { return **this->I; }\n};\n\ntemplate <typename RangeT, typename WrappedIteratorT =\n                               decltype(std::begin(std::declval<RangeT>()))>\niterator_range<pointee_iterator<WrappedIteratorT>>\nmake_pointee_range(RangeT &&Range) {\n  using PointeeIteratorT = pointee_iterator<WrappedIteratorT>;\n  return make_range(PointeeIteratorT(std::begin(std::forward<RangeT>(Range))),\n                    PointeeIteratorT(std::end(std::forward<RangeT>(Range))));\n}\n\ntemplate <typename WrappedIteratorT,\n          typename T = decltype(&*std::declval<WrappedIteratorT>())>\nclass pointer_iterator\n    : public iterator_adaptor_base<\n          pointer_iterator<WrappedIteratorT, T>, WrappedIteratorT,\n          typename std::iterator_traits<WrappedIteratorT>::iterator_category,\n          T> {\n  mutable T Ptr;\n\npublic:\n  pointer_iterator() = default;\n\n  explicit pointer_iterator(WrappedIteratorT u)\n      : pointer_iterator::iterator_adaptor_base(std::move(u)) {}\n\n  T &operator*() { return Ptr = &*this->I; }\n  const T &operator*() const { return Ptr = &*this->I; }\n};\n\ntemplate <typename RangeT, typename WrappedIteratorT =\n                               decltype(std::begin(std::declval<RangeT>()))>\niterator_range<pointer_iterator<WrappedIteratorT>>\nmake_pointer_range(RangeT &&Range) {\n  using PointerIteratorT = pointer_iterator<WrappedIteratorT>;\n  return make_range(PointerIteratorT(std::begin(std::forward<RangeT>(Range))),\n                    PointerIteratorT(std::end(std::forward<RangeT>(Range))));\n}\n\ntemplate <typename WrappedIteratorT,\n          typename T1 = std::remove_reference_t<decltype(\n              **std::declval<WrappedIteratorT>())>,\n          typename T2 = std::add_pointer_t<T1>>\nusing raw_pointer_iterator =\n    pointer_iterator<pointee_iterator<WrappedIteratorT, T1>, T2>;\n\n// Wrapper iterator over iterator ItType, adding DataRef to the type of ItType,\n// to create NodeRef = std::pair<InnerTypeOfItType, DataRef>.\ntemplate <typename ItType, typename NodeRef, typename DataRef>\nclass WrappedPairNodeDataIterator\n    : public iterator_adaptor_base<\n          WrappedPairNodeDataIterator<ItType, NodeRef, DataRef>, ItType,\n          typename std::iterator_traits<ItType>::iterator_category, NodeRef,\n          std::ptrdiff_t, NodeRef *, NodeRef &> {\n  using BaseT = iterator_adaptor_base<\n      WrappedPairNodeDataIterator, ItType,\n      typename std::iterator_traits<ItType>::iterator_category, NodeRef,\n      std::ptrdiff_t, NodeRef *, NodeRef &>;\n\n  const DataRef DR;\n  mutable NodeRef NR;\n\npublic:\n  WrappedPairNodeDataIterator(ItType Begin, const DataRef DR)\n      : BaseT(Begin), DR(DR) {\n    NR.first = DR;\n  }\n\n  NodeRef &operator*() const {\n    NR.second = *this->I;\n    return NR;\n  }\n};\n\n} // end namespace llvm\n\n#endif // LLVM_ADT_ITERATOR_H\n"}, "22": {"id": 22, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/CodeGen/AccelTable.h", "content": "//==- include/llvm/CodeGen/AccelTable.h - Accelerator Tables -----*- C++ -*-==//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// This file contains support for writing accelerator tables.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_CODEGEN_ACCELTABLE_H\n#define LLVM_CODEGEN_ACCELTABLE_H\n\n#include \"llvm/ADT/ArrayRef.h\"\n#include \"llvm/ADT/SmallVector.h\"\n#include \"llvm/ADT/StringMap.h\"\n#include \"llvm/ADT/StringRef.h\"\n#include \"llvm/BinaryFormat/Dwarf.h\"\n#include \"llvm/CodeGen/DIE.h\"\n#include \"llvm/CodeGen/DwarfStringPoolEntry.h\"\n#include \"llvm/MC/MCSymbol.h\"\n#include \"llvm/Support/Allocator.h\"\n#include \"llvm/Support/DJB.h\"\n#include \"llvm/Support/Debug.h\"\n#include \"llvm/Support/Format.h\"\n#include \"llvm/Support/raw_ostream.h\"\n#include <cstddef>\n#include <cstdint>\n#include <vector>\n\n/// The DWARF and Apple accelerator tables are an indirect hash table optimized\n/// for null lookup rather than access to known data. The Apple accelerator\n/// tables are a precursor of the newer DWARF v5 accelerator tables. Both\n/// formats share common design ideas.\n///\n/// The Apple accelerator table are output into an on-disk format that looks\n/// like this:\n///\n/// .------------------.\n/// |  HEADER          |\n/// |------------------|\n/// |  BUCKETS         |\n/// |------------------|\n/// |  HASHES          |\n/// |------------------|\n/// |  OFFSETS         |\n/// |------------------|\n/// |  DATA            |\n/// `------------------'\n///\n/// The header contains a magic number, version, type of hash function,\n/// the number of buckets, total number of hashes, and room for a special struct\n/// of data and the length of that struct.\n///\n/// The buckets contain an index (e.g. 6) into the hashes array. The hashes\n/// section contains all of the 32-bit hash values in contiguous memory, and the\n/// offsets contain the offset into the data area for the particular hash.\n///\n/// For a lookup example, we could hash a function name and take it modulo the\n/// number of buckets giving us our bucket. From there we take the bucket value\n/// as an index into the hashes table and look at each successive hash as long\n/// as the hash value is still the same modulo result (bucket value) as earlier.\n/// If we have a match we look at that same entry in the offsets table and grab\n/// the offset in the data for our final match.\n///\n/// The DWARF v5 accelerator table consists of zero or more name indices that\n/// are output into an on-disk format that looks like this:\n///\n/// .------------------.\n/// |  HEADER          |\n/// |------------------|\n/// |  CU LIST         |\n/// |------------------|\n/// |  LOCAL TU LIST   |\n/// |------------------|\n/// |  FOREIGN TU LIST |\n/// |------------------|\n/// |  HASH TABLE      |\n/// |------------------|\n/// |  NAME TABLE      |\n/// |------------------|\n/// |  ABBREV TABLE    |\n/// |------------------|\n/// |  ENTRY POOL      |\n/// `------------------'\n///\n/// For the full documentation please refer to the DWARF 5 standard.\n///\n///\n/// This file defines the class template AccelTable, which is represents an\n/// abstract view of an Accelerator table, without any notion of an on-disk\n/// layout. This class is parameterized by an entry type, which should derive\n/// from AccelTableData. This is the type of individual entries in the table,\n/// and it should store the data necessary to emit them. AppleAccelTableData is\n/// the base class for Apple Accelerator Table entries, which have a uniform\n/// structure based on a sequence of Atoms. There are different sub-classes\n/// derived from AppleAccelTable, which differ in the set of Atoms and how they\n/// obtain their values.\n///\n/// An Apple Accelerator Table can be serialized by calling emitAppleAccelTable\n/// function.\n\nnamespace llvm {\n\nclass AsmPrinter;\nclass DwarfCompileUnit;\nclass DwarfDebug;\n\n/// Interface which the different types of accelerator table data have to\n/// conform. It serves as a base class for different values of the template\n/// argument of the AccelTable class template.\nclass AccelTableData {\npublic:\n  virtual ~AccelTableData() = default;\n\n  bool operator<(const AccelTableData &Other) const {\n    return order() < Other.order();\n  }\n\n    // Subclasses should implement:\n    // static uint32_t hash(StringRef Name);\n\n#ifndef NDEBUG\n  virtual void print(raw_ostream &OS) const = 0;\n#endif\nprotected:\n  virtual uint64_t order() const = 0;\n};\n\n/// A base class holding non-template-dependant functionality of the AccelTable\n/// class. Clients should not use this class directly but rather instantiate\n/// AccelTable with a type derived from AccelTableData.\nclass AccelTableBase {\npublic:\n  using HashFn = uint32_t(StringRef);\n\n  /// Represents a group of entries with identical name (and hence, hash value).\n  struct HashData {\n    DwarfStringPoolEntryRef Name;\n    uint32_t HashValue;\n    std::vector<AccelTableData *> Values;\n    MCSymbol *Sym;\n\n    HashData(DwarfStringPoolEntryRef Name, HashFn *Hash)\n        : Name(Name), HashValue(Hash(Name.getString())) {}\n\n#ifndef NDEBUG\n    void print(raw_ostream &OS) const;\n    void dump() const { print(dbgs()); }\n#endif\n  };\n  using HashList = std::vector<HashData *>;\n  using BucketList = std::vector<HashList>;\n\nprotected:\n  /// Allocator for HashData and Values.\n  BumpPtrAllocator Allocator;\n\n  using StringEntries = StringMap<HashData, BumpPtrAllocator &>;\n  StringEntries Entries;\n\n  HashFn *Hash;\n  uint32_t BucketCount;\n  uint32_t UniqueHashCount;\n\n  HashList Hashes;\n  BucketList Buckets;\n\n  void computeBucketCount();\n\n  AccelTableBase(HashFn *Hash) : Entries(Allocator), Hash(Hash) {}\n\npublic:\n  void finalize(AsmPrinter *Asm, StringRef Prefix);\n  ArrayRef<HashList> getBuckets() const { return Buckets; }\n  uint32_t getBucketCount() const { return BucketCount; }\n  uint32_t getUniqueHashCount() const { return UniqueHashCount; }\n  uint32_t getUniqueNameCount() const { return Entries.size(); }\n\n#ifndef NDEBUG\n  void print(raw_ostream &OS) const;\n  void dump() const { print(dbgs()); }\n#endif\n\n  AccelTableBase(const AccelTableBase &) = delete;\n  void operator=(const AccelTableBase &) = delete;\n};\n\n/// This class holds an abstract representation of an Accelerator Table,\n/// consisting of a sequence of buckets, each bucket containint a sequence of\n/// HashData entries. The class is parameterized by the type of entries it\n/// holds. The type template parameter also defines the hash function to use for\n/// hashing names.\ntemplate <typename DataT> class AccelTable : public AccelTableBase {\npublic:\n  AccelTable() : AccelTableBase(DataT::hash) {}\n\n  template <typename... Types>\n  void addName(DwarfStringPoolEntryRef Name, Types &&... Args);\n};\n\ntemplate <typename AccelTableDataT>\ntemplate <typename... Types>\nvoid AccelTable<AccelTableDataT>::addName(DwarfStringPoolEntryRef Name,\n                                          Types &&... Args) {\n  assert(Buckets.empty() && \"Already finalized!\");\n  // If the string is in the list already then add this die to the list\n  // otherwise add a new one.\n  auto Iter = Entries.try_emplace(Name.getString(), Name, Hash).first;\n  assert(Iter->second.Name == Name);\n  Iter->second.Values.push_back(\n      new (Allocator) AccelTableDataT(std::forward<Types>(Args)...));\n}\n\n/// A base class for different implementations of Data classes for Apple\n/// Accelerator Tables. The columns in the table are defined by the static Atoms\n/// variable defined on the subclasses.\nclass AppleAccelTableData : public AccelTableData {\npublic:\n  /// An Atom defines the form of the data in an Apple accelerator table.\n  /// Conceptually it is a column in the accelerator consisting of a type and a\n  /// specification of the form of its data.\n  struct Atom {\n    /// Atom Type.\n    const uint16_t Type;\n    /// DWARF Form.\n    const uint16_t Form;\n\n    constexpr Atom(uint16_t Type, uint16_t Form) : Type(Type), Form(Form) {}\n\n#ifndef NDEBUG\n    void print(raw_ostream &OS) const;\n    void dump() const { print(dbgs()); }\n#endif\n  };\n  // Subclasses should define:\n  // static constexpr Atom Atoms[];\n\n  virtual void emit(AsmPrinter *Asm) const = 0;\n\n  static uint32_t hash(StringRef Buffer) { return djbHash(Buffer); }\n};\n\n/// The Data class implementation for DWARF v5 accelerator table. Unlike the\n/// Apple Data classes, this class is just a DIE wrapper, and does not know to\n/// serialize itself. The complete serialization logic is in the\n/// emitDWARF5AccelTable function.\nclass DWARF5AccelTableData : public AccelTableData {\npublic:\n  static uint32_t hash(StringRef Name) { return caseFoldingDjbHash(Name); }\n\n  DWARF5AccelTableData(const DIE &Die) : Die(Die) {}\n\n#ifndef NDEBUG\n  void print(raw_ostream &OS) const override;\n#endif\n\n  const DIE &getDie() const { return Die; }\n  uint64_t getDieOffset() const { return Die.getOffset(); }\n  unsigned getDieTag() const { return Die.getTag(); }\n\nprotected:\n  const DIE &Die;\n\n  uint64_t order() const override { return Die.getOffset(); }\n};\n\nclass DWARF5AccelTableStaticData : public AccelTableData {\npublic:\n  static uint32_t hash(StringRef Name) { return caseFoldingDjbHash(Name); }\n\n  DWARF5AccelTableStaticData(uint64_t DieOffset, unsigned DieTag,\n                             unsigned CUIndex)\n      : DieOffset(DieOffset), DieTag(DieTag), CUIndex(CUIndex) {}\n\n#ifndef NDEBUG\n  void print(raw_ostream &OS) const override;\n#endif\n\n  uint64_t getDieOffset() const { return DieOffset; }\n  unsigned getDieTag() const { return DieTag; }\n  unsigned getCUIndex() const { return CUIndex; }\n\nprotected:\n  uint64_t DieOffset;\n  unsigned DieTag;\n  unsigned CUIndex;\n\n  uint64_t order() const override { return DieOffset; }\n};\n\nvoid emitAppleAccelTableImpl(AsmPrinter *Asm, AccelTableBase &Contents,\n                             StringRef Prefix, const MCSymbol *SecBegin,\n                             ArrayRef<AppleAccelTableData::Atom> Atoms);\n\n/// Emit an Apple Accelerator Table consisting of entries in the specified\n/// AccelTable. The DataT template parameter should be derived from\n/// AppleAccelTableData.\ntemplate <typename DataT>\nvoid emitAppleAccelTable(AsmPrinter *Asm, AccelTable<DataT> &Contents,\n                         StringRef Prefix, const MCSymbol *SecBegin) {\n  static_assert(std::is_convertible<DataT *, AppleAccelTableData *>::value, \"\");\n  emitAppleAccelTableImpl(Asm, Contents, Prefix, SecBegin, DataT::Atoms);\n}\n\nvoid emitDWARF5AccelTable(AsmPrinter *Asm,\n                          AccelTable<DWARF5AccelTableData> &Contents,\n                          const DwarfDebug &DD,\n                          ArrayRef<std::unique_ptr<DwarfCompileUnit>> CUs);\n\nvoid emitDWARF5AccelTable(\n    AsmPrinter *Asm, AccelTable<DWARF5AccelTableStaticData> &Contents,\n    ArrayRef<MCSymbol *> CUs,\n    llvm::function_ref<unsigned(const DWARF5AccelTableStaticData &)>\n        getCUIndexForEntry);\n\n/// Accelerator table data implementation for simple Apple accelerator tables\n/// with just a DIE reference.\nclass AppleAccelTableOffsetData : public AppleAccelTableData {\npublic:\n  AppleAccelTableOffsetData(const DIE &D) : Die(D) {}\n\n  void emit(AsmPrinter *Asm) const override;\n\n  static constexpr Atom Atoms[] = {\n      Atom(dwarf::DW_ATOM_die_offset, dwarf::DW_FORM_data4)};\n\n#ifndef NDEBUG\n  void print(raw_ostream &OS) const override;\n#endif\nprotected:\n  uint64_t order() const override { return Die.getOffset(); }\n\n  const DIE &Die;\n};\n\n/// Accelerator table data implementation for Apple type accelerator tables.\nclass AppleAccelTableTypeData : public AppleAccelTableOffsetData {\npublic:\n  AppleAccelTableTypeData(const DIE &D) : AppleAccelTableOffsetData(D) {}\n\n  void emit(AsmPrinter *Asm) const override;\n\n  static constexpr Atom Atoms[] = {\n      Atom(dwarf::DW_ATOM_die_offset, dwarf::DW_FORM_data4),\n      Atom(dwarf::DW_ATOM_die_tag, dwarf::DW_FORM_data2),\n      Atom(dwarf::DW_ATOM_type_flags, dwarf::DW_FORM_data1)};\n\n#ifndef NDEBUG\n  void print(raw_ostream &OS) const override;\n#endif\n};\n\n/// Accelerator table data implementation for simple Apple accelerator tables\n/// with a DIE offset but no actual DIE pointer.\nclass AppleAccelTableStaticOffsetData : public AppleAccelTableData {\npublic:\n  AppleAccelTableStaticOffsetData(uint32_t Offset) : Offset(Offset) {}\n\n  void emit(AsmPrinter *Asm) const override;\n\n  static constexpr Atom Atoms[] = {\n      Atom(dwarf::DW_ATOM_die_offset, dwarf::DW_FORM_data4)};\n\n#ifndef NDEBUG\n  void print(raw_ostream &OS) const override;\n#endif\nprotected:\n  uint64_t order() const override { return Offset; }\n\n  uint32_t Offset;\n};\n\n/// Accelerator table data implementation for type accelerator tables with\n/// a DIE offset but no actual DIE pointer.\nclass AppleAccelTableStaticTypeData : public AppleAccelTableStaticOffsetData {\npublic:\n  AppleAccelTableStaticTypeData(uint32_t Offset, uint16_t Tag,\n                                bool ObjCClassIsImplementation,\n                                uint32_t QualifiedNameHash)\n      : AppleAccelTableStaticOffsetData(Offset),\n        QualifiedNameHash(QualifiedNameHash), Tag(Tag),\n        ObjCClassIsImplementation(ObjCClassIsImplementation) {}\n\n  void emit(AsmPrinter *Asm) const override;\n\n  static constexpr Atom Atoms[] = {\n      Atom(dwarf::DW_ATOM_die_offset, dwarf::DW_FORM_data4),\n      Atom(dwarf::DW_ATOM_die_tag, dwarf::DW_FORM_data2),\n      Atom(5, dwarf::DW_FORM_data1), Atom(6, dwarf::DW_FORM_data4)};\n\n#ifndef NDEBUG\n  void print(raw_ostream &OS) const override;\n#endif\nprotected:\n  uint64_t order() const override { return Offset; }\n\n  uint32_t QualifiedNameHash;\n  uint16_t Tag;\n  bool ObjCClassIsImplementation;\n};\n\n} // end namespace llvm\n\n#endif // LLVM_CODEGEN_ACCELTABLE_H\n"}, "23": {"id": 23, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/CodeGen/DIE.h", "content": "//===- lib/CodeGen/DIE.h - DWARF Info Entries -------------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// Data structures for DWARF info entries.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_CODEGEN_DIE_H\n#define LLVM_CODEGEN_DIE_H\n\n#include \"llvm/ADT/FoldingSet.h\"\n#include \"llvm/ADT/PointerIntPair.h\"\n#include \"llvm/ADT/PointerUnion.h\"\n#include \"llvm/ADT/SmallVector.h\"\n#include \"llvm/ADT/StringRef.h\"\n#include \"llvm/ADT/iterator.h\"\n#include \"llvm/ADT/iterator_range.h\"\n#include \"llvm/BinaryFormat/Dwarf.h\"\n#include \"llvm/CodeGen/DwarfStringPoolEntry.h\"\n#include \"llvm/Support/AlignOf.h\"\n#include \"llvm/Support/Allocator.h\"\n#include <cassert>\n#include <cstddef>\n#include <cstdint>\n#include <iterator>\n#include <new>\n#include <type_traits>\n#include <utility>\n#include <vector>\n\nnamespace llvm {\n\nclass AsmPrinter;\nclass DIE;\nclass DIEUnit;\nclass DwarfCompileUnit;\nclass MCExpr;\nclass MCSection;\nclass MCSymbol;\nclass raw_ostream;\n\n//===--------------------------------------------------------------------===//\n/// Dwarf abbreviation data, describes one attribute of a Dwarf abbreviation.\nclass DIEAbbrevData {\n  /// Dwarf attribute code.\n  dwarf::Attribute Attribute;\n\n  /// Dwarf form code.\n  dwarf::Form Form;\n\n  /// Dwarf attribute value for DW_FORM_implicit_const\n  int64_t Value = 0;\n\npublic:\n  DIEAbbrevData(dwarf::Attribute A, dwarf::Form F)\n      : Attribute(A), Form(F) {}\n  DIEAbbrevData(dwarf::Attribute A, int64_t V)\n      : Attribute(A), Form(dwarf::DW_FORM_implicit_const), Value(V) {}\n\n  /// Accessors.\n  /// @{\n  dwarf::Attribute getAttribute() const { return Attribute; }\n  dwarf::Form getForm() const { return Form; }\n  int64_t getValue() const { return Value; }\n  /// @}\n\n  /// Used to gather unique data for the abbreviation folding set.\n  void Profile(FoldingSetNodeID &ID) const;\n};\n\n//===--------------------------------------------------------------------===//\n/// Dwarf abbreviation, describes the organization of a debug information\n/// object.\nclass DIEAbbrev : public FoldingSetNode {\n  /// Unique number for node.\n  unsigned Number = 0;\n\n  /// Dwarf tag code.\n  dwarf::Tag Tag;\n\n  /// Whether or not this node has children.\n  ///\n  /// This cheats a bit in all of the uses since the values in the standard\n  /// are 0 and 1 for no children and children respectively.\n  bool Children;\n\n  /// Raw data bytes for abbreviation.\n  SmallVector<DIEAbbrevData, 12> Data;\n\npublic:\n  DIEAbbrev(dwarf::Tag T, bool C) : Tag(T), Children(C) {}\n\n  /// Accessors.\n  /// @{\n  dwarf::Tag getTag() const { return Tag; }\n  unsigned getNumber() const { return Number; }\n  bool hasChildren() const { return Children; }\n  const SmallVectorImpl<DIEAbbrevData> &getData() const { return Data; }\n  void setChildrenFlag(bool hasChild) { Children = hasChild; }\n  void setNumber(unsigned N) { Number = N; }\n  /// @}\n\n  /// Adds another set of attribute information to the abbreviation.\n  void AddAttribute(dwarf::Attribute Attribute, dwarf::Form Form) {\n    Data.push_back(DIEAbbrevData(Attribute, Form));\n  }\n\n  /// Adds attribute with DW_FORM_implicit_const value\n  void AddImplicitConstAttribute(dwarf::Attribute Attribute, int64_t Value) {\n    Data.push_back(DIEAbbrevData(Attribute, Value));\n  }\n\n  /// Used to gather unique data for the abbreviation folding set.\n  void Profile(FoldingSetNodeID &ID) const;\n\n  /// Print the abbreviation using the specified asm printer.\n  void Emit(const AsmPrinter *AP) const;\n\n  void print(raw_ostream &O) const;\n  void dump() const;\n};\n\n//===--------------------------------------------------------------------===//\n/// Helps unique DIEAbbrev objects and assigns abbreviation numbers.\n///\n/// This class will unique the DIE abbreviations for a llvm::DIE object and\n/// assign a unique abbreviation number to each unique DIEAbbrev object it\n/// finds. The resulting collection of DIEAbbrev objects can then be emitted\n/// into the .debug_abbrev section.\nclass DIEAbbrevSet {\n  /// The bump allocator to use when creating DIEAbbrev objects in the uniqued\n  /// storage container.\n  BumpPtrAllocator &Alloc;\n  /// FoldingSet that uniques the abbreviations.\n  FoldingSet<DIEAbbrev> AbbreviationsSet;\n  /// A list of all the unique abbreviations in use.\n  std::vector<DIEAbbrev *> Abbreviations;\n\npublic:\n  DIEAbbrevSet(BumpPtrAllocator &A) : Alloc(A) {}\n  ~DIEAbbrevSet();\n\n  /// Generate the abbreviation declaration for a DIE and return a pointer to\n  /// the generated abbreviation.\n  ///\n  /// \\param Die the debug info entry to generate the abbreviation for.\n  /// \\returns A reference to the uniqued abbreviation declaration that is\n  /// owned by this class.\n  DIEAbbrev &uniqueAbbreviation(DIE &Die);\n\n  /// Print all abbreviations using the specified asm printer.\n  void Emit(const AsmPrinter *AP, MCSection *Section) const;\n};\n\n//===--------------------------------------------------------------------===//\n/// An integer value DIE.\n///\nclass DIEInteger {\n  uint64_t Integer;\n\npublic:\n  explicit DIEInteger(uint64_t I) : Integer(I) {}\n\n  /// Choose the best form for integer.\n  static dwarf::Form BestForm(bool IsSigned, uint64_t Int) {\n    if (IsSigned) {\n      const int64_t SignedInt = Int;\n      if ((char)Int == SignedInt)\n        return dwarf::DW_FORM_data1;\n      if ((short)Int == SignedInt)\n        return dwarf::DW_FORM_data2;\n      if ((int)Int == SignedInt)\n        return dwarf::DW_FORM_data4;\n    } else {\n      if ((unsigned char)Int == Int)\n        return dwarf::DW_FORM_data1;\n      if ((unsigned short)Int == Int)\n        return dwarf::DW_FORM_data2;\n      if ((unsigned int)Int == Int)\n        return dwarf::DW_FORM_data4;\n    }\n    return dwarf::DW_FORM_data8;\n  }\n\n  uint64_t getValue() const { return Integer; }\n  void setValue(uint64_t Val) { Integer = Val; }\n\n  void emitValue(const AsmPrinter *Asm, dwarf::Form Form) const;\n  unsigned SizeOf(const AsmPrinter *AP, dwarf::Form Form) const;\n\n  void print(raw_ostream &O) const;\n};\n\n//===--------------------------------------------------------------------===//\n/// An expression DIE.\nclass DIEExpr {\n  const MCExpr *Expr;\n\npublic:\n  explicit DIEExpr(const MCExpr *E) : Expr(E) {}\n\n  /// Get MCExpr.\n  const MCExpr *getValue() const { return Expr; }\n\n  void emitValue(const AsmPrinter *AP, dwarf::Form Form) const;\n  unsigned SizeOf(const AsmPrinter *AP, dwarf::Form Form) const;\n\n  void print(raw_ostream &O) const;\n};\n\n//===--------------------------------------------------------------------===//\n/// A label DIE.\nclass DIELabel {\n  const MCSymbol *Label;\n\npublic:\n  explicit DIELabel(const MCSymbol *L) : Label(L) {}\n\n  /// Get MCSymbol.\n  const MCSymbol *getValue() const { return Label; }\n\n  void emitValue(const AsmPrinter *AP, dwarf::Form Form) const;\n  unsigned SizeOf(const AsmPrinter *AP, dwarf::Form Form) const;\n\n  void print(raw_ostream &O) const;\n};\n\n//===--------------------------------------------------------------------===//\n/// A BaseTypeRef DIE.\nclass DIEBaseTypeRef {\n  const DwarfCompileUnit *CU;\n  const uint64_t Index;\n  static constexpr unsigned ULEB128PadSize = 4;\n\npublic:\n  explicit DIEBaseTypeRef(const DwarfCompileUnit *TheCU, uint64_t Idx)\n    : CU(TheCU), Index(Idx) {}\n\n  /// EmitValue - Emit base type reference.\n  void emitValue(const AsmPrinter *AP, dwarf::Form Form) const;\n  /// SizeOf - Determine size of the base type reference in bytes.\n  unsigned SizeOf(const AsmPrinter *AP, dwarf::Form Form) const;\n\n  void print(raw_ostream &O) const;\n  uint64_t getIndex() const { return Index; }\n};\n\n//===--------------------------------------------------------------------===//\n/// A simple label difference DIE.\n///\nclass DIEDelta {\n  const MCSymbol *LabelHi;\n  const MCSymbol *LabelLo;\n\npublic:\n  DIEDelta(const MCSymbol *Hi, const MCSymbol *Lo) : LabelHi(Hi), LabelLo(Lo) {}\n\n  void emitValue(const AsmPrinter *AP, dwarf::Form Form) const;\n  unsigned SizeOf(const AsmPrinter *AP, dwarf::Form Form) const;\n\n  void print(raw_ostream &O) const;\n};\n\n//===--------------------------------------------------------------------===//\n/// A container for string pool string values.\n///\n/// This class is used with the DW_FORM_strp and DW_FORM_GNU_str_index forms.\nclass DIEString {\n  DwarfStringPoolEntryRef S;\n\npublic:\n  DIEString(DwarfStringPoolEntryRef S) : S(S) {}\n\n  /// Grab the string out of the object.\n  StringRef getString() const { return S.getString(); }\n\n  void emitValue(const AsmPrinter *AP, dwarf::Form Form) const;\n  unsigned SizeOf(const AsmPrinter *AP, dwarf::Form Form) const;\n\n  void print(raw_ostream &O) const;\n};\n\n//===--------------------------------------------------------------------===//\n/// A container for inline string values.\n///\n/// This class is used with the DW_FORM_string form.\nclass DIEInlineString {\n  StringRef S;\n\npublic:\n  template <typename Allocator>\n  explicit DIEInlineString(StringRef Str, Allocator &A) : S(Str.copy(A)) {}\n\n  ~DIEInlineString() = default;\n\n  /// Grab the string out of the object.\n  StringRef getString() const { return S; }\n\n  void emitValue(const AsmPrinter *AP, dwarf::Form Form) const;\n  unsigned SizeOf(const AsmPrinter *AP, dwarf::Form Form) const;\n\n  void print(raw_ostream &O) const;\n};\n\n//===--------------------------------------------------------------------===//\n/// A pointer to another debug information entry.  An instance of this class can\n/// also be used as a proxy for a debug information entry not yet defined\n/// (ie. types.)\nclass DIEEntry {\n  DIE *Entry;\n\npublic:\n  DIEEntry() = delete;\n  explicit DIEEntry(DIE &E) : Entry(&E) {}\n\n  DIE &getEntry() const { return *Entry; }\n\n  void emitValue(const AsmPrinter *AP, dwarf::Form Form) const;\n  unsigned SizeOf(const AsmPrinter *AP, dwarf::Form Form) const;\n\n  void print(raw_ostream &O) const;\n};\n\n//===--------------------------------------------------------------------===//\n/// Represents a pointer to a location list in the debug_loc\n/// section.\nclass DIELocList {\n  /// Index into the .debug_loc vector.\n  size_t Index;\n\npublic:\n  DIELocList(size_t I) : Index(I) {}\n\n  /// Grab the current index out.\n  size_t getValue() const { return Index; }\n\n  void emitValue(const AsmPrinter *AP, dwarf::Form Form) const;\n  unsigned SizeOf(const AsmPrinter *AP, dwarf::Form Form) const;\n\n  void print(raw_ostream &O) const;\n};\n\n//===--------------------------------------------------------------------===//\n/// A BaseTypeRef DIE.\nclass DIEAddrOffset {\n  DIEInteger Addr;\n  DIEDelta Offset;\n\npublic:\n  explicit DIEAddrOffset(uint64_t Idx, const MCSymbol *Hi, const MCSymbol *Lo)\n      : Addr(Idx), Offset(Hi, Lo) {}\n\n  void emitValue(const AsmPrinter *AP, dwarf::Form Form) const;\n  unsigned SizeOf(const AsmPrinter *AP, dwarf::Form Form) const;\n\n  void print(raw_ostream &O) const;\n};\n\n//===--------------------------------------------------------------------===//\n/// A debug information entry value. Some of these roughly correlate\n/// to DWARF attribute classes.\nclass DIEBlock;\nclass DIELoc;\nclass DIEValue {\npublic:\n  enum Type {\n    isNone,\n#define HANDLE_DIEVALUE(T) is##T,\n#include \"llvm/CodeGen/DIEValue.def\"\n  };\n\nprivate:\n  /// Type of data stored in the value.\n  Type Ty = isNone;\n  dwarf::Attribute Attribute = (dwarf::Attribute)0;\n  dwarf::Form Form = (dwarf::Form)0;\n\n  /// Storage for the value.\n  ///\n  /// All values that aren't standard layout (or are larger than 8 bytes)\n  /// should be stored by reference instead of by value.\n  using ValTy =\n      AlignedCharArrayUnion<DIEInteger, DIEString, DIEExpr, DIELabel,\n                            DIEDelta *, DIEEntry, DIEBlock *, DIELoc *,\n                            DIELocList, DIEBaseTypeRef *, DIEAddrOffset *>;\n\n  static_assert(sizeof(ValTy) <= sizeof(uint64_t) ||\n                    sizeof(ValTy) <= sizeof(void *),\n                \"Expected all large types to be stored via pointer\");\n\n  /// Underlying stored value.\n  ValTy Val;\n\n  template <class T> void construct(T V) {\n    static_assert(std::is_standard_layout<T>::value ||\n                      std::is_pointer<T>::value,\n                  \"Expected standard layout or pointer\");\n    new (reinterpret_cast<void *>(&Val)) T(V);\n  }\n\n  template <class T> T *get() { return reinterpret_cast<T *>(&Val); }\n  template <class T> const T *get() const {\n    return reinterpret_cast<const T *>(&Val);\n  }\n  template <class T> void destruct() { get<T>()->~T(); }\n\n  /// Destroy the underlying value.\n  ///\n  /// This should get optimized down to a no-op.  We could skip it if we could\n  /// add a static assert on \\a std::is_trivially_copyable(), but we currently\n  /// support versions of GCC that don't understand that.\n  void destroyVal() {\n    switch (Ty) {\n    case isNone:\n      return;\n#define HANDLE_DIEVALUE_SMALL(T)                                               \\\n  case is##T:                                                                  \\\n    destruct<DIE##T>();                                                        \\\n    return;\n#define HANDLE_DIEVALUE_LARGE(T)                                               \\\n  case is##T:                                                                  \\\n    destruct<const DIE##T *>();                                                \\\n    return;\n#include \"llvm/CodeGen/DIEValue.def\"\n    }\n  }\n\n  /// Copy the underlying value.\n  ///\n  /// This should get optimized down to a simple copy.  We need to actually\n  /// construct the value, rather than calling memcpy, to satisfy strict\n  /// aliasing rules.\n  void copyVal(const DIEValue &X) {\n    switch (Ty) {\n    case isNone:\n      return;\n#define HANDLE_DIEVALUE_SMALL(T)                                               \\\n  case is##T:                                                                  \\\n    construct<DIE##T>(*X.get<DIE##T>());                                       \\\n    return;\n#define HANDLE_DIEVALUE_LARGE(T)                                               \\\n  case is##T:                                                                  \\\n    construct<const DIE##T *>(*X.get<const DIE##T *>());                       \\\n    return;\n#include \"llvm/CodeGen/DIEValue.def\"\n    }\n  }\n\npublic:\n  DIEValue() = default;\n\n  DIEValue(const DIEValue &X) : Ty(X.Ty), Attribute(X.Attribute), Form(X.Form) {\n    copyVal(X);\n  }\n\n  DIEValue &operator=(const DIEValue &X) {\n    destroyVal();\n    Ty = X.Ty;\n    Attribute = X.Attribute;\n    Form = X.Form;\n    copyVal(X);\n    return *this;\n  }\n\n  ~DIEValue() { destroyVal(); }\n\n#define HANDLE_DIEVALUE_SMALL(T)                                               \\\n  DIEValue(dwarf::Attribute Attribute, dwarf::Form Form, const DIE##T &V)      \\\n      : Ty(is##T), Attribute(Attribute), Form(Form) {                          \\\n    construct<DIE##T>(V);                                                      \\\n  }\n#define HANDLE_DIEVALUE_LARGE(T)                                               \\\n  DIEValue(dwarf::Attribute Attribute, dwarf::Form Form, const DIE##T *V)      \\\n      : Ty(is##T), Attribute(Attribute), Form(Form) {                          \\\n    assert(V && \"Expected valid value\");                                       \\\n    construct<const DIE##T *>(V);                                              \\\n  }\n#include \"llvm/CodeGen/DIEValue.def\"\n\n  /// Accessors.\n  /// @{\n  Type getType() const { return Ty; }\n  dwarf::Attribute getAttribute() const { return Attribute; }\n  dwarf::Form getForm() const { return Form; }\n  explicit operator bool() const { return Ty; }\n  /// @}\n\n#define HANDLE_DIEVALUE_SMALL(T)                                               \\\n  const DIE##T &getDIE##T() const {                                            \\\n    assert(getType() == is##T && \"Expected \" #T);                              \\\n    return *get<DIE##T>();                                                     \\\n  }\n#define HANDLE_DIEVALUE_LARGE(T)                                               \\\n  const DIE##T &getDIE##T() const {                                            \\\n    assert(getType() == is##T && \"Expected \" #T);                              \\\n    return **get<const DIE##T *>();                                            \\\n  }\n#include \"llvm/CodeGen/DIEValue.def\"\n\n  /// Emit value via the Dwarf writer.\n  void emitValue(const AsmPrinter *AP) const;\n\n  /// Return the size of a value in bytes.\n  unsigned SizeOf(const AsmPrinter *AP) const;\n\n  void print(raw_ostream &O) const;\n  void dump() const;\n};\n\nstruct IntrusiveBackListNode {\n  PointerIntPair<IntrusiveBackListNode *, 1> Next;\n\n  IntrusiveBackListNode() : Next(this, true) {}\n\n  IntrusiveBackListNode *getNext() const {\n    return Next.getInt() ? nullptr : Next.getPointer();\n  }\n};\n\nstruct IntrusiveBackListBase {\n  using Node = IntrusiveBackListNode;\n\n  Node *Last = nullptr;\n\n  bool empty() const { return !Last; }\n\n  void push_back(Node &N) {\n    assert(N.Next.getPointer() == &N && \"Expected unlinked node\");\n    assert(N.Next.getInt() == true && \"Expected unlinked node\");\n\n    if (Last) {\n      N.Next = Last->Next;\n      Last->Next.setPointerAndInt(&N, false);\n    }\n    Last = &N;\n  }\n\n  void push_front(Node &N) {\n    assert(N.Next.getPointer() == &N && \"Expected unlinked node\");\n    assert(N.Next.getInt() == true && \"Expected unlinked node\");\n\n    if (Last) {\n      N.Next.setPointerAndInt(Last->Next.getPointer(), false);\n      Last->Next.setPointerAndInt(&N, true);\n    } else {\n      Last = &N;\n    }\n  }\n};\n\ntemplate <class T> class IntrusiveBackList : IntrusiveBackListBase {\npublic:\n  using IntrusiveBackListBase::empty;\n\n  void push_back(T &N) { IntrusiveBackListBase::push_back(N); }\n  void push_front(T &N) { IntrusiveBackListBase::push_front(N); }\n  T &back() { return *static_cast<T *>(Last); }\n  const T &back() const { return *static_cast<T *>(Last); }\n  T &front() {\n    return *static_cast<T *>(Last ? Last->Next.getPointer() : nullptr);\n  }\n  const T &front() const {\n    return *static_cast<T *>(Last ? Last->Next.getPointer() : nullptr);\n  }\n\n  void takeNodes(IntrusiveBackList<T> &Other) {\n    if (Other.empty())\n      return;\n\n    T *FirstNode = static_cast<T *>(Other.Last->Next.getPointer());\n    T *IterNode = FirstNode;\n    do {\n      // Keep a pointer to the node and increment the iterator.\n      T *TmpNode = IterNode;\n      IterNode = static_cast<T *>(IterNode->Next.getPointer());\n\n      // Unlink the node and push it back to this list.\n      TmpNode->Next.setPointerAndInt(TmpNode, true);\n      push_back(*TmpNode);\n    } while (IterNode != FirstNode);\n\n    Other.Last = nullptr;\n  }\n\n  class const_iterator;\n  class iterator\n      : public iterator_facade_base<iterator, std::forward_iterator_tag, T> {\n    friend class const_iterator;\n\n    Node *N = nullptr;\n\n  public:\n    iterator() = default;\n    explicit iterator(T *N) : N(N) {}\n\n    iterator &operator++() {\n      N = N->getNext();\n      return *this;\n    }\n\n    explicit operator bool() const { return N; }\n    T &operator*() const { return *static_cast<T *>(N); }\n\n    bool operator==(const iterator &X) const { return N == X.N; }\n  };\n\n  class const_iterator\n      : public iterator_facade_base<const_iterator, std::forward_iterator_tag,\n                                    const T> {\n    const Node *N = nullptr;\n\n  public:\n    const_iterator() = default;\n    // Placate MSVC by explicitly scoping 'iterator'.\n    const_iterator(typename IntrusiveBackList<T>::iterator X) : N(X.N) {}\n    explicit const_iterator(const T *N) : N(N) {}\n\n    const_iterator &operator++() {\n      N = N->getNext();\n      return *this;\n    }\n\n    explicit operator bool() const { return N; }\n    const T &operator*() const { return *static_cast<const T *>(N); }\n\n    bool operator==(const const_iterator &X) const { return N == X.N; }\n  };\n\n  iterator begin() {\n    return Last ? iterator(static_cast<T *>(Last->Next.getPointer())) : end();\n  }\n  const_iterator begin() const {\n    return const_cast<IntrusiveBackList *>(this)->begin();\n  }\n  iterator end() { return iterator(); }\n  const_iterator end() const { return const_iterator(); }\n\n  static iterator toIterator(T &N) { return iterator(&N); }\n  static const_iterator toIterator(const T &N) { return const_iterator(&N); }\n};\n\n/// A list of DIE values.\n///\n/// This is a singly-linked list, but instead of reversing the order of\n/// insertion, we keep a pointer to the back of the list so we can push in\n/// order.\n///\n/// There are two main reasons to choose a linked list over a customized\n/// vector-like data structure.\n///\n///  1. For teardown efficiency, we want DIEs to be BumpPtrAllocated.  Using a\n///     linked list here makes this way easier to accomplish.\n///  2. Carrying an extra pointer per \\a DIEValue isn't expensive.  45% of DIEs\n///     have 2 or fewer values, and 90% have 5 or fewer.  A vector would be\n///     over-allocated by 50% on average anyway, the same cost as the\n///     linked-list node.\nclass DIEValueList {\n  struct Node : IntrusiveBackListNode {\n    DIEValue V;\n\n    explicit Node(DIEValue V) : V(V) {}\n  };\n\n  using ListTy = IntrusiveBackList<Node>;\n\n  ListTy List;\n\npublic:\n  class const_value_iterator;\n  class value_iterator\n      : public iterator_adaptor_base<value_iterator, ListTy::iterator,\n                                     std::forward_iterator_tag, DIEValue> {\n    friend class const_value_iterator;\n\n    using iterator_adaptor =\n        iterator_adaptor_base<value_iterator, ListTy::iterator,\n                              std::forward_iterator_tag, DIEValue>;\n\n  public:\n    value_iterator() = default;\n    explicit value_iterator(ListTy::iterator X) : iterator_adaptor(X) {}\n\n    explicit operator bool() const { return bool(wrapped()); }\n    DIEValue &operator*() const { return wrapped()->V; }\n  };\n\n  class const_value_iterator : public iterator_adaptor_base<\n                                   const_value_iterator, ListTy::const_iterator,\n                                   std::forward_iterator_tag, const DIEValue> {\n    using iterator_adaptor =\n        iterator_adaptor_base<const_value_iterator, ListTy::const_iterator,\n                              std::forward_iterator_tag, const DIEValue>;\n\n  public:\n    const_value_iterator() = default;\n    const_value_iterator(DIEValueList::value_iterator X)\n        : iterator_adaptor(X.wrapped()) {}\n    explicit const_value_iterator(ListTy::const_iterator X)\n        : iterator_adaptor(X) {}\n\n    explicit operator bool() const { return bool(wrapped()); }\n    const DIEValue &operator*() const { return wrapped()->V; }\n  };\n\n  using value_range = iterator_range<value_iterator>;\n  using const_value_range = iterator_range<const_value_iterator>;\n\n  value_iterator addValue(BumpPtrAllocator &Alloc, const DIEValue &V) {\n    List.push_back(*new (Alloc) Node(V));\n    return value_iterator(ListTy::toIterator(List.back()));\n  }\n  template <class T>\n  value_iterator addValue(BumpPtrAllocator &Alloc, dwarf::Attribute Attribute,\n                    dwarf::Form Form, T &&Value) {\n    return addValue(Alloc, DIEValue(Attribute, Form, std::forward<T>(Value)));\n  }\n\n  /// Take ownership of the nodes in \\p Other, and append them to the back of\n  /// the list.\n  void takeValues(DIEValueList &Other) { List.takeNodes(Other.List); }\n\n  value_range values() {\n    return make_range(value_iterator(List.begin()), value_iterator(List.end()));\n  }\n  const_value_range values() const {\n    return make_range(const_value_iterator(List.begin()),\n                      const_value_iterator(List.end()));\n  }\n};\n\n//===--------------------------------------------------------------------===//\n/// A structured debug information entry.  Has an abbreviation which\n/// describes its organization.\nclass DIE : IntrusiveBackListNode, public DIEValueList {\n  friend class IntrusiveBackList<DIE>;\n  friend class DIEUnit;\n\n  /// Dwarf unit relative offset.\n  unsigned Offset = 0;\n  /// Size of instance + children.\n  unsigned Size = 0;\n  unsigned AbbrevNumber = ~0u;\n  /// Dwarf tag code.\n  dwarf::Tag Tag = (dwarf::Tag)0;\n  /// Set to true to force a DIE to emit an abbreviation that says it has\n  /// children even when it doesn't. This is used for unit testing purposes.\n  bool ForceChildren = false;\n  /// Children DIEs.\n  IntrusiveBackList<DIE> Children;\n\n  /// The owner is either the parent DIE for children of other DIEs, or a\n  /// DIEUnit which contains this DIE as its unit DIE.\n  PointerUnion<DIE *, DIEUnit *> Owner;\n\n  explicit DIE(dwarf::Tag Tag) : Tag(Tag) {}\n\npublic:\n  DIE() = delete;\n  DIE(const DIE &RHS) = delete;\n  DIE(DIE &&RHS) = delete;\n  DIE &operator=(const DIE &RHS) = delete;\n  DIE &operator=(const DIE &&RHS) = delete;\n\n  static DIE *get(BumpPtrAllocator &Alloc, dwarf::Tag Tag) {\n    return new (Alloc) DIE(Tag);\n  }\n\n  // Accessors.\n  unsigned getAbbrevNumber() const { return AbbrevNumber; }\n  dwarf::Tag getTag() const { return Tag; }\n  /// Get the compile/type unit relative offset of this DIE.\n  unsigned getOffset() const { return Offset; }\n  unsigned getSize() const { return Size; }\n  bool hasChildren() const { return ForceChildren || !Children.empty(); }\n  void setForceChildren(bool B) { ForceChildren = B; }\n\n  using child_iterator = IntrusiveBackList<DIE>::iterator;\n  using const_child_iterator = IntrusiveBackList<DIE>::const_iterator;\n  using child_range = iterator_range<child_iterator>;\n  using const_child_range = iterator_range<const_child_iterator>;\n\n  child_range children() {\n    return make_range(Children.begin(), Children.end());\n  }\n  const_child_range children() const {\n    return make_range(Children.begin(), Children.end());\n  }\n\n  DIE *getParent() const;\n\n  /// Generate the abbreviation for this DIE.\n  ///\n  /// Calculate the abbreviation for this, which should be uniqued and\n  /// eventually used to call \\a setAbbrevNumber().\n  DIEAbbrev generateAbbrev() const;\n\n  /// Set the abbreviation number for this DIE.\n  void setAbbrevNumber(unsigned I) { AbbrevNumber = I; }\n\n  /// Get the absolute offset within the .debug_info or .debug_types section\n  /// for this DIE.\n  uint64_t getDebugSectionOffset() const;\n\n  /// Compute the offset of this DIE and all its children.\n  ///\n  /// This function gets called just before we are going to generate the debug\n  /// information and gives each DIE a chance to figure out its CU relative DIE\n  /// offset, unique its abbreviation and fill in the abbreviation code, and\n  /// return the unit offset that points to where the next DIE will be emitted\n  /// within the debug unit section. After this function has been called for all\n  /// DIE objects, the DWARF can be generated since all DIEs will be able to\n  /// properly refer to other DIE objects since all DIEs have calculated their\n  /// offsets.\n  ///\n  /// \\param AP AsmPrinter to use when calculating sizes.\n  /// \\param AbbrevSet the abbreviation used to unique DIE abbreviations.\n  /// \\param CUOffset the compile/type unit relative offset in bytes.\n  /// \\returns the offset for the DIE that follows this DIE within the\n  /// current compile/type unit.\n  unsigned computeOffsetsAndAbbrevs(const AsmPrinter *AP,\n                                    DIEAbbrevSet &AbbrevSet, unsigned CUOffset);\n\n  /// Climb up the parent chain to get the compile unit or type unit DIE that\n  /// this DIE belongs to.\n  ///\n  /// \\returns the compile or type unit DIE that owns this DIE, or NULL if\n  /// this DIE hasn't been added to a unit DIE.\n  const DIE *getUnitDie() const;\n\n  /// Climb up the parent chain to get the compile unit or type unit that this\n  /// DIE belongs to.\n  ///\n  /// \\returns the DIEUnit that represents the compile or type unit that owns\n  /// this DIE, or NULL if this DIE hasn't been added to a unit DIE.\n  DIEUnit *getUnit() const;\n\n  void setOffset(unsigned O) { Offset = O; }\n  void setSize(unsigned S) { Size = S; }\n\n  /// Add a child to the DIE.\n  DIE &addChild(DIE *Child) {\n    assert(!Child->getParent() && \"Child should be orphaned\");\n    Child->Owner = this;\n    Children.push_back(*Child);\n    return Children.back();\n  }\n\n  DIE &addChildFront(DIE *Child) {\n    assert(!Child->getParent() && \"Child should be orphaned\");\n    Child->Owner = this;\n    Children.push_front(*Child);\n    return Children.front();\n  }\n\n  /// Find a value in the DIE with the attribute given.\n  ///\n  /// Returns a default-constructed DIEValue (where \\a DIEValue::getType()\n  /// gives \\a DIEValue::isNone) if no such attribute exists.\n  DIEValue findAttribute(dwarf::Attribute Attribute) const;\n\n  void print(raw_ostream &O, unsigned IndentCount = 0) const;\n  void dump() const;\n};\n\n//===--------------------------------------------------------------------===//\n/// Represents a compile or type unit.\nclass DIEUnit {\n  /// The compile unit or type unit DIE. This variable must be an instance of\n  /// DIE so that we can calculate the DIEUnit from any DIE by traversing the\n  /// parent backchain and getting the Unit DIE, and then casting itself to a\n  /// DIEUnit. This allows us to be able to find the DIEUnit for any DIE without\n  /// having to store a pointer to the DIEUnit in each DIE instance.\n  DIE Die;\n  /// The section this unit will be emitted in. This may or may not be set to\n  /// a valid section depending on the client that is emitting DWARF.\n  MCSection *Section;\n  uint64_t Offset; /// .debug_info or .debug_types absolute section offset.\nprotected:\n  virtual ~DIEUnit() = default;\n\npublic:\n  explicit DIEUnit(dwarf::Tag UnitTag);\n  DIEUnit(const DIEUnit &RHS) = delete;\n  DIEUnit(DIEUnit &&RHS) = delete;\n  void operator=(const DIEUnit &RHS) = delete;\n  void operator=(const DIEUnit &&RHS) = delete;\n  /// Set the section that this DIEUnit will be emitted into.\n  ///\n  /// This function is used by some clients to set the section. Not all clients\n  /// that emit DWARF use this section variable.\n  void setSection(MCSection *Section) {\n    assert(!this->Section);\n    this->Section = Section;\n  }\n\n  virtual const MCSymbol *getCrossSectionRelativeBaseAddress() const {\n    return nullptr;\n  }\n\n  /// Return the section that this DIEUnit will be emitted into.\n  ///\n  /// \\returns Section pointer which can be NULL.\n  MCSection *getSection() const { return Section; }\n  void setDebugSectionOffset(uint64_t O) { Offset = O; }\n  uint64_t getDebugSectionOffset() const { return Offset; }\n  DIE &getUnitDie() { return Die; }\n  const DIE &getUnitDie() const { return Die; }\n};\n\nstruct BasicDIEUnit final : DIEUnit {\n  explicit BasicDIEUnit(dwarf::Tag UnitTag) : DIEUnit(UnitTag) {}\n};\n\n//===--------------------------------------------------------------------===//\n/// DIELoc - Represents an expression location.\n//\nclass DIELoc : public DIEValueList {\n  mutable unsigned Size = 0; // Size in bytes excluding size header.\n\npublic:\n  DIELoc() = default;\n\n  /// ComputeSize - Calculate the size of the location expression.\n  ///\n  unsigned ComputeSize(const AsmPrinter *AP) const;\n\n  // TODO: move setSize() and Size to DIEValueList.\n  void setSize(unsigned size) { Size = size; }\n\n  /// BestForm - Choose the best form for data.\n  ///\n  dwarf::Form BestForm(unsigned DwarfVersion) const {\n    if (DwarfVersion > 3)\n      return dwarf::DW_FORM_exprloc;\n    // Pre-DWARF4 location expressions were blocks and not exprloc.\n    if ((unsigned char)Size == Size)\n      return dwarf::DW_FORM_block1;\n    if ((unsigned short)Size == Size)\n      return dwarf::DW_FORM_block2;\n    if ((unsigned int)Size == Size)\n      return dwarf::DW_FORM_block4;\n    return dwarf::DW_FORM_block;\n  }\n\n  void emitValue(const AsmPrinter *Asm, dwarf::Form Form) const;\n  unsigned SizeOf(const AsmPrinter *AP, dwarf::Form Form) const;\n\n  void print(raw_ostream &O) const;\n};\n\n//===--------------------------------------------------------------------===//\n/// DIEBlock - Represents a block of values.\n//\nclass DIEBlock : public DIEValueList {\n  mutable unsigned Size = 0; // Size in bytes excluding size header.\n\npublic:\n  DIEBlock() = default;\n\n  /// ComputeSize - Calculate the size of the location expression.\n  ///\n  unsigned ComputeSize(const AsmPrinter *AP) const;\n\n  // TODO: move setSize() and Size to DIEValueList.\n  void setSize(unsigned size) { Size = size; }\n\n  /// BestForm - Choose the best form for data.\n  ///\n  dwarf::Form BestForm() const {\n    if ((unsigned char)Size == Size)\n      return dwarf::DW_FORM_block1;\n    if ((unsigned short)Size == Size)\n      return dwarf::DW_FORM_block2;\n    if ((unsigned int)Size == Size)\n      return dwarf::DW_FORM_block4;\n    return dwarf::DW_FORM_block;\n  }\n\n  void emitValue(const AsmPrinter *Asm, dwarf::Form Form) const;\n  unsigned SizeOf(const AsmPrinter *AP, dwarf::Form Form) const;\n\n  void print(raw_ostream &O) const;\n};\n\n} // end namespace llvm\n\n#endif // LLVM_CODEGEN_DIE_H\n"}, "24": {"id": 24, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/CodeGen/DwarfStringPoolEntry.h", "content": "//===- llvm/CodeGen/DwarfStringPoolEntry.h - String pool entry --*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_CODEGEN_DWARFSTRINGPOOLENTRY_H\n#define LLVM_CODEGEN_DWARFSTRINGPOOLENTRY_H\n\n#include \"llvm/ADT/PointerIntPair.h\"\n#include \"llvm/ADT/StringMap.h\"\n\nnamespace llvm {\n\nclass MCSymbol;\n\n/// Data for a string pool entry.\nstruct DwarfStringPoolEntry {\n  static constexpr unsigned NotIndexed = -1;\n\n  MCSymbol *Symbol;\n  uint64_t Offset;\n  unsigned Index;\n\n  bool isIndexed() const { return Index != NotIndexed; }\n};\n\n/// String pool entry reference.\nclass DwarfStringPoolEntryRef {\n  PointerIntPair<const StringMapEntry<DwarfStringPoolEntry> *, 1, bool>\n      MapEntryAndIndexed;\n\n  const StringMapEntry<DwarfStringPoolEntry> *getMapEntry() const {\n    return MapEntryAndIndexed.getPointer();\n  }\n\npublic:\n  DwarfStringPoolEntryRef() = default;\n  DwarfStringPoolEntryRef(const StringMapEntry<DwarfStringPoolEntry> &Entry,\n                          bool Indexed)\n      : MapEntryAndIndexed(&Entry, Indexed) {}\n\n  explicit operator bool() const { return getMapEntry(); }\n  MCSymbol *getSymbol() const {\n    assert(getMapEntry()->second.Symbol && \"No symbol available!\");\n    return getMapEntry()->second.Symbol;\n  }\n  uint64_t getOffset() const { return getMapEntry()->second.Offset; }\n  bool isIndexed() const { return MapEntryAndIndexed.getInt(); }\n  unsigned getIndex() const {\n    assert(isIndexed());\n    assert(getMapEntry()->getValue().isIndexed());\n    return getMapEntry()->second.Index;\n  }\n  StringRef getString() const { return getMapEntry()->first(); }\n  /// Return the entire string pool entry for convenience.\n  DwarfStringPoolEntry getEntry() const { return getMapEntry()->getValue(); }\n\n  bool operator==(const DwarfStringPoolEntryRef &X) const {\n    return getMapEntry() == X.getMapEntry();\n  }\n  bool operator!=(const DwarfStringPoolEntryRef &X) const {\n    return getMapEntry() != X.getMapEntry();\n  }\n};\n\n} // end namespace llvm\n\n#endif\n"}, "25": {"id": 25, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/CodeGen/MachineBasicBlock.h", "content": "//===- llvm/CodeGen/MachineBasicBlock.h -------------------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// Collect the sequence of machine instructions for a basic block.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_CODEGEN_MACHINEBASICBLOCK_H\n#define LLVM_CODEGEN_MACHINEBASICBLOCK_H\n\n#include \"llvm/ADT/GraphTraits.h\"\n#include \"llvm/ADT/ilist.h\"\n#include \"llvm/ADT/iterator_range.h\"\n#include \"llvm/ADT/SparseBitVector.h\"\n#include \"llvm/CodeGen/MachineInstr.h\"\n#include \"llvm/CodeGen/MachineInstrBundleIterator.h\"\n#include \"llvm/IR/DebugLoc.h\"\n#include \"llvm/MC/LaneBitmask.h\"\n#include \"llvm/Support/BranchProbability.h\"\n#include <cassert>\n#include <cstdint>\n#include <functional>\n#include <iterator>\n#include <string>\n#include <vector>\n\nnamespace llvm {\n\nclass BasicBlock;\nclass MachineFunction;\nclass MCSymbol;\nclass ModuleSlotTracker;\nclass Pass;\nclass Printable;\nclass SlotIndexes;\nclass StringRef;\nclass raw_ostream;\nclass LiveIntervals;\nclass TargetRegisterClass;\nclass TargetRegisterInfo;\n\n// This structure uniquely identifies a basic block section.\n// Possible values are\n//  {Type: Default, Number: (unsigned)} (These are regular section IDs)\n//  {Type: Exception, Number: 0}  (ExceptionSectionID)\n//  {Type: Cold, Number: 0}  (ColdSectionID)\nstruct MBBSectionID {\n  enum SectionType {\n    Default = 0, // Regular section (these sections are distinguished by the\n                 // Number field).\n    Exception,   // Special section type for exception handling blocks\n    Cold,        // Special section type for cold blocks\n  } Type;\n  unsigned Number;\n\n  MBBSectionID(unsigned N) : Type(Default), Number(N) {}\n\n  // Special unique sections for cold and exception blocks.\n  const static MBBSectionID ColdSectionID;\n  const static MBBSectionID ExceptionSectionID;\n\n  bool operator==(const MBBSectionID &Other) const {\n    return Type == Other.Type && Number == Other.Number;\n  }\n\n  bool operator!=(const MBBSectionID &Other) const { return !(*this == Other); }\n\nprivate:\n  // This is only used to construct the special cold and exception sections.\n  MBBSectionID(SectionType T) : Type(T), Number(0) {}\n};\n\ntemplate <> struct ilist_traits<MachineInstr> {\nprivate:\n  friend class MachineBasicBlock; // Set by the owning MachineBasicBlock.\n\n  MachineBasicBlock *Parent;\n\n  using instr_iterator =\n      simple_ilist<MachineInstr, ilist_sentinel_tracking<true>>::iterator;\n\npublic:\n  void addNodeToList(MachineInstr *N);\n  void removeNodeFromList(MachineInstr *N);\n  void transferNodesFromList(ilist_traits &FromList, instr_iterator First,\n                             instr_iterator Last);\n  void deleteNode(MachineInstr *MI);\n};\n\nclass MachineBasicBlock\n    : public ilist_node_with_parent<MachineBasicBlock, MachineFunction> {\npublic:\n  /// Pair of physical register and lane mask.\n  /// This is not simply a std::pair typedef because the members should be named\n  /// clearly as they both have an integer type.\n  struct RegisterMaskPair {\n  public:\n    MCPhysReg PhysReg;\n    LaneBitmask LaneMask;\n\n    RegisterMaskPair(MCPhysReg PhysReg, LaneBitmask LaneMask)\n        : PhysReg(PhysReg), LaneMask(LaneMask) {}\n  };\n\nprivate:\n  using Instructions = ilist<MachineInstr, ilist_sentinel_tracking<true>>;\n\n  Instructions Insts;\n  const BasicBlock *BB;\n  int Number;\n  MachineFunction *xParent;\n\n  /// Keep track of the predecessor / successor basic blocks.\n  std::vector<MachineBasicBlock *> Predecessors;\n  std::vector<MachineBasicBlock *> Successors;\n\n  /// Keep track of the probabilities to the successors. This vector has the\n  /// same order as Successors, or it is empty if we don't use it (disable\n  /// optimization).\n  std::vector<BranchProbability> Probs;\n  using probability_iterator = std::vector<BranchProbability>::iterator;\n  using const_probability_iterator =\n      std::vector<BranchProbability>::const_iterator;\n\n  Optional<uint64_t> IrrLoopHeaderWeight;\n\n  /// Keep track of the physical registers that are livein of the basicblock.\n  using LiveInVector = std::vector<RegisterMaskPair>;\n  LiveInVector LiveIns;\n\n  /// Alignment of the basic block. One if the basic block does not need to be\n  /// aligned.\n  Align Alignment;\n\n  /// Indicate that this basic block is entered via an exception handler.\n  bool IsEHPad = false;\n\n  /// Indicate that this basic block is potentially the target of an indirect\n  /// branch.\n  bool AddressTaken = false;\n\n  /// Indicate that this basic block needs its symbol be emitted regardless of\n  /// whether the flow just falls-through to it.\n  bool LabelMustBeEmitted = false;\n\n  /// Indicate that this basic block is the entry block of an EH scope, i.e.,\n  /// the block that used to have a catchpad or cleanuppad instruction in the\n  /// LLVM IR.\n  bool IsEHScopeEntry = false;\n\n  /// Indicates if this is a target block of a catchret.\n  bool IsEHCatchretTarget = false;\n\n  /// Indicate that this basic block is the entry block of an EH funclet.\n  bool IsEHFuncletEntry = false;\n\n  /// Indicate that this basic block is the entry block of a cleanup funclet.\n  bool IsCleanupFuncletEntry = false;\n\n  /// With basic block sections, this stores the Section ID of the basic block.\n  MBBSectionID SectionID{0};\n\n  // Indicate that this basic block begins a section.\n  bool IsBeginSection = false;\n\n  // Indicate that this basic block ends a section.\n  bool IsEndSection = false;\n\n  /// Indicate that this basic block is the indirect dest of an INLINEASM_BR.\n  bool IsInlineAsmBrIndirectTarget = false;\n\n  /// since getSymbol is a relatively heavy-weight operation, the symbol\n  /// is only computed once and is cached.\n  mutable MCSymbol *CachedMCSymbol = nullptr;\n\n  /// Cached MCSymbol for this block (used if IsEHCatchRetTarget).\n  mutable MCSymbol *CachedEHCatchretMCSymbol = nullptr;\n\n  /// Marks the end of the basic block. Used during basic block sections to\n  /// calculate the size of the basic block, or the BB section ending with it.\n  mutable MCSymbol *CachedEndMCSymbol = nullptr;\n\n  // Intrusive list support\n  MachineBasicBlock() = default;\n\n  explicit MachineBasicBlock(MachineFunction &MF, const BasicBlock *BB);\n\n  ~MachineBasicBlock();\n\n  // MachineBasicBlocks are allocated and owned by MachineFunction.\n  friend class MachineFunction;\n\npublic:\n  /// Return the LLVM basic block that this instance corresponded to originally.\n  /// Note that this may be NULL if this instance does not correspond directly\n  /// to an LLVM basic block.\n  const BasicBlock *getBasicBlock() const { return BB; }\n\n  /// Return the name of the corresponding LLVM basic block, or an empty string.\n  StringRef getName() const;\n\n  /// Return a formatted string to identify this block and its parent function.\n  std::string getFullName() const;\n\n  /// Test whether this block is potentially the target of an indirect branch.\n  bool hasAddressTaken() const { return AddressTaken; }\n\n  /// Set this block to reflect that it potentially is the target of an indirect\n  /// branch.\n  void setHasAddressTaken() { AddressTaken = true; }\n\n  /// Test whether this block must have its label emitted.\n  bool hasLabelMustBeEmitted() const { return LabelMustBeEmitted; }\n\n  /// Set this block to reflect that, regardless how we flow to it, we need\n  /// its label be emitted.\n  void setLabelMustBeEmitted() { LabelMustBeEmitted = true; }\n\n  /// Return the MachineFunction containing this basic block.\n  const MachineFunction *getParent() const { return xParent; }\n  MachineFunction *getParent() { return xParent; }\n\n  using instr_iterator = Instructions::iterator;\n  using const_instr_iterator = Instructions::const_iterator;\n  using reverse_instr_iterator = Instructions::reverse_iterator;\n  using const_reverse_instr_iterator = Instructions::const_reverse_iterator;\n\n  using iterator = MachineInstrBundleIterator<MachineInstr>;\n  using const_iterator = MachineInstrBundleIterator<const MachineInstr>;\n  using reverse_iterator = MachineInstrBundleIterator<MachineInstr, true>;\n  using const_reverse_iterator =\n      MachineInstrBundleIterator<const MachineInstr, true>;\n\n  unsigned size() const { return (unsigned)Insts.size(); }\n  bool empty() const { return Insts.empty(); }\n\n  MachineInstr       &instr_front()       { return Insts.front(); }\n  MachineInstr       &instr_back()        { return Insts.back();  }\n  const MachineInstr &instr_front() const { return Insts.front(); }\n  const MachineInstr &instr_back()  const { return Insts.back();  }\n\n  MachineInstr       &front()             { return Insts.front(); }\n  MachineInstr       &back()              { return *--end();      }\n  const MachineInstr &front()       const { return Insts.front(); }\n  const MachineInstr &back()        const { return *--end();      }\n\n  instr_iterator                instr_begin()       { return Insts.begin();  }\n  const_instr_iterator          instr_begin() const { return Insts.begin();  }\n  instr_iterator                  instr_end()       { return Insts.end();    }\n  const_instr_iterator            instr_end() const { return Insts.end();    }\n  reverse_instr_iterator       instr_rbegin()       { return Insts.rbegin(); }\n  const_reverse_instr_iterator instr_rbegin() const { return Insts.rbegin(); }\n  reverse_instr_iterator       instr_rend  ()       { return Insts.rend();   }\n  const_reverse_instr_iterator instr_rend  () const { return Insts.rend();   }\n\n  using instr_range = iterator_range<instr_iterator>;\n  using const_instr_range = iterator_range<const_instr_iterator>;\n  instr_range instrs() { return instr_range(instr_begin(), instr_end()); }\n  const_instr_range instrs() const {\n    return const_instr_range(instr_begin(), instr_end());\n  }\n\n  iterator                begin()       { return instr_begin();  }\n  const_iterator          begin() const { return instr_begin();  }\n  iterator                end  ()       { return instr_end();    }\n  const_iterator          end  () const { return instr_end();    }\n  reverse_iterator rbegin() {\n    return reverse_iterator::getAtBundleBegin(instr_rbegin());\n  }\n  const_reverse_iterator rbegin() const {\n    return const_reverse_iterator::getAtBundleBegin(instr_rbegin());\n  }\n  reverse_iterator rend() { return reverse_iterator(instr_rend()); }\n  const_reverse_iterator rend() const {\n    return const_reverse_iterator(instr_rend());\n  }\n\n  /// Support for MachineInstr::getNextNode().\n  static Instructions MachineBasicBlock::*getSublistAccess(MachineInstr *) {\n    return &MachineBasicBlock::Insts;\n  }\n\n  inline iterator_range<iterator> terminators() {\n    return make_range(getFirstTerminator(), end());\n  }\n  inline iterator_range<const_iterator> terminators() const {\n    return make_range(getFirstTerminator(), end());\n  }\n\n  /// Returns a range that iterates over the phis in the basic block.\n  inline iterator_range<iterator> phis() {\n    return make_range(begin(), getFirstNonPHI());\n  }\n  inline iterator_range<const_iterator> phis() const {\n    return const_cast<MachineBasicBlock *>(this)->phis();\n  }\n\n  // Machine-CFG iterators\n  using pred_iterator = std::vector<MachineBasicBlock *>::iterator;\n  using const_pred_iterator = std::vector<MachineBasicBlock *>::const_iterator;\n  using succ_iterator = std::vector<MachineBasicBlock *>::iterator;\n  using const_succ_iterator = std::vector<MachineBasicBlock *>::const_iterator;\n  using pred_reverse_iterator =\n      std::vector<MachineBasicBlock *>::reverse_iterator;\n  using const_pred_reverse_iterator =\n      std::vector<MachineBasicBlock *>::const_reverse_iterator;\n  using succ_reverse_iterator =\n      std::vector<MachineBasicBlock *>::reverse_iterator;\n  using const_succ_reverse_iterator =\n      std::vector<MachineBasicBlock *>::const_reverse_iterator;\n  pred_iterator        pred_begin()       { return Predecessors.begin(); }\n  const_pred_iterator  pred_begin() const { return Predecessors.begin(); }\n  pred_iterator        pred_end()         { return Predecessors.end();   }\n  const_pred_iterator  pred_end()   const { return Predecessors.end();   }\n  pred_reverse_iterator        pred_rbegin()\n                                          { return Predecessors.rbegin();}\n  const_pred_reverse_iterator  pred_rbegin() const\n                                          { return Predecessors.rbegin();}\n  pred_reverse_iterator        pred_rend()\n                                          { return Predecessors.rend();  }\n  const_pred_reverse_iterator  pred_rend()   const\n                                          { return Predecessors.rend();  }\n  unsigned             pred_size()  const {\n    return (unsigned)Predecessors.size();\n  }\n  bool                 pred_empty() const { return Predecessors.empty(); }\n  succ_iterator        succ_begin()       { return Successors.begin();   }\n  const_succ_iterator  succ_begin() const { return Successors.begin();   }\n  succ_iterator        succ_end()         { return Successors.end();     }\n  const_succ_iterator  succ_end()   const { return Successors.end();     }\n  succ_reverse_iterator        succ_rbegin()\n                                          { return Successors.rbegin();  }\n  const_succ_reverse_iterator  succ_rbegin() const\n                                          { return Successors.rbegin();  }\n  succ_reverse_iterator        succ_rend()\n                                          { return Successors.rend();    }\n  const_succ_reverse_iterator  succ_rend()   const\n                                          { return Successors.rend();    }\n  unsigned             succ_size()  const {\n    return (unsigned)Successors.size();\n  }\n  bool                 succ_empty() const { return Successors.empty();   }\n\n  inline iterator_range<pred_iterator> predecessors() {\n    return make_range(pred_begin(), pred_end());\n  }\n  inline iterator_range<const_pred_iterator> predecessors() const {\n    return make_range(pred_begin(), pred_end());\n  }\n  inline iterator_range<succ_iterator> successors() {\n    return make_range(succ_begin(), succ_end());\n  }\n  inline iterator_range<const_succ_iterator> successors() const {\n    return make_range(succ_begin(), succ_end());\n  }\n\n  // LiveIn management methods.\n\n  /// Adds the specified register as a live in. Note that it is an error to add\n  /// the same register to the same set more than once unless the intention is\n  /// to call sortUniqueLiveIns after all registers are added.\n  void addLiveIn(MCRegister PhysReg,\n                 LaneBitmask LaneMask = LaneBitmask::getAll()) {\n    LiveIns.push_back(RegisterMaskPair(PhysReg, LaneMask));\n  }\n  void addLiveIn(const RegisterMaskPair &RegMaskPair) {\n    LiveIns.push_back(RegMaskPair);\n  }\n\n  /// Sorts and uniques the LiveIns vector. It can be significantly faster to do\n  /// this than repeatedly calling isLiveIn before calling addLiveIn for every\n  /// LiveIn insertion.\n  void sortUniqueLiveIns();\n\n  /// Clear live in list.\n  void clearLiveIns();\n\n  /// Add PhysReg as live in to this block, and ensure that there is a copy of\n  /// PhysReg to a virtual register of class RC. Return the virtual register\n  /// that is a copy of the live in PhysReg.\n  Register addLiveIn(MCRegister PhysReg, const TargetRegisterClass *RC);\n\n  /// Remove the specified register from the live in set.\n  void removeLiveIn(MCPhysReg Reg,\n                    LaneBitmask LaneMask = LaneBitmask::getAll());\n\n  /// Return true if the specified register is in the live in set.\n  bool isLiveIn(MCPhysReg Reg,\n                LaneBitmask LaneMask = LaneBitmask::getAll()) const;\n\n  // Iteration support for live in sets.  These sets are kept in sorted\n  // order by their register number.\n  using livein_iterator = LiveInVector::const_iterator;\n#ifndef NDEBUG\n  /// Unlike livein_begin, this method does not check that the liveness\n  /// information is accurate. Still for debug purposes it may be useful\n  /// to have iterators that won't assert if the liveness information\n  /// is not current.\n  livein_iterator livein_begin_dbg() const { return LiveIns.begin(); }\n  iterator_range<livein_iterator> liveins_dbg() const {\n    return make_range(livein_begin_dbg(), livein_end());\n  }\n#endif\n  livein_iterator livein_begin() const;\n  livein_iterator livein_end()   const { return LiveIns.end(); }\n  bool            livein_empty() const { return LiveIns.empty(); }\n  iterator_range<livein_iterator> liveins() const {\n    return make_range(livein_begin(), livein_end());\n  }\n\n  /// Remove entry from the livein set and return iterator to the next.\n  livein_iterator removeLiveIn(livein_iterator I);\n\n  /// Get the clobber mask for the start of this basic block. Funclets use this\n  /// to prevent register allocation across funclet transitions.\n  const uint32_t *getBeginClobberMask(const TargetRegisterInfo *TRI) const;\n\n  /// Get the clobber mask for the end of the basic block.\n  /// \\see getBeginClobberMask()\n  const uint32_t *getEndClobberMask(const TargetRegisterInfo *TRI) const;\n\n  /// Return alignment of the basic block.\n  Align getAlignment() const { return Alignment; }\n\n  /// Set alignment of the basic block.\n  void setAlignment(Align A) { Alignment = A; }\n\n  /// Returns true if the block is a landing pad. That is this basic block is\n  /// entered via an exception handler.\n  bool isEHPad() const { return IsEHPad; }\n\n  /// Indicates the block is a landing pad.  That is this basic block is entered\n  /// via an exception handler.\n  void setIsEHPad(bool V = true) { IsEHPad = V; }\n\n  bool hasEHPadSuccessor() const;\n\n  /// Returns true if this is the entry block of the function.\n  bool isEntryBlock() const;\n\n  /// Returns true if this is the entry block of an EH scope, i.e., the block\n  /// that used to have a catchpad or cleanuppad instruction in the LLVM IR.\n  bool isEHScopeEntry() const { return IsEHScopeEntry; }\n\n  /// Indicates if this is the entry block of an EH scope, i.e., the block that\n  /// that used to have a catchpad or cleanuppad instruction in the LLVM IR.\n  void setIsEHScopeEntry(bool V = true) { IsEHScopeEntry = V; }\n\n  /// Returns true if this is a target block of a catchret.\n  bool isEHCatchretTarget() const { return IsEHCatchretTarget; }\n\n  /// Indicates if this is a target block of a catchret.\n  void setIsEHCatchretTarget(bool V = true) { IsEHCatchretTarget = V; }\n\n  /// Returns true if this is the entry block of an EH funclet.\n  bool isEHFuncletEntry() const { return IsEHFuncletEntry; }\n\n  /// Indicates if this is the entry block of an EH funclet.\n  void setIsEHFuncletEntry(bool V = true) { IsEHFuncletEntry = V; }\n\n  /// Returns true if this is the entry block of a cleanup funclet.\n  bool isCleanupFuncletEntry() const { return IsCleanupFuncletEntry; }\n\n  /// Indicates if this is the entry block of a cleanup funclet.\n  void setIsCleanupFuncletEntry(bool V = true) { IsCleanupFuncletEntry = V; }\n\n  /// Returns true if this block begins any section.\n  bool isBeginSection() const { return IsBeginSection; }\n\n  /// Returns true if this block ends any section.\n  bool isEndSection() const { return IsEndSection; }\n\n  void setIsBeginSection(bool V = true) { IsBeginSection = V; }\n\n  void setIsEndSection(bool V = true) { IsEndSection = V; }\n\n  /// Returns the section ID of this basic block.\n  MBBSectionID getSectionID() const { return SectionID; }\n\n  /// Returns the unique section ID number of this basic block.\n  unsigned getSectionIDNum() const {\n    return ((unsigned)MBBSectionID::SectionType::Cold) -\n           ((unsigned)SectionID.Type) + SectionID.Number;\n  }\n\n  /// Sets the section ID for this basic block.\n  void setSectionID(MBBSectionID V) { SectionID = V; }\n\n  /// Returns the MCSymbol marking the end of this basic block.\n  MCSymbol *getEndSymbol() const;\n\n  /// Returns true if this block may have an INLINEASM_BR (overestimate, by\n  /// checking if any of the successors are indirect targets of any inlineasm_br\n  /// in the function).\n  bool mayHaveInlineAsmBr() const;\n\n  /// Returns true if this is the indirect dest of an INLINEASM_BR.\n  bool isInlineAsmBrIndirectTarget() const {\n    return IsInlineAsmBrIndirectTarget;\n  }\n\n  /// Indicates if this is the indirect dest of an INLINEASM_BR.\n  void setIsInlineAsmBrIndirectTarget(bool V = true) {\n    IsInlineAsmBrIndirectTarget = V;\n  }\n\n  /// Returns true if it is legal to hoist instructions into this block.\n  bool isLegalToHoistInto() const;\n\n  // Code Layout methods.\n\n  /// Move 'this' block before or after the specified block.  This only moves\n  /// the block, it does not modify the CFG or adjust potential fall-throughs at\n  /// the end of the block.\n  void moveBefore(MachineBasicBlock *NewAfter);\n  void moveAfter(MachineBasicBlock *NewBefore);\n\n  /// Returns true if this and MBB belong to the same section.\n  bool sameSection(const MachineBasicBlock *MBB) const {\n    return getSectionID() == MBB->getSectionID();\n  }\n\n  /// Update the terminator instructions in block to account for changes to\n  /// block layout which may have been made. PreviousLayoutSuccessor should be\n  /// set to the block which may have been used as fallthrough before the block\n  /// layout was modified.  If the block previously fell through to that block,\n  /// it may now need a branch. If it previously branched to another block, it\n  /// may now be able to fallthrough to the current layout successor.\n  void updateTerminator(MachineBasicBlock *PreviousLayoutSuccessor);\n\n  // Machine-CFG mutators\n\n  /// Add Succ as a successor of this MachineBasicBlock.  The Predecessors list\n  /// of Succ is automatically updated. PROB parameter is stored in\n  /// Probabilities list. The default probability is set as unknown. Mixing\n  /// known and unknown probabilities in successor list is not allowed. When all\n  /// successors have unknown probabilities, 1 / N is returned as the\n  /// probability for each successor, where N is the number of successors.\n  ///\n  /// Note that duplicate Machine CFG edges are not allowed.\n  void addSuccessor(MachineBasicBlock *Succ,\n                    BranchProbability Prob = BranchProbability::getUnknown());\n\n  /// Add Succ as a successor of this MachineBasicBlock.  The Predecessors list\n  /// of Succ is automatically updated. The probability is not provided because\n  /// BPI is not available (e.g. -O0 is used), in which case edge probabilities\n  /// won't be used. Using this interface can save some space.\n  void addSuccessorWithoutProb(MachineBasicBlock *Succ);\n\n  /// Set successor probability of a given iterator.\n  void setSuccProbability(succ_iterator I, BranchProbability Prob);\n\n  /// Normalize probabilities of all successors so that the sum of them becomes\n  /// one. This is usually done when the current update on this MBB is done, and\n  /// the sum of its successors' probabilities is not guaranteed to be one. The\n  /// user is responsible for the correct use of this function.\n  /// MBB::removeSuccessor() has an option to do this automatically.\n  void normalizeSuccProbs() {\n    BranchProbability::normalizeProbabilities(Probs.begin(), Probs.end());\n  }\n\n  /// Validate successors' probabilities and check if the sum of them is\n  /// approximate one. This only works in DEBUG mode.\n  void validateSuccProbs() const;\n\n  /// Remove successor from the successors list of this MachineBasicBlock. The\n  /// Predecessors list of Succ is automatically updated.\n  /// If NormalizeSuccProbs is true, then normalize successors' probabilities\n  /// after the successor is removed.\n  void removeSuccessor(MachineBasicBlock *Succ,\n                       bool NormalizeSuccProbs = false);\n\n  /// Remove specified successor from the successors list of this\n  /// MachineBasicBlock. The Predecessors list of Succ is automatically updated.\n  /// If NormalizeSuccProbs is true, then normalize successors' probabilities\n  /// after the successor is removed.\n  /// Return the iterator to the element after the one removed.\n  succ_iterator removeSuccessor(succ_iterator I,\n                                bool NormalizeSuccProbs = false);\n\n  /// Replace successor OLD with NEW and update probability info.\n  void replaceSuccessor(MachineBasicBlock *Old, MachineBasicBlock *New);\n\n  /// Copy a successor (and any probability info) from original block to this\n  /// block's. Uses an iterator into the original blocks successors.\n  ///\n  /// This is useful when doing a partial clone of successors. Afterward, the\n  /// probabilities may need to be normalized.\n  void copySuccessor(MachineBasicBlock *Orig, succ_iterator I);\n\n  /// Split the old successor into old plus new and updates the probability\n  /// info.\n  void splitSuccessor(MachineBasicBlock *Old, MachineBasicBlock *New,\n                      bool NormalizeSuccProbs = false);\n\n  /// Transfers all the successors from MBB to this machine basic block (i.e.,\n  /// copies all the successors FromMBB and remove all the successors from\n  /// FromMBB).\n  void transferSuccessors(MachineBasicBlock *FromMBB);\n\n  /// Transfers all the successors, as in transferSuccessors, and update PHI\n  /// operands in the successor blocks which refer to FromMBB to refer to this.\n  void transferSuccessorsAndUpdatePHIs(MachineBasicBlock *FromMBB);\n\n  /// move all pseudo probes in this block to the end of /c ToMBB To and tag\n  /// them dangling.\n  void moveAndDanglePseudoProbes(MachineBasicBlock *ToMBB);\n\n  /// Return true if any of the successors have probabilities attached to them.\n  bool hasSuccessorProbabilities() const { return !Probs.empty(); }\n\n  /// Return true if the specified MBB is a predecessor of this block.\n  bool isPredecessor(const MachineBasicBlock *MBB) const;\n\n  /// Return true if the specified MBB is a successor of this block.\n  bool isSuccessor(const MachineBasicBlock *MBB) const;\n\n  /// Return true if the specified MBB will be emitted immediately after this\n  /// block, such that if this block exits by falling through, control will\n  /// transfer to the specified MBB. Note that MBB need not be a successor at\n  /// all, for example if this block ends with an unconditional branch to some\n  /// other block.\n  bool isLayoutSuccessor(const MachineBasicBlock *MBB) const;\n\n  /// Return the fallthrough block if the block can implicitly\n  /// transfer control to the block after it by falling off the end of\n  /// it.  This should return null if it can reach the block after\n  /// it, but it uses an explicit branch to do so (e.g., a table\n  /// jump).  Non-null return  is a conservative answer.\n  MachineBasicBlock *getFallThrough();\n\n  /// Return true if the block can implicitly transfer control to the\n  /// block after it by falling off the end of it.  This should return\n  /// false if it can reach the block after it, but it uses an\n  /// explicit branch to do so (e.g., a table jump).  True is a\n  /// conservative answer.\n  bool canFallThrough();\n\n  /// Returns a pointer to the first instruction in this block that is not a\n  /// PHINode instruction. When adding instructions to the beginning of the\n  /// basic block, they should be added before the returned value, not before\n  /// the first instruction, which might be PHI.\n  /// Returns end() is there's no non-PHI instruction.\n  iterator getFirstNonPHI();\n\n  /// Return the first instruction in MBB after I that is not a PHI or a label.\n  /// This is the correct point to insert lowered copies at the beginning of a\n  /// basic block that must be before any debugging information.\n  iterator SkipPHIsAndLabels(iterator I);\n\n  /// Return the first instruction in MBB after I that is not a PHI, label or\n  /// debug.  This is the correct point to insert copies at the beginning of a\n  /// basic block.\n  iterator SkipPHIsLabelsAndDebug(iterator I);\n\n  /// Returns an iterator to the first terminator instruction of this basic\n  /// block. If a terminator does not exist, it returns end().\n  iterator getFirstTerminator();\n  const_iterator getFirstTerminator() const {\n    return const_cast<MachineBasicBlock *>(this)->getFirstTerminator();\n  }\n\n  /// Same getFirstTerminator but it ignores bundles and return an\n  /// instr_iterator instead.\n  instr_iterator getFirstInstrTerminator();\n\n  /// Returns an iterator to the first non-debug instruction in the basic block,\n  /// or end(). Skip any pseudo probe operation if \\c SkipPseudoOp is true.\n  /// Pseudo probes are like debug instructions which do not turn into real\n  /// machine code. We try to use the function to skip both debug instructions\n  /// and pseudo probe operations to avoid API proliferation. This should work\n  /// most of the time when considering optimizing the rest of code in the\n  /// block, except for certain cases where pseudo probes are designed to block\n  /// the optimizations. For example, code merge like optimizations are supposed\n  /// to be blocked by pseudo probes for better AutoFDO profile quality.\n  /// Therefore, they should be considered as a valid instruction when this\n  /// function is called in a context of such optimizations. On the other hand,\n  /// \\c SkipPseudoOp should be true when it's used in optimizations that\n  /// unlikely hurt profile quality, e.g., without block merging.\n  /// TODO: flip the default value of \\c SkipPseudoOp to maximize code quality\n  /// with pseudo probes.\n  iterator getFirstNonDebugInstr(bool SkipPseudoOp = false);\n  const_iterator getFirstNonDebugInstr(bool SkipPseudoOp = false) const {\n    return const_cast<MachineBasicBlock *>(this)->getFirstNonDebugInstr(\n        SkipPseudoOp);\n  }\n\n  /// Returns an iterator to the last non-debug instruction in the basic block,\n  /// or end(). Skip any pseudo operation if \\c SkipPseudoOp is true.\n  /// Pseudo probes are like debug instructions which do not turn into real\n  /// machine code. We try to use the function to skip both debug instructions\n  /// and pseudo probe operations to avoid API proliferation. This should work\n  /// most of the time when considering optimizing the rest of code in the\n  /// block, except for certain cases where pseudo probes are designed to block\n  /// the optimizations. For example, code merge like optimizations are supposed\n  /// to be blocked by pseudo probes for better AutoFDO profile quality.\n  /// Therefore, they should be considered as a valid instruction when this\n  /// function is called in a context of such optimizations. On the other hand,\n  /// \\c SkipPseudoOp should be true when it's used in optimizations that\n  /// unlikely hurt profile quality, e.g., without block merging.\n  iterator getLastNonDebugInstr(bool SkipPseudoOp = false);\n  const_iterator getLastNonDebugInstr(bool SkipPseudoOp = false) const {\n    return const_cast<MachineBasicBlock *>(this)->getLastNonDebugInstr(\n        SkipPseudoOp);\n  }\n\n  /// Convenience function that returns true if the block ends in a return\n  /// instruction.\n  bool isReturnBlock() const {\n    return !empty() && back().isReturn();\n  }\n\n  /// Convenience function that returns true if the bock ends in a EH scope\n  /// return instruction.\n  bool isEHScopeReturnBlock() const {\n    return !empty() && back().isEHScopeReturn();\n  }\n\n  /// Split a basic block into 2 pieces at \\p SplitPoint. A new block will be\n  /// inserted after this block, and all instructions after \\p SplitInst moved\n  /// to it (\\p SplitInst will be in the original block). If \\p LIS is provided,\n  /// LiveIntervals will be appropriately updated. \\return the newly inserted\n  /// block.\n  ///\n  /// If \\p UpdateLiveIns is true, this will ensure the live ins list is\n  /// accurate, including for physreg uses/defs in the original block.\n  MachineBasicBlock *splitAt(MachineInstr &SplitInst, bool UpdateLiveIns = true,\n                             LiveIntervals *LIS = nullptr);\n\n  /// Split the critical edge from this block to the given successor block, and\n  /// return the newly created block, or null if splitting is not possible.\n  ///\n  /// This function updates LiveVariables, MachineDominatorTree, and\n  /// MachineLoopInfo, as applicable.\n  MachineBasicBlock *\n  SplitCriticalEdge(MachineBasicBlock *Succ, Pass &P,\n                    std::vector<SparseBitVector<>> *LiveInSets = nullptr);\n\n  /// Check if the edge between this block and the given successor \\p\n  /// Succ, can be split. If this returns true a subsequent call to\n  /// SplitCriticalEdge is guaranteed to return a valid basic block if\n  /// no changes occurred in the meantime.\n  bool canSplitCriticalEdge(const MachineBasicBlock *Succ) const;\n\n  void pop_front() { Insts.pop_front(); }\n  void pop_back() { Insts.pop_back(); }\n  void push_back(MachineInstr *MI) { Insts.push_back(MI); }\n\n  /// Insert MI into the instruction list before I, possibly inside a bundle.\n  ///\n  /// If the insertion point is inside a bundle, MI will be added to the bundle,\n  /// otherwise MI will not be added to any bundle. That means this function\n  /// alone can't be used to prepend or append instructions to bundles. See\n  /// MIBundleBuilder::insert() for a more reliable way of doing that.\n  instr_iterator insert(instr_iterator I, MachineInstr *M);\n\n  /// Insert a range of instructions into the instruction list before I.\n  template<typename IT>\n  void insert(iterator I, IT S, IT E) {\n    assert((I == end() || I->getParent() == this) &&\n           \"iterator points outside of basic block\");\n    Insts.insert(I.getInstrIterator(), S, E);\n  }\n\n  /// Insert MI into the instruction list before I.\n  iterator insert(iterator I, MachineInstr *MI) {\n    assert((I == end() || I->getParent() == this) &&\n           \"iterator points outside of basic block\");\n    assert(!MI->isBundledWithPred() && !MI->isBundledWithSucc() &&\n           \"Cannot insert instruction with bundle flags\");\n    return Insts.insert(I.getInstrIterator(), MI);\n  }\n\n  /// Insert MI into the instruction list after I.\n  iterator insertAfter(iterator I, MachineInstr *MI) {\n    assert((I == end() || I->getParent() == this) &&\n           \"iterator points outside of basic block\");\n    assert(!MI->isBundledWithPred() && !MI->isBundledWithSucc() &&\n           \"Cannot insert instruction with bundle flags\");\n    return Insts.insertAfter(I.getInstrIterator(), MI);\n  }\n\n  /// If I is bundled then insert MI into the instruction list after the end of\n  /// the bundle, otherwise insert MI immediately after I.\n  instr_iterator insertAfterBundle(instr_iterator I, MachineInstr *MI) {\n    assert((I == instr_end() || I->getParent() == this) &&\n           \"iterator points outside of basic block\");\n    assert(!MI->isBundledWithPred() && !MI->isBundledWithSucc() &&\n           \"Cannot insert instruction with bundle flags\");\n    while (I->isBundledWithSucc())\n      ++I;\n    return Insts.insertAfter(I, MI);\n  }\n\n  /// Remove an instruction from the instruction list and delete it.\n  ///\n  /// If the instruction is part of a bundle, the other instructions in the\n  /// bundle will still be bundled after removing the single instruction.\n  instr_iterator erase(instr_iterator I);\n\n  /// Remove an instruction from the instruction list and delete it.\n  ///\n  /// If the instruction is part of a bundle, the other instructions in the\n  /// bundle will still be bundled after removing the single instruction.\n  instr_iterator erase_instr(MachineInstr *I) {\n    return erase(instr_iterator(I));\n  }\n\n  /// Remove a range of instructions from the instruction list and delete them.\n  iterator erase(iterator I, iterator E) {\n    return Insts.erase(I.getInstrIterator(), E.getInstrIterator());\n  }\n\n  /// Remove an instruction or bundle from the instruction list and delete it.\n  ///\n  /// If I points to a bundle of instructions, they are all erased.\n  iterator erase(iterator I) {\n    return erase(I, std::next(I));\n  }\n\n  /// Remove an instruction from the instruction list and delete it.\n  ///\n  /// If I is the head of a bundle of instructions, the whole bundle will be\n  /// erased.\n  iterator erase(MachineInstr *I) {\n    return erase(iterator(I));\n  }\n\n  /// Remove the unbundled instruction from the instruction list without\n  /// deleting it.\n  ///\n  /// This function can not be used to remove bundled instructions, use\n  /// remove_instr to remove individual instructions from a bundle.\n  MachineInstr *remove(MachineInstr *I) {\n    assert(!I->isBundled() && \"Cannot remove bundled instructions\");\n    return Insts.remove(instr_iterator(I));\n  }\n\n  /// Remove the possibly bundled instruction from the instruction list\n  /// without deleting it.\n  ///\n  /// If the instruction is part of a bundle, the other instructions in the\n  /// bundle will still be bundled after removing the single instruction.\n  MachineInstr *remove_instr(MachineInstr *I);\n\n  void clear() {\n    Insts.clear();\n  }\n\n  /// Take an instruction from MBB 'Other' at the position From, and insert it\n  /// into this MBB right before 'Where'.\n  ///\n  /// If From points to a bundle of instructions, the whole bundle is moved.\n  void splice(iterator Where, MachineBasicBlock *Other, iterator From) {\n    // The range splice() doesn't allow noop moves, but this one does.\n    if (Where != From)\n      splice(Where, Other, From, std::next(From));\n  }\n\n  /// Take a block of instructions from MBB 'Other' in the range [From, To),\n  /// and insert them into this MBB right before 'Where'.\n  ///\n  /// The instruction at 'Where' must not be included in the range of\n  /// instructions to move.\n  void splice(iterator Where, MachineBasicBlock *Other,\n              iterator From, iterator To) {\n    Insts.splice(Where.getInstrIterator(), Other->Insts,\n                 From.getInstrIterator(), To.getInstrIterator());\n  }\n\n  /// This method unlinks 'this' from the containing function, and returns it,\n  /// but does not delete it.\n  MachineBasicBlock *removeFromParent();\n\n  /// This method unlinks 'this' from the containing function and deletes it.\n  void eraseFromParent();\n\n  /// Given a machine basic block that branched to 'Old', change the code and\n  /// CFG so that it branches to 'New' instead.\n  void ReplaceUsesOfBlockWith(MachineBasicBlock *Old, MachineBasicBlock *New);\n\n  /// Update all phi nodes in this basic block to refer to basic block \\p New\n  /// instead of basic block \\p Old.\n  void replacePhiUsesWith(MachineBasicBlock *Old, MachineBasicBlock *New);\n\n  /// Find the next valid DebugLoc starting at MBBI, skipping any DBG_VALUE\n  /// and DBG_LABEL instructions.  Return UnknownLoc if there is none.\n  DebugLoc findDebugLoc(instr_iterator MBBI);\n  DebugLoc findDebugLoc(iterator MBBI) {\n    return findDebugLoc(MBBI.getInstrIterator());\n  }\n\n  /// Has exact same behavior as @ref findDebugLoc (it also\n  /// searches from the first to the last MI of this MBB) except\n  /// that this takes reverse iterator.\n  DebugLoc rfindDebugLoc(reverse_instr_iterator MBBI);\n  DebugLoc rfindDebugLoc(reverse_iterator MBBI) {\n    return rfindDebugLoc(MBBI.getInstrIterator());\n  }\n\n  /// Find the previous valid DebugLoc preceding MBBI, skipping and DBG_VALUE\n  /// instructions.  Return UnknownLoc if there is none.\n  DebugLoc findPrevDebugLoc(instr_iterator MBBI);\n  DebugLoc findPrevDebugLoc(iterator MBBI) {\n    return findPrevDebugLoc(MBBI.getInstrIterator());\n  }\n\n  /// Has exact same behavior as @ref findPrevDebugLoc (it also\n  /// searches from the last to the first MI of this MBB) except\n  /// that this takes reverse iterator.\n  DebugLoc rfindPrevDebugLoc(reverse_instr_iterator MBBI);\n  DebugLoc rfindPrevDebugLoc(reverse_iterator MBBI) {\n    return rfindPrevDebugLoc(MBBI.getInstrIterator());\n  }\n\n  /// Find and return the merged DebugLoc of the branch instructions of the\n  /// block. Return UnknownLoc if there is none.\n  DebugLoc findBranchDebugLoc();\n\n  /// Possible outcome of a register liveness query to computeRegisterLiveness()\n  enum LivenessQueryResult {\n    LQR_Live,   ///< Register is known to be (at least partially) live.\n    LQR_Dead,   ///< Register is known to be fully dead.\n    LQR_Unknown ///< Register liveness not decidable from local neighborhood.\n  };\n\n  /// Return whether (physical) register \\p Reg has been defined and not\n  /// killed as of just before \\p Before.\n  ///\n  /// Search is localised to a neighborhood of \\p Neighborhood instructions\n  /// before (searching for defs or kills) and \\p Neighborhood instructions\n  /// after (searching just for defs) \\p Before.\n  ///\n  /// \\p Reg must be a physical register.\n  LivenessQueryResult computeRegisterLiveness(const TargetRegisterInfo *TRI,\n                                              MCRegister Reg,\n                                              const_iterator Before,\n                                              unsigned Neighborhood = 10) const;\n\n  // Debugging methods.\n  void dump() const;\n  void print(raw_ostream &OS, const SlotIndexes * = nullptr,\n             bool IsStandalone = true) const;\n  void print(raw_ostream &OS, ModuleSlotTracker &MST,\n             const SlotIndexes * = nullptr, bool IsStandalone = true) const;\n\n  enum PrintNameFlag {\n    PrintNameIr = (1 << 0), ///< Add IR name where available\n    PrintNameAttributes = (1 << 1), ///< Print attributes\n  };\n\n  void printName(raw_ostream &os, unsigned printNameFlags = PrintNameIr,\n                 ModuleSlotTracker *moduleSlotTracker = nullptr) const;\n\n  // Printing method used by LoopInfo.\n  void printAsOperand(raw_ostream &OS, bool PrintType = true) const;\n\n  /// MachineBasicBlocks are uniquely numbered at the function level, unless\n  /// they're not in a MachineFunction yet, in which case this will return -1.\n  int getNumber() const { return Number; }\n  void setNumber(int N) { Number = N; }\n\n  /// Return the MCSymbol for this basic block.\n  MCSymbol *getSymbol() const;\n\n  /// Return the EHCatchret Symbol for this basic block.\n  MCSymbol *getEHCatchretSymbol() const;\n\n  Optional<uint64_t> getIrrLoopHeaderWeight() const {\n    return IrrLoopHeaderWeight;\n  }\n\n  void setIrrLoopHeaderWeight(uint64_t Weight) {\n    IrrLoopHeaderWeight = Weight;\n  }\n\nprivate:\n  /// Return probability iterator corresponding to the I successor iterator.\n  probability_iterator getProbabilityIterator(succ_iterator I);\n  const_probability_iterator\n  getProbabilityIterator(const_succ_iterator I) const;\n\n  friend class MachineBranchProbabilityInfo;\n  friend class MIPrinter;\n\n  /// Return probability of the edge from this block to MBB. This method should\n  /// NOT be called directly, but by using getEdgeProbability method from\n  /// MachineBranchProbabilityInfo class.\n  BranchProbability getSuccProbability(const_succ_iterator Succ) const;\n\n  // Methods used to maintain doubly linked list of blocks...\n  friend struct ilist_callback_traits<MachineBasicBlock>;\n\n  // Machine-CFG mutators\n\n  /// Add Pred as a predecessor of this MachineBasicBlock. Don't do this\n  /// unless you know what you're doing, because it doesn't update Pred's\n  /// successors list. Use Pred->addSuccessor instead.\n  void addPredecessor(MachineBasicBlock *Pred);\n\n  /// Remove Pred as a predecessor of this MachineBasicBlock. Don't do this\n  /// unless you know what you're doing, because it doesn't update Pred's\n  /// successors list. Use Pred->removeSuccessor instead.\n  void removePredecessor(MachineBasicBlock *Pred);\n};\n\nraw_ostream& operator<<(raw_ostream &OS, const MachineBasicBlock &MBB);\n\n/// Prints a machine basic block reference.\n///\n/// The format is:\n///   %bb.5           - a machine basic block with MBB.getNumber() == 5.\n///\n/// Usage: OS << printMBBReference(MBB) << '\\n';\nPrintable printMBBReference(const MachineBasicBlock &MBB);\n\n// This is useful when building IndexedMaps keyed on basic block pointers.\nstruct MBB2NumberFunctor {\n  using argument_type = const MachineBasicBlock *;\n  unsigned operator()(const MachineBasicBlock *MBB) const {\n    return MBB->getNumber();\n  }\n};\n\n//===--------------------------------------------------------------------===//\n// GraphTraits specializations for machine basic block graphs (machine-CFGs)\n//===--------------------------------------------------------------------===//\n\n// Provide specializations of GraphTraits to be able to treat a\n// MachineFunction as a graph of MachineBasicBlocks.\n//\n\ntemplate <> struct GraphTraits<MachineBasicBlock *> {\n  using NodeRef = MachineBasicBlock *;\n  using ChildIteratorType = MachineBasicBlock::succ_iterator;\n\n  static NodeRef getEntryNode(MachineBasicBlock *BB) { return BB; }\n  static ChildIteratorType child_begin(NodeRef N) { return N->succ_begin(); }\n  static ChildIteratorType child_end(NodeRef N) { return N->succ_end(); }\n};\n\ntemplate <> struct GraphTraits<const MachineBasicBlock *> {\n  using NodeRef = const MachineBasicBlock *;\n  using ChildIteratorType = MachineBasicBlock::const_succ_iterator;\n\n  static NodeRef getEntryNode(const MachineBasicBlock *BB) { return BB; }\n  static ChildIteratorType child_begin(NodeRef N) { return N->succ_begin(); }\n  static ChildIteratorType child_end(NodeRef N) { return N->succ_end(); }\n};\n\n// Provide specializations of GraphTraits to be able to treat a\n// MachineFunction as a graph of MachineBasicBlocks and to walk it\n// in inverse order.  Inverse order for a function is considered\n// to be when traversing the predecessor edges of a MBB\n// instead of the successor edges.\n//\ntemplate <> struct GraphTraits<Inverse<MachineBasicBlock*>> {\n  using NodeRef = MachineBasicBlock *;\n  using ChildIteratorType = MachineBasicBlock::pred_iterator;\n\n  static NodeRef getEntryNode(Inverse<MachineBasicBlock *> G) {\n    return G.Graph;\n  }\n\n  static ChildIteratorType child_begin(NodeRef N) { return N->pred_begin(); }\n  static ChildIteratorType child_end(NodeRef N) { return N->pred_end(); }\n};\n\ntemplate <> struct GraphTraits<Inverse<const MachineBasicBlock*>> {\n  using NodeRef = const MachineBasicBlock *;\n  using ChildIteratorType = MachineBasicBlock::const_pred_iterator;\n\n  static NodeRef getEntryNode(Inverse<const MachineBasicBlock *> G) {\n    return G.Graph;\n  }\n\n  static ChildIteratorType child_begin(NodeRef N) { return N->pred_begin(); }\n  static ChildIteratorType child_end(NodeRef N) { return N->pred_end(); }\n};\n\n/// MachineInstrSpan provides an interface to get an iteration range\n/// containing the instruction it was initialized with, along with all\n/// those instructions inserted prior to or following that instruction\n/// at some point after the MachineInstrSpan is constructed.\nclass MachineInstrSpan {\n  MachineBasicBlock &MBB;\n  MachineBasicBlock::iterator I, B, E;\n\npublic:\n  MachineInstrSpan(MachineBasicBlock::iterator I, MachineBasicBlock *BB)\n      : MBB(*BB), I(I), B(I == MBB.begin() ? MBB.end() : std::prev(I)),\n        E(std::next(I)) {\n    assert(I == BB->end() || I->getParent() == BB);\n  }\n\n  MachineBasicBlock::iterator begin() {\n    return B == MBB.end() ? MBB.begin() : std::next(B);\n  }\n  MachineBasicBlock::iterator end() { return E; }\n  bool empty() { return begin() == end(); }\n\n  MachineBasicBlock::iterator getInitial() { return I; }\n};\n\n/// Increment \\p It until it points to a non-debug instruction or to \\p End\n/// and return the resulting iterator. This function should only be used\n/// MachineBasicBlock::{iterator, const_iterator, instr_iterator,\n/// const_instr_iterator} and the respective reverse iterators.\ntemplate <typename IterT>\ninline IterT skipDebugInstructionsForward(IterT It, IterT End,\n                                          bool SkipPseudoOp = false) {\n  while (It != End &&\n         (It->isDebugInstr() || (SkipPseudoOp && It->isPseudoProbe())))\n    ++It;\n  return It;\n}\n\n/// Decrement \\p It until it points to a non-debug instruction or to \\p Begin\n/// and return the resulting iterator. This function should only be used\n/// MachineBasicBlock::{iterator, const_iterator, instr_iterator,\n/// const_instr_iterator} and the respective reverse iterators.\ntemplate <class IterT>\ninline IterT skipDebugInstructionsBackward(IterT It, IterT Begin,\n                                           bool SkipPseudoOp = false) {\n  while (It != Begin &&\n         (It->isDebugInstr() || (SkipPseudoOp && It->isPseudoProbe())))\n    --It;\n  return It;\n}\n\n/// Increment \\p It, then continue incrementing it while it points to a debug\n/// instruction. A replacement for std::next.\ntemplate <typename IterT>\ninline IterT next_nodbg(IterT It, IterT End, bool SkipPseudoOp = false) {\n  return skipDebugInstructionsForward(std::next(It), End, SkipPseudoOp);\n}\n\n/// Decrement \\p It, then continue decrementing it while it points to a debug\n/// instruction. A replacement for std::prev.\ntemplate <typename IterT>\ninline IterT prev_nodbg(IterT It, IterT Begin, bool SkipPseudoOp = false) {\n  return skipDebugInstructionsBackward(std::prev(It), Begin, SkipPseudoOp);\n}\n\n/// Construct a range iterator which begins at \\p It and moves forwards until\n/// \\p End is reached, skipping any debug instructions.\ntemplate <typename IterT>\ninline auto instructionsWithoutDebug(IterT It, IterT End,\n                                     bool SkipPseudoOp = false) {\n  return make_filter_range(make_range(It, End), [=](const MachineInstr &MI) {\n    return !MI.isDebugInstr() && !(SkipPseudoOp && MI.isPseudoProbe());\n  });\n}\n\n} // end namespace llvm\n\n#endif // LLVM_CODEGEN_MACHINEBASICBLOCK_H\n"}, "26": {"id": 26, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h", "content": "//===- llvm/CodeGen/MachineFunction.h ---------------------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// Collect native machine code for a function.  This class contains a list of\n// MachineBasicBlock instances that make up the current compiled function.\n//\n// This class also contains pointers to various classes which hold\n// target-specific information about the generated code.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_CODEGEN_MACHINEFUNCTION_H\n#define LLVM_CODEGEN_MACHINEFUNCTION_H\n\n#include \"llvm/ADT/ArrayRef.h\"\n#include \"llvm/ADT/BitVector.h\"\n#include \"llvm/ADT/DenseMap.h\"\n#include \"llvm/ADT/GraphTraits.h\"\n#include \"llvm/ADT/SmallVector.h\"\n#include \"llvm/ADT/ilist.h\"\n#include \"llvm/ADT/iterator.h\"\n#include \"llvm/Analysis/EHPersonalities.h\"\n#include \"llvm/CodeGen/MachineBasicBlock.h\"\n#include \"llvm/CodeGen/MachineInstr.h\"\n#include \"llvm/CodeGen/MachineMemOperand.h\"\n#include \"llvm/Support/Allocator.h\"\n#include \"llvm/Support/ArrayRecycler.h\"\n#include \"llvm/Support/AtomicOrdering.h\"\n#include \"llvm/Support/Compiler.h\"\n#include \"llvm/Support/Recycler.h\"\n#include \"llvm/Target/TargetOptions.h\"\n#include <cassert>\n#include <cstdint>\n#include <memory>\n#include <utility>\n#include <vector>\n\nnamespace llvm {\n\nclass BasicBlock;\nclass BlockAddress;\nclass DataLayout;\nclass DebugLoc;\nstruct DenormalMode;\nclass DIExpression;\nclass DILocalVariable;\nclass DILocation;\nclass Function;\nclass GISelChangeObserver;\nclass GlobalValue;\nclass LLVMTargetMachine;\nclass MachineConstantPool;\nclass MachineFrameInfo;\nclass MachineFunction;\nclass MachineJumpTableInfo;\nclass MachineModuleInfo;\nclass MachineRegisterInfo;\nclass MCContext;\nclass MCInstrDesc;\nclass MCSymbol;\nclass MCSection;\nclass Pass;\nclass PseudoSourceValueManager;\nclass raw_ostream;\nclass SlotIndexes;\nclass StringRef;\nclass TargetRegisterClass;\nclass TargetSubtargetInfo;\nstruct WasmEHFuncInfo;\nstruct WinEHFuncInfo;\n\ntemplate <> struct ilist_alloc_traits<MachineBasicBlock> {\n  void deleteNode(MachineBasicBlock *MBB);\n};\n\ntemplate <> struct ilist_callback_traits<MachineBasicBlock> {\n  void addNodeToList(MachineBasicBlock* N);\n  void removeNodeFromList(MachineBasicBlock* N);\n\n  template <class Iterator>\n  void transferNodesFromList(ilist_callback_traits &OldList, Iterator, Iterator) {\n    assert(this == &OldList && \"never transfer MBBs between functions\");\n  }\n};\n\n/// MachineFunctionInfo - This class can be derived from and used by targets to\n/// hold private target-specific information for each MachineFunction.  Objects\n/// of type are accessed/created with MF::getInfo and destroyed when the\n/// MachineFunction is destroyed.\nstruct MachineFunctionInfo {\n  virtual ~MachineFunctionInfo();\n\n  /// Factory function: default behavior is to call new using the\n  /// supplied allocator.\n  ///\n  /// This function can be overridden in a derive class.\n  template<typename Ty>\n  static Ty *create(BumpPtrAllocator &Allocator, MachineFunction &MF) {\n    return new (Allocator.Allocate<Ty>()) Ty(MF);\n  }\n};\n\n/// Properties which a MachineFunction may have at a given point in time.\n/// Each of these has checking code in the MachineVerifier, and passes can\n/// require that a property be set.\nclass MachineFunctionProperties {\n  // Possible TODO: Allow targets to extend this (perhaps by allowing the\n  // constructor to specify the size of the bit vector)\n  // Possible TODO: Allow requiring the negative (e.g. VRegsAllocated could be\n  // stated as the negative of \"has vregs\"\n\npublic:\n  // The properties are stated in \"positive\" form; i.e. a pass could require\n  // that the property hold, but not that it does not hold.\n\n  // Property descriptions:\n  // IsSSA: True when the machine function is in SSA form and virtual registers\n  //  have a single def.\n  // NoPHIs: The machine function does not contain any PHI instruction.\n  // TracksLiveness: True when tracking register liveness accurately.\n  //  While this property is set, register liveness information in basic block\n  //  live-in lists and machine instruction operands (e.g. kill flags, implicit\n  //  defs) is accurate. This means it can be used to change the code in ways\n  //  that affect the values in registers, for example by the register\n  //  scavenger.\n  //  When this property is clear, liveness is no longer reliable.\n  // NoVRegs: The machine function does not use any virtual registers.\n  // Legalized: In GlobalISel: the MachineLegalizer ran and all pre-isel generic\n  //  instructions have been legalized; i.e., all instructions are now one of:\n  //   - generic and always legal (e.g., COPY)\n  //   - target-specific\n  //   - legal pre-isel generic instructions.\n  // RegBankSelected: In GlobalISel: the RegBankSelect pass ran and all generic\n  //  virtual registers have been assigned to a register bank.\n  // Selected: In GlobalISel: the InstructionSelect pass ran and all pre-isel\n  //  generic instructions have been eliminated; i.e., all instructions are now\n  //  target-specific or non-pre-isel generic instructions (e.g., COPY).\n  //  Since only pre-isel generic instructions can have generic virtual register\n  //  operands, this also means that all generic virtual registers have been\n  //  constrained to virtual registers (assigned to register classes) and that\n  //  all sizes attached to them have been eliminated.\n  // TiedOpsRewritten: The twoaddressinstruction pass will set this flag, it\n  //  means that tied-def have been rewritten to meet the RegConstraint.\n  enum class Property : unsigned {\n    IsSSA,\n    NoPHIs,\n    TracksLiveness,\n    NoVRegs,\n    FailedISel,\n    Legalized,\n    RegBankSelected,\n    Selected,\n    TiedOpsRewritten,\n    LastProperty = TiedOpsRewritten,\n  };\n\n  bool hasProperty(Property P) const {\n    return Properties[static_cast<unsigned>(P)];\n  }\n\n  MachineFunctionProperties &set(Property P) {\n    Properties.set(static_cast<unsigned>(P));\n    return *this;\n  }\n\n  MachineFunctionProperties &reset(Property P) {\n    Properties.reset(static_cast<unsigned>(P));\n    return *this;\n  }\n\n  /// Reset all the properties.\n  MachineFunctionProperties &reset() {\n    Properties.reset();\n    return *this;\n  }\n\n  MachineFunctionProperties &set(const MachineFunctionProperties &MFP) {\n    Properties |= MFP.Properties;\n    return *this;\n  }\n\n  MachineFunctionProperties &reset(const MachineFunctionProperties &MFP) {\n    Properties.reset(MFP.Properties);\n    return *this;\n  }\n\n  // Returns true if all properties set in V (i.e. required by a pass) are set\n  // in this.\n  bool verifyRequiredProperties(const MachineFunctionProperties &V) const {\n    return !V.Properties.test(Properties);\n  }\n\n  /// Print the MachineFunctionProperties in human-readable form.\n  void print(raw_ostream &OS) const;\n\nprivate:\n  BitVector Properties =\n      BitVector(static_cast<unsigned>(Property::LastProperty)+1);\n};\n\nstruct SEHHandler {\n  /// Filter or finally function. Null indicates a catch-all.\n  const Function *FilterOrFinally;\n\n  /// Address of block to recover at. Null for a finally handler.\n  const BlockAddress *RecoverBA;\n};\n\n/// This structure is used to retain landing pad info for the current function.\nstruct LandingPadInfo {\n  MachineBasicBlock *LandingPadBlock;      // Landing pad block.\n  SmallVector<MCSymbol *, 1> BeginLabels;  // Labels prior to invoke.\n  SmallVector<MCSymbol *, 1> EndLabels;    // Labels after invoke.\n  SmallVector<SEHHandler, 1> SEHHandlers;  // SEH handlers active at this lpad.\n  MCSymbol *LandingPadLabel = nullptr;     // Label at beginning of landing pad.\n  std::vector<int> TypeIds;                // List of type ids (filters negative).\n\n  explicit LandingPadInfo(MachineBasicBlock *MBB)\n      : LandingPadBlock(MBB) {}\n};\n\nclass MachineFunction {\n  Function &F;\n  const LLVMTargetMachine &Target;\n  const TargetSubtargetInfo *STI;\n  MCContext &Ctx;\n  MachineModuleInfo &MMI;\n\n  // RegInfo - Information about each register in use in the function.\n  MachineRegisterInfo *RegInfo;\n\n  // Used to keep track of target-specific per-machine function information for\n  // the target implementation.\n  MachineFunctionInfo *MFInfo;\n\n  // Keep track of objects allocated on the stack.\n  MachineFrameInfo *FrameInfo;\n\n  // Keep track of constants which are spilled to memory\n  MachineConstantPool *ConstantPool;\n\n  // Keep track of jump tables for switch instructions\n  MachineJumpTableInfo *JumpTableInfo;\n\n  // Keep track of the function section.\n  MCSection *Section = nullptr;\n\n  // Keeps track of Wasm exception handling related data. This will be null for\n  // functions that aren't using a wasm EH personality.\n  WasmEHFuncInfo *WasmEHInfo = nullptr;\n\n  // Keeps track of Windows exception handling related data. This will be null\n  // for functions that aren't using a funclet-based EH personality.\n  WinEHFuncInfo *WinEHInfo = nullptr;\n\n  // Function-level unique numbering for MachineBasicBlocks.  When a\n  // MachineBasicBlock is inserted into a MachineFunction is it automatically\n  // numbered and this vector keeps track of the mapping from ID's to MBB's.\n  std::vector<MachineBasicBlock*> MBBNumbering;\n\n  // Unary encoding of basic block symbols is used to reduce size of \".strtab\".\n  // Basic block number 'i' gets a prefix of length 'i'.  The ith character also\n  // denotes the type of basic block number 'i'.  Return blocks are marked with\n  // 'r', landing pads with 'l' and regular blocks with 'a'.\n  std::vector<char> BBSectionsSymbolPrefix;\n\n  // Pool-allocate MachineFunction-lifetime and IR objects.\n  BumpPtrAllocator Allocator;\n\n  // Allocation management for instructions in function.\n  Recycler<MachineInstr> InstructionRecycler;\n\n  // Allocation management for operand arrays on instructions.\n  ArrayRecycler<MachineOperand> OperandRecycler;\n\n  // Allocation management for basic blocks in function.\n  Recycler<MachineBasicBlock> BasicBlockRecycler;\n\n  // List of machine basic blocks in function\n  using BasicBlockListType = ilist<MachineBasicBlock>;\n  BasicBlockListType BasicBlocks;\n\n  /// FunctionNumber - This provides a unique ID for each function emitted in\n  /// this translation unit.\n  ///\n  unsigned FunctionNumber;\n\n  /// Alignment - The alignment of the function.\n  Align Alignment;\n\n  /// ExposesReturnsTwice - True if the function calls setjmp or related\n  /// functions with attribute \"returns twice\", but doesn't have\n  /// the attribute itself.\n  /// This is used to limit optimizations which cannot reason\n  /// about the control flow of such functions.\n  bool ExposesReturnsTwice = false;\n\n  /// True if the function includes any inline assembly.\n  bool HasInlineAsm = false;\n\n  /// True if any WinCFI instruction have been emitted in this function.\n  bool HasWinCFI = false;\n\n  /// Current high-level properties of the IR of the function (e.g. is in SSA\n  /// form or whether registers have been allocated)\n  MachineFunctionProperties Properties;\n\n  // Allocation management for pseudo source values.\n  std::unique_ptr<PseudoSourceValueManager> PSVManager;\n\n  /// List of moves done by a function's prolog.  Used to construct frame maps\n  /// by debug and exception handling consumers.\n  std::vector<MCCFIInstruction> FrameInstructions;\n\n  /// List of basic blocks immediately following calls to _setjmp. Used to\n  /// construct a table of valid longjmp targets for Windows Control Flow Guard.\n  std::vector<MCSymbol *> LongjmpTargets;\n\n  /// List of basic blocks that are the target of catchrets. Used to construct\n  /// a table of valid targets for Windows EHCont Guard.\n  std::vector<MCSymbol *> CatchretTargets;\n\n  /// \\name Exception Handling\n  /// \\{\n\n  /// List of LandingPadInfo describing the landing pad information.\n  std::vector<LandingPadInfo> LandingPads;\n\n  /// Map a landing pad's EH symbol to the call site indexes.\n  DenseMap<MCSymbol*, SmallVector<unsigned, 4>> LPadToCallSiteMap;\n\n  /// Map a landing pad to its index.\n  DenseMap<const MachineBasicBlock *, unsigned> WasmLPadToIndexMap;\n\n  /// Map of invoke call site index values to associated begin EH_LABEL.\n  DenseMap<MCSymbol*, unsigned> CallSiteMap;\n\n  /// CodeView label annotations.\n  std::vector<std::pair<MCSymbol *, MDNode *>> CodeViewAnnotations;\n\n  bool CallsEHReturn = false;\n  bool CallsUnwindInit = false;\n  bool HasEHCatchret = false;\n  bool HasEHScopes = false;\n  bool HasEHFunclets = false;\n\n  /// Section Type for basic blocks, only relevant with basic block sections.\n  BasicBlockSection BBSectionsType = BasicBlockSection::None;\n\n  /// List of C++ TypeInfo used.\n  std::vector<const GlobalValue *> TypeInfos;\n\n  /// List of typeids encoding filters used.\n  std::vector<unsigned> FilterIds;\n\n  /// List of the indices in FilterIds corresponding to filter terminators.\n  std::vector<unsigned> FilterEnds;\n\n  EHPersonality PersonalityTypeCache = EHPersonality::Unknown;\n\n  /// \\}\n\n  /// Clear all the members of this MachineFunction, but the ones used\n  /// to initialize again the MachineFunction.\n  /// More specifically, this deallocates all the dynamically allocated\n  /// objects and get rid of all the XXXInfo data structure, but keep\n  /// unchanged the references to Fn, Target, MMI, and FunctionNumber.\n  void clear();\n  /// Allocate and initialize the different members.\n  /// In particular, the XXXInfo data structure.\n  /// \\pre Fn, Target, MMI, and FunctionNumber are properly set.\n  void init();\n\npublic:\n  struct VariableDbgInfo {\n    const DILocalVariable *Var;\n    const DIExpression *Expr;\n    // The Slot can be negative for fixed stack objects.\n    int Slot;\n    const DILocation *Loc;\n\n    VariableDbgInfo(const DILocalVariable *Var, const DIExpression *Expr,\n                    int Slot, const DILocation *Loc)\n        : Var(Var), Expr(Expr), Slot(Slot), Loc(Loc) {}\n  };\n\n  class Delegate {\n    virtual void anchor();\n\n  public:\n    virtual ~Delegate() = default;\n    /// Callback after an insertion. This should not modify the MI directly.\n    virtual void MF_HandleInsertion(MachineInstr &MI) = 0;\n    /// Callback before a removal. This should not modify the MI directly.\n    virtual void MF_HandleRemoval(MachineInstr &MI) = 0;\n  };\n\n  /// Structure used to represent pair of argument number after call lowering\n  /// and register used to transfer that argument.\n  /// For now we support only cases when argument is transferred through one\n  /// register.\n  struct ArgRegPair {\n    Register Reg;\n    uint16_t ArgNo;\n    ArgRegPair(Register R, unsigned Arg) : Reg(R), ArgNo(Arg) {\n      assert(Arg < (1 << 16) && \"Arg out of range\");\n    }\n  };\n  /// Vector of call argument and its forwarding register.\n  using CallSiteInfo = SmallVector<ArgRegPair, 1>;\n  using CallSiteInfoImpl = SmallVectorImpl<ArgRegPair>;\n\nprivate:\n  Delegate *TheDelegate = nullptr;\n  GISelChangeObserver *Observer = nullptr;\n\n  using CallSiteInfoMap = DenseMap<const MachineInstr *, CallSiteInfo>;\n  /// Map a call instruction to call site arguments forwarding info.\n  CallSiteInfoMap CallSitesInfo;\n\n  /// A helper function that returns call site info for a give call\n  /// instruction if debug entry value support is enabled.\n  CallSiteInfoMap::iterator getCallSiteInfo(const MachineInstr *MI);\n\n  // Callbacks for insertion and removal.\n  void handleInsertion(MachineInstr &MI);\n  void handleRemoval(MachineInstr &MI);\n  friend struct ilist_traits<MachineInstr>;\n\npublic:\n  using VariableDbgInfoMapTy = SmallVector<VariableDbgInfo, 4>;\n  VariableDbgInfoMapTy VariableDbgInfos;\n\n  /// A count of how many instructions in the function have had numbers\n  /// assigned to them. Used for debug value tracking, to determine the\n  /// next instruction number.\n  unsigned DebugInstrNumberingCount = 0;\n\n  /// Set value of DebugInstrNumberingCount field. Avoid using this unless\n  /// you're deserializing this data.\n  void setDebugInstrNumberingCount(unsigned Num);\n\n  /// Pair of instruction number and operand number.\n  using DebugInstrOperandPair = std::pair<unsigned, unsigned>;\n\n  /// Substitution map: from one <inst,operand> pair to another. Used to\n  /// record changes in where a value is defined, so that debug variable\n  /// locations can find it later.\n  std::map<DebugInstrOperandPair, DebugInstrOperandPair>\n      DebugValueSubstitutions;\n\n  /// Create a substitution between one <instr,operand> value to a different,\n  /// new value.\n  void makeDebugValueSubstitution(DebugInstrOperandPair, DebugInstrOperandPair);\n\n  /// Create substitutions for any tracked values in \\p Old, to point at\n  /// \\p New. Needed when we re-create an instruction during optimization,\n  /// which has the same signature (i.e., def operands in the same place) but\n  /// a modified instruction type, flags, or otherwise. An example: X86 moves\n  /// are sometimes transformed into equivalent LEAs.\n  /// If the two instructions are not the same opcode, limit which operands to\n  /// examine for substitutions to the first N operands by setting\n  /// \\p MaxOperand.\n  void substituteDebugValuesForInst(const MachineInstr &Old, MachineInstr &New,\n                                    unsigned MaxOperand = UINT_MAX);\n\n  MachineFunction(Function &F, const LLVMTargetMachine &Target,\n                  const TargetSubtargetInfo &STI, unsigned FunctionNum,\n                  MachineModuleInfo &MMI);\n  MachineFunction(const MachineFunction &) = delete;\n  MachineFunction &operator=(const MachineFunction &) = delete;\n  ~MachineFunction();\n\n  /// Reset the instance as if it was just created.\n  void reset() {\n    clear();\n    init();\n  }\n\n  /// Reset the currently registered delegate - otherwise assert.\n  void resetDelegate(Delegate *delegate) {\n    assert(TheDelegate == delegate &&\n           \"Only the current delegate can perform reset!\");\n    TheDelegate = nullptr;\n  }\n\n  /// Set the delegate. resetDelegate must be called before attempting\n  /// to set.\n  void setDelegate(Delegate *delegate) {\n    assert(delegate && !TheDelegate &&\n           \"Attempted to set delegate to null, or to change it without \"\n           \"first resetting it!\");\n\n    TheDelegate = delegate;\n  }\n\n  void setObserver(GISelChangeObserver *O) { Observer = O; }\n\n  GISelChangeObserver *getObserver() const { return Observer; }\n\n  MachineModuleInfo &getMMI() const { return MMI; }\n  MCContext &getContext() const { return Ctx; }\n\n  /// Returns the Section this function belongs to.\n  MCSection *getSection() const { return Section; }\n\n  /// Indicates the Section this function belongs to.\n  void setSection(MCSection *S) { Section = S; }\n\n  PseudoSourceValueManager &getPSVManager() const { return *PSVManager; }\n\n  /// Return the DataLayout attached to the Module associated to this MF.\n  const DataLayout &getDataLayout() const;\n\n  /// Return the LLVM function that this machine code represents\n  Function &getFunction() { return F; }\n\n  /// Return the LLVM function that this machine code represents\n  const Function &getFunction() const { return F; }\n\n  /// getName - Return the name of the corresponding LLVM function.\n  StringRef getName() const;\n\n  /// getFunctionNumber - Return a unique ID for the current function.\n  unsigned getFunctionNumber() const { return FunctionNumber; }\n\n  /// Returns true if this function has basic block sections enabled.\n  bool hasBBSections() const {\n    return (BBSectionsType == BasicBlockSection::All ||\n            BBSectionsType == BasicBlockSection::List ||\n            BBSectionsType == BasicBlockSection::Preset);\n  }\n\n  /// Returns true if basic block labels are to be generated for this function.\n  bool hasBBLabels() const {\n    return BBSectionsType == BasicBlockSection::Labels;\n  }\n\n  void setBBSectionsType(BasicBlockSection V) { BBSectionsType = V; }\n\n  /// Assign IsBeginSection IsEndSection fields for basic blocks in this\n  /// function.\n  void assignBeginEndSections();\n\n  /// getTarget - Return the target machine this machine code is compiled with\n  const LLVMTargetMachine &getTarget() const { return Target; }\n\n  /// getSubtarget - Return the subtarget for which this machine code is being\n  /// compiled.\n  const TargetSubtargetInfo &getSubtarget() const { return *STI; }\n\n  /// getSubtarget - This method returns a pointer to the specified type of\n  /// TargetSubtargetInfo.  In debug builds, it verifies that the object being\n  /// returned is of the correct type.\n  template<typename STC> const STC &getSubtarget() const {\n    return *static_cast<const STC *>(STI);\n  }\n\n  /// getRegInfo - Return information about the registers currently in use.\n  MachineRegisterInfo &getRegInfo() { return *RegInfo; }\n  const MachineRegisterInfo &getRegInfo() const { return *RegInfo; }\n\n  /// getFrameInfo - Return the frame info object for the current function.\n  /// This object contains information about objects allocated on the stack\n  /// frame of the current function in an abstract way.\n  MachineFrameInfo &getFrameInfo() { return *FrameInfo; }\n  const MachineFrameInfo &getFrameInfo() const { return *FrameInfo; }\n\n  /// getJumpTableInfo - Return the jump table info object for the current\n  /// function.  This object contains information about jump tables in the\n  /// current function.  If the current function has no jump tables, this will\n  /// return null.\n  const MachineJumpTableInfo *getJumpTableInfo() const { return JumpTableInfo; }\n  MachineJumpTableInfo *getJumpTableInfo() { return JumpTableInfo; }\n\n  /// getOrCreateJumpTableInfo - Get the JumpTableInfo for this function, if it\n  /// does already exist, allocate one.\n  MachineJumpTableInfo *getOrCreateJumpTableInfo(unsigned JTEntryKind);\n\n  /// getConstantPool - Return the constant pool object for the current\n  /// function.\n  MachineConstantPool *getConstantPool() { return ConstantPool; }\n  const MachineConstantPool *getConstantPool() const { return ConstantPool; }\n\n  /// getWasmEHFuncInfo - Return information about how the current function uses\n  /// Wasm exception handling. Returns null for functions that don't use wasm\n  /// exception handling.\n  const WasmEHFuncInfo *getWasmEHFuncInfo() const { return WasmEHInfo; }\n  WasmEHFuncInfo *getWasmEHFuncInfo() { return WasmEHInfo; }\n\n  /// getWinEHFuncInfo - Return information about how the current function uses\n  /// Windows exception handling. Returns null for functions that don't use\n  /// funclets for exception handling.\n  const WinEHFuncInfo *getWinEHFuncInfo() const { return WinEHInfo; }\n  WinEHFuncInfo *getWinEHFuncInfo() { return WinEHInfo; }\n\n  /// getAlignment - Return the alignment of the function.\n  Align getAlignment() const { return Alignment; }\n\n  /// setAlignment - Set the alignment of the function.\n  void setAlignment(Align A) { Alignment = A; }\n\n  /// ensureAlignment - Make sure the function is at least A bytes aligned.\n  void ensureAlignment(Align A) {\n    if (Alignment < A)\n      Alignment = A;\n  }\n\n  /// exposesReturnsTwice - Returns true if the function calls setjmp or\n  /// any other similar functions with attribute \"returns twice\" without\n  /// having the attribute itself.\n  bool exposesReturnsTwice() const {\n    return ExposesReturnsTwice;\n  }\n\n  /// setCallsSetJmp - Set a flag that indicates if there's a call to\n  /// a \"returns twice\" function.\n  void setExposesReturnsTwice(bool B) {\n    ExposesReturnsTwice = B;\n  }\n\n  /// Returns true if the function contains any inline assembly.\n  bool hasInlineAsm() const {\n    return HasInlineAsm;\n  }\n\n  /// Set a flag that indicates that the function contains inline assembly.\n  void setHasInlineAsm(bool B) {\n    HasInlineAsm = B;\n  }\n\n  bool hasWinCFI() const {\n    return HasWinCFI;\n  }\n  void setHasWinCFI(bool v) { HasWinCFI = v; }\n\n  /// True if this function needs frame moves for debug or exceptions.\n  bool needsFrameMoves() const;\n\n  /// Get the function properties\n  const MachineFunctionProperties &getProperties() const { return Properties; }\n  MachineFunctionProperties &getProperties() { return Properties; }\n\n  /// getInfo - Keep track of various per-function pieces of information for\n  /// backends that would like to do so.\n  ///\n  template<typename Ty>\n  Ty *getInfo() {\n    if (!MFInfo)\n      MFInfo = Ty::template create<Ty>(Allocator, *this);\n    return static_cast<Ty*>(MFInfo);\n  }\n\n  template<typename Ty>\n  const Ty *getInfo() const {\n     return const_cast<MachineFunction*>(this)->getInfo<Ty>();\n  }\n\n  /// Returns the denormal handling type for the default rounding mode of the\n  /// function.\n  DenormalMode getDenormalMode(const fltSemantics &FPType) const;\n\n  /// getBlockNumbered - MachineBasicBlocks are automatically numbered when they\n  /// are inserted into the machine function.  The block number for a machine\n  /// basic block can be found by using the MBB::getNumber method, this method\n  /// provides the inverse mapping.\n  MachineBasicBlock *getBlockNumbered(unsigned N) const {\n    assert(N < MBBNumbering.size() && \"Illegal block number\");\n    assert(MBBNumbering[N] && \"Block was removed from the machine function!\");\n    return MBBNumbering[N];\n  }\n\n  /// Should we be emitting segmented stack stuff for the function\n  bool shouldSplitStack() const;\n\n  /// getNumBlockIDs - Return the number of MBB ID's allocated.\n  unsigned getNumBlockIDs() const { return (unsigned)MBBNumbering.size(); }\n\n  /// RenumberBlocks - This discards all of the MachineBasicBlock numbers and\n  /// recomputes them.  This guarantees that the MBB numbers are sequential,\n  /// dense, and match the ordering of the blocks within the function.  If a\n  /// specific MachineBasicBlock is specified, only that block and those after\n  /// it are renumbered.\n  void RenumberBlocks(MachineBasicBlock *MBBFrom = nullptr);\n\n  /// print - Print out the MachineFunction in a format suitable for debugging\n  /// to the specified stream.\n  void print(raw_ostream &OS, const SlotIndexes* = nullptr) const;\n\n  /// viewCFG - This function is meant for use from the debugger.  You can just\n  /// say 'call F->viewCFG()' and a ghostview window should pop up from the\n  /// program, displaying the CFG of the current function with the code for each\n  /// basic block inside.  This depends on there being a 'dot' and 'gv' program\n  /// in your path.\n  void viewCFG() const;\n\n  /// viewCFGOnly - This function is meant for use from the debugger.  It works\n  /// just like viewCFG, but it does not include the contents of basic blocks\n  /// into the nodes, just the label.  If you are only interested in the CFG\n  /// this can make the graph smaller.\n  ///\n  void viewCFGOnly() const;\n\n  /// dump - Print the current MachineFunction to cerr, useful for debugger use.\n  void dump() const;\n\n  /// Run the current MachineFunction through the machine code verifier, useful\n  /// for debugger use.\n  /// \\returns true if no problems were found.\n  bool verify(Pass *p = nullptr, const char *Banner = nullptr,\n              bool AbortOnError = true) const;\n\n  // Provide accessors for the MachineBasicBlock list...\n  using iterator = BasicBlockListType::iterator;\n  using const_iterator = BasicBlockListType::const_iterator;\n  using const_reverse_iterator = BasicBlockListType::const_reverse_iterator;\n  using reverse_iterator = BasicBlockListType::reverse_iterator;\n\n  /// Support for MachineBasicBlock::getNextNode().\n  static BasicBlockListType MachineFunction::*\n  getSublistAccess(MachineBasicBlock *) {\n    return &MachineFunction::BasicBlocks;\n  }\n\n  /// addLiveIn - Add the specified physical register as a live-in value and\n  /// create a corresponding virtual register for it.\n  Register addLiveIn(MCRegister PReg, const TargetRegisterClass *RC);\n\n  //===--------------------------------------------------------------------===//\n  // BasicBlock accessor functions.\n  //\n  iterator                 begin()       { return BasicBlocks.begin(); }\n  const_iterator           begin() const { return BasicBlocks.begin(); }\n  iterator                 end  ()       { return BasicBlocks.end();   }\n  const_iterator           end  () const { return BasicBlocks.end();   }\n\n  reverse_iterator        rbegin()       { return BasicBlocks.rbegin(); }\n  const_reverse_iterator  rbegin() const { return BasicBlocks.rbegin(); }\n  reverse_iterator        rend  ()       { return BasicBlocks.rend();   }\n  const_reverse_iterator  rend  () const { return BasicBlocks.rend();   }\n\n  unsigned                  size() const { return (unsigned)BasicBlocks.size();}\n  bool                     empty() const { return BasicBlocks.empty(); }\n  const MachineBasicBlock &front() const { return BasicBlocks.front(); }\n        MachineBasicBlock &front()       { return BasicBlocks.front(); }\n  const MachineBasicBlock & back() const { return BasicBlocks.back(); }\n        MachineBasicBlock & back()       { return BasicBlocks.back(); }\n\n  void push_back (MachineBasicBlock *MBB) { BasicBlocks.push_back (MBB); }\n  void push_front(MachineBasicBlock *MBB) { BasicBlocks.push_front(MBB); }\n  void insert(iterator MBBI, MachineBasicBlock *MBB) {\n    BasicBlocks.insert(MBBI, MBB);\n  }\n  void splice(iterator InsertPt, iterator MBBI) {\n    BasicBlocks.splice(InsertPt, BasicBlocks, MBBI);\n  }\n  void splice(iterator InsertPt, MachineBasicBlock *MBB) {\n    BasicBlocks.splice(InsertPt, BasicBlocks, MBB);\n  }\n  void splice(iterator InsertPt, iterator MBBI, iterator MBBE) {\n    BasicBlocks.splice(InsertPt, BasicBlocks, MBBI, MBBE);\n  }\n\n  void remove(iterator MBBI) { BasicBlocks.remove(MBBI); }\n  void remove(MachineBasicBlock *MBBI) { BasicBlocks.remove(MBBI); }\n  void erase(iterator MBBI) { BasicBlocks.erase(MBBI); }\n  void erase(MachineBasicBlock *MBBI) { BasicBlocks.erase(MBBI); }\n\n  template <typename Comp>\n  void sort(Comp comp) {\n    BasicBlocks.sort(comp);\n  }\n\n  /// Return the number of \\p MachineInstrs in this \\p MachineFunction.\n  unsigned getInstructionCount() const {\n    unsigned InstrCount = 0;\n    for (const MachineBasicBlock &MBB : BasicBlocks)\n      InstrCount += MBB.size();\n    return InstrCount;\n  }\n\n  //===--------------------------------------------------------------------===//\n  // Internal functions used to automatically number MachineBasicBlocks\n\n  /// Adds the MBB to the internal numbering. Returns the unique number\n  /// assigned to the MBB.\n  unsigned addToMBBNumbering(MachineBasicBlock *MBB) {\n    MBBNumbering.push_back(MBB);\n    return (unsigned)MBBNumbering.size()-1;\n  }\n\n  /// removeFromMBBNumbering - Remove the specific machine basic block from our\n  /// tracker, this is only really to be used by the MachineBasicBlock\n  /// implementation.\n  void removeFromMBBNumbering(unsigned N) {\n    assert(N < MBBNumbering.size() && \"Illegal basic block #\");\n    MBBNumbering[N] = nullptr;\n  }\n\n  /// CreateMachineInstr - Allocate a new MachineInstr. Use this instead\n  /// of `new MachineInstr'.\n  MachineInstr *CreateMachineInstr(const MCInstrDesc &MCID, const DebugLoc &DL,\n                                   bool NoImplicit = false);\n\n  /// Create a new MachineInstr which is a copy of \\p Orig, identical in all\n  /// ways except the instruction has no parent, prev, or next. Bundling flags\n  /// are reset.\n  ///\n  /// Note: Clones a single instruction, not whole instruction bundles.\n  /// Does not perform target specific adjustments; consider using\n  /// TargetInstrInfo::duplicate() instead.\n  MachineInstr *CloneMachineInstr(const MachineInstr *Orig);\n\n  /// Clones instruction or the whole instruction bundle \\p Orig and insert\n  /// into \\p MBB before \\p InsertBefore.\n  ///\n  /// Note: Does not perform target specific adjustments; consider using\n  /// TargetInstrInfo::duplicate() intead.\n  MachineInstr &CloneMachineInstrBundle(MachineBasicBlock &MBB,\n      MachineBasicBlock::iterator InsertBefore, const MachineInstr &Orig);\n\n  /// DeleteMachineInstr - Delete the given MachineInstr.\n  void DeleteMachineInstr(MachineInstr *MI);\n\n  /// CreateMachineBasicBlock - Allocate a new MachineBasicBlock. Use this\n  /// instead of `new MachineBasicBlock'.\n  MachineBasicBlock *CreateMachineBasicBlock(const BasicBlock *bb = nullptr);\n\n  /// DeleteMachineBasicBlock - Delete the given MachineBasicBlock.\n  void DeleteMachineBasicBlock(MachineBasicBlock *MBB);\n\n  /// getMachineMemOperand - Allocate a new MachineMemOperand.\n  /// MachineMemOperands are owned by the MachineFunction and need not be\n  /// explicitly deallocated.\n  MachineMemOperand *getMachineMemOperand(\n      MachinePointerInfo PtrInfo, MachineMemOperand::Flags f, uint64_t s,\n      Align base_alignment, const AAMDNodes &AAInfo = AAMDNodes(),\n      const MDNode *Ranges = nullptr, SyncScope::ID SSID = SyncScope::System,\n      AtomicOrdering Ordering = AtomicOrdering::NotAtomic,\n      AtomicOrdering FailureOrdering = AtomicOrdering::NotAtomic);\n\n  /// getMachineMemOperand - Allocate a new MachineMemOperand by copying\n  /// an existing one, adjusting by an offset and using the given size.\n  /// MachineMemOperands are owned by the MachineFunction and need not be\n  /// explicitly deallocated.\n  MachineMemOperand *getMachineMemOperand(const MachineMemOperand *MMO,\n                                          int64_t Offset, uint64_t Size);\n\n  /// getMachineMemOperand - Allocate a new MachineMemOperand by copying\n  /// an existing one, replacing only the MachinePointerInfo and size.\n  /// MachineMemOperands are owned by the MachineFunction and need not be\n  /// explicitly deallocated.\n  MachineMemOperand *getMachineMemOperand(const MachineMemOperand *MMO,\n                                          MachinePointerInfo &PtrInfo,\n                                          uint64_t Size);\n\n  /// Allocate a new MachineMemOperand by copying an existing one,\n  /// replacing only AliasAnalysis information. MachineMemOperands are owned\n  /// by the MachineFunction and need not be explicitly deallocated.\n  MachineMemOperand *getMachineMemOperand(const MachineMemOperand *MMO,\n                                          const AAMDNodes &AAInfo);\n\n  /// Allocate a new MachineMemOperand by copying an existing one,\n  /// replacing the flags. MachineMemOperands are owned\n  /// by the MachineFunction and need not be explicitly deallocated.\n  MachineMemOperand *getMachineMemOperand(const MachineMemOperand *MMO,\n                                          MachineMemOperand::Flags Flags);\n\n  using OperandCapacity = ArrayRecycler<MachineOperand>::Capacity;\n\n  /// Allocate an array of MachineOperands. This is only intended for use by\n  /// internal MachineInstr functions.\n  MachineOperand *allocateOperandArray(OperandCapacity Cap) {\n    return OperandRecycler.allocate(Cap, Allocator);\n  }\n\n  /// Dellocate an array of MachineOperands and recycle the memory. This is\n  /// only intended for use by internal MachineInstr functions.\n  /// Cap must be the same capacity that was used to allocate the array.\n  void deallocateOperandArray(OperandCapacity Cap, MachineOperand *Array) {\n    OperandRecycler.deallocate(Cap, Array);\n  }\n\n  /// Allocate and initialize a register mask with @p NumRegister bits.\n  uint32_t *allocateRegMask();\n\n  ArrayRef<int> allocateShuffleMask(ArrayRef<int> Mask);\n\n  /// Allocate and construct an extra info structure for a `MachineInstr`.\n  ///\n  /// This is allocated on the function's allocator and so lives the life of\n  /// the function.\n  MachineInstr::ExtraInfo *createMIExtraInfo(\n      ArrayRef<MachineMemOperand *> MMOs, MCSymbol *PreInstrSymbol = nullptr,\n      MCSymbol *PostInstrSymbol = nullptr, MDNode *HeapAllocMarker = nullptr);\n\n  /// Allocate a string and populate it with the given external symbol name.\n  const char *createExternalSymbolName(StringRef Name);\n\n  //===--------------------------------------------------------------------===//\n  // Label Manipulation.\n\n  /// getJTISymbol - Return the MCSymbol for the specified non-empty jump table.\n  /// If isLinkerPrivate is specified, an 'l' label is returned, otherwise a\n  /// normal 'L' label is returned.\n  MCSymbol *getJTISymbol(unsigned JTI, MCContext &Ctx,\n                         bool isLinkerPrivate = false) const;\n\n  /// getPICBaseSymbol - Return a function-local symbol to represent the PIC\n  /// base.\n  MCSymbol *getPICBaseSymbol() const;\n\n  /// Returns a reference to a list of cfi instructions in the function's\n  /// prologue.  Used to construct frame maps for debug and exception handling\n  /// comsumers.\n  const std::vector<MCCFIInstruction> &getFrameInstructions() const {\n    return FrameInstructions;\n  }\n\n  LLVM_NODISCARD unsigned addFrameInst(const MCCFIInstruction &Inst);\n\n  /// Returns a reference to a list of symbols immediately following calls to\n  /// _setjmp in the function. Used to construct the longjmp target table used\n  /// by Windows Control Flow Guard.\n  const std::vector<MCSymbol *> &getLongjmpTargets() const {\n    return LongjmpTargets;\n  }\n\n  /// Add the specified symbol to the list of valid longjmp targets for Windows\n  /// Control Flow Guard.\n  void addLongjmpTarget(MCSymbol *Target) { LongjmpTargets.push_back(Target); }\n\n  /// Returns a reference to a list of symbols that we have catchrets.\n  /// Used to construct the catchret target table used by Windows EHCont Guard.\n  const std::vector<MCSymbol *> &getCatchretTargets() const {\n    return CatchretTargets;\n  }\n\n  /// Add the specified symbol to the list of valid catchret targets for Windows\n  /// EHCont Guard.\n  void addCatchretTarget(MCSymbol *Target) {\n    CatchretTargets.push_back(Target);\n  }\n\n  /// \\name Exception Handling\n  /// \\{\n\n  bool callsEHReturn() const { return CallsEHReturn; }\n  void setCallsEHReturn(bool b) { CallsEHReturn = b; }\n\n  bool callsUnwindInit() const { return CallsUnwindInit; }\n  void setCallsUnwindInit(bool b) { CallsUnwindInit = b; }\n\n  bool hasEHCatchret() const { return HasEHCatchret; }\n  void setHasEHCatchret(bool V) { HasEHCatchret = V; }\n\n  bool hasEHScopes() const { return HasEHScopes; }\n  void setHasEHScopes(bool V) { HasEHScopes = V; }\n\n  bool hasEHFunclets() const { return HasEHFunclets; }\n  void setHasEHFunclets(bool V) { HasEHFunclets = V; }\n\n  /// Find or create an LandingPadInfo for the specified MachineBasicBlock.\n  LandingPadInfo &getOrCreateLandingPadInfo(MachineBasicBlock *LandingPad);\n\n  /// Remap landing pad labels and remove any deleted landing pads.\n  void tidyLandingPads(DenseMap<MCSymbol *, uintptr_t> *LPMap = nullptr,\n                       bool TidyIfNoBeginLabels = true);\n\n  /// Return a reference to the landing pad info for the current function.\n  const std::vector<LandingPadInfo> &getLandingPads() const {\n    return LandingPads;\n  }\n\n  /// Provide the begin and end labels of an invoke style call and associate it\n  /// with a try landing pad block.\n  void addInvoke(MachineBasicBlock *LandingPad,\n                 MCSymbol *BeginLabel, MCSymbol *EndLabel);\n\n  /// Add a new panding pad, and extract the exception handling information from\n  /// the landingpad instruction. Returns the label ID for the landing pad\n  /// entry.\n  MCSymbol *addLandingPad(MachineBasicBlock *LandingPad);\n\n  /// Provide the catch typeinfo for a landing pad.\n  void addCatchTypeInfo(MachineBasicBlock *LandingPad,\n                        ArrayRef<const GlobalValue *> TyInfo);\n\n  /// Provide the filter typeinfo for a landing pad.\n  void addFilterTypeInfo(MachineBasicBlock *LandingPad,\n                         ArrayRef<const GlobalValue *> TyInfo);\n\n  /// Add a cleanup action for a landing pad.\n  void addCleanup(MachineBasicBlock *LandingPad);\n\n  void addSEHCatchHandler(MachineBasicBlock *LandingPad, const Function *Filter,\n                          const BlockAddress *RecoverBA);\n\n  void addSEHCleanupHandler(MachineBasicBlock *LandingPad,\n                            const Function *Cleanup);\n\n  /// Return the type id for the specified typeinfo.  This is function wide.\n  unsigned getTypeIDFor(const GlobalValue *TI);\n\n  /// Return the id of the filter encoded by TyIds.  This is function wide.\n  int getFilterIDFor(std::vector<unsigned> &TyIds);\n\n  /// Map the landing pad's EH symbol to the call site indexes.\n  void setCallSiteLandingPad(MCSymbol *Sym, ArrayRef<unsigned> Sites);\n\n  /// Map the landing pad to its index. Used for Wasm exception handling.\n  void setWasmLandingPadIndex(const MachineBasicBlock *LPad, unsigned Index) {\n    WasmLPadToIndexMap[LPad] = Index;\n  }\n\n  /// Returns true if the landing pad has an associate index in wasm EH.\n  bool hasWasmLandingPadIndex(const MachineBasicBlock *LPad) const {\n    return WasmLPadToIndexMap.count(LPad);\n  }\n\n  /// Get the index in wasm EH for a given landing pad.\n  unsigned getWasmLandingPadIndex(const MachineBasicBlock *LPad) const {\n    assert(hasWasmLandingPadIndex(LPad));\n    return WasmLPadToIndexMap.lookup(LPad);\n  }\n\n  /// Get the call site indexes for a landing pad EH symbol.\n  SmallVectorImpl<unsigned> &getCallSiteLandingPad(MCSymbol *Sym) {\n    assert(hasCallSiteLandingPad(Sym) &&\n           \"missing call site number for landing pad!\");\n    return LPadToCallSiteMap[Sym];\n  }\n\n  /// Return true if the landing pad Eh symbol has an associated call site.\n  bool hasCallSiteLandingPad(MCSymbol *Sym) {\n    return !LPadToCallSiteMap[Sym].empty();\n  }\n\n  /// Map the begin label for a call site.\n  void setCallSiteBeginLabel(MCSymbol *BeginLabel, unsigned Site) {\n    CallSiteMap[BeginLabel] = Site;\n  }\n\n  /// Get the call site number for a begin label.\n  unsigned getCallSiteBeginLabel(MCSymbol *BeginLabel) const {\n    assert(hasCallSiteBeginLabel(BeginLabel) &&\n           \"Missing call site number for EH_LABEL!\");\n    return CallSiteMap.lookup(BeginLabel);\n  }\n\n  /// Return true if the begin label has a call site number associated with it.\n  bool hasCallSiteBeginLabel(MCSymbol *BeginLabel) const {\n    return CallSiteMap.count(BeginLabel);\n  }\n\n  /// Record annotations associated with a particular label.\n  void addCodeViewAnnotation(MCSymbol *Label, MDNode *MD) {\n    CodeViewAnnotations.push_back({Label, MD});\n  }\n\n  ArrayRef<std::pair<MCSymbol *, MDNode *>> getCodeViewAnnotations() const {\n    return CodeViewAnnotations;\n  }\n\n  /// Return a reference to the C++ typeinfo for the current function.\n  const std::vector<const GlobalValue *> &getTypeInfos() const {\n    return TypeInfos;\n  }\n\n  /// Return a reference to the typeids encoding filters used in the current\n  /// function.\n  const std::vector<unsigned> &getFilterIds() const {\n    return FilterIds;\n  }\n\n  /// \\}\n\n  /// Collect information used to emit debugging information of a variable.\n  void setVariableDbgInfo(const DILocalVariable *Var, const DIExpression *Expr,\n                          int Slot, const DILocation *Loc) {\n    VariableDbgInfos.emplace_back(Var, Expr, Slot, Loc);\n  }\n\n  VariableDbgInfoMapTy &getVariableDbgInfo() { return VariableDbgInfos; }\n  const VariableDbgInfoMapTy &getVariableDbgInfo() const {\n    return VariableDbgInfos;\n  }\n\n  /// Start tracking the arguments passed to the call \\p CallI.\n  void addCallArgsForwardingRegs(const MachineInstr *CallI,\n                                 CallSiteInfoImpl &&CallInfo) {\n    assert(CallI->isCandidateForCallSiteEntry());\n    bool Inserted =\n        CallSitesInfo.try_emplace(CallI, std::move(CallInfo)).second;\n    (void)Inserted;\n    assert(Inserted && \"Call site info not unique\");\n  }\n\n  const CallSiteInfoMap &getCallSitesInfo() const {\n    return CallSitesInfo;\n  }\n\n  /// Following functions update call site info. They should be called before\n  /// removing, replacing or copying call instruction.\n\n  /// Erase the call site info for \\p MI. It is used to remove a call\n  /// instruction from the instruction stream.\n  void eraseCallSiteInfo(const MachineInstr *MI);\n  /// Copy the call site info from \\p Old to \\ New. Its usage is when we are\n  /// making a copy of the instruction that will be inserted at different point\n  /// of the instruction stream.\n  void copyCallSiteInfo(const MachineInstr *Old,\n                        const MachineInstr *New);\n\n  const std::vector<char> &getBBSectionsSymbolPrefix() const {\n    return BBSectionsSymbolPrefix;\n  }\n\n  /// Move the call site info from \\p Old to \\New call site info. This function\n  /// is used when we are replacing one call instruction with another one to\n  /// the same callee.\n  void moveCallSiteInfo(const MachineInstr *Old,\n                        const MachineInstr *New);\n\n  unsigned getNewDebugInstrNum() {\n    return ++DebugInstrNumberingCount;\n  }\n};\n\n//===--------------------------------------------------------------------===//\n// GraphTraits specializations for function basic block graphs (CFGs)\n//===--------------------------------------------------------------------===//\n\n// Provide specializations of GraphTraits to be able to treat a\n// machine function as a graph of machine basic blocks... these are\n// the same as the machine basic block iterators, except that the root\n// node is implicitly the first node of the function.\n//\ntemplate <> struct GraphTraits<MachineFunction*> :\n  public GraphTraits<MachineBasicBlock*> {\n  static NodeRef getEntryNode(MachineFunction *F) { return &F->front(); }\n\n  // nodes_iterator/begin/end - Allow iteration over all nodes in the graph\n  using nodes_iterator = pointer_iterator<MachineFunction::iterator>;\n\n  static nodes_iterator nodes_begin(MachineFunction *F) {\n    return nodes_iterator(F->begin());\n  }\n\n  static nodes_iterator nodes_end(MachineFunction *F) {\n    return nodes_iterator(F->end());\n  }\n\n  static unsigned       size       (MachineFunction *F) { return F->size(); }\n};\ntemplate <> struct GraphTraits<const MachineFunction*> :\n  public GraphTraits<const MachineBasicBlock*> {\n  static NodeRef getEntryNode(const MachineFunction *F) { return &F->front(); }\n\n  // nodes_iterator/begin/end - Allow iteration over all nodes in the graph\n  using nodes_iterator = pointer_iterator<MachineFunction::const_iterator>;\n\n  static nodes_iterator nodes_begin(const MachineFunction *F) {\n    return nodes_iterator(F->begin());\n  }\n\n  static nodes_iterator nodes_end  (const MachineFunction *F) {\n    return nodes_iterator(F->end());\n  }\n\n  static unsigned       size       (const MachineFunction *F)  {\n    return F->size();\n  }\n};\n\n// Provide specializations of GraphTraits to be able to treat a function as a\n// graph of basic blocks... and to walk it in inverse order.  Inverse order for\n// a function is considered to be when traversing the predecessor edges of a BB\n// instead of the successor edges.\n//\ntemplate <> struct GraphTraits<Inverse<MachineFunction*>> :\n  public GraphTraits<Inverse<MachineBasicBlock*>> {\n  static NodeRef getEntryNode(Inverse<MachineFunction *> G) {\n    return &G.Graph->front();\n  }\n};\ntemplate <> struct GraphTraits<Inverse<const MachineFunction*>> :\n  public GraphTraits<Inverse<const MachineBasicBlock*>> {\n  static NodeRef getEntryNode(Inverse<const MachineFunction *> G) {\n    return &G.Graph->front();\n  }\n};\n\nclass MachineFunctionAnalysisManager;\nvoid verifyMachineFunction(MachineFunctionAnalysisManager *,\n                           const std::string &Banner,\n                           const MachineFunction &MF);\n\n} // end namespace llvm\n\n#endif // LLVM_CODEGEN_MACHINEFUNCTION_H\n"}, "27": {"id": 27, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/CodeGen/MachineFunctionPass.h", "content": "//===-- MachineFunctionPass.h - Pass for MachineFunctions --------*-C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// This file defines the MachineFunctionPass class.  MachineFunctionPass's are\n// just FunctionPass's, except they operate on machine code as part of a code\n// generator.  Because they operate on machine code, not the LLVM\n// representation, MachineFunctionPass's are not allowed to modify the LLVM\n// representation.  Due to this limitation, the MachineFunctionPass class takes\n// care of declaring that no LLVM passes are invalidated.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_CODEGEN_MACHINEFUNCTIONPASS_H\n#define LLVM_CODEGEN_MACHINEFUNCTIONPASS_H\n\n#include \"llvm/CodeGen/MachineFunction.h\"\n#include \"llvm/Pass.h\"\n\nnamespace llvm {\n\n/// MachineFunctionPass - This class adapts the FunctionPass interface to\n/// allow convenient creation of passes that operate on the MachineFunction\n/// representation. Instead of overriding runOnFunction, subclasses\n/// override runOnMachineFunction.\nclass MachineFunctionPass : public FunctionPass {\npublic:\n  bool doInitialization(Module&) override {\n    // Cache the properties info at module-init time so we don't have to\n    // construct them for every function.\n    RequiredProperties = getRequiredProperties();\n    SetProperties = getSetProperties();\n    ClearedProperties = getClearedProperties();\n    return false;\n  }\nprotected:\n  explicit MachineFunctionPass(char &ID) : FunctionPass(ID) {}\n\n  /// runOnMachineFunction - This method must be overloaded to perform the\n  /// desired machine code transformation or analysis.\n  ///\n  virtual bool runOnMachineFunction(MachineFunction &MF) = 0;\n\n  /// getAnalysisUsage - Subclasses that override getAnalysisUsage\n  /// must call this.\n  ///\n  /// For MachineFunctionPasses, calling AU.preservesCFG() indicates that\n  /// the pass does not modify the MachineBasicBlock CFG.\n  ///\n  void getAnalysisUsage(AnalysisUsage &AU) const override;\n\n  virtual MachineFunctionProperties getRequiredProperties() const {\n    return MachineFunctionProperties();\n  }\n  virtual MachineFunctionProperties getSetProperties() const {\n    return MachineFunctionProperties();\n  }\n  virtual MachineFunctionProperties getClearedProperties() const {\n    return MachineFunctionProperties();\n  }\n\nprivate:\n  MachineFunctionProperties RequiredProperties;\n  MachineFunctionProperties SetProperties;\n  MachineFunctionProperties ClearedProperties;\n\n  /// createPrinterPass - Get a machine function printer pass.\n  Pass *createPrinterPass(raw_ostream &O,\n                          const std::string &Banner) const override;\n\n  bool runOnFunction(Function &F) override;\n};\n\n} // End llvm namespace\n\n#endif\n"}, "28": {"id": 28, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h", "content": "//===- llvm/CodeGen/MachineInstr.h - MachineInstr class ---------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// This file contains the declaration of the MachineInstr class, which is the\n// basic representation for all target dependent machine instructions used by\n// the back end.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_CODEGEN_MACHINEINSTR_H\n#define LLVM_CODEGEN_MACHINEINSTR_H\n\n#include \"llvm/ADT/DenseMapInfo.h\"\n#include \"llvm/ADT/PointerSumType.h\"\n#include \"llvm/ADT/SmallSet.h\"\n#include \"llvm/ADT/ilist.h\"\n#include \"llvm/ADT/ilist_node.h\"\n#include \"llvm/ADT/iterator_range.h\"\n#include \"llvm/CodeGen/MachineMemOperand.h\"\n#include \"llvm/CodeGen/MachineOperand.h\"\n#include \"llvm/CodeGen/TargetOpcodes.h\"\n#include \"llvm/IR/DebugLoc.h\"\n#include \"llvm/IR/InlineAsm.h\"\n#include \"llvm/IR/PseudoProbe.h\"\n#include \"llvm/MC/MCInstrDesc.h\"\n#include \"llvm/MC/MCSymbol.h\"\n#include \"llvm/Support/ArrayRecycler.h\"\n#include \"llvm/Support/TrailingObjects.h\"\n#include <algorithm>\n#include <cassert>\n#include <cstdint>\n#include <utility>\n\nnamespace llvm {\n\nclass AAResults;\ntemplate <typename T> class ArrayRef;\nclass DIExpression;\nclass DILocalVariable;\nclass MachineBasicBlock;\nclass MachineFunction;\nclass MachineRegisterInfo;\nclass ModuleSlotTracker;\nclass raw_ostream;\ntemplate <typename T> class SmallVectorImpl;\nclass SmallBitVector;\nclass StringRef;\nclass TargetInstrInfo;\nclass TargetRegisterClass;\nclass TargetRegisterInfo;\n\n//===----------------------------------------------------------------------===//\n/// Representation of each machine instruction.\n///\n/// This class isn't a POD type, but it must have a trivial destructor. When a\n/// MachineFunction is deleted, all the contained MachineInstrs are deallocated\n/// without having their destructor called.\n///\nclass MachineInstr\n    : public ilist_node_with_parent<MachineInstr, MachineBasicBlock,\n                                    ilist_sentinel_tracking<true>> {\npublic:\n  using mmo_iterator = ArrayRef<MachineMemOperand *>::iterator;\n\n  /// Flags to specify different kinds of comments to output in\n  /// assembly code.  These flags carry semantic information not\n  /// otherwise easily derivable from the IR text.\n  ///\n  enum CommentFlag {\n    ReloadReuse = 0x1,    // higher bits are reserved for target dep comments.\n    NoSchedComment = 0x2,\n    TAsmComments = 0x4    // Target Asm comments should start from this value.\n  };\n\n  enum MIFlag {\n    NoFlags      = 0,\n    FrameSetup   = 1 << 0,              // Instruction is used as a part of\n                                        // function frame setup code.\n    FrameDestroy = 1 << 1,              // Instruction is used as a part of\n                                        // function frame destruction code.\n    BundledPred  = 1 << 2,              // Instruction has bundled predecessors.\n    BundledSucc  = 1 << 3,              // Instruction has bundled successors.\n    FmNoNans     = 1 << 4,              // Instruction does not support Fast\n                                        // math nan values.\n    FmNoInfs     = 1 << 5,              // Instruction does not support Fast\n                                        // math infinity values.\n    FmNsz        = 1 << 6,              // Instruction is not required to retain\n                                        // signed zero values.\n    FmArcp       = 1 << 7,              // Instruction supports Fast math\n                                        // reciprocal approximations.\n    FmContract   = 1 << 8,              // Instruction supports Fast math\n                                        // contraction operations like fma.\n    FmAfn        = 1 << 9,              // Instruction may map to Fast math\n                                        // instrinsic approximation.\n    FmReassoc    = 1 << 10,             // Instruction supports Fast math\n                                        // reassociation of operand order.\n    NoUWrap      = 1 << 11,             // Instruction supports binary operator\n                                        // no unsigned wrap.\n    NoSWrap      = 1 << 12,             // Instruction supports binary operator\n                                        // no signed wrap.\n    IsExact      = 1 << 13,             // Instruction supports division is\n                                        // known to be exact.\n    NoFPExcept   = 1 << 14,             // Instruction does not raise\n                                        // floatint-point exceptions.\n    NoMerge      = 1 << 15,             // Passes that drop source location info\n                                        // (e.g. branch folding) should skip\n                                        // this instruction.\n  };\n\nprivate:\n  const MCInstrDesc *MCID;              // Instruction descriptor.\n  MachineBasicBlock *Parent = nullptr;  // Pointer to the owning basic block.\n\n  // Operands are allocated by an ArrayRecycler.\n  MachineOperand *Operands = nullptr;   // Pointer to the first operand.\n  unsigned NumOperands = 0;             // Number of operands on instruction.\n\n  uint16_t Flags = 0;                   // Various bits of additional\n                                        // information about machine\n                                        // instruction.\n\n  uint8_t AsmPrinterFlags = 0;          // Various bits of information used by\n                                        // the AsmPrinter to emit helpful\n                                        // comments.  This is *not* semantic\n                                        // information.  Do not use this for\n                                        // anything other than to convey comment\n                                        // information to AsmPrinter.\n\n  // OperandCapacity has uint8_t size, so it should be next to AsmPrinterFlags\n  // to properly pack.\n  using OperandCapacity = ArrayRecycler<MachineOperand>::Capacity;\n  OperandCapacity CapOperands;          // Capacity of the Operands array.\n\n  /// Internal implementation detail class that provides out-of-line storage for\n  /// extra info used by the machine instruction when this info cannot be stored\n  /// in-line within the instruction itself.\n  ///\n  /// This has to be defined eagerly due to the implementation constraints of\n  /// `PointerSumType` where it is used.\n  class ExtraInfo final\n      : TrailingObjects<ExtraInfo, MachineMemOperand *, MCSymbol *, MDNode *> {\n  public:\n    static ExtraInfo *create(BumpPtrAllocator &Allocator,\n                             ArrayRef<MachineMemOperand *> MMOs,\n                             MCSymbol *PreInstrSymbol = nullptr,\n                             MCSymbol *PostInstrSymbol = nullptr,\n                             MDNode *HeapAllocMarker = nullptr) {\n      bool HasPreInstrSymbol = PreInstrSymbol != nullptr;\n      bool HasPostInstrSymbol = PostInstrSymbol != nullptr;\n      bool HasHeapAllocMarker = HeapAllocMarker != nullptr;\n      auto *Result = new (Allocator.Allocate(\n          totalSizeToAlloc<MachineMemOperand *, MCSymbol *, MDNode *>(\n              MMOs.size(), HasPreInstrSymbol + HasPostInstrSymbol,\n              HasHeapAllocMarker),\n          alignof(ExtraInfo)))\n          ExtraInfo(MMOs.size(), HasPreInstrSymbol, HasPostInstrSymbol,\n                    HasHeapAllocMarker);\n\n      // Copy the actual data into the trailing objects.\n      std::copy(MMOs.begin(), MMOs.end(),\n                Result->getTrailingObjects<MachineMemOperand *>());\n\n      if (HasPreInstrSymbol)\n        Result->getTrailingObjects<MCSymbol *>()[0] = PreInstrSymbol;\n      if (HasPostInstrSymbol)\n        Result->getTrailingObjects<MCSymbol *>()[HasPreInstrSymbol] =\n            PostInstrSymbol;\n      if (HasHeapAllocMarker)\n        Result->getTrailingObjects<MDNode *>()[0] = HeapAllocMarker;\n\n      return Result;\n    }\n\n    ArrayRef<MachineMemOperand *> getMMOs() const {\n      return makeArrayRef(getTrailingObjects<MachineMemOperand *>(), NumMMOs);\n    }\n\n    MCSymbol *getPreInstrSymbol() const {\n      return HasPreInstrSymbol ? getTrailingObjects<MCSymbol *>()[0] : nullptr;\n    }\n\n    MCSymbol *getPostInstrSymbol() const {\n      return HasPostInstrSymbol\n                 ? getTrailingObjects<MCSymbol *>()[HasPreInstrSymbol]\n                 : nullptr;\n    }\n\n    MDNode *getHeapAllocMarker() const {\n      return HasHeapAllocMarker ? getTrailingObjects<MDNode *>()[0] : nullptr;\n    }\n\n  private:\n    friend TrailingObjects;\n\n    // Description of the extra info, used to interpret the actual optional\n    // data appended.\n    //\n    // Note that this is not terribly space optimized. This leaves a great deal\n    // of flexibility to fit more in here later.\n    const int NumMMOs;\n    const bool HasPreInstrSymbol;\n    const bool HasPostInstrSymbol;\n    const bool HasHeapAllocMarker;\n\n    // Implement the `TrailingObjects` internal API.\n    size_t numTrailingObjects(OverloadToken<MachineMemOperand *>) const {\n      return NumMMOs;\n    }\n    size_t numTrailingObjects(OverloadToken<MCSymbol *>) const {\n      return HasPreInstrSymbol + HasPostInstrSymbol;\n    }\n    size_t numTrailingObjects(OverloadToken<MDNode *>) const {\n      return HasHeapAllocMarker;\n    }\n\n    // Just a boring constructor to allow us to initialize the sizes. Always use\n    // the `create` routine above.\n    ExtraInfo(int NumMMOs, bool HasPreInstrSymbol, bool HasPostInstrSymbol,\n              bool HasHeapAllocMarker)\n        : NumMMOs(NumMMOs), HasPreInstrSymbol(HasPreInstrSymbol),\n          HasPostInstrSymbol(HasPostInstrSymbol),\n          HasHeapAllocMarker(HasHeapAllocMarker) {}\n  };\n\n  /// Enumeration of the kinds of inline extra info available. It is important\n  /// that the `MachineMemOperand` inline kind has a tag value of zero to make\n  /// it accessible as an `ArrayRef`.\n  enum ExtraInfoInlineKinds {\n    EIIK_MMO = 0,\n    EIIK_PreInstrSymbol,\n    EIIK_PostInstrSymbol,\n    EIIK_OutOfLine\n  };\n\n  // We store extra information about the instruction here. The common case is\n  // expected to be nothing or a single pointer (typically a MMO or a symbol).\n  // We work to optimize this common case by storing it inline here rather than\n  // requiring a separate allocation, but we fall back to an allocation when\n  // multiple pointers are needed.\n  PointerSumType<ExtraInfoInlineKinds,\n                 PointerSumTypeMember<EIIK_MMO, MachineMemOperand *>,\n                 PointerSumTypeMember<EIIK_PreInstrSymbol, MCSymbol *>,\n                 PointerSumTypeMember<EIIK_PostInstrSymbol, MCSymbol *>,\n                 PointerSumTypeMember<EIIK_OutOfLine, ExtraInfo *>>\n      Info;\n\n  DebugLoc debugLoc;                    // Source line information.\n\n  /// Unique instruction number. Used by DBG_INSTR_REFs to refer to the values\n  /// defined by this instruction.\n  unsigned DebugInstrNum;\n\n  // Intrusive list support\n  friend struct ilist_traits<MachineInstr>;\n  friend struct ilist_callback_traits<MachineBasicBlock>;\n  void setParent(MachineBasicBlock *P) { Parent = P; }\n\n  /// This constructor creates a copy of the given\n  /// MachineInstr in the given MachineFunction.\n  MachineInstr(MachineFunction &, const MachineInstr &);\n\n  /// This constructor create a MachineInstr and add the implicit operands.\n  /// It reserves space for number of operands specified by\n  /// MCInstrDesc.  An explicit DebugLoc is supplied.\n  MachineInstr(MachineFunction &, const MCInstrDesc &tid, DebugLoc dl,\n               bool NoImp = false);\n\n  // MachineInstrs are pool-allocated and owned by MachineFunction.\n  friend class MachineFunction;\n\n  void\n  dumprImpl(const MachineRegisterInfo &MRI, unsigned Depth, unsigned MaxDepth,\n            SmallPtrSetImpl<const MachineInstr *> &AlreadySeenInstrs) const;\n\npublic:\n  MachineInstr(const MachineInstr &) = delete;\n  MachineInstr &operator=(const MachineInstr &) = delete;\n  // Use MachineFunction::DeleteMachineInstr() instead.\n  ~MachineInstr() = delete;\n\n  const MachineBasicBlock* getParent() const { return Parent; }\n  MachineBasicBlock* getParent() { return Parent; }\n\n  /// Move the instruction before \\p MovePos.\n  void moveBefore(MachineInstr *MovePos);\n\n  /// Return the function that contains the basic block that this instruction\n  /// belongs to.\n  ///\n  /// Note: this is undefined behaviour if the instruction does not have a\n  /// parent.\n  const MachineFunction *getMF() const;\n  MachineFunction *getMF() {\n    return const_cast<MachineFunction *>(\n        static_cast<const MachineInstr *>(this)->getMF());\n  }\n\n  /// Return the asm printer flags bitvector.\n  uint8_t getAsmPrinterFlags() const { return AsmPrinterFlags; }\n\n  /// Clear the AsmPrinter bitvector.\n  void clearAsmPrinterFlags() { AsmPrinterFlags = 0; }\n\n  /// Return whether an AsmPrinter flag is set.\n  bool getAsmPrinterFlag(CommentFlag Flag) const {\n    return AsmPrinterFlags & Flag;\n  }\n\n  /// Set a flag for the AsmPrinter.\n  void setAsmPrinterFlag(uint8_t Flag) {\n    AsmPrinterFlags |= Flag;\n  }\n\n  /// Clear specific AsmPrinter flags.\n  void clearAsmPrinterFlag(CommentFlag Flag) {\n    AsmPrinterFlags &= ~Flag;\n  }\n\n  /// Return the MI flags bitvector.\n  uint16_t getFlags() const {\n    return Flags;\n  }\n\n  /// Return whether an MI flag is set.\n  bool getFlag(MIFlag Flag) const {\n    return Flags & Flag;\n  }\n\n  /// Set a MI flag.\n  void setFlag(MIFlag Flag) {\n    Flags |= (uint16_t)Flag;\n  }\n\n  void setFlags(unsigned flags) {\n    // Filter out the automatically maintained flags.\n    unsigned Mask = BundledPred | BundledSucc;\n    Flags = (Flags & Mask) | (flags & ~Mask);\n  }\n\n  /// clearFlag - Clear a MI flag.\n  void clearFlag(MIFlag Flag) {\n    Flags &= ~((uint16_t)Flag);\n  }\n\n  /// Return true if MI is in a bundle (but not the first MI in a bundle).\n  ///\n  /// A bundle looks like this before it's finalized:\n  ///   ----------------\n  ///   |      MI      |\n  ///   ----------------\n  ///          |\n  ///   ----------------\n  ///   |      MI    * |\n  ///   ----------------\n  ///          |\n  ///   ----------------\n  ///   |      MI    * |\n  ///   ----------------\n  /// In this case, the first MI starts a bundle but is not inside a bundle, the\n  /// next 2 MIs are considered \"inside\" the bundle.\n  ///\n  /// After a bundle is finalized, it looks like this:\n  ///   ----------------\n  ///   |    Bundle    |\n  ///   ----------------\n  ///          |\n  ///   ----------------\n  ///   |      MI    * |\n  ///   ----------------\n  ///          |\n  ///   ----------------\n  ///   |      MI    * |\n  ///   ----------------\n  ///          |\n  ///   ----------------\n  ///   |      MI    * |\n  ///   ----------------\n  /// The first instruction has the special opcode \"BUNDLE\". It's not \"inside\"\n  /// a bundle, but the next three MIs are.\n  bool isInsideBundle() const {\n    return getFlag(BundledPred);\n  }\n\n  /// Return true if this instruction part of a bundle. This is true\n  /// if either itself or its following instruction is marked \"InsideBundle\".\n  bool isBundled() const {\n    return isBundledWithPred() || isBundledWithSucc();\n  }\n\n  /// Return true if this instruction is part of a bundle, and it is not the\n  /// first instruction in the bundle.\n  bool isBundledWithPred() const { return getFlag(BundledPred); }\n\n  /// Return true if this instruction is part of a bundle, and it is not the\n  /// last instruction in the bundle.\n  bool isBundledWithSucc() const { return getFlag(BundledSucc); }\n\n  /// Bundle this instruction with its predecessor. This can be an unbundled\n  /// instruction, or it can be the first instruction in a bundle.\n  void bundleWithPred();\n\n  /// Bundle this instruction with its successor. This can be an unbundled\n  /// instruction, or it can be the last instruction in a bundle.\n  void bundleWithSucc();\n\n  /// Break bundle above this instruction.\n  void unbundleFromPred();\n\n  /// Break bundle below this instruction.\n  void unbundleFromSucc();\n\n  /// Returns the debug location id of this MachineInstr.\n  const DebugLoc &getDebugLoc() const { return debugLoc; }\n\n  /// Return the operand containing the offset to be used if this DBG_VALUE\n  /// instruction is indirect; will be an invalid register if this value is\n  /// not indirect, and an immediate with value 0 otherwise.\n  const MachineOperand &getDebugOffset() const {\n    assert(isNonListDebugValue() && \"not a DBG_VALUE\");\n    return getOperand(1);\n  }\n  MachineOperand &getDebugOffset() {\n    assert(isNonListDebugValue() && \"not a DBG_VALUE\");\n    return getOperand(1);\n  }\n\n  /// Return the operand for the debug variable referenced by\n  /// this DBG_VALUE instruction.\n  const MachineOperand &getDebugVariableOp() const;\n  MachineOperand &getDebugVariableOp();\n\n  /// Return the debug variable referenced by\n  /// this DBG_VALUE instruction.\n  const DILocalVariable *getDebugVariable() const;\n\n  /// Return the operand for the complex address expression referenced by\n  /// this DBG_VALUE instruction.\n  const MachineOperand &getDebugExpressionOp() const;\n  MachineOperand &getDebugExpressionOp();\n\n  /// Return the complex address expression referenced by\n  /// this DBG_VALUE instruction.\n  const DIExpression *getDebugExpression() const;\n\n  /// Return the debug label referenced by\n  /// this DBG_LABEL instruction.\n  const DILabel *getDebugLabel() const;\n\n  /// Fetch the instruction number of this MachineInstr. If it does not have\n  /// one already, a new and unique number will be assigned.\n  unsigned getDebugInstrNum();\n\n  /// Examine the instruction number of this MachineInstr. May be zero if\n  /// it hasn't been assigned a number yet.\n  unsigned peekDebugInstrNum() const { return DebugInstrNum; }\n\n  /// Set instruction number of this MachineInstr. Avoid using unless you're\n  /// deserializing this information.\n  void setDebugInstrNum(unsigned Num) { DebugInstrNum = Num; }\n\n  /// Emit an error referring to the source location of this instruction.\n  /// This should only be used for inline assembly that is somehow\n  /// impossible to compile. Other errors should have been handled much\n  /// earlier.\n  ///\n  /// If this method returns, the caller should try to recover from the error.\n  void emitError(StringRef Msg) const;\n\n  /// Returns the target instruction descriptor of this MachineInstr.\n  const MCInstrDesc &getDesc() const { return *MCID; }\n\n  /// Returns the opcode of this MachineInstr.\n  unsigned getOpcode() const { return MCID->Opcode; }\n\n  /// Retuns the total number of operands.\n  unsigned getNumOperands() const { return NumOperands; }\n\n  /// Returns the total number of operands which are debug locations.\n  unsigned getNumDebugOperands() const {\n    return std::distance(debug_operands().begin(), debug_operands().end());\n  }\n\n  const MachineOperand& getOperand(unsigned i) const {\n    assert(i < getNumOperands() && \"getOperand() out of range!\");\n    return Operands[i];\n  }\n  MachineOperand& getOperand(unsigned i) {\n    assert(i < getNumOperands() && \"getOperand() out of range!\");\n    return Operands[i];\n  }\n\n  MachineOperand &getDebugOperand(unsigned Index) {\n    assert(Index < getNumDebugOperands() && \"getDebugOperand() out of range!\");\n    return *(debug_operands().begin() + Index);\n  }\n  const MachineOperand &getDebugOperand(unsigned Index) const {\n    assert(Index < getNumDebugOperands() && \"getDebugOperand() out of range!\");\n    return *(debug_operands().begin() + Index);\n  }\n\n  SmallSet<Register, 4> getUsedDebugRegs() const {\n    assert(isDebugValue() && \"not a DBG_VALUE*\");\n    SmallSet<Register, 4> UsedRegs;\n    for (auto MO : debug_operands())\n      if (MO.isReg() && MO.getReg())\n        UsedRegs.insert(MO.getReg());\n    return UsedRegs;\n  }\n\n  /// Returns whether this debug value has at least one debug operand with the\n  /// register \\p Reg.\n  bool hasDebugOperandForReg(Register Reg) const {\n    return any_of(debug_operands(), [Reg](const MachineOperand &Op) {\n      return Op.isReg() && Op.getReg() == Reg;\n    });\n  }\n\n  /// Returns a range of all of the operands that correspond to a debug use of\n  /// \\p Reg.\n  template <typename Operand, typename Instruction>\n  static iterator_range<\n      filter_iterator<Operand *, std::function<bool(Operand &Op)>>>\n  getDebugOperandsForReg(Instruction *MI, Register Reg) {\n    std::function<bool(Operand & Op)> OpUsesReg(\n        [Reg](Operand &Op) { return Op.isReg() && Op.getReg() == Reg; });\n    return make_filter_range(MI->debug_operands(), OpUsesReg);\n  }\n  iterator_range<filter_iterator<const MachineOperand *,\n                                 std::function<bool(const MachineOperand &Op)>>>\n  getDebugOperandsForReg(Register Reg) const {\n    return MachineInstr::getDebugOperandsForReg<const MachineOperand,\n                                                const MachineInstr>(this, Reg);\n  }\n  iterator_range<filter_iterator<MachineOperand *,\n                                 std::function<bool(MachineOperand &Op)>>>\n  getDebugOperandsForReg(Register Reg) {\n    return MachineInstr::getDebugOperandsForReg<MachineOperand, MachineInstr>(\n        this, Reg);\n  }\n\n  bool isDebugOperand(const MachineOperand *Op) const {\n    return Op >= adl_begin(debug_operands()) && Op <= adl_end(debug_operands());\n  }\n\n  unsigned getDebugOperandIndex(const MachineOperand *Op) const {\n    assert(isDebugOperand(Op) && \"Expected a debug operand.\");\n    return std::distance(adl_begin(debug_operands()), Op);\n  }\n\n  /// Returns the total number of definitions.\n  unsigned getNumDefs() const {\n    return getNumExplicitDefs() + MCID->getNumImplicitDefs();\n  }\n\n  /// Returns true if the instruction has implicit definition.\n  bool hasImplicitDef() const {\n    for (unsigned I = getNumExplicitOperands(), E = getNumOperands();\n      I != E; ++I) {\n      const MachineOperand &MO = getOperand(I);\n      if (MO.isDef() && MO.isImplicit())\n        return true;\n    }\n    return false;\n  }\n\n  /// Returns the implicit operands number.\n  unsigned getNumImplicitOperands() const {\n    return getNumOperands() - getNumExplicitOperands();\n  }\n\n  /// Return true if operand \\p OpIdx is a subregister index.\n  bool isOperandSubregIdx(unsigned OpIdx) const {\n    assert(getOperand(OpIdx).getType() == MachineOperand::MO_Immediate &&\n           \"Expected MO_Immediate operand type.\");\n    if (isExtractSubreg() && OpIdx == 2)\n      return true;\n    if (isInsertSubreg() && OpIdx == 3)\n      return true;\n    if (isRegSequence() && OpIdx > 1 && (OpIdx % 2) == 0)\n      return true;\n    if (isSubregToReg() && OpIdx == 3)\n      return true;\n    return false;\n  }\n\n  /// Returns the number of non-implicit operands.\n  unsigned getNumExplicitOperands() const;\n\n  /// Returns the number of non-implicit definitions.\n  unsigned getNumExplicitDefs() const;\n\n  /// iterator/begin/end - Iterate over all operands of a machine instruction.\n  using mop_iterator = MachineOperand *;\n  using const_mop_iterator = const MachineOperand *;\n\n  mop_iterator operands_begin() { return Operands; }\n  mop_iterator operands_end() { return Operands + NumOperands; }\n\n  const_mop_iterator operands_begin() const { return Operands; }\n  const_mop_iterator operands_end() const { return Operands + NumOperands; }\n\n  iterator_range<mop_iterator> operands() {\n    return make_range(operands_begin(), operands_end());\n  }\n  iterator_range<const_mop_iterator> operands() const {\n    return make_range(operands_begin(), operands_end());\n  }\n  iterator_range<mop_iterator> explicit_operands() {\n    return make_range(operands_begin(),\n                      operands_begin() + getNumExplicitOperands());\n  }\n  iterator_range<const_mop_iterator> explicit_operands() const {\n    return make_range(operands_begin(),\n                      operands_begin() + getNumExplicitOperands());\n  }\n  iterator_range<mop_iterator> implicit_operands() {\n    return make_range(explicit_operands().end(), operands_end());\n  }\n  iterator_range<const_mop_iterator> implicit_operands() const {\n    return make_range(explicit_operands().end(), operands_end());\n  }\n  /// Returns a range over all operands that are used to determine the variable\n  /// location for this DBG_VALUE instruction.\n  iterator_range<mop_iterator> debug_operands() {\n    assert(isDebugValue() && \"Must be a debug value instruction.\");\n    return isDebugValueList()\n               ? make_range(operands_begin() + 2, operands_end())\n               : make_range(operands_begin(), operands_begin() + 1);\n  }\n  /// \\copydoc debug_operands()\n  iterator_range<const_mop_iterator> debug_operands() const {\n    assert(isDebugValue() && \"Must be a debug value instruction.\");\n    return isDebugValueList()\n               ? make_range(operands_begin() + 2, operands_end())\n               : make_range(operands_begin(), operands_begin() + 1);\n  }\n  /// Returns a range over all explicit operands that are register definitions.\n  /// Implicit definition are not included!\n  iterator_range<mop_iterator> defs() {\n    return make_range(operands_begin(),\n                      operands_begin() + getNumExplicitDefs());\n  }\n  /// \\copydoc defs()\n  iterator_range<const_mop_iterator> defs() const {\n    return make_range(operands_begin(),\n                      operands_begin() + getNumExplicitDefs());\n  }\n  /// Returns a range that includes all operands that are register uses.\n  /// This may include unrelated operands which are not register uses.\n  iterator_range<mop_iterator> uses() {\n    return make_range(operands_begin() + getNumExplicitDefs(), operands_end());\n  }\n  /// \\copydoc uses()\n  iterator_range<const_mop_iterator> uses() const {\n    return make_range(operands_begin() + getNumExplicitDefs(), operands_end());\n  }\n  iterator_range<mop_iterator> explicit_uses() {\n    return make_range(operands_begin() + getNumExplicitDefs(),\n                      operands_begin() + getNumExplicitOperands());\n  }\n  iterator_range<const_mop_iterator> explicit_uses() const {\n    return make_range(operands_begin() + getNumExplicitDefs(),\n                      operands_begin() + getNumExplicitOperands());\n  }\n\n  /// Returns the number of the operand iterator \\p I points to.\n  unsigned getOperandNo(const_mop_iterator I) const {\n    return I - operands_begin();\n  }\n\n  /// Access to memory operands of the instruction. If there are none, that does\n  /// not imply anything about whether the function accesses memory. Instead,\n  /// the caller must behave conservatively.\n  ArrayRef<MachineMemOperand *> memoperands() const {\n    if (!Info)\n      return {};\n\n    if (Info.is<EIIK_MMO>())\n      return makeArrayRef(Info.getAddrOfZeroTagPointer(), 1);\n\n    if (ExtraInfo *EI = Info.get<EIIK_OutOfLine>())\n      return EI->getMMOs();\n\n    return {};\n  }\n\n  /// Access to memory operands of the instruction.\n  ///\n  /// If `memoperands_begin() == memoperands_end()`, that does not imply\n  /// anything about whether the function accesses memory. Instead, the caller\n  /// must behave conservatively.\n  mmo_iterator memoperands_begin() const { return memoperands().begin(); }\n\n  /// Access to memory operands of the instruction.\n  ///\n  /// If `memoperands_begin() == memoperands_end()`, that does not imply\n  /// anything about whether the function accesses memory. Instead, the caller\n  /// must behave conservatively.\n  mmo_iterator memoperands_end() const { return memoperands().end(); }\n\n  /// Return true if we don't have any memory operands which described the\n  /// memory access done by this instruction.  If this is true, calling code\n  /// must be conservative.\n  bool memoperands_empty() const { return memoperands().empty(); }\n\n  /// Return true if this instruction has exactly one MachineMemOperand.\n  bool hasOneMemOperand() const { return memoperands().size() == 1; }\n\n  /// Return the number of memory operands.\n  unsigned getNumMemOperands() const { return memoperands().size(); }\n\n  /// Helper to extract a pre-instruction symbol if one has been added.\n  MCSymbol *getPreInstrSymbol() const {\n    if (!Info)\n      return nullptr;\n    if (MCSymbol *S = Info.get<EIIK_PreInstrSymbol>())\n      return S;\n    if (ExtraInfo *EI = Info.get<EIIK_OutOfLine>())\n      return EI->getPreInstrSymbol();\n\n    return nullptr;\n  }\n\n  /// Helper to extract a post-instruction symbol if one has been added.\n  MCSymbol *getPostInstrSymbol() const {\n    if (!Info)\n      return nullptr;\n    if (MCSymbol *S = Info.get<EIIK_PostInstrSymbol>())\n      return S;\n    if (ExtraInfo *EI = Info.get<EIIK_OutOfLine>())\n      return EI->getPostInstrSymbol();\n\n    return nullptr;\n  }\n\n  /// Helper to extract a heap alloc marker if one has been added.\n  MDNode *getHeapAllocMarker() const {\n    if (!Info)\n      return nullptr;\n    if (ExtraInfo *EI = Info.get<EIIK_OutOfLine>())\n      return EI->getHeapAllocMarker();\n\n    return nullptr;\n  }\n\n  /// API for querying MachineInstr properties. They are the same as MCInstrDesc\n  /// queries but they are bundle aware.\n\n  enum QueryType {\n    IgnoreBundle,    // Ignore bundles\n    AnyInBundle,     // Return true if any instruction in bundle has property\n    AllInBundle      // Return true if all instructions in bundle have property\n  };\n\n  /// Return true if the instruction (or in the case of a bundle,\n  /// the instructions inside the bundle) has the specified property.\n  /// The first argument is the property being queried.\n  /// The second argument indicates whether the query should look inside\n  /// instruction bundles.\n  bool hasProperty(unsigned MCFlag, QueryType Type = AnyInBundle) const {\n    assert(MCFlag < 64 &&\n           \"MCFlag out of range for bit mask in getFlags/hasPropertyInBundle.\");\n    // Inline the fast path for unbundled or bundle-internal instructions.\n    if (Type == IgnoreBundle || !isBundled() || isBundledWithPred())\n      return getDesc().getFlags() & (1ULL << MCFlag);\n\n    // If this is the first instruction in a bundle, take the slow path.\n    return hasPropertyInBundle(1ULL << MCFlag, Type);\n  }\n\n  /// Return true if this is an instruction that should go through the usual\n  /// legalization steps.\n  bool isPreISelOpcode(QueryType Type = IgnoreBundle) const {\n    return hasProperty(MCID::PreISelOpcode, Type);\n  }\n\n  /// Return true if this instruction can have a variable number of operands.\n  /// In this case, the variable operands will be after the normal\n  /// operands but before the implicit definitions and uses (if any are\n  /// present).\n  bool isVariadic(QueryType Type = IgnoreBundle) const {\n    return hasProperty(MCID::Variadic, Type);\n  }\n\n  /// Set if this instruction has an optional definition, e.g.\n  /// ARM instructions which can set condition code if 's' bit is set.\n  bool hasOptionalDef(QueryType Type = IgnoreBundle) const {\n    return hasProperty(MCID::HasOptionalDef, Type);\n  }\n\n  /// Return true if this is a pseudo instruction that doesn't\n  /// correspond to a real machine instruction.\n  bool isPseudo(QueryType Type = IgnoreBundle) const {\n    return hasProperty(MCID::Pseudo, Type);\n  }\n\n  bool isReturn(QueryType Type = AnyInBundle) const {\n    return hasProperty(MCID::Return, Type);\n  }\n\n  /// Return true if this is an instruction that marks the end of an EH scope,\n  /// i.e., a catchpad or a cleanuppad instruction.\n  bool isEHScopeReturn(QueryType Type = AnyInBundle) const {\n    return hasProperty(MCID::EHScopeReturn, Type);\n  }\n\n  bool isCall(QueryType Type = AnyInBundle) const {\n    return hasProperty(MCID::Call, Type);\n  }\n\n  /// Return true if this is a call instruction that may have an associated\n  /// call site entry in the debug info.\n  bool isCandidateForCallSiteEntry(QueryType Type = IgnoreBundle) const;\n  /// Return true if copying, moving, or erasing this instruction requires\n  /// updating Call Site Info (see \\ref copyCallSiteInfo, \\ref moveCallSiteInfo,\n  /// \\ref eraseCallSiteInfo).\n  bool shouldUpdateCallSiteInfo() const;\n\n  /// Returns true if the specified instruction stops control flow\n  /// from executing the instruction immediately following it.  Examples include\n  /// unconditional branches and return instructions.\n  bool isBarrier(QueryType Type = AnyInBundle) const {\n    return hasProperty(MCID::Barrier, Type);\n  }\n\n  /// Returns true if this instruction part of the terminator for a basic block.\n  /// Typically this is things like return and branch instructions.\n  ///\n  /// Various passes use this to insert code into the bottom of a basic block,\n  /// but before control flow occurs.\n  bool isTerminator(QueryType Type = AnyInBundle) const {\n    return hasProperty(MCID::Terminator, Type);\n  }\n\n  /// Returns true if this is a conditional, unconditional, or indirect branch.\n  /// Predicates below can be used to discriminate between\n  /// these cases, and the TargetInstrInfo::analyzeBranch method can be used to\n  /// get more information.\n  bool isBranch(QueryType Type = AnyInBundle) const {\n    return hasProperty(MCID::Branch, Type);\n  }\n\n  /// Return true if this is an indirect branch, such as a\n  /// branch through a register.\n  bool isIndirectBranch(QueryType Type = AnyInBundle) const {\n    return hasProperty(MCID::IndirectBranch, Type);\n  }\n\n  /// Return true if this is a branch which may fall\n  /// through to the next instruction or may transfer control flow to some other\n  /// block.  The TargetInstrInfo::analyzeBranch method can be used to get more\n  /// information about this branch.\n  bool isConditionalBranch(QueryType Type = AnyInBundle) const {\n    return isBranch(Type) && !isBarrier(Type) && !isIndirectBranch(Type);\n  }\n\n  /// Return true if this is a branch which always\n  /// transfers control flow to some other block.  The\n  /// TargetInstrInfo::analyzeBranch method can be used to get more information\n  /// about this branch.\n  bool isUnconditionalBranch(QueryType Type = AnyInBundle) const {\n    return isBranch(Type) && isBarrier(Type) && !isIndirectBranch(Type);\n  }\n\n  /// Return true if this instruction has a predicate operand that\n  /// controls execution.  It may be set to 'always', or may be set to other\n  /// values.   There are various methods in TargetInstrInfo that can be used to\n  /// control and modify the predicate in this instruction.\n  bool isPredicable(QueryType Type = AllInBundle) const {\n    // If it's a bundle than all bundled instructions must be predicable for this\n    // to return true.\n    return hasProperty(MCID::Predicable, Type);\n  }\n\n  /// Return true if this instruction is a comparison.\n  bool isCompare(QueryType Type = IgnoreBundle) const {\n    return hasProperty(MCID::Compare, Type);\n  }\n\n  /// Return true if this instruction is a move immediate\n  /// (including conditional moves) instruction.\n  bool isMoveImmediate(QueryType Type = IgnoreBundle) const {\n    return hasProperty(MCID::MoveImm, Type);\n  }\n\n  /// Return true if this instruction is a register move.\n  /// (including moving values from subreg to reg)\n  bool isMoveReg(QueryType Type = IgnoreBundle) const {\n    return hasProperty(MCID::MoveReg, Type);\n  }\n\n  /// Return true if this instruction is a bitcast instruction.\n  bool isBitcast(QueryType Type = IgnoreBundle) const {\n    return hasProperty(MCID::Bitcast, Type);\n  }\n\n  /// Return true if this instruction is a select instruction.\n  bool isSelect(QueryType Type = IgnoreBundle) const {\n    return hasProperty(MCID::Select, Type);\n  }\n\n  /// Return true if this instruction cannot be safely duplicated.\n  /// For example, if the instruction has a unique labels attached\n  /// to it, duplicating it would cause multiple definition errors.\n  bool isNotDuplicable(QueryType Type = AnyInBundle) const {\n    return hasProperty(MCID::NotDuplicable, Type);\n  }\n\n  /// Return true if this instruction is convergent.\n  /// Convergent instructions can not be made control-dependent on any\n  /// additional values.\n  bool isConvergent(QueryType Type = AnyInBundle) const {\n    if (isInlineAsm()) {\n      unsigned ExtraInfo = getOperand(InlineAsm::MIOp_ExtraInfo).getImm();\n      if (ExtraInfo & InlineAsm::Extra_IsConvergent)\n        return true;\n    }\n    return hasProperty(MCID::Convergent, Type);\n  }\n\n  /// Returns true if the specified instruction has a delay slot\n  /// which must be filled by the code generator.\n  bool hasDelaySlot(QueryType Type = AnyInBundle) const {\n    return hasProperty(MCID::DelaySlot, Type);\n  }\n\n  /// Return true for instructions that can be folded as\n  /// memory operands in other instructions. The most common use for this\n  /// is instructions that are simple loads from memory that don't modify\n  /// the loaded value in any way, but it can also be used for instructions\n  /// that can be expressed as constant-pool loads, such as V_SETALLONES\n  /// on x86, to allow them to be folded when it is beneficial.\n  /// This should only be set on instructions that return a value in their\n  /// only virtual register definition.\n  bool canFoldAsLoad(QueryType Type = IgnoreBundle) const {\n    return hasProperty(MCID::FoldableAsLoad, Type);\n  }\n\n  /// Return true if this instruction behaves\n  /// the same way as the generic REG_SEQUENCE instructions.\n  /// E.g., on ARM,\n  /// dX VMOVDRR rY, rZ\n  /// is equivalent to\n  /// dX = REG_SEQUENCE rY, ssub_0, rZ, ssub_1.\n  ///\n  /// Note that for the optimizers to be able to take advantage of\n  /// this property, TargetInstrInfo::getRegSequenceLikeInputs has to be\n  /// override accordingly.\n  bool isRegSequenceLike(QueryType Type = IgnoreBundle) const {\n    return hasProperty(MCID::RegSequence, Type);\n  }\n\n  /// Return true if this instruction behaves\n  /// the same way as the generic EXTRACT_SUBREG instructions.\n  /// E.g., on ARM,\n  /// rX, rY VMOVRRD dZ\n  /// is equivalent to two EXTRACT_SUBREG:\n  /// rX = EXTRACT_SUBREG dZ, ssub_0\n  /// rY = EXTRACT_SUBREG dZ, ssub_1\n  ///\n  /// Note that for the optimizers to be able to take advantage of\n  /// this property, TargetInstrInfo::getExtractSubregLikeInputs has to be\n  /// override accordingly.\n  bool isExtractSubregLike(QueryType Type = IgnoreBundle) const {\n    return hasProperty(MCID::ExtractSubreg, Type);\n  }\n\n  /// Return true if this instruction behaves\n  /// the same way as the generic INSERT_SUBREG instructions.\n  /// E.g., on ARM,\n  /// dX = VSETLNi32 dY, rZ, Imm\n  /// is equivalent to a INSERT_SUBREG:\n  /// dX = INSERT_SUBREG dY, rZ, translateImmToSubIdx(Imm)\n  ///\n  /// Note that for the optimizers to be able to take advantage of\n  /// this property, TargetInstrInfo::getInsertSubregLikeInputs has to be\n  /// override accordingly.\n  bool isInsertSubregLike(QueryType Type = IgnoreBundle) const {\n    return hasProperty(MCID::InsertSubreg, Type);\n  }\n\n  //===--------------------------------------------------------------------===//\n  // Side Effect Analysis\n  //===--------------------------------------------------------------------===//\n\n  /// Return true if this instruction could possibly read memory.\n  /// Instructions with this flag set are not necessarily simple load\n  /// instructions, they may load a value and modify it, for example.\n  bool mayLoad(QueryType Type = AnyInBundle) const {\n    if (isInlineAsm()) {\n      unsigned ExtraInfo = getOperand(InlineAsm::MIOp_ExtraInfo).getImm();\n      if (ExtraInfo & InlineAsm::Extra_MayLoad)\n        return true;\n    }\n    return hasProperty(MCID::MayLoad, Type);\n  }\n\n  /// Return true if this instruction could possibly modify memory.\n  /// Instructions with this flag set are not necessarily simple store\n  /// instructions, they may store a modified value based on their operands, or\n  /// may not actually modify anything, for example.\n  bool mayStore(QueryType Type = AnyInBundle) const {\n    if (isInlineAsm()) {\n      unsigned ExtraInfo = getOperand(InlineAsm::MIOp_ExtraInfo).getImm();\n      if (ExtraInfo & InlineAsm::Extra_MayStore)\n        return true;\n    }\n    return hasProperty(MCID::MayStore, Type);\n  }\n\n  /// Return true if this instruction could possibly read or modify memory.\n  bool mayLoadOrStore(QueryType Type = AnyInBundle) const {\n    return mayLoad(Type) || mayStore(Type);\n  }\n\n  /// Return true if this instruction could possibly raise a floating-point\n  /// exception.  This is the case if the instruction is a floating-point\n  /// instruction that can in principle raise an exception, as indicated\n  /// by the MCID::MayRaiseFPException property, *and* at the same time,\n  /// the instruction is used in a context where we expect floating-point\n  /// exceptions are not disabled, as indicated by the NoFPExcept MI flag.\n  bool mayRaiseFPException() const {\n    return hasProperty(MCID::MayRaiseFPException) &&\n           !getFlag(MachineInstr::MIFlag::NoFPExcept);\n  }\n\n  //===--------------------------------------------------------------------===//\n  // Flags that indicate whether an instruction can be modified by a method.\n  //===--------------------------------------------------------------------===//\n\n  /// Return true if this may be a 2- or 3-address\n  /// instruction (of the form \"X = op Y, Z, ...\"), which produces the same\n  /// result if Y and Z are exchanged.  If this flag is set, then the\n  /// TargetInstrInfo::commuteInstruction method may be used to hack on the\n  /// instruction.\n  ///\n  /// Note that this flag may be set on instructions that are only commutable\n  /// sometimes.  In these cases, the call to commuteInstruction will fail.\n  /// Also note that some instructions require non-trivial modification to\n  /// commute them.\n  bool isCommutable(QueryType Type = IgnoreBundle) const {\n    return hasProperty(MCID::Commutable, Type);\n  }\n\n  /// Return true if this is a 2-address instruction\n  /// which can be changed into a 3-address instruction if needed.  Doing this\n  /// transformation can be profitable in the register allocator, because it\n  /// means that the instruction can use a 2-address form if possible, but\n  /// degrade into a less efficient form if the source and dest register cannot\n  /// be assigned to the same register.  For example, this allows the x86\n  /// backend to turn a \"shl reg, 3\" instruction into an LEA instruction, which\n  /// is the same speed as the shift but has bigger code size.\n  ///\n  /// If this returns true, then the target must implement the\n  /// TargetInstrInfo::convertToThreeAddress method for this instruction, which\n  /// is allowed to fail if the transformation isn't valid for this specific\n  /// instruction (e.g. shl reg, 4 on x86).\n  ///\n  bool isConvertibleTo3Addr(QueryType Type = IgnoreBundle) const {\n    return hasProperty(MCID::ConvertibleTo3Addr, Type);\n  }\n\n  /// Return true if this instruction requires\n  /// custom insertion support when the DAG scheduler is inserting it into a\n  /// machine basic block.  If this is true for the instruction, it basically\n  /// means that it is a pseudo instruction used at SelectionDAG time that is\n  /// expanded out into magic code by the target when MachineInstrs are formed.\n  ///\n  /// If this is true, the TargetLoweringInfo::InsertAtEndOfBasicBlock method\n  /// is used to insert this into the MachineBasicBlock.\n  bool usesCustomInsertionHook(QueryType Type = IgnoreBundle) const {\n    return hasProperty(MCID::UsesCustomInserter, Type);\n  }\n\n  /// Return true if this instruction requires *adjustment*\n  /// after instruction selection by calling a target hook. For example, this\n  /// can be used to fill in ARM 's' optional operand depending on whether\n  /// the conditional flag register is used.\n  bool hasPostISelHook(QueryType Type = IgnoreBundle) const {\n    return hasProperty(MCID::HasPostISelHook, Type);\n  }\n\n  /// Returns true if this instruction is a candidate for remat.\n  /// This flag is deprecated, please don't use it anymore.  If this\n  /// flag is set, the isReallyTriviallyReMaterializable() method is called to\n  /// verify the instruction is really rematable.\n  bool isRematerializable(QueryType Type = AllInBundle) const {\n    // It's only possible to re-mat a bundle if all bundled instructions are\n    // re-materializable.\n    return hasProperty(MCID::Rematerializable, Type);\n  }\n\n  /// Returns true if this instruction has the same cost (or less) than a move\n  /// instruction. This is useful during certain types of optimizations\n  /// (e.g., remat during two-address conversion or machine licm)\n  /// where we would like to remat or hoist the instruction, but not if it costs\n  /// more than moving the instruction into the appropriate register. Note, we\n  /// are not marking copies from and to the same register class with this flag.\n  bool isAsCheapAsAMove(QueryType Type = AllInBundle) const {\n    // Only returns true for a bundle if all bundled instructions are cheap.\n    return hasProperty(MCID::CheapAsAMove, Type);\n  }\n\n  /// Returns true if this instruction source operands\n  /// have special register allocation requirements that are not captured by the\n  /// operand register classes. e.g. ARM::STRD's two source registers must be an\n  /// even / odd pair, ARM::STM registers have to be in ascending order.\n  /// Post-register allocation passes should not attempt to change allocations\n  /// for sources of instructions with this flag.\n  bool hasExtraSrcRegAllocReq(QueryType Type = AnyInBundle) const {\n    return hasProperty(MCID::ExtraSrcRegAllocReq, Type);\n  }\n\n  /// Returns true if this instruction def operands\n  /// have special register allocation requirements that are not captured by the\n  /// operand register classes. e.g. ARM::LDRD's two def registers must be an\n  /// even / odd pair, ARM::LDM registers have to be in ascending order.\n  /// Post-register allocation passes should not attempt to change allocations\n  /// for definitions of instructions with this flag.\n  bool hasExtraDefRegAllocReq(QueryType Type = AnyInBundle) const {\n    return hasProperty(MCID::ExtraDefRegAllocReq, Type);\n  }\n\n  enum MICheckType {\n    CheckDefs,      // Check all operands for equality\n    CheckKillDead,  // Check all operands including kill / dead markers\n    IgnoreDefs,     // Ignore all definitions\n    IgnoreVRegDefs  // Ignore virtual register definitions\n  };\n\n  /// Return true if this instruction is identical to \\p Other.\n  /// Two instructions are identical if they have the same opcode and all their\n  /// operands are identical (with respect to MachineOperand::isIdenticalTo()).\n  /// Note that this means liveness related flags (dead, undef, kill) do not\n  /// affect the notion of identical.\n  bool isIdenticalTo(const MachineInstr &Other,\n                     MICheckType Check = CheckDefs) const;\n\n  /// Unlink 'this' from the containing basic block, and return it without\n  /// deleting it.\n  ///\n  /// This function can not be used on bundled instructions, use\n  /// removeFromBundle() to remove individual instructions from a bundle.\n  MachineInstr *removeFromParent();\n\n  /// Unlink this instruction from its basic block and return it without\n  /// deleting it.\n  ///\n  /// If the instruction is part of a bundle, the other instructions in the\n  /// bundle remain bundled.\n  MachineInstr *removeFromBundle();\n\n  /// Unlink 'this' from the containing basic block and delete it.\n  ///\n  /// If this instruction is the header of a bundle, the whole bundle is erased.\n  /// This function can not be used for instructions inside a bundle, use\n  /// eraseFromBundle() to erase individual bundled instructions.\n  void eraseFromParent();\n\n  /// Unlink 'this' from the containing basic block and delete it.\n  ///\n  /// For all definitions mark their uses in DBG_VALUE nodes\n  /// as undefined. Otherwise like eraseFromParent().\n  void eraseFromParentAndMarkDBGValuesForRemoval();\n\n  /// Unlink 'this' form its basic block and delete it.\n  ///\n  /// If the instruction is part of a bundle, the other instructions in the\n  /// bundle remain bundled.\n  void eraseFromBundle();\n\n  bool isEHLabel() const { return getOpcode() == TargetOpcode::EH_LABEL; }\n  bool isGCLabel() const { return getOpcode() == TargetOpcode::GC_LABEL; }\n  bool isAnnotationLabel() const {\n    return getOpcode() == TargetOpcode::ANNOTATION_LABEL;\n  }\n\n  /// Returns true if the MachineInstr represents a label.\n  bool isLabel() const {\n    return isEHLabel() || isGCLabel() || isAnnotationLabel();\n  }\n\n  bool isCFIInstruction() const {\n    return getOpcode() == TargetOpcode::CFI_INSTRUCTION;\n  }\n\n  bool isPseudoProbe() const {\n    return getOpcode() == TargetOpcode::PSEUDO_PROBE;\n  }\n\n  // True if the instruction represents a position in the function.\n  bool isPosition() const { return isLabel() || isCFIInstruction(); }\n\n  bool isNonListDebugValue() const {\n    return getOpcode() == TargetOpcode::DBG_VALUE;\n  }\n  bool isDebugValueList() const {\n    return getOpcode() == TargetOpcode::DBG_VALUE_LIST;\n  }\n  bool isDebugValue() const {\n    return isNonListDebugValue() || isDebugValueList();\n  }\n  bool isDebugLabel() const { return getOpcode() == TargetOpcode::DBG_LABEL; }\n  bool isDebugRef() const { return getOpcode() == TargetOpcode::DBG_INSTR_REF; }\n  bool isDebugInstr() const {\n    return isDebugValue() || isDebugLabel() || isDebugRef();\n  }\n  bool isDebugOrPseudoInstr() const {\n    return isDebugInstr() || isPseudoProbe();\n  }\n\n  bool isDebugOffsetImm() const {\n    return isNonListDebugValue() && getDebugOffset().isImm();\n  }\n\n  /// A DBG_VALUE is indirect iff the location operand is a register and\n  /// the offset operand is an immediate.\n  bool isIndirectDebugValue() const {\n    return isDebugOffsetImm() && getDebugOperand(0).isReg();\n  }\n\n  /// A DBG_VALUE is an entry value iff its debug expression contains the\n  /// DW_OP_LLVM_entry_value operation.\n  bool isDebugEntryValue() const;\n\n  /// Return true if the instruction is a debug value which describes a part of\n  /// a variable as unavailable.\n  bool isUndefDebugValue() const {\n    if (!isDebugValue())\n      return false;\n    // If any $noreg locations are given, this DV is undef.\n    for (const MachineOperand &Op : debug_operands())\n      if (Op.isReg() && !Op.getReg().isValid())\n        return true;\n    return false;\n  }\n\n  bool isPHI() const {\n    return getOpcode() == TargetOpcode::PHI ||\n           getOpcode() == TargetOpcode::G_PHI;\n  }\n  bool isKill() const { return getOpcode() == TargetOpcode::KILL; }\n  bool isImplicitDef() const { return getOpcode()==TargetOpcode::IMPLICIT_DEF; }\n  bool isInlineAsm() const {\n    return getOpcode() == TargetOpcode::INLINEASM ||\n           getOpcode() == TargetOpcode::INLINEASM_BR;\n  }\n\n  /// FIXME: Seems like a layering violation that the AsmDialect, which is X86\n  /// specific, be attached to a generic MachineInstr.\n  bool isMSInlineAsm() const {\n    return isInlineAsm() && getInlineAsmDialect() == InlineAsm::AD_Intel;\n  }\n\n  bool isStackAligningInlineAsm() const;\n  InlineAsm::AsmDialect getInlineAsmDialect() const;\n\n  bool isInsertSubreg() const {\n    return getOpcode() == TargetOpcode::INSERT_SUBREG;\n  }\n\n  bool isSubregToReg() const {\n    return getOpcode() == TargetOpcode::SUBREG_TO_REG;\n  }\n\n  bool isRegSequence() const {\n    return getOpcode() == TargetOpcode::REG_SEQUENCE;\n  }\n\n  bool isBundle() const {\n    return getOpcode() == TargetOpcode::BUNDLE;\n  }\n\n  bool isCopy() const {\n    return getOpcode() == TargetOpcode::COPY;\n  }\n\n  bool isFullCopy() const {\n    return isCopy() && !getOperand(0).getSubReg() && !getOperand(1).getSubReg();\n  }\n\n  bool isExtractSubreg() const {\n    return getOpcode() == TargetOpcode::EXTRACT_SUBREG;\n  }\n\n  /// Return true if the instruction behaves like a copy.\n  /// This does not include native copy instructions.\n  bool isCopyLike() const {\n    return isCopy() || isSubregToReg();\n  }\n\n  /// Return true is the instruction is an identity copy.\n  bool isIdentityCopy() const {\n    return isCopy() && getOperand(0).getReg() == getOperand(1).getReg() &&\n      getOperand(0).getSubReg() == getOperand(1).getSubReg();\n  }\n\n  /// Return true if this instruction doesn't produce any output in the form of\n  /// executable instructions.\n  bool isMetaInstruction() const {\n    switch (getOpcode()) {\n    default:\n      return false;\n    case TargetOpcode::IMPLICIT_DEF:\n    case TargetOpcode::KILL:\n    case TargetOpcode::CFI_INSTRUCTION:\n    case TargetOpcode::EH_LABEL:\n    case TargetOpcode::GC_LABEL:\n    case TargetOpcode::DBG_VALUE:\n    case TargetOpcode::DBG_VALUE_LIST:\n    case TargetOpcode::DBG_INSTR_REF:\n    case TargetOpcode::DBG_LABEL:\n    case TargetOpcode::LIFETIME_START:\n    case TargetOpcode::LIFETIME_END:\n    case TargetOpcode::PSEUDO_PROBE:\n      return true;\n    }\n  }\n\n  /// Return true if this is a transient instruction that is either very likely\n  /// to be eliminated during register allocation (such as copy-like\n  /// instructions), or if this instruction doesn't have an execution-time cost.\n  bool isTransient() const {\n    switch (getOpcode()) {\n    default:\n      return isMetaInstruction();\n    // Copy-like instructions are usually eliminated during register allocation.\n    case TargetOpcode::PHI:\n    case TargetOpcode::G_PHI:\n    case TargetOpcode::COPY:\n    case TargetOpcode::INSERT_SUBREG:\n    case TargetOpcode::SUBREG_TO_REG:\n    case TargetOpcode::REG_SEQUENCE:\n      return true;\n    }\n  }\n\n  /// Return the number of instructions inside the MI bundle, excluding the\n  /// bundle header.\n  ///\n  /// This is the number of instructions that MachineBasicBlock::iterator\n  /// skips, 0 for unbundled instructions.\n  unsigned getBundleSize() const;\n\n  /// Return true if the MachineInstr reads the specified register.\n  /// If TargetRegisterInfo is passed, then it also checks if there\n  /// is a read of a super-register.\n  /// This does not count partial redefines of virtual registers as reads:\n  ///   %reg1024:6 = OP.\n  bool readsRegister(Register Reg,\n                     const TargetRegisterInfo *TRI = nullptr) const {\n    return findRegisterUseOperandIdx(Reg, false, TRI) != -1;\n  }\n\n  /// Return true if the MachineInstr reads the specified virtual register.\n  /// Take into account that a partial define is a\n  /// read-modify-write operation.\n  bool readsVirtualRegister(Register Reg) const {\n    return readsWritesVirtualRegister(Reg).first;\n  }\n\n  /// Return a pair of bools (reads, writes) indicating if this instruction\n  /// reads or writes Reg. This also considers partial defines.\n  /// If Ops is not null, all operand indices for Reg are added.\n  std::pair<bool,bool> readsWritesVirtualRegister(Register Reg,\n                                SmallVectorImpl<unsigned> *Ops = nullptr) const;\n\n  /// Return true if the MachineInstr kills the specified register.\n  /// If TargetRegisterInfo is passed, then it also checks if there is\n  /// a kill of a super-register.\n  bool killsRegister(Register Reg,\n                     const TargetRegisterInfo *TRI = nullptr) const {\n    return findRegisterUseOperandIdx(Reg, true, TRI) != -1;\n  }\n\n  /// Return true if the MachineInstr fully defines the specified register.\n  /// If TargetRegisterInfo is passed, then it also checks\n  /// if there is a def of a super-register.\n  /// NOTE: It's ignoring subreg indices on virtual registers.\n  bool definesRegister(Register Reg,\n                       const TargetRegisterInfo *TRI = nullptr) const {\n    return findRegisterDefOperandIdx(Reg, false, false, TRI) != -1;\n  }\n\n  /// Return true if the MachineInstr modifies (fully define or partially\n  /// define) the specified register.\n  /// NOTE: It's ignoring subreg indices on virtual registers.\n  bool modifiesRegister(Register Reg,\n                        const TargetRegisterInfo *TRI = nullptr) const {\n    return findRegisterDefOperandIdx(Reg, false, true, TRI) != -1;\n  }\n\n  /// Returns true if the register is dead in this machine instruction.\n  /// If TargetRegisterInfo is passed, then it also checks\n  /// if there is a dead def of a super-register.\n  bool registerDefIsDead(Register Reg,\n                         const TargetRegisterInfo *TRI = nullptr) const {\n    return findRegisterDefOperandIdx(Reg, true, false, TRI) != -1;\n  }\n\n  /// Returns true if the MachineInstr has an implicit-use operand of exactly\n  /// the given register (not considering sub/super-registers).\n  bool hasRegisterImplicitUseOperand(Register Reg) const;\n\n  /// Returns the operand index that is a use of the specific register or -1\n  /// if it is not found. It further tightens the search criteria to a use\n  /// that kills the register if isKill is true.\n  int findRegisterUseOperandIdx(Register Reg, bool isKill = false,\n                                const TargetRegisterInfo *TRI = nullptr) const;\n\n  /// Wrapper for findRegisterUseOperandIdx, it returns\n  /// a pointer to the MachineOperand rather than an index.\n  MachineOperand *findRegisterUseOperand(Register Reg, bool isKill = false,\n                                      const TargetRegisterInfo *TRI = nullptr) {\n    int Idx = findRegisterUseOperandIdx(Reg, isKill, TRI);\n    return (Idx == -1) ? nullptr : &getOperand(Idx);\n  }\n\n  const MachineOperand *findRegisterUseOperand(\n    Register Reg, bool isKill = false,\n    const TargetRegisterInfo *TRI = nullptr) const {\n    return const_cast<MachineInstr *>(this)->\n      findRegisterUseOperand(Reg, isKill, TRI);\n  }\n\n  /// Returns the operand index that is a def of the specified register or\n  /// -1 if it is not found. If isDead is true, defs that are not dead are\n  /// skipped. If Overlap is true, then it also looks for defs that merely\n  /// overlap the specified register. If TargetRegisterInfo is non-null,\n  /// then it also checks if there is a def of a super-register.\n  /// This may also return a register mask operand when Overlap is true.\n  int findRegisterDefOperandIdx(Register Reg,\n                                bool isDead = false, bool Overlap = false,\n                                const TargetRegisterInfo *TRI = nullptr) const;\n\n  /// Wrapper for findRegisterDefOperandIdx, it returns\n  /// a pointer to the MachineOperand rather than an index.\n  MachineOperand *\n  findRegisterDefOperand(Register Reg, bool isDead = false,\n                         bool Overlap = false,\n                         const TargetRegisterInfo *TRI = nullptr) {\n    int Idx = findRegisterDefOperandIdx(Reg, isDead, Overlap, TRI);\n    return (Idx == -1) ? nullptr : &getOperand(Idx);\n  }\n\n  const MachineOperand *\n  findRegisterDefOperand(Register Reg, bool isDead = false,\n                         bool Overlap = false,\n                         const TargetRegisterInfo *TRI = nullptr) const {\n    return const_cast<MachineInstr *>(this)->findRegisterDefOperand(\n        Reg, isDead, Overlap, TRI);\n  }\n\n  /// Find the index of the first operand in the\n  /// operand list that is used to represent the predicate. It returns -1 if\n  /// none is found.\n  int findFirstPredOperandIdx() const;\n\n  /// Find the index of the flag word operand that\n  /// corresponds to operand OpIdx on an inline asm instruction.  Returns -1 if\n  /// getOperand(OpIdx) does not belong to an inline asm operand group.\n  ///\n  /// If GroupNo is not NULL, it will receive the number of the operand group\n  /// containing OpIdx.\n  ///\n  /// The flag operand is an immediate that can be decoded with methods like\n  /// InlineAsm::hasRegClassConstraint().\n  int findInlineAsmFlagIdx(unsigned OpIdx, unsigned *GroupNo = nullptr) const;\n\n  /// Compute the static register class constraint for operand OpIdx.\n  /// For normal instructions, this is derived from the MCInstrDesc.\n  /// For inline assembly it is derived from the flag words.\n  ///\n  /// Returns NULL if the static register class constraint cannot be\n  /// determined.\n  const TargetRegisterClass*\n  getRegClassConstraint(unsigned OpIdx,\n                        const TargetInstrInfo *TII,\n                        const TargetRegisterInfo *TRI) const;\n\n  /// Applies the constraints (def/use) implied by this MI on \\p Reg to\n  /// the given \\p CurRC.\n  /// If \\p ExploreBundle is set and MI is part of a bundle, all the\n  /// instructions inside the bundle will be taken into account. In other words,\n  /// this method accumulates all the constraints of the operand of this MI and\n  /// the related bundle if MI is a bundle or inside a bundle.\n  ///\n  /// Returns the register class that satisfies both \\p CurRC and the\n  /// constraints set by MI. Returns NULL if such a register class does not\n  /// exist.\n  ///\n  /// \\pre CurRC must not be NULL.\n  const TargetRegisterClass *getRegClassConstraintEffectForVReg(\n      Register Reg, const TargetRegisterClass *CurRC,\n      const TargetInstrInfo *TII, const TargetRegisterInfo *TRI,\n      bool ExploreBundle = false) const;\n\n  /// Applies the constraints (def/use) implied by the \\p OpIdx operand\n  /// to the given \\p CurRC.\n  ///\n  /// Returns the register class that satisfies both \\p CurRC and the\n  /// constraints set by \\p OpIdx MI. Returns NULL if such a register class\n  /// does not exist.\n  ///\n  /// \\pre CurRC must not be NULL.\n  /// \\pre The operand at \\p OpIdx must be a register.\n  const TargetRegisterClass *\n  getRegClassConstraintEffect(unsigned OpIdx, const TargetRegisterClass *CurRC,\n                              const TargetInstrInfo *TII,\n                              const TargetRegisterInfo *TRI) const;\n\n  /// Add a tie between the register operands at DefIdx and UseIdx.\n  /// The tie will cause the register allocator to ensure that the two\n  /// operands are assigned the same physical register.\n  ///\n  /// Tied operands are managed automatically for explicit operands in the\n  /// MCInstrDesc. This method is for exceptional cases like inline asm.\n  void tieOperands(unsigned DefIdx, unsigned UseIdx);\n\n  /// Given the index of a tied register operand, find the\n  /// operand it is tied to. Defs are tied to uses and vice versa. Returns the\n  /// index of the tied operand which must exist.\n  unsigned findTiedOperandIdx(unsigned OpIdx) const;\n\n  /// Given the index of a register def operand,\n  /// check if the register def is tied to a source operand, due to either\n  /// two-address elimination or inline assembly constraints. Returns the\n  /// first tied use operand index by reference if UseOpIdx is not null.\n  bool isRegTiedToUseOperand(unsigned DefOpIdx,\n                             unsigned *UseOpIdx = nullptr) const {\n    const MachineOperand &MO = getOperand(DefOpIdx);\n    if (!MO.isReg() || !MO.isDef() || !MO.isTied())\n      return false;\n    if (UseOpIdx)\n      *UseOpIdx = findTiedOperandIdx(DefOpIdx);\n    return true;\n  }\n\n  /// Return true if the use operand of the specified index is tied to a def\n  /// operand. It also returns the def operand index by reference if DefOpIdx\n  /// is not null.\n  bool isRegTiedToDefOperand(unsigned UseOpIdx,\n                             unsigned *DefOpIdx = nullptr) const {\n    const MachineOperand &MO = getOperand(UseOpIdx);\n    if (!MO.isReg() || !MO.isUse() || !MO.isTied())\n      return false;\n    if (DefOpIdx)\n      *DefOpIdx = findTiedOperandIdx(UseOpIdx);\n    return true;\n  }\n\n  /// Clears kill flags on all operands.\n  void clearKillInfo();\n\n  /// Replace all occurrences of FromReg with ToReg:SubIdx,\n  /// properly composing subreg indices where necessary.\n  void substituteRegister(Register FromReg, Register ToReg, unsigned SubIdx,\n                          const TargetRegisterInfo &RegInfo);\n\n  /// We have determined MI kills a register. Look for the\n  /// operand that uses it and mark it as IsKill. If AddIfNotFound is true,\n  /// add a implicit operand if it's not found. Returns true if the operand\n  /// exists / is added.\n  bool addRegisterKilled(Register IncomingReg,\n                         const TargetRegisterInfo *RegInfo,\n                         bool AddIfNotFound = false);\n\n  /// Clear all kill flags affecting Reg.  If RegInfo is provided, this includes\n  /// all aliasing registers.\n  void clearRegisterKills(Register Reg, const TargetRegisterInfo *RegInfo);\n\n  /// We have determined MI defined a register without a use.\n  /// Look for the operand that defines it and mark it as IsDead. If\n  /// AddIfNotFound is true, add a implicit operand if it's not found. Returns\n  /// true if the operand exists / is added.\n  bool addRegisterDead(Register Reg, const TargetRegisterInfo *RegInfo,\n                       bool AddIfNotFound = false);\n\n  /// Clear all dead flags on operands defining register @p Reg.\n  void clearRegisterDeads(Register Reg);\n\n  /// Mark all subregister defs of register @p Reg with the undef flag.\n  /// This function is used when we determined to have a subregister def in an\n  /// otherwise undefined super register.\n  void setRegisterDefReadUndef(Register Reg, bool IsUndef = true);\n\n  /// We have determined MI defines a register. Make sure there is an operand\n  /// defining Reg.\n  void addRegisterDefined(Register Reg,\n                          const TargetRegisterInfo *RegInfo = nullptr);\n\n  /// Mark every physreg used by this instruction as\n  /// dead except those in the UsedRegs list.\n  ///\n  /// On instructions with register mask operands, also add implicit-def\n  /// operands for all registers in UsedRegs.\n  void setPhysRegsDeadExcept(ArrayRef<Register> UsedRegs,\n                             const TargetRegisterInfo &TRI);\n\n  /// Return true if it is safe to move this instruction. If\n  /// SawStore is set to true, it means that there is a store (or call) between\n  /// the instruction's location and its intended destination.\n  bool isSafeToMove(AAResults *AA, bool &SawStore) const;\n\n  /// Returns true if this instruction's memory access aliases the memory\n  /// access of Other.\n  //\n  /// Assumes any physical registers used to compute addresses\n  /// have the same value for both instructions.  Returns false if neither\n  /// instruction writes to memory.\n  ///\n  /// @param AA Optional alias analysis, used to compare memory operands.\n  /// @param Other MachineInstr to check aliasing against.\n  /// @param UseTBAA Whether to pass TBAA information to alias analysis.\n  bool mayAlias(AAResults *AA, const MachineInstr &Other, bool UseTBAA) const;\n\n  /// Return true if this instruction may have an ordered\n  /// or volatile memory reference, or if the information describing the memory\n  /// reference is not available. Return false if it is known to have no\n  /// ordered or volatile memory references.\n  bool hasOrderedMemoryRef() const;\n\n  /// Return true if this load instruction never traps and points to a memory\n  /// location whose value doesn't change during the execution of this function.\n  ///\n  /// Examples include loading a value from the constant pool or from the\n  /// argument area of a function (if it does not change).  If the instruction\n  /// does multiple loads, this returns true only if all of the loads are\n  /// dereferenceable and invariant.\n  bool isDereferenceableInvariantLoad(AAResults *AA) const;\n\n  /// If the specified instruction is a PHI that always merges together the\n  /// same virtual register, return the register, otherwise return 0.\n  unsigned isConstantValuePHI() const;\n\n  /// Return true if this instruction has side effects that are not modeled\n  /// by mayLoad / mayStore, etc.\n  /// For all instructions, the property is encoded in MCInstrDesc::Flags\n  /// (see MCInstrDesc::hasUnmodeledSideEffects(). The only exception is\n  /// INLINEASM instruction, in which case the side effect property is encoded\n  /// in one of its operands (see InlineAsm::Extra_HasSideEffect).\n  ///\n  bool hasUnmodeledSideEffects() const;\n\n  /// Returns true if it is illegal to fold a load across this instruction.\n  bool isLoadFoldBarrier() const;\n\n  /// Return true if all the defs of this instruction are dead.\n  bool allDefsAreDead() const;\n\n  /// Return a valid size if the instruction is a spill instruction.\n  Optional<unsigned> getSpillSize(const TargetInstrInfo *TII) const;\n\n  /// Return a valid size if the instruction is a folded spill instruction.\n  Optional<unsigned> getFoldedSpillSize(const TargetInstrInfo *TII) const;\n\n  /// Return a valid size if the instruction is a restore instruction.\n  Optional<unsigned> getRestoreSize(const TargetInstrInfo *TII) const;\n\n  /// Return a valid size if the instruction is a folded restore instruction.\n  Optional<unsigned>\n  getFoldedRestoreSize(const TargetInstrInfo *TII) const;\n\n  /// Copy implicit register operands from specified\n  /// instruction to this instruction.\n  void copyImplicitOps(MachineFunction &MF, const MachineInstr &MI);\n\n  /// Debugging support\n  /// @{\n  /// Determine the generic type to be printed (if needed) on uses and defs.\n  LLT getTypeToPrint(unsigned OpIdx, SmallBitVector &PrintedTypes,\n                     const MachineRegisterInfo &MRI) const;\n\n  /// Return true when an instruction has tied register that can't be determined\n  /// by the instruction's descriptor. This is useful for MIR printing, to\n  /// determine whether we need to print the ties or not.\n  bool hasComplexRegisterTies() const;\n\n  /// Print this MI to \\p OS.\n  /// Don't print information that can be inferred from other instructions if\n  /// \\p IsStandalone is false. It is usually true when only a fragment of the\n  /// function is printed.\n  /// Only print the defs and the opcode if \\p SkipOpers is true.\n  /// Otherwise, also print operands if \\p SkipDebugLoc is true.\n  /// Otherwise, also print the debug loc, with a terminating newline.\n  /// \\p TII is used to print the opcode name.  If it's not present, but the\n  /// MI is in a function, the opcode will be printed using the function's TII.\n  void print(raw_ostream &OS, bool IsStandalone = true, bool SkipOpers = false,\n             bool SkipDebugLoc = false, bool AddNewLine = true,\n             const TargetInstrInfo *TII = nullptr) const;\n  void print(raw_ostream &OS, ModuleSlotTracker &MST, bool IsStandalone = true,\n             bool SkipOpers = false, bool SkipDebugLoc = false,\n             bool AddNewLine = true,\n             const TargetInstrInfo *TII = nullptr) const;\n  void dump() const;\n  /// Print on dbgs() the current instruction and the instructions defining its\n  /// operands and so on until we reach \\p MaxDepth.\n  void dumpr(const MachineRegisterInfo &MRI,\n             unsigned MaxDepth = UINT_MAX) const;\n  /// @}\n\n  //===--------------------------------------------------------------------===//\n  // Accessors used to build up machine instructions.\n\n  /// Add the specified operand to the instruction.  If it is an implicit\n  /// operand, it is added to the end of the operand list.  If it is an\n  /// explicit operand it is added at the end of the explicit operand list\n  /// (before the first implicit operand).\n  ///\n  /// MF must be the machine function that was used to allocate this\n  /// instruction.\n  ///\n  /// MachineInstrBuilder provides a more convenient interface for creating\n  /// instructions and adding operands.\n  void addOperand(MachineFunction &MF, const MachineOperand &Op);\n\n  /// Add an operand without providing an MF reference. This only works for\n  /// instructions that are inserted in a basic block.\n  ///\n  /// MachineInstrBuilder and the two-argument addOperand(MF, MO) should be\n  /// preferred.\n  void addOperand(const MachineOperand &Op);\n\n  /// Replace the instruction descriptor (thus opcode) of\n  /// the current instruction with a new one.\n  void setDesc(const MCInstrDesc &tid) { MCID = &tid; }\n\n  /// Replace current source information with new such.\n  /// Avoid using this, the constructor argument is preferable.\n  void setDebugLoc(DebugLoc dl) {\n    debugLoc = std::move(dl);\n    assert(debugLoc.hasTrivialDestructor() && \"Expected trivial destructor\");\n  }\n\n  /// Erase an operand from an instruction, leaving it with one\n  /// fewer operand than it started with.\n  void RemoveOperand(unsigned OpNo);\n\n  /// Clear this MachineInstr's memory reference descriptor list.  This resets\n  /// the memrefs to their most conservative state.  This should be used only\n  /// as a last resort since it greatly pessimizes our knowledge of the memory\n  /// access performed by the instruction.\n  void dropMemRefs(MachineFunction &MF);\n\n  /// Assign this MachineInstr's memory reference descriptor list.\n  ///\n  /// Unlike other methods, this *will* allocate them into a new array\n  /// associated with the provided `MachineFunction`.\n  void setMemRefs(MachineFunction &MF, ArrayRef<MachineMemOperand *> MemRefs);\n\n  /// Add a MachineMemOperand to the machine instruction.\n  /// This function should be used only occasionally. The setMemRefs function\n  /// is the primary method for setting up a MachineInstr's MemRefs list.\n  void addMemOperand(MachineFunction &MF, MachineMemOperand *MO);\n\n  /// Clone another MachineInstr's memory reference descriptor list and replace\n  /// ours with it.\n  ///\n  /// Note that `*this` may be the incoming MI!\n  ///\n  /// Prefer this API whenever possible as it can avoid allocations in common\n  /// cases.\n  void cloneMemRefs(MachineFunction &MF, const MachineInstr &MI);\n\n  /// Clone the merge of multiple MachineInstrs' memory reference descriptors\n  /// list and replace ours with it.\n  ///\n  /// Note that `*this` may be one of the incoming MIs!\n  ///\n  /// Prefer this API whenever possible as it can avoid allocations in common\n  /// cases.\n  void cloneMergedMemRefs(MachineFunction &MF,\n                          ArrayRef<const MachineInstr *> MIs);\n\n  /// Set a symbol that will be emitted just prior to the instruction itself.\n  ///\n  /// Setting this to a null pointer will remove any such symbol.\n  ///\n  /// FIXME: This is not fully implemented yet.\n  void setPreInstrSymbol(MachineFunction &MF, MCSymbol *Symbol);\n\n  /// Set a symbol that will be emitted just after the instruction itself.\n  ///\n  /// Setting this to a null pointer will remove any such symbol.\n  ///\n  /// FIXME: This is not fully implemented yet.\n  void setPostInstrSymbol(MachineFunction &MF, MCSymbol *Symbol);\n\n  /// Clone another MachineInstr's pre- and post- instruction symbols and\n  /// replace ours with it.\n  void cloneInstrSymbols(MachineFunction &MF, const MachineInstr &MI);\n\n  /// Set a marker on instructions that denotes where we should create and emit\n  /// heap alloc site labels. This waits until after instruction selection and\n  /// optimizations to create the label, so it should still work if the\n  /// instruction is removed or duplicated.\n  void setHeapAllocMarker(MachineFunction &MF, MDNode *MD);\n\n  /// Return the MIFlags which represent both MachineInstrs. This\n  /// should be used when merging two MachineInstrs into one. This routine does\n  /// not modify the MIFlags of this MachineInstr.\n  uint16_t mergeFlagsWith(const MachineInstr& Other) const;\n\n  static uint16_t copyFlagsFromInstruction(const Instruction &I);\n\n  /// Copy all flags to MachineInst MIFlags\n  void copyIRFlags(const Instruction &I);\n\n  /// Break any tie involving OpIdx.\n  void untieRegOperand(unsigned OpIdx) {\n    MachineOperand &MO = getOperand(OpIdx);\n    if (MO.isReg() && MO.isTied()) {\n      getOperand(findTiedOperandIdx(OpIdx)).TiedTo = 0;\n      MO.TiedTo = 0;\n    }\n  }\n\n  /// Add all implicit def and use operands to this instruction.\n  void addImplicitDefUseOperands(MachineFunction &MF);\n\n  /// Scan instructions immediately following MI and collect any matching\n  /// DBG_VALUEs.\n  void collectDebugValues(SmallVectorImpl<MachineInstr *> &DbgValues);\n\n  /// Find all DBG_VALUEs that point to the register def in this instruction\n  /// and point them to \\p Reg instead.\n  void changeDebugValuesDefReg(Register Reg);\n\n  /// Returns the Intrinsic::ID for this instruction.\n  /// \\pre Must have an intrinsic ID operand.\n  unsigned getIntrinsicID() const {\n    return getOperand(getNumExplicitDefs()).getIntrinsicID();\n  }\n\n  /// Sets all register debug operands in this debug value instruction to be\n  /// undef.\n  void setDebugValueUndef() {\n    assert(isDebugValue() && \"Must be a debug value instruction.\");\n    for (MachineOperand &MO : debug_operands()) {\n      if (MO.isReg()) {\n        MO.setReg(0);\n        MO.setSubReg(0);\n      }\n    }\n  }\n\n  PseudoProbeAttributes getPseudoProbeAttribute() const {\n    assert(isPseudoProbe() && \"Must be a pseudo probe instruction\");\n    return (PseudoProbeAttributes)getOperand(3).getImm();\n  }\n\n  void addPseudoProbeAttribute(PseudoProbeAttributes Attr) {\n    assert(isPseudoProbe() && \"Must be a pseudo probe instruction\");\n    MachineOperand &AttrOperand = getOperand(3);\n    AttrOperand.setImm(AttrOperand.getImm() | (uint32_t)Attr);\n  }\n\nprivate:\n  /// If this instruction is embedded into a MachineFunction, return the\n  /// MachineRegisterInfo object for the current function, otherwise\n  /// return null.\n  MachineRegisterInfo *getRegInfo();\n\n  /// Unlink all of the register operands in this instruction from their\n  /// respective use lists.  This requires that the operands already be on their\n  /// use lists.\n  void RemoveRegOperandsFromUseLists(MachineRegisterInfo&);\n\n  /// Add all of the register operands in this instruction from their\n  /// respective use lists.  This requires that the operands not be on their\n  /// use lists yet.\n  void AddRegOperandsToUseLists(MachineRegisterInfo&);\n\n  /// Slow path for hasProperty when we're dealing with a bundle.\n  bool hasPropertyInBundle(uint64_t Mask, QueryType Type) const;\n\n  /// Implements the logic of getRegClassConstraintEffectForVReg for the\n  /// this MI and the given operand index \\p OpIdx.\n  /// If the related operand does not constrained Reg, this returns CurRC.\n  const TargetRegisterClass *getRegClassConstraintEffectForVRegImpl(\n      unsigned OpIdx, Register Reg, const TargetRegisterClass *CurRC,\n      const TargetInstrInfo *TII, const TargetRegisterInfo *TRI) const;\n\n  /// Stores extra instruction information inline or allocates as ExtraInfo\n  /// based on the number of pointers.\n  void setExtraInfo(MachineFunction &MF, ArrayRef<MachineMemOperand *> MMOs,\n                    MCSymbol *PreInstrSymbol, MCSymbol *PostInstrSymbol,\n                    MDNode *HeapAllocMarker);\n};\n\n/// Special DenseMapInfo traits to compare MachineInstr* by *value* of the\n/// instruction rather than by pointer value.\n/// The hashing and equality testing functions ignore definitions so this is\n/// useful for CSE, etc.\nstruct MachineInstrExpressionTrait : DenseMapInfo<MachineInstr*> {\n  static inline MachineInstr *getEmptyKey() {\n    return nullptr;\n  }\n\n  static inline MachineInstr *getTombstoneKey() {\n    return reinterpret_cast<MachineInstr*>(-1);\n  }\n\n  static unsigned getHashValue(const MachineInstr* const &MI);\n\n  static bool isEqual(const MachineInstr* const &LHS,\n                      const MachineInstr* const &RHS) {\n    if (RHS == getEmptyKey() || RHS == getTombstoneKey() ||\n        LHS == getEmptyKey() || LHS == getTombstoneKey())\n      return LHS == RHS;\n    return LHS->isIdenticalTo(*RHS, MachineInstr::IgnoreVRegDefs);\n  }\n};\n\n//===----------------------------------------------------------------------===//\n// Debugging Support\n\ninline raw_ostream& operator<<(raw_ostream &OS, const MachineInstr &MI) {\n  MI.print(OS);\n  return OS;\n}\n\n} // end namespace llvm\n\n#endif // LLVM_CODEGEN_MACHINEINSTR_H\n"}, "29": {"id": 29, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/CodeGen/MachineMemOperand.h", "content": "//==- llvm/CodeGen/MachineMemOperand.h - MachineMemOperand class -*- C++ -*-==//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// This file contains the declaration of the MachineMemOperand class, which is a\n// description of a memory reference. It is used to help track dependencies\n// in the backend.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_CODEGEN_MACHINEMEMOPERAND_H\n#define LLVM_CODEGEN_MACHINEMEMOPERAND_H\n\n#include \"llvm/ADT/BitmaskEnum.h\"\n#include \"llvm/ADT/PointerUnion.h\"\n#include \"llvm/CodeGen/PseudoSourceValue.h\"\n#include \"llvm/IR/DerivedTypes.h\"\n#include \"llvm/IR/Value.h\" // PointerLikeTypeTraits<Value*>\n#include \"llvm/Support/AtomicOrdering.h\"\n#include \"llvm/Support/DataTypes.h\"\n\nnamespace llvm {\n\nclass FoldingSetNodeID;\nclass MDNode;\nclass raw_ostream;\nclass MachineFunction;\nclass ModuleSlotTracker;\n\n/// This class contains a discriminated union of information about pointers in\n/// memory operands, relating them back to LLVM IR or to virtual locations (such\n/// as frame indices) that are exposed during codegen.\nstruct MachinePointerInfo {\n  /// This is the IR pointer value for the access, or it is null if unknown.\n  /// If this is null, then the access is to a pointer in the default address\n  /// space.\n  PointerUnion<const Value *, const PseudoSourceValue *> V;\n\n  /// Offset - This is an offset from the base Value*.\n  int64_t Offset;\n\n  uint8_t StackID;\n\n  unsigned AddrSpace = 0;\n\n  explicit MachinePointerInfo(const Value *v, int64_t offset = 0,\n                              uint8_t ID = 0)\n      : V(v), Offset(offset), StackID(ID) {\n    AddrSpace = v ? v->getType()->getPointerAddressSpace() : 0;\n  }\n\n  explicit MachinePointerInfo(const PseudoSourceValue *v, int64_t offset = 0,\n                              uint8_t ID = 0)\n      : V(v), Offset(offset), StackID(ID) {\n    AddrSpace = v ? v->getAddressSpace() : 0;\n  }\n\n  explicit MachinePointerInfo(unsigned AddressSpace = 0, int64_t offset = 0)\n      : V((const Value *)nullptr), Offset(offset), StackID(0),\n        AddrSpace(AddressSpace) {}\n\n  explicit MachinePointerInfo(\n    PointerUnion<const Value *, const PseudoSourceValue *> v,\n    int64_t offset = 0,\n    uint8_t ID = 0)\n    : V(v), Offset(offset), StackID(ID) {\n    if (V) {\n      if (const auto *ValPtr = V.dyn_cast<const Value*>())\n        AddrSpace = ValPtr->getType()->getPointerAddressSpace();\n      else\n        AddrSpace = V.get<const PseudoSourceValue*>()->getAddressSpace();\n    }\n  }\n\n  MachinePointerInfo getWithOffset(int64_t O) const {\n    if (V.isNull())\n      return MachinePointerInfo(AddrSpace, Offset + O);\n    if (V.is<const Value*>())\n      return MachinePointerInfo(V.get<const Value*>(), Offset + O, StackID);\n    return MachinePointerInfo(V.get<const PseudoSourceValue*>(), Offset + O,\n                              StackID);\n  }\n\n  /// Return true if memory region [V, V+Offset+Size) is known to be\n  /// dereferenceable.\n  bool isDereferenceable(unsigned Size, LLVMContext &C,\n                         const DataLayout &DL) const;\n\n  /// Return the LLVM IR address space number that this pointer points into.\n  unsigned getAddrSpace() const;\n\n  /// Return a MachinePointerInfo record that refers to the constant pool.\n  static MachinePointerInfo getConstantPool(MachineFunction &MF);\n\n  /// Return a MachinePointerInfo record that refers to the specified\n  /// FrameIndex.\n  static MachinePointerInfo getFixedStack(MachineFunction &MF, int FI,\n                                          int64_t Offset = 0);\n\n  /// Return a MachinePointerInfo record that refers to a jump table entry.\n  static MachinePointerInfo getJumpTable(MachineFunction &MF);\n\n  /// Return a MachinePointerInfo record that refers to a GOT entry.\n  static MachinePointerInfo getGOT(MachineFunction &MF);\n\n  /// Stack pointer relative access.\n  static MachinePointerInfo getStack(MachineFunction &MF, int64_t Offset,\n                                     uint8_t ID = 0);\n\n  /// Stack memory without other information.\n  static MachinePointerInfo getUnknownStack(MachineFunction &MF);\n};\n\n\n//===----------------------------------------------------------------------===//\n/// A description of a memory reference used in the backend.\n/// Instead of holding a StoreInst or LoadInst, this class holds the address\n/// Value of the reference along with a byte size and offset. This allows it\n/// to describe lowered loads and stores. Also, the special PseudoSourceValue\n/// objects can be used to represent loads and stores to memory locations\n/// that aren't explicit in the regular LLVM IR.\n///\nclass MachineMemOperand {\npublic:\n  /// Flags values. These may be or'd together.\n  enum Flags : uint16_t {\n    // No flags set.\n    MONone = 0,\n    /// The memory access reads data.\n    MOLoad = 1u << 0,\n    /// The memory access writes data.\n    MOStore = 1u << 1,\n    /// The memory access is volatile.\n    MOVolatile = 1u << 2,\n    /// The memory access is non-temporal.\n    MONonTemporal = 1u << 3,\n    /// The memory access is dereferenceable (i.e., doesn't trap).\n    MODereferenceable = 1u << 4,\n    /// The memory access always returns the same value (or traps).\n    MOInvariant = 1u << 5,\n\n    // Reserved for use by target-specific passes.\n    // Targets may override getSerializableMachineMemOperandTargetFlags() to\n    // enable MIR serialization/parsing of these flags.  If more of these flags\n    // are added, the MIR printing/parsing code will need to be updated as well.\n    MOTargetFlag1 = 1u << 6,\n    MOTargetFlag2 = 1u << 7,\n    MOTargetFlag3 = 1u << 8,\n\n    LLVM_MARK_AS_BITMASK_ENUM(/* LargestFlag = */ MOTargetFlag3)\n  };\n\nprivate:\n  /// Atomic information for this memory operation.\n  struct MachineAtomicInfo {\n    /// Synchronization scope ID for this memory operation.\n    unsigned SSID : 8;            // SyncScope::ID\n    /// Atomic ordering requirements for this memory operation. For cmpxchg\n    /// atomic operations, atomic ordering requirements when store occurs.\n    unsigned Ordering : 4;        // enum AtomicOrdering\n    /// For cmpxchg atomic operations, atomic ordering requirements when store\n    /// does not occur.\n    unsigned FailureOrdering : 4; // enum AtomicOrdering\n  };\n\n  MachinePointerInfo PtrInfo;\n  uint64_t Size;\n  Flags FlagVals;\n  Align BaseAlign;\n  MachineAtomicInfo AtomicInfo;\n  AAMDNodes AAInfo;\n  const MDNode *Ranges;\n\npublic:\n  /// Construct a MachineMemOperand object with the specified PtrInfo, flags,\n  /// size, and base alignment. For atomic operations the synchronization scope\n  /// and atomic ordering requirements must also be specified. For cmpxchg\n  /// atomic operations the atomic ordering requirements when store does not\n  /// occur must also be specified.\n  MachineMemOperand(MachinePointerInfo PtrInfo, Flags flags, uint64_t s,\n                    Align a, const AAMDNodes &AAInfo = AAMDNodes(),\n                    const MDNode *Ranges = nullptr,\n                    SyncScope::ID SSID = SyncScope::System,\n                    AtomicOrdering Ordering = AtomicOrdering::NotAtomic,\n                    AtomicOrdering FailureOrdering = AtomicOrdering::NotAtomic);\n\n  const MachinePointerInfo &getPointerInfo() const { return PtrInfo; }\n\n  /// Return the base address of the memory access. This may either be a normal\n  /// LLVM IR Value, or one of the special values used in CodeGen.\n  /// Special values are those obtained via\n  /// PseudoSourceValue::getFixedStack(int), PseudoSourceValue::getStack, and\n  /// other PseudoSourceValue member functions which return objects which stand\n  /// for frame/stack pointer relative references and other special references\n  /// which are not representable in the high-level IR.\n  const Value *getValue() const { return PtrInfo.V.dyn_cast<const Value*>(); }\n\n  const PseudoSourceValue *getPseudoValue() const {\n    return PtrInfo.V.dyn_cast<const PseudoSourceValue*>();\n  }\n\n  const void *getOpaqueValue() const { return PtrInfo.V.getOpaqueValue(); }\n\n  /// Return the raw flags of the source value, \\see Flags.\n  Flags getFlags() const { return FlagVals; }\n\n  /// Bitwise OR the current flags with the given flags.\n  void setFlags(Flags f) { FlagVals |= f; }\n\n  /// For normal values, this is a byte offset added to the base address.\n  /// For PseudoSourceValue::FPRel values, this is the FrameIndex number.\n  int64_t getOffset() const { return PtrInfo.Offset; }\n\n  unsigned getAddrSpace() const { return PtrInfo.getAddrSpace(); }\n\n  /// Return the size in bytes of the memory reference.\n  uint64_t getSize() const { return Size; }\n\n  /// Return the size in bits of the memory reference.\n  uint64_t getSizeInBits() const { return Size * 8; }\n\n  LLVM_ATTRIBUTE_DEPRECATED(uint64_t getAlignment() const,\n                            \"Use getAlign instead\");\n\n  /// Return the minimum known alignment in bytes of the actual memory\n  /// reference.\n  Align getAlign() const;\n\n  LLVM_ATTRIBUTE_DEPRECATED(uint64_t getBaseAlignment() const,\n                            \"Use getBaseAlign instead\") {\n    return BaseAlign.value();\n  }\n\n  /// Return the minimum known alignment in bytes of the base address, without\n  /// the offset.\n  Align getBaseAlign() const { return BaseAlign; }\n\n  /// Return the AA tags for the memory reference.\n  AAMDNodes getAAInfo() const { return AAInfo; }\n\n  /// Return the range tag for the memory reference.\n  const MDNode *getRanges() const { return Ranges; }\n\n  /// Returns the synchronization scope ID for this memory operation.\n  SyncScope::ID getSyncScopeID() const {\n    return static_cast<SyncScope::ID>(AtomicInfo.SSID);\n  }\n\n  /// Return the atomic ordering requirements for this memory operation. For\n  /// cmpxchg atomic operations, return the atomic ordering requirements when\n  /// store occurs.\n  AtomicOrdering getOrdering() const {\n    return static_cast<AtomicOrdering>(AtomicInfo.Ordering);\n  }\n\n  /// For cmpxchg atomic operations, return the atomic ordering requirements\n  /// when store does not occur.\n  AtomicOrdering getFailureOrdering() const {\n    return static_cast<AtomicOrdering>(AtomicInfo.FailureOrdering);\n  }\n\n  bool isLoad() const { return FlagVals & MOLoad; }\n  bool isStore() const { return FlagVals & MOStore; }\n  bool isVolatile() const { return FlagVals & MOVolatile; }\n  bool isNonTemporal() const { return FlagVals & MONonTemporal; }\n  bool isDereferenceable() const { return FlagVals & MODereferenceable; }\n  bool isInvariant() const { return FlagVals & MOInvariant; }\n\n  /// Returns true if this operation has an atomic ordering requirement of\n  /// unordered or higher, false otherwise.\n  bool isAtomic() const { return getOrdering() != AtomicOrdering::NotAtomic; }\n\n  /// Returns true if this memory operation doesn't have any ordering\n  /// constraints other than normal aliasing. Volatile and (ordered) atomic\n  /// memory operations can't be reordered. \n  bool isUnordered() const {\n    return (getOrdering() == AtomicOrdering::NotAtomic ||\n            getOrdering() == AtomicOrdering::Unordered) &&\n           !isVolatile();\n  }\n\n  /// Update this MachineMemOperand to reflect the alignment of MMO, if it has a\n  /// greater alignment. This must only be used when the new alignment applies\n  /// to all users of this MachineMemOperand.\n  void refineAlignment(const MachineMemOperand *MMO);\n\n  /// Change the SourceValue for this MachineMemOperand. This should only be\n  /// used when an object is being relocated and all references to it are being\n  /// updated.\n  void setValue(const Value *NewSV) { PtrInfo.V = NewSV; }\n  void setValue(const PseudoSourceValue *NewSV) { PtrInfo.V = NewSV; }\n  void setOffset(int64_t NewOffset) { PtrInfo.Offset = NewOffset; }\n\n  /// Profile - Gather unique data for the object.\n  ///\n  void Profile(FoldingSetNodeID &ID) const;\n\n  /// Support for operator<<.\n  /// @{\n  void print(raw_ostream &OS, ModuleSlotTracker &MST,\n             SmallVectorImpl<StringRef> &SSNs, const LLVMContext &Context,\n             const MachineFrameInfo *MFI, const TargetInstrInfo *TII) const;\n  /// @}\n\n  friend bool operator==(const MachineMemOperand &LHS,\n                         const MachineMemOperand &RHS) {\n    return LHS.getValue() == RHS.getValue() &&\n           LHS.getPseudoValue() == RHS.getPseudoValue() &&\n           LHS.getSize() == RHS.getSize() &&\n           LHS.getOffset() == RHS.getOffset() &&\n           LHS.getFlags() == RHS.getFlags() &&\n           LHS.getAAInfo() == RHS.getAAInfo() &&\n           LHS.getRanges() == RHS.getRanges() &&\n           LHS.getAlign() == RHS.getAlign() &&\n           LHS.getAddrSpace() == RHS.getAddrSpace();\n  }\n\n  friend bool operator!=(const MachineMemOperand &LHS,\n                         const MachineMemOperand &RHS) {\n    return !(LHS == RHS);\n  }\n};\n\n} // End llvm namespace\n\n#endif\n"}, "30": {"id": 30, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/CodeGen/MachineOperand.h", "content": "//===-- llvm/CodeGen/MachineOperand.h - MachineOperand class ----*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// This file contains the declaration of the MachineOperand class.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_CODEGEN_MACHINEOPERAND_H\n#define LLVM_CODEGEN_MACHINEOPERAND_H\n\n#include \"llvm/ADT/DenseMap.h\"\n#include \"llvm/CodeGen/Register.h\"\n#include \"llvm/IR/Intrinsics.h\"\n#include \"llvm/Support/DataTypes.h\"\n#include \"llvm/Support/LowLevelTypeImpl.h\"\n#include <cassert>\n\nnamespace llvm {\n\nclass BlockAddress;\nclass Constant;\nclass ConstantFP;\nclass ConstantInt;\nclass GlobalValue;\nclass MachineBasicBlock;\nclass MachineInstr;\nclass MachineRegisterInfo;\nclass MCCFIInstruction;\nclass MDNode;\nclass ModuleSlotTracker;\nclass TargetIntrinsicInfo;\nclass TargetRegisterInfo;\nclass hash_code;\nclass raw_ostream;\nclass MCSymbol;\n\n/// MachineOperand class - Representation of each machine instruction operand.\n///\n/// This class isn't a POD type because it has a private constructor, but its\n/// destructor must be trivial. Functions like MachineInstr::addOperand(),\n/// MachineRegisterInfo::moveOperands(), and MF::DeleteMachineInstr() depend on\n/// not having to call the MachineOperand destructor.\n///\nclass MachineOperand {\npublic:\n  enum MachineOperandType : unsigned char {\n    MO_Register,          ///< Register operand.\n    MO_Immediate,         ///< Immediate operand\n    MO_CImmediate,        ///< Immediate >64bit operand\n    MO_FPImmediate,       ///< Floating-point immediate operand\n    MO_MachineBasicBlock, ///< MachineBasicBlock reference\n    MO_FrameIndex,        ///< Abstract Stack Frame Index\n    MO_ConstantPoolIndex, ///< Address of indexed Constant in Constant Pool\n    MO_TargetIndex,       ///< Target-dependent index+offset operand.\n    MO_JumpTableIndex,    ///< Address of indexed Jump Table for switch\n    MO_ExternalSymbol,    ///< Name of external global symbol\n    MO_GlobalAddress,     ///< Address of a global value\n    MO_BlockAddress,      ///< Address of a basic block\n    MO_RegisterMask,      ///< Mask of preserved registers.\n    MO_RegisterLiveOut,   ///< Mask of live-out registers.\n    MO_Metadata,          ///< Metadata reference (for debug info)\n    MO_MCSymbol,          ///< MCSymbol reference (for debug/eh info)\n    MO_CFIIndex,          ///< MCCFIInstruction index.\n    MO_IntrinsicID,       ///< Intrinsic ID for ISel\n    MO_Predicate,         ///< Generic predicate for ISel\n    MO_ShuffleMask,       ///< Other IR Constant for ISel (shuffle masks)\n    MO_Last = MO_ShuffleMask\n  };\n\nprivate:\n  /// OpKind - Specify what kind of operand this is.  This discriminates the\n  /// union.\n  unsigned OpKind : 8;\n\n  /// Subregister number for MO_Register.  A value of 0 indicates the\n  /// MO_Register has no subReg.\n  ///\n  /// For all other kinds of operands, this field holds target-specific flags.\n  unsigned SubReg_TargetFlags : 12;\n\n  /// TiedTo - Non-zero when this register operand is tied to another register\n  /// operand. The encoding of this field is described in the block comment\n  /// before MachineInstr::tieOperands().\n  unsigned TiedTo : 4;\n\n  /// IsDef - True if this is a def, false if this is a use of the register.\n  /// This is only valid on register operands.\n  ///\n  unsigned IsDef : 1;\n\n  /// IsImp - True if this is an implicit def or use, false if it is explicit.\n  /// This is only valid on register opderands.\n  ///\n  unsigned IsImp : 1;\n\n  /// IsDeadOrKill\n  /// For uses: IsKill - True if this instruction is the last use of the\n  /// register on this path through the function.\n  /// For defs: IsDead - True if this register is never used by a subsequent\n  /// instruction.\n  /// This is only valid on register operands.\n  unsigned IsDeadOrKill : 1;\n\n  /// See isRenamable().\n  unsigned IsRenamable : 1;\n\n  /// IsUndef - True if this register operand reads an \"undef\" value, i.e. the\n  /// read value doesn't matter.  This flag can be set on both use and def\n  /// operands.  On a sub-register def operand, it refers to the part of the\n  /// register that isn't written.  On a full-register def operand, it is a\n  /// noop.  See readsReg().\n  ///\n  /// This is only valid on registers.\n  ///\n  /// Note that an instruction may have multiple <undef> operands referring to\n  /// the same register.  In that case, the instruction may depend on those\n  /// operands reading the same dont-care value.  For example:\n  ///\n  ///   %1 = XOR undef %2, undef %2\n  ///\n  /// Any register can be used for %2, and its value doesn't matter, but\n  /// the two operands must be the same register.\n  ///\n  unsigned IsUndef : 1;\n\n  /// IsInternalRead - True if this operand reads a value that was defined\n  /// inside the same instruction or bundle.  This flag can be set on both use\n  /// and def operands.  On a sub-register def operand, it refers to the part\n  /// of the register that isn't written.  On a full-register def operand, it\n  /// is a noop.\n  ///\n  /// When this flag is set, the instruction bundle must contain at least one\n  /// other def of the register.  If multiple instructions in the bundle define\n  /// the register, the meaning is target-defined.\n  unsigned IsInternalRead : 1;\n\n  /// IsEarlyClobber - True if this MO_Register 'def' operand is written to\n  /// by the MachineInstr before all input registers are read.  This is used to\n  /// model the GCC inline asm '&' constraint modifier.\n  unsigned IsEarlyClobber : 1;\n\n  /// IsDebug - True if this MO_Register 'use' operand is in a debug pseudo,\n  /// not a real instruction.  Such uses should be ignored during codegen.\n  unsigned IsDebug : 1;\n\n  /// SmallContents - This really should be part of the Contents union, but\n  /// lives out here so we can get a better packed struct.\n  /// MO_Register: Register number.\n  /// OffsetedInfo: Low bits of offset.\n  union {\n    unsigned RegNo;           // For MO_Register.\n    unsigned OffsetLo;        // Matches Contents.OffsetedInfo.OffsetHi.\n  } SmallContents;\n\n  /// ParentMI - This is the instruction that this operand is embedded into.\n  /// This is valid for all operand types, when the operand is in an instr.\n  MachineInstr *ParentMI;\n\n  /// Contents union - This contains the payload for the various operand types.\n  union ContentsUnion {\n    ContentsUnion() {}\n    MachineBasicBlock *MBB;  // For MO_MachineBasicBlock.\n    const ConstantFP *CFP;   // For MO_FPImmediate.\n    const ConstantInt *CI;   // For MO_CImmediate. Integers > 64bit.\n    int64_t ImmVal;          // For MO_Immediate.\n    const uint32_t *RegMask; // For MO_RegisterMask and MO_RegisterLiveOut.\n    const MDNode *MD;        // For MO_Metadata.\n    MCSymbol *Sym;           // For MO_MCSymbol.\n    unsigned CFIIndex;       // For MO_CFI.\n    Intrinsic::ID IntrinsicID; // For MO_IntrinsicID.\n    unsigned Pred;           // For MO_Predicate\n    ArrayRef<int> ShuffleMask; // For MO_ShuffleMask\n\n    struct {                  // For MO_Register.\n      // Register number is in SmallContents.RegNo.\n      MachineOperand *Prev;   // Access list for register. See MRI.\n      MachineOperand *Next;\n    } Reg;\n\n    /// OffsetedInfo - This struct contains the offset and an object identifier.\n    /// this represent the object as with an optional offset from it.\n    struct {\n      union {\n        int Index;                // For MO_*Index - The index itself.\n        const char *SymbolName;   // For MO_ExternalSymbol.\n        const GlobalValue *GV;    // For MO_GlobalAddress.\n        const BlockAddress *BA;   // For MO_BlockAddress.\n      } Val;\n      // Low bits of offset are in SmallContents.OffsetLo.\n      int OffsetHi;               // An offset from the object, high 32 bits.\n    } OffsetedInfo;\n  } Contents;\n\n  explicit MachineOperand(MachineOperandType K)\n    : OpKind(K), SubReg_TargetFlags(0), ParentMI(nullptr) {\n    // Assert that the layout is what we expect. It's easy to grow this object.\n    static_assert(alignof(MachineOperand) <= alignof(int64_t),\n                  \"MachineOperand shouldn't be more than 8 byte aligned\");\n    static_assert(sizeof(Contents) <= 2 * sizeof(void *),\n                  \"Contents should be at most two pointers\");\n    static_assert(sizeof(MachineOperand) <=\n                      alignTo<alignof(int64_t)>(2 * sizeof(unsigned) +\n                                                3 * sizeof(void *)),\n                  \"MachineOperand too big. Should be Kind, SmallContents, \"\n                  \"ParentMI, and Contents\");\n  }\n\npublic:\n  /// getType - Returns the MachineOperandType for this operand.\n  ///\n  MachineOperandType getType() const { return (MachineOperandType)OpKind; }\n\n  unsigned getTargetFlags() const {\n    return isReg() ? 0 : SubReg_TargetFlags;\n  }\n  void setTargetFlags(unsigned F) {\n    assert(!isReg() && \"Register operands can't have target flags\");\n    SubReg_TargetFlags = F;\n    assert(SubReg_TargetFlags == F && \"Target flags out of range\");\n  }\n  void addTargetFlag(unsigned F) {\n    assert(!isReg() && \"Register operands can't have target flags\");\n    SubReg_TargetFlags |= F;\n    assert((SubReg_TargetFlags & F) && \"Target flags out of range\");\n  }\n\n\n  /// getParent - Return the instruction that this operand belongs to.\n  ///\n  MachineInstr *getParent() { return ParentMI; }\n  const MachineInstr *getParent() const { return ParentMI; }\n\n  /// clearParent - Reset the parent pointer.\n  ///\n  /// The MachineOperand copy constructor also copies ParentMI, expecting the\n  /// original to be deleted. If a MachineOperand is ever stored outside a\n  /// MachineInstr, the parent pointer must be cleared.\n  ///\n  /// Never call clearParent() on an operand in a MachineInstr.\n  ///\n  void clearParent() { ParentMI = nullptr; }\n\n  /// Print a subreg index operand.\n  /// MO_Immediate operands can also be subreg idices. If it's the case, the\n  /// subreg index name will be printed. MachineInstr::isOperandSubregIdx can be\n  /// called to check this.\n  static void printSubRegIdx(raw_ostream &OS, uint64_t Index,\n                             const TargetRegisterInfo *TRI);\n\n  /// Print operand target flags.\n  static void printTargetFlags(raw_ostream& OS, const MachineOperand &Op);\n\n  /// Print a MCSymbol as an operand.\n  static void printSymbol(raw_ostream &OS, MCSymbol &Sym);\n\n  /// Print a stack object reference.\n  static void printStackObjectReference(raw_ostream &OS, unsigned FrameIndex,\n                                        bool IsFixed, StringRef Name);\n\n  /// Print the offset with explicit +/- signs.\n  static void printOperandOffset(raw_ostream &OS, int64_t Offset);\n\n  /// Print an IRSlotNumber.\n  static void printIRSlotNumber(raw_ostream &OS, int Slot);\n\n  /// Print the MachineOperand to \\p os.\n  /// Providing a valid \\p TRI and \\p IntrinsicInfo results in a more\n  /// target-specific printing. If \\p TRI and \\p IntrinsicInfo are null, the\n  /// function will try to pick it up from the parent.\n  void print(raw_ostream &os, const TargetRegisterInfo *TRI = nullptr,\n             const TargetIntrinsicInfo *IntrinsicInfo = nullptr) const;\n\n  /// More complex way of printing a MachineOperand.\n  /// \\param TypeToPrint specifies the generic type to be printed on uses and\n  /// defs. It can be determined using MachineInstr::getTypeToPrint.\n  /// \\param OpIdx - specifies the index of the operand in machine instruction.\n  /// This will be used by target dependent MIR formatter. Could be None if the\n  /// index is unknown, e.g. called by dump().\n  /// \\param PrintDef - whether we want to print `def` on an operand which\n  /// isDef. Sometimes, if the operand is printed before '=', we don't print\n  /// `def`.\n  /// \\param IsStandalone - whether we want a verbose output of the MO. This\n  /// prints extra information that can be easily inferred when printing the\n  /// whole function, but not when printing only a fragment of it.\n  /// \\param ShouldPrintRegisterTies - whether we want to print register ties.\n  /// Sometimes they are easily determined by the instruction's descriptor\n  /// (MachineInstr::hasComplexRegiterTies can determine if it's needed).\n  /// \\param TiedOperandIdx - if we need to print register ties this needs to\n  /// provide the index of the tied register. If not, it will be ignored.\n  /// \\param TRI - provide more target-specific information to the printer.\n  /// Unlike the previous function, this one will not try and get the\n  /// information from it's parent.\n  /// \\param IntrinsicInfo - same as \\p TRI.\n  void print(raw_ostream &os, ModuleSlotTracker &MST, LLT TypeToPrint,\n             Optional<unsigned> OpIdx, bool PrintDef, bool IsStandalone,\n             bool ShouldPrintRegisterTies, unsigned TiedOperandIdx,\n             const TargetRegisterInfo *TRI,\n             const TargetIntrinsicInfo *IntrinsicInfo) const;\n\n  /// Same as print(os, TRI, IntrinsicInfo), but allows to specify the low-level\n  /// type to be printed the same way the full version of print(...) does it.\n  void print(raw_ostream &os, LLT TypeToPrint,\n             const TargetRegisterInfo *TRI = nullptr,\n             const TargetIntrinsicInfo *IntrinsicInfo = nullptr) const;\n\n  void dump() const;\n\n  //===--------------------------------------------------------------------===//\n  // Accessors that tell you what kind of MachineOperand you're looking at.\n  //===--------------------------------------------------------------------===//\n\n  /// isReg - Tests if this is a MO_Register operand.\n  bool isReg() const { return OpKind == MO_Register; }\n  /// isImm - Tests if this is a MO_Immediate operand.\n  bool isImm() const { return OpKind == MO_Immediate; }\n  /// isCImm - Test if this is a MO_CImmediate operand.\n  bool isCImm() const { return OpKind == MO_CImmediate; }\n  /// isFPImm - Tests if this is a MO_FPImmediate operand.\n  bool isFPImm() const { return OpKind == MO_FPImmediate; }\n  /// isMBB - Tests if this is a MO_MachineBasicBlock operand.\n  bool isMBB() const { return OpKind == MO_MachineBasicBlock; }\n  /// isFI - Tests if this is a MO_FrameIndex operand.\n  bool isFI() const { return OpKind == MO_FrameIndex; }\n  /// isCPI - Tests if this is a MO_ConstantPoolIndex operand.\n  bool isCPI() const { return OpKind == MO_ConstantPoolIndex; }\n  /// isTargetIndex - Tests if this is a MO_TargetIndex operand.\n  bool isTargetIndex() const { return OpKind == MO_TargetIndex; }\n  /// isJTI - Tests if this is a MO_JumpTableIndex operand.\n  bool isJTI() const { return OpKind == MO_JumpTableIndex; }\n  /// isGlobal - Tests if this is a MO_GlobalAddress operand.\n  bool isGlobal() const { return OpKind == MO_GlobalAddress; }\n  /// isSymbol - Tests if this is a MO_ExternalSymbol operand.\n  bool isSymbol() const { return OpKind == MO_ExternalSymbol; }\n  /// isBlockAddress - Tests if this is a MO_BlockAddress operand.\n  bool isBlockAddress() const { return OpKind == MO_BlockAddress; }\n  /// isRegMask - Tests if this is a MO_RegisterMask operand.\n  bool isRegMask() const { return OpKind == MO_RegisterMask; }\n  /// isRegLiveOut - Tests if this is a MO_RegisterLiveOut operand.\n  bool isRegLiveOut() const { return OpKind == MO_RegisterLiveOut; }\n  /// isMetadata - Tests if this is a MO_Metadata operand.\n  bool isMetadata() const { return OpKind == MO_Metadata; }\n  bool isMCSymbol() const { return OpKind == MO_MCSymbol; }\n  bool isCFIIndex() const { return OpKind == MO_CFIIndex; }\n  bool isIntrinsicID() const { return OpKind == MO_IntrinsicID; }\n  bool isPredicate() const { return OpKind == MO_Predicate; }\n  bool isShuffleMask() const { return OpKind == MO_ShuffleMask; }\n  //===--------------------------------------------------------------------===//\n  // Accessors for Register Operands\n  //===--------------------------------------------------------------------===//\n\n  /// getReg - Returns the register number.\n  Register getReg() const {\n    assert(isReg() && \"This is not a register operand!\");\n    return Register(SmallContents.RegNo);\n  }\n\n  unsigned getSubReg() const {\n    assert(isReg() && \"Wrong MachineOperand accessor\");\n    return SubReg_TargetFlags;\n  }\n\n  bool isUse() const {\n    assert(isReg() && \"Wrong MachineOperand accessor\");\n    return !IsDef;\n  }\n\n  bool isDef() const {\n    assert(isReg() && \"Wrong MachineOperand accessor\");\n    return IsDef;\n  }\n\n  bool isImplicit() const {\n    assert(isReg() && \"Wrong MachineOperand accessor\");\n    return IsImp;\n  }\n\n  bool isDead() const {\n    assert(isReg() && \"Wrong MachineOperand accessor\");\n    return IsDeadOrKill & IsDef;\n  }\n\n  bool isKill() const {\n    assert(isReg() && \"Wrong MachineOperand accessor\");\n    return IsDeadOrKill & !IsDef;\n  }\n\n  bool isUndef() const {\n    assert(isReg() && \"Wrong MachineOperand accessor\");\n    return IsUndef;\n  }\n\n  /// isRenamable - Returns true if this register may be renamed, i.e. it does\n  /// not generate a value that is somehow read in a way that is not represented\n  /// by the Machine IR (e.g. to meet an ABI or ISA requirement).  This is only\n  /// valid on physical register operands.  Virtual registers are assumed to\n  /// always be renamable regardless of the value of this field.\n  ///\n  /// Operands that are renamable can freely be changed to any other register\n  /// that is a member of the register class returned by\n  /// MI->getRegClassConstraint().\n  ///\n  /// isRenamable can return false for several different reasons:\n  ///\n  /// - ABI constraints (since liveness is not always precisely modeled).  We\n  ///   conservatively handle these cases by setting all physical register\n  ///   operands that didn\u2019t start out as virtual regs to not be renamable.\n  ///   Also any physical register operands created after register allocation or\n  ///   whose register is changed after register allocation will not be\n  ///   renamable.  This state is tracked in the MachineOperand::IsRenamable\n  ///   bit.\n  ///\n  /// - Opcode/target constraints: for opcodes that have complex register class\n  ///   requirements (e.g. that depend on other operands/instructions), we set\n  ///   hasExtraSrcRegAllocReq/hasExtraDstRegAllocReq in the machine opcode\n  ///   description.  Operands belonging to instructions with opcodes that are\n  ///   marked hasExtraSrcRegAllocReq/hasExtraDstRegAllocReq return false from\n  ///   isRenamable().  Additionally, the AllowRegisterRenaming target property\n  ///   prevents any operands from being marked renamable for targets that don't\n  ///   have detailed opcode hasExtraSrcRegAllocReq/hasExtraDstRegAllocReq\n  ///   values.\n  bool isRenamable() const;\n\n  bool isInternalRead() const {\n    assert(isReg() && \"Wrong MachineOperand accessor\");\n    return IsInternalRead;\n  }\n\n  bool isEarlyClobber() const {\n    assert(isReg() && \"Wrong MachineOperand accessor\");\n    return IsEarlyClobber;\n  }\n\n  bool isTied() const {\n    assert(isReg() && \"Wrong MachineOperand accessor\");\n    return TiedTo;\n  }\n\n  bool isDebug() const {\n    assert(isReg() && \"Wrong MachineOperand accessor\");\n    return IsDebug;\n  }\n\n  /// readsReg - Returns true if this operand reads the previous value of its\n  /// register.  A use operand with the <undef> flag set doesn't read its\n  /// register.  A sub-register def implicitly reads the other parts of the\n  /// register being redefined unless the <undef> flag is set.\n  ///\n  /// This refers to reading the register value from before the current\n  /// instruction or bundle. Internal bundle reads are not included.\n  bool readsReg() const {\n    assert(isReg() && \"Wrong MachineOperand accessor\");\n    return !isUndef() && !isInternalRead() && (isUse() || getSubReg());\n  }\n\n  //===--------------------------------------------------------------------===//\n  // Mutators for Register Operands\n  //===--------------------------------------------------------------------===//\n\n  /// Change the register this operand corresponds to.\n  ///\n  void setReg(Register Reg);\n\n  void setSubReg(unsigned subReg) {\n    assert(isReg() && \"Wrong MachineOperand mutator\");\n    SubReg_TargetFlags = subReg;\n    assert(SubReg_TargetFlags == subReg && \"SubReg out of range\");\n  }\n\n  /// substVirtReg - Substitute the current register with the virtual\n  /// subregister Reg:SubReg. Take any existing SubReg index into account,\n  /// using TargetRegisterInfo to compose the subreg indices if necessary.\n  /// Reg must be a virtual register, SubIdx can be 0.\n  ///\n  void substVirtReg(Register Reg, unsigned SubIdx, const TargetRegisterInfo&);\n\n  /// substPhysReg - Substitute the current register with the physical register\n  /// Reg, taking any existing SubReg into account. For instance,\n  /// substPhysReg(%eax) will change %reg1024:sub_8bit to %al.\n  ///\n  void substPhysReg(MCRegister Reg, const TargetRegisterInfo&);\n\n  void setIsUse(bool Val = true) { setIsDef(!Val); }\n\n  /// Change a def to a use, or a use to a def.\n  void setIsDef(bool Val = true);\n\n  void setImplicit(bool Val = true) {\n    assert(isReg() && \"Wrong MachineOperand mutator\");\n    IsImp = Val;\n  }\n\n  void setIsKill(bool Val = true) {\n    assert(isReg() && !IsDef && \"Wrong MachineOperand mutator\");\n    assert((!Val || !isDebug()) && \"Marking a debug operation as kill\");\n    IsDeadOrKill = Val;\n  }\n\n  void setIsDead(bool Val = true) {\n    assert(isReg() && IsDef && \"Wrong MachineOperand mutator\");\n    IsDeadOrKill = Val;\n  }\n\n  void setIsUndef(bool Val = true) {\n    assert(isReg() && \"Wrong MachineOperand mutator\");\n    IsUndef = Val;\n  }\n\n  void setIsRenamable(bool Val = true);\n\n  void setIsInternalRead(bool Val = true) {\n    assert(isReg() && \"Wrong MachineOperand mutator\");\n    IsInternalRead = Val;\n  }\n\n  void setIsEarlyClobber(bool Val = true) {\n    assert(isReg() && IsDef && \"Wrong MachineOperand mutator\");\n    IsEarlyClobber = Val;\n  }\n\n  void setIsDebug(bool Val = true) {\n    assert(isReg() && !IsDef && \"Wrong MachineOperand mutator\");\n    IsDebug = Val;\n  }\n\n  //===--------------------------------------------------------------------===//\n  // Accessors for various operand types.\n  //===--------------------------------------------------------------------===//\n\n  int64_t getImm() const {\n    assert(isImm() && \"Wrong MachineOperand accessor\");\n    return Contents.ImmVal;\n  }\n\n  const ConstantInt *getCImm() const {\n    assert(isCImm() && \"Wrong MachineOperand accessor\");\n    return Contents.CI;\n  }\n\n  const ConstantFP *getFPImm() const {\n    assert(isFPImm() && \"Wrong MachineOperand accessor\");\n    return Contents.CFP;\n  }\n\n  MachineBasicBlock *getMBB() const {\n    assert(isMBB() && \"Wrong MachineOperand accessor\");\n    return Contents.MBB;\n  }\n\n  int getIndex() const {\n    assert((isFI() || isCPI() || isTargetIndex() || isJTI()) &&\n           \"Wrong MachineOperand accessor\");\n    return Contents.OffsetedInfo.Val.Index;\n  }\n\n  const GlobalValue *getGlobal() const {\n    assert(isGlobal() && \"Wrong MachineOperand accessor\");\n    return Contents.OffsetedInfo.Val.GV;\n  }\n\n  const BlockAddress *getBlockAddress() const {\n    assert(isBlockAddress() && \"Wrong MachineOperand accessor\");\n    return Contents.OffsetedInfo.Val.BA;\n  }\n\n  MCSymbol *getMCSymbol() const {\n    assert(isMCSymbol() && \"Wrong MachineOperand accessor\");\n    return Contents.Sym;\n  }\n\n  unsigned getCFIIndex() const {\n    assert(isCFIIndex() && \"Wrong MachineOperand accessor\");\n    return Contents.CFIIndex;\n  }\n\n  Intrinsic::ID getIntrinsicID() const {\n    assert(isIntrinsicID() && \"Wrong MachineOperand accessor\");\n    return Contents.IntrinsicID;\n  }\n\n  unsigned getPredicate() const {\n    assert(isPredicate() && \"Wrong MachineOperand accessor\");\n    return Contents.Pred;\n  }\n\n  ArrayRef<int> getShuffleMask() const {\n    assert(isShuffleMask() && \"Wrong MachineOperand accessor\");\n    return Contents.ShuffleMask;\n  }\n\n  /// Return the offset from the symbol in this operand. This always returns 0\n  /// for ExternalSymbol operands.\n  int64_t getOffset() const {\n    assert((isGlobal() || isSymbol() || isMCSymbol() || isCPI() ||\n            isTargetIndex() || isBlockAddress()) &&\n           \"Wrong MachineOperand accessor\");\n    return int64_t(uint64_t(Contents.OffsetedInfo.OffsetHi) << 32) |\n           SmallContents.OffsetLo;\n  }\n\n  const char *getSymbolName() const {\n    assert(isSymbol() && \"Wrong MachineOperand accessor\");\n    return Contents.OffsetedInfo.Val.SymbolName;\n  }\n\n  /// clobbersPhysReg - Returns true if this RegMask clobbers PhysReg.\n  /// It is sometimes necessary to detach the register mask pointer from its\n  /// machine operand. This static method can be used for such detached bit\n  /// mask pointers.\n  static bool clobbersPhysReg(const uint32_t *RegMask, MCRegister PhysReg) {\n    // See TargetRegisterInfo.h.\n    assert(PhysReg < (1u << 30) && \"Not a physical register\");\n    return !(RegMask[PhysReg / 32] & (1u << PhysReg % 32));\n  }\n\n  /// clobbersPhysReg - Returns true if this RegMask operand clobbers PhysReg.\n  bool clobbersPhysReg(MCRegister PhysReg) const {\n     return clobbersPhysReg(getRegMask(), PhysReg);\n  }\n\n  /// getRegMask - Returns a bit mask of registers preserved by this RegMask\n  /// operand.\n  const uint32_t *getRegMask() const {\n    assert(isRegMask() && \"Wrong MachineOperand accessor\");\n    return Contents.RegMask;\n  }\n\n  /// Returns number of elements needed for a regmask array.\n  static unsigned getRegMaskSize(unsigned NumRegs) {\n    return (NumRegs + 31) / 32;\n  }\n\n  /// getRegLiveOut - Returns a bit mask of live-out registers.\n  const uint32_t *getRegLiveOut() const {\n    assert(isRegLiveOut() && \"Wrong MachineOperand accessor\");\n    return Contents.RegMask;\n  }\n\n  const MDNode *getMetadata() const {\n    assert(isMetadata() && \"Wrong MachineOperand accessor\");\n    return Contents.MD;\n  }\n\n  //===--------------------------------------------------------------------===//\n  // Mutators for various operand types.\n  //===--------------------------------------------------------------------===//\n\n  void setImm(int64_t immVal) {\n    assert(isImm() && \"Wrong MachineOperand mutator\");\n    Contents.ImmVal = immVal;\n  }\n\n  void setCImm(const ConstantInt *CI) {\n    assert(isCImm() && \"Wrong MachineOperand mutator\");\n    Contents.CI = CI;\n  }\n\n  void setFPImm(const ConstantFP *CFP) {\n    assert(isFPImm() && \"Wrong MachineOperand mutator\");\n    Contents.CFP = CFP;\n  }\n\n  void setOffset(int64_t Offset) {\n    assert((isGlobal() || isSymbol() || isMCSymbol() || isCPI() ||\n            isTargetIndex() || isBlockAddress()) &&\n           \"Wrong MachineOperand mutator\");\n    SmallContents.OffsetLo = unsigned(Offset);\n    Contents.OffsetedInfo.OffsetHi = int(Offset >> 32);\n  }\n\n  void setIndex(int Idx) {\n    assert((isFI() || isCPI() || isTargetIndex() || isJTI()) &&\n           \"Wrong MachineOperand mutator\");\n    Contents.OffsetedInfo.Val.Index = Idx;\n  }\n\n  void setMetadata(const MDNode *MD) {\n    assert(isMetadata() && \"Wrong MachineOperand mutator\");\n    Contents.MD = MD;\n  }\n\n  void setMBB(MachineBasicBlock *MBB) {\n    assert(isMBB() && \"Wrong MachineOperand mutator\");\n    Contents.MBB = MBB;\n  }\n\n  /// Sets value of register mask operand referencing Mask.  The\n  /// operand does not take ownership of the memory referenced by Mask, it must\n  /// remain valid for the lifetime of the operand. See CreateRegMask().\n  /// Any physreg with a 0 bit in the mask is clobbered by the instruction.\n  void setRegMask(const uint32_t *RegMaskPtr) {\n    assert(isRegMask() && \"Wrong MachineOperand mutator\");\n    Contents.RegMask = RegMaskPtr;\n  }\n\n  void setIntrinsicID(Intrinsic::ID IID) {\n    assert(isIntrinsicID() && \"Wrong MachineOperand mutator\");\n    Contents.IntrinsicID = IID;\n  }\n\n  void setPredicate(unsigned Predicate) {\n    assert(isPredicate() && \"Wrong MachineOperand mutator\");\n    Contents.Pred = Predicate;\n  }\n\n  //===--------------------------------------------------------------------===//\n  // Other methods.\n  //===--------------------------------------------------------------------===//\n\n  /// Returns true if this operand is identical to the specified operand except\n  /// for liveness related flags (isKill, isUndef and isDead). Note that this\n  /// should stay in sync with the hash_value overload below.\n  bool isIdenticalTo(const MachineOperand &Other) const;\n\n  /// MachineOperand hash_value overload.\n  ///\n  /// Note that this includes the same information in the hash that\n  /// isIdenticalTo uses for comparison. It is thus suited for use in hash\n  /// tables which use that function for equality comparisons only. This must\n  /// stay exactly in sync with isIdenticalTo above.\n  friend hash_code hash_value(const MachineOperand &MO);\n\n  /// ChangeToImmediate - Replace this operand with a new immediate operand of\n  /// the specified value.  If an operand is known to be an immediate already,\n  /// the setImm method should be used.\n  void ChangeToImmediate(int64_t ImmVal, unsigned TargetFlags = 0);\n\n  /// ChangeToFPImmediate - Replace this operand with a new FP immediate operand\n  /// of the specified value.  If an operand is known to be an FP immediate\n  /// already, the setFPImm method should be used.\n  void ChangeToFPImmediate(const ConstantFP *FPImm, unsigned TargetFlags = 0);\n\n  /// ChangeToES - Replace this operand with a new external symbol operand.\n  void ChangeToES(const char *SymName, unsigned TargetFlags = 0);\n\n  /// ChangeToGA - Replace this operand with a new global address operand.\n  void ChangeToGA(const GlobalValue *GV, int64_t Offset,\n                  unsigned TargetFlags = 0);\n\n  /// ChangeToMCSymbol - Replace this operand with a new MC symbol operand.\n  void ChangeToMCSymbol(MCSymbol *Sym, unsigned TargetFlags = 0);\n\n  /// Replace this operand with a frame index.\n  void ChangeToFrameIndex(int Idx, unsigned TargetFlags = 0);\n\n  /// Replace this operand with a target index.\n  void ChangeToTargetIndex(unsigned Idx, int64_t Offset,\n                           unsigned TargetFlags = 0);\n\n  /// ChangeToRegister - Replace this operand with a new register operand of\n  /// the specified value.  If an operand is known to be an register already,\n  /// the setReg method should be used.\n  void ChangeToRegister(Register Reg, bool isDef, bool isImp = false,\n                        bool isKill = false, bool isDead = false,\n                        bool isUndef = false, bool isDebug = false);\n\n  /// getTargetIndexName - If this MachineOperand is a TargetIndex that has a\n  /// name, attempt to get the name. Returns nullptr if the TargetIndex does not\n  /// have a name. Asserts if MO is not a TargetIndex.\n  const char *getTargetIndexName() const;\n\n  //===--------------------------------------------------------------------===//\n  // Construction methods.\n  //===--------------------------------------------------------------------===//\n\n  static MachineOperand CreateImm(int64_t Val) {\n    MachineOperand Op(MachineOperand::MO_Immediate);\n    Op.setImm(Val);\n    return Op;\n  }\n\n  static MachineOperand CreateCImm(const ConstantInt *CI) {\n    MachineOperand Op(MachineOperand::MO_CImmediate);\n    Op.Contents.CI = CI;\n    return Op;\n  }\n\n  static MachineOperand CreateFPImm(const ConstantFP *CFP) {\n    MachineOperand Op(MachineOperand::MO_FPImmediate);\n    Op.Contents.CFP = CFP;\n    return Op;\n  }\n\n  static MachineOperand CreateReg(Register Reg, bool isDef, bool isImp = false,\n                                  bool isKill = false, bool isDead = false,\n                                  bool isUndef = false,\n                                  bool isEarlyClobber = false,\n                                  unsigned SubReg = 0, bool isDebug = false,\n                                  bool isInternalRead = false,\n                                  bool isRenamable = false) {\n    assert(!(isDead && !isDef) && \"Dead flag on non-def\");\n    assert(!(isKill && isDef) && \"Kill flag on def\");\n    MachineOperand Op(MachineOperand::MO_Register);\n    Op.IsDef = isDef;\n    Op.IsImp = isImp;\n    Op.IsDeadOrKill = isKill | isDead;\n    Op.IsRenamable = isRenamable;\n    Op.IsUndef = isUndef;\n    Op.IsInternalRead = isInternalRead;\n    Op.IsEarlyClobber = isEarlyClobber;\n    Op.TiedTo = 0;\n    Op.IsDebug = isDebug;\n    Op.SmallContents.RegNo = Reg;\n    Op.Contents.Reg.Prev = nullptr;\n    Op.Contents.Reg.Next = nullptr;\n    Op.setSubReg(SubReg);\n    return Op;\n  }\n  static MachineOperand CreateMBB(MachineBasicBlock *MBB,\n                                  unsigned TargetFlags = 0) {\n    MachineOperand Op(MachineOperand::MO_MachineBasicBlock);\n    Op.setMBB(MBB);\n    Op.setTargetFlags(TargetFlags);\n    return Op;\n  }\n  static MachineOperand CreateFI(int Idx) {\n    MachineOperand Op(MachineOperand::MO_FrameIndex);\n    Op.setIndex(Idx);\n    return Op;\n  }\n  static MachineOperand CreateCPI(unsigned Idx, int Offset,\n                                  unsigned TargetFlags = 0) {\n    MachineOperand Op(MachineOperand::MO_ConstantPoolIndex);\n    Op.setIndex(Idx);\n    Op.setOffset(Offset);\n    Op.setTargetFlags(TargetFlags);\n    return Op;\n  }\n  static MachineOperand CreateTargetIndex(unsigned Idx, int64_t Offset,\n                                          unsigned TargetFlags = 0) {\n    MachineOperand Op(MachineOperand::MO_TargetIndex);\n    Op.setIndex(Idx);\n    Op.setOffset(Offset);\n    Op.setTargetFlags(TargetFlags);\n    return Op;\n  }\n  static MachineOperand CreateJTI(unsigned Idx, unsigned TargetFlags = 0) {\n    MachineOperand Op(MachineOperand::MO_JumpTableIndex);\n    Op.setIndex(Idx);\n    Op.setTargetFlags(TargetFlags);\n    return Op;\n  }\n  static MachineOperand CreateGA(const GlobalValue *GV, int64_t Offset,\n                                 unsigned TargetFlags = 0) {\n    MachineOperand Op(MachineOperand::MO_GlobalAddress);\n    Op.Contents.OffsetedInfo.Val.GV = GV;\n    Op.setOffset(Offset);\n    Op.setTargetFlags(TargetFlags);\n    return Op;\n  }\n  static MachineOperand CreateES(const char *SymName,\n                                 unsigned TargetFlags = 0) {\n    MachineOperand Op(MachineOperand::MO_ExternalSymbol);\n    Op.Contents.OffsetedInfo.Val.SymbolName = SymName;\n    Op.setOffset(0); // Offset is always 0.\n    Op.setTargetFlags(TargetFlags);\n    return Op;\n  }\n  static MachineOperand CreateBA(const BlockAddress *BA, int64_t Offset,\n                                 unsigned TargetFlags = 0) {\n    MachineOperand Op(MachineOperand::MO_BlockAddress);\n    Op.Contents.OffsetedInfo.Val.BA = BA;\n    Op.setOffset(Offset);\n    Op.setTargetFlags(TargetFlags);\n    return Op;\n  }\n  /// CreateRegMask - Creates a register mask operand referencing Mask.  The\n  /// operand does not take ownership of the memory referenced by Mask, it\n  /// must remain valid for the lifetime of the operand.\n  ///\n  /// A RegMask operand represents a set of non-clobbered physical registers\n  /// on an instruction that clobbers many registers, typically a call.  The\n  /// bit mask has a bit set for each physreg that is preserved by this\n  /// instruction, as described in the documentation for\n  /// TargetRegisterInfo::getCallPreservedMask().\n  ///\n  /// Any physreg with a 0 bit in the mask is clobbered by the instruction.\n  ///\n  static MachineOperand CreateRegMask(const uint32_t *Mask) {\n    assert(Mask && \"Missing register mask\");\n    MachineOperand Op(MachineOperand::MO_RegisterMask);\n    Op.Contents.RegMask = Mask;\n    return Op;\n  }\n  static MachineOperand CreateRegLiveOut(const uint32_t *Mask) {\n    assert(Mask && \"Missing live-out register mask\");\n    MachineOperand Op(MachineOperand::MO_RegisterLiveOut);\n    Op.Contents.RegMask = Mask;\n    return Op;\n  }\n  static MachineOperand CreateMetadata(const MDNode *Meta) {\n    MachineOperand Op(MachineOperand::MO_Metadata);\n    Op.Contents.MD = Meta;\n    return Op;\n  }\n\n  static MachineOperand CreateMCSymbol(MCSymbol *Sym,\n                                       unsigned TargetFlags = 0) {\n    MachineOperand Op(MachineOperand::MO_MCSymbol);\n    Op.Contents.Sym = Sym;\n    Op.setOffset(0);\n    Op.setTargetFlags(TargetFlags);\n    return Op;\n  }\n\n  static MachineOperand CreateCFIIndex(unsigned CFIIndex) {\n    MachineOperand Op(MachineOperand::MO_CFIIndex);\n    Op.Contents.CFIIndex = CFIIndex;\n    return Op;\n  }\n\n  static MachineOperand CreateIntrinsicID(Intrinsic::ID ID) {\n    MachineOperand Op(MachineOperand::MO_IntrinsicID);\n    Op.Contents.IntrinsicID = ID;\n    return Op;\n  }\n\n  static MachineOperand CreatePredicate(unsigned Pred) {\n    MachineOperand Op(MachineOperand::MO_Predicate);\n    Op.Contents.Pred = Pred;\n    return Op;\n  }\n\n  static MachineOperand CreateShuffleMask(ArrayRef<int> Mask) {\n    MachineOperand Op(MachineOperand::MO_ShuffleMask);\n    Op.Contents.ShuffleMask = Mask;\n    return Op;\n  }\n\n  friend class MachineInstr;\n  friend class MachineRegisterInfo;\n\nprivate:\n  // If this operand is currently a register operand, and if this is in a\n  // function, deregister the operand from the register's use/def list.\n  void removeRegFromUses();\n\n  /// Artificial kinds for DenseMap usage.\n  enum : unsigned char {\n    MO_Empty = MO_Last + 1,\n    MO_Tombstone,\n  };\n\n  friend struct DenseMapInfo<MachineOperand>;\n\n  //===--------------------------------------------------------------------===//\n  // Methods for handling register use/def lists.\n  //===--------------------------------------------------------------------===//\n\n  /// isOnRegUseList - Return true if this operand is on a register use/def\n  /// list or false if not.  This can only be called for register operands\n  /// that are part of a machine instruction.\n  bool isOnRegUseList() const {\n    assert(isReg() && \"Can only add reg operand to use lists\");\n    return Contents.Reg.Prev != nullptr;\n  }\n};\n\ntemplate <> struct DenseMapInfo<MachineOperand> {\n  static MachineOperand getEmptyKey() {\n    return MachineOperand(static_cast<MachineOperand::MachineOperandType>(\n        MachineOperand::MO_Empty));\n  }\n  static MachineOperand getTombstoneKey() {\n    return MachineOperand(static_cast<MachineOperand::MachineOperandType>(\n        MachineOperand::MO_Tombstone));\n  }\n  static unsigned getHashValue(const MachineOperand &MO) {\n    return hash_value(MO);\n  }\n  static bool isEqual(const MachineOperand &LHS, const MachineOperand &RHS) {\n    if (LHS.getType() == static_cast<MachineOperand::MachineOperandType>(\n                             MachineOperand::MO_Empty) ||\n        LHS.getType() == static_cast<MachineOperand::MachineOperandType>(\n                             MachineOperand::MO_Tombstone))\n      return LHS.getType() == RHS.getType();\n    return LHS.isIdenticalTo(RHS);\n  }\n};\n\ninline raw_ostream &operator<<(raw_ostream &OS, const MachineOperand &MO) {\n  MO.print(OS);\n  return OS;\n}\n\n// See friend declaration above. This additional declaration is required in\n// order to compile LLVM with IBM xlC compiler.\nhash_code hash_value(const MachineOperand &MO);\n} // namespace llvm\n\n#endif\n"}, "31": {"id": 31, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/CodeGen/PseudoSourceValue.h", "content": "//===-- llvm/CodeGen/PseudoSourceValue.h ------------------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// This file contains the declaration of the PseudoSourceValue class.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_CODEGEN_PSEUDOSOURCEVALUE_H\n#define LLVM_CODEGEN_PSEUDOSOURCEVALUE_H\n\n#include \"llvm/ADT/StringMap.h\"\n#include \"llvm/IR/ValueMap.h\"\n#include <map>\n\nnamespace llvm {\n\nclass GlobalValue;\nclass MachineFrameInfo;\nclass MachineMemOperand;\nclass MIRFormatter;\nclass PseudoSourceValue;\nclass raw_ostream;\nclass TargetInstrInfo;\n\nraw_ostream &operator<<(raw_ostream &OS, const PseudoSourceValue* PSV);\n\n/// Special value supplied for machine level alias analysis. It indicates that\n/// a memory access references the functions stack frame (e.g., a spill slot),\n/// below the stack frame (e.g., argument space), or constant pool.\nclass PseudoSourceValue {\npublic:\n  enum PSVKind : unsigned {\n    Stack,\n    GOT,\n    JumpTable,\n    ConstantPool,\n    FixedStack,\n    GlobalValueCallEntry,\n    ExternalSymbolCallEntry,\n    TargetCustom\n  };\n\nprivate:\n  unsigned Kind;\n  unsigned AddressSpace;\n  friend raw_ostream &llvm::operator<<(raw_ostream &OS,\n                                       const PseudoSourceValue* PSV);\n\n  friend class MachineMemOperand; // For printCustom().\n  friend class MIRFormatter;      // For printCustom().\n\n  /// Implement printing for PseudoSourceValue. This is called from\n  /// Value::print or Value's operator<<.\n  virtual void printCustom(raw_ostream &O) const;\n\npublic:\n  explicit PseudoSourceValue(unsigned Kind, const TargetInstrInfo &TII);\n\n  virtual ~PseudoSourceValue();\n\n  unsigned kind() const { return Kind; }\n\n  bool isStack() const { return Kind == Stack; }\n  bool isGOT() const { return Kind == GOT; }\n  bool isConstantPool() const { return Kind == ConstantPool; }\n  bool isJumpTable() const { return Kind == JumpTable; }\n\n  unsigned getAddressSpace() const { return AddressSpace; }\n\n  unsigned getTargetCustom() const {\n    return (Kind >= TargetCustom) ? ((Kind+1) - TargetCustom) : 0;\n  }\n\n  /// Test whether the memory pointed to by this PseudoSourceValue has a\n  /// constant value.\n  virtual bool isConstant(const MachineFrameInfo *) const;\n\n  /// Test whether the memory pointed to by this PseudoSourceValue may also be\n  /// pointed to by an LLVM IR Value.\n  virtual bool isAliased(const MachineFrameInfo *) const;\n\n  /// Return true if the memory pointed to by this PseudoSourceValue can ever\n  /// alias an LLVM IR Value.\n  virtual bool mayAlias(const MachineFrameInfo *) const;\n};\n\n/// A specialized PseudoSourceValue for holding FixedStack values, which must\n/// include a frame index.\nclass FixedStackPseudoSourceValue : public PseudoSourceValue {\n  const int FI;\n\npublic:\n  explicit FixedStackPseudoSourceValue(int FI, const TargetInstrInfo &TII)\n      : PseudoSourceValue(FixedStack, TII), FI(FI) {}\n\n  static bool classof(const PseudoSourceValue *V) {\n    return V->kind() == FixedStack;\n  }\n\n  bool isConstant(const MachineFrameInfo *MFI) const override;\n\n  bool isAliased(const MachineFrameInfo *MFI) const override;\n\n  bool mayAlias(const MachineFrameInfo *) const override;\n\n  void printCustom(raw_ostream &OS) const override;\n\n  int getFrameIndex() const { return FI; }\n};\n\nclass CallEntryPseudoSourceValue : public PseudoSourceValue {\nprotected:\n  CallEntryPseudoSourceValue(unsigned Kind, const TargetInstrInfo &TII);\n\npublic:\n  bool isConstant(const MachineFrameInfo *) const override;\n  bool isAliased(const MachineFrameInfo *) const override;\n  bool mayAlias(const MachineFrameInfo *) const override;\n};\n\n/// A specialized pseudo source value for holding GlobalValue values.\nclass GlobalValuePseudoSourceValue : public CallEntryPseudoSourceValue {\n  const GlobalValue *GV;\n\npublic:\n  GlobalValuePseudoSourceValue(const GlobalValue *GV,\n                               const TargetInstrInfo &TII);\n\n  static bool classof(const PseudoSourceValue *V) {\n    return V->kind() == GlobalValueCallEntry;\n  }\n\n  const GlobalValue *getValue() const { return GV; }\n};\n\n/// A specialized pseudo source value for holding external symbol values.\nclass ExternalSymbolPseudoSourceValue : public CallEntryPseudoSourceValue {\n  const char *ES;\n\npublic:\n  ExternalSymbolPseudoSourceValue(const char *ES, const TargetInstrInfo &TII);\n\n  static bool classof(const PseudoSourceValue *V) {\n    return V->kind() == ExternalSymbolCallEntry;\n  }\n\n  const char *getSymbol() const { return ES; }\n};\n\n/// Manages creation of pseudo source values.\nclass PseudoSourceValueManager {\n  const TargetInstrInfo &TII;\n  const PseudoSourceValue StackPSV, GOTPSV, JumpTablePSV, ConstantPoolPSV;\n  std::map<int, std::unique_ptr<FixedStackPseudoSourceValue>> FSValues;\n  StringMap<std::unique_ptr<const ExternalSymbolPseudoSourceValue>>\n      ExternalCallEntries;\n  ValueMap<const GlobalValue *,\n           std::unique_ptr<const GlobalValuePseudoSourceValue>>\n      GlobalCallEntries;\n\npublic:\n  PseudoSourceValueManager(const TargetInstrInfo &TII);\n\n  /// Return a pseudo source value referencing the area below the stack frame of\n  /// a function, e.g., the argument space.\n  const PseudoSourceValue *getStack();\n\n  /// Return a pseudo source value referencing the global offset table\n  /// (or something the like).\n  const PseudoSourceValue *getGOT();\n\n  /// Return a pseudo source value referencing the constant pool. Since constant\n  /// pools are constant, this doesn't need to identify a specific constant\n  /// pool entry.\n  const PseudoSourceValue *getConstantPool();\n\n  /// Return a pseudo source value referencing a jump table. Since jump tables\n  /// are constant, this doesn't need to identify a specific jump table.\n  const PseudoSourceValue *getJumpTable();\n\n  /// Return a pseudo source value referencing a fixed stack frame entry,\n  /// e.g., a spill slot.\n  const PseudoSourceValue *getFixedStack(int FI);\n\n  const PseudoSourceValue *getGlobalValueCallEntry(const GlobalValue *GV);\n\n  const PseudoSourceValue *getExternalSymbolCallEntry(const char *ES);\n};\n\n} // end namespace llvm\n\n#endif\n"}, "32": {"id": 32, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/CodeGen/Register.h", "content": "//===-- llvm/CodeGen/Register.h ---------------------------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_CODEGEN_REGISTER_H\n#define LLVM_CODEGEN_REGISTER_H\n\n#include \"llvm/MC/MCRegister.h\"\n#include <cassert>\n\nnamespace llvm {\n\n/// Wrapper class representing virtual and physical registers. Should be passed\n/// by value.\nclass Register {\n  unsigned Reg;\n\npublic:\n  constexpr Register(unsigned Val = 0): Reg(Val) {}\n  constexpr Register(MCRegister Val): Reg(Val) {}\n\n  // Register numbers can represent physical registers, virtual registers, and\n  // sometimes stack slots. The unsigned values are divided into these ranges:\n  //\n  //   0           Not a register, can be used as a sentinel.\n  //   [1;2^30)    Physical registers assigned by TableGen.\n  //   [2^30;2^31) Stack slots. (Rarely used.)\n  //   [2^31;2^32) Virtual registers assigned by MachineRegisterInfo.\n  //\n  // Further sentinels can be allocated from the small negative integers.\n  // DenseMapInfo<unsigned> uses -1u and -2u.\n  static_assert(std::numeric_limits<decltype(Reg)>::max() >= 0xFFFFFFFF,\n                \"Reg isn't large enough to hold full range.\");\n\n  /// isStackSlot - Sometimes it is useful the be able to store a non-negative\n  /// frame index in a variable that normally holds a register. isStackSlot()\n  /// returns true if Reg is in the range used for stack slots.\n  ///\n  /// FIXME: remove in favor of member.\n  static bool isStackSlot(unsigned Reg) {\n    return MCRegister::isStackSlot(Reg);\n  }\n\n  /// Return true if this is a stack slot.\n  bool isStack() const { return MCRegister::isStackSlot(Reg); }\n\n  /// Compute the frame index from a register value representing a stack slot.\n  static int stackSlot2Index(Register Reg) {\n    assert(Reg.isStack() && \"Not a stack slot\");\n    return int(Reg - MCRegister::FirstStackSlot);\n  }\n\n  /// Convert a non-negative frame index to a stack slot register value.\n  static Register index2StackSlot(int FI) {\n    assert(FI >= 0 && \"Cannot hold a negative frame index.\");\n    return Register(FI + MCRegister::FirstStackSlot);\n  }\n\n  /// Return true if the specified register number is in\n  /// the physical register namespace.\n  static bool isPhysicalRegister(unsigned Reg) {\n    return MCRegister::isPhysicalRegister(Reg);\n  }\n\n  /// Return true if the specified register number is in\n  /// the virtual register namespace.\n  static bool isVirtualRegister(unsigned Reg) {\n    return Reg & MCRegister::VirtualRegFlag && !isStackSlot(Reg);\n  }\n\n  /// Convert a virtual register number to a 0-based index.\n  /// The first virtual register in a function will get the index 0.\n  static unsigned virtReg2Index(Register Reg) {\n    assert(isVirtualRegister(Reg) && \"Not a virtual register\");\n    return Reg & ~MCRegister::VirtualRegFlag;\n  }\n\n  /// Convert a 0-based index to a virtual register number.\n  /// This is the inverse operation of VirtReg2IndexFunctor below.\n  static Register index2VirtReg(unsigned Index) {\n    assert(Index < (1u << 31) && \"Index too large for virtual register range.\");\n    return Index | MCRegister::VirtualRegFlag;\n  }\n\n  /// Return true if the specified register number is in the virtual register\n  /// namespace.\n  bool isVirtual() const {\n    return isVirtualRegister(Reg);\n  }\n\n  /// Return true if the specified register number is in the physical register\n  /// namespace.\n  bool isPhysical() const {\n    return isPhysicalRegister(Reg);\n  }\n\n  /// Convert a virtual register number to a 0-based index. The first virtual\n  /// register in a function will get the index 0.\n  unsigned virtRegIndex() const {\n    return virtReg2Index(Reg);\n  }\n\n  constexpr operator unsigned() const {\n    return Reg;\n  }\n\n  unsigned id() const { return Reg; }\n\n  operator MCRegister() const {\n    return MCRegister(Reg);\n  }\n\n  /// Utility to check-convert this value to a MCRegister. The caller is\n  /// expected to have already validated that this Register is, indeed,\n  /// physical.\n  MCRegister asMCReg() const {\n    assert(Reg == MCRegister::NoRegister ||\n           MCRegister::isPhysicalRegister(Reg));\n    return MCRegister(Reg);\n  }\n\n  bool isValid() const { return Reg != MCRegister::NoRegister; }\n\n  /// Comparisons between register objects\n  bool operator==(const Register &Other) const { return Reg == Other.Reg; }\n  bool operator!=(const Register &Other) const { return Reg != Other.Reg; }\n  bool operator==(const MCRegister &Other) const { return Reg == Other.id(); }\n  bool operator!=(const MCRegister &Other) const { return Reg != Other.id(); }\n\n  /// Comparisons against register constants. E.g.\n  /// * R == AArch64::WZR\n  /// * R == 0\n  /// * R == VirtRegMap::NO_PHYS_REG\n  bool operator==(unsigned Other) const { return Reg == Other; }\n  bool operator!=(unsigned Other) const { return Reg != Other; }\n  bool operator==(int Other) const { return Reg == unsigned(Other); }\n  bool operator!=(int Other) const { return Reg != unsigned(Other); }\n  // MSVC requires that we explicitly declare these two as well.\n  bool operator==(MCPhysReg Other) const { return Reg == unsigned(Other); }\n  bool operator!=(MCPhysReg Other) const { return Reg != unsigned(Other); }\n};\n\n// Provide DenseMapInfo for Register\ntemplate<> struct DenseMapInfo<Register> {\n  static inline unsigned getEmptyKey() {\n    return DenseMapInfo<unsigned>::getEmptyKey();\n  }\n  static inline unsigned getTombstoneKey() {\n    return DenseMapInfo<unsigned>::getTombstoneKey();\n  }\n  static unsigned getHashValue(const Register &Val) {\n    return DenseMapInfo<unsigned>::getHashValue(Val.id());\n  }\n  static bool isEqual(const Register &LHS, const Register &RHS) {\n    return DenseMapInfo<unsigned>::isEqual(LHS.id(), RHS.id());\n  }\n};\n\n}\n\n#endif // LLVM_CODEGEN_REGISTER_H\n"}, "33": {"id": 33, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/CodeGen/TargetFrameLowering.h", "content": "//===-- llvm/CodeGen/TargetFrameLowering.h ----------------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// Interface to describe the layout of a stack frame on the target machine.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_CODEGEN_TARGETFRAMELOWERING_H\n#define LLVM_CODEGEN_TARGETFRAMELOWERING_H\n\n#include \"llvm/CodeGen/MachineBasicBlock.h\"\n#include \"llvm/Support/TypeSize.h\"\n#include <vector>\n\nnamespace llvm {\n  class BitVector;\n  class CalleeSavedInfo;\n  class MachineFunction;\n  class RegScavenger;\n\nnamespace TargetStackID {\n  enum Value {\n    Default = 0,\n    SGPRSpill = 1,\n    ScalableVector = 2,\n    NoAlloc = 255\n  };\n}\n\n/// Information about stack frame layout on the target.  It holds the direction\n/// of stack growth, the known stack alignment on entry to each function, and\n/// the offset to the locals area.\n///\n/// The offset to the local area is the offset from the stack pointer on\n/// function entry to the first location where function data (local variables,\n/// spill locations) can be stored.\nclass TargetFrameLowering {\npublic:\n  enum StackDirection {\n    StackGrowsUp,        // Adding to the stack increases the stack address\n    StackGrowsDown       // Adding to the stack decreases the stack address\n  };\n\n  // Maps a callee saved register to a stack slot with a fixed offset.\n  struct SpillSlot {\n    unsigned Reg;\n    int Offset; // Offset relative to stack pointer on function entry.\n  };\n\n  struct DwarfFrameBase {\n    // The frame base may be either a register (the default), the CFA,\n    // or a WebAssembly-specific location description.\n    enum FrameBaseKind { Register, CFA, WasmFrameBase } Kind;\n    struct WasmFrameBase {\n      unsigned Kind; // Wasm local, global, or value stack\n      unsigned Index;\n    };\n    union {\n      unsigned Reg;\n      struct WasmFrameBase WasmLoc;\n    } Location;\n  };\n\nprivate:\n  StackDirection StackDir;\n  Align StackAlignment;\n  Align TransientStackAlignment;\n  int LocalAreaOffset;\n  bool StackRealignable;\npublic:\n  TargetFrameLowering(StackDirection D, Align StackAl, int LAO,\n                      Align TransAl = Align(1), bool StackReal = true)\n      : StackDir(D), StackAlignment(StackAl), TransientStackAlignment(TransAl),\n        LocalAreaOffset(LAO), StackRealignable(StackReal) {}\n\n  virtual ~TargetFrameLowering();\n\n  // These methods return information that describes the abstract stack layout\n  // of the target machine.\n\n  /// getStackGrowthDirection - Return the direction the stack grows\n  ///\n  StackDirection getStackGrowthDirection() const { return StackDir; }\n\n  /// getStackAlignment - This method returns the number of bytes to which the\n  /// stack pointer must be aligned on entry to a function.  Typically, this\n  /// is the largest alignment for any data object in the target.\n  ///\n  unsigned getStackAlignment() const { return StackAlignment.value(); }\n  /// getStackAlignment - This method returns the number of bytes to which the\n  /// stack pointer must be aligned on entry to a function.  Typically, this\n  /// is the largest alignment for any data object in the target.\n  ///\n  Align getStackAlign() const { return StackAlignment; }\n\n  /// alignSPAdjust - This method aligns the stack adjustment to the correct\n  /// alignment.\n  ///\n  int alignSPAdjust(int SPAdj) const {\n    if (SPAdj < 0) {\n      SPAdj = -alignTo(-SPAdj, StackAlignment);\n    } else {\n      SPAdj = alignTo(SPAdj, StackAlignment);\n    }\n    return SPAdj;\n  }\n\n  /// getTransientStackAlignment - This method returns the number of bytes to\n  /// which the stack pointer must be aligned at all times, even between\n  /// calls.\n  ///\n  LLVM_ATTRIBUTE_DEPRECATED(unsigned getTransientStackAlignment() const,\n                            \"Use getTransientStackAlign instead\") {\n    return TransientStackAlignment.value();\n  }\n  /// getTransientStackAlignment - This method returns the number of bytes to\n  /// which the stack pointer must be aligned at all times, even between\n  /// calls.\n  ///\n  Align getTransientStackAlign() const { return TransientStackAlignment; }\n\n  /// isStackRealignable - This method returns whether the stack can be\n  /// realigned.\n  bool isStackRealignable() const {\n    return StackRealignable;\n  }\n\n  /// Return the skew that has to be applied to stack alignment under\n  /// certain conditions (e.g. stack was adjusted before function \\p MF\n  /// was called).\n  virtual unsigned getStackAlignmentSkew(const MachineFunction &MF) const;\n\n  /// This method returns whether or not it is safe for an object with the\n  /// given stack id to be bundled into the local area.\n  virtual bool isStackIdSafeForLocalArea(unsigned StackId) const {\n    return true;\n  }\n\n  /// getOffsetOfLocalArea - This method returns the offset of the local area\n  /// from the stack pointer on entrance to a function.\n  ///\n  int getOffsetOfLocalArea() const { return LocalAreaOffset; }\n\n  /// isFPCloseToIncomingSP - Return true if the frame pointer is close to\n  /// the incoming stack pointer, false if it is close to the post-prologue\n  /// stack pointer.\n  virtual bool isFPCloseToIncomingSP() const { return true; }\n\n  /// assignCalleeSavedSpillSlots - Allows target to override spill slot\n  /// assignment logic.  If implemented, assignCalleeSavedSpillSlots() should\n  /// assign frame slots to all CSI entries and return true.  If this method\n  /// returns false, spill slots will be assigned using generic implementation.\n  /// assignCalleeSavedSpillSlots() may add, delete or rearrange elements of\n  /// CSI.\n  virtual bool\n  assignCalleeSavedSpillSlots(MachineFunction &MF,\n                              const TargetRegisterInfo *TRI,\n                              std::vector<CalleeSavedInfo> &CSI) const {\n    return false;\n  }\n\n  /// getCalleeSavedSpillSlots - This method returns a pointer to an array of\n  /// pairs, that contains an entry for each callee saved register that must be\n  /// spilled to a particular stack location if it is spilled.\n  ///\n  /// Each entry in this array contains a <register,offset> pair, indicating the\n  /// fixed offset from the incoming stack pointer that each register should be\n  /// spilled at. If a register is not listed here, the code generator is\n  /// allowed to spill it anywhere it chooses.\n  ///\n  virtual const SpillSlot *\n  getCalleeSavedSpillSlots(unsigned &NumEntries) const {\n    NumEntries = 0;\n    return nullptr;\n  }\n\n  /// targetHandlesStackFrameRounding - Returns true if the target is\n  /// responsible for rounding up the stack frame (probably at emitPrologue\n  /// time).\n  virtual bool targetHandlesStackFrameRounding() const {\n    return false;\n  }\n\n  /// Returns true if the target will correctly handle shrink wrapping.\n  virtual bool enableShrinkWrapping(const MachineFunction &MF) const {\n    return false;\n  }\n\n  /// Returns true if the stack slot holes in the fixed and callee-save stack\n  /// area should be used when allocating other stack locations to reduce stack\n  /// size.\n  virtual bool enableStackSlotScavenging(const MachineFunction &MF) const {\n    return false;\n  }\n\n  /// Returns true if the target can safely skip saving callee-saved registers\n  /// for noreturn nounwind functions.\n  virtual bool enableCalleeSaveSkip(const MachineFunction &MF) const;\n\n  /// emitProlog/emitEpilog - These methods insert prolog and epilog code into\n  /// the function.\n  virtual void emitPrologue(MachineFunction &MF,\n                            MachineBasicBlock &MBB) const = 0;\n  virtual void emitEpilogue(MachineFunction &MF,\n                            MachineBasicBlock &MBB) const = 0;\n\n  /// With basic block sections, emit callee saved frame moves for basic blocks\n  /// that are in a different section.\n  virtual void\n  emitCalleeSavedFrameMoves(MachineBasicBlock &MBB,\n                            MachineBasicBlock::iterator MBBI) const {}\n\n  virtual void emitCalleeSavedFrameMoves(MachineBasicBlock &MBB,\n                                         MachineBasicBlock::iterator MBBI,\n                                         const DebugLoc &DL,\n                                         bool IsPrologue) const {}\n\n  /// Replace a StackProbe stub (if any) with the actual probe code inline\n  virtual void inlineStackProbe(MachineFunction &MF,\n                                MachineBasicBlock &PrologueMBB) const {}\n\n  /// Adjust the prologue to have the function use segmented stacks. This works\n  /// by adding a check even before the \"normal\" function prologue.\n  virtual void adjustForSegmentedStacks(MachineFunction &MF,\n                                        MachineBasicBlock &PrologueMBB) const {}\n\n  /// Adjust the prologue to add Erlang Run-Time System (ERTS) specific code in\n  /// the assembly prologue to explicitly handle the stack.\n  virtual void adjustForHiPEPrologue(MachineFunction &MF,\n                                     MachineBasicBlock &PrologueMBB) const {}\n\n  /// spillCalleeSavedRegisters - Issues instruction(s) to spill all callee\n  /// saved registers and returns true if it isn't possible / profitable to do\n  /// so by issuing a series of store instructions via\n  /// storeRegToStackSlot(). Returns false otherwise.\n  virtual bool spillCalleeSavedRegisters(MachineBasicBlock &MBB,\n                                         MachineBasicBlock::iterator MI,\n                                         ArrayRef<CalleeSavedInfo> CSI,\n                                         const TargetRegisterInfo *TRI) const {\n    return false;\n  }\n\n  /// restoreCalleeSavedRegisters - Issues instruction(s) to restore all callee\n  /// saved registers and returns true if it isn't possible / profitable to do\n  /// so by issuing a series of load instructions via loadRegToStackSlot().\n  /// If it returns true, and any of the registers in CSI is not restored,\n  /// it sets the corresponding Restored flag in CSI to false.\n  /// Returns false otherwise.\n  virtual bool\n  restoreCalleeSavedRegisters(MachineBasicBlock &MBB,\n                              MachineBasicBlock::iterator MI,\n                              MutableArrayRef<CalleeSavedInfo> CSI,\n                              const TargetRegisterInfo *TRI) const {\n    return false;\n  }\n\n  /// Return true if the target wants to keep the frame pointer regardless of\n  /// the function attribute \"frame-pointer\".\n  virtual bool keepFramePointer(const MachineFunction &MF) const {\n    return false;\n  }\n\n  /// hasFP - Return true if the specified function should have a dedicated\n  /// frame pointer register. For most targets this is true only if the function\n  /// has variable sized allocas or if frame pointer elimination is disabled.\n  virtual bool hasFP(const MachineFunction &MF) const = 0;\n\n  /// hasReservedCallFrame - Under normal circumstances, when a frame pointer is\n  /// not required, we reserve argument space for call sites in the function\n  /// immediately on entry to the current function. This eliminates the need for\n  /// add/sub sp brackets around call sites. Returns true if the call frame is\n  /// included as part of the stack frame.\n  virtual bool hasReservedCallFrame(const MachineFunction &MF) const {\n    return !hasFP(MF);\n  }\n\n  /// canSimplifyCallFramePseudos - When possible, it's best to simplify the\n  /// call frame pseudo ops before doing frame index elimination. This is\n  /// possible only when frame index references between the pseudos won't\n  /// need adjusting for the call frame adjustments. Normally, that's true\n  /// if the function has a reserved call frame or a frame pointer. Some\n  /// targets (Thumb2, for example) may have more complicated criteria,\n  /// however, and can override this behavior.\n  virtual bool canSimplifyCallFramePseudos(const MachineFunction &MF) const {\n    return hasReservedCallFrame(MF) || hasFP(MF);\n  }\n\n  // needsFrameIndexResolution - Do we need to perform FI resolution for\n  // this function. Normally, this is required only when the function\n  // has any stack objects. However, targets may want to override this.\n  virtual bool needsFrameIndexResolution(const MachineFunction &MF) const;\n\n  /// getFrameIndexReference - This method should return the base register\n  /// and offset used to reference a frame index location. The offset is\n  /// returned directly, and the base register is returned via FrameReg.\n  virtual StackOffset getFrameIndexReference(const MachineFunction &MF, int FI,\n                                             Register &FrameReg) const;\n\n  /// Same as \\c getFrameIndexReference, except that the stack pointer (as\n  /// opposed to the frame pointer) will be the preferred value for \\p\n  /// FrameReg. This is generally used for emitting statepoint or EH tables that\n  /// use offsets from RSP.  If \\p IgnoreSPUpdates is true, the returned\n  /// offset is only guaranteed to be valid with respect to the value of SP at\n  /// the end of the prologue.\n  virtual StackOffset\n  getFrameIndexReferencePreferSP(const MachineFunction &MF, int FI,\n                                 Register &FrameReg,\n                                 bool IgnoreSPUpdates) const {\n    // Always safe to dispatch to getFrameIndexReference.\n    return getFrameIndexReference(MF, FI, FrameReg);\n  }\n\n  /// getNonLocalFrameIndexReference - This method returns the offset used to\n  /// reference a frame index location. The offset can be from either FP/BP/SP\n  /// based on which base register is returned by llvm.localaddress.\n  virtual StackOffset getNonLocalFrameIndexReference(const MachineFunction &MF,\n                                                     int FI) const {\n    // By default, dispatch to getFrameIndexReference. Interested targets can\n    // override this.\n    Register FrameReg;\n    return getFrameIndexReference(MF, FI, FrameReg);\n  }\n\n  /// Returns the callee-saved registers as computed by determineCalleeSaves\n  /// in the BitVector \\p SavedRegs.\n  virtual void getCalleeSaves(const MachineFunction &MF,\n                                  BitVector &SavedRegs) const;\n\n  /// This method determines which of the registers reported by\n  /// TargetRegisterInfo::getCalleeSavedRegs() should actually get saved.\n  /// The default implementation checks populates the \\p SavedRegs bitset with\n  /// all registers which are modified in the function, targets may override\n  /// this function to save additional registers.\n  /// This method also sets up the register scavenger ensuring there is a free\n  /// register or a frameindex available.\n  /// This method should not be called by any passes outside of PEI, because\n  /// it may change state passed in by \\p MF and \\p RS. The preferred\n  /// interface outside PEI is getCalleeSaves.\n  virtual void determineCalleeSaves(MachineFunction &MF, BitVector &SavedRegs,\n                                    RegScavenger *RS = nullptr) const;\n\n  /// processFunctionBeforeFrameFinalized - This method is called immediately\n  /// before the specified function's frame layout (MF.getFrameInfo()) is\n  /// finalized.  Once the frame is finalized, MO_FrameIndex operands are\n  /// replaced with direct constants.  This method is optional.\n  ///\n  virtual void processFunctionBeforeFrameFinalized(MachineFunction &MF,\n                                             RegScavenger *RS = nullptr) const {\n  }\n\n  /// processFunctionBeforeFrameIndicesReplaced - This method is called\n  /// immediately before MO_FrameIndex operands are eliminated, but after the\n  /// frame is finalized. This method is optional.\n  virtual void\n  processFunctionBeforeFrameIndicesReplaced(MachineFunction &MF,\n                                            RegScavenger *RS = nullptr) const {}\n\n  virtual unsigned getWinEHParentFrameOffset(const MachineFunction &MF) const {\n    report_fatal_error(\"WinEH not implemented for this target\");\n  }\n\n  /// This method is called during prolog/epilog code insertion to eliminate\n  /// call frame setup and destroy pseudo instructions (but only if the Target\n  /// is using them).  It is responsible for eliminating these instructions,\n  /// replacing them with concrete instructions.  This method need only be\n  /// implemented if using call frame setup/destroy pseudo instructions.\n  /// Returns an iterator pointing to the instruction after the replaced one.\n  virtual MachineBasicBlock::iterator\n  eliminateCallFramePseudoInstr(MachineFunction &MF,\n                                MachineBasicBlock &MBB,\n                                MachineBasicBlock::iterator MI) const {\n    llvm_unreachable(\"Call Frame Pseudo Instructions do not exist on this \"\n                     \"target!\");\n  }\n\n\n  /// Order the symbols in the local stack frame.\n  /// The list of objects that we want to order is in \\p objectsToAllocate as\n  /// indices into the MachineFrameInfo. The array can be reordered in any way\n  /// upon return. The contents of the array, however, may not be modified (i.e.\n  /// only their order may be changed).\n  /// By default, just maintain the original order.\n  virtual void\n  orderFrameObjects(const MachineFunction &MF,\n                    SmallVectorImpl<int> &objectsToAllocate) const {\n  }\n\n  /// Check whether or not the given \\p MBB can be used as a prologue\n  /// for the target.\n  /// The prologue will be inserted first in this basic block.\n  /// This method is used by the shrink-wrapping pass to decide if\n  /// \\p MBB will be correctly handled by the target.\n  /// As soon as the target enable shrink-wrapping without overriding\n  /// this method, we assume that each basic block is a valid\n  /// prologue.\n  virtual bool canUseAsPrologue(const MachineBasicBlock &MBB) const {\n    return true;\n  }\n\n  /// Check whether or not the given \\p MBB can be used as a epilogue\n  /// for the target.\n  /// The epilogue will be inserted before the first terminator of that block.\n  /// This method is used by the shrink-wrapping pass to decide if\n  /// \\p MBB will be correctly handled by the target.\n  /// As soon as the target enable shrink-wrapping without overriding\n  /// this method, we assume that each basic block is a valid\n  /// epilogue.\n  virtual bool canUseAsEpilogue(const MachineBasicBlock &MBB) const {\n    return true;\n  }\n\n  /// Returns the StackID that scalable vectors should be associated with.\n  virtual TargetStackID::Value getStackIDForScalableVectors() const {\n    return TargetStackID::Default;\n  }\n\n  virtual bool isSupportedStackID(TargetStackID::Value ID) const {\n    switch (ID) {\n    default:\n      return false;\n    case TargetStackID::Default:\n    case TargetStackID::NoAlloc:\n      return true;\n    }\n  }\n\n  /// Check if given function is safe for not having callee saved registers.\n  /// This is used when interprocedural register allocation is enabled.\n  static bool isSafeForNoCSROpt(const Function &F);\n\n  /// Check if the no-CSR optimisation is profitable for the given function.\n  virtual bool isProfitableForNoCSROpt(const Function &F) const {\n    return true;\n  }\n\n  /// Return initial CFA offset value i.e. the one valid at the beginning of the\n  /// function (before any stack operations).\n  virtual int getInitialCFAOffset(const MachineFunction &MF) const;\n\n  /// Return initial CFA register value i.e. the one valid at the beginning of\n  /// the function (before any stack operations).\n  virtual Register getInitialCFARegister(const MachineFunction &MF) const;\n\n  /// Return the frame base information to be encoded in the DWARF subprogram\n  /// debug info.\n  virtual DwarfFrameBase getDwarfFrameBase(const MachineFunction &MF) const;\n};\n\n} // End llvm namespace\n\n#endif\n"}, "34": {"id": 34, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/IR/Attributes.h", "content": "//===- llvm/Attributes.h - Container for Attributes -------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n/// \\file\n/// This file contains the simple types necessary to represent the\n/// attributes associated with functions and their calls.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_IR_ATTRIBUTES_H\n#define LLVM_IR_ATTRIBUTES_H\n\n#include \"llvm-c/Types.h\"\n#include \"llvm/ADT/ArrayRef.h\"\n#include \"llvm/ADT/Optional.h\"\n#include \"llvm/ADT/StringRef.h\"\n#include \"llvm/ADT/iterator_range.h\"\n#include \"llvm/Config/llvm-config.h\"\n#include \"llvm/Support/Alignment.h\"\n#include \"llvm/Support/PointerLikeTypeTraits.h\"\n#include <bitset>\n#include <cassert>\n#include <cstdint>\n#include <map>\n#include <string>\n#include <utility>\n\nnamespace llvm {\n\nclass AttrBuilder;\nclass AttributeImpl;\nclass AttributeListImpl;\nclass AttributeSetNode;\ntemplate<typename T> struct DenseMapInfo;\nclass FoldingSetNodeID;\nclass Function;\nclass LLVMContext;\nclass Type;\n\n//===----------------------------------------------------------------------===//\n/// \\class\n/// Functions, function parameters, and return types can have attributes\n/// to indicate how they should be treated by optimizations and code\n/// generation. This class represents one of those attributes. It's light-weight\n/// and should be passed around by-value.\nclass Attribute {\npublic:\n  /// This enumeration lists the attributes that can be associated with\n  /// parameters, function results, or the function itself.\n  ///\n  /// Note: The `uwtable' attribute is about the ABI or the user mandating an\n  /// entry in the unwind table. The `nounwind' attribute is about an exception\n  /// passing by the function.\n  ///\n  /// In a theoretical system that uses tables for profiling and SjLj for\n  /// exceptions, they would be fully independent. In a normal system that uses\n  /// tables for both, the semantics are:\n  ///\n  /// nil                = Needs an entry because an exception might pass by.\n  /// nounwind           = No need for an entry\n  /// uwtable            = Needs an entry because the ABI says so and because\n  ///                      an exception might pass by.\n  /// uwtable + nounwind = Needs an entry because the ABI says so.\n\n  enum AttrKind {\n    // IR-Level Attributes\n    None,                  ///< No attributes have been set\n    #define GET_ATTR_NAMES\n    #define ATTRIBUTE_ENUM(ENUM_NAME, OTHER) ENUM_NAME,\n    #include \"llvm/IR/Attributes.inc\"\n    EndAttrKinds,          ///< Sentinal value useful for loops\n    EmptyKey,              ///< Use as Empty key for DenseMap of AttrKind\n    TombstoneKey,          ///< Use as Tombstone key for DenseMap of AttrKind\n  };\n\nprivate:\n  AttributeImpl *pImpl = nullptr;\n\n  Attribute(AttributeImpl *A) : pImpl(A) {}\n\npublic:\n  Attribute() = default;\n\n  //===--------------------------------------------------------------------===//\n  // Attribute Construction\n  //===--------------------------------------------------------------------===//\n\n  /// Return a uniquified Attribute object.\n  static Attribute get(LLVMContext &Context, AttrKind Kind, uint64_t Val = 0);\n  static Attribute get(LLVMContext &Context, StringRef Kind,\n                       StringRef Val = StringRef());\n  static Attribute get(LLVMContext &Context, AttrKind Kind, Type *Ty);\n\n  /// Return a uniquified Attribute object that has the specific\n  /// alignment set.\n  static Attribute getWithAlignment(LLVMContext &Context, Align Alignment);\n  static Attribute getWithStackAlignment(LLVMContext &Context, Align Alignment);\n  static Attribute getWithDereferenceableBytes(LLVMContext &Context,\n                                              uint64_t Bytes);\n  static Attribute getWithDereferenceableOrNullBytes(LLVMContext &Context,\n                                                     uint64_t Bytes);\n  static Attribute getWithAllocSizeArgs(LLVMContext &Context,\n                                        unsigned ElemSizeArg,\n                                        const Optional<unsigned> &NumElemsArg);\n  static Attribute getWithByValType(LLVMContext &Context, Type *Ty);\n  static Attribute getWithStructRetType(LLVMContext &Context, Type *Ty);\n  static Attribute getWithByRefType(LLVMContext &Context, Type *Ty);\n  static Attribute getWithPreallocatedType(LLVMContext &Context, Type *Ty);\n\n  /// For a typed attribute, return the equivalent attribute with the type\n  /// changed to \\p ReplacementTy.\n  Attribute getWithNewType(LLVMContext &Context, Type *ReplacementTy) {\n    assert(isTypeAttribute() && \"this requires a typed attribute\");\n    return get(Context, getKindAsEnum(), ReplacementTy);\n  }\n\n  static Attribute::AttrKind getAttrKindFromName(StringRef AttrName);\n\n  static StringRef getNameFromAttrKind(Attribute::AttrKind AttrKind);\n\n  /// Return true if and only if the attribute has an Argument.\n  static bool doesAttrKindHaveArgument(Attribute::AttrKind AttrKind);\n\n  /// Return true if the provided string matches the IR name of an attribute.\n  /// example: \"noalias\" return true but not \"NoAlias\"\n  static bool isExistingAttribute(StringRef Name);\n\n  //===--------------------------------------------------------------------===//\n  // Attribute Accessors\n  //===--------------------------------------------------------------------===//\n\n  /// Return true if the attribute is an Attribute::AttrKind type.\n  bool isEnumAttribute() const;\n\n  /// Return true if the attribute is an integer attribute.\n  bool isIntAttribute() const;\n\n  /// Return true if the attribute is a string (target-dependent)\n  /// attribute.\n  bool isStringAttribute() const;\n\n  /// Return true if the attribute is a type attribute.\n  bool isTypeAttribute() const;\n\n  /// Return true if the attribute is any kind of attribute.\n  bool isValid() const { return pImpl; }\n\n  /// Return true if the attribute is present.\n  bool hasAttribute(AttrKind Val) const;\n\n  /// Return true if the target-dependent attribute is present.\n  bool hasAttribute(StringRef Val) const;\n\n  /// Return the attribute's kind as an enum (Attribute::AttrKind). This\n  /// requires the attribute to be an enum or integer attribute.\n  Attribute::AttrKind getKindAsEnum() const;\n\n  /// Return the attribute's value as an integer. This requires that the\n  /// attribute be an integer attribute.\n  uint64_t getValueAsInt() const;\n\n  /// Return the attribute's kind as a string. This requires the\n  /// attribute to be a string attribute.\n  StringRef getKindAsString() const;\n\n  /// Return the attribute's value as a string. This requires the\n  /// attribute to be a string attribute.\n  StringRef getValueAsString() const;\n\n  /// Return the attribute's value as a Type. This requires the attribute to be\n  /// a type attribute.\n  Type *getValueAsType() const;\n\n  /// Returns the alignment field of an attribute as a byte alignment\n  /// value.\n  MaybeAlign getAlignment() const;\n\n  /// Returns the stack alignment field of an attribute as a byte\n  /// alignment value.\n  MaybeAlign getStackAlignment() const;\n\n  /// Returns the number of dereferenceable bytes from the\n  /// dereferenceable attribute.\n  uint64_t getDereferenceableBytes() const;\n\n  /// Returns the number of dereferenceable_or_null bytes from the\n  /// dereferenceable_or_null attribute.\n  uint64_t getDereferenceableOrNullBytes() const;\n\n  /// Returns the argument numbers for the allocsize attribute (or pair(0, 0)\n  /// if not known).\n  std::pair<unsigned, Optional<unsigned>> getAllocSizeArgs() const;\n\n  /// The Attribute is converted to a string of equivalent mnemonic. This\n  /// is, presumably, for writing out the mnemonics for the assembly writer.\n  std::string getAsString(bool InAttrGrp = false) const;\n\n  /// Equality and non-equality operators.\n  bool operator==(Attribute A) const { return pImpl == A.pImpl; }\n  bool operator!=(Attribute A) const { return pImpl != A.pImpl; }\n\n  /// Less-than operator. Useful for sorting the attributes list.\n  bool operator<(Attribute A) const;\n\n  void Profile(FoldingSetNodeID &ID) const;\n\n  /// Return a raw pointer that uniquely identifies this attribute.\n  void *getRawPointer() const {\n    return pImpl;\n  }\n\n  /// Get an attribute from a raw pointer created by getRawPointer.\n  static Attribute fromRawPointer(void *RawPtr) {\n    return Attribute(reinterpret_cast<AttributeImpl*>(RawPtr));\n  }\n};\n\n// Specialized opaque value conversions.\ninline LLVMAttributeRef wrap(Attribute Attr) {\n  return reinterpret_cast<LLVMAttributeRef>(Attr.getRawPointer());\n}\n\n// Specialized opaque value conversions.\ninline Attribute unwrap(LLVMAttributeRef Attr) {\n  return Attribute::fromRawPointer(Attr);\n}\n\n//===----------------------------------------------------------------------===//\n/// \\class\n/// This class holds the attributes for a particular argument, parameter,\n/// function, or return value. It is an immutable value type that is cheap to\n/// copy. Adding and removing enum attributes is intended to be fast, but adding\n/// and removing string or integer attributes involves a FoldingSet lookup.\nclass AttributeSet {\n  friend AttributeListImpl;\n  template <typename Ty> friend struct DenseMapInfo;\n\n  // TODO: Extract AvailableAttrs from AttributeSetNode and store them here.\n  // This will allow an efficient implementation of addAttribute and\n  // removeAttribute for enum attrs.\n\n  /// Private implementation pointer.\n  AttributeSetNode *SetNode = nullptr;\n\nprivate:\n  explicit AttributeSet(AttributeSetNode *ASN) : SetNode(ASN) {}\n\npublic:\n  /// AttributeSet is a trivially copyable value type.\n  AttributeSet() = default;\n  AttributeSet(const AttributeSet &) = default;\n  ~AttributeSet() = default;\n\n  static AttributeSet get(LLVMContext &C, const AttrBuilder &B);\n  static AttributeSet get(LLVMContext &C, ArrayRef<Attribute> Attrs);\n\n  bool operator==(const AttributeSet &O) const { return SetNode == O.SetNode; }\n  bool operator!=(const AttributeSet &O) const { return !(*this == O); }\n\n  /// Add an argument attribute. Returns a new set because attribute sets are\n  /// immutable.\n  LLVM_NODISCARD AttributeSet addAttribute(LLVMContext &C,\n                                           Attribute::AttrKind Kind) const;\n\n  /// Add a target-dependent attribute. Returns a new set because attribute sets\n  /// are immutable.\n  LLVM_NODISCARD AttributeSet addAttribute(LLVMContext &C, StringRef Kind,\n                                           StringRef Value = StringRef()) const;\n\n  /// Add attributes to the attribute set. Returns a new set because attribute\n  /// sets are immutable.\n  LLVM_NODISCARD AttributeSet addAttributes(LLVMContext &C,\n                                            AttributeSet AS) const;\n\n  /// Remove the specified attribute from this set. Returns a new set because\n  /// attribute sets are immutable.\n  LLVM_NODISCARD AttributeSet removeAttribute(LLVMContext &C,\n                                              Attribute::AttrKind Kind) const;\n\n  /// Remove the specified attribute from this set. Returns a new set because\n  /// attribute sets are immutable.\n  LLVM_NODISCARD AttributeSet removeAttribute(LLVMContext &C,\n                                              StringRef Kind) const;\n\n  /// Remove the specified attributes from this set. Returns a new set because\n  /// attribute sets are immutable.\n  LLVM_NODISCARD AttributeSet\n  removeAttributes(LLVMContext &C, const AttrBuilder &AttrsToRemove) const;\n\n  /// Return the number of attributes in this set.\n  unsigned getNumAttributes() const;\n\n  /// Return true if attributes exists in this set.\n  bool hasAttributes() const { return SetNode != nullptr; }\n\n  /// Return true if the attribute exists in this set.\n  bool hasAttribute(Attribute::AttrKind Kind) const;\n\n  /// Return true if the attribute exists in this set.\n  bool hasAttribute(StringRef Kind) const;\n\n  /// Return the attribute object.\n  Attribute getAttribute(Attribute::AttrKind Kind) const;\n\n  /// Return the target-dependent attribute object.\n  Attribute getAttribute(StringRef Kind) const;\n\n  MaybeAlign getAlignment() const;\n  MaybeAlign getStackAlignment() const;\n  uint64_t getDereferenceableBytes() const;\n  uint64_t getDereferenceableOrNullBytes() const;\n  Type *getByValType() const;\n  Type *getStructRetType() const;\n  Type *getByRefType() const;\n  Type *getPreallocatedType() const;\n  std::pair<unsigned, Optional<unsigned>> getAllocSizeArgs() const;\n  std::string getAsString(bool InAttrGrp = false) const;\n\n  using iterator = const Attribute *;\n\n  iterator begin() const;\n  iterator end() const;\n#if !defined(NDEBUG) || defined(LLVM_ENABLE_DUMP)\n  void dump() const;\n#endif\n};\n\n//===----------------------------------------------------------------------===//\n/// \\class\n/// Provide DenseMapInfo for AttributeSet.\ntemplate <> struct DenseMapInfo<AttributeSet> {\n  static AttributeSet getEmptyKey() {\n    auto Val = static_cast<uintptr_t>(-1);\n    Val <<= PointerLikeTypeTraits<void *>::NumLowBitsAvailable;\n    return AttributeSet(reinterpret_cast<AttributeSetNode *>(Val));\n  }\n\n  static AttributeSet getTombstoneKey() {\n    auto Val = static_cast<uintptr_t>(-2);\n    Val <<= PointerLikeTypeTraits<void *>::NumLowBitsAvailable;\n    return AttributeSet(reinterpret_cast<AttributeSetNode *>(Val));\n  }\n\n  static unsigned getHashValue(AttributeSet AS) {\n    return (unsigned((uintptr_t)AS.SetNode) >> 4) ^\n           (unsigned((uintptr_t)AS.SetNode) >> 9);\n  }\n\n  static bool isEqual(AttributeSet LHS, AttributeSet RHS) { return LHS == RHS; }\n};\n\n//===----------------------------------------------------------------------===//\n/// \\class\n/// This class holds the attributes for a function, its return value, and\n/// its parameters. You access the attributes for each of them via an index into\n/// the AttributeList object. The function attributes are at index\n/// `AttributeList::FunctionIndex', the return value is at index\n/// `AttributeList::ReturnIndex', and the attributes for the parameters start at\n/// index `AttributeList::FirstArgIndex'.\nclass AttributeList {\npublic:\n  enum AttrIndex : unsigned {\n    ReturnIndex = 0U,\n    FunctionIndex = ~0U,\n    FirstArgIndex = 1,\n  };\n\nprivate:\n  friend class AttrBuilder;\n  friend class AttributeListImpl;\n  friend class AttributeSet;\n  friend class AttributeSetNode;\n  template <typename Ty> friend struct DenseMapInfo;\n\n  /// The attributes that we are managing. This can be null to represent\n  /// the empty attributes list.\n  AttributeListImpl *pImpl = nullptr;\n\npublic:\n  /// Create an AttributeList with the specified parameters in it.\n  static AttributeList get(LLVMContext &C,\n                           ArrayRef<std::pair<unsigned, Attribute>> Attrs);\n  static AttributeList get(LLVMContext &C,\n                           ArrayRef<std::pair<unsigned, AttributeSet>> Attrs);\n\n  /// Create an AttributeList from attribute sets for a function, its\n  /// return value, and all of its arguments.\n  static AttributeList get(LLVMContext &C, AttributeSet FnAttrs,\n                           AttributeSet RetAttrs,\n                           ArrayRef<AttributeSet> ArgAttrs);\n\nprivate:\n  explicit AttributeList(AttributeListImpl *LI) : pImpl(LI) {}\n\n  static AttributeList getImpl(LLVMContext &C, ArrayRef<AttributeSet> AttrSets);\n\n  AttributeList setAttributes(LLVMContext &C, unsigned Index,\n                              AttributeSet Attrs) const;\n\npublic:\n  AttributeList() = default;\n\n  //===--------------------------------------------------------------------===//\n  // AttributeList Construction and Mutation\n  //===--------------------------------------------------------------------===//\n\n  /// Return an AttributeList with the specified parameters in it.\n  static AttributeList get(LLVMContext &C, ArrayRef<AttributeList> Attrs);\n  static AttributeList get(LLVMContext &C, unsigned Index,\n                           ArrayRef<Attribute::AttrKind> Kinds);\n  static AttributeList get(LLVMContext &C, unsigned Index,\n                           ArrayRef<Attribute::AttrKind> Kinds,\n                           ArrayRef<uint64_t> Values);\n  static AttributeList get(LLVMContext &C, unsigned Index,\n                           ArrayRef<StringRef> Kind);\n  static AttributeList get(LLVMContext &C, unsigned Index,\n                           const AttrBuilder &B);\n\n  /// Add an attribute to the attribute set at the given index.\n  /// Returns a new list because attribute lists are immutable.\n  LLVM_NODISCARD AttributeList addAttribute(LLVMContext &C, unsigned Index,\n                                            Attribute::AttrKind Kind) const;\n\n  /// Add an attribute to the attribute set at the given index.\n  /// Returns a new list because attribute lists are immutable.\n  LLVM_NODISCARD AttributeList\n  addAttribute(LLVMContext &C, unsigned Index, StringRef Kind,\n               StringRef Value = StringRef()) const;\n\n  /// Add an attribute to the attribute set at the given index.\n  /// Returns a new list because attribute lists are immutable.\n  LLVM_NODISCARD AttributeList addAttribute(LLVMContext &C, unsigned Index,\n                                            Attribute A) const;\n\n  /// Add attributes to the attribute set at the given index.\n  /// Returns a new list because attribute lists are immutable.\n  LLVM_NODISCARD AttributeList addAttributes(LLVMContext &C, unsigned Index,\n                                             const AttrBuilder &B) const;\n\n  /// Add an argument attribute to the list. Returns a new list because\n  /// attribute lists are immutable.\n  LLVM_NODISCARD AttributeList addParamAttribute(\n      LLVMContext &C, unsigned ArgNo, Attribute::AttrKind Kind) const {\n    return addAttribute(C, ArgNo + FirstArgIndex, Kind);\n  }\n\n  /// Add an argument attribute to the list. Returns a new list because\n  /// attribute lists are immutable.\n  LLVM_NODISCARD AttributeList\n  addParamAttribute(LLVMContext &C, unsigned ArgNo, StringRef Kind,\n                    StringRef Value = StringRef()) const {\n    return addAttribute(C, ArgNo + FirstArgIndex, Kind, Value);\n  }\n\n  /// Add an attribute to the attribute list at the given arg indices. Returns a\n  /// new list because attribute lists are immutable.\n  LLVM_NODISCARD AttributeList addParamAttribute(LLVMContext &C,\n                                                 ArrayRef<unsigned> ArgNos,\n                                                 Attribute A) const;\n\n  /// Add an argument attribute to the list. Returns a new list because\n  /// attribute lists are immutable.\n  LLVM_NODISCARD AttributeList addParamAttributes(LLVMContext &C,\n                                                  unsigned ArgNo,\n                                                  const AttrBuilder &B) const {\n    return addAttributes(C, ArgNo + FirstArgIndex, B);\n  }\n\n  /// Remove the specified attribute at the specified index from this\n  /// attribute list. Returns a new list because attribute lists are immutable.\n  LLVM_NODISCARD AttributeList removeAttribute(LLVMContext &C, unsigned Index,\n                                               Attribute::AttrKind Kind) const;\n\n  /// Remove the specified attribute at the specified index from this\n  /// attribute list. Returns a new list because attribute lists are immutable.\n  LLVM_NODISCARD AttributeList removeAttribute(LLVMContext &C, unsigned Index,\n                                               StringRef Kind) const;\n\n  /// Remove the specified attributes at the specified index from this\n  /// attribute list. Returns a new list because attribute lists are immutable.\n  LLVM_NODISCARD AttributeList removeAttributes(\n      LLVMContext &C, unsigned Index, const AttrBuilder &AttrsToRemove) const;\n\n  /// Remove all attributes at the specified index from this\n  /// attribute list. Returns a new list because attribute lists are immutable.\n  LLVM_NODISCARD AttributeList removeAttributes(LLVMContext &C,\n                                                unsigned Index) const;\n\n  /// Remove the specified attribute at the specified arg index from this\n  /// attribute list. Returns a new list because attribute lists are immutable.\n  LLVM_NODISCARD AttributeList removeParamAttribute(\n      LLVMContext &C, unsigned ArgNo, Attribute::AttrKind Kind) const {\n    return removeAttribute(C, ArgNo + FirstArgIndex, Kind);\n  }\n\n  /// Remove the specified attribute at the specified arg index from this\n  /// attribute list. Returns a new list because attribute lists are immutable.\n  LLVM_NODISCARD AttributeList removeParamAttribute(LLVMContext &C,\n                                                    unsigned ArgNo,\n                                                    StringRef Kind) const {\n    return removeAttribute(C, ArgNo + FirstArgIndex, Kind);\n  }\n\n  /// Remove the specified attribute at the specified arg index from this\n  /// attribute list. Returns a new list because attribute lists are immutable.\n  LLVM_NODISCARD AttributeList removeParamAttributes(\n      LLVMContext &C, unsigned ArgNo, const AttrBuilder &AttrsToRemove) const {\n    return removeAttributes(C, ArgNo + FirstArgIndex, AttrsToRemove);\n  }\n\n  /// Remove all attributes at the specified arg index from this\n  /// attribute list. Returns a new list because attribute lists are immutable.\n  LLVM_NODISCARD AttributeList removeParamAttributes(LLVMContext &C,\n                                                     unsigned ArgNo) const {\n    return removeAttributes(C, ArgNo + FirstArgIndex);\n  }\n\n  /// Replace the type contained by attribute \\p AttrKind at index \\p ArgNo wih\n  /// \\p ReplacementTy, preserving all other attributes.\n  LLVM_NODISCARD AttributeList replaceAttributeType(LLVMContext &C,\n                                                    unsigned ArgNo,\n                                                    Attribute::AttrKind Kind,\n                                                    Type *ReplacementTy) const {\n    Attribute Attr = getAttribute(ArgNo, Kind);\n    auto Attrs = removeAttribute(C, ArgNo, Kind);\n    return Attrs.addAttribute(C, ArgNo, Attr.getWithNewType(C, ReplacementTy));\n  }\n\n  /// \\brief Add the dereferenceable attribute to the attribute set at the given\n  /// index. Returns a new list because attribute lists are immutable.\n  LLVM_NODISCARD AttributeList addDereferenceableAttr(LLVMContext &C,\n                                                      unsigned Index,\n                                                      uint64_t Bytes) const;\n\n  /// \\brief Add the dereferenceable attribute to the attribute set at the given\n  /// arg index. Returns a new list because attribute lists are immutable.\n  LLVM_NODISCARD AttributeList addDereferenceableParamAttr(\n      LLVMContext &C, unsigned ArgNo, uint64_t Bytes) const {\n    return addDereferenceableAttr(C, ArgNo + FirstArgIndex, Bytes);\n  }\n\n  /// Add the dereferenceable_or_null attribute to the attribute set at\n  /// the given index. Returns a new list because attribute lists are immutable.\n  LLVM_NODISCARD AttributeList addDereferenceableOrNullAttr(\n      LLVMContext &C, unsigned Index, uint64_t Bytes) const;\n\n  /// Add the dereferenceable_or_null attribute to the attribute set at\n  /// the given arg index. Returns a new list because attribute lists are\n  /// immutable.\n  LLVM_NODISCARD AttributeList addDereferenceableOrNullParamAttr(\n      LLVMContext &C, unsigned ArgNo, uint64_t Bytes) const {\n    return addDereferenceableOrNullAttr(C, ArgNo + FirstArgIndex, Bytes);\n  }\n\n  /// Add the allocsize attribute to the attribute set at the given index.\n  /// Returns a new list because attribute lists are immutable.\n  LLVM_NODISCARD AttributeList\n  addAllocSizeAttr(LLVMContext &C, unsigned Index, unsigned ElemSizeArg,\n                   const Optional<unsigned> &NumElemsArg);\n\n  /// Add the allocsize attribute to the attribute set at the given arg index.\n  /// Returns a new list because attribute lists are immutable.\n  LLVM_NODISCARD AttributeList\n  addAllocSizeParamAttr(LLVMContext &C, unsigned ArgNo, unsigned ElemSizeArg,\n                        const Optional<unsigned> &NumElemsArg) {\n    return addAllocSizeAttr(C, ArgNo + FirstArgIndex, ElemSizeArg, NumElemsArg);\n  }\n\n  //===--------------------------------------------------------------------===//\n  // AttributeList Accessors\n  //===--------------------------------------------------------------------===//\n\n  /// The attributes for the specified index are returned.\n  AttributeSet getAttributes(unsigned Index) const;\n\n  /// The attributes for the argument or parameter at the given index are\n  /// returned.\n  AttributeSet getParamAttributes(unsigned ArgNo) const;\n\n  /// The attributes for the ret value are returned.\n  AttributeSet getRetAttributes() const;\n\n  /// The function attributes are returned.\n  AttributeSet getFnAttributes() const;\n\n  /// Return true if the attribute exists at the given index.\n  bool hasAttribute(unsigned Index, Attribute::AttrKind Kind) const;\n\n  /// Return true if the attribute exists at the given index.\n  bool hasAttribute(unsigned Index, StringRef Kind) const;\n\n  /// Return true if attribute exists at the given index.\n  bool hasAttributes(unsigned Index) const;\n\n  /// Return true if the attribute exists for the given argument\n  bool hasParamAttr(unsigned ArgNo, Attribute::AttrKind Kind) const {\n    return hasAttribute(ArgNo + FirstArgIndex, Kind);\n  }\n\n  /// Return true if the attribute exists for the given argument\n  bool hasParamAttr(unsigned ArgNo, StringRef Kind) const {\n    return hasAttribute(ArgNo + FirstArgIndex, Kind);\n  }\n\n  /// Return true if attributes exists for the given argument\n  bool hasParamAttrs(unsigned ArgNo) const {\n    return hasAttributes(ArgNo + FirstArgIndex);\n  }\n\n  /// Equivalent to hasAttribute(AttributeList::FunctionIndex, Kind) but\n  /// may be faster.\n  bool hasFnAttribute(Attribute::AttrKind Kind) const;\n\n  /// Equivalent to hasAttribute(AttributeList::FunctionIndex, Kind) but\n  /// may be faster.\n  bool hasFnAttribute(StringRef Kind) const;\n\n  /// Equivalent to hasAttribute(ArgNo + FirstArgIndex, Kind).\n  bool hasParamAttribute(unsigned ArgNo, Attribute::AttrKind Kind) const;\n\n  /// Return true if the specified attribute is set for at least one\n  /// parameter or for the return value. If Index is not nullptr, the index\n  /// of a parameter with the specified attribute is provided.\n  bool hasAttrSomewhere(Attribute::AttrKind Kind,\n                        unsigned *Index = nullptr) const;\n\n  /// Return the attribute object that exists at the given index.\n  Attribute getAttribute(unsigned Index, Attribute::AttrKind Kind) const;\n\n  /// Return the attribute object that exists at the given index.\n  Attribute getAttribute(unsigned Index, StringRef Kind) const;\n\n  /// Return the attribute object that exists at the arg index.\n  Attribute getParamAttr(unsigned ArgNo, Attribute::AttrKind Kind) const {\n    return getAttribute(ArgNo + FirstArgIndex, Kind);\n  }\n\n  /// Return the attribute object that exists at the given index.\n  Attribute getParamAttr(unsigned ArgNo, StringRef Kind) const {\n    return getAttribute(ArgNo + FirstArgIndex, Kind);\n  }\n\n  /// Return the alignment of the return value.\n  MaybeAlign getRetAlignment() const;\n\n  /// Return the alignment for the specified function parameter.\n  MaybeAlign getParamAlignment(unsigned ArgNo) const;\n\n  /// Return the byval type for the specified function parameter.\n  Type *getParamByValType(unsigned ArgNo) const;\n\n  /// Return the sret type for the specified function parameter.\n  Type *getParamStructRetType(unsigned ArgNo) const;\n\n  /// Return the byref type for the specified function parameter.\n  Type *getParamByRefType(unsigned ArgNo) const;\n\n  /// Return the preallocated type for the specified function parameter.\n  Type *getParamPreallocatedType(unsigned ArgNo) const;\n\n  /// Get the stack alignment.\n  MaybeAlign getStackAlignment(unsigned Index) const;\n\n  /// Get the number of dereferenceable bytes (or zero if unknown).\n  uint64_t getDereferenceableBytes(unsigned Index) const;\n\n  /// Get the number of dereferenceable bytes (or zero if unknown) of an\n  /// arg.\n  uint64_t getParamDereferenceableBytes(unsigned ArgNo) const {\n    return getDereferenceableBytes(ArgNo + FirstArgIndex);\n  }\n\n  /// Get the number of dereferenceable_or_null bytes (or zero if\n  /// unknown).\n  uint64_t getDereferenceableOrNullBytes(unsigned Index) const;\n\n  /// Get the number of dereferenceable_or_null bytes (or zero if\n  /// unknown) of an arg.\n  uint64_t getParamDereferenceableOrNullBytes(unsigned ArgNo) const {\n    return getDereferenceableOrNullBytes(ArgNo + FirstArgIndex);\n  }\n\n  /// Get the allocsize argument numbers (or pair(0, 0) if unknown).\n  std::pair<unsigned, Optional<unsigned>>\n  getAllocSizeArgs(unsigned Index) const;\n\n  /// Return the attributes at the index as a string.\n  std::string getAsString(unsigned Index, bool InAttrGrp = false) const;\n\n  //===--------------------------------------------------------------------===//\n  // AttributeList Introspection\n  //===--------------------------------------------------------------------===//\n\n  using iterator = const AttributeSet *;\n\n  iterator begin() const;\n  iterator end() const;\n\n  unsigned getNumAttrSets() const;\n\n  /// Use these to iterate over the valid attribute indices.\n  unsigned index_begin() const { return AttributeList::FunctionIndex; }\n  unsigned index_end() const { return getNumAttrSets() - 1; }\n\n  /// operator==/!= - Provide equality predicates.\n  bool operator==(const AttributeList &RHS) const { return pImpl == RHS.pImpl; }\n  bool operator!=(const AttributeList &RHS) const { return pImpl != RHS.pImpl; }\n\n  /// Return a raw pointer that uniquely identifies this attribute list.\n  void *getRawPointer() const {\n    return pImpl;\n  }\n\n  /// Return true if there are no attributes.\n  bool isEmpty() const { return pImpl == nullptr; }\n\n  void dump() const;\n};\n\n//===----------------------------------------------------------------------===//\n/// \\class\n/// Provide DenseMapInfo for AttributeList.\ntemplate <> struct DenseMapInfo<AttributeList> {\n  static AttributeList getEmptyKey() {\n    auto Val = static_cast<uintptr_t>(-1);\n    Val <<= PointerLikeTypeTraits<void*>::NumLowBitsAvailable;\n    return AttributeList(reinterpret_cast<AttributeListImpl *>(Val));\n  }\n\n  static AttributeList getTombstoneKey() {\n    auto Val = static_cast<uintptr_t>(-2);\n    Val <<= PointerLikeTypeTraits<void*>::NumLowBitsAvailable;\n    return AttributeList(reinterpret_cast<AttributeListImpl *>(Val));\n  }\n\n  static unsigned getHashValue(AttributeList AS) {\n    return (unsigned((uintptr_t)AS.pImpl) >> 4) ^\n           (unsigned((uintptr_t)AS.pImpl) >> 9);\n  }\n\n  static bool isEqual(AttributeList LHS, AttributeList RHS) {\n    return LHS == RHS;\n  }\n};\n\n//===----------------------------------------------------------------------===//\n/// \\class\n/// This class is used in conjunction with the Attribute::get method to\n/// create an Attribute object. The object itself is uniquified. The Builder's\n/// value, however, is not. So this can be used as a quick way to test for\n/// equality, presence of attributes, etc.\nclass AttrBuilder {\n  std::bitset<Attribute::EndAttrKinds> Attrs;\n  std::map<std::string, std::string, std::less<>> TargetDepAttrs;\n  MaybeAlign Alignment;\n  MaybeAlign StackAlignment;\n  uint64_t DerefBytes = 0;\n  uint64_t DerefOrNullBytes = 0;\n  uint64_t AllocSizeArgs = 0;\n  Type *ByValType = nullptr;\n  Type *StructRetType = nullptr;\n  Type *ByRefType = nullptr;\n  Type *PreallocatedType = nullptr;\n\npublic:\n  AttrBuilder() = default;\n\n  AttrBuilder(const Attribute &A) {\n    addAttribute(A);\n  }\n\n  AttrBuilder(AttributeList AS, unsigned Idx);\n  AttrBuilder(AttributeSet AS);\n\n  void clear();\n\n  /// Add an attribute to the builder.\n  AttrBuilder &addAttribute(Attribute::AttrKind Val) {\n    assert((unsigned)Val < Attribute::EndAttrKinds &&\n           \"Attribute out of range!\");\n    assert(!Attribute::doesAttrKindHaveArgument(Val) &&\n           \"Adding integer attribute without adding a value!\");\n    Attrs[Val] = true;\n    return *this;\n  }\n\n  /// Add the Attribute object to the builder.\n  AttrBuilder &addAttribute(Attribute A);\n\n  /// Add the target-dependent attribute to the builder.\n  AttrBuilder &addAttribute(StringRef A, StringRef V = StringRef());\n\n  /// Remove an attribute from the builder.\n  AttrBuilder &removeAttribute(Attribute::AttrKind Val);\n\n  /// Remove the attributes from the builder.\n  AttrBuilder &removeAttributes(AttributeList A, uint64_t WithoutIndex);\n\n  /// Remove the target-dependent attribute to the builder.\n  AttrBuilder &removeAttribute(StringRef A);\n\n  /// Add the attributes from the builder.\n  AttrBuilder &merge(const AttrBuilder &B);\n\n  /// Remove the attributes from the builder.\n  AttrBuilder &remove(const AttrBuilder &B);\n\n  /// Return true if the builder has any attribute that's in the\n  /// specified builder.\n  bool overlaps(const AttrBuilder &B) const;\n\n  /// Return true if the builder has the specified attribute.\n  bool contains(Attribute::AttrKind A) const {\n    assert((unsigned)A < Attribute::EndAttrKinds && \"Attribute out of range!\");\n    return Attrs[A];\n  }\n\n  /// Return true if the builder has the specified target-dependent\n  /// attribute.\n  bool contains(StringRef A) const;\n\n  /// Return true if the builder has IR-level attributes.\n  bool hasAttributes() const;\n\n  /// Return true if the builder has any attribute that's in the\n  /// specified attribute.\n  bool hasAttributes(AttributeList A, uint64_t Index) const;\n\n  /// Return true if the builder has an alignment attribute.\n  bool hasAlignmentAttr() const;\n\n  /// Retrieve the alignment attribute, if it exists.\n  MaybeAlign getAlignment() const { return Alignment; }\n\n  /// Retrieve the stack alignment attribute, if it exists.\n  MaybeAlign getStackAlignment() const { return StackAlignment; }\n\n  /// Retrieve the number of dereferenceable bytes, if the\n  /// dereferenceable attribute exists (zero is returned otherwise).\n  uint64_t getDereferenceableBytes() const { return DerefBytes; }\n\n  /// Retrieve the number of dereferenceable_or_null bytes, if the\n  /// dereferenceable_or_null attribute exists (zero is returned otherwise).\n  uint64_t getDereferenceableOrNullBytes() const { return DerefOrNullBytes; }\n\n  /// Retrieve the byval type.\n  Type *getByValType() const { return ByValType; }\n\n  /// Retrieve the sret type.\n  Type *getStructRetType() const { return StructRetType; }\n\n  /// Retrieve the byref type.\n  Type *getByRefType() const { return ByRefType; }\n\n  /// Retrieve the preallocated type.\n  Type *getPreallocatedType() const { return PreallocatedType; }\n\n  /// Retrieve the allocsize args, if the allocsize attribute exists.  If it\n  /// doesn't exist, pair(0, 0) is returned.\n  std::pair<unsigned, Optional<unsigned>> getAllocSizeArgs() const;\n\n  /// This turns an alignment into the form used internally in Attribute.\n  /// This call has no effect if Align is not set.\n  AttrBuilder &addAlignmentAttr(MaybeAlign Align);\n\n  /// This turns an int alignment (which must be a power of 2) into the\n  /// form used internally in Attribute.\n  /// This call has no effect if Align is 0.\n  /// Deprecated, use the version using a MaybeAlign.\n  inline AttrBuilder &addAlignmentAttr(unsigned Align) {\n    return addAlignmentAttr(MaybeAlign(Align));\n  }\n\n  /// This turns a stack alignment into the form used internally in Attribute.\n  /// This call has no effect if Align is not set.\n  AttrBuilder &addStackAlignmentAttr(MaybeAlign Align);\n\n  /// This turns an int stack alignment (which must be a power of 2) into\n  /// the form used internally in Attribute.\n  /// This call has no effect if Align is 0.\n  /// Deprecated, use the version using a MaybeAlign.\n  inline AttrBuilder &addStackAlignmentAttr(unsigned Align) {\n    return addStackAlignmentAttr(MaybeAlign(Align));\n  }\n\n  /// This turns the number of dereferenceable bytes into the form used\n  /// internally in Attribute.\n  AttrBuilder &addDereferenceableAttr(uint64_t Bytes);\n\n  /// This turns the number of dereferenceable_or_null bytes into the\n  /// form used internally in Attribute.\n  AttrBuilder &addDereferenceableOrNullAttr(uint64_t Bytes);\n\n  /// This turns one (or two) ints into the form used internally in Attribute.\n  AttrBuilder &addAllocSizeAttr(unsigned ElemSizeArg,\n                                const Optional<unsigned> &NumElemsArg);\n\n  /// This turns a byval type into the form used internally in Attribute.\n  AttrBuilder &addByValAttr(Type *Ty);\n\n  /// This turns a sret type into the form used internally in Attribute.\n  AttrBuilder &addStructRetAttr(Type *Ty);\n\n  /// This turns a byref type into the form used internally in Attribute.\n  AttrBuilder &addByRefAttr(Type *Ty);\n\n  /// This turns a preallocated type into the form used internally in Attribute.\n  AttrBuilder &addPreallocatedAttr(Type *Ty);\n\n  /// Add an allocsize attribute, using the representation returned by\n  /// Attribute.getIntValue().\n  AttrBuilder &addAllocSizeAttrFromRawRepr(uint64_t RawAllocSizeRepr);\n\n  /// Return true if the builder contains no target-independent\n  /// attributes.\n  bool empty() const { return Attrs.none(); }\n\n  // Iterators for target-dependent attributes.\n  using td_type = std::pair<std::string, std::string>;\n  using td_iterator = decltype(TargetDepAttrs)::iterator;\n  using td_const_iterator = decltype(TargetDepAttrs)::const_iterator;\n  using td_range = iterator_range<td_iterator>;\n  using td_const_range = iterator_range<td_const_iterator>;\n\n  td_iterator td_begin() { return TargetDepAttrs.begin(); }\n  td_iterator td_end() { return TargetDepAttrs.end(); }\n\n  td_const_iterator td_begin() const { return TargetDepAttrs.begin(); }\n  td_const_iterator td_end() const { return TargetDepAttrs.end(); }\n\n  td_range td_attrs() { return td_range(td_begin(), td_end()); }\n\n  td_const_range td_attrs() const {\n    return td_const_range(td_begin(), td_end());\n  }\n\n  bool td_empty() const { return TargetDepAttrs.empty(); }\n\n  bool operator==(const AttrBuilder &B) const;\n  bool operator!=(const AttrBuilder &B) const { return !(*this == B); }\n};\n\nnamespace AttributeFuncs {\n\n/// Which attributes cannot be applied to a type.\nAttrBuilder typeIncompatible(Type *Ty);\n\n/// \\returns Return true if the two functions have compatible target-independent\n/// attributes for inlining purposes.\nbool areInlineCompatible(const Function &Caller, const Function &Callee);\n\n\n/// Checks  if there are any incompatible function attributes between\n/// \\p A and \\p B.\n///\n/// \\param [in] A - The first function to be compared with.\n/// \\param [in] B - The second function to be compared with.\n/// \\returns true if the functions have compatible attributes.\nbool areOutlineCompatible(const Function &A, const Function &B);\n\n/// Merge caller's and callee's attributes.\nvoid mergeAttributesForInlining(Function &Caller, const Function &Callee);\n\n/// Merges the functions attributes from \\p ToMerge into function \\p Base.\n///\n/// \\param [in,out] Base - The function being merged into.\n/// \\param [in] ToMerge - The function to merge attributes from.\nvoid mergeAttributesForOutlining(Function &Base, const Function &ToMerge);\n\n} // end namespace AttributeFuncs\n\n} // end namespace llvm\n\n#endif // LLVM_IR_ATTRIBUTES_H\n"}, "35": {"id": 35, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/IR/BasicBlock.h", "content": "//===- llvm/BasicBlock.h - Represent a basic block in the VM ----*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// This file contains the declaration of the BasicBlock class.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_IR_BASICBLOCK_H\n#define LLVM_IR_BASICBLOCK_H\n\n#include \"llvm-c/Types.h\"\n#include \"llvm/ADT/Twine.h\"\n#include \"llvm/ADT/ilist.h\"\n#include \"llvm/ADT/ilist_node.h\"\n#include \"llvm/ADT/iterator.h\"\n#include \"llvm/ADT/iterator_range.h\"\n#include \"llvm/IR/Instruction.h\"\n#include \"llvm/IR/SymbolTableListTraits.h\"\n#include \"llvm/IR/Value.h\"\n#include \"llvm/Support/CBindingWrapping.h\"\n#include \"llvm/Support/Casting.h\"\n#include \"llvm/Support/Compiler.h\"\n#include <cassert>\n#include <cstddef>\n#include <iterator>\n\nnamespace llvm {\n\nclass AssemblyAnnotationWriter;\nclass CallInst;\nclass Function;\nclass LandingPadInst;\nclass LLVMContext;\nclass Module;\nclass PHINode;\nclass ValueSymbolTable;\n\n/// LLVM Basic Block Representation\n///\n/// This represents a single basic block in LLVM. A basic block is simply a\n/// container of instructions that execute sequentially. Basic blocks are Values\n/// because they are referenced by instructions such as branches and switch\n/// tables. The type of a BasicBlock is \"Type::LabelTy\" because the basic block\n/// represents a label to which a branch can jump.\n///\n/// A well formed basic block is formed of a list of non-terminating\n/// instructions followed by a single terminator instruction. Terminator\n/// instructions may not occur in the middle of basic blocks, and must terminate\n/// the blocks. The BasicBlock class allows malformed basic blocks to occur\n/// because it may be useful in the intermediate stage of constructing or\n/// modifying a program. However, the verifier will ensure that basic blocks are\n/// \"well formed\".\nclass BasicBlock final : public Value, // Basic blocks are data objects also\n                         public ilist_node_with_parent<BasicBlock, Function> {\npublic:\n  using InstListType = SymbolTableList<Instruction>;\n\nprivate:\n  friend class BlockAddress;\n  friend class SymbolTableListTraits<BasicBlock>;\n\n  InstListType InstList;\n  Function *Parent;\n\n  void setParent(Function *parent);\n\n  /// Constructor.\n  ///\n  /// If the function parameter is specified, the basic block is automatically\n  /// inserted at either the end of the function (if InsertBefore is null), or\n  /// before the specified basic block.\n  explicit BasicBlock(LLVMContext &C, const Twine &Name = \"\",\n                      Function *Parent = nullptr,\n                      BasicBlock *InsertBefore = nullptr);\n\npublic:\n  BasicBlock(const BasicBlock &) = delete;\n  BasicBlock &operator=(const BasicBlock &) = delete;\n  ~BasicBlock();\n\n  /// Get the context in which this basic block lives.\n  LLVMContext &getContext() const;\n\n  /// Instruction iterators...\n  using iterator = InstListType::iterator;\n  using const_iterator = InstListType::const_iterator;\n  using reverse_iterator = InstListType::reverse_iterator;\n  using const_reverse_iterator = InstListType::const_reverse_iterator;\n\n  /// Creates a new BasicBlock.\n  ///\n  /// If the Parent parameter is specified, the basic block is automatically\n  /// inserted at either the end of the function (if InsertBefore is 0), or\n  /// before the specified basic block.\n  static BasicBlock *Create(LLVMContext &Context, const Twine &Name = \"\",\n                            Function *Parent = nullptr,\n                            BasicBlock *InsertBefore = nullptr) {\n    return new BasicBlock(Context, Name, Parent, InsertBefore);\n  }\n\n  /// Return the enclosing method, or null if none.\n  const Function *getParent() const { return Parent; }\n        Function *getParent()       { return Parent; }\n\n  /// Return the module owning the function this basic block belongs to, or\n  /// nullptr if the function does not have a module.\n  ///\n  /// Note: this is undefined behavior if the block does not have a parent.\n  const Module *getModule() const;\n  Module *getModule() {\n    return const_cast<Module *>(\n                            static_cast<const BasicBlock *>(this)->getModule());\n  }\n\n  /// Returns the terminator instruction if the block is well formed or null\n  /// if the block is not well formed.\n  const Instruction *getTerminator() const LLVM_READONLY;\n  Instruction *getTerminator() {\n    return const_cast<Instruction *>(\n        static_cast<const BasicBlock *>(this)->getTerminator());\n  }\n\n  /// Returns the call instruction calling \\@llvm.experimental.deoptimize\n  /// prior to the terminating return instruction of this basic block, if such\n  /// a call is present.  Otherwise, returns null.\n  const CallInst *getTerminatingDeoptimizeCall() const;\n  CallInst *getTerminatingDeoptimizeCall() {\n    return const_cast<CallInst *>(\n         static_cast<const BasicBlock *>(this)->getTerminatingDeoptimizeCall());\n  }\n\n  /// Returns the call instruction calling \\@llvm.experimental.deoptimize\n  /// that is present either in current basic block or in block that is a unique\n  /// successor to current block, if such call is present. Otherwise, returns null.\n  const CallInst *getPostdominatingDeoptimizeCall() const;\n  CallInst *getPostdominatingDeoptimizeCall() {\n    return const_cast<CallInst *>(\n         static_cast<const BasicBlock *>(this)->getPostdominatingDeoptimizeCall());\n  }\n\n  /// Returns the call instruction marked 'musttail' prior to the terminating\n  /// return instruction of this basic block, if such a call is present.\n  /// Otherwise, returns null.\n  const CallInst *getTerminatingMustTailCall() const;\n  CallInst *getTerminatingMustTailCall() {\n    return const_cast<CallInst *>(\n           static_cast<const BasicBlock *>(this)->getTerminatingMustTailCall());\n  }\n\n  /// Returns a pointer to the first instruction in this block that is not a\n  /// PHINode instruction.\n  ///\n  /// When adding instructions to the beginning of the basic block, they should\n  /// be added before the returned value, not before the first instruction,\n  /// which might be PHI. Returns 0 is there's no non-PHI instruction.\n  const Instruction* getFirstNonPHI() const;\n  Instruction* getFirstNonPHI() {\n    return const_cast<Instruction *>(\n                       static_cast<const BasicBlock *>(this)->getFirstNonPHI());\n  }\n\n  /// Returns a pointer to the first instruction in this block that is not a\n  /// PHINode or a debug intrinsic, or any pseudo operation if \\c SkipPseudoOp\n  /// is true.\n  const Instruction *getFirstNonPHIOrDbg(bool SkipPseudoOp = false) const;\n  Instruction *getFirstNonPHIOrDbg(bool SkipPseudoOp = false) {\n    return const_cast<Instruction *>(\n        static_cast<const BasicBlock *>(this)->getFirstNonPHIOrDbg(\n            SkipPseudoOp));\n  }\n\n  /// Returns a pointer to the first instruction in this block that is not a\n  /// PHINode, a debug intrinsic, or a lifetime intrinsic, or any pseudo\n  /// operation if \\c SkipPseudoOp is true.\n  const Instruction *\n  getFirstNonPHIOrDbgOrLifetime(bool SkipPseudoOp = false) const;\n  Instruction *getFirstNonPHIOrDbgOrLifetime(bool SkipPseudoOp = false) {\n    return const_cast<Instruction *>(\n        static_cast<const BasicBlock *>(this)->getFirstNonPHIOrDbgOrLifetime(\n            SkipPseudoOp));\n  }\n\n  /// Returns an iterator to the first instruction in this block that is\n  /// suitable for inserting a non-PHI instruction.\n  ///\n  /// In particular, it skips all PHIs and LandingPad instructions.\n  const_iterator getFirstInsertionPt() const;\n  iterator getFirstInsertionPt() {\n    return static_cast<const BasicBlock *>(this)\n                                          ->getFirstInsertionPt().getNonConst();\n  }\n\n  /// Return a const iterator range over the instructions in the block, skipping\n  /// any debug instructions. Skip any pseudo operations as well if \\c\n  /// SkipPseudoOp is true.\n  iterator_range<filter_iterator<BasicBlock::const_iterator,\n                                 std::function<bool(const Instruction &)>>>\n  instructionsWithoutDebug(bool SkipPseudoOp = false) const;\n\n  /// Return an iterator range over the instructions in the block, skipping any\n  /// debug instructions. Skip and any pseudo operations as well if \\c\n  /// SkipPseudoOp is true.\n  iterator_range<\n      filter_iterator<BasicBlock::iterator, std::function<bool(Instruction &)>>>\n  instructionsWithoutDebug(bool SkipPseudoOp = false);\n\n  /// Return the size of the basic block ignoring debug instructions\n  filter_iterator<BasicBlock::const_iterator,\n                  std::function<bool(const Instruction &)>>::difference_type\n  sizeWithoutDebug() const;\n\n  /// Unlink 'this' from the containing function, but do not delete it.\n  void removeFromParent();\n\n  /// Unlink 'this' from the containing function and delete it.\n  ///\n  // \\returns an iterator pointing to the element after the erased one.\n  SymbolTableList<BasicBlock>::iterator eraseFromParent();\n\n  /// Unlink this basic block from its current function and insert it into\n  /// the function that \\p MovePos lives in, right before \\p MovePos.\n  void moveBefore(BasicBlock *MovePos);\n\n  /// Unlink this basic block from its current function and insert it\n  /// right after \\p MovePos in the function \\p MovePos lives in.\n  void moveAfter(BasicBlock *MovePos);\n\n  /// Insert unlinked basic block into a function.\n  ///\n  /// Inserts an unlinked basic block into \\c Parent.  If \\c InsertBefore is\n  /// provided, inserts before that basic block, otherwise inserts at the end.\n  ///\n  /// \\pre \\a getParent() is \\c nullptr.\n  void insertInto(Function *Parent, BasicBlock *InsertBefore = nullptr);\n\n  /// Return the predecessor of this block if it has a single predecessor\n  /// block. Otherwise return a null pointer.\n  const BasicBlock *getSinglePredecessor() const;\n  BasicBlock *getSinglePredecessor() {\n    return const_cast<BasicBlock *>(\n                 static_cast<const BasicBlock *>(this)->getSinglePredecessor());\n  }\n\n  /// Return the predecessor of this block if it has a unique predecessor\n  /// block. Otherwise return a null pointer.\n  ///\n  /// Note that unique predecessor doesn't mean single edge, there can be\n  /// multiple edges from the unique predecessor to this block (for example a\n  /// switch statement with multiple cases having the same destination).\n  const BasicBlock *getUniquePredecessor() const;\n  BasicBlock *getUniquePredecessor() {\n    return const_cast<BasicBlock *>(\n                 static_cast<const BasicBlock *>(this)->getUniquePredecessor());\n  }\n\n  /// Return true if this block has exactly N predecessors.\n  bool hasNPredecessors(unsigned N) const;\n\n  /// Return true if this block has N predecessors or more.\n  bool hasNPredecessorsOrMore(unsigned N) const;\n\n  /// Return the successor of this block if it has a single successor.\n  /// Otherwise return a null pointer.\n  ///\n  /// This method is analogous to getSinglePredecessor above.\n  const BasicBlock *getSingleSuccessor() const;\n  BasicBlock *getSingleSuccessor() {\n    return const_cast<BasicBlock *>(\n                   static_cast<const BasicBlock *>(this)->getSingleSuccessor());\n  }\n\n  /// Return the successor of this block if it has a unique successor.\n  /// Otherwise return a null pointer.\n  ///\n  /// This method is analogous to getUniquePredecessor above.\n  const BasicBlock *getUniqueSuccessor() const;\n  BasicBlock *getUniqueSuccessor() {\n    return const_cast<BasicBlock *>(\n                   static_cast<const BasicBlock *>(this)->getUniqueSuccessor());\n  }\n\n  /// Print the basic block to an output stream with an optional\n  /// AssemblyAnnotationWriter.\n  void print(raw_ostream &OS, AssemblyAnnotationWriter *AAW = nullptr,\n             bool ShouldPreserveUseListOrder = false,\n             bool IsForDebug = false) const;\n\n  //===--------------------------------------------------------------------===//\n  /// Instruction iterator methods\n  ///\n  inline iterator                begin()       { return InstList.begin(); }\n  inline const_iterator          begin() const { return InstList.begin(); }\n  inline iterator                end  ()       { return InstList.end();   }\n  inline const_iterator          end  () const { return InstList.end();   }\n\n  inline reverse_iterator        rbegin()       { return InstList.rbegin(); }\n  inline const_reverse_iterator  rbegin() const { return InstList.rbegin(); }\n  inline reverse_iterator        rend  ()       { return InstList.rend();   }\n  inline const_reverse_iterator  rend  () const { return InstList.rend();   }\n\n  inline size_t                   size() const { return InstList.size();  }\n  inline bool                    empty() const { return InstList.empty(); }\n  inline const Instruction      &front() const { return InstList.front(); }\n  inline       Instruction      &front()       { return InstList.front(); }\n  inline const Instruction       &back() const { return InstList.back();  }\n  inline       Instruction       &back()       { return InstList.back();  }\n\n  /// Iterator to walk just the phi nodes in the basic block.\n  template <typename PHINodeT = PHINode, typename BBIteratorT = iterator>\n  class phi_iterator_impl\n      : public iterator_facade_base<phi_iterator_impl<PHINodeT, BBIteratorT>,\n                                    std::forward_iterator_tag, PHINodeT> {\n    friend BasicBlock;\n\n    PHINodeT *PN;\n\n    phi_iterator_impl(PHINodeT *PN) : PN(PN) {}\n\n  public:\n    // Allow default construction to build variables, but this doesn't build\n    // a useful iterator.\n    phi_iterator_impl() = default;\n\n    // Allow conversion between instantiations where valid.\n    template <typename PHINodeU, typename BBIteratorU,\n              typename = std::enable_if_t<\n                  std::is_convertible<PHINodeU *, PHINodeT *>::value>>\n    phi_iterator_impl(const phi_iterator_impl<PHINodeU, BBIteratorU> &Arg)\n        : PN(Arg.PN) {}\n\n    bool operator==(const phi_iterator_impl &Arg) const { return PN == Arg.PN; }\n\n    PHINodeT &operator*() const { return *PN; }\n\n    using phi_iterator_impl::iterator_facade_base::operator++;\n    phi_iterator_impl &operator++() {\n      assert(PN && \"Cannot increment the end iterator!\");\n      PN = dyn_cast<PHINodeT>(std::next(BBIteratorT(PN)));\n      return *this;\n    }\n  };\n  using phi_iterator = phi_iterator_impl<>;\n  using const_phi_iterator =\n      phi_iterator_impl<const PHINode, BasicBlock::const_iterator>;\n\n  /// Returns a range that iterates over the phis in the basic block.\n  ///\n  /// Note that this cannot be used with basic blocks that have no terminator.\n  iterator_range<const_phi_iterator> phis() const {\n    return const_cast<BasicBlock *>(this)->phis();\n  }\n  iterator_range<phi_iterator> phis();\n\n  /// Return the underlying instruction list container.\n  ///\n  /// Currently you need to access the underlying instruction list container\n  /// directly if you want to modify it.\n  const InstListType &getInstList() const { return InstList; }\n        InstListType &getInstList()       { return InstList; }\n\n  /// Returns a pointer to a member of the instruction list.\n  static InstListType BasicBlock::*getSublistAccess(Instruction*) {\n    return &BasicBlock::InstList;\n  }\n\n  /// Returns a pointer to the symbol table if one exists.\n  ValueSymbolTable *getValueSymbolTable();\n\n  /// Methods for support type inquiry through isa, cast, and dyn_cast.\n  static bool classof(const Value *V) {\n    return V->getValueID() == Value::BasicBlockVal;\n  }\n\n  /// Cause all subinstructions to \"let go\" of all the references that said\n  /// subinstructions are maintaining.\n  ///\n  /// This allows one to 'delete' a whole class at a time, even though there may\n  /// be circular references... first all references are dropped, and all use\n  /// counts go to zero.  Then everything is delete'd for real.  Note that no\n  /// operations are valid on an object that has \"dropped all references\",\n  /// except operator delete.\n  void dropAllReferences();\n\n  /// Update PHI nodes in this BasicBlock before removal of predecessor \\p Pred.\n  /// Note that this function does not actually remove the predecessor.\n  ///\n  /// If \\p KeepOneInputPHIs is true then don't remove PHIs that are left with\n  /// zero or one incoming values, and don't simplify PHIs with all incoming\n  /// values the same.\n  void removePredecessor(BasicBlock *Pred, bool KeepOneInputPHIs = false);\n\n  bool canSplitPredecessors() const;\n\n  /// Split the basic block into two basic blocks at the specified instruction.\n  ///\n  /// If \\p Before is true, splitBasicBlockBefore handles the\n  /// block splitting. Otherwise, execution proceeds as described below.\n  ///\n  /// Note that all instructions BEFORE the specified iterator\n  /// stay as part of the original basic block, an unconditional branch is added\n  /// to the original BB, and the rest of the instructions in the BB are moved\n  /// to the new BB, including the old terminator.  The newly formed basic block\n  /// is returned. This function invalidates the specified iterator.\n  ///\n  /// Note that this only works on well formed basic blocks (must have a\n  /// terminator), and \\p 'I' must not be the end of instruction list (which\n  /// would cause a degenerate basic block to be formed, having a terminator\n  /// inside of the basic block).\n  ///\n  /// Also note that this doesn't preserve any passes. To split blocks while\n  /// keeping loop information consistent, use the SplitBlock utility function.\n  BasicBlock *splitBasicBlock(iterator I, const Twine &BBName = \"\",\n                              bool Before = false);\n  BasicBlock *splitBasicBlock(Instruction *I, const Twine &BBName = \"\",\n                              bool Before = false) {\n    return splitBasicBlock(I->getIterator(), BBName, Before);\n  }\n\n  /// Split the basic block into two basic blocks at the specified instruction\n  /// and insert the new basic blocks as the predecessor of the current block.\n  ///\n  /// This function ensures all instructions AFTER and including the specified\n  /// iterator \\p I are part of the original basic block. All Instructions\n  /// BEFORE the iterator \\p I are moved to the new BB and an unconditional\n  /// branch is added to the new BB. The new basic block is returned.\n  ///\n  /// Note that this only works on well formed basic blocks (must have a\n  /// terminator), and \\p 'I' must not be the end of instruction list (which\n  /// would cause a degenerate basic block to be formed, having a terminator\n  /// inside of the basic block).  \\p 'I' cannot be a iterator for a PHINode\n  /// with multiple incoming blocks.\n  ///\n  /// Also note that this doesn't preserve any passes. To split blocks while\n  /// keeping loop information consistent, use the SplitBlockBefore utility\n  /// function.\n  BasicBlock *splitBasicBlockBefore(iterator I, const Twine &BBName = \"\");\n  BasicBlock *splitBasicBlockBefore(Instruction *I, const Twine &BBName = \"\") {\n    return splitBasicBlockBefore(I->getIterator(), BBName);\n  }\n\n  /// Returns true if there are any uses of this basic block other than\n  /// direct branches, switches, etc. to it.\n  bool hasAddressTaken() const {\n    return getBasicBlockBits().BlockAddressRefCount != 0;\n  }\n\n  /// Update all phi nodes in this basic block to refer to basic block \\p New\n  /// instead of basic block \\p Old.\n  void replacePhiUsesWith(BasicBlock *Old, BasicBlock *New);\n\n  /// Update all phi nodes in this basic block's successors to refer to basic\n  /// block \\p New instead of basic block \\p Old.\n  void replaceSuccessorsPhiUsesWith(BasicBlock *Old, BasicBlock *New);\n\n  /// Update all phi nodes in this basic block's successors to refer to basic\n  /// block \\p New instead of to it.\n  void replaceSuccessorsPhiUsesWith(BasicBlock *New);\n\n  /// Return true if this basic block is an exception handling block.\n  bool isEHPad() const { return getFirstNonPHI()->isEHPad(); }\n\n  /// Return true if this basic block is a landing pad.\n  ///\n  /// Being a ``landing pad'' means that the basic block is the destination of\n  /// the 'unwind' edge of an invoke instruction.\n  bool isLandingPad() const;\n\n  /// Return the landingpad instruction associated with the landing pad.\n  const LandingPadInst *getLandingPadInst() const;\n  LandingPadInst *getLandingPadInst() {\n    return const_cast<LandingPadInst *>(\n                    static_cast<const BasicBlock *>(this)->getLandingPadInst());\n  }\n\n  /// Return true if it is legal to hoist instructions into this block.\n  bool isLegalToHoistInto() const;\n\n  Optional<uint64_t> getIrrLoopHeaderWeight() const;\n\n  /// Returns true if the Order field of child Instructions is valid.\n  bool isInstrOrderValid() const {\n    return getBasicBlockBits().InstrOrderValid;\n  }\n\n  /// Mark instruction ordering invalid. Done on every instruction insert.\n  void invalidateOrders() {\n    validateInstrOrdering();\n    BasicBlockBits Bits = getBasicBlockBits();\n    Bits.InstrOrderValid = false;\n    setBasicBlockBits(Bits);\n  }\n\n  /// Renumber instructions and mark the ordering as valid.\n  void renumberInstructions();\n\n  /// Asserts that instruction order numbers are marked invalid, or that they\n  /// are in ascending order. This is constant time if the ordering is invalid,\n  /// and linear in the number of instructions if the ordering is valid. Callers\n  /// should be careful not to call this in ways that make common operations\n  /// O(n^2). For example, it takes O(n) time to assign order numbers to\n  /// instructions, so the order should be validated no more than once after\n  /// each ordering to ensure that transforms have the same algorithmic\n  /// complexity when asserts are enabled as when they are disabled.\n  void validateInstrOrdering() const;\n\nprivate:\n#if defined(_AIX) && (!defined(__GNUC__) || defined(__ibmxl__))\n// Except for GCC; by default, AIX compilers store bit-fields in 4-byte words\n// and give the `pack` pragma push semantics.\n#define BEGIN_TWO_BYTE_PACK() _Pragma(\"pack(2)\")\n#define END_TWO_BYTE_PACK() _Pragma(\"pack(pop)\")\n#else\n#define BEGIN_TWO_BYTE_PACK()\n#define END_TWO_BYTE_PACK()\n#endif\n\n  BEGIN_TWO_BYTE_PACK()\n  /// Bitfield to help interpret the bits in Value::SubclassData.\n  struct BasicBlockBits {\n    unsigned short BlockAddressRefCount : 15;\n    unsigned short InstrOrderValid : 1;\n  };\n  END_TWO_BYTE_PACK()\n\n#undef BEGIN_TWO_BYTE_PACK\n#undef END_TWO_BYTE_PACK\n\n  /// Safely reinterpret the subclass data bits to a more useful form.\n  BasicBlockBits getBasicBlockBits() const {\n    static_assert(sizeof(BasicBlockBits) == sizeof(unsigned short),\n                  \"too many bits for Value::SubclassData\");\n    unsigned short ValueData = getSubclassDataFromValue();\n    BasicBlockBits AsBits;\n    memcpy(&AsBits, &ValueData, sizeof(AsBits));\n    return AsBits;\n  }\n\n  /// Reinterpret our subclass bits and store them back into Value.\n  void setBasicBlockBits(BasicBlockBits AsBits) {\n    unsigned short D;\n    memcpy(&D, &AsBits, sizeof(D));\n    Value::setValueSubclassData(D);\n  }\n\n  /// Increment the internal refcount of the number of BlockAddresses\n  /// referencing this BasicBlock by \\p Amt.\n  ///\n  /// This is almost always 0, sometimes one possibly, but almost never 2, and\n  /// inconceivably 3 or more.\n  void AdjustBlockAddressRefCount(int Amt) {\n    BasicBlockBits Bits = getBasicBlockBits();\n    Bits.BlockAddressRefCount += Amt;\n    setBasicBlockBits(Bits);\n    assert(Bits.BlockAddressRefCount < 255 && \"Refcount wrap-around\");\n  }\n\n  /// Shadow Value::setValueSubclassData with a private forwarding method so\n  /// that any future subclasses cannot accidentally use it.\n  void setValueSubclassData(unsigned short D) {\n    Value::setValueSubclassData(D);\n  }\n};\n\n// Create wrappers for C Binding types (see CBindingWrapping.h).\nDEFINE_SIMPLE_CONVERSION_FUNCTIONS(BasicBlock, LLVMBasicBlockRef)\n\n/// Advance \\p It while it points to a debug instruction and return the result.\n/// This assumes that \\p It is not at the end of a block.\nBasicBlock::iterator skipDebugIntrinsics(BasicBlock::iterator It);\n\n#ifdef NDEBUG\n/// In release builds, this is a no-op. For !NDEBUG builds, the checks are\n/// implemented in the .cpp file to avoid circular header deps.\ninline void BasicBlock::validateInstrOrdering() const {}\n#endif\n\n} // end namespace llvm\n\n#endif // LLVM_IR_BASICBLOCK_H\n"}, "36": {"id": 36, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/IR/Constants.h", "content": "//===-- llvm/Constants.h - Constant class subclass definitions --*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n/// @file\n/// This file contains the declarations for the subclasses of Constant,\n/// which represent the different flavors of constant values that live in LLVM.\n/// Note that Constants are immutable (once created they never change) and are\n/// fully shared by structural equivalence.  This means that two structurally\n/// equivalent constants will always have the same address.  Constants are\n/// created on demand as needed and never deleted: thus clients don't have to\n/// worry about the lifetime of the objects.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_IR_CONSTANTS_H\n#define LLVM_IR_CONSTANTS_H\n\n#include \"llvm/ADT/APFloat.h\"\n#include \"llvm/ADT/APInt.h\"\n#include \"llvm/ADT/ArrayRef.h\"\n#include \"llvm/ADT/None.h\"\n#include \"llvm/ADT/Optional.h\"\n#include \"llvm/ADT/STLExtras.h\"\n#include \"llvm/ADT/StringRef.h\"\n#include \"llvm/IR/Constant.h\"\n#include \"llvm/IR/DerivedTypes.h\"\n#include \"llvm/IR/OperandTraits.h\"\n#include \"llvm/IR/User.h\"\n#include \"llvm/IR/Value.h\"\n#include \"llvm/Support/Casting.h\"\n#include \"llvm/Support/Compiler.h\"\n#include \"llvm/Support/ErrorHandling.h\"\n#include <cassert>\n#include <cstddef>\n#include <cstdint>\n\nnamespace llvm {\n\ntemplate <class ConstantClass> struct ConstantAggrKeyType;\n\n/// Base class for constants with no operands.\n///\n/// These constants have no operands; they represent their data directly.\n/// Since they can be in use by unrelated modules (and are never based on\n/// GlobalValues), it never makes sense to RAUW them.\nclass ConstantData : public Constant {\n  friend class Constant;\n\n  Value *handleOperandChangeImpl(Value *From, Value *To) {\n    llvm_unreachable(\"Constant data does not have operands!\");\n  }\n\nprotected:\n  explicit ConstantData(Type *Ty, ValueTy VT) : Constant(Ty, VT, nullptr, 0) {}\n\n  void *operator new(size_t s) { return User::operator new(s, 0); }\n\npublic:\n  ConstantData(const ConstantData &) = delete;\n\n  /// Methods to support type inquiry through isa, cast, and dyn_cast.\n  static bool classof(const Value *V) {\n    return V->getValueID() >= ConstantDataFirstVal &&\n           V->getValueID() <= ConstantDataLastVal;\n  }\n};\n\n//===----------------------------------------------------------------------===//\n/// This is the shared class of boolean and integer constants. This class\n/// represents both boolean and integral constants.\n/// Class for constant integers.\nclass ConstantInt final : public ConstantData {\n  friend class Constant;\n\n  APInt Val;\n\n  ConstantInt(IntegerType *Ty, const APInt& V);\n\n  void destroyConstantImpl();\n\npublic:\n  ConstantInt(const ConstantInt &) = delete;\n\n  static ConstantInt *getTrue(LLVMContext &Context);\n  static ConstantInt *getFalse(LLVMContext &Context);\n  static ConstantInt *getBool(LLVMContext &Context, bool V);\n  static Constant *getTrue(Type *Ty);\n  static Constant *getFalse(Type *Ty);\n  static Constant *getBool(Type *Ty, bool V);\n\n  /// If Ty is a vector type, return a Constant with a splat of the given\n  /// value. Otherwise return a ConstantInt for the given value.\n  static Constant *get(Type *Ty, uint64_t V, bool isSigned = false);\n\n  /// Return a ConstantInt with the specified integer value for the specified\n  /// type. If the type is wider than 64 bits, the value will be zero-extended\n  /// to fit the type, unless isSigned is true, in which case the value will\n  /// be interpreted as a 64-bit signed integer and sign-extended to fit\n  /// the type.\n  /// Get a ConstantInt for a specific value.\n  static ConstantInt *get(IntegerType *Ty, uint64_t V,\n                          bool isSigned = false);\n\n  /// Return a ConstantInt with the specified value for the specified type. The\n  /// value V will be canonicalized to a an unsigned APInt. Accessing it with\n  /// either getSExtValue() or getZExtValue() will yield a correctly sized and\n  /// signed value for the type Ty.\n  /// Get a ConstantInt for a specific signed value.\n  static ConstantInt *getSigned(IntegerType *Ty, int64_t V);\n  static Constant *getSigned(Type *Ty, int64_t V);\n\n  /// Return a ConstantInt with the specified value and an implied Type. The\n  /// type is the integer type that corresponds to the bit width of the value.\n  static ConstantInt *get(LLVMContext &Context, const APInt &V);\n\n  /// Return a ConstantInt constructed from the string strStart with the given\n  /// radix.\n  static ConstantInt *get(IntegerType *Ty, StringRef Str,\n                          uint8_t radix);\n\n  /// If Ty is a vector type, return a Constant with a splat of the given\n  /// value. Otherwise return a ConstantInt for the given value.\n  static Constant *get(Type* Ty, const APInt& V);\n\n  /// Return the constant as an APInt value reference. This allows clients to\n  /// obtain a full-precision copy of the value.\n  /// Return the constant's value.\n  inline const APInt &getValue() const {\n    return Val;\n  }\n\n  /// getBitWidth - Return the bitwidth of this constant.\n  unsigned getBitWidth() const { return Val.getBitWidth(); }\n\n  /// Return the constant as a 64-bit unsigned integer value after it\n  /// has been zero extended as appropriate for the type of this constant. Note\n  /// that this method can assert if the value does not fit in 64 bits.\n  /// Return the zero extended value.\n  inline uint64_t getZExtValue() const {\n    return Val.getZExtValue();\n  }\n\n  /// Return the constant as a 64-bit integer value after it has been sign\n  /// extended as appropriate for the type of this constant. Note that\n  /// this method can assert if the value does not fit in 64 bits.\n  /// Return the sign extended value.\n  inline int64_t getSExtValue() const {\n    return Val.getSExtValue();\n  }\n\n  /// Return the constant as an llvm::MaybeAlign.\n  /// Note that this method can assert if the value does not fit in 64 bits or\n  /// is not a power of two.\n  inline MaybeAlign getMaybeAlignValue() const {\n    return MaybeAlign(getZExtValue());\n  }\n\n  /// Return the constant as an llvm::Align, interpreting `0` as `Align(1)`.\n  /// Note that this method can assert if the value does not fit in 64 bits or\n  /// is not a power of two.\n  inline Align getAlignValue() const {\n    return getMaybeAlignValue().valueOrOne();\n  }\n\n  /// A helper method that can be used to determine if the constant contained\n  /// within is equal to a constant.  This only works for very small values,\n  /// because this is all that can be represented with all types.\n  /// Determine if this constant's value is same as an unsigned char.\n  bool equalsInt(uint64_t V) const {\n    return Val == V;\n  }\n\n  /// getType - Specialize the getType() method to always return an IntegerType,\n  /// which reduces the amount of casting needed in parts of the compiler.\n  ///\n  inline IntegerType *getType() const {\n    return cast<IntegerType>(Value::getType());\n  }\n\n  /// This static method returns true if the type Ty is big enough to\n  /// represent the value V. This can be used to avoid having the get method\n  /// assert when V is larger than Ty can represent. Note that there are two\n  /// versions of this method, one for unsigned and one for signed integers.\n  /// Although ConstantInt canonicalizes everything to an unsigned integer,\n  /// the signed version avoids callers having to convert a signed quantity\n  /// to the appropriate unsigned type before calling the method.\n  /// @returns true if V is a valid value for type Ty\n  /// Determine if the value is in range for the given type.\n  static bool isValueValidForType(Type *Ty, uint64_t V);\n  static bool isValueValidForType(Type *Ty, int64_t V);\n\n  bool isNegative() const { return Val.isNegative(); }\n\n  /// This is just a convenience method to make client code smaller for a\n  /// common code. It also correctly performs the comparison without the\n  /// potential for an assertion from getZExtValue().\n  bool isZero() const {\n    return Val.isNullValue();\n  }\n\n  /// This is just a convenience method to make client code smaller for a\n  /// common case. It also correctly performs the comparison without the\n  /// potential for an assertion from getZExtValue().\n  /// Determine if the value is one.\n  bool isOne() const {\n    return Val.isOneValue();\n  }\n\n  /// This function will return true iff every bit in this constant is set\n  /// to true.\n  /// @returns true iff this constant's bits are all set to true.\n  /// Determine if the value is all ones.\n  bool isMinusOne() const {\n    return Val.isAllOnesValue();\n  }\n\n  /// This function will return true iff this constant represents the largest\n  /// value that may be represented by the constant's type.\n  /// @returns true iff this is the largest value that may be represented\n  /// by this type.\n  /// Determine if the value is maximal.\n  bool isMaxValue(bool isSigned) const {\n    if (isSigned)\n      return Val.isMaxSignedValue();\n    else\n      return Val.isMaxValue();\n  }\n\n  /// This function will return true iff this constant represents the smallest\n  /// value that may be represented by this constant's type.\n  /// @returns true if this is the smallest value that may be represented by\n  /// this type.\n  /// Determine if the value is minimal.\n  bool isMinValue(bool isSigned) const {\n    if (isSigned)\n      return Val.isMinSignedValue();\n    else\n      return Val.isMinValue();\n  }\n\n  /// This function will return true iff this constant represents a value with\n  /// active bits bigger than 64 bits or a value greater than the given uint64_t\n  /// value.\n  /// @returns true iff this constant is greater or equal to the given number.\n  /// Determine if the value is greater or equal to the given number.\n  bool uge(uint64_t Num) const {\n    return Val.uge(Num);\n  }\n\n  /// getLimitedValue - If the value is smaller than the specified limit,\n  /// return it, otherwise return the limit value.  This causes the value\n  /// to saturate to the limit.\n  /// @returns the min of the value of the constant and the specified value\n  /// Get the constant's value with a saturation limit\n  uint64_t getLimitedValue(uint64_t Limit = ~0ULL) const {\n    return Val.getLimitedValue(Limit);\n  }\n\n  /// Methods to support type inquiry through isa, cast, and dyn_cast.\n  static bool classof(const Value *V) {\n    return V->getValueID() == ConstantIntVal;\n  }\n};\n\n//===----------------------------------------------------------------------===//\n/// ConstantFP - Floating Point Values [float, double]\n///\nclass ConstantFP final : public ConstantData {\n  friend class Constant;\n\n  APFloat Val;\n\n  ConstantFP(Type *Ty, const APFloat& V);\n\n  void destroyConstantImpl();\n\npublic:\n  ConstantFP(const ConstantFP &) = delete;\n\n  /// Floating point negation must be implemented with f(x) = -0.0 - x. This\n  /// method returns the negative zero constant for floating point or vector\n  /// floating point types; for all other types, it returns the null value.\n  static Constant *getZeroValueForNegation(Type *Ty);\n\n  /// This returns a ConstantFP, or a vector containing a splat of a ConstantFP,\n  /// for the specified value in the specified type. This should only be used\n  /// for simple constant values like 2.0/1.0 etc, that are known-valid both as\n  /// host double and as the target format.\n  static Constant *get(Type* Ty, double V);\n\n  /// If Ty is a vector type, return a Constant with a splat of the given\n  /// value. Otherwise return a ConstantFP for the given value.\n  static Constant *get(Type *Ty, const APFloat &V);\n\n  static Constant *get(Type* Ty, StringRef Str);\n  static ConstantFP *get(LLVMContext &Context, const APFloat &V);\n  static Constant *getNaN(Type *Ty, bool Negative = false, uint64_t Payload = 0);\n  static Constant *getQNaN(Type *Ty, bool Negative = false,\n                           APInt *Payload = nullptr);\n  static Constant *getSNaN(Type *Ty, bool Negative = false,\n                           APInt *Payload = nullptr);\n  static Constant *getNegativeZero(Type *Ty);\n  static Constant *getInfinity(Type *Ty, bool Negative = false);\n\n  /// Return true if Ty is big enough to represent V.\n  static bool isValueValidForType(Type *Ty, const APFloat &V);\n  inline const APFloat &getValueAPF() const { return Val; }\n  inline const APFloat &getValue() const { return Val; }\n\n  /// Return true if the value is positive or negative zero.\n  bool isZero() const { return Val.isZero(); }\n\n  /// Return true if the sign bit is set.\n  bool isNegative() const { return Val.isNegative(); }\n\n  /// Return true if the value is infinity\n  bool isInfinity() const { return Val.isInfinity(); }\n\n  /// Return true if the value is a NaN.\n  bool isNaN() const { return Val.isNaN(); }\n\n  /// We don't rely on operator== working on double values, as it returns true\n  /// for things that are clearly not equal, like -0.0 and 0.0.\n  /// As such, this method can be used to do an exact bit-for-bit comparison of\n  /// two floating point values.  The version with a double operand is retained\n  /// because it's so convenient to write isExactlyValue(2.0), but please use\n  /// it only for simple constants.\n  bool isExactlyValue(const APFloat &V) const;\n\n  bool isExactlyValue(double V) const {\n    bool ignored;\n    APFloat FV(V);\n    FV.convert(Val.getSemantics(), APFloat::rmNearestTiesToEven, &ignored);\n    return isExactlyValue(FV);\n  }\n\n  /// Methods for support type inquiry through isa, cast, and dyn_cast:\n  static bool classof(const Value *V) {\n    return V->getValueID() == ConstantFPVal;\n  }\n};\n\n//===----------------------------------------------------------------------===//\n/// All zero aggregate value\n///\nclass ConstantAggregateZero final : public ConstantData {\n  friend class Constant;\n\n  explicit ConstantAggregateZero(Type *Ty)\n      : ConstantData(Ty, ConstantAggregateZeroVal) {}\n\n  void destroyConstantImpl();\n\npublic:\n  ConstantAggregateZero(const ConstantAggregateZero &) = delete;\n\n  static ConstantAggregateZero *get(Type *Ty);\n\n  /// If this CAZ has array or vector type, return a zero with the right element\n  /// type.\n  Constant *getSequentialElement() const;\n\n  /// If this CAZ has struct type, return a zero with the right element type for\n  /// the specified element.\n  Constant *getStructElement(unsigned Elt) const;\n\n  /// Return a zero of the right value for the specified GEP index if we can,\n  /// otherwise return null (e.g. if C is a ConstantExpr).\n  Constant *getElementValue(Constant *C) const;\n\n  /// Return a zero of the right value for the specified GEP index.\n  Constant *getElementValue(unsigned Idx) const;\n\n  /// Return the number of elements in the array, vector, or struct.\n  unsigned getNumElements() const;\n\n  /// Methods for support type inquiry through isa, cast, and dyn_cast:\n  ///\n  static bool classof(const Value *V) {\n    return V->getValueID() == ConstantAggregateZeroVal;\n  }\n};\n\n/// Base class for aggregate constants (with operands).\n///\n/// These constants are aggregates of other constants, which are stored as\n/// operands.\n///\n/// Subclasses are \\a ConstantStruct, \\a ConstantArray, and \\a\n/// ConstantVector.\n///\n/// \\note Some subclasses of \\a ConstantData are semantically aggregates --\n/// such as \\a ConstantDataArray -- but are not subclasses of this because they\n/// use operands.\nclass ConstantAggregate : public Constant {\nprotected:\n  ConstantAggregate(Type *T, ValueTy VT, ArrayRef<Constant *> V);\n\npublic:\n  /// Transparently provide more efficient getOperand methods.\n  DECLARE_TRANSPARENT_OPERAND_ACCESSORS(Constant);\n\n  /// Methods for support type inquiry through isa, cast, and dyn_cast:\n  static bool classof(const Value *V) {\n    return V->getValueID() >= ConstantAggregateFirstVal &&\n           V->getValueID() <= ConstantAggregateLastVal;\n  }\n};\n\ntemplate <>\nstruct OperandTraits<ConstantAggregate>\n    : public VariadicOperandTraits<ConstantAggregate> {};\n\nDEFINE_TRANSPARENT_OPERAND_ACCESSORS(ConstantAggregate, Constant)\n\n//===----------------------------------------------------------------------===//\n/// ConstantArray - Constant Array Declarations\n///\nclass ConstantArray final : public ConstantAggregate {\n  friend struct ConstantAggrKeyType<ConstantArray>;\n  friend class Constant;\n\n  ConstantArray(ArrayType *T, ArrayRef<Constant *> Val);\n\n  void destroyConstantImpl();\n  Value *handleOperandChangeImpl(Value *From, Value *To);\n\npublic:\n  // ConstantArray accessors\n  static Constant *get(ArrayType *T, ArrayRef<Constant*> V);\n\nprivate:\n  static Constant *getImpl(ArrayType *T, ArrayRef<Constant *> V);\n\npublic:\n  /// Specialize the getType() method to always return an ArrayType,\n  /// which reduces the amount of casting needed in parts of the compiler.\n  inline ArrayType *getType() const {\n    return cast<ArrayType>(Value::getType());\n  }\n\n  /// Methods for support type inquiry through isa, cast, and dyn_cast:\n  static bool classof(const Value *V) {\n    return V->getValueID() == ConstantArrayVal;\n  }\n};\n\n//===----------------------------------------------------------------------===//\n// Constant Struct Declarations\n//\nclass ConstantStruct final : public ConstantAggregate {\n  friend struct ConstantAggrKeyType<ConstantStruct>;\n  friend class Constant;\n\n  ConstantStruct(StructType *T, ArrayRef<Constant *> Val);\n\n  void destroyConstantImpl();\n  Value *handleOperandChangeImpl(Value *From, Value *To);\n\npublic:\n  // ConstantStruct accessors\n  static Constant *get(StructType *T, ArrayRef<Constant*> V);\n\n  template <typename... Csts>\n  static std::enable_if_t<are_base_of<Constant, Csts...>::value, Constant *>\n  get(StructType *T, Csts *... Vs) {\n    SmallVector<Constant *, 8> Values({Vs...});\n    return get(T, Values);\n  }\n\n  /// Return an anonymous struct that has the specified elements.\n  /// If the struct is possibly empty, then you must specify a context.\n  static Constant *getAnon(ArrayRef<Constant*> V, bool Packed = false) {\n    return get(getTypeForElements(V, Packed), V);\n  }\n  static Constant *getAnon(LLVMContext &Ctx,\n                           ArrayRef<Constant*> V, bool Packed = false) {\n    return get(getTypeForElements(Ctx, V, Packed), V);\n  }\n\n  /// Return an anonymous struct type to use for a constant with the specified\n  /// set of elements. The list must not be empty.\n  static StructType *getTypeForElements(ArrayRef<Constant*> V,\n                                        bool Packed = false);\n  /// This version of the method allows an empty list.\n  static StructType *getTypeForElements(LLVMContext &Ctx,\n                                        ArrayRef<Constant*> V,\n                                        bool Packed = false);\n\n  /// Specialization - reduce amount of casting.\n  inline StructType *getType() const {\n    return cast<StructType>(Value::getType());\n  }\n\n  /// Methods for support type inquiry through isa, cast, and dyn_cast:\n  static bool classof(const Value *V) {\n    return V->getValueID() == ConstantStructVal;\n  }\n};\n\n//===----------------------------------------------------------------------===//\n/// Constant Vector Declarations\n///\nclass ConstantVector final : public ConstantAggregate {\n  friend struct ConstantAggrKeyType<ConstantVector>;\n  friend class Constant;\n\n  ConstantVector(VectorType *T, ArrayRef<Constant *> Val);\n\n  void destroyConstantImpl();\n  Value *handleOperandChangeImpl(Value *From, Value *To);\n\npublic:\n  // ConstantVector accessors\n  static Constant *get(ArrayRef<Constant*> V);\n\nprivate:\n  static Constant *getImpl(ArrayRef<Constant *> V);\n\npublic:\n  /// Return a ConstantVector with the specified constant in each element.\n  /// Note that this might not return an instance of ConstantVector\n  static Constant *getSplat(ElementCount EC, Constant *Elt);\n\n  /// Specialize the getType() method to always return a FixedVectorType,\n  /// which reduces the amount of casting needed in parts of the compiler.\n  inline FixedVectorType *getType() const {\n    return cast<FixedVectorType>(Value::getType());\n  }\n\n  /// If all elements of the vector constant have the same value, return that\n  /// value. Otherwise, return nullptr. Ignore undefined elements by setting\n  /// AllowUndefs to true.\n  Constant *getSplatValue(bool AllowUndefs = false) const;\n\n  /// Methods for support type inquiry through isa, cast, and dyn_cast:\n  static bool classof(const Value *V) {\n    return V->getValueID() == ConstantVectorVal;\n  }\n};\n\n//===----------------------------------------------------------------------===//\n/// A constant pointer value that points to null\n///\nclass ConstantPointerNull final : public ConstantData {\n  friend class Constant;\n\n  explicit ConstantPointerNull(PointerType *T)\n      : ConstantData(T, Value::ConstantPointerNullVal) {}\n\n  void destroyConstantImpl();\n\npublic:\n  ConstantPointerNull(const ConstantPointerNull &) = delete;\n\n  /// Static factory methods - Return objects of the specified value\n  static ConstantPointerNull *get(PointerType *T);\n\n  /// Specialize the getType() method to always return an PointerType,\n  /// which reduces the amount of casting needed in parts of the compiler.\n  inline PointerType *getType() const {\n    return cast<PointerType>(Value::getType());\n  }\n\n  /// Methods for support type inquiry through isa, cast, and dyn_cast:\n  static bool classof(const Value *V) {\n    return V->getValueID() == ConstantPointerNullVal;\n  }\n};\n\n//===----------------------------------------------------------------------===//\n/// ConstantDataSequential - A vector or array constant whose element type is a\n/// simple 1/2/4/8-byte integer or float/double, and whose elements are just\n/// simple data values (i.e. ConstantInt/ConstantFP).  This Constant node has no\n/// operands because it stores all of the elements of the constant as densely\n/// packed data, instead of as Value*'s.\n///\n/// This is the common base class of ConstantDataArray and ConstantDataVector.\n///\nclass ConstantDataSequential : public ConstantData {\n  friend class LLVMContextImpl;\n  friend class Constant;\n\n  /// A pointer to the bytes underlying this constant (which is owned by the\n  /// uniquing StringMap).\n  const char *DataElements;\n\n  /// This forms a link list of ConstantDataSequential nodes that have\n  /// the same value but different type.  For example, 0,0,0,1 could be a 4\n  /// element array of i8, or a 1-element array of i32.  They'll both end up in\n  /// the same StringMap bucket, linked up.\n  std::unique_ptr<ConstantDataSequential> Next;\n\n  void destroyConstantImpl();\n\nprotected:\n  explicit ConstantDataSequential(Type *ty, ValueTy VT, const char *Data)\n      : ConstantData(ty, VT), DataElements(Data) {}\n\n  static Constant *getImpl(StringRef Bytes, Type *Ty);\n\npublic:\n  ConstantDataSequential(const ConstantDataSequential &) = delete;\n\n  /// Return true if a ConstantDataSequential can be formed with a vector or\n  /// array of the specified element type.\n  /// ConstantDataArray only works with normal float and int types that are\n  /// stored densely in memory, not with things like i42 or x86_f80.\n  static bool isElementTypeCompatible(Type *Ty);\n\n  /// If this is a sequential container of integers (of any size), return the\n  /// specified element in the low bits of a uint64_t.\n  uint64_t getElementAsInteger(unsigned i) const;\n\n  /// If this is a sequential container of integers (of any size), return the\n  /// specified element as an APInt.\n  APInt getElementAsAPInt(unsigned i) const;\n\n  /// If this is a sequential container of floating point type, return the\n  /// specified element as an APFloat.\n  APFloat getElementAsAPFloat(unsigned i) const;\n\n  /// If this is an sequential container of floats, return the specified element\n  /// as a float.\n  float getElementAsFloat(unsigned i) const;\n\n  /// If this is an sequential container of doubles, return the specified\n  /// element as a double.\n  double getElementAsDouble(unsigned i) const;\n\n  /// Return a Constant for a specified index's element.\n  /// Note that this has to compute a new constant to return, so it isn't as\n  /// efficient as getElementAsInteger/Float/Double.\n  Constant *getElementAsConstant(unsigned i) const;\n\n  /// Return the element type of the array/vector.\n  Type *getElementType() const;\n\n  /// Return the number of elements in the array or vector.\n  unsigned getNumElements() const;\n\n  /// Return the size (in bytes) of each element in the array/vector.\n  /// The size of the elements is known to be a multiple of one byte.\n  uint64_t getElementByteSize() const;\n\n  /// This method returns true if this is an array of \\p CharSize integers.\n  bool isString(unsigned CharSize = 8) const;\n\n  /// This method returns true if the array \"isString\", ends with a null byte,\n  /// and does not contains any other null bytes.\n  bool isCString() const;\n\n  /// If this array is isString(), then this method returns the array as a\n  /// StringRef. Otherwise, it asserts out.\n  StringRef getAsString() const {\n    assert(isString() && \"Not a string\");\n    return getRawDataValues();\n  }\n\n  /// If this array is isCString(), then this method returns the array (without\n  /// the trailing null byte) as a StringRef. Otherwise, it asserts out.\n  StringRef getAsCString() const {\n    assert(isCString() && \"Isn't a C string\");\n    StringRef Str = getAsString();\n    return Str.substr(0, Str.size()-1);\n  }\n\n  /// Return the raw, underlying, bytes of this data. Note that this is an\n  /// extremely tricky thing to work with, as it exposes the host endianness of\n  /// the data elements.\n  StringRef getRawDataValues() const;\n\n  /// Methods for support type inquiry through isa, cast, and dyn_cast:\n  static bool classof(const Value *V) {\n    return V->getValueID() == ConstantDataArrayVal ||\n           V->getValueID() == ConstantDataVectorVal;\n  }\n\nprivate:\n  const char *getElementPointer(unsigned Elt) const;\n};\n\n//===----------------------------------------------------------------------===//\n/// An array constant whose element type is a simple 1/2/4/8-byte integer or\n/// float/double, and whose elements are just simple data values\n/// (i.e. ConstantInt/ConstantFP). This Constant node has no operands because it\n/// stores all of the elements of the constant as densely packed data, instead\n/// of as Value*'s.\nclass ConstantDataArray final : public ConstantDataSequential {\n  friend class ConstantDataSequential;\n\n  explicit ConstantDataArray(Type *ty, const char *Data)\n      : ConstantDataSequential(ty, ConstantDataArrayVal, Data) {}\n\npublic:\n  ConstantDataArray(const ConstantDataArray &) = delete;\n\n  /// get() constructor - Return a constant with array type with an element\n  /// count and element type matching the ArrayRef passed in.  Note that this\n  /// can return a ConstantAggregateZero object.\n  template <typename ElementTy>\n  static Constant *get(LLVMContext &Context, ArrayRef<ElementTy> Elts) {\n    const char *Data = reinterpret_cast<const char *>(Elts.data());\n    return getRaw(StringRef(Data, Elts.size() * sizeof(ElementTy)), Elts.size(),\n                  Type::getScalarTy<ElementTy>(Context));\n  }\n\n  /// get() constructor - ArrayTy needs to be compatible with\n  /// ArrayRef<ElementTy>. Calls get(LLVMContext, ArrayRef<ElementTy>).\n  template <typename ArrayTy>\n  static Constant *get(LLVMContext &Context, ArrayTy &Elts) {\n    return ConstantDataArray::get(Context, makeArrayRef(Elts));\n  }\n\n  /// get() constructor - Return a constant with array type with an element\n  /// count and element type matching the NumElements and ElementTy parameters\n  /// passed in. Note that this can return a ConstantAggregateZero object.\n  /// ElementTy needs to be one of i8/i16/i32/i64/float/double. Data is the\n  /// buffer containing the elements. Be careful to make sure Data uses the\n  /// right endianness, the buffer will be used as-is.\n  static Constant *getRaw(StringRef Data, uint64_t NumElements, Type *ElementTy) {\n    Type *Ty = ArrayType::get(ElementTy, NumElements);\n    return getImpl(Data, Ty);\n  }\n\n  /// getFP() constructors - Return a constant of array type with a float\n  /// element type taken from argument `ElementType', and count taken from\n  /// argument `Elts'.  The amount of bits of the contained type must match the\n  /// number of bits of the type contained in the passed in ArrayRef.\n  /// (i.e. half or bfloat for 16bits, float for 32bits, double for 64bits) Note\n  /// that this can return a ConstantAggregateZero object.\n  static Constant *getFP(Type *ElementType, ArrayRef<uint16_t> Elts);\n  static Constant *getFP(Type *ElementType, ArrayRef<uint32_t> Elts);\n  static Constant *getFP(Type *ElementType, ArrayRef<uint64_t> Elts);\n\n  /// This method constructs a CDS and initializes it with a text string.\n  /// The default behavior (AddNull==true) causes a null terminator to\n  /// be placed at the end of the array (increasing the length of the string by\n  /// one more than the StringRef would normally indicate.  Pass AddNull=false\n  /// to disable this behavior.\n  static Constant *getString(LLVMContext &Context, StringRef Initializer,\n                             bool AddNull = true);\n\n  /// Specialize the getType() method to always return an ArrayType,\n  /// which reduces the amount of casting needed in parts of the compiler.\n  inline ArrayType *getType() const {\n    return cast<ArrayType>(Value::getType());\n  }\n\n  /// Methods for support type inquiry through isa, cast, and dyn_cast:\n  static bool classof(const Value *V) {\n    return V->getValueID() == ConstantDataArrayVal;\n  }\n};\n\n//===----------------------------------------------------------------------===//\n/// A vector constant whose element type is a simple 1/2/4/8-byte integer or\n/// float/double, and whose elements are just simple data values\n/// (i.e. ConstantInt/ConstantFP). This Constant node has no operands because it\n/// stores all of the elements of the constant as densely packed data, instead\n/// of as Value*'s.\nclass ConstantDataVector final : public ConstantDataSequential {\n  friend class ConstantDataSequential;\n\n  explicit ConstantDataVector(Type *ty, const char *Data)\n      : ConstantDataSequential(ty, ConstantDataVectorVal, Data),\n        IsSplatSet(false) {}\n  // Cache whether or not the constant is a splat.\n  mutable bool IsSplatSet : 1;\n  mutable bool IsSplat : 1;\n  bool isSplatData() const;\n\npublic:\n  ConstantDataVector(const ConstantDataVector &) = delete;\n\n  /// get() constructors - Return a constant with vector type with an element\n  /// count and element type matching the ArrayRef passed in.  Note that this\n  /// can return a ConstantAggregateZero object.\n  static Constant *get(LLVMContext &Context, ArrayRef<uint8_t> Elts);\n  static Constant *get(LLVMContext &Context, ArrayRef<uint16_t> Elts);\n  static Constant *get(LLVMContext &Context, ArrayRef<uint32_t> Elts);\n  static Constant *get(LLVMContext &Context, ArrayRef<uint64_t> Elts);\n  static Constant *get(LLVMContext &Context, ArrayRef<float> Elts);\n  static Constant *get(LLVMContext &Context, ArrayRef<double> Elts);\n\n  /// getFP() constructors - Return a constant of vector type with a float\n  /// element type taken from argument `ElementType', and count taken from\n  /// argument `Elts'.  The amount of bits of the contained type must match the\n  /// number of bits of the type contained in the passed in ArrayRef.\n  /// (i.e. half or bfloat for 16bits, float for 32bits, double for 64bits) Note\n  /// that this can return a ConstantAggregateZero object.\n  static Constant *getFP(Type *ElementType, ArrayRef<uint16_t> Elts);\n  static Constant *getFP(Type *ElementType, ArrayRef<uint32_t> Elts);\n  static Constant *getFP(Type *ElementType, ArrayRef<uint64_t> Elts);\n\n  /// Return a ConstantVector with the specified constant in each element.\n  /// The specified constant has to be a of a compatible type (i8/i16/\n  /// i32/i64/float/double) and must be a ConstantFP or ConstantInt.\n  static Constant *getSplat(unsigned NumElts, Constant *Elt);\n\n  /// Returns true if this is a splat constant, meaning that all elements have\n  /// the same value.\n  bool isSplat() const;\n\n  /// If this is a splat constant, meaning that all of the elements have the\n  /// same value, return that value. Otherwise return NULL.\n  Constant *getSplatValue() const;\n\n  /// Specialize the getType() method to always return a FixedVectorType,\n  /// which reduces the amount of casting needed in parts of the compiler.\n  inline FixedVectorType *getType() const {\n    return cast<FixedVectorType>(Value::getType());\n  }\n\n  /// Methods for support type inquiry through isa, cast, and dyn_cast:\n  static bool classof(const Value *V) {\n    return V->getValueID() == ConstantDataVectorVal;\n  }\n};\n\n//===----------------------------------------------------------------------===//\n/// A constant token which is empty\n///\nclass ConstantTokenNone final : public ConstantData {\n  friend class Constant;\n\n  explicit ConstantTokenNone(LLVMContext &Context)\n      : ConstantData(Type::getTokenTy(Context), ConstantTokenNoneVal) {}\n\n  void destroyConstantImpl();\n\npublic:\n  ConstantTokenNone(const ConstantTokenNone &) = delete;\n\n  /// Return the ConstantTokenNone.\n  static ConstantTokenNone *get(LLVMContext &Context);\n\n  /// Methods to support type inquiry through isa, cast, and dyn_cast.\n  static bool classof(const Value *V) {\n    return V->getValueID() == ConstantTokenNoneVal;\n  }\n};\n\n/// The address of a basic block.\n///\nclass BlockAddress final : public Constant {\n  friend class Constant;\n\n  BlockAddress(Function *F, BasicBlock *BB);\n\n  void *operator new(size_t s) { return User::operator new(s, 2); }\n\n  void destroyConstantImpl();\n  Value *handleOperandChangeImpl(Value *From, Value *To);\n\npublic:\n  /// Return a BlockAddress for the specified function and basic block.\n  static BlockAddress *get(Function *F, BasicBlock *BB);\n\n  /// Return a BlockAddress for the specified basic block.  The basic\n  /// block must be embedded into a function.\n  static BlockAddress *get(BasicBlock *BB);\n\n  /// Lookup an existing \\c BlockAddress constant for the given BasicBlock.\n  ///\n  /// \\returns 0 if \\c !BB->hasAddressTaken(), otherwise the \\c BlockAddress.\n  static BlockAddress *lookup(const BasicBlock *BB);\n\n  /// Transparently provide more efficient getOperand methods.\n  DECLARE_TRANSPARENT_OPERAND_ACCESSORS(Value);\n\n  Function *getFunction() const { return (Function*)Op<0>().get(); }\n  BasicBlock *getBasicBlock() const { return (BasicBlock*)Op<1>().get(); }\n\n  /// Methods for support type inquiry through isa, cast, and dyn_cast:\n  static bool classof(const Value *V) {\n    return V->getValueID() == BlockAddressVal;\n  }\n};\n\ntemplate <>\nstruct OperandTraits<BlockAddress> :\n  public FixedNumOperandTraits<BlockAddress, 2> {\n};\n\nDEFINE_TRANSPARENT_OPERAND_ACCESSORS(BlockAddress, Value)\n\n/// Wrapper for a function that represents a value that\n/// functionally represents the original function. This can be a function,\n/// global alias to a function, or an ifunc.\nclass DSOLocalEquivalent final : public Constant {\n  friend class Constant;\n\n  DSOLocalEquivalent(GlobalValue *GV);\n\n  void *operator new(size_t s) { return User::operator new(s, 1); }\n\n  void destroyConstantImpl();\n  Value *handleOperandChangeImpl(Value *From, Value *To);\n\npublic:\n  /// Return a DSOLocalEquivalent for the specified global value.\n  static DSOLocalEquivalent *get(GlobalValue *GV);\n\n  /// Transparently provide more efficient getOperand methods.\n  DECLARE_TRANSPARENT_OPERAND_ACCESSORS(Value);\n\n  GlobalValue *getGlobalValue() const {\n    return cast<GlobalValue>(Op<0>().get());\n  }\n\n  /// Methods for support type inquiry through isa, cast, and dyn_cast:\n  static bool classof(const Value *V) {\n    return V->getValueID() == DSOLocalEquivalentVal;\n  }\n};\n\ntemplate <>\nstruct OperandTraits<DSOLocalEquivalent>\n    : public FixedNumOperandTraits<DSOLocalEquivalent, 1> {};\n\nDEFINE_TRANSPARENT_OPERAND_ACCESSORS(DSOLocalEquivalent, Value)\n\n//===----------------------------------------------------------------------===//\n/// A constant value that is initialized with an expression using\n/// other constant values.\n///\n/// This class uses the standard Instruction opcodes to define the various\n/// constant expressions.  The Opcode field for the ConstantExpr class is\n/// maintained in the Value::SubclassData field.\nclass ConstantExpr : public Constant {\n  friend struct ConstantExprKeyType;\n  friend class Constant;\n\n  void destroyConstantImpl();\n  Value *handleOperandChangeImpl(Value *From, Value *To);\n\nprotected:\n  ConstantExpr(Type *ty, unsigned Opcode, Use *Ops, unsigned NumOps)\n      : Constant(ty, ConstantExprVal, Ops, NumOps) {\n    // Operation type (an Instruction opcode) is stored as the SubclassData.\n    setValueSubclassData(Opcode);\n  }\n\n  ~ConstantExpr() = default;\n\npublic:\n  // Static methods to construct a ConstantExpr of different kinds.  Note that\n  // these methods may return a object that is not an instance of the\n  // ConstantExpr class, because they will attempt to fold the constant\n  // expression into something simpler if possible.\n\n  /// getAlignOf constant expr - computes the alignment of a type in a target\n  /// independent way (Note: the return type is an i64).\n  static Constant *getAlignOf(Type *Ty);\n\n  /// getSizeOf constant expr - computes the (alloc) size of a type (in\n  /// address-units, not bits) in a target independent way (Note: the return\n  /// type is an i64).\n  ///\n  static Constant *getSizeOf(Type *Ty);\n\n  /// getOffsetOf constant expr - computes the offset of a struct field in a\n  /// target independent way (Note: the return type is an i64).\n  ///\n  static Constant *getOffsetOf(StructType *STy, unsigned FieldNo);\n\n  /// getOffsetOf constant expr - This is a generalized form of getOffsetOf,\n  /// which supports any aggregate type, and any Constant index.\n  ///\n  static Constant *getOffsetOf(Type *Ty, Constant *FieldNo);\n\n  static Constant *getNeg(Constant *C, bool HasNUW = false, bool HasNSW =false);\n  static Constant *getFNeg(Constant *C);\n  static Constant *getNot(Constant *C);\n  static Constant *getAdd(Constant *C1, Constant *C2,\n                          bool HasNUW = false, bool HasNSW = false);\n  static Constant *getFAdd(Constant *C1, Constant *C2);\n  static Constant *getSub(Constant *C1, Constant *C2,\n                          bool HasNUW = false, bool HasNSW = false);\n  static Constant *getFSub(Constant *C1, Constant *C2);\n  static Constant *getMul(Constant *C1, Constant *C2,\n                          bool HasNUW = false, bool HasNSW = false);\n  static Constant *getFMul(Constant *C1, Constant *C2);\n  static Constant *getUDiv(Constant *C1, Constant *C2, bool isExact = false);\n  static Constant *getSDiv(Constant *C1, Constant *C2, bool isExact = false);\n  static Constant *getFDiv(Constant *C1, Constant *C2);\n  static Constant *getURem(Constant *C1, Constant *C2);\n  static Constant *getSRem(Constant *C1, Constant *C2);\n  static Constant *getFRem(Constant *C1, Constant *C2);\n  static Constant *getAnd(Constant *C1, Constant *C2);\n  static Constant *getOr(Constant *C1, Constant *C2);\n  static Constant *getXor(Constant *C1, Constant *C2);\n  static Constant *getUMin(Constant *C1, Constant *C2);\n  static Constant *getShl(Constant *C1, Constant *C2,\n                          bool HasNUW = false, bool HasNSW = false);\n  static Constant *getLShr(Constant *C1, Constant *C2, bool isExact = false);\n  static Constant *getAShr(Constant *C1, Constant *C2, bool isExact = false);\n  static Constant *getTrunc(Constant *C, Type *Ty, bool OnlyIfReduced = false);\n  static Constant *getSExt(Constant *C, Type *Ty, bool OnlyIfReduced = false);\n  static Constant *getZExt(Constant *C, Type *Ty, bool OnlyIfReduced = false);\n  static Constant *getFPTrunc(Constant *C, Type *Ty,\n                              bool OnlyIfReduced = false);\n  static Constant *getFPExtend(Constant *C, Type *Ty,\n                               bool OnlyIfReduced = false);\n  static Constant *getUIToFP(Constant *C, Type *Ty, bool OnlyIfReduced = false);\n  static Constant *getSIToFP(Constant *C, Type *Ty, bool OnlyIfReduced = false);\n  static Constant *getFPToUI(Constant *C, Type *Ty, bool OnlyIfReduced = false);\n  static Constant *getFPToSI(Constant *C, Type *Ty, bool OnlyIfReduced = false);\n  static Constant *getPtrToInt(Constant *C, Type *Ty,\n                               bool OnlyIfReduced = false);\n  static Constant *getIntToPtr(Constant *C, Type *Ty,\n                               bool OnlyIfReduced = false);\n  static Constant *getBitCast(Constant *C, Type *Ty,\n                              bool OnlyIfReduced = false);\n  static Constant *getAddrSpaceCast(Constant *C, Type *Ty,\n                                    bool OnlyIfReduced = false);\n\n  static Constant *getNSWNeg(Constant *C) { return getNeg(C, false, true); }\n  static Constant *getNUWNeg(Constant *C) { return getNeg(C, true, false); }\n\n  static Constant *getNSWAdd(Constant *C1, Constant *C2) {\n    return getAdd(C1, C2, false, true);\n  }\n\n  static Constant *getNUWAdd(Constant *C1, Constant *C2) {\n    return getAdd(C1, C2, true, false);\n  }\n\n  static Constant *getNSWSub(Constant *C1, Constant *C2) {\n    return getSub(C1, C2, false, true);\n  }\n\n  static Constant *getNUWSub(Constant *C1, Constant *C2) {\n    return getSub(C1, C2, true, false);\n  }\n\n  static Constant *getNSWMul(Constant *C1, Constant *C2) {\n    return getMul(C1, C2, false, true);\n  }\n\n  static Constant *getNUWMul(Constant *C1, Constant *C2) {\n    return getMul(C1, C2, true, false);\n  }\n\n  static Constant *getNSWShl(Constant *C1, Constant *C2) {\n    return getShl(C1, C2, false, true);\n  }\n\n  static Constant *getNUWShl(Constant *C1, Constant *C2) {\n    return getShl(C1, C2, true, false);\n  }\n\n  static Constant *getExactSDiv(Constant *C1, Constant *C2) {\n    return getSDiv(C1, C2, true);\n  }\n\n  static Constant *getExactUDiv(Constant *C1, Constant *C2) {\n    return getUDiv(C1, C2, true);\n  }\n\n  static Constant *getExactAShr(Constant *C1, Constant *C2) {\n    return getAShr(C1, C2, true);\n  }\n\n  static Constant *getExactLShr(Constant *C1, Constant *C2) {\n    return getLShr(C1, C2, true);\n  }\n\n  /// If C is a scalar/fixed width vector of known powers of 2, then this\n  /// function returns a new scalar/fixed width vector obtained from logBase2\n  /// of C. Undef vector elements are set to zero.\n  /// Return a null pointer otherwise.\n  static Constant *getExactLogBase2(Constant *C);\n\n  /// Return the identity constant for a binary opcode.\n  /// The identity constant C is defined as X op C = X and C op X = X for every\n  /// X when the binary operation is commutative. If the binop is not\n  /// commutative, callers can acquire the operand 1 identity constant by\n  /// setting AllowRHSConstant to true. For example, any shift has a zero\n  /// identity constant for operand 1: X shift 0 = X.\n  /// Return nullptr if the operator does not have an identity constant.\n  static Constant *getBinOpIdentity(unsigned Opcode, Type *Ty,\n                                    bool AllowRHSConstant = false);\n\n  /// Return the absorbing element for the given binary\n  /// operation, i.e. a constant C such that X op C = C and C op X = C for\n  /// every X.  For example, this returns zero for integer multiplication.\n  /// It returns null if the operator doesn't have an absorbing element.\n  static Constant *getBinOpAbsorber(unsigned Opcode, Type *Ty);\n\n  /// Transparently provide more efficient getOperand methods.\n  DECLARE_TRANSPARENT_OPERAND_ACCESSORS(Constant);\n\n  /// Convenience function for getting a Cast operation.\n  ///\n  /// \\param ops The opcode for the conversion\n  /// \\param C  The constant to be converted\n  /// \\param Ty The type to which the constant is converted\n  /// \\param OnlyIfReduced see \\a getWithOperands() docs.\n  static Constant *getCast(unsigned ops, Constant *C, Type *Ty,\n                           bool OnlyIfReduced = false);\n\n  // Create a ZExt or BitCast cast constant expression\n  static Constant *getZExtOrBitCast(\n    Constant *C,   ///< The constant to zext or bitcast\n    Type *Ty ///< The type to zext or bitcast C to\n  );\n\n  // Create a SExt or BitCast cast constant expression\n  static Constant *getSExtOrBitCast(\n    Constant *C,   ///< The constant to sext or bitcast\n    Type *Ty ///< The type to sext or bitcast C to\n  );\n\n  // Create a Trunc or BitCast cast constant expression\n  static Constant *getTruncOrBitCast(\n    Constant *C,   ///< The constant to trunc or bitcast\n    Type *Ty ///< The type to trunc or bitcast C to\n  );\n\n  /// Create a BitCast, AddrSpaceCast, or a PtrToInt cast constant\n  /// expression.\n  static Constant *getPointerCast(\n    Constant *C,   ///< The pointer value to be casted (operand 0)\n    Type *Ty ///< The type to which cast should be made\n  );\n\n  /// Create a BitCast or AddrSpaceCast for a pointer type depending on\n  /// the address space.\n  static Constant *getPointerBitCastOrAddrSpaceCast(\n    Constant *C,   ///< The constant to addrspacecast or bitcast\n    Type *Ty ///< The type to bitcast or addrspacecast C to\n  );\n\n  /// Create a ZExt, Bitcast or Trunc for integer -> integer casts\n  static Constant *getIntegerCast(\n    Constant *C,    ///< The integer constant to be casted\n    Type *Ty, ///< The integer type to cast to\n    bool isSigned   ///< Whether C should be treated as signed or not\n  );\n\n  /// Create a FPExt, Bitcast or FPTrunc for fp -> fp casts\n  static Constant *getFPCast(\n    Constant *C,    ///< The integer constant to be casted\n    Type *Ty ///< The integer type to cast to\n  );\n\n  /// Return true if this is a convert constant expression\n  bool isCast() const;\n\n  /// Return true if this is a compare constant expression\n  bool isCompare() const;\n\n  /// Return true if this is an insertvalue or extractvalue expression,\n  /// and the getIndices() method may be used.\n  bool hasIndices() const;\n\n  /// Return true if this is a getelementptr expression and all\n  /// the index operands are compile-time known integers within the\n  /// corresponding notional static array extents. Note that this is\n  /// not equivalant to, a subset of, or a superset of the \"inbounds\"\n  /// property.\n  bool isGEPWithNoNotionalOverIndexing() const;\n\n  /// Select constant expr\n  ///\n  /// \\param OnlyIfReducedTy see \\a getWithOperands() docs.\n  static Constant *getSelect(Constant *C, Constant *V1, Constant *V2,\n                             Type *OnlyIfReducedTy = nullptr);\n\n  /// get - Return a unary operator constant expression,\n  /// folding if possible.\n  ///\n  /// \\param OnlyIfReducedTy see \\a getWithOperands() docs.\n  static Constant *get(unsigned Opcode, Constant *C1, unsigned Flags = 0, \n                       Type *OnlyIfReducedTy = nullptr);\n\n  /// get - Return a binary or shift operator constant expression,\n  /// folding if possible.\n  ///\n  /// \\param OnlyIfReducedTy see \\a getWithOperands() docs.\n  static Constant *get(unsigned Opcode, Constant *C1, Constant *C2,\n                       unsigned Flags = 0, Type *OnlyIfReducedTy = nullptr);\n\n  /// Return an ICmp or FCmp comparison operator constant expression.\n  ///\n  /// \\param OnlyIfReduced see \\a getWithOperands() docs.\n  static Constant *getCompare(unsigned short pred, Constant *C1, Constant *C2,\n                              bool OnlyIfReduced = false);\n\n  /// get* - Return some common constants without having to\n  /// specify the full Instruction::OPCODE identifier.\n  ///\n  static Constant *getICmp(unsigned short pred, Constant *LHS, Constant *RHS,\n                           bool OnlyIfReduced = false);\n  static Constant *getFCmp(unsigned short pred, Constant *LHS, Constant *RHS,\n                           bool OnlyIfReduced = false);\n\n  /// Getelementptr form.  Value* is only accepted for convenience;\n  /// all elements must be Constants.\n  ///\n  /// \\param InRangeIndex the inrange index if present or None.\n  /// \\param OnlyIfReducedTy see \\a getWithOperands() docs.\n  static Constant *getGetElementPtr(Type *Ty, Constant *C,\n                                    ArrayRef<Constant *> IdxList,\n                                    bool InBounds = false,\n                                    Optional<unsigned> InRangeIndex = None,\n                                    Type *OnlyIfReducedTy = nullptr) {\n    return getGetElementPtr(\n        Ty, C, makeArrayRef((Value * const *)IdxList.data(), IdxList.size()),\n        InBounds, InRangeIndex, OnlyIfReducedTy);\n  }\n  static Constant *getGetElementPtr(Type *Ty, Constant *C, Constant *Idx,\n                                    bool InBounds = false,\n                                    Optional<unsigned> InRangeIndex = None,\n                                    Type *OnlyIfReducedTy = nullptr) {\n    // This form of the function only exists to avoid ambiguous overload\n    // warnings about whether to convert Idx to ArrayRef<Constant *> or\n    // ArrayRef<Value *>.\n    return getGetElementPtr(Ty, C, cast<Value>(Idx), InBounds, InRangeIndex,\n                            OnlyIfReducedTy);\n  }\n  static Constant *getGetElementPtr(Type *Ty, Constant *C,\n                                    ArrayRef<Value *> IdxList,\n                                    bool InBounds = false,\n                                    Optional<unsigned> InRangeIndex = None,\n                                    Type *OnlyIfReducedTy = nullptr);\n\n  /// Create an \"inbounds\" getelementptr. See the documentation for the\n  /// \"inbounds\" flag in LangRef.html for details.\n  static Constant *getInBoundsGetElementPtr(Type *Ty, Constant *C,\n                                            ArrayRef<Constant *> IdxList) {\n    return getGetElementPtr(Ty, C, IdxList, true);\n  }\n  static Constant *getInBoundsGetElementPtr(Type *Ty, Constant *C,\n                                            Constant *Idx) {\n    // This form of the function only exists to avoid ambiguous overload\n    // warnings about whether to convert Idx to ArrayRef<Constant *> or\n    // ArrayRef<Value *>.\n    return getGetElementPtr(Ty, C, Idx, true);\n  }\n  static Constant *getInBoundsGetElementPtr(Type *Ty, Constant *C,\n                                            ArrayRef<Value *> IdxList) {\n    return getGetElementPtr(Ty, C, IdxList, true);\n  }\n\n  static Constant *getExtractElement(Constant *Vec, Constant *Idx,\n                                     Type *OnlyIfReducedTy = nullptr);\n  static Constant *getInsertElement(Constant *Vec, Constant *Elt, Constant *Idx,\n                                    Type *OnlyIfReducedTy = nullptr);\n  static Constant *getShuffleVector(Constant *V1, Constant *V2,\n                                    ArrayRef<int> Mask,\n                                    Type *OnlyIfReducedTy = nullptr);\n  static Constant *getExtractValue(Constant *Agg, ArrayRef<unsigned> Idxs,\n                                   Type *OnlyIfReducedTy = nullptr);\n  static Constant *getInsertValue(Constant *Agg, Constant *Val,\n                                  ArrayRef<unsigned> Idxs,\n                                  Type *OnlyIfReducedTy = nullptr);\n\n  /// Return the opcode at the root of this constant expression\n  unsigned getOpcode() const { return getSubclassDataFromValue(); }\n\n  /// Return the ICMP or FCMP predicate value. Assert if this is not an ICMP or\n  /// FCMP constant expression.\n  unsigned getPredicate() const;\n\n  /// Assert that this is an insertvalue or exactvalue\n  /// expression and return the list of indices.\n  ArrayRef<unsigned> getIndices() const;\n\n  /// Assert that this is a shufflevector and return the mask. See class\n  /// ShuffleVectorInst for a description of the mask representation.\n  ArrayRef<int> getShuffleMask() const;\n\n  /// Assert that this is a shufflevector and return the mask.\n  ///\n  /// TODO: This is a temporary hack until we update the bitcode format for\n  /// shufflevector.\n  Constant *getShuffleMaskForBitcode() const;\n\n  /// Return a string representation for an opcode.\n  const char *getOpcodeName() const;\n\n  /// Return a constant expression identical to this one, but with the specified\n  /// operand set to the specified value.\n  Constant *getWithOperandReplaced(unsigned OpNo, Constant *Op) const;\n\n  /// This returns the current constant expression with the operands replaced\n  /// with the specified values. The specified array must have the same number\n  /// of operands as our current one.\n  Constant *getWithOperands(ArrayRef<Constant*> Ops) const {\n    return getWithOperands(Ops, getType());\n  }\n\n  /// Get the current expression with the operands replaced.\n  ///\n  /// Return the current constant expression with the operands replaced with \\c\n  /// Ops and the type with \\c Ty.  The new operands must have the same number\n  /// as the current ones.\n  ///\n  /// If \\c OnlyIfReduced is \\c true, nullptr will be returned unless something\n  /// gets constant-folded, the type changes, or the expression is otherwise\n  /// canonicalized.  This parameter should almost always be \\c false.\n  Constant *getWithOperands(ArrayRef<Constant *> Ops, Type *Ty,\n                            bool OnlyIfReduced = false,\n                            Type *SrcTy = nullptr) const;\n\n  /// Returns an Instruction which implements the same operation as this\n  /// ConstantExpr. The instruction is not linked to any basic block.\n  ///\n  /// A better approach to this could be to have a constructor for Instruction\n  /// which would take a ConstantExpr parameter, but that would have spread\n  /// implementation details of ConstantExpr outside of Constants.cpp, which\n  /// would make it harder to remove ConstantExprs altogether.\n  Instruction *getAsInstruction() const;\n\n  /// Methods for support type inquiry through isa, cast, and dyn_cast:\n  static bool classof(const Value *V) {\n    return V->getValueID() == ConstantExprVal;\n  }\n\nprivate:\n  // Shadow Value::setValueSubclassData with a private forwarding method so that\n  // subclasses cannot accidentally use it.\n  void setValueSubclassData(unsigned short D) {\n    Value::setValueSubclassData(D);\n  }\n};\n\ntemplate <>\nstruct OperandTraits<ConstantExpr> :\n  public VariadicOperandTraits<ConstantExpr, 1> {\n};\n\nDEFINE_TRANSPARENT_OPERAND_ACCESSORS(ConstantExpr, Constant)\n\n//===----------------------------------------------------------------------===//\n/// 'undef' values are things that do not have specified contents.\n/// These are used for a variety of purposes, including global variable\n/// initializers and operands to instructions.  'undef' values can occur with\n/// any first-class type.\n///\n/// Undef values aren't exactly constants; if they have multiple uses, they\n/// can appear to have different bit patterns at each use. See\n/// LangRef.html#undefvalues for details.\n///\nclass UndefValue : public ConstantData {\n  friend class Constant;\n\n  explicit UndefValue(Type *T) : ConstantData(T, UndefValueVal) {}\n\n  void destroyConstantImpl();\n\nprotected:\n  explicit UndefValue(Type *T, ValueTy vty) : ConstantData(T, vty) {}\n\npublic:\n  UndefValue(const UndefValue &) = delete;\n\n  /// Static factory methods - Return an 'undef' object of the specified type.\n  static UndefValue *get(Type *T);\n\n  /// If this Undef has array or vector type, return a undef with the right\n  /// element type.\n  UndefValue *getSequentialElement() const;\n\n  /// If this undef has struct type, return a undef with the right element type\n  /// for the specified element.\n  UndefValue *getStructElement(unsigned Elt) const;\n\n  /// Return an undef of the right value for the specified GEP index if we can,\n  /// otherwise return null (e.g. if C is a ConstantExpr).\n  UndefValue *getElementValue(Constant *C) const;\n\n  /// Return an undef of the right value for the specified GEP index.\n  UndefValue *getElementValue(unsigned Idx) const;\n\n  /// Return the number of elements in the array, vector, or struct.\n  unsigned getNumElements() const;\n\n  /// Methods for support type inquiry through isa, cast, and dyn_cast:\n  static bool classof(const Value *V) {\n    return V->getValueID() == UndefValueVal ||\n           V->getValueID() == PoisonValueVal;\n  }\n};\n\n//===----------------------------------------------------------------------===//\n/// In order to facilitate speculative execution, many instructions do not\n/// invoke immediate undefined behavior when provided with illegal operands,\n/// and return a poison value instead.\n///\n/// see LangRef.html#poisonvalues for details.\n///\nclass PoisonValue final : public UndefValue {\n  friend class Constant;\n\n  explicit PoisonValue(Type *T) : UndefValue(T, PoisonValueVal) {}\n\n  void destroyConstantImpl();\n\npublic:\n  PoisonValue(const PoisonValue &) = delete;\n\n  /// Static factory methods - Return an 'poison' object of the specified type.\n  static PoisonValue *get(Type *T);\n\n  /// If this poison has array or vector type, return a poison with the right\n  /// element type.\n  PoisonValue *getSequentialElement() const;\n\n  /// If this poison has struct type, return a poison with the right element\n  /// type for the specified element.\n  PoisonValue *getStructElement(unsigned Elt) const;\n\n  /// Return an poison of the right value for the specified GEP index if we can,\n  /// otherwise return null (e.g. if C is a ConstantExpr).\n  PoisonValue *getElementValue(Constant *C) const;\n\n  /// Return an poison of the right value for the specified GEP index.\n  PoisonValue *getElementValue(unsigned Idx) const;\n\n  /// Methods for support type inquiry through isa, cast, and dyn_cast:\n  static bool classof(const Value *V) {\n    return V->getValueID() == PoisonValueVal;\n  }\n};\n\n} // end namespace llvm\n\n#endif // LLVM_IR_CONSTANTS_H\n"}, "37": {"id": 37, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/IR/DebugInfoMetadata.h", "content": "//===- llvm/IR/DebugInfoMetadata.h - Debug info metadata --------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// Declarations for metadata specific to debug info.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_IR_DEBUGINFOMETADATA_H\n#define LLVM_IR_DEBUGINFOMETADATA_H\n\n#include \"llvm/ADT/ArrayRef.h\"\n#include \"llvm/ADT/BitmaskEnum.h\"\n#include \"llvm/ADT/None.h\"\n#include \"llvm/ADT/Optional.h\"\n#include \"llvm/ADT/PointerUnion.h\"\n#include \"llvm/ADT/STLExtras.h\"\n#include \"llvm/ADT/SmallVector.h\"\n#include \"llvm/ADT/StringRef.h\"\n#include \"llvm/ADT/iterator_range.h\"\n#include \"llvm/BinaryFormat/Dwarf.h\"\n#include \"llvm/IR/Constants.h\"\n#include \"llvm/IR/Metadata.h\"\n#include \"llvm/Support/Casting.h\"\n#include <cassert>\n#include <climits>\n#include <cstddef>\n#include <cstdint>\n#include <iterator>\n#include <type_traits>\n#include <vector>\n\n// Helper macros for defining get() overrides.\n#define DEFINE_MDNODE_GET_UNPACK_IMPL(...) __VA_ARGS__\n#define DEFINE_MDNODE_GET_UNPACK(ARGS) DEFINE_MDNODE_GET_UNPACK_IMPL ARGS\n#define DEFINE_MDNODE_GET_DISTINCT_TEMPORARY(CLASS, FORMAL, ARGS)              \\\n  static CLASS *getDistinct(LLVMContext &Context,                              \\\n                            DEFINE_MDNODE_GET_UNPACK(FORMAL)) {                \\\n    return getImpl(Context, DEFINE_MDNODE_GET_UNPACK(ARGS), Distinct);         \\\n  }                                                                            \\\n  static Temp##CLASS getTemporary(LLVMContext &Context,                        \\\n                                  DEFINE_MDNODE_GET_UNPACK(FORMAL)) {          \\\n    return Temp##CLASS(                                                        \\\n        getImpl(Context, DEFINE_MDNODE_GET_UNPACK(ARGS), Temporary));          \\\n  }\n#define DEFINE_MDNODE_GET(CLASS, FORMAL, ARGS)                                 \\\n  static CLASS *get(LLVMContext &Context, DEFINE_MDNODE_GET_UNPACK(FORMAL)) {  \\\n    return getImpl(Context, DEFINE_MDNODE_GET_UNPACK(ARGS), Uniqued);          \\\n  }                                                                            \\\n  static CLASS *getIfExists(LLVMContext &Context,                              \\\n                            DEFINE_MDNODE_GET_UNPACK(FORMAL)) {                \\\n    return getImpl(Context, DEFINE_MDNODE_GET_UNPACK(ARGS), Uniqued,           \\\n                   /* ShouldCreate */ false);                                  \\\n  }                                                                            \\\n  DEFINE_MDNODE_GET_DISTINCT_TEMPORARY(CLASS, FORMAL, ARGS)\n\nnamespace llvm {\n\nclass DITypeRefArray {\n  const MDTuple *N = nullptr;\n\npublic:\n  DITypeRefArray() = default;\n  DITypeRefArray(const MDTuple *N) : N(N) {}\n\n  explicit operator bool() const { return get(); }\n  explicit operator MDTuple *() const { return get(); }\n\n  MDTuple *get() const { return const_cast<MDTuple *>(N); }\n  MDTuple *operator->() const { return get(); }\n  MDTuple &operator*() const { return *get(); }\n\n  // FIXME: Fix callers and remove condition on N.\n  unsigned size() const { return N ? N->getNumOperands() : 0u; }\n  DIType *operator[](unsigned I) const {\n    return cast_or_null<DIType>(N->getOperand(I));\n  }\n\n  class iterator : std::iterator<std::input_iterator_tag, DIType *,\n                                 std::ptrdiff_t, void, DIType *> {\n    MDNode::op_iterator I = nullptr;\n\n  public:\n    iterator() = default;\n    explicit iterator(MDNode::op_iterator I) : I(I) {}\n\n    DIType *operator*() const { return cast_or_null<DIType>(*I); }\n\n    iterator &operator++() {\n      ++I;\n      return *this;\n    }\n\n    iterator operator++(int) {\n      iterator Temp(*this);\n      ++I;\n      return Temp;\n    }\n\n    bool operator==(const iterator &X) const { return I == X.I; }\n    bool operator!=(const iterator &X) const { return I != X.I; }\n  };\n\n  // FIXME: Fix callers and remove condition on N.\n  iterator begin() const { return N ? iterator(N->op_begin()) : iterator(); }\n  iterator end() const { return N ? iterator(N->op_end()) : iterator(); }\n};\n\n/// Tagged DWARF-like metadata node.\n///\n/// A metadata node with a DWARF tag (i.e., a constant named \\c DW_TAG_*,\n/// defined in llvm/BinaryFormat/Dwarf.h).  Called \\a DINode because it's\n/// potentially used for non-DWARF output.\nclass DINode : public MDNode {\n  friend class LLVMContextImpl;\n  friend class MDNode;\n\nprotected:\n  DINode(LLVMContext &C, unsigned ID, StorageType Storage, unsigned Tag,\n         ArrayRef<Metadata *> Ops1, ArrayRef<Metadata *> Ops2 = None)\n      : MDNode(C, ID, Storage, Ops1, Ops2) {\n    assert(Tag < 1u << 16);\n    SubclassData16 = Tag;\n  }\n  ~DINode() = default;\n\n  template <class Ty> Ty *getOperandAs(unsigned I) const {\n    return cast_or_null<Ty>(getOperand(I));\n  }\n\n  StringRef getStringOperand(unsigned I) const {\n    if (auto *S = getOperandAs<MDString>(I))\n      return S->getString();\n    return StringRef();\n  }\n\n  static MDString *getCanonicalMDString(LLVMContext &Context, StringRef S) {\n    if (S.empty())\n      return nullptr;\n    return MDString::get(Context, S);\n  }\n\n  /// Allow subclasses to mutate the tag.\n  void setTag(unsigned Tag) { SubclassData16 = Tag; }\n\npublic:\n  unsigned getTag() const { return SubclassData16; }\n\n  /// Debug info flags.\n  ///\n  /// The three accessibility flags are mutually exclusive and rolled together\n  /// in the first two bits.\n  enum DIFlags : uint32_t {\n#define HANDLE_DI_FLAG(ID, NAME) Flag##NAME = ID,\n#define DI_FLAG_LARGEST_NEEDED\n#include \"llvm/IR/DebugInfoFlags.def\"\n    FlagAccessibility = FlagPrivate | FlagProtected | FlagPublic,\n    FlagPtrToMemberRep = FlagSingleInheritance | FlagMultipleInheritance |\n                         FlagVirtualInheritance,\n    LLVM_MARK_AS_BITMASK_ENUM(FlagLargest)\n  };\n\n  static DIFlags getFlag(StringRef Flag);\n  static StringRef getFlagString(DIFlags Flag);\n\n  /// Split up a flags bitfield.\n  ///\n  /// Split \\c Flags into \\c SplitFlags, a vector of its components.  Returns\n  /// any remaining (unrecognized) bits.\n  static DIFlags splitFlags(DIFlags Flags,\n                            SmallVectorImpl<DIFlags> &SplitFlags);\n\n  static bool classof(const Metadata *MD) {\n    switch (MD->getMetadataID()) {\n    default:\n      return false;\n    case GenericDINodeKind:\n    case DISubrangeKind:\n    case DIEnumeratorKind:\n    case DIBasicTypeKind:\n    case DIStringTypeKind:\n    case DIDerivedTypeKind:\n    case DICompositeTypeKind:\n    case DISubroutineTypeKind:\n    case DIFileKind:\n    case DICompileUnitKind:\n    case DISubprogramKind:\n    case DILexicalBlockKind:\n    case DILexicalBlockFileKind:\n    case DINamespaceKind:\n    case DICommonBlockKind:\n    case DITemplateTypeParameterKind:\n    case DITemplateValueParameterKind:\n    case DIGlobalVariableKind:\n    case DILocalVariableKind:\n    case DILabelKind:\n    case DIObjCPropertyKind:\n    case DIImportedEntityKind:\n    case DIModuleKind:\n    case DIGenericSubrangeKind:\n      return true;\n    }\n  }\n};\n\n/// Generic tagged DWARF-like metadata node.\n///\n/// An un-specialized DWARF-like metadata node.  The first operand is a\n/// (possibly empty) null-separated \\a MDString header that contains arbitrary\n/// fields.  The remaining operands are \\a dwarf_operands(), and are pointers\n/// to other metadata.\nclass GenericDINode : public DINode {\n  friend class LLVMContextImpl;\n  friend class MDNode;\n\n  GenericDINode(LLVMContext &C, StorageType Storage, unsigned Hash,\n                unsigned Tag, ArrayRef<Metadata *> Ops1,\n                ArrayRef<Metadata *> Ops2)\n      : DINode(C, GenericDINodeKind, Storage, Tag, Ops1, Ops2) {\n    setHash(Hash);\n  }\n  ~GenericDINode() { dropAllReferences(); }\n\n  void setHash(unsigned Hash) { SubclassData32 = Hash; }\n  void recalculateHash();\n\n  static GenericDINode *getImpl(LLVMContext &Context, unsigned Tag,\n                                StringRef Header, ArrayRef<Metadata *> DwarfOps,\n                                StorageType Storage, bool ShouldCreate = true) {\n    return getImpl(Context, Tag, getCanonicalMDString(Context, Header),\n                   DwarfOps, Storage, ShouldCreate);\n  }\n\n  static GenericDINode *getImpl(LLVMContext &Context, unsigned Tag,\n                                MDString *Header, ArrayRef<Metadata *> DwarfOps,\n                                StorageType Storage, bool ShouldCreate = true);\n\n  TempGenericDINode cloneImpl() const {\n    return getTemporary(getContext(), getTag(), getHeader(),\n                        SmallVector<Metadata *, 4>(dwarf_operands()));\n  }\n\npublic:\n  unsigned getHash() const { return SubclassData32; }\n\n  DEFINE_MDNODE_GET(GenericDINode, (unsigned Tag, StringRef Header,\n                                    ArrayRef<Metadata *> DwarfOps),\n                    (Tag, Header, DwarfOps))\n  DEFINE_MDNODE_GET(GenericDINode, (unsigned Tag, MDString *Header,\n                                    ArrayRef<Metadata *> DwarfOps),\n                    (Tag, Header, DwarfOps))\n\n  /// Return a (temporary) clone of this.\n  TempGenericDINode clone() const { return cloneImpl(); }\n\n  unsigned getTag() const { return SubclassData16; }\n  StringRef getHeader() const { return getStringOperand(0); }\n  MDString *getRawHeader() const { return getOperandAs<MDString>(0); }\n\n  op_iterator dwarf_op_begin() const { return op_begin() + 1; }\n  op_iterator dwarf_op_end() const { return op_end(); }\n  op_range dwarf_operands() const {\n    return op_range(dwarf_op_begin(), dwarf_op_end());\n  }\n\n  unsigned getNumDwarfOperands() const { return getNumOperands() - 1; }\n  const MDOperand &getDwarfOperand(unsigned I) const {\n    return getOperand(I + 1);\n  }\n  void replaceDwarfOperandWith(unsigned I, Metadata *New) {\n    replaceOperandWith(I + 1, New);\n  }\n\n  static bool classof(const Metadata *MD) {\n    return MD->getMetadataID() == GenericDINodeKind;\n  }\n};\n\n/// Array subrange.\n///\n/// TODO: Merge into node for DW_TAG_array_type, which should have a custom\n/// type.\nclass DISubrange : public DINode {\n  friend class LLVMContextImpl;\n  friend class MDNode;\n\n  DISubrange(LLVMContext &C, StorageType Storage, ArrayRef<Metadata *> Ops)\n      : DINode(C, DISubrangeKind, Storage, dwarf::DW_TAG_subrange_type, Ops) {}\n\n  ~DISubrange() = default;\n\n  static DISubrange *getImpl(LLVMContext &Context, int64_t Count,\n                             int64_t LowerBound, StorageType Storage,\n                             bool ShouldCreate = true);\n\n  static DISubrange *getImpl(LLVMContext &Context, Metadata *CountNode,\n                             int64_t LowerBound, StorageType Storage,\n                             bool ShouldCreate = true);\n\n  static DISubrange *getImpl(LLVMContext &Context, Metadata *CountNode,\n                             Metadata *LowerBound, Metadata *UpperBound,\n                             Metadata *Stride, StorageType Storage,\n                             bool ShouldCreate = true);\n\n  TempDISubrange cloneImpl() const {\n    return getTemporary(getContext(), getRawCountNode(), getRawLowerBound(),\n                        getRawUpperBound(), getRawStride());\n  }\n\npublic:\n  DEFINE_MDNODE_GET(DISubrange, (int64_t Count, int64_t LowerBound = 0),\n                    (Count, LowerBound))\n\n  DEFINE_MDNODE_GET(DISubrange, (Metadata *CountNode, int64_t LowerBound = 0),\n                    (CountNode, LowerBound))\n\n  DEFINE_MDNODE_GET(DISubrange,\n                    (Metadata * CountNode, Metadata *LowerBound,\n                     Metadata *UpperBound, Metadata *Stride),\n                    (CountNode, LowerBound, UpperBound, Stride))\n\n  TempDISubrange clone() const { return cloneImpl(); }\n\n  Metadata *getRawCountNode() const {\n    return getOperand(0).get();\n  }\n\n  Metadata *getRawLowerBound() const { return getOperand(1).get(); }\n\n  Metadata *getRawUpperBound() const { return getOperand(2).get(); }\n\n  Metadata *getRawStride() const { return getOperand(3).get(); }\n\n  typedef PointerUnion<ConstantInt*, DIVariable*> CountType;\n  typedef PointerUnion<ConstantInt *, DIVariable *, DIExpression *> BoundType;\n\n  CountType getCount() const;\n\n  BoundType getLowerBound() const;\n\n  BoundType getUpperBound() const;\n\n  BoundType getStride() const;\n\n  static bool classof(const Metadata *MD) {\n    return MD->getMetadataID() == DISubrangeKind;\n  }\n};\n\nclass DIGenericSubrange : public DINode {\n  friend class LLVMContextImpl;\n  friend class MDNode;\n\n  DIGenericSubrange(LLVMContext &C, StorageType Storage,\n                    ArrayRef<Metadata *> Ops)\n      : DINode(C, DIGenericSubrangeKind, Storage,\n               dwarf::DW_TAG_generic_subrange, Ops) {}\n\n  ~DIGenericSubrange() = default;\n\n  static DIGenericSubrange *getImpl(LLVMContext &Context, Metadata *CountNode,\n                                    Metadata *LowerBound, Metadata *UpperBound,\n                                    Metadata *Stride, StorageType Storage,\n                                    bool ShouldCreate = true);\n\n  TempDIGenericSubrange cloneImpl() const {\n    return getTemporary(getContext(), getRawCountNode(), getRawLowerBound(),\n                        getRawUpperBound(), getRawStride());\n  }\n\npublic:\n  DEFINE_MDNODE_GET(DIGenericSubrange,\n                    (Metadata * CountNode, Metadata *LowerBound,\n                     Metadata *UpperBound, Metadata *Stride),\n                    (CountNode, LowerBound, UpperBound, Stride))\n\n  TempDIGenericSubrange clone() const { return cloneImpl(); }\n\n  Metadata *getRawCountNode() const { return getOperand(0).get(); }\n  Metadata *getRawLowerBound() const { return getOperand(1).get(); }\n  Metadata *getRawUpperBound() const { return getOperand(2).get(); }\n  Metadata *getRawStride() const { return getOperand(3).get(); }\n\n  using BoundType = PointerUnion<DIVariable *, DIExpression *>;\n\n  BoundType getCount() const;\n  BoundType getLowerBound() const;\n  BoundType getUpperBound() const;\n  BoundType getStride() const;\n\n  static bool classof(const Metadata *MD) {\n    return MD->getMetadataID() == DIGenericSubrangeKind;\n  }\n};\n\n/// Enumeration value.\n///\n/// TODO: Add a pointer to the context (DW_TAG_enumeration_type) once that no\n/// longer creates a type cycle.\nclass DIEnumerator : public DINode {\n  friend class LLVMContextImpl;\n  friend class MDNode;\n\n  APInt Value;\n  DIEnumerator(LLVMContext &C, StorageType Storage, const APInt &Value,\n               bool IsUnsigned, ArrayRef<Metadata *> Ops)\n      : DINode(C, DIEnumeratorKind, Storage, dwarf::DW_TAG_enumerator, Ops),\n        Value(Value) {\n    SubclassData32 = IsUnsigned;\n  }\n  DIEnumerator(LLVMContext &C, StorageType Storage, int64_t Value,\n               bool IsUnsigned, ArrayRef<Metadata *> Ops)\n      : DIEnumerator(C, Storage, APInt(64, Value, !IsUnsigned), IsUnsigned,\n                     Ops) {}\n  ~DIEnumerator() = default;\n\n  static DIEnumerator *getImpl(LLVMContext &Context, const APInt &Value,\n                               bool IsUnsigned, StringRef Name,\n                               StorageType Storage, bool ShouldCreate = true) {\n    return getImpl(Context, Value, IsUnsigned,\n                   getCanonicalMDString(Context, Name), Storage, ShouldCreate);\n  }\n  static DIEnumerator *getImpl(LLVMContext &Context, const APInt &Value,\n                               bool IsUnsigned, MDString *Name,\n                               StorageType Storage, bool ShouldCreate = true);\n\n  TempDIEnumerator cloneImpl() const {\n    return getTemporary(getContext(), getValue(), isUnsigned(), getName());\n  }\n\npublic:\n  DEFINE_MDNODE_GET(DIEnumerator,\n                    (int64_t Value, bool IsUnsigned, StringRef Name),\n                    (APInt(64, Value, !IsUnsigned), IsUnsigned, Name))\n  DEFINE_MDNODE_GET(DIEnumerator,\n                    (int64_t Value, bool IsUnsigned, MDString *Name),\n                    (APInt(64, Value, !IsUnsigned), IsUnsigned, Name))\n  DEFINE_MDNODE_GET(DIEnumerator,\n                    (APInt Value, bool IsUnsigned, StringRef Name),\n                    (Value, IsUnsigned, Name))\n  DEFINE_MDNODE_GET(DIEnumerator,\n                    (APInt Value, bool IsUnsigned, MDString *Name),\n                    (Value, IsUnsigned, Name))\n\n  TempDIEnumerator clone() const { return cloneImpl(); }\n\n  const APInt &getValue() const { return Value; }\n  bool isUnsigned() const { return SubclassData32; }\n  StringRef getName() const { return getStringOperand(0); }\n\n  MDString *getRawName() const { return getOperandAs<MDString>(0); }\n\n  static bool classof(const Metadata *MD) {\n    return MD->getMetadataID() == DIEnumeratorKind;\n  }\n};\n\n/// Base class for scope-like contexts.\n///\n/// Base class for lexical scopes and types (which are also declaration\n/// contexts).\n///\n/// TODO: Separate the concepts of declaration contexts and lexical scopes.\nclass DIScope : public DINode {\nprotected:\n  DIScope(LLVMContext &C, unsigned ID, StorageType Storage, unsigned Tag,\n          ArrayRef<Metadata *> Ops)\n      : DINode(C, ID, Storage, Tag, Ops) {}\n  ~DIScope() = default;\n\npublic:\n  DIFile *getFile() const { return cast_or_null<DIFile>(getRawFile()); }\n\n  inline StringRef getFilename() const;\n  inline StringRef getDirectory() const;\n  inline Optional<StringRef> getSource() const;\n\n  StringRef getName() const;\n  DIScope *getScope() const;\n\n  /// Return the raw underlying file.\n  ///\n  /// A \\a DIFile is a \\a DIScope, but it doesn't point at a separate file (it\n  /// \\em is the file).  If \\c this is an \\a DIFile, we need to return \\c this.\n  /// Otherwise, return the first operand, which is where all other subclasses\n  /// store their file pointer.\n  Metadata *getRawFile() const {\n    return isa<DIFile>(this) ? const_cast<DIScope *>(this)\n                             : static_cast<Metadata *>(getOperand(0));\n  }\n\n  static bool classof(const Metadata *MD) {\n    switch (MD->getMetadataID()) {\n    default:\n      return false;\n    case DIBasicTypeKind:\n    case DIStringTypeKind:\n    case DIDerivedTypeKind:\n    case DICompositeTypeKind:\n    case DISubroutineTypeKind:\n    case DIFileKind:\n    case DICompileUnitKind:\n    case DISubprogramKind:\n    case DILexicalBlockKind:\n    case DILexicalBlockFileKind:\n    case DINamespaceKind:\n    case DICommonBlockKind:\n    case DIModuleKind:\n      return true;\n    }\n  }\n};\n\n/// File.\n///\n/// TODO: Merge with directory/file node (including users).\n/// TODO: Canonicalize paths on creation.\nclass DIFile : public DIScope {\n  friend class LLVMContextImpl;\n  friend class MDNode;\n\npublic:\n  /// Which algorithm (e.g. MD5) a checksum was generated with.\n  ///\n  /// The encoding is explicit because it is used directly in Bitcode. The\n  /// value 0 is reserved to indicate the absence of a checksum in Bitcode.\n  enum ChecksumKind {\n    // The first variant was originally CSK_None, encoded as 0. The new\n    // internal representation removes the need for this by wrapping the\n    // ChecksumInfo in an Optional, but to preserve Bitcode compatibility the 0\n    // encoding is reserved.\n    CSK_MD5 = 1,\n    CSK_SHA1 = 2,\n    CSK_SHA256 = 3,\n    CSK_Last = CSK_SHA256 // Should be last enumeration.\n  };\n\n  /// A single checksum, represented by a \\a Kind and a \\a Value (a string).\n  template <typename T>\n  struct ChecksumInfo {\n    /// The kind of checksum which \\a Value encodes.\n    ChecksumKind Kind;\n    /// The string value of the checksum.\n    T Value;\n\n    ChecksumInfo(ChecksumKind Kind, T Value) : Kind(Kind), Value(Value) { }\n    ~ChecksumInfo() = default;\n    bool operator==(const ChecksumInfo<T> &X) const {\n      return Kind == X.Kind && Value == X.Value;\n    }\n    bool operator!=(const ChecksumInfo<T> &X) const { return !(*this == X); }\n    StringRef getKindAsString() const { return getChecksumKindAsString(Kind); }\n  };\n\nprivate:\n  Optional<ChecksumInfo<MDString *>> Checksum;\n  Optional<MDString *> Source;\n\n  DIFile(LLVMContext &C, StorageType Storage,\n         Optional<ChecksumInfo<MDString *>> CS, Optional<MDString *> Src,\n         ArrayRef<Metadata *> Ops)\n      : DIScope(C, DIFileKind, Storage, dwarf::DW_TAG_file_type, Ops),\n        Checksum(CS), Source(Src) {}\n  ~DIFile() = default;\n\n  static DIFile *getImpl(LLVMContext &Context, StringRef Filename,\n                         StringRef Directory,\n                         Optional<ChecksumInfo<StringRef>> CS,\n                         Optional<StringRef> Source,\n                         StorageType Storage, bool ShouldCreate = true) {\n    Optional<ChecksumInfo<MDString *>> MDChecksum;\n    if (CS)\n      MDChecksum.emplace(CS->Kind, getCanonicalMDString(Context, CS->Value));\n    return getImpl(Context, getCanonicalMDString(Context, Filename),\n                   getCanonicalMDString(Context, Directory), MDChecksum,\n                   Source ? Optional<MDString *>(getCanonicalMDString(Context, *Source)) : None,\n                   Storage, ShouldCreate);\n  }\n  static DIFile *getImpl(LLVMContext &Context, MDString *Filename,\n                         MDString *Directory,\n                         Optional<ChecksumInfo<MDString *>> CS,\n                         Optional<MDString *> Source, StorageType Storage,\n                         bool ShouldCreate = true);\n\n  TempDIFile cloneImpl() const {\n    return getTemporary(getContext(), getFilename(), getDirectory(),\n                        getChecksum(), getSource());\n  }\n\npublic:\n  DEFINE_MDNODE_GET(DIFile, (StringRef Filename, StringRef Directory,\n                             Optional<ChecksumInfo<StringRef>> CS = None,\n                             Optional<StringRef> Source = None),\n                    (Filename, Directory, CS, Source))\n  DEFINE_MDNODE_GET(DIFile, (MDString * Filename, MDString *Directory,\n                             Optional<ChecksumInfo<MDString *>> CS = None,\n                             Optional<MDString *> Source = None),\n                    (Filename, Directory, CS, Source))\n\n  TempDIFile clone() const { return cloneImpl(); }\n\n  StringRef getFilename() const { return getStringOperand(0); }\n  StringRef getDirectory() const { return getStringOperand(1); }\n  Optional<ChecksumInfo<StringRef>> getChecksum() const {\n    Optional<ChecksumInfo<StringRef>> StringRefChecksum;\n    if (Checksum)\n      StringRefChecksum.emplace(Checksum->Kind, Checksum->Value->getString());\n    return StringRefChecksum;\n  }\n  Optional<StringRef> getSource() const {\n    return Source ? Optional<StringRef>((*Source)->getString()) : None;\n  }\n\n  MDString *getRawFilename() const { return getOperandAs<MDString>(0); }\n  MDString *getRawDirectory() const { return getOperandAs<MDString>(1); }\n  Optional<ChecksumInfo<MDString *>> getRawChecksum() const { return Checksum; }\n  Optional<MDString *> getRawSource() const { return Source; }\n\n  static StringRef getChecksumKindAsString(ChecksumKind CSKind);\n  static Optional<ChecksumKind> getChecksumKind(StringRef CSKindStr);\n\n  static bool classof(const Metadata *MD) {\n    return MD->getMetadataID() == DIFileKind;\n  }\n};\n\nStringRef DIScope::getFilename() const {\n  if (auto *F = getFile())\n    return F->getFilename();\n  return \"\";\n}\n\nStringRef DIScope::getDirectory() const {\n  if (auto *F = getFile())\n    return F->getDirectory();\n  return \"\";\n}\n\nOptional<StringRef> DIScope::getSource() const {\n  if (auto *F = getFile())\n    return F->getSource();\n  return None;\n}\n\n/// Base class for types.\n///\n/// TODO: Remove the hardcoded name and context, since many types don't use\n/// them.\n/// TODO: Split up flags.\nclass DIType : public DIScope {\n  unsigned Line;\n  DIFlags Flags;\n  uint64_t SizeInBits;\n  uint64_t OffsetInBits;\n  uint32_t AlignInBits;\n\nprotected:\n  DIType(LLVMContext &C, unsigned ID, StorageType Storage, unsigned Tag,\n         unsigned Line, uint64_t SizeInBits, uint32_t AlignInBits,\n         uint64_t OffsetInBits, DIFlags Flags, ArrayRef<Metadata *> Ops)\n      : DIScope(C, ID, Storage, Tag, Ops) {\n    init(Line, SizeInBits, AlignInBits, OffsetInBits, Flags);\n  }\n  ~DIType() = default;\n\n  void init(unsigned Line, uint64_t SizeInBits, uint32_t AlignInBits,\n            uint64_t OffsetInBits, DIFlags Flags) {\n    this->Line = Line;\n    this->Flags = Flags;\n    this->SizeInBits = SizeInBits;\n    this->AlignInBits = AlignInBits;\n    this->OffsetInBits = OffsetInBits;\n  }\n\n  /// Change fields in place.\n  void mutate(unsigned Tag, unsigned Line, uint64_t SizeInBits,\n              uint32_t AlignInBits, uint64_t OffsetInBits, DIFlags Flags) {\n    assert(isDistinct() && \"Only distinct nodes can mutate\");\n    setTag(Tag);\n    init(Line, SizeInBits, AlignInBits, OffsetInBits, Flags);\n  }\n\npublic:\n  TempDIType clone() const {\n    return TempDIType(cast<DIType>(MDNode::clone().release()));\n  }\n\n  unsigned getLine() const { return Line; }\n  uint64_t getSizeInBits() const { return SizeInBits; }\n  uint32_t getAlignInBits() const { return AlignInBits; }\n  uint32_t getAlignInBytes() const { return getAlignInBits() / CHAR_BIT; }\n  uint64_t getOffsetInBits() const { return OffsetInBits; }\n  DIFlags getFlags() const { return Flags; }\n\n  DIScope *getScope() const { return cast_or_null<DIScope>(getRawScope()); }\n  StringRef getName() const { return getStringOperand(2); }\n\n\n  Metadata *getRawScope() const { return getOperand(1); }\n  MDString *getRawName() const { return getOperandAs<MDString>(2); }\n\n  /// Returns a new temporary DIType with updated Flags\n  TempDIType cloneWithFlags(DIFlags NewFlags) const {\n    auto NewTy = clone();\n    NewTy->Flags = NewFlags;\n    return NewTy;\n  }\n\n  bool isPrivate() const {\n    return (getFlags() & FlagAccessibility) == FlagPrivate;\n  }\n  bool isProtected() const {\n    return (getFlags() & FlagAccessibility) == FlagProtected;\n  }\n  bool isPublic() const {\n    return (getFlags() & FlagAccessibility) == FlagPublic;\n  }\n  bool isForwardDecl() const { return getFlags() & FlagFwdDecl; }\n  bool isAppleBlockExtension() const { return getFlags() & FlagAppleBlock; }\n  bool isVirtual() const { return getFlags() & FlagVirtual; }\n  bool isArtificial() const { return getFlags() & FlagArtificial; }\n  bool isObjectPointer() const { return getFlags() & FlagObjectPointer; }\n  bool isObjcClassComplete() const {\n    return getFlags() & FlagObjcClassComplete;\n  }\n  bool isVector() const { return getFlags() & FlagVector; }\n  bool isBitField() const { return getFlags() & FlagBitField; }\n  bool isStaticMember() const { return getFlags() & FlagStaticMember; }\n  bool isLValueReference() const { return getFlags() & FlagLValueReference; }\n  bool isRValueReference() const { return getFlags() & FlagRValueReference; }\n  bool isTypePassByValue() const { return getFlags() & FlagTypePassByValue; }\n  bool isTypePassByReference() const {\n    return getFlags() & FlagTypePassByReference;\n  }\n  bool isBigEndian() const { return getFlags() & FlagBigEndian; }\n  bool isLittleEndian() const { return getFlags() & FlagLittleEndian; }\n  bool getExportSymbols() const { return getFlags() & FlagExportSymbols; }\n\n  static bool classof(const Metadata *MD) {\n    switch (MD->getMetadataID()) {\n    default:\n      return false;\n    case DIBasicTypeKind:\n    case DIStringTypeKind:\n    case DIDerivedTypeKind:\n    case DICompositeTypeKind:\n    case DISubroutineTypeKind:\n      return true;\n    }\n  }\n};\n\n/// Basic type, like 'int' or 'float'.\n///\n/// TODO: Split out DW_TAG_unspecified_type.\n/// TODO: Drop unused accessors.\nclass DIBasicType : public DIType {\n  friend class LLVMContextImpl;\n  friend class MDNode;\n\n  unsigned Encoding;\n\n  DIBasicType(LLVMContext &C, StorageType Storage, unsigned Tag,\n              uint64_t SizeInBits, uint32_t AlignInBits, unsigned Encoding,\n              DIFlags Flags, ArrayRef<Metadata *> Ops)\n      : DIType(C, DIBasicTypeKind, Storage, Tag, 0, SizeInBits, AlignInBits, 0,\n               Flags, Ops),\n        Encoding(Encoding) {}\n  ~DIBasicType() = default;\n\n  static DIBasicType *getImpl(LLVMContext &Context, unsigned Tag,\n                              StringRef Name, uint64_t SizeInBits,\n                              uint32_t AlignInBits, unsigned Encoding,\n                              DIFlags Flags, StorageType Storage,\n                              bool ShouldCreate = true) {\n    return getImpl(Context, Tag, getCanonicalMDString(Context, Name),\n                   SizeInBits, AlignInBits, Encoding, Flags, Storage,\n                   ShouldCreate);\n  }\n  static DIBasicType *getImpl(LLVMContext &Context, unsigned Tag,\n                              MDString *Name, uint64_t SizeInBits,\n                              uint32_t AlignInBits, unsigned Encoding,\n                              DIFlags Flags, StorageType Storage,\n                              bool ShouldCreate = true);\n\n  TempDIBasicType cloneImpl() const {\n    return getTemporary(getContext(), getTag(), getName(), getSizeInBits(),\n                        getAlignInBits(), getEncoding(), getFlags());\n  }\n\npublic:\n  DEFINE_MDNODE_GET(DIBasicType, (unsigned Tag, StringRef Name),\n                    (Tag, Name, 0, 0, 0, FlagZero))\n  DEFINE_MDNODE_GET(DIBasicType,\n                    (unsigned Tag, StringRef Name, uint64_t SizeInBits),\n                    (Tag, Name, SizeInBits, 0, 0, FlagZero))\n  DEFINE_MDNODE_GET(DIBasicType,\n                    (unsigned Tag, MDString *Name, uint64_t SizeInBits),\n                    (Tag, Name, SizeInBits, 0, 0, FlagZero))\n  DEFINE_MDNODE_GET(DIBasicType,\n                    (unsigned Tag, StringRef Name, uint64_t SizeInBits,\n                     uint32_t AlignInBits, unsigned Encoding, DIFlags Flags),\n                    (Tag, Name, SizeInBits, AlignInBits, Encoding, Flags))\n  DEFINE_MDNODE_GET(DIBasicType,\n                    (unsigned Tag, MDString *Name, uint64_t SizeInBits,\n                     uint32_t AlignInBits, unsigned Encoding, DIFlags Flags),\n                    (Tag, Name, SizeInBits, AlignInBits, Encoding, Flags))\n\n  TempDIBasicType clone() const { return cloneImpl(); }\n\n  unsigned getEncoding() const { return Encoding; }\n\n  enum class Signedness { Signed, Unsigned };\n\n  /// Return the signedness of this type, or None if this type is neither\n  /// signed nor unsigned.\n  Optional<Signedness> getSignedness() const;\n\n  static bool classof(const Metadata *MD) {\n    return MD->getMetadataID() == DIBasicTypeKind;\n  }\n};\n\n/// String type, Fortran CHARACTER(n)\nclass DIStringType : public DIType {\n  friend class LLVMContextImpl;\n  friend class MDNode;\n\n  unsigned Encoding;\n\n  DIStringType(LLVMContext &C, StorageType Storage, unsigned Tag,\n               uint64_t SizeInBits, uint32_t AlignInBits, unsigned Encoding,\n               ArrayRef<Metadata *> Ops)\n      : DIType(C, DIStringTypeKind, Storage, Tag, 0, SizeInBits, AlignInBits, 0,\n               FlagZero, Ops),\n        Encoding(Encoding) {}\n  ~DIStringType() = default;\n\n  static DIStringType *getImpl(LLVMContext &Context, unsigned Tag,\n                               StringRef Name, Metadata *StringLength,\n                               Metadata *StrLenExp, uint64_t SizeInBits,\n                               uint32_t AlignInBits, unsigned Encoding,\n                               StorageType Storage, bool ShouldCreate = true) {\n    return getImpl(Context, Tag, getCanonicalMDString(Context, Name),\n                   StringLength, StrLenExp, SizeInBits, AlignInBits, Encoding,\n                   Storage, ShouldCreate);\n  }\n  static DIStringType *getImpl(LLVMContext &Context, unsigned Tag,\n                               MDString *Name, Metadata *StringLength,\n                               Metadata *StrLenExp, uint64_t SizeInBits,\n                               uint32_t AlignInBits, unsigned Encoding,\n                               StorageType Storage, bool ShouldCreate = true);\n\n  TempDIStringType cloneImpl() const {\n    return getTemporary(getContext(), getTag(), getRawName(),\n                        getRawStringLength(), getRawStringLengthExp(),\n                        getSizeInBits(), getAlignInBits(), getEncoding());\n  }\n\npublic:\n  DEFINE_MDNODE_GET(DIStringType,\n                    (unsigned Tag, StringRef Name, uint64_t SizeInBits,\n                     uint32_t AlignInBits),\n                    (Tag, Name, nullptr, nullptr, SizeInBits, AlignInBits, 0))\n  DEFINE_MDNODE_GET(DIStringType,\n                    (unsigned Tag, MDString *Name, Metadata *StringLength,\n                     Metadata *StringLengthExp, uint64_t SizeInBits,\n                     uint32_t AlignInBits, unsigned Encoding),\n                    (Tag, Name, StringLength, StringLengthExp, SizeInBits,\n                     AlignInBits, Encoding))\n  DEFINE_MDNODE_GET(DIStringType,\n                    (unsigned Tag, StringRef Name, Metadata *StringLength,\n                     Metadata *StringLengthExp, uint64_t SizeInBits,\n                     uint32_t AlignInBits, unsigned Encoding),\n                    (Tag, Name, StringLength, StringLengthExp, SizeInBits,\n                     AlignInBits, Encoding))\n\n  TempDIStringType clone() const { return cloneImpl(); }\n\n  static bool classof(const Metadata *MD) {\n    return MD->getMetadataID() == DIStringTypeKind;\n  }\n\n  DIVariable *getStringLength() const {\n    return cast_or_null<DIVariable>(getRawStringLength());\n  }\n\n  DIExpression *getStringLengthExp() const {\n    return cast_or_null<DIExpression>(getRawStringLengthExp());\n  }\n\n  unsigned getEncoding() const { return Encoding; }\n\n  Metadata *getRawStringLength() const { return getOperand(3); }\n\n  Metadata *getRawStringLengthExp() const { return getOperand(4); }\n};\n\n/// Derived types.\n///\n/// This includes qualified types, pointers, references, friends, typedefs, and\n/// class members.\n///\n/// TODO: Split out members (inheritance, fields, methods, etc.).\nclass DIDerivedType : public DIType {\n  friend class LLVMContextImpl;\n  friend class MDNode;\n\n  /// The DWARF address space of the memory pointed to or referenced by a\n  /// pointer or reference type respectively.\n  Optional<unsigned> DWARFAddressSpace;\n\n  DIDerivedType(LLVMContext &C, StorageType Storage, unsigned Tag,\n                unsigned Line, uint64_t SizeInBits, uint32_t AlignInBits,\n                uint64_t OffsetInBits, Optional<unsigned> DWARFAddressSpace,\n                DIFlags Flags, ArrayRef<Metadata *> Ops)\n      : DIType(C, DIDerivedTypeKind, Storage, Tag, Line, SizeInBits,\n               AlignInBits, OffsetInBits, Flags, Ops),\n        DWARFAddressSpace(DWARFAddressSpace) {}\n  ~DIDerivedType() = default;\n\n  static DIDerivedType *\n  getImpl(LLVMContext &Context, unsigned Tag, StringRef Name, DIFile *File,\n          unsigned Line, DIScope *Scope, DIType *BaseType, uint64_t SizeInBits,\n          uint32_t AlignInBits, uint64_t OffsetInBits,\n          Optional<unsigned> DWARFAddressSpace, DIFlags Flags,\n          Metadata *ExtraData, StorageType Storage, bool ShouldCreate = true) {\n    return getImpl(Context, Tag, getCanonicalMDString(Context, Name), File,\n                   Line, Scope, BaseType, SizeInBits, AlignInBits, OffsetInBits,\n                   DWARFAddressSpace, Flags, ExtraData, Storage, ShouldCreate);\n  }\n  static DIDerivedType *getImpl(LLVMContext &Context, unsigned Tag,\n                                MDString *Name, Metadata *File, unsigned Line,\n                                Metadata *Scope, Metadata *BaseType,\n                                uint64_t SizeInBits, uint32_t AlignInBits,\n                                uint64_t OffsetInBits,\n                                Optional<unsigned> DWARFAddressSpace,\n                                DIFlags Flags, Metadata *ExtraData,\n                                StorageType Storage, bool ShouldCreate = true);\n\n  TempDIDerivedType cloneImpl() const {\n    return getTemporary(getContext(), getTag(), getName(), getFile(), getLine(),\n                        getScope(), getBaseType(), getSizeInBits(),\n                        getAlignInBits(), getOffsetInBits(),\n                        getDWARFAddressSpace(), getFlags(), getExtraData());\n  }\n\npublic:\n  DEFINE_MDNODE_GET(DIDerivedType,\n                    (unsigned Tag, MDString *Name, Metadata *File,\n                     unsigned Line, Metadata *Scope, Metadata *BaseType,\n                     uint64_t SizeInBits, uint32_t AlignInBits,\n                     uint64_t OffsetInBits,\n                     Optional<unsigned> DWARFAddressSpace, DIFlags Flags,\n                     Metadata *ExtraData = nullptr),\n                    (Tag, Name, File, Line, Scope, BaseType, SizeInBits,\n                     AlignInBits, OffsetInBits, DWARFAddressSpace, Flags,\n                     ExtraData))\n  DEFINE_MDNODE_GET(DIDerivedType,\n                    (unsigned Tag, StringRef Name, DIFile *File, unsigned Line,\n                     DIScope *Scope, DIType *BaseType, uint64_t SizeInBits,\n                     uint32_t AlignInBits, uint64_t OffsetInBits,\n                     Optional<unsigned> DWARFAddressSpace, DIFlags Flags,\n                     Metadata *ExtraData = nullptr),\n                    (Tag, Name, File, Line, Scope, BaseType, SizeInBits,\n                     AlignInBits, OffsetInBits, DWARFAddressSpace, Flags,\n                     ExtraData))\n\n  TempDIDerivedType clone() const { return cloneImpl(); }\n\n  /// Get the base type this is derived from.\n  DIType *getBaseType() const { return cast_or_null<DIType>(getRawBaseType()); }\n  Metadata *getRawBaseType() const { return getOperand(3); }\n\n  /// \\returns The DWARF address space of the memory pointed to or referenced by\n  /// a pointer or reference type respectively.\n  Optional<unsigned> getDWARFAddressSpace() const { return DWARFAddressSpace; }\n\n  /// Get extra data associated with this derived type.\n  ///\n  /// Class type for pointer-to-members, objective-c property node for ivars,\n  /// global constant wrapper for static members, or virtual base pointer offset\n  /// for inheritance.\n  ///\n  /// TODO: Separate out types that need this extra operand: pointer-to-member\n  /// types and member fields (static members and ivars).\n  Metadata *getExtraData() const { return getRawExtraData(); }\n  Metadata *getRawExtraData() const { return getOperand(4); }\n\n  /// Get casted version of extra data.\n  /// @{\n  DIType *getClassType() const {\n    assert(getTag() == dwarf::DW_TAG_ptr_to_member_type);\n    return cast_or_null<DIType>(getExtraData());\n  }\n\n  DIObjCProperty *getObjCProperty() const {\n    return dyn_cast_or_null<DIObjCProperty>(getExtraData());\n  }\n\n  uint32_t getVBPtrOffset() const {\n    assert(getTag() == dwarf::DW_TAG_inheritance);\n    if (auto *CM = cast_or_null<ConstantAsMetadata>(getExtraData()))\n      if (auto *CI = dyn_cast_or_null<ConstantInt>(CM->getValue()))\n        return static_cast<uint32_t>(CI->getZExtValue());\n    return 0;\n  }\n\n  Constant *getStorageOffsetInBits() const {\n    assert(getTag() == dwarf::DW_TAG_member && isBitField());\n    if (auto *C = cast_or_null<ConstantAsMetadata>(getExtraData()))\n      return C->getValue();\n    return nullptr;\n  }\n\n  Constant *getConstant() const {\n    assert(getTag() == dwarf::DW_TAG_member && isStaticMember());\n    if (auto *C = cast_or_null<ConstantAsMetadata>(getExtraData()))\n      return C->getValue();\n    return nullptr;\n  }\n  Constant *getDiscriminantValue() const {\n    assert(getTag() == dwarf::DW_TAG_member && !isStaticMember());\n    if (auto *C = cast_or_null<ConstantAsMetadata>(getExtraData()))\n      return C->getValue();\n    return nullptr;\n  }\n  /// @}\n\n  static bool classof(const Metadata *MD) {\n    return MD->getMetadataID() == DIDerivedTypeKind;\n  }\n};\n\n/// Composite types.\n///\n/// TODO: Detach from DerivedTypeBase (split out MDEnumType?).\n/// TODO: Create a custom, unrelated node for DW_TAG_array_type.\nclass DICompositeType : public DIType {\n  friend class LLVMContextImpl;\n  friend class MDNode;\n\n  unsigned RuntimeLang;\n\n  DICompositeType(LLVMContext &C, StorageType Storage, unsigned Tag,\n                  unsigned Line, unsigned RuntimeLang, uint64_t SizeInBits,\n                  uint32_t AlignInBits, uint64_t OffsetInBits, DIFlags Flags,\n                  ArrayRef<Metadata *> Ops)\n      : DIType(C, DICompositeTypeKind, Storage, Tag, Line, SizeInBits,\n               AlignInBits, OffsetInBits, Flags, Ops),\n        RuntimeLang(RuntimeLang) {}\n  ~DICompositeType() = default;\n\n  /// Change fields in place.\n  void mutate(unsigned Tag, unsigned Line, unsigned RuntimeLang,\n              uint64_t SizeInBits, uint32_t AlignInBits,\n              uint64_t OffsetInBits, DIFlags Flags) {\n    assert(isDistinct() && \"Only distinct nodes can mutate\");\n    assert(getRawIdentifier() && \"Only ODR-uniqued nodes should mutate\");\n    this->RuntimeLang = RuntimeLang;\n    DIType::mutate(Tag, Line, SizeInBits, AlignInBits, OffsetInBits, Flags);\n  }\n\n  static DICompositeType *\n  getImpl(LLVMContext &Context, unsigned Tag, StringRef Name, Metadata *File,\n          unsigned Line, DIScope *Scope, DIType *BaseType, uint64_t SizeInBits,\n          uint32_t AlignInBits, uint64_t OffsetInBits, DIFlags Flags,\n          DINodeArray Elements, unsigned RuntimeLang, DIType *VTableHolder,\n          DITemplateParameterArray TemplateParams, StringRef Identifier,\n          DIDerivedType *Discriminator, Metadata *DataLocation,\n          Metadata *Associated, Metadata *Allocated, Metadata *Rank,\n          StorageType Storage, bool ShouldCreate = true) {\n    return getImpl(\n        Context, Tag, getCanonicalMDString(Context, Name), File, Line, Scope,\n        BaseType, SizeInBits, AlignInBits, OffsetInBits, Flags, Elements.get(),\n        RuntimeLang, VTableHolder, TemplateParams.get(),\n        getCanonicalMDString(Context, Identifier), Discriminator, DataLocation,\n        Associated, Allocated, Rank, Storage, ShouldCreate);\n  }\n  static DICompositeType *\n  getImpl(LLVMContext &Context, unsigned Tag, MDString *Name, Metadata *File,\n          unsigned Line, Metadata *Scope, Metadata *BaseType,\n          uint64_t SizeInBits, uint32_t AlignInBits, uint64_t OffsetInBits,\n          DIFlags Flags, Metadata *Elements, unsigned RuntimeLang,\n          Metadata *VTableHolder, Metadata *TemplateParams,\n          MDString *Identifier, Metadata *Discriminator, Metadata *DataLocation,\n          Metadata *Associated, Metadata *Allocated, Metadata *Rank,\n          StorageType Storage, bool ShouldCreate = true);\n\n  TempDICompositeType cloneImpl() const {\n    return getTemporary(getContext(), getTag(), getName(), getFile(), getLine(),\n                        getScope(), getBaseType(), getSizeInBits(),\n                        getAlignInBits(), getOffsetInBits(), getFlags(),\n                        getElements(), getRuntimeLang(), getVTableHolder(),\n                        getTemplateParams(), getIdentifier(),\n                        getDiscriminator(), getRawDataLocation(),\n                        getRawAssociated(), getRawAllocated(), getRawRank());\n  }\n\npublic:\n  DEFINE_MDNODE_GET(\n      DICompositeType,\n      (unsigned Tag, StringRef Name, DIFile *File, unsigned Line,\n       DIScope *Scope, DIType *BaseType, uint64_t SizeInBits,\n       uint32_t AlignInBits, uint64_t OffsetInBits, DIFlags Flags,\n       DINodeArray Elements, unsigned RuntimeLang, DIType *VTableHolder,\n       DITemplateParameterArray TemplateParams = nullptr,\n       StringRef Identifier = \"\", DIDerivedType *Discriminator = nullptr,\n       Metadata *DataLocation = nullptr, Metadata *Associated = nullptr,\n       Metadata *Allocated = nullptr, Metadata *Rank = nullptr),\n      (Tag, Name, File, Line, Scope, BaseType, SizeInBits, AlignInBits,\n       OffsetInBits, Flags, Elements, RuntimeLang, VTableHolder, TemplateParams,\n       Identifier, Discriminator, DataLocation, Associated, Allocated, Rank))\n  DEFINE_MDNODE_GET(\n      DICompositeType,\n      (unsigned Tag, MDString *Name, Metadata *File, unsigned Line,\n       Metadata *Scope, Metadata *BaseType, uint64_t SizeInBits,\n       uint32_t AlignInBits, uint64_t OffsetInBits, DIFlags Flags,\n       Metadata *Elements, unsigned RuntimeLang, Metadata *VTableHolder,\n       Metadata *TemplateParams = nullptr, MDString *Identifier = nullptr,\n       Metadata *Discriminator = nullptr, Metadata *DataLocation = nullptr,\n       Metadata *Associated = nullptr, Metadata *Allocated = nullptr,\n       Metadata *Rank = nullptr),\n      (Tag, Name, File, Line, Scope, BaseType, SizeInBits, AlignInBits,\n       OffsetInBits, Flags, Elements, RuntimeLang, VTableHolder, TemplateParams,\n       Identifier, Discriminator, DataLocation, Associated, Allocated, Rank))\n\n  TempDICompositeType clone() const { return cloneImpl(); }\n\n  /// Get a DICompositeType with the given ODR identifier.\n  ///\n  /// If \\a LLVMContext::isODRUniquingDebugTypes(), gets the mapped\n  /// DICompositeType for the given ODR \\c Identifier.  If none exists, creates\n  /// a new node.\n  ///\n  /// Else, returns \\c nullptr.\n  static DICompositeType *\n  getODRType(LLVMContext &Context, MDString &Identifier, unsigned Tag,\n             MDString *Name, Metadata *File, unsigned Line, Metadata *Scope,\n             Metadata *BaseType, uint64_t SizeInBits, uint32_t AlignInBits,\n             uint64_t OffsetInBits, DIFlags Flags, Metadata *Elements,\n             unsigned RuntimeLang, Metadata *VTableHolder,\n             Metadata *TemplateParams, Metadata *Discriminator,\n             Metadata *DataLocation, Metadata *Associated, Metadata *Allocated,\n             Metadata *Rank);\n  static DICompositeType *getODRTypeIfExists(LLVMContext &Context,\n                                             MDString &Identifier);\n\n  /// Build a DICompositeType with the given ODR identifier.\n  ///\n  /// Looks up the mapped DICompositeType for the given ODR \\c Identifier.  If\n  /// it doesn't exist, creates a new one.  If it does exist and \\a\n  /// isForwardDecl(), and the new arguments would be a definition, mutates the\n  /// the type in place.  In either case, returns the type.\n  ///\n  /// If not \\a LLVMContext::isODRUniquingDebugTypes(), this function returns\n  /// nullptr.\n  static DICompositeType *\n  buildODRType(LLVMContext &Context, MDString &Identifier, unsigned Tag,\n               MDString *Name, Metadata *File, unsigned Line, Metadata *Scope,\n               Metadata *BaseType, uint64_t SizeInBits, uint32_t AlignInBits,\n               uint64_t OffsetInBits, DIFlags Flags, Metadata *Elements,\n               unsigned RuntimeLang, Metadata *VTableHolder,\n               Metadata *TemplateParams, Metadata *Discriminator,\n               Metadata *DataLocation, Metadata *Associated,\n               Metadata *Allocated, Metadata *Rank);\n\n  DIType *getBaseType() const { return cast_or_null<DIType>(getRawBaseType()); }\n  DINodeArray getElements() const {\n    return cast_or_null<MDTuple>(getRawElements());\n  }\n  DIType *getVTableHolder() const {\n    return cast_or_null<DIType>(getRawVTableHolder());\n  }\n  DITemplateParameterArray getTemplateParams() const {\n    return cast_or_null<MDTuple>(getRawTemplateParams());\n  }\n  StringRef getIdentifier() const { return getStringOperand(7); }\n  unsigned getRuntimeLang() const { return RuntimeLang; }\n\n  Metadata *getRawBaseType() const { return getOperand(3); }\n  Metadata *getRawElements() const { return getOperand(4); }\n  Metadata *getRawVTableHolder() const { return getOperand(5); }\n  Metadata *getRawTemplateParams() const { return getOperand(6); }\n  MDString *getRawIdentifier() const { return getOperandAs<MDString>(7); }\n  Metadata *getRawDiscriminator() const { return getOperand(8); }\n  DIDerivedType *getDiscriminator() const { return getOperandAs<DIDerivedType>(8); }\n  Metadata *getRawDataLocation() const { return getOperand(9); }\n  DIVariable *getDataLocation() const {\n    return dyn_cast_or_null<DIVariable>(getRawDataLocation());\n  }\n  DIExpression *getDataLocationExp() const {\n    return dyn_cast_or_null<DIExpression>(getRawDataLocation());\n  }\n  Metadata *getRawAssociated() const { return getOperand(10); }\n  DIVariable *getAssociated() const {\n    return dyn_cast_or_null<DIVariable>(getRawAssociated());\n  }\n  DIExpression *getAssociatedExp() const {\n    return dyn_cast_or_null<DIExpression>(getRawAssociated());\n  }\n  Metadata *getRawAllocated() const { return getOperand(11); }\n  DIVariable *getAllocated() const {\n    return dyn_cast_or_null<DIVariable>(getRawAllocated());\n  }\n  DIExpression *getAllocatedExp() const {\n    return dyn_cast_or_null<DIExpression>(getRawAllocated());\n  }\n  Metadata *getRawRank() const { return getOperand(12); }\n  ConstantInt *getRankConst() const {\n    if (auto *MD = dyn_cast_or_null<ConstantAsMetadata>(getRawRank()))\n      return dyn_cast_or_null<ConstantInt>(MD->getValue());\n    return nullptr;\n  }\n  DIExpression *getRankExp() const {\n    return dyn_cast_or_null<DIExpression>(getRawRank());\n  }\n\n  /// Replace operands.\n  ///\n  /// If this \\a isUniqued() and not \\a isResolved(), on a uniquing collision\n  /// this will be RAUW'ed and deleted.  Use a \\a TrackingMDRef to keep track\n  /// of its movement if necessary.\n  /// @{\n  void replaceElements(DINodeArray Elements) {\n#ifndef NDEBUG\n    for (DINode *Op : getElements())\n      assert(is_contained(Elements->operands(), Op) &&\n             \"Lost a member during member list replacement\");\n#endif\n    replaceOperandWith(4, Elements.get());\n  }\n\n  void replaceVTableHolder(DIType *VTableHolder) {\n    replaceOperandWith(5, VTableHolder);\n  }\n\n  void replaceTemplateParams(DITemplateParameterArray TemplateParams) {\n    replaceOperandWith(6, TemplateParams.get());\n  }\n  /// @}\n\n  static bool classof(const Metadata *MD) {\n    return MD->getMetadataID() == DICompositeTypeKind;\n  }\n};\n\n/// Type array for a subprogram.\n///\n/// TODO: Fold the array of types in directly as operands.\nclass DISubroutineType : public DIType {\n  friend class LLVMContextImpl;\n  friend class MDNode;\n\n  /// The calling convention used with DW_AT_calling_convention. Actually of\n  /// type dwarf::CallingConvention.\n  uint8_t CC;\n\n  DISubroutineType(LLVMContext &C, StorageType Storage, DIFlags Flags,\n                   uint8_t CC, ArrayRef<Metadata *> Ops)\n      : DIType(C, DISubroutineTypeKind, Storage, dwarf::DW_TAG_subroutine_type,\n               0, 0, 0, 0, Flags, Ops),\n        CC(CC) {}\n  ~DISubroutineType() = default;\n\n  static DISubroutineType *getImpl(LLVMContext &Context, DIFlags Flags,\n                                   uint8_t CC, DITypeRefArray TypeArray,\n                                   StorageType Storage,\n                                   bool ShouldCreate = true) {\n    return getImpl(Context, Flags, CC, TypeArray.get(), Storage, ShouldCreate);\n  }\n  static DISubroutineType *getImpl(LLVMContext &Context, DIFlags Flags,\n                                   uint8_t CC, Metadata *TypeArray,\n                                   StorageType Storage,\n                                   bool ShouldCreate = true);\n\n  TempDISubroutineType cloneImpl() const {\n    return getTemporary(getContext(), getFlags(), getCC(), getTypeArray());\n  }\n\npublic:\n  DEFINE_MDNODE_GET(DISubroutineType,\n                    (DIFlags Flags, uint8_t CC, DITypeRefArray TypeArray),\n                    (Flags, CC, TypeArray))\n  DEFINE_MDNODE_GET(DISubroutineType,\n                    (DIFlags Flags, uint8_t CC, Metadata *TypeArray),\n                    (Flags, CC, TypeArray))\n\n  TempDISubroutineType clone() const { return cloneImpl(); }\n\n  uint8_t getCC() const { return CC; }\n\n  DITypeRefArray getTypeArray() const {\n    return cast_or_null<MDTuple>(getRawTypeArray());\n  }\n\n  Metadata *getRawTypeArray() const { return getOperand(3); }\n\n  static bool classof(const Metadata *MD) {\n    return MD->getMetadataID() == DISubroutineTypeKind;\n  }\n};\n\n/// Compile unit.\nclass DICompileUnit : public DIScope {\n  friend class LLVMContextImpl;\n  friend class MDNode;\n\npublic:\n  enum DebugEmissionKind : unsigned {\n    NoDebug = 0,\n    FullDebug,\n    LineTablesOnly,\n    DebugDirectivesOnly,\n    LastEmissionKind = DebugDirectivesOnly\n  };\n\n  enum class DebugNameTableKind : unsigned {\n    Default = 0,\n    GNU = 1,\n    None = 2,\n    LastDebugNameTableKind = None\n  };\n\n  static Optional<DebugEmissionKind> getEmissionKind(StringRef Str);\n  static const char *emissionKindString(DebugEmissionKind EK);\n  static Optional<DebugNameTableKind> getNameTableKind(StringRef Str);\n  static const char *nameTableKindString(DebugNameTableKind PK);\n\nprivate:\n  unsigned SourceLanguage;\n  bool IsOptimized;\n  unsigned RuntimeVersion;\n  unsigned EmissionKind;\n  uint64_t DWOId;\n  bool SplitDebugInlining;\n  bool DebugInfoForProfiling;\n  unsigned NameTableKind;\n  bool RangesBaseAddress;\n\n  DICompileUnit(LLVMContext &C, StorageType Storage, unsigned SourceLanguage,\n                bool IsOptimized, unsigned RuntimeVersion,\n                unsigned EmissionKind, uint64_t DWOId, bool SplitDebugInlining,\n                bool DebugInfoForProfiling, unsigned NameTableKind,\n                bool RangesBaseAddress, ArrayRef<Metadata *> Ops)\n      : DIScope(C, DICompileUnitKind, Storage, dwarf::DW_TAG_compile_unit, Ops),\n        SourceLanguage(SourceLanguage), IsOptimized(IsOptimized),\n        RuntimeVersion(RuntimeVersion), EmissionKind(EmissionKind),\n        DWOId(DWOId), SplitDebugInlining(SplitDebugInlining),\n        DebugInfoForProfiling(DebugInfoForProfiling),\n        NameTableKind(NameTableKind), RangesBaseAddress(RangesBaseAddress) {\n    assert(Storage != Uniqued);\n  }\n  ~DICompileUnit() = default;\n\n  static DICompileUnit *\n  getImpl(LLVMContext &Context, unsigned SourceLanguage, DIFile *File,\n          StringRef Producer, bool IsOptimized, StringRef Flags,\n          unsigned RuntimeVersion, StringRef SplitDebugFilename,\n          unsigned EmissionKind, DICompositeTypeArray EnumTypes,\n          DIScopeArray RetainedTypes,\n          DIGlobalVariableExpressionArray GlobalVariables,\n          DIImportedEntityArray ImportedEntities, DIMacroNodeArray Macros,\n          uint64_t DWOId, bool SplitDebugInlining, bool DebugInfoForProfiling,\n          unsigned NameTableKind, bool RangesBaseAddress, StringRef SysRoot,\n          StringRef SDK, StorageType Storage, bool ShouldCreate = true) {\n    return getImpl(\n        Context, SourceLanguage, File, getCanonicalMDString(Context, Producer),\n        IsOptimized, getCanonicalMDString(Context, Flags), RuntimeVersion,\n        getCanonicalMDString(Context, SplitDebugFilename), EmissionKind,\n        EnumTypes.get(), RetainedTypes.get(), GlobalVariables.get(),\n        ImportedEntities.get(), Macros.get(), DWOId, SplitDebugInlining,\n        DebugInfoForProfiling, NameTableKind, RangesBaseAddress,\n        getCanonicalMDString(Context, SysRoot),\n        getCanonicalMDString(Context, SDK), Storage, ShouldCreate);\n  }\n  static DICompileUnit *\n  getImpl(LLVMContext &Context, unsigned SourceLanguage, Metadata *File,\n          MDString *Producer, bool IsOptimized, MDString *Flags,\n          unsigned RuntimeVersion, MDString *SplitDebugFilename,\n          unsigned EmissionKind, Metadata *EnumTypes, Metadata *RetainedTypes,\n          Metadata *GlobalVariables, Metadata *ImportedEntities,\n          Metadata *Macros, uint64_t DWOId, bool SplitDebugInlining,\n          bool DebugInfoForProfiling, unsigned NameTableKind,\n          bool RangesBaseAddress, MDString *SysRoot, MDString *SDK,\n          StorageType Storage, bool ShouldCreate = true);\n\n  TempDICompileUnit cloneImpl() const {\n    return getTemporary(\n        getContext(), getSourceLanguage(), getFile(), getProducer(),\n        isOptimized(), getFlags(), getRuntimeVersion(), getSplitDebugFilename(),\n        getEmissionKind(), getEnumTypes(), getRetainedTypes(),\n        getGlobalVariables(), getImportedEntities(), getMacros(), DWOId,\n        getSplitDebugInlining(), getDebugInfoForProfiling(), getNameTableKind(),\n        getRangesBaseAddress(), getSysRoot(), getSDK());\n  }\n\npublic:\n  static void get() = delete;\n  static void getIfExists() = delete;\n\n  DEFINE_MDNODE_GET_DISTINCT_TEMPORARY(\n      DICompileUnit,\n      (unsigned SourceLanguage, DIFile *File, StringRef Producer,\n       bool IsOptimized, StringRef Flags, unsigned RuntimeVersion,\n       StringRef SplitDebugFilename, DebugEmissionKind EmissionKind,\n       DICompositeTypeArray EnumTypes, DIScopeArray RetainedTypes,\n       DIGlobalVariableExpressionArray GlobalVariables,\n       DIImportedEntityArray ImportedEntities, DIMacroNodeArray Macros,\n       uint64_t DWOId, bool SplitDebugInlining, bool DebugInfoForProfiling,\n       DebugNameTableKind NameTableKind, bool RangesBaseAddress,\n       StringRef SysRoot, StringRef SDK),\n      (SourceLanguage, File, Producer, IsOptimized, Flags, RuntimeVersion,\n       SplitDebugFilename, EmissionKind, EnumTypes, RetainedTypes,\n       GlobalVariables, ImportedEntities, Macros, DWOId, SplitDebugInlining,\n       DebugInfoForProfiling, (unsigned)NameTableKind, RangesBaseAddress,\n       SysRoot, SDK))\n  DEFINE_MDNODE_GET_DISTINCT_TEMPORARY(\n      DICompileUnit,\n      (unsigned SourceLanguage, Metadata *File, MDString *Producer,\n       bool IsOptimized, MDString *Flags, unsigned RuntimeVersion,\n       MDString *SplitDebugFilename, unsigned EmissionKind, Metadata *EnumTypes,\n       Metadata *RetainedTypes, Metadata *GlobalVariables,\n       Metadata *ImportedEntities, Metadata *Macros, uint64_t DWOId,\n       bool SplitDebugInlining, bool DebugInfoForProfiling,\n       unsigned NameTableKind, bool RangesBaseAddress, MDString *SysRoot,\n       MDString *SDK),\n      (SourceLanguage, File, Producer, IsOptimized, Flags, RuntimeVersion,\n       SplitDebugFilename, EmissionKind, EnumTypes, RetainedTypes,\n       GlobalVariables, ImportedEntities, Macros, DWOId, SplitDebugInlining,\n       DebugInfoForProfiling, NameTableKind, RangesBaseAddress, SysRoot, SDK))\n\n  TempDICompileUnit clone() const { return cloneImpl(); }\n\n  unsigned getSourceLanguage() const { return SourceLanguage; }\n  bool isOptimized() const { return IsOptimized; }\n  unsigned getRuntimeVersion() const { return RuntimeVersion; }\n  DebugEmissionKind getEmissionKind() const {\n    return (DebugEmissionKind)EmissionKind;\n  }\n  bool isDebugDirectivesOnly() const {\n    return EmissionKind == DebugDirectivesOnly;\n  }\n  bool getDebugInfoForProfiling() const { return DebugInfoForProfiling; }\n  DebugNameTableKind getNameTableKind() const {\n    return (DebugNameTableKind)NameTableKind;\n  }\n  bool getRangesBaseAddress() const { return RangesBaseAddress; }\n  StringRef getProducer() const { return getStringOperand(1); }\n  StringRef getFlags() const { return getStringOperand(2); }\n  StringRef getSplitDebugFilename() const { return getStringOperand(3); }\n  DICompositeTypeArray getEnumTypes() const {\n    return cast_or_null<MDTuple>(getRawEnumTypes());\n  }\n  DIScopeArray getRetainedTypes() const {\n    return cast_or_null<MDTuple>(getRawRetainedTypes());\n  }\n  DIGlobalVariableExpressionArray getGlobalVariables() const {\n    return cast_or_null<MDTuple>(getRawGlobalVariables());\n  }\n  DIImportedEntityArray getImportedEntities() const {\n    return cast_or_null<MDTuple>(getRawImportedEntities());\n  }\n  DIMacroNodeArray getMacros() const {\n    return cast_or_null<MDTuple>(getRawMacros());\n  }\n  uint64_t getDWOId() const { return DWOId; }\n  void setDWOId(uint64_t DwoId) { DWOId = DwoId; }\n  bool getSplitDebugInlining() const { return SplitDebugInlining; }\n  void setSplitDebugInlining(bool SplitDebugInlining) {\n    this->SplitDebugInlining = SplitDebugInlining;\n  }\n  StringRef getSysRoot() const { return getStringOperand(9); }\n  StringRef getSDK() const { return getStringOperand(10); }\n\n  MDString *getRawProducer() const { return getOperandAs<MDString>(1); }\n  MDString *getRawFlags() const { return getOperandAs<MDString>(2); }\n  MDString *getRawSplitDebugFilename() const {\n    return getOperandAs<MDString>(3);\n  }\n  Metadata *getRawEnumTypes() const { return getOperand(4); }\n  Metadata *getRawRetainedTypes() const { return getOperand(5); }\n  Metadata *getRawGlobalVariables() const { return getOperand(6); }\n  Metadata *getRawImportedEntities() const { return getOperand(7); }\n  Metadata *getRawMacros() const { return getOperand(8); }\n  MDString *getRawSysRoot() const { return getOperandAs<MDString>(9); }\n  MDString *getRawSDK() const { return getOperandAs<MDString>(10); }\n\n  /// Replace arrays.\n  ///\n  /// If this \\a isUniqued() and not \\a isResolved(), it will be RAUW'ed and\n  /// deleted on a uniquing collision.  In practice, uniquing collisions on \\a\n  /// DICompileUnit should be fairly rare.\n  /// @{\n  void replaceEnumTypes(DICompositeTypeArray N) {\n    replaceOperandWith(4, N.get());\n  }\n  void replaceRetainedTypes(DITypeArray N) {\n    replaceOperandWith(5, N.get());\n  }\n  void replaceGlobalVariables(DIGlobalVariableExpressionArray N) {\n    replaceOperandWith(6, N.get());\n  }\n  void replaceImportedEntities(DIImportedEntityArray N) {\n    replaceOperandWith(7, N.get());\n  }\n  void replaceMacros(DIMacroNodeArray N) { replaceOperandWith(8, N.get()); }\n  /// @}\n\n  static bool classof(const Metadata *MD) {\n    return MD->getMetadataID() == DICompileUnitKind;\n  }\n};\n\n/// A scope for locals.\n///\n/// A legal scope for lexical blocks, local variables, and debug info\n/// locations.  Subclasses are \\a DISubprogram, \\a DILexicalBlock, and \\a\n/// DILexicalBlockFile.\nclass DILocalScope : public DIScope {\nprotected:\n  DILocalScope(LLVMContext &C, unsigned ID, StorageType Storage, unsigned Tag,\n               ArrayRef<Metadata *> Ops)\n      : DIScope(C, ID, Storage, Tag, Ops) {}\n  ~DILocalScope() = default;\n\npublic:\n  /// Get the subprogram for this scope.\n  ///\n  /// Return this if it's an \\a DISubprogram; otherwise, look up the scope\n  /// chain.\n  DISubprogram *getSubprogram() const;\n\n  /// Get the first non DILexicalBlockFile scope of this scope.\n  ///\n  /// Return this if it's not a \\a DILexicalBlockFIle; otherwise, look up the\n  /// scope chain.\n  DILocalScope *getNonLexicalBlockFileScope() const;\n\n  static bool classof(const Metadata *MD) {\n    return MD->getMetadataID() == DISubprogramKind ||\n           MD->getMetadataID() == DILexicalBlockKind ||\n           MD->getMetadataID() == DILexicalBlockFileKind;\n  }\n};\n\n/// Debug location.\n///\n/// A debug location in source code, used for debug info and otherwise.\nclass DILocation : public MDNode {\n  friend class LLVMContextImpl;\n  friend class MDNode;\n\n  DILocation(LLVMContext &C, StorageType Storage, unsigned Line,\n             unsigned Column, ArrayRef<Metadata *> MDs, bool ImplicitCode);\n  ~DILocation() { dropAllReferences(); }\n\n  static DILocation *getImpl(LLVMContext &Context, unsigned Line,\n                             unsigned Column, Metadata *Scope,\n                             Metadata *InlinedAt, bool ImplicitCode,\n                             StorageType Storage, bool ShouldCreate = true);\n  static DILocation *getImpl(LLVMContext &Context, unsigned Line,\n                             unsigned Column, DILocalScope *Scope,\n                             DILocation *InlinedAt, bool ImplicitCode,\n                             StorageType Storage, bool ShouldCreate = true) {\n    return getImpl(Context, Line, Column, static_cast<Metadata *>(Scope),\n                   static_cast<Metadata *>(InlinedAt), ImplicitCode, Storage,\n                   ShouldCreate);\n  }\n\n  /// With a given unsigned int \\p U, use up to 13 bits to represent it.\n  /// old_bit 1~5  --> new_bit 1~5\n  /// old_bit 6~12 --> new_bit 7~13\n  /// new_bit_6 is 0 if higher bits (7~13) are all 0\n  static unsigned getPrefixEncodingFromUnsigned(unsigned U) {\n    U &= 0xfff;\n    return U > 0x1f ? (((U & 0xfe0) << 1) | (U & 0x1f) | 0x20) : U;\n  }\n\n  /// Reverse transformation as getPrefixEncodingFromUnsigned.\n  static unsigned getUnsignedFromPrefixEncoding(unsigned U) {\n    if (U & 1)\n      return 0;\n    U >>= 1;\n    return (U & 0x20) ? (((U >> 1) & 0xfe0) | (U & 0x1f)) : (U & 0x1f);\n  }\n\n  /// Returns the next component stored in discriminator.\n  static unsigned getNextComponentInDiscriminator(unsigned D) {\n    if ((D & 1) == 0)\n      return D >> ((D & 0x40) ? 14 : 7);\n    else\n      return D >> 1;\n  }\n\n  TempDILocation cloneImpl() const {\n    // Get the raw scope/inlinedAt since it is possible to invoke this on\n    // a DILocation containing temporary metadata.\n    return getTemporary(getContext(), getLine(), getColumn(), getRawScope(),\n                        getRawInlinedAt(), isImplicitCode());\n  }\n\n  static unsigned encodeComponent(unsigned C) {\n    return (C == 0) ? 1U : (getPrefixEncodingFromUnsigned(C) << 1);\n  }\n\n  static unsigned encodingBits(unsigned C) {\n    return (C == 0) ? 1 : (C > 0x1f ? 14 : 7);\n  }\n\npublic:\n  // Disallow replacing operands.\n  void replaceOperandWith(unsigned I, Metadata *New) = delete;\n\n  DEFINE_MDNODE_GET(DILocation,\n                    (unsigned Line, unsigned Column, Metadata *Scope,\n                     Metadata *InlinedAt = nullptr, bool ImplicitCode = false),\n                    (Line, Column, Scope, InlinedAt, ImplicitCode))\n  DEFINE_MDNODE_GET(DILocation,\n                    (unsigned Line, unsigned Column, DILocalScope *Scope,\n                     DILocation *InlinedAt = nullptr,\n                     bool ImplicitCode = false),\n                    (Line, Column, Scope, InlinedAt, ImplicitCode))\n\n  /// Return a (temporary) clone of this.\n  TempDILocation clone() const { return cloneImpl(); }\n\n  unsigned getLine() const { return SubclassData32; }\n  unsigned getColumn() const { return SubclassData16; }\n  DILocalScope *getScope() const { return cast<DILocalScope>(getRawScope()); }\n\n  DILocation *getInlinedAt() const {\n    return cast_or_null<DILocation>(getRawInlinedAt());\n  }\n\n  /// Check if the location corresponds to an implicit code.\n  /// When the ImplicitCode flag is true, it means that the Instruction\n  /// with this DILocation has been added by the front-end but it hasn't been\n  /// written explicitly by the user (e.g. cleanup stuff in C++ put on a closing\n  /// bracket). It's useful for code coverage to not show a counter on \"empty\"\n  /// lines.\n  bool isImplicitCode() const { return SubclassData1; }\n  void setImplicitCode(bool ImplicitCode) { SubclassData1 = ImplicitCode; }\n\n  DIFile *getFile() const { return getScope()->getFile(); }\n  StringRef getFilename() const { return getScope()->getFilename(); }\n  StringRef getDirectory() const { return getScope()->getDirectory(); }\n  Optional<StringRef> getSource() const { return getScope()->getSource(); }\n\n  /// Get the scope where this is inlined.\n  ///\n  /// Walk through \\a getInlinedAt() and return \\a getScope() from the deepest\n  /// location.\n  DILocalScope *getInlinedAtScope() const {\n    if (auto *IA = getInlinedAt())\n      return IA->getInlinedAtScope();\n    return getScope();\n  }\n\n  /// Get the DWARF discriminator.\n  ///\n  /// DWARF discriminators distinguish identical file locations between\n  /// instructions that are on different basic blocks.\n  ///\n  /// There are 3 components stored in discriminator, from lower bits:\n  ///\n  /// Base discriminator: assigned by AddDiscriminators pass to identify IRs\n  ///                     that are defined by the same source line, but\n  ///                     different basic blocks.\n  /// Duplication factor: assigned by optimizations that will scale down\n  ///                     the execution frequency of the original IR.\n  /// Copy Identifier: assigned by optimizations that clones the IR.\n  ///                  Each copy of the IR will be assigned an identifier.\n  ///\n  /// Encoding:\n  ///\n  /// The above 3 components are encoded into a 32bit unsigned integer in\n  /// order. If the lowest bit is 1, the current component is empty, and the\n  /// next component will start in the next bit. Otherwise, the current\n  /// component is non-empty, and its content starts in the next bit. The\n  /// value of each components is either 5 bit or 12 bit: if the 7th bit\n  /// is 0, the bit 2~6 (5 bits) are used to represent the component; if the\n  /// 7th bit is 1, the bit 2~6 (5 bits) and 8~14 (7 bits) are combined to\n  /// represent the component. Thus, the number of bits used for a component\n  /// is either 0 (if it and all the next components are empty); 1 - if it is\n  /// empty; 7 - if its value is up to and including 0x1f (lsb and msb are both\n  /// 0); or 14, if its value is up to and including 0x1ff. Note that the last\n  /// component is also capped at 0x1ff, even in the case when both first\n  /// components are 0, and we'd technically have 29 bits available.\n  ///\n  /// For precise control over the data being encoded in the discriminator,\n  /// use encodeDiscriminator/decodeDiscriminator.\n\n  inline unsigned getDiscriminator() const;\n\n  // For the regular discriminator, it stands for all empty components if all\n  // the lowest 3 bits are non-zero and all higher 29 bits are unused(zero by\n  // default). Here we fully leverage the higher 29 bits for pseudo probe use.\n  // This is the format:\n  // [2:0] - 0x7\n  // [31:3] - pseudo probe fields guaranteed to be non-zero as a whole\n  // So if the lower 3 bits is non-zero and the others has at least one\n  // non-zero bit, it guarantees to be a pseudo probe discriminator\n  inline static bool isPseudoProbeDiscriminator(unsigned Discriminator) {\n    return ((Discriminator & 0x7) == 0x7) && (Discriminator & 0xFFFFFFF8);\n  }\n\n  /// Returns a new DILocation with updated \\p Discriminator.\n  inline const DILocation *cloneWithDiscriminator(unsigned Discriminator) const;\n\n  /// Returns a new DILocation with updated base discriminator \\p BD. Only the\n  /// base discriminator is set in the new DILocation, the other encoded values\n  /// are elided.\n  /// If the discriminator cannot be encoded, the function returns None.\n  inline Optional<const DILocation *> cloneWithBaseDiscriminator(unsigned BD) const;\n\n  /// Returns the duplication factor stored in the discriminator, or 1 if no\n  /// duplication factor (or 0) is encoded.\n  inline unsigned getDuplicationFactor() const;\n\n  /// Returns the copy identifier stored in the discriminator.\n  inline unsigned getCopyIdentifier() const;\n\n  /// Returns the base discriminator stored in the discriminator.\n  inline unsigned getBaseDiscriminator() const;\n\n  /// Returns a new DILocation with duplication factor \\p DF * current\n  /// duplication factor encoded in the discriminator. The current duplication\n  /// factor is as defined by getDuplicationFactor().\n  /// Returns None if encoding failed.\n  inline Optional<const DILocation *> cloneByMultiplyingDuplicationFactor(unsigned DF) const;\n\n  /// When two instructions are combined into a single instruction we also\n  /// need to combine the original locations into a single location.\n  ///\n  /// When the locations are the same we can use either location. When they\n  /// differ, we need a third location which is distinct from either. If they\n  /// have the same file/line but have a different discriminator we could\n  /// create a location with a new discriminator. If they are from different\n  /// files/lines the location is ambiguous and can't be represented in a line\n  /// entry. In this case, if \\p GenerateLocation is true, we will set the\n  /// merged debug location as line 0 of the nearest common scope where the two\n  /// locations are inlined from.\n  ///\n  /// \\p GenerateLocation: Whether the merged location can be generated when\n  /// \\p LocA and \\p LocB differ.\n  static const DILocation *getMergedLocation(const DILocation *LocA,\n                                             const DILocation *LocB);\n\n  /// Try to combine the vector of locations passed as input in a single one.\n  /// This function applies getMergedLocation() repeatedly left-to-right.\n  ///\n  /// \\p Locs: The locations to be merged.\n  static\n  const DILocation *getMergedLocations(ArrayRef<const DILocation *> Locs);\n\n  /// Returns the base discriminator for a given encoded discriminator \\p D.\n  static unsigned getBaseDiscriminatorFromDiscriminator(unsigned D) {\n    return getUnsignedFromPrefixEncoding(D);\n  }\n\n  /// Raw encoding of the discriminator. APIs such as cloneWithDuplicationFactor\n  /// have certain special case behavior (e.g. treating empty duplication factor\n  /// as the value '1').\n  /// This API, in conjunction with cloneWithDiscriminator, may be used to encode\n  /// the raw values provided. \\p BD: base discriminator \\p DF: duplication factor\n  /// \\p CI: copy index\n  /// The return is None if the values cannot be encoded in 32 bits - for\n  /// example, values for BD or DF larger than 12 bits. Otherwise, the return\n  /// is the encoded value.\n  static Optional<unsigned> encodeDiscriminator(unsigned BD, unsigned DF, unsigned CI);\n\n  /// Raw decoder for values in an encoded discriminator D.\n  static void decodeDiscriminator(unsigned D, unsigned &BD, unsigned &DF,\n                                  unsigned &CI);\n\n  /// Returns the duplication factor for a given encoded discriminator \\p D, or\n  /// 1 if no value or 0 is encoded.\n  static unsigned getDuplicationFactorFromDiscriminator(unsigned D) {\n    D = getNextComponentInDiscriminator(D);\n    unsigned Ret = getUnsignedFromPrefixEncoding(D);\n    if (Ret == 0)\n      return 1;\n    return Ret;\n  }\n\n  /// Returns the copy identifier for a given encoded discriminator \\p D.\n  static unsigned getCopyIdentifierFromDiscriminator(unsigned D) {\n    return getUnsignedFromPrefixEncoding(getNextComponentInDiscriminator(\n        getNextComponentInDiscriminator(D)));\n  }\n\n\n  Metadata *getRawScope() const { return getOperand(0); }\n  Metadata *getRawInlinedAt() const {\n    if (getNumOperands() == 2)\n      return getOperand(1);\n    return nullptr;\n  }\n\n  static bool classof(const Metadata *MD) {\n    return MD->getMetadataID() == DILocationKind;\n  }\n};\n\n/// Subprogram description.\nclass DISubprogram : public DILocalScope {\n  friend class LLVMContextImpl;\n  friend class MDNode;\n\n  unsigned Line;\n  unsigned ScopeLine;\n  unsigned VirtualIndex;\n\n  /// In the MS ABI, the implicit 'this' parameter is adjusted in the prologue\n  /// of method overrides from secondary bases by this amount. It may be\n  /// negative.\n  int ThisAdjustment;\n\npublic:\n  /// Debug info subprogram flags.\n  enum DISPFlags : uint32_t {\n#define HANDLE_DISP_FLAG(ID, NAME) SPFlag##NAME = ID,\n#define DISP_FLAG_LARGEST_NEEDED\n#include \"llvm/IR/DebugInfoFlags.def\"\n    SPFlagNonvirtual = SPFlagZero,\n    SPFlagVirtuality = SPFlagVirtual | SPFlagPureVirtual,\n    LLVM_MARK_AS_BITMASK_ENUM(SPFlagLargest)\n  };\n\n  static DISPFlags getFlag(StringRef Flag);\n  static StringRef getFlagString(DISPFlags Flag);\n\n  /// Split up a flags bitfield for easier printing.\n  ///\n  /// Split \\c Flags into \\c SplitFlags, a vector of its components.  Returns\n  /// any remaining (unrecognized) bits.\n  static DISPFlags splitFlags(DISPFlags Flags,\n                              SmallVectorImpl<DISPFlags> &SplitFlags);\n\n  // Helper for converting old bitfields to new flags word.\n  static DISPFlags toSPFlags(bool IsLocalToUnit, bool IsDefinition,\n                             bool IsOptimized,\n                             unsigned Virtuality = SPFlagNonvirtual,\n                             bool IsMainSubprogram = false) {\n    // We're assuming virtuality is the low-order field.\n    static_assert(\n        int(SPFlagVirtual) == int(dwarf::DW_VIRTUALITY_virtual) &&\n            int(SPFlagPureVirtual) == int(dwarf::DW_VIRTUALITY_pure_virtual),\n        \"Virtuality constant mismatch\");\n    return static_cast<DISPFlags>(\n        (Virtuality & SPFlagVirtuality) |\n        (IsLocalToUnit ? SPFlagLocalToUnit : SPFlagZero) |\n        (IsDefinition ? SPFlagDefinition : SPFlagZero) |\n        (IsOptimized ? SPFlagOptimized : SPFlagZero) |\n        (IsMainSubprogram ? SPFlagMainSubprogram : SPFlagZero));\n  }\n\nprivate:\n  DIFlags Flags;\n  DISPFlags SPFlags;\n\n  DISubprogram(LLVMContext &C, StorageType Storage, unsigned Line,\n               unsigned ScopeLine, unsigned VirtualIndex, int ThisAdjustment,\n               DIFlags Flags, DISPFlags SPFlags, ArrayRef<Metadata *> Ops)\n      : DILocalScope(C, DISubprogramKind, Storage, dwarf::DW_TAG_subprogram,\n                     Ops),\n        Line(Line), ScopeLine(ScopeLine), VirtualIndex(VirtualIndex),\n        ThisAdjustment(ThisAdjustment), Flags(Flags), SPFlags(SPFlags) {\n    static_assert(dwarf::DW_VIRTUALITY_max < 4, \"Virtuality out of range\");\n  }\n  ~DISubprogram() = default;\n\n  static DISubprogram *\n  getImpl(LLVMContext &Context, DIScope *Scope, StringRef Name,\n          StringRef LinkageName, DIFile *File, unsigned Line,\n          DISubroutineType *Type, unsigned ScopeLine, DIType *ContainingType,\n          unsigned VirtualIndex, int ThisAdjustment, DIFlags Flags,\n          DISPFlags SPFlags, DICompileUnit *Unit,\n          DITemplateParameterArray TemplateParams, DISubprogram *Declaration,\n          DINodeArray RetainedNodes, DITypeArray ThrownTypes,\n          StorageType Storage, bool ShouldCreate = true) {\n    return getImpl(Context, Scope, getCanonicalMDString(Context, Name),\n                   getCanonicalMDString(Context, LinkageName), File, Line, Type,\n                   ScopeLine, ContainingType, VirtualIndex, ThisAdjustment,\n                   Flags, SPFlags, Unit, TemplateParams.get(), Declaration,\n                   RetainedNodes.get(), ThrownTypes.get(), Storage,\n                   ShouldCreate);\n  }\n  static DISubprogram *getImpl(LLVMContext &Context, Metadata *Scope,\n                               MDString *Name, MDString *LinkageName,\n                               Metadata *File, unsigned Line, Metadata *Type,\n                               unsigned ScopeLine, Metadata *ContainingType,\n                               unsigned VirtualIndex, int ThisAdjustment,\n                               DIFlags Flags, DISPFlags SPFlags, Metadata *Unit,\n                               Metadata *TemplateParams, Metadata *Declaration,\n                               Metadata *RetainedNodes, Metadata *ThrownTypes,\n                               StorageType Storage, bool ShouldCreate = true);\n\n  TempDISubprogram cloneImpl() const {\n    return getTemporary(getContext(), getScope(), getName(), getLinkageName(),\n                        getFile(), getLine(), getType(), getScopeLine(),\n                        getContainingType(), getVirtualIndex(),\n                        getThisAdjustment(), getFlags(), getSPFlags(),\n                        getUnit(), getTemplateParams(), getDeclaration(),\n                        getRetainedNodes(), getThrownTypes());\n  }\n\npublic:\n  DEFINE_MDNODE_GET(\n      DISubprogram,\n      (DIScope * Scope, StringRef Name, StringRef LinkageName, DIFile *File,\n       unsigned Line, DISubroutineType *Type, unsigned ScopeLine,\n       DIType *ContainingType, unsigned VirtualIndex, int ThisAdjustment,\n       DIFlags Flags, DISPFlags SPFlags, DICompileUnit *Unit,\n       DITemplateParameterArray TemplateParams = nullptr,\n       DISubprogram *Declaration = nullptr, DINodeArray RetainedNodes = nullptr,\n       DITypeArray ThrownTypes = nullptr),\n      (Scope, Name, LinkageName, File, Line, Type, ScopeLine, ContainingType,\n       VirtualIndex, ThisAdjustment, Flags, SPFlags, Unit, TemplateParams,\n       Declaration, RetainedNodes, ThrownTypes))\n\n  DEFINE_MDNODE_GET(\n      DISubprogram,\n      (Metadata * Scope, MDString *Name, MDString *LinkageName, Metadata *File,\n       unsigned Line, Metadata *Type, unsigned ScopeLine,\n       Metadata *ContainingType, unsigned VirtualIndex, int ThisAdjustment,\n       DIFlags Flags, DISPFlags SPFlags, Metadata *Unit,\n       Metadata *TemplateParams = nullptr, Metadata *Declaration = nullptr,\n       Metadata *RetainedNodes = nullptr, Metadata *ThrownTypes = nullptr),\n      (Scope, Name, LinkageName, File, Line, Type, ScopeLine, ContainingType,\n       VirtualIndex, ThisAdjustment, Flags, SPFlags, Unit, TemplateParams,\n       Declaration, RetainedNodes, ThrownTypes))\n\n  TempDISubprogram clone() const { return cloneImpl(); }\n\n  /// Returns a new temporary DISubprogram with updated Flags\n  TempDISubprogram cloneWithFlags(DIFlags NewFlags) const {\n    auto NewSP = clone();\n    NewSP->Flags = NewFlags;\n    return NewSP;\n  }\n\npublic:\n  unsigned getLine() const { return Line; }\n  unsigned getVirtuality() const { return getSPFlags() & SPFlagVirtuality; }\n  unsigned getVirtualIndex() const { return VirtualIndex; }\n  int getThisAdjustment() const { return ThisAdjustment; }\n  unsigned getScopeLine() const { return ScopeLine; }\n  void setScopeLine(unsigned L) { assert(isDistinct()); ScopeLine = L; }\n  DIFlags getFlags() const { return Flags; }\n  DISPFlags getSPFlags() const { return SPFlags; }\n  bool isLocalToUnit() const { return getSPFlags() & SPFlagLocalToUnit; }\n  bool isDefinition() const { return getSPFlags() & SPFlagDefinition; }\n  bool isOptimized() const { return getSPFlags() & SPFlagOptimized; }\n  bool isMainSubprogram() const { return getSPFlags() & SPFlagMainSubprogram; }\n\n  bool isArtificial() const { return getFlags() & FlagArtificial; }\n  bool isPrivate() const {\n    return (getFlags() & FlagAccessibility) == FlagPrivate;\n  }\n  bool isProtected() const {\n    return (getFlags() & FlagAccessibility) == FlagProtected;\n  }\n  bool isPublic() const {\n    return (getFlags() & FlagAccessibility) == FlagPublic;\n  }\n  bool isExplicit() const { return getFlags() & FlagExplicit; }\n  bool isPrototyped() const { return getFlags() & FlagPrototyped; }\n  bool areAllCallsDescribed() const {\n    return getFlags() & FlagAllCallsDescribed;\n  }\n  bool isPure() const { return getSPFlags() & SPFlagPure; }\n  bool isElemental() const { return getSPFlags() & SPFlagElemental; }\n  bool isRecursive() const { return getSPFlags() & SPFlagRecursive; }\n  bool isObjCDirect() const { return getSPFlags() & SPFlagObjCDirect; }\n\n  /// Check if this is deleted member function.\n  ///\n  /// Return true if this subprogram is a C++11 special\n  /// member function declared deleted.\n  bool isDeleted() const { return getSPFlags() & SPFlagDeleted; }\n\n  /// Check if this is reference-qualified.\n  ///\n  /// Return true if this subprogram is a C++11 reference-qualified non-static\n  /// member function (void foo() &).\n  bool isLValueReference() const { return getFlags() & FlagLValueReference; }\n\n  /// Check if this is rvalue-reference-qualified.\n  ///\n  /// Return true if this subprogram is a C++11 rvalue-reference-qualified\n  /// non-static member function (void foo() &&).\n  bool isRValueReference() const { return getFlags() & FlagRValueReference; }\n\n  /// Check if this is marked as noreturn.\n  ///\n  /// Return true if this subprogram is C++11 noreturn or C11 _Noreturn\n  bool isNoReturn() const { return getFlags() & FlagNoReturn; }\n\n  // Check if this routine is a compiler-generated thunk.\n  //\n  // Returns true if this subprogram is a thunk generated by the compiler.\n  bool isThunk() const { return getFlags() & FlagThunk; }\n\n  DIScope *getScope() const { return cast_or_null<DIScope>(getRawScope()); }\n\n  StringRef getName() const { return getStringOperand(2); }\n  StringRef getLinkageName() const { return getStringOperand(3); }\n\n  DISubroutineType *getType() const {\n    return cast_or_null<DISubroutineType>(getRawType());\n  }\n  DIType *getContainingType() const {\n    return cast_or_null<DIType>(getRawContainingType());\n  }\n\n  DICompileUnit *getUnit() const {\n    return cast_or_null<DICompileUnit>(getRawUnit());\n  }\n  void replaceUnit(DICompileUnit *CU) { replaceOperandWith(5, CU); }\n  DITemplateParameterArray getTemplateParams() const {\n    return cast_or_null<MDTuple>(getRawTemplateParams());\n  }\n  DISubprogram *getDeclaration() const {\n    return cast_or_null<DISubprogram>(getRawDeclaration());\n  }\n  DINodeArray getRetainedNodes() const {\n    return cast_or_null<MDTuple>(getRawRetainedNodes());\n  }\n  DITypeArray getThrownTypes() const {\n    return cast_or_null<MDTuple>(getRawThrownTypes());\n  }\n\n  Metadata *getRawScope() const { return getOperand(1); }\n  MDString *getRawName() const { return getOperandAs<MDString>(2); }\n  MDString *getRawLinkageName() const { return getOperandAs<MDString>(3); }\n  Metadata *getRawType() const { return getOperand(4); }\n  Metadata *getRawUnit() const { return getOperand(5); }\n  Metadata *getRawDeclaration() const { return getOperand(6); }\n  Metadata *getRawRetainedNodes() const { return getOperand(7); }\n  Metadata *getRawContainingType() const {\n    return getNumOperands() > 8 ? getOperandAs<Metadata>(8) : nullptr;\n  }\n  Metadata *getRawTemplateParams() const {\n    return getNumOperands() > 9 ? getOperandAs<Metadata>(9) : nullptr;\n  }\n  Metadata *getRawThrownTypes() const {\n    return getNumOperands() > 10 ? getOperandAs<Metadata>(10) : nullptr;\n  }\n\n  void replaceRawLinkageName(MDString *LinkageName) {\n    replaceOperandWith(3, LinkageName);\n  }\n\n  /// Check if this subprogram describes the given function.\n  ///\n  /// FIXME: Should this be looking through bitcasts?\n  bool describes(const Function *F) const;\n\n  static bool classof(const Metadata *MD) {\n    return MD->getMetadataID() == DISubprogramKind;\n  }\n};\n\nclass DILexicalBlockBase : public DILocalScope {\nprotected:\n  DILexicalBlockBase(LLVMContext &C, unsigned ID, StorageType Storage,\n                     ArrayRef<Metadata *> Ops)\n      : DILocalScope(C, ID, Storage, dwarf::DW_TAG_lexical_block, Ops) {}\n  ~DILexicalBlockBase() = default;\n\npublic:\n  DILocalScope *getScope() const { return cast<DILocalScope>(getRawScope()); }\n\n  Metadata *getRawScope() const { return getOperand(1); }\n\n  static bool classof(const Metadata *MD) {\n    return MD->getMetadataID() == DILexicalBlockKind ||\n           MD->getMetadataID() == DILexicalBlockFileKind;\n  }\n};\n\nclass DILexicalBlock : public DILexicalBlockBase {\n  friend class LLVMContextImpl;\n  friend class MDNode;\n\n  unsigned Line;\n  uint16_t Column;\n\n  DILexicalBlock(LLVMContext &C, StorageType Storage, unsigned Line,\n                 unsigned Column, ArrayRef<Metadata *> Ops)\n      : DILexicalBlockBase(C, DILexicalBlockKind, Storage, Ops), Line(Line),\n        Column(Column) {\n    assert(Column < (1u << 16) && \"Expected 16-bit column\");\n  }\n  ~DILexicalBlock() = default;\n\n  static DILexicalBlock *getImpl(LLVMContext &Context, DILocalScope *Scope,\n                                 DIFile *File, unsigned Line, unsigned Column,\n                                 StorageType Storage,\n                                 bool ShouldCreate = true) {\n    return getImpl(Context, static_cast<Metadata *>(Scope),\n                   static_cast<Metadata *>(File), Line, Column, Storage,\n                   ShouldCreate);\n  }\n\n  static DILexicalBlock *getImpl(LLVMContext &Context, Metadata *Scope,\n                                 Metadata *File, unsigned Line, unsigned Column,\n                                 StorageType Storage, bool ShouldCreate = true);\n\n  TempDILexicalBlock cloneImpl() const {\n    return getTemporary(getContext(), getScope(), getFile(), getLine(),\n                        getColumn());\n  }\n\npublic:\n  DEFINE_MDNODE_GET(DILexicalBlock, (DILocalScope * Scope, DIFile *File,\n                                     unsigned Line, unsigned Column),\n                    (Scope, File, Line, Column))\n  DEFINE_MDNODE_GET(DILexicalBlock, (Metadata * Scope, Metadata *File,\n                                     unsigned Line, unsigned Column),\n                    (Scope, File, Line, Column))\n\n  TempDILexicalBlock clone() const { return cloneImpl(); }\n\n  unsigned getLine() const { return Line; }\n  unsigned getColumn() const { return Column; }\n\n  static bool classof(const Metadata *MD) {\n    return MD->getMetadataID() == DILexicalBlockKind;\n  }\n};\n\nclass DILexicalBlockFile : public DILexicalBlockBase {\n  friend class LLVMContextImpl;\n  friend class MDNode;\n\n  unsigned Discriminator;\n\n  DILexicalBlockFile(LLVMContext &C, StorageType Storage,\n                     unsigned Discriminator, ArrayRef<Metadata *> Ops)\n      : DILexicalBlockBase(C, DILexicalBlockFileKind, Storage, Ops),\n        Discriminator(Discriminator) {}\n  ~DILexicalBlockFile() = default;\n\n  static DILexicalBlockFile *getImpl(LLVMContext &Context, DILocalScope *Scope,\n                                     DIFile *File, unsigned Discriminator,\n                                     StorageType Storage,\n                                     bool ShouldCreate = true) {\n    return getImpl(Context, static_cast<Metadata *>(Scope),\n                   static_cast<Metadata *>(File), Discriminator, Storage,\n                   ShouldCreate);\n  }\n\n  static DILexicalBlockFile *getImpl(LLVMContext &Context, Metadata *Scope,\n                                     Metadata *File, unsigned Discriminator,\n                                     StorageType Storage,\n                                     bool ShouldCreate = true);\n\n  TempDILexicalBlockFile cloneImpl() const {\n    return getTemporary(getContext(), getScope(), getFile(),\n                        getDiscriminator());\n  }\n\npublic:\n  DEFINE_MDNODE_GET(DILexicalBlockFile, (DILocalScope * Scope, DIFile *File,\n                                         unsigned Discriminator),\n                    (Scope, File, Discriminator))\n  DEFINE_MDNODE_GET(DILexicalBlockFile,\n                    (Metadata * Scope, Metadata *File, unsigned Discriminator),\n                    (Scope, File, Discriminator))\n\n  TempDILexicalBlockFile clone() const { return cloneImpl(); }\n  unsigned getDiscriminator() const { return Discriminator; }\n\n  static bool classof(const Metadata *MD) {\n    return MD->getMetadataID() == DILexicalBlockFileKind;\n  }\n};\n\nunsigned DILocation::getDiscriminator() const {\n  if (auto *F = dyn_cast<DILexicalBlockFile>(getScope()))\n    return F->getDiscriminator();\n  return 0;\n}\n\nconst DILocation *\nDILocation::cloneWithDiscriminator(unsigned Discriminator) const {\n  DIScope *Scope = getScope();\n  // Skip all parent DILexicalBlockFile that already have a discriminator\n  // assigned. We do not want to have nested DILexicalBlockFiles that have\n  // mutliple discriminators because only the leaf DILexicalBlockFile's\n  // dominator will be used.\n  for (auto *LBF = dyn_cast<DILexicalBlockFile>(Scope);\n       LBF && LBF->getDiscriminator() != 0;\n       LBF = dyn_cast<DILexicalBlockFile>(Scope))\n    Scope = LBF->getScope();\n  DILexicalBlockFile *NewScope =\n      DILexicalBlockFile::get(getContext(), Scope, getFile(), Discriminator);\n  return DILocation::get(getContext(), getLine(), getColumn(), NewScope,\n                         getInlinedAt());\n}\n\nunsigned DILocation::getBaseDiscriminator() const {\n  return getBaseDiscriminatorFromDiscriminator(getDiscriminator());\n}\n\nunsigned DILocation::getDuplicationFactor() const {\n  return getDuplicationFactorFromDiscriminator(getDiscriminator());\n}\n\nunsigned DILocation::getCopyIdentifier() const {\n  return getCopyIdentifierFromDiscriminator(getDiscriminator());\n}\n\nOptional<const DILocation *> DILocation::cloneWithBaseDiscriminator(unsigned D) const {\n  unsigned BD, DF, CI;\n  decodeDiscriminator(getDiscriminator(), BD, DF, CI);\n  if (D == BD)\n    return this;\n  if (Optional<unsigned> Encoded = encodeDiscriminator(D, DF, CI))\n    return cloneWithDiscriminator(*Encoded);\n  return None;\n}\n\nOptional<const DILocation *> DILocation::cloneByMultiplyingDuplicationFactor(unsigned DF) const {\n  DF *= getDuplicationFactor();\n  if (DF <= 1)\n    return this;\n\n  unsigned BD = getBaseDiscriminator();\n  unsigned CI = getCopyIdentifier();\n  if (Optional<unsigned> D = encodeDiscriminator(BD, DF, CI))\n    return cloneWithDiscriminator(*D);\n  return None;\n}\n\nclass DINamespace : public DIScope {\n  friend class LLVMContextImpl;\n  friend class MDNode;\n\n  unsigned ExportSymbols : 1;\n\n  DINamespace(LLVMContext &Context, StorageType Storage, bool ExportSymbols,\n              ArrayRef<Metadata *> Ops)\n      : DIScope(Context, DINamespaceKind, Storage, dwarf::DW_TAG_namespace,\n                Ops),\n        ExportSymbols(ExportSymbols) {}\n  ~DINamespace() = default;\n\n  static DINamespace *getImpl(LLVMContext &Context, DIScope *Scope,\n                              StringRef Name, bool ExportSymbols,\n                              StorageType Storage, bool ShouldCreate = true) {\n    return getImpl(Context, Scope, getCanonicalMDString(Context, Name),\n                   ExportSymbols, Storage, ShouldCreate);\n  }\n  static DINamespace *getImpl(LLVMContext &Context, Metadata *Scope,\n                              MDString *Name, bool ExportSymbols,\n                              StorageType Storage, bool ShouldCreate = true);\n\n  TempDINamespace cloneImpl() const {\n    return getTemporary(getContext(), getScope(), getName(),\n                        getExportSymbols());\n  }\n\npublic:\n  DEFINE_MDNODE_GET(DINamespace,\n                    (DIScope *Scope, StringRef Name, bool ExportSymbols),\n                    (Scope, Name, ExportSymbols))\n  DEFINE_MDNODE_GET(DINamespace,\n                    (Metadata *Scope, MDString *Name, bool ExportSymbols),\n                    (Scope, Name, ExportSymbols))\n\n  TempDINamespace clone() const { return cloneImpl(); }\n\n  bool getExportSymbols() const { return ExportSymbols; }\n  DIScope *getScope() const { return cast_or_null<DIScope>(getRawScope()); }\n  StringRef getName() const { return getStringOperand(2); }\n\n  Metadata *getRawScope() const { return getOperand(1); }\n  MDString *getRawName() const { return getOperandAs<MDString>(2); }\n\n  static bool classof(const Metadata *MD) {\n    return MD->getMetadataID() == DINamespaceKind;\n  }\n};\n\n/// Represents a module in the programming language, for example, a Clang\n/// module, or a Fortran module.\nclass DIModule : public DIScope {\n  friend class LLVMContextImpl;\n  friend class MDNode;\n  unsigned LineNo;\n  bool IsDecl;\n\n  DIModule(LLVMContext &Context, StorageType Storage, unsigned LineNo,\n           bool IsDecl, ArrayRef<Metadata *> Ops)\n      : DIScope(Context, DIModuleKind, Storage, dwarf::DW_TAG_module, Ops),\n        LineNo(LineNo), IsDecl(IsDecl) {}\n  ~DIModule() = default;\n\n  static DIModule *getImpl(LLVMContext &Context, DIFile *File, DIScope *Scope,\n                           StringRef Name, StringRef ConfigurationMacros,\n                           StringRef IncludePath, StringRef APINotesFile,\n                           unsigned LineNo, bool IsDecl, StorageType Storage,\n                           bool ShouldCreate = true) {\n    return getImpl(Context, File, Scope, getCanonicalMDString(Context, Name),\n                   getCanonicalMDString(Context, ConfigurationMacros),\n                   getCanonicalMDString(Context, IncludePath),\n                   getCanonicalMDString(Context, APINotesFile), LineNo, IsDecl,\n                   Storage, ShouldCreate);\n  }\n  static DIModule *getImpl(LLVMContext &Context, Metadata *File,\n                           Metadata *Scope, MDString *Name,\n                           MDString *ConfigurationMacros, MDString *IncludePath,\n                           MDString *APINotesFile, unsigned LineNo, bool IsDecl,\n                           StorageType Storage, bool ShouldCreate = true);\n\n  TempDIModule cloneImpl() const {\n    return getTemporary(getContext(), getFile(), getScope(), getName(),\n                        getConfigurationMacros(), getIncludePath(),\n                        getAPINotesFile(), getLineNo(), getIsDecl());\n  }\n\npublic:\n  DEFINE_MDNODE_GET(DIModule,\n                    (DIFile * File, DIScope *Scope, StringRef Name,\n                     StringRef ConfigurationMacros, StringRef IncludePath,\n                     StringRef APINotesFile, unsigned LineNo,\n                     bool IsDecl = false),\n                    (File, Scope, Name, ConfigurationMacros, IncludePath,\n                     APINotesFile, LineNo, IsDecl))\n  DEFINE_MDNODE_GET(DIModule,\n                    (Metadata * File, Metadata *Scope, MDString *Name,\n                     MDString *ConfigurationMacros, MDString *IncludePath,\n                     MDString *APINotesFile, unsigned LineNo,\n                     bool IsDecl = false),\n                    (File, Scope, Name, ConfigurationMacros, IncludePath,\n                     APINotesFile, LineNo, IsDecl))\n\n  TempDIModule clone() const { return cloneImpl(); }\n\n  DIScope *getScope() const { return cast_or_null<DIScope>(getRawScope()); }\n  StringRef getName() const { return getStringOperand(2); }\n  StringRef getConfigurationMacros() const { return getStringOperand(3); }\n  StringRef getIncludePath() const { return getStringOperand(4); }\n  StringRef getAPINotesFile() const { return getStringOperand(5); }\n  unsigned getLineNo() const { return LineNo; }\n  bool getIsDecl() const { return IsDecl; }\n\n  Metadata *getRawScope() const { return getOperand(1); }\n  MDString *getRawName() const { return getOperandAs<MDString>(2); }\n  MDString *getRawConfigurationMacros() const {\n    return getOperandAs<MDString>(3);\n  }\n  MDString *getRawIncludePath() const { return getOperandAs<MDString>(4); }\n  MDString *getRawAPINotesFile() const { return getOperandAs<MDString>(5); }\n\n  static bool classof(const Metadata *MD) {\n    return MD->getMetadataID() == DIModuleKind;\n  }\n};\n\n/// Base class for template parameters.\nclass DITemplateParameter : public DINode {\nprotected:\n  bool IsDefault;\n\n  DITemplateParameter(LLVMContext &Context, unsigned ID, StorageType Storage,\n                      unsigned Tag, bool IsDefault, ArrayRef<Metadata *> Ops)\n      : DINode(Context, ID, Storage, Tag, Ops), IsDefault(IsDefault) {}\n  ~DITemplateParameter() = default;\n\npublic:\n  StringRef getName() const { return getStringOperand(0); }\n  DIType *getType() const { return cast_or_null<DIType>(getRawType()); }\n\n  MDString *getRawName() const { return getOperandAs<MDString>(0); }\n  Metadata *getRawType() const { return getOperand(1); }\n  bool isDefault() const { return IsDefault; }\n\n  static bool classof(const Metadata *MD) {\n    return MD->getMetadataID() == DITemplateTypeParameterKind ||\n           MD->getMetadataID() == DITemplateValueParameterKind;\n  }\n};\n\nclass DITemplateTypeParameter : public DITemplateParameter {\n  friend class LLVMContextImpl;\n  friend class MDNode;\n\n  DITemplateTypeParameter(LLVMContext &Context, StorageType Storage,\n                          bool IsDefault, ArrayRef<Metadata *> Ops)\n      : DITemplateParameter(Context, DITemplateTypeParameterKind, Storage,\n                            dwarf::DW_TAG_template_type_parameter, IsDefault,\n                            Ops) {}\n  ~DITemplateTypeParameter() = default;\n\n  static DITemplateTypeParameter *getImpl(LLVMContext &Context, StringRef Name,\n                                          DIType *Type, bool IsDefault,\n                                          StorageType Storage,\n                                          bool ShouldCreate = true) {\n    return getImpl(Context, getCanonicalMDString(Context, Name), Type,\n                   IsDefault, Storage, ShouldCreate);\n  }\n  static DITemplateTypeParameter *getImpl(LLVMContext &Context, MDString *Name,\n                                          Metadata *Type, bool IsDefault,\n                                          StorageType Storage,\n                                          bool ShouldCreate = true);\n\n  TempDITemplateTypeParameter cloneImpl() const {\n    return getTemporary(getContext(), getName(), getType(), isDefault());\n  }\n\npublic:\n  DEFINE_MDNODE_GET(DITemplateTypeParameter,\n                    (StringRef Name, DIType *Type, bool IsDefault),\n                    (Name, Type, IsDefault))\n  DEFINE_MDNODE_GET(DITemplateTypeParameter,\n                    (MDString *Name, Metadata *Type, bool IsDefault),\n                    (Name, Type, IsDefault))\n\n  TempDITemplateTypeParameter clone() const { return cloneImpl(); }\n\n  static bool classof(const Metadata *MD) {\n    return MD->getMetadataID() == DITemplateTypeParameterKind;\n  }\n};\n\nclass DITemplateValueParameter : public DITemplateParameter {\n  friend class LLVMContextImpl;\n  friend class MDNode;\n\n  DITemplateValueParameter(LLVMContext &Context, StorageType Storage,\n                           unsigned Tag, bool IsDefault,\n                           ArrayRef<Metadata *> Ops)\n      : DITemplateParameter(Context, DITemplateValueParameterKind, Storage, Tag,\n                            IsDefault, Ops) {}\n  ~DITemplateValueParameter() = default;\n\n  static DITemplateValueParameter *getImpl(LLVMContext &Context, unsigned Tag,\n                                           StringRef Name, DIType *Type,\n                                           bool IsDefault, Metadata *Value,\n                                           StorageType Storage,\n                                           bool ShouldCreate = true) {\n    return getImpl(Context, Tag, getCanonicalMDString(Context, Name), Type,\n                   IsDefault, Value, Storage, ShouldCreate);\n  }\n  static DITemplateValueParameter *getImpl(LLVMContext &Context, unsigned Tag,\n                                           MDString *Name, Metadata *Type,\n                                           bool IsDefault, Metadata *Value,\n                                           StorageType Storage,\n                                           bool ShouldCreate = true);\n\n  TempDITemplateValueParameter cloneImpl() const {\n    return getTemporary(getContext(), getTag(), getName(), getType(),\n                        isDefault(), getValue());\n  }\n\npublic:\n  DEFINE_MDNODE_GET(DITemplateValueParameter,\n                    (unsigned Tag, StringRef Name, DIType *Type, bool IsDefault,\n                     Metadata *Value),\n                    (Tag, Name, Type, IsDefault, Value))\n  DEFINE_MDNODE_GET(DITemplateValueParameter,\n                    (unsigned Tag, MDString *Name, Metadata *Type,\n                     bool IsDefault, Metadata *Value),\n                    (Tag, Name, Type, IsDefault, Value))\n\n  TempDITemplateValueParameter clone() const { return cloneImpl(); }\n\n  Metadata *getValue() const { return getOperand(2); }\n\n  static bool classof(const Metadata *MD) {\n    return MD->getMetadataID() == DITemplateValueParameterKind;\n  }\n};\n\n/// Base class for variables.\nclass DIVariable : public DINode {\n  unsigned Line;\n  uint32_t AlignInBits;\n\nprotected:\n  DIVariable(LLVMContext &C, unsigned ID, StorageType Storage, unsigned Line,\n             ArrayRef<Metadata *> Ops, uint32_t AlignInBits = 0)\n      : DINode(C, ID, Storage, dwarf::DW_TAG_variable, Ops), Line(Line),\n        AlignInBits(AlignInBits) {}\n  ~DIVariable() = default;\n\npublic:\n  unsigned getLine() const { return Line; }\n  DIScope *getScope() const { return cast_or_null<DIScope>(getRawScope()); }\n  StringRef getName() const { return getStringOperand(1); }\n  DIFile *getFile() const { return cast_or_null<DIFile>(getRawFile()); }\n  DIType *getType() const { return cast_or_null<DIType>(getRawType()); }\n  uint32_t getAlignInBits() const { return AlignInBits; }\n  uint32_t getAlignInBytes() const { return getAlignInBits() / CHAR_BIT; }\n  /// Determines the size of the variable's type.\n  Optional<uint64_t> getSizeInBits() const;\n\n  /// Return the signedness of this variable's type, or None if this type is\n  /// neither signed nor unsigned.\n  Optional<DIBasicType::Signedness> getSignedness() const {\n    if (auto *BT = dyn_cast<DIBasicType>(getType()))\n      return BT->getSignedness();\n    return None;\n  }\n\n  StringRef getFilename() const {\n    if (auto *F = getFile())\n      return F->getFilename();\n    return \"\";\n  }\n\n  StringRef getDirectory() const {\n    if (auto *F = getFile())\n      return F->getDirectory();\n    return \"\";\n  }\n\n  Optional<StringRef> getSource() const {\n    if (auto *F = getFile())\n      return F->getSource();\n    return None;\n  }\n\n  Metadata *getRawScope() const { return getOperand(0); }\n  MDString *getRawName() const { return getOperandAs<MDString>(1); }\n  Metadata *getRawFile() const { return getOperand(2); }\n  Metadata *getRawType() const { return getOperand(3); }\n\n  static bool classof(const Metadata *MD) {\n    return MD->getMetadataID() == DILocalVariableKind ||\n           MD->getMetadataID() == DIGlobalVariableKind;\n  }\n};\n\n/// DWARF expression.\n///\n/// This is (almost) a DWARF expression that modifies the location of a\n/// variable, or the location of a single piece of a variable, or (when using\n/// DW_OP_stack_value) is the constant variable value.\n///\n/// TODO: Co-allocate the expression elements.\n/// TODO: Separate from MDNode, or otherwise drop Distinct and Temporary\n/// storage types.\nclass DIExpression : public MDNode {\n  friend class LLVMContextImpl;\n  friend class MDNode;\n\n  std::vector<uint64_t> Elements;\n\n  DIExpression(LLVMContext &C, StorageType Storage, ArrayRef<uint64_t> Elements)\n      : MDNode(C, DIExpressionKind, Storage, None),\n        Elements(Elements.begin(), Elements.end()) {}\n  ~DIExpression() = default;\n\n  static DIExpression *getImpl(LLVMContext &Context,\n                               ArrayRef<uint64_t> Elements, StorageType Storage,\n                               bool ShouldCreate = true);\n\n  TempDIExpression cloneImpl() const {\n    return getTemporary(getContext(), getElements());\n  }\n\npublic:\n  DEFINE_MDNODE_GET(DIExpression, (ArrayRef<uint64_t> Elements), (Elements))\n\n  TempDIExpression clone() const { return cloneImpl(); }\n\n  ArrayRef<uint64_t> getElements() const { return Elements; }\n\n  unsigned getNumElements() const { return Elements.size(); }\n\n  uint64_t getElement(unsigned I) const {\n    assert(I < Elements.size() && \"Index out of range\");\n    return Elements[I];\n  }\n\n  /// Determine whether this represents a standalone constant value.\n  bool isConstant() const;\n\n  /// Determine whether this represents a standalone signed constant value.\n  bool isSignedConstant() const;\n\n  using element_iterator = ArrayRef<uint64_t>::iterator;\n\n  element_iterator elements_begin() const { return getElements().begin(); }\n  element_iterator elements_end() const { return getElements().end(); }\n\n  /// A lightweight wrapper around an expression operand.\n  ///\n  /// TODO: Store arguments directly and change \\a DIExpression to store a\n  /// range of these.\n  class ExprOperand {\n    const uint64_t *Op = nullptr;\n\n  public:\n    ExprOperand() = default;\n    explicit ExprOperand(const uint64_t *Op) : Op(Op) {}\n\n    const uint64_t *get() const { return Op; }\n\n    /// Get the operand code.\n    uint64_t getOp() const { return *Op; }\n\n    /// Get an argument to the operand.\n    ///\n    /// Never returns the operand itself.\n    uint64_t getArg(unsigned I) const { return Op[I + 1]; }\n\n    unsigned getNumArgs() const { return getSize() - 1; }\n\n    /// Return the size of the operand.\n    ///\n    /// Return the number of elements in the operand (1 + args).\n    unsigned getSize() const;\n\n    /// Append the elements of this operand to \\p V.\n    void appendToVector(SmallVectorImpl<uint64_t> &V) const {\n      V.append(get(), get() + getSize());\n    }\n  };\n\n  /// An iterator for expression operands.\n  class expr_op_iterator\n      : public std::iterator<std::input_iterator_tag, ExprOperand> {\n    ExprOperand Op;\n\n  public:\n    expr_op_iterator() = default;\n    explicit expr_op_iterator(element_iterator I) : Op(I) {}\n\n    element_iterator getBase() const { return Op.get(); }\n    const ExprOperand &operator*() const { return Op; }\n    const ExprOperand *operator->() const { return &Op; }\n\n    expr_op_iterator &operator++() {\n      increment();\n      return *this;\n    }\n    expr_op_iterator operator++(int) {\n      expr_op_iterator T(*this);\n      increment();\n      return T;\n    }\n\n    /// Get the next iterator.\n    ///\n    /// \\a std::next() doesn't work because this is technically an\n    /// input_iterator, but it's a perfectly valid operation.  This is an\n    /// accessor to provide the same functionality.\n    expr_op_iterator getNext() const { return ++expr_op_iterator(*this); }\n\n    bool operator==(const expr_op_iterator &X) const {\n      return getBase() == X.getBase();\n    }\n    bool operator!=(const expr_op_iterator &X) const {\n      return getBase() != X.getBase();\n    }\n\n  private:\n    void increment() { Op = ExprOperand(getBase() + Op.getSize()); }\n  };\n\n  /// Visit the elements via ExprOperand wrappers.\n  ///\n  /// These range iterators visit elements through \\a ExprOperand wrappers.\n  /// This is not guaranteed to be a valid range unless \\a isValid() gives \\c\n  /// true.\n  ///\n  /// \\pre \\a isValid() gives \\c true.\n  /// @{\n  expr_op_iterator expr_op_begin() const {\n    return expr_op_iterator(elements_begin());\n  }\n  expr_op_iterator expr_op_end() const {\n    return expr_op_iterator(elements_end());\n  }\n  iterator_range<expr_op_iterator> expr_ops() const {\n    return {expr_op_begin(), expr_op_end()};\n  }\n  /// @}\n\n  bool isValid() const;\n\n  static bool classof(const Metadata *MD) {\n    return MD->getMetadataID() == DIExpressionKind;\n  }\n\n  /// Return whether the first element a DW_OP_deref.\n  bool startsWithDeref() const {\n    return getNumElements() > 0 && getElement(0) == dwarf::DW_OP_deref;\n  }\n\n  /// Holds the characteristics of one fragment of a larger variable.\n  struct FragmentInfo {\n    uint64_t SizeInBits;\n    uint64_t OffsetInBits;\n  };\n\n  /// Retrieve the details of this fragment expression.\n  static Optional<FragmentInfo> getFragmentInfo(expr_op_iterator Start,\n                                                expr_op_iterator End);\n\n  /// Retrieve the details of this fragment expression.\n  Optional<FragmentInfo> getFragmentInfo() const {\n    return getFragmentInfo(expr_op_begin(), expr_op_end());\n  }\n\n  /// Return whether this is a piece of an aggregate variable.\n  bool isFragment() const { return getFragmentInfo().hasValue(); }\n\n  /// Return whether this is an implicit location description.\n  bool isImplicit() const;\n\n  /// Return whether the location is computed on the expression stack, meaning\n  /// it cannot be a simple register location.\n  bool isComplex() const;\n\n  /// Append \\p Ops with operations to apply the \\p Offset.\n  static void appendOffset(SmallVectorImpl<uint64_t> &Ops, int64_t Offset);\n\n  /// If this is a constant offset, extract it. If there is no expression,\n  /// return true with an offset of zero.\n  bool extractIfOffset(int64_t &Offset) const;\n\n  /// Checks if the last 4 elements of the expression are DW_OP_constu <DWARF\n  /// Address Space> DW_OP_swap DW_OP_xderef and extracts the <DWARF Address\n  /// Space>.\n  static const DIExpression *extractAddressClass(const DIExpression *Expr,\n                                                 unsigned &AddrClass);\n\n  /// Used for DIExpression::prepend.\n  enum PrependOps : uint8_t {\n    ApplyOffset = 0,\n    DerefBefore = 1 << 0,\n    DerefAfter = 1 << 1,\n    StackValue = 1 << 2,\n    EntryValue = 1 << 3\n  };\n\n  /// Prepend \\p DIExpr with a deref and offset operation and optionally turn it\n  /// into a stack value or/and an entry value.\n  static DIExpression *prepend(const DIExpression *Expr, uint8_t Flags,\n                               int64_t Offset = 0);\n\n  /// Prepend \\p DIExpr with the given opcodes and optionally turn it into a\n  /// stack value.\n  static DIExpression *prependOpcodes(const DIExpression *Expr,\n                                      SmallVectorImpl<uint64_t> &Ops,\n                                      bool StackValue = false,\n                                      bool EntryValue = false);\n\n  /// Append the opcodes \\p Ops to \\p DIExpr. Unlike \\ref appendToStack, the\n  /// returned expression is a stack value only if \\p DIExpr is a stack value.\n  /// If \\p DIExpr describes a fragment, the returned expression will describe\n  /// the same fragment.\n  static DIExpression *append(const DIExpression *Expr, ArrayRef<uint64_t> Ops);\n\n  /// Convert \\p DIExpr into a stack value if it isn't one already by appending\n  /// DW_OP_deref if needed, and appending \\p Ops to the resulting expression.\n  /// If \\p DIExpr describes a fragment, the returned expression will describe\n  /// the same fragment.\n  static DIExpression *appendToStack(const DIExpression *Expr,\n                                     ArrayRef<uint64_t> Ops);\n\n  /// Create a copy of \\p Expr by appending the given list of \\p Ops to each\n  /// instance of the operand `DW_OP_LLVM_arg, \\p ArgNo`. This is used to\n  /// modify a specific location used by \\p Expr, such as when salvaging that\n  /// location.\n  static DIExpression *appendOpsToArg(const DIExpression *Expr,\n                                      ArrayRef<uint64_t> Ops, unsigned ArgNo,\n                                      bool StackValue = false);\n\n  /// Create a copy of \\p Expr with each instance of\n  /// `DW_OP_LLVM_arg, \\p OldArg` replaced with `DW_OP_LLVM_arg, \\p NewArg`,\n  /// and each instance of `DW_OP_LLVM_arg, Arg` with `DW_OP_LLVM_arg, Arg - 1`\n  /// for all Arg > \\p OldArg.\n  /// This is used when replacing one of the operands of a debug value list\n  /// with another operand in the same list and deleting the old operand.\n  static DIExpression *replaceArg(const DIExpression *Expr, uint64_t OldArg,\n                                  uint64_t NewArg);\n\n  /// Create a DIExpression to describe one part of an aggregate variable that\n  /// is fragmented across multiple Values. The DW_OP_LLVM_fragment operation\n  /// will be appended to the elements of \\c Expr. If \\c Expr already contains\n  /// a \\c DW_OP_LLVM_fragment \\c OffsetInBits is interpreted as an offset\n  /// into the existing fragment.\n  ///\n  /// \\param OffsetInBits Offset of the piece in bits.\n  /// \\param SizeInBits   Size of the piece in bits.\n  /// \\return             Creating a fragment expression may fail if \\c Expr\n  ///                     contains arithmetic operations that would be truncated.\n  static Optional<DIExpression *>\n  createFragmentExpression(const DIExpression *Expr, unsigned OffsetInBits,\n                           unsigned SizeInBits);\n\n  /// Determine the relative position of the fragments passed in.\n  /// Returns -1 if this is entirely before Other, 0 if this and Other overlap,\n  /// 1 if this is entirely after Other.\n  static int fragmentCmp(const FragmentInfo &A, const FragmentInfo &B) {\n    uint64_t l1 = A.OffsetInBits;\n    uint64_t l2 = B.OffsetInBits;\n    uint64_t r1 = l1 + A.SizeInBits;\n    uint64_t r2 = l2 + B.SizeInBits;\n    if (r1 <= l2)\n      return -1;\n    else if (r2 <= l1)\n      return 1;\n    else\n      return 0;\n  }\n\n  using ExtOps = std::array<uint64_t, 6>;\n\n  /// Returns the ops for a zero- or sign-extension in a DIExpression.\n  static ExtOps getExtOps(unsigned FromSize, unsigned ToSize, bool Signed);\n\n  /// Append a zero- or sign-extension to \\p Expr. Converts the expression to a\n  /// stack value if it isn't one already.\n  static DIExpression *appendExt(const DIExpression *Expr, unsigned FromSize,\n                                 unsigned ToSize, bool Signed);\n\n  /// Check if fragments overlap between a pair of FragmentInfos.\n  static bool fragmentsOverlap(const FragmentInfo &A, const FragmentInfo &B) {\n    return fragmentCmp(A, B) == 0;\n  }\n\n  /// Determine the relative position of the fragments described by this\n  /// DIExpression and \\p Other. Calls static fragmentCmp implementation.\n  int fragmentCmp(const DIExpression *Other) const {\n    auto Fragment1 = *getFragmentInfo();\n    auto Fragment2 = *Other->getFragmentInfo();\n    return fragmentCmp(Fragment1, Fragment2);\n  }\n\n  /// Check if fragments overlap between this DIExpression and \\p Other.\n  bool fragmentsOverlap(const DIExpression *Other) const {\n    if (!isFragment() || !Other->isFragment())\n      return true;\n    return fragmentCmp(Other) == 0;\n  }\n\n  /// Check if the expression consists of exactly one entry value operand.\n  /// (This is the only configuration of entry values that is supported.)\n  bool isEntryValue() const {\n    return getNumElements() > 0 &&\n           getElement(0) == dwarf::DW_OP_LLVM_entry_value;\n  }\n};\n\ninline bool operator==(const DIExpression::FragmentInfo &A,\n                       const DIExpression::FragmentInfo &B) {\n  return std::tie(A.SizeInBits, A.OffsetInBits) ==\n         std::tie(B.SizeInBits, B.OffsetInBits);\n}\n\ninline bool operator<(const DIExpression::FragmentInfo &A,\n                      const DIExpression::FragmentInfo &B) {\n  return std::tie(A.SizeInBits, A.OffsetInBits) <\n         std::tie(B.SizeInBits, B.OffsetInBits);\n}\n\ntemplate <> struct DenseMapInfo<DIExpression::FragmentInfo> {\n  using FragInfo = DIExpression::FragmentInfo;\n  static const uint64_t MaxVal = std::numeric_limits<uint64_t>::max();\n\n  static inline FragInfo getEmptyKey() { return {MaxVal, MaxVal}; }\n\n  static inline FragInfo getTombstoneKey() { return {MaxVal - 1, MaxVal - 1}; }\n\n  static unsigned getHashValue(const FragInfo &Frag) {\n    return (Frag.SizeInBits & 0xffff) << 16 | (Frag.OffsetInBits & 0xffff);\n  }\n\n  static bool isEqual(const FragInfo &A, const FragInfo &B) { return A == B; }\n};\n\n/// Global variables.\n///\n/// TODO: Remove DisplayName.  It's always equal to Name.\nclass DIGlobalVariable : public DIVariable {\n  friend class LLVMContextImpl;\n  friend class MDNode;\n\n  bool IsLocalToUnit;\n  bool IsDefinition;\n\n  DIGlobalVariable(LLVMContext &C, StorageType Storage, unsigned Line,\n                   bool IsLocalToUnit, bool IsDefinition, uint32_t AlignInBits,\n                   ArrayRef<Metadata *> Ops)\n      : DIVariable(C, DIGlobalVariableKind, Storage, Line, Ops, AlignInBits),\n        IsLocalToUnit(IsLocalToUnit), IsDefinition(IsDefinition) {}\n  ~DIGlobalVariable() = default;\n\n  static DIGlobalVariable *\n  getImpl(LLVMContext &Context, DIScope *Scope, StringRef Name,\n          StringRef LinkageName, DIFile *File, unsigned Line, DIType *Type,\n          bool IsLocalToUnit, bool IsDefinition,\n          DIDerivedType *StaticDataMemberDeclaration, MDTuple *TemplateParams,\n          uint32_t AlignInBits, StorageType Storage, bool ShouldCreate = true) {\n    return getImpl(Context, Scope, getCanonicalMDString(Context, Name),\n                   getCanonicalMDString(Context, LinkageName), File, Line, Type,\n                   IsLocalToUnit, IsDefinition, StaticDataMemberDeclaration,\n                   cast_or_null<Metadata>(TemplateParams), AlignInBits, Storage,\n                   ShouldCreate);\n  }\n  static DIGlobalVariable *\n  getImpl(LLVMContext &Context, Metadata *Scope, MDString *Name,\n          MDString *LinkageName, Metadata *File, unsigned Line, Metadata *Type,\n          bool IsLocalToUnit, bool IsDefinition,\n          Metadata *StaticDataMemberDeclaration, Metadata *TemplateParams,\n          uint32_t AlignInBits, StorageType Storage, bool ShouldCreate = true);\n\n  TempDIGlobalVariable cloneImpl() const {\n    return getTemporary(getContext(), getScope(), getName(), getLinkageName(),\n                        getFile(), getLine(), getType(), isLocalToUnit(),\n                        isDefinition(), getStaticDataMemberDeclaration(),\n                        getTemplateParams(), getAlignInBits());\n  }\n\npublic:\n  DEFINE_MDNODE_GET(DIGlobalVariable,\n                    (DIScope * Scope, StringRef Name, StringRef LinkageName,\n                     DIFile *File, unsigned Line, DIType *Type,\n                     bool IsLocalToUnit, bool IsDefinition,\n                     DIDerivedType *StaticDataMemberDeclaration,\n                     MDTuple *TemplateParams, uint32_t AlignInBits),\n                    (Scope, Name, LinkageName, File, Line, Type, IsLocalToUnit,\n                     IsDefinition, StaticDataMemberDeclaration, TemplateParams,\n                     AlignInBits))\n  DEFINE_MDNODE_GET(DIGlobalVariable,\n                    (Metadata * Scope, MDString *Name, MDString *LinkageName,\n                     Metadata *File, unsigned Line, Metadata *Type,\n                     bool IsLocalToUnit, bool IsDefinition,\n                     Metadata *StaticDataMemberDeclaration,\n                     Metadata *TemplateParams, uint32_t AlignInBits),\n                    (Scope, Name, LinkageName, File, Line, Type, IsLocalToUnit,\n                     IsDefinition, StaticDataMemberDeclaration, TemplateParams,\n                     AlignInBits))\n\n  TempDIGlobalVariable clone() const { return cloneImpl(); }\n\n  bool isLocalToUnit() const { return IsLocalToUnit; }\n  bool isDefinition() const { return IsDefinition; }\n  StringRef getDisplayName() const { return getStringOperand(4); }\n  StringRef getLinkageName() const { return getStringOperand(5); }\n  DIDerivedType *getStaticDataMemberDeclaration() const {\n    return cast_or_null<DIDerivedType>(getRawStaticDataMemberDeclaration());\n  }\n\n  MDString *getRawLinkageName() const { return getOperandAs<MDString>(5); }\n  Metadata *getRawStaticDataMemberDeclaration() const { return getOperand(6); }\n  Metadata *getRawTemplateParams() const { return getOperand(7); }\n  MDTuple *getTemplateParams() const { return getOperandAs<MDTuple>(7); }\n\n  static bool classof(const Metadata *MD) {\n    return MD->getMetadataID() == DIGlobalVariableKind;\n  }\n};\n\nclass DICommonBlock : public DIScope {\n  unsigned LineNo;\n\n  friend class LLVMContextImpl;\n  friend class MDNode;\n\n  DICommonBlock(LLVMContext &Context, StorageType Storage, unsigned LineNo,\n                ArrayRef<Metadata *> Ops)\n      : DIScope(Context, DICommonBlockKind, Storage, dwarf::DW_TAG_common_block,\n                Ops), LineNo(LineNo) {}\n\n  static DICommonBlock *getImpl(LLVMContext &Context, DIScope *Scope,\n                                DIGlobalVariable *Decl, StringRef Name,\n                                DIFile *File, unsigned LineNo,\n                                StorageType Storage,\n                                bool ShouldCreate = true) {\n    return getImpl(Context, Scope, Decl, getCanonicalMDString(Context, Name),\n                   File, LineNo, Storage, ShouldCreate);\n  }\n  static DICommonBlock *getImpl(LLVMContext &Context, Metadata *Scope,\n                                Metadata *Decl, MDString *Name, Metadata *File,\n                                unsigned LineNo, \n                                StorageType Storage, bool ShouldCreate = true);\n\n  TempDICommonBlock cloneImpl() const {\n    return getTemporary(getContext(), getScope(), getDecl(), getName(),\n                        getFile(), getLineNo());\n  }\n\npublic:\n  DEFINE_MDNODE_GET(DICommonBlock,\n                    (DIScope *Scope, DIGlobalVariable *Decl, StringRef Name,\n                     DIFile *File, unsigned LineNo),\n                    (Scope, Decl, Name, File, LineNo))\n  DEFINE_MDNODE_GET(DICommonBlock,\n                    (Metadata *Scope, Metadata *Decl, MDString *Name,\n                     Metadata *File, unsigned LineNo),\n                    (Scope, Decl, Name, File, LineNo))\n\n  TempDICommonBlock clone() const { return cloneImpl(); }\n\n  DIScope *getScope() const { return cast_or_null<DIScope>(getRawScope()); }\n  DIGlobalVariable *getDecl() const {\n    return cast_or_null<DIGlobalVariable>(getRawDecl());\n  }\n  StringRef getName() const { return getStringOperand(2); }\n  DIFile *getFile() const { return cast_or_null<DIFile>(getRawFile()); }\n  unsigned getLineNo() const { return LineNo; }\n\n  Metadata *getRawScope() const { return getOperand(0); }\n  Metadata *getRawDecl() const { return getOperand(1); }\n  MDString *getRawName() const { return getOperandAs<MDString>(2); }\n  Metadata *getRawFile() const { return getOperand(3); }\n\n  static bool classof(const Metadata *MD) {\n    return MD->getMetadataID() == DICommonBlockKind;\n  }\n};\n\n/// Local variable.\n///\n/// TODO: Split up flags.\nclass DILocalVariable : public DIVariable {\n  friend class LLVMContextImpl;\n  friend class MDNode;\n\n  unsigned Arg : 16;\n  DIFlags Flags;\n\n  DILocalVariable(LLVMContext &C, StorageType Storage, unsigned Line,\n                  unsigned Arg, DIFlags Flags, uint32_t AlignInBits,\n                  ArrayRef<Metadata *> Ops)\n      : DIVariable(C, DILocalVariableKind, Storage, Line, Ops, AlignInBits),\n        Arg(Arg), Flags(Flags) {\n    assert(Arg < (1 << 16) && \"DILocalVariable: Arg out of range\");\n  }\n  ~DILocalVariable() = default;\n\n  static DILocalVariable *getImpl(LLVMContext &Context, DIScope *Scope,\n                                  StringRef Name, DIFile *File, unsigned Line,\n                                  DIType *Type, unsigned Arg, DIFlags Flags,\n                                  uint32_t AlignInBits, StorageType Storage,\n                                  bool ShouldCreate = true) {\n    return getImpl(Context, Scope, getCanonicalMDString(Context, Name), File,\n                   Line, Type, Arg, Flags, AlignInBits, Storage, ShouldCreate);\n  }\n  static DILocalVariable *getImpl(LLVMContext &Context, Metadata *Scope,\n                                  MDString *Name, Metadata *File, unsigned Line,\n                                  Metadata *Type, unsigned Arg, DIFlags Flags,\n                                  uint32_t AlignInBits, StorageType Storage,\n                                  bool ShouldCreate = true);\n\n  TempDILocalVariable cloneImpl() const {\n    return getTemporary(getContext(), getScope(), getName(), getFile(),\n                        getLine(), getType(), getArg(), getFlags(),\n                        getAlignInBits());\n  }\n\npublic:\n  DEFINE_MDNODE_GET(DILocalVariable,\n                    (DILocalScope * Scope, StringRef Name, DIFile *File,\n                     unsigned Line, DIType *Type, unsigned Arg, DIFlags Flags,\n                     uint32_t AlignInBits),\n                    (Scope, Name, File, Line, Type, Arg, Flags, AlignInBits))\n  DEFINE_MDNODE_GET(DILocalVariable,\n                    (Metadata * Scope, MDString *Name, Metadata *File,\n                     unsigned Line, Metadata *Type, unsigned Arg,\n                     DIFlags Flags, uint32_t AlignInBits),\n                    (Scope, Name, File, Line, Type, Arg, Flags, AlignInBits))\n\n  TempDILocalVariable clone() const { return cloneImpl(); }\n\n  /// Get the local scope for this variable.\n  ///\n  /// Variables must be defined in a local scope.\n  DILocalScope *getScope() const {\n    return cast<DILocalScope>(DIVariable::getScope());\n  }\n\n  bool isParameter() const { return Arg; }\n  unsigned getArg() const { return Arg; }\n  DIFlags getFlags() const { return Flags; }\n\n  bool isArtificial() const { return getFlags() & FlagArtificial; }\n  bool isObjectPointer() const { return getFlags() & FlagObjectPointer; }\n\n  /// Check that a location is valid for this variable.\n  ///\n  /// Check that \\c DL exists, is in the same subprogram, and has the same\n  /// inlined-at location as \\c this.  (Otherwise, it's not a valid attachment\n  /// to a \\a DbgInfoIntrinsic.)\n  bool isValidLocationForIntrinsic(const DILocation *DL) const {\n    return DL && getScope()->getSubprogram() == DL->getScope()->getSubprogram();\n  }\n\n  static bool classof(const Metadata *MD) {\n    return MD->getMetadataID() == DILocalVariableKind;\n  }\n};\n\n/// Label.\n///\nclass DILabel : public DINode {\n  friend class LLVMContextImpl;\n  friend class MDNode;\n\n  unsigned Line;\n\n  DILabel(LLVMContext &C, StorageType Storage, unsigned Line,\n          ArrayRef<Metadata *> Ops)\n      : DINode(C, DILabelKind, Storage, dwarf::DW_TAG_label, Ops), Line(Line) {}\n  ~DILabel() = default;\n\n  static DILabel *getImpl(LLVMContext &Context, DIScope *Scope,\n                          StringRef Name, DIFile *File, unsigned Line,\n                          StorageType Storage,\n                          bool ShouldCreate = true) {\n    return getImpl(Context, Scope, getCanonicalMDString(Context, Name), File,\n                   Line, Storage, ShouldCreate);\n  }\n  static DILabel *getImpl(LLVMContext &Context, Metadata *Scope,\n                          MDString *Name, Metadata *File, unsigned Line,\n                          StorageType Storage,\n                          bool ShouldCreate = true);\n\n  TempDILabel cloneImpl() const {\n    return getTemporary(getContext(), getScope(), getName(), getFile(),\n                        getLine());\n  }\n\npublic:\n  DEFINE_MDNODE_GET(DILabel,\n                    (DILocalScope * Scope, StringRef Name, DIFile *File,\n                     unsigned Line),\n                    (Scope, Name, File, Line))\n  DEFINE_MDNODE_GET(DILabel,\n                    (Metadata * Scope, MDString *Name, Metadata *File,\n                     unsigned Line),\n                    (Scope, Name, File, Line))\n\n  TempDILabel clone() const { return cloneImpl(); }\n\n  /// Get the local scope for this label.\n  ///\n  /// Labels must be defined in a local scope.\n  DILocalScope *getScope() const {\n    return cast_or_null<DILocalScope>(getRawScope());\n  }\n  unsigned getLine() const { return Line; }\n  StringRef getName() const { return getStringOperand(1); }\n  DIFile *getFile() const { return cast_or_null<DIFile>(getRawFile()); }\n\n  Metadata *getRawScope() const { return getOperand(0); }\n  MDString *getRawName() const { return getOperandAs<MDString>(1); }\n  Metadata *getRawFile() const { return getOperand(2); }\n\n  /// Check that a location is valid for this label.\n  ///\n  /// Check that \\c DL exists, is in the same subprogram, and has the same\n  /// inlined-at location as \\c this.  (Otherwise, it's not a valid attachment\n  /// to a \\a DbgInfoIntrinsic.)\n  bool isValidLocationForIntrinsic(const DILocation *DL) const {\n    return DL && getScope()->getSubprogram() == DL->getScope()->getSubprogram();\n  }\n\n  static bool classof(const Metadata *MD) {\n    return MD->getMetadataID() == DILabelKind;\n  }\n};\n\nclass DIObjCProperty : public DINode {\n  friend class LLVMContextImpl;\n  friend class MDNode;\n\n  unsigned Line;\n  unsigned Attributes;\n\n  DIObjCProperty(LLVMContext &C, StorageType Storage, unsigned Line,\n                 unsigned Attributes, ArrayRef<Metadata *> Ops)\n      : DINode(C, DIObjCPropertyKind, Storage, dwarf::DW_TAG_APPLE_property,\n               Ops),\n        Line(Line), Attributes(Attributes) {}\n  ~DIObjCProperty() = default;\n\n  static DIObjCProperty *\n  getImpl(LLVMContext &Context, StringRef Name, DIFile *File, unsigned Line,\n          StringRef GetterName, StringRef SetterName, unsigned Attributes,\n          DIType *Type, StorageType Storage, bool ShouldCreate = true) {\n    return getImpl(Context, getCanonicalMDString(Context, Name), File, Line,\n                   getCanonicalMDString(Context, GetterName),\n                   getCanonicalMDString(Context, SetterName), Attributes, Type,\n                   Storage, ShouldCreate);\n  }\n  static DIObjCProperty *getImpl(LLVMContext &Context, MDString *Name,\n                                 Metadata *File, unsigned Line,\n                                 MDString *GetterName, MDString *SetterName,\n                                 unsigned Attributes, Metadata *Type,\n                                 StorageType Storage, bool ShouldCreate = true);\n\n  TempDIObjCProperty cloneImpl() const {\n    return getTemporary(getContext(), getName(), getFile(), getLine(),\n                        getGetterName(), getSetterName(), getAttributes(),\n                        getType());\n  }\n\npublic:\n  DEFINE_MDNODE_GET(DIObjCProperty,\n                    (StringRef Name, DIFile *File, unsigned Line,\n                     StringRef GetterName, StringRef SetterName,\n                     unsigned Attributes, DIType *Type),\n                    (Name, File, Line, GetterName, SetterName, Attributes,\n                     Type))\n  DEFINE_MDNODE_GET(DIObjCProperty,\n                    (MDString * Name, Metadata *File, unsigned Line,\n                     MDString *GetterName, MDString *SetterName,\n                     unsigned Attributes, Metadata *Type),\n                    (Name, File, Line, GetterName, SetterName, Attributes,\n                     Type))\n\n  TempDIObjCProperty clone() const { return cloneImpl(); }\n\n  unsigned getLine() const { return Line; }\n  unsigned getAttributes() const { return Attributes; }\n  StringRef getName() const { return getStringOperand(0); }\n  DIFile *getFile() const { return cast_or_null<DIFile>(getRawFile()); }\n  StringRef getGetterName() const { return getStringOperand(2); }\n  StringRef getSetterName() const { return getStringOperand(3); }\n  DIType *getType() const { return cast_or_null<DIType>(getRawType()); }\n\n  StringRef getFilename() const {\n    if (auto *F = getFile())\n      return F->getFilename();\n    return \"\";\n  }\n\n  StringRef getDirectory() const {\n    if (auto *F = getFile())\n      return F->getDirectory();\n    return \"\";\n  }\n\n  MDString *getRawName() const { return getOperandAs<MDString>(0); }\n  Metadata *getRawFile() const { return getOperand(1); }\n  MDString *getRawGetterName() const { return getOperandAs<MDString>(2); }\n  MDString *getRawSetterName() const { return getOperandAs<MDString>(3); }\n  Metadata *getRawType() const { return getOperand(4); }\n\n  static bool classof(const Metadata *MD) {\n    return MD->getMetadataID() == DIObjCPropertyKind;\n  }\n};\n\n/// An imported module (C++ using directive or similar).\nclass DIImportedEntity : public DINode {\n  friend class LLVMContextImpl;\n  friend class MDNode;\n\n  unsigned Line;\n\n  DIImportedEntity(LLVMContext &C, StorageType Storage, unsigned Tag,\n                   unsigned Line, ArrayRef<Metadata *> Ops)\n      : DINode(C, DIImportedEntityKind, Storage, Tag, Ops), Line(Line) {}\n  ~DIImportedEntity() = default;\n\n  static DIImportedEntity *getImpl(LLVMContext &Context, unsigned Tag,\n                                   DIScope *Scope, DINode *Entity, DIFile *File,\n                                   unsigned Line, StringRef Name,\n                                   StorageType Storage,\n                                   bool ShouldCreate = true) {\n    return getImpl(Context, Tag, Scope, Entity, File, Line,\n                   getCanonicalMDString(Context, Name), Storage, ShouldCreate);\n  }\n  static DIImportedEntity *getImpl(LLVMContext &Context, unsigned Tag,\n                                   Metadata *Scope, Metadata *Entity,\n                                   Metadata *File, unsigned Line,\n                                   MDString *Name, StorageType Storage,\n                                   bool ShouldCreate = true);\n\n  TempDIImportedEntity cloneImpl() const {\n    return getTemporary(getContext(), getTag(), getScope(), getEntity(),\n                        getFile(), getLine(), getName());\n  }\n\npublic:\n  DEFINE_MDNODE_GET(DIImportedEntity,\n                    (unsigned Tag, DIScope *Scope, DINode *Entity, DIFile *File,\n                     unsigned Line, StringRef Name = \"\"),\n                    (Tag, Scope, Entity, File, Line, Name))\n  DEFINE_MDNODE_GET(DIImportedEntity,\n                    (unsigned Tag, Metadata *Scope, Metadata *Entity,\n                     Metadata *File, unsigned Line, MDString *Name),\n                    (Tag, Scope, Entity, File, Line, Name))\n\n  TempDIImportedEntity clone() const { return cloneImpl(); }\n\n  unsigned getLine() const { return Line; }\n  DIScope *getScope() const { return cast_or_null<DIScope>(getRawScope()); }\n  DINode *getEntity() const { return cast_or_null<DINode>(getRawEntity()); }\n  StringRef getName() const { return getStringOperand(2); }\n  DIFile *getFile() const { return cast_or_null<DIFile>(getRawFile()); }\n\n  Metadata *getRawScope() const { return getOperand(0); }\n  Metadata *getRawEntity() const { return getOperand(1); }\n  MDString *getRawName() const { return getOperandAs<MDString>(2); }\n  Metadata *getRawFile() const { return getOperand(3); }\n\n  static bool classof(const Metadata *MD) {\n    return MD->getMetadataID() == DIImportedEntityKind;\n  }\n};\n\n/// A pair of DIGlobalVariable and DIExpression.\nclass DIGlobalVariableExpression : public MDNode {\n  friend class LLVMContextImpl;\n  friend class MDNode;\n\n  DIGlobalVariableExpression(LLVMContext &C, StorageType Storage,\n                             ArrayRef<Metadata *> Ops)\n      : MDNode(C, DIGlobalVariableExpressionKind, Storage, Ops) {}\n  ~DIGlobalVariableExpression() = default;\n\n  static DIGlobalVariableExpression *\n  getImpl(LLVMContext &Context, Metadata *Variable, Metadata *Expression,\n          StorageType Storage, bool ShouldCreate = true);\n\n  TempDIGlobalVariableExpression cloneImpl() const {\n    return getTemporary(getContext(), getVariable(), getExpression());\n  }\n\npublic:\n  DEFINE_MDNODE_GET(DIGlobalVariableExpression,\n                    (Metadata * Variable, Metadata *Expression),\n                    (Variable, Expression))\n\n  TempDIGlobalVariableExpression clone() const { return cloneImpl(); }\n\n  Metadata *getRawVariable() const { return getOperand(0); }\n\n  DIGlobalVariable *getVariable() const {\n    return cast_or_null<DIGlobalVariable>(getRawVariable());\n  }\n\n  Metadata *getRawExpression() const { return getOperand(1); }\n\n  DIExpression *getExpression() const {\n    return cast<DIExpression>(getRawExpression());\n  }\n\n  static bool classof(const Metadata *MD) {\n    return MD->getMetadataID() == DIGlobalVariableExpressionKind;\n  }\n};\n\n/// Macro Info DWARF-like metadata node.\n///\n/// A metadata node with a DWARF macro info (i.e., a constant named\n/// \\c DW_MACINFO_*, defined in llvm/BinaryFormat/Dwarf.h).  Called \\a\n/// DIMacroNode\n/// because it's potentially used for non-DWARF output.\nclass DIMacroNode : public MDNode {\n  friend class LLVMContextImpl;\n  friend class MDNode;\n\nprotected:\n  DIMacroNode(LLVMContext &C, unsigned ID, StorageType Storage, unsigned MIType,\n              ArrayRef<Metadata *> Ops1, ArrayRef<Metadata *> Ops2 = None)\n      : MDNode(C, ID, Storage, Ops1, Ops2) {\n    assert(MIType < 1u << 16);\n    SubclassData16 = MIType;\n  }\n  ~DIMacroNode() = default;\n\n  template <class Ty> Ty *getOperandAs(unsigned I) const {\n    return cast_or_null<Ty>(getOperand(I));\n  }\n\n  StringRef getStringOperand(unsigned I) const {\n    if (auto *S = getOperandAs<MDString>(I))\n      return S->getString();\n    return StringRef();\n  }\n\n  static MDString *getCanonicalMDString(LLVMContext &Context, StringRef S) {\n    if (S.empty())\n      return nullptr;\n    return MDString::get(Context, S);\n  }\n\npublic:\n  unsigned getMacinfoType() const { return SubclassData16; }\n\n  static bool classof(const Metadata *MD) {\n    switch (MD->getMetadataID()) {\n    default:\n      return false;\n    case DIMacroKind:\n    case DIMacroFileKind:\n      return true;\n    }\n  }\n};\n\nclass DIMacro : public DIMacroNode {\n  friend class LLVMContextImpl;\n  friend class MDNode;\n\n  unsigned Line;\n\n  DIMacro(LLVMContext &C, StorageType Storage, unsigned MIType, unsigned Line,\n          ArrayRef<Metadata *> Ops)\n      : DIMacroNode(C, DIMacroKind, Storage, MIType, Ops), Line(Line) {}\n  ~DIMacro() = default;\n\n  static DIMacro *getImpl(LLVMContext &Context, unsigned MIType, unsigned Line,\n                          StringRef Name, StringRef Value, StorageType Storage,\n                          bool ShouldCreate = true) {\n    return getImpl(Context, MIType, Line, getCanonicalMDString(Context, Name),\n                   getCanonicalMDString(Context, Value), Storage, ShouldCreate);\n  }\n  static DIMacro *getImpl(LLVMContext &Context, unsigned MIType, unsigned Line,\n                          MDString *Name, MDString *Value, StorageType Storage,\n                          bool ShouldCreate = true);\n\n  TempDIMacro cloneImpl() const {\n    return getTemporary(getContext(), getMacinfoType(), getLine(), getName(),\n                        getValue());\n  }\n\npublic:\n  DEFINE_MDNODE_GET(DIMacro, (unsigned MIType, unsigned Line, StringRef Name,\n                              StringRef Value = \"\"),\n                    (MIType, Line, Name, Value))\n  DEFINE_MDNODE_GET(DIMacro, (unsigned MIType, unsigned Line, MDString *Name,\n                              MDString *Value),\n                    (MIType, Line, Name, Value))\n\n  TempDIMacro clone() const { return cloneImpl(); }\n\n  unsigned getLine() const { return Line; }\n\n  StringRef getName() const { return getStringOperand(0); }\n  StringRef getValue() const { return getStringOperand(1); }\n\n  MDString *getRawName() const { return getOperandAs<MDString>(0); }\n  MDString *getRawValue() const { return getOperandAs<MDString>(1); }\n\n  static bool classof(const Metadata *MD) {\n    return MD->getMetadataID() == DIMacroKind;\n  }\n};\n\nclass DIMacroFile : public DIMacroNode {\n  friend class LLVMContextImpl;\n  friend class MDNode;\n\n  unsigned Line;\n\n  DIMacroFile(LLVMContext &C, StorageType Storage, unsigned MIType,\n              unsigned Line, ArrayRef<Metadata *> Ops)\n      : DIMacroNode(C, DIMacroFileKind, Storage, MIType, Ops), Line(Line) {}\n  ~DIMacroFile() = default;\n\n  static DIMacroFile *getImpl(LLVMContext &Context, unsigned MIType,\n                              unsigned Line, DIFile *File,\n                              DIMacroNodeArray Elements, StorageType Storage,\n                              bool ShouldCreate = true) {\n    return getImpl(Context, MIType, Line, static_cast<Metadata *>(File),\n                   Elements.get(), Storage, ShouldCreate);\n  }\n\n  static DIMacroFile *getImpl(LLVMContext &Context, unsigned MIType,\n                              unsigned Line, Metadata *File, Metadata *Elements,\n                              StorageType Storage, bool ShouldCreate = true);\n\n  TempDIMacroFile cloneImpl() const {\n    return getTemporary(getContext(), getMacinfoType(), getLine(), getFile(),\n                        getElements());\n  }\n\npublic:\n  DEFINE_MDNODE_GET(DIMacroFile, (unsigned MIType, unsigned Line, DIFile *File,\n                                  DIMacroNodeArray Elements),\n                    (MIType, Line, File, Elements))\n  DEFINE_MDNODE_GET(DIMacroFile, (unsigned MIType, unsigned Line,\n                                  Metadata *File, Metadata *Elements),\n                    (MIType, Line, File, Elements))\n\n  TempDIMacroFile clone() const { return cloneImpl(); }\n\n  void replaceElements(DIMacroNodeArray Elements) {\n#ifndef NDEBUG\n    for (DIMacroNode *Op : getElements())\n      assert(is_contained(Elements->operands(), Op) &&\n             \"Lost a macro node during macro node list replacement\");\n#endif\n    replaceOperandWith(1, Elements.get());\n  }\n\n  unsigned getLine() const { return Line; }\n  DIFile *getFile() const { return cast_or_null<DIFile>(getRawFile()); }\n\n  DIMacroNodeArray getElements() const {\n    return cast_or_null<MDTuple>(getRawElements());\n  }\n\n  Metadata *getRawFile() const { return getOperand(0); }\n  Metadata *getRawElements() const { return getOperand(1); }\n\n  static bool classof(const Metadata *MD) {\n    return MD->getMetadataID() == DIMacroFileKind;\n  }\n};\n\n/// List of ValueAsMetadata, to be used as an argument to a dbg.value\n/// intrinsic.\nclass DIArgList : public MDNode {\n  friend class LLVMContextImpl;\n  friend class MDNode;\n  using iterator = SmallVectorImpl<ValueAsMetadata *>::iterator;\n\n  SmallVector<ValueAsMetadata *, 4> Args;\n\n  DIArgList(LLVMContext &C, StorageType Storage,\n            ArrayRef<ValueAsMetadata *> Args)\n      : MDNode(C, DIArgListKind, Storage, None),\n        Args(Args.begin(), Args.end()) {\n    track();\n  }\n  ~DIArgList() { untrack(); }\n\n  static DIArgList *getImpl(LLVMContext &Context,\n                            ArrayRef<ValueAsMetadata *> Args,\n                            StorageType Storage, bool ShouldCreate = true);\n\n  TempDIArgList cloneImpl() const {\n    return getTemporary(getContext(), getArgs());\n  }\n\n  void track();\n  void untrack();\n  void dropAllReferences();\n\npublic:\n  DEFINE_MDNODE_GET(DIArgList, (ArrayRef<ValueAsMetadata *> Args), (Args))\n\n  TempDIArgList clone() const { return cloneImpl(); }\n\n  ArrayRef<ValueAsMetadata *> getArgs() const { return Args; }\n\n  iterator args_begin() { return Args.begin(); }\n  iterator args_end() { return Args.end(); }\n\n  static bool classof(const Metadata *MD) {\n    return MD->getMetadataID() == DIArgListKind;\n  }\n\n  void handleChangedOperand(void *Ref, Metadata *New);\n};\n\n/// Identifies a unique instance of a variable.\n///\n/// Storage for identifying a potentially inlined instance of a variable,\n/// or a fragment thereof. This guarantees that exactly one variable instance\n/// may be identified by this class, even when that variable is a fragment of\n/// an aggregate variable and/or there is another inlined instance of the same\n/// source code variable nearby.\n/// This class does not necessarily uniquely identify that variable: it is\n/// possible that a DebugVariable with different parameters may point to the\n/// same variable instance, but not that one DebugVariable points to multiple\n/// variable instances.\nclass DebugVariable {\n  using FragmentInfo = DIExpression::FragmentInfo;\n\n  const DILocalVariable *Variable;\n  Optional<FragmentInfo> Fragment;\n  const DILocation *InlinedAt;\n\n  /// Fragment that will overlap all other fragments. Used as default when\n  /// caller demands a fragment.\n  static const FragmentInfo DefaultFragment;\n\npublic:\n  DebugVariable(const DILocalVariable *Var, Optional<FragmentInfo> FragmentInfo,\n                const DILocation *InlinedAt)\n      : Variable(Var), Fragment(FragmentInfo), InlinedAt(InlinedAt) {}\n\n  DebugVariable(const DILocalVariable *Var, const DIExpression *DIExpr,\n                const DILocation *InlinedAt)\n      : Variable(Var),\n        Fragment(DIExpr ? DIExpr->getFragmentInfo() : NoneType()),\n        InlinedAt(InlinedAt) {}\n\n  const DILocalVariable *getVariable() const { return Variable; }\n  Optional<FragmentInfo> getFragment() const { return Fragment; }\n  const DILocation *getInlinedAt() const { return InlinedAt; }\n\n  FragmentInfo getFragmentOrDefault() const {\n    return Fragment.getValueOr(DefaultFragment);\n  }\n\n  static bool isDefaultFragment(const FragmentInfo F) {\n    return F == DefaultFragment;\n  }\n\n  bool operator==(const DebugVariable &Other) const {\n    return std::tie(Variable, Fragment, InlinedAt) ==\n           std::tie(Other.Variable, Other.Fragment, Other.InlinedAt);\n  }\n\n  bool operator<(const DebugVariable &Other) const {\n    return std::tie(Variable, Fragment, InlinedAt) <\n           std::tie(Other.Variable, Other.Fragment, Other.InlinedAt);\n  }\n};\n\ntemplate <> struct DenseMapInfo<DebugVariable> {\n  using FragmentInfo = DIExpression::FragmentInfo;\n\n  /// Empty key: no key should be generated that has no DILocalVariable.\n  static inline DebugVariable getEmptyKey() {\n    return DebugVariable(nullptr, NoneType(), nullptr);\n  }\n\n  /// Difference in tombstone is that the Optional is meaningful.\n  static inline DebugVariable getTombstoneKey() {\n    return DebugVariable(nullptr, {{0, 0}}, nullptr);\n  }\n\n  static unsigned getHashValue(const DebugVariable &D) {\n    unsigned HV = 0;\n    const Optional<FragmentInfo> Fragment = D.getFragment();\n    if (Fragment)\n      HV = DenseMapInfo<FragmentInfo>::getHashValue(*Fragment);\n\n    return hash_combine(D.getVariable(), HV, D.getInlinedAt());\n  }\n\n  static bool isEqual(const DebugVariable &A, const DebugVariable &B) {\n    return A == B;\n  }\n};\n\n} // end namespace llvm\n\n#undef DEFINE_MDNODE_GET_UNPACK_IMPL\n#undef DEFINE_MDNODE_GET_UNPACK\n#undef DEFINE_MDNODE_GET\n\n#endif // LLVM_IR_DEBUGINFOMETADATA_H\n"}, "38": {"id": 38, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/IR/DerivedTypes.h", "content": "//===- llvm/DerivedTypes.h - Classes for handling data types ----*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// This file contains the declarations of classes that represent \"derived\n// types\".  These are things like \"arrays of x\" or \"structure of x, y, z\" or\n// \"function returning x taking (y,z) as parameters\", etc...\n//\n// The implementations of these classes live in the Type.cpp file.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_IR_DERIVEDTYPES_H\n#define LLVM_IR_DERIVEDTYPES_H\n\n#include \"llvm/ADT/ArrayRef.h\"\n#include \"llvm/ADT/STLExtras.h\"\n#include \"llvm/ADT/StringRef.h\"\n#include \"llvm/IR/Type.h\"\n#include \"llvm/Support/Casting.h\"\n#include \"llvm/Support/Compiler.h\"\n#include \"llvm/Support/TypeSize.h\"\n#include <cassert>\n#include <cstdint>\n\nnamespace llvm {\n\nclass Value;\nclass APInt;\nclass LLVMContext;\n\n/// Class to represent integer types. Note that this class is also used to\n/// represent the built-in integer types: Int1Ty, Int8Ty, Int16Ty, Int32Ty and\n/// Int64Ty.\n/// Integer representation type\nclass IntegerType : public Type {\n  friend class LLVMContextImpl;\n\nprotected:\n  explicit IntegerType(LLVMContext &C, unsigned NumBits) : Type(C, IntegerTyID){\n    setSubclassData(NumBits);\n  }\n\npublic:\n  /// This enum is just used to hold constants we need for IntegerType.\n  enum {\n    MIN_INT_BITS = 1,        ///< Minimum number of bits that can be specified\n    MAX_INT_BITS = (1<<24)-1 ///< Maximum number of bits that can be specified\n      ///< Note that bit width is stored in the Type classes SubclassData field\n      ///< which has 24 bits. This yields a maximum bit width of 16,777,215\n      ///< bits.\n  };\n\n  /// This static method is the primary way of constructing an IntegerType.\n  /// If an IntegerType with the same NumBits value was previously instantiated,\n  /// that instance will be returned. Otherwise a new one will be created. Only\n  /// one instance with a given NumBits value is ever created.\n  /// Get or create an IntegerType instance.\n  static IntegerType *get(LLVMContext &C, unsigned NumBits);\n\n  /// Returns type twice as wide the input type.\n  IntegerType *getExtendedType() const {\n    return Type::getIntNTy(getContext(), 2 * getScalarSizeInBits());\n  }\n\n  /// Get the number of bits in this IntegerType\n  unsigned getBitWidth() const { return getSubclassData(); }\n\n  /// Return a bitmask with ones set for all of the bits that can be set by an\n  /// unsigned version of this type. This is 0xFF for i8, 0xFFFF for i16, etc.\n  uint64_t getBitMask() const {\n    return ~uint64_t(0UL) >> (64-getBitWidth());\n  }\n\n  /// Return a uint64_t with just the most significant bit set (the sign bit, if\n  /// the value is treated as a signed number).\n  uint64_t getSignBit() const {\n    return 1ULL << (getBitWidth()-1);\n  }\n\n  /// For example, this is 0xFF for an 8 bit integer, 0xFFFF for i16, etc.\n  /// @returns a bit mask with ones set for all the bits of this type.\n  /// Get a bit mask for this type.\n  APInt getMask() const;\n\n  /// Methods for support type inquiry through isa, cast, and dyn_cast.\n  static bool classof(const Type *T) {\n    return T->getTypeID() == IntegerTyID;\n  }\n};\n\nunsigned Type::getIntegerBitWidth() const {\n  return cast<IntegerType>(this)->getBitWidth();\n}\n\n/// Class to represent function types\n///\nclass FunctionType : public Type {\n  FunctionType(Type *Result, ArrayRef<Type*> Params, bool IsVarArgs);\n\npublic:\n  FunctionType(const FunctionType &) = delete;\n  FunctionType &operator=(const FunctionType &) = delete;\n\n  /// This static method is the primary way of constructing a FunctionType.\n  static FunctionType *get(Type *Result,\n                           ArrayRef<Type*> Params, bool isVarArg);\n\n  /// Create a FunctionType taking no parameters.\n  static FunctionType *get(Type *Result, bool isVarArg);\n\n  /// Return true if the specified type is valid as a return type.\n  static bool isValidReturnType(Type *RetTy);\n\n  /// Return true if the specified type is valid as an argument type.\n  static bool isValidArgumentType(Type *ArgTy);\n\n  bool isVarArg() const { return getSubclassData()!=0; }\n  Type *getReturnType() const { return ContainedTys[0]; }\n\n  using param_iterator = Type::subtype_iterator;\n\n  param_iterator param_begin() const { return ContainedTys + 1; }\n  param_iterator param_end() const { return &ContainedTys[NumContainedTys]; }\n  ArrayRef<Type *> params() const {\n    return makeArrayRef(param_begin(), param_end());\n  }\n\n  /// Parameter type accessors.\n  Type *getParamType(unsigned i) const { return ContainedTys[i+1]; }\n\n  /// Return the number of fixed parameters this function type requires.\n  /// This does not consider varargs.\n  unsigned getNumParams() const { return NumContainedTys - 1; }\n\n  /// Methods for support type inquiry through isa, cast, and dyn_cast.\n  static bool classof(const Type *T) {\n    return T->getTypeID() == FunctionTyID;\n  }\n};\nstatic_assert(alignof(FunctionType) >= alignof(Type *),\n              \"Alignment sufficient for objects appended to FunctionType\");\n\nbool Type::isFunctionVarArg() const {\n  return cast<FunctionType>(this)->isVarArg();\n}\n\nType *Type::getFunctionParamType(unsigned i) const {\n  return cast<FunctionType>(this)->getParamType(i);\n}\n\nunsigned Type::getFunctionNumParams() const {\n  return cast<FunctionType>(this)->getNumParams();\n}\n\n/// A handy container for a FunctionType+Callee-pointer pair, which can be\n/// passed around as a single entity. This assists in replacing the use of\n/// PointerType::getElementType() to access the function's type, since that's\n/// slated for removal as part of the [opaque pointer types] project.\nclass FunctionCallee {\npublic:\n  // Allow implicit conversion from types which have a getFunctionType member\n  // (e.g. Function and InlineAsm).\n  template <typename T, typename U = decltype(&T::getFunctionType)>\n  FunctionCallee(T *Fn)\n      : FnTy(Fn ? Fn->getFunctionType() : nullptr), Callee(Fn) {}\n\n  FunctionCallee(FunctionType *FnTy, Value *Callee)\n      : FnTy(FnTy), Callee(Callee) {\n    assert((FnTy == nullptr) == (Callee == nullptr));\n  }\n\n  FunctionCallee(std::nullptr_t) {}\n\n  FunctionCallee() = default;\n\n  FunctionType *getFunctionType() { return FnTy; }\n\n  Value *getCallee() { return Callee; }\n\n  explicit operator bool() { return Callee; }\n\nprivate:\n  FunctionType *FnTy = nullptr;\n  Value *Callee = nullptr;\n};\n\n/// Class to represent struct types. There are two different kinds of struct\n/// types: Literal structs and Identified structs.\n///\n/// Literal struct types (e.g. { i32, i32 }) are uniqued structurally, and must\n/// always have a body when created.  You can get one of these by using one of\n/// the StructType::get() forms.\n///\n/// Identified structs (e.g. %foo or %42) may optionally have a name and are not\n/// uniqued.  The names for identified structs are managed at the LLVMContext\n/// level, so there can only be a single identified struct with a given name in\n/// a particular LLVMContext.  Identified structs may also optionally be opaque\n/// (have no body specified).  You get one of these by using one of the\n/// StructType::create() forms.\n///\n/// Independent of what kind of struct you have, the body of a struct type are\n/// laid out in memory consecutively with the elements directly one after the\n/// other (if the struct is packed) or (if not packed) with padding between the\n/// elements as defined by DataLayout (which is required to match what the code\n/// generator for a target expects).\n///\nclass StructType : public Type {\n  StructType(LLVMContext &C) : Type(C, StructTyID) {}\n\n  enum {\n    /// This is the contents of the SubClassData field.\n    SCDB_HasBody = 1,\n    SCDB_Packed = 2,\n    SCDB_IsLiteral = 4,\n    SCDB_IsSized = 8\n  };\n\n  /// For a named struct that actually has a name, this is a pointer to the\n  /// symbol table entry (maintained by LLVMContext) for the struct.\n  /// This is null if the type is an literal struct or if it is a identified\n  /// type that has an empty name.\n  void *SymbolTableEntry = nullptr;\n\npublic:\n  StructType(const StructType &) = delete;\n  StructType &operator=(const StructType &) = delete;\n\n  /// This creates an identified struct.\n  static StructType *create(LLVMContext &Context, StringRef Name);\n  static StructType *create(LLVMContext &Context);\n\n  static StructType *create(ArrayRef<Type *> Elements, StringRef Name,\n                            bool isPacked = false);\n  static StructType *create(ArrayRef<Type *> Elements);\n  static StructType *create(LLVMContext &Context, ArrayRef<Type *> Elements,\n                            StringRef Name, bool isPacked = false);\n  static StructType *create(LLVMContext &Context, ArrayRef<Type *> Elements);\n  template <class... Tys>\n  static std::enable_if_t<are_base_of<Type, Tys...>::value, StructType *>\n  create(StringRef Name, Type *elt1, Tys *... elts) {\n    assert(elt1 && \"Cannot create a struct type with no elements with this\");\n    SmallVector<llvm::Type *, 8> StructFields({elt1, elts...});\n    return create(StructFields, Name);\n  }\n\n  /// This static method is the primary way to create a literal StructType.\n  static StructType *get(LLVMContext &Context, ArrayRef<Type*> Elements,\n                         bool isPacked = false);\n\n  /// Create an empty structure type.\n  static StructType *get(LLVMContext &Context, bool isPacked = false);\n\n  /// This static method is a convenience method for creating structure types by\n  /// specifying the elements as arguments. Note that this method always returns\n  /// a non-packed struct, and requires at least one element type.\n  template <class... Tys>\n  static std::enable_if_t<are_base_of<Type, Tys...>::value, StructType *>\n  get(Type *elt1, Tys *... elts) {\n    assert(elt1 && \"Cannot create a struct type with no elements with this\");\n    LLVMContext &Ctx = elt1->getContext();\n    SmallVector<llvm::Type *, 8> StructFields({elt1, elts...});\n    return llvm::StructType::get(Ctx, StructFields);\n  }\n\n  /// Return the type with the specified name, or null if there is none by that\n  /// name.\n  static StructType *getTypeByName(LLVMContext &C, StringRef Name);\n\n  bool isPacked() const { return (getSubclassData() & SCDB_Packed) != 0; }\n\n  /// Return true if this type is uniqued by structural equivalence, false if it\n  /// is a struct definition.\n  bool isLiteral() const { return (getSubclassData() & SCDB_IsLiteral) != 0; }\n\n  /// Return true if this is a type with an identity that has no body specified\n  /// yet. These prints as 'opaque' in .ll files.\n  bool isOpaque() const { return (getSubclassData() & SCDB_HasBody) == 0; }\n\n  /// isSized - Return true if this is a sized type.\n  bool isSized(SmallPtrSetImpl<Type *> *Visited = nullptr) const;\n\n  /// Returns true if this struct contains a scalable vector.\n  bool containsScalableVectorType() const;\n\n  /// Return true if this is a named struct that has a non-empty name.\n  bool hasName() const { return SymbolTableEntry != nullptr; }\n\n  /// Return the name for this struct type if it has an identity.\n  /// This may return an empty string for an unnamed struct type.  Do not call\n  /// this on an literal type.\n  StringRef getName() const;\n\n  /// Change the name of this type to the specified name, or to a name with a\n  /// suffix if there is a collision. Do not call this on an literal type.\n  void setName(StringRef Name);\n\n  /// Specify a body for an opaque identified type.\n  void setBody(ArrayRef<Type*> Elements, bool isPacked = false);\n\n  template <typename... Tys>\n  std::enable_if_t<are_base_of<Type, Tys...>::value, void>\n  setBody(Type *elt1, Tys *... elts) {\n    assert(elt1 && \"Cannot create a struct type with no elements with this\");\n    SmallVector<llvm::Type *, 8> StructFields({elt1, elts...});\n    setBody(StructFields);\n  }\n\n  /// Return true if the specified type is valid as a element type.\n  static bool isValidElementType(Type *ElemTy);\n\n  // Iterator access to the elements.\n  using element_iterator = Type::subtype_iterator;\n\n  element_iterator element_begin() const { return ContainedTys; }\n  element_iterator element_end() const { return &ContainedTys[NumContainedTys];}\n  ArrayRef<Type *> elements() const {\n    return makeArrayRef(element_begin(), element_end());\n  }\n\n  /// Return true if this is layout identical to the specified struct.\n  bool isLayoutIdentical(StructType *Other) const;\n\n  /// Random access to the elements\n  unsigned getNumElements() const { return NumContainedTys; }\n  Type *getElementType(unsigned N) const {\n    assert(N < NumContainedTys && \"Element number out of range!\");\n    return ContainedTys[N];\n  }\n  /// Given an index value into the type, return the type of the element.\n  Type *getTypeAtIndex(const Value *V) const;\n  Type *getTypeAtIndex(unsigned N) const { return getElementType(N); }\n  bool indexValid(const Value *V) const;\n  bool indexValid(unsigned Idx) const { return Idx < getNumElements(); }\n\n  /// Methods for support type inquiry through isa, cast, and dyn_cast.\n  static bool classof(const Type *T) {\n    return T->getTypeID() == StructTyID;\n  }\n};\n\nStringRef Type::getStructName() const {\n  return cast<StructType>(this)->getName();\n}\n\nunsigned Type::getStructNumElements() const {\n  return cast<StructType>(this)->getNumElements();\n}\n\nType *Type::getStructElementType(unsigned N) const {\n  return cast<StructType>(this)->getElementType(N);\n}\n\n/// Class to represent array types.\nclass ArrayType : public Type {\n  /// The element type of the array.\n  Type *ContainedType;\n  /// Number of elements in the array.\n  uint64_t NumElements;\n\n  ArrayType(Type *ElType, uint64_t NumEl);\n\npublic:\n  ArrayType(const ArrayType &) = delete;\n  ArrayType &operator=(const ArrayType &) = delete;\n\n  uint64_t getNumElements() const { return NumElements; }\n  Type *getElementType() const { return ContainedType; }\n\n  /// This static method is the primary way to construct an ArrayType\n  static ArrayType *get(Type *ElementType, uint64_t NumElements);\n\n  /// Return true if the specified type is valid as a element type.\n  static bool isValidElementType(Type *ElemTy);\n\n  /// Methods for support type inquiry through isa, cast, and dyn_cast.\n  static bool classof(const Type *T) {\n    return T->getTypeID() == ArrayTyID;\n  }\n};\n\nuint64_t Type::getArrayNumElements() const {\n  return cast<ArrayType>(this)->getNumElements();\n}\n\n/// Base class of all SIMD vector types\nclass VectorType : public Type {\n  /// A fully specified VectorType is of the form <vscale x n x Ty>. 'n' is the\n  /// minimum number of elements of type Ty contained within the vector, and\n  /// 'vscale x' indicates that the total element count is an integer multiple\n  /// of 'n', where the multiple is either guaranteed to be one, or is\n  /// statically unknown at compile time.\n  ///\n  /// If the multiple is known to be 1, then the extra term is discarded in\n  /// textual IR:\n  ///\n  /// <4 x i32>          - a vector containing 4 i32s\n  /// <vscale x 4 x i32> - a vector containing an unknown integer multiple\n  ///                      of 4 i32s\n\n  /// The element type of the vector.\n  Type *ContainedType;\n\nprotected:\n  /// The element quantity of this vector. The meaning of this value depends\n  /// on the type of vector:\n  /// - For FixedVectorType = <ElementQuantity x ty>, there are\n  ///   exactly ElementQuantity elements in this vector.\n  /// - For ScalableVectorType = <vscale x ElementQuantity x ty>,\n  ///   there are vscale * ElementQuantity elements in this vector, where\n  ///   vscale is a runtime-constant integer greater than 0.\n  const unsigned ElementQuantity;\n\n  VectorType(Type *ElType, unsigned EQ, Type::TypeID TID);\n\npublic:\n  VectorType(const VectorType &) = delete;\n  VectorType &operator=(const VectorType &) = delete;\n\n  Type *getElementType() const { return ContainedType; }\n\n  /// This static method is the primary way to construct an VectorType.\n  static VectorType *get(Type *ElementType, ElementCount EC);\n\n  static VectorType *get(Type *ElementType, unsigned NumElements,\n                         bool Scalable) {\n    return VectorType::get(ElementType,\n                           ElementCount::get(NumElements, Scalable));\n  }\n\n  static VectorType *get(Type *ElementType, const VectorType *Other) {\n    return VectorType::get(ElementType, Other->getElementCount());\n  }\n\n  /// This static method gets a VectorType with the same number of elements as\n  /// the input type, and the element type is an integer type of the same width\n  /// as the input element type.\n  static VectorType *getInteger(VectorType *VTy) {\n    unsigned EltBits = VTy->getElementType()->getPrimitiveSizeInBits();\n    assert(EltBits && \"Element size must be of a non-zero size\");\n    Type *EltTy = IntegerType::get(VTy->getContext(), EltBits);\n    return VectorType::get(EltTy, VTy->getElementCount());\n  }\n\n  /// This static method is like getInteger except that the element types are\n  /// twice as wide as the elements in the input type.\n  static VectorType *getExtendedElementVectorType(VectorType *VTy) {\n    assert(VTy->isIntOrIntVectorTy() && \"VTy expected to be a vector of ints.\");\n    auto *EltTy = cast<IntegerType>(VTy->getElementType());\n    return VectorType::get(EltTy->getExtendedType(), VTy->getElementCount());\n  }\n\n  // This static method gets a VectorType with the same number of elements as\n  // the input type, and the element type is an integer or float type which\n  // is half as wide as the elements in the input type.\n  static VectorType *getTruncatedElementVectorType(VectorType *VTy) {\n    Type *EltTy;\n    if (VTy->getElementType()->isFloatingPointTy()) {\n      switch(VTy->getElementType()->getTypeID()) {\n      case DoubleTyID:\n        EltTy = Type::getFloatTy(VTy->getContext());\n        break;\n      case FloatTyID:\n        EltTy = Type::getHalfTy(VTy->getContext());\n        break;\n      default:\n        llvm_unreachable(\"Cannot create narrower fp vector element type\");\n      }\n    } else {\n      unsigned EltBits = VTy->getElementType()->getPrimitiveSizeInBits();\n      assert((EltBits & 1) == 0 &&\n             \"Cannot truncate vector element with odd bit-width\");\n      EltTy = IntegerType::get(VTy->getContext(), EltBits / 2);\n    }\n    return VectorType::get(EltTy, VTy->getElementCount());\n  }\n\n  // This static method returns a VectorType with a smaller number of elements\n  // of a larger type than the input element type. For example, a <16 x i8>\n  // subdivided twice would return <4 x i32>\n  static VectorType *getSubdividedVectorType(VectorType *VTy, int NumSubdivs) {\n    for (int i = 0; i < NumSubdivs; ++i) {\n      VTy = VectorType::getDoubleElementsVectorType(VTy);\n      VTy = VectorType::getTruncatedElementVectorType(VTy);\n    }\n    return VTy;\n  }\n\n  /// This static method returns a VectorType with half as many elements as the\n  /// input type and the same element type.\n  static VectorType *getHalfElementsVectorType(VectorType *VTy) {\n    auto EltCnt = VTy->getElementCount();\n    assert(EltCnt.isKnownEven() &&\n           \"Cannot halve vector with odd number of elements.\");\n    return VectorType::get(VTy->getElementType(),\n                           EltCnt.divideCoefficientBy(2));\n  }\n\n  /// This static method returns a VectorType with twice as many elements as the\n  /// input type and the same element type.\n  static VectorType *getDoubleElementsVectorType(VectorType *VTy) {\n    auto EltCnt = VTy->getElementCount();\n    assert((EltCnt.getKnownMinValue() * 2ull) <= UINT_MAX &&\n           \"Too many elements in vector\");\n    return VectorType::get(VTy->getElementType(), EltCnt * 2);\n  }\n\n  /// Return true if the specified type is valid as a element type.\n  static bool isValidElementType(Type *ElemTy);\n\n  /// Return an ElementCount instance to represent the (possibly scalable)\n  /// number of elements in the vector.\n  inline ElementCount getElementCount() const;\n\n  /// Methods for support type inquiry through isa, cast, and dyn_cast.\n  static bool classof(const Type *T) {\n    return T->getTypeID() == FixedVectorTyID ||\n           T->getTypeID() == ScalableVectorTyID;\n  }\n};\n\n/// Class to represent fixed width SIMD vectors\nclass FixedVectorType : public VectorType {\nprotected:\n  FixedVectorType(Type *ElTy, unsigned NumElts)\n      : VectorType(ElTy, NumElts, FixedVectorTyID) {}\n\npublic:\n  static FixedVectorType *get(Type *ElementType, unsigned NumElts);\n\n  static FixedVectorType *get(Type *ElementType, const FixedVectorType *FVTy) {\n    return get(ElementType, FVTy->getNumElements());\n  }\n\n  static FixedVectorType *getInteger(FixedVectorType *VTy) {\n    return cast<FixedVectorType>(VectorType::getInteger(VTy));\n  }\n\n  static FixedVectorType *getExtendedElementVectorType(FixedVectorType *VTy) {\n    return cast<FixedVectorType>(VectorType::getExtendedElementVectorType(VTy));\n  }\n\n  static FixedVectorType *getTruncatedElementVectorType(FixedVectorType *VTy) {\n    return cast<FixedVectorType>(\n        VectorType::getTruncatedElementVectorType(VTy));\n  }\n\n  static FixedVectorType *getSubdividedVectorType(FixedVectorType *VTy,\n                                                  int NumSubdivs) {\n    return cast<FixedVectorType>(\n        VectorType::getSubdividedVectorType(VTy, NumSubdivs));\n  }\n\n  static FixedVectorType *getHalfElementsVectorType(FixedVectorType *VTy) {\n    return cast<FixedVectorType>(VectorType::getHalfElementsVectorType(VTy));\n  }\n\n  static FixedVectorType *getDoubleElementsVectorType(FixedVectorType *VTy) {\n    return cast<FixedVectorType>(VectorType::getDoubleElementsVectorType(VTy));\n  }\n\n  static bool classof(const Type *T) {\n    return T->getTypeID() == FixedVectorTyID;\n  }\n\n  unsigned getNumElements() const { return ElementQuantity; }\n};\n\n/// Class to represent scalable SIMD vectors\nclass ScalableVectorType : public VectorType {\nprotected:\n  ScalableVectorType(Type *ElTy, unsigned MinNumElts)\n      : VectorType(ElTy, MinNumElts, ScalableVectorTyID) {}\n\npublic:\n  static ScalableVectorType *get(Type *ElementType, unsigned MinNumElts);\n\n  static ScalableVectorType *get(Type *ElementType,\n                                 const ScalableVectorType *SVTy) {\n    return get(ElementType, SVTy->getMinNumElements());\n  }\n\n  static ScalableVectorType *getInteger(ScalableVectorType *VTy) {\n    return cast<ScalableVectorType>(VectorType::getInteger(VTy));\n  }\n\n  static ScalableVectorType *\n  getExtendedElementVectorType(ScalableVectorType *VTy) {\n    return cast<ScalableVectorType>(\n        VectorType::getExtendedElementVectorType(VTy));\n  }\n\n  static ScalableVectorType *\n  getTruncatedElementVectorType(ScalableVectorType *VTy) {\n    return cast<ScalableVectorType>(\n        VectorType::getTruncatedElementVectorType(VTy));\n  }\n\n  static ScalableVectorType *getSubdividedVectorType(ScalableVectorType *VTy,\n                                                     int NumSubdivs) {\n    return cast<ScalableVectorType>(\n        VectorType::getSubdividedVectorType(VTy, NumSubdivs));\n  }\n\n  static ScalableVectorType *\n  getHalfElementsVectorType(ScalableVectorType *VTy) {\n    return cast<ScalableVectorType>(VectorType::getHalfElementsVectorType(VTy));\n  }\n\n  static ScalableVectorType *\n  getDoubleElementsVectorType(ScalableVectorType *VTy) {\n    return cast<ScalableVectorType>(\n        VectorType::getDoubleElementsVectorType(VTy));\n  }\n\n  /// Get the minimum number of elements in this vector. The actual number of\n  /// elements in the vector is an integer multiple of this value.\n  uint64_t getMinNumElements() const { return ElementQuantity; }\n\n  static bool classof(const Type *T) {\n    return T->getTypeID() == ScalableVectorTyID;\n  }\n};\n\ninline ElementCount VectorType::getElementCount() const {\n  return ElementCount::get(ElementQuantity, isa<ScalableVectorType>(this));\n}\n\n/// Class to represent pointers.\nclass PointerType : public Type {\n  explicit PointerType(Type *ElType, unsigned AddrSpace);\n\n  Type *PointeeTy;\n\npublic:\n  PointerType(const PointerType &) = delete;\n  PointerType &operator=(const PointerType &) = delete;\n\n  /// This constructs a pointer to an object of the specified type in a numbered\n  /// address space.\n  static PointerType *get(Type *ElementType, unsigned AddressSpace);\n\n  /// This constructs a pointer to an object of the specified type in the\n  /// generic address space (address space zero).\n  static PointerType *getUnqual(Type *ElementType) {\n    return PointerType::get(ElementType, 0);\n  }\n\n  Type *getElementType() const { return PointeeTy; }\n\n  /// Return true if the specified type is valid as a element type.\n  static bool isValidElementType(Type *ElemTy);\n\n  /// Return true if we can load or store from a pointer to this type.\n  static bool isLoadableOrStorableType(Type *ElemTy);\n\n  /// Return the address space of the Pointer type.\n  inline unsigned getAddressSpace() const { return getSubclassData(); }\n\n  /// Implement support type inquiry through isa, cast, and dyn_cast.\n  static bool classof(const Type *T) {\n    return T->getTypeID() == PointerTyID;\n  }\n};\n\nType *Type::getExtendedType() const {\n  assert(\n      isIntOrIntVectorTy() &&\n      \"Original type expected to be a vector of integers or a scalar integer.\");\n  if (auto *VTy = dyn_cast<VectorType>(this))\n    return VectorType::getExtendedElementVectorType(\n        const_cast<VectorType *>(VTy));\n  return cast<IntegerType>(this)->getExtendedType();\n}\n\nType *Type::getWithNewBitWidth(unsigned NewBitWidth) const {\n  assert(\n      isIntOrIntVectorTy() &&\n      \"Original type expected to be a vector of integers or a scalar integer.\");\n  Type *NewType = getIntNTy(getContext(), NewBitWidth);\n  if (auto *VTy = dyn_cast<VectorType>(this))\n    NewType = VectorType::get(NewType, VTy->getElementCount());\n  return NewType;\n}\n\nunsigned Type::getPointerAddressSpace() const {\n  return cast<PointerType>(getScalarType())->getAddressSpace();\n}\n\n} // end namespace llvm\n\n#endif // LLVM_IR_DERIVEDTYPES_H\n"}, "39": {"id": 39, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/IR/Function.h", "content": "//===- llvm/Function.h - Class to represent a single function ---*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// This file contains the declaration of the Function class, which represents a\n// single function/procedure in LLVM.\n//\n// A function basically consists of a list of basic blocks, a list of arguments,\n// and a symbol table.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_IR_FUNCTION_H\n#define LLVM_IR_FUNCTION_H\n\n#include \"llvm/ADT/DenseSet.h\"\n#include \"llvm/ADT/StringRef.h\"\n#include \"llvm/ADT/Twine.h\"\n#include \"llvm/ADT/ilist_node.h\"\n#include \"llvm/ADT/iterator_range.h\"\n#include \"llvm/IR/Argument.h\"\n#include \"llvm/IR/Attributes.h\"\n#include \"llvm/IR/BasicBlock.h\"\n#include \"llvm/IR/CallingConv.h\"\n#include \"llvm/IR/DerivedTypes.h\"\n#include \"llvm/IR/GlobalObject.h\"\n#include \"llvm/IR/GlobalValue.h\"\n#include \"llvm/IR/OperandTraits.h\"\n#include \"llvm/IR/SymbolTableListTraits.h\"\n#include \"llvm/IR/Value.h\"\n#include \"llvm/Support/Casting.h\"\n#include \"llvm/Support/Compiler.h\"\n#include <cassert>\n#include <cstddef>\n#include <cstdint>\n#include <memory>\n#include <string>\n\nnamespace llvm {\n\nnamespace Intrinsic {\ntypedef unsigned ID;\n}\n\nclass AssemblyAnnotationWriter;\nclass Constant;\nclass DISubprogram;\nclass LLVMContext;\nclass Module;\ntemplate <typename T> class Optional;\nclass raw_ostream;\nclass Type;\nclass User;\nclass BranchProbabilityInfo;\nclass BlockFrequencyInfo;\n\nclass Function : public GlobalObject, public ilist_node<Function> {\npublic:\n  using BasicBlockListType = SymbolTableList<BasicBlock>;\n\n  // BasicBlock iterators...\n  using iterator = BasicBlockListType::iterator;\n  using const_iterator = BasicBlockListType::const_iterator;\n\n  using arg_iterator = Argument *;\n  using const_arg_iterator = const Argument *;\n\nprivate:\n  // Important things that make up a function!\n  BasicBlockListType BasicBlocks;         ///< The basic blocks\n  mutable Argument *Arguments = nullptr;  ///< The formal arguments\n  size_t NumArgs;\n  std::unique_ptr<ValueSymbolTable>\n      SymTab;                             ///< Symbol table of args/instructions\n  AttributeList AttributeSets;            ///< Parameter attributes\n\n  /*\n   * Value::SubclassData\n   *\n   * bit 0      : HasLazyArguments\n   * bit 1      : HasPrefixData\n   * bit 2      : HasPrologueData\n   * bit 3      : HasPersonalityFn\n   * bits 4-13  : CallingConvention\n   * bits 14    : HasGC\n   * bits 15 : [reserved]\n   */\n\n  /// Bits from GlobalObject::GlobalObjectSubclassData.\n  enum {\n    /// Whether this function is materializable.\n    IsMaterializableBit = 0,\n  };\n\n  friend class SymbolTableListTraits<Function>;\n\n  /// hasLazyArguments/CheckLazyArguments - The argument list of a function is\n  /// built on demand, so that the list isn't allocated until the first client\n  /// needs it.  The hasLazyArguments predicate returns true if the arg list\n  /// hasn't been set up yet.\npublic:\n  bool hasLazyArguments() const {\n    return getSubclassDataFromValue() & (1<<0);\n  }\n\nprivate:\n  void CheckLazyArguments() const {\n    if (hasLazyArguments())\n      BuildLazyArguments();\n  }\n\n  void BuildLazyArguments() const;\n\n  void clearArguments();\n\n  /// Function ctor - If the (optional) Module argument is specified, the\n  /// function is automatically inserted into the end of the function list for\n  /// the module.\n  ///\n  Function(FunctionType *Ty, LinkageTypes Linkage, unsigned AddrSpace,\n           const Twine &N = \"\", Module *M = nullptr);\n\npublic:\n  Function(const Function&) = delete;\n  void operator=(const Function&) = delete;\n  ~Function();\n\n  // This is here to help easily convert from FunctionT * (Function * or\n  // MachineFunction *) in BlockFrequencyInfoImpl to Function * by calling\n  // FunctionT->getFunction().\n  const Function &getFunction() const { return *this; }\n\n  static Function *Create(FunctionType *Ty, LinkageTypes Linkage,\n                          unsigned AddrSpace, const Twine &N = \"\",\n                          Module *M = nullptr) {\n    return new Function(Ty, Linkage, AddrSpace, N, M);\n  }\n\n  // TODO: remove this once all users have been updated to pass an AddrSpace\n  static Function *Create(FunctionType *Ty, LinkageTypes Linkage,\n                          const Twine &N = \"\", Module *M = nullptr) {\n    return new Function(Ty, Linkage, static_cast<unsigned>(-1), N, M);\n  }\n\n  /// Creates a new function and attaches it to a module.\n  ///\n  /// Places the function in the program address space as specified\n  /// by the module's data layout.\n  static Function *Create(FunctionType *Ty, LinkageTypes Linkage,\n                          const Twine &N, Module &M);\n\n  // Provide fast operand accessors.\n  DECLARE_TRANSPARENT_OPERAND_ACCESSORS(Value);\n\n  /// Returns the number of non-debug IR instructions in this function.\n  /// This is equivalent to the sum of the sizes of each basic block contained\n  /// within this function.\n  unsigned getInstructionCount() const;\n\n  /// Returns the FunctionType for me.\n  FunctionType *getFunctionType() const {\n    return cast<FunctionType>(getValueType());\n  }\n\n  /// Returns the type of the ret val.\n  Type *getReturnType() const { return getFunctionType()->getReturnType(); }\n\n  /// getContext - Return a reference to the LLVMContext associated with this\n  /// function.\n  LLVMContext &getContext() const;\n\n  /// isVarArg - Return true if this function takes a variable number of\n  /// arguments.\n  bool isVarArg() const { return getFunctionType()->isVarArg(); }\n\n  bool isMaterializable() const {\n    return getGlobalObjectSubClassData() & (1 << IsMaterializableBit);\n  }\n  void setIsMaterializable(bool V) {\n    unsigned Mask = 1 << IsMaterializableBit;\n    setGlobalObjectSubClassData((~Mask & getGlobalObjectSubClassData()) |\n                                (V ? Mask : 0u));\n  }\n\n  /// getIntrinsicID - This method returns the ID number of the specified\n  /// function, or Intrinsic::not_intrinsic if the function is not an\n  /// intrinsic, or if the pointer is null.  This value is always defined to be\n  /// zero to allow easy checking for whether a function is intrinsic or not.\n  /// The particular intrinsic functions which correspond to this value are\n  /// defined in llvm/Intrinsics.h.\n  Intrinsic::ID getIntrinsicID() const LLVM_READONLY { return IntID; }\n\n  /// isIntrinsic - Returns true if the function's name starts with \"llvm.\".\n  /// It's possible for this function to return true while getIntrinsicID()\n  /// returns Intrinsic::not_intrinsic!\n  bool isIntrinsic() const { return HasLLVMReservedName; }\n\n  /// isTargetIntrinsic - Returns true if IID is an intrinsic specific to a\n  /// certain target. If it is a generic intrinsic false is returned.\n  static bool isTargetIntrinsic(Intrinsic::ID IID);\n\n  /// isTargetIntrinsic - Returns true if this function is an intrinsic and the\n  /// intrinsic is specific to a certain target. If this is not an intrinsic\n  /// or a generic intrinsic, false is returned.\n  bool isTargetIntrinsic() const;\n\n  /// Returns true if the function is one of the \"Constrained Floating-Point\n  /// Intrinsics\". Returns false if not, and returns false when\n  /// getIntrinsicID() returns Intrinsic::not_intrinsic.\n  bool isConstrainedFPIntrinsic() const;\n\n  static Intrinsic::ID lookupIntrinsicID(StringRef Name);\n\n  /// Recalculate the ID for this function if it is an Intrinsic defined\n  /// in llvm/Intrinsics.h.  Sets the intrinsic ID to Intrinsic::not_intrinsic\n  /// if the name of this function does not match an intrinsic in that header.\n  /// Note, this method does not need to be called directly, as it is called\n  /// from Value::setName() whenever the name of this function changes.\n  void recalculateIntrinsicID();\n\n  /// getCallingConv()/setCallingConv(CC) - These method get and set the\n  /// calling convention of this function.  The enum values for the known\n  /// calling conventions are defined in CallingConv.h.\n  CallingConv::ID getCallingConv() const {\n    return static_cast<CallingConv::ID>((getSubclassDataFromValue() >> 4) &\n                                        CallingConv::MaxID);\n  }\n  void setCallingConv(CallingConv::ID CC) {\n    auto ID = static_cast<unsigned>(CC);\n    assert(!(ID & ~CallingConv::MaxID) && \"Unsupported calling convention\");\n    setValueSubclassData((getSubclassDataFromValue() & 0xc00f) | (ID << 4));\n  }\n\n  /// Return the attribute list for this Function.\n  AttributeList getAttributes() const { return AttributeSets; }\n\n  /// Set the attribute list for this Function.\n  void setAttributes(AttributeList Attrs) { AttributeSets = Attrs; }\n\n  /// Add function attributes to this function.\n  void addFnAttr(Attribute::AttrKind Kind) {\n    addAttribute(AttributeList::FunctionIndex, Kind);\n  }\n\n  /// Add function attributes to this function.\n  void addFnAttr(StringRef Kind, StringRef Val = StringRef()) {\n    addAttribute(AttributeList::FunctionIndex,\n                 Attribute::get(getContext(), Kind, Val));\n  }\n\n  /// Add function attributes to this function.\n  void addFnAttr(Attribute Attr) {\n    addAttribute(AttributeList::FunctionIndex, Attr);\n  }\n\n  /// Remove function attributes from this function.\n  void removeFnAttr(Attribute::AttrKind Kind) {\n    removeAttribute(AttributeList::FunctionIndex, Kind);\n  }\n\n  /// Remove function attribute from this function.\n  void removeFnAttr(StringRef Kind) {\n    setAttributes(getAttributes().removeAttribute(\n        getContext(), AttributeList::FunctionIndex, Kind));\n  }\n\n  /// A function will have the \"coroutine.presplit\" attribute if it's\n  /// a coroutine and has not gone through full CoroSplit pass.\n  bool isPresplitCoroutine() const {\n    return hasFnAttribute(\"coroutine.presplit\");\n  }\n\n  enum ProfileCountType { PCT_Invalid, PCT_Real, PCT_Synthetic };\n\n  /// Class to represent profile counts.\n  ///\n  /// This class represents both real and synthetic profile counts.\n  class ProfileCount {\n  private:\n    uint64_t Count;\n    ProfileCountType PCT;\n    static ProfileCount Invalid;\n\n  public:\n    ProfileCount() : Count(-1), PCT(PCT_Invalid) {}\n    ProfileCount(uint64_t Count, ProfileCountType PCT)\n        : Count(Count), PCT(PCT) {}\n    bool hasValue() const { return PCT != PCT_Invalid; }\n    uint64_t getCount() const { return Count; }\n    ProfileCountType getType() const { return PCT; }\n    bool isSynthetic() const { return PCT == PCT_Synthetic; }\n    explicit operator bool() { return hasValue(); }\n    bool operator!() const { return !hasValue(); }\n    // Update the count retaining the same profile count type.\n    ProfileCount &setCount(uint64_t C) {\n      Count = C;\n      return *this;\n    }\n    static ProfileCount getInvalid() { return ProfileCount(-1, PCT_Invalid); }\n  };\n\n  /// Set the entry count for this function.\n  ///\n  /// Entry count is the number of times this function was executed based on\n  /// pgo data. \\p Imports points to a set of GUIDs that needs to\n  /// be imported by the function for sample PGO, to enable the same inlines as\n  /// the profiled optimized binary.\n  void setEntryCount(ProfileCount Count,\n                     const DenseSet<GlobalValue::GUID> *Imports = nullptr);\n\n  /// A convenience wrapper for setting entry count\n  void setEntryCount(uint64_t Count, ProfileCountType Type = PCT_Real,\n                     const DenseSet<GlobalValue::GUID> *Imports = nullptr);\n\n  /// Get the entry count for this function.\n  ///\n  /// Entry count is the number of times the function was executed.\n  /// When AllowSynthetic is false, only pgo_data will be returned.\n  ProfileCount getEntryCount(bool AllowSynthetic = false) const;\n\n  /// Return true if the function is annotated with profile data.\n  ///\n  /// Presence of entry counts from a profile run implies the function has\n  /// profile annotations. If IncludeSynthetic is false, only return true\n  /// when the profile data is real.\n  bool hasProfileData(bool IncludeSynthetic = false) const {\n    return getEntryCount(IncludeSynthetic).hasValue();\n  }\n\n  /// Returns the set of GUIDs that needs to be imported to the function for\n  /// sample PGO, to enable the same inlines as the profiled optimized binary.\n  DenseSet<GlobalValue::GUID> getImportGUIDs() const;\n\n  /// Set the section prefix for this function.\n  void setSectionPrefix(StringRef Prefix);\n\n  /// Get the section prefix for this function.\n  Optional<StringRef> getSectionPrefix() const;\n\n  /// Return true if the function has the attribute.\n  bool hasFnAttribute(Attribute::AttrKind Kind) const {\n    return AttributeSets.hasFnAttribute(Kind);\n  }\n\n  /// Return true if the function has the attribute.\n  bool hasFnAttribute(StringRef Kind) const {\n    return AttributeSets.hasFnAttribute(Kind);\n  }\n\n  /// Return the attribute for the given attribute kind.\n  Attribute getFnAttribute(Attribute::AttrKind Kind) const {\n    return getAttribute(AttributeList::FunctionIndex, Kind);\n  }\n\n  /// Return the attribute for the given attribute kind.\n  Attribute getFnAttribute(StringRef Kind) const {\n    return getAttribute(AttributeList::FunctionIndex, Kind);\n  }\n\n  /// Return the stack alignment for the function.\n  unsigned getFnStackAlignment() const {\n    if (!hasFnAttribute(Attribute::StackAlignment))\n      return 0;\n    if (const auto MA =\n            AttributeSets.getStackAlignment(AttributeList::FunctionIndex))\n      return MA->value();\n    return 0;\n  }\n\n  /// Return the stack alignment for the function.\n  MaybeAlign getFnStackAlign() const {\n    if (!hasFnAttribute(Attribute::StackAlignment))\n      return None;\n    return AttributeSets.getStackAlignment(AttributeList::FunctionIndex);\n  }\n\n  /// hasGC/getGC/setGC/clearGC - The name of the garbage collection algorithm\n  ///                             to use during code generation.\n  bool hasGC() const {\n    return getSubclassDataFromValue() & (1<<14);\n  }\n  const std::string &getGC() const;\n  void setGC(std::string Str);\n  void clearGC();\n\n  /// Returns true if the function has ssp, sspstrong, or sspreq fn attrs.\n  bool hasStackProtectorFnAttr() const;\n\n  /// adds the attribute to the list of attributes.\n  void addAttribute(unsigned i, Attribute::AttrKind Kind);\n\n  /// adds the attribute to the list of attributes.\n  void addAttribute(unsigned i, Attribute Attr);\n\n  /// adds the attributes to the list of attributes.\n  void addAttributes(unsigned i, const AttrBuilder &Attrs);\n\n  /// adds the attribute to the list of attributes for the given arg.\n  void addParamAttr(unsigned ArgNo, Attribute::AttrKind Kind);\n\n  /// adds the attribute to the list of attributes for the given arg.\n  void addParamAttr(unsigned ArgNo, Attribute Attr);\n\n  /// adds the attributes to the list of attributes for the given arg.\n  void addParamAttrs(unsigned ArgNo, const AttrBuilder &Attrs);\n\n  /// removes the attribute from the list of attributes.\n  void removeAttribute(unsigned i, Attribute::AttrKind Kind);\n\n  /// removes the attribute from the list of attributes.\n  void removeAttribute(unsigned i, StringRef Kind);\n\n  /// removes the attributes from the list of attributes.\n  void removeAttributes(unsigned i, const AttrBuilder &Attrs);\n\n  /// removes the attribute from the list of attributes.\n  void removeParamAttr(unsigned ArgNo, Attribute::AttrKind Kind);\n\n  /// removes the attribute from the list of attributes.\n  void removeParamAttr(unsigned ArgNo, StringRef Kind);\n\n  /// removes the attribute from the list of attributes.\n  void removeParamAttrs(unsigned ArgNo, const AttrBuilder &Attrs);\n\n  /// check if an attributes is in the list of attributes.\n  bool hasAttribute(unsigned i, Attribute::AttrKind Kind) const {\n    return getAttributes().hasAttribute(i, Kind);\n  }\n\n  /// check if an attributes is in the list of attributes.\n  bool hasParamAttribute(unsigned ArgNo, Attribute::AttrKind Kind) const {\n    return getAttributes().hasParamAttribute(ArgNo, Kind);\n  }\n\n  /// gets the specified attribute from the list of attributes.\n  Attribute getParamAttribute(unsigned ArgNo, Attribute::AttrKind Kind) const {\n    return getAttributes().getParamAttr(ArgNo, Kind);\n  }\n\n  /// gets the attribute from the list of attributes.\n  Attribute getAttribute(unsigned i, Attribute::AttrKind Kind) const {\n    return AttributeSets.getAttribute(i, Kind);\n  }\n\n  /// gets the attribute from the list of attributes.\n  Attribute getAttribute(unsigned i, StringRef Kind) const {\n    return AttributeSets.getAttribute(i, Kind);\n  }\n\n  /// adds the dereferenceable attribute to the list of attributes.\n  void addDereferenceableAttr(unsigned i, uint64_t Bytes);\n\n  /// adds the dereferenceable attribute to the list of attributes for\n  /// the given arg.\n  void addDereferenceableParamAttr(unsigned ArgNo, uint64_t Bytes);\n\n  /// adds the dereferenceable_or_null attribute to the list of\n  /// attributes.\n  void addDereferenceableOrNullAttr(unsigned i, uint64_t Bytes);\n\n  /// adds the dereferenceable_or_null attribute to the list of\n  /// attributes for the given arg.\n  void addDereferenceableOrNullParamAttr(unsigned ArgNo, uint64_t Bytes);\n\n  /// Extract the alignment for a call or parameter (0=unknown).\n  /// FIXME: Remove this function once transition to Align is over.\n  /// Use getParamAlign() instead.\n  unsigned getParamAlignment(unsigned ArgNo) const {\n    if (const auto MA = getParamAlign(ArgNo))\n      return MA->value();\n    return 0;\n  }\n\n  MaybeAlign getParamAlign(unsigned ArgNo) const {\n    return AttributeSets.getParamAlignment(ArgNo);\n  }\n\n  /// Extract the byval type for a parameter.\n  Type *getParamByValType(unsigned ArgNo) const {\n    return AttributeSets.getParamByValType(ArgNo);\n  }\n\n  /// Extract the sret type for a parameter.\n  Type *getParamStructRetType(unsigned ArgNo) const {\n    return AttributeSets.getParamStructRetType(ArgNo);\n  }\n\n  /// Extract the byref type for a parameter.\n  Type *getParamByRefType(unsigned ArgNo) const {\n    return AttributeSets.getParamByRefType(ArgNo);\n  }\n\n  /// Extract the number of dereferenceable bytes for a call or\n  /// parameter (0=unknown).\n  /// @param i AttributeList index, referring to a return value or argument.\n  uint64_t getDereferenceableBytes(unsigned i) const {\n    return AttributeSets.getDereferenceableBytes(i);\n  }\n\n  /// Extract the number of dereferenceable bytes for a parameter.\n  /// @param ArgNo Index of an argument, with 0 being the first function arg.\n  uint64_t getParamDereferenceableBytes(unsigned ArgNo) const {\n    return AttributeSets.getParamDereferenceableBytes(ArgNo);\n  }\n\n  /// Extract the number of dereferenceable_or_null bytes for a call or\n  /// parameter (0=unknown).\n  /// @param i AttributeList index, referring to a return value or argument.\n  uint64_t getDereferenceableOrNullBytes(unsigned i) const {\n    return AttributeSets.getDereferenceableOrNullBytes(i);\n  }\n\n  /// Extract the number of dereferenceable_or_null bytes for a\n  /// parameter.\n  /// @param ArgNo AttributeList ArgNo, referring to an argument.\n  uint64_t getParamDereferenceableOrNullBytes(unsigned ArgNo) const {\n    return AttributeSets.getParamDereferenceableOrNullBytes(ArgNo);\n  }\n\n  /// Determine if the function does not access memory.\n  bool doesNotAccessMemory() const {\n    return hasFnAttribute(Attribute::ReadNone);\n  }\n  void setDoesNotAccessMemory() {\n    addFnAttr(Attribute::ReadNone);\n  }\n\n  /// Determine if the function does not access or only reads memory.\n  bool onlyReadsMemory() const {\n    return doesNotAccessMemory() || hasFnAttribute(Attribute::ReadOnly);\n  }\n  void setOnlyReadsMemory() {\n    addFnAttr(Attribute::ReadOnly);\n  }\n\n  /// Determine if the function does not access or only writes memory.\n  bool doesNotReadMemory() const {\n    return doesNotAccessMemory() || hasFnAttribute(Attribute::WriteOnly);\n  }\n  void setDoesNotReadMemory() {\n    addFnAttr(Attribute::WriteOnly);\n  }\n\n  /// Determine if the call can access memmory only using pointers based\n  /// on its arguments.\n  bool onlyAccessesArgMemory() const {\n    return hasFnAttribute(Attribute::ArgMemOnly);\n  }\n  void setOnlyAccessesArgMemory() { addFnAttr(Attribute::ArgMemOnly); }\n\n  /// Determine if the function may only access memory that is\n  ///  inaccessible from the IR.\n  bool onlyAccessesInaccessibleMemory() const {\n    return hasFnAttribute(Attribute::InaccessibleMemOnly);\n  }\n  void setOnlyAccessesInaccessibleMemory() {\n    addFnAttr(Attribute::InaccessibleMemOnly);\n  }\n\n  /// Determine if the function may only access memory that is\n  ///  either inaccessible from the IR or pointed to by its arguments.\n  bool onlyAccessesInaccessibleMemOrArgMem() const {\n    return hasFnAttribute(Attribute::InaccessibleMemOrArgMemOnly);\n  }\n  void setOnlyAccessesInaccessibleMemOrArgMem() {\n    addFnAttr(Attribute::InaccessibleMemOrArgMemOnly);\n  }\n\n  /// Determine if the function cannot return.\n  bool doesNotReturn() const {\n    return hasFnAttribute(Attribute::NoReturn);\n  }\n  void setDoesNotReturn() {\n    addFnAttr(Attribute::NoReturn);\n  }\n\n  /// Determine if the function should not perform indirect branch tracking.\n  bool doesNoCfCheck() const { return hasFnAttribute(Attribute::NoCfCheck); }\n\n  /// Determine if the function cannot unwind.\n  bool doesNotThrow() const {\n    return hasFnAttribute(Attribute::NoUnwind);\n  }\n  void setDoesNotThrow() {\n    addFnAttr(Attribute::NoUnwind);\n  }\n\n  /// Determine if the call cannot be duplicated.\n  bool cannotDuplicate() const {\n    return hasFnAttribute(Attribute::NoDuplicate);\n  }\n  void setCannotDuplicate() {\n    addFnAttr(Attribute::NoDuplicate);\n  }\n\n  /// Determine if the call is convergent.\n  bool isConvergent() const {\n    return hasFnAttribute(Attribute::Convergent);\n  }\n  void setConvergent() {\n    addFnAttr(Attribute::Convergent);\n  }\n  void setNotConvergent() {\n    removeFnAttr(Attribute::Convergent);\n  }\n\n  /// Determine if the call has sideeffects.\n  bool isSpeculatable() const {\n    return hasFnAttribute(Attribute::Speculatable);\n  }\n  void setSpeculatable() {\n    addFnAttr(Attribute::Speculatable);\n  }\n\n  /// Determine if the call might deallocate memory.\n  bool doesNotFreeMemory() const {\n    return onlyReadsMemory() || hasFnAttribute(Attribute::NoFree);\n  }\n  void setDoesNotFreeMemory() {\n    addFnAttr(Attribute::NoFree);\n  }\n\n  /// Determine if the function is known not to recurse, directly or\n  /// indirectly.\n  bool doesNotRecurse() const {\n    return hasFnAttribute(Attribute::NoRecurse);\n  }\n  void setDoesNotRecurse() {\n    addFnAttr(Attribute::NoRecurse);\n  }\n\n  /// Determine if the function is required to make forward progress.\n  bool mustProgress() const {\n    return hasFnAttribute(Attribute::MustProgress) ||\n           hasFnAttribute(Attribute::WillReturn);\n  }\n  void setMustProgress() { addFnAttr(Attribute::MustProgress); }\n\n  /// Determine if the function will return.\n  bool willReturn() const { return hasFnAttribute(Attribute::WillReturn); }\n  void setWillReturn() { addFnAttr(Attribute::WillReturn); }\n\n  /// True if the ABI mandates (or the user requested) that this\n  /// function be in a unwind table.\n  bool hasUWTable() const {\n    return hasFnAttribute(Attribute::UWTable);\n  }\n  void setHasUWTable() {\n    addFnAttr(Attribute::UWTable);\n  }\n\n  /// True if this function needs an unwind table.\n  bool needsUnwindTableEntry() const {\n    return hasUWTable() || !doesNotThrow() || hasPersonalityFn();\n  }\n\n  /// Determine if the function returns a structure through first\n  /// or second pointer argument.\n  bool hasStructRetAttr() const {\n    return AttributeSets.hasParamAttribute(0, Attribute::StructRet) ||\n           AttributeSets.hasParamAttribute(1, Attribute::StructRet);\n  }\n\n  /// Determine if the parameter or return value is marked with NoAlias\n  /// attribute.\n  bool returnDoesNotAlias() const {\n    return AttributeSets.hasAttribute(AttributeList::ReturnIndex,\n                                      Attribute::NoAlias);\n  }\n  void setReturnDoesNotAlias() {\n    addAttribute(AttributeList::ReturnIndex, Attribute::NoAlias);\n  }\n\n  /// Do not optimize this function (-O0).\n  bool hasOptNone() const { return hasFnAttribute(Attribute::OptimizeNone); }\n\n  /// Optimize this function for minimum size (-Oz).\n  bool hasMinSize() const { return hasFnAttribute(Attribute::MinSize); }\n\n  /// Optimize this function for size (-Os) or minimum size (-Oz).\n  bool hasOptSize() const {\n    return hasFnAttribute(Attribute::OptimizeForSize) || hasMinSize();\n  }\n\n  /// Returns the denormal handling type for the default rounding mode of the\n  /// function.\n  DenormalMode getDenormalMode(const fltSemantics &FPType) const;\n\n  /// copyAttributesFrom - copy all additional attributes (those not needed to\n  /// create a Function) from the Function Src to this one.\n  void copyAttributesFrom(const Function *Src);\n\n  /// deleteBody - This method deletes the body of the function, and converts\n  /// the linkage to external.\n  ///\n  void deleteBody() {\n    dropAllReferences();\n    setLinkage(ExternalLinkage);\n  }\n\n  /// removeFromParent - This method unlinks 'this' from the containing module,\n  /// but does not delete it.\n  ///\n  void removeFromParent();\n\n  /// eraseFromParent - This method unlinks 'this' from the containing module\n  /// and deletes it.\n  ///\n  void eraseFromParent();\n\n  /// Steal arguments from another function.\n  ///\n  /// Drop this function's arguments and splice in the ones from \\c Src.\n  /// Requires that this has no function body.\n  void stealArgumentListFrom(Function &Src);\n\n  /// Get the underlying elements of the Function... the basic block list is\n  /// empty for external functions.\n  ///\n  const BasicBlockListType &getBasicBlockList() const { return BasicBlocks; }\n        BasicBlockListType &getBasicBlockList()       { return BasicBlocks; }\n\n  static BasicBlockListType Function::*getSublistAccess(BasicBlock*) {\n    return &Function::BasicBlocks;\n  }\n\n  const BasicBlock       &getEntryBlock() const   { return front(); }\n        BasicBlock       &getEntryBlock()         { return front(); }\n\n  //===--------------------------------------------------------------------===//\n  // Symbol Table Accessing functions...\n\n  /// getSymbolTable() - Return the symbol table if any, otherwise nullptr.\n  ///\n  inline ValueSymbolTable *getValueSymbolTable() { return SymTab.get(); }\n  inline const ValueSymbolTable *getValueSymbolTable() const {\n    return SymTab.get();\n  }\n\n  //===--------------------------------------------------------------------===//\n  // BasicBlock iterator forwarding functions\n  //\n  iterator                begin()       { return BasicBlocks.begin(); }\n  const_iterator          begin() const { return BasicBlocks.begin(); }\n  iterator                end  ()       { return BasicBlocks.end();   }\n  const_iterator          end  () const { return BasicBlocks.end();   }\n\n  size_t                   size() const { return BasicBlocks.size();  }\n  bool                    empty() const { return BasicBlocks.empty(); }\n  const BasicBlock       &front() const { return BasicBlocks.front(); }\n        BasicBlock       &front()       { return BasicBlocks.front(); }\n  const BasicBlock        &back() const { return BasicBlocks.back();  }\n        BasicBlock        &back()       { return BasicBlocks.back();  }\n\n/// @name Function Argument Iteration\n/// @{\n\n  arg_iterator arg_begin() {\n    CheckLazyArguments();\n    return Arguments;\n  }\n  const_arg_iterator arg_begin() const {\n    CheckLazyArguments();\n    return Arguments;\n  }\n\n  arg_iterator arg_end() {\n    CheckLazyArguments();\n    return Arguments + NumArgs;\n  }\n  const_arg_iterator arg_end() const {\n    CheckLazyArguments();\n    return Arguments + NumArgs;\n  }\n\n  Argument* getArg(unsigned i) const {\n    assert (i < NumArgs && \"getArg() out of range!\");\n    CheckLazyArguments();\n    return Arguments + i;\n  }\n\n  iterator_range<arg_iterator> args() {\n    return make_range(arg_begin(), arg_end());\n  }\n  iterator_range<const_arg_iterator> args() const {\n    return make_range(arg_begin(), arg_end());\n  }\n\n/// @}\n\n  size_t arg_size() const { return NumArgs; }\n  bool arg_empty() const { return arg_size() == 0; }\n\n  /// Check whether this function has a personality function.\n  bool hasPersonalityFn() const {\n    return getSubclassDataFromValue() & (1<<3);\n  }\n\n  /// Get the personality function associated with this function.\n  Constant *getPersonalityFn() const;\n  void setPersonalityFn(Constant *Fn);\n\n  /// Check whether this function has prefix data.\n  bool hasPrefixData() const {\n    return getSubclassDataFromValue() & (1<<1);\n  }\n\n  /// Get the prefix data associated with this function.\n  Constant *getPrefixData() const;\n  void setPrefixData(Constant *PrefixData);\n\n  /// Check whether this function has prologue data.\n  bool hasPrologueData() const {\n    return getSubclassDataFromValue() & (1<<2);\n  }\n\n  /// Get the prologue data associated with this function.\n  Constant *getPrologueData() const;\n  void setPrologueData(Constant *PrologueData);\n\n  /// Print the function to an output stream with an optional\n  /// AssemblyAnnotationWriter.\n  void print(raw_ostream &OS, AssemblyAnnotationWriter *AAW = nullptr,\n             bool ShouldPreserveUseListOrder = false,\n             bool IsForDebug = false) const;\n\n  /// viewCFG - This function is meant for use from the debugger.  You can just\n  /// say 'call F->viewCFG()' and a ghostview window should pop up from the\n  /// program, displaying the CFG of the current function with the code for each\n  /// basic block inside.  This depends on there being a 'dot' and 'gv' program\n  /// in your path.\n  ///\n  void viewCFG() const;\n\n  /// Extended form to print edge weights.\n  void viewCFG(bool ViewCFGOnly, const BlockFrequencyInfo *BFI,\n               const BranchProbabilityInfo *BPI) const;\n\n  /// viewCFGOnly - This function is meant for use from the debugger.  It works\n  /// just like viewCFG, but it does not include the contents of basic blocks\n  /// into the nodes, just the label.  If you are only interested in the CFG\n  /// this can make the graph smaller.\n  ///\n  void viewCFGOnly() const;\n\n  /// Extended form to print edge weights.\n  void viewCFGOnly(const BlockFrequencyInfo *BFI,\n                   const BranchProbabilityInfo *BPI) const;\n\n  /// Methods for support type inquiry through isa, cast, and dyn_cast:\n  static bool classof(const Value *V) {\n    return V->getValueID() == Value::FunctionVal;\n  }\n\n  /// dropAllReferences() - This method causes all the subinstructions to \"let\n  /// go\" of all references that they are maintaining.  This allows one to\n  /// 'delete' a whole module at a time, even though there may be circular\n  /// references... first all references are dropped, and all use counts go to\n  /// zero.  Then everything is deleted for real.  Note that no operations are\n  /// valid on an object that has \"dropped all references\", except operator\n  /// delete.\n  ///\n  /// Since no other object in the module can have references into the body of a\n  /// function, dropping all references deletes the entire body of the function,\n  /// including any contained basic blocks.\n  ///\n  void dropAllReferences();\n\n  /// hasAddressTaken - returns true if there are any uses of this function\n  /// other than direct calls or invokes to it, or blockaddress expressions.\n  /// Optionally passes back an offending user for diagnostic purposes,\n  /// ignores callback uses, assume like pointer annotation calls, and\n  /// references in llvm.used and llvm.compiler.used variables.\n  ///\n  bool hasAddressTaken(const User ** = nullptr,\n                       bool IgnoreCallbackUses = false,\n                       bool IgnoreAssumeLikeCalls = false,\n                       bool IngoreLLVMUsed = false) const;\n\n  /// isDefTriviallyDead - Return true if it is trivially safe to remove\n  /// this function definition from the module (because it isn't externally\n  /// visible, does not have its address taken, and has no callers).  To make\n  /// this more accurate, call removeDeadConstantUsers first.\n  bool isDefTriviallyDead() const;\n\n  /// callsFunctionThatReturnsTwice - Return true if the function has a call to\n  /// setjmp or other function that gcc recognizes as \"returning twice\".\n  bool callsFunctionThatReturnsTwice() const;\n\n  /// Set the attached subprogram.\n  ///\n  /// Calls \\a setMetadata() with \\a LLVMContext::MD_dbg.\n  void setSubprogram(DISubprogram *SP);\n\n  /// Get the attached subprogram.\n  ///\n  /// Calls \\a getMetadata() with \\a LLVMContext::MD_dbg and casts the result\n  /// to \\a DISubprogram.\n  DISubprogram *getSubprogram() const;\n\n  /// Returns true if we should emit debug info for profiling.\n  bool isDebugInfoForProfiling() const;\n\n  /// Check if null pointer dereferencing is considered undefined behavior for\n  /// the function.\n  /// Return value: false => null pointer dereference is undefined.\n  /// Return value: true =>  null pointer dereference is not undefined.\n  bool nullPointerIsDefined() const;\n\nprivate:\n  void allocHungoffUselist();\n  template<int Idx> void setHungoffOperand(Constant *C);\n\n  /// Shadow Value::setValueSubclassData with a private forwarding method so\n  /// that subclasses cannot accidentally use it.\n  void setValueSubclassData(unsigned short D) {\n    Value::setValueSubclassData(D);\n  }\n  void setValueSubclassDataBit(unsigned Bit, bool On);\n};\n\n/// Check whether null pointer dereferencing is considered undefined behavior\n/// for a given function or an address space.\n/// Null pointer access in non-zero address space is not considered undefined.\n/// Return value: false => null pointer dereference is undefined.\n/// Return value: true =>  null pointer dereference is not undefined.\nbool NullPointerIsDefined(const Function *F, unsigned AS = 0);\n\ntemplate <>\nstruct OperandTraits<Function> : public HungoffOperandTraits<3> {};\n\nDEFINE_TRANSPARENT_OPERAND_ACCESSORS(Function, Value)\n\n} // end namespace llvm\n\n#endif // LLVM_IR_FUNCTION_H\n"}, "40": {"id": 40, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/IR/GlobalObject.h", "content": "//===-- llvm/GlobalObject.h - Class to represent global objects -*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// This represents an independent object. That is, a function or a global\n// variable, but not an alias.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_IR_GLOBALOBJECT_H\n#define LLVM_IR_GLOBALOBJECT_H\n\n#include \"llvm/ADT/StringRef.h\"\n#include \"llvm/IR/GlobalValue.h\"\n#include \"llvm/IR/Value.h\"\n#include \"llvm/Support/Alignment.h\"\n#include <string>\n#include <utility>\n\nnamespace llvm {\n\nclass Comdat;\nclass MDNode;\nclass Metadata;\n\nclass GlobalObject : public GlobalValue {\npublic:\n  // VCallVisibility - values for visibility metadata attached to vtables. This\n  // describes the scope in which a virtual call could end up being dispatched\n  // through this vtable.\n  enum VCallVisibility {\n    // Type is potentially visible to external code.\n    VCallVisibilityPublic = 0,\n    // Type is only visible to code which will be in the current Module after\n    // LTO internalization.\n    VCallVisibilityLinkageUnit = 1,\n    // Type is only visible to code in the current Module.\n    VCallVisibilityTranslationUnit = 2,\n  };\n\nprotected:\n  GlobalObject(Type *Ty, ValueTy VTy, Use *Ops, unsigned NumOps,\n               LinkageTypes Linkage, const Twine &Name,\n               unsigned AddressSpace = 0)\n      : GlobalValue(Ty, VTy, Ops, NumOps, Linkage, Name, AddressSpace),\n        ObjComdat(nullptr) {\n    setGlobalValueSubClassData(0);\n  }\n\n  Comdat *ObjComdat;\n  enum {\n    LastAlignmentBit = 4,\n    HasSectionHashEntryBit,\n\n    GlobalObjectBits,\n  };\n  static const unsigned GlobalObjectSubClassDataBits =\n      GlobalValueSubClassDataBits - GlobalObjectBits;\n\nprivate:\n  static const unsigned AlignmentBits = LastAlignmentBit + 1;\n  static const unsigned AlignmentMask = (1 << AlignmentBits) - 1;\n  static const unsigned GlobalObjectMask = (1 << GlobalObjectBits) - 1;\n\npublic:\n  GlobalObject(const GlobalObject &) = delete;\n\n  /// FIXME: Remove this function once transition to Align is over.\n  unsigned getAlignment() const {\n    MaybeAlign Align = getAlign();\n    return Align ? Align->value() : 0;\n  }\n\n  /// Returns the alignment of the given variable or function.\n  ///\n  /// Note that for functions this is the alignment of the code, not the\n  /// alignment of a function pointer.\n  MaybeAlign getAlign() const {\n    unsigned Data = getGlobalValueSubClassData();\n    unsigned AlignmentData = Data & AlignmentMask;\n    return decodeMaybeAlign(AlignmentData);\n  }\n\n  void setAlignment(MaybeAlign Align);\n\n  unsigned getGlobalObjectSubClassData() const {\n    unsigned ValueData = getGlobalValueSubClassData();\n    return ValueData >> GlobalObjectBits;\n  }\n\n  void setGlobalObjectSubClassData(unsigned Val) {\n    unsigned OldData = getGlobalValueSubClassData();\n    setGlobalValueSubClassData((OldData & GlobalObjectMask) |\n                               (Val << GlobalObjectBits));\n    assert(getGlobalObjectSubClassData() == Val && \"representation error\");\n  }\n\n  /// Check if this global has a custom object file section.\n  ///\n  /// This is more efficient than calling getSection() and checking for an empty\n  /// string.\n  bool hasSection() const {\n    return getGlobalValueSubClassData() & (1 << HasSectionHashEntryBit);\n  }\n\n  /// Get the custom section of this global if it has one.\n  ///\n  /// If this global does not have a custom section, this will be empty and the\n  /// default object file section (.text, .data, etc) will be used.\n  StringRef getSection() const {\n    return hasSection() ? getSectionImpl() : StringRef();\n  }\n\n  /// Change the section for this global.\n  ///\n  /// Setting the section to the empty string tells LLVM to choose an\n  /// appropriate default object file section.\n  void setSection(StringRef S);\n\n  bool hasComdat() const { return getComdat() != nullptr; }\n  const Comdat *getComdat() const { return ObjComdat; }\n  Comdat *getComdat() { return ObjComdat; }\n  void setComdat(Comdat *C) { ObjComdat = C; }\n\n  using Value::addMetadata;\n  using Value::clearMetadata;\n  using Value::eraseMetadata;\n  using Value::getAllMetadata;\n  using Value::getMetadata;\n  using Value::hasMetadata;\n  using Value::setMetadata;\n\n  /// Copy metadata from Src, adjusting offsets by Offset.\n  void copyMetadata(const GlobalObject *Src, unsigned Offset);\n\n  void addTypeMetadata(unsigned Offset, Metadata *TypeID);\n  void setVCallVisibilityMetadata(VCallVisibility Visibility);\n  VCallVisibility getVCallVisibility() const;\n\n  /// Returns true if the alignment of the value can be unilaterally\n  /// increased.\n  ///\n  /// Note that for functions this is the alignment of the code, not the\n  /// alignment of a function pointer.\n  bool canIncreaseAlignment() const;\n\nprotected:\n  void copyAttributesFrom(const GlobalObject *Src);\n\npublic:\n  // Methods for support type inquiry through isa, cast, and dyn_cast:\n  static bool classof(const Value *V) {\n    return V->getValueID() == Value::FunctionVal ||\n           V->getValueID() == Value::GlobalVariableVal;\n  }\n\nprivate:\n  void setGlobalObjectFlag(unsigned Bit, bool Val) {\n    unsigned Mask = 1 << Bit;\n    setGlobalValueSubClassData((~Mask & getGlobalValueSubClassData()) |\n                               (Val ? Mask : 0u));\n  }\n\n  StringRef getSectionImpl() const;\n};\n\n} // end namespace llvm\n\n#endif // LLVM_IR_GLOBALOBJECT_H\n"}, "41": {"id": 41, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/IR/Intrinsics.h", "content": "//===- Intrinsics.h - LLVM Intrinsic Function Handling ----------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// This file defines a set of enums which allow processing of intrinsic\n// functions.  Values of these enum types are returned by\n// Function::getIntrinsicID.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_IR_INTRINSICS_H\n#define LLVM_IR_INTRINSICS_H\n\n#include \"llvm/ADT/ArrayRef.h\"\n#include \"llvm/ADT/None.h\"\n#include \"llvm/ADT/Optional.h\"\n#include \"llvm/Support/TypeSize.h\"\n#include <string>\n\nnamespace llvm {\n\nclass Type;\nclass FunctionType;\nclass Function;\nclass LLVMContext;\nclass Module;\nclass AttributeList;\n\n/// This namespace contains an enum with a value for every intrinsic/builtin\n/// function known by LLVM. The enum values are returned by\n/// Function::getIntrinsicID().\nnamespace Intrinsic {\n  // Abstraction for the arguments of the noalias intrinsics\n  static const int NoAliasScopeDeclScopeArg = 0;\n\n  // Intrinsic ID type. This is an opaque typedef to facilitate splitting up\n  // the enum into target-specific enums.\n  typedef unsigned ID;\n\n  enum IndependentIntrinsics : unsigned {\n    not_intrinsic = 0, // Must be zero\n\n  // Get the intrinsic enums generated from Intrinsics.td\n#define GET_INTRINSIC_ENUM_VALUES\n#include \"llvm/IR/IntrinsicEnums.inc\"\n#undef GET_INTRINSIC_ENUM_VALUES\n  };\n\n  /// Return the LLVM name for an intrinsic, such as \"llvm.ppc.altivec.lvx\".\n  /// Note, this version is for intrinsics with no overloads.  Use the other\n  /// version of getName if overloads are required.\n  StringRef getName(ID id);\n\n  /// Return the LLVM name for an intrinsic, such as \"llvm.ppc.altivec.lvx\".\n  /// Note, this version of getName supports overloads, but is less efficient\n  /// than the StringRef version of this function.  If no overloads are\n  /// requried, it is safe to use this version, but better to use the StringRef\n  /// version.\n  std::string getName(ID id, ArrayRef<Type*> Tys);\n\n  /// Return the function type for an intrinsic.\n  FunctionType *getType(LLVMContext &Context, ID id,\n                        ArrayRef<Type*> Tys = None);\n\n  /// Returns true if the intrinsic can be overloaded.\n  bool isOverloaded(ID id);\n\n  /// Returns true if the intrinsic is a leaf, i.e. it does not make any calls\n  /// itself.  Most intrinsics are leafs, the exceptions being the patchpoint\n  /// and statepoint intrinsics. These call (or invoke) their \"target\" argument.\n  bool isLeaf(ID id);\n\n  /// Return the attributes for an intrinsic.\n  AttributeList getAttributes(LLVMContext &C, ID id);\n\n  /// Create or insert an LLVM Function declaration for an intrinsic, and return\n  /// it.\n  ///\n  /// The Tys parameter is for intrinsics with overloaded types (e.g., those\n  /// using iAny, fAny, vAny, or iPTRAny).  For a declaration of an overloaded\n  /// intrinsic, Tys must provide exactly one type for each overloaded type in\n  /// the intrinsic.\n  Function *getDeclaration(Module *M, ID id, ArrayRef<Type*> Tys = None);\n\n  /// Looks up Name in NameTable via binary search. NameTable must be sorted\n  /// and all entries must start with \"llvm.\".  If NameTable contains an exact\n  /// match for Name or a prefix of Name followed by a dot, its index in\n  /// NameTable is returned. Otherwise, -1 is returned.\n  int lookupLLVMIntrinsicByName(ArrayRef<const char *> NameTable,\n                                StringRef Name);\n\n  /// Map a GCC builtin name to an intrinsic ID.\n  ID getIntrinsicForGCCBuiltin(const char *Prefix, StringRef BuiltinName);\n\n  /// Map a MS builtin name to an intrinsic ID.\n  ID getIntrinsicForMSBuiltin(const char *Prefix, StringRef BuiltinName);\n\n  /// This is a type descriptor which explains the type requirements of an\n  /// intrinsic. This is returned by getIntrinsicInfoTableEntries.\n  struct IITDescriptor {\n    enum IITDescriptorKind {\n      Void,\n      VarArg,\n      MMX,\n      Token,\n      Metadata,\n      Half,\n      BFloat,\n      Float,\n      Double,\n      Quad,\n      Integer,\n      Vector,\n      Pointer,\n      Struct,\n      Argument,\n      ExtendArgument,\n      TruncArgument,\n      HalfVecArgument,\n      SameVecWidthArgument,\n      PtrToArgument,\n      PtrToElt,\n      VecOfAnyPtrsToElt,\n      VecElementArgument,\n      Subdivide2Argument,\n      Subdivide4Argument,\n      VecOfBitcastsToInt,\n      AMX\n    } Kind;\n\n    union {\n      unsigned Integer_Width;\n      unsigned Float_Width;\n      unsigned Pointer_AddressSpace;\n      unsigned Struct_NumElements;\n      unsigned Argument_Info;\n      ElementCount Vector_Width;\n    };\n\n    enum ArgKind {\n      AK_Any,\n      AK_AnyInteger,\n      AK_AnyFloat,\n      AK_AnyVector,\n      AK_AnyPointer,\n      AK_MatchType = 7\n    };\n\n    unsigned getArgumentNumber() const {\n      assert(Kind == Argument || Kind == ExtendArgument ||\n             Kind == TruncArgument || Kind == HalfVecArgument ||\n             Kind == SameVecWidthArgument || Kind == PtrToArgument ||\n             Kind == PtrToElt || Kind == VecElementArgument ||\n             Kind == Subdivide2Argument || Kind == Subdivide4Argument ||\n             Kind == VecOfBitcastsToInt);\n      return Argument_Info >> 3;\n    }\n    ArgKind getArgumentKind() const {\n      assert(Kind == Argument || Kind == ExtendArgument ||\n             Kind == TruncArgument || Kind == HalfVecArgument ||\n             Kind == SameVecWidthArgument || Kind == PtrToArgument ||\n             Kind == VecElementArgument || Kind == Subdivide2Argument ||\n             Kind == Subdivide4Argument || Kind == VecOfBitcastsToInt);\n      return (ArgKind)(Argument_Info & 7);\n    }\n\n    // VecOfAnyPtrsToElt uses both an overloaded argument (for address space)\n    // and a reference argument (for matching vector width and element types)\n    unsigned getOverloadArgNumber() const {\n      assert(Kind == VecOfAnyPtrsToElt);\n      return Argument_Info >> 16;\n    }\n    unsigned getRefArgNumber() const {\n      assert(Kind == VecOfAnyPtrsToElt);\n      return Argument_Info & 0xFFFF;\n    }\n\n    static IITDescriptor get(IITDescriptorKind K, unsigned Field) {\n      IITDescriptor Result = { K, { Field } };\n      return Result;\n    }\n\n    static IITDescriptor get(IITDescriptorKind K, unsigned short Hi,\n                             unsigned short Lo) {\n      unsigned Field = Hi << 16 | Lo;\n      IITDescriptor Result = {K, {Field}};\n      return Result;\n    }\n\n    static IITDescriptor getVector(unsigned Width, bool IsScalable) {\n      IITDescriptor Result = {Vector, {0}};\n      Result.Vector_Width = ElementCount::get(Width, IsScalable);\n      return Result;\n    }\n  };\n\n  /// Return the IIT table descriptor for the specified intrinsic into an array\n  /// of IITDescriptors.\n  void getIntrinsicInfoTableEntries(ID id, SmallVectorImpl<IITDescriptor> &T);\n\n  enum MatchIntrinsicTypesResult {\n    MatchIntrinsicTypes_Match = 0,\n    MatchIntrinsicTypes_NoMatchRet = 1,\n    MatchIntrinsicTypes_NoMatchArg = 2,\n  };\n\n  /// Match the specified function type with the type constraints specified by\n  /// the .td file. If the given type is an overloaded type it is pushed to the\n  /// ArgTys vector.\n  ///\n  /// Returns false if the given type matches with the constraints, true\n  /// otherwise.\n  MatchIntrinsicTypesResult\n  matchIntrinsicSignature(FunctionType *FTy, ArrayRef<IITDescriptor> &Infos,\n                          SmallVectorImpl<Type *> &ArgTys);\n\n  /// Verify if the intrinsic has variable arguments. This method is intended to\n  /// be called after all the fixed arguments have been matched first.\n  ///\n  /// This method returns true on error.\n  bool matchIntrinsicVarArg(bool isVarArg, ArrayRef<IITDescriptor> &Infos);\n\n  /// Gets the type arguments of an intrinsic call by matching type contraints\n  /// specified by the .td file. The overloaded types are pushed into the\n  /// AgTys vector.\n  ///\n  /// Returns false if the given function is not a valid intrinsic call.\n  bool getIntrinsicSignature(Function *F, SmallVectorImpl<Type *> &ArgTys);\n\n  // Checks if the intrinsic name matches with its signature and if not\n  // returns the declaration with the same signature and remangled name.\n  llvm::Optional<Function*> remangleIntrinsicFunction(Function *F);\n\n} // End Intrinsic namespace\n\n} // End llvm namespace\n\n#endif\n"}, "42": {"id": 42, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/IR/Metadata.h", "content": "//===- llvm/IR/Metadata.h - Metadata definitions ----------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n/// @file\n/// This file contains the declarations for metadata subclasses.\n/// They represent the different flavors of metadata that live in LLVM.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_IR_METADATA_H\n#define LLVM_IR_METADATA_H\n\n#include \"llvm/ADT/ArrayRef.h\"\n#include \"llvm/ADT/DenseMap.h\"\n#include \"llvm/ADT/DenseMapInfo.h\"\n#include \"llvm/ADT/None.h\"\n#include \"llvm/ADT/PointerUnion.h\"\n#include \"llvm/ADT/STLExtras.h\"\n#include \"llvm/ADT/SmallVector.h\"\n#include \"llvm/ADT/StringMap.h\"\n#include \"llvm/ADT/StringRef.h\"\n#include \"llvm/ADT/ilist_node.h\"\n#include \"llvm/ADT/iterator_range.h\"\n#include \"llvm/IR/Constant.h\"\n#include \"llvm/IR/LLVMContext.h\"\n#include \"llvm/IR/Value.h\"\n#include \"llvm/Support/CBindingWrapping.h\"\n#include \"llvm/Support/Casting.h\"\n#include \"llvm/Support/ErrorHandling.h\"\n#include <cassert>\n#include <cstddef>\n#include <cstdint>\n#include <iterator>\n#include <memory>\n#include <string>\n#include <type_traits>\n#include <utility>\n\nnamespace llvm {\n\nclass Module;\nclass ModuleSlotTracker;\nclass raw_ostream;\nclass Type;\n\nenum LLVMConstants : uint32_t {\n  DEBUG_METADATA_VERSION = 3 // Current debug info version number.\n};\n\n/// Root of the metadata hierarchy.\n///\n/// This is a root class for typeless data in the IR.\nclass Metadata {\n  friend class ReplaceableMetadataImpl;\n\n  /// RTTI.\n  const unsigned char SubclassID;\n\nprotected:\n  /// Active type of storage.\n  enum StorageType { Uniqued, Distinct, Temporary };\n\n  /// Storage flag for non-uniqued, otherwise unowned, metadata.\n  unsigned char Storage : 7;\n\n  unsigned char SubclassData1 : 1;\n  unsigned short SubclassData16 = 0;\n  unsigned SubclassData32 = 0;\n\npublic:\n  enum MetadataKind {\n#define HANDLE_METADATA_LEAF(CLASS) CLASS##Kind,\n#include \"llvm/IR/Metadata.def\"\n  };\n\nprotected:\n  Metadata(unsigned ID, StorageType Storage)\n      : SubclassID(ID), Storage(Storage), SubclassData1(false) {\n    static_assert(sizeof(*this) == 8, \"Metadata fields poorly packed\");\n  }\n\n  ~Metadata() = default;\n\n  /// Default handling of a changed operand, which asserts.\n  ///\n  /// If subclasses pass themselves in as owners to a tracking node reference,\n  /// they must provide an implementation of this method.\n  void handleChangedOperand(void *, Metadata *) {\n    llvm_unreachable(\"Unimplemented in Metadata subclass\");\n  }\n\npublic:\n  unsigned getMetadataID() const { return SubclassID; }\n\n  /// User-friendly dump.\n  ///\n  /// If \\c M is provided, metadata nodes will be numbered canonically;\n  /// otherwise, pointer addresses are substituted.\n  ///\n  /// Note: this uses an explicit overload instead of default arguments so that\n  /// the nullptr version is easy to call from a debugger.\n  ///\n  /// @{\n  void dump() const;\n  void dump(const Module *M) const;\n  /// @}\n\n  /// Print.\n  ///\n  /// Prints definition of \\c this.\n  ///\n  /// If \\c M is provided, metadata nodes will be numbered canonically;\n  /// otherwise, pointer addresses are substituted.\n  /// @{\n  void print(raw_ostream &OS, const Module *M = nullptr,\n             bool IsForDebug = false) const;\n  void print(raw_ostream &OS, ModuleSlotTracker &MST, const Module *M = nullptr,\n             bool IsForDebug = false) const;\n  /// @}\n\n  /// Print as operand.\n  ///\n  /// Prints reference of \\c this.\n  ///\n  /// If \\c M is provided, metadata nodes will be numbered canonically;\n  /// otherwise, pointer addresses are substituted.\n  /// @{\n  void printAsOperand(raw_ostream &OS, const Module *M = nullptr) const;\n  void printAsOperand(raw_ostream &OS, ModuleSlotTracker &MST,\n                      const Module *M = nullptr) const;\n  /// @}\n};\n\n// Create wrappers for C Binding types (see CBindingWrapping.h).\nDEFINE_ISA_CONVERSION_FUNCTIONS(Metadata, LLVMMetadataRef)\n\n// Specialized opaque metadata conversions.\ninline Metadata **unwrap(LLVMMetadataRef *MDs) {\n  return reinterpret_cast<Metadata**>(MDs);\n}\n\n#define HANDLE_METADATA(CLASS) class CLASS;\n#include \"llvm/IR/Metadata.def\"\n\n// Provide specializations of isa so that we don't need definitions of\n// subclasses to see if the metadata is a subclass.\n#define HANDLE_METADATA_LEAF(CLASS)                                            \\\n  template <> struct isa_impl<CLASS, Metadata> {                               \\\n    static inline bool doit(const Metadata &MD) {                              \\\n      return MD.getMetadataID() == Metadata::CLASS##Kind;                      \\\n    }                                                                          \\\n  };\n#include \"llvm/IR/Metadata.def\"\n\ninline raw_ostream &operator<<(raw_ostream &OS, const Metadata &MD) {\n  MD.print(OS);\n  return OS;\n}\n\n/// Metadata wrapper in the Value hierarchy.\n///\n/// A member of the \\a Value hierarchy to represent a reference to metadata.\n/// This allows, e.g., instrinsics to have metadata as operands.\n///\n/// Notably, this is the only thing in either hierarchy that is allowed to\n/// reference \\a LocalAsMetadata.\nclass MetadataAsValue : public Value {\n  friend class ReplaceableMetadataImpl;\n  friend class LLVMContextImpl;\n\n  Metadata *MD;\n\n  MetadataAsValue(Type *Ty, Metadata *MD);\n\n  /// Drop use of metadata (during teardown).\n  void dropUse() { MD = nullptr; }\n\npublic:\n  ~MetadataAsValue();\n\n  static MetadataAsValue *get(LLVMContext &Context, Metadata *MD);\n  static MetadataAsValue *getIfExists(LLVMContext &Context, Metadata *MD);\n\n  Metadata *getMetadata() const { return MD; }\n\n  static bool classof(const Value *V) {\n    return V->getValueID() == MetadataAsValueVal;\n  }\n\nprivate:\n  void handleChangedMetadata(Metadata *MD);\n  void track();\n  void untrack();\n};\n\n/// API for tracking metadata references through RAUW and deletion.\n///\n/// Shared API for updating \\a Metadata pointers in subclasses that support\n/// RAUW.\n///\n/// This API is not meant to be used directly.  See \\a TrackingMDRef for a\n/// user-friendly tracking reference.\nclass MetadataTracking {\npublic:\n  /// Track the reference to metadata.\n  ///\n  /// Register \\c MD with \\c *MD, if the subclass supports tracking.  If \\c *MD\n  /// gets RAUW'ed, \\c MD will be updated to the new address.  If \\c *MD gets\n  /// deleted, \\c MD will be set to \\c nullptr.\n  ///\n  /// If tracking isn't supported, \\c *MD will not change.\n  ///\n  /// \\return true iff tracking is supported by \\c MD.\n  static bool track(Metadata *&MD) {\n    return track(&MD, *MD, static_cast<Metadata *>(nullptr));\n  }\n\n  /// Track the reference to metadata for \\a Metadata.\n  ///\n  /// As \\a track(Metadata*&), but with support for calling back to \\c Owner to\n  /// tell it that its operand changed.  This could trigger \\c Owner being\n  /// re-uniqued.\n  static bool track(void *Ref, Metadata &MD, Metadata &Owner) {\n    return track(Ref, MD, &Owner);\n  }\n\n  /// Track the reference to metadata for \\a MetadataAsValue.\n  ///\n  /// As \\a track(Metadata*&), but with support for calling back to \\c Owner to\n  /// tell it that its operand changed.  This could trigger \\c Owner being\n  /// re-uniqued.\n  static bool track(void *Ref, Metadata &MD, MetadataAsValue &Owner) {\n    return track(Ref, MD, &Owner);\n  }\n\n  /// Stop tracking a reference to metadata.\n  ///\n  /// Stops \\c *MD from tracking \\c MD.\n  static void untrack(Metadata *&MD) { untrack(&MD, *MD); }\n  static void untrack(void *Ref, Metadata &MD);\n\n  /// Move tracking from one reference to another.\n  ///\n  /// Semantically equivalent to \\c untrack(MD) followed by \\c track(New),\n  /// except that ownership callbacks are maintained.\n  ///\n  /// Note: it is an error if \\c *MD does not equal \\c New.\n  ///\n  /// \\return true iff tracking is supported by \\c MD.\n  static bool retrack(Metadata *&MD, Metadata *&New) {\n    return retrack(&MD, *MD, &New);\n  }\n  static bool retrack(void *Ref, Metadata &MD, void *New);\n\n  /// Check whether metadata is replaceable.\n  static bool isReplaceable(const Metadata &MD);\n\n  using OwnerTy = PointerUnion<MetadataAsValue *, Metadata *>;\n\nprivate:\n  /// Track a reference to metadata for an owner.\n  ///\n  /// Generalized version of tracking.\n  static bool track(void *Ref, Metadata &MD, OwnerTy Owner);\n};\n\n/// Shared implementation of use-lists for replaceable metadata.\n///\n/// Most metadata cannot be RAUW'ed.  This is a shared implementation of\n/// use-lists and associated API for the two that support it (\\a ValueAsMetadata\n/// and \\a TempMDNode).\nclass ReplaceableMetadataImpl {\n  friend class MetadataTracking;\n\npublic:\n  using OwnerTy = MetadataTracking::OwnerTy;\n\nprivate:\n  LLVMContext &Context;\n  uint64_t NextIndex = 0;\n  SmallDenseMap<void *, std::pair<OwnerTy, uint64_t>, 4> UseMap;\n\npublic:\n  ReplaceableMetadataImpl(LLVMContext &Context) : Context(Context) {}\n\n  ~ReplaceableMetadataImpl() {\n    assert(UseMap.empty() && \"Cannot destroy in-use replaceable metadata\");\n  }\n\n  LLVMContext &getContext() const { return Context; }\n\n  /// Replace all uses of this with MD.\n  ///\n  /// Replace all uses of this with \\c MD, which is allowed to be null.\n  void replaceAllUsesWith(Metadata *MD);\n\n  /// Returns the list of all DIArgList users of this.\n  SmallVector<Metadata *, 4> getAllArgListUsers();\n\n  /// Resolve all uses of this.\n  ///\n  /// Resolve all uses of this, turning off RAUW permanently.  If \\c\n  /// ResolveUsers, call \\a MDNode::resolve() on any users whose last operand\n  /// is resolved.\n  void resolveAllUses(bool ResolveUsers = true);\n\nprivate:\n  void addRef(void *Ref, OwnerTy Owner);\n  void dropRef(void *Ref);\n  void moveRef(void *Ref, void *New, const Metadata &MD);\n\n  /// Lazily construct RAUW support on MD.\n  ///\n  /// If this is an unresolved MDNode, RAUW support will be created on-demand.\n  /// ValueAsMetadata always has RAUW support.\n  static ReplaceableMetadataImpl *getOrCreate(Metadata &MD);\n\n  /// Get RAUW support on MD, if it exists.\n  static ReplaceableMetadataImpl *getIfExists(Metadata &MD);\n\n  /// Check whether this node will support RAUW.\n  ///\n  /// Returns \\c true unless getOrCreate() would return null.\n  static bool isReplaceable(const Metadata &MD);\n};\n\n/// Value wrapper in the Metadata hierarchy.\n///\n/// This is a custom value handle that allows other metadata to refer to\n/// classes in the Value hierarchy.\n///\n/// Because of full uniquing support, each value is only wrapped by a single \\a\n/// ValueAsMetadata object, so the lookup maps are far more efficient than\n/// those using ValueHandleBase.\nclass ValueAsMetadata : public Metadata, ReplaceableMetadataImpl {\n  friend class ReplaceableMetadataImpl;\n  friend class LLVMContextImpl;\n\n  Value *V;\n\n  /// Drop users without RAUW (during teardown).\n  void dropUsers() {\n    ReplaceableMetadataImpl::resolveAllUses(/* ResolveUsers */ false);\n  }\n\nprotected:\n  ValueAsMetadata(unsigned ID, Value *V)\n      : Metadata(ID, Uniqued), ReplaceableMetadataImpl(V->getContext()), V(V) {\n    assert(V && \"Expected valid value\");\n  }\n\n  ~ValueAsMetadata() = default;\n\npublic:\n  static ValueAsMetadata *get(Value *V);\n\n  static ConstantAsMetadata *getConstant(Value *C) {\n    return cast<ConstantAsMetadata>(get(C));\n  }\n\n  static LocalAsMetadata *getLocal(Value *Local) {\n    return cast<LocalAsMetadata>(get(Local));\n  }\n\n  static ValueAsMetadata *getIfExists(Value *V);\n\n  static ConstantAsMetadata *getConstantIfExists(Value *C) {\n    return cast_or_null<ConstantAsMetadata>(getIfExists(C));\n  }\n\n  static LocalAsMetadata *getLocalIfExists(Value *Local) {\n    return cast_or_null<LocalAsMetadata>(getIfExists(Local));\n  }\n\n  Value *getValue() const { return V; }\n  Type *getType() const { return V->getType(); }\n  LLVMContext &getContext() const { return V->getContext(); }\n\n  SmallVector<Metadata *, 4> getAllArgListUsers() {\n    return ReplaceableMetadataImpl::getAllArgListUsers();\n  }\n\n  static void handleDeletion(Value *V);\n  static void handleRAUW(Value *From, Value *To);\n\nprotected:\n  /// Handle collisions after \\a Value::replaceAllUsesWith().\n  ///\n  /// RAUW isn't supported directly for \\a ValueAsMetadata, but if the wrapped\n  /// \\a Value gets RAUW'ed and the target already exists, this is used to\n  /// merge the two metadata nodes.\n  void replaceAllUsesWith(Metadata *MD) {\n    ReplaceableMetadataImpl::replaceAllUsesWith(MD);\n  }\n\npublic:\n  static bool classof(const Metadata *MD) {\n    return MD->getMetadataID() == LocalAsMetadataKind ||\n           MD->getMetadataID() == ConstantAsMetadataKind;\n  }\n};\n\nclass ConstantAsMetadata : public ValueAsMetadata {\n  friend class ValueAsMetadata;\n\n  ConstantAsMetadata(Constant *C)\n      : ValueAsMetadata(ConstantAsMetadataKind, C) {}\n\npublic:\n  static ConstantAsMetadata *get(Constant *C) {\n    return ValueAsMetadata::getConstant(C);\n  }\n\n  static ConstantAsMetadata *getIfExists(Constant *C) {\n    return ValueAsMetadata::getConstantIfExists(C);\n  }\n\n  Constant *getValue() const {\n    return cast<Constant>(ValueAsMetadata::getValue());\n  }\n\n  static bool classof(const Metadata *MD) {\n    return MD->getMetadataID() == ConstantAsMetadataKind;\n  }\n};\n\nclass LocalAsMetadata : public ValueAsMetadata {\n  friend class ValueAsMetadata;\n\n  LocalAsMetadata(Value *Local)\n      : ValueAsMetadata(LocalAsMetadataKind, Local) {\n    assert(!isa<Constant>(Local) && \"Expected local value\");\n  }\n\npublic:\n  static LocalAsMetadata *get(Value *Local) {\n    return ValueAsMetadata::getLocal(Local);\n  }\n\n  static LocalAsMetadata *getIfExists(Value *Local) {\n    return ValueAsMetadata::getLocalIfExists(Local);\n  }\n\n  static bool classof(const Metadata *MD) {\n    return MD->getMetadataID() == LocalAsMetadataKind;\n  }\n};\n\n/// Transitional API for extracting constants from Metadata.\n///\n/// This namespace contains transitional functions for metadata that points to\n/// \\a Constants.\n///\n/// In prehistory -- when metadata was a subclass of \\a Value -- \\a MDNode\n/// operands could refer to any \\a Value.  There's was a lot of code like this:\n///\n/// \\code\n///     MDNode *N = ...;\n///     auto *CI = dyn_cast<ConstantInt>(N->getOperand(2));\n/// \\endcode\n///\n/// Now that \\a Value and \\a Metadata are in separate hierarchies, maintaining\n/// the semantics for \\a isa(), \\a cast(), \\a dyn_cast() (etc.) requires three\n/// steps: cast in the \\a Metadata hierarchy, extraction of the \\a Value, and\n/// cast in the \\a Value hierarchy.  Besides creating boiler-plate, this\n/// requires subtle control flow changes.\n///\n/// The end-goal is to create a new type of metadata, called (e.g.) \\a MDInt,\n/// so that metadata can refer to numbers without traversing a bridge to the \\a\n/// Value hierarchy.  In this final state, the code above would look like this:\n///\n/// \\code\n///     MDNode *N = ...;\n///     auto *MI = dyn_cast<MDInt>(N->getOperand(2));\n/// \\endcode\n///\n/// The API in this namespace supports the transition.  \\a MDInt doesn't exist\n/// yet, and even once it does, changing each metadata schema to use it is its\n/// own mini-project.  In the meantime this API prevents us from introducing\n/// complex and bug-prone control flow that will disappear in the end.  In\n/// particular, the above code looks like this:\n///\n/// \\code\n///     MDNode *N = ...;\n///     auto *CI = mdconst::dyn_extract<ConstantInt>(N->getOperand(2));\n/// \\endcode\n///\n/// The full set of provided functions includes:\n///\n///   mdconst::hasa                <=> isa\n///   mdconst::extract             <=> cast\n///   mdconst::extract_or_null     <=> cast_or_null\n///   mdconst::dyn_extract         <=> dyn_cast\n///   mdconst::dyn_extract_or_null <=> dyn_cast_or_null\n///\n/// The target of the cast must be a subclass of \\a Constant.\nnamespace mdconst {\n\nnamespace detail {\n\ntemplate <class T> T &make();\ntemplate <class T, class Result> struct HasDereference {\n  using Yes = char[1];\n  using No = char[2];\n  template <size_t N> struct SFINAE {};\n\n  template <class U, class V>\n  static Yes &hasDereference(SFINAE<sizeof(static_cast<V>(*make<U>()))> * = 0);\n  template <class U, class V> static No &hasDereference(...);\n\n  static const bool value =\n      sizeof(hasDereference<T, Result>(nullptr)) == sizeof(Yes);\n};\ntemplate <class V, class M> struct IsValidPointer {\n  static const bool value = std::is_base_of<Constant, V>::value &&\n                            HasDereference<M, const Metadata &>::value;\n};\ntemplate <class V, class M> struct IsValidReference {\n  static const bool value = std::is_base_of<Constant, V>::value &&\n                            std::is_convertible<M, const Metadata &>::value;\n};\n\n} // end namespace detail\n\n/// Check whether Metadata has a Value.\n///\n/// As an analogue to \\a isa(), check whether \\c MD has an \\a Value inside of\n/// type \\c X.\ntemplate <class X, class Y>\ninline std::enable_if_t<detail::IsValidPointer<X, Y>::value, bool>\nhasa(Y &&MD) {\n  assert(MD && \"Null pointer sent into hasa\");\n  if (auto *V = dyn_cast<ConstantAsMetadata>(MD))\n    return isa<X>(V->getValue());\n  return false;\n}\ntemplate <class X, class Y>\ninline std::enable_if_t<detail::IsValidReference<X, Y &>::value, bool>\nhasa(Y &MD) {\n  return hasa(&MD);\n}\n\n/// Extract a Value from Metadata.\n///\n/// As an analogue to \\a cast(), extract the \\a Value subclass \\c X from \\c MD.\ntemplate <class X, class Y>\ninline std::enable_if_t<detail::IsValidPointer<X, Y>::value, X *>\nextract(Y &&MD) {\n  return cast<X>(cast<ConstantAsMetadata>(MD)->getValue());\n}\ntemplate <class X, class Y>\ninline std::enable_if_t<detail::IsValidReference<X, Y &>::value, X *>\nextract(Y &MD) {\n  return extract(&MD);\n}\n\n/// Extract a Value from Metadata, allowing null.\n///\n/// As an analogue to \\a cast_or_null(), extract the \\a Value subclass \\c X\n/// from \\c MD, allowing \\c MD to be null.\ntemplate <class X, class Y>\ninline std::enable_if_t<detail::IsValidPointer<X, Y>::value, X *>\nextract_or_null(Y &&MD) {\n  if (auto *V = cast_or_null<ConstantAsMetadata>(MD))\n    return cast<X>(V->getValue());\n  return nullptr;\n}\n\n/// Extract a Value from Metadata, if any.\n///\n/// As an analogue to \\a dyn_cast_or_null(), extract the \\a Value subclass \\c X\n/// from \\c MD, return null if \\c MD doesn't contain a \\a Value or if the \\a\n/// Value it does contain is of the wrong subclass.\ntemplate <class X, class Y>\ninline std::enable_if_t<detail::IsValidPointer<X, Y>::value, X *>\ndyn_extract(Y &&MD) {\n  if (auto *V = dyn_cast<ConstantAsMetadata>(MD))\n    return dyn_cast<X>(V->getValue());\n  return nullptr;\n}\n\n/// Extract a Value from Metadata, if any, allowing null.\n///\n/// As an analogue to \\a dyn_cast_or_null(), extract the \\a Value subclass \\c X\n/// from \\c MD, return null if \\c MD doesn't contain a \\a Value or if the \\a\n/// Value it does contain is of the wrong subclass, allowing \\c MD to be null.\ntemplate <class X, class Y>\ninline std::enable_if_t<detail::IsValidPointer<X, Y>::value, X *>\ndyn_extract_or_null(Y &&MD) {\n  if (auto *V = dyn_cast_or_null<ConstantAsMetadata>(MD))\n    return dyn_cast<X>(V->getValue());\n  return nullptr;\n}\n\n} // end namespace mdconst\n\n//===----------------------------------------------------------------------===//\n/// A single uniqued string.\n///\n/// These are used to efficiently contain a byte sequence for metadata.\n/// MDString is always unnamed.\nclass MDString : public Metadata {\n  friend class StringMapEntryStorage<MDString>;\n\n  StringMapEntry<MDString> *Entry = nullptr;\n\n  MDString() : Metadata(MDStringKind, Uniqued) {}\n\npublic:\n  MDString(const MDString &) = delete;\n  MDString &operator=(MDString &&) = delete;\n  MDString &operator=(const MDString &) = delete;\n\n  static MDString *get(LLVMContext &Context, StringRef Str);\n  static MDString *get(LLVMContext &Context, const char *Str) {\n    return get(Context, Str ? StringRef(Str) : StringRef());\n  }\n\n  StringRef getString() const;\n\n  unsigned getLength() const { return (unsigned)getString().size(); }\n\n  using iterator = StringRef::iterator;\n\n  /// Pointer to the first byte of the string.\n  iterator begin() const { return getString().begin(); }\n\n  /// Pointer to one byte past the end of the string.\n  iterator end() const { return getString().end(); }\n\n  const unsigned char *bytes_begin() const { return getString().bytes_begin(); }\n  const unsigned char *bytes_end() const { return getString().bytes_end(); }\n\n  /// Methods for support type inquiry through isa, cast, and dyn_cast.\n  static bool classof(const Metadata *MD) {\n    return MD->getMetadataID() == MDStringKind;\n  }\n};\n\n/// A collection of metadata nodes that might be associated with a\n/// memory access used by the alias-analysis infrastructure.\nstruct AAMDNodes {\n  explicit AAMDNodes() = default;\n  explicit AAMDNodes(MDNode *T, MDNode *TS, MDNode *S, MDNode *N)\n      : TBAA(T), TBAAStruct(TS), Scope(S), NoAlias(N) {}\n\n  bool operator==(const AAMDNodes &A) const {\n    return TBAA == A.TBAA && TBAAStruct == A.TBAAStruct && Scope == A.Scope &&\n           NoAlias == A.NoAlias;\n  }\n\n  bool operator!=(const AAMDNodes &A) const { return !(*this == A); }\n\n  explicit operator bool() const {\n    return TBAA || TBAAStruct || Scope || NoAlias;\n  }\n\n  /// The tag for type-based alias analysis.\n  MDNode *TBAA = nullptr;\n\n  /// The tag for type-based alias analysis (tbaa struct).\n  MDNode *TBAAStruct = nullptr;\n\n  /// The tag for alias scope specification (used with noalias).\n  MDNode *Scope = nullptr;\n\n  /// The tag specifying the noalias scope.\n  MDNode *NoAlias = nullptr;\n\n  // Shift tbaa Metadata node to start off bytes later\n  static MDNode *ShiftTBAA(MDNode *M, size_t off);\n\n  // Shift tbaa.struct Metadata node to start off bytes later\n  static MDNode *ShiftTBAAStruct(MDNode *M, size_t off);\n\n  /// Given two sets of AAMDNodes that apply to the same pointer,\n  /// give the best AAMDNodes that are compatible with both (i.e. a set of\n  /// nodes whose allowable aliasing conclusions are a subset of those\n  /// allowable by both of the inputs). However, for efficiency\n  /// reasons, do not create any new MDNodes.\n  AAMDNodes intersect(const AAMDNodes &Other) {\n    AAMDNodes Result;\n    Result.TBAA = Other.TBAA == TBAA ? TBAA : nullptr;\n    Result.TBAAStruct = Other.TBAAStruct == TBAAStruct ? TBAAStruct : nullptr;\n    Result.Scope = Other.Scope == Scope ? Scope : nullptr;\n    Result.NoAlias = Other.NoAlias == NoAlias ? NoAlias : nullptr;\n    return Result;\n  }\n\n  /// Create a new AAMDNode that describes this AAMDNode after applying a\n  /// constant offset to the start of the pointer\n  AAMDNodes shift(size_t Offset) {\n    AAMDNodes Result;\n    Result.TBAA = TBAA ? ShiftTBAA(TBAA, Offset) : nullptr;\n    Result.TBAAStruct =\n        TBAAStruct ? ShiftTBAAStruct(TBAAStruct, Offset) : nullptr;\n    Result.Scope = Scope;\n    Result.NoAlias = NoAlias;\n    return Result;\n  }\n};\n\n// Specialize DenseMapInfo for AAMDNodes.\ntemplate<>\nstruct DenseMapInfo<AAMDNodes> {\n  static inline AAMDNodes getEmptyKey() {\n    return AAMDNodes(DenseMapInfo<MDNode *>::getEmptyKey(),\n                     nullptr, nullptr, nullptr);\n  }\n\n  static inline AAMDNodes getTombstoneKey() {\n    return AAMDNodes(DenseMapInfo<MDNode *>::getTombstoneKey(),\n                     nullptr, nullptr, nullptr);\n  }\n\n  static unsigned getHashValue(const AAMDNodes &Val) {\n    return DenseMapInfo<MDNode *>::getHashValue(Val.TBAA) ^\n           DenseMapInfo<MDNode *>::getHashValue(Val.TBAAStruct) ^\n           DenseMapInfo<MDNode *>::getHashValue(Val.Scope) ^\n           DenseMapInfo<MDNode *>::getHashValue(Val.NoAlias);\n  }\n\n  static bool isEqual(const AAMDNodes &LHS, const AAMDNodes &RHS) {\n    return LHS == RHS;\n  }\n};\n\n/// Tracking metadata reference owned by Metadata.\n///\n/// Similar to \\a TrackingMDRef, but it's expected to be owned by an instance\n/// of \\a Metadata, which has the option of registering itself for callbacks to\n/// re-unique itself.\n///\n/// In particular, this is used by \\a MDNode.\nclass MDOperand {\n  Metadata *MD = nullptr;\n\npublic:\n  MDOperand() = default;\n  MDOperand(MDOperand &&) = delete;\n  MDOperand(const MDOperand &) = delete;\n  MDOperand &operator=(MDOperand &&) = delete;\n  MDOperand &operator=(const MDOperand &) = delete;\n  ~MDOperand() { untrack(); }\n\n  Metadata *get() const { return MD; }\n  operator Metadata *() const { return get(); }\n  Metadata *operator->() const { return get(); }\n  Metadata &operator*() const { return *get(); }\n\n  void reset() {\n    untrack();\n    MD = nullptr;\n  }\n  void reset(Metadata *MD, Metadata *Owner) {\n    untrack();\n    this->MD = MD;\n    track(Owner);\n  }\n\nprivate:\n  void track(Metadata *Owner) {\n    if (MD) {\n      if (Owner)\n        MetadataTracking::track(this, *MD, *Owner);\n      else\n        MetadataTracking::track(MD);\n    }\n  }\n\n  void untrack() {\n    assert(static_cast<void *>(this) == &MD && \"Expected same address\");\n    if (MD)\n      MetadataTracking::untrack(MD);\n  }\n};\n\ntemplate <> struct simplify_type<MDOperand> {\n  using SimpleType = Metadata *;\n\n  static SimpleType getSimplifiedValue(MDOperand &MD) { return MD.get(); }\n};\n\ntemplate <> struct simplify_type<const MDOperand> {\n  using SimpleType = Metadata *;\n\n  static SimpleType getSimplifiedValue(const MDOperand &MD) { return MD.get(); }\n};\n\n/// Pointer to the context, with optional RAUW support.\n///\n/// Either a raw (non-null) pointer to the \\a LLVMContext, or an owned pointer\n/// to \\a ReplaceableMetadataImpl (which has a reference to \\a LLVMContext).\nclass ContextAndReplaceableUses {\n  PointerUnion<LLVMContext *, ReplaceableMetadataImpl *> Ptr;\n\npublic:\n  ContextAndReplaceableUses(LLVMContext &Context) : Ptr(&Context) {}\n  ContextAndReplaceableUses(\n      std::unique_ptr<ReplaceableMetadataImpl> ReplaceableUses)\n      : Ptr(ReplaceableUses.release()) {\n    assert(getReplaceableUses() && \"Expected non-null replaceable uses\");\n  }\n  ContextAndReplaceableUses() = delete;\n  ContextAndReplaceableUses(ContextAndReplaceableUses &&) = delete;\n  ContextAndReplaceableUses(const ContextAndReplaceableUses &) = delete;\n  ContextAndReplaceableUses &operator=(ContextAndReplaceableUses &&) = delete;\n  ContextAndReplaceableUses &\n  operator=(const ContextAndReplaceableUses &) = delete;\n  ~ContextAndReplaceableUses() { delete getReplaceableUses(); }\n\n  operator LLVMContext &() { return getContext(); }\n\n  /// Whether this contains RAUW support.\n  bool hasReplaceableUses() const {\n    return Ptr.is<ReplaceableMetadataImpl *>();\n  }\n\n  LLVMContext &getContext() const {\n    if (hasReplaceableUses())\n      return getReplaceableUses()->getContext();\n    return *Ptr.get<LLVMContext *>();\n  }\n\n  ReplaceableMetadataImpl *getReplaceableUses() const {\n    if (hasReplaceableUses())\n      return Ptr.get<ReplaceableMetadataImpl *>();\n    return nullptr;\n  }\n\n  /// Ensure that this has RAUW support, and then return it.\n  ReplaceableMetadataImpl *getOrCreateReplaceableUses() {\n    if (!hasReplaceableUses())\n      makeReplaceable(std::make_unique<ReplaceableMetadataImpl>(getContext()));\n    return getReplaceableUses();\n  }\n\n  /// Assign RAUW support to this.\n  ///\n  /// Make this replaceable, taking ownership of \\c ReplaceableUses (which must\n  /// not be null).\n  void\n  makeReplaceable(std::unique_ptr<ReplaceableMetadataImpl> ReplaceableUses) {\n    assert(ReplaceableUses && \"Expected non-null replaceable uses\");\n    assert(&ReplaceableUses->getContext() == &getContext() &&\n           \"Expected same context\");\n    delete getReplaceableUses();\n    Ptr = ReplaceableUses.release();\n  }\n\n  /// Drop RAUW support.\n  ///\n  /// Cede ownership of RAUW support, returning it.\n  std::unique_ptr<ReplaceableMetadataImpl> takeReplaceableUses() {\n    assert(hasReplaceableUses() && \"Expected to own replaceable uses\");\n    std::unique_ptr<ReplaceableMetadataImpl> ReplaceableUses(\n        getReplaceableUses());\n    Ptr = &ReplaceableUses->getContext();\n    return ReplaceableUses;\n  }\n};\n\nstruct TempMDNodeDeleter {\n  inline void operator()(MDNode *Node) const;\n};\n\n#define HANDLE_MDNODE_LEAF(CLASS)                                              \\\n  using Temp##CLASS = std::unique_ptr<CLASS, TempMDNodeDeleter>;\n#define HANDLE_MDNODE_BRANCH(CLASS) HANDLE_MDNODE_LEAF(CLASS)\n#include \"llvm/IR/Metadata.def\"\n\n/// Metadata node.\n///\n/// Metadata nodes can be uniqued, like constants, or distinct.  Temporary\n/// metadata nodes (with full support for RAUW) can be used to delay uniquing\n/// until forward references are known.  The basic metadata node is an \\a\n/// MDTuple.\n///\n/// There is limited support for RAUW at construction time.  At construction\n/// time, if any operand is a temporary node (or an unresolved uniqued node,\n/// which indicates a transitive temporary operand), the node itself will be\n/// unresolved.  As soon as all operands become resolved, it will drop RAUW\n/// support permanently.\n///\n/// If an unresolved node is part of a cycle, \\a resolveCycles() needs\n/// to be called on some member of the cycle once all temporary nodes have been\n/// replaced.\nclass MDNode : public Metadata {\n  friend class ReplaceableMetadataImpl;\n  friend class LLVMContextImpl;\n\n  unsigned NumOperands;\n  unsigned NumUnresolved;\n\n  ContextAndReplaceableUses Context;\n\nprotected:\n  MDNode(LLVMContext &Context, unsigned ID, StorageType Storage,\n         ArrayRef<Metadata *> Ops1, ArrayRef<Metadata *> Ops2 = None);\n  ~MDNode() = default;\n\n  void *operator new(size_t Size, unsigned NumOps);\n  void operator delete(void *Mem);\n\n  /// Required by std, but never called.\n  void operator delete(void *, unsigned) {\n    llvm_unreachable(\"Constructor throws?\");\n  }\n\n  /// Required by std, but never called.\n  void operator delete(void *, unsigned, bool) {\n    llvm_unreachable(\"Constructor throws?\");\n  }\n\n  void dropAllReferences();\n\n  MDOperand *mutable_begin() { return mutable_end() - NumOperands; }\n  MDOperand *mutable_end() { return reinterpret_cast<MDOperand *>(this); }\n\n  using mutable_op_range = iterator_range<MDOperand *>;\n\n  mutable_op_range mutable_operands() {\n    return mutable_op_range(mutable_begin(), mutable_end());\n  }\n\npublic:\n  MDNode(const MDNode &) = delete;\n  void operator=(const MDNode &) = delete;\n  void *operator new(size_t) = delete;\n\n  static inline MDTuple *get(LLVMContext &Context, ArrayRef<Metadata *> MDs);\n  static inline MDTuple *getIfExists(LLVMContext &Context,\n                                     ArrayRef<Metadata *> MDs);\n  static inline MDTuple *getDistinct(LLVMContext &Context,\n                                     ArrayRef<Metadata *> MDs);\n  static inline TempMDTuple getTemporary(LLVMContext &Context,\n                                         ArrayRef<Metadata *> MDs);\n\n  /// Create a (temporary) clone of this.\n  TempMDNode clone() const;\n\n  /// Deallocate a node created by getTemporary.\n  ///\n  /// Calls \\c replaceAllUsesWith(nullptr) before deleting, so any remaining\n  /// references will be reset.\n  static void deleteTemporary(MDNode *N);\n\n  LLVMContext &getContext() const { return Context.getContext(); }\n\n  /// Replace a specific operand.\n  void replaceOperandWith(unsigned I, Metadata *New);\n\n  /// Check if node is fully resolved.\n  ///\n  /// If \\a isTemporary(), this always returns \\c false; if \\a isDistinct(),\n  /// this always returns \\c true.\n  ///\n  /// If \\a isUniqued(), returns \\c true if this has already dropped RAUW\n  /// support (because all operands are resolved).\n  ///\n  /// As forward declarations are resolved, their containers should get\n  /// resolved automatically.  However, if this (or one of its operands) is\n  /// involved in a cycle, \\a resolveCycles() needs to be called explicitly.\n  bool isResolved() const { return !isTemporary() && !NumUnresolved; }\n\n  bool isUniqued() const { return Storage == Uniqued; }\n  bool isDistinct() const { return Storage == Distinct; }\n  bool isTemporary() const { return Storage == Temporary; }\n\n  /// RAUW a temporary.\n  ///\n  /// \\pre \\a isTemporary() must be \\c true.\n  void replaceAllUsesWith(Metadata *MD) {\n    assert(isTemporary() && \"Expected temporary node\");\n    if (Context.hasReplaceableUses())\n      Context.getReplaceableUses()->replaceAllUsesWith(MD);\n  }\n\n  /// Resolve cycles.\n  ///\n  /// Once all forward declarations have been resolved, force cycles to be\n  /// resolved.\n  ///\n  /// \\pre No operands (or operands' operands, etc.) have \\a isTemporary().\n  void resolveCycles();\n\n  /// Resolve a unique, unresolved node.\n  void resolve();\n\n  /// Replace a temporary node with a permanent one.\n  ///\n  /// Try to create a uniqued version of \\c N -- in place, if possible -- and\n  /// return it.  If \\c N cannot be uniqued, return a distinct node instead.\n  template <class T>\n  static std::enable_if_t<std::is_base_of<MDNode, T>::value, T *>\n  replaceWithPermanent(std::unique_ptr<T, TempMDNodeDeleter> N) {\n    return cast<T>(N.release()->replaceWithPermanentImpl());\n  }\n\n  /// Replace a temporary node with a uniqued one.\n  ///\n  /// Create a uniqued version of \\c N -- in place, if possible -- and return\n  /// it.  Takes ownership of the temporary node.\n  ///\n  /// \\pre N does not self-reference.\n  template <class T>\n  static std::enable_if_t<std::is_base_of<MDNode, T>::value, T *>\n  replaceWithUniqued(std::unique_ptr<T, TempMDNodeDeleter> N) {\n    return cast<T>(N.release()->replaceWithUniquedImpl());\n  }\n\n  /// Replace a temporary node with a distinct one.\n  ///\n  /// Create a distinct version of \\c N -- in place, if possible -- and return\n  /// it.  Takes ownership of the temporary node.\n  template <class T>\n  static std::enable_if_t<std::is_base_of<MDNode, T>::value, T *>\n  replaceWithDistinct(std::unique_ptr<T, TempMDNodeDeleter> N) {\n    return cast<T>(N.release()->replaceWithDistinctImpl());\n  }\n\nprivate:\n  MDNode *replaceWithPermanentImpl();\n  MDNode *replaceWithUniquedImpl();\n  MDNode *replaceWithDistinctImpl();\n\nprotected:\n  /// Set an operand.\n  ///\n  /// Sets the operand directly, without worrying about uniquing.\n  void setOperand(unsigned I, Metadata *New);\n\n  void storeDistinctInContext();\n  template <class T, class StoreT>\n  static T *storeImpl(T *N, StorageType Storage, StoreT &Store);\n  template <class T> static T *storeImpl(T *N, StorageType Storage);\n\nprivate:\n  void handleChangedOperand(void *Ref, Metadata *New);\n\n  /// Drop RAUW support, if any.\n  void dropReplaceableUses();\n\n  void resolveAfterOperandChange(Metadata *Old, Metadata *New);\n  void decrementUnresolvedOperandCount();\n  void countUnresolvedOperands();\n\n  /// Mutate this to be \"uniqued\".\n  ///\n  /// Mutate this so that \\a isUniqued().\n  /// \\pre \\a isTemporary().\n  /// \\pre already added to uniquing set.\n  void makeUniqued();\n\n  /// Mutate this to be \"distinct\".\n  ///\n  /// Mutate this so that \\a isDistinct().\n  /// \\pre \\a isTemporary().\n  void makeDistinct();\n\n  void deleteAsSubclass();\n  MDNode *uniquify();\n  void eraseFromStore();\n\n  template <class NodeTy> struct HasCachedHash;\n  template <class NodeTy>\n  static void dispatchRecalculateHash(NodeTy *N, std::true_type) {\n    N->recalculateHash();\n  }\n  template <class NodeTy>\n  static void dispatchRecalculateHash(NodeTy *, std::false_type) {}\n  template <class NodeTy>\n  static void dispatchResetHash(NodeTy *N, std::true_type) {\n    N->setHash(0);\n  }\n  template <class NodeTy>\n  static void dispatchResetHash(NodeTy *, std::false_type) {}\n\npublic:\n  using op_iterator = const MDOperand *;\n  using op_range = iterator_range<op_iterator>;\n\n  op_iterator op_begin() const {\n    return const_cast<MDNode *>(this)->mutable_begin();\n  }\n\n  op_iterator op_end() const {\n    return const_cast<MDNode *>(this)->mutable_end();\n  }\n\n  op_range operands() const { return op_range(op_begin(), op_end()); }\n\n  const MDOperand &getOperand(unsigned I) const {\n    assert(I < NumOperands && \"Out of range\");\n    return op_begin()[I];\n  }\n\n  /// Return number of MDNode operands.\n  unsigned getNumOperands() const { return NumOperands; }\n\n  /// Methods for support type inquiry through isa, cast, and dyn_cast:\n  static bool classof(const Metadata *MD) {\n    switch (MD->getMetadataID()) {\n    default:\n      return false;\n#define HANDLE_MDNODE_LEAF(CLASS)                                              \\\n  case CLASS##Kind:                                                            \\\n    return true;\n#include \"llvm/IR/Metadata.def\"\n    }\n  }\n\n  /// Check whether MDNode is a vtable access.\n  bool isTBAAVtableAccess() const;\n\n  /// Methods for metadata merging.\n  static MDNode *concatenate(MDNode *A, MDNode *B);\n  static MDNode *intersect(MDNode *A, MDNode *B);\n  static MDNode *getMostGenericTBAA(MDNode *A, MDNode *B);\n  static MDNode *getMostGenericFPMath(MDNode *A, MDNode *B);\n  static MDNode *getMostGenericRange(MDNode *A, MDNode *B);\n  static MDNode *getMostGenericAliasScope(MDNode *A, MDNode *B);\n  static MDNode *getMostGenericAlignmentOrDereferenceable(MDNode *A, MDNode *B);\n};\n\n/// Tuple of metadata.\n///\n/// This is the simple \\a MDNode arbitrary tuple.  Nodes are uniqued by\n/// default based on their operands.\nclass MDTuple : public MDNode {\n  friend class LLVMContextImpl;\n  friend class MDNode;\n\n  MDTuple(LLVMContext &C, StorageType Storage, unsigned Hash,\n          ArrayRef<Metadata *> Vals)\n      : MDNode(C, MDTupleKind, Storage, Vals) {\n    setHash(Hash);\n  }\n\n  ~MDTuple() { dropAllReferences(); }\n\n  void setHash(unsigned Hash) { SubclassData32 = Hash; }\n  void recalculateHash();\n\n  static MDTuple *getImpl(LLVMContext &Context, ArrayRef<Metadata *> MDs,\n                          StorageType Storage, bool ShouldCreate = true);\n\n  TempMDTuple cloneImpl() const {\n    return getTemporary(getContext(), SmallVector<Metadata *, 4>(operands()));\n  }\n\npublic:\n  /// Get the hash, if any.\n  unsigned getHash() const { return SubclassData32; }\n\n  static MDTuple *get(LLVMContext &Context, ArrayRef<Metadata *> MDs) {\n    return getImpl(Context, MDs, Uniqued);\n  }\n\n  static MDTuple *getIfExists(LLVMContext &Context, ArrayRef<Metadata *> MDs) {\n    return getImpl(Context, MDs, Uniqued, /* ShouldCreate */ false);\n  }\n\n  /// Return a distinct node.\n  ///\n  /// Return a distinct node -- i.e., a node that is not uniqued.\n  static MDTuple *getDistinct(LLVMContext &Context, ArrayRef<Metadata *> MDs) {\n    return getImpl(Context, MDs, Distinct);\n  }\n\n  /// Return a temporary node.\n  ///\n  /// For use in constructing cyclic MDNode structures. A temporary MDNode is\n  /// not uniqued, may be RAUW'd, and must be manually deleted with\n  /// deleteTemporary.\n  static TempMDTuple getTemporary(LLVMContext &Context,\n                                  ArrayRef<Metadata *> MDs) {\n    return TempMDTuple(getImpl(Context, MDs, Temporary));\n  }\n\n  /// Return a (temporary) clone of this.\n  TempMDTuple clone() const { return cloneImpl(); }\n\n  static bool classof(const Metadata *MD) {\n    return MD->getMetadataID() == MDTupleKind;\n  }\n};\n\nMDTuple *MDNode::get(LLVMContext &Context, ArrayRef<Metadata *> MDs) {\n  return MDTuple::get(Context, MDs);\n}\n\nMDTuple *MDNode::getIfExists(LLVMContext &Context, ArrayRef<Metadata *> MDs) {\n  return MDTuple::getIfExists(Context, MDs);\n}\n\nMDTuple *MDNode::getDistinct(LLVMContext &Context, ArrayRef<Metadata *> MDs) {\n  return MDTuple::getDistinct(Context, MDs);\n}\n\nTempMDTuple MDNode::getTemporary(LLVMContext &Context,\n                                 ArrayRef<Metadata *> MDs) {\n  return MDTuple::getTemporary(Context, MDs);\n}\n\nvoid TempMDNodeDeleter::operator()(MDNode *Node) const {\n  MDNode::deleteTemporary(Node);\n}\n\n/// This is a simple wrapper around an MDNode which provides a higher-level\n/// interface by hiding the details of how alias analysis information is encoded\n/// in its operands.\nclass AliasScopeNode {\n  const MDNode *Node = nullptr;\n\npublic:\n  AliasScopeNode() = default;\n  explicit AliasScopeNode(const MDNode *N) : Node(N) {}\n\n  /// Get the MDNode for this AliasScopeNode.\n  const MDNode *getNode() const { return Node; }\n\n  /// Get the MDNode for this AliasScopeNode's domain.\n  const MDNode *getDomain() const {\n    if (Node->getNumOperands() < 2)\n      return nullptr;\n    return dyn_cast_or_null<MDNode>(Node->getOperand(1));\n  }\n  StringRef getName() const {\n    if (Node->getNumOperands() > 2)\n      if (MDString *N = dyn_cast_or_null<MDString>(Node->getOperand(2)))\n        return N->getString();\n    return StringRef();\n  }\n};\n\n/// Typed iterator through MDNode operands.\n///\n/// An iterator that transforms an \\a MDNode::iterator into an iterator over a\n/// particular Metadata subclass.\ntemplate <class T>\nclass TypedMDOperandIterator\n    : public std::iterator<std::input_iterator_tag, T *, std::ptrdiff_t, void,\n                           T *> {\n  MDNode::op_iterator I = nullptr;\n\npublic:\n  TypedMDOperandIterator() = default;\n  explicit TypedMDOperandIterator(MDNode::op_iterator I) : I(I) {}\n\n  T *operator*() const { return cast_or_null<T>(*I); }\n\n  TypedMDOperandIterator &operator++() {\n    ++I;\n    return *this;\n  }\n\n  TypedMDOperandIterator operator++(int) {\n    TypedMDOperandIterator Temp(*this);\n    ++I;\n    return Temp;\n  }\n\n  bool operator==(const TypedMDOperandIterator &X) const { return I == X.I; }\n  bool operator!=(const TypedMDOperandIterator &X) const { return I != X.I; }\n};\n\n/// Typed, array-like tuple of metadata.\n///\n/// This is a wrapper for \\a MDTuple that makes it act like an array holding a\n/// particular type of metadata.\ntemplate <class T> class MDTupleTypedArrayWrapper {\n  const MDTuple *N = nullptr;\n\npublic:\n  MDTupleTypedArrayWrapper() = default;\n  MDTupleTypedArrayWrapper(const MDTuple *N) : N(N) {}\n\n  template <class U>\n  MDTupleTypedArrayWrapper(\n      const MDTupleTypedArrayWrapper<U> &Other,\n      std::enable_if_t<std::is_convertible<U *, T *>::value> * = nullptr)\n      : N(Other.get()) {}\n\n  template <class U>\n  explicit MDTupleTypedArrayWrapper(\n      const MDTupleTypedArrayWrapper<U> &Other,\n      std::enable_if_t<!std::is_convertible<U *, T *>::value> * = nullptr)\n      : N(Other.get()) {}\n\n  explicit operator bool() const { return get(); }\n  explicit operator MDTuple *() const { return get(); }\n\n  MDTuple *get() const { return const_cast<MDTuple *>(N); }\n  MDTuple *operator->() const { return get(); }\n  MDTuple &operator*() const { return *get(); }\n\n  // FIXME: Fix callers and remove condition on N.\n  unsigned size() const { return N ? N->getNumOperands() : 0u; }\n  bool empty() const { return N ? N->getNumOperands() == 0 : true; }\n  T *operator[](unsigned I) const { return cast_or_null<T>(N->getOperand(I)); }\n\n  // FIXME: Fix callers and remove condition on N.\n  using iterator = TypedMDOperandIterator<T>;\n\n  iterator begin() const { return N ? iterator(N->op_begin()) : iterator(); }\n  iterator end() const { return N ? iterator(N->op_end()) : iterator(); }\n};\n\n#define HANDLE_METADATA(CLASS)                                                 \\\n  using CLASS##Array = MDTupleTypedArrayWrapper<CLASS>;\n#include \"llvm/IR/Metadata.def\"\n\n/// Placeholder metadata for operands of distinct MDNodes.\n///\n/// This is a lightweight placeholder for an operand of a distinct node.  It's\n/// purpose is to help track forward references when creating a distinct node.\n/// This allows distinct nodes involved in a cycle to be constructed before\n/// their operands without requiring a heavyweight temporary node with\n/// full-blown RAUW support.\n///\n/// Each placeholder supports only a single MDNode user.  Clients should pass\n/// an ID, retrieved via \\a getID(), to indicate the \"real\" operand that this\n/// should be replaced with.\n///\n/// While it would be possible to implement move operators, they would be\n/// fairly expensive.  Leave them unimplemented to discourage their use\n/// (clients can use std::deque, std::list, BumpPtrAllocator, etc.).\nclass DistinctMDOperandPlaceholder : public Metadata {\n  friend class MetadataTracking;\n\n  Metadata **Use = nullptr;\n\npublic:\n  explicit DistinctMDOperandPlaceholder(unsigned ID)\n      : Metadata(DistinctMDOperandPlaceholderKind, Distinct) {\n    SubclassData32 = ID;\n  }\n\n  DistinctMDOperandPlaceholder() = delete;\n  DistinctMDOperandPlaceholder(DistinctMDOperandPlaceholder &&) = delete;\n  DistinctMDOperandPlaceholder(const DistinctMDOperandPlaceholder &) = delete;\n\n  ~DistinctMDOperandPlaceholder() {\n    if (Use)\n      *Use = nullptr;\n  }\n\n  unsigned getID() const { return SubclassData32; }\n\n  /// Replace the use of this with MD.\n  void replaceUseWith(Metadata *MD) {\n    if (!Use)\n      return;\n    *Use = MD;\n\n    if (*Use)\n      MetadataTracking::track(*Use);\n\n    Metadata *T = cast<Metadata>(this);\n    MetadataTracking::untrack(T);\n    assert(!Use && \"Use is still being tracked despite being untracked!\");\n  }\n};\n\n//===----------------------------------------------------------------------===//\n/// A tuple of MDNodes.\n///\n/// Despite its name, a NamedMDNode isn't itself an MDNode.\n///\n/// NamedMDNodes are named module-level entities that contain lists of MDNodes.\n///\n/// It is illegal for a NamedMDNode to appear as an operand of an MDNode.\nclass NamedMDNode : public ilist_node<NamedMDNode> {\n  friend class LLVMContextImpl;\n  friend class Module;\n\n  std::string Name;\n  Module *Parent = nullptr;\n  void *Operands; // SmallVector<TrackingMDRef, 4>\n\n  void setParent(Module *M) { Parent = M; }\n\n  explicit NamedMDNode(const Twine &N);\n\n  template<class T1, class T2>\n  class op_iterator_impl :\n      public std::iterator<std::bidirectional_iterator_tag, T2> {\n    friend class NamedMDNode;\n\n    const NamedMDNode *Node = nullptr;\n    unsigned Idx = 0;\n\n    op_iterator_impl(const NamedMDNode *N, unsigned i) : Node(N), Idx(i) {}\n\n  public:\n    op_iterator_impl() = default;\n\n    bool operator==(const op_iterator_impl &o) const { return Idx == o.Idx; }\n    bool operator!=(const op_iterator_impl &o) const { return Idx != o.Idx; }\n\n    op_iterator_impl &operator++() {\n      ++Idx;\n      return *this;\n    }\n\n    op_iterator_impl operator++(int) {\n      op_iterator_impl tmp(*this);\n      operator++();\n      return tmp;\n    }\n\n    op_iterator_impl &operator--() {\n      --Idx;\n      return *this;\n    }\n\n    op_iterator_impl operator--(int) {\n      op_iterator_impl tmp(*this);\n      operator--();\n      return tmp;\n    }\n\n    T1 operator*() const { return Node->getOperand(Idx); }\n  };\n\npublic:\n  NamedMDNode(const NamedMDNode &) = delete;\n  ~NamedMDNode();\n\n  /// Drop all references and remove the node from parent module.\n  void eraseFromParent();\n\n  /// Remove all uses and clear node vector.\n  void dropAllReferences() { clearOperands(); }\n  /// Drop all references to this node's operands.\n  void clearOperands();\n\n  /// Get the module that holds this named metadata collection.\n  inline Module *getParent() { return Parent; }\n  inline const Module *getParent() const { return Parent; }\n\n  MDNode *getOperand(unsigned i) const;\n  unsigned getNumOperands() const;\n  void addOperand(MDNode *M);\n  void setOperand(unsigned I, MDNode *New);\n  StringRef getName() const;\n  void print(raw_ostream &ROS, bool IsForDebug = false) const;\n  void print(raw_ostream &ROS, ModuleSlotTracker &MST,\n             bool IsForDebug = false) const;\n  void dump() const;\n\n  // ---------------------------------------------------------------------------\n  // Operand Iterator interface...\n  //\n  using op_iterator = op_iterator_impl<MDNode *, MDNode>;\n\n  op_iterator op_begin() { return op_iterator(this, 0); }\n  op_iterator op_end()   { return op_iterator(this, getNumOperands()); }\n\n  using const_op_iterator = op_iterator_impl<const MDNode *, MDNode>;\n\n  const_op_iterator op_begin() const { return const_op_iterator(this, 0); }\n  const_op_iterator op_end()   const { return const_op_iterator(this, getNumOperands()); }\n\n  inline iterator_range<op_iterator>  operands() {\n    return make_range(op_begin(), op_end());\n  }\n  inline iterator_range<const_op_iterator> operands() const {\n    return make_range(op_begin(), op_end());\n  }\n};\n\n// Create wrappers for C Binding types (see CBindingWrapping.h).\nDEFINE_ISA_CONVERSION_FUNCTIONS(NamedMDNode, LLVMNamedMDNodeRef)\n\n} // end namespace llvm\n\n#endif // LLVM_IR_METADATA_H\n"}, "43": {"id": 43, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/IR/Module.h", "content": "//===- llvm/Module.h - C++ class to represent a VM module -------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n/// @file\n/// Module.h This file contains the declarations for the Module class.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_IR_MODULE_H\n#define LLVM_IR_MODULE_H\n\n#include \"llvm-c/Types.h\"\n#include \"llvm/ADT/Optional.h\"\n#include \"llvm/ADT/STLExtras.h\"\n#include \"llvm/ADT/StringMap.h\"\n#include \"llvm/ADT/StringRef.h\"\n#include \"llvm/ADT/iterator_range.h\"\n#include \"llvm/IR/Attributes.h\"\n#include \"llvm/IR/Comdat.h\"\n#include \"llvm/IR/DataLayout.h\"\n#include \"llvm/IR/Function.h\"\n#include \"llvm/IR/GlobalAlias.h\"\n#include \"llvm/IR/GlobalIFunc.h\"\n#include \"llvm/IR/GlobalVariable.h\"\n#include \"llvm/IR/Metadata.h\"\n#include \"llvm/IR/ProfileSummary.h\"\n#include \"llvm/IR/SymbolTableListTraits.h\"\n#include \"llvm/Support/CBindingWrapping.h\"\n#include \"llvm/Support/CodeGen.h\"\n#include <cstddef>\n#include <cstdint>\n#include <iterator>\n#include <memory>\n#include <string>\n#include <vector>\n\nnamespace llvm {\n\nclass Error;\nclass FunctionType;\nclass GVMaterializer;\nclass LLVMContext;\nclass MemoryBuffer;\nclass ModuleSummaryIndex;\nclass Pass;\nclass RandomNumberGenerator;\ntemplate <class PtrType> class SmallPtrSetImpl;\nclass StructType;\nclass VersionTuple;\n\n/// A Module instance is used to store all the information related to an\n/// LLVM module. Modules are the top level container of all other LLVM\n/// Intermediate Representation (IR) objects. Each module directly contains a\n/// list of globals variables, a list of functions, a list of libraries (or\n/// other modules) this module depends on, a symbol table, and various data\n/// about the target's characteristics.\n///\n/// A module maintains a GlobalValRefMap object that is used to hold all\n/// constant references to global variables in the module.  When a global\n/// variable is destroyed, it should have no entries in the GlobalValueRefMap.\n/// The main container class for the LLVM Intermediate Representation.\nclass Module {\n/// @name Types And Enumerations\n/// @{\npublic:\n  /// The type for the list of global variables.\n  using GlobalListType = SymbolTableList<GlobalVariable>;\n  /// The type for the list of functions.\n  using FunctionListType = SymbolTableList<Function>;\n  /// The type for the list of aliases.\n  using AliasListType = SymbolTableList<GlobalAlias>;\n  /// The type for the list of ifuncs.\n  using IFuncListType = SymbolTableList<GlobalIFunc>;\n  /// The type for the list of named metadata.\n  using NamedMDListType = ilist<NamedMDNode>;\n  /// The type of the comdat \"symbol\" table.\n  using ComdatSymTabType = StringMap<Comdat>;\n  /// The type for mapping names to named metadata.\n  using NamedMDSymTabType = StringMap<NamedMDNode *>;\n\n  /// The Global Variable iterator.\n  using global_iterator = GlobalListType::iterator;\n  /// The Global Variable constant iterator.\n  using const_global_iterator = GlobalListType::const_iterator;\n\n  /// The Function iterators.\n  using iterator = FunctionListType::iterator;\n  /// The Function constant iterator\n  using const_iterator = FunctionListType::const_iterator;\n\n  /// The Function reverse iterator.\n  using reverse_iterator = FunctionListType::reverse_iterator;\n  /// The Function constant reverse iterator.\n  using const_reverse_iterator = FunctionListType::const_reverse_iterator;\n\n  /// The Global Alias iterators.\n  using alias_iterator = AliasListType::iterator;\n  /// The Global Alias constant iterator\n  using const_alias_iterator = AliasListType::const_iterator;\n\n  /// The Global IFunc iterators.\n  using ifunc_iterator = IFuncListType::iterator;\n  /// The Global IFunc constant iterator\n  using const_ifunc_iterator = IFuncListType::const_iterator;\n\n  /// The named metadata iterators.\n  using named_metadata_iterator = NamedMDListType::iterator;\n  /// The named metadata constant iterators.\n  using const_named_metadata_iterator = NamedMDListType::const_iterator;\n\n  /// This enumeration defines the supported behaviors of module flags.\n  enum ModFlagBehavior {\n    /// Emits an error if two values disagree, otherwise the resulting value is\n    /// that of the operands.\n    Error = 1,\n\n    /// Emits a warning if two values disagree. The result value will be the\n    /// operand for the flag from the first module being linked.\n    Warning = 2,\n\n    /// Adds a requirement that another module flag be present and have a\n    /// specified value after linking is performed. The value must be a metadata\n    /// pair, where the first element of the pair is the ID of the module flag\n    /// to be restricted, and the second element of the pair is the value the\n    /// module flag should be restricted to. This behavior can be used to\n    /// restrict the allowable results (via triggering of an error) of linking\n    /// IDs with the **Override** behavior.\n    Require = 3,\n\n    /// Uses the specified value, regardless of the behavior or value of the\n    /// other module. If both modules specify **Override**, but the values\n    /// differ, an error will be emitted.\n    Override = 4,\n\n    /// Appends the two values, which are required to be metadata nodes.\n    Append = 5,\n\n    /// Appends the two values, which are required to be metadata\n    /// nodes. However, duplicate entries in the second list are dropped\n    /// during the append operation.\n    AppendUnique = 6,\n\n    /// Takes the max of the two values, which are required to be integers.\n    Max = 7,\n\n    // Markers:\n    ModFlagBehaviorFirstVal = Error,\n    ModFlagBehaviorLastVal = Max\n  };\n\n  /// Checks if Metadata represents a valid ModFlagBehavior, and stores the\n  /// converted result in MFB.\n  static bool isValidModFlagBehavior(Metadata *MD, ModFlagBehavior &MFB);\n\n  /// Check if the given module flag metadata represents a valid module flag,\n  /// and store the flag behavior, the key string and the value metadata.\n  static bool isValidModuleFlag(const MDNode &ModFlag, ModFlagBehavior &MFB,\n                                MDString *&Key, Metadata *&Val);\n\n  struct ModuleFlagEntry {\n    ModFlagBehavior Behavior;\n    MDString *Key;\n    Metadata *Val;\n\n    ModuleFlagEntry(ModFlagBehavior B, MDString *K, Metadata *V)\n        : Behavior(B), Key(K), Val(V) {}\n  };\n\n/// @}\n/// @name Member Variables\n/// @{\nprivate:\n  LLVMContext &Context;           ///< The LLVMContext from which types and\n                                  ///< constants are allocated.\n  GlobalListType GlobalList;      ///< The Global Variables in the module\n  FunctionListType FunctionList;  ///< The Functions in the module\n  AliasListType AliasList;        ///< The Aliases in the module\n  IFuncListType IFuncList;        ///< The IFuncs in the module\n  NamedMDListType NamedMDList;    ///< The named metadata in the module\n  std::string GlobalScopeAsm;     ///< Inline Asm at global scope.\n  std::unique_ptr<ValueSymbolTable> ValSymTab; ///< Symbol table for values\n  ComdatSymTabType ComdatSymTab;  ///< Symbol table for COMDATs\n  std::unique_ptr<MemoryBuffer>\n  OwnedMemoryBuffer;              ///< Memory buffer directly owned by this\n                                  ///< module, for legacy clients only.\n  std::unique_ptr<GVMaterializer>\n  Materializer;                   ///< Used to materialize GlobalValues\n  std::string ModuleID;           ///< Human readable identifier for the module\n  std::string SourceFileName;     ///< Original source file name for module,\n                                  ///< recorded in bitcode.\n  std::string TargetTriple;       ///< Platform target triple Module compiled on\n                                  ///< Format: (arch)(sub)-(vendor)-(sys0-(abi)\n  NamedMDSymTabType NamedMDSymTab;  ///< NamedMDNode names.\n  DataLayout DL;                  ///< DataLayout associated with the module\n\n  friend class Constant;\n\n/// @}\n/// @name Constructors\n/// @{\npublic:\n  /// The Module constructor. Note that there is no default constructor. You\n  /// must provide a name for the module upon construction.\n  explicit Module(StringRef ModuleID, LLVMContext& C);\n  /// The module destructor. This will dropAllReferences.\n  ~Module();\n\n/// @}\n/// @name Module Level Accessors\n/// @{\n\n  /// Get the module identifier which is, essentially, the name of the module.\n  /// @returns the module identifier as a string\n  const std::string &getModuleIdentifier() const { return ModuleID; }\n\n  /// Returns the number of non-debug IR instructions in the module.\n  /// This is equivalent to the sum of the IR instruction counts of each\n  /// function contained in the module.\n  unsigned getInstructionCount();\n\n  /// Get the module's original source file name. When compiling from\n  /// bitcode, this is taken from a bitcode record where it was recorded.\n  /// For other compiles it is the same as the ModuleID, which would\n  /// contain the source file name.\n  const std::string &getSourceFileName() const { return SourceFileName; }\n\n  /// Get a short \"name\" for the module.\n  ///\n  /// This is useful for debugging or logging. It is essentially a convenience\n  /// wrapper around getModuleIdentifier().\n  StringRef getName() const { return ModuleID; }\n\n  /// Get the data layout string for the module's target platform. This is\n  /// equivalent to getDataLayout()->getStringRepresentation().\n  const std::string &getDataLayoutStr() const {\n    return DL.getStringRepresentation();\n  }\n\n  /// Get the data layout for the module's target platform.\n  const DataLayout &getDataLayout() const;\n\n  /// Get the target triple which is a string describing the target host.\n  /// @returns a string containing the target triple.\n  const std::string &getTargetTriple() const { return TargetTriple; }\n\n  /// Get the global data context.\n  /// @returns LLVMContext - a container for LLVM's global information\n  LLVMContext &getContext() const { return Context; }\n\n  /// Get any module-scope inline assembly blocks.\n  /// @returns a string containing the module-scope inline assembly blocks.\n  const std::string &getModuleInlineAsm() const { return GlobalScopeAsm; }\n\n  /// Get a RandomNumberGenerator salted for use with this module. The\n  /// RNG can be seeded via -rng-seed=<uint64> and is salted with the\n  /// ModuleID and the provided pass salt. The returned RNG should not\n  /// be shared across threads or passes.\n  ///\n  /// A unique RNG per pass ensures a reproducible random stream even\n  /// when other randomness consuming passes are added or removed. In\n  /// addition, the random stream will be reproducible across LLVM\n  /// versions when the pass does not change.\n  std::unique_ptr<RandomNumberGenerator> createRNG(const StringRef Name) const;\n\n  /// Return true if size-info optimization remark is enabled, false\n  /// otherwise.\n  bool shouldEmitInstrCountChangedRemark() {\n    return getContext().getDiagHandlerPtr()->isAnalysisRemarkEnabled(\n        \"size-info\");\n  }\n\n  /// @}\n  /// @name Module Level Mutators\n  /// @{\n\n  /// Set the module identifier.\n  void setModuleIdentifier(StringRef ID) { ModuleID = std::string(ID); }\n\n  /// Set the module's original source file name.\n  void setSourceFileName(StringRef Name) { SourceFileName = std::string(Name); }\n\n  /// Set the data layout\n  void setDataLayout(StringRef Desc);\n  void setDataLayout(const DataLayout &Other);\n\n  /// Set the target triple.\n  void setTargetTriple(StringRef T) { TargetTriple = std::string(T); }\n\n  /// Set the module-scope inline assembly blocks.\n  /// A trailing newline is added if the input doesn't have one.\n  void setModuleInlineAsm(StringRef Asm) {\n    GlobalScopeAsm = std::string(Asm);\n    if (!GlobalScopeAsm.empty() && GlobalScopeAsm.back() != '\\n')\n      GlobalScopeAsm += '\\n';\n  }\n\n  /// Append to the module-scope inline assembly blocks.\n  /// A trailing newline is added if the input doesn't have one.\n  void appendModuleInlineAsm(StringRef Asm) {\n    GlobalScopeAsm += Asm;\n    if (!GlobalScopeAsm.empty() && GlobalScopeAsm.back() != '\\n')\n      GlobalScopeAsm += '\\n';\n  }\n\n/// @}\n/// @name Generic Value Accessors\n/// @{\n\n  /// Return the global value in the module with the specified name, of\n  /// arbitrary type. This method returns null if a global with the specified\n  /// name is not found.\n  GlobalValue *getNamedValue(StringRef Name) const;\n\n  /// Return a unique non-zero ID for the specified metadata kind. This ID is\n  /// uniqued across modules in the current LLVMContext.\n  unsigned getMDKindID(StringRef Name) const;\n\n  /// Populate client supplied SmallVector with the name for custom metadata IDs\n  /// registered in this LLVMContext.\n  void getMDKindNames(SmallVectorImpl<StringRef> &Result) const;\n\n  /// Populate client supplied SmallVector with the bundle tags registered in\n  /// this LLVMContext.  The bundle tags are ordered by increasing bundle IDs.\n  /// \\see LLVMContext::getOperandBundleTagID\n  void getOperandBundleTags(SmallVectorImpl<StringRef> &Result) const;\n\n  std::vector<StructType *> getIdentifiedStructTypes() const;\n\n/// @}\n/// @name Function Accessors\n/// @{\n\n  /// Look up the specified function in the module symbol table. Four\n  /// possibilities:\n  ///   1. If it does not exist, add a prototype for the function and return it.\n  ///   2. Otherwise, if the existing function has the correct prototype, return\n  ///      the existing function.\n  ///   3. Finally, the function exists but has the wrong prototype: return the\n  ///      function with a constantexpr cast to the right prototype.\n  ///\n  /// In all cases, the returned value is a FunctionCallee wrapper around the\n  /// 'FunctionType *T' passed in, as well as a 'Value*' either of the Function or\n  /// the bitcast to the function.\n  FunctionCallee getOrInsertFunction(StringRef Name, FunctionType *T,\n                                     AttributeList AttributeList);\n\n  FunctionCallee getOrInsertFunction(StringRef Name, FunctionType *T);\n\n  /// Look up the specified function in the module symbol table. If it does not\n  /// exist, add a prototype for the function and return it. This function\n  /// guarantees to return a constant of pointer to the specified function type\n  /// or a ConstantExpr BitCast of that type if the named function has a\n  /// different type. This version of the method takes a list of\n  /// function arguments, which makes it easier for clients to use.\n  template <typename... ArgsTy>\n  FunctionCallee getOrInsertFunction(StringRef Name,\n                                     AttributeList AttributeList, Type *RetTy,\n                                     ArgsTy... Args) {\n    SmallVector<Type*, sizeof...(ArgsTy)> ArgTys{Args...};\n    return getOrInsertFunction(Name,\n                               FunctionType::get(RetTy, ArgTys, false),\n                               AttributeList);\n  }\n\n  /// Same as above, but without the attributes.\n  template <typename... ArgsTy>\n  FunctionCallee getOrInsertFunction(StringRef Name, Type *RetTy,\n                                     ArgsTy... Args) {\n    return getOrInsertFunction(Name, AttributeList{}, RetTy, Args...);\n  }\n\n  // Avoid an incorrect ordering that'd otherwise compile incorrectly.\n  template <typename... ArgsTy>\n  FunctionCallee\n  getOrInsertFunction(StringRef Name, AttributeList AttributeList,\n                      FunctionType *Invalid, ArgsTy... Args) = delete;\n\n  /// Look up the specified function in the module symbol table. If it does not\n  /// exist, return null.\n  Function *getFunction(StringRef Name) const;\n\n/// @}\n/// @name Global Variable Accessors\n/// @{\n\n  /// Look up the specified global variable in the module symbol table. If it\n  /// does not exist, return null. If AllowInternal is set to true, this\n  /// function will return types that have InternalLinkage. By default, these\n  /// types are not returned.\n  GlobalVariable *getGlobalVariable(StringRef Name) const {\n    return getGlobalVariable(Name, false);\n  }\n\n  GlobalVariable *getGlobalVariable(StringRef Name, bool AllowInternal) const;\n\n  GlobalVariable *getGlobalVariable(StringRef Name,\n                                    bool AllowInternal = false) {\n    return static_cast<const Module *>(this)->getGlobalVariable(Name,\n                                                                AllowInternal);\n  }\n\n  /// Return the global variable in the module with the specified name, of\n  /// arbitrary type. This method returns null if a global with the specified\n  /// name is not found.\n  const GlobalVariable *getNamedGlobal(StringRef Name) const {\n    return getGlobalVariable(Name, true);\n  }\n  GlobalVariable *getNamedGlobal(StringRef Name) {\n    return const_cast<GlobalVariable *>(\n                       static_cast<const Module *>(this)->getNamedGlobal(Name));\n  }\n\n  /// Look up the specified global in the module symbol table.\n  /// If it does not exist, invoke a callback to create a declaration of the\n  /// global and return it. The global is constantexpr casted to the expected\n  /// type if necessary.\n  Constant *\n  getOrInsertGlobal(StringRef Name, Type *Ty,\n                    function_ref<GlobalVariable *()> CreateGlobalCallback);\n\n  /// Look up the specified global in the module symbol table. If required, this\n  /// overload constructs the global variable using its constructor's defaults.\n  Constant *getOrInsertGlobal(StringRef Name, Type *Ty);\n\n/// @}\n/// @name Global Alias Accessors\n/// @{\n\n  /// Return the global alias in the module with the specified name, of\n  /// arbitrary type. This method returns null if a global with the specified\n  /// name is not found.\n  GlobalAlias *getNamedAlias(StringRef Name) const;\n\n/// @}\n/// @name Global IFunc Accessors\n/// @{\n\n  /// Return the global ifunc in the module with the specified name, of\n  /// arbitrary type. This method returns null if a global with the specified\n  /// name is not found.\n  GlobalIFunc *getNamedIFunc(StringRef Name) const;\n\n/// @}\n/// @name Named Metadata Accessors\n/// @{\n\n  /// Return the first NamedMDNode in the module with the specified name. This\n  /// method returns null if a NamedMDNode with the specified name is not found.\n  NamedMDNode *getNamedMetadata(const Twine &Name) const;\n\n  /// Return the named MDNode in the module with the specified name. This method\n  /// returns a new NamedMDNode if a NamedMDNode with the specified name is not\n  /// found.\n  NamedMDNode *getOrInsertNamedMetadata(StringRef Name);\n\n  /// Remove the given NamedMDNode from this module and delete it.\n  void eraseNamedMetadata(NamedMDNode *NMD);\n\n/// @}\n/// @name Comdat Accessors\n/// @{\n\n  /// Return the Comdat in the module with the specified name. It is created\n  /// if it didn't already exist.\n  Comdat *getOrInsertComdat(StringRef Name);\n\n/// @}\n/// @name Module Flags Accessors\n/// @{\n\n  /// Returns the module flags in the provided vector.\n  void getModuleFlagsMetadata(SmallVectorImpl<ModuleFlagEntry> &Flags) const;\n\n  /// Return the corresponding value if Key appears in module flags, otherwise\n  /// return null.\n  Metadata *getModuleFlag(StringRef Key) const;\n\n  /// Returns the NamedMDNode in the module that represents module-level flags.\n  /// This method returns null if there are no module-level flags.\n  NamedMDNode *getModuleFlagsMetadata() const;\n\n  /// Returns the NamedMDNode in the module that represents module-level flags.\n  /// If module-level flags aren't found, it creates the named metadata that\n  /// contains them.\n  NamedMDNode *getOrInsertModuleFlagsMetadata();\n\n  /// Add a module-level flag to the module-level flags metadata. It will create\n  /// the module-level flags named metadata if it doesn't already exist.\n  void addModuleFlag(ModFlagBehavior Behavior, StringRef Key, Metadata *Val);\n  void addModuleFlag(ModFlagBehavior Behavior, StringRef Key, Constant *Val);\n  void addModuleFlag(ModFlagBehavior Behavior, StringRef Key, uint32_t Val);\n  void addModuleFlag(MDNode *Node);\n  /// Like addModuleFlag but replaces the old module flag if it already exists.\n  void setModuleFlag(ModFlagBehavior Behavior, StringRef Key, Metadata *Val);\n\n  /// @}\n  /// @name Materialization\n  /// @{\n\n  /// Sets the GVMaterializer to GVM. This module must not yet have a\n  /// Materializer. To reset the materializer for a module that already has one,\n  /// call materializeAll first. Destroying this module will destroy\n  /// its materializer without materializing any more GlobalValues. Without\n  /// destroying the Module, there is no way to detach or destroy a materializer\n  /// without materializing all the GVs it controls, to avoid leaving orphan\n  /// unmaterialized GVs.\n  void setMaterializer(GVMaterializer *GVM);\n  /// Retrieves the GVMaterializer, if any, for this Module.\n  GVMaterializer *getMaterializer() const { return Materializer.get(); }\n  bool isMaterialized() const { return !getMaterializer(); }\n\n  /// Make sure the GlobalValue is fully read.\n  llvm::Error materialize(GlobalValue *GV);\n\n  /// Make sure all GlobalValues in this Module are fully read and clear the\n  /// Materializer.\n  llvm::Error materializeAll();\n\n  llvm::Error materializeMetadata();\n\n/// @}\n/// @name Direct access to the globals list, functions list, and symbol table\n/// @{\n\n  /// Get the Module's list of global variables (constant).\n  const GlobalListType   &getGlobalList() const       { return GlobalList; }\n  /// Get the Module's list of global variables.\n  GlobalListType         &getGlobalList()             { return GlobalList; }\n\n  static GlobalListType Module::*getSublistAccess(GlobalVariable*) {\n    return &Module::GlobalList;\n  }\n\n  /// Get the Module's list of functions (constant).\n  const FunctionListType &getFunctionList() const     { return FunctionList; }\n  /// Get the Module's list of functions.\n  FunctionListType       &getFunctionList()           { return FunctionList; }\n  static FunctionListType Module::*getSublistAccess(Function*) {\n    return &Module::FunctionList;\n  }\n\n  /// Get the Module's list of aliases (constant).\n  const AliasListType    &getAliasList() const        { return AliasList; }\n  /// Get the Module's list of aliases.\n  AliasListType          &getAliasList()              { return AliasList; }\n\n  static AliasListType Module::*getSublistAccess(GlobalAlias*) {\n    return &Module::AliasList;\n  }\n\n  /// Get the Module's list of ifuncs (constant).\n  const IFuncListType    &getIFuncList() const        { return IFuncList; }\n  /// Get the Module's list of ifuncs.\n  IFuncListType          &getIFuncList()              { return IFuncList; }\n\n  static IFuncListType Module::*getSublistAccess(GlobalIFunc*) {\n    return &Module::IFuncList;\n  }\n\n  /// Get the Module's list of named metadata (constant).\n  const NamedMDListType  &getNamedMDList() const      { return NamedMDList; }\n  /// Get the Module's list of named metadata.\n  NamedMDListType        &getNamedMDList()            { return NamedMDList; }\n\n  static NamedMDListType Module::*getSublistAccess(NamedMDNode*) {\n    return &Module::NamedMDList;\n  }\n\n  /// Get the symbol table of global variable and function identifiers\n  const ValueSymbolTable &getValueSymbolTable() const { return *ValSymTab; }\n  /// Get the Module's symbol table of global variable and function identifiers.\n  ValueSymbolTable       &getValueSymbolTable()       { return *ValSymTab; }\n\n  /// Get the Module's symbol table for COMDATs (constant).\n  const ComdatSymTabType &getComdatSymbolTable() const { return ComdatSymTab; }\n  /// Get the Module's symbol table for COMDATs.\n  ComdatSymTabType &getComdatSymbolTable() { return ComdatSymTab; }\n\n/// @}\n/// @name Global Variable Iteration\n/// @{\n\n  global_iterator       global_begin()       { return GlobalList.begin(); }\n  const_global_iterator global_begin() const { return GlobalList.begin(); }\n  global_iterator       global_end  ()       { return GlobalList.end(); }\n  const_global_iterator global_end  () const { return GlobalList.end(); }\n  size_t                global_size () const { return GlobalList.size(); }\n  bool                  global_empty() const { return GlobalList.empty(); }\n\n  iterator_range<global_iterator> globals() {\n    return make_range(global_begin(), global_end());\n  }\n  iterator_range<const_global_iterator> globals() const {\n    return make_range(global_begin(), global_end());\n  }\n\n/// @}\n/// @name Function Iteration\n/// @{\n\n  iterator                begin()       { return FunctionList.begin(); }\n  const_iterator          begin() const { return FunctionList.begin(); }\n  iterator                end  ()       { return FunctionList.end();   }\n  const_iterator          end  () const { return FunctionList.end();   }\n  reverse_iterator        rbegin()      { return FunctionList.rbegin(); }\n  const_reverse_iterator  rbegin() const{ return FunctionList.rbegin(); }\n  reverse_iterator        rend()        { return FunctionList.rend(); }\n  const_reverse_iterator  rend() const  { return FunctionList.rend(); }\n  size_t                  size() const  { return FunctionList.size(); }\n  bool                    empty() const { return FunctionList.empty(); }\n\n  iterator_range<iterator> functions() {\n    return make_range(begin(), end());\n  }\n  iterator_range<const_iterator> functions() const {\n    return make_range(begin(), end());\n  }\n\n/// @}\n/// @name Alias Iteration\n/// @{\n\n  alias_iterator       alias_begin()            { return AliasList.begin(); }\n  const_alias_iterator alias_begin() const      { return AliasList.begin(); }\n  alias_iterator       alias_end  ()            { return AliasList.end();   }\n  const_alias_iterator alias_end  () const      { return AliasList.end();   }\n  size_t               alias_size () const      { return AliasList.size();  }\n  bool                 alias_empty() const      { return AliasList.empty(); }\n\n  iterator_range<alias_iterator> aliases() {\n    return make_range(alias_begin(), alias_end());\n  }\n  iterator_range<const_alias_iterator> aliases() const {\n    return make_range(alias_begin(), alias_end());\n  }\n\n/// @}\n/// @name IFunc Iteration\n/// @{\n\n  ifunc_iterator       ifunc_begin()            { return IFuncList.begin(); }\n  const_ifunc_iterator ifunc_begin() const      { return IFuncList.begin(); }\n  ifunc_iterator       ifunc_end  ()            { return IFuncList.end();   }\n  const_ifunc_iterator ifunc_end  () const      { return IFuncList.end();   }\n  size_t               ifunc_size () const      { return IFuncList.size();  }\n  bool                 ifunc_empty() const      { return IFuncList.empty(); }\n\n  iterator_range<ifunc_iterator> ifuncs() {\n    return make_range(ifunc_begin(), ifunc_end());\n  }\n  iterator_range<const_ifunc_iterator> ifuncs() const {\n    return make_range(ifunc_begin(), ifunc_end());\n  }\n\n  /// @}\n  /// @name Convenience iterators\n  /// @{\n\n  using global_object_iterator =\n      concat_iterator<GlobalObject, iterator, global_iterator>;\n  using const_global_object_iterator =\n      concat_iterator<const GlobalObject, const_iterator,\n                      const_global_iterator>;\n\n  iterator_range<global_object_iterator> global_objects();\n  iterator_range<const_global_object_iterator> global_objects() const;\n\n  using global_value_iterator =\n      concat_iterator<GlobalValue, iterator, global_iterator, alias_iterator,\n                      ifunc_iterator>;\n  using const_global_value_iterator =\n      concat_iterator<const GlobalValue, const_iterator, const_global_iterator,\n                      const_alias_iterator, const_ifunc_iterator>;\n\n  iterator_range<global_value_iterator> global_values();\n  iterator_range<const_global_value_iterator> global_values() const;\n\n  /// @}\n  /// @name Named Metadata Iteration\n  /// @{\n\n  named_metadata_iterator named_metadata_begin() { return NamedMDList.begin(); }\n  const_named_metadata_iterator named_metadata_begin() const {\n    return NamedMDList.begin();\n  }\n\n  named_metadata_iterator named_metadata_end() { return NamedMDList.end(); }\n  const_named_metadata_iterator named_metadata_end() const {\n    return NamedMDList.end();\n  }\n\n  size_t named_metadata_size() const { return NamedMDList.size();  }\n  bool named_metadata_empty() const { return NamedMDList.empty(); }\n\n  iterator_range<named_metadata_iterator> named_metadata() {\n    return make_range(named_metadata_begin(), named_metadata_end());\n  }\n  iterator_range<const_named_metadata_iterator> named_metadata() const {\n    return make_range(named_metadata_begin(), named_metadata_end());\n  }\n\n  /// An iterator for DICompileUnits that skips those marked NoDebug.\n  class debug_compile_units_iterator\n      : public std::iterator<std::input_iterator_tag, DICompileUnit *> {\n    NamedMDNode *CUs;\n    unsigned Idx;\n\n    void SkipNoDebugCUs();\n\n  public:\n    explicit debug_compile_units_iterator(NamedMDNode *CUs, unsigned Idx)\n        : CUs(CUs), Idx(Idx) {\n      SkipNoDebugCUs();\n    }\n\n    debug_compile_units_iterator &operator++() {\n      ++Idx;\n      SkipNoDebugCUs();\n      return *this;\n    }\n\n    debug_compile_units_iterator operator++(int) {\n      debug_compile_units_iterator T(*this);\n      ++Idx;\n      return T;\n    }\n\n    bool operator==(const debug_compile_units_iterator &I) const {\n      return Idx == I.Idx;\n    }\n\n    bool operator!=(const debug_compile_units_iterator &I) const {\n      return Idx != I.Idx;\n    }\n\n    DICompileUnit *operator*() const;\n    DICompileUnit *operator->() const;\n  };\n\n  debug_compile_units_iterator debug_compile_units_begin() const {\n    auto *CUs = getNamedMetadata(\"llvm.dbg.cu\");\n    return debug_compile_units_iterator(CUs, 0);\n  }\n\n  debug_compile_units_iterator debug_compile_units_end() const {\n    auto *CUs = getNamedMetadata(\"llvm.dbg.cu\");\n    return debug_compile_units_iterator(CUs, CUs ? CUs->getNumOperands() : 0);\n  }\n\n  /// Return an iterator for all DICompileUnits listed in this Module's\n  /// llvm.dbg.cu named metadata node and aren't explicitly marked as\n  /// NoDebug.\n  iterator_range<debug_compile_units_iterator> debug_compile_units() const {\n    auto *CUs = getNamedMetadata(\"llvm.dbg.cu\");\n    return make_range(\n        debug_compile_units_iterator(CUs, 0),\n        debug_compile_units_iterator(CUs, CUs ? CUs->getNumOperands() : 0));\n  }\n/// @}\n\n  /// Destroy ConstantArrays in LLVMContext if they are not used.\n  /// ConstantArrays constructed during linking can cause quadratic memory\n  /// explosion. Releasing all unused constants can cause a 20% LTO compile-time\n  /// slowdown for a large application.\n  ///\n  /// NOTE: Constants are currently owned by LLVMContext. This can then only\n  /// be called where all uses of the LLVMContext are understood.\n  void dropTriviallyDeadConstantArrays();\n\n/// @name Utility functions for printing and dumping Module objects\n/// @{\n\n  /// Print the module to an output stream with an optional\n  /// AssemblyAnnotationWriter.  If \\c ShouldPreserveUseListOrder, then include\n  /// uselistorder directives so that use-lists can be recreated when reading\n  /// the assembly.\n  void print(raw_ostream &OS, AssemblyAnnotationWriter *AAW,\n             bool ShouldPreserveUseListOrder = false,\n             bool IsForDebug = false) const;\n\n  /// Dump the module to stderr (for debugging).\n  void dump() const;\n\n  /// This function causes all the subinstructions to \"let go\" of all references\n  /// that they are maintaining.  This allows one to 'delete' a whole class at\n  /// a time, even though there may be circular references... first all\n  /// references are dropped, and all use counts go to zero.  Then everything\n  /// is delete'd for real.  Note that no operations are valid on an object\n  /// that has \"dropped all references\", except operator delete.\n  void dropAllReferences();\n\n/// @}\n/// @name Utility functions for querying Debug information.\n/// @{\n\n  /// Returns the Number of Register ParametersDwarf Version by checking\n  /// module flags.\n  unsigned getNumberRegisterParameters() const;\n\n  /// Returns the Dwarf Version by checking module flags.\n  unsigned getDwarfVersion() const;\n\n  /// Returns the DWARF format by checking module flags.\n  bool isDwarf64() const;\n\n  /// Returns the CodeView Version by checking module flags.\n  /// Returns zero if not present in module.\n  unsigned getCodeViewFlag() const;\n\n/// @}\n/// @name Utility functions for querying and setting PIC level\n/// @{\n\n  /// Returns the PIC level (small or large model)\n  PICLevel::Level getPICLevel() const;\n\n  /// Set the PIC level (small or large model)\n  void setPICLevel(PICLevel::Level PL);\n/// @}\n\n/// @}\n/// @name Utility functions for querying and setting PIE level\n/// @{\n\n  /// Returns the PIE level (small or large model)\n  PIELevel::Level getPIELevel() const;\n\n  /// Set the PIE level (small or large model)\n  void setPIELevel(PIELevel::Level PL);\n/// @}\n\n  /// @}\n  /// @name Utility function for querying and setting code model\n  /// @{\n\n  /// Returns the code model (tiny, small, kernel, medium or large model)\n  Optional<CodeModel::Model> getCodeModel() const;\n\n  /// Set the code model (tiny, small, kernel, medium or large)\n  void setCodeModel(CodeModel::Model CL);\n  /// @}\n\n  /// @name Utility functions for querying and setting PGO summary\n  /// @{\n\n  /// Attach profile summary metadata to this module.\n  void setProfileSummary(Metadata *M, ProfileSummary::Kind Kind);\n\n  /// Returns profile summary metadata. When IsCS is true, use the context\n  /// sensitive profile summary.\n  Metadata *getProfileSummary(bool IsCS) const;\n  /// @}\n\n  /// Returns whether semantic interposition is to be respected.\n  bool getSemanticInterposition() const;\n\n  /// Set whether semantic interposition is to be respected.\n  void setSemanticInterposition(bool);\n\n  /// Returns true if PLT should be avoided for RTLib calls.\n  bool getRtLibUseGOT() const;\n\n  /// Set that PLT should be avoid for RTLib calls.\n  void setRtLibUseGOT();\n\n  /// @name Utility functions for querying and setting the build SDK version\n  /// @{\n\n  /// Attach a build SDK version metadata to this module.\n  void setSDKVersion(const VersionTuple &V);\n\n  /// Get the build SDK version metadata.\n  ///\n  /// An empty version is returned if no such metadata is attached.\n  VersionTuple getSDKVersion() const;\n  /// @}\n\n  /// Take ownership of the given memory buffer.\n  void setOwnedMemoryBuffer(std::unique_ptr<MemoryBuffer> MB);\n\n  /// Set the partial sample profile ratio in the profile summary module flag,\n  /// if applicable.\n  void setPartialSampleProfileRatio(const ModuleSummaryIndex &Index);\n};\n\n/// Given \"llvm.used\" or \"llvm.compiler.used\" as a global name, collect the\n/// initializer elements of that global in a SmallVector and return the global\n/// itself.\nGlobalVariable *collectUsedGlobalVariables(const Module &M,\n                                           SmallVectorImpl<GlobalValue *> &Vec,\n                                           bool CompilerUsed);\n\n/// An raw_ostream inserter for modules.\ninline raw_ostream &operator<<(raw_ostream &O, const Module &M) {\n  M.print(O, nullptr);\n  return O;\n}\n\n// Create wrappers for C Binding types (see CBindingWrapping.h).\nDEFINE_SIMPLE_CONVERSION_FUNCTIONS(Module, LLVMModuleRef)\n\n/* LLVMModuleProviderRef exists for historical reasons, but now just holds a\n * Module.\n */\ninline Module *unwrap(LLVMModuleProviderRef MP) {\n  return reinterpret_cast<Module*>(MP);\n}\n\n} // end namespace llvm\n\n#endif // LLVM_IR_MODULE_H\n"}, "44": {"id": 44, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/IR/PassInstrumentation.h", "content": "//===- llvm/IR/PassInstrumentation.h ----------------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n/// \\file\n///\n/// This file defines the Pass Instrumentation classes that provide\n/// instrumentation points into the pass execution by PassManager.\n///\n/// There are two main classes:\n///   - PassInstrumentation provides a set of instrumentation points for\n///     pass managers to call on.\n///\n///   - PassInstrumentationCallbacks registers callbacks and provides access\n///     to them for PassInstrumentation.\n///\n/// PassInstrumentation object is being used as a result of\n/// PassInstrumentationAnalysis (so it is intended to be easily copyable).\n///\n/// Intended scheme of use for Pass Instrumentation is as follows:\n///    - register instrumentation callbacks in PassInstrumentationCallbacks\n///      instance. PassBuilder provides helper for that.\n///\n///    - register PassInstrumentationAnalysis with all the PassManagers.\n///      PassBuilder handles that automatically when registering analyses.\n///\n///    - Pass Manager requests PassInstrumentationAnalysis from analysis manager\n///      and gets PassInstrumentation as its result.\n///\n///    - Pass Manager invokes PassInstrumentation entry points appropriately,\n///      passing StringRef identification (\"name\") of the pass currently being\n///      executed and IRUnit it works on. There can be different schemes of\n///      providing names in future, currently it is just a name() of the pass.\n///\n///    - PassInstrumentation wraps address of IRUnit into llvm::Any and passes\n///      control to all the registered callbacks. Note that we specifically wrap\n///      'const IRUnitT*' so as to avoid any accidental changes to IR in\n///      instrumenting callbacks.\n///\n///    - Some instrumentation points (BeforePass) allow to control execution\n///      of a pass. For those callbacks returning false means pass will not be\n///      executed.\n///\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_IR_PASSINSTRUMENTATION_H\n#define LLVM_IR_PASSINSTRUMENTATION_H\n\n#include \"llvm/ADT/Any.h\"\n#include \"llvm/ADT/FunctionExtras.h\"\n#include \"llvm/ADT/SmallVector.h\"\n#include \"llvm/ADT/StringMap.h\"\n#include <type_traits>\n\nnamespace llvm {\n\nclass PreservedAnalyses;\nclass StringRef;\n\n/// This class manages callbacks registration, as well as provides a way for\n/// PassInstrumentation to pass control to the registered callbacks.\nclass PassInstrumentationCallbacks {\npublic:\n  // Before/After callbacks accept IRUnits whenever appropriate, so they need\n  // to take them as constant pointers, wrapped with llvm::Any.\n  // For the case when IRUnit has been invalidated there is a different\n  // callback to use - AfterPassInvalidated.\n  // We call all BeforePassFuncs to determine if a pass should run or not.\n  // BeforeNonSkippedPassFuncs are called only if the pass should run.\n  // TODO: currently AfterPassInvalidated does not accept IRUnit, since passing\n  // already invalidated IRUnit is unsafe. There are ways to handle invalidated\n  // IRUnits in a safe way, and we might pursue that as soon as there is a\n  // useful instrumentation that needs it.\n  using BeforePassFunc = bool(StringRef, Any);\n  using BeforeSkippedPassFunc = void(StringRef, Any);\n  using BeforeNonSkippedPassFunc = void(StringRef, Any);\n  using AfterPassFunc = void(StringRef, Any, const PreservedAnalyses &);\n  using AfterPassInvalidatedFunc = void(StringRef, const PreservedAnalyses &);\n  using BeforeAnalysisFunc = void(StringRef, Any);\n  using AfterAnalysisFunc = void(StringRef, Any);\n\npublic:\n  PassInstrumentationCallbacks() {}\n\n  /// Copying PassInstrumentationCallbacks is not intended.\n  PassInstrumentationCallbacks(const PassInstrumentationCallbacks &) = delete;\n  void operator=(const PassInstrumentationCallbacks &) = delete;\n\n  template <typename CallableT>\n  void registerShouldRunOptionalPassCallback(CallableT C) {\n    ShouldRunOptionalPassCallbacks.emplace_back(std::move(C));\n  }\n\n  template <typename CallableT>\n  void registerBeforeSkippedPassCallback(CallableT C) {\n    BeforeSkippedPassCallbacks.emplace_back(std::move(C));\n  }\n\n  template <typename CallableT>\n  void registerBeforeNonSkippedPassCallback(CallableT C) {\n    BeforeNonSkippedPassCallbacks.emplace_back(std::move(C));\n  }\n\n  template <typename CallableT> void registerAfterPassCallback(CallableT C) {\n    AfterPassCallbacks.emplace_back(std::move(C));\n  }\n\n  template <typename CallableT>\n  void registerAfterPassInvalidatedCallback(CallableT C) {\n    AfterPassInvalidatedCallbacks.emplace_back(std::move(C));\n  }\n\n  template <typename CallableT>\n  void registerBeforeAnalysisCallback(CallableT C) {\n    BeforeAnalysisCallbacks.emplace_back(std::move(C));\n  }\n\n  template <typename CallableT>\n  void registerAfterAnalysisCallback(CallableT C) {\n    AfterAnalysisCallbacks.emplace_back(std::move(C));\n  }\n\n  /// Add a class name to pass name mapping for use by pass instrumentation.\n  void addClassToPassName(StringRef ClassName, StringRef PassName);\n  /// Get the pass name for a given pass class name.\n  StringRef getPassNameForClassName(StringRef ClassName);\n\nprivate:\n  friend class PassInstrumentation;\n\n  /// These are only run on passes that are not required. They return false when\n  /// an optional pass should be skipped.\n  SmallVector<llvm::unique_function<BeforePassFunc>, 4>\n      ShouldRunOptionalPassCallbacks;\n  /// These are run on passes that are skipped.\n  SmallVector<llvm::unique_function<BeforeSkippedPassFunc>, 4>\n      BeforeSkippedPassCallbacks;\n  /// These are run on passes that are about to be run.\n  SmallVector<llvm::unique_function<BeforeNonSkippedPassFunc>, 4>\n      BeforeNonSkippedPassCallbacks;\n  /// These are run on passes that have just run.\n  SmallVector<llvm::unique_function<AfterPassFunc>, 4> AfterPassCallbacks;\n  /// These are run passes that have just run on invalidated IR.\n  SmallVector<llvm::unique_function<AfterPassInvalidatedFunc>, 4>\n      AfterPassInvalidatedCallbacks;\n  /// These are run on analyses that are about to be run.\n  SmallVector<llvm::unique_function<BeforeAnalysisFunc>, 4>\n      BeforeAnalysisCallbacks;\n  /// These are run on analyses that have been run.\n  SmallVector<llvm::unique_function<AfterAnalysisFunc>, 4>\n      AfterAnalysisCallbacks;\n\n  StringMap<std::string> ClassToPassName;\n};\n\n/// This class provides instrumentation entry points for the Pass Manager,\n/// doing calls to callbacks registered in PassInstrumentationCallbacks.\nclass PassInstrumentation {\n  PassInstrumentationCallbacks *Callbacks;\n\n  // Template argument PassT of PassInstrumentation::runBeforePass could be two\n  // kinds: (1) a regular pass inherited from PassInfoMixin (happen when\n  // creating a adaptor pass for a regular pass); (2) a type-erased PassConcept\n  // created from (1). Here we want to make case (1) skippable unconditionally\n  // since they are regular passes. We call PassConcept::isRequired to decide\n  // for case (2).\n  template <typename PassT>\n  using has_required_t = decltype(std::declval<PassT &>().isRequired());\n\n  template <typename PassT>\n  static std::enable_if_t<is_detected<has_required_t, PassT>::value, bool>\n  isRequired(const PassT &Pass) {\n    return Pass.isRequired();\n  }\n  template <typename PassT>\n  static std::enable_if_t<!is_detected<has_required_t, PassT>::value, bool>\n  isRequired(const PassT &Pass) {\n    return false;\n  }\n\npublic:\n  /// Callbacks object is not owned by PassInstrumentation, its life-time\n  /// should at least match the life-time of corresponding\n  /// PassInstrumentationAnalysis (which usually is till the end of current\n  /// compilation).\n  PassInstrumentation(PassInstrumentationCallbacks *CB = nullptr)\n      : Callbacks(CB) {}\n\n  /// BeforePass instrumentation point - takes \\p Pass instance to be executed\n  /// and constant reference to IR it operates on. \\Returns true if pass is\n  /// allowed to be executed. These are only run on optional pass since required\n  /// passes must always be run. This allows these callbacks to print info when\n  /// they want to skip a pass.\n  template <typename IRUnitT, typename PassT>\n  bool runBeforePass(const PassT &Pass, const IRUnitT &IR) const {\n    if (!Callbacks)\n      return true;\n\n    bool ShouldRun = true;\n    if (!isRequired(Pass)) {\n      for (auto &C : Callbacks->ShouldRunOptionalPassCallbacks)\n        ShouldRun &= C(Pass.name(), llvm::Any(&IR));\n    }\n\n    if (ShouldRun) {\n      for (auto &C : Callbacks->BeforeNonSkippedPassCallbacks)\n        C(Pass.name(), llvm::Any(&IR));\n    } else {\n      for (auto &C : Callbacks->BeforeSkippedPassCallbacks)\n        C(Pass.name(), llvm::Any(&IR));\n    }\n\n    return ShouldRun;\n  }\n\n  /// AfterPass instrumentation point - takes \\p Pass instance that has\n  /// just been executed and constant reference to \\p IR it operates on.\n  /// \\p IR is guaranteed to be valid at this point.\n  template <typename IRUnitT, typename PassT>\n  void runAfterPass(const PassT &Pass, const IRUnitT &IR,\n                    const PreservedAnalyses &PA) const {\n    if (Callbacks)\n      for (auto &C : Callbacks->AfterPassCallbacks)\n        C(Pass.name(), llvm::Any(&IR), PA);\n  }\n\n  /// AfterPassInvalidated instrumentation point - takes \\p Pass instance\n  /// that has just been executed. For use when IR has been invalidated\n  /// by \\p Pass execution.\n  template <typename IRUnitT, typename PassT>\n  void runAfterPassInvalidated(const PassT &Pass,\n                               const PreservedAnalyses &PA) const {\n    if (Callbacks)\n      for (auto &C : Callbacks->AfterPassInvalidatedCallbacks)\n        C(Pass.name(), PA);\n  }\n\n  /// BeforeAnalysis instrumentation point - takes \\p Analysis instance\n  /// to be executed and constant reference to IR it operates on.\n  template <typename IRUnitT, typename PassT>\n  void runBeforeAnalysis(const PassT &Analysis, const IRUnitT &IR) const {\n    if (Callbacks)\n      for (auto &C : Callbacks->BeforeAnalysisCallbacks)\n        C(Analysis.name(), llvm::Any(&IR));\n  }\n\n  /// AfterAnalysis instrumentation point - takes \\p Analysis instance\n  /// that has just been executed and constant reference to IR it operated on.\n  template <typename IRUnitT, typename PassT>\n  void runAfterAnalysis(const PassT &Analysis, const IRUnitT &IR) const {\n    if (Callbacks)\n      for (auto &C : Callbacks->AfterAnalysisCallbacks)\n        C(Analysis.name(), llvm::Any(&IR));\n  }\n\n  /// Handle invalidation from the pass manager when PassInstrumentation\n  /// is used as the result of PassInstrumentationAnalysis.\n  ///\n  /// On attempt to invalidate just return false. There is nothing to become\n  /// invalid here.\n  template <typename IRUnitT, typename... ExtraArgsT>\n  bool invalidate(IRUnitT &, const class llvm::PreservedAnalyses &,\n                  ExtraArgsT...) {\n    return false;\n  }\n\n  template <typename CallableT>\n  void pushBeforeNonSkippedPassCallback(CallableT C) {\n    if (Callbacks)\n      Callbacks->BeforeNonSkippedPassCallbacks.emplace_back(std::move(C));\n  }\n  void popBeforeNonSkippedPassCallback() {\n    if (Callbacks)\n      Callbacks->BeforeNonSkippedPassCallbacks.pop_back();\n  }\n};\n\nbool isSpecialPass(StringRef PassID, const std::vector<StringRef> &Specials);\n\n} // namespace llvm\n\n#endif\n"}, "45": {"id": 45, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/IR/PassManager.h", "content": "//===- PassManager.h - Pass management infrastructure -----------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n/// \\file\n///\n/// This header defines various interfaces for pass management in LLVM. There\n/// is no \"pass\" interface in LLVM per se. Instead, an instance of any class\n/// which supports a method to 'run' it over a unit of IR can be used as\n/// a pass. A pass manager is generally a tool to collect a sequence of passes\n/// which run over a particular IR construct, and run each of them in sequence\n/// over each such construct in the containing IR construct. As there is no\n/// containing IR construct for a Module, a manager for passes over modules\n/// forms the base case which runs its managed passes in sequence over the\n/// single module provided.\n///\n/// The core IR library provides managers for running passes over\n/// modules and functions.\n///\n/// * FunctionPassManager can run over a Module, runs each pass over\n///   a Function.\n/// * ModulePassManager must be directly run, runs each pass over the Module.\n///\n/// Note that the implementations of the pass managers use concept-based\n/// polymorphism as outlined in the \"Value Semantics and Concept-based\n/// Polymorphism\" talk (or its abbreviated sibling \"Inheritance Is The Base\n/// Class of Evil\") by Sean Parent:\n/// * http://github.com/sean-parent/sean-parent.github.com/wiki/Papers-and-Presentations\n/// * http://www.youtube.com/watch?v=_BpMYeUFXv8\n/// * http://channel9.msdn.com/Events/GoingNative/2013/Inheritance-Is-The-Base-Class-of-Evil\n///\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_IR_PASSMANAGER_H\n#define LLVM_IR_PASSMANAGER_H\n\n#include \"llvm/ADT/DenseMap.h\"\n#include \"llvm/ADT/STLExtras.h\"\n#include \"llvm/ADT/SmallPtrSet.h\"\n#include \"llvm/ADT/StringRef.h\"\n#include \"llvm/ADT/TinyPtrVector.h\"\n#include \"llvm/IR/Function.h\"\n#include \"llvm/IR/Module.h\"\n#include \"llvm/IR/PassInstrumentation.h\"\n#include \"llvm/IR/PassManagerInternal.h\"\n#include \"llvm/Pass.h\"\n#include \"llvm/Support/Debug.h\"\n#include \"llvm/Support/TimeProfiler.h\"\n#include \"llvm/Support/TypeName.h\"\n#include <algorithm>\n#include <cassert>\n#include <cstring>\n#include <iterator>\n#include <list>\n#include <memory>\n#include <tuple>\n#include <type_traits>\n#include <utility>\n#include <vector>\n\nnamespace llvm {\n\n/// A special type used by analysis passes to provide an address that\n/// identifies that particular analysis pass type.\n///\n/// Analysis passes should have a static data member of this type and derive\n/// from the \\c AnalysisInfoMixin to get a static ID method used to identify\n/// the analysis in the pass management infrastructure.\nstruct alignas(8) AnalysisKey {};\n\n/// A special type used to provide an address that identifies a set of related\n/// analyses.  These sets are primarily used below to mark sets of analyses as\n/// preserved.\n///\n/// For example, a transformation can indicate that it preserves the CFG of a\n/// function by preserving the appropriate AnalysisSetKey.  An analysis that\n/// depends only on the CFG can then check if that AnalysisSetKey is preserved;\n/// if it is, the analysis knows that it itself is preserved.\nstruct alignas(8) AnalysisSetKey {};\n\n/// This templated class represents \"all analyses that operate over \\<a\n/// particular IR unit\\>\" (e.g. a Function or a Module) in instances of\n/// PreservedAnalysis.\n///\n/// This lets a transformation say e.g. \"I preserved all function analyses\".\n///\n/// Note that you must provide an explicit instantiation declaration and\n/// definition for this template in order to get the correct behavior on\n/// Windows. Otherwise, the address of SetKey will not be stable.\ntemplate <typename IRUnitT> class AllAnalysesOn {\npublic:\n  static AnalysisSetKey *ID() { return &SetKey; }\n\nprivate:\n  static AnalysisSetKey SetKey;\n};\n\ntemplate <typename IRUnitT> AnalysisSetKey AllAnalysesOn<IRUnitT>::SetKey;\n\nextern template class AllAnalysesOn<Module>;\nextern template class AllAnalysesOn<Function>;\n\n/// Represents analyses that only rely on functions' control flow.\n///\n/// This can be used with \\c PreservedAnalyses to mark the CFG as preserved and\n/// to query whether it has been preserved.\n///\n/// The CFG of a function is defined as the set of basic blocks and the edges\n/// between them. Changing the set of basic blocks in a function is enough to\n/// mutate the CFG. Mutating the condition of a branch or argument of an\n/// invoked function does not mutate the CFG, but changing the successor labels\n/// of those instructions does.\nclass CFGAnalyses {\npublic:\n  static AnalysisSetKey *ID() { return &SetKey; }\n\nprivate:\n  static AnalysisSetKey SetKey;\n};\n\n/// A set of analyses that are preserved following a run of a transformation\n/// pass.\n///\n/// Transformation passes build and return these objects to communicate which\n/// analyses are still valid after the transformation. For most passes this is\n/// fairly simple: if they don't change anything all analyses are preserved,\n/// otherwise only a short list of analyses that have been explicitly updated\n/// are preserved.\n///\n/// This class also lets transformation passes mark abstract *sets* of analyses\n/// as preserved. A transformation that (say) does not alter the CFG can\n/// indicate such by marking a particular AnalysisSetKey as preserved, and\n/// then analyses can query whether that AnalysisSetKey is preserved.\n///\n/// Finally, this class can represent an \"abandoned\" analysis, which is\n/// not preserved even if it would be covered by some abstract set of analyses.\n///\n/// Given a `PreservedAnalyses` object, an analysis will typically want to\n/// figure out whether it is preserved. In the example below, MyAnalysisType is\n/// preserved if it's not abandoned, and (a) it's explicitly marked as\n/// preserved, (b), the set AllAnalysesOn<MyIRUnit> is preserved, or (c) both\n/// AnalysisSetA and AnalysisSetB are preserved.\n///\n/// ```\n///   auto PAC = PA.getChecker<MyAnalysisType>();\n///   if (PAC.preserved() || PAC.preservedSet<AllAnalysesOn<MyIRUnit>>() ||\n///       (PAC.preservedSet<AnalysisSetA>() &&\n///        PAC.preservedSet<AnalysisSetB>())) {\n///     // The analysis has been successfully preserved ...\n///   }\n/// ```\nclass PreservedAnalyses {\npublic:\n  /// Convenience factory function for the empty preserved set.\n  static PreservedAnalyses none() { return PreservedAnalyses(); }\n\n  /// Construct a special preserved set that preserves all passes.\n  static PreservedAnalyses all() {\n    PreservedAnalyses PA;\n    PA.PreservedIDs.insert(&AllAnalysesKey);\n    return PA;\n  }\n\n  /// Construct a preserved analyses object with a single preserved set.\n  template <typename AnalysisSetT>\n  static PreservedAnalyses allInSet() {\n    PreservedAnalyses PA;\n    PA.preserveSet<AnalysisSetT>();\n    return PA;\n  }\n\n  /// Mark an analysis as preserved.\n  template <typename AnalysisT> void preserve() { preserve(AnalysisT::ID()); }\n\n  /// Given an analysis's ID, mark the analysis as preserved, adding it\n  /// to the set.\n  void preserve(AnalysisKey *ID) {\n    // Clear this ID from the explicit not-preserved set if present.\n    NotPreservedAnalysisIDs.erase(ID);\n\n    // If we're not already preserving all analyses (other than those in\n    // NotPreservedAnalysisIDs).\n    if (!areAllPreserved())\n      PreservedIDs.insert(ID);\n  }\n\n  /// Mark an analysis set as preserved.\n  template <typename AnalysisSetT> void preserveSet() {\n    preserveSet(AnalysisSetT::ID());\n  }\n\n  /// Mark an analysis set as preserved using its ID.\n  void preserveSet(AnalysisSetKey *ID) {\n    // If we're not already in the saturated 'all' state, add this set.\n    if (!areAllPreserved())\n      PreservedIDs.insert(ID);\n  }\n\n  /// Mark an analysis as abandoned.\n  ///\n  /// An abandoned analysis is not preserved, even if it is nominally covered\n  /// by some other set or was previously explicitly marked as preserved.\n  ///\n  /// Note that you can only abandon a specific analysis, not a *set* of\n  /// analyses.\n  template <typename AnalysisT> void abandon() { abandon(AnalysisT::ID()); }\n\n  /// Mark an analysis as abandoned using its ID.\n  ///\n  /// An abandoned analysis is not preserved, even if it is nominally covered\n  /// by some other set or was previously explicitly marked as preserved.\n  ///\n  /// Note that you can only abandon a specific analysis, not a *set* of\n  /// analyses.\n  void abandon(AnalysisKey *ID) {\n    PreservedIDs.erase(ID);\n    NotPreservedAnalysisIDs.insert(ID);\n  }\n\n  /// Intersect this set with another in place.\n  ///\n  /// This is a mutating operation on this preserved set, removing all\n  /// preserved passes which are not also preserved in the argument.\n  void intersect(const PreservedAnalyses &Arg) {\n    if (Arg.areAllPreserved())\n      return;\n    if (areAllPreserved()) {\n      *this = Arg;\n      return;\n    }\n    // The intersection requires the *union* of the explicitly not-preserved\n    // IDs and the *intersection* of the preserved IDs.\n    for (auto ID : Arg.NotPreservedAnalysisIDs) {\n      PreservedIDs.erase(ID);\n      NotPreservedAnalysisIDs.insert(ID);\n    }\n    for (auto ID : PreservedIDs)\n      if (!Arg.PreservedIDs.count(ID))\n        PreservedIDs.erase(ID);\n  }\n\n  /// Intersect this set with a temporary other set in place.\n  ///\n  /// This is a mutating operation on this preserved set, removing all\n  /// preserved passes which are not also preserved in the argument.\n  void intersect(PreservedAnalyses &&Arg) {\n    if (Arg.areAllPreserved())\n      return;\n    if (areAllPreserved()) {\n      *this = std::move(Arg);\n      return;\n    }\n    // The intersection requires the *union* of the explicitly not-preserved\n    // IDs and the *intersection* of the preserved IDs.\n    for (auto ID : Arg.NotPreservedAnalysisIDs) {\n      PreservedIDs.erase(ID);\n      NotPreservedAnalysisIDs.insert(ID);\n    }\n    for (auto ID : PreservedIDs)\n      if (!Arg.PreservedIDs.count(ID))\n        PreservedIDs.erase(ID);\n  }\n\n  /// A checker object that makes it easy to query for whether an analysis or\n  /// some set covering it is preserved.\n  class PreservedAnalysisChecker {\n    friend class PreservedAnalyses;\n\n    const PreservedAnalyses &PA;\n    AnalysisKey *const ID;\n    const bool IsAbandoned;\n\n    /// A PreservedAnalysisChecker is tied to a particular Analysis because\n    /// `preserved()` and `preservedSet()` both return false if the Analysis\n    /// was abandoned.\n    PreservedAnalysisChecker(const PreservedAnalyses &PA, AnalysisKey *ID)\n        : PA(PA), ID(ID), IsAbandoned(PA.NotPreservedAnalysisIDs.count(ID)) {}\n\n  public:\n    /// Returns true if the checker's analysis was not abandoned and either\n    ///  - the analysis is explicitly preserved or\n    ///  - all analyses are preserved.\n    bool preserved() {\n      return !IsAbandoned && (PA.PreservedIDs.count(&AllAnalysesKey) ||\n                              PA.PreservedIDs.count(ID));\n    }\n\n    /// Return true if the checker's analysis was not abandoned, i.e. it was not\n    /// explicitly invalidated. Even if the analysis is not explicitly\n    /// preserved, if the analysis is known stateless, then it is preserved.\n    bool preservedWhenStateless() {\n      return !IsAbandoned;\n    }\n\n    /// Returns true if the checker's analysis was not abandoned and either\n    ///  - \\p AnalysisSetT is explicitly preserved or\n    ///  - all analyses are preserved.\n    template <typename AnalysisSetT> bool preservedSet() {\n      AnalysisSetKey *SetID = AnalysisSetT::ID();\n      return !IsAbandoned && (PA.PreservedIDs.count(&AllAnalysesKey) ||\n                              PA.PreservedIDs.count(SetID));\n    }\n  };\n\n  /// Build a checker for this `PreservedAnalyses` and the specified analysis\n  /// type.\n  ///\n  /// You can use the returned object to query whether an analysis was\n  /// preserved. See the example in the comment on `PreservedAnalysis`.\n  template <typename AnalysisT> PreservedAnalysisChecker getChecker() const {\n    return PreservedAnalysisChecker(*this, AnalysisT::ID());\n  }\n\n  /// Build a checker for this `PreservedAnalyses` and the specified analysis\n  /// ID.\n  ///\n  /// You can use the returned object to query whether an analysis was\n  /// preserved. See the example in the comment on `PreservedAnalysis`.\n  PreservedAnalysisChecker getChecker(AnalysisKey *ID) const {\n    return PreservedAnalysisChecker(*this, ID);\n  }\n\n  /// Test whether all analyses are preserved (and none are abandoned).\n  ///\n  /// This is used primarily to optimize for the common case of a transformation\n  /// which makes no changes to the IR.\n  bool areAllPreserved() const {\n    return NotPreservedAnalysisIDs.empty() &&\n           PreservedIDs.count(&AllAnalysesKey);\n  }\n\n  /// Directly test whether a set of analyses is preserved.\n  ///\n  /// This is only true when no analyses have been explicitly abandoned.\n  template <typename AnalysisSetT> bool allAnalysesInSetPreserved() const {\n    return allAnalysesInSetPreserved(AnalysisSetT::ID());\n  }\n\n  /// Directly test whether a set of analyses is preserved.\n  ///\n  /// This is only true when no analyses have been explicitly abandoned.\n  bool allAnalysesInSetPreserved(AnalysisSetKey *SetID) const {\n    return NotPreservedAnalysisIDs.empty() &&\n           (PreservedIDs.count(&AllAnalysesKey) || PreservedIDs.count(SetID));\n  }\n\nprivate:\n  /// A special key used to indicate all analyses.\n  static AnalysisSetKey AllAnalysesKey;\n\n  /// The IDs of analyses and analysis sets that are preserved.\n  SmallPtrSet<void *, 2> PreservedIDs;\n\n  /// The IDs of explicitly not-preserved analyses.\n  ///\n  /// If an analysis in this set is covered by a set in `PreservedIDs`, we\n  /// consider it not-preserved. That is, `NotPreservedAnalysisIDs` always\n  /// \"wins\" over analysis sets in `PreservedIDs`.\n  ///\n  /// Also, a given ID should never occur both here and in `PreservedIDs`.\n  SmallPtrSet<AnalysisKey *, 2> NotPreservedAnalysisIDs;\n};\n\n// Forward declare the analysis manager template.\ntemplate <typename IRUnitT, typename... ExtraArgTs> class AnalysisManager;\n\n/// A CRTP mix-in to automatically provide informational APIs needed for\n/// passes.\n///\n/// This provides some boilerplate for types that are passes.\ntemplate <typename DerivedT> struct PassInfoMixin {\n  /// Gets the name of the pass we are mixed into.\n  static StringRef name() {\n    static_assert(std::is_base_of<PassInfoMixin, DerivedT>::value,\n                  \"Must pass the derived type as the template argument!\");\n    StringRef Name = getTypeName<DerivedT>();\n    if (Name.startswith(\"llvm::\"))\n      Name = Name.drop_front(strlen(\"llvm::\"));\n    return Name;\n  }\n};\n\n/// A CRTP mix-in that provides informational APIs needed for analysis passes.\n///\n/// This provides some boilerplate for types that are analysis passes. It\n/// automatically mixes in \\c PassInfoMixin.\ntemplate <typename DerivedT>\nstruct AnalysisInfoMixin : PassInfoMixin<DerivedT> {\n  /// Returns an opaque, unique ID for this analysis type.\n  ///\n  /// This ID is a pointer type that is guaranteed to be 8-byte aligned and thus\n  /// suitable for use in sets, maps, and other data structures that use the low\n  /// bits of pointers.\n  ///\n  /// Note that this requires the derived type provide a static \\c AnalysisKey\n  /// member called \\c Key.\n  ///\n  /// FIXME: The only reason the mixin type itself can't declare the Key value\n  /// is that some compilers cannot correctly unique a templated static variable\n  /// so it has the same addresses in each instantiation. The only currently\n  /// known platform with this limitation is Windows DLL builds, specifically\n  /// building each part of LLVM as a DLL. If we ever remove that build\n  /// configuration, this mixin can provide the static key as well.\n  static AnalysisKey *ID() {\n    static_assert(std::is_base_of<AnalysisInfoMixin, DerivedT>::value,\n                  \"Must pass the derived type as the template argument!\");\n    return &DerivedT::Key;\n  }\n};\n\nnamespace detail {\n\n/// Actual unpacker of extra arguments in getAnalysisResult,\n/// passes only those tuple arguments that are mentioned in index_sequence.\ntemplate <typename PassT, typename IRUnitT, typename AnalysisManagerT,\n          typename... ArgTs, size_t... Ns>\ntypename PassT::Result\ngetAnalysisResultUnpackTuple(AnalysisManagerT &AM, IRUnitT &IR,\n                             std::tuple<ArgTs...> Args,\n                             std::index_sequence<Ns...>) {\n  (void)Args;\n  return AM.template getResult<PassT>(IR, std::get<Ns>(Args)...);\n}\n\n/// Helper for *partial* unpacking of extra arguments in getAnalysisResult.\n///\n/// Arguments passed in tuple come from PassManager, so they might have extra\n/// arguments after those AnalysisManager's ExtraArgTs ones that we need to\n/// pass to getResult.\ntemplate <typename PassT, typename IRUnitT, typename... AnalysisArgTs,\n          typename... MainArgTs>\ntypename PassT::Result\ngetAnalysisResult(AnalysisManager<IRUnitT, AnalysisArgTs...> &AM, IRUnitT &IR,\n                  std::tuple<MainArgTs...> Args) {\n  return (getAnalysisResultUnpackTuple<\n          PassT, IRUnitT>)(AM, IR, Args,\n                           std::index_sequence_for<AnalysisArgTs...>{});\n}\n\n} // namespace detail\n\n// Forward declare the pass instrumentation analysis explicitly queried in\n// generic PassManager code.\n// FIXME: figure out a way to move PassInstrumentationAnalysis into its own\n// header.\nclass PassInstrumentationAnalysis;\n\n/// Manages a sequence of passes over a particular unit of IR.\n///\n/// A pass manager contains a sequence of passes to run over a particular unit\n/// of IR (e.g. Functions, Modules). It is itself a valid pass over that unit of\n/// IR, and when run over some given IR will run each of its contained passes in\n/// sequence. Pass managers are the primary and most basic building block of a\n/// pass pipeline.\n///\n/// When you run a pass manager, you provide an \\c AnalysisManager<IRUnitT>\n/// argument. The pass manager will propagate that analysis manager to each\n/// pass it runs, and will call the analysis manager's invalidation routine with\n/// the PreservedAnalyses of each pass it runs.\ntemplate <typename IRUnitT,\n          typename AnalysisManagerT = AnalysisManager<IRUnitT>,\n          typename... ExtraArgTs>\nclass PassManager : public PassInfoMixin<\n                        PassManager<IRUnitT, AnalysisManagerT, ExtraArgTs...>> {\npublic:\n  /// Construct a pass manager.\n  ///\n  /// If \\p DebugLogging is true, we'll log our progress to llvm::dbgs().\n  explicit PassManager(bool DebugLogging = false) : DebugLogging(DebugLogging) {}\n\n  // FIXME: These are equivalent to the default move constructor/move\n  // assignment. However, using = default triggers linker errors due to the\n  // explicit instantiations below. Find away to use the default and remove the\n  // duplicated code here.\n  PassManager(PassManager &&Arg)\n      : Passes(std::move(Arg.Passes)),\n        DebugLogging(std::move(Arg.DebugLogging)) {}\n\n  PassManager &operator=(PassManager &&RHS) {\n    Passes = std::move(RHS.Passes);\n    DebugLogging = std::move(RHS.DebugLogging);\n    return *this;\n  }\n\n  /// Run all of the passes in this manager over the given unit of IR.\n  /// ExtraArgs are passed to each pass.\n  PreservedAnalyses run(IRUnitT &IR, AnalysisManagerT &AM,\n                        ExtraArgTs... ExtraArgs) {\n    PreservedAnalyses PA = PreservedAnalyses::all();\n\n    // Request PassInstrumentation from analysis manager, will use it to run\n    // instrumenting callbacks for the passes later.\n    // Here we use std::tuple wrapper over getResult which helps to extract\n    // AnalysisManager's arguments out of the whole ExtraArgs set.\n    PassInstrumentation PI =\n        detail::getAnalysisResult<PassInstrumentationAnalysis>(\n            AM, IR, std::tuple<ExtraArgTs...>(ExtraArgs...));\n\n    if (DebugLogging)\n      dbgs() << \"Starting \" << getTypeName<IRUnitT>() << \" pass manager run.\\n\";\n\n    for (unsigned Idx = 0, Size = Passes.size(); Idx != Size; ++Idx) {\n      auto *P = Passes[Idx].get();\n\n      // Check the PassInstrumentation's BeforePass callbacks before running the\n      // pass, skip its execution completely if asked to (callback returns\n      // false).\n      if (!PI.runBeforePass<IRUnitT>(*P, IR))\n        continue;\n\n      PreservedAnalyses PassPA;\n      {\n        TimeTraceScope TimeScope(P->name(), IR.getName());\n        PassPA = P->run(IR, AM, ExtraArgs...);\n      }\n\n      // Call onto PassInstrumentation's AfterPass callbacks immediately after\n      // running the pass.\n      PI.runAfterPass<IRUnitT>(*P, IR, PassPA);\n\n      // Update the analysis manager as each pass runs and potentially\n      // invalidates analyses.\n      AM.invalidate(IR, PassPA);\n\n      // Finally, intersect the preserved analyses to compute the aggregate\n      // preserved set for this pass manager.\n      PA.intersect(std::move(PassPA));\n\n      // FIXME: Historically, the pass managers all called the LLVM context's\n      // yield function here. We don't have a generic way to acquire the\n      // context and it isn't yet clear what the right pattern is for yielding\n      // in the new pass manager so it is currently omitted.\n      //IR.getContext().yield();\n    }\n\n    // Invalidation was handled after each pass in the above loop for the\n    // current unit of IR. Therefore, the remaining analysis results in the\n    // AnalysisManager are preserved. We mark this with a set so that we don't\n    // need to inspect each one individually.\n    PA.preserveSet<AllAnalysesOn<IRUnitT>>();\n\n    if (DebugLogging)\n      dbgs() << \"Finished \" << getTypeName<IRUnitT>() << \" pass manager run.\\n\";\n\n    return PA;\n  }\n\n  template <typename PassT>\n  std::enable_if_t<!std::is_same<PassT, PassManager>::value>\n  addPass(PassT Pass) {\n    using PassModelT =\n        detail::PassModel<IRUnitT, PassT, PreservedAnalyses, AnalysisManagerT,\n                          ExtraArgTs...>;\n\n    Passes.emplace_back(new PassModelT(std::move(Pass)));\n  }\n\n  /// When adding a pass manager pass that has the same type as this pass\n  /// manager, simply move the passes over. This is because we don't have use\n  /// cases rely on executing nested pass managers. Doing this could reduce\n  /// implementation complexity and avoid potential invalidation issues that may\n  /// happen with nested pass managers of the same type.\n  template <typename PassT>\n  std::enable_if_t<std::is_same<PassT, PassManager>::value>\n  addPass(PassT &&Pass) {\n    for (auto &P : Pass.Passes)\n      Passes.emplace_back(std::move(P));\n  }\n\n  /// Returns if the pass manager contains any passes.\n  bool isEmpty() const { return Passes.empty(); }\n\n  static bool isRequired() { return true; }\n\nprotected:\n  using PassConceptT =\n      detail::PassConcept<IRUnitT, AnalysisManagerT, ExtraArgTs...>;\n\n  std::vector<std::unique_ptr<PassConceptT>> Passes;\n\n  /// Flag indicating whether we should do debug logging.\n  bool DebugLogging;\n};\n\nextern template class PassManager<Module>;\n\n/// Convenience typedef for a pass manager over modules.\nusing ModulePassManager = PassManager<Module>;\n\nextern template class PassManager<Function>;\n\n/// Convenience typedef for a pass manager over functions.\nusing FunctionPassManager = PassManager<Function>;\n\n/// Pseudo-analysis pass that exposes the \\c PassInstrumentation to pass\n/// managers. Goes before AnalysisManager definition to provide its\n/// internals (e.g PassInstrumentationAnalysis::ID) for use there if needed.\n/// FIXME: figure out a way to move PassInstrumentationAnalysis into its own\n/// header.\nclass PassInstrumentationAnalysis\n    : public AnalysisInfoMixin<PassInstrumentationAnalysis> {\n  friend AnalysisInfoMixin<PassInstrumentationAnalysis>;\n  static AnalysisKey Key;\n\n  PassInstrumentationCallbacks *Callbacks;\n\npublic:\n  /// PassInstrumentationCallbacks object is shared, owned by something else,\n  /// not this analysis.\n  PassInstrumentationAnalysis(PassInstrumentationCallbacks *Callbacks = nullptr)\n      : Callbacks(Callbacks) {}\n\n  using Result = PassInstrumentation;\n\n  template <typename IRUnitT, typename AnalysisManagerT, typename... ExtraArgTs>\n  Result run(IRUnitT &, AnalysisManagerT &, ExtraArgTs &&...) {\n    return PassInstrumentation(Callbacks);\n  }\n};\n\n/// A container for analyses that lazily runs them and caches their\n/// results.\n///\n/// This class can manage analyses for any IR unit where the address of the IR\n/// unit sufficies as its identity.\ntemplate <typename IRUnitT, typename... ExtraArgTs> class AnalysisManager {\npublic:\n  class Invalidator;\n\nprivate:\n  // Now that we've defined our invalidator, we can define the concept types.\n  using ResultConceptT =\n      detail::AnalysisResultConcept<IRUnitT, PreservedAnalyses, Invalidator>;\n  using PassConceptT =\n      detail::AnalysisPassConcept<IRUnitT, PreservedAnalyses, Invalidator,\n                                  ExtraArgTs...>;\n\n  /// List of analysis pass IDs and associated concept pointers.\n  ///\n  /// Requires iterators to be valid across appending new entries and arbitrary\n  /// erases. Provides the analysis ID to enable finding iterators to a given\n  /// entry in maps below, and provides the storage for the actual result\n  /// concept.\n  using AnalysisResultListT =\n      std::list<std::pair<AnalysisKey *, std::unique_ptr<ResultConceptT>>>;\n\n  /// Map type from IRUnitT pointer to our custom list type.\n  using AnalysisResultListMapT = DenseMap<IRUnitT *, AnalysisResultListT>;\n\n  /// Map type from a pair of analysis ID and IRUnitT pointer to an\n  /// iterator into a particular result list (which is where the actual analysis\n  /// result is stored).\n  using AnalysisResultMapT =\n      DenseMap<std::pair<AnalysisKey *, IRUnitT *>,\n               typename AnalysisResultListT::iterator>;\n\npublic:\n  /// API to communicate dependencies between analyses during invalidation.\n  ///\n  /// When an analysis result embeds handles to other analysis results, it\n  /// needs to be invalidated both when its own information isn't preserved and\n  /// when any of its embedded analysis results end up invalidated. We pass an\n  /// \\c Invalidator object as an argument to \\c invalidate() in order to let\n  /// the analysis results themselves define the dependency graph on the fly.\n  /// This lets us avoid building an explicit representation of the\n  /// dependencies between analysis results.\n  class Invalidator {\n  public:\n    /// Trigger the invalidation of some other analysis pass if not already\n    /// handled and return whether it was in fact invalidated.\n    ///\n    /// This is expected to be called from within a given analysis result's \\c\n    /// invalidate method to trigger a depth-first walk of all inter-analysis\n    /// dependencies. The same \\p IR unit and \\p PA passed to that result's \\c\n    /// invalidate method should in turn be provided to this routine.\n    ///\n    /// The first time this is called for a given analysis pass, it will call\n    /// the corresponding result's \\c invalidate method.  Subsequent calls will\n    /// use a cache of the results of that initial call.  It is an error to form\n    /// cyclic dependencies between analysis results.\n    ///\n    /// This returns true if the given analysis's result is invalid. Any\n    /// dependecies on it will become invalid as a result.\n    template <typename PassT>\n    bool invalidate(IRUnitT &IR, const PreservedAnalyses &PA) {\n      using ResultModelT =\n          detail::AnalysisResultModel<IRUnitT, PassT, typename PassT::Result,\n                                      PreservedAnalyses, Invalidator>;\n\n      return invalidateImpl<ResultModelT>(PassT::ID(), IR, PA);\n    }\n\n    /// A type-erased variant of the above invalidate method with the same core\n    /// API other than passing an analysis ID rather than an analysis type\n    /// parameter.\n    ///\n    /// This is sadly less efficient than the above routine, which leverages\n    /// the type parameter to avoid the type erasure overhead.\n    bool invalidate(AnalysisKey *ID, IRUnitT &IR, const PreservedAnalyses &PA) {\n      return invalidateImpl<>(ID, IR, PA);\n    }\n\n  private:\n    friend class AnalysisManager;\n\n    template <typename ResultT = ResultConceptT>\n    bool invalidateImpl(AnalysisKey *ID, IRUnitT &IR,\n                        const PreservedAnalyses &PA) {\n      // If we've already visited this pass, return true if it was invalidated\n      // and false otherwise.\n      auto IMapI = IsResultInvalidated.find(ID);\n      if (IMapI != IsResultInvalidated.end())\n        return IMapI->second;\n\n      // Otherwise look up the result object.\n      auto RI = Results.find({ID, &IR});\n      assert(RI != Results.end() &&\n             \"Trying to invalidate a dependent result that isn't in the \"\n             \"manager's cache is always an error, likely due to a stale result \"\n             \"handle!\");\n\n      auto &Result = static_cast<ResultT &>(*RI->second->second);\n\n      // Insert into the map whether the result should be invalidated and return\n      // that. Note that we cannot reuse IMapI and must do a fresh insert here,\n      // as calling invalidate could (recursively) insert things into the map,\n      // making any iterator or reference invalid.\n      bool Inserted;\n      std::tie(IMapI, Inserted) =\n          IsResultInvalidated.insert({ID, Result.invalidate(IR, PA, *this)});\n      (void)Inserted;\n      assert(Inserted && \"Should not have already inserted this ID, likely \"\n                         \"indicates a dependency cycle!\");\n      return IMapI->second;\n    }\n\n    Invalidator(SmallDenseMap<AnalysisKey *, bool, 8> &IsResultInvalidated,\n                const AnalysisResultMapT &Results)\n        : IsResultInvalidated(IsResultInvalidated), Results(Results) {}\n\n    SmallDenseMap<AnalysisKey *, bool, 8> &IsResultInvalidated;\n    const AnalysisResultMapT &Results;\n  };\n\n  /// Construct an empty analysis manager.\n  ///\n  /// If \\p DebugLogging is true, we'll log our progress to llvm::dbgs().\n  AnalysisManager(bool DebugLogging = false);\n  AnalysisManager(AnalysisManager &&);\n  AnalysisManager &operator=(AnalysisManager &&);\n\n  /// Returns true if the analysis manager has an empty results cache.\n  bool empty() const {\n    assert(AnalysisResults.empty() == AnalysisResultLists.empty() &&\n           \"The storage and index of analysis results disagree on how many \"\n           \"there are!\");\n    return AnalysisResults.empty();\n  }\n\n  /// Clear any cached analysis results for a single unit of IR.\n  ///\n  /// This doesn't invalidate, but instead simply deletes, the relevant results.\n  /// It is useful when the IR is being removed and we want to clear out all the\n  /// memory pinned for it.\n  void clear(IRUnitT &IR, llvm::StringRef Name);\n\n  /// Clear all analysis results cached by this AnalysisManager.\n  ///\n  /// Like \\c clear(IRUnitT&), this doesn't invalidate the results; it simply\n  /// deletes them.  This lets you clean up the AnalysisManager when the set of\n  /// IR units itself has potentially changed, and thus we can't even look up a\n  /// a result and invalidate/clear it directly.\n  void clear() {\n    AnalysisResults.clear();\n    AnalysisResultLists.clear();\n  }\n\n  /// Get the result of an analysis pass for a given IR unit.\n  ///\n  /// Runs the analysis if a cached result is not available.\n  template <typename PassT>\n  typename PassT::Result &getResult(IRUnitT &IR, ExtraArgTs... ExtraArgs) {\n    assert(AnalysisPasses.count(PassT::ID()) &&\n           \"This analysis pass was not registered prior to being queried\");\n    ResultConceptT &ResultConcept =\n        getResultImpl(PassT::ID(), IR, ExtraArgs...);\n\n    using ResultModelT =\n        detail::AnalysisResultModel<IRUnitT, PassT, typename PassT::Result,\n                                    PreservedAnalyses, Invalidator>;\n\n    return static_cast<ResultModelT &>(ResultConcept).Result;\n  }\n\n  /// Get the cached result of an analysis pass for a given IR unit.\n  ///\n  /// This method never runs the analysis.\n  ///\n  /// \\returns null if there is no cached result.\n  template <typename PassT>\n  typename PassT::Result *getCachedResult(IRUnitT &IR) const {\n    assert(AnalysisPasses.count(PassT::ID()) &&\n           \"This analysis pass was not registered prior to being queried\");\n\n    ResultConceptT *ResultConcept = getCachedResultImpl(PassT::ID(), IR);\n    if (!ResultConcept)\n      return nullptr;\n\n    using ResultModelT =\n        detail::AnalysisResultModel<IRUnitT, PassT, typename PassT::Result,\n                                    PreservedAnalyses, Invalidator>;\n\n    return &static_cast<ResultModelT *>(ResultConcept)->Result;\n  }\n\n  /// Verify that the given Result cannot be invalidated, assert otherwise.\n  template <typename PassT>\n  void verifyNotInvalidated(IRUnitT &IR, typename PassT::Result *Result) const {\n    PreservedAnalyses PA = PreservedAnalyses::none();\n    SmallDenseMap<AnalysisKey *, bool, 8> IsResultInvalidated;\n    Invalidator Inv(IsResultInvalidated, AnalysisResults);\n    assert(!Result->invalidate(IR, PA, Inv) &&\n           \"Cached result cannot be invalidated\");\n  }\n\n  /// Register an analysis pass with the manager.\n  ///\n  /// The parameter is a callable whose result is an analysis pass. This allows\n  /// passing in a lambda to construct the analysis.\n  ///\n  /// The analysis type to register is the type returned by calling the \\c\n  /// PassBuilder argument. If that type has already been registered, then the\n  /// argument will not be called and this function will return false.\n  /// Otherwise, we register the analysis returned by calling \\c PassBuilder(),\n  /// and this function returns true.\n  ///\n  /// (Note: Although the return value of this function indicates whether or not\n  /// an analysis was previously registered, there intentionally isn't a way to\n  /// query this directly.  Instead, you should just register all the analyses\n  /// you might want and let this class run them lazily.  This idiom lets us\n  /// minimize the number of times we have to look up analyses in our\n  /// hashtable.)\n  template <typename PassBuilderT>\n  bool registerPass(PassBuilderT &&PassBuilder) {\n    using PassT = decltype(PassBuilder());\n    using PassModelT =\n        detail::AnalysisPassModel<IRUnitT, PassT, PreservedAnalyses,\n                                  Invalidator, ExtraArgTs...>;\n\n    auto &PassPtr = AnalysisPasses[PassT::ID()];\n    if (PassPtr)\n      // Already registered this pass type!\n      return false;\n\n    // Construct a new model around the instance returned by the builder.\n    PassPtr.reset(new PassModelT(PassBuilder()));\n    return true;\n  }\n\n  /// Invalidate a specific analysis pass for an IR unit.\n  ///\n  /// Note that the analysis result can disregard invalidation, if it determines\n  /// it is in fact still valid.\n  template <typename PassT> void invalidate(IRUnitT &IR) {\n    assert(AnalysisPasses.count(PassT::ID()) &&\n           \"This analysis pass was not registered prior to being invalidated\");\n    invalidateImpl(PassT::ID(), IR);\n  }\n\n  /// Invalidate cached analyses for an IR unit.\n  ///\n  /// Walk through all of the analyses pertaining to this unit of IR and\n  /// invalidate them, unless they are preserved by the PreservedAnalyses set.\n  void invalidate(IRUnitT &IR, const PreservedAnalyses &PA);\n\nprivate:\n  /// Look up a registered analysis pass.\n  PassConceptT &lookUpPass(AnalysisKey *ID) {\n    typename AnalysisPassMapT::iterator PI = AnalysisPasses.find(ID);\n    assert(PI != AnalysisPasses.end() &&\n           \"Analysis passes must be registered prior to being queried!\");\n    return *PI->second;\n  }\n\n  /// Look up a registered analysis pass.\n  const PassConceptT &lookUpPass(AnalysisKey *ID) const {\n    typename AnalysisPassMapT::const_iterator PI = AnalysisPasses.find(ID);\n    assert(PI != AnalysisPasses.end() &&\n           \"Analysis passes must be registered prior to being queried!\");\n    return *PI->second;\n  }\n\n  /// Get an analysis result, running the pass if necessary.\n  ResultConceptT &getResultImpl(AnalysisKey *ID, IRUnitT &IR,\n                                ExtraArgTs... ExtraArgs);\n\n  /// Get a cached analysis result or return null.\n  ResultConceptT *getCachedResultImpl(AnalysisKey *ID, IRUnitT &IR) const {\n    typename AnalysisResultMapT::const_iterator RI =\n        AnalysisResults.find({ID, &IR});\n    return RI == AnalysisResults.end() ? nullptr : &*RI->second->second;\n  }\n\n  /// Invalidate a pass result for a IR unit.\n  void invalidateImpl(AnalysisKey *ID, IRUnitT &IR) {\n    typename AnalysisResultMapT::iterator RI =\n        AnalysisResults.find({ID, &IR});\n    if (RI == AnalysisResults.end())\n      return;\n\n    if (DebugLogging)\n      dbgs() << \"Invalidating analysis: \" << this->lookUpPass(ID).name()\n             << \" on \" << IR.getName() << \"\\n\";\n    AnalysisResultLists[&IR].erase(RI->second);\n    AnalysisResults.erase(RI);\n  }\n\n  /// Map type from analysis pass ID to pass concept pointer.\n  using AnalysisPassMapT =\n      DenseMap<AnalysisKey *, std::unique_ptr<PassConceptT>>;\n\n  /// Collection of analysis passes, indexed by ID.\n  AnalysisPassMapT AnalysisPasses;\n\n  /// Map from IR unit to a list of analysis results.\n  ///\n  /// Provides linear time removal of all analysis results for a IR unit and\n  /// the ultimate storage for a particular cached analysis result.\n  AnalysisResultListMapT AnalysisResultLists;\n\n  /// Map from an analysis ID and IR unit to a particular cached\n  /// analysis result.\n  AnalysisResultMapT AnalysisResults;\n\n  /// Indicates whether we log to \\c llvm::dbgs().\n  bool DebugLogging;\n};\n\nextern template class AnalysisManager<Module>;\n\n/// Convenience typedef for the Module analysis manager.\nusing ModuleAnalysisManager = AnalysisManager<Module>;\n\nextern template class AnalysisManager<Function>;\n\n/// Convenience typedef for the Function analysis manager.\nusing FunctionAnalysisManager = AnalysisManager<Function>;\n\n/// An analysis over an \"outer\" IR unit that provides access to an\n/// analysis manager over an \"inner\" IR unit.  The inner unit must be contained\n/// in the outer unit.\n///\n/// For example, InnerAnalysisManagerProxy<FunctionAnalysisManager, Module> is\n/// an analysis over Modules (the \"outer\" unit) that provides access to a\n/// Function analysis manager.  The FunctionAnalysisManager is the \"inner\"\n/// manager being proxied, and Functions are the \"inner\" unit.  The inner/outer\n/// relationship is valid because each Function is contained in one Module.\n///\n/// If you're (transitively) within a pass manager for an IR unit U that\n/// contains IR unit V, you should never use an analysis manager over V, except\n/// via one of these proxies.\n///\n/// Note that the proxy's result is a move-only RAII object.  The validity of\n/// the analyses in the inner analysis manager is tied to its lifetime.\ntemplate <typename AnalysisManagerT, typename IRUnitT, typename... ExtraArgTs>\nclass InnerAnalysisManagerProxy\n    : public AnalysisInfoMixin<\n          InnerAnalysisManagerProxy<AnalysisManagerT, IRUnitT>> {\npublic:\n  class Result {\n  public:\n    explicit Result(AnalysisManagerT &InnerAM) : InnerAM(&InnerAM) {}\n\n    Result(Result &&Arg) : InnerAM(std::move(Arg.InnerAM)) {\n      // We have to null out the analysis manager in the moved-from state\n      // because we are taking ownership of the responsibilty to clear the\n      // analysis state.\n      Arg.InnerAM = nullptr;\n    }\n\n    ~Result() {\n      // InnerAM is cleared in a moved from state where there is nothing to do.\n      if (!InnerAM)\n        return;\n\n      // Clear out the analysis manager if we're being destroyed -- it means we\n      // didn't even see an invalidate call when we got invalidated.\n      InnerAM->clear();\n    }\n\n    Result &operator=(Result &&RHS) {\n      InnerAM = RHS.InnerAM;\n      // We have to null out the analysis manager in the moved-from state\n      // because we are taking ownership of the responsibilty to clear the\n      // analysis state.\n      RHS.InnerAM = nullptr;\n      return *this;\n    }\n\n    /// Accessor for the analysis manager.\n    AnalysisManagerT &getManager() { return *InnerAM; }\n\n    /// Handler for invalidation of the outer IR unit, \\c IRUnitT.\n    ///\n    /// If the proxy analysis itself is not preserved, we assume that the set of\n    /// inner IR objects contained in IRUnit may have changed.  In this case,\n    /// we have to call \\c clear() on the inner analysis manager, as it may now\n    /// have stale pointers to its inner IR objects.\n    ///\n    /// Regardless of whether the proxy analysis is marked as preserved, all of\n    /// the analyses in the inner analysis manager are potentially invalidated\n    /// based on the set of preserved analyses.\n    bool invalidate(\n        IRUnitT &IR, const PreservedAnalyses &PA,\n        typename AnalysisManager<IRUnitT, ExtraArgTs...>::Invalidator &Inv);\n\n  private:\n    AnalysisManagerT *InnerAM;\n  };\n\n  explicit InnerAnalysisManagerProxy(AnalysisManagerT &InnerAM)\n      : InnerAM(&InnerAM) {}\n\n  /// Run the analysis pass and create our proxy result object.\n  ///\n  /// This doesn't do any interesting work; it is primarily used to insert our\n  /// proxy result object into the outer analysis cache so that we can proxy\n  /// invalidation to the inner analysis manager.\n  Result run(IRUnitT &IR, AnalysisManager<IRUnitT, ExtraArgTs...> &AM,\n             ExtraArgTs...) {\n    return Result(*InnerAM);\n  }\n\nprivate:\n  friend AnalysisInfoMixin<\n      InnerAnalysisManagerProxy<AnalysisManagerT, IRUnitT>>;\n\n  static AnalysisKey Key;\n\n  AnalysisManagerT *InnerAM;\n};\n\ntemplate <typename AnalysisManagerT, typename IRUnitT, typename... ExtraArgTs>\nAnalysisKey\n    InnerAnalysisManagerProxy<AnalysisManagerT, IRUnitT, ExtraArgTs...>::Key;\n\n/// Provide the \\c FunctionAnalysisManager to \\c Module proxy.\nusing FunctionAnalysisManagerModuleProxy =\n    InnerAnalysisManagerProxy<FunctionAnalysisManager, Module>;\n\n/// Specialization of the invalidate method for the \\c\n/// FunctionAnalysisManagerModuleProxy's result.\ntemplate <>\nbool FunctionAnalysisManagerModuleProxy::Result::invalidate(\n    Module &M, const PreservedAnalyses &PA,\n    ModuleAnalysisManager::Invalidator &Inv);\n\n// Ensure the \\c FunctionAnalysisManagerModuleProxy is provided as an extern\n// template.\nextern template class InnerAnalysisManagerProxy<FunctionAnalysisManager,\n                                                Module>;\n\n/// An analysis over an \"inner\" IR unit that provides access to an\n/// analysis manager over a \"outer\" IR unit.  The inner unit must be contained\n/// in the outer unit.\n///\n/// For example OuterAnalysisManagerProxy<ModuleAnalysisManager, Function> is an\n/// analysis over Functions (the \"inner\" unit) which provides access to a Module\n/// analysis manager.  The ModuleAnalysisManager is the \"outer\" manager being\n/// proxied, and Modules are the \"outer\" IR unit.  The inner/outer relationship\n/// is valid because each Function is contained in one Module.\n///\n/// This proxy only exposes the const interface of the outer analysis manager,\n/// to indicate that you cannot cause an outer analysis to run from within an\n/// inner pass.  Instead, you must rely on the \\c getCachedResult API.  This is\n/// due to keeping potential future concurrency in mind. To give an example,\n/// running a module analysis before any function passes may give a different\n/// result than running it in a function pass. Both may be valid, but it would\n/// produce non-deterministic results. GlobalsAA is a good analysis example,\n/// because the cached information has the mod/ref info for all memory for each\n/// function at the time the analysis was computed. The information is still\n/// valid after a function transformation, but it may be *different* if\n/// recomputed after that transform. GlobalsAA is never invalidated.\n\n///\n/// This proxy doesn't manage invalidation in any way -- that is handled by the\n/// recursive return path of each layer of the pass manager.  A consequence of\n/// this is the outer analyses may be stale.  We invalidate the outer analyses\n/// only when we're done running passes over the inner IR units.\ntemplate <typename AnalysisManagerT, typename IRUnitT, typename... ExtraArgTs>\nclass OuterAnalysisManagerProxy\n    : public AnalysisInfoMixin<\n          OuterAnalysisManagerProxy<AnalysisManagerT, IRUnitT, ExtraArgTs...>> {\npublic:\n  /// Result proxy object for \\c OuterAnalysisManagerProxy.\n  class Result {\n  public:\n    explicit Result(const AnalysisManagerT &OuterAM) : OuterAM(&OuterAM) {}\n\n    /// Get a cached analysis. If the analysis can be invalidated, this will\n    /// assert.\n    template <typename PassT, typename IRUnitTParam>\n    typename PassT::Result *getCachedResult(IRUnitTParam &IR) const {\n      typename PassT::Result *Res =\n          OuterAM->template getCachedResult<PassT>(IR);\n      if (Res)\n        OuterAM->template verifyNotInvalidated<PassT>(IR, Res);\n      return Res;\n    }\n\n    /// Method provided for unit testing, not intended for general use.\n    template <typename PassT, typename IRUnitTParam>\n    bool cachedResultExists(IRUnitTParam &IR) const {\n      typename PassT::Result *Res =\n          OuterAM->template getCachedResult<PassT>(IR);\n      return Res != nullptr;\n    }\n\n    /// When invalidation occurs, remove any registered invalidation events.\n    bool invalidate(\n        IRUnitT &IRUnit, const PreservedAnalyses &PA,\n        typename AnalysisManager<IRUnitT, ExtraArgTs...>::Invalidator &Inv) {\n      // Loop over the set of registered outer invalidation mappings and if any\n      // of them map to an analysis that is now invalid, clear it out.\n      SmallVector<AnalysisKey *, 4> DeadKeys;\n      for (auto &KeyValuePair : OuterAnalysisInvalidationMap) {\n        AnalysisKey *OuterID = KeyValuePair.first;\n        auto &InnerIDs = KeyValuePair.second;\n        llvm::erase_if(InnerIDs, [&](AnalysisKey *InnerID) {\n          return Inv.invalidate(InnerID, IRUnit, PA);\n        });\n        if (InnerIDs.empty())\n          DeadKeys.push_back(OuterID);\n      }\n\n      for (auto OuterID : DeadKeys)\n        OuterAnalysisInvalidationMap.erase(OuterID);\n\n      // The proxy itself remains valid regardless of anything else.\n      return false;\n    }\n\n    /// Register a deferred invalidation event for when the outer analysis\n    /// manager processes its invalidations.\n    template <typename OuterAnalysisT, typename InvalidatedAnalysisT>\n    void registerOuterAnalysisInvalidation() {\n      AnalysisKey *OuterID = OuterAnalysisT::ID();\n      AnalysisKey *InvalidatedID = InvalidatedAnalysisT::ID();\n\n      auto &InvalidatedIDList = OuterAnalysisInvalidationMap[OuterID];\n      // Note, this is a linear scan. If we end up with large numbers of\n      // analyses that all trigger invalidation on the same outer analysis,\n      // this entire system should be changed to some other deterministic\n      // data structure such as a `SetVector` of a pair of pointers.\n      if (!llvm::is_contained(InvalidatedIDList, InvalidatedID))\n        InvalidatedIDList.push_back(InvalidatedID);\n    }\n\n    /// Access the map from outer analyses to deferred invalidation requiring\n    /// analyses.\n    const SmallDenseMap<AnalysisKey *, TinyPtrVector<AnalysisKey *>, 2> &\n    getOuterInvalidations() const {\n      return OuterAnalysisInvalidationMap;\n    }\n\n  private:\n    const AnalysisManagerT *OuterAM;\n\n    /// A map from an outer analysis ID to the set of this IR-unit's analyses\n    /// which need to be invalidated.\n    SmallDenseMap<AnalysisKey *, TinyPtrVector<AnalysisKey *>, 2>\n        OuterAnalysisInvalidationMap;\n  };\n\n  OuterAnalysisManagerProxy(const AnalysisManagerT &OuterAM)\n      : OuterAM(&OuterAM) {}\n\n  /// Run the analysis pass and create our proxy result object.\n  /// Nothing to see here, it just forwards the \\c OuterAM reference into the\n  /// result.\n  Result run(IRUnitT &, AnalysisManager<IRUnitT, ExtraArgTs...> &,\n             ExtraArgTs...) {\n    return Result(*OuterAM);\n  }\n\nprivate:\n  friend AnalysisInfoMixin<\n      OuterAnalysisManagerProxy<AnalysisManagerT, IRUnitT, ExtraArgTs...>>;\n\n  static AnalysisKey Key;\n\n  const AnalysisManagerT *OuterAM;\n};\n\ntemplate <typename AnalysisManagerT, typename IRUnitT, typename... ExtraArgTs>\nAnalysisKey\n    OuterAnalysisManagerProxy<AnalysisManagerT, IRUnitT, ExtraArgTs...>::Key;\n\nextern template class OuterAnalysisManagerProxy<ModuleAnalysisManager,\n                                                Function>;\n/// Provide the \\c ModuleAnalysisManager to \\c Function proxy.\nusing ModuleAnalysisManagerFunctionProxy =\n    OuterAnalysisManagerProxy<ModuleAnalysisManager, Function>;\n\n/// Trivial adaptor that maps from a module to its functions.\n///\n/// Designed to allow composition of a FunctionPass(Manager) and\n/// a ModulePassManager, by running the FunctionPass(Manager) over every\n/// function in the module.\n///\n/// Function passes run within this adaptor can rely on having exclusive access\n/// to the function they are run over. They should not read or modify any other\n/// functions! Other threads or systems may be manipulating other functions in\n/// the module, and so their state should never be relied on.\n/// FIXME: Make the above true for all of LLVM's actual passes, some still\n/// violate this principle.\n///\n/// Function passes can also read the module containing the function, but they\n/// should not modify that module outside of the use lists of various globals.\n/// For example, a function pass is not permitted to add functions to the\n/// module.\n/// FIXME: Make the above true for all of LLVM's actual passes, some still\n/// violate this principle.\n///\n/// Note that although function passes can access module analyses, module\n/// analyses are not invalidated while the function passes are running, so they\n/// may be stale.  Function analyses will not be stale.\nclass ModuleToFunctionPassAdaptor\n    : public PassInfoMixin<ModuleToFunctionPassAdaptor> {\npublic:\n  using PassConceptT = detail::PassConcept<Function, FunctionAnalysisManager>;\n\n  explicit ModuleToFunctionPassAdaptor(std::unique_ptr<PassConceptT> Pass)\n      : Pass(std::move(Pass)) {}\n\n  /// Runs the function pass across every function in the module.\n  PreservedAnalyses run(Module &M, ModuleAnalysisManager &AM);\n\n  static bool isRequired() { return true; }\n\nprivate:\n  std::unique_ptr<PassConceptT> Pass;\n};\n\n/// A function to deduce a function pass type and wrap it in the\n/// templated adaptor.\ntemplate <typename FunctionPassT>\nModuleToFunctionPassAdaptor\ncreateModuleToFunctionPassAdaptor(FunctionPassT Pass) {\n  using PassModelT =\n      detail::PassModel<Function, FunctionPassT, PreservedAnalyses,\n                        FunctionAnalysisManager>;\n\n  return ModuleToFunctionPassAdaptor(\n      std::make_unique<PassModelT>(std::move(Pass)));\n}\n\n/// A utility pass template to force an analysis result to be available.\n///\n/// If there are extra arguments at the pass's run level there may also be\n/// extra arguments to the analysis manager's \\c getResult routine. We can't\n/// guess how to effectively map the arguments from one to the other, and so\n/// this specialization just ignores them.\n///\n/// Specific patterns of run-method extra arguments and analysis manager extra\n/// arguments will have to be defined as appropriate specializations.\ntemplate <typename AnalysisT, typename IRUnitT,\n          typename AnalysisManagerT = AnalysisManager<IRUnitT>,\n          typename... ExtraArgTs>\nstruct RequireAnalysisPass\n    : PassInfoMixin<RequireAnalysisPass<AnalysisT, IRUnitT, AnalysisManagerT,\n                                        ExtraArgTs...>> {\n  /// Run this pass over some unit of IR.\n  ///\n  /// This pass can be run over any unit of IR and use any analysis manager\n  /// provided they satisfy the basic API requirements. When this pass is\n  /// created, these methods can be instantiated to satisfy whatever the\n  /// context requires.\n  PreservedAnalyses run(IRUnitT &Arg, AnalysisManagerT &AM,\n                        ExtraArgTs &&... Args) {\n    (void)AM.template getResult<AnalysisT>(Arg,\n                                           std::forward<ExtraArgTs>(Args)...);\n\n    return PreservedAnalyses::all();\n  }\n  static bool isRequired() { return true; }\n};\n\n/// A no-op pass template which simply forces a specific analysis result\n/// to be invalidated.\ntemplate <typename AnalysisT>\nstruct InvalidateAnalysisPass\n    : PassInfoMixin<InvalidateAnalysisPass<AnalysisT>> {\n  /// Run this pass over some unit of IR.\n  ///\n  /// This pass can be run over any unit of IR and use any analysis manager,\n  /// provided they satisfy the basic API requirements. When this pass is\n  /// created, these methods can be instantiated to satisfy whatever the\n  /// context requires.\n  template <typename IRUnitT, typename AnalysisManagerT, typename... ExtraArgTs>\n  PreservedAnalyses run(IRUnitT &Arg, AnalysisManagerT &AM, ExtraArgTs &&...) {\n    auto PA = PreservedAnalyses::all();\n    PA.abandon<AnalysisT>();\n    return PA;\n  }\n};\n\n/// A utility pass that does nothing, but preserves no analyses.\n///\n/// Because this preserves no analyses, any analysis passes queried after this\n/// pass runs will recompute fresh results.\nstruct InvalidateAllAnalysesPass : PassInfoMixin<InvalidateAllAnalysesPass> {\n  /// Run this pass over some unit of IR.\n  template <typename IRUnitT, typename AnalysisManagerT, typename... ExtraArgTs>\n  PreservedAnalyses run(IRUnitT &, AnalysisManagerT &, ExtraArgTs &&...) {\n    return PreservedAnalyses::none();\n  }\n};\n\n/// A utility pass template that simply runs another pass multiple times.\n///\n/// This can be useful when debugging or testing passes. It also serves as an\n/// example of how to extend the pass manager in ways beyond composition.\ntemplate <typename PassT>\nclass RepeatedPass : public PassInfoMixin<RepeatedPass<PassT>> {\npublic:\n  RepeatedPass(int Count, PassT P) : Count(Count), P(std::move(P)) {}\n\n  template <typename IRUnitT, typename AnalysisManagerT, typename... Ts>\n  PreservedAnalyses run(IRUnitT &IR, AnalysisManagerT &AM, Ts &&... Args) {\n\n    // Request PassInstrumentation from analysis manager, will use it to run\n    // instrumenting callbacks for the passes later.\n    // Here we use std::tuple wrapper over getResult which helps to extract\n    // AnalysisManager's arguments out of the whole Args set.\n    PassInstrumentation PI =\n        detail::getAnalysisResult<PassInstrumentationAnalysis>(\n            AM, IR, std::tuple<Ts...>(Args...));\n\n    auto PA = PreservedAnalyses::all();\n    for (int i = 0; i < Count; ++i) {\n      // Check the PassInstrumentation's BeforePass callbacks before running the\n      // pass, skip its execution completely if asked to (callback returns\n      // false).\n      if (!PI.runBeforePass<IRUnitT>(P, IR))\n        continue;\n      PreservedAnalyses IterPA = P.run(IR, AM, std::forward<Ts>(Args)...);\n      PA.intersect(IterPA);\n      PI.runAfterPass(P, IR, IterPA);\n    }\n    return PA;\n  }\n\nprivate:\n  int Count;\n  PassT P;\n};\n\ntemplate <typename PassT>\nRepeatedPass<PassT> createRepeatedPass(int Count, PassT P) {\n  return RepeatedPass<PassT>(Count, std::move(P));\n}\n\n} // end namespace llvm\n\n#endif // LLVM_IR_PASSMANAGER_H\n"}, "46": {"id": 46, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/IR/User.h", "content": "//===- llvm/User.h - User class definition ----------------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// This class defines the interface that one who uses a Value must implement.\n// Each instance of the Value class keeps track of what User's have handles\n// to it.\n//\n//  * Instructions are the largest class of Users.\n//  * Constants may be users of other constants (think arrays and stuff)\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_IR_USER_H\n#define LLVM_IR_USER_H\n\n#include \"llvm/ADT/iterator.h\"\n#include \"llvm/ADT/iterator_range.h\"\n#include \"llvm/IR/Use.h\"\n#include \"llvm/IR/Value.h\"\n#include \"llvm/Support/Casting.h\"\n#include \"llvm/Support/Compiler.h\"\n#include \"llvm/Support/ErrorHandling.h\"\n#include <cassert>\n#include <cstddef>\n#include <cstdint>\n#include <iterator>\n\nnamespace llvm {\n\ntemplate <typename T> class ArrayRef;\ntemplate <typename T> class MutableArrayRef;\n\n/// Compile-time customization of User operands.\n///\n/// Customizes operand-related allocators and accessors.\ntemplate <class>\nstruct OperandTraits;\n\nclass User : public Value {\n  template <unsigned>\n  friend struct HungoffOperandTraits;\n\n  LLVM_ATTRIBUTE_ALWAYS_INLINE static void *\n  allocateFixedOperandUser(size_t, unsigned, unsigned);\n\nprotected:\n  /// Allocate a User with an operand pointer co-allocated.\n  ///\n  /// This is used for subclasses which need to allocate a variable number\n  /// of operands, ie, 'hung off uses'.\n  void *operator new(size_t Size);\n\n  /// Allocate a User with the operands co-allocated.\n  ///\n  /// This is used for subclasses which have a fixed number of operands.\n  void *operator new(size_t Size, unsigned Us);\n\n  /// Allocate a User with the operands co-allocated.  If DescBytes is non-zero\n  /// then allocate an additional DescBytes bytes before the operands. These\n  /// bytes can be accessed by calling getDescriptor.\n  ///\n  /// DescBytes needs to be divisible by sizeof(void *).  The allocated\n  /// descriptor, if any, is aligned to sizeof(void *) bytes.\n  ///\n  /// This is used for subclasses which have a fixed number of operands.\n  void *operator new(size_t Size, unsigned Us, unsigned DescBytes);\n\n  User(Type *ty, unsigned vty, Use *, unsigned NumOps)\n      : Value(ty, vty) {\n    assert(NumOps < (1u << NumUserOperandsBits) && \"Too many operands\");\n    NumUserOperands = NumOps;\n    // If we have hung off uses, then the operand list should initially be\n    // null.\n    assert((!HasHungOffUses || !getOperandList()) &&\n           \"Error in initializing hung off uses for User\");\n  }\n\n  /// Allocate the array of Uses, followed by a pointer\n  /// (with bottom bit set) to the User.\n  /// \\param IsPhi identifies callers which are phi nodes and which need\n  /// N BasicBlock* allocated along with N\n  void allocHungoffUses(unsigned N, bool IsPhi = false);\n\n  /// Grow the number of hung off uses.  Note that allocHungoffUses\n  /// should be called if there are no uses.\n  void growHungoffUses(unsigned N, bool IsPhi = false);\n\nprotected:\n  ~User() = default; // Use deleteValue() to delete a generic Instruction.\n\npublic:\n  User(const User &) = delete;\n\n  /// Free memory allocated for User and Use objects.\n  void operator delete(void *Usr);\n  /// Placement delete - required by std, called if the ctor throws.\n  void operator delete(void *Usr, unsigned) {\n    // Note: If a subclass manipulates the information which is required to calculate the\n    // Usr memory pointer, e.g. NumUserOperands, the operator delete of that subclass has\n    // to restore the changed information to the original value, since the dtor of that class\n    // is not called if the ctor fails.\n    User::operator delete(Usr);\n\n#ifndef LLVM_ENABLE_EXCEPTIONS\n    llvm_unreachable(\"Constructor throws?\");\n#endif\n  }\n  /// Placement delete - required by std, called if the ctor throws.\n  void operator delete(void *Usr, unsigned, unsigned) {\n    // Note: If a subclass manipulates the information which is required to calculate the\n    // Usr memory pointer, e.g. NumUserOperands, the operator delete of that subclass has\n    // to restore the changed information to the original value, since the dtor of that class\n    // is not called if the ctor fails.\n    User::operator delete(Usr);\n\n#ifndef LLVM_ENABLE_EXCEPTIONS\n    llvm_unreachable(\"Constructor throws?\");\n#endif\n  }\n\nprotected:\n  template <int Idx, typename U> static Use &OpFrom(const U *that) {\n    return Idx < 0\n      ? OperandTraits<U>::op_end(const_cast<U*>(that))[Idx]\n      : OperandTraits<U>::op_begin(const_cast<U*>(that))[Idx];\n  }\n\n  template <int Idx> Use &Op() {\n    return OpFrom<Idx>(this);\n  }\n  template <int Idx> const Use &Op() const {\n    return OpFrom<Idx>(this);\n  }\n\nprivate:\n  const Use *getHungOffOperands() const {\n    return *(reinterpret_cast<const Use *const *>(this) - 1);\n  }\n\n  Use *&getHungOffOperands() { return *(reinterpret_cast<Use **>(this) - 1); }\n\n  const Use *getIntrusiveOperands() const {\n    return reinterpret_cast<const Use *>(this) - NumUserOperands;\n  }\n\n  Use *getIntrusiveOperands() {\n    return reinterpret_cast<Use *>(this) - NumUserOperands;\n  }\n\n  void setOperandList(Use *NewList) {\n    assert(HasHungOffUses &&\n           \"Setting operand list only required for hung off uses\");\n    getHungOffOperands() = NewList;\n  }\n\npublic:\n  const Use *getOperandList() const {\n    return HasHungOffUses ? getHungOffOperands() : getIntrusiveOperands();\n  }\n  Use *getOperandList() {\n    return const_cast<Use *>(static_cast<const User *>(this)->getOperandList());\n  }\n\n  Value *getOperand(unsigned i) const {\n    assert(i < NumUserOperands && \"getOperand() out of range!\");\n    return getOperandList()[i];\n  }\n\n  void setOperand(unsigned i, Value *Val) {\n    assert(i < NumUserOperands && \"setOperand() out of range!\");\n    assert((!isa<Constant>((const Value*)this) ||\n            isa<GlobalValue>((const Value*)this)) &&\n           \"Cannot mutate a constant with setOperand!\");\n    getOperandList()[i] = Val;\n  }\n\n  const Use &getOperandUse(unsigned i) const {\n    assert(i < NumUserOperands && \"getOperandUse() out of range!\");\n    return getOperandList()[i];\n  }\n  Use &getOperandUse(unsigned i) {\n    assert(i < NumUserOperands && \"getOperandUse() out of range!\");\n    return getOperandList()[i];\n  }\n\n  unsigned getNumOperands() const { return NumUserOperands; }\n\n  /// Returns the descriptor co-allocated with this User instance.\n  ArrayRef<const uint8_t> getDescriptor() const;\n\n  /// Returns the descriptor co-allocated with this User instance.\n  MutableArrayRef<uint8_t> getDescriptor();\n\n  /// Set the number of operands on a GlobalVariable.\n  ///\n  /// GlobalVariable always allocates space for a single operands, but\n  /// doesn't always use it.\n  ///\n  /// FIXME: As that the number of operands is used to find the start of\n  /// the allocated memory in operator delete, we need to always think we have\n  /// 1 operand before delete.\n  void setGlobalVariableNumOperands(unsigned NumOps) {\n    assert(NumOps <= 1 && \"GlobalVariable can only have 0 or 1 operands\");\n    NumUserOperands = NumOps;\n  }\n\n  /// Subclasses with hung off uses need to manage the operand count\n  /// themselves.  In these instances, the operand count isn't used to find the\n  /// OperandList, so there's no issue in having the operand count change.\n  void setNumHungOffUseOperands(unsigned NumOps) {\n    assert(HasHungOffUses && \"Must have hung off uses to use this method\");\n    assert(NumOps < (1u << NumUserOperandsBits) && \"Too many operands\");\n    NumUserOperands = NumOps;\n  }\n\n  /// A droppable user is a user for which uses can be dropped without affecting\n  /// correctness and should be dropped rather than preventing a transformation\n  /// from happening.\n  bool isDroppable() const;\n\n  // ---------------------------------------------------------------------------\n  // Operand Iterator interface...\n  //\n  using op_iterator = Use*;\n  using const_op_iterator = const Use*;\n  using op_range = iterator_range<op_iterator>;\n  using const_op_range = iterator_range<const_op_iterator>;\n\n  op_iterator       op_begin()       { return getOperandList(); }\n  const_op_iterator op_begin() const { return getOperandList(); }\n  op_iterator       op_end()         {\n    return getOperandList() + NumUserOperands;\n  }\n  const_op_iterator op_end()   const {\n    return getOperandList() + NumUserOperands;\n  }\n  op_range operands() {\n    return op_range(op_begin(), op_end());\n  }\n  const_op_range operands() const {\n    return const_op_range(op_begin(), op_end());\n  }\n\n  /// Iterator for directly iterating over the operand Values.\n  struct value_op_iterator\n      : iterator_adaptor_base<value_op_iterator, op_iterator,\n                              std::random_access_iterator_tag, Value *,\n                              ptrdiff_t, Value *, Value *> {\n    explicit value_op_iterator(Use *U = nullptr) : iterator_adaptor_base(U) {}\n\n    Value *operator*() const { return *I; }\n    Value *operator->() const { return operator*(); }\n  };\n\n  value_op_iterator value_op_begin() {\n    return value_op_iterator(op_begin());\n  }\n  value_op_iterator value_op_end() {\n    return value_op_iterator(op_end());\n  }\n  iterator_range<value_op_iterator> operand_values() {\n    return make_range(value_op_begin(), value_op_end());\n  }\n\n  struct const_value_op_iterator\n      : iterator_adaptor_base<const_value_op_iterator, const_op_iterator,\n                              std::random_access_iterator_tag, const Value *,\n                              ptrdiff_t, const Value *, const Value *> {\n    explicit const_value_op_iterator(const Use *U = nullptr) :\n      iterator_adaptor_base(U) {}\n\n    const Value *operator*() const { return *I; }\n    const Value *operator->() const { return operator*(); }\n  };\n\n  const_value_op_iterator value_op_begin() const {\n    return const_value_op_iterator(op_begin());\n  }\n  const_value_op_iterator value_op_end() const {\n    return const_value_op_iterator(op_end());\n  }\n  iterator_range<const_value_op_iterator> operand_values() const {\n    return make_range(value_op_begin(), value_op_end());\n  }\n\n  /// Drop all references to operands.\n  ///\n  /// This function is in charge of \"letting go\" of all objects that this User\n  /// refers to.  This allows one to 'delete' a whole class at a time, even\n  /// though there may be circular references...  First all references are\n  /// dropped, and all use counts go to zero.  Then everything is deleted for\n  /// real.  Note that no operations are valid on an object that has \"dropped\n  /// all references\", except operator delete.\n  void dropAllReferences() {\n    for (Use &U : operands())\n      U.set(nullptr);\n  }\n\n  /// Replace uses of one Value with another.\n  ///\n  /// Replaces all references to the \"From\" definition with references to the\n  /// \"To\" definition.\n  void replaceUsesOfWith(Value *From, Value *To);\n\n  // Methods for support type inquiry through isa, cast, and dyn_cast:\n  static bool classof(const Value *V) {\n    return isa<Instruction>(V) || isa<Constant>(V);\n  }\n};\n\n// Either Use objects, or a Use pointer can be prepended to User.\nstatic_assert(alignof(Use) >= alignof(User),\n              \"Alignment is insufficient after objects prepended to User\");\nstatic_assert(alignof(Use *) >= alignof(User),\n              \"Alignment is insufficient after objects prepended to User\");\n\ntemplate<> struct simplify_type<User::op_iterator> {\n  using SimpleType = Value*;\n\n  static SimpleType getSimplifiedValue(User::op_iterator &Val) {\n    return Val->get();\n  }\n};\ntemplate<> struct simplify_type<User::const_op_iterator> {\n  using SimpleType = /*const*/ Value*;\n\n  static SimpleType getSimplifiedValue(User::const_op_iterator &Val) {\n    return Val->get();\n  }\n};\n\n} // end namespace llvm\n\n#endif // LLVM_IR_USER_H\n"}, "47": {"id": 47, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/IR/Value.h", "content": "//===- llvm/Value.h - Definition of the Value class -------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// This file declares the Value class.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_IR_VALUE_H\n#define LLVM_IR_VALUE_H\n\n#include \"llvm-c/Types.h\"\n#include \"llvm/ADT/STLExtras.h\"\n#include \"llvm/ADT/StringRef.h\"\n#include \"llvm/ADT/iterator_range.h\"\n#include \"llvm/IR/Use.h\"\n#include \"llvm/Support/Alignment.h\"\n#include \"llvm/Support/CBindingWrapping.h\"\n#include \"llvm/Support/Casting.h\"\n#include <cassert>\n#include <iterator>\n#include <memory>\n\nnamespace llvm {\n\nclass APInt;\nclass Argument;\nclass BasicBlock;\nclass Constant;\nclass ConstantData;\nclass ConstantAggregate;\nclass DataLayout;\nclass Function;\nclass GlobalAlias;\nclass GlobalIFunc;\nclass GlobalIndirectSymbol;\nclass GlobalObject;\nclass GlobalValue;\nclass GlobalVariable;\nclass InlineAsm;\nclass Instruction;\nclass LLVMContext;\nclass MDNode;\nclass Module;\nclass ModuleSlotTracker;\nclass raw_ostream;\ntemplate<typename ValueTy> class StringMapEntry;\nclass Twine;\nclass Type;\nclass User;\n\nusing ValueName = StringMapEntry<Value *>;\n\n//===----------------------------------------------------------------------===//\n//                                 Value Class\n//===----------------------------------------------------------------------===//\n\n/// LLVM Value Representation\n///\n/// This is a very important LLVM class. It is the base class of all values\n/// computed by a program that may be used as operands to other values. Value is\n/// the super class of other important classes such as Instruction and Function.\n/// All Values have a Type. Type is not a subclass of Value. Some values can\n/// have a name and they belong to some Module.  Setting the name on the Value\n/// automatically updates the module's symbol table.\n///\n/// Every value has a \"use list\" that keeps track of which other Values are\n/// using this Value.  A Value can also have an arbitrary number of ValueHandle\n/// objects that watch it and listen to RAUW and Destroy events.  See\n/// llvm/IR/ValueHandle.h for details.\nclass Value {\n  Type *VTy;\n  Use *UseList;\n\n  friend class ValueAsMetadata; // Allow access to IsUsedByMD.\n  friend class ValueHandleBase;\n\n  const unsigned char SubclassID;   // Subclass identifier (for isa/dyn_cast)\n  unsigned char HasValueHandle : 1; // Has a ValueHandle pointing to this?\n\nprotected:\n  /// Hold subclass data that can be dropped.\n  ///\n  /// This member is similar to SubclassData, however it is for holding\n  /// information which may be used to aid optimization, but which may be\n  /// cleared to zero without affecting conservative interpretation.\n  unsigned char SubclassOptionalData : 7;\n\nprivate:\n  /// Hold arbitrary subclass data.\n  ///\n  /// This member is defined by this class, but is not used for anything.\n  /// Subclasses can use it to hold whatever state they find useful.  This\n  /// field is initialized to zero by the ctor.\n  unsigned short SubclassData;\n\nprotected:\n  /// The number of operands in the subclass.\n  ///\n  /// This member is defined by this class, but not used for anything.\n  /// Subclasses can use it to store their number of operands, if they have\n  /// any.\n  ///\n  /// This is stored here to save space in User on 64-bit hosts.  Since most\n  /// instances of Value have operands, 32-bit hosts aren't significantly\n  /// affected.\n  ///\n  /// Note, this should *NOT* be used directly by any class other than User.\n  /// User uses this value to find the Use list.\n  enum : unsigned { NumUserOperandsBits = 27 };\n  unsigned NumUserOperands : NumUserOperandsBits;\n\n  // Use the same type as the bitfield above so that MSVC will pack them.\n  unsigned IsUsedByMD : 1;\n  unsigned HasName : 1;\n  unsigned HasMetadata : 1; // Has metadata attached to this?\n  unsigned HasHungOffUses : 1;\n  unsigned HasDescriptor : 1;\n\nprivate:\n  template <typename UseT> // UseT == 'Use' or 'const Use'\n  class use_iterator_impl\n      : public std::iterator<std::forward_iterator_tag, UseT *> {\n    friend class Value;\n\n    UseT *U;\n\n    explicit use_iterator_impl(UseT *u) : U(u) {}\n\n  public:\n    use_iterator_impl() : U() {}\n\n    bool operator==(const use_iterator_impl &x) const { return U == x.U; }\n    bool operator!=(const use_iterator_impl &x) const { return !operator==(x); }\n\n    use_iterator_impl &operator++() { // Preincrement\n      assert(U && \"Cannot increment end iterator!\");\n      U = U->getNext();\n      return *this;\n    }\n\n    use_iterator_impl operator++(int) { // Postincrement\n      auto tmp = *this;\n      ++*this;\n      return tmp;\n    }\n\n    UseT &operator*() const {\n      assert(U && \"Cannot dereference end iterator!\");\n      return *U;\n    }\n\n    UseT *operator->() const { return &operator*(); }\n\n    operator use_iterator_impl<const UseT>() const {\n      return use_iterator_impl<const UseT>(U);\n    }\n  };\n\n  template <typename UserTy> // UserTy == 'User' or 'const User'\n  class user_iterator_impl\n      : public std::iterator<std::forward_iterator_tag, UserTy *> {\n    use_iterator_impl<Use> UI;\n    explicit user_iterator_impl(Use *U) : UI(U) {}\n    friend class Value;\n\n  public:\n    user_iterator_impl() = default;\n\n    bool operator==(const user_iterator_impl &x) const { return UI == x.UI; }\n    bool operator!=(const user_iterator_impl &x) const { return !operator==(x); }\n\n    /// Returns true if this iterator is equal to user_end() on the value.\n    bool atEnd() const { return *this == user_iterator_impl(); }\n\n    user_iterator_impl &operator++() { // Preincrement\n      ++UI;\n      return *this;\n    }\n\n    user_iterator_impl operator++(int) { // Postincrement\n      auto tmp = *this;\n      ++*this;\n      return tmp;\n    }\n\n    // Retrieve a pointer to the current User.\n    UserTy *operator*() const {\n      return UI->getUser();\n    }\n\n    UserTy *operator->() const { return operator*(); }\n\n    operator user_iterator_impl<const UserTy>() const {\n      return user_iterator_impl<const UserTy>(*UI);\n    }\n\n    Use &getUse() const { return *UI; }\n  };\n\nprotected:\n  Value(Type *Ty, unsigned scid);\n\n  /// Value's destructor should be virtual by design, but that would require\n  /// that Value and all of its subclasses have a vtable that effectively\n  /// duplicates the information in the value ID. As a size optimization, the\n  /// destructor has been protected, and the caller should manually call\n  /// deleteValue.\n  ~Value(); // Use deleteValue() to delete a generic Value.\n\npublic:\n  Value(const Value &) = delete;\n  Value &operator=(const Value &) = delete;\n\n  /// Delete a pointer to a generic Value.\n  void deleteValue();\n\n  /// Support for debugging, callable in GDB: V->dump()\n  void dump() const;\n\n  /// Implement operator<< on Value.\n  /// @{\n  void print(raw_ostream &O, bool IsForDebug = false) const;\n  void print(raw_ostream &O, ModuleSlotTracker &MST,\n             bool IsForDebug = false) const;\n  /// @}\n\n  /// Print the name of this Value out to the specified raw_ostream.\n  ///\n  /// This is useful when you just want to print 'int %reg126', not the\n  /// instruction that generated it. If you specify a Module for context, then\n  /// even constanst get pretty-printed; for example, the type of a null\n  /// pointer is printed symbolically.\n  /// @{\n  void printAsOperand(raw_ostream &O, bool PrintType = true,\n                      const Module *M = nullptr) const;\n  void printAsOperand(raw_ostream &O, bool PrintType,\n                      ModuleSlotTracker &MST) const;\n  /// @}\n\n  /// All values are typed, get the type of this value.\n  Type *getType() const { return VTy; }\n\n  /// All values hold a context through their type.\n  LLVMContext &getContext() const;\n\n  // All values can potentially be named.\n  bool hasName() const { return HasName; }\n  ValueName *getValueName() const;\n  void setValueName(ValueName *VN);\n\nprivate:\n  void destroyValueName();\n  enum class ReplaceMetadataUses { No, Yes };\n  void doRAUW(Value *New, ReplaceMetadataUses);\n  void setNameImpl(const Twine &Name);\n\npublic:\n  /// Return a constant reference to the value's name.\n  ///\n  /// This guaranteed to return the same reference as long as the value is not\n  /// modified.  If the value has a name, this does a hashtable lookup, so it's\n  /// not free.\n  StringRef getName() const;\n\n  /// Change the name of the value.\n  ///\n  /// Choose a new unique name if the provided name is taken.\n  ///\n  /// \\param Name The new name; or \"\" if the value's name should be removed.\n  void setName(const Twine &Name);\n\n  /// Transfer the name from V to this value.\n  ///\n  /// After taking V's name, sets V's name to empty.\n  ///\n  /// \\note It is an error to call V->takeName(V).\n  void takeName(Value *V);\n\n#ifndef NDEBUG\n  std::string getNameOrAsOperand() const;\n#endif\n\n  /// Change all uses of this to point to a new Value.\n  ///\n  /// Go through the uses list for this definition and make each use point to\n  /// \"V\" instead of \"this\".  After this completes, 'this's use list is\n  /// guaranteed to be empty.\n  void replaceAllUsesWith(Value *V);\n\n  /// Change non-metadata uses of this to point to a new Value.\n  ///\n  /// Go through the uses list for this definition and make each use point to\n  /// \"V\" instead of \"this\". This function skips metadata entries in the list.\n  void replaceNonMetadataUsesWith(Value *V);\n\n  /// Go through the uses list for this definition and make each use point\n  /// to \"V\" if the callback ShouldReplace returns true for the given Use.\n  /// Unlike replaceAllUsesWith() this function does not support basic block\n  /// values or constant users.\n  void replaceUsesWithIf(Value *New,\n                         llvm::function_ref<bool(Use &U)> ShouldReplace) {\n    assert(New && \"Value::replaceUsesWithIf(<null>) is invalid!\");\n    assert(New->getType() == getType() &&\n           \"replaceUses of value with new value of different type!\");\n\n    for (use_iterator UI = use_begin(), E = use_end(); UI != E;) {\n      Use &U = *UI;\n      ++UI;\n      if (!ShouldReplace(U))\n        continue;\n      U.set(New);\n    }\n  }\n\n  /// replaceUsesOutsideBlock - Go through the uses list for this definition and\n  /// make each use point to \"V\" instead of \"this\" when the use is outside the\n  /// block. 'This's use list is expected to have at least one element.\n  /// Unlike replaceAllUsesWith() this function does not support basic block\n  /// values or constant users.\n  void replaceUsesOutsideBlock(Value *V, BasicBlock *BB);\n\n  //----------------------------------------------------------------------\n  // Methods for handling the chain of uses of this Value.\n  //\n  // Materializing a function can introduce new uses, so these methods come in\n  // two variants:\n  // The methods that start with materialized_ check the uses that are\n  // currently known given which functions are materialized. Be very careful\n  // when using them since you might not get all uses.\n  // The methods that don't start with materialized_ assert that modules is\n  // fully materialized.\n  void assertModuleIsMaterializedImpl() const;\n  // This indirection exists so we can keep assertModuleIsMaterializedImpl()\n  // around in release builds of Value.cpp to be linked with other code built\n  // in debug mode. But this avoids calling it in any of the release built code.\n  void assertModuleIsMaterialized() const {\n#ifndef NDEBUG\n    assertModuleIsMaterializedImpl();\n#endif\n  }\n\n  bool use_empty() const {\n    assertModuleIsMaterialized();\n    return UseList == nullptr;\n  }\n\n  bool materialized_use_empty() const {\n    return UseList == nullptr;\n  }\n\n  using use_iterator = use_iterator_impl<Use>;\n  using const_use_iterator = use_iterator_impl<const Use>;\n\n  use_iterator materialized_use_begin() { return use_iterator(UseList); }\n  const_use_iterator materialized_use_begin() const {\n    return const_use_iterator(UseList);\n  }\n  use_iterator use_begin() {\n    assertModuleIsMaterialized();\n    return materialized_use_begin();\n  }\n  const_use_iterator use_begin() const {\n    assertModuleIsMaterialized();\n    return materialized_use_begin();\n  }\n  use_iterator use_end() { return use_iterator(); }\n  const_use_iterator use_end() const { return const_use_iterator(); }\n  iterator_range<use_iterator> materialized_uses() {\n    return make_range(materialized_use_begin(), use_end());\n  }\n  iterator_range<const_use_iterator> materialized_uses() const {\n    return make_range(materialized_use_begin(), use_end());\n  }\n  iterator_range<use_iterator> uses() {\n    assertModuleIsMaterialized();\n    return materialized_uses();\n  }\n  iterator_range<const_use_iterator> uses() const {\n    assertModuleIsMaterialized();\n    return materialized_uses();\n  }\n\n  bool user_empty() const {\n    assertModuleIsMaterialized();\n    return UseList == nullptr;\n  }\n\n  using user_iterator = user_iterator_impl<User>;\n  using const_user_iterator = user_iterator_impl<const User>;\n\n  user_iterator materialized_user_begin() { return user_iterator(UseList); }\n  const_user_iterator materialized_user_begin() const {\n    return const_user_iterator(UseList);\n  }\n  user_iterator user_begin() {\n    assertModuleIsMaterialized();\n    return materialized_user_begin();\n  }\n  const_user_iterator user_begin() const {\n    assertModuleIsMaterialized();\n    return materialized_user_begin();\n  }\n  user_iterator user_end() { return user_iterator(); }\n  const_user_iterator user_end() const { return const_user_iterator(); }\n  User *user_back() {\n    assertModuleIsMaterialized();\n    return *materialized_user_begin();\n  }\n  const User *user_back() const {\n    assertModuleIsMaterialized();\n    return *materialized_user_begin();\n  }\n  iterator_range<user_iterator> materialized_users() {\n    return make_range(materialized_user_begin(), user_end());\n  }\n  iterator_range<const_user_iterator> materialized_users() const {\n    return make_range(materialized_user_begin(), user_end());\n  }\n  iterator_range<user_iterator> users() {\n    assertModuleIsMaterialized();\n    return materialized_users();\n  }\n  iterator_range<const_user_iterator> users() const {\n    assertModuleIsMaterialized();\n    return materialized_users();\n  }\n\n  /// Return true if there is exactly one use of this value.\n  ///\n  /// This is specialized because it is a common request and does not require\n  /// traversing the whole use list.\n  bool hasOneUse() const { return hasSingleElement(uses()); }\n\n  /// Return true if this Value has exactly N uses.\n  bool hasNUses(unsigned N) const;\n\n  /// Return true if this value has N uses or more.\n  ///\n  /// This is logically equivalent to getNumUses() >= N.\n  bool hasNUsesOrMore(unsigned N) const;\n\n  /// Return true if there is exactly one user of this value.\n  ///\n  /// Note that this is not the same as \"has one use\". If a value has one use,\n  /// then there certainly is a single user. But if value has several uses,\n  /// it is possible that all uses are in a single user, or not.\n  ///\n  /// This check is potentially costly, since it requires traversing,\n  /// in the worst case, the whole use list of a value.\n  bool hasOneUser() const;\n\n  /// Return true if there is exactly one use of this value that cannot be\n  /// dropped.\n  ///\n  /// This is specialized because it is a common request and does not require\n  /// traversing the whole use list.\n  Use *getSingleUndroppableUse();\n  const Use *getSingleUndroppableUse() const {\n    return const_cast<Value *>(this)->getSingleUndroppableUse();\n  }\n\n  /// Return true if there this value.\n  ///\n  /// This is specialized because it is a common request and does not require\n  /// traversing the whole use list.\n  bool hasNUndroppableUses(unsigned N) const;\n\n  /// Return true if this value has N uses or more.\n  ///\n  /// This is logically equivalent to getNumUses() >= N.\n  bool hasNUndroppableUsesOrMore(unsigned N) const;\n\n  /// Remove every uses that can safely be removed.\n  ///\n  /// This will remove for example uses in llvm.assume.\n  /// This should be used when performing want to perform a tranformation but\n  /// some Droppable uses pervent it.\n  /// This function optionally takes a filter to only remove some droppable\n  /// uses.\n  void dropDroppableUses(llvm::function_ref<bool(const Use *)> ShouldDrop =\n                             [](const Use *) { return true; });\n\n  /// Remove every use of this value in \\p User that can safely be removed.\n  void dropDroppableUsesIn(User &Usr);\n\n  /// Remove the droppable use \\p U.\n  static void dropDroppableUse(Use &U);\n\n  /// Check if this value is used in the specified basic block.\n  bool isUsedInBasicBlock(const BasicBlock *BB) const;\n\n  /// This method computes the number of uses of this Value.\n  ///\n  /// This is a linear time operation.  Use hasOneUse, hasNUses, or\n  /// hasNUsesOrMore to check for specific values.\n  unsigned getNumUses() const;\n\n  /// This method should only be used by the Use class.\n  void addUse(Use &U) { U.addToList(&UseList); }\n\n  /// Concrete subclass of this.\n  ///\n  /// An enumeration for keeping track of the concrete subclass of Value that\n  /// is actually instantiated. Values of this enumeration are kept in the\n  /// Value classes SubclassID field. They are used for concrete type\n  /// identification.\n  enum ValueTy {\n#define HANDLE_VALUE(Name) Name##Val,\n#include \"llvm/IR/Value.def\"\n\n    // Markers:\n#define HANDLE_CONSTANT_MARKER(Marker, Constant) Marker = Constant##Val,\n#include \"llvm/IR/Value.def\"\n  };\n\n  /// Return an ID for the concrete type of this object.\n  ///\n  /// This is used to implement the classof checks.  This should not be used\n  /// for any other purpose, as the values may change as LLVM evolves.  Also,\n  /// note that for instructions, the Instruction's opcode is added to\n  /// InstructionVal. So this means three things:\n  /// # there is no value with code InstructionVal (no opcode==0).\n  /// # there are more possible values for the value type than in ValueTy enum.\n  /// # the InstructionVal enumerator must be the highest valued enumerator in\n  ///   the ValueTy enum.\n  unsigned getValueID() const {\n    return SubclassID;\n  }\n\n  /// Return the raw optional flags value contained in this value.\n  ///\n  /// This should only be used when testing two Values for equivalence.\n  unsigned getRawSubclassOptionalData() const {\n    return SubclassOptionalData;\n  }\n\n  /// Clear the optional flags contained in this value.\n  void clearSubclassOptionalData() {\n    SubclassOptionalData = 0;\n  }\n\n  /// Check the optional flags for equality.\n  bool hasSameSubclassOptionalData(const Value *V) const {\n    return SubclassOptionalData == V->SubclassOptionalData;\n  }\n\n  /// Return true if there is a value handle associated with this value.\n  bool hasValueHandle() const { return HasValueHandle; }\n\n  /// Return true if there is metadata referencing this value.\n  bool isUsedByMetadata() const { return IsUsedByMD; }\n\nprotected:\n  /// Get the current metadata attachments for the given kind, if any.\n  ///\n  /// These functions require that the value have at most a single attachment\n  /// of the given kind, and return \\c nullptr if such an attachment is missing.\n  /// @{\n  MDNode *getMetadata(unsigned KindID) const;\n  MDNode *getMetadata(StringRef Kind) const;\n  /// @}\n\n  /// Appends all attachments with the given ID to \\c MDs in insertion order.\n  /// If the Value has no attachments with the given ID, or if ID is invalid,\n  /// leaves MDs unchanged.\n  /// @{\n  void getMetadata(unsigned KindID, SmallVectorImpl<MDNode *> &MDs) const;\n  void getMetadata(StringRef Kind, SmallVectorImpl<MDNode *> &MDs) const;\n  /// @}\n\n  /// Appends all metadata attached to this value to \\c MDs, sorting by\n  /// KindID. The first element of each pair returned is the KindID, the second\n  /// element is the metadata value. Attachments with the same ID appear in\n  /// insertion order.\n  void\n  getAllMetadata(SmallVectorImpl<std::pair<unsigned, MDNode *>> &MDs) const;\n\n  /// Return true if this value has any metadata attached to it.\n  bool hasMetadata() const { return (bool)HasMetadata; }\n\n  /// Return true if this value has the given type of metadata attached.\n  /// @{\n  bool hasMetadata(unsigned KindID) const {\n    return getMetadata(KindID) != nullptr;\n  }\n  bool hasMetadata(StringRef Kind) const {\n    return getMetadata(Kind) != nullptr;\n  }\n  /// @}\n\n  /// Set a particular kind of metadata attachment.\n  ///\n  /// Sets the given attachment to \\c MD, erasing it if \\c MD is \\c nullptr or\n  /// replacing it if it already exists.\n  /// @{\n  void setMetadata(unsigned KindID, MDNode *Node);\n  void setMetadata(StringRef Kind, MDNode *Node);\n  /// @}\n\n  /// Add a metadata attachment.\n  /// @{\n  void addMetadata(unsigned KindID, MDNode &MD);\n  void addMetadata(StringRef Kind, MDNode &MD);\n  /// @}\n\n  /// Erase all metadata attachments with the given kind.\n  ///\n  /// \\returns true if any metadata was removed.\n  bool eraseMetadata(unsigned KindID);\n\n  /// Erase all metadata attached to this Value.\n  void clearMetadata();\n\npublic:\n  /// Return true if this value is a swifterror value.\n  ///\n  /// swifterror values can be either a function argument or an alloca with a\n  /// swifterror attribute.\n  bool isSwiftError() const;\n\n  /// Strip off pointer casts, all-zero GEPs and address space casts.\n  ///\n  /// Returns the original uncasted value.  If this is called on a non-pointer\n  /// value, it returns 'this'.\n  const Value *stripPointerCasts() const;\n  Value *stripPointerCasts() {\n    return const_cast<Value *>(\n        static_cast<const Value *>(this)->stripPointerCasts());\n  }\n\n  /// Strip off pointer casts, all-zero GEPs, address space casts, and aliases.\n  ///\n  /// Returns the original uncasted value.  If this is called on a non-pointer\n  /// value, it returns 'this'.\n  const Value *stripPointerCastsAndAliases() const;\n  Value *stripPointerCastsAndAliases() {\n    return const_cast<Value *>(\n        static_cast<const Value *>(this)->stripPointerCastsAndAliases());\n  }\n\n  /// Strip off pointer casts, all-zero GEPs and address space casts\n  /// but ensures the representation of the result stays the same.\n  ///\n  /// Returns the original uncasted value with the same representation. If this\n  /// is called on a non-pointer value, it returns 'this'.\n  const Value *stripPointerCastsSameRepresentation() const;\n  Value *stripPointerCastsSameRepresentation() {\n    return const_cast<Value *>(static_cast<const Value *>(this)\n                                   ->stripPointerCastsSameRepresentation());\n  }\n\n  /// Strip off pointer casts, all-zero GEPs, single-argument phi nodes and\n  /// invariant group info.\n  ///\n  /// Returns the original uncasted value.  If this is called on a non-pointer\n  /// value, it returns 'this'. This function should be used only in\n  /// Alias analysis.\n  const Value *stripPointerCastsForAliasAnalysis() const;\n  Value *stripPointerCastsForAliasAnalysis() {\n    return const_cast<Value *>(static_cast<const Value *>(this)\n                                   ->stripPointerCastsForAliasAnalysis());\n  }\n\n  /// Strip off pointer casts and all-constant inbounds GEPs.\n  ///\n  /// Returns the original pointer value.  If this is called on a non-pointer\n  /// value, it returns 'this'.\n  const Value *stripInBoundsConstantOffsets() const;\n  Value *stripInBoundsConstantOffsets() {\n    return const_cast<Value *>(\n              static_cast<const Value *>(this)->stripInBoundsConstantOffsets());\n  }\n\n  /// Accumulate the constant offset this value has compared to a base pointer.\n  /// Only 'getelementptr' instructions (GEPs) are accumulated but other\n  /// instructions, e.g., casts, are stripped away as well.\n  /// The accumulated constant offset is added to \\p Offset and the base\n  /// pointer is returned.\n  ///\n  /// The APInt \\p Offset has to have a bit-width equal to the IntPtr type for\n  /// the address space of 'this' pointer value, e.g., use\n  /// DataLayout::getIndexTypeSizeInBits(Ty).\n  ///\n  /// If \\p AllowNonInbounds is true, offsets in GEPs are stripped and\n  /// accumulated even if the GEP is not \"inbounds\".\n  ///\n  /// If \\p ExternalAnalysis is provided it will be used to calculate a offset\n  /// when a operand of GEP is not constant.\n  /// For example, for a value \\p ExternalAnalysis might try to calculate a\n  /// lower bound. If \\p ExternalAnalysis is successful, it should return true.\n  ///\n  /// If this is called on a non-pointer value, it returns 'this' and the\n  /// \\p Offset is not modified.\n  ///\n  /// Note that this function will never return a nullptr. It will also never\n  /// manipulate the \\p Offset in a way that would not match the difference\n  /// between the underlying value and the returned one. Thus, if no constant\n  /// offset was found, the returned value is the underlying one and \\p Offset\n  /// is unchanged.\n  const Value *stripAndAccumulateConstantOffsets(\n      const DataLayout &DL, APInt &Offset, bool AllowNonInbounds,\n      function_ref<bool(Value &Value, APInt &Offset)> ExternalAnalysis =\n          nullptr) const;\n  Value *stripAndAccumulateConstantOffsets(const DataLayout &DL, APInt &Offset,\n                                           bool AllowNonInbounds) {\n    return const_cast<Value *>(\n        static_cast<const Value *>(this)->stripAndAccumulateConstantOffsets(\n            DL, Offset, AllowNonInbounds));\n  }\n\n  /// This is a wrapper around stripAndAccumulateConstantOffsets with the\n  /// in-bounds requirement set to false.\n  const Value *stripAndAccumulateInBoundsConstantOffsets(const DataLayout &DL,\n                                                         APInt &Offset) const {\n    return stripAndAccumulateConstantOffsets(DL, Offset,\n                                             /* AllowNonInbounds */ false);\n  }\n  Value *stripAndAccumulateInBoundsConstantOffsets(const DataLayout &DL,\n                                                   APInt &Offset) {\n    return stripAndAccumulateConstantOffsets(DL, Offset,\n                                             /* AllowNonInbounds */ false);\n  }\n\n  /// Strip off pointer casts and inbounds GEPs.\n  ///\n  /// Returns the original pointer value.  If this is called on a non-pointer\n  /// value, it returns 'this'.\n  const Value *stripInBoundsOffsets(function_ref<void(const Value *)> Func =\n                                        [](const Value *) {}) const;\n  inline Value *stripInBoundsOffsets(function_ref<void(const Value *)> Func =\n                                  [](const Value *) {}) {\n    return const_cast<Value *>(\n        static_cast<const Value *>(this)->stripInBoundsOffsets(Func));\n  }\n\n  /// Returns the number of bytes known to be dereferenceable for the\n  /// pointer value.\n  ///\n  /// If CanBeNull is set by this function the pointer can either be null or be\n  /// dereferenceable up to the returned number of bytes.\n  uint64_t getPointerDereferenceableBytes(const DataLayout &DL,\n                                          bool &CanBeNull) const;\n\n  /// Returns an alignment of the pointer value.\n  ///\n  /// Returns an alignment which is either specified explicitly, e.g. via\n  /// align attribute of a function argument, or guaranteed by DataLayout.\n  Align getPointerAlignment(const DataLayout &DL) const;\n\n  /// Translate PHI node to its predecessor from the given basic block.\n  ///\n  /// If this value is a PHI node with CurBB as its parent, return the value in\n  /// the PHI node corresponding to PredBB.  If not, return ourself.  This is\n  /// useful if you want to know the value something has in a predecessor\n  /// block.\n  const Value *DoPHITranslation(const BasicBlock *CurBB,\n                                const BasicBlock *PredBB) const;\n  Value *DoPHITranslation(const BasicBlock *CurBB, const BasicBlock *PredBB) {\n    return const_cast<Value *>(\n             static_cast<const Value *>(this)->DoPHITranslation(CurBB, PredBB));\n  }\n\n  /// The maximum alignment for instructions.\n  ///\n  /// This is the greatest alignment value supported by load, store, and alloca\n  /// instructions, and global values.\n  static const unsigned MaxAlignmentExponent = 29;\n  static const unsigned MaximumAlignment = 1u << MaxAlignmentExponent;\n\n  /// Mutate the type of this Value to be of the specified type.\n  ///\n  /// Note that this is an extremely dangerous operation which can create\n  /// completely invalid IR very easily.  It is strongly recommended that you\n  /// recreate IR objects with the right types instead of mutating them in\n  /// place.\n  void mutateType(Type *Ty) {\n    VTy = Ty;\n  }\n\n  /// Sort the use-list.\n  ///\n  /// Sorts the Value's use-list by Cmp using a stable mergesort.  Cmp is\n  /// expected to compare two \\a Use references.\n  template <class Compare> void sortUseList(Compare Cmp);\n\n  /// Reverse the use-list.\n  void reverseUseList();\n\nprivate:\n  /// Merge two lists together.\n  ///\n  /// Merges \\c L and \\c R using \\c Cmp.  To enable stable sorts, always pushes\n  /// \"equal\" items from L before items from R.\n  ///\n  /// \\return the first element in the list.\n  ///\n  /// \\note Completely ignores \\a Use::Prev (doesn't read, doesn't update).\n  template <class Compare>\n  static Use *mergeUseLists(Use *L, Use *R, Compare Cmp) {\n    Use *Merged;\n    Use **Next = &Merged;\n\n    while (true) {\n      if (!L) {\n        *Next = R;\n        break;\n      }\n      if (!R) {\n        *Next = L;\n        break;\n      }\n      if (Cmp(*R, *L)) {\n        *Next = R;\n        Next = &R->Next;\n        R = R->Next;\n      } else {\n        *Next = L;\n        Next = &L->Next;\n        L = L->Next;\n      }\n    }\n\n    return Merged;\n  }\n\nprotected:\n  unsigned short getSubclassDataFromValue() const { return SubclassData; }\n  void setValueSubclassData(unsigned short D) { SubclassData = D; }\n};\n\nstruct ValueDeleter { void operator()(Value *V) { V->deleteValue(); } };\n\n/// Use this instead of std::unique_ptr<Value> or std::unique_ptr<Instruction>.\n/// Those don't work because Value and Instruction's destructors are protected,\n/// aren't virtual, and won't destroy the complete object.\nusing unique_value = std::unique_ptr<Value, ValueDeleter>;\n\ninline raw_ostream &operator<<(raw_ostream &OS, const Value &V) {\n  V.print(OS);\n  return OS;\n}\n\nvoid Use::set(Value *V) {\n  if (Val) removeFromList();\n  Val = V;\n  if (V) V->addUse(*this);\n}\n\nValue *Use::operator=(Value *RHS) {\n  set(RHS);\n  return RHS;\n}\n\nconst Use &Use::operator=(const Use &RHS) {\n  set(RHS.Val);\n  return *this;\n}\n\ntemplate <class Compare> void Value::sortUseList(Compare Cmp) {\n  if (!UseList || !UseList->Next)\n    // No need to sort 0 or 1 uses.\n    return;\n\n  // Note: this function completely ignores Prev pointers until the end when\n  // they're fixed en masse.\n\n  // Create a binomial vector of sorted lists, visiting uses one at a time and\n  // merging lists as necessary.\n  const unsigned MaxSlots = 32;\n  Use *Slots[MaxSlots];\n\n  // Collect the first use, turning it into a single-item list.\n  Use *Next = UseList->Next;\n  UseList->Next = nullptr;\n  unsigned NumSlots = 1;\n  Slots[0] = UseList;\n\n  // Collect all but the last use.\n  while (Next->Next) {\n    Use *Current = Next;\n    Next = Current->Next;\n\n    // Turn Current into a single-item list.\n    Current->Next = nullptr;\n\n    // Save Current in the first available slot, merging on collisions.\n    unsigned I;\n    for (I = 0; I < NumSlots; ++I) {\n      if (!Slots[I])\n        break;\n\n      // Merge two lists, doubling the size of Current and emptying slot I.\n      //\n      // Since the uses in Slots[I] originally preceded those in Current, send\n      // Slots[I] in as the left parameter to maintain a stable sort.\n      Current = mergeUseLists(Slots[I], Current, Cmp);\n      Slots[I] = nullptr;\n    }\n    // Check if this is a new slot.\n    if (I == NumSlots) {\n      ++NumSlots;\n      assert(NumSlots <= MaxSlots && \"Use list bigger than 2^32\");\n    }\n\n    // Found an open slot.\n    Slots[I] = Current;\n  }\n\n  // Merge all the lists together.\n  assert(Next && \"Expected one more Use\");\n  assert(!Next->Next && \"Expected only one Use\");\n  UseList = Next;\n  for (unsigned I = 0; I < NumSlots; ++I)\n    if (Slots[I])\n      // Since the uses in Slots[I] originally preceded those in UseList, send\n      // Slots[I] in as the left parameter to maintain a stable sort.\n      UseList = mergeUseLists(Slots[I], UseList, Cmp);\n\n  // Fix the Prev pointers.\n  for (Use *I = UseList, **Prev = &UseList; I; I = I->Next) {\n    I->Prev = Prev;\n    Prev = &I->Next;\n  }\n}\n\n// isa - Provide some specializations of isa so that we don't have to include\n// the subtype header files to test to see if the value is a subclass...\n//\ntemplate <> struct isa_impl<Constant, Value> {\n  static inline bool doit(const Value &Val) {\n    static_assert(Value::ConstantFirstVal == 0, \"Val.getValueID() >= Value::ConstantFirstVal\");\n    return Val.getValueID() <= Value::ConstantLastVal;\n  }\n};\n\ntemplate <> struct isa_impl<ConstantData, Value> {\n  static inline bool doit(const Value &Val) {\n    return Val.getValueID() >= Value::ConstantDataFirstVal &&\n           Val.getValueID() <= Value::ConstantDataLastVal;\n  }\n};\n\ntemplate <> struct isa_impl<ConstantAggregate, Value> {\n  static inline bool doit(const Value &Val) {\n    return Val.getValueID() >= Value::ConstantAggregateFirstVal &&\n           Val.getValueID() <= Value::ConstantAggregateLastVal;\n  }\n};\n\ntemplate <> struct isa_impl<Argument, Value> {\n  static inline bool doit (const Value &Val) {\n    return Val.getValueID() == Value::ArgumentVal;\n  }\n};\n\ntemplate <> struct isa_impl<InlineAsm, Value> {\n  static inline bool doit(const Value &Val) {\n    return Val.getValueID() == Value::InlineAsmVal;\n  }\n};\n\ntemplate <> struct isa_impl<Instruction, Value> {\n  static inline bool doit(const Value &Val) {\n    return Val.getValueID() >= Value::InstructionVal;\n  }\n};\n\ntemplate <> struct isa_impl<BasicBlock, Value> {\n  static inline bool doit(const Value &Val) {\n    return Val.getValueID() == Value::BasicBlockVal;\n  }\n};\n\ntemplate <> struct isa_impl<Function, Value> {\n  static inline bool doit(const Value &Val) {\n    return Val.getValueID() == Value::FunctionVal;\n  }\n};\n\ntemplate <> struct isa_impl<GlobalVariable, Value> {\n  static inline bool doit(const Value &Val) {\n    return Val.getValueID() == Value::GlobalVariableVal;\n  }\n};\n\ntemplate <> struct isa_impl<GlobalAlias, Value> {\n  static inline bool doit(const Value &Val) {\n    return Val.getValueID() == Value::GlobalAliasVal;\n  }\n};\n\ntemplate <> struct isa_impl<GlobalIFunc, Value> {\n  static inline bool doit(const Value &Val) {\n    return Val.getValueID() == Value::GlobalIFuncVal;\n  }\n};\n\ntemplate <> struct isa_impl<GlobalIndirectSymbol, Value> {\n  static inline bool doit(const Value &Val) {\n    return isa<GlobalAlias>(Val) || isa<GlobalIFunc>(Val);\n  }\n};\n\ntemplate <> struct isa_impl<GlobalValue, Value> {\n  static inline bool doit(const Value &Val) {\n    return isa<GlobalObject>(Val) || isa<GlobalIndirectSymbol>(Val);\n  }\n};\n\ntemplate <> struct isa_impl<GlobalObject, Value> {\n  static inline bool doit(const Value &Val) {\n    return isa<GlobalVariable>(Val) || isa<Function>(Val);\n  }\n};\n\n// Create wrappers for C Binding types (see CBindingWrapping.h).\nDEFINE_ISA_CONVERSION_FUNCTIONS(Value, LLVMValueRef)\n\n// Specialized opaque value conversions.\ninline Value **unwrap(LLVMValueRef *Vals) {\n  return reinterpret_cast<Value**>(Vals);\n}\n\ntemplate<typename T>\ninline T **unwrap(LLVMValueRef *Vals, unsigned Length) {\n#ifndef NDEBUG\n  for (LLVMValueRef *I = Vals, *E = Vals + Length; I != E; ++I)\n    unwrap<T>(*I); // For side effect of calling assert on invalid usage.\n#endif\n  (void)Length;\n  return reinterpret_cast<T**>(Vals);\n}\n\ninline LLVMValueRef *wrap(const Value **Vals) {\n  return reinterpret_cast<LLVMValueRef*>(const_cast<Value**>(Vals));\n}\n\n} // end namespace llvm\n\n#endif // LLVM_IR_VALUE_H\n"}, "48": {"id": 48, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/IR/ValueHandle.h", "content": "//===- ValueHandle.h - Value Smart Pointer classes --------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// This file declares the ValueHandle class and its sub-classes.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_IR_VALUEHANDLE_H\n#define LLVM_IR_VALUEHANDLE_H\n\n#include \"llvm/ADT/DenseMapInfo.h\"\n#include \"llvm/ADT/PointerIntPair.h\"\n#include \"llvm/IR/Value.h\"\n#include \"llvm/Support/Casting.h\"\n#include <cassert>\n\nnamespace llvm {\n\n/// This is the common base class of value handles.\n///\n/// ValueHandle's are smart pointers to Value's that have special behavior when\n/// the value is deleted or ReplaceAllUsesWith'd.  See the specific handles\n/// below for details.\nclass ValueHandleBase {\n  friend class Value;\n\nprotected:\n  /// This indicates what sub class the handle actually is.\n  ///\n  /// This is to avoid having a vtable for the light-weight handle pointers. The\n  /// fully general Callback version does have a vtable.\n  enum HandleBaseKind { Assert, Callback, Weak, WeakTracking };\n\n  ValueHandleBase(const ValueHandleBase &RHS)\n      : ValueHandleBase(RHS.PrevPair.getInt(), RHS) {}\n\n  ValueHandleBase(HandleBaseKind Kind, const ValueHandleBase &RHS)\n      : PrevPair(nullptr, Kind), Val(RHS.getValPtr()) {\n    if (isValid(getValPtr()))\n      AddToExistingUseList(RHS.getPrevPtr());\n  }\n\nprivate:\n  PointerIntPair<ValueHandleBase**, 2, HandleBaseKind> PrevPair;\n  ValueHandleBase *Next = nullptr;\n  Value *Val = nullptr;\n\n  void setValPtr(Value *V) { Val = V; }\n\npublic:\n  explicit ValueHandleBase(HandleBaseKind Kind)\n      : PrevPair(nullptr, Kind) {}\n  ValueHandleBase(HandleBaseKind Kind, Value *V)\n      : PrevPair(nullptr, Kind), Val(V) {\n    if (isValid(getValPtr()))\n      AddToUseList();\n  }\n\n  ~ValueHandleBase() {\n    if (isValid(getValPtr()))\n      RemoveFromUseList();\n  }\n\n  Value *operator=(Value *RHS) {\n    if (getValPtr() == RHS)\n      return RHS;\n    if (isValid(getValPtr()))\n      RemoveFromUseList();\n    setValPtr(RHS);\n    if (isValid(getValPtr()))\n      AddToUseList();\n    return RHS;\n  }\n\n  Value *operator=(const ValueHandleBase &RHS) {\n    if (getValPtr() == RHS.getValPtr())\n      return RHS.getValPtr();\n    if (isValid(getValPtr()))\n      RemoveFromUseList();\n    setValPtr(RHS.getValPtr());\n    if (isValid(getValPtr()))\n      AddToExistingUseList(RHS.getPrevPtr());\n    return getValPtr();\n  }\n\n  Value *operator->() const { return getValPtr(); }\n  Value &operator*() const {\n    Value *V = getValPtr();\n    assert(V && \"Dereferencing deleted ValueHandle\");\n    return *V;\n  }\n\nprotected:\n  Value *getValPtr() const { return Val; }\n\n  static bool isValid(Value *V) {\n    return V &&\n           V != DenseMapInfo<Value *>::getEmptyKey() &&\n           V != DenseMapInfo<Value *>::getTombstoneKey();\n  }\n\n  /// Remove this ValueHandle from its current use list.\n  void RemoveFromUseList();\n\n  /// Clear the underlying pointer without clearing the use list.\n  ///\n  /// This should only be used if a derived class has manually removed the\n  /// handle from the use list.\n  void clearValPtr() { setValPtr(nullptr); }\n\npublic:\n  // Callbacks made from Value.\n  static void ValueIsDeleted(Value *V);\n  static void ValueIsRAUWd(Value *Old, Value *New);\n\nprivate:\n  // Internal implementation details.\n  ValueHandleBase **getPrevPtr() const { return PrevPair.getPointer(); }\n  HandleBaseKind getKind() const { return PrevPair.getInt(); }\n  void setPrevPtr(ValueHandleBase **Ptr) { PrevPair.setPointer(Ptr); }\n\n  /// Add this ValueHandle to the use list for V.\n  ///\n  /// List is the address of either the head of the list or a Next node within\n  /// the existing use list.\n  void AddToExistingUseList(ValueHandleBase **List);\n\n  /// Add this ValueHandle to the use list after Node.\n  void AddToExistingUseListAfter(ValueHandleBase *Node);\n\n  /// Add this ValueHandle to the use list for V.\n  void AddToUseList();\n};\n\n/// A nullable Value handle that is nullable.\n///\n/// This is a value handle that points to a value, and nulls itself\n/// out if that value is deleted.\nclass WeakVH : public ValueHandleBase {\npublic:\n  WeakVH() : ValueHandleBase(Weak) {}\n  WeakVH(Value *P) : ValueHandleBase(Weak, P) {}\n  WeakVH(const WeakVH &RHS)\n      : ValueHandleBase(Weak, RHS) {}\n\n  WeakVH &operator=(const WeakVH &RHS) = default;\n\n  Value *operator=(Value *RHS) {\n    return ValueHandleBase::operator=(RHS);\n  }\n  Value *operator=(const ValueHandleBase &RHS) {\n    return ValueHandleBase::operator=(RHS);\n  }\n\n  operator Value*() const {\n    return getValPtr();\n  }\n};\n\n// Specialize simplify_type to allow WeakVH to participate in\n// dyn_cast, isa, etc.\ntemplate <> struct simplify_type<WeakVH> {\n  using SimpleType = Value *;\n\n  static SimpleType getSimplifiedValue(WeakVH &WVH) { return WVH; }\n};\ntemplate <> struct simplify_type<const WeakVH> {\n  using SimpleType = Value *;\n\n  static SimpleType getSimplifiedValue(const WeakVH &WVH) { return WVH; }\n};\n\n// Specialize DenseMapInfo to allow WeakVH to participate in DenseMap.\ntemplate <> struct DenseMapInfo<WeakVH> {\n  static inline WeakVH getEmptyKey() {\n    return WeakVH(DenseMapInfo<Value *>::getEmptyKey());\n  }\n\n  static inline WeakVH getTombstoneKey() {\n    return WeakVH(DenseMapInfo<Value *>::getTombstoneKey());\n  }\n\n  static unsigned getHashValue(const WeakVH &Val) {\n    return DenseMapInfo<Value *>::getHashValue(Val);\n  }\n\n  static bool isEqual(const WeakVH &LHS, const WeakVH &RHS) {\n    return DenseMapInfo<Value *>::isEqual(LHS, RHS);\n  }\n};\n\n/// Value handle that is nullable, but tries to track the Value.\n///\n/// This is a value handle that tries hard to point to a Value, even across\n/// RAUW operations, but will null itself out if the value is destroyed.  this\n/// is useful for advisory sorts of information, but should not be used as the\n/// key of a map (since the map would have to rearrange itself when the pointer\n/// changes).\nclass WeakTrackingVH : public ValueHandleBase {\npublic:\n  WeakTrackingVH() : ValueHandleBase(WeakTracking) {}\n  WeakTrackingVH(Value *P) : ValueHandleBase(WeakTracking, P) {}\n  WeakTrackingVH(const WeakTrackingVH &RHS)\n      : ValueHandleBase(WeakTracking, RHS) {}\n\n  WeakTrackingVH &operator=(const WeakTrackingVH &RHS) = default;\n\n  Value *operator=(Value *RHS) {\n    return ValueHandleBase::operator=(RHS);\n  }\n  Value *operator=(const ValueHandleBase &RHS) {\n    return ValueHandleBase::operator=(RHS);\n  }\n\n  operator Value*() const {\n    return getValPtr();\n  }\n\n  bool pointsToAliveValue() const {\n    return ValueHandleBase::isValid(getValPtr());\n  }\n};\n\n// Specialize simplify_type to allow WeakTrackingVH to participate in\n// dyn_cast, isa, etc.\ntemplate <> struct simplify_type<WeakTrackingVH> {\n  using SimpleType = Value *;\n\n  static SimpleType getSimplifiedValue(WeakTrackingVH &WVH) { return WVH; }\n};\ntemplate <> struct simplify_type<const WeakTrackingVH> {\n  using SimpleType = Value *;\n\n  static SimpleType getSimplifiedValue(const WeakTrackingVH &WVH) {\n    return WVH;\n  }\n};\n\n/// Value handle that asserts if the Value is deleted.\n///\n/// This is a Value Handle that points to a value and asserts out if the value\n/// is destroyed while the handle is still live.  This is very useful for\n/// catching dangling pointer bugs and other things which can be non-obvious.\n/// One particularly useful place to use this is as the Key of a map.  Dangling\n/// pointer bugs often lead to really subtle bugs that only occur if another\n/// object happens to get allocated to the same address as the old one.  Using\n/// an AssertingVH ensures that an assert is triggered as soon as the bad\n/// delete occurs.\n///\n/// Note that an AssertingVH handle does *not* follow values across RAUW\n/// operations.  This means that RAUW's need to explicitly update the\n/// AssertingVH's as it moves.  This is required because in non-assert mode this\n/// class turns into a trivial wrapper around a pointer.\ntemplate <typename ValueTy>\nclass AssertingVH\n#if LLVM_ENABLE_ABI_BREAKING_CHECKS\n    : public ValueHandleBase\n#endif\n{\n  friend struct DenseMapInfo<AssertingVH<ValueTy>>;\n\n#if LLVM_ENABLE_ABI_BREAKING_CHECKS\n  Value *getRawValPtr() const { return ValueHandleBase::getValPtr(); }\n  void setRawValPtr(Value *P) { ValueHandleBase::operator=(P); }\n#else\n  Value *ThePtr;\n  Value *getRawValPtr() const { return ThePtr; }\n  void setRawValPtr(Value *P) { ThePtr = P; }\n#endif\n  // Convert a ValueTy*, which may be const, to the raw Value*.\n  static Value *GetAsValue(Value *V) { return V; }\n  static Value *GetAsValue(const Value *V) { return const_cast<Value*>(V); }\n\n  ValueTy *getValPtr() const { return static_cast<ValueTy *>(getRawValPtr()); }\n  void setValPtr(ValueTy *P) { setRawValPtr(GetAsValue(P)); }\n\npublic:\n#if LLVM_ENABLE_ABI_BREAKING_CHECKS\n  AssertingVH() : ValueHandleBase(Assert) {}\n  AssertingVH(ValueTy *P) : ValueHandleBase(Assert, GetAsValue(P)) {}\n  AssertingVH(const AssertingVH &RHS) : ValueHandleBase(Assert, RHS) {}\n#else\n  AssertingVH() : ThePtr(nullptr) {}\n  AssertingVH(ValueTy *P) : ThePtr(GetAsValue(P)) {}\n  AssertingVH(const AssertingVH &) = default;\n#endif\n\n  operator ValueTy*() const {\n    return getValPtr();\n  }\n\n  ValueTy *operator=(ValueTy *RHS) {\n    setValPtr(RHS);\n    return getValPtr();\n  }\n  ValueTy *operator=(const AssertingVH<ValueTy> &RHS) {\n    setValPtr(RHS.getValPtr());\n    return getValPtr();\n  }\n\n  ValueTy *operator->() const { return getValPtr(); }\n  ValueTy &operator*() const { return *getValPtr(); }\n};\n\n// Treat AssertingVH<T> like T* inside maps. This also allows using find_as()\n// to look up a value without constructing a value handle.\ntemplate<typename T>\nstruct DenseMapInfo<AssertingVH<T>> : DenseMapInfo<T *> {};\n\n/// Value handle that tracks a Value across RAUW.\n///\n/// TrackingVH is designed for situations where a client needs to hold a handle\n/// to a Value (or subclass) across some operations which may move that value,\n/// but should never destroy it or replace it with some unacceptable type.\n///\n/// It is an error to attempt to replace a value with one of a type which is\n/// incompatible with any of its outstanding TrackingVHs.\n///\n/// It is an error to read from a TrackingVH that does not point to a valid\n/// value.  A TrackingVH is said to not point to a valid value if either it\n/// hasn't yet been assigned a value yet or because the value it was tracking\n/// has since been deleted.\n///\n/// Assigning a value to a TrackingVH is always allowed, even if said TrackingVH\n/// no longer points to a valid value.\ntemplate <typename ValueTy> class TrackingVH {\n  WeakTrackingVH InnerHandle;\n\npublic:\n  ValueTy *getValPtr() const {\n    assert(InnerHandle.pointsToAliveValue() &&\n           \"TrackingVH must be non-null and valid on dereference!\");\n\n    // Check that the value is a member of the correct subclass. We would like\n    // to check this property on assignment for better debugging, but we don't\n    // want to require a virtual interface on this VH. Instead we allow RAUW to\n    // replace this value with a value of an invalid type, and check it here.\n    assert(isa<ValueTy>(InnerHandle) &&\n           \"Tracked Value was replaced by one with an invalid type!\");\n    return cast<ValueTy>(InnerHandle);\n  }\n\n  void setValPtr(ValueTy *P) {\n    // Assigning to non-valid TrackingVH's are fine so we just unconditionally\n    // assign here.\n    InnerHandle = GetAsValue(P);\n  }\n\n  // Convert a ValueTy*, which may be const, to the type the base\n  // class expects.\n  static Value *GetAsValue(Value *V) { return V; }\n  static Value *GetAsValue(const Value *V) { return const_cast<Value*>(V); }\n\npublic:\n  TrackingVH() = default;\n  TrackingVH(ValueTy *P) { setValPtr(P); }\n\n  operator ValueTy*() const {\n    return getValPtr();\n  }\n\n  ValueTy *operator=(ValueTy *RHS) {\n    setValPtr(RHS);\n    return getValPtr();\n  }\n\n  ValueTy *operator->() const { return getValPtr(); }\n  ValueTy &operator*() const { return *getValPtr(); }\n};\n\n/// Value handle with callbacks on RAUW and destruction.\n///\n/// This is a value handle that allows subclasses to define callbacks that run\n/// when the underlying Value has RAUW called on it or is destroyed.  This\n/// class can be used as the key of a map, as long as the user takes it out of\n/// the map before calling setValPtr() (since the map has to rearrange itself\n/// when the pointer changes).  Unlike ValueHandleBase, this class has a vtable.\nclass CallbackVH : public ValueHandleBase {\n  virtual void anchor();\nprotected:\n  ~CallbackVH() = default;\n  CallbackVH(const CallbackVH &) = default;\n  CallbackVH &operator=(const CallbackVH &) = default;\n\n  void setValPtr(Value *P) {\n    ValueHandleBase::operator=(P);\n  }\n\npublic:\n  CallbackVH() : ValueHandleBase(Callback) {}\n  CallbackVH(Value *P) : ValueHandleBase(Callback, P) {}\n  CallbackVH(const Value *P) : CallbackVH(const_cast<Value *>(P)) {}\n\n  operator Value*() const {\n    return getValPtr();\n  }\n\n  /// Callback for Value destruction.\n  ///\n  /// Called when this->getValPtr() is destroyed, inside ~Value(), so you\n  /// may call any non-virtual Value method on getValPtr(), but no subclass\n  /// methods.  If WeakTrackingVH were implemented as a CallbackVH, it would use\n  /// this\n  /// method to call setValPtr(NULL).  AssertingVH would use this method to\n  /// cause an assertion failure.\n  ///\n  /// All implementations must remove the reference from this object to the\n  /// Value that's being destroyed.\n  virtual void deleted() { setValPtr(nullptr); }\n\n  /// Callback for Value RAUW.\n  ///\n  /// Called when this->getValPtr()->replaceAllUsesWith(new_value) is called,\n  /// _before_ any of the uses have actually been replaced.  If WeakTrackingVH\n  /// were\n  /// implemented as a CallbackVH, it would use this method to call\n  /// setValPtr(new_value).  AssertingVH would do nothing in this method.\n  virtual void allUsesReplacedWith(Value *) {}\n};\n\n/// Value handle that poisons itself if the Value is deleted.\n///\n/// This is a Value Handle that points to a value and poisons itself if the\n/// value is destroyed while the handle is still live.  This is very useful for\n/// catching dangling pointer bugs where an \\c AssertingVH cannot be used\n/// because the dangling handle needs to outlive the value without ever being\n/// used.\n///\n/// One particularly useful place to use this is as the Key of a map. Dangling\n/// pointer bugs often lead to really subtle bugs that only occur if another\n/// object happens to get allocated to the same address as the old one. Using\n/// a PoisoningVH ensures that an assert is triggered if looking up a new value\n/// in the map finds a handle from the old value.\n///\n/// Note that a PoisoningVH handle does *not* follow values across RAUW\n/// operations. This means that RAUW's need to explicitly update the\n/// PoisoningVH's as it moves. This is required because in non-assert mode this\n/// class turns into a trivial wrapper around a pointer.\ntemplate <typename ValueTy>\nclass PoisoningVH final\n#if LLVM_ENABLE_ABI_BREAKING_CHECKS\n    : public CallbackVH\n#endif\n{\n  friend struct DenseMapInfo<PoisoningVH<ValueTy>>;\n\n  // Convert a ValueTy*, which may be const, to the raw Value*.\n  static Value *GetAsValue(Value *V) { return V; }\n  static Value *GetAsValue(const Value *V) { return const_cast<Value *>(V); }\n\n#if LLVM_ENABLE_ABI_BREAKING_CHECKS\n  /// A flag tracking whether this value has been poisoned.\n  ///\n  /// On delete and RAUW, we leave the value pointer alone so that as a raw\n  /// pointer it produces the same value (and we fit into the same key of\n  /// a hash table, etc), but we poison the handle so that any top-level usage\n  /// will fail.\n  bool Poisoned = false;\n\n  Value *getRawValPtr() const { return ValueHandleBase::getValPtr(); }\n  void setRawValPtr(Value *P) { ValueHandleBase::operator=(P); }\n\n  /// Handle deletion by poisoning the handle.\n  void deleted() override {\n    assert(!Poisoned && \"Tried to delete an already poisoned handle!\");\n    Poisoned = true;\n    RemoveFromUseList();\n  }\n\n  /// Handle RAUW by poisoning the handle.\n  void allUsesReplacedWith(Value *) override {\n    assert(!Poisoned && \"Tried to RAUW an already poisoned handle!\");\n    Poisoned = true;\n    RemoveFromUseList();\n  }\n#else // LLVM_ENABLE_ABI_BREAKING_CHECKS\n  Value *ThePtr = nullptr;\n\n  Value *getRawValPtr() const { return ThePtr; }\n  void setRawValPtr(Value *P) { ThePtr = P; }\n#endif\n\n  ValueTy *getValPtr() const {\n#if LLVM_ENABLE_ABI_BREAKING_CHECKS\n    assert(!Poisoned && \"Accessed a poisoned value handle!\");\n#endif\n    return static_cast<ValueTy *>(getRawValPtr());\n  }\n  void setValPtr(ValueTy *P) { setRawValPtr(GetAsValue(P)); }\n\npublic:\n  PoisoningVH() = default;\n#if LLVM_ENABLE_ABI_BREAKING_CHECKS\n  PoisoningVH(ValueTy *P) : CallbackVH(GetAsValue(P)) {}\n  PoisoningVH(const PoisoningVH &RHS)\n      : CallbackVH(RHS), Poisoned(RHS.Poisoned) {}\n\n  ~PoisoningVH() {\n    if (Poisoned)\n      clearValPtr();\n  }\n\n  PoisoningVH &operator=(const PoisoningVH &RHS) {\n    if (Poisoned)\n      clearValPtr();\n    CallbackVH::operator=(RHS);\n    Poisoned = RHS.Poisoned;\n    return *this;\n  }\n#else\n  PoisoningVH(ValueTy *P) : ThePtr(GetAsValue(P)) {}\n#endif\n\n  operator ValueTy *() const { return getValPtr(); }\n\n  ValueTy *operator->() const { return getValPtr(); }\n  ValueTy &operator*() const { return *getValPtr(); }\n};\n\n// Specialize DenseMapInfo to allow PoisoningVH to participate in DenseMap.\ntemplate <typename T> struct DenseMapInfo<PoisoningVH<T>> {\n  static inline PoisoningVH<T> getEmptyKey() {\n    PoisoningVH<T> Res;\n    Res.setRawValPtr(DenseMapInfo<Value *>::getEmptyKey());\n    return Res;\n  }\n\n  static inline PoisoningVH<T> getTombstoneKey() {\n    PoisoningVH<T> Res;\n    Res.setRawValPtr(DenseMapInfo<Value *>::getTombstoneKey());\n    return Res;\n  }\n\n  static unsigned getHashValue(const PoisoningVH<T> &Val) {\n    return DenseMapInfo<Value *>::getHashValue(Val.getRawValPtr());\n  }\n\n  static bool isEqual(const PoisoningVH<T> &LHS, const PoisoningVH<T> &RHS) {\n    return DenseMapInfo<Value *>::isEqual(LHS.getRawValPtr(),\n                                          RHS.getRawValPtr());\n  }\n\n  // Allow lookup by T* via find_as(), without constructing a temporary\n  // value handle.\n\n  static unsigned getHashValue(const T *Val) {\n    return DenseMapInfo<Value *>::getHashValue(Val);\n  }\n\n  static bool isEqual(const T *LHS, const PoisoningVH<T> &RHS) {\n    return DenseMapInfo<Value *>::isEqual(LHS, RHS.getRawValPtr());\n  }\n};\n\n} // end namespace llvm\n\n#endif // LLVM_IR_VALUEHANDLE_H\n"}, "49": {"id": 49, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/MC/LaneBitmask.h", "content": "//===- llvm/MC/LaneBitmask.h ------------------------------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n///\n/// \\file\n/// A common definition of LaneBitmask for use in TableGen and CodeGen.\n///\n/// A lane mask is a bitmask representing the covering of a register with\n/// sub-registers.\n///\n/// This is typically used to track liveness at sub-register granularity.\n/// Lane masks for sub-register indices are similar to register units for\n/// physical registers. The individual bits in a lane mask can't be assigned\n/// any specific meaning. They can be used to check if two sub-register\n/// indices overlap.\n///\n/// Iff the target has a register such that:\n///\n///   getSubReg(Reg, A) overlaps getSubReg(Reg, B)\n///\n/// then:\n///\n///   (getSubRegIndexLaneMask(A) & getSubRegIndexLaneMask(B)) != 0\n\n#ifndef LLVM_MC_LANEBITMASK_H\n#define LLVM_MC_LANEBITMASK_H\n\n#include \"llvm/Support/Compiler.h\"\n#include \"llvm/Support/Format.h\"\n#include \"llvm/Support/Printable.h\"\n#include \"llvm/Support/raw_ostream.h\"\n\nnamespace llvm {\n\n  struct LaneBitmask {\n    // When changing the underlying type, change the format string as well.\n    using Type = uint64_t;\n    enum : unsigned { BitWidth = 8*sizeof(Type) };\n    constexpr static const char *const FormatStr = \"%016llX\";\n\n    constexpr LaneBitmask() = default;\n    explicit constexpr LaneBitmask(Type V) : Mask(V) {}\n\n    constexpr bool operator== (LaneBitmask M) const { return Mask == M.Mask; }\n    constexpr bool operator!= (LaneBitmask M) const { return Mask != M.Mask; }\n    constexpr bool operator< (LaneBitmask M)  const { return Mask < M.Mask; }\n    constexpr bool none() const { return Mask == 0; }\n    constexpr bool any()  const { return Mask != 0; }\n    constexpr bool all()  const { return ~Mask == 0; }\n\n    constexpr LaneBitmask operator~() const {\n      return LaneBitmask(~Mask);\n    }\n    constexpr LaneBitmask operator|(LaneBitmask M) const {\n      return LaneBitmask(Mask | M.Mask);\n    }\n    constexpr LaneBitmask operator&(LaneBitmask M) const {\n      return LaneBitmask(Mask & M.Mask);\n    }\n    LaneBitmask &operator|=(LaneBitmask M) {\n      Mask |= M.Mask;\n      return *this;\n    }\n    LaneBitmask &operator&=(LaneBitmask M) {\n      Mask &= M.Mask;\n      return *this;\n    }\n\n    constexpr Type getAsInteger() const { return Mask; }\n\n    unsigned getNumLanes() const {\n      return countPopulation(Mask);\n    }\n    unsigned getHighestLane() const {\n      return Log2_64(Mask);\n    }\n\n    static constexpr LaneBitmask getNone() { return LaneBitmask(0); }\n    static constexpr LaneBitmask getAll() { return ~LaneBitmask(0); }\n    static constexpr LaneBitmask getLane(unsigned Lane) {\n      return LaneBitmask(Type(1) << Lane);\n    }\n\n  private:\n    Type Mask = 0;\n  };\n\n  /// Create Printable object to print LaneBitmasks on a \\ref raw_ostream.\n  inline Printable PrintLaneMask(LaneBitmask LaneMask) {\n    return Printable([LaneMask](raw_ostream &OS) {\n      OS << format(LaneBitmask::FormatStr, LaneMask.getAsInteger());\n    });\n  }\n\n} // end namespace llvm\n\n#endif // LLVM_MC_LANEBITMASK_H\n"}, "50": {"id": 50, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/MC/MCDwarf.h", "content": "//===- MCDwarf.h - Machine Code Dwarf support -------------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// This file contains the declaration of the MCDwarfFile to support the dwarf\n// .file directive and the .loc directive.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_MC_MCDWARF_H\n#define LLVM_MC_MCDWARF_H\n\n#include \"llvm/ADT/MapVector.h\"\n#include \"llvm/ADT/Optional.h\"\n#include \"llvm/ADT/SmallVector.h\"\n#include \"llvm/ADT/StringMap.h\"\n#include \"llvm/ADT/StringRef.h\"\n#include \"llvm/MC/MCSection.h\"\n#include \"llvm/Support/Error.h\"\n#include \"llvm/Support/MD5.h\"\n#include <cassert>\n#include <cstdint>\n#include <string>\n#include <tuple>\n#include <utility>\n#include <vector>\n\nnamespace llvm {\n\ntemplate <typename T> class ArrayRef;\nclass MCAsmBackend;\nclass MCContext;\nclass MCDwarfLineStr;\nclass MCObjectStreamer;\nclass MCStreamer;\nclass MCSymbol;\nclass raw_ostream;\nclass SMLoc;\nclass SourceMgr;\n\nnamespace mcdwarf {\n// Emit the common part of the DWARF 5 range/locations list tables header.\nMCSymbol *emitListsTableHeaderStart(MCStreamer &S);\n} // namespace mcdwarf\n\n/// Instances of this class represent the name of the dwarf .file directive and\n/// its associated dwarf file number in the MC file. MCDwarfFile's are created\n/// and uniqued by the MCContext class. In Dwarf 4 file numbers start from 1;\n/// i.e. the entry with file number 1 is the first element in the vector of\n/// DwarfFiles and there is no MCDwarfFile with file number 0. In Dwarf 5 file\n/// numbers start from 0, with the MCDwarfFile with file number 0 being the\n/// primary source file, and file numbers correspond to their index in the\n/// vector.\nstruct MCDwarfFile {\n  // The base name of the file without its directory path.\n  std::string Name;\n\n  // The index into the list of directory names for this file name.\n  unsigned DirIndex = 0;\n\n  /// The MD5 checksum, if there is one. Non-owning pointer to data allocated\n  /// in MCContext.\n  Optional<MD5::MD5Result> Checksum;\n\n  /// The source code of the file. Non-owning reference to data allocated in\n  /// MCContext.\n  Optional<StringRef> Source;\n};\n\n/// Instances of this class represent the information from a\n/// dwarf .loc directive.\nclass MCDwarfLoc {\n  uint32_t FileNum;\n  uint32_t Line;\n  uint16_t Column;\n  // Flags (see #define's below)\n  uint8_t Flags;\n  uint8_t Isa;\n  uint32_t Discriminator;\n\n// Flag that indicates the initial value of the is_stmt_start flag.\n#define DWARF2_LINE_DEFAULT_IS_STMT 1\n\n#define DWARF2_FLAG_IS_STMT (1 << 0)\n#define DWARF2_FLAG_BASIC_BLOCK (1 << 1)\n#define DWARF2_FLAG_PROLOGUE_END (1 << 2)\n#define DWARF2_FLAG_EPILOGUE_BEGIN (1 << 3)\n\nprivate: // MCContext manages these\n  friend class MCContext;\n  friend class MCDwarfLineEntry;\n\n  MCDwarfLoc(unsigned fileNum, unsigned line, unsigned column, unsigned flags,\n             unsigned isa, unsigned discriminator)\n      : FileNum(fileNum), Line(line), Column(column), Flags(flags), Isa(isa),\n        Discriminator(discriminator) {}\n\n  // Allow the default copy constructor and assignment operator to be used\n  // for an MCDwarfLoc object.\n\npublic:\n  /// Get the FileNum of this MCDwarfLoc.\n  unsigned getFileNum() const { return FileNum; }\n\n  /// Get the Line of this MCDwarfLoc.\n  unsigned getLine() const { return Line; }\n\n  /// Get the Column of this MCDwarfLoc.\n  unsigned getColumn() const { return Column; }\n\n  /// Get the Flags of this MCDwarfLoc.\n  unsigned getFlags() const { return Flags; }\n\n  /// Get the Isa of this MCDwarfLoc.\n  unsigned getIsa() const { return Isa; }\n\n  /// Get the Discriminator of this MCDwarfLoc.\n  unsigned getDiscriminator() const { return Discriminator; }\n\n  /// Set the FileNum of this MCDwarfLoc.\n  void setFileNum(unsigned fileNum) { FileNum = fileNum; }\n\n  /// Set the Line of this MCDwarfLoc.\n  void setLine(unsigned line) { Line = line; }\n\n  /// Set the Column of this MCDwarfLoc.\n  void setColumn(unsigned column) {\n    assert(column <= UINT16_MAX);\n    Column = column;\n  }\n\n  /// Set the Flags of this MCDwarfLoc.\n  void setFlags(unsigned flags) {\n    assert(flags <= UINT8_MAX);\n    Flags = flags;\n  }\n\n  /// Set the Isa of this MCDwarfLoc.\n  void setIsa(unsigned isa) {\n    assert(isa <= UINT8_MAX);\n    Isa = isa;\n  }\n\n  /// Set the Discriminator of this MCDwarfLoc.\n  void setDiscriminator(unsigned discriminator) {\n    Discriminator = discriminator;\n  }\n};\n\n/// Instances of this class represent the line information for\n/// the dwarf line table entries.  Which is created after a machine\n/// instruction is assembled and uses an address from a temporary label\n/// created at the current address in the current section and the info from\n/// the last .loc directive seen as stored in the context.\nclass MCDwarfLineEntry : public MCDwarfLoc {\n  MCSymbol *Label;\n\nprivate:\n  // Allow the default copy constructor and assignment operator to be used\n  // for an MCDwarfLineEntry object.\n\npublic:\n  // Constructor to create an MCDwarfLineEntry given a symbol and the dwarf loc.\n  MCDwarfLineEntry(MCSymbol *label, const MCDwarfLoc loc)\n      : MCDwarfLoc(loc), Label(label) {}\n\n  MCSymbol *getLabel() const { return Label; }\n\n  // This is called when an instruction is assembled into the specified\n  // section and if there is information from the last .loc directive that\n  // has yet to have a line entry made for it is made.\n  static void make(MCStreamer *MCOS, MCSection *Section);\n};\n\n/// Instances of this class represent the line information for a compile\n/// unit where machine instructions have been assembled after seeing .loc\n/// directives.  This is the information used to build the dwarf line\n/// table for a section.\nclass MCLineSection {\npublic:\n  // Add an entry to this MCLineSection's line entries.\n  void addLineEntry(const MCDwarfLineEntry &LineEntry, MCSection *Sec) {\n    MCLineDivisions[Sec].push_back(LineEntry);\n  }\n\n  using MCDwarfLineEntryCollection = std::vector<MCDwarfLineEntry>;\n  using iterator = MCDwarfLineEntryCollection::iterator;\n  using const_iterator = MCDwarfLineEntryCollection::const_iterator;\n  using MCLineDivisionMap = MapVector<MCSection *, MCDwarfLineEntryCollection>;\n\nprivate:\n  // A collection of MCDwarfLineEntry for each section.\n  MCLineDivisionMap MCLineDivisions;\n\npublic:\n  // Returns the collection of MCDwarfLineEntry for a given Compile Unit ID.\n  const MCLineDivisionMap &getMCLineEntries() const {\n    return MCLineDivisions;\n  }\n};\n\nstruct MCDwarfLineTableParams {\n  /// First special line opcode - leave room for the standard opcodes.\n  /// Note: If you want to change this, you'll have to update the\n  /// \"StandardOpcodeLengths\" table that is emitted in\n  /// \\c Emit().\n  uint8_t DWARF2LineOpcodeBase = 13;\n  /// Minimum line offset in a special line info. opcode.  The value\n  /// -5 was chosen to give a reasonable range of values.\n  int8_t DWARF2LineBase = -5;\n  /// Range of line offsets in a special line info. opcode.\n  uint8_t DWARF2LineRange = 14;\n};\n\nstruct MCDwarfLineTableHeader {\n  MCSymbol *Label = nullptr;\n  SmallVector<std::string, 3> MCDwarfDirs;\n  SmallVector<MCDwarfFile, 3> MCDwarfFiles;\n  StringMap<unsigned> SourceIdMap;\n  std::string CompilationDir;\n  MCDwarfFile RootFile;\n  bool HasSource = false;\nprivate:\n  bool HasAllMD5 = true;\n  bool HasAnyMD5 = false;\n\npublic:\n  MCDwarfLineTableHeader() = default;\n\n  Expected<unsigned> tryGetFile(StringRef &Directory, StringRef &FileName,\n                                Optional<MD5::MD5Result> Checksum,\n                                Optional<StringRef> Source,\n                                uint16_t DwarfVersion,\n                                unsigned FileNumber = 0);\n  std::pair<MCSymbol *, MCSymbol *>\n  Emit(MCStreamer *MCOS, MCDwarfLineTableParams Params,\n       Optional<MCDwarfLineStr> &LineStr) const;\n  std::pair<MCSymbol *, MCSymbol *>\n  Emit(MCStreamer *MCOS, MCDwarfLineTableParams Params,\n       ArrayRef<char> SpecialOpcodeLengths,\n       Optional<MCDwarfLineStr> &LineStr) const;\n  void resetMD5Usage() {\n    HasAllMD5 = true;\n    HasAnyMD5 = false;\n  }\n  void trackMD5Usage(bool MD5Used) {\n    HasAllMD5 &= MD5Used;\n    HasAnyMD5 |= MD5Used;\n  }\n  bool isMD5UsageConsistent() const {\n    return MCDwarfFiles.empty() || (HasAllMD5 == HasAnyMD5);\n  }\n\n  void setRootFile(StringRef Directory, StringRef FileName,\n                   Optional<MD5::MD5Result> Checksum,\n                   Optional<StringRef> Source) {\n    CompilationDir = std::string(Directory);\n    RootFile.Name = std::string(FileName);\n    RootFile.DirIndex = 0;\n    RootFile.Checksum = Checksum;\n    RootFile.Source = Source;\n    trackMD5Usage(Checksum.hasValue());\n    HasSource = Source.hasValue();\n  }\n\n  void resetFileTable() {\n    MCDwarfDirs.clear();\n    MCDwarfFiles.clear();\n    RootFile.Name.clear();\n    resetMD5Usage();\n    HasSource = false;\n  }\n\nprivate:\n  void emitV2FileDirTables(MCStreamer *MCOS) const;\n  void emitV5FileDirTables(MCStreamer *MCOS, Optional<MCDwarfLineStr> &LineStr) const;\n};\n\nclass MCDwarfDwoLineTable {\n  MCDwarfLineTableHeader Header;\n  bool HasSplitLineTable = false;\n\npublic:\n  void maybeSetRootFile(StringRef Directory, StringRef FileName,\n                        Optional<MD5::MD5Result> Checksum,\n                        Optional<StringRef> Source) {\n    if (!Header.RootFile.Name.empty())\n      return;\n    Header.setRootFile(Directory, FileName, Checksum, Source);\n  }\n\n  unsigned getFile(StringRef Directory, StringRef FileName,\n                   Optional<MD5::MD5Result> Checksum, uint16_t DwarfVersion,\n                   Optional<StringRef> Source) {\n    HasSplitLineTable = true;\n    return cantFail(Header.tryGetFile(Directory, FileName, Checksum, Source,\n                                      DwarfVersion));\n  }\n\n  void Emit(MCStreamer &MCOS, MCDwarfLineTableParams Params,\n            MCSection *Section) const;\n};\n\nclass MCDwarfLineTable {\n  MCDwarfLineTableHeader Header;\n  MCLineSection MCLineSections;\n\npublic:\n  // This emits the Dwarf file and the line tables for all Compile Units.\n  static void emit(MCStreamer *MCOS, MCDwarfLineTableParams Params);\n\n  // This emits the Dwarf file and the line tables for a given Compile Unit.\n  void emitCU(MCStreamer *MCOS, MCDwarfLineTableParams Params,\n              Optional<MCDwarfLineStr> &LineStr) const;\n\n  Expected<unsigned> tryGetFile(StringRef &Directory, StringRef &FileName,\n                                Optional<MD5::MD5Result> Checksum,\n                                Optional<StringRef> Source,\n                                uint16_t DwarfVersion,\n                                unsigned FileNumber = 0);\n  unsigned getFile(StringRef &Directory, StringRef &FileName,\n                   Optional<MD5::MD5Result> Checksum, Optional<StringRef> Source,\n                   uint16_t DwarfVersion, unsigned FileNumber = 0) {\n    return cantFail(tryGetFile(Directory, FileName, Checksum, Source,\n                               DwarfVersion, FileNumber));\n  }\n\n  void setRootFile(StringRef Directory, StringRef FileName,\n                   Optional<MD5::MD5Result> Checksum, Optional<StringRef> Source) {\n    Header.CompilationDir = std::string(Directory);\n    Header.RootFile.Name = std::string(FileName);\n    Header.RootFile.DirIndex = 0;\n    Header.RootFile.Checksum = Checksum;\n    Header.RootFile.Source = Source;\n    Header.trackMD5Usage(Checksum.hasValue());\n    Header.HasSource = Source.hasValue();\n  }\n\n  void resetFileTable() { Header.resetFileTable(); }\n\n  bool hasRootFile() const { return !Header.RootFile.Name.empty(); }\n\n  const MCDwarfFile &getRootFile() const { return Header.RootFile; }\n\n  // Report whether MD5 usage has been consistent (all-or-none).\n  bool isMD5UsageConsistent() const { return Header.isMD5UsageConsistent(); }\n\n  MCSymbol *getLabel() const {\n    return Header.Label;\n  }\n\n  void setLabel(MCSymbol *Label) {\n    Header.Label = Label;\n  }\n\n  const SmallVectorImpl<std::string> &getMCDwarfDirs() const {\n    return Header.MCDwarfDirs;\n  }\n\n  SmallVectorImpl<std::string> &getMCDwarfDirs() {\n    return Header.MCDwarfDirs;\n  }\n\n  const SmallVectorImpl<MCDwarfFile> &getMCDwarfFiles() const {\n    return Header.MCDwarfFiles;\n  }\n\n  SmallVectorImpl<MCDwarfFile> &getMCDwarfFiles() {\n    return Header.MCDwarfFiles;\n  }\n\n  const MCLineSection &getMCLineSections() const {\n    return MCLineSections;\n  }\n  MCLineSection &getMCLineSections() {\n    return MCLineSections;\n  }\n};\n\nclass MCDwarfLineAddr {\npublic:\n  /// Utility function to encode a Dwarf pair of LineDelta and AddrDeltas.\n  static void Encode(MCContext &Context, MCDwarfLineTableParams Params,\n                     int64_t LineDelta, uint64_t AddrDelta, raw_ostream &OS);\n\n  /// Utility function to encode a Dwarf pair of LineDelta and AddrDeltas using\n  /// fixed length operands. Returns (Offset, Size, SetDelta).\n  static std::tuple<uint32_t, uint32_t, bool> fixedEncode(MCContext &Context,\n                                                          int64_t LineDelta,\n                                                          uint64_t AddrDelta,\n                                                          raw_ostream &OS);\n\n  /// Utility function to emit the encoding to a streamer.\n  static void Emit(MCStreamer *MCOS, MCDwarfLineTableParams Params,\n                   int64_t LineDelta, uint64_t AddrDelta);\n};\n\nclass MCGenDwarfInfo {\npublic:\n  //\n  // When generating dwarf for assembly source files this emits the Dwarf\n  // sections.\n  //\n  static void Emit(MCStreamer *MCOS);\n};\n\n// When generating dwarf for assembly source files this is the info that is\n// needed to be gathered for each symbol that will have a dwarf label.\nclass MCGenDwarfLabelEntry {\nprivate:\n  // Name of the symbol without a leading underbar, if any.\n  StringRef Name;\n  // The dwarf file number this symbol is in.\n  unsigned FileNumber;\n  // The line number this symbol is at.\n  unsigned LineNumber;\n  // The low_pc for the dwarf label is taken from this symbol.\n  MCSymbol *Label;\n\npublic:\n  MCGenDwarfLabelEntry(StringRef name, unsigned fileNumber, unsigned lineNumber,\n                       MCSymbol *label)\n      : Name(name), FileNumber(fileNumber), LineNumber(lineNumber),\n        Label(label) {}\n\n  StringRef getName() const { return Name; }\n  unsigned getFileNumber() const { return FileNumber; }\n  unsigned getLineNumber() const { return LineNumber; }\n  MCSymbol *getLabel() const { return Label; }\n\n  // This is called when label is created when we are generating dwarf for\n  // assembly source files.\n  static void Make(MCSymbol *Symbol, MCStreamer *MCOS, SourceMgr &SrcMgr,\n                   SMLoc &Loc);\n};\n\nclass MCCFIInstruction {\npublic:\n  enum OpType {\n    OpSameValue,\n    OpRememberState,\n    OpRestoreState,\n    OpOffset,\n    OpDefCfaRegister,\n    OpDefCfaOffset,\n    OpDefCfa,\n    OpRelOffset,\n    OpAdjustCfaOffset,\n    OpEscape,\n    OpRestore,\n    OpUndefined,\n    OpRegister,\n    OpWindowSave,\n    OpNegateRAState,\n    OpGnuArgsSize\n  };\n\nprivate:\n  OpType Operation;\n  MCSymbol *Label;\n  unsigned Register;\n  union {\n    int Offset;\n    unsigned Register2;\n  };\n  std::vector<char> Values;\n  std::string Comment;\n\n  MCCFIInstruction(OpType Op, MCSymbol *L, unsigned R, int O, StringRef V,\n                   StringRef Comment = \"\")\n      : Operation(Op), Label(L), Register(R), Offset(O),\n        Values(V.begin(), V.end()), Comment(Comment) {\n    assert(Op != OpRegister);\n  }\n\n  MCCFIInstruction(OpType Op, MCSymbol *L, unsigned R1, unsigned R2)\n      : Operation(Op), Label(L), Register(R1), Register2(R2) {\n    assert(Op == OpRegister);\n  }\n\npublic:\n  /// .cfi_def_cfa defines a rule for computing CFA as: take address from\n  /// Register and add Offset to it.\n  static MCCFIInstruction cfiDefCfa(MCSymbol *L, unsigned Register,\n                                    int Offset) {\n    return MCCFIInstruction(OpDefCfa, L, Register, Offset, \"\");\n  }\n\n  /// .cfi_def_cfa_register modifies a rule for computing CFA. From now\n  /// on Register will be used instead of the old one. Offset remains the same.\n  static MCCFIInstruction createDefCfaRegister(MCSymbol *L, unsigned Register) {\n    return MCCFIInstruction(OpDefCfaRegister, L, Register, 0, \"\");\n  }\n\n  /// .cfi_def_cfa_offset modifies a rule for computing CFA. Register\n  /// remains the same, but offset is new. Note that it is the absolute offset\n  /// that will be added to a defined register to the compute CFA address.\n  static MCCFIInstruction cfiDefCfaOffset(MCSymbol *L, int Offset) {\n    return MCCFIInstruction(OpDefCfaOffset, L, 0, Offset, \"\");\n  }\n\n  /// .cfi_adjust_cfa_offset Same as .cfi_def_cfa_offset, but\n  /// Offset is a relative value that is added/subtracted from the previous\n  /// offset.\n  static MCCFIInstruction createAdjustCfaOffset(MCSymbol *L, int Adjustment) {\n    return MCCFIInstruction(OpAdjustCfaOffset, L, 0, Adjustment, \"\");\n  }\n\n  /// .cfi_offset Previous value of Register is saved at offset Offset\n  /// from CFA.\n  static MCCFIInstruction createOffset(MCSymbol *L, unsigned Register,\n                                       int Offset) {\n    return MCCFIInstruction(OpOffset, L, Register, Offset, \"\");\n  }\n\n  /// .cfi_rel_offset Previous value of Register is saved at offset\n  /// Offset from the current CFA register. This is transformed to .cfi_offset\n  /// using the known displacement of the CFA register from the CFA.\n  static MCCFIInstruction createRelOffset(MCSymbol *L, unsigned Register,\n                                          int Offset) {\n    return MCCFIInstruction(OpRelOffset, L, Register, Offset, \"\");\n  }\n\n  /// .cfi_register Previous value of Register1 is saved in\n  /// register Register2.\n  static MCCFIInstruction createRegister(MCSymbol *L, unsigned Register1,\n                                         unsigned Register2) {\n    return MCCFIInstruction(OpRegister, L, Register1, Register2);\n  }\n\n  /// .cfi_window_save SPARC register window is saved.\n  static MCCFIInstruction createWindowSave(MCSymbol *L) {\n    return MCCFIInstruction(OpWindowSave, L, 0, 0, \"\");\n  }\n\n  /// .cfi_negate_ra_state AArch64 negate RA state.\n  static MCCFIInstruction createNegateRAState(MCSymbol *L) {\n    return MCCFIInstruction(OpNegateRAState, L, 0, 0, \"\");\n  }\n\n  /// .cfi_restore says that the rule for Register is now the same as it\n  /// was at the beginning of the function, after all initial instructions added\n  /// by .cfi_startproc were executed.\n  static MCCFIInstruction createRestore(MCSymbol *L, unsigned Register) {\n    return MCCFIInstruction(OpRestore, L, Register, 0, \"\");\n  }\n\n  /// .cfi_undefined From now on the previous value of Register can't be\n  /// restored anymore.\n  static MCCFIInstruction createUndefined(MCSymbol *L, unsigned Register) {\n    return MCCFIInstruction(OpUndefined, L, Register, 0, \"\");\n  }\n\n  /// .cfi_same_value Current value of Register is the same as in the\n  /// previous frame. I.e., no restoration is needed.\n  static MCCFIInstruction createSameValue(MCSymbol *L, unsigned Register) {\n    return MCCFIInstruction(OpSameValue, L, Register, 0, \"\");\n  }\n\n  /// .cfi_remember_state Save all current rules for all registers.\n  static MCCFIInstruction createRememberState(MCSymbol *L) {\n    return MCCFIInstruction(OpRememberState, L, 0, 0, \"\");\n  }\n\n  /// .cfi_restore_state Restore the previously saved state.\n  static MCCFIInstruction createRestoreState(MCSymbol *L) {\n    return MCCFIInstruction(OpRestoreState, L, 0, 0, \"\");\n  }\n\n  /// .cfi_escape Allows the user to add arbitrary bytes to the unwind\n  /// info.\n  static MCCFIInstruction createEscape(MCSymbol *L, StringRef Vals,\n                                       StringRef Comment = \"\") {\n    return MCCFIInstruction(OpEscape, L, 0, 0, Vals, Comment);\n  }\n\n  /// A special wrapper for .cfi_escape that indicates GNU_ARGS_SIZE\n  static MCCFIInstruction createGnuArgsSize(MCSymbol *L, int Size) {\n    return MCCFIInstruction(OpGnuArgsSize, L, 0, Size, \"\");\n  }\n\n  OpType getOperation() const { return Operation; }\n  MCSymbol *getLabel() const { return Label; }\n\n  unsigned getRegister() const {\n    assert(Operation == OpDefCfa || Operation == OpOffset ||\n           Operation == OpRestore || Operation == OpUndefined ||\n           Operation == OpSameValue || Operation == OpDefCfaRegister ||\n           Operation == OpRelOffset || Operation == OpRegister);\n    return Register;\n  }\n\n  unsigned getRegister2() const {\n    assert(Operation == OpRegister);\n    return Register2;\n  }\n\n  int getOffset() const {\n    assert(Operation == OpDefCfa || Operation == OpOffset ||\n           Operation == OpRelOffset || Operation == OpDefCfaOffset ||\n           Operation == OpAdjustCfaOffset || Operation == OpGnuArgsSize);\n    return Offset;\n  }\n\n  StringRef getValues() const {\n    assert(Operation == OpEscape);\n    return StringRef(&Values[0], Values.size());\n  }\n\n  StringRef getComment() const {\n    return Comment;\n  }\n};\n\nstruct MCDwarfFrameInfo {\n  MCDwarfFrameInfo() = default;\n\n  MCSymbol *Begin = nullptr;\n  MCSymbol *End = nullptr;\n  const MCSymbol *Personality = nullptr;\n  const MCSymbol *Lsda = nullptr;\n  std::vector<MCCFIInstruction> Instructions;\n  unsigned CurrentCfaRegister = 0;\n  unsigned PersonalityEncoding = 0;\n  unsigned LsdaEncoding = 0;\n  uint32_t CompactUnwindEncoding = 0;\n  bool IsSignalFrame = false;\n  bool IsSimple = false;\n  unsigned RAReg = static_cast<unsigned>(INT_MAX);\n  bool IsBKeyFrame = false;\n};\n\nclass MCDwarfFrameEmitter {\npublic:\n  //\n  // This emits the frame info section.\n  //\n  static void Emit(MCObjectStreamer &streamer, MCAsmBackend *MAB, bool isEH);\n  static void EmitAdvanceLoc(MCObjectStreamer &Streamer, uint64_t AddrDelta);\n  static void EncodeAdvanceLoc(MCContext &Context, uint64_t AddrDelta,\n                               raw_ostream &OS, uint32_t *Offset = nullptr,\n                               uint32_t *Size = nullptr);\n};\n\n} // end namespace llvm\n\n#endif // LLVM_MC_MCDWARF_H\n"}, "54": {"id": 54, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/MC/MCRegister.h", "content": "//===-- llvm/MC/Register.h --------------------------------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_MC_MCREGISTER_H\n#define LLVM_MC_MCREGISTER_H\n\n#include \"llvm/ADT/DenseMapInfo.h\"\n#include <cassert>\n\nnamespace llvm {\n\n/// An unsigned integer type large enough to represent all physical registers,\n/// but not necessarily virtual registers.\nusing MCPhysReg = uint16_t;\n\n/// Wrapper class representing physical registers. Should be passed by value.\nclass MCRegister {\n  friend hash_code hash_value(const MCRegister &);\n  unsigned Reg;\n\npublic:\n  constexpr MCRegister(unsigned Val = 0): Reg(Val) {}\n\n  // Register numbers can represent physical registers, virtual registers, and\n  // sometimes stack slots. The unsigned values are divided into these ranges:\n  //\n  //   0           Not a register, can be used as a sentinel.\n  //   [1;2^30)    Physical registers assigned by TableGen.\n  //   [2^30;2^31) Stack slots. (Rarely used.)\n  //   [2^31;2^32) Virtual registers assigned by MachineRegisterInfo.\n  //\n  // Further sentinels can be allocated from the small negative integers.\n  // DenseMapInfo<unsigned> uses -1u and -2u.\n  static_assert(std::numeric_limits<decltype(Reg)>::max() >= 0xFFFFFFFF,\n                \"Reg isn't large enough to hold full range.\");\n  static constexpr unsigned NoRegister = 0u;\n  static constexpr unsigned FirstPhysicalReg = 1u;\n  static constexpr unsigned FirstStackSlot = 1u << 30;\n  static constexpr unsigned VirtualRegFlag = 1u << 31;\n\n  /// This is the portion of the positive number space that is not a physical\n  /// register. StackSlot values do not exist in the MC layer, see\n  /// Register::isStackSlot() for the more information on them.\n  ///\n  static bool isStackSlot(unsigned Reg) {\n    return FirstStackSlot <= Reg && Reg < VirtualRegFlag;\n  }\n\n  /// Return true if the specified register number is in\n  /// the physical register namespace.\n  static bool isPhysicalRegister(unsigned Reg) {\n    return FirstPhysicalReg <= Reg && Reg < FirstStackSlot;\n  }\n\n  constexpr operator unsigned() const {\n    return Reg;\n  }\n\n  /// Check the provided unsigned value is a valid MCRegister.\n  static MCRegister from(unsigned Val) {\n    assert(Val == NoRegister || isPhysicalRegister(Val));\n    return MCRegister(Val);\n  }\n\n  unsigned id() const {\n    return Reg;\n  }\n\n  bool isValid() const { return Reg != NoRegister; }\n\n  /// Comparisons between register objects\n  bool operator==(const MCRegister &Other) const { return Reg == Other.Reg; }\n  bool operator!=(const MCRegister &Other) const { return Reg != Other.Reg; }\n\n  /// Comparisons against register constants. E.g.\n  /// * R == AArch64::WZR\n  /// * R == 0\n  /// * R == VirtRegMap::NO_PHYS_REG\n  bool operator==(unsigned Other) const { return Reg == Other; }\n  bool operator!=(unsigned Other) const { return Reg != Other; }\n  bool operator==(int Other) const { return Reg == unsigned(Other); }\n  bool operator!=(int Other) const { return Reg != unsigned(Other); }\n  // MSVC requires that we explicitly declare these two as well.\n  bool operator==(MCPhysReg Other) const { return Reg == unsigned(Other); }\n  bool operator!=(MCPhysReg Other) const { return Reg != unsigned(Other); }\n};\n\n// Provide DenseMapInfo for MCRegister\ntemplate<> struct DenseMapInfo<MCRegister> {\n  static inline unsigned getEmptyKey() {\n    return DenseMapInfo<unsigned>::getEmptyKey();\n  }\n  static inline unsigned getTombstoneKey() {\n    return DenseMapInfo<unsigned>::getTombstoneKey();\n  }\n  static unsigned getHashValue(const MCRegister &Val) {\n    return DenseMapInfo<unsigned>::getHashValue(Val.id());\n  }\n  static bool isEqual(const MCRegister &LHS, const MCRegister &RHS) {\n    return DenseMapInfo<unsigned>::isEqual(LHS.id(), RHS.id());\n  }\n};\n\ninline hash_code hash_value(const MCRegister &Reg) {\n  return hash_value(Reg.id());\n}\n}\n\n#endif // LLVM_MC_MCREGISTER_H\n"}, "55": {"id": 55, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/MC/MCRegisterInfo.h", "content": "//===- MC/MCRegisterInfo.h - Target Register Description --------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// This file describes an abstract interface used to get information about a\n// target machines register file.  This information is used for a variety of\n// purposed, especially register allocation.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_MC_MCREGISTERINFO_H\n#define LLVM_MC_MCREGISTERINFO_H\n\n#include \"llvm/ADT/DenseMap.h\"\n#include \"llvm/ADT/iterator.h\"\n#include \"llvm/ADT/iterator_range.h\"\n#include \"llvm/MC/LaneBitmask.h\"\n#include \"llvm/MC/MCRegister.h\"\n#include <cassert>\n#include <cstdint>\n#include <iterator>\n#include <utility>\n\nnamespace llvm {\n\n/// MCRegisterClass - Base class of TargetRegisterClass.\nclass MCRegisterClass {\npublic:\n  using iterator = const MCPhysReg*;\n  using const_iterator = const MCPhysReg*;\n\n  const iterator RegsBegin;\n  const uint8_t *const RegSet;\n  const uint32_t NameIdx;\n  const uint16_t RegsSize;\n  const uint16_t RegSetSize;\n  const uint16_t ID;\n  const int8_t CopyCost;\n  const bool Allocatable;\n\n  /// getID() - Return the register class ID number.\n  ///\n  unsigned getID() const { return ID; }\n\n  /// begin/end - Return all of the registers in this class.\n  ///\n  iterator       begin() const { return RegsBegin; }\n  iterator         end() const { return RegsBegin + RegsSize; }\n\n  /// getNumRegs - Return the number of registers in this class.\n  ///\n  unsigned getNumRegs() const { return RegsSize; }\n\n  /// getRegister - Return the specified register in the class.\n  ///\n  unsigned getRegister(unsigned i) const {\n    assert(i < getNumRegs() && \"Register number out of range!\");\n    return RegsBegin[i];\n  }\n\n  /// contains - Return true if the specified register is included in this\n  /// register class.  This does not include virtual registers.\n  bool contains(MCRegister Reg) const {\n    unsigned RegNo = unsigned(Reg);\n    unsigned InByte = RegNo % 8;\n    unsigned Byte = RegNo / 8;\n    if (Byte >= RegSetSize)\n      return false;\n    return (RegSet[Byte] & (1 << InByte)) != 0;\n  }\n\n  /// contains - Return true if both registers are in this class.\n  bool contains(MCRegister Reg1, MCRegister Reg2) const {\n    return contains(Reg1) && contains(Reg2);\n  }\n\n  /// getCopyCost - Return the cost of copying a value between two registers in\n  /// this class. A negative number means the register class is very expensive\n  /// to copy e.g. status flag register classes.\n  int getCopyCost() const { return CopyCost; }\n\n  /// isAllocatable - Return true if this register class may be used to create\n  /// virtual registers.\n  bool isAllocatable() const { return Allocatable; }\n};\n\n/// MCRegisterDesc - This record contains information about a particular\n/// register.  The SubRegs field is a zero terminated array of registers that\n/// are sub-registers of the specific register, e.g. AL, AH are sub-registers\n/// of AX. The SuperRegs field is a zero terminated array of registers that are\n/// super-registers of the specific register, e.g. RAX, EAX, are\n/// super-registers of AX.\n///\nstruct MCRegisterDesc {\n  uint32_t Name;      // Printable name for the reg (for debugging)\n  uint32_t SubRegs;   // Sub-register set, described above\n  uint32_t SuperRegs; // Super-register set, described above\n\n  // Offset into MCRI::SubRegIndices of a list of sub-register indices for each\n  // sub-register in SubRegs.\n  uint32_t SubRegIndices;\n\n  // RegUnits - Points to the list of register units. The low 4 bits holds the\n  // Scale, the high bits hold an offset into DiffLists. See MCRegUnitIterator.\n  uint32_t RegUnits;\n\n  /// Index into list with lane mask sequences. The sequence contains a lanemask\n  /// for every register unit.\n  uint16_t RegUnitLaneMasks;\n};\n\n/// MCRegisterInfo base class - We assume that the target defines a static\n/// array of MCRegisterDesc objects that represent all of the machine\n/// registers that the target has.  As such, we simply have to track a pointer\n/// to this array so that we can turn register number into a register\n/// descriptor.\n///\n/// Note this class is designed to be a base class of TargetRegisterInfo, which\n/// is the interface used by codegen. However, specific targets *should never*\n/// specialize this class. MCRegisterInfo should only contain getters to access\n/// TableGen generated physical register data. It must not be extended with\n/// virtual methods.\n///\nclass MCRegisterInfo {\npublic:\n  using regclass_iterator = const MCRegisterClass *;\n\n  /// DwarfLLVMRegPair - Emitted by tablegen so Dwarf<->LLVM reg mappings can be\n  /// performed with a binary search.\n  struct DwarfLLVMRegPair {\n    unsigned FromReg;\n    unsigned ToReg;\n\n    bool operator<(DwarfLLVMRegPair RHS) const { return FromReg < RHS.FromReg; }\n  };\n\n  /// SubRegCoveredBits - Emitted by tablegen: bit range covered by a subreg\n  /// index, -1 in any being invalid.\n  struct SubRegCoveredBits {\n    uint16_t Offset;\n    uint16_t Size;\n  };\n\nprivate:\n  const MCRegisterDesc *Desc;                 // Pointer to the descriptor array\n  unsigned NumRegs;                           // Number of entries in the array\n  MCRegister RAReg;                           // Return address register\n  MCRegister PCReg;                           // Program counter register\n  const MCRegisterClass *Classes;             // Pointer to the regclass array\n  unsigned NumClasses;                        // Number of entries in the array\n  unsigned NumRegUnits;                       // Number of regunits.\n  const MCPhysReg (*RegUnitRoots)[2];         // Pointer to regunit root table.\n  const MCPhysReg *DiffLists;                 // Pointer to the difflists array\n  const LaneBitmask *RegUnitMaskSequences;    // Pointer to lane mask sequences\n                                              // for register units.\n  const char *RegStrings;                     // Pointer to the string table.\n  const char *RegClassStrings;                // Pointer to the class strings.\n  const uint16_t *SubRegIndices;              // Pointer to the subreg lookup\n                                              // array.\n  const SubRegCoveredBits *SubRegIdxRanges;   // Pointer to the subreg covered\n                                              // bit ranges array.\n  unsigned NumSubRegIndices;                  // Number of subreg indices.\n  const uint16_t *RegEncodingTable;           // Pointer to array of register\n                                              // encodings.\n\n  unsigned L2DwarfRegsSize;\n  unsigned EHL2DwarfRegsSize;\n  unsigned Dwarf2LRegsSize;\n  unsigned EHDwarf2LRegsSize;\n  const DwarfLLVMRegPair *L2DwarfRegs;        // LLVM to Dwarf regs mapping\n  const DwarfLLVMRegPair *EHL2DwarfRegs;      // LLVM to Dwarf regs mapping EH\n  const DwarfLLVMRegPair *Dwarf2LRegs;        // Dwarf to LLVM regs mapping\n  const DwarfLLVMRegPair *EHDwarf2LRegs;      // Dwarf to LLVM regs mapping EH\n  DenseMap<MCRegister, int> L2SEHRegs;        // LLVM to SEH regs mapping\n  DenseMap<MCRegister, int> L2CVRegs;         // LLVM to CV regs mapping\n\npublic:\n  // Forward declaration to become a friend class of DiffListIterator.\n  template <class SubT> class mc_difflist_iterator;\n\n  /// DiffListIterator - Base iterator class that can traverse the\n  /// differentially encoded register and regunit lists in DiffLists.\n  /// Don't use this class directly, use one of the specialized sub-classes\n  /// defined below.\n  class DiffListIterator {\n    uint16_t Val = 0;\n    const MCPhysReg *List = nullptr;\n\n  protected:\n    /// Create an invalid iterator. Call init() to point to something useful.\n    DiffListIterator() = default;\n\n    /// init - Point the iterator to InitVal, decoding subsequent values from\n    /// DiffList. The iterator will initially point to InitVal, sub-classes are\n    /// responsible for skipping the seed value if it is not part of the list.\n    void init(MCPhysReg InitVal, const MCPhysReg *DiffList) {\n      Val = InitVal;\n      List = DiffList;\n    }\n\n    /// advance - Move to the next list position, return the applied\n    /// differential. This function does not detect the end of the list, that\n    /// is the caller's responsibility (by checking for a 0 return value).\n    MCRegister advance() {\n      assert(isValid() && \"Cannot move off the end of the list.\");\n      MCPhysReg D = *List++;\n      Val += D;\n      return D;\n    }\n\n  public:\n    /// isValid - returns true if this iterator is not yet at the end.\n    bool isValid() const { return List; }\n\n    /// Dereference the iterator to get the value at the current position.\n    MCRegister operator*() const { return Val; }\n\n    /// Pre-increment to move to the next position.\n    void operator++() {\n      // The end of the list is encoded as a 0 differential.\n      if (!advance())\n        List = nullptr;\n    }\n\n    template <class SubT> friend class MCRegisterInfo::mc_difflist_iterator;\n  };\n\n  /// Forward iterator using DiffListIterator.\n  template <class SubT>\n  class mc_difflist_iterator\n      : public iterator_facade_base<mc_difflist_iterator<SubT>,\n                                    std::forward_iterator_tag, MCPhysReg> {\n    MCRegisterInfo::DiffListIterator Iter;\n    /// Current value as MCPhysReg, so we can return a reference to it.\n    MCPhysReg Val;\n\n  protected:\n    mc_difflist_iterator(MCRegisterInfo::DiffListIterator Iter) : Iter(Iter) {}\n\n    // Allow conversion between instantiations where valid.\n    mc_difflist_iterator(MCRegister Reg, const MCPhysReg *DiffList) {\n      Iter.init(Reg, DiffList);\n      Val = *Iter;\n    }\n\n  public:\n    // Allow default construction to build variables, but this doesn't build\n    // a useful iterator.\n    mc_difflist_iterator() = default;\n\n    /// Return an iterator past the last element.\n    static SubT end() {\n      SubT End;\n      End.Iter.List = nullptr;\n      return End;\n    }\n\n    bool operator==(const mc_difflist_iterator &Arg) const {\n      return Iter.List == Arg.Iter.List;\n    }\n\n    const MCPhysReg &operator*() const { return Val; }\n\n    using mc_difflist_iterator::iterator_facade_base::operator++;\n    void operator++() {\n      assert(Iter.List && \"Cannot increment the end iterator!\");\n      ++Iter;\n      Val = *Iter;\n    }\n  };\n\n  /// Forward iterator over all sub-registers.\n  /// TODO: Replace remaining uses of MCSubRegIterator.\n  class mc_subreg_iterator : public mc_difflist_iterator<mc_subreg_iterator> {\n  public:\n    mc_subreg_iterator(MCRegisterInfo::DiffListIterator Iter)\n        : mc_difflist_iterator(Iter) {}\n    mc_subreg_iterator() = default;\n    mc_subreg_iterator(MCRegister Reg, const MCRegisterInfo *MCRI)\n        : mc_difflist_iterator(Reg, MCRI->DiffLists + MCRI->get(Reg).SubRegs) {}\n  };\n\n  /// Forward iterator over all super-registers.\n  /// TODO: Replace remaining uses of MCSuperRegIterator.\n  class mc_superreg_iterator\n      : public mc_difflist_iterator<mc_superreg_iterator> {\n  public:\n    mc_superreg_iterator(MCRegisterInfo::DiffListIterator Iter)\n        : mc_difflist_iterator(Iter) {}\n    mc_superreg_iterator() = default;\n    mc_superreg_iterator(MCRegister Reg, const MCRegisterInfo *MCRI)\n        : mc_difflist_iterator(Reg,\n                               MCRI->DiffLists + MCRI->get(Reg).SuperRegs) {}\n  };\n\n  /// Return an iterator range over all sub-registers of \\p Reg, excluding \\p\n  /// Reg.\n  iterator_range<mc_subreg_iterator> subregs(MCRegister Reg) const {\n    return make_range(std::next(mc_subreg_iterator(Reg, this)),\n                      mc_subreg_iterator::end());\n  }\n\n  /// Return an iterator range over all sub-registers of \\p Reg, including \\p\n  /// Reg.\n  iterator_range<mc_subreg_iterator> subregs_inclusive(MCRegister Reg) const {\n    return make_range({Reg, this}, mc_subreg_iterator::end());\n  }\n\n  /// Return an iterator range over all super-registers of \\p Reg, excluding \\p\n  /// Reg.\n  iterator_range<mc_superreg_iterator> superregs(MCRegister Reg) const {\n    return make_range(std::next(mc_superreg_iterator(Reg, this)),\n                      mc_superreg_iterator::end());\n  }\n\n  /// Return an iterator range over all super-registers of \\p Reg, including \\p\n  /// Reg.\n  iterator_range<mc_superreg_iterator>\n  superregs_inclusive(MCRegister Reg) const {\n    return make_range({Reg, this}, mc_superreg_iterator::end());\n  }\n\n  /// Return an iterator range over all sub- and super-registers of \\p Reg,\n  /// including \\p Reg.\n  detail::concat_range<const MCPhysReg, iterator_range<mc_subreg_iterator>,\n                       iterator_range<mc_superreg_iterator>>\n  sub_and_superregs_inclusive(MCRegister Reg) const {\n    return concat<const MCPhysReg>(subregs_inclusive(Reg), superregs(Reg));\n  }\n\n  // These iterators are allowed to sub-class DiffListIterator and access\n  // internal list pointers.\n  friend class MCSubRegIterator;\n  friend class MCSubRegIndexIterator;\n  friend class MCSuperRegIterator;\n  friend class MCRegUnitIterator;\n  friend class MCRegUnitMaskIterator;\n  friend class MCRegUnitRootIterator;\n\n  /// Initialize MCRegisterInfo, called by TableGen\n  /// auto-generated routines. *DO NOT USE*.\n  void InitMCRegisterInfo(const MCRegisterDesc *D, unsigned NR, unsigned RA,\n                          unsigned PC,\n                          const MCRegisterClass *C, unsigned NC,\n                          const MCPhysReg (*RURoots)[2],\n                          unsigned NRU,\n                          const MCPhysReg *DL,\n                          const LaneBitmask *RUMS,\n                          const char *Strings,\n                          const char *ClassStrings,\n                          const uint16_t *SubIndices,\n                          unsigned NumIndices,\n                          const SubRegCoveredBits *SubIdxRanges,\n                          const uint16_t *RET) {\n    Desc = D;\n    NumRegs = NR;\n    RAReg = RA;\n    PCReg = PC;\n    Classes = C;\n    DiffLists = DL;\n    RegUnitMaskSequences = RUMS;\n    RegStrings = Strings;\n    RegClassStrings = ClassStrings;\n    NumClasses = NC;\n    RegUnitRoots = RURoots;\n    NumRegUnits = NRU;\n    SubRegIndices = SubIndices;\n    NumSubRegIndices = NumIndices;\n    SubRegIdxRanges = SubIdxRanges;\n    RegEncodingTable = RET;\n\n    // Initialize DWARF register mapping variables\n    EHL2DwarfRegs = nullptr;\n    EHL2DwarfRegsSize = 0;\n    L2DwarfRegs = nullptr;\n    L2DwarfRegsSize = 0;\n    EHDwarf2LRegs = nullptr;\n    EHDwarf2LRegsSize = 0;\n    Dwarf2LRegs = nullptr;\n    Dwarf2LRegsSize = 0;\n  }\n\n  /// Used to initialize LLVM register to Dwarf\n  /// register number mapping. Called by TableGen auto-generated routines.\n  /// *DO NOT USE*.\n  void mapLLVMRegsToDwarfRegs(const DwarfLLVMRegPair *Map, unsigned Size,\n                              bool isEH) {\n    if (isEH) {\n      EHL2DwarfRegs = Map;\n      EHL2DwarfRegsSize = Size;\n    } else {\n      L2DwarfRegs = Map;\n      L2DwarfRegsSize = Size;\n    }\n  }\n\n  /// Used to initialize Dwarf register to LLVM\n  /// register number mapping. Called by TableGen auto-generated routines.\n  /// *DO NOT USE*.\n  void mapDwarfRegsToLLVMRegs(const DwarfLLVMRegPair *Map, unsigned Size,\n                              bool isEH) {\n    if (isEH) {\n      EHDwarf2LRegs = Map;\n      EHDwarf2LRegsSize = Size;\n    } else {\n      Dwarf2LRegs = Map;\n      Dwarf2LRegsSize = Size;\n    }\n  }\n\n  /// mapLLVMRegToSEHReg - Used to initialize LLVM register to SEH register\n  /// number mapping. By default the SEH register number is just the same\n  /// as the LLVM register number.\n  /// FIXME: TableGen these numbers. Currently this requires target specific\n  /// initialization code.\n  void mapLLVMRegToSEHReg(MCRegister LLVMReg, int SEHReg) {\n    L2SEHRegs[LLVMReg] = SEHReg;\n  }\n\n  void mapLLVMRegToCVReg(MCRegister LLVMReg, int CVReg) {\n    L2CVRegs[LLVMReg] = CVReg;\n  }\n\n  /// This method should return the register where the return\n  /// address can be found.\n  MCRegister getRARegister() const {\n    return RAReg;\n  }\n\n  /// Return the register which is the program counter.\n  MCRegister getProgramCounter() const {\n    return PCReg;\n  }\n\n  const MCRegisterDesc &operator[](MCRegister RegNo) const {\n    assert(RegNo < NumRegs &&\n           \"Attempting to access record for invalid register number!\");\n    return Desc[RegNo];\n  }\n\n  /// Provide a get method, equivalent to [], but more useful with a\n  /// pointer to this object.\n  const MCRegisterDesc &get(MCRegister RegNo) const {\n    return operator[](RegNo);\n  }\n\n  /// Returns the physical register number of sub-register \"Index\"\n  /// for physical register RegNo. Return zero if the sub-register does not\n  /// exist.\n  MCRegister getSubReg(MCRegister Reg, unsigned Idx) const;\n\n  /// Return a super-register of the specified register\n  /// Reg so its sub-register of index SubIdx is Reg.\n  MCRegister getMatchingSuperReg(MCRegister Reg, unsigned SubIdx,\n                                 const MCRegisterClass *RC) const;\n\n  /// For a given register pair, return the sub-register index\n  /// if the second register is a sub-register of the first. Return zero\n  /// otherwise.\n  unsigned getSubRegIndex(MCRegister RegNo, MCRegister SubRegNo) const;\n\n  /// Get the size of the bit range covered by a sub-register index.\n  /// If the index isn't continuous, return the sum of the sizes of its parts.\n  /// If the index is used to access subregisters of different sizes, return -1.\n  unsigned getSubRegIdxSize(unsigned Idx) const;\n\n  /// Get the offset of the bit range covered by a sub-register index.\n  /// If an Offset doesn't make sense (the index isn't continuous, or is used to\n  /// access sub-registers at different offsets), return -1.\n  unsigned getSubRegIdxOffset(unsigned Idx) const;\n\n  /// Return the human-readable symbolic target-specific name for the\n  /// specified physical register.\n  const char *getName(MCRegister RegNo) const {\n    return RegStrings + get(RegNo).Name;\n  }\n\n  /// Return the number of registers this target has (useful for\n  /// sizing arrays holding per register information)\n  unsigned getNumRegs() const {\n    return NumRegs;\n  }\n\n  /// Return the number of sub-register indices\n  /// understood by the target. Index 0 is reserved for the no-op sub-register,\n  /// while 1 to getNumSubRegIndices() - 1 represent real sub-registers.\n  unsigned getNumSubRegIndices() const {\n    return NumSubRegIndices;\n  }\n\n  /// Return the number of (native) register units in the\n  /// target. Register units are numbered from 0 to getNumRegUnits() - 1. They\n  /// can be accessed through MCRegUnitIterator defined below.\n  unsigned getNumRegUnits() const {\n    return NumRegUnits;\n  }\n\n  /// Map a target register to an equivalent dwarf register\n  /// number.  Returns -1 if there is no equivalent value.  The second\n  /// parameter allows targets to use different numberings for EH info and\n  /// debugging info.\n  int getDwarfRegNum(MCRegister RegNum, bool isEH) const;\n\n  /// Map a dwarf register back to a target register. Returns None is there is\n  /// no mapping.\n  Optional<unsigned> getLLVMRegNum(unsigned RegNum, bool isEH) const;\n\n  /// Map a target EH register number to an equivalent DWARF register\n  /// number.\n  int getDwarfRegNumFromDwarfEHRegNum(unsigned RegNum) const;\n\n  /// Map a target register to an equivalent SEH register\n  /// number.  Returns LLVM register number if there is no equivalent value.\n  int getSEHRegNum(MCRegister RegNum) const;\n\n  /// Map a target register to an equivalent CodeView register\n  /// number.\n  int getCodeViewRegNum(MCRegister RegNum) const;\n\n  regclass_iterator regclass_begin() const { return Classes; }\n  regclass_iterator regclass_end() const { return Classes+NumClasses; }\n  iterator_range<regclass_iterator> regclasses() const {\n    return make_range(regclass_begin(), regclass_end());\n  }\n\n  unsigned getNumRegClasses() const {\n    return (unsigned)(regclass_end()-regclass_begin());\n  }\n\n  /// Returns the register class associated with the enumeration\n  /// value.  See class MCOperandInfo.\n  const MCRegisterClass& getRegClass(unsigned i) const {\n    assert(i < getNumRegClasses() && \"Register Class ID out of range\");\n    return Classes[i];\n  }\n\n  const char *getRegClassName(const MCRegisterClass *Class) const {\n    return RegClassStrings + Class->NameIdx;\n  }\n\n   /// Returns the encoding for RegNo\n  uint16_t getEncodingValue(MCRegister RegNo) const {\n    assert(RegNo < NumRegs &&\n           \"Attempting to get encoding for invalid register number!\");\n    return RegEncodingTable[RegNo];\n  }\n\n  /// Returns true if RegB is a sub-register of RegA.\n  bool isSubRegister(MCRegister RegA, MCRegister RegB) const {\n    return isSuperRegister(RegB, RegA);\n  }\n\n  /// Returns true if RegB is a super-register of RegA.\n  bool isSuperRegister(MCRegister RegA, MCRegister RegB) const;\n\n  /// Returns true if RegB is a sub-register of RegA or if RegB == RegA.\n  bool isSubRegisterEq(MCRegister RegA, MCRegister RegB) const {\n    return isSuperRegisterEq(RegB, RegA);\n  }\n\n  /// Returns true if RegB is a super-register of RegA or if\n  /// RegB == RegA.\n  bool isSuperRegisterEq(MCRegister RegA, MCRegister RegB) const {\n    return RegA == RegB || isSuperRegister(RegA, RegB);\n  }\n\n  /// Returns true if RegB is a super-register or sub-register of RegA\n  /// or if RegB == RegA.\n  bool isSuperOrSubRegisterEq(MCRegister RegA, MCRegister RegB) const {\n    return isSubRegisterEq(RegA, RegB) || isSuperRegister(RegA, RegB);\n  }\n};\n\n//===----------------------------------------------------------------------===//\n//                          Register List Iterators\n//===----------------------------------------------------------------------===//\n\n// MCRegisterInfo provides lists of super-registers, sub-registers, and\n// aliasing registers. Use these iterator classes to traverse the lists.\n\n/// MCSubRegIterator enumerates all sub-registers of Reg.\n/// If IncludeSelf is set, Reg itself is included in the list.\nclass MCSubRegIterator : public MCRegisterInfo::DiffListIterator {\npublic:\n  MCSubRegIterator(MCRegister Reg, const MCRegisterInfo *MCRI,\n                   bool IncludeSelf = false) {\n    init(Reg, MCRI->DiffLists + MCRI->get(Reg).SubRegs);\n    // Initially, the iterator points to Reg itself.\n    if (!IncludeSelf)\n      ++*this;\n  }\n};\n\n/// Iterator that enumerates the sub-registers of a Reg and the associated\n/// sub-register indices.\nclass MCSubRegIndexIterator {\n  MCSubRegIterator SRIter;\n  const uint16_t *SRIndex;\n\npublic:\n  /// Constructs an iterator that traverses subregisters and their\n  /// associated subregister indices.\n  MCSubRegIndexIterator(MCRegister Reg, const MCRegisterInfo *MCRI)\n    : SRIter(Reg, MCRI) {\n    SRIndex = MCRI->SubRegIndices + MCRI->get(Reg).SubRegIndices;\n  }\n\n  /// Returns current sub-register.\n  MCRegister getSubReg() const {\n    return *SRIter;\n  }\n\n  /// Returns sub-register index of the current sub-register.\n  unsigned getSubRegIndex() const {\n    return *SRIndex;\n  }\n\n  /// Returns true if this iterator is not yet at the end.\n  bool isValid() const { return SRIter.isValid(); }\n\n  /// Moves to the next position.\n  void operator++() {\n    ++SRIter;\n    ++SRIndex;\n  }\n};\n\n/// MCSuperRegIterator enumerates all super-registers of Reg.\n/// If IncludeSelf is set, Reg itself is included in the list.\nclass MCSuperRegIterator : public MCRegisterInfo::DiffListIterator {\npublic:\n  MCSuperRegIterator() = default;\n\n  MCSuperRegIterator(MCRegister Reg, const MCRegisterInfo *MCRI,\n                     bool IncludeSelf = false) {\n    init(Reg, MCRI->DiffLists + MCRI->get(Reg).SuperRegs);\n    // Initially, the iterator points to Reg itself.\n    if (!IncludeSelf)\n      ++*this;\n  }\n};\n\n// Definition for isSuperRegister. Put it down here since it needs the\n// iterator defined above in addition to the MCRegisterInfo class itself.\ninline bool MCRegisterInfo::isSuperRegister(MCRegister RegA, MCRegister RegB) const{\n  for (MCSuperRegIterator I(RegA, this); I.isValid(); ++I)\n    if (*I == RegB)\n      return true;\n  return false;\n}\n\n//===----------------------------------------------------------------------===//\n//                               Register Units\n//===----------------------------------------------------------------------===//\n\n// Register units are used to compute register aliasing. Every register has at\n// least one register unit, but it can have more. Two registers overlap if and\n// only if they have a common register unit.\n//\n// A target with a complicated sub-register structure will typically have many\n// fewer register units than actual registers. MCRI::getNumRegUnits() returns\n// the number of register units in the target.\n\n// MCRegUnitIterator enumerates a list of register units for Reg. The list is\n// in ascending numerical order.\nclass MCRegUnitIterator : public MCRegisterInfo::DiffListIterator {\npublic:\n  /// MCRegUnitIterator - Create an iterator that traverses the register units\n  /// in Reg.\n  MCRegUnitIterator() = default;\n\n  MCRegUnitIterator(MCRegister Reg, const MCRegisterInfo *MCRI) {\n    assert(Reg && \"Null register has no regunits\");\n    assert(MCRegister::isPhysicalRegister(Reg.id()));\n    // Decode the RegUnits MCRegisterDesc field.\n    unsigned RU = MCRI->get(Reg).RegUnits;\n    unsigned Scale = RU & 15;\n    unsigned Offset = RU >> 4;\n\n    // Initialize the iterator to Reg * Scale, and the List pointer to\n    // DiffLists + Offset.\n    init(Reg * Scale, MCRI->DiffLists + Offset);\n\n    // That may not be a valid unit, we need to advance by one to get the real\n    // unit number. The first differential can be 0 which would normally\n    // terminate the list, but since we know every register has at least one\n    // unit, we can allow a 0 differential here.\n    advance();\n  }\n};\n\n/// MCRegUnitMaskIterator enumerates a list of register units and their\n/// associated lane masks for Reg. The register units are in ascending\n/// numerical order.\nclass MCRegUnitMaskIterator {\n  MCRegUnitIterator RUIter;\n  const LaneBitmask *MaskListIter;\n\npublic:\n  MCRegUnitMaskIterator() = default;\n\n  /// Constructs an iterator that traverses the register units and their\n  /// associated LaneMasks in Reg.\n  MCRegUnitMaskIterator(MCRegister Reg, const MCRegisterInfo *MCRI)\n    : RUIter(Reg, MCRI) {\n      uint16_t Idx = MCRI->get(Reg).RegUnitLaneMasks;\n      MaskListIter = &MCRI->RegUnitMaskSequences[Idx];\n  }\n\n  /// Returns a (RegUnit, LaneMask) pair.\n  std::pair<unsigned,LaneBitmask> operator*() const {\n    return std::make_pair(*RUIter, *MaskListIter);\n  }\n\n  /// Returns true if this iterator is not yet at the end.\n  bool isValid() const { return RUIter.isValid(); }\n\n  /// Moves to the next position.\n  void operator++() {\n    ++MaskListIter;\n    ++RUIter;\n  }\n};\n\n// Each register unit has one or two root registers. The complete set of\n// registers containing a register unit is the union of the roots and their\n// super-registers. All registers aliasing Unit can be visited like this:\n//\n//   for (MCRegUnitRootIterator RI(Unit, MCRI); RI.isValid(); ++RI) {\n//     for (MCSuperRegIterator SI(*RI, MCRI, true); SI.isValid(); ++SI)\n//       visit(*SI);\n//    }\n\n/// MCRegUnitRootIterator enumerates the root registers of a register unit.\nclass MCRegUnitRootIterator {\n  uint16_t Reg0 = 0;\n  uint16_t Reg1 = 0;\n\npublic:\n  MCRegUnitRootIterator() = default;\n\n  MCRegUnitRootIterator(unsigned RegUnit, const MCRegisterInfo *MCRI) {\n    assert(RegUnit < MCRI->getNumRegUnits() && \"Invalid register unit\");\n    Reg0 = MCRI->RegUnitRoots[RegUnit][0];\n    Reg1 = MCRI->RegUnitRoots[RegUnit][1];\n  }\n\n  /// Dereference to get the current root register.\n  unsigned operator*() const {\n    return Reg0;\n  }\n\n  /// Check if the iterator is at the end of the list.\n  bool isValid() const {\n    return Reg0;\n  }\n\n  /// Preincrement to move to the next root register.\n  void operator++() {\n    assert(isValid() && \"Cannot move off the end of the list.\");\n    Reg0 = Reg1;\n    Reg1 = 0;\n  }\n};\n\n/// MCRegAliasIterator enumerates all registers aliasing Reg.  If IncludeSelf is\n/// set, Reg itself is included in the list.  This iterator does not guarantee\n/// any ordering or that entries are unique.\nclass MCRegAliasIterator {\nprivate:\n  MCRegister Reg;\n  const MCRegisterInfo *MCRI;\n  bool IncludeSelf;\n\n  MCRegUnitIterator RI;\n  MCRegUnitRootIterator RRI;\n  MCSuperRegIterator SI;\n\npublic:\n  MCRegAliasIterator(MCRegister Reg, const MCRegisterInfo *MCRI,\n                     bool IncludeSelf)\n    : Reg(Reg), MCRI(MCRI), IncludeSelf(IncludeSelf) {\n    // Initialize the iterators.\n    for (RI = MCRegUnitIterator(Reg, MCRI); RI.isValid(); ++RI) {\n      for (RRI = MCRegUnitRootIterator(*RI, MCRI); RRI.isValid(); ++RRI) {\n        for (SI = MCSuperRegIterator(*RRI, MCRI, true); SI.isValid(); ++SI) {\n          if (!(!IncludeSelf && Reg == *SI))\n            return;\n        }\n      }\n    }\n  }\n\n  bool isValid() const { return RI.isValid(); }\n\n  MCRegister operator*() const {\n    assert(SI.isValid() && \"Cannot dereference an invalid iterator.\");\n    return *SI;\n  }\n\n  void advance() {\n    // Assuming SI is valid.\n    ++SI;\n    if (SI.isValid()) return;\n\n    ++RRI;\n    if (RRI.isValid()) {\n      SI = MCSuperRegIterator(*RRI, MCRI, true);\n      return;\n    }\n\n    ++RI;\n    if (RI.isValid()) {\n      RRI = MCRegUnitRootIterator(*RI, MCRI);\n      SI = MCSuperRegIterator(*RRI, MCRI, true);\n    }\n  }\n\n  void operator++() {\n    assert(isValid() && \"Cannot move off the end of the list.\");\n    do advance();\n    while (!IncludeSelf && isValid() && *SI == Reg);\n  }\n};\n\n} // end namespace llvm\n\n#endif // LLVM_MC_MCREGISTERINFO_H\n"}, "56": {"id": 56, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/MC/MachineLocation.h", "content": "//===- llvm/MC/MachineLocation.h --------------------------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n// The MachineLocation class is used to represent a simple location in a machine\n// frame.  Locations will be one of two forms; a register or an address formed\n// from a base address plus an offset.  Register indirection can be specified by\n// explicitly passing an offset to the constructor.\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_MC_MACHINELOCATION_H\n#define LLVM_MC_MACHINELOCATION_H\n\n#include <cstdint>\n#include <cassert>\n\nnamespace llvm {\n\nclass MachineLocation {\nprivate:\n  bool IsRegister = false;              ///< True if location is a register.\n  unsigned Register = 0;                ///< gcc/gdb register number.\n\npublic:\n  enum : uint32_t {\n    // The target register number for an abstract frame pointer. The value is\n    // an arbitrary value that doesn't collide with any real target register.\n    VirtualFP = ~0U\n  };\n\n  MachineLocation() = default;\n  /// Create a direct register location.\n  explicit MachineLocation(unsigned R, bool Indirect = false)\n      : IsRegister(!Indirect), Register(R) {}\n\n  bool operator==(const MachineLocation &Other) const {\n    return IsRegister == Other.IsRegister && Register == Other.Register;\n  }\n\n  // Accessors.\n  /// \\return true iff this is a register-indirect location.\n  bool isIndirect()      const { return !IsRegister; }\n  bool isReg()           const { return IsRegister; }\n  unsigned getReg()      const { return Register; }\n  void setIsRegister(bool Is)  { IsRegister = Is; }\n  void setRegister(unsigned R) { Register = R; }\n};\n\ninline bool operator!=(const MachineLocation &LHS, const MachineLocation &RHS) {\n  return !(LHS == RHS);\n}\n\n} // end namespace llvm\n\n#endif // LLVM_MC_MACHINELOCATION_H\n"}, "57": {"id": 57, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/MC/SectionKind.h", "content": "//===-- llvm/MC/SectionKind.h - Classification of sections ------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_MC_SECTIONKIND_H\n#define LLVM_MC_SECTIONKIND_H\n\nnamespace llvm {\n\n/// SectionKind - This is a simple POD value that classifies the properties of\n/// a section.  A section is classified into the deepest possible\n/// classification, and then the target maps them onto their sections based on\n/// what capabilities they have.\n///\n/// The comments below describe these as if they were an inheritance hierarchy\n/// in order to explain the predicates below.\n///\nclass SectionKind {\n  enum Kind {\n    /// Metadata - Debug info sections or other metadata.\n    Metadata,\n\n    /// Text - Text section, used for functions and other executable code.\n    Text,\n\n           /// ExecuteOnly, Text section that is not readable.\n           ExecuteOnly,\n\n    /// ReadOnly - Data that is never written to at program runtime by the\n    /// program or the dynamic linker.  Things in the top-level readonly\n    /// SectionKind are not mergeable.\n    ReadOnly,\n\n        /// MergableCString - Any null-terminated string which allows merging.\n        /// These values are known to end in a nul value of the specified size,\n        /// not otherwise contain a nul value, and be mergable.  This allows the\n        /// linker to unique the strings if it so desires.\n\n           /// Mergeable1ByteCString - 1 byte mergable, null terminated, string.\n           Mergeable1ByteCString,\n\n           /// Mergeable2ByteCString - 2 byte mergable, null terminated, string.\n           Mergeable2ByteCString,\n\n           /// Mergeable4ByteCString - 4 byte mergable, null terminated, string.\n           Mergeable4ByteCString,\n\n        /// MergeableConst - These are sections for merging fixed-length\n        /// constants together.  For example, this can be used to unique\n        /// constant pool entries etc.\n\n            /// MergeableConst4 - This is a section used by 4-byte constants,\n            /// for example, floats.\n            MergeableConst4,\n\n            /// MergeableConst8 - This is a section used by 8-byte constants,\n            /// for example, doubles.\n            MergeableConst8,\n\n            /// MergeableConst16 - This is a section used by 16-byte constants,\n            /// for example, vectors.\n            MergeableConst16,\n\n            /// MergeableConst32 - This is a section used by 32-byte constants,\n            /// for example, vectors.\n            MergeableConst32,\n\n    /// Writeable - This is the base of all segments that need to be written\n    /// to during program runtime.\n\n       /// ThreadLocal - This is the base of all TLS segments.  All TLS\n       /// objects must be writeable, otherwise there is no reason for them to\n       /// be thread local!\n\n           /// ThreadBSS - Zero-initialized TLS data objects.\n           ThreadBSS,\n\n           /// ThreadData - Initialized TLS data objects.\n           ThreadData,\n\n           /// ThreadBSSLocal - Zero-initialized TLS data objects with local linkage.\n           ThreadBSSLocal,\n\n       /// GlobalWriteableData - Writeable data that is global (not thread\n       /// local).\n\n           /// BSS - Zero initialized writeable data.\n           BSS,\n\n               /// BSSLocal - This is BSS (zero initialized and writable) data\n               /// which has local linkage.\n               BSSLocal,\n\n               /// BSSExtern - This is BSS data with normal external linkage.\n               BSSExtern,\n\n           /// Common - Data with common linkage.  These represent tentative\n           /// definitions, which always have a zero initializer and are never\n           /// marked 'constant'.\n           Common,\n\n           /// This is writeable data that has a non-zero initializer.\n           Data,\n\n           /// ReadOnlyWithRel - These are global variables that are never\n           /// written to by the program, but that have relocations, so they\n           /// must be stuck in a writeable section so that the dynamic linker\n           /// can write to them.  If it chooses to, the dynamic linker can\n           /// mark the pages these globals end up on as read-only after it is\n           /// done with its relocation phase.\n           ReadOnlyWithRel\n  } K : 8;\npublic:\n\n  bool isMetadata() const { return K == Metadata; }\n\n  bool isText() const { return K == Text || K == ExecuteOnly; }\n\n  bool isExecuteOnly() const { return K == ExecuteOnly; }\n\n  bool isReadOnly() const {\n    return K == ReadOnly || isMergeableCString() ||\n           isMergeableConst();\n  }\n\n  bool isMergeableCString() const {\n    return K == Mergeable1ByteCString || K == Mergeable2ByteCString ||\n           K == Mergeable4ByteCString;\n  }\n  bool isMergeable1ByteCString() const { return K == Mergeable1ByteCString; }\n  bool isMergeable2ByteCString() const { return K == Mergeable2ByteCString; }\n  bool isMergeable4ByteCString() const { return K == Mergeable4ByteCString; }\n\n  bool isMergeableConst() const {\n    return K == MergeableConst4 || K == MergeableConst8 ||\n           K == MergeableConst16 || K == MergeableConst32;\n  }\n  bool isMergeableConst4() const { return K == MergeableConst4; }\n  bool isMergeableConst8() const { return K == MergeableConst8; }\n  bool isMergeableConst16() const { return K == MergeableConst16; }\n  bool isMergeableConst32() const { return K == MergeableConst32; }\n\n  bool isWriteable() const {\n    return isThreadLocal() || isGlobalWriteableData();\n  }\n\n  bool isThreadLocal() const {\n    return K == ThreadData || K == ThreadBSS || K == ThreadBSSLocal;\n  }\n\n  bool isThreadBSS() const { return K == ThreadBSS || K == ThreadBSSLocal; }\n  bool isThreadData() const { return K == ThreadData; }\n  bool isThreadBSSLocal() const { return K == ThreadBSSLocal; }\n\n  bool isGlobalWriteableData() const {\n    return isBSS() || isCommon() || isData() || isReadOnlyWithRel();\n  }\n\n  bool isBSS() const { return K == BSS || K == BSSLocal || K == BSSExtern; }\n  bool isBSSLocal() const { return K == BSSLocal; }\n  bool isBSSExtern() const { return K == BSSExtern; }\n\n  bool isCommon() const { return K == Common; }\n\n  bool isData() const { return K == Data; }\n\n  bool isReadOnlyWithRel() const {\n    return K == ReadOnlyWithRel;\n  }\nprivate:\n  static SectionKind get(Kind K) {\n    SectionKind Res;\n    Res.K = K;\n    return Res;\n  }\npublic:\n\n  static SectionKind getMetadata() { return get(Metadata); }\n  static SectionKind getText() { return get(Text); }\n  static SectionKind getExecuteOnly() { return get(ExecuteOnly); }\n  static SectionKind getReadOnly() { return get(ReadOnly); }\n  static SectionKind getMergeable1ByteCString() {\n    return get(Mergeable1ByteCString);\n  }\n  static SectionKind getMergeable2ByteCString() {\n    return get(Mergeable2ByteCString);\n  }\n  static SectionKind getMergeable4ByteCString() {\n    return get(Mergeable4ByteCString);\n  }\n  static SectionKind getMergeableConst4() { return get(MergeableConst4); }\n  static SectionKind getMergeableConst8() { return get(MergeableConst8); }\n  static SectionKind getMergeableConst16() { return get(MergeableConst16); }\n  static SectionKind getMergeableConst32() { return get(MergeableConst32); }\n  static SectionKind getThreadBSS() { return get(ThreadBSS); }\n  static SectionKind getThreadData() { return get(ThreadData); }\n  static SectionKind getThreadBSSLocal() { return get(ThreadBSSLocal); }\n  static SectionKind getBSS() { return get(BSS); }\n  static SectionKind getBSSLocal() { return get(BSSLocal); }\n  static SectionKind getBSSExtern() { return get(BSSExtern); }\n  static SectionKind getCommon() { return get(Common); }\n  static SectionKind getData() { return get(Data); }\n  static SectionKind getReadOnlyWithRel() { return get(ReadOnlyWithRel); }\n};\n\n} // end namespace llvm\n\n#endif\n"}, "59": {"id": 59, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Pass.h", "content": "//===- llvm/Pass.h - Base class for Passes ----------------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// This file defines a base class that indicates that a specified class is a\n// transformation pass implementation.\n//\n// Passes are designed this way so that it is possible to run passes in a cache\n// and organizationally optimal order without having to specify it at the front\n// end.  This allows arbitrary passes to be strung together and have them\n// executed as efficiently as possible.\n//\n// Passes should extend one of the classes below, depending on the guarantees\n// that it can make about what will be modified as it is run.  For example, most\n// global optimizations should derive from FunctionPass, because they do not add\n// or delete functions, they operate on the internals of the function.\n//\n// Note that this file #includes PassSupport.h and PassAnalysisSupport.h (at the\n// bottom), so the APIs exposed by these files are also automatically available\n// to all users of this file.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_PASS_H\n#define LLVM_PASS_H\n\n#include <string>\n\nnamespace llvm {\n\nclass AnalysisResolver;\nclass AnalysisUsage;\nclass Function;\nclass ImmutablePass;\nclass Module;\nclass PassInfo;\nclass PMDataManager;\nclass PMStack;\nclass raw_ostream;\nclass StringRef;\n\n// AnalysisID - Use the PassInfo to identify a pass...\nusing AnalysisID = const void *;\n\n/// Different types of internal pass managers. External pass managers\n/// (PassManager and FunctionPassManager) are not represented here.\n/// Ordering of pass manager types is important here.\nenum PassManagerType {\n  PMT_Unknown = 0,\n  PMT_ModulePassManager = 1, ///< MPPassManager\n  PMT_CallGraphPassManager,  ///< CGPassManager\n  PMT_FunctionPassManager,   ///< FPPassManager\n  PMT_LoopPassManager,       ///< LPPassManager\n  PMT_RegionPassManager,     ///< RGPassManager\n  PMT_Last\n};\n\n// Different types of passes.\nenum PassKind {\n  PT_Region,\n  PT_Loop,\n  PT_Function,\n  PT_CallGraphSCC,\n  PT_Module,\n  PT_PassManager\n};\n\n/// This enumerates the LLVM full LTO or ThinLTO optimization phases.\nenum class ThinOrFullLTOPhase {\n  /// No LTO/ThinLTO behavior needed.\n  None,\n  /// ThinLTO prelink (summary) phase.\n  ThinLTOPreLink,\n  /// ThinLTO postlink (backend compile) phase.\n  ThinLTOPostLink,\n  /// Full LTO prelink phase.\n  FullLTOPreLink,\n  /// Full LTO postlink (backend compile) phase.\n  FullLTOPostLink\n};\n\n//===----------------------------------------------------------------------===//\n/// Pass interface - Implemented by all 'passes'.  Subclass this if you are an\n/// interprocedural optimization or you do not fit into any of the more\n/// constrained passes described below.\n///\nclass Pass {\n  AnalysisResolver *Resolver = nullptr;  // Used to resolve analysis\n  const void *PassID;\n  PassKind Kind;\n\npublic:\n  explicit Pass(PassKind K, char &pid) : PassID(&pid), Kind(K) {}\n  Pass(const Pass &) = delete;\n  Pass &operator=(const Pass &) = delete;\n  virtual ~Pass();\n\n  PassKind getPassKind() const { return Kind; }\n\n  /// getPassName - Return a nice clean name for a pass.  This usually\n  /// implemented in terms of the name that is registered by one of the\n  /// Registration templates, but can be overloaded directly.\n  virtual StringRef getPassName() const;\n\n  /// getPassID - Return the PassID number that corresponds to this pass.\n  AnalysisID getPassID() const {\n    return PassID;\n  }\n\n  /// doInitialization - Virtual method overridden by subclasses to do\n  /// any necessary initialization before any pass is run.\n  virtual bool doInitialization(Module &)  { return false; }\n\n  /// doFinalization - Virtual method overriden by subclasses to do any\n  /// necessary clean up after all passes have run.\n  virtual bool doFinalization(Module &) { return false; }\n\n  /// print - Print out the internal state of the pass.  This is called by\n  /// Analyze to print out the contents of an analysis.  Otherwise it is not\n  /// necessary to implement this method.  Beware that the module pointer MAY be\n  /// null.  This automatically forwards to a virtual function that does not\n  /// provide the Module* in case the analysis doesn't need it it can just be\n  /// ignored.\n  virtual void print(raw_ostream &OS, const Module *M) const;\n\n  void dump() const; // dump - Print to stderr.\n\n  /// createPrinterPass - Get a Pass appropriate to print the IR this\n  /// pass operates on (Module, Function or MachineFunction).\n  virtual Pass *createPrinterPass(raw_ostream &OS,\n                                  const std::string &Banner) const = 0;\n\n  /// Each pass is responsible for assigning a pass manager to itself.\n  /// PMS is the stack of available pass manager.\n  virtual void assignPassManager(PMStack &,\n                                 PassManagerType) {}\n\n  /// Check if available pass managers are suitable for this pass or not.\n  virtual void preparePassManager(PMStack &);\n\n  ///  Return what kind of Pass Manager can manage this pass.\n  virtual PassManagerType getPotentialPassManagerType() const;\n\n  // Access AnalysisResolver\n  void setResolver(AnalysisResolver *AR);\n  AnalysisResolver *getResolver() const { return Resolver; }\n\n  /// getAnalysisUsage - This function should be overriden by passes that need\n  /// analysis information to do their job.  If a pass specifies that it uses a\n  /// particular analysis result to this function, it can then use the\n  /// getAnalysis<AnalysisType>() function, below.\n  virtual void getAnalysisUsage(AnalysisUsage &) const;\n\n  /// releaseMemory() - This member can be implemented by a pass if it wants to\n  /// be able to release its memory when it is no longer needed.  The default\n  /// behavior of passes is to hold onto memory for the entire duration of their\n  /// lifetime (which is the entire compile time).  For pipelined passes, this\n  /// is not a big deal because that memory gets recycled every time the pass is\n  /// invoked on another program unit.  For IP passes, it is more important to\n  /// free memory when it is unused.\n  ///\n  /// Optionally implement this function to release pass memory when it is no\n  /// longer used.\n  virtual void releaseMemory();\n\n  /// getAdjustedAnalysisPointer - This method is used when a pass implements\n  /// an analysis interface through multiple inheritance.  If needed, it should\n  /// override this to adjust the this pointer as needed for the specified pass\n  /// info.\n  virtual void *getAdjustedAnalysisPointer(AnalysisID ID);\n  virtual ImmutablePass *getAsImmutablePass();\n  virtual PMDataManager *getAsPMDataManager();\n\n  /// verifyAnalysis() - This member can be implemented by a analysis pass to\n  /// check state of analysis information.\n  virtual void verifyAnalysis() const;\n\n  // dumpPassStructure - Implement the -debug-passes=PassStructure option\n  virtual void dumpPassStructure(unsigned Offset = 0);\n\n  // lookupPassInfo - Return the pass info object for the specified pass class,\n  // or null if it is not known.\n  static const PassInfo *lookupPassInfo(const void *TI);\n\n  // lookupPassInfo - Return the pass info object for the pass with the given\n  // argument string, or null if it is not known.\n  static const PassInfo *lookupPassInfo(StringRef Arg);\n\n  // createPass - Create a object for the specified pass class,\n  // or null if it is not known.\n  static Pass *createPass(AnalysisID ID);\n\n  /// getAnalysisIfAvailable<AnalysisType>() - Subclasses use this function to\n  /// get analysis information that might be around, for example to update it.\n  /// This is different than getAnalysis in that it can fail (if the analysis\n  /// results haven't been computed), so should only be used if you can handle\n  /// the case when the analysis is not available.  This method is often used by\n  /// transformation APIs to update analysis results for a pass automatically as\n  /// the transform is performed.\n  template<typename AnalysisType> AnalysisType *\n    getAnalysisIfAvailable() const; // Defined in PassAnalysisSupport.h\n\n  /// mustPreserveAnalysisID - This method serves the same function as\n  /// getAnalysisIfAvailable, but works if you just have an AnalysisID.  This\n  /// obviously cannot give you a properly typed instance of the class if you\n  /// don't have the class name available (use getAnalysisIfAvailable if you\n  /// do), but it can tell you if you need to preserve the pass at least.\n  bool mustPreserveAnalysisID(char &AID) const;\n\n  /// getAnalysis<AnalysisType>() - This function is used by subclasses to get\n  /// to the analysis information that they claim to use by overriding the\n  /// getAnalysisUsage function.\n  template<typename AnalysisType>\n  AnalysisType &getAnalysis() const; // Defined in PassAnalysisSupport.h\n\n  template <typename AnalysisType>\n  AnalysisType &\n  getAnalysis(Function &F,\n              bool *Changed = nullptr); // Defined in PassAnalysisSupport.h\n\n  template<typename AnalysisType>\n  AnalysisType &getAnalysisID(AnalysisID PI) const;\n\n  template <typename AnalysisType>\n  AnalysisType &getAnalysisID(AnalysisID PI, Function &F,\n                              bool *Changed = nullptr);\n};\n\n//===----------------------------------------------------------------------===//\n/// ModulePass class - This class is used to implement unstructured\n/// interprocedural optimizations and analyses.  ModulePasses may do anything\n/// they want to the program.\n///\nclass ModulePass : public Pass {\npublic:\n  explicit ModulePass(char &pid) : Pass(PT_Module, pid) {}\n\n  // Force out-of-line virtual method.\n  ~ModulePass() override;\n\n  /// createPrinterPass - Get a module printer pass.\n  Pass *createPrinterPass(raw_ostream &OS,\n                          const std::string &Banner) const override;\n\n  /// runOnModule - Virtual method overriden by subclasses to process the module\n  /// being operated on.\n  virtual bool runOnModule(Module &M) = 0;\n\n  void assignPassManager(PMStack &PMS, PassManagerType T) override;\n\n  ///  Return what kind of Pass Manager can manage this pass.\n  PassManagerType getPotentialPassManagerType() const override;\n\nprotected:\n  /// Optional passes call this function to check whether the pass should be\n  /// skipped. This is the case when optimization bisect is over the limit.\n  bool skipModule(Module &M) const;\n};\n\n//===----------------------------------------------------------------------===//\n/// ImmutablePass class - This class is used to provide information that does\n/// not need to be run.  This is useful for things like target information and\n/// \"basic\" versions of AnalysisGroups.\n///\nclass ImmutablePass : public ModulePass {\npublic:\n  explicit ImmutablePass(char &pid) : ModulePass(pid) {}\n\n  // Force out-of-line virtual method.\n  ~ImmutablePass() override;\n\n  /// initializePass - This method may be overriden by immutable passes to allow\n  /// them to perform various initialization actions they require.  This is\n  /// primarily because an ImmutablePass can \"require\" another ImmutablePass,\n  /// and if it does, the overloaded version of initializePass may get access to\n  /// these passes with getAnalysis<>.\n  virtual void initializePass();\n\n  ImmutablePass *getAsImmutablePass() override { return this; }\n\n  /// ImmutablePasses are never run.\n  bool runOnModule(Module &) override { return false; }\n};\n\n//===----------------------------------------------------------------------===//\n/// FunctionPass class - This class is used to implement most global\n/// optimizations.  Optimizations should subclass this class if they meet the\n/// following constraints:\n///\n///  1. Optimizations are organized globally, i.e., a function at a time\n///  2. Optimizing a function does not cause the addition or removal of any\n///     functions in the module\n///\nclass FunctionPass : public Pass {\npublic:\n  explicit FunctionPass(char &pid) : Pass(PT_Function, pid) {}\n\n  /// createPrinterPass - Get a function printer pass.\n  Pass *createPrinterPass(raw_ostream &OS,\n                          const std::string &Banner) const override;\n\n  /// runOnFunction - Virtual method overriden by subclasses to do the\n  /// per-function processing of the pass.\n  virtual bool runOnFunction(Function &F) = 0;\n\n  void assignPassManager(PMStack &PMS, PassManagerType T) override;\n\n  ///  Return what kind of Pass Manager can manage this pass.\n  PassManagerType getPotentialPassManagerType() const override;\n\nprotected:\n  /// Optional passes call this function to check whether the pass should be\n  /// skipped. This is the case when Attribute::OptimizeNone is set or when\n  /// optimization bisect is over the limit.\n  bool skipFunction(const Function &F) const;\n};\n\n/// If the user specifies the -time-passes argument on an LLVM tool command line\n/// then the value of this boolean will be true, otherwise false.\n/// This is the storage for the -time-passes option.\nextern bool TimePassesIsEnabled;\n/// If TimePassesPerRun is true, there would be one line of report for\n/// each pass invocation.\n/// If TimePassesPerRun is false, there would be only one line of\n/// report for each pass (even there are more than one pass objects).\n/// (For new pass manager only)\nextern bool TimePassesPerRun;\n\n} // end namespace llvm\n\n// Include support files that contain important APIs commonly used by Passes,\n// but that we want to separate out to make it easier to read the header files.\n#include \"llvm/PassAnalysisSupport.h\"\n#include \"llvm/PassSupport.h\"\n\n#endif // LLVM_PASS_H\n"}, "60": {"id": 60, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/ARMTargetParser.h", "content": "//===-- ARMTargetParser - Parser for ARM target features --------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// This file implements a target parser to recognise ARM hardware features\n// such as FPU/CPU/ARCH/extensions and specific support such as HWDIV.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_SUPPORT_ARMTARGETPARSER_H\n#define LLVM_SUPPORT_ARMTARGETPARSER_H\n\n#include \"llvm/ADT/SmallVector.h\"\n#include \"llvm/ADT/StringRef.h\"\n#include \"llvm/Support/ARMBuildAttributes.h\"\n#include <vector>\n\nnamespace llvm {\n\nclass Triple;\n\nnamespace ARM {\n\n// Arch extension modifiers for CPUs.\n// Note that this is not the same as the AArch64 list\nenum ArchExtKind : uint64_t {\n  AEK_INVALID =     0,\n  AEK_NONE =        1,\n  AEK_CRC =         1 << 1,\n  AEK_CRYPTO =      1 << 2,\n  AEK_FP =          1 << 3,\n  AEK_HWDIVTHUMB =  1 << 4,\n  AEK_HWDIVARM =    1 << 5,\n  AEK_MP =          1 << 6,\n  AEK_SIMD =        1 << 7,\n  AEK_SEC =         1 << 8,\n  AEK_VIRT =        1 << 9,\n  AEK_DSP =         1 << 10,\n  AEK_FP16 =        1 << 11,\n  AEK_RAS =         1 << 12,\n  AEK_DOTPROD =     1 << 13,\n  AEK_SHA2    =     1 << 14,\n  AEK_AES     =     1 << 15,\n  AEK_FP16FML =     1 << 16,\n  AEK_SB      =     1 << 17,\n  AEK_FP_DP   =     1 << 18,\n  AEK_LOB     =     1 << 19,\n  AEK_BF16    =     1 << 20,\n  AEK_I8MM    =     1 << 21,\n  AEK_CDECP0 =      1 << 22,\n  AEK_CDECP1 =      1 << 23,\n  AEK_CDECP2 =      1 << 24,\n  AEK_CDECP3 =      1 << 25,\n  AEK_CDECP4 =      1 << 26,\n  AEK_CDECP5 =      1 << 27,\n  AEK_CDECP6 =      1 << 28,\n  AEK_CDECP7 =      1 << 29,\n\n  // Unsupported extensions.\n  AEK_OS       =    1ULL << 59,\n  AEK_IWMMXT   =    1ULL << 60,\n  AEK_IWMMXT2  =    1ULL << 61,\n  AEK_MAVERICK =    1ULL << 62,\n  AEK_XSCALE   =    1ULL << 63,\n};\n\n// List of Arch Extension names.\n// FIXME: TableGen this.\nstruct ExtName {\n  const char *NameCStr;\n  size_t NameLength;\n  uint64_t ID;\n  const char *Feature;\n  const char *NegFeature;\n\n  StringRef getName() const { return StringRef(NameCStr, NameLength); }\n};\n\nconst ExtName ARCHExtNames[] = {\n#define ARM_ARCH_EXT_NAME(NAME, ID, FEATURE, NEGFEATURE)                       \\\n  {NAME, sizeof(NAME) - 1, ID, FEATURE, NEGFEATURE},\n#include \"ARMTargetParser.def\"\n};\n\n// List of HWDiv names (use getHWDivSynonym) and which architectural\n// features they correspond to (use getHWDivFeatures).\n// FIXME: TableGen this.\nconst struct {\n  const char *NameCStr;\n  size_t NameLength;\n  uint64_t ID;\n\n  StringRef getName() const { return StringRef(NameCStr, NameLength); }\n} HWDivNames[] = {\n#define ARM_HW_DIV_NAME(NAME, ID) {NAME, sizeof(NAME) - 1, ID},\n#include \"ARMTargetParser.def\"\n};\n\n// Arch names.\nenum class ArchKind {\n#define ARM_ARCH(NAME, ID, CPU_ATTR, SUB_ARCH, ARCH_ATTR, ARCH_FPU, ARCH_BASE_EXT) ID,\n#include \"ARMTargetParser.def\"\n};\n\n// List of CPU names and their arches.\n// The same CPU can have multiple arches and can be default on multiple arches.\n// When finding the Arch for a CPU, first-found prevails. Sort them accordingly.\n// When this becomes table-generated, we'd probably need two tables.\n// FIXME: TableGen this.\ntemplate <typename T> struct CpuNames {\n  const char *NameCStr;\n  size_t NameLength;\n  T ArchID;\n  bool Default; // is $Name the default CPU for $ArchID ?\n  uint64_t DefaultExtensions;\n\n  StringRef getName() const { return StringRef(NameCStr, NameLength); }\n};\n\nconst CpuNames<ArchKind> CPUNames[] = {\n#define ARM_CPU_NAME(NAME, ID, DEFAULT_FPU, IS_DEFAULT, DEFAULT_EXT)           \\\n  {NAME, sizeof(NAME) - 1, ARM::ArchKind::ID, IS_DEFAULT, DEFAULT_EXT},\n#include \"ARMTargetParser.def\"\n};\n\n// FPU names.\nenum FPUKind {\n#define ARM_FPU(NAME, KIND, VERSION, NEON_SUPPORT, RESTRICTION) KIND,\n#include \"ARMTargetParser.def\"\n  FK_LAST\n};\n\n// FPU Version\nenum class FPUVersion {\n  NONE,\n  VFPV2,\n  VFPV3,\n  VFPV3_FP16,\n  VFPV4,\n  VFPV5,\n  VFPV5_FULLFP16,\n};\n\n// An FPU name restricts the FPU in one of three ways:\nenum class FPURestriction {\n  None = 0, ///< No restriction\n  D16,      ///< Only 16 D registers\n  SP_D16    ///< Only single-precision instructions, with 16 D registers\n};\n\n// An FPU name implies one of three levels of Neon support:\nenum class NeonSupportLevel {\n  None = 0, ///< No Neon\n  Neon,     ///< Neon\n  Crypto    ///< Neon with Crypto\n};\n\n// ISA kinds.\nenum class ISAKind { INVALID = 0, ARM, THUMB, AARCH64 };\n\n// Endianness\n// FIXME: BE8 vs. BE32?\nenum class EndianKind { INVALID = 0, LITTLE, BIG };\n\n// v6/v7/v8 Profile\nenum class ProfileKind { INVALID = 0, A, R, M };\n\n// List of canonical FPU names (use getFPUSynonym) and which architectural\n// features they correspond to (use getFPUFeatures).\n// FIXME: TableGen this.\n// The entries must appear in the order listed in ARM::FPUKind for correct\n// indexing\nstruct FPUName {\n  const char *NameCStr;\n  size_t NameLength;\n  FPUKind ID;\n  FPUVersion FPUVer;\n  NeonSupportLevel NeonSupport;\n  FPURestriction Restriction;\n\n  StringRef getName() const { return StringRef(NameCStr, NameLength); }\n};\n\nstatic const FPUName FPUNames[] = {\n#define ARM_FPU(NAME, KIND, VERSION, NEON_SUPPORT, RESTRICTION)                \\\n  {NAME, sizeof(NAME) - 1, KIND, VERSION, NEON_SUPPORT, RESTRICTION},\n#include \"llvm/Support/ARMTargetParser.def\"\n};\n\n// List of canonical arch names (use getArchSynonym).\n// This table also provides the build attribute fields for CPU arch\n// and Arch ID, according to the Addenda to the ARM ABI, chapters\n// 2.4 and 2.3.5.2 respectively.\n// FIXME: SubArch values were simplified to fit into the expectations\n// of the triples and are not conforming with their official names.\n// Check to see if the expectation should be changed.\n// FIXME: TableGen this.\ntemplate <typename T> struct ArchNames {\n  const char *NameCStr;\n  size_t NameLength;\n  const char *CPUAttrCStr;\n  size_t CPUAttrLength;\n  const char *SubArchCStr;\n  size_t SubArchLength;\n  unsigned DefaultFPU;\n  uint64_t ArchBaseExtensions;\n  T ID;\n  ARMBuildAttrs::CPUArch ArchAttr; // Arch ID in build attributes.\n\n  StringRef getName() const { return StringRef(NameCStr, NameLength); }\n\n  // CPU class in build attributes.\n  StringRef getCPUAttr() const { return StringRef(CPUAttrCStr, CPUAttrLength); }\n\n  // Sub-Arch name.\n  StringRef getSubArch() const { return StringRef(SubArchCStr, SubArchLength); }\n};\n\nstatic const ArchNames<ArchKind> ARCHNames[] = {\n#define ARM_ARCH(NAME, ID, CPU_ATTR, SUB_ARCH, ARCH_ATTR, ARCH_FPU,            \\\n                 ARCH_BASE_EXT)                                                \\\n  {NAME,         sizeof(NAME) - 1,                                             \\\n   CPU_ATTR,     sizeof(CPU_ATTR) - 1,                                         \\\n   SUB_ARCH,     sizeof(SUB_ARCH) - 1,                                         \\\n   ARCH_FPU,     ARCH_BASE_EXT,                                                \\\n   ArchKind::ID, ARCH_ATTR},\n#include \"llvm/Support/ARMTargetParser.def\"\n};\n\n// Information by ID\nStringRef getFPUName(unsigned FPUKind);\nFPUVersion getFPUVersion(unsigned FPUKind);\nNeonSupportLevel getFPUNeonSupportLevel(unsigned FPUKind);\nFPURestriction getFPURestriction(unsigned FPUKind);\n\n// FIXME: These should be moved to TargetTuple once it exists\nbool getFPUFeatures(unsigned FPUKind, std::vector<StringRef> &Features);\nbool getHWDivFeatures(uint64_t HWDivKind, std::vector<StringRef> &Features);\nbool getExtensionFeatures(uint64_t Extensions,\n                          std::vector<StringRef> &Features);\n\nStringRef getArchName(ArchKind AK);\nunsigned getArchAttr(ArchKind AK);\nStringRef getCPUAttr(ArchKind AK);\nStringRef getSubArch(ArchKind AK);\nStringRef getArchExtName(uint64_t ArchExtKind);\nStringRef getArchExtFeature(StringRef ArchExt);\nbool appendArchExtFeatures(StringRef CPU, ARM::ArchKind AK, StringRef ArchExt,\n                           std::vector<StringRef> &Features,\n                           unsigned &ArgFPUKind);\nStringRef getHWDivName(uint64_t HWDivKind);\n\n// Information by Name\nunsigned getDefaultFPU(StringRef CPU, ArchKind AK);\nuint64_t getDefaultExtensions(StringRef CPU, ArchKind AK);\nStringRef getDefaultCPU(StringRef Arch);\nStringRef getCanonicalArchName(StringRef Arch);\nStringRef getFPUSynonym(StringRef FPU);\nStringRef getArchSynonym(StringRef Arch);\n\n// Parser\nuint64_t parseHWDiv(StringRef HWDiv);\nunsigned parseFPU(StringRef FPU);\nArchKind parseArch(StringRef Arch);\nuint64_t parseArchExt(StringRef ArchExt);\nArchKind parseCPUArch(StringRef CPU);\nISAKind parseArchISA(StringRef Arch);\nEndianKind parseArchEndian(StringRef Arch);\nProfileKind parseArchProfile(StringRef Arch);\nunsigned parseArchVersion(StringRef Arch);\n\nvoid fillValidCPUArchList(SmallVectorImpl<StringRef> &Values);\nStringRef computeDefaultTargetABI(const Triple &TT, StringRef CPU);\n\n} // namespace ARM\n} // namespace llvm\n\n#endif\n"}, "64": {"id": 64, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/BranchProbability.h", "content": "//===- BranchProbability.h - Branch Probability Wrapper ---------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// Definition of BranchProbability shared by IR and Machine Instructions.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_SUPPORT_BRANCHPROBABILITY_H\n#define LLVM_SUPPORT_BRANCHPROBABILITY_H\n\n#include \"llvm/Support/DataTypes.h\"\n#include <algorithm>\n#include <cassert>\n#include <climits>\n#include <numeric>\n\nnamespace llvm {\n\nclass raw_ostream;\n\n// This class represents Branch Probability as a non-negative fraction that is\n// no greater than 1. It uses a fixed-point-like implementation, in which the\n// denominator is always a constant value (here we use 1<<31 for maximum\n// precision).\nclass BranchProbability {\n  // Numerator\n  uint32_t N;\n\n  // Denominator, which is a constant value.\n  static constexpr uint32_t D = 1u << 31;\n  static constexpr uint32_t UnknownN = UINT32_MAX;\n\n  // Construct a BranchProbability with only numerator assuming the denominator\n  // is 1<<31. For internal use only.\n  explicit BranchProbability(uint32_t n) : N(n) {}\n\npublic:\n  BranchProbability() : N(UnknownN) {}\n  BranchProbability(uint32_t Numerator, uint32_t Denominator);\n\n  bool isZero() const { return N == 0; }\n  bool isUnknown() const { return N == UnknownN; }\n\n  static BranchProbability getZero() { return BranchProbability(0); }\n  static BranchProbability getOne() { return BranchProbability(D); }\n  static BranchProbability getUnknown() { return BranchProbability(UnknownN); }\n  // Create a BranchProbability object with the given numerator and 1<<31\n  // as denominator.\n  static BranchProbability getRaw(uint32_t N) { return BranchProbability(N); }\n  // Create a BranchProbability object from 64-bit integers.\n  static BranchProbability getBranchProbability(uint64_t Numerator,\n                                                uint64_t Denominator);\n\n  // Normalize given probabilties so that the sum of them becomes approximate\n  // one.\n  template <class ProbabilityIter>\n  static void normalizeProbabilities(ProbabilityIter Begin,\n                                     ProbabilityIter End);\n\n  uint32_t getNumerator() const { return N; }\n  static uint32_t getDenominator() { return D; }\n\n  // Return (1 - Probability).\n  BranchProbability getCompl() const { return BranchProbability(D - N); }\n\n  raw_ostream &print(raw_ostream &OS) const;\n\n  void dump() const;\n\n  /// Scale a large integer.\n  ///\n  /// Scales \\c Num.  Guarantees full precision.  Returns the floor of the\n  /// result.\n  ///\n  /// \\return \\c Num times \\c this.\n  uint64_t scale(uint64_t Num) const;\n\n  /// Scale a large integer by the inverse.\n  ///\n  /// Scales \\c Num by the inverse of \\c this.  Guarantees full precision.\n  /// Returns the floor of the result.\n  ///\n  /// \\return \\c Num divided by \\c this.\n  uint64_t scaleByInverse(uint64_t Num) const;\n\n  BranchProbability &operator+=(BranchProbability RHS) {\n    assert(N != UnknownN && RHS.N != UnknownN &&\n           \"Unknown probability cannot participate in arithmetics.\");\n    // Saturate the result in case of overflow.\n    N = (uint64_t(N) + RHS.N > D) ? D : N + RHS.N;\n    return *this;\n  }\n\n  BranchProbability &operator-=(BranchProbability RHS) {\n    assert(N != UnknownN && RHS.N != UnknownN &&\n           \"Unknown probability cannot participate in arithmetics.\");\n    // Saturate the result in case of underflow.\n    N = N < RHS.N ? 0 : N - RHS.N;\n    return *this;\n  }\n\n  BranchProbability &operator*=(BranchProbability RHS) {\n    assert(N != UnknownN && RHS.N != UnknownN &&\n           \"Unknown probability cannot participate in arithmetics.\");\n    N = (static_cast<uint64_t>(N) * RHS.N + D / 2) / D;\n    return *this;\n  }\n\n  BranchProbability &operator*=(uint32_t RHS) {\n    assert(N != UnknownN &&\n           \"Unknown probability cannot participate in arithmetics.\");\n    N = (uint64_t(N) * RHS > D) ? D : N * RHS;\n    return *this;\n  }\n\n  BranchProbability &operator/=(BranchProbability RHS) {\n    assert(N != UnknownN && RHS.N != UnknownN &&\n           \"Unknown probability cannot participate in arithmetics.\");\n    N = (static_cast<uint64_t>(N) * D + RHS.N / 2) / RHS.N;\n    return *this;\n  }\n\n  BranchProbability &operator/=(uint32_t RHS) {\n    assert(N != UnknownN &&\n           \"Unknown probability cannot participate in arithmetics.\");\n    assert(RHS > 0 && \"The divider cannot be zero.\");\n    N /= RHS;\n    return *this;\n  }\n\n  BranchProbability operator+(BranchProbability RHS) const {\n    BranchProbability Prob(*this);\n    Prob += RHS;\n    return Prob;\n  }\n\n  BranchProbability operator-(BranchProbability RHS) const {\n    BranchProbability Prob(*this);\n    Prob -= RHS;\n    return Prob;\n  }\n\n  BranchProbability operator*(BranchProbability RHS) const {\n    BranchProbability Prob(*this);\n    Prob *= RHS;\n    return Prob;\n  }\n\n  BranchProbability operator*(uint32_t RHS) const {\n    BranchProbability Prob(*this);\n    Prob *= RHS;\n    return Prob;\n  }\n\n  BranchProbability operator/(BranchProbability RHS) const {\n    BranchProbability Prob(*this);\n    Prob /= RHS;\n    return Prob;\n  }\n\n  BranchProbability operator/(uint32_t RHS) const {\n    BranchProbability Prob(*this);\n    Prob /= RHS;\n    return Prob;\n  }\n\n  bool operator==(BranchProbability RHS) const { return N == RHS.N; }\n  bool operator!=(BranchProbability RHS) const { return !(*this == RHS); }\n\n  bool operator<(BranchProbability RHS) const {\n    assert(N != UnknownN && RHS.N != UnknownN &&\n           \"Unknown probability cannot participate in comparisons.\");\n    return N < RHS.N;\n  }\n\n  bool operator>(BranchProbability RHS) const {\n    assert(N != UnknownN && RHS.N != UnknownN &&\n           \"Unknown probability cannot participate in comparisons.\");\n    return RHS < *this;\n  }\n\n  bool operator<=(BranchProbability RHS) const {\n    assert(N != UnknownN && RHS.N != UnknownN &&\n           \"Unknown probability cannot participate in comparisons.\");\n    return !(RHS < *this);\n  }\n\n  bool operator>=(BranchProbability RHS) const {\n    assert(N != UnknownN && RHS.N != UnknownN &&\n           \"Unknown probability cannot participate in comparisons.\");\n    return !(*this < RHS);\n  }\n};\n\ninline raw_ostream &operator<<(raw_ostream &OS, BranchProbability Prob) {\n  return Prob.print(OS);\n}\n\ntemplate <class ProbabilityIter>\nvoid BranchProbability::normalizeProbabilities(ProbabilityIter Begin,\n                                               ProbabilityIter End) {\n  if (Begin == End)\n    return;\n\n  unsigned UnknownProbCount = 0;\n  uint64_t Sum = std::accumulate(Begin, End, uint64_t(0),\n                                 [&](uint64_t S, const BranchProbability &BP) {\n                                   if (!BP.isUnknown())\n                                     return S + BP.N;\n                                   UnknownProbCount++;\n                                   return S;\n                                 });\n\n  if (UnknownProbCount > 0) {\n    BranchProbability ProbForUnknown = BranchProbability::getZero();\n    // If the sum of all known probabilities is less than one, evenly distribute\n    // the complement of sum to unknown probabilities. Otherwise, set unknown\n    // probabilities to zeros and continue to normalize known probabilities.\n    if (Sum < BranchProbability::getDenominator())\n      ProbForUnknown = BranchProbability::getRaw(\n          (BranchProbability::getDenominator() - Sum) / UnknownProbCount);\n\n    std::replace_if(Begin, End,\n                    [](const BranchProbability &BP) { return BP.isUnknown(); },\n                    ProbForUnknown);\n\n    if (Sum <= BranchProbability::getDenominator())\n      return;\n  }\n\n  if (Sum == 0) {\n    BranchProbability BP(1, std::distance(Begin, End));\n    std::fill(Begin, End, BP);\n    return;\n  }\n\n  for (auto I = Begin; I != End; ++I)\n    I->N = (I->N * uint64_t(D) + Sum / 2) / Sum;\n}\n\n}\n\n#endif\n"}, "65": {"id": 65, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/CommandLine.h", "content": "//===- llvm/Support/CommandLine.h - Command line handler --------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// This class implements a command line argument processor that is useful when\n// creating a tool.  It provides a simple, minimalistic interface that is easily\n// extensible and supports nonlocal (library) command line options.\n//\n// Note that rather than trying to figure out what this code does, you should\n// read the library documentation located in docs/CommandLine.html or looks at\n// the many example usages in tools/*/*.cpp\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_SUPPORT_COMMANDLINE_H\n#define LLVM_SUPPORT_COMMANDLINE_H\n\n#include \"llvm/ADT/ArrayRef.h\"\n#include \"llvm/ADT/None.h\"\n#include \"llvm/ADT/Optional.h\"\n#include \"llvm/ADT/STLExtras.h\"\n#include \"llvm/ADT/SmallPtrSet.h\"\n#include \"llvm/ADT/SmallVector.h\"\n#include \"llvm/ADT/StringMap.h\"\n#include \"llvm/ADT/StringRef.h\"\n#include \"llvm/ADT/Twine.h\"\n#include \"llvm/ADT/iterator_range.h\"\n#include \"llvm/Support/ErrorHandling.h\"\n#include \"llvm/Support/ManagedStatic.h\"\n#include \"llvm/Support/VirtualFileSystem.h\"\n#include \"llvm/Support/raw_ostream.h\"\n#include <cassert>\n#include <climits>\n#include <cstddef>\n#include <functional>\n#include <initializer_list>\n#include <string>\n#include <type_traits>\n#include <vector>\n\nnamespace llvm {\n\nclass StringSaver;\n\n/// cl Namespace - This namespace contains all of the command line option\n/// processing machinery.  It is intentionally a short name to make qualified\n/// usage concise.\nnamespace cl {\n\n//===----------------------------------------------------------------------===//\n// ParseCommandLineOptions - Command line option processing entry point.\n//\n// Returns true on success. Otherwise, this will print the error message to\n// stderr and exit if \\p Errs is not set (nullptr by default), or print the\n// error message to \\p Errs and return false if \\p Errs is provided.\n//\n// If EnvVar is not nullptr, command-line options are also parsed from the\n// environment variable named by EnvVar.  Precedence is given to occurrences\n// from argv.  This precedence is currently implemented by parsing argv after\n// the environment variable, so it is only implemented correctly for options\n// that give precedence to later occurrences.  If your program supports options\n// that give precedence to earlier occurrences, you will need to extend this\n// function to support it correctly.\nbool ParseCommandLineOptions(int argc, const char *const *argv,\n                             StringRef Overview = \"\",\n                             raw_ostream *Errs = nullptr,\n                             const char *EnvVar = nullptr,\n                             bool LongOptionsUseDoubleDash = false);\n\n// Function pointer type for printing version information.\nusing VersionPrinterTy = std::function<void(raw_ostream &)>;\n\n///===---------------------------------------------------------------------===//\n/// SetVersionPrinter - Override the default (LLVM specific) version printer\n///                     used to print out the version when --version is given\n///                     on the command line. This allows other systems using the\n///                     CommandLine utilities to print their own version string.\nvoid SetVersionPrinter(VersionPrinterTy func);\n\n///===---------------------------------------------------------------------===//\n/// AddExtraVersionPrinter - Add an extra printer to use in addition to the\n///                          default one. This can be called multiple times,\n///                          and each time it adds a new function to the list\n///                          which will be called after the basic LLVM version\n///                          printing is complete. Each can then add additional\n///                          information specific to the tool.\nvoid AddExtraVersionPrinter(VersionPrinterTy func);\n\n// PrintOptionValues - Print option values.\n// With -print-options print the difference between option values and defaults.\n// With -print-all-options print all option values.\n// (Currently not perfect, but best-effort.)\nvoid PrintOptionValues();\n\n// Forward declaration - AddLiteralOption needs to be up here to make gcc happy.\nclass Option;\n\n/// Adds a new option for parsing and provides the option it refers to.\n///\n/// \\param O pointer to the option\n/// \\param Name the string name for the option to handle during parsing\n///\n/// Literal options are used by some parsers to register special option values.\n/// This is how the PassNameParser registers pass names for opt.\nvoid AddLiteralOption(Option &O, StringRef Name);\n\n//===----------------------------------------------------------------------===//\n// Flags permitted to be passed to command line arguments\n//\n\nenum NumOccurrencesFlag { // Flags for the number of occurrences allowed\n  Optional = 0x00,        // Zero or One occurrence\n  ZeroOrMore = 0x01,      // Zero or more occurrences allowed\n  Required = 0x02,        // One occurrence required\n  OneOrMore = 0x03,       // One or more occurrences required\n\n  // ConsumeAfter - Indicates that this option is fed anything that follows the\n  // last positional argument required by the application (it is an error if\n  // there are zero positional arguments, and a ConsumeAfter option is used).\n  // Thus, for example, all arguments to LLI are processed until a filename is\n  // found.  Once a filename is found, all of the succeeding arguments are\n  // passed, unprocessed, to the ConsumeAfter option.\n  //\n  ConsumeAfter = 0x04\n};\n\nenum ValueExpected { // Is a value required for the option?\n  // zero reserved for the unspecified value\n  ValueOptional = 0x01,  // The value can appear... or not\n  ValueRequired = 0x02,  // The value is required to appear!\n  ValueDisallowed = 0x03 // A value may not be specified (for flags)\n};\n\nenum OptionHidden {   // Control whether -help shows this option\n  NotHidden = 0x00,   // Option included in -help & -help-hidden\n  Hidden = 0x01,      // -help doesn't, but -help-hidden does\n  ReallyHidden = 0x02 // Neither -help nor -help-hidden show this arg\n};\n\n// Formatting flags - This controls special features that the option might have\n// that cause it to be parsed differently...\n//\n// Prefix - This option allows arguments that are otherwise unrecognized to be\n// matched by options that are a prefix of the actual value.  This is useful for\n// cases like a linker, where options are typically of the form '-lfoo' or\n// '-L../../include' where -l or -L are the actual flags.  When prefix is\n// enabled, and used, the value for the flag comes from the suffix of the\n// argument.\n//\n// AlwaysPrefix - Only allow the behavior enabled by the Prefix flag and reject\n// the Option=Value form.\n//\n\nenum FormattingFlags {\n  NormalFormatting = 0x00, // Nothing special\n  Positional = 0x01,       // Is a positional argument, no '-' required\n  Prefix = 0x02,           // Can this option directly prefix its value?\n  AlwaysPrefix = 0x03      // Can this option only directly prefix its value?\n};\n\nenum MiscFlags {             // Miscellaneous flags to adjust argument\n  CommaSeparated = 0x01,     // Should this cl::list split between commas?\n  PositionalEatsArgs = 0x02, // Should this positional cl::list eat -args?\n  Sink = 0x04,               // Should this cl::list eat all unknown options?\n\n  // Grouping - Can this option group with other options?\n  // If this is enabled, multiple letter options are allowed to bunch together\n  // with only a single hyphen for the whole group.  This allows emulation\n  // of the behavior that ls uses for example: ls -la === ls -l -a\n  Grouping = 0x08,\n\n  // Default option\n  DefaultOption = 0x10\n};\n\n//===----------------------------------------------------------------------===//\n// Option Category class\n//\nclass OptionCategory {\nprivate:\n  StringRef const Name;\n  StringRef const Description;\n\n  void registerCategory();\n\npublic:\n  OptionCategory(StringRef const Name,\n                 StringRef const Description = \"\")\n      : Name(Name), Description(Description) {\n    registerCategory();\n  }\n\n  StringRef getName() const { return Name; }\n  StringRef getDescription() const { return Description; }\n};\n\n// The general Option Category (used as default category).\nextern OptionCategory GeneralCategory;\n\n//===----------------------------------------------------------------------===//\n// SubCommand class\n//\nclass SubCommand {\nprivate:\n  StringRef Name;\n  StringRef Description;\n\nprotected:\n  void registerSubCommand();\n  void unregisterSubCommand();\n\npublic:\n  SubCommand(StringRef Name, StringRef Description = \"\")\n      : Name(Name), Description(Description) {\n        registerSubCommand();\n  }\n  SubCommand() = default;\n\n  void reset();\n\n  explicit operator bool() const;\n\n  StringRef getName() const { return Name; }\n  StringRef getDescription() const { return Description; }\n\n  SmallVector<Option *, 4> PositionalOpts;\n  SmallVector<Option *, 4> SinkOpts;\n  StringMap<Option *> OptionsMap;\n\n  Option *ConsumeAfterOpt = nullptr; // The ConsumeAfter option if it exists.\n};\n\n// A special subcommand representing no subcommand\nextern ManagedStatic<SubCommand> TopLevelSubCommand;\n\n// A special subcommand that can be used to put an option into all subcommands.\nextern ManagedStatic<SubCommand> AllSubCommands;\n\n//===----------------------------------------------------------------------===//\n// Option Base class\n//\nclass Option {\n  friend class alias;\n\n  // handleOccurrences - Overriden by subclasses to handle the value passed into\n  // an argument.  Should return true if there was an error processing the\n  // argument and the program should exit.\n  //\n  virtual bool handleOccurrence(unsigned pos, StringRef ArgName,\n                                StringRef Arg) = 0;\n\n  virtual enum ValueExpected getValueExpectedFlagDefault() const {\n    return ValueOptional;\n  }\n\n  // Out of line virtual function to provide home for the class.\n  virtual void anchor();\n\n  uint16_t NumOccurrences; // The number of times specified\n  // Occurrences, HiddenFlag, and Formatting are all enum types but to avoid\n  // problems with signed enums in bitfields.\n  uint16_t Occurrences : 3; // enum NumOccurrencesFlag\n  // not using the enum type for 'Value' because zero is an implementation\n  // detail representing the non-value\n  uint16_t Value : 2;\n  uint16_t HiddenFlag : 2; // enum OptionHidden\n  uint16_t Formatting : 2; // enum FormattingFlags\n  uint16_t Misc : 5;\n  uint16_t FullyInitialized : 1; // Has addArgument been called?\n  uint16_t Position;             // Position of last occurrence of the option\n  uint16_t AdditionalVals;       // Greater than 0 for multi-valued option.\n\npublic:\n  StringRef ArgStr;   // The argument string itself (ex: \"help\", \"o\")\n  StringRef HelpStr;  // The descriptive text message for -help\n  StringRef ValueStr; // String describing what the value of this option is\n  SmallVector<OptionCategory *, 1>\n      Categories;                    // The Categories this option belongs to\n  SmallPtrSet<SubCommand *, 1> Subs; // The subcommands this option belongs to.\n\n  inline enum NumOccurrencesFlag getNumOccurrencesFlag() const {\n    return (enum NumOccurrencesFlag)Occurrences;\n  }\n\n  inline enum ValueExpected getValueExpectedFlag() const {\n    return Value ? ((enum ValueExpected)Value) : getValueExpectedFlagDefault();\n  }\n\n  inline enum OptionHidden getOptionHiddenFlag() const {\n    return (enum OptionHidden)HiddenFlag;\n  }\n\n  inline enum FormattingFlags getFormattingFlag() const {\n    return (enum FormattingFlags)Formatting;\n  }\n\n  inline unsigned getMiscFlags() const { return Misc; }\n  inline unsigned getPosition() const { return Position; }\n  inline unsigned getNumAdditionalVals() const { return AdditionalVals; }\n\n  // hasArgStr - Return true if the argstr != \"\"\n  bool hasArgStr() const { return !ArgStr.empty(); }\n  bool isPositional() const { return getFormattingFlag() == cl::Positional; }\n  bool isSink() const { return getMiscFlags() & cl::Sink; }\n  bool isDefaultOption() const { return getMiscFlags() & cl::DefaultOption; }\n\n  bool isConsumeAfter() const {\n    return getNumOccurrencesFlag() == cl::ConsumeAfter;\n  }\n\n  bool isInAllSubCommands() const {\n    return any_of(Subs, [](const SubCommand *SC) {\n      return SC == &*AllSubCommands;\n    });\n  }\n\n  //-------------------------------------------------------------------------===\n  // Accessor functions set by OptionModifiers\n  //\n  void setArgStr(StringRef S);\n  void setDescription(StringRef S) { HelpStr = S; }\n  void setValueStr(StringRef S) { ValueStr = S; }\n  void setNumOccurrencesFlag(enum NumOccurrencesFlag Val) { Occurrences = Val; }\n  void setValueExpectedFlag(enum ValueExpected Val) { Value = Val; }\n  void setHiddenFlag(enum OptionHidden Val) { HiddenFlag = Val; }\n  void setFormattingFlag(enum FormattingFlags V) { Formatting = V; }\n  void setMiscFlag(enum MiscFlags M) { Misc |= M; }\n  void setPosition(unsigned pos) { Position = pos; }\n  void addCategory(OptionCategory &C);\n  void addSubCommand(SubCommand &S) { Subs.insert(&S); }\n\nprotected:\n  explicit Option(enum NumOccurrencesFlag OccurrencesFlag,\n                  enum OptionHidden Hidden)\n      : NumOccurrences(0), Occurrences(OccurrencesFlag), Value(0),\n        HiddenFlag(Hidden), Formatting(NormalFormatting), Misc(0),\n        FullyInitialized(false), Position(0), AdditionalVals(0) {\n    Categories.push_back(&GeneralCategory);\n  }\n\n  inline void setNumAdditionalVals(unsigned n) { AdditionalVals = n; }\n\npublic:\n  virtual ~Option() = default;\n\n  // addArgument - Register this argument with the commandline system.\n  //\n  void addArgument();\n\n  /// Unregisters this option from the CommandLine system.\n  ///\n  /// This option must have been the last option registered.\n  /// For testing purposes only.\n  void removeArgument();\n\n  // Return the width of the option tag for printing...\n  virtual size_t getOptionWidth() const = 0;\n\n  // printOptionInfo - Print out information about this option.  The\n  // to-be-maintained width is specified.\n  //\n  virtual void printOptionInfo(size_t GlobalWidth) const = 0;\n\n  virtual void printOptionValue(size_t GlobalWidth, bool Force) const = 0;\n\n  virtual void setDefault() = 0;\n\n  // Prints the help string for an option.\n  //\n  // This maintains the Indent for multi-line descriptions.\n  // FirstLineIndentedBy is the count of chars of the first line\n  //      i.e. the one containing the --<option name>.\n  static void printHelpStr(StringRef HelpStr, size_t Indent,\n                           size_t FirstLineIndentedBy);\n\n  // Prints the help string for an enum value.\n  //\n  // This maintains the Indent for multi-line descriptions.\n  // FirstLineIndentedBy is the count of chars of the first line\n  //      i.e. the one containing the =<value>.\n  static void printEnumValHelpStr(StringRef HelpStr, size_t Indent,\n                                  size_t FirstLineIndentedBy);\n\n  virtual void getExtraOptionNames(SmallVectorImpl<StringRef> &) {}\n\n  // addOccurrence - Wrapper around handleOccurrence that enforces Flags.\n  //\n  virtual bool addOccurrence(unsigned pos, StringRef ArgName, StringRef Value,\n                             bool MultiArg = false);\n\n  // Prints option name followed by message.  Always returns true.\n  bool error(const Twine &Message, StringRef ArgName = StringRef(), raw_ostream &Errs = llvm::errs());\n  bool error(const Twine &Message, raw_ostream &Errs) {\n    return error(Message, StringRef(), Errs);\n  }\n\n  inline int getNumOccurrences() const { return NumOccurrences; }\n  void reset();\n};\n\n//===----------------------------------------------------------------------===//\n// Command line option modifiers that can be used to modify the behavior of\n// command line option parsers...\n//\n\n// desc - Modifier to set the description shown in the -help output...\nstruct desc {\n  StringRef Desc;\n\n  desc(StringRef Str) : Desc(Str) {}\n\n  void apply(Option &O) const { O.setDescription(Desc); }\n};\n\n// value_desc - Modifier to set the value description shown in the -help\n// output...\nstruct value_desc {\n  StringRef Desc;\n\n  value_desc(StringRef Str) : Desc(Str) {}\n\n  void apply(Option &O) const { O.setValueStr(Desc); }\n};\n\n// init - Specify a default (initial) value for the command line argument, if\n// the default constructor for the argument type does not give you what you\n// want.  This is only valid on \"opt\" arguments, not on \"list\" arguments.\n//\ntemplate <class Ty> struct initializer {\n  const Ty &Init;\n  initializer(const Ty &Val) : Init(Val) {}\n\n  template <class Opt> void apply(Opt &O) const { O.setInitialValue(Init); }\n};\n\ntemplate <class Ty> initializer<Ty> init(const Ty &Val) {\n  return initializer<Ty>(Val);\n}\n\n// location - Allow the user to specify which external variable they want to\n// store the results of the command line argument processing into, if they don't\n// want to store it in the option itself.\n//\ntemplate <class Ty> struct LocationClass {\n  Ty &Loc;\n\n  LocationClass(Ty &L) : Loc(L) {}\n\n  template <class Opt> void apply(Opt &O) const { O.setLocation(O, Loc); }\n};\n\ntemplate <class Ty> LocationClass<Ty> location(Ty &L) {\n  return LocationClass<Ty>(L);\n}\n\n// cat - Specifiy the Option category for the command line argument to belong\n// to.\nstruct cat {\n  OptionCategory &Category;\n\n  cat(OptionCategory &c) : Category(c) {}\n\n  template <class Opt> void apply(Opt &O) const { O.addCategory(Category); }\n};\n\n// sub - Specify the subcommand that this option belongs to.\nstruct sub {\n  SubCommand &Sub;\n\n  sub(SubCommand &S) : Sub(S) {}\n\n  template <class Opt> void apply(Opt &O) const { O.addSubCommand(Sub); }\n};\n\n// Specify a callback function to be called when an option is seen.\n// Can be used to set other options automatically.\ntemplate <typename R, typename Ty> struct cb {\n  std::function<R(Ty)> CB;\n\n  cb(std::function<R(Ty)> CB) : CB(CB) {}\n\n  template <typename Opt> void apply(Opt &O) const { O.setCallback(CB); }\n};\n\nnamespace detail {\ntemplate <typename F>\nstruct callback_traits : public callback_traits<decltype(&F::operator())> {};\n\ntemplate <typename R, typename C, typename... Args>\nstruct callback_traits<R (C::*)(Args...) const> {\n  using result_type = R;\n  using arg_type = std::tuple_element_t<0, std::tuple<Args...>>;\n  static_assert(sizeof...(Args) == 1, \"callback function must have one and only one parameter\");\n  static_assert(std::is_same<result_type, void>::value,\n                \"callback return type must be void\");\n  static_assert(std::is_lvalue_reference<arg_type>::value &&\n                    std::is_const<std::remove_reference_t<arg_type>>::value,\n                \"callback arg_type must be a const lvalue reference\");\n};\n} // namespace detail\n\ntemplate <typename F>\ncb<typename detail::callback_traits<F>::result_type,\n   typename detail::callback_traits<F>::arg_type>\ncallback(F CB) {\n  using result_type = typename detail::callback_traits<F>::result_type;\n  using arg_type = typename detail::callback_traits<F>::arg_type;\n  return cb<result_type, arg_type>(CB);\n}\n\n//===----------------------------------------------------------------------===//\n// OptionValue class\n\n// Support value comparison outside the template.\nstruct GenericOptionValue {\n  virtual bool compare(const GenericOptionValue &V) const = 0;\n\nprotected:\n  GenericOptionValue() = default;\n  GenericOptionValue(const GenericOptionValue&) = default;\n  GenericOptionValue &operator=(const GenericOptionValue &) = default;\n  ~GenericOptionValue() = default;\n\nprivate:\n  virtual void anchor();\n};\n\ntemplate <class DataType> struct OptionValue;\n\n// The default value safely does nothing. Option value printing is only\n// best-effort.\ntemplate <class DataType, bool isClass>\nstruct OptionValueBase : public GenericOptionValue {\n  // Temporary storage for argument passing.\n  using WrapperType = OptionValue<DataType>;\n\n  bool hasValue() const { return false; }\n\n  const DataType &getValue() const { llvm_unreachable(\"no default value\"); }\n\n  // Some options may take their value from a different data type.\n  template <class DT> void setValue(const DT & /*V*/) {}\n\n  bool compare(const DataType & /*V*/) const { return false; }\n\n  bool compare(const GenericOptionValue & /*V*/) const override {\n    return false;\n  }\n\nprotected:\n  ~OptionValueBase() = default;\n};\n\n// Simple copy of the option value.\ntemplate <class DataType> class OptionValueCopy : public GenericOptionValue {\n  DataType Value;\n  bool Valid = false;\n\nprotected:\n  OptionValueCopy(const OptionValueCopy&) = default;\n  OptionValueCopy &operator=(const OptionValueCopy &) = default;\n  ~OptionValueCopy() = default;\n\npublic:\n  OptionValueCopy() = default;\n\n  bool hasValue() const { return Valid; }\n\n  const DataType &getValue() const {\n    assert(Valid && \"invalid option value\");\n    return Value;\n  }\n\n  void setValue(const DataType &V) {\n    Valid = true;\n    Value = V;\n  }\n\n  bool compare(const DataType &V) const { return Valid && (Value != V); }\n\n  bool compare(const GenericOptionValue &V) const override {\n    const OptionValueCopy<DataType> &VC =\n        static_cast<const OptionValueCopy<DataType> &>(V);\n    if (!VC.hasValue())\n      return false;\n    return compare(VC.getValue());\n  }\n};\n\n// Non-class option values.\ntemplate <class DataType>\nstruct OptionValueBase<DataType, false> : OptionValueCopy<DataType> {\n  using WrapperType = DataType;\n\nprotected:\n  OptionValueBase() = default;\n  OptionValueBase(const OptionValueBase&) = default;\n  OptionValueBase &operator=(const OptionValueBase &) = default;\n  ~OptionValueBase() = default;\n};\n\n// Top-level option class.\ntemplate <class DataType>\nstruct OptionValue final\n    : OptionValueBase<DataType, std::is_class<DataType>::value> {\n  OptionValue() = default;\n\n  OptionValue(const DataType &V) { this->setValue(V); }\n\n  // Some options may take their value from a different data type.\n  template <class DT> OptionValue<DataType> &operator=(const DT &V) {\n    this->setValue(V);\n    return *this;\n  }\n};\n\n// Other safe-to-copy-by-value common option types.\nenum boolOrDefault { BOU_UNSET, BOU_TRUE, BOU_FALSE };\ntemplate <>\nstruct OptionValue<cl::boolOrDefault> final\n    : OptionValueCopy<cl::boolOrDefault> {\n  using WrapperType = cl::boolOrDefault;\n\n  OptionValue() = default;\n\n  OptionValue(const cl::boolOrDefault &V) { this->setValue(V); }\n\n  OptionValue<cl::boolOrDefault> &operator=(const cl::boolOrDefault &V) {\n    setValue(V);\n    return *this;\n  }\n\nprivate:\n  void anchor() override;\n};\n\ntemplate <>\nstruct OptionValue<std::string> final : OptionValueCopy<std::string> {\n  using WrapperType = StringRef;\n\n  OptionValue() = default;\n\n  OptionValue(const std::string &V) { this->setValue(V); }\n\n  OptionValue<std::string> &operator=(const std::string &V) {\n    setValue(V);\n    return *this;\n  }\n\nprivate:\n  void anchor() override;\n};\n\n//===----------------------------------------------------------------------===//\n// Enum valued command line option\n//\n\n// This represents a single enum value, using \"int\" as the underlying type.\nstruct OptionEnumValue {\n  StringRef Name;\n  int Value;\n  StringRef Description;\n};\n\n#define clEnumVal(ENUMVAL, DESC)                                               \\\n  llvm::cl::OptionEnumValue { #ENUMVAL, int(ENUMVAL), DESC }\n#define clEnumValN(ENUMVAL, FLAGNAME, DESC)                                    \\\n  llvm::cl::OptionEnumValue { FLAGNAME, int(ENUMVAL), DESC }\n\n// values - For custom data types, allow specifying a group of values together\n// as the values that go into the mapping that the option handler uses.\n//\nclass ValuesClass {\n  // Use a vector instead of a map, because the lists should be short,\n  // the overhead is less, and most importantly, it keeps them in the order\n  // inserted so we can print our option out nicely.\n  SmallVector<OptionEnumValue, 4> Values;\n\npublic:\n  ValuesClass(std::initializer_list<OptionEnumValue> Options)\n      : Values(Options) {}\n\n  template <class Opt> void apply(Opt &O) const {\n    for (const auto &Value : Values)\n      O.getParser().addLiteralOption(Value.Name, Value.Value,\n                                     Value.Description);\n  }\n};\n\n/// Helper to build a ValuesClass by forwarding a variable number of arguments\n/// as an initializer list to the ValuesClass constructor.\ntemplate <typename... OptsTy> ValuesClass values(OptsTy... Options) {\n  return ValuesClass({Options...});\n}\n\n//===----------------------------------------------------------------------===//\n// parser class - Parameterizable parser for different data types.  By default,\n// known data types (string, int, bool) have specialized parsers, that do what\n// you would expect.  The default parser, used for data types that are not\n// built-in, uses a mapping table to map specific options to values, which is\n// used, among other things, to handle enum types.\n\n//--------------------------------------------------\n// generic_parser_base - This class holds all the non-generic code that we do\n// not need replicated for every instance of the generic parser.  This also\n// allows us to put stuff into CommandLine.cpp\n//\nclass generic_parser_base {\nprotected:\n  class GenericOptionInfo {\n  public:\n    GenericOptionInfo(StringRef name, StringRef helpStr)\n        : Name(name), HelpStr(helpStr) {}\n    StringRef Name;\n    StringRef HelpStr;\n  };\n\npublic:\n  generic_parser_base(Option &O) : Owner(O) {}\n\n  virtual ~generic_parser_base() = default;\n  // Base class should have virtual-destructor\n\n  // getNumOptions - Virtual function implemented by generic subclass to\n  // indicate how many entries are in Values.\n  //\n  virtual unsigned getNumOptions() const = 0;\n\n  // getOption - Return option name N.\n  virtual StringRef getOption(unsigned N) const = 0;\n\n  // getDescription - Return description N\n  virtual StringRef getDescription(unsigned N) const = 0;\n\n  // Return the width of the option tag for printing...\n  virtual size_t getOptionWidth(const Option &O) const;\n\n  virtual const GenericOptionValue &getOptionValue(unsigned N) const = 0;\n\n  // printOptionInfo - Print out information about this option.  The\n  // to-be-maintained width is specified.\n  //\n  virtual void printOptionInfo(const Option &O, size_t GlobalWidth) const;\n\n  void printGenericOptionDiff(const Option &O, const GenericOptionValue &V,\n                              const GenericOptionValue &Default,\n                              size_t GlobalWidth) const;\n\n  // printOptionDiff - print the value of an option and it's default.\n  //\n  // Template definition ensures that the option and default have the same\n  // DataType (via the same AnyOptionValue).\n  template <class AnyOptionValue>\n  void printOptionDiff(const Option &O, const AnyOptionValue &V,\n                       const AnyOptionValue &Default,\n                       size_t GlobalWidth) const {\n    printGenericOptionDiff(O, V, Default, GlobalWidth);\n  }\n\n  void initialize() {}\n\n  void getExtraOptionNames(SmallVectorImpl<StringRef> &OptionNames) {\n    // If there has been no argstr specified, that means that we need to add an\n    // argument for every possible option.  This ensures that our options are\n    // vectored to us.\n    if (!Owner.hasArgStr())\n      for (unsigned i = 0, e = getNumOptions(); i != e; ++i)\n        OptionNames.push_back(getOption(i));\n  }\n\n  enum ValueExpected getValueExpectedFlagDefault() const {\n    // If there is an ArgStr specified, then we are of the form:\n    //\n    //    -opt=O2   or   -opt O2  or  -optO2\n    //\n    // In which case, the value is required.  Otherwise if an arg str has not\n    // been specified, we are of the form:\n    //\n    //    -O2 or O2 or -la (where -l and -a are separate options)\n    //\n    // If this is the case, we cannot allow a value.\n    //\n    if (Owner.hasArgStr())\n      return ValueRequired;\n    else\n      return ValueDisallowed;\n  }\n\n  // findOption - Return the option number corresponding to the specified\n  // argument string.  If the option is not found, getNumOptions() is returned.\n  //\n  unsigned findOption(StringRef Name);\n\nprotected:\n  Option &Owner;\n};\n\n// Default parser implementation - This implementation depends on having a\n// mapping of recognized options to values of some sort.  In addition to this,\n// each entry in the mapping also tracks a help message that is printed with the\n// command line option for -help.  Because this is a simple mapping parser, the\n// data type can be any unsupported type.\n//\ntemplate <class DataType> class parser : public generic_parser_base {\nprotected:\n  class OptionInfo : public GenericOptionInfo {\n  public:\n    OptionInfo(StringRef name, DataType v, StringRef helpStr)\n        : GenericOptionInfo(name, helpStr), V(v) {}\n\n    OptionValue<DataType> V;\n  };\n  SmallVector<OptionInfo, 8> Values;\n\npublic:\n  parser(Option &O) : generic_parser_base(O) {}\n\n  using parser_data_type = DataType;\n\n  // Implement virtual functions needed by generic_parser_base\n  unsigned getNumOptions() const override { return unsigned(Values.size()); }\n  StringRef getOption(unsigned N) const override { return Values[N].Name; }\n  StringRef getDescription(unsigned N) const override {\n    return Values[N].HelpStr;\n  }\n\n  // getOptionValue - Return the value of option name N.\n  const GenericOptionValue &getOptionValue(unsigned N) const override {\n    return Values[N].V;\n  }\n\n  // parse - Return true on error.\n  bool parse(Option &O, StringRef ArgName, StringRef Arg, DataType &V) {\n    StringRef ArgVal;\n    if (Owner.hasArgStr())\n      ArgVal = Arg;\n    else\n      ArgVal = ArgName;\n\n    for (size_t i = 0, e = Values.size(); i != e; ++i)\n      if (Values[i].Name == ArgVal) {\n        V = Values[i].V.getValue();\n        return false;\n      }\n\n    return O.error(\"Cannot find option named '\" + ArgVal + \"'!\");\n  }\n\n  /// addLiteralOption - Add an entry to the mapping table.\n  ///\n  template <class DT>\n  void addLiteralOption(StringRef Name, const DT &V, StringRef HelpStr) {\n    assert(findOption(Name) == Values.size() && \"Option already exists!\");\n    OptionInfo X(Name, static_cast<DataType>(V), HelpStr);\n    Values.push_back(X);\n    AddLiteralOption(Owner, Name);\n  }\n\n  /// removeLiteralOption - Remove the specified option.\n  ///\n  void removeLiteralOption(StringRef Name) {\n    unsigned N = findOption(Name);\n    assert(N != Values.size() && \"Option not found!\");\n    Values.erase(Values.begin() + N);\n  }\n};\n\n//--------------------------------------------------\n// basic_parser - Super class of parsers to provide boilerplate code\n//\nclass basic_parser_impl { // non-template implementation of basic_parser<t>\npublic:\n  basic_parser_impl(Option &) {}\n\n  virtual ~basic_parser_impl() {}\n\n  enum ValueExpected getValueExpectedFlagDefault() const {\n    return ValueRequired;\n  }\n\n  void getExtraOptionNames(SmallVectorImpl<StringRef> &) {}\n\n  void initialize() {}\n\n  // Return the width of the option tag for printing...\n  size_t getOptionWidth(const Option &O) const;\n\n  // printOptionInfo - Print out information about this option.  The\n  // to-be-maintained width is specified.\n  //\n  void printOptionInfo(const Option &O, size_t GlobalWidth) const;\n\n  // printOptionNoValue - Print a placeholder for options that don't yet support\n  // printOptionDiff().\n  void printOptionNoValue(const Option &O, size_t GlobalWidth) const;\n\n  // getValueName - Overload in subclass to provide a better default value.\n  virtual StringRef getValueName() const { return \"value\"; }\n\n  // An out-of-line virtual method to provide a 'home' for this class.\n  virtual void anchor();\n\nprotected:\n  // A helper for basic_parser::printOptionDiff.\n  void printOptionName(const Option &O, size_t GlobalWidth) const;\n};\n\n// basic_parser - The real basic parser is just a template wrapper that provides\n// a typedef for the provided data type.\n//\ntemplate <class DataType> class basic_parser : public basic_parser_impl {\npublic:\n  using parser_data_type = DataType;\n  using OptVal = OptionValue<DataType>;\n\n  basic_parser(Option &O) : basic_parser_impl(O) {}\n};\n\n//--------------------------------------------------\n// parser<bool>\n//\ntemplate <> class parser<bool> : public basic_parser<bool> {\npublic:\n  parser(Option &O) : basic_parser(O) {}\n\n  // parse - Return true on error.\n  bool parse(Option &O, StringRef ArgName, StringRef Arg, bool &Val);\n\n  void initialize() {}\n\n  enum ValueExpected getValueExpectedFlagDefault() const {\n    return ValueOptional;\n  }\n\n  // getValueName - Do not print =<value> at all.\n  StringRef getValueName() const override { return StringRef(); }\n\n  void printOptionDiff(const Option &O, bool V, OptVal Default,\n                       size_t GlobalWidth) const;\n\n  // An out-of-line virtual method to provide a 'home' for this class.\n  void anchor() override;\n};\n\nextern template class basic_parser<bool>;\n\n//--------------------------------------------------\n// parser<boolOrDefault>\ntemplate <> class parser<boolOrDefault> : public basic_parser<boolOrDefault> {\npublic:\n  parser(Option &O) : basic_parser(O) {}\n\n  // parse - Return true on error.\n  bool parse(Option &O, StringRef ArgName, StringRef Arg, boolOrDefault &Val);\n\n  enum ValueExpected getValueExpectedFlagDefault() const {\n    return ValueOptional;\n  }\n\n  // getValueName - Do not print =<value> at all.\n  StringRef getValueName() const override { return StringRef(); }\n\n  void printOptionDiff(const Option &O, boolOrDefault V, OptVal Default,\n                       size_t GlobalWidth) const;\n\n  // An out-of-line virtual method to provide a 'home' for this class.\n  void anchor() override;\n};\n\nextern template class basic_parser<boolOrDefault>;\n\n//--------------------------------------------------\n// parser<int>\n//\ntemplate <> class parser<int> : public basic_parser<int> {\npublic:\n  parser(Option &O) : basic_parser(O) {}\n\n  // parse - Return true on error.\n  bool parse(Option &O, StringRef ArgName, StringRef Arg, int &Val);\n\n  // getValueName - Overload in subclass to provide a better default value.\n  StringRef getValueName() const override { return \"int\"; }\n\n  void printOptionDiff(const Option &O, int V, OptVal Default,\n                       size_t GlobalWidth) const;\n\n  // An out-of-line virtual method to provide a 'home' for this class.\n  void anchor() override;\n};\n\nextern template class basic_parser<int>;\n\n//--------------------------------------------------\n// parser<long>\n//\ntemplate <> class parser<long> final : public basic_parser<long> {\npublic:\n  parser(Option &O) : basic_parser(O) {}\n\n  // parse - Return true on error.\n  bool parse(Option &O, StringRef ArgName, StringRef Arg, long &Val);\n\n  // getValueName - Overload in subclass to provide a better default value.\n  StringRef getValueName() const override { return \"long\"; }\n\n  void printOptionDiff(const Option &O, long V, OptVal Default,\n                       size_t GlobalWidth) const;\n\n  // An out-of-line virtual method to provide a 'home' for this class.\n  void anchor() override;\n};\n\nextern template class basic_parser<long>;\n\n//--------------------------------------------------\n// parser<long long>\n//\ntemplate <> class parser<long long> : public basic_parser<long long> {\npublic:\n  parser(Option &O) : basic_parser(O) {}\n\n  // parse - Return true on error.\n  bool parse(Option &O, StringRef ArgName, StringRef Arg, long long &Val);\n\n  // getValueName - Overload in subclass to provide a better default value.\n  StringRef getValueName() const override { return \"long\"; }\n\n  void printOptionDiff(const Option &O, long long V, OptVal Default,\n                       size_t GlobalWidth) const;\n\n  // An out-of-line virtual method to provide a 'home' for this class.\n  void anchor() override;\n};\n\nextern template class basic_parser<long long>;\n\n//--------------------------------------------------\n// parser<unsigned>\n//\ntemplate <> class parser<unsigned> : public basic_parser<unsigned> {\npublic:\n  parser(Option &O) : basic_parser(O) {}\n\n  // parse - Return true on error.\n  bool parse(Option &O, StringRef ArgName, StringRef Arg, unsigned &Val);\n\n  // getValueName - Overload in subclass to provide a better default value.\n  StringRef getValueName() const override { return \"uint\"; }\n\n  void printOptionDiff(const Option &O, unsigned V, OptVal Default,\n                       size_t GlobalWidth) const;\n\n  // An out-of-line virtual method to provide a 'home' for this class.\n  void anchor() override;\n};\n\nextern template class basic_parser<unsigned>;\n\n//--------------------------------------------------\n// parser<unsigned long>\n//\ntemplate <>\nclass parser<unsigned long> final : public basic_parser<unsigned long> {\npublic:\n  parser(Option &O) : basic_parser(O) {}\n\n  // parse - Return true on error.\n  bool parse(Option &O, StringRef ArgName, StringRef Arg, unsigned long &Val);\n\n  // getValueName - Overload in subclass to provide a better default value.\n  StringRef getValueName() const override { return \"ulong\"; }\n\n  void printOptionDiff(const Option &O, unsigned long V, OptVal Default,\n                       size_t GlobalWidth) const;\n\n  // An out-of-line virtual method to provide a 'home' for this class.\n  void anchor() override;\n};\n\nextern template class basic_parser<unsigned long>;\n\n//--------------------------------------------------\n// parser<unsigned long long>\n//\ntemplate <>\nclass parser<unsigned long long> : public basic_parser<unsigned long long> {\npublic:\n  parser(Option &O) : basic_parser(O) {}\n\n  // parse - Return true on error.\n  bool parse(Option &O, StringRef ArgName, StringRef Arg,\n             unsigned long long &Val);\n\n  // getValueName - Overload in subclass to provide a better default value.\n  StringRef getValueName() const override { return \"ulong\"; }\n\n  void printOptionDiff(const Option &O, unsigned long long V, OptVal Default,\n                       size_t GlobalWidth) const;\n\n  // An out-of-line virtual method to provide a 'home' for this class.\n  void anchor() override;\n};\n\nextern template class basic_parser<unsigned long long>;\n\n//--------------------------------------------------\n// parser<double>\n//\ntemplate <> class parser<double> : public basic_parser<double> {\npublic:\n  parser(Option &O) : basic_parser(O) {}\n\n  // parse - Return true on error.\n  bool parse(Option &O, StringRef ArgName, StringRef Arg, double &Val);\n\n  // getValueName - Overload in subclass to provide a better default value.\n  StringRef getValueName() const override { return \"number\"; }\n\n  void printOptionDiff(const Option &O, double V, OptVal Default,\n                       size_t GlobalWidth) const;\n\n  // An out-of-line virtual method to provide a 'home' for this class.\n  void anchor() override;\n};\n\nextern template class basic_parser<double>;\n\n//--------------------------------------------------\n// parser<float>\n//\ntemplate <> class parser<float> : public basic_parser<float> {\npublic:\n  parser(Option &O) : basic_parser(O) {}\n\n  // parse - Return true on error.\n  bool parse(Option &O, StringRef ArgName, StringRef Arg, float &Val);\n\n  // getValueName - Overload in subclass to provide a better default value.\n  StringRef getValueName() const override { return \"number\"; }\n\n  void printOptionDiff(const Option &O, float V, OptVal Default,\n                       size_t GlobalWidth) const;\n\n  // An out-of-line virtual method to provide a 'home' for this class.\n  void anchor() override;\n};\n\nextern template class basic_parser<float>;\n\n//--------------------------------------------------\n// parser<std::string>\n//\ntemplate <> class parser<std::string> : public basic_parser<std::string> {\npublic:\n  parser(Option &O) : basic_parser(O) {}\n\n  // parse - Return true on error.\n  bool parse(Option &, StringRef, StringRef Arg, std::string &Value) {\n    Value = Arg.str();\n    return false;\n  }\n\n  // getValueName - Overload in subclass to provide a better default value.\n  StringRef getValueName() const override { return \"string\"; }\n\n  void printOptionDiff(const Option &O, StringRef V, const OptVal &Default,\n                       size_t GlobalWidth) const;\n\n  // An out-of-line virtual method to provide a 'home' for this class.\n  void anchor() override;\n};\n\nextern template class basic_parser<std::string>;\n\n//--------------------------------------------------\n// parser<char>\n//\ntemplate <> class parser<char> : public basic_parser<char> {\npublic:\n  parser(Option &O) : basic_parser(O) {}\n\n  // parse - Return true on error.\n  bool parse(Option &, StringRef, StringRef Arg, char &Value) {\n    Value = Arg[0];\n    return false;\n  }\n\n  // getValueName - Overload in subclass to provide a better default value.\n  StringRef getValueName() const override { return \"char\"; }\n\n  void printOptionDiff(const Option &O, char V, OptVal Default,\n                       size_t GlobalWidth) const;\n\n  // An out-of-line virtual method to provide a 'home' for this class.\n  void anchor() override;\n};\n\nextern template class basic_parser<char>;\n\n//--------------------------------------------------\n// PrintOptionDiff\n//\n// This collection of wrappers is the intermediary between class opt and class\n// parser to handle all the template nastiness.\n\n// This overloaded function is selected by the generic parser.\ntemplate <class ParserClass, class DT>\nvoid printOptionDiff(const Option &O, const generic_parser_base &P, const DT &V,\n                     const OptionValue<DT> &Default, size_t GlobalWidth) {\n  OptionValue<DT> OV = V;\n  P.printOptionDiff(O, OV, Default, GlobalWidth);\n}\n\n// This is instantiated for basic parsers when the parsed value has a different\n// type than the option value. e.g. HelpPrinter.\ntemplate <class ParserDT, class ValDT> struct OptionDiffPrinter {\n  void print(const Option &O, const parser<ParserDT> &P, const ValDT & /*V*/,\n             const OptionValue<ValDT> & /*Default*/, size_t GlobalWidth) {\n    P.printOptionNoValue(O, GlobalWidth);\n  }\n};\n\n// This is instantiated for basic parsers when the parsed value has the same\n// type as the option value.\ntemplate <class DT> struct OptionDiffPrinter<DT, DT> {\n  void print(const Option &O, const parser<DT> &P, const DT &V,\n             const OptionValue<DT> &Default, size_t GlobalWidth) {\n    P.printOptionDiff(O, V, Default, GlobalWidth);\n  }\n};\n\n// This overloaded function is selected by the basic parser, which may parse a\n// different type than the option type.\ntemplate <class ParserClass, class ValDT>\nvoid printOptionDiff(\n    const Option &O,\n    const basic_parser<typename ParserClass::parser_data_type> &P,\n    const ValDT &V, const OptionValue<ValDT> &Default, size_t GlobalWidth) {\n\n  OptionDiffPrinter<typename ParserClass::parser_data_type, ValDT> printer;\n  printer.print(O, static_cast<const ParserClass &>(P), V, Default,\n                GlobalWidth);\n}\n\n//===----------------------------------------------------------------------===//\n// applicator class - This class is used because we must use partial\n// specialization to handle literal string arguments specially (const char* does\n// not correctly respond to the apply method).  Because the syntax to use this\n// is a pain, we have the 'apply' method below to handle the nastiness...\n//\ntemplate <class Mod> struct applicator {\n  template <class Opt> static void opt(const Mod &M, Opt &O) { M.apply(O); }\n};\n\n// Handle const char* as a special case...\ntemplate <unsigned n> struct applicator<char[n]> {\n  template <class Opt> static void opt(StringRef Str, Opt &O) {\n    O.setArgStr(Str);\n  }\n};\ntemplate <unsigned n> struct applicator<const char[n]> {\n  template <class Opt> static void opt(StringRef Str, Opt &O) {\n    O.setArgStr(Str);\n  }\n};\ntemplate <> struct applicator<StringRef > {\n  template <class Opt> static void opt(StringRef Str, Opt &O) {\n    O.setArgStr(Str);\n  }\n};\n\ntemplate <> struct applicator<NumOccurrencesFlag> {\n  static void opt(NumOccurrencesFlag N, Option &O) {\n    O.setNumOccurrencesFlag(N);\n  }\n};\n\ntemplate <> struct applicator<ValueExpected> {\n  static void opt(ValueExpected VE, Option &O) { O.setValueExpectedFlag(VE); }\n};\n\ntemplate <> struct applicator<OptionHidden> {\n  static void opt(OptionHidden OH, Option &O) { O.setHiddenFlag(OH); }\n};\n\ntemplate <> struct applicator<FormattingFlags> {\n  static void opt(FormattingFlags FF, Option &O) { O.setFormattingFlag(FF); }\n};\n\ntemplate <> struct applicator<MiscFlags> {\n  static void opt(MiscFlags MF, Option &O) {\n    assert((MF != Grouping || O.ArgStr.size() == 1) &&\n           \"cl::Grouping can only apply to single charater Options.\");\n    O.setMiscFlag(MF);\n  }\n};\n\n// apply method - Apply modifiers to an option in a type safe way.\ntemplate <class Opt, class Mod, class... Mods>\nvoid apply(Opt *O, const Mod &M, const Mods &... Ms) {\n  applicator<Mod>::opt(M, *O);\n  apply(O, Ms...);\n}\n\ntemplate <class Opt, class Mod> void apply(Opt *O, const Mod &M) {\n  applicator<Mod>::opt(M, *O);\n}\n\n//===----------------------------------------------------------------------===//\n// opt_storage class\n\n// Default storage class definition: external storage.  This implementation\n// assumes the user will specify a variable to store the data into with the\n// cl::location(x) modifier.\n//\ntemplate <class DataType, bool ExternalStorage, bool isClass>\nclass opt_storage {\n  DataType *Location = nullptr; // Where to store the object...\n  OptionValue<DataType> Default;\n\n  void check_location() const {\n    assert(Location && \"cl::location(...) not specified for a command \"\n                       \"line option with external storage, \"\n                       \"or cl::init specified before cl::location()!!\");\n  }\n\npublic:\n  opt_storage() = default;\n\n  bool setLocation(Option &O, DataType &L) {\n    if (Location)\n      return O.error(\"cl::location(x) specified more than once!\");\n    Location = &L;\n    Default = L;\n    return false;\n  }\n\n  template <class T> void setValue(const T &V, bool initial = false) {\n    check_location();\n    *Location = V;\n    if (initial)\n      Default = V;\n  }\n\n  DataType &getValue() {\n    check_location();\n    return *Location;\n  }\n  const DataType &getValue() const {\n    check_location();\n    return *Location;\n  }\n\n  operator DataType() const { return this->getValue(); }\n\n  const OptionValue<DataType> &getDefault() const { return Default; }\n};\n\n// Define how to hold a class type object, such as a string.  Since we can\n// inherit from a class, we do so.  This makes us exactly compatible with the\n// object in all cases that it is used.\n//\ntemplate <class DataType>\nclass opt_storage<DataType, false, true> : public DataType {\npublic:\n  OptionValue<DataType> Default;\n\n  template <class T> void setValue(const T &V, bool initial = false) {\n    DataType::operator=(V);\n    if (initial)\n      Default = V;\n  }\n\n  DataType &getValue() { return *this; }\n  const DataType &getValue() const { return *this; }\n\n  const OptionValue<DataType> &getDefault() const { return Default; }\n};\n\n// Define a partial specialization to handle things we cannot inherit from.  In\n// this case, we store an instance through containment, and overload operators\n// to get at the value.\n//\ntemplate <class DataType> class opt_storage<DataType, false, false> {\npublic:\n  DataType Value;\n  OptionValue<DataType> Default;\n\n  // Make sure we initialize the value with the default constructor for the\n  // type.\n  opt_storage() : Value(DataType()), Default(DataType()) {}\n\n  template <class T> void setValue(const T &V, bool initial = false) {\n    Value = V;\n    if (initial)\n      Default = V;\n  }\n  DataType &getValue() { return Value; }\n  DataType getValue() const { return Value; }\n\n  const OptionValue<DataType> &getDefault() const { return Default; }\n\n  operator DataType() const { return getValue(); }\n\n  // If the datatype is a pointer, support -> on it.\n  DataType operator->() const { return Value; }\n};\n\n//===----------------------------------------------------------------------===//\n// opt - A scalar command line option.\n//\ntemplate <class DataType, bool ExternalStorage = false,\n          class ParserClass = parser<DataType>>\nclass opt : public Option,\n            public opt_storage<DataType, ExternalStorage,\n                               std::is_class<DataType>::value> {\n  ParserClass Parser;\n\n  bool handleOccurrence(unsigned pos, StringRef ArgName,\n                        StringRef Arg) override {\n    typename ParserClass::parser_data_type Val =\n        typename ParserClass::parser_data_type();\n    if (Parser.parse(*this, ArgName, Arg, Val))\n      return true; // Parse error!\n    this->setValue(Val);\n    this->setPosition(pos);\n    Callback(Val);\n    return false;\n  }\n\n  enum ValueExpected getValueExpectedFlagDefault() const override {\n    return Parser.getValueExpectedFlagDefault();\n  }\n\n  void getExtraOptionNames(SmallVectorImpl<StringRef> &OptionNames) override {\n    return Parser.getExtraOptionNames(OptionNames);\n  }\n\n  // Forward printing stuff to the parser...\n  size_t getOptionWidth() const override {\n    return Parser.getOptionWidth(*this);\n  }\n\n  void printOptionInfo(size_t GlobalWidth) const override {\n    Parser.printOptionInfo(*this, GlobalWidth);\n  }\n\n  void printOptionValue(size_t GlobalWidth, bool Force) const override {\n    if (Force || this->getDefault().compare(this->getValue())) {\n      cl::printOptionDiff<ParserClass>(*this, Parser, this->getValue(),\n                                       this->getDefault(), GlobalWidth);\n    }\n  }\n\n  template <class T,\n            class = std::enable_if_t<std::is_assignable<T &, T>::value>>\n  void setDefaultImpl() {\n    const OptionValue<DataType> &V = this->getDefault();\n    if (V.hasValue())\n      this->setValue(V.getValue());\n  }\n\n  template <class T,\n            class = std::enable_if_t<!std::is_assignable<T &, T>::value>>\n  void setDefaultImpl(...) {}\n\n  void setDefault() override { setDefaultImpl<DataType>(); }\n\n  void done() {\n    addArgument();\n    Parser.initialize();\n  }\n\npublic:\n  // Command line options should not be copyable\n  opt(const opt &) = delete;\n  opt &operator=(const opt &) = delete;\n\n  // setInitialValue - Used by the cl::init modifier...\n  void setInitialValue(const DataType &V) { this->setValue(V, true); }\n\n  ParserClass &getParser() { return Parser; }\n\n  template <class T> DataType &operator=(const T &Val) {\n    this->setValue(Val);\n    Callback(Val);\n    return this->getValue();\n  }\n\n  template <class... Mods>\n  explicit opt(const Mods &... Ms)\n      : Option(llvm::cl::Optional, NotHidden), Parser(*this) {\n    apply(this, Ms...);\n    done();\n  }\n\n  void setCallback(\n      std::function<void(const typename ParserClass::parser_data_type &)> CB) {\n    Callback = CB;\n  }\n\n  std::function<void(const typename ParserClass::parser_data_type &)> Callback =\n      [](const typename ParserClass::parser_data_type &) {};\n};\n\nextern template class opt<unsigned>;\nextern template class opt<int>;\nextern template class opt<std::string>;\nextern template class opt<char>;\nextern template class opt<bool>;\n\n//===----------------------------------------------------------------------===//\n// list_storage class\n\n// Default storage class definition: external storage.  This implementation\n// assumes the user will specify a variable to store the data into with the\n// cl::location(x) modifier.\n//\ntemplate <class DataType, class StorageClass> class list_storage {\n  StorageClass *Location = nullptr; // Where to store the object...\n\npublic:\n  list_storage() = default;\n\n  void clear() {}\n\n  bool setLocation(Option &O, StorageClass &L) {\n    if (Location)\n      return O.error(\"cl::location(x) specified more than once!\");\n    Location = &L;\n    return false;\n  }\n\n  template <class T> void addValue(const T &V) {\n    assert(Location != 0 && \"cl::location(...) not specified for a command \"\n                            \"line option with external storage!\");\n    Location->push_back(V);\n  }\n};\n\n// Define how to hold a class type object, such as a string.\n// Originally this code inherited from std::vector. In transitioning to a new\n// API for command line options we should change this. The new implementation\n// of this list_storage specialization implements the minimum subset of the\n// std::vector API required for all the current clients.\n//\n// FIXME: Reduce this API to a more narrow subset of std::vector\n//\ntemplate <class DataType> class list_storage<DataType, bool> {\n  std::vector<DataType> Storage;\n\npublic:\n  using iterator = typename std::vector<DataType>::iterator;\n\n  iterator begin() { return Storage.begin(); }\n  iterator end() { return Storage.end(); }\n\n  using const_iterator = typename std::vector<DataType>::const_iterator;\n\n  const_iterator begin() const { return Storage.begin(); }\n  const_iterator end() const { return Storage.end(); }\n\n  using size_type = typename std::vector<DataType>::size_type;\n\n  size_type size() const { return Storage.size(); }\n\n  bool empty() const { return Storage.empty(); }\n\n  void push_back(const DataType &value) { Storage.push_back(value); }\n  void push_back(DataType &&value) { Storage.push_back(value); }\n\n  using reference = typename std::vector<DataType>::reference;\n  using const_reference = typename std::vector<DataType>::const_reference;\n\n  reference operator[](size_type pos) { return Storage[pos]; }\n  const_reference operator[](size_type pos) const { return Storage[pos]; }\n\n  void clear() {\n    Storage.clear();\n  }\n\n  iterator erase(const_iterator pos) { return Storage.erase(pos); }\n  iterator erase(const_iterator first, const_iterator last) {\n    return Storage.erase(first, last);\n  }\n\n  iterator erase(iterator pos) { return Storage.erase(pos); }\n  iterator erase(iterator first, iterator last) {\n    return Storage.erase(first, last);\n  }\n\n  iterator insert(const_iterator pos, const DataType &value) {\n    return Storage.insert(pos, value);\n  }\n  iterator insert(const_iterator pos, DataType &&value) {\n    return Storage.insert(pos, value);\n  }\n\n  iterator insert(iterator pos, const DataType &value) {\n    return Storage.insert(pos, value);\n  }\n  iterator insert(iterator pos, DataType &&value) {\n    return Storage.insert(pos, value);\n  }\n\n  reference front() { return Storage.front(); }\n  const_reference front() const { return Storage.front(); }\n\n  operator std::vector<DataType> &() { return Storage; }\n  operator ArrayRef<DataType>() const { return Storage; }\n  std::vector<DataType> *operator&() { return &Storage; }\n  const std::vector<DataType> *operator&() const { return &Storage; }\n\n  template <class T> void addValue(const T &V) { Storage.push_back(V); }\n};\n\n//===----------------------------------------------------------------------===//\n// list - A list of command line options.\n//\ntemplate <class DataType, class StorageClass = bool,\n          class ParserClass = parser<DataType>>\nclass list : public Option, public list_storage<DataType, StorageClass> {\n  std::vector<unsigned> Positions;\n  ParserClass Parser;\n\n  enum ValueExpected getValueExpectedFlagDefault() const override {\n    return Parser.getValueExpectedFlagDefault();\n  }\n\n  void getExtraOptionNames(SmallVectorImpl<StringRef> &OptionNames) override {\n    return Parser.getExtraOptionNames(OptionNames);\n  }\n\n  bool handleOccurrence(unsigned pos, StringRef ArgName,\n                        StringRef Arg) override {\n    typename ParserClass::parser_data_type Val =\n        typename ParserClass::parser_data_type();\n    if (Parser.parse(*this, ArgName, Arg, Val))\n      return true; // Parse Error!\n    list_storage<DataType, StorageClass>::addValue(Val);\n    setPosition(pos);\n    Positions.push_back(pos);\n    Callback(Val);\n    return false;\n  }\n\n  // Forward printing stuff to the parser...\n  size_t getOptionWidth() const override {\n    return Parser.getOptionWidth(*this);\n  }\n\n  void printOptionInfo(size_t GlobalWidth) const override {\n    Parser.printOptionInfo(*this, GlobalWidth);\n  }\n\n  // Unimplemented: list options don't currently store their default value.\n  void printOptionValue(size_t /*GlobalWidth*/, bool /*Force*/) const override {\n  }\n\n  void setDefault() override {\n    Positions.clear();\n    list_storage<DataType, StorageClass>::clear();\n  }\n\n  void done() {\n    addArgument();\n    Parser.initialize();\n  }\n\npublic:\n  // Command line options should not be copyable\n  list(const list &) = delete;\n  list &operator=(const list &) = delete;\n\n  ParserClass &getParser() { return Parser; }\n\n  unsigned getPosition(unsigned optnum) const {\n    assert(optnum < this->size() && \"Invalid option index\");\n    return Positions[optnum];\n  }\n\n  void setNumAdditionalVals(unsigned n) { Option::setNumAdditionalVals(n); }\n\n  template <class... Mods>\n  explicit list(const Mods &... Ms)\n      : Option(ZeroOrMore, NotHidden), Parser(*this) {\n    apply(this, Ms...);\n    done();\n  }\n\n  void setCallback(\n      std::function<void(const typename ParserClass::parser_data_type &)> CB) {\n    Callback = CB;\n  }\n\n  std::function<void(const typename ParserClass::parser_data_type &)> Callback =\n      [](const typename ParserClass::parser_data_type &) {};\n};\n\n// multi_val - Modifier to set the number of additional values.\nstruct multi_val {\n  unsigned AdditionalVals;\n  explicit multi_val(unsigned N) : AdditionalVals(N) {}\n\n  template <typename D, typename S, typename P>\n  void apply(list<D, S, P> &L) const {\n    L.setNumAdditionalVals(AdditionalVals);\n  }\n};\n\n//===----------------------------------------------------------------------===//\n// bits_storage class\n\n// Default storage class definition: external storage.  This implementation\n// assumes the user will specify a variable to store the data into with the\n// cl::location(x) modifier.\n//\ntemplate <class DataType, class StorageClass> class bits_storage {\n  unsigned *Location = nullptr; // Where to store the bits...\n\n  template <class T> static unsigned Bit(const T &V) {\n    unsigned BitPos = reinterpret_cast<unsigned>(V);\n    assert(BitPos < sizeof(unsigned) * CHAR_BIT &&\n           \"enum exceeds width of bit vector!\");\n    return 1 << BitPos;\n  }\n\npublic:\n  bits_storage() = default;\n\n  bool setLocation(Option &O, unsigned &L) {\n    if (Location)\n      return O.error(\"cl::location(x) specified more than once!\");\n    Location = &L;\n    return false;\n  }\n\n  template <class T> void addValue(const T &V) {\n    assert(Location != 0 && \"cl::location(...) not specified for a command \"\n                            \"line option with external storage!\");\n    *Location |= Bit(V);\n  }\n\n  unsigned getBits() { return *Location; }\n\n  template <class T> bool isSet(const T &V) {\n    return (*Location & Bit(V)) != 0;\n  }\n};\n\n// Define how to hold bits.  Since we can inherit from a class, we do so.\n// This makes us exactly compatible with the bits in all cases that it is used.\n//\ntemplate <class DataType> class bits_storage<DataType, bool> {\n  unsigned Bits; // Where to store the bits...\n\n  template <class T> static unsigned Bit(const T &V) {\n    unsigned BitPos = (unsigned)V;\n    assert(BitPos < sizeof(unsigned) * CHAR_BIT &&\n           \"enum exceeds width of bit vector!\");\n    return 1 << BitPos;\n  }\n\npublic:\n  template <class T> void addValue(const T &V) { Bits |= Bit(V); }\n\n  unsigned getBits() { return Bits; }\n\n  template <class T> bool isSet(const T &V) { return (Bits & Bit(V)) != 0; }\n};\n\n//===----------------------------------------------------------------------===//\n// bits - A bit vector of command options.\n//\ntemplate <class DataType, class Storage = bool,\n          class ParserClass = parser<DataType>>\nclass bits : public Option, public bits_storage<DataType, Storage> {\n  std::vector<unsigned> Positions;\n  ParserClass Parser;\n\n  enum ValueExpected getValueExpectedFlagDefault() const override {\n    return Parser.getValueExpectedFlagDefault();\n  }\n\n  void getExtraOptionNames(SmallVectorImpl<StringRef> &OptionNames) override {\n    return Parser.getExtraOptionNames(OptionNames);\n  }\n\n  bool handleOccurrence(unsigned pos, StringRef ArgName,\n                        StringRef Arg) override {\n    typename ParserClass::parser_data_type Val =\n        typename ParserClass::parser_data_type();\n    if (Parser.parse(*this, ArgName, Arg, Val))\n      return true; // Parse Error!\n    this->addValue(Val);\n    setPosition(pos);\n    Positions.push_back(pos);\n    Callback(Val);\n    return false;\n  }\n\n  // Forward printing stuff to the parser...\n  size_t getOptionWidth() const override {\n    return Parser.getOptionWidth(*this);\n  }\n\n  void printOptionInfo(size_t GlobalWidth) const override {\n    Parser.printOptionInfo(*this, GlobalWidth);\n  }\n\n  // Unimplemented: bits options don't currently store their default values.\n  void printOptionValue(size_t /*GlobalWidth*/, bool /*Force*/) const override {\n  }\n\n  void setDefault() override {}\n\n  void done() {\n    addArgument();\n    Parser.initialize();\n  }\n\npublic:\n  // Command line options should not be copyable\n  bits(const bits &) = delete;\n  bits &operator=(const bits &) = delete;\n\n  ParserClass &getParser() { return Parser; }\n\n  unsigned getPosition(unsigned optnum) const {\n    assert(optnum < this->size() && \"Invalid option index\");\n    return Positions[optnum];\n  }\n\n  template <class... Mods>\n  explicit bits(const Mods &... Ms)\n      : Option(ZeroOrMore, NotHidden), Parser(*this) {\n    apply(this, Ms...);\n    done();\n  }\n\n  void setCallback(\n      std::function<void(const typename ParserClass::parser_data_type &)> CB) {\n    Callback = CB;\n  }\n\n  std::function<void(const typename ParserClass::parser_data_type &)> Callback =\n      [](const typename ParserClass::parser_data_type &) {};\n};\n\n//===----------------------------------------------------------------------===//\n// Aliased command line option (alias this name to a preexisting name)\n//\n\nclass alias : public Option {\n  Option *AliasFor;\n\n  bool handleOccurrence(unsigned pos, StringRef /*ArgName*/,\n                        StringRef Arg) override {\n    return AliasFor->handleOccurrence(pos, AliasFor->ArgStr, Arg);\n  }\n\n  bool addOccurrence(unsigned pos, StringRef /*ArgName*/, StringRef Value,\n                     bool MultiArg = false) override {\n    return AliasFor->addOccurrence(pos, AliasFor->ArgStr, Value, MultiArg);\n  }\n\n  // Handle printing stuff...\n  size_t getOptionWidth() const override;\n  void printOptionInfo(size_t GlobalWidth) const override;\n\n  // Aliases do not need to print their values.\n  void printOptionValue(size_t /*GlobalWidth*/, bool /*Force*/) const override {\n  }\n\n  void setDefault() override { AliasFor->setDefault(); }\n\n  ValueExpected getValueExpectedFlagDefault() const override {\n    return AliasFor->getValueExpectedFlag();\n  }\n\n  void done() {\n    if (!hasArgStr())\n      error(\"cl::alias must have argument name specified!\");\n    if (!AliasFor)\n      error(\"cl::alias must have an cl::aliasopt(option) specified!\");\n    if (!Subs.empty())\n      error(\"cl::alias must not have cl::sub(), aliased option's cl::sub() will be used!\");\n    Subs = AliasFor->Subs;\n    Categories = AliasFor->Categories;\n    addArgument();\n  }\n\npublic:\n  // Command line options should not be copyable\n  alias(const alias &) = delete;\n  alias &operator=(const alias &) = delete;\n\n  void setAliasFor(Option &O) {\n    if (AliasFor)\n      error(\"cl::alias must only have one cl::aliasopt(...) specified!\");\n    AliasFor = &O;\n  }\n\n  template <class... Mods>\n  explicit alias(const Mods &... Ms)\n      : Option(Optional, Hidden), AliasFor(nullptr) {\n    apply(this, Ms...);\n    done();\n  }\n};\n\n// aliasfor - Modifier to set the option an alias aliases.\nstruct aliasopt {\n  Option &Opt;\n\n  explicit aliasopt(Option &O) : Opt(O) {}\n\n  void apply(alias &A) const { A.setAliasFor(Opt); }\n};\n\n// extrahelp - provide additional help at the end of the normal help\n// output. All occurrences of cl::extrahelp will be accumulated and\n// printed to stderr at the end of the regular help, just before\n// exit is called.\nstruct extrahelp {\n  StringRef morehelp;\n\n  explicit extrahelp(StringRef help);\n};\n\nvoid PrintVersionMessage();\n\n/// This function just prints the help message, exactly the same way as if the\n/// -help or -help-hidden option had been given on the command line.\n///\n/// \\param Hidden if true will print hidden options\n/// \\param Categorized if true print options in categories\nvoid PrintHelpMessage(bool Hidden = false, bool Categorized = false);\n\n//===----------------------------------------------------------------------===//\n// Public interface for accessing registered options.\n//\n\n/// Use this to get a StringMap to all registered named options\n/// (e.g. -help).\n///\n/// \\return A reference to the StringMap used by the cl APIs to parse options.\n///\n/// Access to unnamed arguments (i.e. positional) are not provided because\n/// it is expected that the client already has access to these.\n///\n/// Typical usage:\n/// \\code\n/// main(int argc,char* argv[]) {\n/// StringMap<llvm::cl::Option*> &opts = llvm::cl::getRegisteredOptions();\n/// assert(opts.count(\"help\") == 1)\n/// opts[\"help\"]->setDescription(\"Show alphabetical help information\")\n/// // More code\n/// llvm::cl::ParseCommandLineOptions(argc,argv);\n/// //More code\n/// }\n/// \\endcode\n///\n/// This interface is useful for modifying options in libraries that are out of\n/// the control of the client. The options should be modified before calling\n/// llvm::cl::ParseCommandLineOptions().\n///\n/// Hopefully this API can be deprecated soon. Any situation where options need\n/// to be modified by tools or libraries should be handled by sane APIs rather\n/// than just handing around a global list.\nStringMap<Option *> &getRegisteredOptions(SubCommand &Sub = *TopLevelSubCommand);\n\n/// Use this to get all registered SubCommands from the provided parser.\n///\n/// \\return A range of all SubCommand pointers registered with the parser.\n///\n/// Typical usage:\n/// \\code\n/// main(int argc, char* argv[]) {\n///   llvm::cl::ParseCommandLineOptions(argc, argv);\n///   for (auto* S : llvm::cl::getRegisteredSubcommands()) {\n///     if (*S) {\n///       std::cout << \"Executing subcommand: \" << S->getName() << std::endl;\n///       // Execute some function based on the name...\n///     }\n///   }\n/// }\n/// \\endcode\n///\n/// This interface is useful for defining subcommands in libraries and\n/// the dispatch from a single point (like in the main function).\niterator_range<typename SmallPtrSet<SubCommand *, 4>::iterator>\ngetRegisteredSubcommands();\n\n//===----------------------------------------------------------------------===//\n// Standalone command line processing utilities.\n//\n\n/// Tokenizes a command line that can contain escapes and quotes.\n//\n/// The quoting rules match those used by GCC and other tools that use\n/// libiberty's buildargv() or expandargv() utilities, and do not match bash.\n/// They differ from buildargv() on treatment of backslashes that do not escape\n/// a special character to make it possible to accept most Windows file paths.\n///\n/// \\param [in] Source The string to be split on whitespace with quotes.\n/// \\param [in] Saver Delegates back to the caller for saving parsed strings.\n/// \\param [in] MarkEOLs true if tokenizing a response file and you want end of\n/// lines and end of the response file to be marked with a nullptr string.\n/// \\param [out] NewArgv All parsed strings are appended to NewArgv.\nvoid TokenizeGNUCommandLine(StringRef Source, StringSaver &Saver,\n                            SmallVectorImpl<const char *> &NewArgv,\n                            bool MarkEOLs = false);\n\n/// Tokenizes a Windows command line which may contain quotes and escaped\n/// quotes.\n///\n/// See MSDN docs for CommandLineToArgvW for information on the quoting rules.\n/// http://msdn.microsoft.com/en-us/library/windows/desktop/17w5ykft(v=vs.85).aspx\n///\n/// \\param [in] Source The string to be split on whitespace with quotes.\n/// \\param [in] Saver Delegates back to the caller for saving parsed strings.\n/// \\param [in] MarkEOLs true if tokenizing a response file and you want end of\n/// lines and end of the response file to be marked with a nullptr string.\n/// \\param [out] NewArgv All parsed strings are appended to NewArgv.\nvoid TokenizeWindowsCommandLine(StringRef Source, StringSaver &Saver,\n                                SmallVectorImpl<const char *> &NewArgv,\n                                bool MarkEOLs = false);\n\n/// Tokenizes a Windows command line while attempting to avoid copies. If no\n/// quoting or escaping was used, this produces substrings of the original\n/// string. If a token requires unquoting, it will be allocated with the\n/// StringSaver.\nvoid TokenizeWindowsCommandLineNoCopy(StringRef Source, StringSaver &Saver,\n                                      SmallVectorImpl<StringRef> &NewArgv);\n\n/// String tokenization function type.  Should be compatible with either\n/// Windows or Unix command line tokenizers.\nusing TokenizerCallback = void (*)(StringRef Source, StringSaver &Saver,\n                                   SmallVectorImpl<const char *> &NewArgv,\n                                   bool MarkEOLs);\n\n/// Tokenizes content of configuration file.\n///\n/// \\param [in] Source The string representing content of config file.\n/// \\param [in] Saver Delegates back to the caller for saving parsed strings.\n/// \\param [out] NewArgv All parsed strings are appended to NewArgv.\n/// \\param [in] MarkEOLs Added for compatibility with TokenizerCallback.\n///\n/// It works like TokenizeGNUCommandLine with ability to skip comment lines.\n///\nvoid tokenizeConfigFile(StringRef Source, StringSaver &Saver,\n                        SmallVectorImpl<const char *> &NewArgv,\n                        bool MarkEOLs = false);\n\n/// Reads command line options from the given configuration file.\n///\n/// \\param [in] CfgFileName Path to configuration file.\n/// \\param [in] Saver  Objects that saves allocated strings.\n/// \\param [out] Argv Array to which the read options are added.\n/// \\return true if the file was successfully read.\n///\n/// It reads content of the specified file, tokenizes it and expands \"@file\"\n/// commands resolving file names in them relative to the directory where\n/// CfgFilename resides.\n///\nbool readConfigFile(StringRef CfgFileName, StringSaver &Saver,\n                    SmallVectorImpl<const char *> &Argv);\n\n/// Expand response files on a command line recursively using the given\n/// StringSaver and tokenization strategy.  Argv should contain the command line\n/// before expansion and will be modified in place. If requested, Argv will\n/// also be populated with nullptrs indicating where each response file line\n/// ends, which is useful for the \"/link\" argument that needs to consume all\n/// remaining arguments only until the next end of line, when in a response\n/// file.\n///\n/// \\param [in] Saver Delegates back to the caller for saving parsed strings.\n/// \\param [in] Tokenizer Tokenization strategy. Typically Unix or Windows.\n/// \\param [in,out] Argv Command line into which to expand response files.\n/// \\param [in] MarkEOLs Mark end of lines and the end of the response file\n/// with nullptrs in the Argv vector.\n/// \\param [in] RelativeNames true if names of nested response files must be\n/// resolved relative to including file.\n/// \\param [in] FS File system used for all file access when running the tool.\n/// \\param [in] CurrentDir Path used to resolve relative rsp files. If set to\n/// None, process' cwd is used instead.\n/// \\return true if all @files were expanded successfully or there were none.\nbool ExpandResponseFiles(\n    StringSaver &Saver, TokenizerCallback Tokenizer,\n    SmallVectorImpl<const char *> &Argv, bool MarkEOLs = false,\n    bool RelativeNames = false,\n    llvm::vfs::FileSystem &FS = *llvm::vfs::getRealFileSystem(),\n    llvm::Optional<llvm::StringRef> CurrentDir = llvm::None);\n\n/// A convenience helper which concatenates the options specified by the\n/// environment variable EnvVar and command line options, then expands response\n/// files recursively. The tokenizer is a predefined GNU or Windows one.\n/// \\return true if all @files were expanded successfully or there were none.\nbool expandResponseFiles(int Argc, const char *const *Argv, const char *EnvVar,\n                         StringSaver &Saver,\n                         SmallVectorImpl<const char *> &NewArgv);\n\n/// Mark all options not part of this category as cl::ReallyHidden.\n///\n/// \\param Category the category of options to keep displaying\n///\n/// Some tools (like clang-format) like to be able to hide all options that are\n/// not specific to the tool. This function allows a tool to specify a single\n/// option category to display in the -help output.\nvoid HideUnrelatedOptions(cl::OptionCategory &Category,\n                          SubCommand &Sub = *TopLevelSubCommand);\n\n/// Mark all options not part of the categories as cl::ReallyHidden.\n///\n/// \\param Categories the categories of options to keep displaying.\n///\n/// Some tools (like clang-format) like to be able to hide all options that are\n/// not specific to the tool. This function allows a tool to specify a single\n/// option category to display in the -help output.\nvoid HideUnrelatedOptions(ArrayRef<const cl::OptionCategory *> Categories,\n                          SubCommand &Sub = *TopLevelSubCommand);\n\n/// Reset all command line options to a state that looks as if they have\n/// never appeared on the command line.  This is useful for being able to parse\n/// a command line multiple times (especially useful for writing tests).\nvoid ResetAllOptionOccurrences();\n\n/// Reset the command line parser back to its initial state.  This\n/// removes\n/// all options, categories, and subcommands and returns the parser to a state\n/// where no options are supported.\nvoid ResetCommandLineParser();\n\n/// Parses `Arg` into the option handler `Handler`.\nbool ProvidePositionalOption(Option *Handler, StringRef Arg, int i);\n\n} // end namespace cl\n\n} // end namespace llvm\n\n#endif // LLVM_SUPPORT_COMMANDLINE_H\n"}, "69": {"id": 69, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/LowLevelTypeImpl.h", "content": "//== llvm/Support/LowLevelTypeImpl.h --------------------------- -*- C++ -*-==//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n/// Implement a low-level type suitable for MachineInstr level instruction\n/// selection.\n///\n/// For a type attached to a MachineInstr, we only care about 2 details: total\n/// size and the number of vector lanes (if any). Accordingly, there are 4\n/// possible valid type-kinds:\n///\n///    * `sN` for scalars and aggregates\n///    * `<N x sM>` for vectors, which must have at least 2 elements.\n///    * `pN` for pointers\n///\n/// Other information required for correct selection is expected to be carried\n/// by the opcode, or non-type flags. For example the distinction between G_ADD\n/// and G_FADD for int/float or fast-math flags.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_SUPPORT_LOWLEVELTYPEIMPL_H\n#define LLVM_SUPPORT_LOWLEVELTYPEIMPL_H\n\n#include \"llvm/ADT/DenseMapInfo.h\"\n#include \"llvm/Support/Debug.h\"\n#include \"llvm/Support/MachineValueType.h\"\n#include <cassert>\n\nnamespace llvm {\n\nclass DataLayout;\nclass Type;\nclass raw_ostream;\n\nclass LLT {\npublic:\n  /// Get a low-level scalar or aggregate \"bag of bits\".\n  static LLT scalar(unsigned SizeInBits) {\n    assert(SizeInBits > 0 && \"invalid scalar size\");\n    return LLT{/*isPointer=*/false, /*isVector=*/false, /*NumElements=*/0,\n               SizeInBits, /*AddressSpace=*/0};\n  }\n\n  /// Get a low-level pointer in the given address space.\n  static LLT pointer(unsigned AddressSpace, unsigned SizeInBits) {\n    assert(SizeInBits > 0 && \"invalid pointer size\");\n    return LLT{/*isPointer=*/true, /*isVector=*/false, /*NumElements=*/0,\n               SizeInBits, AddressSpace};\n  }\n\n  /// Get a low-level vector of some number of elements and element width.\n  /// \\p NumElements must be at least 2.\n  static LLT vector(uint16_t NumElements, unsigned ScalarSizeInBits) {\n    assert(NumElements > 1 && \"invalid number of vector elements\");\n    assert(ScalarSizeInBits > 0 && \"invalid vector element size\");\n    return LLT{/*isPointer=*/false, /*isVector=*/true, NumElements,\n               ScalarSizeInBits, /*AddressSpace=*/0};\n  }\n\n  /// Get a low-level vector of some number of elements and element type.\n  static LLT vector(uint16_t NumElements, LLT ScalarTy) {\n    assert(NumElements > 1 && \"invalid number of vector elements\");\n    assert(!ScalarTy.isVector() && \"invalid vector element type\");\n    return LLT{ScalarTy.isPointer(), /*isVector=*/true, NumElements,\n               ScalarTy.getSizeInBits(),\n               ScalarTy.isPointer() ? ScalarTy.getAddressSpace() : 0};\n  }\n\n  static LLT scalarOrVector(uint16_t NumElements, LLT ScalarTy) {\n    return NumElements == 1 ? ScalarTy : LLT::vector(NumElements, ScalarTy);\n  }\n\n  static LLT scalarOrVector(uint16_t NumElements, unsigned ScalarSize) {\n    return scalarOrVector(NumElements, LLT::scalar(ScalarSize));\n  }\n\n  explicit LLT(bool isPointer, bool isVector, uint16_t NumElements,\n               unsigned SizeInBits, unsigned AddressSpace) {\n    init(isPointer, isVector, NumElements, SizeInBits, AddressSpace);\n  }\n  explicit LLT() : IsPointer(false), IsVector(false), RawData(0) {}\n\n  explicit LLT(MVT VT);\n\n  bool isValid() const { return RawData != 0; }\n\n  bool isScalar() const { return isValid() && !IsPointer && !IsVector; }\n\n  bool isPointer() const { return isValid() && IsPointer && !IsVector; }\n\n  bool isVector() const { return isValid() && IsVector; }\n\n  /// Returns the number of elements in a vector LLT. Must only be called on\n  /// vector types.\n  uint16_t getNumElements() const {\n    assert(IsVector && \"cannot get number of elements on scalar/aggregate\");\n    if (!IsPointer)\n      return getFieldValue(VectorElementsFieldInfo);\n    else\n      return getFieldValue(PointerVectorElementsFieldInfo);\n  }\n\n  /// Returns the total size of the type. Must only be called on sized types.\n  unsigned getSizeInBits() const {\n    if (isPointer() || isScalar())\n      return getScalarSizeInBits();\n    return getScalarSizeInBits() * getNumElements();\n  }\n\n  /// Returns the total size of the type in bytes, i.e. number of whole bytes\n  /// needed to represent the size in bits. Must only be called on sized types.\n  unsigned getSizeInBytes() const {\n    return (getSizeInBits() + 7) / 8;\n  }\n\n  LLT getScalarType() const {\n    return isVector() ? getElementType() : *this;\n  }\n\n  /// If this type is a vector, return a vector with the same number of elements\n  /// but the new element type. Otherwise, return the new element type.\n  LLT changeElementType(LLT NewEltTy) const {\n    return isVector() ? LLT::vector(getNumElements(), NewEltTy) : NewEltTy;\n  }\n\n  /// If this type is a vector, return a vector with the same number of elements\n  /// but the new element size. Otherwise, return the new element type. Invalid\n  /// for pointer types. For pointer types, use changeElementType.\n  LLT changeElementSize(unsigned NewEltSize) const {\n    assert(!getScalarType().isPointer() &&\n           \"invalid to directly change element size for pointers\");\n    return isVector() ? LLT::vector(getNumElements(), NewEltSize)\n                      : LLT::scalar(NewEltSize);\n  }\n\n  /// Return a vector or scalar with the same element type and the new number of\n  /// elements.\n  LLT changeNumElements(unsigned NewNumElts) const {\n    return LLT::scalarOrVector(NewNumElts, getScalarType());\n  }\n\n  /// Return a type that is \\p Factor times smaller. Reduces the number of\n  /// elements if this is a vector, or the bitwidth for scalar/pointers. Does\n  /// not attempt to handle cases that aren't evenly divisible.\n  LLT divide(int Factor) const {\n    assert(Factor != 1);\n    if (isVector()) {\n      assert(getNumElements() % Factor == 0);\n      return scalarOrVector(getNumElements() / Factor, getElementType());\n    }\n\n    assert(getSizeInBits() % Factor == 0);\n    return scalar(getSizeInBits() / Factor);\n  }\n\n  bool isByteSized() const { return (getSizeInBits() & 7) == 0; }\n\n  unsigned getScalarSizeInBits() const {\n    assert(RawData != 0 && \"Invalid Type\");\n    if (!IsVector) {\n      if (!IsPointer)\n        return getFieldValue(ScalarSizeFieldInfo);\n      else\n        return getFieldValue(PointerSizeFieldInfo);\n    } else {\n      if (!IsPointer)\n        return getFieldValue(VectorSizeFieldInfo);\n      else\n        return getFieldValue(PointerVectorSizeFieldInfo);\n    }\n  }\n\n  unsigned getAddressSpace() const {\n    assert(RawData != 0 && \"Invalid Type\");\n    assert(IsPointer && \"cannot get address space of non-pointer type\");\n    if (!IsVector)\n      return getFieldValue(PointerAddressSpaceFieldInfo);\n    else\n      return getFieldValue(PointerVectorAddressSpaceFieldInfo);\n  }\n\n  /// Returns the vector's element type. Only valid for vector types.\n  LLT getElementType() const {\n    assert(isVector() && \"cannot get element type of scalar/aggregate\");\n    if (IsPointer)\n      return pointer(getAddressSpace(), getScalarSizeInBits());\n    else\n      return scalar(getScalarSizeInBits());\n  }\n\n  void print(raw_ostream &OS) const;\n\n#if !defined(NDEBUG) || defined(LLVM_ENABLE_DUMP)\n  LLVM_DUMP_METHOD void dump() const {\n    print(dbgs());\n    dbgs() << '\\n';\n  }\n#endif\n\n  bool operator==(const LLT &RHS) const {\n    return IsPointer == RHS.IsPointer && IsVector == RHS.IsVector &&\n           RHS.RawData == RawData;\n  }\n\n  bool operator!=(const LLT &RHS) const { return !(*this == RHS); }\n\n  friend struct DenseMapInfo<LLT>;\n  friend class GISelInstProfileBuilder;\n\nprivate:\n  /// LLT is packed into 64 bits as follows:\n  /// isPointer : 1\n  /// isVector  : 1\n  /// with 62 bits remaining for Kind-specific data, packed in bitfields\n  /// as described below. As there isn't a simple portable way to pack bits\n  /// into bitfields, here the different fields in the packed structure is\n  /// described in static const *Field variables. Each of these variables\n  /// is a 2-element array, with the first element describing the bitfield size\n  /// and the second element describing the bitfield offset.\n  typedef int BitFieldInfo[2];\n  ///\n  /// This is how the bitfields are packed per Kind:\n  /// * Invalid:\n  ///   gets encoded as RawData == 0, as that is an invalid encoding, since for\n  ///   valid encodings, SizeInBits/SizeOfElement must be larger than 0.\n  /// * Non-pointer scalar (isPointer == 0 && isVector == 0):\n  ///   SizeInBits: 32;\n  static const constexpr BitFieldInfo ScalarSizeFieldInfo{32, 0};\n  /// * Pointer (isPointer == 1 && isVector == 0):\n  ///   SizeInBits: 16;\n  ///   AddressSpace: 24;\n  static const constexpr BitFieldInfo PointerSizeFieldInfo{16, 0};\n  static const constexpr BitFieldInfo PointerAddressSpaceFieldInfo{\n      24, PointerSizeFieldInfo[0] + PointerSizeFieldInfo[1]};\n  /// * Vector-of-non-pointer (isPointer == 0 && isVector == 1):\n  ///   NumElements: 16;\n  ///   SizeOfElement: 32;\n  static const constexpr BitFieldInfo VectorElementsFieldInfo{16, 0};\n  static const constexpr BitFieldInfo VectorSizeFieldInfo{\n      32, VectorElementsFieldInfo[0] + VectorElementsFieldInfo[1]};\n  /// * Vector-of-pointer (isPointer == 1 && isVector == 1):\n  ///   NumElements: 16;\n  ///   SizeOfElement: 16;\n  ///   AddressSpace: 24;\n  static const constexpr BitFieldInfo PointerVectorElementsFieldInfo{16, 0};\n  static const constexpr BitFieldInfo PointerVectorSizeFieldInfo{\n      16,\n      PointerVectorElementsFieldInfo[1] + PointerVectorElementsFieldInfo[0]};\n  static const constexpr BitFieldInfo PointerVectorAddressSpaceFieldInfo{\n      24, PointerVectorSizeFieldInfo[1] + PointerVectorSizeFieldInfo[0]};\n\n  uint64_t IsPointer : 1;\n  uint64_t IsVector : 1;\n  uint64_t RawData : 62;\n\n  static uint64_t getMask(const BitFieldInfo FieldInfo) {\n    const int FieldSizeInBits = FieldInfo[0];\n    return (((uint64_t)1) << FieldSizeInBits) - 1;\n  }\n  static uint64_t maskAndShift(uint64_t Val, uint64_t Mask, uint8_t Shift) {\n    assert(Val <= Mask && \"Value too large for field\");\n    return (Val & Mask) << Shift;\n  }\n  static uint64_t maskAndShift(uint64_t Val, const BitFieldInfo FieldInfo) {\n    return maskAndShift(Val, getMask(FieldInfo), FieldInfo[1]);\n  }\n  uint64_t getFieldValue(const BitFieldInfo FieldInfo) const {\n    return getMask(FieldInfo) & (RawData >> FieldInfo[1]);\n  }\n\n  void init(bool IsPointer, bool IsVector, uint16_t NumElements,\n            unsigned SizeInBits, unsigned AddressSpace) {\n    this->IsPointer = IsPointer;\n    this->IsVector = IsVector;\n    if (!IsVector) {\n      if (!IsPointer)\n        RawData = maskAndShift(SizeInBits, ScalarSizeFieldInfo);\n      else\n        RawData = maskAndShift(SizeInBits, PointerSizeFieldInfo) |\n                  maskAndShift(AddressSpace, PointerAddressSpaceFieldInfo);\n    } else {\n      assert(NumElements > 1 && \"invalid number of vector elements\");\n      if (!IsPointer)\n        RawData = maskAndShift(NumElements, VectorElementsFieldInfo) |\n                  maskAndShift(SizeInBits, VectorSizeFieldInfo);\n      else\n        RawData =\n            maskAndShift(NumElements, PointerVectorElementsFieldInfo) |\n            maskAndShift(SizeInBits, PointerVectorSizeFieldInfo) |\n            maskAndShift(AddressSpace, PointerVectorAddressSpaceFieldInfo);\n    }\n  }\n\n  uint64_t getUniqueRAWLLTData() const {\n    return ((uint64_t)RawData) << 2 | ((uint64_t)IsPointer) << 1 |\n           ((uint64_t)IsVector);\n  }\n};\n\ninline raw_ostream& operator<<(raw_ostream &OS, const LLT &Ty) {\n  Ty.print(OS);\n  return OS;\n}\n\ntemplate<> struct DenseMapInfo<LLT> {\n  static inline LLT getEmptyKey() {\n    LLT Invalid;\n    Invalid.IsPointer = true;\n    return Invalid;\n  }\n  static inline LLT getTombstoneKey() {\n    LLT Invalid;\n    Invalid.IsVector = true;\n    return Invalid;\n  }\n  static inline unsigned getHashValue(const LLT &Ty) {\n    uint64_t Val = Ty.getUniqueRAWLLTData();\n    return DenseMapInfo<uint64_t>::getHashValue(Val);\n  }\n  static bool isEqual(const LLT &LHS, const LLT &RHS) {\n    return LHS == RHS;\n  }\n};\n\n}\n\n#endif // LLVM_SUPPORT_LOWLEVELTYPEIMPL_H\n"}, "71": {"id": 71, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/MachineValueType.h", "content": "//===- Support/MachineValueType.h - Machine-Level types ---------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// This file defines the set of machine-level target independent types which\n// legal values in the code generator use.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_SUPPORT_MACHINEVALUETYPE_H\n#define LLVM_SUPPORT_MACHINEVALUETYPE_H\n\n#include \"llvm/ADT/iterator_range.h\"\n#include \"llvm/Support/ErrorHandling.h\"\n#include \"llvm/Support/MathExtras.h\"\n#include \"llvm/Support/TypeSize.h\"\n#include <cassert>\n\nnamespace llvm {\n\n  class Type;\n\n  /// Machine Value Type. Every type that is supported natively by some\n  /// processor targeted by LLVM occurs here. This means that any legal value\n  /// type can be represented by an MVT.\n  class MVT {\n  public:\n    enum SimpleValueType : uint8_t {\n      // Simple value types that aren't explicitly part of this enumeration\n      // are considered extended value types.\n      INVALID_SIMPLE_VALUE_TYPE = 0,\n\n      // If you change this numbering, you must change the values in\n      // ValueTypes.td as well!\n      Other          =   1,   // This is a non-standard value\n      i1             =   2,   // This is a 1 bit integer value\n      i8             =   3,   // This is an 8 bit integer value\n      i16            =   4,   // This is a 16 bit integer value\n      i32            =   5,   // This is a 32 bit integer value\n      i64            =   6,   // This is a 64 bit integer value\n      i128           =   7,   // This is a 128 bit integer value\n\n      FIRST_INTEGER_VALUETYPE = i1,\n      LAST_INTEGER_VALUETYPE  = i128,\n\n      bf16           =   8,   // This is a 16 bit brain floating point value\n      f16            =   9,   // This is a 16 bit floating point value\n      f32            =  10,   // This is a 32 bit floating point value\n      f64            =  11,   // This is a 64 bit floating point value\n      f80            =  12,   // This is a 80 bit floating point value\n      f128           =  13,   // This is a 128 bit floating point value\n      ppcf128        =  14,   // This is a PPC 128-bit floating point value\n\n      FIRST_FP_VALUETYPE = bf16,\n      LAST_FP_VALUETYPE  = ppcf128,\n\n      v1i1           =  15,   //    1 x i1\n      v2i1           =  16,   //    2 x i1\n      v4i1           =  17,   //    4 x i1\n      v8i1           =  18,   //    8 x i1\n      v16i1          =  19,   //   16 x i1\n      v32i1          =  20,   //   32 x i1\n      v64i1          =  21,   //   64 x i1\n      v128i1         =  22,   //  128 x i1\n      v256i1         =  23,   //  256 x i1\n      v512i1         =  24,   //  512 x i1\n      v1024i1        =  25,   // 1024 x i1\n\n      v1i8           =  26,   //  1 x i8\n      v2i8           =  27,   //  2 x i8\n      v4i8           =  28,   //  4 x i8\n      v8i8           =  29,   //  8 x i8\n      v16i8          =  30,   // 16 x i8\n      v32i8          =  31,   // 32 x i8\n      v64i8          =  32,   // 64 x i8\n      v128i8         =  33,   //128 x i8\n      v256i8         =  34,   //256 x i8\n\n      v1i16          =  35,   //  1 x i16\n      v2i16          =  36,   //  2 x i16\n      v3i16          =  37,   //  3 x i16\n      v4i16          =  38,   //  4 x i16\n      v8i16          =  39,   //  8 x i16\n      v16i16         =  40,   // 16 x i16\n      v32i16         =  41,   // 32 x i16\n      v64i16         =  42,   // 64 x i16\n      v128i16        =  43,   //128 x i16\n\n      v1i32          =  44,   //    1 x i32\n      v2i32          =  45,   //    2 x i32\n      v3i32          =  46,   //    3 x i32\n      v4i32          =  47,   //    4 x i32\n      v5i32          =  48,   //    5 x i32\n      v8i32          =  49,   //    8 x i32\n      v16i32         =  50,   //   16 x i32\n      v32i32         =  51,   //   32 x i32\n      v64i32         =  52,   //   64 x i32\n      v128i32        =  53,   //  128 x i32\n      v256i32        =  54,   //  256 x i32\n      v512i32        =  55,   //  512 x i32\n      v1024i32       =  56,   // 1024 x i32\n      v2048i32       =  57,   // 2048 x i32\n\n      v1i64          =  58,   //  1 x i64\n      v2i64          =  59,   //  2 x i64\n      v4i64          =  60,   //  4 x i64\n      v8i64          =  61,   //  8 x i64\n      v16i64         =  62,   // 16 x i64\n      v32i64         =  63,   // 32 x i64\n      v64i64         =  64,   // 64 x i64\n      v128i64        =  65,   // 128 x i64\n      v256i64        =  66,   // 256 x i64\n\n      v1i128         =  67,   //  1 x i128\n\n      FIRST_INTEGER_FIXEDLEN_VECTOR_VALUETYPE = v1i1,\n      LAST_INTEGER_FIXEDLEN_VECTOR_VALUETYPE = v1i128,\n\n      v2f16          =  68,   //    2 x f16\n      v3f16          =  69,   //    3 x f16\n      v4f16          =  70,   //    4 x f16\n      v8f16          =  71,   //    8 x f16\n      v16f16         =  72,   //   16 x f16\n      v32f16         =  73,   //   32 x f16\n      v64f16         =  74,   //   64 x f16\n      v128f16        =  75,   //  128 x f16\n      v2bf16         =  76,   //    2 x bf16\n      v3bf16         =  77,   //    3 x bf16\n      v4bf16         =  78,   //    4 x bf16\n      v8bf16         =  79,   //    8 x bf16\n      v16bf16        =  80,   //   16 x bf16\n      v32bf16        =  81,   //   32 x bf16\n      v64bf16        =  82,   //   64 x bf16\n      v128bf16       =  83,   //  128 x bf16\n      v1f32          =  84,   //    1 x f32\n      v2f32          =  85,   //    2 x f32\n      v3f32          =  86,   //    3 x f32\n      v4f32          =  87,   //    4 x f32\n      v5f32          =  88,   //    5 x f32\n      v8f32          =  89,   //    8 x f32\n      v16f32         =  90,   //   16 x f32\n      v32f32         =  91,   //   32 x f32\n      v64f32         =  92,   //   64 x f32\n      v128f32        =  93,   //  128 x f32\n      v256f32        =  94,   //  256 x f32\n      v512f32        =  95,   //  512 x f32\n      v1024f32       =  96,   // 1024 x f32\n      v2048f32       =  97,   // 2048 x f32\n      v1f64          =  98,   //    1 x f64\n      v2f64          =  99,   //    2 x f64\n      v4f64          = 100,   //    4 x f64\n      v8f64          = 101,   //    8 x f64\n      v16f64         = 102,   //   16 x f64\n      v32f64         = 103,   //   32 x f64\n      v64f64         = 104,   //   64 x f64\n      v128f64        = 105,   //  128 x f64\n      v256f64        = 106,   //  256 x f64\n\n      FIRST_FP_FIXEDLEN_VECTOR_VALUETYPE = v2f16,\n      LAST_FP_FIXEDLEN_VECTOR_VALUETYPE = v256f64,\n\n      FIRST_FIXEDLEN_VECTOR_VALUETYPE = v1i1,\n      LAST_FIXEDLEN_VECTOR_VALUETYPE = v256f64,\n\n      nxv1i1         = 107,   // n x  1 x i1\n      nxv2i1         = 108,   // n x  2 x i1\n      nxv4i1         = 109,   // n x  4 x i1\n      nxv8i1         = 110,   // n x  8 x i1\n      nxv16i1        = 111,   // n x 16 x i1\n      nxv32i1        = 112,   // n x 32 x i1\n      nxv64i1        = 113,   // n x  64 x i1\n\n      nxv1i8         = 114,   // n x  1 x i8\n      nxv2i8         = 115,   // n x  2 x i8\n      nxv4i8         = 116,   // n x  4 x i8\n      nxv8i8         = 117,   // n x  8 x i8\n      nxv16i8        = 118,   // n x 16 x i8\n      nxv32i8        = 119,   // n x 32 x i8\n      nxv64i8        = 120,   // n x  64 x i8\n\n      nxv1i16        = 121,  // n x  1 x i16\n      nxv2i16        = 122,  // n x  2 x i16\n      nxv4i16        = 123,  // n x  4 x i16\n      nxv8i16        = 124,  // n x  8 x i16\n      nxv16i16       = 125,  // n x 16 x i16\n      nxv32i16       = 126,  // n x 32 x i16\n\n      nxv1i32        = 127,  // n x  1 x i32\n      nxv2i32        = 128,  // n x  2 x i32\n      nxv4i32        = 129,  // n x  4 x i32\n      nxv8i32        = 130,  // n x  8 x i32\n      nxv16i32       = 131,  // n x 16 x i32\n      nxv32i32       = 132,  // n x 32 x i32\n\n      nxv1i64        = 133,  // n x  1 x i64\n      nxv2i64        = 134,  // n x  2 x i64\n      nxv4i64        = 135,  // n x  4 x i64\n      nxv8i64        = 136,  // n x  8 x i64\n      nxv16i64       = 137,  // n x 16 x i64\n      nxv32i64       = 138,  // n x 32 x i64\n\n      FIRST_INTEGER_SCALABLE_VECTOR_VALUETYPE = nxv1i1,\n      LAST_INTEGER_SCALABLE_VECTOR_VALUETYPE = nxv32i64,\n\n      nxv1f16        = 139,   // n x   1 x f16\n      nxv2f16        = 140,  // n x  2 x f16\n      nxv4f16        = 141,  // n x  4 x f16\n      nxv8f16        = 142,  // n x  8 x f16\n      nxv16f16       = 143,   // n x  16 x f16\n      nxv32f16       = 144,   // n x  32 x f16\n      nxv1bf16       = 145,  // n x  1 x bf16\n      nxv2bf16       = 146,  // n x  2 x bf16\n      nxv4bf16       = 147,  // n x  4 x bf16\n      nxv8bf16       = 148,  // n x  8 x bf16\n      nxv1f32        = 149,  // n x  1 x f32\n      nxv2f32        = 150,  // n x  2 x f32\n      nxv4f32        = 151,  // n x  4 x f32\n      nxv8f32        = 152,  // n x  8 x f32\n      nxv16f32       = 153,  // n x 16 x f32\n      nxv1f64        = 154,  // n x  1 x f64\n      nxv2f64        = 155,  // n x  2 x f64\n      nxv4f64        = 156,  // n x  4 x f64\n      nxv8f64        = 157,  // n x  8 x f64\n\n      FIRST_FP_SCALABLE_VECTOR_VALUETYPE = nxv1f16,\n      LAST_FP_SCALABLE_VECTOR_VALUETYPE = nxv8f64,\n\n      FIRST_SCALABLE_VECTOR_VALUETYPE = nxv1i1,\n      LAST_SCALABLE_VECTOR_VALUETYPE = nxv8f64,\n\n      FIRST_VECTOR_VALUETYPE = v1i1,\n      LAST_VECTOR_VALUETYPE  = nxv8f64,\n\n      x86mmx         = 158,   // This is an X86 MMX value\n\n      Glue           = 159,   // This glues nodes together during pre-RA sched\n\n      isVoid         = 160,   // This has no value\n\n      Untyped        = 161,   // This value takes a register, but has\n                              // unspecified type.  The register class\n                              // will be determined by the opcode.\n\n      funcref        = 162,   // WebAssembly's funcref type\n      externref      = 163,   // WebAssembly's externref type\n      x86amx         = 164,   // This is an X86 AMX value\n\n      FIRST_VALUETYPE =  1,   // This is always the beginning of the list.\n      LAST_VALUETYPE = 165,   // This always remains at the end of the list.\n\n      // This is the current maximum for LAST_VALUETYPE.\n      // MVT::MAX_ALLOWED_VALUETYPE is used for asserts and to size bit vectors\n      // This value must be a multiple of 32.\n      MAX_ALLOWED_VALUETYPE = 192,\n\n      // A value of type llvm::TokenTy\n      token          = 248,\n\n      // This is MDNode or MDString.\n      Metadata       = 249,\n\n      // An int value the size of the pointer of the current\n      // target to any address space. This must only be used internal to\n      // tblgen. Other than for overloading, we treat iPTRAny the same as iPTR.\n      iPTRAny        = 250,\n\n      // A vector with any length and element size. This is used\n      // for intrinsics that have overloadings based on vector types.\n      // This is only for tblgen's consumption!\n      vAny           = 251,\n\n      // Any floating-point or vector floating-point value. This is used\n      // for intrinsics that have overloadings based on floating-point types.\n      // This is only for tblgen's consumption!\n      fAny           = 252,\n\n      // An integer or vector integer value of any bit width. This is\n      // used for intrinsics that have overloadings based on integer bit widths.\n      // This is only for tblgen's consumption!\n      iAny           = 253,\n\n      // An int value the size of the pointer of the current\n      // target.  This should only be used internal to tblgen!\n      iPTR           = 254,\n\n      // Any type. This is used for intrinsics that have overloadings.\n      // This is only for tblgen's consumption!\n      Any            = 255\n    };\n\n    SimpleValueType SimpleTy = INVALID_SIMPLE_VALUE_TYPE;\n\n    constexpr MVT() = default;\n    constexpr MVT(SimpleValueType SVT) : SimpleTy(SVT) {}\n\n    bool operator>(const MVT& S)  const { return SimpleTy >  S.SimpleTy; }\n    bool operator<(const MVT& S)  const { return SimpleTy <  S.SimpleTy; }\n    bool operator==(const MVT& S) const { return SimpleTy == S.SimpleTy; }\n    bool operator!=(const MVT& S) const { return SimpleTy != S.SimpleTy; }\n    bool operator>=(const MVT& S) const { return SimpleTy >= S.SimpleTy; }\n    bool operator<=(const MVT& S) const { return SimpleTy <= S.SimpleTy; }\n\n    /// Return true if this is a valid simple valuetype.\n    bool isValid() const {\n      return (SimpleTy >= MVT::FIRST_VALUETYPE &&\n              SimpleTy < MVT::LAST_VALUETYPE);\n    }\n\n    /// Return true if this is a FP or a vector FP type.\n    bool isFloatingPoint() const {\n      return ((SimpleTy >= MVT::FIRST_FP_VALUETYPE &&\n               SimpleTy <= MVT::LAST_FP_VALUETYPE) ||\n              (SimpleTy >= MVT::FIRST_FP_FIXEDLEN_VECTOR_VALUETYPE &&\n               SimpleTy <= MVT::LAST_FP_FIXEDLEN_VECTOR_VALUETYPE) ||\n              (SimpleTy >= MVT::FIRST_FP_SCALABLE_VECTOR_VALUETYPE &&\n               SimpleTy <= MVT::LAST_FP_SCALABLE_VECTOR_VALUETYPE));\n    }\n\n    /// Return true if this is an integer or a vector integer type.\n    bool isInteger() const {\n      return ((SimpleTy >= MVT::FIRST_INTEGER_VALUETYPE &&\n               SimpleTy <= MVT::LAST_INTEGER_VALUETYPE) ||\n              (SimpleTy >= MVT::FIRST_INTEGER_FIXEDLEN_VECTOR_VALUETYPE &&\n               SimpleTy <= MVT::LAST_INTEGER_FIXEDLEN_VECTOR_VALUETYPE) ||\n              (SimpleTy >= MVT::FIRST_INTEGER_SCALABLE_VECTOR_VALUETYPE &&\n               SimpleTy <= MVT::LAST_INTEGER_SCALABLE_VECTOR_VALUETYPE));\n    }\n\n    /// Return true if this is an integer, not including vectors.\n    bool isScalarInteger() const {\n      return (SimpleTy >= MVT::FIRST_INTEGER_VALUETYPE &&\n              SimpleTy <= MVT::LAST_INTEGER_VALUETYPE);\n    }\n\n    /// Return true if this is a vector value type.\n    bool isVector() const {\n      return (SimpleTy >= MVT::FIRST_VECTOR_VALUETYPE &&\n              SimpleTy <= MVT::LAST_VECTOR_VALUETYPE);\n    }\n\n    /// Return true if this is a vector value type where the\n    /// runtime length is machine dependent\n    bool isScalableVector() const {\n      return (SimpleTy >= MVT::FIRST_SCALABLE_VECTOR_VALUETYPE &&\n              SimpleTy <= MVT::LAST_SCALABLE_VECTOR_VALUETYPE);\n    }\n\n    bool isFixedLengthVector() const {\n      return (SimpleTy >= MVT::FIRST_FIXEDLEN_VECTOR_VALUETYPE &&\n              SimpleTy <= MVT::LAST_FIXEDLEN_VECTOR_VALUETYPE);\n    }\n\n    /// Return true if this is a 16-bit vector type.\n    bool is16BitVector() const {\n      return (SimpleTy == MVT::v2i8  || SimpleTy == MVT::v1i16 ||\n              SimpleTy == MVT::v16i1);\n    }\n\n    /// Return true if this is a 32-bit vector type.\n    bool is32BitVector() const {\n      return (SimpleTy == MVT::v32i1 || SimpleTy == MVT::v4i8   ||\n              SimpleTy == MVT::v2i16 || SimpleTy == MVT::v1i32  ||\n              SimpleTy == MVT::v2f16 || SimpleTy == MVT::v2bf16 ||\n              SimpleTy == MVT::v1f32);\n    }\n\n    /// Return true if this is a 64-bit vector type.\n    bool is64BitVector() const {\n      return (SimpleTy == MVT::v64i1  || SimpleTy == MVT::v8i8  ||\n              SimpleTy == MVT::v4i16  || SimpleTy == MVT::v2i32 ||\n              SimpleTy == MVT::v1i64  || SimpleTy == MVT::v4f16 ||\n              SimpleTy == MVT::v4bf16 ||SimpleTy == MVT::v2f32  ||\n              SimpleTy == MVT::v1f64);\n    }\n\n    /// Return true if this is a 128-bit vector type.\n    bool is128BitVector() const {\n      return (SimpleTy == MVT::v128i1 || SimpleTy == MVT::v16i8  ||\n              SimpleTy == MVT::v8i16  || SimpleTy == MVT::v4i32  ||\n              SimpleTy == MVT::v2i64  || SimpleTy == MVT::v1i128 ||\n              SimpleTy == MVT::v8f16  || SimpleTy == MVT::v8bf16 ||\n              SimpleTy == MVT::v4f32  || SimpleTy == MVT::v2f64);\n    }\n\n    /// Return true if this is a 256-bit vector type.\n    bool is256BitVector() const {\n      return (SimpleTy == MVT::v16f16 || SimpleTy == MVT::v16bf16 ||\n              SimpleTy == MVT::v8f32  || SimpleTy == MVT::v4f64   ||\n              SimpleTy == MVT::v32i8  || SimpleTy == MVT::v16i16  ||\n              SimpleTy == MVT::v8i32  || SimpleTy == MVT::v4i64   ||\n              SimpleTy == MVT::v256i1);\n    }\n\n    /// Return true if this is a 512-bit vector type.\n    bool is512BitVector() const {\n      return (SimpleTy == MVT::v32f16 || SimpleTy == MVT::v32bf16 ||\n              SimpleTy == MVT::v16f32 || SimpleTy == MVT::v8f64   ||\n              SimpleTy == MVT::v512i1 || SimpleTy == MVT::v64i8   ||\n              SimpleTy == MVT::v32i16 || SimpleTy == MVT::v16i32  ||\n              SimpleTy == MVT::v8i64);\n    }\n\n    /// Return true if this is a 1024-bit vector type.\n    bool is1024BitVector() const {\n      return (SimpleTy == MVT::v1024i1 || SimpleTy == MVT::v128i8 ||\n              SimpleTy == MVT::v64i16  || SimpleTy == MVT::v32i32 ||\n              SimpleTy == MVT::v16i64  || SimpleTy == MVT::v64f16 ||\n              SimpleTy == MVT::v32f32  || SimpleTy == MVT::v16f64 ||\n              SimpleTy == MVT::v64bf16);\n    }\n\n    /// Return true if this is a 2048-bit vector type.\n    bool is2048BitVector() const {\n      return (SimpleTy == MVT::v256i8  || SimpleTy == MVT::v128i16 ||\n              SimpleTy == MVT::v64i32  || SimpleTy == MVT::v32i64  ||\n              SimpleTy == MVT::v128f16 || SimpleTy == MVT::v64f32  ||\n              SimpleTy == MVT::v32f64  || SimpleTy == MVT::v128bf16);\n    }\n\n    /// Return true if this is an overloaded type for TableGen.\n    bool isOverloaded() const {\n      return (SimpleTy == MVT::Any || SimpleTy == MVT::iAny ||\n              SimpleTy == MVT::fAny || SimpleTy == MVT::vAny ||\n              SimpleTy == MVT::iPTRAny);\n    }\n\n    /// Return a vector with the same number of elements as this vector, but\n    /// with the element type converted to an integer type with the same\n    /// bitwidth.\n    MVT changeVectorElementTypeToInteger() const {\n      MVT EltTy = getVectorElementType();\n      MVT IntTy = MVT::getIntegerVT(EltTy.getSizeInBits());\n      MVT VecTy = MVT::getVectorVT(IntTy, getVectorElementCount());\n      assert(VecTy.SimpleTy != MVT::INVALID_SIMPLE_VALUE_TYPE &&\n             \"Simple vector VT not representable by simple integer vector VT!\");\n      return VecTy;\n    }\n\n    /// Return a VT for a vector type whose attributes match ourselves\n    /// with the exception of the element type that is chosen by the caller.\n    MVT changeVectorElementType(MVT EltVT) const {\n      MVT VecTy = MVT::getVectorVT(EltVT, getVectorElementCount());\n      assert(VecTy.SimpleTy != MVT::INVALID_SIMPLE_VALUE_TYPE &&\n             \"Simple vector VT not representable by simple integer vector VT!\");\n      return VecTy;\n    }\n\n    /// Return the type converted to an equivalently sized integer or vector\n    /// with integer element type. Similar to changeVectorElementTypeToInteger,\n    /// but also handles scalars.\n    MVT changeTypeToInteger() {\n      if (isVector())\n        return changeVectorElementTypeToInteger();\n      return MVT::getIntegerVT(getSizeInBits());\n    }\n\n    /// Return a VT for a vector type with the same element type but\n    /// half the number of elements.\n    MVT getHalfNumVectorElementsVT() const {\n      MVT EltVT = getVectorElementType();\n      auto EltCnt = getVectorElementCount();\n      assert(EltCnt.isKnownEven() && \"Splitting vector, but not in half!\");\n      return getVectorVT(EltVT, EltCnt.divideCoefficientBy(2));\n    }\n\n    /// Returns true if the given vector is a power of 2.\n    bool isPow2VectorType() const {\n      unsigned NElts = getVectorNumElements();\n      return !(NElts & (NElts - 1));\n    }\n\n    /// Widens the length of the given vector MVT up to the nearest power of 2\n    /// and returns that type.\n    MVT getPow2VectorType() const {\n      if (isPow2VectorType())\n        return *this;\n\n      unsigned NElts = getVectorNumElements();\n      unsigned Pow2NElts = 1 << Log2_32_Ceil(NElts);\n      return MVT::getVectorVT(getVectorElementType(), Pow2NElts);\n    }\n\n    /// If this is a vector, return the element type, otherwise return this.\n    MVT getScalarType() const {\n      return isVector() ? getVectorElementType() : *this;\n    }\n\n    MVT getVectorElementType() const {\n      switch (SimpleTy) {\n      default:\n        llvm_unreachable(\"Not a vector MVT!\");\n      case v1i1:\n      case v2i1:\n      case v4i1:\n      case v8i1:\n      case v16i1:\n      case v32i1:\n      case v64i1:\n      case v128i1:\n      case v256i1:\n      case v512i1:\n      case v1024i1:\n      case nxv1i1:\n      case nxv2i1:\n      case nxv4i1:\n      case nxv8i1:\n      case nxv16i1:\n      case nxv32i1:\n      case nxv64i1: return i1;\n      case v1i8:\n      case v2i8:\n      case v4i8:\n      case v8i8:\n      case v16i8:\n      case v32i8:\n      case v64i8:\n      case v128i8:\n      case v256i8:\n      case nxv1i8:\n      case nxv2i8:\n      case nxv4i8:\n      case nxv8i8:\n      case nxv16i8:\n      case nxv32i8:\n      case nxv64i8: return i8;\n      case v1i16:\n      case v2i16:\n      case v3i16:\n      case v4i16:\n      case v8i16:\n      case v16i16:\n      case v32i16:\n      case v64i16:\n      case v128i16:\n      case nxv1i16:\n      case nxv2i16:\n      case nxv4i16:\n      case nxv8i16:\n      case nxv16i16:\n      case nxv32i16: return i16;\n      case v1i32:\n      case v2i32:\n      case v3i32:\n      case v4i32:\n      case v5i32:\n      case v8i32:\n      case v16i32:\n      case v32i32:\n      case v64i32:\n      case v128i32:\n      case v256i32:\n      case v512i32:\n      case v1024i32:\n      case v2048i32:\n      case nxv1i32:\n      case nxv2i32:\n      case nxv4i32:\n      case nxv8i32:\n      case nxv16i32:\n      case nxv32i32: return i32;\n      case v1i64:\n      case v2i64:\n      case v4i64:\n      case v8i64:\n      case v16i64:\n      case v32i64:\n      case v64i64:\n      case v128i64:\n      case v256i64:\n      case nxv1i64:\n      case nxv2i64:\n      case nxv4i64:\n      case nxv8i64:\n      case nxv16i64:\n      case nxv32i64: return i64;\n      case v1i128: return i128;\n      case v2f16:\n      case v3f16:\n      case v4f16:\n      case v8f16:\n      case v16f16:\n      case v32f16:\n      case v64f16:\n      case v128f16:\n      case nxv1f16:\n      case nxv2f16:\n      case nxv4f16:\n      case nxv8f16:\n      case nxv16f16:\n      case nxv32f16: return f16;\n      case v2bf16:\n      case v3bf16:\n      case v4bf16:\n      case v8bf16:\n      case v16bf16:\n      case v32bf16:\n      case v64bf16:\n      case v128bf16:\n      case nxv1bf16:\n      case nxv2bf16:\n      case nxv4bf16:\n      case nxv8bf16: return bf16;\n      case v1f32:\n      case v2f32:\n      case v3f32:\n      case v4f32:\n      case v5f32:\n      case v8f32:\n      case v16f32:\n      case v32f32:\n      case v64f32:\n      case v128f32:\n      case v256f32:\n      case v512f32:\n      case v1024f32:\n      case v2048f32:\n      case nxv1f32:\n      case nxv2f32:\n      case nxv4f32:\n      case nxv8f32:\n      case nxv16f32: return f32;\n      case v1f64:\n      case v2f64:\n      case v4f64:\n      case v8f64:\n      case v16f64:\n      case v32f64:\n      case v64f64:\n      case v128f64:\n      case v256f64:\n      case nxv1f64:\n      case nxv2f64:\n      case nxv4f64:\n      case nxv8f64: return f64;\n      }\n    }\n\n    unsigned getVectorNumElements() const {\n      switch (SimpleTy) {\n      default:\n        llvm_unreachable(\"Not a vector MVT!\");\n      case v2048i32:\n      case v2048f32: return 2048;\n      case v1024i1:\n      case v1024i32:\n      case v1024f32: return 1024;\n      case v512i1:\n      case v512i32:\n      case v512f32: return 512;\n      case v256i1:\n      case v256i8:\n      case v256i32:\n      case v256i64:\n      case v256f32:\n      case v256f64: return 256;\n      case v128i1:\n      case v128i8:\n      case v128i16:\n      case v128i32:\n      case v128i64:\n      case v128f16:\n      case v128bf16:\n      case v128f32:\n      case v128f64: return 128;\n      case v64i1:\n      case v64i8:\n      case v64i16:\n      case v64i32:\n      case v64i64:\n      case v64f16:\n      case v64bf16:\n      case v64f32:\n      case v64f64:\n      case nxv64i1:\n      case nxv64i8: return 64;\n      case v32i1:\n      case v32i8:\n      case v32i16:\n      case v32i32:\n      case v32i64:\n      case v32f16:\n      case v32bf16:\n      case v32f32:\n      case v32f64:\n      case nxv32i1:\n      case nxv32i8:\n      case nxv32i16:\n      case nxv32i32:\n      case nxv32i64:\n      case nxv32f16: return 32;\n      case v16i1:\n      case v16i8:\n      case v16i16:\n      case v16i32:\n      case v16i64:\n      case v16f16:\n      case v16bf16:\n      case v16f32:\n      case v16f64:\n      case nxv16i1:\n      case nxv16i8:\n      case nxv16i16:\n      case nxv16i32:\n      case nxv16i64:\n      case nxv16f16:\n      case nxv16f32: return 16;\n      case v8i1:\n      case v8i8:\n      case v8i16:\n      case v8i32:\n      case v8i64:\n      case v8f16:\n      case v8bf16:\n      case v8f32:\n      case v8f64:\n      case nxv8i1:\n      case nxv8i8:\n      case nxv8i16:\n      case nxv8i32:\n      case nxv8i64:\n      case nxv8f16:\n      case nxv8bf16:\n      case nxv8f32:\n      case nxv8f64: return 8;\n      case v5i32:\n      case v5f32: return 5;\n      case v4i1:\n      case v4i8:\n      case v4i16:\n      case v4i32:\n      case v4i64:\n      case v4f16:\n      case v4bf16:\n      case v4f32:\n      case v4f64:\n      case nxv4i1:\n      case nxv4i8:\n      case nxv4i16:\n      case nxv4i32:\n      case nxv4i64:\n      case nxv4f16:\n      case nxv4bf16:\n      case nxv4f32:\n      case nxv4f64: return 4;\n      case v3i16:\n      case v3i32:\n      case v3f16:\n      case v3bf16:\n      case v3f32: return 3;\n      case v2i1:\n      case v2i8:\n      case v2i16:\n      case v2i32:\n      case v2i64:\n      case v2f16:\n      case v2bf16:\n      case v2f32:\n      case v2f64:\n      case nxv2i1:\n      case nxv2i8:\n      case nxv2i16:\n      case nxv2i32:\n      case nxv2i64:\n      case nxv2f16:\n      case nxv2bf16:\n      case nxv2f32:\n      case nxv2f64: return 2;\n      case v1i1:\n      case v1i8:\n      case v1i16:\n      case v1i32:\n      case v1i64:\n      case v1i128:\n      case v1f32:\n      case v1f64:\n      case nxv1i1:\n      case nxv1i8:\n      case nxv1i16:\n      case nxv1i32:\n      case nxv1i64:\n      case nxv1f16:\n      case nxv1bf16:\n      case nxv1f32:\n      case nxv1f64: return 1;\n      }\n    }\n\n    ElementCount getVectorElementCount() const {\n      return ElementCount::get(getVectorNumElements(), isScalableVector());\n    }\n\n    /// Given a vector type, return the minimum number of elements it contains.\n    unsigned getVectorMinNumElements() const {\n      return getVectorElementCount().getKnownMinValue();\n    }\n\n    /// Returns the size of the specified MVT in bits.\n    ///\n    /// If the value type is a scalable vector type, the scalable property will\n    /// be set and the runtime size will be a positive integer multiple of the\n    /// base size.\n    TypeSize getSizeInBits() const {\n      switch (SimpleTy) {\n      default:\n        llvm_unreachable(\"getSizeInBits called on extended MVT.\");\n      case Other:\n        llvm_unreachable(\"Value type is non-standard value, Other.\");\n      case iPTR:\n        llvm_unreachable(\"Value type size is target-dependent. Ask TLI.\");\n      case iPTRAny:\n      case iAny:\n      case fAny:\n      case vAny:\n      case Any:\n        llvm_unreachable(\"Value type is overloaded.\");\n      case token:\n        llvm_unreachable(\"Token type is a sentinel that cannot be used \"\n                         \"in codegen and has no size\");\n      case Metadata:\n        llvm_unreachable(\"Value type is metadata.\");\n      case i1:\n      case v1i1: return TypeSize::Fixed(1);\n      case nxv1i1: return TypeSize::Scalable(1);\n      case v2i1: return TypeSize::Fixed(2);\n      case nxv2i1: return TypeSize::Scalable(2);\n      case v4i1: return TypeSize::Fixed(4);\n      case nxv4i1: return TypeSize::Scalable(4);\n      case i8  :\n      case v1i8:\n      case v8i1: return TypeSize::Fixed(8);\n      case nxv1i8:\n      case nxv8i1: return TypeSize::Scalable(8);\n      case i16 :\n      case f16:\n      case bf16:\n      case v16i1:\n      case v2i8:\n      case v1i16: return TypeSize::Fixed(16);\n      case nxv16i1:\n      case nxv2i8:\n      case nxv1i16:\n      case nxv1bf16:\n      case nxv1f16: return TypeSize::Scalable(16);\n      case f32 :\n      case i32 :\n      case v32i1:\n      case v4i8:\n      case v2i16:\n      case v2f16:\n      case v2bf16:\n      case v1f32:\n      case v1i32: return TypeSize::Fixed(32);\n      case nxv32i1:\n      case nxv4i8:\n      case nxv2i16:\n      case nxv1i32:\n      case nxv2f16:\n      case nxv2bf16:\n      case nxv1f32: return TypeSize::Scalable(32);\n      case v3i16:\n      case v3f16:\n      case v3bf16: return TypeSize::Fixed(48);\n      case x86mmx:\n      case f64 :\n      case i64 :\n      case v64i1:\n      case v8i8:\n      case v4i16:\n      case v2i32:\n      case v1i64:\n      case v4f16:\n      case v4bf16:\n      case v2f32:\n      case v1f64: return TypeSize::Fixed(64);\n      case nxv64i1:\n      case nxv8i8:\n      case nxv4i16:\n      case nxv2i32:\n      case nxv1i64:\n      case nxv4f16:\n      case nxv4bf16:\n      case nxv2f32:\n      case nxv1f64: return TypeSize::Scalable(64);\n      case f80 :  return TypeSize::Fixed(80);\n      case v3i32:\n      case v3f32: return TypeSize::Fixed(96);\n      case f128:\n      case ppcf128:\n      case i128:\n      case v128i1:\n      case v16i8:\n      case v8i16:\n      case v4i32:\n      case v2i64:\n      case v1i128:\n      case v8f16:\n      case v8bf16:\n      case v4f32:\n      case v2f64: return TypeSize::Fixed(128);\n      case nxv16i8:\n      case nxv8i16:\n      case nxv4i32:\n      case nxv2i64:\n      case nxv8f16:\n      case nxv8bf16:\n      case nxv4f32:\n      case nxv2f64: return TypeSize::Scalable(128);\n      case v5i32:\n      case v5f32: return TypeSize::Fixed(160);\n      case v256i1:\n      case v32i8:\n      case v16i16:\n      case v8i32:\n      case v4i64:\n      case v16f16:\n      case v16bf16:\n      case v8f32:\n      case v4f64: return TypeSize::Fixed(256);\n      case nxv32i8:\n      case nxv16i16:\n      case nxv8i32:\n      case nxv4i64:\n      case nxv16f16:\n      case nxv8f32:\n      case nxv4f64: return TypeSize::Scalable(256);\n      case v512i1:\n      case v64i8:\n      case v32i16:\n      case v16i32:\n      case v8i64:\n      case v32f16:\n      case v32bf16:\n      case v16f32:\n      case v8f64: return TypeSize::Fixed(512);\n      case nxv64i8:\n      case nxv32i16:\n      case nxv16i32:\n      case nxv8i64:\n      case nxv32f16:\n      case nxv16f32:\n      case nxv8f64: return TypeSize::Scalable(512);\n      case v1024i1:\n      case v128i8:\n      case v64i16:\n      case v32i32:\n      case v16i64:\n      case v64f16:\n      case v64bf16:\n      case v32f32:\n      case v16f64: return TypeSize::Fixed(1024);\n      case nxv32i32:\n      case nxv16i64: return TypeSize::Scalable(1024);\n      case v256i8:\n      case v128i16:\n      case v64i32:\n      case v32i64:\n      case v128f16:\n      case v128bf16:\n      case v64f32:\n      case v32f64: return TypeSize::Fixed(2048);\n      case nxv32i64: return TypeSize::Scalable(2048);\n      case v128i32:\n      case v64i64:\n      case v128f32:\n      case v64f64:  return TypeSize::Fixed(4096);\n      case v256i32:\n      case v128i64:\n      case v256f32:\n      case x86amx:\n      case v128f64:  return TypeSize::Fixed(8192);\n      case v512i32:\n      case v256i64:\n      case v512f32:\n      case v256f64:  return TypeSize::Fixed(16384);\n      case v1024i32:\n      case v1024f32:  return TypeSize::Fixed(32768);\n      case v2048i32:\n      case v2048f32:  return TypeSize::Fixed(65536);\n      case funcref:\n      case externref: return TypeSize::Fixed(0); // opaque type\n      }\n    }\n\n    /// Return the size of the specified fixed width value type in bits. The\n    /// function will assert if the type is scalable.\n    uint64_t getFixedSizeInBits() const {\n      return getSizeInBits().getFixedSize();\n    }\n\n    uint64_t getScalarSizeInBits() const {\n      return getScalarType().getSizeInBits().getFixedSize();\n    }\n\n    /// Return the number of bytes overwritten by a store of the specified value\n    /// type.\n    ///\n    /// If the value type is a scalable vector type, the scalable property will\n    /// be set and the runtime size will be a positive integer multiple of the\n    /// base size.\n    TypeSize getStoreSize() const {\n      TypeSize BaseSize = getSizeInBits();\n      return {(BaseSize.getKnownMinSize() + 7) / 8, BaseSize.isScalable()};\n    }\n\n    /// Return the number of bits overwritten by a store of the specified value\n    /// type.\n    ///\n    /// If the value type is a scalable vector type, the scalable property will\n    /// be set and the runtime size will be a positive integer multiple of the\n    /// base size.\n    TypeSize getStoreSizeInBits() const {\n      return getStoreSize() * 8;\n    }\n\n    /// Returns true if the number of bits for the type is a multiple of an\n    /// 8-bit byte.\n    bool isByteSized() const { return getSizeInBits().isKnownMultipleOf(8); }\n\n    /// Return true if we know at compile time this has more bits than VT.\n    bool knownBitsGT(MVT VT) const {\n      return TypeSize::isKnownGT(getSizeInBits(), VT.getSizeInBits());\n    }\n\n    /// Return true if we know at compile time this has more than or the same\n    /// bits as VT.\n    bool knownBitsGE(MVT VT) const {\n      return TypeSize::isKnownGE(getSizeInBits(), VT.getSizeInBits());\n    }\n\n    /// Return true if we know at compile time this has fewer bits than VT.\n    bool knownBitsLT(MVT VT) const {\n      return TypeSize::isKnownLT(getSizeInBits(), VT.getSizeInBits());\n    }\n\n    /// Return true if we know at compile time this has fewer than or the same\n    /// bits as VT.\n    bool knownBitsLE(MVT VT) const {\n      return TypeSize::isKnownLE(getSizeInBits(), VT.getSizeInBits());\n    }\n\n    /// Return true if this has more bits than VT.\n    bool bitsGT(MVT VT) const {\n      assert(isScalableVector() == VT.isScalableVector() &&\n             \"Comparison between scalable and fixed types\");\n      return knownBitsGT(VT);\n    }\n\n    /// Return true if this has no less bits than VT.\n    bool bitsGE(MVT VT) const {\n      assert(isScalableVector() == VT.isScalableVector() &&\n             \"Comparison between scalable and fixed types\");\n      return knownBitsGE(VT);\n    }\n\n    /// Return true if this has less bits than VT.\n    bool bitsLT(MVT VT) const {\n      assert(isScalableVector() == VT.isScalableVector() &&\n             \"Comparison between scalable and fixed types\");\n      return knownBitsLT(VT);\n    }\n\n    /// Return true if this has no more bits than VT.\n    bool bitsLE(MVT VT) const {\n      assert(isScalableVector() == VT.isScalableVector() &&\n             \"Comparison between scalable and fixed types\");\n      return knownBitsLE(VT);\n    }\n\n    static MVT getFloatingPointVT(unsigned BitWidth) {\n      switch (BitWidth) {\n      default:\n        llvm_unreachable(\"Bad bit width!\");\n      case 16:\n        return MVT::f16;\n      case 32:\n        return MVT::f32;\n      case 64:\n        return MVT::f64;\n      case 80:\n        return MVT::f80;\n      case 128:\n        return MVT::f128;\n      }\n    }\n\n    static MVT getIntegerVT(unsigned BitWidth) {\n      switch (BitWidth) {\n      default:\n        return (MVT::SimpleValueType)(MVT::INVALID_SIMPLE_VALUE_TYPE);\n      case 1:\n        return MVT::i1;\n      case 8:\n        return MVT::i8;\n      case 16:\n        return MVT::i16;\n      case 32:\n        return MVT::i32;\n      case 64:\n        return MVT::i64;\n      case 128:\n        return MVT::i128;\n      }\n    }\n\n    static MVT getVectorVT(MVT VT, unsigned NumElements) {\n      switch (VT.SimpleTy) {\n      default:\n        break;\n      case MVT::i1:\n        if (NumElements == 1)    return MVT::v1i1;\n        if (NumElements == 2)    return MVT::v2i1;\n        if (NumElements == 4)    return MVT::v4i1;\n        if (NumElements == 8)    return MVT::v8i1;\n        if (NumElements == 16)   return MVT::v16i1;\n        if (NumElements == 32)   return MVT::v32i1;\n        if (NumElements == 64)   return MVT::v64i1;\n        if (NumElements == 128)  return MVT::v128i1;\n        if (NumElements == 256)  return MVT::v256i1;\n        if (NumElements == 512)  return MVT::v512i1;\n        if (NumElements == 1024) return MVT::v1024i1;\n        break;\n      case MVT::i8:\n        if (NumElements == 1)   return MVT::v1i8;\n        if (NumElements == 2)   return MVT::v2i8;\n        if (NumElements == 4)   return MVT::v4i8;\n        if (NumElements == 8)   return MVT::v8i8;\n        if (NumElements == 16)  return MVT::v16i8;\n        if (NumElements == 32)  return MVT::v32i8;\n        if (NumElements == 64)  return MVT::v64i8;\n        if (NumElements == 128) return MVT::v128i8;\n        if (NumElements == 256) return MVT::v256i8;\n        break;\n      case MVT::i16:\n        if (NumElements == 1)   return MVT::v1i16;\n        if (NumElements == 2)   return MVT::v2i16;\n        if (NumElements == 3)   return MVT::v3i16;\n        if (NumElements == 4)   return MVT::v4i16;\n        if (NumElements == 8)   return MVT::v8i16;\n        if (NumElements == 16)  return MVT::v16i16;\n        if (NumElements == 32)  return MVT::v32i16;\n        if (NumElements == 64)  return MVT::v64i16;\n        if (NumElements == 128) return MVT::v128i16;\n        break;\n      case MVT::i32:\n        if (NumElements == 1)    return MVT::v1i32;\n        if (NumElements == 2)    return MVT::v2i32;\n        if (NumElements == 3)    return MVT::v3i32;\n        if (NumElements == 4)    return MVT::v4i32;\n        if (NumElements == 5)    return MVT::v5i32;\n        if (NumElements == 8)    return MVT::v8i32;\n        if (NumElements == 16)   return MVT::v16i32;\n        if (NumElements == 32)   return MVT::v32i32;\n        if (NumElements == 64)   return MVT::v64i32;\n        if (NumElements == 128)  return MVT::v128i32;\n        if (NumElements == 256)  return MVT::v256i32;\n        if (NumElements == 512)  return MVT::v512i32;\n        if (NumElements == 1024) return MVT::v1024i32;\n        if (NumElements == 2048) return MVT::v2048i32;\n        break;\n      case MVT::i64:\n        if (NumElements == 1)  return MVT::v1i64;\n        if (NumElements == 2)  return MVT::v2i64;\n        if (NumElements == 4)  return MVT::v4i64;\n        if (NumElements == 8)  return MVT::v8i64;\n        if (NumElements == 16) return MVT::v16i64;\n        if (NumElements == 32) return MVT::v32i64;\n        if (NumElements == 64) return MVT::v64i64;\n        if (NumElements == 128) return MVT::v128i64;\n        if (NumElements == 256) return MVT::v256i64;\n        break;\n      case MVT::i128:\n        if (NumElements == 1)  return MVT::v1i128;\n        break;\n      case MVT::f16:\n        if (NumElements == 2)   return MVT::v2f16;\n        if (NumElements == 3)   return MVT::v3f16;\n        if (NumElements == 4)   return MVT::v4f16;\n        if (NumElements == 8)   return MVT::v8f16;\n        if (NumElements == 16)  return MVT::v16f16;\n        if (NumElements == 32)  return MVT::v32f16;\n        if (NumElements == 64)  return MVT::v64f16;\n        if (NumElements == 128) return MVT::v128f16;\n        break;\n      case MVT::bf16:\n        if (NumElements == 2)   return MVT::v2bf16;\n        if (NumElements == 3)   return MVT::v3bf16;\n        if (NumElements == 4)   return MVT::v4bf16;\n        if (NumElements == 8)   return MVT::v8bf16;\n        if (NumElements == 16)  return MVT::v16bf16;\n        if (NumElements == 32)  return MVT::v32bf16;\n        if (NumElements == 64)  return MVT::v64bf16;\n        if (NumElements == 128) return MVT::v128bf16;\n        break;\n      case MVT::f32:\n        if (NumElements == 1)    return MVT::v1f32;\n        if (NumElements == 2)    return MVT::v2f32;\n        if (NumElements == 3)    return MVT::v3f32;\n        if (NumElements == 4)    return MVT::v4f32;\n        if (NumElements == 5)    return MVT::v5f32;\n        if (NumElements == 8)    return MVT::v8f32;\n        if (NumElements == 16)   return MVT::v16f32;\n        if (NumElements == 32)   return MVT::v32f32;\n        if (NumElements == 64)   return MVT::v64f32;\n        if (NumElements == 128)  return MVT::v128f32;\n        if (NumElements == 256)  return MVT::v256f32;\n        if (NumElements == 512)  return MVT::v512f32;\n        if (NumElements == 1024) return MVT::v1024f32;\n        if (NumElements == 2048) return MVT::v2048f32;\n        break;\n      case MVT::f64:\n        if (NumElements == 1)  return MVT::v1f64;\n        if (NumElements == 2)  return MVT::v2f64;\n        if (NumElements == 4)  return MVT::v4f64;\n        if (NumElements == 8)  return MVT::v8f64;\n        if (NumElements == 16) return MVT::v16f64;\n        if (NumElements == 32) return MVT::v32f64;\n        if (NumElements == 64) return MVT::v64f64;\n        if (NumElements == 128) return MVT::v128f64;\n        if (NumElements == 256) return MVT::v256f64;\n        break;\n      }\n      return (MVT::SimpleValueType)(MVT::INVALID_SIMPLE_VALUE_TYPE);\n    }\n\n    static MVT getScalableVectorVT(MVT VT, unsigned NumElements) {\n      switch(VT.SimpleTy) {\n        default:\n          break;\n        case MVT::i1:\n          if (NumElements == 1)  return MVT::nxv1i1;\n          if (NumElements == 2)  return MVT::nxv2i1;\n          if (NumElements == 4)  return MVT::nxv4i1;\n          if (NumElements == 8)  return MVT::nxv8i1;\n          if (NumElements == 16) return MVT::nxv16i1;\n          if (NumElements == 32) return MVT::nxv32i1;\n          if (NumElements == 64) return MVT::nxv64i1;\n          break;\n        case MVT::i8:\n          if (NumElements == 1)  return MVT::nxv1i8;\n          if (NumElements == 2)  return MVT::nxv2i8;\n          if (NumElements == 4)  return MVT::nxv4i8;\n          if (NumElements == 8)  return MVT::nxv8i8;\n          if (NumElements == 16) return MVT::nxv16i8;\n          if (NumElements == 32) return MVT::nxv32i8;\n          if (NumElements == 64) return MVT::nxv64i8;\n          break;\n        case MVT::i16:\n          if (NumElements == 1)  return MVT::nxv1i16;\n          if (NumElements == 2)  return MVT::nxv2i16;\n          if (NumElements == 4)  return MVT::nxv4i16;\n          if (NumElements == 8)  return MVT::nxv8i16;\n          if (NumElements == 16) return MVT::nxv16i16;\n          if (NumElements == 32) return MVT::nxv32i16;\n          break;\n        case MVT::i32:\n          if (NumElements == 1)  return MVT::nxv1i32;\n          if (NumElements == 2)  return MVT::nxv2i32;\n          if (NumElements == 4)  return MVT::nxv4i32;\n          if (NumElements == 8)  return MVT::nxv8i32;\n          if (NumElements == 16) return MVT::nxv16i32;\n          if (NumElements == 32) return MVT::nxv32i32;\n          break;\n        case MVT::i64:\n          if (NumElements == 1)  return MVT::nxv1i64;\n          if (NumElements == 2)  return MVT::nxv2i64;\n          if (NumElements == 4)  return MVT::nxv4i64;\n          if (NumElements == 8)  return MVT::nxv8i64;\n          if (NumElements == 16) return MVT::nxv16i64;\n          if (NumElements == 32) return MVT::nxv32i64;\n          break;\n        case MVT::f16:\n          if (NumElements == 1)  return MVT::nxv1f16;\n          if (NumElements == 2)  return MVT::nxv2f16;\n          if (NumElements == 4)  return MVT::nxv4f16;\n          if (NumElements == 8)  return MVT::nxv8f16;\n          if (NumElements == 16)  return MVT::nxv16f16;\n          if (NumElements == 32)  return MVT::nxv32f16;\n          break;\n        case MVT::bf16:\n          if (NumElements == 1)  return MVT::nxv1bf16;\n          if (NumElements == 2)  return MVT::nxv2bf16;\n          if (NumElements == 4)  return MVT::nxv4bf16;\n          if (NumElements == 8)  return MVT::nxv8bf16;\n          break;\n        case MVT::f32:\n          if (NumElements == 1)  return MVT::nxv1f32;\n          if (NumElements == 2)  return MVT::nxv2f32;\n          if (NumElements == 4)  return MVT::nxv4f32;\n          if (NumElements == 8)  return MVT::nxv8f32;\n          if (NumElements == 16) return MVT::nxv16f32;\n          break;\n        case MVT::f64:\n          if (NumElements == 1)  return MVT::nxv1f64;\n          if (NumElements == 2)  return MVT::nxv2f64;\n          if (NumElements == 4)  return MVT::nxv4f64;\n          if (NumElements == 8)  return MVT::nxv8f64;\n          break;\n      }\n      return (MVT::SimpleValueType)(MVT::INVALID_SIMPLE_VALUE_TYPE);\n    }\n\n    static MVT getVectorVT(MVT VT, unsigned NumElements, bool IsScalable) {\n      if (IsScalable)\n        return getScalableVectorVT(VT, NumElements);\n      return getVectorVT(VT, NumElements);\n    }\n\n    static MVT getVectorVT(MVT VT, ElementCount EC) {\n      if (EC.isScalable())\n        return getScalableVectorVT(VT, EC.getKnownMinValue());\n      return getVectorVT(VT, EC.getKnownMinValue());\n    }\n\n    /// Return the value type corresponding to the specified type.  This returns\n    /// all pointers as iPTR.  If HandleUnknown is true, unknown types are\n    /// returned as Other, otherwise they are invalid.\n    static MVT getVT(Type *Ty, bool HandleUnknown = false);\n\n  private:\n    /// A simple iterator over the MVT::SimpleValueType enum.\n    struct mvt_iterator {\n      SimpleValueType VT;\n\n      mvt_iterator(SimpleValueType VT) : VT(VT) {}\n\n      MVT operator*() const { return VT; }\n      bool operator!=(const mvt_iterator &LHS) const { return VT != LHS.VT; }\n\n      mvt_iterator& operator++() {\n        VT = (MVT::SimpleValueType)((int)VT + 1);\n        assert((int)VT <= MVT::MAX_ALLOWED_VALUETYPE &&\n               \"MVT iterator overflowed.\");\n        return *this;\n      }\n    };\n\n    /// A range of the MVT::SimpleValueType enum.\n    using mvt_range = iterator_range<mvt_iterator>;\n\n  public:\n    /// SimpleValueType Iteration\n    /// @{\n    static mvt_range all_valuetypes() {\n      return mvt_range(MVT::FIRST_VALUETYPE, MVT::LAST_VALUETYPE);\n    }\n\n    static mvt_range integer_valuetypes() {\n      return mvt_range(MVT::FIRST_INTEGER_VALUETYPE,\n                       (MVT::SimpleValueType)(MVT::LAST_INTEGER_VALUETYPE + 1));\n    }\n\n    static mvt_range fp_valuetypes() {\n      return mvt_range(MVT::FIRST_FP_VALUETYPE,\n                       (MVT::SimpleValueType)(MVT::LAST_FP_VALUETYPE + 1));\n    }\n\n    static mvt_range vector_valuetypes() {\n      return mvt_range(MVT::FIRST_VECTOR_VALUETYPE,\n                       (MVT::SimpleValueType)(MVT::LAST_VECTOR_VALUETYPE + 1));\n    }\n\n    static mvt_range fixedlen_vector_valuetypes() {\n      return mvt_range(\n               MVT::FIRST_FIXEDLEN_VECTOR_VALUETYPE,\n               (MVT::SimpleValueType)(MVT::LAST_FIXEDLEN_VECTOR_VALUETYPE + 1));\n    }\n\n    static mvt_range scalable_vector_valuetypes() {\n      return mvt_range(\n               MVT::FIRST_SCALABLE_VECTOR_VALUETYPE,\n               (MVT::SimpleValueType)(MVT::LAST_SCALABLE_VECTOR_VALUETYPE + 1));\n    }\n\n    static mvt_range integer_fixedlen_vector_valuetypes() {\n      return mvt_range(\n       MVT::FIRST_INTEGER_FIXEDLEN_VECTOR_VALUETYPE,\n       (MVT::SimpleValueType)(MVT::LAST_INTEGER_FIXEDLEN_VECTOR_VALUETYPE + 1));\n    }\n\n    static mvt_range fp_fixedlen_vector_valuetypes() {\n      return mvt_range(\n          MVT::FIRST_FP_FIXEDLEN_VECTOR_VALUETYPE,\n          (MVT::SimpleValueType)(MVT::LAST_FP_FIXEDLEN_VECTOR_VALUETYPE + 1));\n    }\n\n    static mvt_range integer_scalable_vector_valuetypes() {\n      return mvt_range(\n       MVT::FIRST_INTEGER_SCALABLE_VECTOR_VALUETYPE,\n       (MVT::SimpleValueType)(MVT::LAST_INTEGER_SCALABLE_VECTOR_VALUETYPE + 1));\n    }\n\n    static mvt_range fp_scalable_vector_valuetypes() {\n      return mvt_range(\n            MVT::FIRST_FP_SCALABLE_VECTOR_VALUETYPE,\n            (MVT::SimpleValueType)(MVT::LAST_FP_SCALABLE_VECTOR_VALUETYPE + 1));\n    }\n    /// @}\n  };\n\n} // end namespace llvm\n\n#endif // LLVM_SUPPORT_MACHINEVALUETYPE_H\n"}, "72": {"id": 72, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/Printable.h", "content": "//===--- Printable.h - Print function helpers -------------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n//  This file defines the Printable struct.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_SUPPORT_PRINTABLE_H\n#define LLVM_SUPPORT_PRINTABLE_H\n\n#include <functional>\n\nnamespace llvm {\n\nclass raw_ostream;\n\n/// Simple wrapper around std::function<void(raw_ostream&)>.\n/// This class is useful to construct print helpers for raw_ostream.\n///\n/// Example:\n///     Printable PrintRegister(unsigned Register) {\n///       return Printable([Register](raw_ostream &OS) {\n///         OS << getRegisterName(Register);\n///       }\n///     }\n///     ... OS << PrintRegister(Register); ...\n///\n/// Implementation note: Ideally this would just be a typedef, but doing so\n/// leads to operator << being ambiguous as function has matching constructors\n/// in some STL versions. I have seen the problem on gcc 4.6 libstdc++ and\n/// microsoft STL.\nclass Printable {\npublic:\n  std::function<void(raw_ostream &OS)> Print;\n  Printable(std::function<void(raw_ostream &OS)> Print)\n      : Print(std::move(Print)) {}\n};\n\ninline raw_ostream &operator<<(raw_ostream &OS, const Printable &P) {\n  P.Print(OS);\n  return OS;\n}\n\n}\n\n#endif\n"}, "77": {"id": 77, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/TypeSize.h", "content": "//===- TypeSize.h - Wrapper around type sizes -------------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// This file provides a struct that can be used to query the size of IR types\n// which may be scalable vectors. It provides convenience operators so that\n// it can be used in much the same way as a single scalar value.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_SUPPORT_TYPESIZE_H\n#define LLVM_SUPPORT_TYPESIZE_H\n\n#include \"llvm/ADT/ArrayRef.h\"\n#include \"llvm/Support/MathExtras.h\"\n#include \"llvm/Support/WithColor.h\"\n\n#include <algorithm>\n#include <array>\n#include <cassert>\n#include <cstdint>\n#include <type_traits>\n\nnamespace llvm {\n\ntemplate <typename LeafTy> struct LinearPolyBaseTypeTraits {};\n\n//===----------------------------------------------------------------------===//\n// LinearPolyBase - a base class for linear polynomials with multiple\n// dimensions. This can e.g. be used to describe offsets that are have both a\n// fixed and scalable component.\n//===----------------------------------------------------------------------===//\n\n/// LinearPolyBase describes a linear polynomial:\n///  c0 * scale0 + c1 * scale1 + ... + cK * scaleK\n/// where the scale is implicit, so only the coefficients are encoded.\ntemplate <typename LeafTy>\nclass LinearPolyBase {\npublic:\n  using ScalarTy = typename LinearPolyBaseTypeTraits<LeafTy>::ScalarTy;\n  static constexpr auto Dimensions = LinearPolyBaseTypeTraits<LeafTy>::Dimensions;\n  static_assert(Dimensions != std::numeric_limits<unsigned>::max(),\n                \"Dimensions out of range\");\n\nprivate:\n  std::array<ScalarTy, Dimensions> Coefficients;\n\nprotected:\n  LinearPolyBase(ArrayRef<ScalarTy> Values) {\n    std::copy(Values.begin(), Values.end(), Coefficients.begin());\n  }\n\npublic:\n  friend LeafTy &operator+=(LeafTy &LHS, const LeafTy &RHS) {\n    for (unsigned I=0; I<Dimensions; ++I)\n      LHS.Coefficients[I] += RHS.Coefficients[I];\n    return LHS;\n  }\n\n  friend LeafTy &operator-=(LeafTy &LHS, const LeafTy &RHS) {\n    for (unsigned I=0; I<Dimensions; ++I)\n      LHS.Coefficients[I] -= RHS.Coefficients[I];\n    return LHS;\n  }\n\n  friend LeafTy &operator*=(LeafTy &LHS, ScalarTy RHS) {\n    for (auto &C : LHS.Coefficients)\n      C *= RHS;\n    return LHS;\n  }\n\n  friend LeafTy operator+(const LeafTy &LHS, const LeafTy &RHS) {\n    LeafTy Copy = LHS;\n    return Copy += RHS;\n  }\n\n  friend LeafTy operator-(const LeafTy &LHS, const LeafTy &RHS) {\n    LeafTy Copy = LHS;\n    return Copy -= RHS;\n  }\n\n  friend LeafTy operator*(const LeafTy &LHS, ScalarTy RHS) {\n    LeafTy Copy = LHS;\n    return Copy *= RHS;\n  }\n\n  template <typename U = ScalarTy>\n  friend typename std::enable_if_t<std::is_signed<U>::value, LeafTy>\n  operator-(const LeafTy &LHS) {\n    LeafTy Copy = LHS;\n    return Copy *= -1;\n  }\n\n  bool operator==(const LinearPolyBase &RHS) const {\n    return std::equal(Coefficients.begin(), Coefficients.end(),\n                      RHS.Coefficients.begin());\n  }\n\n  bool operator!=(const LinearPolyBase &RHS) const {\n    return !(*this == RHS);\n  }\n\n  bool isZero() const {\n    return all_of(Coefficients, [](const ScalarTy &C) { return C == 0; });\n  }\n  bool isNonZero() const { return !isZero(); }\n  explicit operator bool() const { return isNonZero(); }\n\n  ScalarTy getValue(unsigned Dim) const { return Coefficients[Dim]; }\n};\n\n//===----------------------------------------------------------------------===//\n// StackOffset - Represent an offset with named fixed and scalable components.\n//===----------------------------------------------------------------------===//\n\nclass StackOffset;\ntemplate <> struct LinearPolyBaseTypeTraits<StackOffset> {\n  using ScalarTy = int64_t;\n  static constexpr unsigned Dimensions = 2;\n};\n\n/// StackOffset is a class to represent an offset with 2 dimensions,\n/// named fixed and scalable, respectively. This class allows a value for both\n/// dimensions to depict e.g. \"8 bytes and 16 scalable bytes\", which is needed\n/// to represent stack offsets.\nclass StackOffset : public LinearPolyBase<StackOffset> {\nprotected:\n  StackOffset(ScalarTy Fixed, ScalarTy Scalable)\n      : LinearPolyBase<StackOffset>({Fixed, Scalable}) {}\n\npublic:\n  StackOffset() : StackOffset({0, 0}) {}\n  StackOffset(const LinearPolyBase<StackOffset> &Other)\n      : LinearPolyBase<StackOffset>(Other) {}\n  static StackOffset getFixed(ScalarTy Fixed) { return {Fixed, 0}; }\n  static StackOffset getScalable(ScalarTy Scalable) { return {0, Scalable}; }\n  static StackOffset get(ScalarTy Fixed, ScalarTy Scalable) {\n    return {Fixed, Scalable};\n  }\n\n  ScalarTy getFixed() const { return this->getValue(0); }\n  ScalarTy getScalable() const { return this->getValue(1); }\n};\n\n//===----------------------------------------------------------------------===//\n// UnivariateLinearPolyBase - a base class for linear polynomials with multiple\n// dimensions, but where only one dimension can be set at any time.\n// This can e.g. be used to describe sizes that are either fixed or scalable.\n//===----------------------------------------------------------------------===//\n\n/// UnivariateLinearPolyBase is a base class for ElementCount and TypeSize.\n/// Like LinearPolyBase it tries to represent a linear polynomial\n/// where only one dimension can be set at any time, e.g.\n///   0 * scale0 + 0 * scale1 + ... + cJ * scaleJ + ... + 0 * scaleK\n/// The dimension that is set is the univariate dimension.\ntemplate <typename LeafTy>\nclass UnivariateLinearPolyBase {\npublic:\n  using ScalarTy = typename LinearPolyBaseTypeTraits<LeafTy>::ScalarTy;\n  static constexpr auto Dimensions = LinearPolyBaseTypeTraits<LeafTy>::Dimensions;\n  static_assert(Dimensions != std::numeric_limits<unsigned>::max(),\n                \"Dimensions out of range\");\n\nprotected:\n  ScalarTy Value;         // The value at the univeriate dimension.\n  unsigned UnivariateDim; // The univeriate dimension.\n\n  UnivariateLinearPolyBase(ScalarTy Val, unsigned UnivariateDim)\n      : Value(Val), UnivariateDim(UnivariateDim) {\n    assert(UnivariateDim < Dimensions && \"Dimension out of range\");\n  }\n\n  friend LeafTy &operator+=(LeafTy &LHS, const LeafTy &RHS) {\n    assert(LHS.UnivariateDim == RHS.UnivariateDim && \"Invalid dimensions\");\n    LHS.Value += RHS.Value;\n    return LHS;\n  }\n\n  friend LeafTy &operator-=(LeafTy &LHS, const LeafTy &RHS) {\n    assert(LHS.UnivariateDim == RHS.UnivariateDim && \"Invalid dimensions\");\n    LHS.Value -= RHS.Value;\n    return LHS;\n  }\n\n  friend LeafTy &operator*=(LeafTy &LHS, ScalarTy RHS) {\n    LHS.Value *= RHS;\n    return LHS;\n  }\n\n  friend LeafTy operator+(const LeafTy &LHS, const LeafTy &RHS) {\n    LeafTy Copy = LHS;\n    return Copy += RHS;\n  }\n\n  friend LeafTy operator-(const LeafTy &LHS, const LeafTy &RHS) {\n    LeafTy Copy = LHS;\n    return Copy -= RHS;\n  }\n\n  friend LeafTy operator*(const LeafTy &LHS, ScalarTy RHS) {\n    LeafTy Copy = LHS;\n    return Copy *= RHS;\n  }\n\n  template <typename U = ScalarTy>\n  friend typename std::enable_if<std::is_signed<U>::value, LeafTy>::type\n  operator-(const LeafTy &LHS) {\n    LeafTy Copy = LHS;\n    return Copy *= -1;\n  }\n\npublic:\n  bool operator==(const UnivariateLinearPolyBase &RHS) const {\n    return Value == RHS.Value && UnivariateDim == RHS.UnivariateDim;\n  }\n\n  bool operator!=(const UnivariateLinearPolyBase &RHS) const {\n    return !(*this == RHS);\n  }\n\n  bool isZero() const { return !Value; }\n  bool isNonZero() const { return !isZero(); }\n  explicit operator bool() const { return isNonZero(); }\n  ScalarTy getValue() const { return Value; }\n  ScalarTy getValue(unsigned Dim) const {\n    return Dim == UnivariateDim ? Value : 0;\n  }\n\n  /// Add \\p RHS to the value at the univariate dimension.\n  LeafTy getWithIncrement(ScalarTy RHS) const {\n    return static_cast<LeafTy>(\n        UnivariateLinearPolyBase(Value + RHS, UnivariateDim));\n  }\n\n  /// Subtract \\p RHS from the value at the univariate dimension.\n  LeafTy getWithDecrement(ScalarTy RHS) const {\n    return static_cast<LeafTy>(\n        UnivariateLinearPolyBase(Value - RHS, UnivariateDim));\n  }\n};\n\n\n//===----------------------------------------------------------------------===//\n// LinearPolySize - base class for fixed- or scalable sizes.\n//  ^  ^ \n//  |  |\n//  |  +----- ElementCount - Leaf class to represent an element count\n//  |                        (vscale x unsigned)\n//  |\n//  +-------- TypeSize - Leaf class to represent a type size\n//                       (vscale x uint64_t)\n//===----------------------------------------------------------------------===//\n\n/// LinearPolySize is a base class to represent sizes. It is either\n/// fixed-sized or it is scalable-sized, but it cannot be both.\ntemplate <typename LeafTy>\nclass LinearPolySize : public UnivariateLinearPolyBase<LeafTy> {\n  // Make the parent class a friend, so that it can access the protected\n  // conversion/copy-constructor for UnivariatePolyBase<LeafTy> ->\n  // LinearPolySize<LeafTy>.\n  friend class UnivariateLinearPolyBase<LeafTy>;\n\npublic:\n  using ScalarTy = typename UnivariateLinearPolyBase<LeafTy>::ScalarTy;\n  enum Dims : unsigned { FixedDim = 0, ScalableDim = 1 };\n\nprotected:\n  LinearPolySize(ScalarTy MinVal, Dims D)\n      : UnivariateLinearPolyBase<LeafTy>(MinVal, D) {}\n\n  LinearPolySize(const UnivariateLinearPolyBase<LeafTy> &V)\n      : UnivariateLinearPolyBase<LeafTy>(V) {}\n\npublic:\n\n  static LeafTy getFixed(ScalarTy MinVal) {\n    return static_cast<LeafTy>(LinearPolySize(MinVal, FixedDim));\n  }\n  static LeafTy getScalable(ScalarTy MinVal) {\n    return static_cast<LeafTy>(LinearPolySize(MinVal, ScalableDim));\n  }\n  static LeafTy get(ScalarTy MinVal, bool Scalable) {\n    return static_cast<LeafTy>(\n        LinearPolySize(MinVal, Scalable ? ScalableDim : FixedDim));\n  }\n  static LeafTy getNull() { return get(0, false); }\n\n  /// Returns the minimum value this size can represent.\n  ScalarTy getKnownMinValue() const { return this->getValue(); }\n  /// Returns whether the size is scaled by a runtime quantity (vscale).\n  bool isScalable() const { return this->UnivariateDim == ScalableDim; }\n  /// A return value of true indicates we know at compile time that the number\n  /// of elements (vscale * Min) is definitely even. However, returning false\n  /// does not guarantee that the total number of elements is odd.\n  bool isKnownEven() const { return (getKnownMinValue() & 0x1) == 0; }\n  /// This function tells the caller whether the element count is known at\n  /// compile time to be a multiple of the scalar value RHS.\n  bool isKnownMultipleOf(ScalarTy RHS) const {\n    return getKnownMinValue() % RHS == 0;\n  }\n\n  // Return the minimum value with the assumption that the count is exact.\n  // Use in places where a scalable count doesn't make sense (e.g. non-vector\n  // types, or vectors in backends which don't support scalable vectors).\n  ScalarTy getFixedValue() const {\n    assert(!isScalable() &&\n           \"Request for a fixed element count on a scalable object\");\n    return getKnownMinValue();\n  }\n\n  // For some cases, size ordering between scalable and fixed size types cannot\n  // be determined at compile time, so such comparisons aren't allowed.\n  //\n  // e.g. <vscale x 2 x i16> could be bigger than <4 x i32> with a runtime\n  // vscale >= 5, equal sized with a vscale of 4, and smaller with\n  // a vscale <= 3.\n  //\n  // All the functions below make use of the fact vscale is always >= 1, which\n  // means that <vscale x 4 x i32> is guaranteed to be >= <4 x i32>, etc.\n\n  static bool isKnownLT(const LinearPolySize &LHS, const LinearPolySize &RHS) {\n    if (!LHS.isScalable() || RHS.isScalable())\n      return LHS.getKnownMinValue() < RHS.getKnownMinValue();\n    return false;\n  }\n\n  static bool isKnownGT(const LinearPolySize &LHS, const LinearPolySize &RHS) {\n    if (LHS.isScalable() || !RHS.isScalable())\n      return LHS.getKnownMinValue() > RHS.getKnownMinValue();\n    return false;\n  }\n\n  static bool isKnownLE(const LinearPolySize &LHS, const LinearPolySize &RHS) {\n    if (!LHS.isScalable() || RHS.isScalable())\n      return LHS.getKnownMinValue() <= RHS.getKnownMinValue();\n    return false;\n  }\n\n  static bool isKnownGE(const LinearPolySize &LHS, const LinearPolySize &RHS) {\n    if (LHS.isScalable() || !RHS.isScalable())\n      return LHS.getKnownMinValue() >= RHS.getKnownMinValue();\n    return false;\n  }\n\n  /// We do not provide the '/' operator here because division for polynomial\n  /// types does not work in the same way as for normal integer types. We can\n  /// only divide the minimum value (or coefficient) by RHS, which is not the\n  /// same as\n  ///   (Min * Vscale) / RHS\n  /// The caller is recommended to use this function in combination with\n  /// isKnownMultipleOf(RHS), which lets the caller know if it's possible to\n  /// perform a lossless divide by RHS.\n  LeafTy divideCoefficientBy(ScalarTy RHS) const {\n    return static_cast<LeafTy>(\n        LinearPolySize::get(getKnownMinValue() / RHS, isScalable()));\n  }\n\n  LeafTy coefficientNextPowerOf2() const {\n    return static_cast<LeafTy>(LinearPolySize::get(\n        static_cast<ScalarTy>(llvm::NextPowerOf2(getKnownMinValue())),\n        isScalable()));\n  }\n\n  /// Printing function.\n  void print(raw_ostream &OS) const {\n    if (isScalable())\n      OS << \"vscale x \";\n    OS << getKnownMinValue();\n  }\n};\n\nclass ElementCount;\ntemplate <> struct LinearPolyBaseTypeTraits<ElementCount> {\n  using ScalarTy = unsigned;\n  static constexpr unsigned Dimensions = 2;\n};\n\nclass ElementCount : public LinearPolySize<ElementCount> {\npublic:\n  ElementCount() : LinearPolySize(LinearPolySize::getNull()) {}\n\n  ElementCount(const LinearPolySize<ElementCount> &V) : LinearPolySize(V) {}\n\n  /// Counting predicates.\n  ///\n  ///@{ Number of elements..\n  /// Exactly one element.\n  bool isScalar() const { return !isScalable() && getKnownMinValue() == 1; }\n  /// One or more elements.\n  bool isVector() const {\n    return (isScalable() && getKnownMinValue() != 0) || getKnownMinValue() > 1;\n  }\n  ///@}\n};\n\n// This class is used to represent the size of types. If the type is of fixed\nclass TypeSize;\ntemplate <> struct LinearPolyBaseTypeTraits<TypeSize> {\n  using ScalarTy = uint64_t;\n  static constexpr unsigned Dimensions = 2;\n};\n\n// TODO: Most functionality in this class will gradually be phased out\n// so it will resemble LinearPolySize as much as possible.\n//\n// TypeSize is used to represent the size of types. If the type is of fixed\n// size, it will represent the exact size. If the type is a scalable vector,\n// it will represent the known minimum size.\nclass TypeSize : public LinearPolySize<TypeSize> {\npublic:\n  TypeSize(const LinearPolySize<TypeSize> &V) : LinearPolySize(V) {}\n  TypeSize(ScalarTy MinVal, bool IsScalable)\n      : LinearPolySize(LinearPolySize::get(MinVal, IsScalable)) {}\n\n  static TypeSize Fixed(ScalarTy MinVal) { return TypeSize(MinVal, false); }\n  static TypeSize Scalable(ScalarTy MinVal) { return TypeSize(MinVal, true); }\n\n  ScalarTy getFixedSize() const { return getFixedValue(); }\n  ScalarTy getKnownMinSize() const { return getKnownMinValue(); }\n\n  // All code for this class below this point is needed because of the\n  // temporary implicit conversion to uint64_t. The operator overloads are\n  // needed because otherwise the conversion of the parent class\n  // UnivariateLinearPolyBase -> TypeSize is ambiguous.\n  // TODO: Remove the implicit conversion.\n\n  // Casts to a uint64_t if this is a fixed-width size.\n  //\n  // This interface is deprecated and will be removed in a future version\n  // of LLVM in favour of upgrading uses that rely on this implicit conversion\n  // to uint64_t. Calls to functions that return a TypeSize should use the\n  // proper interfaces to TypeSize.\n  // In practice this is mostly calls to MVT/EVT::getSizeInBits().\n  //\n  // To determine how to upgrade the code:\n  //\n  //   if (<algorithm works for both scalable and fixed-width vectors>)\n  //     use getKnownMinValue()\n  //   else if (<algorithm works only for fixed-width vectors>) {\n  //     if <algorithm can be adapted for both scalable and fixed-width vectors>\n  //       update the algorithm and use getKnownMinValue()\n  //     else\n  //       bail out early for scalable vectors and use getFixedValue()\n  //   }\n  operator ScalarTy() const {\n#ifdef STRICT_FIXED_SIZE_VECTORS\n    return getFixedValue();\n#else\n    if (isScalable())\n      WithColor::warning() << \"Compiler has made implicit assumption that \"\n                              \"TypeSize is not scalable. This may or may not \"\n                              \"lead to broken code.\\n\";\n    return getKnownMinValue();\n#endif\n  }\n\n  // Additional operators needed to avoid ambiguous parses\n  // because of the implicit conversion hack.\n  friend TypeSize operator*(const TypeSize &LHS, const int RHS) {\n    return LHS * (ScalarTy)RHS;\n  }\n  friend TypeSize operator*(const TypeSize &LHS, const unsigned RHS) {\n    return LHS * (ScalarTy)RHS;\n  }\n  friend TypeSize operator*(const TypeSize &LHS, const int64_t RHS) {\n    return LHS * (ScalarTy)RHS;\n  }\n  friend TypeSize operator*(const int LHS, const TypeSize &RHS) {\n    return RHS * LHS;\n  }\n  friend TypeSize operator*(const unsigned LHS, const TypeSize &RHS) {\n    return RHS * LHS;\n  }\n  friend TypeSize operator*(const int64_t LHS, const TypeSize &RHS) {\n    return RHS * LHS;\n  }\n  friend TypeSize operator*(const uint64_t LHS, const TypeSize &RHS) {\n    return RHS * LHS;\n  }\n};\n\n//===----------------------------------------------------------------------===//\n// Utilities\n//===----------------------------------------------------------------------===//\n\n/// Returns a TypeSize with a known minimum size that is the next integer\n/// (mod 2**64) that is greater than or equal to \\p Value and is a multiple\n/// of \\p Align. \\p Align must be non-zero.\n///\n/// Similar to the alignTo functions in MathExtras.h\ninline TypeSize alignTo(TypeSize Size, uint64_t Align) {\n  assert(Align != 0u && \"Align must be non-zero\");\n  return {(Size.getKnownMinValue() + Align - 1) / Align * Align,\n          Size.isScalable()};\n}\n\n/// Stream operator function for `LinearPolySize`.\ntemplate <typename LeafTy>\ninline raw_ostream &operator<<(raw_ostream &OS,\n                               const LinearPolySize<LeafTy> &PS) {\n  PS.print(OS);\n  return OS;\n}\n\ntemplate <typename T> struct DenseMapInfo;\ntemplate <> struct DenseMapInfo<ElementCount> {\n  static inline ElementCount getEmptyKey() {\n    return ElementCount::getScalable(~0U);\n  }\n  static inline ElementCount getTombstoneKey() {\n    return ElementCount::getFixed(~0U - 1);\n  }\n  static unsigned getHashValue(const ElementCount &EltCnt) {\n    unsigned HashVal = EltCnt.getKnownMinValue() * 37U;\n    if (EltCnt.isScalable())\n      return (HashVal - 1U);\n\n    return HashVal;\n  }\n\n  static bool isEqual(const ElementCount &LHS, const ElementCount &RHS) {\n    return LHS == RHS;\n  }\n};\n\n} // end namespace llvm\n\n#endif // LLVM_SUPPORT_TYPESIZE_H\n"}, "81": {"id": 81, "path": "/home/vsts/work/1/llvm-project/llvm/lib/CodeGen/AsmPrinter/ByteStreamer.h", "content": "//===-- llvm/CodeGen/ByteStreamer.h - ByteStreamer class --------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// This file contains a class that can take bytes that would normally be\n// streamed via the AsmPrinter.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_LIB_CODEGEN_ASMPRINTER_BYTESTREAMER_H\n#define LLVM_LIB_CODEGEN_ASMPRINTER_BYTESTREAMER_H\n\n#include \"DIEHash.h\"\n#include \"llvm/CodeGen/AsmPrinter.h\"\n#include \"llvm/MC/MCStreamer.h\"\n#include \"llvm/Support/LEB128.h\"\n#include <string>\n\nnamespace llvm {\nclass ByteStreamer {\n protected:\n  ~ByteStreamer() = default;\n  ByteStreamer(const ByteStreamer&) = default;\n  ByteStreamer() = default;\n\n public:\n  // For now we're just handling the calls we need for dwarf emission/hashing.\n  virtual void emitInt8(uint8_t Byte, const Twine &Comment = \"\") = 0;\n  virtual void emitSLEB128(uint64_t DWord, const Twine &Comment = \"\") = 0;\n  virtual void emitULEB128(uint64_t DWord, const Twine &Comment = \"\",\n                           unsigned PadTo = 0) = 0;\n};\n\nclass APByteStreamer final : public ByteStreamer {\nprivate:\n  AsmPrinter &AP;\n\npublic:\n  APByteStreamer(AsmPrinter &Asm) : AP(Asm) {}\n  void emitInt8(uint8_t Byte, const Twine &Comment) override {\n    AP.OutStreamer->AddComment(Comment);\n    AP.emitInt8(Byte);\n  }\n  void emitSLEB128(uint64_t DWord, const Twine &Comment) override {\n    AP.OutStreamer->AddComment(Comment);\n    AP.emitSLEB128(DWord);\n  }\n  void emitULEB128(uint64_t DWord, const Twine &Comment,\n                   unsigned PadTo) override {\n    AP.OutStreamer->AddComment(Comment);\n    AP.emitULEB128(DWord, nullptr, PadTo);\n  }\n};\n\nclass HashingByteStreamer final : public ByteStreamer {\n private:\n  DIEHash &Hash;\n public:\n HashingByteStreamer(DIEHash &H) : Hash(H) {}\n  void emitInt8(uint8_t Byte, const Twine &Comment) override {\n    Hash.update(Byte);\n  }\n  void emitSLEB128(uint64_t DWord, const Twine &Comment) override {\n    Hash.addSLEB128(DWord);\n  }\n  void emitULEB128(uint64_t DWord, const Twine &Comment,\n                   unsigned PadTo) override {\n    Hash.addULEB128(DWord);\n  }\n};\n\nclass BufferByteStreamer final : public ByteStreamer {\nprivate:\n  SmallVectorImpl<char> &Buffer;\n  std::vector<std::string> &Comments;\n\npublic:\n  /// Only verbose textual output needs comments.  This will be set to\n  /// true for that case, and false otherwise.  If false, comments passed in to\n  /// the emit methods will be ignored.\n  const bool GenerateComments;\n\n  BufferByteStreamer(SmallVectorImpl<char> &Buffer,\n                     std::vector<std::string> &Comments, bool GenerateComments)\n      : Buffer(Buffer), Comments(Comments), GenerateComments(GenerateComments) {\n  }\n  void emitInt8(uint8_t Byte, const Twine &Comment) override {\n    Buffer.push_back(Byte);\n    if (GenerateComments)\n      Comments.push_back(Comment.str());\n  }\n  void emitSLEB128(uint64_t DWord, const Twine &Comment) override {\n    raw_svector_ostream OSE(Buffer);\n    unsigned Length = encodeSLEB128(DWord, OSE);\n    if (GenerateComments) {\n      Comments.push_back(Comment.str());\n      // Add some empty comments to keep the Buffer and Comments vectors aligned\n      // with each other.\n      for (size_t i = 1; i < Length; ++i)\n        Comments.push_back(\"\");\n\n    }\n  }\n  void emitULEB128(uint64_t DWord, const Twine &Comment,\n                   unsigned PadTo) override {\n    raw_svector_ostream OSE(Buffer);\n    unsigned Length = encodeULEB128(DWord, OSE, PadTo);\n    if (GenerateComments) {\n      Comments.push_back(Comment.str());\n      // Add some empty comments to keep the Buffer and Comments vectors aligned\n      // with each other.\n      for (size_t i = 1; i < Length; ++i)\n        Comments.push_back(\"\");\n\n    }\n  }\n};\n\n}\n\n#endif\n"}, "82": {"id": 82, "path": "/home/vsts/work/1/llvm-project/llvm/lib/CodeGen/AsmPrinter/DebugLocEntry.h", "content": "//===-- llvm/CodeGen/DebugLocEntry.h - Entry in debug_loc list -*- C++ -*--===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_LIB_CODEGEN_ASMPRINTER_DEBUGLOCENTRY_H\n#define LLVM_LIB_CODEGEN_ASMPRINTER_DEBUGLOCENTRY_H\n\n#include \"DebugLocStream.h\"\n#include \"llvm/Config/llvm-config.h\"\n#include \"llvm/IR/Constants.h\"\n#include \"llvm/IR/DebugInfo.h\"\n#include \"llvm/MC/MCSymbol.h\"\n#include \"llvm/MC/MachineLocation.h\"\n#include \"llvm/Support/Debug.h\"\n\nnamespace llvm {\nclass AsmPrinter;\n\n/// This struct describes target specific location.\nstruct TargetIndexLocation {\n  int Index;\n  int Offset;\n\n  TargetIndexLocation() = default;\n  TargetIndexLocation(unsigned Idx, int64_t Offset)\n      : Index(Idx), Offset(Offset) {}\n\n  bool operator==(const TargetIndexLocation &Other) const {\n    return Index == Other.Index && Offset == Other.Offset;\n  }\n};\n\n/// A single location or constant within a variable location description, with\n/// either a single entry (with an optional DIExpression) used for a DBG_VALUE,\n/// or a list of entries used for a DBG_VALUE_LIST.\nclass DbgValueLocEntry {\n\n  /// Type of entry that this represents.\n  enum EntryType {\n    E_Location,\n    E_Integer,\n    E_ConstantFP,\n    E_ConstantInt,\n    E_TargetIndexLocation\n  };\n  enum EntryType EntryKind;\n\n  /// Either a constant,\n  union {\n    int64_t Int;\n    const ConstantFP *CFP;\n    const ConstantInt *CIP;\n  } Constant;\n\n  union {\n    /// Or a location in the machine frame.\n    MachineLocation Loc;\n    /// Or a location from target specific location.\n    TargetIndexLocation TIL;\n  };\n\npublic:\n  DbgValueLocEntry(int64_t i) : EntryKind(E_Integer) { Constant.Int = i; }\n  DbgValueLocEntry(const ConstantFP *CFP) : EntryKind(E_ConstantFP) {\n    Constant.CFP = CFP;\n  }\n  DbgValueLocEntry(const ConstantInt *CIP) : EntryKind(E_ConstantInt) {\n    Constant.CIP = CIP;\n  }\n  DbgValueLocEntry(MachineLocation Loc) : EntryKind(E_Location), Loc(Loc) {}\n  DbgValueLocEntry(TargetIndexLocation Loc)\n      : EntryKind(E_TargetIndexLocation), TIL(Loc) {}\n\n  bool isLocation() const { return EntryKind == E_Location; }\n  bool isTargetIndexLocation() const {\n    return EntryKind == E_TargetIndexLocation;\n  }\n  bool isInt() const { return EntryKind == E_Integer; }\n  bool isConstantFP() const { return EntryKind == E_ConstantFP; }\n  bool isConstantInt() const { return EntryKind == E_ConstantInt; }\n  int64_t getInt() const { return Constant.Int; }\n  const ConstantFP *getConstantFP() const { return Constant.CFP; }\n  const ConstantInt *getConstantInt() const { return Constant.CIP; }\n  MachineLocation getLoc() const { return Loc; }\n  TargetIndexLocation getTargetIndexLocation() const { return TIL; }\n  friend bool operator==(const DbgValueLocEntry &, const DbgValueLocEntry &);\n#if !defined(NDEBUG) || defined(LLVM_ENABLE_DUMP)\n  LLVM_DUMP_METHOD void dump() const {\n    if (isLocation()) {\n      llvm::dbgs() << \"Loc = { reg=\" << Loc.getReg() << \" \";\n      if (Loc.isIndirect())\n        llvm::dbgs() << \"+0\";\n      llvm::dbgs() << \"} \";\n    } else if (isConstantInt())\n      Constant.CIP->dump();\n    else if (isConstantFP())\n      Constant.CFP->dump();\n  }\n#endif\n};\n\n/// The location of a single variable, composed of an expression and 0 or more\n/// DbgValueLocEntries.\nclass DbgValueLoc {\n  /// Any complex address location expression for this DbgValueLoc.\n  const DIExpression *Expression;\n\n  SmallVector<DbgValueLocEntry, 2> ValueLocEntries;\n\n  bool IsVariadic;\n\npublic:\n  DbgValueLoc(const DIExpression *Expr, ArrayRef<DbgValueLocEntry> Locs)\n      : Expression(Expr), ValueLocEntries(Locs.begin(), Locs.end()),\n        IsVariadic(true) {\n#ifndef NDEBUG\n    // Currently, DBG_VALUE_VAR expressions must use stack_value.\n    assert(Expr && Expr->isValid() &&\n           is_contained(Locs, dwarf::DW_OP_stack_value));\n    for (DbgValueLocEntry &Entry : ValueLocEntries) {\n      assert(!Entry.isConstantFP() && !Entry.isConstantInt() &&\n             \"Constant values should only be present in non-variadic \"\n             \"DBG_VALUEs.\");\n    }\n#endif\n  }\n\n  DbgValueLoc(const DIExpression *Expr, ArrayRef<DbgValueLocEntry> Locs,\n              bool IsVariadic)\n      : Expression(Expr), ValueLocEntries(Locs.begin(), Locs.end()),\n        IsVariadic(IsVariadic) {\n#ifndef NDEBUG\n    assert(cast<DIExpression>(Expr)->isValid() ||\n           !any_of(Locs, [](auto LE) { return LE.isLocation(); }));\n    if (!IsVariadic) {\n      assert(ValueLocEntries.size() == 1);\n    } else {\n      // Currently, DBG_VALUE_VAR expressions must use stack_value.\n      assert(Expr && Expr->isValid() &&\n             is_contained(Expr->getElements(), dwarf::DW_OP_stack_value));\n      for (DbgValueLocEntry &Entry : ValueLocEntries) {\n        assert(!Entry.isConstantFP() && !Entry.isConstantInt() &&\n               \"Constant values should only be present in non-variadic \"\n               \"DBG_VALUEs.\");\n      }\n    }\n#endif\n  }\n\n  DbgValueLoc(const DIExpression *Expr, DbgValueLocEntry Loc)\n      : Expression(Expr), ValueLocEntries(1, Loc), IsVariadic(false) {\n    assert(((Expr && Expr->isValid()) || !Loc.isLocation()) &&\n           \"DBG_VALUE with a machine location must have a valid expression.\");\n  }\n\n  bool isFragment() const { return getExpression()->isFragment(); }\n  bool isEntryVal() const { return getExpression()->isEntryValue(); }\n  bool isVariadic() const { return IsVariadic; }\n  const DIExpression *getExpression() const { return Expression; }\n  const ArrayRef<DbgValueLocEntry> getLocEntries() const {\n    return ValueLocEntries;\n  }\n  friend bool operator==(const DbgValueLoc &, const DbgValueLoc &);\n  friend bool operator<(const DbgValueLoc &, const DbgValueLoc &);\n#if !defined(NDEBUG) || defined(LLVM_ENABLE_DUMP)\n  LLVM_DUMP_METHOD void dump() const {\n    for (DbgValueLocEntry DV : ValueLocEntries)\n      DV.dump();\n    if (Expression)\n      Expression->dump();\n  }\n#endif\n};\n\n/// This struct describes location entries emitted in the .debug_loc\n/// section.\nclass DebugLocEntry {\n  /// Begin and end symbols for the address range that this location is valid.\n  const MCSymbol *Begin;\n  const MCSymbol *End;\n\n  /// A nonempty list of locations/constants belonging to this entry,\n  /// sorted by offset.\n  SmallVector<DbgValueLoc, 1> Values;\n\npublic:\n  /// Create a location list entry for the range [\\p Begin, \\p End).\n  ///\n  /// \\param Vals One or more values describing (parts of) the variable.\n  DebugLocEntry(const MCSymbol *Begin, const MCSymbol *End,\n                ArrayRef<DbgValueLoc> Vals)\n      : Begin(Begin), End(End) {\n    addValues(Vals);\n  }\n\n  /// Attempt to merge this DebugLocEntry with Next and return\n  /// true if the merge was successful. Entries can be merged if they\n  /// share the same Loc/Constant and if Next immediately follows this\n  /// Entry.\n  bool MergeRanges(const DebugLocEntry &Next) {\n    // If this and Next are describing the same variable, merge them.\n    if ((End == Next.Begin && Values == Next.Values)) {\n      End = Next.End;\n      return true;\n    }\n    return false;\n  }\n\n  const MCSymbol *getBeginSym() const { return Begin; }\n  const MCSymbol *getEndSym() const { return End; }\n  ArrayRef<DbgValueLoc> getValues() const { return Values; }\n  void addValues(ArrayRef<DbgValueLoc> Vals) {\n    Values.append(Vals.begin(), Vals.end());\n    sortUniqueValues();\n    assert((Values.size() == 1 || all_of(Values, [](DbgValueLoc V) {\n              return V.isFragment();\n            })) && \"must either have a single value or multiple pieces\");\n  }\n\n  // Sort the pieces by offset.\n  // Remove any duplicate entries by dropping all but the first.\n  void sortUniqueValues() {\n    llvm::sort(Values);\n    Values.erase(std::unique(Values.begin(), Values.end(),\n                             [](const DbgValueLoc &A, const DbgValueLoc &B) {\n                               return A.getExpression() == B.getExpression();\n                             }),\n                 Values.end());\n  }\n\n  /// Lower this entry into a DWARF expression.\n  void finalize(const AsmPrinter &AP,\n                DebugLocStream::ListBuilder &List,\n                const DIBasicType *BT,\n                DwarfCompileUnit &TheCU);\n};\n\n/// Compare two DbgValueLocEntries for equality.\ninline bool operator==(const DbgValueLocEntry &A, const DbgValueLocEntry &B) {\n  if (A.EntryKind != B.EntryKind)\n    return false;\n\n  switch (A.EntryKind) {\n  case DbgValueLocEntry::E_Location:\n    return A.Loc == B.Loc;\n  case DbgValueLocEntry::E_TargetIndexLocation:\n    return A.TIL == B.TIL;\n  case DbgValueLocEntry::E_Integer:\n    return A.Constant.Int == B.Constant.Int;\n  case DbgValueLocEntry::E_ConstantFP:\n    return A.Constant.CFP == B.Constant.CFP;\n  case DbgValueLocEntry::E_ConstantInt:\n    return A.Constant.CIP == B.Constant.CIP;\n  }\n  llvm_unreachable(\"unhandled EntryKind\");\n}\n\n/// Compare two DbgValueLocs for equality.\ninline bool operator==(const DbgValueLoc &A, const DbgValueLoc &B) {\n  return A.ValueLocEntries == B.ValueLocEntries &&\n         A.Expression == B.Expression && A.IsVariadic == B.IsVariadic;\n}\n\n/// Compare two fragments based on their offset.\ninline bool operator<(const DbgValueLoc &A,\n                      const DbgValueLoc &B) {\n  return A.getExpression()->getFragmentInfo()->OffsetInBits <\n         B.getExpression()->getFragmentInfo()->OffsetInBits;\n}\n\n}\n\n#endif\n"}, "83": {"id": 83, "path": "/home/vsts/work/1/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfCompileUnit.cpp", "content": "//===- llvm/CodeGen/DwarfCompileUnit.cpp - Dwarf Compile Units ------------===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// This file contains support for constructing a dwarf compile unit.\n//\n//===----------------------------------------------------------------------===//\n\n#include \"DwarfCompileUnit.h\"\n#include \"AddressPool.h\"\n#include \"DwarfExpression.h\"\n#include \"llvm/ADT/None.h\"\n#include \"llvm/ADT/STLExtras.h\"\n#include \"llvm/ADT/SmallString.h\"\n#include \"llvm/BinaryFormat/Dwarf.h\"\n#include \"llvm/CodeGen/AsmPrinter.h\"\n#include \"llvm/CodeGen/DIE.h\"\n#include \"llvm/CodeGen/MachineFunction.h\"\n#include \"llvm/CodeGen/MachineInstr.h\"\n#include \"llvm/CodeGen/MachineOperand.h\"\n#include \"llvm/CodeGen/TargetFrameLowering.h\"\n#include \"llvm/CodeGen/TargetRegisterInfo.h\"\n#include \"llvm/CodeGen/TargetSubtargetInfo.h\"\n#include \"llvm/IR/DataLayout.h\"\n#include \"llvm/IR/DebugInfo.h\"\n#include \"llvm/IR/GlobalVariable.h\"\n#include \"llvm/MC/MCSection.h\"\n#include \"llvm/MC/MCStreamer.h\"\n#include \"llvm/MC/MCSymbol.h\"\n#include \"llvm/MC/MCSymbolWasm.h\"\n#include \"llvm/MC/MachineLocation.h\"\n#include \"llvm/Target/TargetLoweringObjectFile.h\"\n#include \"llvm/Target/TargetMachine.h\"\n#include \"llvm/Target/TargetOptions.h\"\n#include <iterator>\n#include <string>\n#include <utility>\n\nusing namespace llvm;\n\nstatic dwarf::Tag GetCompileUnitType(UnitKind Kind, DwarfDebug *DW) {\n\n  //  According to DWARF Debugging Information Format Version 5,\n  //  3.1.2 Skeleton Compilation Unit Entries:\n  //  \"When generating a split DWARF object file (see Section 7.3.2\n  //  on page 187), the compilation unit in the .debug_info section\n  //  is a \"skeleton\" compilation unit with the tag DW_TAG_skeleton_unit\"\n  if (DW->getDwarfVersion() >= 5 && Kind == UnitKind::Skeleton)\n    return dwarf::DW_TAG_skeleton_unit;\n\n  return dwarf::DW_TAG_compile_unit;\n}\n\nDwarfCompileUnit::DwarfCompileUnit(unsigned UID, const DICompileUnit *Node,\n                                   AsmPrinter *A, DwarfDebug *DW,\n                                   DwarfFile *DWU, UnitKind Kind)\n    : DwarfUnit(GetCompileUnitType(Kind, DW), Node, A, DW, DWU), UniqueID(UID) {\n  insertDIE(Node, &getUnitDie());\n  MacroLabelBegin = Asm->createTempSymbol(\"cu_macro_begin\");\n}\n\n/// addLabelAddress - Add a dwarf label attribute data and value using\n/// DW_FORM_addr or DW_FORM_GNU_addr_index.\nvoid DwarfCompileUnit::addLabelAddress(DIE &Die, dwarf::Attribute Attribute,\n                                       const MCSymbol *Label) {\n  // Don't use the address pool in non-fission or in the skeleton unit itself.\n  if ((!DD->useSplitDwarf() || !Skeleton) && DD->getDwarfVersion() < 5)\n    return addLocalLabelAddress(Die, Attribute, Label);\n\n  if (Label)\n    DD->addArangeLabel(SymbolCU(this, Label));\n\n  bool UseAddrOffsetFormOrExpressions =\n      DD->useAddrOffsetForm() || DD->useAddrOffsetExpressions();\n\n  const MCSymbol *Base = nullptr;\n  if (Label->isInSection() && UseAddrOffsetFormOrExpressions)\n    Base = DD->getSectionLabel(&Label->getSection());\n\n  if (!Base || Base == Label) {\n    unsigned idx = DD->getAddressPool().getIndex(Label);\n    Die.addValue(DIEValueAllocator, Attribute,\n                 DD->getDwarfVersion() >= 5 ? dwarf::DW_FORM_addrx\n                                            : dwarf::DW_FORM_GNU_addr_index,\n                 DIEInteger(idx));\n    return;\n  }\n\n  // Could be extended to work with DWARFv4 Split DWARF if that's important for\n  // someone. In that case DW_FORM_data would be used.\n  assert(DD->getDwarfVersion() >= 5 &&\n         \"Addr+offset expressions are only valuable when using debug_addr (to \"\n         \"reduce relocations) available in DWARFv5 or higher\");\n  if (DD->useAddrOffsetExpressions()) {\n    auto *Loc = new (DIEValueAllocator) DIEBlock();\n    addPoolOpAddress(*Loc, Label);\n    addBlock(Die, Attribute, dwarf::DW_FORM_exprloc, Loc);\n  } else\n    Die.addValue(DIEValueAllocator, Attribute, dwarf::DW_FORM_LLVM_addrx_offset,\n                 new (DIEValueAllocator) DIEAddrOffset(\n                     DD->getAddressPool().getIndex(Base), Label, Base));\n}\n\nvoid DwarfCompileUnit::addLocalLabelAddress(DIE &Die,\n                                            dwarf::Attribute Attribute,\n                                            const MCSymbol *Label) {\n  if (Label)\n    DD->addArangeLabel(SymbolCU(this, Label));\n\n  if (Label)\n    Die.addValue(DIEValueAllocator, Attribute, dwarf::DW_FORM_addr,\n                 DIELabel(Label));\n  else\n    Die.addValue(DIEValueAllocator, Attribute, dwarf::DW_FORM_addr,\n                 DIEInteger(0));\n}\n\nunsigned DwarfCompileUnit::getOrCreateSourceID(const DIFile *File) {\n  // If we print assembly, we can't separate .file entries according to\n  // compile units. Thus all files will belong to the default compile unit.\n\n  // FIXME: add a better feature test than hasRawTextSupport. Even better,\n  // extend .file to support this.\n  unsigned CUID = Asm->OutStreamer->hasRawTextSupport() ? 0 : getUniqueID();\n  if (!File)\n    return Asm->OutStreamer->emitDwarfFileDirective(0, \"\", \"\", None, None,\n                                                    CUID);\n  return Asm->OutStreamer->emitDwarfFileDirective(\n      0, File->getDirectory(), File->getFilename(), DD->getMD5AsBytes(File),\n      File->getSource(), CUID);\n}\n\nDIE *DwarfCompileUnit::getOrCreateGlobalVariableDIE(\n    const DIGlobalVariable *GV, ArrayRef<GlobalExpr> GlobalExprs) {\n  // Check for pre-existence.\n  if (DIE *Die = getDIE(GV))\n    return Die;\n\n  assert(GV);\n\n  auto *GVContext = GV->getScope();\n  const DIType *GTy = GV->getType();\n\n  // Construct the context before querying for the existence of the DIE in\n  // case such construction creates the DIE.\n  auto *CB = GVContext ? dyn_cast<DICommonBlock>(GVContext) : nullptr;\n  DIE *ContextDIE = CB ? getOrCreateCommonBlock(CB, GlobalExprs)\n    : getOrCreateContextDIE(GVContext);\n\n  // Add to map.\n  DIE *VariableDIE = &createAndAddDIE(GV->getTag(), *ContextDIE, GV);\n  DIScope *DeclContext;\n  if (auto *SDMDecl = GV->getStaticDataMemberDeclaration()) {\n    DeclContext = SDMDecl->getScope();\n    assert(SDMDecl->isStaticMember() && \"Expected static member decl\");\n    assert(GV->isDefinition());\n    // We need the declaration DIE that is in the static member's class.\n    DIE *VariableSpecDIE = getOrCreateStaticMemberDIE(SDMDecl);\n    addDIEEntry(*VariableDIE, dwarf::DW_AT_specification, *VariableSpecDIE);\n    // If the global variable's type is different from the one in the class\n    // member type, assume that it's more specific and also emit it.\n    if (GTy != SDMDecl->getBaseType())\n      addType(*VariableDIE, GTy);\n  } else {\n    DeclContext = GV->getScope();\n    // Add name and type.\n    addString(*VariableDIE, dwarf::DW_AT_name, GV->getDisplayName());\n    if (GTy)\n      addType(*VariableDIE, GTy);\n\n    // Add scoping info.\n    if (!GV->isLocalToUnit())\n      addFlag(*VariableDIE, dwarf::DW_AT_external);\n\n    // Add line number info.\n    addSourceLine(*VariableDIE, GV);\n  }\n\n  if (!GV->isDefinition())\n    addFlag(*VariableDIE, dwarf::DW_AT_declaration);\n  else\n    addGlobalName(GV->getName(), *VariableDIE, DeclContext);\n\n  if (uint32_t AlignInBytes = GV->getAlignInBytes())\n    addUInt(*VariableDIE, dwarf::DW_AT_alignment, dwarf::DW_FORM_udata,\n            AlignInBytes);\n\n  if (MDTuple *TP = GV->getTemplateParams())\n    addTemplateParams(*VariableDIE, DINodeArray(TP));\n\n  // Add location.\n  addLocationAttribute(VariableDIE, GV, GlobalExprs);\n\n  return VariableDIE;\n}\n\nvoid DwarfCompileUnit::addLocationAttribute(\n    DIE *VariableDIE, const DIGlobalVariable *GV, ArrayRef<GlobalExpr> GlobalExprs) {\n  bool addToAccelTable = false;\n  DIELoc *Loc = nullptr;\n  Optional<unsigned> NVPTXAddressSpace;\n  std::unique_ptr<DIEDwarfExpression> DwarfExpr;\n  for (const auto &GE : GlobalExprs) {\n    const GlobalVariable *Global = GE.Var;\n    const DIExpression *Expr = GE.Expr;\n\n    // For compatibility with DWARF 3 and earlier,\n    // DW_AT_location(DW_OP_constu, X, DW_OP_stack_value) becomes\n    // DW_AT_const_value(X).\n    if (GlobalExprs.size() == 1 && Expr && Expr->isConstant()) {\n      addToAccelTable = true;\n      addConstantValue(*VariableDIE, /*Unsigned=*/true, Expr->getElement(1));\n      break;\n    }\n\n    // We cannot describe the location of dllimport'd variables: the\n    // computation of their address requires loads from the IAT.\n    if (Global && Global->hasDLLImportStorageClass())\n      continue;\n\n    // Nothing to describe without address or constant.\n    if (!Global && (!Expr || !Expr->isConstant()))\n      continue;\n\n    if (Global && Global->isThreadLocal() &&\n        !Asm->getObjFileLowering().supportDebugThreadLocalLocation())\n      continue;\n\n    if (!Loc) {\n      addToAccelTable = true;\n      Loc = new (DIEValueAllocator) DIELoc;\n      DwarfExpr = std::make_unique<DIEDwarfExpression>(*Asm, *this, *Loc);\n    }\n\n    if (Expr) {\n      // According to\n      // https://docs.nvidia.com/cuda/archive/10.0/ptx-writers-guide-to-interoperability/index.html#cuda-specific-dwarf\n      // cuda-gdb requires DW_AT_address_class for all variables to be able to\n      // correctly interpret address space of the variable address.\n      // Decode DW_OP_constu <DWARF Address Space> DW_OP_swap DW_OP_xderef\n      // sequence for the NVPTX + gdb target.\n      unsigned LocalNVPTXAddressSpace;\n      if (Asm->TM.getTargetTriple().isNVPTX() && DD->tuneForGDB()) {\n        const DIExpression *NewExpr =\n            DIExpression::extractAddressClass(Expr, LocalNVPTXAddressSpace);\n        if (NewExpr != Expr) {\n          Expr = NewExpr;\n          NVPTXAddressSpace = LocalNVPTXAddressSpace;\n        }\n      }\n      DwarfExpr->addFragmentOffset(Expr);\n    }\n\n    if (Global) {\n      const MCSymbol *Sym = Asm->getSymbol(Global);\n      if (Global->isThreadLocal()) {\n        if (Asm->TM.useEmulatedTLS()) {\n          // TODO: add debug info for emulated thread local mode.\n        } else {\n          // FIXME: Make this work with -gsplit-dwarf.\n          unsigned PointerSize = Asm->getDataLayout().getPointerSize();\n          assert((PointerSize == 4 || PointerSize == 8) &&\n                 \"Add support for other sizes if necessary\");\n          // Based on GCC's support for TLS:\n          if (!DD->useSplitDwarf()) {\n            // 1) Start with a constNu of the appropriate pointer size\n            addUInt(*Loc, dwarf::DW_FORM_data1,\n                    PointerSize == 4 ? dwarf::DW_OP_const4u\n                                     : dwarf::DW_OP_const8u);\n            // 2) containing the (relocated) offset of the TLS variable\n            //    within the module's TLS block.\n            addExpr(*Loc,\n                    PointerSize == 4 ? dwarf::DW_FORM_data4\n                                     : dwarf::DW_FORM_data8,\n                    Asm->getObjFileLowering().getDebugThreadLocalSymbol(Sym));\n          } else {\n            addUInt(*Loc, dwarf::DW_FORM_data1, dwarf::DW_OP_GNU_const_index);\n            addUInt(*Loc, dwarf::DW_FORM_udata,\n                    DD->getAddressPool().getIndex(Sym, /* TLS */ true));\n          }\n          // 3) followed by an OP to make the debugger do a TLS lookup.\n          addUInt(*Loc, dwarf::DW_FORM_data1,\n                  DD->useGNUTLSOpcode() ? dwarf::DW_OP_GNU_push_tls_address\n                                        : dwarf::DW_OP_form_tls_address);\n        }\n      } else {\n        DD->addArangeLabel(SymbolCU(this, Sym));\n        addOpAddress(*Loc, Sym);\n      }\n    }\n    // Global variables attached to symbols are memory locations.\n    // It would be better if this were unconditional, but malformed input that\n    // mixes non-fragments and fragments for the same variable is too expensive\n    // to detect in the verifier.\n    if (DwarfExpr->isUnknownLocation())\n      DwarfExpr->setMemoryLocationKind();\n    DwarfExpr->addExpression(Expr);\n  }\n  if (Asm->TM.getTargetTriple().isNVPTX() && DD->tuneForGDB()) {\n    // According to\n    // https://docs.nvidia.com/cuda/archive/10.0/ptx-writers-guide-to-interoperability/index.html#cuda-specific-dwarf\n    // cuda-gdb requires DW_AT_address_class for all variables to be able to\n    // correctly interpret address space of the variable address.\n    const unsigned NVPTX_ADDR_global_space = 5;\n    addUInt(*VariableDIE, dwarf::DW_AT_address_class, dwarf::DW_FORM_data1,\n            NVPTXAddressSpace ? *NVPTXAddressSpace : NVPTX_ADDR_global_space);\n  }\n  if (Loc)\n    addBlock(*VariableDIE, dwarf::DW_AT_location, DwarfExpr->finalize());\n\n  if (DD->useAllLinkageNames())\n    addLinkageName(*VariableDIE, GV->getLinkageName());\n\n  if (addToAccelTable) {\n    DD->addAccelName(*CUNode, GV->getName(), *VariableDIE);\n\n    // If the linkage name is different than the name, go ahead and output\n    // that as well into the name table.\n    if (GV->getLinkageName() != \"\" && GV->getName() != GV->getLinkageName() &&\n        DD->useAllLinkageNames())\n      DD->addAccelName(*CUNode, GV->getLinkageName(), *VariableDIE);\n  }\n}\n\nDIE *DwarfCompileUnit::getOrCreateCommonBlock(\n    const DICommonBlock *CB, ArrayRef<GlobalExpr> GlobalExprs) {\n  // Construct the context before querying for the existence of the DIE in case\n  // such construction creates the DIE.\n  DIE *ContextDIE = getOrCreateContextDIE(CB->getScope());\n\n  if (DIE *NDie = getDIE(CB))\n    return NDie;\n  DIE &NDie = createAndAddDIE(dwarf::DW_TAG_common_block, *ContextDIE, CB);\n  StringRef Name = CB->getName().empty() ? \"_BLNK_\" : CB->getName();\n  addString(NDie, dwarf::DW_AT_name, Name);\n  addGlobalName(Name, NDie, CB->getScope());\n  if (CB->getFile())\n    addSourceLine(NDie, CB->getLineNo(), CB->getFile());\n  if (DIGlobalVariable *V = CB->getDecl())\n    getCU().addLocationAttribute(&NDie, V, GlobalExprs);\n  return &NDie;\n}\n\nvoid DwarfCompileUnit::addRange(RangeSpan Range) {\n  DD->insertSectionLabel(Range.Begin);\n\n  bool SameAsPrevCU = this == DD->getPrevCU();\n  DD->setPrevCU(this);\n  // If we have no current ranges just add the range and return, otherwise,\n  // check the current section and CU against the previous section and CU we\n  // emitted into and the subprogram was contained within. If these are the\n  // same then extend our current range, otherwise add this as a new range.\n  if (CURanges.empty() || !SameAsPrevCU ||\n      (&CURanges.back().End->getSection() !=\n       &Range.End->getSection())) {\n    CURanges.push_back(Range);\n    return;\n  }\n\n  CURanges.back().End = Range.End;\n}\n\nvoid DwarfCompileUnit::initStmtList() {\n  if (CUNode->isDebugDirectivesOnly())\n    return;\n\n  const TargetLoweringObjectFile &TLOF = Asm->getObjFileLowering();\n  if (DD->useSectionsAsReferences()) {\n    LineTableStartSym = TLOF.getDwarfLineSection()->getBeginSymbol();\n  } else {\n    LineTableStartSym =\n        Asm->OutStreamer->getDwarfLineTableSymbol(getUniqueID());\n  }\n\n  // DW_AT_stmt_list is a offset of line number information for this\n  // compile unit in debug_line section. For split dwarf this is\n  // left in the skeleton CU and so not included.\n  // The line table entries are not always emitted in assembly, so it\n  // is not okay to use line_table_start here.\n      addSectionLabel(getUnitDie(), dwarf::DW_AT_stmt_list, LineTableStartSym,\n                      TLOF.getDwarfLineSection()->getBeginSymbol());\n}\n\nvoid DwarfCompileUnit::applyStmtList(DIE &D) {\n  const TargetLoweringObjectFile &TLOF = Asm->getObjFileLowering();\n  addSectionLabel(D, dwarf::DW_AT_stmt_list, LineTableStartSym,\n                  TLOF.getDwarfLineSection()->getBeginSymbol());\n}\n\nvoid DwarfCompileUnit::attachLowHighPC(DIE &D, const MCSymbol *Begin,\n                                       const MCSymbol *End) {\n  assert(Begin && \"Begin label should not be null!\");\n  assert(End && \"End label should not be null!\");\n  assert(Begin->isDefined() && \"Invalid starting label\");\n  assert(End->isDefined() && \"Invalid end label\");\n\n  addLabelAddress(D, dwarf::DW_AT_low_pc, Begin);\n  if (DD->getDwarfVersion() < 4)\n    addLabelAddress(D, dwarf::DW_AT_high_pc, End);\n  else\n    addLabelDelta(D, dwarf::DW_AT_high_pc, End, Begin);\n}\n\n// Find DIE for the given subprogram and attach appropriate DW_AT_low_pc\n// and DW_AT_high_pc attributes. If there are global variables in this\n// scope then create and insert DIEs for these variables.\nDIE &DwarfCompileUnit::updateSubprogramScopeDIE(const DISubprogram *SP) {\n  DIE *SPDie = getOrCreateSubprogramDIE(SP, includeMinimalInlineScopes());\n\n  SmallVector<RangeSpan, 2> BB_List;\n  // If basic block sections are on, ranges for each basic block section has\n  // to be emitted separately.\n  for (const auto &R : Asm->MBBSectionRanges)\n    BB_List.push_back({R.second.BeginLabel, R.second.EndLabel});\n\n  attachRangesOrLowHighPC(*SPDie, BB_List);\n\n  if (DD->useAppleExtensionAttributes() &&\n      !DD->getCurrentFunction()->getTarget().Options.DisableFramePointerElim(\n          *DD->getCurrentFunction()))\n    addFlag(*SPDie, dwarf::DW_AT_APPLE_omit_frame_ptr);\n\n  // Only include DW_AT_frame_base in full debug info\n  if (!includeMinimalInlineScopes()) {\n    const TargetFrameLowering *TFI = Asm->MF->getSubtarget().getFrameLowering();\n    TargetFrameLowering::DwarfFrameBase FrameBase =\n        TFI->getDwarfFrameBase(*Asm->MF);\n    switch (FrameBase.Kind) {\n    case TargetFrameLowering::DwarfFrameBase::Register: {\n      if (Register::isPhysicalRegister(FrameBase.Location.Reg)) {\n        MachineLocation Location(FrameBase.Location.Reg);\n        addAddress(*SPDie, dwarf::DW_AT_frame_base, Location);\n      }\n      break;\n    }\n    case TargetFrameLowering::DwarfFrameBase::CFA: {\n      DIELoc *Loc = new (DIEValueAllocator) DIELoc;\n      addUInt(*Loc, dwarf::DW_FORM_data1, dwarf::DW_OP_call_frame_cfa);\n      addBlock(*SPDie, dwarf::DW_AT_frame_base, Loc);\n      break;\n    }\n    case TargetFrameLowering::DwarfFrameBase::WasmFrameBase: {\n      // FIXME: duplicated from Target/WebAssembly/WebAssembly.h\n      // don't want to depend on target specific headers in this code?\n      const unsigned TI_GLOBAL_RELOC = 3;\n      if (FrameBase.Location.WasmLoc.Kind == TI_GLOBAL_RELOC) {\n        // These need to be relocatable.\n        assert(FrameBase.Location.WasmLoc.Index == 0);  // Only SP so far.\n        auto SPSym = cast<MCSymbolWasm>(\n          Asm->GetExternalSymbolSymbol(\"__stack_pointer\"));\n        // FIXME: this repeats what WebAssemblyMCInstLower::\n        // GetExternalSymbolSymbol does, since if there's no code that\n        // refers to this symbol, we have to set it here.\n        SPSym->setType(wasm::WASM_SYMBOL_TYPE_GLOBAL);\n        SPSym->setGlobalType(wasm::WasmGlobalType{\n            uint8_t(Asm->getSubtargetInfo().getTargetTriple().getArch() ==\n                            Triple::wasm64\n                        ? wasm::WASM_TYPE_I64\n                        : wasm::WASM_TYPE_I32),\n            true});\n        DIELoc *Loc = new (DIEValueAllocator) DIELoc;\n        addUInt(*Loc, dwarf::DW_FORM_data1, dwarf::DW_OP_WASM_location);\n        addSInt(*Loc, dwarf::DW_FORM_sdata, TI_GLOBAL_RELOC);\n        if (!isDwoUnit()) {\n          addLabel(*Loc, dwarf::DW_FORM_data4, SPSym);\n          DD->addArangeLabel(SymbolCU(this, SPSym));\n        } else {\n          // FIXME: when writing dwo, we need to avoid relocations. Probably\n          // the \"right\" solution is to treat globals the way func and data\n          // symbols are (with entries in .debug_addr).\n          // For now, since we only ever use index 0, this should work as-is.       \n          addUInt(*Loc, dwarf::DW_FORM_data4, FrameBase.Location.WasmLoc.Index);\n        }\n        addUInt(*Loc, dwarf::DW_FORM_data1, dwarf::DW_OP_stack_value);\n        addBlock(*SPDie, dwarf::DW_AT_frame_base, Loc);\n      } else {\n        DIELoc *Loc = new (DIEValueAllocator) DIELoc;\n        DIEDwarfExpression DwarfExpr(*Asm, *this, *Loc);\n        DIExpressionCursor Cursor({});\n        DwarfExpr.addWasmLocation(FrameBase.Location.WasmLoc.Kind,\n            FrameBase.Location.WasmLoc.Index);\n        DwarfExpr.addExpression(std::move(Cursor));\n        addBlock(*SPDie, dwarf::DW_AT_frame_base, DwarfExpr.finalize());\n      }\n      break;\n    }\n    }\n  }\n\n  // Add name to the name table, we do this here because we're guaranteed\n  // to have concrete versions of our DW_TAG_subprogram nodes.\n  DD->addSubprogramNames(*CUNode, SP, *SPDie);\n\n  return *SPDie;\n}\n\n// Construct a DIE for this scope.\nvoid DwarfCompileUnit::constructScopeDIE(\n    LexicalScope *Scope, SmallVectorImpl<DIE *> &FinalChildren) {\n  if (!Scope || !Scope->getScopeNode())\n    return;\n\n  auto *DS = Scope->getScopeNode();\n\n  assert((Scope->getInlinedAt() || !isa<DISubprogram>(DS)) &&\n         \"Only handle inlined subprograms here, use \"\n         \"constructSubprogramScopeDIE for non-inlined \"\n         \"subprograms\");\n\n  SmallVector<DIE *, 8> Children;\n\n  // We try to create the scope DIE first, then the children DIEs. This will\n  // avoid creating un-used children then removing them later when we find out\n  // the scope DIE is null.\n  DIE *ScopeDIE;\n  if (Scope->getParent() && isa<DISubprogram>(DS)) {\n    ScopeDIE = constructInlinedScopeDIE(Scope);\n    if (!ScopeDIE)\n      return;\n    // We create children when the scope DIE is not null.\n    createScopeChildrenDIE(Scope, Children);\n  } else {\n    // Early exit when we know the scope DIE is going to be null.\n    if (DD->isLexicalScopeDIENull(Scope))\n      return;\n\n    bool HasNonScopeChildren = false;\n\n    // We create children here when we know the scope DIE is not going to be\n    // null and the children will be added to the scope DIE.\n    createScopeChildrenDIE(Scope, Children, &HasNonScopeChildren);\n\n    // If there are only other scopes as children, put them directly in the\n    // parent instead, as this scope would serve no purpose.\n    if (!HasNonScopeChildren) {\n      FinalChildren.insert(FinalChildren.end(),\n                           std::make_move_iterator(Children.begin()),\n                           std::make_move_iterator(Children.end()));\n      return;\n    }\n    ScopeDIE = constructLexicalScopeDIE(Scope);\n    assert(ScopeDIE && \"Scope DIE should not be null.\");\n  }\n\n  // Add children\n  for (auto &I : Children)\n    ScopeDIE->addChild(std::move(I));\n\n  FinalChildren.push_back(std::move(ScopeDIE));\n}\n\nvoid DwarfCompileUnit::addScopeRangeList(DIE &ScopeDIE,\n                                         SmallVector<RangeSpan, 2> Range) {\n\n  HasRangeLists = true;\n\n  // Add the range list to the set of ranges to be emitted.\n  auto IndexAndList =\n      (DD->getDwarfVersion() < 5 && Skeleton ? Skeleton->DU : DU)\n          ->addRange(*(Skeleton ? Skeleton : this), std::move(Range));\n\n  uint32_t Index = IndexAndList.first;\n  auto &List = *IndexAndList.second;\n\n  // Under fission, ranges are specified by constant offsets relative to the\n  // CU's DW_AT_GNU_ranges_base.\n  // FIXME: For DWARF v5, do not generate the DW_AT_ranges attribute under\n  // fission until we support the forms using the .debug_addr section\n  // (DW_RLE_startx_endx etc.).\n  if (DD->getDwarfVersion() >= 5)\n    addUInt(ScopeDIE, dwarf::DW_AT_ranges, dwarf::DW_FORM_rnglistx, Index);\n  else {\n    const TargetLoweringObjectFile &TLOF = Asm->getObjFileLowering();\n    const MCSymbol *RangeSectionSym =\n        TLOF.getDwarfRangesSection()->getBeginSymbol();\n    if (isDwoUnit())\n      addSectionDelta(ScopeDIE, dwarf::DW_AT_ranges, List.Label,\n                      RangeSectionSym);\n    else\n      addSectionLabel(ScopeDIE, dwarf::DW_AT_ranges, List.Label,\n                      RangeSectionSym);\n  }\n}\n\nvoid DwarfCompileUnit::attachRangesOrLowHighPC(\n    DIE &Die, SmallVector<RangeSpan, 2> Ranges) {\n  assert(!Ranges.empty());\n  if (!DD->useRangesSection() ||\n      (Ranges.size() == 1 &&\n       (!DD->alwaysUseRanges() ||\n        DD->getSectionLabel(&Ranges.front().Begin->getSection()) ==\n            Ranges.front().Begin))) {\n    const RangeSpan &Front = Ranges.front();\n    const RangeSpan &Back = Ranges.back();\n    attachLowHighPC(Die, Front.Begin, Back.End);\n  } else\n    addScopeRangeList(Die, std::move(Ranges));\n}\n\nvoid DwarfCompileUnit::attachRangesOrLowHighPC(\n    DIE &Die, const SmallVectorImpl<InsnRange> &Ranges) {\n  SmallVector<RangeSpan, 2> List;\n  List.reserve(Ranges.size());\n  for (const InsnRange &R : Ranges) {\n    auto *BeginLabel = DD->getLabelBeforeInsn(R.first);\n    auto *EndLabel = DD->getLabelAfterInsn(R.second);\n\n    const auto *BeginMBB = R.first->getParent();\n    const auto *EndMBB = R.second->getParent();\n\n    const auto *MBB = BeginMBB;\n    // Basic block sections allows basic block subsets to be placed in unique\n    // sections. For each section, the begin and end label must be added to the\n    // list. If there is more than one range, debug ranges must be used.\n    // Otherwise, low/high PC can be used.\n    // FIXME: Debug Info Emission depends on block order and this assumes that\n    // the order of blocks will be frozen beyond this point.\n    do {\n      if (MBB->sameSection(EndMBB) || MBB->isEndSection()) {\n        auto MBBSectionRange = Asm->MBBSectionRanges[MBB->getSectionIDNum()];\n        List.push_back(\n            {MBB->sameSection(BeginMBB) ? BeginLabel\n                                        : MBBSectionRange.BeginLabel,\n             MBB->sameSection(EndMBB) ? EndLabel : MBBSectionRange.EndLabel});\n      }\n      if (MBB->sameSection(EndMBB))\n        break;\n      MBB = MBB->getNextNode();\n    } while (true);\n  }\n  attachRangesOrLowHighPC(Die, std::move(List));\n}\n\n// This scope represents inlined body of a function. Construct DIE to\n// represent this concrete inlined copy of the function.\nDIE *DwarfCompileUnit::constructInlinedScopeDIE(LexicalScope *Scope) {\n  assert(Scope->getScopeNode());\n  auto *DS = Scope->getScopeNode();\n  auto *InlinedSP = getDISubprogram(DS);\n  // Find the subprogram's DwarfCompileUnit in the SPMap in case the subprogram\n  // was inlined from another compile unit.\n  DIE *OriginDIE = getAbstractSPDies()[InlinedSP];\n  assert(OriginDIE && \"Unable to find original DIE for an inlined subprogram.\");\n\n  auto ScopeDIE = DIE::get(DIEValueAllocator, dwarf::DW_TAG_inlined_subroutine);\n  addDIEEntry(*ScopeDIE, dwarf::DW_AT_abstract_origin, *OriginDIE);\n\n  attachRangesOrLowHighPC(*ScopeDIE, Scope->getRanges());\n\n  // Add the call site information to the DIE.\n  const DILocation *IA = Scope->getInlinedAt();\n  addUInt(*ScopeDIE, dwarf::DW_AT_call_file, None,\n          getOrCreateSourceID(IA->getFile()));\n  addUInt(*ScopeDIE, dwarf::DW_AT_call_line, None, IA->getLine());\n  if (IA->getColumn())\n    addUInt(*ScopeDIE, dwarf::DW_AT_call_column, None, IA->getColumn());\n  if (IA->getDiscriminator() && DD->getDwarfVersion() >= 4)\n    addUInt(*ScopeDIE, dwarf::DW_AT_GNU_discriminator, None,\n            IA->getDiscriminator());\n\n  // Add name to the name table, we do this here because we're guaranteed\n  // to have concrete versions of our DW_TAG_inlined_subprogram nodes.\n  DD->addSubprogramNames(*CUNode, InlinedSP, *ScopeDIE);\n\n  return ScopeDIE;\n}\n\n// Construct new DW_TAG_lexical_block for this scope and attach\n// DW_AT_low_pc/DW_AT_high_pc labels.\nDIE *DwarfCompileUnit::constructLexicalScopeDIE(LexicalScope *Scope) {\n  if (DD->isLexicalScopeDIENull(Scope))\n    return nullptr;\n\n  auto ScopeDIE = DIE::get(DIEValueAllocator, dwarf::DW_TAG_lexical_block);\n  if (Scope->isAbstractScope())\n    return ScopeDIE;\n\n  attachRangesOrLowHighPC(*ScopeDIE, Scope->getRanges());\n\n  return ScopeDIE;\n}\n\n/// constructVariableDIE - Construct a DIE for the given DbgVariable.\nDIE *DwarfCompileUnit::constructVariableDIE(DbgVariable &DV, bool Abstract) {\n  auto D = constructVariableDIEImpl(DV, Abstract);\n  DV.setDIE(*D);\n  return D;\n}\n\nDIE *DwarfCompileUnit::constructLabelDIE(DbgLabel &DL,\n                                         const LexicalScope &Scope) {\n  auto LabelDie = DIE::get(DIEValueAllocator, DL.getTag());\n  insertDIE(DL.getLabel(), LabelDie);\n  DL.setDIE(*LabelDie);\n\n  if (Scope.isAbstractScope())\n    applyLabelAttributes(DL, *LabelDie);\n\n  return LabelDie;\n}\n\nDIE *DwarfCompileUnit::constructVariableDIEImpl(const DbgVariable &DV,\n                                                bool Abstract) {\n  // Define variable debug information entry.\n  auto VariableDie = DIE::get(DIEValueAllocator, DV.getTag());\n  insertDIE(DV.getVariable(), VariableDie);\n\n  if (Abstract) {\n    applyVariableAttributes(DV, *VariableDie);\n    return VariableDie;\n  }\n\n  // Add variable address.\n\n  unsigned Index = DV.getDebugLocListIndex();\n  if (Index != ~0U) {\n    addLocationList(*VariableDie, dwarf::DW_AT_location, Index);\n    auto TagOffset = DV.getDebugLocListTagOffset();\n    if (TagOffset)\n      addUInt(*VariableDie, dwarf::DW_AT_LLVM_tag_offset, dwarf::DW_FORM_data1,\n              *TagOffset);\n    return VariableDie;\n  }\n\n  // Check if variable has a single location description.\n  if (auto *DVal = DV.getValueLoc()) {\n    if (!DVal->isVariadic()) {\n      const DbgValueLocEntry *Entry = DVal->getLocEntries().begin();\n      if (Entry->isLocation()) {\n        addVariableAddress(DV, *VariableDie, Entry->getLoc());\n      } else if (Entry->isInt()) {\n        auto *Expr = DV.getSingleExpression();\n        if (Expr && Expr->getNumElements()) {\n          DIELoc *Loc = new (DIEValueAllocator) DIELoc;\n          DIEDwarfExpression DwarfExpr(*Asm, *this, *Loc);\n          // If there is an expression, emit raw unsigned bytes.\n          DwarfExpr.addFragmentOffset(Expr);\n          DwarfExpr.addUnsignedConstant(Entry->getInt());\n          DwarfExpr.addExpression(Expr);\n          addBlock(*VariableDie, dwarf::DW_AT_location, DwarfExpr.finalize());\n          if (DwarfExpr.TagOffset)\n            addUInt(*VariableDie, dwarf::DW_AT_LLVM_tag_offset,\n                    dwarf::DW_FORM_data1, *DwarfExpr.TagOffset);\n        } else\n          addConstantValue(*VariableDie, Entry->getInt(), DV.getType());\n      } else if (Entry->isConstantFP()) {\n        addConstantFPValue(*VariableDie, Entry->getConstantFP());\n      } else if (Entry->isConstantInt()) {\n        addConstantValue(*VariableDie, Entry->getConstantInt(), DV.getType());\n      } else if (Entry->isTargetIndexLocation()) {\n        DIELoc *Loc = new (DIEValueAllocator) DIELoc;\n        DIEDwarfExpression DwarfExpr(*Asm, *this, *Loc);\n        const DIBasicType *BT = dyn_cast<DIBasicType>(\n            static_cast<const Metadata *>(DV.getVariable()->getType()));\n        DwarfDebug::emitDebugLocValue(*Asm, BT, *DVal, DwarfExpr);\n        addBlock(*VariableDie, dwarf::DW_AT_location, DwarfExpr.finalize());\n      }\n      return VariableDie;\n    }\n    // If any of the location entries are registers with the value 0, then the\n    // location is undefined.\n    if (any_of(DVal->getLocEntries(), [](const DbgValueLocEntry &Entry) {\n          return Entry.isLocation() && !Entry.getLoc().getReg();\n        }))\n      return VariableDie;\n    const DIExpression *Expr = DV.getSingleExpression();\n    assert(Expr && \"Variadic Debug Value must have an Expression.\");\n    DIELoc *Loc = new (DIEValueAllocator) DIELoc;\n    DIEDwarfExpression DwarfExpr(*Asm, *this, *Loc);\n    DwarfExpr.addFragmentOffset(Expr);\n    DIExpressionCursor Cursor(Expr);\n    const TargetRegisterInfo &TRI = *Asm->MF->getSubtarget().getRegisterInfo();\n\n    auto AddEntry = [&](const DbgValueLocEntry &Entry,\n                                            DIExpressionCursor &Cursor) {\n      if (Entry.isLocation()) {\n        if (!DwarfExpr.addMachineRegExpression(TRI, Cursor,\n                                               Entry.getLoc().getReg()))\n          return false;\n      } else if (Entry.isInt()) {\n        // If there is an expression, emit raw unsigned bytes.\n        DwarfExpr.addUnsignedConstant(Entry.getInt());\n      } else if (Entry.isConstantFP()) {\n        APInt RawBytes = Entry.getConstantFP()->getValueAPF().bitcastToAPInt();\n        DwarfExpr.addUnsignedConstant(RawBytes);\n      } else if (Entry.isConstantInt()) {\n        APInt RawBytes = Entry.getConstantInt()->getValue();\n        DwarfExpr.addUnsignedConstant(RawBytes);\n      } else if (Entry.isTargetIndexLocation()) {\n        TargetIndexLocation Loc = Entry.getTargetIndexLocation();\n        // TODO TargetIndexLocation is a target-independent. Currently only the\n        // WebAssembly-specific encoding is supported.\n        assert(Asm->TM.getTargetTriple().isWasm());\n        DwarfExpr.addWasmLocation(Loc.Index, static_cast<uint64_t>(Loc.Offset));\n      } else {\n        llvm_unreachable(\"Unsupported Entry type.\");\n      }\n      return true;\n    };\n\n    DwarfExpr.addExpression(\n        std::move(Cursor),\n        [&](unsigned Idx, DIExpressionCursor &Cursor) -> bool {\n          return AddEntry(DVal->getLocEntries()[Idx], Cursor);\n        });\n\n    // Now attach the location information to the DIE.\n    addBlock(*VariableDie, dwarf::DW_AT_location, DwarfExpr.finalize());\n    if (DwarfExpr.TagOffset)\n      addUInt(*VariableDie, dwarf::DW_AT_LLVM_tag_offset, dwarf::DW_FORM_data1,\n              *DwarfExpr.TagOffset);\n\n    return VariableDie;\n  }\n\n  // .. else use frame index.\n  if (!DV.hasFrameIndexExprs())\n    return VariableDie;\n\n  Optional<unsigned> NVPTXAddressSpace;\n  DIELoc *Loc = new (DIEValueAllocator) DIELoc;\n  DIEDwarfExpression DwarfExpr(*Asm, *this, *Loc);\n  for (auto &Fragment : DV.getFrameIndexExprs()) {\n    Register FrameReg;\n    const DIExpression *Expr = Fragment.Expr;\n    const TargetFrameLowering *TFI = Asm->MF->getSubtarget().getFrameLowering();\n    StackOffset Offset =\n        TFI->getFrameIndexReference(*Asm->MF, Fragment.FI, FrameReg);\n    DwarfExpr.addFragmentOffset(Expr);\n\n    auto *TRI = Asm->MF->getSubtarget().getRegisterInfo();\n    SmallVector<uint64_t, 8> Ops;\n    TRI->getOffsetOpcodes(Offset, Ops);\n\n    // According to\n    // https://docs.nvidia.com/cuda/archive/10.0/ptx-writers-guide-to-interoperability/index.html#cuda-specific-dwarf\n    // cuda-gdb requires DW_AT_address_class for all variables to be able to\n    // correctly interpret address space of the variable address.\n    // Decode DW_OP_constu <DWARF Address Space> DW_OP_swap DW_OP_xderef\n    // sequence for the NVPTX + gdb target.\n    unsigned LocalNVPTXAddressSpace;\n    if (Asm->TM.getTargetTriple().isNVPTX() && DD->tuneForGDB()) {\n      const DIExpression *NewExpr =\n          DIExpression::extractAddressClass(Expr, LocalNVPTXAddressSpace);\n      if (NewExpr != Expr) {\n        Expr = NewExpr;\n        NVPTXAddressSpace = LocalNVPTXAddressSpace;\n      }\n    }\n    if (Expr)\n      Ops.append(Expr->elements_begin(), Expr->elements_end());\n    DIExpressionCursor Cursor(Ops);\n    DwarfExpr.setMemoryLocationKind();\n    if (const MCSymbol *FrameSymbol = Asm->getFunctionFrameSymbol())\n      addOpAddress(*Loc, FrameSymbol);\n    else\n      DwarfExpr.addMachineRegExpression(\n          *Asm->MF->getSubtarget().getRegisterInfo(), Cursor, FrameReg);\n    DwarfExpr.addExpression(std::move(Cursor));\n  }\n  if (Asm->TM.getTargetTriple().isNVPTX() && DD->tuneForGDB()) {\n    // According to\n    // https://docs.nvidia.com/cuda/archive/10.0/ptx-writers-guide-to-interoperability/index.html#cuda-specific-dwarf\n    // cuda-gdb requires DW_AT_address_class for all variables to be able to\n    // correctly interpret address space of the variable address.\n    const unsigned NVPTX_ADDR_local_space = 6;\n    addUInt(*VariableDie, dwarf::DW_AT_address_class, dwarf::DW_FORM_data1,\n            NVPTXAddressSpace ? *NVPTXAddressSpace : NVPTX_ADDR_local_space);\n  }\n  addBlock(*VariableDie, dwarf::DW_AT_location, DwarfExpr.finalize());\n  if (DwarfExpr.TagOffset)\n    addUInt(*VariableDie, dwarf::DW_AT_LLVM_tag_offset, dwarf::DW_FORM_data1,\n            *DwarfExpr.TagOffset);\n\n  return VariableDie;\n}\n\nDIE *DwarfCompileUnit::constructVariableDIE(DbgVariable &DV,\n                                            const LexicalScope &Scope,\n                                            DIE *&ObjectPointer) {\n  auto Var = constructVariableDIE(DV, Scope.isAbstractScope());\n  if (DV.isObjectPointer())\n    ObjectPointer = Var;\n  return Var;\n}\n\n/// Return all DIVariables that appear in count: expressions.\nstatic SmallVector<const DIVariable *, 2> dependencies(DbgVariable *Var) {\n  SmallVector<const DIVariable *, 2> Result;\n  auto *Array = dyn_cast<DICompositeType>(Var->getType());\n  if (!Array || Array->getTag() != dwarf::DW_TAG_array_type)\n    return Result;\n  if (auto *DLVar = Array->getDataLocation())\n    Result.push_back(DLVar);\n  if (auto *AsVar = Array->getAssociated())\n    Result.push_back(AsVar);\n  if (auto *AlVar = Array->getAllocated())\n    Result.push_back(AlVar);\n  for (auto *El : Array->getElements()) {\n    if (auto *Subrange = dyn_cast<DISubrange>(El)) {\n      if (auto Count = Subrange->getCount())\n        if (auto *Dependency = Count.dyn_cast<DIVariable *>())\n          Result.push_back(Dependency);\n      if (auto LB = Subrange->getLowerBound())\n        if (auto *Dependency = LB.dyn_cast<DIVariable *>())\n          Result.push_back(Dependency);\n      if (auto UB = Subrange->getUpperBound())\n        if (auto *Dependency = UB.dyn_cast<DIVariable *>())\n          Result.push_back(Dependency);\n      if (auto ST = Subrange->getStride())\n        if (auto *Dependency = ST.dyn_cast<DIVariable *>())\n          Result.push_back(Dependency);\n    } else if (auto *GenericSubrange = dyn_cast<DIGenericSubrange>(El)) {\n      if (auto Count = GenericSubrange->getCount())\n        if (auto *Dependency = Count.dyn_cast<DIVariable *>())\n          Result.push_back(Dependency);\n      if (auto LB = GenericSubrange->getLowerBound())\n        if (auto *Dependency = LB.dyn_cast<DIVariable *>())\n          Result.push_back(Dependency);\n      if (auto UB = GenericSubrange->getUpperBound())\n        if (auto *Dependency = UB.dyn_cast<DIVariable *>())\n          Result.push_back(Dependency);\n      if (auto ST = GenericSubrange->getStride())\n        if (auto *Dependency = ST.dyn_cast<DIVariable *>())\n          Result.push_back(Dependency);\n    }\n  }\n  return Result;\n}\n\n/// Sort local variables so that variables appearing inside of helper\n/// expressions come first.\nstatic SmallVector<DbgVariable *, 8>\nsortLocalVars(SmallVectorImpl<DbgVariable *> &Input) {\n  SmallVector<DbgVariable *, 8> Result;\n  SmallVector<PointerIntPair<DbgVariable *, 1>, 8> WorkList;\n  // Map back from a DIVariable to its containing DbgVariable.\n  SmallDenseMap<const DILocalVariable *, DbgVariable *> DbgVar;\n  // Set of DbgVariables in Result.\n  SmallDenseSet<DbgVariable *, 8> Visited;\n  // For cycle detection.\n  SmallDenseSet<DbgVariable *, 8> Visiting;\n\n  // Initialize the worklist and the DIVariable lookup table.\n  for (auto Var : reverse(Input)) {\n    DbgVar.insert({Var->getVariable(), Var});\n    WorkList.push_back({Var, 0});\n  }\n\n  // Perform a stable topological sort by doing a DFS.\n  while (!WorkList.empty()) {\n    auto Item = WorkList.back();\n    DbgVariable *Var = Item.getPointer();\n    bool visitedAllDependencies = Item.getInt();\n    WorkList.pop_back();\n\n    // Dependency is in a different lexical scope or a global.\n    if (!Var)\n      continue;\n\n    // Already handled.\n    if (Visited.count(Var))\n      continue;\n\n    // Add to Result if all dependencies are visited.\n    if (visitedAllDependencies) {\n      Visited.insert(Var);\n      Result.push_back(Var);\n      continue;\n    }\n\n    // Detect cycles.\n    auto Res = Visiting.insert(Var);\n    if (!Res.second) {\n      assert(false && \"dependency cycle in local variables\");\n      return Result;\n    }\n\n    // Push dependencies and this node onto the worklist, so that this node is\n    // visited again after all of its dependencies are handled.\n    WorkList.push_back({Var, 1});\n    for (auto *Dependency : dependencies(Var)) {\n      auto Dep = dyn_cast_or_null<const DILocalVariable>(Dependency);\n      WorkList.push_back({DbgVar[Dep], 0});\n    }\n  }\n  return Result;\n}\n\nDIE *DwarfCompileUnit::createScopeChildrenDIE(LexicalScope *Scope,\n                                              SmallVectorImpl<DIE *> &Children,\n                                              bool *HasNonScopeChildren) {\n  assert(Children.empty());\n  DIE *ObjectPointer = nullptr;\n\n  // Emit function arguments (order is significant).\n  auto Vars = DU->getScopeVariables().lookup(Scope);\n  for (auto &DV : Vars.Args)\n    Children.push_back(constructVariableDIE(*DV.second, *Scope, ObjectPointer));\n\n  // Emit local variables.\n  auto Locals = sortLocalVars(Vars.Locals);\n  for (DbgVariable *DV : Locals)\n    Children.push_back(constructVariableDIE(*DV, *Scope, ObjectPointer));\n\n  // Skip imported directives in gmlt-like data.\n  if (!includeMinimalInlineScopes()) {\n    // There is no need to emit empty lexical block DIE.\n    for (const auto *IE : ImportedEntities[Scope->getScopeNode()])\n      Children.push_back(\n          constructImportedEntityDIE(cast<DIImportedEntity>(IE)));\n  }\n\n  if (HasNonScopeChildren)\n    *HasNonScopeChildren = !Children.empty();\n\n  for (DbgLabel *DL : DU->getScopeLabels().lookup(Scope))\n    Children.push_back(constructLabelDIE(*DL, *Scope));\n\n  for (LexicalScope *LS : Scope->getChildren())\n    constructScopeDIE(LS, Children);\n\n  return ObjectPointer;\n}\n\nDIE &DwarfCompileUnit::constructSubprogramScopeDIE(const DISubprogram *Sub,\n                                                   LexicalScope *Scope) {\n  DIE &ScopeDIE = updateSubprogramScopeDIE(Sub);\n\n  if (Scope) {\n    assert(!Scope->getInlinedAt());\n    assert(!Scope->isAbstractScope());\n    // Collect lexical scope children first.\n    // ObjectPointer might be a local (non-argument) local variable if it's a\n    // block's synthetic this pointer.\n    if (DIE *ObjectPointer = createAndAddScopeChildren(Scope, ScopeDIE))\n      addDIEEntry(ScopeDIE, dwarf::DW_AT_object_pointer, *ObjectPointer);\n  }\n\n  // If this is a variadic function, add an unspecified parameter.\n  DITypeRefArray FnArgs = Sub->getType()->getTypeArray();\n\n  // If we have a single element of null, it is a function that returns void.\n  // If we have more than one elements and the last one is null, it is a\n  // variadic function.\n  if (FnArgs.size() > 1 && !FnArgs[FnArgs.size() - 1] &&\n      !includeMinimalInlineScopes())\n    ScopeDIE.addChild(\n        DIE::get(DIEValueAllocator, dwarf::DW_TAG_unspecified_parameters));\n\n  return ScopeDIE;\n}\n\nDIE *DwarfCompileUnit::createAndAddScopeChildren(LexicalScope *Scope,\n                                                 DIE &ScopeDIE) {\n  // We create children when the scope DIE is not null.\n  SmallVector<DIE *, 8> Children;\n  DIE *ObjectPointer = createScopeChildrenDIE(Scope, Children);\n\n  // Add children\n  for (auto &I : Children)\n    ScopeDIE.addChild(std::move(I));\n\n  return ObjectPointer;\n}\n\nvoid DwarfCompileUnit::constructAbstractSubprogramScopeDIE(\n    LexicalScope *Scope) {\n  DIE *&AbsDef = getAbstractSPDies()[Scope->getScopeNode()];\n  if (AbsDef)\n    return;\n\n  auto *SP = cast<DISubprogram>(Scope->getScopeNode());\n\n  DIE *ContextDIE;\n  DwarfCompileUnit *ContextCU = this;\n\n  if (includeMinimalInlineScopes())\n    ContextDIE = &getUnitDie();\n  // Some of this is duplicated from DwarfUnit::getOrCreateSubprogramDIE, with\n  // the important distinction that the debug node is not associated with the\n  // DIE (since the debug node will be associated with the concrete DIE, if\n  // any). It could be refactored to some common utility function.\n  else if (auto *SPDecl = SP->getDeclaration()) {\n    ContextDIE = &getUnitDie();\n    getOrCreateSubprogramDIE(SPDecl);\n  } else {\n    ContextDIE = getOrCreateContextDIE(SP->getScope());\n    // The scope may be shared with a subprogram that has already been\n    // constructed in another CU, in which case we need to construct this\n    // subprogram in the same CU.\n    ContextCU = DD->lookupCU(ContextDIE->getUnitDie());\n  }\n\n  // Passing null as the associated node because the abstract definition\n  // shouldn't be found by lookup.\n  AbsDef = &ContextCU->createAndAddDIE(dwarf::DW_TAG_subprogram, *ContextDIE, nullptr);\n  ContextCU->applySubprogramAttributesToDefinition(SP, *AbsDef);\n\n  if (!ContextCU->includeMinimalInlineScopes())\n    ContextCU->addUInt(*AbsDef, dwarf::DW_AT_inline, None, dwarf::DW_INL_inlined);\n  if (DIE *ObjectPointer = ContextCU->createAndAddScopeChildren(Scope, *AbsDef))\n    ContextCU->addDIEEntry(*AbsDef, dwarf::DW_AT_object_pointer, *ObjectPointer);\n}\n\nbool DwarfCompileUnit::useGNUAnalogForDwarf5Feature() const {\n  return DD->getDwarfVersion() == 4 && !DD->tuneForLLDB();\n}\n\ndwarf::Tag DwarfCompileUnit::getDwarf5OrGNUTag(dwarf::Tag Tag) const {\n  if (!useGNUAnalogForDwarf5Feature())\n    return Tag;\n  switch (Tag) {\n  case dwarf::DW_TAG_call_site:\n    return dwarf::DW_TAG_GNU_call_site;\n  case dwarf::DW_TAG_call_site_parameter:\n    return dwarf::DW_TAG_GNU_call_site_parameter;\n  default:\n    llvm_unreachable(\"DWARF5 tag with no GNU analog\");\n  }\n}\n\ndwarf::Attribute\nDwarfCompileUnit::getDwarf5OrGNUAttr(dwarf::Attribute Attr) const {\n  if (!useGNUAnalogForDwarf5Feature())\n    return Attr;\n  switch (Attr) {\n  case dwarf::DW_AT_call_all_calls:\n    return dwarf::DW_AT_GNU_all_call_sites;\n  case dwarf::DW_AT_call_target:\n    return dwarf::DW_AT_GNU_call_site_target;\n  case dwarf::DW_AT_call_origin:\n    return dwarf::DW_AT_abstract_origin;\n  case dwarf::DW_AT_call_return_pc:\n    return dwarf::DW_AT_low_pc;\n  case dwarf::DW_AT_call_value:\n    return dwarf::DW_AT_GNU_call_site_value;\n  case dwarf::DW_AT_call_tail_call:\n    return dwarf::DW_AT_GNU_tail_call;\n  default:\n    llvm_unreachable(\"DWARF5 attribute with no GNU analog\");\n  }\n}\n\ndwarf::LocationAtom\nDwarfCompileUnit::getDwarf5OrGNULocationAtom(dwarf::LocationAtom Loc) const {\n  if (!useGNUAnalogForDwarf5Feature())\n    return Loc;\n  switch (Loc) {\n  case dwarf::DW_OP_entry_value:\n    return dwarf::DW_OP_GNU_entry_value;\n  default:\n    llvm_unreachable(\"DWARF5 location atom with no GNU analog\");\n  }\n}\n\nDIE &DwarfCompileUnit::constructCallSiteEntryDIE(DIE &ScopeDIE,\n                                                 DIE *CalleeDIE,\n                                                 bool IsTail,\n                                                 const MCSymbol *PCAddr,\n                                                 const MCSymbol *CallAddr,\n                                                 unsigned CallReg) {\n  // Insert a call site entry DIE within ScopeDIE.\n  DIE &CallSiteDIE = createAndAddDIE(getDwarf5OrGNUTag(dwarf::DW_TAG_call_site),\n                                     ScopeDIE, nullptr);\n\n  if (CallReg) {\n    // Indirect call.\n    addAddress(CallSiteDIE, getDwarf5OrGNUAttr(dwarf::DW_AT_call_target),\n               MachineLocation(CallReg));\n  } else {\n    assert(CalleeDIE && \"No DIE for call site entry origin\");\n    addDIEEntry(CallSiteDIE, getDwarf5OrGNUAttr(dwarf::DW_AT_call_origin),\n                *CalleeDIE);\n  }\n\n  if (IsTail) {\n    // Attach DW_AT_call_tail_call to tail calls for standards compliance.\n    addFlag(CallSiteDIE, getDwarf5OrGNUAttr(dwarf::DW_AT_call_tail_call));\n\n    // Attach the address of the branch instruction to allow the debugger to\n    // show where the tail call occurred. This attribute has no GNU analog.\n    //\n    // GDB works backwards from non-standard usage of DW_AT_low_pc (in DWARF4\n    // mode -- equivalently, in DWARF5 mode, DW_AT_call_return_pc) at tail-call\n    // site entries to figure out the PC of tail-calling branch instructions.\n    // This means it doesn't need the compiler to emit DW_AT_call_pc, so we\n    // don't emit it here.\n    //\n    // There's no need to tie non-GDB debuggers to this non-standardness, as it\n    // adds unnecessary complexity to the debugger. For non-GDB debuggers, emit\n    // the standard DW_AT_call_pc info.\n    if (!useGNUAnalogForDwarf5Feature())\n      addLabelAddress(CallSiteDIE, dwarf::DW_AT_call_pc, CallAddr);\n  }\n\n  // Attach the return PC to allow the debugger to disambiguate call paths\n  // from one function to another.\n  //\n  // The return PC is only really needed when the call /isn't/ a tail call, but\n  // GDB expects it in DWARF4 mode, even for tail calls (see the comment above\n  // the DW_AT_call_pc emission logic for an explanation).\n  if (!IsTail || useGNUAnalogForDwarf5Feature()) {\n    assert(PCAddr && \"Missing return PC information for a call\");\n    addLabelAddress(CallSiteDIE,\n                    getDwarf5OrGNUAttr(dwarf::DW_AT_call_return_pc), PCAddr);\n  }\n\n  return CallSiteDIE;\n}\n\nvoid DwarfCompileUnit::constructCallSiteParmEntryDIEs(\n    DIE &CallSiteDIE, SmallVector<DbgCallSiteParam, 4> &Params) {\n  for (const auto &Param : Params) {\n    unsigned Register = Param.getRegister();\n    auto CallSiteDieParam =\n        DIE::get(DIEValueAllocator,\n                 getDwarf5OrGNUTag(dwarf::DW_TAG_call_site_parameter));\n    insertDIE(CallSiteDieParam);\n    addAddress(*CallSiteDieParam, dwarf::DW_AT_location,\n               MachineLocation(Register));\n\n    DIELoc *Loc = new (DIEValueAllocator) DIELoc;\n    DIEDwarfExpression DwarfExpr(*Asm, *this, *Loc);\n    DwarfExpr.setCallSiteParamValueFlag();\n\n    DwarfDebug::emitDebugLocValue(*Asm, nullptr, Param.getValue(), DwarfExpr);\n\n    addBlock(*CallSiteDieParam, getDwarf5OrGNUAttr(dwarf::DW_AT_call_value),\n             DwarfExpr.finalize());\n\n    CallSiteDIE.addChild(CallSiteDieParam);\n  }\n}\n\nDIE *DwarfCompileUnit::constructImportedEntityDIE(\n    const DIImportedEntity *Module) {\n  DIE *IMDie = DIE::get(DIEValueAllocator, (dwarf::Tag)Module->getTag());\n  insertDIE(Module, IMDie);\n  DIE *EntityDie;\n  auto *Entity = Module->getEntity();\n  if (auto *NS = dyn_cast<DINamespace>(Entity))\n    EntityDie = getOrCreateNameSpace(NS);\n  else if (auto *M = dyn_cast<DIModule>(Entity))\n    EntityDie = getOrCreateModule(M);\n  else if (auto *SP = dyn_cast<DISubprogram>(Entity))\n    EntityDie = getOrCreateSubprogramDIE(SP);\n  else if (auto *T = dyn_cast<DIType>(Entity))\n    EntityDie = getOrCreateTypeDIE(T);\n  else if (auto *GV = dyn_cast<DIGlobalVariable>(Entity))\n    EntityDie = getOrCreateGlobalVariableDIE(GV, {});\n  else\n    EntityDie = getDIE(Entity);\n  assert(EntityDie);\n  addSourceLine(*IMDie, Module->getLine(), Module->getFile());\n  addDIEEntry(*IMDie, dwarf::DW_AT_import, *EntityDie);\n  StringRef Name = Module->getName();\n  if (!Name.empty())\n    addString(*IMDie, dwarf::DW_AT_name, Name);\n\n  return IMDie;\n}\n\nvoid DwarfCompileUnit::finishSubprogramDefinition(const DISubprogram *SP) {\n  DIE *D = getDIE(SP);\n  if (DIE *AbsSPDIE = getAbstractSPDies().lookup(SP)) {\n    if (D)\n      // If this subprogram has an abstract definition, reference that\n      addDIEEntry(*D, dwarf::DW_AT_abstract_origin, *AbsSPDIE);\n  } else {\n    assert(D || includeMinimalInlineScopes());\n    if (D)\n      // And attach the attributes\n      applySubprogramAttributesToDefinition(SP, *D);\n  }\n}\n\nvoid DwarfCompileUnit::finishEntityDefinition(const DbgEntity *Entity) {\n  DbgEntity *AbsEntity = getExistingAbstractEntity(Entity->getEntity());\n\n  auto *Die = Entity->getDIE();\n  /// Label may be used to generate DW_AT_low_pc, so put it outside\n  /// if/else block.\n  const DbgLabel *Label = nullptr;\n  if (AbsEntity && AbsEntity->getDIE()) {\n    addDIEEntry(*Die, dwarf::DW_AT_abstract_origin, *AbsEntity->getDIE());\n    Label = dyn_cast<const DbgLabel>(Entity);\n  } else {\n    if (const DbgVariable *Var = dyn_cast<const DbgVariable>(Entity))\n      applyVariableAttributes(*Var, *Die);\n    else if ((Label = dyn_cast<const DbgLabel>(Entity)))\n      applyLabelAttributes(*Label, *Die);\n    else\n      llvm_unreachable(\"DbgEntity must be DbgVariable or DbgLabel.\");\n  }\n\n  if (Label)\n    if (const auto *Sym = Label->getSymbol())\n      addLabelAddress(*Die, dwarf::DW_AT_low_pc, Sym);\n}\n\nDbgEntity *DwarfCompileUnit::getExistingAbstractEntity(const DINode *Node) {\n  auto &AbstractEntities = getAbstractEntities();\n  auto I = AbstractEntities.find(Node);\n  if (I != AbstractEntities.end())\n    return I->second.get();\n  return nullptr;\n}\n\nvoid DwarfCompileUnit::createAbstractEntity(const DINode *Node,\n                                            LexicalScope *Scope) {\n  assert(Scope && Scope->isAbstractScope());\n  auto &Entity = getAbstractEntities()[Node];\n  if (isa<const DILocalVariable>(Node)) {\n    Entity = std::make_unique<DbgVariable>(\n                        cast<const DILocalVariable>(Node), nullptr /* IA */);;\n    DU->addScopeVariable(Scope, cast<DbgVariable>(Entity.get()));\n  } else if (isa<const DILabel>(Node)) {\n    Entity = std::make_unique<DbgLabel>(\n                        cast<const DILabel>(Node), nullptr /* IA */);\n    DU->addScopeLabel(Scope, cast<DbgLabel>(Entity.get()));\n  }\n}\n\nvoid DwarfCompileUnit::emitHeader(bool UseOffsets) {\n  // Don't bother labeling the .dwo unit, as its offset isn't used.\n  if (!Skeleton && !DD->useSectionsAsReferences()) {\n    LabelBegin = Asm->createTempSymbol(\"cu_begin\");\n    Asm->OutStreamer->emitLabel(LabelBegin);\n  }\n\n  dwarf::UnitType UT = Skeleton ? dwarf::DW_UT_split_compile\n                                : DD->useSplitDwarf() ? dwarf::DW_UT_skeleton\n                                                      : dwarf::DW_UT_compile;\n  DwarfUnit::emitCommonHeader(UseOffsets, UT);\n  if (DD->getDwarfVersion() >= 5 && UT != dwarf::DW_UT_compile)\n    Asm->emitInt64(getDWOId());\n}\n\nbool DwarfCompileUnit::hasDwarfPubSections() const {\n  switch (CUNode->getNameTableKind()) {\n  case DICompileUnit::DebugNameTableKind::None:\n    return false;\n    // Opting in to GNU Pubnames/types overrides the default to ensure these are\n    // generated for things like Gold's gdb_index generation.\n  case DICompileUnit::DebugNameTableKind::GNU:\n    return true;\n  case DICompileUnit::DebugNameTableKind::Default:\n    return DD->tuneForGDB() && !includeMinimalInlineScopes() &&\n           !CUNode->isDebugDirectivesOnly() &&\n           DD->getAccelTableKind() != AccelTableKind::Apple &&\n           DD->getDwarfVersion() < 5;\n  }\n  llvm_unreachable(\"Unhandled DICompileUnit::DebugNameTableKind enum\");\n}\n\n/// addGlobalName - Add a new global name to the compile unit.\nvoid DwarfCompileUnit::addGlobalName(StringRef Name, const DIE &Die,\n                                     const DIScope *Context) {\n  if (!hasDwarfPubSections())\n    return;\n  std::string FullName = getParentContextString(Context) + Name.str();\n  GlobalNames[FullName] = &Die;\n}\n\nvoid DwarfCompileUnit::addGlobalNameForTypeUnit(StringRef Name,\n                                                const DIScope *Context) {\n  if (!hasDwarfPubSections())\n    return;\n  std::string FullName = getParentContextString(Context) + Name.str();\n  // Insert, allowing the entry to remain as-is if it's already present\n  // This way the CU-level type DIE is preferred over the \"can't describe this\n  // type as a unit offset because it's not really in the CU at all, it's only\n  // in a type unit\"\n  GlobalNames.insert(std::make_pair(std::move(FullName), &getUnitDie()));\n}\n\n/// Add a new global type to the unit.\nvoid DwarfCompileUnit::addGlobalType(const DIType *Ty, const DIE &Die,\n                                     const DIScope *Context) {\n  if (!hasDwarfPubSections())\n    return;\n  std::string FullName = getParentContextString(Context) + Ty->getName().str();\n  GlobalTypes[FullName] = &Die;\n}\n\nvoid DwarfCompileUnit::addGlobalTypeUnitType(const DIType *Ty,\n                                             const DIScope *Context) {\n  if (!hasDwarfPubSections())\n    return;\n  std::string FullName = getParentContextString(Context) + Ty->getName().str();\n  // Insert, allowing the entry to remain as-is if it's already present\n  // This way the CU-level type DIE is preferred over the \"can't describe this\n  // type as a unit offset because it's not really in the CU at all, it's only\n  // in a type unit\"\n  GlobalTypes.insert(std::make_pair(std::move(FullName), &getUnitDie()));\n}\n\nvoid DwarfCompileUnit::addVariableAddress(const DbgVariable &DV, DIE &Die,\n                                          MachineLocation Location) {\n  if (DV.hasComplexAddress())\n    addComplexAddress(DV, Die, dwarf::DW_AT_location, Location);\n  else\n    addAddress(Die, dwarf::DW_AT_location, Location);\n}\n\n/// Add an address attribute to a die based on the location provided.\nvoid DwarfCompileUnit::addAddress(DIE &Die, dwarf::Attribute Attribute,\n                                  const MachineLocation &Location) {\n  DIELoc *Loc = new (DIEValueAllocator) DIELoc;\n  DIEDwarfExpression DwarfExpr(*Asm, *this, *Loc);\n  if (Location.isIndirect())\n    DwarfExpr.setMemoryLocationKind();\n\n  DIExpressionCursor Cursor({});\n  const TargetRegisterInfo &TRI = *Asm->MF->getSubtarget().getRegisterInfo();\n  if (!DwarfExpr.addMachineRegExpression(TRI, Cursor, Location.getReg()))\n    return;\n  DwarfExpr.addExpression(std::move(Cursor));\n\n  // Now attach the location information to the DIE.\n  addBlock(Die, Attribute, DwarfExpr.finalize());\n\n  if (DwarfExpr.TagOffset)\n    addUInt(Die, dwarf::DW_AT_LLVM_tag_offset, dwarf::DW_FORM_data1,\n            *DwarfExpr.TagOffset);\n}\n\n/// Start with the address based on the location provided, and generate the\n/// DWARF information necessary to find the actual variable given the extra\n/// address information encoded in the DbgVariable, starting from the starting\n/// location.  Add the DWARF information to the die.\nvoid DwarfCompileUnit::addComplexAddress(const DbgVariable &DV, DIE &Die,\n                                         dwarf::Attribute Attribute,\n                                         const MachineLocation &Location) {\n  DIELoc *Loc = new (DIEValueAllocator) DIELoc;\n  DIEDwarfExpression DwarfExpr(*Asm, *this, *Loc);\n  const DIExpression *DIExpr = DV.getSingleExpression();\n  DwarfExpr.addFragmentOffset(DIExpr);\n  DwarfExpr.setLocation(Location, DIExpr);\n\n  DIExpressionCursor Cursor(DIExpr);\n\n  if (DIExpr->isEntryValue())\n    DwarfExpr.beginEntryValueExpression(Cursor);\n\n  const TargetRegisterInfo &TRI = *Asm->MF->getSubtarget().getRegisterInfo();\n  if (!DwarfExpr.addMachineRegExpression(TRI, Cursor, Location.getReg()))\n    return;\n  DwarfExpr.addExpression(std::move(Cursor));\n\n  // Now attach the location information to the DIE.\n  addBlock(Die, Attribute, DwarfExpr.finalize());\n\n  if (DwarfExpr.TagOffset)\n    addUInt(Die, dwarf::DW_AT_LLVM_tag_offset, dwarf::DW_FORM_data1,\n            *DwarfExpr.TagOffset);\n}\n\n/// Add a Dwarf loclistptr attribute data and value.\nvoid DwarfCompileUnit::addLocationList(DIE &Die, dwarf::Attribute Attribute,\n                                       unsigned Index) {\n  dwarf::Form Form = (DD->getDwarfVersion() >= 5)\n                         ? dwarf::DW_FORM_loclistx\n                         : DD->getDwarfSectionOffsetForm();\n  Die.addValue(DIEValueAllocator, Attribute, Form, DIELocList(Index));\n}\n\nvoid DwarfCompileUnit::applyVariableAttributes(const DbgVariable &Var,\n                                               DIE &VariableDie) {\n  StringRef Name = Var.getName();\n  if (!Name.empty())\n    addString(VariableDie, dwarf::DW_AT_name, Name);\n  const auto *DIVar = Var.getVariable();\n  if (DIVar)\n    if (uint32_t AlignInBytes = DIVar->getAlignInBytes())\n      addUInt(VariableDie, dwarf::DW_AT_alignment, dwarf::DW_FORM_udata,\n              AlignInBytes);\n\n  addSourceLine(VariableDie, DIVar);\n  addType(VariableDie, Var.getType());\n  if (Var.isArtificial())\n    addFlag(VariableDie, dwarf::DW_AT_artificial);\n}\n\nvoid DwarfCompileUnit::applyLabelAttributes(const DbgLabel &Label,\n                                            DIE &LabelDie) {\n  StringRef Name = Label.getName();\n  if (!Name.empty())\n    addString(LabelDie, dwarf::DW_AT_name, Name);\n  const auto *DILabel = Label.getLabel();\n  addSourceLine(LabelDie, DILabel);\n}\n\n/// Add a Dwarf expression attribute data and value.\nvoid DwarfCompileUnit::addExpr(DIELoc &Die, dwarf::Form Form,\n                               const MCExpr *Expr) {\n  Die.addValue(DIEValueAllocator, (dwarf::Attribute)0, Form, DIEExpr(Expr));\n}\n\nvoid DwarfCompileUnit::applySubprogramAttributesToDefinition(\n    const DISubprogram *SP, DIE &SPDie) {\n  auto *SPDecl = SP->getDeclaration();\n  auto *Context = SPDecl ? SPDecl->getScope() : SP->getScope();\n  applySubprogramAttributes(SP, SPDie, includeMinimalInlineScopes());\n  addGlobalName(SP->getName(), SPDie, Context);\n}\n\nbool DwarfCompileUnit::isDwoUnit() const {\n  return DD->useSplitDwarf() && Skeleton;\n}\n\nvoid DwarfCompileUnit::finishNonUnitTypeDIE(DIE& D, const DICompositeType *CTy) {\n  constructTypeDIE(D, CTy);\n}\n\nbool DwarfCompileUnit::includeMinimalInlineScopes() const {\n  return getCUNode()->getEmissionKind() == DICompileUnit::LineTablesOnly ||\n         (DD->useSplitDwarf() && !Skeleton);\n}\n\nvoid DwarfCompileUnit::addAddrTableBase() {\n  const TargetLoweringObjectFile &TLOF = Asm->getObjFileLowering();\n  MCSymbol *Label = DD->getAddressPool().getLabel();\n  addSectionLabel(getUnitDie(),\n                  DD->getDwarfVersion() >= 5 ? dwarf::DW_AT_addr_base\n                                             : dwarf::DW_AT_GNU_addr_base,\n                  Label, TLOF.getDwarfAddrSection()->getBeginSymbol());\n}\n\nvoid DwarfCompileUnit::addBaseTypeRef(DIEValueList &Die, int64_t Idx) {\n  Die.addValue(DIEValueAllocator, (dwarf::Attribute)0, dwarf::DW_FORM_udata,\n               new (DIEValueAllocator) DIEBaseTypeRef(this, Idx));\n}\n\nvoid DwarfCompileUnit::createBaseTypeDIEs() {\n  // Insert the base_type DIEs directly after the CU so that their offsets will\n  // fit in the fixed size ULEB128 used inside the location expressions.\n  // Maintain order by iterating backwards and inserting to the front of CU\n  // child list.\n  for (auto &Btr : reverse(ExprRefedBaseTypes)) {\n    DIE &Die = getUnitDie().addChildFront(\n      DIE::get(DIEValueAllocator, dwarf::DW_TAG_base_type));\n    SmallString<32> Str;\n    addString(Die, dwarf::DW_AT_name,\n              Twine(dwarf::AttributeEncodingString(Btr.Encoding) +\n                    \"_\" + Twine(Btr.BitSize)).toStringRef(Str));\n    addUInt(Die, dwarf::DW_AT_encoding, dwarf::DW_FORM_data1, Btr.Encoding);\n    addUInt(Die, dwarf::DW_AT_byte_size, None, Btr.BitSize / 8);\n\n    Btr.Die = &Die;\n  }\n}\n"}, "84": {"id": 84, "path": "/home/vsts/work/1/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfCompileUnit.h", "content": "//===- llvm/CodeGen/DwarfCompileUnit.h - Dwarf Compile Unit -----*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// This file contains support for writing dwarf compile unit.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_LIB_CODEGEN_ASMPRINTER_DWARFCOMPILEUNIT_H\n#define LLVM_LIB_CODEGEN_ASMPRINTER_DWARFCOMPILEUNIT_H\n\n#include \"DwarfDebug.h\"\n#include \"DwarfUnit.h\"\n#include \"llvm/ADT/ArrayRef.h\"\n#include \"llvm/ADT/DenseMap.h\"\n#include \"llvm/ADT/SmallVector.h\"\n#include \"llvm/ADT/StringMap.h\"\n#include \"llvm/ADT/StringRef.h\"\n#include \"llvm/BinaryFormat/Dwarf.h\"\n#include \"llvm/CodeGen/DbgEntityHistoryCalculator.h\"\n#include \"llvm/CodeGen/LexicalScopes.h\"\n#include \"llvm/IR/DebugInfoMetadata.h\"\n#include \"llvm/Support/Casting.h\"\n#include <algorithm>\n#include <cassert>\n#include <cstdint>\n#include <memory>\n\nnamespace llvm {\n\nclass AsmPrinter;\nclass DIE;\nclass DIELoc;\nclass DIEValueList;\nclass DwarfFile;\nclass GlobalVariable;\nclass MCExpr;\nclass MCSymbol;\nclass MDNode;\n\nenum class UnitKind { Skeleton, Full };\n\nclass DwarfCompileUnit final : public DwarfUnit {\n  /// A numeric ID unique among all CUs in the module\n  unsigned UniqueID;\n  bool HasRangeLists = false;\n\n  /// The start of the unit line section, this is also\n  /// reused in appyStmtList.\n  MCSymbol *LineTableStartSym;\n\n  /// Skeleton unit associated with this unit.\n  DwarfCompileUnit *Skeleton = nullptr;\n\n  /// The start of the unit within its section.\n  MCSymbol *LabelBegin = nullptr;\n\n  /// The start of the unit macro info within macro section.\n  MCSymbol *MacroLabelBegin;\n\n  using ImportedEntityList = SmallVector<const MDNode *, 8>;\n  using ImportedEntityMap = DenseMap<const MDNode *, ImportedEntityList>;\n\n  ImportedEntityMap ImportedEntities;\n\n  /// GlobalNames - A map of globally visible named entities for this unit.\n  StringMap<const DIE *> GlobalNames;\n\n  /// GlobalTypes - A map of globally visible types for this unit.\n  StringMap<const DIE *> GlobalTypes;\n\n  // List of ranges for a given compile unit.\n  SmallVector<RangeSpan, 2> CURanges;\n\n  // The base address of this unit, if any. Used for relative references in\n  // ranges/locs.\n  const MCSymbol *BaseAddress = nullptr;\n\n  DenseMap<const MDNode *, DIE *> AbstractSPDies;\n  DenseMap<const DINode *, std::unique_ptr<DbgEntity>> AbstractEntities;\n\n  /// DWO ID for correlating skeleton and split units.\n  uint64_t DWOId = 0;\n\n  /// Construct a DIE for the given DbgVariable without initializing the\n  /// DbgVariable's DIE reference.\n  DIE *constructVariableDIEImpl(const DbgVariable &DV, bool Abstract);\n\n  bool isDwoUnit() const override;\n\n  DenseMap<const MDNode *, DIE *> &getAbstractSPDies() {\n    if (isDwoUnit() && !DD->shareAcrossDWOCUs())\n      return AbstractSPDies;\n    return DU->getAbstractSPDies();\n  }\n\n  DenseMap<const DINode *, std::unique_ptr<DbgEntity>> &getAbstractEntities() {\n    if (isDwoUnit() && !DD->shareAcrossDWOCUs())\n      return AbstractEntities;\n    return DU->getAbstractEntities();\n  }\n\n  void finishNonUnitTypeDIE(DIE& D, const DICompositeType *CTy) override;\n\npublic:\n  DwarfCompileUnit(unsigned UID, const DICompileUnit *Node, AsmPrinter *A,\n                   DwarfDebug *DW, DwarfFile *DWU,\n                   UnitKind Kind = UnitKind::Full);\n\n  bool hasRangeLists() const { return HasRangeLists; }\n  unsigned getUniqueID() const { return UniqueID; }\n\n  DwarfCompileUnit *getSkeleton() const {\n    return Skeleton;\n  }\n\n  bool includeMinimalInlineScopes() const;\n\n  void initStmtList();\n\n  /// Apply the DW_AT_stmt_list from this compile unit to the specified DIE.\n  void applyStmtList(DIE &D);\n\n  /// Get line table start symbol for this unit.\n  MCSymbol *getLineTableStartSym() const { return LineTableStartSym; }\n\n  /// A pair of GlobalVariable and DIExpression.\n  struct GlobalExpr {\n    const GlobalVariable *Var;\n    const DIExpression *Expr;\n  };\n\n  struct BaseTypeRef {\n    BaseTypeRef(unsigned BitSize, dwarf::TypeKind Encoding) :\n      BitSize(BitSize), Encoding(Encoding) {}\n    unsigned BitSize;\n    dwarf::TypeKind Encoding;\n    DIE *Die = nullptr;\n  };\n\n  std::vector<BaseTypeRef> ExprRefedBaseTypes;\n\n  /// Get or create global variable DIE.\n  DIE *\n  getOrCreateGlobalVariableDIE(const DIGlobalVariable *GV,\n                               ArrayRef<GlobalExpr> GlobalExprs);\n\n  DIE *getOrCreateCommonBlock(const DICommonBlock *CB,\n                              ArrayRef<GlobalExpr> GlobalExprs);\n\n  void addLocationAttribute(DIE *ToDIE, const DIGlobalVariable *GV,\n                            ArrayRef<GlobalExpr> GlobalExprs);\n\n  /// addLabelAddress - Add a dwarf label attribute data and value using\n  /// either DW_FORM_addr or DW_FORM_GNU_addr_index.\n  void addLabelAddress(DIE &Die, dwarf::Attribute Attribute,\n                       const MCSymbol *Label);\n\n  /// addLocalLabelAddress - Add a dwarf label attribute data and value using\n  /// DW_FORM_addr only.\n  void addLocalLabelAddress(DIE &Die, dwarf::Attribute Attribute,\n                            const MCSymbol *Label);\n\n  DwarfCompileUnit &getCU() override { return *this; }\n\n  unsigned getOrCreateSourceID(const DIFile *File) override;\n\n  void addImportedEntity(const DIImportedEntity* IE) {\n    DIScope *Scope = IE->getScope();\n    assert(Scope && \"Invalid Scope encoding!\");\n    if (!isa<DILocalScope>(Scope))\n      // No need to add imported enities that are not local declaration.\n      return;\n\n    auto *LocalScope = cast<DILocalScope>(Scope)->getNonLexicalBlockFileScope();\n    ImportedEntities[LocalScope].push_back(IE);\n  }\n\n  /// addRange - Add an address range to the list of ranges for this unit.\n  void addRange(RangeSpan Range);\n\n  void attachLowHighPC(DIE &D, const MCSymbol *Begin, const MCSymbol *End);\n\n  /// Find DIE for the given subprogram and attach appropriate\n  /// DW_AT_low_pc and DW_AT_high_pc attributes. If there are global\n  /// variables in this scope then create and insert DIEs for these\n  /// variables.\n  DIE &updateSubprogramScopeDIE(const DISubprogram *SP);\n\n  void constructScopeDIE(LexicalScope *Scope,\n                         SmallVectorImpl<DIE *> &FinalChildren);\n\n  /// A helper function to construct a RangeSpanList for a given\n  /// lexical scope.\n  void addScopeRangeList(DIE &ScopeDIE, SmallVector<RangeSpan, 2> Range);\n\n  void attachRangesOrLowHighPC(DIE &D, SmallVector<RangeSpan, 2> Ranges);\n\n  void attachRangesOrLowHighPC(DIE &D,\n                               const SmallVectorImpl<InsnRange> &Ranges);\n\n  /// This scope represents inlined body of a function. Construct\n  /// DIE to represent this concrete inlined copy of the function.\n  DIE *constructInlinedScopeDIE(LexicalScope *Scope);\n\n  /// Construct new DW_TAG_lexical_block for this scope and\n  /// attach DW_AT_low_pc/DW_AT_high_pc labels.\n  DIE *constructLexicalScopeDIE(LexicalScope *Scope);\n\n  /// constructVariableDIE - Construct a DIE for the given DbgVariable.\n  DIE *constructVariableDIE(DbgVariable &DV, bool Abstract = false);\n\n  DIE *constructVariableDIE(DbgVariable &DV, const LexicalScope &Scope,\n                            DIE *&ObjectPointer);\n\n  /// Construct a DIE for the given DbgLabel.\n  DIE *constructLabelDIE(DbgLabel &DL, const LexicalScope &Scope);\n\n  /// A helper function to create children of a Scope DIE.\n  DIE *createScopeChildrenDIE(LexicalScope *Scope,\n                              SmallVectorImpl<DIE *> &Children,\n                              bool *HasNonScopeChildren = nullptr);\n\n  void createBaseTypeDIEs();\n\n  /// Construct a DIE for this subprogram scope.\n  DIE &constructSubprogramScopeDIE(const DISubprogram *Sub,\n                                   LexicalScope *Scope);\n\n  DIE *createAndAddScopeChildren(LexicalScope *Scope, DIE &ScopeDIE);\n\n  void constructAbstractSubprogramScopeDIE(LexicalScope *Scope);\n\n  /// Whether to use the GNU analog for a DWARF5 tag, attribute, or location\n  /// atom. Only applicable when emitting otherwise DWARF4-compliant debug info.\n  bool useGNUAnalogForDwarf5Feature() const;\n\n  /// This takes a DWARF 5 tag and returns it or a GNU analog.\n  dwarf::Tag getDwarf5OrGNUTag(dwarf::Tag Tag) const;\n\n  /// This takes a DWARF 5 attribute and returns it or a GNU analog.\n  dwarf::Attribute getDwarf5OrGNUAttr(dwarf::Attribute Attr) const;\n\n  /// This takes a DWARF 5 location atom and either returns it or a GNU analog.\n  dwarf::LocationAtom getDwarf5OrGNULocationAtom(dwarf::LocationAtom Loc) const;\n\n  /// Construct a call site entry DIE describing a call within \\p Scope to a\n  /// callee described by \\p CalleeDIE.\n  /// \\p CalleeDIE is a declaration or definition subprogram DIE for the callee.\n  /// For indirect calls \\p CalleeDIE is set to nullptr.\n  /// \\p IsTail specifies whether the call is a tail call.\n  /// \\p PCAddr points to the PC value after the call instruction.\n  /// \\p CallAddr points to the PC value at the call instruction (or is null).\n  /// \\p CallReg is a register location for an indirect call. For direct calls\n  /// the \\p CallReg is set to 0.\n  DIE &constructCallSiteEntryDIE(DIE &ScopeDIE, DIE *CalleeDIE, bool IsTail,\n                                 const MCSymbol *PCAddr,\n                                 const MCSymbol *CallAddr, unsigned CallReg);\n  /// Construct call site parameter DIEs for the \\p CallSiteDIE. The \\p Params\n  /// were collected by the \\ref collectCallSiteParameters.\n  /// Note: The order of parameters does not matter, since debuggers recognize\n  ///       call site parameters by the DW_AT_location attribute.\n  void constructCallSiteParmEntryDIEs(DIE &CallSiteDIE,\n                                      SmallVector<DbgCallSiteParam, 4> &Params);\n\n  /// Construct import_module DIE.\n  DIE *constructImportedEntityDIE(const DIImportedEntity *Module);\n\n  void finishSubprogramDefinition(const DISubprogram *SP);\n  void finishEntityDefinition(const DbgEntity *Entity);\n\n  /// Find abstract variable associated with Var.\n  using InlinedEntity = DbgValueHistoryMap::InlinedEntity;\n  DbgEntity *getExistingAbstractEntity(const DINode *Node);\n  void createAbstractEntity(const DINode *Node, LexicalScope *Scope);\n\n  /// Set the skeleton unit associated with this unit.\n  void setSkeleton(DwarfCompileUnit &Skel) { Skeleton = &Skel; }\n\n  unsigned getHeaderSize() const override {\n    // DWARF v5 added the DWO ID to the header for split/skeleton units.\n    unsigned DWOIdSize =\n        DD->getDwarfVersion() >= 5 && DD->useSplitDwarf() ? sizeof(uint64_t)\n                                                          : 0;\n    return DwarfUnit::getHeaderSize() + DWOIdSize;\n  }\n  unsigned getLength() {\n    return Asm->getUnitLengthFieldByteSize() + // Length field\n           getHeaderSize() + getUnitDie().getSize();\n  }\n\n  void emitHeader(bool UseOffsets) override;\n\n  /// Add the DW_AT_addr_base attribute to the unit DIE.\n  void addAddrTableBase();\n\n  MCSymbol *getLabelBegin() const {\n    assert(LabelBegin && \"LabelBegin is not initialized\");\n    return LabelBegin;\n  }\n\n  MCSymbol *getMacroLabelBegin() const {\n    return MacroLabelBegin;\n  }\n\n  /// Add a new global name to the compile unit.\n  void addGlobalName(StringRef Name, const DIE &Die,\n                     const DIScope *Context) override;\n\n  /// Add a new global name present in a type unit to this compile unit.\n  void addGlobalNameForTypeUnit(StringRef Name, const DIScope *Context);\n\n  /// Add a new global type to the compile unit.\n  void addGlobalType(const DIType *Ty, const DIE &Die,\n                     const DIScope *Context) override;\n\n  /// Add a new global type present in a type unit to this compile unit.\n  void addGlobalTypeUnitType(const DIType *Ty, const DIScope *Context);\n\n  const StringMap<const DIE *> &getGlobalNames() const { return GlobalNames; }\n  const StringMap<const DIE *> &getGlobalTypes() const { return GlobalTypes; }\n\n  /// Add DW_AT_location attribute for a DbgVariable based on provided\n  /// MachineLocation.\n  void addVariableAddress(const DbgVariable &DV, DIE &Die,\n                          MachineLocation Location);\n  /// Add an address attribute to a die based on the location provided.\n  void addAddress(DIE &Die, dwarf::Attribute Attribute,\n                  const MachineLocation &Location);\n\n  /// Start with the address based on the location provided, and generate the\n  /// DWARF information necessary to find the actual variable (navigating the\n  /// extra location information encoded in the type) based on the starting\n  /// location.  Add the DWARF information to the die.\n  void addComplexAddress(const DbgVariable &DV, DIE &Die,\n                         dwarf::Attribute Attribute,\n                         const MachineLocation &Location);\n\n  /// Add a Dwarf loclistptr attribute data and value.\n  void addLocationList(DIE &Die, dwarf::Attribute Attribute, unsigned Index);\n  void applyVariableAttributes(const DbgVariable &Var, DIE &VariableDie);\n\n  /// Add a Dwarf expression attribute data and value.\n  void addExpr(DIELoc &Die, dwarf::Form Form, const MCExpr *Expr);\n\n  void applySubprogramAttributesToDefinition(const DISubprogram *SP,\n                                             DIE &SPDie);\n\n  void applyLabelAttributes(const DbgLabel &Label, DIE &LabelDie);\n\n  /// getRanges - Get the list of ranges for this unit.\n  const SmallVectorImpl<RangeSpan> &getRanges() const { return CURanges; }\n  SmallVector<RangeSpan, 2> takeRanges() { return std::move(CURanges); }\n\n  void setBaseAddress(const MCSymbol *Base) { BaseAddress = Base; }\n  const MCSymbol *getBaseAddress() const { return BaseAddress; }\n\n  uint64_t getDWOId() const { return DWOId; }\n  void setDWOId(uint64_t DwoId) { DWOId = DwoId; }\n\n  bool hasDwarfPubSections() const;\n\n  void addBaseTypeRef(DIEValueList &Die, int64_t Idx);\n};\n\n} // end namespace llvm\n\n#endif // LLVM_LIB_CODEGEN_ASMPRINTER_DWARFCOMPILEUNIT_H\n"}, "85": {"id": 85, "path": "/home/vsts/work/1/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.h", "content": "//===- llvm/CodeGen/DwarfDebug.h - Dwarf Debug Framework --------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// This file contains support for writing dwarf debug info into asm files.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_LIB_CODEGEN_ASMPRINTER_DWARFDEBUG_H\n#define LLVM_LIB_CODEGEN_ASMPRINTER_DWARFDEBUG_H\n\n#include \"AddressPool.h\"\n#include \"DebugLocStream.h\"\n#include \"DebugLocEntry.h\"\n#include \"DwarfFile.h\"\n#include \"llvm/ADT/ArrayRef.h\"\n#include \"llvm/ADT/DenseMap.h\"\n#include \"llvm/ADT/DenseSet.h\"\n#include \"llvm/ADT/MapVector.h\"\n#include \"llvm/ADT/STLExtras.h\"\n#include \"llvm/ADT/SetVector.h\"\n#include \"llvm/ADT/SmallPtrSet.h\"\n#include \"llvm/ADT/SmallVector.h\"\n#include \"llvm/ADT/StringMap.h\"\n#include \"llvm/ADT/StringRef.h\"\n#include \"llvm/BinaryFormat/Dwarf.h\"\n#include \"llvm/CodeGen/AccelTable.h\"\n#include \"llvm/CodeGen/DbgEntityHistoryCalculator.h\"\n#include \"llvm/CodeGen/DebugHandlerBase.h\"\n#include \"llvm/CodeGen/MachineInstr.h\"\n#include \"llvm/IR/DebugInfoMetadata.h\"\n#include \"llvm/IR/DebugLoc.h\"\n#include \"llvm/IR/Metadata.h\"\n#include \"llvm/MC/MCDwarf.h\"\n#include \"llvm/Support/Allocator.h\"\n#include \"llvm/Target/TargetOptions.h\"\n#include <cassert>\n#include <cstdint>\n#include <limits>\n#include <memory>\n#include <utility>\n#include <vector>\n\nnamespace llvm {\n\nclass AsmPrinter;\nclass ByteStreamer;\nclass DIE;\nclass DwarfCompileUnit;\nclass DwarfExpression;\nclass DwarfTypeUnit;\nclass DwarfUnit;\nclass LexicalScope;\nclass MachineFunction;\nclass MCSection;\nclass MCSymbol;\nclass Module;\n\n//===----------------------------------------------------------------------===//\n/// This class is defined as the common parent of DbgVariable and DbgLabel\n/// such that it could levarage polymorphism to extract common code for\n/// DbgVariable and DbgLabel.\nclass DbgEntity {\n  const DINode *Entity;\n  const DILocation *InlinedAt;\n  DIE *TheDIE = nullptr;\n  unsigned SubclassID;\n\npublic:\n  enum DbgEntityKind {\n    DbgVariableKind,\n    DbgLabelKind\n  };\n\n  DbgEntity(const DINode *N, const DILocation *IA, unsigned ID)\n    : Entity(N), InlinedAt(IA), SubclassID(ID) {}\n  virtual ~DbgEntity() {}\n\n  /// Accessors.\n  /// @{\n  const DINode *getEntity() const { return Entity; }\n  const DILocation *getInlinedAt() const { return InlinedAt; }\n  DIE *getDIE() const { return TheDIE; }\n  unsigned getDbgEntityID() const { return SubclassID; }\n  /// @}\n\n  void setDIE(DIE &D) { TheDIE = &D; }\n\n  static bool classof(const DbgEntity *N) {\n    switch (N->getDbgEntityID()) {\n    default:\n      return false;\n    case DbgVariableKind:\n    case DbgLabelKind:\n      return true;\n    }\n  }\n};\n\n//===----------------------------------------------------------------------===//\n/// This class is used to track local variable information.\n///\n/// Variables can be created from allocas, in which case they're generated from\n/// the MMI table.  Such variables can have multiple expressions and frame\n/// indices.\n///\n/// Variables can be created from \\c DBG_VALUE instructions.  Those whose\n/// location changes over time use \\a DebugLocListIndex, while those with a\n/// single location use \\a ValueLoc and (optionally) a single entry of \\a Expr.\n///\n/// Variables that have been optimized out use none of these fields.\nclass DbgVariable : public DbgEntity {\n  /// Index of the entry list in DebugLocs.\n  unsigned DebugLocListIndex = ~0u;\n  /// DW_OP_LLVM_tag_offset value from DebugLocs.\n  Optional<uint8_t> DebugLocListTagOffset;\n\n  /// Single value location description.\n  std::unique_ptr<DbgValueLoc> ValueLoc = nullptr;\n\n  struct FrameIndexExpr {\n    int FI;\n    const DIExpression *Expr;\n  };\n  mutable SmallVector<FrameIndexExpr, 1>\n      FrameIndexExprs; /// Frame index + expression.\n\npublic:\n  /// Construct a DbgVariable.\n  ///\n  /// Creates a variable without any DW_AT_location.  Call \\a initializeMMI()\n  /// for MMI entries, or \\a initializeDbgValue() for DBG_VALUE instructions.\n  DbgVariable(const DILocalVariable *V, const DILocation *IA)\n      : DbgEntity(V, IA, DbgVariableKind) {}\n\n  /// Initialize from the MMI table.\n  void initializeMMI(const DIExpression *E, int FI) {\n    assert(FrameIndexExprs.empty() && \"Already initialized?\");\n    assert(!ValueLoc.get() && \"Already initialized?\");\n\n    assert((!E || E->isValid()) && \"Expected valid expression\");\n    assert(FI != std::numeric_limits<int>::max() && \"Expected valid index\");\n\n    FrameIndexExprs.push_back({FI, E});\n  }\n\n  // Initialize variable's location.\n  void initializeDbgValue(DbgValueLoc Value) {\n    assert(FrameIndexExprs.empty() && \"Already initialized?\");\n    assert(!ValueLoc && \"Already initialized?\");\n    assert(!Value.getExpression()->isFragment() && \"Fragments not supported.\");\n\n    ValueLoc = std::make_unique<DbgValueLoc>(Value);\n    if (auto *E = ValueLoc->getExpression())\n      if (E->getNumElements())\n        FrameIndexExprs.push_back({0, E});\n  }\n\n  /// Initialize from a DBG_VALUE instruction.\n  void initializeDbgValue(const MachineInstr *DbgValue);\n\n  // Accessors.\n  const DILocalVariable *getVariable() const {\n    return cast<DILocalVariable>(getEntity());\n  }\n\n  const DIExpression *getSingleExpression() const {\n    assert(ValueLoc.get() && FrameIndexExprs.size() <= 1);\n    return FrameIndexExprs.size() ? FrameIndexExprs[0].Expr : nullptr;\n  }\n\n  void setDebugLocListIndex(unsigned O) { DebugLocListIndex = O; }\n  unsigned getDebugLocListIndex() const { return DebugLocListIndex; }\n  void setDebugLocListTagOffset(uint8_t O) { DebugLocListTagOffset = O; }\n  Optional<uint8_t> getDebugLocListTagOffset() const { return DebugLocListTagOffset; }\n  StringRef getName() const { return getVariable()->getName(); }\n  const DbgValueLoc *getValueLoc() const { return ValueLoc.get(); }\n  /// Get the FI entries, sorted by fragment offset.\n  ArrayRef<FrameIndexExpr> getFrameIndexExprs() const;\n  bool hasFrameIndexExprs() const { return !FrameIndexExprs.empty(); }\n  void addMMIEntry(const DbgVariable &V);\n\n  // Translate tag to proper Dwarf tag.\n  dwarf::Tag getTag() const {\n    // FIXME: Why don't we just infer this tag and store it all along?\n    if (getVariable()->isParameter())\n      return dwarf::DW_TAG_formal_parameter;\n\n    return dwarf::DW_TAG_variable;\n  }\n\n  /// Return true if DbgVariable is artificial.\n  bool isArtificial() const {\n    if (getVariable()->isArtificial())\n      return true;\n    if (getType()->isArtificial())\n      return true;\n    return false;\n  }\n\n  bool isObjectPointer() const {\n    if (getVariable()->isObjectPointer())\n      return true;\n    if (getType()->isObjectPointer())\n      return true;\n    return false;\n  }\n\n  bool hasComplexAddress() const {\n    assert(ValueLoc.get() && \"Expected DBG_VALUE, not MMI variable\");\n    assert((FrameIndexExprs.empty() ||\n            (FrameIndexExprs.size() == 1 &&\n             FrameIndexExprs[0].Expr->getNumElements())) &&\n           \"Invalid Expr for DBG_VALUE\");\n    return !FrameIndexExprs.empty();\n  }\n\n  const DIType *getType() const;\n\n  static bool classof(const DbgEntity *N) {\n    return N->getDbgEntityID() == DbgVariableKind;\n  }\n};\n\n//===----------------------------------------------------------------------===//\n/// This class is used to track label information.\n///\n/// Labels are collected from \\c DBG_LABEL instructions.\nclass DbgLabel : public DbgEntity {\n  const MCSymbol *Sym;                  /// Symbol before DBG_LABEL instruction.\n\npublic:\n  /// We need MCSymbol information to generate DW_AT_low_pc.\n  DbgLabel(const DILabel *L, const DILocation *IA, const MCSymbol *Sym = nullptr)\n      : DbgEntity(L, IA, DbgLabelKind), Sym(Sym) {}\n\n  /// Accessors.\n  /// @{\n  const DILabel *getLabel() const { return cast<DILabel>(getEntity()); }\n  const MCSymbol *getSymbol() const { return Sym; }\n\n  StringRef getName() const { return getLabel()->getName(); }\n  /// @}\n\n  /// Translate tag to proper Dwarf tag.\n  dwarf::Tag getTag() const {\n    return dwarf::DW_TAG_label;\n  }\n\n  static bool classof(const DbgEntity *N) {\n    return N->getDbgEntityID() == DbgLabelKind;\n  }\n};\n\n/// Used for tracking debug info about call site parameters.\nclass DbgCallSiteParam {\nprivate:\n  unsigned Register; ///< Parameter register at the callee entry point.\n  DbgValueLoc Value; ///< Corresponding location for the parameter value at\n                     ///< the call site.\npublic:\n  DbgCallSiteParam(unsigned Reg, DbgValueLoc Val)\n      : Register(Reg), Value(Val) {\n    assert(Reg && \"Parameter register cannot be undef\");\n  }\n\n  unsigned getRegister() const { return Register; }\n  DbgValueLoc getValue() const { return Value; }\n};\n\n/// Collection used for storing debug call site parameters.\nusing ParamSet = SmallVector<DbgCallSiteParam, 4>;\n\n/// Helper used to pair up a symbol and its DWARF compile unit.\nstruct SymbolCU {\n  SymbolCU(DwarfCompileUnit *CU, const MCSymbol *Sym) : Sym(Sym), CU(CU) {}\n\n  const MCSymbol *Sym;\n  DwarfCompileUnit *CU;\n};\n\n/// The kind of accelerator tables we should emit.\nenum class AccelTableKind {\n  Default, ///< Platform default.\n  None,    ///< None.\n  Apple,   ///< .apple_names, .apple_namespaces, .apple_types, .apple_objc.\n  Dwarf,   ///< DWARF v5 .debug_names.\n};\n\n/// Collects and handles dwarf debug information.\nclass DwarfDebug : public DebugHandlerBase {\n  /// All DIEValues are allocated through this allocator.\n  BumpPtrAllocator DIEValueAllocator;\n\n  /// Maps MDNode with its corresponding DwarfCompileUnit.\n  MapVector<const MDNode *, DwarfCompileUnit *> CUMap;\n\n  /// Maps a CU DIE with its corresponding DwarfCompileUnit.\n  DenseMap<const DIE *, DwarfCompileUnit *> CUDieMap;\n\n  /// List of all labels used in aranges generation.\n  std::vector<SymbolCU> ArangeLabels;\n\n  /// Size of each symbol emitted (for those symbols that have a specific size).\n  DenseMap<const MCSymbol *, uint64_t> SymSize;\n\n  /// Collection of abstract variables/labels.\n  SmallVector<std::unique_ptr<DbgEntity>, 64> ConcreteEntities;\n\n  /// Collection of DebugLocEntry. Stored in a linked list so that DIELocLists\n  /// can refer to them in spite of insertions into this list.\n  DebugLocStream DebugLocs;\n\n  /// This is a collection of subprogram MDNodes that are processed to\n  /// create DIEs.\n  SetVector<const DISubprogram *, SmallVector<const DISubprogram *, 16>,\n            SmallPtrSet<const DISubprogram *, 16>>\n      ProcessedSPNodes;\n\n  /// If nonnull, stores the current machine function we're processing.\n  const MachineFunction *CurFn = nullptr;\n\n  /// If nonnull, stores the CU in which the previous subprogram was contained.\n  const DwarfCompileUnit *PrevCU = nullptr;\n\n  /// As an optimization, there is no need to emit an entry in the directory\n  /// table for the same directory as DW_AT_comp_dir.\n  StringRef CompilationDir;\n\n  /// Holder for the file specific debug information.\n  DwarfFile InfoHolder;\n\n  /// Holders for the various debug information flags that we might need to\n  /// have exposed. See accessor functions below for description.\n\n  /// Map from MDNodes for user-defined types to their type signatures. Also\n  /// used to keep track of which types we have emitted type units for.\n  DenseMap<const MDNode *, uint64_t> TypeSignatures;\n\n  DenseMap<const MCSection *, const MCSymbol *> SectionLabels;\n\n  SmallVector<\n      std::pair<std::unique_ptr<DwarfTypeUnit>, const DICompositeType *>, 1>\n      TypeUnitsUnderConstruction;\n\n  /// Whether to use the GNU TLS opcode (instead of the standard opcode).\n  bool UseGNUTLSOpcode;\n\n  /// Whether to use DWARF 2 bitfields (instead of the DWARF 4 format).\n  bool UseDWARF2Bitfields;\n\n  /// Whether to emit all linkage names, or just abstract subprograms.\n  bool UseAllLinkageNames;\n\n  /// Use inlined strings.\n  bool UseInlineStrings = false;\n\n  /// Allow emission of .debug_ranges section.\n  bool UseRangesSection = true;\n\n  /// True if the sections itself must be used as references and don't create\n  /// temp symbols inside DWARF sections.\n  bool UseSectionsAsReferences = false;\n\n  ///Allow emission of the .debug_loc section.\n  bool UseLocSection = true;\n\n  /// Generate DWARF v4 type units.\n  bool GenerateTypeUnits;\n\n  /// Emit a .debug_macro section instead of .debug_macinfo.\n  bool UseDebugMacroSection;\n\n  /// Avoid using DW_OP_convert due to consumer incompatibilities.\n  bool EnableOpConvert;\n\npublic:\n  enum class MinimizeAddrInV5 {\n    Default,\n    Disabled,\n    Ranges,\n    Expressions,\n    Form,\n  };\n\nprivate:\n  /// Force the use of DW_AT_ranges even for single-entry range lists.\n  MinimizeAddrInV5 MinimizeAddr = MinimizeAddrInV5::Disabled;\n\n  /// DWARF5 Experimental Options\n  /// @{\n  AccelTableKind TheAccelTableKind;\n  bool HasAppleExtensionAttributes;\n  bool HasSplitDwarf;\n\n  /// Whether to generate the DWARF v5 string offsets table.\n  /// It consists of a series of contributions, each preceded by a header.\n  /// The pre-DWARF v5 string offsets table for split dwarf is, in contrast,\n  /// a monolithic sequence of string offsets.\n  bool UseSegmentedStringOffsetsTable;\n\n  /// Enable production of call site parameters needed to print the debug entry\n  /// values. Useful for testing purposes when a debugger does not support the\n  /// feature yet.\n  bool EmitDebugEntryValues;\n\n  /// Separated Dwarf Variables\n  /// In general these will all be for bits that are left in the\n  /// original object file, rather than things that are meant\n  /// to be in the .dwo sections.\n\n  /// Holder for the skeleton information.\n  DwarfFile SkeletonHolder;\n\n  /// Store file names for type units under fission in a line table\n  /// header that will be emitted into debug_line.dwo.\n  // FIXME: replace this with a map from comp_dir to table so that we\n  // can emit multiple tables during LTO each of which uses directory\n  // 0, referencing the comp_dir of all the type units that use it.\n  MCDwarfDwoLineTable SplitTypeUnitFileTable;\n  /// @}\n\n  /// True iff there are multiple CUs in this module.\n  bool SingleCU;\n  bool IsDarwin;\n\n  /// Map for tracking Fortran deferred CHARACTER lengths.\n  DenseMap<const DIStringType *, unsigned> StringTypeLocMap;\n\n  AddressPool AddrPool;\n\n  /// Accelerator tables.\n  AccelTable<DWARF5AccelTableData> AccelDebugNames;\n  AccelTable<AppleAccelTableOffsetData> AccelNames;\n  AccelTable<AppleAccelTableOffsetData> AccelObjC;\n  AccelTable<AppleAccelTableOffsetData> AccelNamespace;\n  AccelTable<AppleAccelTableTypeData> AccelTypes;\n\n  // Identify a debugger for \"tuning\" the debug info.\n  DebuggerKind DebuggerTuning = DebuggerKind::Default;\n\n  MCDwarfDwoLineTable *getDwoLineTable(const DwarfCompileUnit &);\n\n  const SmallVectorImpl<std::unique_ptr<DwarfCompileUnit>> &getUnits() {\n    return InfoHolder.getUnits();\n  }\n\n  using InlinedEntity = DbgValueHistoryMap::InlinedEntity;\n\n  void ensureAbstractEntityIsCreated(DwarfCompileUnit &CU,\n                                     const DINode *Node,\n                                     const MDNode *Scope);\n  void ensureAbstractEntityIsCreatedIfScoped(DwarfCompileUnit &CU,\n                                             const DINode *Node,\n                                             const MDNode *Scope);\n\n  DbgEntity *createConcreteEntity(DwarfCompileUnit &TheCU,\n                                  LexicalScope &Scope,\n                                  const DINode *Node,\n                                  const DILocation *Location,\n                                  const MCSymbol *Sym = nullptr);\n\n  /// Construct a DIE for this abstract scope.\n  void constructAbstractSubprogramScopeDIE(DwarfCompileUnit &SrcCU, LexicalScope *Scope);\n\n  /// Construct a DIE for the subprogram definition \\p SP and return it.\n  DIE &constructSubprogramDefinitionDIE(const DISubprogram *SP);\n\n  /// Construct DIEs for call site entries describing the calls in \\p MF.\n  void constructCallSiteEntryDIEs(const DISubprogram &SP, DwarfCompileUnit &CU,\n                                  DIE &ScopeDIE, const MachineFunction &MF);\n\n  template <typename DataT>\n  void addAccelNameImpl(const DICompileUnit &CU, AccelTable<DataT> &AppleAccel,\n                        StringRef Name, const DIE &Die);\n\n  void finishEntityDefinitions();\n\n  void finishSubprogramDefinitions();\n\n  /// Finish off debug information after all functions have been\n  /// processed.\n  void finalizeModuleInfo();\n\n  /// Emit the debug info section.\n  void emitDebugInfo();\n\n  /// Emit the abbreviation section.\n  void emitAbbreviations();\n\n  /// Emit the string offsets table header.\n  void emitStringOffsetsTableHeader();\n\n  /// Emit a specified accelerator table.\n  template <typename AccelTableT>\n  void emitAccel(AccelTableT &Accel, MCSection *Section, StringRef TableName);\n\n  /// Emit DWARF v5 accelerator table.\n  void emitAccelDebugNames();\n\n  /// Emit visible names into a hashed accelerator table section.\n  void emitAccelNames();\n\n  /// Emit objective C classes and categories into a hashed\n  /// accelerator table section.\n  void emitAccelObjC();\n\n  /// Emit namespace dies into a hashed accelerator table.\n  void emitAccelNamespaces();\n\n  /// Emit type dies into a hashed accelerator table.\n  void emitAccelTypes();\n\n  /// Emit visible names and types into debug pubnames and pubtypes sections.\n  void emitDebugPubSections();\n\n  void emitDebugPubSection(bool GnuStyle, StringRef Name,\n                           DwarfCompileUnit *TheU,\n                           const StringMap<const DIE *> &Globals);\n\n  /// Emit null-terminated strings into a debug str section.\n  void emitDebugStr();\n\n  /// Emit variable locations into a debug loc section.\n  void emitDebugLoc();\n\n  /// Emit variable locations into a debug loc dwo section.\n  void emitDebugLocDWO();\n\n  void emitDebugLocImpl(MCSection *Sec);\n\n  /// Emit address ranges into a debug aranges section.\n  void emitDebugARanges();\n\n  /// Emit address ranges into a debug ranges section.\n  void emitDebugRanges();\n  void emitDebugRangesDWO();\n  void emitDebugRangesImpl(const DwarfFile &Holder, MCSection *Section);\n\n  /// Emit macros into a debug macinfo section.\n  void emitDebugMacinfo();\n  /// Emit macros into a debug macinfo.dwo section.\n  void emitDebugMacinfoDWO();\n  void emitDebugMacinfoImpl(MCSection *Section);\n  void emitMacro(DIMacro &M);\n  void emitMacroFile(DIMacroFile &F, DwarfCompileUnit &U);\n  void emitMacroFileImpl(DIMacroFile &F, DwarfCompileUnit &U,\n                         unsigned StartFile, unsigned EndFile,\n                         StringRef (*MacroFormToString)(unsigned Form));\n  void handleMacroNodes(DIMacroNodeArray Nodes, DwarfCompileUnit &U);\n\n  /// DWARF 5 Experimental Split Dwarf Emitters\n\n  /// Initialize common features of skeleton units.\n  void initSkeletonUnit(const DwarfUnit &U, DIE &Die,\n                        std::unique_ptr<DwarfCompileUnit> NewU);\n\n  /// Construct the split debug info compile unit for the debug info section.\n  /// In DWARF v5, the skeleton unit DIE may have the following attributes:\n  /// DW_AT_addr_base, DW_AT_comp_dir, DW_AT_dwo_name, DW_AT_high_pc,\n  /// DW_AT_low_pc, DW_AT_ranges, DW_AT_stmt_list, and DW_AT_str_offsets_base.\n  /// Prior to DWARF v5 it may also have DW_AT_GNU_dwo_id. DW_AT_GNU_dwo_name\n  /// is used instead of DW_AT_dwo_name, Dw_AT_GNU_addr_base instead of\n  /// DW_AT_addr_base, and DW_AT_GNU_ranges_base instead of DW_AT_rnglists_base.\n  DwarfCompileUnit &constructSkeletonCU(const DwarfCompileUnit &CU);\n\n  /// Emit the debug info dwo section.\n  void emitDebugInfoDWO();\n\n  /// Emit the debug abbrev dwo section.\n  void emitDebugAbbrevDWO();\n\n  /// Emit the debug line dwo section.\n  void emitDebugLineDWO();\n\n  /// Emit the dwo stringoffsets table header.\n  void emitStringOffsetsTableHeaderDWO();\n\n  /// Emit the debug str dwo section.\n  void emitDebugStrDWO();\n\n  /// Emit DWO addresses.\n  void emitDebugAddr();\n\n  /// Flags to let the linker know we have emitted new style pubnames. Only\n  /// emit it here if we don't have a skeleton CU for split dwarf.\n  void addGnuPubAttributes(DwarfCompileUnit &U, DIE &D) const;\n\n  /// Create new DwarfCompileUnit for the given metadata node with tag\n  /// DW_TAG_compile_unit.\n  DwarfCompileUnit &getOrCreateDwarfCompileUnit(const DICompileUnit *DIUnit);\n  void finishUnitAttributes(const DICompileUnit *DIUnit,\n                            DwarfCompileUnit &NewCU);\n\n  /// Construct imported_module or imported_declaration DIE.\n  void constructAndAddImportedEntityDIE(DwarfCompileUnit &TheCU,\n                                        const DIImportedEntity *N);\n\n  /// Register a source line with debug info. Returns the unique\n  /// label that was emitted and which provides correspondence to the\n  /// source line list.\n  void recordSourceLine(unsigned Line, unsigned Col, const MDNode *Scope,\n                        unsigned Flags);\n\n  /// Populate LexicalScope entries with variables' info.\n  void collectEntityInfo(DwarfCompileUnit &TheCU, const DISubprogram *SP,\n                         DenseSet<InlinedEntity> &ProcessedVars);\n\n  /// Build the location list for all DBG_VALUEs in the\n  /// function that describe the same variable. If the resulting \n  /// list has only one entry that is valid for entire variable's\n  /// scope return true.\n  bool buildLocationList(SmallVectorImpl<DebugLocEntry> &DebugLoc,\n                         const DbgValueHistoryMap::Entries &Entries);\n\n  /// Collect variable information from the side table maintained by MF.\n  void collectVariableInfoFromMFTable(DwarfCompileUnit &TheCU,\n                                      DenseSet<InlinedEntity> &P);\n\n  /// Emit the reference to the section.\n  void emitSectionReference(const DwarfCompileUnit &CU);\n\nprotected:\n  /// Gather pre-function debug information.\n  void beginFunctionImpl(const MachineFunction *MF) override;\n\n  /// Gather and emit post-function debug information.\n  void endFunctionImpl(const MachineFunction *MF) override;\n\n  void skippedNonDebugFunction() override;\n\npublic:\n  //===--------------------------------------------------------------------===//\n  // Main entry points.\n  //\n  DwarfDebug(AsmPrinter *A);\n\n  ~DwarfDebug() override;\n\n  /// Emit all Dwarf sections that should come prior to the\n  /// content.\n  void beginModule(Module *M) override;\n\n  /// Emit all Dwarf sections that should come after the content.\n  void endModule() override;\n\n  /// Emits inital debug location directive.\n  DebugLoc emitInitialLocDirective(const MachineFunction &MF, unsigned CUID);\n\n  /// Process beginning of an instruction.\n  void beginInstruction(const MachineInstr *MI) override;\n\n  /// Perform an MD5 checksum of \\p Identifier and return the lower 64 bits.\n  static uint64_t makeTypeSignature(StringRef Identifier);\n\n  /// Add a DIE to the set of types that we're going to pull into\n  /// type units.\n  void addDwarfTypeUnitType(DwarfCompileUnit &CU, StringRef Identifier,\n                            DIE &Die, const DICompositeType *CTy);\n\n  class NonTypeUnitContext {\n    DwarfDebug *DD;\n    decltype(DwarfDebug::TypeUnitsUnderConstruction) TypeUnitsUnderConstruction;\n    bool AddrPoolUsed;\n    friend class DwarfDebug;\n    NonTypeUnitContext(DwarfDebug *DD);\n  public:\n    NonTypeUnitContext(NonTypeUnitContext&&) = default;\n    ~NonTypeUnitContext();\n  };\n\n  NonTypeUnitContext enterNonTypeUnitContext();\n\n  /// Add a label so that arange data can be generated for it.\n  void addArangeLabel(SymbolCU SCU) { ArangeLabels.push_back(SCU); }\n\n  /// For symbols that have a size designated (e.g. common symbols),\n  /// this tracks that size.\n  void setSymbolSize(const MCSymbol *Sym, uint64_t Size) override {\n    SymSize[Sym] = Size;\n  }\n\n  /// Returns whether we should emit all DW_AT_[MIPS_]linkage_name.\n  /// If not, we still might emit certain cases.\n  bool useAllLinkageNames() const { return UseAllLinkageNames; }\n\n  /// Returns whether to use DW_OP_GNU_push_tls_address, instead of the\n  /// standard DW_OP_form_tls_address opcode\n  bool useGNUTLSOpcode() const { return UseGNUTLSOpcode; }\n\n  /// Returns whether to use the DWARF2 format for bitfields instyead of the\n  /// DWARF4 format.\n  bool useDWARF2Bitfields() const { return UseDWARF2Bitfields; }\n\n  /// Returns whether to use inline strings.\n  bool useInlineStrings() const { return UseInlineStrings; }\n\n  /// Returns whether ranges section should be emitted.\n  bool useRangesSection() const { return UseRangesSection; }\n\n  /// Returns whether range encodings should be used for single entry range\n  /// lists.\n  bool alwaysUseRanges() const {\n    return MinimizeAddr == MinimizeAddrInV5::Ranges;\n  }\n\n  // Returns whether novel exprloc addrx+offset encodings should be used to\n  // reduce debug_addr size.\n  bool useAddrOffsetExpressions() const {\n    return MinimizeAddr == MinimizeAddrInV5::Expressions;\n  }\n\n  // Returns whether addrx+offset LLVM extension form should be used to reduce\n  // debug_addr size.\n  bool useAddrOffsetForm() const {\n    return MinimizeAddr == MinimizeAddrInV5::Form;\n  }\n\n  /// Returns whether to use sections as labels rather than temp symbols.\n  bool useSectionsAsReferences() const {\n    return UseSectionsAsReferences;\n  }\n\n  /// Returns whether .debug_loc section should be emitted.\n  bool useLocSection() const { return UseLocSection; }\n\n  /// Returns whether to generate DWARF v4 type units.\n  bool generateTypeUnits() const { return GenerateTypeUnits; }\n\n  // Experimental DWARF5 features.\n\n  /// Returns what kind (if any) of accelerator tables to emit.\n  AccelTableKind getAccelTableKind() const { return TheAccelTableKind; }\n\n  bool useAppleExtensionAttributes() const {\n    return HasAppleExtensionAttributes;\n  }\n\n  /// Returns whether or not to change the current debug info for the\n  /// split dwarf proposal support.\n  bool useSplitDwarf() const { return HasSplitDwarf; }\n\n  /// Returns whether to generate a string offsets table with (possibly shared)\n  /// contributions from each CU and type unit. This implies the use of\n  /// DW_FORM_strx* indirect references with DWARF v5 and beyond. Note that\n  /// DW_FORM_GNU_str_index is also an indirect reference, but it is used with\n  /// a pre-DWARF v5 implementation of split DWARF sections, which uses a\n  /// monolithic string offsets table.\n  bool useSegmentedStringOffsetsTable() const {\n    return UseSegmentedStringOffsetsTable;\n  }\n\n  bool emitDebugEntryValues() const {\n    return EmitDebugEntryValues;\n  }\n\n  bool useOpConvert() const {\n    return EnableOpConvert;\n  }\n\n  bool shareAcrossDWOCUs() const;\n\n  /// Returns the Dwarf Version.\n  uint16_t getDwarfVersion() const;\n\n  /// Returns a suitable DWARF form to represent a section offset, i.e.\n  /// * DW_FORM_sec_offset for DWARF version >= 4;\n  /// * DW_FORM_data8 for 64-bit DWARFv3;\n  /// * DW_FORM_data4 for 32-bit DWARFv3 and DWARFv2.\n  dwarf::Form getDwarfSectionOffsetForm() const;\n\n  /// Returns the previous CU that was being updated\n  const DwarfCompileUnit *getPrevCU() const { return PrevCU; }\n  void setPrevCU(const DwarfCompileUnit *PrevCU) { this->PrevCU = PrevCU; }\n\n  /// Returns the entries for the .debug_loc section.\n  const DebugLocStream &getDebugLocs() const { return DebugLocs; }\n\n  /// Emit an entry for the debug loc section. This can be used to\n  /// handle an entry that's going to be emitted into the debug loc section.\n  void emitDebugLocEntry(ByteStreamer &Streamer,\n                         const DebugLocStream::Entry &Entry,\n                         const DwarfCompileUnit *CU);\n\n  /// Emit the location for a debug loc entry, including the size header.\n  void emitDebugLocEntryLocation(const DebugLocStream::Entry &Entry,\n                                 const DwarfCompileUnit *CU);\n\n  void addSubprogramNames(const DICompileUnit &CU, const DISubprogram *SP,\n                          DIE &Die);\n\n  AddressPool &getAddressPool() { return AddrPool; }\n\n  void addAccelName(const DICompileUnit &CU, StringRef Name, const DIE &Die);\n\n  void addAccelObjC(const DICompileUnit &CU, StringRef Name, const DIE &Die);\n\n  void addAccelNamespace(const DICompileUnit &CU, StringRef Name,\n                         const DIE &Die);\n\n  void addAccelType(const DICompileUnit &CU, StringRef Name, const DIE &Die,\n                    char Flags);\n\n  const MachineFunction *getCurrentFunction() const { return CurFn; }\n\n  /// A helper function to check whether the DIE for a given Scope is\n  /// going to be null.\n  bool isLexicalScopeDIENull(LexicalScope *Scope);\n\n  /// Find the matching DwarfCompileUnit for the given CU DIE.\n  DwarfCompileUnit *lookupCU(const DIE *Die) { return CUDieMap.lookup(Die); }\n  const DwarfCompileUnit *lookupCU(const DIE *Die) const {\n    return CUDieMap.lookup(Die);\n  }\n\n  unsigned getStringTypeLoc(const DIStringType *ST) const {\n    return StringTypeLocMap.lookup(ST);\n  }\n\n  void addStringTypeLoc(const DIStringType *ST, unsigned Loc) {\n    assert(ST);\n    if (Loc)\n      StringTypeLocMap[ST] = Loc;\n  }\n\n  /// \\defgroup DebuggerTuning Predicates to tune DWARF for a given debugger.\n  ///\n  /// Returns whether we are \"tuning\" for a given debugger.\n  /// @{\n  bool tuneForGDB() const { return DebuggerTuning == DebuggerKind::GDB; }\n  bool tuneForLLDB() const { return DebuggerTuning == DebuggerKind::LLDB; }\n  bool tuneForSCE() const { return DebuggerTuning == DebuggerKind::SCE; }\n  /// @}\n\n  const MCSymbol *getSectionLabel(const MCSection *S);\n  void insertSectionLabel(const MCSymbol *S);\n\n  static void emitDebugLocValue(const AsmPrinter &AP, const DIBasicType *BT,\n                                const DbgValueLoc &Value,\n                                DwarfExpression &DwarfExpr);\n\n  /// If the \\p File has an MD5 checksum, return it as an MD5Result\n  /// allocated in the MCContext.\n  Optional<MD5::MD5Result> getMD5AsBytes(const DIFile *File) const;\n};\n\n} // end namespace llvm\n\n#endif // LLVM_LIB_CODEGEN_ASMPRINTER_DWARFDEBUG_H\n"}}, "reports": [{"events": [{"location": {"col": 7, "file": 9, "line": 313}, "message": "destructor '~FoldingSetNodeID' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/FoldingSet.h", "reportHash": "99c47edaf3585267d67496203505c691", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 9, "line": 493}, "message": "destructor '~FoldingSet' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/FoldingSet.h", "reportHash": "c4019edf3816cf59a28c07f5bf3b7286", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 13, "line": 45}, "message": "destructor '~PointerIntPair' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/PointerIntPair.h", "reportHash": "a76a57ed9e04b43e8f3d15a66799888b", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 13, "line": 45}, "message": "move assignment operator 'operator=' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/PointerIntPair.h", "reportHash": "00a6ebcd66df0f9273aaa66cc0cc7575", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 13, "line": 45}, "message": "move constructor 'PointerIntPair' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/PointerIntPair.h", "reportHash": "abd015e24af3cf91b3a0508dffc70457", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 9, "file": 14, "line": 97}, "message": "move assignment operator 'operator=' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/PointerUnion.h", "reportHash": "4669ce212b6e530155e5a01f79eed19b", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 9, "file": 14, "line": 97}, "message": "move constructor 'PointerUnionMembers' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/PointerUnion.h", "reportHash": "1e4824dcca8f2910cef0660d6f0f8c22", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 9, "file": 14, "line": 100}, "message": "destructor '~PointerUnionMembers' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/PointerUnion.h", "reportHash": "fb8866025d20479ac501f3a27795ec44", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 9, "file": 14, "line": 100}, "message": "move assignment operator 'operator=' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/PointerUnion.h", "reportHash": "47f6cf3560b996f7c0cc1ed4e1b3e1d2", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 9, "file": 14, "line": 100}, "message": "move constructor 'PointerUnionMembers' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/PointerUnion.h", "reportHash": "2b71aeea3338cd6893245f0147718e94", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 9, "file": 14, "line": 111}, "message": "destructor '~PointerUnionMembers' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/PointerUnion.h", "reportHash": "6835ee16d57d00e60d43892d7c5362de", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 14, "line": 149}, "message": "destructor '~PointerUnion' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/PointerUnion.h", "reportHash": "3fd3d56d7fb9c249634c6c33e7db66dd", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 14, "line": 149}, "message": "move assignment operator 'operator=' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/PointerUnion.h", "reportHash": "a27c0c39eb79599ca0e8f488b2d16482", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 14, "line": 149}, "message": "move constructor 'PointerUnion' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/PointerUnion.h", "reportHash": "819fd66c75ed705007e8825cde305b54", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 19, "line": 207}, "message": "destructor '~iterator_adaptor_base' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/iterator.h", "reportHash": "f221bafa0186256f20b06195c22a0523", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 19, "line": 207}, "message": "move constructor 'iterator_adaptor_base' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/iterator.h", "reportHash": "f0a1f203a12fc844f3fe17255ac1f37e", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 22, "line": 114}, "message": "default constructor 'AccelTableData' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/CodeGen/AccelTable.h", "reportHash": "1560d2f7eae2336b7f91cdcc2be0ff89", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 22, "line": 220}, "message": "default constructor 'AppleAccelTableData' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/CodeGen/AccelTable.h", "reportHash": "aa27a71bc540345d6364d684f6514ef8", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 22, "line": 220}, "message": "destructor '~AppleAccelTableData' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/CodeGen/AccelTable.h", "reportHash": "7cb8c7daa7c806b98227331bc7019712", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 10, "file": 22, "line": 225}, "message": "destructor '~Atom' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/CodeGen/AccelTable.h", "reportHash": "a37de04a82916b1d20a4871c2adf6544", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 10, "file": 22, "line": 225}, "message": "move constructor 'Atom' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/CodeGen/AccelTable.h", "reportHash": "db07f8b09426f3ec7c53d9cd98e18a62", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 22, "line": 250}, "message": "destructor '~DWARF5AccelTableData' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/CodeGen/AccelTable.h", "reportHash": "914b6d217993c89eca8852f65d7c6372", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 22, "line": 270}, "message": "destructor '~DWARF5AccelTableStaticData' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/CodeGen/AccelTable.h", "reportHash": "f7eaa442a95ba3c59979f4123fdb84c5", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 22, "line": 321}, "message": "destructor '~AppleAccelTableOffsetData' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/CodeGen/AccelTable.h", "reportHash": "88bcafdc56663d06b4315bec5b969e03", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 22, "line": 340}, "message": "destructor '~AppleAccelTableTypeData' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/CodeGen/AccelTable.h", "reportHash": "081960c06771ef5614f8438c40ea296e", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 22, "line": 358}, "message": "destructor '~AppleAccelTableStaticOffsetData' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/CodeGen/AccelTable.h", "reportHash": "3c1bd5bd0f5587e5f0558c80f619d2ee", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 22, "line": 378}, "message": "destructor '~AppleAccelTableStaticTypeData' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/CodeGen/AccelTable.h", "reportHash": "eaa1dacf7931c678d0d0be662a7cadb5", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 23, "line": 49}, "message": "destructor '~DIEAbbrevData' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/CodeGen/DIE.h", "reportHash": "516d6f2a42344790c50001cc3cd5cb90", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 23, "line": 49}, "message": "move constructor 'DIEAbbrevData' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/CodeGen/DIE.h", "reportHash": "cc116277e39dd038f308554d454ed25e", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 23, "line": 163}, "message": "destructor '~DIEInteger' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/CodeGen/DIE.h", "reportHash": "d6bfa68f8d5fc994eccd944b3f5721dc", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 23, "line": 201}, "message": "destructor '~DIEExpr' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/CodeGen/DIE.h", "reportHash": "29d16d4fc3d3d1fe6db1b5dfaf67087c", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 23, "line": 218}, "message": "destructor '~DIELabel' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/CodeGen/DIE.h", "reportHash": "6703ba6e1886dc0daf467fd40127dfb6", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 23, "line": 273}, "message": "destructor '~DIEString' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/CodeGen/DIE.h", "reportHash": "a9069ef0dcec2dec5057de9a2c7399a5", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 23, "line": 314}, "message": "destructor '~DIEEntry' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/CodeGen/DIE.h", "reportHash": "79926a3f44b1b5b04bd8fa7e6ee5f2b0", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 23, "line": 332}, "message": "destructor '~DIELocList' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/CodeGen/DIE.h", "reportHash": "5723ae6194b6368d3f558fc67b1953b7", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 23, "line": 515}, "message": "destructor '~IntrusiveBackListNode' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/CodeGen/DIE.h", "reportHash": "7881765bd68d706fe13b177fd57ba033", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 23, "line": 525}, "message": "default constructor 'IntrusiveBackListBase' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/CodeGen/DIE.h", "reportHash": "48900fbb11900585197098ae0dce2a63", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 23, "line": 525}, "message": "destructor '~IntrusiveBackListBase' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/CodeGen/DIE.h", "reportHash": "e096a74be37e810c1bba7e5e1705b122", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 26, "file": 23, "line": 556}, "message": "default constructor 'IntrusiveBackList' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/CodeGen/DIE.h", "reportHash": "02ebf4ffc21fe799f8bc6d3e81a14ec5", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 26, "file": 23, "line": 556}, "message": "destructor '~IntrusiveBackList' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/CodeGen/DIE.h", "reportHash": "27233c1e0be4b54b69e8e81bc577c591", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 9, "file": 23, "line": 591}, "message": "destructor '~iterator' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/CodeGen/DIE.h", "reportHash": "2ce700337049a9dd92f9cc58f0894a67", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 9, "file": 23, "line": 591}, "message": "move constructor 'iterator' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/CodeGen/DIE.h", "reportHash": "c7cf16d8b08bbc992d5fae6acec6d69b", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 9, "file": 23, "line": 612}, "message": "destructor '~const_iterator' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/CodeGen/DIE.h", "reportHash": "970024c6a130272d4ddbe3c97c00adce", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 9, "file": 23, "line": 612}, "message": "move constructor 'const_iterator' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/CodeGen/DIE.h", "reportHash": "fafed4e7d7d1555f0f5ee6073299447e", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 23, "line": 662}, "message": "default constructor 'DIEValueList' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/CodeGen/DIE.h", "reportHash": "6313147f4e2872e376ee0f352c0f3c86", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 23, "line": 662}, "message": "destructor '~DIEValueList' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/CodeGen/DIE.h", "reportHash": "9fdbf87d44ea236bcd60aa9f9eb9537e", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 9, "file": 23, "line": 675}, "message": "destructor '~value_iterator' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/CodeGen/DIE.h", "reportHash": "1712ab5db6d5b46c62717bec5fca2c53", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 9, "file": 23, "line": 675}, "message": "move constructor 'value_iterator' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/CodeGen/DIE.h", "reportHash": "afdbb91fff38f24895f9fe2076cb889e", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 9, "file": 23, "line": 692}, "message": "destructor '~const_value_iterator' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/CodeGen/DIE.h", "reportHash": "2c4599b3bba6ebf39e0099bf2bd10827", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 9, "file": 23, "line": 692}, "message": "move constructor 'const_value_iterator' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/CodeGen/DIE.h", "reportHash": "c96816ea439bc93b8105a744bcae221f", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 23, "line": 739}, "message": "destructor '~DIE' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/CodeGen/DIE.h", "reportHash": "044fe98bfa016a161d3e92da60d5bc7e", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 23, "line": 915}, "message": "destructor '~BasicDIEUnit' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/CodeGen/DIE.h", "reportHash": "167d249620672ac970e8ce2972160494", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 24, "line": 20}, "message": "destructor '~DwarfStringPoolEntry' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/CodeGen/DwarfStringPoolEntry.h", "reportHash": "18fd41c2291eea2a41253e139a54731b", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 24, "line": 20}, "message": "move constructor 'DwarfStringPoolEntry' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/CodeGen/DwarfStringPoolEntry.h", "reportHash": "b23680b8df2b44f2ef7ed3d4748e03f7", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 24, "line": 31}, "message": "destructor '~DwarfStringPoolEntryRef' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/CodeGen/DwarfStringPoolEntry.h", "reportHash": "f205216901c1ccd2c50704df5434e1b3", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 25, "line": 52}, "message": "destructor '~MBBSectionID' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/CodeGen/MachineBasicBlock.h", "reportHash": "e6082aa6b9c62a0d5c5074116e4a20ec", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 10, "file": 25, "line": 101}, "message": "destructor '~RegisterMaskPair' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/CodeGen/MachineBasicBlock.h", "reportHash": "20fea310b4b4dcb79f665b7c21d5698c", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 26, "line": 111}, "message": "destructor '~MachineFunctionProperties' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h", "reportHash": "a19adb791d77b6309de94e8c9dd38fc2", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 27, "line": 30}, "message": "destructor '~MachineFunctionPass' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/CodeGen/MachineFunctionPass.h", "reportHash": "643754257d1ff86194d370fa850392fe", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 37, "file": 28, "line": 518}, "message": "destructor '~' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h", "reportHash": "70caa300d01dcfe8392ca6ca21d9e4b3", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 29, "line": 37}, "message": "destructor '~MachinePointerInfo' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/CodeGen/MachineMemOperand.h", "reportHash": "0823e4547e3351a50e5652f360f142b1", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 29, "line": 37}, "message": "move constructor 'MachinePointerInfo' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/CodeGen/MachineMemOperand.h", "reportHash": "b6afb8c8517e0b430d3b4e7c98995ae8", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 30, "line": 49}, "message": "move constructor 'MachineOperand' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/CodeGen/MachineOperand.h", "reportHash": "b2ba22d21c8f9dfb2a29c4846ccb99b5", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 30, "line": 155}, "message": "default constructor '' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/CodeGen/MachineOperand.h", "reportHash": "eae5c9894a302ef5b12bceff40edfc43", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 30, "line": 155}, "message": "move constructor '' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/CodeGen/MachineOperand.h", "reportHash": "2d9b3b70ae116ee267effc0222f310ee", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 31, "line": 94}, "message": "destructor '~FixedStackPseudoSourceValue' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/CodeGen/PseudoSourceValue.h", "reportHash": "7009afcafe925a8bd1be356bba798bad", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 32, "line": 19}, "message": "destructor '~Register' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/CodeGen/Register.h", "reportHash": "536b6f3eb463f9c27ace6f7d0530b553", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 32, "line": 19}, "message": "move constructor 'Register' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/CodeGen/Register.h", "reportHash": "2f8dcce7f76aa6977b80d5e94cffddc8", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 10, "file": 33, "line": 55}, "message": "destructor '~DwarfFrameBase' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/CodeGen/TargetFrameLowering.h", "reportHash": "3c43fa804a23a8f92705c8db2cc4c185", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 10, "file": 33, "line": 55}, "message": "move constructor 'DwarfFrameBase' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/CodeGen/TargetFrameLowering.h", "reportHash": "b8f0af08699c7be12908ff5301bd33ed", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 12, "file": 33, "line": 59}, "message": "destructor '~WasmFrameBase' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/CodeGen/TargetFrameLowering.h", "reportHash": "7aa12c59f76da230c3995e37fabafe70", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 12, "file": 33, "line": 59}, "message": "move constructor 'WasmFrameBase' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/CodeGen/TargetFrameLowering.h", "reportHash": "e9bdaf6b94c764dfead7c98b4bb5138c", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 5, "file": 33, "line": 63}, "message": "destructor '~' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/CodeGen/TargetFrameLowering.h", "reportHash": "0b1c6446db33a5045c4c4c8b8afe2e23", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 5, "file": 33, "line": 63}, "message": "move constructor '' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/CodeGen/TargetFrameLowering.h", "reportHash": "faa2412522bb1694d927a3731403c937", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 34, "line": 51}, "message": "destructor '~Attribute' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/IR/Attributes.h", "reportHash": "a7d27cd6fdcef80ee6e3b0a5c3ebee3d", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 34, "line": 51}, "message": "move constructor 'Attribute' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/IR/Attributes.h", "reportHash": "9564857a659bf90838ee100b66995672", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 34, "line": 365}, "message": "destructor '~AttributeList' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/IR/Attributes.h", "reportHash": "9927c85addf68c9234c90b334e874e00", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 34, "line": 365}, "message": "move constructor 'AttributeList' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/IR/Attributes.h", "reportHash": "fb84d961dee345344624c316f92f72a8", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 10, "file": 35, "line": 524}, "message": "default constructor 'BasicBlockBits' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/IR/BasicBlock.h", "reportHash": "bad013ba5979a44c9f84e524220d0d09", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 10, "file": 35, "line": 524}, "message": "destructor '~BasicBlockBits' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/IR/BasicBlock.h", "reportHash": "990770ee8567af13bf502d1b43f627b6", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 10, "file": 35, "line": 524}, "message": "move constructor 'BasicBlockBits' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/IR/BasicBlock.h", "reportHash": "bf69e0dd0f749366adcacc9c17e3cc9a", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 36, "line": 51}, "message": "destructor '~ConstantData' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/IR/Constants.h", "reportHash": "76058d7e244636ed76503b2b6c4c1947", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 36, "line": 1353}, "message": "destructor '~UndefValue' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/IR/Constants.h", "reportHash": "ed5b677cc0b406dffc1c2d07143125a0", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 37, "line": 63}, "message": "destructor '~DITypeRefArray' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/IR/DebugInfoMetadata.h", "reportHash": "f5a1d8d1ce031c0bcfa7584c2391bc84", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 37, "line": 63}, "message": "move constructor 'DITypeRefArray' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/IR/DebugInfoMetadata.h", "reportHash": "36c29569edbb5c7fa8605ca74bb3cc6f", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 9, "file": 37, "line": 83}, "message": "move constructor 'iterator' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/IR/DebugInfoMetadata.h", "reportHash": "ab4b9a9071219accf61fb5826c5f5806", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 9, "file": 37, "line": 2601}, "message": "destructor '~ExprOperand' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/IR/DebugInfoMetadata.h", "reportHash": "541d32e4e98ceb8630ea36bb6057d833", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 9, "file": 37, "line": 2601}, "message": "move assignment operator 'operator=' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/IR/DebugInfoMetadata.h", "reportHash": "21f059917f34a4011cbe03a06faf6788", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 9, "file": 37, "line": 2601}, "message": "move constructor 'ExprOperand' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/IR/DebugInfoMetadata.h", "reportHash": "369aba8eaffc1927d2aa6b691ccbf628", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 9, "file": 37, "line": 2632}, "message": "destructor '~expr_op_iterator' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/IR/DebugInfoMetadata.h", "reportHash": "a09c49af623008ae22a5b34ba4c50b01", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 9, "file": 37, "line": 2632}, "message": "move assignment operator 'operator=' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/IR/DebugInfoMetadata.h", "reportHash": "5b039f5bda78f7aa968766f1fbdbe3f9", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 9, "file": 37, "line": 2632}, "message": "move constructor 'expr_op_iterator' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/IR/DebugInfoMetadata.h", "reportHash": "68e3a730878b3a42e3165b9a9d251e5d", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 37, "line": 3579}, "message": "move constructor 'DebugVariable' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/IR/DebugInfoMetadata.h", "reportHash": "3453787b4a68ba5621c9e5522ec52517", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 38, "line": 391}, "message": "destructor '~VectorType' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/IR/DerivedTypes.h", "reportHash": "5d8b395838b4ecad65a5d5b07e2d3d8e", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 9, "file": 39, "line": 282}, "message": "destructor '~ProfileCount' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/IR/Function.h", "reportHash": "98c9159125259e006e30065bb30e4e7a", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 9, "file": 39, "line": 282}, "message": "move constructor 'ProfileCount' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/IR/Function.h", "reportHash": "4a61b3392969c7ff08cf6a736da66b8c", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 40, "line": 30}, "message": "destructor '~GlobalObject' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/IR/GlobalObject.h", "reportHash": "d8edc7ebe8a945f2b1e4289ea8d2c64c", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 10, "file": 41, "line": 49}, "message": "'llvm/IR/IntrinsicEnums.inc' file not found"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/IR/Intrinsics.h", "reportHash": "66fd43c8c64831667bf194039dfffe87", "checkerName": "clang-diagnostic-error", "reviewStatus": null, "severity": "CRITICAL"}, {"events": [{"location": {"col": 10, "file": 41, "line": 104}, "message": "move constructor 'IITDescriptor' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/IR/Intrinsics.h", "reportHash": "83c7d2a24e32746528cf5235410d368c", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 5, "file": 41, "line": 135}, "message": "destructor '~' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/IR/Intrinsics.h", "reportHash": "eea5ff0fd8a7c554c8c90e89ecd7d5e3", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 5, "file": 41, "line": 135}, "message": "move constructor '' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/IR/Intrinsics.h", "reportHash": "8c431cb9b3ce5dcbb1c024fb28926656", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 42, "line": 647}, "message": "destructor '~AAMDNodes' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/IR/Metadata.h", "reportHash": "73d23ad26bbc1dd9f6d5530bb7bd5a1c", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 42, "line": 647}, "message": "move constructor 'AAMDNodes' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/IR/Metadata.h", "reportHash": "7b95410438db64083112150f85f16f4d", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 42, "line": 868}, "message": "default constructor 'TempMDNodeDeleter' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/IR/Metadata.h", "reportHash": "cd96d9cc4ad6d91f8a12539be3f25fc1", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 42, "line": 868}, "message": "destructor '~TempMDNodeDeleter' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/IR/Metadata.h", "reportHash": "1a370f5152b4b90eb8d165e175536afd", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 42, "line": 868}, "message": "move assignment operator 'operator=' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/IR/Metadata.h", "reportHash": "d6767cb0de0fe11d38e421c887920db7", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 42, "line": 868}, "message": "move constructor 'TempMDNodeDeleter' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/IR/Metadata.h", "reportHash": "82425b46e92b6c7b3341dfb4619ea7f7", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 9, "file": 42, "line": 1392}, "message": "destructor '~op_iterator_impl' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/IR/Metadata.h", "reportHash": "514240fdfb34a69f4fb03400189d0cb2", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 9, "file": 42, "line": 1392}, "message": "move constructor 'op_iterator_impl' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/IR/Metadata.h", "reportHash": "9a218da058ceea01528a4cb24ad895ef", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 9, "file": 43, "line": 708}, "message": "destructor '~debug_compile_units_iterator' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/IR/Module.h", "reportHash": "f340fe67fe99071fddee26042ad9febc", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 9, "file": 43, "line": 708}, "message": "move constructor 'debug_compile_units_iterator' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/IR/Module.h", "reportHash": "84aee4d17da5fb443c9443e7dbcb447e", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 44, "line": 161}, "message": "destructor '~PassInstrumentation' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/IR/PassInstrumentation.h", "reportHash": "c73999364381b2fb342732af617f7444", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 44, "line": 161}, "message": "move constructor 'PassInstrumentation' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/IR/PassInstrumentation.h", "reportHash": "0ec332a326ce891f9cdd9a3d36e960a3", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 19, "file": 45, "line": 72}, "message": "default constructor 'AnalysisKey' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/IR/PassManager.h", "reportHash": "2ea396aaad0a37e964d2f6f4e55c8d2e", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 19, "file": 45, "line": 82}, "message": "default constructor 'AnalysisSetKey' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/IR/PassManager.h", "reportHash": "225e110badf4c9673f7a906841ca5561", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 45, "line": 155}, "message": "default constructor 'PreservedAnalyses' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/IR/PassManager.h", "reportHash": "136feadac2c6be9d14abf6c474173dca", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 45, "line": 155}, "message": "move constructor 'PreservedAnalyses' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/IR/PassManager.h", "reportHash": "e002f93affbbc138f8a8701dd1b85344", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 9, "file": 45, "line": 269}, "message": "destructor '~PreservedAnalysisChecker' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/IR/PassManager.h", "reportHash": "fc121099dd466b63774651b10f31610a", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 9, "file": 45, "line": 269}, "message": "move constructor 'PreservedAnalysisChecker' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/IR/PassManager.h", "reportHash": "24f86b956a03f92fd0da5ec7dcaf032e", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 45, "line": 1231}, "message": "move constructor 'ModuleToFunctionPassAdaptor' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/IR/PassManager.h", "reportHash": "d1a9ec3f9fa0e9d5f604d0d9079b83de", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 10, "file": 46, "line": 250}, "message": "destructor '~value_op_iterator' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/IR/User.h", "reportHash": "7433e71465ed81ef94045d855a05e118", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 10, "file": 46, "line": 250}, "message": "move constructor 'value_op_iterator' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/IR/User.h", "reportHash": "b1402f11f5319aa7f3feea2d6e87d5ca", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 10, "file": 46, "line": 270}, "message": "destructor '~const_value_op_iterator' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/IR/User.h", "reportHash": "7e572b7795fd822de4a6a8f579c8199e", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 10, "file": 46, "line": 270}, "message": "move constructor 'const_value_op_iterator' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/IR/User.h", "reportHash": "faf3ebfd6fe975b4448800e55c9628c1", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 9, "file": 47, "line": 126}, "message": "destructor '~use_iterator_impl' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/IR/Value.h", "reportHash": "a98c3cf0729854f522912ff7bc5a7359", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 9, "file": 47, "line": 126}, "message": "move constructor 'use_iterator_impl' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/IR/Value.h", "reportHash": "4412462b20c198316319eeec283a8ee8", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 9, "file": 47, "line": 165}, "message": "destructor '~user_iterator_impl' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/IR/Value.h", "reportHash": "f4ec617c26a76610d37d292443dac24d", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 9, "file": 47, "line": 165}, "message": "move constructor 'user_iterator_impl' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/IR/Value.h", "reportHash": "6fe3e6c2036abda96d77be42f2e7f3bf", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 30, "file": 47, "line": 486}, "message": "destructor '~' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/IR/Value.h", "reportHash": "2acb5673d3220c61c6d56d669dc0ea33", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 41, "file": 47, "line": 734}, "message": "destructor '~' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/IR/Value.h", "reportHash": "d8fc044bef32a7f9f881164c7b365d54", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 35, "file": 47, "line": 736}, "message": "destructor '~' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/IR/Value.h", "reportHash": "dd14e03077f0cf7cc0ace33029d7ddc4", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 48, "line": 144}, "message": "destructor '~WeakVH' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/IR/ValueHandle.h", "reportHash": "255079d6f78e48025784bcf43567eac1", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 10, "file": 49, "line": 39}, "message": "destructor '~LaneBitmask' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/MC/LaneBitmask.h", "reportHash": "99ed545e2704423f6c3b624bceca0d3f", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 10, "file": 49, "line": 39}, "message": "move constructor 'LaneBitmask' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/MC/LaneBitmask.h", "reportHash": "1c37244935cff17b7342bebb0c1187a6", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 22, "file": 49, "line": 94}, "message": "destructor '~' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/MC/LaneBitmask.h", "reportHash": "138b588d6fd00a6208a42d1a433eeded", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 50, "line": 441}, "message": "move constructor 'MCCFIInstruction' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/MC/MCDwarf.h", "reportHash": "3990d0a77e3fc5d806578a0b26b9d798", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 50, "line": 466}, "message": "move constructor '' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/MC/MCDwarf.h", "reportHash": "6390fe72db7c433359639df9ebcb463f", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 54, "line": 22}, "message": "destructor '~MCRegister' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/MC/MCRegister.h", "reportHash": "972cc770616c3c9aaa71f8c0f363e7cc", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 54, "line": 22}, "message": "move assignment operator 'operator=' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/MC/MCRegister.h", "reportHash": "ec74a6ad11c1e875e1ff4bc51d7c5227", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 54, "line": 22}, "message": "move constructor 'MCRegister' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/MC/MCRegister.h", "reportHash": "e7e225e713b5b52664fa905852f71cf4", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 9, "file": 55, "line": 189}, "message": "destructor '~DiffListIterator' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/MC/MCRegisterInfo.h", "reportHash": "d54b015469ce945545bf54eb5a1bda94", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 9, "file": 55, "line": 189}, "message": "move assignment operator 'operator=' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/MC/MCRegisterInfo.h", "reportHash": "74b1a3d71e0679bedeb72c8f82267cba", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 55, "line": 634}, "message": "destructor '~MCSuperRegIterator' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/MC/MCRegisterInfo.h", "reportHash": "a0efa71c23044bc7aadfb814dee6c00f", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 55, "line": 634}, "message": "move assignment operator 'operator=' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/MC/MCRegisterInfo.h", "reportHash": "d9c736ec6b6c910707d3df80169b7bcf", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 55, "line": 670}, "message": "destructor '~MCRegUnitIterator' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/MC/MCRegisterInfo.h", "reportHash": "b73938cd3da1bc3c86e16982b8bffc03", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 55, "line": 670}, "message": "move assignment operator 'operator=' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/MC/MCRegisterInfo.h", "reportHash": "efc265273283dabf64b1747143225c20", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 55, "line": 739}, "message": "destructor '~MCRegUnitRootIterator' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/MC/MCRegisterInfo.h", "reportHash": "66b7a55318b44879be977179f6d11772", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 55, "line": 739}, "message": "move assignment operator 'operator=' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/MC/MCRegisterInfo.h", "reportHash": "a7201188f83a96b9cd536b77e499596a", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 56, "line": 22}, "message": "destructor '~MachineLocation' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/MC/MachineLocation.h", "reportHash": "716046be4e5e151c6ac79b48e170e143", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 56, "line": 22}, "message": "move constructor 'MachineLocation' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/MC/MachineLocation.h", "reportHash": "4789985572727ebbf4247e4e5374b681", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 57, "line": 22}, "message": "default constructor 'SectionKind' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/MC/SectionKind.h", "reportHash": "4a4a09735928db5c15423243705c82fb", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 57, "line": 22}, "message": "destructor '~SectionKind' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/MC/SectionKind.h", "reportHash": "191a76f97362575d8dc89534b4a56a6e", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 57, "line": 22}, "message": "move constructor 'SectionKind' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/MC/SectionKind.h", "reportHash": "0aebe1151552b2604272da771388df04", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 59, "line": 298}, "message": "destructor '~FunctionPass' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Pass.h", "reportHash": "3062a62ffb65a182b9bfaf441fa2cfef", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 60, "line": 73}, "message": "destructor '~ExtName' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/ARMTargetParser.h", "reportHash": "50df8854f6329833f439cccd215a95c1", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 60, "line": 92}, "message": "destructor '~' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/ARMTargetParser.h", "reportHash": "57750e272e00fb38974a038ef63b5329", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 60, "line": 177}, "message": "destructor '~FPUName' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/ARMTargetParser.h", "reportHash": "b64541419ea7dcfd279f7d5b680a21cd", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 64, "line": 30}, "message": "destructor '~BranchProbability' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/BranchProbability.h", "reportHash": "b26e78d027fbec5ec57c71537195d964", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 64, "line": 30}, "message": "move assignment operator 'operator=' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/BranchProbability.h", "reportHash": "ba20d96e31ccbbd3f6a7276063026323", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 64, "line": 30}, "message": "move constructor 'BranchProbability' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/BranchProbability.h", "reportHash": "237815a568a82db99652782bd9840ea8", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 65, "line": 677}, "message": "move constructor 'ValuesClass' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/CommandLine.h", "reportHash": "cd87d8217631fb5f999b9d8cbdaddfbd", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 69, "line": 40}, "message": "destructor '~LLT' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/LowLevelTypeImpl.h", "reportHash": "3e65695a815746335be30c29affa81ae", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 69, "line": 40}, "message": "move constructor 'LLT' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/LowLevelTypeImpl.h", "reportHash": "16349e59d553607e67617fc58c36da8e", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 9, "file": 71, "line": 30}, "message": "destructor '~MVT' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/MachineValueType.h", "reportHash": "4816901103e3fbc0d1dcd0660446784d", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 9, "file": 71, "line": 30}, "message": "move constructor 'MVT' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/MachineValueType.h", "reportHash": "46e293b80162fdd953394788e324c2df", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 72, "line": 37}, "message": "move constructor 'Printable' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/Printable.h", "reportHash": "e82b52762024c649dde9ff7874cc010d", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 77, "line": 42}, "message": "destructor '~LinearPolyBase' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/TypeSize.h", "reportHash": "2c7fd9d8c3a6b6b4cb7c488fc68584b2", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 77, "line": 42}, "message": "move constructor 'LinearPolyBase' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/TypeSize.h", "reportHash": "96cef3f5948670292e1386974996666e", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 77, "line": 130}, "message": "destructor '~StackOffset' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/TypeSize.h", "reportHash": "905fe68b7919703f60093103262151b2", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 77, "line": 130}, "message": "move constructor 'StackOffset' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/TypeSize.h", "reportHash": "1ae8c21376b6d387f5e6f152b63ec5b7", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 77, "line": 161}, "message": "destructor '~UnivariateLinearPolyBase' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/TypeSize.h", "reportHash": "90aab98c99a461a20be3a26fa2202374", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 77, "line": 161}, "message": "move assignment operator 'operator=' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/TypeSize.h", "reportHash": "08ab90fe75e81b5be8705cee859b86f9", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 77, "line": 161}, "message": "move constructor 'UnivariateLinearPolyBase' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/TypeSize.h", "reportHash": "dafbf7a1973758c25d0308e07622020c", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 77, "line": 261}, "message": "destructor '~LinearPolySize' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/TypeSize.h", "reportHash": "587117abebe2c98db4f9905c24f30184", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 77, "line": 261}, "message": "move assignment operator 'operator=' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/TypeSize.h", "reportHash": "55c52ea3587016e3f4d1a51ac15d34b2", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 77, "line": 261}, "message": "move constructor 'LinearPolySize' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/TypeSize.h", "reportHash": "905ce26694147a10d10fc3ef5439cda6", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 77, "line": 382}, "message": "destructor '~ElementCount' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/TypeSize.h", "reportHash": "c0e49f40534b92811241756a3e76cae4", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 77, "line": 382}, "message": "move assignment operator 'operator=' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/TypeSize.h", "reportHash": "f36a280eb301c3d88e3dc6c91ffc0565", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 77, "line": 382}, "message": "move constructor 'ElementCount' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/TypeSize.h", "reportHash": "55b4762d9f6500d9e4c17fec6bb063e1", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 77, "line": 413}, "message": "destructor '~TypeSize' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/TypeSize.h", "reportHash": "36d3000ffabb898355b8ef8d60bf7cb6", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 77, "line": 413}, "message": "move constructor 'TypeSize' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/TypeSize.h", "reportHash": "8f792eb945e7e9ea8809b5122d1efe0c", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 81, "line": 76}, "message": "move constructor 'BufferByteStreamer' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/lib/CodeGen/AsmPrinter/ByteStreamer.h", "reportHash": "570467c90da0149967beec5a5667ce01", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 82, "line": 24}, "message": "destructor '~TargetIndexLocation' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/lib/CodeGen/AsmPrinter/DebugLocEntry.h", "reportHash": "1b33ce89dc1d0f32e34a35056fe0aad6", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 82, "line": 24}, "message": "move constructor 'TargetIndexLocation' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/lib/CodeGen/AsmPrinter/DebugLocEntry.h", "reportHash": "bb5fa5d45783de66d796a9cb24d8bdb5", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 82, "line": 53}, "message": "default constructor '' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/lib/CodeGen/AsmPrinter/DebugLocEntry.h", "reportHash": "0f56279188326e513c6c17456479181e", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 39, "file": 83, "line": 766}, "message": "destructor '~' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfCompileUnit.cpp", "reportHash": "58a9229095da1636420168fc728016ac", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 21, "file": 83, "line": 778}, "message": "destructor '~' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfCompileUnit.cpp", "reportHash": "0cba7e57373152c4a9c982bcac058d0c", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 21, "file": 83, "line": 778}, "message": "move constructor '' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfCompileUnit.cpp", "reportHash": "d80b5aa6f567dba0deb2edabf5f755ae", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 9, "file": 83, "line": 807}, "message": "destructor '~' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfCompileUnit.cpp", "reportHash": "a2c6e9b2151b4bd5c3f902c3af6d14e2", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 84, "line": 47}, "message": "destructor '~DwarfCompileUnit' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfCompileUnit.h", "reportHash": "2205fa25420fef53bcd1b0b57969ae6f", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 85, "line": 116}, "message": "destructor '~DbgVariable' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.h", "reportHash": "0db85c0c6174ee3b72a179361e335de8", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 85, "line": 233}, "message": "destructor '~DbgLabel' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.h", "reportHash": "89d06b015d5177ce31a1418da3057622", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 85, "line": 279}, "message": "destructor '~SymbolCU' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.h", "reportHash": "a13e351ea4873fd66c4dd8686fed6dda", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 85, "line": 279}, "message": "move constructor 'SymbolCU' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.h", "reportHash": "d3f0d7523531f823a5243007efb1e853", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}]};
      window.onload = function() {
        if (!browserCompatible) {
          setNonCompatibleBrowserMessage();
        } else {
          BugViewer.init(data.files, data.reports);
          BugViewer.create();
          BugViewer.initByUrl();
        }
      };
    </script>
  </head>
  <body>
  <div class="container">
    <div id="content">
      <div id="side-bar">
        <div class="header">
          <a href="index.html" class="button">&#8249; Return to List</a>
        </div>
        <div id="report-nav">
          <div class="header">Reports</div>
        </div>
      </div>
      <div id="editor-wrapper">
        <div class="header">
          <div id="file">
            <span class="label">File:</span>
            <span id="file-path"></span>
          </div>
          <div id="checker">
            <span class="label">Checker name:</span>
            <span id="checker-name"></span>
          </div>
          <div id="review-status-wrapper">
            <span class="label">Review status:</span>
            <span id="review-status"></span>
          </div>
        </div>
        <div id="editor"></div>
      </div>
    </div>
  </div>
  </body>
</html>
