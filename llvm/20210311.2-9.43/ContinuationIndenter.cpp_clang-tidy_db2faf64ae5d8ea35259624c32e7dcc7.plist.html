<!DOCTYPE html>
<html>
  <head>
    <title>Plist HTML Viewer</title>

    <meta charset="UTF-8">

    <style type="text/css">
      .CodeMirror{font-family:monospace;height:300px;color:#000;direction:ltr}.CodeMirror-lines{padding:4px 0}.CodeMirror pre{padding:0 4px}.CodeMirror-gutter-filler,.CodeMirror-scrollbar-filler{background-color:#fff}.CodeMirror-gutters{border-right:1px solid #ddd;background-color:#f7f7f7;white-space:nowrap}.CodeMirror-linenumber{padding:0 3px 0 5px;min-width:20px;text-align:right;color:#999;white-space:nowrap}.CodeMirror-guttermarker{color:#000}.CodeMirror-guttermarker-subtle{color:#999}.CodeMirror-cursor{border-left:1px solid #000;border-right:none;width:0}.CodeMirror div.CodeMirror-secondarycursor{border-left:1px solid silver}.cm-fat-cursor .CodeMirror-cursor{width:auto;border:0!important;background:#7e7}.cm-fat-cursor div.CodeMirror-cursors{z-index:1}.cm-animate-fat-cursor{width:auto;border:0;-webkit-animation:blink 1.06s steps(1) infinite;-moz-animation:blink 1.06s steps(1) infinite;animation:blink 1.06s steps(1) infinite;background-color:#7e7}@-moz-keyframes blink{50%{background-color:transparent}}@-webkit-keyframes blink{50%{background-color:transparent}}@keyframes blink{50%{background-color:transparent}}.cm-tab{display:inline-block;text-decoration:inherit}.CodeMirror-rulers{position:absolute;left:0;right:0;top:-50px;bottom:-20px;overflow:hidden}.CodeMirror-ruler{border-left:1px solid #ccc;top:0;bottom:0;position:absolute}.cm-s-default .cm-header{color:#00f}.cm-s-default .cm-quote{color:#090}.cm-negative{color:#d44}.cm-positive{color:#292}.cm-header,.cm-strong{font-weight:700}.cm-em{font-style:italic}.cm-link{text-decoration:underline}.cm-strikethrough{text-decoration:line-through}.cm-s-default .cm-keyword{color:#708}.cm-s-default .cm-atom{color:#219}.cm-s-default .cm-number{color:#164}.cm-s-default .cm-def{color:#00f}.cm-s-default .cm-variable-2{color:#05a}.cm-s-default .cm-type,.cm-s-default .cm-variable-3{color:#085}.cm-s-default .cm-comment{color:#a50}.cm-s-default .cm-string{color:#a11}.cm-s-default .cm-string-2{color:#f50}.cm-s-default .cm-meta{color:#555}.cm-s-default .cm-qualifier{color:#555}.cm-s-default .cm-builtin{color:#30a}.cm-s-default .cm-bracket{color:#997}.cm-s-default .cm-tag{color:#170}.cm-s-default .cm-attribute{color:#00c}.cm-s-default .cm-hr{color:#999}.cm-s-default .cm-link{color:#00c}.cm-s-default .cm-error{color:red}.cm-invalidchar{color:red}.CodeMirror-composing{border-bottom:2px solid}div.CodeMirror span.CodeMirror-matchingbracket{color:#0f0}div.CodeMirror span.CodeMirror-nonmatchingbracket{color:#f22}.CodeMirror-matchingtag{background:rgba(255,150,0,.3)}.CodeMirror-activeline-background{background:#e8f2ff}.CodeMirror{position:relative;overflow:hidden;background:#fff}.CodeMirror-scroll{overflow:scroll!important;margin-bottom:-30px;margin-right:-30px;padding-bottom:30px;height:100%;outline:0;position:relative}.CodeMirror-sizer{position:relative;border-right:30px solid transparent}.CodeMirror-gutter-filler,.CodeMirror-hscrollbar,.CodeMirror-scrollbar-filler,.CodeMirror-vscrollbar{position:absolute;z-index:6;display:none}.CodeMirror-vscrollbar{right:0;top:0;overflow-x:hidden;overflow-y:scroll}.CodeMirror-hscrollbar{bottom:0;left:0;overflow-y:hidden;overflow-x:scroll}.CodeMirror-scrollbar-filler{right:0;bottom:0}.CodeMirror-gutter-filler{left:0;bottom:0}.CodeMirror-gutters{position:absolute;left:0;top:0;min-height:100%;z-index:3}.CodeMirror-gutter{white-space:normal;height:100%;display:inline-block;vertical-align:top;margin-bottom:-30px}.CodeMirror-gutter-wrapper{position:absolute;z-index:4;background:0 0!important;border:none!important}.CodeMirror-gutter-background{position:absolute;top:0;bottom:0;z-index:4}.CodeMirror-gutter-elt{position:absolute;cursor:default;z-index:4}.CodeMirror-gutter-wrapper ::selection{background-color:transparent}.CodeMirror-gutter-wrapper ::-moz-selection{background-color:transparent}.CodeMirror-lines{cursor:text;min-height:1px}.CodeMirror pre{-moz-border-radius:0;-webkit-border-radius:0;border-radius:0;border-width:0;background:0 0;font-family:inherit;font-size:inherit;margin:0;white-space:pre;word-wrap:normal;line-height:inherit;color:inherit;z-index:2;position:relative;overflow:visible;-webkit-tap-highlight-color:transparent;-webkit-font-variant-ligatures:contextual;font-variant-ligatures:contextual}.CodeMirror-wrap pre{word-wrap:break-word;white-space:pre-wrap;word-break:normal}.CodeMirror-linebackground{position:absolute;left:0;right:0;top:0;bottom:0;z-index:0}.CodeMirror-linewidget{position:relative;z-index:2;overflow:auto}.CodeMirror-rtl pre{direction:rtl}.CodeMirror-code{outline:0}.CodeMirror-gutter,.CodeMirror-gutters,.CodeMirror-linenumber,.CodeMirror-scroll,.CodeMirror-sizer{-moz-box-sizing:content-box;box-sizing:content-box}.CodeMirror-measure{position:absolute;width:100%;height:0;overflow:hidden;visibility:hidden}.CodeMirror-cursor{position:absolute;pointer-events:none}.CodeMirror-measure pre{position:static}div.CodeMirror-cursors{visibility:hidden;position:relative;z-index:3}div.CodeMirror-dragcursors{visibility:visible}.CodeMirror-focused div.CodeMirror-cursors{visibility:visible}.CodeMirror-selected{background:#d9d9d9}.CodeMirror-focused .CodeMirror-selected{background:#d7d4f0}.CodeMirror-crosshair{cursor:crosshair}.CodeMirror-line::selection,.CodeMirror-line>span::selection,.CodeMirror-line>span>span::selection{background:#d7d4f0}.CodeMirror-line::-moz-selection,.CodeMirror-line>span::-moz-selection,.CodeMirror-line>span>span::-moz-selection{background:#d7d4f0}.cm-searching{background-color:#ffa;background-color:rgba(255,255,0,.4)}.cm-force-border{padding-right:.1px}@media print{.CodeMirror div.CodeMirror-cursors{visibility:hidden}}.cm-tab-wrap-hack:after{content:''}span.CodeMirror-selectedtext{background:0 0}
/*# sourceMappingURL=codemirror.min.css.map */

      .severity-low {
  background-color: #669603;
}

.severity-low:after {
  content : 'L';
}

.severity-unspecified {
  background-color: #666666;
}

.severity-unspecified:after {
  content : 'U';
}

.severity-style {
  background-color: #9932cc;
}

.severity-style:after {
  content : 'S';
}

.severity-medium {
  background-color: #a9d323;
  color: black;
}

.severity-medium:after {
  content : 'M';
}

.severity-high {
  background-color: #ffa800;
}

.severity-high:after {
  content : 'H';
}

.severity-critical {
  background-color: #e92625;
}

.severity-critical:after {
  content : 'C';
}

i[class*="severity-"] {
  line-height: normal;
  text-transform: capitalize;
  font-size: 0.8em;
  font-weight: bold;
  color: white;
  display: inline-block;
  width: 16px;
  height: 16px;
  text-align: center;
  font-family: sans-serif;
}

      html, body {
  width: 100%;
  height: 100%;
  padding: 0px;
  margin: 0px;
}

div.container {
  padding: 10px;
}

#content {
  height: 100%;
  display: block;
  overflow: hidden;
}

#content > div {
  margin: 10px;
  overflow: hidden;
  border: 1px solid #ddd;
  border-radius: 3px;
  overflow: hidden;
  height: 97%;
}

.button {
  background-color: #f1f1f1;
  text-decoration: none;
  display: inline-block;
  padding: 8px 16px;
  color: black;
  cursor: pointer;
}

.button:hover {
  background-color: #ddd;
  color: black;
}

.review-status {
  color: white;
  text-align: center;
}

.review-status-confirmed {
  background-color: #e92625;
}

.review-status-false-positive {
  background-color: grey;
}

.review-status-intentional {
  background-color: #669603;
}

      div.container {
  width: 100%;
  height: 100%;
  padding: 0px;
}

#editor-wrapper {
  margin: 10px;
}

#side-bar {
  float: left;
  width: 260px;
  margin: 0px;
}

#report-nav ul {
  list-style-type: none;
  padding: 0;
  margin: 0;
  overflow-y: auto;
  height: 100%;
}

#report-nav ul > li {
  padding: .4em;
  background-color: #fff;
  border-bottom: 1px solid rgba(0,0,0,.125);
  text-align: left;
  overflow: hidden;
  white-space: nowrap;
  text-overflow: ellipsis;
}

#report-nav ul > li.active {
  background-color: #427ea9;
  color: white;
}

#report-nav ul > li:hover {
  background-color: #427ea9;
  color: white;
  cursor: pointer;
}

#report-nav ul a {
  text-decoration: none;
}

#report-nav i[class*="severity-"] {
  margin-right: 5px;
}

.header {
  border-bottom: 1px solid lightgrey;
  font-family: monospace;
  padding: 10px;
  background-color: #fafbfc;
  border-bottom: 1px solid #e1e4e8;
  border-top-left-radius: 2px;
  border-top-right-radius: 2px;
}

#report-nav .header {
  font-weight: bold;
}

#editor-wrapper .header > div {
  padding-top: 2px;
}

#file-path,
#checker-name {
  color: #195ea2;
}

#review-status {
  padding: 0px 5px;
}

#file-path {
  font-family: monospace;
}

.check-msg {
  display: inline-block;
  padding: 3px 6px;
  margin: 1px;
  -webkit-border-radius: 5px;
  -moz-border-radius: 5px;
  border-radius: 5px;
}

.check-msg.info {
  color: #00546f;
  background-color: #bfdfe9;
  border: 1px solid #87a8b3;
}

.check-msg.error {
  background-color: #f2dede;
  color: #a94442;
  border: 1px solid #ebcccc;
}

.check-msg.macro {
  background-color: #d7dac2;
  color: #4f5c6d;
  border: 1px solid #d7dac2;
}

.check-msg.note {
  background-color: #d7d7d7;
  color: #4f5c6d;
  border: 1px solid #bfbfbf;
}

.check-msg.current {
  border: 2px dashed #3692ff;
}

.check-msg .tag {
  padding: 1px 5px;
  text-align: center;
  border-radius: 2px;
  margin-right: 5px;
  text-decoration: inherit;
}

.check-msg .tag.macro {
  background-color: #83876a;
  color: white;
  text-transform: capitalize;
}

.check-msg .tag.note {
  background-color: #9299a1;
  color: white;
  text-transform: capitalize;
}

.checker-enum {
  color: white;
  padding: 1px 5px;
  text-align: center;
  border-radius: 25px;
  margin-right: 5px;
  text-decoration: inherit;
}

.checker-enum.info {
  background-color: #427ea9;
}

.checker-enum.error {
  background-color: #a94442;
}

.arrow {
  border: solid black;
  border-width: 0 3px 3px 0;
  display: inline-block;
  padding: 3px;
  cursor: pointer;
  margin: 0px 5px;
}

.arrow:hover {
  border: solid #437ea8;
  border-width: 0 3px 3px 0;
}

.left-arrow {
  transform: rotate(135deg);
  -webkit-transform: rotate(135deg);
}

.right-arrow {
  transform: rotate(-45deg);
  -webkit-transform: rotate(-45deg);
}

    </style>

    <script type="text/javascript">
      function setNonCompatibleBrowserMessage() {
  document.body.innerHTML =
    '<h2 style="margin-left: 20px;">Your browser is not compatible with CodeChecker Viewer!</h2> \
     <p style="margin-left: 20px;">The version required for the following browsers are:</p> \
     <ul style="margin-left: 20px;"> \
     <li>Internet Explorer: version 9 or newer</li> \
     <li>Firefox: version 22.0 or newer</li> \
     </ul>';
}

// http://stackoverflow.com/questions/5916900/how-can-you-detect-the-version-of-a-browser
var browserVersion = (function(){
  var ua = navigator.userAgent, tem,
    M = ua.match(/(opera|chrome|safari|firefox|msie|trident(?=\/))\/?\s*(\d+)/i) || [];

  if (/trident/i.test(M[1])) {
    tem = /\brv[ :]+(\d+)/g.exec(ua) || [];
    return 'IE ' + (tem[1] || '');
  }

  if (M[1] === 'Chrome') {
    tem = ua.match(/\b(OPR|Edge)\/(\d+)/);
    if (tem != null) return tem.slice(1).join(' ').replace('OPR', 'Opera');
  }

  M = M[2] ? [M[1], M[2]] : [navigator.appName, navigator.appVersion, '-?'];
  if ((tem = ua.match(/version\/(\d+)/i)) != null) M.splice(1, 1, tem[1]);
    return M.join(' ');
})();

var pos = browserVersion.indexOf(' ');
var browser = browserVersion.substr(0, pos);
var version = parseInt(browserVersion.substr(pos + 1));

var browserCompatible
  = browser === 'Firefox'
  ? version >= 22
  : browser === 'IE'
  ? version >= 9
  : true;


      /* MIT License

Copyright (C) 2017 by Marijn Haverbeke <marijnh@gmail.com> and others

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
 */
      !function(e,t){"object"==typeof exports&&"undefined"!=typeof module?module.exports=t():"function"==typeof define&&define.amd?define(t):e.CodeMirror=t()}(this,function(){"use strict";function e(e){return new RegExp("(^|\\s)"+e+"(?:$|\\s)\\s*")}function t(e){for(var t=e.childNodes.length;t>0;--t)e.removeChild(e.firstChild);return e}function r(e,r){return t(e).appendChild(r)}function n(e,t,r,n){var i=document.createElement(e);if(r&&(i.className=r),n&&(i.style.cssText=n),"string"==typeof t)i.appendChild(document.createTextNode(t));else if(t)for(var o=0;o<t.length;++o)i.appendChild(t[o]);return i}function i(e,t,r,i){var o=n(e,t,r,i);return o.setAttribute("role","presentation"),o}function o(e,t){if(3==t.nodeType&&(t=t.parentNode),e.contains)return e.contains(t);do{if(11==t.nodeType&&(t=t.host),t==e)return!0}while(t=t.parentNode)}function l(){var e;try{e=document.activeElement}catch(t){e=document.body||null}for(;e&&e.shadowRoot&&e.shadowRoot.activeElement;)e=e.shadowRoot.activeElement;return e}function s(t,r){var n=t.className;e(r).test(n)||(t.className+=(n?" ":"")+r)}function a(t,r){for(var n=t.split(" "),i=0;i<n.length;i++)n[i]&&!e(n[i]).test(r)&&(r+=" "+n[i]);return r}function u(e){var t=Array.prototype.slice.call(arguments,1);return function(){return e.apply(null,t)}}function c(e,t,r){t||(t={});for(var n in e)!e.hasOwnProperty(n)||!1===r&&t.hasOwnProperty(n)||(t[n]=e[n]);return t}function f(e,t,r,n,i){null==t&&-1==(t=e.search(/[^\s\u00a0]/))&&(t=e.length);for(var o=n||0,l=i||0;;){var s=e.indexOf("\t",o);if(s<0||s>=t)return l+(t-o);l+=s-o,l+=r-l%r,o=s+1}}function h(e,t){for(var r=0;r<e.length;++r)if(e[r]==t)return r;return-1}function d(e,t,r){for(var n=0,i=0;;){var o=e.indexOf("\t",n);-1==o&&(o=e.length);var l=o-n;if(o==e.length||i+l>=t)return n+Math.min(l,t-i);if(i+=o-n,i+=r-i%r,n=o+1,i>=t)return n}}function p(e){for(;Kl.length<=e;)Kl.push(g(Kl)+" ");return Kl[e]}function g(e){return e[e.length-1]}function v(e,t){for(var r=[],n=0;n<e.length;n++)r[n]=t(e[n],n);return r}function m(e,t,r){for(var n=0,i=r(t);n<e.length&&r(e[n])<=i;)n++;e.splice(n,0,t)}function y(){}function b(e,t){var r;return Object.create?r=Object.create(e):(y.prototype=e,r=new y),t&&c(t,r),r}function w(e){return/\w/.test(e)||e>""&&(e.toUpperCase()!=e.toLowerCase()||jl.test(e))}function x(e,t){return t?!!(t.source.indexOf("\\w")>-1&&w(e))||t.test(e):w(e)}function C(e){for(var t in e)if(e.hasOwnProperty(t)&&e[t])return!1;return!0}function S(e){return e.charCodeAt(0)>=768&&Xl.test(e)}function L(e,t,r){for(;(r<0?t>0:t<e.length)&&S(e.charAt(t));)t+=r;return t}function k(e,t,r){for(var n=t>r?-1:1;;){if(t==r)return t;var i=(t+r)/2,o=n<0?Math.ceil(i):Math.floor(i);if(o==t)return e(o)?t:r;e(o)?r=o:t=o+n}}function T(e,t,r){var o=this;this.input=r,o.scrollbarFiller=n("div",null,"CodeMirror-scrollbar-filler"),o.scrollbarFiller.setAttribute("cm-not-content","true"),o.gutterFiller=n("div",null,"CodeMirror-gutter-filler"),o.gutterFiller.setAttribute("cm-not-content","true"),o.lineDiv=i("div",null,"CodeMirror-code"),o.selectionDiv=n("div",null,null,"position: relative; z-index: 1"),o.cursorDiv=n("div",null,"CodeMirror-cursors"),o.measure=n("div",null,"CodeMirror-measure"),o.lineMeasure=n("div",null,"CodeMirror-measure"),o.lineSpace=i("div",[o.measure,o.lineMeasure,o.selectionDiv,o.cursorDiv,o.lineDiv],null,"position: relative; outline: none");var l=i("div",[o.lineSpace],"CodeMirror-lines");o.mover=n("div",[l],null,"position: relative"),o.sizer=n("div",[o.mover],"CodeMirror-sizer"),o.sizerWidth=null,o.heightForcer=n("div",null,null,"position: absolute; height: "+Rl+"px; width: 1px;"),o.gutters=n("div",null,"CodeMirror-gutters"),o.lineGutter=null,o.scroller=n("div",[o.sizer,o.heightForcer,o.gutters],"CodeMirror-scroll"),o.scroller.setAttribute("tabIndex","-1"),o.wrapper=n("div",[o.scrollbarFiller,o.gutterFiller,o.scroller],"CodeMirror"),gl&&vl<8&&(o.gutters.style.zIndex=-1,o.scroller.style.paddingRight=0),ml||fl&&Tl||(o.scroller.draggable=!0),e&&(e.appendChild?e.appendChild(o.wrapper):e(o.wrapper)),o.viewFrom=o.viewTo=t.first,o.reportedViewFrom=o.reportedViewTo=t.first,o.view=[],o.renderedView=null,o.externalMeasured=null,o.viewOffset=0,o.lastWrapHeight=o.lastWrapWidth=0,o.updateLineNumbers=null,o.nativeBarWidth=o.barHeight=o.barWidth=0,o.scrollbarsClipped=!1,o.lineNumWidth=o.lineNumInnerWidth=o.lineNumChars=null,o.alignWidgets=!1,o.cachedCharWidth=o.cachedTextHeight=o.cachedPaddingH=null,o.maxLine=null,o.maxLineLength=0,o.maxLineChanged=!1,o.wheelDX=o.wheelDY=o.wheelStartX=o.wheelStartY=null,o.shift=!1,o.selForContextMenu=null,o.activeTouch=null,r.init(o)}function M(e,t){if((t-=e.first)<0||t>=e.size)throw new Error("There is no line "+(t+e.first)+" in the document.");for(var r=e;!r.lines;)for(var n=0;;++n){var i=r.children[n],o=i.chunkSize();if(t<o){r=i;break}t-=o}return r.lines[t]}function N(e,t,r){var n=[],i=t.line;return e.iter(t.line,r.line+1,function(e){var o=e.text;i==r.line&&(o=o.slice(0,r.ch)),i==t.line&&(o=o.slice(t.ch)),n.push(o),++i}),n}function O(e,t,r){var n=[];return e.iter(t,r,function(e){n.push(e.text)}),n}function A(e,t){var r=t-e.height;if(r)for(var n=e;n;n=n.parent)n.height+=r}function W(e){if(null==e.parent)return null;for(var t=e.parent,r=h(t.lines,e),n=t.parent;n;t=n,n=n.parent)for(var i=0;n.children[i]!=t;++i)r+=n.children[i].chunkSize();return r+t.first}function D(e,t){var r=e.first;e:do{for(var n=0;n<e.children.length;++n){var i=e.children[n],o=i.height;if(t<o){e=i;continue e}t-=o,r+=i.chunkSize()}return r}while(!e.lines);for(var l=0;l<e.lines.length;++l){var s=e.lines[l].height;if(t<s)break;t-=s}return r+l}function H(e,t){return t>=e.first&&t<e.first+e.size}function F(e,t){return String(e.lineNumberFormatter(t+e.firstLineNumber))}function E(e,t,r){if(void 0===r&&(r=null),!(this instanceof E))return new E(e,t,r);this.line=e,this.ch=t,this.sticky=r}function P(e,t){return e.line-t.line||e.ch-t.ch}function I(e,t){return e.sticky==t.sticky&&0==P(e,t)}function z(e){return E(e.line,e.ch)}function R(e,t){return P(e,t)<0?t:e}function B(e,t){return P(e,t)<0?e:t}function G(e,t){return Math.max(e.first,Math.min(t,e.first+e.size-1))}function U(e,t){if(t.line<e.first)return E(e.first,0);var r=e.first+e.size-1;return t.line>r?E(r,M(e,r).text.length):V(t,M(e,t.line).text.length)}function V(e,t){var r=e.ch;return null==r||r>t?E(e.line,t):r<0?E(e.line,0):e}function K(e,t){for(var r=[],n=0;n<t.length;n++)r[n]=U(e,t[n]);return r}function j(){Yl=!0}function X(){_l=!0}function Y(e,t,r){this.marker=e,this.from=t,this.to=r}function _(e,t){if(e)for(var r=0;r<e.length;++r){var n=e[r];if(n.marker==t)return n}}function $(e,t){for(var r,n=0;n<e.length;++n)e[n]!=t&&(r||(r=[])).push(e[n]);return r}function q(e,t){e.markedSpans=e.markedSpans?e.markedSpans.concat([t]):[t],t.marker.attachLine(e)}function Z(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t)||o.from==t&&"bookmark"==l.type&&(!r||!o.marker.insertLeft)){var s=null==o.to||(l.inclusiveRight?o.to>=t:o.to>t);(n||(n=[])).push(new Y(l,o.from,s?null:o.to))}}return n}function Q(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.to||(l.inclusiveRight?o.to>=t:o.to>t)||o.from==t&&"bookmark"==l.type&&(!r||o.marker.insertLeft)){var s=null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t);(n||(n=[])).push(new Y(l,s?null:o.from-t,null==o.to?null:o.to-t))}}return n}function J(e,t){if(t.full)return null;var r=H(e,t.from.line)&&M(e,t.from.line).markedSpans,n=H(e,t.to.line)&&M(e,t.to.line).markedSpans;if(!r&&!n)return null;var i=t.from.ch,o=t.to.ch,l=0==P(t.from,t.to),s=Z(r,i,l),a=Q(n,o,l),u=1==t.text.length,c=g(t.text).length+(u?i:0);if(s)for(var f=0;f<s.length;++f){var h=s[f];if(null==h.to){var d=_(a,h.marker);d?u&&(h.to=null==d.to?null:d.to+c):h.to=i}}if(a)for(var p=0;p<a.length;++p){var v=a[p];null!=v.to&&(v.to+=c),null==v.from?_(s,v.marker)||(v.from=c,u&&(s||(s=[])).push(v)):(v.from+=c,u&&(s||(s=[])).push(v))}s&&(s=ee(s)),a&&a!=s&&(a=ee(a));var m=[s];if(!u){var y,b=t.text.length-2;if(b>0&&s)for(var w=0;w<s.length;++w)null==s[w].to&&(y||(y=[])).push(new Y(s[w].marker,null,null));for(var x=0;x<b;++x)m.push(y);m.push(a)}return m}function ee(e){for(var t=0;t<e.length;++t){var r=e[t];null!=r.from&&r.from==r.to&&!1!==r.marker.clearWhenEmpty&&e.splice(t--,1)}return e.length?e:null}function te(e,t,r){var n=null;if(e.iter(t.line,r.line+1,function(e){if(e.markedSpans)for(var t=0;t<e.markedSpans.length;++t){var r=e.markedSpans[t].marker;!r.readOnly||n&&-1!=h(n,r)||(n||(n=[])).push(r)}}),!n)return null;for(var i=[{from:t,to:r}],o=0;o<n.length;++o)for(var l=n[o],s=l.find(0),a=0;a<i.length;++a){var u=i[a];if(!(P(u.to,s.from)<0||P(u.from,s.to)>0)){var c=[a,1],f=P(u.from,s.from),d=P(u.to,s.to);(f<0||!l.inclusiveLeft&&!f)&&c.push({from:u.from,to:s.from}),(d>0||!l.inclusiveRight&&!d)&&c.push({from:s.to,to:u.to}),i.splice.apply(i,c),a+=c.length-3}}return i}function re(e){var t=e.markedSpans;if(t){for(var r=0;r<t.length;++r)t[r].marker.detachLine(e);e.markedSpans=null}}function ne(e,t){if(t){for(var r=0;r<t.length;++r)t[r].marker.attachLine(e);e.markedSpans=t}}function ie(e){return e.inclusiveLeft?-1:0}function oe(e){return e.inclusiveRight?1:0}function le(e,t){var r=e.lines.length-t.lines.length;if(0!=r)return r;var n=e.find(),i=t.find(),o=P(n.from,i.from)||ie(e)-ie(t);if(o)return-o;var l=P(n.to,i.to)||oe(e)-oe(t);return l||t.id-e.id}function se(e,t){var r,n=_l&&e.markedSpans;if(n)for(var i=void 0,o=0;o<n.length;++o)(i=n[o]).marker.collapsed&&null==(t?i.from:i.to)&&(!r||le(r,i.marker)<0)&&(r=i.marker);return r}function ae(e){return se(e,!0)}function ue(e){return se(e,!1)}function ce(e,t,r,n,i){var o=M(e,t),l=_l&&o.markedSpans;if(l)for(var s=0;s<l.length;++s){var a=l[s];if(a.marker.collapsed){var u=a.marker.find(0),c=P(u.from,r)||ie(a.marker)-ie(i),f=P(u.to,n)||oe(a.marker)-oe(i);if(!(c>=0&&f<=0||c<=0&&f>=0)&&(c<=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.to,r)>=0:P(u.to,r)>0)||c>=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.from,n)<=0:P(u.from,n)<0)))return!0}}}function fe(e){for(var t;t=ae(e);)e=t.find(-1,!0).line;return e}function he(e){for(var t;t=ue(e);)e=t.find(1,!0).line;return e}function de(e){for(var t,r;t=ue(e);)e=t.find(1,!0).line,(r||(r=[])).push(e);return r}function pe(e,t){var r=M(e,t),n=fe(r);return r==n?t:W(n)}function ge(e,t){if(t>e.lastLine())return t;var r,n=M(e,t);if(!ve(e,n))return t;for(;r=ue(n);)n=r.find(1,!0).line;return W(n)+1}function ve(e,t){var r=_l&&t.markedSpans;if(r)for(var n=void 0,i=0;i<r.length;++i)if((n=r[i]).marker.collapsed){if(null==n.from)return!0;if(!n.marker.widgetNode&&0==n.from&&n.marker.inclusiveLeft&&me(e,t,n))return!0}}function me(e,t,r){if(null==r.to){var n=r.marker.find(1,!0);return me(e,n.line,_(n.line.markedSpans,r.marker))}if(r.marker.inclusiveRight&&r.to==t.text.length)return!0;for(var i=void 0,o=0;o<t.markedSpans.length;++o)if((i=t.markedSpans[o]).marker.collapsed&&!i.marker.widgetNode&&i.from==r.to&&(null==i.to||i.to!=r.from)&&(i.marker.inclusiveLeft||r.marker.inclusiveRight)&&me(e,t,i))return!0}function ye(e){for(var t=0,r=(e=fe(e)).parent,n=0;n<r.lines.length;++n){var i=r.lines[n];if(i==e)break;t+=i.height}for(var o=r.parent;o;r=o,o=r.parent)for(var l=0;l<o.children.length;++l){var s=o.children[l];if(s==r)break;t+=s.height}return t}function be(e){if(0==e.height)return 0;for(var t,r=e.text.length,n=e;t=ae(n);){var i=t.find(0,!0);n=i.from.line,r+=i.from.ch-i.to.ch}for(n=e;t=ue(n);){var o=t.find(0,!0);r-=n.text.length-o.from.ch,r+=(n=o.to.line).text.length-o.to.ch}return r}function we(e){var t=e.display,r=e.doc;t.maxLine=M(r,r.first),t.maxLineLength=be(t.maxLine),t.maxLineChanged=!0,r.iter(function(e){var r=be(e);r>t.maxLineLength&&(t.maxLineLength=r,t.maxLine=e)})}function xe(e,t,r,n){if(!e)return n(t,r,"ltr",0);for(var i=!1,o=0;o<e.length;++o){var l=e[o];(l.from<r&&l.to>t||t==r&&l.to==t)&&(n(Math.max(l.from,t),Math.min(l.to,r),1==l.level?"rtl":"ltr",o),i=!0)}i||n(t,r,"ltr")}function Ce(e,t,r){var n;$l=null;for(var i=0;i<e.length;++i){var o=e[i];if(o.from<t&&o.to>t)return i;o.to==t&&(o.from!=o.to&&"before"==r?n=i:$l=i),o.from==t&&(o.from!=o.to&&"before"!=r?n=i:$l=i)}return null!=n?n:$l}function Se(e,t){var r=e.order;return null==r&&(r=e.order=ql(e.text,t)),r}function Le(e,t){return e._handlers&&e._handlers[t]||Zl}function ke(e,t,r){if(e.removeEventListener)e.removeEventListener(t,r,!1);else if(e.detachEvent)e.detachEvent("on"+t,r);else{var n=e._handlers,i=n&&n[t];if(i){var o=h(i,r);o>-1&&(n[t]=i.slice(0,o).concat(i.slice(o+1)))}}}function Te(e,t){var r=Le(e,t);if(r.length)for(var n=Array.prototype.slice.call(arguments,2),i=0;i<r.length;++i)r[i].apply(null,n)}function Me(e,t,r){return"string"==typeof t&&(t={type:t,preventDefault:function(){this.defaultPrevented=!0}}),Te(e,r||t.type,e,t),He(t)||t.codemirrorIgnore}function Ne(e){var t=e._handlers&&e._handlers.cursorActivity;if(t)for(var r=e.curOp.cursorActivityHandlers||(e.curOp.cursorActivityHandlers=[]),n=0;n<t.length;++n)-1==h(r,t[n])&&r.push(t[n])}function Oe(e,t){return Le(e,t).length>0}function Ae(e){e.prototype.on=function(e,t){Ql(this,e,t)},e.prototype.off=function(e,t){ke(this,e,t)}}function We(e){e.preventDefault?e.preventDefault():e.returnValue=!1}function De(e){e.stopPropagation?e.stopPropagation():e.cancelBubble=!0}function He(e){return null!=e.defaultPrevented?e.defaultPrevented:0==e.returnValue}function Fe(e){We(e),De(e)}function Ee(e){return e.target||e.srcElement}function Pe(e){var t=e.which;return null==t&&(1&e.button?t=1:2&e.button?t=3:4&e.button&&(t=2)),Ml&&e.ctrlKey&&1==t&&(t=3),t}function Ie(e){if(null==Il){var t=n("span","​");r(e,n("span",[t,document.createTextNode("x")])),0!=e.firstChild.offsetHeight&&(Il=t.offsetWidth<=1&&t.offsetHeight>2&&!(gl&&vl<8))}var i=Il?n("span","​"):n("span"," ",null,"display: inline-block; width: 1px; margin-right: -1px");return i.setAttribute("cm-text",""),i}function ze(e){if(null!=zl)return zl;var n=r(e,document.createTextNode("AخA")),i=Wl(n,0,1).getBoundingClientRect(),o=Wl(n,1,2).getBoundingClientRect();return t(e),!(!i||i.left==i.right)&&(zl=o.right-i.right<3)}function Re(e){if(null!=ns)return ns;var t=r(e,n("span","x")),i=t.getBoundingClientRect(),o=Wl(t,0,1).getBoundingClientRect();return ns=Math.abs(i.left-o.left)>1}function Be(e,t){arguments.length>2&&(t.dependencies=Array.prototype.slice.call(arguments,2)),is[e]=t}function Ge(e){if("string"==typeof e&&os.hasOwnProperty(e))e=os[e];else if(e&&"string"==typeof e.name&&os.hasOwnProperty(e.name)){var t=os[e.name];"string"==typeof t&&(t={name:t}),(e=b(t,e)).name=t.name}else{if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+xml$/.test(e))return Ge("application/xml");if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+json$/.test(e))return Ge("application/json")}return"string"==typeof e?{name:e}:e||{name:"null"}}function Ue(e,t){t=Ge(t);var r=is[t.name];if(!r)return Ue(e,"text/plain");var n=r(e,t);if(ls.hasOwnProperty(t.name)){var i=ls[t.name];for(var o in i)i.hasOwnProperty(o)&&(n.hasOwnProperty(o)&&(n["_"+o]=n[o]),n[o]=i[o])}if(n.name=t.name,t.helperType&&(n.helperType=t.helperType),t.modeProps)for(var l in t.modeProps)n[l]=t.modeProps[l];return n}function Ve(e,t){c(t,ls.hasOwnProperty(e)?ls[e]:ls[e]={})}function Ke(e,t){if(!0===t)return t;if(e.copyState)return e.copyState(t);var r={};for(var n in t){var i=t[n];i instanceof Array&&(i=i.concat([])),r[n]=i}return r}function je(e,t){for(var r;e.innerMode&&(r=e.innerMode(t))&&r.mode!=e;)t=r.state,e=r.mode;return r||{mode:e,state:t}}function Xe(e,t,r){return!e.startState||e.startState(t,r)}function Ye(e,t,r,n){var i=[e.state.modeGen],o={};tt(e,t.text,e.doc.mode,r,function(e,t){return i.push(e,t)},o,n);for(var l=r.state,s=0;s<e.state.overlays.length;++s)!function(n){var l=e.state.overlays[n],s=1,a=0;r.state=!0,tt(e,t.text,l.mode,r,function(e,t){for(var r=s;a<e;){var n=i[s];n>e&&i.splice(s,1,e,i[s+1],n),s+=2,a=Math.min(e,n)}if(t)if(l.opaque)i.splice(r,s-r,e,"overlay "+t),s=r+2;else for(;r<s;r+=2){var o=i[r+1];i[r+1]=(o?o+" ":"")+"overlay "+t}},o)}(s);return r.state=l,{styles:i,classes:o.bgClass||o.textClass?o:null}}function _e(e,t,r){if(!t.styles||t.styles[0]!=e.state.modeGen){var n=$e(e,W(t)),i=t.text.length>e.options.maxHighlightLength&&Ke(e.doc.mode,n.state),o=Ye(e,t,n);i&&(n.state=i),t.stateAfter=n.save(!i),t.styles=o.styles,o.classes?t.styleClasses=o.classes:t.styleClasses&&(t.styleClasses=null),r===e.doc.highlightFrontier&&(e.doc.modeFrontier=Math.max(e.doc.modeFrontier,++e.doc.highlightFrontier))}return t.styles}function $e(e,t,r){var n=e.doc,i=e.display;if(!n.mode.startState)return new us(n,!0,t);var o=rt(e,t,r),l=o>n.first&&M(n,o-1).stateAfter,s=l?us.fromSaved(n,l,o):new us(n,Xe(n.mode),o);return n.iter(o,t,function(r){qe(e,r.text,s);var n=s.line;r.stateAfter=n==t-1||n%5==0||n>=i.viewFrom&&n<i.viewTo?s.save():null,s.nextLine()}),r&&(n.modeFrontier=s.line),s}function qe(e,t,r,n){var i=e.doc.mode,o=new ss(t,e.options.tabSize,r);for(o.start=o.pos=n||0,""==t&&Ze(i,r.state);!o.eol();)Qe(i,o,r.state),o.start=o.pos}function Ze(e,t){if(e.blankLine)return e.blankLine(t);if(e.innerMode){var r=je(e,t);return r.mode.blankLine?r.mode.blankLine(r.state):void 0}}function Qe(e,t,r,n){for(var i=0;i<10;i++){n&&(n[0]=je(e,r).mode);var o=e.token(t,r);if(t.pos>t.start)return o}throw new Error("Mode "+e.name+" failed to advance stream.")}function Je(e,t,r,n){var i,o,l=e.doc,s=l.mode,a=M(l,(t=U(l,t)).line),u=$e(e,t.line,r),c=new ss(a.text,e.options.tabSize,u);for(n&&(o=[]);(n||c.pos<t.ch)&&!c.eol();)c.start=c.pos,i=Qe(s,c,u.state),n&&o.push(new cs(c,i,Ke(l.mode,u.state)));return n?o:new cs(c,i,u.state)}function et(e,t){if(e)for(;;){var r=e.match(/(?:^|\s+)line-(background-)?(\S+)/);if(!r)break;e=e.slice(0,r.index)+e.slice(r.index+r[0].length);var n=r[1]?"bgClass":"textClass";null==t[n]?t[n]=r[2]:new RegExp("(?:^|s)"+r[2]+"(?:$|s)").test(t[n])||(t[n]+=" "+r[2])}return e}function tt(e,t,r,n,i,o,l){var s=r.flattenSpans;null==s&&(s=e.options.flattenSpans);var a,u=0,c=null,f=new ss(t,e.options.tabSize,n),h=e.options.addModeClass&&[null];for(""==t&&et(Ze(r,n.state),o);!f.eol();){if(f.pos>e.options.maxHighlightLength?(s=!1,l&&qe(e,t,n,f.pos),f.pos=t.length,a=null):a=et(Qe(r,f,n.state,h),o),h){var d=h[0].name;d&&(a="m-"+(a?d+" "+a:d))}if(!s||c!=a){for(;u<f.start;)i(u=Math.min(f.start,u+5e3),c);c=a}f.start=f.pos}for(;u<f.pos;){var p=Math.min(f.pos,u+5e3);i(p,c),u=p}}function rt(e,t,r){for(var n,i,o=e.doc,l=r?-1:t-(e.doc.mode.innerMode?1e3:100),s=t;s>l;--s){if(s<=o.first)return o.first;var a=M(o,s-1),u=a.stateAfter;if(u&&(!r||s+(u instanceof as?u.lookAhead:0)<=o.modeFrontier))return s;var c=f(a.text,null,e.options.tabSize);(null==i||n>c)&&(i=s-1,n=c)}return i}function nt(e,t){if(e.modeFrontier=Math.min(e.modeFrontier,t),!(e.highlightFrontier<t-10)){for(var r=e.first,n=t-1;n>r;n--){var i=M(e,n).stateAfter;if(i&&(!(i instanceof as)||n+i.lookAhead<t)){r=n+1;break}}e.highlightFrontier=Math.min(e.highlightFrontier,r)}}function it(e,t,r,n){e.text=t,e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null),null!=e.order&&(e.order=null),re(e),ne(e,r);var i=n?n(e):1;i!=e.height&&A(e,i)}function ot(e){e.parent=null,re(e)}function lt(e,t){if(!e||/^\s*$/.test(e))return null;var r=t.addModeClass?ps:ds;return r[e]||(r[e]=e.replace(/\S+/g,"cm-$&"))}function st(e,t){var r=i("span",null,null,ml?"padding-right: .1px":null),n={pre:i("pre",[r],"CodeMirror-line"),content:r,col:0,pos:0,cm:e,trailingSpace:!1,splitSpaces:(gl||ml)&&e.getOption("lineWrapping")};t.measure={};for(var o=0;o<=(t.rest?t.rest.length:0);o++){var l=o?t.rest[o-1]:t.line,s=void 0;n.pos=0,n.addToken=ut,ze(e.display.measure)&&(s=Se(l,e.doc.direction))&&(n.addToken=ft(n.addToken,s)),n.map=[],dt(l,n,_e(e,l,t!=e.display.externalMeasured&&W(l))),l.styleClasses&&(l.styleClasses.bgClass&&(n.bgClass=a(l.styleClasses.bgClass,n.bgClass||"")),l.styleClasses.textClass&&(n.textClass=a(l.styleClasses.textClass,n.textClass||""))),0==n.map.length&&n.map.push(0,0,n.content.appendChild(Ie(e.display.measure))),0==o?(t.measure.map=n.map,t.measure.cache={}):((t.measure.maps||(t.measure.maps=[])).push(n.map),(t.measure.caches||(t.measure.caches=[])).push({}))}if(ml){var u=n.content.lastChild;(/\bcm-tab\b/.test(u.className)||u.querySelector&&u.querySelector(".cm-tab"))&&(n.content.className="cm-tab-wrap-hack")}return Te(e,"renderLine",e,t.line,n.pre),n.pre.className&&(n.textClass=a(n.pre.className,n.textClass||"")),n}function at(e){var t=n("span","•","cm-invalidchar");return t.title="\\u"+e.charCodeAt(0).toString(16),t.setAttribute("aria-label",t.title),t}function ut(e,t,r,i,o,l,s){if(t){var a,u=e.splitSpaces?ct(t,e.trailingSpace):t,c=e.cm.state.specialChars,f=!1;if(c.test(t)){a=document.createDocumentFragment();for(var h=0;;){c.lastIndex=h;var d=c.exec(t),g=d?d.index-h:t.length-h;if(g){var v=document.createTextNode(u.slice(h,h+g));gl&&vl<9?a.appendChild(n("span",[v])):a.appendChild(v),e.map.push(e.pos,e.pos+g,v),e.col+=g,e.pos+=g}if(!d)break;h+=g+1;var m=void 0;if("\t"==d[0]){var y=e.cm.options.tabSize,b=y-e.col%y;(m=a.appendChild(n("span",p(b),"cm-tab"))).setAttribute("role","presentation"),m.setAttribute("cm-text","\t"),e.col+=b}else"\r"==d[0]||"\n"==d[0]?((m=a.appendChild(n("span","\r"==d[0]?"␍":"␤","cm-invalidchar"))).setAttribute("cm-text",d[0]),e.col+=1):((m=e.cm.options.specialCharPlaceholder(d[0])).setAttribute("cm-text",d[0]),gl&&vl<9?a.appendChild(n("span",[m])):a.appendChild(m),e.col+=1);e.map.push(e.pos,e.pos+1,m),e.pos++}}else e.col+=t.length,a=document.createTextNode(u),e.map.push(e.pos,e.pos+t.length,a),gl&&vl<9&&(f=!0),e.pos+=t.length;if(e.trailingSpace=32==u.charCodeAt(t.length-1),r||i||o||f||s){var w=r||"";i&&(w+=i),o&&(w+=o);var x=n("span",[a],w,s);return l&&(x.title=l),e.content.appendChild(x)}e.content.appendChild(a)}}function ct(e,t){if(e.length>1&&!/  /.test(e))return e;for(var r=t,n="",i=0;i<e.length;i++){var o=e.charAt(i);" "!=o||!r||i!=e.length-1&&32!=e.charCodeAt(i+1)||(o=" "),n+=o,r=" "==o}return n}function ft(e,t){return function(r,n,i,o,l,s,a){i=i?i+" cm-force-border":"cm-force-border";for(var u=r.pos,c=u+n.length;;){for(var f=void 0,h=0;h<t.length&&!((f=t[h]).to>u&&f.from<=u);h++);if(f.to>=c)return e(r,n,i,o,l,s,a);e(r,n.slice(0,f.to-u),i,o,null,s,a),o=null,n=n.slice(f.to-u),u=f.to}}}function ht(e,t,r,n){var i=!n&&r.widgetNode;i&&e.map.push(e.pos,e.pos+t,i),!n&&e.cm.display.input.needsContentAttribute&&(i||(i=e.content.appendChild(document.createElement("span"))),i.setAttribute("cm-marker",r.id)),i&&(e.cm.display.input.setUneditable(i),e.content.appendChild(i)),e.pos+=t,e.trailingSpace=!1}function dt(e,t,r){var n=e.markedSpans,i=e.text,o=0;if(n)for(var l,s,a,u,c,f,h,d=i.length,p=0,g=1,v="",m=0;;){if(m==p){a=u=c=f=s="",h=null,m=1/0;for(var y=[],b=void 0,w=0;w<n.length;++w){var x=n[w],C=x.marker;"bookmark"==C.type&&x.from==p&&C.widgetNode?y.push(C):x.from<=p&&(null==x.to||x.to>p||C.collapsed&&x.to==p&&x.from==p)?(null!=x.to&&x.to!=p&&m>x.to&&(m=x.to,u=""),C.className&&(a+=" "+C.className),C.css&&(s=(s?s+";":"")+C.css),C.startStyle&&x.from==p&&(c+=" "+C.startStyle),C.endStyle&&x.to==m&&(b||(b=[])).push(C.endStyle,x.to),C.title&&!f&&(f=C.title),C.collapsed&&(!h||le(h.marker,C)<0)&&(h=x)):x.from>p&&m>x.from&&(m=x.from)}if(b)for(var S=0;S<b.length;S+=2)b[S+1]==m&&(u+=" "+b[S]);if(!h||h.from==p)for(var L=0;L<y.length;++L)ht(t,0,y[L]);if(h&&(h.from||0)==p){if(ht(t,(null==h.to?d+1:h.to)-p,h.marker,null==h.from),null==h.to)return;h.to==p&&(h=!1)}}if(p>=d)break;for(var k=Math.min(d,m);;){if(v){var T=p+v.length;if(!h){var M=T>k?v.slice(0,k-p):v;t.addToken(t,M,l?l+a:a,c,p+M.length==m?u:"",f,s)}if(T>=k){v=v.slice(k-p),p=k;break}p=T,c=""}v=i.slice(o,o=r[g++]),l=lt(r[g++],t.cm.options)}}else for(var N=1;N<r.length;N+=2)t.addToken(t,i.slice(o,o=r[N]),lt(r[N+1],t.cm.options))}function pt(e,t,r){this.line=t,this.rest=de(t),this.size=this.rest?W(g(this.rest))-r+1:1,this.node=this.text=null,this.hidden=ve(e,t)}function gt(e,t,r){for(var n,i=[],o=t;o<r;o=n){var l=new pt(e.doc,M(e.doc,o),o);n=o+l.size,i.push(l)}return i}function vt(e){gs?gs.ops.push(e):e.ownsGroup=gs={ops:[e],delayedCallbacks:[]}}function mt(e){var t=e.delayedCallbacks,r=0;do{for(;r<t.length;r++)t[r].call(null);for(var n=0;n<e.ops.length;n++){var i=e.ops[n];if(i.cursorActivityHandlers)for(;i.cursorActivityCalled<i.cursorActivityHandlers.length;)i.cursorActivityHandlers[i.cursorActivityCalled++].call(null,i.cm)}}while(r<t.length)}function yt(e,t){var r=e.ownsGroup;if(r)try{mt(r)}finally{gs=null,t(r)}}function bt(e,t){var r=Le(e,t);if(r.length){var n,i=Array.prototype.slice.call(arguments,2);gs?n=gs.delayedCallbacks:vs?n=vs:(n=vs=[],setTimeout(wt,0));for(var o=0;o<r.length;++o)!function(e){n.push(function(){return r[e].apply(null,i)})}(o)}}function wt(){var e=vs;vs=null;for(var t=0;t<e.length;++t)e[t]()}function xt(e,t,r,n){for(var i=0;i<t.changes.length;i++){var o=t.changes[i];"text"==o?kt(e,t):"gutter"==o?Mt(e,t,r,n):"class"==o?Tt(e,t):"widget"==o&&Nt(e,t,n)}t.changes=null}function Ct(e){return e.node==e.text&&(e.node=n("div",null,null,"position: relative"),e.text.parentNode&&e.text.parentNode.replaceChild(e.node,e.text),e.node.appendChild(e.text),gl&&vl<8&&(e.node.style.zIndex=2)),e.node}function St(e,t){var r=t.bgClass?t.bgClass+" "+(t.line.bgClass||""):t.line.bgClass;if(r&&(r+=" CodeMirror-linebackground"),t.background)r?t.background.className=r:(t.background.parentNode.removeChild(t.background),t.background=null);else if(r){var i=Ct(t);t.background=i.insertBefore(n("div",null,r),i.firstChild),e.display.input.setUneditable(t.background)}}function Lt(e,t){var r=e.display.externalMeasured;return r&&r.line==t.line?(e.display.externalMeasured=null,t.measure=r.measure,r.built):st(e,t)}function kt(e,t){var r=t.text.className,n=Lt(e,t);t.text==t.node&&(t.node=n.pre),t.text.parentNode.replaceChild(n.pre,t.text),t.text=n.pre,n.bgClass!=t.bgClass||n.textClass!=t.textClass?(t.bgClass=n.bgClass,t.textClass=n.textClass,Tt(e,t)):r&&(t.text.className=r)}function Tt(e,t){St(e,t),t.line.wrapClass?Ct(t).className=t.line.wrapClass:t.node!=t.text&&(t.node.className="");var r=t.textClass?t.textClass+" "+(t.line.textClass||""):t.line.textClass;t.text.className=r||""}function Mt(e,t,r,i){if(t.gutter&&(t.node.removeChild(t.gutter),t.gutter=null),t.gutterBackground&&(t.node.removeChild(t.gutterBackground),t.gutterBackground=null),t.line.gutterClass){var o=Ct(t);t.gutterBackground=n("div",null,"CodeMirror-gutter-background "+t.line.gutterClass,"left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px; width: "+i.gutterTotalWidth+"px"),e.display.input.setUneditable(t.gutterBackground),o.insertBefore(t.gutterBackground,t.text)}var l=t.line.gutterMarkers;if(e.options.lineNumbers||l){var s=Ct(t),a=t.gutter=n("div",null,"CodeMirror-gutter-wrapper","left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px");if(e.display.input.setUneditable(a),s.insertBefore(a,t.text),t.line.gutterClass&&(a.className+=" "+t.line.gutterClass),!e.options.lineNumbers||l&&l["CodeMirror-linenumbers"]||(t.lineNumber=a.appendChild(n("div",F(e.options,r),"CodeMirror-linenumber CodeMirror-gutter-elt","left: "+i.gutterLeft["CodeMirror-linenumbers"]+"px; width: "+e.display.lineNumInnerWidth+"px"))),l)for(var u=0;u<e.options.gutters.length;++u){var c=e.options.gutters[u],f=l.hasOwnProperty(c)&&l[c];f&&a.appendChild(n("div",[f],"CodeMirror-gutter-elt","left: "+i.gutterLeft[c]+"px; width: "+i.gutterWidth[c]+"px"))}}}function Nt(e,t,r){t.alignable&&(t.alignable=null);for(var n=t.node.firstChild,i=void 0;n;n=i)i=n.nextSibling,"CodeMirror-linewidget"==n.className&&t.node.removeChild(n);At(e,t,r)}function Ot(e,t,r,n){var i=Lt(e,t);return t.text=t.node=i.pre,i.bgClass&&(t.bgClass=i.bgClass),i.textClass&&(t.textClass=i.textClass),Tt(e,t),Mt(e,t,r,n),At(e,t,n),t.node}function At(e,t,r){if(Wt(e,t.line,t,r,!0),t.rest)for(var n=0;n<t.rest.length;n++)Wt(e,t.rest[n],t,r,!1)}function Wt(e,t,r,i,o){if(t.widgets)for(var l=Ct(r),s=0,a=t.widgets;s<a.length;++s){var u=a[s],c=n("div",[u.node],"CodeMirror-linewidget");u.handleMouseEvents||c.setAttribute("cm-ignore-events","true"),Dt(u,c,r,i),e.display.input.setUneditable(c),o&&u.above?l.insertBefore(c,r.gutter||r.text):l.appendChild(c),bt(u,"redraw")}}function Dt(e,t,r,n){if(e.noHScroll){(r.alignable||(r.alignable=[])).push(t);var i=n.wrapperWidth;t.style.left=n.fixedPos+"px",e.coverGutter||(i-=n.gutterTotalWidth,t.style.paddingLeft=n.gutterTotalWidth+"px"),t.style.width=i+"px"}e.coverGutter&&(t.style.zIndex=5,t.style.position="relative",e.noHScroll||(t.style.marginLeft=-n.gutterTotalWidth+"px"))}function Ht(e){if(null!=e.height)return e.height;var t=e.doc.cm;if(!t)return 0;if(!o(document.body,e.node)){var i="position: relative;";e.coverGutter&&(i+="margin-left: -"+t.display.gutters.offsetWidth+"px;"),e.noHScroll&&(i+="width: "+t.display.wrapper.clientWidth+"px;"),r(t.display.measure,n("div",[e.node],null,i))}return e.height=e.node.parentNode.offsetHeight}function Ft(e,t){for(var r=Ee(t);r!=e.wrapper;r=r.parentNode)if(!r||1==r.nodeType&&"true"==r.getAttribute("cm-ignore-events")||r.parentNode==e.sizer&&r!=e.mover)return!0}function Et(e){return e.lineSpace.offsetTop}function Pt(e){return e.mover.offsetHeight-e.lineSpace.offsetHeight}function It(e){if(e.cachedPaddingH)return e.cachedPaddingH;var t=r(e.measure,n("pre","x")),i=window.getComputedStyle?window.getComputedStyle(t):t.currentStyle,o={left:parseInt(i.paddingLeft),right:parseInt(i.paddingRight)};return isNaN(o.left)||isNaN(o.right)||(e.cachedPaddingH=o),o}function zt(e){return Rl-e.display.nativeBarWidth}function Rt(e){return e.display.scroller.clientWidth-zt(e)-e.display.barWidth}function Bt(e){return e.display.scroller.clientHeight-zt(e)-e.display.barHeight}function Gt(e,t,r){var n=e.options.lineWrapping,i=n&&Rt(e);if(!t.measure.heights||n&&t.measure.width!=i){var o=t.measure.heights=[];if(n){t.measure.width=i;for(var l=t.text.firstChild.getClientRects(),s=0;s<l.length-1;s++){var a=l[s],u=l[s+1];Math.abs(a.bottom-u.bottom)>2&&o.push((a.bottom+u.top)/2-r.top)}}o.push(r.bottom-r.top)}}function Ut(e,t,r){if(e.line==t)return{map:e.measure.map,cache:e.measure.cache};for(var n=0;n<e.rest.length;n++)if(e.rest[n]==t)return{map:e.measure.maps[n],cache:e.measure.caches[n]};for(var i=0;i<e.rest.length;i++)if(W(e.rest[i])>r)return{map:e.measure.maps[i],cache:e.measure.caches[i],before:!0}}function Vt(e,t){var n=W(t=fe(t)),i=e.display.externalMeasured=new pt(e.doc,t,n);i.lineN=n;var o=i.built=st(e,i);return i.text=o.pre,r(e.display.lineMeasure,o.pre),i}function Kt(e,t,r,n){return Yt(e,Xt(e,t),r,n)}function jt(e,t){if(t>=e.display.viewFrom&&t<e.display.viewTo)return e.display.view[Lr(e,t)];var r=e.display.externalMeasured;return r&&t>=r.lineN&&t<r.lineN+r.size?r:void 0}function Xt(e,t){var r=W(t),n=jt(e,r);n&&!n.text?n=null:n&&n.changes&&(xt(e,n,r,br(e)),e.curOp.forceUpdate=!0),n||(n=Vt(e,t));var i=Ut(n,t,r);return{line:t,view:n,rect:null,map:i.map,cache:i.cache,before:i.before,hasHeights:!1}}function Yt(e,t,r,n,i){t.before&&(r=-1);var o,l=r+(n||"");return t.cache.hasOwnProperty(l)?o=t.cache[l]:(t.rect||(t.rect=t.view.text.getBoundingClientRect()),t.hasHeights||(Gt(e,t.view,t.rect),t.hasHeights=!0),(o=qt(e,t,r,n)).bogus||(t.cache[l]=o)),{left:o.left,right:o.right,top:i?o.rtop:o.top,bottom:i?o.rbottom:o.bottom}}function _t(e,t,r){for(var n,i,o,l,s,a,u=0;u<e.length;u+=3)if(s=e[u],a=e[u+1],t<s?(i=0,o=1,l="left"):t<a?o=(i=t-s)+1:(u==e.length-3||t==a&&e[u+3]>t)&&(i=(o=a-s)-1,t>=a&&(l="right")),null!=i){if(n=e[u+2],s==a&&r==(n.insertLeft?"left":"right")&&(l=r),"left"==r&&0==i)for(;u&&e[u-2]==e[u-3]&&e[u-1].insertLeft;)n=e[2+(u-=3)],l="left";if("right"==r&&i==a-s)for(;u<e.length-3&&e[u+3]==e[u+4]&&!e[u+5].insertLeft;)n=e[(u+=3)+2],l="right";break}return{node:n,start:i,end:o,collapse:l,coverStart:s,coverEnd:a}}function $t(e,t){var r=ms;if("left"==t)for(var n=0;n<e.length&&(r=e[n]).left==r.right;n++);else for(var i=e.length-1;i>=0&&(r=e[i]).left==r.right;i--);return r}function qt(e,t,r,n){var i,o=_t(t.map,r,n),l=o.node,s=o.start,a=o.end,u=o.collapse;if(3==l.nodeType){for(var c=0;c<4;c++){for(;s&&S(t.line.text.charAt(o.coverStart+s));)--s;for(;o.coverStart+a<o.coverEnd&&S(t.line.text.charAt(o.coverStart+a));)++a;if((i=gl&&vl<9&&0==s&&a==o.coverEnd-o.coverStart?l.parentNode.getBoundingClientRect():$t(Wl(l,s,a).getClientRects(),n)).left||i.right||0==s)break;a=s,s-=1,u="right"}gl&&vl<11&&(i=Zt(e.display.measure,i))}else{s>0&&(u=n="right");var f;i=e.options.lineWrapping&&(f=l.getClientRects()).length>1?f["right"==n?f.length-1:0]:l.getBoundingClientRect()}if(gl&&vl<9&&!s&&(!i||!i.left&&!i.right)){var h=l.parentNode.getClientRects()[0];i=h?{left:h.left,right:h.left+yr(e.display),top:h.top,bottom:h.bottom}:ms}for(var d=i.top-t.rect.top,p=i.bottom-t.rect.top,g=(d+p)/2,v=t.view.measure.heights,m=0;m<v.length-1&&!(g<v[m]);m++);var y=m?v[m-1]:0,b=v[m],w={left:("right"==u?i.right:i.left)-t.rect.left,right:("left"==u?i.left:i.right)-t.rect.left,top:y,bottom:b};return i.left||i.right||(w.bogus=!0),e.options.singleCursorHeightPerLine||(w.rtop=d,w.rbottom=p),w}function Zt(e,t){if(!window.screen||null==screen.logicalXDPI||screen.logicalXDPI==screen.deviceXDPI||!Re(e))return t;var r=screen.logicalXDPI/screen.deviceXDPI,n=screen.logicalYDPI/screen.deviceYDPI;return{left:t.left*r,right:t.right*r,top:t.top*n,bottom:t.bottom*n}}function Qt(e){if(e.measure&&(e.measure.cache={},e.measure.heights=null,e.rest))for(var t=0;t<e.rest.length;t++)e.measure.caches[t]={}}function Jt(e){e.display.externalMeasure=null,t(e.display.lineMeasure);for(var r=0;r<e.display.view.length;r++)Qt(e.display.view[r])}function er(e){Jt(e),e.display.cachedCharWidth=e.display.cachedTextHeight=e.display.cachedPaddingH=null,e.options.lineWrapping||(e.display.maxLineChanged=!0),e.display.lineNumChars=null}function tr(){return bl&&kl?-(document.body.getBoundingClientRect().left-parseInt(getComputedStyle(document.body).marginLeft)):window.pageXOffset||(document.documentElement||document.body).scrollLeft}function rr(){return bl&&kl?-(document.body.getBoundingClientRect().top-parseInt(getComputedStyle(document.body).marginTop)):window.pageYOffset||(document.documentElement||document.body).scrollTop}function nr(e){var t=0;if(e.widgets)for(var r=0;r<e.widgets.length;++r)e.widgets[r].above&&(t+=Ht(e.widgets[r]));return t}function ir(e,t,r,n,i){if(!i){var o=nr(t);r.top+=o,r.bottom+=o}if("line"==n)return r;n||(n="local");var l=ye(t);if("local"==n?l+=Et(e.display):l-=e.display.viewOffset,"page"==n||"window"==n){var s=e.display.lineSpace.getBoundingClientRect();l+=s.top+("window"==n?0:rr());var a=s.left+("window"==n?0:tr());r.left+=a,r.right+=a}return r.top+=l,r.bottom+=l,r}function or(e,t,r){if("div"==r)return t;var n=t.left,i=t.top;if("page"==r)n-=tr(),i-=rr();else if("local"==r||!r){var o=e.display.sizer.getBoundingClientRect();n+=o.left,i+=o.top}var l=e.display.lineSpace.getBoundingClientRect();return{left:n-l.left,top:i-l.top}}function lr(e,t,r,n,i){return n||(n=M(e.doc,t.line)),ir(e,n,Kt(e,n,t.ch,i),r)}function sr(e,t,r,n,i,o){function l(t,l){var s=Yt(e,i,t,l?"right":"left",o);return l?s.left=s.right:s.right=s.left,ir(e,n,s,r)}function s(e,t,r){var n=1==a[t].level;return l(r?e-1:e,n!=r)}n=n||M(e.doc,t.line),i||(i=Xt(e,n));var a=Se(n,e.doc.direction),u=t.ch,c=t.sticky;if(u>=n.text.length?(u=n.text.length,c="before"):u<=0&&(u=0,c="after"),!a)return l("before"==c?u-1:u,"before"==c);var f=Ce(a,u,c),h=$l,d=s(u,f,"before"==c);return null!=h&&(d.other=s(u,h,"before"!=c)),d}function ar(e,t){var r=0;t=U(e.doc,t),e.options.lineWrapping||(r=yr(e.display)*t.ch);var n=M(e.doc,t.line),i=ye(n)+Et(e.display);return{left:r,right:r,top:i,bottom:i+n.height}}function ur(e,t,r,n,i){var o=E(e,t,r);return o.xRel=i,n&&(o.outside=!0),o}function cr(e,t,r){var n=e.doc;if((r+=e.display.viewOffset)<0)return ur(n.first,0,null,!0,-1);var i=D(n,r),o=n.first+n.size-1;if(i>o)return ur(n.first+n.size-1,M(n,o).text.length,null,!0,1);t<0&&(t=0);for(var l=M(n,i);;){var s=pr(e,l,i,t,r),a=ue(l),u=a&&a.find(0,!0);if(!a||!(s.ch>u.from.ch||s.ch==u.from.ch&&s.xRel>0))return s;i=W(l=u.to.line)}}function fr(e,t,r,n){n-=nr(t);var i=t.text.length,o=k(function(t){return Yt(e,r,t-1).bottom<=n},i,0);return i=k(function(t){return Yt(e,r,t).top>n},o,i),{begin:o,end:i}}function hr(e,t,r,n){return r||(r=Xt(e,t)),fr(e,t,r,ir(e,t,Yt(e,r,n),"line").top)}function dr(e,t,r,n){return!(e.bottom<=r)&&(e.top>r||(n?e.left:e.right)>t)}function pr(e,t,r,n,i){i-=ye(t);var o=Xt(e,t),l=nr(t),s=0,a=t.text.length,u=!0,c=Se(t,e.doc.direction);if(c){var f=(e.options.lineWrapping?vr:gr)(e,t,r,o,c,n,i);s=(u=1!=f.level)?f.from:f.to-1,a=u?f.to:f.from-1}var h,d,p=null,g=null,v=k(function(t){var r=Yt(e,o,t);return r.top+=l,r.bottom+=l,!!dr(r,n,i,!1)&&(r.top<=i&&r.left<=n&&(p=t,g=r),!0)},s,a),m=!1;if(g){var y=n-g.left<g.right-n,b=y==u;v=p+(b?0:1),d=b?"after":"before",h=y?g.left:g.right}else{u||v!=a&&v!=s||v++,d=0==v?"after":v==t.text.length?"before":Yt(e,o,v-(u?1:0)).bottom+l<=i==u?"after":"before";var w=sr(e,E(r,v,d),"line",t,o);h=w.left,m=i<w.top||i>=w.bottom}return v=L(t.text,v,1),ur(r,v,d,m,n-h)}function gr(e,t,r,n,i,o,l){var s=k(function(s){var a=i[s],u=1!=a.level;return dr(sr(e,E(r,u?a.to:a.from,u?"before":"after"),"line",t,n),o,l,!0)},0,i.length-1),a=i[s];if(s>0){var u=1!=a.level,c=sr(e,E(r,u?a.from:a.to,u?"after":"before"),"line",t,n);dr(c,o,l,!0)&&c.top>l&&(a=i[s-1])}return a}function vr(e,t,r,n,i,o,l){for(var s=fr(e,t,n,l),a=s.begin,u=s.end,c=null,f=null,h=0;h<i.length;h++){var d=i[h];if(!(d.from>=u||d.to<=a)){var p=Yt(e,n,1!=d.level?Math.min(u,d.to)-1:Math.max(a,d.from)).right,g=p<o?o-p+1e9:p-o;(!c||f>g)&&(c=d,f=g)}}return c||(c=i[i.length-1]),c.from<a&&(c={from:a,to:c.to,level:c.level}),c.to>u&&(c={from:c.from,to:u,level:c.level}),c}function mr(e){if(null!=e.cachedTextHeight)return e.cachedTextHeight;if(null==hs){hs=n("pre");for(var i=0;i<49;++i)hs.appendChild(document.createTextNode("x")),hs.appendChild(n("br"));hs.appendChild(document.createTextNode("x"))}r(e.measure,hs);var o=hs.offsetHeight/50;return o>3&&(e.cachedTextHeight=o),t(e.measure),o||1}function yr(e){if(null!=e.cachedCharWidth)return e.cachedCharWidth;var t=n("span","xxxxxxxxxx"),i=n("pre",[t]);r(e.measure,i);var o=t.getBoundingClientRect(),l=(o.right-o.left)/10;return l>2&&(e.cachedCharWidth=l),l||10}function br(e){for(var t=e.display,r={},n={},i=t.gutters.clientLeft,o=t.gutters.firstChild,l=0;o;o=o.nextSibling,++l)r[e.options.gutters[l]]=o.offsetLeft+o.clientLeft+i,n[e.options.gutters[l]]=o.clientWidth;return{fixedPos:wr(t),gutterTotalWidth:t.gutters.offsetWidth,gutterLeft:r,gutterWidth:n,wrapperWidth:t.wrapper.clientWidth}}function wr(e){return e.scroller.getBoundingClientRect().left-e.sizer.getBoundingClientRect().left}function xr(e){var t=mr(e.display),r=e.options.lineWrapping,n=r&&Math.max(5,e.display.scroller.clientWidth/yr(e.display)-3);return function(i){if(ve(e.doc,i))return 0;var o=0;if(i.widgets)for(var l=0;l<i.widgets.length;l++)i.widgets[l].height&&(o+=i.widgets[l].height);return r?o+(Math.ceil(i.text.length/n)||1)*t:o+t}}function Cr(e){var t=e.doc,r=xr(e);t.iter(function(e){var t=r(e);t!=e.height&&A(e,t)})}function Sr(e,t,r,n){var i=e.display;if(!r&&"true"==Ee(t).getAttribute("cm-not-content"))return null;var o,l,s=i.lineSpace.getBoundingClientRect();try{o=t.clientX-s.left,l=t.clientY-s.top}catch(t){return null}var a,u=cr(e,o,l);if(n&&1==u.xRel&&(a=M(e.doc,u.line).text).length==u.ch){var c=f(a,a.length,e.options.tabSize)-a.length;u=E(u.line,Math.max(0,Math.round((o-It(e.display).left)/yr(e.display))-c))}return u}function Lr(e,t){if(t>=e.display.viewTo)return null;if((t-=e.display.viewFrom)<0)return null;for(var r=e.display.view,n=0;n<r.length;n++)if((t-=r[n].size)<0)return n}function kr(e){e.display.input.showSelection(e.display.input.prepareSelection())}function Tr(e,t){void 0===t&&(t=!0);for(var r=e.doc,n={},i=n.cursors=document.createDocumentFragment(),o=n.selection=document.createDocumentFragment(),l=0;l<r.sel.ranges.length;l++)if(t||l!=r.sel.primIndex){var s=r.sel.ranges[l];if(!(s.from().line>=e.display.viewTo||s.to().line<e.display.viewFrom)){var a=s.empty();(a||e.options.showCursorWhenSelecting)&&Mr(e,s.head,i),a||Or(e,s,o)}}return n}function Mr(e,t,r){var i=sr(e,t,"div",null,null,!e.options.singleCursorHeightPerLine),o=r.appendChild(n("div"," ","CodeMirror-cursor"));if(o.style.left=i.left+"px",o.style.top=i.top+"px",o.style.height=Math.max(0,i.bottom-i.top)*e.options.cursorHeight+"px",i.other){var l=r.appendChild(n("div"," ","CodeMirror-cursor CodeMirror-secondarycursor"));l.style.display="",l.style.left=i.other.left+"px",l.style.top=i.other.top+"px",l.style.height=.85*(i.other.bottom-i.other.top)+"px"}}function Nr(e,t){return e.top-t.top||e.left-t.left}function Or(e,t,r){function i(e,t,r,i){t<0&&(t=0),t=Math.round(t),i=Math.round(i),a.appendChild(n("div",null,"CodeMirror-selected","position: absolute; left: "+e+"px;\n                             top: "+t+"px; width: "+(null==r?f-e:r)+"px;\n                             height: "+(i-t)+"px"))}function o(t,r,n){function o(r,n){return lr(e,E(t,r),"div",u,n)}var l,a,u=M(s,t),h=u.text.length,d=Se(u,s.direction);return xe(d,r||0,null==n?h:n,function(t,s,p,g){var v=o(t,"ltr"==p?"left":"right"),m=o(s-1,"ltr"==p?"right":"left");if("ltr"==p){var y=null==r&&0==t?c:v.left,b=null==n&&s==h?f:m.right;m.top-v.top<=3?i(y,m.top,b-y,m.bottom):(i(y,v.top,null,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top),i(c,m.top,m.right,m.bottom))}else if(t<s){var w=null==r&&0==t?f:v.right,x=null==n&&s==h?c:m.left;if(m.top-v.top<=3)i(x,m.top,w-x,m.bottom);else{var C=c;if(g){var S=hr(e,u,null,t).end;C=o(S-(/\s/.test(u.text.charAt(S-1))?2:1),"left").left}i(C,v.top,w-C,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top);var L=null;d.length,L=o(hr(e,u,null,s).begin,"right").right-x,i(x,m.top,L,m.bottom)}}(!l||Nr(v,l)<0)&&(l=v),Nr(m,l)<0&&(l=m),(!a||Nr(v,a)<0)&&(a=v),Nr(m,a)<0&&(a=m)}),{start:l,end:a}}var l=e.display,s=e.doc,a=document.createDocumentFragment(),u=It(e.display),c=u.left,f=Math.max(l.sizerWidth,Rt(e)-l.sizer.offsetLeft)-u.right,h=t.from(),d=t.to();if(h.line==d.line)o(h.line,h.ch,d.ch);else{var p=M(s,h.line),g=M(s,d.line),v=fe(p)==fe(g),m=o(h.line,h.ch,v?p.text.length+1:null).end,y=o(d.line,v?0:null,d.ch).start;v&&(m.top<y.top-2?(i(m.right,m.top,null,m.bottom),i(c,y.top,y.left,y.bottom)):i(m.right,m.top,y.left-m.right,m.bottom)),m.bottom<y.top&&i(c,m.bottom,null,y.top)}r.appendChild(a)}function Ar(e){if(e.state.focused){var t=e.display;clearInterval(t.blinker);var r=!0;t.cursorDiv.style.visibility="",e.options.cursorBlinkRate>0?t.blinker=setInterval(function(){return t.cursorDiv.style.visibility=(r=!r)?"":"hidden"},e.options.cursorBlinkRate):e.options.cursorBlinkRate<0&&(t.cursorDiv.style.visibility="hidden")}}function Wr(e){e.state.focused||(e.display.input.focus(),Hr(e))}function Dr(e){e.state.delayingBlurEvent=!0,setTimeout(function(){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1,Fr(e))},100)}function Hr(e,t){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1),"nocursor"!=e.options.readOnly&&(e.state.focused||(Te(e,"focus",e,t),e.state.focused=!0,s(e.display.wrapper,"CodeMirror-focused"),e.curOp||e.display.selForContextMenu==e.doc.sel||(e.display.input.reset(),ml&&setTimeout(function(){return e.display.input.reset(!0)},20)),e.display.input.receivedFocus()),Ar(e))}function Fr(e,t){e.state.delayingBlurEvent||(e.state.focused&&(Te(e,"blur",e,t),e.state.focused=!1,Fl(e.display.wrapper,"CodeMirror-focused")),clearInterval(e.display.blinker),setTimeout(function(){e.state.focused||(e.display.shift=!1)},150))}function Er(e){for(var t=e.display,r=t.lineDiv.offsetTop,n=0;n<t.view.length;n++){var i=t.view[n],o=void 0;if(!i.hidden){if(gl&&vl<8){var l=i.node.offsetTop+i.node.offsetHeight;o=l-r,r=l}else{var s=i.node.getBoundingClientRect();o=s.bottom-s.top}var a=i.line.height-o;if(o<2&&(o=mr(t)),(a>.005||a<-.005)&&(A(i.line,o),Pr(i.line),i.rest))for(var u=0;u<i.rest.length;u++)Pr(i.rest[u])}}}function Pr(e){if(e.widgets)for(var t=0;t<e.widgets.length;++t)e.widgets[t].height=e.widgets[t].node.parentNode.offsetHeight}function Ir(e,t,r){var n=r&&null!=r.top?Math.max(0,r.top):e.scroller.scrollTop;n=Math.floor(n-Et(e));var i=r&&null!=r.bottom?r.bottom:n+e.wrapper.clientHeight,o=D(t,n),l=D(t,i);if(r&&r.ensure){var s=r.ensure.from.line,a=r.ensure.to.line;s<o?(o=s,l=D(t,ye(M(t,s))+e.wrapper.clientHeight)):Math.min(a,t.lastLine())>=l&&(o=D(t,ye(M(t,a))-e.wrapper.clientHeight),l=a)}return{from:o,to:Math.max(l,o+1)}}function zr(e){var t=e.display,r=t.view;if(t.alignWidgets||t.gutters.firstChild&&e.options.fixedGutter){for(var n=wr(t)-t.scroller.scrollLeft+e.doc.scrollLeft,i=t.gutters.offsetWidth,o=n+"px",l=0;l<r.length;l++)if(!r[l].hidden){e.options.fixedGutter&&(r[l].gutter&&(r[l].gutter.style.left=o),r[l].gutterBackground&&(r[l].gutterBackground.style.left=o));var s=r[l].alignable;if(s)for(var a=0;a<s.length;a++)s[a].style.left=o}e.options.fixedGutter&&(t.gutters.style.left=n+i+"px")}}function Rr(e){if(!e.options.lineNumbers)return!1;var t=e.doc,r=F(e.options,t.first+t.size-1),i=e.display;if(r.length!=i.lineNumChars){var o=i.measure.appendChild(n("div",[n("div",r)],"CodeMirror-linenumber CodeMirror-gutter-elt")),l=o.firstChild.offsetWidth,s=o.offsetWidth-l;return i.lineGutter.style.width="",i.lineNumInnerWidth=Math.max(l,i.lineGutter.offsetWidth-s)+1,i.lineNumWidth=i.lineNumInnerWidth+s,i.lineNumChars=i.lineNumInnerWidth?r.length:-1,i.lineGutter.style.width=i.lineNumWidth+"px",Wn(e),!0}return!1}function Br(e,t){if(!Me(e,"scrollCursorIntoView")){var r=e.display,i=r.sizer.getBoundingClientRect(),o=null;if(t.top+i.top<0?o=!0:t.bottom+i.top>(window.innerHeight||document.documentElement.clientHeight)&&(o=!1),null!=o&&!Sl){var l=n("div","​",null,"position: absolute;\n                         top: "+(t.top-r.viewOffset-Et(e.display))+"px;\n                         height: "+(t.bottom-t.top+zt(e)+r.barHeight)+"px;\n                         left: "+t.left+"px; width: "+Math.max(2,t.right-t.left)+"px;");e.display.lineSpace.appendChild(l),l.scrollIntoView(o),e.display.lineSpace.removeChild(l)}}}function Gr(e,t,r,n){null==n&&(n=0);var i;e.options.lineWrapping||t!=r||(r="before"==(t=t.ch?E(t.line,"before"==t.sticky?t.ch-1:t.ch,"after"):t).sticky?E(t.line,t.ch+1,"before"):t);for(var o=0;o<5;o++){var l=!1,s=sr(e,t),a=r&&r!=t?sr(e,r):s,u=Vr(e,i={left:Math.min(s.left,a.left),top:Math.min(s.top,a.top)-n,right:Math.max(s.left,a.left),bottom:Math.max(s.bottom,a.bottom)+n}),c=e.doc.scrollTop,f=e.doc.scrollLeft;if(null!=u.scrollTop&&(qr(e,u.scrollTop),Math.abs(e.doc.scrollTop-c)>1&&(l=!0)),null!=u.scrollLeft&&(Qr(e,u.scrollLeft),Math.abs(e.doc.scrollLeft-f)>1&&(l=!0)),!l)break}return i}function Ur(e,t){var r=Vr(e,t);null!=r.scrollTop&&qr(e,r.scrollTop),null!=r.scrollLeft&&Qr(e,r.scrollLeft)}function Vr(e,t){var r=e.display,n=mr(e.display);t.top<0&&(t.top=0);var i=e.curOp&&null!=e.curOp.scrollTop?e.curOp.scrollTop:r.scroller.scrollTop,o=Bt(e),l={};t.bottom-t.top>o&&(t.bottom=t.top+o);var s=e.doc.height+Pt(r),a=t.top<n,u=t.bottom>s-n;if(t.top<i)l.scrollTop=a?0:t.top;else if(t.bottom>i+o){var c=Math.min(t.top,(u?s:t.bottom)-o);c!=i&&(l.scrollTop=c)}var f=e.curOp&&null!=e.curOp.scrollLeft?e.curOp.scrollLeft:r.scroller.scrollLeft,h=Rt(e)-(e.options.fixedGutter?r.gutters.offsetWidth:0),d=t.right-t.left>h;return d&&(t.right=t.left+h),t.left<10?l.scrollLeft=0:t.left<f?l.scrollLeft=Math.max(0,t.left-(d?0:10)):t.right>h+f-3&&(l.scrollLeft=t.right+(d?0:10)-h),l}function Kr(e,t){null!=t&&(_r(e),e.curOp.scrollTop=(null==e.curOp.scrollTop?e.doc.scrollTop:e.curOp.scrollTop)+t)}function jr(e){_r(e);var t=e.getCursor();e.curOp.scrollToPos={from:t,to:t,margin:e.options.cursorScrollMargin}}function Xr(e,t,r){null==t&&null==r||_r(e),null!=t&&(e.curOp.scrollLeft=t),null!=r&&(e.curOp.scrollTop=r)}function Yr(e,t){_r(e),e.curOp.scrollToPos=t}function _r(e){var t=e.curOp.scrollToPos;t&&(e.curOp.scrollToPos=null,$r(e,ar(e,t.from),ar(e,t.to),t.margin))}function $r(e,t,r,n){var i=Vr(e,{left:Math.min(t.left,r.left),top:Math.min(t.top,r.top)-n,right:Math.max(t.right,r.right),bottom:Math.max(t.bottom,r.bottom)+n});Xr(e,i.scrollLeft,i.scrollTop)}function qr(e,t){Math.abs(e.doc.scrollTop-t)<2||(fl||On(e,{top:t}),Zr(e,t,!0),fl&&On(e),Cn(e,100))}function Zr(e,t,r){t=Math.min(e.display.scroller.scrollHeight-e.display.scroller.clientHeight,t),(e.display.scroller.scrollTop!=t||r)&&(e.doc.scrollTop=t,e.display.scrollbars.setScrollTop(t),e.display.scroller.scrollTop!=t&&(e.display.scroller.scrollTop=t))}function Qr(e,t,r,n){t=Math.min(t,e.display.scroller.scrollWidth-e.display.scroller.clientWidth),(r?t==e.doc.scrollLeft:Math.abs(e.doc.scrollLeft-t)<2)&&!n||(e.doc.scrollLeft=t,zr(e),e.display.scroller.scrollLeft!=t&&(e.display.scroller.scrollLeft=t),e.display.scrollbars.setScrollLeft(t))}function Jr(e){var t=e.display,r=t.gutters.offsetWidth,n=Math.round(e.doc.height+Pt(e.display));return{clientHeight:t.scroller.clientHeight,viewHeight:t.wrapper.clientHeight,scrollWidth:t.scroller.scrollWidth,clientWidth:t.scroller.clientWidth,viewWidth:t.wrapper.clientWidth,barLeft:e.options.fixedGutter?r:0,docHeight:n,scrollHeight:n+zt(e)+t.barHeight,nativeBarWidth:t.nativeBarWidth,gutterWidth:r}}function en(e,t){t||(t=Jr(e));var r=e.display.barWidth,n=e.display.barHeight;tn(e,t);for(var i=0;i<4&&r!=e.display.barWidth||n!=e.display.barHeight;i++)r!=e.display.barWidth&&e.options.lineWrapping&&Er(e),tn(e,Jr(e)),r=e.display.barWidth,n=e.display.barHeight}function tn(e,t){var r=e.display,n=r.scrollbars.update(t);r.sizer.style.paddingRight=(r.barWidth=n.right)+"px",r.sizer.style.paddingBottom=(r.barHeight=n.bottom)+"px",r.heightForcer.style.borderBottom=n.bottom+"px solid transparent",n.right&&n.bottom?(r.scrollbarFiller.style.display="block",r.scrollbarFiller.style.height=n.bottom+"px",r.scrollbarFiller.style.width=n.right+"px"):r.scrollbarFiller.style.display="",n.bottom&&e.options.coverGutterNextToScrollbar&&e.options.fixedGutter?(r.gutterFiller.style.display="block",r.gutterFiller.style.height=n.bottom+"px",r.gutterFiller.style.width=t.gutterWidth+"px"):r.gutterFiller.style.display=""}function rn(e){e.display.scrollbars&&(e.display.scrollbars.clear(),e.display.scrollbars.addClass&&Fl(e.display.wrapper,e.display.scrollbars.addClass)),e.display.scrollbars=new ws[e.options.scrollbarStyle](function(t){e.display.wrapper.insertBefore(t,e.display.scrollbarFiller),Ql(t,"mousedown",function(){e.state.focused&&setTimeout(function(){return e.display.input.focus()},0)}),t.setAttribute("cm-not-content","true")},function(t,r){"horizontal"==r?Qr(e,t):qr(e,t)},e),e.display.scrollbars.addClass&&s(e.display.wrapper,e.display.scrollbars.addClass)}function nn(e){e.curOp={cm:e,viewChanged:!1,startHeight:e.doc.height,forceUpdate:!1,updateInput:null,typing:!1,changeObjs:null,cursorActivityHandlers:null,cursorActivityCalled:0,selectionChanged:!1,updateMaxLine:!1,scrollLeft:null,scrollTop:null,scrollToPos:null,focus:!1,id:++xs},vt(e.curOp)}function on(e){yt(e.curOp,function(e){for(var t=0;t<e.ops.length;t++)e.ops[t].cm.curOp=null;ln(e)})}function ln(e){for(var t=e.ops,r=0;r<t.length;r++)sn(t[r]);for(var n=0;n<t.length;n++)an(t[n]);for(var i=0;i<t.length;i++)un(t[i]);for(var o=0;o<t.length;o++)cn(t[o]);for(var l=0;l<t.length;l++)fn(t[l])}function sn(e){var t=e.cm,r=t.display;Ln(t),e.updateMaxLine&&we(t),e.mustUpdate=e.viewChanged||e.forceUpdate||null!=e.scrollTop||e.scrollToPos&&(e.scrollToPos.from.line<r.viewFrom||e.scrollToPos.to.line>=r.viewTo)||r.maxLineChanged&&t.options.lineWrapping,e.update=e.mustUpdate&&new Cs(t,e.mustUpdate&&{top:e.scrollTop,ensure:e.scrollToPos},e.forceUpdate)}function an(e){e.updatedDisplay=e.mustUpdate&&Mn(e.cm,e.update)}function un(e){var t=e.cm,r=t.display;e.updatedDisplay&&Er(t),e.barMeasure=Jr(t),r.maxLineChanged&&!t.options.lineWrapping&&(e.adjustWidthTo=Kt(t,r.maxLine,r.maxLine.text.length).left+3,t.display.sizerWidth=e.adjustWidthTo,e.barMeasure.scrollWidth=Math.max(r.scroller.clientWidth,r.sizer.offsetLeft+e.adjustWidthTo+zt(t)+t.display.barWidth),e.maxScrollLeft=Math.max(0,r.sizer.offsetLeft+e.adjustWidthTo-Rt(t))),(e.updatedDisplay||e.selectionChanged)&&(e.preparedSelection=r.input.prepareSelection())}function cn(e){var t=e.cm;null!=e.adjustWidthTo&&(t.display.sizer.style.minWidth=e.adjustWidthTo+"px",e.maxScrollLeft<t.doc.scrollLeft&&Qr(t,Math.min(t.display.scroller.scrollLeft,e.maxScrollLeft),!0),t.display.maxLineChanged=!1);var r=e.focus&&e.focus==l();e.preparedSelection&&t.display.input.showSelection(e.preparedSelection,r),(e.updatedDisplay||e.startHeight!=t.doc.height)&&en(t,e.barMeasure),e.updatedDisplay&&Dn(t,e.barMeasure),e.selectionChanged&&Ar(t),t.state.focused&&e.updateInput&&t.display.input.reset(e.typing),r&&Wr(e.cm)}function fn(e){var t=e.cm,r=t.display,n=t.doc;e.updatedDisplay&&Nn(t,e.update),null==r.wheelStartX||null==e.scrollTop&&null==e.scrollLeft&&!e.scrollToPos||(r.wheelStartX=r.wheelStartY=null),null!=e.scrollTop&&Zr(t,e.scrollTop,e.forceScroll),null!=e.scrollLeft&&Qr(t,e.scrollLeft,!0,!0),e.scrollToPos&&Br(t,Gr(t,U(n,e.scrollToPos.from),U(n,e.scrollToPos.to),e.scrollToPos.margin));var i=e.maybeHiddenMarkers,o=e.maybeUnhiddenMarkers;if(i)for(var l=0;l<i.length;++l)i[l].lines.length||Te(i[l],"hide");if(o)for(var s=0;s<o.length;++s)o[s].lines.length&&Te(o[s],"unhide");r.wrapper.offsetHeight&&(n.scrollTop=t.display.scroller.scrollTop),e.changeObjs&&Te(t,"changes",t,e.changeObjs),e.update&&e.update.finish()}function hn(e,t){if(e.curOp)return t();nn(e);try{return t()}finally{on(e)}}function dn(e,t){return function(){if(e.curOp)return t.apply(e,arguments);nn(e);try{return t.apply(e,arguments)}finally{on(e)}}}function pn(e){return function(){if(this.curOp)return e.apply(this,arguments);nn(this);try{return e.apply(this,arguments)}finally{on(this)}}}function gn(e){return function(){var t=this.cm;if(!t||t.curOp)return e.apply(this,arguments);nn(t);try{return e.apply(this,arguments)}finally{on(t)}}}function vn(e,t,r,n){null==t&&(t=e.doc.first),null==r&&(r=e.doc.first+e.doc.size),n||(n=0);var i=e.display;if(n&&r<i.viewTo&&(null==i.updateLineNumbers||i.updateLineNumbers>t)&&(i.updateLineNumbers=t),e.curOp.viewChanged=!0,t>=i.viewTo)_l&&pe(e.doc,t)<i.viewTo&&yn(e);else if(r<=i.viewFrom)_l&&ge(e.doc,r+n)>i.viewFrom?yn(e):(i.viewFrom+=n,i.viewTo+=n);else if(t<=i.viewFrom&&r>=i.viewTo)yn(e);else if(t<=i.viewFrom){var o=bn(e,r,r+n,1);o?(i.view=i.view.slice(o.index),i.viewFrom=o.lineN,i.viewTo+=n):yn(e)}else if(r>=i.viewTo){var l=bn(e,t,t,-1);l?(i.view=i.view.slice(0,l.index),i.viewTo=l.lineN):yn(e)}else{var s=bn(e,t,t,-1),a=bn(e,r,r+n,1);s&&a?(i.view=i.view.slice(0,s.index).concat(gt(e,s.lineN,a.lineN)).concat(i.view.slice(a.index)),i.viewTo+=n):yn(e)}var u=i.externalMeasured;u&&(r<u.lineN?u.lineN+=n:t<u.lineN+u.size&&(i.externalMeasured=null))}function mn(e,t,r){e.curOp.viewChanged=!0;var n=e.display,i=e.display.externalMeasured;if(i&&t>=i.lineN&&t<i.lineN+i.size&&(n.externalMeasured=null),!(t<n.viewFrom||t>=n.viewTo)){var o=n.view[Lr(e,t)];if(null!=o.node){var l=o.changes||(o.changes=[]);-1==h(l,r)&&l.push(r)}}}function yn(e){e.display.viewFrom=e.display.viewTo=e.doc.first,e.display.view=[],e.display.viewOffset=0}function bn(e,t,r,n){var i,o=Lr(e,t),l=e.display.view;if(!_l||r==e.doc.first+e.doc.size)return{index:o,lineN:r};for(var s=e.display.viewFrom,a=0;a<o;a++)s+=l[a].size;if(s!=t){if(n>0){if(o==l.length-1)return null;i=s+l[o].size-t,o++}else i=s-t;t+=i,r+=i}for(;pe(e.doc,r)!=r;){if(o==(n<0?0:l.length-1))return null;r+=n*l[o-(n<0?1:0)].size,o+=n}return{index:o,lineN:r}}function wn(e,t,r){var n=e.display;0==n.view.length||t>=n.viewTo||r<=n.viewFrom?(n.view=gt(e,t,r),n.viewFrom=t):(n.viewFrom>t?n.view=gt(e,t,n.viewFrom).concat(n.view):n.viewFrom<t&&(n.view=n.view.slice(Lr(e,t))),n.viewFrom=t,n.viewTo<r?n.view=n.view.concat(gt(e,n.viewTo,r)):n.viewTo>r&&(n.view=n.view.slice(0,Lr(e,r)))),n.viewTo=r}function xn(e){for(var t=e.display.view,r=0,n=0;n<t.length;n++){var i=t[n];i.hidden||i.node&&!i.changes||++r}return r}function Cn(e,t){e.doc.highlightFrontier<e.display.viewTo&&e.state.highlight.set(t,u(Sn,e))}function Sn(e){var t=e.doc;if(!(t.highlightFrontier>=e.display.viewTo)){var r=+new Date+e.options.workTime,n=$e(e,t.highlightFrontier),i=[];t.iter(n.line,Math.min(t.first+t.size,e.display.viewTo+500),function(o){if(n.line>=e.display.viewFrom){var l=o.styles,s=o.text.length>e.options.maxHighlightLength?Ke(t.mode,n.state):null,a=Ye(e,o,n,!0);s&&(n.state=s),o.styles=a.styles;var u=o.styleClasses,c=a.classes;c?o.styleClasses=c:u&&(o.styleClasses=null);for(var f=!l||l.length!=o.styles.length||u!=c&&(!u||!c||u.bgClass!=c.bgClass||u.textClass!=c.textClass),h=0;!f&&h<l.length;++h)f=l[h]!=o.styles[h];f&&i.push(n.line),o.stateAfter=n.save(),n.nextLine()}else o.text.length<=e.options.maxHighlightLength&&qe(e,o.text,n),o.stateAfter=n.line%5==0?n.save():null,n.nextLine();if(+new Date>r)return Cn(e,e.options.workDelay),!0}),t.highlightFrontier=n.line,t.modeFrontier=Math.max(t.modeFrontier,n.line),i.length&&hn(e,function(){for(var t=0;t<i.length;t++)mn(e,i[t],"text")})}}function Ln(e){var t=e.display;!t.scrollbarsClipped&&t.scroller.offsetWidth&&(t.nativeBarWidth=t.scroller.offsetWidth-t.scroller.clientWidth,t.heightForcer.style.height=zt(e)+"px",t.sizer.style.marginBottom=-t.nativeBarWidth+"px",t.sizer.style.borderRightWidth=zt(e)+"px",t.scrollbarsClipped=!0)}function kn(e){if(e.hasFocus())return null;var t=l();if(!t||!o(e.display.lineDiv,t))return null;var r={activeElt:t};if(window.getSelection){var n=window.getSelection();n.anchorNode&&n.extend&&o(e.display.lineDiv,n.anchorNode)&&(r.anchorNode=n.anchorNode,r.anchorOffset=n.anchorOffset,r.focusNode=n.focusNode,r.focusOffset=n.focusOffset)}return r}function Tn(e){if(e&&e.activeElt&&e.activeElt!=l()&&(e.activeElt.focus(),e.anchorNode&&o(document.body,e.anchorNode)&&o(document.body,e.focusNode))){var t=window.getSelection(),r=document.createRange();r.setEnd(e.anchorNode,e.anchorOffset),r.collapse(!1),t.removeAllRanges(),t.addRange(r),t.extend(e.focusNode,e.focusOffset)}}function Mn(e,r){var n=e.display,i=e.doc;if(r.editorIsHidden)return yn(e),!1;if(!r.force&&r.visible.from>=n.viewFrom&&r.visible.to<=n.viewTo&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo)&&n.renderedView==n.view&&0==xn(e))return!1;Rr(e)&&(yn(e),r.dims=br(e));var o=i.first+i.size,l=Math.max(r.visible.from-e.options.viewportMargin,i.first),s=Math.min(o,r.visible.to+e.options.viewportMargin);n.viewFrom<l&&l-n.viewFrom<20&&(l=Math.max(i.first,n.viewFrom)),n.viewTo>s&&n.viewTo-s<20&&(s=Math.min(o,n.viewTo)),_l&&(l=pe(e.doc,l),s=ge(e.doc,s));var a=l!=n.viewFrom||s!=n.viewTo||n.lastWrapHeight!=r.wrapperHeight||n.lastWrapWidth!=r.wrapperWidth;wn(e,l,s),n.viewOffset=ye(M(e.doc,n.viewFrom)),e.display.mover.style.top=n.viewOffset+"px";var u=xn(e);if(!a&&0==u&&!r.force&&n.renderedView==n.view&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo))return!1;var c=kn(e);return u>4&&(n.lineDiv.style.display="none"),An(e,n.updateLineNumbers,r.dims),u>4&&(n.lineDiv.style.display=""),n.renderedView=n.view,Tn(c),t(n.cursorDiv),t(n.selectionDiv),n.gutters.style.height=n.sizer.style.minHeight=0,a&&(n.lastWrapHeight=r.wrapperHeight,n.lastWrapWidth=r.wrapperWidth,Cn(e,400)),n.updateLineNumbers=null,!0}function Nn(e,t){for(var r=t.viewport,n=!0;(n&&e.options.lineWrapping&&t.oldDisplayWidth!=Rt(e)||(r&&null!=r.top&&(r={top:Math.min(e.doc.height+Pt(e.display)-Bt(e),r.top)}),t.visible=Ir(e.display,e.doc,r),!(t.visible.from>=e.display.viewFrom&&t.visible.to<=e.display.viewTo)))&&Mn(e,t);n=!1){Er(e);var i=Jr(e);kr(e),en(e,i),Dn(e,i),t.force=!1}t.signal(e,"update",e),e.display.viewFrom==e.display.reportedViewFrom&&e.display.viewTo==e.display.reportedViewTo||(t.signal(e,"viewportChange",e,e.display.viewFrom,e.display.viewTo),e.display.reportedViewFrom=e.display.viewFrom,e.display.reportedViewTo=e.display.viewTo)}function On(e,t){var r=new Cs(e,t);if(Mn(e,r)){Er(e),Nn(e,r);var n=Jr(e);kr(e),en(e,n),Dn(e,n),r.finish()}}function An(e,r,n){function i(t){var r=t.nextSibling;return ml&&Ml&&e.display.currentWheelTarget==t?t.style.display="none":t.parentNode.removeChild(t),r}for(var o=e.display,l=e.options.lineNumbers,s=o.lineDiv,a=s.firstChild,u=o.view,c=o.viewFrom,f=0;f<u.length;f++){var d=u[f];if(d.hidden);else if(d.node&&d.node.parentNode==s){for(;a!=d.node;)a=i(a);var p=l&&null!=r&&r<=c&&d.lineNumber;d.changes&&(h(d.changes,"gutter")>-1&&(p=!1),xt(e,d,c,n)),p&&(t(d.lineNumber),d.lineNumber.appendChild(document.createTextNode(F(e.options,c)))),a=d.node.nextSibling}else{var g=Ot(e,d,c,n);s.insertBefore(g,a)}c+=d.size}for(;a;)a=i(a)}function Wn(e){var t=e.display.gutters.offsetWidth;e.display.sizer.style.marginLeft=t+"px"}function Dn(e,t){e.display.sizer.style.minHeight=t.docHeight+"px",e.display.heightForcer.style.top=t.docHeight+"px",e.display.gutters.style.height=t.docHeight+e.display.barHeight+zt(e)+"px"}function Hn(e){var r=e.display.gutters,i=e.options.gutters;t(r);for(var o=0;o<i.length;++o){var l=i[o],s=r.appendChild(n("div",null,"CodeMirror-gutter "+l));"CodeMirror-linenumbers"==l&&(e.display.lineGutter=s,s.style.width=(e.display.lineNumWidth||1)+"px")}r.style.display=o?"":"none",Wn(e)}function Fn(e){var t=h(e.gutters,"CodeMirror-linenumbers");-1==t&&e.lineNumbers?e.gutters=e.gutters.concat(["CodeMirror-linenumbers"]):t>-1&&!e.lineNumbers&&(e.gutters=e.gutters.slice(0),e.gutters.splice(t,1))}function En(e){var t=e.wheelDeltaX,r=e.wheelDeltaY;return null==t&&e.detail&&e.axis==e.HORIZONTAL_AXIS&&(t=e.detail),null==r&&e.detail&&e.axis==e.VERTICAL_AXIS?r=e.detail:null==r&&(r=e.wheelDelta),{x:t,y:r}}function Pn(e){var t=En(e);return t.x*=Ls,t.y*=Ls,t}function In(e,t){var r=En(t),n=r.x,i=r.y,o=e.display,l=o.scroller,s=l.scrollWidth>l.clientWidth,a=l.scrollHeight>l.clientHeight;if(n&&s||i&&a){if(i&&Ml&&ml)e:for(var u=t.target,c=o.view;u!=l;u=u.parentNode)for(var f=0;f<c.length;f++)if(c[f].node==u){e.display.currentWheelTarget=u;break e}if(n&&!fl&&!wl&&null!=Ls)return i&&a&&qr(e,Math.max(0,l.scrollTop+i*Ls)),Qr(e,Math.max(0,l.scrollLeft+n*Ls)),(!i||i&&a)&&We(t),void(o.wheelStartX=null);if(i&&null!=Ls){var h=i*Ls,d=e.doc.scrollTop,p=d+o.wrapper.clientHeight;h<0?d=Math.max(0,d+h-50):p=Math.min(e.doc.height,p+h+50),On(e,{top:d,bottom:p})}Ss<20&&(null==o.wheelStartX?(o.wheelStartX=l.scrollLeft,o.wheelStartY=l.scrollTop,o.wheelDX=n,o.wheelDY=i,setTimeout(function(){if(null!=o.wheelStartX){var e=l.scrollLeft-o.wheelStartX,t=l.scrollTop-o.wheelStartY,r=t&&o.wheelDY&&t/o.wheelDY||e&&o.wheelDX&&e/o.wheelDX;o.wheelStartX=o.wheelStartY=null,r&&(Ls=(Ls*Ss+r)/(Ss+1),++Ss)}},200)):(o.wheelDX+=n,o.wheelDY+=i))}}function zn(e,t){var r=e[t];e.sort(function(e,t){return P(e.from(),t.from())}),t=h(e,r);for(var n=1;n<e.length;n++){var i=e[n],o=e[n-1];if(P(o.to(),i.from())>=0){var l=B(o.from(),i.from()),s=R(o.to(),i.to()),a=o.empty()?i.from()==i.head:o.from()==o.head;n<=t&&--t,e.splice(--n,2,new Ts(a?s:l,a?l:s))}}return new ks(e,t)}function Rn(e,t){return new ks([new Ts(e,t||e)],0)}function Bn(e){return e.text?E(e.from.line+e.text.length-1,g(e.text).length+(1==e.text.length?e.from.ch:0)):e.to}function Gn(e,t){if(P(e,t.from)<0)return e;if(P(e,t.to)<=0)return Bn(t);var r=e.line+t.text.length-(t.to.line-t.from.line)-1,n=e.ch;return e.line==t.to.line&&(n+=Bn(t).ch-t.to.ch),E(r,n)}function Un(e,t){for(var r=[],n=0;n<e.sel.ranges.length;n++){var i=e.sel.ranges[n];r.push(new Ts(Gn(i.anchor,t),Gn(i.head,t)))}return zn(r,e.sel.primIndex)}function Vn(e,t,r){return e.line==t.line?E(r.line,e.ch-t.ch+r.ch):E(r.line+(e.line-t.line),e.ch)}function Kn(e,t,r){for(var n=[],i=E(e.first,0),o=i,l=0;l<t.length;l++){var s=t[l],a=Vn(s.from,i,o),u=Vn(Bn(s),i,o);if(i=s.to,o=u,"around"==r){var c=e.sel.ranges[l],f=P(c.head,c.anchor)<0;n[l]=new Ts(f?u:a,f?a:u)}else n[l]=new Ts(a,a)}return new ks(n,e.sel.primIndex)}function jn(e){e.doc.mode=Ue(e.options,e.doc.modeOption),Xn(e)}function Xn(e){e.doc.iter(function(e){e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null)}),e.doc.modeFrontier=e.doc.highlightFrontier=e.doc.first,Cn(e,100),e.state.modeGen++,e.curOp&&vn(e)}function Yn(e,t){return 0==t.from.ch&&0==t.to.ch&&""==g(t.text)&&(!e.cm||e.cm.options.wholeLineUpdateBefore)}function _n(e,t,r,n){function i(e){return r?r[e]:null}function o(e,r,i){it(e,r,i,n),bt(e,"change",e,t)}function l(e,t){for(var r=[],o=e;o<t;++o)r.push(new fs(u[o],i(o),n));return r}var s=t.from,a=t.to,u=t.text,c=M(e,s.line),f=M(e,a.line),h=g(u),d=i(u.length-1),p=a.line-s.line;if(t.full)e.insert(0,l(0,u.length)),e.remove(u.length,e.size-u.length);else if(Yn(e,t)){var v=l(0,u.length-1);o(f,f.text,d),p&&e.remove(s.line,p),v.length&&e.insert(s.line,v)}else if(c==f)if(1==u.length)o(c,c.text.slice(0,s.ch)+h+c.text.slice(a.ch),d);else{var m=l(1,u.length-1);m.push(new fs(h+c.text.slice(a.ch),d,n)),o(c,c.text.slice(0,s.ch)+u[0],i(0)),e.insert(s.line+1,m)}else if(1==u.length)o(c,c.text.slice(0,s.ch)+u[0]+f.text.slice(a.ch),i(0)),e.remove(s.line+1,p);else{o(c,c.text.slice(0,s.ch)+u[0],i(0)),o(f,h+f.text.slice(a.ch),d);var y=l(1,u.length-1);p>1&&e.remove(s.line+1,p-1),e.insert(s.line+1,y)}bt(e,"change",e,t)}function $n(e,t,r){function n(e,i,o){if(e.linked)for(var l=0;l<e.linked.length;++l){var s=e.linked[l];if(s.doc!=i){var a=o&&s.sharedHist;r&&!a||(t(s.doc,a),n(s.doc,e,a))}}}n(e,null,!0)}function qn(e,t){if(t.cm)throw new Error("This document is already in use.");e.doc=t,t.cm=e,Cr(e),jn(e),Zn(e),e.options.lineWrapping||we(e),e.options.mode=t.modeOption,vn(e)}function Zn(e){("rtl"==e.doc.direction?s:Fl)(e.display.lineDiv,"CodeMirror-rtl")}function Qn(e){hn(e,function(){Zn(e),vn(e)})}function Jn(e){this.done=[],this.undone=[],this.undoDepth=1/0,this.lastModTime=this.lastSelTime=0,this.lastOp=this.lastSelOp=null,this.lastOrigin=this.lastSelOrigin=null,this.generation=this.maxGeneration=e||1}function ei(e,t){var r={from:z(t.from),to:Bn(t),text:N(e,t.from,t.to)};return si(e,r,t.from.line,t.to.line+1),$n(e,function(e){return si(e,r,t.from.line,t.to.line+1)},!0),r}function ti(e){for(;e.length&&g(e).ranges;)e.pop()}function ri(e,t){return t?(ti(e.done),g(e.done)):e.done.length&&!g(e.done).ranges?g(e.done):e.done.length>1&&!e.done[e.done.length-2].ranges?(e.done.pop(),g(e.done)):void 0}function ni(e,t,r,n){var i=e.history;i.undone.length=0;var o,l,s=+new Date;if((i.lastOp==n||i.lastOrigin==t.origin&&t.origin&&("+"==t.origin.charAt(0)&&e.cm&&i.lastModTime>s-e.cm.options.historyEventDelay||"*"==t.origin.charAt(0)))&&(o=ri(i,i.lastOp==n)))l=g(o.changes),0==P(t.from,t.to)&&0==P(t.from,l.to)?l.to=Bn(t):o.changes.push(ei(e,t));else{var a=g(i.done);for(a&&a.ranges||li(e.sel,i.done),o={changes:[ei(e,t)],generation:i.generation},i.done.push(o);i.done.length>i.undoDepth;)i.done.shift(),i.done[0].ranges||i.done.shift()}i.done.push(r),i.generation=++i.maxGeneration,i.lastModTime=i.lastSelTime=s,i.lastOp=i.lastSelOp=n,i.lastOrigin=i.lastSelOrigin=t.origin,l||Te(e,"historyAdded")}function ii(e,t,r,n){var i=t.charAt(0);return"*"==i||"+"==i&&r.ranges.length==n.ranges.length&&r.somethingSelected()==n.somethingSelected()&&new Date-e.history.lastSelTime<=(e.cm?e.cm.options.historyEventDelay:500)}function oi(e,t,r,n){var i=e.history,o=n&&n.origin;r==i.lastSelOp||o&&i.lastSelOrigin==o&&(i.lastModTime==i.lastSelTime&&i.lastOrigin==o||ii(e,o,g(i.done),t))?i.done[i.done.length-1]=t:li(t,i.done),i.lastSelTime=+new Date,i.lastSelOrigin=o,i.lastSelOp=r,n&&!1!==n.clearRedo&&ti(i.undone)}function li(e,t){var r=g(t);r&&r.ranges&&r.equals(e)||t.push(e)}function si(e,t,r,n){var i=t["spans_"+e.id],o=0;e.iter(Math.max(e.first,r),Math.min(e.first+e.size,n),function(r){r.markedSpans&&((i||(i=t["spans_"+e.id]={}))[o]=r.markedSpans),++o})}function ai(e){if(!e)return null;for(var t,r=0;r<e.length;++r)e[r].marker.explicitlyCleared?t||(t=e.slice(0,r)):t&&t.push(e[r]);return t?t.length?t:null:e}function ui(e,t){var r=t["spans_"+e.id];if(!r)return null;for(var n=[],i=0;i<t.text.length;++i)n.push(ai(r[i]));return n}function ci(e,t){var r=ui(e,t),n=J(e,t);if(!r)return n;if(!n)return r;for(var i=0;i<r.length;++i){var o=r[i],l=n[i];if(o&&l)e:for(var s=0;s<l.length;++s){for(var a=l[s],u=0;u<o.length;++u)if(o[u].marker==a.marker)continue e;o.push(a)}else l&&(r[i]=l)}return r}function fi(e,t,r){for(var n=[],i=0;i<e.length;++i){var o=e[i];if(o.ranges)n.push(r?ks.prototype.deepCopy.call(o):o);else{var l=o.changes,s=[];n.push({changes:s});for(var a=0;a<l.length;++a){var u=l[a],c=void 0;if(s.push({from:u.from,to:u.to,text:u.text}),t)for(var f in u)(c=f.match(/^spans_(\d+)$/))&&h(t,Number(c[1]))>-1&&(g(s)[f]=u[f],delete u[f])}}}return n}function hi(e,t,r,n){if(n){var i=e.anchor;if(r){var o=P(t,i)<0;o!=P(r,i)<0?(i=t,t=r):o!=P(t,r)<0&&(t=r)}return new Ts(i,t)}return new Ts(r||t,t)}function di(e,t,r,n,i){null==i&&(i=e.cm&&(e.cm.display.shift||e.extend)),bi(e,new ks([hi(e.sel.primary(),t,r,i)],0),n)}function pi(e,t,r){for(var n=[],i=e.cm&&(e.cm.display.shift||e.extend),o=0;o<e.sel.ranges.length;o++)n[o]=hi(e.sel.ranges[o],t[o],null,i);bi(e,zn(n,e.sel.primIndex),r)}function gi(e,t,r,n){var i=e.sel.ranges.slice(0);i[t]=r,bi(e,zn(i,e.sel.primIndex),n)}function vi(e,t,r,n){bi(e,Rn(t,r),n)}function mi(e,t,r){var n={ranges:t.ranges,update:function(t){var r=this;this.ranges=[];for(var n=0;n<t.length;n++)r.ranges[n]=new Ts(U(e,t[n].anchor),U(e,t[n].head))},origin:r&&r.origin};return Te(e,"beforeSelectionChange",e,n),e.cm&&Te(e.cm,"beforeSelectionChange",e.cm,n),n.ranges!=t.ranges?zn(n.ranges,n.ranges.length-1):t}function yi(e,t,r){var n=e.history.done,i=g(n);i&&i.ranges?(n[n.length-1]=t,wi(e,t,r)):bi(e,t,r)}function bi(e,t,r){wi(e,t,r),oi(e,e.sel,e.cm?e.cm.curOp.id:NaN,r)}function wi(e,t,r){(Oe(e,"beforeSelectionChange")||e.cm&&Oe(e.cm,"beforeSelectionChange"))&&(t=mi(e,t,r)),xi(e,Si(e,t,r&&r.bias||(P(t.primary().head,e.sel.primary().head)<0?-1:1),!0)),r&&!1===r.scroll||!e.cm||jr(e.cm)}function xi(e,t){t.equals(e.sel)||(e.sel=t,e.cm&&(e.cm.curOp.updateInput=e.cm.curOp.selectionChanged=!0,Ne(e.cm)),bt(e,"cursorActivity",e))}function Ci(e){xi(e,Si(e,e.sel,null,!1))}function Si(e,t,r,n){for(var i,o=0;o<t.ranges.length;o++){var l=t.ranges[o],s=t.ranges.length==e.sel.ranges.length&&e.sel.ranges[o],a=ki(e,l.anchor,s&&s.anchor,r,n),u=ki(e,l.head,s&&s.head,r,n);(i||a!=l.anchor||u!=l.head)&&(i||(i=t.ranges.slice(0,o)),i[o]=new Ts(a,u))}return i?zn(i,t.primIndex):t}function Li(e,t,r,n,i){var o=M(e,t.line);if(o.markedSpans)for(var l=0;l<o.markedSpans.length;++l){var s=o.markedSpans[l],a=s.marker;if((null==s.from||(a.inclusiveLeft?s.from<=t.ch:s.from<t.ch))&&(null==s.to||(a.inclusiveRight?s.to>=t.ch:s.to>t.ch))){if(i&&(Te(a,"beforeCursorEnter"),a.explicitlyCleared)){if(o.markedSpans){--l;continue}break}if(!a.atomic)continue;if(r){var u=a.find(n<0?1:-1),c=void 0;if((n<0?a.inclusiveRight:a.inclusiveLeft)&&(u=Ti(e,u,-n,u&&u.line==t.line?o:null)),u&&u.line==t.line&&(c=P(u,r))&&(n<0?c<0:c>0))return Li(e,u,t,n,i)}var f=a.find(n<0?-1:1);return(n<0?a.inclusiveLeft:a.inclusiveRight)&&(f=Ti(e,f,n,f.line==t.line?o:null)),f?Li(e,f,t,n,i):null}}return t}function ki(e,t,r,n,i){var o=n||1,l=Li(e,t,r,o,i)||!i&&Li(e,t,r,o,!0)||Li(e,t,r,-o,i)||!i&&Li(e,t,r,-o,!0);return l||(e.cantEdit=!0,E(e.first,0))}function Ti(e,t,r,n){return r<0&&0==t.ch?t.line>e.first?U(e,E(t.line-1)):null:r>0&&t.ch==(n||M(e,t.line)).text.length?t.line<e.first+e.size-1?E(t.line+1,0):null:new E(t.line,t.ch+r)}function Mi(e){e.setSelection(E(e.firstLine(),0),E(e.lastLine()),Gl)}function Ni(e,t,r){var n={canceled:!1,from:t.from,to:t.to,text:t.text,origin:t.origin,cancel:function(){return n.canceled=!0}};return r&&(n.update=function(t,r,i,o){t&&(n.from=U(e,t)),r&&(n.to=U(e,r)),i&&(n.text=i),void 0!==o&&(n.origin=o)}),Te(e,"beforeChange",e,n),e.cm&&Te(e.cm,"beforeChange",e.cm,n),n.canceled?null:{from:n.from,to:n.to,text:n.text,origin:n.origin}}function Oi(e,t,r){if(e.cm){if(!e.cm.curOp)return dn(e.cm,Oi)(e,t,r);if(e.cm.state.suppressEdits)return}if(!(Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"))||(t=Ni(e,t,!0))){var n=Yl&&!r&&te(e,t.from,t.to);if(n)for(var i=n.length-1;i>=0;--i)Ai(e,{from:n[i].from,to:n[i].to,text:i?[""]:t.text,origin:t.origin});else Ai(e,t)}}function Ai(e,t){if(1!=t.text.length||""!=t.text[0]||0!=P(t.from,t.to)){var r=Un(e,t);ni(e,t,r,e.cm?e.cm.curOp.id:NaN),Hi(e,t,r,J(e,t));var n=[];$n(e,function(e,r){r||-1!=h(n,e.history)||(zi(e.history,t),n.push(e.history)),Hi(e,t,null,J(e,t))})}}function Wi(e,t,r){if(!e.cm||!e.cm.state.suppressEdits||r){for(var n,i=e.history,o=e.sel,l="undo"==t?i.done:i.undone,s="undo"==t?i.undone:i.done,a=0;a<l.length&&(n=l[a],r?!n.ranges||n.equals(e.sel):n.ranges);a++);if(a!=l.length){for(i.lastOrigin=i.lastSelOrigin=null;(n=l.pop()).ranges;){if(li(n,s),r&&!n.equals(e.sel))return void bi(e,n,{clearRedo:!1});o=n}var u=[];li(o,s),s.push({changes:u,generation:i.generation}),i.generation=n.generation||++i.maxGeneration;for(var c=Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"),f=n.changes.length-1;f>=0;--f){var d=function(r){var i=n.changes[r];if(i.origin=t,c&&!Ni(e,i,!1))return l.length=0,{};u.push(ei(e,i));var o=r?Un(e,i):g(l);Hi(e,i,o,ci(e,i)),!r&&e.cm&&e.cm.scrollIntoView({from:i.from,to:Bn(i)});var s=[];$n(e,function(e,t){t||-1!=h(s,e.history)||(zi(e.history,i),s.push(e.history)),Hi(e,i,null,ci(e,i))})}(f);if(d)return d.v}}}}function Di(e,t){if(0!=t&&(e.first+=t,e.sel=new ks(v(e.sel.ranges,function(e){return new Ts(E(e.anchor.line+t,e.anchor.ch),E(e.head.line+t,e.head.ch))}),e.sel.primIndex),e.cm)){vn(e.cm,e.first,e.first-t,t);for(var r=e.cm.display,n=r.viewFrom;n<r.viewTo;n++)mn(e.cm,n,"gutter")}}function Hi(e,t,r,n){if(e.cm&&!e.cm.curOp)return dn(e.cm,Hi)(e,t,r,n);if(t.to.line<e.first)Di(e,t.text.length-1-(t.to.line-t.from.line));else if(!(t.from.line>e.lastLine())){if(t.from.line<e.first){var i=t.text.length-1-(e.first-t.from.line);Di(e,i),t={from:E(e.first,0),to:E(t.to.line+i,t.to.ch),text:[g(t.text)],origin:t.origin}}var o=e.lastLine();t.to.line>o&&(t={from:t.from,to:E(o,M(e,o).text.length),text:[t.text[0]],origin:t.origin}),t.removed=N(e,t.from,t.to),r||(r=Un(e,t)),e.cm?Fi(e.cm,t,n):_n(e,t,n),wi(e,r,Gl)}}function Fi(e,t,r){var n=e.doc,i=e.display,o=t.from,l=t.to,s=!1,a=o.line;e.options.lineWrapping||(a=W(fe(M(n,o.line))),n.iter(a,l.line+1,function(e){if(e==i.maxLine)return s=!0,!0})),n.sel.contains(t.from,t.to)>-1&&Ne(e),_n(n,t,r,xr(e)),e.options.lineWrapping||(n.iter(a,o.line+t.text.length,function(e){var t=be(e);t>i.maxLineLength&&(i.maxLine=e,i.maxLineLength=t,i.maxLineChanged=!0,s=!1)}),s&&(e.curOp.updateMaxLine=!0)),nt(n,o.line),Cn(e,400);var u=t.text.length-(l.line-o.line)-1;t.full?vn(e):o.line!=l.line||1!=t.text.length||Yn(e.doc,t)?vn(e,o.line,l.line+1,u):mn(e,o.line,"text");var c=Oe(e,"changes"),f=Oe(e,"change");if(f||c){var h={from:o,to:l,text:t.text,removed:t.removed,origin:t.origin};f&&bt(e,"change",e,h),c&&(e.curOp.changeObjs||(e.curOp.changeObjs=[])).push(h)}e.display.selForContextMenu=null}function Ei(e,t,r,n,i){if(n||(n=r),P(n,r)<0){var o;r=(o=[n,r])[0],n=o[1]}"string"==typeof t&&(t=e.splitLines(t)),Oi(e,{from:r,to:n,text:t,origin:i})}function Pi(e,t,r,n){r<e.line?e.line+=n:t<e.line&&(e.line=t,e.ch=0)}function Ii(e,t,r,n){for(var i=0;i<e.length;++i){var o=e[i],l=!0;if(o.ranges){o.copied||((o=e[i]=o.deepCopy()).copied=!0);for(var s=0;s<o.ranges.length;s++)Pi(o.ranges[s].anchor,t,r,n),Pi(o.ranges[s].head,t,r,n)}else{for(var a=0;a<o.changes.length;++a){var u=o.changes[a];if(r<u.from.line)u.from=E(u.from.line+n,u.from.ch),u.to=E(u.to.line+n,u.to.ch);else if(t<=u.to.line){l=!1;break}}l||(e.splice(0,i+1),i=0)}}}function zi(e,t){var r=t.from.line,n=t.to.line,i=t.text.length-(n-r)-1;Ii(e.done,r,n,i),Ii(e.undone,r,n,i)}function Ri(e,t,r,n){var i=t,o=t;return"number"==typeof t?o=M(e,G(e,t)):i=W(t),null==i?null:(n(o,i)&&e.cm&&mn(e.cm,i,r),o)}function Bi(e){var t=this;this.lines=e,this.parent=null;for(var r=0,n=0;n<e.length;++n)e[n].parent=t,r+=e[n].height;this.height=r}function Gi(e){var t=this;this.children=e;for(var r=0,n=0,i=0;i<e.length;++i){var o=e[i];r+=o.chunkSize(),n+=o.height,o.parent=t}this.size=r,this.height=n,this.parent=null}function Ui(e,t,r){ye(t)<(e.curOp&&e.curOp.scrollTop||e.doc.scrollTop)&&Kr(e,r)}function Vi(e,t,r,n){var i=new Ms(e,r,n),o=e.cm;return o&&i.noHScroll&&(o.display.alignWidgets=!0),Ri(e,t,"widget",function(t){var r=t.widgets||(t.widgets=[]);if(null==i.insertAt?r.push(i):r.splice(Math.min(r.length-1,Math.max(0,i.insertAt)),0,i),i.line=t,o&&!ve(e,t)){var n=ye(t)<e.scrollTop;A(t,t.height+Ht(i)),n&&Kr(o,i.height),o.curOp.forceUpdate=!0}return!0}),bt(o,"lineWidgetAdded",o,i,"number"==typeof t?t:W(t)),i}function Ki(e,t,r,n,o){if(n&&n.shared)return ji(e,t,r,n,o);if(e.cm&&!e.cm.curOp)return dn(e.cm,Ki)(e,t,r,n,o);var l=new Os(e,o),s=P(t,r);if(n&&c(n,l,!1),s>0||0==s&&!1!==l.clearWhenEmpty)return l;if(l.replacedWith&&(l.collapsed=!0,l.widgetNode=i("span",[l.replacedWith],"CodeMirror-widget"),n.handleMouseEvents||l.widgetNode.setAttribute("cm-ignore-events","true"),n.insertLeft&&(l.widgetNode.insertLeft=!0)),l.collapsed){if(ce(e,t.line,t,r,l)||t.line!=r.line&&ce(e,r.line,t,r,l))throw new Error("Inserting collapsed marker partially overlapping an existing one");X()}l.addToHistory&&ni(e,{from:t,to:r,origin:"markText"},e.sel,NaN);var a,u=t.line,f=e.cm;if(e.iter(u,r.line+1,function(e){f&&l.collapsed&&!f.options.lineWrapping&&fe(e)==f.display.maxLine&&(a=!0),l.collapsed&&u!=t.line&&A(e,0),q(e,new Y(l,u==t.line?t.ch:null,u==r.line?r.ch:null)),++u}),l.collapsed&&e.iter(t.line,r.line+1,function(t){ve(e,t)&&A(t,0)}),l.clearOnEnter&&Ql(l,"beforeCursorEnter",function(){return l.clear()}),l.readOnly&&(j(),(e.history.done.length||e.history.undone.length)&&e.clearHistory()),l.collapsed&&(l.id=++Ns,l.atomic=!0),f){if(a&&(f.curOp.updateMaxLine=!0),l.collapsed)vn(f,t.line,r.line+1);else if(l.className||l.title||l.startStyle||l.endStyle||l.css)for(var h=t.line;h<=r.line;h++)mn(f,h,"text");l.atomic&&Ci(f.doc),bt(f,"markerAdded",f,l)}return l}function ji(e,t,r,n,i){(n=c(n)).shared=!1;var o=[Ki(e,t,r,n,i)],l=o[0],s=n.widgetNode;return $n(e,function(e){s&&(n.widgetNode=s.cloneNode(!0)),o.push(Ki(e,U(e,t),U(e,r),n,i));for(var a=0;a<e.linked.length;++a)if(e.linked[a].isParent)return;l=g(o)}),new As(o,l)}function Xi(e){return e.findMarks(E(e.first,0),e.clipPos(E(e.lastLine())),function(e){return e.parent})}function Yi(e,t){for(var r=0;r<t.length;r++){var n=t[r],i=n.find(),o=e.clipPos(i.from),l=e.clipPos(i.to);if(P(o,l)){var s=Ki(e,o,l,n.primary,n.primary.type);n.markers.push(s),s.parent=n}}}function _i(e){for(var t=0;t<e.length;t++)!function(t){var r=e[t],n=[r.primary.doc];$n(r.primary.doc,function(e){return n.push(e)});for(var i=0;i<r.markers.length;i++){var o=r.markers[i];-1==h(n,o.doc)&&(o.parent=null,r.markers.splice(i--,1))}}(t)}function $i(e){var t=this;if(Qi(t),!Me(t,e)&&!Ft(t.display,e)){We(e),gl&&(Hs=+new Date);var r=Sr(t,e,!0),n=e.dataTransfer.files;if(r&&!t.isReadOnly())if(n&&n.length&&window.FileReader&&window.File)for(var i=n.length,o=Array(i),l=0,s=0;s<i;++s)!function(e,n){if(!t.options.allowDropFileTypes||-1!=h(t.options.allowDropFileTypes,e.type)){var s=new FileReader;s.onload=dn(t,function(){var e=s.result;if(/[\x00-\x08\x0e-\x1f]{2}/.test(e)&&(e=""),o[n]=e,++l==i){var a={from:r=U(t.doc,r),to:r,text:t.doc.splitLines(o.join(t.doc.lineSeparator())),origin:"paste"};Oi(t.doc,a),yi(t.doc,Rn(r,Bn(a)))}}),s.readAsText(e)}}(n[s],s);else{if(t.state.draggingText&&t.doc.sel.contains(r)>-1)return t.state.draggingText(e),void setTimeout(function(){return t.display.input.focus()},20);try{var a=e.dataTransfer.getData("Text");if(a){var u;if(t.state.draggingText&&!t.state.draggingText.copy&&(u=t.listSelections()),wi(t.doc,Rn(r,r)),u)for(var c=0;c<u.length;++c)Ei(t.doc,"",u[c].anchor,u[c].head,"drag");t.replaceSelection(a,"around","paste"),t.display.input.focus()}}catch(e){}}}}function qi(e,t){if(gl&&(!e.state.draggingText||+new Date-Hs<100))Fe(t);else if(!Me(e,t)&&!Ft(e.display,t)&&(t.dataTransfer.setData("Text",e.getSelection()),t.dataTransfer.effectAllowed="copyMove",t.dataTransfer.setDragImage&&!xl)){var r=n("img",null,null,"position: fixed; left: 0; top: 0;");r.src="data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==",wl&&(r.width=r.height=1,e.display.wrapper.appendChild(r),r._top=r.offsetTop),t.dataTransfer.setDragImage(r,0,0),wl&&r.parentNode.removeChild(r)}}function Zi(e,t){var i=Sr(e,t);if(i){var o=document.createDocumentFragment();Mr(e,i,o),e.display.dragCursor||(e.display.dragCursor=n("div",null,"CodeMirror-cursors CodeMirror-dragcursors"),e.display.lineSpace.insertBefore(e.display.dragCursor,e.display.cursorDiv)),r(e.display.dragCursor,o)}}function Qi(e){e.display.dragCursor&&(e.display.lineSpace.removeChild(e.display.dragCursor),e.display.dragCursor=null)}function Ji(e){if(document.getElementsByClassName)for(var t=document.getElementsByClassName("CodeMirror"),r=0;r<t.length;r++){var n=t[r].CodeMirror;n&&e(n)}}function eo(){Fs||(to(),Fs=!0)}function to(){var e;Ql(window,"resize",function(){null==e&&(e=setTimeout(function(){e=null,Ji(ro)},100))}),Ql(window,"blur",function(){return Ji(Fr)})}function ro(e){var t=e.display;t.lastWrapHeight==t.wrapper.clientHeight&&t.lastWrapWidth==t.wrapper.clientWidth||(t.cachedCharWidth=t.cachedTextHeight=t.cachedPaddingH=null,t.scrollbarsClipped=!1,e.setSize())}function no(e){var t=e.split(/-(?!$)/);e=t[t.length-1];for(var r,n,i,o,l=0;l<t.length-1;l++){var s=t[l];if(/^(cmd|meta|m)$/i.test(s))o=!0;else if(/^a(lt)?$/i.test(s))r=!0;else if(/^(c|ctrl|control)$/i.test(s))n=!0;else{if(!/^s(hift)?$/i.test(s))throw new Error("Unrecognized modifier name: "+s);i=!0}}return r&&(e="Alt-"+e),n&&(e="Ctrl-"+e),o&&(e="Cmd-"+e),i&&(e="Shift-"+e),e}function io(e){var t={};for(var r in e)if(e.hasOwnProperty(r)){var n=e[r];if(/^(name|fallthrough|(de|at)tach)$/.test(r))continue;if("..."==n){delete e[r];continue}for(var i=v(r.split(" "),no),o=0;o<i.length;o++){var l=void 0,s=void 0;o==i.length-1?(s=i.join(" "),l=n):(s=i.slice(0,o+1).join(" "),l="...");var a=t[s];if(a){if(a!=l)throw new Error("Inconsistent bindings for "+s)}else t[s]=l}delete e[r]}for(var u in t)e[u]=t[u];return e}function oo(e,t,r,n){var i=(t=uo(t)).call?t.call(e,n):t[e];if(!1===i)return"nothing";if("..."===i)return"multi";if(null!=i&&r(i))return"handled";if(t.fallthrough){if("[object Array]"!=Object.prototype.toString.call(t.fallthrough))return oo(e,t.fallthrough,r,n);for(var o=0;o<t.fallthrough.length;o++){var l=oo(e,t.fallthrough[o],r,n);if(l)return l}}}function lo(e){var t="string"==typeof e?e:Es[e.keyCode];return"Ctrl"==t||"Alt"==t||"Shift"==t||"Mod"==t}function so(e,t,r){var n=e;return t.altKey&&"Alt"!=n&&(e="Alt-"+e),(Dl?t.metaKey:t.ctrlKey)&&"Ctrl"!=n&&(e="Ctrl-"+e),(Dl?t.ctrlKey:t.metaKey)&&"Cmd"!=n&&(e="Cmd-"+e),!r&&t.shiftKey&&"Shift"!=n&&(e="Shift-"+e),e}function ao(e,t){if(wl&&34==e.keyCode&&e.char)return!1;var r=Es[e.keyCode];return null!=r&&!e.altGraphKey&&so(r,e,t)}function uo(e){return"string"==typeof e?Rs[e]:e}function co(e,t){for(var r=e.doc.sel.ranges,n=[],i=0;i<r.length;i++){for(var o=t(r[i]);n.length&&P(o.from,g(n).to)<=0;){var l=n.pop();if(P(l.from,o.from)<0){o.from=l.from;break}}n.push(o)}hn(e,function(){for(var t=n.length-1;t>=0;t--)Ei(e.doc,"",n[t].from,n[t].to,"+delete");jr(e)})}function fo(e,t,r){var n=L(e.text,t+r,r);return n<0||n>e.text.length?null:n}function ho(e,t,r){var n=fo(e,t.ch,r);return null==n?null:new E(t.line,n,r<0?"after":"before")}function po(e,t,r,n,i){if(e){var o=Se(r,t.doc.direction);if(o){var l,s=i<0?g(o):o[0],a=i<0==(1==s.level)?"after":"before";if(s.level>0){var u=Xt(t,r);l=i<0?r.text.length-1:0;var c=Yt(t,u,l).top;l=k(function(e){return Yt(t,u,e).top==c},i<0==(1==s.level)?s.from:s.to-1,l),"before"==a&&(l=fo(r,l,1))}else l=i<0?s.to:s.from;return new E(n,l,a)}}return new E(n,i<0?r.text.length:0,i<0?"before":"after")}function go(e,t,r,n){var i=Se(t,e.doc.direction);if(!i)return ho(t,r,n);r.ch>=t.text.length?(r.ch=t.text.length,r.sticky="before"):r.ch<=0&&(r.ch=0,r.sticky="after");var o=Ce(i,r.ch,r.sticky),l=i[o];if("ltr"==e.doc.direction&&l.level%2==0&&(n>0?l.to>r.ch:l.from<r.ch))return ho(t,r,n);var s,a=function(e,r){return fo(t,e instanceof E?e.ch:e,r)},u=function(r){return e.options.lineWrapping?(s=s||Xt(e,t),hr(e,t,s,r)):{begin:0,end:t.text.length}},c=u("before"==r.sticky?a(r,-1):r.ch);if("rtl"==e.doc.direction||1==l.level){var f=1==l.level==n<0,h=a(r,f?1:-1);if(null!=h&&(f?h<=l.to&&h<=c.end:h>=l.from&&h>=c.begin)){var d=f?"before":"after";return new E(r.line,h,d)}}var p=function(e,t,n){for(var o=function(e,t){return t?new E(r.line,a(e,1),"before"):new E(r.line,e,"after")};e>=0&&e<i.length;e+=t){var l=i[e],s=t>0==(1!=l.level),u=s?n.begin:a(n.end,-1);if(l.from<=u&&u<l.to)return o(u,s);if(u=s?l.from:a(l.to,-1),n.begin<=u&&u<n.end)return o(u,s)}},g=p(o+n,n,c);if(g)return g;var v=n>0?c.end:a(c.begin,-1);return null==v||n>0&&v==t.text.length||!(g=p(n>0?0:i.length-1,n,u(v)))?null:g}function vo(e,t){var r=M(e.doc,t),n=fe(r);return n!=r&&(t=W(n)),po(!0,e,n,t,1)}function mo(e,t){var r=M(e.doc,t),n=he(r);return n!=r&&(t=W(n)),po(!0,e,r,t,-1)}function yo(e,t){var r=vo(e,t.line),n=M(e.doc,r.line),i=Se(n,e.doc.direction);if(!i||0==i[0].level){var o=Math.max(0,n.text.search(/\S/)),l=t.line==r.line&&t.ch<=o&&t.ch;return E(r.line,l?0:o,r.sticky)}return r}function bo(e,t,r){if("string"==typeof t&&!(t=Bs[t]))return!1;e.display.input.ensurePolled();var n=e.display.shift,i=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),r&&(e.display.shift=!1),i=t(e)!=Bl}finally{e.display.shift=n,e.state.suppressEdits=!1}return i}function wo(e,t,r){for(var n=0;n<e.state.keyMaps.length;n++){var i=oo(t,e.state.keyMaps[n],r,e);if(i)return i}return e.options.extraKeys&&oo(t,e.options.extraKeys,r,e)||oo(t,e.options.keyMap,r,e)}function xo(e,t,r,n){var i=e.state.keySeq;if(i){if(lo(t))return"handled";Gs.set(50,function(){e.state.keySeq==i&&(e.state.keySeq=null,e.display.input.reset())}),t=i+" "+t}var o=wo(e,t,n);return"multi"==o&&(e.state.keySeq=t),"handled"==o&&bt(e,"keyHandled",e,t,r),"handled"!=o&&"multi"!=o||(We(r),Ar(e)),i&&!o&&/\'$/.test(t)?(We(r),!0):!!o}function Co(e,t){var r=ao(t,!0);return!!r&&(t.shiftKey&&!e.state.keySeq?xo(e,"Shift-"+r,t,function(t){return bo(e,t,!0)})||xo(e,r,t,function(t){if("string"==typeof t?/^go[A-Z]/.test(t):t.motion)return bo(e,t)}):xo(e,r,t,function(t){return bo(e,t)}))}function So(e,t,r){return xo(e,"'"+r+"'",t,function(t){return bo(e,t,!0)})}function Lo(e){var t=this;if(t.curOp.focus=l(),!Me(t,e)){gl&&vl<11&&27==e.keyCode&&(e.returnValue=!1);var r=e.keyCode;t.display.shift=16==r||e.shiftKey;var n=Co(t,e);wl&&(Us=n?r:null,!n&&88==r&&!rs&&(Ml?e.metaKey:e.ctrlKey)&&t.replaceSelection("",null,"cut")),18!=r||/\bCodeMirror-crosshair\b/.test(t.display.lineDiv.className)||ko(t)}}function ko(e){function t(e){18!=e.keyCode&&e.altKey||(Fl(r,"CodeMirror-crosshair"),ke(document,"keyup",t),ke(document,"mouseover",t))}var r=e.display.lineDiv;s(r,"CodeMirror-crosshair"),Ql(document,"keyup",t),Ql(document,"mouseover",t)}function To(e){16==e.keyCode&&(this.doc.sel.shift=!1),Me(this,e)}function Mo(e){var t=this;if(!(Ft(t.display,e)||Me(t,e)||e.ctrlKey&&!e.altKey||Ml&&e.metaKey)){var r=e.keyCode,n=e.charCode;if(wl&&r==Us)return Us=null,void We(e);if(!wl||e.which&&!(e.which<10)||!Co(t,e)){var i=String.fromCharCode(null==n?r:n);"\b"!=i&&(So(t,e,i)||t.display.input.onKeyPress(e))}}}function No(e,t){var r=+new Date;return js&&js.compare(r,e,t)?(Ks=js=null,"triple"):Ks&&Ks.compare(r,e,t)?(js=new Vs(r,e,t),Ks=null,"double"):(Ks=new Vs(r,e,t),js=null,"single")}function Oo(e){var t=this,r=t.display;if(!(Me(t,e)||r.activeTouch&&r.input.supportsTouch()))if(r.input.ensurePolled(),r.shift=e.shiftKey,Ft(r,e))ml||(r.scroller.draggable=!1,setTimeout(function(){return r.scroller.draggable=!0},100));else if(!zo(t,e)){var n=Sr(t,e),i=Pe(e),o=n?No(n,i):"single";window.focus(),1==i&&t.state.selectingText&&t.state.selectingText(e),n&&Ao(t,i,n,o,e)||(1==i?n?Do(t,n,o,e):Ee(e)==r.scroller&&We(e):2==i?(n&&di(t.doc,n),setTimeout(function(){return r.input.focus()},20)):3==i&&(Hl?Ro(t,e):Dr(t)))}}function Ao(e,t,r,n,i){var o="Click";return"double"==n?o="Double"+o:"triple"==n&&(o="Triple"+o),o=(1==t?"Left":2==t?"Middle":"Right")+o,xo(e,so(o,i),i,function(t){if("string"==typeof t&&(t=Bs[t]),!t)return!1;var n=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),n=t(e,r)!=Bl}finally{e.state.suppressEdits=!1}return n})}function Wo(e,t,r){var n=e.getOption("configureMouse"),i=n?n(e,t,r):{};if(null==i.unit){var o=Nl?r.shiftKey&&r.metaKey:r.altKey;i.unit=o?"rectangle":"single"==t?"char":"double"==t?"word":"line"}return(null==i.extend||e.doc.extend)&&(i.extend=e.doc.extend||r.shiftKey),null==i.addNew&&(i.addNew=Ml?r.metaKey:r.ctrlKey),null==i.moveOnDrag&&(i.moveOnDrag=!(Ml?r.altKey:r.ctrlKey)),i}function Do(e,t,r,n){gl?setTimeout(u(Wr,e),0):e.curOp.focus=l();var i,o=Wo(e,r,n),s=e.doc.sel;e.options.dragDrop&&Jl&&!e.isReadOnly()&&"single"==r&&(i=s.contains(t))>-1&&(P((i=s.ranges[i]).from(),t)<0||t.xRel>0)&&(P(i.to(),t)>0||t.xRel<0)?Ho(e,n,t,o):Eo(e,n,t,o)}function Ho(e,t,r,n){var i=e.display,o=!1,l=dn(e,function(t){ml&&(i.scroller.draggable=!1),e.state.draggingText=!1,ke(document,"mouseup",l),ke(document,"mousemove",s),ke(i.scroller,"dragstart",a),ke(i.scroller,"drop",l),o||(We(t),n.addNew||di(e.doc,r,null,null,n.extend),ml||gl&&9==vl?setTimeout(function(){document.body.focus(),i.input.focus()},20):i.input.focus())}),s=function(e){o=o||Math.abs(t.clientX-e.clientX)+Math.abs(t.clientY-e.clientY)>=10},a=function(){return o=!0};ml&&(i.scroller.draggable=!0),e.state.draggingText=l,l.copy=!n.moveOnDrag,i.scroller.dragDrop&&i.scroller.dragDrop(),Ql(document,"mouseup",l),Ql(document,"mousemove",s),Ql(i.scroller,"dragstart",a),Ql(i.scroller,"drop",l),Dr(e),setTimeout(function(){return i.input.focus()},20)}function Fo(e,t,r){if("char"==r)return new Ts(t,t);if("word"==r)return e.findWordAt(t);if("line"==r)return new Ts(E(t.line,0),U(e.doc,E(t.line+1,0)));var n=r(e,t);return new Ts(n.from,n.to)}function Eo(e,t,r,n){function i(t){if(0!=P(m,t))if(m=t,"rectangle"==n.unit){for(var i=[],o=e.options.tabSize,l=f(M(u,r.line).text,r.ch,o),s=f(M(u,t.line).text,t.ch,o),a=Math.min(l,s),g=Math.max(l,s),v=Math.min(r.line,t.line),y=Math.min(e.lastLine(),Math.max(r.line,t.line));v<=y;v++){var b=M(u,v).text,w=d(b,a,o);a==g?i.push(new Ts(E(v,w),E(v,w))):b.length>w&&i.push(new Ts(E(v,w),E(v,d(b,g,o))))}i.length||i.push(new Ts(r,r)),bi(u,zn(p.ranges.slice(0,h).concat(i),h),{origin:"*mouse",scroll:!1}),e.scrollIntoView(t)}else{var x,C=c,S=Fo(e,t,n.unit),L=C.anchor;P(S.anchor,L)>0?(x=S.head,L=B(C.from(),S.anchor)):(x=S.anchor,L=R(C.to(),S.head));var k=p.ranges.slice(0);k[h]=Po(e,new Ts(U(u,L),x)),bi(u,zn(k,h),Ul)}}function o(t){var r=++b,s=Sr(e,t,!0,"rectangle"==n.unit);if(s)if(0!=P(s,m)){e.curOp.focus=l(),i(s);var c=Ir(a,u);(s.line>=c.to||s.line<c.from)&&setTimeout(dn(e,function(){b==r&&o(t)}),150)}else{var f=t.clientY<y.top?-20:t.clientY>y.bottom?20:0;f&&setTimeout(dn(e,function(){b==r&&(a.scroller.scrollTop+=f,o(t))}),50)}}function s(t){e.state.selectingText=!1,b=1/0,We(t),a.input.focus(),ke(document,"mousemove",w),ke(document,"mouseup",x),u.history.lastSelOrigin=null}var a=e.display,u=e.doc;We(t);var c,h,p=u.sel,g=p.ranges;if(n.addNew&&!n.extend?(h=u.sel.contains(r),c=h>-1?g[h]:new Ts(r,r)):(c=u.sel.primary(),h=u.sel.primIndex),"rectangle"==n.unit)n.addNew||(c=new Ts(r,r)),r=Sr(e,t,!0,!0),h=-1;else{var v=Fo(e,r,n.unit);c=n.extend?hi(c,v.anchor,v.head,n.extend):v}n.addNew?-1==h?(h=g.length,bi(u,zn(g.concat([c]),h),{scroll:!1,origin:"*mouse"})):g.length>1&&g[h].empty()&&"char"==n.unit&&!n.extend?(bi(u,zn(g.slice(0,h).concat(g.slice(h+1)),0),{scroll:!1,origin:"*mouse"}),p=u.sel):gi(u,h,c,Ul):(h=0,bi(u,new ks([c],0),Ul),p=u.sel);var m=r,y=a.wrapper.getBoundingClientRect(),b=0,w=dn(e,function(e){Pe(e)?o(e):s(e)}),x=dn(e,s);e.state.selectingText=x,Ql(document,"mousemove",w),Ql(document,"mouseup",x)}function Po(e,t){var r=t.anchor,n=t.head,i=M(e.doc,r.line);if(0==P(r,n)&&r.sticky==n.sticky)return t;var o=Se(i);if(!o)return t;var l=Ce(o,r.ch,r.sticky),s=o[l];if(s.from!=r.ch&&s.to!=r.ch)return t;var a=l+(s.from==r.ch==(1!=s.level)?0:1);if(0==a||a==o.length)return t;var u;if(n.line!=r.line)u=(n.line-r.line)*("ltr"==e.doc.direction?1:-1)>0;else{var c=Ce(o,n.ch,n.sticky),f=c-l||(n.ch-r.ch)*(1==s.level?-1:1);u=c==a-1||c==a?f<0:f>0}var h=o[a+(u?-1:0)],d=u==(1==h.level),p=d?h.from:h.to,g=d?"after":"before";return r.ch==p&&r.sticky==g?t:new Ts(new E(r.line,p,g),n)}function Io(e,t,r,n){var i,o;if(t.touches)i=t.touches[0].clientX,o=t.touches[0].clientY;else try{i=t.clientX,o=t.clientY}catch(t){return!1}if(i>=Math.floor(e.display.gutters.getBoundingClientRect().right))return!1;n&&We(t);var l=e.display,s=l.lineDiv.getBoundingClientRect();if(o>s.bottom||!Oe(e,r))return He(t);o-=s.top-l.viewOffset;for(var a=0;a<e.options.gutters.length;++a){var u=l.gutters.childNodes[a];if(u&&u.getBoundingClientRect().right>=i)return Te(e,r,e,D(e.doc,o),e.options.gutters[a],t),He(t)}}function zo(e,t){return Io(e,t,"gutterClick",!0)}function Ro(e,t){Ft(e.display,t)||Bo(e,t)||Me(e,t,"contextmenu")||e.display.input.onContextMenu(t)}function Bo(e,t){return!!Oe(e,"gutterContextMenu")&&Io(e,t,"gutterContextMenu",!1)}function Go(e){e.display.wrapper.className=e.display.wrapper.className.replace(/\s*cm-s-\S+/g,"")+e.options.theme.replace(/(^|\s)\s*/g," cm-s-"),er(e)}function Uo(e){Hn(e),vn(e),zr(e)}function Vo(e,t,r){if(!t!=!(r&&r!=Xs)){var n=e.display.dragFunctions,i=t?Ql:ke;i(e.display.scroller,"dragstart",n.start),i(e.display.scroller,"dragenter",n.enter),i(e.display.scroller,"dragover",n.over),i(e.display.scroller,"dragleave",n.leave),i(e.display.scroller,"drop",n.drop)}}function Ko(e){e.options.lineWrapping?(s(e.display.wrapper,"CodeMirror-wrap"),e.display.sizer.style.minWidth="",e.display.sizerWidth=null):(Fl(e.display.wrapper,"CodeMirror-wrap"),we(e)),Cr(e),vn(e),er(e),setTimeout(function(){return en(e)},100)}function jo(e,t){var r=this;if(!(this instanceof jo))return new jo(e,t);this.options=t=t?c(t):{},c(Ys,t,!1),Fn(t);var n=t.value;"string"==typeof n&&(n=new Ds(n,t.mode,null,t.lineSeparator,t.direction)),this.doc=n;var i=new jo.inputStyles[t.inputStyle](this),o=this.display=new T(e,n,i);o.wrapper.CodeMirror=this,Hn(this),Go(this),t.lineWrapping&&(this.display.wrapper.className+=" CodeMirror-wrap"),rn(this),this.state={keyMaps:[],overlays:[],modeGen:0,overwrite:!1,delayingBlurEvent:!1,focused:!1,suppressEdits:!1,pasteIncoming:!1,cutIncoming:!1,selectingText:!1,draggingText:!1,highlight:new Pl,keySeq:null,specialChars:null},t.autofocus&&!Tl&&o.input.focus(),gl&&vl<11&&setTimeout(function(){return r.display.input.reset(!0)},20),Xo(this),eo(),nn(this),this.curOp.forceUpdate=!0,qn(this,n),t.autofocus&&!Tl||this.hasFocus()?setTimeout(u(Hr,this),20):Fr(this);for(var l in _s)_s.hasOwnProperty(l)&&_s[l](r,t[l],Xs);Rr(this),t.finishInit&&t.finishInit(this);for(var s=0;s<$s.length;++s)$s[s](r);on(this),ml&&t.lineWrapping&&"optimizelegibility"==getComputedStyle(o.lineDiv).textRendering&&(o.lineDiv.style.textRendering="auto")}function Xo(e){function t(){i.activeTouch&&(o=setTimeout(function(){return i.activeTouch=null},1e3),(l=i.activeTouch).end=+new Date)}function r(e){if(1!=e.touches.length)return!1;var t=e.touches[0];return t.radiusX<=1&&t.radiusY<=1}function n(e,t){if(null==t.left)return!0;var r=t.left-e.left,n=t.top-e.top;return r*r+n*n>400}var i=e.display;Ql(i.scroller,"mousedown",dn(e,Oo)),gl&&vl<11?Ql(i.scroller,"dblclick",dn(e,function(t){if(!Me(e,t)){var r=Sr(e,t);if(r&&!zo(e,t)&&!Ft(e.display,t)){We(t);var n=e.findWordAt(r);di(e.doc,n.anchor,n.head)}}})):Ql(i.scroller,"dblclick",function(t){return Me(e,t)||We(t)}),Hl||Ql(i.scroller,"contextmenu",function(t){return Ro(e,t)});var o,l={end:0};Ql(i.scroller,"touchstart",function(t){if(!Me(e,t)&&!r(t)&&!zo(e,t)){i.input.ensurePolled(),clearTimeout(o);var n=+new Date;i.activeTouch={start:n,moved:!1,prev:n-l.end<=300?l:null},1==t.touches.length&&(i.activeTouch.left=t.touches[0].pageX,i.activeTouch.top=t.touches[0].pageY)}}),Ql(i.scroller,"touchmove",function(){i.activeTouch&&(i.activeTouch.moved=!0)}),Ql(i.scroller,"touchend",function(r){var o=i.activeTouch;if(o&&!Ft(i,r)&&null!=o.left&&!o.moved&&new Date-o.start<300){var l,s=e.coordsChar(i.activeTouch,"page");l=!o.prev||n(o,o.prev)?new Ts(s,s):!o.prev.prev||n(o,o.prev.prev)?e.findWordAt(s):new Ts(E(s.line,0),U(e.doc,E(s.line+1,0))),e.setSelection(l.anchor,l.head),e.focus(),We(r)}t()}),Ql(i.scroller,"touchcancel",t),Ql(i.scroller,"scroll",function(){i.scroller.clientHeight&&(qr(e,i.scroller.scrollTop),Qr(e,i.scroller.scrollLeft,!0),Te(e,"scroll",e))}),Ql(i.scroller,"mousewheel",function(t){return In(e,t)}),Ql(i.scroller,"DOMMouseScroll",function(t){return In(e,t)}),Ql(i.wrapper,"scroll",function(){return i.wrapper.scrollTop=i.wrapper.scrollLeft=0}),i.dragFunctions={enter:function(t){Me(e,t)||Fe(t)},over:function(t){Me(e,t)||(Zi(e,t),Fe(t))},start:function(t){return qi(e,t)},drop:dn(e,$i),leave:function(t){Me(e,t)||Qi(e)}};var s=i.input.getField();Ql(s,"keyup",function(t){return To.call(e,t)}),Ql(s,"keydown",dn(e,Lo)),Ql(s,"keypress",dn(e,Mo)),Ql(s,"focus",function(t){return Hr(e,t)}),Ql(s,"blur",function(t){return Fr(e,t)})}function Yo(e,t,r,n){var i,o=e.doc;null==r&&(r="add"),"smart"==r&&(o.mode.indent?i=$e(e,t).state:r="prev");var l=e.options.tabSize,s=M(o,t),a=f(s.text,null,l);s.stateAfter&&(s.stateAfter=null);var u,c=s.text.match(/^\s*/)[0];if(n||/\S/.test(s.text)){if("smart"==r&&((u=o.mode.indent(i,s.text.slice(c.length),s.text))==Bl||u>150)){if(!n)return;r="prev"}}else u=0,r="not";"prev"==r?u=t>o.first?f(M(o,t-1).text,null,l):0:"add"==r?u=a+e.options.indentUnit:"subtract"==r?u=a-e.options.indentUnit:"number"==typeof r&&(u=a+r),u=Math.max(0,u);var h="",d=0;if(e.options.indentWithTabs)for(var g=Math.floor(u/l);g;--g)d+=l,h+="\t";if(d<u&&(h+=p(u-d)),h!=c)return Ei(o,h,E(t,0),E(t,c.length),"+input"),s.stateAfter=null,!0;for(var v=0;v<o.sel.ranges.length;v++){var m=o.sel.ranges[v];if(m.head.line==t&&m.head.ch<c.length){var y=E(t,c.length);gi(o,v,new Ts(y,y));break}}}function _o(e){qs=e}function $o(e,t,r,n,i){var o=e.doc;e.display.shift=!1,n||(n=o.sel);var l=e.state.pasteIncoming||"paste"==i,s=es(t),a=null;if(l&&n.ranges.length>1)if(qs&&qs.text.join("\n")==t){if(n.ranges.length%qs.text.length==0){a=[];for(var u=0;u<qs.text.length;u++)a.push(o.splitLines(qs.text[u]))}}else s.length==n.ranges.length&&e.options.pasteLinesPerSelection&&(a=v(s,function(e){return[e]}));for(var c,f=n.ranges.length-1;f>=0;f--){var h=n.ranges[f],d=h.from(),p=h.to();h.empty()&&(r&&r>0?d=E(d.line,d.ch-r):e.state.overwrite&&!l?p=E(p.line,Math.min(M(o,p.line).text.length,p.ch+g(s).length)):qs&&qs.lineWise&&qs.text.join("\n")==t&&(d=p=E(d.line,0))),c=e.curOp.updateInput;var m={from:d,to:p,text:a?a[f%a.length]:s,origin:i||(l?"paste":e.state.cutIncoming?"cut":"+input")};Oi(e.doc,m),bt(e,"inputRead",e,m)}t&&!l&&Zo(e,t),jr(e),e.curOp.updateInput=c,e.curOp.typing=!0,e.state.pasteIncoming=e.state.cutIncoming=!1}function qo(e,t){var r=e.clipboardData&&e.clipboardData.getData("Text");if(r)return e.preventDefault(),t.isReadOnly()||t.options.disableInput||hn(t,function(){return $o(t,r,0,null,"paste")}),!0}function Zo(e,t){if(e.options.electricChars&&e.options.smartIndent)for(var r=e.doc.sel,n=r.ranges.length-1;n>=0;n--){var i=r.ranges[n];if(!(i.head.ch>100||n&&r.ranges[n-1].head.line==i.head.line)){var o=e.getModeAt(i.head),l=!1;if(o.electricChars){for(var s=0;s<o.electricChars.length;s++)if(t.indexOf(o.electricChars.charAt(s))>-1){l=Yo(e,i.head.line,"smart");break}}else o.electricInput&&o.electricInput.test(M(e.doc,i.head.line).text.slice(0,i.head.ch))&&(l=Yo(e,i.head.line,"smart"));l&&bt(e,"electricInput",e,i.head.line)}}}function Qo(e){for(var t=[],r=[],n=0;n<e.doc.sel.ranges.length;n++){var i=e.doc.sel.ranges[n].head.line,o={anchor:E(i,0),head:E(i+1,0)};r.push(o),t.push(e.getRange(o.anchor,o.head))}return{text:t,ranges:r}}function Jo(e,t){e.setAttribute("autocorrect","off"),e.setAttribute("autocapitalize","off"),e.setAttribute("spellcheck",!!t)}function el(){var e=n("textarea",null,null,"position: absolute; bottom: -1em; padding: 0; width: 1px; height: 1em; outline: none"),t=n("div",[e],null,"overflow: hidden; position: relative; width: 3px; height: 0px;");return ml?e.style.width="1000px":e.setAttribute("wrap","off"),Ll&&(e.style.border="1px solid black"),Jo(e),t}function tl(e,t,r,n,i){function o(){var n=t.line+r;return!(n<e.first||n>=e.first+e.size)&&(t=new E(n,t.ch,t.sticky),u=M(e,n))}function l(n){var l;if(null==(l=i?go(e.cm,u,t,r):ho(u,t,r))){if(n||!o())return!1;t=po(i,e.cm,u,t.line,r)}else t=l;return!0}var s=t,a=r,u=M(e,t.line);if("char"==n)l();else if("column"==n)l(!0);else if("word"==n||"group"==n)for(var c=null,f="group"==n,h=e.cm&&e.cm.getHelper(t,"wordChars"),d=!0;!(r<0)||l(!d);d=!1){var p=u.text.charAt(t.ch)||"\n",g=x(p,h)?"w":f&&"\n"==p?"n":!f||/\s/.test(p)?null:"p";if(!f||d||g||(g="s"),c&&c!=g){r<0&&(r=1,l(),t.sticky="after");break}if(g&&(c=g),r>0&&!l(!d))break}var v=ki(e,t,s,a,!0);return I(s,v)&&(v.hitSide=!0),v}function rl(e,t,r,n){var i,o=e.doc,l=t.left;if("page"==n){var s=Math.min(e.display.wrapper.clientHeight,window.innerHeight||document.documentElement.clientHeight),a=Math.max(s-.5*mr(e.display),3);i=(r>0?t.bottom:t.top)+r*a}else"line"==n&&(i=r>0?t.bottom+3:t.top-3);for(var u;(u=cr(e,l,i)).outside;){if(r<0?i<=0:i>=o.height){u.hitSide=!0;break}i+=5*r}return u}function nl(e,t){var r=jt(e,t.line);if(!r||r.hidden)return null;var n=M(e.doc,t.line),i=Ut(r,n,t.line),o=Se(n,e.doc.direction),l="left";o&&(l=Ce(o,t.ch)%2?"right":"left");var s=_t(i.map,t.ch,l);return s.offset="right"==s.collapse?s.end:s.start,s}function il(e){for(var t=e;t;t=t.parentNode)if(/CodeMirror-gutter-wrapper/.test(t.className))return!0;return!1}function ol(e,t){return t&&(e.bad=!0),e}function ll(e,t,r,n,i){function o(e){return function(t){return t.id==e}}function l(){c&&(u+=f,c=!1)}function s(e){e&&(l(),u+=e)}function a(t){if(1==t.nodeType){var r=t.getAttribute("cm-text");if(null!=r)return void s(r||t.textContent.replace(/\u200b/g,""));var u,h=t.getAttribute("cm-marker");if(h){var d=e.findMarks(E(n,0),E(i+1,0),o(+h));return void(d.length&&(u=d[0].find(0))&&s(N(e.doc,u.from,u.to).join(f)))}if("false"==t.getAttribute("contenteditable"))return;var p=/^(pre|div|p)$/i.test(t.nodeName);p&&l();for(var g=0;g<t.childNodes.length;g++)a(t.childNodes[g]);p&&(c=!0)}else 3==t.nodeType&&s(t.nodeValue)}for(var u="",c=!1,f=e.doc.lineSeparator();a(t),t!=r;)t=t.nextSibling;return u}function sl(e,t,r){var n;if(t==e.display.lineDiv){if(!(n=e.display.lineDiv.childNodes[r]))return ol(e.clipPos(E(e.display.viewTo-1)),!0);t=null,r=0}else for(n=t;;n=n.parentNode){if(!n||n==e.display.lineDiv)return null;if(n.parentNode&&n.parentNode==e.display.lineDiv)break}for(var i=0;i<e.display.view.length;i++){var o=e.display.view[i];if(o.node==n)return al(o,t,r)}}function al(e,t,r){function n(t,r,n){for(var i=-1;i<(f?f.length:0);i++)for(var o=i<0?c.map:f[i],l=0;l<o.length;l+=3){var s=o[l+2];if(s==t||s==r){var a=W(i<0?e.line:e.rest[i]),u=o[l]+n;return(n<0||s!=t)&&(u=o[l+(n?1:0)]),E(a,u)}}}var i=e.text.firstChild,l=!1;if(!t||!o(i,t))return ol(E(W(e.line),0),!0);if(t==i&&(l=!0,t=i.childNodes[r],r=0,!t)){var s=e.rest?g(e.rest):e.line;return ol(E(W(s),s.text.length),l)}var a=3==t.nodeType?t:null,u=t;for(a||1!=t.childNodes.length||3!=t.firstChild.nodeType||(a=t.firstChild,r&&(r=a.nodeValue.length));u.parentNode!=i;)u=u.parentNode;var c=e.measure,f=c.maps,h=n(a,u,r);if(h)return ol(h,l);for(var d=u.nextSibling,p=a?a.nodeValue.length-r:0;d;d=d.nextSibling){if(h=n(d,d.firstChild,0))return ol(E(h.line,h.ch-p),l);p+=d.textContent.length}for(var v=u.previousSibling,m=r;v;v=v.previousSibling){if(h=n(v,v.firstChild,-1))return ol(E(h.line,h.ch+m),l);m+=v.textContent.length}}var ul=navigator.userAgent,cl=navigator.platform,fl=/gecko\/\d/i.test(ul),hl=/MSIE \d/.test(ul),dl=/Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(ul),pl=/Edge\/(\d+)/.exec(ul),gl=hl||dl||pl,vl=gl&&(hl?document.documentMode||6:+(pl||dl)[1]),ml=!pl&&/WebKit\//.test(ul),yl=ml&&/Qt\/\d+\.\d+/.test(ul),bl=!pl&&/Chrome\//.test(ul),wl=/Opera\//.test(ul),xl=/Apple Computer/.test(navigator.vendor),Cl=/Mac OS X 1\d\D([8-9]|\d\d)\D/.test(ul),Sl=/PhantomJS/.test(ul),Ll=!pl&&/AppleWebKit/.test(ul)&&/Mobile\/\w+/.test(ul),kl=/Android/.test(ul),Tl=Ll||kl||/webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(ul),Ml=Ll||/Mac/.test(cl),Nl=/\bCrOS\b/.test(ul),Ol=/win/i.test(cl),Al=wl&&ul.match(/Version\/(\d*\.\d*)/);Al&&(Al=Number(Al[1])),Al&&Al>=15&&(wl=!1,ml=!0);var Wl,Dl=Ml&&(yl||wl&&(null==Al||Al<12.11)),Hl=fl||gl&&vl>=9,Fl=function(t,r){var n=t.className,i=e(r).exec(n);if(i){var o=n.slice(i.index+i[0].length);t.className=n.slice(0,i.index)+(o?i[1]+o:"")}};Wl=document.createRange?function(e,t,r,n){var i=document.createRange();return i.setEnd(n||e,r),i.setStart(e,t),i}:function(e,t,r){var n=document.body.createTextRange();try{n.moveToElementText(e.parentNode)}catch(e){return n}return n.collapse(!0),n.moveEnd("character",r),n.moveStart("character",t),n};var El=function(e){e.select()};Ll?El=function(e){e.selectionStart=0,e.selectionEnd=e.value.length}:gl&&(El=function(e){try{e.select()}catch(e){}});var Pl=function(){this.id=null};Pl.prototype.set=function(e,t){clearTimeout(this.id),this.id=setTimeout(t,e)};var Il,zl,Rl=30,Bl={toString:function(){return"CodeMirror.Pass"}},Gl={scroll:!1},Ul={origin:"*mouse"},Vl={origin:"+move"},Kl=[""],jl=/[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/,Xl=/[\u0300-\u036f\u0483-\u0489\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u065e\u0670\u06d6-\u06dc\u06de-\u06e4\u06e7\u06e8\u06ea-\u06ed\u0711\u0730-\u074a\u07a6-\u07b0\u07eb-\u07f3\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0900-\u0902\u093c\u0941-\u0948\u094d\u0951-\u0955\u0962\u0963\u0981\u09bc\u09be\u09c1-\u09c4\u09cd\u09d7\u09e2\u09e3\u0a01\u0a02\u0a3c\u0a41\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a70\u0a71\u0a75\u0a81\u0a82\u0abc\u0ac1-\u0ac5\u0ac7\u0ac8\u0acd\u0ae2\u0ae3\u0b01\u0b3c\u0b3e\u0b3f\u0b41-\u0b44\u0b4d\u0b56\u0b57\u0b62\u0b63\u0b82\u0bbe\u0bc0\u0bcd\u0bd7\u0c3e-\u0c40\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0cbc\u0cbf\u0cc2\u0cc6\u0ccc\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0d3e\u0d41-\u0d44\u0d4d\u0d57\u0d62\u0d63\u0dca\u0dcf\u0dd2-\u0dd4\u0dd6\u0ddf\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0eb1\u0eb4-\u0eb9\u0ebb\u0ebc\u0ec8-\u0ecd\u0f18\u0f19\u0f35\u0f37\u0f39\u0f71-\u0f7e\u0f80-\u0f84\u0f86\u0f87\u0f90-\u0f97\u0f99-\u0fbc\u0fc6\u102d-\u1030\u1032-\u1037\u1039\u103a\u103d\u103e\u1058\u1059\u105e-\u1060\u1071-\u1074\u1082\u1085\u1086\u108d\u109d\u135f\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b7-\u17bd\u17c6\u17c9-\u17d3\u17dd\u180b-\u180d\u18a9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193b\u1a17\u1a18\u1a56\u1a58-\u1a5e\u1a60\u1a62\u1a65-\u1a6c\u1a73-\u1a7c\u1a7f\u1b00-\u1b03\u1b34\u1b36-\u1b3a\u1b3c\u1b42\u1b6b-\u1b73\u1b80\u1b81\u1ba2-\u1ba5\u1ba8\u1ba9\u1c2c-\u1c33\u1c36\u1c37\u1cd0-\u1cd2\u1cd4-\u1ce0\u1ce2-\u1ce8\u1ced\u1dc0-\u1de6\u1dfd-\u1dff\u200c\u200d\u20d0-\u20f0\u2cef-\u2cf1\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua66f-\ua672\ua67c\ua67d\ua6f0\ua6f1\ua802\ua806\ua80b\ua825\ua826\ua8c4\ua8e0-\ua8f1\ua926-\ua92d\ua947-\ua951\ua980-\ua982\ua9b3\ua9b6-\ua9b9\ua9bc\uaa29-\uaa2e\uaa31\uaa32\uaa35\uaa36\uaa43\uaa4c\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uabe5\uabe8\uabed\udc00-\udfff\ufb1e\ufe00-\ufe0f\ufe20-\ufe26\uff9e\uff9f]/,Yl=!1,_l=!1,$l=null,ql=function(){function e(e){return e<=247?r.charAt(e):1424<=e&&e<=1524?"R":1536<=e&&e<=1785?n.charAt(e-1536):1774<=e&&e<=2220?"r":8192<=e&&e<=8203?"w":8204==e?"b":"L"}function t(e,t,r){this.level=e,this.from=t,this.to=r}var r="bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLN",n="nnnnnnNNr%%r,rNNmmmmmmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmmmnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmnNmmmmmmrrmmNmmmmrr1111111111",i=/[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/,o=/[stwN]/,l=/[LRr]/,s=/[Lb1n]/,a=/[1n]/;return function(r,n){var u="ltr"==n?"L":"R";if(0==r.length||"ltr"==n&&!i.test(r))return!1;for(var c=r.length,f=[],h=0;h<c;++h)f.push(e(r.charCodeAt(h)));for(var d=0,p=u;d<c;++d){var v=f[d];"m"==v?f[d]=p:p=v}for(var m=0,y=u;m<c;++m){var b=f[m];"1"==b&&"r"==y?f[m]="n":l.test(b)&&(y=b,"r"==b&&(f[m]="R"))}for(var w=1,x=f[0];w<c-1;++w){var C=f[w];"+"==C&&"1"==x&&"1"==f[w+1]?f[w]="1":","!=C||x!=f[w+1]||"1"!=x&&"n"!=x||(f[w]=x),x=C}for(var S=0;S<c;++S){var L=f[S];if(","==L)f[S]="N";else if("%"==L){var k=void 0;for(k=S+1;k<c&&"%"==f[k];++k);for(var T=S&&"!"==f[S-1]||k<c&&"1"==f[k]?"1":"N",M=S;M<k;++M)f[M]=T;S=k-1}}for(var N=0,O=u;N<c;++N){var A=f[N];"L"==O&&"1"==A?f[N]="L":l.test(A)&&(O=A)}for(var W=0;W<c;++W)if(o.test(f[W])){var D=void 0;for(D=W+1;D<c&&o.test(f[D]);++D);for(var H="L"==(W?f[W-1]:u),F=H==("L"==(D<c?f[D]:u))?H?"L":"R":u,E=W;E<D;++E)f[E]=F;W=D-1}for(var P,I=[],z=0;z<c;)if(s.test(f[z])){var R=z;for(++z;z<c&&s.test(f[z]);++z);I.push(new t(0,R,z))}else{var B=z,G=I.length;for(++z;z<c&&"L"!=f[z];++z);for(var U=B;U<z;)if(a.test(f[U])){B<U&&I.splice(G,0,new t(1,B,U));var V=U;for(++U;U<z&&a.test(f[U]);++U);I.splice(G,0,new t(2,V,U)),B=U}else++U;B<z&&I.splice(G,0,new t(1,B,z))}return 1==I[0].level&&(P=r.match(/^\s+/))&&(I[0].from=P[0].length,I.unshift(new t(0,0,P[0].length))),1==g(I).level&&(P=r.match(/\s+$/))&&(g(I).to-=P[0].length,I.push(new t(0,c-P[0].length,c))),"rtl"==n?I.reverse():I}}(),Zl=[],Ql=function(e,t,r){if(e.addEventListener)e.addEventListener(t,r,!1);else if(e.attachEvent)e.attachEvent("on"+t,r);else{var n=e._handlers||(e._handlers={});n[t]=(n[t]||Zl).concat(r)}},Jl=function(){if(gl&&vl<9)return!1;var e=n("div");return"draggable"in e||"dragDrop"in e}(),es=3!="\n\nb".split(/\n/).length?function(e){for(var t=0,r=[],n=e.length;t<=n;){var i=e.indexOf("\n",t);-1==i&&(i=e.length);var o=e.slice(t,"\r"==e.charAt(i-1)?i-1:i),l=o.indexOf("\r");-1!=l?(r.push(o.slice(0,l)),t+=l+1):(r.push(o),t=i+1)}return r}:function(e){return e.split(/\r\n?|\n/)},ts=window.getSelection?function(e){try{return e.selectionStart!=e.selectionEnd}catch(e){return!1}}:function(e){var t;try{t=e.ownerDocument.selection.createRange()}catch(e){}return!(!t||t.parentElement()!=e)&&0!=t.compareEndPoints("StartToEnd",t)},rs=function(){var e=n("div");return"oncopy"in e||(e.setAttribute("oncopy","return;"),"function"==typeof e.oncopy)}(),ns=null,is={},os={},ls={},ss=function(e,t,r){this.pos=this.start=0,this.string=e,this.tabSize=t||8,this.lastColumnPos=this.lastColumnValue=0,this.lineStart=0,this.lineOracle=r};ss.prototype.eol=function(){return this.pos>=this.string.length},ss.prototype.sol=function(){return this.pos==this.lineStart},ss.prototype.peek=function(){return this.string.charAt(this.pos)||void 0},ss.prototype.next=function(){if(this.pos<this.string.length)return this.string.charAt(this.pos++)},ss.prototype.eat=function(e){var t=this.string.charAt(this.pos);if("string"==typeof e?t==e:t&&(e.test?e.test(t):e(t)))return++this.pos,t},ss.prototype.eatWhile=function(e){for(var t=this.pos;this.eat(e););return this.pos>t},ss.prototype.eatSpace=function(){for(var e=this,t=this.pos;/[\s\u00a0]/.test(this.string.charAt(this.pos));)++e.pos;return this.pos>t},ss.prototype.skipToEnd=function(){this.pos=this.string.length},ss.prototype.skipTo=function(e){var t=this.string.indexOf(e,this.pos);if(t>-1)return this.pos=t,!0},ss.prototype.backUp=function(e){this.pos-=e},ss.prototype.column=function(){return this.lastColumnPos<this.start&&(this.lastColumnValue=f(this.string,this.start,this.tabSize,this.lastColumnPos,this.lastColumnValue),this.lastColumnPos=this.start),this.lastColumnValue-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.indentation=function(){return f(this.string,null,this.tabSize)-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.match=function(e,t,r){if("string"!=typeof e){var n=this.string.slice(this.pos).match(e);return n&&n.index>0?null:(n&&!1!==t&&(this.pos+=n[0].length),n)}var i=function(e){return r?e.toLowerCase():e};if(i(this.string.substr(this.pos,e.length))==i(e))return!1!==t&&(this.pos+=e.length),!0},ss.prototype.current=function(){return this.string.slice(this.start,this.pos)},ss.prototype.hideFirstChars=function(e,t){this.lineStart+=e;try{return t()}finally{this.lineStart-=e}},ss.prototype.lookAhead=function(e){var t=this.lineOracle;return t&&t.lookAhead(e)};var as=function(e,t){this.state=e,this.lookAhead=t},us=function(e,t,r,n){this.state=t,this.doc=e,this.line=r,this.maxLookAhead=n||0};us.prototype.lookAhead=function(e){var t=this.doc.getLine(this.line+e);return null!=t&&e>this.maxLookAhead&&(this.maxLookAhead=e),t},us.prototype.nextLine=function(){this.line++,this.maxLookAhead>0&&this.maxLookAhead--},us.fromSaved=function(e,t,r){return t instanceof as?new us(e,Ke(e.mode,t.state),r,t.lookAhead):new us(e,Ke(e.mode,t),r)},us.prototype.save=function(e){var t=!1!==e?Ke(this.doc.mode,this.state):this.state;return this.maxLookAhead>0?new as(t,this.maxLookAhead):t};var cs=function(e,t,r){this.start=e.start,this.end=e.pos,this.string=e.current(),this.type=t||null,this.state=r},fs=function(e,t,r){this.text=e,ne(this,t),this.height=r?r(this):1};fs.prototype.lineNo=function(){return W(this)},Ae(fs);var hs,ds={},ps={},gs=null,vs=null,ms={left:0,right:0,top:0,bottom:0},ys=function(e,t,r){this.cm=r;var i=this.vert=n("div",[n("div",null,null,"min-width: 1px")],"CodeMirror-vscrollbar"),o=this.horiz=n("div",[n("div",null,null,"height: 100%; min-height: 1px")],"CodeMirror-hscrollbar");e(i),e(o),Ql(i,"scroll",function(){i.clientHeight&&t(i.scrollTop,"vertical")}),Ql(o,"scroll",function(){o.clientWidth&&t(o.scrollLeft,"horizontal")}),this.checkedZeroWidth=!1,gl&&vl<8&&(this.horiz.style.minHeight=this.vert.style.minWidth="18px")};ys.prototype.update=function(e){var t=e.scrollWidth>e.clientWidth+1,r=e.scrollHeight>e.clientHeight+1,n=e.nativeBarWidth;if(r){this.vert.style.display="block",this.vert.style.bottom=t?n+"px":"0";var i=e.viewHeight-(t?n:0);this.vert.firstChild.style.height=Math.max(0,e.scrollHeight-e.clientHeight+i)+"px"}else this.vert.style.display="",this.vert.firstChild.style.height="0";if(t){this.horiz.style.display="block",this.horiz.style.right=r?n+"px":"0",this.horiz.style.left=e.barLeft+"px";var o=e.viewWidth-e.barLeft-(r?n:0);this.horiz.firstChild.style.width=Math.max(0,e.scrollWidth-e.clientWidth+o)+"px"}else this.horiz.style.display="",this.horiz.firstChild.style.width="0";return!this.checkedZeroWidth&&e.clientHeight>0&&(0==n&&this.zeroWidthHack(),this.checkedZeroWidth=!0),{right:r?n:0,bottom:t?n:0}},ys.prototype.setScrollLeft=function(e){this.horiz.scrollLeft!=e&&(this.horiz.scrollLeft=e),this.disableHoriz&&this.enableZeroWidthBar(this.horiz,this.disableHoriz,"horiz")},ys.prototype.setScrollTop=function(e){this.vert.scrollTop!=e&&(this.vert.scrollTop=e),this.disableVert&&this.enableZeroWidthBar(this.vert,this.disableVert,"vert")},ys.prototype.zeroWidthHack=function(){var e=Ml&&!Cl?"12px":"18px";this.horiz.style.height=this.vert.style.width=e,this.horiz.style.pointerEvents=this.vert.style.pointerEvents="none",this.disableHoriz=new Pl,this.disableVert=new Pl},ys.prototype.enableZeroWidthBar=function(e,t,r){function n(){var i=e.getBoundingClientRect();("vert"==r?document.elementFromPoint(i.right-1,(i.top+i.bottom)/2):document.elementFromPoint((i.right+i.left)/2,i.bottom-1))!=e?e.style.pointerEvents="none":t.set(1e3,n)}e.style.pointerEvents="auto",t.set(1e3,n)},ys.prototype.clear=function(){var e=this.horiz.parentNode;e.removeChild(this.horiz),e.removeChild(this.vert)};var bs=function(){};bs.prototype.update=function(){return{bottom:0,right:0}},bs.prototype.setScrollLeft=function(){},bs.prototype.setScrollTop=function(){},bs.prototype.clear=function(){};var ws={native:ys,null:bs},xs=0,Cs=function(e,t,r){var n=e.display;this.viewport=t,this.visible=Ir(n,e.doc,t),this.editorIsHidden=!n.wrapper.offsetWidth,this.wrapperHeight=n.wrapper.clientHeight,this.wrapperWidth=n.wrapper.clientWidth,this.oldDisplayWidth=Rt(e),this.force=r,this.dims=br(e),this.events=[]};Cs.prototype.signal=function(e,t){Oe(e,t)&&this.events.push(arguments)},Cs.prototype.finish=function(){for(var e=this,t=0;t<this.events.length;t++)Te.apply(null,e.events[t])};var Ss=0,Ls=null;gl?Ls=-.53:fl?Ls=15:bl?Ls=-.7:xl&&(Ls=-1/3);var ks=function(e,t){this.ranges=e,this.primIndex=t};ks.prototype.primary=function(){return this.ranges[this.primIndex]},ks.prototype.equals=function(e){var t=this;if(e==this)return!0;if(e.primIndex!=this.primIndex||e.ranges.length!=this.ranges.length)return!1;for(var r=0;r<this.ranges.length;r++){var n=t.ranges[r],i=e.ranges[r];if(!I(n.anchor,i.anchor)||!I(n.head,i.head))return!1}return!0},ks.prototype.deepCopy=function(){for(var e=this,t=[],r=0;r<this.ranges.length;r++)t[r]=new Ts(z(e.ranges[r].anchor),z(e.ranges[r].head));return new ks(t,this.primIndex)},ks.prototype.somethingSelected=function(){for(var e=this,t=0;t<this.ranges.length;t++)if(!e.ranges[t].empty())return!0;return!1},ks.prototype.contains=function(e,t){var r=this;t||(t=e);for(var n=0;n<this.ranges.length;n++){var i=r.ranges[n];if(P(t,i.from())>=0&&P(e,i.to())<=0)return n}return-1};var Ts=function(e,t){this.anchor=e,this.head=t};Ts.prototype.from=function(){return B(this.anchor,this.head)},Ts.prototype.to=function(){return R(this.anchor,this.head)},Ts.prototype.empty=function(){return this.head.line==this.anchor.line&&this.head.ch==this.anchor.ch},Bi.prototype={chunkSize:function(){return this.lines.length},removeInner:function(e,t){for(var r=this,n=e,i=e+t;n<i;++n){var o=r.lines[n];r.height-=o.height,ot(o),bt(o,"delete")}this.lines.splice(e,t)},collapse:function(e){e.push.apply(e,this.lines)},insertInner:function(e,t,r){var n=this;this.height+=r,this.lines=this.lines.slice(0,e).concat(t).concat(this.lines.slice(e));for(var i=0;i<t.length;++i)t[i].parent=n},iterN:function(e,t,r){for(var n=this,i=e+t;e<i;++e)if(r(n.lines[e]))return!0}},Gi.prototype={chunkSize:function(){return this.size},removeInner:function(e,t){var r=this;this.size-=t;for(var n=0;n<this.children.length;++n){var i=r.children[n],o=i.chunkSize();if(e<o){var l=Math.min(t,o-e),s=i.height;if(i.removeInner(e,l),r.height-=s-i.height,o==l&&(r.children.splice(n--,1),i.parent=null),0==(t-=l))break;e=0}else e-=o}if(this.size-t<25&&(this.children.length>1||!(this.children[0]instanceof Bi))){var a=[];this.collapse(a),this.children=[new Bi(a)],this.children[0].parent=this}},collapse:function(e){for(var t=this,r=0;r<this.children.length;++r)t.children[r].collapse(e)},insertInner:function(e,t,r){var n=this;this.size+=t.length,this.height+=r;for(var i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<=l){if(o.insertInner(e,t,r),o.lines&&o.lines.length>50){for(var s=o.lines.length%25+25,a=s;a<o.lines.length;){var u=new Bi(o.lines.slice(a,a+=25));o.height-=u.height,n.children.splice(++i,0,u),u.parent=n}o.lines=o.lines.slice(0,s),n.maybeSpill()}break}e-=l}},maybeSpill:function(){if(!(this.children.length<=10)){var e=this;do{var t=new Gi(e.children.splice(e.children.length-5,5));if(e.parent){e.size-=t.size,e.height-=t.height;var r=h(e.parent.children,e);e.parent.children.splice(r+1,0,t)}else{var n=new Gi(e.children);n.parent=e,e.children=[n,t],e=n}t.parent=e.parent}while(e.children.length>10);e.parent.maybeSpill()}},iterN:function(e,t,r){for(var n=this,i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<l){var s=Math.min(t,l-e);if(o.iterN(e,s,r))return!0;if(0==(t-=s))break;e=0}else e-=l}}};var Ms=function(e,t,r){var n=this;if(r)for(var i in r)r.hasOwnProperty(i)&&(n[i]=r[i]);this.doc=e,this.node=t};Ms.prototype.clear=function(){var e=this,t=this.doc.cm,r=this.line.widgets,n=this.line,i=W(n);if(null!=i&&r){for(var o=0;o<r.length;++o)r[o]==e&&r.splice(o--,1);r.length||(n.widgets=null);var l=Ht(this);A(n,Math.max(0,n.height-l)),t&&(hn(t,function(){Ui(t,n,-l),mn(t,i,"widget")}),bt(t,"lineWidgetCleared",t,this,i))}},Ms.prototype.changed=function(){var e=this,t=this.height,r=this.doc.cm,n=this.line;this.height=null;var i=Ht(this)-t;i&&(A(n,n.height+i),r&&hn(r,function(){r.curOp.forceUpdate=!0,Ui(r,n,i),bt(r,"lineWidgetChanged",r,e,W(n))}))},Ae(Ms);var Ns=0,Os=function(e,t){this.lines=[],this.type=t,this.doc=e,this.id=++Ns};Os.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){var t=this.doc.cm,r=t&&!t.curOp;if(r&&nn(t),Oe(this,"clear")){var n=this.find();n&&bt(this,"clear",n.from,n.to)}for(var i=null,o=null,l=0;l<this.lines.length;++l){var s=e.lines[l],a=_(s.markedSpans,e);t&&!e.collapsed?mn(t,W(s),"text"):t&&(null!=a.to&&(o=W(s)),null!=a.from&&(i=W(s))),s.markedSpans=$(s.markedSpans,a),null==a.from&&e.collapsed&&!ve(e.doc,s)&&t&&A(s,mr(t.display))}if(t&&this.collapsed&&!t.options.lineWrapping)for(var u=0;u<this.lines.length;++u){var c=fe(e.lines[u]),f=be(c);f>t.display.maxLineLength&&(t.display.maxLine=c,t.display.maxLineLength=f,t.display.maxLineChanged=!0)}null!=i&&t&&this.collapsed&&vn(t,i,o+1),this.lines.length=0,this.explicitlyCleared=!0,this.atomic&&this.doc.cantEdit&&(this.doc.cantEdit=!1,t&&Ci(t.doc)),t&&bt(t,"markerCleared",t,this,i,o),r&&on(t),this.parent&&this.parent.clear()}},Os.prototype.find=function(e,t){var r=this;null==e&&"bookmark"==this.type&&(e=1);for(var n,i,o=0;o<this.lines.length;++o){var l=r.lines[o],s=_(l.markedSpans,r);if(null!=s.from&&(n=E(t?l:W(l),s.from),-1==e))return n;if(null!=s.to&&(i=E(t?l:W(l),s.to),1==e))return i}return n&&{from:n,to:i}},Os.prototype.changed=function(){var e=this,t=this.find(-1,!0),r=this,n=this.doc.cm;t&&n&&hn(n,function(){var i=t.line,o=W(t.line),l=jt(n,o);if(l&&(Qt(l),n.curOp.selectionChanged=n.curOp.forceUpdate=!0),n.curOp.updateMaxLine=!0,!ve(r.doc,i)&&null!=r.height){var s=r.height;r.height=null;var a=Ht(r)-s;a&&A(i,i.height+a)}bt(n,"markerChanged",n,e)})},Os.prototype.attachLine=function(e){if(!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;t.maybeHiddenMarkers&&-1!=h(t.maybeHiddenMarkers,this)||(t.maybeUnhiddenMarkers||(t.maybeUnhiddenMarkers=[])).push(this)}this.lines.push(e)},Os.prototype.detachLine=function(e){if(this.lines.splice(h(this.lines,e),1),!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;(t.maybeHiddenMarkers||(t.maybeHiddenMarkers=[])).push(this)}},Ae(Os);var As=function(e,t){var r=this;this.markers=e,this.primary=t;for(var n=0;n<e.length;++n)e[n].parent=r};As.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){this.explicitlyCleared=!0;for(var t=0;t<this.markers.length;++t)e.markers[t].clear();bt(this,"clear")}},As.prototype.find=function(e,t){return this.primary.find(e,t)},Ae(As);var Ws=0,Ds=function(e,t,r,n,i){if(!(this instanceof Ds))return new Ds(e,t,r,n,i);null==r&&(r=0),Gi.call(this,[new Bi([new fs("",null)])]),this.first=r,this.scrollTop=this.scrollLeft=0,this.cantEdit=!1,this.cleanGeneration=1,this.modeFrontier=this.highlightFrontier=r;var o=E(r,0);this.sel=Rn(o),this.history=new Jn(null),this.id=++Ws,this.modeOption=t,this.lineSep=n,this.direction="rtl"==i?"rtl":"ltr",this.extend=!1,"string"==typeof e&&(e=this.splitLines(e)),_n(this,{from:o,to:o,text:e}),bi(this,Rn(o),Gl)};Ds.prototype=b(Gi.prototype,{constructor:Ds,iter:function(e,t,r){r?this.iterN(e-this.first,t-e,r):this.iterN(this.first,this.first+this.size,e)},insert:function(e,t){for(var r=0,n=0;n<t.length;++n)r+=t[n].height;this.insertInner(e-this.first,t,r)},remove:function(e,t){this.removeInner(e-this.first,t)},getValue:function(e){var t=O(this,this.first,this.first+this.size);return!1===e?t:t.join(e||this.lineSeparator())},setValue:gn(function(e){var t=E(this.first,0),r=this.first+this.size-1;Oi(this,{from:t,to:E(r,M(this,r).text.length),text:this.splitLines(e),origin:"setValue",full:!0},!0),this.cm&&Xr(this.cm,0,0),bi(this,Rn(t),Gl)}),replaceRange:function(e,t,r,n){Ei(this,e,t=U(this,t),r=r?U(this,r):t,n)},getRange:function(e,t,r){var n=N(this,U(this,e),U(this,t));return!1===r?n:n.join(r||this.lineSeparator())},getLine:function(e){var t=this.getLineHandle(e);return t&&t.text},getLineHandle:function(e){if(H(this,e))return M(this,e)},getLineNumber:function(e){return W(e)},getLineHandleVisualStart:function(e){return"number"==typeof e&&(e=M(this,e)),fe(e)},lineCount:function(){return this.size},firstLine:function(){return this.first},lastLine:function(){return this.first+this.size-1},clipPos:function(e){return U(this,e)},getCursor:function(e){var t=this.sel.primary();return null==e||"head"==e?t.head:"anchor"==e?t.anchor:"end"==e||"to"==e||!1===e?t.to():t.from()},listSelections:function(){return this.sel.ranges},somethingSelected:function(){return this.sel.somethingSelected()},setCursor:gn(function(e,t,r){vi(this,U(this,"number"==typeof e?E(e,t||0):e),null,r)}),setSelection:gn(function(e,t,r){vi(this,U(this,e),U(this,t||e),r)}),extendSelection:gn(function(e,t,r){di(this,U(this,e),t&&U(this,t),r)}),extendSelections:gn(function(e,t){pi(this,K(this,e),t)}),extendSelectionsBy:gn(function(e,t){pi(this,K(this,v(this.sel.ranges,e)),t)}),setSelections:gn(function(e,t,r){var n=this;if(e.length){for(var i=[],o=0;o<e.length;o++)i[o]=new Ts(U(n,e[o].anchor),U(n,e[o].head));null==t&&(t=Math.min(e.length-1,this.sel.primIndex)),bi(this,zn(i,t),r)}}),addSelection:gn(function(e,t,r){var n=this.sel.ranges.slice(0);n.push(new Ts(U(this,e),U(this,t||e))),bi(this,zn(n,n.length-1),r)}),getSelection:function(e){for(var t,r=this,n=this.sel.ranges,i=0;i<n.length;i++){var o=N(r,n[i].from(),n[i].to());t=t?t.concat(o):o}return!1===e?t:t.join(e||this.lineSeparator())},getSelections:function(e){for(var t=this,r=[],n=this.sel.ranges,i=0;i<n.length;i++){var o=N(t,n[i].from(),n[i].to());!1!==e&&(o=o.join(e||t.lineSeparator())),r[i]=o}return r},replaceSelection:function(e,t,r){for(var n=[],i=0;i<this.sel.ranges.length;i++)n[i]=e;this.replaceSelections(n,t,r||"+input")},replaceSelections:gn(function(e,t,r){for(var n=this,i=[],o=this.sel,l=0;l<o.ranges.length;l++){var s=o.ranges[l];i[l]={from:s.from(),to:s.to(),text:n.splitLines(e[l]),origin:r}}for(var a=t&&"end"!=t&&Kn(this,i,t),u=i.length-1;u>=0;u--)Oi(n,i[u]);a?yi(this,a):this.cm&&jr(this.cm)}),undo:gn(function(){Wi(this,"undo")}),redo:gn(function(){Wi(this,"redo")}),undoSelection:gn(function(){Wi(this,"undo",!0)}),redoSelection:gn(function(){Wi(this,"redo",!0)}),setExtending:function(e){this.extend=e},getExtending:function(){return this.extend},historySize:function(){for(var e=this.history,t=0,r=0,n=0;n<e.done.length;n++)e.done[n].ranges||++t;for(var i=0;i<e.undone.length;i++)e.undone[i].ranges||++r;return{undo:t,redo:r}},clearHistory:function(){this.history=new Jn(this.history.maxGeneration)},markClean:function(){this.cleanGeneration=this.changeGeneration(!0)},changeGeneration:function(e){return e&&(this.history.lastOp=this.history.lastSelOp=this.history.lastOrigin=null),this.history.generation},isClean:function(e){return this.history.generation==(e||this.cleanGeneration)},getHistory:function(){return{done:fi(this.history.done),undone:fi(this.history.undone)}},setHistory:function(e){var t=this.history=new Jn(this.history.maxGeneration);t.done=fi(e.done.slice(0),null,!0),t.undone=fi(e.undone.slice(0),null,!0)},setGutterMarker:gn(function(e,t,r){return Ri(this,e,"gutter",function(e){var n=e.gutterMarkers||(e.gutterMarkers={});return n[t]=r,!r&&C(n)&&(e.gutterMarkers=null),!0})}),clearGutter:gn(function(e){var t=this;this.iter(function(r){r.gutterMarkers&&r.gutterMarkers[e]&&Ri(t,r,"gutter",function(){return r.gutterMarkers[e]=null,C(r.gutterMarkers)&&(r.gutterMarkers=null),!0})})}),lineInfo:function(e){var t;if("number"==typeof e){if(!H(this,e))return null;if(t=e,!(e=M(this,e)))return null}else if(null==(t=W(e)))return null;return{line:t,handle:e,text:e.text,gutterMarkers:e.gutterMarkers,textClass:e.textClass,bgClass:e.bgClass,wrapClass:e.wrapClass,widgets:e.widgets}},addLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass";if(t[i]){if(e(n).test(t[i]))return!1;t[i]+=" "+n}else t[i]=n;return!0})}),removeLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass",o=t[i];if(!o)return!1;if(null==n)t[i]=null;else{var l=o.match(e(n));if(!l)return!1;var s=l.index+l[0].length;t[i]=o.slice(0,l.index)+(l.index&&s!=o.length?" ":"")+o.slice(s)||null}return!0})}),addLineWidget:gn(function(e,t,r){return Vi(this,e,t,r)}),removeLineWidget:function(e){e.clear()},markText:function(e,t,r){return Ki(this,U(this,e),U(this,t),r,r&&r.type||"range")},setBookmark:function(e,t){var r={replacedWith:t&&(null==t.nodeType?t.widget:t),insertLeft:t&&t.insertLeft,clearWhenEmpty:!1,shared:t&&t.shared,handleMouseEvents:t&&t.handleMouseEvents};return e=U(this,e),Ki(this,e,e,r,"bookmark")},findMarksAt:function(e){var t=[],r=M(this,(e=U(this,e)).line).markedSpans;if(r)for(var n=0;n<r.length;++n){var i=r[n];(null==i.from||i.from<=e.ch)&&(null==i.to||i.to>=e.ch)&&t.push(i.marker.parent||i.marker)}return t},findMarks:function(e,t,r){e=U(this,e),t=U(this,t);var n=[],i=e.line;return this.iter(e.line,t.line+1,function(o){var l=o.markedSpans;if(l)for(var s=0;s<l.length;s++){var a=l[s];null!=a.to&&i==e.line&&e.ch>=a.to||null==a.from&&i!=e.line||null!=a.from&&i==t.line&&a.from>=t.ch||r&&!r(a.marker)||n.push(a.marker.parent||a.marker)}++i}),n},getAllMarks:function(){var e=[];return this.iter(function(t){var r=t.markedSpans;if(r)for(var n=0;n<r.length;++n)null!=r[n].from&&e.push(r[n].marker)}),e},posFromIndex:function(e){var t,r=this.first,n=this.lineSeparator().length;return this.iter(function(i){var o=i.text.length+n;if(o>e)return t=e,!0;e-=o,++r}),U(this,E(r,t))},indexFromPos:function(e){var t=(e=U(this,e)).ch;if(e.line<this.first||e.ch<0)return 0;var r=this.lineSeparator().length;return this.iter(this.first,e.line,function(e){t+=e.text.length+r}),t},copy:function(e){var t=new Ds(O(this,this.first,this.first+this.size),this.modeOption,this.first,this.lineSep,this.direction);return t.scrollTop=this.scrollTop,t.scrollLeft=this.scrollLeft,t.sel=this.sel,t.extend=!1,e&&(t.history.undoDepth=this.history.undoDepth,t.setHistory(this.getHistory())),t},linkedDoc:function(e){e||(e={});var t=this.first,r=this.first+this.size;null!=e.from&&e.from>t&&(t=e.from),null!=e.to&&e.to<r&&(r=e.to);var n=new Ds(O(this,t,r),e.mode||this.modeOption,t,this.lineSep,this.direction);return e.sharedHist&&(n.history=this.history),(this.linked||(this.linked=[])).push({doc:n,sharedHist:e.sharedHist}),n.linked=[{doc:this,isParent:!0,sharedHist:e.sharedHist}],Yi(n,Xi(this)),n},unlinkDoc:function(e){var t=this;if(e instanceof jo&&(e=e.doc),this.linked)for(var r=0;r<this.linked.length;++r)if(t.linked[r].doc==e){t.linked.splice(r,1),e.unlinkDoc(t),_i(Xi(t));break}if(e.history==this.history){var n=[e.id];$n(e,function(e){return n.push(e.id)},!0),e.history=new Jn(null),e.history.done=fi(this.history.done,n),e.history.undone=fi(this.history.undone,n)}},iterLinkedDocs:function(e){$n(this,e)},getMode:function(){return this.mode},getEditor:function(){return this.cm},splitLines:function(e){return this.lineSep?e.split(this.lineSep):es(e)},lineSeparator:function(){return this.lineSep||"\n"},setDirection:gn(function(e){"rtl"!=e&&(e="ltr"),e!=this.direction&&(this.direction=e,this.iter(function(e){return e.order=null}),this.cm&&Qn(this.cm))})}),Ds.prototype.eachLine=Ds.prototype.iter;for(var Hs=0,Fs=!1,Es={3:"Enter",8:"Backspace",9:"Tab",13:"Enter",16:"Shift",17:"Ctrl",18:"Alt",19:"Pause",20:"CapsLock",27:"Esc",32:"Space",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"Left",38:"Up",39:"Right",40:"Down",44:"PrintScrn",45:"Insert",46:"Delete",59:";",61:"=",91:"Mod",92:"Mod",93:"Mod",106:"*",107:"=",109:"-",110:".",111:"/",127:"Delete",173:"-",186:";",187:"=",188:",",189:"-",190:".",191:"/",192:"`",219:"[",220:"\\",221:"]",222:"'",63232:"Up",63233:"Down",63234:"Left",63235:"Right",63272:"Delete",63273:"Home",63275:"End",63276:"PageUp",63277:"PageDown",63302:"Insert"},Ps=0;Ps<10;Ps++)Es[Ps+48]=Es[Ps+96]=String(Ps);for(var Is=65;Is<=90;Is++)Es[Is]=String.fromCharCode(Is);for(var zs=1;zs<=12;zs++)Es[zs+111]=Es[zs+63235]="F"+zs;var Rs={};Rs.basic={Left:"goCharLeft",Right:"goCharRight",Up:"goLineUp",Down:"goLineDown",End:"goLineEnd",Home:"goLineStartSmart",PageUp:"goPageUp",PageDown:"goPageDown",Delete:"delCharAfter",Backspace:"delCharBefore","Shift-Backspace":"delCharBefore",Tab:"defaultTab","Shift-Tab":"indentAuto",Enter:"newlineAndIndent",Insert:"toggleOverwrite",Esc:"singleSelection"},Rs.pcDefault={"Ctrl-A":"selectAll","Ctrl-D":"deleteLine","Ctrl-Z":"undo","Shift-Ctrl-Z":"redo","Ctrl-Y":"redo","Ctrl-Home":"goDocStart","Ctrl-End":"goDocEnd","Ctrl-Up":"goLineUp","Ctrl-Down":"goLineDown","Ctrl-Left":"goGroupLeft","Ctrl-Right":"goGroupRight","Alt-Left":"goLineStart","Alt-Right":"goLineEnd","Ctrl-Backspace":"delGroupBefore","Ctrl-Delete":"delGroupAfter","Ctrl-S":"save","Ctrl-F":"find","Ctrl-G":"findNext","Shift-Ctrl-G":"findPrev","Shift-Ctrl-F":"replace","Shift-Ctrl-R":"replaceAll","Ctrl-[":"indentLess","Ctrl-]":"indentMore","Ctrl-U":"undoSelection","Shift-Ctrl-U":"redoSelection","Alt-U":"redoSelection",fallthrough:"basic"},Rs.emacsy={"Ctrl-F":"goCharRight","Ctrl-B":"goCharLeft","Ctrl-P":"goLineUp","Ctrl-N":"goLineDown","Alt-F":"goWordRight","Alt-B":"goWordLeft","Ctrl-A":"goLineStart","Ctrl-E":"goLineEnd","Ctrl-V":"goPageDown","Shift-Ctrl-V":"goPageUp","Ctrl-D":"delCharAfter","Ctrl-H":"delCharBefore","Alt-D":"delWordAfter","Alt-Backspace":"delWordBefore","Ctrl-K":"killLine","Ctrl-T":"transposeChars","Ctrl-O":"openLine"},Rs.macDefault={"Cmd-A":"selectAll","Cmd-D":"deleteLine","Cmd-Z":"undo","Shift-Cmd-Z":"redo","Cmd-Y":"redo","Cmd-Home":"goDocStart","Cmd-Up":"goDocStart","Cmd-End":"goDocEnd","Cmd-Down":"goDocEnd","Alt-Left":"goGroupLeft","Alt-Right":"goGroupRight","Cmd-Left":"goLineLeft","Cmd-Right":"goLineRight","Alt-Backspace":"delGroupBefore","Ctrl-Alt-Backspace":"delGroupAfter","Alt-Delete":"delGroupAfter","Cmd-S":"save","Cmd-F":"find","Cmd-G":"findNext","Shift-Cmd-G":"findPrev","Cmd-Alt-F":"replace","Shift-Cmd-Alt-F":"replaceAll","Cmd-[":"indentLess","Cmd-]":"indentMore","Cmd-Backspace":"delWrappedLineLeft","Cmd-Delete":"delWrappedLineRight","Cmd-U":"undoSelection","Shift-Cmd-U":"redoSelection","Ctrl-Up":"goDocStart","Ctrl-Down":"goDocEnd",fallthrough:["basic","emacsy"]},Rs.default=Ml?Rs.macDefault:Rs.pcDefault;var Bs={selectAll:Mi,singleSelection:function(e){return e.setSelection(e.getCursor("anchor"),e.getCursor("head"),Gl)},killLine:function(e){return co(e,function(t){if(t.empty()){var r=M(e.doc,t.head.line).text.length;return t.head.ch==r&&t.head.line<e.lastLine()?{from:t.head,to:E(t.head.line+1,0)}:{from:t.head,to:E(t.head.line,r)}}return{from:t.from(),to:t.to()}})},deleteLine:function(e){return co(e,function(t){return{from:E(t.from().line,0),to:U(e.doc,E(t.to().line+1,0))}})},delLineLeft:function(e){return co(e,function(e){return{from:E(e.from().line,0),to:e.from()}})},delWrappedLineLeft:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5;return{from:e.coordsChar({left:0,top:r},"div"),to:t.from()}})},delWrappedLineRight:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5,n=e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div");return{from:t.from(),to:n}})},undo:function(e){return e.undo()},redo:function(e){return e.redo()},undoSelection:function(e){return e.undoSelection()},redoSelection:function(e){return e.redoSelection()},goDocStart:function(e){return e.extendSelection(E(e.firstLine(),0))},goDocEnd:function(e){return e.extendSelection(E(e.lastLine()))},goLineStart:function(e){return e.extendSelectionsBy(function(t){return vo(e,t.head.line)},{origin:"+move",bias:1})},goLineStartSmart:function(e){return e.extendSelectionsBy(function(t){return yo(e,t.head)},{origin:"+move",bias:1})},goLineEnd:function(e){return e.extendSelectionsBy(function(t){return mo(e,t.head.line)},{origin:"+move",bias:-1})},goLineRight:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div")},Vl)},goLineLeft:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:0,top:r},"div")},Vl)},goLineLeftSmart:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5,n=e.coordsChar({left:0,top:r},"div");return n.ch<e.getLine(n.line).search(/\S/)?yo(e,t.head):n},Vl)},goLineUp:function(e){return e.moveV(-1,"line")},goLineDown:function(e){return e.moveV(1,"line")},goPageUp:function(e){return e.moveV(-1,"page")},goPageDown:function(e){return e.moveV(1,"page")},goCharLeft:function(e){return e.moveH(-1,"char")},goCharRight:function(e){return e.moveH(1,"char")},goColumnLeft:function(e){return e.moveH(-1,"column")},goColumnRight:function(e){return e.moveH(1,"column")},goWordLeft:function(e){return e.moveH(-1,"word")},goGroupRight:function(e){return e.moveH(1,"group")},goGroupLeft:function(e){return e.moveH(-1,"group")},goWordRight:function(e){return e.moveH(1,"word")},delCharBefore:function(e){return e.deleteH(-1,"char")},delCharAfter:function(e){return e.deleteH(1,"char")},delWordBefore:function(e){return e.deleteH(-1,"word")},delWordAfter:function(e){return e.deleteH(1,"word")},delGroupBefore:function(e){return e.deleteH(-1,"group")},delGroupAfter:function(e){return e.deleteH(1,"group")},indentAuto:function(e){return e.indentSelection("smart")},indentMore:function(e){return e.indentSelection("add")},indentLess:function(e){return e.indentSelection("subtract")},insertTab:function(e){return e.replaceSelection("\t")},insertSoftTab:function(e){for(var t=[],r=e.listSelections(),n=e.options.tabSize,i=0;i<r.length;i++){var o=r[i].from(),l=f(e.getLine(o.line),o.ch,n);t.push(p(n-l%n))}e.replaceSelections(t)},defaultTab:function(e){e.somethingSelected()?e.indentSelection("add"):e.execCommand("insertTab")},transposeChars:function(e){return hn(e,function(){for(var t=e.listSelections(),r=[],n=0;n<t.length;n++)if(t[n].empty()){var i=t[n].head,o=M(e.doc,i.line).text;if(o)if(i.ch==o.length&&(i=new E(i.line,i.ch-1)),i.ch>0)i=new E(i.line,i.ch+1),e.replaceRange(o.charAt(i.ch-1)+o.charAt(i.ch-2),E(i.line,i.ch-2),i,"+transpose");else if(i.line>e.doc.first){var l=M(e.doc,i.line-1).text;l&&(i=new E(i.line,1),e.replaceRange(o.charAt(0)+e.doc.lineSeparator()+l.charAt(l.length-1),E(i.line-1,l.length-1),i,"+transpose"))}r.push(new Ts(i,i))}e.setSelections(r)})},newlineAndIndent:function(e){return hn(e,function(){for(var t=e.listSelections(),r=t.length-1;r>=0;r--)e.replaceRange(e.doc.lineSeparator(),t[r].anchor,t[r].head,"+input");t=e.listSelections();for(var n=0;n<t.length;n++)e.indentLine(t[n].from().line,null,!0);jr(e)})},openLine:function(e){return e.replaceSelection("\n","start")},toggleOverwrite:function(e){return e.toggleOverwrite()}},Gs=new Pl,Us=null,Vs=function(e,t,r){this.time=e,this.pos=t,this.button=r};Vs.prototype.compare=function(e,t,r){return this.time+400>e&&0==P(t,this.pos)&&r==this.button};var Ks,js,Xs={toString:function(){return"CodeMirror.Init"}},Ys={},_s={};jo.defaults=Ys,jo.optionHandlers=_s;var $s=[];jo.defineInitHook=function(e){return $s.push(e)};var qs=null,Zs=function(e){this.cm=e,this.lastAnchorNode=this.lastAnchorOffset=this.lastFocusNode=this.lastFocusOffset=null,this.polling=new Pl,this.composing=null,this.gracePeriod=!1,this.readDOMTimeout=null};Zs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()}),"cut"==e.type&&i.replaceSelection("",null,"cut");else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type&&i.operation(function(){i.setSelections(t.ranges,0,Gl),i.replaceSelection("",null,"cut")})}if(e.clipboardData){e.clipboardData.clearData();var r=qs.text.join("\n");if(e.clipboardData.setData("Text",r),e.clipboardData.getData("Text")==r)return void e.preventDefault()}var l=el(),s=l.firstChild;i.display.lineSpace.insertBefore(l,i.display.lineSpace.firstChild),s.value=qs.text.join("\n");var a=document.activeElement;El(s),setTimeout(function(){i.display.lineSpace.removeChild(l),a.focus(),a==o&&n.showPrimarySelection()},50)}}var r=this,n=this,i=n.cm,o=n.div=e.lineDiv;Jo(o,i.options.spellcheck),Ql(o,"paste",function(e){Me(i,e)||qo(e,i)||vl<=11&&setTimeout(dn(i,function(){return r.updateFromDOM()}),20)}),Ql(o,"compositionstart",function(e){r.composing={data:e.data,done:!1}}),Ql(o,"compositionupdate",function(e){r.composing||(r.composing={data:e.data,done:!1})}),Ql(o,"compositionend",function(e){r.composing&&(e.data!=r.composing.data&&r.readFromDOMSoon(),r.composing.done=!0)}),Ql(o,"touchstart",function(){return n.forceCompositionEnd()}),Ql(o,"input",function(){r.composing||r.readFromDOMSoon()}),Ql(o,"copy",t),Ql(o,"cut",t)},Zs.prototype.prepareSelection=function(){var e=Tr(this.cm,!1);return e.focus=this.cm.state.focused,e},Zs.prototype.showSelection=function(e,t){e&&this.cm.display.view.length&&((e.focus||t)&&this.showPrimarySelection(),this.showMultipleSelections(e))},Zs.prototype.showPrimarySelection=function(){var e=window.getSelection(),t=this.cm,r=t.doc.sel.primary(),n=r.from(),i=r.to();if(t.display.viewTo==t.display.viewFrom||n.line>=t.display.viewTo||i.line<t.display.viewFrom)e.removeAllRanges();else{var o=sl(t,e.anchorNode,e.anchorOffset),l=sl(t,e.focusNode,e.focusOffset);if(!o||o.bad||!l||l.bad||0!=P(B(o,l),n)||0!=P(R(o,l),i)){var s=t.display.view,a=n.line>=t.display.viewFrom&&nl(t,n)||{node:s[0].measure.map[2],offset:0},u=i.line<t.display.viewTo&&nl(t,i);if(!u){var c=s[s.length-1].measure,f=c.maps?c.maps[c.maps.length-1]:c.map;u={node:f[f.length-1],offset:f[f.length-2]-f[f.length-3]}}if(a&&u){var h,d=e.rangeCount&&e.getRangeAt(0);try{h=Wl(a.node,a.offset,u.offset,u.node)}catch(e){}h&&(!fl&&t.state.focused?(e.collapse(a.node,a.offset),h.collapsed||(e.removeAllRanges(),e.addRange(h))):(e.removeAllRanges(),e.addRange(h)),d&&null==e.anchorNode?e.addRange(d):fl&&this.startGracePeriod()),this.rememberSelection()}else e.removeAllRanges()}}},Zs.prototype.startGracePeriod=function(){var e=this;clearTimeout(this.gracePeriod),this.gracePeriod=setTimeout(function(){e.gracePeriod=!1,e.selectionChanged()&&e.cm.operation(function(){return e.cm.curOp.selectionChanged=!0})},20)},Zs.prototype.showMultipleSelections=function(e){r(this.cm.display.cursorDiv,e.cursors),r(this.cm.display.selectionDiv,e.selection)},Zs.prototype.rememberSelection=function(){var e=window.getSelection();this.lastAnchorNode=e.anchorNode,this.lastAnchorOffset=e.anchorOffset,this.lastFocusNode=e.focusNode,this.lastFocusOffset=e.focusOffset},Zs.prototype.selectionInEditor=function(){var e=window.getSelection();if(!e.rangeCount)return!1;var t=e.getRangeAt(0).commonAncestorContainer;return o(this.div,t)},Zs.prototype.focus=function(){"nocursor"!=this.cm.options.readOnly&&(this.selectionInEditor()||this.showSelection(this.prepareSelection(),!0),this.div.focus())},Zs.prototype.blur=function(){this.div.blur()},Zs.prototype.getField=function(){return this.div},Zs.prototype.supportsTouch=function(){return!0},Zs.prototype.receivedFocus=function(){function e(){t.cm.state.focused&&(t.pollSelection(),t.polling.set(t.cm.options.pollInterval,e))}var t=this;this.selectionInEditor()?this.pollSelection():hn(this.cm,function(){return t.cm.curOp.selectionChanged=!0}),this.polling.set(this.cm.options.pollInterval,e)},Zs.prototype.selectionChanged=function(){var e=window.getSelection();return e.anchorNode!=this.lastAnchorNode||e.anchorOffset!=this.lastAnchorOffset||e.focusNode!=this.lastFocusNode||e.focusOffset!=this.lastFocusOffset},Zs.prototype.pollSelection=function(){if(null==this.readDOMTimeout&&!this.gracePeriod&&this.selectionChanged()){var e=window.getSelection(),t=this.cm;if(kl&&bl&&this.cm.options.gutters.length&&il(e.anchorNode))return this.cm.triggerOnKeyDown({type:"keydown",keyCode:8,preventDefault:Math.abs}),this.blur(),void this.focus();if(!this.composing){this.rememberSelection();var r=sl(t,e.anchorNode,e.anchorOffset),n=sl(t,e.focusNode,e.focusOffset);r&&n&&hn(t,function(){bi(t.doc,Rn(r,n),Gl),(r.bad||n.bad)&&(t.curOp.selectionChanged=!0)})}}},Zs.prototype.pollContent=function(){null!=this.readDOMTimeout&&(clearTimeout(this.readDOMTimeout),this.readDOMTimeout=null);var e=this.cm,t=e.display,r=e.doc.sel.primary(),n=r.from(),i=r.to();if(0==n.ch&&n.line>e.firstLine()&&(n=E(n.line-1,M(e.doc,n.line-1).length)),i.ch==M(e.doc,i.line).text.length&&i.line<e.lastLine()&&(i=E(i.line+1,0)),n.line<t.viewFrom||i.line>t.viewTo-1)return!1;var o,l,s;n.line==t.viewFrom||0==(o=Lr(e,n.line))?(l=W(t.view[0].line),s=t.view[0].node):(l=W(t.view[o].line),s=t.view[o-1].node.nextSibling);var a,u,c=Lr(e,i.line);if(c==t.view.length-1?(a=t.viewTo-1,u=t.lineDiv.lastChild):(a=W(t.view[c+1].line)-1,u=t.view[c+1].node.previousSibling),!s)return!1;for(var f=e.doc.splitLines(ll(e,s,u,l,a)),h=N(e.doc,E(l,0),E(a,M(e.doc,a).text.length));f.length>1&&h.length>1;)if(g(f)==g(h))f.pop(),h.pop(),a--;else{if(f[0]!=h[0])break;f.shift(),h.shift(),l++}for(var d=0,p=0,v=f[0],m=h[0],y=Math.min(v.length,m.length);d<y&&v.charCodeAt(d)==m.charCodeAt(d);)++d;for(var b=g(f),w=g(h),x=Math.min(b.length-(1==f.length?d:0),w.length-(1==h.length?d:0));p<x&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)++p;if(1==f.length&&1==h.length&&l==n.line)for(;d&&d>n.ch&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)d--,p++;f[f.length-1]=b.slice(0,b.length-p).replace(/^\u200b+/,""),f[0]=f[0].slice(d).replace(/\u200b+$/,"");var C=E(l,d),S=E(a,h.length?g(h).length-p:0);return f.length>1||f[0]||P(C,S)?(Ei(e.doc,f,C,S,"+input"),!0):void 0},Zs.prototype.ensurePolled=function(){this.forceCompositionEnd()},Zs.prototype.reset=function(){this.forceCompositionEnd()},Zs.prototype.forceCompositionEnd=function(){this.composing&&(clearTimeout(this.readDOMTimeout),this.composing=null,this.updateFromDOM(),this.div.blur(),this.div.focus())},Zs.prototype.readFromDOMSoon=function(){var e=this;null==this.readDOMTimeout&&(this.readDOMTimeout=setTimeout(function(){if(e.readDOMTimeout=null,e.composing){if(!e.composing.done)return;e.composing=null}e.updateFromDOM()},80))},Zs.prototype.updateFromDOM=function(){var e=this;!this.cm.isReadOnly()&&this.pollContent()||hn(this.cm,function(){return vn(e.cm)})},Zs.prototype.setUneditable=function(e){e.contentEditable="false"},Zs.prototype.onKeyPress=function(e){0!=e.charCode&&(e.preventDefault(),this.cm.isReadOnly()||dn(this.cm,$o)(this.cm,String.fromCharCode(null==e.charCode?e.keyCode:e.charCode),0))},Zs.prototype.readOnlyChanged=function(e){this.div.contentEditable=String("nocursor"!=e)},Zs.prototype.onContextMenu=function(){},Zs.prototype.resetPosition=function(){},Zs.prototype.needsContentAttribute=!0;var Qs=function(e){this.cm=e,this.prevInput="",this.pollingFast=!1,this.polling=new Pl,this.hasSelection=!1,this.composing=null};Qs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()});else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type?i.setSelections(t.ranges,null,Gl):(n.prevInput="",l.value=t.text.join("\n"),El(l))}"cut"==e.type&&(i.state.cutIncoming=!0)}}var r=this,n=this,i=this.cm,o=this.wrapper=el(),l=this.textarea=o.firstChild;e.wrapper.insertBefore(o,e.wrapper.firstChild),Ll&&(l.style.width="0px"),Ql(l,"input",function(){gl&&vl>=9&&r.hasSelection&&(r.hasSelection=null),n.poll()}),Ql(l,"paste",function(e){Me(i,e)||qo(e,i)||(i.state.pasteIncoming=!0,n.fastPoll())}),Ql(l,"cut",t),Ql(l,"copy",t),Ql(e.scroller,"paste",function(t){Ft(e,t)||Me(i,t)||(i.state.pasteIncoming=!0,n.focus())}),Ql(e.lineSpace,"selectstart",function(t){Ft(e,t)||We(t)}),Ql(l,"compositionstart",function(){var e=i.getCursor("from");n.composing&&n.composing.range.clear(),n.composing={start:e,range:i.markText(e,i.getCursor("to"),{className:"CodeMirror-composing"})}}),Ql(l,"compositionend",function(){n.composing&&(n.poll(),n.composing.range.clear(),n.composing=null)})},Qs.prototype.prepareSelection=function(){var e=this.cm,t=e.display,r=e.doc,n=Tr(e);if(e.options.moveInputWithCursor){var i=sr(e,r.sel.primary().head,"div"),o=t.wrapper.getBoundingClientRect(),l=t.lineDiv.getBoundingClientRect();n.teTop=Math.max(0,Math.min(t.wrapper.clientHeight-10,i.top+l.top-o.top)),n.teLeft=Math.max(0,Math.min(t.wrapper.clientWidth-10,i.left+l.left-o.left))}return n},Qs.prototype.showSelection=function(e){var t=this.cm.display;r(t.cursorDiv,e.cursors),r(t.selectionDiv,e.selection),null!=e.teTop&&(this.wrapper.style.top=e.teTop+"px",this.wrapper.style.left=e.teLeft+"px")},Qs.prototype.reset=function(e){if(!this.contextMenuPending&&!this.composing){var t=this.cm;if(t.somethingSelected()){this.prevInput="";var r=t.getSelection();this.textarea.value=r,t.state.focused&&El(this.textarea),gl&&vl>=9&&(this.hasSelection=r)}else e||(this.prevInput=this.textarea.value="",gl&&vl>=9&&(this.hasSelection=null))}},Qs.prototype.getField=function(){return this.textarea},Qs.prototype.supportsTouch=function(){return!1},Qs.prototype.focus=function(){if("nocursor"!=this.cm.options.readOnly&&(!Tl||l()!=this.textarea))try{this.textarea.focus()}catch(e){}},Qs.prototype.blur=function(){this.textarea.blur()},Qs.prototype.resetPosition=function(){this.wrapper.style.top=this.wrapper.style.left=0},Qs.prototype.receivedFocus=function(){this.slowPoll()},Qs.prototype.slowPoll=function(){var e=this;this.pollingFast||this.polling.set(this.cm.options.pollInterval,function(){e.poll(),e.cm.state.focused&&e.slowPoll()})},Qs.prototype.fastPoll=function(){function e(){r.poll()||t?(r.pollingFast=!1,r.slowPoll()):(t=!0,r.polling.set(60,e))}var t=!1,r=this;r.pollingFast=!0,r.polling.set(20,e)},Qs.prototype.poll=function(){var e=this,t=this.cm,r=this.textarea,n=this.prevInput;if(this.contextMenuPending||!t.state.focused||ts(r)&&!n&&!this.composing||t.isReadOnly()||t.options.disableInput||t.state.keySeq)return!1;var i=r.value;if(i==n&&!t.somethingSelected())return!1;if(gl&&vl>=9&&this.hasSelection===i||Ml&&/[\uf700-\uf7ff]/.test(i))return t.display.input.reset(),!1;if(t.doc.sel==t.display.selForContextMenu){var o=i.charCodeAt(0);if(8203!=o||n||(n="​"),8666==o)return this.reset(),this.cm.execCommand("undo")}for(var l=0,s=Math.min(n.length,i.length);l<s&&n.charCodeAt(l)==i.charCodeAt(l);)++l;return hn(t,function(){$o(t,i.slice(l),n.length-l,null,e.composing?"*compose":null),i.length>1e3||i.indexOf("\n")>-1?r.value=e.prevInput="":e.prevInput=i,e.composing&&(e.composing.range.clear(),e.composing.range=t.markText(e.composing.start,t.getCursor("to"),{className:"CodeMirror-composing"}))}),!0},Qs.prototype.ensurePolled=function(){this.pollingFast&&this.poll()&&(this.pollingFast=!1)},Qs.prototype.onKeyPress=function(){gl&&vl>=9&&(this.hasSelection=null),this.fastPoll()},Qs.prototype.onContextMenu=function(e){function t(){if(null!=l.selectionStart){var e=i.somethingSelected(),t="​"+(e?l.value:"");l.value="⇚",l.value=t,n.prevInput=e?"":"​",l.selectionStart=1,l.selectionEnd=t.length,o.selForContextMenu=i.doc.sel}}function r(){if(n.contextMenuPending=!1,n.wrapper.style.cssText=c,l.style.cssText=u,gl&&vl<9&&o.scrollbars.setScrollTop(o.scroller.scrollTop=a),null!=l.selectionStart){(!gl||gl&&vl<9)&&t();var e=0,r=function(){o.selForContextMenu==i.doc.sel&&0==l.selectionStart&&l.selectionEnd>0&&"​"==n.prevInput?dn(i,Mi)(i):e++<10?o.detectingSelectAll=setTimeout(r,500):(o.selForContextMenu=null,o.input.reset())};o.detectingSelectAll=setTimeout(r,200)}}var n=this,i=n.cm,o=i.display,l=n.textarea,s=Sr(i,e),a=o.scroller.scrollTop;if(s&&!wl){i.options.resetSelectionOnContextMenu&&-1==i.doc.sel.contains(s)&&dn(i,bi)(i.doc,Rn(s),Gl);var u=l.style.cssText,c=n.wrapper.style.cssText;n.wrapper.style.cssText="position: absolute";var f=n.wrapper.getBoundingClientRect();l.style.cssText="position: absolute; width: 30px; height: 30px;\n      top: "+(e.clientY-f.top-5)+"px; left: "+(e.clientX-f.left-5)+"px;\n      z-index: 1000; background: "+(gl?"rgba(255, 255, 255, .05)":"transparent")+";\n      outline: none; border-width: 0; outline: none; overflow: hidden; opacity: .05; filter: alpha(opacity=5);";var h;if(ml&&(h=window.scrollY),o.input.focus(),ml&&window.scrollTo(null,h),o.input.reset(),i.somethingSelected()||(l.value=n.prevInput=" "),n.contextMenuPending=!0,o.selForContextMenu=i.doc.sel,clearTimeout(o.detectingSelectAll),gl&&vl>=9&&t(),Hl){Fe(e);var d=function(){ke(window,"mouseup",d),setTimeout(r,20)};Ql(window,"mouseup",d)}else setTimeout(r,50)}},Qs.prototype.readOnlyChanged=function(e){e||this.reset(),this.textarea.disabled="nocursor"==e},Qs.prototype.setUneditable=function(){},Qs.prototype.needsContentAttribute=!1,function(e){function t(t,n,i,o){e.defaults[t]=n,i&&(r[t]=o?function(e,t,r){r!=Xs&&i(e,t,r)}:i)}var r=e.optionHandlers;e.defineOption=t,e.Init=Xs,t("value","",function(e,t){return e.setValue(t)},!0),t("mode",null,function(e,t){e.doc.modeOption=t,jn(e)},!0),t("indentUnit",2,jn,!0),t("indentWithTabs",!1),t("smartIndent",!0),t("tabSize",4,function(e){Xn(e),er(e),vn(e)},!0),t("lineSeparator",null,function(e,t){if(e.doc.lineSep=t,t){var r=[],n=e.doc.first;e.doc.iter(function(e){for(var i=0;;){var o=e.text.indexOf(t,i);if(-1==o)break;i=o+t.length,r.push(E(n,o))}n++});for(var i=r.length-1;i>=0;i--)Ei(e.doc,t,r[i],E(r[i].line,r[i].ch+t.length))}}),t("specialChars",/[\u0000-\u001f\u007f-\u009f\u00ad\u061c\u200b-\u200f\u2028\u2029\ufeff]/g,function(e,t,r){e.state.specialChars=new RegExp(t.source+(t.test("\t")?"":"|\t"),"g"),r!=Xs&&e.refresh()}),t("specialCharPlaceholder",at,function(e){return e.refresh()},!0),t("electricChars",!0),t("inputStyle",Tl?"contenteditable":"textarea",function(){throw new Error("inputStyle can not (yet) be changed in a running editor")},!0),t("spellcheck",!1,function(e,t){return e.getInputField().spellcheck=t},!0),t("rtlMoveVisually",!Ol),t("wholeLineUpdateBefore",!0),t("theme","default",function(e){Go(e),Uo(e)},!0),t("keyMap","default",function(e,t,r){var n=uo(t),i=r!=Xs&&uo(r);i&&i.detach&&i.detach(e,n),n.attach&&n.attach(e,i||null)}),t("extraKeys",null),t("configureMouse",null),t("lineWrapping",!1,Ko,!0),t("gutters",[],function(e){Fn(e.options),Uo(e)},!0),t("fixedGutter",!0,function(e,t){e.display.gutters.style.left=t?wr(e.display)+"px":"0",e.refresh()},!0),t("coverGutterNextToScrollbar",!1,function(e){return en(e)},!0),t("scrollbarStyle","native",function(e){rn(e),en(e),e.display.scrollbars.setScrollTop(e.doc.scrollTop),e.display.scrollbars.setScrollLeft(e.doc.scrollLeft)},!0),t("lineNumbers",!1,function(e){Fn(e.options),Uo(e)},!0),t("firstLineNumber",1,Uo,!0),t("lineNumberFormatter",function(e){return e},Uo,!0),t("showCursorWhenSelecting",!1,kr,!0),t("resetSelectionOnContextMenu",!0),t("lineWiseCopyCut",!0),t("pasteLinesPerSelection",!0),t("readOnly",!1,function(e,t){"nocursor"==t&&(Fr(e),e.display.input.blur()),e.display.input.readOnlyChanged(t)}),t("disableInput",!1,function(e,t){t||e.display.input.reset()},!0),t("dragDrop",!0,Vo),t("allowDropFileTypes",null),t("cursorBlinkRate",530),t("cursorScrollMargin",0),t("cursorHeight",1,kr,!0),t("singleCursorHeightPerLine",!0,kr,!0),t("workTime",100),t("workDelay",100),t("flattenSpans",!0,Xn,!0),t("addModeClass",!1,Xn,!0),t("pollInterval",100),t("undoDepth",200,function(e,t){return e.doc.history.undoDepth=t}),t("historyEventDelay",1250),t("viewportMargin",10,function(e){return e.refresh()},!0),t("maxHighlightLength",1e4,Xn,!0),t("moveInputWithCursor",!0,function(e,t){t||e.display.input.resetPosition()}),t("tabindex",null,function(e,t){return e.display.input.getField().tabIndex=t||""}),t("autofocus",null),t("direction","ltr",function(e,t){return e.doc.setDirection(t)},!0)}(jo),function(e){var t=e.optionHandlers,r=e.helpers={};e.prototype={constructor:e,focus:function(){window.focus(),this.display.input.focus()},setOption:function(e,r){var n=this.options,i=n[e];n[e]==r&&"mode"!=e||(n[e]=r,t.hasOwnProperty(e)&&dn(this,t[e])(this,r,i),Te(this,"optionChange",this,e))},getOption:function(e){return this.options[e]},getDoc:function(){return this.doc},addKeyMap:function(e,t){this.state.keyMaps[t?"push":"unshift"](uo(e))},removeKeyMap:function(e){for(var t=this.state.keyMaps,r=0;r<t.length;++r)if(t[r]==e||t[r].name==e)return t.splice(r,1),!0},addOverlay:pn(function(t,r){var n=t.token?t:e.getMode(this.options,t);if(n.startState)throw new Error("Overlays may not be stateful.");m(this.state.overlays,{mode:n,modeSpec:t,opaque:r&&r.opaque,priority:r&&r.priority||0},function(e){return e.priority}),this.state.modeGen++,vn(this)}),removeOverlay:pn(function(e){for(var t=this,r=this.state.overlays,n=0;n<r.length;++n){var i=r[n].modeSpec;if(i==e||"string"==typeof e&&i.name==e)return r.splice(n,1),t.state.modeGen++,void vn(t)}}),indentLine:pn(function(e,t,r){"string"!=typeof t&&"number"!=typeof t&&(t=null==t?this.options.smartIndent?"smart":"prev":t?"add":"subtract"),H(this.doc,e)&&Yo(this,e,t,r)}),indentSelection:pn(function(e){for(var t=this,r=this.doc.sel.ranges,n=-1,i=0;i<r.length;i++){var o=r[i];if(o.empty())o.head.line>n&&(Yo(t,o.head.line,e,!0),n=o.head.line,i==t.doc.sel.primIndex&&jr(t));else{var l=o.from(),s=o.to(),a=Math.max(n,l.line);n=Math.min(t.lastLine(),s.line-(s.ch?0:1))+1;for(var u=a;u<n;++u)Yo(t,u,e);var c=t.doc.sel.ranges;0==l.ch&&r.length==c.length&&c[i].from().ch>0&&gi(t.doc,i,new Ts(l,c[i].to()),Gl)}}}),getTokenAt:function(e,t){return Je(this,e,t)},getLineTokens:function(e,t){return Je(this,E(e),t,!0)},getTokenTypeAt:function(e){e=U(this.doc,e);var t,r=_e(this,M(this.doc,e.line)),n=0,i=(r.length-1)/2,o=e.ch;if(0==o)t=r[2];else for(;;){var l=n+i>>1;if((l?r[2*l-1]:0)>=o)i=l;else{if(!(r[2*l+1]<o)){t=r[2*l+2];break}n=l+1}}var s=t?t.indexOf("overlay "):-1;return s<0?t:0==s?null:t.slice(0,s-1)},getModeAt:function(t){var r=this.doc.mode;return r.innerMode?e.innerMode(r,this.getTokenAt(t).state).mode:r},getHelper:function(e,t){return this.getHelpers(e,t)[0]},getHelpers:function(e,t){var n=this,i=[];if(!r.hasOwnProperty(t))return i;var o=r[t],l=this.getModeAt(e);if("string"==typeof l[t])o[l[t]]&&i.push(o[l[t]]);else if(l[t])for(var s=0;s<l[t].length;s++){var a=o[l[t][s]];a&&i.push(a)}else l.helperType&&o[l.helperType]?i.push(o[l.helperType]):o[l.name]&&i.push(o[l.name]);for(var u=0;u<o._global.length;u++){var c=o._global[u];c.pred(l,n)&&-1==h(i,c.val)&&i.push(c.val)}return i},getStateAfter:function(e,t){var r=this.doc;return e=G(r,null==e?r.first+r.size-1:e),$e(this,e+1,t).state},cursorCoords:function(e,t){var r,n=this.doc.sel.primary();return r=null==e?n.head:"object"==typeof e?U(this.doc,e):e?n.from():n.to(),sr(this,r,t||"page")},charCoords:function(e,t){return lr(this,U(this.doc,e),t||"page")},coordsChar:function(e,t){return e=or(this,e,t||"page"),cr(this,e.left,e.top)},lineAtHeight:function(e,t){return e=or(this,{top:e,left:0},t||"page").top,D(this.doc,e+this.display.viewOffset)},heightAtLine:function(e,t,r){var n,i=!1;if("number"==typeof e){var o=this.doc.first+this.doc.size-1;e<this.doc.first?e=this.doc.first:e>o&&(e=o,i=!0),n=M(this.doc,e)}else n=e;return ir(this,n,{top:0,left:0},t||"page",r||i).top+(i?this.doc.height-ye(n):0)},defaultTextHeight:function(){return mr(this.display)},defaultCharWidth:function(){return yr(this.display)},getViewport:function(){return{from:this.display.viewFrom,to:this.display.viewTo}},addWidget:function(e,t,r,n,i){var o=this.display,l=(e=sr(this,U(this.doc,e))).bottom,s=e.left;if(t.style.position="absolute",t.setAttribute("cm-ignore-events","true"),this.display.input.setUneditable(t),o.sizer.appendChild(t),"over"==n)l=e.top;else if("above"==n||"near"==n){var a=Math.max(o.wrapper.clientHeight,this.doc.height),u=Math.max(o.sizer.clientWidth,o.lineSpace.clientWidth);("above"==n||e.bottom+t.offsetHeight>a)&&e.top>t.offsetHeight?l=e.top-t.offsetHeight:e.bottom+t.offsetHeight<=a&&(l=e.bottom),s+t.offsetWidth>u&&(s=u-t.offsetWidth)}t.style.top=l+"px",t.style.left=t.style.right="","right"==i?(s=o.sizer.clientWidth-t.offsetWidth,t.style.right="0px"):("left"==i?s=0:"middle"==i&&(s=(o.sizer.clientWidth-t.offsetWidth)/2),t.style.left=s+"px"),r&&Ur(this,{left:s,top:l,right:s+t.offsetWidth,bottom:l+t.offsetHeight})},triggerOnKeyDown:pn(Lo),triggerOnKeyPress:pn(Mo),triggerOnKeyUp:To,triggerOnMouseDown:pn(Oo),execCommand:function(e){if(Bs.hasOwnProperty(e))return Bs[e].call(null,this)},triggerElectric:pn(function(e){Zo(this,e)}),findPosH:function(e,t,r,n){var i=this,o=1;t<0&&(o=-1,t=-t);for(var l=U(this.doc,e),s=0;s<t&&!(l=tl(i.doc,l,o,r,n)).hitSide;++s);return l},moveH:pn(function(e,t){var r=this;this.extendSelectionsBy(function(n){return r.display.shift||r.doc.extend||n.empty()?tl(r.doc,n.head,e,t,r.options.rtlMoveVisually):e<0?n.from():n.to()},Vl)}),deleteH:pn(function(e,t){var r=this.doc.sel,n=this.doc;r.somethingSelected()?n.replaceSelection("",null,"+delete"):co(this,function(r){var i=tl(n,r.head,e,t,!1);return e<0?{from:i,to:r.head}:{from:r.head,to:i}})}),findPosV:function(e,t,r,n){var i=this,o=1,l=n;t<0&&(o=-1,t=-t);for(var s=U(this.doc,e),a=0;a<t;++a){var u=sr(i,s,"div");if(null==l?l=u.left:u.left=l,(s=rl(i,u,o,r)).hitSide)break}return s},moveV:pn(function(e,t){var r=this,n=this.doc,i=[],o=!this.display.shift&&!n.extend&&n.sel.somethingSelected();if(n.extendSelectionsBy(function(l){if(o)return e<0?l.from():l.to();var s=sr(r,l.head,"div");null!=l.goalColumn&&(s.left=l.goalColumn),i.push(s.left);var a=rl(r,s,e,t);return"page"==t&&l==n.sel.primary()&&Kr(r,lr(r,a,"div").top-s.top),a},Vl),i.length)for(var l=0;l<n.sel.ranges.length;l++)n.sel.ranges[l].goalColumn=i[l]}),findWordAt:function(e){var t=M(this.doc,e.line).text,r=e.ch,n=e.ch;if(t){var i=this.getHelper(e,"wordChars");"before"!=e.sticky&&n!=t.length||!r?++n:--r;for(var o=t.charAt(r),l=x(o,i)?function(e){return x(e,i)}:/\s/.test(o)?function(e){return/\s/.test(e)}:function(e){return!/\s/.test(e)&&!x(e)};r>0&&l(t.charAt(r-1));)--r;for(;n<t.length&&l(t.charAt(n));)++n}return new Ts(E(e.line,r),E(e.line,n))},toggleOverwrite:function(e){null!=e&&e==this.state.overwrite||((this.state.overwrite=!this.state.overwrite)?s(this.display.cursorDiv,"CodeMirror-overwrite"):Fl(this.display.cursorDiv,"CodeMirror-overwrite"),Te(this,"overwriteToggle",this,this.state.overwrite))},hasFocus:function(){return this.display.input.getField()==l()},isReadOnly:function(){return!(!this.options.readOnly&&!this.doc.cantEdit)},scrollTo:pn(function(e,t){Xr(this,e,t)}),getScrollInfo:function(){var e=this.display.scroller;return{left:e.scrollLeft,top:e.scrollTop,height:e.scrollHeight-zt(this)-this.display.barHeight,width:e.scrollWidth-zt(this)-this.display.barWidth,clientHeight:Bt(this),clientWidth:Rt(this)}},scrollIntoView:pn(function(e,t){null==e?(e={from:this.doc.sel.primary().head,to:null},null==t&&(t=this.options.cursorScrollMargin)):"number"==typeof e?e={from:E(e,0),to:null}:null==e.from&&(e={from:e,to:null}),e.to||(e.to=e.from),e.margin=t||0,null!=e.from.line?Yr(this,e):$r(this,e.from,e.to,e.margin)}),setSize:pn(function(e,t){var r=this,n=function(e){return"number"==typeof e||/^\d+$/.test(String(e))?e+"px":e};null!=e&&(this.display.wrapper.style.width=n(e)),null!=t&&(this.display.wrapper.style.height=n(t)),this.options.lineWrapping&&Jt(this);var i=this.display.viewFrom;this.doc.iter(i,this.display.viewTo,function(e){if(e.widgets)for(var t=0;t<e.widgets.length;t++)if(e.widgets[t].noHScroll){mn(r,i,"widget");break}++i}),this.curOp.forceUpdate=!0,Te(this,"refresh",this)}),operation:function(e){return hn(this,e)},startOperation:function(){return nn(this)},endOperation:function(){return on(this)},refresh:pn(function(){var e=this.display.cachedTextHeight;vn(this),this.curOp.forceUpdate=!0,er(this),Xr(this,this.doc.scrollLeft,this.doc.scrollTop),Wn(this),(null==e||Math.abs(e-mr(this.display))>.5)&&Cr(this),Te(this,"refresh",this)}),swapDoc:pn(function(e){var t=this.doc;return t.cm=null,qn(this,e),er(this),this.display.input.reset(),Xr(this,e.scrollLeft,e.scrollTop),this.curOp.forceScroll=!0,bt(this,"swapDoc",this,t),t}),getInputField:function(){return this.display.input.getField()},getWrapperElement:function(){return this.display.wrapper},getScrollerElement:function(){return this.display.scroller},getGutterElement:function(){return this.display.gutters}},Ae(e),e.registerHelper=function(t,n,i){r.hasOwnProperty(t)||(r[t]=e[t]={_global:[]}),r[t][n]=i},e.registerGlobalHelper=function(t,n,i,o){e.registerHelper(t,n,o),r[t]._global.push({pred:i,val:o})}}(jo);var Js="iter insert remove copy getEditor constructor".split(" ");for(var ea in Ds.prototype)Ds.prototype.hasOwnProperty(ea)&&h(Js,ea)<0&&(jo.prototype[ea]=function(e){return function(){return e.apply(this.doc,arguments)}}(Ds.prototype[ea]));return Ae(Ds),jo.inputStyles={textarea:Qs,contenteditable:Zs},jo.defineMode=function(e){jo.defaults.mode||"null"==e||(jo.defaults.mode=e),Be.apply(this,arguments)},jo.defineMIME=function(e,t){os[e]=t},jo.defineMode("null",function(){return{token:function(e){return e.skipToEnd()}}}),jo.defineMIME("text/plain","null"),jo.defineExtension=function(e,t){jo.prototype[e]=t},jo.defineDocExtension=function(e,t){Ds.prototype[e]=t},jo.fromTextArea=function(e,t){function r(){e.value=a.getValue()}if(t=t?c(t):{},t.value=e.value,!t.tabindex&&e.tabIndex&&(t.tabindex=e.tabIndex),!t.placeholder&&e.placeholder&&(t.placeholder=e.placeholder),null==t.autofocus){var n=l();t.autofocus=n==e||null!=e.getAttribute("autofocus")&&n==document.body}var i;if(e.form&&(Ql(e.form,"submit",r),!t.leaveSubmitMethodAlone)){var o=e.form;i=o.submit;try{var s=o.submit=function(){r(),o.submit=i,o.submit(),o.submit=s}}catch(e){}}t.finishInit=function(t){t.save=r,t.getTextArea=function(){return e},t.toTextArea=function(){t.toTextArea=isNaN,r(),e.parentNode.removeChild(t.getWrapperElement()),e.style.display="",e.form&&(ke(e.form,"submit",r),"function"==typeof e.form.submit&&(e.form.submit=i))}},e.style.display="none";var a=jo(function(t){return e.parentNode.insertBefore(t,e.nextSibling)},t);return a},function(e){e.off=ke,e.on=Ql,e.wheelEventPixels=Pn,e.Doc=Ds,e.splitLines=es,e.countColumn=f,e.findColumn=d,e.isWordChar=w,e.Pass=Bl,e.signal=Te,e.Line=fs,e.changeEnd=Bn,e.scrollbarModel=ws,e.Pos=E,e.cmpPos=P,e.modes=is,e.mimeModes=os,e.resolveMode=Ge,e.getMode=Ue,e.modeExtensions=ls,e.extendMode=Ve,e.copyState=Ke,e.startState=Xe,e.innerMode=je,e.commands=Bs,e.keyMap=Rs,e.keyName=ao,e.isModifierKey=lo,e.lookupKey=oo,e.normalizeKeyMap=io,e.StringStream=ss,e.SharedTextMarker=As,e.TextMarker=Os,e.LineWidget=Ms,e.e_preventDefault=We,e.e_stopPropagation=De,e.e_stop=Fe,e.addClass=s,e.contains=o,e.rmClass=Fl,e.keyNames=Es}(jo),jo.version="5.30.0",jo});
      !function(e){"object"==typeof exports&&"object"==typeof module?e(require("../../lib/codemirror")):"function"==typeof define&&define.amd?define(["../../lib/codemirror"],e):e(CodeMirror)}(function(e){"use strict";function t(e,t,n,r,o,a){this.indented=e,this.column=t,this.type=n,this.info=r,this.align=o,this.prev=a}function n(e,n,r,o){var a=e.indented;return e.context&&"statement"==e.context.type&&"statement"!=r&&(a=e.context.indented),e.context=new t(a,n,r,o,null,e.context)}function r(e){var t=e.context.type;return")"!=t&&"]"!=t&&"}"!=t||(e.indented=e.context.indented),e.context=e.context.prev}function o(e,t,n){return"variable"==t.prevToken||"type"==t.prevToken||(!!/\S(?:[^- ]>|[*\]])\s*$|\*$/.test(e.string.slice(0,n))||(!(!t.typeAtEndOfLine||e.column()!=e.indentation())||void 0))}function a(e){for(;;){if(!e||"top"==e.type)return!0;if("}"==e.type&&"namespace"!=e.prev.info)return!1;e=e.prev}}function i(e){for(var t={},n=e.split(" "),r=0;r<n.length;++r)t[n[r]]=!0;return t}function l(e,t){return"function"==typeof e?e(t):e.propertyIsEnumerable(t)}function s(e,t){if(!t.startOfLine)return!1;for(var n,r=null;n=e.peek();){if("\\"==n&&e.match(/^.$/)){r=s;break}if("/"==n&&e.match(/^\/[\/\*]/,!1))break;e.next()}return t.tokenize=r,"meta"}function c(e,t){return"type"==t.prevToken&&"type"}function u(e){return e.eatWhile(/[\w\.']/),"number"}function d(e,t){if(e.backUp(1),e.match(/(R|u8R|uR|UR|LR)/)){var n=e.match(/"([^\s\\()]{0,16})\(/);return!!n&&(t.cpp11RawStringDelim=n[1],t.tokenize=m,m(e,t))}return e.match(/(u8|u|U|L)/)?!!e.match(/["']/,!1)&&"string":(e.next(),!1)}function f(e){var t=/(\w+)::~?(\w+)$/.exec(e);return t&&t[1]==t[2]}function p(e,t){for(var n;null!=(n=e.next());)if('"'==n&&!e.eat('"')){t.tokenize=null;break}return"string"}function m(e,t){var n=t.cpp11RawStringDelim.replace(/[^\w\s]/g,"\\$&");return e.match(new RegExp(".*?\\)"+n+'"'))?t.tokenize=null:e.skipToEnd(),"string"}function h(t,n){function r(e){if(e)for(var t in e)e.hasOwnProperty(t)&&o.push(t)}"string"==typeof t&&(t=[t]);var o=[];r(n.keywords),r(n.types),r(n.builtin),r(n.atoms),o.length&&(n.helperType=t[0],e.registerHelper("hintWords",t[0],o));for(var a=0;a<t.length;++a)e.defineMIME(t[a],n)}function g(e,t){for(var n=!1;!e.eol();){if(!n&&e.match('"""')){t.tokenize=null;break}n="\\"==e.next()&&!n}return"string"}function y(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!e&&!o&&t.match('"')){a=!0;break}if(e&&t.match('"""')){a=!0;break}r=t.next(),!o&&"$"==r&&t.match("{")&&t.skipTo("}"),o=!o&&"\\"==r&&!e}return!a&&e||(n.tokenize=null),"string"}}function x(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!o&&t.match('"')&&("single"==e||t.match('""'))){a=!0;break}if(!o&&t.match("``")){w=x(e),a=!0;break}r=t.next(),o="single"==e&&!o&&"\\"==r}return a&&(n.tokenize=null),"string"}}e.defineMode("clike",function(i,s){function c(e,t){var n=e.next();if(S[n]){var r=S[n](e,t);if(!1!==r)return r}if('"'==n||"'"==n)return t.tokenize=u(n),t.tokenize(e,t);if(D.test(n))return p=n,null;if(L.test(n)){if(e.backUp(1),e.match(I))return"number";e.next()}if("/"==n){if(e.eat("*"))return t.tokenize=d,d(e,t);if(e.eat("/"))return e.skipToEnd(),"comment"}if(F.test(n)){for(;!e.match(/^\/[\/*]/,!1)&&e.eat(F););return"operator"}if(e.eatWhile(z),P)for(;e.match(P);)e.eatWhile(z);var o=e.current();return l(x,o)?(l(w,o)&&(p="newstatement"),l(v,o)&&(m=!0),"keyword"):l(b,o)?"type":l(k,o)?(l(w,o)&&(p="newstatement"),"builtin"):l(_,o)?"atom":"variable"}function u(e){return function(t,n){for(var r,o=!1,a=!1;null!=(r=t.next());){if(r==e&&!o){a=!0;break}o=!o&&"\\"==r}return(a||!o&&!C)&&(n.tokenize=null),"string"}}function d(e,t){for(var n,r=!1;n=e.next();){if("/"==n&&r){t.tokenize=null;break}r="*"==n}return"comment"}function f(e,t){s.typeFirstDefinitions&&e.eol()&&a(t.context)&&(t.typeAtEndOfLine=o(e,t,e.pos))}var p,m,h=i.indentUnit,g=s.statementIndentUnit||h,y=s.dontAlignCalls,x=s.keywords||{},b=s.types||{},k=s.builtin||{},w=s.blockKeywords||{},v=s.defKeywords||{},_=s.atoms||{},S=s.hooks||{},C=s.multiLineStrings,T=!1!==s.indentStatements,M=!1!==s.indentSwitch,P=s.namespaceSeparator,D=s.isPunctuationChar||/[\[\]{}\(\),;\:\.]/,L=s.numberStart||/[\d\.]/,I=s.number||/^(?:0x[a-f\d]+|0b[01]+|(?:\d+\.?\d*|\.\d+)(?:e[-+]?\d+)?)(u|ll?|l|f)?/i,F=s.isOperatorChar||/[+\-*&%=<>!?|\/]/,z=s.isIdentifierChar||/[\w\$_\xa1-\uffff]/;return{startState:function(e){return{tokenize:null,context:new t((e||0)-h,0,"top",null,!1),indented:0,startOfLine:!0,prevToken:null}},token:function(e,t){var i=t.context;if(e.sol()&&(null==i.align&&(i.align=!1),t.indented=e.indentation(),t.startOfLine=!0),e.eatSpace())return f(e,t),null;p=m=null;var l=(t.tokenize||c)(e,t);if("comment"==l||"meta"==l)return l;if(null==i.align&&(i.align=!0),";"==p||":"==p||","==p&&e.match(/^\s*(?:\/\/.*)?$/,!1))for(;"statement"==t.context.type;)r(t);else if("{"==p)n(t,e.column(),"}");else if("["==p)n(t,e.column(),"]");else if("("==p)n(t,e.column(),")");else if("}"==p){for(;"statement"==i.type;)i=r(t);for("}"==i.type&&(i=r(t));"statement"==i.type;)i=r(t)}else p==i.type?r(t):T&&(("}"==i.type||"top"==i.type)&&";"!=p||"statement"==i.type&&"newstatement"==p)&&n(t,e.column(),"statement",e.current());if("variable"==l&&("def"==t.prevToken||s.typeFirstDefinitions&&o(e,t,e.start)&&a(t.context)&&e.match(/^\s*\(/,!1))&&(l="def"),S.token){var u=S.token(e,t,l);void 0!==u&&(l=u)}return"def"==l&&!1===s.styleDefs&&(l="variable"),t.startOfLine=!1,t.prevToken=m?"def":l||p,f(e,t),l},indent:function(t,n){if(t.tokenize!=c&&null!=t.tokenize||t.typeAtEndOfLine)return e.Pass;var r=t.context,o=n&&n.charAt(0);if("statement"==r.type&&"}"==o&&(r=r.prev),s.dontIndentStatements)for(;"statement"==r.type&&s.dontIndentStatements.test(r.info);)r=r.prev;if(S.indent){var a=S.indent(t,r,n);if("number"==typeof a)return a}var i=o==r.type,l=r.prev&&"switch"==r.prev.info;if(s.allmanIndentation&&/[{(]/.test(o)){for(;"top"!=r.type&&"}"!=r.type;)r=r.prev;return r.indented}return"statement"==r.type?r.indented+("{"==o?0:g):!r.align||y&&")"==r.type?")"!=r.type||i?r.indented+(i?0:h)+(i||!l||/^(?:case|default)\b/.test(n)?0:h):r.indented+g:r.column+(i?0:1)},electricInput:M?/^\s*(?:case .*?:|default:|\{\}?|\})$/:/^\s*[{}]$/,blockCommentStart:"/*",blockCommentEnd:"*/",lineComment:"//",fold:"brace"}});var b="auto if break case register continue return default do sizeof static else struct switch extern typedef union for goto while enum const volatile",k="int long char short double float unsigned signed void size_t ptrdiff_t";h(["text/x-csrc","text/x-c","text/x-chdr"],{name:"clike",keywords:i(b),types:i(k+" bool _Complex _Bool float_t double_t intptr_t intmax_t int8_t int16_t int32_t int64_t uintptr_t uintmax_t uint8_t uint16_t uint32_t uint64_t"),blockKeywords:i("case do else for if switch while struct"),defKeywords:i("struct"),typeFirstDefinitions:!0,atoms:i("null true false"),hooks:{"#":s,"*":c},modeProps:{fold:["brace","include"]}}),h(["text/x-c++src","text/x-c++hdr"],{name:"clike",keywords:i(b+" asm dynamic_cast namespace reinterpret_cast try explicit new static_cast typeid catch operator template typename class friend private this using const_cast inline public throw virtual delete mutable protected alignas alignof constexpr decltype nullptr noexcept thread_local final static_assert override"),types:i(k+" bool wchar_t"),blockKeywords:i("catch class do else finally for if struct switch try while"),defKeywords:i("class namespace struct enum union"),typeFirstDefinitions:!0,atoms:i("true false null"),dontIndentStatements:/^template$/,isIdentifierChar:/[\w\$_~\xa1-\uffff]/,hooks:{"#":s,"*":c,u:d,U:d,L:d,R:d,0:u,1:u,2:u,3:u,4:u,5:u,6:u,7:u,8:u,9:u,token:function(e,t,n){if("variable"==n&&"("==e.peek()&&(";"==t.prevToken||null==t.prevToken||"}"==t.prevToken)&&f(e.current()))return"def"}},namespaceSeparator:"::",modeProps:{fold:["brace","include"]}}),h("text/x-java",{name:"clike",keywords:i("abstract assert break case catch class const continue default do else enum extends final finally float for goto if implements import instanceof interface native new package private protected public return static strictfp super switch synchronized this throw throws transient try volatile while @interface"),types:i("byte short int long float double boolean char void Boolean Byte Character Double Float Integer Long Number Object Short String StringBuffer StringBuilder Void"),blockKeywords:i("catch class do else finally for if switch try while"),defKeywords:i("class interface package enum @interface"),typeFirstDefinitions:!0,atoms:i("true false null"),number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,hooks:{"@":function(e){return!e.match("interface",!1)&&(e.eatWhile(/[\w\$_]/),"meta")}},modeProps:{fold:["brace","import"]}}),h("text/x-csharp",{name:"clike",keywords:i("abstract as async await base break case catch checked class const continue default delegate do else enum event explicit extern finally fixed for foreach goto if implicit in interface internal is lock namespace new operator out override params private protected public readonly ref return sealed sizeof stackalloc static struct switch this throw try typeof unchecked unsafe using virtual void volatile while add alias ascending descending dynamic from get global group into join let orderby partial remove select set value var yield"),types:i("Action Boolean Byte Char DateTime DateTimeOffset Decimal Double Func Guid Int16 Int32 Int64 Object SByte Single String Task TimeSpan UInt16 UInt32 UInt64 bool byte char decimal double short int long object sbyte float string ushort uint ulong"),blockKeywords:i("catch class do else finally for foreach if struct switch try while"),defKeywords:i("class interface namespace struct var"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"@":function(e,t){return e.eat('"')?(t.tokenize=p,p(e,t)):(e.eatWhile(/[\w\$_]/),"meta")}}}),h("text/x-scala",{name:"clike",keywords:i("abstract case catch class def do else extends final finally for forSome if implicit import lazy match new null object override package private protected return sealed super this throw trait try type val var while with yield _ assert assume require print println printf readLine readBoolean readByte readShort readChar readInt readLong readFloat readDouble"),types:i("AnyVal App Application Array BufferedIterator BigDecimal BigInt Char Console Either Enumeration Equiv Error Exception Fractional Function IndexedSeq Int Integral Iterable Iterator List Map Numeric Nil NotNull Option Ordered Ordering PartialFunction PartialOrdering Product Proxy Range Responder Seq Serializable Set Specializable Stream StringBuilder StringContext Symbol Throwable Traversable TraversableOnce Tuple Unit Vector Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),multiLineStrings:!0,blockKeywords:i("catch class enum do else finally for forSome if match switch try while"),defKeywords:i("class enum def object package trait type val var"),atoms:i("true false null"),indentStatements:!1,indentSwitch:!1,isOperatorChar:/[+\-*&%=<>!?|\/#:@]/,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return!!e.match('""')&&(t.tokenize=g,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},"=":function(e,n){var r=n.context;return!("}"!=r.type||!r.align||!e.eat(">"))&&(n.context=new t(r.indented,r.column,r.type,r.info,null,r.prev),"operator")}},modeProps:{closeBrackets:{triples:'"'}}}),h("text/x-kotlin",{name:"clike",keywords:i("package as typealias class interface this super val var fun for is in This throw return break continue object if else while do try when !in !is as? file import where by get set abstract enum open inner override private public internal protected catch finally out final vararg reified dynamic companion constructor init sealed field property receiver param sparam lateinit data inline noinline tailrec external annotation crossinline const operator infix suspend"),types:i("Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),intendSwitch:!1,indentStatements:!1,multiLineStrings:!0,number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,blockKeywords:i("catch class do else finally for if where try while enum"),defKeywords:i("class val var object package interface fun"),atoms:i("true false null this"),hooks:{'"':function(e,t){return t.tokenize=y(e.match('""')),t.tokenize(e,t)}},modeProps:{closeBrackets:{triples:'"'}}}),h(["x-shader/x-vertex","x-shader/x-fragment"],{name:"clike",keywords:i("sampler1D sampler2D sampler3D samplerCube sampler1DShadow sampler2DShadow const attribute uniform varying break continue discard return for while do if else struct in out inout"),types:i("float int bool void vec2 vec3 vec4 ivec2 ivec3 ivec4 bvec2 bvec3 bvec4 mat2 mat3 mat4"),blockKeywords:i("for while do if else struct"),builtin:i("radians degrees sin cos tan asin acos atan pow exp log exp2 sqrt inversesqrt abs sign floor ceil fract mod min max clamp mix step smoothstep length distance dot cross normalize ftransform faceforward reflect refract matrixCompMult lessThan lessThanEqual greaterThan greaterThanEqual equal notEqual any all not texture1D texture1DProj texture1DLod texture1DProjLod texture2D texture2DProj texture2DLod texture2DProjLod texture3D texture3DProj texture3DLod texture3DProjLod textureCube textureCubeLod shadow1D shadow2D shadow1DProj shadow2DProj shadow1DLod shadow2DLod shadow1DProjLod shadow2DProjLod dFdx dFdy fwidth noise1 noise2 noise3 noise4"),atoms:i("true false gl_FragColor gl_SecondaryColor gl_Normal gl_Vertex gl_MultiTexCoord0 gl_MultiTexCoord1 gl_MultiTexCoord2 gl_MultiTexCoord3 gl_MultiTexCoord4 gl_MultiTexCoord5 gl_MultiTexCoord6 gl_MultiTexCoord7 gl_FogCoord gl_PointCoord gl_Position gl_PointSize gl_ClipVertex gl_FrontColor gl_BackColor gl_FrontSecondaryColor gl_BackSecondaryColor gl_TexCoord gl_FogFragCoord gl_FragCoord gl_FrontFacing gl_FragData gl_FragDepth gl_ModelViewMatrix gl_ProjectionMatrix gl_ModelViewProjectionMatrix gl_TextureMatrix gl_NormalMatrix gl_ModelViewMatrixInverse gl_ProjectionMatrixInverse gl_ModelViewProjectionMatrixInverse gl_TexureMatrixTranspose gl_ModelViewMatrixInverseTranspose gl_ProjectionMatrixInverseTranspose gl_ModelViewProjectionMatrixInverseTranspose gl_TextureMatrixInverseTranspose gl_NormalScale gl_DepthRange gl_ClipPlane gl_Point gl_FrontMaterial gl_BackMaterial gl_LightSource gl_LightModel gl_FrontLightModelProduct gl_BackLightModelProduct gl_TextureColor gl_EyePlaneS gl_EyePlaneT gl_EyePlaneR gl_EyePlaneQ gl_FogParameters gl_MaxLights gl_MaxClipPlanes gl_MaxTextureUnits gl_MaxTextureCoords gl_MaxVertexAttribs gl_MaxVertexUniformComponents gl_MaxVaryingFloats gl_MaxVertexTextureImageUnits gl_MaxTextureImageUnits gl_MaxFragmentUniformComponents gl_MaxCombineTextureImageUnits gl_MaxDrawBuffers"),indentSwitch:!1,hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-nesc",{name:"clike",keywords:i(b+"as atomic async call command component components configuration event generic implementation includes interface module new norace nx_struct nx_union post provides signal task uses abstract extends"),types:i(k),blockKeywords:i("case do else for if switch while struct"),atoms:i("null true false"),hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-objectivec",{name:"clike",keywords:i(b+"inline restrict _Bool _Complex _Imaginary BOOL Class bycopy byref id IMP in inout nil oneway out Protocol SEL self super atomic nonatomic retain copy readwrite readonly"),types:i(k),atoms:i("YES NO NULL NILL ON OFF true false"),hooks:{"@":function(e){return e.eatWhile(/[\w\$]/),"keyword"},"#":s,indent:function(e,t,n){if("statement"==t.type&&/^@\w/.test(n))return t.indented}},modeProps:{fold:"brace"}}),h("text/x-squirrel",{name:"clike",keywords:i("base break clone continue const default delete enum extends function in class foreach local resume return this throw typeof yield constructor instanceof static"),types:i(k),blockKeywords:i("case catch class else for foreach if switch try while"),defKeywords:i("function local class"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"#":s},modeProps:{fold:["brace","include"]}});var w=null;h("text/x-ceylon",{name:"clike",keywords:i("abstracts alias assembly assert assign break case catch class continue dynamic else exists extends finally for function given if import in interface is let module new nonempty object of out outer package return satisfies super switch then this throw try value void while"),types:function(e){var t=e.charAt(0);return t===t.toUpperCase()&&t!==t.toLowerCase()},blockKeywords:i("case catch class dynamic else finally for function if interface module new object switch try while"),defKeywords:i("class dynamic function interface module object package value"),builtin:i("abstract actual aliased annotation by default deprecated doc final formal late license native optional sealed see serializable shared suppressWarnings tagged throws variable"),isPunctuationChar:/[\[\]{}\(\),;\:\.`]/,isOperatorChar:/[+\-*&%=<>!?|^~:\/]/,numberStart:/[\d#$]/,number:/^(?:#[\da-fA-F_]+|\$[01_]+|[\d_]+[kMGTPmunpf]?|[\d_]+\.[\d_]+(?:[eE][-+]?\d+|[kMGTPmunpf]|)|)/i,multiLineStrings:!0,typeFirstDefinitions:!0,atoms:i("true false null larger smaller equal empty finished"),indentSwitch:!1,styleDefs:!1,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return t.tokenize=x(e.match('""')?"triple":"single"),t.tokenize(e,t)},"`":function(e,t){return!(!w||!e.match("`"))&&(t.tokenize=w,w=null,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},token:function(e,t,n){if(("variable"==n||"type"==n)&&"."==t.prevToken)return"variable-2"}},modeProps:{fold:["brace","import"],closeBrackets:{triples:'"'}}})});
      // -------------------------------------------------------------------------
//  Part of the CodeChecker project, under the Apache License v2.0 with
//  LLVM Exceptions. See LICENSE for license information.
//  SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
// -------------------------------------------------------------------------

var BugViewer = {
  _files : [],
  _reports : [],
  _lineWidgets : [],
  _navigationMenuItems : [],
  _sourceFileData : null,
  _currentReport : null,
  _lastBugEvent  : null,

  init : function (files, reports) {
    this._files = files;
    this._reports = reports;

    this.initEscapeChars();
  },

  initEscapeChars : function () {
    this.escapeChars = {
      ' ' : 'nbsp',
      '<' : 'lt',
      '>' : 'gt',
      '"' : 'quot',
      '&' : 'amp'
    };

    var regexString = '[';
    for (var key in this.escapeChars) {
      regexString += key;
    }
    regexString += ']';

    this.escapeRegExp = new RegExp( regexString, 'g');
  },

  escapeHTML : function (str) {
    var that = this;

    return str.replace(this.escapeRegExp, function (m) {
      return '&' + that.escapeChars[m] + ';';
    });
  },

  initByUrl : function () {
    if (!this._reports) return;

    var state = {};
    window.location.hash.substr(1).split('&').forEach(function (s) {
      var parts = s.split('=');
      state[parts[0]] = parts[1];
    });

    for (var key in this._reports) {
      var report = this._reports[key];
      if (report.reportHash === state['reportHash']) {
        this.navigate(report);
        return;
      }
    }

    this.navigate(this._reports[0]);
  },

  create : function () {
    this._content = document.getElementById('editor-wrapper');
    this._filepath = document.getElementById('file-path');
    this._checkerName = document.getElementById('checker-name');
    this._reviewStatusWrapper =
      document.getElementById('review-status-wrapper');
    this._reviewStatus = document.getElementById('review-status');
    this._editor = document.getElementById('editor');

    this._codeMirror = CodeMirror(this._editor, {
      mode: 'text/x-c++src',
      matchBrackets : true,
      lineNumbers : true,
      readOnly : true,
      foldGutter : true,
      extraKeys : {},
      viewportMargin : 100
    });

    this._createNavigationMenu();
  },

  navigate : function (report, item) {
    if (!item) {
      var items = this._navigationMenuItems.filter(function (navItem) {
        return navItem.report.reportHash === report.reportHash;
      });

      if (!items.length) return;

      item = items[0].widget;
    }

    this._selectedReport.classList.remove('active');
    this._selectedReport = item;
    this._selectedReport.classList.add('active');
    this.setReport(report);
  },

  _createNavigationMenu : function () {
    var that = this;

    var nav = document.getElementById('report-nav');
    var list = document.createElement('ul');
    this._reports.forEach(function (report) {
      var events = report['events'];
      var lastBugEvent = events[events.length - 1];
      var item = document.createElement('li');

      var severity = document.createElement('i');
      severity.className = 'severity-' + report.severity.toLowerCase();

      item.appendChild(severity);
      item.appendChild(document.createTextNode(lastBugEvent.message));

      item.addEventListener('click', function () {
        that.navigate(report, item);
      })
      list.appendChild(item);
      that._navigationMenuItems.push({ report : report, widget : item });
    });

    if (!this._selectedReport && list.childNodes.length) {
      this._selectedReport = list.childNodes[0];
      this._selectedReport.classList.add('active');
    }

    nav.appendChild(list);
  },

  setReport : function (report) {
    this._currentReport = report;
    var events = report['events'];
    var lastBugEvent = events[events.length - 1];
    this.setCurrentBugEvent(lastBugEvent, events.length - 1);
    this.setCheckerName(report.checkerName);
    this.setReviewStatus(report.reviewStatus);

    window.location.hash = '#reportHash=' + report.reportHash;
  },

  setCurrentBugEvent : function (event, idx) {
    this._currentBugEvent = event;
    this.setSourceFileData(this._files[event.location.file]);
    this.drawBugPath();

    this.jumpTo(event.location.line, 0);
    this.highlightBugEvent(event, idx);
  },

  highlightBugEvent : function (event, idx) {
    this._lineWidgets.forEach(function (widget) {
      var lineIdx = widget.node.getAttribute('idx');
      if (parseInt(lineIdx) === idx) {
        widget.node.classList.add('current');
      }
    });
  },

  setCheckerName : function (checkerName) {
    this._checkerName.innerHTML = checkerName;
  },

  setReviewStatus : function (status) {
    if (status) {
      var className =
        'review-status-' + status.toLowerCase().split(' ').join('-');
      this._reviewStatus.className = "review-status " + className;

      this._reviewStatus.innerHTML = status;
      this._reviewStatusWrapper.style.display = 'block';
    } else {
      this._reviewStatusWrapper.style.display = 'none';
    }
  },

  setSourceFileData : function (file) {
    if (this._sourceFileData && file.id === this._sourceFileData.id) {
      return;
    }

    this._sourceFileData = file;
    this._filepath.innerHTML = file.path;
    this._codeMirror.doc.setValue(file.content);
    this._refresh();
  },

  _refresh : function () {
    var that = this;
    setTimeout(function () {
      var fullHeight = parseInt(that._content.clientHeight);
      var headerHeight = that._filepath.clientHeight;

      that._codeMirror.setSize('auto', fullHeight - headerHeight);
      that._codeMirror.refresh();
    }, 200);
  },

  clearBubbles : function () {
    this._lineWidgets.forEach(function (widget) { widget.clear(); });
    this._lineWidgets = [];
  },

  getMessage : function (event, kind) {
    if (kind === 'macro') {
      var name = 'macro expansion' + (event.name ? ': ' + event.name : '');

      return '<span class="tag macro">' + name + '</span>'
        + this.escapeHTML(event.expansion).replace(/(?:\r\n|\r|\n)/g, '<br>');
    } else if (kind === 'note') {
      return '<span class="tag note">note</span>'
        +  this.escapeHTML(event.message).replace(/(?:\r\n|\r|\n)/g, '<br>');
    }
  },

  addExtraPathEvents : function (events, kind) {
    var that = this;

    if (!events) {
      return;
    }

    events.forEach(function (event) {
      if (event.location.file !== that._currentBugEvent.location.file) {
        return;
      }

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + kind);

      var msg = document.createElement('span');
      msg.innerHTML = that.getMessage(event, kind);
      element.appendChild(msg);

      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  drawBugPath : function () {
    var that = this;

    this.clearBubbles();

    this.addExtraPathEvents(this._currentReport.macros, 'macro');
    this.addExtraPathEvents(this._currentReport.notes, 'note');

    // Processing bug path events.
    var currentEvents = this._currentReport.events;
    currentEvents.forEach(function (event, step) {
      if (event.location.file !== that._currentBugEvent.location.file)
        return;

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';
      var type = step === currentEvents.length - 1 ? 'error' : 'info';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + type);
      element.setAttribute('idx', step);

      var enumeration = document.createElement('span');
      enumeration.setAttribute('class', 'checker-enum ' + type);
      enumeration.innerHTML = step + 1;

      if (currentEvents.length > 1)
        element.appendChild(enumeration);

      var prevBugEvent = step - 1;
      if (step > 0) {
        var prevBug = document.createElement('span');
        prevBug.setAttribute('class', 'arrow left-arrow');
        prevBug.addEventListener('click', function () {
          var event = currentEvents[prevBugEvent];
          that.setCurrentBugEvent(event, prevBugEvent);
        });
        element.appendChild(prevBug);
      }

      var msg = document.createElement('span');
      msg.innerHTML = that.escapeHTML(event.message)
        .replace(/(?:\r\n|\r|\n)/g, '<br>');

      element.appendChild(msg);

      var nextBugEvent = step + 1;
      if (nextBugEvent < currentEvents.length) {
        var nextBug = document.createElement('span');
        nextBug.setAttribute('class', 'arrow right-arrow');
        nextBug.addEventListener('click', function () {
          var event = currentEvents[nextBugEvent];
          that.setCurrentBugEvent(event, nextBugEvent);
        });
        element.appendChild(nextBug);
      }


      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  jumpTo : function (line, column) {
    var that = this;

    setTimeout(function () {
      var selPosPixel
        = that._codeMirror.charCoords({ line : line, ch : column }, 'local');
      var editorSize = {
        width  : that._editor.clientWidth,
        height : that._editor.clientHeight
      };

      that._codeMirror.scrollIntoView({
        top    : selPosPixel.top - 100,
        bottom : selPosPixel.top + editorSize.height - 150,
        left   : selPosPixel.left < editorSize.width - 100
               ? 0
               : selPosPixel.left - 50,
        right  : selPosPixel.left < editorSize.width - 100
               ? 10
               : selPosPixel.left + editorSize.width - 100
      });
    }, 0);
  }
}


      var data = {"files": {"17": {"id": 17, "path": "/home/vsts/work/1/llvm-project/clang/lib/Format/ContinuationIndenter.cpp", "content": "//===--- ContinuationIndenter.cpp - Format C++ code -----------------------===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n///\n/// \\file\n/// This file implements the continuation indenter.\n///\n//===----------------------------------------------------------------------===//\n\n#include \"ContinuationIndenter.h\"\n#include \"BreakableToken.h\"\n#include \"FormatInternal.h\"\n#include \"WhitespaceManager.h\"\n#include \"clang/Basic/OperatorPrecedence.h\"\n#include \"clang/Basic/SourceManager.h\"\n#include \"clang/Format/Format.h\"\n#include \"llvm/Support/Debug.h\"\n\n#define DEBUG_TYPE \"format-indenter\"\n\nnamespace clang {\nnamespace format {\n\n// Returns true if a TT_SelectorName should be indented when wrapped,\n// false otherwise.\nstatic bool shouldIndentWrappedSelectorName(const FormatStyle &Style,\n                                            LineType LineType) {\n  return Style.IndentWrappedFunctionNames || LineType == LT_ObjCMethodDecl;\n}\n\n// Returns the length of everything up to the first possible line break after\n// the ), ], } or > matching \\c Tok.\nstatic unsigned getLengthToMatchingParen(const FormatToken &Tok,\n                                         const std::vector<ParenState> &Stack) {\n  // Normally whether or not a break before T is possible is calculated and\n  // stored in T.CanBreakBefore. Braces, array initializers and text proto\n  // messages like `key: < ... >` are an exception: a break is possible\n  // before a closing brace R if a break was inserted after the corresponding\n  // opening brace. The information about whether or not a break is needed\n  // before a closing brace R is stored in the ParenState field\n  // S.BreakBeforeClosingBrace where S is the state that R closes.\n  //\n  // In order to decide whether there can be a break before encountered right\n  // braces, this implementation iterates over the sequence of tokens and over\n  // the paren stack in lockstep, keeping track of the stack level which visited\n  // right braces correspond to in MatchingStackIndex.\n  //\n  // For example, consider:\n  // L. <- line number\n  // 1. {\n  // 2. {1},\n  // 3. {2},\n  // 4. {{3}}}\n  //     ^ where we call this method with this token.\n  // The paren stack at this point contains 3 brace levels:\n  //  0. { at line 1, BreakBeforeClosingBrace: true\n  //  1. first { at line 4, BreakBeforeClosingBrace: false\n  //  2. second { at line 4, BreakBeforeClosingBrace: false,\n  //  where there might be fake parens levels in-between these levels.\n  // The algorithm will start at the first } on line 4, which is the matching\n  // brace of the initial left brace and at level 2 of the stack. Then,\n  // examining BreakBeforeClosingBrace: false at level 2, it will continue to\n  // the second } on line 4, and will traverse the stack downwards until it\n  // finds the matching { on level 1. Then, examining BreakBeforeClosingBrace:\n  // false at level 1, it will continue to the third } on line 4 and will\n  // traverse the stack downwards until it finds the matching { on level 0.\n  // Then, examining BreakBeforeClosingBrace: true at level 0, the algorithm\n  // will stop and will use the second } on line 4 to determine the length to\n  // return, as in this example the range will include the tokens: {3}}\n  //\n  // The algorithm will only traverse the stack if it encounters braces, array\n  // initializer squares or text proto angle brackets.\n  if (!Tok.MatchingParen)\n    return 0;\n  FormatToken *End = Tok.MatchingParen;\n  // Maintains a stack level corresponding to the current End token.\n  int MatchingStackIndex = Stack.size() - 1;\n  // Traverses the stack downwards, looking for the level to which LBrace\n  // corresponds. Returns either a pointer to the matching level or nullptr if\n  // LParen is not found in the initial portion of the stack up to\n  // MatchingStackIndex.\n  auto FindParenState = [&](const FormatToken *LBrace) -> const ParenState * {\n    while (MatchingStackIndex >= 0 && Stack[MatchingStackIndex].Tok != LBrace)\n      --MatchingStackIndex;\n    return MatchingStackIndex >= 0 ? &Stack[MatchingStackIndex] : nullptr;\n  };\n  for (; End->Next; End = End->Next) {\n    if (End->Next->CanBreakBefore)\n      break;\n    if (!End->Next->closesScope())\n      continue;\n    if (End->Next->MatchingParen &&\n        End->Next->MatchingParen->isOneOf(\n            tok::l_brace, TT_ArrayInitializerLSquare, tok::less)) {\n      const ParenState *State = FindParenState(End->Next->MatchingParen);\n      if (State && State->BreakBeforeClosingBrace)\n        break;\n    }\n  }\n  return End->TotalLength - Tok.TotalLength + 1;\n}\n\nstatic unsigned getLengthToNextOperator(const FormatToken &Tok) {\n  if (!Tok.NextOperator)\n    return 0;\n  return Tok.NextOperator->TotalLength - Tok.TotalLength;\n}\n\n// Returns \\c true if \\c Tok is the \".\" or \"->\" of a call and starts the next\n// segment of a builder type call.\nstatic bool startsSegmentOfBuilderTypeCall(const FormatToken &Tok) {\n  return Tok.isMemberAccess() && Tok.Previous && Tok.Previous->closesScope();\n}\n\n// Returns \\c true if \\c Current starts a new parameter.\nstatic bool startsNextParameter(const FormatToken &Current,\n                                const FormatStyle &Style) {\n  const FormatToken &Previous = *Current.Previous;\n  if (Current.is(TT_CtorInitializerComma) &&\n      Style.BreakConstructorInitializers == FormatStyle::BCIS_BeforeComma)\n    return true;\n  if (Style.Language == FormatStyle::LK_Proto && Current.is(TT_SelectorName))\n    return true;\n  return Previous.is(tok::comma) && !Current.isTrailingComment() &&\n         ((Previous.isNot(TT_CtorInitializerComma) ||\n           Style.BreakConstructorInitializers !=\n               FormatStyle::BCIS_BeforeComma) &&\n          (Previous.isNot(TT_InheritanceComma) ||\n           Style.BreakInheritanceList != FormatStyle::BILS_BeforeComma));\n}\n\nstatic bool opensProtoMessageField(const FormatToken &LessTok,\n                                   const FormatStyle &Style) {\n  if (LessTok.isNot(tok::less))\n    return false;\n  return Style.Language == FormatStyle::LK_TextProto ||\n         (Style.Language == FormatStyle::LK_Proto &&\n          (LessTok.NestingLevel > 0 ||\n           (LessTok.Previous && LessTok.Previous->is(tok::equal))));\n}\n\n// Returns the delimiter of a raw string literal, or None if TokenText is not\n// the text of a raw string literal. The delimiter could be the empty string.\n// For example, the delimiter of R\"deli(cont)deli\" is deli.\nstatic llvm::Optional<StringRef> getRawStringDelimiter(StringRef TokenText) {\n  if (TokenText.size() < 5 // The smallest raw string possible is 'R\"()\"'.\n      || !TokenText.startswith(\"R\\\"\") || !TokenText.endswith(\"\\\"\"))\n    return None;\n\n  // A raw string starts with 'R\"<delimiter>(' and delimiter is ascii and has\n  // size at most 16 by the standard, so the first '(' must be among the first\n  // 19 bytes.\n  size_t LParenPos = TokenText.substr(0, 19).find_first_of('(');\n  if (LParenPos == StringRef::npos)\n    return None;\n  StringRef Delimiter = TokenText.substr(2, LParenPos - 2);\n\n  // Check that the string ends in ')Delimiter\"'.\n  size_t RParenPos = TokenText.size() - Delimiter.size() - 2;\n  if (TokenText[RParenPos] != ')')\n    return None;\n  if (!TokenText.substr(RParenPos + 1).startswith(Delimiter))\n    return None;\n  return Delimiter;\n}\n\n// Returns the canonical delimiter for \\p Language, or the empty string if no\n// canonical delimiter is specified.\nstatic StringRef\ngetCanonicalRawStringDelimiter(const FormatStyle &Style,\n                               FormatStyle::LanguageKind Language) {\n  for (const auto &Format : Style.RawStringFormats) {\n    if (Format.Language == Language)\n      return StringRef(Format.CanonicalDelimiter);\n  }\n  return \"\";\n}\n\nRawStringFormatStyleManager::RawStringFormatStyleManager(\n    const FormatStyle &CodeStyle) {\n  for (const auto &RawStringFormat : CodeStyle.RawStringFormats) {\n    llvm::Optional<FormatStyle> LanguageStyle =\n        CodeStyle.GetLanguageStyle(RawStringFormat.Language);\n    if (!LanguageStyle) {\n      FormatStyle PredefinedStyle;\n      if (!getPredefinedStyle(RawStringFormat.BasedOnStyle,\n                              RawStringFormat.Language, &PredefinedStyle)) {\n        PredefinedStyle = getLLVMStyle();\n        PredefinedStyle.Language = RawStringFormat.Language;\n      }\n      LanguageStyle = PredefinedStyle;\n    }\n    LanguageStyle->ColumnLimit = CodeStyle.ColumnLimit;\n    for (StringRef Delimiter : RawStringFormat.Delimiters) {\n      DelimiterStyle.insert({Delimiter, *LanguageStyle});\n    }\n    for (StringRef EnclosingFunction : RawStringFormat.EnclosingFunctions) {\n      EnclosingFunctionStyle.insert({EnclosingFunction, *LanguageStyle});\n    }\n  }\n}\n\nllvm::Optional<FormatStyle>\nRawStringFormatStyleManager::getDelimiterStyle(StringRef Delimiter) const {\n  auto It = DelimiterStyle.find(Delimiter);\n  if (It == DelimiterStyle.end())\n    return None;\n  return It->second;\n}\n\nllvm::Optional<FormatStyle>\nRawStringFormatStyleManager::getEnclosingFunctionStyle(\n    StringRef EnclosingFunction) const {\n  auto It = EnclosingFunctionStyle.find(EnclosingFunction);\n  if (It == EnclosingFunctionStyle.end())\n    return None;\n  return It->second;\n}\n\nContinuationIndenter::ContinuationIndenter(const FormatStyle &Style,\n                                           const AdditionalKeywords &Keywords,\n                                           const SourceManager &SourceMgr,\n                                           WhitespaceManager &Whitespaces,\n                                           encoding::Encoding Encoding,\n                                           bool BinPackInconclusiveFunctions)\n    : Style(Style), Keywords(Keywords), SourceMgr(SourceMgr),\n      Whitespaces(Whitespaces), Encoding(Encoding),\n      BinPackInconclusiveFunctions(BinPackInconclusiveFunctions),\n      CommentPragmasRegex(Style.CommentPragmas), RawStringFormats(Style) {}\n\nLineState ContinuationIndenter::getInitialState(unsigned FirstIndent,\n                                                unsigned FirstStartColumn,\n                                                const AnnotatedLine *Line,\n                                                bool DryRun) {\n  LineState State;\n  State.FirstIndent = FirstIndent;\n  if (FirstStartColumn && Line->First->NewlinesBefore == 0)\n    State.Column = FirstStartColumn;\n  else\n    State.Column = FirstIndent;\n  // With preprocessor directive indentation, the line starts on column 0\n  // since it's indented after the hash, but FirstIndent is set to the\n  // preprocessor indent.\n  if (Style.IndentPPDirectives == FormatStyle::PPDIS_AfterHash &&\n      (Line->Type == LT_PreprocessorDirective ||\n       Line->Type == LT_ImportStatement))\n    State.Column = 0;\n  State.Line = Line;\n  State.NextToken = Line->First;\n  State.Stack.push_back(ParenState(/*Tok=*/nullptr, FirstIndent, FirstIndent,\n                                   /*AvoidBinPacking=*/false,\n                                   /*NoLineBreak=*/false));\n  State.LineContainsContinuedForLoopSection = false;\n  State.NoContinuation = false;\n  State.StartOfStringLiteral = 0;\n  State.StartOfLineLevel = 0;\n  State.LowestLevelOnLine = 0;\n  State.IgnoreStackForComparison = false;\n\n  if (Style.Language == FormatStyle::LK_TextProto) {\n    // We need this in order to deal with the bin packing of text fields at\n    // global scope.\n    State.Stack.back().AvoidBinPacking = true;\n    State.Stack.back().BreakBeforeParameter = true;\n    State.Stack.back().AlignColons = false;\n  }\n\n  // The first token has already been indented and thus consumed.\n  moveStateToNextToken(State, DryRun, /*Newline=*/false);\n  return State;\n}\n\nbool ContinuationIndenter::canBreak(const LineState &State) {\n  const FormatToken &Current = *State.NextToken;\n  const FormatToken &Previous = *Current.Previous;\n  assert(&Previous == Current.Previous);\n  if (!Current.CanBreakBefore && !(State.Stack.back().BreakBeforeClosingBrace &&\n                                   Current.closesBlockOrBlockTypeList(Style)))\n    return false;\n  // The opening \"{\" of a braced list has to be on the same line as the first\n  // element if it is nested in another braced init list or function call.\n  if (!Current.MustBreakBefore && Previous.is(tok::l_brace) &&\n      Previous.isNot(TT_DictLiteral) && Previous.is(BK_BracedInit) &&\n      Previous.Previous &&\n      Previous.Previous->isOneOf(tok::l_brace, tok::l_paren, tok::comma))\n    return false;\n  // This prevents breaks like:\n  //   ...\n  //   SomeParameter, OtherParameter).DoSomething(\n  //   ...\n  // As they hide \"DoSomething\" and are generally bad for readability.\n  if (Previous.opensScope() && Previous.isNot(tok::l_brace) &&\n      State.LowestLevelOnLine < State.StartOfLineLevel &&\n      State.LowestLevelOnLine < Current.NestingLevel)\n    return false;\n  if (Current.isMemberAccess() && State.Stack.back().ContainsUnwrappedBuilder)\n    return false;\n\n  // Don't create a 'hanging' indent if there are multiple blocks in a single\n  // statement.\n  if (Previous.is(tok::l_brace) && State.Stack.size() > 1 &&\n      State.Stack[State.Stack.size() - 2].NestedBlockInlined &&\n      State.Stack[State.Stack.size() - 2].HasMultipleNestedBlocks)\n    return false;\n\n  // Don't break after very short return types (e.g. \"void\") as that is often\n  // unexpected.\n  if (Current.is(TT_FunctionDeclarationName) && State.Column < 6) {\n    if (Style.AlwaysBreakAfterReturnType == FormatStyle::RTBS_None)\n      return false;\n  }\n\n  // If binary operators are moved to the next line (including commas for some\n  // styles of constructor initializers), that's always ok.\n  if (!Current.isOneOf(TT_BinaryOperator, tok::comma) &&\n      State.Stack.back().NoLineBreakInOperand)\n    return false;\n\n  if (Previous.is(tok::l_square) && Previous.is(TT_ObjCMethodExpr))\n    return false;\n\n  return !State.Stack.back().NoLineBreak;\n}\n\nbool ContinuationIndenter::mustBreak(const LineState &State) {\n  const FormatToken &Current = *State.NextToken;\n  const FormatToken &Previous = *Current.Previous;\n  if (Style.BraceWrapping.BeforeLambdaBody && Current.CanBreakBefore &&\n      Current.is(TT_LambdaLBrace) && Previous.isNot(TT_LineComment)) {\n    auto LambdaBodyLength = getLengthToMatchingParen(Current, State.Stack);\n    return (LambdaBodyLength > getColumnLimit(State));\n  }\n  if (Current.MustBreakBefore || Current.is(TT_InlineASMColon))\n    return true;\n  if (State.Stack.back().BreakBeforeClosingBrace &&\n      Current.closesBlockOrBlockTypeList(Style))\n    return true;\n  if (Previous.is(tok::semi) && State.LineContainsContinuedForLoopSection)\n    return true;\n  if (Style.Language == FormatStyle::LK_ObjC &&\n      Style.ObjCBreakBeforeNestedBlockParam &&\n      Current.ObjCSelectorNameParts > 1 &&\n      Current.startsSequence(TT_SelectorName, tok::colon, tok::caret)) {\n    return true;\n  }\n  // Avoid producing inconsistent states by requiring breaks where they are not\n  // permitted for C# generic type constraints.\n  if (State.Stack.back().IsCSharpGenericTypeConstraint &&\n      Previous.isNot(TT_CSharpGenericTypeConstraintComma))\n    return false;\n  if ((startsNextParameter(Current, Style) || Previous.is(tok::semi) ||\n       (Previous.is(TT_TemplateCloser) && Current.is(TT_StartOfName) &&\n        Style.isCpp() &&\n        // FIXME: This is a temporary workaround for the case where clang-format\n        // sets BreakBeforeParameter to avoid bin packing and this creates a\n        // completely unnecessary line break after a template type that isn't\n        // line-wrapped.\n        (Previous.NestingLevel == 1 || Style.BinPackParameters)) ||\n       (Style.BreakBeforeTernaryOperators && Current.is(TT_ConditionalExpr) &&\n        Previous.isNot(tok::question)) ||\n       (!Style.BreakBeforeTernaryOperators &&\n        Previous.is(TT_ConditionalExpr))) &&\n      State.Stack.back().BreakBeforeParameter && !Current.isTrailingComment() &&\n      !Current.isOneOf(tok::r_paren, tok::r_brace))\n    return true;\n  if (State.Stack.back().IsChainedConditional &&\n      ((Style.BreakBeforeTernaryOperators && Current.is(TT_ConditionalExpr) &&\n        Current.is(tok::colon)) ||\n       (!Style.BreakBeforeTernaryOperators && Previous.is(TT_ConditionalExpr) &&\n        Previous.is(tok::colon))))\n    return true;\n  if (((Previous.is(TT_DictLiteral) && Previous.is(tok::l_brace)) ||\n       (Previous.is(TT_ArrayInitializerLSquare) &&\n        Previous.ParameterCount > 1) ||\n       opensProtoMessageField(Previous, Style)) &&\n      Style.ColumnLimit > 0 &&\n      getLengthToMatchingParen(Previous, State.Stack) + State.Column - 1 >\n          getColumnLimit(State))\n    return true;\n\n  const FormatToken &BreakConstructorInitializersToken =\n      Style.BreakConstructorInitializers == FormatStyle::BCIS_AfterColon\n          ? Previous\n          : Current;\n  if (BreakConstructorInitializersToken.is(TT_CtorInitializerColon) &&\n      (State.Column + State.Line->Last->TotalLength - Previous.TotalLength >\n           getColumnLimit(State) ||\n       State.Stack.back().BreakBeforeParameter) &&\n      (Style.AllowShortFunctionsOnASingleLine != FormatStyle::SFS_All ||\n       Style.BreakConstructorInitializers != FormatStyle::BCIS_BeforeColon ||\n       Style.ColumnLimit != 0))\n    return true;\n\n  if (Current.is(TT_ObjCMethodExpr) && !Previous.is(TT_SelectorName) &&\n      State.Line->startsWith(TT_ObjCMethodSpecifier))\n    return true;\n  if (Current.is(TT_SelectorName) && !Previous.is(tok::at) &&\n      State.Stack.back().ObjCSelectorNameFound &&\n      State.Stack.back().BreakBeforeParameter &&\n      (Style.ObjCBreakBeforeNestedBlockParam ||\n       !Current.startsSequence(TT_SelectorName, tok::colon, tok::caret)))\n    return true;\n\n  unsigned NewLineColumn = getNewLineColumn(State);\n  if (Current.isMemberAccess() && Style.ColumnLimit != 0 &&\n      State.Column + getLengthToNextOperator(Current) > Style.ColumnLimit &&\n      (State.Column > NewLineColumn ||\n       Current.NestingLevel < State.StartOfLineLevel))\n    return true;\n\n  if (startsSegmentOfBuilderTypeCall(Current) &&\n      (State.Stack.back().CallContinuation != 0 ||\n       State.Stack.back().BreakBeforeParameter) &&\n      // JavaScript is treated different here as there is a frequent pattern:\n      //   SomeFunction(function() {\n      //     ...\n      //   }.bind(...));\n      // FIXME: We should find a more generic solution to this problem.\n      !(State.Column <= NewLineColumn &&\n        Style.Language == FormatStyle::LK_JavaScript) &&\n      !(Previous.closesScopeAfterBlock() && State.Column <= NewLineColumn))\n    return true;\n\n  // If the template declaration spans multiple lines, force wrap before the\n  // function/class declaration\n  if (Previous.ClosesTemplateDeclaration &&\n      State.Stack.back().BreakBeforeParameter && Current.CanBreakBefore)\n    return true;\n\n  if (!State.Line->First->is(tok::kw_enum) && State.Column <= NewLineColumn)\n    return false;\n\n  if (Style.AlwaysBreakBeforeMultilineStrings &&\n      (NewLineColumn == State.FirstIndent + Style.ContinuationIndentWidth ||\n       Previous.is(tok::comma) || Current.NestingLevel < 2) &&\n      !Previous.isOneOf(tok::kw_return, tok::lessless, tok::at,\n                        Keywords.kw_dollar) &&\n      !Previous.isOneOf(TT_InlineASMColon, TT_ConditionalExpr) &&\n      nextIsMultilineString(State))\n    return true;\n\n  // Using CanBreakBefore here and below takes care of the decision whether the\n  // current style uses wrapping before or after operators for the given\n  // operator.\n  if (Previous.is(TT_BinaryOperator) && Current.CanBreakBefore) {\n    // If we need to break somewhere inside the LHS of a binary expression, we\n    // should also break after the operator. Otherwise, the formatting would\n    // hide the operator precedence, e.g. in:\n    //   if (aaaaaaaaaaaaaa ==\n    //           bbbbbbbbbbbbbb && c) {..\n    // For comparisons, we only apply this rule, if the LHS is a binary\n    // expression itself as otherwise, the line breaks seem superfluous.\n    // We need special cases for \">>\" which we have split into two \">\" while\n    // lexing in order to make template parsing easier.\n    bool IsComparison = (Previous.getPrecedence() == prec::Relational ||\n                         Previous.getPrecedence() == prec::Equality ||\n                         Previous.getPrecedence() == prec::Spaceship) &&\n                        Previous.Previous &&\n                        Previous.Previous->isNot(TT_BinaryOperator); // For >>.\n    bool LHSIsBinaryExpr =\n        Previous.Previous && Previous.Previous->EndsBinaryExpression;\n    if ((!IsComparison || LHSIsBinaryExpr) && !Current.isTrailingComment() &&\n        Previous.getPrecedence() != prec::Assignment &&\n        State.Stack.back().BreakBeforeParameter)\n      return true;\n  } else if (Current.is(TT_BinaryOperator) && Current.CanBreakBefore &&\n             State.Stack.back().BreakBeforeParameter) {\n    return true;\n  }\n\n  // Same as above, but for the first \"<<\" operator.\n  if (Current.is(tok::lessless) && Current.isNot(TT_OverloadedOperator) &&\n      State.Stack.back().BreakBeforeParameter &&\n      State.Stack.back().FirstLessLess == 0)\n    return true;\n\n  if (Current.NestingLevel == 0 && !Current.isTrailingComment()) {\n    // Always break after \"template <...>\" and leading annotations. This is only\n    // for cases where the entire line does not fit on a single line as a\n    // different LineFormatter would be used otherwise.\n    if (Previous.ClosesTemplateDeclaration)\n      return Style.AlwaysBreakTemplateDeclarations != FormatStyle::BTDS_No;\n    if (Previous.is(TT_FunctionAnnotationRParen))\n      return true;\n    if (Previous.is(TT_LeadingJavaAnnotation) && Current.isNot(tok::l_paren) &&\n        Current.isNot(TT_LeadingJavaAnnotation))\n      return true;\n  }\n\n  // If the return type spans multiple lines, wrap before the function name.\n  if (((Current.is(TT_FunctionDeclarationName) &&\n        // Don't break before a C# function when no break after return type\n        (!Style.isCSharp() ||\n         Style.AlwaysBreakAfterReturnType != FormatStyle::RTBS_None)) ||\n       (Current.is(tok::kw_operator) && !Previous.is(tok::coloncolon))) &&\n      !Previous.is(tok::kw_template) && State.Stack.back().BreakBeforeParameter)\n    return true;\n\n  // The following could be precomputed as they do not depend on the state.\n  // However, as they should take effect only if the UnwrappedLine does not fit\n  // into the ColumnLimit, they are checked here in the ContinuationIndenter.\n  if (Style.ColumnLimit != 0 && Previous.is(BK_Block) &&\n      Previous.is(tok::l_brace) && !Current.isOneOf(tok::r_brace, tok::comment))\n    return true;\n\n  if (Current.is(tok::lessless) &&\n      ((Previous.is(tok::identifier) && Previous.TokenText == \"endl\") ||\n       (Previous.Tok.isLiteral() && (Previous.TokenText.endswith(\"\\\\n\\\"\") ||\n                                     Previous.TokenText == \"\\'\\\\n\\'\"))))\n    return true;\n\n  if (Previous.is(TT_BlockComment) && Previous.IsMultiline)\n    return true;\n\n  if (State.NoContinuation)\n    return true;\n\n  return false;\n}\n\nunsigned ContinuationIndenter::addTokenToState(LineState &State, bool Newline,\n                                               bool DryRun,\n                                               unsigned ExtraSpaces) {\n  const FormatToken &Current = *State.NextToken;\n\n  assert(!State.Stack.empty());\n  State.NoContinuation = false;\n\n  if ((Current.is(TT_ImplicitStringLiteral) &&\n       (Current.Previous->Tok.getIdentifierInfo() == nullptr ||\n        Current.Previous->Tok.getIdentifierInfo()->getPPKeywordID() ==\n            tok::pp_not_keyword))) {\n    unsigned EndColumn =\n        SourceMgr.getSpellingColumnNumber(Current.WhitespaceRange.getEnd());\n    if (Current.LastNewlineOffset != 0) {\n      // If there is a newline within this token, the final column will solely\n      // determined by the current end column.\n      State.Column = EndColumn;\n    } else {\n      unsigned StartColumn =\n          SourceMgr.getSpellingColumnNumber(Current.WhitespaceRange.getBegin());\n      assert(EndColumn >= StartColumn);\n      State.Column += EndColumn - StartColumn;\n    }\n    moveStateToNextToken(State, DryRun, /*Newline=*/false);\n    return 0;\n  }\n\n  unsigned Penalty = 0;\n  if (Newline)\n    Penalty = addTokenOnNewLine(State, DryRun);\n  else\n    addTokenOnCurrentLine(State, DryRun, ExtraSpaces);\n\n  return moveStateToNextToken(State, DryRun, Newline) + Penalty;\n}\n\nvoid ContinuationIndenter::addTokenOnCurrentLine(LineState &State, bool DryRun,\n                                                 unsigned ExtraSpaces) {\n  FormatToken &Current = *State.NextToken;\n  const FormatToken &Previous = *State.NextToken->Previous;\n  if (Current.is(tok::equal) &&\n      (State.Line->First->is(tok::kw_for) || Current.NestingLevel == 0) &&\n      State.Stack.back().VariablePos == 0) {\n    State.Stack.back().VariablePos = State.Column;\n    // Move over * and & if they are bound to the variable name.\n    const FormatToken *Tok = &Previous;\n    while (Tok && State.Stack.back().VariablePos >= Tok->ColumnWidth) {\n      State.Stack.back().VariablePos -= Tok->ColumnWidth;\n      if (Tok->SpacesRequiredBefore != 0)\n        break;\n      Tok = Tok->Previous;\n    }\n    if (Previous.PartOfMultiVariableDeclStmt)\n      State.Stack.back().LastSpace = State.Stack.back().VariablePos;\n  }\n\n  unsigned Spaces = Current.SpacesRequiredBefore + ExtraSpaces;\n\n  // Indent preprocessor directives after the hash if required.\n  int PPColumnCorrection = 0;\n  if (Style.IndentPPDirectives == FormatStyle::PPDIS_AfterHash &&\n      Previous.is(tok::hash) && State.FirstIndent > 0 &&\n      (State.Line->Type == LT_PreprocessorDirective ||\n       State.Line->Type == LT_ImportStatement)) {\n    Spaces += State.FirstIndent;\n\n    // For preprocessor indent with tabs, State.Column will be 1 because of the\n    // hash. This causes second-level indents onward to have an extra space\n    // after the tabs. We avoid this misalignment by subtracting 1 from the\n    // column value passed to replaceWhitespace().\n    if (Style.UseTab != FormatStyle::UT_Never)\n      PPColumnCorrection = -1;\n  }\n\n  if (!DryRun)\n    Whitespaces.replaceWhitespace(Current, /*Newlines=*/0, Spaces,\n                                  State.Column + Spaces + PPColumnCorrection);\n\n  // If \"BreakBeforeInheritanceComma\" mode, don't break within the inheritance\n  // declaration unless there is multiple inheritance.\n  if (Style.BreakInheritanceList == FormatStyle::BILS_BeforeComma &&\n      Current.is(TT_InheritanceColon))\n    State.Stack.back().NoLineBreak = true;\n  if (Style.BreakInheritanceList == FormatStyle::BILS_AfterColon &&\n      Previous.is(TT_InheritanceColon))\n    State.Stack.back().NoLineBreak = true;\n\n  if (Current.is(TT_SelectorName) &&\n      !State.Stack.back().ObjCSelectorNameFound) {\n    unsigned MinIndent =\n        std::max(State.FirstIndent + Style.ContinuationIndentWidth,\n                 State.Stack.back().Indent);\n    unsigned FirstColonPos = State.Column + Spaces + Current.ColumnWidth;\n    if (Current.LongestObjCSelectorName == 0)\n      State.Stack.back().AlignColons = false;\n    else if (MinIndent + Current.LongestObjCSelectorName > FirstColonPos)\n      State.Stack.back().ColonPos = MinIndent + Current.LongestObjCSelectorName;\n    else\n      State.Stack.back().ColonPos = FirstColonPos;\n  }\n\n  // In \"AlwaysBreak\" mode, enforce wrapping directly after the parenthesis by\n  // disallowing any further line breaks if there is no line break after the\n  // opening parenthesis. Don't break if it doesn't conserve columns.\n  if (Style.AlignAfterOpenBracket == FormatStyle::BAS_AlwaysBreak &&\n      (Previous.isOneOf(tok::l_paren, TT_TemplateOpener, tok::l_square) ||\n       (Previous.is(tok::l_brace) && Previous.isNot(BK_Block) &&\n        Style.Cpp11BracedListStyle)) &&\n      State.Column > getNewLineColumn(State) &&\n      (!Previous.Previous || !Previous.Previous->isOneOf(\n                                 tok::kw_for, tok::kw_while, tok::kw_switch)) &&\n      // Don't do this for simple (no expressions) one-argument function calls\n      // as that feels like needlessly wasting whitespace, e.g.:\n      //\n      //   caaaaaaaaaaaall(\n      //       caaaaaaaaaaaall(\n      //           caaaaaaaaaaaall(\n      //               caaaaaaaaaaaaaaaaaaaaaaall(aaaaaaaaaaaaaa, aaaaaaaaa))));\n      Current.FakeLParens.size() > 0 &&\n      Current.FakeLParens.back() > prec::Unknown)\n    State.Stack.back().NoLineBreak = true;\n  if (Previous.is(TT_TemplateString) && Previous.opensScope())\n    State.Stack.back().NoLineBreak = true;\n\n  if (Style.AlignAfterOpenBracket != FormatStyle::BAS_DontAlign &&\n      !State.Stack.back().IsCSharpGenericTypeConstraint &&\n      Previous.opensScope() && Previous.isNot(TT_ObjCMethodExpr) &&\n      (Current.isNot(TT_LineComment) || Previous.is(BK_BracedInit))) {\n    State.Stack.back().Indent = State.Column + Spaces;\n    State.Stack.back().IsAligned = true;\n  }\n  if (State.Stack.back().AvoidBinPacking && startsNextParameter(Current, Style))\n    State.Stack.back().NoLineBreak = true;\n  if (startsSegmentOfBuilderTypeCall(Current) &&\n      State.Column > getNewLineColumn(State))\n    State.Stack.back().ContainsUnwrappedBuilder = true;\n\n  if (Current.is(TT_LambdaArrow) && Style.Language == FormatStyle::LK_Java)\n    State.Stack.back().NoLineBreak = true;\n  if (Current.isMemberAccess() && Previous.is(tok::r_paren) &&\n      (Previous.MatchingParen &&\n       (Previous.TotalLength - Previous.MatchingParen->TotalLength > 10)))\n    // If there is a function call with long parameters, break before trailing\n    // calls. This prevents things like:\n    //   EXPECT_CALL(SomeLongParameter).Times(\n    //       2);\n    // We don't want to do this for short parameters as they can just be\n    // indexes.\n    State.Stack.back().NoLineBreak = true;\n\n  // Don't allow the RHS of an operator to be split over multiple lines unless\n  // there is a line-break right after the operator.\n  // Exclude relational operators, as there, it is always more desirable to\n  // have the LHS 'left' of the RHS.\n  const FormatToken *P = Current.getPreviousNonComment();\n  if (!Current.is(tok::comment) && P &&\n      (P->isOneOf(TT_BinaryOperator, tok::comma) ||\n       (P->is(TT_ConditionalExpr) && P->is(tok::colon))) &&\n      !P->isOneOf(TT_OverloadedOperator, TT_CtorInitializerComma) &&\n      P->getPrecedence() != prec::Assignment &&\n      P->getPrecedence() != prec::Relational &&\n      P->getPrecedence() != prec::Spaceship) {\n    bool BreakBeforeOperator =\n        P->MustBreakBefore || P->is(tok::lessless) ||\n        (P->is(TT_BinaryOperator) &&\n         Style.BreakBeforeBinaryOperators != FormatStyle::BOS_None) ||\n        (P->is(TT_ConditionalExpr) && Style.BreakBeforeTernaryOperators);\n    // Don't do this if there are only two operands. In these cases, there is\n    // always a nice vertical separation between them and the extra line break\n    // does not help.\n    bool HasTwoOperands =\n        P->OperatorIndex == 0 && !P->NextOperator && !P->is(TT_ConditionalExpr);\n    if ((!BreakBeforeOperator &&\n         !(HasTwoOperands &&\n           Style.AlignOperands != FormatStyle::OAS_DontAlign)) ||\n        (!State.Stack.back().LastOperatorWrapped && BreakBeforeOperator))\n      State.Stack.back().NoLineBreakInOperand = true;\n  }\n\n  State.Column += Spaces;\n  if (Current.isNot(tok::comment) && Previous.is(tok::l_paren) &&\n      Previous.Previous &&\n      (Previous.Previous->is(tok::kw_for) || Previous.Previous->isIf())) {\n    // Treat the condition inside an if as if it was a second function\n    // parameter, i.e. let nested calls have a continuation indent.\n    State.Stack.back().LastSpace = State.Column;\n    State.Stack.back().NestedBlockIndent = State.Column;\n  } else if (!Current.isOneOf(tok::comment, tok::caret) &&\n             ((Previous.is(tok::comma) &&\n               !Previous.is(TT_OverloadedOperator)) ||\n              (Previous.is(tok::colon) && Previous.is(TT_ObjCMethodExpr)))) {\n    State.Stack.back().LastSpace = State.Column;\n  } else if (Previous.is(TT_CtorInitializerColon) &&\n             Style.BreakConstructorInitializers ==\n                 FormatStyle::BCIS_AfterColon) {\n    State.Stack.back().Indent = State.Column;\n    State.Stack.back().LastSpace = State.Column;\n  } else if ((Previous.isOneOf(TT_BinaryOperator, TT_ConditionalExpr,\n                               TT_CtorInitializerColon)) &&\n             ((Previous.getPrecedence() != prec::Assignment &&\n               (Previous.isNot(tok::lessless) || Previous.OperatorIndex != 0 ||\n                Previous.NextOperator)) ||\n              Current.StartsBinaryExpression)) {\n    // Indent relative to the RHS of the expression unless this is a simple\n    // assignment without binary expression on the RHS. Also indent relative to\n    // unary operators and the colons of constructor initializers.\n    if (Style.BreakBeforeBinaryOperators == FormatStyle::BOS_None)\n      State.Stack.back().LastSpace = State.Column;\n  } else if (Previous.is(TT_InheritanceColon)) {\n    State.Stack.back().Indent = State.Column;\n    State.Stack.back().LastSpace = State.Column;\n  } else if (Current.is(TT_CSharpGenericTypeConstraintColon)) {\n    State.Stack.back().ColonPos = State.Column;\n  } else if (Previous.opensScope()) {\n    // If a function has a trailing call, indent all parameters from the\n    // opening parenthesis. This avoids confusing indents like:\n    //   OuterFunction(InnerFunctionCall( // break\n    //       ParameterToInnerFunction))   // break\n    //       .SecondInnerFunctionCall();\n    bool HasTrailingCall = false;\n    if (Previous.MatchingParen) {\n      const FormatToken *Next = Previous.MatchingParen->getNextNonComment();\n      HasTrailingCall = Next && Next->isMemberAccess();\n    }\n    if (HasTrailingCall && State.Stack.size() > 1 &&\n        State.Stack[State.Stack.size() - 2].CallContinuation == 0)\n      State.Stack.back().LastSpace = State.Column;\n  }\n}\n\nunsigned ContinuationIndenter::addTokenOnNewLine(LineState &State,\n                                                 bool DryRun) {\n  FormatToken &Current = *State.NextToken;\n  const FormatToken &Previous = *State.NextToken->Previous;\n\n  // Extra penalty that needs to be added because of the way certain line\n  // breaks are chosen.\n  unsigned Penalty = 0;\n\n  const FormatToken *PreviousNonComment = Current.getPreviousNonComment();\n  const FormatToken *NextNonComment = Previous.getNextNonComment();\n  if (!NextNonComment)\n    NextNonComment = &Current;\n  // The first line break on any NestingLevel causes an extra penalty in order\n  // prefer similar line breaks.\n  if (!State.Stack.back().ContainsLineBreak)\n    Penalty += 15;\n  State.Stack.back().ContainsLineBreak = true;\n\n  Penalty += State.NextToken->SplitPenalty;\n\n  // Breaking before the first \"<<\" is generally not desirable if the LHS is\n  // short. Also always add the penalty if the LHS is split over multiple lines\n  // to avoid unnecessary line breaks that just work around this penalty.\n  if (NextNonComment->is(tok::lessless) &&\n      State.Stack.back().FirstLessLess == 0 &&\n      (State.Column <= Style.ColumnLimit / 3 ||\n       State.Stack.back().BreakBeforeParameter))\n    Penalty += Style.PenaltyBreakFirstLessLess;\n\n  State.Column = getNewLineColumn(State);\n\n  // Add Penalty proportional to amount of whitespace away from FirstColumn\n  // This tends to penalize several lines that are far-right indented,\n  // and prefers a line-break prior to such a block, e.g:\n  //\n  // Constructor() :\n  //   member(value), looooooooooooooooong_member(\n  //                      looooooooooong_call(param_1, param_2, param_3))\n  // would then become\n  // Constructor() :\n  //   member(value),\n  //   looooooooooooooooong_member(\n  //       looooooooooong_call(param_1, param_2, param_3))\n  if (State.Column > State.FirstIndent)\n    Penalty +=\n        Style.PenaltyIndentedWhitespace * (State.Column - State.FirstIndent);\n\n  // Indent nested blocks relative to this column, unless in a very specific\n  // JavaScript special case where:\n  //\n  //   var loooooong_name =\n  //       function() {\n  //     // code\n  //   }\n  //\n  // is common and should be formatted like a free-standing function. The same\n  // goes for wrapping before the lambda return type arrow.\n  if (!Current.is(TT_LambdaArrow) &&\n      (Style.Language != FormatStyle::LK_JavaScript ||\n       Current.NestingLevel != 0 || !PreviousNonComment ||\n       !PreviousNonComment->is(tok::equal) ||\n       !Current.isOneOf(Keywords.kw_async, Keywords.kw_function)))\n    State.Stack.back().NestedBlockIndent = State.Column;\n\n  if (NextNonComment->isMemberAccess()) {\n    if (State.Stack.back().CallContinuation == 0)\n      State.Stack.back().CallContinuation = State.Column;\n  } else if (NextNonComment->is(TT_SelectorName)) {\n    if (!State.Stack.back().ObjCSelectorNameFound) {\n      if (NextNonComment->LongestObjCSelectorName == 0) {\n        State.Stack.back().AlignColons = false;\n      } else {\n        State.Stack.back().ColonPos =\n            (shouldIndentWrappedSelectorName(Style, State.Line->Type)\n                 ? std::max(State.Stack.back().Indent,\n                            State.FirstIndent + Style.ContinuationIndentWidth)\n                 : State.Stack.back().Indent) +\n            std::max(NextNonComment->LongestObjCSelectorName,\n                     NextNonComment->ColumnWidth);\n      }\n    } else if (State.Stack.back().AlignColons &&\n               State.Stack.back().ColonPos <= NextNonComment->ColumnWidth) {\n      State.Stack.back().ColonPos = State.Column + NextNonComment->ColumnWidth;\n    }\n  } else if (PreviousNonComment && PreviousNonComment->is(tok::colon) &&\n             PreviousNonComment->isOneOf(TT_ObjCMethodExpr, TT_DictLiteral)) {\n    // FIXME: This is hacky, find a better way. The problem is that in an ObjC\n    // method expression, the block should be aligned to the line starting it,\n    // e.g.:\n    //   [aaaaaaaaaaaaaaa aaaaaaaaa: \\\\ break for some reason\n    //                        ^(int *i) {\n    //                            // ...\n    //                        }];\n    // Thus, we set LastSpace of the next higher NestingLevel, to which we move\n    // when we consume all of the \"}\"'s FakeRParens at the \"{\".\n    if (State.Stack.size() > 1)\n      State.Stack[State.Stack.size() - 2].LastSpace =\n          std::max(State.Stack.back().LastSpace, State.Stack.back().Indent) +\n          Style.ContinuationIndentWidth;\n  }\n\n  if ((PreviousNonComment &&\n       PreviousNonComment->isOneOf(tok::comma, tok::semi) &&\n       !State.Stack.back().AvoidBinPacking) ||\n      Previous.is(TT_BinaryOperator))\n    State.Stack.back().BreakBeforeParameter = false;\n  if (PreviousNonComment &&\n      PreviousNonComment->isOneOf(TT_TemplateCloser, TT_JavaAnnotation) &&\n      Current.NestingLevel == 0)\n    State.Stack.back().BreakBeforeParameter = false;\n  if (NextNonComment->is(tok::question) ||\n      (PreviousNonComment && PreviousNonComment->is(tok::question)))\n    State.Stack.back().BreakBeforeParameter = true;\n  if (Current.is(TT_BinaryOperator) && Current.CanBreakBefore)\n    State.Stack.back().BreakBeforeParameter = false;\n\n  if (!DryRun) {\n    unsigned MaxEmptyLinesToKeep = Style.MaxEmptyLinesToKeep + 1;\n    if (Current.is(tok::r_brace) && Current.MatchingParen &&\n        // Only strip trailing empty lines for l_braces that have children, i.e.\n        // for function expressions (lambdas, arrows, etc).\n        !Current.MatchingParen->Children.empty()) {\n      // lambdas and arrow functions are expressions, thus their r_brace is not\n      // on its own line, and thus not covered by UnwrappedLineFormatter's logic\n      // about removing empty lines on closing blocks. Special case them here.\n      MaxEmptyLinesToKeep = 1;\n    }\n    unsigned Newlines =\n        std::max(1u, std::min(Current.NewlinesBefore, MaxEmptyLinesToKeep));\n    bool ContinuePPDirective =\n        State.Line->InPPDirective && State.Line->Type != LT_ImportStatement;\n    Whitespaces.replaceWhitespace(Current, Newlines, State.Column, State.Column,\n                                  State.Stack.back().IsAligned,\n                                  ContinuePPDirective);\n  }\n\n  if (!Current.isTrailingComment())\n    State.Stack.back().LastSpace = State.Column;\n  if (Current.is(tok::lessless))\n    // If we are breaking before a \"<<\", we always want to indent relative to\n    // RHS. This is necessary only for \"<<\", as we special-case it and don't\n    // always indent relative to the RHS.\n    State.Stack.back().LastSpace += 3; // 3 -> width of \"<< \".\n\n  State.StartOfLineLevel = Current.NestingLevel;\n  State.LowestLevelOnLine = Current.NestingLevel;\n\n  // Any break on this level means that the parent level has been broken\n  // and we need to avoid bin packing there.\n  bool NestedBlockSpecialCase =\n      (!Style.isCpp() && Current.is(tok::r_brace) && State.Stack.size() > 1 &&\n       State.Stack[State.Stack.size() - 2].NestedBlockInlined) ||\n      (Style.Language == FormatStyle::LK_ObjC && Current.is(tok::r_brace) &&\n       State.Stack.size() > 1 && !Style.ObjCBreakBeforeNestedBlockParam);\n  if (!NestedBlockSpecialCase)\n    for (unsigned i = 0, e = State.Stack.size() - 1; i != e; ++i)\n      State.Stack[i].BreakBeforeParameter = true;\n\n  if (PreviousNonComment &&\n      !PreviousNonComment->isOneOf(tok::comma, tok::colon, tok::semi) &&\n      (PreviousNonComment->isNot(TT_TemplateCloser) ||\n       Current.NestingLevel != 0) &&\n      !PreviousNonComment->isOneOf(\n          TT_BinaryOperator, TT_FunctionAnnotationRParen, TT_JavaAnnotation,\n          TT_LeadingJavaAnnotation) &&\n      Current.isNot(TT_BinaryOperator) && !PreviousNonComment->opensScope())\n    State.Stack.back().BreakBeforeParameter = true;\n\n  // If we break after { or the [ of an array initializer, we should also break\n  // before the corresponding } or ].\n  if (PreviousNonComment &&\n      (PreviousNonComment->isOneOf(tok::l_brace, TT_ArrayInitializerLSquare) ||\n       opensProtoMessageField(*PreviousNonComment, Style)))\n    State.Stack.back().BreakBeforeClosingBrace = true;\n\n  if (State.Stack.back().AvoidBinPacking) {\n    // If we are breaking after '(', '{', '<', or this is the break after a ':'\n    // to start a member initializater list in a constructor, this should not\n    // be considered bin packing unless the relevant AllowAll option is false or\n    // this is a dict/object literal.\n    bool PreviousIsBreakingCtorInitializerColon =\n        Previous.is(TT_CtorInitializerColon) &&\n        Style.BreakConstructorInitializers == FormatStyle::BCIS_AfterColon;\n    if (!(Previous.isOneOf(tok::l_paren, tok::l_brace, TT_BinaryOperator) ||\n          PreviousIsBreakingCtorInitializerColon) ||\n        (!Style.AllowAllParametersOfDeclarationOnNextLine &&\n         State.Line->MustBeDeclaration) ||\n        (!Style.AllowAllArgumentsOnNextLine &&\n         !State.Line->MustBeDeclaration) ||\n        (!Style.AllowAllConstructorInitializersOnNextLine &&\n         PreviousIsBreakingCtorInitializerColon) ||\n        Previous.is(TT_DictLiteral))\n      State.Stack.back().BreakBeforeParameter = true;\n\n    // If we are breaking after a ':' to start a member initializer list,\n    // and we allow all arguments on the next line, we should not break\n    // before the next parameter.\n    if (PreviousIsBreakingCtorInitializerColon &&\n        Style.AllowAllConstructorInitializersOnNextLine)\n      State.Stack.back().BreakBeforeParameter = false;\n  }\n\n  return Penalty;\n}\n\nunsigned ContinuationIndenter::getNewLineColumn(const LineState &State) {\n  if (!State.NextToken || !State.NextToken->Previous)\n    return 0;\n\n  FormatToken &Current = *State.NextToken;\n\n  if (State.Stack.back().IsCSharpGenericTypeConstraint &&\n      Current.isNot(TT_CSharpGenericTypeConstraint))\n    return State.Stack.back().ColonPos + 2;\n\n  const FormatToken &Previous = *Current.Previous;\n  // If we are continuing an expression, we want to use the continuation indent.\n  unsigned ContinuationIndent =\n      std::max(State.Stack.back().LastSpace, State.Stack.back().Indent) +\n      Style.ContinuationIndentWidth;\n  const FormatToken *PreviousNonComment = Current.getPreviousNonComment();\n  const FormatToken *NextNonComment = Previous.getNextNonComment();\n  if (!NextNonComment)\n    NextNonComment = &Current;\n\n  // Java specific bits.\n  if (Style.Language == FormatStyle::LK_Java &&\n      Current.isOneOf(Keywords.kw_implements, Keywords.kw_extends))\n    return std::max(State.Stack.back().LastSpace,\n                    State.Stack.back().Indent + Style.ContinuationIndentWidth);\n\n  if (Style.BreakBeforeBraces == FormatStyle::BS_Whitesmiths &&\n      State.Line->First->is(tok::kw_enum))\n    return (Style.IndentWidth * State.Line->First->IndentLevel) +\n           Style.IndentWidth;\n\n  if (NextNonComment->is(tok::l_brace) && NextNonComment->is(BK_Block))\n    return Current.NestingLevel == 0 ? State.FirstIndent\n                                     : State.Stack.back().Indent;\n  if ((Current.isOneOf(tok::r_brace, tok::r_square) ||\n       (Current.is(tok::greater) &&\n        (Style.Language == FormatStyle::LK_Proto ||\n         Style.Language == FormatStyle::LK_TextProto))) &&\n      State.Stack.size() > 1) {\n    if (Current.closesBlockOrBlockTypeList(Style))\n      return State.Stack[State.Stack.size() - 2].NestedBlockIndent;\n    if (Current.MatchingParen && Current.MatchingParen->is(BK_BracedInit))\n      return State.Stack[State.Stack.size() - 2].LastSpace;\n    return State.FirstIndent;\n  }\n  // Indent a closing parenthesis at the previous level if followed by a semi,\n  // const, or opening brace. This allows indentations such as:\n  //     foo(\n  //       a,\n  //     );\n  //     int Foo::getter(\n  //         //\n  //     ) const {\n  //       return foo;\n  //     }\n  //     function foo(\n  //       a,\n  //     ) {\n  //       code(); //\n  //     }\n  if (Current.is(tok::r_paren) && State.Stack.size() > 1 &&\n      (!Current.Next ||\n       Current.Next->isOneOf(tok::semi, tok::kw_const, tok::l_brace)))\n    return State.Stack[State.Stack.size() - 2].LastSpace;\n  if (NextNonComment->is(TT_TemplateString) && NextNonComment->closesScope())\n    return State.Stack[State.Stack.size() - 2].LastSpace;\n  if (Current.is(tok::identifier) && Current.Next &&\n      (Current.Next->is(TT_DictLiteral) ||\n       ((Style.Language == FormatStyle::LK_Proto ||\n         Style.Language == FormatStyle::LK_TextProto) &&\n        Current.Next->isOneOf(tok::less, tok::l_brace))))\n    return State.Stack.back().Indent;\n  if (NextNonComment->is(TT_ObjCStringLiteral) &&\n      State.StartOfStringLiteral != 0)\n    return State.StartOfStringLiteral - 1;\n  if (NextNonComment->isStringLiteral() && State.StartOfStringLiteral != 0)\n    return State.StartOfStringLiteral;\n  if (NextNonComment->is(tok::lessless) &&\n      State.Stack.back().FirstLessLess != 0)\n    return State.Stack.back().FirstLessLess;\n  if (NextNonComment->isMemberAccess()) {\n    if (State.Stack.back().CallContinuation == 0)\n      return ContinuationIndent;\n    return State.Stack.back().CallContinuation;\n  }\n  if (State.Stack.back().QuestionColumn != 0 &&\n      ((NextNonComment->is(tok::colon) &&\n        NextNonComment->is(TT_ConditionalExpr)) ||\n       Previous.is(TT_ConditionalExpr))) {\n    if (((NextNonComment->is(tok::colon) && NextNonComment->Next &&\n          !NextNonComment->Next->FakeLParens.empty() &&\n          NextNonComment->Next->FakeLParens.back() == prec::Conditional) ||\n         (Previous.is(tok::colon) && !Current.FakeLParens.empty() &&\n          Current.FakeLParens.back() == prec::Conditional)) &&\n        !State.Stack.back().IsWrappedConditional) {\n      // NOTE: we may tweak this slightly:\n      //    * not remove the 'lead' ContinuationIndentWidth\n      //    * always un-indent by the operator when\n      //    BreakBeforeTernaryOperators=true\n      unsigned Indent = State.Stack.back().Indent;\n      if (Style.AlignOperands != FormatStyle::OAS_DontAlign) {\n        Indent -= Style.ContinuationIndentWidth;\n      }\n      if (Style.BreakBeforeTernaryOperators &&\n          State.Stack.back().UnindentOperator)\n        Indent -= 2;\n      return Indent;\n    }\n    return State.Stack.back().QuestionColumn;\n  }\n  if (Previous.is(tok::comma) && State.Stack.back().VariablePos != 0)\n    return State.Stack.back().VariablePos;\n  if ((PreviousNonComment &&\n       (PreviousNonComment->ClosesTemplateDeclaration ||\n        PreviousNonComment->isOneOf(\n            TT_AttributeParen, TT_AttributeSquare, TT_FunctionAnnotationRParen,\n            TT_JavaAnnotation, TT_LeadingJavaAnnotation))) ||\n      (!Style.IndentWrappedFunctionNames &&\n       NextNonComment->isOneOf(tok::kw_operator, TT_FunctionDeclarationName)))\n    return std::max(State.Stack.back().LastSpace, State.Stack.back().Indent);\n  if (NextNonComment->is(TT_SelectorName)) {\n    if (!State.Stack.back().ObjCSelectorNameFound) {\n      unsigned MinIndent = State.Stack.back().Indent;\n      if (shouldIndentWrappedSelectorName(Style, State.Line->Type))\n        MinIndent = std::max(MinIndent,\n                             State.FirstIndent + Style.ContinuationIndentWidth);\n      // If LongestObjCSelectorName is 0, we are indenting the first\n      // part of an ObjC selector (or a selector component which is\n      // not colon-aligned due to block formatting).\n      //\n      // Otherwise, we are indenting a subsequent part of an ObjC\n      // selector which should be colon-aligned to the longest\n      // component of the ObjC selector.\n      //\n      // In either case, we want to respect Style.IndentWrappedFunctionNames.\n      return MinIndent +\n             std::max(NextNonComment->LongestObjCSelectorName,\n                      NextNonComment->ColumnWidth) -\n             NextNonComment->ColumnWidth;\n    }\n    if (!State.Stack.back().AlignColons)\n      return State.Stack.back().Indent;\n    if (State.Stack.back().ColonPos > NextNonComment->ColumnWidth)\n      return State.Stack.back().ColonPos - NextNonComment->ColumnWidth;\n    return State.Stack.back().Indent;\n  }\n  if (NextNonComment->is(tok::colon) && NextNonComment->is(TT_ObjCMethodExpr))\n    return State.Stack.back().ColonPos;\n  if (NextNonComment->is(TT_ArraySubscriptLSquare)) {\n    if (State.Stack.back().StartOfArraySubscripts != 0)\n      return State.Stack.back().StartOfArraySubscripts;\n    else if (Style.isCSharp()) // C# allows `[\"key\"] = value` inside object\n                               // initializers.\n      return State.Stack.back().Indent;\n    return ContinuationIndent;\n  }\n\n  // This ensure that we correctly format ObjC methods calls without inputs,\n  // i.e. where the last element isn't selector like: [callee method];\n  if (NextNonComment->is(tok::identifier) && NextNonComment->FakeRParens == 0 &&\n      NextNonComment->Next && NextNonComment->Next->is(TT_ObjCMethodExpr))\n    return State.Stack.back().Indent;\n\n  if (NextNonComment->isOneOf(TT_StartOfName, TT_PointerOrReference) ||\n      Previous.isOneOf(tok::coloncolon, tok::equal, TT_JsTypeColon))\n    return ContinuationIndent;\n  if (PreviousNonComment && PreviousNonComment->is(tok::colon) &&\n      PreviousNonComment->isOneOf(TT_ObjCMethodExpr, TT_DictLiteral))\n    return ContinuationIndent;\n  if (NextNonComment->is(TT_CtorInitializerComma))\n    return State.Stack.back().Indent;\n  if (PreviousNonComment && PreviousNonComment->is(TT_CtorInitializerColon) &&\n      Style.BreakConstructorInitializers == FormatStyle::BCIS_AfterColon)\n    return State.Stack.back().Indent;\n  if (PreviousNonComment && PreviousNonComment->is(TT_InheritanceColon) &&\n      Style.BreakInheritanceList == FormatStyle::BILS_AfterColon)\n    return State.Stack.back().Indent;\n  if (NextNonComment->isOneOf(TT_CtorInitializerColon, TT_InheritanceColon,\n                              TT_InheritanceComma))\n    return State.FirstIndent + Style.ConstructorInitializerIndentWidth;\n  if (Previous.is(tok::r_paren) && !Current.isBinaryOperator() &&\n      !Current.isOneOf(tok::colon, tok::comment))\n    return ContinuationIndent;\n  if (Current.is(TT_ProtoExtensionLSquare))\n    return State.Stack.back().Indent;\n  if (Current.isBinaryOperator() && State.Stack.back().UnindentOperator)\n    return State.Stack.back().Indent - Current.Tok.getLength() -\n           Current.SpacesRequiredBefore;\n  if (Current.isOneOf(tok::comment, TT_BlockComment, TT_LineComment) &&\n      NextNonComment->isBinaryOperator() && State.Stack.back().UnindentOperator)\n    return State.Stack.back().Indent - NextNonComment->Tok.getLength() -\n           NextNonComment->SpacesRequiredBefore;\n  if (State.Stack.back().Indent == State.FirstIndent && PreviousNonComment &&\n      !PreviousNonComment->isOneOf(tok::r_brace, TT_CtorInitializerComma))\n    // Ensure that we fall back to the continuation indent width instead of\n    // just flushing continuations left.\n    return State.Stack.back().Indent + Style.ContinuationIndentWidth;\n  return State.Stack.back().Indent;\n}\n\nstatic bool hasNestedBlockInlined(const FormatToken *Previous,\n                                  const FormatToken &Current,\n                                  const FormatStyle &Style) {\n  if (Previous->isNot(tok::l_paren))\n    return true;\n  if (Previous->ParameterCount > 1)\n    return true;\n\n  // Also a nested block if contains a lambda inside function with 1 parameter\n  return (Style.BraceWrapping.BeforeLambdaBody && Current.is(TT_LambdaLSquare));\n}\n\nunsigned ContinuationIndenter::moveStateToNextToken(LineState &State,\n                                                    bool DryRun, bool Newline) {\n  assert(State.Stack.size());\n  const FormatToken &Current = *State.NextToken;\n\n  if (Current.is(TT_CSharpGenericTypeConstraint))\n    State.Stack.back().IsCSharpGenericTypeConstraint = true;\n  if (Current.isOneOf(tok::comma, TT_BinaryOperator))\n    State.Stack.back().NoLineBreakInOperand = false;\n  if (Current.isOneOf(TT_InheritanceColon, TT_CSharpGenericTypeConstraintColon))\n    State.Stack.back().AvoidBinPacking = true;\n  if (Current.is(tok::lessless) && Current.isNot(TT_OverloadedOperator)) {\n    if (State.Stack.back().FirstLessLess == 0)\n      State.Stack.back().FirstLessLess = State.Column;\n    else\n      State.Stack.back().LastOperatorWrapped = Newline;\n  }\n  if (Current.is(TT_BinaryOperator) && Current.isNot(tok::lessless))\n    State.Stack.back().LastOperatorWrapped = Newline;\n  if (Current.is(TT_ConditionalExpr) && Current.Previous &&\n      !Current.Previous->is(TT_ConditionalExpr))\n    State.Stack.back().LastOperatorWrapped = Newline;\n  if (Current.is(TT_ArraySubscriptLSquare) &&\n      State.Stack.back().StartOfArraySubscripts == 0)\n    State.Stack.back().StartOfArraySubscripts = State.Column;\n  if (Current.is(TT_ConditionalExpr) && Current.is(tok::question) &&\n      ((Current.MustBreakBefore) ||\n       (Current.getNextNonComment() &&\n        Current.getNextNonComment()->MustBreakBefore)))\n    State.Stack.back().IsWrappedConditional = true;\n  if (Style.BreakBeforeTernaryOperators && Current.is(tok::question))\n    State.Stack.back().QuestionColumn = State.Column;\n  if (!Style.BreakBeforeTernaryOperators && Current.isNot(tok::colon)) {\n    const FormatToken *Previous = Current.Previous;\n    while (Previous && Previous->isTrailingComment())\n      Previous = Previous->Previous;\n    if (Previous && Previous->is(tok::question))\n      State.Stack.back().QuestionColumn = State.Column;\n  }\n  if (!Current.opensScope() && !Current.closesScope() &&\n      !Current.is(TT_PointerOrReference))\n    State.LowestLevelOnLine =\n        std::min(State.LowestLevelOnLine, Current.NestingLevel);\n  if (Current.isMemberAccess())\n    State.Stack.back().StartOfFunctionCall =\n        !Current.NextOperator ? 0 : State.Column;\n  if (Current.is(TT_SelectorName))\n    State.Stack.back().ObjCSelectorNameFound = true;\n  if (Current.is(TT_CtorInitializerColon) &&\n      Style.BreakConstructorInitializers != FormatStyle::BCIS_AfterColon) {\n    // Indent 2 from the column, so:\n    // SomeClass::SomeClass()\n    //     : First(...), ...\n    //       Next(...)\n    //       ^ line up here.\n    State.Stack.back().Indent =\n        State.Column +\n        (Style.BreakConstructorInitializers == FormatStyle::BCIS_BeforeComma\n             ? 0\n             : 2);\n    State.Stack.back().NestedBlockIndent = State.Stack.back().Indent;\n    if (Style.ConstructorInitializerAllOnOneLineOrOnePerLine) {\n      State.Stack.back().AvoidBinPacking = true;\n      State.Stack.back().BreakBeforeParameter =\n          !Style.AllowAllConstructorInitializersOnNextLine;\n    } else {\n      State.Stack.back().BreakBeforeParameter = false;\n    }\n  }\n  if (Current.is(TT_CtorInitializerColon) &&\n      Style.BreakConstructorInitializers == FormatStyle::BCIS_AfterColon) {\n    State.Stack.back().Indent =\n        State.FirstIndent + Style.ConstructorInitializerIndentWidth;\n    State.Stack.back().NestedBlockIndent = State.Stack.back().Indent;\n    if (Style.ConstructorInitializerAllOnOneLineOrOnePerLine)\n      State.Stack.back().AvoidBinPacking = true;\n  }\n  if (Current.is(TT_InheritanceColon))\n    State.Stack.back().Indent =\n        State.FirstIndent + Style.ConstructorInitializerIndentWidth;\n  if (Current.isOneOf(TT_BinaryOperator, TT_ConditionalExpr) && Newline)\n    State.Stack.back().NestedBlockIndent =\n        State.Column + Current.ColumnWidth + 1;\n  if (Current.isOneOf(TT_LambdaLSquare, TT_LambdaArrow))\n    State.Stack.back().LastSpace = State.Column;\n\n  // Insert scopes created by fake parenthesis.\n  const FormatToken *Previous = Current.getPreviousNonComment();\n\n  // Add special behavior to support a format commonly used for JavaScript\n  // closures:\n  //   SomeFunction(function() {\n  //     foo();\n  //     bar();\n  //   }, a, b, c);\n  if (Current.isNot(tok::comment) && Previous &&\n      Previous->isOneOf(tok::l_brace, TT_ArrayInitializerLSquare) &&\n      !Previous->is(TT_DictLiteral) && State.Stack.size() > 1 &&\n      !State.Stack.back().HasMultipleNestedBlocks) {\n    if (State.Stack[State.Stack.size() - 2].NestedBlockInlined && Newline)\n      for (unsigned i = 0, e = State.Stack.size() - 1; i != e; ++i)\n        State.Stack[i].NoLineBreak = true;\n    State.Stack[State.Stack.size() - 2].NestedBlockInlined = false;\n  }\n  if (Previous &&\n      (Previous->isOneOf(tok::l_paren, tok::comma, tok::colon) ||\n       Previous->isOneOf(TT_BinaryOperator, TT_ConditionalExpr)) &&\n      !Previous->isOneOf(TT_DictLiteral, TT_ObjCMethodExpr)) {\n    State.Stack.back().NestedBlockInlined =\n        !Newline && hasNestedBlockInlined(Previous, Current, Style);\n  }\n\n  moveStatePastFakeLParens(State, Newline);\n  moveStatePastScopeCloser(State);\n  bool AllowBreak = !State.Stack.back().NoLineBreak &&\n                    !State.Stack.back().NoLineBreakInOperand;\n  moveStatePastScopeOpener(State, Newline);\n  moveStatePastFakeRParens(State);\n\n  if (Current.is(TT_ObjCStringLiteral) && State.StartOfStringLiteral == 0)\n    State.StartOfStringLiteral = State.Column + 1;\n  if (Current.is(TT_CSharpStringLiteral) && State.StartOfStringLiteral == 0)\n    State.StartOfStringLiteral = State.Column + 1;\n  else if (Current.isStringLiteral() && State.StartOfStringLiteral == 0)\n    State.StartOfStringLiteral = State.Column;\n  else if (!Current.isOneOf(tok::comment, tok::identifier, tok::hash) &&\n           !Current.isStringLiteral())\n    State.StartOfStringLiteral = 0;\n\n  State.Column += Current.ColumnWidth;\n  State.NextToken = State.NextToken->Next;\n\n  unsigned Penalty =\n      handleEndOfLine(Current, State, DryRun, AllowBreak, Newline);\n\n  if (Current.Role)\n    Current.Role->formatFromToken(State, this, DryRun);\n  // If the previous has a special role, let it consume tokens as appropriate.\n  // It is necessary to start at the previous token for the only implemented\n  // role (comma separated list). That way, the decision whether or not to break\n  // after the \"{\" is already done and both options are tried and evaluated.\n  // FIXME: This is ugly, find a better way.\n  if (Previous && Previous->Role)\n    Penalty += Previous->Role->formatAfterToken(State, this, DryRun);\n\n  return Penalty;\n}\n\nvoid ContinuationIndenter::moveStatePastFakeLParens(LineState &State,\n                                                    bool Newline) {\n  const FormatToken &Current = *State.NextToken;\n  const FormatToken *Previous = Current.getPreviousNonComment();\n\n  // Don't add extra indentation for the first fake parenthesis after\n  // 'return', assignments or opening <({[. The indentation for these cases\n  // is special cased.\n  bool SkipFirstExtraIndent =\n      (Previous && (Previous->opensScope() ||\n                    Previous->isOneOf(tok::semi, tok::kw_return) ||\n                    (Previous->getPrecedence() == prec::Assignment &&\n                     Style.AlignOperands != FormatStyle::OAS_DontAlign) ||\n                    Previous->is(TT_ObjCMethodExpr)));\n  for (SmallVectorImpl<prec::Level>::const_reverse_iterator\n           I = Current.FakeLParens.rbegin(),\n           E = Current.FakeLParens.rend();\n       I != E; ++I) {\n    ParenState NewParenState = State.Stack.back();\n    NewParenState.Tok = nullptr;\n    NewParenState.ContainsLineBreak = false;\n    NewParenState.LastOperatorWrapped = true;\n    NewParenState.IsChainedConditional = false;\n    NewParenState.IsWrappedConditional = false;\n    NewParenState.UnindentOperator = false;\n    NewParenState.NoLineBreak =\n        NewParenState.NoLineBreak || State.Stack.back().NoLineBreakInOperand;\n\n    // Don't propagate AvoidBinPacking into subexpressions of arg/param lists.\n    if (*I > prec::Comma)\n      NewParenState.AvoidBinPacking = false;\n\n    // Indent from 'LastSpace' unless these are fake parentheses encapsulating\n    // a builder type call after 'return' or, if the alignment after opening\n    // brackets is disabled.\n    if (!Current.isTrailingComment() &&\n        (Style.AlignOperands != FormatStyle::OAS_DontAlign ||\n         *I < prec::Assignment) &&\n        (!Previous || Previous->isNot(tok::kw_return) ||\n         (Style.Language != FormatStyle::LK_Java && *I > 0)) &&\n        (Style.AlignAfterOpenBracket != FormatStyle::BAS_DontAlign ||\n         *I != prec::Comma || Current.NestingLevel == 0)) {\n      NewParenState.Indent =\n          std::max(std::max(State.Column, NewParenState.Indent),\n                   State.Stack.back().LastSpace);\n    }\n\n    if (Previous &&\n        (Previous->getPrecedence() == prec::Assignment ||\n         Previous->is(tok::kw_return) ||\n         (*I == prec::Conditional && Previous->is(tok::question) &&\n          Previous->is(TT_ConditionalExpr))) &&\n        !Newline) {\n      // If BreakBeforeBinaryOperators is set, un-indent a bit to account for\n      // the operator and keep the operands aligned\n      if (Style.AlignOperands == FormatStyle::OAS_AlignAfterOperator)\n        NewParenState.UnindentOperator = true;\n      // Mark indentation as alignment if the expression is aligned.\n      if (Style.AlignOperands != FormatStyle::OAS_DontAlign)\n        NewParenState.IsAligned = true;\n    }\n\n    // Do not indent relative to the fake parentheses inserted for \".\" or \"->\".\n    // This is a special case to make the following to statements consistent:\n    //   OuterFunction(InnerFunctionCall( // break\n    //       ParameterToInnerFunction));\n    //   OuterFunction(SomeObject.InnerFunctionCall( // break\n    //       ParameterToInnerFunction));\n    if (*I > prec::Unknown)\n      NewParenState.LastSpace = std::max(NewParenState.LastSpace, State.Column);\n    if (*I != prec::Conditional && !Current.is(TT_UnaryOperator) &&\n        Style.AlignAfterOpenBracket != FormatStyle::BAS_DontAlign)\n      NewParenState.StartOfFunctionCall = State.Column;\n\n    // Indent conditional expressions, unless they are chained \"else-if\"\n    // conditionals. Never indent expression where the 'operator' is ',', ';' or\n    // an assignment (i.e. *I <= prec::Assignment) as those have different\n    // indentation rules. Indent other expression, unless the indentation needs\n    // to be skipped.\n    if (*I == prec::Conditional && Previous && Previous->is(tok::colon) &&\n        Previous->is(TT_ConditionalExpr) && I == Current.FakeLParens.rbegin() &&\n        !State.Stack.back().IsWrappedConditional) {\n      NewParenState.IsChainedConditional = true;\n      NewParenState.UnindentOperator = State.Stack.back().UnindentOperator;\n    } else if (*I == prec::Conditional ||\n               (!SkipFirstExtraIndent && *I > prec::Assignment &&\n                !Current.isTrailingComment())) {\n      NewParenState.Indent += Style.ContinuationIndentWidth;\n    }\n    if ((Previous && !Previous->opensScope()) || *I != prec::Comma)\n      NewParenState.BreakBeforeParameter = false;\n    State.Stack.push_back(NewParenState);\n    SkipFirstExtraIndent = false;\n  }\n}\n\nvoid ContinuationIndenter::moveStatePastFakeRParens(LineState &State) {\n  for (unsigned i = 0, e = State.NextToken->FakeRParens; i != e; ++i) {\n    unsigned VariablePos = State.Stack.back().VariablePos;\n    if (State.Stack.size() == 1) {\n      // Do not pop the last element.\n      break;\n    }\n    State.Stack.pop_back();\n    State.Stack.back().VariablePos = VariablePos;\n  }\n}\n\nvoid ContinuationIndenter::moveStatePastScopeOpener(LineState &State,\n                                                    bool Newline) {\n  const FormatToken &Current = *State.NextToken;\n  if (!Current.opensScope())\n    return;\n\n  // Don't allow '<' or '(' in C# generic type constraints to start new scopes.\n  if (Current.isOneOf(tok::less, tok::l_paren) &&\n      State.Stack.back().IsCSharpGenericTypeConstraint)\n    return;\n\n  if (Current.MatchingParen && Current.is(BK_Block)) {\n    moveStateToNewBlock(State);\n    return;\n  }\n\n  unsigned NewIndent;\n  unsigned LastSpace = State.Stack.back().LastSpace;\n  bool AvoidBinPacking;\n  bool BreakBeforeParameter = false;\n  unsigned NestedBlockIndent = std::max(State.Stack.back().StartOfFunctionCall,\n                                        State.Stack.back().NestedBlockIndent);\n  if (Current.isOneOf(tok::l_brace, TT_ArrayInitializerLSquare) ||\n      opensProtoMessageField(Current, Style)) {\n    if (Current.opensBlockOrBlockTypeList(Style)) {\n      NewIndent = Style.IndentWidth +\n                  std::min(State.Column, State.Stack.back().NestedBlockIndent);\n    } else {\n      NewIndent = State.Stack.back().LastSpace + Style.ContinuationIndentWidth;\n    }\n    const FormatToken *NextNoComment = Current.getNextNonComment();\n    bool EndsInComma = Current.MatchingParen &&\n                       Current.MatchingParen->Previous &&\n                       Current.MatchingParen->Previous->is(tok::comma);\n    AvoidBinPacking = EndsInComma || Current.is(TT_DictLiteral) ||\n                      Style.Language == FormatStyle::LK_Proto ||\n                      Style.Language == FormatStyle::LK_TextProto ||\n                      !Style.BinPackArguments ||\n                      (NextNoComment &&\n                       NextNoComment->isOneOf(TT_DesignatedInitializerPeriod,\n                                              TT_DesignatedInitializerLSquare));\n    BreakBeforeParameter = EndsInComma;\n    if (Current.ParameterCount > 1)\n      NestedBlockIndent = std::max(NestedBlockIndent, State.Column + 1);\n  } else {\n    NewIndent = Style.ContinuationIndentWidth +\n                std::max(State.Stack.back().LastSpace,\n                         State.Stack.back().StartOfFunctionCall);\n\n    // Ensure that different different brackets force relative alignment, e.g.:\n    // void SomeFunction(vector<  // break\n    //                       int> v);\n    // FIXME: We likely want to do this for more combinations of brackets.\n    if (Current.is(tok::less) && Current.ParentBracket == tok::l_paren) {\n      NewIndent = std::max(NewIndent, State.Stack.back().Indent);\n      LastSpace = std::max(LastSpace, State.Stack.back().Indent);\n    }\n\n    bool EndsInComma =\n        Current.MatchingParen &&\n        Current.MatchingParen->getPreviousNonComment() &&\n        Current.MatchingParen->getPreviousNonComment()->is(tok::comma);\n\n    // If ObjCBinPackProtocolList is unspecified, fall back to BinPackParameters\n    // for backwards compatibility.\n    bool ObjCBinPackProtocolList =\n        (Style.ObjCBinPackProtocolList == FormatStyle::BPS_Auto &&\n         Style.BinPackParameters) ||\n        Style.ObjCBinPackProtocolList == FormatStyle::BPS_Always;\n\n    bool BinPackDeclaration =\n        (State.Line->Type != LT_ObjCDecl && Style.BinPackParameters) ||\n        (State.Line->Type == LT_ObjCDecl && ObjCBinPackProtocolList);\n\n    AvoidBinPacking =\n        (State.Stack.back().IsCSharpGenericTypeConstraint) ||\n        (Style.Language == FormatStyle::LK_JavaScript && EndsInComma) ||\n        (State.Line->MustBeDeclaration && !BinPackDeclaration) ||\n        (!State.Line->MustBeDeclaration && !Style.BinPackArguments) ||\n        (Style.ExperimentalAutoDetectBinPacking &&\n         (Current.is(PPK_OnePerLine) ||\n          (!BinPackInconclusiveFunctions && Current.is(PPK_Inconclusive))));\n\n    if (Current.is(TT_ObjCMethodExpr) && Current.MatchingParen &&\n        Style.ObjCBreakBeforeNestedBlockParam) {\n      if (Style.ColumnLimit) {\n        // If this '[' opens an ObjC call, determine whether all parameters fit\n        // into one line and put one per line if they don't.\n        if (getLengthToMatchingParen(Current, State.Stack) + State.Column >\n            getColumnLimit(State))\n          BreakBeforeParameter = true;\n      } else {\n        // For ColumnLimit = 0, we have to figure out whether there is or has to\n        // be a line break within this call.\n        for (const FormatToken *Tok = &Current;\n             Tok && Tok != Current.MatchingParen; Tok = Tok->Next) {\n          if (Tok->MustBreakBefore ||\n              (Tok->CanBreakBefore && Tok->NewlinesBefore > 0)) {\n            BreakBeforeParameter = true;\n            break;\n          }\n        }\n      }\n    }\n\n    if (Style.Language == FormatStyle::LK_JavaScript && EndsInComma)\n      BreakBeforeParameter = true;\n  }\n  // Generally inherit NoLineBreak from the current scope to nested scope.\n  // However, don't do this for non-empty nested blocks, dict literals and\n  // array literals as these follow different indentation rules.\n  bool NoLineBreak =\n      Current.Children.empty() &&\n      !Current.isOneOf(TT_DictLiteral, TT_ArrayInitializerLSquare) &&\n      (State.Stack.back().NoLineBreak ||\n       State.Stack.back().NoLineBreakInOperand ||\n       (Current.is(TT_TemplateOpener) &&\n        State.Stack.back().ContainsUnwrappedBuilder));\n  State.Stack.push_back(\n      ParenState(&Current, NewIndent, LastSpace, AvoidBinPacking, NoLineBreak));\n  State.Stack.back().NestedBlockIndent = NestedBlockIndent;\n  State.Stack.back().BreakBeforeParameter = BreakBeforeParameter;\n  State.Stack.back().HasMultipleNestedBlocks =\n      (Current.BlockParameterCount > 1);\n\n  if (Style.BraceWrapping.BeforeLambdaBody && Current.Next != nullptr &&\n      Current.Tok.is(tok::l_paren)) {\n    // Search for any parameter that is a lambda\n    FormatToken const *next = Current.Next;\n    while (next != nullptr) {\n      if (next->is(TT_LambdaLSquare)) {\n        State.Stack.back().HasMultipleNestedBlocks = true;\n        break;\n      }\n      next = next->Next;\n    }\n  }\n\n  State.Stack.back().IsInsideObjCArrayLiteral =\n      Current.is(TT_ArrayInitializerLSquare) && Current.Previous &&\n      Current.Previous->is(tok::at);\n}\n\nvoid ContinuationIndenter::moveStatePastScopeCloser(LineState &State) {\n  const FormatToken &Current = *State.NextToken;\n  if (!Current.closesScope())\n    return;\n\n  // If we encounter a closing ), ], } or >, we can remove a level from our\n  // stacks.\n  if (State.Stack.size() > 1 &&\n      (Current.isOneOf(tok::r_paren, tok::r_square, TT_TemplateString) ||\n       (Current.is(tok::r_brace) && State.NextToken != State.Line->First) ||\n       State.NextToken->is(TT_TemplateCloser) ||\n       (Current.is(tok::greater) && Current.is(TT_DictLiteral))))\n    State.Stack.pop_back();\n\n  // Reevaluate whether ObjC message arguments fit into one line.\n  // If a receiver spans multiple lines, e.g.:\n  //   [[object block:^{\n  //     return 42;\n  //   }] a:42 b:42];\n  // BreakBeforeParameter is calculated based on an incorrect assumption\n  // (it is checked whether the whole expression fits into one line without\n  // considering a line break inside a message receiver).\n  // We check whether arguements fit after receiver scope closer (into the same\n  // line).\n  if (State.Stack.back().BreakBeforeParameter && Current.MatchingParen &&\n      Current.MatchingParen->Previous) {\n    const FormatToken &CurrentScopeOpener = *Current.MatchingParen->Previous;\n    if (CurrentScopeOpener.is(TT_ObjCMethodExpr) &&\n        CurrentScopeOpener.MatchingParen) {\n      int NecessarySpaceInLine =\n          getLengthToMatchingParen(CurrentScopeOpener, State.Stack) +\n          CurrentScopeOpener.TotalLength - Current.TotalLength - 1;\n      if (State.Column + Current.ColumnWidth + NecessarySpaceInLine <=\n          Style.ColumnLimit)\n        State.Stack.back().BreakBeforeParameter = false;\n    }\n  }\n\n  if (Current.is(tok::r_square)) {\n    // If this ends the array subscript expr, reset the corresponding value.\n    const FormatToken *NextNonComment = Current.getNextNonComment();\n    if (NextNonComment && NextNonComment->isNot(tok::l_square))\n      State.Stack.back().StartOfArraySubscripts = 0;\n  }\n}\n\nvoid ContinuationIndenter::moveStateToNewBlock(LineState &State) {\n  unsigned NestedBlockIndent = State.Stack.back().NestedBlockIndent;\n  // ObjC block sometimes follow special indentation rules.\n  unsigned NewIndent =\n      NestedBlockIndent + (State.NextToken->is(TT_ObjCBlockLBrace)\n                               ? Style.ObjCBlockIndentWidth\n                               : Style.IndentWidth);\n  State.Stack.push_back(ParenState(State.NextToken, NewIndent,\n                                   State.Stack.back().LastSpace,\n                                   /*AvoidBinPacking=*/true,\n                                   /*NoLineBreak=*/false));\n  State.Stack.back().NestedBlockIndent = NestedBlockIndent;\n  State.Stack.back().BreakBeforeParameter = true;\n}\n\nstatic unsigned getLastLineEndColumn(StringRef Text, unsigned StartColumn,\n                                     unsigned TabWidth,\n                                     encoding::Encoding Encoding) {\n  size_t LastNewlinePos = Text.find_last_of(\"\\n\");\n  if (LastNewlinePos == StringRef::npos) {\n    return StartColumn +\n           encoding::columnWidthWithTabs(Text, StartColumn, TabWidth, Encoding);\n  } else {\n    return encoding::columnWidthWithTabs(Text.substr(LastNewlinePos),\n                                         /*StartColumn=*/0, TabWidth, Encoding);\n  }\n}\n\nunsigned ContinuationIndenter::reformatRawStringLiteral(\n    const FormatToken &Current, LineState &State,\n    const FormatStyle &RawStringStyle, bool DryRun, bool Newline) {\n  unsigned StartColumn = State.Column - Current.ColumnWidth;\n  StringRef OldDelimiter = *getRawStringDelimiter(Current.TokenText);\n  StringRef NewDelimiter =\n      getCanonicalRawStringDelimiter(Style, RawStringStyle.Language);\n  if (NewDelimiter.empty())\n    NewDelimiter = OldDelimiter;\n  // The text of a raw string is between the leading 'R\"delimiter(' and the\n  // trailing 'delimiter)\"'.\n  unsigned OldPrefixSize = 3 + OldDelimiter.size();\n  unsigned OldSuffixSize = 2 + OldDelimiter.size();\n  // We create a virtual text environment which expects a null-terminated\n  // string, so we cannot use StringRef.\n  std::string RawText = std::string(\n      Current.TokenText.substr(OldPrefixSize).drop_back(OldSuffixSize));\n  if (NewDelimiter != OldDelimiter) {\n    // Don't update to the canonical delimiter 'deli' if ')deli\"' occurs in the\n    // raw string.\n    std::string CanonicalDelimiterSuffix = (\")\" + NewDelimiter + \"\\\"\").str();\n    if (StringRef(RawText).contains(CanonicalDelimiterSuffix))\n      NewDelimiter = OldDelimiter;\n  }\n\n  unsigned NewPrefixSize = 3 + NewDelimiter.size();\n  unsigned NewSuffixSize = 2 + NewDelimiter.size();\n\n  // The first start column is the column the raw text starts after formatting.\n  unsigned FirstStartColumn = StartColumn + NewPrefixSize;\n\n  // The next start column is the intended indentation a line break inside\n  // the raw string at level 0. It is determined by the following rules:\n  //   - if the content starts on newline, it is one level more than the current\n  //     indent, and\n  //   - if the content does not start on a newline, it is the first start\n  //     column.\n  // These rules have the advantage that the formatted content both does not\n  // violate the rectangle rule and visually flows within the surrounding\n  // source.\n  bool ContentStartsOnNewline = Current.TokenText[OldPrefixSize] == '\\n';\n  // If this token is the last parameter (checked by looking if it's followed by\n  // `)` and is not on a newline, the base the indent off the line's nested\n  // block indent. Otherwise, base the indent off the arguments indent, so we\n  // can achieve:\n  //\n  // fffffffffff(1, 2, 3, R\"pb(\n  //     key1: 1  #\n  //     key2: 2)pb\");\n  //\n  // fffffffffff(1, 2, 3,\n  //             R\"pb(\n  //               key1: 1  #\n  //               key2: 2\n  //             )pb\");\n  //\n  // fffffffffff(1, 2, 3,\n  //             R\"pb(\n  //               key1: 1  #\n  //               key2: 2\n  //             )pb\",\n  //             5);\n  unsigned CurrentIndent =\n      (!Newline && Current.Next && Current.Next->is(tok::r_paren))\n          ? State.Stack.back().NestedBlockIndent\n          : State.Stack.back().Indent;\n  unsigned NextStartColumn = ContentStartsOnNewline\n                                 ? CurrentIndent + Style.IndentWidth\n                                 : FirstStartColumn;\n\n  // The last start column is the column the raw string suffix starts if it is\n  // put on a newline.\n  // The last start column is the intended indentation of the raw string postfix\n  // if it is put on a newline. It is determined by the following rules:\n  //   - if the raw string prefix starts on a newline, it is the column where\n  //     that raw string prefix starts, and\n  //   - if the raw string prefix does not start on a newline, it is the current\n  //     indent.\n  unsigned LastStartColumn =\n      Current.NewlinesBefore ? FirstStartColumn - NewPrefixSize : CurrentIndent;\n\n  std::pair<tooling::Replacements, unsigned> Fixes = internal::reformat(\n      RawStringStyle, RawText, {tooling::Range(0, RawText.size())},\n      FirstStartColumn, NextStartColumn, LastStartColumn, \"<stdin>\",\n      /*Status=*/nullptr);\n\n  auto NewCode = applyAllReplacements(RawText, Fixes.first);\n  tooling::Replacements NoFixes;\n  if (!NewCode) {\n    return addMultilineToken(Current, State);\n  }\n  if (!DryRun) {\n    if (NewDelimiter != OldDelimiter) {\n      // In 'R\"delimiter(...', the delimiter starts 2 characters after the start\n      // of the token.\n      SourceLocation PrefixDelimiterStart =\n          Current.Tok.getLocation().getLocWithOffset(2);\n      auto PrefixErr = Whitespaces.addReplacement(tooling::Replacement(\n          SourceMgr, PrefixDelimiterStart, OldDelimiter.size(), NewDelimiter));\n      if (PrefixErr) {\n        llvm::errs()\n            << \"Failed to update the prefix delimiter of a raw string: \"\n            << llvm::toString(std::move(PrefixErr)) << \"\\n\";\n      }\n      // In 'R\"delimiter(...)delimiter\"', the suffix delimiter starts at\n      // position length - 1 - |delimiter|.\n      SourceLocation SuffixDelimiterStart =\n          Current.Tok.getLocation().getLocWithOffset(Current.TokenText.size() -\n                                                     1 - OldDelimiter.size());\n      auto SuffixErr = Whitespaces.addReplacement(tooling::Replacement(\n          SourceMgr, SuffixDelimiterStart, OldDelimiter.size(), NewDelimiter));\n      if (SuffixErr) {\n        llvm::errs()\n            << \"Failed to update the suffix delimiter of a raw string: \"\n            << llvm::toString(std::move(SuffixErr)) << \"\\n\";\n      }\n    }\n    SourceLocation OriginLoc =\n        Current.Tok.getLocation().getLocWithOffset(OldPrefixSize);\n    for (const tooling::Replacement &Fix : Fixes.first) {\n      auto Err = Whitespaces.addReplacement(tooling::Replacement(\n          SourceMgr, OriginLoc.getLocWithOffset(Fix.getOffset()),\n          Fix.getLength(), Fix.getReplacementText()));\n      if (Err) {\n        llvm::errs() << \"Failed to reformat raw string: \"\n                     << llvm::toString(std::move(Err)) << \"\\n\";\n      }\n    }\n  }\n  unsigned RawLastLineEndColumn = getLastLineEndColumn(\n      *NewCode, FirstStartColumn, Style.TabWidth, Encoding);\n  State.Column = RawLastLineEndColumn + NewSuffixSize;\n  // Since we're updating the column to after the raw string literal here, we\n  // have to manually add the penalty for the prefix R\"delim( over the column\n  // limit.\n  unsigned PrefixExcessCharacters =\n      StartColumn + NewPrefixSize > Style.ColumnLimit\n          ? StartColumn + NewPrefixSize - Style.ColumnLimit\n          : 0;\n  bool IsMultiline =\n      ContentStartsOnNewline || (NewCode->find('\\n') != std::string::npos);\n  if (IsMultiline) {\n    // Break before further function parameters on all levels.\n    for (unsigned i = 0, e = State.Stack.size(); i != e; ++i)\n      State.Stack[i].BreakBeforeParameter = true;\n  }\n  return Fixes.second + PrefixExcessCharacters * Style.PenaltyExcessCharacter;\n}\n\nunsigned ContinuationIndenter::addMultilineToken(const FormatToken &Current,\n                                                 LineState &State) {\n  // Break before further function parameters on all levels.\n  for (unsigned i = 0, e = State.Stack.size(); i != e; ++i)\n    State.Stack[i].BreakBeforeParameter = true;\n\n  unsigned ColumnsUsed = State.Column;\n  // We can only affect layout of the first and the last line, so the penalty\n  // for all other lines is constant, and we ignore it.\n  State.Column = Current.LastLineColumnWidth;\n\n  if (ColumnsUsed > getColumnLimit(State))\n    return Style.PenaltyExcessCharacter * (ColumnsUsed - getColumnLimit(State));\n  return 0;\n}\n\nunsigned ContinuationIndenter::handleEndOfLine(const FormatToken &Current,\n                                               LineState &State, bool DryRun,\n                                               bool AllowBreak, bool Newline) {\n  unsigned Penalty = 0;\n  // Compute the raw string style to use in case this is a raw string literal\n  // that can be reformatted.\n  auto RawStringStyle = getRawStringStyle(Current, State);\n  if (RawStringStyle && !Current.Finalized) {\n    Penalty = reformatRawStringLiteral(Current, State, *RawStringStyle, DryRun,\n                                       Newline);\n  } else if (Current.IsMultiline && Current.isNot(TT_BlockComment)) {\n    // Don't break multi-line tokens other than block comments and raw string\n    // literals. Instead, just update the state.\n    Penalty = addMultilineToken(Current, State);\n  } else if (State.Line->Type != LT_ImportStatement) {\n    // We generally don't break import statements.\n    LineState OriginalState = State;\n\n    // Whether we force the reflowing algorithm to stay strictly within the\n    // column limit.\n    bool Strict = false;\n    // Whether the first non-strict attempt at reflowing did intentionally\n    // exceed the column limit.\n    bool Exceeded = false;\n    std::tie(Penalty, Exceeded) = breakProtrudingToken(\n        Current, State, AllowBreak, /*DryRun=*/true, Strict);\n    if (Exceeded) {\n      // If non-strict reflowing exceeds the column limit, try whether strict\n      // reflowing leads to an overall lower penalty.\n      LineState StrictState = OriginalState;\n      unsigned StrictPenalty =\n          breakProtrudingToken(Current, StrictState, AllowBreak,\n                               /*DryRun=*/true, /*Strict=*/true)\n              .first;\n      Strict = StrictPenalty <= Penalty;\n      if (Strict) {\n        Penalty = StrictPenalty;\n        State = StrictState;\n      }\n    }\n    if (!DryRun) {\n      // If we're not in dry-run mode, apply the changes with the decision on\n      // strictness made above.\n      breakProtrudingToken(Current, OriginalState, AllowBreak, /*DryRun=*/false,\n                           Strict);\n    }\n  }\n  if (State.Column > getColumnLimit(State)) {\n    unsigned ExcessCharacters = State.Column - getColumnLimit(State);\n    Penalty += Style.PenaltyExcessCharacter * ExcessCharacters;\n  }\n  return Penalty;\n}\n\n// Returns the enclosing function name of a token, or the empty string if not\n// found.\nstatic StringRef getEnclosingFunctionName(const FormatToken &Current) {\n  // Look for: 'function(' or 'function<templates>(' before Current.\n  auto Tok = Current.getPreviousNonComment();\n  if (!Tok || !Tok->is(tok::l_paren))\n    return \"\";\n  Tok = Tok->getPreviousNonComment();\n  if (!Tok)\n    return \"\";\n  if (Tok->is(TT_TemplateCloser)) {\n    Tok = Tok->MatchingParen;\n    if (Tok)\n      Tok = Tok->getPreviousNonComment();\n  }\n  if (!Tok || !Tok->is(tok::identifier))\n    return \"\";\n  return Tok->TokenText;\n}\n\nllvm::Optional<FormatStyle>\nContinuationIndenter::getRawStringStyle(const FormatToken &Current,\n                                        const LineState &State) {\n  if (!Current.isStringLiteral())\n    return None;\n  auto Delimiter = getRawStringDelimiter(Current.TokenText);\n  if (!Delimiter)\n    return None;\n  auto RawStringStyle = RawStringFormats.getDelimiterStyle(*Delimiter);\n  if (!RawStringStyle && Delimiter->empty())\n    RawStringStyle = RawStringFormats.getEnclosingFunctionStyle(\n        getEnclosingFunctionName(Current));\n  if (!RawStringStyle)\n    return None;\n  RawStringStyle->ColumnLimit = getColumnLimit(State);\n  return RawStringStyle;\n}\n\nstd::unique_ptr<BreakableToken>\nContinuationIndenter::createBreakableToken(const FormatToken &Current,\n                                           LineState &State, bool AllowBreak) {\n  unsigned StartColumn = State.Column - Current.ColumnWidth;\n  if (Current.isStringLiteral()) {\n    // FIXME: String literal breaking is currently disabled for C#, Java and\n    // JavaScript, as it requires strings to be merged using \"+\" which we\n    // don't support.\n    if (Style.Language == FormatStyle::LK_Java ||\n        Style.Language == FormatStyle::LK_JavaScript || Style.isCSharp() ||\n        !Style.BreakStringLiterals || !AllowBreak)\n      return nullptr;\n\n    // Don't break string literals inside preprocessor directives (except for\n    // #define directives, as their contents are stored in separate lines and\n    // are not affected by this check).\n    // This way we avoid breaking code with line directives and unknown\n    // preprocessor directives that contain long string literals.\n    if (State.Line->Type == LT_PreprocessorDirective)\n      return nullptr;\n    // Exempts unterminated string literals from line breaking. The user will\n    // likely want to terminate the string before any line breaking is done.\n    if (Current.IsUnterminatedLiteral)\n      return nullptr;\n    // Don't break string literals inside Objective-C array literals (doing so\n    // raises the warning -Wobjc-string-concatenation).\n    if (State.Stack.back().IsInsideObjCArrayLiteral) {\n      return nullptr;\n    }\n\n    StringRef Text = Current.TokenText;\n    StringRef Prefix;\n    StringRef Postfix;\n    // FIXME: Handle whitespace between '_T', '(', '\"...\"', and ')'.\n    // FIXME: Store Prefix and Suffix (or PrefixLength and SuffixLength to\n    // reduce the overhead) for each FormatToken, which is a string, so that we\n    // don't run multiple checks here on the hot path.\n    if ((Text.endswith(Postfix = \"\\\"\") &&\n         (Text.startswith(Prefix = \"@\\\"\") || Text.startswith(Prefix = \"\\\"\") ||\n          Text.startswith(Prefix = \"u\\\"\") || Text.startswith(Prefix = \"U\\\"\") ||\n          Text.startswith(Prefix = \"u8\\\"\") ||\n          Text.startswith(Prefix = \"L\\\"\"))) ||\n        (Text.startswith(Prefix = \"_T(\\\"\") && Text.endswith(Postfix = \"\\\")\"))) {\n      // We need this to address the case where there is an unbreakable tail\n      // only if certain other formatting decisions have been taken. The\n      // UnbreakableTailLength of Current is an overapproximation is that case\n      // and we need to be correct here.\n      unsigned UnbreakableTailLength = (State.NextToken && canBreak(State))\n                                           ? 0\n                                           : Current.UnbreakableTailLength;\n      return std::make_unique<BreakableStringLiteral>(\n          Current, StartColumn, Prefix, Postfix, UnbreakableTailLength,\n          State.Line->InPPDirective, Encoding, Style);\n    }\n  } else if (Current.is(TT_BlockComment)) {\n    if (!Style.ReflowComments ||\n        // If a comment token switches formatting, like\n        // /* clang-format on */, we don't want to break it further,\n        // but we may still want to adjust its indentation.\n        switchesFormatting(Current)) {\n      return nullptr;\n    }\n    return std::make_unique<BreakableBlockComment>(\n        Current, StartColumn, Current.OriginalColumn, !Current.Previous,\n        State.Line->InPPDirective, Encoding, Style, Whitespaces.useCRLF());\n  } else if (Current.is(TT_LineComment) &&\n             (Current.Previous == nullptr ||\n              Current.Previous->isNot(TT_ImplicitStringLiteral))) {\n    if (!Style.ReflowComments ||\n        CommentPragmasRegex.match(Current.TokenText.substr(2)) ||\n        switchesFormatting(Current))\n      return nullptr;\n    return std::make_unique<BreakableLineCommentSection>(\n        Current, StartColumn, /*InPPDirective=*/false, Encoding, Style);\n  }\n  return nullptr;\n}\n\nstd::pair<unsigned, bool>\nContinuationIndenter::breakProtrudingToken(const FormatToken &Current,\n                                           LineState &State, bool AllowBreak,\n                                           bool DryRun, bool Strict) {\n  std::unique_ptr<const BreakableToken> Token =\n      createBreakableToken(Current, State, AllowBreak);\n  if (!Token)\n    return {0, false};\n  assert(Token->getLineCount() > 0);\n  unsigned ColumnLimit = getColumnLimit(State);\n  if (Current.is(TT_LineComment)) {\n    // We don't insert backslashes when breaking line comments.\n    ColumnLimit = Style.ColumnLimit;\n  }\n  if (ColumnLimit == 0) {\n    // To make the rest of the function easier set the column limit to the\n    // maximum, if there should be no limit.\n    ColumnLimit = std::numeric_limits<decltype(ColumnLimit)>::max();\n  }\n  if (Current.UnbreakableTailLength >= ColumnLimit)\n    return {0, false};\n  // ColumnWidth was already accounted into State.Column before calling\n  // breakProtrudingToken.\n  unsigned StartColumn = State.Column - Current.ColumnWidth;\n  unsigned NewBreakPenalty = Current.isStringLiteral()\n                                 ? Style.PenaltyBreakString\n                                 : Style.PenaltyBreakComment;\n  // Stores whether we intentionally decide to let a line exceed the column\n  // limit.\n  bool Exceeded = false;\n  // Stores whether we introduce a break anywhere in the token.\n  bool BreakInserted = Token->introducesBreakBeforeToken();\n  // Store whether we inserted a new line break at the end of the previous\n  // logical line.\n  bool NewBreakBefore = false;\n  // We use a conservative reflowing strategy. Reflow starts after a line is\n  // broken or the corresponding whitespace compressed. Reflow ends as soon as a\n  // line that doesn't get reflown with the previous line is reached.\n  bool Reflow = false;\n  // Keep track of where we are in the token:\n  // Where we are in the content of the current logical line.\n  unsigned TailOffset = 0;\n  // The column number we're currently at.\n  unsigned ContentStartColumn =\n      Token->getContentStartColumn(0, /*Break=*/false);\n  // The number of columns left in the current logical line after TailOffset.\n  unsigned RemainingTokenColumns =\n      Token->getRemainingLength(0, TailOffset, ContentStartColumn);\n  // Adapt the start of the token, for example indent.\n  if (!DryRun)\n    Token->adaptStartOfLine(0, Whitespaces);\n\n  unsigned ContentIndent = 0;\n  unsigned Penalty = 0;\n  LLVM_DEBUG(llvm::dbgs() << \"Breaking protruding token at column \"\n                          << StartColumn << \".\\n\");\n  for (unsigned LineIndex = 0, EndIndex = Token->getLineCount();\n       LineIndex != EndIndex; ++LineIndex) {\n    LLVM_DEBUG(llvm::dbgs()\n               << \"  Line: \" << LineIndex << \" (Reflow: \" << Reflow << \")\\n\");\n    NewBreakBefore = false;\n    // If we did reflow the previous line, we'll try reflowing again. Otherwise\n    // we'll start reflowing if the current line is broken or whitespace is\n    // compressed.\n    bool TryReflow = Reflow;\n    // Break the current token until we can fit the rest of the line.\n    while (ContentStartColumn + RemainingTokenColumns > ColumnLimit) {\n      LLVM_DEBUG(llvm::dbgs() << \"    Over limit, need: \"\n                              << (ContentStartColumn + RemainingTokenColumns)\n                              << \", space: \" << ColumnLimit\n                              << \", reflown prefix: \" << ContentStartColumn\n                              << \", offset in line: \" << TailOffset << \"\\n\");\n      // If the current token doesn't fit, find the latest possible split in the\n      // current line so that breaking at it will be under the column limit.\n      // FIXME: Use the earliest possible split while reflowing to correctly\n      // compress whitespace within a line.\n      BreakableToken::Split Split =\n          Token->getSplit(LineIndex, TailOffset, ColumnLimit,\n                          ContentStartColumn, CommentPragmasRegex);\n      if (Split.first == StringRef::npos) {\n        // No break opportunity - update the penalty and continue with the next\n        // logical line.\n        if (LineIndex < EndIndex - 1)\n          // The last line's penalty is handled in addNextStateToQueue() or when\n          // calling replaceWhitespaceAfterLastLine below.\n          Penalty += Style.PenaltyExcessCharacter *\n                     (ContentStartColumn + RemainingTokenColumns - ColumnLimit);\n        LLVM_DEBUG(llvm::dbgs() << \"    No break opportunity.\\n\");\n        break;\n      }\n      assert(Split.first != 0);\n\n      if (Token->supportsReflow()) {\n        // Check whether the next natural split point after the current one can\n        // still fit the line, either because we can compress away whitespace,\n        // or because the penalty the excess characters introduce is lower than\n        // the break penalty.\n        // We only do this for tokens that support reflowing, and thus allow us\n        // to change the whitespace arbitrarily (e.g. comments).\n        // Other tokens, like string literals, can be broken on arbitrary\n        // positions.\n\n        // First, compute the columns from TailOffset to the next possible split\n        // position.\n        // For example:\n        // ColumnLimit:     |\n        // // Some text   that    breaks\n        //    ^ tail offset\n        //             ^-- split\n        //    ^-------- to split columns\n        //                    ^--- next split\n        //    ^--------------- to next split columns\n        unsigned ToSplitColumns = Token->getRangeLength(\n            LineIndex, TailOffset, Split.first, ContentStartColumn);\n        LLVM_DEBUG(llvm::dbgs() << \"    ToSplit: \" << ToSplitColumns << \"\\n\");\n\n        BreakableToken::Split NextSplit = Token->getSplit(\n            LineIndex, TailOffset + Split.first + Split.second, ColumnLimit,\n            ContentStartColumn + ToSplitColumns + 1, CommentPragmasRegex);\n        // Compute the columns necessary to fit the next non-breakable sequence\n        // into the current line.\n        unsigned ToNextSplitColumns = 0;\n        if (NextSplit.first == StringRef::npos) {\n          ToNextSplitColumns = Token->getRemainingLength(LineIndex, TailOffset,\n                                                         ContentStartColumn);\n        } else {\n          ToNextSplitColumns = Token->getRangeLength(\n              LineIndex, TailOffset,\n              Split.first + Split.second + NextSplit.first, ContentStartColumn);\n        }\n        // Compress the whitespace between the break and the start of the next\n        // unbreakable sequence.\n        ToNextSplitColumns =\n            Token->getLengthAfterCompression(ToNextSplitColumns, Split);\n        LLVM_DEBUG(llvm::dbgs()\n                   << \"    ContentStartColumn: \" << ContentStartColumn << \"\\n\");\n        LLVM_DEBUG(llvm::dbgs()\n                   << \"    ToNextSplit: \" << ToNextSplitColumns << \"\\n\");\n        // If the whitespace compression makes us fit, continue on the current\n        // line.\n        bool ContinueOnLine =\n            ContentStartColumn + ToNextSplitColumns <= ColumnLimit;\n        unsigned ExcessCharactersPenalty = 0;\n        if (!ContinueOnLine && !Strict) {\n          // Similarly, if the excess characters' penalty is lower than the\n          // penalty of introducing a new break, continue on the current line.\n          ExcessCharactersPenalty =\n              (ContentStartColumn + ToNextSplitColumns - ColumnLimit) *\n              Style.PenaltyExcessCharacter;\n          LLVM_DEBUG(llvm::dbgs()\n                     << \"    Penalty excess: \" << ExcessCharactersPenalty\n                     << \"\\n            break : \" << NewBreakPenalty << \"\\n\");\n          if (ExcessCharactersPenalty < NewBreakPenalty) {\n            Exceeded = true;\n            ContinueOnLine = true;\n          }\n        }\n        if (ContinueOnLine) {\n          LLVM_DEBUG(llvm::dbgs() << \"    Continuing on line...\\n\");\n          // The current line fits after compressing the whitespace - reflow\n          // the next line into it if possible.\n          TryReflow = true;\n          if (!DryRun)\n            Token->compressWhitespace(LineIndex, TailOffset, Split,\n                                      Whitespaces);\n          // When we continue on the same line, leave one space between content.\n          ContentStartColumn += ToSplitColumns + 1;\n          Penalty += ExcessCharactersPenalty;\n          TailOffset += Split.first + Split.second;\n          RemainingTokenColumns = Token->getRemainingLength(\n              LineIndex, TailOffset, ContentStartColumn);\n          continue;\n        }\n      }\n      LLVM_DEBUG(llvm::dbgs() << \"    Breaking...\\n\");\n      // Update the ContentIndent only if the current line was not reflown with\n      // the previous line, since in that case the previous line should still\n      // determine the ContentIndent. Also never intent the last line.\n      if (!Reflow)\n        ContentIndent = Token->getContentIndent(LineIndex);\n      LLVM_DEBUG(llvm::dbgs()\n                 << \"    ContentIndent: \" << ContentIndent << \"\\n\");\n      ContentStartColumn = ContentIndent + Token->getContentStartColumn(\n                                               LineIndex, /*Break=*/true);\n\n      unsigned NewRemainingTokenColumns = Token->getRemainingLength(\n          LineIndex, TailOffset + Split.first + Split.second,\n          ContentStartColumn);\n      if (NewRemainingTokenColumns == 0) {\n        // No content to indent.\n        ContentIndent = 0;\n        ContentStartColumn =\n            Token->getContentStartColumn(LineIndex, /*Break=*/true);\n        NewRemainingTokenColumns = Token->getRemainingLength(\n            LineIndex, TailOffset + Split.first + Split.second,\n            ContentStartColumn);\n      }\n\n      // When breaking before a tab character, it may be moved by a few columns,\n      // but will still be expanded to the next tab stop, so we don't save any\n      // columns.\n      if (NewRemainingTokenColumns == RemainingTokenColumns) {\n        // FIXME: Do we need to adjust the penalty?\n        break;\n      }\n      assert(NewRemainingTokenColumns < RemainingTokenColumns);\n\n      LLVM_DEBUG(llvm::dbgs() << \"    Breaking at: \" << TailOffset + Split.first\n                              << \", \" << Split.second << \"\\n\");\n      if (!DryRun)\n        Token->insertBreak(LineIndex, TailOffset, Split, ContentIndent,\n                           Whitespaces);\n\n      Penalty += NewBreakPenalty;\n      TailOffset += Split.first + Split.second;\n      RemainingTokenColumns = NewRemainingTokenColumns;\n      BreakInserted = true;\n      NewBreakBefore = true;\n    }\n    // In case there's another line, prepare the state for the start of the next\n    // line.\n    if (LineIndex + 1 != EndIndex) {\n      unsigned NextLineIndex = LineIndex + 1;\n      if (NewBreakBefore)\n        // After breaking a line, try to reflow the next line into the current\n        // one once RemainingTokenColumns fits.\n        TryReflow = true;\n      if (TryReflow) {\n        // We decided that we want to try reflowing the next line into the\n        // current one.\n        // We will now adjust the state as if the reflow is successful (in\n        // preparation for the next line), and see whether that works. If we\n        // decide that we cannot reflow, we will later reset the state to the\n        // start of the next line.\n        Reflow = false;\n        // As we did not continue breaking the line, RemainingTokenColumns is\n        // known to fit after ContentStartColumn. Adapt ContentStartColumn to\n        // the position at which we want to format the next line if we do\n        // actually reflow.\n        // When we reflow, we need to add a space between the end of the current\n        // line and the next line's start column.\n        ContentStartColumn += RemainingTokenColumns + 1;\n        // Get the split that we need to reflow next logical line into the end\n        // of the current one; the split will include any leading whitespace of\n        // the next logical line.\n        BreakableToken::Split SplitBeforeNext =\n            Token->getReflowSplit(NextLineIndex, CommentPragmasRegex);\n        LLVM_DEBUG(llvm::dbgs()\n                   << \"    Size of reflown text: \" << ContentStartColumn\n                   << \"\\n    Potential reflow split: \");\n        if (SplitBeforeNext.first != StringRef::npos) {\n          LLVM_DEBUG(llvm::dbgs() << SplitBeforeNext.first << \", \"\n                                  << SplitBeforeNext.second << \"\\n\");\n          TailOffset = SplitBeforeNext.first + SplitBeforeNext.second;\n          // If the rest of the next line fits into the current line below the\n          // column limit, we can safely reflow.\n          RemainingTokenColumns = Token->getRemainingLength(\n              NextLineIndex, TailOffset, ContentStartColumn);\n          Reflow = true;\n          if (ContentStartColumn + RemainingTokenColumns > ColumnLimit) {\n            LLVM_DEBUG(llvm::dbgs()\n                       << \"    Over limit after reflow, need: \"\n                       << (ContentStartColumn + RemainingTokenColumns)\n                       << \", space: \" << ColumnLimit\n                       << \", reflown prefix: \" << ContentStartColumn\n                       << \", offset in line: \" << TailOffset << \"\\n\");\n            // If the whole next line does not fit, try to find a point in\n            // the next line at which we can break so that attaching the part\n            // of the next line to that break point onto the current line is\n            // below the column limit.\n            BreakableToken::Split Split =\n                Token->getSplit(NextLineIndex, TailOffset, ColumnLimit,\n                                ContentStartColumn, CommentPragmasRegex);\n            if (Split.first == StringRef::npos) {\n              LLVM_DEBUG(llvm::dbgs() << \"    Did not find later break\\n\");\n              Reflow = false;\n            } else {\n              // Check whether the first split point gets us below the column\n              // limit. Note that we will execute this split below as part of\n              // the normal token breaking and reflow logic within the line.\n              unsigned ToSplitColumns = Token->getRangeLength(\n                  NextLineIndex, TailOffset, Split.first, ContentStartColumn);\n              if (ContentStartColumn + ToSplitColumns > ColumnLimit) {\n                LLVM_DEBUG(llvm::dbgs() << \"    Next split protrudes, need: \"\n                                        << (ContentStartColumn + ToSplitColumns)\n                                        << \", space: \" << ColumnLimit);\n                unsigned ExcessCharactersPenalty =\n                    (ContentStartColumn + ToSplitColumns - ColumnLimit) *\n                    Style.PenaltyExcessCharacter;\n                if (NewBreakPenalty < ExcessCharactersPenalty) {\n                  Reflow = false;\n                }\n              }\n            }\n          }\n        } else {\n          LLVM_DEBUG(llvm::dbgs() << \"not found.\\n\");\n        }\n      }\n      if (!Reflow) {\n        // If we didn't reflow into the next line, the only space to consider is\n        // the next logical line. Reset our state to match the start of the next\n        // line.\n        TailOffset = 0;\n        ContentStartColumn =\n            Token->getContentStartColumn(NextLineIndex, /*Break=*/false);\n        RemainingTokenColumns = Token->getRemainingLength(\n            NextLineIndex, TailOffset, ContentStartColumn);\n        // Adapt the start of the token, for example indent.\n        if (!DryRun)\n          Token->adaptStartOfLine(NextLineIndex, Whitespaces);\n      } else {\n        // If we found a reflow split and have added a new break before the next\n        // line, we are going to remove the line break at the start of the next\n        // logical line. For example, here we'll add a new line break after\n        // 'text', and subsequently delete the line break between 'that' and\n        // 'reflows'.\n        //   // some text that\n        //   // reflows\n        // ->\n        //   // some text\n        //   // that reflows\n        // When adding the line break, we also added the penalty for it, so we\n        // need to subtract that penalty again when we remove the line break due\n        // to reflowing.\n        if (NewBreakBefore) {\n          assert(Penalty >= NewBreakPenalty);\n          Penalty -= NewBreakPenalty;\n        }\n        if (!DryRun)\n          Token->reflow(NextLineIndex, Whitespaces);\n      }\n    }\n  }\n\n  BreakableToken::Split SplitAfterLastLine =\n      Token->getSplitAfterLastLine(TailOffset);\n  if (SplitAfterLastLine.first != StringRef::npos) {\n    LLVM_DEBUG(llvm::dbgs() << \"Replacing whitespace after last line.\\n\");\n\n    // We add the last line's penalty here, since that line is going to be split\n    // now.\n    Penalty += Style.PenaltyExcessCharacter *\n               (ContentStartColumn + RemainingTokenColumns - ColumnLimit);\n\n    if (!DryRun)\n      Token->replaceWhitespaceAfterLastLine(TailOffset, SplitAfterLastLine,\n                                            Whitespaces);\n    ContentStartColumn =\n        Token->getContentStartColumn(Token->getLineCount() - 1, /*Break=*/true);\n    RemainingTokenColumns = Token->getRemainingLength(\n        Token->getLineCount() - 1,\n        TailOffset + SplitAfterLastLine.first + SplitAfterLastLine.second,\n        ContentStartColumn);\n  }\n\n  State.Column = ContentStartColumn + RemainingTokenColumns -\n                 Current.UnbreakableTailLength;\n\n  if (BreakInserted) {\n    // If we break the token inside a parameter list, we need to break before\n    // the next parameter on all levels, so that the next parameter is clearly\n    // visible. Line comments already introduce a break.\n    if (Current.isNot(TT_LineComment)) {\n      for (unsigned i = 0, e = State.Stack.size(); i != e; ++i)\n        State.Stack[i].BreakBeforeParameter = true;\n    }\n\n    if (Current.is(TT_BlockComment))\n      State.NoContinuation = true;\n\n    State.Stack.back().LastSpace = StartColumn;\n  }\n\n  Token->updateNextToken(State);\n\n  return {Penalty, Exceeded};\n}\n\nunsigned ContinuationIndenter::getColumnLimit(const LineState &State) const {\n  // In preprocessor directives reserve two chars for trailing \" \\\"\n  return Style.ColumnLimit - (State.Line->InPPDirective ? 2 : 0);\n}\n\nbool ContinuationIndenter::nextIsMultilineString(const LineState &State) {\n  const FormatToken &Current = *State.NextToken;\n  if (!Current.isStringLiteral() || Current.is(TT_ImplicitStringLiteral))\n    return false;\n  // We never consider raw string literals \"multiline\" for the purpose of\n  // AlwaysBreakBeforeMultilineStrings implementation as they are special-cased\n  // (see TokenAnnotator::mustBreakBefore().\n  if (Current.TokenText.startswith(\"R\\\"\"))\n    return false;\n  if (Current.IsMultiline)\n    return true;\n  if (Current.getNextNonComment() &&\n      Current.getNextNonComment()->isStringLiteral())\n    return true; // Implicit concatenation.\n  if (Style.ColumnLimit != 0 && Style.BreakStringLiterals &&\n      State.Column + Current.ColumnWidth + Current.UnbreakableTailLength >\n          Style.ColumnLimit)\n    return true; // String will be split.\n  return false;\n}\n\n} // namespace format\n} // namespace clang\n"}, "18": {"id": 18, "path": "/home/vsts/work/1/llvm-project/clang/lib/Format/ContinuationIndenter.h", "content": "//===--- ContinuationIndenter.h - Format C++ code ---------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n///\n/// \\file\n/// This file implements an indenter that manages the indentation of\n/// continuations.\n///\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_CLANG_LIB_FORMAT_CONTINUATIONINDENTER_H\n#define LLVM_CLANG_LIB_FORMAT_CONTINUATIONINDENTER_H\n\n#include \"Encoding.h\"\n#include \"FormatToken.h\"\n#include \"clang/Format/Format.h\"\n#include \"llvm/Support/Regex.h\"\n#include <map>\n#include <tuple>\n\nnamespace clang {\nclass SourceManager;\n\nnamespace format {\n\nclass AnnotatedLine;\nclass BreakableToken;\nstruct FormatToken;\nstruct LineState;\nstruct ParenState;\nstruct RawStringFormatStyleManager;\nclass WhitespaceManager;\n\nstruct RawStringFormatStyleManager {\n  llvm::StringMap<FormatStyle> DelimiterStyle;\n  llvm::StringMap<FormatStyle> EnclosingFunctionStyle;\n\n  RawStringFormatStyleManager(const FormatStyle &CodeStyle);\n\n  llvm::Optional<FormatStyle> getDelimiterStyle(StringRef Delimiter) const;\n\n  llvm::Optional<FormatStyle>\n  getEnclosingFunctionStyle(StringRef EnclosingFunction) const;\n};\n\nclass ContinuationIndenter {\npublic:\n  /// Constructs a \\c ContinuationIndenter to format \\p Line starting in\n  /// column \\p FirstIndent.\n  ContinuationIndenter(const FormatStyle &Style,\n                       const AdditionalKeywords &Keywords,\n                       const SourceManager &SourceMgr,\n                       WhitespaceManager &Whitespaces,\n                       encoding::Encoding Encoding,\n                       bool BinPackInconclusiveFunctions);\n\n  /// Get the initial state, i.e. the state after placing \\p Line's\n  /// first token at \\p FirstIndent. When reformatting a fragment of code, as in\n  /// the case of formatting inside raw string literals, \\p FirstStartColumn is\n  /// the column at which the state of the parent formatter is.\n  LineState getInitialState(unsigned FirstIndent, unsigned FirstStartColumn,\n                            const AnnotatedLine *Line, bool DryRun);\n\n  // FIXME: canBreak and mustBreak aren't strictly indentation-related. Find a\n  // better home.\n  /// Returns \\c true, if a line break after \\p State is allowed.\n  bool canBreak(const LineState &State);\n\n  /// Returns \\c true, if a line break after \\p State is mandatory.\n  bool mustBreak(const LineState &State);\n\n  /// Appends the next token to \\p State and updates information\n  /// necessary for indentation.\n  ///\n  /// Puts the token on the current line if \\p Newline is \\c false and adds a\n  /// line break and necessary indentation otherwise.\n  ///\n  /// If \\p DryRun is \\c false, also creates and stores the required\n  /// \\c Replacement.\n  unsigned addTokenToState(LineState &State, bool Newline, bool DryRun,\n                           unsigned ExtraSpaces = 0);\n\n  /// Get the column limit for this line. This is the style's column\n  /// limit, potentially reduced for preprocessor definitions.\n  unsigned getColumnLimit(const LineState &State) const;\n\nprivate:\n  /// Mark the next token as consumed in \\p State and modify its stacks\n  /// accordingly.\n  unsigned moveStateToNextToken(LineState &State, bool DryRun, bool Newline);\n\n  /// Update 'State' according to the next token's fake left parentheses.\n  void moveStatePastFakeLParens(LineState &State, bool Newline);\n  /// Update 'State' according to the next token's fake r_parens.\n  void moveStatePastFakeRParens(LineState &State);\n\n  /// Update 'State' according to the next token being one of \"(<{[\".\n  void moveStatePastScopeOpener(LineState &State, bool Newline);\n  /// Update 'State' according to the next token being one of \")>}]\".\n  void moveStatePastScopeCloser(LineState &State);\n  /// Update 'State' with the next token opening a nested block.\n  void moveStateToNewBlock(LineState &State);\n\n  /// Reformats a raw string literal.\n  ///\n  /// \\returns An extra penalty induced by reformatting the token.\n  unsigned reformatRawStringLiteral(const FormatToken &Current,\n                                    LineState &State,\n                                    const FormatStyle &RawStringStyle,\n                                    bool DryRun, bool Newline);\n\n  /// If the current token is at the end of the current line, handle\n  /// the transition to the next line.\n  unsigned handleEndOfLine(const FormatToken &Current, LineState &State,\n                           bool DryRun, bool AllowBreak, bool Newline);\n\n  /// If \\p Current is a raw string that is configured to be reformatted,\n  /// return the style to be used.\n  llvm::Optional<FormatStyle> getRawStringStyle(const FormatToken &Current,\n                                                const LineState &State);\n\n  /// If the current token sticks out over the end of the line, break\n  /// it if possible.\n  ///\n  /// \\returns A pair (penalty, exceeded), where penalty is the extra penalty\n  /// when tokens are broken or lines exceed the column limit, and exceeded\n  /// indicates whether the algorithm purposefully left lines exceeding the\n  /// column limit.\n  ///\n  /// The returned penalty will cover the cost of the additional line breaks\n  /// and column limit violation in all lines except for the last one. The\n  /// penalty for the column limit violation in the last line (and in single\n  /// line tokens) is handled in \\c addNextStateToQueue.\n  ///\n  /// \\p Strict indicates whether reflowing is allowed to leave characters\n  /// protruding the column limit; if true, lines will be split strictly within\n  /// the column limit where possible; if false, words are allowed to protrude\n  /// over the column limit as long as the penalty is less than the penalty\n  /// of a break.\n  std::pair<unsigned, bool> breakProtrudingToken(const FormatToken &Current,\n                                                 LineState &State,\n                                                 bool AllowBreak, bool DryRun,\n                                                 bool Strict);\n\n  /// Returns the \\c BreakableToken starting at \\p Current, or nullptr\n  /// if the current token cannot be broken.\n  std::unique_ptr<BreakableToken>\n  createBreakableToken(const FormatToken &Current, LineState &State,\n                       bool AllowBreak);\n\n  /// Appends the next token to \\p State and updates information\n  /// necessary for indentation.\n  ///\n  /// Puts the token on the current line.\n  ///\n  /// If \\p DryRun is \\c false, also creates and stores the required\n  /// \\c Replacement.\n  void addTokenOnCurrentLine(LineState &State, bool DryRun,\n                             unsigned ExtraSpaces);\n\n  /// Appends the next token to \\p State and updates information\n  /// necessary for indentation.\n  ///\n  /// Adds a line break and necessary indentation.\n  ///\n  /// If \\p DryRun is \\c false, also creates and stores the required\n  /// \\c Replacement.\n  unsigned addTokenOnNewLine(LineState &State, bool DryRun);\n\n  /// Calculate the new column for a line wrap before the next token.\n  unsigned getNewLineColumn(const LineState &State);\n\n  /// Adds a multiline token to the \\p State.\n  ///\n  /// \\returns Extra penalty for the first line of the literal: last line is\n  /// handled in \\c addNextStateToQueue, and the penalty for other lines doesn't\n  /// matter, as we don't change them.\n  unsigned addMultilineToken(const FormatToken &Current, LineState &State);\n\n  /// Returns \\c true if the next token starts a multiline string\n  /// literal.\n  ///\n  /// This includes implicitly concatenated strings, strings that will be broken\n  /// by clang-format and string literals with escaped newlines.\n  bool nextIsMultilineString(const LineState &State);\n\n  FormatStyle Style;\n  const AdditionalKeywords &Keywords;\n  const SourceManager &SourceMgr;\n  WhitespaceManager &Whitespaces;\n  encoding::Encoding Encoding;\n  bool BinPackInconclusiveFunctions;\n  llvm::Regex CommentPragmasRegex;\n  const RawStringFormatStyleManager RawStringFormats;\n};\n\nstruct ParenState {\n  ParenState(const FormatToken *Tok, unsigned Indent, unsigned LastSpace,\n             bool AvoidBinPacking, bool NoLineBreak)\n      : Tok(Tok), Indent(Indent), LastSpace(LastSpace),\n        NestedBlockIndent(Indent), IsAligned(false),\n        BreakBeforeClosingBrace(false), AvoidBinPacking(AvoidBinPacking),\n        BreakBeforeParameter(false), NoLineBreak(NoLineBreak),\n        NoLineBreakInOperand(false), LastOperatorWrapped(true),\n        ContainsLineBreak(false), ContainsUnwrappedBuilder(false),\n        AlignColons(true), ObjCSelectorNameFound(false),\n        HasMultipleNestedBlocks(false), NestedBlockInlined(false),\n        IsInsideObjCArrayLiteral(false), IsCSharpGenericTypeConstraint(false),\n        IsChainedConditional(false), IsWrappedConditional(false),\n        UnindentOperator(false) {}\n\n  /// \\brief The token opening this parenthesis level, or nullptr if this level\n  /// is opened by fake parenthesis.\n  ///\n  /// Not considered for memoization as it will always have the same value at\n  /// the same token.\n  const FormatToken *Tok;\n\n  /// The position to which a specific parenthesis level needs to be\n  /// indented.\n  unsigned Indent;\n\n  /// The position of the last space on each level.\n  ///\n  /// Used e.g. to break like:\n  /// functionCall(Parameter, otherCall(\n  ///                             OtherParameter));\n  unsigned LastSpace;\n\n  /// If a block relative to this parenthesis level gets wrapped, indent\n  /// it this much.\n  unsigned NestedBlockIndent;\n\n  /// The position the first \"<<\" operator encountered on each level.\n  ///\n  /// Used to align \"<<\" operators. 0 if no such operator has been encountered\n  /// on a level.\n  unsigned FirstLessLess = 0;\n\n  /// The column of a \\c ? in a conditional expression;\n  unsigned QuestionColumn = 0;\n\n  /// The position of the colon in an ObjC method declaration/call.\n  unsigned ColonPos = 0;\n\n  /// The start of the most recent function in a builder-type call.\n  unsigned StartOfFunctionCall = 0;\n\n  /// Contains the start of array subscript expressions, so that they\n  /// can be aligned.\n  unsigned StartOfArraySubscripts = 0;\n\n  /// If a nested name specifier was broken over multiple lines, this\n  /// contains the start column of the second line. Otherwise 0.\n  unsigned NestedNameSpecifierContinuation = 0;\n\n  /// If a call expression was broken over multiple lines, this\n  /// contains the start column of the second line. Otherwise 0.\n  unsigned CallContinuation = 0;\n\n  /// The column of the first variable name in a variable declaration.\n  ///\n  /// Used to align further variables if necessary.\n  unsigned VariablePos = 0;\n\n  /// Whether this block's indentation is used for alignment.\n  bool IsAligned : 1;\n\n  /// Whether a newline needs to be inserted before the block's closing\n  /// brace.\n  ///\n  /// We only want to insert a newline before the closing brace if there also\n  /// was a newline after the beginning left brace.\n  bool BreakBeforeClosingBrace : 1;\n\n  /// Avoid bin packing, i.e. multiple parameters/elements on multiple\n  /// lines, in this context.\n  bool AvoidBinPacking : 1;\n\n  /// Break after the next comma (or all the commas in this context if\n  /// \\c AvoidBinPacking is \\c true).\n  bool BreakBeforeParameter : 1;\n\n  /// Line breaking in this context would break a formatting rule.\n  bool NoLineBreak : 1;\n\n  /// Same as \\c NoLineBreak, but is restricted until the end of the\n  /// operand (including the next \",\").\n  bool NoLineBreakInOperand : 1;\n\n  /// True if the last binary operator on this level was wrapped to the\n  /// next line.\n  bool LastOperatorWrapped : 1;\n\n  /// \\c true if this \\c ParenState already contains a line-break.\n  ///\n  /// The first line break in a certain \\c ParenState causes extra penalty so\n  /// that clang-format prefers similar breaks, i.e. breaks in the same\n  /// parenthesis.\n  bool ContainsLineBreak : 1;\n\n  /// \\c true if this \\c ParenState contains multiple segments of a\n  /// builder-type call on one line.\n  bool ContainsUnwrappedBuilder : 1;\n\n  /// \\c true if the colons of the curren ObjC method expression should\n  /// be aligned.\n  ///\n  /// Not considered for memoization as it will always have the same value at\n  /// the same token.\n  bool AlignColons : 1;\n\n  /// \\c true if at least one selector name was found in the current\n  /// ObjC method expression.\n  ///\n  /// Not considered for memoization as it will always have the same value at\n  /// the same token.\n  bool ObjCSelectorNameFound : 1;\n\n  /// \\c true if there are multiple nested blocks inside these parens.\n  ///\n  /// Not considered for memoization as it will always have the same value at\n  /// the same token.\n  bool HasMultipleNestedBlocks : 1;\n\n  /// The start of a nested block (e.g. lambda introducer in C++ or\n  /// \"function\" in JavaScript) is not wrapped to a new line.\n  bool NestedBlockInlined : 1;\n\n  /// \\c true if the current \\c ParenState represents an Objective-C\n  /// array literal.\n  bool IsInsideObjCArrayLiteral : 1;\n\n  bool IsCSharpGenericTypeConstraint : 1;\n\n  /// \\brief true if the current \\c ParenState represents the false branch of\n  /// a chained conditional expression (e.g. else-if)\n  bool IsChainedConditional : 1;\n\n  /// \\brief true if there conditionnal was wrapped on the first operator (the\n  /// question mark)\n  bool IsWrappedConditional : 1;\n\n  /// \\brief Indicates the indent should be reduced by the length of the\n  /// operator.\n  bool UnindentOperator : 1;\n\n  bool operator<(const ParenState &Other) const {\n    if (Indent != Other.Indent)\n      return Indent < Other.Indent;\n    if (LastSpace != Other.LastSpace)\n      return LastSpace < Other.LastSpace;\n    if (NestedBlockIndent != Other.NestedBlockIndent)\n      return NestedBlockIndent < Other.NestedBlockIndent;\n    if (FirstLessLess != Other.FirstLessLess)\n      return FirstLessLess < Other.FirstLessLess;\n    if (IsAligned != Other.IsAligned)\n      return IsAligned;\n    if (BreakBeforeClosingBrace != Other.BreakBeforeClosingBrace)\n      return BreakBeforeClosingBrace;\n    if (QuestionColumn != Other.QuestionColumn)\n      return QuestionColumn < Other.QuestionColumn;\n    if (AvoidBinPacking != Other.AvoidBinPacking)\n      return AvoidBinPacking;\n    if (BreakBeforeParameter != Other.BreakBeforeParameter)\n      return BreakBeforeParameter;\n    if (NoLineBreak != Other.NoLineBreak)\n      return NoLineBreak;\n    if (LastOperatorWrapped != Other.LastOperatorWrapped)\n      return LastOperatorWrapped;\n    if (ColonPos != Other.ColonPos)\n      return ColonPos < Other.ColonPos;\n    if (StartOfFunctionCall != Other.StartOfFunctionCall)\n      return StartOfFunctionCall < Other.StartOfFunctionCall;\n    if (StartOfArraySubscripts != Other.StartOfArraySubscripts)\n      return StartOfArraySubscripts < Other.StartOfArraySubscripts;\n    if (CallContinuation != Other.CallContinuation)\n      return CallContinuation < Other.CallContinuation;\n    if (VariablePos != Other.VariablePos)\n      return VariablePos < Other.VariablePos;\n    if (ContainsLineBreak != Other.ContainsLineBreak)\n      return ContainsLineBreak;\n    if (ContainsUnwrappedBuilder != Other.ContainsUnwrappedBuilder)\n      return ContainsUnwrappedBuilder;\n    if (NestedBlockInlined != Other.NestedBlockInlined)\n      return NestedBlockInlined;\n    if (IsCSharpGenericTypeConstraint != Other.IsCSharpGenericTypeConstraint)\n      return IsCSharpGenericTypeConstraint;\n    if (IsChainedConditional != Other.IsChainedConditional)\n      return IsChainedConditional;\n    if (IsWrappedConditional != Other.IsWrappedConditional)\n      return IsWrappedConditional;\n    if (UnindentOperator != Other.UnindentOperator)\n      return UnindentOperator;\n    return false;\n  }\n};\n\n/// The current state when indenting a unwrapped line.\n///\n/// As the indenting tries different combinations this is copied by value.\nstruct LineState {\n  /// The number of used columns in the current line.\n  unsigned Column;\n\n  /// The token that needs to be next formatted.\n  FormatToken *NextToken;\n\n  /// \\c true if this line contains a continued for-loop section.\n  bool LineContainsContinuedForLoopSection;\n\n  /// \\c true if \\p NextToken should not continue this line.\n  bool NoContinuation;\n\n  /// The \\c NestingLevel at the start of this line.\n  unsigned StartOfLineLevel;\n\n  /// The lowest \\c NestingLevel on the current line.\n  unsigned LowestLevelOnLine;\n\n  /// The start column of the string literal, if we're in a string\n  /// literal sequence, 0 otherwise.\n  unsigned StartOfStringLiteral;\n\n  /// A stack keeping track of properties applying to parenthesis\n  /// levels.\n  std::vector<ParenState> Stack;\n\n  /// Ignore the stack of \\c ParenStates for state comparison.\n  ///\n  /// In long and deeply nested unwrapped lines, the current algorithm can\n  /// be insufficient for finding the best formatting with a reasonable amount\n  /// of time and memory. Setting this flag will effectively lead to the\n  /// algorithm not analyzing some combinations. However, these combinations\n  /// rarely contain the optimal solution: In short, accepting a higher\n  /// penalty early would need to lead to different values in the \\c\n  /// ParenState stack (in an otherwise identical state) and these different\n  /// values would need to lead to a significant amount of avoided penalty\n  /// later.\n  ///\n  /// FIXME: Come up with a better algorithm instead.\n  bool IgnoreStackForComparison;\n\n  /// The indent of the first token.\n  unsigned FirstIndent;\n\n  /// The line that is being formatted.\n  ///\n  /// Does not need to be considered for memoization because it doesn't change.\n  const AnnotatedLine *Line;\n\n  /// Comparison operator to be able to used \\c LineState in \\c map.\n  bool operator<(const LineState &Other) const {\n    if (NextToken != Other.NextToken)\n      return NextToken < Other.NextToken;\n    if (Column != Other.Column)\n      return Column < Other.Column;\n    if (LineContainsContinuedForLoopSection !=\n        Other.LineContainsContinuedForLoopSection)\n      return LineContainsContinuedForLoopSection;\n    if (NoContinuation != Other.NoContinuation)\n      return NoContinuation;\n    if (StartOfLineLevel != Other.StartOfLineLevel)\n      return StartOfLineLevel < Other.StartOfLineLevel;\n    if (LowestLevelOnLine != Other.LowestLevelOnLine)\n      return LowestLevelOnLine < Other.LowestLevelOnLine;\n    if (StartOfStringLiteral != Other.StartOfStringLiteral)\n      return StartOfStringLiteral < Other.StartOfStringLiteral;\n    if (IgnoreStackForComparison || Other.IgnoreStackForComparison)\n      return false;\n    return Stack < Other.Stack;\n  }\n};\n\n} // end namespace format\n} // end namespace clang\n\n#endif\n"}, "19": {"id": 19, "path": "/home/vsts/work/1/llvm-project/clang/lib/Format/FormatToken.h", "content": "//===--- FormatToken.h - Format C++ code ------------------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n///\n/// \\file\n/// This file contains the declaration of the FormatToken, a wrapper\n/// around Token with additional information related to formatting.\n///\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_CLANG_LIB_FORMAT_FORMATTOKEN_H\n#define LLVM_CLANG_LIB_FORMAT_FORMATTOKEN_H\n\n#include \"clang/Basic/IdentifierTable.h\"\n#include \"clang/Basic/OperatorPrecedence.h\"\n#include \"clang/Format/Format.h\"\n#include \"clang/Lex/Lexer.h\"\n#include <memory>\n#include <unordered_set>\n\nnamespace clang {\nnamespace format {\n\n#define LIST_TOKEN_TYPES                                                       \\\n  TYPE(ArrayInitializerLSquare)                                                \\\n  TYPE(ArraySubscriptLSquare)                                                  \\\n  TYPE(AttributeColon)                                                         \\\n  TYPE(AttributeMacro)                                                         \\\n  TYPE(AttributeParen)                                                         \\\n  TYPE(AttributeSquare)                                                        \\\n  TYPE(BinaryOperator)                                                         \\\n  TYPE(BitFieldColon)                                                          \\\n  TYPE(BlockComment)                                                           \\\n  TYPE(CastRParen)                                                             \\\n  TYPE(ConditionalExpr)                                                        \\\n  TYPE(ConflictAlternative)                                                    \\\n  TYPE(ConflictEnd)                                                            \\\n  TYPE(ConflictStart)                                                          \\\n  TYPE(ConstraintJunctions)                                                    \\\n  TYPE(CtorInitializerColon)                                                   \\\n  TYPE(CtorInitializerComma)                                                   \\\n  TYPE(DesignatedInitializerLSquare)                                           \\\n  TYPE(DesignatedInitializerPeriod)                                            \\\n  TYPE(DictLiteral)                                                            \\\n  TYPE(ForEachMacro)                                                           \\\n  TYPE(FunctionAnnotationRParen)                                               \\\n  TYPE(FunctionDeclarationName)                                                \\\n  TYPE(FunctionLBrace)                                                         \\\n  TYPE(FunctionTypeLParen)                                                     \\\n  TYPE(ImplicitStringLiteral)                                                  \\\n  TYPE(InheritanceColon)                                                       \\\n  TYPE(InheritanceComma)                                                       \\\n  TYPE(InlineASMBrace)                                                         \\\n  TYPE(InlineASMColon)                                                         \\\n  TYPE(InlineASMSymbolicNameLSquare)                                           \\\n  TYPE(JavaAnnotation)                                                         \\\n  TYPE(JsComputedPropertyName)                                                 \\\n  TYPE(JsExponentiation)                                                       \\\n  TYPE(JsExponentiationEqual)                                                  \\\n  TYPE(JsFatArrow)                                                             \\\n  TYPE(JsNonNullAssertion)                                                     \\\n  TYPE(JsNullishCoalescingOperator)                                            \\\n  TYPE(JsNullPropagatingOperator)                                              \\\n  TYPE(JsPrivateIdentifier)                                                    \\\n  TYPE(JsTypeColon)                                                            \\\n  TYPE(JsTypeOperator)                                                         \\\n  TYPE(JsTypeOptionalQuestion)                                                 \\\n  TYPE(JsAndAndEqual)                                                          \\\n  TYPE(JsPipePipeEqual)                                                        \\\n  TYPE(JsNullishCoalescingEqual)                                               \\\n  TYPE(LambdaArrow)                                                            \\\n  TYPE(LambdaLBrace)                                                           \\\n  TYPE(LambdaLSquare)                                                          \\\n  TYPE(LeadingJavaAnnotation)                                                  \\\n  TYPE(LineComment)                                                            \\\n  TYPE(MacroBlockBegin)                                                        \\\n  TYPE(MacroBlockEnd)                                                          \\\n  TYPE(NamespaceMacro)                                                         \\\n  TYPE(ObjCBlockLBrace)                                                        \\\n  TYPE(ObjCBlockLParen)                                                        \\\n  TYPE(ObjCDecl)                                                               \\\n  TYPE(ObjCForIn)                                                              \\\n  TYPE(ObjCMethodExpr)                                                         \\\n  TYPE(ObjCMethodSpecifier)                                                    \\\n  TYPE(ObjCProperty)                                                           \\\n  TYPE(ObjCStringLiteral)                                                      \\\n  TYPE(OverloadedOperator)                                                     \\\n  TYPE(OverloadedOperatorLParen)                                               \\\n  TYPE(PointerOrReference)                                                     \\\n  TYPE(PureVirtualSpecifier)                                                   \\\n  TYPE(RangeBasedForLoopColon)                                                 \\\n  TYPE(RegexLiteral)                                                           \\\n  TYPE(SelectorName)                                                           \\\n  TYPE(StartOfName)                                                            \\\n  TYPE(StatementAttributeLikeMacro)                                            \\\n  TYPE(StatementMacro)                                                         \\\n  TYPE(StructuredBindingLSquare)                                               \\\n  TYPE(TemplateCloser)                                                         \\\n  TYPE(TemplateOpener)                                                         \\\n  TYPE(TemplateString)                                                         \\\n  TYPE(ProtoExtensionLSquare)                                                  \\\n  TYPE(TrailingAnnotation)                                                     \\\n  TYPE(TrailingReturnArrow)                                                    \\\n  TYPE(TrailingUnaryOperator)                                                  \\\n  TYPE(TypeDeclarationParen)                                                   \\\n  TYPE(TypenameMacro)                                                          \\\n  TYPE(UnaryOperator)                                                          \\\n  TYPE(UntouchableMacroFunc)                                                   \\\n  TYPE(CSharpStringLiteral)                                                    \\\n  TYPE(CSharpNamedArgumentColon)                                               \\\n  TYPE(CSharpNullable)                                                         \\\n  TYPE(CSharpNullCoalescing)                                                   \\\n  TYPE(CSharpNullConditional)                                                  \\\n  TYPE(CSharpNullConditionalLSquare)                                           \\\n  TYPE(CSharpGenericTypeConstraint)                                            \\\n  TYPE(CSharpGenericTypeConstraintColon)                                       \\\n  TYPE(CSharpGenericTypeConstraintComma)                                       \\\n  TYPE(Unknown)\n\n/// Determines the semantic type of a syntactic token, e.g. whether \"<\" is a\n/// template opener or binary operator.\nenum TokenType : uint8_t {\n#define TYPE(X) TT_##X,\n  LIST_TOKEN_TYPES\n#undef TYPE\n      NUM_TOKEN_TYPES\n};\n\n/// Determines the name of a token type.\nconst char *getTokenTypeName(TokenType Type);\n\n// Represents what type of block a set of braces open.\nenum BraceBlockKind { BK_Unknown, BK_Block, BK_BracedInit };\n\n// The packing kind of a function's parameters.\nenum ParameterPackingKind { PPK_BinPacked, PPK_OnePerLine, PPK_Inconclusive };\n\nenum FormatDecision { FD_Unformatted, FD_Continue, FD_Break };\n\n/// Roles a token can take in a configured macro expansion.\nenum MacroRole {\n  /// The token was expanded from a macro argument when formatting the expanded\n  /// token sequence.\n  MR_ExpandedArg,\n  /// The token is part of a macro argument that was previously formatted as\n  /// expansion when formatting the unexpanded macro call.\n  MR_UnexpandedArg,\n  /// The token was expanded from a macro definition, and is not visible as part\n  /// of the macro call.\n  MR_Hidden,\n};\n\nstruct FormatToken;\n\n/// Contains information on the token's role in a macro expansion.\n///\n/// Given the following definitions:\n/// A(X) = [ X ]\n/// B(X) = < X >\n/// C(X) = X\n///\n/// Consider the macro call:\n/// A({B(C(C(x)))}) -> [{<x>}]\n///\n/// In this case, the tokens of the unexpanded macro call will have the\n/// following relevant entries in their macro context (note that formatting\n/// the unexpanded macro call happens *after* formatting the expanded macro\n/// call):\n///                   A( { B( C( C(x) ) ) } )\n/// Role:             NN U NN NN NNUN N N U N  (N=None, U=UnexpandedArg)\n///\n///                   [  { <       x    > } ]\n/// Role:             H  E H       E    H E H  (H=Hidden, E=ExpandedArg)\n/// ExpandedFrom[0]:  A  A A       A    A A A\n/// ExpandedFrom[1]:       B       B    B\n/// ExpandedFrom[2]:               C\n/// ExpandedFrom[3]:               C\n/// StartOfExpansion: 1  0 1       2    0 0 0\n/// EndOfExpansion:   0  0 0       2    1 0 1\nstruct MacroExpansion {\n  MacroExpansion(MacroRole Role) : Role(Role) {}\n\n  /// The token's role in the macro expansion.\n  /// When formatting an expanded macro, all tokens that are part of macro\n  /// arguments will be MR_ExpandedArg, while all tokens that are not visible in\n  /// the macro call will be MR_Hidden.\n  /// When formatting an unexpanded macro call, all tokens that are part of\n  /// macro arguments will be MR_UnexpandedArg.\n  MacroRole Role;\n\n  /// The stack of macro call identifier tokens this token was expanded from.\n  llvm::SmallVector<FormatToken *, 1> ExpandedFrom;\n\n  /// The number of expansions of which this macro is the first entry.\n  unsigned StartOfExpansion = 0;\n\n  /// The number of currently open expansions in \\c ExpandedFrom this macro is\n  /// the last token in.\n  unsigned EndOfExpansion = 0;\n};\n\nclass TokenRole;\nclass AnnotatedLine;\n\n/// A wrapper around a \\c Token storing information about the\n/// whitespace characters preceding it.\nstruct FormatToken {\n  FormatToken()\n      : HasUnescapedNewline(false), IsMultiline(false), IsFirst(false),\n        MustBreakBefore(false), IsUnterminatedLiteral(false),\n        CanBreakBefore(false), ClosesTemplateDeclaration(false),\n        StartsBinaryExpression(false), EndsBinaryExpression(false),\n        PartOfMultiVariableDeclStmt(false), ContinuesLineCommentSection(false),\n        Finalized(false), BlockKind(BK_Unknown), Decision(FD_Unformatted),\n        PackingKind(PPK_Inconclusive), Type(TT_Unknown) {}\n\n  /// The \\c Token.\n  Token Tok;\n\n  /// The raw text of the token.\n  ///\n  /// Contains the raw token text without leading whitespace and without leading\n  /// escaped newlines.\n  StringRef TokenText;\n\n  /// A token can have a special role that can carry extra information\n  /// about the token's formatting.\n  /// FIXME: Make FormatToken for parsing and AnnotatedToken two different\n  /// classes and make this a unique_ptr in the AnnotatedToken class.\n  std::shared_ptr<TokenRole> Role;\n\n  /// The range of the whitespace immediately preceding the \\c Token.\n  SourceRange WhitespaceRange;\n\n  /// Whether there is at least one unescaped newline before the \\c\n  /// Token.\n  unsigned HasUnescapedNewline : 1;\n\n  /// Whether the token text contains newlines (escaped or not).\n  unsigned IsMultiline : 1;\n\n  /// Indicates that this is the first token of the file.\n  unsigned IsFirst : 1;\n\n  /// Whether there must be a line break before this token.\n  ///\n  /// This happens for example when a preprocessor directive ended directly\n  /// before the token.\n  unsigned MustBreakBefore : 1;\n\n  /// Set to \\c true if this token is an unterminated literal.\n  unsigned IsUnterminatedLiteral : 1;\n\n  /// \\c true if it is allowed to break before this token.\n  unsigned CanBreakBefore : 1;\n\n  /// \\c true if this is the \">\" of \"template<..>\".\n  unsigned ClosesTemplateDeclaration : 1;\n\n  /// \\c true if this token starts a binary expression, i.e. has at least\n  /// one fake l_paren with a precedence greater than prec::Unknown.\n  unsigned StartsBinaryExpression : 1;\n  /// \\c true if this token ends a binary expression.\n  unsigned EndsBinaryExpression : 1;\n\n  /// Is this token part of a \\c DeclStmt defining multiple variables?\n  ///\n  /// Only set if \\c Type == \\c TT_StartOfName.\n  unsigned PartOfMultiVariableDeclStmt : 1;\n\n  /// Does this line comment continue a line comment section?\n  ///\n  /// Only set to true if \\c Type == \\c TT_LineComment.\n  unsigned ContinuesLineCommentSection : 1;\n\n  /// If \\c true, this token has been fully formatted (indented and\n  /// potentially re-formatted inside), and we do not allow further formatting\n  /// changes.\n  unsigned Finalized : 1;\n\nprivate:\n  /// Contains the kind of block if this token is a brace.\n  unsigned BlockKind : 2;\n\npublic:\n  BraceBlockKind getBlockKind() const {\n    return static_cast<BraceBlockKind>(BlockKind);\n  }\n  void setBlockKind(BraceBlockKind BBK) {\n    BlockKind = BBK;\n    assert(getBlockKind() == BBK && \"BraceBlockKind overflow!\");\n  }\n\nprivate:\n  /// Stores the formatting decision for the token once it was made.\n  unsigned Decision : 2;\n\npublic:\n  FormatDecision getDecision() const {\n    return static_cast<FormatDecision>(Decision);\n  }\n  void setDecision(FormatDecision D) {\n    Decision = D;\n    assert(getDecision() == D && \"FormatDecision overflow!\");\n  }\n\nprivate:\n  /// If this is an opening parenthesis, how are the parameters packed?\n  unsigned PackingKind : 2;\n\npublic:\n  ParameterPackingKind getPackingKind() const {\n    return static_cast<ParameterPackingKind>(PackingKind);\n  }\n  void setPackingKind(ParameterPackingKind K) {\n    PackingKind = K;\n    assert(getPackingKind() == K && \"ParameterPackingKind overflow!\");\n  }\n\nprivate:\n  TokenType Type;\n\npublic:\n  /// Returns the token's type, e.g. whether \"<\" is a template opener or\n  /// binary operator.\n  TokenType getType() const { return Type; }\n  void setType(TokenType T) { Type = T; }\n\n  /// The number of newlines immediately before the \\c Token.\n  ///\n  /// This can be used to determine what the user wrote in the original code\n  /// and thereby e.g. leave an empty line between two function definitions.\n  unsigned NewlinesBefore = 0;\n\n  /// The offset just past the last '\\n' in this token's leading\n  /// whitespace (relative to \\c WhiteSpaceStart). 0 if there is no '\\n'.\n  unsigned LastNewlineOffset = 0;\n\n  /// The width of the non-whitespace parts of the token (or its first\n  /// line for multi-line tokens) in columns.\n  /// We need this to correctly measure number of columns a token spans.\n  unsigned ColumnWidth = 0;\n\n  /// Contains the width in columns of the last line of a multi-line\n  /// token.\n  unsigned LastLineColumnWidth = 0;\n\n  /// The number of spaces that should be inserted before this token.\n  unsigned SpacesRequiredBefore = 0;\n\n  /// Number of parameters, if this is \"(\", \"[\" or \"<\".\n  unsigned ParameterCount = 0;\n\n  /// Number of parameters that are nested blocks,\n  /// if this is \"(\", \"[\" or \"<\".\n  unsigned BlockParameterCount = 0;\n\n  /// If this is a bracket (\"<\", \"(\", \"[\" or \"{\"), contains the kind of\n  /// the surrounding bracket.\n  tok::TokenKind ParentBracket = tok::unknown;\n\n  /// The total length of the unwrapped line up to and including this\n  /// token.\n  unsigned TotalLength = 0;\n\n  /// The original 0-based column of this token, including expanded tabs.\n  /// The configured TabWidth is used as tab width.\n  unsigned OriginalColumn = 0;\n\n  /// The length of following tokens until the next natural split point,\n  /// or the next token that can be broken.\n  unsigned UnbreakableTailLength = 0;\n\n  // FIXME: Come up with a 'cleaner' concept.\n  /// The binding strength of a token. This is a combined value of\n  /// operator precedence, parenthesis nesting, etc.\n  unsigned BindingStrength = 0;\n\n  /// The nesting level of this token, i.e. the number of surrounding (),\n  /// [], {} or <>.\n  unsigned NestingLevel = 0;\n\n  /// The indent level of this token. Copied from the surrounding line.\n  unsigned IndentLevel = 0;\n\n  /// Penalty for inserting a line break before this token.\n  unsigned SplitPenalty = 0;\n\n  /// If this is the first ObjC selector name in an ObjC method\n  /// definition or call, this contains the length of the longest name.\n  ///\n  /// This being set to 0 means that the selectors should not be colon-aligned,\n  /// e.g. because several of them are block-type.\n  unsigned LongestObjCSelectorName = 0;\n\n  /// If this is the first ObjC selector name in an ObjC method\n  /// definition or call, this contains the number of parts that the whole\n  /// selector consist of.\n  unsigned ObjCSelectorNameParts = 0;\n\n  /// The 0-based index of the parameter/argument. For ObjC it is set\n  /// for the selector name token.\n  /// For now calculated only for ObjC.\n  unsigned ParameterIndex = 0;\n\n  /// Stores the number of required fake parentheses and the\n  /// corresponding operator precedence.\n  ///\n  /// If multiple fake parentheses start at a token, this vector stores them in\n  /// reverse order, i.e. inner fake parenthesis first.\n  SmallVector<prec::Level, 4> FakeLParens;\n  /// Insert this many fake ) after this token for correct indentation.\n  unsigned FakeRParens = 0;\n\n  /// If this is an operator (or \".\"/\"->\") in a sequence of operators\n  /// with the same precedence, contains the 0-based operator index.\n  unsigned OperatorIndex = 0;\n\n  /// If this is an operator (or \".\"/\"->\") in a sequence of operators\n  /// with the same precedence, points to the next operator.\n  FormatToken *NextOperator = nullptr;\n\n  /// If this is a bracket, this points to the matching one.\n  FormatToken *MatchingParen = nullptr;\n\n  /// The previous token in the unwrapped line.\n  FormatToken *Previous = nullptr;\n\n  /// The next token in the unwrapped line.\n  FormatToken *Next = nullptr;\n\n  /// If this token starts a block, this contains all the unwrapped lines\n  /// in it.\n  SmallVector<AnnotatedLine *, 1> Children;\n\n  // Contains all attributes related to how this token takes part\n  // in a configured macro expansion.\n  llvm::Optional<MacroExpansion> MacroCtx;\n\n  bool is(tok::TokenKind Kind) const { return Tok.is(Kind); }\n  bool is(TokenType TT) const { return getType() == TT; }\n  bool is(const IdentifierInfo *II) const {\n    return II && II == Tok.getIdentifierInfo();\n  }\n  bool is(tok::PPKeywordKind Kind) const {\n    return Tok.getIdentifierInfo() &&\n           Tok.getIdentifierInfo()->getPPKeywordID() == Kind;\n  }\n  bool is(BraceBlockKind BBK) const { return getBlockKind() == BBK; }\n  bool is(ParameterPackingKind PPK) const { return getPackingKind() == PPK; }\n\n  template <typename A, typename B> bool isOneOf(A K1, B K2) const {\n    return is(K1) || is(K2);\n  }\n  template <typename A, typename B, typename... Ts>\n  bool isOneOf(A K1, B K2, Ts... Ks) const {\n    return is(K1) || isOneOf(K2, Ks...);\n  }\n  template <typename T> bool isNot(T Kind) const { return !is(Kind); }\n\n  bool isIf(bool AllowConstexprMacro = true) const {\n    return is(tok::kw_if) || endsSequence(tok::kw_constexpr, tok::kw_if) ||\n           (endsSequence(tok::identifier, tok::kw_if) && AllowConstexprMacro);\n  }\n\n  bool closesScopeAfterBlock() const {\n    if (getBlockKind() == BK_Block)\n      return true;\n    if (closesScope())\n      return Previous->closesScopeAfterBlock();\n    return false;\n  }\n\n  /// \\c true if this token starts a sequence with the given tokens in order,\n  /// following the ``Next`` pointers, ignoring comments.\n  template <typename A, typename... Ts>\n  bool startsSequence(A K1, Ts... Tokens) const {\n    return startsSequenceInternal(K1, Tokens...);\n  }\n\n  /// \\c true if this token ends a sequence with the given tokens in order,\n  /// following the ``Previous`` pointers, ignoring comments.\n  /// For example, given tokens [T1, T2, T3], the function returns true if\n  /// 3 tokens ending at this (ignoring comments) are [T3, T2, T1]. In other\n  /// words, the tokens passed to this function need to the reverse of the\n  /// order the tokens appear in code.\n  template <typename A, typename... Ts>\n  bool endsSequence(A K1, Ts... Tokens) const {\n    return endsSequenceInternal(K1, Tokens...);\n  }\n\n  bool isStringLiteral() const { return tok::isStringLiteral(Tok.getKind()); }\n\n  bool isObjCAtKeyword(tok::ObjCKeywordKind Kind) const {\n    return Tok.isObjCAtKeyword(Kind);\n  }\n\n  bool isAccessSpecifier(bool ColonRequired = true) const {\n    return isOneOf(tok::kw_public, tok::kw_protected, tok::kw_private) &&\n           (!ColonRequired || (Next && Next->is(tok::colon)));\n  }\n\n  bool canBePointerOrReferenceQualifier() const {\n    return isOneOf(tok::kw_const, tok::kw_restrict, tok::kw_volatile,\n                   tok::kw___attribute, tok::kw__Nonnull, tok::kw__Nullable,\n                   tok::kw__Null_unspecified, tok::kw___ptr32, tok::kw___ptr64,\n                   TT_AttributeMacro);\n  }\n\n  /// Determine whether the token is a simple-type-specifier.\n  bool isSimpleTypeSpecifier() const;\n\n  bool isObjCAccessSpecifier() const {\n    return is(tok::at) && Next &&\n           (Next->isObjCAtKeyword(tok::objc_public) ||\n            Next->isObjCAtKeyword(tok::objc_protected) ||\n            Next->isObjCAtKeyword(tok::objc_package) ||\n            Next->isObjCAtKeyword(tok::objc_private));\n  }\n\n  /// Returns whether \\p Tok is ([{ or an opening < of a template or in\n  /// protos.\n  bool opensScope() const {\n    if (is(TT_TemplateString) && TokenText.endswith(\"${\"))\n      return true;\n    if (is(TT_DictLiteral) && is(tok::less))\n      return true;\n    return isOneOf(tok::l_paren, tok::l_brace, tok::l_square,\n                   TT_TemplateOpener);\n  }\n  /// Returns whether \\p Tok is )]} or a closing > of a template or in\n  /// protos.\n  bool closesScope() const {\n    if (is(TT_TemplateString) && TokenText.startswith(\"}\"))\n      return true;\n    if (is(TT_DictLiteral) && is(tok::greater))\n      return true;\n    return isOneOf(tok::r_paren, tok::r_brace, tok::r_square,\n                   TT_TemplateCloser);\n  }\n\n  /// Returns \\c true if this is a \".\" or \"->\" accessing a member.\n  bool isMemberAccess() const {\n    return isOneOf(tok::arrow, tok::period, tok::arrowstar) &&\n           !isOneOf(TT_DesignatedInitializerPeriod, TT_TrailingReturnArrow,\n                    TT_LambdaArrow, TT_LeadingJavaAnnotation);\n  }\n\n  bool isUnaryOperator() const {\n    switch (Tok.getKind()) {\n    case tok::plus:\n    case tok::plusplus:\n    case tok::minus:\n    case tok::minusminus:\n    case tok::exclaim:\n    case tok::tilde:\n    case tok::kw_sizeof:\n    case tok::kw_alignof:\n      return true;\n    default:\n      return false;\n    }\n  }\n\n  bool isBinaryOperator() const {\n    // Comma is a binary operator, but does not behave as such wrt. formatting.\n    return getPrecedence() > prec::Comma;\n  }\n\n  bool isTrailingComment() const {\n    return is(tok::comment) &&\n           (is(TT_LineComment) || !Next || Next->NewlinesBefore > 0);\n  }\n\n  /// Returns \\c true if this is a keyword that can be used\n  /// like a function call (e.g. sizeof, typeid, ...).\n  bool isFunctionLikeKeyword() const {\n    switch (Tok.getKind()) {\n    case tok::kw_throw:\n    case tok::kw_typeid:\n    case tok::kw_return:\n    case tok::kw_sizeof:\n    case tok::kw_alignof:\n    case tok::kw_alignas:\n    case tok::kw_decltype:\n    case tok::kw_noexcept:\n    case tok::kw_static_assert:\n    case tok::kw__Atomic:\n    case tok::kw___attribute:\n    case tok::kw___underlying_type:\n    case tok::kw_requires:\n      return true;\n    default:\n      return false;\n    }\n  }\n\n  /// Returns \\c true if this is a string literal that's like a label,\n  /// e.g. ends with \"=\" or \":\".\n  bool isLabelString() const {\n    if (!is(tok::string_literal))\n      return false;\n    StringRef Content = TokenText;\n    if (Content.startswith(\"\\\"\") || Content.startswith(\"'\"))\n      Content = Content.drop_front(1);\n    if (Content.endswith(\"\\\"\") || Content.endswith(\"'\"))\n      Content = Content.drop_back(1);\n    Content = Content.trim();\n    return Content.size() > 1 &&\n           (Content.back() == ':' || Content.back() == '=');\n  }\n\n  /// Returns actual token start location without leading escaped\n  /// newlines and whitespace.\n  ///\n  /// This can be different to Tok.getLocation(), which includes leading escaped\n  /// newlines.\n  SourceLocation getStartOfNonWhitespace() const {\n    return WhitespaceRange.getEnd();\n  }\n\n  prec::Level getPrecedence() const {\n    return getBinOpPrecedence(Tok.getKind(), /*GreaterThanIsOperator=*/true,\n                              /*CPlusPlus11=*/true);\n  }\n\n  /// Returns the previous token ignoring comments.\n  FormatToken *getPreviousNonComment() const {\n    FormatToken *Tok = Previous;\n    while (Tok && Tok->is(tok::comment))\n      Tok = Tok->Previous;\n    return Tok;\n  }\n\n  /// Returns the next token ignoring comments.\n  const FormatToken *getNextNonComment() const {\n    const FormatToken *Tok = Next;\n    while (Tok && Tok->is(tok::comment))\n      Tok = Tok->Next;\n    return Tok;\n  }\n\n  /// Returns \\c true if this tokens starts a block-type list, i.e. a\n  /// list that should be indented with a block indent.\n  bool opensBlockOrBlockTypeList(const FormatStyle &Style) const {\n    // C# Does not indent object initialisers as continuations.\n    if (is(tok::l_brace) && getBlockKind() == BK_BracedInit && Style.isCSharp())\n      return true;\n    if (is(TT_TemplateString) && opensScope())\n      return true;\n    return is(TT_ArrayInitializerLSquare) || is(TT_ProtoExtensionLSquare) ||\n           (is(tok::l_brace) &&\n            (getBlockKind() == BK_Block || is(TT_DictLiteral) ||\n             (!Style.Cpp11BracedListStyle && NestingLevel == 0))) ||\n           (is(tok::less) && (Style.Language == FormatStyle::LK_Proto ||\n                              Style.Language == FormatStyle::LK_TextProto));\n  }\n\n  /// Returns whether the token is the left square bracket of a C++\n  /// structured binding declaration.\n  bool isCppStructuredBinding(const FormatStyle &Style) const {\n    if (!Style.isCpp() || isNot(tok::l_square))\n      return false;\n    const FormatToken *T = this;\n    do {\n      T = T->getPreviousNonComment();\n    } while (T && T->isOneOf(tok::kw_const, tok::kw_volatile, tok::amp,\n                             tok::ampamp));\n    return T && T->is(tok::kw_auto);\n  }\n\n  /// Same as opensBlockOrBlockTypeList, but for the closing token.\n  bool closesBlockOrBlockTypeList(const FormatStyle &Style) const {\n    if (is(TT_TemplateString) && closesScope())\n      return true;\n    return MatchingParen && MatchingParen->opensBlockOrBlockTypeList(Style);\n  }\n\n  /// Return the actual namespace token, if this token starts a namespace\n  /// block.\n  const FormatToken *getNamespaceToken() const {\n    const FormatToken *NamespaceTok = this;\n    if (is(tok::comment))\n      NamespaceTok = NamespaceTok->getNextNonComment();\n    // Detect \"(inline|export)? namespace\" in the beginning of a line.\n    if (NamespaceTok && NamespaceTok->isOneOf(tok::kw_inline, tok::kw_export))\n      NamespaceTok = NamespaceTok->getNextNonComment();\n    return NamespaceTok &&\n                   NamespaceTok->isOneOf(tok::kw_namespace, TT_NamespaceMacro)\n               ? NamespaceTok\n               : nullptr;\n  }\n\n  void copyFrom(const FormatToken &Tok) { *this = Tok; }\n\nprivate:\n  // Only allow copying via the explicit copyFrom method.\n  FormatToken(const FormatToken &) = delete;\n  FormatToken &operator=(const FormatToken &) = default;\n\n  template <typename A, typename... Ts>\n  bool startsSequenceInternal(A K1, Ts... Tokens) const {\n    if (is(tok::comment) && Next)\n      return Next->startsSequenceInternal(K1, Tokens...);\n    return is(K1) && Next && Next->startsSequenceInternal(Tokens...);\n  }\n\n  template <typename A> bool startsSequenceInternal(A K1) const {\n    if (is(tok::comment) && Next)\n      return Next->startsSequenceInternal(K1);\n    return is(K1);\n  }\n\n  template <typename A, typename... Ts> bool endsSequenceInternal(A K1) const {\n    if (is(tok::comment) && Previous)\n      return Previous->endsSequenceInternal(K1);\n    return is(K1);\n  }\n\n  template <typename A, typename... Ts>\n  bool endsSequenceInternal(A K1, Ts... Tokens) const {\n    if (is(tok::comment) && Previous)\n      return Previous->endsSequenceInternal(K1, Tokens...);\n    return is(K1) && Previous && Previous->endsSequenceInternal(Tokens...);\n  }\n};\n\nclass ContinuationIndenter;\nstruct LineState;\n\nclass TokenRole {\npublic:\n  TokenRole(const FormatStyle &Style) : Style(Style) {}\n  virtual ~TokenRole();\n\n  /// After the \\c TokenAnnotator has finished annotating all the tokens,\n  /// this function precomputes required information for formatting.\n  virtual void precomputeFormattingInfos(const FormatToken *Token);\n\n  /// Apply the special formatting that the given role demands.\n  ///\n  /// Assumes that the token having this role is already formatted.\n  ///\n  /// Continues formatting from \\p State leaving indentation to \\p Indenter and\n  /// returns the total penalty that this formatting incurs.\n  virtual unsigned formatFromToken(LineState &State,\n                                   ContinuationIndenter *Indenter,\n                                   bool DryRun) {\n    return 0;\n  }\n\n  /// Same as \\c formatFromToken, but assumes that the first token has\n  /// already been set thereby deciding on the first line break.\n  virtual unsigned formatAfterToken(LineState &State,\n                                    ContinuationIndenter *Indenter,\n                                    bool DryRun) {\n    return 0;\n  }\n\n  /// Notifies the \\c Role that a comma was found.\n  virtual void CommaFound(const FormatToken *Token) {}\n\n  virtual const FormatToken *lastComma() { return nullptr; }\n\nprotected:\n  const FormatStyle &Style;\n};\n\nclass CommaSeparatedList : public TokenRole {\npublic:\n  CommaSeparatedList(const FormatStyle &Style)\n      : TokenRole(Style), HasNestedBracedList(false) {}\n\n  void precomputeFormattingInfos(const FormatToken *Token) override;\n\n  unsigned formatAfterToken(LineState &State, ContinuationIndenter *Indenter,\n                            bool DryRun) override;\n\n  unsigned formatFromToken(LineState &State, ContinuationIndenter *Indenter,\n                           bool DryRun) override;\n\n  /// Adds \\p Token as the next comma to the \\c CommaSeparated list.\n  void CommaFound(const FormatToken *Token) override {\n    Commas.push_back(Token);\n  }\n\n  const FormatToken *lastComma() override {\n    if (Commas.empty())\n      return nullptr;\n    return Commas.back();\n  }\n\nprivate:\n  /// A struct that holds information on how to format a given list with\n  /// a specific number of columns.\n  struct ColumnFormat {\n    /// The number of columns to use.\n    unsigned Columns;\n\n    /// The total width in characters.\n    unsigned TotalWidth;\n\n    /// The number of lines required for this format.\n    unsigned LineCount;\n\n    /// The size of each column in characters.\n    SmallVector<unsigned, 8> ColumnSizes;\n  };\n\n  /// Calculate which \\c ColumnFormat fits best into\n  /// \\p RemainingCharacters.\n  const ColumnFormat *getColumnFormat(unsigned RemainingCharacters) const;\n\n  /// The ordered \\c FormatTokens making up the commas of this list.\n  SmallVector<const FormatToken *, 8> Commas;\n\n  /// The length of each of the list's items in characters including the\n  /// trailing comma.\n  SmallVector<unsigned, 8> ItemLengths;\n\n  /// Precomputed formats that can be used for this list.\n  SmallVector<ColumnFormat, 4> Formats;\n\n  bool HasNestedBracedList;\n};\n\n/// Encapsulates keywords that are context sensitive or for languages not\n/// properly supported by Clang's lexer.\nstruct AdditionalKeywords {\n  AdditionalKeywords(IdentifierTable &IdentTable) {\n    kw_final = &IdentTable.get(\"final\");\n    kw_override = &IdentTable.get(\"override\");\n    kw_in = &IdentTable.get(\"in\");\n    kw_of = &IdentTable.get(\"of\");\n    kw_CF_CLOSED_ENUM = &IdentTable.get(\"CF_CLOSED_ENUM\");\n    kw_CF_ENUM = &IdentTable.get(\"CF_ENUM\");\n    kw_CF_OPTIONS = &IdentTable.get(\"CF_OPTIONS\");\n    kw_NS_CLOSED_ENUM = &IdentTable.get(\"NS_CLOSED_ENUM\");\n    kw_NS_ENUM = &IdentTable.get(\"NS_ENUM\");\n    kw_NS_OPTIONS = &IdentTable.get(\"NS_OPTIONS\");\n\n    kw_as = &IdentTable.get(\"as\");\n    kw_async = &IdentTable.get(\"async\");\n    kw_await = &IdentTable.get(\"await\");\n    kw_declare = &IdentTable.get(\"declare\");\n    kw_finally = &IdentTable.get(\"finally\");\n    kw_from = &IdentTable.get(\"from\");\n    kw_function = &IdentTable.get(\"function\");\n    kw_get = &IdentTable.get(\"get\");\n    kw_import = &IdentTable.get(\"import\");\n    kw_infer = &IdentTable.get(\"infer\");\n    kw_is = &IdentTable.get(\"is\");\n    kw_let = &IdentTable.get(\"let\");\n    kw_module = &IdentTable.get(\"module\");\n    kw_readonly = &IdentTable.get(\"readonly\");\n    kw_set = &IdentTable.get(\"set\");\n    kw_type = &IdentTable.get(\"type\");\n    kw_typeof = &IdentTable.get(\"typeof\");\n    kw_var = &IdentTable.get(\"var\");\n    kw_yield = &IdentTable.get(\"yield\");\n\n    kw_abstract = &IdentTable.get(\"abstract\");\n    kw_assert = &IdentTable.get(\"assert\");\n    kw_extends = &IdentTable.get(\"extends\");\n    kw_implements = &IdentTable.get(\"implements\");\n    kw_instanceof = &IdentTable.get(\"instanceof\");\n    kw_interface = &IdentTable.get(\"interface\");\n    kw_native = &IdentTable.get(\"native\");\n    kw_package = &IdentTable.get(\"package\");\n    kw_synchronized = &IdentTable.get(\"synchronized\");\n    kw_throws = &IdentTable.get(\"throws\");\n    kw___except = &IdentTable.get(\"__except\");\n    kw___has_include = &IdentTable.get(\"__has_include\");\n    kw___has_include_next = &IdentTable.get(\"__has_include_next\");\n\n    kw_mark = &IdentTable.get(\"mark\");\n\n    kw_extend = &IdentTable.get(\"extend\");\n    kw_option = &IdentTable.get(\"option\");\n    kw_optional = &IdentTable.get(\"optional\");\n    kw_repeated = &IdentTable.get(\"repeated\");\n    kw_required = &IdentTable.get(\"required\");\n    kw_returns = &IdentTable.get(\"returns\");\n\n    kw_signals = &IdentTable.get(\"signals\");\n    kw_qsignals = &IdentTable.get(\"Q_SIGNALS\");\n    kw_slots = &IdentTable.get(\"slots\");\n    kw_qslots = &IdentTable.get(\"Q_SLOTS\");\n\n    // C# keywords\n    kw_dollar = &IdentTable.get(\"dollar\");\n    kw_base = &IdentTable.get(\"base\");\n    kw_byte = &IdentTable.get(\"byte\");\n    kw_checked = &IdentTable.get(\"checked\");\n    kw_decimal = &IdentTable.get(\"decimal\");\n    kw_delegate = &IdentTable.get(\"delegate\");\n    kw_event = &IdentTable.get(\"event\");\n    kw_fixed = &IdentTable.get(\"fixed\");\n    kw_foreach = &IdentTable.get(\"foreach\");\n    kw_implicit = &IdentTable.get(\"implicit\");\n    kw_internal = &IdentTable.get(\"internal\");\n    kw_lock = &IdentTable.get(\"lock\");\n    kw_null = &IdentTable.get(\"null\");\n    kw_object = &IdentTable.get(\"object\");\n    kw_out = &IdentTable.get(\"out\");\n    kw_params = &IdentTable.get(\"params\");\n    kw_ref = &IdentTable.get(\"ref\");\n    kw_string = &IdentTable.get(\"string\");\n    kw_stackalloc = &IdentTable.get(\"stackalloc\");\n    kw_sbyte = &IdentTable.get(\"sbyte\");\n    kw_sealed = &IdentTable.get(\"sealed\");\n    kw_uint = &IdentTable.get(\"uint\");\n    kw_ulong = &IdentTable.get(\"ulong\");\n    kw_unchecked = &IdentTable.get(\"unchecked\");\n    kw_unsafe = &IdentTable.get(\"unsafe\");\n    kw_ushort = &IdentTable.get(\"ushort\");\n    kw_when = &IdentTable.get(\"when\");\n    kw_where = &IdentTable.get(\"where\");\n\n    // Keep this at the end of the constructor to make sure everything here\n    // is\n    // already initialized.\n    JsExtraKeywords = std::unordered_set<IdentifierInfo *>(\n        {kw_as, kw_async, kw_await, kw_declare, kw_finally, kw_from,\n         kw_function, kw_get, kw_import, kw_is, kw_let, kw_module, kw_readonly,\n         kw_set, kw_type, kw_typeof, kw_var, kw_yield,\n         // Keywords from the Java section.\n         kw_abstract, kw_extends, kw_implements, kw_instanceof, kw_interface});\n\n    CSharpExtraKeywords = std::unordered_set<IdentifierInfo *>(\n        {kw_base, kw_byte, kw_checked, kw_decimal, kw_delegate, kw_event,\n         kw_fixed, kw_foreach, kw_implicit, kw_in, kw_interface, kw_internal,\n         kw_is, kw_lock, kw_null, kw_object, kw_out, kw_override, kw_params,\n         kw_readonly, kw_ref, kw_string, kw_stackalloc, kw_sbyte, kw_sealed,\n         kw_uint, kw_ulong, kw_unchecked, kw_unsafe, kw_ushort, kw_when,\n         kw_where,\n         // Keywords from the JavaScript section.\n         kw_as, kw_async, kw_await, kw_declare, kw_finally, kw_from,\n         kw_function, kw_get, kw_import, kw_is, kw_let, kw_module, kw_readonly,\n         kw_set, kw_type, kw_typeof, kw_var, kw_yield,\n         // Keywords from the Java section.\n         kw_abstract, kw_extends, kw_implements, kw_instanceof, kw_interface});\n  }\n\n  // Context sensitive keywords.\n  IdentifierInfo *kw_final;\n  IdentifierInfo *kw_override;\n  IdentifierInfo *kw_in;\n  IdentifierInfo *kw_of;\n  IdentifierInfo *kw_CF_CLOSED_ENUM;\n  IdentifierInfo *kw_CF_ENUM;\n  IdentifierInfo *kw_CF_OPTIONS;\n  IdentifierInfo *kw_NS_CLOSED_ENUM;\n  IdentifierInfo *kw_NS_ENUM;\n  IdentifierInfo *kw_NS_OPTIONS;\n  IdentifierInfo *kw___except;\n  IdentifierInfo *kw___has_include;\n  IdentifierInfo *kw___has_include_next;\n\n  // JavaScript keywords.\n  IdentifierInfo *kw_as;\n  IdentifierInfo *kw_async;\n  IdentifierInfo *kw_await;\n  IdentifierInfo *kw_declare;\n  IdentifierInfo *kw_finally;\n  IdentifierInfo *kw_from;\n  IdentifierInfo *kw_function;\n  IdentifierInfo *kw_get;\n  IdentifierInfo *kw_import;\n  IdentifierInfo *kw_infer;\n  IdentifierInfo *kw_is;\n  IdentifierInfo *kw_let;\n  IdentifierInfo *kw_module;\n  IdentifierInfo *kw_readonly;\n  IdentifierInfo *kw_set;\n  IdentifierInfo *kw_type;\n  IdentifierInfo *kw_typeof;\n  IdentifierInfo *kw_var;\n  IdentifierInfo *kw_yield;\n\n  // Java keywords.\n  IdentifierInfo *kw_abstract;\n  IdentifierInfo *kw_assert;\n  IdentifierInfo *kw_extends;\n  IdentifierInfo *kw_implements;\n  IdentifierInfo *kw_instanceof;\n  IdentifierInfo *kw_interface;\n  IdentifierInfo *kw_native;\n  IdentifierInfo *kw_package;\n  IdentifierInfo *kw_synchronized;\n  IdentifierInfo *kw_throws;\n\n  // Pragma keywords.\n  IdentifierInfo *kw_mark;\n\n  // Proto keywords.\n  IdentifierInfo *kw_extend;\n  IdentifierInfo *kw_option;\n  IdentifierInfo *kw_optional;\n  IdentifierInfo *kw_repeated;\n  IdentifierInfo *kw_required;\n  IdentifierInfo *kw_returns;\n\n  // QT keywords.\n  IdentifierInfo *kw_signals;\n  IdentifierInfo *kw_qsignals;\n  IdentifierInfo *kw_slots;\n  IdentifierInfo *kw_qslots;\n\n  // C# keywords\n  IdentifierInfo *kw_dollar;\n  IdentifierInfo *kw_base;\n  IdentifierInfo *kw_byte;\n  IdentifierInfo *kw_checked;\n  IdentifierInfo *kw_decimal;\n  IdentifierInfo *kw_delegate;\n  IdentifierInfo *kw_event;\n  IdentifierInfo *kw_fixed;\n  IdentifierInfo *kw_foreach;\n  IdentifierInfo *kw_implicit;\n  IdentifierInfo *kw_internal;\n\n  IdentifierInfo *kw_lock;\n  IdentifierInfo *kw_null;\n  IdentifierInfo *kw_object;\n  IdentifierInfo *kw_out;\n\n  IdentifierInfo *kw_params;\n\n  IdentifierInfo *kw_ref;\n  IdentifierInfo *kw_string;\n  IdentifierInfo *kw_stackalloc;\n  IdentifierInfo *kw_sbyte;\n  IdentifierInfo *kw_sealed;\n  IdentifierInfo *kw_uint;\n  IdentifierInfo *kw_ulong;\n  IdentifierInfo *kw_unchecked;\n  IdentifierInfo *kw_unsafe;\n  IdentifierInfo *kw_ushort;\n  IdentifierInfo *kw_when;\n  IdentifierInfo *kw_where;\n\n  /// Returns \\c true if \\p Tok is a true JavaScript identifier, returns\n  /// \\c false if it is a keyword or a pseudo keyword.\n  /// If \\c AcceptIdentifierName is true, returns true not only for keywords,\n  // but also for IdentifierName tokens (aka pseudo-keywords), such as\n  // ``yield``.\n  bool IsJavaScriptIdentifier(const FormatToken &Tok,\n                              bool AcceptIdentifierName = true) const {\n    // Based on the list of JavaScript & TypeScript keywords here:\n    // https://github.com/microsoft/TypeScript/blob/master/src/compiler/scanner.ts#L74\n    switch (Tok.Tok.getKind()) {\n    case tok::kw_break:\n    case tok::kw_case:\n    case tok::kw_catch:\n    case tok::kw_class:\n    case tok::kw_continue:\n    case tok::kw_const:\n    case tok::kw_default:\n    case tok::kw_delete:\n    case tok::kw_do:\n    case tok::kw_else:\n    case tok::kw_enum:\n    case tok::kw_export:\n    case tok::kw_false:\n    case tok::kw_for:\n    case tok::kw_if:\n    case tok::kw_import:\n    case tok::kw_module:\n    case tok::kw_new:\n    case tok::kw_private:\n    case tok::kw_protected:\n    case tok::kw_public:\n    case tok::kw_return:\n    case tok::kw_static:\n    case tok::kw_switch:\n    case tok::kw_this:\n    case tok::kw_throw:\n    case tok::kw_true:\n    case tok::kw_try:\n    case tok::kw_typeof:\n    case tok::kw_void:\n    case tok::kw_while:\n      // These are JS keywords that are lexed by LLVM/clang as keywords.\n      return false;\n    case tok::identifier: {\n      // For identifiers, make sure they are true identifiers, excluding the\n      // JavaScript pseudo-keywords (not lexed by LLVM/clang as keywords).\n      bool IsPseudoKeyword =\n          JsExtraKeywords.find(Tok.Tok.getIdentifierInfo()) !=\n          JsExtraKeywords.end();\n      return AcceptIdentifierName || !IsPseudoKeyword;\n    }\n    default:\n      // Other keywords are handled in the switch below, to avoid problems due\n      // to duplicate case labels when using the #include trick.\n      break;\n    }\n\n    switch (Tok.Tok.getKind()) {\n      // Handle C++ keywords not included above: these are all JS identifiers.\n#define KEYWORD(X, Y) case tok::kw_##X:\n#include \"clang/Basic/TokenKinds.def\"\n      // #undef KEYWORD is not needed -- it's #undef-ed at the end of\n      // TokenKinds.def\n      return true;\n    default:\n      // All other tokens (punctuation etc) are not JS identifiers.\n      return false;\n    }\n  }\n\n  /// Returns \\c true if \\p Tok is a C# keyword, returns\n  /// \\c false if it is a anything else.\n  bool isCSharpKeyword(const FormatToken &Tok) const {\n    switch (Tok.Tok.getKind()) {\n    case tok::kw_bool:\n    case tok::kw_break:\n    case tok::kw_case:\n    case tok::kw_catch:\n    case tok::kw_char:\n    case tok::kw_class:\n    case tok::kw_const:\n    case tok::kw_continue:\n    case tok::kw_default:\n    case tok::kw_do:\n    case tok::kw_double:\n    case tok::kw_else:\n    case tok::kw_enum:\n    case tok::kw_explicit:\n    case tok::kw_extern:\n    case tok::kw_false:\n    case tok::kw_float:\n    case tok::kw_for:\n    case tok::kw_goto:\n    case tok::kw_if:\n    case tok::kw_int:\n    case tok::kw_long:\n    case tok::kw_namespace:\n    case tok::kw_new:\n    case tok::kw_operator:\n    case tok::kw_private:\n    case tok::kw_protected:\n    case tok::kw_public:\n    case tok::kw_return:\n    case tok::kw_short:\n    case tok::kw_sizeof:\n    case tok::kw_static:\n    case tok::kw_struct:\n    case tok::kw_switch:\n    case tok::kw_this:\n    case tok::kw_throw:\n    case tok::kw_true:\n    case tok::kw_try:\n    case tok::kw_typeof:\n    case tok::kw_using:\n    case tok::kw_virtual:\n    case tok::kw_void:\n    case tok::kw_volatile:\n    case tok::kw_while:\n      return true;\n    default:\n      return Tok.is(tok::identifier) &&\n             CSharpExtraKeywords.find(Tok.Tok.getIdentifierInfo()) ==\n                 CSharpExtraKeywords.end();\n    }\n  }\n\nprivate:\n  /// The JavaScript keywords beyond the C++ keyword set.\n  std::unordered_set<IdentifierInfo *> JsExtraKeywords;\n\n  /// The C# keywords beyond the C++ keyword set\n  std::unordered_set<IdentifierInfo *> CSharpExtraKeywords;\n};\n\n} // namespace format\n} // namespace clang\n\n#endif\n"}, "20": {"id": 20, "path": "/home/vsts/work/1/llvm-project/clang/lib/Format/UnwrappedLineParser.h", "content": "//===--- UnwrappedLineParser.h - Format C++ code ----------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n///\n/// \\file\n/// This file contains the declaration of the UnwrappedLineParser,\n/// which turns a stream of tokens into UnwrappedLines.\n///\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_CLANG_LIB_FORMAT_UNWRAPPEDLINEPARSER_H\n#define LLVM_CLANG_LIB_FORMAT_UNWRAPPEDLINEPARSER_H\n\n#include \"FormatToken.h\"\n#include \"clang/Basic/IdentifierTable.h\"\n#include \"clang/Format/Format.h\"\n#include \"llvm/Support/Regex.h\"\n#include <list>\n#include <stack>\n\nnamespace clang {\nnamespace format {\n\nstruct UnwrappedLineNode;\n\n/// An unwrapped line is a sequence of \\c Token, that we would like to\n/// put on a single line if there was no column limit.\n///\n/// This is used as a main interface between the \\c UnwrappedLineParser and the\n/// \\c UnwrappedLineFormatter. The key property is that changing the formatting\n/// within an unwrapped line does not affect any other unwrapped lines.\nstruct UnwrappedLine {\n  UnwrappedLine();\n\n  // FIXME: Don't use std::list here.\n  /// The \\c Tokens comprising this \\c UnwrappedLine.\n  std::list<UnwrappedLineNode> Tokens;\n\n  /// The indent level of the \\c UnwrappedLine.\n  unsigned Level;\n\n  /// Whether this \\c UnwrappedLine is part of a preprocessor directive.\n  bool InPPDirective;\n\n  bool MustBeDeclaration;\n\n  /// If this \\c UnwrappedLine closes a block in a sequence of lines,\n  /// \\c MatchingOpeningBlockLineIndex stores the index of the corresponding\n  /// opening line. Otherwise, \\c MatchingOpeningBlockLineIndex must be\n  /// \\c kInvalidIndex.\n  size_t MatchingOpeningBlockLineIndex = kInvalidIndex;\n\n  /// If this \\c UnwrappedLine opens a block, stores the index of the\n  /// line with the corresponding closing brace.\n  size_t MatchingClosingBlockLineIndex = kInvalidIndex;\n\n  static const size_t kInvalidIndex = -1;\n\n  unsigned FirstStartColumn = 0;\n};\n\nclass UnwrappedLineConsumer {\npublic:\n  virtual ~UnwrappedLineConsumer() {}\n  virtual void consumeUnwrappedLine(const UnwrappedLine &Line) = 0;\n  virtual void finishRun() = 0;\n};\n\nclass FormatTokenSource;\n\nclass UnwrappedLineParser {\npublic:\n  UnwrappedLineParser(const FormatStyle &Style,\n                      const AdditionalKeywords &Keywords,\n                      unsigned FirstStartColumn, ArrayRef<FormatToken *> Tokens,\n                      UnwrappedLineConsumer &Callback);\n\n  void parse();\n\nprivate:\n  void reset();\n  void parseFile();\n  void parseLevel(bool HasOpeningBrace);\n  void parseBlock(bool MustBeDeclaration, unsigned AddLevels = 1u,\n                  bool MunchSemi = true,\n                  bool UnindentWhitesmithsBraces = false);\n  void parseChildBlock();\n  void parsePPDirective();\n  void parsePPDefine();\n  void parsePPIf(bool IfDef);\n  void parsePPElIf();\n  void parsePPElse();\n  void parsePPEndIf();\n  void parsePPUnknown();\n  void readTokenWithJavaScriptASI();\n  void parseStructuralElement();\n  bool tryToParseBracedList();\n  bool parseBracedList(bool ContinueOnSemicolons = false, bool IsEnum = false,\n                       tok::TokenKind ClosingBraceKind = tok::r_brace);\n  void parseParens();\n  void parseSquare(bool LambdaIntroducer = false);\n  void parseIfThenElse();\n  void parseTryCatch();\n  void parseForOrWhileLoop();\n  void parseDoWhile();\n  void parseLabel(bool LeftAlignLabel = false);\n  void parseCaseLabel();\n  void parseSwitch();\n  void parseNamespace();\n  void parseNew();\n  void parseAccessSpecifier();\n  bool parseEnum();\n  void parseConcept();\n  void parseRequires();\n  void parseRequiresExpression(unsigned int OriginalLevel);\n  void parseConstraintExpression(unsigned int OriginalLevel);\n  void parseJavaEnumBody();\n  // Parses a record (aka class) as a top level element. If ParseAsExpr is true,\n  // parses the record as a child block, i.e. if the class declaration is an\n  // expression.\n  void parseRecord(bool ParseAsExpr = false);\n  void parseObjCLightweightGenerics();\n  void parseObjCMethod();\n  void parseObjCProtocolList();\n  void parseObjCUntilAtEnd();\n  void parseObjCInterfaceOrImplementation();\n  bool parseObjCProtocol();\n  void parseJavaScriptEs6ImportExport();\n  void parseStatementMacro();\n  void parseCSharpAttribute();\n  // Parse a C# generic type constraint: `where T : IComparable<T>`.\n  // See:\n  // https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/where-generic-type-constraint\n  void parseCSharpGenericTypeConstraint();\n  bool tryToParseLambda();\n  bool tryToParseLambdaIntroducer();\n  bool tryToParsePropertyAccessor();\n  void tryToParseJSFunction();\n  bool tryToParseSimpleAttribute();\n\n  // Used by addUnwrappedLine to denote whether to keep or remove a level\n  // when resetting the line state.\n  enum class LineLevel { Remove, Keep };\n\n  void addUnwrappedLine(LineLevel AdjustLevel = LineLevel::Remove);\n  bool eof() const;\n  // LevelDifference is the difference of levels after and before the current\n  // token. For example:\n  // - if the token is '{' and opens a block, LevelDifference is 1.\n  // - if the token is '}' and closes a block, LevelDifference is -1.\n  void nextToken(int LevelDifference = 0);\n  void readToken(int LevelDifference = 0);\n\n  // Decides which comment tokens should be added to the current line and which\n  // should be added as comments before the next token.\n  //\n  // Comments specifies the sequence of comment tokens to analyze. They get\n  // either pushed to the current line or added to the comments before the next\n  // token.\n  //\n  // NextTok specifies the next token. A null pointer NextTok is supported, and\n  // signifies either the absence of a next token, or that the next token\n  // shouldn't be taken into accunt for the analysis.\n  void distributeComments(const SmallVectorImpl<FormatToken *> &Comments,\n                          const FormatToken *NextTok);\n\n  // Adds the comment preceding the next token to unwrapped lines.\n  void flushComments(bool NewlineBeforeNext);\n  void pushToken(FormatToken *Tok);\n  void calculateBraceTypes(bool ExpectClassBody = false);\n\n  // Marks a conditional compilation edge (for example, an '#if', '#ifdef',\n  // '#else' or merge conflict marker). If 'Unreachable' is true, assumes\n  // this branch either cannot be taken (for example '#if false'), or should\n  // not be taken in this round.\n  void conditionalCompilationCondition(bool Unreachable);\n  void conditionalCompilationStart(bool Unreachable);\n  void conditionalCompilationAlternative();\n  void conditionalCompilationEnd();\n\n  bool isOnNewLine(const FormatToken &FormatTok);\n\n  // Compute hash of the current preprocessor branch.\n  // This is used to identify the different branches, and thus track if block\n  // open and close in the same branch.\n  size_t computePPHash() const;\n\n  // FIXME: We are constantly running into bugs where Line.Level is incorrectly\n  // subtracted from beyond 0. Introduce a method to subtract from Line.Level\n  // and use that everywhere in the Parser.\n  std::unique_ptr<UnwrappedLine> Line;\n\n  // Comments are sorted into unwrapped lines by whether they are in the same\n  // line as the previous token, or not. If not, they belong to the next token.\n  // Since the next token might already be in a new unwrapped line, we need to\n  // store the comments belonging to that token.\n  SmallVector<FormatToken *, 1> CommentsBeforeNextToken;\n  FormatToken *FormatTok;\n  bool MustBreakBeforeNextToken;\n\n  // The parsed lines. Only added to through \\c CurrentLines.\n  SmallVector<UnwrappedLine, 8> Lines;\n\n  // Preprocessor directives are parsed out-of-order from other unwrapped lines.\n  // Thus, we need to keep a list of preprocessor directives to be reported\n  // after an unwrapped line that has been started was finished.\n  SmallVector<UnwrappedLine, 4> PreprocessorDirectives;\n\n  // New unwrapped lines are added via CurrentLines.\n  // Usually points to \\c &Lines. While parsing a preprocessor directive when\n  // there is an unfinished previous unwrapped line, will point to\n  // \\c &PreprocessorDirectives.\n  SmallVectorImpl<UnwrappedLine> *CurrentLines;\n\n  // We store for each line whether it must be a declaration depending on\n  // whether we are in a compound statement or not.\n  std::vector<bool> DeclarationScopeStack;\n\n  const FormatStyle &Style;\n  const AdditionalKeywords &Keywords;\n\n  llvm::Regex CommentPragmasRegex;\n\n  FormatTokenSource *Tokens;\n  UnwrappedLineConsumer &Callback;\n\n  // FIXME: This is a temporary measure until we have reworked the ownership\n  // of the format tokens. The goal is to have the actual tokens created and\n  // owned outside of and handed into the UnwrappedLineParser.\n  ArrayRef<FormatToken *> AllTokens;\n\n  // Represents preprocessor branch type, so we can find matching\n  // #if/#else/#endif directives.\n  enum PPBranchKind {\n    PP_Conditional, // Any #if, #ifdef, #ifndef, #elif, block outside #if 0\n    PP_Unreachable  // #if 0 or a conditional preprocessor block inside #if 0\n  };\n\n  struct PPBranch {\n    PPBranch(PPBranchKind Kind, size_t Line) : Kind(Kind), Line(Line) {}\n    PPBranchKind Kind;\n    size_t Line;\n  };\n\n  // Keeps a stack of currently active preprocessor branching directives.\n  SmallVector<PPBranch, 16> PPStack;\n\n  // The \\c UnwrappedLineParser re-parses the code for each combination\n  // of preprocessor branches that can be taken.\n  // To that end, we take the same branch (#if, #else, or one of the #elif\n  // branches) for each nesting level of preprocessor branches.\n  // \\c PPBranchLevel stores the current nesting level of preprocessor\n  // branches during one pass over the code.\n  int PPBranchLevel;\n\n  // Contains the current branch (#if, #else or one of the #elif branches)\n  // for each nesting level.\n  SmallVector<int, 8> PPLevelBranchIndex;\n\n  // Contains the maximum number of branches at each nesting level.\n  SmallVector<int, 8> PPLevelBranchCount;\n\n  // Contains the number of branches per nesting level we are currently\n  // in while parsing a preprocessor branch sequence.\n  // This is used to update PPLevelBranchCount at the end of a branch\n  // sequence.\n  std::stack<int> PPChainBranchIndex;\n\n  // Include guard search state. Used to fixup preprocessor indent levels\n  // so that include guards do not participate in indentation.\n  enum IncludeGuardState {\n    IG_Inited,   // Search started, looking for #ifndef.\n    IG_IfNdefed, // #ifndef found, IncludeGuardToken points to condition.\n    IG_Defined,  // Matching #define found, checking other requirements.\n    IG_Found,    // All requirements met, need to fix indents.\n    IG_Rejected, // Search failed or never started.\n  };\n\n  // Current state of include guard search.\n  IncludeGuardState IncludeGuard;\n\n  // Points to the #ifndef condition for a potential include guard. Null unless\n  // IncludeGuardState == IG_IfNdefed.\n  FormatToken *IncludeGuardToken;\n\n  // Contains the first start column where the source begins. This is zero for\n  // normal source code and may be nonzero when formatting a code fragment that\n  // does not start at the beginning of the file.\n  unsigned FirstStartColumn;\n\n  friend class ScopedLineState;\n  friend class CompoundStatementIndenter;\n};\n\nstruct UnwrappedLineNode {\n  UnwrappedLineNode() : Tok(nullptr) {}\n  UnwrappedLineNode(FormatToken *Tok) : Tok(Tok) {}\n\n  FormatToken *Tok;\n  SmallVector<UnwrappedLine, 0> Children;\n};\n\ninline UnwrappedLine::UnwrappedLine()\n    : Level(0), InPPDirective(false), MustBeDeclaration(false),\n      MatchingOpeningBlockLineIndex(kInvalidIndex) {}\n\n} // end namespace format\n} // end namespace clang\n\n#endif\n"}}, "reports": [{"events": [{"location": {"col": 25, "file": 17, "line": 86}, "message": "destructor '~' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/lib/Format/ContinuationIndenter.cpp", "reportHash": "802d80c4c6e25321101489510a17283d", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 25, "file": 17, "line": 86}, "message": "move constructor '' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/lib/Format/ContinuationIndenter.cpp", "reportHash": "b70aa8b9d5f6b9431467d660313a7158", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 18, "line": 38}, "message": "destructor '~RawStringFormatStyleManager' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/lib/Format/ContinuationIndenter.h", "reportHash": "b731db57db68ab31f0ed62e4c85d3f2e", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 18, "line": 201}, "message": "destructor '~ParenState' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/lib/Format/ContinuationIndenter.h", "reportHash": "763655f2ef3e869dd43f2b75b95e63c0", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 18, "line": 406}, "message": "destructor '~LineState' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/lib/Format/ContinuationIndenter.h", "reportHash": "f6e2b328d67491194e78f7bbe823c153", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 18, "line": 406}, "message": "move constructor 'LineState' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/lib/Format/ContinuationIndenter.h", "reportHash": "119394afaa11f690f0bb1480de66e066", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 19, "line": 184}, "message": "destructor '~MacroExpansion' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/lib/Format/FormatToken.h", "reportHash": "ff18260477d2e7818e6cf9adb1c2dbda", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 10, "file": 19, "line": 800}, "message": "destructor '~ColumnFormat' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/lib/Format/FormatToken.h", "reportHash": "dde0be5a01c1127a955199bffa3abf3a", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 20, "line": 36}, "message": "destructor '~UnwrappedLine' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/lib/Format/UnwrappedLineParser.h", "reportHash": "256de74f47a43d49eee1bbc410698f1e", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 10, "file": 20, "line": 243}, "message": "destructor '~PPBranch' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/lib/Format/UnwrappedLineParser.h", "reportHash": "dd2050534a7ab4a4fcf1000d7bdf83ad", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 10, "file": 20, "line": 243}, "message": "move constructor 'PPBranch' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/lib/Format/UnwrappedLineParser.h", "reportHash": "c608aff8c5198751118cda23c6a6f236", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}]};
      window.onload = function() {
        if (!browserCompatible) {
          setNonCompatibleBrowserMessage();
        } else {
          BugViewer.init(data.files, data.reports);
          BugViewer.create();
          BugViewer.initByUrl();
        }
      };
    </script>
  </head>
  <body>
  <div class="container">
    <div id="content">
      <div id="side-bar">
        <div class="header">
          <a href="index.html" class="button">&#8249; Return to List</a>
        </div>
        <div id="report-nav">
          <div class="header">Reports</div>
        </div>
      </div>
      <div id="editor-wrapper">
        <div class="header">
          <div id="file">
            <span class="label">File:</span>
            <span id="file-path"></span>
          </div>
          <div id="checker">
            <span class="label">Checker name:</span>
            <span id="checker-name"></span>
          </div>
          <div id="review-status-wrapper">
            <span class="label">Review status:</span>
            <span id="review-status"></span>
          </div>
        </div>
        <div id="editor"></div>
      </div>
    </div>
  </div>
  </body>
</html>
