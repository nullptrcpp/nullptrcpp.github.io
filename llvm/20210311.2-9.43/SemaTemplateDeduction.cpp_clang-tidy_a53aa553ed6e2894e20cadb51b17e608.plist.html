<!DOCTYPE html>
<html>
  <head>
    <title>Plist HTML Viewer</title>

    <meta charset="UTF-8">

    <style type="text/css">
      .CodeMirror{font-family:monospace;height:300px;color:#000;direction:ltr}.CodeMirror-lines{padding:4px 0}.CodeMirror pre{padding:0 4px}.CodeMirror-gutter-filler,.CodeMirror-scrollbar-filler{background-color:#fff}.CodeMirror-gutters{border-right:1px solid #ddd;background-color:#f7f7f7;white-space:nowrap}.CodeMirror-linenumber{padding:0 3px 0 5px;min-width:20px;text-align:right;color:#999;white-space:nowrap}.CodeMirror-guttermarker{color:#000}.CodeMirror-guttermarker-subtle{color:#999}.CodeMirror-cursor{border-left:1px solid #000;border-right:none;width:0}.CodeMirror div.CodeMirror-secondarycursor{border-left:1px solid silver}.cm-fat-cursor .CodeMirror-cursor{width:auto;border:0!important;background:#7e7}.cm-fat-cursor div.CodeMirror-cursors{z-index:1}.cm-animate-fat-cursor{width:auto;border:0;-webkit-animation:blink 1.06s steps(1) infinite;-moz-animation:blink 1.06s steps(1) infinite;animation:blink 1.06s steps(1) infinite;background-color:#7e7}@-moz-keyframes blink{50%{background-color:transparent}}@-webkit-keyframes blink{50%{background-color:transparent}}@keyframes blink{50%{background-color:transparent}}.cm-tab{display:inline-block;text-decoration:inherit}.CodeMirror-rulers{position:absolute;left:0;right:0;top:-50px;bottom:-20px;overflow:hidden}.CodeMirror-ruler{border-left:1px solid #ccc;top:0;bottom:0;position:absolute}.cm-s-default .cm-header{color:#00f}.cm-s-default .cm-quote{color:#090}.cm-negative{color:#d44}.cm-positive{color:#292}.cm-header,.cm-strong{font-weight:700}.cm-em{font-style:italic}.cm-link{text-decoration:underline}.cm-strikethrough{text-decoration:line-through}.cm-s-default .cm-keyword{color:#708}.cm-s-default .cm-atom{color:#219}.cm-s-default .cm-number{color:#164}.cm-s-default .cm-def{color:#00f}.cm-s-default .cm-variable-2{color:#05a}.cm-s-default .cm-type,.cm-s-default .cm-variable-3{color:#085}.cm-s-default .cm-comment{color:#a50}.cm-s-default .cm-string{color:#a11}.cm-s-default .cm-string-2{color:#f50}.cm-s-default .cm-meta{color:#555}.cm-s-default .cm-qualifier{color:#555}.cm-s-default .cm-builtin{color:#30a}.cm-s-default .cm-bracket{color:#997}.cm-s-default .cm-tag{color:#170}.cm-s-default .cm-attribute{color:#00c}.cm-s-default .cm-hr{color:#999}.cm-s-default .cm-link{color:#00c}.cm-s-default .cm-error{color:red}.cm-invalidchar{color:red}.CodeMirror-composing{border-bottom:2px solid}div.CodeMirror span.CodeMirror-matchingbracket{color:#0f0}div.CodeMirror span.CodeMirror-nonmatchingbracket{color:#f22}.CodeMirror-matchingtag{background:rgba(255,150,0,.3)}.CodeMirror-activeline-background{background:#e8f2ff}.CodeMirror{position:relative;overflow:hidden;background:#fff}.CodeMirror-scroll{overflow:scroll!important;margin-bottom:-30px;margin-right:-30px;padding-bottom:30px;height:100%;outline:0;position:relative}.CodeMirror-sizer{position:relative;border-right:30px solid transparent}.CodeMirror-gutter-filler,.CodeMirror-hscrollbar,.CodeMirror-scrollbar-filler,.CodeMirror-vscrollbar{position:absolute;z-index:6;display:none}.CodeMirror-vscrollbar{right:0;top:0;overflow-x:hidden;overflow-y:scroll}.CodeMirror-hscrollbar{bottom:0;left:0;overflow-y:hidden;overflow-x:scroll}.CodeMirror-scrollbar-filler{right:0;bottom:0}.CodeMirror-gutter-filler{left:0;bottom:0}.CodeMirror-gutters{position:absolute;left:0;top:0;min-height:100%;z-index:3}.CodeMirror-gutter{white-space:normal;height:100%;display:inline-block;vertical-align:top;margin-bottom:-30px}.CodeMirror-gutter-wrapper{position:absolute;z-index:4;background:0 0!important;border:none!important}.CodeMirror-gutter-background{position:absolute;top:0;bottom:0;z-index:4}.CodeMirror-gutter-elt{position:absolute;cursor:default;z-index:4}.CodeMirror-gutter-wrapper ::selection{background-color:transparent}.CodeMirror-gutter-wrapper ::-moz-selection{background-color:transparent}.CodeMirror-lines{cursor:text;min-height:1px}.CodeMirror pre{-moz-border-radius:0;-webkit-border-radius:0;border-radius:0;border-width:0;background:0 0;font-family:inherit;font-size:inherit;margin:0;white-space:pre;word-wrap:normal;line-height:inherit;color:inherit;z-index:2;position:relative;overflow:visible;-webkit-tap-highlight-color:transparent;-webkit-font-variant-ligatures:contextual;font-variant-ligatures:contextual}.CodeMirror-wrap pre{word-wrap:break-word;white-space:pre-wrap;word-break:normal}.CodeMirror-linebackground{position:absolute;left:0;right:0;top:0;bottom:0;z-index:0}.CodeMirror-linewidget{position:relative;z-index:2;overflow:auto}.CodeMirror-rtl pre{direction:rtl}.CodeMirror-code{outline:0}.CodeMirror-gutter,.CodeMirror-gutters,.CodeMirror-linenumber,.CodeMirror-scroll,.CodeMirror-sizer{-moz-box-sizing:content-box;box-sizing:content-box}.CodeMirror-measure{position:absolute;width:100%;height:0;overflow:hidden;visibility:hidden}.CodeMirror-cursor{position:absolute;pointer-events:none}.CodeMirror-measure pre{position:static}div.CodeMirror-cursors{visibility:hidden;position:relative;z-index:3}div.CodeMirror-dragcursors{visibility:visible}.CodeMirror-focused div.CodeMirror-cursors{visibility:visible}.CodeMirror-selected{background:#d9d9d9}.CodeMirror-focused .CodeMirror-selected{background:#d7d4f0}.CodeMirror-crosshair{cursor:crosshair}.CodeMirror-line::selection,.CodeMirror-line>span::selection,.CodeMirror-line>span>span::selection{background:#d7d4f0}.CodeMirror-line::-moz-selection,.CodeMirror-line>span::-moz-selection,.CodeMirror-line>span>span::-moz-selection{background:#d7d4f0}.cm-searching{background-color:#ffa;background-color:rgba(255,255,0,.4)}.cm-force-border{padding-right:.1px}@media print{.CodeMirror div.CodeMirror-cursors{visibility:hidden}}.cm-tab-wrap-hack:after{content:''}span.CodeMirror-selectedtext{background:0 0}
/*# sourceMappingURL=codemirror.min.css.map */

      .severity-low {
  background-color: #669603;
}

.severity-low:after {
  content : 'L';
}

.severity-unspecified {
  background-color: #666666;
}

.severity-unspecified:after {
  content : 'U';
}

.severity-style {
  background-color: #9932cc;
}

.severity-style:after {
  content : 'S';
}

.severity-medium {
  background-color: #a9d323;
  color: black;
}

.severity-medium:after {
  content : 'M';
}

.severity-high {
  background-color: #ffa800;
}

.severity-high:after {
  content : 'H';
}

.severity-critical {
  background-color: #e92625;
}

.severity-critical:after {
  content : 'C';
}

i[class*="severity-"] {
  line-height: normal;
  text-transform: capitalize;
  font-size: 0.8em;
  font-weight: bold;
  color: white;
  display: inline-block;
  width: 16px;
  height: 16px;
  text-align: center;
  font-family: sans-serif;
}

      html, body {
  width: 100%;
  height: 100%;
  padding: 0px;
  margin: 0px;
}

div.container {
  padding: 10px;
}

#content {
  height: 100%;
  display: block;
  overflow: hidden;
}

#content > div {
  margin: 10px;
  overflow: hidden;
  border: 1px solid #ddd;
  border-radius: 3px;
  overflow: hidden;
  height: 97%;
}

.button {
  background-color: #f1f1f1;
  text-decoration: none;
  display: inline-block;
  padding: 8px 16px;
  color: black;
  cursor: pointer;
}

.button:hover {
  background-color: #ddd;
  color: black;
}

.review-status {
  color: white;
  text-align: center;
}

.review-status-confirmed {
  background-color: #e92625;
}

.review-status-false-positive {
  background-color: grey;
}

.review-status-intentional {
  background-color: #669603;
}

      div.container {
  width: 100%;
  height: 100%;
  padding: 0px;
}

#editor-wrapper {
  margin: 10px;
}

#side-bar {
  float: left;
  width: 260px;
  margin: 0px;
}

#report-nav ul {
  list-style-type: none;
  padding: 0;
  margin: 0;
  overflow-y: auto;
  height: 100%;
}

#report-nav ul > li {
  padding: .4em;
  background-color: #fff;
  border-bottom: 1px solid rgba(0,0,0,.125);
  text-align: left;
  overflow: hidden;
  white-space: nowrap;
  text-overflow: ellipsis;
}

#report-nav ul > li.active {
  background-color: #427ea9;
  color: white;
}

#report-nav ul > li:hover {
  background-color: #427ea9;
  color: white;
  cursor: pointer;
}

#report-nav ul a {
  text-decoration: none;
}

#report-nav i[class*="severity-"] {
  margin-right: 5px;
}

.header {
  border-bottom: 1px solid lightgrey;
  font-family: monospace;
  padding: 10px;
  background-color: #fafbfc;
  border-bottom: 1px solid #e1e4e8;
  border-top-left-radius: 2px;
  border-top-right-radius: 2px;
}

#report-nav .header {
  font-weight: bold;
}

#editor-wrapper .header > div {
  padding-top: 2px;
}

#file-path,
#checker-name {
  color: #195ea2;
}

#review-status {
  padding: 0px 5px;
}

#file-path {
  font-family: monospace;
}

.check-msg {
  display: inline-block;
  padding: 3px 6px;
  margin: 1px;
  -webkit-border-radius: 5px;
  -moz-border-radius: 5px;
  border-radius: 5px;
}

.check-msg.info {
  color: #00546f;
  background-color: #bfdfe9;
  border: 1px solid #87a8b3;
}

.check-msg.error {
  background-color: #f2dede;
  color: #a94442;
  border: 1px solid #ebcccc;
}

.check-msg.macro {
  background-color: #d7dac2;
  color: #4f5c6d;
  border: 1px solid #d7dac2;
}

.check-msg.note {
  background-color: #d7d7d7;
  color: #4f5c6d;
  border: 1px solid #bfbfbf;
}

.check-msg.current {
  border: 2px dashed #3692ff;
}

.check-msg .tag {
  padding: 1px 5px;
  text-align: center;
  border-radius: 2px;
  margin-right: 5px;
  text-decoration: inherit;
}

.check-msg .tag.macro {
  background-color: #83876a;
  color: white;
  text-transform: capitalize;
}

.check-msg .tag.note {
  background-color: #9299a1;
  color: white;
  text-transform: capitalize;
}

.checker-enum {
  color: white;
  padding: 1px 5px;
  text-align: center;
  border-radius: 25px;
  margin-right: 5px;
  text-decoration: inherit;
}

.checker-enum.info {
  background-color: #427ea9;
}

.checker-enum.error {
  background-color: #a94442;
}

.arrow {
  border: solid black;
  border-width: 0 3px 3px 0;
  display: inline-block;
  padding: 3px;
  cursor: pointer;
  margin: 0px 5px;
}

.arrow:hover {
  border: solid #437ea8;
  border-width: 0 3px 3px 0;
}

.left-arrow {
  transform: rotate(135deg);
  -webkit-transform: rotate(135deg);
}

.right-arrow {
  transform: rotate(-45deg);
  -webkit-transform: rotate(-45deg);
}

    </style>

    <script type="text/javascript">
      function setNonCompatibleBrowserMessage() {
  document.body.innerHTML =
    '<h2 style="margin-left: 20px;">Your browser is not compatible with CodeChecker Viewer!</h2> \
     <p style="margin-left: 20px;">The version required for the following browsers are:</p> \
     <ul style="margin-left: 20px;"> \
     <li>Internet Explorer: version 9 or newer</li> \
     <li>Firefox: version 22.0 or newer</li> \
     </ul>';
}

// http://stackoverflow.com/questions/5916900/how-can-you-detect-the-version-of-a-browser
var browserVersion = (function(){
  var ua = navigator.userAgent, tem,
    M = ua.match(/(opera|chrome|safari|firefox|msie|trident(?=\/))\/?\s*(\d+)/i) || [];

  if (/trident/i.test(M[1])) {
    tem = /\brv[ :]+(\d+)/g.exec(ua) || [];
    return 'IE ' + (tem[1] || '');
  }

  if (M[1] === 'Chrome') {
    tem = ua.match(/\b(OPR|Edge)\/(\d+)/);
    if (tem != null) return tem.slice(1).join(' ').replace('OPR', 'Opera');
  }

  M = M[2] ? [M[1], M[2]] : [navigator.appName, navigator.appVersion, '-?'];
  if ((tem = ua.match(/version\/(\d+)/i)) != null) M.splice(1, 1, tem[1]);
    return M.join(' ');
})();

var pos = browserVersion.indexOf(' ');
var browser = browserVersion.substr(0, pos);
var version = parseInt(browserVersion.substr(pos + 1));

var browserCompatible
  = browser === 'Firefox'
  ? version >= 22
  : browser === 'IE'
  ? version >= 9
  : true;


      /* MIT License

Copyright (C) 2017 by Marijn Haverbeke <marijnh@gmail.com> and others

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
 */
      !function(e,t){"object"==typeof exports&&"undefined"!=typeof module?module.exports=t():"function"==typeof define&&define.amd?define(t):e.CodeMirror=t()}(this,function(){"use strict";function e(e){return new RegExp("(^|\\s)"+e+"(?:$|\\s)\\s*")}function t(e){for(var t=e.childNodes.length;t>0;--t)e.removeChild(e.firstChild);return e}function r(e,r){return t(e).appendChild(r)}function n(e,t,r,n){var i=document.createElement(e);if(r&&(i.className=r),n&&(i.style.cssText=n),"string"==typeof t)i.appendChild(document.createTextNode(t));else if(t)for(var o=0;o<t.length;++o)i.appendChild(t[o]);return i}function i(e,t,r,i){var o=n(e,t,r,i);return o.setAttribute("role","presentation"),o}function o(e,t){if(3==t.nodeType&&(t=t.parentNode),e.contains)return e.contains(t);do{if(11==t.nodeType&&(t=t.host),t==e)return!0}while(t=t.parentNode)}function l(){var e;try{e=document.activeElement}catch(t){e=document.body||null}for(;e&&e.shadowRoot&&e.shadowRoot.activeElement;)e=e.shadowRoot.activeElement;return e}function s(t,r){var n=t.className;e(r).test(n)||(t.className+=(n?" ":"")+r)}function a(t,r){for(var n=t.split(" "),i=0;i<n.length;i++)n[i]&&!e(n[i]).test(r)&&(r+=" "+n[i]);return r}function u(e){var t=Array.prototype.slice.call(arguments,1);return function(){return e.apply(null,t)}}function c(e,t,r){t||(t={});for(var n in e)!e.hasOwnProperty(n)||!1===r&&t.hasOwnProperty(n)||(t[n]=e[n]);return t}function f(e,t,r,n,i){null==t&&-1==(t=e.search(/[^\s\u00a0]/))&&(t=e.length);for(var o=n||0,l=i||0;;){var s=e.indexOf("\t",o);if(s<0||s>=t)return l+(t-o);l+=s-o,l+=r-l%r,o=s+1}}function h(e,t){for(var r=0;r<e.length;++r)if(e[r]==t)return r;return-1}function d(e,t,r){for(var n=0,i=0;;){var o=e.indexOf("\t",n);-1==o&&(o=e.length);var l=o-n;if(o==e.length||i+l>=t)return n+Math.min(l,t-i);if(i+=o-n,i+=r-i%r,n=o+1,i>=t)return n}}function p(e){for(;Kl.length<=e;)Kl.push(g(Kl)+" ");return Kl[e]}function g(e){return e[e.length-1]}function v(e,t){for(var r=[],n=0;n<e.length;n++)r[n]=t(e[n],n);return r}function m(e,t,r){for(var n=0,i=r(t);n<e.length&&r(e[n])<=i;)n++;e.splice(n,0,t)}function y(){}function b(e,t){var r;return Object.create?r=Object.create(e):(y.prototype=e,r=new y),t&&c(t,r),r}function w(e){return/\w/.test(e)||e>""&&(e.toUpperCase()!=e.toLowerCase()||jl.test(e))}function x(e,t){return t?!!(t.source.indexOf("\\w")>-1&&w(e))||t.test(e):w(e)}function C(e){for(var t in e)if(e.hasOwnProperty(t)&&e[t])return!1;return!0}function S(e){return e.charCodeAt(0)>=768&&Xl.test(e)}function L(e,t,r){for(;(r<0?t>0:t<e.length)&&S(e.charAt(t));)t+=r;return t}function k(e,t,r){for(var n=t>r?-1:1;;){if(t==r)return t;var i=(t+r)/2,o=n<0?Math.ceil(i):Math.floor(i);if(o==t)return e(o)?t:r;e(o)?r=o:t=o+n}}function T(e,t,r){var o=this;this.input=r,o.scrollbarFiller=n("div",null,"CodeMirror-scrollbar-filler"),o.scrollbarFiller.setAttribute("cm-not-content","true"),o.gutterFiller=n("div",null,"CodeMirror-gutter-filler"),o.gutterFiller.setAttribute("cm-not-content","true"),o.lineDiv=i("div",null,"CodeMirror-code"),o.selectionDiv=n("div",null,null,"position: relative; z-index: 1"),o.cursorDiv=n("div",null,"CodeMirror-cursors"),o.measure=n("div",null,"CodeMirror-measure"),o.lineMeasure=n("div",null,"CodeMirror-measure"),o.lineSpace=i("div",[o.measure,o.lineMeasure,o.selectionDiv,o.cursorDiv,o.lineDiv],null,"position: relative; outline: none");var l=i("div",[o.lineSpace],"CodeMirror-lines");o.mover=n("div",[l],null,"position: relative"),o.sizer=n("div",[o.mover],"CodeMirror-sizer"),o.sizerWidth=null,o.heightForcer=n("div",null,null,"position: absolute; height: "+Rl+"px; width: 1px;"),o.gutters=n("div",null,"CodeMirror-gutters"),o.lineGutter=null,o.scroller=n("div",[o.sizer,o.heightForcer,o.gutters],"CodeMirror-scroll"),o.scroller.setAttribute("tabIndex","-1"),o.wrapper=n("div",[o.scrollbarFiller,o.gutterFiller,o.scroller],"CodeMirror"),gl&&vl<8&&(o.gutters.style.zIndex=-1,o.scroller.style.paddingRight=0),ml||fl&&Tl||(o.scroller.draggable=!0),e&&(e.appendChild?e.appendChild(o.wrapper):e(o.wrapper)),o.viewFrom=o.viewTo=t.first,o.reportedViewFrom=o.reportedViewTo=t.first,o.view=[],o.renderedView=null,o.externalMeasured=null,o.viewOffset=0,o.lastWrapHeight=o.lastWrapWidth=0,o.updateLineNumbers=null,o.nativeBarWidth=o.barHeight=o.barWidth=0,o.scrollbarsClipped=!1,o.lineNumWidth=o.lineNumInnerWidth=o.lineNumChars=null,o.alignWidgets=!1,o.cachedCharWidth=o.cachedTextHeight=o.cachedPaddingH=null,o.maxLine=null,o.maxLineLength=0,o.maxLineChanged=!1,o.wheelDX=o.wheelDY=o.wheelStartX=o.wheelStartY=null,o.shift=!1,o.selForContextMenu=null,o.activeTouch=null,r.init(o)}function M(e,t){if((t-=e.first)<0||t>=e.size)throw new Error("There is no line "+(t+e.first)+" in the document.");for(var r=e;!r.lines;)for(var n=0;;++n){var i=r.children[n],o=i.chunkSize();if(t<o){r=i;break}t-=o}return r.lines[t]}function N(e,t,r){var n=[],i=t.line;return e.iter(t.line,r.line+1,function(e){var o=e.text;i==r.line&&(o=o.slice(0,r.ch)),i==t.line&&(o=o.slice(t.ch)),n.push(o),++i}),n}function O(e,t,r){var n=[];return e.iter(t,r,function(e){n.push(e.text)}),n}function A(e,t){var r=t-e.height;if(r)for(var n=e;n;n=n.parent)n.height+=r}function W(e){if(null==e.parent)return null;for(var t=e.parent,r=h(t.lines,e),n=t.parent;n;t=n,n=n.parent)for(var i=0;n.children[i]!=t;++i)r+=n.children[i].chunkSize();return r+t.first}function D(e,t){var r=e.first;e:do{for(var n=0;n<e.children.length;++n){var i=e.children[n],o=i.height;if(t<o){e=i;continue e}t-=o,r+=i.chunkSize()}return r}while(!e.lines);for(var l=0;l<e.lines.length;++l){var s=e.lines[l].height;if(t<s)break;t-=s}return r+l}function H(e,t){return t>=e.first&&t<e.first+e.size}function F(e,t){return String(e.lineNumberFormatter(t+e.firstLineNumber))}function E(e,t,r){if(void 0===r&&(r=null),!(this instanceof E))return new E(e,t,r);this.line=e,this.ch=t,this.sticky=r}function P(e,t){return e.line-t.line||e.ch-t.ch}function I(e,t){return e.sticky==t.sticky&&0==P(e,t)}function z(e){return E(e.line,e.ch)}function R(e,t){return P(e,t)<0?t:e}function B(e,t){return P(e,t)<0?e:t}function G(e,t){return Math.max(e.first,Math.min(t,e.first+e.size-1))}function U(e,t){if(t.line<e.first)return E(e.first,0);var r=e.first+e.size-1;return t.line>r?E(r,M(e,r).text.length):V(t,M(e,t.line).text.length)}function V(e,t){var r=e.ch;return null==r||r>t?E(e.line,t):r<0?E(e.line,0):e}function K(e,t){for(var r=[],n=0;n<t.length;n++)r[n]=U(e,t[n]);return r}function j(){Yl=!0}function X(){_l=!0}function Y(e,t,r){this.marker=e,this.from=t,this.to=r}function _(e,t){if(e)for(var r=0;r<e.length;++r){var n=e[r];if(n.marker==t)return n}}function $(e,t){for(var r,n=0;n<e.length;++n)e[n]!=t&&(r||(r=[])).push(e[n]);return r}function q(e,t){e.markedSpans=e.markedSpans?e.markedSpans.concat([t]):[t],t.marker.attachLine(e)}function Z(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t)||o.from==t&&"bookmark"==l.type&&(!r||!o.marker.insertLeft)){var s=null==o.to||(l.inclusiveRight?o.to>=t:o.to>t);(n||(n=[])).push(new Y(l,o.from,s?null:o.to))}}return n}function Q(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.to||(l.inclusiveRight?o.to>=t:o.to>t)||o.from==t&&"bookmark"==l.type&&(!r||o.marker.insertLeft)){var s=null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t);(n||(n=[])).push(new Y(l,s?null:o.from-t,null==o.to?null:o.to-t))}}return n}function J(e,t){if(t.full)return null;var r=H(e,t.from.line)&&M(e,t.from.line).markedSpans,n=H(e,t.to.line)&&M(e,t.to.line).markedSpans;if(!r&&!n)return null;var i=t.from.ch,o=t.to.ch,l=0==P(t.from,t.to),s=Z(r,i,l),a=Q(n,o,l),u=1==t.text.length,c=g(t.text).length+(u?i:0);if(s)for(var f=0;f<s.length;++f){var h=s[f];if(null==h.to){var d=_(a,h.marker);d?u&&(h.to=null==d.to?null:d.to+c):h.to=i}}if(a)for(var p=0;p<a.length;++p){var v=a[p];null!=v.to&&(v.to+=c),null==v.from?_(s,v.marker)||(v.from=c,u&&(s||(s=[])).push(v)):(v.from+=c,u&&(s||(s=[])).push(v))}s&&(s=ee(s)),a&&a!=s&&(a=ee(a));var m=[s];if(!u){var y,b=t.text.length-2;if(b>0&&s)for(var w=0;w<s.length;++w)null==s[w].to&&(y||(y=[])).push(new Y(s[w].marker,null,null));for(var x=0;x<b;++x)m.push(y);m.push(a)}return m}function ee(e){for(var t=0;t<e.length;++t){var r=e[t];null!=r.from&&r.from==r.to&&!1!==r.marker.clearWhenEmpty&&e.splice(t--,1)}return e.length?e:null}function te(e,t,r){var n=null;if(e.iter(t.line,r.line+1,function(e){if(e.markedSpans)for(var t=0;t<e.markedSpans.length;++t){var r=e.markedSpans[t].marker;!r.readOnly||n&&-1!=h(n,r)||(n||(n=[])).push(r)}}),!n)return null;for(var i=[{from:t,to:r}],o=0;o<n.length;++o)for(var l=n[o],s=l.find(0),a=0;a<i.length;++a){var u=i[a];if(!(P(u.to,s.from)<0||P(u.from,s.to)>0)){var c=[a,1],f=P(u.from,s.from),d=P(u.to,s.to);(f<0||!l.inclusiveLeft&&!f)&&c.push({from:u.from,to:s.from}),(d>0||!l.inclusiveRight&&!d)&&c.push({from:s.to,to:u.to}),i.splice.apply(i,c),a+=c.length-3}}return i}function re(e){var t=e.markedSpans;if(t){for(var r=0;r<t.length;++r)t[r].marker.detachLine(e);e.markedSpans=null}}function ne(e,t){if(t){for(var r=0;r<t.length;++r)t[r].marker.attachLine(e);e.markedSpans=t}}function ie(e){return e.inclusiveLeft?-1:0}function oe(e){return e.inclusiveRight?1:0}function le(e,t){var r=e.lines.length-t.lines.length;if(0!=r)return r;var n=e.find(),i=t.find(),o=P(n.from,i.from)||ie(e)-ie(t);if(o)return-o;var l=P(n.to,i.to)||oe(e)-oe(t);return l||t.id-e.id}function se(e,t){var r,n=_l&&e.markedSpans;if(n)for(var i=void 0,o=0;o<n.length;++o)(i=n[o]).marker.collapsed&&null==(t?i.from:i.to)&&(!r||le(r,i.marker)<0)&&(r=i.marker);return r}function ae(e){return se(e,!0)}function ue(e){return se(e,!1)}function ce(e,t,r,n,i){var o=M(e,t),l=_l&&o.markedSpans;if(l)for(var s=0;s<l.length;++s){var a=l[s];if(a.marker.collapsed){var u=a.marker.find(0),c=P(u.from,r)||ie(a.marker)-ie(i),f=P(u.to,n)||oe(a.marker)-oe(i);if(!(c>=0&&f<=0||c<=0&&f>=0)&&(c<=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.to,r)>=0:P(u.to,r)>0)||c>=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.from,n)<=0:P(u.from,n)<0)))return!0}}}function fe(e){for(var t;t=ae(e);)e=t.find(-1,!0).line;return e}function he(e){for(var t;t=ue(e);)e=t.find(1,!0).line;return e}function de(e){for(var t,r;t=ue(e);)e=t.find(1,!0).line,(r||(r=[])).push(e);return r}function pe(e,t){var r=M(e,t),n=fe(r);return r==n?t:W(n)}function ge(e,t){if(t>e.lastLine())return t;var r,n=M(e,t);if(!ve(e,n))return t;for(;r=ue(n);)n=r.find(1,!0).line;return W(n)+1}function ve(e,t){var r=_l&&t.markedSpans;if(r)for(var n=void 0,i=0;i<r.length;++i)if((n=r[i]).marker.collapsed){if(null==n.from)return!0;if(!n.marker.widgetNode&&0==n.from&&n.marker.inclusiveLeft&&me(e,t,n))return!0}}function me(e,t,r){if(null==r.to){var n=r.marker.find(1,!0);return me(e,n.line,_(n.line.markedSpans,r.marker))}if(r.marker.inclusiveRight&&r.to==t.text.length)return!0;for(var i=void 0,o=0;o<t.markedSpans.length;++o)if((i=t.markedSpans[o]).marker.collapsed&&!i.marker.widgetNode&&i.from==r.to&&(null==i.to||i.to!=r.from)&&(i.marker.inclusiveLeft||r.marker.inclusiveRight)&&me(e,t,i))return!0}function ye(e){for(var t=0,r=(e=fe(e)).parent,n=0;n<r.lines.length;++n){var i=r.lines[n];if(i==e)break;t+=i.height}for(var o=r.parent;o;r=o,o=r.parent)for(var l=0;l<o.children.length;++l){var s=o.children[l];if(s==r)break;t+=s.height}return t}function be(e){if(0==e.height)return 0;for(var t,r=e.text.length,n=e;t=ae(n);){var i=t.find(0,!0);n=i.from.line,r+=i.from.ch-i.to.ch}for(n=e;t=ue(n);){var o=t.find(0,!0);r-=n.text.length-o.from.ch,r+=(n=o.to.line).text.length-o.to.ch}return r}function we(e){var t=e.display,r=e.doc;t.maxLine=M(r,r.first),t.maxLineLength=be(t.maxLine),t.maxLineChanged=!0,r.iter(function(e){var r=be(e);r>t.maxLineLength&&(t.maxLineLength=r,t.maxLine=e)})}function xe(e,t,r,n){if(!e)return n(t,r,"ltr",0);for(var i=!1,o=0;o<e.length;++o){var l=e[o];(l.from<r&&l.to>t||t==r&&l.to==t)&&(n(Math.max(l.from,t),Math.min(l.to,r),1==l.level?"rtl":"ltr",o),i=!0)}i||n(t,r,"ltr")}function Ce(e,t,r){var n;$l=null;for(var i=0;i<e.length;++i){var o=e[i];if(o.from<t&&o.to>t)return i;o.to==t&&(o.from!=o.to&&"before"==r?n=i:$l=i),o.from==t&&(o.from!=o.to&&"before"!=r?n=i:$l=i)}return null!=n?n:$l}function Se(e,t){var r=e.order;return null==r&&(r=e.order=ql(e.text,t)),r}function Le(e,t){return e._handlers&&e._handlers[t]||Zl}function ke(e,t,r){if(e.removeEventListener)e.removeEventListener(t,r,!1);else if(e.detachEvent)e.detachEvent("on"+t,r);else{var n=e._handlers,i=n&&n[t];if(i){var o=h(i,r);o>-1&&(n[t]=i.slice(0,o).concat(i.slice(o+1)))}}}function Te(e,t){var r=Le(e,t);if(r.length)for(var n=Array.prototype.slice.call(arguments,2),i=0;i<r.length;++i)r[i].apply(null,n)}function Me(e,t,r){return"string"==typeof t&&(t={type:t,preventDefault:function(){this.defaultPrevented=!0}}),Te(e,r||t.type,e,t),He(t)||t.codemirrorIgnore}function Ne(e){var t=e._handlers&&e._handlers.cursorActivity;if(t)for(var r=e.curOp.cursorActivityHandlers||(e.curOp.cursorActivityHandlers=[]),n=0;n<t.length;++n)-1==h(r,t[n])&&r.push(t[n])}function Oe(e,t){return Le(e,t).length>0}function Ae(e){e.prototype.on=function(e,t){Ql(this,e,t)},e.prototype.off=function(e,t){ke(this,e,t)}}function We(e){e.preventDefault?e.preventDefault():e.returnValue=!1}function De(e){e.stopPropagation?e.stopPropagation():e.cancelBubble=!0}function He(e){return null!=e.defaultPrevented?e.defaultPrevented:0==e.returnValue}function Fe(e){We(e),De(e)}function Ee(e){return e.target||e.srcElement}function Pe(e){var t=e.which;return null==t&&(1&e.button?t=1:2&e.button?t=3:4&e.button&&(t=2)),Ml&&e.ctrlKey&&1==t&&(t=3),t}function Ie(e){if(null==Il){var t=n("span","​");r(e,n("span",[t,document.createTextNode("x")])),0!=e.firstChild.offsetHeight&&(Il=t.offsetWidth<=1&&t.offsetHeight>2&&!(gl&&vl<8))}var i=Il?n("span","​"):n("span"," ",null,"display: inline-block; width: 1px; margin-right: -1px");return i.setAttribute("cm-text",""),i}function ze(e){if(null!=zl)return zl;var n=r(e,document.createTextNode("AخA")),i=Wl(n,0,1).getBoundingClientRect(),o=Wl(n,1,2).getBoundingClientRect();return t(e),!(!i||i.left==i.right)&&(zl=o.right-i.right<3)}function Re(e){if(null!=ns)return ns;var t=r(e,n("span","x")),i=t.getBoundingClientRect(),o=Wl(t,0,1).getBoundingClientRect();return ns=Math.abs(i.left-o.left)>1}function Be(e,t){arguments.length>2&&(t.dependencies=Array.prototype.slice.call(arguments,2)),is[e]=t}function Ge(e){if("string"==typeof e&&os.hasOwnProperty(e))e=os[e];else if(e&&"string"==typeof e.name&&os.hasOwnProperty(e.name)){var t=os[e.name];"string"==typeof t&&(t={name:t}),(e=b(t,e)).name=t.name}else{if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+xml$/.test(e))return Ge("application/xml");if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+json$/.test(e))return Ge("application/json")}return"string"==typeof e?{name:e}:e||{name:"null"}}function Ue(e,t){t=Ge(t);var r=is[t.name];if(!r)return Ue(e,"text/plain");var n=r(e,t);if(ls.hasOwnProperty(t.name)){var i=ls[t.name];for(var o in i)i.hasOwnProperty(o)&&(n.hasOwnProperty(o)&&(n["_"+o]=n[o]),n[o]=i[o])}if(n.name=t.name,t.helperType&&(n.helperType=t.helperType),t.modeProps)for(var l in t.modeProps)n[l]=t.modeProps[l];return n}function Ve(e,t){c(t,ls.hasOwnProperty(e)?ls[e]:ls[e]={})}function Ke(e,t){if(!0===t)return t;if(e.copyState)return e.copyState(t);var r={};for(var n in t){var i=t[n];i instanceof Array&&(i=i.concat([])),r[n]=i}return r}function je(e,t){for(var r;e.innerMode&&(r=e.innerMode(t))&&r.mode!=e;)t=r.state,e=r.mode;return r||{mode:e,state:t}}function Xe(e,t,r){return!e.startState||e.startState(t,r)}function Ye(e,t,r,n){var i=[e.state.modeGen],o={};tt(e,t.text,e.doc.mode,r,function(e,t){return i.push(e,t)},o,n);for(var l=r.state,s=0;s<e.state.overlays.length;++s)!function(n){var l=e.state.overlays[n],s=1,a=0;r.state=!0,tt(e,t.text,l.mode,r,function(e,t){for(var r=s;a<e;){var n=i[s];n>e&&i.splice(s,1,e,i[s+1],n),s+=2,a=Math.min(e,n)}if(t)if(l.opaque)i.splice(r,s-r,e,"overlay "+t),s=r+2;else for(;r<s;r+=2){var o=i[r+1];i[r+1]=(o?o+" ":"")+"overlay "+t}},o)}(s);return r.state=l,{styles:i,classes:o.bgClass||o.textClass?o:null}}function _e(e,t,r){if(!t.styles||t.styles[0]!=e.state.modeGen){var n=$e(e,W(t)),i=t.text.length>e.options.maxHighlightLength&&Ke(e.doc.mode,n.state),o=Ye(e,t,n);i&&(n.state=i),t.stateAfter=n.save(!i),t.styles=o.styles,o.classes?t.styleClasses=o.classes:t.styleClasses&&(t.styleClasses=null),r===e.doc.highlightFrontier&&(e.doc.modeFrontier=Math.max(e.doc.modeFrontier,++e.doc.highlightFrontier))}return t.styles}function $e(e,t,r){var n=e.doc,i=e.display;if(!n.mode.startState)return new us(n,!0,t);var o=rt(e,t,r),l=o>n.first&&M(n,o-1).stateAfter,s=l?us.fromSaved(n,l,o):new us(n,Xe(n.mode),o);return n.iter(o,t,function(r){qe(e,r.text,s);var n=s.line;r.stateAfter=n==t-1||n%5==0||n>=i.viewFrom&&n<i.viewTo?s.save():null,s.nextLine()}),r&&(n.modeFrontier=s.line),s}function qe(e,t,r,n){var i=e.doc.mode,o=new ss(t,e.options.tabSize,r);for(o.start=o.pos=n||0,""==t&&Ze(i,r.state);!o.eol();)Qe(i,o,r.state),o.start=o.pos}function Ze(e,t){if(e.blankLine)return e.blankLine(t);if(e.innerMode){var r=je(e,t);return r.mode.blankLine?r.mode.blankLine(r.state):void 0}}function Qe(e,t,r,n){for(var i=0;i<10;i++){n&&(n[0]=je(e,r).mode);var o=e.token(t,r);if(t.pos>t.start)return o}throw new Error("Mode "+e.name+" failed to advance stream.")}function Je(e,t,r,n){var i,o,l=e.doc,s=l.mode,a=M(l,(t=U(l,t)).line),u=$e(e,t.line,r),c=new ss(a.text,e.options.tabSize,u);for(n&&(o=[]);(n||c.pos<t.ch)&&!c.eol();)c.start=c.pos,i=Qe(s,c,u.state),n&&o.push(new cs(c,i,Ke(l.mode,u.state)));return n?o:new cs(c,i,u.state)}function et(e,t){if(e)for(;;){var r=e.match(/(?:^|\s+)line-(background-)?(\S+)/);if(!r)break;e=e.slice(0,r.index)+e.slice(r.index+r[0].length);var n=r[1]?"bgClass":"textClass";null==t[n]?t[n]=r[2]:new RegExp("(?:^|s)"+r[2]+"(?:$|s)").test(t[n])||(t[n]+=" "+r[2])}return e}function tt(e,t,r,n,i,o,l){var s=r.flattenSpans;null==s&&(s=e.options.flattenSpans);var a,u=0,c=null,f=new ss(t,e.options.tabSize,n),h=e.options.addModeClass&&[null];for(""==t&&et(Ze(r,n.state),o);!f.eol();){if(f.pos>e.options.maxHighlightLength?(s=!1,l&&qe(e,t,n,f.pos),f.pos=t.length,a=null):a=et(Qe(r,f,n.state,h),o),h){var d=h[0].name;d&&(a="m-"+(a?d+" "+a:d))}if(!s||c!=a){for(;u<f.start;)i(u=Math.min(f.start,u+5e3),c);c=a}f.start=f.pos}for(;u<f.pos;){var p=Math.min(f.pos,u+5e3);i(p,c),u=p}}function rt(e,t,r){for(var n,i,o=e.doc,l=r?-1:t-(e.doc.mode.innerMode?1e3:100),s=t;s>l;--s){if(s<=o.first)return o.first;var a=M(o,s-1),u=a.stateAfter;if(u&&(!r||s+(u instanceof as?u.lookAhead:0)<=o.modeFrontier))return s;var c=f(a.text,null,e.options.tabSize);(null==i||n>c)&&(i=s-1,n=c)}return i}function nt(e,t){if(e.modeFrontier=Math.min(e.modeFrontier,t),!(e.highlightFrontier<t-10)){for(var r=e.first,n=t-1;n>r;n--){var i=M(e,n).stateAfter;if(i&&(!(i instanceof as)||n+i.lookAhead<t)){r=n+1;break}}e.highlightFrontier=Math.min(e.highlightFrontier,r)}}function it(e,t,r,n){e.text=t,e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null),null!=e.order&&(e.order=null),re(e),ne(e,r);var i=n?n(e):1;i!=e.height&&A(e,i)}function ot(e){e.parent=null,re(e)}function lt(e,t){if(!e||/^\s*$/.test(e))return null;var r=t.addModeClass?ps:ds;return r[e]||(r[e]=e.replace(/\S+/g,"cm-$&"))}function st(e,t){var r=i("span",null,null,ml?"padding-right: .1px":null),n={pre:i("pre",[r],"CodeMirror-line"),content:r,col:0,pos:0,cm:e,trailingSpace:!1,splitSpaces:(gl||ml)&&e.getOption("lineWrapping")};t.measure={};for(var o=0;o<=(t.rest?t.rest.length:0);o++){var l=o?t.rest[o-1]:t.line,s=void 0;n.pos=0,n.addToken=ut,ze(e.display.measure)&&(s=Se(l,e.doc.direction))&&(n.addToken=ft(n.addToken,s)),n.map=[],dt(l,n,_e(e,l,t!=e.display.externalMeasured&&W(l))),l.styleClasses&&(l.styleClasses.bgClass&&(n.bgClass=a(l.styleClasses.bgClass,n.bgClass||"")),l.styleClasses.textClass&&(n.textClass=a(l.styleClasses.textClass,n.textClass||""))),0==n.map.length&&n.map.push(0,0,n.content.appendChild(Ie(e.display.measure))),0==o?(t.measure.map=n.map,t.measure.cache={}):((t.measure.maps||(t.measure.maps=[])).push(n.map),(t.measure.caches||(t.measure.caches=[])).push({}))}if(ml){var u=n.content.lastChild;(/\bcm-tab\b/.test(u.className)||u.querySelector&&u.querySelector(".cm-tab"))&&(n.content.className="cm-tab-wrap-hack")}return Te(e,"renderLine",e,t.line,n.pre),n.pre.className&&(n.textClass=a(n.pre.className,n.textClass||"")),n}function at(e){var t=n("span","•","cm-invalidchar");return t.title="\\u"+e.charCodeAt(0).toString(16),t.setAttribute("aria-label",t.title),t}function ut(e,t,r,i,o,l,s){if(t){var a,u=e.splitSpaces?ct(t,e.trailingSpace):t,c=e.cm.state.specialChars,f=!1;if(c.test(t)){a=document.createDocumentFragment();for(var h=0;;){c.lastIndex=h;var d=c.exec(t),g=d?d.index-h:t.length-h;if(g){var v=document.createTextNode(u.slice(h,h+g));gl&&vl<9?a.appendChild(n("span",[v])):a.appendChild(v),e.map.push(e.pos,e.pos+g,v),e.col+=g,e.pos+=g}if(!d)break;h+=g+1;var m=void 0;if("\t"==d[0]){var y=e.cm.options.tabSize,b=y-e.col%y;(m=a.appendChild(n("span",p(b),"cm-tab"))).setAttribute("role","presentation"),m.setAttribute("cm-text","\t"),e.col+=b}else"\r"==d[0]||"\n"==d[0]?((m=a.appendChild(n("span","\r"==d[0]?"␍":"␤","cm-invalidchar"))).setAttribute("cm-text",d[0]),e.col+=1):((m=e.cm.options.specialCharPlaceholder(d[0])).setAttribute("cm-text",d[0]),gl&&vl<9?a.appendChild(n("span",[m])):a.appendChild(m),e.col+=1);e.map.push(e.pos,e.pos+1,m),e.pos++}}else e.col+=t.length,a=document.createTextNode(u),e.map.push(e.pos,e.pos+t.length,a),gl&&vl<9&&(f=!0),e.pos+=t.length;if(e.trailingSpace=32==u.charCodeAt(t.length-1),r||i||o||f||s){var w=r||"";i&&(w+=i),o&&(w+=o);var x=n("span",[a],w,s);return l&&(x.title=l),e.content.appendChild(x)}e.content.appendChild(a)}}function ct(e,t){if(e.length>1&&!/  /.test(e))return e;for(var r=t,n="",i=0;i<e.length;i++){var o=e.charAt(i);" "!=o||!r||i!=e.length-1&&32!=e.charCodeAt(i+1)||(o=" "),n+=o,r=" "==o}return n}function ft(e,t){return function(r,n,i,o,l,s,a){i=i?i+" cm-force-border":"cm-force-border";for(var u=r.pos,c=u+n.length;;){for(var f=void 0,h=0;h<t.length&&!((f=t[h]).to>u&&f.from<=u);h++);if(f.to>=c)return e(r,n,i,o,l,s,a);e(r,n.slice(0,f.to-u),i,o,null,s,a),o=null,n=n.slice(f.to-u),u=f.to}}}function ht(e,t,r,n){var i=!n&&r.widgetNode;i&&e.map.push(e.pos,e.pos+t,i),!n&&e.cm.display.input.needsContentAttribute&&(i||(i=e.content.appendChild(document.createElement("span"))),i.setAttribute("cm-marker",r.id)),i&&(e.cm.display.input.setUneditable(i),e.content.appendChild(i)),e.pos+=t,e.trailingSpace=!1}function dt(e,t,r){var n=e.markedSpans,i=e.text,o=0;if(n)for(var l,s,a,u,c,f,h,d=i.length,p=0,g=1,v="",m=0;;){if(m==p){a=u=c=f=s="",h=null,m=1/0;for(var y=[],b=void 0,w=0;w<n.length;++w){var x=n[w],C=x.marker;"bookmark"==C.type&&x.from==p&&C.widgetNode?y.push(C):x.from<=p&&(null==x.to||x.to>p||C.collapsed&&x.to==p&&x.from==p)?(null!=x.to&&x.to!=p&&m>x.to&&(m=x.to,u=""),C.className&&(a+=" "+C.className),C.css&&(s=(s?s+";":"")+C.css),C.startStyle&&x.from==p&&(c+=" "+C.startStyle),C.endStyle&&x.to==m&&(b||(b=[])).push(C.endStyle,x.to),C.title&&!f&&(f=C.title),C.collapsed&&(!h||le(h.marker,C)<0)&&(h=x)):x.from>p&&m>x.from&&(m=x.from)}if(b)for(var S=0;S<b.length;S+=2)b[S+1]==m&&(u+=" "+b[S]);if(!h||h.from==p)for(var L=0;L<y.length;++L)ht(t,0,y[L]);if(h&&(h.from||0)==p){if(ht(t,(null==h.to?d+1:h.to)-p,h.marker,null==h.from),null==h.to)return;h.to==p&&(h=!1)}}if(p>=d)break;for(var k=Math.min(d,m);;){if(v){var T=p+v.length;if(!h){var M=T>k?v.slice(0,k-p):v;t.addToken(t,M,l?l+a:a,c,p+M.length==m?u:"",f,s)}if(T>=k){v=v.slice(k-p),p=k;break}p=T,c=""}v=i.slice(o,o=r[g++]),l=lt(r[g++],t.cm.options)}}else for(var N=1;N<r.length;N+=2)t.addToken(t,i.slice(o,o=r[N]),lt(r[N+1],t.cm.options))}function pt(e,t,r){this.line=t,this.rest=de(t),this.size=this.rest?W(g(this.rest))-r+1:1,this.node=this.text=null,this.hidden=ve(e,t)}function gt(e,t,r){for(var n,i=[],o=t;o<r;o=n){var l=new pt(e.doc,M(e.doc,o),o);n=o+l.size,i.push(l)}return i}function vt(e){gs?gs.ops.push(e):e.ownsGroup=gs={ops:[e],delayedCallbacks:[]}}function mt(e){var t=e.delayedCallbacks,r=0;do{for(;r<t.length;r++)t[r].call(null);for(var n=0;n<e.ops.length;n++){var i=e.ops[n];if(i.cursorActivityHandlers)for(;i.cursorActivityCalled<i.cursorActivityHandlers.length;)i.cursorActivityHandlers[i.cursorActivityCalled++].call(null,i.cm)}}while(r<t.length)}function yt(e,t){var r=e.ownsGroup;if(r)try{mt(r)}finally{gs=null,t(r)}}function bt(e,t){var r=Le(e,t);if(r.length){var n,i=Array.prototype.slice.call(arguments,2);gs?n=gs.delayedCallbacks:vs?n=vs:(n=vs=[],setTimeout(wt,0));for(var o=0;o<r.length;++o)!function(e){n.push(function(){return r[e].apply(null,i)})}(o)}}function wt(){var e=vs;vs=null;for(var t=0;t<e.length;++t)e[t]()}function xt(e,t,r,n){for(var i=0;i<t.changes.length;i++){var o=t.changes[i];"text"==o?kt(e,t):"gutter"==o?Mt(e,t,r,n):"class"==o?Tt(e,t):"widget"==o&&Nt(e,t,n)}t.changes=null}function Ct(e){return e.node==e.text&&(e.node=n("div",null,null,"position: relative"),e.text.parentNode&&e.text.parentNode.replaceChild(e.node,e.text),e.node.appendChild(e.text),gl&&vl<8&&(e.node.style.zIndex=2)),e.node}function St(e,t){var r=t.bgClass?t.bgClass+" "+(t.line.bgClass||""):t.line.bgClass;if(r&&(r+=" CodeMirror-linebackground"),t.background)r?t.background.className=r:(t.background.parentNode.removeChild(t.background),t.background=null);else if(r){var i=Ct(t);t.background=i.insertBefore(n("div",null,r),i.firstChild),e.display.input.setUneditable(t.background)}}function Lt(e,t){var r=e.display.externalMeasured;return r&&r.line==t.line?(e.display.externalMeasured=null,t.measure=r.measure,r.built):st(e,t)}function kt(e,t){var r=t.text.className,n=Lt(e,t);t.text==t.node&&(t.node=n.pre),t.text.parentNode.replaceChild(n.pre,t.text),t.text=n.pre,n.bgClass!=t.bgClass||n.textClass!=t.textClass?(t.bgClass=n.bgClass,t.textClass=n.textClass,Tt(e,t)):r&&(t.text.className=r)}function Tt(e,t){St(e,t),t.line.wrapClass?Ct(t).className=t.line.wrapClass:t.node!=t.text&&(t.node.className="");var r=t.textClass?t.textClass+" "+(t.line.textClass||""):t.line.textClass;t.text.className=r||""}function Mt(e,t,r,i){if(t.gutter&&(t.node.removeChild(t.gutter),t.gutter=null),t.gutterBackground&&(t.node.removeChild(t.gutterBackground),t.gutterBackground=null),t.line.gutterClass){var o=Ct(t);t.gutterBackground=n("div",null,"CodeMirror-gutter-background "+t.line.gutterClass,"left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px; width: "+i.gutterTotalWidth+"px"),e.display.input.setUneditable(t.gutterBackground),o.insertBefore(t.gutterBackground,t.text)}var l=t.line.gutterMarkers;if(e.options.lineNumbers||l){var s=Ct(t),a=t.gutter=n("div",null,"CodeMirror-gutter-wrapper","left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px");if(e.display.input.setUneditable(a),s.insertBefore(a,t.text),t.line.gutterClass&&(a.className+=" "+t.line.gutterClass),!e.options.lineNumbers||l&&l["CodeMirror-linenumbers"]||(t.lineNumber=a.appendChild(n("div",F(e.options,r),"CodeMirror-linenumber CodeMirror-gutter-elt","left: "+i.gutterLeft["CodeMirror-linenumbers"]+"px; width: "+e.display.lineNumInnerWidth+"px"))),l)for(var u=0;u<e.options.gutters.length;++u){var c=e.options.gutters[u],f=l.hasOwnProperty(c)&&l[c];f&&a.appendChild(n("div",[f],"CodeMirror-gutter-elt","left: "+i.gutterLeft[c]+"px; width: "+i.gutterWidth[c]+"px"))}}}function Nt(e,t,r){t.alignable&&(t.alignable=null);for(var n=t.node.firstChild,i=void 0;n;n=i)i=n.nextSibling,"CodeMirror-linewidget"==n.className&&t.node.removeChild(n);At(e,t,r)}function Ot(e,t,r,n){var i=Lt(e,t);return t.text=t.node=i.pre,i.bgClass&&(t.bgClass=i.bgClass),i.textClass&&(t.textClass=i.textClass),Tt(e,t),Mt(e,t,r,n),At(e,t,n),t.node}function At(e,t,r){if(Wt(e,t.line,t,r,!0),t.rest)for(var n=0;n<t.rest.length;n++)Wt(e,t.rest[n],t,r,!1)}function Wt(e,t,r,i,o){if(t.widgets)for(var l=Ct(r),s=0,a=t.widgets;s<a.length;++s){var u=a[s],c=n("div",[u.node],"CodeMirror-linewidget");u.handleMouseEvents||c.setAttribute("cm-ignore-events","true"),Dt(u,c,r,i),e.display.input.setUneditable(c),o&&u.above?l.insertBefore(c,r.gutter||r.text):l.appendChild(c),bt(u,"redraw")}}function Dt(e,t,r,n){if(e.noHScroll){(r.alignable||(r.alignable=[])).push(t);var i=n.wrapperWidth;t.style.left=n.fixedPos+"px",e.coverGutter||(i-=n.gutterTotalWidth,t.style.paddingLeft=n.gutterTotalWidth+"px"),t.style.width=i+"px"}e.coverGutter&&(t.style.zIndex=5,t.style.position="relative",e.noHScroll||(t.style.marginLeft=-n.gutterTotalWidth+"px"))}function Ht(e){if(null!=e.height)return e.height;var t=e.doc.cm;if(!t)return 0;if(!o(document.body,e.node)){var i="position: relative;";e.coverGutter&&(i+="margin-left: -"+t.display.gutters.offsetWidth+"px;"),e.noHScroll&&(i+="width: "+t.display.wrapper.clientWidth+"px;"),r(t.display.measure,n("div",[e.node],null,i))}return e.height=e.node.parentNode.offsetHeight}function Ft(e,t){for(var r=Ee(t);r!=e.wrapper;r=r.parentNode)if(!r||1==r.nodeType&&"true"==r.getAttribute("cm-ignore-events")||r.parentNode==e.sizer&&r!=e.mover)return!0}function Et(e){return e.lineSpace.offsetTop}function Pt(e){return e.mover.offsetHeight-e.lineSpace.offsetHeight}function It(e){if(e.cachedPaddingH)return e.cachedPaddingH;var t=r(e.measure,n("pre","x")),i=window.getComputedStyle?window.getComputedStyle(t):t.currentStyle,o={left:parseInt(i.paddingLeft),right:parseInt(i.paddingRight)};return isNaN(o.left)||isNaN(o.right)||(e.cachedPaddingH=o),o}function zt(e){return Rl-e.display.nativeBarWidth}function Rt(e){return e.display.scroller.clientWidth-zt(e)-e.display.barWidth}function Bt(e){return e.display.scroller.clientHeight-zt(e)-e.display.barHeight}function Gt(e,t,r){var n=e.options.lineWrapping,i=n&&Rt(e);if(!t.measure.heights||n&&t.measure.width!=i){var o=t.measure.heights=[];if(n){t.measure.width=i;for(var l=t.text.firstChild.getClientRects(),s=0;s<l.length-1;s++){var a=l[s],u=l[s+1];Math.abs(a.bottom-u.bottom)>2&&o.push((a.bottom+u.top)/2-r.top)}}o.push(r.bottom-r.top)}}function Ut(e,t,r){if(e.line==t)return{map:e.measure.map,cache:e.measure.cache};for(var n=0;n<e.rest.length;n++)if(e.rest[n]==t)return{map:e.measure.maps[n],cache:e.measure.caches[n]};for(var i=0;i<e.rest.length;i++)if(W(e.rest[i])>r)return{map:e.measure.maps[i],cache:e.measure.caches[i],before:!0}}function Vt(e,t){var n=W(t=fe(t)),i=e.display.externalMeasured=new pt(e.doc,t,n);i.lineN=n;var o=i.built=st(e,i);return i.text=o.pre,r(e.display.lineMeasure,o.pre),i}function Kt(e,t,r,n){return Yt(e,Xt(e,t),r,n)}function jt(e,t){if(t>=e.display.viewFrom&&t<e.display.viewTo)return e.display.view[Lr(e,t)];var r=e.display.externalMeasured;return r&&t>=r.lineN&&t<r.lineN+r.size?r:void 0}function Xt(e,t){var r=W(t),n=jt(e,r);n&&!n.text?n=null:n&&n.changes&&(xt(e,n,r,br(e)),e.curOp.forceUpdate=!0),n||(n=Vt(e,t));var i=Ut(n,t,r);return{line:t,view:n,rect:null,map:i.map,cache:i.cache,before:i.before,hasHeights:!1}}function Yt(e,t,r,n,i){t.before&&(r=-1);var o,l=r+(n||"");return t.cache.hasOwnProperty(l)?o=t.cache[l]:(t.rect||(t.rect=t.view.text.getBoundingClientRect()),t.hasHeights||(Gt(e,t.view,t.rect),t.hasHeights=!0),(o=qt(e,t,r,n)).bogus||(t.cache[l]=o)),{left:o.left,right:o.right,top:i?o.rtop:o.top,bottom:i?o.rbottom:o.bottom}}function _t(e,t,r){for(var n,i,o,l,s,a,u=0;u<e.length;u+=3)if(s=e[u],a=e[u+1],t<s?(i=0,o=1,l="left"):t<a?o=(i=t-s)+1:(u==e.length-3||t==a&&e[u+3]>t)&&(i=(o=a-s)-1,t>=a&&(l="right")),null!=i){if(n=e[u+2],s==a&&r==(n.insertLeft?"left":"right")&&(l=r),"left"==r&&0==i)for(;u&&e[u-2]==e[u-3]&&e[u-1].insertLeft;)n=e[2+(u-=3)],l="left";if("right"==r&&i==a-s)for(;u<e.length-3&&e[u+3]==e[u+4]&&!e[u+5].insertLeft;)n=e[(u+=3)+2],l="right";break}return{node:n,start:i,end:o,collapse:l,coverStart:s,coverEnd:a}}function $t(e,t){var r=ms;if("left"==t)for(var n=0;n<e.length&&(r=e[n]).left==r.right;n++);else for(var i=e.length-1;i>=0&&(r=e[i]).left==r.right;i--);return r}function qt(e,t,r,n){var i,o=_t(t.map,r,n),l=o.node,s=o.start,a=o.end,u=o.collapse;if(3==l.nodeType){for(var c=0;c<4;c++){for(;s&&S(t.line.text.charAt(o.coverStart+s));)--s;for(;o.coverStart+a<o.coverEnd&&S(t.line.text.charAt(o.coverStart+a));)++a;if((i=gl&&vl<9&&0==s&&a==o.coverEnd-o.coverStart?l.parentNode.getBoundingClientRect():$t(Wl(l,s,a).getClientRects(),n)).left||i.right||0==s)break;a=s,s-=1,u="right"}gl&&vl<11&&(i=Zt(e.display.measure,i))}else{s>0&&(u=n="right");var f;i=e.options.lineWrapping&&(f=l.getClientRects()).length>1?f["right"==n?f.length-1:0]:l.getBoundingClientRect()}if(gl&&vl<9&&!s&&(!i||!i.left&&!i.right)){var h=l.parentNode.getClientRects()[0];i=h?{left:h.left,right:h.left+yr(e.display),top:h.top,bottom:h.bottom}:ms}for(var d=i.top-t.rect.top,p=i.bottom-t.rect.top,g=(d+p)/2,v=t.view.measure.heights,m=0;m<v.length-1&&!(g<v[m]);m++);var y=m?v[m-1]:0,b=v[m],w={left:("right"==u?i.right:i.left)-t.rect.left,right:("left"==u?i.left:i.right)-t.rect.left,top:y,bottom:b};return i.left||i.right||(w.bogus=!0),e.options.singleCursorHeightPerLine||(w.rtop=d,w.rbottom=p),w}function Zt(e,t){if(!window.screen||null==screen.logicalXDPI||screen.logicalXDPI==screen.deviceXDPI||!Re(e))return t;var r=screen.logicalXDPI/screen.deviceXDPI,n=screen.logicalYDPI/screen.deviceYDPI;return{left:t.left*r,right:t.right*r,top:t.top*n,bottom:t.bottom*n}}function Qt(e){if(e.measure&&(e.measure.cache={},e.measure.heights=null,e.rest))for(var t=0;t<e.rest.length;t++)e.measure.caches[t]={}}function Jt(e){e.display.externalMeasure=null,t(e.display.lineMeasure);for(var r=0;r<e.display.view.length;r++)Qt(e.display.view[r])}function er(e){Jt(e),e.display.cachedCharWidth=e.display.cachedTextHeight=e.display.cachedPaddingH=null,e.options.lineWrapping||(e.display.maxLineChanged=!0),e.display.lineNumChars=null}function tr(){return bl&&kl?-(document.body.getBoundingClientRect().left-parseInt(getComputedStyle(document.body).marginLeft)):window.pageXOffset||(document.documentElement||document.body).scrollLeft}function rr(){return bl&&kl?-(document.body.getBoundingClientRect().top-parseInt(getComputedStyle(document.body).marginTop)):window.pageYOffset||(document.documentElement||document.body).scrollTop}function nr(e){var t=0;if(e.widgets)for(var r=0;r<e.widgets.length;++r)e.widgets[r].above&&(t+=Ht(e.widgets[r]));return t}function ir(e,t,r,n,i){if(!i){var o=nr(t);r.top+=o,r.bottom+=o}if("line"==n)return r;n||(n="local");var l=ye(t);if("local"==n?l+=Et(e.display):l-=e.display.viewOffset,"page"==n||"window"==n){var s=e.display.lineSpace.getBoundingClientRect();l+=s.top+("window"==n?0:rr());var a=s.left+("window"==n?0:tr());r.left+=a,r.right+=a}return r.top+=l,r.bottom+=l,r}function or(e,t,r){if("div"==r)return t;var n=t.left,i=t.top;if("page"==r)n-=tr(),i-=rr();else if("local"==r||!r){var o=e.display.sizer.getBoundingClientRect();n+=o.left,i+=o.top}var l=e.display.lineSpace.getBoundingClientRect();return{left:n-l.left,top:i-l.top}}function lr(e,t,r,n,i){return n||(n=M(e.doc,t.line)),ir(e,n,Kt(e,n,t.ch,i),r)}function sr(e,t,r,n,i,o){function l(t,l){var s=Yt(e,i,t,l?"right":"left",o);return l?s.left=s.right:s.right=s.left,ir(e,n,s,r)}function s(e,t,r){var n=1==a[t].level;return l(r?e-1:e,n!=r)}n=n||M(e.doc,t.line),i||(i=Xt(e,n));var a=Se(n,e.doc.direction),u=t.ch,c=t.sticky;if(u>=n.text.length?(u=n.text.length,c="before"):u<=0&&(u=0,c="after"),!a)return l("before"==c?u-1:u,"before"==c);var f=Ce(a,u,c),h=$l,d=s(u,f,"before"==c);return null!=h&&(d.other=s(u,h,"before"!=c)),d}function ar(e,t){var r=0;t=U(e.doc,t),e.options.lineWrapping||(r=yr(e.display)*t.ch);var n=M(e.doc,t.line),i=ye(n)+Et(e.display);return{left:r,right:r,top:i,bottom:i+n.height}}function ur(e,t,r,n,i){var o=E(e,t,r);return o.xRel=i,n&&(o.outside=!0),o}function cr(e,t,r){var n=e.doc;if((r+=e.display.viewOffset)<0)return ur(n.first,0,null,!0,-1);var i=D(n,r),o=n.first+n.size-1;if(i>o)return ur(n.first+n.size-1,M(n,o).text.length,null,!0,1);t<0&&(t=0);for(var l=M(n,i);;){var s=pr(e,l,i,t,r),a=ue(l),u=a&&a.find(0,!0);if(!a||!(s.ch>u.from.ch||s.ch==u.from.ch&&s.xRel>0))return s;i=W(l=u.to.line)}}function fr(e,t,r,n){n-=nr(t);var i=t.text.length,o=k(function(t){return Yt(e,r,t-1).bottom<=n},i,0);return i=k(function(t){return Yt(e,r,t).top>n},o,i),{begin:o,end:i}}function hr(e,t,r,n){return r||(r=Xt(e,t)),fr(e,t,r,ir(e,t,Yt(e,r,n),"line").top)}function dr(e,t,r,n){return!(e.bottom<=r)&&(e.top>r||(n?e.left:e.right)>t)}function pr(e,t,r,n,i){i-=ye(t);var o=Xt(e,t),l=nr(t),s=0,a=t.text.length,u=!0,c=Se(t,e.doc.direction);if(c){var f=(e.options.lineWrapping?vr:gr)(e,t,r,o,c,n,i);s=(u=1!=f.level)?f.from:f.to-1,a=u?f.to:f.from-1}var h,d,p=null,g=null,v=k(function(t){var r=Yt(e,o,t);return r.top+=l,r.bottom+=l,!!dr(r,n,i,!1)&&(r.top<=i&&r.left<=n&&(p=t,g=r),!0)},s,a),m=!1;if(g){var y=n-g.left<g.right-n,b=y==u;v=p+(b?0:1),d=b?"after":"before",h=y?g.left:g.right}else{u||v!=a&&v!=s||v++,d=0==v?"after":v==t.text.length?"before":Yt(e,o,v-(u?1:0)).bottom+l<=i==u?"after":"before";var w=sr(e,E(r,v,d),"line",t,o);h=w.left,m=i<w.top||i>=w.bottom}return v=L(t.text,v,1),ur(r,v,d,m,n-h)}function gr(e,t,r,n,i,o,l){var s=k(function(s){var a=i[s],u=1!=a.level;return dr(sr(e,E(r,u?a.to:a.from,u?"before":"after"),"line",t,n),o,l,!0)},0,i.length-1),a=i[s];if(s>0){var u=1!=a.level,c=sr(e,E(r,u?a.from:a.to,u?"after":"before"),"line",t,n);dr(c,o,l,!0)&&c.top>l&&(a=i[s-1])}return a}function vr(e,t,r,n,i,o,l){for(var s=fr(e,t,n,l),a=s.begin,u=s.end,c=null,f=null,h=0;h<i.length;h++){var d=i[h];if(!(d.from>=u||d.to<=a)){var p=Yt(e,n,1!=d.level?Math.min(u,d.to)-1:Math.max(a,d.from)).right,g=p<o?o-p+1e9:p-o;(!c||f>g)&&(c=d,f=g)}}return c||(c=i[i.length-1]),c.from<a&&(c={from:a,to:c.to,level:c.level}),c.to>u&&(c={from:c.from,to:u,level:c.level}),c}function mr(e){if(null!=e.cachedTextHeight)return e.cachedTextHeight;if(null==hs){hs=n("pre");for(var i=0;i<49;++i)hs.appendChild(document.createTextNode("x")),hs.appendChild(n("br"));hs.appendChild(document.createTextNode("x"))}r(e.measure,hs);var o=hs.offsetHeight/50;return o>3&&(e.cachedTextHeight=o),t(e.measure),o||1}function yr(e){if(null!=e.cachedCharWidth)return e.cachedCharWidth;var t=n("span","xxxxxxxxxx"),i=n("pre",[t]);r(e.measure,i);var o=t.getBoundingClientRect(),l=(o.right-o.left)/10;return l>2&&(e.cachedCharWidth=l),l||10}function br(e){for(var t=e.display,r={},n={},i=t.gutters.clientLeft,o=t.gutters.firstChild,l=0;o;o=o.nextSibling,++l)r[e.options.gutters[l]]=o.offsetLeft+o.clientLeft+i,n[e.options.gutters[l]]=o.clientWidth;return{fixedPos:wr(t),gutterTotalWidth:t.gutters.offsetWidth,gutterLeft:r,gutterWidth:n,wrapperWidth:t.wrapper.clientWidth}}function wr(e){return e.scroller.getBoundingClientRect().left-e.sizer.getBoundingClientRect().left}function xr(e){var t=mr(e.display),r=e.options.lineWrapping,n=r&&Math.max(5,e.display.scroller.clientWidth/yr(e.display)-3);return function(i){if(ve(e.doc,i))return 0;var o=0;if(i.widgets)for(var l=0;l<i.widgets.length;l++)i.widgets[l].height&&(o+=i.widgets[l].height);return r?o+(Math.ceil(i.text.length/n)||1)*t:o+t}}function Cr(e){var t=e.doc,r=xr(e);t.iter(function(e){var t=r(e);t!=e.height&&A(e,t)})}function Sr(e,t,r,n){var i=e.display;if(!r&&"true"==Ee(t).getAttribute("cm-not-content"))return null;var o,l,s=i.lineSpace.getBoundingClientRect();try{o=t.clientX-s.left,l=t.clientY-s.top}catch(t){return null}var a,u=cr(e,o,l);if(n&&1==u.xRel&&(a=M(e.doc,u.line).text).length==u.ch){var c=f(a,a.length,e.options.tabSize)-a.length;u=E(u.line,Math.max(0,Math.round((o-It(e.display).left)/yr(e.display))-c))}return u}function Lr(e,t){if(t>=e.display.viewTo)return null;if((t-=e.display.viewFrom)<0)return null;for(var r=e.display.view,n=0;n<r.length;n++)if((t-=r[n].size)<0)return n}function kr(e){e.display.input.showSelection(e.display.input.prepareSelection())}function Tr(e,t){void 0===t&&(t=!0);for(var r=e.doc,n={},i=n.cursors=document.createDocumentFragment(),o=n.selection=document.createDocumentFragment(),l=0;l<r.sel.ranges.length;l++)if(t||l!=r.sel.primIndex){var s=r.sel.ranges[l];if(!(s.from().line>=e.display.viewTo||s.to().line<e.display.viewFrom)){var a=s.empty();(a||e.options.showCursorWhenSelecting)&&Mr(e,s.head,i),a||Or(e,s,o)}}return n}function Mr(e,t,r){var i=sr(e,t,"div",null,null,!e.options.singleCursorHeightPerLine),o=r.appendChild(n("div"," ","CodeMirror-cursor"));if(o.style.left=i.left+"px",o.style.top=i.top+"px",o.style.height=Math.max(0,i.bottom-i.top)*e.options.cursorHeight+"px",i.other){var l=r.appendChild(n("div"," ","CodeMirror-cursor CodeMirror-secondarycursor"));l.style.display="",l.style.left=i.other.left+"px",l.style.top=i.other.top+"px",l.style.height=.85*(i.other.bottom-i.other.top)+"px"}}function Nr(e,t){return e.top-t.top||e.left-t.left}function Or(e,t,r){function i(e,t,r,i){t<0&&(t=0),t=Math.round(t),i=Math.round(i),a.appendChild(n("div",null,"CodeMirror-selected","position: absolute; left: "+e+"px;\n                             top: "+t+"px; width: "+(null==r?f-e:r)+"px;\n                             height: "+(i-t)+"px"))}function o(t,r,n){function o(r,n){return lr(e,E(t,r),"div",u,n)}var l,a,u=M(s,t),h=u.text.length,d=Se(u,s.direction);return xe(d,r||0,null==n?h:n,function(t,s,p,g){var v=o(t,"ltr"==p?"left":"right"),m=o(s-1,"ltr"==p?"right":"left");if("ltr"==p){var y=null==r&&0==t?c:v.left,b=null==n&&s==h?f:m.right;m.top-v.top<=3?i(y,m.top,b-y,m.bottom):(i(y,v.top,null,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top),i(c,m.top,m.right,m.bottom))}else if(t<s){var w=null==r&&0==t?f:v.right,x=null==n&&s==h?c:m.left;if(m.top-v.top<=3)i(x,m.top,w-x,m.bottom);else{var C=c;if(g){var S=hr(e,u,null,t).end;C=o(S-(/\s/.test(u.text.charAt(S-1))?2:1),"left").left}i(C,v.top,w-C,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top);var L=null;d.length,L=o(hr(e,u,null,s).begin,"right").right-x,i(x,m.top,L,m.bottom)}}(!l||Nr(v,l)<0)&&(l=v),Nr(m,l)<0&&(l=m),(!a||Nr(v,a)<0)&&(a=v),Nr(m,a)<0&&(a=m)}),{start:l,end:a}}var l=e.display,s=e.doc,a=document.createDocumentFragment(),u=It(e.display),c=u.left,f=Math.max(l.sizerWidth,Rt(e)-l.sizer.offsetLeft)-u.right,h=t.from(),d=t.to();if(h.line==d.line)o(h.line,h.ch,d.ch);else{var p=M(s,h.line),g=M(s,d.line),v=fe(p)==fe(g),m=o(h.line,h.ch,v?p.text.length+1:null).end,y=o(d.line,v?0:null,d.ch).start;v&&(m.top<y.top-2?(i(m.right,m.top,null,m.bottom),i(c,y.top,y.left,y.bottom)):i(m.right,m.top,y.left-m.right,m.bottom)),m.bottom<y.top&&i(c,m.bottom,null,y.top)}r.appendChild(a)}function Ar(e){if(e.state.focused){var t=e.display;clearInterval(t.blinker);var r=!0;t.cursorDiv.style.visibility="",e.options.cursorBlinkRate>0?t.blinker=setInterval(function(){return t.cursorDiv.style.visibility=(r=!r)?"":"hidden"},e.options.cursorBlinkRate):e.options.cursorBlinkRate<0&&(t.cursorDiv.style.visibility="hidden")}}function Wr(e){e.state.focused||(e.display.input.focus(),Hr(e))}function Dr(e){e.state.delayingBlurEvent=!0,setTimeout(function(){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1,Fr(e))},100)}function Hr(e,t){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1),"nocursor"!=e.options.readOnly&&(e.state.focused||(Te(e,"focus",e,t),e.state.focused=!0,s(e.display.wrapper,"CodeMirror-focused"),e.curOp||e.display.selForContextMenu==e.doc.sel||(e.display.input.reset(),ml&&setTimeout(function(){return e.display.input.reset(!0)},20)),e.display.input.receivedFocus()),Ar(e))}function Fr(e,t){e.state.delayingBlurEvent||(e.state.focused&&(Te(e,"blur",e,t),e.state.focused=!1,Fl(e.display.wrapper,"CodeMirror-focused")),clearInterval(e.display.blinker),setTimeout(function(){e.state.focused||(e.display.shift=!1)},150))}function Er(e){for(var t=e.display,r=t.lineDiv.offsetTop,n=0;n<t.view.length;n++){var i=t.view[n],o=void 0;if(!i.hidden){if(gl&&vl<8){var l=i.node.offsetTop+i.node.offsetHeight;o=l-r,r=l}else{var s=i.node.getBoundingClientRect();o=s.bottom-s.top}var a=i.line.height-o;if(o<2&&(o=mr(t)),(a>.005||a<-.005)&&(A(i.line,o),Pr(i.line),i.rest))for(var u=0;u<i.rest.length;u++)Pr(i.rest[u])}}}function Pr(e){if(e.widgets)for(var t=0;t<e.widgets.length;++t)e.widgets[t].height=e.widgets[t].node.parentNode.offsetHeight}function Ir(e,t,r){var n=r&&null!=r.top?Math.max(0,r.top):e.scroller.scrollTop;n=Math.floor(n-Et(e));var i=r&&null!=r.bottom?r.bottom:n+e.wrapper.clientHeight,o=D(t,n),l=D(t,i);if(r&&r.ensure){var s=r.ensure.from.line,a=r.ensure.to.line;s<o?(o=s,l=D(t,ye(M(t,s))+e.wrapper.clientHeight)):Math.min(a,t.lastLine())>=l&&(o=D(t,ye(M(t,a))-e.wrapper.clientHeight),l=a)}return{from:o,to:Math.max(l,o+1)}}function zr(e){var t=e.display,r=t.view;if(t.alignWidgets||t.gutters.firstChild&&e.options.fixedGutter){for(var n=wr(t)-t.scroller.scrollLeft+e.doc.scrollLeft,i=t.gutters.offsetWidth,o=n+"px",l=0;l<r.length;l++)if(!r[l].hidden){e.options.fixedGutter&&(r[l].gutter&&(r[l].gutter.style.left=o),r[l].gutterBackground&&(r[l].gutterBackground.style.left=o));var s=r[l].alignable;if(s)for(var a=0;a<s.length;a++)s[a].style.left=o}e.options.fixedGutter&&(t.gutters.style.left=n+i+"px")}}function Rr(e){if(!e.options.lineNumbers)return!1;var t=e.doc,r=F(e.options,t.first+t.size-1),i=e.display;if(r.length!=i.lineNumChars){var o=i.measure.appendChild(n("div",[n("div",r)],"CodeMirror-linenumber CodeMirror-gutter-elt")),l=o.firstChild.offsetWidth,s=o.offsetWidth-l;return i.lineGutter.style.width="",i.lineNumInnerWidth=Math.max(l,i.lineGutter.offsetWidth-s)+1,i.lineNumWidth=i.lineNumInnerWidth+s,i.lineNumChars=i.lineNumInnerWidth?r.length:-1,i.lineGutter.style.width=i.lineNumWidth+"px",Wn(e),!0}return!1}function Br(e,t){if(!Me(e,"scrollCursorIntoView")){var r=e.display,i=r.sizer.getBoundingClientRect(),o=null;if(t.top+i.top<0?o=!0:t.bottom+i.top>(window.innerHeight||document.documentElement.clientHeight)&&(o=!1),null!=o&&!Sl){var l=n("div","​",null,"position: absolute;\n                         top: "+(t.top-r.viewOffset-Et(e.display))+"px;\n                         height: "+(t.bottom-t.top+zt(e)+r.barHeight)+"px;\n                         left: "+t.left+"px; width: "+Math.max(2,t.right-t.left)+"px;");e.display.lineSpace.appendChild(l),l.scrollIntoView(o),e.display.lineSpace.removeChild(l)}}}function Gr(e,t,r,n){null==n&&(n=0);var i;e.options.lineWrapping||t!=r||(r="before"==(t=t.ch?E(t.line,"before"==t.sticky?t.ch-1:t.ch,"after"):t).sticky?E(t.line,t.ch+1,"before"):t);for(var o=0;o<5;o++){var l=!1,s=sr(e,t),a=r&&r!=t?sr(e,r):s,u=Vr(e,i={left:Math.min(s.left,a.left),top:Math.min(s.top,a.top)-n,right:Math.max(s.left,a.left),bottom:Math.max(s.bottom,a.bottom)+n}),c=e.doc.scrollTop,f=e.doc.scrollLeft;if(null!=u.scrollTop&&(qr(e,u.scrollTop),Math.abs(e.doc.scrollTop-c)>1&&(l=!0)),null!=u.scrollLeft&&(Qr(e,u.scrollLeft),Math.abs(e.doc.scrollLeft-f)>1&&(l=!0)),!l)break}return i}function Ur(e,t){var r=Vr(e,t);null!=r.scrollTop&&qr(e,r.scrollTop),null!=r.scrollLeft&&Qr(e,r.scrollLeft)}function Vr(e,t){var r=e.display,n=mr(e.display);t.top<0&&(t.top=0);var i=e.curOp&&null!=e.curOp.scrollTop?e.curOp.scrollTop:r.scroller.scrollTop,o=Bt(e),l={};t.bottom-t.top>o&&(t.bottom=t.top+o);var s=e.doc.height+Pt(r),a=t.top<n,u=t.bottom>s-n;if(t.top<i)l.scrollTop=a?0:t.top;else if(t.bottom>i+o){var c=Math.min(t.top,(u?s:t.bottom)-o);c!=i&&(l.scrollTop=c)}var f=e.curOp&&null!=e.curOp.scrollLeft?e.curOp.scrollLeft:r.scroller.scrollLeft,h=Rt(e)-(e.options.fixedGutter?r.gutters.offsetWidth:0),d=t.right-t.left>h;return d&&(t.right=t.left+h),t.left<10?l.scrollLeft=0:t.left<f?l.scrollLeft=Math.max(0,t.left-(d?0:10)):t.right>h+f-3&&(l.scrollLeft=t.right+(d?0:10)-h),l}function Kr(e,t){null!=t&&(_r(e),e.curOp.scrollTop=(null==e.curOp.scrollTop?e.doc.scrollTop:e.curOp.scrollTop)+t)}function jr(e){_r(e);var t=e.getCursor();e.curOp.scrollToPos={from:t,to:t,margin:e.options.cursorScrollMargin}}function Xr(e,t,r){null==t&&null==r||_r(e),null!=t&&(e.curOp.scrollLeft=t),null!=r&&(e.curOp.scrollTop=r)}function Yr(e,t){_r(e),e.curOp.scrollToPos=t}function _r(e){var t=e.curOp.scrollToPos;t&&(e.curOp.scrollToPos=null,$r(e,ar(e,t.from),ar(e,t.to),t.margin))}function $r(e,t,r,n){var i=Vr(e,{left:Math.min(t.left,r.left),top:Math.min(t.top,r.top)-n,right:Math.max(t.right,r.right),bottom:Math.max(t.bottom,r.bottom)+n});Xr(e,i.scrollLeft,i.scrollTop)}function qr(e,t){Math.abs(e.doc.scrollTop-t)<2||(fl||On(e,{top:t}),Zr(e,t,!0),fl&&On(e),Cn(e,100))}function Zr(e,t,r){t=Math.min(e.display.scroller.scrollHeight-e.display.scroller.clientHeight,t),(e.display.scroller.scrollTop!=t||r)&&(e.doc.scrollTop=t,e.display.scrollbars.setScrollTop(t),e.display.scroller.scrollTop!=t&&(e.display.scroller.scrollTop=t))}function Qr(e,t,r,n){t=Math.min(t,e.display.scroller.scrollWidth-e.display.scroller.clientWidth),(r?t==e.doc.scrollLeft:Math.abs(e.doc.scrollLeft-t)<2)&&!n||(e.doc.scrollLeft=t,zr(e),e.display.scroller.scrollLeft!=t&&(e.display.scroller.scrollLeft=t),e.display.scrollbars.setScrollLeft(t))}function Jr(e){var t=e.display,r=t.gutters.offsetWidth,n=Math.round(e.doc.height+Pt(e.display));return{clientHeight:t.scroller.clientHeight,viewHeight:t.wrapper.clientHeight,scrollWidth:t.scroller.scrollWidth,clientWidth:t.scroller.clientWidth,viewWidth:t.wrapper.clientWidth,barLeft:e.options.fixedGutter?r:0,docHeight:n,scrollHeight:n+zt(e)+t.barHeight,nativeBarWidth:t.nativeBarWidth,gutterWidth:r}}function en(e,t){t||(t=Jr(e));var r=e.display.barWidth,n=e.display.barHeight;tn(e,t);for(var i=0;i<4&&r!=e.display.barWidth||n!=e.display.barHeight;i++)r!=e.display.barWidth&&e.options.lineWrapping&&Er(e),tn(e,Jr(e)),r=e.display.barWidth,n=e.display.barHeight}function tn(e,t){var r=e.display,n=r.scrollbars.update(t);r.sizer.style.paddingRight=(r.barWidth=n.right)+"px",r.sizer.style.paddingBottom=(r.barHeight=n.bottom)+"px",r.heightForcer.style.borderBottom=n.bottom+"px solid transparent",n.right&&n.bottom?(r.scrollbarFiller.style.display="block",r.scrollbarFiller.style.height=n.bottom+"px",r.scrollbarFiller.style.width=n.right+"px"):r.scrollbarFiller.style.display="",n.bottom&&e.options.coverGutterNextToScrollbar&&e.options.fixedGutter?(r.gutterFiller.style.display="block",r.gutterFiller.style.height=n.bottom+"px",r.gutterFiller.style.width=t.gutterWidth+"px"):r.gutterFiller.style.display=""}function rn(e){e.display.scrollbars&&(e.display.scrollbars.clear(),e.display.scrollbars.addClass&&Fl(e.display.wrapper,e.display.scrollbars.addClass)),e.display.scrollbars=new ws[e.options.scrollbarStyle](function(t){e.display.wrapper.insertBefore(t,e.display.scrollbarFiller),Ql(t,"mousedown",function(){e.state.focused&&setTimeout(function(){return e.display.input.focus()},0)}),t.setAttribute("cm-not-content","true")},function(t,r){"horizontal"==r?Qr(e,t):qr(e,t)},e),e.display.scrollbars.addClass&&s(e.display.wrapper,e.display.scrollbars.addClass)}function nn(e){e.curOp={cm:e,viewChanged:!1,startHeight:e.doc.height,forceUpdate:!1,updateInput:null,typing:!1,changeObjs:null,cursorActivityHandlers:null,cursorActivityCalled:0,selectionChanged:!1,updateMaxLine:!1,scrollLeft:null,scrollTop:null,scrollToPos:null,focus:!1,id:++xs},vt(e.curOp)}function on(e){yt(e.curOp,function(e){for(var t=0;t<e.ops.length;t++)e.ops[t].cm.curOp=null;ln(e)})}function ln(e){for(var t=e.ops,r=0;r<t.length;r++)sn(t[r]);for(var n=0;n<t.length;n++)an(t[n]);for(var i=0;i<t.length;i++)un(t[i]);for(var o=0;o<t.length;o++)cn(t[o]);for(var l=0;l<t.length;l++)fn(t[l])}function sn(e){var t=e.cm,r=t.display;Ln(t),e.updateMaxLine&&we(t),e.mustUpdate=e.viewChanged||e.forceUpdate||null!=e.scrollTop||e.scrollToPos&&(e.scrollToPos.from.line<r.viewFrom||e.scrollToPos.to.line>=r.viewTo)||r.maxLineChanged&&t.options.lineWrapping,e.update=e.mustUpdate&&new Cs(t,e.mustUpdate&&{top:e.scrollTop,ensure:e.scrollToPos},e.forceUpdate)}function an(e){e.updatedDisplay=e.mustUpdate&&Mn(e.cm,e.update)}function un(e){var t=e.cm,r=t.display;e.updatedDisplay&&Er(t),e.barMeasure=Jr(t),r.maxLineChanged&&!t.options.lineWrapping&&(e.adjustWidthTo=Kt(t,r.maxLine,r.maxLine.text.length).left+3,t.display.sizerWidth=e.adjustWidthTo,e.barMeasure.scrollWidth=Math.max(r.scroller.clientWidth,r.sizer.offsetLeft+e.adjustWidthTo+zt(t)+t.display.barWidth),e.maxScrollLeft=Math.max(0,r.sizer.offsetLeft+e.adjustWidthTo-Rt(t))),(e.updatedDisplay||e.selectionChanged)&&(e.preparedSelection=r.input.prepareSelection())}function cn(e){var t=e.cm;null!=e.adjustWidthTo&&(t.display.sizer.style.minWidth=e.adjustWidthTo+"px",e.maxScrollLeft<t.doc.scrollLeft&&Qr(t,Math.min(t.display.scroller.scrollLeft,e.maxScrollLeft),!0),t.display.maxLineChanged=!1);var r=e.focus&&e.focus==l();e.preparedSelection&&t.display.input.showSelection(e.preparedSelection,r),(e.updatedDisplay||e.startHeight!=t.doc.height)&&en(t,e.barMeasure),e.updatedDisplay&&Dn(t,e.barMeasure),e.selectionChanged&&Ar(t),t.state.focused&&e.updateInput&&t.display.input.reset(e.typing),r&&Wr(e.cm)}function fn(e){var t=e.cm,r=t.display,n=t.doc;e.updatedDisplay&&Nn(t,e.update),null==r.wheelStartX||null==e.scrollTop&&null==e.scrollLeft&&!e.scrollToPos||(r.wheelStartX=r.wheelStartY=null),null!=e.scrollTop&&Zr(t,e.scrollTop,e.forceScroll),null!=e.scrollLeft&&Qr(t,e.scrollLeft,!0,!0),e.scrollToPos&&Br(t,Gr(t,U(n,e.scrollToPos.from),U(n,e.scrollToPos.to),e.scrollToPos.margin));var i=e.maybeHiddenMarkers,o=e.maybeUnhiddenMarkers;if(i)for(var l=0;l<i.length;++l)i[l].lines.length||Te(i[l],"hide");if(o)for(var s=0;s<o.length;++s)o[s].lines.length&&Te(o[s],"unhide");r.wrapper.offsetHeight&&(n.scrollTop=t.display.scroller.scrollTop),e.changeObjs&&Te(t,"changes",t,e.changeObjs),e.update&&e.update.finish()}function hn(e,t){if(e.curOp)return t();nn(e);try{return t()}finally{on(e)}}function dn(e,t){return function(){if(e.curOp)return t.apply(e,arguments);nn(e);try{return t.apply(e,arguments)}finally{on(e)}}}function pn(e){return function(){if(this.curOp)return e.apply(this,arguments);nn(this);try{return e.apply(this,arguments)}finally{on(this)}}}function gn(e){return function(){var t=this.cm;if(!t||t.curOp)return e.apply(this,arguments);nn(t);try{return e.apply(this,arguments)}finally{on(t)}}}function vn(e,t,r,n){null==t&&(t=e.doc.first),null==r&&(r=e.doc.first+e.doc.size),n||(n=0);var i=e.display;if(n&&r<i.viewTo&&(null==i.updateLineNumbers||i.updateLineNumbers>t)&&(i.updateLineNumbers=t),e.curOp.viewChanged=!0,t>=i.viewTo)_l&&pe(e.doc,t)<i.viewTo&&yn(e);else if(r<=i.viewFrom)_l&&ge(e.doc,r+n)>i.viewFrom?yn(e):(i.viewFrom+=n,i.viewTo+=n);else if(t<=i.viewFrom&&r>=i.viewTo)yn(e);else if(t<=i.viewFrom){var o=bn(e,r,r+n,1);o?(i.view=i.view.slice(o.index),i.viewFrom=o.lineN,i.viewTo+=n):yn(e)}else if(r>=i.viewTo){var l=bn(e,t,t,-1);l?(i.view=i.view.slice(0,l.index),i.viewTo=l.lineN):yn(e)}else{var s=bn(e,t,t,-1),a=bn(e,r,r+n,1);s&&a?(i.view=i.view.slice(0,s.index).concat(gt(e,s.lineN,a.lineN)).concat(i.view.slice(a.index)),i.viewTo+=n):yn(e)}var u=i.externalMeasured;u&&(r<u.lineN?u.lineN+=n:t<u.lineN+u.size&&(i.externalMeasured=null))}function mn(e,t,r){e.curOp.viewChanged=!0;var n=e.display,i=e.display.externalMeasured;if(i&&t>=i.lineN&&t<i.lineN+i.size&&(n.externalMeasured=null),!(t<n.viewFrom||t>=n.viewTo)){var o=n.view[Lr(e,t)];if(null!=o.node){var l=o.changes||(o.changes=[]);-1==h(l,r)&&l.push(r)}}}function yn(e){e.display.viewFrom=e.display.viewTo=e.doc.first,e.display.view=[],e.display.viewOffset=0}function bn(e,t,r,n){var i,o=Lr(e,t),l=e.display.view;if(!_l||r==e.doc.first+e.doc.size)return{index:o,lineN:r};for(var s=e.display.viewFrom,a=0;a<o;a++)s+=l[a].size;if(s!=t){if(n>0){if(o==l.length-1)return null;i=s+l[o].size-t,o++}else i=s-t;t+=i,r+=i}for(;pe(e.doc,r)!=r;){if(o==(n<0?0:l.length-1))return null;r+=n*l[o-(n<0?1:0)].size,o+=n}return{index:o,lineN:r}}function wn(e,t,r){var n=e.display;0==n.view.length||t>=n.viewTo||r<=n.viewFrom?(n.view=gt(e,t,r),n.viewFrom=t):(n.viewFrom>t?n.view=gt(e,t,n.viewFrom).concat(n.view):n.viewFrom<t&&(n.view=n.view.slice(Lr(e,t))),n.viewFrom=t,n.viewTo<r?n.view=n.view.concat(gt(e,n.viewTo,r)):n.viewTo>r&&(n.view=n.view.slice(0,Lr(e,r)))),n.viewTo=r}function xn(e){for(var t=e.display.view,r=0,n=0;n<t.length;n++){var i=t[n];i.hidden||i.node&&!i.changes||++r}return r}function Cn(e,t){e.doc.highlightFrontier<e.display.viewTo&&e.state.highlight.set(t,u(Sn,e))}function Sn(e){var t=e.doc;if(!(t.highlightFrontier>=e.display.viewTo)){var r=+new Date+e.options.workTime,n=$e(e,t.highlightFrontier),i=[];t.iter(n.line,Math.min(t.first+t.size,e.display.viewTo+500),function(o){if(n.line>=e.display.viewFrom){var l=o.styles,s=o.text.length>e.options.maxHighlightLength?Ke(t.mode,n.state):null,a=Ye(e,o,n,!0);s&&(n.state=s),o.styles=a.styles;var u=o.styleClasses,c=a.classes;c?o.styleClasses=c:u&&(o.styleClasses=null);for(var f=!l||l.length!=o.styles.length||u!=c&&(!u||!c||u.bgClass!=c.bgClass||u.textClass!=c.textClass),h=0;!f&&h<l.length;++h)f=l[h]!=o.styles[h];f&&i.push(n.line),o.stateAfter=n.save(),n.nextLine()}else o.text.length<=e.options.maxHighlightLength&&qe(e,o.text,n),o.stateAfter=n.line%5==0?n.save():null,n.nextLine();if(+new Date>r)return Cn(e,e.options.workDelay),!0}),t.highlightFrontier=n.line,t.modeFrontier=Math.max(t.modeFrontier,n.line),i.length&&hn(e,function(){for(var t=0;t<i.length;t++)mn(e,i[t],"text")})}}function Ln(e){var t=e.display;!t.scrollbarsClipped&&t.scroller.offsetWidth&&(t.nativeBarWidth=t.scroller.offsetWidth-t.scroller.clientWidth,t.heightForcer.style.height=zt(e)+"px",t.sizer.style.marginBottom=-t.nativeBarWidth+"px",t.sizer.style.borderRightWidth=zt(e)+"px",t.scrollbarsClipped=!0)}function kn(e){if(e.hasFocus())return null;var t=l();if(!t||!o(e.display.lineDiv,t))return null;var r={activeElt:t};if(window.getSelection){var n=window.getSelection();n.anchorNode&&n.extend&&o(e.display.lineDiv,n.anchorNode)&&(r.anchorNode=n.anchorNode,r.anchorOffset=n.anchorOffset,r.focusNode=n.focusNode,r.focusOffset=n.focusOffset)}return r}function Tn(e){if(e&&e.activeElt&&e.activeElt!=l()&&(e.activeElt.focus(),e.anchorNode&&o(document.body,e.anchorNode)&&o(document.body,e.focusNode))){var t=window.getSelection(),r=document.createRange();r.setEnd(e.anchorNode,e.anchorOffset),r.collapse(!1),t.removeAllRanges(),t.addRange(r),t.extend(e.focusNode,e.focusOffset)}}function Mn(e,r){var n=e.display,i=e.doc;if(r.editorIsHidden)return yn(e),!1;if(!r.force&&r.visible.from>=n.viewFrom&&r.visible.to<=n.viewTo&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo)&&n.renderedView==n.view&&0==xn(e))return!1;Rr(e)&&(yn(e),r.dims=br(e));var o=i.first+i.size,l=Math.max(r.visible.from-e.options.viewportMargin,i.first),s=Math.min(o,r.visible.to+e.options.viewportMargin);n.viewFrom<l&&l-n.viewFrom<20&&(l=Math.max(i.first,n.viewFrom)),n.viewTo>s&&n.viewTo-s<20&&(s=Math.min(o,n.viewTo)),_l&&(l=pe(e.doc,l),s=ge(e.doc,s));var a=l!=n.viewFrom||s!=n.viewTo||n.lastWrapHeight!=r.wrapperHeight||n.lastWrapWidth!=r.wrapperWidth;wn(e,l,s),n.viewOffset=ye(M(e.doc,n.viewFrom)),e.display.mover.style.top=n.viewOffset+"px";var u=xn(e);if(!a&&0==u&&!r.force&&n.renderedView==n.view&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo))return!1;var c=kn(e);return u>4&&(n.lineDiv.style.display="none"),An(e,n.updateLineNumbers,r.dims),u>4&&(n.lineDiv.style.display=""),n.renderedView=n.view,Tn(c),t(n.cursorDiv),t(n.selectionDiv),n.gutters.style.height=n.sizer.style.minHeight=0,a&&(n.lastWrapHeight=r.wrapperHeight,n.lastWrapWidth=r.wrapperWidth,Cn(e,400)),n.updateLineNumbers=null,!0}function Nn(e,t){for(var r=t.viewport,n=!0;(n&&e.options.lineWrapping&&t.oldDisplayWidth!=Rt(e)||(r&&null!=r.top&&(r={top:Math.min(e.doc.height+Pt(e.display)-Bt(e),r.top)}),t.visible=Ir(e.display,e.doc,r),!(t.visible.from>=e.display.viewFrom&&t.visible.to<=e.display.viewTo)))&&Mn(e,t);n=!1){Er(e);var i=Jr(e);kr(e),en(e,i),Dn(e,i),t.force=!1}t.signal(e,"update",e),e.display.viewFrom==e.display.reportedViewFrom&&e.display.viewTo==e.display.reportedViewTo||(t.signal(e,"viewportChange",e,e.display.viewFrom,e.display.viewTo),e.display.reportedViewFrom=e.display.viewFrom,e.display.reportedViewTo=e.display.viewTo)}function On(e,t){var r=new Cs(e,t);if(Mn(e,r)){Er(e),Nn(e,r);var n=Jr(e);kr(e),en(e,n),Dn(e,n),r.finish()}}function An(e,r,n){function i(t){var r=t.nextSibling;return ml&&Ml&&e.display.currentWheelTarget==t?t.style.display="none":t.parentNode.removeChild(t),r}for(var o=e.display,l=e.options.lineNumbers,s=o.lineDiv,a=s.firstChild,u=o.view,c=o.viewFrom,f=0;f<u.length;f++){var d=u[f];if(d.hidden);else if(d.node&&d.node.parentNode==s){for(;a!=d.node;)a=i(a);var p=l&&null!=r&&r<=c&&d.lineNumber;d.changes&&(h(d.changes,"gutter")>-1&&(p=!1),xt(e,d,c,n)),p&&(t(d.lineNumber),d.lineNumber.appendChild(document.createTextNode(F(e.options,c)))),a=d.node.nextSibling}else{var g=Ot(e,d,c,n);s.insertBefore(g,a)}c+=d.size}for(;a;)a=i(a)}function Wn(e){var t=e.display.gutters.offsetWidth;e.display.sizer.style.marginLeft=t+"px"}function Dn(e,t){e.display.sizer.style.minHeight=t.docHeight+"px",e.display.heightForcer.style.top=t.docHeight+"px",e.display.gutters.style.height=t.docHeight+e.display.barHeight+zt(e)+"px"}function Hn(e){var r=e.display.gutters,i=e.options.gutters;t(r);for(var o=0;o<i.length;++o){var l=i[o],s=r.appendChild(n("div",null,"CodeMirror-gutter "+l));"CodeMirror-linenumbers"==l&&(e.display.lineGutter=s,s.style.width=(e.display.lineNumWidth||1)+"px")}r.style.display=o?"":"none",Wn(e)}function Fn(e){var t=h(e.gutters,"CodeMirror-linenumbers");-1==t&&e.lineNumbers?e.gutters=e.gutters.concat(["CodeMirror-linenumbers"]):t>-1&&!e.lineNumbers&&(e.gutters=e.gutters.slice(0),e.gutters.splice(t,1))}function En(e){var t=e.wheelDeltaX,r=e.wheelDeltaY;return null==t&&e.detail&&e.axis==e.HORIZONTAL_AXIS&&(t=e.detail),null==r&&e.detail&&e.axis==e.VERTICAL_AXIS?r=e.detail:null==r&&(r=e.wheelDelta),{x:t,y:r}}function Pn(e){var t=En(e);return t.x*=Ls,t.y*=Ls,t}function In(e,t){var r=En(t),n=r.x,i=r.y,o=e.display,l=o.scroller,s=l.scrollWidth>l.clientWidth,a=l.scrollHeight>l.clientHeight;if(n&&s||i&&a){if(i&&Ml&&ml)e:for(var u=t.target,c=o.view;u!=l;u=u.parentNode)for(var f=0;f<c.length;f++)if(c[f].node==u){e.display.currentWheelTarget=u;break e}if(n&&!fl&&!wl&&null!=Ls)return i&&a&&qr(e,Math.max(0,l.scrollTop+i*Ls)),Qr(e,Math.max(0,l.scrollLeft+n*Ls)),(!i||i&&a)&&We(t),void(o.wheelStartX=null);if(i&&null!=Ls){var h=i*Ls,d=e.doc.scrollTop,p=d+o.wrapper.clientHeight;h<0?d=Math.max(0,d+h-50):p=Math.min(e.doc.height,p+h+50),On(e,{top:d,bottom:p})}Ss<20&&(null==o.wheelStartX?(o.wheelStartX=l.scrollLeft,o.wheelStartY=l.scrollTop,o.wheelDX=n,o.wheelDY=i,setTimeout(function(){if(null!=o.wheelStartX){var e=l.scrollLeft-o.wheelStartX,t=l.scrollTop-o.wheelStartY,r=t&&o.wheelDY&&t/o.wheelDY||e&&o.wheelDX&&e/o.wheelDX;o.wheelStartX=o.wheelStartY=null,r&&(Ls=(Ls*Ss+r)/(Ss+1),++Ss)}},200)):(o.wheelDX+=n,o.wheelDY+=i))}}function zn(e,t){var r=e[t];e.sort(function(e,t){return P(e.from(),t.from())}),t=h(e,r);for(var n=1;n<e.length;n++){var i=e[n],o=e[n-1];if(P(o.to(),i.from())>=0){var l=B(o.from(),i.from()),s=R(o.to(),i.to()),a=o.empty()?i.from()==i.head:o.from()==o.head;n<=t&&--t,e.splice(--n,2,new Ts(a?s:l,a?l:s))}}return new ks(e,t)}function Rn(e,t){return new ks([new Ts(e,t||e)],0)}function Bn(e){return e.text?E(e.from.line+e.text.length-1,g(e.text).length+(1==e.text.length?e.from.ch:0)):e.to}function Gn(e,t){if(P(e,t.from)<0)return e;if(P(e,t.to)<=0)return Bn(t);var r=e.line+t.text.length-(t.to.line-t.from.line)-1,n=e.ch;return e.line==t.to.line&&(n+=Bn(t).ch-t.to.ch),E(r,n)}function Un(e,t){for(var r=[],n=0;n<e.sel.ranges.length;n++){var i=e.sel.ranges[n];r.push(new Ts(Gn(i.anchor,t),Gn(i.head,t)))}return zn(r,e.sel.primIndex)}function Vn(e,t,r){return e.line==t.line?E(r.line,e.ch-t.ch+r.ch):E(r.line+(e.line-t.line),e.ch)}function Kn(e,t,r){for(var n=[],i=E(e.first,0),o=i,l=0;l<t.length;l++){var s=t[l],a=Vn(s.from,i,o),u=Vn(Bn(s),i,o);if(i=s.to,o=u,"around"==r){var c=e.sel.ranges[l],f=P(c.head,c.anchor)<0;n[l]=new Ts(f?u:a,f?a:u)}else n[l]=new Ts(a,a)}return new ks(n,e.sel.primIndex)}function jn(e){e.doc.mode=Ue(e.options,e.doc.modeOption),Xn(e)}function Xn(e){e.doc.iter(function(e){e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null)}),e.doc.modeFrontier=e.doc.highlightFrontier=e.doc.first,Cn(e,100),e.state.modeGen++,e.curOp&&vn(e)}function Yn(e,t){return 0==t.from.ch&&0==t.to.ch&&""==g(t.text)&&(!e.cm||e.cm.options.wholeLineUpdateBefore)}function _n(e,t,r,n){function i(e){return r?r[e]:null}function o(e,r,i){it(e,r,i,n),bt(e,"change",e,t)}function l(e,t){for(var r=[],o=e;o<t;++o)r.push(new fs(u[o],i(o),n));return r}var s=t.from,a=t.to,u=t.text,c=M(e,s.line),f=M(e,a.line),h=g(u),d=i(u.length-1),p=a.line-s.line;if(t.full)e.insert(0,l(0,u.length)),e.remove(u.length,e.size-u.length);else if(Yn(e,t)){var v=l(0,u.length-1);o(f,f.text,d),p&&e.remove(s.line,p),v.length&&e.insert(s.line,v)}else if(c==f)if(1==u.length)o(c,c.text.slice(0,s.ch)+h+c.text.slice(a.ch),d);else{var m=l(1,u.length-1);m.push(new fs(h+c.text.slice(a.ch),d,n)),o(c,c.text.slice(0,s.ch)+u[0],i(0)),e.insert(s.line+1,m)}else if(1==u.length)o(c,c.text.slice(0,s.ch)+u[0]+f.text.slice(a.ch),i(0)),e.remove(s.line+1,p);else{o(c,c.text.slice(0,s.ch)+u[0],i(0)),o(f,h+f.text.slice(a.ch),d);var y=l(1,u.length-1);p>1&&e.remove(s.line+1,p-1),e.insert(s.line+1,y)}bt(e,"change",e,t)}function $n(e,t,r){function n(e,i,o){if(e.linked)for(var l=0;l<e.linked.length;++l){var s=e.linked[l];if(s.doc!=i){var a=o&&s.sharedHist;r&&!a||(t(s.doc,a),n(s.doc,e,a))}}}n(e,null,!0)}function qn(e,t){if(t.cm)throw new Error("This document is already in use.");e.doc=t,t.cm=e,Cr(e),jn(e),Zn(e),e.options.lineWrapping||we(e),e.options.mode=t.modeOption,vn(e)}function Zn(e){("rtl"==e.doc.direction?s:Fl)(e.display.lineDiv,"CodeMirror-rtl")}function Qn(e){hn(e,function(){Zn(e),vn(e)})}function Jn(e){this.done=[],this.undone=[],this.undoDepth=1/0,this.lastModTime=this.lastSelTime=0,this.lastOp=this.lastSelOp=null,this.lastOrigin=this.lastSelOrigin=null,this.generation=this.maxGeneration=e||1}function ei(e,t){var r={from:z(t.from),to:Bn(t),text:N(e,t.from,t.to)};return si(e,r,t.from.line,t.to.line+1),$n(e,function(e){return si(e,r,t.from.line,t.to.line+1)},!0),r}function ti(e){for(;e.length&&g(e).ranges;)e.pop()}function ri(e,t){return t?(ti(e.done),g(e.done)):e.done.length&&!g(e.done).ranges?g(e.done):e.done.length>1&&!e.done[e.done.length-2].ranges?(e.done.pop(),g(e.done)):void 0}function ni(e,t,r,n){var i=e.history;i.undone.length=0;var o,l,s=+new Date;if((i.lastOp==n||i.lastOrigin==t.origin&&t.origin&&("+"==t.origin.charAt(0)&&e.cm&&i.lastModTime>s-e.cm.options.historyEventDelay||"*"==t.origin.charAt(0)))&&(o=ri(i,i.lastOp==n)))l=g(o.changes),0==P(t.from,t.to)&&0==P(t.from,l.to)?l.to=Bn(t):o.changes.push(ei(e,t));else{var a=g(i.done);for(a&&a.ranges||li(e.sel,i.done),o={changes:[ei(e,t)],generation:i.generation},i.done.push(o);i.done.length>i.undoDepth;)i.done.shift(),i.done[0].ranges||i.done.shift()}i.done.push(r),i.generation=++i.maxGeneration,i.lastModTime=i.lastSelTime=s,i.lastOp=i.lastSelOp=n,i.lastOrigin=i.lastSelOrigin=t.origin,l||Te(e,"historyAdded")}function ii(e,t,r,n){var i=t.charAt(0);return"*"==i||"+"==i&&r.ranges.length==n.ranges.length&&r.somethingSelected()==n.somethingSelected()&&new Date-e.history.lastSelTime<=(e.cm?e.cm.options.historyEventDelay:500)}function oi(e,t,r,n){var i=e.history,o=n&&n.origin;r==i.lastSelOp||o&&i.lastSelOrigin==o&&(i.lastModTime==i.lastSelTime&&i.lastOrigin==o||ii(e,o,g(i.done),t))?i.done[i.done.length-1]=t:li(t,i.done),i.lastSelTime=+new Date,i.lastSelOrigin=o,i.lastSelOp=r,n&&!1!==n.clearRedo&&ti(i.undone)}function li(e,t){var r=g(t);r&&r.ranges&&r.equals(e)||t.push(e)}function si(e,t,r,n){var i=t["spans_"+e.id],o=0;e.iter(Math.max(e.first,r),Math.min(e.first+e.size,n),function(r){r.markedSpans&&((i||(i=t["spans_"+e.id]={}))[o]=r.markedSpans),++o})}function ai(e){if(!e)return null;for(var t,r=0;r<e.length;++r)e[r].marker.explicitlyCleared?t||(t=e.slice(0,r)):t&&t.push(e[r]);return t?t.length?t:null:e}function ui(e,t){var r=t["spans_"+e.id];if(!r)return null;for(var n=[],i=0;i<t.text.length;++i)n.push(ai(r[i]));return n}function ci(e,t){var r=ui(e,t),n=J(e,t);if(!r)return n;if(!n)return r;for(var i=0;i<r.length;++i){var o=r[i],l=n[i];if(o&&l)e:for(var s=0;s<l.length;++s){for(var a=l[s],u=0;u<o.length;++u)if(o[u].marker==a.marker)continue e;o.push(a)}else l&&(r[i]=l)}return r}function fi(e,t,r){for(var n=[],i=0;i<e.length;++i){var o=e[i];if(o.ranges)n.push(r?ks.prototype.deepCopy.call(o):o);else{var l=o.changes,s=[];n.push({changes:s});for(var a=0;a<l.length;++a){var u=l[a],c=void 0;if(s.push({from:u.from,to:u.to,text:u.text}),t)for(var f in u)(c=f.match(/^spans_(\d+)$/))&&h(t,Number(c[1]))>-1&&(g(s)[f]=u[f],delete u[f])}}}return n}function hi(e,t,r,n){if(n){var i=e.anchor;if(r){var o=P(t,i)<0;o!=P(r,i)<0?(i=t,t=r):o!=P(t,r)<0&&(t=r)}return new Ts(i,t)}return new Ts(r||t,t)}function di(e,t,r,n,i){null==i&&(i=e.cm&&(e.cm.display.shift||e.extend)),bi(e,new ks([hi(e.sel.primary(),t,r,i)],0),n)}function pi(e,t,r){for(var n=[],i=e.cm&&(e.cm.display.shift||e.extend),o=0;o<e.sel.ranges.length;o++)n[o]=hi(e.sel.ranges[o],t[o],null,i);bi(e,zn(n,e.sel.primIndex),r)}function gi(e,t,r,n){var i=e.sel.ranges.slice(0);i[t]=r,bi(e,zn(i,e.sel.primIndex),n)}function vi(e,t,r,n){bi(e,Rn(t,r),n)}function mi(e,t,r){var n={ranges:t.ranges,update:function(t){var r=this;this.ranges=[];for(var n=0;n<t.length;n++)r.ranges[n]=new Ts(U(e,t[n].anchor),U(e,t[n].head))},origin:r&&r.origin};return Te(e,"beforeSelectionChange",e,n),e.cm&&Te(e.cm,"beforeSelectionChange",e.cm,n),n.ranges!=t.ranges?zn(n.ranges,n.ranges.length-1):t}function yi(e,t,r){var n=e.history.done,i=g(n);i&&i.ranges?(n[n.length-1]=t,wi(e,t,r)):bi(e,t,r)}function bi(e,t,r){wi(e,t,r),oi(e,e.sel,e.cm?e.cm.curOp.id:NaN,r)}function wi(e,t,r){(Oe(e,"beforeSelectionChange")||e.cm&&Oe(e.cm,"beforeSelectionChange"))&&(t=mi(e,t,r)),xi(e,Si(e,t,r&&r.bias||(P(t.primary().head,e.sel.primary().head)<0?-1:1),!0)),r&&!1===r.scroll||!e.cm||jr(e.cm)}function xi(e,t){t.equals(e.sel)||(e.sel=t,e.cm&&(e.cm.curOp.updateInput=e.cm.curOp.selectionChanged=!0,Ne(e.cm)),bt(e,"cursorActivity",e))}function Ci(e){xi(e,Si(e,e.sel,null,!1))}function Si(e,t,r,n){for(var i,o=0;o<t.ranges.length;o++){var l=t.ranges[o],s=t.ranges.length==e.sel.ranges.length&&e.sel.ranges[o],a=ki(e,l.anchor,s&&s.anchor,r,n),u=ki(e,l.head,s&&s.head,r,n);(i||a!=l.anchor||u!=l.head)&&(i||(i=t.ranges.slice(0,o)),i[o]=new Ts(a,u))}return i?zn(i,t.primIndex):t}function Li(e,t,r,n,i){var o=M(e,t.line);if(o.markedSpans)for(var l=0;l<o.markedSpans.length;++l){var s=o.markedSpans[l],a=s.marker;if((null==s.from||(a.inclusiveLeft?s.from<=t.ch:s.from<t.ch))&&(null==s.to||(a.inclusiveRight?s.to>=t.ch:s.to>t.ch))){if(i&&(Te(a,"beforeCursorEnter"),a.explicitlyCleared)){if(o.markedSpans){--l;continue}break}if(!a.atomic)continue;if(r){var u=a.find(n<0?1:-1),c=void 0;if((n<0?a.inclusiveRight:a.inclusiveLeft)&&(u=Ti(e,u,-n,u&&u.line==t.line?o:null)),u&&u.line==t.line&&(c=P(u,r))&&(n<0?c<0:c>0))return Li(e,u,t,n,i)}var f=a.find(n<0?-1:1);return(n<0?a.inclusiveLeft:a.inclusiveRight)&&(f=Ti(e,f,n,f.line==t.line?o:null)),f?Li(e,f,t,n,i):null}}return t}function ki(e,t,r,n,i){var o=n||1,l=Li(e,t,r,o,i)||!i&&Li(e,t,r,o,!0)||Li(e,t,r,-o,i)||!i&&Li(e,t,r,-o,!0);return l||(e.cantEdit=!0,E(e.first,0))}function Ti(e,t,r,n){return r<0&&0==t.ch?t.line>e.first?U(e,E(t.line-1)):null:r>0&&t.ch==(n||M(e,t.line)).text.length?t.line<e.first+e.size-1?E(t.line+1,0):null:new E(t.line,t.ch+r)}function Mi(e){e.setSelection(E(e.firstLine(),0),E(e.lastLine()),Gl)}function Ni(e,t,r){var n={canceled:!1,from:t.from,to:t.to,text:t.text,origin:t.origin,cancel:function(){return n.canceled=!0}};return r&&(n.update=function(t,r,i,o){t&&(n.from=U(e,t)),r&&(n.to=U(e,r)),i&&(n.text=i),void 0!==o&&(n.origin=o)}),Te(e,"beforeChange",e,n),e.cm&&Te(e.cm,"beforeChange",e.cm,n),n.canceled?null:{from:n.from,to:n.to,text:n.text,origin:n.origin}}function Oi(e,t,r){if(e.cm){if(!e.cm.curOp)return dn(e.cm,Oi)(e,t,r);if(e.cm.state.suppressEdits)return}if(!(Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"))||(t=Ni(e,t,!0))){var n=Yl&&!r&&te(e,t.from,t.to);if(n)for(var i=n.length-1;i>=0;--i)Ai(e,{from:n[i].from,to:n[i].to,text:i?[""]:t.text,origin:t.origin});else Ai(e,t)}}function Ai(e,t){if(1!=t.text.length||""!=t.text[0]||0!=P(t.from,t.to)){var r=Un(e,t);ni(e,t,r,e.cm?e.cm.curOp.id:NaN),Hi(e,t,r,J(e,t));var n=[];$n(e,function(e,r){r||-1!=h(n,e.history)||(zi(e.history,t),n.push(e.history)),Hi(e,t,null,J(e,t))})}}function Wi(e,t,r){if(!e.cm||!e.cm.state.suppressEdits||r){for(var n,i=e.history,o=e.sel,l="undo"==t?i.done:i.undone,s="undo"==t?i.undone:i.done,a=0;a<l.length&&(n=l[a],r?!n.ranges||n.equals(e.sel):n.ranges);a++);if(a!=l.length){for(i.lastOrigin=i.lastSelOrigin=null;(n=l.pop()).ranges;){if(li(n,s),r&&!n.equals(e.sel))return void bi(e,n,{clearRedo:!1});o=n}var u=[];li(o,s),s.push({changes:u,generation:i.generation}),i.generation=n.generation||++i.maxGeneration;for(var c=Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"),f=n.changes.length-1;f>=0;--f){var d=function(r){var i=n.changes[r];if(i.origin=t,c&&!Ni(e,i,!1))return l.length=0,{};u.push(ei(e,i));var o=r?Un(e,i):g(l);Hi(e,i,o,ci(e,i)),!r&&e.cm&&e.cm.scrollIntoView({from:i.from,to:Bn(i)});var s=[];$n(e,function(e,t){t||-1!=h(s,e.history)||(zi(e.history,i),s.push(e.history)),Hi(e,i,null,ci(e,i))})}(f);if(d)return d.v}}}}function Di(e,t){if(0!=t&&(e.first+=t,e.sel=new ks(v(e.sel.ranges,function(e){return new Ts(E(e.anchor.line+t,e.anchor.ch),E(e.head.line+t,e.head.ch))}),e.sel.primIndex),e.cm)){vn(e.cm,e.first,e.first-t,t);for(var r=e.cm.display,n=r.viewFrom;n<r.viewTo;n++)mn(e.cm,n,"gutter")}}function Hi(e,t,r,n){if(e.cm&&!e.cm.curOp)return dn(e.cm,Hi)(e,t,r,n);if(t.to.line<e.first)Di(e,t.text.length-1-(t.to.line-t.from.line));else if(!(t.from.line>e.lastLine())){if(t.from.line<e.first){var i=t.text.length-1-(e.first-t.from.line);Di(e,i),t={from:E(e.first,0),to:E(t.to.line+i,t.to.ch),text:[g(t.text)],origin:t.origin}}var o=e.lastLine();t.to.line>o&&(t={from:t.from,to:E(o,M(e,o).text.length),text:[t.text[0]],origin:t.origin}),t.removed=N(e,t.from,t.to),r||(r=Un(e,t)),e.cm?Fi(e.cm,t,n):_n(e,t,n),wi(e,r,Gl)}}function Fi(e,t,r){var n=e.doc,i=e.display,o=t.from,l=t.to,s=!1,a=o.line;e.options.lineWrapping||(a=W(fe(M(n,o.line))),n.iter(a,l.line+1,function(e){if(e==i.maxLine)return s=!0,!0})),n.sel.contains(t.from,t.to)>-1&&Ne(e),_n(n,t,r,xr(e)),e.options.lineWrapping||(n.iter(a,o.line+t.text.length,function(e){var t=be(e);t>i.maxLineLength&&(i.maxLine=e,i.maxLineLength=t,i.maxLineChanged=!0,s=!1)}),s&&(e.curOp.updateMaxLine=!0)),nt(n,o.line),Cn(e,400);var u=t.text.length-(l.line-o.line)-1;t.full?vn(e):o.line!=l.line||1!=t.text.length||Yn(e.doc,t)?vn(e,o.line,l.line+1,u):mn(e,o.line,"text");var c=Oe(e,"changes"),f=Oe(e,"change");if(f||c){var h={from:o,to:l,text:t.text,removed:t.removed,origin:t.origin};f&&bt(e,"change",e,h),c&&(e.curOp.changeObjs||(e.curOp.changeObjs=[])).push(h)}e.display.selForContextMenu=null}function Ei(e,t,r,n,i){if(n||(n=r),P(n,r)<0){var o;r=(o=[n,r])[0],n=o[1]}"string"==typeof t&&(t=e.splitLines(t)),Oi(e,{from:r,to:n,text:t,origin:i})}function Pi(e,t,r,n){r<e.line?e.line+=n:t<e.line&&(e.line=t,e.ch=0)}function Ii(e,t,r,n){for(var i=0;i<e.length;++i){var o=e[i],l=!0;if(o.ranges){o.copied||((o=e[i]=o.deepCopy()).copied=!0);for(var s=0;s<o.ranges.length;s++)Pi(o.ranges[s].anchor,t,r,n),Pi(o.ranges[s].head,t,r,n)}else{for(var a=0;a<o.changes.length;++a){var u=o.changes[a];if(r<u.from.line)u.from=E(u.from.line+n,u.from.ch),u.to=E(u.to.line+n,u.to.ch);else if(t<=u.to.line){l=!1;break}}l||(e.splice(0,i+1),i=0)}}}function zi(e,t){var r=t.from.line,n=t.to.line,i=t.text.length-(n-r)-1;Ii(e.done,r,n,i),Ii(e.undone,r,n,i)}function Ri(e,t,r,n){var i=t,o=t;return"number"==typeof t?o=M(e,G(e,t)):i=W(t),null==i?null:(n(o,i)&&e.cm&&mn(e.cm,i,r),o)}function Bi(e){var t=this;this.lines=e,this.parent=null;for(var r=0,n=0;n<e.length;++n)e[n].parent=t,r+=e[n].height;this.height=r}function Gi(e){var t=this;this.children=e;for(var r=0,n=0,i=0;i<e.length;++i){var o=e[i];r+=o.chunkSize(),n+=o.height,o.parent=t}this.size=r,this.height=n,this.parent=null}function Ui(e,t,r){ye(t)<(e.curOp&&e.curOp.scrollTop||e.doc.scrollTop)&&Kr(e,r)}function Vi(e,t,r,n){var i=new Ms(e,r,n),o=e.cm;return o&&i.noHScroll&&(o.display.alignWidgets=!0),Ri(e,t,"widget",function(t){var r=t.widgets||(t.widgets=[]);if(null==i.insertAt?r.push(i):r.splice(Math.min(r.length-1,Math.max(0,i.insertAt)),0,i),i.line=t,o&&!ve(e,t)){var n=ye(t)<e.scrollTop;A(t,t.height+Ht(i)),n&&Kr(o,i.height),o.curOp.forceUpdate=!0}return!0}),bt(o,"lineWidgetAdded",o,i,"number"==typeof t?t:W(t)),i}function Ki(e,t,r,n,o){if(n&&n.shared)return ji(e,t,r,n,o);if(e.cm&&!e.cm.curOp)return dn(e.cm,Ki)(e,t,r,n,o);var l=new Os(e,o),s=P(t,r);if(n&&c(n,l,!1),s>0||0==s&&!1!==l.clearWhenEmpty)return l;if(l.replacedWith&&(l.collapsed=!0,l.widgetNode=i("span",[l.replacedWith],"CodeMirror-widget"),n.handleMouseEvents||l.widgetNode.setAttribute("cm-ignore-events","true"),n.insertLeft&&(l.widgetNode.insertLeft=!0)),l.collapsed){if(ce(e,t.line,t,r,l)||t.line!=r.line&&ce(e,r.line,t,r,l))throw new Error("Inserting collapsed marker partially overlapping an existing one");X()}l.addToHistory&&ni(e,{from:t,to:r,origin:"markText"},e.sel,NaN);var a,u=t.line,f=e.cm;if(e.iter(u,r.line+1,function(e){f&&l.collapsed&&!f.options.lineWrapping&&fe(e)==f.display.maxLine&&(a=!0),l.collapsed&&u!=t.line&&A(e,0),q(e,new Y(l,u==t.line?t.ch:null,u==r.line?r.ch:null)),++u}),l.collapsed&&e.iter(t.line,r.line+1,function(t){ve(e,t)&&A(t,0)}),l.clearOnEnter&&Ql(l,"beforeCursorEnter",function(){return l.clear()}),l.readOnly&&(j(),(e.history.done.length||e.history.undone.length)&&e.clearHistory()),l.collapsed&&(l.id=++Ns,l.atomic=!0),f){if(a&&(f.curOp.updateMaxLine=!0),l.collapsed)vn(f,t.line,r.line+1);else if(l.className||l.title||l.startStyle||l.endStyle||l.css)for(var h=t.line;h<=r.line;h++)mn(f,h,"text");l.atomic&&Ci(f.doc),bt(f,"markerAdded",f,l)}return l}function ji(e,t,r,n,i){(n=c(n)).shared=!1;var o=[Ki(e,t,r,n,i)],l=o[0],s=n.widgetNode;return $n(e,function(e){s&&(n.widgetNode=s.cloneNode(!0)),o.push(Ki(e,U(e,t),U(e,r),n,i));for(var a=0;a<e.linked.length;++a)if(e.linked[a].isParent)return;l=g(o)}),new As(o,l)}function Xi(e){return e.findMarks(E(e.first,0),e.clipPos(E(e.lastLine())),function(e){return e.parent})}function Yi(e,t){for(var r=0;r<t.length;r++){var n=t[r],i=n.find(),o=e.clipPos(i.from),l=e.clipPos(i.to);if(P(o,l)){var s=Ki(e,o,l,n.primary,n.primary.type);n.markers.push(s),s.parent=n}}}function _i(e){for(var t=0;t<e.length;t++)!function(t){var r=e[t],n=[r.primary.doc];$n(r.primary.doc,function(e){return n.push(e)});for(var i=0;i<r.markers.length;i++){var o=r.markers[i];-1==h(n,o.doc)&&(o.parent=null,r.markers.splice(i--,1))}}(t)}function $i(e){var t=this;if(Qi(t),!Me(t,e)&&!Ft(t.display,e)){We(e),gl&&(Hs=+new Date);var r=Sr(t,e,!0),n=e.dataTransfer.files;if(r&&!t.isReadOnly())if(n&&n.length&&window.FileReader&&window.File)for(var i=n.length,o=Array(i),l=0,s=0;s<i;++s)!function(e,n){if(!t.options.allowDropFileTypes||-1!=h(t.options.allowDropFileTypes,e.type)){var s=new FileReader;s.onload=dn(t,function(){var e=s.result;if(/[\x00-\x08\x0e-\x1f]{2}/.test(e)&&(e=""),o[n]=e,++l==i){var a={from:r=U(t.doc,r),to:r,text:t.doc.splitLines(o.join(t.doc.lineSeparator())),origin:"paste"};Oi(t.doc,a),yi(t.doc,Rn(r,Bn(a)))}}),s.readAsText(e)}}(n[s],s);else{if(t.state.draggingText&&t.doc.sel.contains(r)>-1)return t.state.draggingText(e),void setTimeout(function(){return t.display.input.focus()},20);try{var a=e.dataTransfer.getData("Text");if(a){var u;if(t.state.draggingText&&!t.state.draggingText.copy&&(u=t.listSelections()),wi(t.doc,Rn(r,r)),u)for(var c=0;c<u.length;++c)Ei(t.doc,"",u[c].anchor,u[c].head,"drag");t.replaceSelection(a,"around","paste"),t.display.input.focus()}}catch(e){}}}}function qi(e,t){if(gl&&(!e.state.draggingText||+new Date-Hs<100))Fe(t);else if(!Me(e,t)&&!Ft(e.display,t)&&(t.dataTransfer.setData("Text",e.getSelection()),t.dataTransfer.effectAllowed="copyMove",t.dataTransfer.setDragImage&&!xl)){var r=n("img",null,null,"position: fixed; left: 0; top: 0;");r.src="data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==",wl&&(r.width=r.height=1,e.display.wrapper.appendChild(r),r._top=r.offsetTop),t.dataTransfer.setDragImage(r,0,0),wl&&r.parentNode.removeChild(r)}}function Zi(e,t){var i=Sr(e,t);if(i){var o=document.createDocumentFragment();Mr(e,i,o),e.display.dragCursor||(e.display.dragCursor=n("div",null,"CodeMirror-cursors CodeMirror-dragcursors"),e.display.lineSpace.insertBefore(e.display.dragCursor,e.display.cursorDiv)),r(e.display.dragCursor,o)}}function Qi(e){e.display.dragCursor&&(e.display.lineSpace.removeChild(e.display.dragCursor),e.display.dragCursor=null)}function Ji(e){if(document.getElementsByClassName)for(var t=document.getElementsByClassName("CodeMirror"),r=0;r<t.length;r++){var n=t[r].CodeMirror;n&&e(n)}}function eo(){Fs||(to(),Fs=!0)}function to(){var e;Ql(window,"resize",function(){null==e&&(e=setTimeout(function(){e=null,Ji(ro)},100))}),Ql(window,"blur",function(){return Ji(Fr)})}function ro(e){var t=e.display;t.lastWrapHeight==t.wrapper.clientHeight&&t.lastWrapWidth==t.wrapper.clientWidth||(t.cachedCharWidth=t.cachedTextHeight=t.cachedPaddingH=null,t.scrollbarsClipped=!1,e.setSize())}function no(e){var t=e.split(/-(?!$)/);e=t[t.length-1];for(var r,n,i,o,l=0;l<t.length-1;l++){var s=t[l];if(/^(cmd|meta|m)$/i.test(s))o=!0;else if(/^a(lt)?$/i.test(s))r=!0;else if(/^(c|ctrl|control)$/i.test(s))n=!0;else{if(!/^s(hift)?$/i.test(s))throw new Error("Unrecognized modifier name: "+s);i=!0}}return r&&(e="Alt-"+e),n&&(e="Ctrl-"+e),o&&(e="Cmd-"+e),i&&(e="Shift-"+e),e}function io(e){var t={};for(var r in e)if(e.hasOwnProperty(r)){var n=e[r];if(/^(name|fallthrough|(de|at)tach)$/.test(r))continue;if("..."==n){delete e[r];continue}for(var i=v(r.split(" "),no),o=0;o<i.length;o++){var l=void 0,s=void 0;o==i.length-1?(s=i.join(" "),l=n):(s=i.slice(0,o+1).join(" "),l="...");var a=t[s];if(a){if(a!=l)throw new Error("Inconsistent bindings for "+s)}else t[s]=l}delete e[r]}for(var u in t)e[u]=t[u];return e}function oo(e,t,r,n){var i=(t=uo(t)).call?t.call(e,n):t[e];if(!1===i)return"nothing";if("..."===i)return"multi";if(null!=i&&r(i))return"handled";if(t.fallthrough){if("[object Array]"!=Object.prototype.toString.call(t.fallthrough))return oo(e,t.fallthrough,r,n);for(var o=0;o<t.fallthrough.length;o++){var l=oo(e,t.fallthrough[o],r,n);if(l)return l}}}function lo(e){var t="string"==typeof e?e:Es[e.keyCode];return"Ctrl"==t||"Alt"==t||"Shift"==t||"Mod"==t}function so(e,t,r){var n=e;return t.altKey&&"Alt"!=n&&(e="Alt-"+e),(Dl?t.metaKey:t.ctrlKey)&&"Ctrl"!=n&&(e="Ctrl-"+e),(Dl?t.ctrlKey:t.metaKey)&&"Cmd"!=n&&(e="Cmd-"+e),!r&&t.shiftKey&&"Shift"!=n&&(e="Shift-"+e),e}function ao(e,t){if(wl&&34==e.keyCode&&e.char)return!1;var r=Es[e.keyCode];return null!=r&&!e.altGraphKey&&so(r,e,t)}function uo(e){return"string"==typeof e?Rs[e]:e}function co(e,t){for(var r=e.doc.sel.ranges,n=[],i=0;i<r.length;i++){for(var o=t(r[i]);n.length&&P(o.from,g(n).to)<=0;){var l=n.pop();if(P(l.from,o.from)<0){o.from=l.from;break}}n.push(o)}hn(e,function(){for(var t=n.length-1;t>=0;t--)Ei(e.doc,"",n[t].from,n[t].to,"+delete");jr(e)})}function fo(e,t,r){var n=L(e.text,t+r,r);return n<0||n>e.text.length?null:n}function ho(e,t,r){var n=fo(e,t.ch,r);return null==n?null:new E(t.line,n,r<0?"after":"before")}function po(e,t,r,n,i){if(e){var o=Se(r,t.doc.direction);if(o){var l,s=i<0?g(o):o[0],a=i<0==(1==s.level)?"after":"before";if(s.level>0){var u=Xt(t,r);l=i<0?r.text.length-1:0;var c=Yt(t,u,l).top;l=k(function(e){return Yt(t,u,e).top==c},i<0==(1==s.level)?s.from:s.to-1,l),"before"==a&&(l=fo(r,l,1))}else l=i<0?s.to:s.from;return new E(n,l,a)}}return new E(n,i<0?r.text.length:0,i<0?"before":"after")}function go(e,t,r,n){var i=Se(t,e.doc.direction);if(!i)return ho(t,r,n);r.ch>=t.text.length?(r.ch=t.text.length,r.sticky="before"):r.ch<=0&&(r.ch=0,r.sticky="after");var o=Ce(i,r.ch,r.sticky),l=i[o];if("ltr"==e.doc.direction&&l.level%2==0&&(n>0?l.to>r.ch:l.from<r.ch))return ho(t,r,n);var s,a=function(e,r){return fo(t,e instanceof E?e.ch:e,r)},u=function(r){return e.options.lineWrapping?(s=s||Xt(e,t),hr(e,t,s,r)):{begin:0,end:t.text.length}},c=u("before"==r.sticky?a(r,-1):r.ch);if("rtl"==e.doc.direction||1==l.level){var f=1==l.level==n<0,h=a(r,f?1:-1);if(null!=h&&(f?h<=l.to&&h<=c.end:h>=l.from&&h>=c.begin)){var d=f?"before":"after";return new E(r.line,h,d)}}var p=function(e,t,n){for(var o=function(e,t){return t?new E(r.line,a(e,1),"before"):new E(r.line,e,"after")};e>=0&&e<i.length;e+=t){var l=i[e],s=t>0==(1!=l.level),u=s?n.begin:a(n.end,-1);if(l.from<=u&&u<l.to)return o(u,s);if(u=s?l.from:a(l.to,-1),n.begin<=u&&u<n.end)return o(u,s)}},g=p(o+n,n,c);if(g)return g;var v=n>0?c.end:a(c.begin,-1);return null==v||n>0&&v==t.text.length||!(g=p(n>0?0:i.length-1,n,u(v)))?null:g}function vo(e,t){var r=M(e.doc,t),n=fe(r);return n!=r&&(t=W(n)),po(!0,e,n,t,1)}function mo(e,t){var r=M(e.doc,t),n=he(r);return n!=r&&(t=W(n)),po(!0,e,r,t,-1)}function yo(e,t){var r=vo(e,t.line),n=M(e.doc,r.line),i=Se(n,e.doc.direction);if(!i||0==i[0].level){var o=Math.max(0,n.text.search(/\S/)),l=t.line==r.line&&t.ch<=o&&t.ch;return E(r.line,l?0:o,r.sticky)}return r}function bo(e,t,r){if("string"==typeof t&&!(t=Bs[t]))return!1;e.display.input.ensurePolled();var n=e.display.shift,i=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),r&&(e.display.shift=!1),i=t(e)!=Bl}finally{e.display.shift=n,e.state.suppressEdits=!1}return i}function wo(e,t,r){for(var n=0;n<e.state.keyMaps.length;n++){var i=oo(t,e.state.keyMaps[n],r,e);if(i)return i}return e.options.extraKeys&&oo(t,e.options.extraKeys,r,e)||oo(t,e.options.keyMap,r,e)}function xo(e,t,r,n){var i=e.state.keySeq;if(i){if(lo(t))return"handled";Gs.set(50,function(){e.state.keySeq==i&&(e.state.keySeq=null,e.display.input.reset())}),t=i+" "+t}var o=wo(e,t,n);return"multi"==o&&(e.state.keySeq=t),"handled"==o&&bt(e,"keyHandled",e,t,r),"handled"!=o&&"multi"!=o||(We(r),Ar(e)),i&&!o&&/\'$/.test(t)?(We(r),!0):!!o}function Co(e,t){var r=ao(t,!0);return!!r&&(t.shiftKey&&!e.state.keySeq?xo(e,"Shift-"+r,t,function(t){return bo(e,t,!0)})||xo(e,r,t,function(t){if("string"==typeof t?/^go[A-Z]/.test(t):t.motion)return bo(e,t)}):xo(e,r,t,function(t){return bo(e,t)}))}function So(e,t,r){return xo(e,"'"+r+"'",t,function(t){return bo(e,t,!0)})}function Lo(e){var t=this;if(t.curOp.focus=l(),!Me(t,e)){gl&&vl<11&&27==e.keyCode&&(e.returnValue=!1);var r=e.keyCode;t.display.shift=16==r||e.shiftKey;var n=Co(t,e);wl&&(Us=n?r:null,!n&&88==r&&!rs&&(Ml?e.metaKey:e.ctrlKey)&&t.replaceSelection("",null,"cut")),18!=r||/\bCodeMirror-crosshair\b/.test(t.display.lineDiv.className)||ko(t)}}function ko(e){function t(e){18!=e.keyCode&&e.altKey||(Fl(r,"CodeMirror-crosshair"),ke(document,"keyup",t),ke(document,"mouseover",t))}var r=e.display.lineDiv;s(r,"CodeMirror-crosshair"),Ql(document,"keyup",t),Ql(document,"mouseover",t)}function To(e){16==e.keyCode&&(this.doc.sel.shift=!1),Me(this,e)}function Mo(e){var t=this;if(!(Ft(t.display,e)||Me(t,e)||e.ctrlKey&&!e.altKey||Ml&&e.metaKey)){var r=e.keyCode,n=e.charCode;if(wl&&r==Us)return Us=null,void We(e);if(!wl||e.which&&!(e.which<10)||!Co(t,e)){var i=String.fromCharCode(null==n?r:n);"\b"!=i&&(So(t,e,i)||t.display.input.onKeyPress(e))}}}function No(e,t){var r=+new Date;return js&&js.compare(r,e,t)?(Ks=js=null,"triple"):Ks&&Ks.compare(r,e,t)?(js=new Vs(r,e,t),Ks=null,"double"):(Ks=new Vs(r,e,t),js=null,"single")}function Oo(e){var t=this,r=t.display;if(!(Me(t,e)||r.activeTouch&&r.input.supportsTouch()))if(r.input.ensurePolled(),r.shift=e.shiftKey,Ft(r,e))ml||(r.scroller.draggable=!1,setTimeout(function(){return r.scroller.draggable=!0},100));else if(!zo(t,e)){var n=Sr(t,e),i=Pe(e),o=n?No(n,i):"single";window.focus(),1==i&&t.state.selectingText&&t.state.selectingText(e),n&&Ao(t,i,n,o,e)||(1==i?n?Do(t,n,o,e):Ee(e)==r.scroller&&We(e):2==i?(n&&di(t.doc,n),setTimeout(function(){return r.input.focus()},20)):3==i&&(Hl?Ro(t,e):Dr(t)))}}function Ao(e,t,r,n,i){var o="Click";return"double"==n?o="Double"+o:"triple"==n&&(o="Triple"+o),o=(1==t?"Left":2==t?"Middle":"Right")+o,xo(e,so(o,i),i,function(t){if("string"==typeof t&&(t=Bs[t]),!t)return!1;var n=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),n=t(e,r)!=Bl}finally{e.state.suppressEdits=!1}return n})}function Wo(e,t,r){var n=e.getOption("configureMouse"),i=n?n(e,t,r):{};if(null==i.unit){var o=Nl?r.shiftKey&&r.metaKey:r.altKey;i.unit=o?"rectangle":"single"==t?"char":"double"==t?"word":"line"}return(null==i.extend||e.doc.extend)&&(i.extend=e.doc.extend||r.shiftKey),null==i.addNew&&(i.addNew=Ml?r.metaKey:r.ctrlKey),null==i.moveOnDrag&&(i.moveOnDrag=!(Ml?r.altKey:r.ctrlKey)),i}function Do(e,t,r,n){gl?setTimeout(u(Wr,e),0):e.curOp.focus=l();var i,o=Wo(e,r,n),s=e.doc.sel;e.options.dragDrop&&Jl&&!e.isReadOnly()&&"single"==r&&(i=s.contains(t))>-1&&(P((i=s.ranges[i]).from(),t)<0||t.xRel>0)&&(P(i.to(),t)>0||t.xRel<0)?Ho(e,n,t,o):Eo(e,n,t,o)}function Ho(e,t,r,n){var i=e.display,o=!1,l=dn(e,function(t){ml&&(i.scroller.draggable=!1),e.state.draggingText=!1,ke(document,"mouseup",l),ke(document,"mousemove",s),ke(i.scroller,"dragstart",a),ke(i.scroller,"drop",l),o||(We(t),n.addNew||di(e.doc,r,null,null,n.extend),ml||gl&&9==vl?setTimeout(function(){document.body.focus(),i.input.focus()},20):i.input.focus())}),s=function(e){o=o||Math.abs(t.clientX-e.clientX)+Math.abs(t.clientY-e.clientY)>=10},a=function(){return o=!0};ml&&(i.scroller.draggable=!0),e.state.draggingText=l,l.copy=!n.moveOnDrag,i.scroller.dragDrop&&i.scroller.dragDrop(),Ql(document,"mouseup",l),Ql(document,"mousemove",s),Ql(i.scroller,"dragstart",a),Ql(i.scroller,"drop",l),Dr(e),setTimeout(function(){return i.input.focus()},20)}function Fo(e,t,r){if("char"==r)return new Ts(t,t);if("word"==r)return e.findWordAt(t);if("line"==r)return new Ts(E(t.line,0),U(e.doc,E(t.line+1,0)));var n=r(e,t);return new Ts(n.from,n.to)}function Eo(e,t,r,n){function i(t){if(0!=P(m,t))if(m=t,"rectangle"==n.unit){for(var i=[],o=e.options.tabSize,l=f(M(u,r.line).text,r.ch,o),s=f(M(u,t.line).text,t.ch,o),a=Math.min(l,s),g=Math.max(l,s),v=Math.min(r.line,t.line),y=Math.min(e.lastLine(),Math.max(r.line,t.line));v<=y;v++){var b=M(u,v).text,w=d(b,a,o);a==g?i.push(new Ts(E(v,w),E(v,w))):b.length>w&&i.push(new Ts(E(v,w),E(v,d(b,g,o))))}i.length||i.push(new Ts(r,r)),bi(u,zn(p.ranges.slice(0,h).concat(i),h),{origin:"*mouse",scroll:!1}),e.scrollIntoView(t)}else{var x,C=c,S=Fo(e,t,n.unit),L=C.anchor;P(S.anchor,L)>0?(x=S.head,L=B(C.from(),S.anchor)):(x=S.anchor,L=R(C.to(),S.head));var k=p.ranges.slice(0);k[h]=Po(e,new Ts(U(u,L),x)),bi(u,zn(k,h),Ul)}}function o(t){var r=++b,s=Sr(e,t,!0,"rectangle"==n.unit);if(s)if(0!=P(s,m)){e.curOp.focus=l(),i(s);var c=Ir(a,u);(s.line>=c.to||s.line<c.from)&&setTimeout(dn(e,function(){b==r&&o(t)}),150)}else{var f=t.clientY<y.top?-20:t.clientY>y.bottom?20:0;f&&setTimeout(dn(e,function(){b==r&&(a.scroller.scrollTop+=f,o(t))}),50)}}function s(t){e.state.selectingText=!1,b=1/0,We(t),a.input.focus(),ke(document,"mousemove",w),ke(document,"mouseup",x),u.history.lastSelOrigin=null}var a=e.display,u=e.doc;We(t);var c,h,p=u.sel,g=p.ranges;if(n.addNew&&!n.extend?(h=u.sel.contains(r),c=h>-1?g[h]:new Ts(r,r)):(c=u.sel.primary(),h=u.sel.primIndex),"rectangle"==n.unit)n.addNew||(c=new Ts(r,r)),r=Sr(e,t,!0,!0),h=-1;else{var v=Fo(e,r,n.unit);c=n.extend?hi(c,v.anchor,v.head,n.extend):v}n.addNew?-1==h?(h=g.length,bi(u,zn(g.concat([c]),h),{scroll:!1,origin:"*mouse"})):g.length>1&&g[h].empty()&&"char"==n.unit&&!n.extend?(bi(u,zn(g.slice(0,h).concat(g.slice(h+1)),0),{scroll:!1,origin:"*mouse"}),p=u.sel):gi(u,h,c,Ul):(h=0,bi(u,new ks([c],0),Ul),p=u.sel);var m=r,y=a.wrapper.getBoundingClientRect(),b=0,w=dn(e,function(e){Pe(e)?o(e):s(e)}),x=dn(e,s);e.state.selectingText=x,Ql(document,"mousemove",w),Ql(document,"mouseup",x)}function Po(e,t){var r=t.anchor,n=t.head,i=M(e.doc,r.line);if(0==P(r,n)&&r.sticky==n.sticky)return t;var o=Se(i);if(!o)return t;var l=Ce(o,r.ch,r.sticky),s=o[l];if(s.from!=r.ch&&s.to!=r.ch)return t;var a=l+(s.from==r.ch==(1!=s.level)?0:1);if(0==a||a==o.length)return t;var u;if(n.line!=r.line)u=(n.line-r.line)*("ltr"==e.doc.direction?1:-1)>0;else{var c=Ce(o,n.ch,n.sticky),f=c-l||(n.ch-r.ch)*(1==s.level?-1:1);u=c==a-1||c==a?f<0:f>0}var h=o[a+(u?-1:0)],d=u==(1==h.level),p=d?h.from:h.to,g=d?"after":"before";return r.ch==p&&r.sticky==g?t:new Ts(new E(r.line,p,g),n)}function Io(e,t,r,n){var i,o;if(t.touches)i=t.touches[0].clientX,o=t.touches[0].clientY;else try{i=t.clientX,o=t.clientY}catch(t){return!1}if(i>=Math.floor(e.display.gutters.getBoundingClientRect().right))return!1;n&&We(t);var l=e.display,s=l.lineDiv.getBoundingClientRect();if(o>s.bottom||!Oe(e,r))return He(t);o-=s.top-l.viewOffset;for(var a=0;a<e.options.gutters.length;++a){var u=l.gutters.childNodes[a];if(u&&u.getBoundingClientRect().right>=i)return Te(e,r,e,D(e.doc,o),e.options.gutters[a],t),He(t)}}function zo(e,t){return Io(e,t,"gutterClick",!0)}function Ro(e,t){Ft(e.display,t)||Bo(e,t)||Me(e,t,"contextmenu")||e.display.input.onContextMenu(t)}function Bo(e,t){return!!Oe(e,"gutterContextMenu")&&Io(e,t,"gutterContextMenu",!1)}function Go(e){e.display.wrapper.className=e.display.wrapper.className.replace(/\s*cm-s-\S+/g,"")+e.options.theme.replace(/(^|\s)\s*/g," cm-s-"),er(e)}function Uo(e){Hn(e),vn(e),zr(e)}function Vo(e,t,r){if(!t!=!(r&&r!=Xs)){var n=e.display.dragFunctions,i=t?Ql:ke;i(e.display.scroller,"dragstart",n.start),i(e.display.scroller,"dragenter",n.enter),i(e.display.scroller,"dragover",n.over),i(e.display.scroller,"dragleave",n.leave),i(e.display.scroller,"drop",n.drop)}}function Ko(e){e.options.lineWrapping?(s(e.display.wrapper,"CodeMirror-wrap"),e.display.sizer.style.minWidth="",e.display.sizerWidth=null):(Fl(e.display.wrapper,"CodeMirror-wrap"),we(e)),Cr(e),vn(e),er(e),setTimeout(function(){return en(e)},100)}function jo(e,t){var r=this;if(!(this instanceof jo))return new jo(e,t);this.options=t=t?c(t):{},c(Ys,t,!1),Fn(t);var n=t.value;"string"==typeof n&&(n=new Ds(n,t.mode,null,t.lineSeparator,t.direction)),this.doc=n;var i=new jo.inputStyles[t.inputStyle](this),o=this.display=new T(e,n,i);o.wrapper.CodeMirror=this,Hn(this),Go(this),t.lineWrapping&&(this.display.wrapper.className+=" CodeMirror-wrap"),rn(this),this.state={keyMaps:[],overlays:[],modeGen:0,overwrite:!1,delayingBlurEvent:!1,focused:!1,suppressEdits:!1,pasteIncoming:!1,cutIncoming:!1,selectingText:!1,draggingText:!1,highlight:new Pl,keySeq:null,specialChars:null},t.autofocus&&!Tl&&o.input.focus(),gl&&vl<11&&setTimeout(function(){return r.display.input.reset(!0)},20),Xo(this),eo(),nn(this),this.curOp.forceUpdate=!0,qn(this,n),t.autofocus&&!Tl||this.hasFocus()?setTimeout(u(Hr,this),20):Fr(this);for(var l in _s)_s.hasOwnProperty(l)&&_s[l](r,t[l],Xs);Rr(this),t.finishInit&&t.finishInit(this);for(var s=0;s<$s.length;++s)$s[s](r);on(this),ml&&t.lineWrapping&&"optimizelegibility"==getComputedStyle(o.lineDiv).textRendering&&(o.lineDiv.style.textRendering="auto")}function Xo(e){function t(){i.activeTouch&&(o=setTimeout(function(){return i.activeTouch=null},1e3),(l=i.activeTouch).end=+new Date)}function r(e){if(1!=e.touches.length)return!1;var t=e.touches[0];return t.radiusX<=1&&t.radiusY<=1}function n(e,t){if(null==t.left)return!0;var r=t.left-e.left,n=t.top-e.top;return r*r+n*n>400}var i=e.display;Ql(i.scroller,"mousedown",dn(e,Oo)),gl&&vl<11?Ql(i.scroller,"dblclick",dn(e,function(t){if(!Me(e,t)){var r=Sr(e,t);if(r&&!zo(e,t)&&!Ft(e.display,t)){We(t);var n=e.findWordAt(r);di(e.doc,n.anchor,n.head)}}})):Ql(i.scroller,"dblclick",function(t){return Me(e,t)||We(t)}),Hl||Ql(i.scroller,"contextmenu",function(t){return Ro(e,t)});var o,l={end:0};Ql(i.scroller,"touchstart",function(t){if(!Me(e,t)&&!r(t)&&!zo(e,t)){i.input.ensurePolled(),clearTimeout(o);var n=+new Date;i.activeTouch={start:n,moved:!1,prev:n-l.end<=300?l:null},1==t.touches.length&&(i.activeTouch.left=t.touches[0].pageX,i.activeTouch.top=t.touches[0].pageY)}}),Ql(i.scroller,"touchmove",function(){i.activeTouch&&(i.activeTouch.moved=!0)}),Ql(i.scroller,"touchend",function(r){var o=i.activeTouch;if(o&&!Ft(i,r)&&null!=o.left&&!o.moved&&new Date-o.start<300){var l,s=e.coordsChar(i.activeTouch,"page");l=!o.prev||n(o,o.prev)?new Ts(s,s):!o.prev.prev||n(o,o.prev.prev)?e.findWordAt(s):new Ts(E(s.line,0),U(e.doc,E(s.line+1,0))),e.setSelection(l.anchor,l.head),e.focus(),We(r)}t()}),Ql(i.scroller,"touchcancel",t),Ql(i.scroller,"scroll",function(){i.scroller.clientHeight&&(qr(e,i.scroller.scrollTop),Qr(e,i.scroller.scrollLeft,!0),Te(e,"scroll",e))}),Ql(i.scroller,"mousewheel",function(t){return In(e,t)}),Ql(i.scroller,"DOMMouseScroll",function(t){return In(e,t)}),Ql(i.wrapper,"scroll",function(){return i.wrapper.scrollTop=i.wrapper.scrollLeft=0}),i.dragFunctions={enter:function(t){Me(e,t)||Fe(t)},over:function(t){Me(e,t)||(Zi(e,t),Fe(t))},start:function(t){return qi(e,t)},drop:dn(e,$i),leave:function(t){Me(e,t)||Qi(e)}};var s=i.input.getField();Ql(s,"keyup",function(t){return To.call(e,t)}),Ql(s,"keydown",dn(e,Lo)),Ql(s,"keypress",dn(e,Mo)),Ql(s,"focus",function(t){return Hr(e,t)}),Ql(s,"blur",function(t){return Fr(e,t)})}function Yo(e,t,r,n){var i,o=e.doc;null==r&&(r="add"),"smart"==r&&(o.mode.indent?i=$e(e,t).state:r="prev");var l=e.options.tabSize,s=M(o,t),a=f(s.text,null,l);s.stateAfter&&(s.stateAfter=null);var u,c=s.text.match(/^\s*/)[0];if(n||/\S/.test(s.text)){if("smart"==r&&((u=o.mode.indent(i,s.text.slice(c.length),s.text))==Bl||u>150)){if(!n)return;r="prev"}}else u=0,r="not";"prev"==r?u=t>o.first?f(M(o,t-1).text,null,l):0:"add"==r?u=a+e.options.indentUnit:"subtract"==r?u=a-e.options.indentUnit:"number"==typeof r&&(u=a+r),u=Math.max(0,u);var h="",d=0;if(e.options.indentWithTabs)for(var g=Math.floor(u/l);g;--g)d+=l,h+="\t";if(d<u&&(h+=p(u-d)),h!=c)return Ei(o,h,E(t,0),E(t,c.length),"+input"),s.stateAfter=null,!0;for(var v=0;v<o.sel.ranges.length;v++){var m=o.sel.ranges[v];if(m.head.line==t&&m.head.ch<c.length){var y=E(t,c.length);gi(o,v,new Ts(y,y));break}}}function _o(e){qs=e}function $o(e,t,r,n,i){var o=e.doc;e.display.shift=!1,n||(n=o.sel);var l=e.state.pasteIncoming||"paste"==i,s=es(t),a=null;if(l&&n.ranges.length>1)if(qs&&qs.text.join("\n")==t){if(n.ranges.length%qs.text.length==0){a=[];for(var u=0;u<qs.text.length;u++)a.push(o.splitLines(qs.text[u]))}}else s.length==n.ranges.length&&e.options.pasteLinesPerSelection&&(a=v(s,function(e){return[e]}));for(var c,f=n.ranges.length-1;f>=0;f--){var h=n.ranges[f],d=h.from(),p=h.to();h.empty()&&(r&&r>0?d=E(d.line,d.ch-r):e.state.overwrite&&!l?p=E(p.line,Math.min(M(o,p.line).text.length,p.ch+g(s).length)):qs&&qs.lineWise&&qs.text.join("\n")==t&&(d=p=E(d.line,0))),c=e.curOp.updateInput;var m={from:d,to:p,text:a?a[f%a.length]:s,origin:i||(l?"paste":e.state.cutIncoming?"cut":"+input")};Oi(e.doc,m),bt(e,"inputRead",e,m)}t&&!l&&Zo(e,t),jr(e),e.curOp.updateInput=c,e.curOp.typing=!0,e.state.pasteIncoming=e.state.cutIncoming=!1}function qo(e,t){var r=e.clipboardData&&e.clipboardData.getData("Text");if(r)return e.preventDefault(),t.isReadOnly()||t.options.disableInput||hn(t,function(){return $o(t,r,0,null,"paste")}),!0}function Zo(e,t){if(e.options.electricChars&&e.options.smartIndent)for(var r=e.doc.sel,n=r.ranges.length-1;n>=0;n--){var i=r.ranges[n];if(!(i.head.ch>100||n&&r.ranges[n-1].head.line==i.head.line)){var o=e.getModeAt(i.head),l=!1;if(o.electricChars){for(var s=0;s<o.electricChars.length;s++)if(t.indexOf(o.electricChars.charAt(s))>-1){l=Yo(e,i.head.line,"smart");break}}else o.electricInput&&o.electricInput.test(M(e.doc,i.head.line).text.slice(0,i.head.ch))&&(l=Yo(e,i.head.line,"smart"));l&&bt(e,"electricInput",e,i.head.line)}}}function Qo(e){for(var t=[],r=[],n=0;n<e.doc.sel.ranges.length;n++){var i=e.doc.sel.ranges[n].head.line,o={anchor:E(i,0),head:E(i+1,0)};r.push(o),t.push(e.getRange(o.anchor,o.head))}return{text:t,ranges:r}}function Jo(e,t){e.setAttribute("autocorrect","off"),e.setAttribute("autocapitalize","off"),e.setAttribute("spellcheck",!!t)}function el(){var e=n("textarea",null,null,"position: absolute; bottom: -1em; padding: 0; width: 1px; height: 1em; outline: none"),t=n("div",[e],null,"overflow: hidden; position: relative; width: 3px; height: 0px;");return ml?e.style.width="1000px":e.setAttribute("wrap","off"),Ll&&(e.style.border="1px solid black"),Jo(e),t}function tl(e,t,r,n,i){function o(){var n=t.line+r;return!(n<e.first||n>=e.first+e.size)&&(t=new E(n,t.ch,t.sticky),u=M(e,n))}function l(n){var l;if(null==(l=i?go(e.cm,u,t,r):ho(u,t,r))){if(n||!o())return!1;t=po(i,e.cm,u,t.line,r)}else t=l;return!0}var s=t,a=r,u=M(e,t.line);if("char"==n)l();else if("column"==n)l(!0);else if("word"==n||"group"==n)for(var c=null,f="group"==n,h=e.cm&&e.cm.getHelper(t,"wordChars"),d=!0;!(r<0)||l(!d);d=!1){var p=u.text.charAt(t.ch)||"\n",g=x(p,h)?"w":f&&"\n"==p?"n":!f||/\s/.test(p)?null:"p";if(!f||d||g||(g="s"),c&&c!=g){r<0&&(r=1,l(),t.sticky="after");break}if(g&&(c=g),r>0&&!l(!d))break}var v=ki(e,t,s,a,!0);return I(s,v)&&(v.hitSide=!0),v}function rl(e,t,r,n){var i,o=e.doc,l=t.left;if("page"==n){var s=Math.min(e.display.wrapper.clientHeight,window.innerHeight||document.documentElement.clientHeight),a=Math.max(s-.5*mr(e.display),3);i=(r>0?t.bottom:t.top)+r*a}else"line"==n&&(i=r>0?t.bottom+3:t.top-3);for(var u;(u=cr(e,l,i)).outside;){if(r<0?i<=0:i>=o.height){u.hitSide=!0;break}i+=5*r}return u}function nl(e,t){var r=jt(e,t.line);if(!r||r.hidden)return null;var n=M(e.doc,t.line),i=Ut(r,n,t.line),o=Se(n,e.doc.direction),l="left";o&&(l=Ce(o,t.ch)%2?"right":"left");var s=_t(i.map,t.ch,l);return s.offset="right"==s.collapse?s.end:s.start,s}function il(e){for(var t=e;t;t=t.parentNode)if(/CodeMirror-gutter-wrapper/.test(t.className))return!0;return!1}function ol(e,t){return t&&(e.bad=!0),e}function ll(e,t,r,n,i){function o(e){return function(t){return t.id==e}}function l(){c&&(u+=f,c=!1)}function s(e){e&&(l(),u+=e)}function a(t){if(1==t.nodeType){var r=t.getAttribute("cm-text");if(null!=r)return void s(r||t.textContent.replace(/\u200b/g,""));var u,h=t.getAttribute("cm-marker");if(h){var d=e.findMarks(E(n,0),E(i+1,0),o(+h));return void(d.length&&(u=d[0].find(0))&&s(N(e.doc,u.from,u.to).join(f)))}if("false"==t.getAttribute("contenteditable"))return;var p=/^(pre|div|p)$/i.test(t.nodeName);p&&l();for(var g=0;g<t.childNodes.length;g++)a(t.childNodes[g]);p&&(c=!0)}else 3==t.nodeType&&s(t.nodeValue)}for(var u="",c=!1,f=e.doc.lineSeparator();a(t),t!=r;)t=t.nextSibling;return u}function sl(e,t,r){var n;if(t==e.display.lineDiv){if(!(n=e.display.lineDiv.childNodes[r]))return ol(e.clipPos(E(e.display.viewTo-1)),!0);t=null,r=0}else for(n=t;;n=n.parentNode){if(!n||n==e.display.lineDiv)return null;if(n.parentNode&&n.parentNode==e.display.lineDiv)break}for(var i=0;i<e.display.view.length;i++){var o=e.display.view[i];if(o.node==n)return al(o,t,r)}}function al(e,t,r){function n(t,r,n){for(var i=-1;i<(f?f.length:0);i++)for(var o=i<0?c.map:f[i],l=0;l<o.length;l+=3){var s=o[l+2];if(s==t||s==r){var a=W(i<0?e.line:e.rest[i]),u=o[l]+n;return(n<0||s!=t)&&(u=o[l+(n?1:0)]),E(a,u)}}}var i=e.text.firstChild,l=!1;if(!t||!o(i,t))return ol(E(W(e.line),0),!0);if(t==i&&(l=!0,t=i.childNodes[r],r=0,!t)){var s=e.rest?g(e.rest):e.line;return ol(E(W(s),s.text.length),l)}var a=3==t.nodeType?t:null,u=t;for(a||1!=t.childNodes.length||3!=t.firstChild.nodeType||(a=t.firstChild,r&&(r=a.nodeValue.length));u.parentNode!=i;)u=u.parentNode;var c=e.measure,f=c.maps,h=n(a,u,r);if(h)return ol(h,l);for(var d=u.nextSibling,p=a?a.nodeValue.length-r:0;d;d=d.nextSibling){if(h=n(d,d.firstChild,0))return ol(E(h.line,h.ch-p),l);p+=d.textContent.length}for(var v=u.previousSibling,m=r;v;v=v.previousSibling){if(h=n(v,v.firstChild,-1))return ol(E(h.line,h.ch+m),l);m+=v.textContent.length}}var ul=navigator.userAgent,cl=navigator.platform,fl=/gecko\/\d/i.test(ul),hl=/MSIE \d/.test(ul),dl=/Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(ul),pl=/Edge\/(\d+)/.exec(ul),gl=hl||dl||pl,vl=gl&&(hl?document.documentMode||6:+(pl||dl)[1]),ml=!pl&&/WebKit\//.test(ul),yl=ml&&/Qt\/\d+\.\d+/.test(ul),bl=!pl&&/Chrome\//.test(ul),wl=/Opera\//.test(ul),xl=/Apple Computer/.test(navigator.vendor),Cl=/Mac OS X 1\d\D([8-9]|\d\d)\D/.test(ul),Sl=/PhantomJS/.test(ul),Ll=!pl&&/AppleWebKit/.test(ul)&&/Mobile\/\w+/.test(ul),kl=/Android/.test(ul),Tl=Ll||kl||/webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(ul),Ml=Ll||/Mac/.test(cl),Nl=/\bCrOS\b/.test(ul),Ol=/win/i.test(cl),Al=wl&&ul.match(/Version\/(\d*\.\d*)/);Al&&(Al=Number(Al[1])),Al&&Al>=15&&(wl=!1,ml=!0);var Wl,Dl=Ml&&(yl||wl&&(null==Al||Al<12.11)),Hl=fl||gl&&vl>=9,Fl=function(t,r){var n=t.className,i=e(r).exec(n);if(i){var o=n.slice(i.index+i[0].length);t.className=n.slice(0,i.index)+(o?i[1]+o:"")}};Wl=document.createRange?function(e,t,r,n){var i=document.createRange();return i.setEnd(n||e,r),i.setStart(e,t),i}:function(e,t,r){var n=document.body.createTextRange();try{n.moveToElementText(e.parentNode)}catch(e){return n}return n.collapse(!0),n.moveEnd("character",r),n.moveStart("character",t),n};var El=function(e){e.select()};Ll?El=function(e){e.selectionStart=0,e.selectionEnd=e.value.length}:gl&&(El=function(e){try{e.select()}catch(e){}});var Pl=function(){this.id=null};Pl.prototype.set=function(e,t){clearTimeout(this.id),this.id=setTimeout(t,e)};var Il,zl,Rl=30,Bl={toString:function(){return"CodeMirror.Pass"}},Gl={scroll:!1},Ul={origin:"*mouse"},Vl={origin:"+move"},Kl=[""],jl=/[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/,Xl=/[\u0300-\u036f\u0483-\u0489\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u065e\u0670\u06d6-\u06dc\u06de-\u06e4\u06e7\u06e8\u06ea-\u06ed\u0711\u0730-\u074a\u07a6-\u07b0\u07eb-\u07f3\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0900-\u0902\u093c\u0941-\u0948\u094d\u0951-\u0955\u0962\u0963\u0981\u09bc\u09be\u09c1-\u09c4\u09cd\u09d7\u09e2\u09e3\u0a01\u0a02\u0a3c\u0a41\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a70\u0a71\u0a75\u0a81\u0a82\u0abc\u0ac1-\u0ac5\u0ac7\u0ac8\u0acd\u0ae2\u0ae3\u0b01\u0b3c\u0b3e\u0b3f\u0b41-\u0b44\u0b4d\u0b56\u0b57\u0b62\u0b63\u0b82\u0bbe\u0bc0\u0bcd\u0bd7\u0c3e-\u0c40\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0cbc\u0cbf\u0cc2\u0cc6\u0ccc\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0d3e\u0d41-\u0d44\u0d4d\u0d57\u0d62\u0d63\u0dca\u0dcf\u0dd2-\u0dd4\u0dd6\u0ddf\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0eb1\u0eb4-\u0eb9\u0ebb\u0ebc\u0ec8-\u0ecd\u0f18\u0f19\u0f35\u0f37\u0f39\u0f71-\u0f7e\u0f80-\u0f84\u0f86\u0f87\u0f90-\u0f97\u0f99-\u0fbc\u0fc6\u102d-\u1030\u1032-\u1037\u1039\u103a\u103d\u103e\u1058\u1059\u105e-\u1060\u1071-\u1074\u1082\u1085\u1086\u108d\u109d\u135f\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b7-\u17bd\u17c6\u17c9-\u17d3\u17dd\u180b-\u180d\u18a9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193b\u1a17\u1a18\u1a56\u1a58-\u1a5e\u1a60\u1a62\u1a65-\u1a6c\u1a73-\u1a7c\u1a7f\u1b00-\u1b03\u1b34\u1b36-\u1b3a\u1b3c\u1b42\u1b6b-\u1b73\u1b80\u1b81\u1ba2-\u1ba5\u1ba8\u1ba9\u1c2c-\u1c33\u1c36\u1c37\u1cd0-\u1cd2\u1cd4-\u1ce0\u1ce2-\u1ce8\u1ced\u1dc0-\u1de6\u1dfd-\u1dff\u200c\u200d\u20d0-\u20f0\u2cef-\u2cf1\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua66f-\ua672\ua67c\ua67d\ua6f0\ua6f1\ua802\ua806\ua80b\ua825\ua826\ua8c4\ua8e0-\ua8f1\ua926-\ua92d\ua947-\ua951\ua980-\ua982\ua9b3\ua9b6-\ua9b9\ua9bc\uaa29-\uaa2e\uaa31\uaa32\uaa35\uaa36\uaa43\uaa4c\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uabe5\uabe8\uabed\udc00-\udfff\ufb1e\ufe00-\ufe0f\ufe20-\ufe26\uff9e\uff9f]/,Yl=!1,_l=!1,$l=null,ql=function(){function e(e){return e<=247?r.charAt(e):1424<=e&&e<=1524?"R":1536<=e&&e<=1785?n.charAt(e-1536):1774<=e&&e<=2220?"r":8192<=e&&e<=8203?"w":8204==e?"b":"L"}function t(e,t,r){this.level=e,this.from=t,this.to=r}var r="bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLN",n="nnnnnnNNr%%r,rNNmmmmmmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmmmnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmnNmmmmmmrrmmNmmmmrr1111111111",i=/[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/,o=/[stwN]/,l=/[LRr]/,s=/[Lb1n]/,a=/[1n]/;return function(r,n){var u="ltr"==n?"L":"R";if(0==r.length||"ltr"==n&&!i.test(r))return!1;for(var c=r.length,f=[],h=0;h<c;++h)f.push(e(r.charCodeAt(h)));for(var d=0,p=u;d<c;++d){var v=f[d];"m"==v?f[d]=p:p=v}for(var m=0,y=u;m<c;++m){var b=f[m];"1"==b&&"r"==y?f[m]="n":l.test(b)&&(y=b,"r"==b&&(f[m]="R"))}for(var w=1,x=f[0];w<c-1;++w){var C=f[w];"+"==C&&"1"==x&&"1"==f[w+1]?f[w]="1":","!=C||x!=f[w+1]||"1"!=x&&"n"!=x||(f[w]=x),x=C}for(var S=0;S<c;++S){var L=f[S];if(","==L)f[S]="N";else if("%"==L){var k=void 0;for(k=S+1;k<c&&"%"==f[k];++k);for(var T=S&&"!"==f[S-1]||k<c&&"1"==f[k]?"1":"N",M=S;M<k;++M)f[M]=T;S=k-1}}for(var N=0,O=u;N<c;++N){var A=f[N];"L"==O&&"1"==A?f[N]="L":l.test(A)&&(O=A)}for(var W=0;W<c;++W)if(o.test(f[W])){var D=void 0;for(D=W+1;D<c&&o.test(f[D]);++D);for(var H="L"==(W?f[W-1]:u),F=H==("L"==(D<c?f[D]:u))?H?"L":"R":u,E=W;E<D;++E)f[E]=F;W=D-1}for(var P,I=[],z=0;z<c;)if(s.test(f[z])){var R=z;for(++z;z<c&&s.test(f[z]);++z);I.push(new t(0,R,z))}else{var B=z,G=I.length;for(++z;z<c&&"L"!=f[z];++z);for(var U=B;U<z;)if(a.test(f[U])){B<U&&I.splice(G,0,new t(1,B,U));var V=U;for(++U;U<z&&a.test(f[U]);++U);I.splice(G,0,new t(2,V,U)),B=U}else++U;B<z&&I.splice(G,0,new t(1,B,z))}return 1==I[0].level&&(P=r.match(/^\s+/))&&(I[0].from=P[0].length,I.unshift(new t(0,0,P[0].length))),1==g(I).level&&(P=r.match(/\s+$/))&&(g(I).to-=P[0].length,I.push(new t(0,c-P[0].length,c))),"rtl"==n?I.reverse():I}}(),Zl=[],Ql=function(e,t,r){if(e.addEventListener)e.addEventListener(t,r,!1);else if(e.attachEvent)e.attachEvent("on"+t,r);else{var n=e._handlers||(e._handlers={});n[t]=(n[t]||Zl).concat(r)}},Jl=function(){if(gl&&vl<9)return!1;var e=n("div");return"draggable"in e||"dragDrop"in e}(),es=3!="\n\nb".split(/\n/).length?function(e){for(var t=0,r=[],n=e.length;t<=n;){var i=e.indexOf("\n",t);-1==i&&(i=e.length);var o=e.slice(t,"\r"==e.charAt(i-1)?i-1:i),l=o.indexOf("\r");-1!=l?(r.push(o.slice(0,l)),t+=l+1):(r.push(o),t=i+1)}return r}:function(e){return e.split(/\r\n?|\n/)},ts=window.getSelection?function(e){try{return e.selectionStart!=e.selectionEnd}catch(e){return!1}}:function(e){var t;try{t=e.ownerDocument.selection.createRange()}catch(e){}return!(!t||t.parentElement()!=e)&&0!=t.compareEndPoints("StartToEnd",t)},rs=function(){var e=n("div");return"oncopy"in e||(e.setAttribute("oncopy","return;"),"function"==typeof e.oncopy)}(),ns=null,is={},os={},ls={},ss=function(e,t,r){this.pos=this.start=0,this.string=e,this.tabSize=t||8,this.lastColumnPos=this.lastColumnValue=0,this.lineStart=0,this.lineOracle=r};ss.prototype.eol=function(){return this.pos>=this.string.length},ss.prototype.sol=function(){return this.pos==this.lineStart},ss.prototype.peek=function(){return this.string.charAt(this.pos)||void 0},ss.prototype.next=function(){if(this.pos<this.string.length)return this.string.charAt(this.pos++)},ss.prototype.eat=function(e){var t=this.string.charAt(this.pos);if("string"==typeof e?t==e:t&&(e.test?e.test(t):e(t)))return++this.pos,t},ss.prototype.eatWhile=function(e){for(var t=this.pos;this.eat(e););return this.pos>t},ss.prototype.eatSpace=function(){for(var e=this,t=this.pos;/[\s\u00a0]/.test(this.string.charAt(this.pos));)++e.pos;return this.pos>t},ss.prototype.skipToEnd=function(){this.pos=this.string.length},ss.prototype.skipTo=function(e){var t=this.string.indexOf(e,this.pos);if(t>-1)return this.pos=t,!0},ss.prototype.backUp=function(e){this.pos-=e},ss.prototype.column=function(){return this.lastColumnPos<this.start&&(this.lastColumnValue=f(this.string,this.start,this.tabSize,this.lastColumnPos,this.lastColumnValue),this.lastColumnPos=this.start),this.lastColumnValue-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.indentation=function(){return f(this.string,null,this.tabSize)-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.match=function(e,t,r){if("string"!=typeof e){var n=this.string.slice(this.pos).match(e);return n&&n.index>0?null:(n&&!1!==t&&(this.pos+=n[0].length),n)}var i=function(e){return r?e.toLowerCase():e};if(i(this.string.substr(this.pos,e.length))==i(e))return!1!==t&&(this.pos+=e.length),!0},ss.prototype.current=function(){return this.string.slice(this.start,this.pos)},ss.prototype.hideFirstChars=function(e,t){this.lineStart+=e;try{return t()}finally{this.lineStart-=e}},ss.prototype.lookAhead=function(e){var t=this.lineOracle;return t&&t.lookAhead(e)};var as=function(e,t){this.state=e,this.lookAhead=t},us=function(e,t,r,n){this.state=t,this.doc=e,this.line=r,this.maxLookAhead=n||0};us.prototype.lookAhead=function(e){var t=this.doc.getLine(this.line+e);return null!=t&&e>this.maxLookAhead&&(this.maxLookAhead=e),t},us.prototype.nextLine=function(){this.line++,this.maxLookAhead>0&&this.maxLookAhead--},us.fromSaved=function(e,t,r){return t instanceof as?new us(e,Ke(e.mode,t.state),r,t.lookAhead):new us(e,Ke(e.mode,t),r)},us.prototype.save=function(e){var t=!1!==e?Ke(this.doc.mode,this.state):this.state;return this.maxLookAhead>0?new as(t,this.maxLookAhead):t};var cs=function(e,t,r){this.start=e.start,this.end=e.pos,this.string=e.current(),this.type=t||null,this.state=r},fs=function(e,t,r){this.text=e,ne(this,t),this.height=r?r(this):1};fs.prototype.lineNo=function(){return W(this)},Ae(fs);var hs,ds={},ps={},gs=null,vs=null,ms={left:0,right:0,top:0,bottom:0},ys=function(e,t,r){this.cm=r;var i=this.vert=n("div",[n("div",null,null,"min-width: 1px")],"CodeMirror-vscrollbar"),o=this.horiz=n("div",[n("div",null,null,"height: 100%; min-height: 1px")],"CodeMirror-hscrollbar");e(i),e(o),Ql(i,"scroll",function(){i.clientHeight&&t(i.scrollTop,"vertical")}),Ql(o,"scroll",function(){o.clientWidth&&t(o.scrollLeft,"horizontal")}),this.checkedZeroWidth=!1,gl&&vl<8&&(this.horiz.style.minHeight=this.vert.style.minWidth="18px")};ys.prototype.update=function(e){var t=e.scrollWidth>e.clientWidth+1,r=e.scrollHeight>e.clientHeight+1,n=e.nativeBarWidth;if(r){this.vert.style.display="block",this.vert.style.bottom=t?n+"px":"0";var i=e.viewHeight-(t?n:0);this.vert.firstChild.style.height=Math.max(0,e.scrollHeight-e.clientHeight+i)+"px"}else this.vert.style.display="",this.vert.firstChild.style.height="0";if(t){this.horiz.style.display="block",this.horiz.style.right=r?n+"px":"0",this.horiz.style.left=e.barLeft+"px";var o=e.viewWidth-e.barLeft-(r?n:0);this.horiz.firstChild.style.width=Math.max(0,e.scrollWidth-e.clientWidth+o)+"px"}else this.horiz.style.display="",this.horiz.firstChild.style.width="0";return!this.checkedZeroWidth&&e.clientHeight>0&&(0==n&&this.zeroWidthHack(),this.checkedZeroWidth=!0),{right:r?n:0,bottom:t?n:0}},ys.prototype.setScrollLeft=function(e){this.horiz.scrollLeft!=e&&(this.horiz.scrollLeft=e),this.disableHoriz&&this.enableZeroWidthBar(this.horiz,this.disableHoriz,"horiz")},ys.prototype.setScrollTop=function(e){this.vert.scrollTop!=e&&(this.vert.scrollTop=e),this.disableVert&&this.enableZeroWidthBar(this.vert,this.disableVert,"vert")},ys.prototype.zeroWidthHack=function(){var e=Ml&&!Cl?"12px":"18px";this.horiz.style.height=this.vert.style.width=e,this.horiz.style.pointerEvents=this.vert.style.pointerEvents="none",this.disableHoriz=new Pl,this.disableVert=new Pl},ys.prototype.enableZeroWidthBar=function(e,t,r){function n(){var i=e.getBoundingClientRect();("vert"==r?document.elementFromPoint(i.right-1,(i.top+i.bottom)/2):document.elementFromPoint((i.right+i.left)/2,i.bottom-1))!=e?e.style.pointerEvents="none":t.set(1e3,n)}e.style.pointerEvents="auto",t.set(1e3,n)},ys.prototype.clear=function(){var e=this.horiz.parentNode;e.removeChild(this.horiz),e.removeChild(this.vert)};var bs=function(){};bs.prototype.update=function(){return{bottom:0,right:0}},bs.prototype.setScrollLeft=function(){},bs.prototype.setScrollTop=function(){},bs.prototype.clear=function(){};var ws={native:ys,null:bs},xs=0,Cs=function(e,t,r){var n=e.display;this.viewport=t,this.visible=Ir(n,e.doc,t),this.editorIsHidden=!n.wrapper.offsetWidth,this.wrapperHeight=n.wrapper.clientHeight,this.wrapperWidth=n.wrapper.clientWidth,this.oldDisplayWidth=Rt(e),this.force=r,this.dims=br(e),this.events=[]};Cs.prototype.signal=function(e,t){Oe(e,t)&&this.events.push(arguments)},Cs.prototype.finish=function(){for(var e=this,t=0;t<this.events.length;t++)Te.apply(null,e.events[t])};var Ss=0,Ls=null;gl?Ls=-.53:fl?Ls=15:bl?Ls=-.7:xl&&(Ls=-1/3);var ks=function(e,t){this.ranges=e,this.primIndex=t};ks.prototype.primary=function(){return this.ranges[this.primIndex]},ks.prototype.equals=function(e){var t=this;if(e==this)return!0;if(e.primIndex!=this.primIndex||e.ranges.length!=this.ranges.length)return!1;for(var r=0;r<this.ranges.length;r++){var n=t.ranges[r],i=e.ranges[r];if(!I(n.anchor,i.anchor)||!I(n.head,i.head))return!1}return!0},ks.prototype.deepCopy=function(){for(var e=this,t=[],r=0;r<this.ranges.length;r++)t[r]=new Ts(z(e.ranges[r].anchor),z(e.ranges[r].head));return new ks(t,this.primIndex)},ks.prototype.somethingSelected=function(){for(var e=this,t=0;t<this.ranges.length;t++)if(!e.ranges[t].empty())return!0;return!1},ks.prototype.contains=function(e,t){var r=this;t||(t=e);for(var n=0;n<this.ranges.length;n++){var i=r.ranges[n];if(P(t,i.from())>=0&&P(e,i.to())<=0)return n}return-1};var Ts=function(e,t){this.anchor=e,this.head=t};Ts.prototype.from=function(){return B(this.anchor,this.head)},Ts.prototype.to=function(){return R(this.anchor,this.head)},Ts.prototype.empty=function(){return this.head.line==this.anchor.line&&this.head.ch==this.anchor.ch},Bi.prototype={chunkSize:function(){return this.lines.length},removeInner:function(e,t){for(var r=this,n=e,i=e+t;n<i;++n){var o=r.lines[n];r.height-=o.height,ot(o),bt(o,"delete")}this.lines.splice(e,t)},collapse:function(e){e.push.apply(e,this.lines)},insertInner:function(e,t,r){var n=this;this.height+=r,this.lines=this.lines.slice(0,e).concat(t).concat(this.lines.slice(e));for(var i=0;i<t.length;++i)t[i].parent=n},iterN:function(e,t,r){for(var n=this,i=e+t;e<i;++e)if(r(n.lines[e]))return!0}},Gi.prototype={chunkSize:function(){return this.size},removeInner:function(e,t){var r=this;this.size-=t;for(var n=0;n<this.children.length;++n){var i=r.children[n],o=i.chunkSize();if(e<o){var l=Math.min(t,o-e),s=i.height;if(i.removeInner(e,l),r.height-=s-i.height,o==l&&(r.children.splice(n--,1),i.parent=null),0==(t-=l))break;e=0}else e-=o}if(this.size-t<25&&(this.children.length>1||!(this.children[0]instanceof Bi))){var a=[];this.collapse(a),this.children=[new Bi(a)],this.children[0].parent=this}},collapse:function(e){for(var t=this,r=0;r<this.children.length;++r)t.children[r].collapse(e)},insertInner:function(e,t,r){var n=this;this.size+=t.length,this.height+=r;for(var i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<=l){if(o.insertInner(e,t,r),o.lines&&o.lines.length>50){for(var s=o.lines.length%25+25,a=s;a<o.lines.length;){var u=new Bi(o.lines.slice(a,a+=25));o.height-=u.height,n.children.splice(++i,0,u),u.parent=n}o.lines=o.lines.slice(0,s),n.maybeSpill()}break}e-=l}},maybeSpill:function(){if(!(this.children.length<=10)){var e=this;do{var t=new Gi(e.children.splice(e.children.length-5,5));if(e.parent){e.size-=t.size,e.height-=t.height;var r=h(e.parent.children,e);e.parent.children.splice(r+1,0,t)}else{var n=new Gi(e.children);n.parent=e,e.children=[n,t],e=n}t.parent=e.parent}while(e.children.length>10);e.parent.maybeSpill()}},iterN:function(e,t,r){for(var n=this,i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<l){var s=Math.min(t,l-e);if(o.iterN(e,s,r))return!0;if(0==(t-=s))break;e=0}else e-=l}}};var Ms=function(e,t,r){var n=this;if(r)for(var i in r)r.hasOwnProperty(i)&&(n[i]=r[i]);this.doc=e,this.node=t};Ms.prototype.clear=function(){var e=this,t=this.doc.cm,r=this.line.widgets,n=this.line,i=W(n);if(null!=i&&r){for(var o=0;o<r.length;++o)r[o]==e&&r.splice(o--,1);r.length||(n.widgets=null);var l=Ht(this);A(n,Math.max(0,n.height-l)),t&&(hn(t,function(){Ui(t,n,-l),mn(t,i,"widget")}),bt(t,"lineWidgetCleared",t,this,i))}},Ms.prototype.changed=function(){var e=this,t=this.height,r=this.doc.cm,n=this.line;this.height=null;var i=Ht(this)-t;i&&(A(n,n.height+i),r&&hn(r,function(){r.curOp.forceUpdate=!0,Ui(r,n,i),bt(r,"lineWidgetChanged",r,e,W(n))}))},Ae(Ms);var Ns=0,Os=function(e,t){this.lines=[],this.type=t,this.doc=e,this.id=++Ns};Os.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){var t=this.doc.cm,r=t&&!t.curOp;if(r&&nn(t),Oe(this,"clear")){var n=this.find();n&&bt(this,"clear",n.from,n.to)}for(var i=null,o=null,l=0;l<this.lines.length;++l){var s=e.lines[l],a=_(s.markedSpans,e);t&&!e.collapsed?mn(t,W(s),"text"):t&&(null!=a.to&&(o=W(s)),null!=a.from&&(i=W(s))),s.markedSpans=$(s.markedSpans,a),null==a.from&&e.collapsed&&!ve(e.doc,s)&&t&&A(s,mr(t.display))}if(t&&this.collapsed&&!t.options.lineWrapping)for(var u=0;u<this.lines.length;++u){var c=fe(e.lines[u]),f=be(c);f>t.display.maxLineLength&&(t.display.maxLine=c,t.display.maxLineLength=f,t.display.maxLineChanged=!0)}null!=i&&t&&this.collapsed&&vn(t,i,o+1),this.lines.length=0,this.explicitlyCleared=!0,this.atomic&&this.doc.cantEdit&&(this.doc.cantEdit=!1,t&&Ci(t.doc)),t&&bt(t,"markerCleared",t,this,i,o),r&&on(t),this.parent&&this.parent.clear()}},Os.prototype.find=function(e,t){var r=this;null==e&&"bookmark"==this.type&&(e=1);for(var n,i,o=0;o<this.lines.length;++o){var l=r.lines[o],s=_(l.markedSpans,r);if(null!=s.from&&(n=E(t?l:W(l),s.from),-1==e))return n;if(null!=s.to&&(i=E(t?l:W(l),s.to),1==e))return i}return n&&{from:n,to:i}},Os.prototype.changed=function(){var e=this,t=this.find(-1,!0),r=this,n=this.doc.cm;t&&n&&hn(n,function(){var i=t.line,o=W(t.line),l=jt(n,o);if(l&&(Qt(l),n.curOp.selectionChanged=n.curOp.forceUpdate=!0),n.curOp.updateMaxLine=!0,!ve(r.doc,i)&&null!=r.height){var s=r.height;r.height=null;var a=Ht(r)-s;a&&A(i,i.height+a)}bt(n,"markerChanged",n,e)})},Os.prototype.attachLine=function(e){if(!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;t.maybeHiddenMarkers&&-1!=h(t.maybeHiddenMarkers,this)||(t.maybeUnhiddenMarkers||(t.maybeUnhiddenMarkers=[])).push(this)}this.lines.push(e)},Os.prototype.detachLine=function(e){if(this.lines.splice(h(this.lines,e),1),!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;(t.maybeHiddenMarkers||(t.maybeHiddenMarkers=[])).push(this)}},Ae(Os);var As=function(e,t){var r=this;this.markers=e,this.primary=t;for(var n=0;n<e.length;++n)e[n].parent=r};As.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){this.explicitlyCleared=!0;for(var t=0;t<this.markers.length;++t)e.markers[t].clear();bt(this,"clear")}},As.prototype.find=function(e,t){return this.primary.find(e,t)},Ae(As);var Ws=0,Ds=function(e,t,r,n,i){if(!(this instanceof Ds))return new Ds(e,t,r,n,i);null==r&&(r=0),Gi.call(this,[new Bi([new fs("",null)])]),this.first=r,this.scrollTop=this.scrollLeft=0,this.cantEdit=!1,this.cleanGeneration=1,this.modeFrontier=this.highlightFrontier=r;var o=E(r,0);this.sel=Rn(o),this.history=new Jn(null),this.id=++Ws,this.modeOption=t,this.lineSep=n,this.direction="rtl"==i?"rtl":"ltr",this.extend=!1,"string"==typeof e&&(e=this.splitLines(e)),_n(this,{from:o,to:o,text:e}),bi(this,Rn(o),Gl)};Ds.prototype=b(Gi.prototype,{constructor:Ds,iter:function(e,t,r){r?this.iterN(e-this.first,t-e,r):this.iterN(this.first,this.first+this.size,e)},insert:function(e,t){for(var r=0,n=0;n<t.length;++n)r+=t[n].height;this.insertInner(e-this.first,t,r)},remove:function(e,t){this.removeInner(e-this.first,t)},getValue:function(e){var t=O(this,this.first,this.first+this.size);return!1===e?t:t.join(e||this.lineSeparator())},setValue:gn(function(e){var t=E(this.first,0),r=this.first+this.size-1;Oi(this,{from:t,to:E(r,M(this,r).text.length),text:this.splitLines(e),origin:"setValue",full:!0},!0),this.cm&&Xr(this.cm,0,0),bi(this,Rn(t),Gl)}),replaceRange:function(e,t,r,n){Ei(this,e,t=U(this,t),r=r?U(this,r):t,n)},getRange:function(e,t,r){var n=N(this,U(this,e),U(this,t));return!1===r?n:n.join(r||this.lineSeparator())},getLine:function(e){var t=this.getLineHandle(e);return t&&t.text},getLineHandle:function(e){if(H(this,e))return M(this,e)},getLineNumber:function(e){return W(e)},getLineHandleVisualStart:function(e){return"number"==typeof e&&(e=M(this,e)),fe(e)},lineCount:function(){return this.size},firstLine:function(){return this.first},lastLine:function(){return this.first+this.size-1},clipPos:function(e){return U(this,e)},getCursor:function(e){var t=this.sel.primary();return null==e||"head"==e?t.head:"anchor"==e?t.anchor:"end"==e||"to"==e||!1===e?t.to():t.from()},listSelections:function(){return this.sel.ranges},somethingSelected:function(){return this.sel.somethingSelected()},setCursor:gn(function(e,t,r){vi(this,U(this,"number"==typeof e?E(e,t||0):e),null,r)}),setSelection:gn(function(e,t,r){vi(this,U(this,e),U(this,t||e),r)}),extendSelection:gn(function(e,t,r){di(this,U(this,e),t&&U(this,t),r)}),extendSelections:gn(function(e,t){pi(this,K(this,e),t)}),extendSelectionsBy:gn(function(e,t){pi(this,K(this,v(this.sel.ranges,e)),t)}),setSelections:gn(function(e,t,r){var n=this;if(e.length){for(var i=[],o=0;o<e.length;o++)i[o]=new Ts(U(n,e[o].anchor),U(n,e[o].head));null==t&&(t=Math.min(e.length-1,this.sel.primIndex)),bi(this,zn(i,t),r)}}),addSelection:gn(function(e,t,r){var n=this.sel.ranges.slice(0);n.push(new Ts(U(this,e),U(this,t||e))),bi(this,zn(n,n.length-1),r)}),getSelection:function(e){for(var t,r=this,n=this.sel.ranges,i=0;i<n.length;i++){var o=N(r,n[i].from(),n[i].to());t=t?t.concat(o):o}return!1===e?t:t.join(e||this.lineSeparator())},getSelections:function(e){for(var t=this,r=[],n=this.sel.ranges,i=0;i<n.length;i++){var o=N(t,n[i].from(),n[i].to());!1!==e&&(o=o.join(e||t.lineSeparator())),r[i]=o}return r},replaceSelection:function(e,t,r){for(var n=[],i=0;i<this.sel.ranges.length;i++)n[i]=e;this.replaceSelections(n,t,r||"+input")},replaceSelections:gn(function(e,t,r){for(var n=this,i=[],o=this.sel,l=0;l<o.ranges.length;l++){var s=o.ranges[l];i[l]={from:s.from(),to:s.to(),text:n.splitLines(e[l]),origin:r}}for(var a=t&&"end"!=t&&Kn(this,i,t),u=i.length-1;u>=0;u--)Oi(n,i[u]);a?yi(this,a):this.cm&&jr(this.cm)}),undo:gn(function(){Wi(this,"undo")}),redo:gn(function(){Wi(this,"redo")}),undoSelection:gn(function(){Wi(this,"undo",!0)}),redoSelection:gn(function(){Wi(this,"redo",!0)}),setExtending:function(e){this.extend=e},getExtending:function(){return this.extend},historySize:function(){for(var e=this.history,t=0,r=0,n=0;n<e.done.length;n++)e.done[n].ranges||++t;for(var i=0;i<e.undone.length;i++)e.undone[i].ranges||++r;return{undo:t,redo:r}},clearHistory:function(){this.history=new Jn(this.history.maxGeneration)},markClean:function(){this.cleanGeneration=this.changeGeneration(!0)},changeGeneration:function(e){return e&&(this.history.lastOp=this.history.lastSelOp=this.history.lastOrigin=null),this.history.generation},isClean:function(e){return this.history.generation==(e||this.cleanGeneration)},getHistory:function(){return{done:fi(this.history.done),undone:fi(this.history.undone)}},setHistory:function(e){var t=this.history=new Jn(this.history.maxGeneration);t.done=fi(e.done.slice(0),null,!0),t.undone=fi(e.undone.slice(0),null,!0)},setGutterMarker:gn(function(e,t,r){return Ri(this,e,"gutter",function(e){var n=e.gutterMarkers||(e.gutterMarkers={});return n[t]=r,!r&&C(n)&&(e.gutterMarkers=null),!0})}),clearGutter:gn(function(e){var t=this;this.iter(function(r){r.gutterMarkers&&r.gutterMarkers[e]&&Ri(t,r,"gutter",function(){return r.gutterMarkers[e]=null,C(r.gutterMarkers)&&(r.gutterMarkers=null),!0})})}),lineInfo:function(e){var t;if("number"==typeof e){if(!H(this,e))return null;if(t=e,!(e=M(this,e)))return null}else if(null==(t=W(e)))return null;return{line:t,handle:e,text:e.text,gutterMarkers:e.gutterMarkers,textClass:e.textClass,bgClass:e.bgClass,wrapClass:e.wrapClass,widgets:e.widgets}},addLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass";if(t[i]){if(e(n).test(t[i]))return!1;t[i]+=" "+n}else t[i]=n;return!0})}),removeLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass",o=t[i];if(!o)return!1;if(null==n)t[i]=null;else{var l=o.match(e(n));if(!l)return!1;var s=l.index+l[0].length;t[i]=o.slice(0,l.index)+(l.index&&s!=o.length?" ":"")+o.slice(s)||null}return!0})}),addLineWidget:gn(function(e,t,r){return Vi(this,e,t,r)}),removeLineWidget:function(e){e.clear()},markText:function(e,t,r){return Ki(this,U(this,e),U(this,t),r,r&&r.type||"range")},setBookmark:function(e,t){var r={replacedWith:t&&(null==t.nodeType?t.widget:t),insertLeft:t&&t.insertLeft,clearWhenEmpty:!1,shared:t&&t.shared,handleMouseEvents:t&&t.handleMouseEvents};return e=U(this,e),Ki(this,e,e,r,"bookmark")},findMarksAt:function(e){var t=[],r=M(this,(e=U(this,e)).line).markedSpans;if(r)for(var n=0;n<r.length;++n){var i=r[n];(null==i.from||i.from<=e.ch)&&(null==i.to||i.to>=e.ch)&&t.push(i.marker.parent||i.marker)}return t},findMarks:function(e,t,r){e=U(this,e),t=U(this,t);var n=[],i=e.line;return this.iter(e.line,t.line+1,function(o){var l=o.markedSpans;if(l)for(var s=0;s<l.length;s++){var a=l[s];null!=a.to&&i==e.line&&e.ch>=a.to||null==a.from&&i!=e.line||null!=a.from&&i==t.line&&a.from>=t.ch||r&&!r(a.marker)||n.push(a.marker.parent||a.marker)}++i}),n},getAllMarks:function(){var e=[];return this.iter(function(t){var r=t.markedSpans;if(r)for(var n=0;n<r.length;++n)null!=r[n].from&&e.push(r[n].marker)}),e},posFromIndex:function(e){var t,r=this.first,n=this.lineSeparator().length;return this.iter(function(i){var o=i.text.length+n;if(o>e)return t=e,!0;e-=o,++r}),U(this,E(r,t))},indexFromPos:function(e){var t=(e=U(this,e)).ch;if(e.line<this.first||e.ch<0)return 0;var r=this.lineSeparator().length;return this.iter(this.first,e.line,function(e){t+=e.text.length+r}),t},copy:function(e){var t=new Ds(O(this,this.first,this.first+this.size),this.modeOption,this.first,this.lineSep,this.direction);return t.scrollTop=this.scrollTop,t.scrollLeft=this.scrollLeft,t.sel=this.sel,t.extend=!1,e&&(t.history.undoDepth=this.history.undoDepth,t.setHistory(this.getHistory())),t},linkedDoc:function(e){e||(e={});var t=this.first,r=this.first+this.size;null!=e.from&&e.from>t&&(t=e.from),null!=e.to&&e.to<r&&(r=e.to);var n=new Ds(O(this,t,r),e.mode||this.modeOption,t,this.lineSep,this.direction);return e.sharedHist&&(n.history=this.history),(this.linked||(this.linked=[])).push({doc:n,sharedHist:e.sharedHist}),n.linked=[{doc:this,isParent:!0,sharedHist:e.sharedHist}],Yi(n,Xi(this)),n},unlinkDoc:function(e){var t=this;if(e instanceof jo&&(e=e.doc),this.linked)for(var r=0;r<this.linked.length;++r)if(t.linked[r].doc==e){t.linked.splice(r,1),e.unlinkDoc(t),_i(Xi(t));break}if(e.history==this.history){var n=[e.id];$n(e,function(e){return n.push(e.id)},!0),e.history=new Jn(null),e.history.done=fi(this.history.done,n),e.history.undone=fi(this.history.undone,n)}},iterLinkedDocs:function(e){$n(this,e)},getMode:function(){return this.mode},getEditor:function(){return this.cm},splitLines:function(e){return this.lineSep?e.split(this.lineSep):es(e)},lineSeparator:function(){return this.lineSep||"\n"},setDirection:gn(function(e){"rtl"!=e&&(e="ltr"),e!=this.direction&&(this.direction=e,this.iter(function(e){return e.order=null}),this.cm&&Qn(this.cm))})}),Ds.prototype.eachLine=Ds.prototype.iter;for(var Hs=0,Fs=!1,Es={3:"Enter",8:"Backspace",9:"Tab",13:"Enter",16:"Shift",17:"Ctrl",18:"Alt",19:"Pause",20:"CapsLock",27:"Esc",32:"Space",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"Left",38:"Up",39:"Right",40:"Down",44:"PrintScrn",45:"Insert",46:"Delete",59:";",61:"=",91:"Mod",92:"Mod",93:"Mod",106:"*",107:"=",109:"-",110:".",111:"/",127:"Delete",173:"-",186:";",187:"=",188:",",189:"-",190:".",191:"/",192:"`",219:"[",220:"\\",221:"]",222:"'",63232:"Up",63233:"Down",63234:"Left",63235:"Right",63272:"Delete",63273:"Home",63275:"End",63276:"PageUp",63277:"PageDown",63302:"Insert"},Ps=0;Ps<10;Ps++)Es[Ps+48]=Es[Ps+96]=String(Ps);for(var Is=65;Is<=90;Is++)Es[Is]=String.fromCharCode(Is);for(var zs=1;zs<=12;zs++)Es[zs+111]=Es[zs+63235]="F"+zs;var Rs={};Rs.basic={Left:"goCharLeft",Right:"goCharRight",Up:"goLineUp",Down:"goLineDown",End:"goLineEnd",Home:"goLineStartSmart",PageUp:"goPageUp",PageDown:"goPageDown",Delete:"delCharAfter",Backspace:"delCharBefore","Shift-Backspace":"delCharBefore",Tab:"defaultTab","Shift-Tab":"indentAuto",Enter:"newlineAndIndent",Insert:"toggleOverwrite",Esc:"singleSelection"},Rs.pcDefault={"Ctrl-A":"selectAll","Ctrl-D":"deleteLine","Ctrl-Z":"undo","Shift-Ctrl-Z":"redo","Ctrl-Y":"redo","Ctrl-Home":"goDocStart","Ctrl-End":"goDocEnd","Ctrl-Up":"goLineUp","Ctrl-Down":"goLineDown","Ctrl-Left":"goGroupLeft","Ctrl-Right":"goGroupRight","Alt-Left":"goLineStart","Alt-Right":"goLineEnd","Ctrl-Backspace":"delGroupBefore","Ctrl-Delete":"delGroupAfter","Ctrl-S":"save","Ctrl-F":"find","Ctrl-G":"findNext","Shift-Ctrl-G":"findPrev","Shift-Ctrl-F":"replace","Shift-Ctrl-R":"replaceAll","Ctrl-[":"indentLess","Ctrl-]":"indentMore","Ctrl-U":"undoSelection","Shift-Ctrl-U":"redoSelection","Alt-U":"redoSelection",fallthrough:"basic"},Rs.emacsy={"Ctrl-F":"goCharRight","Ctrl-B":"goCharLeft","Ctrl-P":"goLineUp","Ctrl-N":"goLineDown","Alt-F":"goWordRight","Alt-B":"goWordLeft","Ctrl-A":"goLineStart","Ctrl-E":"goLineEnd","Ctrl-V":"goPageDown","Shift-Ctrl-V":"goPageUp","Ctrl-D":"delCharAfter","Ctrl-H":"delCharBefore","Alt-D":"delWordAfter","Alt-Backspace":"delWordBefore","Ctrl-K":"killLine","Ctrl-T":"transposeChars","Ctrl-O":"openLine"},Rs.macDefault={"Cmd-A":"selectAll","Cmd-D":"deleteLine","Cmd-Z":"undo","Shift-Cmd-Z":"redo","Cmd-Y":"redo","Cmd-Home":"goDocStart","Cmd-Up":"goDocStart","Cmd-End":"goDocEnd","Cmd-Down":"goDocEnd","Alt-Left":"goGroupLeft","Alt-Right":"goGroupRight","Cmd-Left":"goLineLeft","Cmd-Right":"goLineRight","Alt-Backspace":"delGroupBefore","Ctrl-Alt-Backspace":"delGroupAfter","Alt-Delete":"delGroupAfter","Cmd-S":"save","Cmd-F":"find","Cmd-G":"findNext","Shift-Cmd-G":"findPrev","Cmd-Alt-F":"replace","Shift-Cmd-Alt-F":"replaceAll","Cmd-[":"indentLess","Cmd-]":"indentMore","Cmd-Backspace":"delWrappedLineLeft","Cmd-Delete":"delWrappedLineRight","Cmd-U":"undoSelection","Shift-Cmd-U":"redoSelection","Ctrl-Up":"goDocStart","Ctrl-Down":"goDocEnd",fallthrough:["basic","emacsy"]},Rs.default=Ml?Rs.macDefault:Rs.pcDefault;var Bs={selectAll:Mi,singleSelection:function(e){return e.setSelection(e.getCursor("anchor"),e.getCursor("head"),Gl)},killLine:function(e){return co(e,function(t){if(t.empty()){var r=M(e.doc,t.head.line).text.length;return t.head.ch==r&&t.head.line<e.lastLine()?{from:t.head,to:E(t.head.line+1,0)}:{from:t.head,to:E(t.head.line,r)}}return{from:t.from(),to:t.to()}})},deleteLine:function(e){return co(e,function(t){return{from:E(t.from().line,0),to:U(e.doc,E(t.to().line+1,0))}})},delLineLeft:function(e){return co(e,function(e){return{from:E(e.from().line,0),to:e.from()}})},delWrappedLineLeft:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5;return{from:e.coordsChar({left:0,top:r},"div"),to:t.from()}})},delWrappedLineRight:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5,n=e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div");return{from:t.from(),to:n}})},undo:function(e){return e.undo()},redo:function(e){return e.redo()},undoSelection:function(e){return e.undoSelection()},redoSelection:function(e){return e.redoSelection()},goDocStart:function(e){return e.extendSelection(E(e.firstLine(),0))},goDocEnd:function(e){return e.extendSelection(E(e.lastLine()))},goLineStart:function(e){return e.extendSelectionsBy(function(t){return vo(e,t.head.line)},{origin:"+move",bias:1})},goLineStartSmart:function(e){return e.extendSelectionsBy(function(t){return yo(e,t.head)},{origin:"+move",bias:1})},goLineEnd:function(e){return e.extendSelectionsBy(function(t){return mo(e,t.head.line)},{origin:"+move",bias:-1})},goLineRight:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div")},Vl)},goLineLeft:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:0,top:r},"div")},Vl)},goLineLeftSmart:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5,n=e.coordsChar({left:0,top:r},"div");return n.ch<e.getLine(n.line).search(/\S/)?yo(e,t.head):n},Vl)},goLineUp:function(e){return e.moveV(-1,"line")},goLineDown:function(e){return e.moveV(1,"line")},goPageUp:function(e){return e.moveV(-1,"page")},goPageDown:function(e){return e.moveV(1,"page")},goCharLeft:function(e){return e.moveH(-1,"char")},goCharRight:function(e){return e.moveH(1,"char")},goColumnLeft:function(e){return e.moveH(-1,"column")},goColumnRight:function(e){return e.moveH(1,"column")},goWordLeft:function(e){return e.moveH(-1,"word")},goGroupRight:function(e){return e.moveH(1,"group")},goGroupLeft:function(e){return e.moveH(-1,"group")},goWordRight:function(e){return e.moveH(1,"word")},delCharBefore:function(e){return e.deleteH(-1,"char")},delCharAfter:function(e){return e.deleteH(1,"char")},delWordBefore:function(e){return e.deleteH(-1,"word")},delWordAfter:function(e){return e.deleteH(1,"word")},delGroupBefore:function(e){return e.deleteH(-1,"group")},delGroupAfter:function(e){return e.deleteH(1,"group")},indentAuto:function(e){return e.indentSelection("smart")},indentMore:function(e){return e.indentSelection("add")},indentLess:function(e){return e.indentSelection("subtract")},insertTab:function(e){return e.replaceSelection("\t")},insertSoftTab:function(e){for(var t=[],r=e.listSelections(),n=e.options.tabSize,i=0;i<r.length;i++){var o=r[i].from(),l=f(e.getLine(o.line),o.ch,n);t.push(p(n-l%n))}e.replaceSelections(t)},defaultTab:function(e){e.somethingSelected()?e.indentSelection("add"):e.execCommand("insertTab")},transposeChars:function(e){return hn(e,function(){for(var t=e.listSelections(),r=[],n=0;n<t.length;n++)if(t[n].empty()){var i=t[n].head,o=M(e.doc,i.line).text;if(o)if(i.ch==o.length&&(i=new E(i.line,i.ch-1)),i.ch>0)i=new E(i.line,i.ch+1),e.replaceRange(o.charAt(i.ch-1)+o.charAt(i.ch-2),E(i.line,i.ch-2),i,"+transpose");else if(i.line>e.doc.first){var l=M(e.doc,i.line-1).text;l&&(i=new E(i.line,1),e.replaceRange(o.charAt(0)+e.doc.lineSeparator()+l.charAt(l.length-1),E(i.line-1,l.length-1),i,"+transpose"))}r.push(new Ts(i,i))}e.setSelections(r)})},newlineAndIndent:function(e){return hn(e,function(){for(var t=e.listSelections(),r=t.length-1;r>=0;r--)e.replaceRange(e.doc.lineSeparator(),t[r].anchor,t[r].head,"+input");t=e.listSelections();for(var n=0;n<t.length;n++)e.indentLine(t[n].from().line,null,!0);jr(e)})},openLine:function(e){return e.replaceSelection("\n","start")},toggleOverwrite:function(e){return e.toggleOverwrite()}},Gs=new Pl,Us=null,Vs=function(e,t,r){this.time=e,this.pos=t,this.button=r};Vs.prototype.compare=function(e,t,r){return this.time+400>e&&0==P(t,this.pos)&&r==this.button};var Ks,js,Xs={toString:function(){return"CodeMirror.Init"}},Ys={},_s={};jo.defaults=Ys,jo.optionHandlers=_s;var $s=[];jo.defineInitHook=function(e){return $s.push(e)};var qs=null,Zs=function(e){this.cm=e,this.lastAnchorNode=this.lastAnchorOffset=this.lastFocusNode=this.lastFocusOffset=null,this.polling=new Pl,this.composing=null,this.gracePeriod=!1,this.readDOMTimeout=null};Zs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()}),"cut"==e.type&&i.replaceSelection("",null,"cut");else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type&&i.operation(function(){i.setSelections(t.ranges,0,Gl),i.replaceSelection("",null,"cut")})}if(e.clipboardData){e.clipboardData.clearData();var r=qs.text.join("\n");if(e.clipboardData.setData("Text",r),e.clipboardData.getData("Text")==r)return void e.preventDefault()}var l=el(),s=l.firstChild;i.display.lineSpace.insertBefore(l,i.display.lineSpace.firstChild),s.value=qs.text.join("\n");var a=document.activeElement;El(s),setTimeout(function(){i.display.lineSpace.removeChild(l),a.focus(),a==o&&n.showPrimarySelection()},50)}}var r=this,n=this,i=n.cm,o=n.div=e.lineDiv;Jo(o,i.options.spellcheck),Ql(o,"paste",function(e){Me(i,e)||qo(e,i)||vl<=11&&setTimeout(dn(i,function(){return r.updateFromDOM()}),20)}),Ql(o,"compositionstart",function(e){r.composing={data:e.data,done:!1}}),Ql(o,"compositionupdate",function(e){r.composing||(r.composing={data:e.data,done:!1})}),Ql(o,"compositionend",function(e){r.composing&&(e.data!=r.composing.data&&r.readFromDOMSoon(),r.composing.done=!0)}),Ql(o,"touchstart",function(){return n.forceCompositionEnd()}),Ql(o,"input",function(){r.composing||r.readFromDOMSoon()}),Ql(o,"copy",t),Ql(o,"cut",t)},Zs.prototype.prepareSelection=function(){var e=Tr(this.cm,!1);return e.focus=this.cm.state.focused,e},Zs.prototype.showSelection=function(e,t){e&&this.cm.display.view.length&&((e.focus||t)&&this.showPrimarySelection(),this.showMultipleSelections(e))},Zs.prototype.showPrimarySelection=function(){var e=window.getSelection(),t=this.cm,r=t.doc.sel.primary(),n=r.from(),i=r.to();if(t.display.viewTo==t.display.viewFrom||n.line>=t.display.viewTo||i.line<t.display.viewFrom)e.removeAllRanges();else{var o=sl(t,e.anchorNode,e.anchorOffset),l=sl(t,e.focusNode,e.focusOffset);if(!o||o.bad||!l||l.bad||0!=P(B(o,l),n)||0!=P(R(o,l),i)){var s=t.display.view,a=n.line>=t.display.viewFrom&&nl(t,n)||{node:s[0].measure.map[2],offset:0},u=i.line<t.display.viewTo&&nl(t,i);if(!u){var c=s[s.length-1].measure,f=c.maps?c.maps[c.maps.length-1]:c.map;u={node:f[f.length-1],offset:f[f.length-2]-f[f.length-3]}}if(a&&u){var h,d=e.rangeCount&&e.getRangeAt(0);try{h=Wl(a.node,a.offset,u.offset,u.node)}catch(e){}h&&(!fl&&t.state.focused?(e.collapse(a.node,a.offset),h.collapsed||(e.removeAllRanges(),e.addRange(h))):(e.removeAllRanges(),e.addRange(h)),d&&null==e.anchorNode?e.addRange(d):fl&&this.startGracePeriod()),this.rememberSelection()}else e.removeAllRanges()}}},Zs.prototype.startGracePeriod=function(){var e=this;clearTimeout(this.gracePeriod),this.gracePeriod=setTimeout(function(){e.gracePeriod=!1,e.selectionChanged()&&e.cm.operation(function(){return e.cm.curOp.selectionChanged=!0})},20)},Zs.prototype.showMultipleSelections=function(e){r(this.cm.display.cursorDiv,e.cursors),r(this.cm.display.selectionDiv,e.selection)},Zs.prototype.rememberSelection=function(){var e=window.getSelection();this.lastAnchorNode=e.anchorNode,this.lastAnchorOffset=e.anchorOffset,this.lastFocusNode=e.focusNode,this.lastFocusOffset=e.focusOffset},Zs.prototype.selectionInEditor=function(){var e=window.getSelection();if(!e.rangeCount)return!1;var t=e.getRangeAt(0).commonAncestorContainer;return o(this.div,t)},Zs.prototype.focus=function(){"nocursor"!=this.cm.options.readOnly&&(this.selectionInEditor()||this.showSelection(this.prepareSelection(),!0),this.div.focus())},Zs.prototype.blur=function(){this.div.blur()},Zs.prototype.getField=function(){return this.div},Zs.prototype.supportsTouch=function(){return!0},Zs.prototype.receivedFocus=function(){function e(){t.cm.state.focused&&(t.pollSelection(),t.polling.set(t.cm.options.pollInterval,e))}var t=this;this.selectionInEditor()?this.pollSelection():hn(this.cm,function(){return t.cm.curOp.selectionChanged=!0}),this.polling.set(this.cm.options.pollInterval,e)},Zs.prototype.selectionChanged=function(){var e=window.getSelection();return e.anchorNode!=this.lastAnchorNode||e.anchorOffset!=this.lastAnchorOffset||e.focusNode!=this.lastFocusNode||e.focusOffset!=this.lastFocusOffset},Zs.prototype.pollSelection=function(){if(null==this.readDOMTimeout&&!this.gracePeriod&&this.selectionChanged()){var e=window.getSelection(),t=this.cm;if(kl&&bl&&this.cm.options.gutters.length&&il(e.anchorNode))return this.cm.triggerOnKeyDown({type:"keydown",keyCode:8,preventDefault:Math.abs}),this.blur(),void this.focus();if(!this.composing){this.rememberSelection();var r=sl(t,e.anchorNode,e.anchorOffset),n=sl(t,e.focusNode,e.focusOffset);r&&n&&hn(t,function(){bi(t.doc,Rn(r,n),Gl),(r.bad||n.bad)&&(t.curOp.selectionChanged=!0)})}}},Zs.prototype.pollContent=function(){null!=this.readDOMTimeout&&(clearTimeout(this.readDOMTimeout),this.readDOMTimeout=null);var e=this.cm,t=e.display,r=e.doc.sel.primary(),n=r.from(),i=r.to();if(0==n.ch&&n.line>e.firstLine()&&(n=E(n.line-1,M(e.doc,n.line-1).length)),i.ch==M(e.doc,i.line).text.length&&i.line<e.lastLine()&&(i=E(i.line+1,0)),n.line<t.viewFrom||i.line>t.viewTo-1)return!1;var o,l,s;n.line==t.viewFrom||0==(o=Lr(e,n.line))?(l=W(t.view[0].line),s=t.view[0].node):(l=W(t.view[o].line),s=t.view[o-1].node.nextSibling);var a,u,c=Lr(e,i.line);if(c==t.view.length-1?(a=t.viewTo-1,u=t.lineDiv.lastChild):(a=W(t.view[c+1].line)-1,u=t.view[c+1].node.previousSibling),!s)return!1;for(var f=e.doc.splitLines(ll(e,s,u,l,a)),h=N(e.doc,E(l,0),E(a,M(e.doc,a).text.length));f.length>1&&h.length>1;)if(g(f)==g(h))f.pop(),h.pop(),a--;else{if(f[0]!=h[0])break;f.shift(),h.shift(),l++}for(var d=0,p=0,v=f[0],m=h[0],y=Math.min(v.length,m.length);d<y&&v.charCodeAt(d)==m.charCodeAt(d);)++d;for(var b=g(f),w=g(h),x=Math.min(b.length-(1==f.length?d:0),w.length-(1==h.length?d:0));p<x&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)++p;if(1==f.length&&1==h.length&&l==n.line)for(;d&&d>n.ch&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)d--,p++;f[f.length-1]=b.slice(0,b.length-p).replace(/^\u200b+/,""),f[0]=f[0].slice(d).replace(/\u200b+$/,"");var C=E(l,d),S=E(a,h.length?g(h).length-p:0);return f.length>1||f[0]||P(C,S)?(Ei(e.doc,f,C,S,"+input"),!0):void 0},Zs.prototype.ensurePolled=function(){this.forceCompositionEnd()},Zs.prototype.reset=function(){this.forceCompositionEnd()},Zs.prototype.forceCompositionEnd=function(){this.composing&&(clearTimeout(this.readDOMTimeout),this.composing=null,this.updateFromDOM(),this.div.blur(),this.div.focus())},Zs.prototype.readFromDOMSoon=function(){var e=this;null==this.readDOMTimeout&&(this.readDOMTimeout=setTimeout(function(){if(e.readDOMTimeout=null,e.composing){if(!e.composing.done)return;e.composing=null}e.updateFromDOM()},80))},Zs.prototype.updateFromDOM=function(){var e=this;!this.cm.isReadOnly()&&this.pollContent()||hn(this.cm,function(){return vn(e.cm)})},Zs.prototype.setUneditable=function(e){e.contentEditable="false"},Zs.prototype.onKeyPress=function(e){0!=e.charCode&&(e.preventDefault(),this.cm.isReadOnly()||dn(this.cm,$o)(this.cm,String.fromCharCode(null==e.charCode?e.keyCode:e.charCode),0))},Zs.prototype.readOnlyChanged=function(e){this.div.contentEditable=String("nocursor"!=e)},Zs.prototype.onContextMenu=function(){},Zs.prototype.resetPosition=function(){},Zs.prototype.needsContentAttribute=!0;var Qs=function(e){this.cm=e,this.prevInput="",this.pollingFast=!1,this.polling=new Pl,this.hasSelection=!1,this.composing=null};Qs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()});else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type?i.setSelections(t.ranges,null,Gl):(n.prevInput="",l.value=t.text.join("\n"),El(l))}"cut"==e.type&&(i.state.cutIncoming=!0)}}var r=this,n=this,i=this.cm,o=this.wrapper=el(),l=this.textarea=o.firstChild;e.wrapper.insertBefore(o,e.wrapper.firstChild),Ll&&(l.style.width="0px"),Ql(l,"input",function(){gl&&vl>=9&&r.hasSelection&&(r.hasSelection=null),n.poll()}),Ql(l,"paste",function(e){Me(i,e)||qo(e,i)||(i.state.pasteIncoming=!0,n.fastPoll())}),Ql(l,"cut",t),Ql(l,"copy",t),Ql(e.scroller,"paste",function(t){Ft(e,t)||Me(i,t)||(i.state.pasteIncoming=!0,n.focus())}),Ql(e.lineSpace,"selectstart",function(t){Ft(e,t)||We(t)}),Ql(l,"compositionstart",function(){var e=i.getCursor("from");n.composing&&n.composing.range.clear(),n.composing={start:e,range:i.markText(e,i.getCursor("to"),{className:"CodeMirror-composing"})}}),Ql(l,"compositionend",function(){n.composing&&(n.poll(),n.composing.range.clear(),n.composing=null)})},Qs.prototype.prepareSelection=function(){var e=this.cm,t=e.display,r=e.doc,n=Tr(e);if(e.options.moveInputWithCursor){var i=sr(e,r.sel.primary().head,"div"),o=t.wrapper.getBoundingClientRect(),l=t.lineDiv.getBoundingClientRect();n.teTop=Math.max(0,Math.min(t.wrapper.clientHeight-10,i.top+l.top-o.top)),n.teLeft=Math.max(0,Math.min(t.wrapper.clientWidth-10,i.left+l.left-o.left))}return n},Qs.prototype.showSelection=function(e){var t=this.cm.display;r(t.cursorDiv,e.cursors),r(t.selectionDiv,e.selection),null!=e.teTop&&(this.wrapper.style.top=e.teTop+"px",this.wrapper.style.left=e.teLeft+"px")},Qs.prototype.reset=function(e){if(!this.contextMenuPending&&!this.composing){var t=this.cm;if(t.somethingSelected()){this.prevInput="";var r=t.getSelection();this.textarea.value=r,t.state.focused&&El(this.textarea),gl&&vl>=9&&(this.hasSelection=r)}else e||(this.prevInput=this.textarea.value="",gl&&vl>=9&&(this.hasSelection=null))}},Qs.prototype.getField=function(){return this.textarea},Qs.prototype.supportsTouch=function(){return!1},Qs.prototype.focus=function(){if("nocursor"!=this.cm.options.readOnly&&(!Tl||l()!=this.textarea))try{this.textarea.focus()}catch(e){}},Qs.prototype.blur=function(){this.textarea.blur()},Qs.prototype.resetPosition=function(){this.wrapper.style.top=this.wrapper.style.left=0},Qs.prototype.receivedFocus=function(){this.slowPoll()},Qs.prototype.slowPoll=function(){var e=this;this.pollingFast||this.polling.set(this.cm.options.pollInterval,function(){e.poll(),e.cm.state.focused&&e.slowPoll()})},Qs.prototype.fastPoll=function(){function e(){r.poll()||t?(r.pollingFast=!1,r.slowPoll()):(t=!0,r.polling.set(60,e))}var t=!1,r=this;r.pollingFast=!0,r.polling.set(20,e)},Qs.prototype.poll=function(){var e=this,t=this.cm,r=this.textarea,n=this.prevInput;if(this.contextMenuPending||!t.state.focused||ts(r)&&!n&&!this.composing||t.isReadOnly()||t.options.disableInput||t.state.keySeq)return!1;var i=r.value;if(i==n&&!t.somethingSelected())return!1;if(gl&&vl>=9&&this.hasSelection===i||Ml&&/[\uf700-\uf7ff]/.test(i))return t.display.input.reset(),!1;if(t.doc.sel==t.display.selForContextMenu){var o=i.charCodeAt(0);if(8203!=o||n||(n="​"),8666==o)return this.reset(),this.cm.execCommand("undo")}for(var l=0,s=Math.min(n.length,i.length);l<s&&n.charCodeAt(l)==i.charCodeAt(l);)++l;return hn(t,function(){$o(t,i.slice(l),n.length-l,null,e.composing?"*compose":null),i.length>1e3||i.indexOf("\n")>-1?r.value=e.prevInput="":e.prevInput=i,e.composing&&(e.composing.range.clear(),e.composing.range=t.markText(e.composing.start,t.getCursor("to"),{className:"CodeMirror-composing"}))}),!0},Qs.prototype.ensurePolled=function(){this.pollingFast&&this.poll()&&(this.pollingFast=!1)},Qs.prototype.onKeyPress=function(){gl&&vl>=9&&(this.hasSelection=null),this.fastPoll()},Qs.prototype.onContextMenu=function(e){function t(){if(null!=l.selectionStart){var e=i.somethingSelected(),t="​"+(e?l.value:"");l.value="⇚",l.value=t,n.prevInput=e?"":"​",l.selectionStart=1,l.selectionEnd=t.length,o.selForContextMenu=i.doc.sel}}function r(){if(n.contextMenuPending=!1,n.wrapper.style.cssText=c,l.style.cssText=u,gl&&vl<9&&o.scrollbars.setScrollTop(o.scroller.scrollTop=a),null!=l.selectionStart){(!gl||gl&&vl<9)&&t();var e=0,r=function(){o.selForContextMenu==i.doc.sel&&0==l.selectionStart&&l.selectionEnd>0&&"​"==n.prevInput?dn(i,Mi)(i):e++<10?o.detectingSelectAll=setTimeout(r,500):(o.selForContextMenu=null,o.input.reset())};o.detectingSelectAll=setTimeout(r,200)}}var n=this,i=n.cm,o=i.display,l=n.textarea,s=Sr(i,e),a=o.scroller.scrollTop;if(s&&!wl){i.options.resetSelectionOnContextMenu&&-1==i.doc.sel.contains(s)&&dn(i,bi)(i.doc,Rn(s),Gl);var u=l.style.cssText,c=n.wrapper.style.cssText;n.wrapper.style.cssText="position: absolute";var f=n.wrapper.getBoundingClientRect();l.style.cssText="position: absolute; width: 30px; height: 30px;\n      top: "+(e.clientY-f.top-5)+"px; left: "+(e.clientX-f.left-5)+"px;\n      z-index: 1000; background: "+(gl?"rgba(255, 255, 255, .05)":"transparent")+";\n      outline: none; border-width: 0; outline: none; overflow: hidden; opacity: .05; filter: alpha(opacity=5);";var h;if(ml&&(h=window.scrollY),o.input.focus(),ml&&window.scrollTo(null,h),o.input.reset(),i.somethingSelected()||(l.value=n.prevInput=" "),n.contextMenuPending=!0,o.selForContextMenu=i.doc.sel,clearTimeout(o.detectingSelectAll),gl&&vl>=9&&t(),Hl){Fe(e);var d=function(){ke(window,"mouseup",d),setTimeout(r,20)};Ql(window,"mouseup",d)}else setTimeout(r,50)}},Qs.prototype.readOnlyChanged=function(e){e||this.reset(),this.textarea.disabled="nocursor"==e},Qs.prototype.setUneditable=function(){},Qs.prototype.needsContentAttribute=!1,function(e){function t(t,n,i,o){e.defaults[t]=n,i&&(r[t]=o?function(e,t,r){r!=Xs&&i(e,t,r)}:i)}var r=e.optionHandlers;e.defineOption=t,e.Init=Xs,t("value","",function(e,t){return e.setValue(t)},!0),t("mode",null,function(e,t){e.doc.modeOption=t,jn(e)},!0),t("indentUnit",2,jn,!0),t("indentWithTabs",!1),t("smartIndent",!0),t("tabSize",4,function(e){Xn(e),er(e),vn(e)},!0),t("lineSeparator",null,function(e,t){if(e.doc.lineSep=t,t){var r=[],n=e.doc.first;e.doc.iter(function(e){for(var i=0;;){var o=e.text.indexOf(t,i);if(-1==o)break;i=o+t.length,r.push(E(n,o))}n++});for(var i=r.length-1;i>=0;i--)Ei(e.doc,t,r[i],E(r[i].line,r[i].ch+t.length))}}),t("specialChars",/[\u0000-\u001f\u007f-\u009f\u00ad\u061c\u200b-\u200f\u2028\u2029\ufeff]/g,function(e,t,r){e.state.specialChars=new RegExp(t.source+(t.test("\t")?"":"|\t"),"g"),r!=Xs&&e.refresh()}),t("specialCharPlaceholder",at,function(e){return e.refresh()},!0),t("electricChars",!0),t("inputStyle",Tl?"contenteditable":"textarea",function(){throw new Error("inputStyle can not (yet) be changed in a running editor")},!0),t("spellcheck",!1,function(e,t){return e.getInputField().spellcheck=t},!0),t("rtlMoveVisually",!Ol),t("wholeLineUpdateBefore",!0),t("theme","default",function(e){Go(e),Uo(e)},!0),t("keyMap","default",function(e,t,r){var n=uo(t),i=r!=Xs&&uo(r);i&&i.detach&&i.detach(e,n),n.attach&&n.attach(e,i||null)}),t("extraKeys",null),t("configureMouse",null),t("lineWrapping",!1,Ko,!0),t("gutters",[],function(e){Fn(e.options),Uo(e)},!0),t("fixedGutter",!0,function(e,t){e.display.gutters.style.left=t?wr(e.display)+"px":"0",e.refresh()},!0),t("coverGutterNextToScrollbar",!1,function(e){return en(e)},!0),t("scrollbarStyle","native",function(e){rn(e),en(e),e.display.scrollbars.setScrollTop(e.doc.scrollTop),e.display.scrollbars.setScrollLeft(e.doc.scrollLeft)},!0),t("lineNumbers",!1,function(e){Fn(e.options),Uo(e)},!0),t("firstLineNumber",1,Uo,!0),t("lineNumberFormatter",function(e){return e},Uo,!0),t("showCursorWhenSelecting",!1,kr,!0),t("resetSelectionOnContextMenu",!0),t("lineWiseCopyCut",!0),t("pasteLinesPerSelection",!0),t("readOnly",!1,function(e,t){"nocursor"==t&&(Fr(e),e.display.input.blur()),e.display.input.readOnlyChanged(t)}),t("disableInput",!1,function(e,t){t||e.display.input.reset()},!0),t("dragDrop",!0,Vo),t("allowDropFileTypes",null),t("cursorBlinkRate",530),t("cursorScrollMargin",0),t("cursorHeight",1,kr,!0),t("singleCursorHeightPerLine",!0,kr,!0),t("workTime",100),t("workDelay",100),t("flattenSpans",!0,Xn,!0),t("addModeClass",!1,Xn,!0),t("pollInterval",100),t("undoDepth",200,function(e,t){return e.doc.history.undoDepth=t}),t("historyEventDelay",1250),t("viewportMargin",10,function(e){return e.refresh()},!0),t("maxHighlightLength",1e4,Xn,!0),t("moveInputWithCursor",!0,function(e,t){t||e.display.input.resetPosition()}),t("tabindex",null,function(e,t){return e.display.input.getField().tabIndex=t||""}),t("autofocus",null),t("direction","ltr",function(e,t){return e.doc.setDirection(t)},!0)}(jo),function(e){var t=e.optionHandlers,r=e.helpers={};e.prototype={constructor:e,focus:function(){window.focus(),this.display.input.focus()},setOption:function(e,r){var n=this.options,i=n[e];n[e]==r&&"mode"!=e||(n[e]=r,t.hasOwnProperty(e)&&dn(this,t[e])(this,r,i),Te(this,"optionChange",this,e))},getOption:function(e){return this.options[e]},getDoc:function(){return this.doc},addKeyMap:function(e,t){this.state.keyMaps[t?"push":"unshift"](uo(e))},removeKeyMap:function(e){for(var t=this.state.keyMaps,r=0;r<t.length;++r)if(t[r]==e||t[r].name==e)return t.splice(r,1),!0},addOverlay:pn(function(t,r){var n=t.token?t:e.getMode(this.options,t);if(n.startState)throw new Error("Overlays may not be stateful.");m(this.state.overlays,{mode:n,modeSpec:t,opaque:r&&r.opaque,priority:r&&r.priority||0},function(e){return e.priority}),this.state.modeGen++,vn(this)}),removeOverlay:pn(function(e){for(var t=this,r=this.state.overlays,n=0;n<r.length;++n){var i=r[n].modeSpec;if(i==e||"string"==typeof e&&i.name==e)return r.splice(n,1),t.state.modeGen++,void vn(t)}}),indentLine:pn(function(e,t,r){"string"!=typeof t&&"number"!=typeof t&&(t=null==t?this.options.smartIndent?"smart":"prev":t?"add":"subtract"),H(this.doc,e)&&Yo(this,e,t,r)}),indentSelection:pn(function(e){for(var t=this,r=this.doc.sel.ranges,n=-1,i=0;i<r.length;i++){var o=r[i];if(o.empty())o.head.line>n&&(Yo(t,o.head.line,e,!0),n=o.head.line,i==t.doc.sel.primIndex&&jr(t));else{var l=o.from(),s=o.to(),a=Math.max(n,l.line);n=Math.min(t.lastLine(),s.line-(s.ch?0:1))+1;for(var u=a;u<n;++u)Yo(t,u,e);var c=t.doc.sel.ranges;0==l.ch&&r.length==c.length&&c[i].from().ch>0&&gi(t.doc,i,new Ts(l,c[i].to()),Gl)}}}),getTokenAt:function(e,t){return Je(this,e,t)},getLineTokens:function(e,t){return Je(this,E(e),t,!0)},getTokenTypeAt:function(e){e=U(this.doc,e);var t,r=_e(this,M(this.doc,e.line)),n=0,i=(r.length-1)/2,o=e.ch;if(0==o)t=r[2];else for(;;){var l=n+i>>1;if((l?r[2*l-1]:0)>=o)i=l;else{if(!(r[2*l+1]<o)){t=r[2*l+2];break}n=l+1}}var s=t?t.indexOf("overlay "):-1;return s<0?t:0==s?null:t.slice(0,s-1)},getModeAt:function(t){var r=this.doc.mode;return r.innerMode?e.innerMode(r,this.getTokenAt(t).state).mode:r},getHelper:function(e,t){return this.getHelpers(e,t)[0]},getHelpers:function(e,t){var n=this,i=[];if(!r.hasOwnProperty(t))return i;var o=r[t],l=this.getModeAt(e);if("string"==typeof l[t])o[l[t]]&&i.push(o[l[t]]);else if(l[t])for(var s=0;s<l[t].length;s++){var a=o[l[t][s]];a&&i.push(a)}else l.helperType&&o[l.helperType]?i.push(o[l.helperType]):o[l.name]&&i.push(o[l.name]);for(var u=0;u<o._global.length;u++){var c=o._global[u];c.pred(l,n)&&-1==h(i,c.val)&&i.push(c.val)}return i},getStateAfter:function(e,t){var r=this.doc;return e=G(r,null==e?r.first+r.size-1:e),$e(this,e+1,t).state},cursorCoords:function(e,t){var r,n=this.doc.sel.primary();return r=null==e?n.head:"object"==typeof e?U(this.doc,e):e?n.from():n.to(),sr(this,r,t||"page")},charCoords:function(e,t){return lr(this,U(this.doc,e),t||"page")},coordsChar:function(e,t){return e=or(this,e,t||"page"),cr(this,e.left,e.top)},lineAtHeight:function(e,t){return e=or(this,{top:e,left:0},t||"page").top,D(this.doc,e+this.display.viewOffset)},heightAtLine:function(e,t,r){var n,i=!1;if("number"==typeof e){var o=this.doc.first+this.doc.size-1;e<this.doc.first?e=this.doc.first:e>o&&(e=o,i=!0),n=M(this.doc,e)}else n=e;return ir(this,n,{top:0,left:0},t||"page",r||i).top+(i?this.doc.height-ye(n):0)},defaultTextHeight:function(){return mr(this.display)},defaultCharWidth:function(){return yr(this.display)},getViewport:function(){return{from:this.display.viewFrom,to:this.display.viewTo}},addWidget:function(e,t,r,n,i){var o=this.display,l=(e=sr(this,U(this.doc,e))).bottom,s=e.left;if(t.style.position="absolute",t.setAttribute("cm-ignore-events","true"),this.display.input.setUneditable(t),o.sizer.appendChild(t),"over"==n)l=e.top;else if("above"==n||"near"==n){var a=Math.max(o.wrapper.clientHeight,this.doc.height),u=Math.max(o.sizer.clientWidth,o.lineSpace.clientWidth);("above"==n||e.bottom+t.offsetHeight>a)&&e.top>t.offsetHeight?l=e.top-t.offsetHeight:e.bottom+t.offsetHeight<=a&&(l=e.bottom),s+t.offsetWidth>u&&(s=u-t.offsetWidth)}t.style.top=l+"px",t.style.left=t.style.right="","right"==i?(s=o.sizer.clientWidth-t.offsetWidth,t.style.right="0px"):("left"==i?s=0:"middle"==i&&(s=(o.sizer.clientWidth-t.offsetWidth)/2),t.style.left=s+"px"),r&&Ur(this,{left:s,top:l,right:s+t.offsetWidth,bottom:l+t.offsetHeight})},triggerOnKeyDown:pn(Lo),triggerOnKeyPress:pn(Mo),triggerOnKeyUp:To,triggerOnMouseDown:pn(Oo),execCommand:function(e){if(Bs.hasOwnProperty(e))return Bs[e].call(null,this)},triggerElectric:pn(function(e){Zo(this,e)}),findPosH:function(e,t,r,n){var i=this,o=1;t<0&&(o=-1,t=-t);for(var l=U(this.doc,e),s=0;s<t&&!(l=tl(i.doc,l,o,r,n)).hitSide;++s);return l},moveH:pn(function(e,t){var r=this;this.extendSelectionsBy(function(n){return r.display.shift||r.doc.extend||n.empty()?tl(r.doc,n.head,e,t,r.options.rtlMoveVisually):e<0?n.from():n.to()},Vl)}),deleteH:pn(function(e,t){var r=this.doc.sel,n=this.doc;r.somethingSelected()?n.replaceSelection("",null,"+delete"):co(this,function(r){var i=tl(n,r.head,e,t,!1);return e<0?{from:i,to:r.head}:{from:r.head,to:i}})}),findPosV:function(e,t,r,n){var i=this,o=1,l=n;t<0&&(o=-1,t=-t);for(var s=U(this.doc,e),a=0;a<t;++a){var u=sr(i,s,"div");if(null==l?l=u.left:u.left=l,(s=rl(i,u,o,r)).hitSide)break}return s},moveV:pn(function(e,t){var r=this,n=this.doc,i=[],o=!this.display.shift&&!n.extend&&n.sel.somethingSelected();if(n.extendSelectionsBy(function(l){if(o)return e<0?l.from():l.to();var s=sr(r,l.head,"div");null!=l.goalColumn&&(s.left=l.goalColumn),i.push(s.left);var a=rl(r,s,e,t);return"page"==t&&l==n.sel.primary()&&Kr(r,lr(r,a,"div").top-s.top),a},Vl),i.length)for(var l=0;l<n.sel.ranges.length;l++)n.sel.ranges[l].goalColumn=i[l]}),findWordAt:function(e){var t=M(this.doc,e.line).text,r=e.ch,n=e.ch;if(t){var i=this.getHelper(e,"wordChars");"before"!=e.sticky&&n!=t.length||!r?++n:--r;for(var o=t.charAt(r),l=x(o,i)?function(e){return x(e,i)}:/\s/.test(o)?function(e){return/\s/.test(e)}:function(e){return!/\s/.test(e)&&!x(e)};r>0&&l(t.charAt(r-1));)--r;for(;n<t.length&&l(t.charAt(n));)++n}return new Ts(E(e.line,r),E(e.line,n))},toggleOverwrite:function(e){null!=e&&e==this.state.overwrite||((this.state.overwrite=!this.state.overwrite)?s(this.display.cursorDiv,"CodeMirror-overwrite"):Fl(this.display.cursorDiv,"CodeMirror-overwrite"),Te(this,"overwriteToggle",this,this.state.overwrite))},hasFocus:function(){return this.display.input.getField()==l()},isReadOnly:function(){return!(!this.options.readOnly&&!this.doc.cantEdit)},scrollTo:pn(function(e,t){Xr(this,e,t)}),getScrollInfo:function(){var e=this.display.scroller;return{left:e.scrollLeft,top:e.scrollTop,height:e.scrollHeight-zt(this)-this.display.barHeight,width:e.scrollWidth-zt(this)-this.display.barWidth,clientHeight:Bt(this),clientWidth:Rt(this)}},scrollIntoView:pn(function(e,t){null==e?(e={from:this.doc.sel.primary().head,to:null},null==t&&(t=this.options.cursorScrollMargin)):"number"==typeof e?e={from:E(e,0),to:null}:null==e.from&&(e={from:e,to:null}),e.to||(e.to=e.from),e.margin=t||0,null!=e.from.line?Yr(this,e):$r(this,e.from,e.to,e.margin)}),setSize:pn(function(e,t){var r=this,n=function(e){return"number"==typeof e||/^\d+$/.test(String(e))?e+"px":e};null!=e&&(this.display.wrapper.style.width=n(e)),null!=t&&(this.display.wrapper.style.height=n(t)),this.options.lineWrapping&&Jt(this);var i=this.display.viewFrom;this.doc.iter(i,this.display.viewTo,function(e){if(e.widgets)for(var t=0;t<e.widgets.length;t++)if(e.widgets[t].noHScroll){mn(r,i,"widget");break}++i}),this.curOp.forceUpdate=!0,Te(this,"refresh",this)}),operation:function(e){return hn(this,e)},startOperation:function(){return nn(this)},endOperation:function(){return on(this)},refresh:pn(function(){var e=this.display.cachedTextHeight;vn(this),this.curOp.forceUpdate=!0,er(this),Xr(this,this.doc.scrollLeft,this.doc.scrollTop),Wn(this),(null==e||Math.abs(e-mr(this.display))>.5)&&Cr(this),Te(this,"refresh",this)}),swapDoc:pn(function(e){var t=this.doc;return t.cm=null,qn(this,e),er(this),this.display.input.reset(),Xr(this,e.scrollLeft,e.scrollTop),this.curOp.forceScroll=!0,bt(this,"swapDoc",this,t),t}),getInputField:function(){return this.display.input.getField()},getWrapperElement:function(){return this.display.wrapper},getScrollerElement:function(){return this.display.scroller},getGutterElement:function(){return this.display.gutters}},Ae(e),e.registerHelper=function(t,n,i){r.hasOwnProperty(t)||(r[t]=e[t]={_global:[]}),r[t][n]=i},e.registerGlobalHelper=function(t,n,i,o){e.registerHelper(t,n,o),r[t]._global.push({pred:i,val:o})}}(jo);var Js="iter insert remove copy getEditor constructor".split(" ");for(var ea in Ds.prototype)Ds.prototype.hasOwnProperty(ea)&&h(Js,ea)<0&&(jo.prototype[ea]=function(e){return function(){return e.apply(this.doc,arguments)}}(Ds.prototype[ea]));return Ae(Ds),jo.inputStyles={textarea:Qs,contenteditable:Zs},jo.defineMode=function(e){jo.defaults.mode||"null"==e||(jo.defaults.mode=e),Be.apply(this,arguments)},jo.defineMIME=function(e,t){os[e]=t},jo.defineMode("null",function(){return{token:function(e){return e.skipToEnd()}}}),jo.defineMIME("text/plain","null"),jo.defineExtension=function(e,t){jo.prototype[e]=t},jo.defineDocExtension=function(e,t){Ds.prototype[e]=t},jo.fromTextArea=function(e,t){function r(){e.value=a.getValue()}if(t=t?c(t):{},t.value=e.value,!t.tabindex&&e.tabIndex&&(t.tabindex=e.tabIndex),!t.placeholder&&e.placeholder&&(t.placeholder=e.placeholder),null==t.autofocus){var n=l();t.autofocus=n==e||null!=e.getAttribute("autofocus")&&n==document.body}var i;if(e.form&&(Ql(e.form,"submit",r),!t.leaveSubmitMethodAlone)){var o=e.form;i=o.submit;try{var s=o.submit=function(){r(),o.submit=i,o.submit(),o.submit=s}}catch(e){}}t.finishInit=function(t){t.save=r,t.getTextArea=function(){return e},t.toTextArea=function(){t.toTextArea=isNaN,r(),e.parentNode.removeChild(t.getWrapperElement()),e.style.display="",e.form&&(ke(e.form,"submit",r),"function"==typeof e.form.submit&&(e.form.submit=i))}},e.style.display="none";var a=jo(function(t){return e.parentNode.insertBefore(t,e.nextSibling)},t);return a},function(e){e.off=ke,e.on=Ql,e.wheelEventPixels=Pn,e.Doc=Ds,e.splitLines=es,e.countColumn=f,e.findColumn=d,e.isWordChar=w,e.Pass=Bl,e.signal=Te,e.Line=fs,e.changeEnd=Bn,e.scrollbarModel=ws,e.Pos=E,e.cmpPos=P,e.modes=is,e.mimeModes=os,e.resolveMode=Ge,e.getMode=Ue,e.modeExtensions=ls,e.extendMode=Ve,e.copyState=Ke,e.startState=Xe,e.innerMode=je,e.commands=Bs,e.keyMap=Rs,e.keyName=ao,e.isModifierKey=lo,e.lookupKey=oo,e.normalizeKeyMap=io,e.StringStream=ss,e.SharedTextMarker=As,e.TextMarker=Os,e.LineWidget=Ms,e.e_preventDefault=We,e.e_stopPropagation=De,e.e_stop=Fe,e.addClass=s,e.contains=o,e.rmClass=Fl,e.keyNames=Es}(jo),jo.version="5.30.0",jo});
      !function(e){"object"==typeof exports&&"object"==typeof module?e(require("../../lib/codemirror")):"function"==typeof define&&define.amd?define(["../../lib/codemirror"],e):e(CodeMirror)}(function(e){"use strict";function t(e,t,n,r,o,a){this.indented=e,this.column=t,this.type=n,this.info=r,this.align=o,this.prev=a}function n(e,n,r,o){var a=e.indented;return e.context&&"statement"==e.context.type&&"statement"!=r&&(a=e.context.indented),e.context=new t(a,n,r,o,null,e.context)}function r(e){var t=e.context.type;return")"!=t&&"]"!=t&&"}"!=t||(e.indented=e.context.indented),e.context=e.context.prev}function o(e,t,n){return"variable"==t.prevToken||"type"==t.prevToken||(!!/\S(?:[^- ]>|[*\]])\s*$|\*$/.test(e.string.slice(0,n))||(!(!t.typeAtEndOfLine||e.column()!=e.indentation())||void 0))}function a(e){for(;;){if(!e||"top"==e.type)return!0;if("}"==e.type&&"namespace"!=e.prev.info)return!1;e=e.prev}}function i(e){for(var t={},n=e.split(" "),r=0;r<n.length;++r)t[n[r]]=!0;return t}function l(e,t){return"function"==typeof e?e(t):e.propertyIsEnumerable(t)}function s(e,t){if(!t.startOfLine)return!1;for(var n,r=null;n=e.peek();){if("\\"==n&&e.match(/^.$/)){r=s;break}if("/"==n&&e.match(/^\/[\/\*]/,!1))break;e.next()}return t.tokenize=r,"meta"}function c(e,t){return"type"==t.prevToken&&"type"}function u(e){return e.eatWhile(/[\w\.']/),"number"}function d(e,t){if(e.backUp(1),e.match(/(R|u8R|uR|UR|LR)/)){var n=e.match(/"([^\s\\()]{0,16})\(/);return!!n&&(t.cpp11RawStringDelim=n[1],t.tokenize=m,m(e,t))}return e.match(/(u8|u|U|L)/)?!!e.match(/["']/,!1)&&"string":(e.next(),!1)}function f(e){var t=/(\w+)::~?(\w+)$/.exec(e);return t&&t[1]==t[2]}function p(e,t){for(var n;null!=(n=e.next());)if('"'==n&&!e.eat('"')){t.tokenize=null;break}return"string"}function m(e,t){var n=t.cpp11RawStringDelim.replace(/[^\w\s]/g,"\\$&");return e.match(new RegExp(".*?\\)"+n+'"'))?t.tokenize=null:e.skipToEnd(),"string"}function h(t,n){function r(e){if(e)for(var t in e)e.hasOwnProperty(t)&&o.push(t)}"string"==typeof t&&(t=[t]);var o=[];r(n.keywords),r(n.types),r(n.builtin),r(n.atoms),o.length&&(n.helperType=t[0],e.registerHelper("hintWords",t[0],o));for(var a=0;a<t.length;++a)e.defineMIME(t[a],n)}function g(e,t){for(var n=!1;!e.eol();){if(!n&&e.match('"""')){t.tokenize=null;break}n="\\"==e.next()&&!n}return"string"}function y(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!e&&!o&&t.match('"')){a=!0;break}if(e&&t.match('"""')){a=!0;break}r=t.next(),!o&&"$"==r&&t.match("{")&&t.skipTo("}"),o=!o&&"\\"==r&&!e}return!a&&e||(n.tokenize=null),"string"}}function x(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!o&&t.match('"')&&("single"==e||t.match('""'))){a=!0;break}if(!o&&t.match("``")){w=x(e),a=!0;break}r=t.next(),o="single"==e&&!o&&"\\"==r}return a&&(n.tokenize=null),"string"}}e.defineMode("clike",function(i,s){function c(e,t){var n=e.next();if(S[n]){var r=S[n](e,t);if(!1!==r)return r}if('"'==n||"'"==n)return t.tokenize=u(n),t.tokenize(e,t);if(D.test(n))return p=n,null;if(L.test(n)){if(e.backUp(1),e.match(I))return"number";e.next()}if("/"==n){if(e.eat("*"))return t.tokenize=d,d(e,t);if(e.eat("/"))return e.skipToEnd(),"comment"}if(F.test(n)){for(;!e.match(/^\/[\/*]/,!1)&&e.eat(F););return"operator"}if(e.eatWhile(z),P)for(;e.match(P);)e.eatWhile(z);var o=e.current();return l(x,o)?(l(w,o)&&(p="newstatement"),l(v,o)&&(m=!0),"keyword"):l(b,o)?"type":l(k,o)?(l(w,o)&&(p="newstatement"),"builtin"):l(_,o)?"atom":"variable"}function u(e){return function(t,n){for(var r,o=!1,a=!1;null!=(r=t.next());){if(r==e&&!o){a=!0;break}o=!o&&"\\"==r}return(a||!o&&!C)&&(n.tokenize=null),"string"}}function d(e,t){for(var n,r=!1;n=e.next();){if("/"==n&&r){t.tokenize=null;break}r="*"==n}return"comment"}function f(e,t){s.typeFirstDefinitions&&e.eol()&&a(t.context)&&(t.typeAtEndOfLine=o(e,t,e.pos))}var p,m,h=i.indentUnit,g=s.statementIndentUnit||h,y=s.dontAlignCalls,x=s.keywords||{},b=s.types||{},k=s.builtin||{},w=s.blockKeywords||{},v=s.defKeywords||{},_=s.atoms||{},S=s.hooks||{},C=s.multiLineStrings,T=!1!==s.indentStatements,M=!1!==s.indentSwitch,P=s.namespaceSeparator,D=s.isPunctuationChar||/[\[\]{}\(\),;\:\.]/,L=s.numberStart||/[\d\.]/,I=s.number||/^(?:0x[a-f\d]+|0b[01]+|(?:\d+\.?\d*|\.\d+)(?:e[-+]?\d+)?)(u|ll?|l|f)?/i,F=s.isOperatorChar||/[+\-*&%=<>!?|\/]/,z=s.isIdentifierChar||/[\w\$_\xa1-\uffff]/;return{startState:function(e){return{tokenize:null,context:new t((e||0)-h,0,"top",null,!1),indented:0,startOfLine:!0,prevToken:null}},token:function(e,t){var i=t.context;if(e.sol()&&(null==i.align&&(i.align=!1),t.indented=e.indentation(),t.startOfLine=!0),e.eatSpace())return f(e,t),null;p=m=null;var l=(t.tokenize||c)(e,t);if("comment"==l||"meta"==l)return l;if(null==i.align&&(i.align=!0),";"==p||":"==p||","==p&&e.match(/^\s*(?:\/\/.*)?$/,!1))for(;"statement"==t.context.type;)r(t);else if("{"==p)n(t,e.column(),"}");else if("["==p)n(t,e.column(),"]");else if("("==p)n(t,e.column(),")");else if("}"==p){for(;"statement"==i.type;)i=r(t);for("}"==i.type&&(i=r(t));"statement"==i.type;)i=r(t)}else p==i.type?r(t):T&&(("}"==i.type||"top"==i.type)&&";"!=p||"statement"==i.type&&"newstatement"==p)&&n(t,e.column(),"statement",e.current());if("variable"==l&&("def"==t.prevToken||s.typeFirstDefinitions&&o(e,t,e.start)&&a(t.context)&&e.match(/^\s*\(/,!1))&&(l="def"),S.token){var u=S.token(e,t,l);void 0!==u&&(l=u)}return"def"==l&&!1===s.styleDefs&&(l="variable"),t.startOfLine=!1,t.prevToken=m?"def":l||p,f(e,t),l},indent:function(t,n){if(t.tokenize!=c&&null!=t.tokenize||t.typeAtEndOfLine)return e.Pass;var r=t.context,o=n&&n.charAt(0);if("statement"==r.type&&"}"==o&&(r=r.prev),s.dontIndentStatements)for(;"statement"==r.type&&s.dontIndentStatements.test(r.info);)r=r.prev;if(S.indent){var a=S.indent(t,r,n);if("number"==typeof a)return a}var i=o==r.type,l=r.prev&&"switch"==r.prev.info;if(s.allmanIndentation&&/[{(]/.test(o)){for(;"top"!=r.type&&"}"!=r.type;)r=r.prev;return r.indented}return"statement"==r.type?r.indented+("{"==o?0:g):!r.align||y&&")"==r.type?")"!=r.type||i?r.indented+(i?0:h)+(i||!l||/^(?:case|default)\b/.test(n)?0:h):r.indented+g:r.column+(i?0:1)},electricInput:M?/^\s*(?:case .*?:|default:|\{\}?|\})$/:/^\s*[{}]$/,blockCommentStart:"/*",blockCommentEnd:"*/",lineComment:"//",fold:"brace"}});var b="auto if break case register continue return default do sizeof static else struct switch extern typedef union for goto while enum const volatile",k="int long char short double float unsigned signed void size_t ptrdiff_t";h(["text/x-csrc","text/x-c","text/x-chdr"],{name:"clike",keywords:i(b),types:i(k+" bool _Complex _Bool float_t double_t intptr_t intmax_t int8_t int16_t int32_t int64_t uintptr_t uintmax_t uint8_t uint16_t uint32_t uint64_t"),blockKeywords:i("case do else for if switch while struct"),defKeywords:i("struct"),typeFirstDefinitions:!0,atoms:i("null true false"),hooks:{"#":s,"*":c},modeProps:{fold:["brace","include"]}}),h(["text/x-c++src","text/x-c++hdr"],{name:"clike",keywords:i(b+" asm dynamic_cast namespace reinterpret_cast try explicit new static_cast typeid catch operator template typename class friend private this using const_cast inline public throw virtual delete mutable protected alignas alignof constexpr decltype nullptr noexcept thread_local final static_assert override"),types:i(k+" bool wchar_t"),blockKeywords:i("catch class do else finally for if struct switch try while"),defKeywords:i("class namespace struct enum union"),typeFirstDefinitions:!0,atoms:i("true false null"),dontIndentStatements:/^template$/,isIdentifierChar:/[\w\$_~\xa1-\uffff]/,hooks:{"#":s,"*":c,u:d,U:d,L:d,R:d,0:u,1:u,2:u,3:u,4:u,5:u,6:u,7:u,8:u,9:u,token:function(e,t,n){if("variable"==n&&"("==e.peek()&&(";"==t.prevToken||null==t.prevToken||"}"==t.prevToken)&&f(e.current()))return"def"}},namespaceSeparator:"::",modeProps:{fold:["brace","include"]}}),h("text/x-java",{name:"clike",keywords:i("abstract assert break case catch class const continue default do else enum extends final finally float for goto if implements import instanceof interface native new package private protected public return static strictfp super switch synchronized this throw throws transient try volatile while @interface"),types:i("byte short int long float double boolean char void Boolean Byte Character Double Float Integer Long Number Object Short String StringBuffer StringBuilder Void"),blockKeywords:i("catch class do else finally for if switch try while"),defKeywords:i("class interface package enum @interface"),typeFirstDefinitions:!0,atoms:i("true false null"),number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,hooks:{"@":function(e){return!e.match("interface",!1)&&(e.eatWhile(/[\w\$_]/),"meta")}},modeProps:{fold:["brace","import"]}}),h("text/x-csharp",{name:"clike",keywords:i("abstract as async await base break case catch checked class const continue default delegate do else enum event explicit extern finally fixed for foreach goto if implicit in interface internal is lock namespace new operator out override params private protected public readonly ref return sealed sizeof stackalloc static struct switch this throw try typeof unchecked unsafe using virtual void volatile while add alias ascending descending dynamic from get global group into join let orderby partial remove select set value var yield"),types:i("Action Boolean Byte Char DateTime DateTimeOffset Decimal Double Func Guid Int16 Int32 Int64 Object SByte Single String Task TimeSpan UInt16 UInt32 UInt64 bool byte char decimal double short int long object sbyte float string ushort uint ulong"),blockKeywords:i("catch class do else finally for foreach if struct switch try while"),defKeywords:i("class interface namespace struct var"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"@":function(e,t){return e.eat('"')?(t.tokenize=p,p(e,t)):(e.eatWhile(/[\w\$_]/),"meta")}}}),h("text/x-scala",{name:"clike",keywords:i("abstract case catch class def do else extends final finally for forSome if implicit import lazy match new null object override package private protected return sealed super this throw trait try type val var while with yield _ assert assume require print println printf readLine readBoolean readByte readShort readChar readInt readLong readFloat readDouble"),types:i("AnyVal App Application Array BufferedIterator BigDecimal BigInt Char Console Either Enumeration Equiv Error Exception Fractional Function IndexedSeq Int Integral Iterable Iterator List Map Numeric Nil NotNull Option Ordered Ordering PartialFunction PartialOrdering Product Proxy Range Responder Seq Serializable Set Specializable Stream StringBuilder StringContext Symbol Throwable Traversable TraversableOnce Tuple Unit Vector Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),multiLineStrings:!0,blockKeywords:i("catch class enum do else finally for forSome if match switch try while"),defKeywords:i("class enum def object package trait type val var"),atoms:i("true false null"),indentStatements:!1,indentSwitch:!1,isOperatorChar:/[+\-*&%=<>!?|\/#:@]/,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return!!e.match('""')&&(t.tokenize=g,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},"=":function(e,n){var r=n.context;return!("}"!=r.type||!r.align||!e.eat(">"))&&(n.context=new t(r.indented,r.column,r.type,r.info,null,r.prev),"operator")}},modeProps:{closeBrackets:{triples:'"'}}}),h("text/x-kotlin",{name:"clike",keywords:i("package as typealias class interface this super val var fun for is in This throw return break continue object if else while do try when !in !is as? file import where by get set abstract enum open inner override private public internal protected catch finally out final vararg reified dynamic companion constructor init sealed field property receiver param sparam lateinit data inline noinline tailrec external annotation crossinline const operator infix suspend"),types:i("Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),intendSwitch:!1,indentStatements:!1,multiLineStrings:!0,number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,blockKeywords:i("catch class do else finally for if where try while enum"),defKeywords:i("class val var object package interface fun"),atoms:i("true false null this"),hooks:{'"':function(e,t){return t.tokenize=y(e.match('""')),t.tokenize(e,t)}},modeProps:{closeBrackets:{triples:'"'}}}),h(["x-shader/x-vertex","x-shader/x-fragment"],{name:"clike",keywords:i("sampler1D sampler2D sampler3D samplerCube sampler1DShadow sampler2DShadow const attribute uniform varying break continue discard return for while do if else struct in out inout"),types:i("float int bool void vec2 vec3 vec4 ivec2 ivec3 ivec4 bvec2 bvec3 bvec4 mat2 mat3 mat4"),blockKeywords:i("for while do if else struct"),builtin:i("radians degrees sin cos tan asin acos atan pow exp log exp2 sqrt inversesqrt abs sign floor ceil fract mod min max clamp mix step smoothstep length distance dot cross normalize ftransform faceforward reflect refract matrixCompMult lessThan lessThanEqual greaterThan greaterThanEqual equal notEqual any all not texture1D texture1DProj texture1DLod texture1DProjLod texture2D texture2DProj texture2DLod texture2DProjLod texture3D texture3DProj texture3DLod texture3DProjLod textureCube textureCubeLod shadow1D shadow2D shadow1DProj shadow2DProj shadow1DLod shadow2DLod shadow1DProjLod shadow2DProjLod dFdx dFdy fwidth noise1 noise2 noise3 noise4"),atoms:i("true false gl_FragColor gl_SecondaryColor gl_Normal gl_Vertex gl_MultiTexCoord0 gl_MultiTexCoord1 gl_MultiTexCoord2 gl_MultiTexCoord3 gl_MultiTexCoord4 gl_MultiTexCoord5 gl_MultiTexCoord6 gl_MultiTexCoord7 gl_FogCoord gl_PointCoord gl_Position gl_PointSize gl_ClipVertex gl_FrontColor gl_BackColor gl_FrontSecondaryColor gl_BackSecondaryColor gl_TexCoord gl_FogFragCoord gl_FragCoord gl_FrontFacing gl_FragData gl_FragDepth gl_ModelViewMatrix gl_ProjectionMatrix gl_ModelViewProjectionMatrix gl_TextureMatrix gl_NormalMatrix gl_ModelViewMatrixInverse gl_ProjectionMatrixInverse gl_ModelViewProjectionMatrixInverse gl_TexureMatrixTranspose gl_ModelViewMatrixInverseTranspose gl_ProjectionMatrixInverseTranspose gl_ModelViewProjectionMatrixInverseTranspose gl_TextureMatrixInverseTranspose gl_NormalScale gl_DepthRange gl_ClipPlane gl_Point gl_FrontMaterial gl_BackMaterial gl_LightSource gl_LightModel gl_FrontLightModelProduct gl_BackLightModelProduct gl_TextureColor gl_EyePlaneS gl_EyePlaneT gl_EyePlaneR gl_EyePlaneQ gl_FogParameters gl_MaxLights gl_MaxClipPlanes gl_MaxTextureUnits gl_MaxTextureCoords gl_MaxVertexAttribs gl_MaxVertexUniformComponents gl_MaxVaryingFloats gl_MaxVertexTextureImageUnits gl_MaxTextureImageUnits gl_MaxFragmentUniformComponents gl_MaxCombineTextureImageUnits gl_MaxDrawBuffers"),indentSwitch:!1,hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-nesc",{name:"clike",keywords:i(b+"as atomic async call command component components configuration event generic implementation includes interface module new norace nx_struct nx_union post provides signal task uses abstract extends"),types:i(k),blockKeywords:i("case do else for if switch while struct"),atoms:i("null true false"),hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-objectivec",{name:"clike",keywords:i(b+"inline restrict _Bool _Complex _Imaginary BOOL Class bycopy byref id IMP in inout nil oneway out Protocol SEL self super atomic nonatomic retain copy readwrite readonly"),types:i(k),atoms:i("YES NO NULL NILL ON OFF true false"),hooks:{"@":function(e){return e.eatWhile(/[\w\$]/),"keyword"},"#":s,indent:function(e,t,n){if("statement"==t.type&&/^@\w/.test(n))return t.indented}},modeProps:{fold:"brace"}}),h("text/x-squirrel",{name:"clike",keywords:i("base break clone continue const default delete enum extends function in class foreach local resume return this throw typeof yield constructor instanceof static"),types:i(k),blockKeywords:i("case catch class else for foreach if switch try while"),defKeywords:i("function local class"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"#":s},modeProps:{fold:["brace","include"]}});var w=null;h("text/x-ceylon",{name:"clike",keywords:i("abstracts alias assembly assert assign break case catch class continue dynamic else exists extends finally for function given if import in interface is let module new nonempty object of out outer package return satisfies super switch then this throw try value void while"),types:function(e){var t=e.charAt(0);return t===t.toUpperCase()&&t!==t.toLowerCase()},blockKeywords:i("case catch class dynamic else finally for function if interface module new object switch try while"),defKeywords:i("class dynamic function interface module object package value"),builtin:i("abstract actual aliased annotation by default deprecated doc final formal late license native optional sealed see serializable shared suppressWarnings tagged throws variable"),isPunctuationChar:/[\[\]{}\(\),;\:\.`]/,isOperatorChar:/[+\-*&%=<>!?|^~:\/]/,numberStart:/[\d#$]/,number:/^(?:#[\da-fA-F_]+|\$[01_]+|[\d_]+[kMGTPmunpf]?|[\d_]+\.[\d_]+(?:[eE][-+]?\d+|[kMGTPmunpf]|)|)/i,multiLineStrings:!0,typeFirstDefinitions:!0,atoms:i("true false null larger smaller equal empty finished"),indentSwitch:!1,styleDefs:!1,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return t.tokenize=x(e.match('""')?"triple":"single"),t.tokenize(e,t)},"`":function(e,t){return!(!w||!e.match("`"))&&(t.tokenize=w,w=null,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},token:function(e,t,n){if(("variable"==n||"type"==n)&&"."==t.prevToken)return"variable-2"}},modeProps:{fold:["brace","import"],closeBrackets:{triples:'"'}}})});
      // -------------------------------------------------------------------------
//  Part of the CodeChecker project, under the Apache License v2.0 with
//  LLVM Exceptions. See LICENSE for license information.
//  SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
// -------------------------------------------------------------------------

var BugViewer = {
  _files : [],
  _reports : [],
  _lineWidgets : [],
  _navigationMenuItems : [],
  _sourceFileData : null,
  _currentReport : null,
  _lastBugEvent  : null,

  init : function (files, reports) {
    this._files = files;
    this._reports = reports;

    this.initEscapeChars();
  },

  initEscapeChars : function () {
    this.escapeChars = {
      ' ' : 'nbsp',
      '<' : 'lt',
      '>' : 'gt',
      '"' : 'quot',
      '&' : 'amp'
    };

    var regexString = '[';
    for (var key in this.escapeChars) {
      regexString += key;
    }
    regexString += ']';

    this.escapeRegExp = new RegExp( regexString, 'g');
  },

  escapeHTML : function (str) {
    var that = this;

    return str.replace(this.escapeRegExp, function (m) {
      return '&' + that.escapeChars[m] + ';';
    });
  },

  initByUrl : function () {
    if (!this._reports) return;

    var state = {};
    window.location.hash.substr(1).split('&').forEach(function (s) {
      var parts = s.split('=');
      state[parts[0]] = parts[1];
    });

    for (var key in this._reports) {
      var report = this._reports[key];
      if (report.reportHash === state['reportHash']) {
        this.navigate(report);
        return;
      }
    }

    this.navigate(this._reports[0]);
  },

  create : function () {
    this._content = document.getElementById('editor-wrapper');
    this._filepath = document.getElementById('file-path');
    this._checkerName = document.getElementById('checker-name');
    this._reviewStatusWrapper =
      document.getElementById('review-status-wrapper');
    this._reviewStatus = document.getElementById('review-status');
    this._editor = document.getElementById('editor');

    this._codeMirror = CodeMirror(this._editor, {
      mode: 'text/x-c++src',
      matchBrackets : true,
      lineNumbers : true,
      readOnly : true,
      foldGutter : true,
      extraKeys : {},
      viewportMargin : 100
    });

    this._createNavigationMenu();
  },

  navigate : function (report, item) {
    if (!item) {
      var items = this._navigationMenuItems.filter(function (navItem) {
        return navItem.report.reportHash === report.reportHash;
      });

      if (!items.length) return;

      item = items[0].widget;
    }

    this._selectedReport.classList.remove('active');
    this._selectedReport = item;
    this._selectedReport.classList.add('active');
    this.setReport(report);
  },

  _createNavigationMenu : function () {
    var that = this;

    var nav = document.getElementById('report-nav');
    var list = document.createElement('ul');
    this._reports.forEach(function (report) {
      var events = report['events'];
      var lastBugEvent = events[events.length - 1];
      var item = document.createElement('li');

      var severity = document.createElement('i');
      severity.className = 'severity-' + report.severity.toLowerCase();

      item.appendChild(severity);
      item.appendChild(document.createTextNode(lastBugEvent.message));

      item.addEventListener('click', function () {
        that.navigate(report, item);
      })
      list.appendChild(item);
      that._navigationMenuItems.push({ report : report, widget : item });
    });

    if (!this._selectedReport && list.childNodes.length) {
      this._selectedReport = list.childNodes[0];
      this._selectedReport.classList.add('active');
    }

    nav.appendChild(list);
  },

  setReport : function (report) {
    this._currentReport = report;
    var events = report['events'];
    var lastBugEvent = events[events.length - 1];
    this.setCurrentBugEvent(lastBugEvent, events.length - 1);
    this.setCheckerName(report.checkerName);
    this.setReviewStatus(report.reviewStatus);

    window.location.hash = '#reportHash=' + report.reportHash;
  },

  setCurrentBugEvent : function (event, idx) {
    this._currentBugEvent = event;
    this.setSourceFileData(this._files[event.location.file]);
    this.drawBugPath();

    this.jumpTo(event.location.line, 0);
    this.highlightBugEvent(event, idx);
  },

  highlightBugEvent : function (event, idx) {
    this._lineWidgets.forEach(function (widget) {
      var lineIdx = widget.node.getAttribute('idx');
      if (parseInt(lineIdx) === idx) {
        widget.node.classList.add('current');
      }
    });
  },

  setCheckerName : function (checkerName) {
    this._checkerName.innerHTML = checkerName;
  },

  setReviewStatus : function (status) {
    if (status) {
      var className =
        'review-status-' + status.toLowerCase().split(' ').join('-');
      this._reviewStatus.className = "review-status " + className;

      this._reviewStatus.innerHTML = status;
      this._reviewStatusWrapper.style.display = 'block';
    } else {
      this._reviewStatusWrapper.style.display = 'none';
    }
  },

  setSourceFileData : function (file) {
    if (this._sourceFileData && file.id === this._sourceFileData.id) {
      return;
    }

    this._sourceFileData = file;
    this._filepath.innerHTML = file.path;
    this._codeMirror.doc.setValue(file.content);
    this._refresh();
  },

  _refresh : function () {
    var that = this;
    setTimeout(function () {
      var fullHeight = parseInt(that._content.clientHeight);
      var headerHeight = that._filepath.clientHeight;

      that._codeMirror.setSize('auto', fullHeight - headerHeight);
      that._codeMirror.refresh();
    }, 200);
  },

  clearBubbles : function () {
    this._lineWidgets.forEach(function (widget) { widget.clear(); });
    this._lineWidgets = [];
  },

  getMessage : function (event, kind) {
    if (kind === 'macro') {
      var name = 'macro expansion' + (event.name ? ': ' + event.name : '');

      return '<span class="tag macro">' + name + '</span>'
        + this.escapeHTML(event.expansion).replace(/(?:\r\n|\r|\n)/g, '<br>');
    } else if (kind === 'note') {
      return '<span class="tag note">note</span>'
        +  this.escapeHTML(event.message).replace(/(?:\r\n|\r|\n)/g, '<br>');
    }
  },

  addExtraPathEvents : function (events, kind) {
    var that = this;

    if (!events) {
      return;
    }

    events.forEach(function (event) {
      if (event.location.file !== that._currentBugEvent.location.file) {
        return;
      }

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + kind);

      var msg = document.createElement('span');
      msg.innerHTML = that.getMessage(event, kind);
      element.appendChild(msg);

      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  drawBugPath : function () {
    var that = this;

    this.clearBubbles();

    this.addExtraPathEvents(this._currentReport.macros, 'macro');
    this.addExtraPathEvents(this._currentReport.notes, 'note');

    // Processing bug path events.
    var currentEvents = this._currentReport.events;
    currentEvents.forEach(function (event, step) {
      if (event.location.file !== that._currentBugEvent.location.file)
        return;

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';
      var type = step === currentEvents.length - 1 ? 'error' : 'info';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + type);
      element.setAttribute('idx', step);

      var enumeration = document.createElement('span');
      enumeration.setAttribute('class', 'checker-enum ' + type);
      enumeration.innerHTML = step + 1;

      if (currentEvents.length > 1)
        element.appendChild(enumeration);

      var prevBugEvent = step - 1;
      if (step > 0) {
        var prevBug = document.createElement('span');
        prevBug.setAttribute('class', 'arrow left-arrow');
        prevBug.addEventListener('click', function () {
          var event = currentEvents[prevBugEvent];
          that.setCurrentBugEvent(event, prevBugEvent);
        });
        element.appendChild(prevBug);
      }

      var msg = document.createElement('span');
      msg.innerHTML = that.escapeHTML(event.message)
        .replace(/(?:\r\n|\r|\n)/g, '<br>');

      element.appendChild(msg);

      var nextBugEvent = step + 1;
      if (nextBugEvent < currentEvents.length) {
        var nextBug = document.createElement('span');
        nextBug.setAttribute('class', 'arrow right-arrow');
        nextBug.addEventListener('click', function () {
          var event = currentEvents[nextBugEvent];
          that.setCurrentBugEvent(event, nextBugEvent);
        });
        element.appendChild(nextBug);
      }


      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  jumpTo : function (line, column) {
    var that = this;

    setTimeout(function () {
      var selPosPixel
        = that._codeMirror.charCoords({ line : line, ch : column }, 'local');
      var editorSize = {
        width  : that._editor.clientWidth,
        height : that._editor.clientHeight
      };

      that._codeMirror.scrollIntoView({
        top    : selPosPixel.top - 100,
        bottom : selPosPixel.top + editorSize.height - 150,
        left   : selPosPixel.left < editorSize.width - 100
               ? 0
               : selPosPixel.left - 50,
        right  : selPosPixel.left < editorSize.width - 100
               ? 10
               : selPosPixel.left + editorSize.width - 100
      });
    }, 0);
  }
}


      var data = {"files": {"13": {"id": 13, "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/NestedNameSpecifier.h", "content": "//===- NestedNameSpecifier.h - C++ nested name specifiers -------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n//  This file defines the NestedNameSpecifier class, which represents\n//  a C++ nested-name-specifier.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_CLANG_AST_NESTEDNAMESPECIFIER_H\n#define LLVM_CLANG_AST_NESTEDNAMESPECIFIER_H\n\n#include \"clang/AST/DependenceFlags.h\"\n#include \"clang/Basic/Diagnostic.h\"\n#include \"clang/Basic/SourceLocation.h\"\n#include \"llvm/ADT/DenseMapInfo.h\"\n#include \"llvm/ADT/FoldingSet.h\"\n#include \"llvm/ADT/PointerIntPair.h\"\n#include \"llvm/Support/Compiler.h\"\n#include <cstdint>\n#include <cstdlib>\n#include <utility>\n\nnamespace clang {\n\nclass ASTContext;\nclass CXXRecordDecl;\nclass IdentifierInfo;\nclass LangOptions;\nclass NamespaceAliasDecl;\nclass NamespaceDecl;\nstruct PrintingPolicy;\nclass Type;\nclass TypeLoc;\n\n/// Represents a C++ nested name specifier, such as\n/// \"\\::std::vector<int>::\".\n///\n/// C++ nested name specifiers are the prefixes to qualified\n/// names. For example, \"foo::\" in \"foo::x\" is a nested name\n/// specifier. Nested name specifiers are made up of a sequence of\n/// specifiers, each of which can be a namespace, type, identifier\n/// (for dependent names), decltype specifier, or the global specifier ('::').\n/// The last two specifiers can only appear at the start of a\n/// nested-namespace-specifier.\nclass NestedNameSpecifier : public llvm::FoldingSetNode {\n  /// Enumeration describing\n  enum StoredSpecifierKind {\n    StoredIdentifier = 0,\n    StoredDecl = 1,\n    StoredTypeSpec = 2,\n    StoredTypeSpecWithTemplate = 3\n  };\n\n  /// The nested name specifier that precedes this nested name\n  /// specifier.\n  ///\n  /// The pointer is the nested-name-specifier that precedes this\n  /// one. The integer stores one of the first four values of type\n  /// SpecifierKind.\n  llvm::PointerIntPair<NestedNameSpecifier *, 2, StoredSpecifierKind> Prefix;\n\n  /// The last component in the nested name specifier, which\n  /// can be an identifier, a declaration, or a type.\n  ///\n  /// When the pointer is NULL, this specifier represents the global\n  /// specifier '::'. Otherwise, the pointer is one of\n  /// IdentifierInfo*, Namespace*, or Type*, depending on the kind of\n  /// specifier as encoded within the prefix.\n  void* Specifier = nullptr;\n\npublic:\n  /// The kind of specifier that completes this nested name\n  /// specifier.\n  enum SpecifierKind {\n    /// An identifier, stored as an IdentifierInfo*.\n    Identifier,\n\n    /// A namespace, stored as a NamespaceDecl*.\n    Namespace,\n\n    /// A namespace alias, stored as a NamespaceAliasDecl*.\n    NamespaceAlias,\n\n    /// A type, stored as a Type*.\n    TypeSpec,\n\n    /// A type that was preceded by the 'template' keyword,\n    /// stored as a Type*.\n    TypeSpecWithTemplate,\n\n    /// The global specifier '::'. There is no stored value.\n    Global,\n\n    /// Microsoft's '__super' specifier, stored as a CXXRecordDecl* of\n    /// the class it appeared in.\n    Super\n  };\n\nprivate:\n  /// Builds the global specifier.\n  NestedNameSpecifier() : Prefix(nullptr, StoredIdentifier) {}\n\n  /// Copy constructor used internally to clone nested name\n  /// specifiers.\n  NestedNameSpecifier(const NestedNameSpecifier &Other) = default;\n\n  /// Either find or insert the given nested name specifier\n  /// mockup in the given context.\n  static NestedNameSpecifier *FindOrInsert(const ASTContext &Context,\n                                           const NestedNameSpecifier &Mockup);\n\npublic:\n  NestedNameSpecifier &operator=(const NestedNameSpecifier &) = delete;\n\n  /// Builds a specifier combining a prefix and an identifier.\n  ///\n  /// The prefix must be dependent, since nested name specifiers\n  /// referencing an identifier are only permitted when the identifier\n  /// cannot be resolved.\n  static NestedNameSpecifier *Create(const ASTContext &Context,\n                                     NestedNameSpecifier *Prefix,\n                                     IdentifierInfo *II);\n\n  /// Builds a nested name specifier that names a namespace.\n  static NestedNameSpecifier *Create(const ASTContext &Context,\n                                     NestedNameSpecifier *Prefix,\n                                     const NamespaceDecl *NS);\n\n  /// Builds a nested name specifier that names a namespace alias.\n  static NestedNameSpecifier *Create(const ASTContext &Context,\n                                     NestedNameSpecifier *Prefix,\n                                     NamespaceAliasDecl *Alias);\n\n  /// Builds a nested name specifier that names a type.\n  static NestedNameSpecifier *Create(const ASTContext &Context,\n                                     NestedNameSpecifier *Prefix,\n                                     bool Template, const Type *T);\n\n  /// Builds a specifier that consists of just an identifier.\n  ///\n  /// The nested-name-specifier is assumed to be dependent, but has no\n  /// prefix because the prefix is implied by something outside of the\n  /// nested name specifier, e.g., in \"x->Base::f\", the \"x\" has a dependent\n  /// type.\n  static NestedNameSpecifier *Create(const ASTContext &Context,\n                                     IdentifierInfo *II);\n\n  /// Returns the nested name specifier representing the global\n  /// scope.\n  static NestedNameSpecifier *GlobalSpecifier(const ASTContext &Context);\n\n  /// Returns the nested name specifier representing the __super scope\n  /// for the given CXXRecordDecl.\n  static NestedNameSpecifier *SuperSpecifier(const ASTContext &Context,\n                                             CXXRecordDecl *RD);\n\n  /// Return the prefix of this nested name specifier.\n  ///\n  /// The prefix contains all of the parts of the nested name\n  /// specifier that preced this current specifier. For example, for a\n  /// nested name specifier that represents \"foo::bar::\", the current\n  /// specifier will contain \"bar::\" and the prefix will contain\n  /// \"foo::\".\n  NestedNameSpecifier *getPrefix() const { return Prefix.getPointer(); }\n\n  /// Determine what kind of nested name specifier is stored.\n  SpecifierKind getKind() const;\n\n  /// Retrieve the identifier stored in this nested name\n  /// specifier.\n  IdentifierInfo *getAsIdentifier() const {\n    if (Prefix.getInt() == StoredIdentifier)\n      return (IdentifierInfo *)Specifier;\n\n    return nullptr;\n  }\n\n  /// Retrieve the namespace stored in this nested name\n  /// specifier.\n  NamespaceDecl *getAsNamespace() const;\n\n  /// Retrieve the namespace alias stored in this nested name\n  /// specifier.\n  NamespaceAliasDecl *getAsNamespaceAlias() const;\n\n  /// Retrieve the record declaration stored in this nested name\n  /// specifier.\n  CXXRecordDecl *getAsRecordDecl() const;\n\n  /// Retrieve the type stored in this nested name specifier.\n  const Type *getAsType() const {\n    if (Prefix.getInt() == StoredTypeSpec ||\n        Prefix.getInt() == StoredTypeSpecWithTemplate)\n      return (const Type *)Specifier;\n\n    return nullptr;\n  }\n\n  NestedNameSpecifierDependence getDependence() const;\n\n  /// Whether this nested name specifier refers to a dependent\n  /// type or not.\n  bool isDependent() const;\n\n  /// Whether this nested name specifier involves a template\n  /// parameter.\n  bool isInstantiationDependent() const;\n\n  /// Whether this nested-name-specifier contains an unexpanded\n  /// parameter pack (for C++11 variadic templates).\n  bool containsUnexpandedParameterPack() const;\n\n  /// Whether this nested name specifier contains an error.\n  bool containsErrors() const;\n\n  /// Print this nested name specifier to the given output stream. If\n  /// `ResolveTemplateArguments` is true, we'll print actual types, e.g.\n  /// `ns::SomeTemplate<int, MyClass>` instead of\n  /// `ns::SomeTemplate<Container::value_type, T>`.\n  void print(raw_ostream &OS, const PrintingPolicy &Policy,\n             bool ResolveTemplateArguments = false) const;\n\n  void Profile(llvm::FoldingSetNodeID &ID) const {\n    ID.AddPointer(Prefix.getOpaqueValue());\n    ID.AddPointer(Specifier);\n  }\n\n  /// Dump the nested name specifier to standard output to aid\n  /// in debugging.\n  void dump(const LangOptions &LO) const;\n  void dump() const;\n  void dump(llvm::raw_ostream &OS) const;\n  void dump(llvm::raw_ostream &OS, const LangOptions &LO) const;\n};\n\n/// A C++ nested-name-specifier augmented with source location\n/// information.\nclass NestedNameSpecifierLoc {\n  NestedNameSpecifier *Qualifier = nullptr;\n  void *Data = nullptr;\n\n  /// Determines the data length for the last component in the\n  /// given nested-name-specifier.\n  static unsigned getLocalDataLength(NestedNameSpecifier *Qualifier);\n\n  /// Determines the data length for the entire\n  /// nested-name-specifier.\n  static unsigned getDataLength(NestedNameSpecifier *Qualifier);\n\npublic:\n  /// Construct an empty nested-name-specifier.\n  NestedNameSpecifierLoc() = default;\n\n  /// Construct a nested-name-specifier with source location information\n  /// from\n  NestedNameSpecifierLoc(NestedNameSpecifier *Qualifier, void *Data)\n      : Qualifier(Qualifier), Data(Data) {}\n\n  /// Evaluates true when this nested-name-specifier location is\n  /// non-empty.\n  explicit operator bool() const { return Qualifier; }\n\n  /// Evaluates true when this nested-name-specifier location is\n  /// empty.\n  bool hasQualifier() const { return Qualifier; }\n\n  /// Retrieve the nested-name-specifier to which this instance\n  /// refers.\n  NestedNameSpecifier *getNestedNameSpecifier() const {\n    return Qualifier;\n  }\n\n  /// Retrieve the opaque pointer that refers to source-location data.\n  void *getOpaqueData() const { return Data; }\n\n  /// Retrieve the source range covering the entirety of this\n  /// nested-name-specifier.\n  ///\n  /// For example, if this instance refers to a nested-name-specifier\n  /// \\c \\::std::vector<int>::, the returned source range would cover\n  /// from the initial '::' to the last '::'.\n  SourceRange getSourceRange() const LLVM_READONLY;\n\n  /// Retrieve the source range covering just the last part of\n  /// this nested-name-specifier, not including the prefix.\n  ///\n  /// For example, if this instance refers to a nested-name-specifier\n  /// \\c \\::std::vector<int>::, the returned source range would cover\n  /// from \"vector\" to the last '::'.\n  SourceRange getLocalSourceRange() const;\n\n  /// Retrieve the location of the beginning of this\n  /// nested-name-specifier.\n  SourceLocation getBeginLoc() const {\n    return getSourceRange().getBegin();\n  }\n\n  /// Retrieve the location of the end of this\n  /// nested-name-specifier.\n  SourceLocation getEndLoc() const {\n    return getSourceRange().getEnd();\n  }\n\n  /// Retrieve the location of the beginning of this\n  /// component of the nested-name-specifier.\n  SourceLocation getLocalBeginLoc() const {\n    return getLocalSourceRange().getBegin();\n  }\n\n  /// Retrieve the location of the end of this component of the\n  /// nested-name-specifier.\n  SourceLocation getLocalEndLoc() const {\n    return getLocalSourceRange().getEnd();\n  }\n\n  /// Return the prefix of this nested-name-specifier.\n  ///\n  /// For example, if this instance refers to a nested-name-specifier\n  /// \\c \\::std::vector<int>::, the prefix is \\c \\::std::. Note that the\n  /// returned prefix may be empty, if this is the first component of\n  /// the nested-name-specifier.\n  NestedNameSpecifierLoc getPrefix() const {\n    if (!Qualifier)\n      return *this;\n\n    return NestedNameSpecifierLoc(Qualifier->getPrefix(), Data);\n  }\n\n  /// For a nested-name-specifier that refers to a type,\n  /// retrieve the type with source-location information.\n  TypeLoc getTypeLoc() const;\n\n  /// Determines the data length for the entire\n  /// nested-name-specifier.\n  unsigned getDataLength() const { return getDataLength(Qualifier); }\n\n  friend bool operator==(NestedNameSpecifierLoc X,\n                         NestedNameSpecifierLoc Y) {\n    return X.Qualifier == Y.Qualifier && X.Data == Y.Data;\n  }\n\n  friend bool operator!=(NestedNameSpecifierLoc X,\n                         NestedNameSpecifierLoc Y) {\n    return !(X == Y);\n  }\n};\n\n/// Class that aids in the construction of nested-name-specifiers along\n/// with source-location information for all of the components of the\n/// nested-name-specifier.\nclass NestedNameSpecifierLocBuilder {\n  /// The current representation of the nested-name-specifier we're\n  /// building.\n  NestedNameSpecifier *Representation = nullptr;\n\n  /// Buffer used to store source-location information for the\n  /// nested-name-specifier.\n  ///\n  /// Note that we explicitly manage the buffer (rather than using a\n  /// SmallVector) because \\c Declarator expects it to be possible to memcpy()\n  /// a \\c CXXScopeSpec, and CXXScopeSpec uses a NestedNameSpecifierLocBuilder.\n  char *Buffer = nullptr;\n\n  /// The size of the buffer used to store source-location information\n  /// for the nested-name-specifier.\n  unsigned BufferSize = 0;\n\n  /// The capacity of the buffer used to store source-location\n  /// information for the nested-name-specifier.\n  unsigned BufferCapacity = 0;\n\npublic:\n  NestedNameSpecifierLocBuilder() = default;\n  NestedNameSpecifierLocBuilder(const NestedNameSpecifierLocBuilder &Other);\n\n  NestedNameSpecifierLocBuilder &\n  operator=(const NestedNameSpecifierLocBuilder &Other);\n\n  ~NestedNameSpecifierLocBuilder() {\n    if (BufferCapacity)\n      free(Buffer);\n  }\n\n  /// Retrieve the representation of the nested-name-specifier.\n  NestedNameSpecifier *getRepresentation() const { return Representation; }\n\n  /// Extend the current nested-name-specifier by another\n  /// nested-name-specifier component of the form 'type::'.\n  ///\n  /// \\param Context The AST context in which this nested-name-specifier\n  /// resides.\n  ///\n  /// \\param TemplateKWLoc The location of the 'template' keyword, if present.\n  ///\n  /// \\param TL The TypeLoc that describes the type preceding the '::'.\n  ///\n  /// \\param ColonColonLoc The location of the trailing '::'.\n  void Extend(ASTContext &Context, SourceLocation TemplateKWLoc, TypeLoc TL,\n              SourceLocation ColonColonLoc);\n\n  /// Extend the current nested-name-specifier by another\n  /// nested-name-specifier component of the form 'identifier::'.\n  ///\n  /// \\param Context The AST context in which this nested-name-specifier\n  /// resides.\n  ///\n  /// \\param Identifier The identifier.\n  ///\n  /// \\param IdentifierLoc The location of the identifier.\n  ///\n  /// \\param ColonColonLoc The location of the trailing '::'.\n  void Extend(ASTContext &Context, IdentifierInfo *Identifier,\n              SourceLocation IdentifierLoc, SourceLocation ColonColonLoc);\n\n  /// Extend the current nested-name-specifier by another\n  /// nested-name-specifier component of the form 'namespace::'.\n  ///\n  /// \\param Context The AST context in which this nested-name-specifier\n  /// resides.\n  ///\n  /// \\param Namespace The namespace.\n  ///\n  /// \\param NamespaceLoc The location of the namespace name.\n  ///\n  /// \\param ColonColonLoc The location of the trailing '::'.\n  void Extend(ASTContext &Context, NamespaceDecl *Namespace,\n              SourceLocation NamespaceLoc, SourceLocation ColonColonLoc);\n\n  /// Extend the current nested-name-specifier by another\n  /// nested-name-specifier component of the form 'namespace-alias::'.\n  ///\n  /// \\param Context The AST context in which this nested-name-specifier\n  /// resides.\n  ///\n  /// \\param Alias The namespace alias.\n  ///\n  /// \\param AliasLoc The location of the namespace alias\n  /// name.\n  ///\n  /// \\param ColonColonLoc The location of the trailing '::'.\n  void Extend(ASTContext &Context, NamespaceAliasDecl *Alias,\n              SourceLocation AliasLoc, SourceLocation ColonColonLoc);\n\n  /// Turn this (empty) nested-name-specifier into the global\n  /// nested-name-specifier '::'.\n  void MakeGlobal(ASTContext &Context, SourceLocation ColonColonLoc);\n\n  /// Turns this (empty) nested-name-specifier into '__super'\n  /// nested-name-specifier.\n  ///\n  /// \\param Context The AST context in which this nested-name-specifier\n  /// resides.\n  ///\n  /// \\param RD The declaration of the class in which nested-name-specifier\n  /// appeared.\n  ///\n  /// \\param SuperLoc The location of the '__super' keyword.\n  /// name.\n  ///\n  /// \\param ColonColonLoc The location of the trailing '::'.\n  void MakeSuper(ASTContext &Context, CXXRecordDecl *RD,\n                 SourceLocation SuperLoc, SourceLocation ColonColonLoc);\n\n  /// Make a new nested-name-specifier from incomplete source-location\n  /// information.\n  ///\n  /// This routine should be used very, very rarely, in cases where we\n  /// need to synthesize a nested-name-specifier. Most code should instead use\n  /// \\c Adopt() with a proper \\c NestedNameSpecifierLoc.\n  void MakeTrivial(ASTContext &Context, NestedNameSpecifier *Qualifier,\n                   SourceRange R);\n\n  /// Adopt an existing nested-name-specifier (with source-range\n  /// information).\n  void Adopt(NestedNameSpecifierLoc Other);\n\n  /// Retrieve the source range covered by this nested-name-specifier.\n  SourceRange getSourceRange() const LLVM_READONLY {\n    return NestedNameSpecifierLoc(Representation, Buffer).getSourceRange();\n  }\n\n  /// Retrieve a nested-name-specifier with location information,\n  /// copied into the given AST context.\n  ///\n  /// \\param Context The context into which this nested-name-specifier will be\n  /// copied.\n  NestedNameSpecifierLoc getWithLocInContext(ASTContext &Context) const;\n\n  /// Retrieve a nested-name-specifier with location\n  /// information based on the information in this builder.\n  ///\n  /// This loc will contain references to the builder's internal data and may\n  /// be invalidated by any change to the builder.\n  NestedNameSpecifierLoc getTemporary() const {\n    return NestedNameSpecifierLoc(Representation, Buffer);\n  }\n\n  /// Clear out this builder, and prepare it to build another\n  /// nested-name-specifier with source-location information.\n  void Clear() {\n    Representation = nullptr;\n    BufferSize = 0;\n  }\n\n  /// Retrieve the underlying buffer.\n  ///\n  /// \\returns A pair containing a pointer to the buffer of source-location\n  /// data and the size of the source-location data that resides in that\n  /// buffer.\n  std::pair<char *, unsigned> getBuffer() const {\n    return std::make_pair(Buffer, BufferSize);\n  }\n};\n\n/// Insertion operator for diagnostics.  This allows sending\n/// NestedNameSpecifiers into a diagnostic with <<.\ninline const StreamingDiagnostic &operator<<(const StreamingDiagnostic &DB,\n                                             NestedNameSpecifier *NNS) {\n  DB.AddTaggedVal(reinterpret_cast<intptr_t>(NNS),\n                  DiagnosticsEngine::ak_nestednamespec);\n  return DB;\n}\n\n} // namespace clang\n\nnamespace llvm {\n\ntemplate <> struct DenseMapInfo<clang::NestedNameSpecifierLoc> {\n  using FirstInfo = DenseMapInfo<clang::NestedNameSpecifier *>;\n  using SecondInfo = DenseMapInfo<void *>;\n\n  static clang::NestedNameSpecifierLoc getEmptyKey() {\n    return clang::NestedNameSpecifierLoc(FirstInfo::getEmptyKey(),\n                                         SecondInfo::getEmptyKey());\n  }\n\n  static clang::NestedNameSpecifierLoc getTombstoneKey() {\n    return clang::NestedNameSpecifierLoc(FirstInfo::getTombstoneKey(),\n                                         SecondInfo::getTombstoneKey());\n  }\n\n  static unsigned getHashValue(const clang::NestedNameSpecifierLoc &PairVal) {\n    return hash_combine(\n        FirstInfo::getHashValue(PairVal.getNestedNameSpecifier()),\n        SecondInfo::getHashValue(PairVal.getOpaqueData()));\n  }\n\n  static bool isEqual(const clang::NestedNameSpecifierLoc &LHS,\n                      const clang::NestedNameSpecifierLoc &RHS) {\n    return LHS == RHS;\n  }\n};\n} // namespace llvm\n\n#endif // LLVM_CLANG_AST_NESTEDNAMESPECIFIER_H\n"}, "15": {"id": 15, "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/TemplateBase.h", "content": "//===- TemplateBase.h - Core classes for C++ templates ----------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n//  This file provides definitions which are common for all kinds of\n//  template representation.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_CLANG_AST_TEMPLATEBASE_H\n#define LLVM_CLANG_AST_TEMPLATEBASE_H\n\n#include \"clang/AST/DependenceFlags.h\"\n#include \"clang/AST/NestedNameSpecifier.h\"\n#include \"clang/AST/TemplateName.h\"\n#include \"clang/AST/Type.h\"\n#include \"clang/Basic/LLVM.h\"\n#include \"clang/Basic/SourceLocation.h\"\n#include \"llvm/ADT/APInt.h\"\n#include \"llvm/ADT/APSInt.h\"\n#include \"llvm/ADT/ArrayRef.h\"\n#include \"llvm/ADT/None.h\"\n#include \"llvm/ADT/Optional.h\"\n#include \"llvm/ADT/SmallVector.h\"\n#include \"llvm/Support/Compiler.h\"\n#include \"llvm/Support/TrailingObjects.h\"\n#include <cassert>\n#include <cstddef>\n#include <cstdint>\n\nnamespace llvm {\n\nclass FoldingSetNodeID;\n\n// Provide PointerLikeTypeTraits for clang::Expr*, this default one requires a\n// full definition of Expr, but this file only sees a forward del because of\n// the dependency.\ntemplate <> struct PointerLikeTypeTraits<clang::Expr *> {\n  static inline void *getAsVoidPointer(clang::Expr *P) { return P; }\n  static inline clang::Expr *getFromVoidPointer(void *P) {\n    return static_cast<clang::Expr *>(P);\n  }\n  static constexpr int NumLowBitsAvailable = 2;\n};\n\n} // namespace llvm\n\nnamespace clang {\n\nclass ASTContext;\nclass DiagnosticBuilder;\nclass Expr;\nstruct PrintingPolicy;\nclass TypeSourceInfo;\nclass ValueDecl;\n\n/// Represents a template argument.\nclass TemplateArgument {\npublic:\n  /// The kind of template argument we're storing.\n  enum ArgKind {\n    /// Represents an empty template argument, e.g., one that has not\n    /// been deduced.\n    Null = 0,\n\n    /// The template argument is a type.\n    Type,\n\n    /// The template argument is a declaration that was provided for a pointer,\n    /// reference, or pointer to member non-type template parameter.\n    Declaration,\n\n    /// The template argument is a null pointer or null pointer to member that\n    /// was provided for a non-type template parameter.\n    NullPtr,\n\n    /// The template argument is an integral value stored in an llvm::APSInt\n    /// that was provided for an integral non-type template parameter.\n    Integral,\n\n    /// The template argument is a template name that was provided for a\n    /// template template parameter.\n    Template,\n\n    /// The template argument is a pack expansion of a template name that was\n    /// provided for a template template parameter.\n    TemplateExpansion,\n\n    /// The template argument is an expression, and we've not resolved it to one\n    /// of the other forms yet, either because it's dependent or because we're\n    /// representing a non-canonical template argument (for instance, in a\n    /// TemplateSpecializationType).\n    Expression,\n\n    /// The template argument is actually a parameter pack. Arguments are stored\n    /// in the Args struct.\n    Pack\n  };\n\nprivate:\n  /// The kind of template argument we're storing.\n\n  struct DA {\n    unsigned Kind;\n    void *QT;\n    ValueDecl *D;\n  };\n  struct I {\n    unsigned Kind;\n    // We store a decomposed APSInt with the data allocated by ASTContext if\n    // BitWidth > 64. The memory may be shared between multiple\n    // TemplateArgument instances.\n    unsigned BitWidth : 31;\n    unsigned IsUnsigned : 1;\n    union {\n      /// Used to store the <= 64 bits integer value.\n      uint64_t VAL;\n\n      /// Used to store the >64 bits integer value.\n      const uint64_t *pVal;\n    };\n    void *Type;\n  };\n  struct A {\n    unsigned Kind;\n    unsigned NumArgs;\n    const TemplateArgument *Args;\n  };\n  struct TA {\n    unsigned Kind;\n    unsigned NumExpansions;\n    void *Name;\n  };\n  struct TV {\n    unsigned Kind;\n    uintptr_t V;\n  };\n  union {\n    struct DA DeclArg;\n    struct I Integer;\n    struct A Args;\n    struct TA TemplateArg;\n    struct TV TypeOrValue;\n  };\n\npublic:\n  /// Construct an empty, invalid template argument.\n  constexpr TemplateArgument() : TypeOrValue({Null, 0}) {}\n\n  /// Construct a template type argument.\n  TemplateArgument(QualType T, bool isNullPtr = false) {\n    TypeOrValue.Kind = isNullPtr ? NullPtr : Type;\n    TypeOrValue.V = reinterpret_cast<uintptr_t>(T.getAsOpaquePtr());\n  }\n\n  /// Construct a template argument that refers to a\n  /// declaration, which is either an external declaration or a\n  /// template declaration.\n  TemplateArgument(ValueDecl *D, QualType QT) {\n    assert(D && \"Expected decl\");\n    DeclArg.Kind = Declaration;\n    DeclArg.QT = QT.getAsOpaquePtr();\n    DeclArg.D = D;\n  }\n\n  /// Construct an integral constant template argument. The memory to\n  /// store the value is allocated with Ctx.\n  TemplateArgument(ASTContext &Ctx, const llvm::APSInt &Value, QualType Type);\n\n  /// Construct an integral constant template argument with the same\n  /// value as Other but a different type.\n  TemplateArgument(const TemplateArgument &Other, QualType Type) {\n    Integer = Other.Integer;\n    Integer.Type = Type.getAsOpaquePtr();\n  }\n\n  /// Construct a template argument that is a template.\n  ///\n  /// This form of template argument is generally used for template template\n  /// parameters. However, the template name could be a dependent template\n  /// name that ends up being instantiated to a function template whose address\n  /// is taken.\n  ///\n  /// \\param Name The template name.\n  TemplateArgument(TemplateName Name) {\n    TemplateArg.Kind = Template;\n    TemplateArg.Name = Name.getAsVoidPointer();\n    TemplateArg.NumExpansions = 0;\n  }\n\n  /// Construct a template argument that is a template pack expansion.\n  ///\n  /// This form of template argument is generally used for template template\n  /// parameters. However, the template name could be a dependent template\n  /// name that ends up being instantiated to a function template whose address\n  /// is taken.\n  ///\n  /// \\param Name The template name.\n  ///\n  /// \\param NumExpansions The number of expansions that will be generated by\n  /// instantiating\n  TemplateArgument(TemplateName Name, Optional<unsigned> NumExpansions) {\n    TemplateArg.Kind = TemplateExpansion;\n    TemplateArg.Name = Name.getAsVoidPointer();\n    if (NumExpansions)\n      TemplateArg.NumExpansions = *NumExpansions + 1;\n    else\n      TemplateArg.NumExpansions = 0;\n  }\n\n  /// Construct a template argument that is an expression.\n  ///\n  /// This form of template argument only occurs in template argument\n  /// lists used for dependent types and for expression; it will not\n  /// occur in a non-dependent, canonical template argument list.\n  TemplateArgument(Expr *E) {\n    TypeOrValue.Kind = Expression;\n    TypeOrValue.V = reinterpret_cast<uintptr_t>(E);\n  }\n\n  /// Construct a template argument that is a template argument pack.\n  ///\n  /// We assume that storage for the template arguments provided\n  /// outlives the TemplateArgument itself.\n  explicit TemplateArgument(ArrayRef<TemplateArgument> Args) {\n    this->Args.Kind = Pack;\n    this->Args.Args = Args.data();\n    this->Args.NumArgs = Args.size();\n  }\n\n  TemplateArgument(TemplateName, bool) = delete;\n\n  static TemplateArgument getEmptyPack() { return TemplateArgument(None); }\n\n  /// Create a new template argument pack by copying the given set of\n  /// template arguments.\n  static TemplateArgument CreatePackCopy(ASTContext &Context,\n                                         ArrayRef<TemplateArgument> Args);\n\n  /// Return the kind of stored template argument.\n  ArgKind getKind() const { return (ArgKind)TypeOrValue.Kind; }\n\n  /// Determine whether this template argument has no value.\n  bool isNull() const { return getKind() == Null; }\n\n  TemplateArgumentDependence getDependence() const;\n\n  /// Whether this template argument is dependent on a template\n  /// parameter such that its result can change from one instantiation to\n  /// another.\n  bool isDependent() const;\n\n  /// Whether this template argument is dependent on a template\n  /// parameter.\n  bool isInstantiationDependent() const;\n\n  /// Whether this template argument contains an unexpanded\n  /// parameter pack.\n  bool containsUnexpandedParameterPack() const;\n\n  /// Determine whether this template argument is a pack expansion.\n  bool isPackExpansion() const;\n\n  /// Retrieve the type for a type template argument.\n  QualType getAsType() const {\n    assert(getKind() == Type && \"Unexpected kind\");\n    return QualType::getFromOpaquePtr(reinterpret_cast<void*>(TypeOrValue.V));\n  }\n\n  /// Retrieve the declaration for a declaration non-type\n  /// template argument.\n  ValueDecl *getAsDecl() const {\n    assert(getKind() == Declaration && \"Unexpected kind\");\n    return DeclArg.D;\n  }\n\n  QualType getParamTypeForDecl() const {\n    assert(getKind() == Declaration && \"Unexpected kind\");\n    return QualType::getFromOpaquePtr(DeclArg.QT);\n  }\n\n  /// Retrieve the type for null non-type template argument.\n  QualType getNullPtrType() const {\n    assert(getKind() == NullPtr && \"Unexpected kind\");\n    return QualType::getFromOpaquePtr(reinterpret_cast<void*>(TypeOrValue.V));\n  }\n\n  /// Retrieve the template name for a template name argument.\n  TemplateName getAsTemplate() const {\n    assert(getKind() == Template && \"Unexpected kind\");\n    return TemplateName::getFromVoidPointer(TemplateArg.Name);\n  }\n\n  /// Retrieve the template argument as a template name; if the argument\n  /// is a pack expansion, return the pattern as a template name.\n  TemplateName getAsTemplateOrTemplatePattern() const {\n    assert((getKind() == Template || getKind() == TemplateExpansion) &&\n           \"Unexpected kind\");\n\n    return TemplateName::getFromVoidPointer(TemplateArg.Name);\n  }\n\n  /// Retrieve the number of expansions that a template template argument\n  /// expansion will produce, if known.\n  Optional<unsigned> getNumTemplateExpansions() const;\n\n  /// Retrieve the template argument as an integral value.\n  // FIXME: Provide a way to read the integral data without copying the value.\n  llvm::APSInt getAsIntegral() const {\n    assert(getKind() == Integral && \"Unexpected kind\");\n\n    using namespace llvm;\n\n    if (Integer.BitWidth <= 64)\n      return APSInt(APInt(Integer.BitWidth, Integer.VAL), Integer.IsUnsigned);\n\n    unsigned NumWords = APInt::getNumWords(Integer.BitWidth);\n    return APSInt(APInt(Integer.BitWidth, makeArrayRef(Integer.pVal, NumWords)),\n                  Integer.IsUnsigned);\n  }\n\n  /// Retrieve the type of the integral value.\n  QualType getIntegralType() const {\n    assert(getKind() == Integral && \"Unexpected kind\");\n    return QualType::getFromOpaquePtr(Integer.Type);\n  }\n\n  void setIntegralType(QualType T) {\n    assert(getKind() == Integral && \"Unexpected kind\");\n    Integer.Type = T.getAsOpaquePtr();\n  }\n\n  /// If this is a non-type template argument, get its type. Otherwise,\n  /// returns a null QualType.\n  QualType getNonTypeTemplateArgumentType() const;\n\n  /// Retrieve the template argument as an expression.\n  Expr *getAsExpr() const {\n    assert(getKind() == Expression && \"Unexpected kind\");\n    return reinterpret_cast<Expr *>(TypeOrValue.V);\n  }\n\n  /// Iterator that traverses the elements of a template argument pack.\n  using pack_iterator = const TemplateArgument *;\n\n  /// Iterator referencing the first argument of a template argument\n  /// pack.\n  pack_iterator pack_begin() const {\n    assert(getKind() == Pack);\n    return Args.Args;\n  }\n\n  /// Iterator referencing one past the last argument of a template\n  /// argument pack.\n  pack_iterator pack_end() const {\n    assert(getKind() == Pack);\n    return Args.Args + Args.NumArgs;\n  }\n\n  /// Iterator range referencing all of the elements of a template\n  /// argument pack.\n  ArrayRef<TemplateArgument> pack_elements() const {\n    return llvm::makeArrayRef(pack_begin(), pack_end());\n  }\n\n  /// The number of template arguments in the given template argument\n  /// pack.\n  unsigned pack_size() const {\n    assert(getKind() == Pack);\n    return Args.NumArgs;\n  }\n\n  /// Return the array of arguments in this template argument pack.\n  ArrayRef<TemplateArgument> getPackAsArray() const {\n    assert(getKind() == Pack);\n    return llvm::makeArrayRef(Args.Args, Args.NumArgs);\n  }\n\n  /// Determines whether two template arguments are superficially the\n  /// same.\n  bool structurallyEquals(const TemplateArgument &Other) const;\n\n  /// When the template argument is a pack expansion, returns\n  /// the pattern of the pack expansion.\n  TemplateArgument getPackExpansionPattern() const;\n\n  /// Print this template argument to the given output stream.\n  void print(const PrintingPolicy &Policy, raw_ostream &Out) const;\n\n  /// Debugging aid that dumps the template argument.\n  void dump(raw_ostream &Out) const;\n\n  /// Debugging aid that dumps the template argument to standard error.\n  void dump() const;\n\n  /// Used to insert TemplateArguments into FoldingSets.\n  void Profile(llvm::FoldingSetNodeID &ID, const ASTContext &Context) const;\n};\n\n/// Location information for a TemplateArgument.\nstruct TemplateArgumentLocInfo {\nprivate:\n  struct TemplateTemplateArgLocInfo {\n    // FIXME: We'd like to just use the qualifier in the TemplateName,\n    // but template arguments get canonicalized too quickly.\n    NestedNameSpecifier *Qualifier;\n    void *QualifierLocData;\n    SourceLocation TemplateNameLoc;\n    SourceLocation EllipsisLoc;\n  };\n\n  llvm::PointerUnion<TemplateTemplateArgLocInfo *, Expr *, TypeSourceInfo *>\n      Pointer;\n\n  TemplateTemplateArgLocInfo *getTemplate() const {\n    return Pointer.get<TemplateTemplateArgLocInfo *>();\n  }\n\npublic:\n  TemplateArgumentLocInfo() {}\n  TemplateArgumentLocInfo(TypeSourceInfo *Declarator) { Pointer = Declarator; }\n\n  TemplateArgumentLocInfo(Expr *E) { Pointer = E; }\n  // Ctx is used for allocation -- this case is unusually large and also rare,\n  // so we store the payload out-of-line.\n  TemplateArgumentLocInfo(ASTContext &Ctx, NestedNameSpecifierLoc QualifierLoc,\n                          SourceLocation TemplateNameLoc,\n                          SourceLocation EllipsisLoc);\n\n  TypeSourceInfo *getAsTypeSourceInfo() const {\n    return Pointer.get<TypeSourceInfo *>();\n  }\n\n  Expr *getAsExpr() const { return Pointer.get<Expr *>(); }\n\n  NestedNameSpecifierLoc getTemplateQualifierLoc() const {\n    const auto *Template = getTemplate();\n    return NestedNameSpecifierLoc(Template->Qualifier,\n                                  Template->QualifierLocData);\n  }\n\n  SourceLocation getTemplateNameLoc() const {\n    return getTemplate()->TemplateNameLoc;\n  }\n\n  SourceLocation getTemplateEllipsisLoc() const {\n    return getTemplate()->EllipsisLoc;\n  }\n};\n\n/// Location wrapper for a TemplateArgument.  TemplateArgument is to\n/// TemplateArgumentLoc as Type is to TypeLoc.\nclass TemplateArgumentLoc {\n  TemplateArgument Argument;\n  TemplateArgumentLocInfo LocInfo;\n\npublic:\n  TemplateArgumentLoc() {}\n\n  TemplateArgumentLoc(const TemplateArgument &Argument,\n                      TemplateArgumentLocInfo Opaque)\n      : Argument(Argument), LocInfo(Opaque) {}\n\n  TemplateArgumentLoc(const TemplateArgument &Argument, TypeSourceInfo *TInfo)\n      : Argument(Argument), LocInfo(TInfo) {\n    assert(Argument.getKind() == TemplateArgument::Type);\n  }\n\n  TemplateArgumentLoc(const TemplateArgument &Argument, Expr *E)\n      : Argument(Argument), LocInfo(E) {\n\n    // Permit any kind of template argument that can be represented with an\n    // expression.\n    assert(Argument.getKind() == TemplateArgument::NullPtr ||\n           Argument.getKind() == TemplateArgument::Integral ||\n           Argument.getKind() == TemplateArgument::Declaration ||\n           Argument.getKind() == TemplateArgument::Expression);\n  }\n\n  TemplateArgumentLoc(ASTContext &Ctx, const TemplateArgument &Argument,\n                      NestedNameSpecifierLoc QualifierLoc,\n                      SourceLocation TemplateNameLoc,\n                      SourceLocation EllipsisLoc = SourceLocation())\n      : Argument(Argument),\n        LocInfo(Ctx, QualifierLoc, TemplateNameLoc, EllipsisLoc) {\n    assert(Argument.getKind() == TemplateArgument::Template ||\n           Argument.getKind() == TemplateArgument::TemplateExpansion);\n  }\n\n  /// - Fetches the primary location of the argument.\n  SourceLocation getLocation() const {\n    if (Argument.getKind() == TemplateArgument::Template ||\n        Argument.getKind() == TemplateArgument::TemplateExpansion)\n      return getTemplateNameLoc();\n\n    return getSourceRange().getBegin();\n  }\n\n  /// - Fetches the full source range of the argument.\n  SourceRange getSourceRange() const LLVM_READONLY;\n\n  const TemplateArgument &getArgument() const {\n    return Argument;\n  }\n\n  TemplateArgumentLocInfo getLocInfo() const {\n    return LocInfo;\n  }\n\n  TypeSourceInfo *getTypeSourceInfo() const {\n    assert(Argument.getKind() == TemplateArgument::Type);\n    return LocInfo.getAsTypeSourceInfo();\n  }\n\n  Expr *getSourceExpression() const {\n    assert(Argument.getKind() == TemplateArgument::Expression);\n    return LocInfo.getAsExpr();\n  }\n\n  Expr *getSourceDeclExpression() const {\n    assert(Argument.getKind() == TemplateArgument::Declaration);\n    return LocInfo.getAsExpr();\n  }\n\n  Expr *getSourceNullPtrExpression() const {\n    assert(Argument.getKind() == TemplateArgument::NullPtr);\n    return LocInfo.getAsExpr();\n  }\n\n  Expr *getSourceIntegralExpression() const {\n    assert(Argument.getKind() == TemplateArgument::Integral);\n    return LocInfo.getAsExpr();\n  }\n\n  NestedNameSpecifierLoc getTemplateQualifierLoc() const {\n    if (Argument.getKind() != TemplateArgument::Template &&\n        Argument.getKind() != TemplateArgument::TemplateExpansion)\n      return NestedNameSpecifierLoc();\n    return LocInfo.getTemplateQualifierLoc();\n  }\n\n  SourceLocation getTemplateNameLoc() const {\n    if (Argument.getKind() != TemplateArgument::Template &&\n        Argument.getKind() != TemplateArgument::TemplateExpansion)\n      return SourceLocation();\n    return LocInfo.getTemplateNameLoc();\n  }\n\n  SourceLocation getTemplateEllipsisLoc() const {\n    if (Argument.getKind() != TemplateArgument::TemplateExpansion)\n      return SourceLocation();\n    return LocInfo.getTemplateEllipsisLoc();\n  }\n};\n\n/// A convenient class for passing around template argument\n/// information.  Designed to be passed by reference.\nclass TemplateArgumentListInfo {\n  SmallVector<TemplateArgumentLoc, 8> Arguments;\n  SourceLocation LAngleLoc;\n  SourceLocation RAngleLoc;\n\npublic:\n  TemplateArgumentListInfo() = default;\n\n  TemplateArgumentListInfo(SourceLocation LAngleLoc,\n                           SourceLocation RAngleLoc)\n      : LAngleLoc(LAngleLoc), RAngleLoc(RAngleLoc) {}\n\n  // This can leak if used in an AST node, use ASTTemplateArgumentListInfo\n  // instead.\n  void *operator new(size_t bytes, ASTContext &C) = delete;\n\n  SourceLocation getLAngleLoc() const { return LAngleLoc; }\n  SourceLocation getRAngleLoc() const { return RAngleLoc; }\n\n  void setLAngleLoc(SourceLocation Loc) { LAngleLoc = Loc; }\n  void setRAngleLoc(SourceLocation Loc) { RAngleLoc = Loc; }\n\n  unsigned size() const { return Arguments.size(); }\n\n  const TemplateArgumentLoc *getArgumentArray() const {\n    return Arguments.data();\n  }\n\n  llvm::ArrayRef<TemplateArgumentLoc> arguments() const {\n    return Arguments;\n  }\n\n  const TemplateArgumentLoc &operator[](unsigned I) const {\n    return Arguments[I];\n  }\n\n  TemplateArgumentLoc &operator[](unsigned I) {\n    return Arguments[I];\n  }\n\n  void addArgument(const TemplateArgumentLoc &Loc) {\n    Arguments.push_back(Loc);\n  }\n};\n\n/// Represents an explicit template argument list in C++, e.g.,\n/// the \"<int>\" in \"sort<int>\".\n/// This is safe to be used inside an AST node, in contrast with\n/// TemplateArgumentListInfo.\nstruct ASTTemplateArgumentListInfo final\n    : private llvm::TrailingObjects<ASTTemplateArgumentListInfo,\n                                    TemplateArgumentLoc> {\nprivate:\n  friend class ASTNodeImporter;\n  friend TrailingObjects;\n\n  ASTTemplateArgumentListInfo(const TemplateArgumentListInfo &List);\n\npublic:\n  /// The source location of the left angle bracket ('<').\n  SourceLocation LAngleLoc;\n\n  /// The source location of the right angle bracket ('>').\n  SourceLocation RAngleLoc;\n\n  /// The number of template arguments in TemplateArgs.\n  unsigned NumTemplateArgs;\n\n  SourceLocation getLAngleLoc() const { return LAngleLoc; }\n  SourceLocation getRAngleLoc() const { return RAngleLoc; }\n\n  /// Retrieve the template arguments\n  const TemplateArgumentLoc *getTemplateArgs() const {\n    return getTrailingObjects<TemplateArgumentLoc>();\n  }\n  unsigned getNumTemplateArgs() const { return NumTemplateArgs; }\n\n  llvm::ArrayRef<TemplateArgumentLoc> arguments() const {\n    return llvm::makeArrayRef(getTemplateArgs(), getNumTemplateArgs());\n  }\n\n  const TemplateArgumentLoc &operator[](unsigned I) const {\n    return getTemplateArgs()[I];\n  }\n\n  static const ASTTemplateArgumentListInfo *\n  Create(const ASTContext &C, const TemplateArgumentListInfo &List);\n};\n\n/// Represents an explicit template argument list in C++, e.g.,\n/// the \"<int>\" in \"sort<int>\".\n///\n/// It is intended to be used as a trailing object on AST nodes, and\n/// as such, doesn't contain the array of TemplateArgumentLoc itself,\n/// but expects the containing object to also provide storage for\n/// that.\nstruct alignas(void *) ASTTemplateKWAndArgsInfo {\n  /// The source location of the left angle bracket ('<').\n  SourceLocation LAngleLoc;\n\n  /// The source location of the right angle bracket ('>').\n  SourceLocation RAngleLoc;\n\n  /// The source location of the template keyword; this is used\n  /// as part of the representation of qualified identifiers, such as\n  /// S<T>::template apply<T>.  Will be empty if this expression does\n  /// not have a template keyword.\n  SourceLocation TemplateKWLoc;\n\n  /// The number of template arguments in TemplateArgs.\n  unsigned NumTemplateArgs;\n\n  void initializeFrom(SourceLocation TemplateKWLoc,\n                      const TemplateArgumentListInfo &List,\n                      TemplateArgumentLoc *OutArgArray);\n  // FIXME: The parameter Deps is the result populated by this method, the\n  // caller doesn't need it since it is populated by computeDependence. remove\n  // it.\n  void initializeFrom(SourceLocation TemplateKWLoc,\n                      const TemplateArgumentListInfo &List,\n                      TemplateArgumentLoc *OutArgArray,\n                      TemplateArgumentDependence &Deps);\n  void initializeFrom(SourceLocation TemplateKWLoc);\n\n  void copyInto(const TemplateArgumentLoc *ArgArray,\n                TemplateArgumentListInfo &List) const;\n};\n\nconst StreamingDiagnostic &operator<<(const StreamingDiagnostic &DB,\n                                      const TemplateArgument &Arg);\n\ninline TemplateSpecializationType::iterator\n    TemplateSpecializationType::end() const {\n  return getArgs() + getNumArgs();\n}\n\ninline DependentTemplateSpecializationType::iterator\n    DependentTemplateSpecializationType::end() const {\n  return getArgs() + getNumArgs();\n}\n\ninline const TemplateArgument &\n    TemplateSpecializationType::getArg(unsigned Idx) const {\n  assert(Idx < getNumArgs() && \"Template argument out of range\");\n  return getArgs()[Idx];\n}\n\ninline const TemplateArgument &\n    DependentTemplateSpecializationType::getArg(unsigned Idx) const {\n  assert(Idx < getNumArgs() && \"Template argument out of range\");\n  return getArgs()[Idx];\n}\n\ninline const TemplateArgument &AutoType::getArg(unsigned Idx) const {\n  assert(Idx < getNumArgs() && \"Template argument out of range\");\n  return getArgs()[Idx];\n}\n\n} // namespace clang\n\n#endif // LLVM_CLANG_AST_TEMPLATEBASE_H\n"}, "26": {"id": 26, "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Sema/Template.h", "content": "//===- SemaTemplate.h - C++ Templates ---------------------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//===----------------------------------------------------------------------===//\n//\n// This file provides types used in the semantic analysis of C++ templates.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_CLANG_SEMA_TEMPLATE_H\n#define LLVM_CLANG_SEMA_TEMPLATE_H\n\n#include \"clang/AST/DeclTemplate.h\"\n#include \"clang/AST/DeclVisitor.h\"\n#include \"clang/AST/TemplateBase.h\"\n#include \"clang/AST/Type.h\"\n#include \"clang/Basic/LLVM.h\"\n#include \"clang/Sema/Sema.h\"\n#include \"llvm/ADT/ArrayRef.h\"\n#include \"llvm/ADT/DenseMap.h\"\n#include \"llvm/ADT/PointerUnion.h\"\n#include \"llvm/ADT/SmallVector.h\"\n#include <cassert>\n#include <utility>\n\nnamespace clang {\n\nclass ASTContext;\nclass BindingDecl;\nclass CXXMethodDecl;\nclass Decl;\nclass DeclaratorDecl;\nclass DeclContext;\nclass EnumDecl;\nclass FunctionDecl;\nclass NamedDecl;\nclass ParmVarDecl;\nclass TagDecl;\nclass TypedefNameDecl;\nclass TypeSourceInfo;\nclass VarDecl;\n\n/// The kind of template substitution being performed.\nenum class TemplateSubstitutionKind : char {\n  /// We are substituting template parameters for template arguments in order\n  /// to form a template specialization.\n  Specialization,\n  /// We are substituting template parameters for (typically) other template\n  /// parameters in order to rewrite a declaration as a different declaration\n  /// (for example, when forming a deduction guide from a constructor).\n  Rewrite,\n};\n\n  /// Data structure that captures multiple levels of template argument\n  /// lists for use in template instantiation.\n  ///\n  /// Multiple levels of template arguments occur when instantiating the\n  /// definitions of member templates. For example:\n  ///\n  /// \\code\n  /// template<typename T>\n  /// struct X {\n  ///   template<T Value>\n  ///   struct Y {\n  ///     void f();\n  ///   };\n  /// };\n  /// \\endcode\n  ///\n  /// When instantiating X<int>::Y<17>::f, the multi-level template argument\n  /// list will contain a template argument list (int) at depth 0 and a\n  /// template argument list (17) at depth 1.\n  class MultiLevelTemplateArgumentList {\n    /// The template argument list at a certain template depth\n    using ArgList = ArrayRef<TemplateArgument>;\n\n    /// The template argument lists, stored from the innermost template\n    /// argument list (first) to the outermost template argument list (last).\n    SmallVector<ArgList, 4> TemplateArgumentLists;\n\n    /// The number of outer levels of template arguments that are not\n    /// being substituted.\n    unsigned NumRetainedOuterLevels = 0;\n\n    /// The kind of substitution described by this argument list.\n    TemplateSubstitutionKind Kind = TemplateSubstitutionKind::Specialization;\n\n  public:\n    /// Construct an empty set of template argument lists.\n    MultiLevelTemplateArgumentList() = default;\n\n    /// Construct a single-level template argument list.\n    explicit\n    MultiLevelTemplateArgumentList(const TemplateArgumentList &TemplateArgs) {\n      addOuterTemplateArguments(&TemplateArgs);\n    }\n\n    void setKind(TemplateSubstitutionKind K) { Kind = K; }\n\n    /// Determine the kind of template substitution being performed.\n    TemplateSubstitutionKind getKind() const { return Kind; }\n\n    /// Determine whether we are rewriting template parameters rather than\n    /// substituting for them. If so, we should not leave references to the\n    /// original template parameters behind.\n    bool isRewrite() const {\n      return Kind == TemplateSubstitutionKind::Rewrite;\n    }\n\n    /// Determine the number of levels in this template argument\n    /// list.\n    unsigned getNumLevels() const {\n      return TemplateArgumentLists.size() + NumRetainedOuterLevels;\n    }\n\n    /// Determine the number of substituted levels in this template\n    /// argument list.\n    unsigned getNumSubstitutedLevels() const {\n      return TemplateArgumentLists.size();\n    }\n\n    unsigned getNumRetainedOuterLevels() const {\n      return NumRetainedOuterLevels;\n    }\n\n    /// Determine how many of the \\p OldDepth outermost template parameter\n    /// lists would be removed by substituting these arguments.\n    unsigned getNewDepth(unsigned OldDepth) const {\n      if (OldDepth < NumRetainedOuterLevels)\n        return OldDepth;\n      if (OldDepth < getNumLevels())\n        return NumRetainedOuterLevels;\n      return OldDepth - TemplateArgumentLists.size();\n    }\n\n    /// Retrieve the template argument at a given depth and index.\n    const TemplateArgument &operator()(unsigned Depth, unsigned Index) const {\n      assert(NumRetainedOuterLevels <= Depth && Depth < getNumLevels());\n      assert(Index < TemplateArgumentLists[getNumLevels() - Depth - 1].size());\n      return TemplateArgumentLists[getNumLevels() - Depth - 1][Index];\n    }\n\n    /// Determine whether there is a non-NULL template argument at the\n    /// given depth and index.\n    ///\n    /// There must exist a template argument list at the given depth.\n    bool hasTemplateArgument(unsigned Depth, unsigned Index) const {\n      assert(Depth < getNumLevels());\n\n      if (Depth < NumRetainedOuterLevels)\n        return false;\n\n      if (Index >= TemplateArgumentLists[getNumLevels() - Depth - 1].size())\n        return false;\n\n      return !(*this)(Depth, Index).isNull();\n    }\n\n    /// Clear out a specific template argument.\n    void setArgument(unsigned Depth, unsigned Index,\n                     TemplateArgument Arg) {\n      assert(NumRetainedOuterLevels <= Depth && Depth < getNumLevels());\n      assert(Index < TemplateArgumentLists[getNumLevels() - Depth - 1].size());\n      const_cast<TemplateArgument&>(\n                TemplateArgumentLists[getNumLevels() - Depth - 1][Index])\n        = Arg;\n    }\n\n    /// Add a new outermost level to the multi-level template argument\n    /// list.\n    void addOuterTemplateArguments(const TemplateArgumentList *TemplateArgs) {\n      addOuterTemplateArguments(ArgList(TemplateArgs->data(),\n                                        TemplateArgs->size()));\n    }\n\n    /// Add a new outmost level to the multi-level template argument\n    /// list.\n    void addOuterTemplateArguments(ArgList Args) {\n      assert(!NumRetainedOuterLevels &&\n             \"substituted args outside retained args?\");\n      TemplateArgumentLists.push_back(Args);\n    }\n\n    /// Add an outermost level that we are not substituting. We have no\n    /// arguments at this level, and do not remove it from the depth of inner\n    /// template parameters that we instantiate.\n    void addOuterRetainedLevel() {\n      ++NumRetainedOuterLevels;\n    }\n    void addOuterRetainedLevels(unsigned Num) {\n      NumRetainedOuterLevels += Num;\n    }\n\n    /// Retrieve the innermost template argument list.\n    const ArgList &getInnermost() const {\n      return TemplateArgumentLists.front();\n    }\n  };\n\n  /// The context in which partial ordering of function templates occurs.\n  enum TPOC {\n    /// Partial ordering of function templates for a function call.\n    TPOC_Call,\n\n    /// Partial ordering of function templates for a call to a\n    /// conversion function.\n    TPOC_Conversion,\n\n    /// Partial ordering of function templates in other contexts, e.g.,\n    /// taking the address of a function template or matching a function\n    /// template specialization to a function template.\n    TPOC_Other\n  };\n\n  // This is lame but unavoidable in a world without forward\n  // declarations of enums.  The alternatives are to either pollute\n  // Sema.h (by including this file) or sacrifice type safety (by\n  // making Sema.h declare things as enums).\n  class TemplatePartialOrderingContext {\n    TPOC Value;\n\n  public:\n    TemplatePartialOrderingContext(TPOC Value) : Value(Value) {}\n\n    operator TPOC() const { return Value; }\n  };\n\n  /// Captures a template argument whose value has been deduced\n  /// via c++ template argument deduction.\n  class DeducedTemplateArgument : public TemplateArgument {\n    /// For a non-type template argument, whether the value was\n    /// deduced from an array bound.\n    bool DeducedFromArrayBound = false;\n\n  public:\n    DeducedTemplateArgument() = default;\n\n    DeducedTemplateArgument(const TemplateArgument &Arg,\n                            bool DeducedFromArrayBound = false)\n        : TemplateArgument(Arg), DeducedFromArrayBound(DeducedFromArrayBound) {}\n\n    /// Construct an integral non-type template argument that\n    /// has been deduced, possibly from an array bound.\n    DeducedTemplateArgument(ASTContext &Ctx,\n                            const llvm::APSInt &Value,\n                            QualType ValueType,\n                            bool DeducedFromArrayBound)\n        : TemplateArgument(Ctx, Value, ValueType),\n          DeducedFromArrayBound(DeducedFromArrayBound) {}\n\n    /// For a non-type template argument, determine whether the\n    /// template argument was deduced from an array bound.\n    bool wasDeducedFromArrayBound() const { return DeducedFromArrayBound; }\n\n    /// Specify whether the given non-type template argument\n    /// was deduced from an array bound.\n    void setDeducedFromArrayBound(bool Deduced) {\n      DeducedFromArrayBound = Deduced;\n    }\n  };\n\n  /// A stack-allocated class that identifies which local\n  /// variable declaration instantiations are present in this scope.\n  ///\n  /// A new instance of this class type will be created whenever we\n  /// instantiate a new function declaration, which will have its own\n  /// set of parameter declarations.\n  class LocalInstantiationScope {\n  public:\n    /// A set of declarations.\n    using DeclArgumentPack = SmallVector<VarDecl *, 4>;\n\n  private:\n    /// Reference to the semantic analysis that is performing\n    /// this template instantiation.\n    Sema &SemaRef;\n\n    using LocalDeclsMap =\n        llvm::SmallDenseMap<const Decl *,\n                            llvm::PointerUnion<Decl *, DeclArgumentPack *>, 4>;\n\n    /// A mapping from local declarations that occur\n    /// within a template to their instantiations.\n    ///\n    /// This mapping is used during instantiation to keep track of,\n    /// e.g., function parameter and variable declarations. For example,\n    /// given:\n    ///\n    /// \\code\n    ///   template<typename T> T add(T x, T y) { return x + y; }\n    /// \\endcode\n    ///\n    /// when we instantiate add<int>, we will introduce a mapping from\n    /// the ParmVarDecl for 'x' that occurs in the template to the\n    /// instantiated ParmVarDecl for 'x'.\n    ///\n    /// For a parameter pack, the local instantiation scope may contain a\n    /// set of instantiated parameters. This is stored as a DeclArgumentPack\n    /// pointer.\n    LocalDeclsMap LocalDecls;\n\n    /// The set of argument packs we've allocated.\n    SmallVector<DeclArgumentPack *, 1> ArgumentPacks;\n\n    /// The outer scope, which contains local variable\n    /// definitions from some other instantiation (that may not be\n    /// relevant to this particular scope).\n    LocalInstantiationScope *Outer;\n\n    /// Whether we have already exited this scope.\n    bool Exited = false;\n\n    /// Whether to combine this scope with the outer scope, such that\n    /// lookup will search our outer scope.\n    bool CombineWithOuterScope;\n\n    /// If non-NULL, the template parameter pack that has been\n    /// partially substituted per C++0x [temp.arg.explicit]p9.\n    NamedDecl *PartiallySubstitutedPack = nullptr;\n\n    /// If \\c PartiallySubstitutedPack is non-null, the set of\n    /// explicitly-specified template arguments in that pack.\n    const TemplateArgument *ArgsInPartiallySubstitutedPack;\n\n    /// If \\c PartiallySubstitutedPack, the number of\n    /// explicitly-specified template arguments in\n    /// ArgsInPartiallySubstitutedPack.\n    unsigned NumArgsInPartiallySubstitutedPack;\n\n  public:\n    LocalInstantiationScope(Sema &SemaRef, bool CombineWithOuterScope = false)\n        : SemaRef(SemaRef), Outer(SemaRef.CurrentInstantiationScope),\n          CombineWithOuterScope(CombineWithOuterScope) {\n      SemaRef.CurrentInstantiationScope = this;\n    }\n\n    LocalInstantiationScope(const LocalInstantiationScope &) = delete;\n    LocalInstantiationScope &\n    operator=(const LocalInstantiationScope &) = delete;\n\n    ~LocalInstantiationScope() {\n      Exit();\n    }\n\n    const Sema &getSema() const { return SemaRef; }\n\n    /// Exit this local instantiation scope early.\n    void Exit() {\n      if (Exited)\n        return;\n\n      for (unsigned I = 0, N = ArgumentPacks.size(); I != N; ++I)\n        delete ArgumentPacks[I];\n\n      SemaRef.CurrentInstantiationScope = Outer;\n      Exited = true;\n    }\n\n    /// Clone this scope, and all outer scopes, down to the given\n    /// outermost scope.\n    LocalInstantiationScope *cloneScopes(LocalInstantiationScope *Outermost) {\n      if (this == Outermost) return this;\n\n      // Save the current scope from SemaRef since the LocalInstantiationScope\n      // will overwrite it on construction\n      LocalInstantiationScope *oldScope = SemaRef.CurrentInstantiationScope;\n\n      LocalInstantiationScope *newScope =\n        new LocalInstantiationScope(SemaRef, CombineWithOuterScope);\n\n      newScope->Outer = nullptr;\n      if (Outer)\n        newScope->Outer = Outer->cloneScopes(Outermost);\n\n      newScope->PartiallySubstitutedPack = PartiallySubstitutedPack;\n      newScope->ArgsInPartiallySubstitutedPack = ArgsInPartiallySubstitutedPack;\n      newScope->NumArgsInPartiallySubstitutedPack =\n        NumArgsInPartiallySubstitutedPack;\n\n      for (LocalDeclsMap::iterator I = LocalDecls.begin(), E = LocalDecls.end();\n           I != E; ++I) {\n        const Decl *D = I->first;\n        llvm::PointerUnion<Decl *, DeclArgumentPack *> &Stored =\n          newScope->LocalDecls[D];\n        if (I->second.is<Decl *>()) {\n          Stored = I->second.get<Decl *>();\n        } else {\n          DeclArgumentPack *OldPack = I->second.get<DeclArgumentPack *>();\n          DeclArgumentPack *NewPack = new DeclArgumentPack(*OldPack);\n          Stored = NewPack;\n          newScope->ArgumentPacks.push_back(NewPack);\n        }\n      }\n      // Restore the saved scope to SemaRef\n      SemaRef.CurrentInstantiationScope = oldScope;\n      return newScope;\n    }\n\n    /// deletes the given scope, and all otuer scopes, down to the\n    /// given outermost scope.\n    static void deleteScopes(LocalInstantiationScope *Scope,\n                             LocalInstantiationScope *Outermost) {\n      while (Scope && Scope != Outermost) {\n        LocalInstantiationScope *Out = Scope->Outer;\n        delete Scope;\n        Scope = Out;\n      }\n    }\n\n    /// Find the instantiation of the declaration D within the current\n    /// instantiation scope.\n    ///\n    /// \\param D The declaration whose instantiation we are searching for.\n    ///\n    /// \\returns A pointer to the declaration or argument pack of declarations\n    /// to which the declaration \\c D is instantiated, if found. Otherwise,\n    /// returns NULL.\n    llvm::PointerUnion<Decl *, DeclArgumentPack *> *\n    findInstantiationOf(const Decl *D);\n\n    void InstantiatedLocal(const Decl *D, Decl *Inst);\n    void InstantiatedLocalPackArg(const Decl *D, VarDecl *Inst);\n    void MakeInstantiatedLocalArgPack(const Decl *D);\n\n    /// Note that the given parameter pack has been partially substituted\n    /// via explicit specification of template arguments\n    /// (C++0x [temp.arg.explicit]p9).\n    ///\n    /// \\param Pack The parameter pack, which will always be a template\n    /// parameter pack.\n    ///\n    /// \\param ExplicitArgs The explicitly-specified template arguments provided\n    /// for this parameter pack.\n    ///\n    /// \\param NumExplicitArgs The number of explicitly-specified template\n    /// arguments provided for this parameter pack.\n    void SetPartiallySubstitutedPack(NamedDecl *Pack,\n                                     const TemplateArgument *ExplicitArgs,\n                                     unsigned NumExplicitArgs);\n\n    /// Reset the partially-substituted pack when it is no longer of\n    /// interest.\n    void ResetPartiallySubstitutedPack() {\n      assert(PartiallySubstitutedPack && \"No partially-substituted pack\");\n      PartiallySubstitutedPack = nullptr;\n      ArgsInPartiallySubstitutedPack = nullptr;\n      NumArgsInPartiallySubstitutedPack = 0;\n    }\n\n    /// Retrieve the partially-substitued template parameter pack.\n    ///\n    /// If there is no partially-substituted parameter pack, returns NULL.\n    NamedDecl *\n    getPartiallySubstitutedPack(const TemplateArgument **ExplicitArgs = nullptr,\n                                unsigned *NumExplicitArgs = nullptr) const;\n\n    /// Determine whether D is a pack expansion created in this scope.\n    bool isLocalPackExpansion(const Decl *D);\n  };\n\n  class TemplateDeclInstantiator\n    : public DeclVisitor<TemplateDeclInstantiator, Decl *>\n  {\n    Sema &SemaRef;\n    Sema::ArgumentPackSubstitutionIndexRAII SubstIndex;\n    DeclContext *Owner;\n    const MultiLevelTemplateArgumentList &TemplateArgs;\n    Sema::LateInstantiatedAttrVec* LateAttrs = nullptr;\n    LocalInstantiationScope *StartingScope = nullptr;\n\n    /// A list of out-of-line class template partial\n    /// specializations that will need to be instantiated after the\n    /// enclosing class's instantiation is complete.\n    SmallVector<std::pair<ClassTemplateDecl *,\n                                ClassTemplatePartialSpecializationDecl *>, 4>\n      OutOfLinePartialSpecs;\n\n    /// A list of out-of-line variable template partial\n    /// specializations that will need to be instantiated after the\n    /// enclosing variable's instantiation is complete.\n    /// FIXME: Verify that this is needed.\n    SmallVector<\n        std::pair<VarTemplateDecl *, VarTemplatePartialSpecializationDecl *>, 4>\n    OutOfLineVarPartialSpecs;\n\n  public:\n    TemplateDeclInstantiator(Sema &SemaRef, DeclContext *Owner,\n                             const MultiLevelTemplateArgumentList &TemplateArgs)\n        : SemaRef(SemaRef),\n          SubstIndex(SemaRef, SemaRef.ArgumentPackSubstitutionIndex),\n          Owner(Owner), TemplateArgs(TemplateArgs) {}\n\n// Define all the decl visitors using DeclNodes.inc\n#define DECL(DERIVED, BASE) \\\n    Decl *Visit ## DERIVED ## Decl(DERIVED ## Decl *D);\n#define ABSTRACT_DECL(DECL)\n\n// Decls which never appear inside a class or function.\n#define OBJCCONTAINER(DERIVED, BASE)\n#define FILESCOPEASM(DERIVED, BASE)\n#define IMPORT(DERIVED, BASE)\n#define EXPORT(DERIVED, BASE)\n#define LINKAGESPEC(DERIVED, BASE)\n#define OBJCCOMPATIBLEALIAS(DERIVED, BASE)\n#define OBJCMETHOD(DERIVED, BASE)\n#define OBJCTYPEPARAM(DERIVED, BASE)\n#define OBJCIVAR(DERIVED, BASE)\n#define OBJCPROPERTY(DERIVED, BASE)\n#define OBJCPROPERTYIMPL(DERIVED, BASE)\n#define EMPTY(DERIVED, BASE)\n#define LIFETIMEEXTENDEDTEMPORARY(DERIVED, BASE)\n\n    // Decls which use special-case instantiation code.\n#define BLOCK(DERIVED, BASE)\n#define CAPTURED(DERIVED, BASE)\n#define IMPLICITPARAM(DERIVED, BASE)\n\n#include \"clang/AST/DeclNodes.inc\"\n\n    enum class RewriteKind { None, RewriteSpaceshipAsEqualEqual };\n\n    void adjustForRewrite(RewriteKind RK, FunctionDecl *Orig, QualType &T,\n                          TypeSourceInfo *&TInfo,\n                          DeclarationNameInfo &NameInfo);\n\n    // A few supplemental visitor functions.\n    Decl *VisitCXXMethodDecl(CXXMethodDecl *D,\n                             TemplateParameterList *TemplateParams,\n                             Optional<const ASTTemplateArgumentListInfo *>\n                                 ClassScopeSpecializationArgs = llvm::None,\n                             RewriteKind RK = RewriteKind::None);\n    Decl *VisitFunctionDecl(FunctionDecl *D,\n                            TemplateParameterList *TemplateParams,\n                            RewriteKind RK = RewriteKind::None);\n    Decl *VisitDecl(Decl *D);\n    Decl *VisitVarDecl(VarDecl *D, bool InstantiatingVarTemplate,\n                       ArrayRef<BindingDecl *> *Bindings = nullptr);\n\n    // Enable late instantiation of attributes.  Late instantiated attributes\n    // will be stored in LA.\n    void enableLateAttributeInstantiation(Sema::LateInstantiatedAttrVec *LA) {\n      LateAttrs = LA;\n      StartingScope = SemaRef.CurrentInstantiationScope;\n    }\n\n    // Disable late instantiation of attributes.\n    void disableLateAttributeInstantiation() {\n      LateAttrs = nullptr;\n      StartingScope = nullptr;\n    }\n\n    LocalInstantiationScope *getStartingScope() const { return StartingScope; }\n\n    using delayed_partial_spec_iterator = SmallVectorImpl<std::pair<\n      ClassTemplateDecl *, ClassTemplatePartialSpecializationDecl *>>::iterator;\n\n    using delayed_var_partial_spec_iterator = SmallVectorImpl<std::pair<\n        VarTemplateDecl *, VarTemplatePartialSpecializationDecl *>>::iterator;\n\n    /// Return an iterator to the beginning of the set of\n    /// \"delayed\" partial specializations, which must be passed to\n    /// InstantiateClassTemplatePartialSpecialization once the class\n    /// definition has been completed.\n    delayed_partial_spec_iterator delayed_partial_spec_begin() {\n      return OutOfLinePartialSpecs.begin();\n    }\n\n    delayed_var_partial_spec_iterator delayed_var_partial_spec_begin() {\n      return OutOfLineVarPartialSpecs.begin();\n    }\n\n    /// Return an iterator to the end of the set of\n    /// \"delayed\" partial specializations, which must be passed to\n    /// InstantiateClassTemplatePartialSpecialization once the class\n    /// definition has been completed.\n    delayed_partial_spec_iterator delayed_partial_spec_end() {\n      return OutOfLinePartialSpecs.end();\n    }\n\n    delayed_var_partial_spec_iterator delayed_var_partial_spec_end() {\n      return OutOfLineVarPartialSpecs.end();\n    }\n\n    // Helper functions for instantiating methods.\n    TypeSourceInfo *SubstFunctionType(FunctionDecl *D,\n                             SmallVectorImpl<ParmVarDecl *> &Params);\n    bool InitFunctionInstantiation(FunctionDecl *New, FunctionDecl *Tmpl);\n    bool InitMethodInstantiation(CXXMethodDecl *New, CXXMethodDecl *Tmpl);\n\n    bool SubstDefaultedFunction(FunctionDecl *New, FunctionDecl *Tmpl);\n\n    TemplateParameterList *\n      SubstTemplateParams(TemplateParameterList *List);\n\n    bool SubstQualifier(const DeclaratorDecl *OldDecl,\n                        DeclaratorDecl *NewDecl);\n    bool SubstQualifier(const TagDecl *OldDecl,\n                        TagDecl *NewDecl);\n\n    Decl *VisitVarTemplateSpecializationDecl(\n        VarTemplateDecl *VarTemplate, VarDecl *FromVar,\n        const TemplateArgumentListInfo &TemplateArgsInfo,\n        ArrayRef<TemplateArgument> Converted,\n        VarTemplateSpecializationDecl *PrevDecl = nullptr);\n\n    Decl *InstantiateTypedefNameDecl(TypedefNameDecl *D, bool IsTypeAlias);\n    ClassTemplatePartialSpecializationDecl *\n    InstantiateClassTemplatePartialSpecialization(\n                                              ClassTemplateDecl *ClassTemplate,\n                           ClassTemplatePartialSpecializationDecl *PartialSpec);\n    VarTemplatePartialSpecializationDecl *\n    InstantiateVarTemplatePartialSpecialization(\n        VarTemplateDecl *VarTemplate,\n        VarTemplatePartialSpecializationDecl *PartialSpec);\n    void InstantiateEnumDefinition(EnumDecl *Enum, EnumDecl *Pattern);\n\n  private:\n    template<typename T>\n    Decl *instantiateUnresolvedUsingDecl(T *D,\n                                         bool InstantiatingPackElement = false);\n  };\n\n} // namespace clang\n\n#endif // LLVM_CLANG_SEMA_TEMPLATE_H\n"}, "27": {"id": 27, "path": "/home/vsts/work/1/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp", "content": "//===- SemaTemplateDeduction.cpp - Template Argument Deduction ------------===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// This file implements C++ template argument deduction.\n//\n//===----------------------------------------------------------------------===//\n\n#include \"clang/Sema/TemplateDeduction.h\"\n#include \"TreeTransform.h\"\n#include \"TypeLocBuilder.h\"\n#include \"clang/AST/ASTContext.h\"\n#include \"clang/AST/ASTLambda.h\"\n#include \"clang/AST/Decl.h\"\n#include \"clang/AST/DeclAccessPair.h\"\n#include \"clang/AST/DeclBase.h\"\n#include \"clang/AST/DeclCXX.h\"\n#include \"clang/AST/DeclTemplate.h\"\n#include \"clang/AST/DeclarationName.h\"\n#include \"clang/AST/Expr.h\"\n#include \"clang/AST/ExprCXX.h\"\n#include \"clang/AST/NestedNameSpecifier.h\"\n#include \"clang/AST/RecursiveASTVisitor.h\"\n#include \"clang/AST/TemplateBase.h\"\n#include \"clang/AST/TemplateName.h\"\n#include \"clang/AST/Type.h\"\n#include \"clang/AST/TypeLoc.h\"\n#include \"clang/AST/UnresolvedSet.h\"\n#include \"clang/Basic/AddressSpaces.h\"\n#include \"clang/Basic/ExceptionSpecificationType.h\"\n#include \"clang/Basic/LLVM.h\"\n#include \"clang/Basic/LangOptions.h\"\n#include \"clang/Basic/PartialDiagnostic.h\"\n#include \"clang/Basic/SourceLocation.h\"\n#include \"clang/Basic/Specifiers.h\"\n#include \"clang/Sema/Ownership.h\"\n#include \"clang/Sema/Sema.h\"\n#include \"clang/Sema/Template.h\"\n#include \"llvm/ADT/APInt.h\"\n#include \"llvm/ADT/APSInt.h\"\n#include \"llvm/ADT/ArrayRef.h\"\n#include \"llvm/ADT/DenseMap.h\"\n#include \"llvm/ADT/FoldingSet.h\"\n#include \"llvm/ADT/Optional.h\"\n#include \"llvm/ADT/SmallBitVector.h\"\n#include \"llvm/ADT/SmallPtrSet.h\"\n#include \"llvm/ADT/SmallVector.h\"\n#include \"llvm/Support/Casting.h\"\n#include \"llvm/Support/Compiler.h\"\n#include \"llvm/Support/ErrorHandling.h\"\n#include <algorithm>\n#include <cassert>\n#include <tuple>\n#include <utility>\n\nnamespace clang {\n\n  /// Various flags that control template argument deduction.\n  ///\n  /// These flags can be bitwise-OR'd together.\n  enum TemplateDeductionFlags {\n    /// No template argument deduction flags, which indicates the\n    /// strictest results for template argument deduction (as used for, e.g.,\n    /// matching class template partial specializations).\n    TDF_None = 0,\n\n    /// Within template argument deduction from a function call, we are\n    /// matching with a parameter type for which the original parameter was\n    /// a reference.\n    TDF_ParamWithReferenceType = 0x1,\n\n    /// Within template argument deduction from a function call, we\n    /// are matching in a case where we ignore cv-qualifiers.\n    TDF_IgnoreQualifiers = 0x02,\n\n    /// Within template argument deduction from a function call,\n    /// we are matching in a case where we can perform template argument\n    /// deduction from a template-id of a derived class of the argument type.\n    TDF_DerivedClass = 0x04,\n\n    /// Allow non-dependent types to differ, e.g., when performing\n    /// template argument deduction from a function call where conversions\n    /// may apply.\n    TDF_SkipNonDependent = 0x08,\n\n    /// Whether we are performing template argument deduction for\n    /// parameters and arguments in a top-level template argument\n    TDF_TopLevelParameterTypeList = 0x10,\n\n    /// Within template argument deduction from overload resolution per\n    /// C++ [over.over] allow matching function types that are compatible in\n    /// terms of noreturn and default calling convention adjustments, or\n    /// similarly matching a declared template specialization against a\n    /// possible template, per C++ [temp.deduct.decl]. In either case, permit\n    /// deduction where the parameter is a function type that can be converted\n    /// to the argument type.\n    TDF_AllowCompatibleFunctionType = 0x20,\n\n    /// Within template argument deduction for a conversion function, we are\n    /// matching with an argument type for which the original argument was\n    /// a reference.\n    TDF_ArgWithReferenceType = 0x40,\n  };\n}\n\nusing namespace clang;\nusing namespace sema;\n\n/// Compare two APSInts, extending and switching the sign as\n/// necessary to compare their values regardless of underlying type.\nstatic bool hasSameExtendedValue(llvm::APSInt X, llvm::APSInt Y) {\n  if (Y.getBitWidth() > X.getBitWidth())\n    X = X.extend(Y.getBitWidth());\n  else if (Y.getBitWidth() < X.getBitWidth())\n    Y = Y.extend(X.getBitWidth());\n\n  // If there is a signedness mismatch, correct it.\n  if (X.isSigned() != Y.isSigned()) {\n    // If the signed value is negative, then the values cannot be the same.\n    if ((Y.isSigned() && Y.isNegative()) || (X.isSigned() && X.isNegative()))\n      return false;\n\n    Y.setIsSigned(true);\n    X.setIsSigned(true);\n  }\n\n  return X == Y;\n}\n\nstatic Sema::TemplateDeductionResult\nDeduceTemplateArguments(Sema &S,\n                        TemplateParameterList *TemplateParams,\n                        const TemplateArgument &Param,\n                        TemplateArgument Arg,\n                        TemplateDeductionInfo &Info,\n                        SmallVectorImpl<DeducedTemplateArgument> &Deduced);\n\nstatic Sema::TemplateDeductionResult\nDeduceTemplateArgumentsByTypeMatch(Sema &S,\n                                   TemplateParameterList *TemplateParams,\n                                   QualType Param,\n                                   QualType Arg,\n                                   TemplateDeductionInfo &Info,\n                                   SmallVectorImpl<DeducedTemplateArgument> &\n                                                      Deduced,\n                                   unsigned TDF,\n                                   bool PartialOrdering = false,\n                                   bool DeducedFromArrayBound = false);\n\nstatic Sema::TemplateDeductionResult\nDeduceTemplateArguments(Sema &S, TemplateParameterList *TemplateParams,\n                        ArrayRef<TemplateArgument> Params,\n                        ArrayRef<TemplateArgument> Args,\n                        TemplateDeductionInfo &Info,\n                        SmallVectorImpl<DeducedTemplateArgument> &Deduced,\n                        bool NumberOfArgumentsMustMatch);\n\nstatic void MarkUsedTemplateParameters(ASTContext &Ctx,\n                                       const TemplateArgument &TemplateArg,\n                                       bool OnlyDeduced, unsigned Depth,\n                                       llvm::SmallBitVector &Used);\n\nstatic void MarkUsedTemplateParameters(ASTContext &Ctx, QualType T,\n                                       bool OnlyDeduced, unsigned Level,\n                                       llvm::SmallBitVector &Deduced);\n\n/// If the given expression is of a form that permits the deduction\n/// of a non-type template parameter, return the declaration of that\n/// non-type template parameter.\nstatic const NonTypeTemplateParmDecl *\ngetDeducedParameterFromExpr(const Expr *E, unsigned Depth) {\n  // If we are within an alias template, the expression may have undergone\n  // any number of parameter substitutions already.\n  while (true) {\n    if (const auto *IC = dyn_cast<ImplicitCastExpr>(E))\n      E = IC->getSubExpr();\n    else if (const auto *CE = dyn_cast<ConstantExpr>(E))\n      E = CE->getSubExpr();\n    else if (const auto *Subst = dyn_cast<SubstNonTypeTemplateParmExpr>(E))\n      E = Subst->getReplacement();\n    else if (const auto *CCE = dyn_cast<CXXConstructExpr>(E)) {\n      // Look through implicit copy construction from an lvalue of the same type.\n      if (CCE->getParenOrBraceRange().isValid())\n        break;\n      // Note, there could be default arguments.\n      assert(CCE->getNumArgs() >= 1 && \"implicit construct expr should have 1 arg\");\n      E = CCE->getArg(0);\n    } else\n      break;\n  }\n\n  if (const auto *DRE = dyn_cast<DeclRefExpr>(E))\n    if (const auto *NTTP = dyn_cast<NonTypeTemplateParmDecl>(DRE->getDecl()))\n      if (NTTP->getDepth() == Depth)\n        return NTTP;\n\n  return nullptr;\n}\n\nstatic const NonTypeTemplateParmDecl *\ngetDeducedParameterFromExpr(TemplateDeductionInfo &Info, Expr *E) {\n  return getDeducedParameterFromExpr(E, Info.getDeducedDepth());\n}\n\n/// Determine whether two declaration pointers refer to the same\n/// declaration.\nstatic bool isSameDeclaration(Decl *X, Decl *Y) {\n  if (NamedDecl *NX = dyn_cast<NamedDecl>(X))\n    X = NX->getUnderlyingDecl();\n  if (NamedDecl *NY = dyn_cast<NamedDecl>(Y))\n    Y = NY->getUnderlyingDecl();\n\n  return X->getCanonicalDecl() == Y->getCanonicalDecl();\n}\n\n/// Verify that the given, deduced template arguments are compatible.\n///\n/// \\returns The deduced template argument, or a NULL template argument if\n/// the deduced template arguments were incompatible.\nstatic DeducedTemplateArgument\ncheckDeducedTemplateArguments(ASTContext &Context,\n                              const DeducedTemplateArgument &X,\n                              const DeducedTemplateArgument &Y) {\n  // We have no deduction for one or both of the arguments; they're compatible.\n  if (X.isNull())\n    return Y;\n  if (Y.isNull())\n    return X;\n\n  // If we have two non-type template argument values deduced for the same\n  // parameter, they must both match the type of the parameter, and thus must\n  // match each other's type. As we're only keeping one of them, we must check\n  // for that now. The exception is that if either was deduced from an array\n  // bound, the type is permitted to differ.\n  if (!X.wasDeducedFromArrayBound() && !Y.wasDeducedFromArrayBound()) {\n    QualType XType = X.getNonTypeTemplateArgumentType();\n    if (!XType.isNull()) {\n      QualType YType = Y.getNonTypeTemplateArgumentType();\n      if (YType.isNull() || !Context.hasSameType(XType, YType))\n        return DeducedTemplateArgument();\n    }\n  }\n\n  switch (X.getKind()) {\n  case TemplateArgument::Null:\n    llvm_unreachable(\"Non-deduced template arguments handled above\");\n\n  case TemplateArgument::Type:\n    // If two template type arguments have the same type, they're compatible.\n    if (Y.getKind() == TemplateArgument::Type &&\n        Context.hasSameType(X.getAsType(), Y.getAsType()))\n      return X;\n\n    // If one of the two arguments was deduced from an array bound, the other\n    // supersedes it.\n    if (X.wasDeducedFromArrayBound() != Y.wasDeducedFromArrayBound())\n      return X.wasDeducedFromArrayBound() ? Y : X;\n\n    // The arguments are not compatible.\n    return DeducedTemplateArgument();\n\n  case TemplateArgument::Integral:\n    // If we deduced a constant in one case and either a dependent expression or\n    // declaration in another case, keep the integral constant.\n    // If both are integral constants with the same value, keep that value.\n    if (Y.getKind() == TemplateArgument::Expression ||\n        Y.getKind() == TemplateArgument::Declaration ||\n        (Y.getKind() == TemplateArgument::Integral &&\n         hasSameExtendedValue(X.getAsIntegral(), Y.getAsIntegral())))\n      return X.wasDeducedFromArrayBound() ? Y : X;\n\n    // All other combinations are incompatible.\n    return DeducedTemplateArgument();\n\n  case TemplateArgument::Template:\n    if (Y.getKind() == TemplateArgument::Template &&\n        Context.hasSameTemplateName(X.getAsTemplate(), Y.getAsTemplate()))\n      return X;\n\n    // All other combinations are incompatible.\n    return DeducedTemplateArgument();\n\n  case TemplateArgument::TemplateExpansion:\n    if (Y.getKind() == TemplateArgument::TemplateExpansion &&\n        Context.hasSameTemplateName(X.getAsTemplateOrTemplatePattern(),\n                                    Y.getAsTemplateOrTemplatePattern()))\n      return X;\n\n    // All other combinations are incompatible.\n    return DeducedTemplateArgument();\n\n  case TemplateArgument::Expression: {\n    if (Y.getKind() != TemplateArgument::Expression)\n      return checkDeducedTemplateArguments(Context, Y, X);\n\n    // Compare the expressions for equality\n    llvm::FoldingSetNodeID ID1, ID2;\n    X.getAsExpr()->Profile(ID1, Context, true);\n    Y.getAsExpr()->Profile(ID2, Context, true);\n    if (ID1 == ID2)\n      return X.wasDeducedFromArrayBound() ? Y : X;\n\n    // Differing dependent expressions are incompatible.\n    return DeducedTemplateArgument();\n  }\n\n  case TemplateArgument::Declaration:\n    assert(!X.wasDeducedFromArrayBound());\n\n    // If we deduced a declaration and a dependent expression, keep the\n    // declaration.\n    if (Y.getKind() == TemplateArgument::Expression)\n      return X;\n\n    // If we deduced a declaration and an integral constant, keep the\n    // integral constant and whichever type did not come from an array\n    // bound.\n    if (Y.getKind() == TemplateArgument::Integral) {\n      if (Y.wasDeducedFromArrayBound())\n        return TemplateArgument(Context, Y.getAsIntegral(),\n                                X.getParamTypeForDecl());\n      return Y;\n    }\n\n    // If we deduced two declarations, make sure that they refer to the\n    // same declaration.\n    if (Y.getKind() == TemplateArgument::Declaration &&\n        isSameDeclaration(X.getAsDecl(), Y.getAsDecl()))\n      return X;\n\n    // All other combinations are incompatible.\n    return DeducedTemplateArgument();\n\n  case TemplateArgument::NullPtr:\n    // If we deduced a null pointer and a dependent expression, keep the\n    // null pointer.\n    if (Y.getKind() == TemplateArgument::Expression)\n      return X;\n\n    // If we deduced a null pointer and an integral constant, keep the\n    // integral constant.\n    if (Y.getKind() == TemplateArgument::Integral)\n      return Y;\n\n    // If we deduced two null pointers, they are the same.\n    if (Y.getKind() == TemplateArgument::NullPtr)\n      return X;\n\n    // All other combinations are incompatible.\n    return DeducedTemplateArgument();\n\n  case TemplateArgument::Pack: {\n    if (Y.getKind() != TemplateArgument::Pack ||\n        X.pack_size() != Y.pack_size())\n      return DeducedTemplateArgument();\n\n    llvm::SmallVector<TemplateArgument, 8> NewPack;\n    for (TemplateArgument::pack_iterator XA = X.pack_begin(),\n                                      XAEnd = X.pack_end(),\n                                         YA = Y.pack_begin();\n         XA != XAEnd; ++XA, ++YA) {\n      TemplateArgument Merged = checkDeducedTemplateArguments(\n          Context, DeducedTemplateArgument(*XA, X.wasDeducedFromArrayBound()),\n          DeducedTemplateArgument(*YA, Y.wasDeducedFromArrayBound()));\n      if (Merged.isNull() && !(XA->isNull() && YA->isNull()))\n        return DeducedTemplateArgument();\n      NewPack.push_back(Merged);\n    }\n\n    return DeducedTemplateArgument(\n        TemplateArgument::CreatePackCopy(Context, NewPack),\n        X.wasDeducedFromArrayBound() && Y.wasDeducedFromArrayBound());\n  }\n  }\n\n  llvm_unreachable(\"Invalid TemplateArgument Kind!\");\n}\n\n/// Deduce the value of the given non-type template parameter\n/// as the given deduced template argument. All non-type template parameter\n/// deduction is funneled through here.\nstatic Sema::TemplateDeductionResult DeduceNonTypeTemplateArgument(\n    Sema &S, TemplateParameterList *TemplateParams,\n    const NonTypeTemplateParmDecl *NTTP, const DeducedTemplateArgument &NewDeduced,\n    QualType ValueType, TemplateDeductionInfo &Info,\n    SmallVectorImpl<DeducedTemplateArgument> &Deduced) {\n  assert(NTTP->getDepth() == Info.getDeducedDepth() &&\n         \"deducing non-type template argument with wrong depth\");\n\n  DeducedTemplateArgument Result = checkDeducedTemplateArguments(\n      S.Context, Deduced[NTTP->getIndex()], NewDeduced);\n  if (Result.isNull()) {\n    Info.Param = const_cast<NonTypeTemplateParmDecl*>(NTTP);\n    Info.FirstArg = Deduced[NTTP->getIndex()];\n    Info.SecondArg = NewDeduced;\n    return Sema::TDK_Inconsistent;\n  }\n\n  Deduced[NTTP->getIndex()] = Result;\n  if (!S.getLangOpts().CPlusPlus17)\n    return Sema::TDK_Success;\n\n  if (NTTP->isExpandedParameterPack())\n    // FIXME: We may still need to deduce parts of the type here! But we\n    // don't have any way to find which slice of the type to use, and the\n    // type stored on the NTTP itself is nonsense. Perhaps the type of an\n    // expanded NTTP should be a pack expansion type?\n    return Sema::TDK_Success;\n\n  // Get the type of the parameter for deduction. If it's a (dependent) array\n  // or function type, we will not have decayed it yet, so do that now.\n  QualType ParamType = S.Context.getAdjustedParameterType(NTTP->getType());\n  if (auto *Expansion = dyn_cast<PackExpansionType>(ParamType))\n    ParamType = Expansion->getPattern();\n\n  // FIXME: It's not clear how deduction of a parameter of reference\n  // type from an argument (of non-reference type) should be performed.\n  // For now, we just remove reference types from both sides and let\n  // the final check for matching types sort out the mess.\n  ValueType = ValueType.getNonReferenceType();\n  if (ParamType->isReferenceType())\n    ParamType = ParamType.getNonReferenceType();\n  else\n    // Top-level cv-qualifiers are irrelevant for a non-reference type.\n    ValueType = ValueType.getUnqualifiedType();\n\n  return DeduceTemplateArgumentsByTypeMatch(\n      S, TemplateParams, ParamType, ValueType, Info, Deduced,\n      TDF_SkipNonDependent, /*PartialOrdering=*/false,\n      /*ArrayBound=*/NewDeduced.wasDeducedFromArrayBound());\n}\n\n/// Deduce the value of the given non-type template parameter\n/// from the given integral constant.\nstatic Sema::TemplateDeductionResult DeduceNonTypeTemplateArgument(\n    Sema &S, TemplateParameterList *TemplateParams,\n    const NonTypeTemplateParmDecl *NTTP, const llvm::APSInt &Value,\n    QualType ValueType, bool DeducedFromArrayBound, TemplateDeductionInfo &Info,\n    SmallVectorImpl<DeducedTemplateArgument> &Deduced) {\n  return DeduceNonTypeTemplateArgument(\n      S, TemplateParams, NTTP,\n      DeducedTemplateArgument(S.Context, Value, ValueType,\n                              DeducedFromArrayBound),\n      ValueType, Info, Deduced);\n}\n\n/// Deduce the value of the given non-type template parameter\n/// from the given null pointer template argument type.\nstatic Sema::TemplateDeductionResult DeduceNullPtrTemplateArgument(\n    Sema &S, TemplateParameterList *TemplateParams,\n    const NonTypeTemplateParmDecl *NTTP, QualType NullPtrType,\n    TemplateDeductionInfo &Info,\n    SmallVectorImpl<DeducedTemplateArgument> &Deduced) {\n  Expr *Value =\n      S.ImpCastExprToType(new (S.Context) CXXNullPtrLiteralExpr(\n                              S.Context.NullPtrTy, NTTP->getLocation()),\n                          NullPtrType, CK_NullToPointer)\n          .get();\n  return DeduceNonTypeTemplateArgument(S, TemplateParams, NTTP,\n                                       DeducedTemplateArgument(Value),\n                                       Value->getType(), Info, Deduced);\n}\n\n/// Deduce the value of the given non-type template parameter\n/// from the given type- or value-dependent expression.\n///\n/// \\returns true if deduction succeeded, false otherwise.\nstatic Sema::TemplateDeductionResult DeduceNonTypeTemplateArgument(\n    Sema &S, TemplateParameterList *TemplateParams,\n    const NonTypeTemplateParmDecl *NTTP, Expr *Value, TemplateDeductionInfo &Info,\n    SmallVectorImpl<DeducedTemplateArgument> &Deduced) {\n  return DeduceNonTypeTemplateArgument(S, TemplateParams, NTTP,\n                                       DeducedTemplateArgument(Value),\n                                       Value->getType(), Info, Deduced);\n}\n\n/// Deduce the value of the given non-type template parameter\n/// from the given declaration.\n///\n/// \\returns true if deduction succeeded, false otherwise.\nstatic Sema::TemplateDeductionResult DeduceNonTypeTemplateArgument(\n    Sema &S, TemplateParameterList *TemplateParams,\n    const NonTypeTemplateParmDecl *NTTP, ValueDecl *D, QualType T,\n    TemplateDeductionInfo &Info,\n    SmallVectorImpl<DeducedTemplateArgument> &Deduced) {\n  D = D ? cast<ValueDecl>(D->getCanonicalDecl()) : nullptr;\n  TemplateArgument New(D, T);\n  return DeduceNonTypeTemplateArgument(\n      S, TemplateParams, NTTP, DeducedTemplateArgument(New), T, Info, Deduced);\n}\n\nstatic Sema::TemplateDeductionResult\nDeduceTemplateArguments(Sema &S,\n                        TemplateParameterList *TemplateParams,\n                        TemplateName Param,\n                        TemplateName Arg,\n                        TemplateDeductionInfo &Info,\n                        SmallVectorImpl<DeducedTemplateArgument> &Deduced) {\n  TemplateDecl *ParamDecl = Param.getAsTemplateDecl();\n  if (!ParamDecl) {\n    // The parameter type is dependent and is not a template template parameter,\n    // so there is nothing that we can deduce.\n    return Sema::TDK_Success;\n  }\n\n  if (TemplateTemplateParmDecl *TempParam\n        = dyn_cast<TemplateTemplateParmDecl>(ParamDecl)) {\n    // If we're not deducing at this depth, there's nothing to deduce.\n    if (TempParam->getDepth() != Info.getDeducedDepth())\n      return Sema::TDK_Success;\n\n    DeducedTemplateArgument NewDeduced(S.Context.getCanonicalTemplateName(Arg));\n    DeducedTemplateArgument Result = checkDeducedTemplateArguments(S.Context,\n                                                 Deduced[TempParam->getIndex()],\n                                                                   NewDeduced);\n    if (Result.isNull()) {\n      Info.Param = TempParam;\n      Info.FirstArg = Deduced[TempParam->getIndex()];\n      Info.SecondArg = NewDeduced;\n      return Sema::TDK_Inconsistent;\n    }\n\n    Deduced[TempParam->getIndex()] = Result;\n    return Sema::TDK_Success;\n  }\n\n  // Verify that the two template names are equivalent.\n  if (S.Context.hasSameTemplateName(Param, Arg))\n    return Sema::TDK_Success;\n\n  // Mismatch of non-dependent template parameter to argument.\n  Info.FirstArg = TemplateArgument(Param);\n  Info.SecondArg = TemplateArgument(Arg);\n  return Sema::TDK_NonDeducedMismatch;\n}\n\n/// Deduce the template arguments by comparing the template parameter\n/// type (which is a template-id) with the template argument type.\n///\n/// \\param S the Sema\n///\n/// \\param TemplateParams the template parameters that we are deducing\n///\n/// \\param Param the parameter type\n///\n/// \\param Arg the argument type\n///\n/// \\param Info information about the template argument deduction itself\n///\n/// \\param Deduced the deduced template arguments\n///\n/// \\returns the result of template argument deduction so far. Note that a\n/// \"success\" result means that template argument deduction has not yet failed,\n/// but it may still fail, later, for other reasons.\nstatic Sema::TemplateDeductionResult\nDeduceTemplateArguments(Sema &S,\n                        TemplateParameterList *TemplateParams,\n                        const TemplateSpecializationType *Param,\n                        QualType Arg,\n                        TemplateDeductionInfo &Info,\n                        SmallVectorImpl<DeducedTemplateArgument> &Deduced) {\n  assert(Arg.isCanonical() && \"Argument type must be canonical\");\n\n  // Treat an injected-class-name as its underlying template-id.\n  if (auto *Injected = dyn_cast<InjectedClassNameType>(Arg))\n    Arg = Injected->getInjectedSpecializationType();\n\n  // Check whether the template argument is a dependent template-id.\n  if (const TemplateSpecializationType *SpecArg\n        = dyn_cast<TemplateSpecializationType>(Arg)) {\n    // Perform template argument deduction for the template name.\n    if (Sema::TemplateDeductionResult Result\n          = DeduceTemplateArguments(S, TemplateParams,\n                                    Param->getTemplateName(),\n                                    SpecArg->getTemplateName(),\n                                    Info, Deduced))\n      return Result;\n\n\n    // Perform template argument deduction on each template\n    // argument. Ignore any missing/extra arguments, since they could be\n    // filled in by default arguments.\n    return DeduceTemplateArguments(S, TemplateParams,\n                                   Param->template_arguments(),\n                                   SpecArg->template_arguments(), Info, Deduced,\n                                   /*NumberOfArgumentsMustMatch=*/false);\n  }\n\n  // If the argument type is a class template specialization, we\n  // perform template argument deduction using its template\n  // arguments.\n  const RecordType *RecordArg = dyn_cast<RecordType>(Arg);\n  if (!RecordArg) {\n    Info.FirstArg = TemplateArgument(QualType(Param, 0));\n    Info.SecondArg = TemplateArgument(Arg);\n    return Sema::TDK_NonDeducedMismatch;\n  }\n\n  ClassTemplateSpecializationDecl *SpecArg\n    = dyn_cast<ClassTemplateSpecializationDecl>(RecordArg->getDecl());\n  if (!SpecArg) {\n    Info.FirstArg = TemplateArgument(QualType(Param, 0));\n    Info.SecondArg = TemplateArgument(Arg);\n    return Sema::TDK_NonDeducedMismatch;\n  }\n\n  // Perform template argument deduction for the template name.\n  if (Sema::TemplateDeductionResult Result\n        = DeduceTemplateArguments(S,\n                                  TemplateParams,\n                                  Param->getTemplateName(),\n                               TemplateName(SpecArg->getSpecializedTemplate()),\n                                  Info, Deduced))\n    return Result;\n\n  // Perform template argument deduction for the template arguments.\n  return DeduceTemplateArguments(S, TemplateParams, Param->template_arguments(),\n                                 SpecArg->getTemplateArgs().asArray(), Info,\n                                 Deduced, /*NumberOfArgumentsMustMatch=*/true);\n}\n\n/// Determines whether the given type is an opaque type that\n/// might be more qualified when instantiated.\nstatic bool IsPossiblyOpaquelyQualifiedType(QualType T) {\n  switch (T->getTypeClass()) {\n  case Type::TypeOfExpr:\n  case Type::TypeOf:\n  case Type::DependentName:\n  case Type::Decltype:\n  case Type::UnresolvedUsing:\n  case Type::TemplateTypeParm:\n    return true;\n\n  case Type::ConstantArray:\n  case Type::IncompleteArray:\n  case Type::VariableArray:\n  case Type::DependentSizedArray:\n    return IsPossiblyOpaquelyQualifiedType(\n                                      cast<ArrayType>(T)->getElementType());\n\n  default:\n    return false;\n  }\n}\n\n/// Helper function to build a TemplateParameter when we don't\n/// know its type statically.\nstatic TemplateParameter makeTemplateParameter(Decl *D) {\n  if (TemplateTypeParmDecl *TTP = dyn_cast<TemplateTypeParmDecl>(D))\n    return TemplateParameter(TTP);\n  if (NonTypeTemplateParmDecl *NTTP = dyn_cast<NonTypeTemplateParmDecl>(D))\n    return TemplateParameter(NTTP);\n\n  return TemplateParameter(cast<TemplateTemplateParmDecl>(D));\n}\n\n/// A pack that we're currently deducing.\nstruct clang::DeducedPack {\n  // The index of the pack.\n  unsigned Index;\n\n  // The old value of the pack before we started deducing it.\n  DeducedTemplateArgument Saved;\n\n  // A deferred value of this pack from an inner deduction, that couldn't be\n  // deduced because this deduction hadn't happened yet.\n  DeducedTemplateArgument DeferredDeduction;\n\n  // The new value of the pack.\n  SmallVector<DeducedTemplateArgument, 4> New;\n\n  // The outer deduction for this pack, if any.\n  DeducedPack *Outer = nullptr;\n\n  DeducedPack(unsigned Index) : Index(Index) {}\n};\n\nnamespace {\n\n/// A scope in which we're performing pack deduction.\nclass PackDeductionScope {\npublic:\n  /// Prepare to deduce the packs named within Pattern.\n  PackDeductionScope(Sema &S, TemplateParameterList *TemplateParams,\n                     SmallVectorImpl<DeducedTemplateArgument> &Deduced,\n                     TemplateDeductionInfo &Info, TemplateArgument Pattern)\n      : S(S), TemplateParams(TemplateParams), Deduced(Deduced), Info(Info) {\n    unsigned NumNamedPacks = addPacks(Pattern);\n    finishConstruction(NumNamedPacks);\n  }\n\n  /// Prepare to directly deduce arguments of the parameter with index \\p Index.\n  PackDeductionScope(Sema &S, TemplateParameterList *TemplateParams,\n                     SmallVectorImpl<DeducedTemplateArgument> &Deduced,\n                     TemplateDeductionInfo &Info, unsigned Index)\n      : S(S), TemplateParams(TemplateParams), Deduced(Deduced), Info(Info) {\n    addPack(Index);\n    finishConstruction(1);\n  }\n\nprivate:\n  void addPack(unsigned Index) {\n    // Save the deduced template argument for the parameter pack expanded\n    // by this pack expansion, then clear out the deduction.\n    DeducedPack Pack(Index);\n    Pack.Saved = Deduced[Index];\n    Deduced[Index] = TemplateArgument();\n\n    // FIXME: What if we encounter multiple packs with different numbers of\n    // pre-expanded expansions? (This should already have been diagnosed\n    // during substitution.)\n    if (Optional<unsigned> ExpandedPackExpansions =\n            getExpandedPackSize(TemplateParams->getParam(Index)))\n      FixedNumExpansions = ExpandedPackExpansions;\n\n    Packs.push_back(Pack);\n  }\n\n  unsigned addPacks(TemplateArgument Pattern) {\n    // Compute the set of template parameter indices that correspond to\n    // parameter packs expanded by the pack expansion.\n    llvm::SmallBitVector SawIndices(TemplateParams->size());\n    llvm::SmallVector<TemplateArgument, 4> ExtraDeductions;\n\n    auto AddPack = [&](unsigned Index) {\n      if (SawIndices[Index])\n        return;\n      SawIndices[Index] = true;\n      addPack(Index);\n\n      // Deducing a parameter pack that is a pack expansion also constrains the\n      // packs appearing in that parameter to have the same deduced arity. Also,\n      // in C++17 onwards, deducing a non-type template parameter deduces its\n      // type, so we need to collect the pending deduced values for those packs.\n      if (auto *NTTP = dyn_cast<NonTypeTemplateParmDecl>(\n              TemplateParams->getParam(Index))) {\n        if (!NTTP->isExpandedParameterPack())\n          if (auto *Expansion = dyn_cast<PackExpansionType>(NTTP->getType()))\n            ExtraDeductions.push_back(Expansion->getPattern());\n      }\n      // FIXME: Also collect the unexpanded packs in any type and template\n      // parameter packs that are pack expansions.\n    };\n\n    auto Collect = [&](TemplateArgument Pattern) {\n      SmallVector<UnexpandedParameterPack, 2> Unexpanded;\n      S.collectUnexpandedParameterPacks(Pattern, Unexpanded);\n      for (unsigned I = 0, N = Unexpanded.size(); I != N; ++I) {\n        unsigned Depth, Index;\n        std::tie(Depth, Index) = getDepthAndIndex(Unexpanded[I]);\n        if (Depth == Info.getDeducedDepth())\n          AddPack(Index);\n      }\n    };\n\n    // Look for unexpanded packs in the pattern.\n    Collect(Pattern);\n    assert(!Packs.empty() && \"Pack expansion without unexpanded packs?\");\n\n    unsigned NumNamedPacks = Packs.size();\n\n    // Also look for unexpanded packs that are indirectly deduced by deducing\n    // the sizes of the packs in this pattern.\n    while (!ExtraDeductions.empty())\n      Collect(ExtraDeductions.pop_back_val());\n\n    return NumNamedPacks;\n  }\n\n  void finishConstruction(unsigned NumNamedPacks) {\n    // Dig out the partially-substituted pack, if there is one.\n    const TemplateArgument *PartialPackArgs = nullptr;\n    unsigned NumPartialPackArgs = 0;\n    std::pair<unsigned, unsigned> PartialPackDepthIndex(-1u, -1u);\n    if (auto *Scope = S.CurrentInstantiationScope)\n      if (auto *Partial = Scope->getPartiallySubstitutedPack(\n              &PartialPackArgs, &NumPartialPackArgs))\n        PartialPackDepthIndex = getDepthAndIndex(Partial);\n\n    // This pack expansion will have been partially or fully expanded if\n    // it only names explicitly-specified parameter packs (including the\n    // partially-substituted one, if any).\n    bool IsExpanded = true;\n    for (unsigned I = 0; I != NumNamedPacks; ++I) {\n      if (Packs[I].Index >= Info.getNumExplicitArgs()) {\n        IsExpanded = false;\n        IsPartiallyExpanded = false;\n        break;\n      }\n      if (PartialPackDepthIndex ==\n            std::make_pair(Info.getDeducedDepth(), Packs[I].Index)) {\n        IsPartiallyExpanded = true;\n      }\n    }\n\n    // Skip over the pack elements that were expanded into separate arguments.\n    // If we partially expanded, this is the number of partial arguments.\n    if (IsPartiallyExpanded)\n      PackElements += NumPartialPackArgs;\n    else if (IsExpanded)\n      PackElements += *FixedNumExpansions;\n\n    for (auto &Pack : Packs) {\n      if (Info.PendingDeducedPacks.size() > Pack.Index)\n        Pack.Outer = Info.PendingDeducedPacks[Pack.Index];\n      else\n        Info.PendingDeducedPacks.resize(Pack.Index + 1);\n      Info.PendingDeducedPacks[Pack.Index] = &Pack;\n\n      if (PartialPackDepthIndex ==\n            std::make_pair(Info.getDeducedDepth(), Pack.Index)) {\n        Pack.New.append(PartialPackArgs, PartialPackArgs + NumPartialPackArgs);\n        // We pre-populate the deduced value of the partially-substituted\n        // pack with the specified value. This is not entirely correct: the\n        // value is supposed to have been substituted, not deduced, but the\n        // cases where this is observable require an exact type match anyway.\n        //\n        // FIXME: If we could represent a \"depth i, index j, pack elem k\"\n        // parameter, we could substitute the partially-substituted pack\n        // everywhere and avoid this.\n        if (!IsPartiallyExpanded)\n          Deduced[Pack.Index] = Pack.New[PackElements];\n      }\n    }\n  }\n\npublic:\n  ~PackDeductionScope() {\n    for (auto &Pack : Packs)\n      Info.PendingDeducedPacks[Pack.Index] = Pack.Outer;\n  }\n\n  /// Determine whether this pack has already been partially expanded into a\n  /// sequence of (prior) function parameters / template arguments.\n  bool isPartiallyExpanded() { return IsPartiallyExpanded; }\n\n  /// Determine whether this pack expansion scope has a known, fixed arity.\n  /// This happens if it involves a pack from an outer template that has\n  /// (notionally) already been expanded.\n  bool hasFixedArity() { return FixedNumExpansions.hasValue(); }\n\n  /// Determine whether the next element of the argument is still part of this\n  /// pack. This is the case unless the pack is already expanded to a fixed\n  /// length.\n  bool hasNextElement() {\n    return !FixedNumExpansions || *FixedNumExpansions > PackElements;\n  }\n\n  /// Move to deducing the next element in each pack that is being deduced.\n  void nextPackElement() {\n    // Capture the deduced template arguments for each parameter pack expanded\n    // by this pack expansion, add them to the list of arguments we've deduced\n    // for that pack, then clear out the deduced argument.\n    for (auto &Pack : Packs) {\n      DeducedTemplateArgument &DeducedArg = Deduced[Pack.Index];\n      if (!Pack.New.empty() || !DeducedArg.isNull()) {\n        while (Pack.New.size() < PackElements)\n          Pack.New.push_back(DeducedTemplateArgument());\n        if (Pack.New.size() == PackElements)\n          Pack.New.push_back(DeducedArg);\n        else\n          Pack.New[PackElements] = DeducedArg;\n        DeducedArg = Pack.New.size() > PackElements + 1\n                         ? Pack.New[PackElements + 1]\n                         : DeducedTemplateArgument();\n      }\n    }\n    ++PackElements;\n  }\n\n  /// Finish template argument deduction for a set of argument packs,\n  /// producing the argument packs and checking for consistency with prior\n  /// deductions.\n  Sema::TemplateDeductionResult finish() {\n    // Build argument packs for each of the parameter packs expanded by this\n    // pack expansion.\n    for (auto &Pack : Packs) {\n      // Put back the old value for this pack.\n      Deduced[Pack.Index] = Pack.Saved;\n\n      // Always make sure the size of this pack is correct, even if we didn't\n      // deduce any values for it.\n      //\n      // FIXME: This isn't required by the normative wording, but substitution\n      // and post-substitution checking will always fail if the arity of any\n      // pack is not equal to the number of elements we processed. (Either that\n      // or something else has gone *very* wrong.) We're permitted to skip any\n      // hard errors from those follow-on steps by the intent (but not the\n      // wording) of C++ [temp.inst]p8:\n      //\n      //   If the function selected by overload resolution can be determined\n      //   without instantiating a class template definition, it is unspecified\n      //   whether that instantiation actually takes place\n      Pack.New.resize(PackElements);\n\n      // Build or find a new value for this pack.\n      DeducedTemplateArgument NewPack;\n      if (Pack.New.empty()) {\n        // If we deduced an empty argument pack, create it now.\n        NewPack = DeducedTemplateArgument(TemplateArgument::getEmptyPack());\n      } else {\n        TemplateArgument *ArgumentPack =\n            new (S.Context) TemplateArgument[Pack.New.size()];\n        std::copy(Pack.New.begin(), Pack.New.end(), ArgumentPack);\n        NewPack = DeducedTemplateArgument(\n            TemplateArgument(llvm::makeArrayRef(ArgumentPack, Pack.New.size())),\n            // FIXME: This is wrong, it's possible that some pack elements are\n            // deduced from an array bound and others are not:\n            //   template<typename ...T, T ...V> void g(const T (&...p)[V]);\n            //   g({1, 2, 3}, {{}, {}});\n            // ... should deduce T = {int, size_t (from array bound)}.\n            Pack.New[0].wasDeducedFromArrayBound());\n      }\n\n      // Pick where we're going to put the merged pack.\n      DeducedTemplateArgument *Loc;\n      if (Pack.Outer) {\n        if (Pack.Outer->DeferredDeduction.isNull()) {\n          // Defer checking this pack until we have a complete pack to compare\n          // it against.\n          Pack.Outer->DeferredDeduction = NewPack;\n          continue;\n        }\n        Loc = &Pack.Outer->DeferredDeduction;\n      } else {\n        Loc = &Deduced[Pack.Index];\n      }\n\n      // Check the new pack matches any previous value.\n      DeducedTemplateArgument OldPack = *Loc;\n      DeducedTemplateArgument Result =\n          checkDeducedTemplateArguments(S.Context, OldPack, NewPack);\n\n      // If we deferred a deduction of this pack, check that one now too.\n      if (!Result.isNull() && !Pack.DeferredDeduction.isNull()) {\n        OldPack = Result;\n        NewPack = Pack.DeferredDeduction;\n        Result = checkDeducedTemplateArguments(S.Context, OldPack, NewPack);\n      }\n\n      NamedDecl *Param = TemplateParams->getParam(Pack.Index);\n      if (Result.isNull()) {\n        Info.Param = makeTemplateParameter(Param);\n        Info.FirstArg = OldPack;\n        Info.SecondArg = NewPack;\n        return Sema::TDK_Inconsistent;\n      }\n\n      // If we have a pre-expanded pack and we didn't deduce enough elements\n      // for it, fail deduction.\n      if (Optional<unsigned> Expansions = getExpandedPackSize(Param)) {\n        if (*Expansions != PackElements) {\n          Info.Param = makeTemplateParameter(Param);\n          Info.FirstArg = Result;\n          return Sema::TDK_IncompletePack;\n        }\n      }\n\n      *Loc = Result;\n    }\n\n    return Sema::TDK_Success;\n  }\n\nprivate:\n  Sema &S;\n  TemplateParameterList *TemplateParams;\n  SmallVectorImpl<DeducedTemplateArgument> &Deduced;\n  TemplateDeductionInfo &Info;\n  unsigned PackElements = 0;\n  bool IsPartiallyExpanded = false;\n  /// The number of expansions, if we have a fully-expanded pack in this scope.\n  Optional<unsigned> FixedNumExpansions;\n\n  SmallVector<DeducedPack, 2> Packs;\n};\n\n} // namespace\n\n/// Deduce the template arguments by comparing the list of parameter\n/// types to the list of argument types, as in the parameter-type-lists of\n/// function types (C++ [temp.deduct.type]p10).\n///\n/// \\param S The semantic analysis object within which we are deducing\n///\n/// \\param TemplateParams The template parameters that we are deducing\n///\n/// \\param Params The list of parameter types\n///\n/// \\param NumParams The number of types in \\c Params\n///\n/// \\param Args The list of argument types\n///\n/// \\param NumArgs The number of types in \\c Args\n///\n/// \\param Info information about the template argument deduction itself\n///\n/// \\param Deduced the deduced template arguments\n///\n/// \\param TDF bitwise OR of the TemplateDeductionFlags bits that describe\n/// how template argument deduction is performed.\n///\n/// \\param PartialOrdering If true, we are performing template argument\n/// deduction for during partial ordering for a call\n/// (C++0x [temp.deduct.partial]).\n///\n/// \\returns the result of template argument deduction so far. Note that a\n/// \"success\" result means that template argument deduction has not yet failed,\n/// but it may still fail, later, for other reasons.\nstatic Sema::TemplateDeductionResult\nDeduceTemplateArguments(Sema &S,\n                        TemplateParameterList *TemplateParams,\n                        const QualType *Params, unsigned NumParams,\n                        const QualType *Args, unsigned NumArgs,\n                        TemplateDeductionInfo &Info,\n                        SmallVectorImpl<DeducedTemplateArgument> &Deduced,\n                        unsigned TDF,\n                        bool PartialOrdering = false) {\n  // C++0x [temp.deduct.type]p10:\n  //   Similarly, if P has a form that contains (T), then each parameter type\n  //   Pi of the respective parameter-type- list of P is compared with the\n  //   corresponding parameter type Ai of the corresponding parameter-type-list\n  //   of A. [...]\n  unsigned ArgIdx = 0, ParamIdx = 0;\n  for (; ParamIdx != NumParams; ++ParamIdx) {\n    // Check argument types.\n    const PackExpansionType *Expansion\n                                = dyn_cast<PackExpansionType>(Params[ParamIdx]);\n    if (!Expansion) {\n      // Simple case: compare the parameter and argument types at this point.\n\n      // Make sure we have an argument.\n      if (ArgIdx >= NumArgs)\n        return Sema::TDK_MiscellaneousDeductionFailure;\n\n      if (isa<PackExpansionType>(Args[ArgIdx])) {\n        // C++0x [temp.deduct.type]p22:\n        //   If the original function parameter associated with A is a function\n        //   parameter pack and the function parameter associated with P is not\n        //   a function parameter pack, then template argument deduction fails.\n        return Sema::TDK_MiscellaneousDeductionFailure;\n      }\n\n      if (Sema::TemplateDeductionResult Result\n            = DeduceTemplateArgumentsByTypeMatch(S, TemplateParams,\n                                                 Params[ParamIdx], Args[ArgIdx],\n                                                 Info, Deduced, TDF,\n                                                 PartialOrdering))\n        return Result;\n\n      ++ArgIdx;\n      continue;\n    }\n\n    // C++0x [temp.deduct.type]p10:\n    //   If the parameter-declaration corresponding to Pi is a function\n    //   parameter pack, then the type of its declarator- id is compared with\n    //   each remaining parameter type in the parameter-type-list of A. Each\n    //   comparison deduces template arguments for subsequent positions in the\n    //   template parameter packs expanded by the function parameter pack.\n\n    QualType Pattern = Expansion->getPattern();\n    PackDeductionScope PackScope(S, TemplateParams, Deduced, Info, Pattern);\n\n    // A pack scope with fixed arity is not really a pack any more, so is not\n    // a non-deduced context.\n    if (ParamIdx + 1 == NumParams || PackScope.hasFixedArity()) {\n      for (; ArgIdx < NumArgs && PackScope.hasNextElement(); ++ArgIdx) {\n        // Deduce template arguments from the pattern.\n        if (Sema::TemplateDeductionResult Result\n              = DeduceTemplateArgumentsByTypeMatch(S, TemplateParams, Pattern,\n                                                   Args[ArgIdx], Info, Deduced,\n                                                   TDF, PartialOrdering))\n          return Result;\n\n        PackScope.nextPackElement();\n      }\n    } else {\n      // C++0x [temp.deduct.type]p5:\n      //   The non-deduced contexts are:\n      //     - A function parameter pack that does not occur at the end of the\n      //       parameter-declaration-clause.\n      //\n      // FIXME: There is no wording to say what we should do in this case. We\n      // choose to resolve this by applying the same rule that is applied for a\n      // function call: that is, deduce all contained packs to their\n      // explicitly-specified values (or to <> if there is no such value).\n      //\n      // This is seemingly-arbitrarily different from the case of a template-id\n      // with a non-trailing pack-expansion in its arguments, which renders the\n      // entire template-argument-list a non-deduced context.\n\n      // If the parameter type contains an explicitly-specified pack that we\n      // could not expand, skip the number of parameters notionally created\n      // by the expansion.\n      Optional<unsigned> NumExpansions = Expansion->getNumExpansions();\n      if (NumExpansions && !PackScope.isPartiallyExpanded()) {\n        for (unsigned I = 0; I != *NumExpansions && ArgIdx < NumArgs;\n             ++I, ++ArgIdx)\n          PackScope.nextPackElement();\n      }\n    }\n\n    // Build argument packs for each of the parameter packs expanded by this\n    // pack expansion.\n    if (auto Result = PackScope.finish())\n      return Result;\n  }\n\n  // Make sure we don't have any extra arguments.\n  if (ArgIdx < NumArgs)\n    return Sema::TDK_MiscellaneousDeductionFailure;\n\n  return Sema::TDK_Success;\n}\n\n/// Determine whether the parameter has qualifiers that the argument\n/// lacks. Put another way, determine whether there is no way to add\n/// a deduced set of qualifiers to the ParamType that would result in\n/// its qualifiers matching those of the ArgType.\nstatic bool hasInconsistentOrSupersetQualifiersOf(QualType ParamType,\n                                                  QualType ArgType) {\n  Qualifiers ParamQs = ParamType.getQualifiers();\n  Qualifiers ArgQs = ArgType.getQualifiers();\n\n  if (ParamQs == ArgQs)\n    return false;\n\n  // Mismatched (but not missing) Objective-C GC attributes.\n  if (ParamQs.getObjCGCAttr() != ArgQs.getObjCGCAttr() &&\n      ParamQs.hasObjCGCAttr())\n    return true;\n\n  // Mismatched (but not missing) address spaces.\n  if (ParamQs.getAddressSpace() != ArgQs.getAddressSpace() &&\n      ParamQs.hasAddressSpace())\n    return true;\n\n  // Mismatched (but not missing) Objective-C lifetime qualifiers.\n  if (ParamQs.getObjCLifetime() != ArgQs.getObjCLifetime() &&\n      ParamQs.hasObjCLifetime())\n    return true;\n\n  // CVR qualifiers inconsistent or a superset.\n  return (ParamQs.getCVRQualifiers() & ~ArgQs.getCVRQualifiers()) != 0;\n}\n\n/// Compare types for equality with respect to possibly compatible\n/// function types (noreturn adjustment, implicit calling conventions). If any\n/// of parameter and argument is not a function, just perform type comparison.\n///\n/// \\param Param the template parameter type.\n///\n/// \\param Arg the argument type.\nbool Sema::isSameOrCompatibleFunctionType(CanQualType Param,\n                                          CanQualType Arg) {\n  const FunctionType *ParamFunction = Param->getAs<FunctionType>(),\n                     *ArgFunction   = Arg->getAs<FunctionType>();\n\n  // Just compare if not functions.\n  if (!ParamFunction || !ArgFunction)\n    return Param == Arg;\n\n  // Noreturn and noexcept adjustment.\n  QualType AdjustedParam;\n  if (IsFunctionConversion(Param, Arg, AdjustedParam))\n    return Arg == Context.getCanonicalType(AdjustedParam);\n\n  // FIXME: Compatible calling conventions.\n\n  return Param == Arg;\n}\n\n/// Get the index of the first template parameter that was originally from the\n/// innermost template-parameter-list. This is 0 except when we concatenate\n/// the template parameter lists of a class template and a constructor template\n/// when forming an implicit deduction guide.\nstatic unsigned getFirstInnerIndex(FunctionTemplateDecl *FTD) {\n  auto *Guide = dyn_cast<CXXDeductionGuideDecl>(FTD->getTemplatedDecl());\n  if (!Guide || !Guide->isImplicit())\n    return 0;\n  return Guide->getDeducedTemplate()->getTemplateParameters()->size();\n}\n\n/// Determine whether a type denotes a forwarding reference.\nstatic bool isForwardingReference(QualType Param, unsigned FirstInnerIndex) {\n  // C++1z [temp.deduct.call]p3:\n  //   A forwarding reference is an rvalue reference to a cv-unqualified\n  //   template parameter that does not represent a template parameter of a\n  //   class template.\n  if (auto *ParamRef = Param->getAs<RValueReferenceType>()) {\n    if (ParamRef->getPointeeType().getQualifiers())\n      return false;\n    auto *TypeParm = ParamRef->getPointeeType()->getAs<TemplateTypeParmType>();\n    return TypeParm && TypeParm->getIndex() >= FirstInnerIndex;\n  }\n  return false;\n}\n\n///  Attempt to deduce the template arguments by checking the base types\n///  according to (C++20 [temp.deduct.call] p4b3.\n///\n/// \\param S the semantic analysis object within which we are deducing.\n///\n/// \\param RecordT the top level record object we are deducing against.\n///\n/// \\param TemplateParams the template parameters that we are deducing.\n///\n/// \\param SpecParam the template specialization parameter type.\n///\n/// \\param Info information about the template argument deduction itself.\n///\n/// \\param Deduced the deduced template arguments.\n///\n/// \\returns the result of template argument deduction with the bases. \"invalid\"\n/// means no matches, \"success\" found a single item, and the\n/// \"MiscellaneousDeductionFailure\" result happens when the match is ambiguous.\nstatic Sema::TemplateDeductionResult DeduceTemplateBases(\n    Sema &S, const RecordType *RecordT, TemplateParameterList *TemplateParams,\n    const TemplateSpecializationType *SpecParam, TemplateDeductionInfo &Info,\n    SmallVectorImpl<DeducedTemplateArgument> &Deduced) {\n  // C++14 [temp.deduct.call] p4b3:\n  //   If P is a class and P has the form simple-template-id, then the\n  //   transformed A can be a derived class of the deduced A. Likewise if\n  //   P is a pointer to a class of the form simple-template-id, the\n  //   transformed A can be a pointer to a derived class pointed to by the\n  //   deduced A. However, if there is a class C that is a (direct or\n  //   indirect) base class of D and derived (directly or indirectly) from a\n  //   class B and that would be a valid deduced A, the deduced A cannot be\n  //   B or pointer to B, respectively.\n  //\n  //   These alternatives are considered only if type deduction would\n  //   otherwise fail. If they yield more than one possible deduced A, the\n  //   type deduction fails.\n\n  // Use a breadth-first search through the bases to collect the set of\n  // successful matches. Visited contains the set of nodes we have already\n  // visited, while ToVisit is our stack of records that we still need to\n  // visit.  Matches contains a list of matches that have yet to be\n  // disqualified.\n  llvm::SmallPtrSet<const RecordType *, 8> Visited;\n  SmallVector<const RecordType *, 8> ToVisit;\n  // We iterate over this later, so we have to use MapVector to ensure\n  // determinism.\n  llvm::MapVector<const RecordType *, SmallVector<DeducedTemplateArgument, 8>>\n      Matches;\n\n  auto AddBases = [&Visited, &ToVisit](const RecordType *RT) {\n    CXXRecordDecl *RD = cast<CXXRecordDecl>(RT->getDecl());\n    for (const auto &Base : RD->bases()) {\n      assert(Base.getType()->isRecordType() &&\n             \"Base class that isn't a record?\");\n      const RecordType *RT = Base.getType()->getAs<RecordType>();\n      if (Visited.insert(RT).second)\n        ToVisit.push_back(Base.getType()->getAs<RecordType>());\n    }\n  };\n\n  // Set up the loop by adding all the bases.\n  AddBases(RecordT);\n\n  // Search each path of bases until we either run into a successful match\n  // (where all bases of it are invalid), or we run out of bases.\n  while (!ToVisit.empty()) {\n    const RecordType *NextT = ToVisit.pop_back_val();\n\n    SmallVector<DeducedTemplateArgument, 8> DeducedCopy(Deduced.begin(),\n                                                        Deduced.end());\n    TemplateDeductionInfo BaseInfo(TemplateDeductionInfo::ForBase, Info);\n    Sema::TemplateDeductionResult BaseResult =\n        DeduceTemplateArguments(S, TemplateParams, SpecParam,\n                                QualType(NextT, 0), BaseInfo, DeducedCopy);\n\n    // If this was a successful deduction, add it to the list of matches,\n    // otherwise we need to continue searching its bases.\n    if (BaseResult == Sema::TDK_Success)\n      Matches.insert({NextT, DeducedCopy});\n    else\n      AddBases(NextT);\n  }\n\n  // At this point, 'Matches' contains a list of seemingly valid bases, however\n  // in the event that we have more than 1 match, it is possible that the base\n  // of one of the matches might be disqualified for being a base of another\n  // valid match. We can count on cyclical instantiations being invalid to\n  // simplify the disqualifications.  That is, if A & B are both matches, and B\n  // inherits from A (disqualifying A), we know that A cannot inherit from B.\n  if (Matches.size() > 1) {\n    Visited.clear();\n    for (const auto &Match : Matches)\n      AddBases(Match.first);\n\n    // We can give up once we have a single item (or have run out of things to\n    // search) since cyclical inheritence isn't valid.\n    while (Matches.size() > 1 && !ToVisit.empty()) {\n      const RecordType *NextT = ToVisit.pop_back_val();\n      Matches.erase(NextT);\n\n      // Always add all bases, since the inheritence tree can contain\n      // disqualifications for multiple matches.\n      AddBases(NextT);\n    }\n  }\n\n  if (Matches.empty())\n    return Sema::TDK_Invalid;\n  if (Matches.size() > 1)\n    return Sema::TDK_MiscellaneousDeductionFailure;\n\n  std::swap(Matches.front().second, Deduced);\n  return Sema::TDK_Success;\n}\n\n/// Deduce the template arguments by comparing the parameter type and\n/// the argument type (C++ [temp.deduct.type]).\n///\n/// \\param S the semantic analysis object within which we are deducing\n///\n/// \\param TemplateParams the template parameters that we are deducing\n///\n/// \\param ParamIn the parameter type\n///\n/// \\param ArgIn the argument type\n///\n/// \\param Info information about the template argument deduction itself\n///\n/// \\param Deduced the deduced template arguments\n///\n/// \\param TDF bitwise OR of the TemplateDeductionFlags bits that describe\n/// how template argument deduction is performed.\n///\n/// \\param PartialOrdering Whether we're performing template argument deduction\n/// in the context of partial ordering (C++0x [temp.deduct.partial]).\n///\n/// \\returns the result of template argument deduction so far. Note that a\n/// \"success\" result means that template argument deduction has not yet failed,\n/// but it may still fail, later, for other reasons.\nstatic Sema::TemplateDeductionResult\nDeduceTemplateArgumentsByTypeMatch(Sema &S,\n                                   TemplateParameterList *TemplateParams,\n                                   QualType ParamIn, QualType ArgIn,\n                                   TemplateDeductionInfo &Info,\n                            SmallVectorImpl<DeducedTemplateArgument> &Deduced,\n                                   unsigned TDF,\n                                   bool PartialOrdering,\n                                   bool DeducedFromArrayBound) {\n  // We only want to look at the canonical types, since typedefs and\n  // sugar are not part of template argument deduction.\n  QualType Param = S.Context.getCanonicalType(ParamIn);\n  QualType Arg = S.Context.getCanonicalType(ArgIn);\n\n  // If the argument type is a pack expansion, look at its pattern.\n  // This isn't explicitly called out\n  if (const PackExpansionType *ArgExpansion\n                                            = dyn_cast<PackExpansionType>(Arg))\n    Arg = ArgExpansion->getPattern();\n\n  if (PartialOrdering) {\n    // C++11 [temp.deduct.partial]p5:\n    //   Before the partial ordering is done, certain transformations are\n    //   performed on the types used for partial ordering:\n    //     - If P is a reference type, P is replaced by the type referred to.\n    const ReferenceType *ParamRef = Param->getAs<ReferenceType>();\n    if (ParamRef)\n      Param = ParamRef->getPointeeType();\n\n    //     - If A is a reference type, A is replaced by the type referred to.\n    const ReferenceType *ArgRef = Arg->getAs<ReferenceType>();\n    if (ArgRef)\n      Arg = ArgRef->getPointeeType();\n\n    if (ParamRef && ArgRef && S.Context.hasSameUnqualifiedType(Param, Arg)) {\n      // C++11 [temp.deduct.partial]p9:\n      //   If, for a given type, deduction succeeds in both directions (i.e.,\n      //   the types are identical after the transformations above) and both\n      //   P and A were reference types [...]:\n      //     - if [one type] was an lvalue reference and [the other type] was\n      //       not, [the other type] is not considered to be at least as\n      //       specialized as [the first type]\n      //     - if [one type] is more cv-qualified than [the other type],\n      //       [the other type] is not considered to be at least as specialized\n      //       as [the first type]\n      // Objective-C ARC adds:\n      //     - [one type] has non-trivial lifetime, [the other type] has\n      //       __unsafe_unretained lifetime, and the types are otherwise\n      //       identical\n      //\n      // A is \"considered to be at least as specialized\" as P iff deduction\n      // succeeds, so we model this as a deduction failure. Note that\n      // [the first type] is P and [the other type] is A here; the standard\n      // gets this backwards.\n      Qualifiers ParamQuals = Param.getQualifiers();\n      Qualifiers ArgQuals = Arg.getQualifiers();\n      if ((ParamRef->isLValueReferenceType() &&\n           !ArgRef->isLValueReferenceType()) ||\n          ParamQuals.isStrictSupersetOf(ArgQuals) ||\n          (ParamQuals.hasNonTrivialObjCLifetime() &&\n           ArgQuals.getObjCLifetime() == Qualifiers::OCL_ExplicitNone &&\n           ParamQuals.withoutObjCLifetime() ==\n               ArgQuals.withoutObjCLifetime())) {\n        Info.FirstArg = TemplateArgument(ParamIn);\n        Info.SecondArg = TemplateArgument(ArgIn);\n        return Sema::TDK_NonDeducedMismatch;\n      }\n    }\n\n    // C++11 [temp.deduct.partial]p7:\n    //   Remove any top-level cv-qualifiers:\n    //     - If P is a cv-qualified type, P is replaced by the cv-unqualified\n    //       version of P.\n    Param = Param.getUnqualifiedType();\n    //     - If A is a cv-qualified type, A is replaced by the cv-unqualified\n    //       version of A.\n    Arg = Arg.getUnqualifiedType();\n  } else {\n    // C++0x [temp.deduct.call]p4 bullet 1:\n    //   - If the original P is a reference type, the deduced A (i.e., the type\n    //     referred to by the reference) can be more cv-qualified than the\n    //     transformed A.\n    if (TDF & TDF_ParamWithReferenceType) {\n      Qualifiers Quals;\n      QualType UnqualParam = S.Context.getUnqualifiedArrayType(Param, Quals);\n      Quals.setCVRQualifiers(Quals.getCVRQualifiers() &\n                             Arg.getCVRQualifiers());\n      Param = S.Context.getQualifiedType(UnqualParam, Quals);\n    }\n\n    if ((TDF & TDF_TopLevelParameterTypeList) && !Param->isFunctionType()) {\n      // C++0x [temp.deduct.type]p10:\n      //   If P and A are function types that originated from deduction when\n      //   taking the address of a function template (14.8.2.2) or when deducing\n      //   template arguments from a function declaration (14.8.2.6) and Pi and\n      //   Ai are parameters of the top-level parameter-type-list of P and A,\n      //   respectively, Pi is adjusted if it is a forwarding reference and Ai\n      //   is an lvalue reference, in\n      //   which case the type of Pi is changed to be the template parameter\n      //   type (i.e., T&& is changed to simply T). [ Note: As a result, when\n      //   Pi is T&& and Ai is X&, the adjusted Pi will be T, causing T to be\n      //   deduced as X&. - end note ]\n      TDF &= ~TDF_TopLevelParameterTypeList;\n      if (isForwardingReference(Param, 0) && Arg->isLValueReferenceType())\n        Param = Param->getPointeeType();\n    }\n  }\n\n  // C++ [temp.deduct.type]p9:\n  //   A template type argument T, a template template argument TT or a\n  //   template non-type argument i can be deduced if P and A have one of\n  //   the following forms:\n  //\n  //     T\n  //     cv-list T\n  if (const TemplateTypeParmType *TemplateTypeParm\n        = Param->getAs<TemplateTypeParmType>()) {\n    // Just skip any attempts to deduce from a placeholder type or a parameter\n    // at a different depth.\n    if (Arg->isPlaceholderType() ||\n        Info.getDeducedDepth() != TemplateTypeParm->getDepth())\n      return Sema::TDK_Success;\n\n    unsigned Index = TemplateTypeParm->getIndex();\n    bool RecanonicalizeArg = false;\n\n    // If the argument type is an array type, move the qualifiers up to the\n    // top level, so they can be matched with the qualifiers on the parameter.\n    if (isa<ArrayType>(Arg)) {\n      Qualifiers Quals;\n      Arg = S.Context.getUnqualifiedArrayType(Arg, Quals);\n      if (Quals) {\n        Arg = S.Context.getQualifiedType(Arg, Quals);\n        RecanonicalizeArg = true;\n      }\n    }\n\n    // The argument type can not be less qualified than the parameter\n    // type.\n    if (!(TDF & TDF_IgnoreQualifiers) &&\n        hasInconsistentOrSupersetQualifiersOf(Param, Arg)) {\n      Info.Param = cast<TemplateTypeParmDecl>(TemplateParams->getParam(Index));\n      Info.FirstArg = TemplateArgument(Param);\n      Info.SecondArg = TemplateArgument(Arg);\n      return Sema::TDK_Underqualified;\n    }\n\n    // Do not match a function type with a cv-qualified type.\n    // http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_active.html#1584\n    if (Arg->isFunctionType() && Param.hasQualifiers()) {\n      return Sema::TDK_NonDeducedMismatch;\n    }\n\n    assert(TemplateTypeParm->getDepth() == Info.getDeducedDepth() &&\n           \"saw template type parameter with wrong depth\");\n    assert(Arg != S.Context.OverloadTy && \"Unresolved overloaded function\");\n    QualType DeducedType = Arg;\n\n    // Remove any qualifiers on the parameter from the deduced type.\n    // We checked the qualifiers for consistency above.\n    Qualifiers DeducedQs = DeducedType.getQualifiers();\n    Qualifiers ParamQs = Param.getQualifiers();\n    DeducedQs.removeCVRQualifiers(ParamQs.getCVRQualifiers());\n    if (ParamQs.hasObjCGCAttr())\n      DeducedQs.removeObjCGCAttr();\n    if (ParamQs.hasAddressSpace())\n      DeducedQs.removeAddressSpace();\n    if (ParamQs.hasObjCLifetime())\n      DeducedQs.removeObjCLifetime();\n\n    // Objective-C ARC:\n    //   If template deduction would produce a lifetime qualifier on a type\n    //   that is not a lifetime type, template argument deduction fails.\n    if (ParamQs.hasObjCLifetime() && !DeducedType->isObjCLifetimeType() &&\n        !DeducedType->isDependentType()) {\n      Info.Param = cast<TemplateTypeParmDecl>(TemplateParams->getParam(Index));\n      Info.FirstArg = TemplateArgument(Param);\n      Info.SecondArg = TemplateArgument(Arg);\n      return Sema::TDK_Underqualified;\n    }\n\n    // Objective-C ARC:\n    //   If template deduction would produce an argument type with lifetime type\n    //   but no lifetime qualifier, the __strong lifetime qualifier is inferred.\n    if (S.getLangOpts().ObjCAutoRefCount &&\n        DeducedType->isObjCLifetimeType() &&\n        !DeducedQs.hasObjCLifetime())\n      DeducedQs.setObjCLifetime(Qualifiers::OCL_Strong);\n\n    DeducedType = S.Context.getQualifiedType(DeducedType.getUnqualifiedType(),\n                                             DeducedQs);\n\n    if (RecanonicalizeArg)\n      DeducedType = S.Context.getCanonicalType(DeducedType);\n\n    DeducedTemplateArgument NewDeduced(DeducedType, DeducedFromArrayBound);\n    DeducedTemplateArgument Result = checkDeducedTemplateArguments(S.Context,\n                                                                 Deduced[Index],\n                                                                   NewDeduced);\n    if (Result.isNull()) {\n      Info.Param = cast<TemplateTypeParmDecl>(TemplateParams->getParam(Index));\n      Info.FirstArg = Deduced[Index];\n      Info.SecondArg = NewDeduced;\n      return Sema::TDK_Inconsistent;\n    }\n\n    Deduced[Index] = Result;\n    return Sema::TDK_Success;\n  }\n\n  // Set up the template argument deduction information for a failure.\n  Info.FirstArg = TemplateArgument(ParamIn);\n  Info.SecondArg = TemplateArgument(ArgIn);\n\n  // If the parameter is an already-substituted template parameter\n  // pack, do nothing: we don't know which of its arguments to look\n  // at, so we have to wait until all of the parameter packs in this\n  // expansion have arguments.\n  if (isa<SubstTemplateTypeParmPackType>(Param))\n    return Sema::TDK_Success;\n\n  // Check the cv-qualifiers on the parameter and argument types.\n  CanQualType CanParam = S.Context.getCanonicalType(Param);\n  CanQualType CanArg = S.Context.getCanonicalType(Arg);\n  if (!(TDF & TDF_IgnoreQualifiers)) {\n    if (TDF & TDF_ParamWithReferenceType) {\n      if (hasInconsistentOrSupersetQualifiersOf(Param, Arg))\n        return Sema::TDK_NonDeducedMismatch;\n    } else if (TDF & TDF_ArgWithReferenceType) {\n      // C++ [temp.deduct.conv]p4:\n      //   If the original A is a reference type, A can be more cv-qualified\n      //   than the deduced A\n      if (!Arg.getQualifiers().compatiblyIncludes(Param.getQualifiers()))\n        return Sema::TDK_NonDeducedMismatch;\n\n      // Strip out all extra qualifiers from the argument to figure out the\n      // type we're converting to, prior to the qualification conversion.\n      Qualifiers Quals;\n      Arg = S.Context.getUnqualifiedArrayType(Arg, Quals);\n      Arg = S.Context.getQualifiedType(Arg, Param.getQualifiers());\n    } else if (!IsPossiblyOpaquelyQualifiedType(Param)) {\n      if (Param.getCVRQualifiers() != Arg.getCVRQualifiers())\n        return Sema::TDK_NonDeducedMismatch;\n    }\n\n    // If the parameter type is not dependent, there is nothing to deduce.\n    if (!Param->isDependentType()) {\n      if (!(TDF & TDF_SkipNonDependent)) {\n        bool NonDeduced =\n            (TDF & TDF_AllowCompatibleFunctionType)\n                ? !S.isSameOrCompatibleFunctionType(CanParam, CanArg)\n                : Param != Arg;\n        if (NonDeduced) {\n          return Sema::TDK_NonDeducedMismatch;\n        }\n      }\n      return Sema::TDK_Success;\n    }\n  } else if (!Param->isDependentType()) {\n    if (!(TDF & TDF_SkipNonDependent)) {\n      CanQualType ParamUnqualType = CanParam.getUnqualifiedType(),\n                  ArgUnqualType = CanArg.getUnqualifiedType();\n      bool Success =\n          (TDF & TDF_AllowCompatibleFunctionType)\n              ? S.isSameOrCompatibleFunctionType(ParamUnqualType, ArgUnqualType)\n              : ParamUnqualType == ArgUnqualType;\n      if (Success)\n        return Sema::TDK_Success;\n    } else {\n      return Sema::TDK_Success;\n    }\n  }\n\n  switch (Param->getTypeClass()) {\n    // Non-canonical types cannot appear here.\n#define NON_CANONICAL_TYPE(Class, Base) \\\n  case Type::Class: llvm_unreachable(\"deducing non-canonical type: \" #Class);\n#define TYPE(Class, Base)\n#include \"clang/AST/TypeNodes.inc\"\n\n    case Type::TemplateTypeParm:\n    case Type::SubstTemplateTypeParmPack:\n      llvm_unreachable(\"Type nodes handled above\");\n\n    // These types cannot be dependent, so simply check whether the types are\n    // the same.\n    case Type::Builtin:\n    case Type::VariableArray:\n    case Type::Vector:\n    case Type::FunctionNoProto:\n    case Type::Record:\n    case Type::Enum:\n    case Type::ObjCObject:\n    case Type::ObjCInterface:\n    case Type::ObjCObjectPointer:\n    case Type::ExtInt:\n      if (TDF & TDF_SkipNonDependent)\n        return Sema::TDK_Success;\n\n      if (TDF & TDF_IgnoreQualifiers) {\n        Param = Param.getUnqualifiedType();\n        Arg = Arg.getUnqualifiedType();\n      }\n\n      return Param == Arg? Sema::TDK_Success : Sema::TDK_NonDeducedMismatch;\n\n    //     _Complex T   [placeholder extension]\n    case Type::Complex:\n      if (const ComplexType *ComplexArg = Arg->getAs<ComplexType>())\n        return DeduceTemplateArgumentsByTypeMatch(S, TemplateParams,\n                                    cast<ComplexType>(Param)->getElementType(),\n                                    ComplexArg->getElementType(),\n                                    Info, Deduced, TDF);\n\n      return Sema::TDK_NonDeducedMismatch;\n\n    //     _Atomic T   [extension]\n    case Type::Atomic:\n      if (const AtomicType *AtomicArg = Arg->getAs<AtomicType>())\n        return DeduceTemplateArgumentsByTypeMatch(S, TemplateParams,\n                                       cast<AtomicType>(Param)->getValueType(),\n                                       AtomicArg->getValueType(),\n                                       Info, Deduced, TDF);\n\n      return Sema::TDK_NonDeducedMismatch;\n\n    //     T *\n    case Type::Pointer: {\n      QualType PointeeType;\n      if (const PointerType *PointerArg = Arg->getAs<PointerType>()) {\n        PointeeType = PointerArg->getPointeeType();\n      } else if (const ObjCObjectPointerType *PointerArg\n                   = Arg->getAs<ObjCObjectPointerType>()) {\n        PointeeType = PointerArg->getPointeeType();\n      } else {\n        return Sema::TDK_NonDeducedMismatch;\n      }\n\n      unsigned SubTDF = TDF & (TDF_IgnoreQualifiers | TDF_DerivedClass);\n      return DeduceTemplateArgumentsByTypeMatch(S, TemplateParams,\n                                     cast<PointerType>(Param)->getPointeeType(),\n                                     PointeeType,\n                                     Info, Deduced, SubTDF);\n    }\n\n    //     T &\n    case Type::LValueReference: {\n      const LValueReferenceType *ReferenceArg =\n          Arg->getAs<LValueReferenceType>();\n      if (!ReferenceArg)\n        return Sema::TDK_NonDeducedMismatch;\n\n      return DeduceTemplateArgumentsByTypeMatch(S, TemplateParams,\n                           cast<LValueReferenceType>(Param)->getPointeeType(),\n                           ReferenceArg->getPointeeType(), Info, Deduced, 0);\n    }\n\n    //     T && [C++0x]\n    case Type::RValueReference: {\n      const RValueReferenceType *ReferenceArg =\n          Arg->getAs<RValueReferenceType>();\n      if (!ReferenceArg)\n        return Sema::TDK_NonDeducedMismatch;\n\n      return DeduceTemplateArgumentsByTypeMatch(S, TemplateParams,\n                             cast<RValueReferenceType>(Param)->getPointeeType(),\n                             ReferenceArg->getPointeeType(),\n                             Info, Deduced, 0);\n    }\n\n    //     T [] (implied, but not stated explicitly)\n    case Type::IncompleteArray: {\n      const IncompleteArrayType *IncompleteArrayArg =\n        S.Context.getAsIncompleteArrayType(Arg);\n      if (!IncompleteArrayArg)\n        return Sema::TDK_NonDeducedMismatch;\n\n      unsigned SubTDF = TDF & TDF_IgnoreQualifiers;\n      return DeduceTemplateArgumentsByTypeMatch(S, TemplateParams,\n                    S.Context.getAsIncompleteArrayType(Param)->getElementType(),\n                    IncompleteArrayArg->getElementType(),\n                    Info, Deduced, SubTDF);\n    }\n\n    //     T [integer-constant]\n    case Type::ConstantArray: {\n      const ConstantArrayType *ConstantArrayArg =\n        S.Context.getAsConstantArrayType(Arg);\n      if (!ConstantArrayArg)\n        return Sema::TDK_NonDeducedMismatch;\n\n      const ConstantArrayType *ConstantArrayParm =\n        S.Context.getAsConstantArrayType(Param);\n      if (ConstantArrayArg->getSize() != ConstantArrayParm->getSize())\n        return Sema::TDK_NonDeducedMismatch;\n\n      unsigned SubTDF = TDF & TDF_IgnoreQualifiers;\n      return DeduceTemplateArgumentsByTypeMatch(S, TemplateParams,\n                                           ConstantArrayParm->getElementType(),\n                                           ConstantArrayArg->getElementType(),\n                                           Info, Deduced, SubTDF);\n    }\n\n    //     type [i]\n    case Type::DependentSizedArray: {\n      const ArrayType *ArrayArg = S.Context.getAsArrayType(Arg);\n      if (!ArrayArg)\n        return Sema::TDK_NonDeducedMismatch;\n\n      unsigned SubTDF = TDF & TDF_IgnoreQualifiers;\n\n      // Check the element type of the arrays\n      const DependentSizedArrayType *DependentArrayParm\n        = S.Context.getAsDependentSizedArrayType(Param);\n      if (Sema::TemplateDeductionResult Result\n            = DeduceTemplateArgumentsByTypeMatch(S, TemplateParams,\n                                          DependentArrayParm->getElementType(),\n                                          ArrayArg->getElementType(),\n                                          Info, Deduced, SubTDF))\n        return Result;\n\n      // Determine the array bound is something we can deduce.\n      const NonTypeTemplateParmDecl *NTTP\n        = getDeducedParameterFromExpr(Info, DependentArrayParm->getSizeExpr());\n      if (!NTTP)\n        return Sema::TDK_Success;\n\n      // We can perform template argument deduction for the given non-type\n      // template parameter.\n      assert(NTTP->getDepth() == Info.getDeducedDepth() &&\n             \"saw non-type template parameter with wrong depth\");\n      if (const ConstantArrayType *ConstantArrayArg\n            = dyn_cast<ConstantArrayType>(ArrayArg)) {\n        llvm::APSInt Size(ConstantArrayArg->getSize());\n        return DeduceNonTypeTemplateArgument(S, TemplateParams, NTTP, Size,\n                                             S.Context.getSizeType(),\n                                             /*ArrayBound=*/true,\n                                             Info, Deduced);\n      }\n      if (const DependentSizedArrayType *DependentArrayArg\n            = dyn_cast<DependentSizedArrayType>(ArrayArg))\n        if (DependentArrayArg->getSizeExpr())\n          return DeduceNonTypeTemplateArgument(S, TemplateParams, NTTP,\n                                               DependentArrayArg->getSizeExpr(),\n                                               Info, Deduced);\n\n      // Incomplete type does not match a dependently-sized array type\n      return Sema::TDK_NonDeducedMismatch;\n    }\n\n    //     type(*)(T)\n    //     T(*)()\n    //     T(*)(T)\n    case Type::FunctionProto: {\n      unsigned SubTDF = TDF & TDF_TopLevelParameterTypeList;\n      const FunctionProtoType *FunctionProtoArg =\n        dyn_cast<FunctionProtoType>(Arg);\n      if (!FunctionProtoArg)\n        return Sema::TDK_NonDeducedMismatch;\n\n      const FunctionProtoType *FunctionProtoParam =\n        cast<FunctionProtoType>(Param);\n\n      if (FunctionProtoParam->getMethodQuals()\n            != FunctionProtoArg->getMethodQuals() ||\n          FunctionProtoParam->getRefQualifier()\n            != FunctionProtoArg->getRefQualifier() ||\n          FunctionProtoParam->isVariadic() != FunctionProtoArg->isVariadic())\n        return Sema::TDK_NonDeducedMismatch;\n\n      // Check return types.\n      if (auto Result = DeduceTemplateArgumentsByTypeMatch(\n              S, TemplateParams, FunctionProtoParam->getReturnType(),\n              FunctionProtoArg->getReturnType(), Info, Deduced, 0))\n        return Result;\n\n      // Check parameter types.\n      if (auto Result = DeduceTemplateArguments(\n              S, TemplateParams, FunctionProtoParam->param_type_begin(),\n              FunctionProtoParam->getNumParams(),\n              FunctionProtoArg->param_type_begin(),\n              FunctionProtoArg->getNumParams(), Info, Deduced, SubTDF))\n        return Result;\n\n      if (TDF & TDF_AllowCompatibleFunctionType)\n        return Sema::TDK_Success;\n\n      // FIXME: Per core-2016/10/1019 (no corresponding core issue yet), permit\n      // deducing through the noexcept-specifier if it's part of the canonical\n      // type. libstdc++ relies on this.\n      Expr *NoexceptExpr = FunctionProtoParam->getNoexceptExpr();\n      if (const NonTypeTemplateParmDecl *NTTP =\n          NoexceptExpr ? getDeducedParameterFromExpr(Info, NoexceptExpr)\n                       : nullptr) {\n        assert(NTTP->getDepth() == Info.getDeducedDepth() &&\n               \"saw non-type template parameter with wrong depth\");\n\n        llvm::APSInt Noexcept(1);\n        switch (FunctionProtoArg->canThrow()) {\n        case CT_Cannot:\n          Noexcept = 1;\n          LLVM_FALLTHROUGH;\n\n        case CT_Can:\n          // We give E in noexcept(E) the \"deduced from array bound\" treatment.\n          // FIXME: Should we?\n          return DeduceNonTypeTemplateArgument(\n              S, TemplateParams, NTTP, Noexcept, S.Context.BoolTy,\n              /*ArrayBound*/true, Info, Deduced);\n\n        case CT_Dependent:\n          if (Expr *ArgNoexceptExpr = FunctionProtoArg->getNoexceptExpr())\n            return DeduceNonTypeTemplateArgument(\n                S, TemplateParams, NTTP, ArgNoexceptExpr, Info, Deduced);\n          // Can't deduce anything from throw(T...).\n          break;\n        }\n      }\n      // FIXME: Detect non-deduced exception specification mismatches?\n      //\n      // Careful about [temp.deduct.call] and [temp.deduct.conv], which allow\n      // top-level differences in noexcept-specifications.\n\n      return Sema::TDK_Success;\n    }\n\n    case Type::InjectedClassName:\n      // Treat a template's injected-class-name as if the template\n      // specialization type had been used.\n      Param = cast<InjectedClassNameType>(Param)\n        ->getInjectedSpecializationType();\n      assert(isa<TemplateSpecializationType>(Param) &&\n             \"injected class name is not a template specialization type\");\n      LLVM_FALLTHROUGH;\n\n    //     template-name<T> (where template-name refers to a class template)\n    //     template-name<i>\n    //     TT<T>\n    //     TT<i>\n    //     TT<>\n    case Type::TemplateSpecialization: {\n      const TemplateSpecializationType *SpecParam =\n          cast<TemplateSpecializationType>(Param);\n\n      // When Arg cannot be a derived class, we can just try to deduce template\n      // arguments from the template-id.\n      const RecordType *RecordT = Arg->getAs<RecordType>();\n      if (!(TDF & TDF_DerivedClass) || !RecordT)\n        return DeduceTemplateArguments(S, TemplateParams, SpecParam, Arg, Info,\n                                       Deduced);\n\n      SmallVector<DeducedTemplateArgument, 8> DeducedOrig(Deduced.begin(),\n                                                          Deduced.end());\n\n      Sema::TemplateDeductionResult Result = DeduceTemplateArguments(\n          S, TemplateParams, SpecParam, Arg, Info, Deduced);\n\n      if (Result == Sema::TDK_Success)\n        return Result;\n\n      // We cannot inspect base classes as part of deduction when the type\n      // is incomplete, so either instantiate any templates necessary to\n      // complete the type, or skip over it if it cannot be completed.\n      if (!S.isCompleteType(Info.getLocation(), Arg))\n        return Result;\n\n      // Reset the incorrectly deduced argument from above.\n      Deduced = DeducedOrig;\n\n      // Check bases according to C++14 [temp.deduct.call] p4b3:\n      Sema::TemplateDeductionResult BaseResult = DeduceTemplateBases(\n          S, RecordT, TemplateParams, SpecParam, Info, Deduced);\n\n      if (BaseResult != Sema::TDK_Invalid)\n        return BaseResult;\n      return Result;\n    }\n\n    //     T type::*\n    //     T T::*\n    //     T (type::*)()\n    //     type (T::*)()\n    //     type (type::*)(T)\n    //     type (T::*)(T)\n    //     T (type::*)(T)\n    //     T (T::*)()\n    //     T (T::*)(T)\n    case Type::MemberPointer: {\n      const MemberPointerType *MemPtrParam = cast<MemberPointerType>(Param);\n      const MemberPointerType *MemPtrArg = dyn_cast<MemberPointerType>(Arg);\n      if (!MemPtrArg)\n        return Sema::TDK_NonDeducedMismatch;\n\n      QualType ParamPointeeType = MemPtrParam->getPointeeType();\n      if (ParamPointeeType->isFunctionType())\n        S.adjustMemberFunctionCC(ParamPointeeType, /*IsStatic=*/true,\n                                 /*IsCtorOrDtor=*/false, Info.getLocation());\n      QualType ArgPointeeType = MemPtrArg->getPointeeType();\n      if (ArgPointeeType->isFunctionType())\n        S.adjustMemberFunctionCC(ArgPointeeType, /*IsStatic=*/true,\n                                 /*IsCtorOrDtor=*/false, Info.getLocation());\n\n      if (Sema::TemplateDeductionResult Result\n            = DeduceTemplateArgumentsByTypeMatch(S, TemplateParams,\n                                                 ParamPointeeType,\n                                                 ArgPointeeType,\n                                                 Info, Deduced,\n                                                 TDF & TDF_IgnoreQualifiers))\n        return Result;\n\n      return DeduceTemplateArgumentsByTypeMatch(S, TemplateParams,\n                                           QualType(MemPtrParam->getClass(), 0),\n                                           QualType(MemPtrArg->getClass(), 0),\n                                           Info, Deduced,\n                                           TDF & TDF_IgnoreQualifiers);\n    }\n\n    //     (clang extension)\n    //\n    //     type(^)(T)\n    //     T(^)()\n    //     T(^)(T)\n    case Type::BlockPointer: {\n      const BlockPointerType *BlockPtrParam = cast<BlockPointerType>(Param);\n      const BlockPointerType *BlockPtrArg = dyn_cast<BlockPointerType>(Arg);\n\n      if (!BlockPtrArg)\n        return Sema::TDK_NonDeducedMismatch;\n\n      return DeduceTemplateArgumentsByTypeMatch(S, TemplateParams,\n                                                BlockPtrParam->getPointeeType(),\n                                                BlockPtrArg->getPointeeType(),\n                                                Info, Deduced, 0);\n    }\n\n    //     (clang extension)\n    //\n    //     T __attribute__(((ext_vector_type(<integral constant>))))\n    case Type::ExtVector: {\n      const ExtVectorType *VectorParam = cast<ExtVectorType>(Param);\n      if (const ExtVectorType *VectorArg = dyn_cast<ExtVectorType>(Arg)) {\n        // Make sure that the vectors have the same number of elements.\n        if (VectorParam->getNumElements() != VectorArg->getNumElements())\n          return Sema::TDK_NonDeducedMismatch;\n\n        // Perform deduction on the element types.\n        return DeduceTemplateArgumentsByTypeMatch(S, TemplateParams,\n                                                  VectorParam->getElementType(),\n                                                  VectorArg->getElementType(),\n                                                  Info, Deduced, TDF);\n      }\n\n      if (const DependentSizedExtVectorType *VectorArg\n                                = dyn_cast<DependentSizedExtVectorType>(Arg)) {\n        // We can't check the number of elements, since the argument has a\n        // dependent number of elements. This can only occur during partial\n        // ordering.\n\n        // Perform deduction on the element types.\n        return DeduceTemplateArgumentsByTypeMatch(S, TemplateParams,\n                                                  VectorParam->getElementType(),\n                                                  VectorArg->getElementType(),\n                                                  Info, Deduced, TDF);\n      }\n\n      return Sema::TDK_NonDeducedMismatch;\n    }\n\n    case Type::DependentVector: {\n      const auto *VectorParam = cast<DependentVectorType>(Param);\n\n      if (const auto *VectorArg = dyn_cast<VectorType>(Arg)) {\n        // Perform deduction on the element types.\n        if (Sema::TemplateDeductionResult Result =\n                DeduceTemplateArgumentsByTypeMatch(\n                    S, TemplateParams, VectorParam->getElementType(),\n                    VectorArg->getElementType(), Info, Deduced, TDF))\n          return Result;\n\n        // Perform deduction on the vector size, if we can.\n        const NonTypeTemplateParmDecl *NTTP =\n            getDeducedParameterFromExpr(Info, VectorParam->getSizeExpr());\n        if (!NTTP)\n          return Sema::TDK_Success;\n\n        llvm::APSInt ArgSize(S.Context.getTypeSize(S.Context.IntTy), false);\n        ArgSize = VectorArg->getNumElements();\n        // Note that we use the \"array bound\" rules here; just like in that\n        // case, we don't have any particular type for the vector size, but\n        // we can provide one if necessary.\n        return DeduceNonTypeTemplateArgument(S, TemplateParams, NTTP, ArgSize,\n                                             S.Context.UnsignedIntTy, true,\n                                             Info, Deduced);\n      }\n\n      if (const auto *VectorArg = dyn_cast<DependentVectorType>(Arg)) {\n        // Perform deduction on the element types.\n        if (Sema::TemplateDeductionResult Result =\n                DeduceTemplateArgumentsByTypeMatch(\n                    S, TemplateParams, VectorParam->getElementType(),\n                    VectorArg->getElementType(), Info, Deduced, TDF))\n          return Result;\n\n        // Perform deduction on the vector size, if we can.\n        const NonTypeTemplateParmDecl *NTTP = getDeducedParameterFromExpr(\n            Info, VectorParam->getSizeExpr());\n        if (!NTTP)\n          return Sema::TDK_Success;\n\n        return DeduceNonTypeTemplateArgument(\n            S, TemplateParams, NTTP, VectorArg->getSizeExpr(), Info, Deduced);\n      }\n\n      return Sema::TDK_NonDeducedMismatch;\n    }\n\n    //     (clang extension)\n    //\n    //     T __attribute__(((ext_vector_type(N))))\n    case Type::DependentSizedExtVector: {\n      const DependentSizedExtVectorType *VectorParam\n        = cast<DependentSizedExtVectorType>(Param);\n\n      if (const ExtVectorType *VectorArg = dyn_cast<ExtVectorType>(Arg)) {\n        // Perform deduction on the element types.\n        if (Sema::TemplateDeductionResult Result\n              = DeduceTemplateArgumentsByTypeMatch(S, TemplateParams,\n                                                  VectorParam->getElementType(),\n                                                   VectorArg->getElementType(),\n                                                   Info, Deduced, TDF))\n          return Result;\n\n        // Perform deduction on the vector size, if we can.\n        const NonTypeTemplateParmDecl *NTTP =\n            getDeducedParameterFromExpr(Info, VectorParam->getSizeExpr());\n        if (!NTTP)\n          return Sema::TDK_Success;\n\n        llvm::APSInt ArgSize(S.Context.getTypeSize(S.Context.IntTy), false);\n        ArgSize = VectorArg->getNumElements();\n        // Note that we use the \"array bound\" rules here; just like in that\n        // case, we don't have any particular type for the vector size, but\n        // we can provide one if necessary.\n        return DeduceNonTypeTemplateArgument(S, TemplateParams, NTTP, ArgSize,\n                                             S.Context.IntTy, true, Info,\n                                             Deduced);\n      }\n\n      if (const DependentSizedExtVectorType *VectorArg\n                                = dyn_cast<DependentSizedExtVectorType>(Arg)) {\n        // Perform deduction on the element types.\n        if (Sema::TemplateDeductionResult Result\n            = DeduceTemplateArgumentsByTypeMatch(S, TemplateParams,\n                                                 VectorParam->getElementType(),\n                                                 VectorArg->getElementType(),\n                                                 Info, Deduced, TDF))\n          return Result;\n\n        // Perform deduction on the vector size, if we can.\n        const NonTypeTemplateParmDecl *NTTP =\n            getDeducedParameterFromExpr(Info, VectorParam->getSizeExpr());\n        if (!NTTP)\n          return Sema::TDK_Success;\n\n        return DeduceNonTypeTemplateArgument(S, TemplateParams, NTTP,\n                                             VectorArg->getSizeExpr(),\n                                             Info, Deduced);\n      }\n\n      return Sema::TDK_NonDeducedMismatch;\n    }\n\n    //     (clang extension)\n    //\n    //     T __attribute__((matrix_type(<integral constant>,\n    //                                  <integral constant>)))\n    case Type::ConstantMatrix: {\n      const ConstantMatrixType *MatrixArg = dyn_cast<ConstantMatrixType>(Arg);\n      if (!MatrixArg)\n        return Sema::TDK_NonDeducedMismatch;\n\n      const ConstantMatrixType *MatrixParam = cast<ConstantMatrixType>(Param);\n      // Check that the dimensions are the same\n      if (MatrixParam->getNumRows() != MatrixArg->getNumRows() ||\n          MatrixParam->getNumColumns() != MatrixArg->getNumColumns()) {\n        return Sema::TDK_NonDeducedMismatch;\n      }\n      // Perform deduction on element types.\n      return DeduceTemplateArgumentsByTypeMatch(\n          S, TemplateParams, MatrixParam->getElementType(),\n          MatrixArg->getElementType(), Info, Deduced, TDF);\n    }\n\n    case Type::DependentSizedMatrix: {\n      const MatrixType *MatrixArg = dyn_cast<MatrixType>(Arg);\n      if (!MatrixArg)\n        return Sema::TDK_NonDeducedMismatch;\n\n      // Check the element type of the matrixes.\n      const DependentSizedMatrixType *MatrixParam =\n          cast<DependentSizedMatrixType>(Param);\n      if (Sema::TemplateDeductionResult Result =\n              DeduceTemplateArgumentsByTypeMatch(\n                  S, TemplateParams, MatrixParam->getElementType(),\n                  MatrixArg->getElementType(), Info, Deduced, TDF))\n        return Result;\n\n      // Try to deduce a matrix dimension.\n      auto DeduceMatrixArg =\n          [&S, &Info, &Deduced, &TemplateParams](\n              Expr *ParamExpr, const MatrixType *Arg,\n              unsigned (ConstantMatrixType::*GetArgDimension)() const,\n              Expr *(DependentSizedMatrixType::*GetArgDimensionExpr)() const) {\n            const auto *ArgConstMatrix = dyn_cast<ConstantMatrixType>(Arg);\n            const auto *ArgDepMatrix = dyn_cast<DependentSizedMatrixType>(Arg);\n            if (!ParamExpr->isValueDependent()) {\n              Optional<llvm::APSInt> ParamConst =\n                  ParamExpr->getIntegerConstantExpr(S.Context);\n              if (!ParamConst)\n                return Sema::TDK_NonDeducedMismatch;\n\n              if (ArgConstMatrix) {\n                if ((ArgConstMatrix->*GetArgDimension)() == *ParamConst)\n                  return Sema::TDK_Success;\n                return Sema::TDK_NonDeducedMismatch;\n              }\n\n              Expr *ArgExpr = (ArgDepMatrix->*GetArgDimensionExpr)();\n              if (!ArgExpr->isValueDependent())\n                if (Optional<llvm::APSInt> ArgConst =\n                        ArgExpr->getIntegerConstantExpr(S.Context))\n                  if (*ArgConst == *ParamConst)\n                    return Sema::TDK_Success;\n              return Sema::TDK_NonDeducedMismatch;\n            }\n\n            const NonTypeTemplateParmDecl *NTTP =\n                getDeducedParameterFromExpr(Info, ParamExpr);\n            if (!NTTP)\n              return Sema::TDK_Success;\n\n            if (ArgConstMatrix) {\n              llvm::APSInt ArgConst(\n                  S.Context.getTypeSize(S.Context.getSizeType()));\n              ArgConst = (ArgConstMatrix->*GetArgDimension)();\n              return DeduceNonTypeTemplateArgument(\n                  S, TemplateParams, NTTP, ArgConst, S.Context.getSizeType(),\n                  /*ArrayBound=*/true, Info, Deduced);\n            }\n\n            return DeduceNonTypeTemplateArgument(\n                S, TemplateParams, NTTP, (ArgDepMatrix->*GetArgDimensionExpr)(),\n                Info, Deduced);\n          };\n\n      auto Result = DeduceMatrixArg(MatrixParam->getRowExpr(), MatrixArg,\n                                    &ConstantMatrixType::getNumRows,\n                                    &DependentSizedMatrixType::getRowExpr);\n      if (Result)\n        return Result;\n\n      return DeduceMatrixArg(MatrixParam->getColumnExpr(), MatrixArg,\n                             &ConstantMatrixType::getNumColumns,\n                             &DependentSizedMatrixType::getColumnExpr);\n    }\n\n    //     (clang extension)\n    //\n    //     T __attribute__(((address_space(N))))\n    case Type::DependentAddressSpace: {\n      const DependentAddressSpaceType *AddressSpaceParam =\n          cast<DependentAddressSpaceType>(Param);\n\n      if (const DependentAddressSpaceType *AddressSpaceArg =\n              dyn_cast<DependentAddressSpaceType>(Arg)) {\n        // Perform deduction on the pointer type.\n        if (Sema::TemplateDeductionResult Result =\n                DeduceTemplateArgumentsByTypeMatch(\n                    S, TemplateParams, AddressSpaceParam->getPointeeType(),\n                    AddressSpaceArg->getPointeeType(), Info, Deduced, TDF))\n          return Result;\n\n        // Perform deduction on the address space, if we can.\n        const NonTypeTemplateParmDecl *NTTP = getDeducedParameterFromExpr(\n            Info, AddressSpaceParam->getAddrSpaceExpr());\n        if (!NTTP)\n          return Sema::TDK_Success;\n\n        return DeduceNonTypeTemplateArgument(\n            S, TemplateParams, NTTP, AddressSpaceArg->getAddrSpaceExpr(), Info,\n            Deduced);\n      }\n\n      if (isTargetAddressSpace(Arg.getAddressSpace())) {\n        llvm::APSInt ArgAddressSpace(S.Context.getTypeSize(S.Context.IntTy),\n                                     false);\n        ArgAddressSpace = toTargetAddressSpace(Arg.getAddressSpace());\n\n        // Perform deduction on the pointer types.\n        if (Sema::TemplateDeductionResult Result =\n                DeduceTemplateArgumentsByTypeMatch(\n                    S, TemplateParams, AddressSpaceParam->getPointeeType(),\n                    S.Context.removeAddrSpaceQualType(Arg), Info, Deduced, TDF))\n          return Result;\n\n        // Perform deduction on the address space, if we can.\n        const NonTypeTemplateParmDecl *NTTP = getDeducedParameterFromExpr(\n            Info, AddressSpaceParam->getAddrSpaceExpr());\n        if (!NTTP)\n          return Sema::TDK_Success;\n\n        return DeduceNonTypeTemplateArgument(S, TemplateParams, NTTP,\n                                             ArgAddressSpace, S.Context.IntTy,\n                                             true, Info, Deduced);\n      }\n\n      return Sema::TDK_NonDeducedMismatch;\n    }\n    case Type::DependentExtInt: {\n      const auto *IntParam = cast<DependentExtIntType>(Param);\n\n      if (const auto *IntArg = dyn_cast<ExtIntType>(Arg)){\n        if (IntParam->isUnsigned() != IntArg->isUnsigned())\n          return Sema::TDK_NonDeducedMismatch;\n\n        const NonTypeTemplateParmDecl *NTTP =\n            getDeducedParameterFromExpr(Info, IntParam->getNumBitsExpr());\n        if (!NTTP)\n          return Sema::TDK_Success;\n\n        llvm::APSInt ArgSize(S.Context.getTypeSize(S.Context.IntTy), false);\n        ArgSize = IntArg->getNumBits();\n\n        return DeduceNonTypeTemplateArgument(S, TemplateParams, NTTP, ArgSize,\n                                             S.Context.IntTy, true, Info,\n                                             Deduced);\n      }\n\n      if (const auto *IntArg = dyn_cast<DependentExtIntType>(Arg)) {\n        if (IntParam->isUnsigned() != IntArg->isUnsigned())\n          return Sema::TDK_NonDeducedMismatch;\n        return Sema::TDK_Success;\n      }\n      return Sema::TDK_NonDeducedMismatch;\n    }\n\n    case Type::TypeOfExpr:\n    case Type::TypeOf:\n    case Type::DependentName:\n    case Type::UnresolvedUsing:\n    case Type::Decltype:\n    case Type::UnaryTransform:\n    case Type::Auto:\n    case Type::DeducedTemplateSpecialization:\n    case Type::DependentTemplateSpecialization:\n    case Type::PackExpansion:\n    case Type::Pipe:\n      // No template argument deduction for these types\n      return Sema::TDK_Success;\n  }\n\n  llvm_unreachable(\"Invalid Type Class!\");\n}\n\nstatic Sema::TemplateDeductionResult\nDeduceTemplateArguments(Sema &S,\n                        TemplateParameterList *TemplateParams,\n                        const TemplateArgument &Param,\n                        TemplateArgument Arg,\n                        TemplateDeductionInfo &Info,\n                        SmallVectorImpl<DeducedTemplateArgument> &Deduced) {\n  // If the template argument is a pack expansion, perform template argument\n  // deduction against the pattern of that expansion. This only occurs during\n  // partial ordering.\n  if (Arg.isPackExpansion())\n    Arg = Arg.getPackExpansionPattern();\n\n  switch (Param.getKind()) {\n  case TemplateArgument::Null:\n    llvm_unreachable(\"Null template argument in parameter list\");\n\n  case TemplateArgument::Type:\n    if (Arg.getKind() == TemplateArgument::Type)\n      return DeduceTemplateArgumentsByTypeMatch(S, TemplateParams,\n                                                Param.getAsType(),\n                                                Arg.getAsType(),\n                                                Info, Deduced, 0);\n    Info.FirstArg = Param;\n    Info.SecondArg = Arg;\n    return Sema::TDK_NonDeducedMismatch;\n\n  case TemplateArgument::Template:\n    if (Arg.getKind() == TemplateArgument::Template)\n      return DeduceTemplateArguments(S, TemplateParams,\n                                     Param.getAsTemplate(),\n                                     Arg.getAsTemplate(), Info, Deduced);\n    Info.FirstArg = Param;\n    Info.SecondArg = Arg;\n    return Sema::TDK_NonDeducedMismatch;\n\n  case TemplateArgument::TemplateExpansion:\n    llvm_unreachable(\"caller should handle pack expansions\");\n\n  case TemplateArgument::Declaration:\n    if (Arg.getKind() == TemplateArgument::Declaration &&\n        isSameDeclaration(Param.getAsDecl(), Arg.getAsDecl()))\n      return Sema::TDK_Success;\n\n    Info.FirstArg = Param;\n    Info.SecondArg = Arg;\n    return Sema::TDK_NonDeducedMismatch;\n\n  case TemplateArgument::NullPtr:\n    if (Arg.getKind() == TemplateArgument::NullPtr &&\n        S.Context.hasSameType(Param.getNullPtrType(), Arg.getNullPtrType()))\n      return Sema::TDK_Success;\n\n    Info.FirstArg = Param;\n    Info.SecondArg = Arg;\n    return Sema::TDK_NonDeducedMismatch;\n\n  case TemplateArgument::Integral:\n    if (Arg.getKind() == TemplateArgument::Integral) {\n      if (hasSameExtendedValue(Param.getAsIntegral(), Arg.getAsIntegral()))\n        return Sema::TDK_Success;\n\n      Info.FirstArg = Param;\n      Info.SecondArg = Arg;\n      return Sema::TDK_NonDeducedMismatch;\n    }\n\n    if (Arg.getKind() == TemplateArgument::Expression) {\n      Info.FirstArg = Param;\n      Info.SecondArg = Arg;\n      return Sema::TDK_NonDeducedMismatch;\n    }\n\n    Info.FirstArg = Param;\n    Info.SecondArg = Arg;\n    return Sema::TDK_NonDeducedMismatch;\n\n  case TemplateArgument::Expression:\n    if (const NonTypeTemplateParmDecl *NTTP =\n            getDeducedParameterFromExpr(Info, Param.getAsExpr())) {\n      if (Arg.getKind() == TemplateArgument::Integral)\n        return DeduceNonTypeTemplateArgument(S, TemplateParams, NTTP,\n                                             Arg.getAsIntegral(),\n                                             Arg.getIntegralType(),\n                                             /*ArrayBound=*/false,\n                                             Info, Deduced);\n      if (Arg.getKind() == TemplateArgument::NullPtr)\n        return DeduceNullPtrTemplateArgument(S, TemplateParams, NTTP,\n                                             Arg.getNullPtrType(),\n                                             Info, Deduced);\n      if (Arg.getKind() == TemplateArgument::Expression)\n        return DeduceNonTypeTemplateArgument(S, TemplateParams, NTTP,\n                                             Arg.getAsExpr(), Info, Deduced);\n      if (Arg.getKind() == TemplateArgument::Declaration)\n        return DeduceNonTypeTemplateArgument(S, TemplateParams, NTTP,\n                                             Arg.getAsDecl(),\n                                             Arg.getParamTypeForDecl(),\n                                             Info, Deduced);\n\n      Info.FirstArg = Param;\n      Info.SecondArg = Arg;\n      return Sema::TDK_NonDeducedMismatch;\n    }\n\n    // Can't deduce anything, but that's okay.\n    return Sema::TDK_Success;\n\n  case TemplateArgument::Pack:\n    llvm_unreachable(\"Argument packs should be expanded by the caller!\");\n  }\n\n  llvm_unreachable(\"Invalid TemplateArgument Kind!\");\n}\n\n/// Determine whether there is a template argument to be used for\n/// deduction.\n///\n/// This routine \"expands\" argument packs in-place, overriding its input\n/// parameters so that \\c Args[ArgIdx] will be the available template argument.\n///\n/// \\returns true if there is another template argument (which will be at\n/// \\c Args[ArgIdx]), false otherwise.\nstatic bool hasTemplateArgumentForDeduction(ArrayRef<TemplateArgument> &Args,\n                                            unsigned &ArgIdx) {\n  if (ArgIdx == Args.size())\n    return false;\n\n  const TemplateArgument &Arg = Args[ArgIdx];\n  if (Arg.getKind() != TemplateArgument::Pack)\n    return true;\n\n  assert(ArgIdx == Args.size() - 1 && \"Pack not at the end of argument list?\");\n  Args = Arg.pack_elements();\n  ArgIdx = 0;\n  return ArgIdx < Args.size();\n}\n\n/// Determine whether the given set of template arguments has a pack\n/// expansion that is not the last template argument.\nstatic bool hasPackExpansionBeforeEnd(ArrayRef<TemplateArgument> Args) {\n  bool FoundPackExpansion = false;\n  for (const auto &A : Args) {\n    if (FoundPackExpansion)\n      return true;\n\n    if (A.getKind() == TemplateArgument::Pack)\n      return hasPackExpansionBeforeEnd(A.pack_elements());\n\n    // FIXME: If this is a fixed-arity pack expansion from an outer level of\n    // templates, it should not be treated as a pack expansion.\n    if (A.isPackExpansion())\n      FoundPackExpansion = true;\n  }\n\n  return false;\n}\n\nstatic Sema::TemplateDeductionResult\nDeduceTemplateArguments(Sema &S, TemplateParameterList *TemplateParams,\n                        ArrayRef<TemplateArgument> Params,\n                        ArrayRef<TemplateArgument> Args,\n                        TemplateDeductionInfo &Info,\n                        SmallVectorImpl<DeducedTemplateArgument> &Deduced,\n                        bool NumberOfArgumentsMustMatch) {\n  // C++0x [temp.deduct.type]p9:\n  //   If the template argument list of P contains a pack expansion that is not\n  //   the last template argument, the entire template argument list is a\n  //   non-deduced context.\n  if (hasPackExpansionBeforeEnd(Params))\n    return Sema::TDK_Success;\n\n  // C++0x [temp.deduct.type]p9:\n  //   If P has a form that contains <T> or <i>, then each argument Pi of the\n  //   respective template argument list P is compared with the corresponding\n  //   argument Ai of the corresponding template argument list of A.\n  unsigned ArgIdx = 0, ParamIdx = 0;\n  for (; hasTemplateArgumentForDeduction(Params, ParamIdx); ++ParamIdx) {\n    if (!Params[ParamIdx].isPackExpansion()) {\n      // The simple case: deduce template arguments by matching Pi and Ai.\n\n      // Check whether we have enough arguments.\n      if (!hasTemplateArgumentForDeduction(Args, ArgIdx))\n        return NumberOfArgumentsMustMatch\n                   ? Sema::TDK_MiscellaneousDeductionFailure\n                   : Sema::TDK_Success;\n\n      // C++1z [temp.deduct.type]p9:\n      //   During partial ordering, if Ai was originally a pack expansion [and]\n      //   Pi is not a pack expansion, template argument deduction fails.\n      if (Args[ArgIdx].isPackExpansion())\n        return Sema::TDK_MiscellaneousDeductionFailure;\n\n      // Perform deduction for this Pi/Ai pair.\n      if (Sema::TemplateDeductionResult Result\n            = DeduceTemplateArguments(S, TemplateParams,\n                                      Params[ParamIdx], Args[ArgIdx],\n                                      Info, Deduced))\n        return Result;\n\n      // Move to the next argument.\n      ++ArgIdx;\n      continue;\n    }\n\n    // The parameter is a pack expansion.\n\n    // C++0x [temp.deduct.type]p9:\n    //   If Pi is a pack expansion, then the pattern of Pi is compared with\n    //   each remaining argument in the template argument list of A. Each\n    //   comparison deduces template arguments for subsequent positions in the\n    //   template parameter packs expanded by Pi.\n    TemplateArgument Pattern = Params[ParamIdx].getPackExpansionPattern();\n\n    // Prepare to deduce the packs within the pattern.\n    PackDeductionScope PackScope(S, TemplateParams, Deduced, Info, Pattern);\n\n    // Keep track of the deduced template arguments for each parameter pack\n    // expanded by this pack expansion (the outer index) and for each\n    // template argument (the inner SmallVectors).\n    for (; hasTemplateArgumentForDeduction(Args, ArgIdx) &&\n           PackScope.hasNextElement();\n         ++ArgIdx) {\n      // Deduce template arguments from the pattern.\n      if (Sema::TemplateDeductionResult Result\n            = DeduceTemplateArguments(S, TemplateParams, Pattern, Args[ArgIdx],\n                                      Info, Deduced))\n        return Result;\n\n      PackScope.nextPackElement();\n    }\n\n    // Build argument packs for each of the parameter packs expanded by this\n    // pack expansion.\n    if (auto Result = PackScope.finish())\n      return Result;\n  }\n\n  return Sema::TDK_Success;\n}\n\nstatic Sema::TemplateDeductionResult\nDeduceTemplateArguments(Sema &S,\n                        TemplateParameterList *TemplateParams,\n                        const TemplateArgumentList &ParamList,\n                        const TemplateArgumentList &ArgList,\n                        TemplateDeductionInfo &Info,\n                        SmallVectorImpl<DeducedTemplateArgument> &Deduced) {\n  return DeduceTemplateArguments(S, TemplateParams, ParamList.asArray(),\n                                 ArgList.asArray(), Info, Deduced,\n                                 /*NumberOfArgumentsMustMatch*/false);\n}\n\n/// Determine whether two template arguments are the same.\nstatic bool isSameTemplateArg(ASTContext &Context,\n                              TemplateArgument X,\n                              const TemplateArgument &Y,\n                              bool PackExpansionMatchesPack = false) {\n  // If we're checking deduced arguments (X) against original arguments (Y),\n  // we will have flattened packs to non-expansions in X.\n  if (PackExpansionMatchesPack && X.isPackExpansion() && !Y.isPackExpansion())\n    X = X.getPackExpansionPattern();\n\n  if (X.getKind() != Y.getKind())\n    return false;\n\n  switch (X.getKind()) {\n    case TemplateArgument::Null:\n      llvm_unreachable(\"Comparing NULL template argument\");\n\n    case TemplateArgument::Type:\n      return Context.getCanonicalType(X.getAsType()) ==\n             Context.getCanonicalType(Y.getAsType());\n\n    case TemplateArgument::Declaration:\n      return isSameDeclaration(X.getAsDecl(), Y.getAsDecl());\n\n    case TemplateArgument::NullPtr:\n      return Context.hasSameType(X.getNullPtrType(), Y.getNullPtrType());\n\n    case TemplateArgument::Template:\n    case TemplateArgument::TemplateExpansion:\n      return Context.getCanonicalTemplateName(\n                    X.getAsTemplateOrTemplatePattern()).getAsVoidPointer() ==\n             Context.getCanonicalTemplateName(\n                    Y.getAsTemplateOrTemplatePattern()).getAsVoidPointer();\n\n    case TemplateArgument::Integral:\n      return hasSameExtendedValue(X.getAsIntegral(), Y.getAsIntegral());\n\n    case TemplateArgument::Expression: {\n      llvm::FoldingSetNodeID XID, YID;\n      X.getAsExpr()->Profile(XID, Context, true);\n      Y.getAsExpr()->Profile(YID, Context, true);\n      return XID == YID;\n    }\n\n    case TemplateArgument::Pack:\n      if (X.pack_size() != Y.pack_size())\n        return false;\n\n      for (TemplateArgument::pack_iterator XP = X.pack_begin(),\n                                        XPEnd = X.pack_end(),\n                                           YP = Y.pack_begin();\n           XP != XPEnd; ++XP, ++YP)\n        if (!isSameTemplateArg(Context, *XP, *YP, PackExpansionMatchesPack))\n          return false;\n\n      return true;\n  }\n\n  llvm_unreachable(\"Invalid TemplateArgument Kind!\");\n}\n\n/// Allocate a TemplateArgumentLoc where all locations have\n/// been initialized to the given location.\n///\n/// \\param Arg The template argument we are producing template argument\n/// location information for.\n///\n/// \\param NTTPType For a declaration template argument, the type of\n/// the non-type template parameter that corresponds to this template\n/// argument. Can be null if no type sugar is available to add to the\n/// type from the template argument.\n///\n/// \\param Loc The source location to use for the resulting template\n/// argument.\nTemplateArgumentLoc\nSema::getTrivialTemplateArgumentLoc(const TemplateArgument &Arg,\n                                    QualType NTTPType, SourceLocation Loc) {\n  switch (Arg.getKind()) {\n  case TemplateArgument::Null:\n    llvm_unreachable(\"Can't get a NULL template argument here\");\n\n  case TemplateArgument::Type:\n    return TemplateArgumentLoc(\n        Arg, Context.getTrivialTypeSourceInfo(Arg.getAsType(), Loc));\n\n  case TemplateArgument::Declaration: {\n    if (NTTPType.isNull())\n      NTTPType = Arg.getParamTypeForDecl();\n    Expr *E = BuildExpressionFromDeclTemplateArgument(Arg, NTTPType, Loc)\n                  .getAs<Expr>();\n    return TemplateArgumentLoc(TemplateArgument(E), E);\n  }\n\n  case TemplateArgument::NullPtr: {\n    if (NTTPType.isNull())\n      NTTPType = Arg.getNullPtrType();\n    Expr *E = BuildExpressionFromDeclTemplateArgument(Arg, NTTPType, Loc)\n                  .getAs<Expr>();\n    return TemplateArgumentLoc(TemplateArgument(NTTPType, /*isNullPtr*/true),\n                               E);\n  }\n\n  case TemplateArgument::Integral: {\n    Expr *E =\n        BuildExpressionFromIntegralTemplateArgument(Arg, Loc).getAs<Expr>();\n    return TemplateArgumentLoc(TemplateArgument(E), E);\n  }\n\n    case TemplateArgument::Template:\n    case TemplateArgument::TemplateExpansion: {\n      NestedNameSpecifierLocBuilder Builder;\n      TemplateName Template = Arg.getAsTemplateOrTemplatePattern();\n      if (DependentTemplateName *DTN = Template.getAsDependentTemplateName())\n        Builder.MakeTrivial(Context, DTN->getQualifier(), Loc);\n      else if (QualifiedTemplateName *QTN =\n                   Template.getAsQualifiedTemplateName())\n        Builder.MakeTrivial(Context, QTN->getQualifier(), Loc);\n\n      if (Arg.getKind() == TemplateArgument::Template)\n        return TemplateArgumentLoc(Context, Arg,\n                                   Builder.getWithLocInContext(Context), Loc);\n\n      return TemplateArgumentLoc(\n          Context, Arg, Builder.getWithLocInContext(Context), Loc, Loc);\n    }\n\n  case TemplateArgument::Expression:\n    return TemplateArgumentLoc(Arg, Arg.getAsExpr());\n\n  case TemplateArgument::Pack:\n    return TemplateArgumentLoc(Arg, TemplateArgumentLocInfo());\n  }\n\n  llvm_unreachable(\"Invalid TemplateArgument Kind!\");\n}\n\nTemplateArgumentLoc\nSema::getIdentityTemplateArgumentLoc(NamedDecl *TemplateParm,\n                                     SourceLocation Location) {\n  return getTrivialTemplateArgumentLoc(\n      Context.getInjectedTemplateArg(TemplateParm), QualType(), Location);\n}\n\n/// Convert the given deduced template argument and add it to the set of\n/// fully-converted template arguments.\nstatic bool\nConvertDeducedTemplateArgument(Sema &S, NamedDecl *Param,\n                               DeducedTemplateArgument Arg,\n                               NamedDecl *Template,\n                               TemplateDeductionInfo &Info,\n                               bool IsDeduced,\n                               SmallVectorImpl<TemplateArgument> &Output) {\n  auto ConvertArg = [&](DeducedTemplateArgument Arg,\n                        unsigned ArgumentPackIndex) {\n    // Convert the deduced template argument into a template\n    // argument that we can check, almost as if the user had written\n    // the template argument explicitly.\n    TemplateArgumentLoc ArgLoc =\n        S.getTrivialTemplateArgumentLoc(Arg, QualType(), Info.getLocation());\n\n    // Check the template argument, converting it as necessary.\n    return S.CheckTemplateArgument(\n        Param, ArgLoc, Template, Template->getLocation(),\n        Template->getSourceRange().getEnd(), ArgumentPackIndex, Output,\n        IsDeduced\n            ? (Arg.wasDeducedFromArrayBound() ? Sema::CTAK_DeducedFromArrayBound\n                                              : Sema::CTAK_Deduced)\n            : Sema::CTAK_Specified);\n  };\n\n  if (Arg.getKind() == TemplateArgument::Pack) {\n    // This is a template argument pack, so check each of its arguments against\n    // the template parameter.\n    SmallVector<TemplateArgument, 2> PackedArgsBuilder;\n    for (const auto &P : Arg.pack_elements()) {\n      // When converting the deduced template argument, append it to the\n      // general output list. We need to do this so that the template argument\n      // checking logic has all of the prior template arguments available.\n      DeducedTemplateArgument InnerArg(P);\n      InnerArg.setDeducedFromArrayBound(Arg.wasDeducedFromArrayBound());\n      assert(InnerArg.getKind() != TemplateArgument::Pack &&\n             \"deduced nested pack\");\n      if (P.isNull()) {\n        // We deduced arguments for some elements of this pack, but not for\n        // all of them. This happens if we get a conditionally-non-deduced\n        // context in a pack expansion (such as an overload set in one of the\n        // arguments).\n        S.Diag(Param->getLocation(),\n               diag::err_template_arg_deduced_incomplete_pack)\n          << Arg << Param;\n        return true;\n      }\n      if (ConvertArg(InnerArg, PackedArgsBuilder.size()))\n        return true;\n\n      // Move the converted template argument into our argument pack.\n      PackedArgsBuilder.push_back(Output.pop_back_val());\n    }\n\n    // If the pack is empty, we still need to substitute into the parameter\n    // itself, in case that substitution fails.\n    if (PackedArgsBuilder.empty()) {\n      LocalInstantiationScope Scope(S);\n      TemplateArgumentList TemplateArgs(TemplateArgumentList::OnStack, Output);\n      MultiLevelTemplateArgumentList Args(TemplateArgs);\n\n      if (auto *NTTP = dyn_cast<NonTypeTemplateParmDecl>(Param)) {\n        Sema::InstantiatingTemplate Inst(S, Template->getLocation(), Template,\n                                         NTTP, Output,\n                                         Template->getSourceRange());\n        if (Inst.isInvalid() ||\n            S.SubstType(NTTP->getType(), Args, NTTP->getLocation(),\n                        NTTP->getDeclName()).isNull())\n          return true;\n      } else if (auto *TTP = dyn_cast<TemplateTemplateParmDecl>(Param)) {\n        Sema::InstantiatingTemplate Inst(S, Template->getLocation(), Template,\n                                         TTP, Output,\n                                         Template->getSourceRange());\n        if (Inst.isInvalid() || !S.SubstDecl(TTP, S.CurContext, Args))\n          return true;\n      }\n      // For type parameters, no substitution is ever required.\n    }\n\n    // Create the resulting argument pack.\n    Output.push_back(\n        TemplateArgument::CreatePackCopy(S.Context, PackedArgsBuilder));\n    return false;\n  }\n\n  return ConvertArg(Arg, 0);\n}\n\n// FIXME: This should not be a template, but\n// ClassTemplatePartialSpecializationDecl sadly does not derive from\n// TemplateDecl.\ntemplate<typename TemplateDeclT>\nstatic Sema::TemplateDeductionResult ConvertDeducedTemplateArguments(\n    Sema &S, TemplateDeclT *Template, bool IsDeduced,\n    SmallVectorImpl<DeducedTemplateArgument> &Deduced,\n    TemplateDeductionInfo &Info, SmallVectorImpl<TemplateArgument> &Builder,\n    LocalInstantiationScope *CurrentInstantiationScope = nullptr,\n    unsigned NumAlreadyConverted = 0, bool PartialOverloading = false) {\n  TemplateParameterList *TemplateParams = Template->getTemplateParameters();\n\n  for (unsigned I = 0, N = TemplateParams->size(); I != N; ++I) {\n    NamedDecl *Param = TemplateParams->getParam(I);\n\n    // C++0x [temp.arg.explicit]p3:\n    //    A trailing template parameter pack (14.5.3) not otherwise deduced will\n    //    be deduced to an empty sequence of template arguments.\n    // FIXME: Where did the word \"trailing\" come from?\n    if (Deduced[I].isNull() && Param->isTemplateParameterPack()) {\n      if (auto Result =\n              PackDeductionScope(S, TemplateParams, Deduced, Info, I).finish())\n        return Result;\n    }\n\n    if (!Deduced[I].isNull()) {\n      if (I < NumAlreadyConverted) {\n        // We may have had explicitly-specified template arguments for a\n        // template parameter pack (that may or may not have been extended\n        // via additional deduced arguments).\n        if (Param->isParameterPack() && CurrentInstantiationScope &&\n            CurrentInstantiationScope->getPartiallySubstitutedPack() == Param) {\n          // Forget the partially-substituted pack; its substitution is now\n          // complete.\n          CurrentInstantiationScope->ResetPartiallySubstitutedPack();\n          // We still need to check the argument in case it was extended by\n          // deduction.\n        } else {\n          // We have already fully type-checked and converted this\n          // argument, because it was explicitly-specified. Just record the\n          // presence of this argument.\n          Builder.push_back(Deduced[I]);\n          continue;\n        }\n      }\n\n      // We may have deduced this argument, so it still needs to be\n      // checked and converted.\n      if (ConvertDeducedTemplateArgument(S, Param, Deduced[I], Template, Info,\n                                         IsDeduced, Builder)) {\n        Info.Param = makeTemplateParameter(Param);\n        // FIXME: These template arguments are temporary. Free them!\n        Info.reset(TemplateArgumentList::CreateCopy(S.Context, Builder));\n        return Sema::TDK_SubstitutionFailure;\n      }\n\n      continue;\n    }\n\n    // Substitute into the default template argument, if available.\n    bool HasDefaultArg = false;\n    TemplateDecl *TD = dyn_cast<TemplateDecl>(Template);\n    if (!TD) {\n      assert(isa<ClassTemplatePartialSpecializationDecl>(Template) ||\n             isa<VarTemplatePartialSpecializationDecl>(Template));\n      return Sema::TDK_Incomplete;\n    }\n\n    TemplateArgumentLoc DefArg = S.SubstDefaultTemplateArgumentIfAvailable(\n        TD, TD->getLocation(), TD->getSourceRange().getEnd(), Param, Builder,\n        HasDefaultArg);\n\n    // If there was no default argument, deduction is incomplete.\n    if (DefArg.getArgument().isNull()) {\n      Info.Param = makeTemplateParameter(\n          const_cast<NamedDecl *>(TemplateParams->getParam(I)));\n      Info.reset(TemplateArgumentList::CreateCopy(S.Context, Builder));\n      if (PartialOverloading) break;\n\n      return HasDefaultArg ? Sema::TDK_SubstitutionFailure\n                           : Sema::TDK_Incomplete;\n    }\n\n    // Check whether we can actually use the default argument.\n    if (S.CheckTemplateArgument(Param, DefArg, TD, TD->getLocation(),\n                                TD->getSourceRange().getEnd(), 0, Builder,\n                                Sema::CTAK_Specified)) {\n      Info.Param = makeTemplateParameter(\n                         const_cast<NamedDecl *>(TemplateParams->getParam(I)));\n      // FIXME: These template arguments are temporary. Free them!\n      Info.reset(TemplateArgumentList::CreateCopy(S.Context, Builder));\n      return Sema::TDK_SubstitutionFailure;\n    }\n\n    // If we get here, we successfully used the default template argument.\n  }\n\n  return Sema::TDK_Success;\n}\n\nstatic DeclContext *getAsDeclContextOrEnclosing(Decl *D) {\n  if (auto *DC = dyn_cast<DeclContext>(D))\n    return DC;\n  return D->getDeclContext();\n}\n\ntemplate<typename T> struct IsPartialSpecialization {\n  static constexpr bool value = false;\n};\ntemplate<>\nstruct IsPartialSpecialization<ClassTemplatePartialSpecializationDecl> {\n  static constexpr bool value = true;\n};\ntemplate<>\nstruct IsPartialSpecialization<VarTemplatePartialSpecializationDecl> {\n  static constexpr bool value = true;\n};\n\ntemplate<typename TemplateDeclT>\nstatic Sema::TemplateDeductionResult\nCheckDeducedArgumentConstraints(Sema& S, TemplateDeclT *Template,\n                                ArrayRef<TemplateArgument> DeducedArgs,\n                                TemplateDeductionInfo& Info) {\n  llvm::SmallVector<const Expr *, 3> AssociatedConstraints;\n  Template->getAssociatedConstraints(AssociatedConstraints);\n  if (S.CheckConstraintSatisfaction(Template, AssociatedConstraints,\n                                    DeducedArgs, Info.getLocation(),\n                                    Info.AssociatedConstraintsSatisfaction) ||\n      !Info.AssociatedConstraintsSatisfaction.IsSatisfied) {\n    Info.reset(TemplateArgumentList::CreateCopy(S.Context, DeducedArgs));\n    return Sema::TDK_ConstraintsNotSatisfied;\n  }\n  return Sema::TDK_Success;\n}\n\n/// Complete template argument deduction for a partial specialization.\ntemplate <typename T>\nstatic std::enable_if_t<IsPartialSpecialization<T>::value,\n                        Sema::TemplateDeductionResult>\nFinishTemplateArgumentDeduction(\n    Sema &S, T *Partial, bool IsPartialOrdering,\n    const TemplateArgumentList &TemplateArgs,\n    SmallVectorImpl<DeducedTemplateArgument> &Deduced,\n    TemplateDeductionInfo &Info) {\n  // Unevaluated SFINAE context.\n  EnterExpressionEvaluationContext Unevaluated(\n      S, Sema::ExpressionEvaluationContext::Unevaluated);\n  Sema::SFINAETrap Trap(S);\n\n  Sema::ContextRAII SavedContext(S, getAsDeclContextOrEnclosing(Partial));\n\n  // C++ [temp.deduct.type]p2:\n  //   [...] or if any template argument remains neither deduced nor\n  //   explicitly specified, template argument deduction fails.\n  SmallVector<TemplateArgument, 4> Builder;\n  if (auto Result = ConvertDeducedTemplateArguments(\n          S, Partial, IsPartialOrdering, Deduced, Info, Builder))\n    return Result;\n\n  // Form the template argument list from the deduced template arguments.\n  TemplateArgumentList *DeducedArgumentList\n    = TemplateArgumentList::CreateCopy(S.Context, Builder);\n\n  Info.reset(DeducedArgumentList);\n\n  // Substitute the deduced template arguments into the template\n  // arguments of the class template partial specialization, and\n  // verify that the instantiated template arguments are both valid\n  // and are equivalent to the template arguments originally provided\n  // to the class template.\n  LocalInstantiationScope InstScope(S);\n  auto *Template = Partial->getSpecializedTemplate();\n  const ASTTemplateArgumentListInfo *PartialTemplArgInfo =\n      Partial->getTemplateArgsAsWritten();\n  const TemplateArgumentLoc *PartialTemplateArgs =\n      PartialTemplArgInfo->getTemplateArgs();\n\n  TemplateArgumentListInfo InstArgs(PartialTemplArgInfo->LAngleLoc,\n                                    PartialTemplArgInfo->RAngleLoc);\n\n  if (S.Subst(PartialTemplateArgs, PartialTemplArgInfo->NumTemplateArgs,\n              InstArgs, MultiLevelTemplateArgumentList(*DeducedArgumentList))) {\n    unsigned ArgIdx = InstArgs.size(), ParamIdx = ArgIdx;\n    if (ParamIdx >= Partial->getTemplateParameters()->size())\n      ParamIdx = Partial->getTemplateParameters()->size() - 1;\n\n    Decl *Param = const_cast<NamedDecl *>(\n        Partial->getTemplateParameters()->getParam(ParamIdx));\n    Info.Param = makeTemplateParameter(Param);\n    Info.FirstArg = PartialTemplateArgs[ArgIdx].getArgument();\n    return Sema::TDK_SubstitutionFailure;\n  }\n\n  bool ConstraintsNotSatisfied;\n  SmallVector<TemplateArgument, 4> ConvertedInstArgs;\n  if (S.CheckTemplateArgumentList(Template, Partial->getLocation(), InstArgs,\n                                  false, ConvertedInstArgs,\n                                  /*UpdateArgsWithConversions=*/true,\n                                  &ConstraintsNotSatisfied))\n    return ConstraintsNotSatisfied ? Sema::TDK_ConstraintsNotSatisfied :\n                                     Sema::TDK_SubstitutionFailure;\n\n  TemplateParameterList *TemplateParams = Template->getTemplateParameters();\n  for (unsigned I = 0, E = TemplateParams->size(); I != E; ++I) {\n    TemplateArgument InstArg = ConvertedInstArgs.data()[I];\n    if (!isSameTemplateArg(S.Context, TemplateArgs[I], InstArg)) {\n      Info.Param = makeTemplateParameter(TemplateParams->getParam(I));\n      Info.FirstArg = TemplateArgs[I];\n      Info.SecondArg = InstArg;\n      return Sema::TDK_NonDeducedMismatch;\n    }\n  }\n\n  if (Trap.hasErrorOccurred())\n    return Sema::TDK_SubstitutionFailure;\n\n  if (auto Result = CheckDeducedArgumentConstraints(S, Partial, Builder, Info))\n    return Result;\n\n  return Sema::TDK_Success;\n}\n\n/// Complete template argument deduction for a class or variable template,\n/// when partial ordering against a partial specialization.\n// FIXME: Factor out duplication with partial specialization version above.\nstatic Sema::TemplateDeductionResult FinishTemplateArgumentDeduction(\n    Sema &S, TemplateDecl *Template, bool PartialOrdering,\n    const TemplateArgumentList &TemplateArgs,\n    SmallVectorImpl<DeducedTemplateArgument> &Deduced,\n    TemplateDeductionInfo &Info) {\n  // Unevaluated SFINAE context.\n  EnterExpressionEvaluationContext Unevaluated(\n      S, Sema::ExpressionEvaluationContext::Unevaluated);\n  Sema::SFINAETrap Trap(S);\n\n  Sema::ContextRAII SavedContext(S, getAsDeclContextOrEnclosing(Template));\n\n  // C++ [temp.deduct.type]p2:\n  //   [...] or if any template argument remains neither deduced nor\n  //   explicitly specified, template argument deduction fails.\n  SmallVector<TemplateArgument, 4> Builder;\n  if (auto Result = ConvertDeducedTemplateArguments(\n          S, Template, /*IsDeduced*/PartialOrdering, Deduced, Info, Builder))\n    return Result;\n\n  // Check that we produced the correct argument list.\n  TemplateParameterList *TemplateParams = Template->getTemplateParameters();\n  for (unsigned I = 0, E = TemplateParams->size(); I != E; ++I) {\n    TemplateArgument InstArg = Builder[I];\n    if (!isSameTemplateArg(S.Context, TemplateArgs[I], InstArg,\n                           /*PackExpansionMatchesPack*/true)) {\n      Info.Param = makeTemplateParameter(TemplateParams->getParam(I));\n      Info.FirstArg = TemplateArgs[I];\n      Info.SecondArg = InstArg;\n      return Sema::TDK_NonDeducedMismatch;\n    }\n  }\n\n  if (Trap.hasErrorOccurred())\n    return Sema::TDK_SubstitutionFailure;\n\n  if (auto Result = CheckDeducedArgumentConstraints(S, Template, Builder,\n                                                    Info))\n    return Result;\n\n  return Sema::TDK_Success;\n}\n\n/// Perform template argument deduction to determine whether\n/// the given template arguments match the given class template\n/// partial specialization per C++ [temp.class.spec.match].\nSema::TemplateDeductionResult\nSema::DeduceTemplateArguments(ClassTemplatePartialSpecializationDecl *Partial,\n                              const TemplateArgumentList &TemplateArgs,\n                              TemplateDeductionInfo &Info) {\n  if (Partial->isInvalidDecl())\n    return TDK_Invalid;\n\n  // C++ [temp.class.spec.match]p2:\n  //   A partial specialization matches a given actual template\n  //   argument list if the template arguments of the partial\n  //   specialization can be deduced from the actual template argument\n  //   list (14.8.2).\n\n  // Unevaluated SFINAE context.\n  EnterExpressionEvaluationContext Unevaluated(\n      *this, Sema::ExpressionEvaluationContext::Unevaluated);\n  SFINAETrap Trap(*this);\n\n  SmallVector<DeducedTemplateArgument, 4> Deduced;\n  Deduced.resize(Partial->getTemplateParameters()->size());\n  if (TemplateDeductionResult Result\n        = ::DeduceTemplateArguments(*this,\n                                    Partial->getTemplateParameters(),\n                                    Partial->getTemplateArgs(),\n                                    TemplateArgs, Info, Deduced))\n    return Result;\n\n  SmallVector<TemplateArgument, 4> DeducedArgs(Deduced.begin(), Deduced.end());\n  InstantiatingTemplate Inst(*this, Info.getLocation(), Partial, DeducedArgs,\n                             Info);\n  if (Inst.isInvalid())\n    return TDK_InstantiationDepth;\n\n  if (Trap.hasErrorOccurred())\n    return Sema::TDK_SubstitutionFailure;\n\n  TemplateDeductionResult Result;\n  runWithSufficientStackSpace(Info.getLocation(), [&] {\n    Result = ::FinishTemplateArgumentDeduction(*this, Partial,\n                                               /*IsPartialOrdering=*/false,\n                                               TemplateArgs, Deduced, Info);\n  });\n  return Result;\n}\n\n/// Perform template argument deduction to determine whether\n/// the given template arguments match the given variable template\n/// partial specialization per C++ [temp.class.spec.match].\nSema::TemplateDeductionResult\nSema::DeduceTemplateArguments(VarTemplatePartialSpecializationDecl *Partial,\n                              const TemplateArgumentList &TemplateArgs,\n                              TemplateDeductionInfo &Info) {\n  if (Partial->isInvalidDecl())\n    return TDK_Invalid;\n\n  // C++ [temp.class.spec.match]p2:\n  //   A partial specialization matches a given actual template\n  //   argument list if the template arguments of the partial\n  //   specialization can be deduced from the actual template argument\n  //   list (14.8.2).\n\n  // Unevaluated SFINAE context.\n  EnterExpressionEvaluationContext Unevaluated(\n      *this, Sema::ExpressionEvaluationContext::Unevaluated);\n  SFINAETrap Trap(*this);\n\n  SmallVector<DeducedTemplateArgument, 4> Deduced;\n  Deduced.resize(Partial->getTemplateParameters()->size());\n  if (TemplateDeductionResult Result = ::DeduceTemplateArguments(\n          *this, Partial->getTemplateParameters(), Partial->getTemplateArgs(),\n          TemplateArgs, Info, Deduced))\n    return Result;\n\n  SmallVector<TemplateArgument, 4> DeducedArgs(Deduced.begin(), Deduced.end());\n  InstantiatingTemplate Inst(*this, Info.getLocation(), Partial, DeducedArgs,\n                             Info);\n  if (Inst.isInvalid())\n    return TDK_InstantiationDepth;\n\n  if (Trap.hasErrorOccurred())\n    return Sema::TDK_SubstitutionFailure;\n\n  TemplateDeductionResult Result;\n  runWithSufficientStackSpace(Info.getLocation(), [&] {\n    Result = ::FinishTemplateArgumentDeduction(*this, Partial,\n                                               /*IsPartialOrdering=*/false,\n                                               TemplateArgs, Deduced, Info);\n  });\n  return Result;\n}\n\n/// Determine whether the given type T is a simple-template-id type.\nstatic bool isSimpleTemplateIdType(QualType T) {\n  if (const TemplateSpecializationType *Spec\n        = T->getAs<TemplateSpecializationType>())\n    return Spec->getTemplateName().getAsTemplateDecl() != nullptr;\n\n  // C++17 [temp.local]p2:\n  //   the injected-class-name [...] is equivalent to the template-name followed\n  //   by the template-arguments of the class template specialization or partial\n  //   specialization enclosed in <>\n  // ... which means it's equivalent to a simple-template-id.\n  //\n  // This only arises during class template argument deduction for a copy\n  // deduction candidate, where it permits slicing.\n  if (T->getAs<InjectedClassNameType>())\n    return true;\n\n  return false;\n}\n\n/// Substitute the explicitly-provided template arguments into the\n/// given function template according to C++ [temp.arg.explicit].\n///\n/// \\param FunctionTemplate the function template into which the explicit\n/// template arguments will be substituted.\n///\n/// \\param ExplicitTemplateArgs the explicitly-specified template\n/// arguments.\n///\n/// \\param Deduced the deduced template arguments, which will be populated\n/// with the converted and checked explicit template arguments.\n///\n/// \\param ParamTypes will be populated with the instantiated function\n/// parameters.\n///\n/// \\param FunctionType if non-NULL, the result type of the function template\n/// will also be instantiated and the pointed-to value will be updated with\n/// the instantiated function type.\n///\n/// \\param Info if substitution fails for any reason, this object will be\n/// populated with more information about the failure.\n///\n/// \\returns TDK_Success if substitution was successful, or some failure\n/// condition.\nSema::TemplateDeductionResult\nSema::SubstituteExplicitTemplateArguments(\n                                      FunctionTemplateDecl *FunctionTemplate,\n                               TemplateArgumentListInfo &ExplicitTemplateArgs,\n                       SmallVectorImpl<DeducedTemplateArgument> &Deduced,\n                                 SmallVectorImpl<QualType> &ParamTypes,\n                                          QualType *FunctionType,\n                                          TemplateDeductionInfo &Info) {\n  FunctionDecl *Function = FunctionTemplate->getTemplatedDecl();\n  TemplateParameterList *TemplateParams\n    = FunctionTemplate->getTemplateParameters();\n\n  if (ExplicitTemplateArgs.size() == 0) {\n    // No arguments to substitute; just copy over the parameter types and\n    // fill in the function type.\n    for (auto P : Function->parameters())\n      ParamTypes.push_back(P->getType());\n\n    if (FunctionType)\n      *FunctionType = Function->getType();\n    return TDK_Success;\n  }\n\n  // Unevaluated SFINAE context.\n  EnterExpressionEvaluationContext Unevaluated(\n      *this, Sema::ExpressionEvaluationContext::Unevaluated);\n  SFINAETrap Trap(*this);\n\n  // C++ [temp.arg.explicit]p3:\n  //   Template arguments that are present shall be specified in the\n  //   declaration order of their corresponding template-parameters. The\n  //   template argument list shall not specify more template-arguments than\n  //   there are corresponding template-parameters.\n  SmallVector<TemplateArgument, 4> Builder;\n\n  // Enter a new template instantiation context where we check the\n  // explicitly-specified template arguments against this function template,\n  // and then substitute them into the function parameter types.\n  SmallVector<TemplateArgument, 4> DeducedArgs;\n  InstantiatingTemplate Inst(\n      *this, Info.getLocation(), FunctionTemplate, DeducedArgs,\n      CodeSynthesisContext::ExplicitTemplateArgumentSubstitution, Info);\n  if (Inst.isInvalid())\n    return TDK_InstantiationDepth;\n\n  if (CheckTemplateArgumentList(FunctionTemplate, SourceLocation(),\n                                ExplicitTemplateArgs, true, Builder, false) ||\n      Trap.hasErrorOccurred()) {\n    unsigned Index = Builder.size();\n    if (Index >= TemplateParams->size())\n      return TDK_SubstitutionFailure;\n    Info.Param = makeTemplateParameter(TemplateParams->getParam(Index));\n    return TDK_InvalidExplicitArguments;\n  }\n\n  // Form the template argument list from the explicitly-specified\n  // template arguments.\n  TemplateArgumentList *ExplicitArgumentList\n    = TemplateArgumentList::CreateCopy(Context, Builder);\n  Info.setExplicitArgs(ExplicitArgumentList);\n\n  // Template argument deduction and the final substitution should be\n  // done in the context of the templated declaration.  Explicit\n  // argument substitution, on the other hand, needs to happen in the\n  // calling context.\n  ContextRAII SavedContext(*this, FunctionTemplate->getTemplatedDecl());\n\n  // If we deduced template arguments for a template parameter pack,\n  // note that the template argument pack is partially substituted and record\n  // the explicit template arguments. They'll be used as part of deduction\n  // for this template parameter pack.\n  unsigned PartiallySubstitutedPackIndex = -1u;\n  if (!Builder.empty()) {\n    const TemplateArgument &Arg = Builder.back();\n    if (Arg.getKind() == TemplateArgument::Pack) {\n      auto *Param = TemplateParams->getParam(Builder.size() - 1);\n      // If this is a fully-saturated fixed-size pack, it should be\n      // fully-substituted, not partially-substituted.\n      Optional<unsigned> Expansions = getExpandedPackSize(Param);\n      if (!Expansions || Arg.pack_size() < *Expansions) {\n        PartiallySubstitutedPackIndex = Builder.size() - 1;\n        CurrentInstantiationScope->SetPartiallySubstitutedPack(\n            Param, Arg.pack_begin(), Arg.pack_size());\n      }\n    }\n  }\n\n  const FunctionProtoType *Proto\n    = Function->getType()->getAs<FunctionProtoType>();\n  assert(Proto && \"Function template does not have a prototype?\");\n\n  // Isolate our substituted parameters from our caller.\n  LocalInstantiationScope InstScope(*this, /*MergeWithOuterScope*/true);\n\n  ExtParameterInfoBuilder ExtParamInfos;\n\n  // Instantiate the types of each of the function parameters given the\n  // explicitly-specified template arguments. If the function has a trailing\n  // return type, substitute it after the arguments to ensure we substitute\n  // in lexical order.\n  if (Proto->hasTrailingReturn()) {\n    if (SubstParmTypes(Function->getLocation(), Function->parameters(),\n                       Proto->getExtParameterInfosOrNull(),\n                       MultiLevelTemplateArgumentList(*ExplicitArgumentList),\n                       ParamTypes, /*params*/ nullptr, ExtParamInfos))\n      return TDK_SubstitutionFailure;\n  }\n\n  // Instantiate the return type.\n  QualType ResultType;\n  {\n    // C++11 [expr.prim.general]p3:\n    //   If a declaration declares a member function or member function\n    //   template of a class X, the expression this is a prvalue of type\n    //   \"pointer to cv-qualifier-seq X\" between the optional cv-qualifer-seq\n    //   and the end of the function-definition, member-declarator, or\n    //   declarator.\n    Qualifiers ThisTypeQuals;\n    CXXRecordDecl *ThisContext = nullptr;\n    if (CXXMethodDecl *Method = dyn_cast<CXXMethodDecl>(Function)) {\n      ThisContext = Method->getParent();\n      ThisTypeQuals = Method->getMethodQualifiers();\n    }\n\n    CXXThisScopeRAII ThisScope(*this, ThisContext, ThisTypeQuals,\n                               getLangOpts().CPlusPlus11);\n\n    ResultType =\n        SubstType(Proto->getReturnType(),\n                  MultiLevelTemplateArgumentList(*ExplicitArgumentList),\n                  Function->getTypeSpecStartLoc(), Function->getDeclName());\n    if (ResultType.isNull() || Trap.hasErrorOccurred())\n      return TDK_SubstitutionFailure;\n    // CUDA: Kernel function must have 'void' return type.\n    if (getLangOpts().CUDA)\n      if (Function->hasAttr<CUDAGlobalAttr>() && !ResultType->isVoidType()) {\n        Diag(Function->getLocation(), diag::err_kern_type_not_void_return)\n            << Function->getType() << Function->getSourceRange();\n        return TDK_SubstitutionFailure;\n      }\n  }\n\n  // Instantiate the types of each of the function parameters given the\n  // explicitly-specified template arguments if we didn't do so earlier.\n  if (!Proto->hasTrailingReturn() &&\n      SubstParmTypes(Function->getLocation(), Function->parameters(),\n                     Proto->getExtParameterInfosOrNull(),\n                     MultiLevelTemplateArgumentList(*ExplicitArgumentList),\n                     ParamTypes, /*params*/ nullptr, ExtParamInfos))\n    return TDK_SubstitutionFailure;\n\n  if (FunctionType) {\n    auto EPI = Proto->getExtProtoInfo();\n    EPI.ExtParameterInfos = ExtParamInfos.getPointerOrNull(ParamTypes.size());\n\n    // In C++1z onwards, exception specifications are part of the function type,\n    // so substitution into the type must also substitute into the exception\n    // specification.\n    SmallVector<QualType, 4> ExceptionStorage;\n    if (getLangOpts().CPlusPlus17 &&\n        SubstExceptionSpec(\n            Function->getLocation(), EPI.ExceptionSpec, ExceptionStorage,\n            MultiLevelTemplateArgumentList(*ExplicitArgumentList)))\n      return TDK_SubstitutionFailure;\n\n    *FunctionType = BuildFunctionType(ResultType, ParamTypes,\n                                      Function->getLocation(),\n                                      Function->getDeclName(),\n                                      EPI);\n    if (FunctionType->isNull() || Trap.hasErrorOccurred())\n      return TDK_SubstitutionFailure;\n  }\n\n  // C++ [temp.arg.explicit]p2:\n  //   Trailing template arguments that can be deduced (14.8.2) may be\n  //   omitted from the list of explicit template-arguments. If all of the\n  //   template arguments can be deduced, they may all be omitted; in this\n  //   case, the empty template argument list <> itself may also be omitted.\n  //\n  // Take all of the explicitly-specified arguments and put them into\n  // the set of deduced template arguments. The partially-substituted\n  // parameter pack, however, will be set to NULL since the deduction\n  // mechanism handles the partially-substituted argument pack directly.\n  Deduced.reserve(TemplateParams->size());\n  for (unsigned I = 0, N = ExplicitArgumentList->size(); I != N; ++I) {\n    const TemplateArgument &Arg = ExplicitArgumentList->get(I);\n    if (I == PartiallySubstitutedPackIndex)\n      Deduced.push_back(DeducedTemplateArgument());\n    else\n      Deduced.push_back(Arg);\n  }\n\n  return TDK_Success;\n}\n\n/// Check whether the deduced argument type for a call to a function\n/// template matches the actual argument type per C++ [temp.deduct.call]p4.\nstatic Sema::TemplateDeductionResult\nCheckOriginalCallArgDeduction(Sema &S, TemplateDeductionInfo &Info,\n                              Sema::OriginalCallArg OriginalArg,\n                              QualType DeducedA) {\n  ASTContext &Context = S.Context;\n\n  auto Failed = [&]() -> Sema::TemplateDeductionResult {\n    Info.FirstArg = TemplateArgument(DeducedA);\n    Info.SecondArg = TemplateArgument(OriginalArg.OriginalArgType);\n    Info.CallArgIndex = OriginalArg.ArgIdx;\n    return OriginalArg.DecomposedParam ? Sema::TDK_DeducedMismatchNested\n                                       : Sema::TDK_DeducedMismatch;\n  };\n\n  QualType A = OriginalArg.OriginalArgType;\n  QualType OriginalParamType = OriginalArg.OriginalParamType;\n\n  // Check for type equality (top-level cv-qualifiers are ignored).\n  if (Context.hasSameUnqualifiedType(A, DeducedA))\n    return Sema::TDK_Success;\n\n  // Strip off references on the argument types; they aren't needed for\n  // the following checks.\n  if (const ReferenceType *DeducedARef = DeducedA->getAs<ReferenceType>())\n    DeducedA = DeducedARef->getPointeeType();\n  if (const ReferenceType *ARef = A->getAs<ReferenceType>())\n    A = ARef->getPointeeType();\n\n  // C++ [temp.deduct.call]p4:\n  //   [...] However, there are three cases that allow a difference:\n  //     - If the original P is a reference type, the deduced A (i.e., the\n  //       type referred to by the reference) can be more cv-qualified than\n  //       the transformed A.\n  if (const ReferenceType *OriginalParamRef\n      = OriginalParamType->getAs<ReferenceType>()) {\n    // We don't want to keep the reference around any more.\n    OriginalParamType = OriginalParamRef->getPointeeType();\n\n    // FIXME: Resolve core issue (no number yet): if the original P is a\n    // reference type and the transformed A is function type \"noexcept F\",\n    // the deduced A can be F.\n    QualType Tmp;\n    if (A->isFunctionType() && S.IsFunctionConversion(A, DeducedA, Tmp))\n      return Sema::TDK_Success;\n\n    Qualifiers AQuals = A.getQualifiers();\n    Qualifiers DeducedAQuals = DeducedA.getQualifiers();\n\n    // Under Objective-C++ ARC, the deduced type may have implicitly\n    // been given strong or (when dealing with a const reference)\n    // unsafe_unretained lifetime. If so, update the original\n    // qualifiers to include this lifetime.\n    if (S.getLangOpts().ObjCAutoRefCount &&\n        ((DeducedAQuals.getObjCLifetime() == Qualifiers::OCL_Strong &&\n          AQuals.getObjCLifetime() == Qualifiers::OCL_None) ||\n         (DeducedAQuals.hasConst() &&\n          DeducedAQuals.getObjCLifetime() == Qualifiers::OCL_ExplicitNone))) {\n      AQuals.setObjCLifetime(DeducedAQuals.getObjCLifetime());\n    }\n\n    if (AQuals == DeducedAQuals) {\n      // Qualifiers match; there's nothing to do.\n    } else if (!DeducedAQuals.compatiblyIncludes(AQuals)) {\n      return Failed();\n    } else {\n      // Qualifiers are compatible, so have the argument type adopt the\n      // deduced argument type's qualifiers as if we had performed the\n      // qualification conversion.\n      A = Context.getQualifiedType(A.getUnqualifiedType(), DeducedAQuals);\n    }\n  }\n\n  //    - The transformed A can be another pointer or pointer to member\n  //      type that can be converted to the deduced A via a function pointer\n  //      conversion and/or a qualification conversion.\n  //\n  // Also allow conversions which merely strip __attribute__((noreturn)) from\n  // function types (recursively).\n  bool ObjCLifetimeConversion = false;\n  QualType ResultTy;\n  if ((A->isAnyPointerType() || A->isMemberPointerType()) &&\n      (S.IsQualificationConversion(A, DeducedA, false,\n                                   ObjCLifetimeConversion) ||\n       S.IsFunctionConversion(A, DeducedA, ResultTy)))\n    return Sema::TDK_Success;\n\n  //    - If P is a class and P has the form simple-template-id, then the\n  //      transformed A can be a derived class of the deduced A. [...]\n  //     [...] Likewise, if P is a pointer to a class of the form\n  //      simple-template-id, the transformed A can be a pointer to a\n  //      derived class pointed to by the deduced A.\n  if (const PointerType *OriginalParamPtr\n      = OriginalParamType->getAs<PointerType>()) {\n    if (const PointerType *DeducedAPtr = DeducedA->getAs<PointerType>()) {\n      if (const PointerType *APtr = A->getAs<PointerType>()) {\n        if (A->getPointeeType()->isRecordType()) {\n          OriginalParamType = OriginalParamPtr->getPointeeType();\n          DeducedA = DeducedAPtr->getPointeeType();\n          A = APtr->getPointeeType();\n        }\n      }\n    }\n  }\n\n  if (Context.hasSameUnqualifiedType(A, DeducedA))\n    return Sema::TDK_Success;\n\n  if (A->isRecordType() && isSimpleTemplateIdType(OriginalParamType) &&\n      S.IsDerivedFrom(Info.getLocation(), A, DeducedA))\n    return Sema::TDK_Success;\n\n  return Failed();\n}\n\n/// Find the pack index for a particular parameter index in an instantiation of\n/// a function template with specific arguments.\n///\n/// \\return The pack index for whichever pack produced this parameter, or -1\n///         if this was not produced by a parameter. Intended to be used as the\n///         ArgumentPackSubstitutionIndex for further substitutions.\n// FIXME: We should track this in OriginalCallArgs so we don't need to\n// reconstruct it here.\nstatic unsigned getPackIndexForParam(Sema &S,\n                                     FunctionTemplateDecl *FunctionTemplate,\n                                     const MultiLevelTemplateArgumentList &Args,\n                                     unsigned ParamIdx) {\n  unsigned Idx = 0;\n  for (auto *PD : FunctionTemplate->getTemplatedDecl()->parameters()) {\n    if (PD->isParameterPack()) {\n      unsigned NumExpansions =\n          S.getNumArgumentsInExpansion(PD->getType(), Args).getValueOr(1);\n      if (Idx + NumExpansions > ParamIdx)\n        return ParamIdx - Idx;\n      Idx += NumExpansions;\n    } else {\n      if (Idx == ParamIdx)\n        return -1; // Not a pack expansion\n      ++Idx;\n    }\n  }\n\n  llvm_unreachable(\"parameter index would not be produced from template\");\n}\n\n/// Finish template argument deduction for a function template,\n/// checking the deduced template arguments for completeness and forming\n/// the function template specialization.\n///\n/// \\param OriginalCallArgs If non-NULL, the original call arguments against\n/// which the deduced argument types should be compared.\nSema::TemplateDeductionResult Sema::FinishTemplateArgumentDeduction(\n    FunctionTemplateDecl *FunctionTemplate,\n    SmallVectorImpl<DeducedTemplateArgument> &Deduced,\n    unsigned NumExplicitlySpecified, FunctionDecl *&Specialization,\n    TemplateDeductionInfo &Info,\n    SmallVectorImpl<OriginalCallArg> const *OriginalCallArgs,\n    bool PartialOverloading, llvm::function_ref<bool()> CheckNonDependent) {\n  // Unevaluated SFINAE context.\n  EnterExpressionEvaluationContext Unevaluated(\n      *this, Sema::ExpressionEvaluationContext::Unevaluated);\n  SFINAETrap Trap(*this);\n\n  // Enter a new template instantiation context while we instantiate the\n  // actual function declaration.\n  SmallVector<TemplateArgument, 4> DeducedArgs(Deduced.begin(), Deduced.end());\n  InstantiatingTemplate Inst(\n      *this, Info.getLocation(), FunctionTemplate, DeducedArgs,\n      CodeSynthesisContext::DeducedTemplateArgumentSubstitution, Info);\n  if (Inst.isInvalid())\n    return TDK_InstantiationDepth;\n\n  ContextRAII SavedContext(*this, FunctionTemplate->getTemplatedDecl());\n\n  // C++ [temp.deduct.type]p2:\n  //   [...] or if any template argument remains neither deduced nor\n  //   explicitly specified, template argument deduction fails.\n  SmallVector<TemplateArgument, 4> Builder;\n  if (auto Result = ConvertDeducedTemplateArguments(\n          *this, FunctionTemplate, /*IsDeduced*/true, Deduced, Info, Builder,\n          CurrentInstantiationScope, NumExplicitlySpecified,\n          PartialOverloading))\n    return Result;\n\n  // C++ [temp.deduct.call]p10: [DR1391]\n  //   If deduction succeeds for all parameters that contain\n  //   template-parameters that participate in template argument deduction,\n  //   and all template arguments are explicitly specified, deduced, or\n  //   obtained from default template arguments, remaining parameters are then\n  //   compared with the corresponding arguments. For each remaining parameter\n  //   P with a type that was non-dependent before substitution of any\n  //   explicitly-specified template arguments, if the corresponding argument\n  //   A cannot be implicitly converted to P, deduction fails.\n  if (CheckNonDependent())\n    return TDK_NonDependentConversionFailure;\n\n  // Form the template argument list from the deduced template arguments.\n  TemplateArgumentList *DeducedArgumentList\n    = TemplateArgumentList::CreateCopy(Context, Builder);\n  Info.reset(DeducedArgumentList);\n\n  // Substitute the deduced template arguments into the function template\n  // declaration to produce the function template specialization.\n  DeclContext *Owner = FunctionTemplate->getDeclContext();\n  if (FunctionTemplate->getFriendObjectKind())\n    Owner = FunctionTemplate->getLexicalDeclContext();\n  MultiLevelTemplateArgumentList SubstArgs(*DeducedArgumentList);\n  Specialization = cast_or_null<FunctionDecl>(\n      SubstDecl(FunctionTemplate->getTemplatedDecl(), Owner, SubstArgs));\n  if (!Specialization || Specialization->isInvalidDecl())\n    return TDK_SubstitutionFailure;\n\n  assert(Specialization->getPrimaryTemplate()->getCanonicalDecl() ==\n         FunctionTemplate->getCanonicalDecl());\n\n  // If the template argument list is owned by the function template\n  // specialization, release it.\n  if (Specialization->getTemplateSpecializationArgs() == DeducedArgumentList &&\n      !Trap.hasErrorOccurred())\n    Info.take();\n\n  // There may have been an error that did not prevent us from constructing a\n  // declaration. Mark the declaration invalid and return with a substitution\n  // failure.\n  if (Trap.hasErrorOccurred()) {\n    Specialization->setInvalidDecl(true);\n    return TDK_SubstitutionFailure;\n  }\n\n  // C++2a [temp.deduct]p5\n  //   [...] When all template arguments have been deduced [...] all uses of\n  //   template parameters [...] are replaced with the corresponding deduced\n  //   or default argument values.\n  //   [...] If the function template has associated constraints\n  //   ([temp.constr.decl]), those constraints are checked for satisfaction\n  //   ([temp.constr.constr]). If the constraints are not satisfied, type\n  //   deduction fails.\n  if (!PartialOverloading ||\n      (Builder.size() == FunctionTemplate->getTemplateParameters()->size())) {\n    if (CheckInstantiatedFunctionTemplateConstraints(Info.getLocation(),\n            Specialization, Builder, Info.AssociatedConstraintsSatisfaction))\n      return TDK_MiscellaneousDeductionFailure;\n\n    if (!Info.AssociatedConstraintsSatisfaction.IsSatisfied) {\n      Info.reset(TemplateArgumentList::CreateCopy(Context, Builder));\n      return TDK_ConstraintsNotSatisfied;\n    }\n  }\n\n  if (OriginalCallArgs) {\n    // C++ [temp.deduct.call]p4:\n    //   In general, the deduction process attempts to find template argument\n    //   values that will make the deduced A identical to A (after the type A\n    //   is transformed as described above). [...]\n    llvm::SmallDenseMap<std::pair<unsigned, QualType>, QualType> DeducedATypes;\n    for (unsigned I = 0, N = OriginalCallArgs->size(); I != N; ++I) {\n      OriginalCallArg OriginalArg = (*OriginalCallArgs)[I];\n\n      auto ParamIdx = OriginalArg.ArgIdx;\n      if (ParamIdx >= Specialization->getNumParams())\n        // FIXME: This presumably means a pack ended up smaller than we\n        // expected while deducing. Should this not result in deduction\n        // failure? Can it even happen?\n        continue;\n\n      QualType DeducedA;\n      if (!OriginalArg.DecomposedParam) {\n        // P is one of the function parameters, just look up its substituted\n        // type.\n        DeducedA = Specialization->getParamDecl(ParamIdx)->getType();\n      } else {\n        // P is a decomposed element of a parameter corresponding to a\n        // braced-init-list argument. Substitute back into P to find the\n        // deduced A.\n        QualType &CacheEntry =\n            DeducedATypes[{ParamIdx, OriginalArg.OriginalParamType}];\n        if (CacheEntry.isNull()) {\n          ArgumentPackSubstitutionIndexRAII PackIndex(\n              *this, getPackIndexForParam(*this, FunctionTemplate, SubstArgs,\n                                          ParamIdx));\n          CacheEntry =\n              SubstType(OriginalArg.OriginalParamType, SubstArgs,\n                        Specialization->getTypeSpecStartLoc(),\n                        Specialization->getDeclName());\n        }\n        DeducedA = CacheEntry;\n      }\n\n      if (auto TDK =\n              CheckOriginalCallArgDeduction(*this, Info, OriginalArg, DeducedA))\n        return TDK;\n    }\n  }\n\n  // If we suppressed any diagnostics while performing template argument\n  // deduction, and if we haven't already instantiated this declaration,\n  // keep track of these diagnostics. They'll be emitted if this specialization\n  // is actually used.\n  if (Info.diag_begin() != Info.diag_end()) {\n    SuppressedDiagnosticsMap::iterator\n      Pos = SuppressedDiagnostics.find(Specialization->getCanonicalDecl());\n    if (Pos == SuppressedDiagnostics.end())\n        SuppressedDiagnostics[Specialization->getCanonicalDecl()]\n          .append(Info.diag_begin(), Info.diag_end());\n  }\n\n  return TDK_Success;\n}\n\n/// Gets the type of a function for template-argument-deducton\n/// purposes when it's considered as part of an overload set.\nstatic QualType GetTypeOfFunction(Sema &S, const OverloadExpr::FindResult &R,\n                                  FunctionDecl *Fn) {\n  // We may need to deduce the return type of the function now.\n  if (S.getLangOpts().CPlusPlus14 && Fn->getReturnType()->isUndeducedType() &&\n      S.DeduceReturnType(Fn, R.Expression->getExprLoc(), /*Diagnose*/ false))\n    return {};\n\n  if (CXXMethodDecl *Method = dyn_cast<CXXMethodDecl>(Fn))\n    if (Method->isInstance()) {\n      // An instance method that's referenced in a form that doesn't\n      // look like a member pointer is just invalid.\n      if (!R.HasFormOfMemberPointer)\n        return {};\n\n      return S.Context.getMemberPointerType(Fn->getType(),\n               S.Context.getTypeDeclType(Method->getParent()).getTypePtr());\n    }\n\n  if (!R.IsAddressOfOperand) return Fn->getType();\n  return S.Context.getPointerType(Fn->getType());\n}\n\n/// Apply the deduction rules for overload sets.\n///\n/// \\return the null type if this argument should be treated as an\n/// undeduced context\nstatic QualType\nResolveOverloadForDeduction(Sema &S, TemplateParameterList *TemplateParams,\n                            Expr *Arg, QualType ParamType,\n                            bool ParamWasReference) {\n\n  OverloadExpr::FindResult R = OverloadExpr::find(Arg);\n\n  OverloadExpr *Ovl = R.Expression;\n\n  // C++0x [temp.deduct.call]p4\n  unsigned TDF = 0;\n  if (ParamWasReference)\n    TDF |= TDF_ParamWithReferenceType;\n  if (R.IsAddressOfOperand)\n    TDF |= TDF_IgnoreQualifiers;\n\n  // C++0x [temp.deduct.call]p6:\n  //   When P is a function type, pointer to function type, or pointer\n  //   to member function type:\n\n  if (!ParamType->isFunctionType() &&\n      !ParamType->isFunctionPointerType() &&\n      !ParamType->isMemberFunctionPointerType()) {\n    if (Ovl->hasExplicitTemplateArgs()) {\n      // But we can still look for an explicit specialization.\n      if (FunctionDecl *ExplicitSpec\n            = S.ResolveSingleFunctionTemplateSpecialization(Ovl))\n        return GetTypeOfFunction(S, R, ExplicitSpec);\n    }\n\n    DeclAccessPair DAP;\n    if (FunctionDecl *Viable =\n            S.resolveAddressOfSingleOverloadCandidate(Arg, DAP))\n      return GetTypeOfFunction(S, R, Viable);\n\n    return {};\n  }\n\n  // Gather the explicit template arguments, if any.\n  TemplateArgumentListInfo ExplicitTemplateArgs;\n  if (Ovl->hasExplicitTemplateArgs())\n    Ovl->copyTemplateArgumentsInto(ExplicitTemplateArgs);\n  QualType Match;\n  for (UnresolvedSetIterator I = Ovl->decls_begin(),\n         E = Ovl->decls_end(); I != E; ++I) {\n    NamedDecl *D = (*I)->getUnderlyingDecl();\n\n    if (FunctionTemplateDecl *FunTmpl = dyn_cast<FunctionTemplateDecl>(D)) {\n      //   - If the argument is an overload set containing one or more\n      //     function templates, the parameter is treated as a\n      //     non-deduced context.\n      if (!Ovl->hasExplicitTemplateArgs())\n        return {};\n\n      // Otherwise, see if we can resolve a function type\n      FunctionDecl *Specialization = nullptr;\n      TemplateDeductionInfo Info(Ovl->getNameLoc());\n      if (S.DeduceTemplateArguments(FunTmpl, &ExplicitTemplateArgs,\n                                    Specialization, Info))\n        continue;\n\n      D = Specialization;\n    }\n\n    FunctionDecl *Fn = cast<FunctionDecl>(D);\n    QualType ArgType = GetTypeOfFunction(S, R, Fn);\n    if (ArgType.isNull()) continue;\n\n    // Function-to-pointer conversion.\n    if (!ParamWasReference && ParamType->isPointerType() &&\n        ArgType->isFunctionType())\n      ArgType = S.Context.getPointerType(ArgType);\n\n    //   - If the argument is an overload set (not containing function\n    //     templates), trial argument deduction is attempted using each\n    //     of the members of the set. If deduction succeeds for only one\n    //     of the overload set members, that member is used as the\n    //     argument value for the deduction. If deduction succeeds for\n    //     more than one member of the overload set the parameter is\n    //     treated as a non-deduced context.\n\n    // We do all of this in a fresh context per C++0x [temp.deduct.type]p2:\n    //   Type deduction is done independently for each P/A pair, and\n    //   the deduced template argument values are then combined.\n    // So we do not reject deductions which were made elsewhere.\n    SmallVector<DeducedTemplateArgument, 8>\n      Deduced(TemplateParams->size());\n    TemplateDeductionInfo Info(Ovl->getNameLoc());\n    Sema::TemplateDeductionResult Result\n      = DeduceTemplateArgumentsByTypeMatch(S, TemplateParams, ParamType,\n                                           ArgType, Info, Deduced, TDF);\n    if (Result) continue;\n    if (!Match.isNull())\n      return {};\n    Match = ArgType;\n  }\n\n  return Match;\n}\n\n/// Perform the adjustments to the parameter and argument types\n/// described in C++ [temp.deduct.call].\n///\n/// \\returns true if the caller should not attempt to perform any template\n/// argument deduction based on this P/A pair because the argument is an\n/// overloaded function set that could not be resolved.\nstatic bool AdjustFunctionParmAndArgTypesForDeduction(\n    Sema &S, TemplateParameterList *TemplateParams, unsigned FirstInnerIndex,\n    QualType &ParamType, QualType &ArgType, Expr *Arg, unsigned &TDF) {\n  // C++0x [temp.deduct.call]p3:\n  //   If P is a cv-qualified type, the top level cv-qualifiers of P's type\n  //   are ignored for type deduction.\n  if (ParamType.hasQualifiers())\n    ParamType = ParamType.getUnqualifiedType();\n\n  //   [...] If P is a reference type, the type referred to by P is\n  //   used for type deduction.\n  const ReferenceType *ParamRefType = ParamType->getAs<ReferenceType>();\n  if (ParamRefType)\n    ParamType = ParamRefType->getPointeeType();\n\n  // Overload sets usually make this parameter an undeduced context,\n  // but there are sometimes special circumstances.  Typically\n  // involving a template-id-expr.\n  if (ArgType == S.Context.OverloadTy) {\n    ArgType = ResolveOverloadForDeduction(S, TemplateParams,\n                                          Arg, ParamType,\n                                          ParamRefType != nullptr);\n    if (ArgType.isNull())\n      return true;\n  }\n\n  if (ParamRefType) {\n    // If the argument has incomplete array type, try to complete its type.\n    if (ArgType->isIncompleteArrayType())\n      ArgType = S.getCompletedType(Arg);\n\n    // C++1z [temp.deduct.call]p3:\n    //   If P is a forwarding reference and the argument is an lvalue, the type\n    //   \"lvalue reference to A\" is used in place of A for type deduction.\n    if (isForwardingReference(QualType(ParamRefType, 0), FirstInnerIndex) &&\n        Arg->isLValue()) {\n      if (S.getLangOpts().OpenCL  && !ArgType.hasAddressSpace())\n        ArgType = S.Context.getAddrSpaceQualType(ArgType, LangAS::opencl_generic);\n      ArgType = S.Context.getLValueReferenceType(ArgType);\n    }\n  } else {\n    // C++ [temp.deduct.call]p2:\n    //   If P is not a reference type:\n    //   - If A is an array type, the pointer type produced by the\n    //     array-to-pointer standard conversion (4.2) is used in place of\n    //     A for type deduction; otherwise,\n    if (ArgType->isArrayType())\n      ArgType = S.Context.getArrayDecayedType(ArgType);\n    //   - If A is a function type, the pointer type produced by the\n    //     function-to-pointer standard conversion (4.3) is used in place\n    //     of A for type deduction; otherwise,\n    else if (ArgType->isFunctionType())\n      ArgType = S.Context.getPointerType(ArgType);\n    else {\n      // - If A is a cv-qualified type, the top level cv-qualifiers of A's\n      //   type are ignored for type deduction.\n      ArgType = ArgType.getUnqualifiedType();\n    }\n  }\n\n  // C++0x [temp.deduct.call]p4:\n  //   In general, the deduction process attempts to find template argument\n  //   values that will make the deduced A identical to A (after the type A\n  //   is transformed as described above). [...]\n  TDF = TDF_SkipNonDependent;\n\n  //     - If the original P is a reference type, the deduced A (i.e., the\n  //       type referred to by the reference) can be more cv-qualified than\n  //       the transformed A.\n  if (ParamRefType)\n    TDF |= TDF_ParamWithReferenceType;\n  //     - The transformed A can be another pointer or pointer to member\n  //       type that can be converted to the deduced A via a qualification\n  //       conversion (4.4).\n  if (ArgType->isPointerType() || ArgType->isMemberPointerType() ||\n      ArgType->isObjCObjectPointerType())\n    TDF |= TDF_IgnoreQualifiers;\n  //     - If P is a class and P has the form simple-template-id, then the\n  //       transformed A can be a derived class of the deduced A. Likewise,\n  //       if P is a pointer to a class of the form simple-template-id, the\n  //       transformed A can be a pointer to a derived class pointed to by\n  //       the deduced A.\n  if (isSimpleTemplateIdType(ParamType) ||\n      (isa<PointerType>(ParamType) &&\n       isSimpleTemplateIdType(\n                              ParamType->getAs<PointerType>()->getPointeeType())))\n    TDF |= TDF_DerivedClass;\n\n  return false;\n}\n\nstatic bool\nhasDeducibleTemplateParameters(Sema &S, FunctionTemplateDecl *FunctionTemplate,\n                               QualType T);\n\nstatic Sema::TemplateDeductionResult DeduceTemplateArgumentsFromCallArgument(\n    Sema &S, TemplateParameterList *TemplateParams, unsigned FirstInnerIndex,\n    QualType ParamType, Expr *Arg, TemplateDeductionInfo &Info,\n    SmallVectorImpl<DeducedTemplateArgument> &Deduced,\n    SmallVectorImpl<Sema::OriginalCallArg> &OriginalCallArgs,\n    bool DecomposedParam, unsigned ArgIdx, unsigned TDF);\n\n/// Attempt template argument deduction from an initializer list\n///        deemed to be an argument in a function call.\nstatic Sema::TemplateDeductionResult DeduceFromInitializerList(\n    Sema &S, TemplateParameterList *TemplateParams, QualType AdjustedParamType,\n    InitListExpr *ILE, TemplateDeductionInfo &Info,\n    SmallVectorImpl<DeducedTemplateArgument> &Deduced,\n    SmallVectorImpl<Sema::OriginalCallArg> &OriginalCallArgs, unsigned ArgIdx,\n    unsigned TDF) {\n  // C++ [temp.deduct.call]p1: (CWG 1591)\n  //   If removing references and cv-qualifiers from P gives\n  //   std::initializer_list<P0> or P0[N] for some P0 and N and the argument is\n  //   a non-empty initializer list, then deduction is performed instead for\n  //   each element of the initializer list, taking P0 as a function template\n  //   parameter type and the initializer element as its argument\n  //\n  // We've already removed references and cv-qualifiers here.\n  if (!ILE->getNumInits())\n    return Sema::TDK_Success;\n\n  QualType ElTy;\n  auto *ArrTy = S.Context.getAsArrayType(AdjustedParamType);\n  if (ArrTy)\n    ElTy = ArrTy->getElementType();\n  else if (!S.isStdInitializerList(AdjustedParamType, &ElTy)) {\n    //   Otherwise, an initializer list argument causes the parameter to be\n    //   considered a non-deduced context\n    return Sema::TDK_Success;\n  }\n\n  // Resolving a core issue: a braced-init-list containing any designators is\n  // a non-deduced context.\n  for (Expr *E : ILE->inits())\n    if (isa<DesignatedInitExpr>(E))\n      return Sema::TDK_Success;\n\n  // Deduction only needs to be done for dependent types.\n  if (ElTy->isDependentType()) {\n    for (Expr *E : ILE->inits()) {\n      if (auto Result = DeduceTemplateArgumentsFromCallArgument(\n              S, TemplateParams, 0, ElTy, E, Info, Deduced, OriginalCallArgs, true,\n              ArgIdx, TDF))\n        return Result;\n    }\n  }\n\n  //   in the P0[N] case, if N is a non-type template parameter, N is deduced\n  //   from the length of the initializer list.\n  if (auto *DependentArrTy = dyn_cast_or_null<DependentSizedArrayType>(ArrTy)) {\n    // Determine the array bound is something we can deduce.\n    if (const NonTypeTemplateParmDecl *NTTP =\n            getDeducedParameterFromExpr(Info, DependentArrTy->getSizeExpr())) {\n      // We can perform template argument deduction for the given non-type\n      // template parameter.\n      // C++ [temp.deduct.type]p13:\n      //   The type of N in the type T[N] is std::size_t.\n      QualType T = S.Context.getSizeType();\n      llvm::APInt Size(S.Context.getIntWidth(T), ILE->getNumInits());\n      if (auto Result = DeduceNonTypeTemplateArgument(\n              S, TemplateParams, NTTP, llvm::APSInt(Size), T,\n              /*ArrayBound=*/true, Info, Deduced))\n        return Result;\n    }\n  }\n\n  return Sema::TDK_Success;\n}\n\n/// Perform template argument deduction per [temp.deduct.call] for a\n///        single parameter / argument pair.\nstatic Sema::TemplateDeductionResult DeduceTemplateArgumentsFromCallArgument(\n    Sema &S, TemplateParameterList *TemplateParams, unsigned FirstInnerIndex,\n    QualType ParamType, Expr *Arg, TemplateDeductionInfo &Info,\n    SmallVectorImpl<DeducedTemplateArgument> &Deduced,\n    SmallVectorImpl<Sema::OriginalCallArg> &OriginalCallArgs,\n    bool DecomposedParam, unsigned ArgIdx, unsigned TDF) {\n  QualType ArgType = Arg->getType();\n  QualType OrigParamType = ParamType;\n\n  //   If P is a reference type [...]\n  //   If P is a cv-qualified type [...]\n  if (AdjustFunctionParmAndArgTypesForDeduction(\n          S, TemplateParams, FirstInnerIndex, ParamType, ArgType, Arg, TDF))\n    return Sema::TDK_Success;\n\n  //   If [...] the argument is a non-empty initializer list [...]\n  if (InitListExpr *ILE = dyn_cast<InitListExpr>(Arg))\n    return DeduceFromInitializerList(S, TemplateParams, ParamType, ILE, Info,\n                                     Deduced, OriginalCallArgs, ArgIdx, TDF);\n\n  //   [...] the deduction process attempts to find template argument values\n  //   that will make the deduced A identical to A\n  //\n  // Keep track of the argument type and corresponding parameter index,\n  // so we can check for compatibility between the deduced A and A.\n  OriginalCallArgs.push_back(\n      Sema::OriginalCallArg(OrigParamType, DecomposedParam, ArgIdx, ArgType));\n  return DeduceTemplateArgumentsByTypeMatch(S, TemplateParams, ParamType,\n                                            ArgType, Info, Deduced, TDF);\n}\n\n/// Perform template argument deduction from a function call\n/// (C++ [temp.deduct.call]).\n///\n/// \\param FunctionTemplate the function template for which we are performing\n/// template argument deduction.\n///\n/// \\param ExplicitTemplateArgs the explicit template arguments provided\n/// for this call.\n///\n/// \\param Args the function call arguments\n///\n/// \\param Specialization if template argument deduction was successful,\n/// this will be set to the function template specialization produced by\n/// template argument deduction.\n///\n/// \\param Info the argument will be updated to provide additional information\n/// about template argument deduction.\n///\n/// \\param CheckNonDependent A callback to invoke to check conversions for\n/// non-dependent parameters, between deduction and substitution, per DR1391.\n/// If this returns true, substitution will be skipped and we return\n/// TDK_NonDependentConversionFailure. The callback is passed the parameter\n/// types (after substituting explicit template arguments).\n///\n/// \\returns the result of template argument deduction.\nSema::TemplateDeductionResult Sema::DeduceTemplateArguments(\n    FunctionTemplateDecl *FunctionTemplate,\n    TemplateArgumentListInfo *ExplicitTemplateArgs, ArrayRef<Expr *> Args,\n    FunctionDecl *&Specialization, TemplateDeductionInfo &Info,\n    bool PartialOverloading,\n    llvm::function_ref<bool(ArrayRef<QualType>)> CheckNonDependent) {\n  if (FunctionTemplate->isInvalidDecl())\n    return TDK_Invalid;\n\n  FunctionDecl *Function = FunctionTemplate->getTemplatedDecl();\n  unsigned NumParams = Function->getNumParams();\n\n  unsigned FirstInnerIndex = getFirstInnerIndex(FunctionTemplate);\n\n  // C++ [temp.deduct.call]p1:\n  //   Template argument deduction is done by comparing each function template\n  //   parameter type (call it P) with the type of the corresponding argument\n  //   of the call (call it A) as described below.\n  if (Args.size() < Function->getMinRequiredArguments() && !PartialOverloading)\n    return TDK_TooFewArguments;\n  else if (TooManyArguments(NumParams, Args.size(), PartialOverloading)) {\n    const auto *Proto = Function->getType()->castAs<FunctionProtoType>();\n    if (Proto->isTemplateVariadic())\n      /* Do nothing */;\n    else if (!Proto->isVariadic())\n      return TDK_TooManyArguments;\n  }\n\n  // The types of the parameters from which we will perform template argument\n  // deduction.\n  LocalInstantiationScope InstScope(*this);\n  TemplateParameterList *TemplateParams\n    = FunctionTemplate->getTemplateParameters();\n  SmallVector<DeducedTemplateArgument, 4> Deduced;\n  SmallVector<QualType, 8> ParamTypes;\n  unsigned NumExplicitlySpecified = 0;\n  if (ExplicitTemplateArgs) {\n    TemplateDeductionResult Result;\n    runWithSufficientStackSpace(Info.getLocation(), [&] {\n      Result = SubstituteExplicitTemplateArguments(\n          FunctionTemplate, *ExplicitTemplateArgs, Deduced, ParamTypes, nullptr,\n          Info);\n    });\n    if (Result)\n      return Result;\n\n    NumExplicitlySpecified = Deduced.size();\n  } else {\n    // Just fill in the parameter types from the function declaration.\n    for (unsigned I = 0; I != NumParams; ++I)\n      ParamTypes.push_back(Function->getParamDecl(I)->getType());\n  }\n\n  SmallVector<OriginalCallArg, 8> OriginalCallArgs;\n\n  // Deduce an argument of type ParamType from an expression with index ArgIdx.\n  auto DeduceCallArgument = [&](QualType ParamType, unsigned ArgIdx) {\n    // C++ [demp.deduct.call]p1: (DR1391)\n    //   Template argument deduction is done by comparing each function template\n    //   parameter that contains template-parameters that participate in\n    //   template argument deduction ...\n    if (!hasDeducibleTemplateParameters(*this, FunctionTemplate, ParamType))\n      return Sema::TDK_Success;\n\n    //   ... with the type of the corresponding argument\n    return DeduceTemplateArgumentsFromCallArgument(\n        *this, TemplateParams, FirstInnerIndex, ParamType, Args[ArgIdx], Info, Deduced,\n        OriginalCallArgs, /*Decomposed*/false, ArgIdx, /*TDF*/ 0);\n  };\n\n  // Deduce template arguments from the function parameters.\n  Deduced.resize(TemplateParams->size());\n  SmallVector<QualType, 8> ParamTypesForArgChecking;\n  for (unsigned ParamIdx = 0, NumParamTypes = ParamTypes.size(), ArgIdx = 0;\n       ParamIdx != NumParamTypes; ++ParamIdx) {\n    QualType ParamType = ParamTypes[ParamIdx];\n\n    const PackExpansionType *ParamExpansion =\n        dyn_cast<PackExpansionType>(ParamType);\n    if (!ParamExpansion) {\n      // Simple case: matching a function parameter to a function argument.\n      if (ArgIdx >= Args.size())\n        break;\n\n      ParamTypesForArgChecking.push_back(ParamType);\n      if (auto Result = DeduceCallArgument(ParamType, ArgIdx++))\n        return Result;\n\n      continue;\n    }\n\n    QualType ParamPattern = ParamExpansion->getPattern();\n    PackDeductionScope PackScope(*this, TemplateParams, Deduced, Info,\n                                 ParamPattern);\n\n    // C++0x [temp.deduct.call]p1:\n    //   For a function parameter pack that occurs at the end of the\n    //   parameter-declaration-list, the type A of each remaining argument of\n    //   the call is compared with the type P of the declarator-id of the\n    //   function parameter pack. Each comparison deduces template arguments\n    //   for subsequent positions in the template parameter packs expanded by\n    //   the function parameter pack. When a function parameter pack appears\n    //   in a non-deduced context [not at the end of the list], the type of\n    //   that parameter pack is never deduced.\n    //\n    // FIXME: The above rule allows the size of the parameter pack to change\n    // after we skip it (in the non-deduced case). That makes no sense, so\n    // we instead notionally deduce the pack against N arguments, where N is\n    // the length of the explicitly-specified pack if it's expanded by the\n    // parameter pack and 0 otherwise, and we treat each deduction as a\n    // non-deduced context.\n    if (ParamIdx + 1 == NumParamTypes || PackScope.hasFixedArity()) {\n      for (; ArgIdx < Args.size() && PackScope.hasNextElement();\n           PackScope.nextPackElement(), ++ArgIdx) {\n        ParamTypesForArgChecking.push_back(ParamPattern);\n        if (auto Result = DeduceCallArgument(ParamPattern, ArgIdx))\n          return Result;\n      }\n    } else {\n      // If the parameter type contains an explicitly-specified pack that we\n      // could not expand, skip the number of parameters notionally created\n      // by the expansion.\n      Optional<unsigned> NumExpansions = ParamExpansion->getNumExpansions();\n      if (NumExpansions && !PackScope.isPartiallyExpanded()) {\n        for (unsigned I = 0; I != *NumExpansions && ArgIdx < Args.size();\n             ++I, ++ArgIdx) {\n          ParamTypesForArgChecking.push_back(ParamPattern);\n          // FIXME: Should we add OriginalCallArgs for these? What if the\n          // corresponding argument is a list?\n          PackScope.nextPackElement();\n        }\n      }\n    }\n\n    // Build argument packs for each of the parameter packs expanded by this\n    // pack expansion.\n    if (auto Result = PackScope.finish())\n      return Result;\n  }\n\n  // Capture the context in which the function call is made. This is the context\n  // that is needed when the accessibility of template arguments is checked.\n  DeclContext *CallingCtx = CurContext;\n\n  TemplateDeductionResult Result;\n  runWithSufficientStackSpace(Info.getLocation(), [&] {\n    Result = FinishTemplateArgumentDeduction(\n        FunctionTemplate, Deduced, NumExplicitlySpecified, Specialization, Info,\n        &OriginalCallArgs, PartialOverloading, [&, CallingCtx]() {\n          ContextRAII SavedContext(*this, CallingCtx);\n          return CheckNonDependent(ParamTypesForArgChecking);\n        });\n  });\n  return Result;\n}\n\nQualType Sema::adjustCCAndNoReturn(QualType ArgFunctionType,\n                                   QualType FunctionType,\n                                   bool AdjustExceptionSpec) {\n  if (ArgFunctionType.isNull())\n    return ArgFunctionType;\n\n  const auto *FunctionTypeP = FunctionType->castAs<FunctionProtoType>();\n  const auto *ArgFunctionTypeP = ArgFunctionType->castAs<FunctionProtoType>();\n  FunctionProtoType::ExtProtoInfo EPI = ArgFunctionTypeP->getExtProtoInfo();\n  bool Rebuild = false;\n\n  CallingConv CC = FunctionTypeP->getCallConv();\n  if (EPI.ExtInfo.getCC() != CC) {\n    EPI.ExtInfo = EPI.ExtInfo.withCallingConv(CC);\n    Rebuild = true;\n  }\n\n  bool NoReturn = FunctionTypeP->getNoReturnAttr();\n  if (EPI.ExtInfo.getNoReturn() != NoReturn) {\n    EPI.ExtInfo = EPI.ExtInfo.withNoReturn(NoReturn);\n    Rebuild = true;\n  }\n\n  if (AdjustExceptionSpec && (FunctionTypeP->hasExceptionSpec() ||\n                              ArgFunctionTypeP->hasExceptionSpec())) {\n    EPI.ExceptionSpec = FunctionTypeP->getExtProtoInfo().ExceptionSpec;\n    Rebuild = true;\n  }\n\n  if (!Rebuild)\n    return ArgFunctionType;\n\n  return Context.getFunctionType(ArgFunctionTypeP->getReturnType(),\n                                 ArgFunctionTypeP->getParamTypes(), EPI);\n}\n\n/// Deduce template arguments when taking the address of a function\n/// template (C++ [temp.deduct.funcaddr]) or matching a specialization to\n/// a template.\n///\n/// \\param FunctionTemplate the function template for which we are performing\n/// template argument deduction.\n///\n/// \\param ExplicitTemplateArgs the explicitly-specified template\n/// arguments.\n///\n/// \\param ArgFunctionType the function type that will be used as the\n/// \"argument\" type (A) when performing template argument deduction from the\n/// function template's function type. This type may be NULL, if there is no\n/// argument type to compare against, in C++0x [temp.arg.explicit]p3.\n///\n/// \\param Specialization if template argument deduction was successful,\n/// this will be set to the function template specialization produced by\n/// template argument deduction.\n///\n/// \\param Info the argument will be updated to provide additional information\n/// about template argument deduction.\n///\n/// \\param IsAddressOfFunction If \\c true, we are deducing as part of taking\n/// the address of a function template per [temp.deduct.funcaddr] and\n/// [over.over]. If \\c false, we are looking up a function template\n/// specialization based on its signature, per [temp.deduct.decl].\n///\n/// \\returns the result of template argument deduction.\nSema::TemplateDeductionResult Sema::DeduceTemplateArguments(\n    FunctionTemplateDecl *FunctionTemplate,\n    TemplateArgumentListInfo *ExplicitTemplateArgs, QualType ArgFunctionType,\n    FunctionDecl *&Specialization, TemplateDeductionInfo &Info,\n    bool IsAddressOfFunction) {\n  if (FunctionTemplate->isInvalidDecl())\n    return TDK_Invalid;\n\n  FunctionDecl *Function = FunctionTemplate->getTemplatedDecl();\n  TemplateParameterList *TemplateParams\n    = FunctionTemplate->getTemplateParameters();\n  QualType FunctionType = Function->getType();\n\n  // Substitute any explicit template arguments.\n  LocalInstantiationScope InstScope(*this);\n  SmallVector<DeducedTemplateArgument, 4> Deduced;\n  unsigned NumExplicitlySpecified = 0;\n  SmallVector<QualType, 4> ParamTypes;\n  if (ExplicitTemplateArgs) {\n    TemplateDeductionResult Result;\n    runWithSufficientStackSpace(Info.getLocation(), [&] {\n      Result = SubstituteExplicitTemplateArguments(\n          FunctionTemplate, *ExplicitTemplateArgs, Deduced, ParamTypes,\n          &FunctionType, Info);\n    });\n    if (Result)\n      return Result;\n\n    NumExplicitlySpecified = Deduced.size();\n  }\n\n  // When taking the address of a function, we require convertibility of\n  // the resulting function type. Otherwise, we allow arbitrary mismatches\n  // of calling convention and noreturn.\n  if (!IsAddressOfFunction)\n    ArgFunctionType = adjustCCAndNoReturn(ArgFunctionType, FunctionType,\n                                          /*AdjustExceptionSpec*/false);\n\n  // Unevaluated SFINAE context.\n  EnterExpressionEvaluationContext Unevaluated(\n      *this, Sema::ExpressionEvaluationContext::Unevaluated);\n  SFINAETrap Trap(*this);\n\n  Deduced.resize(TemplateParams->size());\n\n  // If the function has a deduced return type, substitute it for a dependent\n  // type so that we treat it as a non-deduced context in what follows. If we\n  // are looking up by signature, the signature type should also have a deduced\n  // return type, which we instead expect to exactly match.\n  bool HasDeducedReturnType = false;\n  if (getLangOpts().CPlusPlus14 && IsAddressOfFunction &&\n      Function->getReturnType()->getContainedAutoType()) {\n    FunctionType = SubstAutoType(FunctionType, Context.DependentTy);\n    HasDeducedReturnType = true;\n  }\n\n  if (!ArgFunctionType.isNull()) {\n    unsigned TDF =\n        TDF_TopLevelParameterTypeList | TDF_AllowCompatibleFunctionType;\n    // Deduce template arguments from the function type.\n    if (TemplateDeductionResult Result\n          = DeduceTemplateArgumentsByTypeMatch(*this, TemplateParams,\n                                               FunctionType, ArgFunctionType,\n                                               Info, Deduced, TDF))\n      return Result;\n  }\n\n  TemplateDeductionResult Result;\n  runWithSufficientStackSpace(Info.getLocation(), [&] {\n    Result = FinishTemplateArgumentDeduction(FunctionTemplate, Deduced,\n                                             NumExplicitlySpecified,\n                                             Specialization, Info);\n  });\n  if (Result)\n    return Result;\n\n  // If the function has a deduced return type, deduce it now, so we can check\n  // that the deduced function type matches the requested type.\n  if (HasDeducedReturnType &&\n      Specialization->getReturnType()->isUndeducedType() &&\n      DeduceReturnType(Specialization, Info.getLocation(), false))\n    return TDK_MiscellaneousDeductionFailure;\n\n  // If the function has a dependent exception specification, resolve it now,\n  // so we can check that the exception specification matches.\n  auto *SpecializationFPT =\n      Specialization->getType()->castAs<FunctionProtoType>();\n  if (getLangOpts().CPlusPlus17 &&\n      isUnresolvedExceptionSpec(SpecializationFPT->getExceptionSpecType()) &&\n      !ResolveExceptionSpec(Info.getLocation(), SpecializationFPT))\n    return TDK_MiscellaneousDeductionFailure;\n\n  // Adjust the exception specification of the argument to match the\n  // substituted and resolved type we just formed. (Calling convention and\n  // noreturn can't be dependent, so we don't actually need this for them\n  // right now.)\n  QualType SpecializationType = Specialization->getType();\n  if (!IsAddressOfFunction)\n    ArgFunctionType = adjustCCAndNoReturn(ArgFunctionType, SpecializationType,\n                                          /*AdjustExceptionSpec*/true);\n\n  // If the requested function type does not match the actual type of the\n  // specialization with respect to arguments of compatible pointer to function\n  // types, template argument deduction fails.\n  if (!ArgFunctionType.isNull()) {\n    if (IsAddressOfFunction &&\n        !isSameOrCompatibleFunctionType(\n            Context.getCanonicalType(SpecializationType),\n            Context.getCanonicalType(ArgFunctionType)))\n      return TDK_MiscellaneousDeductionFailure;\n\n    if (!IsAddressOfFunction &&\n        !Context.hasSameType(SpecializationType, ArgFunctionType))\n      return TDK_MiscellaneousDeductionFailure;\n  }\n\n  return TDK_Success;\n}\n\n/// Deduce template arguments for a templated conversion\n/// function (C++ [temp.deduct.conv]) and, if successful, produce a\n/// conversion function template specialization.\nSema::TemplateDeductionResult\nSema::DeduceTemplateArguments(FunctionTemplateDecl *ConversionTemplate,\n                              QualType ToType,\n                              CXXConversionDecl *&Specialization,\n                              TemplateDeductionInfo &Info) {\n  if (ConversionTemplate->isInvalidDecl())\n    return TDK_Invalid;\n\n  CXXConversionDecl *ConversionGeneric\n    = cast<CXXConversionDecl>(ConversionTemplate->getTemplatedDecl());\n\n  QualType FromType = ConversionGeneric->getConversionType();\n\n  // Canonicalize the types for deduction.\n  QualType P = Context.getCanonicalType(FromType);\n  QualType A = Context.getCanonicalType(ToType);\n\n  // C++0x [temp.deduct.conv]p2:\n  //   If P is a reference type, the type referred to by P is used for\n  //   type deduction.\n  if (const ReferenceType *PRef = P->getAs<ReferenceType>())\n    P = PRef->getPointeeType();\n\n  // C++0x [temp.deduct.conv]p4:\n  //   [...] If A is a reference type, the type referred to by A is used\n  //   for type deduction.\n  if (const ReferenceType *ARef = A->getAs<ReferenceType>()) {\n    A = ARef->getPointeeType();\n    // We work around a defect in the standard here: cv-qualifiers are also\n    // removed from P and A in this case, unless P was a reference type. This\n    // seems to mostly match what other compilers are doing.\n    if (!FromType->getAs<ReferenceType>()) {\n      A = A.getUnqualifiedType();\n      P = P.getUnqualifiedType();\n    }\n\n  // C++ [temp.deduct.conv]p3:\n  //\n  //   If A is not a reference type:\n  } else {\n    assert(!A->isReferenceType() && \"Reference types were handled above\");\n\n    //   - If P is an array type, the pointer type produced by the\n    //     array-to-pointer standard conversion (4.2) is used in place\n    //     of P for type deduction; otherwise,\n    if (P->isArrayType())\n      P = Context.getArrayDecayedType(P);\n    //   - If P is a function type, the pointer type produced by the\n    //     function-to-pointer standard conversion (4.3) is used in\n    //     place of P for type deduction; otherwise,\n    else if (P->isFunctionType())\n      P = Context.getPointerType(P);\n    //   - If P is a cv-qualified type, the top level cv-qualifiers of\n    //     P's type are ignored for type deduction.\n    else\n      P = P.getUnqualifiedType();\n\n    // C++0x [temp.deduct.conv]p4:\n    //   If A is a cv-qualified type, the top level cv-qualifiers of A's\n    //   type are ignored for type deduction. If A is a reference type, the type\n    //   referred to by A is used for type deduction.\n    A = A.getUnqualifiedType();\n  }\n\n  // Unevaluated SFINAE context.\n  EnterExpressionEvaluationContext Unevaluated(\n      *this, Sema::ExpressionEvaluationContext::Unevaluated);\n  SFINAETrap Trap(*this);\n\n  // C++ [temp.deduct.conv]p1:\n  //   Template argument deduction is done by comparing the return\n  //   type of the template conversion function (call it P) with the\n  //   type that is required as the result of the conversion (call it\n  //   A) as described in 14.8.2.4.\n  TemplateParameterList *TemplateParams\n    = ConversionTemplate->getTemplateParameters();\n  SmallVector<DeducedTemplateArgument, 4> Deduced;\n  Deduced.resize(TemplateParams->size());\n\n  // C++0x [temp.deduct.conv]p4:\n  //   In general, the deduction process attempts to find template\n  //   argument values that will make the deduced A identical to\n  //   A. However, there are two cases that allow a difference:\n  unsigned TDF = 0;\n  //     - If the original A is a reference type, A can be more\n  //       cv-qualified than the deduced A (i.e., the type referred to\n  //       by the reference)\n  if (ToType->isReferenceType())\n    TDF |= TDF_ArgWithReferenceType;\n  //     - The deduced A can be another pointer or pointer to member\n  //       type that can be converted to A via a qualification\n  //       conversion.\n  //\n  // (C++0x [temp.deduct.conv]p6 clarifies that this only happens when\n  // both P and A are pointers or member pointers. In this case, we\n  // just ignore cv-qualifiers completely).\n  if ((P->isPointerType() && A->isPointerType()) ||\n      (P->isMemberPointerType() && A->isMemberPointerType()))\n    TDF |= TDF_IgnoreQualifiers;\n  if (TemplateDeductionResult Result\n        = DeduceTemplateArgumentsByTypeMatch(*this, TemplateParams,\n                                             P, A, Info, Deduced, TDF))\n    return Result;\n\n  // Create an Instantiation Scope for finalizing the operator.\n  LocalInstantiationScope InstScope(*this);\n  // Finish template argument deduction.\n  FunctionDecl *ConversionSpecialized = nullptr;\n  TemplateDeductionResult Result;\n  runWithSufficientStackSpace(Info.getLocation(), [&] {\n    Result = FinishTemplateArgumentDeduction(ConversionTemplate, Deduced, 0,\n                                             ConversionSpecialized, Info);\n  });\n  Specialization = cast_or_null<CXXConversionDecl>(ConversionSpecialized);\n  return Result;\n}\n\n/// Deduce template arguments for a function template when there is\n/// nothing to deduce against (C++0x [temp.arg.explicit]p3).\n///\n/// \\param FunctionTemplate the function template for which we are performing\n/// template argument deduction.\n///\n/// \\param ExplicitTemplateArgs the explicitly-specified template\n/// arguments.\n///\n/// \\param Specialization if template argument deduction was successful,\n/// this will be set to the function template specialization produced by\n/// template argument deduction.\n///\n/// \\param Info the argument will be updated to provide additional information\n/// about template argument deduction.\n///\n/// \\param IsAddressOfFunction If \\c true, we are deducing as part of taking\n/// the address of a function template in a context where we do not have a\n/// target type, per [over.over]. If \\c false, we are looking up a function\n/// template specialization based on its signature, which only happens when\n/// deducing a function parameter type from an argument that is a template-id\n/// naming a function template specialization.\n///\n/// \\returns the result of template argument deduction.\nSema::TemplateDeductionResult Sema::DeduceTemplateArguments(\n    FunctionTemplateDecl *FunctionTemplate,\n    TemplateArgumentListInfo *ExplicitTemplateArgs,\n    FunctionDecl *&Specialization, TemplateDeductionInfo &Info,\n    bool IsAddressOfFunction) {\n  return DeduceTemplateArguments(FunctionTemplate, ExplicitTemplateArgs,\n                                 QualType(), Specialization, Info,\n                                 IsAddressOfFunction);\n}\n\nnamespace {\n  struct DependentAuto { bool IsPack; };\n\n  /// Substitute the 'auto' specifier or deduced template specialization type\n  /// specifier within a type for a given replacement type.\n  class SubstituteDeducedTypeTransform :\n      public TreeTransform<SubstituteDeducedTypeTransform> {\n    QualType Replacement;\n    bool ReplacementIsPack;\n    bool UseTypeSugar;\n\n  public:\n    SubstituteDeducedTypeTransform(Sema &SemaRef, DependentAuto DA)\n        : TreeTransform<SubstituteDeducedTypeTransform>(SemaRef), Replacement(),\n          ReplacementIsPack(DA.IsPack), UseTypeSugar(true) {}\n\n    SubstituteDeducedTypeTransform(Sema &SemaRef, QualType Replacement,\n                                   bool UseTypeSugar = true)\n        : TreeTransform<SubstituteDeducedTypeTransform>(SemaRef),\n          Replacement(Replacement), ReplacementIsPack(false),\n          UseTypeSugar(UseTypeSugar) {}\n\n    QualType TransformDesugared(TypeLocBuilder &TLB, DeducedTypeLoc TL) {\n      assert(isa<TemplateTypeParmType>(Replacement) &&\n             \"unexpected unsugared replacement kind\");\n      QualType Result = Replacement;\n      TemplateTypeParmTypeLoc NewTL = TLB.push<TemplateTypeParmTypeLoc>(Result);\n      NewTL.setNameLoc(TL.getNameLoc());\n      return Result;\n    }\n\n    QualType TransformAutoType(TypeLocBuilder &TLB, AutoTypeLoc TL) {\n      // If we're building the type pattern to deduce against, don't wrap the\n      // substituted type in an AutoType. Certain template deduction rules\n      // apply only when a template type parameter appears directly (and not if\n      // the parameter is found through desugaring). For instance:\n      //   auto &&lref = lvalue;\n      // must transform into \"rvalue reference to T\" not \"rvalue reference to\n      // auto type deduced as T\" in order for [temp.deduct.call]p3 to apply.\n      //\n      // FIXME: Is this still necessary?\n      if (!UseTypeSugar)\n        return TransformDesugared(TLB, TL);\n\n      QualType Result = SemaRef.Context.getAutoType(\n          Replacement, TL.getTypePtr()->getKeyword(), Replacement.isNull(),\n          ReplacementIsPack, TL.getTypePtr()->getTypeConstraintConcept(),\n          TL.getTypePtr()->getTypeConstraintArguments());\n      auto NewTL = TLB.push<AutoTypeLoc>(Result);\n      NewTL.copy(TL);\n      return Result;\n    }\n\n    QualType TransformDeducedTemplateSpecializationType(\n        TypeLocBuilder &TLB, DeducedTemplateSpecializationTypeLoc TL) {\n      if (!UseTypeSugar)\n        return TransformDesugared(TLB, TL);\n\n      QualType Result = SemaRef.Context.getDeducedTemplateSpecializationType(\n          TL.getTypePtr()->getTemplateName(),\n          Replacement, Replacement.isNull());\n      auto NewTL = TLB.push<DeducedTemplateSpecializationTypeLoc>(Result);\n      NewTL.setNameLoc(TL.getNameLoc());\n      return Result;\n    }\n\n    ExprResult TransformLambdaExpr(LambdaExpr *E) {\n      // Lambdas never need to be transformed.\n      return E;\n    }\n\n    QualType Apply(TypeLoc TL) {\n      // Create some scratch storage for the transformed type locations.\n      // FIXME: We're just going to throw this information away. Don't build it.\n      TypeLocBuilder TLB;\n      TLB.reserve(TL.getFullDataSize());\n      return TransformType(TLB, TL);\n    }\n  };\n\n} // namespace\n\nSema::DeduceAutoResult\nSema::DeduceAutoType(TypeSourceInfo *Type, Expr *&Init, QualType &Result,\n                     Optional<unsigned> DependentDeductionDepth,\n                     bool IgnoreConstraints) {\n  return DeduceAutoType(Type->getTypeLoc(), Init, Result,\n                        DependentDeductionDepth, IgnoreConstraints);\n}\n\n/// Attempt to produce an informative diagostic explaining why auto deduction\n/// failed.\n/// \\return \\c true if diagnosed, \\c false if not.\nstatic bool diagnoseAutoDeductionFailure(Sema &S,\n                                         Sema::TemplateDeductionResult TDK,\n                                         TemplateDeductionInfo &Info,\n                                         ArrayRef<SourceRange> Ranges) {\n  switch (TDK) {\n  case Sema::TDK_Inconsistent: {\n    // Inconsistent deduction means we were deducing from an initializer list.\n    auto D = S.Diag(Info.getLocation(), diag::err_auto_inconsistent_deduction);\n    D << Info.FirstArg << Info.SecondArg;\n    for (auto R : Ranges)\n      D << R;\n    return true;\n  }\n\n  // FIXME: Are there other cases for which a custom diagnostic is more useful\n  // than the basic \"types don't match\" diagnostic?\n\n  default:\n    return false;\n  }\n}\n\nstatic Sema::DeduceAutoResult\nCheckDeducedPlaceholderConstraints(Sema &S, const AutoType &Type,\n                                   AutoTypeLoc TypeLoc, QualType Deduced) {\n  ConstraintSatisfaction Satisfaction;\n  ConceptDecl *Concept = Type.getTypeConstraintConcept();\n  TemplateArgumentListInfo TemplateArgs(TypeLoc.getLAngleLoc(),\n                                        TypeLoc.getRAngleLoc());\n  TemplateArgs.addArgument(\n      TemplateArgumentLoc(TemplateArgument(Deduced),\n                          S.Context.getTrivialTypeSourceInfo(\n                              Deduced, TypeLoc.getNameLoc())));\n  for (unsigned I = 0, C = TypeLoc.getNumArgs(); I != C; ++I)\n    TemplateArgs.addArgument(TypeLoc.getArgLoc(I));\n\n  llvm::SmallVector<TemplateArgument, 4> Converted;\n  if (S.CheckTemplateArgumentList(Concept, SourceLocation(), TemplateArgs,\n                                  /*PartialTemplateArgs=*/false, Converted))\n    return Sema::DAR_FailedAlreadyDiagnosed;\n  if (S.CheckConstraintSatisfaction(Concept, {Concept->getConstraintExpr()},\n                                    Converted, TypeLoc.getLocalSourceRange(),\n                                    Satisfaction))\n    return Sema::DAR_FailedAlreadyDiagnosed;\n  if (!Satisfaction.IsSatisfied) {\n    std::string Buf;\n    llvm::raw_string_ostream OS(Buf);\n    OS << \"'\" << Concept->getName();\n    if (TypeLoc.hasExplicitTemplateArgs()) {\n      OS << \"<\";\n      for (const auto &Arg : Type.getTypeConstraintArguments())\n        Arg.print(S.getPrintingPolicy(), OS);\n      OS << \">\";\n    }\n    OS << \"'\";\n    OS.flush();\n    S.Diag(TypeLoc.getConceptNameLoc(),\n           diag::err_placeholder_constraints_not_satisfied)\n         << Deduced << Buf << TypeLoc.getLocalSourceRange();\n    S.DiagnoseUnsatisfiedConstraint(Satisfaction);\n    return Sema::DAR_FailedAlreadyDiagnosed;\n  }\n  return Sema::DAR_Succeeded;\n}\n\n/// Deduce the type for an auto type-specifier (C++11 [dcl.spec.auto]p6)\n///\n/// Note that this is done even if the initializer is dependent. (This is\n/// necessary to support partial ordering of templates using 'auto'.)\n/// A dependent type will be produced when deducing from a dependent type.\n///\n/// \\param Type the type pattern using the auto type-specifier.\n/// \\param Init the initializer for the variable whose type is to be deduced.\n/// \\param Result if type deduction was successful, this will be set to the\n///        deduced type.\n/// \\param DependentDeductionDepth Set if we should permit deduction in\n///        dependent cases. This is necessary for template partial ordering with\n///        'auto' template parameters. The value specified is the template\n///        parameter depth at which we should perform 'auto' deduction.\n/// \\param IgnoreConstraints Set if we should not fail if the deduced type does\n///                          not satisfy the type-constraint in the auto type.\nSema::DeduceAutoResult\nSema::DeduceAutoType(TypeLoc Type, Expr *&Init, QualType &Result,\n                     Optional<unsigned> DependentDeductionDepth,\n                     bool IgnoreConstraints) {\n  if (Init->containsErrors())\n    return DAR_FailedAlreadyDiagnosed;\n  if (Init->getType()->isNonOverloadPlaceholderType()) {\n    ExprResult NonPlaceholder = CheckPlaceholderExpr(Init);\n    if (NonPlaceholder.isInvalid())\n      return DAR_FailedAlreadyDiagnosed;\n    Init = NonPlaceholder.get();\n  }\n\n  DependentAuto DependentResult = {\n      /*.IsPack = */ (bool)Type.getAs<PackExpansionTypeLoc>()};\n\n  if (!DependentDeductionDepth &&\n      (Type.getType()->isDependentType() || Init->isTypeDependent() ||\n       Init->containsUnexpandedParameterPack())) {\n    Result = SubstituteDeducedTypeTransform(*this, DependentResult).Apply(Type);\n    assert(!Result.isNull() && \"substituting DependentTy can't fail\");\n    return DAR_Succeeded;\n  }\n\n  // Find the depth of template parameter to synthesize.\n  unsigned Depth = DependentDeductionDepth.getValueOr(0);\n\n  // If this is a 'decltype(auto)' specifier, do the decltype dance.\n  // Since 'decltype(auto)' can only occur at the top of the type, we\n  // don't need to go digging for it.\n  if (const AutoType *AT = Type.getType()->getAs<AutoType>()) {\n    if (AT->isDecltypeAuto()) {\n      if (isa<InitListExpr>(Init)) {\n        Diag(Init->getBeginLoc(), diag::err_decltype_auto_initializer_list);\n        return DAR_FailedAlreadyDiagnosed;\n      }\n\n      ExprResult ER = CheckPlaceholderExpr(Init);\n      if (ER.isInvalid())\n        return DAR_FailedAlreadyDiagnosed;\n      Init = ER.get();\n      QualType Deduced = BuildDecltypeType(Init, Init->getBeginLoc(), false);\n      if (Deduced.isNull())\n        return DAR_FailedAlreadyDiagnosed;\n      // FIXME: Support a non-canonical deduced type for 'auto'.\n      Deduced = Context.getCanonicalType(Deduced);\n      if (AT->isConstrained() && !IgnoreConstraints) {\n        auto ConstraintsResult =\n            CheckDeducedPlaceholderConstraints(*this, *AT,\n                                               Type.getContainedAutoTypeLoc(),\n                                               Deduced);\n        if (ConstraintsResult != DAR_Succeeded)\n          return ConstraintsResult;\n      }\n      Result = SubstituteDeducedTypeTransform(*this, Deduced).Apply(Type);\n      if (Result.isNull())\n        return DAR_FailedAlreadyDiagnosed;\n      return DAR_Succeeded;\n    } else if (!getLangOpts().CPlusPlus) {\n      if (isa<InitListExpr>(Init)) {\n        Diag(Init->getBeginLoc(), diag::err_auto_init_list_from_c);\n        return DAR_FailedAlreadyDiagnosed;\n      }\n    }\n  }\n\n  SourceLocation Loc = Init->getExprLoc();\n\n  LocalInstantiationScope InstScope(*this);\n\n  // Build template<class TemplParam> void Func(FuncParam);\n  TemplateTypeParmDecl *TemplParam = TemplateTypeParmDecl::Create(\n      Context, nullptr, SourceLocation(), Loc, Depth, 0, nullptr, false, false,\n      false);\n  QualType TemplArg = QualType(TemplParam->getTypeForDecl(), 0);\n  NamedDecl *TemplParamPtr = TemplParam;\n  FixedSizeTemplateParameterListStorage<1, false> TemplateParamsSt(\n      Context, Loc, Loc, TemplParamPtr, Loc, nullptr);\n\n  QualType FuncParam =\n      SubstituteDeducedTypeTransform(*this, TemplArg, /*UseTypeSugar*/false)\n          .Apply(Type);\n  assert(!FuncParam.isNull() &&\n         \"substituting template parameter for 'auto' failed\");\n\n  // Deduce type of TemplParam in Func(Init)\n  SmallVector<DeducedTemplateArgument, 1> Deduced;\n  Deduced.resize(1);\n\n  TemplateDeductionInfo Info(Loc, Depth);\n\n  // If deduction failed, don't diagnose if the initializer is dependent; it\n  // might acquire a matching type in the instantiation.\n  auto DeductionFailed = [&](TemplateDeductionResult TDK,\n                             ArrayRef<SourceRange> Ranges) -> DeduceAutoResult {\n    if (Init->isTypeDependent()) {\n      Result =\n          SubstituteDeducedTypeTransform(*this, DependentResult).Apply(Type);\n      assert(!Result.isNull() && \"substituting DependentTy can't fail\");\n      return DAR_Succeeded;\n    }\n    if (diagnoseAutoDeductionFailure(*this, TDK, Info, Ranges))\n      return DAR_FailedAlreadyDiagnosed;\n    return DAR_Failed;\n  };\n\n  SmallVector<OriginalCallArg, 4> OriginalCallArgs;\n\n  InitListExpr *InitList = dyn_cast<InitListExpr>(Init);\n  if (InitList) {\n    // Notionally, we substitute std::initializer_list<T> for 'auto' and deduce\n    // against that. Such deduction only succeeds if removing cv-qualifiers and\n    // references results in std::initializer_list<T>.\n    if (!Type.getType().getNonReferenceType()->getAs<AutoType>())\n      return DAR_Failed;\n\n    // Resolving a core issue: a braced-init-list containing any designators is\n    // a non-deduced context.\n    for (Expr *E : InitList->inits())\n      if (isa<DesignatedInitExpr>(E))\n        return DAR_Failed;\n\n    SourceRange DeducedFromInitRange;\n    for (unsigned i = 0, e = InitList->getNumInits(); i < e; ++i) {\n      Expr *Init = InitList->getInit(i);\n\n      if (auto TDK = DeduceTemplateArgumentsFromCallArgument(\n              *this, TemplateParamsSt.get(), 0, TemplArg, Init,\n              Info, Deduced, OriginalCallArgs, /*Decomposed*/ true,\n              /*ArgIdx*/ 0, /*TDF*/ 0))\n        return DeductionFailed(TDK, {DeducedFromInitRange,\n                                     Init->getSourceRange()});\n\n      if (DeducedFromInitRange.isInvalid() &&\n          Deduced[0].getKind() != TemplateArgument::Null)\n        DeducedFromInitRange = Init->getSourceRange();\n    }\n  } else {\n    if (!getLangOpts().CPlusPlus && Init->refersToBitField()) {\n      Diag(Loc, diag::err_auto_bitfield);\n      return DAR_FailedAlreadyDiagnosed;\n    }\n\n    if (auto TDK = DeduceTemplateArgumentsFromCallArgument(\n            *this, TemplateParamsSt.get(), 0, FuncParam, Init, Info, Deduced,\n            OriginalCallArgs, /*Decomposed*/ false, /*ArgIdx*/ 0, /*TDF*/ 0))\n      return DeductionFailed(TDK, {});\n  }\n\n  // Could be null if somehow 'auto' appears in a non-deduced context.\n  if (Deduced[0].getKind() != TemplateArgument::Type)\n    return DeductionFailed(TDK_Incomplete, {});\n\n  QualType DeducedType = Deduced[0].getAsType();\n\n  if (InitList) {\n    DeducedType = BuildStdInitializerList(DeducedType, Loc);\n    if (DeducedType.isNull())\n      return DAR_FailedAlreadyDiagnosed;\n  }\n\n  if (const auto *AT = Type.getType()->getAs<AutoType>()) {\n    if (AT->isConstrained() && !IgnoreConstraints) {\n      auto ConstraintsResult =\n          CheckDeducedPlaceholderConstraints(*this, *AT,\n                                             Type.getContainedAutoTypeLoc(),\n                                             DeducedType);\n      if (ConstraintsResult != DAR_Succeeded)\n        return ConstraintsResult;\n    }\n  }\n\n  Result = SubstituteDeducedTypeTransform(*this, DeducedType).Apply(Type);\n  if (Result.isNull())\n    return DAR_FailedAlreadyDiagnosed;\n\n  // Check that the deduced argument type is compatible with the original\n  // argument type per C++ [temp.deduct.call]p4.\n  QualType DeducedA = InitList ? Deduced[0].getAsType() : Result;\n  for (const OriginalCallArg &OriginalArg : OriginalCallArgs) {\n    assert((bool)InitList == OriginalArg.DecomposedParam &&\n           \"decomposed non-init-list in auto deduction?\");\n    if (auto TDK =\n            CheckOriginalCallArgDeduction(*this, Info, OriginalArg, DeducedA)) {\n      Result = QualType();\n      return DeductionFailed(TDK, {});\n    }\n  }\n\n  return DAR_Succeeded;\n}\n\nQualType Sema::SubstAutoType(QualType TypeWithAuto,\n                             QualType TypeToReplaceAuto) {\n  if (TypeToReplaceAuto->isDependentType())\n    return SubstituteDeducedTypeTransform(\n               *this, DependentAuto{\n                          TypeToReplaceAuto->containsUnexpandedParameterPack()})\n        .TransformType(TypeWithAuto);\n  return SubstituteDeducedTypeTransform(*this, TypeToReplaceAuto)\n      .TransformType(TypeWithAuto);\n}\n\nTypeSourceInfo *Sema::SubstAutoTypeSourceInfo(TypeSourceInfo *TypeWithAuto,\n                                              QualType TypeToReplaceAuto) {\n  if (TypeToReplaceAuto->isDependentType())\n    return SubstituteDeducedTypeTransform(\n               *this,\n               DependentAuto{\n                   TypeToReplaceAuto->containsUnexpandedParameterPack()})\n        .TransformType(TypeWithAuto);\n  return SubstituteDeducedTypeTransform(*this, TypeToReplaceAuto)\n      .TransformType(TypeWithAuto);\n}\n\nQualType Sema::ReplaceAutoType(QualType TypeWithAuto,\n                               QualType TypeToReplaceAuto) {\n  return SubstituteDeducedTypeTransform(*this, TypeToReplaceAuto,\n                                        /*UseTypeSugar*/ false)\n      .TransformType(TypeWithAuto);\n}\n\nTypeSourceInfo *Sema::ReplaceAutoTypeSourceInfo(TypeSourceInfo *TypeWithAuto,\n                                                QualType TypeToReplaceAuto) {\n  return SubstituteDeducedTypeTransform(*this, TypeToReplaceAuto,\n                                        /*UseTypeSugar*/ false)\n      .TransformType(TypeWithAuto);\n}\n\nvoid Sema::DiagnoseAutoDeductionFailure(VarDecl *VDecl, Expr *Init) {\n  if (isa<InitListExpr>(Init))\n    Diag(VDecl->getLocation(),\n         VDecl->isInitCapture()\n             ? diag::err_init_capture_deduction_failure_from_init_list\n             : diag::err_auto_var_deduction_failure_from_init_list)\n      << VDecl->getDeclName() << VDecl->getType() << Init->getSourceRange();\n  else\n    Diag(VDecl->getLocation(),\n         VDecl->isInitCapture() ? diag::err_init_capture_deduction_failure\n                                : diag::err_auto_var_deduction_failure)\n      << VDecl->getDeclName() << VDecl->getType() << Init->getType()\n      << Init->getSourceRange();\n}\n\nbool Sema::DeduceReturnType(FunctionDecl *FD, SourceLocation Loc,\n                            bool Diagnose) {\n  assert(FD->getReturnType()->isUndeducedType());\n\n  // For a lambda's conversion operator, deduce any 'auto' or 'decltype(auto)'\n  // within the return type from the call operator's type.\n  if (isLambdaConversionOperator(FD)) {\n    CXXRecordDecl *Lambda = cast<CXXMethodDecl>(FD)->getParent();\n    FunctionDecl *CallOp = Lambda->getLambdaCallOperator();\n\n    // For a generic lambda, instantiate the call operator if needed.\n    if (auto *Args = FD->getTemplateSpecializationArgs()) {\n      CallOp = InstantiateFunctionDeclaration(\n          CallOp->getDescribedFunctionTemplate(), Args, Loc);\n      if (!CallOp || CallOp->isInvalidDecl())\n        return true;\n\n      // We might need to deduce the return type by instantiating the definition\n      // of the operator() function.\n      if (CallOp->getReturnType()->isUndeducedType()) {\n        runWithSufficientStackSpace(Loc, [&] {\n          InstantiateFunctionDefinition(Loc, CallOp);\n        });\n      }\n    }\n\n    if (CallOp->isInvalidDecl())\n      return true;\n    assert(!CallOp->getReturnType()->isUndeducedType() &&\n           \"failed to deduce lambda return type\");\n\n    // Build the new return type from scratch.\n    CallingConv RetTyCC = FD->getReturnType()\n                              ->getPointeeType()\n                              ->castAs<FunctionType>()\n                              ->getCallConv();\n    QualType RetType = getLambdaConversionFunctionResultType(\n        CallOp->getType()->castAs<FunctionProtoType>(), RetTyCC);\n    if (FD->getReturnType()->getAs<PointerType>())\n      RetType = Context.getPointerType(RetType);\n    else {\n      assert(FD->getReturnType()->getAs<BlockPointerType>());\n      RetType = Context.getBlockPointerType(RetType);\n    }\n    Context.adjustDeducedFunctionResultType(FD, RetType);\n    return false;\n  }\n\n  if (FD->getTemplateInstantiationPattern()) {\n    runWithSufficientStackSpace(Loc, [&] {\n      InstantiateFunctionDefinition(Loc, FD);\n    });\n  }\n\n  bool StillUndeduced = FD->getReturnType()->isUndeducedType();\n  if (StillUndeduced && Diagnose && !FD->isInvalidDecl()) {\n    Diag(Loc, diag::err_auto_fn_used_before_defined) << FD;\n    Diag(FD->getLocation(), diag::note_callee_decl) << FD;\n  }\n\n  return StillUndeduced;\n}\n\n/// If this is a non-static member function,\nstatic void\nAddImplicitObjectParameterType(ASTContext &Context,\n                               CXXMethodDecl *Method,\n                               SmallVectorImpl<QualType> &ArgTypes) {\n  // C++11 [temp.func.order]p3:\n  //   [...] The new parameter is of type \"reference to cv A,\" where cv are\n  //   the cv-qualifiers of the function template (if any) and A is\n  //   the class of which the function template is a member.\n  //\n  // The standard doesn't say explicitly, but we pick the appropriate kind of\n  // reference type based on [over.match.funcs]p4.\n  QualType ArgTy = Context.getTypeDeclType(Method->getParent());\n  ArgTy = Context.getQualifiedType(ArgTy, Method->getMethodQualifiers());\n  if (Method->getRefQualifier() == RQ_RValue)\n    ArgTy = Context.getRValueReferenceType(ArgTy);\n  else\n    ArgTy = Context.getLValueReferenceType(ArgTy);\n  ArgTypes.push_back(ArgTy);\n}\n\n/// Determine whether the function template \\p FT1 is at least as\n/// specialized as \\p FT2.\nstatic bool isAtLeastAsSpecializedAs(Sema &S,\n                                     SourceLocation Loc,\n                                     FunctionTemplateDecl *FT1,\n                                     FunctionTemplateDecl *FT2,\n                                     TemplatePartialOrderingContext TPOC,\n                                     unsigned NumCallArguments1,\n                                     bool Reversed) {\n  assert(!Reversed || TPOC == TPOC_Call);\n\n  FunctionDecl *FD1 = FT1->getTemplatedDecl();\n  FunctionDecl *FD2 = FT2->getTemplatedDecl();\n  const FunctionProtoType *Proto1 = FD1->getType()->getAs<FunctionProtoType>();\n  const FunctionProtoType *Proto2 = FD2->getType()->getAs<FunctionProtoType>();\n\n  assert(Proto1 && Proto2 && \"Function templates must have prototypes\");\n  TemplateParameterList *TemplateParams = FT2->getTemplateParameters();\n  SmallVector<DeducedTemplateArgument, 4> Deduced;\n  Deduced.resize(TemplateParams->size());\n\n  // C++0x [temp.deduct.partial]p3:\n  //   The types used to determine the ordering depend on the context in which\n  //   the partial ordering is done:\n  TemplateDeductionInfo Info(Loc);\n  SmallVector<QualType, 4> Args2;\n  switch (TPOC) {\n  case TPOC_Call: {\n    //   - In the context of a function call, the function parameter types are\n    //     used.\n    CXXMethodDecl *Method1 = dyn_cast<CXXMethodDecl>(FD1);\n    CXXMethodDecl *Method2 = dyn_cast<CXXMethodDecl>(FD2);\n\n    // C++11 [temp.func.order]p3:\n    //   [...] If only one of the function templates is a non-static\n    //   member, that function template is considered to have a new\n    //   first parameter inserted in its function parameter list. The\n    //   new parameter is of type \"reference to cv A,\" where cv are\n    //   the cv-qualifiers of the function template (if any) and A is\n    //   the class of which the function template is a member.\n    //\n    // Note that we interpret this to mean \"if one of the function\n    // templates is a non-static member and the other is a non-member\";\n    // otherwise, the ordering rules for static functions against non-static\n    // functions don't make any sense.\n    //\n    // C++98/03 doesn't have this provision but we've extended DR532 to cover\n    // it as wording was broken prior to it.\n    SmallVector<QualType, 4> Args1;\n\n    unsigned NumComparedArguments = NumCallArguments1;\n\n    if (!Method2 && Method1 && !Method1->isStatic()) {\n      // Compare 'this' from Method1 against first parameter from Method2.\n      AddImplicitObjectParameterType(S.Context, Method1, Args1);\n      ++NumComparedArguments;\n    } else if (!Method1 && Method2 && !Method2->isStatic()) {\n      // Compare 'this' from Method2 against first parameter from Method1.\n      AddImplicitObjectParameterType(S.Context, Method2, Args2);\n    } else if (Method1 && Method2 && Reversed) {\n      // Compare 'this' from Method1 against second parameter from Method2\n      // and 'this' from Method2 against second parameter from Method1.\n      AddImplicitObjectParameterType(S.Context, Method1, Args1);\n      AddImplicitObjectParameterType(S.Context, Method2, Args2);\n      ++NumComparedArguments;\n    }\n\n    Args1.insert(Args1.end(), Proto1->param_type_begin(),\n                 Proto1->param_type_end());\n    Args2.insert(Args2.end(), Proto2->param_type_begin(),\n                 Proto2->param_type_end());\n\n    // C++ [temp.func.order]p5:\n    //   The presence of unused ellipsis and default arguments has no effect on\n    //   the partial ordering of function templates.\n    if (Args1.size() > NumComparedArguments)\n      Args1.resize(NumComparedArguments);\n    if (Args2.size() > NumComparedArguments)\n      Args2.resize(NumComparedArguments);\n    if (Reversed)\n      std::reverse(Args2.begin(), Args2.end());\n    if (DeduceTemplateArguments(S, TemplateParams, Args2.data(), Args2.size(),\n                                Args1.data(), Args1.size(), Info, Deduced,\n                                TDF_None, /*PartialOrdering=*/true))\n      return false;\n\n    break;\n  }\n\n  case TPOC_Conversion:\n    //   - In the context of a call to a conversion operator, the return types\n    //     of the conversion function templates are used.\n    if (DeduceTemplateArgumentsByTypeMatch(\n            S, TemplateParams, Proto2->getReturnType(), Proto1->getReturnType(),\n            Info, Deduced, TDF_None,\n            /*PartialOrdering=*/true))\n      return false;\n    break;\n\n  case TPOC_Other:\n    //   - In other contexts (14.6.6.2) the function template's function type\n    //     is used.\n    if (DeduceTemplateArgumentsByTypeMatch(S, TemplateParams,\n                                           FD2->getType(), FD1->getType(),\n                                           Info, Deduced, TDF_None,\n                                           /*PartialOrdering=*/true))\n      return false;\n    break;\n  }\n\n  // C++0x [temp.deduct.partial]p11:\n  //   In most cases, all template parameters must have values in order for\n  //   deduction to succeed, but for partial ordering purposes a template\n  //   parameter may remain without a value provided it is not used in the\n  //   types being used for partial ordering. [ Note: a template parameter used\n  //   in a non-deduced context is considered used. -end note]\n  unsigned ArgIdx = 0, NumArgs = Deduced.size();\n  for (; ArgIdx != NumArgs; ++ArgIdx)\n    if (Deduced[ArgIdx].isNull())\n      break;\n\n  // FIXME: We fail to implement [temp.deduct.type]p1 along this path. We need\n  // to substitute the deduced arguments back into the template and check that\n  // we get the right type.\n\n  if (ArgIdx == NumArgs) {\n    // All template arguments were deduced. FT1 is at least as specialized\n    // as FT2.\n    return true;\n  }\n\n  // Figure out which template parameters were used.\n  llvm::SmallBitVector UsedParameters(TemplateParams->size());\n  switch (TPOC) {\n  case TPOC_Call:\n    for (unsigned I = 0, N = Args2.size(); I != N; ++I)\n      ::MarkUsedTemplateParameters(S.Context, Args2[I], false,\n                                   TemplateParams->getDepth(),\n                                   UsedParameters);\n    break;\n\n  case TPOC_Conversion:\n    ::MarkUsedTemplateParameters(S.Context, Proto2->getReturnType(), false,\n                                 TemplateParams->getDepth(), UsedParameters);\n    break;\n\n  case TPOC_Other:\n    ::MarkUsedTemplateParameters(S.Context, FD2->getType(), false,\n                                 TemplateParams->getDepth(),\n                                 UsedParameters);\n    break;\n  }\n\n  for (; ArgIdx != NumArgs; ++ArgIdx)\n    // If this argument had no value deduced but was used in one of the types\n    // used for partial ordering, then deduction fails.\n    if (Deduced[ArgIdx].isNull() && UsedParameters[ArgIdx])\n      return false;\n\n  return true;\n}\n\n/// Determine whether this a function template whose parameter-type-list\n/// ends with a function parameter pack.\nstatic bool isVariadicFunctionTemplate(FunctionTemplateDecl *FunTmpl) {\n  FunctionDecl *Function = FunTmpl->getTemplatedDecl();\n  unsigned NumParams = Function->getNumParams();\n  if (NumParams == 0)\n    return false;\n\n  ParmVarDecl *Last = Function->getParamDecl(NumParams - 1);\n  if (!Last->isParameterPack())\n    return false;\n\n  // Make sure that no previous parameter is a parameter pack.\n  while (--NumParams > 0) {\n    if (Function->getParamDecl(NumParams - 1)->isParameterPack())\n      return false;\n  }\n\n  return true;\n}\n\n/// Returns the more specialized function template according\n/// to the rules of function template partial ordering (C++ [temp.func.order]).\n///\n/// \\param FT1 the first function template\n///\n/// \\param FT2 the second function template\n///\n/// \\param TPOC the context in which we are performing partial ordering of\n/// function templates.\n///\n/// \\param NumCallArguments1 The number of arguments in the call to FT1, used\n/// only when \\c TPOC is \\c TPOC_Call.\n///\n/// \\param NumCallArguments2 The number of arguments in the call to FT2, used\n/// only when \\c TPOC is \\c TPOC_Call.\n///\n/// \\param Reversed If \\c true, exactly one of FT1 and FT2 is an overload\n/// candidate with a reversed parameter order. In this case, the corresponding\n/// P/A pairs between FT1 and FT2 are reversed.\n///\n/// \\returns the more specialized function template. If neither\n/// template is more specialized, returns NULL.\nFunctionTemplateDecl *\nSema::getMoreSpecializedTemplate(FunctionTemplateDecl *FT1,\n                                 FunctionTemplateDecl *FT2,\n                                 SourceLocation Loc,\n                                 TemplatePartialOrderingContext TPOC,\n                                 unsigned NumCallArguments1,\n                                 unsigned NumCallArguments2,\n                                 bool Reversed) {\n\n  auto JudgeByConstraints = [&] () -> FunctionTemplateDecl * {\n    llvm::SmallVector<const Expr *, 3> AC1, AC2;\n    FT1->getAssociatedConstraints(AC1);\n    FT2->getAssociatedConstraints(AC2);\n    bool AtLeastAsConstrained1, AtLeastAsConstrained2;\n    if (IsAtLeastAsConstrained(FT1, AC1, FT2, AC2, AtLeastAsConstrained1))\n      return nullptr;\n    if (IsAtLeastAsConstrained(FT2, AC2, FT1, AC1, AtLeastAsConstrained2))\n      return nullptr;\n    if (AtLeastAsConstrained1 == AtLeastAsConstrained2)\n      return nullptr;\n    return AtLeastAsConstrained1 ? FT1 : FT2;\n  };\n\n  bool Better1 = isAtLeastAsSpecializedAs(*this, Loc, FT1, FT2, TPOC,\n                                          NumCallArguments1, Reversed);\n  bool Better2 = isAtLeastAsSpecializedAs(*this, Loc, FT2, FT1, TPOC,\n                                          NumCallArguments2, Reversed);\n\n  if (Better1 != Better2) // We have a clear winner\n    return Better1 ? FT1 : FT2;\n\n  if (!Better1 && !Better2) // Neither is better than the other\n    return JudgeByConstraints();\n\n  // FIXME: This mimics what GCC implements, but doesn't match up with the\n  // proposed resolution for core issue 692. This area needs to be sorted out,\n  // but for now we attempt to maintain compatibility.\n  bool Variadic1 = isVariadicFunctionTemplate(FT1);\n  bool Variadic2 = isVariadicFunctionTemplate(FT2);\n  if (Variadic1 != Variadic2)\n    return Variadic1? FT2 : FT1;\n\n  return JudgeByConstraints();\n}\n\n/// Determine if the two templates are equivalent.\nstatic bool isSameTemplate(TemplateDecl *T1, TemplateDecl *T2) {\n  if (T1 == T2)\n    return true;\n\n  if (!T1 || !T2)\n    return false;\n\n  return T1->getCanonicalDecl() == T2->getCanonicalDecl();\n}\n\n/// Retrieve the most specialized of the given function template\n/// specializations.\n///\n/// \\param SpecBegin the start iterator of the function template\n/// specializations that we will be comparing.\n///\n/// \\param SpecEnd the end iterator of the function template\n/// specializations, paired with \\p SpecBegin.\n///\n/// \\param Loc the location where the ambiguity or no-specializations\n/// diagnostic should occur.\n///\n/// \\param NoneDiag partial diagnostic used to diagnose cases where there are\n/// no matching candidates.\n///\n/// \\param AmbigDiag partial diagnostic used to diagnose an ambiguity, if one\n/// occurs.\n///\n/// \\param CandidateDiag partial diagnostic used for each function template\n/// specialization that is a candidate in the ambiguous ordering. One parameter\n/// in this diagnostic should be unbound, which will correspond to the string\n/// describing the template arguments for the function template specialization.\n///\n/// \\returns the most specialized function template specialization, if\n/// found. Otherwise, returns SpecEnd.\nUnresolvedSetIterator Sema::getMostSpecialized(\n    UnresolvedSetIterator SpecBegin, UnresolvedSetIterator SpecEnd,\n    TemplateSpecCandidateSet &FailedCandidates,\n    SourceLocation Loc, const PartialDiagnostic &NoneDiag,\n    const PartialDiagnostic &AmbigDiag, const PartialDiagnostic &CandidateDiag,\n    bool Complain, QualType TargetType) {\n  if (SpecBegin == SpecEnd) {\n    if (Complain) {\n      Diag(Loc, NoneDiag);\n      FailedCandidates.NoteCandidates(*this, Loc);\n    }\n    return SpecEnd;\n  }\n\n  if (SpecBegin + 1 == SpecEnd)\n    return SpecBegin;\n\n  // Find the function template that is better than all of the templates it\n  // has been compared to.\n  UnresolvedSetIterator Best = SpecBegin;\n  FunctionTemplateDecl *BestTemplate\n    = cast<FunctionDecl>(*Best)->getPrimaryTemplate();\n  assert(BestTemplate && \"Not a function template specialization?\");\n  for (UnresolvedSetIterator I = SpecBegin + 1; I != SpecEnd; ++I) {\n    FunctionTemplateDecl *Challenger\n      = cast<FunctionDecl>(*I)->getPrimaryTemplate();\n    assert(Challenger && \"Not a function template specialization?\");\n    if (isSameTemplate(getMoreSpecializedTemplate(BestTemplate, Challenger,\n                                                  Loc, TPOC_Other, 0, 0),\n                       Challenger)) {\n      Best = I;\n      BestTemplate = Challenger;\n    }\n  }\n\n  // Make sure that the \"best\" function template is more specialized than all\n  // of the others.\n  bool Ambiguous = false;\n  for (UnresolvedSetIterator I = SpecBegin; I != SpecEnd; ++I) {\n    FunctionTemplateDecl *Challenger\n      = cast<FunctionDecl>(*I)->getPrimaryTemplate();\n    if (I != Best &&\n        !isSameTemplate(getMoreSpecializedTemplate(BestTemplate, Challenger,\n                                                   Loc, TPOC_Other, 0, 0),\n                        BestTemplate)) {\n      Ambiguous = true;\n      break;\n    }\n  }\n\n  if (!Ambiguous) {\n    // We found an answer. Return it.\n    return Best;\n  }\n\n  // Diagnose the ambiguity.\n  if (Complain) {\n    Diag(Loc, AmbigDiag);\n\n    // FIXME: Can we order the candidates in some sane way?\n    for (UnresolvedSetIterator I = SpecBegin; I != SpecEnd; ++I) {\n      PartialDiagnostic PD = CandidateDiag;\n      const auto *FD = cast<FunctionDecl>(*I);\n      PD << FD << getTemplateArgumentBindingsText(\n                      FD->getPrimaryTemplate()->getTemplateParameters(),\n                      *FD->getTemplateSpecializationArgs());\n      if (!TargetType.isNull())\n        HandleFunctionTypeMismatch(PD, FD->getType(), TargetType);\n      Diag((*I)->getLocation(), PD);\n    }\n  }\n\n  return SpecEnd;\n}\n\n/// Determine whether one partial specialization, P1, is at least as\n/// specialized than another, P2.\n///\n/// \\tparam TemplateLikeDecl The kind of P2, which must be a\n/// TemplateDecl or {Class,Var}TemplatePartialSpecializationDecl.\n/// \\param T1 The injected-class-name of P1 (faked for a variable template).\n/// \\param T2 The injected-class-name of P2 (faked for a variable template).\ntemplate<typename TemplateLikeDecl>\nstatic bool isAtLeastAsSpecializedAs(Sema &S, QualType T1, QualType T2,\n                                     TemplateLikeDecl *P2,\n                                     TemplateDeductionInfo &Info) {\n  // C++ [temp.class.order]p1:\n  //   For two class template partial specializations, the first is at least as\n  //   specialized as the second if, given the following rewrite to two\n  //   function templates, the first function template is at least as\n  //   specialized as the second according to the ordering rules for function\n  //   templates (14.6.6.2):\n  //     - the first function template has the same template parameters as the\n  //       first partial specialization and has a single function parameter\n  //       whose type is a class template specialization with the template\n  //       arguments of the first partial specialization, and\n  //     - the second function template has the same template parameters as the\n  //       second partial specialization and has a single function parameter\n  //       whose type is a class template specialization with the template\n  //       arguments of the second partial specialization.\n  //\n  // Rather than synthesize function templates, we merely perform the\n  // equivalent partial ordering by performing deduction directly on\n  // the template arguments of the class template partial\n  // specializations. This computation is slightly simpler than the\n  // general problem of function template partial ordering, because\n  // class template partial specializations are more constrained. We\n  // know that every template parameter is deducible from the class\n  // template partial specialization's template arguments, for\n  // example.\n  SmallVector<DeducedTemplateArgument, 4> Deduced;\n\n  // Determine whether P1 is at least as specialized as P2.\n  Deduced.resize(P2->getTemplateParameters()->size());\n  if (DeduceTemplateArgumentsByTypeMatch(S, P2->getTemplateParameters(),\n                                         T2, T1, Info, Deduced, TDF_None,\n                                         /*PartialOrdering=*/true))\n    return false;\n\n  SmallVector<TemplateArgument, 4> DeducedArgs(Deduced.begin(),\n                                               Deduced.end());\n  Sema::InstantiatingTemplate Inst(S, Info.getLocation(), P2, DeducedArgs,\n                                   Info);\n  auto *TST1 = T1->castAs<TemplateSpecializationType>();\n  bool AtLeastAsSpecialized;\n  S.runWithSufficientStackSpace(Info.getLocation(), [&] {\n    AtLeastAsSpecialized = !FinishTemplateArgumentDeduction(\n        S, P2, /*IsPartialOrdering=*/true,\n        TemplateArgumentList(TemplateArgumentList::OnStack,\n                             TST1->template_arguments()),\n        Deduced, Info);\n  });\n  return AtLeastAsSpecialized;\n}\n\n/// Returns the more specialized class template partial specialization\n/// according to the rules of partial ordering of class template partial\n/// specializations (C++ [temp.class.order]).\n///\n/// \\param PS1 the first class template partial specialization\n///\n/// \\param PS2 the second class template partial specialization\n///\n/// \\returns the more specialized class template partial specialization. If\n/// neither partial specialization is more specialized, returns NULL.\nClassTemplatePartialSpecializationDecl *\nSema::getMoreSpecializedPartialSpecialization(\n                                  ClassTemplatePartialSpecializationDecl *PS1,\n                                  ClassTemplatePartialSpecializationDecl *PS2,\n                                              SourceLocation Loc) {\n  QualType PT1 = PS1->getInjectedSpecializationType();\n  QualType PT2 = PS2->getInjectedSpecializationType();\n\n  TemplateDeductionInfo Info(Loc);\n  bool Better1 = isAtLeastAsSpecializedAs(*this, PT1, PT2, PS2, Info);\n  bool Better2 = isAtLeastAsSpecializedAs(*this, PT2, PT1, PS1, Info);\n\n  if (!Better1 && !Better2)\n      return nullptr;\n  if (Better1 && Better2) {\n    llvm::SmallVector<const Expr *, 3> AC1, AC2;\n    PS1->getAssociatedConstraints(AC1);\n    PS2->getAssociatedConstraints(AC2);\n    bool AtLeastAsConstrained1, AtLeastAsConstrained2;\n    if (IsAtLeastAsConstrained(PS1, AC1, PS2, AC2, AtLeastAsConstrained1))\n      return nullptr;\n    if (IsAtLeastAsConstrained(PS2, AC2, PS1, AC1, AtLeastAsConstrained2))\n      return nullptr;\n    if (AtLeastAsConstrained1 == AtLeastAsConstrained2)\n      return nullptr;\n    return AtLeastAsConstrained1 ? PS1 : PS2;\n  }\n\n  return Better1 ? PS1 : PS2;\n}\n\nbool Sema::isMoreSpecializedThanPrimary(\n    ClassTemplatePartialSpecializationDecl *Spec, TemplateDeductionInfo &Info) {\n  ClassTemplateDecl *Primary = Spec->getSpecializedTemplate();\n  QualType PrimaryT = Primary->getInjectedClassNameSpecialization();\n  QualType PartialT = Spec->getInjectedSpecializationType();\n  if (!isAtLeastAsSpecializedAs(*this, PartialT, PrimaryT, Primary, Info))\n    return false;\n  if (!isAtLeastAsSpecializedAs(*this, PrimaryT, PartialT, Spec, Info))\n    return true;\n  Info.clearSFINAEDiagnostic();\n  llvm::SmallVector<const Expr *, 3> PrimaryAC, SpecAC;\n  Primary->getAssociatedConstraints(PrimaryAC);\n  Spec->getAssociatedConstraints(SpecAC);\n  bool AtLeastAsConstrainedPrimary, AtLeastAsConstrainedSpec;\n  if (IsAtLeastAsConstrained(Spec, SpecAC, Primary, PrimaryAC,\n                             AtLeastAsConstrainedSpec))\n    return false;\n  if (!AtLeastAsConstrainedSpec)\n    return false;\n  if (IsAtLeastAsConstrained(Primary, PrimaryAC, Spec, SpecAC,\n                             AtLeastAsConstrainedPrimary))\n    return false;\n  return !AtLeastAsConstrainedPrimary;\n}\n\nVarTemplatePartialSpecializationDecl *\nSema::getMoreSpecializedPartialSpecialization(\n    VarTemplatePartialSpecializationDecl *PS1,\n    VarTemplatePartialSpecializationDecl *PS2, SourceLocation Loc) {\n  // Pretend the variable template specializations are class template\n  // specializations and form a fake injected class name type for comparison.\n  assert(PS1->getSpecializedTemplate() == PS2->getSpecializedTemplate() &&\n         \"the partial specializations being compared should specialize\"\n         \" the same template.\");\n  TemplateName Name(PS1->getSpecializedTemplate());\n  TemplateName CanonTemplate = Context.getCanonicalTemplateName(Name);\n  QualType PT1 = Context.getTemplateSpecializationType(\n      CanonTemplate, PS1->getTemplateArgs().asArray());\n  QualType PT2 = Context.getTemplateSpecializationType(\n      CanonTemplate, PS2->getTemplateArgs().asArray());\n\n  TemplateDeductionInfo Info(Loc);\n  bool Better1 = isAtLeastAsSpecializedAs(*this, PT1, PT2, PS2, Info);\n  bool Better2 = isAtLeastAsSpecializedAs(*this, PT2, PT1, PS1, Info);\n\n  if (!Better1 && !Better2)\n    return nullptr;\n  if (Better1 && Better2) {\n    llvm::SmallVector<const Expr *, 3> AC1, AC2;\n    PS1->getAssociatedConstraints(AC1);\n    PS2->getAssociatedConstraints(AC2);\n    bool AtLeastAsConstrained1, AtLeastAsConstrained2;\n    if (IsAtLeastAsConstrained(PS1, AC1, PS2, AC2, AtLeastAsConstrained1))\n      return nullptr;\n    if (IsAtLeastAsConstrained(PS2, AC2, PS1, AC1, AtLeastAsConstrained2))\n      return nullptr;\n    if (AtLeastAsConstrained1 == AtLeastAsConstrained2)\n      return nullptr;\n    return AtLeastAsConstrained1 ? PS1 : PS2;\n  }\n\n  return Better1 ? PS1 : PS2;\n}\n\nbool Sema::isMoreSpecializedThanPrimary(\n    VarTemplatePartialSpecializationDecl *Spec, TemplateDeductionInfo &Info) {\n  TemplateDecl *Primary = Spec->getSpecializedTemplate();\n  // FIXME: Cache the injected template arguments rather than recomputing\n  // them for each partial specialization.\n  SmallVector<TemplateArgument, 8> PrimaryArgs;\n  Context.getInjectedTemplateArgs(Primary->getTemplateParameters(),\n                                  PrimaryArgs);\n\n  TemplateName CanonTemplate =\n      Context.getCanonicalTemplateName(TemplateName(Primary));\n  QualType PrimaryT = Context.getTemplateSpecializationType(\n      CanonTemplate, PrimaryArgs);\n  QualType PartialT = Context.getTemplateSpecializationType(\n      CanonTemplate, Spec->getTemplateArgs().asArray());\n\n  if (!isAtLeastAsSpecializedAs(*this, PartialT, PrimaryT, Primary, Info))\n    return false;\n  if (!isAtLeastAsSpecializedAs(*this, PrimaryT, PartialT, Spec, Info))\n    return true;\n  Info.clearSFINAEDiagnostic();\n  llvm::SmallVector<const Expr *, 3> PrimaryAC, SpecAC;\n  Primary->getAssociatedConstraints(PrimaryAC);\n  Spec->getAssociatedConstraints(SpecAC);\n  bool AtLeastAsConstrainedPrimary, AtLeastAsConstrainedSpec;\n  if (IsAtLeastAsConstrained(Spec, SpecAC, Primary, PrimaryAC,\n                             AtLeastAsConstrainedSpec))\n    return false;\n  if (!AtLeastAsConstrainedSpec)\n    return false;\n  if (IsAtLeastAsConstrained(Primary, PrimaryAC, Spec, SpecAC,\n                             AtLeastAsConstrainedPrimary))\n    return false;\n  return !AtLeastAsConstrainedPrimary;\n}\n\nbool Sema::isTemplateTemplateParameterAtLeastAsSpecializedAs(\n     TemplateParameterList *P, TemplateDecl *AArg, SourceLocation Loc) {\n  // C++1z [temp.arg.template]p4: (DR 150)\n  //   A template template-parameter P is at least as specialized as a\n  //   template template-argument A if, given the following rewrite to two\n  //   function templates...\n\n  // Rather than synthesize function templates, we merely perform the\n  // equivalent partial ordering by performing deduction directly on\n  // the template parameter lists of the template template parameters.\n  //\n  //   Given an invented class template X with the template parameter list of\n  //   A (including default arguments):\n  TemplateName X = Context.getCanonicalTemplateName(TemplateName(AArg));\n  TemplateParameterList *A = AArg->getTemplateParameters();\n\n  //    - Each function template has a single function parameter whose type is\n  //      a specialization of X with template arguments corresponding to the\n  //      template parameters from the respective function template\n  SmallVector<TemplateArgument, 8> AArgs;\n  Context.getInjectedTemplateArgs(A, AArgs);\n\n  // Check P's arguments against A's parameter list. This will fill in default\n  // template arguments as needed. AArgs are already correct by construction.\n  // We can't just use CheckTemplateIdType because that will expand alias\n  // templates.\n  SmallVector<TemplateArgument, 4> PArgs;\n  {\n    SFINAETrap Trap(*this);\n\n    Context.getInjectedTemplateArgs(P, PArgs);\n    TemplateArgumentListInfo PArgList(P->getLAngleLoc(),\n                                      P->getRAngleLoc());\n    for (unsigned I = 0, N = P->size(); I != N; ++I) {\n      // Unwrap packs that getInjectedTemplateArgs wrapped around pack\n      // expansions, to form an \"as written\" argument list.\n      TemplateArgument Arg = PArgs[I];\n      if (Arg.getKind() == TemplateArgument::Pack) {\n        assert(Arg.pack_size() == 1 && Arg.pack_begin()->isPackExpansion());\n        Arg = *Arg.pack_begin();\n      }\n      PArgList.addArgument(getTrivialTemplateArgumentLoc(\n          Arg, QualType(), P->getParam(I)->getLocation()));\n    }\n    PArgs.clear();\n\n    // C++1z [temp.arg.template]p3:\n    //   If the rewrite produces an invalid type, then P is not at least as\n    //   specialized as A.\n    if (CheckTemplateArgumentList(AArg, Loc, PArgList, false, PArgs) ||\n        Trap.hasErrorOccurred())\n      return false;\n  }\n\n  QualType AType = Context.getTemplateSpecializationType(X, AArgs);\n  QualType PType = Context.getTemplateSpecializationType(X, PArgs);\n\n  //   ... the function template corresponding to P is at least as specialized\n  //   as the function template corresponding to A according to the partial\n  //   ordering rules for function templates.\n  TemplateDeductionInfo Info(Loc, A->getDepth());\n  return isAtLeastAsSpecializedAs(*this, PType, AType, AArg, Info);\n}\n\nnamespace {\nstruct MarkUsedTemplateParameterVisitor :\n    RecursiveASTVisitor<MarkUsedTemplateParameterVisitor> {\n  llvm::SmallBitVector &Used;\n  unsigned Depth;\n\n  MarkUsedTemplateParameterVisitor(llvm::SmallBitVector &Used,\n                                   unsigned Depth)\n      : Used(Used), Depth(Depth) { }\n\n  bool VisitTemplateTypeParmType(TemplateTypeParmType *T) {\n    if (T->getDepth() == Depth)\n      Used[T->getIndex()] = true;\n    return true;\n  }\n\n  bool TraverseTemplateName(TemplateName Template) {\n    if (auto *TTP =\n            dyn_cast<TemplateTemplateParmDecl>(Template.getAsTemplateDecl()))\n      if (TTP->getDepth() == Depth)\n        Used[TTP->getIndex()] = true;\n    RecursiveASTVisitor<MarkUsedTemplateParameterVisitor>::\n        TraverseTemplateName(Template);\n    return true;\n  }\n\n  bool VisitDeclRefExpr(DeclRefExpr *E) {\n    if (auto *NTTP = dyn_cast<NonTypeTemplateParmDecl>(E->getDecl()))\n      if (NTTP->getDepth() == Depth)\n        Used[NTTP->getIndex()] = true;\n    return true;\n  }\n};\n}\n\n/// Mark the template parameters that are used by the given\n/// expression.\nstatic void\nMarkUsedTemplateParameters(ASTContext &Ctx,\n                           const Expr *E,\n                           bool OnlyDeduced,\n                           unsigned Depth,\n                           llvm::SmallBitVector &Used) {\n  if (!OnlyDeduced) {\n    MarkUsedTemplateParameterVisitor(Used, Depth)\n        .TraverseStmt(const_cast<Expr *>(E));\n    return;\n  }\n\n  // We can deduce from a pack expansion.\n  if (const PackExpansionExpr *Expansion = dyn_cast<PackExpansionExpr>(E))\n    E = Expansion->getPattern();\n\n  const NonTypeTemplateParmDecl *NTTP = getDeducedParameterFromExpr(E, Depth);\n  if (!NTTP)\n    return;\n\n  if (NTTP->getDepth() == Depth)\n    Used[NTTP->getIndex()] = true;\n\n  // In C++17 mode, additional arguments may be deduced from the type of a\n  // non-type argument.\n  if (Ctx.getLangOpts().CPlusPlus17)\n    MarkUsedTemplateParameters(Ctx, NTTP->getType(), OnlyDeduced, Depth, Used);\n}\n\n/// Mark the template parameters that are used by the given\n/// nested name specifier.\nstatic void\nMarkUsedTemplateParameters(ASTContext &Ctx,\n                           NestedNameSpecifier *NNS,\n                           bool OnlyDeduced,\n                           unsigned Depth,\n                           llvm::SmallBitVector &Used) {\n  if (!NNS)\n    return;\n\n  MarkUsedTemplateParameters(Ctx, NNS->getPrefix(), OnlyDeduced, Depth,\n                             Used);\n  MarkUsedTemplateParameters(Ctx, QualType(NNS->getAsType(), 0),\n                             OnlyDeduced, Depth, Used);\n}\n\n/// Mark the template parameters that are used by the given\n/// template name.\nstatic void\nMarkUsedTemplateParameters(ASTContext &Ctx,\n                           TemplateName Name,\n                           bool OnlyDeduced,\n                           unsigned Depth,\n                           llvm::SmallBitVector &Used) {\n  if (TemplateDecl *Template = Name.getAsTemplateDecl()) {\n    if (TemplateTemplateParmDecl *TTP\n          = dyn_cast<TemplateTemplateParmDecl>(Template)) {\n      if (TTP->getDepth() == Depth)\n        Used[TTP->getIndex()] = true;\n    }\n    return;\n  }\n\n  if (QualifiedTemplateName *QTN = Name.getAsQualifiedTemplateName())\n    MarkUsedTemplateParameters(Ctx, QTN->getQualifier(), OnlyDeduced,\n                               Depth, Used);\n  if (DependentTemplateName *DTN = Name.getAsDependentTemplateName())\n    MarkUsedTemplateParameters(Ctx, DTN->getQualifier(), OnlyDeduced,\n                               Depth, Used);\n}\n\n/// Mark the template parameters that are used by the given\n/// type.\nstatic void\nMarkUsedTemplateParameters(ASTContext &Ctx, QualType T,\n                           bool OnlyDeduced,\n                           unsigned Depth,\n                           llvm::SmallBitVector &Used) {\n  if (T.isNull())\n    return;\n\n  // Non-dependent types have nothing deducible\n  if (!T->isDependentType())\n    return;\n\n  T = Ctx.getCanonicalType(T);\n  switch (T->getTypeClass()) {\n  case Type::Pointer:\n    MarkUsedTemplateParameters(Ctx,\n                               cast<PointerType>(T)->getPointeeType(),\n                               OnlyDeduced,\n                               Depth,\n                               Used);\n    break;\n\n  case Type::BlockPointer:\n    MarkUsedTemplateParameters(Ctx,\n                               cast<BlockPointerType>(T)->getPointeeType(),\n                               OnlyDeduced,\n                               Depth,\n                               Used);\n    break;\n\n  case Type::LValueReference:\n  case Type::RValueReference:\n    MarkUsedTemplateParameters(Ctx,\n                               cast<ReferenceType>(T)->getPointeeType(),\n                               OnlyDeduced,\n                               Depth,\n                               Used);\n    break;\n\n  case Type::MemberPointer: {\n    const MemberPointerType *MemPtr = cast<MemberPointerType>(T.getTypePtr());\n    MarkUsedTemplateParameters(Ctx, MemPtr->getPointeeType(), OnlyDeduced,\n                               Depth, Used);\n    MarkUsedTemplateParameters(Ctx, QualType(MemPtr->getClass(), 0),\n                               OnlyDeduced, Depth, Used);\n    break;\n  }\n\n  case Type::DependentSizedArray:\n    MarkUsedTemplateParameters(Ctx,\n                               cast<DependentSizedArrayType>(T)->getSizeExpr(),\n                               OnlyDeduced, Depth, Used);\n    // Fall through to check the element type\n    LLVM_FALLTHROUGH;\n\n  case Type::ConstantArray:\n  case Type::IncompleteArray:\n    MarkUsedTemplateParameters(Ctx,\n                               cast<ArrayType>(T)->getElementType(),\n                               OnlyDeduced, Depth, Used);\n    break;\n\n  case Type::Vector:\n  case Type::ExtVector:\n    MarkUsedTemplateParameters(Ctx,\n                               cast<VectorType>(T)->getElementType(),\n                               OnlyDeduced, Depth, Used);\n    break;\n\n  case Type::DependentVector: {\n    const auto *VecType = cast<DependentVectorType>(T);\n    MarkUsedTemplateParameters(Ctx, VecType->getElementType(), OnlyDeduced,\n                               Depth, Used);\n    MarkUsedTemplateParameters(Ctx, VecType->getSizeExpr(), OnlyDeduced, Depth,\n                               Used);\n    break;\n  }\n  case Type::DependentSizedExtVector: {\n    const DependentSizedExtVectorType *VecType\n      = cast<DependentSizedExtVectorType>(T);\n    MarkUsedTemplateParameters(Ctx, VecType->getElementType(), OnlyDeduced,\n                               Depth, Used);\n    MarkUsedTemplateParameters(Ctx, VecType->getSizeExpr(), OnlyDeduced,\n                               Depth, Used);\n    break;\n  }\n\n  case Type::DependentAddressSpace: {\n    const DependentAddressSpaceType *DependentASType =\n        cast<DependentAddressSpaceType>(T);\n    MarkUsedTemplateParameters(Ctx, DependentASType->getPointeeType(),\n                               OnlyDeduced, Depth, Used);\n    MarkUsedTemplateParameters(Ctx,\n                               DependentASType->getAddrSpaceExpr(),\n                               OnlyDeduced, Depth, Used);\n    break;\n  }\n\n  case Type::ConstantMatrix: {\n    const ConstantMatrixType *MatType = cast<ConstantMatrixType>(T);\n    MarkUsedTemplateParameters(Ctx, MatType->getElementType(), OnlyDeduced,\n                               Depth, Used);\n    break;\n  }\n\n  case Type::DependentSizedMatrix: {\n    const DependentSizedMatrixType *MatType = cast<DependentSizedMatrixType>(T);\n    MarkUsedTemplateParameters(Ctx, MatType->getElementType(), OnlyDeduced,\n                               Depth, Used);\n    MarkUsedTemplateParameters(Ctx, MatType->getRowExpr(), OnlyDeduced, Depth,\n                               Used);\n    MarkUsedTemplateParameters(Ctx, MatType->getColumnExpr(), OnlyDeduced,\n                               Depth, Used);\n    break;\n  }\n\n  case Type::FunctionProto: {\n    const FunctionProtoType *Proto = cast<FunctionProtoType>(T);\n    MarkUsedTemplateParameters(Ctx, Proto->getReturnType(), OnlyDeduced, Depth,\n                               Used);\n    for (unsigned I = 0, N = Proto->getNumParams(); I != N; ++I) {\n      // C++17 [temp.deduct.type]p5:\n      //   The non-deduced contexts are: [...]\n      //   -- A function parameter pack that does not occur at the end of the\n      //      parameter-declaration-list.\n      if (!OnlyDeduced || I + 1 == N ||\n          !Proto->getParamType(I)->getAs<PackExpansionType>()) {\n        MarkUsedTemplateParameters(Ctx, Proto->getParamType(I), OnlyDeduced,\n                                   Depth, Used);\n      } else {\n        // FIXME: C++17 [temp.deduct.call]p1:\n        //   When a function parameter pack appears in a non-deduced context,\n        //   the type of that pack is never deduced.\n        //\n        // We should also track a set of \"never deduced\" parameters, and\n        // subtract that from the list of deduced parameters after marking.\n      }\n    }\n    if (auto *E = Proto->getNoexceptExpr())\n      MarkUsedTemplateParameters(Ctx, E, OnlyDeduced, Depth, Used);\n    break;\n  }\n\n  case Type::TemplateTypeParm: {\n    const TemplateTypeParmType *TTP = cast<TemplateTypeParmType>(T);\n    if (TTP->getDepth() == Depth)\n      Used[TTP->getIndex()] = true;\n    break;\n  }\n\n  case Type::SubstTemplateTypeParmPack: {\n    const SubstTemplateTypeParmPackType *Subst\n      = cast<SubstTemplateTypeParmPackType>(T);\n    MarkUsedTemplateParameters(Ctx,\n                               QualType(Subst->getReplacedParameter(), 0),\n                               OnlyDeduced, Depth, Used);\n    MarkUsedTemplateParameters(Ctx, Subst->getArgumentPack(),\n                               OnlyDeduced, Depth, Used);\n    break;\n  }\n\n  case Type::InjectedClassName:\n    T = cast<InjectedClassNameType>(T)->getInjectedSpecializationType();\n    LLVM_FALLTHROUGH;\n\n  case Type::TemplateSpecialization: {\n    const TemplateSpecializationType *Spec\n      = cast<TemplateSpecializationType>(T);\n    MarkUsedTemplateParameters(Ctx, Spec->getTemplateName(), OnlyDeduced,\n                               Depth, Used);\n\n    // C++0x [temp.deduct.type]p9:\n    //   If the template argument list of P contains a pack expansion that is\n    //   not the last template argument, the entire template argument list is a\n    //   non-deduced context.\n    if (OnlyDeduced &&\n        hasPackExpansionBeforeEnd(Spec->template_arguments()))\n      break;\n\n    for (unsigned I = 0, N = Spec->getNumArgs(); I != N; ++I)\n      MarkUsedTemplateParameters(Ctx, Spec->getArg(I), OnlyDeduced, Depth,\n                                 Used);\n    break;\n  }\n\n  case Type::Complex:\n    if (!OnlyDeduced)\n      MarkUsedTemplateParameters(Ctx,\n                                 cast<ComplexType>(T)->getElementType(),\n                                 OnlyDeduced, Depth, Used);\n    break;\n\n  case Type::Atomic:\n    if (!OnlyDeduced)\n      MarkUsedTemplateParameters(Ctx,\n                                 cast<AtomicType>(T)->getValueType(),\n                                 OnlyDeduced, Depth, Used);\n    break;\n\n  case Type::DependentName:\n    if (!OnlyDeduced)\n      MarkUsedTemplateParameters(Ctx,\n                                 cast<DependentNameType>(T)->getQualifier(),\n                                 OnlyDeduced, Depth, Used);\n    break;\n\n  case Type::DependentTemplateSpecialization: {\n    // C++14 [temp.deduct.type]p5:\n    //   The non-deduced contexts are:\n    //     -- The nested-name-specifier of a type that was specified using a\n    //        qualified-id\n    //\n    // C++14 [temp.deduct.type]p6:\n    //   When a type name is specified in a way that includes a non-deduced\n    //   context, all of the types that comprise that type name are also\n    //   non-deduced.\n    if (OnlyDeduced)\n      break;\n\n    const DependentTemplateSpecializationType *Spec\n      = cast<DependentTemplateSpecializationType>(T);\n\n    MarkUsedTemplateParameters(Ctx, Spec->getQualifier(),\n                               OnlyDeduced, Depth, Used);\n\n    for (unsigned I = 0, N = Spec->getNumArgs(); I != N; ++I)\n      MarkUsedTemplateParameters(Ctx, Spec->getArg(I), OnlyDeduced, Depth,\n                                 Used);\n    break;\n  }\n\n  case Type::TypeOf:\n    if (!OnlyDeduced)\n      MarkUsedTemplateParameters(Ctx,\n                                 cast<TypeOfType>(T)->getUnderlyingType(),\n                                 OnlyDeduced, Depth, Used);\n    break;\n\n  case Type::TypeOfExpr:\n    if (!OnlyDeduced)\n      MarkUsedTemplateParameters(Ctx,\n                                 cast<TypeOfExprType>(T)->getUnderlyingExpr(),\n                                 OnlyDeduced, Depth, Used);\n    break;\n\n  case Type::Decltype:\n    if (!OnlyDeduced)\n      MarkUsedTemplateParameters(Ctx,\n                                 cast<DecltypeType>(T)->getUnderlyingExpr(),\n                                 OnlyDeduced, Depth, Used);\n    break;\n\n  case Type::UnaryTransform:\n    if (!OnlyDeduced)\n      MarkUsedTemplateParameters(Ctx,\n                                 cast<UnaryTransformType>(T)->getUnderlyingType(),\n                                 OnlyDeduced, Depth, Used);\n    break;\n\n  case Type::PackExpansion:\n    MarkUsedTemplateParameters(Ctx,\n                               cast<PackExpansionType>(T)->getPattern(),\n                               OnlyDeduced, Depth, Used);\n    break;\n\n  case Type::Auto:\n  case Type::DeducedTemplateSpecialization:\n    MarkUsedTemplateParameters(Ctx,\n                               cast<DeducedType>(T)->getDeducedType(),\n                               OnlyDeduced, Depth, Used);\n    break;\n  case Type::DependentExtInt:\n    MarkUsedTemplateParameters(Ctx,\n                               cast<DependentExtIntType>(T)->getNumBitsExpr(),\n                               OnlyDeduced, Depth, Used);\n    break;\n\n  // None of these types have any template parameters in them.\n  case Type::Builtin:\n  case Type::VariableArray:\n  case Type::FunctionNoProto:\n  case Type::Record:\n  case Type::Enum:\n  case Type::ObjCInterface:\n  case Type::ObjCObject:\n  case Type::ObjCObjectPointer:\n  case Type::UnresolvedUsing:\n  case Type::Pipe:\n  case Type::ExtInt:\n#define TYPE(Class, Base)\n#define ABSTRACT_TYPE(Class, Base)\n#define DEPENDENT_TYPE(Class, Base)\n#define NON_CANONICAL_TYPE(Class, Base) case Type::Class:\n#include \"clang/AST/TypeNodes.inc\"\n    break;\n  }\n}\n\n/// Mark the template parameters that are used by this\n/// template argument.\nstatic void\nMarkUsedTemplateParameters(ASTContext &Ctx,\n                           const TemplateArgument &TemplateArg,\n                           bool OnlyDeduced,\n                           unsigned Depth,\n                           llvm::SmallBitVector &Used) {\n  switch (TemplateArg.getKind()) {\n  case TemplateArgument::Null:\n  case TemplateArgument::Integral:\n  case TemplateArgument::Declaration:\n    break;\n\n  case TemplateArgument::NullPtr:\n    MarkUsedTemplateParameters(Ctx, TemplateArg.getNullPtrType(), OnlyDeduced,\n                               Depth, Used);\n    break;\n\n  case TemplateArgument::Type:\n    MarkUsedTemplateParameters(Ctx, TemplateArg.getAsType(), OnlyDeduced,\n                               Depth, Used);\n    break;\n\n  case TemplateArgument::Template:\n  case TemplateArgument::TemplateExpansion:\n    MarkUsedTemplateParameters(Ctx,\n                               TemplateArg.getAsTemplateOrTemplatePattern(),\n                               OnlyDeduced, Depth, Used);\n    break;\n\n  case TemplateArgument::Expression:\n    MarkUsedTemplateParameters(Ctx, TemplateArg.getAsExpr(), OnlyDeduced,\n                               Depth, Used);\n    break;\n\n  case TemplateArgument::Pack:\n    for (const auto &P : TemplateArg.pack_elements())\n      MarkUsedTemplateParameters(Ctx, P, OnlyDeduced, Depth, Used);\n    break;\n  }\n}\n\n/// Mark which template parameters are used in a given expression.\n///\n/// \\param E the expression from which template parameters will be deduced.\n///\n/// \\param Used a bit vector whose elements will be set to \\c true\n/// to indicate when the corresponding template parameter will be\n/// deduced.\nvoid\nSema::MarkUsedTemplateParameters(const Expr *E, bool OnlyDeduced,\n                                 unsigned Depth,\n                                 llvm::SmallBitVector &Used) {\n  ::MarkUsedTemplateParameters(Context, E, OnlyDeduced, Depth, Used);\n}\n\n/// Mark which template parameters can be deduced from a given\n/// template argument list.\n///\n/// \\param TemplateArgs the template argument list from which template\n/// parameters will be deduced.\n///\n/// \\param Used a bit vector whose elements will be set to \\c true\n/// to indicate when the corresponding template parameter will be\n/// deduced.\nvoid\nSema::MarkUsedTemplateParameters(const TemplateArgumentList &TemplateArgs,\n                                 bool OnlyDeduced, unsigned Depth,\n                                 llvm::SmallBitVector &Used) {\n  // C++0x [temp.deduct.type]p9:\n  //   If the template argument list of P contains a pack expansion that is not\n  //   the last template argument, the entire template argument list is a\n  //   non-deduced context.\n  if (OnlyDeduced &&\n      hasPackExpansionBeforeEnd(TemplateArgs.asArray()))\n    return;\n\n  for (unsigned I = 0, N = TemplateArgs.size(); I != N; ++I)\n    ::MarkUsedTemplateParameters(Context, TemplateArgs[I], OnlyDeduced,\n                                 Depth, Used);\n}\n\n/// Marks all of the template parameters that will be deduced by a\n/// call to the given function template.\nvoid Sema::MarkDeducedTemplateParameters(\n    ASTContext &Ctx, const FunctionTemplateDecl *FunctionTemplate,\n    llvm::SmallBitVector &Deduced) {\n  TemplateParameterList *TemplateParams\n    = FunctionTemplate->getTemplateParameters();\n  Deduced.clear();\n  Deduced.resize(TemplateParams->size());\n\n  FunctionDecl *Function = FunctionTemplate->getTemplatedDecl();\n  for (unsigned I = 0, N = Function->getNumParams(); I != N; ++I)\n    ::MarkUsedTemplateParameters(Ctx, Function->getParamDecl(I)->getType(),\n                                 true, TemplateParams->getDepth(), Deduced);\n}\n\nbool hasDeducibleTemplateParameters(Sema &S,\n                                    FunctionTemplateDecl *FunctionTemplate,\n                                    QualType T) {\n  if (!T->isDependentType())\n    return false;\n\n  TemplateParameterList *TemplateParams\n    = FunctionTemplate->getTemplateParameters();\n  llvm::SmallBitVector Deduced(TemplateParams->size());\n  ::MarkUsedTemplateParameters(S.Context, T, true, TemplateParams->getDepth(),\n                               Deduced);\n\n  return Deduced.any();\n}\n"}}, "reports": [{"events": [{"location": {"col": 7, "file": 13, "line": 243}, "message": "move assignment operator 'operator=' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/NestedNameSpecifier.h", "reportHash": "3b6f7dea24442930a0cc09e20f04a12e", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 15, "line": 62}, "message": "move assignment operator 'operator=' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/TemplateBase.h", "reportHash": "e8ecc0c93a3517776c89334c8d381a42", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 10, "file": 15, "line": 107}, "message": "move assignment operator 'operator=' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/TemplateBase.h", "reportHash": "253ae0f786d9969b3a6f1607dad16216", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 10, "file": 15, "line": 112}, "message": "move assignment operator 'operator=' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/TemplateBase.h", "reportHash": "ba46c4f8fe6c7db8a1c402e0db020294", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 5, "file": 15, "line": 119}, "message": "move assignment operator 'operator=' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/TemplateBase.h", "reportHash": "192deda34c9b4691e7c3c2e2ca1be538", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 10, "file": 15, "line": 128}, "message": "move assignment operator 'operator=' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/TemplateBase.h", "reportHash": "64cc038ac1a3146c2967db79a53f38bd", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 10, "file": 15, "line": 133}, "message": "move assignment operator 'operator=' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/TemplateBase.h", "reportHash": "d383af693cd9ad9d32d7194841074162", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 10, "file": 15, "line": 138}, "message": "move assignment operator 'operator=' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/TemplateBase.h", "reportHash": "8fd722449a21575a2c21665c610e666c", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 15, "line": 142}, "message": "move assignment operator 'operator=' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/TemplateBase.h", "reportHash": "9b929dfa0c4e6744cc88ab0d714873d8", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 15, "line": 405}, "message": "move constructor 'TemplateArgumentLocInfo' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/TemplateBase.h", "reportHash": "4891285b231be05a65e7cbc78dd07160", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 15, "line": 457}, "message": "move assignment operator 'operator=' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/TemplateBase.h", "reportHash": "0efb3cee2f21f24021d601deecaf9553", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 9, "file": 26, "line": 232}, "message": "destructor '~DeducedTemplateArgument' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Sema/Template.h", "reportHash": "245aad8f7b572091d89dd6a2d7fe9641", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 9, "file": 26, "line": 232}, "message": "move assignment operator 'operator=' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Sema/Template.h", "reportHash": "66eeb75f9c3a5ce2b9021f6fc5b29d5b", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 9, "file": 26, "line": 232}, "message": "move constructor 'DeducedTemplateArgument' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Sema/Template.h", "reportHash": "5874999e20f5f8dc7b75802d7860aecb", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 20, "file": 27, "line": 729}, "message": "destructor '~' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp", "reportHash": "2259f548a2a05a318a5aeaeefc8f483e", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 20, "file": 27, "line": 729}, "message": "move constructor '' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp", "reportHash": "6b3db8c976a649d28fe1df1f7aad217e", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 20, "file": 27, "line": 749}, "message": "destructor '~' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp", "reportHash": "b2c86ba9285083b5d03f2f1b3d7a28e0", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 20, "file": 27, "line": 749}, "message": "move constructor '' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp", "reportHash": "6f572c992125779ffa254cec98f957de", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 19, "file": 27, "line": 1252}, "message": "destructor '~' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp", "reportHash": "5dfb5c52ff76ff484453053abea53196", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 19, "file": 27, "line": 1252}, "message": "move constructor '' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp", "reportHash": "ce6169fd8308f81ba5be4df9494d241f", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 11, "file": 27, "line": 2151}, "message": "destructor '~' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp", "reportHash": "550f3bd4186bec6e305656a3e6cebe29", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 11, "file": 27, "line": 2151}, "message": "move constructor '' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp", "reportHash": "e14247152755d4d5f14f16fae63ca6a3", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 21, "file": 27, "line": 2710}, "message": "destructor '~' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp", "reportHash": "9df6a60b0fae12e34920e9c9d60ec525", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 21, "file": 27, "line": 2710}, "message": "move constructor '' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp", "reportHash": "9990e97868408b2d9a885fa864e691f8", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}]};
      window.onload = function() {
        if (!browserCompatible) {
          setNonCompatibleBrowserMessage();
        } else {
          BugViewer.init(data.files, data.reports);
          BugViewer.create();
          BugViewer.initByUrl();
        }
      };
    </script>
  </head>
  <body>
  <div class="container">
    <div id="content">
      <div id="side-bar">
        <div class="header">
          <a href="index.html" class="button">&#8249; Return to List</a>
        </div>
        <div id="report-nav">
          <div class="header">Reports</div>
        </div>
      </div>
      <div id="editor-wrapper">
        <div class="header">
          <div id="file">
            <span class="label">File:</span>
            <span id="file-path"></span>
          </div>
          <div id="checker">
            <span class="label">Checker name:</span>
            <span id="checker-name"></span>
          </div>
          <div id="review-status-wrapper">
            <span class="label">Review status:</span>
            <span id="review-status"></span>
          </div>
        </div>
        <div id="editor"></div>
      </div>
    </div>
  </div>
  </body>
</html>
