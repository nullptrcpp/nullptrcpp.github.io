<!DOCTYPE html>
<html>
  <head>
    <title>Plist HTML Viewer</title>

    <meta charset="UTF-8">

    <style type="text/css">
      .CodeMirror{font-family:monospace;height:300px;color:#000;direction:ltr}.CodeMirror-lines{padding:4px 0}.CodeMirror pre{padding:0 4px}.CodeMirror-gutter-filler,.CodeMirror-scrollbar-filler{background-color:#fff}.CodeMirror-gutters{border-right:1px solid #ddd;background-color:#f7f7f7;white-space:nowrap}.CodeMirror-linenumber{padding:0 3px 0 5px;min-width:20px;text-align:right;color:#999;white-space:nowrap}.CodeMirror-guttermarker{color:#000}.CodeMirror-guttermarker-subtle{color:#999}.CodeMirror-cursor{border-left:1px solid #000;border-right:none;width:0}.CodeMirror div.CodeMirror-secondarycursor{border-left:1px solid silver}.cm-fat-cursor .CodeMirror-cursor{width:auto;border:0!important;background:#7e7}.cm-fat-cursor div.CodeMirror-cursors{z-index:1}.cm-animate-fat-cursor{width:auto;border:0;-webkit-animation:blink 1.06s steps(1) infinite;-moz-animation:blink 1.06s steps(1) infinite;animation:blink 1.06s steps(1) infinite;background-color:#7e7}@-moz-keyframes blink{50%{background-color:transparent}}@-webkit-keyframes blink{50%{background-color:transparent}}@keyframes blink{50%{background-color:transparent}}.cm-tab{display:inline-block;text-decoration:inherit}.CodeMirror-rulers{position:absolute;left:0;right:0;top:-50px;bottom:-20px;overflow:hidden}.CodeMirror-ruler{border-left:1px solid #ccc;top:0;bottom:0;position:absolute}.cm-s-default .cm-header{color:#00f}.cm-s-default .cm-quote{color:#090}.cm-negative{color:#d44}.cm-positive{color:#292}.cm-header,.cm-strong{font-weight:700}.cm-em{font-style:italic}.cm-link{text-decoration:underline}.cm-strikethrough{text-decoration:line-through}.cm-s-default .cm-keyword{color:#708}.cm-s-default .cm-atom{color:#219}.cm-s-default .cm-number{color:#164}.cm-s-default .cm-def{color:#00f}.cm-s-default .cm-variable-2{color:#05a}.cm-s-default .cm-type,.cm-s-default .cm-variable-3{color:#085}.cm-s-default .cm-comment{color:#a50}.cm-s-default .cm-string{color:#a11}.cm-s-default .cm-string-2{color:#f50}.cm-s-default .cm-meta{color:#555}.cm-s-default .cm-qualifier{color:#555}.cm-s-default .cm-builtin{color:#30a}.cm-s-default .cm-bracket{color:#997}.cm-s-default .cm-tag{color:#170}.cm-s-default .cm-attribute{color:#00c}.cm-s-default .cm-hr{color:#999}.cm-s-default .cm-link{color:#00c}.cm-s-default .cm-error{color:red}.cm-invalidchar{color:red}.CodeMirror-composing{border-bottom:2px solid}div.CodeMirror span.CodeMirror-matchingbracket{color:#0f0}div.CodeMirror span.CodeMirror-nonmatchingbracket{color:#f22}.CodeMirror-matchingtag{background:rgba(255,150,0,.3)}.CodeMirror-activeline-background{background:#e8f2ff}.CodeMirror{position:relative;overflow:hidden;background:#fff}.CodeMirror-scroll{overflow:scroll!important;margin-bottom:-30px;margin-right:-30px;padding-bottom:30px;height:100%;outline:0;position:relative}.CodeMirror-sizer{position:relative;border-right:30px solid transparent}.CodeMirror-gutter-filler,.CodeMirror-hscrollbar,.CodeMirror-scrollbar-filler,.CodeMirror-vscrollbar{position:absolute;z-index:6;display:none}.CodeMirror-vscrollbar{right:0;top:0;overflow-x:hidden;overflow-y:scroll}.CodeMirror-hscrollbar{bottom:0;left:0;overflow-y:hidden;overflow-x:scroll}.CodeMirror-scrollbar-filler{right:0;bottom:0}.CodeMirror-gutter-filler{left:0;bottom:0}.CodeMirror-gutters{position:absolute;left:0;top:0;min-height:100%;z-index:3}.CodeMirror-gutter{white-space:normal;height:100%;display:inline-block;vertical-align:top;margin-bottom:-30px}.CodeMirror-gutter-wrapper{position:absolute;z-index:4;background:0 0!important;border:none!important}.CodeMirror-gutter-background{position:absolute;top:0;bottom:0;z-index:4}.CodeMirror-gutter-elt{position:absolute;cursor:default;z-index:4}.CodeMirror-gutter-wrapper ::selection{background-color:transparent}.CodeMirror-gutter-wrapper ::-moz-selection{background-color:transparent}.CodeMirror-lines{cursor:text;min-height:1px}.CodeMirror pre{-moz-border-radius:0;-webkit-border-radius:0;border-radius:0;border-width:0;background:0 0;font-family:inherit;font-size:inherit;margin:0;white-space:pre;word-wrap:normal;line-height:inherit;color:inherit;z-index:2;position:relative;overflow:visible;-webkit-tap-highlight-color:transparent;-webkit-font-variant-ligatures:contextual;font-variant-ligatures:contextual}.CodeMirror-wrap pre{word-wrap:break-word;white-space:pre-wrap;word-break:normal}.CodeMirror-linebackground{position:absolute;left:0;right:0;top:0;bottom:0;z-index:0}.CodeMirror-linewidget{position:relative;z-index:2;overflow:auto}.CodeMirror-rtl pre{direction:rtl}.CodeMirror-code{outline:0}.CodeMirror-gutter,.CodeMirror-gutters,.CodeMirror-linenumber,.CodeMirror-scroll,.CodeMirror-sizer{-moz-box-sizing:content-box;box-sizing:content-box}.CodeMirror-measure{position:absolute;width:100%;height:0;overflow:hidden;visibility:hidden}.CodeMirror-cursor{position:absolute;pointer-events:none}.CodeMirror-measure pre{position:static}div.CodeMirror-cursors{visibility:hidden;position:relative;z-index:3}div.CodeMirror-dragcursors{visibility:visible}.CodeMirror-focused div.CodeMirror-cursors{visibility:visible}.CodeMirror-selected{background:#d9d9d9}.CodeMirror-focused .CodeMirror-selected{background:#d7d4f0}.CodeMirror-crosshair{cursor:crosshair}.CodeMirror-line::selection,.CodeMirror-line>span::selection,.CodeMirror-line>span>span::selection{background:#d7d4f0}.CodeMirror-line::-moz-selection,.CodeMirror-line>span::-moz-selection,.CodeMirror-line>span>span::-moz-selection{background:#d7d4f0}.cm-searching{background-color:#ffa;background-color:rgba(255,255,0,.4)}.cm-force-border{padding-right:.1px}@media print{.CodeMirror div.CodeMirror-cursors{visibility:hidden}}.cm-tab-wrap-hack:after{content:''}span.CodeMirror-selectedtext{background:0 0}
/*# sourceMappingURL=codemirror.min.css.map */

      .severity-low {
  background-color: #669603;
}

.severity-low:after {
  content : 'L';
}

.severity-unspecified {
  background-color: #666666;
}

.severity-unspecified:after {
  content : 'U';
}

.severity-style {
  background-color: #9932cc;
}

.severity-style:after {
  content : 'S';
}

.severity-medium {
  background-color: #a9d323;
  color: black;
}

.severity-medium:after {
  content : 'M';
}

.severity-high {
  background-color: #ffa800;
}

.severity-high:after {
  content : 'H';
}

.severity-critical {
  background-color: #e92625;
}

.severity-critical:after {
  content : 'C';
}

i[class*="severity-"] {
  line-height: normal;
  text-transform: capitalize;
  font-size: 0.8em;
  font-weight: bold;
  color: white;
  display: inline-block;
  width: 16px;
  height: 16px;
  text-align: center;
  font-family: sans-serif;
}

      html, body {
  width: 100%;
  height: 100%;
  padding: 0px;
  margin: 0px;
}

div.container {
  padding: 10px;
}

#content {
  height: 100%;
  display: block;
  overflow: hidden;
}

#content > div {
  margin: 10px;
  overflow: hidden;
  border: 1px solid #ddd;
  border-radius: 3px;
  overflow: hidden;
  height: 97%;
}

.button {
  background-color: #f1f1f1;
  text-decoration: none;
  display: inline-block;
  padding: 8px 16px;
  color: black;
  cursor: pointer;
}

.button:hover {
  background-color: #ddd;
  color: black;
}

.review-status {
  color: white;
  text-align: center;
}

.review-status-confirmed {
  background-color: #e92625;
}

.review-status-false-positive {
  background-color: grey;
}

.review-status-intentional {
  background-color: #669603;
}

      div.container {
  width: 100%;
  height: 100%;
  padding: 0px;
}

#editor-wrapper {
  margin: 10px;
}

#side-bar {
  float: left;
  width: 260px;
  margin: 0px;
}

#report-nav ul {
  list-style-type: none;
  padding: 0;
  margin: 0;
  overflow-y: auto;
  height: 100%;
}

#report-nav ul > li {
  padding: .4em;
  background-color: #fff;
  border-bottom: 1px solid rgba(0,0,0,.125);
  text-align: left;
  overflow: hidden;
  white-space: nowrap;
  text-overflow: ellipsis;
}

#report-nav ul > li.active {
  background-color: #427ea9;
  color: white;
}

#report-nav ul > li:hover {
  background-color: #427ea9;
  color: white;
  cursor: pointer;
}

#report-nav ul a {
  text-decoration: none;
}

#report-nav i[class*="severity-"] {
  margin-right: 5px;
}

.header {
  border-bottom: 1px solid lightgrey;
  font-family: monospace;
  padding: 10px;
  background-color: #fafbfc;
  border-bottom: 1px solid #e1e4e8;
  border-top-left-radius: 2px;
  border-top-right-radius: 2px;
}

#report-nav .header {
  font-weight: bold;
}

#editor-wrapper .header > div {
  padding-top: 2px;
}

#file-path,
#checker-name {
  color: #195ea2;
}

#review-status {
  padding: 0px 5px;
}

#file-path {
  font-family: monospace;
}

.check-msg {
  display: inline-block;
  padding: 3px 6px;
  margin: 1px;
  -webkit-border-radius: 5px;
  -moz-border-radius: 5px;
  border-radius: 5px;
}

.check-msg.info {
  color: #00546f;
  background-color: #bfdfe9;
  border: 1px solid #87a8b3;
}

.check-msg.error {
  background-color: #f2dede;
  color: #a94442;
  border: 1px solid #ebcccc;
}

.check-msg.macro {
  background-color: #d7dac2;
  color: #4f5c6d;
  border: 1px solid #d7dac2;
}

.check-msg.note {
  background-color: #d7d7d7;
  color: #4f5c6d;
  border: 1px solid #bfbfbf;
}

.check-msg.current {
  border: 2px dashed #3692ff;
}

.check-msg .tag {
  padding: 1px 5px;
  text-align: center;
  border-radius: 2px;
  margin-right: 5px;
  text-decoration: inherit;
}

.check-msg .tag.macro {
  background-color: #83876a;
  color: white;
  text-transform: capitalize;
}

.check-msg .tag.note {
  background-color: #9299a1;
  color: white;
  text-transform: capitalize;
}

.checker-enum {
  color: white;
  padding: 1px 5px;
  text-align: center;
  border-radius: 25px;
  margin-right: 5px;
  text-decoration: inherit;
}

.checker-enum.info {
  background-color: #427ea9;
}

.checker-enum.error {
  background-color: #a94442;
}

.arrow {
  border: solid black;
  border-width: 0 3px 3px 0;
  display: inline-block;
  padding: 3px;
  cursor: pointer;
  margin: 0px 5px;
}

.arrow:hover {
  border: solid #437ea8;
  border-width: 0 3px 3px 0;
}

.left-arrow {
  transform: rotate(135deg);
  -webkit-transform: rotate(135deg);
}

.right-arrow {
  transform: rotate(-45deg);
  -webkit-transform: rotate(-45deg);
}

    </style>

    <script type="text/javascript">
      function setNonCompatibleBrowserMessage() {
  document.body.innerHTML =
    '<h2 style="margin-left: 20px;">Your browser is not compatible with CodeChecker Viewer!</h2> \
     <p style="margin-left: 20px;">The version required for the following browsers are:</p> \
     <ul style="margin-left: 20px;"> \
     <li>Internet Explorer: version 9 or newer</li> \
     <li>Firefox: version 22.0 or newer</li> \
     </ul>';
}

// http://stackoverflow.com/questions/5916900/how-can-you-detect-the-version-of-a-browser
var browserVersion = (function(){
  var ua = navigator.userAgent, tem,
    M = ua.match(/(opera|chrome|safari|firefox|msie|trident(?=\/))\/?\s*(\d+)/i) || [];

  if (/trident/i.test(M[1])) {
    tem = /\brv[ :]+(\d+)/g.exec(ua) || [];
    return 'IE ' + (tem[1] || '');
  }

  if (M[1] === 'Chrome') {
    tem = ua.match(/\b(OPR|Edge)\/(\d+)/);
    if (tem != null) return tem.slice(1).join(' ').replace('OPR', 'Opera');
  }

  M = M[2] ? [M[1], M[2]] : [navigator.appName, navigator.appVersion, '-?'];
  if ((tem = ua.match(/version\/(\d+)/i)) != null) M.splice(1, 1, tem[1]);
    return M.join(' ');
})();

var pos = browserVersion.indexOf(' ');
var browser = browserVersion.substr(0, pos);
var version = parseInt(browserVersion.substr(pos + 1));

var browserCompatible
  = browser === 'Firefox'
  ? version >= 22
  : browser === 'IE'
  ? version >= 9
  : true;


      /* MIT License

Copyright (C) 2017 by Marijn Haverbeke <marijnh@gmail.com> and others

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
 */
      !function(e,t){"object"==typeof exports&&"undefined"!=typeof module?module.exports=t():"function"==typeof define&&define.amd?define(t):e.CodeMirror=t()}(this,function(){"use strict";function e(e){return new RegExp("(^|\\s)"+e+"(?:$|\\s)\\s*")}function t(e){for(var t=e.childNodes.length;t>0;--t)e.removeChild(e.firstChild);return e}function r(e,r){return t(e).appendChild(r)}function n(e,t,r,n){var i=document.createElement(e);if(r&&(i.className=r),n&&(i.style.cssText=n),"string"==typeof t)i.appendChild(document.createTextNode(t));else if(t)for(var o=0;o<t.length;++o)i.appendChild(t[o]);return i}function i(e,t,r,i){var o=n(e,t,r,i);return o.setAttribute("role","presentation"),o}function o(e,t){if(3==t.nodeType&&(t=t.parentNode),e.contains)return e.contains(t);do{if(11==t.nodeType&&(t=t.host),t==e)return!0}while(t=t.parentNode)}function l(){var e;try{e=document.activeElement}catch(t){e=document.body||null}for(;e&&e.shadowRoot&&e.shadowRoot.activeElement;)e=e.shadowRoot.activeElement;return e}function s(t,r){var n=t.className;e(r).test(n)||(t.className+=(n?" ":"")+r)}function a(t,r){for(var n=t.split(" "),i=0;i<n.length;i++)n[i]&&!e(n[i]).test(r)&&(r+=" "+n[i]);return r}function u(e){var t=Array.prototype.slice.call(arguments,1);return function(){return e.apply(null,t)}}function c(e,t,r){t||(t={});for(var n in e)!e.hasOwnProperty(n)||!1===r&&t.hasOwnProperty(n)||(t[n]=e[n]);return t}function f(e,t,r,n,i){null==t&&-1==(t=e.search(/[^\s\u00a0]/))&&(t=e.length);for(var o=n||0,l=i||0;;){var s=e.indexOf("\t",o);if(s<0||s>=t)return l+(t-o);l+=s-o,l+=r-l%r,o=s+1}}function h(e,t){for(var r=0;r<e.length;++r)if(e[r]==t)return r;return-1}function d(e,t,r){for(var n=0,i=0;;){var o=e.indexOf("\t",n);-1==o&&(o=e.length);var l=o-n;if(o==e.length||i+l>=t)return n+Math.min(l,t-i);if(i+=o-n,i+=r-i%r,n=o+1,i>=t)return n}}function p(e){for(;Kl.length<=e;)Kl.push(g(Kl)+" ");return Kl[e]}function g(e){return e[e.length-1]}function v(e,t){for(var r=[],n=0;n<e.length;n++)r[n]=t(e[n],n);return r}function m(e,t,r){for(var n=0,i=r(t);n<e.length&&r(e[n])<=i;)n++;e.splice(n,0,t)}function y(){}function b(e,t){var r;return Object.create?r=Object.create(e):(y.prototype=e,r=new y),t&&c(t,r),r}function w(e){return/\w/.test(e)||e>""&&(e.toUpperCase()!=e.toLowerCase()||jl.test(e))}function x(e,t){return t?!!(t.source.indexOf("\\w")>-1&&w(e))||t.test(e):w(e)}function C(e){for(var t in e)if(e.hasOwnProperty(t)&&e[t])return!1;return!0}function S(e){return e.charCodeAt(0)>=768&&Xl.test(e)}function L(e,t,r){for(;(r<0?t>0:t<e.length)&&S(e.charAt(t));)t+=r;return t}function k(e,t,r){for(var n=t>r?-1:1;;){if(t==r)return t;var i=(t+r)/2,o=n<0?Math.ceil(i):Math.floor(i);if(o==t)return e(o)?t:r;e(o)?r=o:t=o+n}}function T(e,t,r){var o=this;this.input=r,o.scrollbarFiller=n("div",null,"CodeMirror-scrollbar-filler"),o.scrollbarFiller.setAttribute("cm-not-content","true"),o.gutterFiller=n("div",null,"CodeMirror-gutter-filler"),o.gutterFiller.setAttribute("cm-not-content","true"),o.lineDiv=i("div",null,"CodeMirror-code"),o.selectionDiv=n("div",null,null,"position: relative; z-index: 1"),o.cursorDiv=n("div",null,"CodeMirror-cursors"),o.measure=n("div",null,"CodeMirror-measure"),o.lineMeasure=n("div",null,"CodeMirror-measure"),o.lineSpace=i("div",[o.measure,o.lineMeasure,o.selectionDiv,o.cursorDiv,o.lineDiv],null,"position: relative; outline: none");var l=i("div",[o.lineSpace],"CodeMirror-lines");o.mover=n("div",[l],null,"position: relative"),o.sizer=n("div",[o.mover],"CodeMirror-sizer"),o.sizerWidth=null,o.heightForcer=n("div",null,null,"position: absolute; height: "+Rl+"px; width: 1px;"),o.gutters=n("div",null,"CodeMirror-gutters"),o.lineGutter=null,o.scroller=n("div",[o.sizer,o.heightForcer,o.gutters],"CodeMirror-scroll"),o.scroller.setAttribute("tabIndex","-1"),o.wrapper=n("div",[o.scrollbarFiller,o.gutterFiller,o.scroller],"CodeMirror"),gl&&vl<8&&(o.gutters.style.zIndex=-1,o.scroller.style.paddingRight=0),ml||fl&&Tl||(o.scroller.draggable=!0),e&&(e.appendChild?e.appendChild(o.wrapper):e(o.wrapper)),o.viewFrom=o.viewTo=t.first,o.reportedViewFrom=o.reportedViewTo=t.first,o.view=[],o.renderedView=null,o.externalMeasured=null,o.viewOffset=0,o.lastWrapHeight=o.lastWrapWidth=0,o.updateLineNumbers=null,o.nativeBarWidth=o.barHeight=o.barWidth=0,o.scrollbarsClipped=!1,o.lineNumWidth=o.lineNumInnerWidth=o.lineNumChars=null,o.alignWidgets=!1,o.cachedCharWidth=o.cachedTextHeight=o.cachedPaddingH=null,o.maxLine=null,o.maxLineLength=0,o.maxLineChanged=!1,o.wheelDX=o.wheelDY=o.wheelStartX=o.wheelStartY=null,o.shift=!1,o.selForContextMenu=null,o.activeTouch=null,r.init(o)}function M(e,t){if((t-=e.first)<0||t>=e.size)throw new Error("There is no line "+(t+e.first)+" in the document.");for(var r=e;!r.lines;)for(var n=0;;++n){var i=r.children[n],o=i.chunkSize();if(t<o){r=i;break}t-=o}return r.lines[t]}function N(e,t,r){var n=[],i=t.line;return e.iter(t.line,r.line+1,function(e){var o=e.text;i==r.line&&(o=o.slice(0,r.ch)),i==t.line&&(o=o.slice(t.ch)),n.push(o),++i}),n}function O(e,t,r){var n=[];return e.iter(t,r,function(e){n.push(e.text)}),n}function A(e,t){var r=t-e.height;if(r)for(var n=e;n;n=n.parent)n.height+=r}function W(e){if(null==e.parent)return null;for(var t=e.parent,r=h(t.lines,e),n=t.parent;n;t=n,n=n.parent)for(var i=0;n.children[i]!=t;++i)r+=n.children[i].chunkSize();return r+t.first}function D(e,t){var r=e.first;e:do{for(var n=0;n<e.children.length;++n){var i=e.children[n],o=i.height;if(t<o){e=i;continue e}t-=o,r+=i.chunkSize()}return r}while(!e.lines);for(var l=0;l<e.lines.length;++l){var s=e.lines[l].height;if(t<s)break;t-=s}return r+l}function H(e,t){return t>=e.first&&t<e.first+e.size}function F(e,t){return String(e.lineNumberFormatter(t+e.firstLineNumber))}function E(e,t,r){if(void 0===r&&(r=null),!(this instanceof E))return new E(e,t,r);this.line=e,this.ch=t,this.sticky=r}function P(e,t){return e.line-t.line||e.ch-t.ch}function I(e,t){return e.sticky==t.sticky&&0==P(e,t)}function z(e){return E(e.line,e.ch)}function R(e,t){return P(e,t)<0?t:e}function B(e,t){return P(e,t)<0?e:t}function G(e,t){return Math.max(e.first,Math.min(t,e.first+e.size-1))}function U(e,t){if(t.line<e.first)return E(e.first,0);var r=e.first+e.size-1;return t.line>r?E(r,M(e,r).text.length):V(t,M(e,t.line).text.length)}function V(e,t){var r=e.ch;return null==r||r>t?E(e.line,t):r<0?E(e.line,0):e}function K(e,t){for(var r=[],n=0;n<t.length;n++)r[n]=U(e,t[n]);return r}function j(){Yl=!0}function X(){_l=!0}function Y(e,t,r){this.marker=e,this.from=t,this.to=r}function _(e,t){if(e)for(var r=0;r<e.length;++r){var n=e[r];if(n.marker==t)return n}}function $(e,t){for(var r,n=0;n<e.length;++n)e[n]!=t&&(r||(r=[])).push(e[n]);return r}function q(e,t){e.markedSpans=e.markedSpans?e.markedSpans.concat([t]):[t],t.marker.attachLine(e)}function Z(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t)||o.from==t&&"bookmark"==l.type&&(!r||!o.marker.insertLeft)){var s=null==o.to||(l.inclusiveRight?o.to>=t:o.to>t);(n||(n=[])).push(new Y(l,o.from,s?null:o.to))}}return n}function Q(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.to||(l.inclusiveRight?o.to>=t:o.to>t)||o.from==t&&"bookmark"==l.type&&(!r||o.marker.insertLeft)){var s=null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t);(n||(n=[])).push(new Y(l,s?null:o.from-t,null==o.to?null:o.to-t))}}return n}function J(e,t){if(t.full)return null;var r=H(e,t.from.line)&&M(e,t.from.line).markedSpans,n=H(e,t.to.line)&&M(e,t.to.line).markedSpans;if(!r&&!n)return null;var i=t.from.ch,o=t.to.ch,l=0==P(t.from,t.to),s=Z(r,i,l),a=Q(n,o,l),u=1==t.text.length,c=g(t.text).length+(u?i:0);if(s)for(var f=0;f<s.length;++f){var h=s[f];if(null==h.to){var d=_(a,h.marker);d?u&&(h.to=null==d.to?null:d.to+c):h.to=i}}if(a)for(var p=0;p<a.length;++p){var v=a[p];null!=v.to&&(v.to+=c),null==v.from?_(s,v.marker)||(v.from=c,u&&(s||(s=[])).push(v)):(v.from+=c,u&&(s||(s=[])).push(v))}s&&(s=ee(s)),a&&a!=s&&(a=ee(a));var m=[s];if(!u){var y,b=t.text.length-2;if(b>0&&s)for(var w=0;w<s.length;++w)null==s[w].to&&(y||(y=[])).push(new Y(s[w].marker,null,null));for(var x=0;x<b;++x)m.push(y);m.push(a)}return m}function ee(e){for(var t=0;t<e.length;++t){var r=e[t];null!=r.from&&r.from==r.to&&!1!==r.marker.clearWhenEmpty&&e.splice(t--,1)}return e.length?e:null}function te(e,t,r){var n=null;if(e.iter(t.line,r.line+1,function(e){if(e.markedSpans)for(var t=0;t<e.markedSpans.length;++t){var r=e.markedSpans[t].marker;!r.readOnly||n&&-1!=h(n,r)||(n||(n=[])).push(r)}}),!n)return null;for(var i=[{from:t,to:r}],o=0;o<n.length;++o)for(var l=n[o],s=l.find(0),a=0;a<i.length;++a){var u=i[a];if(!(P(u.to,s.from)<0||P(u.from,s.to)>0)){var c=[a,1],f=P(u.from,s.from),d=P(u.to,s.to);(f<0||!l.inclusiveLeft&&!f)&&c.push({from:u.from,to:s.from}),(d>0||!l.inclusiveRight&&!d)&&c.push({from:s.to,to:u.to}),i.splice.apply(i,c),a+=c.length-3}}return i}function re(e){var t=e.markedSpans;if(t){for(var r=0;r<t.length;++r)t[r].marker.detachLine(e);e.markedSpans=null}}function ne(e,t){if(t){for(var r=0;r<t.length;++r)t[r].marker.attachLine(e);e.markedSpans=t}}function ie(e){return e.inclusiveLeft?-1:0}function oe(e){return e.inclusiveRight?1:0}function le(e,t){var r=e.lines.length-t.lines.length;if(0!=r)return r;var n=e.find(),i=t.find(),o=P(n.from,i.from)||ie(e)-ie(t);if(o)return-o;var l=P(n.to,i.to)||oe(e)-oe(t);return l||t.id-e.id}function se(e,t){var r,n=_l&&e.markedSpans;if(n)for(var i=void 0,o=0;o<n.length;++o)(i=n[o]).marker.collapsed&&null==(t?i.from:i.to)&&(!r||le(r,i.marker)<0)&&(r=i.marker);return r}function ae(e){return se(e,!0)}function ue(e){return se(e,!1)}function ce(e,t,r,n,i){var o=M(e,t),l=_l&&o.markedSpans;if(l)for(var s=0;s<l.length;++s){var a=l[s];if(a.marker.collapsed){var u=a.marker.find(0),c=P(u.from,r)||ie(a.marker)-ie(i),f=P(u.to,n)||oe(a.marker)-oe(i);if(!(c>=0&&f<=0||c<=0&&f>=0)&&(c<=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.to,r)>=0:P(u.to,r)>0)||c>=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.from,n)<=0:P(u.from,n)<0)))return!0}}}function fe(e){for(var t;t=ae(e);)e=t.find(-1,!0).line;return e}function he(e){for(var t;t=ue(e);)e=t.find(1,!0).line;return e}function de(e){for(var t,r;t=ue(e);)e=t.find(1,!0).line,(r||(r=[])).push(e);return r}function pe(e,t){var r=M(e,t),n=fe(r);return r==n?t:W(n)}function ge(e,t){if(t>e.lastLine())return t;var r,n=M(e,t);if(!ve(e,n))return t;for(;r=ue(n);)n=r.find(1,!0).line;return W(n)+1}function ve(e,t){var r=_l&&t.markedSpans;if(r)for(var n=void 0,i=0;i<r.length;++i)if((n=r[i]).marker.collapsed){if(null==n.from)return!0;if(!n.marker.widgetNode&&0==n.from&&n.marker.inclusiveLeft&&me(e,t,n))return!0}}function me(e,t,r){if(null==r.to){var n=r.marker.find(1,!0);return me(e,n.line,_(n.line.markedSpans,r.marker))}if(r.marker.inclusiveRight&&r.to==t.text.length)return!0;for(var i=void 0,o=0;o<t.markedSpans.length;++o)if((i=t.markedSpans[o]).marker.collapsed&&!i.marker.widgetNode&&i.from==r.to&&(null==i.to||i.to!=r.from)&&(i.marker.inclusiveLeft||r.marker.inclusiveRight)&&me(e,t,i))return!0}function ye(e){for(var t=0,r=(e=fe(e)).parent,n=0;n<r.lines.length;++n){var i=r.lines[n];if(i==e)break;t+=i.height}for(var o=r.parent;o;r=o,o=r.parent)for(var l=0;l<o.children.length;++l){var s=o.children[l];if(s==r)break;t+=s.height}return t}function be(e){if(0==e.height)return 0;for(var t,r=e.text.length,n=e;t=ae(n);){var i=t.find(0,!0);n=i.from.line,r+=i.from.ch-i.to.ch}for(n=e;t=ue(n);){var o=t.find(0,!0);r-=n.text.length-o.from.ch,r+=(n=o.to.line).text.length-o.to.ch}return r}function we(e){var t=e.display,r=e.doc;t.maxLine=M(r,r.first),t.maxLineLength=be(t.maxLine),t.maxLineChanged=!0,r.iter(function(e){var r=be(e);r>t.maxLineLength&&(t.maxLineLength=r,t.maxLine=e)})}function xe(e,t,r,n){if(!e)return n(t,r,"ltr",0);for(var i=!1,o=0;o<e.length;++o){var l=e[o];(l.from<r&&l.to>t||t==r&&l.to==t)&&(n(Math.max(l.from,t),Math.min(l.to,r),1==l.level?"rtl":"ltr",o),i=!0)}i||n(t,r,"ltr")}function Ce(e,t,r){var n;$l=null;for(var i=0;i<e.length;++i){var o=e[i];if(o.from<t&&o.to>t)return i;o.to==t&&(o.from!=o.to&&"before"==r?n=i:$l=i),o.from==t&&(o.from!=o.to&&"before"!=r?n=i:$l=i)}return null!=n?n:$l}function Se(e,t){var r=e.order;return null==r&&(r=e.order=ql(e.text,t)),r}function Le(e,t){return e._handlers&&e._handlers[t]||Zl}function ke(e,t,r){if(e.removeEventListener)e.removeEventListener(t,r,!1);else if(e.detachEvent)e.detachEvent("on"+t,r);else{var n=e._handlers,i=n&&n[t];if(i){var o=h(i,r);o>-1&&(n[t]=i.slice(0,o).concat(i.slice(o+1)))}}}function Te(e,t){var r=Le(e,t);if(r.length)for(var n=Array.prototype.slice.call(arguments,2),i=0;i<r.length;++i)r[i].apply(null,n)}function Me(e,t,r){return"string"==typeof t&&(t={type:t,preventDefault:function(){this.defaultPrevented=!0}}),Te(e,r||t.type,e,t),He(t)||t.codemirrorIgnore}function Ne(e){var t=e._handlers&&e._handlers.cursorActivity;if(t)for(var r=e.curOp.cursorActivityHandlers||(e.curOp.cursorActivityHandlers=[]),n=0;n<t.length;++n)-1==h(r,t[n])&&r.push(t[n])}function Oe(e,t){return Le(e,t).length>0}function Ae(e){e.prototype.on=function(e,t){Ql(this,e,t)},e.prototype.off=function(e,t){ke(this,e,t)}}function We(e){e.preventDefault?e.preventDefault():e.returnValue=!1}function De(e){e.stopPropagation?e.stopPropagation():e.cancelBubble=!0}function He(e){return null!=e.defaultPrevented?e.defaultPrevented:0==e.returnValue}function Fe(e){We(e),De(e)}function Ee(e){return e.target||e.srcElement}function Pe(e){var t=e.which;return null==t&&(1&e.button?t=1:2&e.button?t=3:4&e.button&&(t=2)),Ml&&e.ctrlKey&&1==t&&(t=3),t}function Ie(e){if(null==Il){var t=n("span","​");r(e,n("span",[t,document.createTextNode("x")])),0!=e.firstChild.offsetHeight&&(Il=t.offsetWidth<=1&&t.offsetHeight>2&&!(gl&&vl<8))}var i=Il?n("span","​"):n("span"," ",null,"display: inline-block; width: 1px; margin-right: -1px");return i.setAttribute("cm-text",""),i}function ze(e){if(null!=zl)return zl;var n=r(e,document.createTextNode("AخA")),i=Wl(n,0,1).getBoundingClientRect(),o=Wl(n,1,2).getBoundingClientRect();return t(e),!(!i||i.left==i.right)&&(zl=o.right-i.right<3)}function Re(e){if(null!=ns)return ns;var t=r(e,n("span","x")),i=t.getBoundingClientRect(),o=Wl(t,0,1).getBoundingClientRect();return ns=Math.abs(i.left-o.left)>1}function Be(e,t){arguments.length>2&&(t.dependencies=Array.prototype.slice.call(arguments,2)),is[e]=t}function Ge(e){if("string"==typeof e&&os.hasOwnProperty(e))e=os[e];else if(e&&"string"==typeof e.name&&os.hasOwnProperty(e.name)){var t=os[e.name];"string"==typeof t&&(t={name:t}),(e=b(t,e)).name=t.name}else{if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+xml$/.test(e))return Ge("application/xml");if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+json$/.test(e))return Ge("application/json")}return"string"==typeof e?{name:e}:e||{name:"null"}}function Ue(e,t){t=Ge(t);var r=is[t.name];if(!r)return Ue(e,"text/plain");var n=r(e,t);if(ls.hasOwnProperty(t.name)){var i=ls[t.name];for(var o in i)i.hasOwnProperty(o)&&(n.hasOwnProperty(o)&&(n["_"+o]=n[o]),n[o]=i[o])}if(n.name=t.name,t.helperType&&(n.helperType=t.helperType),t.modeProps)for(var l in t.modeProps)n[l]=t.modeProps[l];return n}function Ve(e,t){c(t,ls.hasOwnProperty(e)?ls[e]:ls[e]={})}function Ke(e,t){if(!0===t)return t;if(e.copyState)return e.copyState(t);var r={};for(var n in t){var i=t[n];i instanceof Array&&(i=i.concat([])),r[n]=i}return r}function je(e,t){for(var r;e.innerMode&&(r=e.innerMode(t))&&r.mode!=e;)t=r.state,e=r.mode;return r||{mode:e,state:t}}function Xe(e,t,r){return!e.startState||e.startState(t,r)}function Ye(e,t,r,n){var i=[e.state.modeGen],o={};tt(e,t.text,e.doc.mode,r,function(e,t){return i.push(e,t)},o,n);for(var l=r.state,s=0;s<e.state.overlays.length;++s)!function(n){var l=e.state.overlays[n],s=1,a=0;r.state=!0,tt(e,t.text,l.mode,r,function(e,t){for(var r=s;a<e;){var n=i[s];n>e&&i.splice(s,1,e,i[s+1],n),s+=2,a=Math.min(e,n)}if(t)if(l.opaque)i.splice(r,s-r,e,"overlay "+t),s=r+2;else for(;r<s;r+=2){var o=i[r+1];i[r+1]=(o?o+" ":"")+"overlay "+t}},o)}(s);return r.state=l,{styles:i,classes:o.bgClass||o.textClass?o:null}}function _e(e,t,r){if(!t.styles||t.styles[0]!=e.state.modeGen){var n=$e(e,W(t)),i=t.text.length>e.options.maxHighlightLength&&Ke(e.doc.mode,n.state),o=Ye(e,t,n);i&&(n.state=i),t.stateAfter=n.save(!i),t.styles=o.styles,o.classes?t.styleClasses=o.classes:t.styleClasses&&(t.styleClasses=null),r===e.doc.highlightFrontier&&(e.doc.modeFrontier=Math.max(e.doc.modeFrontier,++e.doc.highlightFrontier))}return t.styles}function $e(e,t,r){var n=e.doc,i=e.display;if(!n.mode.startState)return new us(n,!0,t);var o=rt(e,t,r),l=o>n.first&&M(n,o-1).stateAfter,s=l?us.fromSaved(n,l,o):new us(n,Xe(n.mode),o);return n.iter(o,t,function(r){qe(e,r.text,s);var n=s.line;r.stateAfter=n==t-1||n%5==0||n>=i.viewFrom&&n<i.viewTo?s.save():null,s.nextLine()}),r&&(n.modeFrontier=s.line),s}function qe(e,t,r,n){var i=e.doc.mode,o=new ss(t,e.options.tabSize,r);for(o.start=o.pos=n||0,""==t&&Ze(i,r.state);!o.eol();)Qe(i,o,r.state),o.start=o.pos}function Ze(e,t){if(e.blankLine)return e.blankLine(t);if(e.innerMode){var r=je(e,t);return r.mode.blankLine?r.mode.blankLine(r.state):void 0}}function Qe(e,t,r,n){for(var i=0;i<10;i++){n&&(n[0]=je(e,r).mode);var o=e.token(t,r);if(t.pos>t.start)return o}throw new Error("Mode "+e.name+" failed to advance stream.")}function Je(e,t,r,n){var i,o,l=e.doc,s=l.mode,a=M(l,(t=U(l,t)).line),u=$e(e,t.line,r),c=new ss(a.text,e.options.tabSize,u);for(n&&(o=[]);(n||c.pos<t.ch)&&!c.eol();)c.start=c.pos,i=Qe(s,c,u.state),n&&o.push(new cs(c,i,Ke(l.mode,u.state)));return n?o:new cs(c,i,u.state)}function et(e,t){if(e)for(;;){var r=e.match(/(?:^|\s+)line-(background-)?(\S+)/);if(!r)break;e=e.slice(0,r.index)+e.slice(r.index+r[0].length);var n=r[1]?"bgClass":"textClass";null==t[n]?t[n]=r[2]:new RegExp("(?:^|s)"+r[2]+"(?:$|s)").test(t[n])||(t[n]+=" "+r[2])}return e}function tt(e,t,r,n,i,o,l){var s=r.flattenSpans;null==s&&(s=e.options.flattenSpans);var a,u=0,c=null,f=new ss(t,e.options.tabSize,n),h=e.options.addModeClass&&[null];for(""==t&&et(Ze(r,n.state),o);!f.eol();){if(f.pos>e.options.maxHighlightLength?(s=!1,l&&qe(e,t,n,f.pos),f.pos=t.length,a=null):a=et(Qe(r,f,n.state,h),o),h){var d=h[0].name;d&&(a="m-"+(a?d+" "+a:d))}if(!s||c!=a){for(;u<f.start;)i(u=Math.min(f.start,u+5e3),c);c=a}f.start=f.pos}for(;u<f.pos;){var p=Math.min(f.pos,u+5e3);i(p,c),u=p}}function rt(e,t,r){for(var n,i,o=e.doc,l=r?-1:t-(e.doc.mode.innerMode?1e3:100),s=t;s>l;--s){if(s<=o.first)return o.first;var a=M(o,s-1),u=a.stateAfter;if(u&&(!r||s+(u instanceof as?u.lookAhead:0)<=o.modeFrontier))return s;var c=f(a.text,null,e.options.tabSize);(null==i||n>c)&&(i=s-1,n=c)}return i}function nt(e,t){if(e.modeFrontier=Math.min(e.modeFrontier,t),!(e.highlightFrontier<t-10)){for(var r=e.first,n=t-1;n>r;n--){var i=M(e,n).stateAfter;if(i&&(!(i instanceof as)||n+i.lookAhead<t)){r=n+1;break}}e.highlightFrontier=Math.min(e.highlightFrontier,r)}}function it(e,t,r,n){e.text=t,e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null),null!=e.order&&(e.order=null),re(e),ne(e,r);var i=n?n(e):1;i!=e.height&&A(e,i)}function ot(e){e.parent=null,re(e)}function lt(e,t){if(!e||/^\s*$/.test(e))return null;var r=t.addModeClass?ps:ds;return r[e]||(r[e]=e.replace(/\S+/g,"cm-$&"))}function st(e,t){var r=i("span",null,null,ml?"padding-right: .1px":null),n={pre:i("pre",[r],"CodeMirror-line"),content:r,col:0,pos:0,cm:e,trailingSpace:!1,splitSpaces:(gl||ml)&&e.getOption("lineWrapping")};t.measure={};for(var o=0;o<=(t.rest?t.rest.length:0);o++){var l=o?t.rest[o-1]:t.line,s=void 0;n.pos=0,n.addToken=ut,ze(e.display.measure)&&(s=Se(l,e.doc.direction))&&(n.addToken=ft(n.addToken,s)),n.map=[],dt(l,n,_e(e,l,t!=e.display.externalMeasured&&W(l))),l.styleClasses&&(l.styleClasses.bgClass&&(n.bgClass=a(l.styleClasses.bgClass,n.bgClass||"")),l.styleClasses.textClass&&(n.textClass=a(l.styleClasses.textClass,n.textClass||""))),0==n.map.length&&n.map.push(0,0,n.content.appendChild(Ie(e.display.measure))),0==o?(t.measure.map=n.map,t.measure.cache={}):((t.measure.maps||(t.measure.maps=[])).push(n.map),(t.measure.caches||(t.measure.caches=[])).push({}))}if(ml){var u=n.content.lastChild;(/\bcm-tab\b/.test(u.className)||u.querySelector&&u.querySelector(".cm-tab"))&&(n.content.className="cm-tab-wrap-hack")}return Te(e,"renderLine",e,t.line,n.pre),n.pre.className&&(n.textClass=a(n.pre.className,n.textClass||"")),n}function at(e){var t=n("span","•","cm-invalidchar");return t.title="\\u"+e.charCodeAt(0).toString(16),t.setAttribute("aria-label",t.title),t}function ut(e,t,r,i,o,l,s){if(t){var a,u=e.splitSpaces?ct(t,e.trailingSpace):t,c=e.cm.state.specialChars,f=!1;if(c.test(t)){a=document.createDocumentFragment();for(var h=0;;){c.lastIndex=h;var d=c.exec(t),g=d?d.index-h:t.length-h;if(g){var v=document.createTextNode(u.slice(h,h+g));gl&&vl<9?a.appendChild(n("span",[v])):a.appendChild(v),e.map.push(e.pos,e.pos+g,v),e.col+=g,e.pos+=g}if(!d)break;h+=g+1;var m=void 0;if("\t"==d[0]){var y=e.cm.options.tabSize,b=y-e.col%y;(m=a.appendChild(n("span",p(b),"cm-tab"))).setAttribute("role","presentation"),m.setAttribute("cm-text","\t"),e.col+=b}else"\r"==d[0]||"\n"==d[0]?((m=a.appendChild(n("span","\r"==d[0]?"␍":"␤","cm-invalidchar"))).setAttribute("cm-text",d[0]),e.col+=1):((m=e.cm.options.specialCharPlaceholder(d[0])).setAttribute("cm-text",d[0]),gl&&vl<9?a.appendChild(n("span",[m])):a.appendChild(m),e.col+=1);e.map.push(e.pos,e.pos+1,m),e.pos++}}else e.col+=t.length,a=document.createTextNode(u),e.map.push(e.pos,e.pos+t.length,a),gl&&vl<9&&(f=!0),e.pos+=t.length;if(e.trailingSpace=32==u.charCodeAt(t.length-1),r||i||o||f||s){var w=r||"";i&&(w+=i),o&&(w+=o);var x=n("span",[a],w,s);return l&&(x.title=l),e.content.appendChild(x)}e.content.appendChild(a)}}function ct(e,t){if(e.length>1&&!/  /.test(e))return e;for(var r=t,n="",i=0;i<e.length;i++){var o=e.charAt(i);" "!=o||!r||i!=e.length-1&&32!=e.charCodeAt(i+1)||(o=" "),n+=o,r=" "==o}return n}function ft(e,t){return function(r,n,i,o,l,s,a){i=i?i+" cm-force-border":"cm-force-border";for(var u=r.pos,c=u+n.length;;){for(var f=void 0,h=0;h<t.length&&!((f=t[h]).to>u&&f.from<=u);h++);if(f.to>=c)return e(r,n,i,o,l,s,a);e(r,n.slice(0,f.to-u),i,o,null,s,a),o=null,n=n.slice(f.to-u),u=f.to}}}function ht(e,t,r,n){var i=!n&&r.widgetNode;i&&e.map.push(e.pos,e.pos+t,i),!n&&e.cm.display.input.needsContentAttribute&&(i||(i=e.content.appendChild(document.createElement("span"))),i.setAttribute("cm-marker",r.id)),i&&(e.cm.display.input.setUneditable(i),e.content.appendChild(i)),e.pos+=t,e.trailingSpace=!1}function dt(e,t,r){var n=e.markedSpans,i=e.text,o=0;if(n)for(var l,s,a,u,c,f,h,d=i.length,p=0,g=1,v="",m=0;;){if(m==p){a=u=c=f=s="",h=null,m=1/0;for(var y=[],b=void 0,w=0;w<n.length;++w){var x=n[w],C=x.marker;"bookmark"==C.type&&x.from==p&&C.widgetNode?y.push(C):x.from<=p&&(null==x.to||x.to>p||C.collapsed&&x.to==p&&x.from==p)?(null!=x.to&&x.to!=p&&m>x.to&&(m=x.to,u=""),C.className&&(a+=" "+C.className),C.css&&(s=(s?s+";":"")+C.css),C.startStyle&&x.from==p&&(c+=" "+C.startStyle),C.endStyle&&x.to==m&&(b||(b=[])).push(C.endStyle,x.to),C.title&&!f&&(f=C.title),C.collapsed&&(!h||le(h.marker,C)<0)&&(h=x)):x.from>p&&m>x.from&&(m=x.from)}if(b)for(var S=0;S<b.length;S+=2)b[S+1]==m&&(u+=" "+b[S]);if(!h||h.from==p)for(var L=0;L<y.length;++L)ht(t,0,y[L]);if(h&&(h.from||0)==p){if(ht(t,(null==h.to?d+1:h.to)-p,h.marker,null==h.from),null==h.to)return;h.to==p&&(h=!1)}}if(p>=d)break;for(var k=Math.min(d,m);;){if(v){var T=p+v.length;if(!h){var M=T>k?v.slice(0,k-p):v;t.addToken(t,M,l?l+a:a,c,p+M.length==m?u:"",f,s)}if(T>=k){v=v.slice(k-p),p=k;break}p=T,c=""}v=i.slice(o,o=r[g++]),l=lt(r[g++],t.cm.options)}}else for(var N=1;N<r.length;N+=2)t.addToken(t,i.slice(o,o=r[N]),lt(r[N+1],t.cm.options))}function pt(e,t,r){this.line=t,this.rest=de(t),this.size=this.rest?W(g(this.rest))-r+1:1,this.node=this.text=null,this.hidden=ve(e,t)}function gt(e,t,r){for(var n,i=[],o=t;o<r;o=n){var l=new pt(e.doc,M(e.doc,o),o);n=o+l.size,i.push(l)}return i}function vt(e){gs?gs.ops.push(e):e.ownsGroup=gs={ops:[e],delayedCallbacks:[]}}function mt(e){var t=e.delayedCallbacks,r=0;do{for(;r<t.length;r++)t[r].call(null);for(var n=0;n<e.ops.length;n++){var i=e.ops[n];if(i.cursorActivityHandlers)for(;i.cursorActivityCalled<i.cursorActivityHandlers.length;)i.cursorActivityHandlers[i.cursorActivityCalled++].call(null,i.cm)}}while(r<t.length)}function yt(e,t){var r=e.ownsGroup;if(r)try{mt(r)}finally{gs=null,t(r)}}function bt(e,t){var r=Le(e,t);if(r.length){var n,i=Array.prototype.slice.call(arguments,2);gs?n=gs.delayedCallbacks:vs?n=vs:(n=vs=[],setTimeout(wt,0));for(var o=0;o<r.length;++o)!function(e){n.push(function(){return r[e].apply(null,i)})}(o)}}function wt(){var e=vs;vs=null;for(var t=0;t<e.length;++t)e[t]()}function xt(e,t,r,n){for(var i=0;i<t.changes.length;i++){var o=t.changes[i];"text"==o?kt(e,t):"gutter"==o?Mt(e,t,r,n):"class"==o?Tt(e,t):"widget"==o&&Nt(e,t,n)}t.changes=null}function Ct(e){return e.node==e.text&&(e.node=n("div",null,null,"position: relative"),e.text.parentNode&&e.text.parentNode.replaceChild(e.node,e.text),e.node.appendChild(e.text),gl&&vl<8&&(e.node.style.zIndex=2)),e.node}function St(e,t){var r=t.bgClass?t.bgClass+" "+(t.line.bgClass||""):t.line.bgClass;if(r&&(r+=" CodeMirror-linebackground"),t.background)r?t.background.className=r:(t.background.parentNode.removeChild(t.background),t.background=null);else if(r){var i=Ct(t);t.background=i.insertBefore(n("div",null,r),i.firstChild),e.display.input.setUneditable(t.background)}}function Lt(e,t){var r=e.display.externalMeasured;return r&&r.line==t.line?(e.display.externalMeasured=null,t.measure=r.measure,r.built):st(e,t)}function kt(e,t){var r=t.text.className,n=Lt(e,t);t.text==t.node&&(t.node=n.pre),t.text.parentNode.replaceChild(n.pre,t.text),t.text=n.pre,n.bgClass!=t.bgClass||n.textClass!=t.textClass?(t.bgClass=n.bgClass,t.textClass=n.textClass,Tt(e,t)):r&&(t.text.className=r)}function Tt(e,t){St(e,t),t.line.wrapClass?Ct(t).className=t.line.wrapClass:t.node!=t.text&&(t.node.className="");var r=t.textClass?t.textClass+" "+(t.line.textClass||""):t.line.textClass;t.text.className=r||""}function Mt(e,t,r,i){if(t.gutter&&(t.node.removeChild(t.gutter),t.gutter=null),t.gutterBackground&&(t.node.removeChild(t.gutterBackground),t.gutterBackground=null),t.line.gutterClass){var o=Ct(t);t.gutterBackground=n("div",null,"CodeMirror-gutter-background "+t.line.gutterClass,"left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px; width: "+i.gutterTotalWidth+"px"),e.display.input.setUneditable(t.gutterBackground),o.insertBefore(t.gutterBackground,t.text)}var l=t.line.gutterMarkers;if(e.options.lineNumbers||l){var s=Ct(t),a=t.gutter=n("div",null,"CodeMirror-gutter-wrapper","left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px");if(e.display.input.setUneditable(a),s.insertBefore(a,t.text),t.line.gutterClass&&(a.className+=" "+t.line.gutterClass),!e.options.lineNumbers||l&&l["CodeMirror-linenumbers"]||(t.lineNumber=a.appendChild(n("div",F(e.options,r),"CodeMirror-linenumber CodeMirror-gutter-elt","left: "+i.gutterLeft["CodeMirror-linenumbers"]+"px; width: "+e.display.lineNumInnerWidth+"px"))),l)for(var u=0;u<e.options.gutters.length;++u){var c=e.options.gutters[u],f=l.hasOwnProperty(c)&&l[c];f&&a.appendChild(n("div",[f],"CodeMirror-gutter-elt","left: "+i.gutterLeft[c]+"px; width: "+i.gutterWidth[c]+"px"))}}}function Nt(e,t,r){t.alignable&&(t.alignable=null);for(var n=t.node.firstChild,i=void 0;n;n=i)i=n.nextSibling,"CodeMirror-linewidget"==n.className&&t.node.removeChild(n);At(e,t,r)}function Ot(e,t,r,n){var i=Lt(e,t);return t.text=t.node=i.pre,i.bgClass&&(t.bgClass=i.bgClass),i.textClass&&(t.textClass=i.textClass),Tt(e,t),Mt(e,t,r,n),At(e,t,n),t.node}function At(e,t,r){if(Wt(e,t.line,t,r,!0),t.rest)for(var n=0;n<t.rest.length;n++)Wt(e,t.rest[n],t,r,!1)}function Wt(e,t,r,i,o){if(t.widgets)for(var l=Ct(r),s=0,a=t.widgets;s<a.length;++s){var u=a[s],c=n("div",[u.node],"CodeMirror-linewidget");u.handleMouseEvents||c.setAttribute("cm-ignore-events","true"),Dt(u,c,r,i),e.display.input.setUneditable(c),o&&u.above?l.insertBefore(c,r.gutter||r.text):l.appendChild(c),bt(u,"redraw")}}function Dt(e,t,r,n){if(e.noHScroll){(r.alignable||(r.alignable=[])).push(t);var i=n.wrapperWidth;t.style.left=n.fixedPos+"px",e.coverGutter||(i-=n.gutterTotalWidth,t.style.paddingLeft=n.gutterTotalWidth+"px"),t.style.width=i+"px"}e.coverGutter&&(t.style.zIndex=5,t.style.position="relative",e.noHScroll||(t.style.marginLeft=-n.gutterTotalWidth+"px"))}function Ht(e){if(null!=e.height)return e.height;var t=e.doc.cm;if(!t)return 0;if(!o(document.body,e.node)){var i="position: relative;";e.coverGutter&&(i+="margin-left: -"+t.display.gutters.offsetWidth+"px;"),e.noHScroll&&(i+="width: "+t.display.wrapper.clientWidth+"px;"),r(t.display.measure,n("div",[e.node],null,i))}return e.height=e.node.parentNode.offsetHeight}function Ft(e,t){for(var r=Ee(t);r!=e.wrapper;r=r.parentNode)if(!r||1==r.nodeType&&"true"==r.getAttribute("cm-ignore-events")||r.parentNode==e.sizer&&r!=e.mover)return!0}function Et(e){return e.lineSpace.offsetTop}function Pt(e){return e.mover.offsetHeight-e.lineSpace.offsetHeight}function It(e){if(e.cachedPaddingH)return e.cachedPaddingH;var t=r(e.measure,n("pre","x")),i=window.getComputedStyle?window.getComputedStyle(t):t.currentStyle,o={left:parseInt(i.paddingLeft),right:parseInt(i.paddingRight)};return isNaN(o.left)||isNaN(o.right)||(e.cachedPaddingH=o),o}function zt(e){return Rl-e.display.nativeBarWidth}function Rt(e){return e.display.scroller.clientWidth-zt(e)-e.display.barWidth}function Bt(e){return e.display.scroller.clientHeight-zt(e)-e.display.barHeight}function Gt(e,t,r){var n=e.options.lineWrapping,i=n&&Rt(e);if(!t.measure.heights||n&&t.measure.width!=i){var o=t.measure.heights=[];if(n){t.measure.width=i;for(var l=t.text.firstChild.getClientRects(),s=0;s<l.length-1;s++){var a=l[s],u=l[s+1];Math.abs(a.bottom-u.bottom)>2&&o.push((a.bottom+u.top)/2-r.top)}}o.push(r.bottom-r.top)}}function Ut(e,t,r){if(e.line==t)return{map:e.measure.map,cache:e.measure.cache};for(var n=0;n<e.rest.length;n++)if(e.rest[n]==t)return{map:e.measure.maps[n],cache:e.measure.caches[n]};for(var i=0;i<e.rest.length;i++)if(W(e.rest[i])>r)return{map:e.measure.maps[i],cache:e.measure.caches[i],before:!0}}function Vt(e,t){var n=W(t=fe(t)),i=e.display.externalMeasured=new pt(e.doc,t,n);i.lineN=n;var o=i.built=st(e,i);return i.text=o.pre,r(e.display.lineMeasure,o.pre),i}function Kt(e,t,r,n){return Yt(e,Xt(e,t),r,n)}function jt(e,t){if(t>=e.display.viewFrom&&t<e.display.viewTo)return e.display.view[Lr(e,t)];var r=e.display.externalMeasured;return r&&t>=r.lineN&&t<r.lineN+r.size?r:void 0}function Xt(e,t){var r=W(t),n=jt(e,r);n&&!n.text?n=null:n&&n.changes&&(xt(e,n,r,br(e)),e.curOp.forceUpdate=!0),n||(n=Vt(e,t));var i=Ut(n,t,r);return{line:t,view:n,rect:null,map:i.map,cache:i.cache,before:i.before,hasHeights:!1}}function Yt(e,t,r,n,i){t.before&&(r=-1);var o,l=r+(n||"");return t.cache.hasOwnProperty(l)?o=t.cache[l]:(t.rect||(t.rect=t.view.text.getBoundingClientRect()),t.hasHeights||(Gt(e,t.view,t.rect),t.hasHeights=!0),(o=qt(e,t,r,n)).bogus||(t.cache[l]=o)),{left:o.left,right:o.right,top:i?o.rtop:o.top,bottom:i?o.rbottom:o.bottom}}function _t(e,t,r){for(var n,i,o,l,s,a,u=0;u<e.length;u+=3)if(s=e[u],a=e[u+1],t<s?(i=0,o=1,l="left"):t<a?o=(i=t-s)+1:(u==e.length-3||t==a&&e[u+3]>t)&&(i=(o=a-s)-1,t>=a&&(l="right")),null!=i){if(n=e[u+2],s==a&&r==(n.insertLeft?"left":"right")&&(l=r),"left"==r&&0==i)for(;u&&e[u-2]==e[u-3]&&e[u-1].insertLeft;)n=e[2+(u-=3)],l="left";if("right"==r&&i==a-s)for(;u<e.length-3&&e[u+3]==e[u+4]&&!e[u+5].insertLeft;)n=e[(u+=3)+2],l="right";break}return{node:n,start:i,end:o,collapse:l,coverStart:s,coverEnd:a}}function $t(e,t){var r=ms;if("left"==t)for(var n=0;n<e.length&&(r=e[n]).left==r.right;n++);else for(var i=e.length-1;i>=0&&(r=e[i]).left==r.right;i--);return r}function qt(e,t,r,n){var i,o=_t(t.map,r,n),l=o.node,s=o.start,a=o.end,u=o.collapse;if(3==l.nodeType){for(var c=0;c<4;c++){for(;s&&S(t.line.text.charAt(o.coverStart+s));)--s;for(;o.coverStart+a<o.coverEnd&&S(t.line.text.charAt(o.coverStart+a));)++a;if((i=gl&&vl<9&&0==s&&a==o.coverEnd-o.coverStart?l.parentNode.getBoundingClientRect():$t(Wl(l,s,a).getClientRects(),n)).left||i.right||0==s)break;a=s,s-=1,u="right"}gl&&vl<11&&(i=Zt(e.display.measure,i))}else{s>0&&(u=n="right");var f;i=e.options.lineWrapping&&(f=l.getClientRects()).length>1?f["right"==n?f.length-1:0]:l.getBoundingClientRect()}if(gl&&vl<9&&!s&&(!i||!i.left&&!i.right)){var h=l.parentNode.getClientRects()[0];i=h?{left:h.left,right:h.left+yr(e.display),top:h.top,bottom:h.bottom}:ms}for(var d=i.top-t.rect.top,p=i.bottom-t.rect.top,g=(d+p)/2,v=t.view.measure.heights,m=0;m<v.length-1&&!(g<v[m]);m++);var y=m?v[m-1]:0,b=v[m],w={left:("right"==u?i.right:i.left)-t.rect.left,right:("left"==u?i.left:i.right)-t.rect.left,top:y,bottom:b};return i.left||i.right||(w.bogus=!0),e.options.singleCursorHeightPerLine||(w.rtop=d,w.rbottom=p),w}function Zt(e,t){if(!window.screen||null==screen.logicalXDPI||screen.logicalXDPI==screen.deviceXDPI||!Re(e))return t;var r=screen.logicalXDPI/screen.deviceXDPI,n=screen.logicalYDPI/screen.deviceYDPI;return{left:t.left*r,right:t.right*r,top:t.top*n,bottom:t.bottom*n}}function Qt(e){if(e.measure&&(e.measure.cache={},e.measure.heights=null,e.rest))for(var t=0;t<e.rest.length;t++)e.measure.caches[t]={}}function Jt(e){e.display.externalMeasure=null,t(e.display.lineMeasure);for(var r=0;r<e.display.view.length;r++)Qt(e.display.view[r])}function er(e){Jt(e),e.display.cachedCharWidth=e.display.cachedTextHeight=e.display.cachedPaddingH=null,e.options.lineWrapping||(e.display.maxLineChanged=!0),e.display.lineNumChars=null}function tr(){return bl&&kl?-(document.body.getBoundingClientRect().left-parseInt(getComputedStyle(document.body).marginLeft)):window.pageXOffset||(document.documentElement||document.body).scrollLeft}function rr(){return bl&&kl?-(document.body.getBoundingClientRect().top-parseInt(getComputedStyle(document.body).marginTop)):window.pageYOffset||(document.documentElement||document.body).scrollTop}function nr(e){var t=0;if(e.widgets)for(var r=0;r<e.widgets.length;++r)e.widgets[r].above&&(t+=Ht(e.widgets[r]));return t}function ir(e,t,r,n,i){if(!i){var o=nr(t);r.top+=o,r.bottom+=o}if("line"==n)return r;n||(n="local");var l=ye(t);if("local"==n?l+=Et(e.display):l-=e.display.viewOffset,"page"==n||"window"==n){var s=e.display.lineSpace.getBoundingClientRect();l+=s.top+("window"==n?0:rr());var a=s.left+("window"==n?0:tr());r.left+=a,r.right+=a}return r.top+=l,r.bottom+=l,r}function or(e,t,r){if("div"==r)return t;var n=t.left,i=t.top;if("page"==r)n-=tr(),i-=rr();else if("local"==r||!r){var o=e.display.sizer.getBoundingClientRect();n+=o.left,i+=o.top}var l=e.display.lineSpace.getBoundingClientRect();return{left:n-l.left,top:i-l.top}}function lr(e,t,r,n,i){return n||(n=M(e.doc,t.line)),ir(e,n,Kt(e,n,t.ch,i),r)}function sr(e,t,r,n,i,o){function l(t,l){var s=Yt(e,i,t,l?"right":"left",o);return l?s.left=s.right:s.right=s.left,ir(e,n,s,r)}function s(e,t,r){var n=1==a[t].level;return l(r?e-1:e,n!=r)}n=n||M(e.doc,t.line),i||(i=Xt(e,n));var a=Se(n,e.doc.direction),u=t.ch,c=t.sticky;if(u>=n.text.length?(u=n.text.length,c="before"):u<=0&&(u=0,c="after"),!a)return l("before"==c?u-1:u,"before"==c);var f=Ce(a,u,c),h=$l,d=s(u,f,"before"==c);return null!=h&&(d.other=s(u,h,"before"!=c)),d}function ar(e,t){var r=0;t=U(e.doc,t),e.options.lineWrapping||(r=yr(e.display)*t.ch);var n=M(e.doc,t.line),i=ye(n)+Et(e.display);return{left:r,right:r,top:i,bottom:i+n.height}}function ur(e,t,r,n,i){var o=E(e,t,r);return o.xRel=i,n&&(o.outside=!0),o}function cr(e,t,r){var n=e.doc;if((r+=e.display.viewOffset)<0)return ur(n.first,0,null,!0,-1);var i=D(n,r),o=n.first+n.size-1;if(i>o)return ur(n.first+n.size-1,M(n,o).text.length,null,!0,1);t<0&&(t=0);for(var l=M(n,i);;){var s=pr(e,l,i,t,r),a=ue(l),u=a&&a.find(0,!0);if(!a||!(s.ch>u.from.ch||s.ch==u.from.ch&&s.xRel>0))return s;i=W(l=u.to.line)}}function fr(e,t,r,n){n-=nr(t);var i=t.text.length,o=k(function(t){return Yt(e,r,t-1).bottom<=n},i,0);return i=k(function(t){return Yt(e,r,t).top>n},o,i),{begin:o,end:i}}function hr(e,t,r,n){return r||(r=Xt(e,t)),fr(e,t,r,ir(e,t,Yt(e,r,n),"line").top)}function dr(e,t,r,n){return!(e.bottom<=r)&&(e.top>r||(n?e.left:e.right)>t)}function pr(e,t,r,n,i){i-=ye(t);var o=Xt(e,t),l=nr(t),s=0,a=t.text.length,u=!0,c=Se(t,e.doc.direction);if(c){var f=(e.options.lineWrapping?vr:gr)(e,t,r,o,c,n,i);s=(u=1!=f.level)?f.from:f.to-1,a=u?f.to:f.from-1}var h,d,p=null,g=null,v=k(function(t){var r=Yt(e,o,t);return r.top+=l,r.bottom+=l,!!dr(r,n,i,!1)&&(r.top<=i&&r.left<=n&&(p=t,g=r),!0)},s,a),m=!1;if(g){var y=n-g.left<g.right-n,b=y==u;v=p+(b?0:1),d=b?"after":"before",h=y?g.left:g.right}else{u||v!=a&&v!=s||v++,d=0==v?"after":v==t.text.length?"before":Yt(e,o,v-(u?1:0)).bottom+l<=i==u?"after":"before";var w=sr(e,E(r,v,d),"line",t,o);h=w.left,m=i<w.top||i>=w.bottom}return v=L(t.text,v,1),ur(r,v,d,m,n-h)}function gr(e,t,r,n,i,o,l){var s=k(function(s){var a=i[s],u=1!=a.level;return dr(sr(e,E(r,u?a.to:a.from,u?"before":"after"),"line",t,n),o,l,!0)},0,i.length-1),a=i[s];if(s>0){var u=1!=a.level,c=sr(e,E(r,u?a.from:a.to,u?"after":"before"),"line",t,n);dr(c,o,l,!0)&&c.top>l&&(a=i[s-1])}return a}function vr(e,t,r,n,i,o,l){for(var s=fr(e,t,n,l),a=s.begin,u=s.end,c=null,f=null,h=0;h<i.length;h++){var d=i[h];if(!(d.from>=u||d.to<=a)){var p=Yt(e,n,1!=d.level?Math.min(u,d.to)-1:Math.max(a,d.from)).right,g=p<o?o-p+1e9:p-o;(!c||f>g)&&(c=d,f=g)}}return c||(c=i[i.length-1]),c.from<a&&(c={from:a,to:c.to,level:c.level}),c.to>u&&(c={from:c.from,to:u,level:c.level}),c}function mr(e){if(null!=e.cachedTextHeight)return e.cachedTextHeight;if(null==hs){hs=n("pre");for(var i=0;i<49;++i)hs.appendChild(document.createTextNode("x")),hs.appendChild(n("br"));hs.appendChild(document.createTextNode("x"))}r(e.measure,hs);var o=hs.offsetHeight/50;return o>3&&(e.cachedTextHeight=o),t(e.measure),o||1}function yr(e){if(null!=e.cachedCharWidth)return e.cachedCharWidth;var t=n("span","xxxxxxxxxx"),i=n("pre",[t]);r(e.measure,i);var o=t.getBoundingClientRect(),l=(o.right-o.left)/10;return l>2&&(e.cachedCharWidth=l),l||10}function br(e){for(var t=e.display,r={},n={},i=t.gutters.clientLeft,o=t.gutters.firstChild,l=0;o;o=o.nextSibling,++l)r[e.options.gutters[l]]=o.offsetLeft+o.clientLeft+i,n[e.options.gutters[l]]=o.clientWidth;return{fixedPos:wr(t),gutterTotalWidth:t.gutters.offsetWidth,gutterLeft:r,gutterWidth:n,wrapperWidth:t.wrapper.clientWidth}}function wr(e){return e.scroller.getBoundingClientRect().left-e.sizer.getBoundingClientRect().left}function xr(e){var t=mr(e.display),r=e.options.lineWrapping,n=r&&Math.max(5,e.display.scroller.clientWidth/yr(e.display)-3);return function(i){if(ve(e.doc,i))return 0;var o=0;if(i.widgets)for(var l=0;l<i.widgets.length;l++)i.widgets[l].height&&(o+=i.widgets[l].height);return r?o+(Math.ceil(i.text.length/n)||1)*t:o+t}}function Cr(e){var t=e.doc,r=xr(e);t.iter(function(e){var t=r(e);t!=e.height&&A(e,t)})}function Sr(e,t,r,n){var i=e.display;if(!r&&"true"==Ee(t).getAttribute("cm-not-content"))return null;var o,l,s=i.lineSpace.getBoundingClientRect();try{o=t.clientX-s.left,l=t.clientY-s.top}catch(t){return null}var a,u=cr(e,o,l);if(n&&1==u.xRel&&(a=M(e.doc,u.line).text).length==u.ch){var c=f(a,a.length,e.options.tabSize)-a.length;u=E(u.line,Math.max(0,Math.round((o-It(e.display).left)/yr(e.display))-c))}return u}function Lr(e,t){if(t>=e.display.viewTo)return null;if((t-=e.display.viewFrom)<0)return null;for(var r=e.display.view,n=0;n<r.length;n++)if((t-=r[n].size)<0)return n}function kr(e){e.display.input.showSelection(e.display.input.prepareSelection())}function Tr(e,t){void 0===t&&(t=!0);for(var r=e.doc,n={},i=n.cursors=document.createDocumentFragment(),o=n.selection=document.createDocumentFragment(),l=0;l<r.sel.ranges.length;l++)if(t||l!=r.sel.primIndex){var s=r.sel.ranges[l];if(!(s.from().line>=e.display.viewTo||s.to().line<e.display.viewFrom)){var a=s.empty();(a||e.options.showCursorWhenSelecting)&&Mr(e,s.head,i),a||Or(e,s,o)}}return n}function Mr(e,t,r){var i=sr(e,t,"div",null,null,!e.options.singleCursorHeightPerLine),o=r.appendChild(n("div"," ","CodeMirror-cursor"));if(o.style.left=i.left+"px",o.style.top=i.top+"px",o.style.height=Math.max(0,i.bottom-i.top)*e.options.cursorHeight+"px",i.other){var l=r.appendChild(n("div"," ","CodeMirror-cursor CodeMirror-secondarycursor"));l.style.display="",l.style.left=i.other.left+"px",l.style.top=i.other.top+"px",l.style.height=.85*(i.other.bottom-i.other.top)+"px"}}function Nr(e,t){return e.top-t.top||e.left-t.left}function Or(e,t,r){function i(e,t,r,i){t<0&&(t=0),t=Math.round(t),i=Math.round(i),a.appendChild(n("div",null,"CodeMirror-selected","position: absolute; left: "+e+"px;\n                             top: "+t+"px; width: "+(null==r?f-e:r)+"px;\n                             height: "+(i-t)+"px"))}function o(t,r,n){function o(r,n){return lr(e,E(t,r),"div",u,n)}var l,a,u=M(s,t),h=u.text.length,d=Se(u,s.direction);return xe(d,r||0,null==n?h:n,function(t,s,p,g){var v=o(t,"ltr"==p?"left":"right"),m=o(s-1,"ltr"==p?"right":"left");if("ltr"==p){var y=null==r&&0==t?c:v.left,b=null==n&&s==h?f:m.right;m.top-v.top<=3?i(y,m.top,b-y,m.bottom):(i(y,v.top,null,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top),i(c,m.top,m.right,m.bottom))}else if(t<s){var w=null==r&&0==t?f:v.right,x=null==n&&s==h?c:m.left;if(m.top-v.top<=3)i(x,m.top,w-x,m.bottom);else{var C=c;if(g){var S=hr(e,u,null,t).end;C=o(S-(/\s/.test(u.text.charAt(S-1))?2:1),"left").left}i(C,v.top,w-C,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top);var L=null;d.length,L=o(hr(e,u,null,s).begin,"right").right-x,i(x,m.top,L,m.bottom)}}(!l||Nr(v,l)<0)&&(l=v),Nr(m,l)<0&&(l=m),(!a||Nr(v,a)<0)&&(a=v),Nr(m,a)<0&&(a=m)}),{start:l,end:a}}var l=e.display,s=e.doc,a=document.createDocumentFragment(),u=It(e.display),c=u.left,f=Math.max(l.sizerWidth,Rt(e)-l.sizer.offsetLeft)-u.right,h=t.from(),d=t.to();if(h.line==d.line)o(h.line,h.ch,d.ch);else{var p=M(s,h.line),g=M(s,d.line),v=fe(p)==fe(g),m=o(h.line,h.ch,v?p.text.length+1:null).end,y=o(d.line,v?0:null,d.ch).start;v&&(m.top<y.top-2?(i(m.right,m.top,null,m.bottom),i(c,y.top,y.left,y.bottom)):i(m.right,m.top,y.left-m.right,m.bottom)),m.bottom<y.top&&i(c,m.bottom,null,y.top)}r.appendChild(a)}function Ar(e){if(e.state.focused){var t=e.display;clearInterval(t.blinker);var r=!0;t.cursorDiv.style.visibility="",e.options.cursorBlinkRate>0?t.blinker=setInterval(function(){return t.cursorDiv.style.visibility=(r=!r)?"":"hidden"},e.options.cursorBlinkRate):e.options.cursorBlinkRate<0&&(t.cursorDiv.style.visibility="hidden")}}function Wr(e){e.state.focused||(e.display.input.focus(),Hr(e))}function Dr(e){e.state.delayingBlurEvent=!0,setTimeout(function(){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1,Fr(e))},100)}function Hr(e,t){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1),"nocursor"!=e.options.readOnly&&(e.state.focused||(Te(e,"focus",e,t),e.state.focused=!0,s(e.display.wrapper,"CodeMirror-focused"),e.curOp||e.display.selForContextMenu==e.doc.sel||(e.display.input.reset(),ml&&setTimeout(function(){return e.display.input.reset(!0)},20)),e.display.input.receivedFocus()),Ar(e))}function Fr(e,t){e.state.delayingBlurEvent||(e.state.focused&&(Te(e,"blur",e,t),e.state.focused=!1,Fl(e.display.wrapper,"CodeMirror-focused")),clearInterval(e.display.blinker),setTimeout(function(){e.state.focused||(e.display.shift=!1)},150))}function Er(e){for(var t=e.display,r=t.lineDiv.offsetTop,n=0;n<t.view.length;n++){var i=t.view[n],o=void 0;if(!i.hidden){if(gl&&vl<8){var l=i.node.offsetTop+i.node.offsetHeight;o=l-r,r=l}else{var s=i.node.getBoundingClientRect();o=s.bottom-s.top}var a=i.line.height-o;if(o<2&&(o=mr(t)),(a>.005||a<-.005)&&(A(i.line,o),Pr(i.line),i.rest))for(var u=0;u<i.rest.length;u++)Pr(i.rest[u])}}}function Pr(e){if(e.widgets)for(var t=0;t<e.widgets.length;++t)e.widgets[t].height=e.widgets[t].node.parentNode.offsetHeight}function Ir(e,t,r){var n=r&&null!=r.top?Math.max(0,r.top):e.scroller.scrollTop;n=Math.floor(n-Et(e));var i=r&&null!=r.bottom?r.bottom:n+e.wrapper.clientHeight,o=D(t,n),l=D(t,i);if(r&&r.ensure){var s=r.ensure.from.line,a=r.ensure.to.line;s<o?(o=s,l=D(t,ye(M(t,s))+e.wrapper.clientHeight)):Math.min(a,t.lastLine())>=l&&(o=D(t,ye(M(t,a))-e.wrapper.clientHeight),l=a)}return{from:o,to:Math.max(l,o+1)}}function zr(e){var t=e.display,r=t.view;if(t.alignWidgets||t.gutters.firstChild&&e.options.fixedGutter){for(var n=wr(t)-t.scroller.scrollLeft+e.doc.scrollLeft,i=t.gutters.offsetWidth,o=n+"px",l=0;l<r.length;l++)if(!r[l].hidden){e.options.fixedGutter&&(r[l].gutter&&(r[l].gutter.style.left=o),r[l].gutterBackground&&(r[l].gutterBackground.style.left=o));var s=r[l].alignable;if(s)for(var a=0;a<s.length;a++)s[a].style.left=o}e.options.fixedGutter&&(t.gutters.style.left=n+i+"px")}}function Rr(e){if(!e.options.lineNumbers)return!1;var t=e.doc,r=F(e.options,t.first+t.size-1),i=e.display;if(r.length!=i.lineNumChars){var o=i.measure.appendChild(n("div",[n("div",r)],"CodeMirror-linenumber CodeMirror-gutter-elt")),l=o.firstChild.offsetWidth,s=o.offsetWidth-l;return i.lineGutter.style.width="",i.lineNumInnerWidth=Math.max(l,i.lineGutter.offsetWidth-s)+1,i.lineNumWidth=i.lineNumInnerWidth+s,i.lineNumChars=i.lineNumInnerWidth?r.length:-1,i.lineGutter.style.width=i.lineNumWidth+"px",Wn(e),!0}return!1}function Br(e,t){if(!Me(e,"scrollCursorIntoView")){var r=e.display,i=r.sizer.getBoundingClientRect(),o=null;if(t.top+i.top<0?o=!0:t.bottom+i.top>(window.innerHeight||document.documentElement.clientHeight)&&(o=!1),null!=o&&!Sl){var l=n("div","​",null,"position: absolute;\n                         top: "+(t.top-r.viewOffset-Et(e.display))+"px;\n                         height: "+(t.bottom-t.top+zt(e)+r.barHeight)+"px;\n                         left: "+t.left+"px; width: "+Math.max(2,t.right-t.left)+"px;");e.display.lineSpace.appendChild(l),l.scrollIntoView(o),e.display.lineSpace.removeChild(l)}}}function Gr(e,t,r,n){null==n&&(n=0);var i;e.options.lineWrapping||t!=r||(r="before"==(t=t.ch?E(t.line,"before"==t.sticky?t.ch-1:t.ch,"after"):t).sticky?E(t.line,t.ch+1,"before"):t);for(var o=0;o<5;o++){var l=!1,s=sr(e,t),a=r&&r!=t?sr(e,r):s,u=Vr(e,i={left:Math.min(s.left,a.left),top:Math.min(s.top,a.top)-n,right:Math.max(s.left,a.left),bottom:Math.max(s.bottom,a.bottom)+n}),c=e.doc.scrollTop,f=e.doc.scrollLeft;if(null!=u.scrollTop&&(qr(e,u.scrollTop),Math.abs(e.doc.scrollTop-c)>1&&(l=!0)),null!=u.scrollLeft&&(Qr(e,u.scrollLeft),Math.abs(e.doc.scrollLeft-f)>1&&(l=!0)),!l)break}return i}function Ur(e,t){var r=Vr(e,t);null!=r.scrollTop&&qr(e,r.scrollTop),null!=r.scrollLeft&&Qr(e,r.scrollLeft)}function Vr(e,t){var r=e.display,n=mr(e.display);t.top<0&&(t.top=0);var i=e.curOp&&null!=e.curOp.scrollTop?e.curOp.scrollTop:r.scroller.scrollTop,o=Bt(e),l={};t.bottom-t.top>o&&(t.bottom=t.top+o);var s=e.doc.height+Pt(r),a=t.top<n,u=t.bottom>s-n;if(t.top<i)l.scrollTop=a?0:t.top;else if(t.bottom>i+o){var c=Math.min(t.top,(u?s:t.bottom)-o);c!=i&&(l.scrollTop=c)}var f=e.curOp&&null!=e.curOp.scrollLeft?e.curOp.scrollLeft:r.scroller.scrollLeft,h=Rt(e)-(e.options.fixedGutter?r.gutters.offsetWidth:0),d=t.right-t.left>h;return d&&(t.right=t.left+h),t.left<10?l.scrollLeft=0:t.left<f?l.scrollLeft=Math.max(0,t.left-(d?0:10)):t.right>h+f-3&&(l.scrollLeft=t.right+(d?0:10)-h),l}function Kr(e,t){null!=t&&(_r(e),e.curOp.scrollTop=(null==e.curOp.scrollTop?e.doc.scrollTop:e.curOp.scrollTop)+t)}function jr(e){_r(e);var t=e.getCursor();e.curOp.scrollToPos={from:t,to:t,margin:e.options.cursorScrollMargin}}function Xr(e,t,r){null==t&&null==r||_r(e),null!=t&&(e.curOp.scrollLeft=t),null!=r&&(e.curOp.scrollTop=r)}function Yr(e,t){_r(e),e.curOp.scrollToPos=t}function _r(e){var t=e.curOp.scrollToPos;t&&(e.curOp.scrollToPos=null,$r(e,ar(e,t.from),ar(e,t.to),t.margin))}function $r(e,t,r,n){var i=Vr(e,{left:Math.min(t.left,r.left),top:Math.min(t.top,r.top)-n,right:Math.max(t.right,r.right),bottom:Math.max(t.bottom,r.bottom)+n});Xr(e,i.scrollLeft,i.scrollTop)}function qr(e,t){Math.abs(e.doc.scrollTop-t)<2||(fl||On(e,{top:t}),Zr(e,t,!0),fl&&On(e),Cn(e,100))}function Zr(e,t,r){t=Math.min(e.display.scroller.scrollHeight-e.display.scroller.clientHeight,t),(e.display.scroller.scrollTop!=t||r)&&(e.doc.scrollTop=t,e.display.scrollbars.setScrollTop(t),e.display.scroller.scrollTop!=t&&(e.display.scroller.scrollTop=t))}function Qr(e,t,r,n){t=Math.min(t,e.display.scroller.scrollWidth-e.display.scroller.clientWidth),(r?t==e.doc.scrollLeft:Math.abs(e.doc.scrollLeft-t)<2)&&!n||(e.doc.scrollLeft=t,zr(e),e.display.scroller.scrollLeft!=t&&(e.display.scroller.scrollLeft=t),e.display.scrollbars.setScrollLeft(t))}function Jr(e){var t=e.display,r=t.gutters.offsetWidth,n=Math.round(e.doc.height+Pt(e.display));return{clientHeight:t.scroller.clientHeight,viewHeight:t.wrapper.clientHeight,scrollWidth:t.scroller.scrollWidth,clientWidth:t.scroller.clientWidth,viewWidth:t.wrapper.clientWidth,barLeft:e.options.fixedGutter?r:0,docHeight:n,scrollHeight:n+zt(e)+t.barHeight,nativeBarWidth:t.nativeBarWidth,gutterWidth:r}}function en(e,t){t||(t=Jr(e));var r=e.display.barWidth,n=e.display.barHeight;tn(e,t);for(var i=0;i<4&&r!=e.display.barWidth||n!=e.display.barHeight;i++)r!=e.display.barWidth&&e.options.lineWrapping&&Er(e),tn(e,Jr(e)),r=e.display.barWidth,n=e.display.barHeight}function tn(e,t){var r=e.display,n=r.scrollbars.update(t);r.sizer.style.paddingRight=(r.barWidth=n.right)+"px",r.sizer.style.paddingBottom=(r.barHeight=n.bottom)+"px",r.heightForcer.style.borderBottom=n.bottom+"px solid transparent",n.right&&n.bottom?(r.scrollbarFiller.style.display="block",r.scrollbarFiller.style.height=n.bottom+"px",r.scrollbarFiller.style.width=n.right+"px"):r.scrollbarFiller.style.display="",n.bottom&&e.options.coverGutterNextToScrollbar&&e.options.fixedGutter?(r.gutterFiller.style.display="block",r.gutterFiller.style.height=n.bottom+"px",r.gutterFiller.style.width=t.gutterWidth+"px"):r.gutterFiller.style.display=""}function rn(e){e.display.scrollbars&&(e.display.scrollbars.clear(),e.display.scrollbars.addClass&&Fl(e.display.wrapper,e.display.scrollbars.addClass)),e.display.scrollbars=new ws[e.options.scrollbarStyle](function(t){e.display.wrapper.insertBefore(t,e.display.scrollbarFiller),Ql(t,"mousedown",function(){e.state.focused&&setTimeout(function(){return e.display.input.focus()},0)}),t.setAttribute("cm-not-content","true")},function(t,r){"horizontal"==r?Qr(e,t):qr(e,t)},e),e.display.scrollbars.addClass&&s(e.display.wrapper,e.display.scrollbars.addClass)}function nn(e){e.curOp={cm:e,viewChanged:!1,startHeight:e.doc.height,forceUpdate:!1,updateInput:null,typing:!1,changeObjs:null,cursorActivityHandlers:null,cursorActivityCalled:0,selectionChanged:!1,updateMaxLine:!1,scrollLeft:null,scrollTop:null,scrollToPos:null,focus:!1,id:++xs},vt(e.curOp)}function on(e){yt(e.curOp,function(e){for(var t=0;t<e.ops.length;t++)e.ops[t].cm.curOp=null;ln(e)})}function ln(e){for(var t=e.ops,r=0;r<t.length;r++)sn(t[r]);for(var n=0;n<t.length;n++)an(t[n]);for(var i=0;i<t.length;i++)un(t[i]);for(var o=0;o<t.length;o++)cn(t[o]);for(var l=0;l<t.length;l++)fn(t[l])}function sn(e){var t=e.cm,r=t.display;Ln(t),e.updateMaxLine&&we(t),e.mustUpdate=e.viewChanged||e.forceUpdate||null!=e.scrollTop||e.scrollToPos&&(e.scrollToPos.from.line<r.viewFrom||e.scrollToPos.to.line>=r.viewTo)||r.maxLineChanged&&t.options.lineWrapping,e.update=e.mustUpdate&&new Cs(t,e.mustUpdate&&{top:e.scrollTop,ensure:e.scrollToPos},e.forceUpdate)}function an(e){e.updatedDisplay=e.mustUpdate&&Mn(e.cm,e.update)}function un(e){var t=e.cm,r=t.display;e.updatedDisplay&&Er(t),e.barMeasure=Jr(t),r.maxLineChanged&&!t.options.lineWrapping&&(e.adjustWidthTo=Kt(t,r.maxLine,r.maxLine.text.length).left+3,t.display.sizerWidth=e.adjustWidthTo,e.barMeasure.scrollWidth=Math.max(r.scroller.clientWidth,r.sizer.offsetLeft+e.adjustWidthTo+zt(t)+t.display.barWidth),e.maxScrollLeft=Math.max(0,r.sizer.offsetLeft+e.adjustWidthTo-Rt(t))),(e.updatedDisplay||e.selectionChanged)&&(e.preparedSelection=r.input.prepareSelection())}function cn(e){var t=e.cm;null!=e.adjustWidthTo&&(t.display.sizer.style.minWidth=e.adjustWidthTo+"px",e.maxScrollLeft<t.doc.scrollLeft&&Qr(t,Math.min(t.display.scroller.scrollLeft,e.maxScrollLeft),!0),t.display.maxLineChanged=!1);var r=e.focus&&e.focus==l();e.preparedSelection&&t.display.input.showSelection(e.preparedSelection,r),(e.updatedDisplay||e.startHeight!=t.doc.height)&&en(t,e.barMeasure),e.updatedDisplay&&Dn(t,e.barMeasure),e.selectionChanged&&Ar(t),t.state.focused&&e.updateInput&&t.display.input.reset(e.typing),r&&Wr(e.cm)}function fn(e){var t=e.cm,r=t.display,n=t.doc;e.updatedDisplay&&Nn(t,e.update),null==r.wheelStartX||null==e.scrollTop&&null==e.scrollLeft&&!e.scrollToPos||(r.wheelStartX=r.wheelStartY=null),null!=e.scrollTop&&Zr(t,e.scrollTop,e.forceScroll),null!=e.scrollLeft&&Qr(t,e.scrollLeft,!0,!0),e.scrollToPos&&Br(t,Gr(t,U(n,e.scrollToPos.from),U(n,e.scrollToPos.to),e.scrollToPos.margin));var i=e.maybeHiddenMarkers,o=e.maybeUnhiddenMarkers;if(i)for(var l=0;l<i.length;++l)i[l].lines.length||Te(i[l],"hide");if(o)for(var s=0;s<o.length;++s)o[s].lines.length&&Te(o[s],"unhide");r.wrapper.offsetHeight&&(n.scrollTop=t.display.scroller.scrollTop),e.changeObjs&&Te(t,"changes",t,e.changeObjs),e.update&&e.update.finish()}function hn(e,t){if(e.curOp)return t();nn(e);try{return t()}finally{on(e)}}function dn(e,t){return function(){if(e.curOp)return t.apply(e,arguments);nn(e);try{return t.apply(e,arguments)}finally{on(e)}}}function pn(e){return function(){if(this.curOp)return e.apply(this,arguments);nn(this);try{return e.apply(this,arguments)}finally{on(this)}}}function gn(e){return function(){var t=this.cm;if(!t||t.curOp)return e.apply(this,arguments);nn(t);try{return e.apply(this,arguments)}finally{on(t)}}}function vn(e,t,r,n){null==t&&(t=e.doc.first),null==r&&(r=e.doc.first+e.doc.size),n||(n=0);var i=e.display;if(n&&r<i.viewTo&&(null==i.updateLineNumbers||i.updateLineNumbers>t)&&(i.updateLineNumbers=t),e.curOp.viewChanged=!0,t>=i.viewTo)_l&&pe(e.doc,t)<i.viewTo&&yn(e);else if(r<=i.viewFrom)_l&&ge(e.doc,r+n)>i.viewFrom?yn(e):(i.viewFrom+=n,i.viewTo+=n);else if(t<=i.viewFrom&&r>=i.viewTo)yn(e);else if(t<=i.viewFrom){var o=bn(e,r,r+n,1);o?(i.view=i.view.slice(o.index),i.viewFrom=o.lineN,i.viewTo+=n):yn(e)}else if(r>=i.viewTo){var l=bn(e,t,t,-1);l?(i.view=i.view.slice(0,l.index),i.viewTo=l.lineN):yn(e)}else{var s=bn(e,t,t,-1),a=bn(e,r,r+n,1);s&&a?(i.view=i.view.slice(0,s.index).concat(gt(e,s.lineN,a.lineN)).concat(i.view.slice(a.index)),i.viewTo+=n):yn(e)}var u=i.externalMeasured;u&&(r<u.lineN?u.lineN+=n:t<u.lineN+u.size&&(i.externalMeasured=null))}function mn(e,t,r){e.curOp.viewChanged=!0;var n=e.display,i=e.display.externalMeasured;if(i&&t>=i.lineN&&t<i.lineN+i.size&&(n.externalMeasured=null),!(t<n.viewFrom||t>=n.viewTo)){var o=n.view[Lr(e,t)];if(null!=o.node){var l=o.changes||(o.changes=[]);-1==h(l,r)&&l.push(r)}}}function yn(e){e.display.viewFrom=e.display.viewTo=e.doc.first,e.display.view=[],e.display.viewOffset=0}function bn(e,t,r,n){var i,o=Lr(e,t),l=e.display.view;if(!_l||r==e.doc.first+e.doc.size)return{index:o,lineN:r};for(var s=e.display.viewFrom,a=0;a<o;a++)s+=l[a].size;if(s!=t){if(n>0){if(o==l.length-1)return null;i=s+l[o].size-t,o++}else i=s-t;t+=i,r+=i}for(;pe(e.doc,r)!=r;){if(o==(n<0?0:l.length-1))return null;r+=n*l[o-(n<0?1:0)].size,o+=n}return{index:o,lineN:r}}function wn(e,t,r){var n=e.display;0==n.view.length||t>=n.viewTo||r<=n.viewFrom?(n.view=gt(e,t,r),n.viewFrom=t):(n.viewFrom>t?n.view=gt(e,t,n.viewFrom).concat(n.view):n.viewFrom<t&&(n.view=n.view.slice(Lr(e,t))),n.viewFrom=t,n.viewTo<r?n.view=n.view.concat(gt(e,n.viewTo,r)):n.viewTo>r&&(n.view=n.view.slice(0,Lr(e,r)))),n.viewTo=r}function xn(e){for(var t=e.display.view,r=0,n=0;n<t.length;n++){var i=t[n];i.hidden||i.node&&!i.changes||++r}return r}function Cn(e,t){e.doc.highlightFrontier<e.display.viewTo&&e.state.highlight.set(t,u(Sn,e))}function Sn(e){var t=e.doc;if(!(t.highlightFrontier>=e.display.viewTo)){var r=+new Date+e.options.workTime,n=$e(e,t.highlightFrontier),i=[];t.iter(n.line,Math.min(t.first+t.size,e.display.viewTo+500),function(o){if(n.line>=e.display.viewFrom){var l=o.styles,s=o.text.length>e.options.maxHighlightLength?Ke(t.mode,n.state):null,a=Ye(e,o,n,!0);s&&(n.state=s),o.styles=a.styles;var u=o.styleClasses,c=a.classes;c?o.styleClasses=c:u&&(o.styleClasses=null);for(var f=!l||l.length!=o.styles.length||u!=c&&(!u||!c||u.bgClass!=c.bgClass||u.textClass!=c.textClass),h=0;!f&&h<l.length;++h)f=l[h]!=o.styles[h];f&&i.push(n.line),o.stateAfter=n.save(),n.nextLine()}else o.text.length<=e.options.maxHighlightLength&&qe(e,o.text,n),o.stateAfter=n.line%5==0?n.save():null,n.nextLine();if(+new Date>r)return Cn(e,e.options.workDelay),!0}),t.highlightFrontier=n.line,t.modeFrontier=Math.max(t.modeFrontier,n.line),i.length&&hn(e,function(){for(var t=0;t<i.length;t++)mn(e,i[t],"text")})}}function Ln(e){var t=e.display;!t.scrollbarsClipped&&t.scroller.offsetWidth&&(t.nativeBarWidth=t.scroller.offsetWidth-t.scroller.clientWidth,t.heightForcer.style.height=zt(e)+"px",t.sizer.style.marginBottom=-t.nativeBarWidth+"px",t.sizer.style.borderRightWidth=zt(e)+"px",t.scrollbarsClipped=!0)}function kn(e){if(e.hasFocus())return null;var t=l();if(!t||!o(e.display.lineDiv,t))return null;var r={activeElt:t};if(window.getSelection){var n=window.getSelection();n.anchorNode&&n.extend&&o(e.display.lineDiv,n.anchorNode)&&(r.anchorNode=n.anchorNode,r.anchorOffset=n.anchorOffset,r.focusNode=n.focusNode,r.focusOffset=n.focusOffset)}return r}function Tn(e){if(e&&e.activeElt&&e.activeElt!=l()&&(e.activeElt.focus(),e.anchorNode&&o(document.body,e.anchorNode)&&o(document.body,e.focusNode))){var t=window.getSelection(),r=document.createRange();r.setEnd(e.anchorNode,e.anchorOffset),r.collapse(!1),t.removeAllRanges(),t.addRange(r),t.extend(e.focusNode,e.focusOffset)}}function Mn(e,r){var n=e.display,i=e.doc;if(r.editorIsHidden)return yn(e),!1;if(!r.force&&r.visible.from>=n.viewFrom&&r.visible.to<=n.viewTo&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo)&&n.renderedView==n.view&&0==xn(e))return!1;Rr(e)&&(yn(e),r.dims=br(e));var o=i.first+i.size,l=Math.max(r.visible.from-e.options.viewportMargin,i.first),s=Math.min(o,r.visible.to+e.options.viewportMargin);n.viewFrom<l&&l-n.viewFrom<20&&(l=Math.max(i.first,n.viewFrom)),n.viewTo>s&&n.viewTo-s<20&&(s=Math.min(o,n.viewTo)),_l&&(l=pe(e.doc,l),s=ge(e.doc,s));var a=l!=n.viewFrom||s!=n.viewTo||n.lastWrapHeight!=r.wrapperHeight||n.lastWrapWidth!=r.wrapperWidth;wn(e,l,s),n.viewOffset=ye(M(e.doc,n.viewFrom)),e.display.mover.style.top=n.viewOffset+"px";var u=xn(e);if(!a&&0==u&&!r.force&&n.renderedView==n.view&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo))return!1;var c=kn(e);return u>4&&(n.lineDiv.style.display="none"),An(e,n.updateLineNumbers,r.dims),u>4&&(n.lineDiv.style.display=""),n.renderedView=n.view,Tn(c),t(n.cursorDiv),t(n.selectionDiv),n.gutters.style.height=n.sizer.style.minHeight=0,a&&(n.lastWrapHeight=r.wrapperHeight,n.lastWrapWidth=r.wrapperWidth,Cn(e,400)),n.updateLineNumbers=null,!0}function Nn(e,t){for(var r=t.viewport,n=!0;(n&&e.options.lineWrapping&&t.oldDisplayWidth!=Rt(e)||(r&&null!=r.top&&(r={top:Math.min(e.doc.height+Pt(e.display)-Bt(e),r.top)}),t.visible=Ir(e.display,e.doc,r),!(t.visible.from>=e.display.viewFrom&&t.visible.to<=e.display.viewTo)))&&Mn(e,t);n=!1){Er(e);var i=Jr(e);kr(e),en(e,i),Dn(e,i),t.force=!1}t.signal(e,"update",e),e.display.viewFrom==e.display.reportedViewFrom&&e.display.viewTo==e.display.reportedViewTo||(t.signal(e,"viewportChange",e,e.display.viewFrom,e.display.viewTo),e.display.reportedViewFrom=e.display.viewFrom,e.display.reportedViewTo=e.display.viewTo)}function On(e,t){var r=new Cs(e,t);if(Mn(e,r)){Er(e),Nn(e,r);var n=Jr(e);kr(e),en(e,n),Dn(e,n),r.finish()}}function An(e,r,n){function i(t){var r=t.nextSibling;return ml&&Ml&&e.display.currentWheelTarget==t?t.style.display="none":t.parentNode.removeChild(t),r}for(var o=e.display,l=e.options.lineNumbers,s=o.lineDiv,a=s.firstChild,u=o.view,c=o.viewFrom,f=0;f<u.length;f++){var d=u[f];if(d.hidden);else if(d.node&&d.node.parentNode==s){for(;a!=d.node;)a=i(a);var p=l&&null!=r&&r<=c&&d.lineNumber;d.changes&&(h(d.changes,"gutter")>-1&&(p=!1),xt(e,d,c,n)),p&&(t(d.lineNumber),d.lineNumber.appendChild(document.createTextNode(F(e.options,c)))),a=d.node.nextSibling}else{var g=Ot(e,d,c,n);s.insertBefore(g,a)}c+=d.size}for(;a;)a=i(a)}function Wn(e){var t=e.display.gutters.offsetWidth;e.display.sizer.style.marginLeft=t+"px"}function Dn(e,t){e.display.sizer.style.minHeight=t.docHeight+"px",e.display.heightForcer.style.top=t.docHeight+"px",e.display.gutters.style.height=t.docHeight+e.display.barHeight+zt(e)+"px"}function Hn(e){var r=e.display.gutters,i=e.options.gutters;t(r);for(var o=0;o<i.length;++o){var l=i[o],s=r.appendChild(n("div",null,"CodeMirror-gutter "+l));"CodeMirror-linenumbers"==l&&(e.display.lineGutter=s,s.style.width=(e.display.lineNumWidth||1)+"px")}r.style.display=o?"":"none",Wn(e)}function Fn(e){var t=h(e.gutters,"CodeMirror-linenumbers");-1==t&&e.lineNumbers?e.gutters=e.gutters.concat(["CodeMirror-linenumbers"]):t>-1&&!e.lineNumbers&&(e.gutters=e.gutters.slice(0),e.gutters.splice(t,1))}function En(e){var t=e.wheelDeltaX,r=e.wheelDeltaY;return null==t&&e.detail&&e.axis==e.HORIZONTAL_AXIS&&(t=e.detail),null==r&&e.detail&&e.axis==e.VERTICAL_AXIS?r=e.detail:null==r&&(r=e.wheelDelta),{x:t,y:r}}function Pn(e){var t=En(e);return t.x*=Ls,t.y*=Ls,t}function In(e,t){var r=En(t),n=r.x,i=r.y,o=e.display,l=o.scroller,s=l.scrollWidth>l.clientWidth,a=l.scrollHeight>l.clientHeight;if(n&&s||i&&a){if(i&&Ml&&ml)e:for(var u=t.target,c=o.view;u!=l;u=u.parentNode)for(var f=0;f<c.length;f++)if(c[f].node==u){e.display.currentWheelTarget=u;break e}if(n&&!fl&&!wl&&null!=Ls)return i&&a&&qr(e,Math.max(0,l.scrollTop+i*Ls)),Qr(e,Math.max(0,l.scrollLeft+n*Ls)),(!i||i&&a)&&We(t),void(o.wheelStartX=null);if(i&&null!=Ls){var h=i*Ls,d=e.doc.scrollTop,p=d+o.wrapper.clientHeight;h<0?d=Math.max(0,d+h-50):p=Math.min(e.doc.height,p+h+50),On(e,{top:d,bottom:p})}Ss<20&&(null==o.wheelStartX?(o.wheelStartX=l.scrollLeft,o.wheelStartY=l.scrollTop,o.wheelDX=n,o.wheelDY=i,setTimeout(function(){if(null!=o.wheelStartX){var e=l.scrollLeft-o.wheelStartX,t=l.scrollTop-o.wheelStartY,r=t&&o.wheelDY&&t/o.wheelDY||e&&o.wheelDX&&e/o.wheelDX;o.wheelStartX=o.wheelStartY=null,r&&(Ls=(Ls*Ss+r)/(Ss+1),++Ss)}},200)):(o.wheelDX+=n,o.wheelDY+=i))}}function zn(e,t){var r=e[t];e.sort(function(e,t){return P(e.from(),t.from())}),t=h(e,r);for(var n=1;n<e.length;n++){var i=e[n],o=e[n-1];if(P(o.to(),i.from())>=0){var l=B(o.from(),i.from()),s=R(o.to(),i.to()),a=o.empty()?i.from()==i.head:o.from()==o.head;n<=t&&--t,e.splice(--n,2,new Ts(a?s:l,a?l:s))}}return new ks(e,t)}function Rn(e,t){return new ks([new Ts(e,t||e)],0)}function Bn(e){return e.text?E(e.from.line+e.text.length-1,g(e.text).length+(1==e.text.length?e.from.ch:0)):e.to}function Gn(e,t){if(P(e,t.from)<0)return e;if(P(e,t.to)<=0)return Bn(t);var r=e.line+t.text.length-(t.to.line-t.from.line)-1,n=e.ch;return e.line==t.to.line&&(n+=Bn(t).ch-t.to.ch),E(r,n)}function Un(e,t){for(var r=[],n=0;n<e.sel.ranges.length;n++){var i=e.sel.ranges[n];r.push(new Ts(Gn(i.anchor,t),Gn(i.head,t)))}return zn(r,e.sel.primIndex)}function Vn(e,t,r){return e.line==t.line?E(r.line,e.ch-t.ch+r.ch):E(r.line+(e.line-t.line),e.ch)}function Kn(e,t,r){for(var n=[],i=E(e.first,0),o=i,l=0;l<t.length;l++){var s=t[l],a=Vn(s.from,i,o),u=Vn(Bn(s),i,o);if(i=s.to,o=u,"around"==r){var c=e.sel.ranges[l],f=P(c.head,c.anchor)<0;n[l]=new Ts(f?u:a,f?a:u)}else n[l]=new Ts(a,a)}return new ks(n,e.sel.primIndex)}function jn(e){e.doc.mode=Ue(e.options,e.doc.modeOption),Xn(e)}function Xn(e){e.doc.iter(function(e){e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null)}),e.doc.modeFrontier=e.doc.highlightFrontier=e.doc.first,Cn(e,100),e.state.modeGen++,e.curOp&&vn(e)}function Yn(e,t){return 0==t.from.ch&&0==t.to.ch&&""==g(t.text)&&(!e.cm||e.cm.options.wholeLineUpdateBefore)}function _n(e,t,r,n){function i(e){return r?r[e]:null}function o(e,r,i){it(e,r,i,n),bt(e,"change",e,t)}function l(e,t){for(var r=[],o=e;o<t;++o)r.push(new fs(u[o],i(o),n));return r}var s=t.from,a=t.to,u=t.text,c=M(e,s.line),f=M(e,a.line),h=g(u),d=i(u.length-1),p=a.line-s.line;if(t.full)e.insert(0,l(0,u.length)),e.remove(u.length,e.size-u.length);else if(Yn(e,t)){var v=l(0,u.length-1);o(f,f.text,d),p&&e.remove(s.line,p),v.length&&e.insert(s.line,v)}else if(c==f)if(1==u.length)o(c,c.text.slice(0,s.ch)+h+c.text.slice(a.ch),d);else{var m=l(1,u.length-1);m.push(new fs(h+c.text.slice(a.ch),d,n)),o(c,c.text.slice(0,s.ch)+u[0],i(0)),e.insert(s.line+1,m)}else if(1==u.length)o(c,c.text.slice(0,s.ch)+u[0]+f.text.slice(a.ch),i(0)),e.remove(s.line+1,p);else{o(c,c.text.slice(0,s.ch)+u[0],i(0)),o(f,h+f.text.slice(a.ch),d);var y=l(1,u.length-1);p>1&&e.remove(s.line+1,p-1),e.insert(s.line+1,y)}bt(e,"change",e,t)}function $n(e,t,r){function n(e,i,o){if(e.linked)for(var l=0;l<e.linked.length;++l){var s=e.linked[l];if(s.doc!=i){var a=o&&s.sharedHist;r&&!a||(t(s.doc,a),n(s.doc,e,a))}}}n(e,null,!0)}function qn(e,t){if(t.cm)throw new Error("This document is already in use.");e.doc=t,t.cm=e,Cr(e),jn(e),Zn(e),e.options.lineWrapping||we(e),e.options.mode=t.modeOption,vn(e)}function Zn(e){("rtl"==e.doc.direction?s:Fl)(e.display.lineDiv,"CodeMirror-rtl")}function Qn(e){hn(e,function(){Zn(e),vn(e)})}function Jn(e){this.done=[],this.undone=[],this.undoDepth=1/0,this.lastModTime=this.lastSelTime=0,this.lastOp=this.lastSelOp=null,this.lastOrigin=this.lastSelOrigin=null,this.generation=this.maxGeneration=e||1}function ei(e,t){var r={from:z(t.from),to:Bn(t),text:N(e,t.from,t.to)};return si(e,r,t.from.line,t.to.line+1),$n(e,function(e){return si(e,r,t.from.line,t.to.line+1)},!0),r}function ti(e){for(;e.length&&g(e).ranges;)e.pop()}function ri(e,t){return t?(ti(e.done),g(e.done)):e.done.length&&!g(e.done).ranges?g(e.done):e.done.length>1&&!e.done[e.done.length-2].ranges?(e.done.pop(),g(e.done)):void 0}function ni(e,t,r,n){var i=e.history;i.undone.length=0;var o,l,s=+new Date;if((i.lastOp==n||i.lastOrigin==t.origin&&t.origin&&("+"==t.origin.charAt(0)&&e.cm&&i.lastModTime>s-e.cm.options.historyEventDelay||"*"==t.origin.charAt(0)))&&(o=ri(i,i.lastOp==n)))l=g(o.changes),0==P(t.from,t.to)&&0==P(t.from,l.to)?l.to=Bn(t):o.changes.push(ei(e,t));else{var a=g(i.done);for(a&&a.ranges||li(e.sel,i.done),o={changes:[ei(e,t)],generation:i.generation},i.done.push(o);i.done.length>i.undoDepth;)i.done.shift(),i.done[0].ranges||i.done.shift()}i.done.push(r),i.generation=++i.maxGeneration,i.lastModTime=i.lastSelTime=s,i.lastOp=i.lastSelOp=n,i.lastOrigin=i.lastSelOrigin=t.origin,l||Te(e,"historyAdded")}function ii(e,t,r,n){var i=t.charAt(0);return"*"==i||"+"==i&&r.ranges.length==n.ranges.length&&r.somethingSelected()==n.somethingSelected()&&new Date-e.history.lastSelTime<=(e.cm?e.cm.options.historyEventDelay:500)}function oi(e,t,r,n){var i=e.history,o=n&&n.origin;r==i.lastSelOp||o&&i.lastSelOrigin==o&&(i.lastModTime==i.lastSelTime&&i.lastOrigin==o||ii(e,o,g(i.done),t))?i.done[i.done.length-1]=t:li(t,i.done),i.lastSelTime=+new Date,i.lastSelOrigin=o,i.lastSelOp=r,n&&!1!==n.clearRedo&&ti(i.undone)}function li(e,t){var r=g(t);r&&r.ranges&&r.equals(e)||t.push(e)}function si(e,t,r,n){var i=t["spans_"+e.id],o=0;e.iter(Math.max(e.first,r),Math.min(e.first+e.size,n),function(r){r.markedSpans&&((i||(i=t["spans_"+e.id]={}))[o]=r.markedSpans),++o})}function ai(e){if(!e)return null;for(var t,r=0;r<e.length;++r)e[r].marker.explicitlyCleared?t||(t=e.slice(0,r)):t&&t.push(e[r]);return t?t.length?t:null:e}function ui(e,t){var r=t["spans_"+e.id];if(!r)return null;for(var n=[],i=0;i<t.text.length;++i)n.push(ai(r[i]));return n}function ci(e,t){var r=ui(e,t),n=J(e,t);if(!r)return n;if(!n)return r;for(var i=0;i<r.length;++i){var o=r[i],l=n[i];if(o&&l)e:for(var s=0;s<l.length;++s){for(var a=l[s],u=0;u<o.length;++u)if(o[u].marker==a.marker)continue e;o.push(a)}else l&&(r[i]=l)}return r}function fi(e,t,r){for(var n=[],i=0;i<e.length;++i){var o=e[i];if(o.ranges)n.push(r?ks.prototype.deepCopy.call(o):o);else{var l=o.changes,s=[];n.push({changes:s});for(var a=0;a<l.length;++a){var u=l[a],c=void 0;if(s.push({from:u.from,to:u.to,text:u.text}),t)for(var f in u)(c=f.match(/^spans_(\d+)$/))&&h(t,Number(c[1]))>-1&&(g(s)[f]=u[f],delete u[f])}}}return n}function hi(e,t,r,n){if(n){var i=e.anchor;if(r){var o=P(t,i)<0;o!=P(r,i)<0?(i=t,t=r):o!=P(t,r)<0&&(t=r)}return new Ts(i,t)}return new Ts(r||t,t)}function di(e,t,r,n,i){null==i&&(i=e.cm&&(e.cm.display.shift||e.extend)),bi(e,new ks([hi(e.sel.primary(),t,r,i)],0),n)}function pi(e,t,r){for(var n=[],i=e.cm&&(e.cm.display.shift||e.extend),o=0;o<e.sel.ranges.length;o++)n[o]=hi(e.sel.ranges[o],t[o],null,i);bi(e,zn(n,e.sel.primIndex),r)}function gi(e,t,r,n){var i=e.sel.ranges.slice(0);i[t]=r,bi(e,zn(i,e.sel.primIndex),n)}function vi(e,t,r,n){bi(e,Rn(t,r),n)}function mi(e,t,r){var n={ranges:t.ranges,update:function(t){var r=this;this.ranges=[];for(var n=0;n<t.length;n++)r.ranges[n]=new Ts(U(e,t[n].anchor),U(e,t[n].head))},origin:r&&r.origin};return Te(e,"beforeSelectionChange",e,n),e.cm&&Te(e.cm,"beforeSelectionChange",e.cm,n),n.ranges!=t.ranges?zn(n.ranges,n.ranges.length-1):t}function yi(e,t,r){var n=e.history.done,i=g(n);i&&i.ranges?(n[n.length-1]=t,wi(e,t,r)):bi(e,t,r)}function bi(e,t,r){wi(e,t,r),oi(e,e.sel,e.cm?e.cm.curOp.id:NaN,r)}function wi(e,t,r){(Oe(e,"beforeSelectionChange")||e.cm&&Oe(e.cm,"beforeSelectionChange"))&&(t=mi(e,t,r)),xi(e,Si(e,t,r&&r.bias||(P(t.primary().head,e.sel.primary().head)<0?-1:1),!0)),r&&!1===r.scroll||!e.cm||jr(e.cm)}function xi(e,t){t.equals(e.sel)||(e.sel=t,e.cm&&(e.cm.curOp.updateInput=e.cm.curOp.selectionChanged=!0,Ne(e.cm)),bt(e,"cursorActivity",e))}function Ci(e){xi(e,Si(e,e.sel,null,!1))}function Si(e,t,r,n){for(var i,o=0;o<t.ranges.length;o++){var l=t.ranges[o],s=t.ranges.length==e.sel.ranges.length&&e.sel.ranges[o],a=ki(e,l.anchor,s&&s.anchor,r,n),u=ki(e,l.head,s&&s.head,r,n);(i||a!=l.anchor||u!=l.head)&&(i||(i=t.ranges.slice(0,o)),i[o]=new Ts(a,u))}return i?zn(i,t.primIndex):t}function Li(e,t,r,n,i){var o=M(e,t.line);if(o.markedSpans)for(var l=0;l<o.markedSpans.length;++l){var s=o.markedSpans[l],a=s.marker;if((null==s.from||(a.inclusiveLeft?s.from<=t.ch:s.from<t.ch))&&(null==s.to||(a.inclusiveRight?s.to>=t.ch:s.to>t.ch))){if(i&&(Te(a,"beforeCursorEnter"),a.explicitlyCleared)){if(o.markedSpans){--l;continue}break}if(!a.atomic)continue;if(r){var u=a.find(n<0?1:-1),c=void 0;if((n<0?a.inclusiveRight:a.inclusiveLeft)&&(u=Ti(e,u,-n,u&&u.line==t.line?o:null)),u&&u.line==t.line&&(c=P(u,r))&&(n<0?c<0:c>0))return Li(e,u,t,n,i)}var f=a.find(n<0?-1:1);return(n<0?a.inclusiveLeft:a.inclusiveRight)&&(f=Ti(e,f,n,f.line==t.line?o:null)),f?Li(e,f,t,n,i):null}}return t}function ki(e,t,r,n,i){var o=n||1,l=Li(e,t,r,o,i)||!i&&Li(e,t,r,o,!0)||Li(e,t,r,-o,i)||!i&&Li(e,t,r,-o,!0);return l||(e.cantEdit=!0,E(e.first,0))}function Ti(e,t,r,n){return r<0&&0==t.ch?t.line>e.first?U(e,E(t.line-1)):null:r>0&&t.ch==(n||M(e,t.line)).text.length?t.line<e.first+e.size-1?E(t.line+1,0):null:new E(t.line,t.ch+r)}function Mi(e){e.setSelection(E(e.firstLine(),0),E(e.lastLine()),Gl)}function Ni(e,t,r){var n={canceled:!1,from:t.from,to:t.to,text:t.text,origin:t.origin,cancel:function(){return n.canceled=!0}};return r&&(n.update=function(t,r,i,o){t&&(n.from=U(e,t)),r&&(n.to=U(e,r)),i&&(n.text=i),void 0!==o&&(n.origin=o)}),Te(e,"beforeChange",e,n),e.cm&&Te(e.cm,"beforeChange",e.cm,n),n.canceled?null:{from:n.from,to:n.to,text:n.text,origin:n.origin}}function Oi(e,t,r){if(e.cm){if(!e.cm.curOp)return dn(e.cm,Oi)(e,t,r);if(e.cm.state.suppressEdits)return}if(!(Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"))||(t=Ni(e,t,!0))){var n=Yl&&!r&&te(e,t.from,t.to);if(n)for(var i=n.length-1;i>=0;--i)Ai(e,{from:n[i].from,to:n[i].to,text:i?[""]:t.text,origin:t.origin});else Ai(e,t)}}function Ai(e,t){if(1!=t.text.length||""!=t.text[0]||0!=P(t.from,t.to)){var r=Un(e,t);ni(e,t,r,e.cm?e.cm.curOp.id:NaN),Hi(e,t,r,J(e,t));var n=[];$n(e,function(e,r){r||-1!=h(n,e.history)||(zi(e.history,t),n.push(e.history)),Hi(e,t,null,J(e,t))})}}function Wi(e,t,r){if(!e.cm||!e.cm.state.suppressEdits||r){for(var n,i=e.history,o=e.sel,l="undo"==t?i.done:i.undone,s="undo"==t?i.undone:i.done,a=0;a<l.length&&(n=l[a],r?!n.ranges||n.equals(e.sel):n.ranges);a++);if(a!=l.length){for(i.lastOrigin=i.lastSelOrigin=null;(n=l.pop()).ranges;){if(li(n,s),r&&!n.equals(e.sel))return void bi(e,n,{clearRedo:!1});o=n}var u=[];li(o,s),s.push({changes:u,generation:i.generation}),i.generation=n.generation||++i.maxGeneration;for(var c=Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"),f=n.changes.length-1;f>=0;--f){var d=function(r){var i=n.changes[r];if(i.origin=t,c&&!Ni(e,i,!1))return l.length=0,{};u.push(ei(e,i));var o=r?Un(e,i):g(l);Hi(e,i,o,ci(e,i)),!r&&e.cm&&e.cm.scrollIntoView({from:i.from,to:Bn(i)});var s=[];$n(e,function(e,t){t||-1!=h(s,e.history)||(zi(e.history,i),s.push(e.history)),Hi(e,i,null,ci(e,i))})}(f);if(d)return d.v}}}}function Di(e,t){if(0!=t&&(e.first+=t,e.sel=new ks(v(e.sel.ranges,function(e){return new Ts(E(e.anchor.line+t,e.anchor.ch),E(e.head.line+t,e.head.ch))}),e.sel.primIndex),e.cm)){vn(e.cm,e.first,e.first-t,t);for(var r=e.cm.display,n=r.viewFrom;n<r.viewTo;n++)mn(e.cm,n,"gutter")}}function Hi(e,t,r,n){if(e.cm&&!e.cm.curOp)return dn(e.cm,Hi)(e,t,r,n);if(t.to.line<e.first)Di(e,t.text.length-1-(t.to.line-t.from.line));else if(!(t.from.line>e.lastLine())){if(t.from.line<e.first){var i=t.text.length-1-(e.first-t.from.line);Di(e,i),t={from:E(e.first,0),to:E(t.to.line+i,t.to.ch),text:[g(t.text)],origin:t.origin}}var o=e.lastLine();t.to.line>o&&(t={from:t.from,to:E(o,M(e,o).text.length),text:[t.text[0]],origin:t.origin}),t.removed=N(e,t.from,t.to),r||(r=Un(e,t)),e.cm?Fi(e.cm,t,n):_n(e,t,n),wi(e,r,Gl)}}function Fi(e,t,r){var n=e.doc,i=e.display,o=t.from,l=t.to,s=!1,a=o.line;e.options.lineWrapping||(a=W(fe(M(n,o.line))),n.iter(a,l.line+1,function(e){if(e==i.maxLine)return s=!0,!0})),n.sel.contains(t.from,t.to)>-1&&Ne(e),_n(n,t,r,xr(e)),e.options.lineWrapping||(n.iter(a,o.line+t.text.length,function(e){var t=be(e);t>i.maxLineLength&&(i.maxLine=e,i.maxLineLength=t,i.maxLineChanged=!0,s=!1)}),s&&(e.curOp.updateMaxLine=!0)),nt(n,o.line),Cn(e,400);var u=t.text.length-(l.line-o.line)-1;t.full?vn(e):o.line!=l.line||1!=t.text.length||Yn(e.doc,t)?vn(e,o.line,l.line+1,u):mn(e,o.line,"text");var c=Oe(e,"changes"),f=Oe(e,"change");if(f||c){var h={from:o,to:l,text:t.text,removed:t.removed,origin:t.origin};f&&bt(e,"change",e,h),c&&(e.curOp.changeObjs||(e.curOp.changeObjs=[])).push(h)}e.display.selForContextMenu=null}function Ei(e,t,r,n,i){if(n||(n=r),P(n,r)<0){var o;r=(o=[n,r])[0],n=o[1]}"string"==typeof t&&(t=e.splitLines(t)),Oi(e,{from:r,to:n,text:t,origin:i})}function Pi(e,t,r,n){r<e.line?e.line+=n:t<e.line&&(e.line=t,e.ch=0)}function Ii(e,t,r,n){for(var i=0;i<e.length;++i){var o=e[i],l=!0;if(o.ranges){o.copied||((o=e[i]=o.deepCopy()).copied=!0);for(var s=0;s<o.ranges.length;s++)Pi(o.ranges[s].anchor,t,r,n),Pi(o.ranges[s].head,t,r,n)}else{for(var a=0;a<o.changes.length;++a){var u=o.changes[a];if(r<u.from.line)u.from=E(u.from.line+n,u.from.ch),u.to=E(u.to.line+n,u.to.ch);else if(t<=u.to.line){l=!1;break}}l||(e.splice(0,i+1),i=0)}}}function zi(e,t){var r=t.from.line,n=t.to.line,i=t.text.length-(n-r)-1;Ii(e.done,r,n,i),Ii(e.undone,r,n,i)}function Ri(e,t,r,n){var i=t,o=t;return"number"==typeof t?o=M(e,G(e,t)):i=W(t),null==i?null:(n(o,i)&&e.cm&&mn(e.cm,i,r),o)}function Bi(e){var t=this;this.lines=e,this.parent=null;for(var r=0,n=0;n<e.length;++n)e[n].parent=t,r+=e[n].height;this.height=r}function Gi(e){var t=this;this.children=e;for(var r=0,n=0,i=0;i<e.length;++i){var o=e[i];r+=o.chunkSize(),n+=o.height,o.parent=t}this.size=r,this.height=n,this.parent=null}function Ui(e,t,r){ye(t)<(e.curOp&&e.curOp.scrollTop||e.doc.scrollTop)&&Kr(e,r)}function Vi(e,t,r,n){var i=new Ms(e,r,n),o=e.cm;return o&&i.noHScroll&&(o.display.alignWidgets=!0),Ri(e,t,"widget",function(t){var r=t.widgets||(t.widgets=[]);if(null==i.insertAt?r.push(i):r.splice(Math.min(r.length-1,Math.max(0,i.insertAt)),0,i),i.line=t,o&&!ve(e,t)){var n=ye(t)<e.scrollTop;A(t,t.height+Ht(i)),n&&Kr(o,i.height),o.curOp.forceUpdate=!0}return!0}),bt(o,"lineWidgetAdded",o,i,"number"==typeof t?t:W(t)),i}function Ki(e,t,r,n,o){if(n&&n.shared)return ji(e,t,r,n,o);if(e.cm&&!e.cm.curOp)return dn(e.cm,Ki)(e,t,r,n,o);var l=new Os(e,o),s=P(t,r);if(n&&c(n,l,!1),s>0||0==s&&!1!==l.clearWhenEmpty)return l;if(l.replacedWith&&(l.collapsed=!0,l.widgetNode=i("span",[l.replacedWith],"CodeMirror-widget"),n.handleMouseEvents||l.widgetNode.setAttribute("cm-ignore-events","true"),n.insertLeft&&(l.widgetNode.insertLeft=!0)),l.collapsed){if(ce(e,t.line,t,r,l)||t.line!=r.line&&ce(e,r.line,t,r,l))throw new Error("Inserting collapsed marker partially overlapping an existing one");X()}l.addToHistory&&ni(e,{from:t,to:r,origin:"markText"},e.sel,NaN);var a,u=t.line,f=e.cm;if(e.iter(u,r.line+1,function(e){f&&l.collapsed&&!f.options.lineWrapping&&fe(e)==f.display.maxLine&&(a=!0),l.collapsed&&u!=t.line&&A(e,0),q(e,new Y(l,u==t.line?t.ch:null,u==r.line?r.ch:null)),++u}),l.collapsed&&e.iter(t.line,r.line+1,function(t){ve(e,t)&&A(t,0)}),l.clearOnEnter&&Ql(l,"beforeCursorEnter",function(){return l.clear()}),l.readOnly&&(j(),(e.history.done.length||e.history.undone.length)&&e.clearHistory()),l.collapsed&&(l.id=++Ns,l.atomic=!0),f){if(a&&(f.curOp.updateMaxLine=!0),l.collapsed)vn(f,t.line,r.line+1);else if(l.className||l.title||l.startStyle||l.endStyle||l.css)for(var h=t.line;h<=r.line;h++)mn(f,h,"text");l.atomic&&Ci(f.doc),bt(f,"markerAdded",f,l)}return l}function ji(e,t,r,n,i){(n=c(n)).shared=!1;var o=[Ki(e,t,r,n,i)],l=o[0],s=n.widgetNode;return $n(e,function(e){s&&(n.widgetNode=s.cloneNode(!0)),o.push(Ki(e,U(e,t),U(e,r),n,i));for(var a=0;a<e.linked.length;++a)if(e.linked[a].isParent)return;l=g(o)}),new As(o,l)}function Xi(e){return e.findMarks(E(e.first,0),e.clipPos(E(e.lastLine())),function(e){return e.parent})}function Yi(e,t){for(var r=0;r<t.length;r++){var n=t[r],i=n.find(),o=e.clipPos(i.from),l=e.clipPos(i.to);if(P(o,l)){var s=Ki(e,o,l,n.primary,n.primary.type);n.markers.push(s),s.parent=n}}}function _i(e){for(var t=0;t<e.length;t++)!function(t){var r=e[t],n=[r.primary.doc];$n(r.primary.doc,function(e){return n.push(e)});for(var i=0;i<r.markers.length;i++){var o=r.markers[i];-1==h(n,o.doc)&&(o.parent=null,r.markers.splice(i--,1))}}(t)}function $i(e){var t=this;if(Qi(t),!Me(t,e)&&!Ft(t.display,e)){We(e),gl&&(Hs=+new Date);var r=Sr(t,e,!0),n=e.dataTransfer.files;if(r&&!t.isReadOnly())if(n&&n.length&&window.FileReader&&window.File)for(var i=n.length,o=Array(i),l=0,s=0;s<i;++s)!function(e,n){if(!t.options.allowDropFileTypes||-1!=h(t.options.allowDropFileTypes,e.type)){var s=new FileReader;s.onload=dn(t,function(){var e=s.result;if(/[\x00-\x08\x0e-\x1f]{2}/.test(e)&&(e=""),o[n]=e,++l==i){var a={from:r=U(t.doc,r),to:r,text:t.doc.splitLines(o.join(t.doc.lineSeparator())),origin:"paste"};Oi(t.doc,a),yi(t.doc,Rn(r,Bn(a)))}}),s.readAsText(e)}}(n[s],s);else{if(t.state.draggingText&&t.doc.sel.contains(r)>-1)return t.state.draggingText(e),void setTimeout(function(){return t.display.input.focus()},20);try{var a=e.dataTransfer.getData("Text");if(a){var u;if(t.state.draggingText&&!t.state.draggingText.copy&&(u=t.listSelections()),wi(t.doc,Rn(r,r)),u)for(var c=0;c<u.length;++c)Ei(t.doc,"",u[c].anchor,u[c].head,"drag");t.replaceSelection(a,"around","paste"),t.display.input.focus()}}catch(e){}}}}function qi(e,t){if(gl&&(!e.state.draggingText||+new Date-Hs<100))Fe(t);else if(!Me(e,t)&&!Ft(e.display,t)&&(t.dataTransfer.setData("Text",e.getSelection()),t.dataTransfer.effectAllowed="copyMove",t.dataTransfer.setDragImage&&!xl)){var r=n("img",null,null,"position: fixed; left: 0; top: 0;");r.src="data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==",wl&&(r.width=r.height=1,e.display.wrapper.appendChild(r),r._top=r.offsetTop),t.dataTransfer.setDragImage(r,0,0),wl&&r.parentNode.removeChild(r)}}function Zi(e,t){var i=Sr(e,t);if(i){var o=document.createDocumentFragment();Mr(e,i,o),e.display.dragCursor||(e.display.dragCursor=n("div",null,"CodeMirror-cursors CodeMirror-dragcursors"),e.display.lineSpace.insertBefore(e.display.dragCursor,e.display.cursorDiv)),r(e.display.dragCursor,o)}}function Qi(e){e.display.dragCursor&&(e.display.lineSpace.removeChild(e.display.dragCursor),e.display.dragCursor=null)}function Ji(e){if(document.getElementsByClassName)for(var t=document.getElementsByClassName("CodeMirror"),r=0;r<t.length;r++){var n=t[r].CodeMirror;n&&e(n)}}function eo(){Fs||(to(),Fs=!0)}function to(){var e;Ql(window,"resize",function(){null==e&&(e=setTimeout(function(){e=null,Ji(ro)},100))}),Ql(window,"blur",function(){return Ji(Fr)})}function ro(e){var t=e.display;t.lastWrapHeight==t.wrapper.clientHeight&&t.lastWrapWidth==t.wrapper.clientWidth||(t.cachedCharWidth=t.cachedTextHeight=t.cachedPaddingH=null,t.scrollbarsClipped=!1,e.setSize())}function no(e){var t=e.split(/-(?!$)/);e=t[t.length-1];for(var r,n,i,o,l=0;l<t.length-1;l++){var s=t[l];if(/^(cmd|meta|m)$/i.test(s))o=!0;else if(/^a(lt)?$/i.test(s))r=!0;else if(/^(c|ctrl|control)$/i.test(s))n=!0;else{if(!/^s(hift)?$/i.test(s))throw new Error("Unrecognized modifier name: "+s);i=!0}}return r&&(e="Alt-"+e),n&&(e="Ctrl-"+e),o&&(e="Cmd-"+e),i&&(e="Shift-"+e),e}function io(e){var t={};for(var r in e)if(e.hasOwnProperty(r)){var n=e[r];if(/^(name|fallthrough|(de|at)tach)$/.test(r))continue;if("..."==n){delete e[r];continue}for(var i=v(r.split(" "),no),o=0;o<i.length;o++){var l=void 0,s=void 0;o==i.length-1?(s=i.join(" "),l=n):(s=i.slice(0,o+1).join(" "),l="...");var a=t[s];if(a){if(a!=l)throw new Error("Inconsistent bindings for "+s)}else t[s]=l}delete e[r]}for(var u in t)e[u]=t[u];return e}function oo(e,t,r,n){var i=(t=uo(t)).call?t.call(e,n):t[e];if(!1===i)return"nothing";if("..."===i)return"multi";if(null!=i&&r(i))return"handled";if(t.fallthrough){if("[object Array]"!=Object.prototype.toString.call(t.fallthrough))return oo(e,t.fallthrough,r,n);for(var o=0;o<t.fallthrough.length;o++){var l=oo(e,t.fallthrough[o],r,n);if(l)return l}}}function lo(e){var t="string"==typeof e?e:Es[e.keyCode];return"Ctrl"==t||"Alt"==t||"Shift"==t||"Mod"==t}function so(e,t,r){var n=e;return t.altKey&&"Alt"!=n&&(e="Alt-"+e),(Dl?t.metaKey:t.ctrlKey)&&"Ctrl"!=n&&(e="Ctrl-"+e),(Dl?t.ctrlKey:t.metaKey)&&"Cmd"!=n&&(e="Cmd-"+e),!r&&t.shiftKey&&"Shift"!=n&&(e="Shift-"+e),e}function ao(e,t){if(wl&&34==e.keyCode&&e.char)return!1;var r=Es[e.keyCode];return null!=r&&!e.altGraphKey&&so(r,e,t)}function uo(e){return"string"==typeof e?Rs[e]:e}function co(e,t){for(var r=e.doc.sel.ranges,n=[],i=0;i<r.length;i++){for(var o=t(r[i]);n.length&&P(o.from,g(n).to)<=0;){var l=n.pop();if(P(l.from,o.from)<0){o.from=l.from;break}}n.push(o)}hn(e,function(){for(var t=n.length-1;t>=0;t--)Ei(e.doc,"",n[t].from,n[t].to,"+delete");jr(e)})}function fo(e,t,r){var n=L(e.text,t+r,r);return n<0||n>e.text.length?null:n}function ho(e,t,r){var n=fo(e,t.ch,r);return null==n?null:new E(t.line,n,r<0?"after":"before")}function po(e,t,r,n,i){if(e){var o=Se(r,t.doc.direction);if(o){var l,s=i<0?g(o):o[0],a=i<0==(1==s.level)?"after":"before";if(s.level>0){var u=Xt(t,r);l=i<0?r.text.length-1:0;var c=Yt(t,u,l).top;l=k(function(e){return Yt(t,u,e).top==c},i<0==(1==s.level)?s.from:s.to-1,l),"before"==a&&(l=fo(r,l,1))}else l=i<0?s.to:s.from;return new E(n,l,a)}}return new E(n,i<0?r.text.length:0,i<0?"before":"after")}function go(e,t,r,n){var i=Se(t,e.doc.direction);if(!i)return ho(t,r,n);r.ch>=t.text.length?(r.ch=t.text.length,r.sticky="before"):r.ch<=0&&(r.ch=0,r.sticky="after");var o=Ce(i,r.ch,r.sticky),l=i[o];if("ltr"==e.doc.direction&&l.level%2==0&&(n>0?l.to>r.ch:l.from<r.ch))return ho(t,r,n);var s,a=function(e,r){return fo(t,e instanceof E?e.ch:e,r)},u=function(r){return e.options.lineWrapping?(s=s||Xt(e,t),hr(e,t,s,r)):{begin:0,end:t.text.length}},c=u("before"==r.sticky?a(r,-1):r.ch);if("rtl"==e.doc.direction||1==l.level){var f=1==l.level==n<0,h=a(r,f?1:-1);if(null!=h&&(f?h<=l.to&&h<=c.end:h>=l.from&&h>=c.begin)){var d=f?"before":"after";return new E(r.line,h,d)}}var p=function(e,t,n){for(var o=function(e,t){return t?new E(r.line,a(e,1),"before"):new E(r.line,e,"after")};e>=0&&e<i.length;e+=t){var l=i[e],s=t>0==(1!=l.level),u=s?n.begin:a(n.end,-1);if(l.from<=u&&u<l.to)return o(u,s);if(u=s?l.from:a(l.to,-1),n.begin<=u&&u<n.end)return o(u,s)}},g=p(o+n,n,c);if(g)return g;var v=n>0?c.end:a(c.begin,-1);return null==v||n>0&&v==t.text.length||!(g=p(n>0?0:i.length-1,n,u(v)))?null:g}function vo(e,t){var r=M(e.doc,t),n=fe(r);return n!=r&&(t=W(n)),po(!0,e,n,t,1)}function mo(e,t){var r=M(e.doc,t),n=he(r);return n!=r&&(t=W(n)),po(!0,e,r,t,-1)}function yo(e,t){var r=vo(e,t.line),n=M(e.doc,r.line),i=Se(n,e.doc.direction);if(!i||0==i[0].level){var o=Math.max(0,n.text.search(/\S/)),l=t.line==r.line&&t.ch<=o&&t.ch;return E(r.line,l?0:o,r.sticky)}return r}function bo(e,t,r){if("string"==typeof t&&!(t=Bs[t]))return!1;e.display.input.ensurePolled();var n=e.display.shift,i=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),r&&(e.display.shift=!1),i=t(e)!=Bl}finally{e.display.shift=n,e.state.suppressEdits=!1}return i}function wo(e,t,r){for(var n=0;n<e.state.keyMaps.length;n++){var i=oo(t,e.state.keyMaps[n],r,e);if(i)return i}return e.options.extraKeys&&oo(t,e.options.extraKeys,r,e)||oo(t,e.options.keyMap,r,e)}function xo(e,t,r,n){var i=e.state.keySeq;if(i){if(lo(t))return"handled";Gs.set(50,function(){e.state.keySeq==i&&(e.state.keySeq=null,e.display.input.reset())}),t=i+" "+t}var o=wo(e,t,n);return"multi"==o&&(e.state.keySeq=t),"handled"==o&&bt(e,"keyHandled",e,t,r),"handled"!=o&&"multi"!=o||(We(r),Ar(e)),i&&!o&&/\'$/.test(t)?(We(r),!0):!!o}function Co(e,t){var r=ao(t,!0);return!!r&&(t.shiftKey&&!e.state.keySeq?xo(e,"Shift-"+r,t,function(t){return bo(e,t,!0)})||xo(e,r,t,function(t){if("string"==typeof t?/^go[A-Z]/.test(t):t.motion)return bo(e,t)}):xo(e,r,t,function(t){return bo(e,t)}))}function So(e,t,r){return xo(e,"'"+r+"'",t,function(t){return bo(e,t,!0)})}function Lo(e){var t=this;if(t.curOp.focus=l(),!Me(t,e)){gl&&vl<11&&27==e.keyCode&&(e.returnValue=!1);var r=e.keyCode;t.display.shift=16==r||e.shiftKey;var n=Co(t,e);wl&&(Us=n?r:null,!n&&88==r&&!rs&&(Ml?e.metaKey:e.ctrlKey)&&t.replaceSelection("",null,"cut")),18!=r||/\bCodeMirror-crosshair\b/.test(t.display.lineDiv.className)||ko(t)}}function ko(e){function t(e){18!=e.keyCode&&e.altKey||(Fl(r,"CodeMirror-crosshair"),ke(document,"keyup",t),ke(document,"mouseover",t))}var r=e.display.lineDiv;s(r,"CodeMirror-crosshair"),Ql(document,"keyup",t),Ql(document,"mouseover",t)}function To(e){16==e.keyCode&&(this.doc.sel.shift=!1),Me(this,e)}function Mo(e){var t=this;if(!(Ft(t.display,e)||Me(t,e)||e.ctrlKey&&!e.altKey||Ml&&e.metaKey)){var r=e.keyCode,n=e.charCode;if(wl&&r==Us)return Us=null,void We(e);if(!wl||e.which&&!(e.which<10)||!Co(t,e)){var i=String.fromCharCode(null==n?r:n);"\b"!=i&&(So(t,e,i)||t.display.input.onKeyPress(e))}}}function No(e,t){var r=+new Date;return js&&js.compare(r,e,t)?(Ks=js=null,"triple"):Ks&&Ks.compare(r,e,t)?(js=new Vs(r,e,t),Ks=null,"double"):(Ks=new Vs(r,e,t),js=null,"single")}function Oo(e){var t=this,r=t.display;if(!(Me(t,e)||r.activeTouch&&r.input.supportsTouch()))if(r.input.ensurePolled(),r.shift=e.shiftKey,Ft(r,e))ml||(r.scroller.draggable=!1,setTimeout(function(){return r.scroller.draggable=!0},100));else if(!zo(t,e)){var n=Sr(t,e),i=Pe(e),o=n?No(n,i):"single";window.focus(),1==i&&t.state.selectingText&&t.state.selectingText(e),n&&Ao(t,i,n,o,e)||(1==i?n?Do(t,n,o,e):Ee(e)==r.scroller&&We(e):2==i?(n&&di(t.doc,n),setTimeout(function(){return r.input.focus()},20)):3==i&&(Hl?Ro(t,e):Dr(t)))}}function Ao(e,t,r,n,i){var o="Click";return"double"==n?o="Double"+o:"triple"==n&&(o="Triple"+o),o=(1==t?"Left":2==t?"Middle":"Right")+o,xo(e,so(o,i),i,function(t){if("string"==typeof t&&(t=Bs[t]),!t)return!1;var n=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),n=t(e,r)!=Bl}finally{e.state.suppressEdits=!1}return n})}function Wo(e,t,r){var n=e.getOption("configureMouse"),i=n?n(e,t,r):{};if(null==i.unit){var o=Nl?r.shiftKey&&r.metaKey:r.altKey;i.unit=o?"rectangle":"single"==t?"char":"double"==t?"word":"line"}return(null==i.extend||e.doc.extend)&&(i.extend=e.doc.extend||r.shiftKey),null==i.addNew&&(i.addNew=Ml?r.metaKey:r.ctrlKey),null==i.moveOnDrag&&(i.moveOnDrag=!(Ml?r.altKey:r.ctrlKey)),i}function Do(e,t,r,n){gl?setTimeout(u(Wr,e),0):e.curOp.focus=l();var i,o=Wo(e,r,n),s=e.doc.sel;e.options.dragDrop&&Jl&&!e.isReadOnly()&&"single"==r&&(i=s.contains(t))>-1&&(P((i=s.ranges[i]).from(),t)<0||t.xRel>0)&&(P(i.to(),t)>0||t.xRel<0)?Ho(e,n,t,o):Eo(e,n,t,o)}function Ho(e,t,r,n){var i=e.display,o=!1,l=dn(e,function(t){ml&&(i.scroller.draggable=!1),e.state.draggingText=!1,ke(document,"mouseup",l),ke(document,"mousemove",s),ke(i.scroller,"dragstart",a),ke(i.scroller,"drop",l),o||(We(t),n.addNew||di(e.doc,r,null,null,n.extend),ml||gl&&9==vl?setTimeout(function(){document.body.focus(),i.input.focus()},20):i.input.focus())}),s=function(e){o=o||Math.abs(t.clientX-e.clientX)+Math.abs(t.clientY-e.clientY)>=10},a=function(){return o=!0};ml&&(i.scroller.draggable=!0),e.state.draggingText=l,l.copy=!n.moveOnDrag,i.scroller.dragDrop&&i.scroller.dragDrop(),Ql(document,"mouseup",l),Ql(document,"mousemove",s),Ql(i.scroller,"dragstart",a),Ql(i.scroller,"drop",l),Dr(e),setTimeout(function(){return i.input.focus()},20)}function Fo(e,t,r){if("char"==r)return new Ts(t,t);if("word"==r)return e.findWordAt(t);if("line"==r)return new Ts(E(t.line,0),U(e.doc,E(t.line+1,0)));var n=r(e,t);return new Ts(n.from,n.to)}function Eo(e,t,r,n){function i(t){if(0!=P(m,t))if(m=t,"rectangle"==n.unit){for(var i=[],o=e.options.tabSize,l=f(M(u,r.line).text,r.ch,o),s=f(M(u,t.line).text,t.ch,o),a=Math.min(l,s),g=Math.max(l,s),v=Math.min(r.line,t.line),y=Math.min(e.lastLine(),Math.max(r.line,t.line));v<=y;v++){var b=M(u,v).text,w=d(b,a,o);a==g?i.push(new Ts(E(v,w),E(v,w))):b.length>w&&i.push(new Ts(E(v,w),E(v,d(b,g,o))))}i.length||i.push(new Ts(r,r)),bi(u,zn(p.ranges.slice(0,h).concat(i),h),{origin:"*mouse",scroll:!1}),e.scrollIntoView(t)}else{var x,C=c,S=Fo(e,t,n.unit),L=C.anchor;P(S.anchor,L)>0?(x=S.head,L=B(C.from(),S.anchor)):(x=S.anchor,L=R(C.to(),S.head));var k=p.ranges.slice(0);k[h]=Po(e,new Ts(U(u,L),x)),bi(u,zn(k,h),Ul)}}function o(t){var r=++b,s=Sr(e,t,!0,"rectangle"==n.unit);if(s)if(0!=P(s,m)){e.curOp.focus=l(),i(s);var c=Ir(a,u);(s.line>=c.to||s.line<c.from)&&setTimeout(dn(e,function(){b==r&&o(t)}),150)}else{var f=t.clientY<y.top?-20:t.clientY>y.bottom?20:0;f&&setTimeout(dn(e,function(){b==r&&(a.scroller.scrollTop+=f,o(t))}),50)}}function s(t){e.state.selectingText=!1,b=1/0,We(t),a.input.focus(),ke(document,"mousemove",w),ke(document,"mouseup",x),u.history.lastSelOrigin=null}var a=e.display,u=e.doc;We(t);var c,h,p=u.sel,g=p.ranges;if(n.addNew&&!n.extend?(h=u.sel.contains(r),c=h>-1?g[h]:new Ts(r,r)):(c=u.sel.primary(),h=u.sel.primIndex),"rectangle"==n.unit)n.addNew||(c=new Ts(r,r)),r=Sr(e,t,!0,!0),h=-1;else{var v=Fo(e,r,n.unit);c=n.extend?hi(c,v.anchor,v.head,n.extend):v}n.addNew?-1==h?(h=g.length,bi(u,zn(g.concat([c]),h),{scroll:!1,origin:"*mouse"})):g.length>1&&g[h].empty()&&"char"==n.unit&&!n.extend?(bi(u,zn(g.slice(0,h).concat(g.slice(h+1)),0),{scroll:!1,origin:"*mouse"}),p=u.sel):gi(u,h,c,Ul):(h=0,bi(u,new ks([c],0),Ul),p=u.sel);var m=r,y=a.wrapper.getBoundingClientRect(),b=0,w=dn(e,function(e){Pe(e)?o(e):s(e)}),x=dn(e,s);e.state.selectingText=x,Ql(document,"mousemove",w),Ql(document,"mouseup",x)}function Po(e,t){var r=t.anchor,n=t.head,i=M(e.doc,r.line);if(0==P(r,n)&&r.sticky==n.sticky)return t;var o=Se(i);if(!o)return t;var l=Ce(o,r.ch,r.sticky),s=o[l];if(s.from!=r.ch&&s.to!=r.ch)return t;var a=l+(s.from==r.ch==(1!=s.level)?0:1);if(0==a||a==o.length)return t;var u;if(n.line!=r.line)u=(n.line-r.line)*("ltr"==e.doc.direction?1:-1)>0;else{var c=Ce(o,n.ch,n.sticky),f=c-l||(n.ch-r.ch)*(1==s.level?-1:1);u=c==a-1||c==a?f<0:f>0}var h=o[a+(u?-1:0)],d=u==(1==h.level),p=d?h.from:h.to,g=d?"after":"before";return r.ch==p&&r.sticky==g?t:new Ts(new E(r.line,p,g),n)}function Io(e,t,r,n){var i,o;if(t.touches)i=t.touches[0].clientX,o=t.touches[0].clientY;else try{i=t.clientX,o=t.clientY}catch(t){return!1}if(i>=Math.floor(e.display.gutters.getBoundingClientRect().right))return!1;n&&We(t);var l=e.display,s=l.lineDiv.getBoundingClientRect();if(o>s.bottom||!Oe(e,r))return He(t);o-=s.top-l.viewOffset;for(var a=0;a<e.options.gutters.length;++a){var u=l.gutters.childNodes[a];if(u&&u.getBoundingClientRect().right>=i)return Te(e,r,e,D(e.doc,o),e.options.gutters[a],t),He(t)}}function zo(e,t){return Io(e,t,"gutterClick",!0)}function Ro(e,t){Ft(e.display,t)||Bo(e,t)||Me(e,t,"contextmenu")||e.display.input.onContextMenu(t)}function Bo(e,t){return!!Oe(e,"gutterContextMenu")&&Io(e,t,"gutterContextMenu",!1)}function Go(e){e.display.wrapper.className=e.display.wrapper.className.replace(/\s*cm-s-\S+/g,"")+e.options.theme.replace(/(^|\s)\s*/g," cm-s-"),er(e)}function Uo(e){Hn(e),vn(e),zr(e)}function Vo(e,t,r){if(!t!=!(r&&r!=Xs)){var n=e.display.dragFunctions,i=t?Ql:ke;i(e.display.scroller,"dragstart",n.start),i(e.display.scroller,"dragenter",n.enter),i(e.display.scroller,"dragover",n.over),i(e.display.scroller,"dragleave",n.leave),i(e.display.scroller,"drop",n.drop)}}function Ko(e){e.options.lineWrapping?(s(e.display.wrapper,"CodeMirror-wrap"),e.display.sizer.style.minWidth="",e.display.sizerWidth=null):(Fl(e.display.wrapper,"CodeMirror-wrap"),we(e)),Cr(e),vn(e),er(e),setTimeout(function(){return en(e)},100)}function jo(e,t){var r=this;if(!(this instanceof jo))return new jo(e,t);this.options=t=t?c(t):{},c(Ys,t,!1),Fn(t);var n=t.value;"string"==typeof n&&(n=new Ds(n,t.mode,null,t.lineSeparator,t.direction)),this.doc=n;var i=new jo.inputStyles[t.inputStyle](this),o=this.display=new T(e,n,i);o.wrapper.CodeMirror=this,Hn(this),Go(this),t.lineWrapping&&(this.display.wrapper.className+=" CodeMirror-wrap"),rn(this),this.state={keyMaps:[],overlays:[],modeGen:0,overwrite:!1,delayingBlurEvent:!1,focused:!1,suppressEdits:!1,pasteIncoming:!1,cutIncoming:!1,selectingText:!1,draggingText:!1,highlight:new Pl,keySeq:null,specialChars:null},t.autofocus&&!Tl&&o.input.focus(),gl&&vl<11&&setTimeout(function(){return r.display.input.reset(!0)},20),Xo(this),eo(),nn(this),this.curOp.forceUpdate=!0,qn(this,n),t.autofocus&&!Tl||this.hasFocus()?setTimeout(u(Hr,this),20):Fr(this);for(var l in _s)_s.hasOwnProperty(l)&&_s[l](r,t[l],Xs);Rr(this),t.finishInit&&t.finishInit(this);for(var s=0;s<$s.length;++s)$s[s](r);on(this),ml&&t.lineWrapping&&"optimizelegibility"==getComputedStyle(o.lineDiv).textRendering&&(o.lineDiv.style.textRendering="auto")}function Xo(e){function t(){i.activeTouch&&(o=setTimeout(function(){return i.activeTouch=null},1e3),(l=i.activeTouch).end=+new Date)}function r(e){if(1!=e.touches.length)return!1;var t=e.touches[0];return t.radiusX<=1&&t.radiusY<=1}function n(e,t){if(null==t.left)return!0;var r=t.left-e.left,n=t.top-e.top;return r*r+n*n>400}var i=e.display;Ql(i.scroller,"mousedown",dn(e,Oo)),gl&&vl<11?Ql(i.scroller,"dblclick",dn(e,function(t){if(!Me(e,t)){var r=Sr(e,t);if(r&&!zo(e,t)&&!Ft(e.display,t)){We(t);var n=e.findWordAt(r);di(e.doc,n.anchor,n.head)}}})):Ql(i.scroller,"dblclick",function(t){return Me(e,t)||We(t)}),Hl||Ql(i.scroller,"contextmenu",function(t){return Ro(e,t)});var o,l={end:0};Ql(i.scroller,"touchstart",function(t){if(!Me(e,t)&&!r(t)&&!zo(e,t)){i.input.ensurePolled(),clearTimeout(o);var n=+new Date;i.activeTouch={start:n,moved:!1,prev:n-l.end<=300?l:null},1==t.touches.length&&(i.activeTouch.left=t.touches[0].pageX,i.activeTouch.top=t.touches[0].pageY)}}),Ql(i.scroller,"touchmove",function(){i.activeTouch&&(i.activeTouch.moved=!0)}),Ql(i.scroller,"touchend",function(r){var o=i.activeTouch;if(o&&!Ft(i,r)&&null!=o.left&&!o.moved&&new Date-o.start<300){var l,s=e.coordsChar(i.activeTouch,"page");l=!o.prev||n(o,o.prev)?new Ts(s,s):!o.prev.prev||n(o,o.prev.prev)?e.findWordAt(s):new Ts(E(s.line,0),U(e.doc,E(s.line+1,0))),e.setSelection(l.anchor,l.head),e.focus(),We(r)}t()}),Ql(i.scroller,"touchcancel",t),Ql(i.scroller,"scroll",function(){i.scroller.clientHeight&&(qr(e,i.scroller.scrollTop),Qr(e,i.scroller.scrollLeft,!0),Te(e,"scroll",e))}),Ql(i.scroller,"mousewheel",function(t){return In(e,t)}),Ql(i.scroller,"DOMMouseScroll",function(t){return In(e,t)}),Ql(i.wrapper,"scroll",function(){return i.wrapper.scrollTop=i.wrapper.scrollLeft=0}),i.dragFunctions={enter:function(t){Me(e,t)||Fe(t)},over:function(t){Me(e,t)||(Zi(e,t),Fe(t))},start:function(t){return qi(e,t)},drop:dn(e,$i),leave:function(t){Me(e,t)||Qi(e)}};var s=i.input.getField();Ql(s,"keyup",function(t){return To.call(e,t)}),Ql(s,"keydown",dn(e,Lo)),Ql(s,"keypress",dn(e,Mo)),Ql(s,"focus",function(t){return Hr(e,t)}),Ql(s,"blur",function(t){return Fr(e,t)})}function Yo(e,t,r,n){var i,o=e.doc;null==r&&(r="add"),"smart"==r&&(o.mode.indent?i=$e(e,t).state:r="prev");var l=e.options.tabSize,s=M(o,t),a=f(s.text,null,l);s.stateAfter&&(s.stateAfter=null);var u,c=s.text.match(/^\s*/)[0];if(n||/\S/.test(s.text)){if("smart"==r&&((u=o.mode.indent(i,s.text.slice(c.length),s.text))==Bl||u>150)){if(!n)return;r="prev"}}else u=0,r="not";"prev"==r?u=t>o.first?f(M(o,t-1).text,null,l):0:"add"==r?u=a+e.options.indentUnit:"subtract"==r?u=a-e.options.indentUnit:"number"==typeof r&&(u=a+r),u=Math.max(0,u);var h="",d=0;if(e.options.indentWithTabs)for(var g=Math.floor(u/l);g;--g)d+=l,h+="\t";if(d<u&&(h+=p(u-d)),h!=c)return Ei(o,h,E(t,0),E(t,c.length),"+input"),s.stateAfter=null,!0;for(var v=0;v<o.sel.ranges.length;v++){var m=o.sel.ranges[v];if(m.head.line==t&&m.head.ch<c.length){var y=E(t,c.length);gi(o,v,new Ts(y,y));break}}}function _o(e){qs=e}function $o(e,t,r,n,i){var o=e.doc;e.display.shift=!1,n||(n=o.sel);var l=e.state.pasteIncoming||"paste"==i,s=es(t),a=null;if(l&&n.ranges.length>1)if(qs&&qs.text.join("\n")==t){if(n.ranges.length%qs.text.length==0){a=[];for(var u=0;u<qs.text.length;u++)a.push(o.splitLines(qs.text[u]))}}else s.length==n.ranges.length&&e.options.pasteLinesPerSelection&&(a=v(s,function(e){return[e]}));for(var c,f=n.ranges.length-1;f>=0;f--){var h=n.ranges[f],d=h.from(),p=h.to();h.empty()&&(r&&r>0?d=E(d.line,d.ch-r):e.state.overwrite&&!l?p=E(p.line,Math.min(M(o,p.line).text.length,p.ch+g(s).length)):qs&&qs.lineWise&&qs.text.join("\n")==t&&(d=p=E(d.line,0))),c=e.curOp.updateInput;var m={from:d,to:p,text:a?a[f%a.length]:s,origin:i||(l?"paste":e.state.cutIncoming?"cut":"+input")};Oi(e.doc,m),bt(e,"inputRead",e,m)}t&&!l&&Zo(e,t),jr(e),e.curOp.updateInput=c,e.curOp.typing=!0,e.state.pasteIncoming=e.state.cutIncoming=!1}function qo(e,t){var r=e.clipboardData&&e.clipboardData.getData("Text");if(r)return e.preventDefault(),t.isReadOnly()||t.options.disableInput||hn(t,function(){return $o(t,r,0,null,"paste")}),!0}function Zo(e,t){if(e.options.electricChars&&e.options.smartIndent)for(var r=e.doc.sel,n=r.ranges.length-1;n>=0;n--){var i=r.ranges[n];if(!(i.head.ch>100||n&&r.ranges[n-1].head.line==i.head.line)){var o=e.getModeAt(i.head),l=!1;if(o.electricChars){for(var s=0;s<o.electricChars.length;s++)if(t.indexOf(o.electricChars.charAt(s))>-1){l=Yo(e,i.head.line,"smart");break}}else o.electricInput&&o.electricInput.test(M(e.doc,i.head.line).text.slice(0,i.head.ch))&&(l=Yo(e,i.head.line,"smart"));l&&bt(e,"electricInput",e,i.head.line)}}}function Qo(e){for(var t=[],r=[],n=0;n<e.doc.sel.ranges.length;n++){var i=e.doc.sel.ranges[n].head.line,o={anchor:E(i,0),head:E(i+1,0)};r.push(o),t.push(e.getRange(o.anchor,o.head))}return{text:t,ranges:r}}function Jo(e,t){e.setAttribute("autocorrect","off"),e.setAttribute("autocapitalize","off"),e.setAttribute("spellcheck",!!t)}function el(){var e=n("textarea",null,null,"position: absolute; bottom: -1em; padding: 0; width: 1px; height: 1em; outline: none"),t=n("div",[e],null,"overflow: hidden; position: relative; width: 3px; height: 0px;");return ml?e.style.width="1000px":e.setAttribute("wrap","off"),Ll&&(e.style.border="1px solid black"),Jo(e),t}function tl(e,t,r,n,i){function o(){var n=t.line+r;return!(n<e.first||n>=e.first+e.size)&&(t=new E(n,t.ch,t.sticky),u=M(e,n))}function l(n){var l;if(null==(l=i?go(e.cm,u,t,r):ho(u,t,r))){if(n||!o())return!1;t=po(i,e.cm,u,t.line,r)}else t=l;return!0}var s=t,a=r,u=M(e,t.line);if("char"==n)l();else if("column"==n)l(!0);else if("word"==n||"group"==n)for(var c=null,f="group"==n,h=e.cm&&e.cm.getHelper(t,"wordChars"),d=!0;!(r<0)||l(!d);d=!1){var p=u.text.charAt(t.ch)||"\n",g=x(p,h)?"w":f&&"\n"==p?"n":!f||/\s/.test(p)?null:"p";if(!f||d||g||(g="s"),c&&c!=g){r<0&&(r=1,l(),t.sticky="after");break}if(g&&(c=g),r>0&&!l(!d))break}var v=ki(e,t,s,a,!0);return I(s,v)&&(v.hitSide=!0),v}function rl(e,t,r,n){var i,o=e.doc,l=t.left;if("page"==n){var s=Math.min(e.display.wrapper.clientHeight,window.innerHeight||document.documentElement.clientHeight),a=Math.max(s-.5*mr(e.display),3);i=(r>0?t.bottom:t.top)+r*a}else"line"==n&&(i=r>0?t.bottom+3:t.top-3);for(var u;(u=cr(e,l,i)).outside;){if(r<0?i<=0:i>=o.height){u.hitSide=!0;break}i+=5*r}return u}function nl(e,t){var r=jt(e,t.line);if(!r||r.hidden)return null;var n=M(e.doc,t.line),i=Ut(r,n,t.line),o=Se(n,e.doc.direction),l="left";o&&(l=Ce(o,t.ch)%2?"right":"left");var s=_t(i.map,t.ch,l);return s.offset="right"==s.collapse?s.end:s.start,s}function il(e){for(var t=e;t;t=t.parentNode)if(/CodeMirror-gutter-wrapper/.test(t.className))return!0;return!1}function ol(e,t){return t&&(e.bad=!0),e}function ll(e,t,r,n,i){function o(e){return function(t){return t.id==e}}function l(){c&&(u+=f,c=!1)}function s(e){e&&(l(),u+=e)}function a(t){if(1==t.nodeType){var r=t.getAttribute("cm-text");if(null!=r)return void s(r||t.textContent.replace(/\u200b/g,""));var u,h=t.getAttribute("cm-marker");if(h){var d=e.findMarks(E(n,0),E(i+1,0),o(+h));return void(d.length&&(u=d[0].find(0))&&s(N(e.doc,u.from,u.to).join(f)))}if("false"==t.getAttribute("contenteditable"))return;var p=/^(pre|div|p)$/i.test(t.nodeName);p&&l();for(var g=0;g<t.childNodes.length;g++)a(t.childNodes[g]);p&&(c=!0)}else 3==t.nodeType&&s(t.nodeValue)}for(var u="",c=!1,f=e.doc.lineSeparator();a(t),t!=r;)t=t.nextSibling;return u}function sl(e,t,r){var n;if(t==e.display.lineDiv){if(!(n=e.display.lineDiv.childNodes[r]))return ol(e.clipPos(E(e.display.viewTo-1)),!0);t=null,r=0}else for(n=t;;n=n.parentNode){if(!n||n==e.display.lineDiv)return null;if(n.parentNode&&n.parentNode==e.display.lineDiv)break}for(var i=0;i<e.display.view.length;i++){var o=e.display.view[i];if(o.node==n)return al(o,t,r)}}function al(e,t,r){function n(t,r,n){for(var i=-1;i<(f?f.length:0);i++)for(var o=i<0?c.map:f[i],l=0;l<o.length;l+=3){var s=o[l+2];if(s==t||s==r){var a=W(i<0?e.line:e.rest[i]),u=o[l]+n;return(n<0||s!=t)&&(u=o[l+(n?1:0)]),E(a,u)}}}var i=e.text.firstChild,l=!1;if(!t||!o(i,t))return ol(E(W(e.line),0),!0);if(t==i&&(l=!0,t=i.childNodes[r],r=0,!t)){var s=e.rest?g(e.rest):e.line;return ol(E(W(s),s.text.length),l)}var a=3==t.nodeType?t:null,u=t;for(a||1!=t.childNodes.length||3!=t.firstChild.nodeType||(a=t.firstChild,r&&(r=a.nodeValue.length));u.parentNode!=i;)u=u.parentNode;var c=e.measure,f=c.maps,h=n(a,u,r);if(h)return ol(h,l);for(var d=u.nextSibling,p=a?a.nodeValue.length-r:0;d;d=d.nextSibling){if(h=n(d,d.firstChild,0))return ol(E(h.line,h.ch-p),l);p+=d.textContent.length}for(var v=u.previousSibling,m=r;v;v=v.previousSibling){if(h=n(v,v.firstChild,-1))return ol(E(h.line,h.ch+m),l);m+=v.textContent.length}}var ul=navigator.userAgent,cl=navigator.platform,fl=/gecko\/\d/i.test(ul),hl=/MSIE \d/.test(ul),dl=/Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(ul),pl=/Edge\/(\d+)/.exec(ul),gl=hl||dl||pl,vl=gl&&(hl?document.documentMode||6:+(pl||dl)[1]),ml=!pl&&/WebKit\//.test(ul),yl=ml&&/Qt\/\d+\.\d+/.test(ul),bl=!pl&&/Chrome\//.test(ul),wl=/Opera\//.test(ul),xl=/Apple Computer/.test(navigator.vendor),Cl=/Mac OS X 1\d\D([8-9]|\d\d)\D/.test(ul),Sl=/PhantomJS/.test(ul),Ll=!pl&&/AppleWebKit/.test(ul)&&/Mobile\/\w+/.test(ul),kl=/Android/.test(ul),Tl=Ll||kl||/webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(ul),Ml=Ll||/Mac/.test(cl),Nl=/\bCrOS\b/.test(ul),Ol=/win/i.test(cl),Al=wl&&ul.match(/Version\/(\d*\.\d*)/);Al&&(Al=Number(Al[1])),Al&&Al>=15&&(wl=!1,ml=!0);var Wl,Dl=Ml&&(yl||wl&&(null==Al||Al<12.11)),Hl=fl||gl&&vl>=9,Fl=function(t,r){var n=t.className,i=e(r).exec(n);if(i){var o=n.slice(i.index+i[0].length);t.className=n.slice(0,i.index)+(o?i[1]+o:"")}};Wl=document.createRange?function(e,t,r,n){var i=document.createRange();return i.setEnd(n||e,r),i.setStart(e,t),i}:function(e,t,r){var n=document.body.createTextRange();try{n.moveToElementText(e.parentNode)}catch(e){return n}return n.collapse(!0),n.moveEnd("character",r),n.moveStart("character",t),n};var El=function(e){e.select()};Ll?El=function(e){e.selectionStart=0,e.selectionEnd=e.value.length}:gl&&(El=function(e){try{e.select()}catch(e){}});var Pl=function(){this.id=null};Pl.prototype.set=function(e,t){clearTimeout(this.id),this.id=setTimeout(t,e)};var Il,zl,Rl=30,Bl={toString:function(){return"CodeMirror.Pass"}},Gl={scroll:!1},Ul={origin:"*mouse"},Vl={origin:"+move"},Kl=[""],jl=/[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/,Xl=/[\u0300-\u036f\u0483-\u0489\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u065e\u0670\u06d6-\u06dc\u06de-\u06e4\u06e7\u06e8\u06ea-\u06ed\u0711\u0730-\u074a\u07a6-\u07b0\u07eb-\u07f3\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0900-\u0902\u093c\u0941-\u0948\u094d\u0951-\u0955\u0962\u0963\u0981\u09bc\u09be\u09c1-\u09c4\u09cd\u09d7\u09e2\u09e3\u0a01\u0a02\u0a3c\u0a41\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a70\u0a71\u0a75\u0a81\u0a82\u0abc\u0ac1-\u0ac5\u0ac7\u0ac8\u0acd\u0ae2\u0ae3\u0b01\u0b3c\u0b3e\u0b3f\u0b41-\u0b44\u0b4d\u0b56\u0b57\u0b62\u0b63\u0b82\u0bbe\u0bc0\u0bcd\u0bd7\u0c3e-\u0c40\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0cbc\u0cbf\u0cc2\u0cc6\u0ccc\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0d3e\u0d41-\u0d44\u0d4d\u0d57\u0d62\u0d63\u0dca\u0dcf\u0dd2-\u0dd4\u0dd6\u0ddf\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0eb1\u0eb4-\u0eb9\u0ebb\u0ebc\u0ec8-\u0ecd\u0f18\u0f19\u0f35\u0f37\u0f39\u0f71-\u0f7e\u0f80-\u0f84\u0f86\u0f87\u0f90-\u0f97\u0f99-\u0fbc\u0fc6\u102d-\u1030\u1032-\u1037\u1039\u103a\u103d\u103e\u1058\u1059\u105e-\u1060\u1071-\u1074\u1082\u1085\u1086\u108d\u109d\u135f\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b7-\u17bd\u17c6\u17c9-\u17d3\u17dd\u180b-\u180d\u18a9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193b\u1a17\u1a18\u1a56\u1a58-\u1a5e\u1a60\u1a62\u1a65-\u1a6c\u1a73-\u1a7c\u1a7f\u1b00-\u1b03\u1b34\u1b36-\u1b3a\u1b3c\u1b42\u1b6b-\u1b73\u1b80\u1b81\u1ba2-\u1ba5\u1ba8\u1ba9\u1c2c-\u1c33\u1c36\u1c37\u1cd0-\u1cd2\u1cd4-\u1ce0\u1ce2-\u1ce8\u1ced\u1dc0-\u1de6\u1dfd-\u1dff\u200c\u200d\u20d0-\u20f0\u2cef-\u2cf1\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua66f-\ua672\ua67c\ua67d\ua6f0\ua6f1\ua802\ua806\ua80b\ua825\ua826\ua8c4\ua8e0-\ua8f1\ua926-\ua92d\ua947-\ua951\ua980-\ua982\ua9b3\ua9b6-\ua9b9\ua9bc\uaa29-\uaa2e\uaa31\uaa32\uaa35\uaa36\uaa43\uaa4c\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uabe5\uabe8\uabed\udc00-\udfff\ufb1e\ufe00-\ufe0f\ufe20-\ufe26\uff9e\uff9f]/,Yl=!1,_l=!1,$l=null,ql=function(){function e(e){return e<=247?r.charAt(e):1424<=e&&e<=1524?"R":1536<=e&&e<=1785?n.charAt(e-1536):1774<=e&&e<=2220?"r":8192<=e&&e<=8203?"w":8204==e?"b":"L"}function t(e,t,r){this.level=e,this.from=t,this.to=r}var r="bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLN",n="nnnnnnNNr%%r,rNNmmmmmmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmmmnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmnNmmmmmmrrmmNmmmmrr1111111111",i=/[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/,o=/[stwN]/,l=/[LRr]/,s=/[Lb1n]/,a=/[1n]/;return function(r,n){var u="ltr"==n?"L":"R";if(0==r.length||"ltr"==n&&!i.test(r))return!1;for(var c=r.length,f=[],h=0;h<c;++h)f.push(e(r.charCodeAt(h)));for(var d=0,p=u;d<c;++d){var v=f[d];"m"==v?f[d]=p:p=v}for(var m=0,y=u;m<c;++m){var b=f[m];"1"==b&&"r"==y?f[m]="n":l.test(b)&&(y=b,"r"==b&&(f[m]="R"))}for(var w=1,x=f[0];w<c-1;++w){var C=f[w];"+"==C&&"1"==x&&"1"==f[w+1]?f[w]="1":","!=C||x!=f[w+1]||"1"!=x&&"n"!=x||(f[w]=x),x=C}for(var S=0;S<c;++S){var L=f[S];if(","==L)f[S]="N";else if("%"==L){var k=void 0;for(k=S+1;k<c&&"%"==f[k];++k);for(var T=S&&"!"==f[S-1]||k<c&&"1"==f[k]?"1":"N",M=S;M<k;++M)f[M]=T;S=k-1}}for(var N=0,O=u;N<c;++N){var A=f[N];"L"==O&&"1"==A?f[N]="L":l.test(A)&&(O=A)}for(var W=0;W<c;++W)if(o.test(f[W])){var D=void 0;for(D=W+1;D<c&&o.test(f[D]);++D);for(var H="L"==(W?f[W-1]:u),F=H==("L"==(D<c?f[D]:u))?H?"L":"R":u,E=W;E<D;++E)f[E]=F;W=D-1}for(var P,I=[],z=0;z<c;)if(s.test(f[z])){var R=z;for(++z;z<c&&s.test(f[z]);++z);I.push(new t(0,R,z))}else{var B=z,G=I.length;for(++z;z<c&&"L"!=f[z];++z);for(var U=B;U<z;)if(a.test(f[U])){B<U&&I.splice(G,0,new t(1,B,U));var V=U;for(++U;U<z&&a.test(f[U]);++U);I.splice(G,0,new t(2,V,U)),B=U}else++U;B<z&&I.splice(G,0,new t(1,B,z))}return 1==I[0].level&&(P=r.match(/^\s+/))&&(I[0].from=P[0].length,I.unshift(new t(0,0,P[0].length))),1==g(I).level&&(P=r.match(/\s+$/))&&(g(I).to-=P[0].length,I.push(new t(0,c-P[0].length,c))),"rtl"==n?I.reverse():I}}(),Zl=[],Ql=function(e,t,r){if(e.addEventListener)e.addEventListener(t,r,!1);else if(e.attachEvent)e.attachEvent("on"+t,r);else{var n=e._handlers||(e._handlers={});n[t]=(n[t]||Zl).concat(r)}},Jl=function(){if(gl&&vl<9)return!1;var e=n("div");return"draggable"in e||"dragDrop"in e}(),es=3!="\n\nb".split(/\n/).length?function(e){for(var t=0,r=[],n=e.length;t<=n;){var i=e.indexOf("\n",t);-1==i&&(i=e.length);var o=e.slice(t,"\r"==e.charAt(i-1)?i-1:i),l=o.indexOf("\r");-1!=l?(r.push(o.slice(0,l)),t+=l+1):(r.push(o),t=i+1)}return r}:function(e){return e.split(/\r\n?|\n/)},ts=window.getSelection?function(e){try{return e.selectionStart!=e.selectionEnd}catch(e){return!1}}:function(e){var t;try{t=e.ownerDocument.selection.createRange()}catch(e){}return!(!t||t.parentElement()!=e)&&0!=t.compareEndPoints("StartToEnd",t)},rs=function(){var e=n("div");return"oncopy"in e||(e.setAttribute("oncopy","return;"),"function"==typeof e.oncopy)}(),ns=null,is={},os={},ls={},ss=function(e,t,r){this.pos=this.start=0,this.string=e,this.tabSize=t||8,this.lastColumnPos=this.lastColumnValue=0,this.lineStart=0,this.lineOracle=r};ss.prototype.eol=function(){return this.pos>=this.string.length},ss.prototype.sol=function(){return this.pos==this.lineStart},ss.prototype.peek=function(){return this.string.charAt(this.pos)||void 0},ss.prototype.next=function(){if(this.pos<this.string.length)return this.string.charAt(this.pos++)},ss.prototype.eat=function(e){var t=this.string.charAt(this.pos);if("string"==typeof e?t==e:t&&(e.test?e.test(t):e(t)))return++this.pos,t},ss.prototype.eatWhile=function(e){for(var t=this.pos;this.eat(e););return this.pos>t},ss.prototype.eatSpace=function(){for(var e=this,t=this.pos;/[\s\u00a0]/.test(this.string.charAt(this.pos));)++e.pos;return this.pos>t},ss.prototype.skipToEnd=function(){this.pos=this.string.length},ss.prototype.skipTo=function(e){var t=this.string.indexOf(e,this.pos);if(t>-1)return this.pos=t,!0},ss.prototype.backUp=function(e){this.pos-=e},ss.prototype.column=function(){return this.lastColumnPos<this.start&&(this.lastColumnValue=f(this.string,this.start,this.tabSize,this.lastColumnPos,this.lastColumnValue),this.lastColumnPos=this.start),this.lastColumnValue-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.indentation=function(){return f(this.string,null,this.tabSize)-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.match=function(e,t,r){if("string"!=typeof e){var n=this.string.slice(this.pos).match(e);return n&&n.index>0?null:(n&&!1!==t&&(this.pos+=n[0].length),n)}var i=function(e){return r?e.toLowerCase():e};if(i(this.string.substr(this.pos,e.length))==i(e))return!1!==t&&(this.pos+=e.length),!0},ss.prototype.current=function(){return this.string.slice(this.start,this.pos)},ss.prototype.hideFirstChars=function(e,t){this.lineStart+=e;try{return t()}finally{this.lineStart-=e}},ss.prototype.lookAhead=function(e){var t=this.lineOracle;return t&&t.lookAhead(e)};var as=function(e,t){this.state=e,this.lookAhead=t},us=function(e,t,r,n){this.state=t,this.doc=e,this.line=r,this.maxLookAhead=n||0};us.prototype.lookAhead=function(e){var t=this.doc.getLine(this.line+e);return null!=t&&e>this.maxLookAhead&&(this.maxLookAhead=e),t},us.prototype.nextLine=function(){this.line++,this.maxLookAhead>0&&this.maxLookAhead--},us.fromSaved=function(e,t,r){return t instanceof as?new us(e,Ke(e.mode,t.state),r,t.lookAhead):new us(e,Ke(e.mode,t),r)},us.prototype.save=function(e){var t=!1!==e?Ke(this.doc.mode,this.state):this.state;return this.maxLookAhead>0?new as(t,this.maxLookAhead):t};var cs=function(e,t,r){this.start=e.start,this.end=e.pos,this.string=e.current(),this.type=t||null,this.state=r},fs=function(e,t,r){this.text=e,ne(this,t),this.height=r?r(this):1};fs.prototype.lineNo=function(){return W(this)},Ae(fs);var hs,ds={},ps={},gs=null,vs=null,ms={left:0,right:0,top:0,bottom:0},ys=function(e,t,r){this.cm=r;var i=this.vert=n("div",[n("div",null,null,"min-width: 1px")],"CodeMirror-vscrollbar"),o=this.horiz=n("div",[n("div",null,null,"height: 100%; min-height: 1px")],"CodeMirror-hscrollbar");e(i),e(o),Ql(i,"scroll",function(){i.clientHeight&&t(i.scrollTop,"vertical")}),Ql(o,"scroll",function(){o.clientWidth&&t(o.scrollLeft,"horizontal")}),this.checkedZeroWidth=!1,gl&&vl<8&&(this.horiz.style.minHeight=this.vert.style.minWidth="18px")};ys.prototype.update=function(e){var t=e.scrollWidth>e.clientWidth+1,r=e.scrollHeight>e.clientHeight+1,n=e.nativeBarWidth;if(r){this.vert.style.display="block",this.vert.style.bottom=t?n+"px":"0";var i=e.viewHeight-(t?n:0);this.vert.firstChild.style.height=Math.max(0,e.scrollHeight-e.clientHeight+i)+"px"}else this.vert.style.display="",this.vert.firstChild.style.height="0";if(t){this.horiz.style.display="block",this.horiz.style.right=r?n+"px":"0",this.horiz.style.left=e.barLeft+"px";var o=e.viewWidth-e.barLeft-(r?n:0);this.horiz.firstChild.style.width=Math.max(0,e.scrollWidth-e.clientWidth+o)+"px"}else this.horiz.style.display="",this.horiz.firstChild.style.width="0";return!this.checkedZeroWidth&&e.clientHeight>0&&(0==n&&this.zeroWidthHack(),this.checkedZeroWidth=!0),{right:r?n:0,bottom:t?n:0}},ys.prototype.setScrollLeft=function(e){this.horiz.scrollLeft!=e&&(this.horiz.scrollLeft=e),this.disableHoriz&&this.enableZeroWidthBar(this.horiz,this.disableHoriz,"horiz")},ys.prototype.setScrollTop=function(e){this.vert.scrollTop!=e&&(this.vert.scrollTop=e),this.disableVert&&this.enableZeroWidthBar(this.vert,this.disableVert,"vert")},ys.prototype.zeroWidthHack=function(){var e=Ml&&!Cl?"12px":"18px";this.horiz.style.height=this.vert.style.width=e,this.horiz.style.pointerEvents=this.vert.style.pointerEvents="none",this.disableHoriz=new Pl,this.disableVert=new Pl},ys.prototype.enableZeroWidthBar=function(e,t,r){function n(){var i=e.getBoundingClientRect();("vert"==r?document.elementFromPoint(i.right-1,(i.top+i.bottom)/2):document.elementFromPoint((i.right+i.left)/2,i.bottom-1))!=e?e.style.pointerEvents="none":t.set(1e3,n)}e.style.pointerEvents="auto",t.set(1e3,n)},ys.prototype.clear=function(){var e=this.horiz.parentNode;e.removeChild(this.horiz),e.removeChild(this.vert)};var bs=function(){};bs.prototype.update=function(){return{bottom:0,right:0}},bs.prototype.setScrollLeft=function(){},bs.prototype.setScrollTop=function(){},bs.prototype.clear=function(){};var ws={native:ys,null:bs},xs=0,Cs=function(e,t,r){var n=e.display;this.viewport=t,this.visible=Ir(n,e.doc,t),this.editorIsHidden=!n.wrapper.offsetWidth,this.wrapperHeight=n.wrapper.clientHeight,this.wrapperWidth=n.wrapper.clientWidth,this.oldDisplayWidth=Rt(e),this.force=r,this.dims=br(e),this.events=[]};Cs.prototype.signal=function(e,t){Oe(e,t)&&this.events.push(arguments)},Cs.prototype.finish=function(){for(var e=this,t=0;t<this.events.length;t++)Te.apply(null,e.events[t])};var Ss=0,Ls=null;gl?Ls=-.53:fl?Ls=15:bl?Ls=-.7:xl&&(Ls=-1/3);var ks=function(e,t){this.ranges=e,this.primIndex=t};ks.prototype.primary=function(){return this.ranges[this.primIndex]},ks.prototype.equals=function(e){var t=this;if(e==this)return!0;if(e.primIndex!=this.primIndex||e.ranges.length!=this.ranges.length)return!1;for(var r=0;r<this.ranges.length;r++){var n=t.ranges[r],i=e.ranges[r];if(!I(n.anchor,i.anchor)||!I(n.head,i.head))return!1}return!0},ks.prototype.deepCopy=function(){for(var e=this,t=[],r=0;r<this.ranges.length;r++)t[r]=new Ts(z(e.ranges[r].anchor),z(e.ranges[r].head));return new ks(t,this.primIndex)},ks.prototype.somethingSelected=function(){for(var e=this,t=0;t<this.ranges.length;t++)if(!e.ranges[t].empty())return!0;return!1},ks.prototype.contains=function(e,t){var r=this;t||(t=e);for(var n=0;n<this.ranges.length;n++){var i=r.ranges[n];if(P(t,i.from())>=0&&P(e,i.to())<=0)return n}return-1};var Ts=function(e,t){this.anchor=e,this.head=t};Ts.prototype.from=function(){return B(this.anchor,this.head)},Ts.prototype.to=function(){return R(this.anchor,this.head)},Ts.prototype.empty=function(){return this.head.line==this.anchor.line&&this.head.ch==this.anchor.ch},Bi.prototype={chunkSize:function(){return this.lines.length},removeInner:function(e,t){for(var r=this,n=e,i=e+t;n<i;++n){var o=r.lines[n];r.height-=o.height,ot(o),bt(o,"delete")}this.lines.splice(e,t)},collapse:function(e){e.push.apply(e,this.lines)},insertInner:function(e,t,r){var n=this;this.height+=r,this.lines=this.lines.slice(0,e).concat(t).concat(this.lines.slice(e));for(var i=0;i<t.length;++i)t[i].parent=n},iterN:function(e,t,r){for(var n=this,i=e+t;e<i;++e)if(r(n.lines[e]))return!0}},Gi.prototype={chunkSize:function(){return this.size},removeInner:function(e,t){var r=this;this.size-=t;for(var n=0;n<this.children.length;++n){var i=r.children[n],o=i.chunkSize();if(e<o){var l=Math.min(t,o-e),s=i.height;if(i.removeInner(e,l),r.height-=s-i.height,o==l&&(r.children.splice(n--,1),i.parent=null),0==(t-=l))break;e=0}else e-=o}if(this.size-t<25&&(this.children.length>1||!(this.children[0]instanceof Bi))){var a=[];this.collapse(a),this.children=[new Bi(a)],this.children[0].parent=this}},collapse:function(e){for(var t=this,r=0;r<this.children.length;++r)t.children[r].collapse(e)},insertInner:function(e,t,r){var n=this;this.size+=t.length,this.height+=r;for(var i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<=l){if(o.insertInner(e,t,r),o.lines&&o.lines.length>50){for(var s=o.lines.length%25+25,a=s;a<o.lines.length;){var u=new Bi(o.lines.slice(a,a+=25));o.height-=u.height,n.children.splice(++i,0,u),u.parent=n}o.lines=o.lines.slice(0,s),n.maybeSpill()}break}e-=l}},maybeSpill:function(){if(!(this.children.length<=10)){var e=this;do{var t=new Gi(e.children.splice(e.children.length-5,5));if(e.parent){e.size-=t.size,e.height-=t.height;var r=h(e.parent.children,e);e.parent.children.splice(r+1,0,t)}else{var n=new Gi(e.children);n.parent=e,e.children=[n,t],e=n}t.parent=e.parent}while(e.children.length>10);e.parent.maybeSpill()}},iterN:function(e,t,r){for(var n=this,i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<l){var s=Math.min(t,l-e);if(o.iterN(e,s,r))return!0;if(0==(t-=s))break;e=0}else e-=l}}};var Ms=function(e,t,r){var n=this;if(r)for(var i in r)r.hasOwnProperty(i)&&(n[i]=r[i]);this.doc=e,this.node=t};Ms.prototype.clear=function(){var e=this,t=this.doc.cm,r=this.line.widgets,n=this.line,i=W(n);if(null!=i&&r){for(var o=0;o<r.length;++o)r[o]==e&&r.splice(o--,1);r.length||(n.widgets=null);var l=Ht(this);A(n,Math.max(0,n.height-l)),t&&(hn(t,function(){Ui(t,n,-l),mn(t,i,"widget")}),bt(t,"lineWidgetCleared",t,this,i))}},Ms.prototype.changed=function(){var e=this,t=this.height,r=this.doc.cm,n=this.line;this.height=null;var i=Ht(this)-t;i&&(A(n,n.height+i),r&&hn(r,function(){r.curOp.forceUpdate=!0,Ui(r,n,i),bt(r,"lineWidgetChanged",r,e,W(n))}))},Ae(Ms);var Ns=0,Os=function(e,t){this.lines=[],this.type=t,this.doc=e,this.id=++Ns};Os.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){var t=this.doc.cm,r=t&&!t.curOp;if(r&&nn(t),Oe(this,"clear")){var n=this.find();n&&bt(this,"clear",n.from,n.to)}for(var i=null,o=null,l=0;l<this.lines.length;++l){var s=e.lines[l],a=_(s.markedSpans,e);t&&!e.collapsed?mn(t,W(s),"text"):t&&(null!=a.to&&(o=W(s)),null!=a.from&&(i=W(s))),s.markedSpans=$(s.markedSpans,a),null==a.from&&e.collapsed&&!ve(e.doc,s)&&t&&A(s,mr(t.display))}if(t&&this.collapsed&&!t.options.lineWrapping)for(var u=0;u<this.lines.length;++u){var c=fe(e.lines[u]),f=be(c);f>t.display.maxLineLength&&(t.display.maxLine=c,t.display.maxLineLength=f,t.display.maxLineChanged=!0)}null!=i&&t&&this.collapsed&&vn(t,i,o+1),this.lines.length=0,this.explicitlyCleared=!0,this.atomic&&this.doc.cantEdit&&(this.doc.cantEdit=!1,t&&Ci(t.doc)),t&&bt(t,"markerCleared",t,this,i,o),r&&on(t),this.parent&&this.parent.clear()}},Os.prototype.find=function(e,t){var r=this;null==e&&"bookmark"==this.type&&(e=1);for(var n,i,o=0;o<this.lines.length;++o){var l=r.lines[o],s=_(l.markedSpans,r);if(null!=s.from&&(n=E(t?l:W(l),s.from),-1==e))return n;if(null!=s.to&&(i=E(t?l:W(l),s.to),1==e))return i}return n&&{from:n,to:i}},Os.prototype.changed=function(){var e=this,t=this.find(-1,!0),r=this,n=this.doc.cm;t&&n&&hn(n,function(){var i=t.line,o=W(t.line),l=jt(n,o);if(l&&(Qt(l),n.curOp.selectionChanged=n.curOp.forceUpdate=!0),n.curOp.updateMaxLine=!0,!ve(r.doc,i)&&null!=r.height){var s=r.height;r.height=null;var a=Ht(r)-s;a&&A(i,i.height+a)}bt(n,"markerChanged",n,e)})},Os.prototype.attachLine=function(e){if(!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;t.maybeHiddenMarkers&&-1!=h(t.maybeHiddenMarkers,this)||(t.maybeUnhiddenMarkers||(t.maybeUnhiddenMarkers=[])).push(this)}this.lines.push(e)},Os.prototype.detachLine=function(e){if(this.lines.splice(h(this.lines,e),1),!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;(t.maybeHiddenMarkers||(t.maybeHiddenMarkers=[])).push(this)}},Ae(Os);var As=function(e,t){var r=this;this.markers=e,this.primary=t;for(var n=0;n<e.length;++n)e[n].parent=r};As.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){this.explicitlyCleared=!0;for(var t=0;t<this.markers.length;++t)e.markers[t].clear();bt(this,"clear")}},As.prototype.find=function(e,t){return this.primary.find(e,t)},Ae(As);var Ws=0,Ds=function(e,t,r,n,i){if(!(this instanceof Ds))return new Ds(e,t,r,n,i);null==r&&(r=0),Gi.call(this,[new Bi([new fs("",null)])]),this.first=r,this.scrollTop=this.scrollLeft=0,this.cantEdit=!1,this.cleanGeneration=1,this.modeFrontier=this.highlightFrontier=r;var o=E(r,0);this.sel=Rn(o),this.history=new Jn(null),this.id=++Ws,this.modeOption=t,this.lineSep=n,this.direction="rtl"==i?"rtl":"ltr",this.extend=!1,"string"==typeof e&&(e=this.splitLines(e)),_n(this,{from:o,to:o,text:e}),bi(this,Rn(o),Gl)};Ds.prototype=b(Gi.prototype,{constructor:Ds,iter:function(e,t,r){r?this.iterN(e-this.first,t-e,r):this.iterN(this.first,this.first+this.size,e)},insert:function(e,t){for(var r=0,n=0;n<t.length;++n)r+=t[n].height;this.insertInner(e-this.first,t,r)},remove:function(e,t){this.removeInner(e-this.first,t)},getValue:function(e){var t=O(this,this.first,this.first+this.size);return!1===e?t:t.join(e||this.lineSeparator())},setValue:gn(function(e){var t=E(this.first,0),r=this.first+this.size-1;Oi(this,{from:t,to:E(r,M(this,r).text.length),text:this.splitLines(e),origin:"setValue",full:!0},!0),this.cm&&Xr(this.cm,0,0),bi(this,Rn(t),Gl)}),replaceRange:function(e,t,r,n){Ei(this,e,t=U(this,t),r=r?U(this,r):t,n)},getRange:function(e,t,r){var n=N(this,U(this,e),U(this,t));return!1===r?n:n.join(r||this.lineSeparator())},getLine:function(e){var t=this.getLineHandle(e);return t&&t.text},getLineHandle:function(e){if(H(this,e))return M(this,e)},getLineNumber:function(e){return W(e)},getLineHandleVisualStart:function(e){return"number"==typeof e&&(e=M(this,e)),fe(e)},lineCount:function(){return this.size},firstLine:function(){return this.first},lastLine:function(){return this.first+this.size-1},clipPos:function(e){return U(this,e)},getCursor:function(e){var t=this.sel.primary();return null==e||"head"==e?t.head:"anchor"==e?t.anchor:"end"==e||"to"==e||!1===e?t.to():t.from()},listSelections:function(){return this.sel.ranges},somethingSelected:function(){return this.sel.somethingSelected()},setCursor:gn(function(e,t,r){vi(this,U(this,"number"==typeof e?E(e,t||0):e),null,r)}),setSelection:gn(function(e,t,r){vi(this,U(this,e),U(this,t||e),r)}),extendSelection:gn(function(e,t,r){di(this,U(this,e),t&&U(this,t),r)}),extendSelections:gn(function(e,t){pi(this,K(this,e),t)}),extendSelectionsBy:gn(function(e,t){pi(this,K(this,v(this.sel.ranges,e)),t)}),setSelections:gn(function(e,t,r){var n=this;if(e.length){for(var i=[],o=0;o<e.length;o++)i[o]=new Ts(U(n,e[o].anchor),U(n,e[o].head));null==t&&(t=Math.min(e.length-1,this.sel.primIndex)),bi(this,zn(i,t),r)}}),addSelection:gn(function(e,t,r){var n=this.sel.ranges.slice(0);n.push(new Ts(U(this,e),U(this,t||e))),bi(this,zn(n,n.length-1),r)}),getSelection:function(e){for(var t,r=this,n=this.sel.ranges,i=0;i<n.length;i++){var o=N(r,n[i].from(),n[i].to());t=t?t.concat(o):o}return!1===e?t:t.join(e||this.lineSeparator())},getSelections:function(e){for(var t=this,r=[],n=this.sel.ranges,i=0;i<n.length;i++){var o=N(t,n[i].from(),n[i].to());!1!==e&&(o=o.join(e||t.lineSeparator())),r[i]=o}return r},replaceSelection:function(e,t,r){for(var n=[],i=0;i<this.sel.ranges.length;i++)n[i]=e;this.replaceSelections(n,t,r||"+input")},replaceSelections:gn(function(e,t,r){for(var n=this,i=[],o=this.sel,l=0;l<o.ranges.length;l++){var s=o.ranges[l];i[l]={from:s.from(),to:s.to(),text:n.splitLines(e[l]),origin:r}}for(var a=t&&"end"!=t&&Kn(this,i,t),u=i.length-1;u>=0;u--)Oi(n,i[u]);a?yi(this,a):this.cm&&jr(this.cm)}),undo:gn(function(){Wi(this,"undo")}),redo:gn(function(){Wi(this,"redo")}),undoSelection:gn(function(){Wi(this,"undo",!0)}),redoSelection:gn(function(){Wi(this,"redo",!0)}),setExtending:function(e){this.extend=e},getExtending:function(){return this.extend},historySize:function(){for(var e=this.history,t=0,r=0,n=0;n<e.done.length;n++)e.done[n].ranges||++t;for(var i=0;i<e.undone.length;i++)e.undone[i].ranges||++r;return{undo:t,redo:r}},clearHistory:function(){this.history=new Jn(this.history.maxGeneration)},markClean:function(){this.cleanGeneration=this.changeGeneration(!0)},changeGeneration:function(e){return e&&(this.history.lastOp=this.history.lastSelOp=this.history.lastOrigin=null),this.history.generation},isClean:function(e){return this.history.generation==(e||this.cleanGeneration)},getHistory:function(){return{done:fi(this.history.done),undone:fi(this.history.undone)}},setHistory:function(e){var t=this.history=new Jn(this.history.maxGeneration);t.done=fi(e.done.slice(0),null,!0),t.undone=fi(e.undone.slice(0),null,!0)},setGutterMarker:gn(function(e,t,r){return Ri(this,e,"gutter",function(e){var n=e.gutterMarkers||(e.gutterMarkers={});return n[t]=r,!r&&C(n)&&(e.gutterMarkers=null),!0})}),clearGutter:gn(function(e){var t=this;this.iter(function(r){r.gutterMarkers&&r.gutterMarkers[e]&&Ri(t,r,"gutter",function(){return r.gutterMarkers[e]=null,C(r.gutterMarkers)&&(r.gutterMarkers=null),!0})})}),lineInfo:function(e){var t;if("number"==typeof e){if(!H(this,e))return null;if(t=e,!(e=M(this,e)))return null}else if(null==(t=W(e)))return null;return{line:t,handle:e,text:e.text,gutterMarkers:e.gutterMarkers,textClass:e.textClass,bgClass:e.bgClass,wrapClass:e.wrapClass,widgets:e.widgets}},addLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass";if(t[i]){if(e(n).test(t[i]))return!1;t[i]+=" "+n}else t[i]=n;return!0})}),removeLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass",o=t[i];if(!o)return!1;if(null==n)t[i]=null;else{var l=o.match(e(n));if(!l)return!1;var s=l.index+l[0].length;t[i]=o.slice(0,l.index)+(l.index&&s!=o.length?" ":"")+o.slice(s)||null}return!0})}),addLineWidget:gn(function(e,t,r){return Vi(this,e,t,r)}),removeLineWidget:function(e){e.clear()},markText:function(e,t,r){return Ki(this,U(this,e),U(this,t),r,r&&r.type||"range")},setBookmark:function(e,t){var r={replacedWith:t&&(null==t.nodeType?t.widget:t),insertLeft:t&&t.insertLeft,clearWhenEmpty:!1,shared:t&&t.shared,handleMouseEvents:t&&t.handleMouseEvents};return e=U(this,e),Ki(this,e,e,r,"bookmark")},findMarksAt:function(e){var t=[],r=M(this,(e=U(this,e)).line).markedSpans;if(r)for(var n=0;n<r.length;++n){var i=r[n];(null==i.from||i.from<=e.ch)&&(null==i.to||i.to>=e.ch)&&t.push(i.marker.parent||i.marker)}return t},findMarks:function(e,t,r){e=U(this,e),t=U(this,t);var n=[],i=e.line;return this.iter(e.line,t.line+1,function(o){var l=o.markedSpans;if(l)for(var s=0;s<l.length;s++){var a=l[s];null!=a.to&&i==e.line&&e.ch>=a.to||null==a.from&&i!=e.line||null!=a.from&&i==t.line&&a.from>=t.ch||r&&!r(a.marker)||n.push(a.marker.parent||a.marker)}++i}),n},getAllMarks:function(){var e=[];return this.iter(function(t){var r=t.markedSpans;if(r)for(var n=0;n<r.length;++n)null!=r[n].from&&e.push(r[n].marker)}),e},posFromIndex:function(e){var t,r=this.first,n=this.lineSeparator().length;return this.iter(function(i){var o=i.text.length+n;if(o>e)return t=e,!0;e-=o,++r}),U(this,E(r,t))},indexFromPos:function(e){var t=(e=U(this,e)).ch;if(e.line<this.first||e.ch<0)return 0;var r=this.lineSeparator().length;return this.iter(this.first,e.line,function(e){t+=e.text.length+r}),t},copy:function(e){var t=new Ds(O(this,this.first,this.first+this.size),this.modeOption,this.first,this.lineSep,this.direction);return t.scrollTop=this.scrollTop,t.scrollLeft=this.scrollLeft,t.sel=this.sel,t.extend=!1,e&&(t.history.undoDepth=this.history.undoDepth,t.setHistory(this.getHistory())),t},linkedDoc:function(e){e||(e={});var t=this.first,r=this.first+this.size;null!=e.from&&e.from>t&&(t=e.from),null!=e.to&&e.to<r&&(r=e.to);var n=new Ds(O(this,t,r),e.mode||this.modeOption,t,this.lineSep,this.direction);return e.sharedHist&&(n.history=this.history),(this.linked||(this.linked=[])).push({doc:n,sharedHist:e.sharedHist}),n.linked=[{doc:this,isParent:!0,sharedHist:e.sharedHist}],Yi(n,Xi(this)),n},unlinkDoc:function(e){var t=this;if(e instanceof jo&&(e=e.doc),this.linked)for(var r=0;r<this.linked.length;++r)if(t.linked[r].doc==e){t.linked.splice(r,1),e.unlinkDoc(t),_i(Xi(t));break}if(e.history==this.history){var n=[e.id];$n(e,function(e){return n.push(e.id)},!0),e.history=new Jn(null),e.history.done=fi(this.history.done,n),e.history.undone=fi(this.history.undone,n)}},iterLinkedDocs:function(e){$n(this,e)},getMode:function(){return this.mode},getEditor:function(){return this.cm},splitLines:function(e){return this.lineSep?e.split(this.lineSep):es(e)},lineSeparator:function(){return this.lineSep||"\n"},setDirection:gn(function(e){"rtl"!=e&&(e="ltr"),e!=this.direction&&(this.direction=e,this.iter(function(e){return e.order=null}),this.cm&&Qn(this.cm))})}),Ds.prototype.eachLine=Ds.prototype.iter;for(var Hs=0,Fs=!1,Es={3:"Enter",8:"Backspace",9:"Tab",13:"Enter",16:"Shift",17:"Ctrl",18:"Alt",19:"Pause",20:"CapsLock",27:"Esc",32:"Space",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"Left",38:"Up",39:"Right",40:"Down",44:"PrintScrn",45:"Insert",46:"Delete",59:";",61:"=",91:"Mod",92:"Mod",93:"Mod",106:"*",107:"=",109:"-",110:".",111:"/",127:"Delete",173:"-",186:";",187:"=",188:",",189:"-",190:".",191:"/",192:"`",219:"[",220:"\\",221:"]",222:"'",63232:"Up",63233:"Down",63234:"Left",63235:"Right",63272:"Delete",63273:"Home",63275:"End",63276:"PageUp",63277:"PageDown",63302:"Insert"},Ps=0;Ps<10;Ps++)Es[Ps+48]=Es[Ps+96]=String(Ps);for(var Is=65;Is<=90;Is++)Es[Is]=String.fromCharCode(Is);for(var zs=1;zs<=12;zs++)Es[zs+111]=Es[zs+63235]="F"+zs;var Rs={};Rs.basic={Left:"goCharLeft",Right:"goCharRight",Up:"goLineUp",Down:"goLineDown",End:"goLineEnd",Home:"goLineStartSmart",PageUp:"goPageUp",PageDown:"goPageDown",Delete:"delCharAfter",Backspace:"delCharBefore","Shift-Backspace":"delCharBefore",Tab:"defaultTab","Shift-Tab":"indentAuto",Enter:"newlineAndIndent",Insert:"toggleOverwrite",Esc:"singleSelection"},Rs.pcDefault={"Ctrl-A":"selectAll","Ctrl-D":"deleteLine","Ctrl-Z":"undo","Shift-Ctrl-Z":"redo","Ctrl-Y":"redo","Ctrl-Home":"goDocStart","Ctrl-End":"goDocEnd","Ctrl-Up":"goLineUp","Ctrl-Down":"goLineDown","Ctrl-Left":"goGroupLeft","Ctrl-Right":"goGroupRight","Alt-Left":"goLineStart","Alt-Right":"goLineEnd","Ctrl-Backspace":"delGroupBefore","Ctrl-Delete":"delGroupAfter","Ctrl-S":"save","Ctrl-F":"find","Ctrl-G":"findNext","Shift-Ctrl-G":"findPrev","Shift-Ctrl-F":"replace","Shift-Ctrl-R":"replaceAll","Ctrl-[":"indentLess","Ctrl-]":"indentMore","Ctrl-U":"undoSelection","Shift-Ctrl-U":"redoSelection","Alt-U":"redoSelection",fallthrough:"basic"},Rs.emacsy={"Ctrl-F":"goCharRight","Ctrl-B":"goCharLeft","Ctrl-P":"goLineUp","Ctrl-N":"goLineDown","Alt-F":"goWordRight","Alt-B":"goWordLeft","Ctrl-A":"goLineStart","Ctrl-E":"goLineEnd","Ctrl-V":"goPageDown","Shift-Ctrl-V":"goPageUp","Ctrl-D":"delCharAfter","Ctrl-H":"delCharBefore","Alt-D":"delWordAfter","Alt-Backspace":"delWordBefore","Ctrl-K":"killLine","Ctrl-T":"transposeChars","Ctrl-O":"openLine"},Rs.macDefault={"Cmd-A":"selectAll","Cmd-D":"deleteLine","Cmd-Z":"undo","Shift-Cmd-Z":"redo","Cmd-Y":"redo","Cmd-Home":"goDocStart","Cmd-Up":"goDocStart","Cmd-End":"goDocEnd","Cmd-Down":"goDocEnd","Alt-Left":"goGroupLeft","Alt-Right":"goGroupRight","Cmd-Left":"goLineLeft","Cmd-Right":"goLineRight","Alt-Backspace":"delGroupBefore","Ctrl-Alt-Backspace":"delGroupAfter","Alt-Delete":"delGroupAfter","Cmd-S":"save","Cmd-F":"find","Cmd-G":"findNext","Shift-Cmd-G":"findPrev","Cmd-Alt-F":"replace","Shift-Cmd-Alt-F":"replaceAll","Cmd-[":"indentLess","Cmd-]":"indentMore","Cmd-Backspace":"delWrappedLineLeft","Cmd-Delete":"delWrappedLineRight","Cmd-U":"undoSelection","Shift-Cmd-U":"redoSelection","Ctrl-Up":"goDocStart","Ctrl-Down":"goDocEnd",fallthrough:["basic","emacsy"]},Rs.default=Ml?Rs.macDefault:Rs.pcDefault;var Bs={selectAll:Mi,singleSelection:function(e){return e.setSelection(e.getCursor("anchor"),e.getCursor("head"),Gl)},killLine:function(e){return co(e,function(t){if(t.empty()){var r=M(e.doc,t.head.line).text.length;return t.head.ch==r&&t.head.line<e.lastLine()?{from:t.head,to:E(t.head.line+1,0)}:{from:t.head,to:E(t.head.line,r)}}return{from:t.from(),to:t.to()}})},deleteLine:function(e){return co(e,function(t){return{from:E(t.from().line,0),to:U(e.doc,E(t.to().line+1,0))}})},delLineLeft:function(e){return co(e,function(e){return{from:E(e.from().line,0),to:e.from()}})},delWrappedLineLeft:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5;return{from:e.coordsChar({left:0,top:r},"div"),to:t.from()}})},delWrappedLineRight:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5,n=e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div");return{from:t.from(),to:n}})},undo:function(e){return e.undo()},redo:function(e){return e.redo()},undoSelection:function(e){return e.undoSelection()},redoSelection:function(e){return e.redoSelection()},goDocStart:function(e){return e.extendSelection(E(e.firstLine(),0))},goDocEnd:function(e){return e.extendSelection(E(e.lastLine()))},goLineStart:function(e){return e.extendSelectionsBy(function(t){return vo(e,t.head.line)},{origin:"+move",bias:1})},goLineStartSmart:function(e){return e.extendSelectionsBy(function(t){return yo(e,t.head)},{origin:"+move",bias:1})},goLineEnd:function(e){return e.extendSelectionsBy(function(t){return mo(e,t.head.line)},{origin:"+move",bias:-1})},goLineRight:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div")},Vl)},goLineLeft:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:0,top:r},"div")},Vl)},goLineLeftSmart:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5,n=e.coordsChar({left:0,top:r},"div");return n.ch<e.getLine(n.line).search(/\S/)?yo(e,t.head):n},Vl)},goLineUp:function(e){return e.moveV(-1,"line")},goLineDown:function(e){return e.moveV(1,"line")},goPageUp:function(e){return e.moveV(-1,"page")},goPageDown:function(e){return e.moveV(1,"page")},goCharLeft:function(e){return e.moveH(-1,"char")},goCharRight:function(e){return e.moveH(1,"char")},goColumnLeft:function(e){return e.moveH(-1,"column")},goColumnRight:function(e){return e.moveH(1,"column")},goWordLeft:function(e){return e.moveH(-1,"word")},goGroupRight:function(e){return e.moveH(1,"group")},goGroupLeft:function(e){return e.moveH(-1,"group")},goWordRight:function(e){return e.moveH(1,"word")},delCharBefore:function(e){return e.deleteH(-1,"char")},delCharAfter:function(e){return e.deleteH(1,"char")},delWordBefore:function(e){return e.deleteH(-1,"word")},delWordAfter:function(e){return e.deleteH(1,"word")},delGroupBefore:function(e){return e.deleteH(-1,"group")},delGroupAfter:function(e){return e.deleteH(1,"group")},indentAuto:function(e){return e.indentSelection("smart")},indentMore:function(e){return e.indentSelection("add")},indentLess:function(e){return e.indentSelection("subtract")},insertTab:function(e){return e.replaceSelection("\t")},insertSoftTab:function(e){for(var t=[],r=e.listSelections(),n=e.options.tabSize,i=0;i<r.length;i++){var o=r[i].from(),l=f(e.getLine(o.line),o.ch,n);t.push(p(n-l%n))}e.replaceSelections(t)},defaultTab:function(e){e.somethingSelected()?e.indentSelection("add"):e.execCommand("insertTab")},transposeChars:function(e){return hn(e,function(){for(var t=e.listSelections(),r=[],n=0;n<t.length;n++)if(t[n].empty()){var i=t[n].head,o=M(e.doc,i.line).text;if(o)if(i.ch==o.length&&(i=new E(i.line,i.ch-1)),i.ch>0)i=new E(i.line,i.ch+1),e.replaceRange(o.charAt(i.ch-1)+o.charAt(i.ch-2),E(i.line,i.ch-2),i,"+transpose");else if(i.line>e.doc.first){var l=M(e.doc,i.line-1).text;l&&(i=new E(i.line,1),e.replaceRange(o.charAt(0)+e.doc.lineSeparator()+l.charAt(l.length-1),E(i.line-1,l.length-1),i,"+transpose"))}r.push(new Ts(i,i))}e.setSelections(r)})},newlineAndIndent:function(e){return hn(e,function(){for(var t=e.listSelections(),r=t.length-1;r>=0;r--)e.replaceRange(e.doc.lineSeparator(),t[r].anchor,t[r].head,"+input");t=e.listSelections();for(var n=0;n<t.length;n++)e.indentLine(t[n].from().line,null,!0);jr(e)})},openLine:function(e){return e.replaceSelection("\n","start")},toggleOverwrite:function(e){return e.toggleOverwrite()}},Gs=new Pl,Us=null,Vs=function(e,t,r){this.time=e,this.pos=t,this.button=r};Vs.prototype.compare=function(e,t,r){return this.time+400>e&&0==P(t,this.pos)&&r==this.button};var Ks,js,Xs={toString:function(){return"CodeMirror.Init"}},Ys={},_s={};jo.defaults=Ys,jo.optionHandlers=_s;var $s=[];jo.defineInitHook=function(e){return $s.push(e)};var qs=null,Zs=function(e){this.cm=e,this.lastAnchorNode=this.lastAnchorOffset=this.lastFocusNode=this.lastFocusOffset=null,this.polling=new Pl,this.composing=null,this.gracePeriod=!1,this.readDOMTimeout=null};Zs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()}),"cut"==e.type&&i.replaceSelection("",null,"cut");else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type&&i.operation(function(){i.setSelections(t.ranges,0,Gl),i.replaceSelection("",null,"cut")})}if(e.clipboardData){e.clipboardData.clearData();var r=qs.text.join("\n");if(e.clipboardData.setData("Text",r),e.clipboardData.getData("Text")==r)return void e.preventDefault()}var l=el(),s=l.firstChild;i.display.lineSpace.insertBefore(l,i.display.lineSpace.firstChild),s.value=qs.text.join("\n");var a=document.activeElement;El(s),setTimeout(function(){i.display.lineSpace.removeChild(l),a.focus(),a==o&&n.showPrimarySelection()},50)}}var r=this,n=this,i=n.cm,o=n.div=e.lineDiv;Jo(o,i.options.spellcheck),Ql(o,"paste",function(e){Me(i,e)||qo(e,i)||vl<=11&&setTimeout(dn(i,function(){return r.updateFromDOM()}),20)}),Ql(o,"compositionstart",function(e){r.composing={data:e.data,done:!1}}),Ql(o,"compositionupdate",function(e){r.composing||(r.composing={data:e.data,done:!1})}),Ql(o,"compositionend",function(e){r.composing&&(e.data!=r.composing.data&&r.readFromDOMSoon(),r.composing.done=!0)}),Ql(o,"touchstart",function(){return n.forceCompositionEnd()}),Ql(o,"input",function(){r.composing||r.readFromDOMSoon()}),Ql(o,"copy",t),Ql(o,"cut",t)},Zs.prototype.prepareSelection=function(){var e=Tr(this.cm,!1);return e.focus=this.cm.state.focused,e},Zs.prototype.showSelection=function(e,t){e&&this.cm.display.view.length&&((e.focus||t)&&this.showPrimarySelection(),this.showMultipleSelections(e))},Zs.prototype.showPrimarySelection=function(){var e=window.getSelection(),t=this.cm,r=t.doc.sel.primary(),n=r.from(),i=r.to();if(t.display.viewTo==t.display.viewFrom||n.line>=t.display.viewTo||i.line<t.display.viewFrom)e.removeAllRanges();else{var o=sl(t,e.anchorNode,e.anchorOffset),l=sl(t,e.focusNode,e.focusOffset);if(!o||o.bad||!l||l.bad||0!=P(B(o,l),n)||0!=P(R(o,l),i)){var s=t.display.view,a=n.line>=t.display.viewFrom&&nl(t,n)||{node:s[0].measure.map[2],offset:0},u=i.line<t.display.viewTo&&nl(t,i);if(!u){var c=s[s.length-1].measure,f=c.maps?c.maps[c.maps.length-1]:c.map;u={node:f[f.length-1],offset:f[f.length-2]-f[f.length-3]}}if(a&&u){var h,d=e.rangeCount&&e.getRangeAt(0);try{h=Wl(a.node,a.offset,u.offset,u.node)}catch(e){}h&&(!fl&&t.state.focused?(e.collapse(a.node,a.offset),h.collapsed||(e.removeAllRanges(),e.addRange(h))):(e.removeAllRanges(),e.addRange(h)),d&&null==e.anchorNode?e.addRange(d):fl&&this.startGracePeriod()),this.rememberSelection()}else e.removeAllRanges()}}},Zs.prototype.startGracePeriod=function(){var e=this;clearTimeout(this.gracePeriod),this.gracePeriod=setTimeout(function(){e.gracePeriod=!1,e.selectionChanged()&&e.cm.operation(function(){return e.cm.curOp.selectionChanged=!0})},20)},Zs.prototype.showMultipleSelections=function(e){r(this.cm.display.cursorDiv,e.cursors),r(this.cm.display.selectionDiv,e.selection)},Zs.prototype.rememberSelection=function(){var e=window.getSelection();this.lastAnchorNode=e.anchorNode,this.lastAnchorOffset=e.anchorOffset,this.lastFocusNode=e.focusNode,this.lastFocusOffset=e.focusOffset},Zs.prototype.selectionInEditor=function(){var e=window.getSelection();if(!e.rangeCount)return!1;var t=e.getRangeAt(0).commonAncestorContainer;return o(this.div,t)},Zs.prototype.focus=function(){"nocursor"!=this.cm.options.readOnly&&(this.selectionInEditor()||this.showSelection(this.prepareSelection(),!0),this.div.focus())},Zs.prototype.blur=function(){this.div.blur()},Zs.prototype.getField=function(){return this.div},Zs.prototype.supportsTouch=function(){return!0},Zs.prototype.receivedFocus=function(){function e(){t.cm.state.focused&&(t.pollSelection(),t.polling.set(t.cm.options.pollInterval,e))}var t=this;this.selectionInEditor()?this.pollSelection():hn(this.cm,function(){return t.cm.curOp.selectionChanged=!0}),this.polling.set(this.cm.options.pollInterval,e)},Zs.prototype.selectionChanged=function(){var e=window.getSelection();return e.anchorNode!=this.lastAnchorNode||e.anchorOffset!=this.lastAnchorOffset||e.focusNode!=this.lastFocusNode||e.focusOffset!=this.lastFocusOffset},Zs.prototype.pollSelection=function(){if(null==this.readDOMTimeout&&!this.gracePeriod&&this.selectionChanged()){var e=window.getSelection(),t=this.cm;if(kl&&bl&&this.cm.options.gutters.length&&il(e.anchorNode))return this.cm.triggerOnKeyDown({type:"keydown",keyCode:8,preventDefault:Math.abs}),this.blur(),void this.focus();if(!this.composing){this.rememberSelection();var r=sl(t,e.anchorNode,e.anchorOffset),n=sl(t,e.focusNode,e.focusOffset);r&&n&&hn(t,function(){bi(t.doc,Rn(r,n),Gl),(r.bad||n.bad)&&(t.curOp.selectionChanged=!0)})}}},Zs.prototype.pollContent=function(){null!=this.readDOMTimeout&&(clearTimeout(this.readDOMTimeout),this.readDOMTimeout=null);var e=this.cm,t=e.display,r=e.doc.sel.primary(),n=r.from(),i=r.to();if(0==n.ch&&n.line>e.firstLine()&&(n=E(n.line-1,M(e.doc,n.line-1).length)),i.ch==M(e.doc,i.line).text.length&&i.line<e.lastLine()&&(i=E(i.line+1,0)),n.line<t.viewFrom||i.line>t.viewTo-1)return!1;var o,l,s;n.line==t.viewFrom||0==(o=Lr(e,n.line))?(l=W(t.view[0].line),s=t.view[0].node):(l=W(t.view[o].line),s=t.view[o-1].node.nextSibling);var a,u,c=Lr(e,i.line);if(c==t.view.length-1?(a=t.viewTo-1,u=t.lineDiv.lastChild):(a=W(t.view[c+1].line)-1,u=t.view[c+1].node.previousSibling),!s)return!1;for(var f=e.doc.splitLines(ll(e,s,u,l,a)),h=N(e.doc,E(l,0),E(a,M(e.doc,a).text.length));f.length>1&&h.length>1;)if(g(f)==g(h))f.pop(),h.pop(),a--;else{if(f[0]!=h[0])break;f.shift(),h.shift(),l++}for(var d=0,p=0,v=f[0],m=h[0],y=Math.min(v.length,m.length);d<y&&v.charCodeAt(d)==m.charCodeAt(d);)++d;for(var b=g(f),w=g(h),x=Math.min(b.length-(1==f.length?d:0),w.length-(1==h.length?d:0));p<x&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)++p;if(1==f.length&&1==h.length&&l==n.line)for(;d&&d>n.ch&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)d--,p++;f[f.length-1]=b.slice(0,b.length-p).replace(/^\u200b+/,""),f[0]=f[0].slice(d).replace(/\u200b+$/,"");var C=E(l,d),S=E(a,h.length?g(h).length-p:0);return f.length>1||f[0]||P(C,S)?(Ei(e.doc,f,C,S,"+input"),!0):void 0},Zs.prototype.ensurePolled=function(){this.forceCompositionEnd()},Zs.prototype.reset=function(){this.forceCompositionEnd()},Zs.prototype.forceCompositionEnd=function(){this.composing&&(clearTimeout(this.readDOMTimeout),this.composing=null,this.updateFromDOM(),this.div.blur(),this.div.focus())},Zs.prototype.readFromDOMSoon=function(){var e=this;null==this.readDOMTimeout&&(this.readDOMTimeout=setTimeout(function(){if(e.readDOMTimeout=null,e.composing){if(!e.composing.done)return;e.composing=null}e.updateFromDOM()},80))},Zs.prototype.updateFromDOM=function(){var e=this;!this.cm.isReadOnly()&&this.pollContent()||hn(this.cm,function(){return vn(e.cm)})},Zs.prototype.setUneditable=function(e){e.contentEditable="false"},Zs.prototype.onKeyPress=function(e){0!=e.charCode&&(e.preventDefault(),this.cm.isReadOnly()||dn(this.cm,$o)(this.cm,String.fromCharCode(null==e.charCode?e.keyCode:e.charCode),0))},Zs.prototype.readOnlyChanged=function(e){this.div.contentEditable=String("nocursor"!=e)},Zs.prototype.onContextMenu=function(){},Zs.prototype.resetPosition=function(){},Zs.prototype.needsContentAttribute=!0;var Qs=function(e){this.cm=e,this.prevInput="",this.pollingFast=!1,this.polling=new Pl,this.hasSelection=!1,this.composing=null};Qs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()});else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type?i.setSelections(t.ranges,null,Gl):(n.prevInput="",l.value=t.text.join("\n"),El(l))}"cut"==e.type&&(i.state.cutIncoming=!0)}}var r=this,n=this,i=this.cm,o=this.wrapper=el(),l=this.textarea=o.firstChild;e.wrapper.insertBefore(o,e.wrapper.firstChild),Ll&&(l.style.width="0px"),Ql(l,"input",function(){gl&&vl>=9&&r.hasSelection&&(r.hasSelection=null),n.poll()}),Ql(l,"paste",function(e){Me(i,e)||qo(e,i)||(i.state.pasteIncoming=!0,n.fastPoll())}),Ql(l,"cut",t),Ql(l,"copy",t),Ql(e.scroller,"paste",function(t){Ft(e,t)||Me(i,t)||(i.state.pasteIncoming=!0,n.focus())}),Ql(e.lineSpace,"selectstart",function(t){Ft(e,t)||We(t)}),Ql(l,"compositionstart",function(){var e=i.getCursor("from");n.composing&&n.composing.range.clear(),n.composing={start:e,range:i.markText(e,i.getCursor("to"),{className:"CodeMirror-composing"})}}),Ql(l,"compositionend",function(){n.composing&&(n.poll(),n.composing.range.clear(),n.composing=null)})},Qs.prototype.prepareSelection=function(){var e=this.cm,t=e.display,r=e.doc,n=Tr(e);if(e.options.moveInputWithCursor){var i=sr(e,r.sel.primary().head,"div"),o=t.wrapper.getBoundingClientRect(),l=t.lineDiv.getBoundingClientRect();n.teTop=Math.max(0,Math.min(t.wrapper.clientHeight-10,i.top+l.top-o.top)),n.teLeft=Math.max(0,Math.min(t.wrapper.clientWidth-10,i.left+l.left-o.left))}return n},Qs.prototype.showSelection=function(e){var t=this.cm.display;r(t.cursorDiv,e.cursors),r(t.selectionDiv,e.selection),null!=e.teTop&&(this.wrapper.style.top=e.teTop+"px",this.wrapper.style.left=e.teLeft+"px")},Qs.prototype.reset=function(e){if(!this.contextMenuPending&&!this.composing){var t=this.cm;if(t.somethingSelected()){this.prevInput="";var r=t.getSelection();this.textarea.value=r,t.state.focused&&El(this.textarea),gl&&vl>=9&&(this.hasSelection=r)}else e||(this.prevInput=this.textarea.value="",gl&&vl>=9&&(this.hasSelection=null))}},Qs.prototype.getField=function(){return this.textarea},Qs.prototype.supportsTouch=function(){return!1},Qs.prototype.focus=function(){if("nocursor"!=this.cm.options.readOnly&&(!Tl||l()!=this.textarea))try{this.textarea.focus()}catch(e){}},Qs.prototype.blur=function(){this.textarea.blur()},Qs.prototype.resetPosition=function(){this.wrapper.style.top=this.wrapper.style.left=0},Qs.prototype.receivedFocus=function(){this.slowPoll()},Qs.prototype.slowPoll=function(){var e=this;this.pollingFast||this.polling.set(this.cm.options.pollInterval,function(){e.poll(),e.cm.state.focused&&e.slowPoll()})},Qs.prototype.fastPoll=function(){function e(){r.poll()||t?(r.pollingFast=!1,r.slowPoll()):(t=!0,r.polling.set(60,e))}var t=!1,r=this;r.pollingFast=!0,r.polling.set(20,e)},Qs.prototype.poll=function(){var e=this,t=this.cm,r=this.textarea,n=this.prevInput;if(this.contextMenuPending||!t.state.focused||ts(r)&&!n&&!this.composing||t.isReadOnly()||t.options.disableInput||t.state.keySeq)return!1;var i=r.value;if(i==n&&!t.somethingSelected())return!1;if(gl&&vl>=9&&this.hasSelection===i||Ml&&/[\uf700-\uf7ff]/.test(i))return t.display.input.reset(),!1;if(t.doc.sel==t.display.selForContextMenu){var o=i.charCodeAt(0);if(8203!=o||n||(n="​"),8666==o)return this.reset(),this.cm.execCommand("undo")}for(var l=0,s=Math.min(n.length,i.length);l<s&&n.charCodeAt(l)==i.charCodeAt(l);)++l;return hn(t,function(){$o(t,i.slice(l),n.length-l,null,e.composing?"*compose":null),i.length>1e3||i.indexOf("\n")>-1?r.value=e.prevInput="":e.prevInput=i,e.composing&&(e.composing.range.clear(),e.composing.range=t.markText(e.composing.start,t.getCursor("to"),{className:"CodeMirror-composing"}))}),!0},Qs.prototype.ensurePolled=function(){this.pollingFast&&this.poll()&&(this.pollingFast=!1)},Qs.prototype.onKeyPress=function(){gl&&vl>=9&&(this.hasSelection=null),this.fastPoll()},Qs.prototype.onContextMenu=function(e){function t(){if(null!=l.selectionStart){var e=i.somethingSelected(),t="​"+(e?l.value:"");l.value="⇚",l.value=t,n.prevInput=e?"":"​",l.selectionStart=1,l.selectionEnd=t.length,o.selForContextMenu=i.doc.sel}}function r(){if(n.contextMenuPending=!1,n.wrapper.style.cssText=c,l.style.cssText=u,gl&&vl<9&&o.scrollbars.setScrollTop(o.scroller.scrollTop=a),null!=l.selectionStart){(!gl||gl&&vl<9)&&t();var e=0,r=function(){o.selForContextMenu==i.doc.sel&&0==l.selectionStart&&l.selectionEnd>0&&"​"==n.prevInput?dn(i,Mi)(i):e++<10?o.detectingSelectAll=setTimeout(r,500):(o.selForContextMenu=null,o.input.reset())};o.detectingSelectAll=setTimeout(r,200)}}var n=this,i=n.cm,o=i.display,l=n.textarea,s=Sr(i,e),a=o.scroller.scrollTop;if(s&&!wl){i.options.resetSelectionOnContextMenu&&-1==i.doc.sel.contains(s)&&dn(i,bi)(i.doc,Rn(s),Gl);var u=l.style.cssText,c=n.wrapper.style.cssText;n.wrapper.style.cssText="position: absolute";var f=n.wrapper.getBoundingClientRect();l.style.cssText="position: absolute; width: 30px; height: 30px;\n      top: "+(e.clientY-f.top-5)+"px; left: "+(e.clientX-f.left-5)+"px;\n      z-index: 1000; background: "+(gl?"rgba(255, 255, 255, .05)":"transparent")+";\n      outline: none; border-width: 0; outline: none; overflow: hidden; opacity: .05; filter: alpha(opacity=5);";var h;if(ml&&(h=window.scrollY),o.input.focus(),ml&&window.scrollTo(null,h),o.input.reset(),i.somethingSelected()||(l.value=n.prevInput=" "),n.contextMenuPending=!0,o.selForContextMenu=i.doc.sel,clearTimeout(o.detectingSelectAll),gl&&vl>=9&&t(),Hl){Fe(e);var d=function(){ke(window,"mouseup",d),setTimeout(r,20)};Ql(window,"mouseup",d)}else setTimeout(r,50)}},Qs.prototype.readOnlyChanged=function(e){e||this.reset(),this.textarea.disabled="nocursor"==e},Qs.prototype.setUneditable=function(){},Qs.prototype.needsContentAttribute=!1,function(e){function t(t,n,i,o){e.defaults[t]=n,i&&(r[t]=o?function(e,t,r){r!=Xs&&i(e,t,r)}:i)}var r=e.optionHandlers;e.defineOption=t,e.Init=Xs,t("value","",function(e,t){return e.setValue(t)},!0),t("mode",null,function(e,t){e.doc.modeOption=t,jn(e)},!0),t("indentUnit",2,jn,!0),t("indentWithTabs",!1),t("smartIndent",!0),t("tabSize",4,function(e){Xn(e),er(e),vn(e)},!0),t("lineSeparator",null,function(e,t){if(e.doc.lineSep=t,t){var r=[],n=e.doc.first;e.doc.iter(function(e){for(var i=0;;){var o=e.text.indexOf(t,i);if(-1==o)break;i=o+t.length,r.push(E(n,o))}n++});for(var i=r.length-1;i>=0;i--)Ei(e.doc,t,r[i],E(r[i].line,r[i].ch+t.length))}}),t("specialChars",/[\u0000-\u001f\u007f-\u009f\u00ad\u061c\u200b-\u200f\u2028\u2029\ufeff]/g,function(e,t,r){e.state.specialChars=new RegExp(t.source+(t.test("\t")?"":"|\t"),"g"),r!=Xs&&e.refresh()}),t("specialCharPlaceholder",at,function(e){return e.refresh()},!0),t("electricChars",!0),t("inputStyle",Tl?"contenteditable":"textarea",function(){throw new Error("inputStyle can not (yet) be changed in a running editor")},!0),t("spellcheck",!1,function(e,t){return e.getInputField().spellcheck=t},!0),t("rtlMoveVisually",!Ol),t("wholeLineUpdateBefore",!0),t("theme","default",function(e){Go(e),Uo(e)},!0),t("keyMap","default",function(e,t,r){var n=uo(t),i=r!=Xs&&uo(r);i&&i.detach&&i.detach(e,n),n.attach&&n.attach(e,i||null)}),t("extraKeys",null),t("configureMouse",null),t("lineWrapping",!1,Ko,!0),t("gutters",[],function(e){Fn(e.options),Uo(e)},!0),t("fixedGutter",!0,function(e,t){e.display.gutters.style.left=t?wr(e.display)+"px":"0",e.refresh()},!0),t("coverGutterNextToScrollbar",!1,function(e){return en(e)},!0),t("scrollbarStyle","native",function(e){rn(e),en(e),e.display.scrollbars.setScrollTop(e.doc.scrollTop),e.display.scrollbars.setScrollLeft(e.doc.scrollLeft)},!0),t("lineNumbers",!1,function(e){Fn(e.options),Uo(e)},!0),t("firstLineNumber",1,Uo,!0),t("lineNumberFormatter",function(e){return e},Uo,!0),t("showCursorWhenSelecting",!1,kr,!0),t("resetSelectionOnContextMenu",!0),t("lineWiseCopyCut",!0),t("pasteLinesPerSelection",!0),t("readOnly",!1,function(e,t){"nocursor"==t&&(Fr(e),e.display.input.blur()),e.display.input.readOnlyChanged(t)}),t("disableInput",!1,function(e,t){t||e.display.input.reset()},!0),t("dragDrop",!0,Vo),t("allowDropFileTypes",null),t("cursorBlinkRate",530),t("cursorScrollMargin",0),t("cursorHeight",1,kr,!0),t("singleCursorHeightPerLine",!0,kr,!0),t("workTime",100),t("workDelay",100),t("flattenSpans",!0,Xn,!0),t("addModeClass",!1,Xn,!0),t("pollInterval",100),t("undoDepth",200,function(e,t){return e.doc.history.undoDepth=t}),t("historyEventDelay",1250),t("viewportMargin",10,function(e){return e.refresh()},!0),t("maxHighlightLength",1e4,Xn,!0),t("moveInputWithCursor",!0,function(e,t){t||e.display.input.resetPosition()}),t("tabindex",null,function(e,t){return e.display.input.getField().tabIndex=t||""}),t("autofocus",null),t("direction","ltr",function(e,t){return e.doc.setDirection(t)},!0)}(jo),function(e){var t=e.optionHandlers,r=e.helpers={};e.prototype={constructor:e,focus:function(){window.focus(),this.display.input.focus()},setOption:function(e,r){var n=this.options,i=n[e];n[e]==r&&"mode"!=e||(n[e]=r,t.hasOwnProperty(e)&&dn(this,t[e])(this,r,i),Te(this,"optionChange",this,e))},getOption:function(e){return this.options[e]},getDoc:function(){return this.doc},addKeyMap:function(e,t){this.state.keyMaps[t?"push":"unshift"](uo(e))},removeKeyMap:function(e){for(var t=this.state.keyMaps,r=0;r<t.length;++r)if(t[r]==e||t[r].name==e)return t.splice(r,1),!0},addOverlay:pn(function(t,r){var n=t.token?t:e.getMode(this.options,t);if(n.startState)throw new Error("Overlays may not be stateful.");m(this.state.overlays,{mode:n,modeSpec:t,opaque:r&&r.opaque,priority:r&&r.priority||0},function(e){return e.priority}),this.state.modeGen++,vn(this)}),removeOverlay:pn(function(e){for(var t=this,r=this.state.overlays,n=0;n<r.length;++n){var i=r[n].modeSpec;if(i==e||"string"==typeof e&&i.name==e)return r.splice(n,1),t.state.modeGen++,void vn(t)}}),indentLine:pn(function(e,t,r){"string"!=typeof t&&"number"!=typeof t&&(t=null==t?this.options.smartIndent?"smart":"prev":t?"add":"subtract"),H(this.doc,e)&&Yo(this,e,t,r)}),indentSelection:pn(function(e){for(var t=this,r=this.doc.sel.ranges,n=-1,i=0;i<r.length;i++){var o=r[i];if(o.empty())o.head.line>n&&(Yo(t,o.head.line,e,!0),n=o.head.line,i==t.doc.sel.primIndex&&jr(t));else{var l=o.from(),s=o.to(),a=Math.max(n,l.line);n=Math.min(t.lastLine(),s.line-(s.ch?0:1))+1;for(var u=a;u<n;++u)Yo(t,u,e);var c=t.doc.sel.ranges;0==l.ch&&r.length==c.length&&c[i].from().ch>0&&gi(t.doc,i,new Ts(l,c[i].to()),Gl)}}}),getTokenAt:function(e,t){return Je(this,e,t)},getLineTokens:function(e,t){return Je(this,E(e),t,!0)},getTokenTypeAt:function(e){e=U(this.doc,e);var t,r=_e(this,M(this.doc,e.line)),n=0,i=(r.length-1)/2,o=e.ch;if(0==o)t=r[2];else for(;;){var l=n+i>>1;if((l?r[2*l-1]:0)>=o)i=l;else{if(!(r[2*l+1]<o)){t=r[2*l+2];break}n=l+1}}var s=t?t.indexOf("overlay "):-1;return s<0?t:0==s?null:t.slice(0,s-1)},getModeAt:function(t){var r=this.doc.mode;return r.innerMode?e.innerMode(r,this.getTokenAt(t).state).mode:r},getHelper:function(e,t){return this.getHelpers(e,t)[0]},getHelpers:function(e,t){var n=this,i=[];if(!r.hasOwnProperty(t))return i;var o=r[t],l=this.getModeAt(e);if("string"==typeof l[t])o[l[t]]&&i.push(o[l[t]]);else if(l[t])for(var s=0;s<l[t].length;s++){var a=o[l[t][s]];a&&i.push(a)}else l.helperType&&o[l.helperType]?i.push(o[l.helperType]):o[l.name]&&i.push(o[l.name]);for(var u=0;u<o._global.length;u++){var c=o._global[u];c.pred(l,n)&&-1==h(i,c.val)&&i.push(c.val)}return i},getStateAfter:function(e,t){var r=this.doc;return e=G(r,null==e?r.first+r.size-1:e),$e(this,e+1,t).state},cursorCoords:function(e,t){var r,n=this.doc.sel.primary();return r=null==e?n.head:"object"==typeof e?U(this.doc,e):e?n.from():n.to(),sr(this,r,t||"page")},charCoords:function(e,t){return lr(this,U(this.doc,e),t||"page")},coordsChar:function(e,t){return e=or(this,e,t||"page"),cr(this,e.left,e.top)},lineAtHeight:function(e,t){return e=or(this,{top:e,left:0},t||"page").top,D(this.doc,e+this.display.viewOffset)},heightAtLine:function(e,t,r){var n,i=!1;if("number"==typeof e){var o=this.doc.first+this.doc.size-1;e<this.doc.first?e=this.doc.first:e>o&&(e=o,i=!0),n=M(this.doc,e)}else n=e;return ir(this,n,{top:0,left:0},t||"page",r||i).top+(i?this.doc.height-ye(n):0)},defaultTextHeight:function(){return mr(this.display)},defaultCharWidth:function(){return yr(this.display)},getViewport:function(){return{from:this.display.viewFrom,to:this.display.viewTo}},addWidget:function(e,t,r,n,i){var o=this.display,l=(e=sr(this,U(this.doc,e))).bottom,s=e.left;if(t.style.position="absolute",t.setAttribute("cm-ignore-events","true"),this.display.input.setUneditable(t),o.sizer.appendChild(t),"over"==n)l=e.top;else if("above"==n||"near"==n){var a=Math.max(o.wrapper.clientHeight,this.doc.height),u=Math.max(o.sizer.clientWidth,o.lineSpace.clientWidth);("above"==n||e.bottom+t.offsetHeight>a)&&e.top>t.offsetHeight?l=e.top-t.offsetHeight:e.bottom+t.offsetHeight<=a&&(l=e.bottom),s+t.offsetWidth>u&&(s=u-t.offsetWidth)}t.style.top=l+"px",t.style.left=t.style.right="","right"==i?(s=o.sizer.clientWidth-t.offsetWidth,t.style.right="0px"):("left"==i?s=0:"middle"==i&&(s=(o.sizer.clientWidth-t.offsetWidth)/2),t.style.left=s+"px"),r&&Ur(this,{left:s,top:l,right:s+t.offsetWidth,bottom:l+t.offsetHeight})},triggerOnKeyDown:pn(Lo),triggerOnKeyPress:pn(Mo),triggerOnKeyUp:To,triggerOnMouseDown:pn(Oo),execCommand:function(e){if(Bs.hasOwnProperty(e))return Bs[e].call(null,this)},triggerElectric:pn(function(e){Zo(this,e)}),findPosH:function(e,t,r,n){var i=this,o=1;t<0&&(o=-1,t=-t);for(var l=U(this.doc,e),s=0;s<t&&!(l=tl(i.doc,l,o,r,n)).hitSide;++s);return l},moveH:pn(function(e,t){var r=this;this.extendSelectionsBy(function(n){return r.display.shift||r.doc.extend||n.empty()?tl(r.doc,n.head,e,t,r.options.rtlMoveVisually):e<0?n.from():n.to()},Vl)}),deleteH:pn(function(e,t){var r=this.doc.sel,n=this.doc;r.somethingSelected()?n.replaceSelection("",null,"+delete"):co(this,function(r){var i=tl(n,r.head,e,t,!1);return e<0?{from:i,to:r.head}:{from:r.head,to:i}})}),findPosV:function(e,t,r,n){var i=this,o=1,l=n;t<0&&(o=-1,t=-t);for(var s=U(this.doc,e),a=0;a<t;++a){var u=sr(i,s,"div");if(null==l?l=u.left:u.left=l,(s=rl(i,u,o,r)).hitSide)break}return s},moveV:pn(function(e,t){var r=this,n=this.doc,i=[],o=!this.display.shift&&!n.extend&&n.sel.somethingSelected();if(n.extendSelectionsBy(function(l){if(o)return e<0?l.from():l.to();var s=sr(r,l.head,"div");null!=l.goalColumn&&(s.left=l.goalColumn),i.push(s.left);var a=rl(r,s,e,t);return"page"==t&&l==n.sel.primary()&&Kr(r,lr(r,a,"div").top-s.top),a},Vl),i.length)for(var l=0;l<n.sel.ranges.length;l++)n.sel.ranges[l].goalColumn=i[l]}),findWordAt:function(e){var t=M(this.doc,e.line).text,r=e.ch,n=e.ch;if(t){var i=this.getHelper(e,"wordChars");"before"!=e.sticky&&n!=t.length||!r?++n:--r;for(var o=t.charAt(r),l=x(o,i)?function(e){return x(e,i)}:/\s/.test(o)?function(e){return/\s/.test(e)}:function(e){return!/\s/.test(e)&&!x(e)};r>0&&l(t.charAt(r-1));)--r;for(;n<t.length&&l(t.charAt(n));)++n}return new Ts(E(e.line,r),E(e.line,n))},toggleOverwrite:function(e){null!=e&&e==this.state.overwrite||((this.state.overwrite=!this.state.overwrite)?s(this.display.cursorDiv,"CodeMirror-overwrite"):Fl(this.display.cursorDiv,"CodeMirror-overwrite"),Te(this,"overwriteToggle",this,this.state.overwrite))},hasFocus:function(){return this.display.input.getField()==l()},isReadOnly:function(){return!(!this.options.readOnly&&!this.doc.cantEdit)},scrollTo:pn(function(e,t){Xr(this,e,t)}),getScrollInfo:function(){var e=this.display.scroller;return{left:e.scrollLeft,top:e.scrollTop,height:e.scrollHeight-zt(this)-this.display.barHeight,width:e.scrollWidth-zt(this)-this.display.barWidth,clientHeight:Bt(this),clientWidth:Rt(this)}},scrollIntoView:pn(function(e,t){null==e?(e={from:this.doc.sel.primary().head,to:null},null==t&&(t=this.options.cursorScrollMargin)):"number"==typeof e?e={from:E(e,0),to:null}:null==e.from&&(e={from:e,to:null}),e.to||(e.to=e.from),e.margin=t||0,null!=e.from.line?Yr(this,e):$r(this,e.from,e.to,e.margin)}),setSize:pn(function(e,t){var r=this,n=function(e){return"number"==typeof e||/^\d+$/.test(String(e))?e+"px":e};null!=e&&(this.display.wrapper.style.width=n(e)),null!=t&&(this.display.wrapper.style.height=n(t)),this.options.lineWrapping&&Jt(this);var i=this.display.viewFrom;this.doc.iter(i,this.display.viewTo,function(e){if(e.widgets)for(var t=0;t<e.widgets.length;t++)if(e.widgets[t].noHScroll){mn(r,i,"widget");break}++i}),this.curOp.forceUpdate=!0,Te(this,"refresh",this)}),operation:function(e){return hn(this,e)},startOperation:function(){return nn(this)},endOperation:function(){return on(this)},refresh:pn(function(){var e=this.display.cachedTextHeight;vn(this),this.curOp.forceUpdate=!0,er(this),Xr(this,this.doc.scrollLeft,this.doc.scrollTop),Wn(this),(null==e||Math.abs(e-mr(this.display))>.5)&&Cr(this),Te(this,"refresh",this)}),swapDoc:pn(function(e){var t=this.doc;return t.cm=null,qn(this,e),er(this),this.display.input.reset(),Xr(this,e.scrollLeft,e.scrollTop),this.curOp.forceScroll=!0,bt(this,"swapDoc",this,t),t}),getInputField:function(){return this.display.input.getField()},getWrapperElement:function(){return this.display.wrapper},getScrollerElement:function(){return this.display.scroller},getGutterElement:function(){return this.display.gutters}},Ae(e),e.registerHelper=function(t,n,i){r.hasOwnProperty(t)||(r[t]=e[t]={_global:[]}),r[t][n]=i},e.registerGlobalHelper=function(t,n,i,o){e.registerHelper(t,n,o),r[t]._global.push({pred:i,val:o})}}(jo);var Js="iter insert remove copy getEditor constructor".split(" ");for(var ea in Ds.prototype)Ds.prototype.hasOwnProperty(ea)&&h(Js,ea)<0&&(jo.prototype[ea]=function(e){return function(){return e.apply(this.doc,arguments)}}(Ds.prototype[ea]));return Ae(Ds),jo.inputStyles={textarea:Qs,contenteditable:Zs},jo.defineMode=function(e){jo.defaults.mode||"null"==e||(jo.defaults.mode=e),Be.apply(this,arguments)},jo.defineMIME=function(e,t){os[e]=t},jo.defineMode("null",function(){return{token:function(e){return e.skipToEnd()}}}),jo.defineMIME("text/plain","null"),jo.defineExtension=function(e,t){jo.prototype[e]=t},jo.defineDocExtension=function(e,t){Ds.prototype[e]=t},jo.fromTextArea=function(e,t){function r(){e.value=a.getValue()}if(t=t?c(t):{},t.value=e.value,!t.tabindex&&e.tabIndex&&(t.tabindex=e.tabIndex),!t.placeholder&&e.placeholder&&(t.placeholder=e.placeholder),null==t.autofocus){var n=l();t.autofocus=n==e||null!=e.getAttribute("autofocus")&&n==document.body}var i;if(e.form&&(Ql(e.form,"submit",r),!t.leaveSubmitMethodAlone)){var o=e.form;i=o.submit;try{var s=o.submit=function(){r(),o.submit=i,o.submit(),o.submit=s}}catch(e){}}t.finishInit=function(t){t.save=r,t.getTextArea=function(){return e},t.toTextArea=function(){t.toTextArea=isNaN,r(),e.parentNode.removeChild(t.getWrapperElement()),e.style.display="",e.form&&(ke(e.form,"submit",r),"function"==typeof e.form.submit&&(e.form.submit=i))}},e.style.display="none";var a=jo(function(t){return e.parentNode.insertBefore(t,e.nextSibling)},t);return a},function(e){e.off=ke,e.on=Ql,e.wheelEventPixels=Pn,e.Doc=Ds,e.splitLines=es,e.countColumn=f,e.findColumn=d,e.isWordChar=w,e.Pass=Bl,e.signal=Te,e.Line=fs,e.changeEnd=Bn,e.scrollbarModel=ws,e.Pos=E,e.cmpPos=P,e.modes=is,e.mimeModes=os,e.resolveMode=Ge,e.getMode=Ue,e.modeExtensions=ls,e.extendMode=Ve,e.copyState=Ke,e.startState=Xe,e.innerMode=je,e.commands=Bs,e.keyMap=Rs,e.keyName=ao,e.isModifierKey=lo,e.lookupKey=oo,e.normalizeKeyMap=io,e.StringStream=ss,e.SharedTextMarker=As,e.TextMarker=Os,e.LineWidget=Ms,e.e_preventDefault=We,e.e_stopPropagation=De,e.e_stop=Fe,e.addClass=s,e.contains=o,e.rmClass=Fl,e.keyNames=Es}(jo),jo.version="5.30.0",jo});
      !function(e){"object"==typeof exports&&"object"==typeof module?e(require("../../lib/codemirror")):"function"==typeof define&&define.amd?define(["../../lib/codemirror"],e):e(CodeMirror)}(function(e){"use strict";function t(e,t,n,r,o,a){this.indented=e,this.column=t,this.type=n,this.info=r,this.align=o,this.prev=a}function n(e,n,r,o){var a=e.indented;return e.context&&"statement"==e.context.type&&"statement"!=r&&(a=e.context.indented),e.context=new t(a,n,r,o,null,e.context)}function r(e){var t=e.context.type;return")"!=t&&"]"!=t&&"}"!=t||(e.indented=e.context.indented),e.context=e.context.prev}function o(e,t,n){return"variable"==t.prevToken||"type"==t.prevToken||(!!/\S(?:[^- ]>|[*\]])\s*$|\*$/.test(e.string.slice(0,n))||(!(!t.typeAtEndOfLine||e.column()!=e.indentation())||void 0))}function a(e){for(;;){if(!e||"top"==e.type)return!0;if("}"==e.type&&"namespace"!=e.prev.info)return!1;e=e.prev}}function i(e){for(var t={},n=e.split(" "),r=0;r<n.length;++r)t[n[r]]=!0;return t}function l(e,t){return"function"==typeof e?e(t):e.propertyIsEnumerable(t)}function s(e,t){if(!t.startOfLine)return!1;for(var n,r=null;n=e.peek();){if("\\"==n&&e.match(/^.$/)){r=s;break}if("/"==n&&e.match(/^\/[\/\*]/,!1))break;e.next()}return t.tokenize=r,"meta"}function c(e,t){return"type"==t.prevToken&&"type"}function u(e){return e.eatWhile(/[\w\.']/),"number"}function d(e,t){if(e.backUp(1),e.match(/(R|u8R|uR|UR|LR)/)){var n=e.match(/"([^\s\\()]{0,16})\(/);return!!n&&(t.cpp11RawStringDelim=n[1],t.tokenize=m,m(e,t))}return e.match(/(u8|u|U|L)/)?!!e.match(/["']/,!1)&&"string":(e.next(),!1)}function f(e){var t=/(\w+)::~?(\w+)$/.exec(e);return t&&t[1]==t[2]}function p(e,t){for(var n;null!=(n=e.next());)if('"'==n&&!e.eat('"')){t.tokenize=null;break}return"string"}function m(e,t){var n=t.cpp11RawStringDelim.replace(/[^\w\s]/g,"\\$&");return e.match(new RegExp(".*?\\)"+n+'"'))?t.tokenize=null:e.skipToEnd(),"string"}function h(t,n){function r(e){if(e)for(var t in e)e.hasOwnProperty(t)&&o.push(t)}"string"==typeof t&&(t=[t]);var o=[];r(n.keywords),r(n.types),r(n.builtin),r(n.atoms),o.length&&(n.helperType=t[0],e.registerHelper("hintWords",t[0],o));for(var a=0;a<t.length;++a)e.defineMIME(t[a],n)}function g(e,t){for(var n=!1;!e.eol();){if(!n&&e.match('"""')){t.tokenize=null;break}n="\\"==e.next()&&!n}return"string"}function y(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!e&&!o&&t.match('"')){a=!0;break}if(e&&t.match('"""')){a=!0;break}r=t.next(),!o&&"$"==r&&t.match("{")&&t.skipTo("}"),o=!o&&"\\"==r&&!e}return!a&&e||(n.tokenize=null),"string"}}function x(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!o&&t.match('"')&&("single"==e||t.match('""'))){a=!0;break}if(!o&&t.match("``")){w=x(e),a=!0;break}r=t.next(),o="single"==e&&!o&&"\\"==r}return a&&(n.tokenize=null),"string"}}e.defineMode("clike",function(i,s){function c(e,t){var n=e.next();if(S[n]){var r=S[n](e,t);if(!1!==r)return r}if('"'==n||"'"==n)return t.tokenize=u(n),t.tokenize(e,t);if(D.test(n))return p=n,null;if(L.test(n)){if(e.backUp(1),e.match(I))return"number";e.next()}if("/"==n){if(e.eat("*"))return t.tokenize=d,d(e,t);if(e.eat("/"))return e.skipToEnd(),"comment"}if(F.test(n)){for(;!e.match(/^\/[\/*]/,!1)&&e.eat(F););return"operator"}if(e.eatWhile(z),P)for(;e.match(P);)e.eatWhile(z);var o=e.current();return l(x,o)?(l(w,o)&&(p="newstatement"),l(v,o)&&(m=!0),"keyword"):l(b,o)?"type":l(k,o)?(l(w,o)&&(p="newstatement"),"builtin"):l(_,o)?"atom":"variable"}function u(e){return function(t,n){for(var r,o=!1,a=!1;null!=(r=t.next());){if(r==e&&!o){a=!0;break}o=!o&&"\\"==r}return(a||!o&&!C)&&(n.tokenize=null),"string"}}function d(e,t){for(var n,r=!1;n=e.next();){if("/"==n&&r){t.tokenize=null;break}r="*"==n}return"comment"}function f(e,t){s.typeFirstDefinitions&&e.eol()&&a(t.context)&&(t.typeAtEndOfLine=o(e,t,e.pos))}var p,m,h=i.indentUnit,g=s.statementIndentUnit||h,y=s.dontAlignCalls,x=s.keywords||{},b=s.types||{},k=s.builtin||{},w=s.blockKeywords||{},v=s.defKeywords||{},_=s.atoms||{},S=s.hooks||{},C=s.multiLineStrings,T=!1!==s.indentStatements,M=!1!==s.indentSwitch,P=s.namespaceSeparator,D=s.isPunctuationChar||/[\[\]{}\(\),;\:\.]/,L=s.numberStart||/[\d\.]/,I=s.number||/^(?:0x[a-f\d]+|0b[01]+|(?:\d+\.?\d*|\.\d+)(?:e[-+]?\d+)?)(u|ll?|l|f)?/i,F=s.isOperatorChar||/[+\-*&%=<>!?|\/]/,z=s.isIdentifierChar||/[\w\$_\xa1-\uffff]/;return{startState:function(e){return{tokenize:null,context:new t((e||0)-h,0,"top",null,!1),indented:0,startOfLine:!0,prevToken:null}},token:function(e,t){var i=t.context;if(e.sol()&&(null==i.align&&(i.align=!1),t.indented=e.indentation(),t.startOfLine=!0),e.eatSpace())return f(e,t),null;p=m=null;var l=(t.tokenize||c)(e,t);if("comment"==l||"meta"==l)return l;if(null==i.align&&(i.align=!0),";"==p||":"==p||","==p&&e.match(/^\s*(?:\/\/.*)?$/,!1))for(;"statement"==t.context.type;)r(t);else if("{"==p)n(t,e.column(),"}");else if("["==p)n(t,e.column(),"]");else if("("==p)n(t,e.column(),")");else if("}"==p){for(;"statement"==i.type;)i=r(t);for("}"==i.type&&(i=r(t));"statement"==i.type;)i=r(t)}else p==i.type?r(t):T&&(("}"==i.type||"top"==i.type)&&";"!=p||"statement"==i.type&&"newstatement"==p)&&n(t,e.column(),"statement",e.current());if("variable"==l&&("def"==t.prevToken||s.typeFirstDefinitions&&o(e,t,e.start)&&a(t.context)&&e.match(/^\s*\(/,!1))&&(l="def"),S.token){var u=S.token(e,t,l);void 0!==u&&(l=u)}return"def"==l&&!1===s.styleDefs&&(l="variable"),t.startOfLine=!1,t.prevToken=m?"def":l||p,f(e,t),l},indent:function(t,n){if(t.tokenize!=c&&null!=t.tokenize||t.typeAtEndOfLine)return e.Pass;var r=t.context,o=n&&n.charAt(0);if("statement"==r.type&&"}"==o&&(r=r.prev),s.dontIndentStatements)for(;"statement"==r.type&&s.dontIndentStatements.test(r.info);)r=r.prev;if(S.indent){var a=S.indent(t,r,n);if("number"==typeof a)return a}var i=o==r.type,l=r.prev&&"switch"==r.prev.info;if(s.allmanIndentation&&/[{(]/.test(o)){for(;"top"!=r.type&&"}"!=r.type;)r=r.prev;return r.indented}return"statement"==r.type?r.indented+("{"==o?0:g):!r.align||y&&")"==r.type?")"!=r.type||i?r.indented+(i?0:h)+(i||!l||/^(?:case|default)\b/.test(n)?0:h):r.indented+g:r.column+(i?0:1)},electricInput:M?/^\s*(?:case .*?:|default:|\{\}?|\})$/:/^\s*[{}]$/,blockCommentStart:"/*",blockCommentEnd:"*/",lineComment:"//",fold:"brace"}});var b="auto if break case register continue return default do sizeof static else struct switch extern typedef union for goto while enum const volatile",k="int long char short double float unsigned signed void size_t ptrdiff_t";h(["text/x-csrc","text/x-c","text/x-chdr"],{name:"clike",keywords:i(b),types:i(k+" bool _Complex _Bool float_t double_t intptr_t intmax_t int8_t int16_t int32_t int64_t uintptr_t uintmax_t uint8_t uint16_t uint32_t uint64_t"),blockKeywords:i("case do else for if switch while struct"),defKeywords:i("struct"),typeFirstDefinitions:!0,atoms:i("null true false"),hooks:{"#":s,"*":c},modeProps:{fold:["brace","include"]}}),h(["text/x-c++src","text/x-c++hdr"],{name:"clike",keywords:i(b+" asm dynamic_cast namespace reinterpret_cast try explicit new static_cast typeid catch operator template typename class friend private this using const_cast inline public throw virtual delete mutable protected alignas alignof constexpr decltype nullptr noexcept thread_local final static_assert override"),types:i(k+" bool wchar_t"),blockKeywords:i("catch class do else finally for if struct switch try while"),defKeywords:i("class namespace struct enum union"),typeFirstDefinitions:!0,atoms:i("true false null"),dontIndentStatements:/^template$/,isIdentifierChar:/[\w\$_~\xa1-\uffff]/,hooks:{"#":s,"*":c,u:d,U:d,L:d,R:d,0:u,1:u,2:u,3:u,4:u,5:u,6:u,7:u,8:u,9:u,token:function(e,t,n){if("variable"==n&&"("==e.peek()&&(";"==t.prevToken||null==t.prevToken||"}"==t.prevToken)&&f(e.current()))return"def"}},namespaceSeparator:"::",modeProps:{fold:["brace","include"]}}),h("text/x-java",{name:"clike",keywords:i("abstract assert break case catch class const continue default do else enum extends final finally float for goto if implements import instanceof interface native new package private protected public return static strictfp super switch synchronized this throw throws transient try volatile while @interface"),types:i("byte short int long float double boolean char void Boolean Byte Character Double Float Integer Long Number Object Short String StringBuffer StringBuilder Void"),blockKeywords:i("catch class do else finally for if switch try while"),defKeywords:i("class interface package enum @interface"),typeFirstDefinitions:!0,atoms:i("true false null"),number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,hooks:{"@":function(e){return!e.match("interface",!1)&&(e.eatWhile(/[\w\$_]/),"meta")}},modeProps:{fold:["brace","import"]}}),h("text/x-csharp",{name:"clike",keywords:i("abstract as async await base break case catch checked class const continue default delegate do else enum event explicit extern finally fixed for foreach goto if implicit in interface internal is lock namespace new operator out override params private protected public readonly ref return sealed sizeof stackalloc static struct switch this throw try typeof unchecked unsafe using virtual void volatile while add alias ascending descending dynamic from get global group into join let orderby partial remove select set value var yield"),types:i("Action Boolean Byte Char DateTime DateTimeOffset Decimal Double Func Guid Int16 Int32 Int64 Object SByte Single String Task TimeSpan UInt16 UInt32 UInt64 bool byte char decimal double short int long object sbyte float string ushort uint ulong"),blockKeywords:i("catch class do else finally for foreach if struct switch try while"),defKeywords:i("class interface namespace struct var"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"@":function(e,t){return e.eat('"')?(t.tokenize=p,p(e,t)):(e.eatWhile(/[\w\$_]/),"meta")}}}),h("text/x-scala",{name:"clike",keywords:i("abstract case catch class def do else extends final finally for forSome if implicit import lazy match new null object override package private protected return sealed super this throw trait try type val var while with yield _ assert assume require print println printf readLine readBoolean readByte readShort readChar readInt readLong readFloat readDouble"),types:i("AnyVal App Application Array BufferedIterator BigDecimal BigInt Char Console Either Enumeration Equiv Error Exception Fractional Function IndexedSeq Int Integral Iterable Iterator List Map Numeric Nil NotNull Option Ordered Ordering PartialFunction PartialOrdering Product Proxy Range Responder Seq Serializable Set Specializable Stream StringBuilder StringContext Symbol Throwable Traversable TraversableOnce Tuple Unit Vector Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),multiLineStrings:!0,blockKeywords:i("catch class enum do else finally for forSome if match switch try while"),defKeywords:i("class enum def object package trait type val var"),atoms:i("true false null"),indentStatements:!1,indentSwitch:!1,isOperatorChar:/[+\-*&%=<>!?|\/#:@]/,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return!!e.match('""')&&(t.tokenize=g,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},"=":function(e,n){var r=n.context;return!("}"!=r.type||!r.align||!e.eat(">"))&&(n.context=new t(r.indented,r.column,r.type,r.info,null,r.prev),"operator")}},modeProps:{closeBrackets:{triples:'"'}}}),h("text/x-kotlin",{name:"clike",keywords:i("package as typealias class interface this super val var fun for is in This throw return break continue object if else while do try when !in !is as? file import where by get set abstract enum open inner override private public internal protected catch finally out final vararg reified dynamic companion constructor init sealed field property receiver param sparam lateinit data inline noinline tailrec external annotation crossinline const operator infix suspend"),types:i("Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),intendSwitch:!1,indentStatements:!1,multiLineStrings:!0,number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,blockKeywords:i("catch class do else finally for if where try while enum"),defKeywords:i("class val var object package interface fun"),atoms:i("true false null this"),hooks:{'"':function(e,t){return t.tokenize=y(e.match('""')),t.tokenize(e,t)}},modeProps:{closeBrackets:{triples:'"'}}}),h(["x-shader/x-vertex","x-shader/x-fragment"],{name:"clike",keywords:i("sampler1D sampler2D sampler3D samplerCube sampler1DShadow sampler2DShadow const attribute uniform varying break continue discard return for while do if else struct in out inout"),types:i("float int bool void vec2 vec3 vec4 ivec2 ivec3 ivec4 bvec2 bvec3 bvec4 mat2 mat3 mat4"),blockKeywords:i("for while do if else struct"),builtin:i("radians degrees sin cos tan asin acos atan pow exp log exp2 sqrt inversesqrt abs sign floor ceil fract mod min max clamp mix step smoothstep length distance dot cross normalize ftransform faceforward reflect refract matrixCompMult lessThan lessThanEqual greaterThan greaterThanEqual equal notEqual any all not texture1D texture1DProj texture1DLod texture1DProjLod texture2D texture2DProj texture2DLod texture2DProjLod texture3D texture3DProj texture3DLod texture3DProjLod textureCube textureCubeLod shadow1D shadow2D shadow1DProj shadow2DProj shadow1DLod shadow2DLod shadow1DProjLod shadow2DProjLod dFdx dFdy fwidth noise1 noise2 noise3 noise4"),atoms:i("true false gl_FragColor gl_SecondaryColor gl_Normal gl_Vertex gl_MultiTexCoord0 gl_MultiTexCoord1 gl_MultiTexCoord2 gl_MultiTexCoord3 gl_MultiTexCoord4 gl_MultiTexCoord5 gl_MultiTexCoord6 gl_MultiTexCoord7 gl_FogCoord gl_PointCoord gl_Position gl_PointSize gl_ClipVertex gl_FrontColor gl_BackColor gl_FrontSecondaryColor gl_BackSecondaryColor gl_TexCoord gl_FogFragCoord gl_FragCoord gl_FrontFacing gl_FragData gl_FragDepth gl_ModelViewMatrix gl_ProjectionMatrix gl_ModelViewProjectionMatrix gl_TextureMatrix gl_NormalMatrix gl_ModelViewMatrixInverse gl_ProjectionMatrixInverse gl_ModelViewProjectionMatrixInverse gl_TexureMatrixTranspose gl_ModelViewMatrixInverseTranspose gl_ProjectionMatrixInverseTranspose gl_ModelViewProjectionMatrixInverseTranspose gl_TextureMatrixInverseTranspose gl_NormalScale gl_DepthRange gl_ClipPlane gl_Point gl_FrontMaterial gl_BackMaterial gl_LightSource gl_LightModel gl_FrontLightModelProduct gl_BackLightModelProduct gl_TextureColor gl_EyePlaneS gl_EyePlaneT gl_EyePlaneR gl_EyePlaneQ gl_FogParameters gl_MaxLights gl_MaxClipPlanes gl_MaxTextureUnits gl_MaxTextureCoords gl_MaxVertexAttribs gl_MaxVertexUniformComponents gl_MaxVaryingFloats gl_MaxVertexTextureImageUnits gl_MaxTextureImageUnits gl_MaxFragmentUniformComponents gl_MaxCombineTextureImageUnits gl_MaxDrawBuffers"),indentSwitch:!1,hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-nesc",{name:"clike",keywords:i(b+"as atomic async call command component components configuration event generic implementation includes interface module new norace nx_struct nx_union post provides signal task uses abstract extends"),types:i(k),blockKeywords:i("case do else for if switch while struct"),atoms:i("null true false"),hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-objectivec",{name:"clike",keywords:i(b+"inline restrict _Bool _Complex _Imaginary BOOL Class bycopy byref id IMP in inout nil oneway out Protocol SEL self super atomic nonatomic retain copy readwrite readonly"),types:i(k),atoms:i("YES NO NULL NILL ON OFF true false"),hooks:{"@":function(e){return e.eatWhile(/[\w\$]/),"keyword"},"#":s,indent:function(e,t,n){if("statement"==t.type&&/^@\w/.test(n))return t.indented}},modeProps:{fold:"brace"}}),h("text/x-squirrel",{name:"clike",keywords:i("base break clone continue const default delete enum extends function in class foreach local resume return this throw typeof yield constructor instanceof static"),types:i(k),blockKeywords:i("case catch class else for foreach if switch try while"),defKeywords:i("function local class"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"#":s},modeProps:{fold:["brace","include"]}});var w=null;h("text/x-ceylon",{name:"clike",keywords:i("abstracts alias assembly assert assign break case catch class continue dynamic else exists extends finally for function given if import in interface is let module new nonempty object of out outer package return satisfies super switch then this throw try value void while"),types:function(e){var t=e.charAt(0);return t===t.toUpperCase()&&t!==t.toLowerCase()},blockKeywords:i("case catch class dynamic else finally for function if interface module new object switch try while"),defKeywords:i("class dynamic function interface module object package value"),builtin:i("abstract actual aliased annotation by default deprecated doc final formal late license native optional sealed see serializable shared suppressWarnings tagged throws variable"),isPunctuationChar:/[\[\]{}\(\),;\:\.`]/,isOperatorChar:/[+\-*&%=<>!?|^~:\/]/,numberStart:/[\d#$]/,number:/^(?:#[\da-fA-F_]+|\$[01_]+|[\d_]+[kMGTPmunpf]?|[\d_]+\.[\d_]+(?:[eE][-+]?\d+|[kMGTPmunpf]|)|)/i,multiLineStrings:!0,typeFirstDefinitions:!0,atoms:i("true false null larger smaller equal empty finished"),indentSwitch:!1,styleDefs:!1,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return t.tokenize=x(e.match('""')?"triple":"single"),t.tokenize(e,t)},"`":function(e,t){return!(!w||!e.match("`"))&&(t.tokenize=w,w=null,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},token:function(e,t,n){if(("variable"==n||"type"==n)&&"."==t.prevToken)return"variable-2"}},modeProps:{fold:["brace","import"],closeBrackets:{triples:'"'}}})});
      // -------------------------------------------------------------------------
//  Part of the CodeChecker project, under the Apache License v2.0 with
//  LLVM Exceptions. See LICENSE for license information.
//  SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
// -------------------------------------------------------------------------

var BugViewer = {
  _files : [],
  _reports : [],
  _lineWidgets : [],
  _navigationMenuItems : [],
  _sourceFileData : null,
  _currentReport : null,
  _lastBugEvent  : null,

  init : function (files, reports) {
    this._files = files;
    this._reports = reports;

    this.initEscapeChars();
  },

  initEscapeChars : function () {
    this.escapeChars = {
      ' ' : 'nbsp',
      '<' : 'lt',
      '>' : 'gt',
      '"' : 'quot',
      '&' : 'amp'
    };

    var regexString = '[';
    for (var key in this.escapeChars) {
      regexString += key;
    }
    regexString += ']';

    this.escapeRegExp = new RegExp( regexString, 'g');
  },

  escapeHTML : function (str) {
    var that = this;

    return str.replace(this.escapeRegExp, function (m) {
      return '&' + that.escapeChars[m] + ';';
    });
  },

  initByUrl : function () {
    if (!this._reports) return;

    var state = {};
    window.location.hash.substr(1).split('&').forEach(function (s) {
      var parts = s.split('=');
      state[parts[0]] = parts[1];
    });

    for (var key in this._reports) {
      var report = this._reports[key];
      if (report.reportHash === state['reportHash']) {
        this.navigate(report);
        return;
      }
    }

    this.navigate(this._reports[0]);
  },

  create : function () {
    this._content = document.getElementById('editor-wrapper');
    this._filepath = document.getElementById('file-path');
    this._checkerName = document.getElementById('checker-name');
    this._reviewStatusWrapper =
      document.getElementById('review-status-wrapper');
    this._reviewStatus = document.getElementById('review-status');
    this._editor = document.getElementById('editor');

    this._codeMirror = CodeMirror(this._editor, {
      mode: 'text/x-c++src',
      matchBrackets : true,
      lineNumbers : true,
      readOnly : true,
      foldGutter : true,
      extraKeys : {},
      viewportMargin : 100
    });

    this._createNavigationMenu();
  },

  navigate : function (report, item) {
    if (!item) {
      var items = this._navigationMenuItems.filter(function (navItem) {
        return navItem.report.reportHash === report.reportHash;
      });

      if (!items.length) return;

      item = items[0].widget;
    }

    this._selectedReport.classList.remove('active');
    this._selectedReport = item;
    this._selectedReport.classList.add('active');
    this.setReport(report);
  },

  _createNavigationMenu : function () {
    var that = this;

    var nav = document.getElementById('report-nav');
    var list = document.createElement('ul');
    this._reports.forEach(function (report) {
      var events = report['events'];
      var lastBugEvent = events[events.length - 1];
      var item = document.createElement('li');

      var severity = document.createElement('i');
      severity.className = 'severity-' + report.severity.toLowerCase();

      item.appendChild(severity);
      item.appendChild(document.createTextNode(lastBugEvent.message));

      item.addEventListener('click', function () {
        that.navigate(report, item);
      })
      list.appendChild(item);
      that._navigationMenuItems.push({ report : report, widget : item });
    });

    if (!this._selectedReport && list.childNodes.length) {
      this._selectedReport = list.childNodes[0];
      this._selectedReport.classList.add('active');
    }

    nav.appendChild(list);
  },

  setReport : function (report) {
    this._currentReport = report;
    var events = report['events'];
    var lastBugEvent = events[events.length - 1];
    this.setCurrentBugEvent(lastBugEvent, events.length - 1);
    this.setCheckerName(report.checkerName);
    this.setReviewStatus(report.reviewStatus);

    window.location.hash = '#reportHash=' + report.reportHash;
  },

  setCurrentBugEvent : function (event, idx) {
    this._currentBugEvent = event;
    this.setSourceFileData(this._files[event.location.file]);
    this.drawBugPath();

    this.jumpTo(event.location.line, 0);
    this.highlightBugEvent(event, idx);
  },

  highlightBugEvent : function (event, idx) {
    this._lineWidgets.forEach(function (widget) {
      var lineIdx = widget.node.getAttribute('idx');
      if (parseInt(lineIdx) === idx) {
        widget.node.classList.add('current');
      }
    });
  },

  setCheckerName : function (checkerName) {
    this._checkerName.innerHTML = checkerName;
  },

  setReviewStatus : function (status) {
    if (status) {
      var className =
        'review-status-' + status.toLowerCase().split(' ').join('-');
      this._reviewStatus.className = "review-status " + className;

      this._reviewStatus.innerHTML = status;
      this._reviewStatusWrapper.style.display = 'block';
    } else {
      this._reviewStatusWrapper.style.display = 'none';
    }
  },

  setSourceFileData : function (file) {
    if (this._sourceFileData && file.id === this._sourceFileData.id) {
      return;
    }

    this._sourceFileData = file;
    this._filepath.innerHTML = file.path;
    this._codeMirror.doc.setValue(file.content);
    this._refresh();
  },

  _refresh : function () {
    var that = this;
    setTimeout(function () {
      var fullHeight = parseInt(that._content.clientHeight);
      var headerHeight = that._filepath.clientHeight;

      that._codeMirror.setSize('auto', fullHeight - headerHeight);
      that._codeMirror.refresh();
    }, 200);
  },

  clearBubbles : function () {
    this._lineWidgets.forEach(function (widget) { widget.clear(); });
    this._lineWidgets = [];
  },

  getMessage : function (event, kind) {
    if (kind === 'macro') {
      var name = 'macro expansion' + (event.name ? ': ' + event.name : '');

      return '<span class="tag macro">' + name + '</span>'
        + this.escapeHTML(event.expansion).replace(/(?:\r\n|\r|\n)/g, '<br>');
    } else if (kind === 'note') {
      return '<span class="tag note">note</span>'
        +  this.escapeHTML(event.message).replace(/(?:\r\n|\r|\n)/g, '<br>');
    }
  },

  addExtraPathEvents : function (events, kind) {
    var that = this;

    if (!events) {
      return;
    }

    events.forEach(function (event) {
      if (event.location.file !== that._currentBugEvent.location.file) {
        return;
      }

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + kind);

      var msg = document.createElement('span');
      msg.innerHTML = that.getMessage(event, kind);
      element.appendChild(msg);

      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  drawBugPath : function () {
    var that = this;

    this.clearBubbles();

    this.addExtraPathEvents(this._currentReport.macros, 'macro');
    this.addExtraPathEvents(this._currentReport.notes, 'note');

    // Processing bug path events.
    var currentEvents = this._currentReport.events;
    currentEvents.forEach(function (event, step) {
      if (event.location.file !== that._currentBugEvent.location.file)
        return;

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';
      var type = step === currentEvents.length - 1 ? 'error' : 'info';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + type);
      element.setAttribute('idx', step);

      var enumeration = document.createElement('span');
      enumeration.setAttribute('class', 'checker-enum ' + type);
      enumeration.innerHTML = step + 1;

      if (currentEvents.length > 1)
        element.appendChild(enumeration);

      var prevBugEvent = step - 1;
      if (step > 0) {
        var prevBug = document.createElement('span');
        prevBug.setAttribute('class', 'arrow left-arrow');
        prevBug.addEventListener('click', function () {
          var event = currentEvents[prevBugEvent];
          that.setCurrentBugEvent(event, prevBugEvent);
        });
        element.appendChild(prevBug);
      }

      var msg = document.createElement('span');
      msg.innerHTML = that.escapeHTML(event.message)
        .replace(/(?:\r\n|\r|\n)/g, '<br>');

      element.appendChild(msg);

      var nextBugEvent = step + 1;
      if (nextBugEvent < currentEvents.length) {
        var nextBug = document.createElement('span');
        nextBug.setAttribute('class', 'arrow right-arrow');
        nextBug.addEventListener('click', function () {
          var event = currentEvents[nextBugEvent];
          that.setCurrentBugEvent(event, nextBugEvent);
        });
        element.appendChild(nextBug);
      }


      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  jumpTo : function (line, column) {
    var that = this;

    setTimeout(function () {
      var selPosPixel
        = that._codeMirror.charCoords({ line : line, ch : column }, 'local');
      var editorSize = {
        width  : that._editor.clientWidth,
        height : that._editor.clientHeight
      };

      that._codeMirror.scrollIntoView({
        top    : selPosPixel.top - 100,
        bottom : selPosPixel.top + editorSize.height - 150,
        left   : selPosPixel.left < editorSize.width - 100
               ? 0
               : selPosPixel.left - 50,
        right  : selPosPixel.left < editorSize.width - 100
               ? 10
               : selPosPixel.left + editorSize.width - 100
      });
    }, 0);
  }
}


      var data = {"files": {"3": {"id": 3, "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clangd/CodeComplete.h", "content": "//===--- CodeComplete.h ------------------------------------------*- C++-*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// Code completion provides suggestions for what the user might type next.\n// After \"std::string S; S.\" we might suggest members of std::string.\n// Signature help describes the parameters of a function as you type them.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_CLANG_TOOLS_EXTRA_CLANGD_CODECOMPLETE_H\n#define LLVM_CLANG_TOOLS_EXTRA_CLANGD_CODECOMPLETE_H\n\n#include \"ASTSignals.h\"\n#include \"Compiler.h\"\n#include \"Headers.h\"\n#include \"Protocol.h\"\n#include \"Quality.h\"\n#include \"index/Index.h\"\n#include \"index/Symbol.h\"\n#include \"index/SymbolOrigin.h\"\n#include \"support/Logger.h\"\n#include \"support/Markup.h\"\n#include \"support/Path.h\"\n#include \"clang/Sema/CodeCompleteConsumer.h\"\n#include \"clang/Sema/CodeCompleteOptions.h\"\n#include \"clang/Tooling/CompilationDatabase.h\"\n#include \"llvm/ADT/Optional.h\"\n#include \"llvm/ADT/SmallVector.h\"\n#include \"llvm/ADT/StringRef.h\"\n#include \"llvm/Support/Error.h\"\n#include <functional>\n#include <future>\n\nnamespace clang {\nclass NamedDecl;\nnamespace clangd {\nstruct PreambleData;\nstruct CodeCompletion;\n\nstruct CodeCompleteOptions {\n  /// Returns options that can be passed to clang's completion engine.\n  clang::CodeCompleteOptions getClangCompleteOpts() const;\n\n  /// When true, completion items will contain expandable code snippets in\n  /// completion (e.g.  `return ${1:expression}` or `foo(${1:int a}, ${2:int\n  /// b})).\n  bool EnableSnippets = false;\n\n  /// Include results that are not legal completions in the current context.\n  /// For example, private members are usually inaccessible.\n  bool IncludeIneligibleResults = false;\n\n  /// Combine overloads into a single completion item where possible.\n  /// If none, the implementation may choose an appropriate behavior.\n  /// (In practice, ClangdLSPServer enables bundling if the client claims\n  /// to supports signature help).\n  llvm::Optional<bool> BundleOverloads;\n\n  /// Limit the number of results returned (0 means no limit).\n  /// If more results are available, we set CompletionList.isIncomplete.\n  size_t Limit = 0;\n\n  /// Whether to present doc comments as plain-text or markdown.\n  MarkupKind DocumentationFormat = MarkupKind::PlainText;\n\n  enum IncludeInsertion {\n    IWYU,\n    NeverInsert,\n  } InsertIncludes = IncludeInsertion::IWYU;\n\n  /// A visual indicator to prepend to the completion label to indicate whether\n  /// completion result would trigger an #include insertion or not.\n  struct IncludeInsertionIndicator {\n    std::string Insert = \"\u2022\";\n    std::string NoInsert = \" \";\n  } IncludeIndicator;\n\n  /// Expose origins of completion items in the label (for debugging).\n  bool ShowOrigins = false;\n\n  // Populated internally by clangd, do not set.\n  /// If `Index` is set, it is used to augment the code completion\n  /// results.\n  /// FIXME(ioeric): we might want a better way to pass the index around inside\n  /// clangd.\n  const SymbolIndex *Index = nullptr;\n\n  const ASTSignals *MainFileSignals = nullptr;\n  /// Include completions that require small corrections, e.g. change '.' to\n  /// '->' on member access etc.\n  bool IncludeFixIts = false;\n\n  /// Whether to generate snippets for function arguments on code-completion.\n  /// Needs snippets to be enabled as well.\n  bool EnableFunctionArgSnippets = true;\n\n  /// Whether to include index symbols that are not defined in the scopes\n  /// visible from the code completion point. This applies in contexts without\n  /// explicit scope qualifiers.\n  ///\n  /// Such completions can insert scope qualifiers.\n  bool AllScopes = false;\n\n  /// Whether to use the clang parser, or fallback to text-based completion\n  /// (using identifiers in the current file and symbol indexes).\n  enum CodeCompletionParse {\n    /// Block until we can run the parser (e.g. preamble is built).\n    /// Return an error if this fails.\n    AlwaysParse,\n    /// Run the parser if inputs (preamble) are ready.\n    /// Otherwise, use text-based completion.\n    ParseIfReady,\n    /// Always use text-based completion.\n    NeverParse,\n  } RunParser = ParseIfReady;\n\n  /// Callback invoked on all CompletionCandidate after they are scored and\n  /// before they are ranked (by -Score). Thus the results are yielded in\n  /// arbitrary order.\n  ///\n  /// This callbacks allows capturing various internal structures used by clangd\n  /// during code completion. Eg: Symbol quality and relevance signals.\n  std::function<void(const CodeCompletion &, const SymbolQualitySignals &,\n                     const SymbolRelevanceSignals &, float Score)>\n      RecordCCResult;\n\n  /// Model to use for ranking code completion candidates.\n  enum CodeCompletionRankingModel {\n    Heuristics,\n    DecisionForest,\n  } RankingModel = DecisionForest;\n\n  /// Callback used to score a CompletionCandidate if DecisionForest ranking\n  /// model is enabled.\n  /// This allows us to inject experimental models and compare them with\n  /// baseline model using A/B testing.\n  std::function<DecisionForestScores(\n      const SymbolQualitySignals &, const SymbolRelevanceSignals &, float Base)>\n      DecisionForestScorer = &evaluateDecisionForest;\n  /// Weight for combining NameMatch and Prediction of DecisionForest.\n  /// CompletionScore is NameMatch * pow(Base, Prediction).\n  /// The optimal value of Base largely depends on the semantics of the model\n  /// and prediction score (e.g. algorithm used during training, number of\n  /// trees, etc.). Usually if the range of Prediciton is [-20, 20] then a Base\n  /// in [1.2, 1.7] works fine.\n  /// Semantics: E.g. For Base = 1.3, if the Prediciton score reduces by 2.6\n  /// points then completion score reduces by 50% or 1.3^(-2.6).\n  float DecisionForestBase = 1.3f;\n};\n\n// Semi-structured representation of a code-complete suggestion for our C++ API.\n// We don't use the LSP structures here (unlike most features) as we want\n// to expose more data to allow for more precise testing and evaluation.\nstruct CodeCompletion {\n  // The unqualified name of the symbol or other completion item.\n  std::string Name;\n  // The scope qualifier for the symbol name. e.g. \"ns1::ns2::\"\n  // Empty for non-symbol completions. Not inserted, but may be displayed.\n  std::string Scope;\n  // Text that must be inserted before the name, and displayed (e.g. base::).\n  std::string RequiredQualifier;\n  // Details to be displayed following the name. Not inserted.\n  std::string Signature;\n  // Text to be inserted following the name, in snippet format.\n  std::string SnippetSuffix;\n  // Type to be displayed for this completion.\n  std::string ReturnType;\n  // The parsed documentation comment.\n  llvm::Optional<markup::Document> Documentation;\n  CompletionItemKind Kind = CompletionItemKind::Missing;\n  // This completion item may represent several symbols that can be inserted in\n  // the same way, such as function overloads. In this case BundleSize > 1, and\n  // the following fields are summaries:\n  //  - Signature is e.g. \"(...)\" for functions.\n  //  - SnippetSuffix is similarly e.g. \"(${0})\".\n  //  - ReturnType may be empty\n  //  - Documentation may be from one symbol, or a combination of several\n  // Other fields should apply equally to all bundled completions.\n  unsigned BundleSize = 1;\n  SymbolOrigin Origin = SymbolOrigin::Unknown;\n\n  struct IncludeCandidate {\n    // The header through which this symbol could be included.\n    // Quoted string as expected by an #include directive, e.g. \"<memory>\".\n    // Empty for non-symbol completions, or when not known.\n    std::string Header;\n    // Present if Header should be inserted to use this item.\n    llvm::Optional<TextEdit> Insertion;\n  };\n  // All possible include headers ranked by preference. By default, the first\n  // include is used.\n  // If we've bundled together overloads that have different sets of includes,\n  // thse includes may not be accurate for all of them.\n  llvm::SmallVector<IncludeCandidate, 1> Includes;\n\n  /// Holds information about small corrections that needs to be done. Like\n  /// converting '->' to '.' on member access.\n  std::vector<TextEdit> FixIts;\n\n  /// Holds the range of the token we are going to replace with this completion.\n  Range CompletionTokenRange;\n\n  // Scores are used to rank completion items.\n  struct Scores {\n    // The score that items are ranked by.\n    float Total = 0.f;\n\n    // The finalScore with the fuzzy name match score excluded.\n    // When filtering client-side, editors should calculate the new fuzzy score,\n    // whose scale is 0-1 (with 1 = prefix match, special case 2 = exact match),\n    // and recompute finalScore = fuzzyScore * symbolScore.\n    float ExcludingName = 0.f;\n\n    // Component scores that contributed to the final score:\n\n    // Quality describes how important we think this candidate is,\n    // independent of the query.\n    // e.g. symbols with lots of incoming references have higher quality.\n    float Quality = 0.f;\n    // Relevance describes how well this candidate matched the query.\n    // e.g. symbols from nearby files have higher relevance.\n    float Relevance = 0.f;\n  };\n  Scores Score;\n\n  /// Indicates if this item is deprecated.\n  bool Deprecated = false;\n\n  // Serialize this to an LSP completion item. This is a lossy operation.\n  CompletionItem render(const CodeCompleteOptions &) const;\n};\nraw_ostream &operator<<(raw_ostream &, const CodeCompletion &);\nstruct CodeCompleteResult {\n  std::vector<CodeCompletion> Completions;\n  bool HasMore = false;\n  CodeCompletionContext::Kind Context = CodeCompletionContext::CCC_Other;\n  // The text that is being directly completed.\n  // Example: foo.pb^ -> foo.push_back()\n  //              ~~\n  // Typically matches the textEdit.range of Completions, but not guaranteed to.\n  llvm::Optional<Range> CompletionRange;\n  // Usually the source will be parsed with a real C++ parser.\n  // But heuristics may be used instead if e.g. the preamble is not ready.\n  bool RanParser = true;\n};\nraw_ostream &operator<<(raw_ostream &, const CodeCompleteResult &);\n\n/// A speculative and asynchronous fuzzy find index request (based on cached\n/// request) that can be sent before parsing sema. This would reduce completion\n/// latency if the speculation succeeds.\nstruct SpeculativeFuzzyFind {\n  /// A cached request from past code completions.\n  /// Set by caller of `codeComplete()`.\n  llvm::Optional<FuzzyFindRequest> CachedReq;\n  /// The actual request used by `codeComplete()`.\n  /// Set by `codeComplete()`. This can be used by callers to update cache.\n  llvm::Optional<FuzzyFindRequest> NewReq;\n  /// The result is consumed by `codeComplete()` if speculation succeeded.\n  /// NOTE: the destructor will wait for the async call to finish.\n  std::future<SymbolSlab> Result;\n};\n\n/// Gets code completions at a specified \\p Pos in \\p FileName.\n///\n/// If \\p Preamble is nullptr, this runs code completion without compiling the\n/// code.\n///\n/// If \\p SpecFuzzyFind is set, a speculative and asynchronous fuzzy find index\n/// request (based on cached request) will be run before parsing sema. In case\n/// the speculative result is used by code completion (e.g. speculation failed),\n/// the speculative result is not consumed, and `SpecFuzzyFind` is only\n/// destroyed when the async request finishes.\nCodeCompleteResult codeComplete(PathRef FileName, Position Pos,\n                                const PreambleData *Preamble,\n                                const ParseInputs &ParseInput,\n                                CodeCompleteOptions Opts,\n                                SpeculativeFuzzyFind *SpecFuzzyFind = nullptr);\n\n/// Get signature help at a specified \\p Pos in \\p FileName.\nSignatureHelp signatureHelp(PathRef FileName, Position Pos,\n                            const PreambleData &Preamble,\n                            const ParseInputs &ParseInput);\n\n// For index-based completion, we only consider:\n//   * symbols in namespaces or translation unit scopes (e.g. no class\n//     members, no locals)\n//   * enum constants in unscoped enum decl (e.g. \"red\" in \"enum {red};\")\n//   * primary templates (no specializations)\n// For the other cases, we let Clang do the completion because it does not\n// need any non-local information and it will be much better at following\n// lookup rules. Other symbols still appear in the index for other purposes,\n// like workspace/symbols or textDocument/definition, but are not used for code\n// completion.\nbool isIndexedForCodeCompletion(const NamedDecl &ND, ASTContext &ASTCtx);\n\n// Text immediately before the completion point that should be completed.\n// This is heuristically derived from the source code, and is used when:\n//   - semantic analysis fails\n//   - semantic analysis may be slow, and we speculatively query the index\nstruct CompletionPrefix {\n  // The unqualified partial name.\n  // If there is none, begin() == end() == completion position.\n  llvm::StringRef Name;\n  // The spelled scope qualifier, such as Foo::.\n  // If there is none, begin() == end() == Name.begin().\n  llvm::StringRef Qualifier;\n};\n// Heuristically parses before Offset to determine what should be completed.\nCompletionPrefix guessCompletionPrefix(llvm::StringRef Content,\n                                       unsigned Offset);\n\n// Whether it makes sense to complete at the point based on typed characters.\n// For instance, we implicitly trigger at `a->^` but not at `a>^`.\nbool allowImplicitCompletion(llvm::StringRef Content, unsigned Offset);\n\n} // namespace clangd\n} // namespace clang\n\n#endif // LLVM_CLANG_TOOLS_EXTRA_CLANGD_CODECOMPLETE_H\n"}, "7": {"id": 7, "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clangd/Protocol.h", "content": "//===--- Protocol.h - Language Server Protocol Implementation ---*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// This file contains structs based on the LSP specification at\n// https://github.com/Microsoft/language-server-protocol/blob/master/protocol.md\n//\n// This is not meant to be a complete implementation, new interfaces are added\n// when they're needed.\n//\n// Each struct has a toJSON and fromJSON function, that converts between\n// the struct and a JSON representation. (See JSON.h)\n//\n// Some structs also have operator<< serialization. This is for debugging and\n// tests, and is not generally machine-readable.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_CLANG_TOOLS_EXTRA_CLANGD_PROTOCOL_H\n#define LLVM_CLANG_TOOLS_EXTRA_CLANGD_PROTOCOL_H\n\n#include \"URI.h\"\n#include \"index/SymbolID.h\"\n#include \"support/MemoryTree.h\"\n#include \"clang/Index/IndexSymbol.h\"\n#include \"llvm/ADT/Optional.h\"\n#include \"llvm/Support/JSON.h\"\n#include \"llvm/Support/raw_ostream.h\"\n#include <bitset>\n#include <memory>\n#include <string>\n#include <vector>\n\nnamespace clang {\nnamespace clangd {\n\nenum class ErrorCode {\n  // Defined by JSON RPC.\n  ParseError = -32700,\n  InvalidRequest = -32600,\n  MethodNotFound = -32601,\n  InvalidParams = -32602,\n  InternalError = -32603,\n\n  ServerNotInitialized = -32002,\n  UnknownErrorCode = -32001,\n\n  // Defined by the protocol.\n  RequestCancelled = -32800,\n  ContentModified = -32801,\n};\n// Models an LSP error as an llvm::Error.\nclass LSPError : public llvm::ErrorInfo<LSPError> {\npublic:\n  std::string Message;\n  ErrorCode Code;\n  static char ID;\n\n  LSPError(std::string Message, ErrorCode Code)\n      : Message(std::move(Message)), Code(Code) {}\n\n  void log(llvm::raw_ostream &OS) const override {\n    OS << int(Code) << \": \" << Message;\n  }\n  std::error_code convertToErrorCode() const override {\n    return llvm::inconvertibleErrorCode();\n  }\n};\n\n// URI in \"file\" scheme for a file.\nstruct URIForFile {\n  URIForFile() = default;\n\n  /// Canonicalizes \\p AbsPath via URI.\n  ///\n  /// File paths in URIForFile can come from index or local AST. Path from\n  /// index goes through URI transformation, and the final path is resolved by\n  /// URI scheme and could potentially be different from the original path.\n  /// Hence, we do the same transformation for all paths.\n  ///\n  /// Files can be referred to by several paths (e.g. in the presence of links).\n  /// Which one we prefer may depend on where we're coming from. \\p TUPath is a\n  /// hint, and should usually be the main entrypoint file we're processing.\n  static URIForFile canonicalize(llvm::StringRef AbsPath,\n                                 llvm::StringRef TUPath);\n\n  static llvm::Expected<URIForFile> fromURI(const URI &U,\n                                            llvm::StringRef HintPath);\n\n  /// Retrieves absolute path to the file.\n  llvm::StringRef file() const { return File; }\n\n  explicit operator bool() const { return !File.empty(); }\n  std::string uri() const { return URI::createFile(File).toString(); }\n\n  friend bool operator==(const URIForFile &LHS, const URIForFile &RHS) {\n    return LHS.File == RHS.File;\n  }\n\n  friend bool operator!=(const URIForFile &LHS, const URIForFile &RHS) {\n    return !(LHS == RHS);\n  }\n\n  friend bool operator<(const URIForFile &LHS, const URIForFile &RHS) {\n    return LHS.File < RHS.File;\n  }\n\nprivate:\n  explicit URIForFile(std::string &&File) : File(std::move(File)) {}\n\n  std::string File;\n};\n\n/// Serialize/deserialize \\p URIForFile to/from a string URI.\nllvm::json::Value toJSON(const URIForFile &U);\nbool fromJSON(const llvm::json::Value &, URIForFile &, llvm::json::Path);\n\nstruct TextDocumentIdentifier {\n  /// The text document's URI.\n  URIForFile uri;\n};\nllvm::json::Value toJSON(const TextDocumentIdentifier &);\nbool fromJSON(const llvm::json::Value &, TextDocumentIdentifier &,\n              llvm::json::Path);\n\nstruct VersionedTextDocumentIdentifier : public TextDocumentIdentifier {\n  /// The version number of this document. If a versioned text document\n  /// identifier is sent from the server to the client and the file is not open\n  /// in the editor (the server has not received an open notification before)\n  /// the server can send `null` to indicate that the version is known and the\n  /// content on disk is the master (as speced with document content ownership).\n  ///\n  /// The version number of a document will increase after each change,\n  /// including undo/redo. The number doesn't need to be consecutive.\n  ///\n  /// clangd extension: versions are optional, and synthesized if missing.\n  llvm::Optional<std::int64_t> version;\n};\nllvm::json::Value toJSON(const VersionedTextDocumentIdentifier &);\nbool fromJSON(const llvm::json::Value &, VersionedTextDocumentIdentifier &,\n              llvm::json::Path);\n\nstruct Position {\n  /// Line position in a document (zero-based).\n  int line = 0;\n\n  /// Character offset on a line in a document (zero-based).\n  /// WARNING: this is in UTF-16 codepoints, not bytes or characters!\n  /// Use the functions in SourceCode.h to construct/interpret Positions.\n  int character = 0;\n\n  friend bool operator==(const Position &LHS, const Position &RHS) {\n    return std::tie(LHS.line, LHS.character) ==\n           std::tie(RHS.line, RHS.character);\n  }\n  friend bool operator!=(const Position &LHS, const Position &RHS) {\n    return !(LHS == RHS);\n  }\n  friend bool operator<(const Position &LHS, const Position &RHS) {\n    return std::tie(LHS.line, LHS.character) <\n           std::tie(RHS.line, RHS.character);\n  }\n  friend bool operator<=(const Position &LHS, const Position &RHS) {\n    return std::tie(LHS.line, LHS.character) <=\n           std::tie(RHS.line, RHS.character);\n  }\n};\nbool fromJSON(const llvm::json::Value &, Position &, llvm::json::Path);\nllvm::json::Value toJSON(const Position &);\nllvm::raw_ostream &operator<<(llvm::raw_ostream &, const Position &);\n\nstruct Range {\n  /// The range's start position.\n  Position start;\n\n  /// The range's end position.\n  Position end;\n\n  friend bool operator==(const Range &LHS, const Range &RHS) {\n    return std::tie(LHS.start, LHS.end) == std::tie(RHS.start, RHS.end);\n  }\n  friend bool operator!=(const Range &LHS, const Range &RHS) {\n    return !(LHS == RHS);\n  }\n  friend bool operator<(const Range &LHS, const Range &RHS) {\n    return std::tie(LHS.start, LHS.end) < std::tie(RHS.start, RHS.end);\n  }\n\n  bool contains(Position Pos) const { return start <= Pos && Pos < end; }\n  bool contains(Range Rng) const {\n    return start <= Rng.start && Rng.end <= end;\n  }\n};\nbool fromJSON(const llvm::json::Value &, Range &, llvm::json::Path);\nllvm::json::Value toJSON(const Range &);\nllvm::raw_ostream &operator<<(llvm::raw_ostream &, const Range &);\n\nstruct Location {\n  /// The text document's URI.\n  URIForFile uri;\n  Range range;\n\n  friend bool operator==(const Location &LHS, const Location &RHS) {\n    return LHS.uri == RHS.uri && LHS.range == RHS.range;\n  }\n\n  friend bool operator!=(const Location &LHS, const Location &RHS) {\n    return !(LHS == RHS);\n  }\n\n  friend bool operator<(const Location &LHS, const Location &RHS) {\n    return std::tie(LHS.uri, LHS.range) < std::tie(RHS.uri, RHS.range);\n  }\n};\nllvm::json::Value toJSON(const Location &);\nllvm::raw_ostream &operator<<(llvm::raw_ostream &, const Location &);\n\nstruct TextEdit {\n  /// The range of the text document to be manipulated. To insert\n  /// text into a document create a range where start === end.\n  Range range;\n\n  /// The string to be inserted. For delete operations use an\n  /// empty string.\n  std::string newText;\n};\ninline bool operator==(const TextEdit &L, const TextEdit &R) {\n  return std::tie(L.newText, L.range) == std::tie(R.newText, R.range);\n}\nbool fromJSON(const llvm::json::Value &, TextEdit &, llvm::json::Path);\nllvm::json::Value toJSON(const TextEdit &);\nllvm::raw_ostream &operator<<(llvm::raw_ostream &, const TextEdit &);\n\nstruct TextDocumentItem {\n  /// The text document's URI.\n  URIForFile uri;\n\n  /// The text document's language identifier.\n  std::string languageId;\n\n  /// The version number of this document (it will strictly increase after each\n  /// change, including undo/redo.\n  ///\n  /// clangd extension: versions are optional, and synthesized if missing.\n  llvm::Optional<int64_t> version;\n\n  /// The content of the opened text document.\n  std::string text;\n};\nbool fromJSON(const llvm::json::Value &, TextDocumentItem &, llvm::json::Path);\n\nenum class TraceLevel {\n  Off = 0,\n  Messages = 1,\n  Verbose = 2,\n};\nbool fromJSON(const llvm::json::Value &E, TraceLevel &Out, llvm::json::Path);\n\nstruct NoParams {};\ninline llvm::json::Value toJSON(const NoParams &) { return nullptr; }\ninline bool fromJSON(const llvm::json::Value &, NoParams &, llvm::json::Path) {\n  return true;\n}\nusing InitializedParams = NoParams;\n\n/// Defines how the host (editor) should sync document changes to the language\n/// server.\nenum class TextDocumentSyncKind {\n  /// Documents should not be synced at all.\n  None = 0,\n\n  /// Documents are synced by always sending the full content of the document.\n  Full = 1,\n\n  /// Documents are synced by sending the full content on open.  After that\n  /// only incremental updates to the document are send.\n  Incremental = 2,\n};\n\n/// The kind of a completion entry.\nenum class CompletionItemKind {\n  Missing = 0,\n  Text = 1,\n  Method = 2,\n  Function = 3,\n  Constructor = 4,\n  Field = 5,\n  Variable = 6,\n  Class = 7,\n  Interface = 8,\n  Module = 9,\n  Property = 10,\n  Unit = 11,\n  Value = 12,\n  Enum = 13,\n  Keyword = 14,\n  Snippet = 15,\n  Color = 16,\n  File = 17,\n  Reference = 18,\n  Folder = 19,\n  EnumMember = 20,\n  Constant = 21,\n  Struct = 22,\n  Event = 23,\n  Operator = 24,\n  TypeParameter = 25,\n};\nbool fromJSON(const llvm::json::Value &, CompletionItemKind &,\n              llvm::json::Path);\nconstexpr auto CompletionItemKindMin =\n    static_cast<size_t>(CompletionItemKind::Text);\nconstexpr auto CompletionItemKindMax =\n    static_cast<size_t>(CompletionItemKind::TypeParameter);\nusing CompletionItemKindBitset = std::bitset<CompletionItemKindMax + 1>;\nbool fromJSON(const llvm::json::Value &, CompletionItemKindBitset &,\n              llvm::json::Path);\nCompletionItemKind\nadjustKindToCapability(CompletionItemKind Kind,\n                       CompletionItemKindBitset &SupportedCompletionItemKinds);\n\n/// A symbol kind.\nenum class SymbolKind {\n  File = 1,\n  Module = 2,\n  Namespace = 3,\n  Package = 4,\n  Class = 5,\n  Method = 6,\n  Property = 7,\n  Field = 8,\n  Constructor = 9,\n  Enum = 10,\n  Interface = 11,\n  Function = 12,\n  Variable = 13,\n  Constant = 14,\n  String = 15,\n  Number = 16,\n  Boolean = 17,\n  Array = 18,\n  Object = 19,\n  Key = 20,\n  Null = 21,\n  EnumMember = 22,\n  Struct = 23,\n  Event = 24,\n  Operator = 25,\n  TypeParameter = 26\n};\nbool fromJSON(const llvm::json::Value &, SymbolKind &, llvm::json::Path);\nconstexpr auto SymbolKindMin = static_cast<size_t>(SymbolKind::File);\nconstexpr auto SymbolKindMax = static_cast<size_t>(SymbolKind::TypeParameter);\nusing SymbolKindBitset = std::bitset<SymbolKindMax + 1>;\nbool fromJSON(const llvm::json::Value &, SymbolKindBitset &, llvm::json::Path);\nSymbolKind adjustKindToCapability(SymbolKind Kind,\n                                  SymbolKindBitset &supportedSymbolKinds);\n\n// Convert a index::SymbolKind to clangd::SymbolKind (LSP)\n// Note, some are not perfect matches and should be improved when this LSP\n// issue is addressed:\n// https://github.com/Microsoft/language-server-protocol/issues/344\nSymbolKind indexSymbolKindToSymbolKind(index::SymbolKind Kind);\n\n// Determines the encoding used to measure offsets and lengths of source in LSP.\nenum class OffsetEncoding {\n  // Any string is legal on the wire. Unrecognized encodings parse as this.\n  UnsupportedEncoding,\n  // Length counts code units of UTF-16 encoded text. (Standard LSP behavior).\n  UTF16,\n  // Length counts bytes of UTF-8 encoded text. (Clangd extension).\n  UTF8,\n  // Length counts codepoints in unicode text. (Clangd extension).\n  UTF32,\n};\nllvm::json::Value toJSON(const OffsetEncoding &);\nbool fromJSON(const llvm::json::Value &, OffsetEncoding &, llvm::json::Path);\nllvm::raw_ostream &operator<<(llvm::raw_ostream &, OffsetEncoding);\n\n// Describes the content type that a client supports in various result literals\n// like `Hover`, `ParameterInfo` or `CompletionItem`.\nenum class MarkupKind {\n  PlainText,\n  Markdown,\n};\nbool fromJSON(const llvm::json::Value &, MarkupKind &, llvm::json::Path);\nllvm::raw_ostream &operator<<(llvm::raw_ostream &OS, MarkupKind);\n\n// This struct doesn't mirror LSP!\n// The protocol defines deeply nested structures for client capabilities.\n// Instead of mapping them all, this just parses out the bits we care about.\nstruct ClientCapabilities {\n  /// The supported set of SymbolKinds for workspace/symbol.\n  /// workspace.symbol.symbolKind.valueSet\n  llvm::Optional<SymbolKindBitset> WorkspaceSymbolKinds;\n\n  /// Whether the client accepts diagnostics with codeActions attached inline.\n  /// textDocument.publishDiagnostics.codeActionsInline.\n  bool DiagnosticFixes = false;\n\n  /// Whether the client accepts diagnostics with related locations.\n  /// textDocument.publishDiagnostics.relatedInformation.\n  bool DiagnosticRelatedInformation = false;\n\n  /// Whether the client accepts diagnostics with category attached to it\n  /// using the \"category\" extension.\n  /// textDocument.publishDiagnostics.categorySupport\n  bool DiagnosticCategory = false;\n\n  /// Client supports snippets as insert text.\n  /// textDocument.completion.completionItem.snippetSupport\n  bool CompletionSnippets = false;\n\n  /// Client supports completions with additionalTextEdit near the cursor.\n  /// This is a clangd extension. (LSP says this is for unrelated text only).\n  /// textDocument.completion.editsNearCursor\n  bool CompletionFixes = false;\n\n  /// Client supports hierarchical document symbols.\n  /// textDocument.documentSymbol.hierarchicalDocumentSymbolSupport\n  bool HierarchicalDocumentSymbol = false;\n\n  /// Client supports signature help.\n  /// textDocument.signatureHelp\n  bool HasSignatureHelp = false;\n\n  /// Client supports processing label offsets instead of a simple label string.\n  /// textDocument.signatureHelp.signatureInformation.parameterInformation.labelOffsetSupport\n  bool OffsetsInSignatureHelp = false;\n\n  /// The supported set of CompletionItemKinds for textDocument/completion.\n  /// textDocument.completion.completionItemKind.valueSet\n  llvm::Optional<CompletionItemKindBitset> CompletionItemKinds;\n\n  /// The documentation format that should be used for textDocument/completion.\n  /// textDocument.completion.completionItem.documentationFormat\n  MarkupKind CompletionDocumentationFormat = MarkupKind::PlainText;\n\n  /// Client supports CodeAction return value for textDocument/codeAction.\n  /// textDocument.codeAction.codeActionLiteralSupport.\n  bool CodeActionStructure = false;\n\n  /// Client advertises support for the semanticTokens feature.\n  /// We support the textDocument/semanticTokens request in any case.\n  /// textDocument.semanticTokens\n  bool SemanticTokens = false;\n  /// Client supports Theia semantic highlighting extension.\n  /// https://github.com/microsoft/vscode-languageserver-node/pull/367\n  /// clangd no longer supports this, we detect it just to log a warning.\n  /// textDocument.semanticHighlightingCapabilities.semanticHighlighting\n  bool TheiaSemanticHighlighting = false;\n\n  /// Supported encodings for LSP character offsets. (clangd extension).\n  llvm::Optional<std::vector<OffsetEncoding>> offsetEncoding;\n\n  /// The content format that should be used for Hover requests.\n  /// textDocument.hover.contentEncoding\n  MarkupKind HoverContentFormat = MarkupKind::PlainText;\n\n  /// The client supports testing for validity of rename operations\n  /// before execution.\n  bool RenamePrepareSupport = false;\n\n  /// The client supports progress notifications.\n  /// window.workDoneProgress\n  bool WorkDoneProgress = false;\n\n  /// The client supports implicit $/progress work-done progress streams,\n  /// without a preceding window/workDoneProgress/create.\n  /// This is a clangd extension.\n  /// window.implicitWorkDoneProgressCreate\n  bool ImplicitProgressCreation = false;\n\n  /// Whether the client implementation supports a refresh request sent from the\n  /// server to the client.\n  bool SemanticTokenRefreshSupport = false;\n};\nbool fromJSON(const llvm::json::Value &, ClientCapabilities &,\n              llvm::json::Path);\n\n/// Clangd extension that's used in the 'compilationDatabaseChanges' in\n/// workspace/didChangeConfiguration to record updates to the in-memory\n/// compilation database.\nstruct ClangdCompileCommand {\n  std::string workingDirectory;\n  std::vector<std::string> compilationCommand;\n};\nbool fromJSON(const llvm::json::Value &, ClangdCompileCommand &,\n              llvm::json::Path);\n\n/// Clangd extension: parameters configurable at any time, via the\n/// `workspace/didChangeConfiguration` notification.\n/// LSP defines this type as `any`.\nstruct ConfigurationSettings {\n  // Changes to the in-memory compilation database.\n  // The key of the map is a file name.\n  std::map<std::string, ClangdCompileCommand> compilationDatabaseChanges;\n};\nbool fromJSON(const llvm::json::Value &, ConfigurationSettings &,\n              llvm::json::Path);\n\n/// Clangd extension: parameters configurable at `initialize` time.\n/// LSP defines this type as `any`.\nstruct InitializationOptions {\n  // What we can change throught the didChangeConfiguration request, we can\n  // also set through the initialize request (initializationOptions field).\n  ConfigurationSettings ConfigSettings;\n\n  llvm::Optional<std::string> compilationDatabasePath;\n  // Additional flags to be included in the \"fallback command\" used when\n  // the compilation database doesn't describe an opened file.\n  // The command used will be approximately `clang $FILE $fallbackFlags`.\n  std::vector<std::string> fallbackFlags;\n\n  /// Clients supports show file status for textDocument/clangd.fileStatus.\n  bool FileStatus = false;\n};\nbool fromJSON(const llvm::json::Value &, InitializationOptions &,\n              llvm::json::Path);\n\nstruct InitializeParams {\n  /// The process Id of the parent process that started\n  /// the server. Is null if the process has not been started by another\n  /// process. If the parent process is not alive then the server should exit\n  /// (see exit notification) its process.\n  llvm::Optional<int> processId;\n\n  /// The rootPath of the workspace. Is null\n  /// if no folder is open.\n  ///\n  /// @deprecated in favour of rootUri.\n  llvm::Optional<std::string> rootPath;\n\n  /// The rootUri of the workspace. Is null if no\n  /// folder is open. If both `rootPath` and `rootUri` are set\n  /// `rootUri` wins.\n  llvm::Optional<URIForFile> rootUri;\n\n  // User provided initialization options.\n  // initializationOptions?: any;\n\n  /// The capabilities provided by the client (editor or tool)\n  ClientCapabilities capabilities;\n  /// The same data as capabilities, but not parsed (to expose to modules).\n  llvm::json::Object rawCapabilities;\n\n  /// The initial trace setting. If omitted trace is disabled ('off').\n  llvm::Optional<TraceLevel> trace;\n\n  /// User-provided initialization options.\n  InitializationOptions initializationOptions;\n};\nbool fromJSON(const llvm::json::Value &, InitializeParams &, llvm::json::Path);\n\nstruct WorkDoneProgressCreateParams {\n  /// The token to be used to report progress.\n  llvm::json::Value token = nullptr;\n};\nllvm::json::Value toJSON(const WorkDoneProgressCreateParams &P);\n\ntemplate <typename T> struct ProgressParams {\n  /// The progress token provided by the client or server.\n  llvm::json::Value token = nullptr;\n\n  /// The progress data.\n  T value;\n};\ntemplate <typename T> llvm::json::Value toJSON(const ProgressParams<T> &P) {\n  return llvm::json::Object{{\"token\", P.token}, {\"value\", P.value}};\n}\n/// To start progress reporting a $/progress notification with the following\n/// payload must be sent.\nstruct WorkDoneProgressBegin {\n  /// Mandatory title of the progress operation. Used to briefly inform about\n  /// the kind of operation being performed.\n  ///\n  /// Examples: \"Indexing\" or \"Linking dependencies\".\n  std::string title;\n\n  /// Controls if a cancel button should show to allow the user to cancel the\n  /// long-running operation. Clients that don't support cancellation are\n  /// allowed to ignore the setting.\n  bool cancellable = false;\n\n  /// Optional progress percentage to display (value 100 is considered 100%).\n  /// If not provided infinite progress is assumed and clients are allowed\n  /// to ignore the `percentage` value in subsequent in report notifications.\n  ///\n  /// The value should be steadily rising. Clients are free to ignore values\n  /// that are not following this rule.\n  ///\n  /// Clangd implementation note: we only send nonzero percentages in\n  /// the WorkProgressReport. 'true' here means percentages will be used.\n  bool percentage = false;\n};\nllvm::json::Value toJSON(const WorkDoneProgressBegin &);\n\n/// Reporting progress is done using the following payload.\nstruct WorkDoneProgressReport {\n  /// Mandatory title of the progress operation. Used to briefly inform about\n  /// the kind of operation being performed.\n  ///\n  /// Examples: \"Indexing\" or \"Linking dependencies\".\n  std::string title;\n\n  /// Controls enablement state of a cancel button. This property is only valid\n  /// if a cancel button got requested in the `WorkDoneProgressStart` payload.\n  ///\n  /// Clients that don't support cancellation or don't support control\n  /// the button's enablement state are allowed to ignore the setting.\n  llvm::Optional<bool> cancellable;\n\n  /// Optional, more detailed associated progress message. Contains\n  /// complementary information to the `title`.\n  ///\n  /// Examples: \"3/25 files\", \"project/src/module2\", \"node_modules/some_dep\".\n  /// If unset, the previous progress message (if any) is still valid.\n  llvm::Optional<std::string> message;\n\n  /// Optional progress percentage to display (value 100 is considered 100%).\n  /// If not provided infinite progress is assumed and clients are allowed\n  /// to ignore the `percentage` value in subsequent in report notifications.\n  ///\n  /// The value should be steadily rising. Clients are free to ignore values\n  /// that are not following this rule.\n  llvm::Optional<double> percentage;\n};\nllvm::json::Value toJSON(const WorkDoneProgressReport &);\n//\n/// Signals the end of progress reporting.\nstruct WorkDoneProgressEnd {\n  /// Optional, a final message indicating to for example indicate the outcome\n  /// of the operation.\n  llvm::Optional<std::string> message;\n};\nllvm::json::Value toJSON(const WorkDoneProgressEnd &);\n\nenum class MessageType {\n  /// An error message.\n  Error = 1,\n  /// A warning message.\n  Warning = 2,\n  /// An information message.\n  Info = 3,\n  /// A log message.\n  Log = 4,\n};\nllvm::json::Value toJSON(const MessageType &);\n\n/// The show message notification is sent from a server to a client to ask the\n/// client to display a particular message in the user interface.\nstruct ShowMessageParams {\n  /// The message type.\n  MessageType type = MessageType::Info;\n  /// The actual message.\n  std::string message;\n};\nllvm::json::Value toJSON(const ShowMessageParams &);\n\nstruct DidOpenTextDocumentParams {\n  /// The document that was opened.\n  TextDocumentItem textDocument;\n};\nbool fromJSON(const llvm::json::Value &, DidOpenTextDocumentParams &,\n              llvm::json::Path);\n\nstruct DidCloseTextDocumentParams {\n  /// The document that was closed.\n  TextDocumentIdentifier textDocument;\n};\nbool fromJSON(const llvm::json::Value &, DidCloseTextDocumentParams &,\n              llvm::json::Path);\n\nstruct DidSaveTextDocumentParams {\n  /// The document that was saved.\n  TextDocumentIdentifier textDocument;\n};\nbool fromJSON(const llvm::json::Value &, DidSaveTextDocumentParams &,\n              llvm::json::Path);\n\nstruct TextDocumentContentChangeEvent {\n  /// The range of the document that changed.\n  llvm::Optional<Range> range;\n\n  /// The length of the range that got replaced.\n  llvm::Optional<int> rangeLength;\n\n  /// The new text of the range/document.\n  std::string text;\n};\nbool fromJSON(const llvm::json::Value &, TextDocumentContentChangeEvent &,\n              llvm::json::Path);\n\nstruct DidChangeTextDocumentParams {\n  /// The document that did change. The version number points\n  /// to the version after all provided content changes have\n  /// been applied.\n  VersionedTextDocumentIdentifier textDocument;\n\n  /// The actual content changes.\n  std::vector<TextDocumentContentChangeEvent> contentChanges;\n\n  /// Forces diagnostics to be generated, or to not be generated, for this\n  /// version of the file. If not set, diagnostics are eventually consistent:\n  /// either they will be provided for this version or some subsequent one.\n  /// This is a clangd extension.\n  llvm::Optional<bool> wantDiagnostics;\n\n  /// Force a complete rebuild of the file, ignoring all cached state. Slow!\n  /// This is useful to defeat clangd's assumption that missing headers will\n  /// stay missing.\n  /// This is a clangd extension.\n  bool forceRebuild = false;\n};\nbool fromJSON(const llvm::json::Value &, DidChangeTextDocumentParams &,\n              llvm::json::Path);\n\nenum class FileChangeType {\n  /// The file got created.\n  Created = 1,\n  /// The file got changed.\n  Changed = 2,\n  /// The file got deleted.\n  Deleted = 3\n};\nbool fromJSON(const llvm::json::Value &E, FileChangeType &Out,\n              llvm::json::Path);\n\nstruct FileEvent {\n  /// The file's URI.\n  URIForFile uri;\n  /// The change type.\n  FileChangeType type = FileChangeType::Created;\n};\nbool fromJSON(const llvm::json::Value &, FileEvent &, llvm::json::Path);\n\nstruct DidChangeWatchedFilesParams {\n  /// The actual file events.\n  std::vector<FileEvent> changes;\n};\nbool fromJSON(const llvm::json::Value &, DidChangeWatchedFilesParams &,\n              llvm::json::Path);\n\nstruct DidChangeConfigurationParams {\n  ConfigurationSettings settings;\n};\nbool fromJSON(const llvm::json::Value &, DidChangeConfigurationParams &,\n              llvm::json::Path);\n\n// Note: we do not parse FormattingOptions for *FormattingParams.\n// In general, we use a clang-format style detected from common mechanisms\n// (.clang-format files and the -fallback-style flag).\n// It would be possible to override these with FormatOptions, but:\n//  - the protocol makes FormatOptions mandatory, so many clients set them to\n//    useless values, and we can't tell when to respect them\n// - we also format in other places, where FormatOptions aren't available.\n\nstruct DocumentRangeFormattingParams {\n  /// The document to format.\n  TextDocumentIdentifier textDocument;\n\n  /// The range to format\n  Range range;\n};\nbool fromJSON(const llvm::json::Value &, DocumentRangeFormattingParams &,\n              llvm::json::Path);\n\nstruct DocumentOnTypeFormattingParams {\n  /// The document to format.\n  TextDocumentIdentifier textDocument;\n\n  /// The position at which this request was sent.\n  Position position;\n\n  /// The character that has been typed.\n  std::string ch;\n};\nbool fromJSON(const llvm::json::Value &, DocumentOnTypeFormattingParams &,\n              llvm::json::Path);\n\nstruct DocumentFormattingParams {\n  /// The document to format.\n  TextDocumentIdentifier textDocument;\n};\nbool fromJSON(const llvm::json::Value &, DocumentFormattingParams &,\n              llvm::json::Path);\n\nstruct DocumentSymbolParams {\n  // The text document to find symbols in.\n  TextDocumentIdentifier textDocument;\n};\nbool fromJSON(const llvm::json::Value &, DocumentSymbolParams &,\n              llvm::json::Path);\n\n/// Represents a related message and source code location for a diagnostic.\n/// This should be used to point to code locations that cause or related to a\n/// diagnostics, e.g when duplicating a symbol in a scope.\nstruct DiagnosticRelatedInformation {\n  /// The location of this related diagnostic information.\n  Location location;\n  /// The message of this related diagnostic information.\n  std::string message;\n};\nllvm::json::Value toJSON(const DiagnosticRelatedInformation &);\n\nstruct CodeAction;\nstruct Diagnostic {\n  /// The range at which the message applies.\n  Range range;\n\n  /// The diagnostic's severity. Can be omitted. If omitted it is up to the\n  /// client to interpret diagnostics as error, warning, info or hint.\n  int severity = 0;\n\n  /// The diagnostic's code. Can be omitted.\n  std::string code;\n\n  /// A human-readable string describing the source of this\n  /// diagnostic, e.g. 'typescript' or 'super lint'.\n  std::string source;\n\n  /// The diagnostic's message.\n  std::string message;\n\n  /// An array of related diagnostic information, e.g. when symbol-names within\n  /// a scope collide all definitions can be marked via this property.\n  llvm::Optional<std::vector<DiagnosticRelatedInformation>> relatedInformation;\n\n  /// The diagnostic's category. Can be omitted.\n  /// An LSP extension that's used to send the name of the category over to the\n  /// client. The category typically describes the compilation stage during\n  /// which the issue was produced, e.g. \"Semantic Issue\" or \"Parse Issue\".\n  llvm::Optional<std::string> category;\n\n  /// Clangd extension: code actions related to this diagnostic.\n  /// Only with capability textDocument.publishDiagnostics.codeActionsInline.\n  /// (These actions can also be obtained using textDocument/codeAction).\n  llvm::Optional<std::vector<CodeAction>> codeActions;\n};\nllvm::json::Value toJSON(const Diagnostic &);\n\n/// A LSP-specific comparator used to find diagnostic in a container like\n/// std:map.\n/// We only use the required fields of Diagnostic to do the comparison to avoid\n/// any regression issues from LSP clients (e.g. VScode), see\n/// https://git.io/vbr29\nstruct LSPDiagnosticCompare {\n  bool operator()(const Diagnostic &LHS, const Diagnostic &RHS) const {\n    return std::tie(LHS.range, LHS.message) < std::tie(RHS.range, RHS.message);\n  }\n};\nbool fromJSON(const llvm::json::Value &, Diagnostic &, llvm::json::Path);\nllvm::raw_ostream &operator<<(llvm::raw_ostream &, const Diagnostic &);\n\nstruct PublishDiagnosticsParams {\n  /// The URI for which diagnostic information is reported.\n  URIForFile uri;\n  /// An array of diagnostic information items.\n  std::vector<Diagnostic> diagnostics;\n  /// The version number of the document the diagnostics are published for.\n  llvm::Optional<int64_t> version;\n};\nllvm::json::Value toJSON(const PublishDiagnosticsParams &);\n\nstruct CodeActionContext {\n  /// An array of diagnostics known on the client side overlapping the range\n  /// provided to the `textDocument/codeAction` request. They are provided so\n  /// that the server knows which errors are currently presented to the user for\n  /// the given range. There is no guarantee that these accurately reflect the\n  /// error state of the resource. The primary parameter to compute code actions\n  /// is the provided range.\n  std::vector<Diagnostic> diagnostics;\n\n  /// Requested kind of actions to return.\n  ///\n  /// Actions not of this kind are filtered out by the client before being\n  /// shown. So servers can omit computing them.\n  std::vector<std::string> only;\n};\nbool fromJSON(const llvm::json::Value &, CodeActionContext &, llvm::json::Path);\n\nstruct CodeActionParams {\n  /// The document in which the command was invoked.\n  TextDocumentIdentifier textDocument;\n\n  /// The range for which the command was invoked.\n  Range range;\n\n  /// Context carrying additional information.\n  CodeActionContext context;\n};\nbool fromJSON(const llvm::json::Value &, CodeActionParams &, llvm::json::Path);\n\nstruct WorkspaceEdit {\n  /// Holds changes to existing resources.\n  llvm::Optional<std::map<std::string, std::vector<TextEdit>>> changes;\n\n  /// Note: \"documentChanges\" is not currently used because currently there is\n  /// no support for versioned edits.\n};\nbool fromJSON(const llvm::json::Value &, WorkspaceEdit &, llvm::json::Path);\nllvm::json::Value toJSON(const WorkspaceEdit &WE);\n\n/// Arguments for the 'applyTweak' command. The server sends these commands as a\n/// response to the textDocument/codeAction request. The client can later send a\n/// command back to the server if the user requests to execute a particular code\n/// tweak.\nstruct TweakArgs {\n  /// A file provided by the client on a textDocument/codeAction request.\n  URIForFile file;\n  /// A selection provided by the client on a textDocument/codeAction request.\n  Range selection;\n  /// ID of the tweak that should be executed. Corresponds to Tweak::id().\n  std::string tweakID;\n};\nbool fromJSON(const llvm::json::Value &, TweakArgs &, llvm::json::Path);\nllvm::json::Value toJSON(const TweakArgs &A);\n\nstruct ExecuteCommandParams {\n  /// The identifier of the actual command handler.\n  std::string command;\n\n  // This is `arguments?: []any` in LSP.\n  // All clangd's commands accept a single argument (or none => null).\n  llvm::json::Value argument = nullptr;\n};\nbool fromJSON(const llvm::json::Value &, ExecuteCommandParams &,\n              llvm::json::Path);\n\nstruct Command : public ExecuteCommandParams {\n  std::string title;\n};\nllvm::json::Value toJSON(const Command &C);\n\n/// A code action represents a change that can be performed in code, e.g. to fix\n/// a problem or to refactor code.\n///\n/// A CodeAction must set either `edit` and/or a `command`. If both are\n/// supplied, the `edit` is applied first, then the `command` is executed.\nstruct CodeAction {\n  /// A short, human-readable, title for this code action.\n  std::string title;\n\n  /// The kind of the code action.\n  /// Used to filter code actions.\n  llvm::Optional<std::string> kind;\n  const static llvm::StringLiteral QUICKFIX_KIND;\n  const static llvm::StringLiteral REFACTOR_KIND;\n  const static llvm::StringLiteral INFO_KIND;\n\n  /// The diagnostics that this code action resolves.\n  llvm::Optional<std::vector<Diagnostic>> diagnostics;\n\n  /// Marks this as a preferred action. Preferred actions are used by the\n  /// `auto fix` command and can be targeted by keybindings.\n  /// A quick fix should be marked preferred if it properly addresses the\n  /// underlying error. A refactoring should be marked preferred if it is the\n  /// most reasonable choice of actions to take.\n  bool isPreferred = false;\n\n  /// The workspace edit this code action performs.\n  llvm::Optional<WorkspaceEdit> edit;\n\n  /// A command this code action executes. If a code action provides an edit\n  /// and a command, first the edit is executed and then the command.\n  llvm::Optional<Command> command;\n};\nllvm::json::Value toJSON(const CodeAction &);\n\n/// Represents programming constructs like variables, classes, interfaces etc.\n/// that appear in a document. Document symbols can be hierarchical and they\n/// have two ranges: one that encloses its definition and one that points to its\n/// most interesting range, e.g. the range of an identifier.\nstruct DocumentSymbol {\n  /// The name of this symbol.\n  std::string name;\n\n  /// More detail for this symbol, e.g the signature of a function.\n  std::string detail;\n\n  /// The kind of this symbol.\n  SymbolKind kind;\n\n  /// Indicates if this symbol is deprecated.\n  bool deprecated = false;\n\n  /// The range enclosing this symbol not including leading/trailing whitespace\n  /// but everything else like comments. This information is typically used to\n  /// determine if the clients cursor is inside the symbol to reveal in the\n  /// symbol in the UI.\n  Range range;\n\n  /// The range that should be selected and revealed when this symbol is being\n  /// picked, e.g the name of a function. Must be contained by the `range`.\n  Range selectionRange;\n\n  /// Children of this symbol, e.g. properties of a class.\n  std::vector<DocumentSymbol> children;\n};\nllvm::raw_ostream &operator<<(llvm::raw_ostream &O, const DocumentSymbol &S);\nllvm::json::Value toJSON(const DocumentSymbol &S);\n\n/// Represents information about programming constructs like variables, classes,\n/// interfaces etc.\nstruct SymbolInformation {\n  /// The name of this symbol.\n  std::string name;\n\n  /// The kind of this symbol.\n  SymbolKind kind;\n\n  /// The location of this symbol.\n  Location location;\n\n  /// The name of the symbol containing this symbol.\n  std::string containerName;\n\n  /// The score that clangd calculates to rank the returned symbols.\n  /// This excludes the fuzzy-matching score between `name` and the query.\n  /// (Specifically, the last ::-separated component).\n  /// This can be used to re-rank results as the user types, using client-side\n  /// fuzzy-matching (that score should be multiplied with this one).\n  /// This is a clangd extension, set only for workspace/symbol responses.\n  llvm::Optional<float> score;\n};\nllvm::json::Value toJSON(const SymbolInformation &);\nllvm::raw_ostream &operator<<(llvm::raw_ostream &, const SymbolInformation &);\n\n/// Represents information about identifier.\n/// This is returned from textDocument/symbolInfo, which is a clangd extension.\nstruct SymbolDetails {\n  std::string name;\n\n  std::string containerName;\n\n  /// Unified Symbol Resolution identifier\n  /// This is an opaque string uniquely identifying a symbol.\n  /// Unlike SymbolID, it is variable-length and somewhat human-readable.\n  /// It is a common representation across several clang tools.\n  /// (See USRGeneration.h)\n  std::string USR;\n\n  SymbolID ID;\n};\nllvm::json::Value toJSON(const SymbolDetails &);\nllvm::raw_ostream &operator<<(llvm::raw_ostream &, const SymbolDetails &);\nbool operator==(const SymbolDetails &, const SymbolDetails &);\n\n/// The parameters of a Workspace Symbol Request.\nstruct WorkspaceSymbolParams {\n  /// A non-empty query string\n  std::string query;\n};\nbool fromJSON(const llvm::json::Value &, WorkspaceSymbolParams &,\n              llvm::json::Path);\n\nstruct ApplyWorkspaceEditParams {\n  WorkspaceEdit edit;\n};\nllvm::json::Value toJSON(const ApplyWorkspaceEditParams &);\n\nstruct ApplyWorkspaceEditResponse {\n  bool applied = true;\n  llvm::Optional<std::string> failureReason;\n};\nbool fromJSON(const llvm::json::Value &, ApplyWorkspaceEditResponse &,\n              llvm::json::Path);\n\nstruct TextDocumentPositionParams {\n  /// The text document.\n  TextDocumentIdentifier textDocument;\n\n  /// The position inside the text document.\n  Position position;\n};\nbool fromJSON(const llvm::json::Value &, TextDocumentPositionParams &,\n              llvm::json::Path);\n\nenum class CompletionTriggerKind {\n  /// Completion was triggered by typing an identifier (24x7 code\n  /// complete), manual invocation (e.g Ctrl+Space) or via API.\n  Invoked = 1,\n  /// Completion was triggered by a trigger character specified by\n  /// the `triggerCharacters` properties of the `CompletionRegistrationOptions`.\n  TriggerCharacter = 2,\n  /// Completion was re-triggered as the current completion list is incomplete.\n  TriggerTriggerForIncompleteCompletions = 3\n};\n\nstruct CompletionContext {\n  /// How the completion was triggered.\n  CompletionTriggerKind triggerKind = CompletionTriggerKind::Invoked;\n  /// The trigger character (a single character) that has trigger code complete.\n  /// Is undefined if `triggerKind !== CompletionTriggerKind.TriggerCharacter`\n  std::string triggerCharacter;\n};\nbool fromJSON(const llvm::json::Value &, CompletionContext &, llvm::json::Path);\n\nstruct CompletionParams : TextDocumentPositionParams {\n  CompletionContext context;\n};\nbool fromJSON(const llvm::json::Value &, CompletionParams &, llvm::json::Path);\n\nstruct MarkupContent {\n  MarkupKind kind = MarkupKind::PlainText;\n  std::string value;\n};\nllvm::json::Value toJSON(const MarkupContent &MC);\n\nstruct Hover {\n  /// The hover's content\n  MarkupContent contents;\n\n  /// An optional range is a range inside a text document\n  /// that is used to visualize a hover, e.g. by changing the background color.\n  llvm::Optional<Range> range;\n};\nllvm::json::Value toJSON(const Hover &H);\n\n/// Defines whether the insert text in a completion item should be interpreted\n/// as plain text or a snippet.\nenum class InsertTextFormat {\n  Missing = 0,\n  /// The primary text to be inserted is treated as a plain string.\n  PlainText = 1,\n  /// The primary text to be inserted is treated as a snippet.\n  ///\n  /// A snippet can define tab stops and placeholders with `$1`, `$2`\n  /// and `${3:foo}`. `$0` defines the final tab stop, it defaults to the end\n  /// of the snippet. Placeholders with equal identifiers are linked, that is\n  /// typing in one will update others too.\n  ///\n  /// See also:\n  /// https//github.com/Microsoft/vscode/blob/master/src/vs/editor/contrib/snippet/common/snippet.md\n  Snippet = 2,\n};\n\nstruct CompletionItem {\n  /// The label of this completion item. By default also the text that is\n  /// inserted when selecting this completion.\n  std::string label;\n\n  /// The kind of this completion item. Based of the kind an icon is chosen by\n  /// the editor.\n  CompletionItemKind kind = CompletionItemKind::Missing;\n\n  /// A human-readable string with additional information about this item, like\n  /// type or symbol information.\n  std::string detail;\n\n  /// A human-readable string that represents a doc-comment.\n  llvm::Optional<MarkupContent> documentation;\n\n  /// A string that should be used when comparing this item with other items.\n  /// When `falsy` the label is used.\n  std::string sortText;\n\n  /// A string that should be used when filtering a set of completion items.\n  /// When `falsy` the label is used.\n  std::string filterText;\n\n  /// A string that should be inserted to a document when selecting this\n  /// completion. When `falsy` the label is used.\n  std::string insertText;\n\n  /// The format of the insert text. The format applies to both the `insertText`\n  /// property and the `newText` property of a provided `textEdit`.\n  InsertTextFormat insertTextFormat = InsertTextFormat::Missing;\n\n  /// An edit which is applied to a document when selecting this completion.\n  /// When an edit is provided `insertText` is ignored.\n  ///\n  /// Note: The range of the edit must be a single line range and it must\n  /// contain the position at which completion has been requested.\n  llvm::Optional<TextEdit> textEdit;\n\n  /// An optional array of additional text edits that are applied when selecting\n  /// this completion. Edits must not overlap with the main edit nor with\n  /// themselves.\n  std::vector<TextEdit> additionalTextEdits;\n\n  /// Indicates if this item is deprecated.\n  bool deprecated = false;\n\n  /// The score that clangd calculates to rank the returned completions.\n  /// This excludes the fuzzy-match between `filterText` and the partial word.\n  /// This can be used to re-rank results as the user types, using client-side\n  /// fuzzy-matching (that score should be multiplied with this one).\n  /// This is a clangd extension.\n  float score = 0.f;\n\n  // TODO: Add custom commitCharacters for some of the completion items. For\n  // example, it makes sense to use () only for the functions.\n  // TODO(krasimir): The following optional fields defined by the language\n  // server protocol are unsupported:\n  //\n  // data?: any - A data entry field that is preserved on a completion item\n  //              between a completion and a completion resolve request.\n};\nllvm::json::Value toJSON(const CompletionItem &);\nllvm::raw_ostream &operator<<(llvm::raw_ostream &, const CompletionItem &);\n\nbool operator<(const CompletionItem &, const CompletionItem &);\n\n/// Represents a collection of completion items to be presented in the editor.\nstruct CompletionList {\n  /// The list is not complete. Further typing should result in recomputing the\n  /// list.\n  bool isIncomplete = false;\n\n  /// The completion items.\n  std::vector<CompletionItem> items;\n};\nllvm::json::Value toJSON(const CompletionList &);\n\n/// A single parameter of a particular signature.\nstruct ParameterInformation {\n\n  /// The label of this parameter. Ignored when labelOffsets is set.\n  std::string labelString;\n\n  /// Inclusive start and exclusive end offsets withing the containing signature\n  /// label.\n  /// Offsets are computed by lspLength(), which counts UTF-16 code units by\n  /// default but that can be overriden, see its documentation for details.\n  llvm::Optional<std::pair<unsigned, unsigned>> labelOffsets;\n\n  /// The documentation of this parameter. Optional.\n  std::string documentation;\n};\nllvm::json::Value toJSON(const ParameterInformation &);\n\n/// Represents the signature of something callable.\nstruct SignatureInformation {\n\n  /// The label of this signature. Mandatory.\n  std::string label;\n\n  /// The documentation of this signature. Optional.\n  std::string documentation;\n\n  /// The parameters of this signature.\n  std::vector<ParameterInformation> parameters;\n};\nllvm::json::Value toJSON(const SignatureInformation &);\nllvm::raw_ostream &operator<<(llvm::raw_ostream &,\n                              const SignatureInformation &);\n\n/// Represents the signature of a callable.\nstruct SignatureHelp {\n\n  /// The resulting signatures.\n  std::vector<SignatureInformation> signatures;\n\n  /// The active signature.\n  int activeSignature = 0;\n\n  /// The active parameter of the active signature.\n  int activeParameter = 0;\n\n  /// Position of the start of the argument list, including opening paren. e.g.\n  /// foo(\"first arg\",   \"second arg\",\n  ///    ^-argListStart   ^-cursor\n  /// This is a clangd-specific extension, it is only available via C++ API and\n  /// not currently serialized for the LSP.\n  Position argListStart;\n};\nllvm::json::Value toJSON(const SignatureHelp &);\n\nstruct RenameParams {\n  /// The document that was opened.\n  TextDocumentIdentifier textDocument;\n\n  /// The position at which this request was sent.\n  Position position;\n\n  /// The new name of the symbol.\n  std::string newName;\n};\nbool fromJSON(const llvm::json::Value &, RenameParams &, llvm::json::Path);\n\nenum class DocumentHighlightKind { Text = 1, Read = 2, Write = 3 };\n\n/// A document highlight is a range inside a text document which deserves\n/// special attention. Usually a document highlight is visualized by changing\n/// the background color of its range.\n\nstruct DocumentHighlight {\n  /// The range this highlight applies to.\n  Range range;\n\n  /// The highlight kind, default is DocumentHighlightKind.Text.\n  DocumentHighlightKind kind = DocumentHighlightKind::Text;\n\n  friend bool operator<(const DocumentHighlight &LHS,\n                        const DocumentHighlight &RHS) {\n    int LHSKind = static_cast<int>(LHS.kind);\n    int RHSKind = static_cast<int>(RHS.kind);\n    return std::tie(LHS.range, LHSKind) < std::tie(RHS.range, RHSKind);\n  }\n\n  friend bool operator==(const DocumentHighlight &LHS,\n                         const DocumentHighlight &RHS) {\n    return LHS.kind == RHS.kind && LHS.range == RHS.range;\n  }\n};\nllvm::json::Value toJSON(const DocumentHighlight &DH);\nllvm::raw_ostream &operator<<(llvm::raw_ostream &, const DocumentHighlight &);\n\nenum class TypeHierarchyDirection { Children = 0, Parents = 1, Both = 2 };\nbool fromJSON(const llvm::json::Value &E, TypeHierarchyDirection &Out,\n              llvm::json::Path);\n\n/// The type hierarchy params is an extension of the\n/// `TextDocumentPositionsParams` with optional properties which can be used to\n/// eagerly resolve the item when requesting from the server.\nstruct TypeHierarchyParams : public TextDocumentPositionParams {\n  /// The hierarchy levels to resolve. `0` indicates no level.\n  int resolve = 0;\n\n  /// The direction of the hierarchy levels to resolve.\n  TypeHierarchyDirection direction = TypeHierarchyDirection::Parents;\n};\nbool fromJSON(const llvm::json::Value &, TypeHierarchyParams &,\n              llvm::json::Path);\n\nstruct TypeHierarchyItem {\n  /// The human readable name of the hierarchy item.\n  std::string name;\n\n  /// Optional detail for the hierarchy item. It can be, for instance, the\n  /// signature of a function or method.\n  llvm::Optional<std::string> detail;\n\n  /// The kind of the hierarchy item. For instance, class or interface.\n  SymbolKind kind;\n\n  /// `true` if the hierarchy item is deprecated. Otherwise, `false`.\n  bool deprecated = false;\n\n  /// The URI of the text document where this type hierarchy item belongs to.\n  URIForFile uri;\n\n  /// The range enclosing this type hierarchy item not including\n  /// leading/trailing whitespace but everything else like comments. This\n  /// information is typically used to determine if the client's cursor is\n  /// inside the type hierarch item to reveal in the symbol in the UI.\n  Range range;\n\n  /// The range that should be selected and revealed when this type hierarchy\n  /// item is being picked, e.g. the name of a function. Must be contained by\n  /// the `range`.\n  Range selectionRange;\n\n  /// If this type hierarchy item is resolved, it contains the direct parents.\n  /// Could be empty if the item does not have direct parents. If not defined,\n  /// the parents have not been resolved yet.\n  llvm::Optional<std::vector<TypeHierarchyItem>> parents;\n\n  /// If this type hierarchy item is resolved, it contains the direct children\n  /// of the current item. Could be empty if the item does not have any\n  /// descendants. If not defined, the children have not been resolved.\n  llvm::Optional<std::vector<TypeHierarchyItem>> children;\n\n  /// An optional 'data' field, which can be used to identify a type hierarchy\n  /// item in a resolve request.\n  llvm::Optional<std::string> data;\n};\nllvm::json::Value toJSON(const TypeHierarchyItem &);\nllvm::raw_ostream &operator<<(llvm::raw_ostream &, const TypeHierarchyItem &);\nbool fromJSON(const llvm::json::Value &, TypeHierarchyItem &, llvm::json::Path);\n\n/// Parameters for the `typeHierarchy/resolve` request.\nstruct ResolveTypeHierarchyItemParams {\n  /// The item to resolve.\n  TypeHierarchyItem item;\n\n  /// The hierarchy levels to resolve. `0` indicates no level.\n  int resolve;\n\n  /// The direction of the hierarchy levels to resolve.\n  TypeHierarchyDirection direction;\n};\nbool fromJSON(const llvm::json::Value &, ResolveTypeHierarchyItemParams &,\n              llvm::json::Path);\n\nenum class SymbolTag { Deprecated = 1 };\nllvm::json::Value toJSON(SymbolTag);\n\n/// The parameter of a `textDocument/prepareCallHierarchy` request.\nstruct CallHierarchyPrepareParams : public TextDocumentPositionParams {};\n\n/// Represents programming constructs like functions or constructors\n/// in the context of call hierarchy.\nstruct CallHierarchyItem {\n  /// The name of this item.\n  std::string name;\n\n  /// The kind of this item.\n  SymbolKind kind;\n\n  /// Tags for this item.\n  std::vector<SymbolTag> tags;\n\n  /// More detaill for this item, e.g. the signature of a function.\n  std::string detail;\n\n  /// The resource identifier of this item.\n  URIForFile uri;\n\n  /// The range enclosing this symbol not including leading / trailing\n  /// whitespace but everything else, e.g. comments and code.\n  Range range;\n\n  /// The range that should be selected and revealed when this symbol\n  /// is being picked, e.g. the name of a function.\n  /// Must be contained by `Rng`.\n  Range selectionRange;\n\n  /// An optional 'data' field, which can be used to identify a call\n  /// hierarchy item in an incomingCalls or outgoingCalls request.\n  std::string data;\n};\nllvm::json::Value toJSON(const CallHierarchyItem &);\nbool fromJSON(const llvm::json::Value &, CallHierarchyItem &, llvm::json::Path);\n\n/// The parameter of a `callHierarchy/incomingCalls` request.\nstruct CallHierarchyIncomingCallsParams {\n  CallHierarchyItem item;\n};\nbool fromJSON(const llvm::json::Value &, CallHierarchyIncomingCallsParams &,\n              llvm::json::Path);\n\n/// Represents an incoming call, e.g. a caller of a method or constructor.\nstruct CallHierarchyIncomingCall {\n  /// The item that makes the call.\n  CallHierarchyItem from;\n\n  /// The range at which the calls appear.\n  /// This is relative to the caller denoted by `From`.\n  std::vector<Range> fromRanges;\n};\nllvm::json::Value toJSON(const CallHierarchyIncomingCall &);\n\n/// The parameter of a `callHierarchy/outgoingCalls` request.\nstruct CallHierarchyOutgoingCallsParams {\n  CallHierarchyItem item;\n};\nbool fromJSON(const llvm::json::Value &, CallHierarchyOutgoingCallsParams &,\n              llvm::json::Path);\n\n/// Represents an outgoing call, e.g. calling a getter from a method or\n/// a method from a constructor etc.\nstruct CallHierarchyOutgoingCall {\n  /// The item that is called.\n  CallHierarchyItem to;\n\n  /// The range at which this item is called.\n  /// This is the range relative to the caller, and not `To`.\n  std::vector<Range> fromRanges;\n};\nllvm::json::Value toJSON(const CallHierarchyOutgoingCall &);\n\nstruct ReferenceContext {\n  /// Include the declaration of the current symbol.\n  bool includeDeclaration = false;\n};\n\nstruct ReferenceParams : public TextDocumentPositionParams {\n  ReferenceContext context;\n};\nbool fromJSON(const llvm::json::Value &, ReferenceParams &, llvm::json::Path);\n\n/// Clangd extension: indicates the current state of the file in clangd,\n/// sent from server via the `textDocument/clangd.fileStatus` notification.\nstruct FileStatus {\n  /// The text document's URI.\n  URIForFile uri;\n  /// The human-readable string presents the current state of the file, can be\n  /// shown in the UI (e.g. status bar).\n  std::string state;\n  // FIXME: add detail messages.\n};\nllvm::json::Value toJSON(const FileStatus &);\n\n/// Specifies a single semantic token in the document.\n/// This struct is not part of LSP, which just encodes lists of tokens as\n/// arrays of numbers directly.\nstruct SemanticToken {\n  /// token line number, relative to the previous token\n  unsigned deltaLine = 0;\n  /// token start character, relative to the previous token\n  /// (relative to 0 or the previous token's start if they are on the same line)\n  unsigned deltaStart = 0;\n  /// the length of the token. A token cannot be multiline\n  unsigned length = 0;\n  /// will be looked up in `SemanticTokensLegend.tokenTypes`\n  unsigned tokenType = 0;\n  /// each set bit will be looked up in `SemanticTokensLegend.tokenModifiers`\n  unsigned tokenModifiers = 0;\n};\nbool operator==(const SemanticToken &, const SemanticToken &);\n\n/// A versioned set of tokens.\nstruct SemanticTokens {\n  // An optional result id. If provided and clients support delta updating\n  // the client will include the result id in the next semantic token request.\n  // A server can then instead of computing all semantic tokens again simply\n  // send a delta.\n  std::string resultId;\n\n  /// The actual tokens.\n  std::vector<SemanticToken> tokens; // encoded as a flat integer array.\n};\nllvm::json::Value toJSON(const SemanticTokens &);\n\n/// Body of textDocument/semanticTokens/full request.\nstruct SemanticTokensParams {\n  /// The text document.\n  TextDocumentIdentifier textDocument;\n};\nbool fromJSON(const llvm::json::Value &, SemanticTokensParams &,\n              llvm::json::Path);\n\n/// Body of textDocument/semanticTokens/full/delta request.\n/// Requests the changes in semantic tokens since a previous response.\nstruct SemanticTokensDeltaParams {\n  /// The text document.\n  TextDocumentIdentifier textDocument;\n  /// The previous result id.\n  std::string previousResultId;\n};\nbool fromJSON(const llvm::json::Value &Params, SemanticTokensDeltaParams &R,\n              llvm::json::Path);\n\n/// Describes a a replacement of a contiguous range of semanticTokens.\nstruct SemanticTokensEdit {\n  // LSP specifies `start` and `deleteCount` which are relative to the array\n  // encoding of the previous tokens.\n  // We use token counts instead, and translate when serializing this struct.\n  unsigned startToken = 0;\n  unsigned deleteTokens = 0;\n  std::vector<SemanticToken> tokens; // encoded as a flat integer array\n};\nllvm::json::Value toJSON(const SemanticTokensEdit &);\n\n/// This models LSP SemanticTokensDelta | SemanticTokens, which is the result of\n/// textDocument/semanticTokens/full/delta.\nstruct SemanticTokensOrDelta {\n  std::string resultId;\n  /// Set if we computed edits relative to a previous set of tokens.\n  llvm::Optional<std::vector<SemanticTokensEdit>> edits;\n  /// Set if we computed a fresh set of tokens.\n  llvm::Optional<std::vector<SemanticToken>> tokens; // encoded as integer array\n};\nllvm::json::Value toJSON(const SemanticTokensOrDelta &);\n\nstruct SelectionRangeParams {\n  /// The text document.\n  TextDocumentIdentifier textDocument;\n\n  /// The positions inside the text document.\n  std::vector<Position> positions;\n};\nbool fromJSON(const llvm::json::Value &, SelectionRangeParams &,\n              llvm::json::Path);\n\nstruct SelectionRange {\n  /**\n   * The range of this selection range.\n   */\n  Range range;\n  /**\n   * The parent selection range containing this range. Therefore `parent.range`\n   * must contain `this.range`.\n   */\n  std::unique_ptr<SelectionRange> parent;\n};\nllvm::json::Value toJSON(const SelectionRange &);\n\n/// Parameters for the document link request.\nstruct DocumentLinkParams {\n  /// The document to provide document links for.\n  TextDocumentIdentifier textDocument;\n};\nbool fromJSON(const llvm::json::Value &, DocumentLinkParams &,\n              llvm::json::Path);\n\n/// A range in a text document that links to an internal or external resource,\n/// like another text document or a web site.\nstruct DocumentLink {\n  /// The range this link applies to.\n  Range range;\n\n  /// The uri this link points to. If missing a resolve request is sent later.\n  URIForFile target;\n\n  // TODO(forster): The following optional fields defined by the language\n  // server protocol are unsupported:\n  //\n  // data?: any - A data entry field that is preserved on a document link\n  //              between a DocumentLinkRequest and a\n  //              DocumentLinkResolveRequest.\n\n  friend bool operator==(const DocumentLink &LHS, const DocumentLink &RHS) {\n    return LHS.range == RHS.range && LHS.target == RHS.target;\n  }\n\n  friend bool operator!=(const DocumentLink &LHS, const DocumentLink &RHS) {\n    return !(LHS == RHS);\n  }\n};\nllvm::json::Value toJSON(const DocumentLink &DocumentLink);\n\n// FIXME(kirillbobyrev): Add FoldingRangeClientCapabilities so we can support\n// per-line-folding editors.\nstruct FoldingRangeParams {\n  TextDocumentIdentifier textDocument;\n};\nbool fromJSON(const llvm::json::Value &, FoldingRangeParams &,\n              llvm::json::Path);\n\n/// Stores information about a region of code that can be folded.\nstruct FoldingRange {\n  unsigned startLine = 0;\n  unsigned startCharacter;\n  unsigned endLine = 0;\n  unsigned endCharacter;\n  llvm::Optional<std::string> kind;\n};\nllvm::json::Value toJSON(const FoldingRange &Range);\n\n/// Keys starting with an underscore(_) represent leaves, e.g. _total or _self\n/// for memory usage of whole subtree or only that specific node in bytes. All\n/// other keys represents children. An example:\n///   {\n///     \"_self\": 0,\n///     \"_total\": 8,\n///     \"child1\": {\n///       \"_self\": 4,\n///       \"_total\": 4,\n///     }\n///     \"child2\": {\n///       \"_self\": 2,\n///       \"_total\": 4,\n///       \"child_deep\": {\n///         \"_self\": 2,\n///         \"_total\": 2,\n///       }\n///     }\n///   }\nllvm::json::Value toJSON(const MemoryTree &MT);\n\n/// Payload for textDocument/ast request.\n/// This request is a clangd extension.\nstruct ASTParams {\n  /// The text document.\n  TextDocumentIdentifier textDocument;\n\n  /// The position of the node to be dumped.\n  /// The highest-level node that entirely contains the range will be returned.\n  Range range;\n};\nbool fromJSON(const llvm::json::Value &, ASTParams &, llvm::json::Path);\n\n/// Simplified description of a clang AST node.\n/// This is clangd's internal representation of C++ code.\nstruct ASTNode {\n  /// The general kind of node, such as \"expression\"\n  /// Corresponds to the base AST node type such as Expr.\n  std::string role;\n  /// The specific kind of node this is, such as \"BinaryOperator\".\n  /// This is usually a concrete node class (with Expr etc suffix dropped).\n  /// When there's no hierarchy (e.g. TemplateName), the variant (NameKind).\n  std::string kind;\n  /// Brief additional information, such as \"||\" for the particular operator.\n  /// The information included depends on the node kind, and may be empty.\n  std::string detail;\n  /// A one-line dump of detailed information about the node.\n  /// This includes role/kind/description information, but is rather cryptic.\n  /// It is similar to the output from `clang -Xclang -ast-dump`.\n  /// May be empty for certain types of nodes.\n  std::string arcana;\n  /// The range of the original source file covered by this node.\n  /// May be missing for implicit nodes, or those created by macro expansion.\n  llvm::Optional<Range> range;\n  /// Nodes nested within this one, such as the operands of a BinaryOperator.\n  std::vector<ASTNode> children;\n};\nllvm::json::Value toJSON(const ASTNode &);\nllvm::raw_ostream &operator<<(llvm::raw_ostream &, const ASTNode &);\n\n} // namespace clangd\n} // namespace clang\n\nnamespace llvm {\ntemplate <> struct format_provider<clang::clangd::Position> {\n  static void format(const clang::clangd::Position &Pos, raw_ostream &OS,\n                     StringRef Style) {\n    assert(Style.empty() && \"style modifiers for this type are not supported\");\n    OS << Pos;\n  }\n};\n} // namespace llvm\n\n#endif\n"}, "8": {"id": 8, "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clangd/Quality.h", "content": "//===--- Quality.h - Ranking alternatives for ambiguous queries --*- C++-*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n///\n/// Some operations such as code completion produce a set of candidates.\n/// Usually the user can choose between them, but we should put the best options\n/// at the top (they're easier to select, and more likely to be seen).\n///\n/// This file defines building blocks for ranking candidates.\n/// It's used by the features directly and also in the implementation of\n/// indexes, as indexes also need to heuristically limit their results.\n///\n/// The facilities here are:\n///   - retrieving scoring signals from e.g. indexes, AST, CodeCompletionString\n///     These are structured in a way that they can be debugged, and are fairly\n///     consistent regardless of the source.\n///   - compute scores from scoring signals. These are suitable for sorting.\n///   - sorting utilities like the TopN container.\n/// These could be split up further to isolate dependencies if we care.\n///\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_CLANG_TOOLS_EXTRA_CLANGD_QUALITY_H\n#define LLVM_CLANG_TOOLS_EXTRA_CLANGD_QUALITY_H\n\n#include \"ExpectedTypes.h\"\n#include \"FileDistance.h\"\n#include \"TUScheduler.h\"\n#include \"clang/Sema/CodeCompleteConsumer.h\"\n#include \"llvm/ADT/ArrayRef.h\"\n#include \"llvm/ADT/StringRef.h\"\n#include \"llvm/ADT/StringSet.h\"\n#include <algorithm>\n#include <functional>\n#include <vector>\n\nnamespace llvm {\nclass raw_ostream;\n} // namespace llvm\n\nnamespace clang {\nclass CodeCompletionResult;\n\nnamespace clangd {\n\nstruct Symbol;\nclass URIDistance;\n\n// Signals structs are designed to be aggregated from 0 or more sources.\n// A default instance has neutral signals, and sources are merged into it.\n// They can be dumped for debugging, and evaluate()d into a score.\n\n/// Attributes of a symbol that affect how much we like it.\nstruct SymbolQualitySignals {\n  bool Deprecated = false;\n  bool ReservedName = false; // __foo, _Foo are usually implementation details.\n                             // FIXME: make these findable once user types _.\n  bool ImplementationDetail = false;\n  unsigned References = 0;\n\n  enum SymbolCategory {\n    Unknown = 0,\n    Variable,\n    Macro,\n    Type,\n    Function,\n    Constructor,\n    Destructor,\n    Namespace,\n    Keyword,\n    Operator,\n  } Category = Unknown;\n\n  void merge(const CodeCompletionResult &SemaCCResult);\n  void merge(const Symbol &IndexResult);\n\n  // Condense these signals down to a single number, higher is better.\n  float evaluateHeuristics() const;\n};\nllvm::raw_ostream &operator<<(llvm::raw_ostream &,\n                              const SymbolQualitySignals &);\n\n/// Attributes of a symbol-query pair that affect how much we like it.\nstruct SymbolRelevanceSignals {\n  /// The name of the symbol (for ContextWords). Must be explicitly assigned.\n  llvm::StringRef Name;\n  /// 0-1+ fuzzy-match score for unqualified name. Must be explicitly assigned.\n  float NameMatch = 1;\n  /// Lowercase words relevant to the context (e.g. near the completion point).\n  llvm::StringSet<>* ContextWords = nullptr;\n  bool Forbidden = false; // Unavailable (e.g const) or inaccessible (private).\n  /// Whether fixits needs to be applied for that completion or not.\n  bool NeedsFixIts = false;\n  bool InBaseClass = false; // A member from base class of the accessed class.\n\n  URIDistance *FileProximityMatch = nullptr;\n  /// These are used to calculate proximity between the index symbol and the\n  /// query.\n  llvm::StringRef SymbolURI;\n  /// FIXME: unify with index proximity score - signals should be\n  /// source-independent.\n  /// Proximity between best declaration and the query. [0-1], 1 is closest.\n  float SemaFileProximityScore = 0;\n\n  // Scope proximity is only considered (both index and sema) when this is set.\n  ScopeDistance *ScopeProximityMatch = nullptr;\n  llvm::Optional<llvm::StringRef> SymbolScope;\n  // A symbol from sema should be accessible from the current scope.\n  bool SemaSaysInScope = false;\n\n  // An approximate measure of where we expect the symbol to be used.\n  enum AccessibleScope {\n    FunctionScope,\n    ClassScope,\n    FileScope,\n    GlobalScope,\n  } Scope = GlobalScope;\n\n  enum QueryType {\n    CodeComplete,\n    Generic,\n  } Query = Generic;\n\n  CodeCompletionContext::Kind Context = CodeCompletionContext::CCC_Other;\n\n  // Whether symbol is an instance member of a class.\n  bool IsInstanceMember = false;\n\n  // Whether clang provided a preferred type in the completion context.\n  bool HadContextType = false;\n  // Whether a source completion item or a symbol had a type information.\n  bool HadSymbolType = false;\n  // Whether the item matches the type expected in the completion context.\n  bool TypeMatchesPreferred = false;\n\n  /// Length of the unqualified partial name of Symbol typed in\n  /// CompletionPrefix.\n  unsigned FilterLength = 0;\n\n  const ASTSignals *MainFileSignals = nullptr;\n  /// Number of references to the candidate in the main file.\n  unsigned MainFileRefs = 0;\n  /// Number of unique symbols in the main file which belongs to candidate's\n  /// namespace. This indicates how relevant the namespace is in the current\n  /// file.\n  unsigned ScopeRefsInFile = 0;\n\n  /// Set of derived signals computed by calculateDerivedSignals(). Must not be\n  /// set explicitly.\n  struct DerivedSignals {\n    /// Whether Name contains some word from context.\n    bool NameMatchesContext = false;\n    /// Min distance between SymbolURI and all the headers included by the TU.\n    unsigned FileProximityDistance = FileDistance::Unreachable;\n    /// Min distance between SymbolScope and all the available scopes.\n    unsigned ScopeProximityDistance = FileDistance::Unreachable;\n  };\n\n  DerivedSignals calculateDerivedSignals() const;\n\n  void merge(const CodeCompletionResult &SemaResult);\n  void merge(const Symbol &IndexResult);\n  void computeASTSignals(const CodeCompletionResult &SemaResult);\n\n  // Condense these signals down to a single number, higher is better.\n  float evaluateHeuristics() const;\n};\nllvm::raw_ostream &operator<<(llvm::raw_ostream &,\n                              const SymbolRelevanceSignals &);\n\n/// Combine symbol quality and relevance into a single score.\nfloat evaluateSymbolAndRelevance(float SymbolQuality, float SymbolRelevance);\n\n/// Same semantics as CodeComplete::Score. Quality score and Relevance score\n/// have been removed since DecisionForest cannot assign individual scores to\n/// Quality and Relevance signals.\nstruct DecisionForestScores {\n  float Total = 0.f;\n  float ExcludingName = 0.f;\n};\n\nDecisionForestScores\nevaluateDecisionForest(const SymbolQualitySignals &Quality,\n                       const SymbolRelevanceSignals &Relevance, float Base);\n\n/// TopN<T> is a lossy container that preserves only the \"best\" N elements.\ntemplate <typename T, typename Compare = std::greater<T>> class TopN {\npublic:\n  using value_type = T;\n  TopN(size_t N, Compare Greater = Compare())\n      : N(N), Greater(std::move(Greater)) {}\n\n  // Adds a candidate to the set.\n  // Returns true if a candidate was dropped to get back under N.\n  bool push(value_type &&V) {\n    bool Dropped = false;\n    if (Heap.size() >= N) {\n      Dropped = true;\n      if (N > 0 && Greater(V, Heap.front())) {\n        std::pop_heap(Heap.begin(), Heap.end(), Greater);\n        Heap.back() = std::move(V);\n        std::push_heap(Heap.begin(), Heap.end(), Greater);\n      }\n    } else {\n      Heap.push_back(std::move(V));\n      std::push_heap(Heap.begin(), Heap.end(), Greater);\n    }\n    assert(Heap.size() <= N);\n    assert(std::is_heap(Heap.begin(), Heap.end(), Greater));\n    return Dropped;\n  }\n\n  // Returns candidates from best to worst.\n  std::vector<value_type> items() && {\n    std::sort_heap(Heap.begin(), Heap.end(), Greater);\n    assert(Heap.size() <= N);\n    return std::move(Heap);\n  }\n\nprivate:\n  const size_t N;\n  std::vector<value_type> Heap; // Min-heap, comparator is Greater.\n  Compare Greater;\n};\n\n/// Returns a string that sorts in the same order as (-Score, Tiebreak), for\n/// LSP. (The highest score compares smallest so it sorts at the top).\nstd::string sortText(float Score, llvm::StringRef Tiebreak = \"\");\n\nstruct SignatureQualitySignals {\n  uint32_t NumberOfParameters = 0;\n  uint32_t NumberOfOptionalParameters = 0;\n  CodeCompleteConsumer::OverloadCandidate::CandidateKind Kind =\n      CodeCompleteConsumer::OverloadCandidate::CandidateKind::CK_Function;\n};\nllvm::raw_ostream &operator<<(llvm::raw_ostream &,\n                              const SignatureQualitySignals &);\n\n} // namespace clangd\n} // namespace clang\n\n#endif // LLVM_CLANG_TOOLS_EXTRA_CLANGD_QUALITY_H\n"}, "21": {"id": 21, "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clangd/unittests/Annotations.h", "content": "//===--- Annotations.h - Annotated source code for tests ---------*- C++-*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n// A clangd-specific version of llvm/Testing/Support/Annotations.h, replaces\n// offsets and offset-based ranges with types from the LSP protocol.\n//===---------------------------------------------------------------------===//\n\n#ifndef LLVM_CLANG_TOOLS_EXTRA_UNITTESTS_CLANGD_ANNOTATIONS_H\n#define LLVM_CLANG_TOOLS_EXTRA_UNITTESTS_CLANGD_ANNOTATIONS_H\n\n#include \"Protocol.h\"\n#include \"llvm/Testing/Support/Annotations.h\"\n\nnamespace clang {\nnamespace clangd {\n\n/// Same as llvm::Annotations, but adjusts functions to LSP-specific types for\n/// positions and ranges.\nclass Annotations : public llvm::Annotations {\n  using Base = llvm::Annotations;\n\npublic:\n  using llvm::Annotations::Annotations;\n\n  Position point(llvm::StringRef Name = \"\") const;\n  std::vector<Position> points(llvm::StringRef Name = \"\") const;\n\n  clangd::Range range(llvm::StringRef Name = \"\") const;\n  std::vector<clangd::Range> ranges(llvm::StringRef Name = \"\") const;\n};\n\n} // namespace clangd\n} // namespace clang\n\n#endif // LLVM_CLANG_TOOLS_EXTRA_UNITTESTS_CLANGD_ANNOTATIONS_H\n"}, "23": {"id": 23, "path": "/home/vsts/work/1/llvm-project/llvm/utils/unittest/googlemock/include/gmock/gmock-generated-matchers.h", "content": "// This file was GENERATED by command:\n//     pump.py gmock-generated-matchers.h.pump\n// DO NOT EDIT BY HAND!!!\n\n// Copyright 2008, Google Inc.\n// All rights reserved.\n//\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions are\n// met:\n//\n//     * Redistributions of source code must retain the above copyright\n// notice, this list of conditions and the following disclaimer.\n//     * Redistributions in binary form must reproduce the above\n// copyright notice, this list of conditions and the following disclaimer\n// in the documentation and/or other materials provided with the\n// distribution.\n//     * Neither the name of Google Inc. nor the names of its\n// contributors may be used to endorse or promote products derived from\n// this software without specific prior written permission.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n// \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\n// Google Mock - a framework for writing C++ mock classes.\n//\n// This file implements some commonly used variadic matchers.\n\n// IWYU pragma: private, include \"gmock/gmock.h\"\n\n#ifndef GMOCK_INCLUDE_GMOCK_GMOCK_GENERATED_MATCHERS_H_\n#define GMOCK_INCLUDE_GMOCK_GMOCK_GENERATED_MATCHERS_H_\n\n#include <iterator>\n#include <sstream>\n#include <string>\n#include <vector>\n#include \"gmock/gmock-matchers.h\"\n\nnamespace testing {\nnamespace internal {\n\n// The type of the i-th (0-based) field of Tuple.\n#define GMOCK_FIELD_TYPE_(Tuple, i) \\\n    typename ::testing::tuple_element<i, Tuple>::type\n\n// TupleFields<Tuple, k0, ..., kn> is for selecting fields from a\n// tuple of type Tuple.  It has two members:\n//\n//   type: a tuple type whose i-th field is the ki-th field of Tuple.\n//   GetSelectedFields(t): returns fields k0, ..., and kn of t as a tuple.\n//\n// For example, in class TupleFields<tuple<bool, char, int>, 2, 0>, we have:\n//\n//   type is tuple<int, bool>, and\n//   GetSelectedFields(make_tuple(true, 'a', 42)) is (42, true).\n\ntemplate <class Tuple, int k0 = -1, int k1 = -1, int k2 = -1, int k3 = -1,\n    int k4 = -1, int k5 = -1, int k6 = -1, int k7 = -1, int k8 = -1,\n    int k9 = -1>\nclass TupleFields;\n\n// This generic version is used when there are 10 selectors.\ntemplate <class Tuple, int k0, int k1, int k2, int k3, int k4, int k5, int k6,\n    int k7, int k8, int k9>\nclass TupleFields {\n public:\n  typedef ::testing::tuple<GMOCK_FIELD_TYPE_(Tuple, k0),\n      GMOCK_FIELD_TYPE_(Tuple, k1), GMOCK_FIELD_TYPE_(Tuple, k2),\n      GMOCK_FIELD_TYPE_(Tuple, k3), GMOCK_FIELD_TYPE_(Tuple, k4),\n      GMOCK_FIELD_TYPE_(Tuple, k5), GMOCK_FIELD_TYPE_(Tuple, k6),\n      GMOCK_FIELD_TYPE_(Tuple, k7), GMOCK_FIELD_TYPE_(Tuple, k8),\n      GMOCK_FIELD_TYPE_(Tuple, k9)> type;\n  static type GetSelectedFields(const Tuple& t) {\n    return type(get<k0>(t), get<k1>(t), get<k2>(t), get<k3>(t), get<k4>(t),\n        get<k5>(t), get<k6>(t), get<k7>(t), get<k8>(t), get<k9>(t));\n  }\n};\n\n// The following specialization is used for 0 ~ 9 selectors.\n\ntemplate <class Tuple>\nclass TupleFields<Tuple, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1> {\n public:\n  typedef ::testing::tuple<> type;\n  static type GetSelectedFields(const Tuple& /* t */) {\n    return type();\n  }\n};\n\ntemplate <class Tuple, int k0>\nclass TupleFields<Tuple, k0, -1, -1, -1, -1, -1, -1, -1, -1, -1> {\n public:\n  typedef ::testing::tuple<GMOCK_FIELD_TYPE_(Tuple, k0)> type;\n  static type GetSelectedFields(const Tuple& t) {\n    return type(get<k0>(t));\n  }\n};\n\ntemplate <class Tuple, int k0, int k1>\nclass TupleFields<Tuple, k0, k1, -1, -1, -1, -1, -1, -1, -1, -1> {\n public:\n  typedef ::testing::tuple<GMOCK_FIELD_TYPE_(Tuple, k0),\n      GMOCK_FIELD_TYPE_(Tuple, k1)> type;\n  static type GetSelectedFields(const Tuple& t) {\n    return type(get<k0>(t), get<k1>(t));\n  }\n};\n\ntemplate <class Tuple, int k0, int k1, int k2>\nclass TupleFields<Tuple, k0, k1, k2, -1, -1, -1, -1, -1, -1, -1> {\n public:\n  typedef ::testing::tuple<GMOCK_FIELD_TYPE_(Tuple, k0),\n      GMOCK_FIELD_TYPE_(Tuple, k1), GMOCK_FIELD_TYPE_(Tuple, k2)> type;\n  static type GetSelectedFields(const Tuple& t) {\n    return type(get<k0>(t), get<k1>(t), get<k2>(t));\n  }\n};\n\ntemplate <class Tuple, int k0, int k1, int k2, int k3>\nclass TupleFields<Tuple, k0, k1, k2, k3, -1, -1, -1, -1, -1, -1> {\n public:\n  typedef ::testing::tuple<GMOCK_FIELD_TYPE_(Tuple, k0),\n      GMOCK_FIELD_TYPE_(Tuple, k1), GMOCK_FIELD_TYPE_(Tuple, k2),\n      GMOCK_FIELD_TYPE_(Tuple, k3)> type;\n  static type GetSelectedFields(const Tuple& t) {\n    return type(get<k0>(t), get<k1>(t), get<k2>(t), get<k3>(t));\n  }\n};\n\ntemplate <class Tuple, int k0, int k1, int k2, int k3, int k4>\nclass TupleFields<Tuple, k0, k1, k2, k3, k4, -1, -1, -1, -1, -1> {\n public:\n  typedef ::testing::tuple<GMOCK_FIELD_TYPE_(Tuple, k0),\n      GMOCK_FIELD_TYPE_(Tuple, k1), GMOCK_FIELD_TYPE_(Tuple, k2),\n      GMOCK_FIELD_TYPE_(Tuple, k3), GMOCK_FIELD_TYPE_(Tuple, k4)> type;\n  static type GetSelectedFields(const Tuple& t) {\n    return type(get<k0>(t), get<k1>(t), get<k2>(t), get<k3>(t), get<k4>(t));\n  }\n};\n\ntemplate <class Tuple, int k0, int k1, int k2, int k3, int k4, int k5>\nclass TupleFields<Tuple, k0, k1, k2, k3, k4, k5, -1, -1, -1, -1> {\n public:\n  typedef ::testing::tuple<GMOCK_FIELD_TYPE_(Tuple, k0),\n      GMOCK_FIELD_TYPE_(Tuple, k1), GMOCK_FIELD_TYPE_(Tuple, k2),\n      GMOCK_FIELD_TYPE_(Tuple, k3), GMOCK_FIELD_TYPE_(Tuple, k4),\n      GMOCK_FIELD_TYPE_(Tuple, k5)> type;\n  static type GetSelectedFields(const Tuple& t) {\n    return type(get<k0>(t), get<k1>(t), get<k2>(t), get<k3>(t), get<k4>(t),\n        get<k5>(t));\n  }\n};\n\ntemplate <class Tuple, int k0, int k1, int k2, int k3, int k4, int k5, int k6>\nclass TupleFields<Tuple, k0, k1, k2, k3, k4, k5, k6, -1, -1, -1> {\n public:\n  typedef ::testing::tuple<GMOCK_FIELD_TYPE_(Tuple, k0),\n      GMOCK_FIELD_TYPE_(Tuple, k1), GMOCK_FIELD_TYPE_(Tuple, k2),\n      GMOCK_FIELD_TYPE_(Tuple, k3), GMOCK_FIELD_TYPE_(Tuple, k4),\n      GMOCK_FIELD_TYPE_(Tuple, k5), GMOCK_FIELD_TYPE_(Tuple, k6)> type;\n  static type GetSelectedFields(const Tuple& t) {\n    return type(get<k0>(t), get<k1>(t), get<k2>(t), get<k3>(t), get<k4>(t),\n        get<k5>(t), get<k6>(t));\n  }\n};\n\ntemplate <class Tuple, int k0, int k1, int k2, int k3, int k4, int k5, int k6,\n    int k7>\nclass TupleFields<Tuple, k0, k1, k2, k3, k4, k5, k6, k7, -1, -1> {\n public:\n  typedef ::testing::tuple<GMOCK_FIELD_TYPE_(Tuple, k0),\n      GMOCK_FIELD_TYPE_(Tuple, k1), GMOCK_FIELD_TYPE_(Tuple, k2),\n      GMOCK_FIELD_TYPE_(Tuple, k3), GMOCK_FIELD_TYPE_(Tuple, k4),\n      GMOCK_FIELD_TYPE_(Tuple, k5), GMOCK_FIELD_TYPE_(Tuple, k6),\n      GMOCK_FIELD_TYPE_(Tuple, k7)> type;\n  static type GetSelectedFields(const Tuple& t) {\n    return type(get<k0>(t), get<k1>(t), get<k2>(t), get<k3>(t), get<k4>(t),\n        get<k5>(t), get<k6>(t), get<k7>(t));\n  }\n};\n\ntemplate <class Tuple, int k0, int k1, int k2, int k3, int k4, int k5, int k6,\n    int k7, int k8>\nclass TupleFields<Tuple, k0, k1, k2, k3, k4, k5, k6, k7, k8, -1> {\n public:\n  typedef ::testing::tuple<GMOCK_FIELD_TYPE_(Tuple, k0),\n      GMOCK_FIELD_TYPE_(Tuple, k1), GMOCK_FIELD_TYPE_(Tuple, k2),\n      GMOCK_FIELD_TYPE_(Tuple, k3), GMOCK_FIELD_TYPE_(Tuple, k4),\n      GMOCK_FIELD_TYPE_(Tuple, k5), GMOCK_FIELD_TYPE_(Tuple, k6),\n      GMOCK_FIELD_TYPE_(Tuple, k7), GMOCK_FIELD_TYPE_(Tuple, k8)> type;\n  static type GetSelectedFields(const Tuple& t) {\n    return type(get<k0>(t), get<k1>(t), get<k2>(t), get<k3>(t), get<k4>(t),\n        get<k5>(t), get<k6>(t), get<k7>(t), get<k8>(t));\n  }\n};\n\n#undef GMOCK_FIELD_TYPE_\n\n// Implements the Args() matcher.\ntemplate <class ArgsTuple, int k0 = -1, int k1 = -1, int k2 = -1, int k3 = -1,\n    int k4 = -1, int k5 = -1, int k6 = -1, int k7 = -1, int k8 = -1,\n    int k9 = -1>\nclass ArgsMatcherImpl : public MatcherInterface<ArgsTuple> {\n public:\n  // ArgsTuple may have top-level const or reference modifiers.\n  typedef GTEST_REMOVE_REFERENCE_AND_CONST_(ArgsTuple) RawArgsTuple;\n  typedef typename internal::TupleFields<RawArgsTuple, k0, k1, k2, k3, k4, k5,\n      k6, k7, k8, k9>::type SelectedArgs;\n  typedef Matcher<const SelectedArgs&> MonomorphicInnerMatcher;\n\n  template <typename InnerMatcher>\n  explicit ArgsMatcherImpl(const InnerMatcher& inner_matcher)\n      : inner_matcher_(SafeMatcherCast<const SelectedArgs&>(inner_matcher)) {}\n\n  virtual bool MatchAndExplain(ArgsTuple args,\n                               MatchResultListener* listener) const {\n    const SelectedArgs& selected_args = GetSelectedArgs(args);\n    if (!listener->IsInterested())\n      return inner_matcher_.Matches(selected_args);\n\n    PrintIndices(listener->stream());\n    *listener << \"are \" << PrintToString(selected_args);\n\n    StringMatchResultListener inner_listener;\n    const bool match = inner_matcher_.MatchAndExplain(selected_args,\n                                                      &inner_listener);\n    PrintIfNotEmpty(inner_listener.str(), listener->stream());\n    return match;\n  }\n\n  virtual void DescribeTo(::std::ostream* os) const {\n    *os << \"are a tuple \";\n    PrintIndices(os);\n    inner_matcher_.DescribeTo(os);\n  }\n\n  virtual void DescribeNegationTo(::std::ostream* os) const {\n    *os << \"are a tuple \";\n    PrintIndices(os);\n    inner_matcher_.DescribeNegationTo(os);\n  }\n\n private:\n  static SelectedArgs GetSelectedArgs(ArgsTuple args) {\n    return TupleFields<RawArgsTuple, k0, k1, k2, k3, k4, k5, k6, k7, k8,\n        k9>::GetSelectedFields(args);\n  }\n\n  // Prints the indices of the selected fields.\n  static void PrintIndices(::std::ostream* os) {\n    *os << \"whose fields (\";\n    const int indices[10] = { k0, k1, k2, k3, k4, k5, k6, k7, k8, k9 };\n    for (int i = 0; i < 10; i++) {\n      if (indices[i] < 0)\n        break;\n\n      if (i >= 1)\n        *os << \", \";\n\n      *os << \"#\" << indices[i];\n    }\n    *os << \") \";\n  }\n\n  const MonomorphicInnerMatcher inner_matcher_;\n\n  GTEST_DISALLOW_ASSIGN_(ArgsMatcherImpl);\n};\n\ntemplate <class InnerMatcher, int k0 = -1, int k1 = -1, int k2 = -1,\n    int k3 = -1, int k4 = -1, int k5 = -1, int k6 = -1, int k7 = -1,\n    int k8 = -1, int k9 = -1>\nclass ArgsMatcher {\n public:\n  explicit ArgsMatcher(const InnerMatcher& inner_matcher)\n      : inner_matcher_(inner_matcher) {}\n\n  template <typename ArgsTuple>\n  operator Matcher<ArgsTuple>() const {\n    return MakeMatcher(new ArgsMatcherImpl<ArgsTuple, k0, k1, k2, k3, k4, k5,\n        k6, k7, k8, k9>(inner_matcher_));\n  }\n\n private:\n  const InnerMatcher inner_matcher_;\n\n  GTEST_DISALLOW_ASSIGN_(ArgsMatcher);\n};\n\n// A set of metafunctions for computing the result type of AllOf.\n// AllOf(m1, ..., mN) returns\n// AllOfResultN<decltype(m1), ..., decltype(mN)>::type.\n\n// Although AllOf isn't defined for one argument, AllOfResult1 is defined\n// to simplify the implementation.\ntemplate <typename M1>\nstruct AllOfResult1 {\n  typedef M1 type;\n};\n\ntemplate <typename M1, typename M2>\nstruct AllOfResult2 {\n  typedef BothOfMatcher<\n      typename AllOfResult1<M1>::type,\n      typename AllOfResult1<M2>::type\n  > type;\n};\n\ntemplate <typename M1, typename M2, typename M3>\nstruct AllOfResult3 {\n  typedef BothOfMatcher<\n      typename AllOfResult1<M1>::type,\n      typename AllOfResult2<M2, M3>::type\n  > type;\n};\n\ntemplate <typename M1, typename M2, typename M3, typename M4>\nstruct AllOfResult4 {\n  typedef BothOfMatcher<\n      typename AllOfResult2<M1, M2>::type,\n      typename AllOfResult2<M3, M4>::type\n  > type;\n};\n\ntemplate <typename M1, typename M2, typename M3, typename M4, typename M5>\nstruct AllOfResult5 {\n  typedef BothOfMatcher<\n      typename AllOfResult2<M1, M2>::type,\n      typename AllOfResult3<M3, M4, M5>::type\n  > type;\n};\n\ntemplate <typename M1, typename M2, typename M3, typename M4, typename M5,\n    typename M6>\nstruct AllOfResult6 {\n  typedef BothOfMatcher<\n      typename AllOfResult3<M1, M2, M3>::type,\n      typename AllOfResult3<M4, M5, M6>::type\n  > type;\n};\n\ntemplate <typename M1, typename M2, typename M3, typename M4, typename M5,\n    typename M6, typename M7>\nstruct AllOfResult7 {\n  typedef BothOfMatcher<\n      typename AllOfResult3<M1, M2, M3>::type,\n      typename AllOfResult4<M4, M5, M6, M7>::type\n  > type;\n};\n\ntemplate <typename M1, typename M2, typename M3, typename M4, typename M5,\n    typename M6, typename M7, typename M8>\nstruct AllOfResult8 {\n  typedef BothOfMatcher<\n      typename AllOfResult4<M1, M2, M3, M4>::type,\n      typename AllOfResult4<M5, M6, M7, M8>::type\n  > type;\n};\n\ntemplate <typename M1, typename M2, typename M3, typename M4, typename M5,\n    typename M6, typename M7, typename M8, typename M9>\nstruct AllOfResult9 {\n  typedef BothOfMatcher<\n      typename AllOfResult4<M1, M2, M3, M4>::type,\n      typename AllOfResult5<M5, M6, M7, M8, M9>::type\n  > type;\n};\n\ntemplate <typename M1, typename M2, typename M3, typename M4, typename M5,\n    typename M6, typename M7, typename M8, typename M9, typename M10>\nstruct AllOfResult10 {\n  typedef BothOfMatcher<\n      typename AllOfResult5<M1, M2, M3, M4, M5>::type,\n      typename AllOfResult5<M6, M7, M8, M9, M10>::type\n  > type;\n};\n\n// A set of metafunctions for computing the result type of AnyOf.\n// AnyOf(m1, ..., mN) returns\n// AnyOfResultN<decltype(m1), ..., decltype(mN)>::type.\n\n// Although AnyOf isn't defined for one argument, AnyOfResult1 is defined\n// to simplify the implementation.\ntemplate <typename M1>\nstruct AnyOfResult1 {\n  typedef M1 type;\n};\n\ntemplate <typename M1, typename M2>\nstruct AnyOfResult2 {\n  typedef EitherOfMatcher<\n      typename AnyOfResult1<M1>::type,\n      typename AnyOfResult1<M2>::type\n  > type;\n};\n\ntemplate <typename M1, typename M2, typename M3>\nstruct AnyOfResult3 {\n  typedef EitherOfMatcher<\n      typename AnyOfResult1<M1>::type,\n      typename AnyOfResult2<M2, M3>::type\n  > type;\n};\n\ntemplate <typename M1, typename M2, typename M3, typename M4>\nstruct AnyOfResult4 {\n  typedef EitherOfMatcher<\n      typename AnyOfResult2<M1, M2>::type,\n      typename AnyOfResult2<M3, M4>::type\n  > type;\n};\n\ntemplate <typename M1, typename M2, typename M3, typename M4, typename M5>\nstruct AnyOfResult5 {\n  typedef EitherOfMatcher<\n      typename AnyOfResult2<M1, M2>::type,\n      typename AnyOfResult3<M3, M4, M5>::type\n  > type;\n};\n\ntemplate <typename M1, typename M2, typename M3, typename M4, typename M5,\n    typename M6>\nstruct AnyOfResult6 {\n  typedef EitherOfMatcher<\n      typename AnyOfResult3<M1, M2, M3>::type,\n      typename AnyOfResult3<M4, M5, M6>::type\n  > type;\n};\n\ntemplate <typename M1, typename M2, typename M3, typename M4, typename M5,\n    typename M6, typename M7>\nstruct AnyOfResult7 {\n  typedef EitherOfMatcher<\n      typename AnyOfResult3<M1, M2, M3>::type,\n      typename AnyOfResult4<M4, M5, M6, M7>::type\n  > type;\n};\n\ntemplate <typename M1, typename M2, typename M3, typename M4, typename M5,\n    typename M6, typename M7, typename M8>\nstruct AnyOfResult8 {\n  typedef EitherOfMatcher<\n      typename AnyOfResult4<M1, M2, M3, M4>::type,\n      typename AnyOfResult4<M5, M6, M7, M8>::type\n  > type;\n};\n\ntemplate <typename M1, typename M2, typename M3, typename M4, typename M5,\n    typename M6, typename M7, typename M8, typename M9>\nstruct AnyOfResult9 {\n  typedef EitherOfMatcher<\n      typename AnyOfResult4<M1, M2, M3, M4>::type,\n      typename AnyOfResult5<M5, M6, M7, M8, M9>::type\n  > type;\n};\n\ntemplate <typename M1, typename M2, typename M3, typename M4, typename M5,\n    typename M6, typename M7, typename M8, typename M9, typename M10>\nstruct AnyOfResult10 {\n  typedef EitherOfMatcher<\n      typename AnyOfResult5<M1, M2, M3, M4, M5>::type,\n      typename AnyOfResult5<M6, M7, M8, M9, M10>::type\n  > type;\n};\n\n}  // namespace internal\n\n// Args<N1, N2, ..., Nk>(a_matcher) matches a tuple if the selected\n// fields of it matches a_matcher.  C++ doesn't support default\n// arguments for function templates, so we have to overload it.\ntemplate <typename InnerMatcher>\ninline internal::ArgsMatcher<InnerMatcher>\nArgs(const InnerMatcher& matcher) {\n  return internal::ArgsMatcher<InnerMatcher>(matcher);\n}\n\ntemplate <int k1, typename InnerMatcher>\ninline internal::ArgsMatcher<InnerMatcher, k1>\nArgs(const InnerMatcher& matcher) {\n  return internal::ArgsMatcher<InnerMatcher, k1>(matcher);\n}\n\ntemplate <int k1, int k2, typename InnerMatcher>\ninline internal::ArgsMatcher<InnerMatcher, k1, k2>\nArgs(const InnerMatcher& matcher) {\n  return internal::ArgsMatcher<InnerMatcher, k1, k2>(matcher);\n}\n\ntemplate <int k1, int k2, int k3, typename InnerMatcher>\ninline internal::ArgsMatcher<InnerMatcher, k1, k2, k3>\nArgs(const InnerMatcher& matcher) {\n  return internal::ArgsMatcher<InnerMatcher, k1, k2, k3>(matcher);\n}\n\ntemplate <int k1, int k2, int k3, int k4, typename InnerMatcher>\ninline internal::ArgsMatcher<InnerMatcher, k1, k2, k3, k4>\nArgs(const InnerMatcher& matcher) {\n  return internal::ArgsMatcher<InnerMatcher, k1, k2, k3, k4>(matcher);\n}\n\ntemplate <int k1, int k2, int k3, int k4, int k5, typename InnerMatcher>\ninline internal::ArgsMatcher<InnerMatcher, k1, k2, k3, k4, k5>\nArgs(const InnerMatcher& matcher) {\n  return internal::ArgsMatcher<InnerMatcher, k1, k2, k3, k4, k5>(matcher);\n}\n\ntemplate <int k1, int k2, int k3, int k4, int k5, int k6, typename InnerMatcher>\ninline internal::ArgsMatcher<InnerMatcher, k1, k2, k3, k4, k5, k6>\nArgs(const InnerMatcher& matcher) {\n  return internal::ArgsMatcher<InnerMatcher, k1, k2, k3, k4, k5, k6>(matcher);\n}\n\ntemplate <int k1, int k2, int k3, int k4, int k5, int k6, int k7,\n    typename InnerMatcher>\ninline internal::ArgsMatcher<InnerMatcher, k1, k2, k3, k4, k5, k6, k7>\nArgs(const InnerMatcher& matcher) {\n  return internal::ArgsMatcher<InnerMatcher, k1, k2, k3, k4, k5, k6,\n      k7>(matcher);\n}\n\ntemplate <int k1, int k2, int k3, int k4, int k5, int k6, int k7, int k8,\n    typename InnerMatcher>\ninline internal::ArgsMatcher<InnerMatcher, k1, k2, k3, k4, k5, k6, k7, k8>\nArgs(const InnerMatcher& matcher) {\n  return internal::ArgsMatcher<InnerMatcher, k1, k2, k3, k4, k5, k6, k7,\n      k8>(matcher);\n}\n\ntemplate <int k1, int k2, int k3, int k4, int k5, int k6, int k7, int k8,\n    int k9, typename InnerMatcher>\ninline internal::ArgsMatcher<InnerMatcher, k1, k2, k3, k4, k5, k6, k7, k8, k9>\nArgs(const InnerMatcher& matcher) {\n  return internal::ArgsMatcher<InnerMatcher, k1, k2, k3, k4, k5, k6, k7, k8,\n      k9>(matcher);\n}\n\ntemplate <int k1, int k2, int k3, int k4, int k5, int k6, int k7, int k8,\n    int k9, int k10, typename InnerMatcher>\ninline internal::ArgsMatcher<InnerMatcher, k1, k2, k3, k4, k5, k6, k7, k8, k9,\n    k10>\nArgs(const InnerMatcher& matcher) {\n  return internal::ArgsMatcher<InnerMatcher, k1, k2, k3, k4, k5, k6, k7, k8,\n      k9, k10>(matcher);\n}\n\n// ElementsAre(e_1, e_2, ... e_n) matches an STL-style container with\n// n elements, where the i-th element in the container must\n// match the i-th argument in the list.  Each argument of\n// ElementsAre() can be either a value or a matcher.  We support up to\n// 10 arguments.\n//\n// The use of DecayArray in the implementation allows ElementsAre()\n// to accept string literals, whose type is const char[N], but we\n// want to treat them as const char*.\n//\n// NOTE: Since ElementsAre() cares about the order of the elements, it\n// must not be used with containers whose elements's order is\n// undefined (e.g. hash_map).\n\ninline internal::ElementsAreMatcher<\n    ::testing::tuple<> >\nElementsAre() {\n  typedef ::testing::tuple<> Args;\n  return internal::ElementsAreMatcher<Args>(Args());\n}\n\ntemplate <typename T1>\ninline internal::ElementsAreMatcher<\n    ::testing::tuple<\n        typename internal::DecayArray<T1>::type> >\nElementsAre(const T1& e1) {\n  typedef ::testing::tuple<\n      typename internal::DecayArray<T1>::type> Args;\n  return internal::ElementsAreMatcher<Args>(Args(e1));\n}\n\ntemplate <typename T1, typename T2>\ninline internal::ElementsAreMatcher<\n    ::testing::tuple<\n        typename internal::DecayArray<T1>::type,\n        typename internal::DecayArray<T2>::type> >\nElementsAre(const T1& e1, const T2& e2) {\n  typedef ::testing::tuple<\n      typename internal::DecayArray<T1>::type,\n      typename internal::DecayArray<T2>::type> Args;\n  return internal::ElementsAreMatcher<Args>(Args(e1, e2));\n}\n\ntemplate <typename T1, typename T2, typename T3>\ninline internal::ElementsAreMatcher<\n    ::testing::tuple<\n        typename internal::DecayArray<T1>::type,\n        typename internal::DecayArray<T2>::type,\n        typename internal::DecayArray<T3>::type> >\nElementsAre(const T1& e1, const T2& e2, const T3& e3) {\n  typedef ::testing::tuple<\n      typename internal::DecayArray<T1>::type,\n      typename internal::DecayArray<T2>::type,\n      typename internal::DecayArray<T3>::type> Args;\n  return internal::ElementsAreMatcher<Args>(Args(e1, e2, e3));\n}\n\ntemplate <typename T1, typename T2, typename T3, typename T4>\ninline internal::ElementsAreMatcher<\n    ::testing::tuple<\n        typename internal::DecayArray<T1>::type,\n        typename internal::DecayArray<T2>::type,\n        typename internal::DecayArray<T3>::type,\n        typename internal::DecayArray<T4>::type> >\nElementsAre(const T1& e1, const T2& e2, const T3& e3, const T4& e4) {\n  typedef ::testing::tuple<\n      typename internal::DecayArray<T1>::type,\n      typename internal::DecayArray<T2>::type,\n      typename internal::DecayArray<T3>::type,\n      typename internal::DecayArray<T4>::type> Args;\n  return internal::ElementsAreMatcher<Args>(Args(e1, e2, e3, e4));\n}\n\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5>\ninline internal::ElementsAreMatcher<\n    ::testing::tuple<\n        typename internal::DecayArray<T1>::type,\n        typename internal::DecayArray<T2>::type,\n        typename internal::DecayArray<T3>::type,\n        typename internal::DecayArray<T4>::type,\n        typename internal::DecayArray<T5>::type> >\nElementsAre(const T1& e1, const T2& e2, const T3& e3, const T4& e4,\n    const T5& e5) {\n  typedef ::testing::tuple<\n      typename internal::DecayArray<T1>::type,\n      typename internal::DecayArray<T2>::type,\n      typename internal::DecayArray<T3>::type,\n      typename internal::DecayArray<T4>::type,\n      typename internal::DecayArray<T5>::type> Args;\n  return internal::ElementsAreMatcher<Args>(Args(e1, e2, e3, e4, e5));\n}\n\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6>\ninline internal::ElementsAreMatcher<\n    ::testing::tuple<\n        typename internal::DecayArray<T1>::type,\n        typename internal::DecayArray<T2>::type,\n        typename internal::DecayArray<T3>::type,\n        typename internal::DecayArray<T4>::type,\n        typename internal::DecayArray<T5>::type,\n        typename internal::DecayArray<T6>::type> >\nElementsAre(const T1& e1, const T2& e2, const T3& e3, const T4& e4,\n    const T5& e5, const T6& e6) {\n  typedef ::testing::tuple<\n      typename internal::DecayArray<T1>::type,\n      typename internal::DecayArray<T2>::type,\n      typename internal::DecayArray<T3>::type,\n      typename internal::DecayArray<T4>::type,\n      typename internal::DecayArray<T5>::type,\n      typename internal::DecayArray<T6>::type> Args;\n  return internal::ElementsAreMatcher<Args>(Args(e1, e2, e3, e4, e5, e6));\n}\n\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6, typename T7>\ninline internal::ElementsAreMatcher<\n    ::testing::tuple<\n        typename internal::DecayArray<T1>::type,\n        typename internal::DecayArray<T2>::type,\n        typename internal::DecayArray<T3>::type,\n        typename internal::DecayArray<T4>::type,\n        typename internal::DecayArray<T5>::type,\n        typename internal::DecayArray<T6>::type,\n        typename internal::DecayArray<T7>::type> >\nElementsAre(const T1& e1, const T2& e2, const T3& e3, const T4& e4,\n    const T5& e5, const T6& e6, const T7& e7) {\n  typedef ::testing::tuple<\n      typename internal::DecayArray<T1>::type,\n      typename internal::DecayArray<T2>::type,\n      typename internal::DecayArray<T3>::type,\n      typename internal::DecayArray<T4>::type,\n      typename internal::DecayArray<T5>::type,\n      typename internal::DecayArray<T6>::type,\n      typename internal::DecayArray<T7>::type> Args;\n  return internal::ElementsAreMatcher<Args>(Args(e1, e2, e3, e4, e5, e6, e7));\n}\n\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6, typename T7, typename T8>\ninline internal::ElementsAreMatcher<\n    ::testing::tuple<\n        typename internal::DecayArray<T1>::type,\n        typename internal::DecayArray<T2>::type,\n        typename internal::DecayArray<T3>::type,\n        typename internal::DecayArray<T4>::type,\n        typename internal::DecayArray<T5>::type,\n        typename internal::DecayArray<T6>::type,\n        typename internal::DecayArray<T7>::type,\n        typename internal::DecayArray<T8>::type> >\nElementsAre(const T1& e1, const T2& e2, const T3& e3, const T4& e4,\n    const T5& e5, const T6& e6, const T7& e7, const T8& e8) {\n  typedef ::testing::tuple<\n      typename internal::DecayArray<T1>::type,\n      typename internal::DecayArray<T2>::type,\n      typename internal::DecayArray<T3>::type,\n      typename internal::DecayArray<T4>::type,\n      typename internal::DecayArray<T5>::type,\n      typename internal::DecayArray<T6>::type,\n      typename internal::DecayArray<T7>::type,\n      typename internal::DecayArray<T8>::type> Args;\n  return internal::ElementsAreMatcher<Args>(Args(e1, e2, e3, e4, e5, e6, e7,\n      e8));\n}\n\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6, typename T7, typename T8, typename T9>\ninline internal::ElementsAreMatcher<\n    ::testing::tuple<\n        typename internal::DecayArray<T1>::type,\n        typename internal::DecayArray<T2>::type,\n        typename internal::DecayArray<T3>::type,\n        typename internal::DecayArray<T4>::type,\n        typename internal::DecayArray<T5>::type,\n        typename internal::DecayArray<T6>::type,\n        typename internal::DecayArray<T7>::type,\n        typename internal::DecayArray<T8>::type,\n        typename internal::DecayArray<T9>::type> >\nElementsAre(const T1& e1, const T2& e2, const T3& e3, const T4& e4,\n    const T5& e5, const T6& e6, const T7& e7, const T8& e8, const T9& e9) {\n  typedef ::testing::tuple<\n      typename internal::DecayArray<T1>::type,\n      typename internal::DecayArray<T2>::type,\n      typename internal::DecayArray<T3>::type,\n      typename internal::DecayArray<T4>::type,\n      typename internal::DecayArray<T5>::type,\n      typename internal::DecayArray<T6>::type,\n      typename internal::DecayArray<T7>::type,\n      typename internal::DecayArray<T8>::type,\n      typename internal::DecayArray<T9>::type> Args;\n  return internal::ElementsAreMatcher<Args>(Args(e1, e2, e3, e4, e5, e6, e7,\n      e8, e9));\n}\n\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6, typename T7, typename T8, typename T9, typename T10>\ninline internal::ElementsAreMatcher<\n    ::testing::tuple<\n        typename internal::DecayArray<T1>::type,\n        typename internal::DecayArray<T2>::type,\n        typename internal::DecayArray<T3>::type,\n        typename internal::DecayArray<T4>::type,\n        typename internal::DecayArray<T5>::type,\n        typename internal::DecayArray<T6>::type,\n        typename internal::DecayArray<T7>::type,\n        typename internal::DecayArray<T8>::type,\n        typename internal::DecayArray<T9>::type,\n        typename internal::DecayArray<T10>::type> >\nElementsAre(const T1& e1, const T2& e2, const T3& e3, const T4& e4,\n    const T5& e5, const T6& e6, const T7& e7, const T8& e8, const T9& e9,\n    const T10& e10) {\n  typedef ::testing::tuple<\n      typename internal::DecayArray<T1>::type,\n      typename internal::DecayArray<T2>::type,\n      typename internal::DecayArray<T3>::type,\n      typename internal::DecayArray<T4>::type,\n      typename internal::DecayArray<T5>::type,\n      typename internal::DecayArray<T6>::type,\n      typename internal::DecayArray<T7>::type,\n      typename internal::DecayArray<T8>::type,\n      typename internal::DecayArray<T9>::type,\n      typename internal::DecayArray<T10>::type> Args;\n  return internal::ElementsAreMatcher<Args>(Args(e1, e2, e3, e4, e5, e6, e7,\n      e8, e9, e10));\n}\n\n// UnorderedElementsAre(e_1, e_2, ..., e_n) is an ElementsAre extension\n// that matches n elements in any order.  We support up to n=10 arguments.\n\ninline internal::UnorderedElementsAreMatcher<\n    ::testing::tuple<> >\nUnorderedElementsAre() {\n  typedef ::testing::tuple<> Args;\n  return internal::UnorderedElementsAreMatcher<Args>(Args());\n}\n\ntemplate <typename T1>\ninline internal::UnorderedElementsAreMatcher<\n    ::testing::tuple<\n        typename internal::DecayArray<T1>::type> >\nUnorderedElementsAre(const T1& e1) {\n  typedef ::testing::tuple<\n      typename internal::DecayArray<T1>::type> Args;\n  return internal::UnorderedElementsAreMatcher<Args>(Args(e1));\n}\n\ntemplate <typename T1, typename T2>\ninline internal::UnorderedElementsAreMatcher<\n    ::testing::tuple<\n        typename internal::DecayArray<T1>::type,\n        typename internal::DecayArray<T2>::type> >\nUnorderedElementsAre(const T1& e1, const T2& e2) {\n  typedef ::testing::tuple<\n      typename internal::DecayArray<T1>::type,\n      typename internal::DecayArray<T2>::type> Args;\n  return internal::UnorderedElementsAreMatcher<Args>(Args(e1, e2));\n}\n\ntemplate <typename T1, typename T2, typename T3>\ninline internal::UnorderedElementsAreMatcher<\n    ::testing::tuple<\n        typename internal::DecayArray<T1>::type,\n        typename internal::DecayArray<T2>::type,\n        typename internal::DecayArray<T3>::type> >\nUnorderedElementsAre(const T1& e1, const T2& e2, const T3& e3) {\n  typedef ::testing::tuple<\n      typename internal::DecayArray<T1>::type,\n      typename internal::DecayArray<T2>::type,\n      typename internal::DecayArray<T3>::type> Args;\n  return internal::UnorderedElementsAreMatcher<Args>(Args(e1, e2, e3));\n}\n\ntemplate <typename T1, typename T2, typename T3, typename T4>\ninline internal::UnorderedElementsAreMatcher<\n    ::testing::tuple<\n        typename internal::DecayArray<T1>::type,\n        typename internal::DecayArray<T2>::type,\n        typename internal::DecayArray<T3>::type,\n        typename internal::DecayArray<T4>::type> >\nUnorderedElementsAre(const T1& e1, const T2& e2, const T3& e3, const T4& e4) {\n  typedef ::testing::tuple<\n      typename internal::DecayArray<T1>::type,\n      typename internal::DecayArray<T2>::type,\n      typename internal::DecayArray<T3>::type,\n      typename internal::DecayArray<T4>::type> Args;\n  return internal::UnorderedElementsAreMatcher<Args>(Args(e1, e2, e3, e4));\n}\n\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5>\ninline internal::UnorderedElementsAreMatcher<\n    ::testing::tuple<\n        typename internal::DecayArray<T1>::type,\n        typename internal::DecayArray<T2>::type,\n        typename internal::DecayArray<T3>::type,\n        typename internal::DecayArray<T4>::type,\n        typename internal::DecayArray<T5>::type> >\nUnorderedElementsAre(const T1& e1, const T2& e2, const T3& e3, const T4& e4,\n    const T5& e5) {\n  typedef ::testing::tuple<\n      typename internal::DecayArray<T1>::type,\n      typename internal::DecayArray<T2>::type,\n      typename internal::DecayArray<T3>::type,\n      typename internal::DecayArray<T4>::type,\n      typename internal::DecayArray<T5>::type> Args;\n  return internal::UnorderedElementsAreMatcher<Args>(Args(e1, e2, e3, e4, e5));\n}\n\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6>\ninline internal::UnorderedElementsAreMatcher<\n    ::testing::tuple<\n        typename internal::DecayArray<T1>::type,\n        typename internal::DecayArray<T2>::type,\n        typename internal::DecayArray<T3>::type,\n        typename internal::DecayArray<T4>::type,\n        typename internal::DecayArray<T5>::type,\n        typename internal::DecayArray<T6>::type> >\nUnorderedElementsAre(const T1& e1, const T2& e2, const T3& e3, const T4& e4,\n    const T5& e5, const T6& e6) {\n  typedef ::testing::tuple<\n      typename internal::DecayArray<T1>::type,\n      typename internal::DecayArray<T2>::type,\n      typename internal::DecayArray<T3>::type,\n      typename internal::DecayArray<T4>::type,\n      typename internal::DecayArray<T5>::type,\n      typename internal::DecayArray<T6>::type> Args;\n  return internal::UnorderedElementsAreMatcher<Args>(Args(e1, e2, e3, e4, e5,\n      e6));\n}\n\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6, typename T7>\ninline internal::UnorderedElementsAreMatcher<\n    ::testing::tuple<\n        typename internal::DecayArray<T1>::type,\n        typename internal::DecayArray<T2>::type,\n        typename internal::DecayArray<T3>::type,\n        typename internal::DecayArray<T4>::type,\n        typename internal::DecayArray<T5>::type,\n        typename internal::DecayArray<T6>::type,\n        typename internal::DecayArray<T7>::type> >\nUnorderedElementsAre(const T1& e1, const T2& e2, const T3& e3, const T4& e4,\n    const T5& e5, const T6& e6, const T7& e7) {\n  typedef ::testing::tuple<\n      typename internal::DecayArray<T1>::type,\n      typename internal::DecayArray<T2>::type,\n      typename internal::DecayArray<T3>::type,\n      typename internal::DecayArray<T4>::type,\n      typename internal::DecayArray<T5>::type,\n      typename internal::DecayArray<T6>::type,\n      typename internal::DecayArray<T7>::type> Args;\n  return internal::UnorderedElementsAreMatcher<Args>(Args(e1, e2, e3, e4, e5,\n      e6, e7));\n}\n\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6, typename T7, typename T8>\ninline internal::UnorderedElementsAreMatcher<\n    ::testing::tuple<\n        typename internal::DecayArray<T1>::type,\n        typename internal::DecayArray<T2>::type,\n        typename internal::DecayArray<T3>::type,\n        typename internal::DecayArray<T4>::type,\n        typename internal::DecayArray<T5>::type,\n        typename internal::DecayArray<T6>::type,\n        typename internal::DecayArray<T7>::type,\n        typename internal::DecayArray<T8>::type> >\nUnorderedElementsAre(const T1& e1, const T2& e2, const T3& e3, const T4& e4,\n    const T5& e5, const T6& e6, const T7& e7, const T8& e8) {\n  typedef ::testing::tuple<\n      typename internal::DecayArray<T1>::type,\n      typename internal::DecayArray<T2>::type,\n      typename internal::DecayArray<T3>::type,\n      typename internal::DecayArray<T4>::type,\n      typename internal::DecayArray<T5>::type,\n      typename internal::DecayArray<T6>::type,\n      typename internal::DecayArray<T7>::type,\n      typename internal::DecayArray<T8>::type> Args;\n  return internal::UnorderedElementsAreMatcher<Args>(Args(e1, e2, e3, e4, e5,\n      e6, e7, e8));\n}\n\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6, typename T7, typename T8, typename T9>\ninline internal::UnorderedElementsAreMatcher<\n    ::testing::tuple<\n        typename internal::DecayArray<T1>::type,\n        typename internal::DecayArray<T2>::type,\n        typename internal::DecayArray<T3>::type,\n        typename internal::DecayArray<T4>::type,\n        typename internal::DecayArray<T5>::type,\n        typename internal::DecayArray<T6>::type,\n        typename internal::DecayArray<T7>::type,\n        typename internal::DecayArray<T8>::type,\n        typename internal::DecayArray<T9>::type> >\nUnorderedElementsAre(const T1& e1, const T2& e2, const T3& e3, const T4& e4,\n    const T5& e5, const T6& e6, const T7& e7, const T8& e8, const T9& e9) {\n  typedef ::testing::tuple<\n      typename internal::DecayArray<T1>::type,\n      typename internal::DecayArray<T2>::type,\n      typename internal::DecayArray<T3>::type,\n      typename internal::DecayArray<T4>::type,\n      typename internal::DecayArray<T5>::type,\n      typename internal::DecayArray<T6>::type,\n      typename internal::DecayArray<T7>::type,\n      typename internal::DecayArray<T8>::type,\n      typename internal::DecayArray<T9>::type> Args;\n  return internal::UnorderedElementsAreMatcher<Args>(Args(e1, e2, e3, e4, e5,\n      e6, e7, e8, e9));\n}\n\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6, typename T7, typename T8, typename T9, typename T10>\ninline internal::UnorderedElementsAreMatcher<\n    ::testing::tuple<\n        typename internal::DecayArray<T1>::type,\n        typename internal::DecayArray<T2>::type,\n        typename internal::DecayArray<T3>::type,\n        typename internal::DecayArray<T4>::type,\n        typename internal::DecayArray<T5>::type,\n        typename internal::DecayArray<T6>::type,\n        typename internal::DecayArray<T7>::type,\n        typename internal::DecayArray<T8>::type,\n        typename internal::DecayArray<T9>::type,\n        typename internal::DecayArray<T10>::type> >\nUnorderedElementsAre(const T1& e1, const T2& e2, const T3& e3, const T4& e4,\n    const T5& e5, const T6& e6, const T7& e7, const T8& e8, const T9& e9,\n    const T10& e10) {\n  typedef ::testing::tuple<\n      typename internal::DecayArray<T1>::type,\n      typename internal::DecayArray<T2>::type,\n      typename internal::DecayArray<T3>::type,\n      typename internal::DecayArray<T4>::type,\n      typename internal::DecayArray<T5>::type,\n      typename internal::DecayArray<T6>::type,\n      typename internal::DecayArray<T7>::type,\n      typename internal::DecayArray<T8>::type,\n      typename internal::DecayArray<T9>::type,\n      typename internal::DecayArray<T10>::type> Args;\n  return internal::UnorderedElementsAreMatcher<Args>(Args(e1, e2, e3, e4, e5,\n      e6, e7, e8, e9, e10));\n}\n\n// AllOf(m1, m2, ..., mk) matches any value that matches all of the given\n// sub-matchers.  AllOf is called fully qualified to prevent ADL from firing.\n\ntemplate <typename M1, typename M2>\ninline typename internal::AllOfResult2<M1, M2>::type\nAllOf(M1 m1, M2 m2) {\n  return typename internal::AllOfResult2<M1, M2>::type(\n      m1,\n      m2);\n}\n\ntemplate <typename M1, typename M2, typename M3>\ninline typename internal::AllOfResult3<M1, M2, M3>::type\nAllOf(M1 m1, M2 m2, M3 m3) {\n  return typename internal::AllOfResult3<M1, M2, M3>::type(\n      m1,\n      ::testing::AllOf(m2, m3));\n}\n\ntemplate <typename M1, typename M2, typename M3, typename M4>\ninline typename internal::AllOfResult4<M1, M2, M3, M4>::type\nAllOf(M1 m1, M2 m2, M3 m3, M4 m4) {\n  return typename internal::AllOfResult4<M1, M2, M3, M4>::type(\n      ::testing::AllOf(m1, m2),\n      ::testing::AllOf(m3, m4));\n}\n\ntemplate <typename M1, typename M2, typename M3, typename M4, typename M5>\ninline typename internal::AllOfResult5<M1, M2, M3, M4, M5>::type\nAllOf(M1 m1, M2 m2, M3 m3, M4 m4, M5 m5) {\n  return typename internal::AllOfResult5<M1, M2, M3, M4, M5>::type(\n      ::testing::AllOf(m1, m2),\n      ::testing::AllOf(m3, m4, m5));\n}\n\ntemplate <typename M1, typename M2, typename M3, typename M4, typename M5,\n    typename M6>\ninline typename internal::AllOfResult6<M1, M2, M3, M4, M5, M6>::type\nAllOf(M1 m1, M2 m2, M3 m3, M4 m4, M5 m5, M6 m6) {\n  return typename internal::AllOfResult6<M1, M2, M3, M4, M5, M6>::type(\n      ::testing::AllOf(m1, m2, m3),\n      ::testing::AllOf(m4, m5, m6));\n}\n\ntemplate <typename M1, typename M2, typename M3, typename M4, typename M5,\n    typename M6, typename M7>\ninline typename internal::AllOfResult7<M1, M2, M3, M4, M5, M6, M7>::type\nAllOf(M1 m1, M2 m2, M3 m3, M4 m4, M5 m5, M6 m6, M7 m7) {\n  return typename internal::AllOfResult7<M1, M2, M3, M4, M5, M6, M7>::type(\n      ::testing::AllOf(m1, m2, m3),\n      ::testing::AllOf(m4, m5, m6, m7));\n}\n\ntemplate <typename M1, typename M2, typename M3, typename M4, typename M5,\n    typename M6, typename M7, typename M8>\ninline typename internal::AllOfResult8<M1, M2, M3, M4, M5, M6, M7, M8>::type\nAllOf(M1 m1, M2 m2, M3 m3, M4 m4, M5 m5, M6 m6, M7 m7, M8 m8) {\n  return typename internal::AllOfResult8<M1, M2, M3, M4, M5, M6, M7, M8>::type(\n      ::testing::AllOf(m1, m2, m3, m4),\n      ::testing::AllOf(m5, m6, m7, m8));\n}\n\ntemplate <typename M1, typename M2, typename M3, typename M4, typename M5,\n    typename M6, typename M7, typename M8, typename M9>\ninline typename internal::AllOfResult9<M1, M2, M3, M4, M5, M6, M7, M8, M9>::type\nAllOf(M1 m1, M2 m2, M3 m3, M4 m4, M5 m5, M6 m6, M7 m7, M8 m8, M9 m9) {\n  return typename internal::AllOfResult9<M1, M2, M3, M4, M5, M6, M7, M8,\n      M9>::type(\n      ::testing::AllOf(m1, m2, m3, m4),\n      ::testing::AllOf(m5, m6, m7, m8, m9));\n}\n\ntemplate <typename M1, typename M2, typename M3, typename M4, typename M5,\n    typename M6, typename M7, typename M8, typename M9, typename M10>\ninline typename internal::AllOfResult10<M1, M2, M3, M4, M5, M6, M7, M8, M9,\n    M10>::type\nAllOf(M1 m1, M2 m2, M3 m3, M4 m4, M5 m5, M6 m6, M7 m7, M8 m8, M9 m9, M10 m10) {\n  return typename internal::AllOfResult10<M1, M2, M3, M4, M5, M6, M7, M8, M9,\n      M10>::type(\n      ::testing::AllOf(m1, m2, m3, m4, m5),\n      ::testing::AllOf(m6, m7, m8, m9, m10));\n}\n\n// AnyOf(m1, m2, ..., mk) matches any value that matches any of the given\n// sub-matchers.  AnyOf is called fully qualified to prevent ADL from firing.\n\ntemplate <typename M1, typename M2>\ninline typename internal::AnyOfResult2<M1, M2>::type\nAnyOf(M1 m1, M2 m2) {\n  return typename internal::AnyOfResult2<M1, M2>::type(\n      m1,\n      m2);\n}\n\ntemplate <typename M1, typename M2, typename M3>\ninline typename internal::AnyOfResult3<M1, M2, M3>::type\nAnyOf(M1 m1, M2 m2, M3 m3) {\n  return typename internal::AnyOfResult3<M1, M2, M3>::type(\n      m1,\n      ::testing::AnyOf(m2, m3));\n}\n\ntemplate <typename M1, typename M2, typename M3, typename M4>\ninline typename internal::AnyOfResult4<M1, M2, M3, M4>::type\nAnyOf(M1 m1, M2 m2, M3 m3, M4 m4) {\n  return typename internal::AnyOfResult4<M1, M2, M3, M4>::type(\n      ::testing::AnyOf(m1, m2),\n      ::testing::AnyOf(m3, m4));\n}\n\ntemplate <typename M1, typename M2, typename M3, typename M4, typename M5>\ninline typename internal::AnyOfResult5<M1, M2, M3, M4, M5>::type\nAnyOf(M1 m1, M2 m2, M3 m3, M4 m4, M5 m5) {\n  return typename internal::AnyOfResult5<M1, M2, M3, M4, M5>::type(\n      ::testing::AnyOf(m1, m2),\n      ::testing::AnyOf(m3, m4, m5));\n}\n\ntemplate <typename M1, typename M2, typename M3, typename M4, typename M5,\n    typename M6>\ninline typename internal::AnyOfResult6<M1, M2, M3, M4, M5, M6>::type\nAnyOf(M1 m1, M2 m2, M3 m3, M4 m4, M5 m5, M6 m6) {\n  return typename internal::AnyOfResult6<M1, M2, M3, M4, M5, M6>::type(\n      ::testing::AnyOf(m1, m2, m3),\n      ::testing::AnyOf(m4, m5, m6));\n}\n\ntemplate <typename M1, typename M2, typename M3, typename M4, typename M5,\n    typename M6, typename M7>\ninline typename internal::AnyOfResult7<M1, M2, M3, M4, M5, M6, M7>::type\nAnyOf(M1 m1, M2 m2, M3 m3, M4 m4, M5 m5, M6 m6, M7 m7) {\n  return typename internal::AnyOfResult7<M1, M2, M3, M4, M5, M6, M7>::type(\n      ::testing::AnyOf(m1, m2, m3),\n      ::testing::AnyOf(m4, m5, m6, m7));\n}\n\ntemplate <typename M1, typename M2, typename M3, typename M4, typename M5,\n    typename M6, typename M7, typename M8>\ninline typename internal::AnyOfResult8<M1, M2, M3, M4, M5, M6, M7, M8>::type\nAnyOf(M1 m1, M2 m2, M3 m3, M4 m4, M5 m5, M6 m6, M7 m7, M8 m8) {\n  return typename internal::AnyOfResult8<M1, M2, M3, M4, M5, M6, M7, M8>::type(\n      ::testing::AnyOf(m1, m2, m3, m4),\n      ::testing::AnyOf(m5, m6, m7, m8));\n}\n\ntemplate <typename M1, typename M2, typename M3, typename M4, typename M5,\n    typename M6, typename M7, typename M8, typename M9>\ninline typename internal::AnyOfResult9<M1, M2, M3, M4, M5, M6, M7, M8, M9>::type\nAnyOf(M1 m1, M2 m2, M3 m3, M4 m4, M5 m5, M6 m6, M7 m7, M8 m8, M9 m9) {\n  return typename internal::AnyOfResult9<M1, M2, M3, M4, M5, M6, M7, M8,\n      M9>::type(\n      ::testing::AnyOf(m1, m2, m3, m4),\n      ::testing::AnyOf(m5, m6, m7, m8, m9));\n}\n\ntemplate <typename M1, typename M2, typename M3, typename M4, typename M5,\n    typename M6, typename M7, typename M8, typename M9, typename M10>\ninline typename internal::AnyOfResult10<M1, M2, M3, M4, M5, M6, M7, M8, M9,\n    M10>::type\nAnyOf(M1 m1, M2 m2, M3 m3, M4 m4, M5 m5, M6 m6, M7 m7, M8 m8, M9 m9, M10 m10) {\n  return typename internal::AnyOfResult10<M1, M2, M3, M4, M5, M6, M7, M8, M9,\n      M10>::type(\n      ::testing::AnyOf(m1, m2, m3, m4, m5),\n      ::testing::AnyOf(m6, m7, m8, m9, m10));\n}\n\n}  // namespace testing\n\n\n// The MATCHER* family of macros can be used in a namespace scope to\n// define custom matchers easily.\n//\n// Basic Usage\n// ===========\n//\n// The syntax\n//\n//   MATCHER(name, description_string) { statements; }\n//\n// defines a matcher with the given name that executes the statements,\n// which must return a bool to indicate if the match succeeds.  Inside\n// the statements, you can refer to the value being matched by 'arg',\n// and refer to its type by 'arg_type'.\n//\n// The description string documents what the matcher does, and is used\n// to generate the failure message when the match fails.  Since a\n// MATCHER() is usually defined in a header file shared by multiple\n// C++ source files, we require the description to be a C-string\n// literal to avoid possible side effects.  It can be empty, in which\n// case we'll use the sequence of words in the matcher name as the\n// description.\n//\n// For example:\n//\n//   MATCHER(IsEven, \"\") { return (arg % 2) == 0; }\n//\n// allows you to write\n//\n//   // Expects mock_foo.Bar(n) to be called where n is even.\n//   EXPECT_CALL(mock_foo, Bar(IsEven()));\n//\n// or,\n//\n//   // Verifies that the value of some_expression is even.\n//   EXPECT_THAT(some_expression, IsEven());\n//\n// If the above assertion fails, it will print something like:\n//\n//   Value of: some_expression\n//   Expected: is even\n//     Actual: 7\n//\n// where the description \"is even\" is automatically calculated from the\n// matcher name IsEven.\n//\n// Argument Type\n// =============\n//\n// Note that the type of the value being matched (arg_type) is\n// determined by the context in which you use the matcher and is\n// supplied to you by the compiler, so you don't need to worry about\n// declaring it (nor can you).  This allows the matcher to be\n// polymorphic.  For example, IsEven() can be used to match any type\n// where the value of \"(arg % 2) == 0\" can be implicitly converted to\n// a bool.  In the \"Bar(IsEven())\" example above, if method Bar()\n// takes an int, 'arg_type' will be int; if it takes an unsigned long,\n// 'arg_type' will be unsigned long; and so on.\n//\n// Parameterizing Matchers\n// =======================\n//\n// Sometimes you'll want to parameterize the matcher.  For that you\n// can use another macro:\n//\n//   MATCHER_P(name, param_name, description_string) { statements; }\n//\n// For example:\n//\n//   MATCHER_P(HasAbsoluteValue, value, \"\") { return abs(arg) == value; }\n//\n// will allow you to write:\n//\n//   EXPECT_THAT(Blah(\"a\"), HasAbsoluteValue(n));\n//\n// which may lead to this message (assuming n is 10):\n//\n//   Value of: Blah(\"a\")\n//   Expected: has absolute value 10\n//     Actual: -9\n//\n// Note that both the matcher description and its parameter are\n// printed, making the message human-friendly.\n//\n// In the matcher definition body, you can write 'foo_type' to\n// reference the type of a parameter named 'foo'.  For example, in the\n// body of MATCHER_P(HasAbsoluteValue, value) above, you can write\n// 'value_type' to refer to the type of 'value'.\n//\n// We also provide MATCHER_P2, MATCHER_P3, ..., up to MATCHER_P10 to\n// support multi-parameter matchers.\n//\n// Describing Parameterized Matchers\n// =================================\n//\n// The last argument to MATCHER*() is a string-typed expression.  The\n// expression can reference all of the matcher's parameters and a\n// special bool-typed variable named 'negation'.  When 'negation' is\n// false, the expression should evaluate to the matcher's description;\n// otherwise it should evaluate to the description of the negation of\n// the matcher.  For example,\n//\n//   using testing::PrintToString;\n//\n//   MATCHER_P2(InClosedRange, low, hi,\n//       string(negation ? \"is not\" : \"is\") + \" in range [\" +\n//       PrintToString(low) + \", \" + PrintToString(hi) + \"]\") {\n//     return low <= arg && arg <= hi;\n//   }\n//   ...\n//   EXPECT_THAT(3, InClosedRange(4, 6));\n//   EXPECT_THAT(3, Not(InClosedRange(2, 4)));\n//\n// would generate two failures that contain the text:\n//\n//   Expected: is in range [4, 6]\n//   ...\n//   Expected: is not in range [2, 4]\n//\n// If you specify \"\" as the description, the failure message will\n// contain the sequence of words in the matcher name followed by the\n// parameter values printed as a tuple.  For example,\n//\n//   MATCHER_P2(InClosedRange, low, hi, \"\") { ... }\n//   ...\n//   EXPECT_THAT(3, InClosedRange(4, 6));\n//   EXPECT_THAT(3, Not(InClosedRange(2, 4)));\n//\n// would generate two failures that contain the text:\n//\n//   Expected: in closed range (4, 6)\n//   ...\n//   Expected: not (in closed range (2, 4))\n//\n// Types of Matcher Parameters\n// ===========================\n//\n// For the purpose of typing, you can view\n//\n//   MATCHER_Pk(Foo, p1, ..., pk, description_string) { ... }\n//\n// as shorthand for\n//\n//   template <typename p1_type, ..., typename pk_type>\n//   FooMatcherPk<p1_type, ..., pk_type>\n//   Foo(p1_type p1, ..., pk_type pk) { ... }\n//\n// When you write Foo(v1, ..., vk), the compiler infers the types of\n// the parameters v1, ..., and vk for you.  If you are not happy with\n// the result of the type inference, you can specify the types by\n// explicitly instantiating the template, as in Foo<long, bool>(5,\n// false).  As said earlier, you don't get to (or need to) specify\n// 'arg_type' as that's determined by the context in which the matcher\n// is used.  You can assign the result of expression Foo(p1, ..., pk)\n// to a variable of type FooMatcherPk<p1_type, ..., pk_type>.  This\n// can be useful when composing matchers.\n//\n// While you can instantiate a matcher template with reference types,\n// passing the parameters by pointer usually makes your code more\n// readable.  If, however, you still want to pass a parameter by\n// reference, be aware that in the failure message generated by the\n// matcher you will see the value of the referenced object but not its\n// address.\n//\n// Explaining Match Results\n// ========================\n//\n// Sometimes the matcher description alone isn't enough to explain why\n// the match has failed or succeeded.  For example, when expecting a\n// long string, it can be very helpful to also print the diff between\n// the expected string and the actual one.  To achieve that, you can\n// optionally stream additional information to a special variable\n// named result_listener, whose type is a pointer to class\n// MatchResultListener:\n//\n//   MATCHER_P(EqualsLongString, str, \"\") {\n//     if (arg == str) return true;\n//\n//     *result_listener << \"the difference: \"\n///                     << DiffStrings(str, arg);\n//     return false;\n//   }\n//\n// Overloading Matchers\n// ====================\n//\n// You can overload matchers with different numbers of parameters:\n//\n//   MATCHER_P(Blah, a, description_string1) { ... }\n//   MATCHER_P2(Blah, a, b, description_string2) { ... }\n//\n// Caveats\n// =======\n//\n// When defining a new matcher, you should also consider implementing\n// MatcherInterface or using MakePolymorphicMatcher().  These\n// approaches require more work than the MATCHER* macros, but also\n// give you more control on the types of the value being matched and\n// the matcher parameters, which may leads to better compiler error\n// messages when the matcher is used wrong.  They also allow\n// overloading matchers based on parameter types (as opposed to just\n// based on the number of parameters).\n//\n// MATCHER*() can only be used in a namespace scope.  The reason is\n// that C++ doesn't yet allow function-local types to be used to\n// instantiate templates.  The up-coming C++0x standard will fix this.\n// Once that's done, we'll consider supporting using MATCHER*() inside\n// a function.\n//\n// More Information\n// ================\n//\n// To learn more about using these macros, please search for 'MATCHER'\n// on http://code.google.com/p/googlemock/wiki/CookBook.\n\n#define MATCHER(name, description)\\\n  class name##Matcher {\\\n   public:\\\n    template <typename arg_type>\\\n    class gmock_Impl : public ::testing::MatcherInterface<arg_type> {\\\n     public:\\\n      gmock_Impl()\\\n           {}\\\n      virtual bool MatchAndExplain(\\\n          arg_type arg, ::testing::MatchResultListener* result_listener) const;\\\n      virtual void DescribeTo(::std::ostream* gmock_os) const {\\\n        *gmock_os << FormatDescription(false);\\\n      }\\\n      virtual void DescribeNegationTo(::std::ostream* gmock_os) const {\\\n        *gmock_os << FormatDescription(true);\\\n      }\\\n     private:\\\n      ::testing::internal::string FormatDescription(bool negation) const {\\\n        const ::testing::internal::string gmock_description = (description);\\\n        if (!gmock_description.empty())\\\n          return gmock_description;\\\n        return ::testing::internal::FormatMatcherDescription(\\\n            negation, #name, \\\n            ::testing::internal::UniversalTersePrintTupleFieldsToStrings(\\\n                ::testing::tuple<>()));\\\n      }\\\n      GTEST_DISALLOW_ASSIGN_(gmock_Impl);\\\n    };\\\n    template <typename arg_type>\\\n    operator ::testing::Matcher<arg_type>() const {\\\n      return ::testing::Matcher<arg_type>(\\\n          new gmock_Impl<arg_type>());\\\n    }\\\n    name##Matcher() {\\\n    }\\\n   private:\\\n    GTEST_DISALLOW_ASSIGN_(name##Matcher);\\\n  };\\\n  inline name##Matcher name() {\\\n    return name##Matcher();\\\n  }\\\n  template <typename arg_type>\\\n  bool name##Matcher::gmock_Impl<arg_type>::MatchAndExplain(\\\n      arg_type arg, \\\n      ::testing::MatchResultListener* result_listener GTEST_ATTRIBUTE_UNUSED_)\\\n          const\n\n#define MATCHER_P(name, p0, description)\\\n  template <typename p0##_type>\\\n  class name##MatcherP {\\\n   public:\\\n    template <typename arg_type>\\\n    class gmock_Impl : public ::testing::MatcherInterface<arg_type> {\\\n     public:\\\n      explicit gmock_Impl(p0##_type gmock_p0)\\\n           : p0(gmock_p0) {}\\\n      virtual bool MatchAndExplain(\\\n          arg_type arg, ::testing::MatchResultListener* result_listener) const;\\\n      virtual void DescribeTo(::std::ostream* gmock_os) const {\\\n        *gmock_os << FormatDescription(false);\\\n      }\\\n      virtual void DescribeNegationTo(::std::ostream* gmock_os) const {\\\n        *gmock_os << FormatDescription(true);\\\n      }\\\n      p0##_type p0;\\\n     private:\\\n      ::testing::internal::string FormatDescription(bool negation) const {\\\n        const ::testing::internal::string gmock_description = (description);\\\n        if (!gmock_description.empty())\\\n          return gmock_description;\\\n        return ::testing::internal::FormatMatcherDescription(\\\n            negation, #name, \\\n            ::testing::internal::UniversalTersePrintTupleFieldsToStrings(\\\n                ::testing::tuple<p0##_type>(p0)));\\\n      }\\\n      GTEST_DISALLOW_ASSIGN_(gmock_Impl);\\\n    };\\\n    template <typename arg_type>\\\n    operator ::testing::Matcher<arg_type>() const {\\\n      return ::testing::Matcher<arg_type>(\\\n          new gmock_Impl<arg_type>(p0));\\\n    }\\\n    explicit name##MatcherP(p0##_type gmock_p0) : p0(gmock_p0) {\\\n    }\\\n    p0##_type p0;\\\n   private:\\\n    GTEST_DISALLOW_ASSIGN_(name##MatcherP);\\\n  };\\\n  template <typename p0##_type>\\\n  inline name##MatcherP<p0##_type> name(p0##_type p0) {\\\n    return name##MatcherP<p0##_type>(p0);\\\n  }\\\n  template <typename p0##_type>\\\n  template <typename arg_type>\\\n  bool name##MatcherP<p0##_type>::gmock_Impl<arg_type>::MatchAndExplain(\\\n      arg_type arg, \\\n      ::testing::MatchResultListener* result_listener GTEST_ATTRIBUTE_UNUSED_)\\\n          const\n\n#define MATCHER_P2(name, p0, p1, description)\\\n  template <typename p0##_type, typename p1##_type>\\\n  class name##MatcherP2 {\\\n   public:\\\n    template <typename arg_type>\\\n    class gmock_Impl : public ::testing::MatcherInterface<arg_type> {\\\n     public:\\\n      gmock_Impl(p0##_type gmock_p0, p1##_type gmock_p1)\\\n           : p0(gmock_p0), p1(gmock_p1) {}\\\n      virtual bool MatchAndExplain(\\\n          arg_type arg, ::testing::MatchResultListener* result_listener) const;\\\n      virtual void DescribeTo(::std::ostream* gmock_os) const {\\\n        *gmock_os << FormatDescription(false);\\\n      }\\\n      virtual void DescribeNegationTo(::std::ostream* gmock_os) const {\\\n        *gmock_os << FormatDescription(true);\\\n      }\\\n      p0##_type p0;\\\n      p1##_type p1;\\\n     private:\\\n      ::testing::internal::string FormatDescription(bool negation) const {\\\n        const ::testing::internal::string gmock_description = (description);\\\n        if (!gmock_description.empty())\\\n          return gmock_description;\\\n        return ::testing::internal::FormatMatcherDescription(\\\n            negation, #name, \\\n            ::testing::internal::UniversalTersePrintTupleFieldsToStrings(\\\n                ::testing::tuple<p0##_type, p1##_type>(p0, p1)));\\\n      }\\\n      GTEST_DISALLOW_ASSIGN_(gmock_Impl);\\\n    };\\\n    template <typename arg_type>\\\n    operator ::testing::Matcher<arg_type>() const {\\\n      return ::testing::Matcher<arg_type>(\\\n          new gmock_Impl<arg_type>(p0, p1));\\\n    }\\\n    name##MatcherP2(p0##_type gmock_p0, p1##_type gmock_p1) : p0(gmock_p0), \\\n        p1(gmock_p1) {\\\n    }\\\n    p0##_type p0;\\\n    p1##_type p1;\\\n   private:\\\n    GTEST_DISALLOW_ASSIGN_(name##MatcherP2);\\\n  };\\\n  template <typename p0##_type, typename p1##_type>\\\n  inline name##MatcherP2<p0##_type, p1##_type> name(p0##_type p0, \\\n      p1##_type p1) {\\\n    return name##MatcherP2<p0##_type, p1##_type>(p0, p1);\\\n  }\\\n  template <typename p0##_type, typename p1##_type>\\\n  template <typename arg_type>\\\n  bool name##MatcherP2<p0##_type, \\\n      p1##_type>::gmock_Impl<arg_type>::MatchAndExplain(\\\n      arg_type arg, \\\n      ::testing::MatchResultListener* result_listener GTEST_ATTRIBUTE_UNUSED_)\\\n          const\n\n#define MATCHER_P3(name, p0, p1, p2, description)\\\n  template <typename p0##_type, typename p1##_type, typename p2##_type>\\\n  class name##MatcherP3 {\\\n   public:\\\n    template <typename arg_type>\\\n    class gmock_Impl : public ::testing::MatcherInterface<arg_type> {\\\n     public:\\\n      gmock_Impl(p0##_type gmock_p0, p1##_type gmock_p1, p2##_type gmock_p2)\\\n           : p0(gmock_p0), p1(gmock_p1), p2(gmock_p2) {}\\\n      virtual bool MatchAndExplain(\\\n          arg_type arg, ::testing::MatchResultListener* result_listener) const;\\\n      virtual void DescribeTo(::std::ostream* gmock_os) const {\\\n        *gmock_os << FormatDescription(false);\\\n      }\\\n      virtual void DescribeNegationTo(::std::ostream* gmock_os) const {\\\n        *gmock_os << FormatDescription(true);\\\n      }\\\n      p0##_type p0;\\\n      p1##_type p1;\\\n      p2##_type p2;\\\n     private:\\\n      ::testing::internal::string FormatDescription(bool negation) const {\\\n        const ::testing::internal::string gmock_description = (description);\\\n        if (!gmock_description.empty())\\\n          return gmock_description;\\\n        return ::testing::internal::FormatMatcherDescription(\\\n            negation, #name, \\\n            ::testing::internal::UniversalTersePrintTupleFieldsToStrings(\\\n                ::testing::tuple<p0##_type, p1##_type, p2##_type>(p0, p1, \\\n                    p2)));\\\n      }\\\n      GTEST_DISALLOW_ASSIGN_(gmock_Impl);\\\n    };\\\n    template <typename arg_type>\\\n    operator ::testing::Matcher<arg_type>() const {\\\n      return ::testing::Matcher<arg_type>(\\\n          new gmock_Impl<arg_type>(p0, p1, p2));\\\n    }\\\n    name##MatcherP3(p0##_type gmock_p0, p1##_type gmock_p1, \\\n        p2##_type gmock_p2) : p0(gmock_p0), p1(gmock_p1), p2(gmock_p2) {\\\n    }\\\n    p0##_type p0;\\\n    p1##_type p1;\\\n    p2##_type p2;\\\n   private:\\\n    GTEST_DISALLOW_ASSIGN_(name##MatcherP3);\\\n  };\\\n  template <typename p0##_type, typename p1##_type, typename p2##_type>\\\n  inline name##MatcherP3<p0##_type, p1##_type, p2##_type> name(p0##_type p0, \\\n      p1##_type p1, p2##_type p2) {\\\n    return name##MatcherP3<p0##_type, p1##_type, p2##_type>(p0, p1, p2);\\\n  }\\\n  template <typename p0##_type, typename p1##_type, typename p2##_type>\\\n  template <typename arg_type>\\\n  bool name##MatcherP3<p0##_type, p1##_type, \\\n      p2##_type>::gmock_Impl<arg_type>::MatchAndExplain(\\\n      arg_type arg, \\\n      ::testing::MatchResultListener* result_listener GTEST_ATTRIBUTE_UNUSED_)\\\n          const\n\n#define MATCHER_P4(name, p0, p1, p2, p3, description)\\\n  template <typename p0##_type, typename p1##_type, typename p2##_type, \\\n      typename p3##_type>\\\n  class name##MatcherP4 {\\\n   public:\\\n    template <typename arg_type>\\\n    class gmock_Impl : public ::testing::MatcherInterface<arg_type> {\\\n     public:\\\n      gmock_Impl(p0##_type gmock_p0, p1##_type gmock_p1, p2##_type gmock_p2, \\\n          p3##_type gmock_p3)\\\n           : p0(gmock_p0), p1(gmock_p1), p2(gmock_p2), p3(gmock_p3) {}\\\n      virtual bool MatchAndExplain(\\\n          arg_type arg, ::testing::MatchResultListener* result_listener) const;\\\n      virtual void DescribeTo(::std::ostream* gmock_os) const {\\\n        *gmock_os << FormatDescription(false);\\\n      }\\\n      virtual void DescribeNegationTo(::std::ostream* gmock_os) const {\\\n        *gmock_os << FormatDescription(true);\\\n      }\\\n      p0##_type p0;\\\n      p1##_type p1;\\\n      p2##_type p2;\\\n      p3##_type p3;\\\n     private:\\\n      ::testing::internal::string FormatDescription(bool negation) const {\\\n        const ::testing::internal::string gmock_description = (description);\\\n        if (!gmock_description.empty())\\\n          return gmock_description;\\\n        return ::testing::internal::FormatMatcherDescription(\\\n            negation, #name, \\\n            ::testing::internal::UniversalTersePrintTupleFieldsToStrings(\\\n                ::testing::tuple<p0##_type, p1##_type, p2##_type, \\\n                    p3##_type>(p0, p1, p2, p3)));\\\n      }\\\n      GTEST_DISALLOW_ASSIGN_(gmock_Impl);\\\n    };\\\n    template <typename arg_type>\\\n    operator ::testing::Matcher<arg_type>() const {\\\n      return ::testing::Matcher<arg_type>(\\\n          new gmock_Impl<arg_type>(p0, p1, p2, p3));\\\n    }\\\n    name##MatcherP4(p0##_type gmock_p0, p1##_type gmock_p1, \\\n        p2##_type gmock_p2, p3##_type gmock_p3) : p0(gmock_p0), p1(gmock_p1), \\\n        p2(gmock_p2), p3(gmock_p3) {\\\n    }\\\n    p0##_type p0;\\\n    p1##_type p1;\\\n    p2##_type p2;\\\n    p3##_type p3;\\\n   private:\\\n    GTEST_DISALLOW_ASSIGN_(name##MatcherP4);\\\n  };\\\n  template <typename p0##_type, typename p1##_type, typename p2##_type, \\\n      typename p3##_type>\\\n  inline name##MatcherP4<p0##_type, p1##_type, p2##_type, \\\n      p3##_type> name(p0##_type p0, p1##_type p1, p2##_type p2, \\\n      p3##_type p3) {\\\n    return name##MatcherP4<p0##_type, p1##_type, p2##_type, p3##_type>(p0, \\\n        p1, p2, p3);\\\n  }\\\n  template <typename p0##_type, typename p1##_type, typename p2##_type, \\\n      typename p3##_type>\\\n  template <typename arg_type>\\\n  bool name##MatcherP4<p0##_type, p1##_type, p2##_type, \\\n      p3##_type>::gmock_Impl<arg_type>::MatchAndExplain(\\\n      arg_type arg, \\\n      ::testing::MatchResultListener* result_listener GTEST_ATTRIBUTE_UNUSED_)\\\n          const\n\n#define MATCHER_P5(name, p0, p1, p2, p3, p4, description)\\\n  template <typename p0##_type, typename p1##_type, typename p2##_type, \\\n      typename p3##_type, typename p4##_type>\\\n  class name##MatcherP5 {\\\n   public:\\\n    template <typename arg_type>\\\n    class gmock_Impl : public ::testing::MatcherInterface<arg_type> {\\\n     public:\\\n      gmock_Impl(p0##_type gmock_p0, p1##_type gmock_p1, p2##_type gmock_p2, \\\n          p3##_type gmock_p3, p4##_type gmock_p4)\\\n           : p0(gmock_p0), p1(gmock_p1), p2(gmock_p2), p3(gmock_p3), \\\n               p4(gmock_p4) {}\\\n      virtual bool MatchAndExplain(\\\n          arg_type arg, ::testing::MatchResultListener* result_listener) const;\\\n      virtual void DescribeTo(::std::ostream* gmock_os) const {\\\n        *gmock_os << FormatDescription(false);\\\n      }\\\n      virtual void DescribeNegationTo(::std::ostream* gmock_os) const {\\\n        *gmock_os << FormatDescription(true);\\\n      }\\\n      p0##_type p0;\\\n      p1##_type p1;\\\n      p2##_type p2;\\\n      p3##_type p3;\\\n      p4##_type p4;\\\n     private:\\\n      ::testing::internal::string FormatDescription(bool negation) const {\\\n        const ::testing::internal::string gmock_description = (description);\\\n        if (!gmock_description.empty())\\\n          return gmock_description;\\\n        return ::testing::internal::FormatMatcherDescription(\\\n            negation, #name, \\\n            ::testing::internal::UniversalTersePrintTupleFieldsToStrings(\\\n                ::testing::tuple<p0##_type, p1##_type, p2##_type, p3##_type, \\\n                    p4##_type>(p0, p1, p2, p3, p4)));\\\n      }\\\n      GTEST_DISALLOW_ASSIGN_(gmock_Impl);\\\n    };\\\n    template <typename arg_type>\\\n    operator ::testing::Matcher<arg_type>() const {\\\n      return ::testing::Matcher<arg_type>(\\\n          new gmock_Impl<arg_type>(p0, p1, p2, p3, p4));\\\n    }\\\n    name##MatcherP5(p0##_type gmock_p0, p1##_type gmock_p1, \\\n        p2##_type gmock_p2, p3##_type gmock_p3, \\\n        p4##_type gmock_p4) : p0(gmock_p0), p1(gmock_p1), p2(gmock_p2), \\\n        p3(gmock_p3), p4(gmock_p4) {\\\n    }\\\n    p0##_type p0;\\\n    p1##_type p1;\\\n    p2##_type p2;\\\n    p3##_type p3;\\\n    p4##_type p4;\\\n   private:\\\n    GTEST_DISALLOW_ASSIGN_(name##MatcherP5);\\\n  };\\\n  template <typename p0##_type, typename p1##_type, typename p2##_type, \\\n      typename p3##_type, typename p4##_type>\\\n  inline name##MatcherP5<p0##_type, p1##_type, p2##_type, p3##_type, \\\n      p4##_type> name(p0##_type p0, p1##_type p1, p2##_type p2, p3##_type p3, \\\n      p4##_type p4) {\\\n    return name##MatcherP5<p0##_type, p1##_type, p2##_type, p3##_type, \\\n        p4##_type>(p0, p1, p2, p3, p4);\\\n  }\\\n  template <typename p0##_type, typename p1##_type, typename p2##_type, \\\n      typename p3##_type, typename p4##_type>\\\n  template <typename arg_type>\\\n  bool name##MatcherP5<p0##_type, p1##_type, p2##_type, p3##_type, \\\n      p4##_type>::gmock_Impl<arg_type>::MatchAndExplain(\\\n      arg_type arg, \\\n      ::testing::MatchResultListener* result_listener GTEST_ATTRIBUTE_UNUSED_)\\\n          const\n\n#define MATCHER_P6(name, p0, p1, p2, p3, p4, p5, description)\\\n  template <typename p0##_type, typename p1##_type, typename p2##_type, \\\n      typename p3##_type, typename p4##_type, typename p5##_type>\\\n  class name##MatcherP6 {\\\n   public:\\\n    template <typename arg_type>\\\n    class gmock_Impl : public ::testing::MatcherInterface<arg_type> {\\\n     public:\\\n      gmock_Impl(p0##_type gmock_p0, p1##_type gmock_p1, p2##_type gmock_p2, \\\n          p3##_type gmock_p3, p4##_type gmock_p4, p5##_type gmock_p5)\\\n           : p0(gmock_p0), p1(gmock_p1), p2(gmock_p2), p3(gmock_p3), \\\n               p4(gmock_p4), p5(gmock_p5) {}\\\n      virtual bool MatchAndExplain(\\\n          arg_type arg, ::testing::MatchResultListener* result_listener) const;\\\n      virtual void DescribeTo(::std::ostream* gmock_os) const {\\\n        *gmock_os << FormatDescription(false);\\\n      }\\\n      virtual void DescribeNegationTo(::std::ostream* gmock_os) const {\\\n        *gmock_os << FormatDescription(true);\\\n      }\\\n      p0##_type p0;\\\n      p1##_type p1;\\\n      p2##_type p2;\\\n      p3##_type p3;\\\n      p4##_type p4;\\\n      p5##_type p5;\\\n     private:\\\n      ::testing::internal::string FormatDescription(bool negation) const {\\\n        const ::testing::internal::string gmock_description = (description);\\\n        if (!gmock_description.empty())\\\n          return gmock_description;\\\n        return ::testing::internal::FormatMatcherDescription(\\\n            negation, #name, \\\n            ::testing::internal::UniversalTersePrintTupleFieldsToStrings(\\\n                ::testing::tuple<p0##_type, p1##_type, p2##_type, p3##_type, \\\n                    p4##_type, p5##_type>(p0, p1, p2, p3, p4, p5)));\\\n      }\\\n      GTEST_DISALLOW_ASSIGN_(gmock_Impl);\\\n    };\\\n    template <typename arg_type>\\\n    operator ::testing::Matcher<arg_type>() const {\\\n      return ::testing::Matcher<arg_type>(\\\n          new gmock_Impl<arg_type>(p0, p1, p2, p3, p4, p5));\\\n    }\\\n    name##MatcherP6(p0##_type gmock_p0, p1##_type gmock_p1, \\\n        p2##_type gmock_p2, p3##_type gmock_p3, p4##_type gmock_p4, \\\n        p5##_type gmock_p5) : p0(gmock_p0), p1(gmock_p1), p2(gmock_p2), \\\n        p3(gmock_p3), p4(gmock_p4), p5(gmock_p5) {\\\n    }\\\n    p0##_type p0;\\\n    p1##_type p1;\\\n    p2##_type p2;\\\n    p3##_type p3;\\\n    p4##_type p4;\\\n    p5##_type p5;\\\n   private:\\\n    GTEST_DISALLOW_ASSIGN_(name##MatcherP6);\\\n  };\\\n  template <typename p0##_type, typename p1##_type, typename p2##_type, \\\n      typename p3##_type, typename p4##_type, typename p5##_type>\\\n  inline name##MatcherP6<p0##_type, p1##_type, p2##_type, p3##_type, \\\n      p4##_type, p5##_type> name(p0##_type p0, p1##_type p1, p2##_type p2, \\\n      p3##_type p3, p4##_type p4, p5##_type p5) {\\\n    return name##MatcherP6<p0##_type, p1##_type, p2##_type, p3##_type, \\\n        p4##_type, p5##_type>(p0, p1, p2, p3, p4, p5);\\\n  }\\\n  template <typename p0##_type, typename p1##_type, typename p2##_type, \\\n      typename p3##_type, typename p4##_type, typename p5##_type>\\\n  template <typename arg_type>\\\n  bool name##MatcherP6<p0##_type, p1##_type, p2##_type, p3##_type, p4##_type, \\\n      p5##_type>::gmock_Impl<arg_type>::MatchAndExplain(\\\n      arg_type arg, \\\n      ::testing::MatchResultListener* result_listener GTEST_ATTRIBUTE_UNUSED_)\\\n          const\n\n#define MATCHER_P7(name, p0, p1, p2, p3, p4, p5, p6, description)\\\n  template <typename p0##_type, typename p1##_type, typename p2##_type, \\\n      typename p3##_type, typename p4##_type, typename p5##_type, \\\n      typename p6##_type>\\\n  class name##MatcherP7 {\\\n   public:\\\n    template <typename arg_type>\\\n    class gmock_Impl : public ::testing::MatcherInterface<arg_type> {\\\n     public:\\\n      gmock_Impl(p0##_type gmock_p0, p1##_type gmock_p1, p2##_type gmock_p2, \\\n          p3##_type gmock_p3, p4##_type gmock_p4, p5##_type gmock_p5, \\\n          p6##_type gmock_p6)\\\n           : p0(gmock_p0), p1(gmock_p1), p2(gmock_p2), p3(gmock_p3), \\\n               p4(gmock_p4), p5(gmock_p5), p6(gmock_p6) {}\\\n      virtual bool MatchAndExplain(\\\n          arg_type arg, ::testing::MatchResultListener* result_listener) const;\\\n      virtual void DescribeTo(::std::ostream* gmock_os) const {\\\n        *gmock_os << FormatDescription(false);\\\n      }\\\n      virtual void DescribeNegationTo(::std::ostream* gmock_os) const {\\\n        *gmock_os << FormatDescription(true);\\\n      }\\\n      p0##_type p0;\\\n      p1##_type p1;\\\n      p2##_type p2;\\\n      p3##_type p3;\\\n      p4##_type p4;\\\n      p5##_type p5;\\\n      p6##_type p6;\\\n     private:\\\n      ::testing::internal::string FormatDescription(bool negation) const {\\\n        const ::testing::internal::string gmock_description = (description);\\\n        if (!gmock_description.empty())\\\n          return gmock_description;\\\n        return ::testing::internal::FormatMatcherDescription(\\\n            negation, #name, \\\n            ::testing::internal::UniversalTersePrintTupleFieldsToStrings(\\\n                ::testing::tuple<p0##_type, p1##_type, p2##_type, p3##_type, \\\n                    p4##_type, p5##_type, p6##_type>(p0, p1, p2, p3, p4, p5, \\\n                    p6)));\\\n      }\\\n      GTEST_DISALLOW_ASSIGN_(gmock_Impl);\\\n    };\\\n    template <typename arg_type>\\\n    operator ::testing::Matcher<arg_type>() const {\\\n      return ::testing::Matcher<arg_type>(\\\n          new gmock_Impl<arg_type>(p0, p1, p2, p3, p4, p5, p6));\\\n    }\\\n    name##MatcherP7(p0##_type gmock_p0, p1##_type gmock_p1, \\\n        p2##_type gmock_p2, p3##_type gmock_p3, p4##_type gmock_p4, \\\n        p5##_type gmock_p5, p6##_type gmock_p6) : p0(gmock_p0), p1(gmock_p1), \\\n        p2(gmock_p2), p3(gmock_p3), p4(gmock_p4), p5(gmock_p5), \\\n        p6(gmock_p6) {\\\n    }\\\n    p0##_type p0;\\\n    p1##_type p1;\\\n    p2##_type p2;\\\n    p3##_type p3;\\\n    p4##_type p4;\\\n    p5##_type p5;\\\n    p6##_type p6;\\\n   private:\\\n    GTEST_DISALLOW_ASSIGN_(name##MatcherP7);\\\n  };\\\n  template <typename p0##_type, typename p1##_type, typename p2##_type, \\\n      typename p3##_type, typename p4##_type, typename p5##_type, \\\n      typename p6##_type>\\\n  inline name##MatcherP7<p0##_type, p1##_type, p2##_type, p3##_type, \\\n      p4##_type, p5##_type, p6##_type> name(p0##_type p0, p1##_type p1, \\\n      p2##_type p2, p3##_type p3, p4##_type p4, p5##_type p5, \\\n      p6##_type p6) {\\\n    return name##MatcherP7<p0##_type, p1##_type, p2##_type, p3##_type, \\\n        p4##_type, p5##_type, p6##_type>(p0, p1, p2, p3, p4, p5, p6);\\\n  }\\\n  template <typename p0##_type, typename p1##_type, typename p2##_type, \\\n      typename p3##_type, typename p4##_type, typename p5##_type, \\\n      typename p6##_type>\\\n  template <typename arg_type>\\\n  bool name##MatcherP7<p0##_type, p1##_type, p2##_type, p3##_type, p4##_type, \\\n      p5##_type, p6##_type>::gmock_Impl<arg_type>::MatchAndExplain(\\\n      arg_type arg, \\\n      ::testing::MatchResultListener* result_listener GTEST_ATTRIBUTE_UNUSED_)\\\n          const\n\n#define MATCHER_P8(name, p0, p1, p2, p3, p4, p5, p6, p7, description)\\\n  template <typename p0##_type, typename p1##_type, typename p2##_type, \\\n      typename p3##_type, typename p4##_type, typename p5##_type, \\\n      typename p6##_type, typename p7##_type>\\\n  class name##MatcherP8 {\\\n   public:\\\n    template <typename arg_type>\\\n    class gmock_Impl : public ::testing::MatcherInterface<arg_type> {\\\n     public:\\\n      gmock_Impl(p0##_type gmock_p0, p1##_type gmock_p1, p2##_type gmock_p2, \\\n          p3##_type gmock_p3, p4##_type gmock_p4, p5##_type gmock_p5, \\\n          p6##_type gmock_p6, p7##_type gmock_p7)\\\n           : p0(gmock_p0), p1(gmock_p1), p2(gmock_p2), p3(gmock_p3), \\\n               p4(gmock_p4), p5(gmock_p5), p6(gmock_p6), p7(gmock_p7) {}\\\n      virtual bool MatchAndExplain(\\\n          arg_type arg, ::testing::MatchResultListener* result_listener) const;\\\n      virtual void DescribeTo(::std::ostream* gmock_os) const {\\\n        *gmock_os << FormatDescription(false);\\\n      }\\\n      virtual void DescribeNegationTo(::std::ostream* gmock_os) const {\\\n        *gmock_os << FormatDescription(true);\\\n      }\\\n      p0##_type p0;\\\n      p1##_type p1;\\\n      p2##_type p2;\\\n      p3##_type p3;\\\n      p4##_type p4;\\\n      p5##_type p5;\\\n      p6##_type p6;\\\n      p7##_type p7;\\\n     private:\\\n      ::testing::internal::string FormatDescription(bool negation) const {\\\n        const ::testing::internal::string gmock_description = (description);\\\n        if (!gmock_description.empty())\\\n          return gmock_description;\\\n        return ::testing::internal::FormatMatcherDescription(\\\n            negation, #name, \\\n            ::testing::internal::UniversalTersePrintTupleFieldsToStrings(\\\n                ::testing::tuple<p0##_type, p1##_type, p2##_type, p3##_type, \\\n                    p4##_type, p5##_type, p6##_type, p7##_type>(p0, p1, p2, \\\n                    p3, p4, p5, p6, p7)));\\\n      }\\\n      GTEST_DISALLOW_ASSIGN_(gmock_Impl);\\\n    };\\\n    template <typename arg_type>\\\n    operator ::testing::Matcher<arg_type>() const {\\\n      return ::testing::Matcher<arg_type>(\\\n          new gmock_Impl<arg_type>(p0, p1, p2, p3, p4, p5, p6, p7));\\\n    }\\\n    name##MatcherP8(p0##_type gmock_p0, p1##_type gmock_p1, \\\n        p2##_type gmock_p2, p3##_type gmock_p3, p4##_type gmock_p4, \\\n        p5##_type gmock_p5, p6##_type gmock_p6, \\\n        p7##_type gmock_p7) : p0(gmock_p0), p1(gmock_p1), p2(gmock_p2), \\\n        p3(gmock_p3), p4(gmock_p4), p5(gmock_p5), p6(gmock_p6), \\\n        p7(gmock_p7) {\\\n    }\\\n    p0##_type p0;\\\n    p1##_type p1;\\\n    p2##_type p2;\\\n    p3##_type p3;\\\n    p4##_type p4;\\\n    p5##_type p5;\\\n    p6##_type p6;\\\n    p7##_type p7;\\\n   private:\\\n    GTEST_DISALLOW_ASSIGN_(name##MatcherP8);\\\n  };\\\n  template <typename p0##_type, typename p1##_type, typename p2##_type, \\\n      typename p3##_type, typename p4##_type, typename p5##_type, \\\n      typename p6##_type, typename p7##_type>\\\n  inline name##MatcherP8<p0##_type, p1##_type, p2##_type, p3##_type, \\\n      p4##_type, p5##_type, p6##_type, p7##_type> name(p0##_type p0, \\\n      p1##_type p1, p2##_type p2, p3##_type p3, p4##_type p4, p5##_type p5, \\\n      p6##_type p6, p7##_type p7) {\\\n    return name##MatcherP8<p0##_type, p1##_type, p2##_type, p3##_type, \\\n        p4##_type, p5##_type, p6##_type, p7##_type>(p0, p1, p2, p3, p4, p5, \\\n        p6, p7);\\\n  }\\\n  template <typename p0##_type, typename p1##_type, typename p2##_type, \\\n      typename p3##_type, typename p4##_type, typename p5##_type, \\\n      typename p6##_type, typename p7##_type>\\\n  template <typename arg_type>\\\n  bool name##MatcherP8<p0##_type, p1##_type, p2##_type, p3##_type, p4##_type, \\\n      p5##_type, p6##_type, \\\n      p7##_type>::gmock_Impl<arg_type>::MatchAndExplain(\\\n      arg_type arg, \\\n      ::testing::MatchResultListener* result_listener GTEST_ATTRIBUTE_UNUSED_)\\\n          const\n\n#define MATCHER_P9(name, p0, p1, p2, p3, p4, p5, p6, p7, p8, description)\\\n  template <typename p0##_type, typename p1##_type, typename p2##_type, \\\n      typename p3##_type, typename p4##_type, typename p5##_type, \\\n      typename p6##_type, typename p7##_type, typename p8##_type>\\\n  class name##MatcherP9 {\\\n   public:\\\n    template <typename arg_type>\\\n    class gmock_Impl : public ::testing::MatcherInterface<arg_type> {\\\n     public:\\\n      gmock_Impl(p0##_type gmock_p0, p1##_type gmock_p1, p2##_type gmock_p2, \\\n          p3##_type gmock_p3, p4##_type gmock_p4, p5##_type gmock_p5, \\\n          p6##_type gmock_p6, p7##_type gmock_p7, p8##_type gmock_p8)\\\n           : p0(gmock_p0), p1(gmock_p1), p2(gmock_p2), p3(gmock_p3), \\\n               p4(gmock_p4), p5(gmock_p5), p6(gmock_p6), p7(gmock_p7), \\\n               p8(gmock_p8) {}\\\n      virtual bool MatchAndExplain(\\\n          arg_type arg, ::testing::MatchResultListener* result_listener) const;\\\n      virtual void DescribeTo(::std::ostream* gmock_os) const {\\\n        *gmock_os << FormatDescription(false);\\\n      }\\\n      virtual void DescribeNegationTo(::std::ostream* gmock_os) const {\\\n        *gmock_os << FormatDescription(true);\\\n      }\\\n      p0##_type p0;\\\n      p1##_type p1;\\\n      p2##_type p2;\\\n      p3##_type p3;\\\n      p4##_type p4;\\\n      p5##_type p5;\\\n      p6##_type p6;\\\n      p7##_type p7;\\\n      p8##_type p8;\\\n     private:\\\n      ::testing::internal::string FormatDescription(bool negation) const {\\\n        const ::testing::internal::string gmock_description = (description);\\\n        if (!gmock_description.empty())\\\n          return gmock_description;\\\n        return ::testing::internal::FormatMatcherDescription(\\\n            negation, #name, \\\n            ::testing::internal::UniversalTersePrintTupleFieldsToStrings(\\\n                ::testing::tuple<p0##_type, p1##_type, p2##_type, p3##_type, \\\n                    p4##_type, p5##_type, p6##_type, p7##_type, \\\n                    p8##_type>(p0, p1, p2, p3, p4, p5, p6, p7, p8)));\\\n      }\\\n      GTEST_DISALLOW_ASSIGN_(gmock_Impl);\\\n    };\\\n    template <typename arg_type>\\\n    operator ::testing::Matcher<arg_type>() const {\\\n      return ::testing::Matcher<arg_type>(\\\n          new gmock_Impl<arg_type>(p0, p1, p2, p3, p4, p5, p6, p7, p8));\\\n    }\\\n    name##MatcherP9(p0##_type gmock_p0, p1##_type gmock_p1, \\\n        p2##_type gmock_p2, p3##_type gmock_p3, p4##_type gmock_p4, \\\n        p5##_type gmock_p5, p6##_type gmock_p6, p7##_type gmock_p7, \\\n        p8##_type gmock_p8) : p0(gmock_p0), p1(gmock_p1), p2(gmock_p2), \\\n        p3(gmock_p3), p4(gmock_p4), p5(gmock_p5), p6(gmock_p6), p7(gmock_p7), \\\n        p8(gmock_p8) {\\\n    }\\\n    p0##_type p0;\\\n    p1##_type p1;\\\n    p2##_type p2;\\\n    p3##_type p3;\\\n    p4##_type p4;\\\n    p5##_type p5;\\\n    p6##_type p6;\\\n    p7##_type p7;\\\n    p8##_type p8;\\\n   private:\\\n    GTEST_DISALLOW_ASSIGN_(name##MatcherP9);\\\n  };\\\n  template <typename p0##_type, typename p1##_type, typename p2##_type, \\\n      typename p3##_type, typename p4##_type, typename p5##_type, \\\n      typename p6##_type, typename p7##_type, typename p8##_type>\\\n  inline name##MatcherP9<p0##_type, p1##_type, p2##_type, p3##_type, \\\n      p4##_type, p5##_type, p6##_type, p7##_type, \\\n      p8##_type> name(p0##_type p0, p1##_type p1, p2##_type p2, p3##_type p3, \\\n      p4##_type p4, p5##_type p5, p6##_type p6, p7##_type p7, \\\n      p8##_type p8) {\\\n    return name##MatcherP9<p0##_type, p1##_type, p2##_type, p3##_type, \\\n        p4##_type, p5##_type, p6##_type, p7##_type, p8##_type>(p0, p1, p2, \\\n        p3, p4, p5, p6, p7, p8);\\\n  }\\\n  template <typename p0##_type, typename p1##_type, typename p2##_type, \\\n      typename p3##_type, typename p4##_type, typename p5##_type, \\\n      typename p6##_type, typename p7##_type, typename p8##_type>\\\n  template <typename arg_type>\\\n  bool name##MatcherP9<p0##_type, p1##_type, p2##_type, p3##_type, p4##_type, \\\n      p5##_type, p6##_type, p7##_type, \\\n      p8##_type>::gmock_Impl<arg_type>::MatchAndExplain(\\\n      arg_type arg, \\\n      ::testing::MatchResultListener* result_listener GTEST_ATTRIBUTE_UNUSED_)\\\n          const\n\n#define MATCHER_P10(name, p0, p1, p2, p3, p4, p5, p6, p7, p8, p9, description)\\\n  template <typename p0##_type, typename p1##_type, typename p2##_type, \\\n      typename p3##_type, typename p4##_type, typename p5##_type, \\\n      typename p6##_type, typename p7##_type, typename p8##_type, \\\n      typename p9##_type>\\\n  class name##MatcherP10 {\\\n   public:\\\n    template <typename arg_type>\\\n    class gmock_Impl : public ::testing::MatcherInterface<arg_type> {\\\n     public:\\\n      gmock_Impl(p0##_type gmock_p0, p1##_type gmock_p1, p2##_type gmock_p2, \\\n          p3##_type gmock_p3, p4##_type gmock_p4, p5##_type gmock_p5, \\\n          p6##_type gmock_p6, p7##_type gmock_p7, p8##_type gmock_p8, \\\n          p9##_type gmock_p9)\\\n           : p0(gmock_p0), p1(gmock_p1), p2(gmock_p2), p3(gmock_p3), \\\n               p4(gmock_p4), p5(gmock_p5), p6(gmock_p6), p7(gmock_p7), \\\n               p8(gmock_p8), p9(gmock_p9) {}\\\n      virtual bool MatchAndExplain(\\\n          arg_type arg, ::testing::MatchResultListener* result_listener) const;\\\n      virtual void DescribeTo(::std::ostream* gmock_os) const {\\\n        *gmock_os << FormatDescription(false);\\\n      }\\\n      virtual void DescribeNegationTo(::std::ostream* gmock_os) const {\\\n        *gmock_os << FormatDescription(true);\\\n      }\\\n      p0##_type p0;\\\n      p1##_type p1;\\\n      p2##_type p2;\\\n      p3##_type p3;\\\n      p4##_type p4;\\\n      p5##_type p5;\\\n      p6##_type p6;\\\n      p7##_type p7;\\\n      p8##_type p8;\\\n      p9##_type p9;\\\n     private:\\\n      ::testing::internal::string FormatDescription(bool negation) const {\\\n        const ::testing::internal::string gmock_description = (description);\\\n        if (!gmock_description.empty())\\\n          return gmock_description;\\\n        return ::testing::internal::FormatMatcherDescription(\\\n            negation, #name, \\\n            ::testing::internal::UniversalTersePrintTupleFieldsToStrings(\\\n                ::testing::tuple<p0##_type, p1##_type, p2##_type, p3##_type, \\\n                    p4##_type, p5##_type, p6##_type, p7##_type, p8##_type, \\\n                    p9##_type>(p0, p1, p2, p3, p4, p5, p6, p7, p8, p9)));\\\n      }\\\n      GTEST_DISALLOW_ASSIGN_(gmock_Impl);\\\n    };\\\n    template <typename arg_type>\\\n    operator ::testing::Matcher<arg_type>() const {\\\n      return ::testing::Matcher<arg_type>(\\\n          new gmock_Impl<arg_type>(p0, p1, p2, p3, p4, p5, p6, p7, p8, p9));\\\n    }\\\n    name##MatcherP10(p0##_type gmock_p0, p1##_type gmock_p1, \\\n        p2##_type gmock_p2, p3##_type gmock_p3, p4##_type gmock_p4, \\\n        p5##_type gmock_p5, p6##_type gmock_p6, p7##_type gmock_p7, \\\n        p8##_type gmock_p8, p9##_type gmock_p9) : p0(gmock_p0), p1(gmock_p1), \\\n        p2(gmock_p2), p3(gmock_p3), p4(gmock_p4), p5(gmock_p5), p6(gmock_p6), \\\n        p7(gmock_p7), p8(gmock_p8), p9(gmock_p9) {\\\n    }\\\n    p0##_type p0;\\\n    p1##_type p1;\\\n    p2##_type p2;\\\n    p3##_type p3;\\\n    p4##_type p4;\\\n    p5##_type p5;\\\n    p6##_type p6;\\\n    p7##_type p7;\\\n    p8##_type p8;\\\n    p9##_type p9;\\\n   private:\\\n    GTEST_DISALLOW_ASSIGN_(name##MatcherP10);\\\n  };\\\n  template <typename p0##_type, typename p1##_type, typename p2##_type, \\\n      typename p3##_type, typename p4##_type, typename p5##_type, \\\n      typename p6##_type, typename p7##_type, typename p8##_type, \\\n      typename p9##_type>\\\n  inline name##MatcherP10<p0##_type, p1##_type, p2##_type, p3##_type, \\\n      p4##_type, p5##_type, p6##_type, p7##_type, p8##_type, \\\n      p9##_type> name(p0##_type p0, p1##_type p1, p2##_type p2, p3##_type p3, \\\n      p4##_type p4, p5##_type p5, p6##_type p6, p7##_type p7, p8##_type p8, \\\n      p9##_type p9) {\\\n    return name##MatcherP10<p0##_type, p1##_type, p2##_type, p3##_type, \\\n        p4##_type, p5##_type, p6##_type, p7##_type, p8##_type, p9##_type>(p0, \\\n        p1, p2, p3, p4, p5, p6, p7, p8, p9);\\\n  }\\\n  template <typename p0##_type, typename p1##_type, typename p2##_type, \\\n      typename p3##_type, typename p4##_type, typename p5##_type, \\\n      typename p6##_type, typename p7##_type, typename p8##_type, \\\n      typename p9##_type>\\\n  template <typename arg_type>\\\n  bool name##MatcherP10<p0##_type, p1##_type, p2##_type, p3##_type, \\\n      p4##_type, p5##_type, p6##_type, p7##_type, p8##_type, \\\n      p9##_type>::gmock_Impl<arg_type>::MatchAndExplain(\\\n      arg_type arg, \\\n      ::testing::MatchResultListener* result_listener GTEST_ATTRIBUTE_UNUSED_)\\\n          const\n\n#endif  // GMOCK_INCLUDE_GMOCK_GMOCK_GENERATED_MATCHERS_H_\n"}, "22": {"id": 22, "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clangd/unittests/CodeCompleteTests.cpp", "content": "//===-- CodeCompleteTests.cpp -----------------------------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#include \"ASTSignals.h\"\n#include \"Annotations.h\"\n#include \"ClangdServer.h\"\n#include \"CodeComplete.h\"\n#include \"Compiler.h\"\n#include \"Matchers.h\"\n#include \"Protocol.h\"\n#include \"Quality.h\"\n#include \"SourceCode.h\"\n#include \"SyncAPI.h\"\n#include \"TestFS.h\"\n#include \"TestIndex.h\"\n#include \"TestTU.h\"\n#include \"index/Index.h\"\n#include \"index/MemIndex.h\"\n#include \"support/Threading.h\"\n#include \"clang/Sema/CodeCompleteConsumer.h\"\n#include \"clang/Tooling/CompilationDatabase.h\"\n#include \"llvm/Support/Error.h\"\n#include \"llvm/Support/Path.h\"\n#include \"llvm/Testing/Support/Annotations.h\"\n#include \"llvm/Testing/Support/Error.h\"\n#include \"gmock/gmock.h\"\n#include \"gtest/gtest.h\"\n#include <condition_variable>\n#include <functional>\n#include <mutex>\n#include <vector>\n\nnamespace clang {\nnamespace clangd {\n\nnamespace {\nusing ::llvm::Failed;\nusing ::testing::AllOf;\nusing ::testing::Contains;\nusing ::testing::ElementsAre;\nusing ::testing::Field;\nusing ::testing::HasSubstr;\nusing ::testing::IsEmpty;\nusing ::testing::Not;\nusing ::testing::UnorderedElementsAre;\nusing ContextKind = CodeCompletionContext::Kind;\n\n// GMock helpers for matching completion items.\nMATCHER_P(Named, Name, \"\") { return arg.Name == Name; }\nMATCHER_P(MainFileRefs, Refs, \"\") { return arg.MainFileRefs == Refs; }\nMATCHER_P(ScopeRefs, Refs, \"\") { return arg.ScopeRefsInFile == Refs; }\nMATCHER_P(NameStartsWith, Prefix, \"\") {\n  return llvm::StringRef(arg.Name).startswith(Prefix);\n}\nMATCHER_P(Scope, S, \"\") { return arg.Scope == S; }\nMATCHER_P(Qualifier, Q, \"\") { return arg.RequiredQualifier == Q; }\nMATCHER_P(Labeled, Label, \"\") {\n  return arg.RequiredQualifier + arg.Name + arg.Signature == Label;\n}\nMATCHER_P(SigHelpLabeled, Label, \"\") { return arg.label == Label; }\nMATCHER_P(Kind, K, \"\") { return arg.Kind == K; }\nMATCHER_P(Doc, D, \"\") {\n  return arg.Documentation && arg.Documentation->asPlainText() == D;\n}\nMATCHER_P(ReturnType, D, \"\") { return arg.ReturnType == D; }\nMATCHER_P(HasInclude, IncludeHeader, \"\") {\n  return !arg.Includes.empty() && arg.Includes[0].Header == IncludeHeader;\n}\nMATCHER_P(InsertInclude, IncludeHeader, \"\") {\n  return !arg.Includes.empty() && arg.Includes[0].Header == IncludeHeader &&\n         bool(arg.Includes[0].Insertion);\n}\nMATCHER(InsertInclude, \"\") {\n  return !arg.Includes.empty() && bool(arg.Includes[0].Insertion);\n}\nMATCHER_P(SnippetSuffix, Text, \"\") { return arg.SnippetSuffix == Text; }\nMATCHER_P(Origin, OriginSet, \"\") { return arg.Origin == OriginSet; }\nMATCHER_P(Signature, S, \"\") { return arg.Signature == S; }\n\n// Shorthand for Contains(Named(Name)).\nMatcher<const std::vector<CodeCompletion> &> Has(std::string Name) {\n  return Contains(Named(std::move(Name)));\n}\nMatcher<const std::vector<CodeCompletion> &> Has(std::string Name,\n                                                 CompletionItemKind K) {\n  return Contains(AllOf(Named(std::move(Name)), Kind(K)));\n}\nMATCHER(IsDocumented, \"\") { return arg.Documentation.hasValue(); }\nMATCHER(Deprecated, \"\") { return arg.Deprecated; }\n\nstd::unique_ptr<SymbolIndex> memIndex(std::vector<Symbol> Symbols) {\n  SymbolSlab::Builder Slab;\n  for (const auto &Sym : Symbols)\n    Slab.insert(Sym);\n  return MemIndex::build(std::move(Slab).build(), RefSlab(), RelationSlab());\n}\n\n// Runs code completion.\n// If IndexSymbols is non-empty, an index will be built and passed to opts.\nCodeCompleteResult completions(const TestTU &TU, Position Point,\n                               std::vector<Symbol> IndexSymbols = {},\n                               clangd::CodeCompleteOptions Opts = {}) {\n  std::unique_ptr<SymbolIndex> OverrideIndex;\n  if (!IndexSymbols.empty()) {\n    assert(!Opts.Index && \"both Index and IndexSymbols given!\");\n    OverrideIndex = memIndex(std::move(IndexSymbols));\n    Opts.Index = OverrideIndex.get();\n  }\n\n  MockFS FS;\n  auto Inputs = TU.inputs(FS);\n  IgnoreDiagnostics Diags;\n  auto CI = buildCompilerInvocation(Inputs, Diags);\n  if (!CI) {\n    ADD_FAILURE() << \"Couldn't build CompilerInvocation\";\n    return {};\n  }\n  auto Preamble = buildPreamble(testPath(TU.Filename), *CI, Inputs,\n                                /*InMemory=*/true, /*Callback=*/nullptr);\n  return codeComplete(testPath(TU.Filename), Point, Preamble.get(), Inputs,\n                      Opts);\n}\n\n// Runs code completion.\nCodeCompleteResult completions(llvm::StringRef Text,\n                               std::vector<Symbol> IndexSymbols = {},\n                               clangd::CodeCompleteOptions Opts = {},\n                               PathRef FilePath = \"foo.cpp\") {\n  Annotations Test(Text);\n  auto TU = TestTU::withCode(Test.code());\n  // To make sure our tests for completiopns inside templates work on Windows.\n  TU.Filename = FilePath.str();\n  return completions(TU, Test.point(), std::move(IndexSymbols),\n                     std::move(Opts));\n}\n\n// Runs code completion without the clang parser.\nCodeCompleteResult completionsNoCompile(llvm::StringRef Text,\n                                        std::vector<Symbol> IndexSymbols = {},\n                                        clangd::CodeCompleteOptions Opts = {},\n                                        PathRef FilePath = \"foo.cpp\") {\n  std::unique_ptr<SymbolIndex> OverrideIndex;\n  if (!IndexSymbols.empty()) {\n    assert(!Opts.Index && \"both Index and IndexSymbols given!\");\n    OverrideIndex = memIndex(std::move(IndexSymbols));\n    Opts.Index = OverrideIndex.get();\n  }\n\n  MockFS FS;\n  Annotations Test(Text);\n  ParseInputs ParseInput{tooling::CompileCommand(), &FS, Test.code().str()};\n  return codeComplete(FilePath, Test.point(), /*Preamble=*/nullptr, ParseInput,\n                      Opts);\n}\n\nSymbol withReferences(int N, Symbol S) {\n  S.References = N;\n  return S;\n}\n\nTEST(DecisionForestRankingModel, NameMatchSanityTest) {\n  clangd::CodeCompleteOptions Opts;\n  Opts.RankingModel = CodeCompleteOptions::DecisionForest;\n  auto Results = completions(\n      R\"cpp(\nstruct MemberAccess {\n  int ABG();\n  int AlphaBetaGamma();\n};\nint func() { MemberAccess().ABG^ }\n)cpp\",\n      /*IndexSymbols=*/{}, Opts);\n  EXPECT_THAT(Results.Completions,\n              ElementsAre(Named(\"ABG\"), Named(\"AlphaBetaGamma\")));\n}\n\nTEST(DecisionForestRankingModel, ReferencesAffectRanking) {\n  clangd::CodeCompleteOptions Opts;\n  Opts.RankingModel = CodeCompleteOptions::DecisionForest;\n  constexpr int NumReferences = 100000;\n  EXPECT_THAT(\n      completions(\"int main() { clang^ }\",\n                  {ns(\"clangA\"), withReferences(NumReferences, func(\"clangD\"))},\n                  Opts)\n          .Completions,\n      ElementsAre(Named(\"clangD\"), Named(\"clangA\")));\n  EXPECT_THAT(\n      completions(\"int main() { clang^ }\",\n                  {withReferences(NumReferences, ns(\"clangA\")), func(\"clangD\")},\n                  Opts)\n          .Completions,\n      ElementsAre(Named(\"clangA\"), Named(\"clangD\")));\n}\n\nTEST(DecisionForestRankingModel, DecisionForestScorerCallbackTest) {\n  clangd::CodeCompleteOptions Opts;\n  constexpr float MagicNumber = 1234.5678f;\n  Opts.RankingModel = CodeCompleteOptions::DecisionForest;\n  Opts.DecisionForestScorer = [&](const SymbolQualitySignals &,\n                                  const SymbolRelevanceSignals &, float Base) {\n    DecisionForestScores Scores;\n    Scores.Total = MagicNumber;\n    Scores.ExcludingName = MagicNumber;\n    return Scores;\n  };\n  llvm::StringRef Code = \"int func() { int xyz; xy^ }\";\n  auto Results = completions(Code,\n                             /*IndexSymbols=*/{}, Opts);\n  ASSERT_EQ(Results.Completions.size(), 1u);\n  EXPECT_EQ(Results.Completions[0].Score.Total, MagicNumber);\n  EXPECT_EQ(Results.Completions[0].Score.ExcludingName, MagicNumber);\n\n  // Do not use DecisionForestScorer for heuristics model.\n  Opts.RankingModel = CodeCompleteOptions::Heuristics;\n  Results = completions(Code,\n                        /*IndexSymbols=*/{}, Opts);\n  ASSERT_EQ(Results.Completions.size(), 1u);\n  EXPECT_NE(Results.Completions[0].Score.Total, MagicNumber);\n  EXPECT_NE(Results.Completions[0].Score.ExcludingName, MagicNumber);\n}\n\nTEST(CompletionTest, Limit) {\n  clangd::CodeCompleteOptions Opts;\n  Opts.Limit = 2;\n  auto Results = completions(R\"cpp(\nstruct ClassWithMembers {\n  int AAA();\n  int BBB();\n  int CCC();\n};\n\nint main() { ClassWithMembers().^ }\n      )cpp\",\n                             /*IndexSymbols=*/{}, Opts);\n\n  EXPECT_TRUE(Results.HasMore);\n  EXPECT_THAT(Results.Completions, ElementsAre(Named(\"AAA\"), Named(\"BBB\")));\n}\n\nTEST(CompletionTest, Filter) {\n  std::string Body = R\"cpp(\n    #define MotorCar\n    int Car;\n    struct S {\n      int FooBar;\n      int FooBaz;\n      int Qux;\n    };\n  )cpp\";\n\n  // Only items matching the fuzzy query are returned.\n  EXPECT_THAT(completions(Body + \"int main() { S().Foba^ }\").Completions,\n              AllOf(Has(\"FooBar\"), Has(\"FooBaz\"), Not(Has(\"Qux\"))));\n\n  // Macros require prefix match, either from index or AST.\n  Symbol Sym = var(\"MotorCarIndex\");\n  Sym.SymInfo.Kind = index::SymbolKind::Macro;\n  EXPECT_THAT(\n      completions(Body + \"int main() { C^ }\", {Sym}).Completions,\n      AllOf(Has(\"Car\"), Not(Has(\"MotorCar\")), Not(Has(\"MotorCarIndex\"))));\n  EXPECT_THAT(completions(Body + \"int main() { M^ }\", {Sym}).Completions,\n              AllOf(Has(\"MotorCar\"), Has(\"MotorCarIndex\")));\n}\n\nvoid testAfterDotCompletion(clangd::CodeCompleteOptions Opts) {\n  auto Results = completions(\n      R\"cpp(\n      int global_var;\n\n      int global_func();\n\n      // Make sure this is not in preamble.\n      #define MACRO X\n\n      struct GlobalClass {};\n\n      struct ClassWithMembers {\n        /// Doc for method.\n        int method();\n\n        int field;\n      private:\n        int private_field;\n      };\n\n      int test() {\n        struct LocalClass {};\n\n        /// Doc for local_var.\n        int local_var;\n\n        ClassWithMembers().^\n      }\n      )cpp\",\n      {cls(\"IndexClass\"), var(\"index_var\"), func(\"index_func\")}, Opts);\n\n  EXPECT_TRUE(Results.RanParser);\n  // Class members. The only items that must be present in after-dot\n  // completion.\n  EXPECT_THAT(Results.Completions,\n              AllOf(Has(\"method\"), Has(\"field\"), Not(Has(\"ClassWithMembers\")),\n                    Not(Has(\"operator=\")), Not(Has(\"~ClassWithMembers\"))));\n  EXPECT_IFF(Opts.IncludeIneligibleResults, Results.Completions,\n             Has(\"private_field\"));\n  // Global items.\n  EXPECT_THAT(\n      Results.Completions,\n      Not(AnyOf(Has(\"global_var\"), Has(\"index_var\"), Has(\"global_func\"),\n                Has(\"global_func()\"), Has(\"index_func\"), Has(\"GlobalClass\"),\n                Has(\"IndexClass\"), Has(\"MACRO\"), Has(\"LocalClass\"))));\n  // There should be no code patterns (aka snippets) in after-dot\n  // completion. At least there aren't any we're aware of.\n  EXPECT_THAT(Results.Completions,\n              Not(Contains(Kind(CompletionItemKind::Snippet))));\n  // Check documentation.\n  EXPECT_THAT(Results.Completions, Contains(IsDocumented()));\n}\n\nvoid testGlobalScopeCompletion(clangd::CodeCompleteOptions Opts) {\n  auto Results = completions(\n      R\"cpp(\n      int global_var;\n      int global_func();\n\n      // Make sure this is not in preamble.\n      #define MACRO X\n\n      struct GlobalClass {};\n\n      struct ClassWithMembers {\n        /// Doc for method.\n        int method();\n      };\n\n      int test() {\n        struct LocalClass {};\n\n        /// Doc for local_var.\n        int local_var;\n\n        ^\n      }\n      )cpp\",\n      {cls(\"IndexClass\"), var(\"index_var\"), func(\"index_func\")}, Opts);\n\n  EXPECT_TRUE(Results.RanParser);\n  // Class members. Should never be present in global completions.\n  EXPECT_THAT(Results.Completions,\n              Not(AnyOf(Has(\"method\"), Has(\"method()\"), Has(\"field\"))));\n  // Global items.\n  EXPECT_THAT(Results.Completions,\n              AllOf(Has(\"global_var\"), Has(\"index_var\"), Has(\"global_func\"),\n                    Has(\"index_func\" /* our fake symbol doesn't include () */),\n                    Has(\"GlobalClass\"), Has(\"IndexClass\")));\n  // A macro.\n  EXPECT_THAT(Results.Completions, Has(\"MACRO\"));\n  // Local items. Must be present always.\n  EXPECT_THAT(Results.Completions,\n              AllOf(Has(\"local_var\"), Has(\"LocalClass\"),\n                    Contains(Kind(CompletionItemKind::Snippet))));\n  // Check documentation.\n  EXPECT_THAT(Results.Completions, Contains(IsDocumented()));\n}\n\nTEST(CompletionTest, CompletionOptions) {\n  auto Test = [&](const clangd::CodeCompleteOptions &Opts) {\n    testAfterDotCompletion(Opts);\n    testGlobalScopeCompletion(Opts);\n  };\n  // We used to test every combination of options, but that got too slow (2^N).\n  auto Flags = {\n      &clangd::CodeCompleteOptions::IncludeIneligibleResults,\n  };\n  // Test default options.\n  Test({});\n  // Test with one flag flipped.\n  for (auto &F : Flags) {\n    clangd::CodeCompleteOptions O;\n    O.*F ^= true;\n    Test(O);\n  }\n}\n\nTEST(CompletionTest, Accessible) {\n  auto Internal = completions(R\"cpp(\n      class Foo {\n        public: void pub();\n        protected: void prot();\n        private: void priv();\n      };\n      void Foo::pub() { this->^ }\n  )cpp\");\n  EXPECT_THAT(Internal.Completions,\n              AllOf(Has(\"priv\"), Has(\"prot\"), Has(\"pub\")));\n\n  auto External = completions(R\"cpp(\n      class Foo {\n        public: void pub();\n        protected: void prot();\n        private: void priv();\n      };\n      void test() {\n        Foo F;\n        F.^\n      }\n  )cpp\");\n  EXPECT_THAT(External.Completions,\n              AllOf(Has(\"pub\"), Not(Has(\"prot\")), Not(Has(\"priv\"))));\n}\n\nTEST(CompletionTest, Qualifiers) {\n  auto Results = completions(R\"cpp(\n      class Foo {\n        public: int foo() const;\n        int bar() const;\n      };\n      class Bar : public Foo {\n        int foo() const;\n      };\n      void test() { Bar().^ }\n  )cpp\");\n  EXPECT_THAT(Results.Completions,\n              Contains(AllOf(Qualifier(\"\"), Named(\"bar\"))));\n  // Hidden members are not shown.\n  EXPECT_THAT(Results.Completions,\n              Not(Contains(AllOf(Qualifier(\"Foo::\"), Named(\"foo\")))));\n  // Private members are not shown.\n  EXPECT_THAT(Results.Completions,\n              Not(Contains(AllOf(Qualifier(\"\"), Named(\"foo\")))));\n}\n\nTEST(CompletionTest, InjectedTypename) {\n  // These are suppressed when accessed as a member...\n  EXPECT_THAT(completions(\"struct X{}; void foo(){ X().^ }\").Completions,\n              Not(Has(\"X\")));\n  EXPECT_THAT(completions(\"struct X{ void foo(){ this->^ } };\").Completions,\n              Not(Has(\"X\")));\n  // ...but accessible in other, more useful cases.\n  EXPECT_THAT(completions(\"struct X{ void foo(){ ^ } };\").Completions,\n              Has(\"X\"));\n  EXPECT_THAT(\n      completions(\"struct Y{}; struct X:Y{ void foo(){ ^ } };\").Completions,\n      Has(\"Y\"));\n  EXPECT_THAT(\n      completions(\n          \"template<class> struct Y{}; struct X:Y<int>{ void foo(){ ^ } };\")\n          .Completions,\n      Has(\"Y\"));\n  // This case is marginal (`using X::X` is useful), we allow it for now.\n  EXPECT_THAT(completions(\"struct X{}; void foo(){ X::^ }\").Completions,\n              Has(\"X\"));\n}\n\nTEST(CompletionTest, SkipInjectedWhenUnqualified) {\n  EXPECT_THAT(completions(\"struct X { void f() { X^ }};\").Completions,\n              ElementsAre(Named(\"X\"), Named(\"~X\")));\n}\n\nTEST(CompletionTest, Snippets) {\n  clangd::CodeCompleteOptions Opts;\n  auto Results = completions(\n      R\"cpp(\n      struct fake {\n        int a;\n        int f(int i, const float f) const;\n      };\n      int main() {\n        fake f;\n        f.^\n      }\n      )cpp\",\n      /*IndexSymbols=*/{}, Opts);\n  EXPECT_THAT(\n      Results.Completions,\n      HasSubsequence(Named(\"a\"),\n                     SnippetSuffix(\"(${1:int i}, ${2:const float f})\")));\n}\n\nTEST(CompletionTest, NoSnippetsInUsings) {\n  clangd::CodeCompleteOptions Opts;\n  Opts.EnableSnippets = true;\n  auto Results = completions(\n      R\"cpp(\n      namespace ns {\n        int func(int a, int b);\n      }\n\n      using ns::^;\n      )cpp\",\n      /*IndexSymbols=*/{}, Opts);\n  EXPECT_THAT(Results.Completions,\n              ElementsAre(AllOf(Named(\"func\"), Labeled(\"func(int a, int b)\"),\n                                SnippetSuffix(\"\"))));\n\n  // Check index completions too.\n  auto Func = func(\"ns::func\");\n  Func.CompletionSnippetSuffix = \"(${1:int a}, ${2: int b})\";\n  Func.Signature = \"(int a, int b)\";\n  Func.ReturnType = \"void\";\n\n  Results = completions(R\"cpp(\n      namespace ns {}\n      using ns::^;\n  )cpp\",\n                        /*IndexSymbols=*/{Func}, Opts);\n  EXPECT_THAT(Results.Completions,\n              ElementsAre(AllOf(Named(\"func\"), Labeled(\"func(int a, int b)\"),\n                                SnippetSuffix(\"\"))));\n\n  // Check all-scopes completions too.\n  Opts.AllScopes = true;\n  Results = completions(R\"cpp(\n      using ^;\n  )cpp\",\n                        /*IndexSymbols=*/{Func}, Opts);\n  EXPECT_THAT(Results.Completions,\n              Contains(AllOf(Named(\"func\"), Labeled(\"ns::func(int a, int b)\"),\n                             SnippetSuffix(\"\"))));\n}\n\nTEST(CompletionTest, Kinds) {\n  auto Results = completions(\n      R\"cpp(\n          int variable;\n          struct Struct {};\n          int function();\n          // make sure MACRO is not included in preamble.\n          #define MACRO 10\n          int X = ^\n      )cpp\",\n      {func(\"indexFunction\"), var(\"indexVariable\"), cls(\"indexClass\")});\n  EXPECT_THAT(Results.Completions,\n              AllOf(Has(\"function\", CompletionItemKind::Function),\n                    Has(\"variable\", CompletionItemKind::Variable),\n                    Has(\"int\", CompletionItemKind::Keyword),\n                    Has(\"Struct\", CompletionItemKind::Struct),\n                    Has(\"MACRO\", CompletionItemKind::Text),\n                    Has(\"indexFunction\", CompletionItemKind::Function),\n                    Has(\"indexVariable\", CompletionItemKind::Variable),\n                    Has(\"indexClass\", CompletionItemKind::Class)));\n\n  Results = completions(\"nam^\");\n  EXPECT_THAT(Results.Completions,\n              Has(\"namespace\", CompletionItemKind::Snippet));\n\n  // Members of anonymous unions are of kind 'field'.\n  Results = completions(\n      R\"cpp(\n        struct X{\n            union {\n              void *a;\n            };\n        };\n        auto u = X().^\n      )cpp\");\n  EXPECT_THAT(\n      Results.Completions,\n      UnorderedElementsAre(AllOf(Named(\"a\"), Kind(CompletionItemKind::Field))));\n\n  // Completion kinds for templates should not be unknown.\n  Results = completions(\n      R\"cpp(\n        template <class T> struct complete_class {};\n        template <class T> void complete_function();\n        template <class T> using complete_type_alias = int;\n        template <class T> int complete_variable = 10;\n\n        struct X {\n          template <class T> static int complete_static_member = 10;\n\n          static auto x = complete_^\n        }\n      )cpp\");\n  EXPECT_THAT(\n      Results.Completions,\n      UnorderedElementsAre(\n          AllOf(Named(\"complete_class\"), Kind(CompletionItemKind::Class)),\n          AllOf(Named(\"complete_function\"), Kind(CompletionItemKind::Function)),\n          AllOf(Named(\"complete_type_alias\"),\n                Kind(CompletionItemKind::Interface)),\n          AllOf(Named(\"complete_variable\"), Kind(CompletionItemKind::Variable)),\n          AllOf(Named(\"complete_static_member\"),\n                Kind(CompletionItemKind::Property))));\n\n  Results = completions(\n      R\"cpp(\n        enum Color {\n          Red\n        };\n        Color u = ^\n      )cpp\");\n  EXPECT_THAT(\n      Results.Completions,\n      Contains(AllOf(Named(\"Red\"), Kind(CompletionItemKind::EnumMember))));\n}\n\nTEST(CompletionTest, NoDuplicates) {\n  auto Results = completions(\n      R\"cpp(\n          class Adapter {\n          };\n\n          void f() {\n            Adapter^\n          }\n      )cpp\",\n      {cls(\"Adapter\")});\n\n  // Make sure there are no duplicate entries of 'Adapter'.\n  EXPECT_THAT(Results.Completions, ElementsAre(Named(\"Adapter\")));\n}\n\nTEST(CompletionTest, ScopedNoIndex) {\n  auto Results = completions(\n      R\"cpp(\n          namespace fake { int BigBang, Babble, Box; };\n          int main() { fake::ba^ }\n      \")cpp\");\n  // Babble is a better match than BigBang. Box doesn't match at all.\n  EXPECT_THAT(Results.Completions,\n              ElementsAre(Named(\"Babble\"), Named(\"BigBang\")));\n}\n\nTEST(CompletionTest, Scoped) {\n  auto Results = completions(\n      R\"cpp(\n          namespace fake { int Babble, Box; };\n          int main() { fake::ba^ }\n      \")cpp\",\n      {var(\"fake::BigBang\")});\n  EXPECT_THAT(Results.Completions,\n              ElementsAre(Named(\"Babble\"), Named(\"BigBang\")));\n}\n\nTEST(CompletionTest, ScopedWithFilter) {\n  auto Results = completions(\n      R\"cpp(\n          void f() { ns::x^ }\n      )cpp\",\n      {cls(\"ns::XYZ\"), func(\"ns::foo\")});\n  EXPECT_THAT(Results.Completions, UnorderedElementsAre(Named(\"XYZ\")));\n}\n\nTEST(CompletionTest, ReferencesAffectRanking) {\n  EXPECT_THAT(completions(\"int main() { abs^ }\", {func(\"absA\"), func(\"absB\")})\n                  .Completions,\n              HasSubsequence(Named(\"absA\"), Named(\"absB\")));\n  EXPECT_THAT(completions(\"int main() { abs^ }\",\n                          {func(\"absA\"), withReferences(1000, func(\"absB\"))})\n                  .Completions,\n              HasSubsequence(Named(\"absB\"), Named(\"absA\")));\n}\n\nTEST(CompletionTest, ContextWords) {\n  auto Results = completions(R\"cpp(\n  enum class Color { RED, YELLOW, BLUE };\n\n  // (blank lines so the definition above isn't \"context\")\n\n  // \"It was a yellow car,\" he said. \"Big yellow car, new.\"\n  auto Finish = Color::^\n  )cpp\");\n  // Yellow would normally sort last (alphabetic).\n  // But the recent mention should bump it up.\n  ASSERT_THAT(Results.Completions,\n              HasSubsequence(Named(\"YELLOW\"), Named(\"BLUE\")));\n}\n\nTEST(CompletionTest, GlobalQualified) {\n  auto Results = completions(\n      R\"cpp(\n          void f() { ::^ }\n      )cpp\",\n      {cls(\"XYZ\")});\n  EXPECT_THAT(Results.Completions,\n              AllOf(Has(\"XYZ\", CompletionItemKind::Class),\n                    Has(\"f\", CompletionItemKind::Function)));\n}\n\nTEST(CompletionTest, FullyQualified) {\n  auto Results = completions(\n      R\"cpp(\n          namespace ns { void bar(); }\n          void f() { ::ns::^ }\n      )cpp\",\n      {cls(\"ns::XYZ\")});\n  EXPECT_THAT(Results.Completions,\n              AllOf(Has(\"XYZ\", CompletionItemKind::Class),\n                    Has(\"bar\", CompletionItemKind::Function)));\n}\n\nTEST(CompletionTest, SemaIndexMerge) {\n  auto Results = completions(\n      R\"cpp(\n          namespace ns { int local; void both(); }\n          void f() { ::ns::^ }\n      )cpp\",\n      {func(\"ns::both\"), cls(\"ns::Index\")});\n  // We get results from both index and sema, with no duplicates.\n  EXPECT_THAT(Results.Completions,\n              UnorderedElementsAre(\n                  AllOf(Named(\"local\"), Origin(SymbolOrigin::AST)),\n                  AllOf(Named(\"Index\"), Origin(SymbolOrigin::Static)),\n                  AllOf(Named(\"both\"),\n                        Origin(SymbolOrigin::AST | SymbolOrigin::Static))));\n}\n\nTEST(CompletionTest, SemaIndexMergeWithLimit) {\n  clangd::CodeCompleteOptions Opts;\n  Opts.Limit = 1;\n  auto Results = completions(\n      R\"cpp(\n          namespace ns { int local; void both(); }\n          void f() { ::ns::^ }\n      )cpp\",\n      {func(\"ns::both\"), cls(\"ns::Index\")}, Opts);\n  EXPECT_EQ(Results.Completions.size(), Opts.Limit);\n  EXPECT_TRUE(Results.HasMore);\n}\n\nTEST(CompletionTest, IncludeInsertionPreprocessorIntegrationTests) {\n  TestTU TU;\n  TU.ExtraArgs.push_back(\"-I\" + testPath(\"sub\"));\n  TU.AdditionalFiles[\"sub/bar.h\"] = \"\";\n  auto BarURI = URI::create(testPath(\"sub/bar.h\")).toString();\n\n  Symbol Sym = cls(\"ns::X\");\n  Sym.CanonicalDeclaration.FileURI = BarURI.c_str();\n  Sym.IncludeHeaders.emplace_back(BarURI, 1);\n  // Shorten include path based on search directory and insert.\n  Annotations Test(\"int main() { ns::^ }\");\n  TU.Code = Test.code().str();\n  auto Results = completions(TU, Test.point(), {Sym});\n  EXPECT_THAT(Results.Completions,\n              ElementsAre(AllOf(Named(\"X\"), InsertInclude(\"\\\"bar.h\\\"\"))));\n  // Can be disabled via option.\n  CodeCompleteOptions NoInsertion;\n  NoInsertion.InsertIncludes = CodeCompleteOptions::NeverInsert;\n  Results = completions(TU, Test.point(), {Sym}, NoInsertion);\n  EXPECT_THAT(Results.Completions,\n              ElementsAre(AllOf(Named(\"X\"), Not(InsertInclude()))));\n  // Duplicate based on inclusions in preamble.\n  Test = Annotations(R\"cpp(\n          #include \"sub/bar.h\"  // not shortest, so should only match resolved.\n          int main() { ns::^ }\n      )cpp\");\n  TU.Code = Test.code().str();\n  Results = completions(TU, Test.point(), {Sym});\n  EXPECT_THAT(Results.Completions, ElementsAre(AllOf(Named(\"X\"), Labeled(\"X\"),\n                                                     Not(InsertInclude()))));\n}\n\nTEST(CompletionTest, NoIncludeInsertionWhenDeclFoundInFile) {\n  Symbol SymX = cls(\"ns::X\");\n  Symbol SymY = cls(\"ns::Y\");\n  std::string BarHeader = testPath(\"bar.h\");\n  auto BarURI = URI::create(BarHeader).toString();\n  SymX.CanonicalDeclaration.FileURI = BarURI.c_str();\n  SymY.CanonicalDeclaration.FileURI = BarURI.c_str();\n  SymX.IncludeHeaders.emplace_back(\"<bar>\", 1);\n  SymY.IncludeHeaders.emplace_back(\"<bar>\", 1);\n  // Shorten include path based on search directory and insert.\n  auto Results = completions(R\"cpp(\n          namespace ns {\n            class X;\n            class Y {};\n          }\n          int main() { ns::^ }\n      )cpp\",\n                             {SymX, SymY});\n  EXPECT_THAT(Results.Completions,\n              ElementsAre(AllOf(Named(\"X\"), Not(InsertInclude())),\n                          AllOf(Named(\"Y\"), Not(InsertInclude()))));\n}\n\nTEST(CompletionTest, IndexSuppressesPreambleCompletions) {\n  Annotations Test(R\"cpp(\n      #include \"bar.h\"\n      namespace ns { int local; }\n      void f() { ns::^; }\n      void f2() { ns::preamble().$2^; }\n  )cpp\");\n  auto TU = TestTU::withCode(Test.code());\n  TU.AdditionalFiles[\"bar.h\"] =\n      R\"cpp(namespace ns { struct preamble { int member; }; })cpp\";\n\n  clangd::CodeCompleteOptions Opts = {};\n  auto I = memIndex({var(\"ns::index\")});\n  Opts.Index = I.get();\n  auto WithIndex = completions(TU, Test.point(), {}, Opts);\n  EXPECT_THAT(WithIndex.Completions,\n              UnorderedElementsAre(Named(\"local\"), Named(\"index\")));\n  auto ClassFromPreamble = completions(TU, Test.point(\"2\"), {}, Opts);\n  EXPECT_THAT(ClassFromPreamble.Completions, Contains(Named(\"member\")));\n\n  Opts.Index = nullptr;\n  auto WithoutIndex = completions(TU, Test.point(), {}, Opts);\n  EXPECT_THAT(WithoutIndex.Completions,\n              UnorderedElementsAre(Named(\"local\"), Named(\"preamble\")));\n}\n\n// This verifies that we get normal preprocessor completions in the preamble.\n// This is a regression test for an old bug: if we override the preamble and\n// try to complete inside it, clang kicks our completion point just outside the\n// preamble, resulting in always getting top-level completions.\nTEST(CompletionTest, CompletionInPreamble) {\n  auto Results = completions(R\"cpp(\n    #ifnd^ef FOO_H_\n    #define BAR_H_\n    #include <bar.h>\n    int foo() {}\n    #endif\n    )cpp\")\n                     .Completions;\n  EXPECT_THAT(Results, ElementsAre(Named(\"ifndef\")));\n}\n\nTEST(CompletionTest, CompletionRecoveryASTType) {\n  auto Results = completions(R\"cpp(\n    struct S { int member; };\n    S overloaded(int);\n    void foo() {\n      // No overload matches, but we have recovery-expr with the correct type.\n      overloaded().^\n    })cpp\")\n                     .Completions;\n  EXPECT_THAT(Results, ElementsAre(Named(\"member\")));\n}\n\nTEST(CompletionTest, DynamicIndexIncludeInsertion) {\n  MockFS FS;\n  MockCompilationDatabase CDB;\n  ClangdServer::Options Opts = ClangdServer::optsForTest();\n  Opts.BuildDynamicSymbolIndex = true;\n  ClangdServer Server(CDB, FS, Opts);\n\n  FS.Files[testPath(\"foo_header.h\")] = R\"cpp(\n    #pragma once\n    struct Foo {\n       // Member doc\n       int foo();\n    };\n  )cpp\";\n  const std::string FileContent(R\"cpp(\n    #include \"foo_header.h\"\n    int Foo::foo() {\n      return 42;\n    }\n  )cpp\");\n  Server.addDocument(testPath(\"foo_impl.cpp\"), FileContent);\n  // Wait for the dynamic index being built.\n  ASSERT_TRUE(Server.blockUntilIdleForTest());\n\n  auto File = testPath(\"foo.cpp\");\n  Annotations Test(\"Foo^ foo;\");\n  runAddDocument(Server, File, Test.code());\n  auto CompletionList =\n      llvm::cantFail(runCodeComplete(Server, File, Test.point(), {}));\n\n  EXPECT_THAT(CompletionList.Completions,\n              ElementsAre(AllOf(Named(\"Foo\"), HasInclude(\"\\\"foo_header.h\\\"\"),\n                                InsertInclude())));\n}\n\nTEST(CompletionTest, DynamicIndexMultiFile) {\n  MockFS FS;\n  MockCompilationDatabase CDB;\n  auto Opts = ClangdServer::optsForTest();\n  Opts.BuildDynamicSymbolIndex = true;\n  ClangdServer Server(CDB, FS, Opts);\n\n  FS.Files[testPath(\"foo.h\")] = R\"cpp(\n      namespace ns { class XYZ {}; void foo(int x) {} }\n  )cpp\";\n  runAddDocument(Server, testPath(\"foo.cpp\"), R\"cpp(\n      #include \"foo.h\"\n  )cpp\");\n\n  auto File = testPath(\"bar.cpp\");\n  Annotations Test(R\"cpp(\n      namespace ns {\n      class XXX {};\n      /// Doooc\n      void fooooo() {}\n      }\n      void f() { ns::^ }\n  )cpp\");\n  runAddDocument(Server, File, Test.code());\n\n  auto Results = cantFail(runCodeComplete(Server, File, Test.point(), {}));\n  // \"XYZ\" and \"foo\" are not included in the file being completed but are still\n  // visible through the index.\n  EXPECT_THAT(Results.Completions, Has(\"XYZ\", CompletionItemKind::Class));\n  EXPECT_THAT(Results.Completions, Has(\"foo\", CompletionItemKind::Function));\n  EXPECT_THAT(Results.Completions, Has(\"XXX\", CompletionItemKind::Class));\n  EXPECT_THAT(Results.Completions,\n              Contains((Named(\"fooooo\"), Kind(CompletionItemKind::Function),\n                        Doc(\"Doooc\"), ReturnType(\"void\"))));\n}\n\nTEST(CompletionTest, Documentation) {\n  auto Results = completions(\n      R\"cpp(\n      // Non-doxygen comment.\n      int foo();\n      /// Doxygen comment.\n      /// \\param int a\n      int bar(int a);\n      /* Multi-line\n         block comment\n      */\n      int baz();\n\n      int x = ^\n     )cpp\");\n  EXPECT_THAT(Results.Completions,\n              Contains(AllOf(Named(\"foo\"), Doc(\"Non-doxygen comment.\"))));\n  EXPECT_THAT(\n      Results.Completions,\n      Contains(AllOf(Named(\"bar\"), Doc(\"Doxygen comment.\\n\\\\param int a\"))));\n  EXPECT_THAT(Results.Completions,\n              Contains(AllOf(Named(\"baz\"), Doc(\"Multi-line block comment\"))));\n}\n\nTEST(CompletionTest, CommentsFromSystemHeaders) {\n  MockFS FS;\n  MockCompilationDatabase CDB;\n\n  auto Opts = ClangdServer::optsForTest();\n  Opts.BuildDynamicSymbolIndex = true;\n\n  ClangdServer Server(CDB, FS, Opts);\n\n  FS.Files[testPath(\"foo.h\")] = R\"cpp(\n    #pragma GCC system_header\n\n    // This comment should be retained!\n    int foo();\n  )cpp\";\n\n  auto File = testPath(\"foo.cpp\");\n  Annotations Test(R\"cpp(\n#include \"foo.h\"\nint x = foo^\n     )cpp\");\n  runAddDocument(Server, File, Test.code());\n  auto CompletionList =\n      llvm::cantFail(runCodeComplete(Server, File, Test.point(), {}));\n\n  EXPECT_THAT(\n      CompletionList.Completions,\n      Contains(AllOf(Named(\"foo\"), Doc(\"This comment should be retained!\"))));\n}\n\nTEST(CompletionTest, GlobalCompletionFiltering) {\n\n  Symbol Class = cls(\"XYZ\");\n  Class.Flags = static_cast<Symbol::SymbolFlag>(\n      Class.Flags & ~(Symbol::IndexedForCodeCompletion));\n  Symbol Func = func(\"XYZ::foooo\");\n  Func.Flags = static_cast<Symbol::SymbolFlag>(\n      Func.Flags & ~(Symbol::IndexedForCodeCompletion));\n\n  auto Results = completions(R\"(//      void f() {\n      XYZ::foooo^\n      })\",\n                             {Class, Func});\n  EXPECT_THAT(Results.Completions, IsEmpty());\n}\n\nTEST(CodeCompleteTest, DisableTypoCorrection) {\n  auto Results = completions(R\"cpp(\n     namespace clang { int v; }\n     void f() { clangd::^\n  )cpp\");\n  EXPECT_TRUE(Results.Completions.empty());\n}\n\nTEST(CodeCompleteTest, NoColonColonAtTheEnd) {\n  auto Results = completions(R\"cpp(\n    namespace clang { }\n    void f() {\n      clan^\n    }\n  )cpp\");\n\n  EXPECT_THAT(Results.Completions, Contains(Labeled(\"clang\")));\n  EXPECT_THAT(Results.Completions, Not(Contains(Labeled(\"clang::\"))));\n}\n\nTEST(CompletionTest, BacktrackCrashes) {\n  // Sema calls code completion callbacks twice in these cases.\n  auto Results = completions(R\"cpp(\n      namespace ns {\n      struct FooBarBaz {};\n      } // namespace ns\n\n     int foo(ns::FooBar^\n  )cpp\");\n\n  EXPECT_THAT(Results.Completions, ElementsAre(Labeled(\"FooBarBaz\")));\n\n  // Check we don't crash in that case too.\n  completions(R\"cpp(\n    struct FooBarBaz {};\n    void test() {\n      if (FooBarBaz * x^) {}\n    }\n)cpp\");\n}\n\nTEST(CompletionTest, CompleteInMacroWithStringification) {\n  auto Results = completions(R\"cpp(\nvoid f(const char *, int x);\n#define F(x) f(#x, x)\n\nnamespace ns {\nint X;\nint Y;\n}  // namespace ns\n\nint f(int input_num) {\n  F(ns::^)\n}\n)cpp\");\n\n  EXPECT_THAT(Results.Completions,\n              UnorderedElementsAre(Named(\"X\"), Named(\"Y\")));\n}\n\nTEST(CompletionTest, CompleteInMacroAndNamespaceWithStringification) {\n  auto Results = completions(R\"cpp(\nvoid f(const char *, int x);\n#define F(x) f(#x, x)\n\nnamespace ns {\nint X;\n\nint f(int input_num) {\n  F(^)\n}\n}  // namespace ns\n)cpp\");\n\n  EXPECT_THAT(Results.Completions, Contains(Named(\"X\")));\n}\n\nTEST(CompletionTest, IgnoreCompleteInExcludedPPBranchWithRecoveryContext) {\n  auto Results = completions(R\"cpp(\n    int bar(int param_in_bar) {\n    }\n\n    int foo(int param_in_foo) {\n#if 0\n  // In recovery mode, \"param_in_foo\" will also be suggested among many other\n  // unrelated symbols; however, this is really a special case where this works.\n  // If the #if block is outside of the function, \"param_in_foo\" is still\n  // suggested, but \"bar\" and \"foo\" are missing. So the recovery mode doesn't\n  // really provide useful results in excluded branches.\n  par^\n#endif\n    }\n)cpp\");\n\n  EXPECT_TRUE(Results.Completions.empty());\n}\n\nTEST(CompletionTest, DefaultArgs) {\n  clangd::CodeCompleteOptions Opts;\n  std::string Context = R\"cpp(\n    int X(int A = 0);\n    int Y(int A, int B = 0);\n    int Z(int A, int B = 0, int C = 0, int D = 0);\n  )cpp\";\n  EXPECT_THAT(completions(Context + \"int y = X^\", {}, Opts).Completions,\n              UnorderedElementsAre(Labeled(\"X(int A = 0)\")));\n  EXPECT_THAT(completions(Context + \"int y = Y^\", {}, Opts).Completions,\n              UnorderedElementsAre(AllOf(Labeled(\"Y(int A, int B = 0)\"),\n                                         SnippetSuffix(\"(${1:int A})\"))));\n  EXPECT_THAT(completions(Context + \"int y = Z^\", {}, Opts).Completions,\n              UnorderedElementsAre(\n                  AllOf(Labeled(\"Z(int A, int B = 0, int C = 0, int D = 0)\"),\n                        SnippetSuffix(\"(${1:int A})\"))));\n}\n\nTEST(CompletionTest, NoCrashWithTemplateParamsAndPreferredTypes) {\n  auto Completions = completions(R\"cpp(\ntemplate <template <class> class TT> int foo() {\n  int a = ^\n}\n)cpp\")\n                         .Completions;\n  EXPECT_THAT(Completions, Contains(Named(\"TT\")));\n}\n\nTEST(CompletionTest, NestedTemplateHeuristics) {\n  auto Completions = completions(R\"cpp(\nstruct Plain { int xxx; };\ntemplate <typename T> class Templ { Plain ppp; };\ntemplate <typename T> void foo(Templ<T> &t) {\n  // Formally ppp has DependentTy, because Templ may be specialized.\n  // However we sholud be able to see into it using the primary template.\n  t.ppp.^\n}\n)cpp\")\n                         .Completions;\n  EXPECT_THAT(Completions, Contains(Named(\"xxx\")));\n}\n\nTEST(CompletionTest, RecordCCResultCallback) {\n  std::vector<CodeCompletion> RecordedCompletions;\n  CodeCompleteOptions Opts;\n  Opts.RecordCCResult = [&RecordedCompletions](const CodeCompletion &CC,\n                                               const SymbolQualitySignals &,\n                                               const SymbolRelevanceSignals &,\n                                               float Score) {\n    RecordedCompletions.push_back(CC);\n  };\n\n  completions(\"int xy1, xy2; int a = xy^\", /*IndexSymbols=*/{}, Opts);\n  EXPECT_THAT(RecordedCompletions,\n              UnorderedElementsAre(Named(\"xy1\"), Named(\"xy2\")));\n}\n\nTEST(CompletionTest, ASTSignals) {\n  struct Completion {\n    std::string Name;\n    unsigned MainFileRefs;\n    unsigned ScopeRefsInFile;\n  };\n  CodeCompleteOptions Opts;\n  std::vector<Completion> RecordedCompletions;\n  Opts.RecordCCResult = [&RecordedCompletions](const CodeCompletion &CC,\n                                               const SymbolQualitySignals &,\n                                               const SymbolRelevanceSignals &R,\n                                               float Score) {\n    RecordedCompletions.push_back({CC.Name, R.MainFileRefs, R.ScopeRefsInFile});\n  };\n  ASTSignals MainFileSignals;\n  MainFileSignals.ReferencedSymbols[var(\"xy1\").ID] = 3;\n  MainFileSignals.ReferencedSymbols[var(\"xy2\").ID] = 1;\n  MainFileSignals.ReferencedSymbols[var(\"xyindex\").ID] = 10;\n  MainFileSignals.RelatedNamespaces[\"tar::\"] = 5;\n  MainFileSignals.RelatedNamespaces[\"bar::\"] = 3;\n  Opts.MainFileSignals = &MainFileSignals;\n  Opts.AllScopes = true;\n  completions(\n      R\"cpp(\n      int xy1;\n      int xy2;\n      namespace bar {\n      int xybar = 1;\n      int a = xy^\n      }\n      )cpp\",\n      /*IndexSymbols=*/{var(\"xyindex\"), var(\"tar::xytar\"), var(\"bar::xybar\")},\n      Opts);\n  EXPECT_THAT(RecordedCompletions,\n              UnorderedElementsAre(\n                  AllOf(Named(\"xy1\"), MainFileRefs(3u), ScopeRefs(0u)),\n                  AllOf(Named(\"xy2\"), MainFileRefs(1u), ScopeRefs(0u)),\n                  AllOf(Named(\"xyindex\"), MainFileRefs(10u), ScopeRefs(0u)),\n                  AllOf(Named(\"xytar\"), MainFileRefs(0u), ScopeRefs(5u)),\n                  AllOf(/*both from sema and index*/ Named(\"xybar\"),\n                        MainFileRefs(0u), ScopeRefs(3u))));\n}\n\nSignatureHelp signatures(llvm::StringRef Text, Position Point,\n                         std::vector<Symbol> IndexSymbols = {}) {\n  std::unique_ptr<SymbolIndex> Index;\n  if (!IndexSymbols.empty())\n    Index = memIndex(IndexSymbols);\n\n  auto TU = TestTU::withCode(Text);\n  MockFS FS;\n  auto Inputs = TU.inputs(FS);\n  Inputs.Index = Index.get();\n  IgnoreDiagnostics Diags;\n  auto CI = buildCompilerInvocation(Inputs, Diags);\n  if (!CI) {\n    ADD_FAILURE() << \"Couldn't build CompilerInvocation\";\n    return {};\n  }\n  auto Preamble = buildPreamble(testPath(TU.Filename), *CI, Inputs,\n                                /*InMemory=*/true, /*Callback=*/nullptr);\n  if (!Preamble) {\n    ADD_FAILURE() << \"Couldn't build Preamble\";\n    return {};\n  }\n  return signatureHelp(testPath(TU.Filename), Point, *Preamble, Inputs);\n}\n\nSignatureHelp signatures(llvm::StringRef Text,\n                         std::vector<Symbol> IndexSymbols = {}) {\n  Annotations Test(Text);\n  return signatures(Test.code(), Test.point(), std::move(IndexSymbols));\n}\n\nstruct ExpectedParameter {\n  std::string Text;\n  std::pair<unsigned, unsigned> Offsets;\n};\nMATCHER_P(ParamsAre, P, \"\") {\n  if (P.size() != arg.parameters.size())\n    return false;\n  for (unsigned I = 0; I < P.size(); ++I) {\n    if (P[I].Text != arg.parameters[I].labelString ||\n        P[I].Offsets != arg.parameters[I].labelOffsets)\n      return false;\n  }\n  return true;\n}\nMATCHER_P(SigDoc, Doc, \"\") { return arg.documentation == Doc; }\n\n/// \\p AnnotatedLabel is a signature label with ranges marking parameters, e.g.\n///    foo([[int p1]], [[double p2]]) -> void\nMatcher<SignatureInformation> Sig(llvm::StringRef AnnotatedLabel) {\n  llvm::Annotations A(AnnotatedLabel);\n  std::string Label = std::string(A.code());\n  std::vector<ExpectedParameter> Parameters;\n  for (auto Range : A.ranges()) {\n    Parameters.emplace_back();\n\n    ExpectedParameter &P = Parameters.back();\n    P.Text = Label.substr(Range.Begin, Range.End - Range.Begin);\n    P.Offsets.first = lspLength(llvm::StringRef(Label).substr(0, Range.Begin));\n    P.Offsets.second = lspLength(llvm::StringRef(Label).substr(1, Range.End));\n  }\n  return AllOf(SigHelpLabeled(Label), ParamsAre(Parameters));\n}\n\nTEST(SignatureHelpTest, Overloads) {\n  auto Results = signatures(R\"cpp(\n    void foo(int x, int y);\n    void foo(int x, float y);\n    void foo(float x, int y);\n    void foo(float x, float y);\n    void bar(int x, int y = 0);\n    int main() { foo(^); }\n  )cpp\");\n  EXPECT_THAT(Results.signatures,\n              UnorderedElementsAre(Sig(\"foo([[float x]], [[float y]]) -> void\"),\n                                   Sig(\"foo([[float x]], [[int y]]) -> void\"),\n                                   Sig(\"foo([[int x]], [[float y]]) -> void\"),\n                                   Sig(\"foo([[int x]], [[int y]]) -> void\")));\n  // We always prefer the first signature.\n  EXPECT_EQ(0, Results.activeSignature);\n  EXPECT_EQ(0, Results.activeParameter);\n}\n\nTEST(SignatureHelpTest, DefaultArgs) {\n  auto Results = signatures(R\"cpp(\n    void bar(int x, int y = 0);\n    void bar(float x = 0, int y = 42);\n    int main() { bar(^\n  )cpp\");\n  EXPECT_THAT(Results.signatures,\n              UnorderedElementsAre(\n                  Sig(\"bar([[int x]], [[int y = 0]]) -> void\"),\n                  Sig(\"bar([[float x = 0]], [[int y = 42]]) -> void\")));\n  EXPECT_EQ(0, Results.activeSignature);\n  EXPECT_EQ(0, Results.activeParameter);\n}\n\nTEST(SignatureHelpTest, ActiveArg) {\n  auto Results = signatures(R\"cpp(\n    int baz(int a, int b, int c);\n    int main() { baz(baz(1,2,3), ^); }\n  )cpp\");\n  EXPECT_THAT(Results.signatures,\n              ElementsAre(Sig(\"baz([[int a]], [[int b]], [[int c]]) -> int\")));\n  EXPECT_EQ(0, Results.activeSignature);\n  EXPECT_EQ(1, Results.activeParameter);\n}\n\nTEST(SignatureHelpTest, OpeningParen) {\n  llvm::StringLiteral Tests[] = {\n      // Recursive function call.\n      R\"cpp(\n        int foo(int a, int b, int c);\n        int main() {\n          foo(foo $p^( foo(10, 10, 10), ^ )));\n        })cpp\",\n      // Functional type cast.\n      R\"cpp(\n        struct Foo {\n          Foo(int a, int b, int c);\n        };\n        int main() {\n          Foo $p^( 10, ^ );\n        })cpp\",\n      // New expression.\n      R\"cpp(\n        struct Foo {\n          Foo(int a, int b, int c);\n        };\n        int main() {\n          new Foo $p^( 10, ^ );\n        })cpp\",\n      // Macro expansion.\n      R\"cpp(\n        int foo(int a, int b, int c);\n        #define FOO foo(\n\n        int main() {\n          // Macro expansions.\n          $p^FOO 10, ^ );\n        })cpp\",\n      // Macro arguments.\n      R\"cpp(\n        int foo(int a, int b, int c);\n        int main() {\n        #define ID(X) X\n          // FIXME: figure out why ID(foo (foo(10), )) doesn't work when preserving\n          // the recovery expression.\n          ID(foo $p^( 10, ^ ))\n        })cpp\",\n      // Dependent args.\n      R\"cpp(\n        int foo(int a, int b);\n        template <typename T> void bar(T t) {\n          foo$p^(t, ^t);\n        })cpp\",\n      // Dependent args on templated func.\n      R\"cpp(\n        template <typename T>\n        int foo(T, T);\n        template <typename T> void bar(T t) {\n          foo$p^(t, ^t);\n        })cpp\",\n      // Dependent args on member.\n      R\"cpp(\n        struct Foo { int foo(int, int); };\n        template <typename T> void bar(T t) {\n          Foo f;\n          f.foo$p^(t, ^t);\n        })cpp\",\n      // Dependent args on templated member.\n      R\"cpp(\n        struct Foo { template <typename T> int foo(T, T); };\n        template <typename T> void bar(T t) {\n          Foo f;\n          f.foo$p^(t, ^t);\n        })cpp\",\n  };\n\n  for (auto Test : Tests) {\n    Annotations Code(Test);\n    EXPECT_EQ(signatures(Code.code(), Code.point()).argListStart,\n              Code.point(\"p\"))\n        << \"Test source:\" << Test;\n  }\n}\n\nTEST(SignatureHelpTest, StalePreamble) {\n  TestTU TU;\n  TU.Code = \"\";\n  IgnoreDiagnostics Diags;\n  MockFS FS;\n  auto Inputs = TU.inputs(FS);\n  auto CI = buildCompilerInvocation(Inputs, Diags);\n  ASSERT_TRUE(CI);\n  auto EmptyPreamble = buildPreamble(testPath(TU.Filename), *CI, Inputs,\n                                     /*InMemory=*/true, /*Callback=*/nullptr);\n  ASSERT_TRUE(EmptyPreamble);\n\n  TU.AdditionalFiles[\"a.h\"] = \"int foo(int x);\";\n  const Annotations Test(R\"cpp(\n    #include \"a.h\"\n    void bar() { foo(^2); })cpp\");\n  TU.Code = Test.code().str();\n  auto Results = signatureHelp(testPath(TU.Filename), Test.point(),\n                               *EmptyPreamble, TU.inputs(FS));\n  EXPECT_THAT(Results.signatures, ElementsAre(Sig(\"foo([[int x]]) -> int\")));\n  EXPECT_EQ(0, Results.activeSignature);\n  EXPECT_EQ(0, Results.activeParameter);\n}\n\nclass IndexRequestCollector : public SymbolIndex {\npublic:\n  bool\n  fuzzyFind(const FuzzyFindRequest &Req,\n            llvm::function_ref<void(const Symbol &)> Callback) const override {\n    std::unique_lock<std::mutex> Lock(Mut);\n    Requests.push_back(Req);\n    ReceivedRequestCV.notify_one();\n    return true;\n  }\n\n  void lookup(const LookupRequest &,\n              llvm::function_ref<void(const Symbol &)>) const override {}\n\n  bool refs(const RefsRequest &,\n            llvm::function_ref<void(const Ref &)>) const override {\n    return false;\n  }\n\n  void relations(const RelationsRequest &,\n                 llvm::function_ref<void(const SymbolID &, const Symbol &)>)\n      const override {}\n\n  llvm::unique_function<IndexContents(llvm::StringRef) const>\n  indexedFiles() const override {\n    return [](llvm::StringRef) { return IndexContents::None; };\n  }\n\n  // This is incorrect, but IndexRequestCollector is not an actual index and it\n  // isn't used in production code.\n  size_t estimateMemoryUsage() const override { return 0; }\n\n  const std::vector<FuzzyFindRequest> consumeRequests(size_t Num) const {\n    std::unique_lock<std::mutex> Lock(Mut);\n    EXPECT_TRUE(wait(Lock, ReceivedRequestCV, timeoutSeconds(30),\n                     [this, Num] { return Requests.size() == Num; }));\n    auto Reqs = std::move(Requests);\n    Requests = {};\n    return Reqs;\n  }\n\nprivate:\n  // We need a mutex to handle async fuzzy find requests.\n  mutable std::condition_variable ReceivedRequestCV;\n  mutable std::mutex Mut;\n  mutable std::vector<FuzzyFindRequest> Requests;\n};\n\n// Clients have to consume exactly Num requests.\nstd::vector<FuzzyFindRequest> captureIndexRequests(llvm::StringRef Code,\n                                                   size_t Num = 1) {\n  clangd::CodeCompleteOptions Opts;\n  IndexRequestCollector Requests;\n  Opts.Index = &Requests;\n  completions(Code, {}, Opts);\n  const auto Reqs = Requests.consumeRequests(Num);\n  EXPECT_EQ(Reqs.size(), Num);\n  return Reqs;\n}\n\nTEST(CompletionTest, UnqualifiedIdQuery) {\n  auto Requests = captureIndexRequests(R\"cpp(\n      namespace std {}\n      using namespace std;\n      namespace ns {\n      void f() {\n        vec^\n      }\n      }\n  )cpp\");\n\n  EXPECT_THAT(Requests,\n              ElementsAre(Field(&FuzzyFindRequest::Scopes,\n                                UnorderedElementsAre(\"\", \"ns::\", \"std::\"))));\n}\n\nTEST(CompletionTest, EnclosingScopeComesFirst) {\n  auto Requests = captureIndexRequests(R\"cpp(\n      namespace std {}\n      using namespace std;\n      namespace nx {\n      namespace ns {\n      namespace {\n      void f() {\n        vec^\n      }\n      }\n      }\n      }\n  )cpp\");\n\n  EXPECT_THAT(Requests,\n              ElementsAre(Field(\n                  &FuzzyFindRequest::Scopes,\n                  UnorderedElementsAre(\"\", \"std::\", \"nx::ns::\", \"nx::\"))));\n  EXPECT_EQ(Requests[0].Scopes[0], \"nx::ns::\");\n}\n\nTEST(CompletionTest, ResolvedQualifiedIdQuery) {\n  auto Requests = captureIndexRequests(R\"cpp(\n      namespace ns1 {}\n      namespace ns2 {} // ignore\n      namespace ns3 { namespace nns3 {} }\n      namespace foo {\n      using namespace ns1;\n      using namespace ns3::nns3;\n      }\n      namespace ns {\n      void f() {\n        foo::^\n      }\n      }\n  )cpp\");\n\n  EXPECT_THAT(Requests,\n              ElementsAre(Field(\n                  &FuzzyFindRequest::Scopes,\n                  UnorderedElementsAre(\"foo::\", \"ns1::\", \"ns3::nns3::\"))));\n}\n\nTEST(CompletionTest, UnresolvedQualifierIdQuery) {\n  auto Requests = captureIndexRequests(R\"cpp(\n      namespace a {}\n      using namespace a;\n      namespace ns {\n      void f() {\n      bar::^\n      }\n      } // namespace ns\n  )cpp\");\n\n  EXPECT_THAT(Requests,\n              ElementsAre(Field(\n                  &FuzzyFindRequest::Scopes,\n                  UnorderedElementsAre(\"a::bar::\", \"ns::bar::\", \"bar::\"))));\n}\n\nTEST(CompletionTest, UnresolvedNestedQualifierIdQuery) {\n  auto Requests = captureIndexRequests(R\"cpp(\n      namespace a {}\n      using namespace a;\n      namespace ns {\n      void f() {\n      ::a::bar::^\n      }\n      } // namespace ns\n  )cpp\");\n\n  EXPECT_THAT(Requests, ElementsAre(Field(&FuzzyFindRequest::Scopes,\n                                          UnorderedElementsAre(\"a::bar::\"))));\n}\n\nTEST(CompletionTest, EmptyQualifiedQuery) {\n  auto Requests = captureIndexRequests(R\"cpp(\n      namespace ns {\n      void f() {\n      ^\n      }\n      } // namespace ns\n  )cpp\");\n\n  EXPECT_THAT(Requests, ElementsAre(Field(&FuzzyFindRequest::Scopes,\n                                          UnorderedElementsAre(\"\", \"ns::\"))));\n}\n\nTEST(CompletionTest, GlobalQualifiedQuery) {\n  auto Requests = captureIndexRequests(R\"cpp(\n      namespace ns {\n      void f() {\n      ::^\n      }\n      } // namespace ns\n  )cpp\");\n\n  EXPECT_THAT(Requests, ElementsAre(Field(&FuzzyFindRequest::Scopes,\n                                          UnorderedElementsAre(\"\"))));\n}\n\nTEST(CompletionTest, NoDuplicatedQueryScopes) {\n  auto Requests = captureIndexRequests(R\"cpp(\n      namespace {}\n\n      namespace na {\n      namespace {}\n      namespace nb {\n      ^\n      } // namespace nb\n      } // namespace na\n  )cpp\");\n\n  EXPECT_THAT(Requests,\n              ElementsAre(Field(&FuzzyFindRequest::Scopes,\n                                UnorderedElementsAre(\"na::\", \"na::nb::\", \"\"))));\n}\n\nTEST(CompletionTest, NoIndexCompletionsInsideClasses) {\n  auto Completions = completions(\n      R\"cpp(\n    struct Foo {\n      int SomeNameOfField;\n      typedef int SomeNameOfTypedefField;\n    };\n\n    Foo::^)cpp\",\n      {func(\"::SomeNameInTheIndex\"), func(\"::Foo::SomeNameInTheIndex\")});\n\n  EXPECT_THAT(Completions.Completions,\n              AllOf(Contains(Labeled(\"SomeNameOfField\")),\n                    Contains(Labeled(\"SomeNameOfTypedefField\")),\n                    Not(Contains(Labeled(\"SomeNameInTheIndex\")))));\n}\n\nTEST(CompletionTest, NoIndexCompletionsInsideDependentCode) {\n  {\n    auto Completions = completions(\n        R\"cpp(\n      template <class T>\n      void foo() {\n        T::^\n      }\n      )cpp\",\n        {func(\"::SomeNameInTheIndex\")});\n\n    EXPECT_THAT(Completions.Completions,\n                Not(Contains(Labeled(\"SomeNameInTheIndex\"))));\n  }\n\n  {\n    auto Completions = completions(\n        R\"cpp(\n      template <class T>\n      void foo() {\n        T::template Y<int>::^\n      }\n      )cpp\",\n        {func(\"::SomeNameInTheIndex\")});\n\n    EXPECT_THAT(Completions.Completions,\n                Not(Contains(Labeled(\"SomeNameInTheIndex\"))));\n  }\n\n  {\n    auto Completions = completions(\n        R\"cpp(\n      template <class T>\n      void foo() {\n        T::foo::^\n      }\n      )cpp\",\n        {func(\"::SomeNameInTheIndex\")});\n\n    EXPECT_THAT(Completions.Completions,\n                Not(Contains(Labeled(\"SomeNameInTheIndex\"))));\n  }\n}\n\nTEST(CompletionTest, OverloadBundling) {\n  clangd::CodeCompleteOptions Opts;\n  Opts.BundleOverloads = true;\n\n  std::string Context = R\"cpp(\n    struct X {\n      // Overload with int\n      int a(int);\n      // Overload with bool\n      int a(bool);\n      int b(float);\n    };\n    int GFuncC(int);\n    int GFuncD(int);\n  )cpp\";\n\n  // Member completions are bundled.\n  EXPECT_THAT(completions(Context + \"int y = X().^\", {}, Opts).Completions,\n              UnorderedElementsAre(Labeled(\"a(\u2026)\"), Labeled(\"b(float)\")));\n\n  // Non-member completions are bundled, including index+sema.\n  Symbol NoArgsGFunc = func(\"GFuncC\");\n  EXPECT_THAT(\n      completions(Context + \"int y = GFunc^\", {NoArgsGFunc}, Opts).Completions,\n      UnorderedElementsAre(Labeled(\"GFuncC(\u2026)\"), Labeled(\"GFuncD(int)\")));\n\n  // Differences in header-to-insert suppress bundling.\n  std::string DeclFile = URI::create(testPath(\"foo\")).toString();\n  NoArgsGFunc.CanonicalDeclaration.FileURI = DeclFile.c_str();\n  NoArgsGFunc.IncludeHeaders.emplace_back(\"<foo>\", 1);\n  EXPECT_THAT(\n      completions(Context + \"int y = GFunc^\", {NoArgsGFunc}, Opts).Completions,\n      UnorderedElementsAre(AllOf(Named(\"GFuncC\"), InsertInclude(\"<foo>\")),\n                           Labeled(\"GFuncC(int)\"), Labeled(\"GFuncD(int)\")));\n\n  // Examine a bundled completion in detail.\n  auto A =\n      completions(Context + \"int y = X().a^\", {}, Opts).Completions.front();\n  EXPECT_EQ(A.Name, \"a\");\n  EXPECT_EQ(A.Signature, \"(\u2026)\");\n  EXPECT_EQ(A.BundleSize, 2u);\n  EXPECT_EQ(A.Kind, CompletionItemKind::Method);\n  EXPECT_EQ(A.ReturnType, \"int\"); // All overloads return int.\n  // For now we just return one of the doc strings arbitrarily.\n  ASSERT_TRUE(A.Documentation);\n  EXPECT_THAT(\n      A.Documentation->asPlainText(),\n      AnyOf(HasSubstr(\"Overload with int\"), HasSubstr(\"Overload with bool\")));\n  EXPECT_EQ(A.SnippetSuffix, \"($0)\");\n}\n\nTEST(CompletionTest, OverloadBundlingSameFileDifferentURI) {\n  clangd::CodeCompleteOptions Opts;\n  Opts.BundleOverloads = true;\n\n  Symbol SymX = sym(\"ns::X\", index::SymbolKind::Function, \"@F@\\\\0#\");\n  Symbol SymY = sym(\"ns::X\", index::SymbolKind::Function, \"@F@\\\\0#I#\");\n  std::string BarHeader = testPath(\"bar.h\");\n  auto BarURI = URI::create(BarHeader).toString();\n  SymX.CanonicalDeclaration.FileURI = BarURI.c_str();\n  SymY.CanonicalDeclaration.FileURI = BarURI.c_str();\n  // The include header is different, but really it's the same file.\n  SymX.IncludeHeaders.emplace_back(\"\\\"bar.h\\\"\", 1);\n  SymY.IncludeHeaders.emplace_back(BarURI.c_str(), 1);\n\n  auto Results = completions(\"void f() { ::ns::^ }\", {SymX, SymY}, Opts);\n  // Expect both results are bundled, despite the different-but-same\n  // IncludeHeader.\n  ASSERT_EQ(1u, Results.Completions.size());\n  const auto &R = Results.Completions.front();\n  EXPECT_EQ(\"X\", R.Name);\n  EXPECT_EQ(2u, R.BundleSize);\n}\n\nTEST(CompletionTest, DocumentationFromChangedFileCrash) {\n  MockFS FS;\n  auto FooH = testPath(\"foo.h\");\n  auto FooCpp = testPath(\"foo.cpp\");\n  FS.Files[FooH] = R\"cpp(\n    // this is my documentation comment.\n    int func();\n  )cpp\";\n  FS.Files[FooCpp] = \"\";\n\n  MockCompilationDatabase CDB;\n  ClangdServer Server(CDB, FS, ClangdServer::optsForTest());\n\n  Annotations Source(R\"cpp(\n    #include \"foo.h\"\n    int func() {\n      // This makes sure we have func from header in the AST.\n    }\n    int a = fun^\n  )cpp\");\n  Server.addDocument(FooCpp, Source.code(), \"null\", WantDiagnostics::Yes);\n  // We need to wait for preamble to build.\n  ASSERT_TRUE(Server.blockUntilIdleForTest());\n\n  // Change the header file. Completion will reuse the old preamble!\n  FS.Files[FooH] = R\"cpp(\n    int func();\n  )cpp\";\n\n  clangd::CodeCompleteOptions Opts;\n  CodeCompleteResult Completions =\n      cantFail(runCodeComplete(Server, FooCpp, Source.point(), Opts));\n  // We shouldn't crash. Unfortunately, current workaround is to not produce\n  // comments for symbols from headers.\n  EXPECT_THAT(Completions.Completions,\n              Contains(AllOf(Not(IsDocumented()), Named(\"func\"))));\n}\n\nTEST(CompletionTest, NonDocComments) {\n  const char *Text = R\"cpp(\n    // We ignore namespace comments, for rationale see CodeCompletionStrings.h.\n    namespace comments_ns {\n    }\n\n    // ------------------\n    int comments_foo();\n\n    // A comment and a decl are separated by newlines.\n    // Therefore, the comment shouldn't show up as doc comment.\n\n    int comments_bar();\n\n    // this comment should be in the results.\n    int comments_baz();\n\n\n    template <class T>\n    struct Struct {\n      int comments_qux();\n      int comments_quux();\n    };\n\n\n    // This comment should not be there.\n\n    template <class T>\n    int Struct<T>::comments_qux() {\n    }\n\n    // This comment **should** be in results.\n    template <class T>\n    int Struct<T>::comments_quux() {\n      int a = comments^;\n    }\n  )cpp\";\n\n  // We should not get any of those comments in completion.\n  EXPECT_THAT(\n      completions(Text).Completions,\n      UnorderedElementsAre(AllOf(Not(IsDocumented()), Named(\"comments_foo\")),\n                           AllOf(IsDocumented(), Named(\"comments_baz\")),\n                           AllOf(IsDocumented(), Named(\"comments_quux\")),\n                           AllOf(Not(IsDocumented()), Named(\"comments_ns\")),\n                           // FIXME(ibiryukov): the following items should have\n                           // empty documentation, since they are separated from\n                           // a comment with an empty line. Unfortunately, I\n                           // couldn't make Sema tests pass if we ignore those.\n                           AllOf(IsDocumented(), Named(\"comments_bar\")),\n                           AllOf(IsDocumented(), Named(\"comments_qux\"))));\n}\n\nTEST(CompletionTest, CompleteOnInvalidLine) {\n  auto FooCpp = testPath(\"foo.cpp\");\n\n  MockCompilationDatabase CDB;\n  MockFS FS;\n  FS.Files[FooCpp] = \"// empty file\";\n\n  ClangdServer Server(CDB, FS, ClangdServer::optsForTest());\n  // Run completion outside the file range.\n  Position Pos;\n  Pos.line = 100;\n  Pos.character = 0;\n  EXPECT_THAT_EXPECTED(\n      runCodeComplete(Server, FooCpp, Pos, clangd::CodeCompleteOptions()),\n      Failed());\n}\n\nTEST(CompletionTest, QualifiedNames) {\n  auto Results = completions(\n      R\"cpp(\n          namespace ns { int local; void both(); }\n          void f() { ::ns::^ }\n      )cpp\",\n      {func(\"ns::both\"), cls(\"ns::Index\")});\n  // We get results from both index and sema, with no duplicates.\n  EXPECT_THAT(\n      Results.Completions,\n      UnorderedElementsAre(Scope(\"ns::\"), Scope(\"ns::\"), Scope(\"ns::\")));\n}\n\nTEST(CompletionTest, Render) {\n  CodeCompletion C;\n  C.Name = \"x\";\n  C.Signature = \"(bool) const\";\n  C.SnippetSuffix = \"(${0:bool})\";\n  C.ReturnType = \"int\";\n  C.RequiredQualifier = \"Foo::\";\n  C.Scope = \"ns::Foo::\";\n  C.Documentation.emplace();\n  C.Documentation->addParagraph().appendText(\"This is \").appendCode(\"x()\");\n  C.Includes.emplace_back();\n  auto &Include = C.Includes.back();\n  Include.Header = \"\\\"foo.h\\\"\";\n  C.Kind = CompletionItemKind::Method;\n  C.Score.Total = 1.0;\n  C.Score.ExcludingName = .5;\n  C.Origin = SymbolOrigin::AST | SymbolOrigin::Static;\n\n  CodeCompleteOptions Opts;\n  Opts.IncludeIndicator.Insert = \"^\";\n  Opts.IncludeIndicator.NoInsert = \"\";\n  Opts.EnableSnippets = false;\n\n  auto R = C.render(Opts);\n  EXPECT_EQ(R.label, \"Foo::x(bool) const\");\n  EXPECT_EQ(R.insertText, \"Foo::x\");\n  EXPECT_EQ(R.insertTextFormat, InsertTextFormat::PlainText);\n  EXPECT_EQ(R.filterText, \"x\");\n  EXPECT_EQ(R.detail, \"int\");\n  EXPECT_EQ(R.documentation->value, \"From \\\"foo.h\\\"\\nThis is x()\");\n  EXPECT_THAT(R.additionalTextEdits, IsEmpty());\n  EXPECT_EQ(R.sortText, sortText(1.0, \"x\"));\n  EXPECT_FALSE(R.deprecated);\n  EXPECT_EQ(R.score, .5f);\n\n  Opts.EnableSnippets = true;\n  R = C.render(Opts);\n  EXPECT_EQ(R.insertText, \"Foo::x(${0:bool})\");\n  EXPECT_EQ(R.insertTextFormat, InsertTextFormat::Snippet);\n\n  Include.Insertion.emplace();\n  R = C.render(Opts);\n  EXPECT_EQ(R.label, \"^Foo::x(bool) const\");\n  EXPECT_THAT(R.additionalTextEdits, Not(IsEmpty()));\n\n  Opts.ShowOrigins = true;\n  R = C.render(Opts);\n  EXPECT_EQ(R.label, \"^[AS]Foo::x(bool) const\");\n\n  C.BundleSize = 2;\n  R = C.render(Opts);\n  EXPECT_EQ(R.detail, \"[2 overloads]\");\n  EXPECT_EQ(R.documentation->value, \"From \\\"foo.h\\\"\\nThis is x()\");\n\n  C.Deprecated = true;\n  R = C.render(Opts);\n  EXPECT_TRUE(R.deprecated);\n\n  Opts.DocumentationFormat = MarkupKind::Markdown;\n  R = C.render(Opts);\n  EXPECT_EQ(R.documentation->value, \"From `\\\"foo.h\\\"`  \\nThis is `x()`\");\n}\n\nTEST(CompletionTest, IgnoreRecoveryResults) {\n  auto Results = completions(\n      R\"cpp(\n          namespace ns { int NotRecovered() { return 0; } }\n          void f() {\n            // Sema enters recovery mode first and then normal mode.\n            if (auto x = ns::NotRecover^)\n          }\n      )cpp\");\n  EXPECT_THAT(Results.Completions, UnorderedElementsAre(Named(\"NotRecovered\")));\n}\n\nTEST(CompletionTest, ScopeOfClassFieldInConstructorInitializer) {\n  auto Results = completions(\n      R\"cpp(\n        namespace ns {\n          class X { public: X(); int x_; };\n          X::X() : x_^(0) {}\n        }\n      )cpp\");\n  EXPECT_THAT(Results.Completions,\n              UnorderedElementsAre(AllOf(Scope(\"ns::X::\"), Named(\"x_\"))));\n}\n\nTEST(CompletionTest, CodeCompletionContext) {\n  auto Results = completions(\n      R\"cpp(\n        namespace ns {\n          class X { public: X(); int x_; };\n          void f() {\n            X x;\n            x.^;\n          }\n        }\n      )cpp\");\n\n  EXPECT_THAT(Results.Context, CodeCompletionContext::CCC_DotMemberAccess);\n}\n\nTEST(CompletionTest, FixItForArrowToDot) {\n  MockFS FS;\n  MockCompilationDatabase CDB;\n\n  CodeCompleteOptions Opts;\n  Opts.IncludeFixIts = true;\n  const char *Code =\n      R\"cpp(\n        class Auxilary {\n         public:\n          void AuxFunction();\n        };\n        class ClassWithPtr {\n         public:\n          void MemberFunction();\n          Auxilary* operator->() const;\n          Auxilary* Aux;\n        };\n        void f() {\n          ClassWithPtr x;\n          x[[->]]^;\n        }\n      )cpp\";\n  auto Results = completions(Code, {}, Opts);\n  EXPECT_EQ(Results.Completions.size(), 3u);\n\n  TextEdit ReplacementEdit;\n  ReplacementEdit.range = Annotations(Code).range();\n  ReplacementEdit.newText = \".\";\n  for (const auto &C : Results.Completions) {\n    EXPECT_TRUE(C.FixIts.size() == 1u || C.Name == \"AuxFunction\");\n    if (!C.FixIts.empty()) {\n      EXPECT_THAT(C.FixIts, ElementsAre(ReplacementEdit));\n    }\n  }\n}\n\nTEST(CompletionTest, FixItForDotToArrow) {\n  CodeCompleteOptions Opts;\n  Opts.IncludeFixIts = true;\n  const char *Code =\n      R\"cpp(\n        class Auxilary {\n         public:\n          void AuxFunction();\n        };\n        class ClassWithPtr {\n         public:\n          void MemberFunction();\n          Auxilary* operator->() const;\n          Auxilary* Aux;\n        };\n        void f() {\n          ClassWithPtr x;\n          x[[.]]^;\n        }\n      )cpp\";\n  auto Results = completions(Code, {}, Opts);\n  EXPECT_EQ(Results.Completions.size(), 3u);\n\n  TextEdit ReplacementEdit;\n  ReplacementEdit.range = Annotations(Code).range();\n  ReplacementEdit.newText = \"->\";\n  for (const auto &C : Results.Completions) {\n    EXPECT_TRUE(C.FixIts.empty() || C.Name == \"AuxFunction\");\n    if (!C.FixIts.empty()) {\n      EXPECT_THAT(C.FixIts, ElementsAre(ReplacementEdit));\n    }\n  }\n}\n\nTEST(CompletionTest, RenderWithFixItMerged) {\n  TextEdit FixIt;\n  FixIt.range.end.character = 5;\n  FixIt.newText = \"->\";\n\n  CodeCompletion C;\n  C.Name = \"x\";\n  C.RequiredQualifier = \"Foo::\";\n  C.FixIts = {FixIt};\n  C.CompletionTokenRange.start.character = 5;\n\n  CodeCompleteOptions Opts;\n  Opts.IncludeFixIts = true;\n\n  auto R = C.render(Opts);\n  EXPECT_TRUE(R.textEdit);\n  EXPECT_EQ(R.textEdit->newText, \"->Foo::x\");\n  EXPECT_TRUE(R.additionalTextEdits.empty());\n}\n\nTEST(CompletionTest, RenderWithFixItNonMerged) {\n  TextEdit FixIt;\n  FixIt.range.end.character = 4;\n  FixIt.newText = \"->\";\n\n  CodeCompletion C;\n  C.Name = \"x\";\n  C.RequiredQualifier = \"Foo::\";\n  C.FixIts = {FixIt};\n  C.CompletionTokenRange.start.character = 5;\n\n  CodeCompleteOptions Opts;\n  Opts.IncludeFixIts = true;\n\n  auto R = C.render(Opts);\n  EXPECT_TRUE(R.textEdit);\n  EXPECT_EQ(R.textEdit->newText, \"Foo::x\");\n  EXPECT_THAT(R.additionalTextEdits, UnorderedElementsAre(FixIt));\n}\n\nTEST(CompletionTest, CompletionTokenRange) {\n  MockFS FS;\n  MockCompilationDatabase CDB;\n  TestTU TU;\n  TU.AdditionalFiles[\"foo/abc/foo.h\"] = \"\";\n\n  constexpr const char *TestCodes[] = {\n      R\"cpp(\n        class Auxilary {\n         public:\n          void AuxFunction();\n        };\n        void f() {\n          Auxilary x;\n          x.[[Aux]]^;\n        }\n      )cpp\",\n      R\"cpp(\n        class Auxilary {\n         public:\n          void AuxFunction();\n        };\n        void f() {\n          Auxilary x;\n          x.[[]]^;\n        }\n      )cpp\",\n      R\"cpp(\n        #include \"foo/[[a^/]]foo.h\"\n      )cpp\",\n      R\"cpp(\n        #include \"foo/abc/[[fo^o.h\"]]\n      )cpp\",\n  };\n  for (const auto &Text : TestCodes) {\n    Annotations TestCode(Text);\n    TU.Code = TestCode.code().str();\n    auto Results = completions(TU, TestCode.point());\n    if (Results.Completions.size() != 1) {\n      ADD_FAILURE() << \"Results.Completions.size() != 1\" << Text;\n      continue;\n    }\n    EXPECT_THAT(Results.Completions.front().CompletionTokenRange,\n                TestCode.range());\n  }\n}\n\nTEST(SignatureHelpTest, OverloadsOrdering) {\n  const auto Results = signatures(R\"cpp(\n    void foo(int x);\n    void foo(int x, float y);\n    void foo(float x, int y);\n    void foo(float x, float y);\n    void foo(int x, int y = 0);\n    int main() { foo(^); }\n  )cpp\");\n  EXPECT_THAT(Results.signatures,\n              ElementsAre(Sig(\"foo([[int x]]) -> void\"),\n                          Sig(\"foo([[int x]], [[int y = 0]]) -> void\"),\n                          Sig(\"foo([[float x]], [[int y]]) -> void\"),\n                          Sig(\"foo([[int x]], [[float y]]) -> void\"),\n                          Sig(\"foo([[float x]], [[float y]]) -> void\")));\n  // We always prefer the first signature.\n  EXPECT_EQ(0, Results.activeSignature);\n  EXPECT_EQ(0, Results.activeParameter);\n}\n\nTEST(SignatureHelpTest, InstantiatedSignatures) {\n  StringRef Sig0 = R\"cpp(\n    template <class T>\n    void foo(T, T, T);\n\n    int main() {\n      foo<int>(^);\n    }\n  )cpp\";\n\n  EXPECT_THAT(signatures(Sig0).signatures,\n              ElementsAre(Sig(\"foo([[T]], [[T]], [[T]]) -> void\")));\n\n  StringRef Sig1 = R\"cpp(\n    template <class T>\n    void foo(T, T, T);\n\n    int main() {\n      foo(10, ^);\n    })cpp\";\n\n  EXPECT_THAT(signatures(Sig1).signatures,\n              ElementsAre(Sig(\"foo([[T]], [[T]], [[T]]) -> void\")));\n\n  StringRef Sig2 = R\"cpp(\n    template <class ...T>\n    void foo(T...);\n\n    int main() {\n      foo<int>(^);\n    }\n  )cpp\";\n\n  EXPECT_THAT(signatures(Sig2).signatures,\n              ElementsAre(Sig(\"foo([[T...]]) -> void\")));\n\n  // It is debatable whether we should substitute the outer template parameter\n  // ('T') in that case. Currently we don't substitute it in signature help, but\n  // do substitute in code complete.\n  // FIXME: make code complete and signature help consistent, figure out which\n  // way is better.\n  StringRef Sig3 = R\"cpp(\n    template <class T>\n    struct X {\n      template <class U>\n      void foo(T, U);\n    };\n\n    int main() {\n      X<int>().foo<double>(^)\n    }\n  )cpp\";\n\n  EXPECT_THAT(signatures(Sig3).signatures,\n              ElementsAre(Sig(\"foo([[T]], [[U]]) -> void\")));\n}\n\nTEST(SignatureHelpTest, IndexDocumentation) {\n  Symbol Foo0 = sym(\"foo\", index::SymbolKind::Function, \"@F@\\\\0#\");\n  Foo0.Documentation = \"Doc from the index\";\n  Symbol Foo1 = sym(\"foo\", index::SymbolKind::Function, \"@F@\\\\0#I#\");\n  Foo1.Documentation = \"Doc from the index\";\n  Symbol Foo2 = sym(\"foo\", index::SymbolKind::Function, \"@F@\\\\0#I#I#\");\n\n  StringRef Sig0 = R\"cpp(\n    int foo();\n    int foo(double);\n\n    void test() {\n      foo(^);\n    }\n  )cpp\";\n\n  EXPECT_THAT(\n      signatures(Sig0, {Foo0}).signatures,\n      ElementsAre(AllOf(Sig(\"foo() -> int\"), SigDoc(\"Doc from the index\")),\n                  AllOf(Sig(\"foo([[double]]) -> int\"), SigDoc(\"\"))));\n\n  StringRef Sig1 = R\"cpp(\n    int foo();\n    // Overriden doc from sema\n    int foo(int);\n    // Doc from sema\n    int foo(int, int);\n\n    void test() {\n      foo(^);\n    }\n  )cpp\";\n\n  EXPECT_THAT(\n      signatures(Sig1, {Foo0, Foo1, Foo2}).signatures,\n      ElementsAre(\n          AllOf(Sig(\"foo() -> int\"), SigDoc(\"Doc from the index\")),\n          AllOf(Sig(\"foo([[int]]) -> int\"), SigDoc(\"Overriden doc from sema\")),\n          AllOf(Sig(\"foo([[int]], [[int]]) -> int\"), SigDoc(\"Doc from sema\"))));\n}\n\nTEST(SignatureHelpTest, DynamicIndexDocumentation) {\n  MockFS FS;\n  MockCompilationDatabase CDB;\n  ClangdServer::Options Opts = ClangdServer::optsForTest();\n  Opts.BuildDynamicSymbolIndex = true;\n  ClangdServer Server(CDB, FS, Opts);\n\n  FS.Files[testPath(\"foo.h\")] = R\"cpp(\n    struct Foo {\n       // Member doc\n       int foo();\n    };\n  )cpp\";\n  Annotations FileContent(R\"cpp(\n    #include \"foo.h\"\n    void test() {\n      Foo f;\n      f.foo(^);\n    }\n  )cpp\");\n  auto File = testPath(\"test.cpp\");\n  Server.addDocument(File, FileContent.code());\n  // Wait for the dynamic index being built.\n  ASSERT_TRUE(Server.blockUntilIdleForTest());\n  EXPECT_THAT(\n      llvm::cantFail(runSignatureHelp(Server, File, FileContent.point()))\n          .signatures,\n      ElementsAre(AllOf(Sig(\"foo() -> int\"), SigDoc(\"Member doc\"))));\n}\n\nTEST(CompletionTest, CompletionFunctionArgsDisabled) {\n  CodeCompleteOptions Opts;\n  Opts.EnableSnippets = true;\n  Opts.EnableFunctionArgSnippets = false;\n\n  {\n    auto Results = completions(\n        R\"cpp(\n      void xfoo();\n      void xfoo(int x, int y);\n      void f() { xfo^ })cpp\",\n        {}, Opts);\n    EXPECT_THAT(\n        Results.Completions,\n        UnorderedElementsAre(AllOf(Named(\"xfoo\"), SnippetSuffix(\"()\")),\n                             AllOf(Named(\"xfoo\"), SnippetSuffix(\"($0)\"))));\n  }\n  {\n    auto Results = completions(\n        R\"cpp(\n      void xbar();\n      void f() { xba^ })cpp\",\n        {}, Opts);\n    EXPECT_THAT(Results.Completions, UnorderedElementsAre(AllOf(\n                                         Named(\"xbar\"), SnippetSuffix(\"()\"))));\n  }\n  {\n    Opts.BundleOverloads = true;\n    auto Results = completions(\n        R\"cpp(\n      void xfoo();\n      void xfoo(int x, int y);\n      void f() { xfo^ })cpp\",\n        {}, Opts);\n    EXPECT_THAT(\n        Results.Completions,\n        UnorderedElementsAre(AllOf(Named(\"xfoo\"), SnippetSuffix(\"($0)\"))));\n  }\n  {\n    auto Results = completions(\n        R\"cpp(\n      template <class T, class U>\n      void xfoo(int a, U b);\n      void f() { xfo^ })cpp\",\n        {}, Opts);\n    EXPECT_THAT(\n        Results.Completions,\n        UnorderedElementsAre(AllOf(Named(\"xfoo\"), SnippetSuffix(\"<$1>($0)\"))));\n  }\n  {\n    auto Results = completions(\n        R\"cpp(\n      template <class T>\n      class foo_class{};\n      template <class T>\n      using foo_alias = T**;\n      void f() { foo_^ })cpp\",\n        {}, Opts);\n    EXPECT_THAT(\n        Results.Completions,\n        UnorderedElementsAre(AllOf(Named(\"foo_class\"), SnippetSuffix(\"<$0>\")),\n                             AllOf(Named(\"foo_alias\"), SnippetSuffix(\"<$0>\"))));\n  }\n}\n\nTEST(CompletionTest, SuggestOverrides) {\n  constexpr const char *const Text(R\"cpp(\n  class A {\n   public:\n    virtual void vfunc(bool param);\n    virtual void vfunc(bool param, int p);\n    void func(bool param);\n  };\n  class B : public A {\n  virtual void ttt(bool param) const;\n  void vfunc(bool param, int p) override;\n  };\n  class C : public B {\n   public:\n    void vfunc(bool param) override;\n    ^\n  };\n  )cpp\");\n  const auto Results = completions(Text);\n  EXPECT_THAT(\n      Results.Completions,\n      AllOf(Contains(AllOf(Labeled(\"void vfunc(bool param, int p) override\"),\n                           NameStartsWith(\"vfunc\"))),\n            Contains(AllOf(Labeled(\"void ttt(bool param) const override\"),\n                           NameStartsWith(\"ttt\"))),\n            Not(Contains(Labeled(\"void vfunc(bool param) override\")))));\n}\n\nTEST(CompletionTest, OverridesNonIdentName) {\n  // Check the completions call does not crash.\n  completions(R\"cpp(\n    struct Base {\n      virtual ~Base() = 0;\n      virtual operator int() = 0;\n      virtual Base& operator+(Base&) = 0;\n    };\n\n    struct Derived : Base {\n      ^\n    };\n  )cpp\");\n}\n\nTEST(GuessCompletionPrefix, Filters) {\n  for (llvm::StringRef Case : {\n           \"[[scope::]][[ident]]^\",\n           \"[[]][[]]^\",\n           \"\\n[[]][[]]^\",\n           \"[[]][[ab]]^\",\n           \"x.[[]][[ab]]^\",\n           \"x.[[]][[]]^\",\n           \"[[x::]][[ab]]^\",\n           \"[[x::]][[]]^\",\n           \"[[::x::]][[ab]]^\",\n           \"some text [[scope::more::]][[identif]]^ier\",\n           \"some text [[scope::]][[mor]]^e::identifier\",\n           \"weird case foo::[[::bar::]][[baz]]^\",\n           \"/* [[]][[]]^ */\",\n       }) {\n    Annotations F(Case);\n    auto Offset = cantFail(positionToOffset(F.code(), F.point()));\n    auto ToStringRef = [&](Range R) {\n      return F.code().slice(cantFail(positionToOffset(F.code(), R.start)),\n                            cantFail(positionToOffset(F.code(), R.end)));\n    };\n    auto WantQualifier = ToStringRef(F.ranges()[0]),\n         WantName = ToStringRef(F.ranges()[1]);\n\n    auto Prefix = guessCompletionPrefix(F.code(), Offset);\n    // Even when components are empty, check their offsets are correct.\n    EXPECT_EQ(WantQualifier, Prefix.Qualifier) << Case;\n    EXPECT_EQ(WantQualifier.begin(), Prefix.Qualifier.begin()) << Case;\n    EXPECT_EQ(WantName, Prefix.Name) << Case;\n    EXPECT_EQ(WantName.begin(), Prefix.Name.begin()) << Case;\n  }\n}\n\nTEST(CompletionTest, EnableSpeculativeIndexRequest) {\n  MockFS FS;\n  MockCompilationDatabase CDB;\n  ClangdServer Server(CDB, FS, ClangdServer::optsForTest());\n\n  auto File = testPath(\"foo.cpp\");\n  Annotations Test(R\"cpp(\n      namespace ns1 { int abc; }\n      namespace ns2 { int abc; }\n      void f() { ns1::ab$1^; ns1::ab$2^; }\n      void f2() { ns2::ab$3^; }\n  )cpp\");\n  runAddDocument(Server, File, Test.code());\n  clangd::CodeCompleteOptions Opts = {};\n\n  IndexRequestCollector Requests;\n  Opts.Index = &Requests;\n\n  auto CompleteAtPoint = [&](StringRef P) {\n    cantFail(runCodeComplete(Server, File, Test.point(P), Opts));\n  };\n\n  CompleteAtPoint(\"1\");\n  auto Reqs1 = Requests.consumeRequests(1);\n  ASSERT_EQ(Reqs1.size(), 1u);\n  EXPECT_THAT(Reqs1[0].Scopes, UnorderedElementsAre(\"ns1::\"));\n\n  CompleteAtPoint(\"2\");\n  auto Reqs2 = Requests.consumeRequests(1);\n  // Speculation succeeded. Used speculative index result.\n  ASSERT_EQ(Reqs2.size(), 1u);\n  EXPECT_EQ(Reqs2[0], Reqs1[0]);\n\n  CompleteAtPoint(\"3\");\n  // Speculation failed. Sent speculative index request and the new index\n  // request after sema.\n  auto Reqs3 = Requests.consumeRequests(2);\n  ASSERT_EQ(Reqs3.size(), 2u);\n}\n\nTEST(CompletionTest, InsertTheMostPopularHeader) {\n  std::string DeclFile = URI::create(testPath(\"foo\")).toString();\n  Symbol Sym = func(\"Func\");\n  Sym.CanonicalDeclaration.FileURI = DeclFile.c_str();\n  Sym.IncludeHeaders.emplace_back(\"\\\"foo.h\\\"\", 2);\n  Sym.IncludeHeaders.emplace_back(\"\\\"bar.h\\\"\", 1000);\n\n  auto Results = completions(\"Fun^\", {Sym}).Completions;\n  assert(!Results.empty());\n  EXPECT_THAT(Results[0], AllOf(Named(\"Func\"), InsertInclude(\"\\\"bar.h\\\"\")));\n  EXPECT_EQ(Results[0].Includes.size(), 2u);\n}\n\nTEST(CompletionTest, NoInsertIncludeIfOnePresent) {\n  Annotations Test(R\"cpp(\n    #include \"foo.h\"\n    Fun^\n  )cpp\");\n  auto TU = TestTU::withCode(Test.code());\n  TU.AdditionalFiles[\"foo.h\"] = \"\";\n\n  std::string DeclFile = URI::create(testPath(\"foo\")).toString();\n  Symbol Sym = func(\"Func\");\n  Sym.CanonicalDeclaration.FileURI = DeclFile.c_str();\n  Sym.IncludeHeaders.emplace_back(\"\\\"foo.h\\\"\", 2);\n  Sym.IncludeHeaders.emplace_back(\"\\\"bar.h\\\"\", 1000);\n\n  EXPECT_THAT(completions(TU, Test.point(), {Sym}).Completions,\n              UnorderedElementsAre(AllOf(Named(\"Func\"), HasInclude(\"\\\"foo.h\\\"\"),\n                                         Not(InsertInclude()))));\n}\n\nTEST(CompletionTest, MergeMacrosFromIndexAndSema) {\n  Symbol Sym;\n  Sym.Name = \"Clangd_Macro_Test\";\n  Sym.ID = SymbolID(\"c:foo.cpp@8@macro@Clangd_Macro_Test\");\n  Sym.SymInfo.Kind = index::SymbolKind::Macro;\n  Sym.Flags |= Symbol::IndexedForCodeCompletion;\n  EXPECT_THAT(completions(\"#define Clangd_Macro_Test\\nClangd_Macro_T^\", {Sym})\n                  .Completions,\n              UnorderedElementsAre(Named(\"Clangd_Macro_Test\")));\n}\n\nTEST(CompletionTest, MacroFromPreamble) {\n  Annotations Test(R\"cpp(#define CLANGD_PREAMBLE_MAIN x\n\n          int x = 0;\n          #define CLANGD_MAIN x\n          void f() { CLANGD_^ }\n      )cpp\");\n  auto TU = TestTU::withCode(Test.code());\n  TU.HeaderCode = \"#define CLANGD_PREAMBLE_HEADER x\";\n  auto Results = completions(TU, Test.point(), {func(\"CLANGD_INDEX\")});\n  // We should get results from the main file, including the preamble section.\n  // However no results from included files (the index should cover them).\n  EXPECT_THAT(Results.Completions,\n              UnorderedElementsAre(Named(\"CLANGD_PREAMBLE_MAIN\"),\n                                   Named(\"CLANGD_MAIN\"),\n                                   Named(\"CLANGD_INDEX\")));\n}\n\nTEST(CompletionTest, DeprecatedResults) {\n  std::string Body = R\"cpp(\n    void TestClangd();\n    void TestClangc() __attribute__((deprecated(\"\", \"\")));\n  )cpp\";\n\n  EXPECT_THAT(\n      completions(Body + \"int main() { TestClang^ }\").Completions,\n      UnorderedElementsAre(AllOf(Named(\"TestClangd\"), Not(Deprecated())),\n                           AllOf(Named(\"TestClangc\"), Deprecated())));\n}\n\nTEST(SignatureHelpTest, PartialSpec) {\n  const auto Results = signatures(R\"cpp(\n      template <typename T> struct Foo {};\n      template <typename T> struct Foo<T*> { Foo(T); };\n      Foo<int*> F(^);)cpp\");\n  EXPECT_THAT(Results.signatures, Contains(Sig(\"Foo([[T]])\")));\n  EXPECT_EQ(0, Results.activeParameter);\n}\n\nTEST(SignatureHelpTest, InsideArgument) {\n  {\n    const auto Results = signatures(R\"cpp(\n      void foo(int x);\n      void foo(int x, int y);\n      int main() { foo(1+^); }\n    )cpp\");\n    EXPECT_THAT(Results.signatures,\n                ElementsAre(Sig(\"foo([[int x]]) -> void\"),\n                            Sig(\"foo([[int x]], [[int y]]) -> void\")));\n    EXPECT_EQ(0, Results.activeParameter);\n  }\n  {\n    const auto Results = signatures(R\"cpp(\n      void foo(int x);\n      void foo(int x, int y);\n      int main() { foo(1^); }\n    )cpp\");\n    EXPECT_THAT(Results.signatures,\n                ElementsAre(Sig(\"foo([[int x]]) -> void\"),\n                            Sig(\"foo([[int x]], [[int y]]) -> void\")));\n    EXPECT_EQ(0, Results.activeParameter);\n  }\n  {\n    const auto Results = signatures(R\"cpp(\n      void foo(int x);\n      void foo(int x, int y);\n      int main() { foo(1^0); }\n    )cpp\");\n    EXPECT_THAT(Results.signatures,\n                ElementsAre(Sig(\"foo([[int x]]) -> void\"),\n                            Sig(\"foo([[int x]], [[int y]]) -> void\")));\n    EXPECT_EQ(0, Results.activeParameter);\n  }\n  {\n    const auto Results = signatures(R\"cpp(\n      void foo(int x);\n      void foo(int x, int y);\n      int bar(int x, int y);\n      int main() { bar(foo(2, 3^)); }\n    )cpp\");\n    EXPECT_THAT(Results.signatures,\n                ElementsAre(Sig(\"foo([[int x]], [[int y]]) -> void\")));\n    EXPECT_EQ(1, Results.activeParameter);\n  }\n}\n\nTEST(SignatureHelpTest, ConstructorInitializeFields) {\n  {\n    const auto Results = signatures(R\"cpp(\n      struct A {\n        A(int);\n      };\n      struct B {\n        B() : a_elem(^) {}\n        A a_elem;\n      };\n    )cpp\");\n    EXPECT_THAT(Results.signatures,\n                UnorderedElementsAre(Sig(\"A([[int]])\"), Sig(\"A([[A &&]])\"),\n                                     Sig(\"A([[const A &]])\")));\n  }\n  {\n    const auto Results = signatures(R\"cpp(\n      struct A {\n        A(int);\n      };\n      struct C {\n        C(int);\n        C(A);\n      };\n      struct B {\n        B() : c_elem(A(1^)) {}\n        C c_elem;\n      };\n    )cpp\");\n    EXPECT_THAT(Results.signatures,\n                UnorderedElementsAre(Sig(\"A([[int]])\"), Sig(\"A([[A &&]])\"),\n                                     Sig(\"A([[const A &]])\")));\n  }\n}\n\nTEST(CompletionTest, IncludedCompletionKinds) {\n  Annotations Test(R\"cpp(#include \"^)cpp\");\n  auto TU = TestTU::withCode(Test.code());\n  TU.AdditionalFiles[\"sub/bar.h\"] = \"\";\n  TU.ExtraArgs.push_back(\"-I\" + testPath(\"sub\"));\n\n  auto Results = completions(TU, Test.point());\n  EXPECT_THAT(Results.Completions,\n              AllOf(Has(\"sub/\", CompletionItemKind::Folder),\n                    Has(\"bar.h\\\"\", CompletionItemKind::File)));\n}\n\nTEST(CompletionTest, NoCrashAtNonAlphaIncludeHeader) {\n  completions(\n      R\"cpp(\n        #include \"./^\"\n      )cpp\");\n}\n\nTEST(CompletionTest, NoAllScopesCompletionWhenQualified) {\n  clangd::CodeCompleteOptions Opts = {};\n  Opts.AllScopes = true;\n\n  auto Results = completions(\n      R\"cpp(\n    void f() { na::Clangd^ }\n  )cpp\",\n      {cls(\"na::ClangdA\"), cls(\"nx::ClangdX\"), cls(\"Clangd3\")}, Opts);\n  EXPECT_THAT(Results.Completions,\n              UnorderedElementsAre(\n                  AllOf(Qualifier(\"\"), Scope(\"na::\"), Named(\"ClangdA\"))));\n}\n\nTEST(CompletionTest, AllScopesCompletion) {\n  clangd::CodeCompleteOptions Opts = {};\n  Opts.AllScopes = true;\n\n  auto Results = completions(\n      R\"cpp(\n    namespace na {\n    void f() { Clangd^ }\n    }\n  )cpp\",\n      {cls(\"nx::Clangd1\"), cls(\"ny::Clangd2\"), cls(\"Clangd3\"),\n       cls(\"na::nb::Clangd4\")},\n      Opts);\n  EXPECT_THAT(\n      Results.Completions,\n      UnorderedElementsAre(AllOf(Qualifier(\"nx::\"), Named(\"Clangd1\")),\n                           AllOf(Qualifier(\"ny::\"), Named(\"Clangd2\")),\n                           AllOf(Qualifier(\"\"), Scope(\"\"), Named(\"Clangd3\")),\n                           AllOf(Qualifier(\"nb::\"), Named(\"Clangd4\"))));\n}\n\nTEST(CompletionTest, NoQualifierIfShadowed) {\n  clangd::CodeCompleteOptions Opts = {};\n  Opts.AllScopes = true;\n\n  auto Results = completions(R\"cpp(\n    namespace nx { class Clangd1 {}; }\n    using nx::Clangd1;\n    void f() { Clangd^ }\n  )cpp\",\n                             {cls(\"nx::Clangd1\"), cls(\"nx::Clangd2\")}, Opts);\n  // Although Clangd1 is from another namespace, Sema tells us it's in-scope and\n  // needs no qualifier.\n  EXPECT_THAT(Results.Completions,\n              UnorderedElementsAre(AllOf(Qualifier(\"\"), Named(\"Clangd1\")),\n                                   AllOf(Qualifier(\"nx::\"), Named(\"Clangd2\"))));\n}\n\nTEST(CompletionTest, NoCompletionsForNewNames) {\n  clangd::CodeCompleteOptions Opts;\n  Opts.AllScopes = true;\n  auto Results = completions(R\"cpp(\n      void f() { int n^ }\n    )cpp\",\n                             {cls(\"naber\"), cls(\"nx::naber\")}, Opts);\n  EXPECT_THAT(Results.Completions, UnorderedElementsAre());\n}\n\nTEST(CompletionTest, Lambda) {\n  clangd::CodeCompleteOptions Opts = {};\n\n  auto Results = completions(R\"cpp(\n    void function() {\n      auto Lambda = [](int a, const double &b) {return 1.f;};\n      Lam^\n    }\n  )cpp\",\n                             {}, Opts);\n\n  ASSERT_EQ(Results.Completions.size(), 1u);\n  const auto &A = Results.Completions.front();\n  EXPECT_EQ(A.Name, \"Lambda\");\n  EXPECT_EQ(A.Signature, \"(int a, const double &b) const\");\n  EXPECT_EQ(A.Kind, CompletionItemKind::Variable);\n  EXPECT_EQ(A.ReturnType, \"float\");\n  EXPECT_EQ(A.SnippetSuffix, \"(${1:int a}, ${2:const double &b})\");\n}\n\nTEST(CompletionTest, StructuredBinding) {\n  clangd::CodeCompleteOptions Opts = {};\n\n  auto Results = completions(R\"cpp(\n    struct S {\n      using Float = float;\n      int x;\n      Float y;\n    };\n    void function() {\n      const auto &[xxx, yyy] = S{};\n      yyy^\n    }\n  )cpp\",\n                             {}, Opts);\n\n  ASSERT_EQ(Results.Completions.size(), 1u);\n  const auto &A = Results.Completions.front();\n  EXPECT_EQ(A.Name, \"yyy\");\n  EXPECT_EQ(A.Kind, CompletionItemKind::Variable);\n  EXPECT_EQ(A.ReturnType, \"const Float\");\n}\n\nTEST(CompletionTest, ObjectiveCMethodNoArguments) {\n  auto Results = completions(R\"objc(\n      @interface Foo\n      @property(nonatomic, setter=setXToIgnoreComplete:) int value;\n      @end\n      Foo *foo = [Foo new]; int y = [foo v^]\n    )objc\",\n                             /*IndexSymbols=*/{},\n                             /*Opts=*/{}, \"Foo.m\");\n\n  auto C = Results.Completions;\n  EXPECT_THAT(C, ElementsAre(Named(\"value\")));\n  EXPECT_THAT(C, ElementsAre(Kind(CompletionItemKind::Method)));\n  EXPECT_THAT(C, ElementsAre(ReturnType(\"int\")));\n  EXPECT_THAT(C, ElementsAre(Signature(\"\")));\n  EXPECT_THAT(C, ElementsAre(SnippetSuffix(\"\")));\n}\n\nTEST(CompletionTest, ObjectiveCMethodOneArgument) {\n  auto Results = completions(R\"objc(\n      @interface Foo\n      - (int)valueForCharacter:(char)c;\n      @end\n      Foo *foo = [Foo new]; int y = [foo v^]\n    )objc\",\n                             /*IndexSymbols=*/{},\n                             /*Opts=*/{}, \"Foo.m\");\n\n  auto C = Results.Completions;\n  EXPECT_THAT(C, ElementsAre(Named(\"valueForCharacter:\")));\n  EXPECT_THAT(C, ElementsAre(Kind(CompletionItemKind::Method)));\n  EXPECT_THAT(C, ElementsAre(ReturnType(\"int\")));\n  EXPECT_THAT(C, ElementsAre(Signature(\"(char)\")));\n  EXPECT_THAT(C, ElementsAre(SnippetSuffix(\"${1:(char)}\")));\n}\n\nTEST(CompletionTest, ObjectiveCMethodTwoArgumentsFromBeginning) {\n  auto Results = completions(R\"objc(\n      @interface Foo\n      + (id)fooWithValue:(int)value fooey:(unsigned int)fooey;\n      @end\n      id val = [Foo foo^]\n    )objc\",\n                             /*IndexSymbols=*/{},\n                             /*Opts=*/{}, \"Foo.m\");\n\n  auto C = Results.Completions;\n  EXPECT_THAT(C, ElementsAre(Named(\"fooWithValue:\")));\n  EXPECT_THAT(C, ElementsAre(Kind(CompletionItemKind::Method)));\n  EXPECT_THAT(C, ElementsAre(ReturnType(\"id\")));\n  EXPECT_THAT(C, ElementsAre(Signature(\"(int) fooey:(unsigned int)\")));\n  EXPECT_THAT(\n      C, ElementsAre(SnippetSuffix(\"${1:(int)} fooey:${2:(unsigned int)}\")));\n}\n\nTEST(CompletionTest, ObjectiveCMethodTwoArgumentsFromMiddle) {\n  auto Results = completions(R\"objc(\n      @interface Foo\n      + (id)fooWithValue:(int)value fooey:(unsigned int)fooey;\n      @end\n      id val = [Foo fooWithValue:10 f^]\n    )objc\",\n                             /*IndexSymbols=*/{},\n                             /*Opts=*/{}, \"Foo.m\");\n\n  auto C = Results.Completions;\n  EXPECT_THAT(C, ElementsAre(Named(\"fooey:\")));\n  EXPECT_THAT(C, ElementsAre(Kind(CompletionItemKind::Method)));\n  EXPECT_THAT(C, ElementsAre(ReturnType(\"id\")));\n  EXPECT_THAT(C, ElementsAre(Signature(\"(unsigned int)\")));\n  EXPECT_THAT(C, ElementsAre(SnippetSuffix(\"${1:(unsigned int)}\")));\n}\n\nTEST(CompletionTest, CursorInSnippets) {\n  clangd::CodeCompleteOptions Options;\n  Options.EnableSnippets = true;\n  auto Results = completions(\n      R\"cpp(\n    void while_foo(int a, int b);\n    void test() {\n      whil^\n    })cpp\",\n      /*IndexSymbols=*/{}, Options);\n\n  // Last placeholder in code patterns should be $0 to put the cursor there.\n  EXPECT_THAT(Results.Completions,\n              Contains(AllOf(\n                  Named(\"while\"),\n                  SnippetSuffix(\" (${1:condition}) {\\n${0:statements}\\n}\"))));\n  // However, snippets for functions must *not* end with $0.\n  EXPECT_THAT(Results.Completions,\n              Contains(AllOf(Named(\"while_foo\"),\n                             SnippetSuffix(\"(${1:int a}, ${2:int b})\"))));\n}\n\nTEST(CompletionTest, WorksWithNullType) {\n  auto R = completions(R\"cpp(\n    int main() {\n      for (auto [loopVar] : y ) { // y has to be unresolved.\n        int z = loopV^;\n      }\n    }\n  )cpp\");\n  EXPECT_THAT(R.Completions, ElementsAre(Named(\"loopVar\")));\n}\n\nTEST(CompletionTest, UsingDecl) {\n  const char *Header(R\"cpp(\n    void foo(int);\n    namespace std {\n      using ::foo;\n    })cpp\");\n  const char *Source(R\"cpp(\n    void bar() {\n      std::^;\n    })cpp\");\n  auto Index = TestTU::withHeaderCode(Header).index();\n  clangd::CodeCompleteOptions Opts;\n  Opts.Index = Index.get();\n  Opts.AllScopes = true;\n  auto R = completions(Source, {}, Opts);\n  EXPECT_THAT(R.Completions,\n              ElementsAre(AllOf(Scope(\"std::\"), Named(\"foo\"),\n                                Kind(CompletionItemKind::Reference))));\n}\n\nTEST(CompletionTest, ScopeIsUnresolved) {\n  clangd::CodeCompleteOptions Opts = {};\n  Opts.AllScopes = true;\n\n  auto Results = completions(R\"cpp(\n    namespace a {\n    void f() { b::X^ }\n    }\n  )cpp\",\n                             {cls(\"a::b::XYZ\")}, Opts);\n  EXPECT_THAT(Results.Completions,\n              UnorderedElementsAre(AllOf(Qualifier(\"\"), Named(\"XYZ\"))));\n}\n\nTEST(CompletionTest, NestedScopeIsUnresolved) {\n  clangd::CodeCompleteOptions Opts = {};\n  Opts.AllScopes = true;\n\n  auto Results = completions(R\"cpp(\n    namespace a {\n    namespace b {}\n    void f() { b::c::X^ }\n    }\n  )cpp\",\n                             {cls(\"a::b::c::XYZ\")}, Opts);\n  EXPECT_THAT(Results.Completions,\n              UnorderedElementsAre(AllOf(Qualifier(\"\"), Named(\"XYZ\"))));\n}\n\n// Clang parser gets confused here and doesn't report the ns:: prefix.\n// Naive behavior is to insert it again. We examine the source and recover.\nTEST(CompletionTest, NamespaceDoubleInsertion) {\n  clangd::CodeCompleteOptions Opts = {};\n\n  auto Results = completions(R\"cpp(\n    namespace foo {\n    namespace ns {}\n    #define M(X) < X\n    M(ns::ABC^\n    }\n  )cpp\",\n                             {cls(\"foo::ns::ABCDE\")}, Opts);\n  EXPECT_THAT(Results.Completions,\n              UnorderedElementsAre(AllOf(Qualifier(\"\"), Named(\"ABCDE\"))));\n}\n\nTEST(CompletionTest, DerivedMethodsAreAlwaysVisible) {\n  // Despite the fact that base method matches the ref-qualifier better,\n  // completion results should only include the derived method.\n  auto Completions = completions(R\"cpp(\n    struct deque_base {\n      float size();\n      double size() const;\n    };\n    struct deque : deque_base {\n        int size() const;\n    };\n\n    auto x = deque().^\n  )cpp\")\n                         .Completions;\n  EXPECT_THAT(Completions,\n              ElementsAre(AllOf(ReturnType(\"int\"), Named(\"size\"))));\n}\n\nTEST(CompletionTest, NoCrashWithIncompleteLambda) {\n  auto Completions = completions(\"auto&& x = []{^\").Completions;\n  // The completion of x itself can cause a problem: in the code completion\n  // callback, its type is not known, which affects the linkage calculation.\n  // A bad linkage value gets cached, and subsequently updated.\n  EXPECT_THAT(Completions, Contains(Named(\"x\")));\n\n  auto Signatures = signatures(\"auto x() { x(^\").signatures;\n  EXPECT_THAT(Signatures, Contains(Sig(\"x() -> auto\")));\n}\n\nTEST(CompletionTest, DelayedTemplateParsing) {\n  Annotations Test(R\"cpp(\n    int xxx;\n    template <typename T> int foo() { return xx^; }\n  )cpp\");\n  auto TU = TestTU::withCode(Test.code());\n  // Even though delayed-template-parsing is on, we will disable it to provide\n  // completion in templates.\n  TU.ExtraArgs.push_back(\"-fdelayed-template-parsing\");\n\n  EXPECT_THAT(completions(TU, Test.point()).Completions,\n              Contains(Named(\"xxx\")));\n}\n\nTEST(CompletionTest, CompletionRange) {\n  const char *WithRange = \"auto x = [[abc]]^\";\n  auto Completions = completions(WithRange);\n  EXPECT_EQ(Completions.CompletionRange, Annotations(WithRange).range());\n  Completions = completionsNoCompile(WithRange);\n  EXPECT_EQ(Completions.CompletionRange, Annotations(WithRange).range());\n\n  const char *EmptyRange = \"auto x = [[]]^\";\n  Completions = completions(EmptyRange);\n  EXPECT_EQ(Completions.CompletionRange, Annotations(EmptyRange).range());\n  Completions = completionsNoCompile(EmptyRange);\n  EXPECT_EQ(Completions.CompletionRange, Annotations(EmptyRange).range());\n\n  // Sema doesn't trigger at all here, while the no-sema completion runs\n  // heuristics as normal and reports a range. It'd be nice to be consistent.\n  const char *NoCompletion = \"/* [[]]^ */\";\n  Completions = completions(NoCompletion);\n  EXPECT_EQ(Completions.CompletionRange, llvm::None);\n  Completions = completionsNoCompile(NoCompletion);\n  EXPECT_EQ(Completions.CompletionRange, Annotations(NoCompletion).range());\n}\n\nTEST(NoCompileCompletionTest, Basic) {\n  auto Results = completionsNoCompile(R\"cpp(\n    void func() {\n      int xyz;\n      int abc;\n      ^\n    }\n  )cpp\");\n  EXPECT_FALSE(Results.RanParser);\n  EXPECT_THAT(Results.Completions,\n              UnorderedElementsAre(Named(\"void\"), Named(\"func\"), Named(\"int\"),\n                                   Named(\"xyz\"), Named(\"abc\")));\n}\n\nTEST(NoCompileCompletionTest, WithFilter) {\n  auto Results = completionsNoCompile(R\"cpp(\n    void func() {\n      int sym1;\n      int sym2;\n      int xyz1;\n      int xyz2;\n      sy^\n    }\n  )cpp\");\n  EXPECT_THAT(Results.Completions,\n              UnorderedElementsAre(Named(\"sym1\"), Named(\"sym2\")));\n}\n\nTEST(NoCompileCompletionTest, WithIndex) {\n  std::vector<Symbol> Syms = {func(\"xxx\"), func(\"a::xxx\"), func(\"ns::b::xxx\"),\n                              func(\"c::xxx\"), func(\"ns::d::xxx\")};\n  auto Results = completionsNoCompile(\n      R\"cpp(\n        // Current-scopes, unqualified completion.\n        using namespace a;\n        namespace ns {\n        using namespace b;\n        void foo() {\n        xx^\n        }\n        }\n      )cpp\",\n      Syms);\n  EXPECT_THAT(Results.Completions,\n              UnorderedElementsAre(AllOf(Qualifier(\"\"), Scope(\"\")),\n                                   AllOf(Qualifier(\"\"), Scope(\"a::\")),\n                                   AllOf(Qualifier(\"\"), Scope(\"ns::b::\"))));\n  CodeCompleteOptions Opts;\n  Opts.AllScopes = true;\n  Results = completionsNoCompile(\n      R\"cpp(\n        // All-scopes unqualified completion.\n        using namespace a;\n        namespace ns {\n        using namespace b;\n        void foo() {\n        xx^\n        }\n        }\n      )cpp\",\n      Syms, Opts);\n  EXPECT_THAT(Results.Completions,\n              UnorderedElementsAre(AllOf(Qualifier(\"\"), Scope(\"\")),\n                                   AllOf(Qualifier(\"\"), Scope(\"a::\")),\n                                   AllOf(Qualifier(\"\"), Scope(\"ns::b::\")),\n                                   AllOf(Qualifier(\"c::\"), Scope(\"c::\")),\n                                   AllOf(Qualifier(\"d::\"), Scope(\"ns::d::\"))));\n  Results = completionsNoCompile(\n      R\"cpp(\n        // Qualified completion.\n        using namespace a;\n        namespace ns {\n        using namespace b;\n        void foo() {\n        b::xx^\n        }\n        }\n      )cpp\",\n      Syms, Opts);\n  EXPECT_THAT(Results.Completions,\n              ElementsAre(AllOf(Qualifier(\"\"), Scope(\"ns::b::\"))));\n  Results = completionsNoCompile(\n      R\"cpp(\n        // Absolutely qualified completion.\n        using namespace a;\n        namespace ns {\n        using namespace b;\n        void foo() {\n        ::a::xx^\n        }\n        }\n      )cpp\",\n      Syms, Opts);\n  EXPECT_THAT(Results.Completions,\n              ElementsAre(AllOf(Qualifier(\"\"), Scope(\"a::\"))));\n}\n\nTEST(AllowImplicitCompletion, All) {\n  const char *Yes[] = {\n      \"foo.^bar\",\n      \"foo->^bar\",\n      \"foo::^bar\",\n      \"  #  include <^foo.h>\",\n      \"#import <foo/^bar.h>\",\n      \"#include_next \\\"^\",\n  };\n  const char *No[] = {\n      \"foo>^bar\",\n      \"foo:^bar\",\n      \"foo\\n^bar\",\n      \"#include <foo.h> //^\",\n      \"#include \\\"foo.h\\\"^\",\n      \"#error <^\",\n      \"#<^\",\n  };\n  for (const char *Test : Yes) {\n    llvm::Annotations A(Test);\n    EXPECT_TRUE(allowImplicitCompletion(A.code(), A.point())) << Test;\n  }\n  for (const char *Test : No) {\n    llvm::Annotations A(Test);\n    EXPECT_FALSE(allowImplicitCompletion(A.code(), A.point())) << Test;\n  }\n}\n\nTEST(CompletionTest, FunctionArgsExist) {\n  clangd::CodeCompleteOptions Opts;\n  Opts.EnableSnippets = true;\n  std::string Context = R\"cpp(\n    int foo(int A);\n    int bar();\n    struct Object {\n      Object(int B) {}\n    };\n    template <typename T>\n    struct Container {\n      Container(int Size) {}\n    };\n  )cpp\";\n  EXPECT_THAT(completions(Context + \"int y = fo^\", {}, Opts).Completions,\n              UnorderedElementsAre(\n                  AllOf(Labeled(\"foo(int A)\"), SnippetSuffix(\"(${1:int A})\"))));\n  EXPECT_THAT(\n      completions(Context + \"int y = fo^(42)\", {}, Opts).Completions,\n      UnorderedElementsAre(AllOf(Labeled(\"foo(int A)\"), SnippetSuffix(\"\"))));\n  // FIXME(kirillbobyrev): No snippet should be produced here.\n  EXPECT_THAT(completions(Context + \"int y = fo^o(42)\", {}, Opts).Completions,\n              UnorderedElementsAre(\n                  AllOf(Labeled(\"foo(int A)\"), SnippetSuffix(\"(${1:int A})\"))));\n  EXPECT_THAT(\n      completions(Context + \"int y = ba^\", {}, Opts).Completions,\n      UnorderedElementsAre(AllOf(Labeled(\"bar()\"), SnippetSuffix(\"()\"))));\n  EXPECT_THAT(completions(Context + \"int y = ba^()\", {}, Opts).Completions,\n              UnorderedElementsAre(AllOf(Labeled(\"bar()\"), SnippetSuffix(\"\"))));\n  EXPECT_THAT(\n      completions(Context + \"Object o = Obj^\", {}, Opts).Completions,\n      Contains(AllOf(Labeled(\"Object(int B)\"), SnippetSuffix(\"(${1:int B})\"),\n                     Kind(CompletionItemKind::Constructor))));\n  EXPECT_THAT(completions(Context + \"Object o = Obj^()\", {}, Opts).Completions,\n              Contains(AllOf(Labeled(\"Object(int B)\"), SnippetSuffix(\"\"),\n                             Kind(CompletionItemKind::Constructor))));\n  EXPECT_THAT(\n      completions(Context + \"Container c = Cont^\", {}, Opts).Completions,\n      Contains(AllOf(Labeled(\"Container<typename T>(int Size)\"),\n                     SnippetSuffix(\"<${1:typename T}>(${2:int Size})\"),\n                     Kind(CompletionItemKind::Constructor))));\n  EXPECT_THAT(\n      completions(Context + \"Container c = Cont^()\", {}, Opts).Completions,\n      Contains(AllOf(Labeled(\"Container<typename T>(int Size)\"),\n                     SnippetSuffix(\"<${1:typename T}>\"),\n                     Kind(CompletionItemKind::Constructor))));\n  EXPECT_THAT(\n      completions(Context + \"Container c = Cont^<int>()\", {}, Opts).Completions,\n      Contains(AllOf(Labeled(\"Container<typename T>(int Size)\"),\n                     SnippetSuffix(\"\"),\n                     Kind(CompletionItemKind::Constructor))));\n}\n\n} // namespace\n} // namespace clangd\n} // namespace clang\n"}, "24": {"id": 24, "path": "/home/vsts/work/1/llvm-project/llvm/utils/unittest/googletest/include/gtest/gtest.h", "content": "// Copyright 2005, Google Inc.\n// All rights reserved.\n//\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions are\n// met:\n//\n//     * Redistributions of source code must retain the above copyright\n// notice, this list of conditions and the following disclaimer.\n//     * Redistributions in binary form must reproduce the above\n// copyright notice, this list of conditions and the following disclaimer\n// in the documentation and/or other materials provided with the\n// distribution.\n//     * Neither the name of Google Inc. nor the names of its\n// contributors may be used to endorse or promote products derived from\n// this software without specific prior written permission.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n// \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n//\n// Author: wan@google.com (Zhanyong Wan)\n//\n// The Google C++ Testing Framework (Google Test)\n//\n// This header file defines the public API for Google Test.  It should be\n// included by any test program that uses Google Test.\n//\n// IMPORTANT NOTE: Due to limitation of the C++ language, we have to\n// leave some internal implementation details in this header file.\n// They are clearly marked by comments like this:\n//\n//   // INTERNAL IMPLEMENTATION - DO NOT USE IN A USER PROGRAM.\n//\n// Such code is NOT meant to be used by a user directly, and is subject\n// to CHANGE WITHOUT NOTICE.  Therefore DO NOT DEPEND ON IT in a user\n// program!\n//\n// Acknowledgment: Google Test borrowed the idea of automatic test\n// registration from Barthelemy Dagenais' (barthelemy@prologique.com)\n// easyUnit framework.\n\n#ifndef GTEST_INCLUDE_GTEST_GTEST_H_\n#define GTEST_INCLUDE_GTEST_GTEST_H_\n\n#include <limits>\n#include <ostream>\n#include <vector>\n\n#include \"gtest/internal/gtest-internal.h\"\n#include \"gtest/internal/gtest-string.h\"\n#include \"gtest/gtest-death-test.h\"\n#include \"gtest/gtest-message.h\"\n#include \"gtest/gtest-param-test.h\"\n#include \"gtest/gtest-printers.h\"\n#include \"gtest/gtest_prod.h\"\n#include \"gtest/gtest-test-part.h\"\n#include \"gtest/gtest-typed-test.h\"\n\n// Depending on the platform, different string classes are available.\n// On Linux, in addition to ::std::string, Google also makes use of\n// class ::string, which has the same interface as ::std::string, but\n// has a different implementation.\n//\n// You can define GTEST_HAS_GLOBAL_STRING to 1 to indicate that\n// ::string is available AND is a distinct type to ::std::string, or\n// define it to 0 to indicate otherwise.\n//\n// If ::std::string and ::string are the same class on your platform\n// due to aliasing, you should define GTEST_HAS_GLOBAL_STRING to 0.\n//\n// If you do not define GTEST_HAS_GLOBAL_STRING, it is defined\n// heuristically.\n\nnamespace testing {\n\n// Declares the flags.\n\n// This flag temporary enables the disabled tests.\nGTEST_DECLARE_bool_(also_run_disabled_tests);\n\n// This flag brings the debugger on an assertion failure.\nGTEST_DECLARE_bool_(break_on_failure);\n\n// This flag controls whether Google Test catches all test-thrown exceptions\n// and logs them as failures.\nGTEST_DECLARE_bool_(catch_exceptions);\n\n// This flag enables using colors in terminal output. Available values are\n// \"yes\" to enable colors, \"no\" (disable colors), or \"auto\" (the default)\n// to let Google Test decide.\nGTEST_DECLARE_string_(color);\n\n// This flag sets up the filter to select by name using a glob pattern\n// the tests to run. If the filter is not given all tests are executed.\nGTEST_DECLARE_string_(filter);\n\n// This flag causes the Google Test to list tests. None of the tests listed\n// are actually run if the flag is provided.\nGTEST_DECLARE_bool_(list_tests);\n\n// This flag controls whether Google Test emits a detailed XML report to a file\n// in addition to its normal textual output.\nGTEST_DECLARE_string_(output);\n\n// This flags control whether Google Test prints the elapsed time for each\n// test.\nGTEST_DECLARE_bool_(print_time);\n\n// This flag specifies the random number seed.\nGTEST_DECLARE_int32_(random_seed);\n\n// This flag sets how many times the tests are repeated. The default value\n// is 1. If the value is -1 the tests are repeating forever.\nGTEST_DECLARE_int32_(repeat);\n\n// This flag controls whether Google Test includes Google Test internal\n// stack frames in failure stack traces.\nGTEST_DECLARE_bool_(show_internal_stack_frames);\n\n// When this flag is specified, tests' order is randomized on every iteration.\nGTEST_DECLARE_bool_(shuffle);\n\n// This flag specifies the maximum number of stack frames to be\n// printed in a failure message.\nGTEST_DECLARE_int32_(stack_trace_depth);\n\n// When this flag is specified, a failed assertion will throw an\n// exception if exceptions are enabled, or exit the program with a\n// non-zero code otherwise.\nGTEST_DECLARE_bool_(throw_on_failure);\n\n// When this flag is set with a \"host:port\" string, on supported\n// platforms test results are streamed to the specified port on\n// the specified host machine.\nGTEST_DECLARE_string_(stream_result_to);\n\n// The upper limit for valid stack trace depths.\nconst int kMaxStackTraceDepth = 100;\n\nnamespace internal {\n\nclass AssertHelper;\nclass DefaultGlobalTestPartResultReporter;\nclass ExecDeathTest;\nclass NoExecDeathTest;\nclass FinalSuccessChecker;\nclass GTestFlagSaver;\nclass StreamingListenerTest;\nclass TestResultAccessor;\nclass TestEventListenersAccessor;\nclass TestEventRepeater;\nclass UnitTestRecordPropertyTestHelper;\nclass WindowsDeathTest;\nclass UnitTestImpl* GetUnitTestImpl();\nvoid ReportFailureInUnknownLocation(TestPartResult::Type result_type,\n                                    const std::string& message);\n\n}  // namespace internal\n\n// The friend relationship of some of these classes is cyclic.\n// If we don't forward declare them the compiler might confuse the classes\n// in friendship clauses with same named classes on the scope.\nclass Test;\nclass TestCase;\nclass TestInfo;\nclass UnitTest;\n\n// A class for indicating whether an assertion was successful.  When\n// the assertion wasn't successful, the AssertionResult object\n// remembers a non-empty message that describes how it failed.\n//\n// To create an instance of this class, use one of the factory functions\n// (AssertionSuccess() and AssertionFailure()).\n//\n// This class is useful for two purposes:\n//   1. Defining predicate functions to be used with Boolean test assertions\n//      EXPECT_TRUE/EXPECT_FALSE and their ASSERT_ counterparts\n//   2. Defining predicate-format functions to be\n//      used with predicate assertions (ASSERT_PRED_FORMAT*, etc).\n//\n// For example, if you define IsEven predicate:\n//\n//   testing::AssertionResult IsEven(int n) {\n//     if ((n % 2) == 0)\n//       return testing::AssertionSuccess();\n//     else\n//       return testing::AssertionFailure() << n << \" is odd\";\n//   }\n//\n// Then the failed expectation EXPECT_TRUE(IsEven(Fib(5)))\n// will print the message\n//\n//   Value of: IsEven(Fib(5))\n//     Actual: false (5 is odd)\n//   Expected: true\n//\n// instead of a more opaque\n//\n//   Value of: IsEven(Fib(5))\n//     Actual: false\n//   Expected: true\n//\n// in case IsEven is a simple Boolean predicate.\n//\n// If you expect your predicate to be reused and want to support informative\n// messages in EXPECT_FALSE and ASSERT_FALSE (negative assertions show up\n// about half as often as positive ones in our tests), supply messages for\n// both success and failure cases:\n//\n//   testing::AssertionResult IsEven(int n) {\n//     if ((n % 2) == 0)\n//       return testing::AssertionSuccess() << n << \" is even\";\n//     else\n//       return testing::AssertionFailure() << n << \" is odd\";\n//   }\n//\n// Then a statement EXPECT_FALSE(IsEven(Fib(6))) will print\n//\n//   Value of: IsEven(Fib(6))\n//     Actual: true (8 is even)\n//   Expected: false\n//\n// NB: Predicates that support negative Boolean assertions have reduced\n// performance in positive ones so be careful not to use them in tests\n// that have lots (tens of thousands) of positive Boolean assertions.\n//\n// To use this class with EXPECT_PRED_FORMAT assertions such as:\n//\n//   // Verifies that Foo() returns an even number.\n//   EXPECT_PRED_FORMAT1(IsEven, Foo());\n//\n// you need to define:\n//\n//   testing::AssertionResult IsEven(const char* expr, int n) {\n//     if ((n % 2) == 0)\n//       return testing::AssertionSuccess();\n//     else\n//       return testing::AssertionFailure()\n//         << \"Expected: \" << expr << \" is even\\n  Actual: it's \" << n;\n//   }\n//\n// If Foo() returns 5, you will see the following message:\n//\n//   Expected: Foo() is even\n//     Actual: it's 5\n//\nclass GTEST_API_ AssertionResult {\n public:\n  // Copy constructor.\n  // Used in EXPECT_TRUE/FALSE(assertion_result).\n  AssertionResult(const AssertionResult& other);\n\n  GTEST_DISABLE_MSC_WARNINGS_PUSH_(4800 /* forcing value to bool */)\n\n  // Used in the EXPECT_TRUE/FALSE(bool_expression).\n  //\n  // T must be contextually convertible to bool.\n  //\n  // The second parameter prevents this overload from being considered if\n  // the argument is implicitly convertible to AssertionResult. In that case\n  // we want AssertionResult's copy constructor to be used.\n  template <typename T>\n  explicit AssertionResult(\n      const T& success,\n      typename internal::EnableIf<\n          !internal::ImplicitlyConvertible<T, AssertionResult>::value>::type*\n          /*enabler*/ = NULL)\n      : success_(success) {}\n\n  GTEST_DISABLE_MSC_WARNINGS_POP_()\n\n  // Assignment operator.\n  AssertionResult& operator=(AssertionResult other) {\n    swap(other);\n    return *this;\n  }\n\n  // Returns true iff the assertion succeeded.\n  operator bool() const { return success_; }  // NOLINT\n\n  // Returns the assertion's negation. Used with EXPECT/ASSERT_FALSE.\n  AssertionResult operator!() const;\n\n  // Returns the text streamed into this AssertionResult. Test assertions\n  // use it when they fail (i.e., the predicate's outcome doesn't match the\n  // assertion's expectation). When nothing has been streamed into the\n  // object, returns an empty string.\n  const char* message() const {\n    return message_.get() != NULL ?  message_->c_str() : \"\";\n  }\n  // TODO(vladl@google.com): Remove this after making sure no clients use it.\n  // Deprecated; please use message() instead.\n  const char* failure_message() const { return message(); }\n\n  // Streams a custom failure message into this object.\n  template <typename T> AssertionResult& operator<<(const T& value) {\n    AppendMessage(Message() << value);\n    return *this;\n  }\n\n  // Allows streaming basic output manipulators such as endl or flush into\n  // this object.\n  AssertionResult& operator<<(\n      ::std::ostream& (*basic_manipulator)(::std::ostream& stream)) {\n    AppendMessage(Message() << basic_manipulator);\n    return *this;\n  }\n\n private:\n  // Appends the contents of message to message_.\n  void AppendMessage(const Message& a_message) {\n    if (message_.get() == NULL)\n      message_.reset(new ::std::string);\n    message_->append(a_message.GetString().c_str());\n  }\n\n  // Swap the contents of this AssertionResult with other.\n  void swap(AssertionResult& other);\n\n  // Stores result of the assertion predicate.\n  bool success_;\n  // Stores the message describing the condition in case the expectation\n  // construct is not satisfied with the predicate's outcome.\n  // Referenced via a pointer to avoid taking too much stack frame space\n  // with test assertions.\n  internal::scoped_ptr< ::std::string> message_;\n};\n\n// Makes a successful assertion result.\nGTEST_API_ AssertionResult AssertionSuccess();\n\n// Makes a failed assertion result.\nGTEST_API_ AssertionResult AssertionFailure();\n\n// Makes a failed assertion result with the given failure message.\n// Deprecated; use AssertionFailure() << msg.\nGTEST_API_ AssertionResult AssertionFailure(const Message& msg);\n\n// The abstract class that all tests inherit from.\n//\n// In Google Test, a unit test program contains one or many TestCases, and\n// each TestCase contains one or many Tests.\n//\n// When you define a test using the TEST macro, you don't need to\n// explicitly derive from Test - the TEST macro automatically does\n// this for you.\n//\n// The only time you derive from Test is when defining a test fixture\n// to be used a TEST_F.  For example:\n//\n//   class FooTest : public testing::Test {\n//    protected:\n//     void SetUp() override { ... }\n//     void TearDown() override { ... }\n//     ...\n//   };\n//\n//   TEST_F(FooTest, Bar) { ... }\n//   TEST_F(FooTest, Baz) { ... }\n//\n// Test is not copyable.\nclass GTEST_API_ Test {\n public:\n  friend class TestInfo;\n\n  // Defines types for pointers to functions that set up and tear down\n  // a test case.\n  typedef internal::SetUpTestCaseFunc SetUpTestCaseFunc;\n  typedef internal::TearDownTestCaseFunc TearDownTestCaseFunc;\n\n  // The d'tor is virtual as we intend to inherit from Test.\n  virtual ~Test();\n\n  // Sets up the stuff shared by all tests in this test case.\n  //\n  // Google Test will call Foo::SetUpTestCase() before running the first\n  // test in test case Foo.  Hence a sub-class can define its own\n  // SetUpTestCase() method to shadow the one defined in the super\n  // class.\n  static void SetUpTestCase() {}\n\n  // Tears down the stuff shared by all tests in this test case.\n  //\n  // Google Test will call Foo::TearDownTestCase() after running the last\n  // test in test case Foo.  Hence a sub-class can define its own\n  // TearDownTestCase() method to shadow the one defined in the super\n  // class.\n  static void TearDownTestCase() {}\n\n  // Returns true iff the current test has a fatal failure.\n  static bool HasFatalFailure();\n\n  // Returns true iff the current test has a non-fatal failure.\n  static bool HasNonfatalFailure();\n\n  // Returns true iff the current test has a (either fatal or\n  // non-fatal) failure.\n  static bool HasFailure() { return HasFatalFailure() || HasNonfatalFailure(); }\n\n  // Logs a property for the current test, test case, or for the entire\n  // invocation of the test program when used outside of the context of a\n  // test case.  Only the last value for a given key is remembered.  These\n  // are public static so they can be called from utility functions that are\n  // not members of the test fixture.  Calls to RecordProperty made during\n  // lifespan of the test (from the moment its constructor starts to the\n  // moment its destructor finishes) will be output in XML as attributes of\n  // the <testcase> element.  Properties recorded from fixture's\n  // SetUpTestCase or TearDownTestCase are logged as attributes of the\n  // corresponding <testsuite> element.  Calls to RecordProperty made in the\n  // global context (before or after invocation of RUN_ALL_TESTS and from\n  // SetUp/TearDown method of Environment objects registered with Google\n  // Test) will be output as attributes of the <testsuites> element.\n  static void RecordProperty(const std::string& key, const std::string& value);\n  static void RecordProperty(const std::string& key, int value);\n\n protected:\n  // Creates a Test object.\n  Test();\n\n  // Sets up the test fixture.\n  virtual void SetUp();\n\n  // Tears down the test fixture.\n  virtual void TearDown();\n\n private:\n  // Returns true iff the current test has the same fixture class as\n  // the first test in the current test case.\n  static bool HasSameFixtureClass();\n\n  // Runs the test after the test fixture has been set up.\n  //\n  // A sub-class must implement this to define the test logic.\n  //\n  // DO NOT OVERRIDE THIS FUNCTION DIRECTLY IN A USER PROGRAM.\n  // Instead, use the TEST or TEST_F macro.\n  virtual void TestBody() = 0;\n\n  // Sets up, executes, and tears down the test.\n  void Run();\n\n  // Deletes self.  We deliberately pick an unusual name for this\n  // internal method to avoid clashing with names used in user TESTs.\n  void DeleteSelf_() { delete this; }\n\n  const internal::scoped_ptr< GTEST_FLAG_SAVER_ > gtest_flag_saver_;\n\n  // Often a user misspells SetUp() as Setup() and spends a long time\n  // wondering why it is never called by Google Test.  The declaration of\n  // the following method is solely for catching such an error at\n  // compile time:\n  //\n  //   - The return type is deliberately chosen to be not void, so it\n  //   will be a conflict if void Setup() is declared in the user's\n  //   test fixture.\n  //\n  //   - This method is private, so it will be another compiler error\n  //   if the method is called from the user's test fixture.\n  //\n  // DO NOT OVERRIDE THIS FUNCTION.\n  //\n  // If you see an error about overriding the following function or\n  // about it being private, you have mis-spelled SetUp() as Setup().\n  struct Setup_should_be_spelled_SetUp {};\n  virtual Setup_should_be_spelled_SetUp* Setup() { return NULL; }\n\n  // We disallow copying Tests.\n  GTEST_DISALLOW_COPY_AND_ASSIGN_(Test);\n};\n\ntypedef internal::TimeInMillis TimeInMillis;\n\n// A copyable object representing a user specified test property which can be\n// output as a key/value string pair.\n//\n// Don't inherit from TestProperty as its destructor is not virtual.\nclass TestProperty {\n public:\n  // C'tor.  TestProperty does NOT have a default constructor.\n  // Always use this constructor (with parameters) to create a\n  // TestProperty object.\n  TestProperty(const std::string& a_key, const std::string& a_value) :\n    key_(a_key), value_(a_value) {\n  }\n\n  // Gets the user supplied key.\n  const char* key() const {\n    return key_.c_str();\n  }\n\n  // Gets the user supplied value.\n  const char* value() const {\n    return value_.c_str();\n  }\n\n  // Sets a new value, overriding the one supplied in the constructor.\n  void SetValue(const std::string& new_value) {\n    value_ = new_value;\n  }\n\n private:\n  // The key supplied by the user.\n  std::string key_;\n  // The value supplied by the user.\n  std::string value_;\n};\n\n// The result of a single Test.  This includes a list of\n// TestPartResults, a list of TestProperties, a count of how many\n// death tests there are in the Test, and how much time it took to run\n// the Test.\n//\n// TestResult is not copyable.\nclass GTEST_API_ TestResult {\n public:\n  // Creates an empty TestResult.\n  TestResult();\n\n  // D'tor.  Do not inherit from TestResult.\n  ~TestResult();\n\n  // Gets the number of all test parts.  This is the sum of the number\n  // of successful test parts and the number of failed test parts.\n  int total_part_count() const;\n\n  // Returns the number of the test properties.\n  int test_property_count() const;\n\n  // Returns true iff the test passed (i.e. no test part failed).\n  bool Passed() const { return !Failed(); }\n\n  // Returns true iff the test failed.\n  bool Failed() const;\n\n  // Returns true iff the test fatally failed.\n  bool HasFatalFailure() const;\n\n  // Returns true iff the test has a non-fatal failure.\n  bool HasNonfatalFailure() const;\n\n  // Returns the elapsed time, in milliseconds.\n  TimeInMillis elapsed_time() const { return elapsed_time_; }\n\n  // Returns the i-th test part result among all the results. i can range\n  // from 0 to test_property_count() - 1. If i is not in that range, aborts\n  // the program.\n  const TestPartResult& GetTestPartResult(int i) const;\n\n  // Returns the i-th test property. i can range from 0 to\n  // test_property_count() - 1. If i is not in that range, aborts the\n  // program.\n  const TestProperty& GetTestProperty(int i) const;\n\n private:\n  friend class TestInfo;\n  friend class TestCase;\n  friend class UnitTest;\n  friend class internal::DefaultGlobalTestPartResultReporter;\n  friend class internal::ExecDeathTest;\n  friend class internal::TestResultAccessor;\n  friend class internal::UnitTestImpl;\n  friend class internal::WindowsDeathTest;\n\n  // Gets the vector of TestPartResults.\n  const std::vector<TestPartResult>& test_part_results() const {\n    return test_part_results_;\n  }\n\n  // Gets the vector of TestProperties.\n  const std::vector<TestProperty>& test_properties() const {\n    return test_properties_;\n  }\n\n  // Sets the elapsed time.\n  void set_elapsed_time(TimeInMillis elapsed) { elapsed_time_ = elapsed; }\n\n  // Adds a test property to the list. The property is validated and may add\n  // a non-fatal failure if invalid (e.g., if it conflicts with reserved\n  // key names). If a property is already recorded for the same key, the\n  // value will be updated, rather than storing multiple values for the same\n  // key.  xml_element specifies the element for which the property is being\n  // recorded and is used for validation.\n  void RecordProperty(const std::string& xml_element,\n                      const TestProperty& test_property);\n\n  // Adds a failure if the key is a reserved attribute of Google Test\n  // testcase tags.  Returns true if the property is valid.\n  // TODO(russr): Validate attribute names are legal and human readable.\n  static bool ValidateTestProperty(const std::string& xml_element,\n                                   const TestProperty& test_property);\n\n  // Adds a test part result to the list.\n  void AddTestPartResult(const TestPartResult& test_part_result);\n\n  // Returns the death test count.\n  int death_test_count() const { return death_test_count_; }\n\n  // Increments the death test count, returning the new count.\n  int increment_death_test_count() { return ++death_test_count_; }\n\n  // Clears the test part results.\n  void ClearTestPartResults();\n\n  // Clears the object.\n  void Clear();\n\n  // Protects mutable state of the property vector and of owned\n  // properties, whose values may be updated.\n  internal::Mutex test_properites_mutex_;\n\n  // The vector of TestPartResults\n  std::vector<TestPartResult> test_part_results_;\n  // The vector of TestProperties\n  std::vector<TestProperty> test_properties_;\n  // Running count of death tests.\n  int death_test_count_;\n  // The elapsed time, in milliseconds.\n  TimeInMillis elapsed_time_;\n\n  // We disallow copying TestResult.\n  GTEST_DISALLOW_COPY_AND_ASSIGN_(TestResult);\n};  // class TestResult\n\n// A TestInfo object stores the following information about a test:\n//\n//   Test case name\n//   Test name\n//   Whether the test should be run\n//   A function pointer that creates the test object when invoked\n//   Test result\n//\n// The constructor of TestInfo registers itself with the UnitTest\n// singleton such that the RUN_ALL_TESTS() macro knows which tests to\n// run.\nclass GTEST_API_ TestInfo {\n public:\n  // Destructs a TestInfo object.  This function is not virtual, so\n  // don't inherit from TestInfo.\n  ~TestInfo();\n\n  // Returns the test case name.\n  const char* test_case_name() const { return test_case_name_.c_str(); }\n\n  // Returns the test name.\n  const char* name() const { return name_.c_str(); }\n\n  // Returns the name of the parameter type, or NULL if this is not a typed\n  // or a type-parameterized test.\n  const char* type_param() const {\n    if (type_param_.get() != NULL)\n      return type_param_->c_str();\n    return NULL;\n  }\n\n  // Returns the text representation of the value parameter, or NULL if this\n  // is not a value-parameterized test.\n  const char* value_param() const {\n    if (value_param_.get() != NULL)\n      return value_param_->c_str();\n    return NULL;\n  }\n\n  // Returns the file name where this test is defined.\n  const char* file() const { return location_.file.c_str(); }\n\n  // Returns the line where this test is defined.\n  int line() const { return location_.line; }\n\n  // Returns true if this test should run, that is if the test is not\n  // disabled (or it is disabled but the also_run_disabled_tests flag has\n  // been specified) and its full name matches the user-specified filter.\n  //\n  // Google Test allows the user to filter the tests by their full names.\n  // The full name of a test Bar in test case Foo is defined as\n  // \"Foo.Bar\".  Only the tests that match the filter will run.\n  //\n  // A filter is a colon-separated list of glob (not regex) patterns,\n  // optionally followed by a '-' and a colon-separated list of\n  // negative patterns (tests to exclude).  A test is run if it\n  // matches one of the positive patterns and does not match any of\n  // the negative patterns.\n  //\n  // For example, *A*:Foo.* is a filter that matches any string that\n  // contains the character 'A' or starts with \"Foo.\".\n  bool should_run() const { return should_run_; }\n\n  // Returns true iff this test will appear in the XML report.\n  bool is_reportable() const {\n    // For now, the XML report includes all tests matching the filter.\n    // In the future, we may trim tests that are excluded because of\n    // sharding.\n    return matches_filter_;\n  }\n\n  // Returns the result of the test.\n  const TestResult* result() const { return &result_; }\n\n private:\n#if GTEST_HAS_DEATH_TEST\n  friend class internal::DefaultDeathTestFactory;\n#endif  // GTEST_HAS_DEATH_TEST\n  friend class Test;\n  friend class TestCase;\n  friend class internal::UnitTestImpl;\n  friend class internal::StreamingListenerTest;\n  friend TestInfo* internal::MakeAndRegisterTestInfo(\n      const char* test_case_name,\n      const char* name,\n      const char* type_param,\n      const char* value_param,\n      internal::CodeLocation code_location,\n      internal::TypeId fixture_class_id,\n      Test::SetUpTestCaseFunc set_up_tc,\n      Test::TearDownTestCaseFunc tear_down_tc,\n      internal::TestFactoryBase* factory);\n\n  // Constructs a TestInfo object. The newly constructed instance assumes\n  // ownership of the factory object.\n  TestInfo(const std::string& test_case_name,\n           const std::string& name,\n           const char* a_type_param,   // NULL if not a type-parameterized test\n           const char* a_value_param,  // NULL if not a value-parameterized test\n           internal::CodeLocation a_code_location,\n           internal::TypeId fixture_class_id,\n           internal::TestFactoryBase* factory);\n\n  // Increments the number of death tests encountered in this test so\n  // far.\n  int increment_death_test_count() {\n    return result_.increment_death_test_count();\n  }\n\n  // Creates the test object, runs it, records its result, and then\n  // deletes it.\n  void Run();\n\n  static void ClearTestResult(TestInfo* test_info) {\n    test_info->result_.Clear();\n  }\n\n  // These fields are immutable properties of the test.\n  const std::string test_case_name_;     // Test case name\n  const std::string name_;               // Test name\n  // Name of the parameter type, or NULL if this is not a typed or a\n  // type-parameterized test.\n  const internal::scoped_ptr<const ::std::string> type_param_;\n  // Text representation of the value parameter, or NULL if this is not a\n  // value-parameterized test.\n  const internal::scoped_ptr<const ::std::string> value_param_;\n  internal::CodeLocation location_;\n  const internal::TypeId fixture_class_id_;   // ID of the test fixture class\n  bool should_run_;                 // True iff this test should run\n  bool is_disabled_;                // True iff this test is disabled\n  bool matches_filter_;             // True if this test matches the\n                                    // user-specified filter.\n  internal::TestFactoryBase* const factory_;  // The factory that creates\n                                              // the test object\n\n  // This field is mutable and needs to be reset before running the\n  // test for the second time.\n  TestResult result_;\n\n  GTEST_DISALLOW_COPY_AND_ASSIGN_(TestInfo);\n};\n\n// A test case, which consists of a vector of TestInfos.\n//\n// TestCase is not copyable.\nclass GTEST_API_ TestCase {\n public:\n  // Creates a TestCase with the given name.\n  //\n  // TestCase does NOT have a default constructor.  Always use this\n  // constructor to create a TestCase object.\n  //\n  // Arguments:\n  //\n  //   name:         name of the test case\n  //   a_type_param: the name of the test's type parameter, or NULL if\n  //                 this is not a type-parameterized test.\n  //   set_up_tc:    pointer to the function that sets up the test case\n  //   tear_down_tc: pointer to the function that tears down the test case\n  TestCase(const char* name, const char* a_type_param,\n           Test::SetUpTestCaseFunc set_up_tc,\n           Test::TearDownTestCaseFunc tear_down_tc);\n\n  // Destructor of TestCase.\n  virtual ~TestCase();\n\n  // Gets the name of the TestCase.\n  const char* name() const { return name_.c_str(); }\n\n  // Returns the name of the parameter type, or NULL if this is not a\n  // type-parameterized test case.\n  const char* type_param() const {\n    if (type_param_.get() != NULL)\n      return type_param_->c_str();\n    return NULL;\n  }\n\n  // Returns true if any test in this test case should run.\n  bool should_run() const { return should_run_; }\n\n  // Gets the number of successful tests in this test case.\n  int successful_test_count() const;\n\n  // Gets the number of failed tests in this test case.\n  int failed_test_count() const;\n\n  // Gets the number of disabled tests that will be reported in the XML report.\n  int reportable_disabled_test_count() const;\n\n  // Gets the number of disabled tests in this test case.\n  int disabled_test_count() const;\n\n  // Gets the number of tests to be printed in the XML report.\n  int reportable_test_count() const;\n\n  // Get the number of tests in this test case that should run.\n  int test_to_run_count() const;\n\n  // Gets the number of all tests in this test case.\n  int total_test_count() const;\n\n  // Returns true iff the test case passed.\n  bool Passed() const { return !Failed(); }\n\n  // Returns true iff the test case failed.\n  bool Failed() const { return failed_test_count() > 0; }\n\n  // Returns the elapsed time, in milliseconds.\n  TimeInMillis elapsed_time() const { return elapsed_time_; }\n\n  // Returns the i-th test among all the tests. i can range from 0 to\n  // total_test_count() - 1. If i is not in that range, returns NULL.\n  const TestInfo* GetTestInfo(int i) const;\n\n  // Returns the TestResult that holds test properties recorded during\n  // execution of SetUpTestCase and TearDownTestCase.\n  const TestResult& ad_hoc_test_result() const { return ad_hoc_test_result_; }\n\n private:\n  friend class Test;\n  friend class internal::UnitTestImpl;\n\n  // Gets the (mutable) vector of TestInfos in this TestCase.\n  std::vector<TestInfo*>& test_info_list() { return test_info_list_; }\n\n  // Gets the (immutable) vector of TestInfos in this TestCase.\n  const std::vector<TestInfo*>& test_info_list() const {\n    return test_info_list_;\n  }\n\n  // Returns the i-th test among all the tests. i can range from 0 to\n  // total_test_count() - 1. If i is not in that range, returns NULL.\n  TestInfo* GetMutableTestInfo(int i);\n\n  // Sets the should_run member.\n  void set_should_run(bool should) { should_run_ = should; }\n\n  // Adds a TestInfo to this test case.  Will delete the TestInfo upon\n  // destruction of the TestCase object.\n  void AddTestInfo(TestInfo * test_info);\n\n  // Clears the results of all tests in this test case.\n  void ClearResult();\n\n  // Clears the results of all tests in the given test case.\n  static void ClearTestCaseResult(TestCase* test_case) {\n    test_case->ClearResult();\n  }\n\n  // Runs every test in this TestCase.\n  void Run();\n\n  // Runs SetUpTestCase() for this TestCase.  This wrapper is needed\n  // for catching exceptions thrown from SetUpTestCase().\n  void RunSetUpTestCase() { (*set_up_tc_)(); }\n\n  // Runs TearDownTestCase() for this TestCase.  This wrapper is\n  // needed for catching exceptions thrown from TearDownTestCase().\n  void RunTearDownTestCase() { (*tear_down_tc_)(); }\n\n  // Returns true iff test passed.\n  static bool TestPassed(const TestInfo* test_info) {\n    return test_info->should_run() && test_info->result()->Passed();\n  }\n\n  // Returns true iff test failed.\n  static bool TestFailed(const TestInfo* test_info) {\n    return test_info->should_run() && test_info->result()->Failed();\n  }\n\n  // Returns true iff the test is disabled and will be reported in the XML\n  // report.\n  static bool TestReportableDisabled(const TestInfo* test_info) {\n    return test_info->is_reportable() && test_info->is_disabled_;\n  }\n\n  // Returns true iff test is disabled.\n  static bool TestDisabled(const TestInfo* test_info) {\n    return test_info->is_disabled_;\n  }\n\n  // Returns true iff this test will appear in the XML report.\n  static bool TestReportable(const TestInfo* test_info) {\n    return test_info->is_reportable();\n  }\n\n  // Returns true if the given test should run.\n  static bool ShouldRunTest(const TestInfo* test_info) {\n    return test_info->should_run();\n  }\n\n  // Shuffles the tests in this test case.\n  void ShuffleTests(internal::Random* random);\n\n  // Restores the test order to before the first shuffle.\n  void UnshuffleTests();\n\n  // Name of the test case.\n  std::string name_;\n  // Name of the parameter type, or NULL if this is not a typed or a\n  // type-parameterized test.\n  const internal::scoped_ptr<const ::std::string> type_param_;\n  // The vector of TestInfos in their original order.  It owns the\n  // elements in the vector.\n  std::vector<TestInfo*> test_info_list_;\n  // Provides a level of indirection for the test list to allow easy\n  // shuffling and restoring the test order.  The i-th element in this\n  // vector is the index of the i-th test in the shuffled test list.\n  std::vector<int> test_indices_;\n  // Pointer to the function that sets up the test case.\n  Test::SetUpTestCaseFunc set_up_tc_;\n  // Pointer to the function that tears down the test case.\n  Test::TearDownTestCaseFunc tear_down_tc_;\n  // True iff any test in this test case should run.\n  bool should_run_;\n  // Elapsed time, in milliseconds.\n  TimeInMillis elapsed_time_;\n  // Holds test properties recorded during execution of SetUpTestCase and\n  // TearDownTestCase.\n  TestResult ad_hoc_test_result_;\n\n  // We disallow copying TestCases.\n  GTEST_DISALLOW_COPY_AND_ASSIGN_(TestCase);\n};\n\n// An Environment object is capable of setting up and tearing down an\n// environment.  You should subclass this to define your own\n// environment(s).\n//\n// An Environment object does the set-up and tear-down in virtual\n// methods SetUp() and TearDown() instead of the constructor and the\n// destructor, as:\n//\n//   1. You cannot safely throw from a destructor.  This is a problem\n//      as in some cases Google Test is used where exceptions are enabled, and\n//      we may want to implement ASSERT_* using exceptions where they are\n//      available.\n//   2. You cannot use ASSERT_* directly in a constructor or\n//      destructor.\nclass Environment {\n public:\n  // The d'tor is virtual as we need to subclass Environment.\n  virtual ~Environment() {}\n\n  // Override this to define how to set up the environment.\n  virtual void SetUp() {}\n\n  // Override this to define how to tear down the environment.\n  virtual void TearDown() {}\n private:\n  // If you see an error about overriding the following function or\n  // about it being private, you have mis-spelled SetUp() as Setup().\n  struct Setup_should_be_spelled_SetUp {};\n  virtual Setup_should_be_spelled_SetUp* Setup() { return NULL; }\n};\n\n// The interface for tracing execution of tests. The methods are organized in\n// the order the corresponding events are fired.\nclass TestEventListener {\n public:\n  virtual ~TestEventListener() {}\n\n  // Fired before any test activity starts.\n  virtual void OnTestProgramStart(const UnitTest& unit_test) = 0;\n\n  // Fired before each iteration of tests starts.  There may be more than\n  // one iteration if GTEST_FLAG(repeat) is set. iteration is the iteration\n  // index, starting from 0.\n  virtual void OnTestIterationStart(const UnitTest& unit_test,\n                                    int iteration) = 0;\n\n  // Fired before environment set-up for each iteration of tests starts.\n  virtual void OnEnvironmentsSetUpStart(const UnitTest& unit_test) = 0;\n\n  // Fired after environment set-up for each iteration of tests ends.\n  virtual void OnEnvironmentsSetUpEnd(const UnitTest& unit_test) = 0;\n\n  // Fired before the test case starts.\n  virtual void OnTestCaseStart(const TestCase& test_case) = 0;\n\n  // Fired before the test starts.\n  virtual void OnTestStart(const TestInfo& test_info) = 0;\n\n  // Fired after a failed assertion or a SUCCEED() invocation.\n  virtual void OnTestPartResult(const TestPartResult& test_part_result) = 0;\n\n  // Fired after the test ends.\n  virtual void OnTestEnd(const TestInfo& test_info) = 0;\n\n  // Fired after the test case ends.\n  virtual void OnTestCaseEnd(const TestCase& test_case) = 0;\n\n  // Fired before environment tear-down for each iteration of tests starts.\n  virtual void OnEnvironmentsTearDownStart(const UnitTest& unit_test) = 0;\n\n  // Fired after environment tear-down for each iteration of tests ends.\n  virtual void OnEnvironmentsTearDownEnd(const UnitTest& unit_test) = 0;\n\n  // Fired after each iteration of tests finishes.\n  virtual void OnTestIterationEnd(const UnitTest& unit_test,\n                                  int iteration) = 0;\n\n  // Fired after all test activities have ended.\n  virtual void OnTestProgramEnd(const UnitTest& unit_test) = 0;\n};\n\n// The convenience class for users who need to override just one or two\n// methods and are not concerned that a possible change to a signature of\n// the methods they override will not be caught during the build.  For\n// comments about each method please see the definition of TestEventListener\n// above.\nclass EmptyTestEventListener : public TestEventListener {\n public:\n  virtual void OnTestProgramStart(const UnitTest& /*unit_test*/) {}\n  virtual void OnTestIterationStart(const UnitTest& /*unit_test*/,\n                                    int /*iteration*/) {}\n  virtual void OnEnvironmentsSetUpStart(const UnitTest& /*unit_test*/) {}\n  virtual void OnEnvironmentsSetUpEnd(const UnitTest& /*unit_test*/) {}\n  virtual void OnTestCaseStart(const TestCase& /*test_case*/) {}\n  virtual void OnTestStart(const TestInfo& /*test_info*/) {}\n  virtual void OnTestPartResult(const TestPartResult& /*test_part_result*/) {}\n  virtual void OnTestEnd(const TestInfo& /*test_info*/) {}\n  virtual void OnTestCaseEnd(const TestCase& /*test_case*/) {}\n  virtual void OnEnvironmentsTearDownStart(const UnitTest& /*unit_test*/) {}\n  virtual void OnEnvironmentsTearDownEnd(const UnitTest& /*unit_test*/) {}\n  virtual void OnTestIterationEnd(const UnitTest& /*unit_test*/,\n                                  int /*iteration*/) {}\n  virtual void OnTestProgramEnd(const UnitTest& /*unit_test*/) {}\n};\n\n// TestEventListeners lets users add listeners to track events in Google Test.\nclass GTEST_API_ TestEventListeners {\n public:\n  TestEventListeners();\n  ~TestEventListeners();\n\n  // Appends an event listener to the end of the list. Google Test assumes\n  // the ownership of the listener (i.e. it will delete the listener when\n  // the test program finishes).\n  void Append(TestEventListener* listener);\n\n  // Removes the given event listener from the list and returns it.  It then\n  // becomes the caller's responsibility to delete the listener. Returns\n  // NULL if the listener is not found in the list.\n  TestEventListener* Release(TestEventListener* listener);\n\n  // Returns the standard listener responsible for the default console\n  // output.  Can be removed from the listeners list to shut down default\n  // console output.  Note that removing this object from the listener list\n  // with Release transfers its ownership to the caller and makes this\n  // function return NULL the next time.\n  TestEventListener* default_result_printer() const {\n    return default_result_printer_;\n  }\n\n  // Returns the standard listener responsible for the default XML output\n  // controlled by the --gtest_output=xml flag.  Can be removed from the\n  // listeners list by users who want to shut down the default XML output\n  // controlled by this flag and substitute it with custom one.  Note that\n  // removing this object from the listener list with Release transfers its\n  // ownership to the caller and makes this function return NULL the next\n  // time.\n  TestEventListener* default_xml_generator() const {\n    return default_xml_generator_;\n  }\n\n private:\n  friend class TestCase;\n  friend class TestInfo;\n  friend class internal::DefaultGlobalTestPartResultReporter;\n  friend class internal::NoExecDeathTest;\n  friend class internal::TestEventListenersAccessor;\n  friend class internal::UnitTestImpl;\n\n  // Returns repeater that broadcasts the TestEventListener events to all\n  // subscribers.\n  TestEventListener* repeater();\n\n  // Sets the default_result_printer attribute to the provided listener.\n  // The listener is also added to the listener list and previous\n  // default_result_printer is removed from it and deleted. The listener can\n  // also be NULL in which case it will not be added to the list. Does\n  // nothing if the previous and the current listener objects are the same.\n  void SetDefaultResultPrinter(TestEventListener* listener);\n\n  // Sets the default_xml_generator attribute to the provided listener.  The\n  // listener is also added to the listener list and previous\n  // default_xml_generator is removed from it and deleted. The listener can\n  // also be NULL in which case it will not be added to the list. Does\n  // nothing if the previous and the current listener objects are the same.\n  void SetDefaultXmlGenerator(TestEventListener* listener);\n\n  // Controls whether events will be forwarded by the repeater to the\n  // listeners in the list.\n  bool EventForwardingEnabled() const;\n  void SuppressEventForwarding();\n\n  // The actual list of listeners.\n  internal::TestEventRepeater* repeater_;\n  // Listener responsible for the standard result output.\n  TestEventListener* default_result_printer_;\n  // Listener responsible for the creation of the XML output file.\n  TestEventListener* default_xml_generator_;\n\n  // We disallow copying TestEventListeners.\n  GTEST_DISALLOW_COPY_AND_ASSIGN_(TestEventListeners);\n};\n\n// A UnitTest consists of a vector of TestCases.\n//\n// This is a singleton class.  The only instance of UnitTest is\n// created when UnitTest::GetInstance() is first called.  This\n// instance is never deleted.\n//\n// UnitTest is not copyable.\n//\n// This class is thread-safe as long as the methods are called\n// according to their specification.\nclass GTEST_API_ UnitTest {\n public:\n  // Gets the singleton UnitTest object.  The first time this method\n  // is called, a UnitTest object is constructed and returned.\n  // Consecutive calls will return the same object.\n  static UnitTest* GetInstance();\n\n  // Runs all tests in this UnitTest object and prints the result.\n  // Returns 0 if successful, or 1 otherwise.\n  //\n  // This method can only be called from the main thread.\n  //\n  // INTERNAL IMPLEMENTATION - DO NOT USE IN A USER PROGRAM.\n  int Run() GTEST_MUST_USE_RESULT_;\n\n  // Returns the working directory when the first TEST() or TEST_F()\n  // was executed.  The UnitTest object owns the string.\n  const char* original_working_dir() const;\n\n  // Returns the TestCase object for the test that's currently running,\n  // or NULL if no test is running.\n  const TestCase* current_test_case() const\n      GTEST_LOCK_EXCLUDED_(mutex_);\n\n  // Returns the TestInfo object for the test that's currently running,\n  // or NULL if no test is running.\n  const TestInfo* current_test_info() const\n      GTEST_LOCK_EXCLUDED_(mutex_);\n\n  // Returns the random seed used at the start of the current test run.\n  int random_seed() const;\n\n#if GTEST_HAS_PARAM_TEST\n  // Returns the ParameterizedTestCaseRegistry object used to keep track of\n  // value-parameterized tests and instantiate and register them.\n  //\n  // INTERNAL IMPLEMENTATION - DO NOT USE IN A USER PROGRAM.\n  internal::ParameterizedTestCaseRegistry& parameterized_test_registry()\n      GTEST_LOCK_EXCLUDED_(mutex_);\n#endif  // GTEST_HAS_PARAM_TEST\n\n  // Gets the number of successful test cases.\n  int successful_test_case_count() const;\n\n  // Gets the number of failed test cases.\n  int failed_test_case_count() const;\n\n  // Gets the number of all test cases.\n  int total_test_case_count() const;\n\n  // Gets the number of all test cases that contain at least one test\n  // that should run.\n  int test_case_to_run_count() const;\n\n  // Gets the number of successful tests.\n  int successful_test_count() const;\n\n  // Gets the number of failed tests.\n  int failed_test_count() const;\n\n  // Gets the number of disabled tests that will be reported in the XML report.\n  int reportable_disabled_test_count() const;\n\n  // Gets the number of disabled tests.\n  int disabled_test_count() const;\n\n  // Gets the number of tests to be printed in the XML report.\n  int reportable_test_count() const;\n\n  // Gets the number of all tests.\n  int total_test_count() const;\n\n  // Gets the number of tests that should run.\n  int test_to_run_count() const;\n\n  // Gets the time of the test program start, in ms from the start of the\n  // UNIX epoch.\n  TimeInMillis start_timestamp() const;\n\n  // Gets the elapsed time, in milliseconds.\n  TimeInMillis elapsed_time() const;\n\n  // Returns true iff the unit test passed (i.e. all test cases passed).\n  bool Passed() const;\n\n  // Returns true iff the unit test failed (i.e. some test case failed\n  // or something outside of all tests failed).\n  bool Failed() const;\n\n  // Gets the i-th test case among all the test cases. i can range from 0 to\n  // total_test_case_count() - 1. If i is not in that range, returns NULL.\n  const TestCase* GetTestCase(int i) const;\n\n  // Returns the TestResult containing information on test failures and\n  // properties logged outside of individual test cases.\n  const TestResult& ad_hoc_test_result() const;\n\n  // Returns the list of event listeners that can be used to track events\n  // inside Google Test.\n  TestEventListeners& listeners();\n\n private:\n  // Registers and returns a global test environment.  When a test\n  // program is run, all global test environments will be set-up in\n  // the order they were registered.  After all tests in the program\n  // have finished, all global test environments will be torn-down in\n  // the *reverse* order they were registered.\n  //\n  // The UnitTest object takes ownership of the given environment.\n  //\n  // This method can only be called from the main thread.\n  Environment* AddEnvironment(Environment* env);\n\n  // Adds a TestPartResult to the current TestResult object.  All\n  // Google Test assertion macros (e.g. ASSERT_TRUE, EXPECT_EQ, etc)\n  // eventually call this to report their results.  The user code\n  // should use the assertion macros instead of calling this directly.\n  void AddTestPartResult(TestPartResult::Type result_type,\n                         const char* file_name,\n                         int line_number,\n                         const std::string& message,\n                         const std::string& os_stack_trace)\n      GTEST_LOCK_EXCLUDED_(mutex_);\n\n  // Adds a TestProperty to the current TestResult object when invoked from\n  // inside a test, to current TestCase's ad_hoc_test_result_ when invoked\n  // from SetUpTestCase or TearDownTestCase, or to the global property set\n  // when invoked elsewhere.  If the result already contains a property with\n  // the same key, the value will be updated.\n  void RecordProperty(const std::string& key, const std::string& value);\n\n  // Gets the i-th test case among all the test cases. i can range from 0 to\n  // total_test_case_count() - 1. If i is not in that range, returns NULL.\n  TestCase* GetMutableTestCase(int i);\n\n  // Accessors for the implementation object.\n  internal::UnitTestImpl* impl() { return impl_; }\n  const internal::UnitTestImpl* impl() const { return impl_; }\n\n  // These classes and funcions are friends as they need to access private\n  // members of UnitTest.\n  friend class Test;\n  friend class internal::AssertHelper;\n  friend class internal::ScopedTrace;\n  friend class internal::StreamingListenerTest;\n  friend class internal::UnitTestRecordPropertyTestHelper;\n  friend Environment* AddGlobalTestEnvironment(Environment* env);\n  friend internal::UnitTestImpl* internal::GetUnitTestImpl();\n  friend void internal::ReportFailureInUnknownLocation(\n      TestPartResult::Type result_type,\n      const std::string& message);\n\n  // Creates an empty UnitTest.\n  UnitTest();\n\n  // D'tor\n  virtual ~UnitTest();\n\n  // Pushes a trace defined by SCOPED_TRACE() on to the per-thread\n  // Google Test trace stack.\n  void PushGTestTrace(const internal::TraceInfo& trace)\n      GTEST_LOCK_EXCLUDED_(mutex_);\n\n  // Pops a trace from the per-thread Google Test trace stack.\n  void PopGTestTrace()\n      GTEST_LOCK_EXCLUDED_(mutex_);\n\n  // Protects mutable state in *impl_.  This is mutable as some const\n  // methods need to lock it too.\n  mutable internal::Mutex mutex_;\n\n  // Opaque implementation object.  This field is never changed once\n  // the object is constructed.  We don't mark it as const here, as\n  // doing so will cause a warning in the constructor of UnitTest.\n  // Mutable state in *impl_ is protected by mutex_.\n  internal::UnitTestImpl* impl_;\n\n  // We disallow copying UnitTest.\n  GTEST_DISALLOW_COPY_AND_ASSIGN_(UnitTest);\n};\n\n// A convenient wrapper for adding an environment for the test\n// program.\n//\n// You should call this before RUN_ALL_TESTS() is called, probably in\n// main().  If you use gtest_main, you need to call this before main()\n// starts for it to take effect.  For example, you can define a global\n// variable like this:\n//\n//   testing::Environment* const foo_env =\n//       testing::AddGlobalTestEnvironment(new FooEnvironment);\n//\n// However, we strongly recommend you to write your own main() and\n// call AddGlobalTestEnvironment() there, as relying on initialization\n// of global variables makes the code harder to read and may cause\n// problems when you register multiple environments from different\n// translation units and the environments have dependencies among them\n// (remember that the compiler doesn't guarantee the order in which\n// global variables from different translation units are initialized).\ninline Environment* AddGlobalTestEnvironment(Environment* env) {\n  return UnitTest::GetInstance()->AddEnvironment(env);\n}\n\n// Initializes Google Test.  This must be called before calling\n// RUN_ALL_TESTS().  In particular, it parses a command line for the\n// flags that Google Test recognizes.  Whenever a Google Test flag is\n// seen, it is removed from argv, and *argc is decremented.\n//\n// No value is returned.  Instead, the Google Test flag variables are\n// updated.\n//\n// Calling the function for the second time has no user-visible effect.\nGTEST_API_ void InitGoogleTest(int* argc, char** argv);\n\n// This overloaded version can be used in Windows programs compiled in\n// UNICODE mode.\nGTEST_API_ void InitGoogleTest(int* argc, wchar_t** argv);\n\nnamespace internal {\n\n// Separate the error generating code from the code path to reduce the stack\n// frame size of CmpHelperEQ. This helps reduce the overhead of some sanitizers\n// when calling EXPECT_* in a tight loop.\ntemplate <typename T1, typename T2>\nAssertionResult CmpHelperEQFailure(const char* lhs_expression,\n                                   const char* rhs_expression,\n                                   const T1& lhs, const T2& rhs) {\n  return EqFailure(lhs_expression,\n                   rhs_expression,\n                   FormatForComparisonFailureMessage(lhs, rhs),\n                   FormatForComparisonFailureMessage(rhs, lhs),\n                   false);\n}\n\n// The helper function for {ASSERT|EXPECT}_EQ.\ntemplate <typename T1, typename T2>\nAssertionResult CmpHelperEQ(const char* lhs_expression,\n                            const char* rhs_expression,\n                            const T1& lhs,\n                            const T2& rhs) {\nGTEST_DISABLE_MSC_WARNINGS_PUSH_(4389 /* signed/unsigned mismatch */)\n  if (lhs == rhs) {\n    return AssertionSuccess();\n  }\nGTEST_DISABLE_MSC_WARNINGS_POP_()\n\n  return CmpHelperEQFailure(lhs_expression, rhs_expression, lhs, rhs);\n}\n\n// With this overloaded version, we allow anonymous enums to be used\n// in {ASSERT|EXPECT}_EQ when compiled with gcc 4, as anonymous enums\n// can be implicitly cast to BiggestInt.\nGTEST_API_ AssertionResult CmpHelperEQ(const char* lhs_expression,\n                                       const char* rhs_expression,\n                                       BiggestInt lhs,\n                                       BiggestInt rhs);\n\n// The helper class for {ASSERT|EXPECT}_EQ.  The template argument\n// lhs_is_null_literal is true iff the first argument to ASSERT_EQ()\n// is a null pointer literal.  The following default implementation is\n// for lhs_is_null_literal being false.\ntemplate <bool lhs_is_null_literal>\nclass EqHelper {\n public:\n  // This templatized version is for the general case.\n  template <typename T1, typename T2>\n  static AssertionResult Compare(const char* lhs_expression,\n                                 const char* rhs_expression,\n                                 const T1& lhs,\n                                 const T2& rhs) {\n    return CmpHelperEQ(lhs_expression, rhs_expression, lhs, rhs);\n  }\n\n  // With this overloaded version, we allow anonymous enums to be used\n  // in {ASSERT|EXPECT}_EQ when compiled with gcc 4, as anonymous\n  // enums can be implicitly cast to BiggestInt.\n  //\n  // Even though its body looks the same as the above version, we\n  // cannot merge the two, as it will make anonymous enums unhappy.\n  static AssertionResult Compare(const char* lhs_expression,\n                                 const char* rhs_expression,\n                                 BiggestInt lhs,\n                                 BiggestInt rhs) {\n    return CmpHelperEQ(lhs_expression, rhs_expression, lhs, rhs);\n  }\n};\n\n// This specialization is used when the first argument to ASSERT_EQ()\n// is a null pointer literal, like NULL, false, or 0.\ntemplate <>\nclass EqHelper<true> {\n public:\n  // We define two overloaded versions of Compare().  The first\n  // version will be picked when the second argument to ASSERT_EQ() is\n  // NOT a pointer, e.g. ASSERT_EQ(0, AnIntFunction()) or\n  // EXPECT_EQ(false, a_bool).\n  template <typename T1, typename T2>\n  static AssertionResult Compare(\n      const char* lhs_expression,\n      const char* rhs_expression,\n      const T1& lhs,\n      const T2& rhs,\n      // The following line prevents this overload from being considered if T2\n      // is not a pointer type.  We need this because ASSERT_EQ(NULL, my_ptr)\n      // expands to Compare(\"\", \"\", NULL, my_ptr), which requires a conversion\n      // to match the Secret* in the other overload, which would otherwise make\n      // this template match better.\n      typename EnableIf<!is_pointer<T2>::value>::type* = 0) {\n    return CmpHelperEQ(lhs_expression, rhs_expression, lhs, rhs);\n  }\n\n  // This version will be picked when the second argument to ASSERT_EQ() is a\n  // pointer, e.g. ASSERT_EQ(NULL, a_pointer).\n  template <typename T>\n  static AssertionResult Compare(\n      const char* lhs_expression,\n      const char* rhs_expression,\n      // We used to have a second template parameter instead of Secret*.  That\n      // template parameter would deduce to 'long', making this a better match\n      // than the first overload even without the first overload's EnableIf.\n      // Unfortunately, gcc with -Wconversion-null warns when \"passing NULL to\n      // non-pointer argument\" (even a deduced integral argument), so the old\n      // implementation caused warnings in user code.\n      Secret* /* lhs (NULL) */,\n      T* rhs) {\n    // We already know that 'lhs' is a null pointer.\n    return CmpHelperEQ(lhs_expression, rhs_expression,\n                       static_cast<T*>(NULL), rhs);\n  }\n};\n\n// Separate the error generating code from the code path to reduce the stack\n// frame size of CmpHelperOP. This helps reduce the overhead of some sanitizers\n// when calling EXPECT_OP in a tight loop.\ntemplate <typename T1, typename T2>\nAssertionResult CmpHelperOpFailure(const char* expr1, const char* expr2,\n                                   const T1& val1, const T2& val2,\n                                   const char* op) {\n  return AssertionFailure()\n         << \"Expected: (\" << expr1 << \") \" << op << \" (\" << expr2\n         << \"), actual: \" << FormatForComparisonFailureMessage(val1, val2)\n         << \" vs \" << FormatForComparisonFailureMessage(val2, val1);\n}\n\n// A macro for implementing the helper functions needed to implement\n// ASSERT_?? and EXPECT_??.  It is here just to avoid copy-and-paste\n// of similar code.\n//\n// For each templatized helper function, we also define an overloaded\n// version for BiggestInt in order to reduce code bloat and allow\n// anonymous enums to be used with {ASSERT|EXPECT}_?? when compiled\n// with gcc 4.\n//\n// INTERNAL IMPLEMENTATION - DO NOT USE IN A USER PROGRAM.\n\n#define GTEST_IMPL_CMP_HELPER_(op_name, op)\\\ntemplate <typename T1, typename T2>\\\nAssertionResult CmpHelper##op_name(const char* expr1, const char* expr2, \\\n                                   const T1& val1, const T2& val2) {\\\n  if (val1 op val2) {\\\n    return AssertionSuccess();\\\n  } else {\\\n    return CmpHelperOpFailure(expr1, expr2, val1, val2, #op);\\\n  }\\\n}\\\nGTEST_API_ AssertionResult CmpHelper##op_name(\\\n    const char* expr1, const char* expr2, BiggestInt val1, BiggestInt val2)\n\n// INTERNAL IMPLEMENTATION - DO NOT USE IN A USER PROGRAM.\n\n// Implements the helper function for {ASSERT|EXPECT}_NE\nGTEST_IMPL_CMP_HELPER_(NE, !=);\n// Implements the helper function for {ASSERT|EXPECT}_LE\nGTEST_IMPL_CMP_HELPER_(LE, <=);\n// Implements the helper function for {ASSERT|EXPECT}_LT\nGTEST_IMPL_CMP_HELPER_(LT, <);\n// Implements the helper function for {ASSERT|EXPECT}_GE\nGTEST_IMPL_CMP_HELPER_(GE, >=);\n// Implements the helper function for {ASSERT|EXPECT}_GT\nGTEST_IMPL_CMP_HELPER_(GT, >);\n\n#undef GTEST_IMPL_CMP_HELPER_\n\n// The helper function for {ASSERT|EXPECT}_STREQ.\n//\n// INTERNAL IMPLEMENTATION - DO NOT USE IN A USER PROGRAM.\nGTEST_API_ AssertionResult CmpHelperSTREQ(const char* s1_expression,\n                                          const char* s2_expression,\n                                          const char* s1,\n                                          const char* s2);\n\n// The helper function for {ASSERT|EXPECT}_STRCASEEQ.\n//\n// INTERNAL IMPLEMENTATION - DO NOT USE IN A USER PROGRAM.\nGTEST_API_ AssertionResult CmpHelperSTRCASEEQ(const char* s1_expression,\n                                              const char* s2_expression,\n                                              const char* s1,\n                                              const char* s2);\n\n// The helper function for {ASSERT|EXPECT}_STRNE.\n//\n// INTERNAL IMPLEMENTATION - DO NOT USE IN A USER PROGRAM.\nGTEST_API_ AssertionResult CmpHelperSTRNE(const char* s1_expression,\n                                          const char* s2_expression,\n                                          const char* s1,\n                                          const char* s2);\n\n// The helper function for {ASSERT|EXPECT}_STRCASENE.\n//\n// INTERNAL IMPLEMENTATION - DO NOT USE IN A USER PROGRAM.\nGTEST_API_ AssertionResult CmpHelperSTRCASENE(const char* s1_expression,\n                                              const char* s2_expression,\n                                              const char* s1,\n                                              const char* s2);\n\n\n// Helper function for *_STREQ on wide strings.\n//\n// INTERNAL IMPLEMENTATION - DO NOT USE IN A USER PROGRAM.\nGTEST_API_ AssertionResult CmpHelperSTREQ(const char* s1_expression,\n                                          const char* s2_expression,\n                                          const wchar_t* s1,\n                                          const wchar_t* s2);\n\n// Helper function for *_STRNE on wide strings.\n//\n// INTERNAL IMPLEMENTATION - DO NOT USE IN A USER PROGRAM.\nGTEST_API_ AssertionResult CmpHelperSTRNE(const char* s1_expression,\n                                          const char* s2_expression,\n                                          const wchar_t* s1,\n                                          const wchar_t* s2);\n\n}  // namespace internal\n\n// IsSubstring() and IsNotSubstring() are intended to be used as the\n// first argument to {EXPECT,ASSERT}_PRED_FORMAT2(), not by\n// themselves.  They check whether needle is a substring of haystack\n// (NULL is considered a substring of itself only), and return an\n// appropriate error message when they fail.\n//\n// The {needle,haystack}_expr arguments are the stringified\n// expressions that generated the two real arguments.\nGTEST_API_ AssertionResult IsSubstring(\n    const char* needle_expr, const char* haystack_expr,\n    const char* needle, const char* haystack);\nGTEST_API_ AssertionResult IsSubstring(\n    const char* needle_expr, const char* haystack_expr,\n    const wchar_t* needle, const wchar_t* haystack);\nGTEST_API_ AssertionResult IsNotSubstring(\n    const char* needle_expr, const char* haystack_expr,\n    const char* needle, const char* haystack);\nGTEST_API_ AssertionResult IsNotSubstring(\n    const char* needle_expr, const char* haystack_expr,\n    const wchar_t* needle, const wchar_t* haystack);\nGTEST_API_ AssertionResult IsSubstring(\n    const char* needle_expr, const char* haystack_expr,\n    const ::std::string& needle, const ::std::string& haystack);\nGTEST_API_ AssertionResult IsNotSubstring(\n    const char* needle_expr, const char* haystack_expr,\n    const ::std::string& needle, const ::std::string& haystack);\n\n#if GTEST_HAS_STD_WSTRING\nGTEST_API_ AssertionResult IsSubstring(\n    const char* needle_expr, const char* haystack_expr,\n    const ::std::wstring& needle, const ::std::wstring& haystack);\nGTEST_API_ AssertionResult IsNotSubstring(\n    const char* needle_expr, const char* haystack_expr,\n    const ::std::wstring& needle, const ::std::wstring& haystack);\n#endif  // GTEST_HAS_STD_WSTRING\n\nnamespace internal {\n\n// Helper template function for comparing floating-points.\n//\n// Template parameter:\n//\n//   RawType: the raw floating-point type (either float or double)\n//\n// INTERNAL IMPLEMENTATION - DO NOT USE IN A USER PROGRAM.\ntemplate <typename RawType>\nAssertionResult CmpHelperFloatingPointEQ(const char* lhs_expression,\n                                         const char* rhs_expression,\n                                         RawType lhs_value,\n                                         RawType rhs_value) {\n  const FloatingPoint<RawType> lhs(lhs_value), rhs(rhs_value);\n\n  if (lhs.AlmostEquals(rhs)) {\n    return AssertionSuccess();\n  }\n\n  ::std::stringstream lhs_ss;\n  lhs_ss << std::setprecision(std::numeric_limits<RawType>::digits10 + 2)\n         << lhs_value;\n\n  ::std::stringstream rhs_ss;\n  rhs_ss << std::setprecision(std::numeric_limits<RawType>::digits10 + 2)\n         << rhs_value;\n\n  return EqFailure(lhs_expression,\n                   rhs_expression,\n                   StringStreamToString(&lhs_ss),\n                   StringStreamToString(&rhs_ss),\n                   false);\n}\n\n// Helper function for implementing ASSERT_NEAR.\n//\n// INTERNAL IMPLEMENTATION - DO NOT USE IN A USER PROGRAM.\nGTEST_API_ AssertionResult DoubleNearPredFormat(const char* expr1,\n                                                const char* expr2,\n                                                const char* abs_error_expr,\n                                                double val1,\n                                                double val2,\n                                                double abs_error);\n\n// INTERNAL IMPLEMENTATION - DO NOT USE IN USER CODE.\n// A class that enables one to stream messages to assertion macros\nclass GTEST_API_ AssertHelper {\n public:\n  // Constructor.\n  AssertHelper(TestPartResult::Type type,\n               const char* file,\n               int line,\n               const char* message);\n  ~AssertHelper();\n\n  // Message assignment is a semantic trick to enable assertion\n  // streaming; see the GTEST_MESSAGE_ macro below.\n  void operator=(const Message& message) const;\n\n private:\n  // We put our data in a struct so that the size of the AssertHelper class can\n  // be as small as possible.  This is important because gcc is incapable of\n  // re-using stack space even for temporary variables, so every EXPECT_EQ\n  // reserves stack space for another AssertHelper.\n  struct AssertHelperData {\n    AssertHelperData(TestPartResult::Type t,\n                     const char* srcfile,\n                     int line_num,\n                     const char* msg)\n        : type(t), file(srcfile), line(line_num), message(msg) { }\n\n    TestPartResult::Type const type;\n    const char* const file;\n    int const line;\n    std::string const message;\n\n   private:\n    GTEST_DISALLOW_COPY_AND_ASSIGN_(AssertHelperData);\n  };\n\n  AssertHelperData* const data_;\n\n  GTEST_DISALLOW_COPY_AND_ASSIGN_(AssertHelper);\n};\n\n}  // namespace internal\n\n#if GTEST_HAS_PARAM_TEST\n// The pure interface class that all value-parameterized tests inherit from.\n// A value-parameterized class must inherit from both ::testing::Test and\n// ::testing::WithParamInterface. In most cases that just means inheriting\n// from ::testing::TestWithParam, but more complicated test hierarchies\n// may need to inherit from Test and WithParamInterface at different levels.\n//\n// This interface has support for accessing the test parameter value via\n// the GetParam() method.\n//\n// Use it with one of the parameter generator defining functions, like Range(),\n// Values(), ValuesIn(), Bool(), and Combine().\n//\n// class FooTest : public ::testing::TestWithParam<int> {\n//  protected:\n//   FooTest() {\n//     // Can use GetParam() here.\n//   }\n//   virtual ~FooTest() {\n//     // Can use GetParam() here.\n//   }\n//   virtual void SetUp() {\n//     // Can use GetParam() here.\n//   }\n//   virtual void TearDown {\n//     // Can use GetParam() here.\n//   }\n// };\n// TEST_P(FooTest, DoesBar) {\n//   // Can use GetParam() method here.\n//   Foo foo;\n//   ASSERT_TRUE(foo.DoesBar(GetParam()));\n// }\n// INSTANTIATE_TEST_CASE_P(OneToTenRange, FooTest, ::testing::Range(1, 10));\n\ntemplate <typename T>\nclass WithParamInterface {\n public:\n  typedef T ParamType;\n  virtual ~WithParamInterface() {}\n\n  // The current parameter value. Is also available in the test fixture's\n  // constructor. This member function is non-static, even though it only\n  // references static data, to reduce the opportunity for incorrect uses\n  // like writing 'WithParamInterface<bool>::GetParam()' for a test that\n  // uses a fixture whose parameter type is int.\n  const ParamType& GetParam() const {\n    GTEST_CHECK_(parameter_ != NULL)\n        << \"GetParam() can only be called inside a value-parameterized test \"\n        << \"-- did you intend to write TEST_P instead of TEST_F?\";\n    return *parameter_;\n  }\n\n private:\n  // Sets parameter value. The caller is responsible for making sure the value\n  // remains alive and unchanged throughout the current test.\n  static void SetParam(const ParamType* parameter) {\n    parameter_ = parameter;\n  }\n\n  // Static value used for accessing parameter during a test lifetime.\n  static const ParamType* parameter_;\n\n  // TestClass must be a subclass of WithParamInterface<T> and Test.\n  template <class TestClass> friend class internal::ParameterizedTestFactory;\n};\n\ntemplate <typename T>\nconst T* WithParamInterface<T>::parameter_ = NULL;\n\n// Most value-parameterized classes can ignore the existence of\n// WithParamInterface, and can just inherit from ::testing::TestWithParam.\n\ntemplate <typename T>\nclass TestWithParam : public Test, public WithParamInterface<T> {\n};\n\n#endif  // GTEST_HAS_PARAM_TEST\n\n// Macros for indicating success/failure in test code.\n\n// ADD_FAILURE unconditionally adds a failure to the current test.\n// SUCCEED generates a success - it doesn't automatically make the\n// current test successful, as a test is only successful when it has\n// no failure.\n//\n// EXPECT_* verifies that a certain condition is satisfied.  If not,\n// it behaves like ADD_FAILURE.  In particular:\n//\n//   EXPECT_TRUE  verifies that a Boolean condition is true.\n//   EXPECT_FALSE verifies that a Boolean condition is false.\n//\n// FAIL and ASSERT_* are similar to ADD_FAILURE and EXPECT_*, except\n// that they will also abort the current function on failure.  People\n// usually want the fail-fast behavior of FAIL and ASSERT_*, but those\n// writing data-driven tests often find themselves using ADD_FAILURE\n// and EXPECT_* more.\n\n// Generates a nonfatal failure with a generic message.\n#define ADD_FAILURE() GTEST_NONFATAL_FAILURE_(\"Failed\")\n\n// Generates a nonfatal failure at the given source file location with\n// a generic message.\n#define ADD_FAILURE_AT(file, line) \\\n  GTEST_MESSAGE_AT_(file, line, \"Failed\", \\\n                    ::testing::TestPartResult::kNonFatalFailure)\n\n// Generates a fatal failure with a generic message.\n#define GTEST_FAIL() GTEST_FATAL_FAILURE_(\"Failed\")\n\n// Define this macro to 1 to omit the definition of FAIL(), which is a\n// generic name and clashes with some other libraries.\n#if !GTEST_DONT_DEFINE_FAIL\n# define FAIL() GTEST_FAIL()\n#endif\n\n// Generates a success with a generic message.\n#define GTEST_SUCCEED() GTEST_SUCCESS_(\"Succeeded\")\n\n// Define this macro to 1 to omit the definition of SUCCEED(), which\n// is a generic name and clashes with some other libraries.\n#if !GTEST_DONT_DEFINE_SUCCEED\n# define SUCCEED() GTEST_SUCCEED()\n#endif\n\n// Macros for testing exceptions.\n//\n//    * {ASSERT|EXPECT}_THROW(statement, expected_exception):\n//         Tests that the statement throws the expected exception.\n//    * {ASSERT|EXPECT}_NO_THROW(statement):\n//         Tests that the statement doesn't throw any exception.\n//    * {ASSERT|EXPECT}_ANY_THROW(statement):\n//         Tests that the statement throws an exception.\n\n#define EXPECT_THROW(statement, expected_exception) \\\n  GTEST_TEST_THROW_(statement, expected_exception, GTEST_NONFATAL_FAILURE_)\n#define EXPECT_NO_THROW(statement) \\\n  GTEST_TEST_NO_THROW_(statement, GTEST_NONFATAL_FAILURE_)\n#define EXPECT_ANY_THROW(statement) \\\n  GTEST_TEST_ANY_THROW_(statement, GTEST_NONFATAL_FAILURE_)\n#define ASSERT_THROW(statement, expected_exception) \\\n  GTEST_TEST_THROW_(statement, expected_exception, GTEST_FATAL_FAILURE_)\n#define ASSERT_NO_THROW(statement) \\\n  GTEST_TEST_NO_THROW_(statement, GTEST_FATAL_FAILURE_)\n#define ASSERT_ANY_THROW(statement) \\\n  GTEST_TEST_ANY_THROW_(statement, GTEST_FATAL_FAILURE_)\n\n// Boolean assertions. Condition can be either a Boolean expression or an\n// AssertionResult. For more information on how to use AssertionResult with\n// these macros see comments on that class.\n#define EXPECT_TRUE(condition) \\\n  GTEST_TEST_BOOLEAN_((condition), #condition, false, true, \\\n                      GTEST_NONFATAL_FAILURE_)\n#define EXPECT_FALSE(condition) \\\n  GTEST_TEST_BOOLEAN_(!(condition), #condition, true, false, \\\n                      GTEST_NONFATAL_FAILURE_)\n#define ASSERT_TRUE(condition) \\\n  GTEST_TEST_BOOLEAN_((condition), #condition, false, true, \\\n                      GTEST_FATAL_FAILURE_)\n#define ASSERT_FALSE(condition) \\\n  GTEST_TEST_BOOLEAN_(!(condition), #condition, true, false, \\\n                      GTEST_FATAL_FAILURE_)\n\n// Includes the auto-generated header that implements a family of\n// generic predicate assertion macros.\n#include \"gtest/gtest_pred_impl.h\"\n\n// Macros for testing equalities and inequalities.\n//\n//    * {ASSERT|EXPECT}_EQ(v1, v2): Tests that v1 == v2\n//    * {ASSERT|EXPECT}_NE(v1, v2): Tests that v1 != v2\n//    * {ASSERT|EXPECT}_LT(v1, v2): Tests that v1 < v2\n//    * {ASSERT|EXPECT}_LE(v1, v2): Tests that v1 <= v2\n//    * {ASSERT|EXPECT}_GT(v1, v2): Tests that v1 > v2\n//    * {ASSERT|EXPECT}_GE(v1, v2): Tests that v1 >= v2\n//\n// When they are not, Google Test prints both the tested expressions and\n// their actual values.  The values must be compatible built-in types,\n// or you will get a compiler error.  By \"compatible\" we mean that the\n// values can be compared by the respective operator.\n//\n// Note:\n//\n//   1. It is possible to make a user-defined type work with\n//   {ASSERT|EXPECT}_??(), but that requires overloading the\n//   comparison operators and is thus discouraged by the Google C++\n//   Usage Guide.  Therefore, you are advised to use the\n//   {ASSERT|EXPECT}_TRUE() macro to assert that two objects are\n//   equal.\n//\n//   2. The {ASSERT|EXPECT}_??() macros do pointer comparisons on\n//   pointers (in particular, C strings).  Therefore, if you use it\n//   with two C strings, you are testing how their locations in memory\n//   are related, not how their content is related.  To compare two C\n//   strings by content, use {ASSERT|EXPECT}_STR*().\n//\n//   3. {ASSERT|EXPECT}_EQ(v1, v2) is preferred to\n//   {ASSERT|EXPECT}_TRUE(v1 == v2), as the former tells you\n//   what the actual value is when it fails, and similarly for the\n//   other comparisons.\n//\n//   4. Do not depend on the order in which {ASSERT|EXPECT}_??()\n//   evaluate their arguments, which is undefined.\n//\n//   5. These macros evaluate their arguments exactly once.\n//\n// Examples:\n//\n//   EXPECT_NE(5, Foo());\n//   EXPECT_EQ(NULL, a_pointer);\n//   ASSERT_LT(i, array_size);\n//   ASSERT_GT(records.size(), 0) << \"There is no record left.\";\n\n#define EXPECT_EQ(val1, val2) \\\n  EXPECT_PRED_FORMAT2(::testing::internal:: \\\n                      EqHelper<GTEST_IS_NULL_LITERAL_(val1)>::Compare, \\\n                      val1, val2)\n#define EXPECT_NE(val1, val2) \\\n  EXPECT_PRED_FORMAT2(::testing::internal::CmpHelperNE, val1, val2)\n#define EXPECT_LE(val1, val2) \\\n  EXPECT_PRED_FORMAT2(::testing::internal::CmpHelperLE, val1, val2)\n#define EXPECT_LT(val1, val2) \\\n  EXPECT_PRED_FORMAT2(::testing::internal::CmpHelperLT, val1, val2)\n#define EXPECT_GE(val1, val2) \\\n  EXPECT_PRED_FORMAT2(::testing::internal::CmpHelperGE, val1, val2)\n#define EXPECT_GT(val1, val2) \\\n  EXPECT_PRED_FORMAT2(::testing::internal::CmpHelperGT, val1, val2)\n\n#define GTEST_ASSERT_EQ(val1, val2) \\\n  ASSERT_PRED_FORMAT2(::testing::internal:: \\\n                      EqHelper<GTEST_IS_NULL_LITERAL_(val1)>::Compare, \\\n                      val1, val2)\n#define GTEST_ASSERT_NE(val1, val2) \\\n  ASSERT_PRED_FORMAT2(::testing::internal::CmpHelperNE, val1, val2)\n#define GTEST_ASSERT_LE(val1, val2) \\\n  ASSERT_PRED_FORMAT2(::testing::internal::CmpHelperLE, val1, val2)\n#define GTEST_ASSERT_LT(val1, val2) \\\n  ASSERT_PRED_FORMAT2(::testing::internal::CmpHelperLT, val1, val2)\n#define GTEST_ASSERT_GE(val1, val2) \\\n  ASSERT_PRED_FORMAT2(::testing::internal::CmpHelperGE, val1, val2)\n#define GTEST_ASSERT_GT(val1, val2) \\\n  ASSERT_PRED_FORMAT2(::testing::internal::CmpHelperGT, val1, val2)\n\n// Define macro GTEST_DONT_DEFINE_ASSERT_XY to 1 to omit the definition of\n// ASSERT_XY(), which clashes with some users' own code.\n\n#if !GTEST_DONT_DEFINE_ASSERT_EQ\n# define ASSERT_EQ(val1, val2) GTEST_ASSERT_EQ(val1, val2)\n#endif\n\n#if !GTEST_DONT_DEFINE_ASSERT_NE\n# define ASSERT_NE(val1, val2) GTEST_ASSERT_NE(val1, val2)\n#endif\n\n#if !GTEST_DONT_DEFINE_ASSERT_LE\n# define ASSERT_LE(val1, val2) GTEST_ASSERT_LE(val1, val2)\n#endif\n\n#if !GTEST_DONT_DEFINE_ASSERT_LT\n# define ASSERT_LT(val1, val2) GTEST_ASSERT_LT(val1, val2)\n#endif\n\n#if !GTEST_DONT_DEFINE_ASSERT_GE\n# define ASSERT_GE(val1, val2) GTEST_ASSERT_GE(val1, val2)\n#endif\n\n#if !GTEST_DONT_DEFINE_ASSERT_GT\n# define ASSERT_GT(val1, val2) GTEST_ASSERT_GT(val1, val2)\n#endif\n\n// C-string Comparisons.  All tests treat NULL and any non-NULL string\n// as different.  Two NULLs are equal.\n//\n//    * {ASSERT|EXPECT}_STREQ(s1, s2):     Tests that s1 == s2\n//    * {ASSERT|EXPECT}_STRNE(s1, s2):     Tests that s1 != s2\n//    * {ASSERT|EXPECT}_STRCASEEQ(s1, s2): Tests that s1 == s2, ignoring case\n//    * {ASSERT|EXPECT}_STRCASENE(s1, s2): Tests that s1 != s2, ignoring case\n//\n// For wide or narrow string objects, you can use the\n// {ASSERT|EXPECT}_??() macros.\n//\n// Don't depend on the order in which the arguments are evaluated,\n// which is undefined.\n//\n// These macros evaluate their arguments exactly once.\n\n#define EXPECT_STREQ(s1, s2) \\\n  EXPECT_PRED_FORMAT2(::testing::internal::CmpHelperSTREQ, s1, s2)\n#define EXPECT_STRNE(s1, s2) \\\n  EXPECT_PRED_FORMAT2(::testing::internal::CmpHelperSTRNE, s1, s2)\n#define EXPECT_STRCASEEQ(s1, s2) \\\n  EXPECT_PRED_FORMAT2(::testing::internal::CmpHelperSTRCASEEQ, s1, s2)\n#define EXPECT_STRCASENE(s1, s2)\\\n  EXPECT_PRED_FORMAT2(::testing::internal::CmpHelperSTRCASENE, s1, s2)\n\n#define ASSERT_STREQ(s1, s2) \\\n  ASSERT_PRED_FORMAT2(::testing::internal::CmpHelperSTREQ, s1, s2)\n#define ASSERT_STRNE(s1, s2) \\\n  ASSERT_PRED_FORMAT2(::testing::internal::CmpHelperSTRNE, s1, s2)\n#define ASSERT_STRCASEEQ(s1, s2) \\\n  ASSERT_PRED_FORMAT2(::testing::internal::CmpHelperSTRCASEEQ, s1, s2)\n#define ASSERT_STRCASENE(s1, s2)\\\n  ASSERT_PRED_FORMAT2(::testing::internal::CmpHelperSTRCASENE, s1, s2)\n\n// Macros for comparing floating-point numbers.\n//\n//    * {ASSERT|EXPECT}_FLOAT_EQ(val1, val2):\n//         Tests that two float values are almost equal.\n//    * {ASSERT|EXPECT}_DOUBLE_EQ(val1, val2):\n//         Tests that two double values are almost equal.\n//    * {ASSERT|EXPECT}_NEAR(v1, v2, abs_error):\n//         Tests that v1 and v2 are within the given distance to each other.\n//\n// Google Test uses ULP-based comparison to automatically pick a default\n// error bound that is appropriate for the operands.  See the\n// FloatingPoint template class in gtest-internal.h if you are\n// interested in the implementation details.\n\n#define EXPECT_FLOAT_EQ(val1, val2)\\\n  EXPECT_PRED_FORMAT2(::testing::internal::CmpHelperFloatingPointEQ<float>, \\\n                      val1, val2)\n\n#define EXPECT_DOUBLE_EQ(val1, val2)\\\n  EXPECT_PRED_FORMAT2(::testing::internal::CmpHelperFloatingPointEQ<double>, \\\n                      val1, val2)\n\n#define ASSERT_FLOAT_EQ(val1, val2)\\\n  ASSERT_PRED_FORMAT2(::testing::internal::CmpHelperFloatingPointEQ<float>, \\\n                      val1, val2)\n\n#define ASSERT_DOUBLE_EQ(val1, val2)\\\n  ASSERT_PRED_FORMAT2(::testing::internal::CmpHelperFloatingPointEQ<double>, \\\n                      val1, val2)\n\n#define EXPECT_NEAR(val1, val2, abs_error)\\\n  EXPECT_PRED_FORMAT3(::testing::internal::DoubleNearPredFormat, \\\n                      val1, val2, abs_error)\n\n#define ASSERT_NEAR(val1, val2, abs_error)\\\n  ASSERT_PRED_FORMAT3(::testing::internal::DoubleNearPredFormat, \\\n                      val1, val2, abs_error)\n\n// These predicate format functions work on floating-point values, and\n// can be used in {ASSERT|EXPECT}_PRED_FORMAT2*(), e.g.\n//\n//   EXPECT_PRED_FORMAT2(testing::DoubleLE, Foo(), 5.0);\n\n// Asserts that val1 is less than, or almost equal to, val2.  Fails\n// otherwise.  In particular, it fails if either val1 or val2 is NaN.\nGTEST_API_ AssertionResult FloatLE(const char* expr1, const char* expr2,\n                                   float val1, float val2);\nGTEST_API_ AssertionResult DoubleLE(const char* expr1, const char* expr2,\n                                    double val1, double val2);\n\n\n#if GTEST_OS_WINDOWS\n\n// Macros that test for HRESULT failure and success, these are only useful\n// on Windows, and rely on Windows SDK macros and APIs to compile.\n//\n//    * {ASSERT|EXPECT}_HRESULT_{SUCCEEDED|FAILED}(expr)\n//\n// When expr unexpectedly fails or succeeds, Google Test prints the\n// expected result and the actual result with both a human-readable\n// string representation of the error, if available, as well as the\n// hex result code.\n# define EXPECT_HRESULT_SUCCEEDED(expr) \\\n    EXPECT_PRED_FORMAT1(::testing::internal::IsHRESULTSuccess, (expr))\n\n# define ASSERT_HRESULT_SUCCEEDED(expr) \\\n    ASSERT_PRED_FORMAT1(::testing::internal::IsHRESULTSuccess, (expr))\n\n# define EXPECT_HRESULT_FAILED(expr) \\\n    EXPECT_PRED_FORMAT1(::testing::internal::IsHRESULTFailure, (expr))\n\n# define ASSERT_HRESULT_FAILED(expr) \\\n    ASSERT_PRED_FORMAT1(::testing::internal::IsHRESULTFailure, (expr))\n\n#endif  // GTEST_OS_WINDOWS\n\n// Macros that execute statement and check that it doesn't generate new fatal\n// failures in the current thread.\n//\n//   * {ASSERT|EXPECT}_NO_FATAL_FAILURE(statement);\n//\n// Examples:\n//\n//   EXPECT_NO_FATAL_FAILURE(Process());\n//   ASSERT_NO_FATAL_FAILURE(Process()) << \"Process() failed\";\n//\n#define ASSERT_NO_FATAL_FAILURE(statement) \\\n    GTEST_TEST_NO_FATAL_FAILURE_(statement, GTEST_FATAL_FAILURE_)\n#define EXPECT_NO_FATAL_FAILURE(statement) \\\n    GTEST_TEST_NO_FATAL_FAILURE_(statement, GTEST_NONFATAL_FAILURE_)\n\n// Causes a trace (including the source file path, the current line\n// number, and the given message) to be included in every test failure\n// message generated by code in the current scope.  The effect is\n// undone when the control leaves the current scope.\n//\n// The message argument can be anything streamable to std::ostream.\n//\n// In the implementation, we include the current line number as part\n// of the dummy variable name, thus allowing multiple SCOPED_TRACE()s\n// to appear in the same block - as long as they are on different\n// lines.\n#define SCOPED_TRACE(message) \\\n  ::testing::internal::ScopedTrace GTEST_CONCAT_TOKEN_(gtest_trace_, __LINE__)(\\\n    __FILE__, __LINE__, ::testing::Message() << (message))\n\n// Compile-time assertion for type equality.\n// StaticAssertTypeEq<type1, type2>() compiles iff type1 and type2 are\n// the same type.  The value it returns is not interesting.\n//\n// Instead of making StaticAssertTypeEq a class template, we make it a\n// function template that invokes a helper class template.  This\n// prevents a user from misusing StaticAssertTypeEq<T1, T2> by\n// defining objects of that type.\n//\n// CAVEAT:\n//\n// When used inside a method of a class template,\n// StaticAssertTypeEq<T1, T2>() is effective ONLY IF the method is\n// instantiated.  For example, given:\n//\n//   template <typename T> class Foo {\n//    public:\n//     void Bar() { testing::StaticAssertTypeEq<int, T>(); }\n//   };\n//\n// the code:\n//\n//   void Test1() { Foo<bool> foo; }\n//\n// will NOT generate a compiler error, as Foo<bool>::Bar() is never\n// actually instantiated.  Instead, you need:\n//\n//   void Test2() { Foo<bool> foo; foo.Bar(); }\n//\n// to cause a compiler error.\ntemplate <typename T1, typename T2>\nbool StaticAssertTypeEq() {\n  (void)internal::StaticAssertTypeEqHelper<T1, T2>();\n  return true;\n}\n\n// Defines a test.\n//\n// The first parameter is the name of the test case, and the second\n// parameter is the name of the test within the test case.\n//\n// The convention is to end the test case name with \"Test\".  For\n// example, a test case for the Foo class can be named FooTest.\n//\n// Test code should appear between braces after an invocation of\n// this macro.  Example:\n//\n//   TEST(FooTest, InitializesCorrectly) {\n//     Foo foo;\n//     EXPECT_TRUE(foo.StatusIsOK());\n//   }\n\n// Note that we call GetTestTypeId() instead of GetTypeId<\n// ::testing::Test>() here to get the type ID of testing::Test.  This\n// is to work around a suspected linker bug when using Google Test as\n// a framework on Mac OS X.  The bug causes GetTypeId<\n// ::testing::Test>() to return different values depending on whether\n// the call is from the Google Test framework itself or from user test\n// code.  GetTestTypeId() is guaranteed to always return the same\n// value, as it always calls GetTypeId<>() from the Google Test\n// framework.\n#define GTEST_TEST(test_case_name, test_name)\\\n  GTEST_TEST_(test_case_name, test_name, \\\n              ::testing::Test, ::testing::internal::GetTestTypeId())\n\n// Define this macro to 1 to omit the definition of TEST(), which\n// is a generic name and clashes with some other libraries.\n#if !GTEST_DONT_DEFINE_TEST\n# define TEST(test_case_name, test_name) GTEST_TEST(test_case_name, test_name)\n#endif\n\n// Defines a test that uses a test fixture.\n//\n// The first parameter is the name of the test fixture class, which\n// also doubles as the test case name.  The second parameter is the\n// name of the test within the test case.\n//\n// A test fixture class must be declared earlier.  The user should put\n// his test code between braces after using this macro.  Example:\n//\n//   class FooTest : public testing::Test {\n//    protected:\n//     virtual void SetUp() { b_.AddElement(3); }\n//\n//     Foo a_;\n//     Foo b_;\n//   };\n//\n//   TEST_F(FooTest, InitializesCorrectly) {\n//     EXPECT_TRUE(a_.StatusIsOK());\n//   }\n//\n//   TEST_F(FooTest, ReturnsElementCountCorrectly) {\n//     EXPECT_EQ(0, a_.size());\n//     EXPECT_EQ(1, b_.size());\n//   }\n\n#define TEST_F(test_fixture, test_name)\\\n  GTEST_TEST_(test_fixture, test_name, test_fixture, \\\n              ::testing::internal::GetTypeId<test_fixture>())\n\n}  // namespace testing\n\n// Use this function in main() to run all tests.  It returns 0 if all\n// tests are successful, or 1 otherwise.\n//\n// RUN_ALL_TESTS() should be invoked after the command line has been\n// parsed by InitGoogleTest().\n//\n// This function was formerly a macro; thus, it is in the global\n// namespace and has an all-caps name.\nint RUN_ALL_TESTS() GTEST_MUST_USE_RESULT_;\n\ninline int RUN_ALL_TESTS() {\n  return ::testing::UnitTest::GetInstance()->Run();\n}\n\n#endif  // GTEST_INCLUDE_GTEST_GTEST_H_\n"}, "25": {"id": 25, "path": "/home/vsts/work/1/llvm-project/llvm/utils/unittest/googletest/include/gtest/internal/gtest-internal.h", "content": "// Copyright 2005, Google Inc.\n// All rights reserved.\n//\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions are\n// met:\n//\n//     * Redistributions of source code must retain the above copyright\n// notice, this list of conditions and the following disclaimer.\n//     * Redistributions in binary form must reproduce the above\n// copyright notice, this list of conditions and the following disclaimer\n// in the documentation and/or other materials provided with the\n// distribution.\n//     * Neither the name of Google Inc. nor the names of its\n// contributors may be used to endorse or promote products derived from\n// this software without specific prior written permission.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n// \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n//\n// Authors: wan@google.com (Zhanyong Wan), eefacm@gmail.com (Sean Mcafee)\n//\n// The Google C++ Testing Framework (Google Test)\n//\n// This header file declares functions and macros used internally by\n// Google Test.  They are subject to change without notice.\n\n#ifndef GTEST_INCLUDE_GTEST_INTERNAL_GTEST_INTERNAL_H_\n#define GTEST_INCLUDE_GTEST_INTERNAL_GTEST_INTERNAL_H_\n\n#include \"gtest/internal/gtest-port.h\"\n\n#if GTEST_OS_LINUX\n# include <stdlib.h>\n# include <sys/types.h>\n# include <sys/wait.h>\n# include <unistd.h>\n#endif  // GTEST_OS_LINUX\n\n#if GTEST_HAS_EXCEPTIONS\n# include <stdexcept>\n#endif\n\n#include <ctype.h>\n#include <float.h>\n#include <string.h>\n#include <iomanip>\n#include <limits>\n#include <map>\n#include <set>\n#include <string>\n#include <vector>\n\n#include \"gtest/gtest-message.h\"\n#include \"gtest/internal/gtest-string.h\"\n#include \"gtest/internal/gtest-filepath.h\"\n#include \"gtest/internal/gtest-type-util.h\"\n\n// Due to C++ preprocessor weirdness, we need double indirection to\n// concatenate two tokens when one of them is __LINE__.  Writing\n//\n//   foo ## __LINE__\n//\n// will result in the token foo__LINE__, instead of foo followed by\n// the current line number.  For more details, see\n// http://www.parashift.com/c++-faq-lite/misc-technical-issues.html#faq-39.6\n#define GTEST_CONCAT_TOKEN_(foo, bar) GTEST_CONCAT_TOKEN_IMPL_(foo, bar)\n#define GTEST_CONCAT_TOKEN_IMPL_(foo, bar) foo ## bar\n\nclass ProtocolMessage;\nnamespace proto2 { class Message; }\n\nnamespace testing {\n\n// Forward declarations.\n\nclass AssertionResult;                 // Result of an assertion.\nclass Message;                         // Represents a failure message.\nclass Test;                            // Represents a test.\nclass TestInfo;                        // Information about a test.\nclass TestPartResult;                  // Result of a test part.\nclass UnitTest;                        // A collection of test cases.\n\ntemplate <typename T>\n::std::string PrintToString(const T& value);\n\nnamespace internal {\n\nstruct TraceInfo;                      // Information about a trace point.\nclass ScopedTrace;                     // Implements scoped trace.\nclass TestInfoImpl;                    // Opaque implementation of TestInfo\nclass UnitTestImpl;                    // Opaque implementation of UnitTest\n\n// The text used in failure messages to indicate the start of the\n// stack trace.\nGTEST_API_ extern const char kStackTraceMarker[];\n\n// Two overloaded helpers for checking at compile time whether an\n// expression is a null pointer literal (i.e. NULL or any 0-valued\n// compile-time integral constant).  Their return values have\n// different sizes, so we can use sizeof() to test which version is\n// picked by the compiler.  These helpers have no implementations, as\n// we only need their signatures.\n//\n// Given IsNullLiteralHelper(x), the compiler will pick the first\n// version if x can be implicitly converted to Secret*, and pick the\n// second version otherwise.  Since Secret is a secret and incomplete\n// type, the only expression a user can write that has type Secret* is\n// a null pointer literal.  Therefore, we know that x is a null\n// pointer literal if and only if the first version is picked by the\n// compiler.\nchar IsNullLiteralHelper(Secret* p);\nchar (&IsNullLiteralHelper(...))[2];  // NOLINT\n\n// A compile-time bool constant that is true if and only if x is a\n// null pointer literal (i.e. NULL or any 0-valued compile-time\n// integral constant).\n#ifdef GTEST_ELLIPSIS_NEEDS_POD_\n// We lose support for NULL detection where the compiler doesn't like\n// passing non-POD classes through ellipsis (...).\n# define GTEST_IS_NULL_LITERAL_(x) false\n#else\n# define GTEST_IS_NULL_LITERAL_(x) \\\n    (sizeof(::testing::internal::IsNullLiteralHelper(x)) == 1)\n#endif  // GTEST_ELLIPSIS_NEEDS_POD_\n\n// Appends the user-supplied message to the Google-Test-generated message.\nGTEST_API_ std::string AppendUserMessage(\n    const std::string& gtest_msg, const Message& user_msg);\n\n#if GTEST_HAS_EXCEPTIONS\n\n// This exception is thrown by (and only by) a failed Google Test\n// assertion when GTEST_FLAG(throw_on_failure) is true (if exceptions\n// are enabled).  We derive it from std::runtime_error, which is for\n// errors presumably detectable only at run time.  Since\n// std::runtime_error inherits from std::exception, many testing\n// frameworks know how to extract and print the message inside it.\nclass GTEST_API_ GoogleTestFailureException : public ::std::runtime_error {\n public:\n  explicit GoogleTestFailureException(const TestPartResult& failure);\n};\n\n#endif  // GTEST_HAS_EXCEPTIONS\n\n// A helper class for creating scoped traces in user programs.\nclass GTEST_API_ ScopedTrace {\n public:\n  // The c'tor pushes the given source file location and message onto\n  // a trace stack maintained by Google Test.\n  ScopedTrace(const char* file, int line, const Message& message);\n\n  // The d'tor pops the info pushed by the c'tor.\n  //\n  // Note that the d'tor is not virtual in order to be efficient.\n  // Don't inherit from ScopedTrace!\n  ~ScopedTrace();\n\n private:\n  GTEST_DISALLOW_COPY_AND_ASSIGN_(ScopedTrace);\n} GTEST_ATTRIBUTE_UNUSED_;  // A ScopedTrace object does its job in its\n                            // c'tor and d'tor.  Therefore it doesn't\n                            // need to be used otherwise.\n\nnamespace edit_distance {\n// Returns the optimal edits to go from 'left' to 'right'.\n// All edits cost the same, with replace having lower priority than\n// add/remove.\n// Simple implementation of the Wagner\u2013Fischer algorithm.\n// See http://en.wikipedia.org/wiki/Wagner-Fischer_algorithm\nenum EditType { kMatch, kAdd, kRemove, kReplace };\nGTEST_API_ std::vector<EditType> CalculateOptimalEdits(\n    const std::vector<size_t>& left, const std::vector<size_t>& right);\n\n// Same as above, but the input is represented as strings.\nGTEST_API_ std::vector<EditType> CalculateOptimalEdits(\n    const std::vector<std::string>& left,\n    const std::vector<std::string>& right);\n\n// Create a diff of the input strings in Unified diff format.\nGTEST_API_ std::string CreateUnifiedDiff(const std::vector<std::string>& left,\n                                         const std::vector<std::string>& right,\n                                         size_t context = 2);\n\n}  // namespace edit_distance\n\n// Calculate the diff between 'left' and 'right' and return it in unified diff\n// format.\n// If not null, stores in 'total_line_count' the total number of lines found\n// in left + right.\nGTEST_API_ std::string DiffStrings(const std::string& left,\n                                   const std::string& right,\n                                   size_t* total_line_count);\n\n// Constructs and returns the message for an equality assertion\n// (e.g. ASSERT_EQ, EXPECT_STREQ, etc) failure.\n//\n// The first four parameters are the expressions used in the assertion\n// and their values, as strings.  For example, for ASSERT_EQ(foo, bar)\n// where foo is 5 and bar is 6, we have:\n//\n//   expected_expression: \"foo\"\n//   actual_expression:   \"bar\"\n//   expected_value:      \"5\"\n//   actual_value:        \"6\"\n//\n// The ignoring_case parameter is true iff the assertion is a\n// *_STRCASEEQ*.  When it's true, the string \" (ignoring case)\" will\n// be inserted into the message.\nGTEST_API_ AssertionResult EqFailure(const char* expected_expression,\n                                     const char* actual_expression,\n                                     const std::string& expected_value,\n                                     const std::string& actual_value,\n                                     bool ignoring_case);\n\n// Constructs a failure message for Boolean assertions such as EXPECT_TRUE.\nGTEST_API_ std::string GetBoolAssertionFailureMessage(\n    const AssertionResult& assertion_result,\n    const char* expression_text,\n    const char* actual_predicate_value,\n    const char* expected_predicate_value);\n\n// This template class represents an IEEE floating-point number\n// (either single-precision or double-precision, depending on the\n// template parameters).\n//\n// The purpose of this class is to do more sophisticated number\n// comparison.  (Due to round-off error, etc, it's very unlikely that\n// two floating-points will be equal exactly.  Hence a naive\n// comparison by the == operation often doesn't work.)\n//\n// Format of IEEE floating-point:\n//\n//   The most-significant bit being the leftmost, an IEEE\n//   floating-point looks like\n//\n//     sign_bit exponent_bits fraction_bits\n//\n//   Here, sign_bit is a single bit that designates the sign of the\n//   number.\n//\n//   For float, there are 8 exponent bits and 23 fraction bits.\n//\n//   For double, there are 11 exponent bits and 52 fraction bits.\n//\n//   More details can be found at\n//   http://en.wikipedia.org/wiki/IEEE_floating-point_standard.\n//\n// Template parameter:\n//\n//   RawType: the raw floating-point type (either float or double)\ntemplate <typename RawType>\nclass FloatingPoint {\n public:\n  // Defines the unsigned integer type that has the same size as the\n  // floating point number.\n  typedef typename TypeWithSize<sizeof(RawType)>::UInt Bits;\n\n  // Constants.\n\n  // # of bits in a number.\n  static const size_t kBitCount = 8*sizeof(RawType);\n\n  // # of fraction bits in a number.\n  static const size_t kFractionBitCount =\n    std::numeric_limits<RawType>::digits - 1;\n\n  // # of exponent bits in a number.\n  static const size_t kExponentBitCount = kBitCount - 1 - kFractionBitCount;\n\n  // The mask for the sign bit.\n  static const Bits kSignBitMask = static_cast<Bits>(1) << (kBitCount - 1);\n\n  // The mask for the fraction bits.\n  static const Bits kFractionBitMask =\n    ~static_cast<Bits>(0) >> (kExponentBitCount + 1);\n\n  // The mask for the exponent bits.\n  static const Bits kExponentBitMask = ~(kSignBitMask | kFractionBitMask);\n\n  // How many ULP's (Units in the Last Place) we want to tolerate when\n  // comparing two numbers.  The larger the value, the more error we\n  // allow.  A 0 value means that two numbers must be exactly the same\n  // to be considered equal.\n  //\n  // The maximum error of a single floating-point operation is 0.5\n  // units in the last place.  On Intel CPU's, all floating-point\n  // calculations are done with 80-bit precision, while double has 64\n  // bits.  Therefore, 4 should be enough for ordinary use.\n  //\n  // See the following article for more details on ULP:\n  // http://randomascii.wordpress.com/2012/02/25/comparing-floating-point-numbers-2012-edition/\n  static const size_t kMaxUlps = 4;\n\n  // Constructs a FloatingPoint from a raw floating-point number.\n  //\n  // On an Intel CPU, passing a non-normalized NAN (Not a Number)\n  // around may change its bits, although the new value is guaranteed\n  // to be also a NAN.  Therefore, don't expect this constructor to\n  // preserve the bits in x when x is a NAN.\n  explicit FloatingPoint(const RawType& x) { u_.value_ = x; }\n\n  // Static methods\n\n  // Reinterprets a bit pattern as a floating-point number.\n  //\n  // This function is needed to test the AlmostEquals() method.\n  static RawType ReinterpretBits(const Bits bits) {\n    FloatingPoint fp(0);\n    fp.u_.bits_ = bits;\n    return fp.u_.value_;\n  }\n\n  // Returns the floating-point number that represent positive infinity.\n  static RawType Infinity() {\n    return ReinterpretBits(kExponentBitMask);\n  }\n\n  // Returns the maximum representable finite floating-point number.\n  static RawType Max();\n\n  // Non-static methods\n\n  // Returns the bits that represents this number.\n  const Bits &bits() const { return u_.bits_; }\n\n  // Returns the exponent bits of this number.\n  Bits exponent_bits() const { return kExponentBitMask & u_.bits_; }\n\n  // Returns the fraction bits of this number.\n  Bits fraction_bits() const { return kFractionBitMask & u_.bits_; }\n\n  // Returns the sign bit of this number.\n  Bits sign_bit() const { return kSignBitMask & u_.bits_; }\n\n  // Returns true iff this is NAN (not a number).\n  bool is_nan() const {\n    // It's a NAN if the exponent bits are all ones and the fraction\n    // bits are not entirely zeros.\n    return (exponent_bits() == kExponentBitMask) && (fraction_bits() != 0);\n  }\n\n  // Returns true iff this number is at most kMaxUlps ULP's away from\n  // rhs.  In particular, this function:\n  //\n  //   - returns false if either number is (or both are) NAN.\n  //   - treats really large numbers as almost equal to infinity.\n  //   - thinks +0.0 and -0.0 are 0 DLP's apart.\n  bool AlmostEquals(const FloatingPoint& rhs) const {\n    // The IEEE standard says that any comparison operation involving\n    // a NAN must return false.\n    if (is_nan() || rhs.is_nan()) return false;\n\n    return DistanceBetweenSignAndMagnitudeNumbers(u_.bits_, rhs.u_.bits_)\n        <= kMaxUlps;\n  }\n\n private:\n  // The data type used to store the actual floating-point number.\n  union FloatingPointUnion {\n    RawType value_;  // The raw floating-point number.\n    Bits bits_;      // The bits that represent the number.\n  };\n\n  // Converts an integer from the sign-and-magnitude representation to\n  // the biased representation.  More precisely, let N be 2 to the\n  // power of (kBitCount - 1), an integer x is represented by the\n  // unsigned number x + N.\n  //\n  // For instance,\n  //\n  //   -N + 1 (the most negative number representable using\n  //          sign-and-magnitude) is represented by 1;\n  //   0      is represented by N; and\n  //   N - 1  (the biggest number representable using\n  //          sign-and-magnitude) is represented by 2N - 1.\n  //\n  // Read http://en.wikipedia.org/wiki/Signed_number_representations\n  // for more details on signed number representations.\n  static Bits SignAndMagnitudeToBiased(const Bits &sam) {\n    if (kSignBitMask & sam) {\n      // sam represents a negative number.\n      return ~sam + 1;\n    } else {\n      // sam represents a positive number.\n      return kSignBitMask | sam;\n    }\n  }\n\n  // Given two numbers in the sign-and-magnitude representation,\n  // returns the distance between them as an unsigned number.\n  static Bits DistanceBetweenSignAndMagnitudeNumbers(const Bits &sam1,\n                                                     const Bits &sam2) {\n    const Bits biased1 = SignAndMagnitudeToBiased(sam1);\n    const Bits biased2 = SignAndMagnitudeToBiased(sam2);\n    return (biased1 >= biased2) ? (biased1 - biased2) : (biased2 - biased1);\n  }\n\n  FloatingPointUnion u_;\n};\n\n// We cannot use std::numeric_limits<T>::max() as it clashes with the max()\n// macro defined by <windows.h>.\ntemplate <>\ninline float FloatingPoint<float>::Max() { return FLT_MAX; }\ntemplate <>\ninline double FloatingPoint<double>::Max() { return DBL_MAX; }\n\n// Typedefs the instances of the FloatingPoint template class that we\n// care to use.\ntypedef FloatingPoint<float> Float;\ntypedef FloatingPoint<double> Double;\n\n// In order to catch the mistake of putting tests that use different\n// test fixture classes in the same test case, we need to assign\n// unique IDs to fixture classes and compare them.  The TypeId type is\n// used to hold such IDs.  The user should treat TypeId as an opaque\n// type: the only operation allowed on TypeId values is to compare\n// them for equality using the == operator.\ntypedef const void* TypeId;\n\ntemplate <typename T>\nclass TypeIdHelper {\n public:\n  // dummy_ must not have a const type.  Otherwise an overly eager\n  // compiler (e.g. MSVC 7.1 & 8.0) may try to merge\n  // TypeIdHelper<T>::dummy_ for different Ts as an \"optimization\".\n  static bool dummy_;\n};\n\ntemplate <typename T>\nbool TypeIdHelper<T>::dummy_ = false;\n\n// GetTypeId<T>() returns the ID of type T.  Different values will be\n// returned for different types.  Calling the function twice with the\n// same type argument is guaranteed to return the same ID.\ntemplate <typename T>\nTypeId GetTypeId() {\n  // The compiler is required to allocate a different\n  // TypeIdHelper<T>::dummy_ variable for each T used to instantiate\n  // the template.  Therefore, the address of dummy_ is guaranteed to\n  // be unique.\n  return &(TypeIdHelper<T>::dummy_);\n}\n\n// Returns the type ID of ::testing::Test.  Always call this instead\n// of GetTypeId< ::testing::Test>() to get the type ID of\n// ::testing::Test, as the latter may give the wrong result due to a\n// suspected linker bug when compiling Google Test as a Mac OS X\n// framework.\nGTEST_API_ TypeId GetTestTypeId();\n\n// Defines the abstract factory interface that creates instances\n// of a Test object.\nclass TestFactoryBase {\n public:\n  virtual ~TestFactoryBase() {}\n\n  // Creates a test instance to run. The instance is both created and destroyed\n  // within TestInfoImpl::Run()\n  virtual Test* CreateTest() = 0;\n\n protected:\n  TestFactoryBase() {}\n\n private:\n  GTEST_DISALLOW_COPY_AND_ASSIGN_(TestFactoryBase);\n};\n\n// This class provides implementation of TeastFactoryBase interface.\n// It is used in TEST and TEST_F macros.\ntemplate <class TestClass>\nclass TestFactoryImpl : public TestFactoryBase {\n public:\n  virtual Test* CreateTest() { return new TestClass; }\n};\n\n#if GTEST_OS_WINDOWS\n\n// Predicate-formatters for implementing the HRESULT checking macros\n// {ASSERT|EXPECT}_HRESULT_{SUCCEEDED|FAILED}\n// We pass a long instead of HRESULT to avoid causing an\n// include dependency for the HRESULT type.\nGTEST_API_ AssertionResult IsHRESULTSuccess(const char* expr,\n                                            long hr);  // NOLINT\nGTEST_API_ AssertionResult IsHRESULTFailure(const char* expr,\n                                            long hr);  // NOLINT\n\n#endif  // GTEST_OS_WINDOWS\n\n// Types of SetUpTestCase() and TearDownTestCase() functions.\ntypedef void (*SetUpTestCaseFunc)();\ntypedef void (*TearDownTestCaseFunc)();\n\nstruct CodeLocation {\n  CodeLocation(const string& a_file, int a_line) : file(a_file), line(a_line) {}\n\n  string file;\n  int line;\n};\n\n// Creates a new TestInfo object and registers it with Google Test;\n// returns the created object.\n//\n// Arguments:\n//\n//   test_case_name:   name of the test case\n//   name:             name of the test\n//   type_param        the name of the test's type parameter, or NULL if\n//                     this is not a typed or a type-parameterized test.\n//   value_param       text representation of the test's value parameter,\n//                     or NULL if this is not a type-parameterized test.\n//   code_location:    code location where the test is defined\n//   fixture_class_id: ID of the test fixture class\n//   set_up_tc:        pointer to the function that sets up the test case\n//   tear_down_tc:     pointer to the function that tears down the test case\n//   factory:          pointer to the factory that creates a test object.\n//                     The newly created TestInfo instance will assume\n//                     ownership of the factory object.\nGTEST_API_ TestInfo* MakeAndRegisterTestInfo(\n    const char* test_case_name,\n    const char* name,\n    const char* type_param,\n    const char* value_param,\n    CodeLocation code_location,\n    TypeId fixture_class_id,\n    SetUpTestCaseFunc set_up_tc,\n    TearDownTestCaseFunc tear_down_tc,\n    TestFactoryBase* factory);\n\n// If *pstr starts with the given prefix, modifies *pstr to be right\n// past the prefix and returns true; otherwise leaves *pstr unchanged\n// and returns false.  None of pstr, *pstr, and prefix can be NULL.\nGTEST_API_ bool SkipPrefix(const char* prefix, const char** pstr);\n\n#if GTEST_HAS_TYPED_TEST || GTEST_HAS_TYPED_TEST_P\n\n// State of the definition of a type-parameterized test case.\nclass GTEST_API_ TypedTestCasePState {\n public:\n  TypedTestCasePState() : registered_(false) {}\n\n  // Adds the given test name to defined_test_names_ and return true\n  // if the test case hasn't been registered; otherwise aborts the\n  // program.\n  bool AddTestName(const char* file, int line, const char* case_name,\n                   const char* test_name) {\n    if (registered_) {\n      fprintf(stderr, \"%s Test %s must be defined before \"\n              \"REGISTER_TYPED_TEST_CASE_P(%s, ...).\\n\",\n              FormatFileLocation(file, line).c_str(), test_name, case_name);\n      fflush(stderr);\n      posix::Abort();\n    }\n    registered_tests_.insert(\n        ::std::make_pair(test_name, CodeLocation(file, line)));\n    return true;\n  }\n\n  bool TestExists(const std::string& test_name) const {\n    return registered_tests_.count(test_name) > 0;\n  }\n\n  const CodeLocation& GetCodeLocation(const std::string& test_name) const {\n    RegisteredTestsMap::const_iterator it = registered_tests_.find(test_name);\n    GTEST_CHECK_(it != registered_tests_.end());\n    return it->second;\n  }\n\n  // Verifies that registered_tests match the test names in\n  // defined_test_names_; returns registered_tests if successful, or\n  // aborts the program otherwise.\n  const char* VerifyRegisteredTestNames(\n      const char* file, int line, const char* registered_tests);\n\n private:\n  typedef ::std::map<std::string, CodeLocation> RegisteredTestsMap;\n\n  bool registered_;\n  RegisteredTestsMap registered_tests_;\n};\n\n// Skips to the first non-space char after the first comma in 'str';\n// returns NULL if no comma is found in 'str'.\ninline const char* SkipComma(const char* str) {\n  const char* comma = strchr(str, ',');\n  if (comma == NULL) {\n    return NULL;\n  }\n  while (IsSpace(*(++comma))) {}\n  return comma;\n}\n\n// Returns the prefix of 'str' before the first comma in it; returns\n// the entire string if it contains no comma.\ninline std::string GetPrefixUntilComma(const char* str) {\n  const char* comma = strchr(str, ',');\n  return comma == NULL ? str : std::string(str, comma);\n}\n\n// Splits a given string on a given delimiter, populating a given\n// vector with the fields.\nvoid SplitString(const ::std::string& str, char delimiter,\n                 ::std::vector< ::std::string>* dest);\n\n// TypeParameterizedTest<Fixture, TestSel, Types>::Register()\n// registers a list of type-parameterized tests with Google Test.  The\n// return value is insignificant - we just need to return something\n// such that we can call this function in a namespace scope.\n//\n// Implementation note: The GTEST_TEMPLATE_ macro declares a template\n// template parameter.  It's defined in gtest-type-util.h.\ntemplate <GTEST_TEMPLATE_ Fixture, class TestSel, typename Types>\nclass TypeParameterizedTest {\n public:\n  // 'index' is the index of the test in the type list 'Types'\n  // specified in INSTANTIATE_TYPED_TEST_CASE_P(Prefix, TestCase,\n  // Types).  Valid values for 'index' are [0, N - 1] where N is the\n  // length of Types.\n  static bool Register(const char* prefix,\n                       CodeLocation code_location,\n                       const char* case_name, const char* test_names,\n                       int index) {\n    typedef typename Types::Head Type;\n    typedef Fixture<Type> FixtureClass;\n    typedef typename GTEST_BIND_(TestSel, Type) TestClass;\n\n    // First, registers the first type-parameterized test in the type\n    // list.\n    MakeAndRegisterTestInfo(\n        (std::string(prefix) + (prefix[0] == '\\0' ? \"\" : \"/\") + case_name + \"/\"\n         + StreamableToString(index)).c_str(),\n        StripTrailingSpaces(GetPrefixUntilComma(test_names)).c_str(),\n        GetTypeName<Type>().c_str(),\n        NULL,  // No value parameter.\n        code_location,\n        GetTypeId<FixtureClass>(),\n        TestClass::SetUpTestCase,\n        TestClass::TearDownTestCase,\n        new TestFactoryImpl<TestClass>);\n\n    // Next, recurses (at compile time) with the tail of the type list.\n    return TypeParameterizedTest<Fixture, TestSel, typename Types::Tail>\n        ::Register(prefix, code_location, case_name, test_names, index + 1);\n  }\n};\n\n// The base case for the compile time recursion.\ntemplate <GTEST_TEMPLATE_ Fixture, class TestSel>\nclass TypeParameterizedTest<Fixture, TestSel, Types0> {\n public:\n  static bool Register(const char* /*prefix*/, CodeLocation,\n                       const char* /*case_name*/, const char* /*test_names*/,\n                       int /*index*/) {\n    return true;\n  }\n};\n\n// TypeParameterizedTestCase<Fixture, Tests, Types>::Register()\n// registers *all combinations* of 'Tests' and 'Types' with Google\n// Test.  The return value is insignificant - we just need to return\n// something such that we can call this function in a namespace scope.\ntemplate <GTEST_TEMPLATE_ Fixture, typename Tests, typename Types>\nclass TypeParameterizedTestCase {\n public:\n  static bool Register(const char* prefix, CodeLocation code_location,\n                       const TypedTestCasePState* state,\n                       const char* case_name, const char* test_names) {\n    std::string test_name = StripTrailingSpaces(\n        GetPrefixUntilComma(test_names));\n    if (!state->TestExists(test_name)) {\n      fprintf(stderr, \"Failed to get code location for test %s.%s at %s.\",\n              case_name, test_name.c_str(),\n              FormatFileLocation(code_location.file.c_str(),\n                                 code_location.line).c_str());\n      fflush(stderr);\n      posix::Abort();\n    }\n    const CodeLocation& test_location = state->GetCodeLocation(test_name);\n\n    typedef typename Tests::Head Head;\n\n    // First, register the first test in 'Test' for each type in 'Types'.\n    TypeParameterizedTest<Fixture, Head, Types>::Register(\n        prefix, test_location, case_name, test_names, 0);\n\n    // Next, recurses (at compile time) with the tail of the test list.\n    return TypeParameterizedTestCase<Fixture, typename Tests::Tail, Types>\n        ::Register(prefix, code_location, state,\n                   case_name, SkipComma(test_names));\n  }\n};\n\n// The base case for the compile time recursion.\ntemplate <GTEST_TEMPLATE_ Fixture, typename Types>\nclass TypeParameterizedTestCase<Fixture, Templates0, Types> {\n public:\n  static bool Register(const char* /*prefix*/, CodeLocation,\n                       const TypedTestCasePState* /*state*/,\n                       const char* /*case_name*/, const char* /*test_names*/) {\n    return true;\n  }\n};\n\n#endif  // GTEST_HAS_TYPED_TEST || GTEST_HAS_TYPED_TEST_P\n\n// Returns the current OS stack trace as an std::string.\n//\n// The maximum number of stack frames to be included is specified by\n// the gtest_stack_trace_depth flag.  The skip_count parameter\n// specifies the number of top frames to be skipped, which doesn't\n// count against the number of frames to be included.\n//\n// For example, if Foo() calls Bar(), which in turn calls\n// GetCurrentOsStackTraceExceptTop(..., 1), Foo() will be included in\n// the trace but Bar() and GetCurrentOsStackTraceExceptTop() won't.\nGTEST_API_ std::string GetCurrentOsStackTraceExceptTop(\n    UnitTest* unit_test, int skip_count);\n\n// Helpers for suppressing warnings on unreachable code or constant\n// condition.\n\n// Always returns true.\nGTEST_API_ bool AlwaysTrue();\n\n// Always returns false.\ninline bool AlwaysFalse() { return !AlwaysTrue(); }\n\n// Helper for suppressing false warning from Clang on a const char*\n// variable declared in a conditional expression always being NULL in\n// the else branch.\nstruct GTEST_API_ ConstCharPtr {\n  ConstCharPtr(const char* str) : value(str) {}\n  operator bool() const { return true; }\n  const char* value;\n};\n\n// A simple Linear Congruential Generator for generating random\n// numbers with a uniform distribution.  Unlike rand() and srand(), it\n// doesn't use global state (and therefore can't interfere with user\n// code).  Unlike rand_r(), it's portable.  An LCG isn't very random,\n// but it's good enough for our purposes.\nclass GTEST_API_ Random {\n public:\n  static const UInt32 kMaxRange = 1u << 31;\n\n  explicit Random(UInt32 seed) : state_(seed) {}\n\n  void Reseed(UInt32 seed) { state_ = seed; }\n\n  // Generates a random number from [0, range).  Crashes if 'range' is\n  // 0 or greater than kMaxRange.\n  UInt32 Generate(UInt32 range);\n\n private:\n  UInt32 state_;\n  GTEST_DISALLOW_COPY_AND_ASSIGN_(Random);\n};\n\n// Defining a variable of type CompileAssertTypesEqual<T1, T2> will cause a\n// compiler error iff T1 and T2 are different types.\ntemplate <typename T1, typename T2>\nstruct CompileAssertTypesEqual;\n\ntemplate <typename T>\nstruct CompileAssertTypesEqual<T, T> {\n};\n\n// Removes the reference from a type if it is a reference type,\n// otherwise leaves it unchanged.  This is the same as\n// tr1::remove_reference, which is not widely available yet.\ntemplate <typename T>\nstruct RemoveReference { typedef T type; };  // NOLINT\ntemplate <typename T>\nstruct RemoveReference<T&> { typedef T type; };  // NOLINT\n\n// A handy wrapper around RemoveReference that works when the argument\n// T depends on template parameters.\n#define GTEST_REMOVE_REFERENCE_(T) \\\n    typename ::testing::internal::RemoveReference<T>::type\n\n// Removes const from a type if it is a const type, otherwise leaves\n// it unchanged.  This is the same as tr1::remove_const, which is not\n// widely available yet.\ntemplate <typename T>\nstruct RemoveConst { typedef T type; };  // NOLINT\ntemplate <typename T>\nstruct RemoveConst<const T> { typedef T type; };  // NOLINT\n\n// MSVC 8.0, Sun C++, and IBM XL C++ have a bug which causes the above\n// definition to fail to remove the const in 'const int[3]' and 'const\n// char[3][4]'.  The following specialization works around the bug.\ntemplate <typename T, size_t N>\nstruct RemoveConst<const T[N]> {\n  typedef typename RemoveConst<T>::type type[N];\n};\n\n#if defined(_MSC_VER) && _MSC_VER < 1400\n// This is the only specialization that allows VC++ 7.1 to remove const in\n// 'const int[3] and 'const int[3][4]'.  However, it causes trouble with GCC\n// and thus needs to be conditionally compiled.\ntemplate <typename T, size_t N>\nstruct RemoveConst<T[N]> {\n  typedef typename RemoveConst<T>::type type[N];\n};\n#endif\n\n// A handy wrapper around RemoveConst that works when the argument\n// T depends on template parameters.\n#define GTEST_REMOVE_CONST_(T) \\\n    typename ::testing::internal::RemoveConst<T>::type\n\n// Turns const U&, U&, const U, and U all into U.\n#define GTEST_REMOVE_REFERENCE_AND_CONST_(T) \\\n    GTEST_REMOVE_CONST_(GTEST_REMOVE_REFERENCE_(T))\n\n// Adds reference to a type if it is not a reference type,\n// otherwise leaves it unchanged.  This is the same as\n// tr1::add_reference, which is not widely available yet.\ntemplate <typename T>\nstruct AddReference { typedef T& type; };  // NOLINT\ntemplate <typename T>\nstruct AddReference<T&> { typedef T& type; };  // NOLINT\n\n// A handy wrapper around AddReference that works when the argument T\n// depends on template parameters.\n#define GTEST_ADD_REFERENCE_(T) \\\n    typename ::testing::internal::AddReference<T>::type\n\n// Adds a reference to const on top of T as necessary.  For example,\n// it transforms\n//\n//   char         ==> const char&\n//   const char   ==> const char&\n//   char&        ==> const char&\n//   const char&  ==> const char&\n//\n// The argument T must depend on some template parameters.\n#define GTEST_REFERENCE_TO_CONST_(T) \\\n    GTEST_ADD_REFERENCE_(const GTEST_REMOVE_REFERENCE_(T))\n\n// ImplicitlyConvertible<From, To>::value is a compile-time bool\n// constant that's true iff type From can be implicitly converted to\n// type To.\ntemplate <typename From, typename To>\nclass ImplicitlyConvertible {\n private:\n  // We need the following helper functions only for their types.\n  // They have no implementations.\n\n  // MakeFrom() is an expression whose type is From.  We cannot simply\n  // use From(), as the type From may not have a public default\n  // constructor.\n  static typename AddReference<From>::type MakeFrom();\n\n  // These two functions are overloaded.  Given an expression\n  // Helper(x), the compiler will pick the first version if x can be\n  // implicitly converted to type To; otherwise it will pick the\n  // second version.\n  //\n  // The first version returns a value of size 1, and the second\n  // version returns a value of size 2.  Therefore, by checking the\n  // size of Helper(x), which can be done at compile time, we can tell\n  // which version of Helper() is used, and hence whether x can be\n  // implicitly converted to type To.\n  static char Helper(To);\n  static char (&Helper(...))[2];  // NOLINT\n\n  // We have to put the 'public' section after the 'private' section,\n  // or MSVC refuses to compile the code.\n public:\n#if defined(__BORLANDC__)\n  // C++Builder cannot use member overload resolution during template\n  // instantiation.  The simplest workaround is to use its C++0x type traits\n  // functions (C++Builder 2009 and above only).\n  static const bool value = __is_convertible(From, To);\n#else\n  // MSVC warns about implicitly converting from double to int for\n  // possible loss of data, so we need to temporarily disable the\n  // warning.\n  GTEST_DISABLE_MSC_WARNINGS_PUSH_(4244)\n  static const bool value =\n      sizeof(Helper(ImplicitlyConvertible::MakeFrom())) == 1;\n  GTEST_DISABLE_MSC_WARNINGS_POP_()\n#endif  // __BORLANDC__\n};\ntemplate <typename From, typename To>\nconst bool ImplicitlyConvertible<From, To>::value;\n\n// IsAProtocolMessage<T>::value is a compile-time bool constant that's\n// true iff T is type ProtocolMessage, proto2::Message, or a subclass\n// of those.\ntemplate <typename T>\nstruct IsAProtocolMessage\n    : public bool_constant<\n  ImplicitlyConvertible<const T*, const ::ProtocolMessage*>::value ||\n  ImplicitlyConvertible<const T*, const ::proto2::Message*>::value> {\n};\n\n// When the compiler sees expression IsContainerTest<C>(0), if C is an\n// STL-style container class, the first overload of IsContainerTest\n// will be viable (since both C::iterator* and C::const_iterator* are\n// valid types and NULL can be implicitly converted to them).  It will\n// be picked over the second overload as 'int' is a perfect match for\n// the type of argument 0.  If C::iterator or C::const_iterator is not\n// a valid type, the first overload is not viable, and the second\n// overload will be picked.  Therefore, we can determine whether C is\n// a container class by checking the type of IsContainerTest<C>(0).\n// The value of the expression is insignificant.\n//\n// Note that we look for both C::iterator and C::const_iterator.  The\n// reason is that C++ injects the name of a class as a member of the\n// class itself (e.g. you can refer to class iterator as either\n// 'iterator' or 'iterator::iterator').  If we look for C::iterator\n// only, for example, we would mistakenly think that a class named\n// iterator is an STL container.\n//\n// Also note that the simpler approach of overloading\n// IsContainerTest(typename C::const_iterator*) and\n// IsContainerTest(...) doesn't work with Visual Age C++ and Sun C++.\ntypedef int IsContainer;\ntemplate <class C>\nIsContainer IsContainerTest(int /* dummy */,\n                            typename C::iterator* /* it */ = NULL,\n                            typename C::const_iterator* /* const_it */ = NULL) {\n  return 0;\n}\n\ntypedef char IsNotContainer;\ntemplate <class C>\nIsNotContainer IsContainerTest(long /* dummy */) { return '\\0'; }\n\n// EnableIf<condition>::type is void when 'Cond' is true, and\n// undefined when 'Cond' is false.  To use SFINAE to make a function\n// overload only apply when a particular expression is true, add\n// \"typename EnableIf<expression>::type* = 0\" as the last parameter.\ntemplate<bool> struct EnableIf;\ntemplate<> struct EnableIf<true> { typedef void type; };  // NOLINT\n\n// Utilities for native arrays.\n\n// ArrayEq() compares two k-dimensional native arrays using the\n// elements' operator==, where k can be any integer >= 0.  When k is\n// 0, ArrayEq() degenerates into comparing a single pair of values.\n\ntemplate <typename T, typename U>\nbool ArrayEq(const T* lhs, size_t size, const U* rhs);\n\n// This generic version is used when k is 0.\ntemplate <typename T, typename U>\ninline bool ArrayEq(const T& lhs, const U& rhs) { return lhs == rhs; }\n\n// This overload is used when k >= 1.\ntemplate <typename T, typename U, size_t N>\ninline bool ArrayEq(const T(&lhs)[N], const U(&rhs)[N]) {\n  return internal::ArrayEq(lhs, N, rhs);\n}\n\n// This helper reduces code bloat.  If we instead put its logic inside\n// the previous ArrayEq() function, arrays with different sizes would\n// lead to different copies of the template code.\ntemplate <typename T, typename U>\nbool ArrayEq(const T* lhs, size_t size, const U* rhs) {\n  for (size_t i = 0; i != size; i++) {\n    if (!internal::ArrayEq(lhs[i], rhs[i]))\n      return false;\n  }\n  return true;\n}\n\n// Finds the first element in the iterator range [begin, end) that\n// equals elem.  Element may be a native array type itself.\ntemplate <typename Iter, typename Element>\nIter ArrayAwareFind(Iter begin, Iter end, const Element& elem) {\n  for (Iter it = begin; it != end; ++it) {\n    if (internal::ArrayEq(*it, elem))\n      return it;\n  }\n  return end;\n}\n\n// CopyArray() copies a k-dimensional native array using the elements'\n// operator=, where k can be any integer >= 0.  When k is 0,\n// CopyArray() degenerates into copying a single value.\n\ntemplate <typename T, typename U>\nvoid CopyArray(const T* from, size_t size, U* to);\n\n// This generic version is used when k is 0.\ntemplate <typename T, typename U>\ninline void CopyArray(const T& from, U* to) { *to = from; }\n\n// This overload is used when k >= 1.\ntemplate <typename T, typename U, size_t N>\ninline void CopyArray(const T(&from)[N], U(*to)[N]) {\n  internal::CopyArray(from, N, *to);\n}\n\n// This helper reduces code bloat.  If we instead put its logic inside\n// the previous CopyArray() function, arrays with different sizes\n// would lead to different copies of the template code.\ntemplate <typename T, typename U>\nvoid CopyArray(const T* from, size_t size, U* to) {\n  for (size_t i = 0; i != size; i++) {\n    internal::CopyArray(from[i], to + i);\n  }\n}\n\n// The relation between an NativeArray object (see below) and the\n// native array it represents.\n// We use 2 different structs to allow non-copyable types to be used, as long\n// as RelationToSourceReference() is passed.\nstruct RelationToSourceReference {};\nstruct RelationToSourceCopy {};\n\n// Adapts a native array to a read-only STL-style container.  Instead\n// of the complete STL container concept, this adaptor only implements\n// members useful for Google Mock's container matchers.  New members\n// should be added as needed.  To simplify the implementation, we only\n// support Element being a raw type (i.e. having no top-level const or\n// reference modifier).  It's the client's responsibility to satisfy\n// this requirement.  Element can be an array type itself (hence\n// multi-dimensional arrays are supported).\ntemplate <typename Element>\nclass NativeArray {\n public:\n  // STL-style container typedefs.\n  typedef Element value_type;\n  typedef Element* iterator;\n  typedef const Element* const_iterator;\n\n  // Constructs from a native array. References the source.\n  NativeArray(const Element* array, size_t count, RelationToSourceReference) {\n    InitRef(array, count);\n  }\n\n  // Constructs from a native array. Copies the source.\n  NativeArray(const Element* array, size_t count, RelationToSourceCopy) {\n    InitCopy(array, count);\n  }\n\n  // Copy constructor.\n  NativeArray(const NativeArray& rhs) {\n    (this->*rhs.clone_)(rhs.array_, rhs.size_);\n  }\n\n  ~NativeArray() {\n    if (clone_ != &NativeArray::InitRef)\n      delete[] array_;\n  }\n\n  // STL-style container methods.\n  size_t size() const { return size_; }\n  const_iterator begin() const { return array_; }\n  const_iterator end() const { return array_ + size_; }\n  bool operator==(const NativeArray& rhs) const {\n    return size() == rhs.size() &&\n        ArrayEq(begin(), size(), rhs.begin());\n  }\n\n private:\n  enum {\n    kCheckTypeIsNotConstOrAReference = StaticAssertTypeEqHelper<\n        Element, GTEST_REMOVE_REFERENCE_AND_CONST_(Element)>::value,\n  };\n\n  // Initializes this object with a copy of the input.\n  void InitCopy(const Element* array, size_t a_size) {\n    Element* const copy = new Element[a_size];\n    CopyArray(array, a_size, copy);\n    array_ = copy;\n    size_ = a_size;\n    clone_ = &NativeArray::InitCopy;\n  }\n\n  // Initializes this object with a reference of the input.\n  void InitRef(const Element* array, size_t a_size) {\n    array_ = array;\n    size_ = a_size;\n    clone_ = &NativeArray::InitRef;\n  }\n\n  const Element* array_;\n  size_t size_;\n  void (NativeArray::*clone_)(const Element*, size_t);\n\n  GTEST_DISALLOW_ASSIGN_(NativeArray);\n};\n\n}  // namespace internal\n}  // namespace testing\n\n#define GTEST_MESSAGE_AT_(file, line, message, result_type) \\\n  ::testing::internal::AssertHelper(result_type, file, line, message) \\\n    = ::testing::Message()\n\n#define GTEST_MESSAGE_(message, result_type) \\\n  GTEST_MESSAGE_AT_(__FILE__, __LINE__, message, result_type)\n\n#define GTEST_FATAL_FAILURE_(message) \\\n  return GTEST_MESSAGE_(message, ::testing::TestPartResult::kFatalFailure)\n\n#define GTEST_NONFATAL_FAILURE_(message) \\\n  GTEST_MESSAGE_(message, ::testing::TestPartResult::kNonFatalFailure)\n\n#define GTEST_SUCCESS_(message) \\\n  GTEST_MESSAGE_(message, ::testing::TestPartResult::kSuccess)\n\n// Suppresses MSVC warnings 4072 (unreachable code) for the code following\n// statement if it returns or throws (or doesn't return or throw in some\n// situations).\n#define GTEST_SUPPRESS_UNREACHABLE_CODE_WARNING_BELOW_(statement) \\\n  if (::testing::internal::AlwaysTrue()) { statement; }\n\n#define GTEST_TEST_THROW_(statement, expected_exception, fail) \\\n  GTEST_AMBIGUOUS_ELSE_BLOCKER_ \\\n  if (::testing::internal::ConstCharPtr gtest_msg = \"\") { \\\n    bool gtest_caught_expected = false; \\\n    try { \\\n      GTEST_SUPPRESS_UNREACHABLE_CODE_WARNING_BELOW_(statement); \\\n    } \\\n    catch (expected_exception const&) { \\\n      gtest_caught_expected = true; \\\n    } \\\n    catch (...) { \\\n      gtest_msg.value = \\\n          \"Expected: \" #statement \" throws an exception of type \" \\\n          #expected_exception \".\\n  Actual: it throws a different type.\"; \\\n      goto GTEST_CONCAT_TOKEN_(gtest_label_testthrow_, __LINE__); \\\n    } \\\n    if (!gtest_caught_expected) { \\\n      gtest_msg.value = \\\n          \"Expected: \" #statement \" throws an exception of type \" \\\n          #expected_exception \".\\n  Actual: it throws nothing.\"; \\\n      goto GTEST_CONCAT_TOKEN_(gtest_label_testthrow_, __LINE__); \\\n    } \\\n  } else \\\n    GTEST_CONCAT_TOKEN_(gtest_label_testthrow_, __LINE__): \\\n      fail(gtest_msg.value)\n\n#define GTEST_TEST_NO_THROW_(statement, fail) \\\n  GTEST_AMBIGUOUS_ELSE_BLOCKER_ \\\n  if (::testing::internal::AlwaysTrue()) { \\\n    try { \\\n      GTEST_SUPPRESS_UNREACHABLE_CODE_WARNING_BELOW_(statement); \\\n    } \\\n    catch (...) { \\\n      goto GTEST_CONCAT_TOKEN_(gtest_label_testnothrow_, __LINE__); \\\n    } \\\n  } else \\\n    GTEST_CONCAT_TOKEN_(gtest_label_testnothrow_, __LINE__): \\\n      fail(\"Expected: \" #statement \" doesn't throw an exception.\\n\" \\\n           \"  Actual: it throws.\")\n\n#define GTEST_TEST_ANY_THROW_(statement, fail) \\\n  GTEST_AMBIGUOUS_ELSE_BLOCKER_ \\\n  if (::testing::internal::AlwaysTrue()) { \\\n    bool gtest_caught_any = false; \\\n    try { \\\n      GTEST_SUPPRESS_UNREACHABLE_CODE_WARNING_BELOW_(statement); \\\n    } \\\n    catch (...) { \\\n      gtest_caught_any = true; \\\n    } \\\n    if (!gtest_caught_any) { \\\n      goto GTEST_CONCAT_TOKEN_(gtest_label_testanythrow_, __LINE__); \\\n    } \\\n  } else \\\n    GTEST_CONCAT_TOKEN_(gtest_label_testanythrow_, __LINE__): \\\n      fail(\"Expected: \" #statement \" throws an exception.\\n\" \\\n           \"  Actual: it doesn't.\")\n\n\n// Implements Boolean test assertions such as EXPECT_TRUE. expression can be\n// either a boolean expression or an AssertionResult. text is a textual\n// represenation of expression as it was passed into the EXPECT_TRUE.\n#define GTEST_TEST_BOOLEAN_(expression, text, actual, expected, fail) \\\n  GTEST_AMBIGUOUS_ELSE_BLOCKER_ \\\n  if (const ::testing::AssertionResult gtest_ar_ = \\\n      ::testing::AssertionResult(expression)) \\\n    ; \\\n  else \\\n    fail(::testing::internal::GetBoolAssertionFailureMessage(\\\n        gtest_ar_, text, #actual, #expected).c_str())\n\n#define GTEST_TEST_NO_FATAL_FAILURE_(statement, fail) \\\n  GTEST_AMBIGUOUS_ELSE_BLOCKER_ \\\n  if (::testing::internal::AlwaysTrue()) { \\\n    ::testing::internal::HasNewFatalFailureHelper gtest_fatal_failure_checker; \\\n    GTEST_SUPPRESS_UNREACHABLE_CODE_WARNING_BELOW_(statement); \\\n    if (gtest_fatal_failure_checker.has_new_fatal_failure()) { \\\n      goto GTEST_CONCAT_TOKEN_(gtest_label_testnofatal_, __LINE__); \\\n    } \\\n  } else \\\n    GTEST_CONCAT_TOKEN_(gtest_label_testnofatal_, __LINE__): \\\n      fail(\"Expected: \" #statement \" doesn't generate new fatal \" \\\n           \"failures in the current thread.\\n\" \\\n           \"  Actual: it does.\")\n\n// Expands to the name of the class that implements the given test.\n#define GTEST_TEST_CLASS_NAME_(test_case_name, test_name) \\\n  test_case_name##_##test_name##_Test\n\n// Helper macro for defining tests.\n#define GTEST_TEST_(test_case_name, test_name, parent_class, parent_id)\\\nclass GTEST_TEST_CLASS_NAME_(test_case_name, test_name) : public parent_class {\\\n public:\\\n  GTEST_TEST_CLASS_NAME_(test_case_name, test_name)() {}\\\n private:\\\n  virtual void TestBody();\\\n  static ::testing::TestInfo* const test_info_ GTEST_ATTRIBUTE_UNUSED_;\\\n  GTEST_DISALLOW_COPY_AND_ASSIGN_(\\\n      GTEST_TEST_CLASS_NAME_(test_case_name, test_name));\\\n};\\\n\\\n::testing::TestInfo* const GTEST_TEST_CLASS_NAME_(test_case_name, test_name)\\\n  ::test_info_ =\\\n    ::testing::internal::MakeAndRegisterTestInfo(\\\n        #test_case_name, #test_name, NULL, NULL, \\\n        ::testing::internal::CodeLocation(__FILE__, __LINE__), \\\n        (parent_id), \\\n        parent_class::SetUpTestCase, \\\n        parent_class::TearDownTestCase, \\\n        new ::testing::internal::TestFactoryImpl<\\\n            GTEST_TEST_CLASS_NAME_(test_case_name, test_name)>);\\\nvoid GTEST_TEST_CLASS_NAME_(test_case_name, test_name)::TestBody()\n\n#endif  // GTEST_INCLUDE_GTEST_INTERNAL_GTEST_INTERNAL_H_\n\n"}}, "reports": [{"events": [{"location": {"col": 8, "file": 3, "line": 159}, "message": "default constructor 'CodeCompletion' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clangd/CodeComplete.h", "reportHash": "30991ca02f0c747dfdb0d827616f1639", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 7, "line": 222}, "message": "default constructor 'TextEdit' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clangd/Protocol.h", "reportHash": "9719384711c674425a4b6ae3704fecef", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 7, "line": 1142}, "message": "move assignment operator 'operator=' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clangd/Protocol.h", "reportHash": "2954a18fa4d367a5673a22ba4639d83c", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 8, "line": 181}, "message": "default constructor 'DecisionForestScores' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clangd/Quality.h", "reportHash": "e36211eab93f53c137755e1804bfe047", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 8, "line": 181}, "message": "move constructor 'DecisionForestScores' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clangd/Quality.h", "reportHash": "d43cf95896dad88d9f6b1cb744a74aea", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 21, "line": 23}, "message": "move assignment operator 'operator=' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clangd/unittests/Annotations.h", "reportHash": "16984307cdc497884974d21cc444fca5", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 9, "file": 23, "line": 1384}, "message": "expanded from macro 'MATCHER'"}, {"location": {"col": 1, "file": 22, "line": 78}, "message": "destructor '~InsertIncludeMatcher' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clangd/unittests/CodeCompleteTests.cpp", "reportHash": "c6838df32f2dd5b5f5f8b18d26cf45f7", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 9, "file": 23, "line": 1384}, "message": "expanded from macro 'MATCHER'"}, {"location": {"col": 1, "file": 22, "line": 93}, "message": "destructor '~IsDocumentedMatcher' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clangd/unittests/CodeCompleteTests.cpp", "reportHash": "aa331964b2062ea3720c10646afd87b0", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 9, "file": 23, "line": 1384}, "message": "expanded from macro 'MATCHER'"}, {"location": {"col": 1, "file": 22, "line": 94}, "message": "destructor '~DeprecatedMatcher' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clangd/unittests/CodeCompleteTests.cpp", "reportHash": "ace32dd545c2cd38ce6244d06d3cb309", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 42, "file": 24, "line": 2187}, "message": "expanded from macro 'TEST'"}, {"location": {"col": 3, "file": 24, "line": 2181}, "message": "expanded from macro 'GTEST_TEST'"}, {"location": {"col": 7, "file": 25, "line": 1215}, "message": "expanded from macro 'GTEST_TEST_'"}, {"location": {"col": 3, "file": 25, "line": 1211}, "message": "expanded from macro 'GTEST_TEST_CLASS_NAME_'"}, {"location": {"col": 1, "file": 22, "line": 166}, "message": "destructor '~DecisionForestRankingModel_NameMatchSanityTest_Test' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clangd/unittests/CodeCompleteTests.cpp", "reportHash": "f3e207f9ae346642f0d6f58aad8e92f3", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 42, "file": 24, "line": 2187}, "message": "expanded from macro 'TEST'"}, {"location": {"col": 3, "file": 24, "line": 2181}, "message": "expanded from macro 'GTEST_TEST'"}, {"location": {"col": 7, "file": 25, "line": 1215}, "message": "expanded from macro 'GTEST_TEST_'"}, {"location": {"col": 3, "file": 25, "line": 1211}, "message": "expanded from macro 'GTEST_TEST_CLASS_NAME_'"}, {"location": {"col": 1, "file": 22, "line": 182}, "message": "destructor '~DecisionForestRankingModel_ReferencesAffectRanking_Test' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clangd/unittests/CodeCompleteTests.cpp", "reportHash": "53941f7533a1802a7dcae2bbf4e0e10c", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 42, "file": 24, "line": 2187}, "message": "expanded from macro 'TEST'"}, {"location": {"col": 3, "file": 24, "line": 2181}, "message": "expanded from macro 'GTEST_TEST'"}, {"location": {"col": 7, "file": 25, "line": 1215}, "message": "expanded from macro 'GTEST_TEST_'"}, {"location": {"col": 3, "file": 25, "line": 1211}, "message": "expanded from macro 'GTEST_TEST_CLASS_NAME_'"}, {"location": {"col": 1, "file": 22, "line": 200}, "message": "destructor '~DecisionForestRankingModel_DecisionForestScorerCallbackTest_Test' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clangd/unittests/CodeCompleteTests.cpp", "reportHash": "fcc8b48fd1abb72b09f6eb94ec5c8471", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 31, "file": 22, "line": 204}, "message": "destructor '~' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clangd/unittests/CodeCompleteTests.cpp", "reportHash": "375187062a79f8592b562ee64b46d319", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 42, "file": 24, "line": 2187}, "message": "expanded from macro 'TEST'"}, {"location": {"col": 3, "file": 24, "line": 2181}, "message": "expanded from macro 'GTEST_TEST'"}, {"location": {"col": 7, "file": 25, "line": 1215}, "message": "expanded from macro 'GTEST_TEST_'"}, {"location": {"col": 3, "file": 25, "line": 1211}, "message": "expanded from macro 'GTEST_TEST_CLASS_NAME_'"}, {"location": {"col": 1, "file": 22, "line": 227}, "message": "destructor '~CompletionTest_Limit_Test' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clangd/unittests/CodeCompleteTests.cpp", "reportHash": "33ed946a88dac63349b0fd8a9936d3b3", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 42, "file": 24, "line": 2187}, "message": "expanded from macro 'TEST'"}, {"location": {"col": 3, "file": 24, "line": 2181}, "message": "expanded from macro 'GTEST_TEST'"}, {"location": {"col": 7, "file": 25, "line": 1215}, "message": "expanded from macro 'GTEST_TEST_'"}, {"location": {"col": 3, "file": 25, "line": 1211}, "message": "expanded from macro 'GTEST_TEST_CLASS_NAME_'"}, {"location": {"col": 1, "file": 22, "line": 245}, "message": "destructor '~CompletionTest_Filter_Test' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clangd/unittests/CodeCompleteTests.cpp", "reportHash": "591fa69f7f061bff757eb3ce52134c62", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 42, "file": 24, "line": 2187}, "message": "expanded from macro 'TEST'"}, {"location": {"col": 3, "file": 24, "line": 2181}, "message": "expanded from macro 'GTEST_TEST'"}, {"location": {"col": 7, "file": 25, "line": 1215}, "message": "expanded from macro 'GTEST_TEST_'"}, {"location": {"col": 3, "file": 25, "line": 1211}, "message": "expanded from macro 'GTEST_TEST_CLASS_NAME_'"}, {"location": {"col": 1, "file": 22, "line": 370}, "message": "destructor '~CompletionTest_CompletionOptions_Test' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clangd/unittests/CodeCompleteTests.cpp", "reportHash": "54d180c758f80e315a36a36cccacf7f4", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 15, "file": 22, "line": 371}, "message": "destructor '~' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clangd/unittests/CodeCompleteTests.cpp", "reportHash": "0be0f3b7650b9bcfd47ad79870f80117", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 15, "file": 22, "line": 371}, "message": "move constructor '' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clangd/unittests/CodeCompleteTests.cpp", "reportHash": "2f3f06fc896652cd6c7f2e713bc49668", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 42, "file": 24, "line": 2187}, "message": "expanded from macro 'TEST'"}, {"location": {"col": 3, "file": 24, "line": 2181}, "message": "expanded from macro 'GTEST_TEST'"}, {"location": {"col": 7, "file": 25, "line": 1215}, "message": "expanded from macro 'GTEST_TEST_'"}, {"location": {"col": 3, "file": 25, "line": 1211}, "message": "expanded from macro 'GTEST_TEST_CLASS_NAME_'"}, {"location": {"col": 1, "file": 22, "line": 389}, "message": "destructor '~CompletionTest_Accessible_Test' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clangd/unittests/CodeCompleteTests.cpp", "reportHash": "ec48bb09594590dece060af989b9cba1", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 42, "file": 24, "line": 2187}, "message": "expanded from macro 'TEST'"}, {"location": {"col": 3, "file": 24, "line": 2181}, "message": "expanded from macro 'GTEST_TEST'"}, {"location": {"col": 7, "file": 25, "line": 1215}, "message": "expanded from macro 'GTEST_TEST_'"}, {"location": {"col": 3, "file": 25, "line": 1211}, "message": "expanded from macro 'GTEST_TEST_CLASS_NAME_'"}, {"location": {"col": 1, "file": 22, "line": 416}, "message": "destructor '~CompletionTest_Qualifiers_Test' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clangd/unittests/CodeCompleteTests.cpp", "reportHash": "dea0e35ed9ba1802d2653f89fe6531da", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 42, "file": 24, "line": 2187}, "message": "expanded from macro 'TEST'"}, {"location": {"col": 3, "file": 24, "line": 2181}, "message": "expanded from macro 'GTEST_TEST'"}, {"location": {"col": 7, "file": 25, "line": 1215}, "message": "expanded from macro 'GTEST_TEST_'"}, {"location": {"col": 3, "file": 25, "line": 1211}, "message": "expanded from macro 'GTEST_TEST_CLASS_NAME_'"}, {"location": {"col": 1, "file": 22, "line": 437}, "message": "destructor '~CompletionTest_InjectedTypename_Test' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clangd/unittests/CodeCompleteTests.cpp", "reportHash": "39f6daddc8f9e2fd5e1a44a927ea1ef0", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 42, "file": 24, "line": 2187}, "message": "expanded from macro 'TEST'"}, {"location": {"col": 3, "file": 24, "line": 2181}, "message": "expanded from macro 'GTEST_TEST'"}, {"location": {"col": 7, "file": 25, "line": 1215}, "message": "expanded from macro 'GTEST_TEST_'"}, {"location": {"col": 3, "file": 25, "line": 1211}, "message": "expanded from macro 'GTEST_TEST_CLASS_NAME_'"}, {"location": {"col": 1, "file": 22, "line": 459}, "message": "destructor '~CompletionTest_SkipInjectedWhenUnqualified_Test' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clangd/unittests/CodeCompleteTests.cpp", "reportHash": "58e332a5953023208d052f0ca43d0706", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 42, "file": 24, "line": 2187}, "message": "expanded from macro 'TEST'"}, {"location": {"col": 3, "file": 24, "line": 2181}, "message": "expanded from macro 'GTEST_TEST'"}, {"location": {"col": 7, "file": 25, "line": 1215}, "message": "expanded from macro 'GTEST_TEST_'"}, {"location": {"col": 3, "file": 25, "line": 1211}, "message": "expanded from macro 'GTEST_TEST_CLASS_NAME_'"}, {"location": {"col": 1, "file": 22, "line": 464}, "message": "destructor '~CompletionTest_Snippets_Test' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clangd/unittests/CodeCompleteTests.cpp", "reportHash": "f207d970c672537a29f0ea35f8516d3d", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 42, "file": 24, "line": 2187}, "message": "expanded from macro 'TEST'"}, {"location": {"col": 3, "file": 24, "line": 2181}, "message": "expanded from macro 'GTEST_TEST'"}, {"location": {"col": 7, "file": 25, "line": 1215}, "message": "expanded from macro 'GTEST_TEST_'"}, {"location": {"col": 3, "file": 25, "line": 1211}, "message": "expanded from macro 'GTEST_TEST_CLASS_NAME_'"}, {"location": {"col": 1, "file": 22, "line": 484}, "message": "destructor '~CompletionTest_NoSnippetsInUsings_Test' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clangd/unittests/CodeCompleteTests.cpp", "reportHash": "2af65325bd11ff1bd10ed62ec1abd62c", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 42, "file": 24, "line": 2187}, "message": "expanded from macro 'TEST'"}, {"location": {"col": 3, "file": 24, "line": 2181}, "message": "expanded from macro 'GTEST_TEST'"}, {"location": {"col": 7, "file": 25, "line": 1215}, "message": "expanded from macro 'GTEST_TEST_'"}, {"location": {"col": 3, "file": 25, "line": 1211}, "message": "expanded from macro 'GTEST_TEST_CLASS_NAME_'"}, {"location": {"col": 1, "file": 22, "line": 526}, "message": "destructor '~CompletionTest_Kinds_Test' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clangd/unittests/CodeCompleteTests.cpp", "reportHash": "903fa2e329bda9253cc5f140abb90c97", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 42, "file": 24, "line": 2187}, "message": "expanded from macro 'TEST'"}, {"location": {"col": 3, "file": 24, "line": 2181}, "message": "expanded from macro 'GTEST_TEST'"}, {"location": {"col": 7, "file": 25, "line": 1215}, "message": "expanded from macro 'GTEST_TEST_'"}, {"location": {"col": 3, "file": 25, "line": 1211}, "message": "expanded from macro 'GTEST_TEST_CLASS_NAME_'"}, {"location": {"col": 1, "file": 22, "line": 602}, "message": "destructor '~CompletionTest_NoDuplicates_Test' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clangd/unittests/CodeCompleteTests.cpp", "reportHash": "c1e9d17932490fced2650031117e7f41", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 42, "file": 24, "line": 2187}, "message": "expanded from macro 'TEST'"}, {"location": {"col": 3, "file": 24, "line": 2181}, "message": "expanded from macro 'GTEST_TEST'"}, {"location": {"col": 7, "file": 25, "line": 1215}, "message": "expanded from macro 'GTEST_TEST_'"}, {"location": {"col": 3, "file": 25, "line": 1211}, "message": "expanded from macro 'GTEST_TEST_CLASS_NAME_'"}, {"location": {"col": 1, "file": 22, "line": 618}, "message": "destructor '~CompletionTest_ScopedNoIndex_Test' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clangd/unittests/CodeCompleteTests.cpp", "reportHash": "b0e51583378506dd6963c46381d944eb", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 42, "file": 24, "line": 2187}, "message": "expanded from macro 'TEST'"}, {"location": {"col": 3, "file": 24, "line": 2181}, "message": "expanded from macro 'GTEST_TEST'"}, {"location": {"col": 7, "file": 25, "line": 1215}, "message": "expanded from macro 'GTEST_TEST_'"}, {"location": {"col": 3, "file": 25, "line": 1211}, "message": "expanded from macro 'GTEST_TEST_CLASS_NAME_'"}, {"location": {"col": 1, "file": 22, "line": 629}, "message": "destructor '~CompletionTest_Scoped_Test' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clangd/unittests/CodeCompleteTests.cpp", "reportHash": "13917cb1c253ca1b20e6f529fe8ff2e4", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 42, "file": 24, "line": 2187}, "message": "expanded from macro 'TEST'"}, {"location": {"col": 3, "file": 24, "line": 2181}, "message": "expanded from macro 'GTEST_TEST'"}, {"location": {"col": 7, "file": 25, "line": 1215}, "message": "expanded from macro 'GTEST_TEST_'"}, {"location": {"col": 3, "file": 25, "line": 1211}, "message": "expanded from macro 'GTEST_TEST_CLASS_NAME_'"}, {"location": {"col": 1, "file": 22, "line": 640}, "message": "destructor '~CompletionTest_ScopedWithFilter_Test' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clangd/unittests/CodeCompleteTests.cpp", "reportHash": "c9ba7e702b032b22ee15ff44acba7463", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 42, "file": 24, "line": 2187}, "message": "expanded from macro 'TEST'"}, {"location": {"col": 3, "file": 24, "line": 2181}, "message": "expanded from macro 'GTEST_TEST'"}, {"location": {"col": 7, "file": 25, "line": 1215}, "message": "expanded from macro 'GTEST_TEST_'"}, {"location": {"col": 3, "file": 25, "line": 1211}, "message": "expanded from macro 'GTEST_TEST_CLASS_NAME_'"}, {"location": {"col": 1, "file": 22, "line": 649}, "message": "destructor '~CompletionTest_ReferencesAffectRanking_Test' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clangd/unittests/CodeCompleteTests.cpp", "reportHash": "ef4630915b632b78a9f2a58d3bf9fed1", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 42, "file": 24, "line": 2187}, "message": "expanded from macro 'TEST'"}, {"location": {"col": 3, "file": 24, "line": 2181}, "message": "expanded from macro 'GTEST_TEST'"}, {"location": {"col": 7, "file": 25, "line": 1215}, "message": "expanded from macro 'GTEST_TEST_'"}, {"location": {"col": 3, "file": 25, "line": 1211}, "message": "expanded from macro 'GTEST_TEST_CLASS_NAME_'"}, {"location": {"col": 1, "file": 22, "line": 659}, "message": "destructor '~CompletionTest_ContextWords_Test' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clangd/unittests/CodeCompleteTests.cpp", "reportHash": "655c3be4b932a5b91dfc5d3b05aab76a", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 42, "file": 24, "line": 2187}, "message": "expanded from macro 'TEST'"}, {"location": {"col": 3, "file": 24, "line": 2181}, "message": "expanded from macro 'GTEST_TEST'"}, {"location": {"col": 7, "file": 25, "line": 1215}, "message": "expanded from macro 'GTEST_TEST_'"}, {"location": {"col": 3, "file": 25, "line": 1211}, "message": "expanded from macro 'GTEST_TEST_CLASS_NAME_'"}, {"location": {"col": 1, "file": 22, "line": 674}, "message": "destructor '~CompletionTest_GlobalQualified_Test' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clangd/unittests/CodeCompleteTests.cpp", "reportHash": "a5d1b064a1bafe9c633dc7946c40bad2", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 42, "file": 24, "line": 2187}, "message": "expanded from macro 'TEST'"}, {"location": {"col": 3, "file": 24, "line": 2181}, "message": "expanded from macro 'GTEST_TEST'"}, {"location": {"col": 7, "file": 25, "line": 1215}, "message": "expanded from macro 'GTEST_TEST_'"}, {"location": {"col": 3, "file": 25, "line": 1211}, "message": "expanded from macro 'GTEST_TEST_CLASS_NAME_'"}, {"location": {"col": 1, "file": 22, "line": 685}, "message": "destructor '~CompletionTest_FullyQualified_Test' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clangd/unittests/CodeCompleteTests.cpp", "reportHash": "f1f4f8fc74185bcdb74b5ae9ebaba87b", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 42, "file": 24, "line": 2187}, "message": "expanded from macro 'TEST'"}, {"location": {"col": 3, "file": 24, "line": 2181}, "message": "expanded from macro 'GTEST_TEST'"}, {"location": {"col": 7, "file": 25, "line": 1215}, "message": "expanded from macro 'GTEST_TEST_'"}, {"location": {"col": 3, "file": 25, "line": 1211}, "message": "expanded from macro 'GTEST_TEST_CLASS_NAME_'"}, {"location": {"col": 1, "file": 22, "line": 697}, "message": "destructor '~CompletionTest_SemaIndexMerge_Test' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clangd/unittests/CodeCompleteTests.cpp", "reportHash": "0cf4fba1ad10251af602940edb974380", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 42, "file": 24, "line": 2187}, "message": "expanded from macro 'TEST'"}, {"location": {"col": 3, "file": 24, "line": 2181}, "message": "expanded from macro 'GTEST_TEST'"}, {"location": {"col": 7, "file": 25, "line": 1215}, "message": "expanded from macro 'GTEST_TEST_'"}, {"location": {"col": 3, "file": 25, "line": 1211}, "message": "expanded from macro 'GTEST_TEST_CLASS_NAME_'"}, {"location": {"col": 1, "file": 22, "line": 713}, "message": "destructor '~CompletionTest_SemaIndexMergeWithLimit_Test' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clangd/unittests/CodeCompleteTests.cpp", "reportHash": "f3e8d1821e87f10685b2b194e6c891b0", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 42, "file": 24, "line": 2187}, "message": "expanded from macro 'TEST'"}, {"location": {"col": 3, "file": 24, "line": 2181}, "message": "expanded from macro 'GTEST_TEST'"}, {"location": {"col": 7, "file": 25, "line": 1215}, "message": "expanded from macro 'GTEST_TEST_'"}, {"location": {"col": 3, "file": 25, "line": 1211}, "message": "expanded from macro 'GTEST_TEST_CLASS_NAME_'"}, {"location": {"col": 1, "file": 22, "line": 726}, "message": "destructor '~CompletionTest_IncludeInsertionPreprocessorIntegrationTests_Test' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clangd/unittests/CodeCompleteTests.cpp", "reportHash": "cb4df88efeb30ffa063b709d10e537a0", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 42, "file": 24, "line": 2187}, "message": "expanded from macro 'TEST'"}, {"location": {"col": 3, "file": 24, "line": 2181}, "message": "expanded from macro 'GTEST_TEST'"}, {"location": {"col": 7, "file": 25, "line": 1215}, "message": "expanded from macro 'GTEST_TEST_'"}, {"location": {"col": 3, "file": 25, "line": 1211}, "message": "expanded from macro 'GTEST_TEST_CLASS_NAME_'"}, {"location": {"col": 1, "file": 22, "line": 758}, "message": "destructor '~CompletionTest_NoIncludeInsertionWhenDeclFoundInFile_Test' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clangd/unittests/CodeCompleteTests.cpp", "reportHash": "b8ca5b90b33a083fcfa42670c4fa5299", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 42, "file": 24, "line": 2187}, "message": "expanded from macro 'TEST'"}, {"location": {"col": 3, "file": 24, "line": 2181}, "message": "expanded from macro 'GTEST_TEST'"}, {"location": {"col": 7, "file": 25, "line": 1215}, "message": "expanded from macro 'GTEST_TEST_'"}, {"location": {"col": 3, "file": 25, "line": 1211}, "message": "expanded from macro 'GTEST_TEST_CLASS_NAME_'"}, {"location": {"col": 1, "file": 22, "line": 781}, "message": "destructor '~CompletionTest_IndexSuppressesPreambleCompletions_Test' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clangd/unittests/CodeCompleteTests.cpp", "reportHash": "2cea6b3c0d99608b0288bf9729b3782f", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 42, "file": 24, "line": 2187}, "message": "expanded from macro 'TEST'"}, {"location": {"col": 3, "file": 24, "line": 2181}, "message": "expanded from macro 'GTEST_TEST'"}, {"location": {"col": 7, "file": 25, "line": 1215}, "message": "expanded from macro 'GTEST_TEST_'"}, {"location": {"col": 3, "file": 25, "line": 1211}, "message": "expanded from macro 'GTEST_TEST_CLASS_NAME_'"}, {"location": {"col": 1, "file": 22, "line": 811}, "message": "destructor '~CompletionTest_CompletionInPreamble_Test' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clangd/unittests/CodeCompleteTests.cpp", "reportHash": "05a21ffea1b90e3493f0998c3d661761", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 42, "file": 24, "line": 2187}, "message": "expanded from macro 'TEST'"}, {"location": {"col": 3, "file": 24, "line": 2181}, "message": "expanded from macro 'GTEST_TEST'"}, {"location": {"col": 7, "file": 25, "line": 1215}, "message": "expanded from macro 'GTEST_TEST_'"}, {"location": {"col": 3, "file": 25, "line": 1211}, "message": "expanded from macro 'GTEST_TEST_CLASS_NAME_'"}, {"location": {"col": 1, "file": 22, "line": 823}, "message": "destructor '~CompletionTest_CompletionRecoveryASTType_Test' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clangd/unittests/CodeCompleteTests.cpp", "reportHash": "c006b3503eb029bb0fab8d23456452f6", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 42, "file": 24, "line": 2187}, "message": "expanded from macro 'TEST'"}, {"location": {"col": 3, "file": 24, "line": 2181}, "message": "expanded from macro 'GTEST_TEST'"}, {"location": {"col": 7, "file": 25, "line": 1215}, "message": "expanded from macro 'GTEST_TEST_'"}, {"location": {"col": 3, "file": 25, "line": 1211}, "message": "expanded from macro 'GTEST_TEST_CLASS_NAME_'"}, {"location": {"col": 1, "file": 22, "line": 835}, "message": "destructor '~CompletionTest_DynamicIndexIncludeInsertion_Test' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clangd/unittests/CodeCompleteTests.cpp", "reportHash": "b5d755620d8c2bdfae3ba4f82c060e1f", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 42, "file": 24, "line": 2187}, "message": "expanded from macro 'TEST'"}, {"location": {"col": 3, "file": 24, "line": 2181}, "message": "expanded from macro 'GTEST_TEST'"}, {"location": {"col": 7, "file": 25, "line": 1215}, "message": "expanded from macro 'GTEST_TEST_'"}, {"location": {"col": 3, "file": 25, "line": 1211}, "message": "expanded from macro 'GTEST_TEST_CLASS_NAME_'"}, {"location": {"col": 1, "file": 22, "line": 870}, "message": "destructor '~CompletionTest_DynamicIndexMultiFile_Test' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clangd/unittests/CodeCompleteTests.cpp", "reportHash": "7fbc873ba8b3600bc3b3cd47d4564afe", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 42, "file": 24, "line": 2187}, "message": "expanded from macro 'TEST'"}, {"location": {"col": 3, "file": 24, "line": 2181}, "message": "expanded from macro 'GTEST_TEST'"}, {"location": {"col": 7, "file": 25, "line": 1215}, "message": "expanded from macro 'GTEST_TEST_'"}, {"location": {"col": 3, "file": 25, "line": 1211}, "message": "expanded from macro 'GTEST_TEST_CLASS_NAME_'"}, {"location": {"col": 1, "file": 22, "line": 906}, "message": "destructor '~CompletionTest_Documentation_Test' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clangd/unittests/CodeCompleteTests.cpp", "reportHash": "560f7d0d9a47716ffe8593de1ed52b94", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 42, "file": 24, "line": 2187}, "message": "expanded from macro 'TEST'"}, {"location": {"col": 3, "file": 24, "line": 2181}, "message": "expanded from macro 'GTEST_TEST'"}, {"location": {"col": 7, "file": 25, "line": 1215}, "message": "expanded from macro 'GTEST_TEST_'"}, {"location": {"col": 3, "file": 25, "line": 1211}, "message": "expanded from macro 'GTEST_TEST_CLASS_NAME_'"}, {"location": {"col": 1, "file": 22, "line": 930}, "message": "destructor '~CompletionTest_CommentsFromSystemHeaders_Test' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clangd/unittests/CodeCompleteTests.cpp", "reportHash": "29acfc341702ad0e5e21e52736d56075", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 42, "file": 24, "line": 2187}, "message": "expanded from macro 'TEST'"}, {"location": {"col": 3, "file": 24, "line": 2181}, "message": "expanded from macro 'GTEST_TEST'"}, {"location": {"col": 7, "file": 25, "line": 1215}, "message": "expanded from macro 'GTEST_TEST_'"}, {"location": {"col": 3, "file": 25, "line": 1211}, "message": "expanded from macro 'GTEST_TEST_CLASS_NAME_'"}, {"location": {"col": 1, "file": 22, "line": 960}, "message": "destructor '~CompletionTest_GlobalCompletionFiltering_Test' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clangd/unittests/CodeCompleteTests.cpp", "reportHash": "6b0bbad04327694c9d0a85abef9a26a2", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 42, "file": 24, "line": 2187}, "message": "expanded from macro 'TEST'"}, {"location": {"col": 3, "file": 24, "line": 2181}, "message": "expanded from macro 'GTEST_TEST'"}, {"location": {"col": 7, "file": 25, "line": 1215}, "message": "expanded from macro 'GTEST_TEST_'"}, {"location": {"col": 3, "file": 25, "line": 1211}, "message": "expanded from macro 'GTEST_TEST_CLASS_NAME_'"}, {"location": {"col": 1, "file": 22, "line": 976}, "message": "destructor '~CodeCompleteTest_DisableTypoCorrection_Test' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clangd/unittests/CodeCompleteTests.cpp", "reportHash": "4df41bfb7075f6f1043602eb093be43e", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 42, "file": 24, "line": 2187}, "message": "expanded from macro 'TEST'"}, {"location": {"col": 3, "file": 24, "line": 2181}, "message": "expanded from macro 'GTEST_TEST'"}, {"location": {"col": 7, "file": 25, "line": 1215}, "message": "expanded from macro 'GTEST_TEST_'"}, {"location": {"col": 3, "file": 25, "line": 1211}, "message": "expanded from macro 'GTEST_TEST_CLASS_NAME_'"}, {"location": {"col": 1, "file": 22, "line": 984}, "message": "destructor '~CodeCompleteTest_NoColonColonAtTheEnd_Test' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clangd/unittests/CodeCompleteTests.cpp", "reportHash": "48ed0720ca42379d4c1c97ea951d8180", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 42, "file": 24, "line": 2187}, "message": "expanded from macro 'TEST'"}, {"location": {"col": 3, "file": 24, "line": 2181}, "message": "expanded from macro 'GTEST_TEST'"}, {"location": {"col": 7, "file": 25, "line": 1215}, "message": "expanded from macro 'GTEST_TEST_'"}, {"location": {"col": 3, "file": 25, "line": 1211}, "message": "expanded from macro 'GTEST_TEST_CLASS_NAME_'"}, {"location": {"col": 1, "file": 22, "line": 996}, "message": "destructor '~CompletionTest_BacktrackCrashes_Test' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clangd/unittests/CodeCompleteTests.cpp", "reportHash": "fd7dbe2021ca5f3734dd30624abcf580", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 42, "file": 24, "line": 2187}, "message": "expanded from macro 'TEST'"}, {"location": {"col": 3, "file": 24, "line": 2181}, "message": "expanded from macro 'GTEST_TEST'"}, {"location": {"col": 7, "file": 25, "line": 1215}, "message": "expanded from macro 'GTEST_TEST_'"}, {"location": {"col": 3, "file": 25, "line": 1211}, "message": "expanded from macro 'GTEST_TEST_CLASS_NAME_'"}, {"location": {"col": 1, "file": 22, "line": 1017}, "message": "destructor '~CompletionTest_CompleteInMacroWithStringification_Test' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clangd/unittests/CodeCompleteTests.cpp", "reportHash": "0f8aa1fb601a1046a21197dbfc6b0eea", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 42, "file": 24, "line": 2187}, "message": "expanded from macro 'TEST'"}, {"location": {"col": 3, "file": 24, "line": 2181}, "message": "expanded from macro 'GTEST_TEST'"}, {"location": {"col": 7, "file": 25, "line": 1215}, "message": "expanded from macro 'GTEST_TEST_'"}, {"location": {"col": 3, "file": 25, "line": 1211}, "message": "expanded from macro 'GTEST_TEST_CLASS_NAME_'"}, {"location": {"col": 1, "file": 22, "line": 1036}, "message": "destructor '~CompletionTest_CompleteInMacroAndNamespaceWithStringification_Test' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clangd/unittests/CodeCompleteTests.cpp", "reportHash": "a49e1165f0e644202dd9903ad4ce42ba", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 42, "file": 24, "line": 2187}, "message": "expanded from macro 'TEST'"}, {"location": {"col": 3, "file": 24, "line": 2181}, "message": "expanded from macro 'GTEST_TEST'"}, {"location": {"col": 7, "file": 25, "line": 1215}, "message": "expanded from macro 'GTEST_TEST_'"}, {"location": {"col": 3, "file": 25, "line": 1211}, "message": "expanded from macro 'GTEST_TEST_CLASS_NAME_'"}, {"location": {"col": 1, "file": 22, "line": 1053}, "message": "destructor '~CompletionTest_IgnoreCompleteInExcludedPPBranchWithRecoveryContext_Test' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clangd/unittests/CodeCompleteTests.cpp", "reportHash": "aaf7cd8df4deb84d8410e30765c8e68b", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 42, "file": 24, "line": 2187}, "message": "expanded from macro 'TEST'"}, {"location": {"col": 3, "file": 24, "line": 2181}, "message": "expanded from macro 'GTEST_TEST'"}, {"location": {"col": 7, "file": 25, "line": 1215}, "message": "expanded from macro 'GTEST_TEST_'"}, {"location": {"col": 3, "file": 25, "line": 1211}, "message": "expanded from macro 'GTEST_TEST_CLASS_NAME_'"}, {"location": {"col": 1, "file": 22, "line": 1073}, "message": "destructor '~CompletionTest_DefaultArgs_Test' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clangd/unittests/CodeCompleteTests.cpp", "reportHash": "09af1df40901c59da46db76bc572c74b", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 42, "file": 24, "line": 2187}, "message": "expanded from macro 'TEST'"}, {"location": {"col": 3, "file": 24, "line": 2181}, "message": "expanded from macro 'GTEST_TEST'"}, {"location": {"col": 7, "file": 25, "line": 1215}, "message": "expanded from macro 'GTEST_TEST_'"}, {"location": {"col": 3, "file": 25, "line": 1211}, "message": "expanded from macro 'GTEST_TEST_CLASS_NAME_'"}, {"location": {"col": 1, "file": 22, "line": 1091}, "message": "destructor '~CompletionTest_NoCrashWithTemplateParamsAndPreferredTypes_Test' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clangd/unittests/CodeCompleteTests.cpp", "reportHash": "1aac4661b0551c4ddd89aeadee359b4f", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 42, "file": 24, "line": 2187}, "message": "expanded from macro 'TEST'"}, {"location": {"col": 3, "file": 24, "line": 2181}, "message": "expanded from macro 'GTEST_TEST'"}, {"location": {"col": 7, "file": 25, "line": 1215}, "message": "expanded from macro 'GTEST_TEST_'"}, {"location": {"col": 3, "file": 25, "line": 1211}, "message": "expanded from macro 'GTEST_TEST_CLASS_NAME_'"}, {"location": {"col": 1, "file": 22, "line": 1101}, "message": "destructor '~CompletionTest_NestedTemplateHeuristics_Test' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clangd/unittests/CodeCompleteTests.cpp", "reportHash": "81c5ade0ecc302f9142fbaf965f1a80e", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 42, "file": 24, "line": 2187}, "message": "expanded from macro 'TEST'"}, {"location": {"col": 3, "file": 24, "line": 2181}, "message": "expanded from macro 'GTEST_TEST'"}, {"location": {"col": 7, "file": 25, "line": 1215}, "message": "expanded from macro 'GTEST_TEST_'"}, {"location": {"col": 3, "file": 25, "line": 1211}, "message": "expanded from macro 'GTEST_TEST_CLASS_NAME_'"}, {"location": {"col": 1, "file": 22, "line": 1115}, "message": "destructor '~CompletionTest_RecordCCResultCallback_Test' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clangd/unittests/CodeCompleteTests.cpp", "reportHash": "ca4299ec24924ebf1612ff29ffcdb9bb", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 25, "file": 22, "line": 1118}, "message": "destructor '~' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clangd/unittests/CodeCompleteTests.cpp", "reportHash": "70a55f0ec3faf71429d93158f1e25d4b", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 42, "file": 24, "line": 2187}, "message": "expanded from macro 'TEST'"}, {"location": {"col": 3, "file": 24, "line": 2181}, "message": "expanded from macro 'GTEST_TEST'"}, {"location": {"col": 7, "file": 25, "line": 1215}, "message": "expanded from macro 'GTEST_TEST_'"}, {"location": {"col": 3, "file": 25, "line": 1211}, "message": "expanded from macro 'GTEST_TEST_CLASS_NAME_'"}, {"location": {"col": 1, "file": 22, "line": 1130}, "message": "destructor '~CompletionTest_ASTSignals_Test' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clangd/unittests/CodeCompleteTests.cpp", "reportHash": "7466288ec0d322df28a8a9c17337a8af", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 25, "file": 22, "line": 1138}, "message": "destructor '~' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clangd/unittests/CodeCompleteTests.cpp", "reportHash": "70a55f0ec3faf71429d93158f1e25d4b", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 42, "file": 24, "line": 2187}, "message": "expanded from macro 'TEST'"}, {"location": {"col": 3, "file": 24, "line": 2181}, "message": "expanded from macro 'GTEST_TEST'"}, {"location": {"col": 7, "file": 25, "line": 1215}, "message": "expanded from macro 'GTEST_TEST_'"}, {"location": {"col": 3, "file": 25, "line": 1211}, "message": "expanded from macro 'GTEST_TEST_CLASS_NAME_'"}, {"location": {"col": 1, "file": 22, "line": 1237}, "message": "destructor '~SignatureHelpTest_Overloads_Test' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clangd/unittests/CodeCompleteTests.cpp", "reportHash": "456788832f2de7fd341302d30adebd6e", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 42, "file": 24, "line": 2187}, "message": "expanded from macro 'TEST'"}, {"location": {"col": 3, "file": 24, "line": 2181}, "message": "expanded from macro 'GTEST_TEST'"}, {"location": {"col": 7, "file": 25, "line": 1215}, "message": "expanded from macro 'GTEST_TEST_'"}, {"location": {"col": 3, "file": 25, "line": 1211}, "message": "expanded from macro 'GTEST_TEST_CLASS_NAME_'"}, {"location": {"col": 1, "file": 22, "line": 1256}, "message": "destructor '~SignatureHelpTest_DefaultArgs_Test' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clangd/unittests/CodeCompleteTests.cpp", "reportHash": "648d6cca57e0cee12aed64076a9a04c0", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 42, "file": 24, "line": 2187}, "message": "expanded from macro 'TEST'"}, {"location": {"col": 3, "file": 24, "line": 2181}, "message": "expanded from macro 'GTEST_TEST'"}, {"location": {"col": 7, "file": 25, "line": 1215}, "message": "expanded from macro 'GTEST_TEST_'"}, {"location": {"col": 3, "file": 25, "line": 1211}, "message": "expanded from macro 'GTEST_TEST_CLASS_NAME_'"}, {"location": {"col": 1, "file": 22, "line": 1270}, "message": "destructor '~SignatureHelpTest_ActiveArg_Test' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clangd/unittests/CodeCompleteTests.cpp", "reportHash": "9ac36313079d8b34d6b2220ddbebf280", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 42, "file": 24, "line": 2187}, "message": "expanded from macro 'TEST'"}, {"location": {"col": 3, "file": 24, "line": 2181}, "message": "expanded from macro 'GTEST_TEST'"}, {"location": {"col": 7, "file": 25, "line": 1215}, "message": "expanded from macro 'GTEST_TEST_'"}, {"location": {"col": 3, "file": 25, "line": 1211}, "message": "expanded from macro 'GTEST_TEST_CLASS_NAME_'"}, {"location": {"col": 1, "file": 22, "line": 1281}, "message": "destructor '~SignatureHelpTest_OpeningParen_Test' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clangd/unittests/CodeCompleteTests.cpp", "reportHash": "0d09313b462860ac5ca458703c2e6ac5", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 42, "file": 24, "line": 2187}, "message": "expanded from macro 'TEST'"}, {"location": {"col": 3, "file": 24, "line": 2181}, "message": "expanded from macro 'GTEST_TEST'"}, {"location": {"col": 7, "file": 25, "line": 1215}, "message": "expanded from macro 'GTEST_TEST_'"}, {"location": {"col": 3, "file": 25, "line": 1211}, "message": "expanded from macro 'GTEST_TEST_CLASS_NAME_'"}, {"location": {"col": 1, "file": 22, "line": 1360}, "message": "destructor '~SignatureHelpTest_StalePreamble_Test' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clangd/unittests/CodeCompleteTests.cpp", "reportHash": "a60e48ce0d115f4c10c920831570dd12", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 22, "line": 1384}, "message": "default constructor 'IndexRequestCollector' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clangd/unittests/CodeCompleteTests.cpp", "reportHash": "8b5a01c456a7c6d3b88a70da867adc37", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 22, "line": 1384}, "message": "destructor '~IndexRequestCollector' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clangd/unittests/CodeCompleteTests.cpp", "reportHash": "c18af9389412cd2e16fe41a5a841f131", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 42, "file": 24, "line": 2187}, "message": "expanded from macro 'TEST'"}, {"location": {"col": 3, "file": 24, "line": 2181}, "message": "expanded from macro 'GTEST_TEST'"}, {"location": {"col": 7, "file": 25, "line": 1215}, "message": "expanded from macro 'GTEST_TEST_'"}, {"location": {"col": 3, "file": 25, "line": 1211}, "message": "expanded from macro 'GTEST_TEST_CLASS_NAME_'"}, {"location": {"col": 1, "file": 22, "line": 1444}, "message": "destructor '~CompletionTest_UnqualifiedIdQuery_Test' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clangd/unittests/CodeCompleteTests.cpp", "reportHash": "d2a65898e47c4220492bc3cbf0f07b1e", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 42, "file": 24, "line": 2187}, "message": "expanded from macro 'TEST'"}, {"location": {"col": 3, "file": 24, "line": 2181}, "message": "expanded from macro 'GTEST_TEST'"}, {"location": {"col": 7, "file": 25, "line": 1215}, "message": "expanded from macro 'GTEST_TEST_'"}, {"location": {"col": 3, "file": 25, "line": 1211}, "message": "expanded from macro 'GTEST_TEST_CLASS_NAME_'"}, {"location": {"col": 1, "file": 22, "line": 1460}, "message": "destructor '~CompletionTest_EnclosingScopeComesFirst_Test' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clangd/unittests/CodeCompleteTests.cpp", "reportHash": "80036fae8bdb9aef3f774dd57138b488", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 42, "file": 24, "line": 2187}, "message": "expanded from macro 'TEST'"}, {"location": {"col": 3, "file": 24, "line": 2181}, "message": "expanded from macro 'GTEST_TEST'"}, {"location": {"col": 7, "file": 25, "line": 1215}, "message": "expanded from macro 'GTEST_TEST_'"}, {"location": {"col": 3, "file": 25, "line": 1211}, "message": "expanded from macro 'GTEST_TEST_CLASS_NAME_'"}, {"location": {"col": 1, "file": 22, "line": 1482}, "message": "destructor '~CompletionTest_ResolvedQualifiedIdQuery_Test' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clangd/unittests/CodeCompleteTests.cpp", "reportHash": "a02d0f938744c041324aadd37155c902", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 42, "file": 24, "line": 2187}, "message": "expanded from macro 'TEST'"}, {"location": {"col": 3, "file": 24, "line": 2181}, "message": "expanded from macro 'GTEST_TEST'"}, {"location": {"col": 7, "file": 25, "line": 1215}, "message": "expanded from macro 'GTEST_TEST_'"}, {"location": {"col": 3, "file": 25, "line": 1211}, "message": "expanded from macro 'GTEST_TEST_CLASS_NAME_'"}, {"location": {"col": 1, "file": 22, "line": 1504}, "message": "destructor '~CompletionTest_UnresolvedQualifierIdQuery_Test' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clangd/unittests/CodeCompleteTests.cpp", "reportHash": "b05bf16c83cef16ea30d99b13abad06a", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 42, "file": 24, "line": 2187}, "message": "expanded from macro 'TEST'"}, {"location": {"col": 3, "file": 24, "line": 2181}, "message": "expanded from macro 'GTEST_TEST'"}, {"location": {"col": 7, "file": 25, "line": 1215}, "message": "expanded from macro 'GTEST_TEST_'"}, {"location": {"col": 3, "file": 25, "line": 1211}, "message": "expanded from macro 'GTEST_TEST_CLASS_NAME_'"}, {"location": {"col": 1, "file": 22, "line": 1521}, "message": "destructor '~CompletionTest_UnresolvedNestedQualifierIdQuery_Test' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clangd/unittests/CodeCompleteTests.cpp", "reportHash": "5e5efb03ad39a8a6981e9655072cc9a6", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 42, "file": 24, "line": 2187}, "message": "expanded from macro 'TEST'"}, {"location": {"col": 3, "file": 24, "line": 2181}, "message": "expanded from macro 'GTEST_TEST'"}, {"location": {"col": 7, "file": 25, "line": 1215}, "message": "expanded from macro 'GTEST_TEST_'"}, {"location": {"col": 3, "file": 25, "line": 1211}, "message": "expanded from macro 'GTEST_TEST_CLASS_NAME_'"}, {"location": {"col": 1, "file": 22, "line": 1536}, "message": "destructor '~CompletionTest_EmptyQualifiedQuery_Test' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clangd/unittests/CodeCompleteTests.cpp", "reportHash": "512e6fbf45d412df2db035a535d81482", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 42, "file": 24, "line": 2187}, "message": "expanded from macro 'TEST'"}, {"location": {"col": 3, "file": 24, "line": 2181}, "message": "expanded from macro 'GTEST_TEST'"}, {"location": {"col": 7, "file": 25, "line": 1215}, "message": "expanded from macro 'GTEST_TEST_'"}, {"location": {"col": 3, "file": 25, "line": 1211}, "message": "expanded from macro 'GTEST_TEST_CLASS_NAME_'"}, {"location": {"col": 1, "file": 22, "line": 1549}, "message": "destructor '~CompletionTest_GlobalQualifiedQuery_Test' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clangd/unittests/CodeCompleteTests.cpp", "reportHash": "084c1497e4186638b99ce7fb1a2b4410", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 42, "file": 24, "line": 2187}, "message": "expanded from macro 'TEST'"}, {"location": {"col": 3, "file": 24, "line": 2181}, "message": "expanded from macro 'GTEST_TEST'"}, {"location": {"col": 7, "file": 25, "line": 1215}, "message": "expanded from macro 'GTEST_TEST_'"}, {"location": {"col": 3, "file": 25, "line": 1211}, "message": "expanded from macro 'GTEST_TEST_CLASS_NAME_'"}, {"location": {"col": 1, "file": 22, "line": 1562}, "message": "destructor '~CompletionTest_NoDuplicatedQueryScopes_Test' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clangd/unittests/CodeCompleteTests.cpp", "reportHash": "a51ea20eabc33298d34edc57365225d1", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 42, "file": 24, "line": 2187}, "message": "expanded from macro 'TEST'"}, {"location": {"col": 3, "file": 24, "line": 2181}, "message": "expanded from macro 'GTEST_TEST'"}, {"location": {"col": 7, "file": 25, "line": 1215}, "message": "expanded from macro 'GTEST_TEST_'"}, {"location": {"col": 3, "file": 25, "line": 1211}, "message": "expanded from macro 'GTEST_TEST_CLASS_NAME_'"}, {"location": {"col": 1, "file": 22, "line": 1579}, "message": "destructor '~CompletionTest_NoIndexCompletionsInsideClasses_Test' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clangd/unittests/CodeCompleteTests.cpp", "reportHash": "a007766f5710d4624059957ea613451d", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 42, "file": 24, "line": 2187}, "message": "expanded from macro 'TEST'"}, {"location": {"col": 3, "file": 24, "line": 2181}, "message": "expanded from macro 'GTEST_TEST'"}, {"location": {"col": 7, "file": 25, "line": 1215}, "message": "expanded from macro 'GTEST_TEST_'"}, {"location": {"col": 3, "file": 25, "line": 1211}, "message": "expanded from macro 'GTEST_TEST_CLASS_NAME_'"}, {"location": {"col": 1, "file": 22, "line": 1596}, "message": "destructor '~CompletionTest_NoIndexCompletionsInsideDependentCode_Test' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clangd/unittests/CodeCompleteTests.cpp", "reportHash": "3d9e554a255625e68d75e4fba64af6ee", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 42, "file": 24, "line": 2187}, "message": "expanded from macro 'TEST'"}, {"location": {"col": 3, "file": 24, "line": 2181}, "message": "expanded from macro 'GTEST_TEST'"}, {"location": {"col": 7, "file": 25, "line": 1215}, "message": "expanded from macro 'GTEST_TEST_'"}, {"location": {"col": 3, "file": 25, "line": 1211}, "message": "expanded from macro 'GTEST_TEST_CLASS_NAME_'"}, {"location": {"col": 1, "file": 22, "line": 1640}, "message": "destructor '~CompletionTest_OverloadBundling_Test' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clangd/unittests/CodeCompleteTests.cpp", "reportHash": "a2edc43ce3d9882a1586f094cffe5d2d", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 42, "file": 24, "line": 2187}, "message": "expanded from macro 'TEST'"}, {"location": {"col": 3, "file": 24, "line": 2181}, "message": "expanded from macro 'GTEST_TEST'"}, {"location": {"col": 7, "file": 25, "line": 1215}, "message": "expanded from macro 'GTEST_TEST_'"}, {"location": {"col": 3, "file": 25, "line": 1211}, "message": "expanded from macro 'GTEST_TEST_CLASS_NAME_'"}, {"location": {"col": 1, "file": 22, "line": 1691}, "message": "destructor '~CompletionTest_OverloadBundlingSameFileDifferentURI_Test' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clangd/unittests/CodeCompleteTests.cpp", "reportHash": "d8bbbe331be0eb75e3e87c58a1e06be6", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 42, "file": 24, "line": 2187}, "message": "expanded from macro 'TEST'"}, {"location": {"col": 3, "file": 24, "line": 2181}, "message": "expanded from macro 'GTEST_TEST'"}, {"location": {"col": 7, "file": 25, "line": 1215}, "message": "expanded from macro 'GTEST_TEST_'"}, {"location": {"col": 3, "file": 25, "line": 1211}, "message": "expanded from macro 'GTEST_TEST_CLASS_NAME_'"}, {"location": {"col": 1, "file": 22, "line": 1714}, "message": "destructor '~CompletionTest_DocumentationFromChangedFileCrash_Test' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clangd/unittests/CodeCompleteTests.cpp", "reportHash": "5ab7bbfa124d5e79e025479882ffc36a", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 42, "file": 24, "line": 2187}, "message": "expanded from macro 'TEST'"}, {"location": {"col": 3, "file": 24, "line": 2181}, "message": "expanded from macro 'GTEST_TEST'"}, {"location": {"col": 7, "file": 25, "line": 1215}, "message": "expanded from macro 'GTEST_TEST_'"}, {"location": {"col": 3, "file": 25, "line": 1211}, "message": "expanded from macro 'GTEST_TEST_CLASS_NAME_'"}, {"location": {"col": 1, "file": 22, "line": 1752}, "message": "destructor '~CompletionTest_NonDocComments_Test' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clangd/unittests/CodeCompleteTests.cpp", "reportHash": "26bd30b0c3960157a85705fa3295fda4", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 42, "file": 24, "line": 2187}, "message": "expanded from macro 'TEST'"}, {"location": {"col": 3, "file": 24, "line": 2181}, "message": "expanded from macro 'GTEST_TEST'"}, {"location": {"col": 7, "file": 25, "line": 1215}, "message": "expanded from macro 'GTEST_TEST_'"}, {"location": {"col": 3, "file": 25, "line": 1211}, "message": "expanded from macro 'GTEST_TEST_CLASS_NAME_'"}, {"location": {"col": 1, "file": 22, "line": 1805}, "message": "destructor '~CompletionTest_CompleteOnInvalidLine_Test' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clangd/unittests/CodeCompleteTests.cpp", "reportHash": "cafdc4feda46152554764bc079f3a1cb", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 42, "file": 24, "line": 2187}, "message": "expanded from macro 'TEST'"}, {"location": {"col": 3, "file": 24, "line": 2181}, "message": "expanded from macro 'GTEST_TEST'"}, {"location": {"col": 7, "file": 25, "line": 1215}, "message": "expanded from macro 'GTEST_TEST_'"}, {"location": {"col": 3, "file": 25, "line": 1211}, "message": "expanded from macro 'GTEST_TEST_CLASS_NAME_'"}, {"location": {"col": 1, "file": 22, "line": 1822}, "message": "destructor '~CompletionTest_QualifiedNames_Test' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clangd/unittests/CodeCompleteTests.cpp", "reportHash": "b097cebfbedeb612d2a993fb92f5c737", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 42, "file": 24, "line": 2187}, "message": "expanded from macro 'TEST'"}, {"location": {"col": 3, "file": 24, "line": 2181}, "message": "expanded from macro 'GTEST_TEST'"}, {"location": {"col": 7, "file": 25, "line": 1215}, "message": "expanded from macro 'GTEST_TEST_'"}, {"location": {"col": 3, "file": 25, "line": 1211}, "message": "expanded from macro 'GTEST_TEST_CLASS_NAME_'"}, {"location": {"col": 1, "file": 22, "line": 1835}, "message": "destructor '~CompletionTest_Render_Test' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clangd/unittests/CodeCompleteTests.cpp", "reportHash": "3ee069a8245534320eb3661b7f7a0835", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 42, "file": 24, "line": 2187}, "message": "expanded from macro 'TEST'"}, {"location": {"col": 3, "file": 24, "line": 2181}, "message": "expanded from macro 'GTEST_TEST'"}, {"location": {"col": 7, "file": 25, "line": 1215}, "message": "expanded from macro 'GTEST_TEST_'"}, {"location": {"col": 3, "file": 25, "line": 1211}, "message": "expanded from macro 'GTEST_TEST_CLASS_NAME_'"}, {"location": {"col": 1, "file": 22, "line": 1898}, "message": "destructor '~CompletionTest_IgnoreRecoveryResults_Test' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clangd/unittests/CodeCompleteTests.cpp", "reportHash": "8e7b95f0b03a13fda2ed030e58de0313", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 42, "file": 24, "line": 2187}, "message": "expanded from macro 'TEST'"}, {"location": {"col": 3, "file": 24, "line": 2181}, "message": "expanded from macro 'GTEST_TEST'"}, {"location": {"col": 7, "file": 25, "line": 1215}, "message": "expanded from macro 'GTEST_TEST_'"}, {"location": {"col": 3, "file": 25, "line": 1211}, "message": "expanded from macro 'GTEST_TEST_CLASS_NAME_'"}, {"location": {"col": 1, "file": 22, "line": 1910}, "message": "destructor '~CompletionTest_ScopeOfClassFieldInConstructorInitializer_Test' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clangd/unittests/CodeCompleteTests.cpp", "reportHash": "9368f9d9d07b468aa69935878a73e271", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 42, "file": 24, "line": 2187}, "message": "expanded from macro 'TEST'"}, {"location": {"col": 3, "file": 24, "line": 2181}, "message": "expanded from macro 'GTEST_TEST'"}, {"location": {"col": 7, "file": 25, "line": 1215}, "message": "expanded from macro 'GTEST_TEST_'"}, {"location": {"col": 3, "file": 25, "line": 1211}, "message": "expanded from macro 'GTEST_TEST_CLASS_NAME_'"}, {"location": {"col": 1, "file": 22, "line": 1922}, "message": "destructor '~CompletionTest_CodeCompletionContext_Test' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clangd/unittests/CodeCompleteTests.cpp", "reportHash": "9efe54d02220157e581c7046bc9146fe", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 42, "file": 24, "line": 2187}, "message": "expanded from macro 'TEST'"}, {"location": {"col": 3, "file": 24, "line": 2181}, "message": "expanded from macro 'GTEST_TEST'"}, {"location": {"col": 7, "file": 25, "line": 1215}, "message": "expanded from macro 'GTEST_TEST_'"}, {"location": {"col": 3, "file": 25, "line": 1211}, "message": "expanded from macro 'GTEST_TEST_CLASS_NAME_'"}, {"location": {"col": 1, "file": 22, "line": 1937}, "message": "destructor '~CompletionTest_FixItForArrowToDot_Test' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clangd/unittests/CodeCompleteTests.cpp", "reportHash": "0a807de2d7b609d02c3ff423b56c53e3", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 42, "file": 24, "line": 2187}, "message": "expanded from macro 'TEST'"}, {"location": {"col": 3, "file": 24, "line": 2181}, "message": "expanded from macro 'GTEST_TEST'"}, {"location": {"col": 7, "file": 25, "line": 1215}, "message": "expanded from macro 'GTEST_TEST_'"}, {"location": {"col": 3, "file": 25, "line": 1211}, "message": "expanded from macro 'GTEST_TEST_CLASS_NAME_'"}, {"location": {"col": 1, "file": 22, "line": 1974}, "message": "destructor '~CompletionTest_FixItForDotToArrow_Test' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clangd/unittests/CodeCompleteTests.cpp", "reportHash": "c9f99b433b5146cba511b8a4a210d3fb", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 42, "file": 24, "line": 2187}, "message": "expanded from macro 'TEST'"}, {"location": {"col": 3, "file": 24, "line": 2181}, "message": "expanded from macro 'GTEST_TEST'"}, {"location": {"col": 7, "file": 25, "line": 1215}, "message": "expanded from macro 'GTEST_TEST_'"}, {"location": {"col": 3, "file": 25, "line": 1211}, "message": "expanded from macro 'GTEST_TEST_CLASS_NAME_'"}, {"location": {"col": 1, "file": 22, "line": 2008}, "message": "destructor '~CompletionTest_RenderWithFixItMerged_Test' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clangd/unittests/CodeCompleteTests.cpp", "reportHash": "6664ab13484d2b4f21a7c9dc952e14e4", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 42, "file": 24, "line": 2187}, "message": "expanded from macro 'TEST'"}, {"location": {"col": 3, "file": 24, "line": 2181}, "message": "expanded from macro 'GTEST_TEST'"}, {"location": {"col": 7, "file": 25, "line": 1215}, "message": "expanded from macro 'GTEST_TEST_'"}, {"location": {"col": 3, "file": 25, "line": 1211}, "message": "expanded from macro 'GTEST_TEST_CLASS_NAME_'"}, {"location": {"col": 1, "file": 22, "line": 2028}, "message": "destructor '~CompletionTest_RenderWithFixItNonMerged_Test' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clangd/unittests/CodeCompleteTests.cpp", "reportHash": "a7d725c1563b2949a681ce47174c2585", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 42, "file": 24, "line": 2187}, "message": "expanded from macro 'TEST'"}, {"location": {"col": 3, "file": 24, "line": 2181}, "message": "expanded from macro 'GTEST_TEST'"}, {"location": {"col": 7, "file": 25, "line": 1215}, "message": "expanded from macro 'GTEST_TEST_'"}, {"location": {"col": 3, "file": 25, "line": 1211}, "message": "expanded from macro 'GTEST_TEST_CLASS_NAME_'"}, {"location": {"col": 1, "file": 22, "line": 2048}, "message": "destructor '~CompletionTest_CompletionTokenRange_Test' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clangd/unittests/CodeCompleteTests.cpp", "reportHash": "6a996b25af3bbc6a131d77dc9830c4e0", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 42, "file": 24, "line": 2187}, "message": "expanded from macro 'TEST'"}, {"location": {"col": 3, "file": 24, "line": 2181}, "message": "expanded from macro 'GTEST_TEST'"}, {"location": {"col": 7, "file": 25, "line": 1215}, "message": "expanded from macro 'GTEST_TEST_'"}, {"location": {"col": 3, "file": 25, "line": 1211}, "message": "expanded from macro 'GTEST_TEST_CLASS_NAME_'"}, {"location": {"col": 1, "file": 22, "line": 2095}, "message": "destructor '~SignatureHelpTest_OverloadsOrdering_Test' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clangd/unittests/CodeCompleteTests.cpp", "reportHash": "3a7433a01b23a9fa48fe50bc227d9694", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 42, "file": 24, "line": 2187}, "message": "expanded from macro 'TEST'"}, {"location": {"col": 3, "file": 24, "line": 2181}, "message": "expanded from macro 'GTEST_TEST'"}, {"location": {"col": 7, "file": 25, "line": 1215}, "message": "expanded from macro 'GTEST_TEST_'"}, {"location": {"col": 3, "file": 25, "line": 1211}, "message": "expanded from macro 'GTEST_TEST_CLASS_NAME_'"}, {"location": {"col": 1, "file": 22, "line": 2115}, "message": "destructor '~SignatureHelpTest_InstantiatedSignatures_Test' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clangd/unittests/CodeCompleteTests.cpp", "reportHash": "5b2d899172ae70536ccb2a3f0fed1fd8", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 42, "file": 24, "line": 2187}, "message": "expanded from macro 'TEST'"}, {"location": {"col": 3, "file": 24, "line": 2181}, "message": "expanded from macro 'GTEST_TEST'"}, {"location": {"col": 7, "file": 25, "line": 1215}, "message": "expanded from macro 'GTEST_TEST_'"}, {"location": {"col": 3, "file": 25, "line": 1211}, "message": "expanded from macro 'GTEST_TEST_CLASS_NAME_'"}, {"location": {"col": 1, "file": 22, "line": 2172}, "message": "destructor '~SignatureHelpTest_IndexDocumentation_Test' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clangd/unittests/CodeCompleteTests.cpp", "reportHash": "0384492d0d3547934c9eea2751f2eaaa", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 42, "file": 24, "line": 2187}, "message": "expanded from macro 'TEST'"}, {"location": {"col": 3, "file": 24, "line": 2181}, "message": "expanded from macro 'GTEST_TEST'"}, {"location": {"col": 7, "file": 25, "line": 1215}, "message": "expanded from macro 'GTEST_TEST_'"}, {"location": {"col": 3, "file": 25, "line": 1211}, "message": "expanded from macro 'GTEST_TEST_CLASS_NAME_'"}, {"location": {"col": 1, "file": 22, "line": 2213}, "message": "destructor '~SignatureHelpTest_DynamicIndexDocumentation_Test' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clangd/unittests/CodeCompleteTests.cpp", "reportHash": "0944c83e50010f8401591794ea9a8ed1", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 42, "file": 24, "line": 2187}, "message": "expanded from macro 'TEST'"}, {"location": {"col": 3, "file": 24, "line": 2181}, "message": "expanded from macro 'GTEST_TEST'"}, {"location": {"col": 7, "file": 25, "line": 1215}, "message": "expanded from macro 'GTEST_TEST_'"}, {"location": {"col": 3, "file": 25, "line": 1211}, "message": "expanded from macro 'GTEST_TEST_CLASS_NAME_'"}, {"location": {"col": 1, "file": 22, "line": 2243}, "message": "destructor '~CompletionTest_CompletionFunctionArgsDisabled_Test' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clangd/unittests/CodeCompleteTests.cpp", "reportHash": "1ee6898728bd52be0feb68e39c8ff3ba", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 42, "file": 24, "line": 2187}, "message": "expanded from macro 'TEST'"}, {"location": {"col": 3, "file": 24, "line": 2181}, "message": "expanded from macro 'GTEST_TEST'"}, {"location": {"col": 7, "file": 25, "line": 1215}, "message": "expanded from macro 'GTEST_TEST_'"}, {"location": {"col": 3, "file": 25, "line": 1211}, "message": "expanded from macro 'GTEST_TEST_CLASS_NAME_'"}, {"location": {"col": 1, "file": 22, "line": 2308}, "message": "destructor '~CompletionTest_SuggestOverrides_Test' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clangd/unittests/CodeCompleteTests.cpp", "reportHash": "4898de7457f478496c892be1c2b39bdf", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 42, "file": 24, "line": 2187}, "message": "expanded from macro 'TEST'"}, {"location": {"col": 3, "file": 24, "line": 2181}, "message": "expanded from macro 'GTEST_TEST'"}, {"location": {"col": 7, "file": 25, "line": 1215}, "message": "expanded from macro 'GTEST_TEST_'"}, {"location": {"col": 3, "file": 25, "line": 1211}, "message": "expanded from macro 'GTEST_TEST_CLASS_NAME_'"}, {"location": {"col": 1, "file": 22, "line": 2336}, "message": "destructor '~CompletionTest_OverridesNonIdentName_Test' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clangd/unittests/CodeCompleteTests.cpp", "reportHash": "5d42ad7a8e2659db3f7d30370bc26041", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 42, "file": 24, "line": 2187}, "message": "expanded from macro 'TEST'"}, {"location": {"col": 3, "file": 24, "line": 2181}, "message": "expanded from macro 'GTEST_TEST'"}, {"location": {"col": 7, "file": 25, "line": 1215}, "message": "expanded from macro 'GTEST_TEST_'"}, {"location": {"col": 3, "file": 25, "line": 1211}, "message": "expanded from macro 'GTEST_TEST_CLASS_NAME_'"}, {"location": {"col": 1, "file": 22, "line": 2351}, "message": "destructor '~GuessCompletionPrefix_Filters_Test' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clangd/unittests/CodeCompleteTests.cpp", "reportHash": "41cf22009eaee7aae5e71feab28d00e1", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 42, "file": 24, "line": 2187}, "message": "expanded from macro 'TEST'"}, {"location": {"col": 3, "file": 24, "line": 2181}, "message": "expanded from macro 'GTEST_TEST'"}, {"location": {"col": 7, "file": 25, "line": 1215}, "message": "expanded from macro 'GTEST_TEST_'"}, {"location": {"col": 3, "file": 25, "line": 1211}, "message": "expanded from macro 'GTEST_TEST_CLASS_NAME_'"}, {"location": {"col": 1, "file": 22, "line": 2385}, "message": "destructor '~CompletionTest_EnableSpeculativeIndexRequest_Test' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clangd/unittests/CodeCompleteTests.cpp", "reportHash": "3c4bd7d752c38e5a2f1ed8f095a34178", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 26, "file": 22, "line": 2403}, "message": "destructor '~' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clangd/unittests/CodeCompleteTests.cpp", "reportHash": "9cd542e0c96050533514cb4b22c60dc2", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 26, "file": 22, "line": 2403}, "message": "move constructor '' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clangd/unittests/CodeCompleteTests.cpp", "reportHash": "21bdac9d5a8e5566bb68d36a407e8f82", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 42, "file": 24, "line": 2187}, "message": "expanded from macro 'TEST'"}, {"location": {"col": 3, "file": 24, "line": 2181}, "message": "expanded from macro 'GTEST_TEST'"}, {"location": {"col": 7, "file": 25, "line": 1215}, "message": "expanded from macro 'GTEST_TEST_'"}, {"location": {"col": 3, "file": 25, "line": 1211}, "message": "expanded from macro 'GTEST_TEST_CLASS_NAME_'"}, {"location": {"col": 1, "file": 22, "line": 2425}, "message": "destructor '~CompletionTest_InsertTheMostPopularHeader_Test' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clangd/unittests/CodeCompleteTests.cpp", "reportHash": "c80dfb3955a9c8076bda77f6f96f8456", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 42, "file": 24, "line": 2187}, "message": "expanded from macro 'TEST'"}, {"location": {"col": 3, "file": 24, "line": 2181}, "message": "expanded from macro 'GTEST_TEST'"}, {"location": {"col": 7, "file": 25, "line": 1215}, "message": "expanded from macro 'GTEST_TEST_'"}, {"location": {"col": 3, "file": 25, "line": 1211}, "message": "expanded from macro 'GTEST_TEST_CLASS_NAME_'"}, {"location": {"col": 1, "file": 22, "line": 2438}, "message": "destructor '~CompletionTest_NoInsertIncludeIfOnePresent_Test' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clangd/unittests/CodeCompleteTests.cpp", "reportHash": "6c671eca3720501526e1b1fa1a642050", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 42, "file": 24, "line": 2187}, "message": "expanded from macro 'TEST'"}, {"location": {"col": 3, "file": 24, "line": 2181}, "message": "expanded from macro 'GTEST_TEST'"}, {"location": {"col": 7, "file": 25, "line": 1215}, "message": "expanded from macro 'GTEST_TEST_'"}, {"location": {"col": 3, "file": 25, "line": 1211}, "message": "expanded from macro 'GTEST_TEST_CLASS_NAME_'"}, {"location": {"col": 1, "file": 22, "line": 2457}, "message": "destructor '~CompletionTest_MergeMacrosFromIndexAndSema_Test' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clangd/unittests/CodeCompleteTests.cpp", "reportHash": "f0951fcdcc6d25d5674768f9612afad5", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 42, "file": 24, "line": 2187}, "message": "expanded from macro 'TEST'"}, {"location": {"col": 3, "file": 24, "line": 2181}, "message": "expanded from macro 'GTEST_TEST'"}, {"location": {"col": 7, "file": 25, "line": 1215}, "message": "expanded from macro 'GTEST_TEST_'"}, {"location": {"col": 3, "file": 25, "line": 1211}, "message": "expanded from macro 'GTEST_TEST_CLASS_NAME_'"}, {"location": {"col": 1, "file": 22, "line": 2468}, "message": "destructor '~CompletionTest_MacroFromPreamble_Test' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clangd/unittests/CodeCompleteTests.cpp", "reportHash": "b993d2085c999c6e8a709e14f8f7b9b1", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 42, "file": 24, "line": 2187}, "message": "expanded from macro 'TEST'"}, {"location": {"col": 3, "file": 24, "line": 2181}, "message": "expanded from macro 'GTEST_TEST'"}, {"location": {"col": 7, "file": 25, "line": 1215}, "message": "expanded from macro 'GTEST_TEST_'"}, {"location": {"col": 3, "file": 25, "line": 1211}, "message": "expanded from macro 'GTEST_TEST_CLASS_NAME_'"}, {"location": {"col": 1, "file": 22, "line": 2486}, "message": "destructor '~CompletionTest_DeprecatedResults_Test' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clangd/unittests/CodeCompleteTests.cpp", "reportHash": "9921e41d4e4a70a5fce4cc3f1f716086", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 42, "file": 24, "line": 2187}, "message": "expanded from macro 'TEST'"}, {"location": {"col": 3, "file": 24, "line": 2181}, "message": "expanded from macro 'GTEST_TEST'"}, {"location": {"col": 7, "file": 25, "line": 1215}, "message": "expanded from macro 'GTEST_TEST_'"}, {"location": {"col": 3, "file": 25, "line": 1211}, "message": "expanded from macro 'GTEST_TEST_CLASS_NAME_'"}, {"location": {"col": 1, "file": 22, "line": 2498}, "message": "destructor '~SignatureHelpTest_PartialSpec_Test' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clangd/unittests/CodeCompleteTests.cpp", "reportHash": "84220d7fecaf3b6f0f38a0f17ec3c0b5", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 42, "file": 24, "line": 2187}, "message": "expanded from macro 'TEST'"}, {"location": {"col": 3, "file": 24, "line": 2181}, "message": "expanded from macro 'GTEST_TEST'"}, {"location": {"col": 7, "file": 25, "line": 1215}, "message": "expanded from macro 'GTEST_TEST_'"}, {"location": {"col": 3, "file": 25, "line": 1211}, "message": "expanded from macro 'GTEST_TEST_CLASS_NAME_'"}, {"location": {"col": 1, "file": 22, "line": 2507}, "message": "destructor '~SignatureHelpTest_InsideArgument_Test' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clangd/unittests/CodeCompleteTests.cpp", "reportHash": "a350edde5ec6c94526db8bc2f52dc515", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 42, "file": 24, "line": 2187}, "message": "expanded from macro 'TEST'"}, {"location": {"col": 3, "file": 24, "line": 2181}, "message": "expanded from macro 'GTEST_TEST'"}, {"location": {"col": 7, "file": 25, "line": 1215}, "message": "expanded from macro 'GTEST_TEST_'"}, {"location": {"col": 3, "file": 25, "line": 1211}, "message": "expanded from macro 'GTEST_TEST_CLASS_NAME_'"}, {"location": {"col": 1, "file": 22, "line": 2554}, "message": "destructor '~SignatureHelpTest_ConstructorInitializeFields_Test' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clangd/unittests/CodeCompleteTests.cpp", "reportHash": "c20f21c3d1b79c73476a82735a4de6f8", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 42, "file": 24, "line": 2187}, "message": "expanded from macro 'TEST'"}, {"location": {"col": 3, "file": 24, "line": 2181}, "message": "expanded from macro 'GTEST_TEST'"}, {"location": {"col": 7, "file": 25, "line": 1215}, "message": "expanded from macro 'GTEST_TEST_'"}, {"location": {"col": 3, "file": 25, "line": 1211}, "message": "expanded from macro 'GTEST_TEST_CLASS_NAME_'"}, {"location": {"col": 1, "file": 22, "line": 2589}, "message": "destructor '~CompletionTest_IncludedCompletionKinds_Test' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clangd/unittests/CodeCompleteTests.cpp", "reportHash": "0a4366fa193396fae0e72aea9c77df4b", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 42, "file": 24, "line": 2187}, "message": "expanded from macro 'TEST'"}, {"location": {"col": 3, "file": 24, "line": 2181}, "message": "expanded from macro 'GTEST_TEST'"}, {"location": {"col": 7, "file": 25, "line": 1215}, "message": "expanded from macro 'GTEST_TEST_'"}, {"location": {"col": 3, "file": 25, "line": 1211}, "message": "expanded from macro 'GTEST_TEST_CLASS_NAME_'"}, {"location": {"col": 1, "file": 22, "line": 2601}, "message": "destructor '~CompletionTest_NoCrashAtNonAlphaIncludeHeader_Test' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clangd/unittests/CodeCompleteTests.cpp", "reportHash": "6a173a6f69b2bb683db71fbcc415e9f2", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 42, "file": 24, "line": 2187}, "message": "expanded from macro 'TEST'"}, {"location": {"col": 3, "file": 24, "line": 2181}, "message": "expanded from macro 'GTEST_TEST'"}, {"location": {"col": 7, "file": 25, "line": 1215}, "message": "expanded from macro 'GTEST_TEST_'"}, {"location": {"col": 3, "file": 25, "line": 1211}, "message": "expanded from macro 'GTEST_TEST_CLASS_NAME_'"}, {"location": {"col": 1, "file": 22, "line": 2608}, "message": "destructor '~CompletionTest_NoAllScopesCompletionWhenQualified_Test' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clangd/unittests/CodeCompleteTests.cpp", "reportHash": "58dea8278ebeb9702ea8fb937fb22c4e", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 42, "file": 24, "line": 2187}, "message": "expanded from macro 'TEST'"}, {"location": {"col": 3, "file": 24, "line": 2181}, "message": "expanded from macro 'GTEST_TEST'"}, {"location": {"col": 7, "file": 25, "line": 1215}, "message": "expanded from macro 'GTEST_TEST_'"}, {"location": {"col": 3, "file": 25, "line": 1211}, "message": "expanded from macro 'GTEST_TEST_CLASS_NAME_'"}, {"location": {"col": 1, "file": 22, "line": 2622}, "message": "destructor '~CompletionTest_AllScopesCompletion_Test' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clangd/unittests/CodeCompleteTests.cpp", "reportHash": "644ef9c9167abac5365342d56b7d8bb6", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 42, "file": 24, "line": 2187}, "message": "expanded from macro 'TEST'"}, {"location": {"col": 3, "file": 24, "line": 2181}, "message": "expanded from macro 'GTEST_TEST'"}, {"location": {"col": 7, "file": 25, "line": 1215}, "message": "expanded from macro 'GTEST_TEST_'"}, {"location": {"col": 3, "file": 25, "line": 1211}, "message": "expanded from macro 'GTEST_TEST_CLASS_NAME_'"}, {"location": {"col": 1, "file": 22, "line": 2643}, "message": "destructor '~CompletionTest_NoQualifierIfShadowed_Test' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clangd/unittests/CodeCompleteTests.cpp", "reportHash": "429ce140151e53e5688390056dd45974", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 42, "file": 24, "line": 2187}, "message": "expanded from macro 'TEST'"}, {"location": {"col": 3, "file": 24, "line": 2181}, "message": "expanded from macro 'GTEST_TEST'"}, {"location": {"col": 7, "file": 25, "line": 1215}, "message": "expanded from macro 'GTEST_TEST_'"}, {"location": {"col": 3, "file": 25, "line": 1211}, "message": "expanded from macro 'GTEST_TEST_CLASS_NAME_'"}, {"location": {"col": 1, "file": 22, "line": 2660}, "message": "destructor '~CompletionTest_NoCompletionsForNewNames_Test' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clangd/unittests/CodeCompleteTests.cpp", "reportHash": "15d448b8c066d9d3506eeb2caad54009", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 42, "file": 24, "line": 2187}, "message": "expanded from macro 'TEST'"}, {"location": {"col": 3, "file": 24, "line": 2181}, "message": "expanded from macro 'GTEST_TEST'"}, {"location": {"col": 7, "file": 25, "line": 1215}, "message": "expanded from macro 'GTEST_TEST_'"}, {"location": {"col": 3, "file": 25, "line": 1211}, "message": "expanded from macro 'GTEST_TEST_CLASS_NAME_'"}, {"location": {"col": 1, "file": 22, "line": 2670}, "message": "destructor '~CompletionTest_Lambda_Test' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clangd/unittests/CodeCompleteTests.cpp", "reportHash": "394d86e7113b86212ff8a5e316c448b0", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 42, "file": 24, "line": 2187}, "message": "expanded from macro 'TEST'"}, {"location": {"col": 3, "file": 24, "line": 2181}, "message": "expanded from macro 'GTEST_TEST'"}, {"location": {"col": 7, "file": 25, "line": 1215}, "message": "expanded from macro 'GTEST_TEST_'"}, {"location": {"col": 3, "file": 25, "line": 1211}, "message": "expanded from macro 'GTEST_TEST_CLASS_NAME_'"}, {"location": {"col": 1, "file": 22, "line": 2690}, "message": "destructor '~CompletionTest_StructuredBinding_Test' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clangd/unittests/CodeCompleteTests.cpp", "reportHash": "2a655a3c58b416601cf499fa05dc22f3", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 42, "file": 24, "line": 2187}, "message": "expanded from macro 'TEST'"}, {"location": {"col": 3, "file": 24, "line": 2181}, "message": "expanded from macro 'GTEST_TEST'"}, {"location": {"col": 7, "file": 25, "line": 1215}, "message": "expanded from macro 'GTEST_TEST_'"}, {"location": {"col": 3, "file": 25, "line": 1211}, "message": "expanded from macro 'GTEST_TEST_CLASS_NAME_'"}, {"location": {"col": 1, "file": 22, "line": 2713}, "message": "destructor '~CompletionTest_ObjectiveCMethodNoArguments_Test' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clangd/unittests/CodeCompleteTests.cpp", "reportHash": "ad31efe4d325d49d4a70a29f7b3c880f", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 42, "file": 24, "line": 2187}, "message": "expanded from macro 'TEST'"}, {"location": {"col": 3, "file": 24, "line": 2181}, "message": "expanded from macro 'GTEST_TEST'"}, {"location": {"col": 7, "file": 25, "line": 1215}, "message": "expanded from macro 'GTEST_TEST_'"}, {"location": {"col": 3, "file": 25, "line": 1211}, "message": "expanded from macro 'GTEST_TEST_CLASS_NAME_'"}, {"location": {"col": 1, "file": 22, "line": 2731}, "message": "destructor '~CompletionTest_ObjectiveCMethodOneArgument_Test' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clangd/unittests/CodeCompleteTests.cpp", "reportHash": "0698a57fb8a0b84d298e18c0ccebebbc", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 42, "file": 24, "line": 2187}, "message": "expanded from macro 'TEST'"}, {"location": {"col": 3, "file": 24, "line": 2181}, "message": "expanded from macro 'GTEST_TEST'"}, {"location": {"col": 7, "file": 25, "line": 1215}, "message": "expanded from macro 'GTEST_TEST_'"}, {"location": {"col": 3, "file": 25, "line": 1211}, "message": "expanded from macro 'GTEST_TEST_CLASS_NAME_'"}, {"location": {"col": 1, "file": 22, "line": 2749}, "message": "destructor '~CompletionTest_ObjectiveCMethodTwoArgumentsFromBeginning_Test' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clangd/unittests/CodeCompleteTests.cpp", "reportHash": "4778c1de4f62e966116f9b45693464ab", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 42, "file": 24, "line": 2187}, "message": "expanded from macro 'TEST'"}, {"location": {"col": 3, "file": 24, "line": 2181}, "message": "expanded from macro 'GTEST_TEST'"}, {"location": {"col": 7, "file": 25, "line": 1215}, "message": "expanded from macro 'GTEST_TEST_'"}, {"location": {"col": 3, "file": 25, "line": 1211}, "message": "expanded from macro 'GTEST_TEST_CLASS_NAME_'"}, {"location": {"col": 1, "file": 22, "line": 2768}, "message": "destructor '~CompletionTest_ObjectiveCMethodTwoArgumentsFromMiddle_Test' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clangd/unittests/CodeCompleteTests.cpp", "reportHash": "8fb7229686feef68192b3e8741993691", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 42, "file": 24, "line": 2187}, "message": "expanded from macro 'TEST'"}, {"location": {"col": 3, "file": 24, "line": 2181}, "message": "expanded from macro 'GTEST_TEST'"}, {"location": {"col": 7, "file": 25, "line": 1215}, "message": "expanded from macro 'GTEST_TEST_'"}, {"location": {"col": 3, "file": 25, "line": 1211}, "message": "expanded from macro 'GTEST_TEST_CLASS_NAME_'"}, {"location": {"col": 1, "file": 22, "line": 2786}, "message": "destructor '~CompletionTest_CursorInSnippets_Test' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clangd/unittests/CodeCompleteTests.cpp", "reportHash": "f31f49284c8c8ae392347f9488cc789e", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 42, "file": 24, "line": 2187}, "message": "expanded from macro 'TEST'"}, {"location": {"col": 3, "file": 24, "line": 2181}, "message": "expanded from macro 'GTEST_TEST'"}, {"location": {"col": 7, "file": 25, "line": 1215}, "message": "expanded from macro 'GTEST_TEST_'"}, {"location": {"col": 3, "file": 25, "line": 1211}, "message": "expanded from macro 'GTEST_TEST_CLASS_NAME_'"}, {"location": {"col": 1, "file": 22, "line": 2808}, "message": "destructor '~CompletionTest_WorksWithNullType_Test' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clangd/unittests/CodeCompleteTests.cpp", "reportHash": "75a464d81afba6bec7f010dbeda2553a", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 42, "file": 24, "line": 2187}, "message": "expanded from macro 'TEST'"}, {"location": {"col": 3, "file": 24, "line": 2181}, "message": "expanded from macro 'GTEST_TEST'"}, {"location": {"col": 7, "file": 25, "line": 1215}, "message": "expanded from macro 'GTEST_TEST_'"}, {"location": {"col": 3, "file": 25, "line": 1211}, "message": "expanded from macro 'GTEST_TEST_CLASS_NAME_'"}, {"location": {"col": 1, "file": 22, "line": 2819}, "message": "destructor '~CompletionTest_UsingDecl_Test' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clangd/unittests/CodeCompleteTests.cpp", "reportHash": "468b4f0b9653aaeeb3253f8e4e8f2c13", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 42, "file": 24, "line": 2187}, "message": "expanded from macro 'TEST'"}, {"location": {"col": 3, "file": 24, "line": 2181}, "message": "expanded from macro 'GTEST_TEST'"}, {"location": {"col": 7, "file": 25, "line": 1215}, "message": "expanded from macro 'GTEST_TEST_'"}, {"location": {"col": 3, "file": 25, "line": 1211}, "message": "expanded from macro 'GTEST_TEST_CLASS_NAME_'"}, {"location": {"col": 1, "file": 22, "line": 2839}, "message": "destructor '~CompletionTest_ScopeIsUnresolved_Test' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clangd/unittests/CodeCompleteTests.cpp", "reportHash": "9059329fba1a40badae4999c3749ff58", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 42, "file": 24, "line": 2187}, "message": "expanded from macro 'TEST'"}, {"location": {"col": 3, "file": 24, "line": 2181}, "message": "expanded from macro 'GTEST_TEST'"}, {"location": {"col": 7, "file": 25, "line": 1215}, "message": "expanded from macro 'GTEST_TEST_'"}, {"location": {"col": 3, "file": 25, "line": 1211}, "message": "expanded from macro 'GTEST_TEST_CLASS_NAME_'"}, {"location": {"col": 1, "file": 22, "line": 2853}, "message": "destructor '~CompletionTest_NestedScopeIsUnresolved_Test' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clangd/unittests/CodeCompleteTests.cpp", "reportHash": "ee886c9048d0ddcde2006eb1e4842e48", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 42, "file": 24, "line": 2187}, "message": "expanded from macro 'TEST'"}, {"location": {"col": 3, "file": 24, "line": 2181}, "message": "expanded from macro 'GTEST_TEST'"}, {"location": {"col": 7, "file": 25, "line": 1215}, "message": "expanded from macro 'GTEST_TEST_'"}, {"location": {"col": 3, "file": 25, "line": 1211}, "message": "expanded from macro 'GTEST_TEST_CLASS_NAME_'"}, {"location": {"col": 1, "file": 22, "line": 2870}, "message": "destructor '~CompletionTest_NamespaceDoubleInsertion_Test' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clangd/unittests/CodeCompleteTests.cpp", "reportHash": "4f0fd15df4392f797b8df73d209fa61a", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 42, "file": 24, "line": 2187}, "message": "expanded from macro 'TEST'"}, {"location": {"col": 3, "file": 24, "line": 2181}, "message": "expanded from macro 'GTEST_TEST'"}, {"location": {"col": 7, "file": 25, "line": 1215}, "message": "expanded from macro 'GTEST_TEST_'"}, {"location": {"col": 3, "file": 25, "line": 1211}, "message": "expanded from macro 'GTEST_TEST_CLASS_NAME_'"}, {"location": {"col": 1, "file": 22, "line": 2885}, "message": "destructor '~CompletionTest_DerivedMethodsAreAlwaysVisible_Test' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clangd/unittests/CodeCompleteTests.cpp", "reportHash": "bdc2044a8d7b6c7390b8854fbcb1674b", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 42, "file": 24, "line": 2187}, "message": "expanded from macro 'TEST'"}, {"location": {"col": 3, "file": 24, "line": 2181}, "message": "expanded from macro 'GTEST_TEST'"}, {"location": {"col": 7, "file": 25, "line": 1215}, "message": "expanded from macro 'GTEST_TEST_'"}, {"location": {"col": 3, "file": 25, "line": 1211}, "message": "expanded from macro 'GTEST_TEST_CLASS_NAME_'"}, {"location": {"col": 1, "file": 22, "line": 2904}, "message": "destructor '~CompletionTest_NoCrashWithIncompleteLambda_Test' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clangd/unittests/CodeCompleteTests.cpp", "reportHash": "67586f84c8c5b985ab0f57886c3c9e65", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 42, "file": 24, "line": 2187}, "message": "expanded from macro 'TEST'"}, {"location": {"col": 3, "file": 24, "line": 2181}, "message": "expanded from macro 'GTEST_TEST'"}, {"location": {"col": 7, "file": 25, "line": 1215}, "message": "expanded from macro 'GTEST_TEST_'"}, {"location": {"col": 3, "file": 25, "line": 1211}, "message": "expanded from macro 'GTEST_TEST_CLASS_NAME_'"}, {"location": {"col": 1, "file": 22, "line": 2915}, "message": "destructor '~CompletionTest_DelayedTemplateParsing_Test' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clangd/unittests/CodeCompleteTests.cpp", "reportHash": "85004f0a762e9aa9230466db298b6b90", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 42, "file": 24, "line": 2187}, "message": "expanded from macro 'TEST'"}, {"location": {"col": 3, "file": 24, "line": 2181}, "message": "expanded from macro 'GTEST_TEST'"}, {"location": {"col": 7, "file": 25, "line": 1215}, "message": "expanded from macro 'GTEST_TEST_'"}, {"location": {"col": 3, "file": 25, "line": 1211}, "message": "expanded from macro 'GTEST_TEST_CLASS_NAME_'"}, {"location": {"col": 1, "file": 22, "line": 2929}, "message": "destructor '~CompletionTest_CompletionRange_Test' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clangd/unittests/CodeCompleteTests.cpp", "reportHash": "c327b98c70a841884d5fc20e5835537e", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 42, "file": 24, "line": 2187}, "message": "expanded from macro 'TEST'"}, {"location": {"col": 3, "file": 24, "line": 2181}, "message": "expanded from macro 'GTEST_TEST'"}, {"location": {"col": 7, "file": 25, "line": 1215}, "message": "expanded from macro 'GTEST_TEST_'"}, {"location": {"col": 3, "file": 25, "line": 1211}, "message": "expanded from macro 'GTEST_TEST_CLASS_NAME_'"}, {"location": {"col": 1, "file": 22, "line": 2951}, "message": "destructor '~NoCompileCompletionTest_Basic_Test' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clangd/unittests/CodeCompleteTests.cpp", "reportHash": "627774febae5922df0b63cb299f1f71f", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 42, "file": 24, "line": 2187}, "message": "expanded from macro 'TEST'"}, {"location": {"col": 3, "file": 24, "line": 2181}, "message": "expanded from macro 'GTEST_TEST'"}, {"location": {"col": 7, "file": 25, "line": 1215}, "message": "expanded from macro 'GTEST_TEST_'"}, {"location": {"col": 3, "file": 25, "line": 1211}, "message": "expanded from macro 'GTEST_TEST_CLASS_NAME_'"}, {"location": {"col": 1, "file": 22, "line": 2965}, "message": "destructor '~NoCompileCompletionTest_WithFilter_Test' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clangd/unittests/CodeCompleteTests.cpp", "reportHash": "01e1ad769f1f64c83dead807d8bf15b4", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 42, "file": 24, "line": 2187}, "message": "expanded from macro 'TEST'"}, {"location": {"col": 3, "file": 24, "line": 2181}, "message": "expanded from macro 'GTEST_TEST'"}, {"location": {"col": 7, "file": 25, "line": 1215}, "message": "expanded from macro 'GTEST_TEST_'"}, {"location": {"col": 3, "file": 25, "line": 1211}, "message": "expanded from macro 'GTEST_TEST_CLASS_NAME_'"}, {"location": {"col": 1, "file": 22, "line": 2979}, "message": "destructor '~NoCompileCompletionTest_WithIndex_Test' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clangd/unittests/CodeCompleteTests.cpp", "reportHash": "e34a09d50691d588b056b79ebb140ef1", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 42, "file": 24, "line": 2187}, "message": "expanded from macro 'TEST'"}, {"location": {"col": 3, "file": 24, "line": 2181}, "message": "expanded from macro 'GTEST_TEST'"}, {"location": {"col": 7, "file": 25, "line": 1215}, "message": "expanded from macro 'GTEST_TEST_'"}, {"location": {"col": 3, "file": 25, "line": 1211}, "message": "expanded from macro 'GTEST_TEST_CLASS_NAME_'"}, {"location": {"col": 1, "file": 22, "line": 3048}, "message": "destructor '~AllowImplicitCompletion_All_Test' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clangd/unittests/CodeCompleteTests.cpp", "reportHash": "ecd82c186fbfc468556dd38f670726e2", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 42, "file": 24, "line": 2187}, "message": "expanded from macro 'TEST'"}, {"location": {"col": 3, "file": 24, "line": 2181}, "message": "expanded from macro 'GTEST_TEST'"}, {"location": {"col": 7, "file": 25, "line": 1215}, "message": "expanded from macro 'GTEST_TEST_'"}, {"location": {"col": 3, "file": 25, "line": 1211}, "message": "expanded from macro 'GTEST_TEST_CLASS_NAME_'"}, {"location": {"col": 1, "file": 22, "line": 3076}, "message": "destructor '~CompletionTest_FunctionArgsExist_Test' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clangd/unittests/CodeCompleteTests.cpp", "reportHash": "67755b6d3505d8ba37b1ce331324e4bf", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}]};
      window.onload = function() {
        if (!browserCompatible) {
          setNonCompatibleBrowserMessage();
        } else {
          BugViewer.init(data.files, data.reports);
          BugViewer.create();
          BugViewer.initByUrl();
        }
      };
    </script>
  </head>
  <body>
  <div class="container">
    <div id="content">
      <div id="side-bar">
        <div class="header">
          <a href="index.html" class="button">&#8249; Return to List</a>
        </div>
        <div id="report-nav">
          <div class="header">Reports</div>
        </div>
      </div>
      <div id="editor-wrapper">
        <div class="header">
          <div id="file">
            <span class="label">File:</span>
            <span id="file-path"></span>
          </div>
          <div id="checker">
            <span class="label">Checker name:</span>
            <span id="checker-name"></span>
          </div>
          <div id="review-status-wrapper">
            <span class="label">Review status:</span>
            <span id="review-status"></span>
          </div>
        </div>
        <div id="editor"></div>
      </div>
    </div>
  </div>
  </body>
</html>
