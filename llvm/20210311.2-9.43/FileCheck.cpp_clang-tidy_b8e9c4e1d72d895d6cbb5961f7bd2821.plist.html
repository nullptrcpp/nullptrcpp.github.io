<!DOCTYPE html>
<html>
  <head>
    <title>Plist HTML Viewer</title>

    <meta charset="UTF-8">

    <style type="text/css">
      .CodeMirror{font-family:monospace;height:300px;color:#000;direction:ltr}.CodeMirror-lines{padding:4px 0}.CodeMirror pre{padding:0 4px}.CodeMirror-gutter-filler,.CodeMirror-scrollbar-filler{background-color:#fff}.CodeMirror-gutters{border-right:1px solid #ddd;background-color:#f7f7f7;white-space:nowrap}.CodeMirror-linenumber{padding:0 3px 0 5px;min-width:20px;text-align:right;color:#999;white-space:nowrap}.CodeMirror-guttermarker{color:#000}.CodeMirror-guttermarker-subtle{color:#999}.CodeMirror-cursor{border-left:1px solid #000;border-right:none;width:0}.CodeMirror div.CodeMirror-secondarycursor{border-left:1px solid silver}.cm-fat-cursor .CodeMirror-cursor{width:auto;border:0!important;background:#7e7}.cm-fat-cursor div.CodeMirror-cursors{z-index:1}.cm-animate-fat-cursor{width:auto;border:0;-webkit-animation:blink 1.06s steps(1) infinite;-moz-animation:blink 1.06s steps(1) infinite;animation:blink 1.06s steps(1) infinite;background-color:#7e7}@-moz-keyframes blink{50%{background-color:transparent}}@-webkit-keyframes blink{50%{background-color:transparent}}@keyframes blink{50%{background-color:transparent}}.cm-tab{display:inline-block;text-decoration:inherit}.CodeMirror-rulers{position:absolute;left:0;right:0;top:-50px;bottom:-20px;overflow:hidden}.CodeMirror-ruler{border-left:1px solid #ccc;top:0;bottom:0;position:absolute}.cm-s-default .cm-header{color:#00f}.cm-s-default .cm-quote{color:#090}.cm-negative{color:#d44}.cm-positive{color:#292}.cm-header,.cm-strong{font-weight:700}.cm-em{font-style:italic}.cm-link{text-decoration:underline}.cm-strikethrough{text-decoration:line-through}.cm-s-default .cm-keyword{color:#708}.cm-s-default .cm-atom{color:#219}.cm-s-default .cm-number{color:#164}.cm-s-default .cm-def{color:#00f}.cm-s-default .cm-variable-2{color:#05a}.cm-s-default .cm-type,.cm-s-default .cm-variable-3{color:#085}.cm-s-default .cm-comment{color:#a50}.cm-s-default .cm-string{color:#a11}.cm-s-default .cm-string-2{color:#f50}.cm-s-default .cm-meta{color:#555}.cm-s-default .cm-qualifier{color:#555}.cm-s-default .cm-builtin{color:#30a}.cm-s-default .cm-bracket{color:#997}.cm-s-default .cm-tag{color:#170}.cm-s-default .cm-attribute{color:#00c}.cm-s-default .cm-hr{color:#999}.cm-s-default .cm-link{color:#00c}.cm-s-default .cm-error{color:red}.cm-invalidchar{color:red}.CodeMirror-composing{border-bottom:2px solid}div.CodeMirror span.CodeMirror-matchingbracket{color:#0f0}div.CodeMirror span.CodeMirror-nonmatchingbracket{color:#f22}.CodeMirror-matchingtag{background:rgba(255,150,0,.3)}.CodeMirror-activeline-background{background:#e8f2ff}.CodeMirror{position:relative;overflow:hidden;background:#fff}.CodeMirror-scroll{overflow:scroll!important;margin-bottom:-30px;margin-right:-30px;padding-bottom:30px;height:100%;outline:0;position:relative}.CodeMirror-sizer{position:relative;border-right:30px solid transparent}.CodeMirror-gutter-filler,.CodeMirror-hscrollbar,.CodeMirror-scrollbar-filler,.CodeMirror-vscrollbar{position:absolute;z-index:6;display:none}.CodeMirror-vscrollbar{right:0;top:0;overflow-x:hidden;overflow-y:scroll}.CodeMirror-hscrollbar{bottom:0;left:0;overflow-y:hidden;overflow-x:scroll}.CodeMirror-scrollbar-filler{right:0;bottom:0}.CodeMirror-gutter-filler{left:0;bottom:0}.CodeMirror-gutters{position:absolute;left:0;top:0;min-height:100%;z-index:3}.CodeMirror-gutter{white-space:normal;height:100%;display:inline-block;vertical-align:top;margin-bottom:-30px}.CodeMirror-gutter-wrapper{position:absolute;z-index:4;background:0 0!important;border:none!important}.CodeMirror-gutter-background{position:absolute;top:0;bottom:0;z-index:4}.CodeMirror-gutter-elt{position:absolute;cursor:default;z-index:4}.CodeMirror-gutter-wrapper ::selection{background-color:transparent}.CodeMirror-gutter-wrapper ::-moz-selection{background-color:transparent}.CodeMirror-lines{cursor:text;min-height:1px}.CodeMirror pre{-moz-border-radius:0;-webkit-border-radius:0;border-radius:0;border-width:0;background:0 0;font-family:inherit;font-size:inherit;margin:0;white-space:pre;word-wrap:normal;line-height:inherit;color:inherit;z-index:2;position:relative;overflow:visible;-webkit-tap-highlight-color:transparent;-webkit-font-variant-ligatures:contextual;font-variant-ligatures:contextual}.CodeMirror-wrap pre{word-wrap:break-word;white-space:pre-wrap;word-break:normal}.CodeMirror-linebackground{position:absolute;left:0;right:0;top:0;bottom:0;z-index:0}.CodeMirror-linewidget{position:relative;z-index:2;overflow:auto}.CodeMirror-rtl pre{direction:rtl}.CodeMirror-code{outline:0}.CodeMirror-gutter,.CodeMirror-gutters,.CodeMirror-linenumber,.CodeMirror-scroll,.CodeMirror-sizer{-moz-box-sizing:content-box;box-sizing:content-box}.CodeMirror-measure{position:absolute;width:100%;height:0;overflow:hidden;visibility:hidden}.CodeMirror-cursor{position:absolute;pointer-events:none}.CodeMirror-measure pre{position:static}div.CodeMirror-cursors{visibility:hidden;position:relative;z-index:3}div.CodeMirror-dragcursors{visibility:visible}.CodeMirror-focused div.CodeMirror-cursors{visibility:visible}.CodeMirror-selected{background:#d9d9d9}.CodeMirror-focused .CodeMirror-selected{background:#d7d4f0}.CodeMirror-crosshair{cursor:crosshair}.CodeMirror-line::selection,.CodeMirror-line>span::selection,.CodeMirror-line>span>span::selection{background:#d7d4f0}.CodeMirror-line::-moz-selection,.CodeMirror-line>span::-moz-selection,.CodeMirror-line>span>span::-moz-selection{background:#d7d4f0}.cm-searching{background-color:#ffa;background-color:rgba(255,255,0,.4)}.cm-force-border{padding-right:.1px}@media print{.CodeMirror div.CodeMirror-cursors{visibility:hidden}}.cm-tab-wrap-hack:after{content:''}span.CodeMirror-selectedtext{background:0 0}
/*# sourceMappingURL=codemirror.min.css.map */

      .severity-low {
  background-color: #669603;
}

.severity-low:after {
  content : 'L';
}

.severity-unspecified {
  background-color: #666666;
}

.severity-unspecified:after {
  content : 'U';
}

.severity-style {
  background-color: #9932cc;
}

.severity-style:after {
  content : 'S';
}

.severity-medium {
  background-color: #a9d323;
  color: black;
}

.severity-medium:after {
  content : 'M';
}

.severity-high {
  background-color: #ffa800;
}

.severity-high:after {
  content : 'H';
}

.severity-critical {
  background-color: #e92625;
}

.severity-critical:after {
  content : 'C';
}

i[class*="severity-"] {
  line-height: normal;
  text-transform: capitalize;
  font-size: 0.8em;
  font-weight: bold;
  color: white;
  display: inline-block;
  width: 16px;
  height: 16px;
  text-align: center;
  font-family: sans-serif;
}

      html, body {
  width: 100%;
  height: 100%;
  padding: 0px;
  margin: 0px;
}

div.container {
  padding: 10px;
}

#content {
  height: 100%;
  display: block;
  overflow: hidden;
}

#content > div {
  margin: 10px;
  overflow: hidden;
  border: 1px solid #ddd;
  border-radius: 3px;
  overflow: hidden;
  height: 97%;
}

.button {
  background-color: #f1f1f1;
  text-decoration: none;
  display: inline-block;
  padding: 8px 16px;
  color: black;
  cursor: pointer;
}

.button:hover {
  background-color: #ddd;
  color: black;
}

.review-status {
  color: white;
  text-align: center;
}

.review-status-confirmed {
  background-color: #e92625;
}

.review-status-false-positive {
  background-color: grey;
}

.review-status-intentional {
  background-color: #669603;
}

      div.container {
  width: 100%;
  height: 100%;
  padding: 0px;
}

#editor-wrapper {
  margin: 10px;
}

#side-bar {
  float: left;
  width: 260px;
  margin: 0px;
}

#report-nav ul {
  list-style-type: none;
  padding: 0;
  margin: 0;
  overflow-y: auto;
  height: 100%;
}

#report-nav ul > li {
  padding: .4em;
  background-color: #fff;
  border-bottom: 1px solid rgba(0,0,0,.125);
  text-align: left;
  overflow: hidden;
  white-space: nowrap;
  text-overflow: ellipsis;
}

#report-nav ul > li.active {
  background-color: #427ea9;
  color: white;
}

#report-nav ul > li:hover {
  background-color: #427ea9;
  color: white;
  cursor: pointer;
}

#report-nav ul a {
  text-decoration: none;
}

#report-nav i[class*="severity-"] {
  margin-right: 5px;
}

.header {
  border-bottom: 1px solid lightgrey;
  font-family: monospace;
  padding: 10px;
  background-color: #fafbfc;
  border-bottom: 1px solid #e1e4e8;
  border-top-left-radius: 2px;
  border-top-right-radius: 2px;
}

#report-nav .header {
  font-weight: bold;
}

#editor-wrapper .header > div {
  padding-top: 2px;
}

#file-path,
#checker-name {
  color: #195ea2;
}

#review-status {
  padding: 0px 5px;
}

#file-path {
  font-family: monospace;
}

.check-msg {
  display: inline-block;
  padding: 3px 6px;
  margin: 1px;
  -webkit-border-radius: 5px;
  -moz-border-radius: 5px;
  border-radius: 5px;
}

.check-msg.info {
  color: #00546f;
  background-color: #bfdfe9;
  border: 1px solid #87a8b3;
}

.check-msg.error {
  background-color: #f2dede;
  color: #a94442;
  border: 1px solid #ebcccc;
}

.check-msg.macro {
  background-color: #d7dac2;
  color: #4f5c6d;
  border: 1px solid #d7dac2;
}

.check-msg.note {
  background-color: #d7d7d7;
  color: #4f5c6d;
  border: 1px solid #bfbfbf;
}

.check-msg.current {
  border: 2px dashed #3692ff;
}

.check-msg .tag {
  padding: 1px 5px;
  text-align: center;
  border-radius: 2px;
  margin-right: 5px;
  text-decoration: inherit;
}

.check-msg .tag.macro {
  background-color: #83876a;
  color: white;
  text-transform: capitalize;
}

.check-msg .tag.note {
  background-color: #9299a1;
  color: white;
  text-transform: capitalize;
}

.checker-enum {
  color: white;
  padding: 1px 5px;
  text-align: center;
  border-radius: 25px;
  margin-right: 5px;
  text-decoration: inherit;
}

.checker-enum.info {
  background-color: #427ea9;
}

.checker-enum.error {
  background-color: #a94442;
}

.arrow {
  border: solid black;
  border-width: 0 3px 3px 0;
  display: inline-block;
  padding: 3px;
  cursor: pointer;
  margin: 0px 5px;
}

.arrow:hover {
  border: solid #437ea8;
  border-width: 0 3px 3px 0;
}

.left-arrow {
  transform: rotate(135deg);
  -webkit-transform: rotate(135deg);
}

.right-arrow {
  transform: rotate(-45deg);
  -webkit-transform: rotate(-45deg);
}

    </style>

    <script type="text/javascript">
      function setNonCompatibleBrowserMessage() {
  document.body.innerHTML =
    '<h2 style="margin-left: 20px;">Your browser is not compatible with CodeChecker Viewer!</h2> \
     <p style="margin-left: 20px;">The version required for the following browsers are:</p> \
     <ul style="margin-left: 20px;"> \
     <li>Internet Explorer: version 9 or newer</li> \
     <li>Firefox: version 22.0 or newer</li> \
     </ul>';
}

// http://stackoverflow.com/questions/5916900/how-can-you-detect-the-version-of-a-browser
var browserVersion = (function(){
  var ua = navigator.userAgent, tem,
    M = ua.match(/(opera|chrome|safari|firefox|msie|trident(?=\/))\/?\s*(\d+)/i) || [];

  if (/trident/i.test(M[1])) {
    tem = /\brv[ :]+(\d+)/g.exec(ua) || [];
    return 'IE ' + (tem[1] || '');
  }

  if (M[1] === 'Chrome') {
    tem = ua.match(/\b(OPR|Edge)\/(\d+)/);
    if (tem != null) return tem.slice(1).join(' ').replace('OPR', 'Opera');
  }

  M = M[2] ? [M[1], M[2]] : [navigator.appName, navigator.appVersion, '-?'];
  if ((tem = ua.match(/version\/(\d+)/i)) != null) M.splice(1, 1, tem[1]);
    return M.join(' ');
})();

var pos = browserVersion.indexOf(' ');
var browser = browserVersion.substr(0, pos);
var version = parseInt(browserVersion.substr(pos + 1));

var browserCompatible
  = browser === 'Firefox'
  ? version >= 22
  : browser === 'IE'
  ? version >= 9
  : true;


      /* MIT License

Copyright (C) 2017 by Marijn Haverbeke <marijnh@gmail.com> and others

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
 */
      !function(e,t){"object"==typeof exports&&"undefined"!=typeof module?module.exports=t():"function"==typeof define&&define.amd?define(t):e.CodeMirror=t()}(this,function(){"use strict";function e(e){return new RegExp("(^|\\s)"+e+"(?:$|\\s)\\s*")}function t(e){for(var t=e.childNodes.length;t>0;--t)e.removeChild(e.firstChild);return e}function r(e,r){return t(e).appendChild(r)}function n(e,t,r,n){var i=document.createElement(e);if(r&&(i.className=r),n&&(i.style.cssText=n),"string"==typeof t)i.appendChild(document.createTextNode(t));else if(t)for(var o=0;o<t.length;++o)i.appendChild(t[o]);return i}function i(e,t,r,i){var o=n(e,t,r,i);return o.setAttribute("role","presentation"),o}function o(e,t){if(3==t.nodeType&&(t=t.parentNode),e.contains)return e.contains(t);do{if(11==t.nodeType&&(t=t.host),t==e)return!0}while(t=t.parentNode)}function l(){var e;try{e=document.activeElement}catch(t){e=document.body||null}for(;e&&e.shadowRoot&&e.shadowRoot.activeElement;)e=e.shadowRoot.activeElement;return e}function s(t,r){var n=t.className;e(r).test(n)||(t.className+=(n?" ":"")+r)}function a(t,r){for(var n=t.split(" "),i=0;i<n.length;i++)n[i]&&!e(n[i]).test(r)&&(r+=" "+n[i]);return r}function u(e){var t=Array.prototype.slice.call(arguments,1);return function(){return e.apply(null,t)}}function c(e,t,r){t||(t={});for(var n in e)!e.hasOwnProperty(n)||!1===r&&t.hasOwnProperty(n)||(t[n]=e[n]);return t}function f(e,t,r,n,i){null==t&&-1==(t=e.search(/[^\s\u00a0]/))&&(t=e.length);for(var o=n||0,l=i||0;;){var s=e.indexOf("\t",o);if(s<0||s>=t)return l+(t-o);l+=s-o,l+=r-l%r,o=s+1}}function h(e,t){for(var r=0;r<e.length;++r)if(e[r]==t)return r;return-1}function d(e,t,r){for(var n=0,i=0;;){var o=e.indexOf("\t",n);-1==o&&(o=e.length);var l=o-n;if(o==e.length||i+l>=t)return n+Math.min(l,t-i);if(i+=o-n,i+=r-i%r,n=o+1,i>=t)return n}}function p(e){for(;Kl.length<=e;)Kl.push(g(Kl)+" ");return Kl[e]}function g(e){return e[e.length-1]}function v(e,t){for(var r=[],n=0;n<e.length;n++)r[n]=t(e[n],n);return r}function m(e,t,r){for(var n=0,i=r(t);n<e.length&&r(e[n])<=i;)n++;e.splice(n,0,t)}function y(){}function b(e,t){var r;return Object.create?r=Object.create(e):(y.prototype=e,r=new y),t&&c(t,r),r}function w(e){return/\w/.test(e)||e>""&&(e.toUpperCase()!=e.toLowerCase()||jl.test(e))}function x(e,t){return t?!!(t.source.indexOf("\\w")>-1&&w(e))||t.test(e):w(e)}function C(e){for(var t in e)if(e.hasOwnProperty(t)&&e[t])return!1;return!0}function S(e){return e.charCodeAt(0)>=768&&Xl.test(e)}function L(e,t,r){for(;(r<0?t>0:t<e.length)&&S(e.charAt(t));)t+=r;return t}function k(e,t,r){for(var n=t>r?-1:1;;){if(t==r)return t;var i=(t+r)/2,o=n<0?Math.ceil(i):Math.floor(i);if(o==t)return e(o)?t:r;e(o)?r=o:t=o+n}}function T(e,t,r){var o=this;this.input=r,o.scrollbarFiller=n("div",null,"CodeMirror-scrollbar-filler"),o.scrollbarFiller.setAttribute("cm-not-content","true"),o.gutterFiller=n("div",null,"CodeMirror-gutter-filler"),o.gutterFiller.setAttribute("cm-not-content","true"),o.lineDiv=i("div",null,"CodeMirror-code"),o.selectionDiv=n("div",null,null,"position: relative; z-index: 1"),o.cursorDiv=n("div",null,"CodeMirror-cursors"),o.measure=n("div",null,"CodeMirror-measure"),o.lineMeasure=n("div",null,"CodeMirror-measure"),o.lineSpace=i("div",[o.measure,o.lineMeasure,o.selectionDiv,o.cursorDiv,o.lineDiv],null,"position: relative; outline: none");var l=i("div",[o.lineSpace],"CodeMirror-lines");o.mover=n("div",[l],null,"position: relative"),o.sizer=n("div",[o.mover],"CodeMirror-sizer"),o.sizerWidth=null,o.heightForcer=n("div",null,null,"position: absolute; height: "+Rl+"px; width: 1px;"),o.gutters=n("div",null,"CodeMirror-gutters"),o.lineGutter=null,o.scroller=n("div",[o.sizer,o.heightForcer,o.gutters],"CodeMirror-scroll"),o.scroller.setAttribute("tabIndex","-1"),o.wrapper=n("div",[o.scrollbarFiller,o.gutterFiller,o.scroller],"CodeMirror"),gl&&vl<8&&(o.gutters.style.zIndex=-1,o.scroller.style.paddingRight=0),ml||fl&&Tl||(o.scroller.draggable=!0),e&&(e.appendChild?e.appendChild(o.wrapper):e(o.wrapper)),o.viewFrom=o.viewTo=t.first,o.reportedViewFrom=o.reportedViewTo=t.first,o.view=[],o.renderedView=null,o.externalMeasured=null,o.viewOffset=0,o.lastWrapHeight=o.lastWrapWidth=0,o.updateLineNumbers=null,o.nativeBarWidth=o.barHeight=o.barWidth=0,o.scrollbarsClipped=!1,o.lineNumWidth=o.lineNumInnerWidth=o.lineNumChars=null,o.alignWidgets=!1,o.cachedCharWidth=o.cachedTextHeight=o.cachedPaddingH=null,o.maxLine=null,o.maxLineLength=0,o.maxLineChanged=!1,o.wheelDX=o.wheelDY=o.wheelStartX=o.wheelStartY=null,o.shift=!1,o.selForContextMenu=null,o.activeTouch=null,r.init(o)}function M(e,t){if((t-=e.first)<0||t>=e.size)throw new Error("There is no line "+(t+e.first)+" in the document.");for(var r=e;!r.lines;)for(var n=0;;++n){var i=r.children[n],o=i.chunkSize();if(t<o){r=i;break}t-=o}return r.lines[t]}function N(e,t,r){var n=[],i=t.line;return e.iter(t.line,r.line+1,function(e){var o=e.text;i==r.line&&(o=o.slice(0,r.ch)),i==t.line&&(o=o.slice(t.ch)),n.push(o),++i}),n}function O(e,t,r){var n=[];return e.iter(t,r,function(e){n.push(e.text)}),n}function A(e,t){var r=t-e.height;if(r)for(var n=e;n;n=n.parent)n.height+=r}function W(e){if(null==e.parent)return null;for(var t=e.parent,r=h(t.lines,e),n=t.parent;n;t=n,n=n.parent)for(var i=0;n.children[i]!=t;++i)r+=n.children[i].chunkSize();return r+t.first}function D(e,t){var r=e.first;e:do{for(var n=0;n<e.children.length;++n){var i=e.children[n],o=i.height;if(t<o){e=i;continue e}t-=o,r+=i.chunkSize()}return r}while(!e.lines);for(var l=0;l<e.lines.length;++l){var s=e.lines[l].height;if(t<s)break;t-=s}return r+l}function H(e,t){return t>=e.first&&t<e.first+e.size}function F(e,t){return String(e.lineNumberFormatter(t+e.firstLineNumber))}function E(e,t,r){if(void 0===r&&(r=null),!(this instanceof E))return new E(e,t,r);this.line=e,this.ch=t,this.sticky=r}function P(e,t){return e.line-t.line||e.ch-t.ch}function I(e,t){return e.sticky==t.sticky&&0==P(e,t)}function z(e){return E(e.line,e.ch)}function R(e,t){return P(e,t)<0?t:e}function B(e,t){return P(e,t)<0?e:t}function G(e,t){return Math.max(e.first,Math.min(t,e.first+e.size-1))}function U(e,t){if(t.line<e.first)return E(e.first,0);var r=e.first+e.size-1;return t.line>r?E(r,M(e,r).text.length):V(t,M(e,t.line).text.length)}function V(e,t){var r=e.ch;return null==r||r>t?E(e.line,t):r<0?E(e.line,0):e}function K(e,t){for(var r=[],n=0;n<t.length;n++)r[n]=U(e,t[n]);return r}function j(){Yl=!0}function X(){_l=!0}function Y(e,t,r){this.marker=e,this.from=t,this.to=r}function _(e,t){if(e)for(var r=0;r<e.length;++r){var n=e[r];if(n.marker==t)return n}}function $(e,t){for(var r,n=0;n<e.length;++n)e[n]!=t&&(r||(r=[])).push(e[n]);return r}function q(e,t){e.markedSpans=e.markedSpans?e.markedSpans.concat([t]):[t],t.marker.attachLine(e)}function Z(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t)||o.from==t&&"bookmark"==l.type&&(!r||!o.marker.insertLeft)){var s=null==o.to||(l.inclusiveRight?o.to>=t:o.to>t);(n||(n=[])).push(new Y(l,o.from,s?null:o.to))}}return n}function Q(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.to||(l.inclusiveRight?o.to>=t:o.to>t)||o.from==t&&"bookmark"==l.type&&(!r||o.marker.insertLeft)){var s=null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t);(n||(n=[])).push(new Y(l,s?null:o.from-t,null==o.to?null:o.to-t))}}return n}function J(e,t){if(t.full)return null;var r=H(e,t.from.line)&&M(e,t.from.line).markedSpans,n=H(e,t.to.line)&&M(e,t.to.line).markedSpans;if(!r&&!n)return null;var i=t.from.ch,o=t.to.ch,l=0==P(t.from,t.to),s=Z(r,i,l),a=Q(n,o,l),u=1==t.text.length,c=g(t.text).length+(u?i:0);if(s)for(var f=0;f<s.length;++f){var h=s[f];if(null==h.to){var d=_(a,h.marker);d?u&&(h.to=null==d.to?null:d.to+c):h.to=i}}if(a)for(var p=0;p<a.length;++p){var v=a[p];null!=v.to&&(v.to+=c),null==v.from?_(s,v.marker)||(v.from=c,u&&(s||(s=[])).push(v)):(v.from+=c,u&&(s||(s=[])).push(v))}s&&(s=ee(s)),a&&a!=s&&(a=ee(a));var m=[s];if(!u){var y,b=t.text.length-2;if(b>0&&s)for(var w=0;w<s.length;++w)null==s[w].to&&(y||(y=[])).push(new Y(s[w].marker,null,null));for(var x=0;x<b;++x)m.push(y);m.push(a)}return m}function ee(e){for(var t=0;t<e.length;++t){var r=e[t];null!=r.from&&r.from==r.to&&!1!==r.marker.clearWhenEmpty&&e.splice(t--,1)}return e.length?e:null}function te(e,t,r){var n=null;if(e.iter(t.line,r.line+1,function(e){if(e.markedSpans)for(var t=0;t<e.markedSpans.length;++t){var r=e.markedSpans[t].marker;!r.readOnly||n&&-1!=h(n,r)||(n||(n=[])).push(r)}}),!n)return null;for(var i=[{from:t,to:r}],o=0;o<n.length;++o)for(var l=n[o],s=l.find(0),a=0;a<i.length;++a){var u=i[a];if(!(P(u.to,s.from)<0||P(u.from,s.to)>0)){var c=[a,1],f=P(u.from,s.from),d=P(u.to,s.to);(f<0||!l.inclusiveLeft&&!f)&&c.push({from:u.from,to:s.from}),(d>0||!l.inclusiveRight&&!d)&&c.push({from:s.to,to:u.to}),i.splice.apply(i,c),a+=c.length-3}}return i}function re(e){var t=e.markedSpans;if(t){for(var r=0;r<t.length;++r)t[r].marker.detachLine(e);e.markedSpans=null}}function ne(e,t){if(t){for(var r=0;r<t.length;++r)t[r].marker.attachLine(e);e.markedSpans=t}}function ie(e){return e.inclusiveLeft?-1:0}function oe(e){return e.inclusiveRight?1:0}function le(e,t){var r=e.lines.length-t.lines.length;if(0!=r)return r;var n=e.find(),i=t.find(),o=P(n.from,i.from)||ie(e)-ie(t);if(o)return-o;var l=P(n.to,i.to)||oe(e)-oe(t);return l||t.id-e.id}function se(e,t){var r,n=_l&&e.markedSpans;if(n)for(var i=void 0,o=0;o<n.length;++o)(i=n[o]).marker.collapsed&&null==(t?i.from:i.to)&&(!r||le(r,i.marker)<0)&&(r=i.marker);return r}function ae(e){return se(e,!0)}function ue(e){return se(e,!1)}function ce(e,t,r,n,i){var o=M(e,t),l=_l&&o.markedSpans;if(l)for(var s=0;s<l.length;++s){var a=l[s];if(a.marker.collapsed){var u=a.marker.find(0),c=P(u.from,r)||ie(a.marker)-ie(i),f=P(u.to,n)||oe(a.marker)-oe(i);if(!(c>=0&&f<=0||c<=0&&f>=0)&&(c<=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.to,r)>=0:P(u.to,r)>0)||c>=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.from,n)<=0:P(u.from,n)<0)))return!0}}}function fe(e){for(var t;t=ae(e);)e=t.find(-1,!0).line;return e}function he(e){for(var t;t=ue(e);)e=t.find(1,!0).line;return e}function de(e){for(var t,r;t=ue(e);)e=t.find(1,!0).line,(r||(r=[])).push(e);return r}function pe(e,t){var r=M(e,t),n=fe(r);return r==n?t:W(n)}function ge(e,t){if(t>e.lastLine())return t;var r,n=M(e,t);if(!ve(e,n))return t;for(;r=ue(n);)n=r.find(1,!0).line;return W(n)+1}function ve(e,t){var r=_l&&t.markedSpans;if(r)for(var n=void 0,i=0;i<r.length;++i)if((n=r[i]).marker.collapsed){if(null==n.from)return!0;if(!n.marker.widgetNode&&0==n.from&&n.marker.inclusiveLeft&&me(e,t,n))return!0}}function me(e,t,r){if(null==r.to){var n=r.marker.find(1,!0);return me(e,n.line,_(n.line.markedSpans,r.marker))}if(r.marker.inclusiveRight&&r.to==t.text.length)return!0;for(var i=void 0,o=0;o<t.markedSpans.length;++o)if((i=t.markedSpans[o]).marker.collapsed&&!i.marker.widgetNode&&i.from==r.to&&(null==i.to||i.to!=r.from)&&(i.marker.inclusiveLeft||r.marker.inclusiveRight)&&me(e,t,i))return!0}function ye(e){for(var t=0,r=(e=fe(e)).parent,n=0;n<r.lines.length;++n){var i=r.lines[n];if(i==e)break;t+=i.height}for(var o=r.parent;o;r=o,o=r.parent)for(var l=0;l<o.children.length;++l){var s=o.children[l];if(s==r)break;t+=s.height}return t}function be(e){if(0==e.height)return 0;for(var t,r=e.text.length,n=e;t=ae(n);){var i=t.find(0,!0);n=i.from.line,r+=i.from.ch-i.to.ch}for(n=e;t=ue(n);){var o=t.find(0,!0);r-=n.text.length-o.from.ch,r+=(n=o.to.line).text.length-o.to.ch}return r}function we(e){var t=e.display,r=e.doc;t.maxLine=M(r,r.first),t.maxLineLength=be(t.maxLine),t.maxLineChanged=!0,r.iter(function(e){var r=be(e);r>t.maxLineLength&&(t.maxLineLength=r,t.maxLine=e)})}function xe(e,t,r,n){if(!e)return n(t,r,"ltr",0);for(var i=!1,o=0;o<e.length;++o){var l=e[o];(l.from<r&&l.to>t||t==r&&l.to==t)&&(n(Math.max(l.from,t),Math.min(l.to,r),1==l.level?"rtl":"ltr",o),i=!0)}i||n(t,r,"ltr")}function Ce(e,t,r){var n;$l=null;for(var i=0;i<e.length;++i){var o=e[i];if(o.from<t&&o.to>t)return i;o.to==t&&(o.from!=o.to&&"before"==r?n=i:$l=i),o.from==t&&(o.from!=o.to&&"before"!=r?n=i:$l=i)}return null!=n?n:$l}function Se(e,t){var r=e.order;return null==r&&(r=e.order=ql(e.text,t)),r}function Le(e,t){return e._handlers&&e._handlers[t]||Zl}function ke(e,t,r){if(e.removeEventListener)e.removeEventListener(t,r,!1);else if(e.detachEvent)e.detachEvent("on"+t,r);else{var n=e._handlers,i=n&&n[t];if(i){var o=h(i,r);o>-1&&(n[t]=i.slice(0,o).concat(i.slice(o+1)))}}}function Te(e,t){var r=Le(e,t);if(r.length)for(var n=Array.prototype.slice.call(arguments,2),i=0;i<r.length;++i)r[i].apply(null,n)}function Me(e,t,r){return"string"==typeof t&&(t={type:t,preventDefault:function(){this.defaultPrevented=!0}}),Te(e,r||t.type,e,t),He(t)||t.codemirrorIgnore}function Ne(e){var t=e._handlers&&e._handlers.cursorActivity;if(t)for(var r=e.curOp.cursorActivityHandlers||(e.curOp.cursorActivityHandlers=[]),n=0;n<t.length;++n)-1==h(r,t[n])&&r.push(t[n])}function Oe(e,t){return Le(e,t).length>0}function Ae(e){e.prototype.on=function(e,t){Ql(this,e,t)},e.prototype.off=function(e,t){ke(this,e,t)}}function We(e){e.preventDefault?e.preventDefault():e.returnValue=!1}function De(e){e.stopPropagation?e.stopPropagation():e.cancelBubble=!0}function He(e){return null!=e.defaultPrevented?e.defaultPrevented:0==e.returnValue}function Fe(e){We(e),De(e)}function Ee(e){return e.target||e.srcElement}function Pe(e){var t=e.which;return null==t&&(1&e.button?t=1:2&e.button?t=3:4&e.button&&(t=2)),Ml&&e.ctrlKey&&1==t&&(t=3),t}function Ie(e){if(null==Il){var t=n("span","​");r(e,n("span",[t,document.createTextNode("x")])),0!=e.firstChild.offsetHeight&&(Il=t.offsetWidth<=1&&t.offsetHeight>2&&!(gl&&vl<8))}var i=Il?n("span","​"):n("span"," ",null,"display: inline-block; width: 1px; margin-right: -1px");return i.setAttribute("cm-text",""),i}function ze(e){if(null!=zl)return zl;var n=r(e,document.createTextNode("AخA")),i=Wl(n,0,1).getBoundingClientRect(),o=Wl(n,1,2).getBoundingClientRect();return t(e),!(!i||i.left==i.right)&&(zl=o.right-i.right<3)}function Re(e){if(null!=ns)return ns;var t=r(e,n("span","x")),i=t.getBoundingClientRect(),o=Wl(t,0,1).getBoundingClientRect();return ns=Math.abs(i.left-o.left)>1}function Be(e,t){arguments.length>2&&(t.dependencies=Array.prototype.slice.call(arguments,2)),is[e]=t}function Ge(e){if("string"==typeof e&&os.hasOwnProperty(e))e=os[e];else if(e&&"string"==typeof e.name&&os.hasOwnProperty(e.name)){var t=os[e.name];"string"==typeof t&&(t={name:t}),(e=b(t,e)).name=t.name}else{if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+xml$/.test(e))return Ge("application/xml");if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+json$/.test(e))return Ge("application/json")}return"string"==typeof e?{name:e}:e||{name:"null"}}function Ue(e,t){t=Ge(t);var r=is[t.name];if(!r)return Ue(e,"text/plain");var n=r(e,t);if(ls.hasOwnProperty(t.name)){var i=ls[t.name];for(var o in i)i.hasOwnProperty(o)&&(n.hasOwnProperty(o)&&(n["_"+o]=n[o]),n[o]=i[o])}if(n.name=t.name,t.helperType&&(n.helperType=t.helperType),t.modeProps)for(var l in t.modeProps)n[l]=t.modeProps[l];return n}function Ve(e,t){c(t,ls.hasOwnProperty(e)?ls[e]:ls[e]={})}function Ke(e,t){if(!0===t)return t;if(e.copyState)return e.copyState(t);var r={};for(var n in t){var i=t[n];i instanceof Array&&(i=i.concat([])),r[n]=i}return r}function je(e,t){for(var r;e.innerMode&&(r=e.innerMode(t))&&r.mode!=e;)t=r.state,e=r.mode;return r||{mode:e,state:t}}function Xe(e,t,r){return!e.startState||e.startState(t,r)}function Ye(e,t,r,n){var i=[e.state.modeGen],o={};tt(e,t.text,e.doc.mode,r,function(e,t){return i.push(e,t)},o,n);for(var l=r.state,s=0;s<e.state.overlays.length;++s)!function(n){var l=e.state.overlays[n],s=1,a=0;r.state=!0,tt(e,t.text,l.mode,r,function(e,t){for(var r=s;a<e;){var n=i[s];n>e&&i.splice(s,1,e,i[s+1],n),s+=2,a=Math.min(e,n)}if(t)if(l.opaque)i.splice(r,s-r,e,"overlay "+t),s=r+2;else for(;r<s;r+=2){var o=i[r+1];i[r+1]=(o?o+" ":"")+"overlay "+t}},o)}(s);return r.state=l,{styles:i,classes:o.bgClass||o.textClass?o:null}}function _e(e,t,r){if(!t.styles||t.styles[0]!=e.state.modeGen){var n=$e(e,W(t)),i=t.text.length>e.options.maxHighlightLength&&Ke(e.doc.mode,n.state),o=Ye(e,t,n);i&&(n.state=i),t.stateAfter=n.save(!i),t.styles=o.styles,o.classes?t.styleClasses=o.classes:t.styleClasses&&(t.styleClasses=null),r===e.doc.highlightFrontier&&(e.doc.modeFrontier=Math.max(e.doc.modeFrontier,++e.doc.highlightFrontier))}return t.styles}function $e(e,t,r){var n=e.doc,i=e.display;if(!n.mode.startState)return new us(n,!0,t);var o=rt(e,t,r),l=o>n.first&&M(n,o-1).stateAfter,s=l?us.fromSaved(n,l,o):new us(n,Xe(n.mode),o);return n.iter(o,t,function(r){qe(e,r.text,s);var n=s.line;r.stateAfter=n==t-1||n%5==0||n>=i.viewFrom&&n<i.viewTo?s.save():null,s.nextLine()}),r&&(n.modeFrontier=s.line),s}function qe(e,t,r,n){var i=e.doc.mode,o=new ss(t,e.options.tabSize,r);for(o.start=o.pos=n||0,""==t&&Ze(i,r.state);!o.eol();)Qe(i,o,r.state),o.start=o.pos}function Ze(e,t){if(e.blankLine)return e.blankLine(t);if(e.innerMode){var r=je(e,t);return r.mode.blankLine?r.mode.blankLine(r.state):void 0}}function Qe(e,t,r,n){for(var i=0;i<10;i++){n&&(n[0]=je(e,r).mode);var o=e.token(t,r);if(t.pos>t.start)return o}throw new Error("Mode "+e.name+" failed to advance stream.")}function Je(e,t,r,n){var i,o,l=e.doc,s=l.mode,a=M(l,(t=U(l,t)).line),u=$e(e,t.line,r),c=new ss(a.text,e.options.tabSize,u);for(n&&(o=[]);(n||c.pos<t.ch)&&!c.eol();)c.start=c.pos,i=Qe(s,c,u.state),n&&o.push(new cs(c,i,Ke(l.mode,u.state)));return n?o:new cs(c,i,u.state)}function et(e,t){if(e)for(;;){var r=e.match(/(?:^|\s+)line-(background-)?(\S+)/);if(!r)break;e=e.slice(0,r.index)+e.slice(r.index+r[0].length);var n=r[1]?"bgClass":"textClass";null==t[n]?t[n]=r[2]:new RegExp("(?:^|s)"+r[2]+"(?:$|s)").test(t[n])||(t[n]+=" "+r[2])}return e}function tt(e,t,r,n,i,o,l){var s=r.flattenSpans;null==s&&(s=e.options.flattenSpans);var a,u=0,c=null,f=new ss(t,e.options.tabSize,n),h=e.options.addModeClass&&[null];for(""==t&&et(Ze(r,n.state),o);!f.eol();){if(f.pos>e.options.maxHighlightLength?(s=!1,l&&qe(e,t,n,f.pos),f.pos=t.length,a=null):a=et(Qe(r,f,n.state,h),o),h){var d=h[0].name;d&&(a="m-"+(a?d+" "+a:d))}if(!s||c!=a){for(;u<f.start;)i(u=Math.min(f.start,u+5e3),c);c=a}f.start=f.pos}for(;u<f.pos;){var p=Math.min(f.pos,u+5e3);i(p,c),u=p}}function rt(e,t,r){for(var n,i,o=e.doc,l=r?-1:t-(e.doc.mode.innerMode?1e3:100),s=t;s>l;--s){if(s<=o.first)return o.first;var a=M(o,s-1),u=a.stateAfter;if(u&&(!r||s+(u instanceof as?u.lookAhead:0)<=o.modeFrontier))return s;var c=f(a.text,null,e.options.tabSize);(null==i||n>c)&&(i=s-1,n=c)}return i}function nt(e,t){if(e.modeFrontier=Math.min(e.modeFrontier,t),!(e.highlightFrontier<t-10)){for(var r=e.first,n=t-1;n>r;n--){var i=M(e,n).stateAfter;if(i&&(!(i instanceof as)||n+i.lookAhead<t)){r=n+1;break}}e.highlightFrontier=Math.min(e.highlightFrontier,r)}}function it(e,t,r,n){e.text=t,e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null),null!=e.order&&(e.order=null),re(e),ne(e,r);var i=n?n(e):1;i!=e.height&&A(e,i)}function ot(e){e.parent=null,re(e)}function lt(e,t){if(!e||/^\s*$/.test(e))return null;var r=t.addModeClass?ps:ds;return r[e]||(r[e]=e.replace(/\S+/g,"cm-$&"))}function st(e,t){var r=i("span",null,null,ml?"padding-right: .1px":null),n={pre:i("pre",[r],"CodeMirror-line"),content:r,col:0,pos:0,cm:e,trailingSpace:!1,splitSpaces:(gl||ml)&&e.getOption("lineWrapping")};t.measure={};for(var o=0;o<=(t.rest?t.rest.length:0);o++){var l=o?t.rest[o-1]:t.line,s=void 0;n.pos=0,n.addToken=ut,ze(e.display.measure)&&(s=Se(l,e.doc.direction))&&(n.addToken=ft(n.addToken,s)),n.map=[],dt(l,n,_e(e,l,t!=e.display.externalMeasured&&W(l))),l.styleClasses&&(l.styleClasses.bgClass&&(n.bgClass=a(l.styleClasses.bgClass,n.bgClass||"")),l.styleClasses.textClass&&(n.textClass=a(l.styleClasses.textClass,n.textClass||""))),0==n.map.length&&n.map.push(0,0,n.content.appendChild(Ie(e.display.measure))),0==o?(t.measure.map=n.map,t.measure.cache={}):((t.measure.maps||(t.measure.maps=[])).push(n.map),(t.measure.caches||(t.measure.caches=[])).push({}))}if(ml){var u=n.content.lastChild;(/\bcm-tab\b/.test(u.className)||u.querySelector&&u.querySelector(".cm-tab"))&&(n.content.className="cm-tab-wrap-hack")}return Te(e,"renderLine",e,t.line,n.pre),n.pre.className&&(n.textClass=a(n.pre.className,n.textClass||"")),n}function at(e){var t=n("span","•","cm-invalidchar");return t.title="\\u"+e.charCodeAt(0).toString(16),t.setAttribute("aria-label",t.title),t}function ut(e,t,r,i,o,l,s){if(t){var a,u=e.splitSpaces?ct(t,e.trailingSpace):t,c=e.cm.state.specialChars,f=!1;if(c.test(t)){a=document.createDocumentFragment();for(var h=0;;){c.lastIndex=h;var d=c.exec(t),g=d?d.index-h:t.length-h;if(g){var v=document.createTextNode(u.slice(h,h+g));gl&&vl<9?a.appendChild(n("span",[v])):a.appendChild(v),e.map.push(e.pos,e.pos+g,v),e.col+=g,e.pos+=g}if(!d)break;h+=g+1;var m=void 0;if("\t"==d[0]){var y=e.cm.options.tabSize,b=y-e.col%y;(m=a.appendChild(n("span",p(b),"cm-tab"))).setAttribute("role","presentation"),m.setAttribute("cm-text","\t"),e.col+=b}else"\r"==d[0]||"\n"==d[0]?((m=a.appendChild(n("span","\r"==d[0]?"␍":"␤","cm-invalidchar"))).setAttribute("cm-text",d[0]),e.col+=1):((m=e.cm.options.specialCharPlaceholder(d[0])).setAttribute("cm-text",d[0]),gl&&vl<9?a.appendChild(n("span",[m])):a.appendChild(m),e.col+=1);e.map.push(e.pos,e.pos+1,m),e.pos++}}else e.col+=t.length,a=document.createTextNode(u),e.map.push(e.pos,e.pos+t.length,a),gl&&vl<9&&(f=!0),e.pos+=t.length;if(e.trailingSpace=32==u.charCodeAt(t.length-1),r||i||o||f||s){var w=r||"";i&&(w+=i),o&&(w+=o);var x=n("span",[a],w,s);return l&&(x.title=l),e.content.appendChild(x)}e.content.appendChild(a)}}function ct(e,t){if(e.length>1&&!/  /.test(e))return e;for(var r=t,n="",i=0;i<e.length;i++){var o=e.charAt(i);" "!=o||!r||i!=e.length-1&&32!=e.charCodeAt(i+1)||(o=" "),n+=o,r=" "==o}return n}function ft(e,t){return function(r,n,i,o,l,s,a){i=i?i+" cm-force-border":"cm-force-border";for(var u=r.pos,c=u+n.length;;){for(var f=void 0,h=0;h<t.length&&!((f=t[h]).to>u&&f.from<=u);h++);if(f.to>=c)return e(r,n,i,o,l,s,a);e(r,n.slice(0,f.to-u),i,o,null,s,a),o=null,n=n.slice(f.to-u),u=f.to}}}function ht(e,t,r,n){var i=!n&&r.widgetNode;i&&e.map.push(e.pos,e.pos+t,i),!n&&e.cm.display.input.needsContentAttribute&&(i||(i=e.content.appendChild(document.createElement("span"))),i.setAttribute("cm-marker",r.id)),i&&(e.cm.display.input.setUneditable(i),e.content.appendChild(i)),e.pos+=t,e.trailingSpace=!1}function dt(e,t,r){var n=e.markedSpans,i=e.text,o=0;if(n)for(var l,s,a,u,c,f,h,d=i.length,p=0,g=1,v="",m=0;;){if(m==p){a=u=c=f=s="",h=null,m=1/0;for(var y=[],b=void 0,w=0;w<n.length;++w){var x=n[w],C=x.marker;"bookmark"==C.type&&x.from==p&&C.widgetNode?y.push(C):x.from<=p&&(null==x.to||x.to>p||C.collapsed&&x.to==p&&x.from==p)?(null!=x.to&&x.to!=p&&m>x.to&&(m=x.to,u=""),C.className&&(a+=" "+C.className),C.css&&(s=(s?s+";":"")+C.css),C.startStyle&&x.from==p&&(c+=" "+C.startStyle),C.endStyle&&x.to==m&&(b||(b=[])).push(C.endStyle,x.to),C.title&&!f&&(f=C.title),C.collapsed&&(!h||le(h.marker,C)<0)&&(h=x)):x.from>p&&m>x.from&&(m=x.from)}if(b)for(var S=0;S<b.length;S+=2)b[S+1]==m&&(u+=" "+b[S]);if(!h||h.from==p)for(var L=0;L<y.length;++L)ht(t,0,y[L]);if(h&&(h.from||0)==p){if(ht(t,(null==h.to?d+1:h.to)-p,h.marker,null==h.from),null==h.to)return;h.to==p&&(h=!1)}}if(p>=d)break;for(var k=Math.min(d,m);;){if(v){var T=p+v.length;if(!h){var M=T>k?v.slice(0,k-p):v;t.addToken(t,M,l?l+a:a,c,p+M.length==m?u:"",f,s)}if(T>=k){v=v.slice(k-p),p=k;break}p=T,c=""}v=i.slice(o,o=r[g++]),l=lt(r[g++],t.cm.options)}}else for(var N=1;N<r.length;N+=2)t.addToken(t,i.slice(o,o=r[N]),lt(r[N+1],t.cm.options))}function pt(e,t,r){this.line=t,this.rest=de(t),this.size=this.rest?W(g(this.rest))-r+1:1,this.node=this.text=null,this.hidden=ve(e,t)}function gt(e,t,r){for(var n,i=[],o=t;o<r;o=n){var l=new pt(e.doc,M(e.doc,o),o);n=o+l.size,i.push(l)}return i}function vt(e){gs?gs.ops.push(e):e.ownsGroup=gs={ops:[e],delayedCallbacks:[]}}function mt(e){var t=e.delayedCallbacks,r=0;do{for(;r<t.length;r++)t[r].call(null);for(var n=0;n<e.ops.length;n++){var i=e.ops[n];if(i.cursorActivityHandlers)for(;i.cursorActivityCalled<i.cursorActivityHandlers.length;)i.cursorActivityHandlers[i.cursorActivityCalled++].call(null,i.cm)}}while(r<t.length)}function yt(e,t){var r=e.ownsGroup;if(r)try{mt(r)}finally{gs=null,t(r)}}function bt(e,t){var r=Le(e,t);if(r.length){var n,i=Array.prototype.slice.call(arguments,2);gs?n=gs.delayedCallbacks:vs?n=vs:(n=vs=[],setTimeout(wt,0));for(var o=0;o<r.length;++o)!function(e){n.push(function(){return r[e].apply(null,i)})}(o)}}function wt(){var e=vs;vs=null;for(var t=0;t<e.length;++t)e[t]()}function xt(e,t,r,n){for(var i=0;i<t.changes.length;i++){var o=t.changes[i];"text"==o?kt(e,t):"gutter"==o?Mt(e,t,r,n):"class"==o?Tt(e,t):"widget"==o&&Nt(e,t,n)}t.changes=null}function Ct(e){return e.node==e.text&&(e.node=n("div",null,null,"position: relative"),e.text.parentNode&&e.text.parentNode.replaceChild(e.node,e.text),e.node.appendChild(e.text),gl&&vl<8&&(e.node.style.zIndex=2)),e.node}function St(e,t){var r=t.bgClass?t.bgClass+" "+(t.line.bgClass||""):t.line.bgClass;if(r&&(r+=" CodeMirror-linebackground"),t.background)r?t.background.className=r:(t.background.parentNode.removeChild(t.background),t.background=null);else if(r){var i=Ct(t);t.background=i.insertBefore(n("div",null,r),i.firstChild),e.display.input.setUneditable(t.background)}}function Lt(e,t){var r=e.display.externalMeasured;return r&&r.line==t.line?(e.display.externalMeasured=null,t.measure=r.measure,r.built):st(e,t)}function kt(e,t){var r=t.text.className,n=Lt(e,t);t.text==t.node&&(t.node=n.pre),t.text.parentNode.replaceChild(n.pre,t.text),t.text=n.pre,n.bgClass!=t.bgClass||n.textClass!=t.textClass?(t.bgClass=n.bgClass,t.textClass=n.textClass,Tt(e,t)):r&&(t.text.className=r)}function Tt(e,t){St(e,t),t.line.wrapClass?Ct(t).className=t.line.wrapClass:t.node!=t.text&&(t.node.className="");var r=t.textClass?t.textClass+" "+(t.line.textClass||""):t.line.textClass;t.text.className=r||""}function Mt(e,t,r,i){if(t.gutter&&(t.node.removeChild(t.gutter),t.gutter=null),t.gutterBackground&&(t.node.removeChild(t.gutterBackground),t.gutterBackground=null),t.line.gutterClass){var o=Ct(t);t.gutterBackground=n("div",null,"CodeMirror-gutter-background "+t.line.gutterClass,"left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px; width: "+i.gutterTotalWidth+"px"),e.display.input.setUneditable(t.gutterBackground),o.insertBefore(t.gutterBackground,t.text)}var l=t.line.gutterMarkers;if(e.options.lineNumbers||l){var s=Ct(t),a=t.gutter=n("div",null,"CodeMirror-gutter-wrapper","left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px");if(e.display.input.setUneditable(a),s.insertBefore(a,t.text),t.line.gutterClass&&(a.className+=" "+t.line.gutterClass),!e.options.lineNumbers||l&&l["CodeMirror-linenumbers"]||(t.lineNumber=a.appendChild(n("div",F(e.options,r),"CodeMirror-linenumber CodeMirror-gutter-elt","left: "+i.gutterLeft["CodeMirror-linenumbers"]+"px; width: "+e.display.lineNumInnerWidth+"px"))),l)for(var u=0;u<e.options.gutters.length;++u){var c=e.options.gutters[u],f=l.hasOwnProperty(c)&&l[c];f&&a.appendChild(n("div",[f],"CodeMirror-gutter-elt","left: "+i.gutterLeft[c]+"px; width: "+i.gutterWidth[c]+"px"))}}}function Nt(e,t,r){t.alignable&&(t.alignable=null);for(var n=t.node.firstChild,i=void 0;n;n=i)i=n.nextSibling,"CodeMirror-linewidget"==n.className&&t.node.removeChild(n);At(e,t,r)}function Ot(e,t,r,n){var i=Lt(e,t);return t.text=t.node=i.pre,i.bgClass&&(t.bgClass=i.bgClass),i.textClass&&(t.textClass=i.textClass),Tt(e,t),Mt(e,t,r,n),At(e,t,n),t.node}function At(e,t,r){if(Wt(e,t.line,t,r,!0),t.rest)for(var n=0;n<t.rest.length;n++)Wt(e,t.rest[n],t,r,!1)}function Wt(e,t,r,i,o){if(t.widgets)for(var l=Ct(r),s=0,a=t.widgets;s<a.length;++s){var u=a[s],c=n("div",[u.node],"CodeMirror-linewidget");u.handleMouseEvents||c.setAttribute("cm-ignore-events","true"),Dt(u,c,r,i),e.display.input.setUneditable(c),o&&u.above?l.insertBefore(c,r.gutter||r.text):l.appendChild(c),bt(u,"redraw")}}function Dt(e,t,r,n){if(e.noHScroll){(r.alignable||(r.alignable=[])).push(t);var i=n.wrapperWidth;t.style.left=n.fixedPos+"px",e.coverGutter||(i-=n.gutterTotalWidth,t.style.paddingLeft=n.gutterTotalWidth+"px"),t.style.width=i+"px"}e.coverGutter&&(t.style.zIndex=5,t.style.position="relative",e.noHScroll||(t.style.marginLeft=-n.gutterTotalWidth+"px"))}function Ht(e){if(null!=e.height)return e.height;var t=e.doc.cm;if(!t)return 0;if(!o(document.body,e.node)){var i="position: relative;";e.coverGutter&&(i+="margin-left: -"+t.display.gutters.offsetWidth+"px;"),e.noHScroll&&(i+="width: "+t.display.wrapper.clientWidth+"px;"),r(t.display.measure,n("div",[e.node],null,i))}return e.height=e.node.parentNode.offsetHeight}function Ft(e,t){for(var r=Ee(t);r!=e.wrapper;r=r.parentNode)if(!r||1==r.nodeType&&"true"==r.getAttribute("cm-ignore-events")||r.parentNode==e.sizer&&r!=e.mover)return!0}function Et(e){return e.lineSpace.offsetTop}function Pt(e){return e.mover.offsetHeight-e.lineSpace.offsetHeight}function It(e){if(e.cachedPaddingH)return e.cachedPaddingH;var t=r(e.measure,n("pre","x")),i=window.getComputedStyle?window.getComputedStyle(t):t.currentStyle,o={left:parseInt(i.paddingLeft),right:parseInt(i.paddingRight)};return isNaN(o.left)||isNaN(o.right)||(e.cachedPaddingH=o),o}function zt(e){return Rl-e.display.nativeBarWidth}function Rt(e){return e.display.scroller.clientWidth-zt(e)-e.display.barWidth}function Bt(e){return e.display.scroller.clientHeight-zt(e)-e.display.barHeight}function Gt(e,t,r){var n=e.options.lineWrapping,i=n&&Rt(e);if(!t.measure.heights||n&&t.measure.width!=i){var o=t.measure.heights=[];if(n){t.measure.width=i;for(var l=t.text.firstChild.getClientRects(),s=0;s<l.length-1;s++){var a=l[s],u=l[s+1];Math.abs(a.bottom-u.bottom)>2&&o.push((a.bottom+u.top)/2-r.top)}}o.push(r.bottom-r.top)}}function Ut(e,t,r){if(e.line==t)return{map:e.measure.map,cache:e.measure.cache};for(var n=0;n<e.rest.length;n++)if(e.rest[n]==t)return{map:e.measure.maps[n],cache:e.measure.caches[n]};for(var i=0;i<e.rest.length;i++)if(W(e.rest[i])>r)return{map:e.measure.maps[i],cache:e.measure.caches[i],before:!0}}function Vt(e,t){var n=W(t=fe(t)),i=e.display.externalMeasured=new pt(e.doc,t,n);i.lineN=n;var o=i.built=st(e,i);return i.text=o.pre,r(e.display.lineMeasure,o.pre),i}function Kt(e,t,r,n){return Yt(e,Xt(e,t),r,n)}function jt(e,t){if(t>=e.display.viewFrom&&t<e.display.viewTo)return e.display.view[Lr(e,t)];var r=e.display.externalMeasured;return r&&t>=r.lineN&&t<r.lineN+r.size?r:void 0}function Xt(e,t){var r=W(t),n=jt(e,r);n&&!n.text?n=null:n&&n.changes&&(xt(e,n,r,br(e)),e.curOp.forceUpdate=!0),n||(n=Vt(e,t));var i=Ut(n,t,r);return{line:t,view:n,rect:null,map:i.map,cache:i.cache,before:i.before,hasHeights:!1}}function Yt(e,t,r,n,i){t.before&&(r=-1);var o,l=r+(n||"");return t.cache.hasOwnProperty(l)?o=t.cache[l]:(t.rect||(t.rect=t.view.text.getBoundingClientRect()),t.hasHeights||(Gt(e,t.view,t.rect),t.hasHeights=!0),(o=qt(e,t,r,n)).bogus||(t.cache[l]=o)),{left:o.left,right:o.right,top:i?o.rtop:o.top,bottom:i?o.rbottom:o.bottom}}function _t(e,t,r){for(var n,i,o,l,s,a,u=0;u<e.length;u+=3)if(s=e[u],a=e[u+1],t<s?(i=0,o=1,l="left"):t<a?o=(i=t-s)+1:(u==e.length-3||t==a&&e[u+3]>t)&&(i=(o=a-s)-1,t>=a&&(l="right")),null!=i){if(n=e[u+2],s==a&&r==(n.insertLeft?"left":"right")&&(l=r),"left"==r&&0==i)for(;u&&e[u-2]==e[u-3]&&e[u-1].insertLeft;)n=e[2+(u-=3)],l="left";if("right"==r&&i==a-s)for(;u<e.length-3&&e[u+3]==e[u+4]&&!e[u+5].insertLeft;)n=e[(u+=3)+2],l="right";break}return{node:n,start:i,end:o,collapse:l,coverStart:s,coverEnd:a}}function $t(e,t){var r=ms;if("left"==t)for(var n=0;n<e.length&&(r=e[n]).left==r.right;n++);else for(var i=e.length-1;i>=0&&(r=e[i]).left==r.right;i--);return r}function qt(e,t,r,n){var i,o=_t(t.map,r,n),l=o.node,s=o.start,a=o.end,u=o.collapse;if(3==l.nodeType){for(var c=0;c<4;c++){for(;s&&S(t.line.text.charAt(o.coverStart+s));)--s;for(;o.coverStart+a<o.coverEnd&&S(t.line.text.charAt(o.coverStart+a));)++a;if((i=gl&&vl<9&&0==s&&a==o.coverEnd-o.coverStart?l.parentNode.getBoundingClientRect():$t(Wl(l,s,a).getClientRects(),n)).left||i.right||0==s)break;a=s,s-=1,u="right"}gl&&vl<11&&(i=Zt(e.display.measure,i))}else{s>0&&(u=n="right");var f;i=e.options.lineWrapping&&(f=l.getClientRects()).length>1?f["right"==n?f.length-1:0]:l.getBoundingClientRect()}if(gl&&vl<9&&!s&&(!i||!i.left&&!i.right)){var h=l.parentNode.getClientRects()[0];i=h?{left:h.left,right:h.left+yr(e.display),top:h.top,bottom:h.bottom}:ms}for(var d=i.top-t.rect.top,p=i.bottom-t.rect.top,g=(d+p)/2,v=t.view.measure.heights,m=0;m<v.length-1&&!(g<v[m]);m++);var y=m?v[m-1]:0,b=v[m],w={left:("right"==u?i.right:i.left)-t.rect.left,right:("left"==u?i.left:i.right)-t.rect.left,top:y,bottom:b};return i.left||i.right||(w.bogus=!0),e.options.singleCursorHeightPerLine||(w.rtop=d,w.rbottom=p),w}function Zt(e,t){if(!window.screen||null==screen.logicalXDPI||screen.logicalXDPI==screen.deviceXDPI||!Re(e))return t;var r=screen.logicalXDPI/screen.deviceXDPI,n=screen.logicalYDPI/screen.deviceYDPI;return{left:t.left*r,right:t.right*r,top:t.top*n,bottom:t.bottom*n}}function Qt(e){if(e.measure&&(e.measure.cache={},e.measure.heights=null,e.rest))for(var t=0;t<e.rest.length;t++)e.measure.caches[t]={}}function Jt(e){e.display.externalMeasure=null,t(e.display.lineMeasure);for(var r=0;r<e.display.view.length;r++)Qt(e.display.view[r])}function er(e){Jt(e),e.display.cachedCharWidth=e.display.cachedTextHeight=e.display.cachedPaddingH=null,e.options.lineWrapping||(e.display.maxLineChanged=!0),e.display.lineNumChars=null}function tr(){return bl&&kl?-(document.body.getBoundingClientRect().left-parseInt(getComputedStyle(document.body).marginLeft)):window.pageXOffset||(document.documentElement||document.body).scrollLeft}function rr(){return bl&&kl?-(document.body.getBoundingClientRect().top-parseInt(getComputedStyle(document.body).marginTop)):window.pageYOffset||(document.documentElement||document.body).scrollTop}function nr(e){var t=0;if(e.widgets)for(var r=0;r<e.widgets.length;++r)e.widgets[r].above&&(t+=Ht(e.widgets[r]));return t}function ir(e,t,r,n,i){if(!i){var o=nr(t);r.top+=o,r.bottom+=o}if("line"==n)return r;n||(n="local");var l=ye(t);if("local"==n?l+=Et(e.display):l-=e.display.viewOffset,"page"==n||"window"==n){var s=e.display.lineSpace.getBoundingClientRect();l+=s.top+("window"==n?0:rr());var a=s.left+("window"==n?0:tr());r.left+=a,r.right+=a}return r.top+=l,r.bottom+=l,r}function or(e,t,r){if("div"==r)return t;var n=t.left,i=t.top;if("page"==r)n-=tr(),i-=rr();else if("local"==r||!r){var o=e.display.sizer.getBoundingClientRect();n+=o.left,i+=o.top}var l=e.display.lineSpace.getBoundingClientRect();return{left:n-l.left,top:i-l.top}}function lr(e,t,r,n,i){return n||(n=M(e.doc,t.line)),ir(e,n,Kt(e,n,t.ch,i),r)}function sr(e,t,r,n,i,o){function l(t,l){var s=Yt(e,i,t,l?"right":"left",o);return l?s.left=s.right:s.right=s.left,ir(e,n,s,r)}function s(e,t,r){var n=1==a[t].level;return l(r?e-1:e,n!=r)}n=n||M(e.doc,t.line),i||(i=Xt(e,n));var a=Se(n,e.doc.direction),u=t.ch,c=t.sticky;if(u>=n.text.length?(u=n.text.length,c="before"):u<=0&&(u=0,c="after"),!a)return l("before"==c?u-1:u,"before"==c);var f=Ce(a,u,c),h=$l,d=s(u,f,"before"==c);return null!=h&&(d.other=s(u,h,"before"!=c)),d}function ar(e,t){var r=0;t=U(e.doc,t),e.options.lineWrapping||(r=yr(e.display)*t.ch);var n=M(e.doc,t.line),i=ye(n)+Et(e.display);return{left:r,right:r,top:i,bottom:i+n.height}}function ur(e,t,r,n,i){var o=E(e,t,r);return o.xRel=i,n&&(o.outside=!0),o}function cr(e,t,r){var n=e.doc;if((r+=e.display.viewOffset)<0)return ur(n.first,0,null,!0,-1);var i=D(n,r),o=n.first+n.size-1;if(i>o)return ur(n.first+n.size-1,M(n,o).text.length,null,!0,1);t<0&&(t=0);for(var l=M(n,i);;){var s=pr(e,l,i,t,r),a=ue(l),u=a&&a.find(0,!0);if(!a||!(s.ch>u.from.ch||s.ch==u.from.ch&&s.xRel>0))return s;i=W(l=u.to.line)}}function fr(e,t,r,n){n-=nr(t);var i=t.text.length,o=k(function(t){return Yt(e,r,t-1).bottom<=n},i,0);return i=k(function(t){return Yt(e,r,t).top>n},o,i),{begin:o,end:i}}function hr(e,t,r,n){return r||(r=Xt(e,t)),fr(e,t,r,ir(e,t,Yt(e,r,n),"line").top)}function dr(e,t,r,n){return!(e.bottom<=r)&&(e.top>r||(n?e.left:e.right)>t)}function pr(e,t,r,n,i){i-=ye(t);var o=Xt(e,t),l=nr(t),s=0,a=t.text.length,u=!0,c=Se(t,e.doc.direction);if(c){var f=(e.options.lineWrapping?vr:gr)(e,t,r,o,c,n,i);s=(u=1!=f.level)?f.from:f.to-1,a=u?f.to:f.from-1}var h,d,p=null,g=null,v=k(function(t){var r=Yt(e,o,t);return r.top+=l,r.bottom+=l,!!dr(r,n,i,!1)&&(r.top<=i&&r.left<=n&&(p=t,g=r),!0)},s,a),m=!1;if(g){var y=n-g.left<g.right-n,b=y==u;v=p+(b?0:1),d=b?"after":"before",h=y?g.left:g.right}else{u||v!=a&&v!=s||v++,d=0==v?"after":v==t.text.length?"before":Yt(e,o,v-(u?1:0)).bottom+l<=i==u?"after":"before";var w=sr(e,E(r,v,d),"line",t,o);h=w.left,m=i<w.top||i>=w.bottom}return v=L(t.text,v,1),ur(r,v,d,m,n-h)}function gr(e,t,r,n,i,o,l){var s=k(function(s){var a=i[s],u=1!=a.level;return dr(sr(e,E(r,u?a.to:a.from,u?"before":"after"),"line",t,n),o,l,!0)},0,i.length-1),a=i[s];if(s>0){var u=1!=a.level,c=sr(e,E(r,u?a.from:a.to,u?"after":"before"),"line",t,n);dr(c,o,l,!0)&&c.top>l&&(a=i[s-1])}return a}function vr(e,t,r,n,i,o,l){for(var s=fr(e,t,n,l),a=s.begin,u=s.end,c=null,f=null,h=0;h<i.length;h++){var d=i[h];if(!(d.from>=u||d.to<=a)){var p=Yt(e,n,1!=d.level?Math.min(u,d.to)-1:Math.max(a,d.from)).right,g=p<o?o-p+1e9:p-o;(!c||f>g)&&(c=d,f=g)}}return c||(c=i[i.length-1]),c.from<a&&(c={from:a,to:c.to,level:c.level}),c.to>u&&(c={from:c.from,to:u,level:c.level}),c}function mr(e){if(null!=e.cachedTextHeight)return e.cachedTextHeight;if(null==hs){hs=n("pre");for(var i=0;i<49;++i)hs.appendChild(document.createTextNode("x")),hs.appendChild(n("br"));hs.appendChild(document.createTextNode("x"))}r(e.measure,hs);var o=hs.offsetHeight/50;return o>3&&(e.cachedTextHeight=o),t(e.measure),o||1}function yr(e){if(null!=e.cachedCharWidth)return e.cachedCharWidth;var t=n("span","xxxxxxxxxx"),i=n("pre",[t]);r(e.measure,i);var o=t.getBoundingClientRect(),l=(o.right-o.left)/10;return l>2&&(e.cachedCharWidth=l),l||10}function br(e){for(var t=e.display,r={},n={},i=t.gutters.clientLeft,o=t.gutters.firstChild,l=0;o;o=o.nextSibling,++l)r[e.options.gutters[l]]=o.offsetLeft+o.clientLeft+i,n[e.options.gutters[l]]=o.clientWidth;return{fixedPos:wr(t),gutterTotalWidth:t.gutters.offsetWidth,gutterLeft:r,gutterWidth:n,wrapperWidth:t.wrapper.clientWidth}}function wr(e){return e.scroller.getBoundingClientRect().left-e.sizer.getBoundingClientRect().left}function xr(e){var t=mr(e.display),r=e.options.lineWrapping,n=r&&Math.max(5,e.display.scroller.clientWidth/yr(e.display)-3);return function(i){if(ve(e.doc,i))return 0;var o=0;if(i.widgets)for(var l=0;l<i.widgets.length;l++)i.widgets[l].height&&(o+=i.widgets[l].height);return r?o+(Math.ceil(i.text.length/n)||1)*t:o+t}}function Cr(e){var t=e.doc,r=xr(e);t.iter(function(e){var t=r(e);t!=e.height&&A(e,t)})}function Sr(e,t,r,n){var i=e.display;if(!r&&"true"==Ee(t).getAttribute("cm-not-content"))return null;var o,l,s=i.lineSpace.getBoundingClientRect();try{o=t.clientX-s.left,l=t.clientY-s.top}catch(t){return null}var a,u=cr(e,o,l);if(n&&1==u.xRel&&(a=M(e.doc,u.line).text).length==u.ch){var c=f(a,a.length,e.options.tabSize)-a.length;u=E(u.line,Math.max(0,Math.round((o-It(e.display).left)/yr(e.display))-c))}return u}function Lr(e,t){if(t>=e.display.viewTo)return null;if((t-=e.display.viewFrom)<0)return null;for(var r=e.display.view,n=0;n<r.length;n++)if((t-=r[n].size)<0)return n}function kr(e){e.display.input.showSelection(e.display.input.prepareSelection())}function Tr(e,t){void 0===t&&(t=!0);for(var r=e.doc,n={},i=n.cursors=document.createDocumentFragment(),o=n.selection=document.createDocumentFragment(),l=0;l<r.sel.ranges.length;l++)if(t||l!=r.sel.primIndex){var s=r.sel.ranges[l];if(!(s.from().line>=e.display.viewTo||s.to().line<e.display.viewFrom)){var a=s.empty();(a||e.options.showCursorWhenSelecting)&&Mr(e,s.head,i),a||Or(e,s,o)}}return n}function Mr(e,t,r){var i=sr(e,t,"div",null,null,!e.options.singleCursorHeightPerLine),o=r.appendChild(n("div"," ","CodeMirror-cursor"));if(o.style.left=i.left+"px",o.style.top=i.top+"px",o.style.height=Math.max(0,i.bottom-i.top)*e.options.cursorHeight+"px",i.other){var l=r.appendChild(n("div"," ","CodeMirror-cursor CodeMirror-secondarycursor"));l.style.display="",l.style.left=i.other.left+"px",l.style.top=i.other.top+"px",l.style.height=.85*(i.other.bottom-i.other.top)+"px"}}function Nr(e,t){return e.top-t.top||e.left-t.left}function Or(e,t,r){function i(e,t,r,i){t<0&&(t=0),t=Math.round(t),i=Math.round(i),a.appendChild(n("div",null,"CodeMirror-selected","position: absolute; left: "+e+"px;\n                             top: "+t+"px; width: "+(null==r?f-e:r)+"px;\n                             height: "+(i-t)+"px"))}function o(t,r,n){function o(r,n){return lr(e,E(t,r),"div",u,n)}var l,a,u=M(s,t),h=u.text.length,d=Se(u,s.direction);return xe(d,r||0,null==n?h:n,function(t,s,p,g){var v=o(t,"ltr"==p?"left":"right"),m=o(s-1,"ltr"==p?"right":"left");if("ltr"==p){var y=null==r&&0==t?c:v.left,b=null==n&&s==h?f:m.right;m.top-v.top<=3?i(y,m.top,b-y,m.bottom):(i(y,v.top,null,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top),i(c,m.top,m.right,m.bottom))}else if(t<s){var w=null==r&&0==t?f:v.right,x=null==n&&s==h?c:m.left;if(m.top-v.top<=3)i(x,m.top,w-x,m.bottom);else{var C=c;if(g){var S=hr(e,u,null,t).end;C=o(S-(/\s/.test(u.text.charAt(S-1))?2:1),"left").left}i(C,v.top,w-C,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top);var L=null;d.length,L=o(hr(e,u,null,s).begin,"right").right-x,i(x,m.top,L,m.bottom)}}(!l||Nr(v,l)<0)&&(l=v),Nr(m,l)<0&&(l=m),(!a||Nr(v,a)<0)&&(a=v),Nr(m,a)<0&&(a=m)}),{start:l,end:a}}var l=e.display,s=e.doc,a=document.createDocumentFragment(),u=It(e.display),c=u.left,f=Math.max(l.sizerWidth,Rt(e)-l.sizer.offsetLeft)-u.right,h=t.from(),d=t.to();if(h.line==d.line)o(h.line,h.ch,d.ch);else{var p=M(s,h.line),g=M(s,d.line),v=fe(p)==fe(g),m=o(h.line,h.ch,v?p.text.length+1:null).end,y=o(d.line,v?0:null,d.ch).start;v&&(m.top<y.top-2?(i(m.right,m.top,null,m.bottom),i(c,y.top,y.left,y.bottom)):i(m.right,m.top,y.left-m.right,m.bottom)),m.bottom<y.top&&i(c,m.bottom,null,y.top)}r.appendChild(a)}function Ar(e){if(e.state.focused){var t=e.display;clearInterval(t.blinker);var r=!0;t.cursorDiv.style.visibility="",e.options.cursorBlinkRate>0?t.blinker=setInterval(function(){return t.cursorDiv.style.visibility=(r=!r)?"":"hidden"},e.options.cursorBlinkRate):e.options.cursorBlinkRate<0&&(t.cursorDiv.style.visibility="hidden")}}function Wr(e){e.state.focused||(e.display.input.focus(),Hr(e))}function Dr(e){e.state.delayingBlurEvent=!0,setTimeout(function(){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1,Fr(e))},100)}function Hr(e,t){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1),"nocursor"!=e.options.readOnly&&(e.state.focused||(Te(e,"focus",e,t),e.state.focused=!0,s(e.display.wrapper,"CodeMirror-focused"),e.curOp||e.display.selForContextMenu==e.doc.sel||(e.display.input.reset(),ml&&setTimeout(function(){return e.display.input.reset(!0)},20)),e.display.input.receivedFocus()),Ar(e))}function Fr(e,t){e.state.delayingBlurEvent||(e.state.focused&&(Te(e,"blur",e,t),e.state.focused=!1,Fl(e.display.wrapper,"CodeMirror-focused")),clearInterval(e.display.blinker),setTimeout(function(){e.state.focused||(e.display.shift=!1)},150))}function Er(e){for(var t=e.display,r=t.lineDiv.offsetTop,n=0;n<t.view.length;n++){var i=t.view[n],o=void 0;if(!i.hidden){if(gl&&vl<8){var l=i.node.offsetTop+i.node.offsetHeight;o=l-r,r=l}else{var s=i.node.getBoundingClientRect();o=s.bottom-s.top}var a=i.line.height-o;if(o<2&&(o=mr(t)),(a>.005||a<-.005)&&(A(i.line,o),Pr(i.line),i.rest))for(var u=0;u<i.rest.length;u++)Pr(i.rest[u])}}}function Pr(e){if(e.widgets)for(var t=0;t<e.widgets.length;++t)e.widgets[t].height=e.widgets[t].node.parentNode.offsetHeight}function Ir(e,t,r){var n=r&&null!=r.top?Math.max(0,r.top):e.scroller.scrollTop;n=Math.floor(n-Et(e));var i=r&&null!=r.bottom?r.bottom:n+e.wrapper.clientHeight,o=D(t,n),l=D(t,i);if(r&&r.ensure){var s=r.ensure.from.line,a=r.ensure.to.line;s<o?(o=s,l=D(t,ye(M(t,s))+e.wrapper.clientHeight)):Math.min(a,t.lastLine())>=l&&(o=D(t,ye(M(t,a))-e.wrapper.clientHeight),l=a)}return{from:o,to:Math.max(l,o+1)}}function zr(e){var t=e.display,r=t.view;if(t.alignWidgets||t.gutters.firstChild&&e.options.fixedGutter){for(var n=wr(t)-t.scroller.scrollLeft+e.doc.scrollLeft,i=t.gutters.offsetWidth,o=n+"px",l=0;l<r.length;l++)if(!r[l].hidden){e.options.fixedGutter&&(r[l].gutter&&(r[l].gutter.style.left=o),r[l].gutterBackground&&(r[l].gutterBackground.style.left=o));var s=r[l].alignable;if(s)for(var a=0;a<s.length;a++)s[a].style.left=o}e.options.fixedGutter&&(t.gutters.style.left=n+i+"px")}}function Rr(e){if(!e.options.lineNumbers)return!1;var t=e.doc,r=F(e.options,t.first+t.size-1),i=e.display;if(r.length!=i.lineNumChars){var o=i.measure.appendChild(n("div",[n("div",r)],"CodeMirror-linenumber CodeMirror-gutter-elt")),l=o.firstChild.offsetWidth,s=o.offsetWidth-l;return i.lineGutter.style.width="",i.lineNumInnerWidth=Math.max(l,i.lineGutter.offsetWidth-s)+1,i.lineNumWidth=i.lineNumInnerWidth+s,i.lineNumChars=i.lineNumInnerWidth?r.length:-1,i.lineGutter.style.width=i.lineNumWidth+"px",Wn(e),!0}return!1}function Br(e,t){if(!Me(e,"scrollCursorIntoView")){var r=e.display,i=r.sizer.getBoundingClientRect(),o=null;if(t.top+i.top<0?o=!0:t.bottom+i.top>(window.innerHeight||document.documentElement.clientHeight)&&(o=!1),null!=o&&!Sl){var l=n("div","​",null,"position: absolute;\n                         top: "+(t.top-r.viewOffset-Et(e.display))+"px;\n                         height: "+(t.bottom-t.top+zt(e)+r.barHeight)+"px;\n                         left: "+t.left+"px; width: "+Math.max(2,t.right-t.left)+"px;");e.display.lineSpace.appendChild(l),l.scrollIntoView(o),e.display.lineSpace.removeChild(l)}}}function Gr(e,t,r,n){null==n&&(n=0);var i;e.options.lineWrapping||t!=r||(r="before"==(t=t.ch?E(t.line,"before"==t.sticky?t.ch-1:t.ch,"after"):t).sticky?E(t.line,t.ch+1,"before"):t);for(var o=0;o<5;o++){var l=!1,s=sr(e,t),a=r&&r!=t?sr(e,r):s,u=Vr(e,i={left:Math.min(s.left,a.left),top:Math.min(s.top,a.top)-n,right:Math.max(s.left,a.left),bottom:Math.max(s.bottom,a.bottom)+n}),c=e.doc.scrollTop,f=e.doc.scrollLeft;if(null!=u.scrollTop&&(qr(e,u.scrollTop),Math.abs(e.doc.scrollTop-c)>1&&(l=!0)),null!=u.scrollLeft&&(Qr(e,u.scrollLeft),Math.abs(e.doc.scrollLeft-f)>1&&(l=!0)),!l)break}return i}function Ur(e,t){var r=Vr(e,t);null!=r.scrollTop&&qr(e,r.scrollTop),null!=r.scrollLeft&&Qr(e,r.scrollLeft)}function Vr(e,t){var r=e.display,n=mr(e.display);t.top<0&&(t.top=0);var i=e.curOp&&null!=e.curOp.scrollTop?e.curOp.scrollTop:r.scroller.scrollTop,o=Bt(e),l={};t.bottom-t.top>o&&(t.bottom=t.top+o);var s=e.doc.height+Pt(r),a=t.top<n,u=t.bottom>s-n;if(t.top<i)l.scrollTop=a?0:t.top;else if(t.bottom>i+o){var c=Math.min(t.top,(u?s:t.bottom)-o);c!=i&&(l.scrollTop=c)}var f=e.curOp&&null!=e.curOp.scrollLeft?e.curOp.scrollLeft:r.scroller.scrollLeft,h=Rt(e)-(e.options.fixedGutter?r.gutters.offsetWidth:0),d=t.right-t.left>h;return d&&(t.right=t.left+h),t.left<10?l.scrollLeft=0:t.left<f?l.scrollLeft=Math.max(0,t.left-(d?0:10)):t.right>h+f-3&&(l.scrollLeft=t.right+(d?0:10)-h),l}function Kr(e,t){null!=t&&(_r(e),e.curOp.scrollTop=(null==e.curOp.scrollTop?e.doc.scrollTop:e.curOp.scrollTop)+t)}function jr(e){_r(e);var t=e.getCursor();e.curOp.scrollToPos={from:t,to:t,margin:e.options.cursorScrollMargin}}function Xr(e,t,r){null==t&&null==r||_r(e),null!=t&&(e.curOp.scrollLeft=t),null!=r&&(e.curOp.scrollTop=r)}function Yr(e,t){_r(e),e.curOp.scrollToPos=t}function _r(e){var t=e.curOp.scrollToPos;t&&(e.curOp.scrollToPos=null,$r(e,ar(e,t.from),ar(e,t.to),t.margin))}function $r(e,t,r,n){var i=Vr(e,{left:Math.min(t.left,r.left),top:Math.min(t.top,r.top)-n,right:Math.max(t.right,r.right),bottom:Math.max(t.bottom,r.bottom)+n});Xr(e,i.scrollLeft,i.scrollTop)}function qr(e,t){Math.abs(e.doc.scrollTop-t)<2||(fl||On(e,{top:t}),Zr(e,t,!0),fl&&On(e),Cn(e,100))}function Zr(e,t,r){t=Math.min(e.display.scroller.scrollHeight-e.display.scroller.clientHeight,t),(e.display.scroller.scrollTop!=t||r)&&(e.doc.scrollTop=t,e.display.scrollbars.setScrollTop(t),e.display.scroller.scrollTop!=t&&(e.display.scroller.scrollTop=t))}function Qr(e,t,r,n){t=Math.min(t,e.display.scroller.scrollWidth-e.display.scroller.clientWidth),(r?t==e.doc.scrollLeft:Math.abs(e.doc.scrollLeft-t)<2)&&!n||(e.doc.scrollLeft=t,zr(e),e.display.scroller.scrollLeft!=t&&(e.display.scroller.scrollLeft=t),e.display.scrollbars.setScrollLeft(t))}function Jr(e){var t=e.display,r=t.gutters.offsetWidth,n=Math.round(e.doc.height+Pt(e.display));return{clientHeight:t.scroller.clientHeight,viewHeight:t.wrapper.clientHeight,scrollWidth:t.scroller.scrollWidth,clientWidth:t.scroller.clientWidth,viewWidth:t.wrapper.clientWidth,barLeft:e.options.fixedGutter?r:0,docHeight:n,scrollHeight:n+zt(e)+t.barHeight,nativeBarWidth:t.nativeBarWidth,gutterWidth:r}}function en(e,t){t||(t=Jr(e));var r=e.display.barWidth,n=e.display.barHeight;tn(e,t);for(var i=0;i<4&&r!=e.display.barWidth||n!=e.display.barHeight;i++)r!=e.display.barWidth&&e.options.lineWrapping&&Er(e),tn(e,Jr(e)),r=e.display.barWidth,n=e.display.barHeight}function tn(e,t){var r=e.display,n=r.scrollbars.update(t);r.sizer.style.paddingRight=(r.barWidth=n.right)+"px",r.sizer.style.paddingBottom=(r.barHeight=n.bottom)+"px",r.heightForcer.style.borderBottom=n.bottom+"px solid transparent",n.right&&n.bottom?(r.scrollbarFiller.style.display="block",r.scrollbarFiller.style.height=n.bottom+"px",r.scrollbarFiller.style.width=n.right+"px"):r.scrollbarFiller.style.display="",n.bottom&&e.options.coverGutterNextToScrollbar&&e.options.fixedGutter?(r.gutterFiller.style.display="block",r.gutterFiller.style.height=n.bottom+"px",r.gutterFiller.style.width=t.gutterWidth+"px"):r.gutterFiller.style.display=""}function rn(e){e.display.scrollbars&&(e.display.scrollbars.clear(),e.display.scrollbars.addClass&&Fl(e.display.wrapper,e.display.scrollbars.addClass)),e.display.scrollbars=new ws[e.options.scrollbarStyle](function(t){e.display.wrapper.insertBefore(t,e.display.scrollbarFiller),Ql(t,"mousedown",function(){e.state.focused&&setTimeout(function(){return e.display.input.focus()},0)}),t.setAttribute("cm-not-content","true")},function(t,r){"horizontal"==r?Qr(e,t):qr(e,t)},e),e.display.scrollbars.addClass&&s(e.display.wrapper,e.display.scrollbars.addClass)}function nn(e){e.curOp={cm:e,viewChanged:!1,startHeight:e.doc.height,forceUpdate:!1,updateInput:null,typing:!1,changeObjs:null,cursorActivityHandlers:null,cursorActivityCalled:0,selectionChanged:!1,updateMaxLine:!1,scrollLeft:null,scrollTop:null,scrollToPos:null,focus:!1,id:++xs},vt(e.curOp)}function on(e){yt(e.curOp,function(e){for(var t=0;t<e.ops.length;t++)e.ops[t].cm.curOp=null;ln(e)})}function ln(e){for(var t=e.ops,r=0;r<t.length;r++)sn(t[r]);for(var n=0;n<t.length;n++)an(t[n]);for(var i=0;i<t.length;i++)un(t[i]);for(var o=0;o<t.length;o++)cn(t[o]);for(var l=0;l<t.length;l++)fn(t[l])}function sn(e){var t=e.cm,r=t.display;Ln(t),e.updateMaxLine&&we(t),e.mustUpdate=e.viewChanged||e.forceUpdate||null!=e.scrollTop||e.scrollToPos&&(e.scrollToPos.from.line<r.viewFrom||e.scrollToPos.to.line>=r.viewTo)||r.maxLineChanged&&t.options.lineWrapping,e.update=e.mustUpdate&&new Cs(t,e.mustUpdate&&{top:e.scrollTop,ensure:e.scrollToPos},e.forceUpdate)}function an(e){e.updatedDisplay=e.mustUpdate&&Mn(e.cm,e.update)}function un(e){var t=e.cm,r=t.display;e.updatedDisplay&&Er(t),e.barMeasure=Jr(t),r.maxLineChanged&&!t.options.lineWrapping&&(e.adjustWidthTo=Kt(t,r.maxLine,r.maxLine.text.length).left+3,t.display.sizerWidth=e.adjustWidthTo,e.barMeasure.scrollWidth=Math.max(r.scroller.clientWidth,r.sizer.offsetLeft+e.adjustWidthTo+zt(t)+t.display.barWidth),e.maxScrollLeft=Math.max(0,r.sizer.offsetLeft+e.adjustWidthTo-Rt(t))),(e.updatedDisplay||e.selectionChanged)&&(e.preparedSelection=r.input.prepareSelection())}function cn(e){var t=e.cm;null!=e.adjustWidthTo&&(t.display.sizer.style.minWidth=e.adjustWidthTo+"px",e.maxScrollLeft<t.doc.scrollLeft&&Qr(t,Math.min(t.display.scroller.scrollLeft,e.maxScrollLeft),!0),t.display.maxLineChanged=!1);var r=e.focus&&e.focus==l();e.preparedSelection&&t.display.input.showSelection(e.preparedSelection,r),(e.updatedDisplay||e.startHeight!=t.doc.height)&&en(t,e.barMeasure),e.updatedDisplay&&Dn(t,e.barMeasure),e.selectionChanged&&Ar(t),t.state.focused&&e.updateInput&&t.display.input.reset(e.typing),r&&Wr(e.cm)}function fn(e){var t=e.cm,r=t.display,n=t.doc;e.updatedDisplay&&Nn(t,e.update),null==r.wheelStartX||null==e.scrollTop&&null==e.scrollLeft&&!e.scrollToPos||(r.wheelStartX=r.wheelStartY=null),null!=e.scrollTop&&Zr(t,e.scrollTop,e.forceScroll),null!=e.scrollLeft&&Qr(t,e.scrollLeft,!0,!0),e.scrollToPos&&Br(t,Gr(t,U(n,e.scrollToPos.from),U(n,e.scrollToPos.to),e.scrollToPos.margin));var i=e.maybeHiddenMarkers,o=e.maybeUnhiddenMarkers;if(i)for(var l=0;l<i.length;++l)i[l].lines.length||Te(i[l],"hide");if(o)for(var s=0;s<o.length;++s)o[s].lines.length&&Te(o[s],"unhide");r.wrapper.offsetHeight&&(n.scrollTop=t.display.scroller.scrollTop),e.changeObjs&&Te(t,"changes",t,e.changeObjs),e.update&&e.update.finish()}function hn(e,t){if(e.curOp)return t();nn(e);try{return t()}finally{on(e)}}function dn(e,t){return function(){if(e.curOp)return t.apply(e,arguments);nn(e);try{return t.apply(e,arguments)}finally{on(e)}}}function pn(e){return function(){if(this.curOp)return e.apply(this,arguments);nn(this);try{return e.apply(this,arguments)}finally{on(this)}}}function gn(e){return function(){var t=this.cm;if(!t||t.curOp)return e.apply(this,arguments);nn(t);try{return e.apply(this,arguments)}finally{on(t)}}}function vn(e,t,r,n){null==t&&(t=e.doc.first),null==r&&(r=e.doc.first+e.doc.size),n||(n=0);var i=e.display;if(n&&r<i.viewTo&&(null==i.updateLineNumbers||i.updateLineNumbers>t)&&(i.updateLineNumbers=t),e.curOp.viewChanged=!0,t>=i.viewTo)_l&&pe(e.doc,t)<i.viewTo&&yn(e);else if(r<=i.viewFrom)_l&&ge(e.doc,r+n)>i.viewFrom?yn(e):(i.viewFrom+=n,i.viewTo+=n);else if(t<=i.viewFrom&&r>=i.viewTo)yn(e);else if(t<=i.viewFrom){var o=bn(e,r,r+n,1);o?(i.view=i.view.slice(o.index),i.viewFrom=o.lineN,i.viewTo+=n):yn(e)}else if(r>=i.viewTo){var l=bn(e,t,t,-1);l?(i.view=i.view.slice(0,l.index),i.viewTo=l.lineN):yn(e)}else{var s=bn(e,t,t,-1),a=bn(e,r,r+n,1);s&&a?(i.view=i.view.slice(0,s.index).concat(gt(e,s.lineN,a.lineN)).concat(i.view.slice(a.index)),i.viewTo+=n):yn(e)}var u=i.externalMeasured;u&&(r<u.lineN?u.lineN+=n:t<u.lineN+u.size&&(i.externalMeasured=null))}function mn(e,t,r){e.curOp.viewChanged=!0;var n=e.display,i=e.display.externalMeasured;if(i&&t>=i.lineN&&t<i.lineN+i.size&&(n.externalMeasured=null),!(t<n.viewFrom||t>=n.viewTo)){var o=n.view[Lr(e,t)];if(null!=o.node){var l=o.changes||(o.changes=[]);-1==h(l,r)&&l.push(r)}}}function yn(e){e.display.viewFrom=e.display.viewTo=e.doc.first,e.display.view=[],e.display.viewOffset=0}function bn(e,t,r,n){var i,o=Lr(e,t),l=e.display.view;if(!_l||r==e.doc.first+e.doc.size)return{index:o,lineN:r};for(var s=e.display.viewFrom,a=0;a<o;a++)s+=l[a].size;if(s!=t){if(n>0){if(o==l.length-1)return null;i=s+l[o].size-t,o++}else i=s-t;t+=i,r+=i}for(;pe(e.doc,r)!=r;){if(o==(n<0?0:l.length-1))return null;r+=n*l[o-(n<0?1:0)].size,o+=n}return{index:o,lineN:r}}function wn(e,t,r){var n=e.display;0==n.view.length||t>=n.viewTo||r<=n.viewFrom?(n.view=gt(e,t,r),n.viewFrom=t):(n.viewFrom>t?n.view=gt(e,t,n.viewFrom).concat(n.view):n.viewFrom<t&&(n.view=n.view.slice(Lr(e,t))),n.viewFrom=t,n.viewTo<r?n.view=n.view.concat(gt(e,n.viewTo,r)):n.viewTo>r&&(n.view=n.view.slice(0,Lr(e,r)))),n.viewTo=r}function xn(e){for(var t=e.display.view,r=0,n=0;n<t.length;n++){var i=t[n];i.hidden||i.node&&!i.changes||++r}return r}function Cn(e,t){e.doc.highlightFrontier<e.display.viewTo&&e.state.highlight.set(t,u(Sn,e))}function Sn(e){var t=e.doc;if(!(t.highlightFrontier>=e.display.viewTo)){var r=+new Date+e.options.workTime,n=$e(e,t.highlightFrontier),i=[];t.iter(n.line,Math.min(t.first+t.size,e.display.viewTo+500),function(o){if(n.line>=e.display.viewFrom){var l=o.styles,s=o.text.length>e.options.maxHighlightLength?Ke(t.mode,n.state):null,a=Ye(e,o,n,!0);s&&(n.state=s),o.styles=a.styles;var u=o.styleClasses,c=a.classes;c?o.styleClasses=c:u&&(o.styleClasses=null);for(var f=!l||l.length!=o.styles.length||u!=c&&(!u||!c||u.bgClass!=c.bgClass||u.textClass!=c.textClass),h=0;!f&&h<l.length;++h)f=l[h]!=o.styles[h];f&&i.push(n.line),o.stateAfter=n.save(),n.nextLine()}else o.text.length<=e.options.maxHighlightLength&&qe(e,o.text,n),o.stateAfter=n.line%5==0?n.save():null,n.nextLine();if(+new Date>r)return Cn(e,e.options.workDelay),!0}),t.highlightFrontier=n.line,t.modeFrontier=Math.max(t.modeFrontier,n.line),i.length&&hn(e,function(){for(var t=0;t<i.length;t++)mn(e,i[t],"text")})}}function Ln(e){var t=e.display;!t.scrollbarsClipped&&t.scroller.offsetWidth&&(t.nativeBarWidth=t.scroller.offsetWidth-t.scroller.clientWidth,t.heightForcer.style.height=zt(e)+"px",t.sizer.style.marginBottom=-t.nativeBarWidth+"px",t.sizer.style.borderRightWidth=zt(e)+"px",t.scrollbarsClipped=!0)}function kn(e){if(e.hasFocus())return null;var t=l();if(!t||!o(e.display.lineDiv,t))return null;var r={activeElt:t};if(window.getSelection){var n=window.getSelection();n.anchorNode&&n.extend&&o(e.display.lineDiv,n.anchorNode)&&(r.anchorNode=n.anchorNode,r.anchorOffset=n.anchorOffset,r.focusNode=n.focusNode,r.focusOffset=n.focusOffset)}return r}function Tn(e){if(e&&e.activeElt&&e.activeElt!=l()&&(e.activeElt.focus(),e.anchorNode&&o(document.body,e.anchorNode)&&o(document.body,e.focusNode))){var t=window.getSelection(),r=document.createRange();r.setEnd(e.anchorNode,e.anchorOffset),r.collapse(!1),t.removeAllRanges(),t.addRange(r),t.extend(e.focusNode,e.focusOffset)}}function Mn(e,r){var n=e.display,i=e.doc;if(r.editorIsHidden)return yn(e),!1;if(!r.force&&r.visible.from>=n.viewFrom&&r.visible.to<=n.viewTo&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo)&&n.renderedView==n.view&&0==xn(e))return!1;Rr(e)&&(yn(e),r.dims=br(e));var o=i.first+i.size,l=Math.max(r.visible.from-e.options.viewportMargin,i.first),s=Math.min(o,r.visible.to+e.options.viewportMargin);n.viewFrom<l&&l-n.viewFrom<20&&(l=Math.max(i.first,n.viewFrom)),n.viewTo>s&&n.viewTo-s<20&&(s=Math.min(o,n.viewTo)),_l&&(l=pe(e.doc,l),s=ge(e.doc,s));var a=l!=n.viewFrom||s!=n.viewTo||n.lastWrapHeight!=r.wrapperHeight||n.lastWrapWidth!=r.wrapperWidth;wn(e,l,s),n.viewOffset=ye(M(e.doc,n.viewFrom)),e.display.mover.style.top=n.viewOffset+"px";var u=xn(e);if(!a&&0==u&&!r.force&&n.renderedView==n.view&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo))return!1;var c=kn(e);return u>4&&(n.lineDiv.style.display="none"),An(e,n.updateLineNumbers,r.dims),u>4&&(n.lineDiv.style.display=""),n.renderedView=n.view,Tn(c),t(n.cursorDiv),t(n.selectionDiv),n.gutters.style.height=n.sizer.style.minHeight=0,a&&(n.lastWrapHeight=r.wrapperHeight,n.lastWrapWidth=r.wrapperWidth,Cn(e,400)),n.updateLineNumbers=null,!0}function Nn(e,t){for(var r=t.viewport,n=!0;(n&&e.options.lineWrapping&&t.oldDisplayWidth!=Rt(e)||(r&&null!=r.top&&(r={top:Math.min(e.doc.height+Pt(e.display)-Bt(e),r.top)}),t.visible=Ir(e.display,e.doc,r),!(t.visible.from>=e.display.viewFrom&&t.visible.to<=e.display.viewTo)))&&Mn(e,t);n=!1){Er(e);var i=Jr(e);kr(e),en(e,i),Dn(e,i),t.force=!1}t.signal(e,"update",e),e.display.viewFrom==e.display.reportedViewFrom&&e.display.viewTo==e.display.reportedViewTo||(t.signal(e,"viewportChange",e,e.display.viewFrom,e.display.viewTo),e.display.reportedViewFrom=e.display.viewFrom,e.display.reportedViewTo=e.display.viewTo)}function On(e,t){var r=new Cs(e,t);if(Mn(e,r)){Er(e),Nn(e,r);var n=Jr(e);kr(e),en(e,n),Dn(e,n),r.finish()}}function An(e,r,n){function i(t){var r=t.nextSibling;return ml&&Ml&&e.display.currentWheelTarget==t?t.style.display="none":t.parentNode.removeChild(t),r}for(var o=e.display,l=e.options.lineNumbers,s=o.lineDiv,a=s.firstChild,u=o.view,c=o.viewFrom,f=0;f<u.length;f++){var d=u[f];if(d.hidden);else if(d.node&&d.node.parentNode==s){for(;a!=d.node;)a=i(a);var p=l&&null!=r&&r<=c&&d.lineNumber;d.changes&&(h(d.changes,"gutter")>-1&&(p=!1),xt(e,d,c,n)),p&&(t(d.lineNumber),d.lineNumber.appendChild(document.createTextNode(F(e.options,c)))),a=d.node.nextSibling}else{var g=Ot(e,d,c,n);s.insertBefore(g,a)}c+=d.size}for(;a;)a=i(a)}function Wn(e){var t=e.display.gutters.offsetWidth;e.display.sizer.style.marginLeft=t+"px"}function Dn(e,t){e.display.sizer.style.minHeight=t.docHeight+"px",e.display.heightForcer.style.top=t.docHeight+"px",e.display.gutters.style.height=t.docHeight+e.display.barHeight+zt(e)+"px"}function Hn(e){var r=e.display.gutters,i=e.options.gutters;t(r);for(var o=0;o<i.length;++o){var l=i[o],s=r.appendChild(n("div",null,"CodeMirror-gutter "+l));"CodeMirror-linenumbers"==l&&(e.display.lineGutter=s,s.style.width=(e.display.lineNumWidth||1)+"px")}r.style.display=o?"":"none",Wn(e)}function Fn(e){var t=h(e.gutters,"CodeMirror-linenumbers");-1==t&&e.lineNumbers?e.gutters=e.gutters.concat(["CodeMirror-linenumbers"]):t>-1&&!e.lineNumbers&&(e.gutters=e.gutters.slice(0),e.gutters.splice(t,1))}function En(e){var t=e.wheelDeltaX,r=e.wheelDeltaY;return null==t&&e.detail&&e.axis==e.HORIZONTAL_AXIS&&(t=e.detail),null==r&&e.detail&&e.axis==e.VERTICAL_AXIS?r=e.detail:null==r&&(r=e.wheelDelta),{x:t,y:r}}function Pn(e){var t=En(e);return t.x*=Ls,t.y*=Ls,t}function In(e,t){var r=En(t),n=r.x,i=r.y,o=e.display,l=o.scroller,s=l.scrollWidth>l.clientWidth,a=l.scrollHeight>l.clientHeight;if(n&&s||i&&a){if(i&&Ml&&ml)e:for(var u=t.target,c=o.view;u!=l;u=u.parentNode)for(var f=0;f<c.length;f++)if(c[f].node==u){e.display.currentWheelTarget=u;break e}if(n&&!fl&&!wl&&null!=Ls)return i&&a&&qr(e,Math.max(0,l.scrollTop+i*Ls)),Qr(e,Math.max(0,l.scrollLeft+n*Ls)),(!i||i&&a)&&We(t),void(o.wheelStartX=null);if(i&&null!=Ls){var h=i*Ls,d=e.doc.scrollTop,p=d+o.wrapper.clientHeight;h<0?d=Math.max(0,d+h-50):p=Math.min(e.doc.height,p+h+50),On(e,{top:d,bottom:p})}Ss<20&&(null==o.wheelStartX?(o.wheelStartX=l.scrollLeft,o.wheelStartY=l.scrollTop,o.wheelDX=n,o.wheelDY=i,setTimeout(function(){if(null!=o.wheelStartX){var e=l.scrollLeft-o.wheelStartX,t=l.scrollTop-o.wheelStartY,r=t&&o.wheelDY&&t/o.wheelDY||e&&o.wheelDX&&e/o.wheelDX;o.wheelStartX=o.wheelStartY=null,r&&(Ls=(Ls*Ss+r)/(Ss+1),++Ss)}},200)):(o.wheelDX+=n,o.wheelDY+=i))}}function zn(e,t){var r=e[t];e.sort(function(e,t){return P(e.from(),t.from())}),t=h(e,r);for(var n=1;n<e.length;n++){var i=e[n],o=e[n-1];if(P(o.to(),i.from())>=0){var l=B(o.from(),i.from()),s=R(o.to(),i.to()),a=o.empty()?i.from()==i.head:o.from()==o.head;n<=t&&--t,e.splice(--n,2,new Ts(a?s:l,a?l:s))}}return new ks(e,t)}function Rn(e,t){return new ks([new Ts(e,t||e)],0)}function Bn(e){return e.text?E(e.from.line+e.text.length-1,g(e.text).length+(1==e.text.length?e.from.ch:0)):e.to}function Gn(e,t){if(P(e,t.from)<0)return e;if(P(e,t.to)<=0)return Bn(t);var r=e.line+t.text.length-(t.to.line-t.from.line)-1,n=e.ch;return e.line==t.to.line&&(n+=Bn(t).ch-t.to.ch),E(r,n)}function Un(e,t){for(var r=[],n=0;n<e.sel.ranges.length;n++){var i=e.sel.ranges[n];r.push(new Ts(Gn(i.anchor,t),Gn(i.head,t)))}return zn(r,e.sel.primIndex)}function Vn(e,t,r){return e.line==t.line?E(r.line,e.ch-t.ch+r.ch):E(r.line+(e.line-t.line),e.ch)}function Kn(e,t,r){for(var n=[],i=E(e.first,0),o=i,l=0;l<t.length;l++){var s=t[l],a=Vn(s.from,i,o),u=Vn(Bn(s),i,o);if(i=s.to,o=u,"around"==r){var c=e.sel.ranges[l],f=P(c.head,c.anchor)<0;n[l]=new Ts(f?u:a,f?a:u)}else n[l]=new Ts(a,a)}return new ks(n,e.sel.primIndex)}function jn(e){e.doc.mode=Ue(e.options,e.doc.modeOption),Xn(e)}function Xn(e){e.doc.iter(function(e){e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null)}),e.doc.modeFrontier=e.doc.highlightFrontier=e.doc.first,Cn(e,100),e.state.modeGen++,e.curOp&&vn(e)}function Yn(e,t){return 0==t.from.ch&&0==t.to.ch&&""==g(t.text)&&(!e.cm||e.cm.options.wholeLineUpdateBefore)}function _n(e,t,r,n){function i(e){return r?r[e]:null}function o(e,r,i){it(e,r,i,n),bt(e,"change",e,t)}function l(e,t){for(var r=[],o=e;o<t;++o)r.push(new fs(u[o],i(o),n));return r}var s=t.from,a=t.to,u=t.text,c=M(e,s.line),f=M(e,a.line),h=g(u),d=i(u.length-1),p=a.line-s.line;if(t.full)e.insert(0,l(0,u.length)),e.remove(u.length,e.size-u.length);else if(Yn(e,t)){var v=l(0,u.length-1);o(f,f.text,d),p&&e.remove(s.line,p),v.length&&e.insert(s.line,v)}else if(c==f)if(1==u.length)o(c,c.text.slice(0,s.ch)+h+c.text.slice(a.ch),d);else{var m=l(1,u.length-1);m.push(new fs(h+c.text.slice(a.ch),d,n)),o(c,c.text.slice(0,s.ch)+u[0],i(0)),e.insert(s.line+1,m)}else if(1==u.length)o(c,c.text.slice(0,s.ch)+u[0]+f.text.slice(a.ch),i(0)),e.remove(s.line+1,p);else{o(c,c.text.slice(0,s.ch)+u[0],i(0)),o(f,h+f.text.slice(a.ch),d);var y=l(1,u.length-1);p>1&&e.remove(s.line+1,p-1),e.insert(s.line+1,y)}bt(e,"change",e,t)}function $n(e,t,r){function n(e,i,o){if(e.linked)for(var l=0;l<e.linked.length;++l){var s=e.linked[l];if(s.doc!=i){var a=o&&s.sharedHist;r&&!a||(t(s.doc,a),n(s.doc,e,a))}}}n(e,null,!0)}function qn(e,t){if(t.cm)throw new Error("This document is already in use.");e.doc=t,t.cm=e,Cr(e),jn(e),Zn(e),e.options.lineWrapping||we(e),e.options.mode=t.modeOption,vn(e)}function Zn(e){("rtl"==e.doc.direction?s:Fl)(e.display.lineDiv,"CodeMirror-rtl")}function Qn(e){hn(e,function(){Zn(e),vn(e)})}function Jn(e){this.done=[],this.undone=[],this.undoDepth=1/0,this.lastModTime=this.lastSelTime=0,this.lastOp=this.lastSelOp=null,this.lastOrigin=this.lastSelOrigin=null,this.generation=this.maxGeneration=e||1}function ei(e,t){var r={from:z(t.from),to:Bn(t),text:N(e,t.from,t.to)};return si(e,r,t.from.line,t.to.line+1),$n(e,function(e){return si(e,r,t.from.line,t.to.line+1)},!0),r}function ti(e){for(;e.length&&g(e).ranges;)e.pop()}function ri(e,t){return t?(ti(e.done),g(e.done)):e.done.length&&!g(e.done).ranges?g(e.done):e.done.length>1&&!e.done[e.done.length-2].ranges?(e.done.pop(),g(e.done)):void 0}function ni(e,t,r,n){var i=e.history;i.undone.length=0;var o,l,s=+new Date;if((i.lastOp==n||i.lastOrigin==t.origin&&t.origin&&("+"==t.origin.charAt(0)&&e.cm&&i.lastModTime>s-e.cm.options.historyEventDelay||"*"==t.origin.charAt(0)))&&(o=ri(i,i.lastOp==n)))l=g(o.changes),0==P(t.from,t.to)&&0==P(t.from,l.to)?l.to=Bn(t):o.changes.push(ei(e,t));else{var a=g(i.done);for(a&&a.ranges||li(e.sel,i.done),o={changes:[ei(e,t)],generation:i.generation},i.done.push(o);i.done.length>i.undoDepth;)i.done.shift(),i.done[0].ranges||i.done.shift()}i.done.push(r),i.generation=++i.maxGeneration,i.lastModTime=i.lastSelTime=s,i.lastOp=i.lastSelOp=n,i.lastOrigin=i.lastSelOrigin=t.origin,l||Te(e,"historyAdded")}function ii(e,t,r,n){var i=t.charAt(0);return"*"==i||"+"==i&&r.ranges.length==n.ranges.length&&r.somethingSelected()==n.somethingSelected()&&new Date-e.history.lastSelTime<=(e.cm?e.cm.options.historyEventDelay:500)}function oi(e,t,r,n){var i=e.history,o=n&&n.origin;r==i.lastSelOp||o&&i.lastSelOrigin==o&&(i.lastModTime==i.lastSelTime&&i.lastOrigin==o||ii(e,o,g(i.done),t))?i.done[i.done.length-1]=t:li(t,i.done),i.lastSelTime=+new Date,i.lastSelOrigin=o,i.lastSelOp=r,n&&!1!==n.clearRedo&&ti(i.undone)}function li(e,t){var r=g(t);r&&r.ranges&&r.equals(e)||t.push(e)}function si(e,t,r,n){var i=t["spans_"+e.id],o=0;e.iter(Math.max(e.first,r),Math.min(e.first+e.size,n),function(r){r.markedSpans&&((i||(i=t["spans_"+e.id]={}))[o]=r.markedSpans),++o})}function ai(e){if(!e)return null;for(var t,r=0;r<e.length;++r)e[r].marker.explicitlyCleared?t||(t=e.slice(0,r)):t&&t.push(e[r]);return t?t.length?t:null:e}function ui(e,t){var r=t["spans_"+e.id];if(!r)return null;for(var n=[],i=0;i<t.text.length;++i)n.push(ai(r[i]));return n}function ci(e,t){var r=ui(e,t),n=J(e,t);if(!r)return n;if(!n)return r;for(var i=0;i<r.length;++i){var o=r[i],l=n[i];if(o&&l)e:for(var s=0;s<l.length;++s){for(var a=l[s],u=0;u<o.length;++u)if(o[u].marker==a.marker)continue e;o.push(a)}else l&&(r[i]=l)}return r}function fi(e,t,r){for(var n=[],i=0;i<e.length;++i){var o=e[i];if(o.ranges)n.push(r?ks.prototype.deepCopy.call(o):o);else{var l=o.changes,s=[];n.push({changes:s});for(var a=0;a<l.length;++a){var u=l[a],c=void 0;if(s.push({from:u.from,to:u.to,text:u.text}),t)for(var f in u)(c=f.match(/^spans_(\d+)$/))&&h(t,Number(c[1]))>-1&&(g(s)[f]=u[f],delete u[f])}}}return n}function hi(e,t,r,n){if(n){var i=e.anchor;if(r){var o=P(t,i)<0;o!=P(r,i)<0?(i=t,t=r):o!=P(t,r)<0&&(t=r)}return new Ts(i,t)}return new Ts(r||t,t)}function di(e,t,r,n,i){null==i&&(i=e.cm&&(e.cm.display.shift||e.extend)),bi(e,new ks([hi(e.sel.primary(),t,r,i)],0),n)}function pi(e,t,r){for(var n=[],i=e.cm&&(e.cm.display.shift||e.extend),o=0;o<e.sel.ranges.length;o++)n[o]=hi(e.sel.ranges[o],t[o],null,i);bi(e,zn(n,e.sel.primIndex),r)}function gi(e,t,r,n){var i=e.sel.ranges.slice(0);i[t]=r,bi(e,zn(i,e.sel.primIndex),n)}function vi(e,t,r,n){bi(e,Rn(t,r),n)}function mi(e,t,r){var n={ranges:t.ranges,update:function(t){var r=this;this.ranges=[];for(var n=0;n<t.length;n++)r.ranges[n]=new Ts(U(e,t[n].anchor),U(e,t[n].head))},origin:r&&r.origin};return Te(e,"beforeSelectionChange",e,n),e.cm&&Te(e.cm,"beforeSelectionChange",e.cm,n),n.ranges!=t.ranges?zn(n.ranges,n.ranges.length-1):t}function yi(e,t,r){var n=e.history.done,i=g(n);i&&i.ranges?(n[n.length-1]=t,wi(e,t,r)):bi(e,t,r)}function bi(e,t,r){wi(e,t,r),oi(e,e.sel,e.cm?e.cm.curOp.id:NaN,r)}function wi(e,t,r){(Oe(e,"beforeSelectionChange")||e.cm&&Oe(e.cm,"beforeSelectionChange"))&&(t=mi(e,t,r)),xi(e,Si(e,t,r&&r.bias||(P(t.primary().head,e.sel.primary().head)<0?-1:1),!0)),r&&!1===r.scroll||!e.cm||jr(e.cm)}function xi(e,t){t.equals(e.sel)||(e.sel=t,e.cm&&(e.cm.curOp.updateInput=e.cm.curOp.selectionChanged=!0,Ne(e.cm)),bt(e,"cursorActivity",e))}function Ci(e){xi(e,Si(e,e.sel,null,!1))}function Si(e,t,r,n){for(var i,o=0;o<t.ranges.length;o++){var l=t.ranges[o],s=t.ranges.length==e.sel.ranges.length&&e.sel.ranges[o],a=ki(e,l.anchor,s&&s.anchor,r,n),u=ki(e,l.head,s&&s.head,r,n);(i||a!=l.anchor||u!=l.head)&&(i||(i=t.ranges.slice(0,o)),i[o]=new Ts(a,u))}return i?zn(i,t.primIndex):t}function Li(e,t,r,n,i){var o=M(e,t.line);if(o.markedSpans)for(var l=0;l<o.markedSpans.length;++l){var s=o.markedSpans[l],a=s.marker;if((null==s.from||(a.inclusiveLeft?s.from<=t.ch:s.from<t.ch))&&(null==s.to||(a.inclusiveRight?s.to>=t.ch:s.to>t.ch))){if(i&&(Te(a,"beforeCursorEnter"),a.explicitlyCleared)){if(o.markedSpans){--l;continue}break}if(!a.atomic)continue;if(r){var u=a.find(n<0?1:-1),c=void 0;if((n<0?a.inclusiveRight:a.inclusiveLeft)&&(u=Ti(e,u,-n,u&&u.line==t.line?o:null)),u&&u.line==t.line&&(c=P(u,r))&&(n<0?c<0:c>0))return Li(e,u,t,n,i)}var f=a.find(n<0?-1:1);return(n<0?a.inclusiveLeft:a.inclusiveRight)&&(f=Ti(e,f,n,f.line==t.line?o:null)),f?Li(e,f,t,n,i):null}}return t}function ki(e,t,r,n,i){var o=n||1,l=Li(e,t,r,o,i)||!i&&Li(e,t,r,o,!0)||Li(e,t,r,-o,i)||!i&&Li(e,t,r,-o,!0);return l||(e.cantEdit=!0,E(e.first,0))}function Ti(e,t,r,n){return r<0&&0==t.ch?t.line>e.first?U(e,E(t.line-1)):null:r>0&&t.ch==(n||M(e,t.line)).text.length?t.line<e.first+e.size-1?E(t.line+1,0):null:new E(t.line,t.ch+r)}function Mi(e){e.setSelection(E(e.firstLine(),0),E(e.lastLine()),Gl)}function Ni(e,t,r){var n={canceled:!1,from:t.from,to:t.to,text:t.text,origin:t.origin,cancel:function(){return n.canceled=!0}};return r&&(n.update=function(t,r,i,o){t&&(n.from=U(e,t)),r&&(n.to=U(e,r)),i&&(n.text=i),void 0!==o&&(n.origin=o)}),Te(e,"beforeChange",e,n),e.cm&&Te(e.cm,"beforeChange",e.cm,n),n.canceled?null:{from:n.from,to:n.to,text:n.text,origin:n.origin}}function Oi(e,t,r){if(e.cm){if(!e.cm.curOp)return dn(e.cm,Oi)(e,t,r);if(e.cm.state.suppressEdits)return}if(!(Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"))||(t=Ni(e,t,!0))){var n=Yl&&!r&&te(e,t.from,t.to);if(n)for(var i=n.length-1;i>=0;--i)Ai(e,{from:n[i].from,to:n[i].to,text:i?[""]:t.text,origin:t.origin});else Ai(e,t)}}function Ai(e,t){if(1!=t.text.length||""!=t.text[0]||0!=P(t.from,t.to)){var r=Un(e,t);ni(e,t,r,e.cm?e.cm.curOp.id:NaN),Hi(e,t,r,J(e,t));var n=[];$n(e,function(e,r){r||-1!=h(n,e.history)||(zi(e.history,t),n.push(e.history)),Hi(e,t,null,J(e,t))})}}function Wi(e,t,r){if(!e.cm||!e.cm.state.suppressEdits||r){for(var n,i=e.history,o=e.sel,l="undo"==t?i.done:i.undone,s="undo"==t?i.undone:i.done,a=0;a<l.length&&(n=l[a],r?!n.ranges||n.equals(e.sel):n.ranges);a++);if(a!=l.length){for(i.lastOrigin=i.lastSelOrigin=null;(n=l.pop()).ranges;){if(li(n,s),r&&!n.equals(e.sel))return void bi(e,n,{clearRedo:!1});o=n}var u=[];li(o,s),s.push({changes:u,generation:i.generation}),i.generation=n.generation||++i.maxGeneration;for(var c=Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"),f=n.changes.length-1;f>=0;--f){var d=function(r){var i=n.changes[r];if(i.origin=t,c&&!Ni(e,i,!1))return l.length=0,{};u.push(ei(e,i));var o=r?Un(e,i):g(l);Hi(e,i,o,ci(e,i)),!r&&e.cm&&e.cm.scrollIntoView({from:i.from,to:Bn(i)});var s=[];$n(e,function(e,t){t||-1!=h(s,e.history)||(zi(e.history,i),s.push(e.history)),Hi(e,i,null,ci(e,i))})}(f);if(d)return d.v}}}}function Di(e,t){if(0!=t&&(e.first+=t,e.sel=new ks(v(e.sel.ranges,function(e){return new Ts(E(e.anchor.line+t,e.anchor.ch),E(e.head.line+t,e.head.ch))}),e.sel.primIndex),e.cm)){vn(e.cm,e.first,e.first-t,t);for(var r=e.cm.display,n=r.viewFrom;n<r.viewTo;n++)mn(e.cm,n,"gutter")}}function Hi(e,t,r,n){if(e.cm&&!e.cm.curOp)return dn(e.cm,Hi)(e,t,r,n);if(t.to.line<e.first)Di(e,t.text.length-1-(t.to.line-t.from.line));else if(!(t.from.line>e.lastLine())){if(t.from.line<e.first){var i=t.text.length-1-(e.first-t.from.line);Di(e,i),t={from:E(e.first,0),to:E(t.to.line+i,t.to.ch),text:[g(t.text)],origin:t.origin}}var o=e.lastLine();t.to.line>o&&(t={from:t.from,to:E(o,M(e,o).text.length),text:[t.text[0]],origin:t.origin}),t.removed=N(e,t.from,t.to),r||(r=Un(e,t)),e.cm?Fi(e.cm,t,n):_n(e,t,n),wi(e,r,Gl)}}function Fi(e,t,r){var n=e.doc,i=e.display,o=t.from,l=t.to,s=!1,a=o.line;e.options.lineWrapping||(a=W(fe(M(n,o.line))),n.iter(a,l.line+1,function(e){if(e==i.maxLine)return s=!0,!0})),n.sel.contains(t.from,t.to)>-1&&Ne(e),_n(n,t,r,xr(e)),e.options.lineWrapping||(n.iter(a,o.line+t.text.length,function(e){var t=be(e);t>i.maxLineLength&&(i.maxLine=e,i.maxLineLength=t,i.maxLineChanged=!0,s=!1)}),s&&(e.curOp.updateMaxLine=!0)),nt(n,o.line),Cn(e,400);var u=t.text.length-(l.line-o.line)-1;t.full?vn(e):o.line!=l.line||1!=t.text.length||Yn(e.doc,t)?vn(e,o.line,l.line+1,u):mn(e,o.line,"text");var c=Oe(e,"changes"),f=Oe(e,"change");if(f||c){var h={from:o,to:l,text:t.text,removed:t.removed,origin:t.origin};f&&bt(e,"change",e,h),c&&(e.curOp.changeObjs||(e.curOp.changeObjs=[])).push(h)}e.display.selForContextMenu=null}function Ei(e,t,r,n,i){if(n||(n=r),P(n,r)<0){var o;r=(o=[n,r])[0],n=o[1]}"string"==typeof t&&(t=e.splitLines(t)),Oi(e,{from:r,to:n,text:t,origin:i})}function Pi(e,t,r,n){r<e.line?e.line+=n:t<e.line&&(e.line=t,e.ch=0)}function Ii(e,t,r,n){for(var i=0;i<e.length;++i){var o=e[i],l=!0;if(o.ranges){o.copied||((o=e[i]=o.deepCopy()).copied=!0);for(var s=0;s<o.ranges.length;s++)Pi(o.ranges[s].anchor,t,r,n),Pi(o.ranges[s].head,t,r,n)}else{for(var a=0;a<o.changes.length;++a){var u=o.changes[a];if(r<u.from.line)u.from=E(u.from.line+n,u.from.ch),u.to=E(u.to.line+n,u.to.ch);else if(t<=u.to.line){l=!1;break}}l||(e.splice(0,i+1),i=0)}}}function zi(e,t){var r=t.from.line,n=t.to.line,i=t.text.length-(n-r)-1;Ii(e.done,r,n,i),Ii(e.undone,r,n,i)}function Ri(e,t,r,n){var i=t,o=t;return"number"==typeof t?o=M(e,G(e,t)):i=W(t),null==i?null:(n(o,i)&&e.cm&&mn(e.cm,i,r),o)}function Bi(e){var t=this;this.lines=e,this.parent=null;for(var r=0,n=0;n<e.length;++n)e[n].parent=t,r+=e[n].height;this.height=r}function Gi(e){var t=this;this.children=e;for(var r=0,n=0,i=0;i<e.length;++i){var o=e[i];r+=o.chunkSize(),n+=o.height,o.parent=t}this.size=r,this.height=n,this.parent=null}function Ui(e,t,r){ye(t)<(e.curOp&&e.curOp.scrollTop||e.doc.scrollTop)&&Kr(e,r)}function Vi(e,t,r,n){var i=new Ms(e,r,n),o=e.cm;return o&&i.noHScroll&&(o.display.alignWidgets=!0),Ri(e,t,"widget",function(t){var r=t.widgets||(t.widgets=[]);if(null==i.insertAt?r.push(i):r.splice(Math.min(r.length-1,Math.max(0,i.insertAt)),0,i),i.line=t,o&&!ve(e,t)){var n=ye(t)<e.scrollTop;A(t,t.height+Ht(i)),n&&Kr(o,i.height),o.curOp.forceUpdate=!0}return!0}),bt(o,"lineWidgetAdded",o,i,"number"==typeof t?t:W(t)),i}function Ki(e,t,r,n,o){if(n&&n.shared)return ji(e,t,r,n,o);if(e.cm&&!e.cm.curOp)return dn(e.cm,Ki)(e,t,r,n,o);var l=new Os(e,o),s=P(t,r);if(n&&c(n,l,!1),s>0||0==s&&!1!==l.clearWhenEmpty)return l;if(l.replacedWith&&(l.collapsed=!0,l.widgetNode=i("span",[l.replacedWith],"CodeMirror-widget"),n.handleMouseEvents||l.widgetNode.setAttribute("cm-ignore-events","true"),n.insertLeft&&(l.widgetNode.insertLeft=!0)),l.collapsed){if(ce(e,t.line,t,r,l)||t.line!=r.line&&ce(e,r.line,t,r,l))throw new Error("Inserting collapsed marker partially overlapping an existing one");X()}l.addToHistory&&ni(e,{from:t,to:r,origin:"markText"},e.sel,NaN);var a,u=t.line,f=e.cm;if(e.iter(u,r.line+1,function(e){f&&l.collapsed&&!f.options.lineWrapping&&fe(e)==f.display.maxLine&&(a=!0),l.collapsed&&u!=t.line&&A(e,0),q(e,new Y(l,u==t.line?t.ch:null,u==r.line?r.ch:null)),++u}),l.collapsed&&e.iter(t.line,r.line+1,function(t){ve(e,t)&&A(t,0)}),l.clearOnEnter&&Ql(l,"beforeCursorEnter",function(){return l.clear()}),l.readOnly&&(j(),(e.history.done.length||e.history.undone.length)&&e.clearHistory()),l.collapsed&&(l.id=++Ns,l.atomic=!0),f){if(a&&(f.curOp.updateMaxLine=!0),l.collapsed)vn(f,t.line,r.line+1);else if(l.className||l.title||l.startStyle||l.endStyle||l.css)for(var h=t.line;h<=r.line;h++)mn(f,h,"text");l.atomic&&Ci(f.doc),bt(f,"markerAdded",f,l)}return l}function ji(e,t,r,n,i){(n=c(n)).shared=!1;var o=[Ki(e,t,r,n,i)],l=o[0],s=n.widgetNode;return $n(e,function(e){s&&(n.widgetNode=s.cloneNode(!0)),o.push(Ki(e,U(e,t),U(e,r),n,i));for(var a=0;a<e.linked.length;++a)if(e.linked[a].isParent)return;l=g(o)}),new As(o,l)}function Xi(e){return e.findMarks(E(e.first,0),e.clipPos(E(e.lastLine())),function(e){return e.parent})}function Yi(e,t){for(var r=0;r<t.length;r++){var n=t[r],i=n.find(),o=e.clipPos(i.from),l=e.clipPos(i.to);if(P(o,l)){var s=Ki(e,o,l,n.primary,n.primary.type);n.markers.push(s),s.parent=n}}}function _i(e){for(var t=0;t<e.length;t++)!function(t){var r=e[t],n=[r.primary.doc];$n(r.primary.doc,function(e){return n.push(e)});for(var i=0;i<r.markers.length;i++){var o=r.markers[i];-1==h(n,o.doc)&&(o.parent=null,r.markers.splice(i--,1))}}(t)}function $i(e){var t=this;if(Qi(t),!Me(t,e)&&!Ft(t.display,e)){We(e),gl&&(Hs=+new Date);var r=Sr(t,e,!0),n=e.dataTransfer.files;if(r&&!t.isReadOnly())if(n&&n.length&&window.FileReader&&window.File)for(var i=n.length,o=Array(i),l=0,s=0;s<i;++s)!function(e,n){if(!t.options.allowDropFileTypes||-1!=h(t.options.allowDropFileTypes,e.type)){var s=new FileReader;s.onload=dn(t,function(){var e=s.result;if(/[\x00-\x08\x0e-\x1f]{2}/.test(e)&&(e=""),o[n]=e,++l==i){var a={from:r=U(t.doc,r),to:r,text:t.doc.splitLines(o.join(t.doc.lineSeparator())),origin:"paste"};Oi(t.doc,a),yi(t.doc,Rn(r,Bn(a)))}}),s.readAsText(e)}}(n[s],s);else{if(t.state.draggingText&&t.doc.sel.contains(r)>-1)return t.state.draggingText(e),void setTimeout(function(){return t.display.input.focus()},20);try{var a=e.dataTransfer.getData("Text");if(a){var u;if(t.state.draggingText&&!t.state.draggingText.copy&&(u=t.listSelections()),wi(t.doc,Rn(r,r)),u)for(var c=0;c<u.length;++c)Ei(t.doc,"",u[c].anchor,u[c].head,"drag");t.replaceSelection(a,"around","paste"),t.display.input.focus()}}catch(e){}}}}function qi(e,t){if(gl&&(!e.state.draggingText||+new Date-Hs<100))Fe(t);else if(!Me(e,t)&&!Ft(e.display,t)&&(t.dataTransfer.setData("Text",e.getSelection()),t.dataTransfer.effectAllowed="copyMove",t.dataTransfer.setDragImage&&!xl)){var r=n("img",null,null,"position: fixed; left: 0; top: 0;");r.src="data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==",wl&&(r.width=r.height=1,e.display.wrapper.appendChild(r),r._top=r.offsetTop),t.dataTransfer.setDragImage(r,0,0),wl&&r.parentNode.removeChild(r)}}function Zi(e,t){var i=Sr(e,t);if(i){var o=document.createDocumentFragment();Mr(e,i,o),e.display.dragCursor||(e.display.dragCursor=n("div",null,"CodeMirror-cursors CodeMirror-dragcursors"),e.display.lineSpace.insertBefore(e.display.dragCursor,e.display.cursorDiv)),r(e.display.dragCursor,o)}}function Qi(e){e.display.dragCursor&&(e.display.lineSpace.removeChild(e.display.dragCursor),e.display.dragCursor=null)}function Ji(e){if(document.getElementsByClassName)for(var t=document.getElementsByClassName("CodeMirror"),r=0;r<t.length;r++){var n=t[r].CodeMirror;n&&e(n)}}function eo(){Fs||(to(),Fs=!0)}function to(){var e;Ql(window,"resize",function(){null==e&&(e=setTimeout(function(){e=null,Ji(ro)},100))}),Ql(window,"blur",function(){return Ji(Fr)})}function ro(e){var t=e.display;t.lastWrapHeight==t.wrapper.clientHeight&&t.lastWrapWidth==t.wrapper.clientWidth||(t.cachedCharWidth=t.cachedTextHeight=t.cachedPaddingH=null,t.scrollbarsClipped=!1,e.setSize())}function no(e){var t=e.split(/-(?!$)/);e=t[t.length-1];for(var r,n,i,o,l=0;l<t.length-1;l++){var s=t[l];if(/^(cmd|meta|m)$/i.test(s))o=!0;else if(/^a(lt)?$/i.test(s))r=!0;else if(/^(c|ctrl|control)$/i.test(s))n=!0;else{if(!/^s(hift)?$/i.test(s))throw new Error("Unrecognized modifier name: "+s);i=!0}}return r&&(e="Alt-"+e),n&&(e="Ctrl-"+e),o&&(e="Cmd-"+e),i&&(e="Shift-"+e),e}function io(e){var t={};for(var r in e)if(e.hasOwnProperty(r)){var n=e[r];if(/^(name|fallthrough|(de|at)tach)$/.test(r))continue;if("..."==n){delete e[r];continue}for(var i=v(r.split(" "),no),o=0;o<i.length;o++){var l=void 0,s=void 0;o==i.length-1?(s=i.join(" "),l=n):(s=i.slice(0,o+1).join(" "),l="...");var a=t[s];if(a){if(a!=l)throw new Error("Inconsistent bindings for "+s)}else t[s]=l}delete e[r]}for(var u in t)e[u]=t[u];return e}function oo(e,t,r,n){var i=(t=uo(t)).call?t.call(e,n):t[e];if(!1===i)return"nothing";if("..."===i)return"multi";if(null!=i&&r(i))return"handled";if(t.fallthrough){if("[object Array]"!=Object.prototype.toString.call(t.fallthrough))return oo(e,t.fallthrough,r,n);for(var o=0;o<t.fallthrough.length;o++){var l=oo(e,t.fallthrough[o],r,n);if(l)return l}}}function lo(e){var t="string"==typeof e?e:Es[e.keyCode];return"Ctrl"==t||"Alt"==t||"Shift"==t||"Mod"==t}function so(e,t,r){var n=e;return t.altKey&&"Alt"!=n&&(e="Alt-"+e),(Dl?t.metaKey:t.ctrlKey)&&"Ctrl"!=n&&(e="Ctrl-"+e),(Dl?t.ctrlKey:t.metaKey)&&"Cmd"!=n&&(e="Cmd-"+e),!r&&t.shiftKey&&"Shift"!=n&&(e="Shift-"+e),e}function ao(e,t){if(wl&&34==e.keyCode&&e.char)return!1;var r=Es[e.keyCode];return null!=r&&!e.altGraphKey&&so(r,e,t)}function uo(e){return"string"==typeof e?Rs[e]:e}function co(e,t){for(var r=e.doc.sel.ranges,n=[],i=0;i<r.length;i++){for(var o=t(r[i]);n.length&&P(o.from,g(n).to)<=0;){var l=n.pop();if(P(l.from,o.from)<0){o.from=l.from;break}}n.push(o)}hn(e,function(){for(var t=n.length-1;t>=0;t--)Ei(e.doc,"",n[t].from,n[t].to,"+delete");jr(e)})}function fo(e,t,r){var n=L(e.text,t+r,r);return n<0||n>e.text.length?null:n}function ho(e,t,r){var n=fo(e,t.ch,r);return null==n?null:new E(t.line,n,r<0?"after":"before")}function po(e,t,r,n,i){if(e){var o=Se(r,t.doc.direction);if(o){var l,s=i<0?g(o):o[0],a=i<0==(1==s.level)?"after":"before";if(s.level>0){var u=Xt(t,r);l=i<0?r.text.length-1:0;var c=Yt(t,u,l).top;l=k(function(e){return Yt(t,u,e).top==c},i<0==(1==s.level)?s.from:s.to-1,l),"before"==a&&(l=fo(r,l,1))}else l=i<0?s.to:s.from;return new E(n,l,a)}}return new E(n,i<0?r.text.length:0,i<0?"before":"after")}function go(e,t,r,n){var i=Se(t,e.doc.direction);if(!i)return ho(t,r,n);r.ch>=t.text.length?(r.ch=t.text.length,r.sticky="before"):r.ch<=0&&(r.ch=0,r.sticky="after");var o=Ce(i,r.ch,r.sticky),l=i[o];if("ltr"==e.doc.direction&&l.level%2==0&&(n>0?l.to>r.ch:l.from<r.ch))return ho(t,r,n);var s,a=function(e,r){return fo(t,e instanceof E?e.ch:e,r)},u=function(r){return e.options.lineWrapping?(s=s||Xt(e,t),hr(e,t,s,r)):{begin:0,end:t.text.length}},c=u("before"==r.sticky?a(r,-1):r.ch);if("rtl"==e.doc.direction||1==l.level){var f=1==l.level==n<0,h=a(r,f?1:-1);if(null!=h&&(f?h<=l.to&&h<=c.end:h>=l.from&&h>=c.begin)){var d=f?"before":"after";return new E(r.line,h,d)}}var p=function(e,t,n){for(var o=function(e,t){return t?new E(r.line,a(e,1),"before"):new E(r.line,e,"after")};e>=0&&e<i.length;e+=t){var l=i[e],s=t>0==(1!=l.level),u=s?n.begin:a(n.end,-1);if(l.from<=u&&u<l.to)return o(u,s);if(u=s?l.from:a(l.to,-1),n.begin<=u&&u<n.end)return o(u,s)}},g=p(o+n,n,c);if(g)return g;var v=n>0?c.end:a(c.begin,-1);return null==v||n>0&&v==t.text.length||!(g=p(n>0?0:i.length-1,n,u(v)))?null:g}function vo(e,t){var r=M(e.doc,t),n=fe(r);return n!=r&&(t=W(n)),po(!0,e,n,t,1)}function mo(e,t){var r=M(e.doc,t),n=he(r);return n!=r&&(t=W(n)),po(!0,e,r,t,-1)}function yo(e,t){var r=vo(e,t.line),n=M(e.doc,r.line),i=Se(n,e.doc.direction);if(!i||0==i[0].level){var o=Math.max(0,n.text.search(/\S/)),l=t.line==r.line&&t.ch<=o&&t.ch;return E(r.line,l?0:o,r.sticky)}return r}function bo(e,t,r){if("string"==typeof t&&!(t=Bs[t]))return!1;e.display.input.ensurePolled();var n=e.display.shift,i=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),r&&(e.display.shift=!1),i=t(e)!=Bl}finally{e.display.shift=n,e.state.suppressEdits=!1}return i}function wo(e,t,r){for(var n=0;n<e.state.keyMaps.length;n++){var i=oo(t,e.state.keyMaps[n],r,e);if(i)return i}return e.options.extraKeys&&oo(t,e.options.extraKeys,r,e)||oo(t,e.options.keyMap,r,e)}function xo(e,t,r,n){var i=e.state.keySeq;if(i){if(lo(t))return"handled";Gs.set(50,function(){e.state.keySeq==i&&(e.state.keySeq=null,e.display.input.reset())}),t=i+" "+t}var o=wo(e,t,n);return"multi"==o&&(e.state.keySeq=t),"handled"==o&&bt(e,"keyHandled",e,t,r),"handled"!=o&&"multi"!=o||(We(r),Ar(e)),i&&!o&&/\'$/.test(t)?(We(r),!0):!!o}function Co(e,t){var r=ao(t,!0);return!!r&&(t.shiftKey&&!e.state.keySeq?xo(e,"Shift-"+r,t,function(t){return bo(e,t,!0)})||xo(e,r,t,function(t){if("string"==typeof t?/^go[A-Z]/.test(t):t.motion)return bo(e,t)}):xo(e,r,t,function(t){return bo(e,t)}))}function So(e,t,r){return xo(e,"'"+r+"'",t,function(t){return bo(e,t,!0)})}function Lo(e){var t=this;if(t.curOp.focus=l(),!Me(t,e)){gl&&vl<11&&27==e.keyCode&&(e.returnValue=!1);var r=e.keyCode;t.display.shift=16==r||e.shiftKey;var n=Co(t,e);wl&&(Us=n?r:null,!n&&88==r&&!rs&&(Ml?e.metaKey:e.ctrlKey)&&t.replaceSelection("",null,"cut")),18!=r||/\bCodeMirror-crosshair\b/.test(t.display.lineDiv.className)||ko(t)}}function ko(e){function t(e){18!=e.keyCode&&e.altKey||(Fl(r,"CodeMirror-crosshair"),ke(document,"keyup",t),ke(document,"mouseover",t))}var r=e.display.lineDiv;s(r,"CodeMirror-crosshair"),Ql(document,"keyup",t),Ql(document,"mouseover",t)}function To(e){16==e.keyCode&&(this.doc.sel.shift=!1),Me(this,e)}function Mo(e){var t=this;if(!(Ft(t.display,e)||Me(t,e)||e.ctrlKey&&!e.altKey||Ml&&e.metaKey)){var r=e.keyCode,n=e.charCode;if(wl&&r==Us)return Us=null,void We(e);if(!wl||e.which&&!(e.which<10)||!Co(t,e)){var i=String.fromCharCode(null==n?r:n);"\b"!=i&&(So(t,e,i)||t.display.input.onKeyPress(e))}}}function No(e,t){var r=+new Date;return js&&js.compare(r,e,t)?(Ks=js=null,"triple"):Ks&&Ks.compare(r,e,t)?(js=new Vs(r,e,t),Ks=null,"double"):(Ks=new Vs(r,e,t),js=null,"single")}function Oo(e){var t=this,r=t.display;if(!(Me(t,e)||r.activeTouch&&r.input.supportsTouch()))if(r.input.ensurePolled(),r.shift=e.shiftKey,Ft(r,e))ml||(r.scroller.draggable=!1,setTimeout(function(){return r.scroller.draggable=!0},100));else if(!zo(t,e)){var n=Sr(t,e),i=Pe(e),o=n?No(n,i):"single";window.focus(),1==i&&t.state.selectingText&&t.state.selectingText(e),n&&Ao(t,i,n,o,e)||(1==i?n?Do(t,n,o,e):Ee(e)==r.scroller&&We(e):2==i?(n&&di(t.doc,n),setTimeout(function(){return r.input.focus()},20)):3==i&&(Hl?Ro(t,e):Dr(t)))}}function Ao(e,t,r,n,i){var o="Click";return"double"==n?o="Double"+o:"triple"==n&&(o="Triple"+o),o=(1==t?"Left":2==t?"Middle":"Right")+o,xo(e,so(o,i),i,function(t){if("string"==typeof t&&(t=Bs[t]),!t)return!1;var n=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),n=t(e,r)!=Bl}finally{e.state.suppressEdits=!1}return n})}function Wo(e,t,r){var n=e.getOption("configureMouse"),i=n?n(e,t,r):{};if(null==i.unit){var o=Nl?r.shiftKey&&r.metaKey:r.altKey;i.unit=o?"rectangle":"single"==t?"char":"double"==t?"word":"line"}return(null==i.extend||e.doc.extend)&&(i.extend=e.doc.extend||r.shiftKey),null==i.addNew&&(i.addNew=Ml?r.metaKey:r.ctrlKey),null==i.moveOnDrag&&(i.moveOnDrag=!(Ml?r.altKey:r.ctrlKey)),i}function Do(e,t,r,n){gl?setTimeout(u(Wr,e),0):e.curOp.focus=l();var i,o=Wo(e,r,n),s=e.doc.sel;e.options.dragDrop&&Jl&&!e.isReadOnly()&&"single"==r&&(i=s.contains(t))>-1&&(P((i=s.ranges[i]).from(),t)<0||t.xRel>0)&&(P(i.to(),t)>0||t.xRel<0)?Ho(e,n,t,o):Eo(e,n,t,o)}function Ho(e,t,r,n){var i=e.display,o=!1,l=dn(e,function(t){ml&&(i.scroller.draggable=!1),e.state.draggingText=!1,ke(document,"mouseup",l),ke(document,"mousemove",s),ke(i.scroller,"dragstart",a),ke(i.scroller,"drop",l),o||(We(t),n.addNew||di(e.doc,r,null,null,n.extend),ml||gl&&9==vl?setTimeout(function(){document.body.focus(),i.input.focus()},20):i.input.focus())}),s=function(e){o=o||Math.abs(t.clientX-e.clientX)+Math.abs(t.clientY-e.clientY)>=10},a=function(){return o=!0};ml&&(i.scroller.draggable=!0),e.state.draggingText=l,l.copy=!n.moveOnDrag,i.scroller.dragDrop&&i.scroller.dragDrop(),Ql(document,"mouseup",l),Ql(document,"mousemove",s),Ql(i.scroller,"dragstart",a),Ql(i.scroller,"drop",l),Dr(e),setTimeout(function(){return i.input.focus()},20)}function Fo(e,t,r){if("char"==r)return new Ts(t,t);if("word"==r)return e.findWordAt(t);if("line"==r)return new Ts(E(t.line,0),U(e.doc,E(t.line+1,0)));var n=r(e,t);return new Ts(n.from,n.to)}function Eo(e,t,r,n){function i(t){if(0!=P(m,t))if(m=t,"rectangle"==n.unit){for(var i=[],o=e.options.tabSize,l=f(M(u,r.line).text,r.ch,o),s=f(M(u,t.line).text,t.ch,o),a=Math.min(l,s),g=Math.max(l,s),v=Math.min(r.line,t.line),y=Math.min(e.lastLine(),Math.max(r.line,t.line));v<=y;v++){var b=M(u,v).text,w=d(b,a,o);a==g?i.push(new Ts(E(v,w),E(v,w))):b.length>w&&i.push(new Ts(E(v,w),E(v,d(b,g,o))))}i.length||i.push(new Ts(r,r)),bi(u,zn(p.ranges.slice(0,h).concat(i),h),{origin:"*mouse",scroll:!1}),e.scrollIntoView(t)}else{var x,C=c,S=Fo(e,t,n.unit),L=C.anchor;P(S.anchor,L)>0?(x=S.head,L=B(C.from(),S.anchor)):(x=S.anchor,L=R(C.to(),S.head));var k=p.ranges.slice(0);k[h]=Po(e,new Ts(U(u,L),x)),bi(u,zn(k,h),Ul)}}function o(t){var r=++b,s=Sr(e,t,!0,"rectangle"==n.unit);if(s)if(0!=P(s,m)){e.curOp.focus=l(),i(s);var c=Ir(a,u);(s.line>=c.to||s.line<c.from)&&setTimeout(dn(e,function(){b==r&&o(t)}),150)}else{var f=t.clientY<y.top?-20:t.clientY>y.bottom?20:0;f&&setTimeout(dn(e,function(){b==r&&(a.scroller.scrollTop+=f,o(t))}),50)}}function s(t){e.state.selectingText=!1,b=1/0,We(t),a.input.focus(),ke(document,"mousemove",w),ke(document,"mouseup",x),u.history.lastSelOrigin=null}var a=e.display,u=e.doc;We(t);var c,h,p=u.sel,g=p.ranges;if(n.addNew&&!n.extend?(h=u.sel.contains(r),c=h>-1?g[h]:new Ts(r,r)):(c=u.sel.primary(),h=u.sel.primIndex),"rectangle"==n.unit)n.addNew||(c=new Ts(r,r)),r=Sr(e,t,!0,!0),h=-1;else{var v=Fo(e,r,n.unit);c=n.extend?hi(c,v.anchor,v.head,n.extend):v}n.addNew?-1==h?(h=g.length,bi(u,zn(g.concat([c]),h),{scroll:!1,origin:"*mouse"})):g.length>1&&g[h].empty()&&"char"==n.unit&&!n.extend?(bi(u,zn(g.slice(0,h).concat(g.slice(h+1)),0),{scroll:!1,origin:"*mouse"}),p=u.sel):gi(u,h,c,Ul):(h=0,bi(u,new ks([c],0),Ul),p=u.sel);var m=r,y=a.wrapper.getBoundingClientRect(),b=0,w=dn(e,function(e){Pe(e)?o(e):s(e)}),x=dn(e,s);e.state.selectingText=x,Ql(document,"mousemove",w),Ql(document,"mouseup",x)}function Po(e,t){var r=t.anchor,n=t.head,i=M(e.doc,r.line);if(0==P(r,n)&&r.sticky==n.sticky)return t;var o=Se(i);if(!o)return t;var l=Ce(o,r.ch,r.sticky),s=o[l];if(s.from!=r.ch&&s.to!=r.ch)return t;var a=l+(s.from==r.ch==(1!=s.level)?0:1);if(0==a||a==o.length)return t;var u;if(n.line!=r.line)u=(n.line-r.line)*("ltr"==e.doc.direction?1:-1)>0;else{var c=Ce(o,n.ch,n.sticky),f=c-l||(n.ch-r.ch)*(1==s.level?-1:1);u=c==a-1||c==a?f<0:f>0}var h=o[a+(u?-1:0)],d=u==(1==h.level),p=d?h.from:h.to,g=d?"after":"before";return r.ch==p&&r.sticky==g?t:new Ts(new E(r.line,p,g),n)}function Io(e,t,r,n){var i,o;if(t.touches)i=t.touches[0].clientX,o=t.touches[0].clientY;else try{i=t.clientX,o=t.clientY}catch(t){return!1}if(i>=Math.floor(e.display.gutters.getBoundingClientRect().right))return!1;n&&We(t);var l=e.display,s=l.lineDiv.getBoundingClientRect();if(o>s.bottom||!Oe(e,r))return He(t);o-=s.top-l.viewOffset;for(var a=0;a<e.options.gutters.length;++a){var u=l.gutters.childNodes[a];if(u&&u.getBoundingClientRect().right>=i)return Te(e,r,e,D(e.doc,o),e.options.gutters[a],t),He(t)}}function zo(e,t){return Io(e,t,"gutterClick",!0)}function Ro(e,t){Ft(e.display,t)||Bo(e,t)||Me(e,t,"contextmenu")||e.display.input.onContextMenu(t)}function Bo(e,t){return!!Oe(e,"gutterContextMenu")&&Io(e,t,"gutterContextMenu",!1)}function Go(e){e.display.wrapper.className=e.display.wrapper.className.replace(/\s*cm-s-\S+/g,"")+e.options.theme.replace(/(^|\s)\s*/g," cm-s-"),er(e)}function Uo(e){Hn(e),vn(e),zr(e)}function Vo(e,t,r){if(!t!=!(r&&r!=Xs)){var n=e.display.dragFunctions,i=t?Ql:ke;i(e.display.scroller,"dragstart",n.start),i(e.display.scroller,"dragenter",n.enter),i(e.display.scroller,"dragover",n.over),i(e.display.scroller,"dragleave",n.leave),i(e.display.scroller,"drop",n.drop)}}function Ko(e){e.options.lineWrapping?(s(e.display.wrapper,"CodeMirror-wrap"),e.display.sizer.style.minWidth="",e.display.sizerWidth=null):(Fl(e.display.wrapper,"CodeMirror-wrap"),we(e)),Cr(e),vn(e),er(e),setTimeout(function(){return en(e)},100)}function jo(e,t){var r=this;if(!(this instanceof jo))return new jo(e,t);this.options=t=t?c(t):{},c(Ys,t,!1),Fn(t);var n=t.value;"string"==typeof n&&(n=new Ds(n,t.mode,null,t.lineSeparator,t.direction)),this.doc=n;var i=new jo.inputStyles[t.inputStyle](this),o=this.display=new T(e,n,i);o.wrapper.CodeMirror=this,Hn(this),Go(this),t.lineWrapping&&(this.display.wrapper.className+=" CodeMirror-wrap"),rn(this),this.state={keyMaps:[],overlays:[],modeGen:0,overwrite:!1,delayingBlurEvent:!1,focused:!1,suppressEdits:!1,pasteIncoming:!1,cutIncoming:!1,selectingText:!1,draggingText:!1,highlight:new Pl,keySeq:null,specialChars:null},t.autofocus&&!Tl&&o.input.focus(),gl&&vl<11&&setTimeout(function(){return r.display.input.reset(!0)},20),Xo(this),eo(),nn(this),this.curOp.forceUpdate=!0,qn(this,n),t.autofocus&&!Tl||this.hasFocus()?setTimeout(u(Hr,this),20):Fr(this);for(var l in _s)_s.hasOwnProperty(l)&&_s[l](r,t[l],Xs);Rr(this),t.finishInit&&t.finishInit(this);for(var s=0;s<$s.length;++s)$s[s](r);on(this),ml&&t.lineWrapping&&"optimizelegibility"==getComputedStyle(o.lineDiv).textRendering&&(o.lineDiv.style.textRendering="auto")}function Xo(e){function t(){i.activeTouch&&(o=setTimeout(function(){return i.activeTouch=null},1e3),(l=i.activeTouch).end=+new Date)}function r(e){if(1!=e.touches.length)return!1;var t=e.touches[0];return t.radiusX<=1&&t.radiusY<=1}function n(e,t){if(null==t.left)return!0;var r=t.left-e.left,n=t.top-e.top;return r*r+n*n>400}var i=e.display;Ql(i.scroller,"mousedown",dn(e,Oo)),gl&&vl<11?Ql(i.scroller,"dblclick",dn(e,function(t){if(!Me(e,t)){var r=Sr(e,t);if(r&&!zo(e,t)&&!Ft(e.display,t)){We(t);var n=e.findWordAt(r);di(e.doc,n.anchor,n.head)}}})):Ql(i.scroller,"dblclick",function(t){return Me(e,t)||We(t)}),Hl||Ql(i.scroller,"contextmenu",function(t){return Ro(e,t)});var o,l={end:0};Ql(i.scroller,"touchstart",function(t){if(!Me(e,t)&&!r(t)&&!zo(e,t)){i.input.ensurePolled(),clearTimeout(o);var n=+new Date;i.activeTouch={start:n,moved:!1,prev:n-l.end<=300?l:null},1==t.touches.length&&(i.activeTouch.left=t.touches[0].pageX,i.activeTouch.top=t.touches[0].pageY)}}),Ql(i.scroller,"touchmove",function(){i.activeTouch&&(i.activeTouch.moved=!0)}),Ql(i.scroller,"touchend",function(r){var o=i.activeTouch;if(o&&!Ft(i,r)&&null!=o.left&&!o.moved&&new Date-o.start<300){var l,s=e.coordsChar(i.activeTouch,"page");l=!o.prev||n(o,o.prev)?new Ts(s,s):!o.prev.prev||n(o,o.prev.prev)?e.findWordAt(s):new Ts(E(s.line,0),U(e.doc,E(s.line+1,0))),e.setSelection(l.anchor,l.head),e.focus(),We(r)}t()}),Ql(i.scroller,"touchcancel",t),Ql(i.scroller,"scroll",function(){i.scroller.clientHeight&&(qr(e,i.scroller.scrollTop),Qr(e,i.scroller.scrollLeft,!0),Te(e,"scroll",e))}),Ql(i.scroller,"mousewheel",function(t){return In(e,t)}),Ql(i.scroller,"DOMMouseScroll",function(t){return In(e,t)}),Ql(i.wrapper,"scroll",function(){return i.wrapper.scrollTop=i.wrapper.scrollLeft=0}),i.dragFunctions={enter:function(t){Me(e,t)||Fe(t)},over:function(t){Me(e,t)||(Zi(e,t),Fe(t))},start:function(t){return qi(e,t)},drop:dn(e,$i),leave:function(t){Me(e,t)||Qi(e)}};var s=i.input.getField();Ql(s,"keyup",function(t){return To.call(e,t)}),Ql(s,"keydown",dn(e,Lo)),Ql(s,"keypress",dn(e,Mo)),Ql(s,"focus",function(t){return Hr(e,t)}),Ql(s,"blur",function(t){return Fr(e,t)})}function Yo(e,t,r,n){var i,o=e.doc;null==r&&(r="add"),"smart"==r&&(o.mode.indent?i=$e(e,t).state:r="prev");var l=e.options.tabSize,s=M(o,t),a=f(s.text,null,l);s.stateAfter&&(s.stateAfter=null);var u,c=s.text.match(/^\s*/)[0];if(n||/\S/.test(s.text)){if("smart"==r&&((u=o.mode.indent(i,s.text.slice(c.length),s.text))==Bl||u>150)){if(!n)return;r="prev"}}else u=0,r="not";"prev"==r?u=t>o.first?f(M(o,t-1).text,null,l):0:"add"==r?u=a+e.options.indentUnit:"subtract"==r?u=a-e.options.indentUnit:"number"==typeof r&&(u=a+r),u=Math.max(0,u);var h="",d=0;if(e.options.indentWithTabs)for(var g=Math.floor(u/l);g;--g)d+=l,h+="\t";if(d<u&&(h+=p(u-d)),h!=c)return Ei(o,h,E(t,0),E(t,c.length),"+input"),s.stateAfter=null,!0;for(var v=0;v<o.sel.ranges.length;v++){var m=o.sel.ranges[v];if(m.head.line==t&&m.head.ch<c.length){var y=E(t,c.length);gi(o,v,new Ts(y,y));break}}}function _o(e){qs=e}function $o(e,t,r,n,i){var o=e.doc;e.display.shift=!1,n||(n=o.sel);var l=e.state.pasteIncoming||"paste"==i,s=es(t),a=null;if(l&&n.ranges.length>1)if(qs&&qs.text.join("\n")==t){if(n.ranges.length%qs.text.length==0){a=[];for(var u=0;u<qs.text.length;u++)a.push(o.splitLines(qs.text[u]))}}else s.length==n.ranges.length&&e.options.pasteLinesPerSelection&&(a=v(s,function(e){return[e]}));for(var c,f=n.ranges.length-1;f>=0;f--){var h=n.ranges[f],d=h.from(),p=h.to();h.empty()&&(r&&r>0?d=E(d.line,d.ch-r):e.state.overwrite&&!l?p=E(p.line,Math.min(M(o,p.line).text.length,p.ch+g(s).length)):qs&&qs.lineWise&&qs.text.join("\n")==t&&(d=p=E(d.line,0))),c=e.curOp.updateInput;var m={from:d,to:p,text:a?a[f%a.length]:s,origin:i||(l?"paste":e.state.cutIncoming?"cut":"+input")};Oi(e.doc,m),bt(e,"inputRead",e,m)}t&&!l&&Zo(e,t),jr(e),e.curOp.updateInput=c,e.curOp.typing=!0,e.state.pasteIncoming=e.state.cutIncoming=!1}function qo(e,t){var r=e.clipboardData&&e.clipboardData.getData("Text");if(r)return e.preventDefault(),t.isReadOnly()||t.options.disableInput||hn(t,function(){return $o(t,r,0,null,"paste")}),!0}function Zo(e,t){if(e.options.electricChars&&e.options.smartIndent)for(var r=e.doc.sel,n=r.ranges.length-1;n>=0;n--){var i=r.ranges[n];if(!(i.head.ch>100||n&&r.ranges[n-1].head.line==i.head.line)){var o=e.getModeAt(i.head),l=!1;if(o.electricChars){for(var s=0;s<o.electricChars.length;s++)if(t.indexOf(o.electricChars.charAt(s))>-1){l=Yo(e,i.head.line,"smart");break}}else o.electricInput&&o.electricInput.test(M(e.doc,i.head.line).text.slice(0,i.head.ch))&&(l=Yo(e,i.head.line,"smart"));l&&bt(e,"electricInput",e,i.head.line)}}}function Qo(e){for(var t=[],r=[],n=0;n<e.doc.sel.ranges.length;n++){var i=e.doc.sel.ranges[n].head.line,o={anchor:E(i,0),head:E(i+1,0)};r.push(o),t.push(e.getRange(o.anchor,o.head))}return{text:t,ranges:r}}function Jo(e,t){e.setAttribute("autocorrect","off"),e.setAttribute("autocapitalize","off"),e.setAttribute("spellcheck",!!t)}function el(){var e=n("textarea",null,null,"position: absolute; bottom: -1em; padding: 0; width: 1px; height: 1em; outline: none"),t=n("div",[e],null,"overflow: hidden; position: relative; width: 3px; height: 0px;");return ml?e.style.width="1000px":e.setAttribute("wrap","off"),Ll&&(e.style.border="1px solid black"),Jo(e),t}function tl(e,t,r,n,i){function o(){var n=t.line+r;return!(n<e.first||n>=e.first+e.size)&&(t=new E(n,t.ch,t.sticky),u=M(e,n))}function l(n){var l;if(null==(l=i?go(e.cm,u,t,r):ho(u,t,r))){if(n||!o())return!1;t=po(i,e.cm,u,t.line,r)}else t=l;return!0}var s=t,a=r,u=M(e,t.line);if("char"==n)l();else if("column"==n)l(!0);else if("word"==n||"group"==n)for(var c=null,f="group"==n,h=e.cm&&e.cm.getHelper(t,"wordChars"),d=!0;!(r<0)||l(!d);d=!1){var p=u.text.charAt(t.ch)||"\n",g=x(p,h)?"w":f&&"\n"==p?"n":!f||/\s/.test(p)?null:"p";if(!f||d||g||(g="s"),c&&c!=g){r<0&&(r=1,l(),t.sticky="after");break}if(g&&(c=g),r>0&&!l(!d))break}var v=ki(e,t,s,a,!0);return I(s,v)&&(v.hitSide=!0),v}function rl(e,t,r,n){var i,o=e.doc,l=t.left;if("page"==n){var s=Math.min(e.display.wrapper.clientHeight,window.innerHeight||document.documentElement.clientHeight),a=Math.max(s-.5*mr(e.display),3);i=(r>0?t.bottom:t.top)+r*a}else"line"==n&&(i=r>0?t.bottom+3:t.top-3);for(var u;(u=cr(e,l,i)).outside;){if(r<0?i<=0:i>=o.height){u.hitSide=!0;break}i+=5*r}return u}function nl(e,t){var r=jt(e,t.line);if(!r||r.hidden)return null;var n=M(e.doc,t.line),i=Ut(r,n,t.line),o=Se(n,e.doc.direction),l="left";o&&(l=Ce(o,t.ch)%2?"right":"left");var s=_t(i.map,t.ch,l);return s.offset="right"==s.collapse?s.end:s.start,s}function il(e){for(var t=e;t;t=t.parentNode)if(/CodeMirror-gutter-wrapper/.test(t.className))return!0;return!1}function ol(e,t){return t&&(e.bad=!0),e}function ll(e,t,r,n,i){function o(e){return function(t){return t.id==e}}function l(){c&&(u+=f,c=!1)}function s(e){e&&(l(),u+=e)}function a(t){if(1==t.nodeType){var r=t.getAttribute("cm-text");if(null!=r)return void s(r||t.textContent.replace(/\u200b/g,""));var u,h=t.getAttribute("cm-marker");if(h){var d=e.findMarks(E(n,0),E(i+1,0),o(+h));return void(d.length&&(u=d[0].find(0))&&s(N(e.doc,u.from,u.to).join(f)))}if("false"==t.getAttribute("contenteditable"))return;var p=/^(pre|div|p)$/i.test(t.nodeName);p&&l();for(var g=0;g<t.childNodes.length;g++)a(t.childNodes[g]);p&&(c=!0)}else 3==t.nodeType&&s(t.nodeValue)}for(var u="",c=!1,f=e.doc.lineSeparator();a(t),t!=r;)t=t.nextSibling;return u}function sl(e,t,r){var n;if(t==e.display.lineDiv){if(!(n=e.display.lineDiv.childNodes[r]))return ol(e.clipPos(E(e.display.viewTo-1)),!0);t=null,r=0}else for(n=t;;n=n.parentNode){if(!n||n==e.display.lineDiv)return null;if(n.parentNode&&n.parentNode==e.display.lineDiv)break}for(var i=0;i<e.display.view.length;i++){var o=e.display.view[i];if(o.node==n)return al(o,t,r)}}function al(e,t,r){function n(t,r,n){for(var i=-1;i<(f?f.length:0);i++)for(var o=i<0?c.map:f[i],l=0;l<o.length;l+=3){var s=o[l+2];if(s==t||s==r){var a=W(i<0?e.line:e.rest[i]),u=o[l]+n;return(n<0||s!=t)&&(u=o[l+(n?1:0)]),E(a,u)}}}var i=e.text.firstChild,l=!1;if(!t||!o(i,t))return ol(E(W(e.line),0),!0);if(t==i&&(l=!0,t=i.childNodes[r],r=0,!t)){var s=e.rest?g(e.rest):e.line;return ol(E(W(s),s.text.length),l)}var a=3==t.nodeType?t:null,u=t;for(a||1!=t.childNodes.length||3!=t.firstChild.nodeType||(a=t.firstChild,r&&(r=a.nodeValue.length));u.parentNode!=i;)u=u.parentNode;var c=e.measure,f=c.maps,h=n(a,u,r);if(h)return ol(h,l);for(var d=u.nextSibling,p=a?a.nodeValue.length-r:0;d;d=d.nextSibling){if(h=n(d,d.firstChild,0))return ol(E(h.line,h.ch-p),l);p+=d.textContent.length}for(var v=u.previousSibling,m=r;v;v=v.previousSibling){if(h=n(v,v.firstChild,-1))return ol(E(h.line,h.ch+m),l);m+=v.textContent.length}}var ul=navigator.userAgent,cl=navigator.platform,fl=/gecko\/\d/i.test(ul),hl=/MSIE \d/.test(ul),dl=/Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(ul),pl=/Edge\/(\d+)/.exec(ul),gl=hl||dl||pl,vl=gl&&(hl?document.documentMode||6:+(pl||dl)[1]),ml=!pl&&/WebKit\//.test(ul),yl=ml&&/Qt\/\d+\.\d+/.test(ul),bl=!pl&&/Chrome\//.test(ul),wl=/Opera\//.test(ul),xl=/Apple Computer/.test(navigator.vendor),Cl=/Mac OS X 1\d\D([8-9]|\d\d)\D/.test(ul),Sl=/PhantomJS/.test(ul),Ll=!pl&&/AppleWebKit/.test(ul)&&/Mobile\/\w+/.test(ul),kl=/Android/.test(ul),Tl=Ll||kl||/webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(ul),Ml=Ll||/Mac/.test(cl),Nl=/\bCrOS\b/.test(ul),Ol=/win/i.test(cl),Al=wl&&ul.match(/Version\/(\d*\.\d*)/);Al&&(Al=Number(Al[1])),Al&&Al>=15&&(wl=!1,ml=!0);var Wl,Dl=Ml&&(yl||wl&&(null==Al||Al<12.11)),Hl=fl||gl&&vl>=9,Fl=function(t,r){var n=t.className,i=e(r).exec(n);if(i){var o=n.slice(i.index+i[0].length);t.className=n.slice(0,i.index)+(o?i[1]+o:"")}};Wl=document.createRange?function(e,t,r,n){var i=document.createRange();return i.setEnd(n||e,r),i.setStart(e,t),i}:function(e,t,r){var n=document.body.createTextRange();try{n.moveToElementText(e.parentNode)}catch(e){return n}return n.collapse(!0),n.moveEnd("character",r),n.moveStart("character",t),n};var El=function(e){e.select()};Ll?El=function(e){e.selectionStart=0,e.selectionEnd=e.value.length}:gl&&(El=function(e){try{e.select()}catch(e){}});var Pl=function(){this.id=null};Pl.prototype.set=function(e,t){clearTimeout(this.id),this.id=setTimeout(t,e)};var Il,zl,Rl=30,Bl={toString:function(){return"CodeMirror.Pass"}},Gl={scroll:!1},Ul={origin:"*mouse"},Vl={origin:"+move"},Kl=[""],jl=/[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/,Xl=/[\u0300-\u036f\u0483-\u0489\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u065e\u0670\u06d6-\u06dc\u06de-\u06e4\u06e7\u06e8\u06ea-\u06ed\u0711\u0730-\u074a\u07a6-\u07b0\u07eb-\u07f3\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0900-\u0902\u093c\u0941-\u0948\u094d\u0951-\u0955\u0962\u0963\u0981\u09bc\u09be\u09c1-\u09c4\u09cd\u09d7\u09e2\u09e3\u0a01\u0a02\u0a3c\u0a41\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a70\u0a71\u0a75\u0a81\u0a82\u0abc\u0ac1-\u0ac5\u0ac7\u0ac8\u0acd\u0ae2\u0ae3\u0b01\u0b3c\u0b3e\u0b3f\u0b41-\u0b44\u0b4d\u0b56\u0b57\u0b62\u0b63\u0b82\u0bbe\u0bc0\u0bcd\u0bd7\u0c3e-\u0c40\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0cbc\u0cbf\u0cc2\u0cc6\u0ccc\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0d3e\u0d41-\u0d44\u0d4d\u0d57\u0d62\u0d63\u0dca\u0dcf\u0dd2-\u0dd4\u0dd6\u0ddf\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0eb1\u0eb4-\u0eb9\u0ebb\u0ebc\u0ec8-\u0ecd\u0f18\u0f19\u0f35\u0f37\u0f39\u0f71-\u0f7e\u0f80-\u0f84\u0f86\u0f87\u0f90-\u0f97\u0f99-\u0fbc\u0fc6\u102d-\u1030\u1032-\u1037\u1039\u103a\u103d\u103e\u1058\u1059\u105e-\u1060\u1071-\u1074\u1082\u1085\u1086\u108d\u109d\u135f\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b7-\u17bd\u17c6\u17c9-\u17d3\u17dd\u180b-\u180d\u18a9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193b\u1a17\u1a18\u1a56\u1a58-\u1a5e\u1a60\u1a62\u1a65-\u1a6c\u1a73-\u1a7c\u1a7f\u1b00-\u1b03\u1b34\u1b36-\u1b3a\u1b3c\u1b42\u1b6b-\u1b73\u1b80\u1b81\u1ba2-\u1ba5\u1ba8\u1ba9\u1c2c-\u1c33\u1c36\u1c37\u1cd0-\u1cd2\u1cd4-\u1ce0\u1ce2-\u1ce8\u1ced\u1dc0-\u1de6\u1dfd-\u1dff\u200c\u200d\u20d0-\u20f0\u2cef-\u2cf1\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua66f-\ua672\ua67c\ua67d\ua6f0\ua6f1\ua802\ua806\ua80b\ua825\ua826\ua8c4\ua8e0-\ua8f1\ua926-\ua92d\ua947-\ua951\ua980-\ua982\ua9b3\ua9b6-\ua9b9\ua9bc\uaa29-\uaa2e\uaa31\uaa32\uaa35\uaa36\uaa43\uaa4c\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uabe5\uabe8\uabed\udc00-\udfff\ufb1e\ufe00-\ufe0f\ufe20-\ufe26\uff9e\uff9f]/,Yl=!1,_l=!1,$l=null,ql=function(){function e(e){return e<=247?r.charAt(e):1424<=e&&e<=1524?"R":1536<=e&&e<=1785?n.charAt(e-1536):1774<=e&&e<=2220?"r":8192<=e&&e<=8203?"w":8204==e?"b":"L"}function t(e,t,r){this.level=e,this.from=t,this.to=r}var r="bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLN",n="nnnnnnNNr%%r,rNNmmmmmmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmmmnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmnNmmmmmmrrmmNmmmmrr1111111111",i=/[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/,o=/[stwN]/,l=/[LRr]/,s=/[Lb1n]/,a=/[1n]/;return function(r,n){var u="ltr"==n?"L":"R";if(0==r.length||"ltr"==n&&!i.test(r))return!1;for(var c=r.length,f=[],h=0;h<c;++h)f.push(e(r.charCodeAt(h)));for(var d=0,p=u;d<c;++d){var v=f[d];"m"==v?f[d]=p:p=v}for(var m=0,y=u;m<c;++m){var b=f[m];"1"==b&&"r"==y?f[m]="n":l.test(b)&&(y=b,"r"==b&&(f[m]="R"))}for(var w=1,x=f[0];w<c-1;++w){var C=f[w];"+"==C&&"1"==x&&"1"==f[w+1]?f[w]="1":","!=C||x!=f[w+1]||"1"!=x&&"n"!=x||(f[w]=x),x=C}for(var S=0;S<c;++S){var L=f[S];if(","==L)f[S]="N";else if("%"==L){var k=void 0;for(k=S+1;k<c&&"%"==f[k];++k);for(var T=S&&"!"==f[S-1]||k<c&&"1"==f[k]?"1":"N",M=S;M<k;++M)f[M]=T;S=k-1}}for(var N=0,O=u;N<c;++N){var A=f[N];"L"==O&&"1"==A?f[N]="L":l.test(A)&&(O=A)}for(var W=0;W<c;++W)if(o.test(f[W])){var D=void 0;for(D=W+1;D<c&&o.test(f[D]);++D);for(var H="L"==(W?f[W-1]:u),F=H==("L"==(D<c?f[D]:u))?H?"L":"R":u,E=W;E<D;++E)f[E]=F;W=D-1}for(var P,I=[],z=0;z<c;)if(s.test(f[z])){var R=z;for(++z;z<c&&s.test(f[z]);++z);I.push(new t(0,R,z))}else{var B=z,G=I.length;for(++z;z<c&&"L"!=f[z];++z);for(var U=B;U<z;)if(a.test(f[U])){B<U&&I.splice(G,0,new t(1,B,U));var V=U;for(++U;U<z&&a.test(f[U]);++U);I.splice(G,0,new t(2,V,U)),B=U}else++U;B<z&&I.splice(G,0,new t(1,B,z))}return 1==I[0].level&&(P=r.match(/^\s+/))&&(I[0].from=P[0].length,I.unshift(new t(0,0,P[0].length))),1==g(I).level&&(P=r.match(/\s+$/))&&(g(I).to-=P[0].length,I.push(new t(0,c-P[0].length,c))),"rtl"==n?I.reverse():I}}(),Zl=[],Ql=function(e,t,r){if(e.addEventListener)e.addEventListener(t,r,!1);else if(e.attachEvent)e.attachEvent("on"+t,r);else{var n=e._handlers||(e._handlers={});n[t]=(n[t]||Zl).concat(r)}},Jl=function(){if(gl&&vl<9)return!1;var e=n("div");return"draggable"in e||"dragDrop"in e}(),es=3!="\n\nb".split(/\n/).length?function(e){for(var t=0,r=[],n=e.length;t<=n;){var i=e.indexOf("\n",t);-1==i&&(i=e.length);var o=e.slice(t,"\r"==e.charAt(i-1)?i-1:i),l=o.indexOf("\r");-1!=l?(r.push(o.slice(0,l)),t+=l+1):(r.push(o),t=i+1)}return r}:function(e){return e.split(/\r\n?|\n/)},ts=window.getSelection?function(e){try{return e.selectionStart!=e.selectionEnd}catch(e){return!1}}:function(e){var t;try{t=e.ownerDocument.selection.createRange()}catch(e){}return!(!t||t.parentElement()!=e)&&0!=t.compareEndPoints("StartToEnd",t)},rs=function(){var e=n("div");return"oncopy"in e||(e.setAttribute("oncopy","return;"),"function"==typeof e.oncopy)}(),ns=null,is={},os={},ls={},ss=function(e,t,r){this.pos=this.start=0,this.string=e,this.tabSize=t||8,this.lastColumnPos=this.lastColumnValue=0,this.lineStart=0,this.lineOracle=r};ss.prototype.eol=function(){return this.pos>=this.string.length},ss.prototype.sol=function(){return this.pos==this.lineStart},ss.prototype.peek=function(){return this.string.charAt(this.pos)||void 0},ss.prototype.next=function(){if(this.pos<this.string.length)return this.string.charAt(this.pos++)},ss.prototype.eat=function(e){var t=this.string.charAt(this.pos);if("string"==typeof e?t==e:t&&(e.test?e.test(t):e(t)))return++this.pos,t},ss.prototype.eatWhile=function(e){for(var t=this.pos;this.eat(e););return this.pos>t},ss.prototype.eatSpace=function(){for(var e=this,t=this.pos;/[\s\u00a0]/.test(this.string.charAt(this.pos));)++e.pos;return this.pos>t},ss.prototype.skipToEnd=function(){this.pos=this.string.length},ss.prototype.skipTo=function(e){var t=this.string.indexOf(e,this.pos);if(t>-1)return this.pos=t,!0},ss.prototype.backUp=function(e){this.pos-=e},ss.prototype.column=function(){return this.lastColumnPos<this.start&&(this.lastColumnValue=f(this.string,this.start,this.tabSize,this.lastColumnPos,this.lastColumnValue),this.lastColumnPos=this.start),this.lastColumnValue-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.indentation=function(){return f(this.string,null,this.tabSize)-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.match=function(e,t,r){if("string"!=typeof e){var n=this.string.slice(this.pos).match(e);return n&&n.index>0?null:(n&&!1!==t&&(this.pos+=n[0].length),n)}var i=function(e){return r?e.toLowerCase():e};if(i(this.string.substr(this.pos,e.length))==i(e))return!1!==t&&(this.pos+=e.length),!0},ss.prototype.current=function(){return this.string.slice(this.start,this.pos)},ss.prototype.hideFirstChars=function(e,t){this.lineStart+=e;try{return t()}finally{this.lineStart-=e}},ss.prototype.lookAhead=function(e){var t=this.lineOracle;return t&&t.lookAhead(e)};var as=function(e,t){this.state=e,this.lookAhead=t},us=function(e,t,r,n){this.state=t,this.doc=e,this.line=r,this.maxLookAhead=n||0};us.prototype.lookAhead=function(e){var t=this.doc.getLine(this.line+e);return null!=t&&e>this.maxLookAhead&&(this.maxLookAhead=e),t},us.prototype.nextLine=function(){this.line++,this.maxLookAhead>0&&this.maxLookAhead--},us.fromSaved=function(e,t,r){return t instanceof as?new us(e,Ke(e.mode,t.state),r,t.lookAhead):new us(e,Ke(e.mode,t),r)},us.prototype.save=function(e){var t=!1!==e?Ke(this.doc.mode,this.state):this.state;return this.maxLookAhead>0?new as(t,this.maxLookAhead):t};var cs=function(e,t,r){this.start=e.start,this.end=e.pos,this.string=e.current(),this.type=t||null,this.state=r},fs=function(e,t,r){this.text=e,ne(this,t),this.height=r?r(this):1};fs.prototype.lineNo=function(){return W(this)},Ae(fs);var hs,ds={},ps={},gs=null,vs=null,ms={left:0,right:0,top:0,bottom:0},ys=function(e,t,r){this.cm=r;var i=this.vert=n("div",[n("div",null,null,"min-width: 1px")],"CodeMirror-vscrollbar"),o=this.horiz=n("div",[n("div",null,null,"height: 100%; min-height: 1px")],"CodeMirror-hscrollbar");e(i),e(o),Ql(i,"scroll",function(){i.clientHeight&&t(i.scrollTop,"vertical")}),Ql(o,"scroll",function(){o.clientWidth&&t(o.scrollLeft,"horizontal")}),this.checkedZeroWidth=!1,gl&&vl<8&&(this.horiz.style.minHeight=this.vert.style.minWidth="18px")};ys.prototype.update=function(e){var t=e.scrollWidth>e.clientWidth+1,r=e.scrollHeight>e.clientHeight+1,n=e.nativeBarWidth;if(r){this.vert.style.display="block",this.vert.style.bottom=t?n+"px":"0";var i=e.viewHeight-(t?n:0);this.vert.firstChild.style.height=Math.max(0,e.scrollHeight-e.clientHeight+i)+"px"}else this.vert.style.display="",this.vert.firstChild.style.height="0";if(t){this.horiz.style.display="block",this.horiz.style.right=r?n+"px":"0",this.horiz.style.left=e.barLeft+"px";var o=e.viewWidth-e.barLeft-(r?n:0);this.horiz.firstChild.style.width=Math.max(0,e.scrollWidth-e.clientWidth+o)+"px"}else this.horiz.style.display="",this.horiz.firstChild.style.width="0";return!this.checkedZeroWidth&&e.clientHeight>0&&(0==n&&this.zeroWidthHack(),this.checkedZeroWidth=!0),{right:r?n:0,bottom:t?n:0}},ys.prototype.setScrollLeft=function(e){this.horiz.scrollLeft!=e&&(this.horiz.scrollLeft=e),this.disableHoriz&&this.enableZeroWidthBar(this.horiz,this.disableHoriz,"horiz")},ys.prototype.setScrollTop=function(e){this.vert.scrollTop!=e&&(this.vert.scrollTop=e),this.disableVert&&this.enableZeroWidthBar(this.vert,this.disableVert,"vert")},ys.prototype.zeroWidthHack=function(){var e=Ml&&!Cl?"12px":"18px";this.horiz.style.height=this.vert.style.width=e,this.horiz.style.pointerEvents=this.vert.style.pointerEvents="none",this.disableHoriz=new Pl,this.disableVert=new Pl},ys.prototype.enableZeroWidthBar=function(e,t,r){function n(){var i=e.getBoundingClientRect();("vert"==r?document.elementFromPoint(i.right-1,(i.top+i.bottom)/2):document.elementFromPoint((i.right+i.left)/2,i.bottom-1))!=e?e.style.pointerEvents="none":t.set(1e3,n)}e.style.pointerEvents="auto",t.set(1e3,n)},ys.prototype.clear=function(){var e=this.horiz.parentNode;e.removeChild(this.horiz),e.removeChild(this.vert)};var bs=function(){};bs.prototype.update=function(){return{bottom:0,right:0}},bs.prototype.setScrollLeft=function(){},bs.prototype.setScrollTop=function(){},bs.prototype.clear=function(){};var ws={native:ys,null:bs},xs=0,Cs=function(e,t,r){var n=e.display;this.viewport=t,this.visible=Ir(n,e.doc,t),this.editorIsHidden=!n.wrapper.offsetWidth,this.wrapperHeight=n.wrapper.clientHeight,this.wrapperWidth=n.wrapper.clientWidth,this.oldDisplayWidth=Rt(e),this.force=r,this.dims=br(e),this.events=[]};Cs.prototype.signal=function(e,t){Oe(e,t)&&this.events.push(arguments)},Cs.prototype.finish=function(){for(var e=this,t=0;t<this.events.length;t++)Te.apply(null,e.events[t])};var Ss=0,Ls=null;gl?Ls=-.53:fl?Ls=15:bl?Ls=-.7:xl&&(Ls=-1/3);var ks=function(e,t){this.ranges=e,this.primIndex=t};ks.prototype.primary=function(){return this.ranges[this.primIndex]},ks.prototype.equals=function(e){var t=this;if(e==this)return!0;if(e.primIndex!=this.primIndex||e.ranges.length!=this.ranges.length)return!1;for(var r=0;r<this.ranges.length;r++){var n=t.ranges[r],i=e.ranges[r];if(!I(n.anchor,i.anchor)||!I(n.head,i.head))return!1}return!0},ks.prototype.deepCopy=function(){for(var e=this,t=[],r=0;r<this.ranges.length;r++)t[r]=new Ts(z(e.ranges[r].anchor),z(e.ranges[r].head));return new ks(t,this.primIndex)},ks.prototype.somethingSelected=function(){for(var e=this,t=0;t<this.ranges.length;t++)if(!e.ranges[t].empty())return!0;return!1},ks.prototype.contains=function(e,t){var r=this;t||(t=e);for(var n=0;n<this.ranges.length;n++){var i=r.ranges[n];if(P(t,i.from())>=0&&P(e,i.to())<=0)return n}return-1};var Ts=function(e,t){this.anchor=e,this.head=t};Ts.prototype.from=function(){return B(this.anchor,this.head)},Ts.prototype.to=function(){return R(this.anchor,this.head)},Ts.prototype.empty=function(){return this.head.line==this.anchor.line&&this.head.ch==this.anchor.ch},Bi.prototype={chunkSize:function(){return this.lines.length},removeInner:function(e,t){for(var r=this,n=e,i=e+t;n<i;++n){var o=r.lines[n];r.height-=o.height,ot(o),bt(o,"delete")}this.lines.splice(e,t)},collapse:function(e){e.push.apply(e,this.lines)},insertInner:function(e,t,r){var n=this;this.height+=r,this.lines=this.lines.slice(0,e).concat(t).concat(this.lines.slice(e));for(var i=0;i<t.length;++i)t[i].parent=n},iterN:function(e,t,r){for(var n=this,i=e+t;e<i;++e)if(r(n.lines[e]))return!0}},Gi.prototype={chunkSize:function(){return this.size},removeInner:function(e,t){var r=this;this.size-=t;for(var n=0;n<this.children.length;++n){var i=r.children[n],o=i.chunkSize();if(e<o){var l=Math.min(t,o-e),s=i.height;if(i.removeInner(e,l),r.height-=s-i.height,o==l&&(r.children.splice(n--,1),i.parent=null),0==(t-=l))break;e=0}else e-=o}if(this.size-t<25&&(this.children.length>1||!(this.children[0]instanceof Bi))){var a=[];this.collapse(a),this.children=[new Bi(a)],this.children[0].parent=this}},collapse:function(e){for(var t=this,r=0;r<this.children.length;++r)t.children[r].collapse(e)},insertInner:function(e,t,r){var n=this;this.size+=t.length,this.height+=r;for(var i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<=l){if(o.insertInner(e,t,r),o.lines&&o.lines.length>50){for(var s=o.lines.length%25+25,a=s;a<o.lines.length;){var u=new Bi(o.lines.slice(a,a+=25));o.height-=u.height,n.children.splice(++i,0,u),u.parent=n}o.lines=o.lines.slice(0,s),n.maybeSpill()}break}e-=l}},maybeSpill:function(){if(!(this.children.length<=10)){var e=this;do{var t=new Gi(e.children.splice(e.children.length-5,5));if(e.parent){e.size-=t.size,e.height-=t.height;var r=h(e.parent.children,e);e.parent.children.splice(r+1,0,t)}else{var n=new Gi(e.children);n.parent=e,e.children=[n,t],e=n}t.parent=e.parent}while(e.children.length>10);e.parent.maybeSpill()}},iterN:function(e,t,r){for(var n=this,i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<l){var s=Math.min(t,l-e);if(o.iterN(e,s,r))return!0;if(0==(t-=s))break;e=0}else e-=l}}};var Ms=function(e,t,r){var n=this;if(r)for(var i in r)r.hasOwnProperty(i)&&(n[i]=r[i]);this.doc=e,this.node=t};Ms.prototype.clear=function(){var e=this,t=this.doc.cm,r=this.line.widgets,n=this.line,i=W(n);if(null!=i&&r){for(var o=0;o<r.length;++o)r[o]==e&&r.splice(o--,1);r.length||(n.widgets=null);var l=Ht(this);A(n,Math.max(0,n.height-l)),t&&(hn(t,function(){Ui(t,n,-l),mn(t,i,"widget")}),bt(t,"lineWidgetCleared",t,this,i))}},Ms.prototype.changed=function(){var e=this,t=this.height,r=this.doc.cm,n=this.line;this.height=null;var i=Ht(this)-t;i&&(A(n,n.height+i),r&&hn(r,function(){r.curOp.forceUpdate=!0,Ui(r,n,i),bt(r,"lineWidgetChanged",r,e,W(n))}))},Ae(Ms);var Ns=0,Os=function(e,t){this.lines=[],this.type=t,this.doc=e,this.id=++Ns};Os.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){var t=this.doc.cm,r=t&&!t.curOp;if(r&&nn(t),Oe(this,"clear")){var n=this.find();n&&bt(this,"clear",n.from,n.to)}for(var i=null,o=null,l=0;l<this.lines.length;++l){var s=e.lines[l],a=_(s.markedSpans,e);t&&!e.collapsed?mn(t,W(s),"text"):t&&(null!=a.to&&(o=W(s)),null!=a.from&&(i=W(s))),s.markedSpans=$(s.markedSpans,a),null==a.from&&e.collapsed&&!ve(e.doc,s)&&t&&A(s,mr(t.display))}if(t&&this.collapsed&&!t.options.lineWrapping)for(var u=0;u<this.lines.length;++u){var c=fe(e.lines[u]),f=be(c);f>t.display.maxLineLength&&(t.display.maxLine=c,t.display.maxLineLength=f,t.display.maxLineChanged=!0)}null!=i&&t&&this.collapsed&&vn(t,i,o+1),this.lines.length=0,this.explicitlyCleared=!0,this.atomic&&this.doc.cantEdit&&(this.doc.cantEdit=!1,t&&Ci(t.doc)),t&&bt(t,"markerCleared",t,this,i,o),r&&on(t),this.parent&&this.parent.clear()}},Os.prototype.find=function(e,t){var r=this;null==e&&"bookmark"==this.type&&(e=1);for(var n,i,o=0;o<this.lines.length;++o){var l=r.lines[o],s=_(l.markedSpans,r);if(null!=s.from&&(n=E(t?l:W(l),s.from),-1==e))return n;if(null!=s.to&&(i=E(t?l:W(l),s.to),1==e))return i}return n&&{from:n,to:i}},Os.prototype.changed=function(){var e=this,t=this.find(-1,!0),r=this,n=this.doc.cm;t&&n&&hn(n,function(){var i=t.line,o=W(t.line),l=jt(n,o);if(l&&(Qt(l),n.curOp.selectionChanged=n.curOp.forceUpdate=!0),n.curOp.updateMaxLine=!0,!ve(r.doc,i)&&null!=r.height){var s=r.height;r.height=null;var a=Ht(r)-s;a&&A(i,i.height+a)}bt(n,"markerChanged",n,e)})},Os.prototype.attachLine=function(e){if(!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;t.maybeHiddenMarkers&&-1!=h(t.maybeHiddenMarkers,this)||(t.maybeUnhiddenMarkers||(t.maybeUnhiddenMarkers=[])).push(this)}this.lines.push(e)},Os.prototype.detachLine=function(e){if(this.lines.splice(h(this.lines,e),1),!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;(t.maybeHiddenMarkers||(t.maybeHiddenMarkers=[])).push(this)}},Ae(Os);var As=function(e,t){var r=this;this.markers=e,this.primary=t;for(var n=0;n<e.length;++n)e[n].parent=r};As.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){this.explicitlyCleared=!0;for(var t=0;t<this.markers.length;++t)e.markers[t].clear();bt(this,"clear")}},As.prototype.find=function(e,t){return this.primary.find(e,t)},Ae(As);var Ws=0,Ds=function(e,t,r,n,i){if(!(this instanceof Ds))return new Ds(e,t,r,n,i);null==r&&(r=0),Gi.call(this,[new Bi([new fs("",null)])]),this.first=r,this.scrollTop=this.scrollLeft=0,this.cantEdit=!1,this.cleanGeneration=1,this.modeFrontier=this.highlightFrontier=r;var o=E(r,0);this.sel=Rn(o),this.history=new Jn(null),this.id=++Ws,this.modeOption=t,this.lineSep=n,this.direction="rtl"==i?"rtl":"ltr",this.extend=!1,"string"==typeof e&&(e=this.splitLines(e)),_n(this,{from:o,to:o,text:e}),bi(this,Rn(o),Gl)};Ds.prototype=b(Gi.prototype,{constructor:Ds,iter:function(e,t,r){r?this.iterN(e-this.first,t-e,r):this.iterN(this.first,this.first+this.size,e)},insert:function(e,t){for(var r=0,n=0;n<t.length;++n)r+=t[n].height;this.insertInner(e-this.first,t,r)},remove:function(e,t){this.removeInner(e-this.first,t)},getValue:function(e){var t=O(this,this.first,this.first+this.size);return!1===e?t:t.join(e||this.lineSeparator())},setValue:gn(function(e){var t=E(this.first,0),r=this.first+this.size-1;Oi(this,{from:t,to:E(r,M(this,r).text.length),text:this.splitLines(e),origin:"setValue",full:!0},!0),this.cm&&Xr(this.cm,0,0),bi(this,Rn(t),Gl)}),replaceRange:function(e,t,r,n){Ei(this,e,t=U(this,t),r=r?U(this,r):t,n)},getRange:function(e,t,r){var n=N(this,U(this,e),U(this,t));return!1===r?n:n.join(r||this.lineSeparator())},getLine:function(e){var t=this.getLineHandle(e);return t&&t.text},getLineHandle:function(e){if(H(this,e))return M(this,e)},getLineNumber:function(e){return W(e)},getLineHandleVisualStart:function(e){return"number"==typeof e&&(e=M(this,e)),fe(e)},lineCount:function(){return this.size},firstLine:function(){return this.first},lastLine:function(){return this.first+this.size-1},clipPos:function(e){return U(this,e)},getCursor:function(e){var t=this.sel.primary();return null==e||"head"==e?t.head:"anchor"==e?t.anchor:"end"==e||"to"==e||!1===e?t.to():t.from()},listSelections:function(){return this.sel.ranges},somethingSelected:function(){return this.sel.somethingSelected()},setCursor:gn(function(e,t,r){vi(this,U(this,"number"==typeof e?E(e,t||0):e),null,r)}),setSelection:gn(function(e,t,r){vi(this,U(this,e),U(this,t||e),r)}),extendSelection:gn(function(e,t,r){di(this,U(this,e),t&&U(this,t),r)}),extendSelections:gn(function(e,t){pi(this,K(this,e),t)}),extendSelectionsBy:gn(function(e,t){pi(this,K(this,v(this.sel.ranges,e)),t)}),setSelections:gn(function(e,t,r){var n=this;if(e.length){for(var i=[],o=0;o<e.length;o++)i[o]=new Ts(U(n,e[o].anchor),U(n,e[o].head));null==t&&(t=Math.min(e.length-1,this.sel.primIndex)),bi(this,zn(i,t),r)}}),addSelection:gn(function(e,t,r){var n=this.sel.ranges.slice(0);n.push(new Ts(U(this,e),U(this,t||e))),bi(this,zn(n,n.length-1),r)}),getSelection:function(e){for(var t,r=this,n=this.sel.ranges,i=0;i<n.length;i++){var o=N(r,n[i].from(),n[i].to());t=t?t.concat(o):o}return!1===e?t:t.join(e||this.lineSeparator())},getSelections:function(e){for(var t=this,r=[],n=this.sel.ranges,i=0;i<n.length;i++){var o=N(t,n[i].from(),n[i].to());!1!==e&&(o=o.join(e||t.lineSeparator())),r[i]=o}return r},replaceSelection:function(e,t,r){for(var n=[],i=0;i<this.sel.ranges.length;i++)n[i]=e;this.replaceSelections(n,t,r||"+input")},replaceSelections:gn(function(e,t,r){for(var n=this,i=[],o=this.sel,l=0;l<o.ranges.length;l++){var s=o.ranges[l];i[l]={from:s.from(),to:s.to(),text:n.splitLines(e[l]),origin:r}}for(var a=t&&"end"!=t&&Kn(this,i,t),u=i.length-1;u>=0;u--)Oi(n,i[u]);a?yi(this,a):this.cm&&jr(this.cm)}),undo:gn(function(){Wi(this,"undo")}),redo:gn(function(){Wi(this,"redo")}),undoSelection:gn(function(){Wi(this,"undo",!0)}),redoSelection:gn(function(){Wi(this,"redo",!0)}),setExtending:function(e){this.extend=e},getExtending:function(){return this.extend},historySize:function(){for(var e=this.history,t=0,r=0,n=0;n<e.done.length;n++)e.done[n].ranges||++t;for(var i=0;i<e.undone.length;i++)e.undone[i].ranges||++r;return{undo:t,redo:r}},clearHistory:function(){this.history=new Jn(this.history.maxGeneration)},markClean:function(){this.cleanGeneration=this.changeGeneration(!0)},changeGeneration:function(e){return e&&(this.history.lastOp=this.history.lastSelOp=this.history.lastOrigin=null),this.history.generation},isClean:function(e){return this.history.generation==(e||this.cleanGeneration)},getHistory:function(){return{done:fi(this.history.done),undone:fi(this.history.undone)}},setHistory:function(e){var t=this.history=new Jn(this.history.maxGeneration);t.done=fi(e.done.slice(0),null,!0),t.undone=fi(e.undone.slice(0),null,!0)},setGutterMarker:gn(function(e,t,r){return Ri(this,e,"gutter",function(e){var n=e.gutterMarkers||(e.gutterMarkers={});return n[t]=r,!r&&C(n)&&(e.gutterMarkers=null),!0})}),clearGutter:gn(function(e){var t=this;this.iter(function(r){r.gutterMarkers&&r.gutterMarkers[e]&&Ri(t,r,"gutter",function(){return r.gutterMarkers[e]=null,C(r.gutterMarkers)&&(r.gutterMarkers=null),!0})})}),lineInfo:function(e){var t;if("number"==typeof e){if(!H(this,e))return null;if(t=e,!(e=M(this,e)))return null}else if(null==(t=W(e)))return null;return{line:t,handle:e,text:e.text,gutterMarkers:e.gutterMarkers,textClass:e.textClass,bgClass:e.bgClass,wrapClass:e.wrapClass,widgets:e.widgets}},addLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass";if(t[i]){if(e(n).test(t[i]))return!1;t[i]+=" "+n}else t[i]=n;return!0})}),removeLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass",o=t[i];if(!o)return!1;if(null==n)t[i]=null;else{var l=o.match(e(n));if(!l)return!1;var s=l.index+l[0].length;t[i]=o.slice(0,l.index)+(l.index&&s!=o.length?" ":"")+o.slice(s)||null}return!0})}),addLineWidget:gn(function(e,t,r){return Vi(this,e,t,r)}),removeLineWidget:function(e){e.clear()},markText:function(e,t,r){return Ki(this,U(this,e),U(this,t),r,r&&r.type||"range")},setBookmark:function(e,t){var r={replacedWith:t&&(null==t.nodeType?t.widget:t),insertLeft:t&&t.insertLeft,clearWhenEmpty:!1,shared:t&&t.shared,handleMouseEvents:t&&t.handleMouseEvents};return e=U(this,e),Ki(this,e,e,r,"bookmark")},findMarksAt:function(e){var t=[],r=M(this,(e=U(this,e)).line).markedSpans;if(r)for(var n=0;n<r.length;++n){var i=r[n];(null==i.from||i.from<=e.ch)&&(null==i.to||i.to>=e.ch)&&t.push(i.marker.parent||i.marker)}return t},findMarks:function(e,t,r){e=U(this,e),t=U(this,t);var n=[],i=e.line;return this.iter(e.line,t.line+1,function(o){var l=o.markedSpans;if(l)for(var s=0;s<l.length;s++){var a=l[s];null!=a.to&&i==e.line&&e.ch>=a.to||null==a.from&&i!=e.line||null!=a.from&&i==t.line&&a.from>=t.ch||r&&!r(a.marker)||n.push(a.marker.parent||a.marker)}++i}),n},getAllMarks:function(){var e=[];return this.iter(function(t){var r=t.markedSpans;if(r)for(var n=0;n<r.length;++n)null!=r[n].from&&e.push(r[n].marker)}),e},posFromIndex:function(e){var t,r=this.first,n=this.lineSeparator().length;return this.iter(function(i){var o=i.text.length+n;if(o>e)return t=e,!0;e-=o,++r}),U(this,E(r,t))},indexFromPos:function(e){var t=(e=U(this,e)).ch;if(e.line<this.first||e.ch<0)return 0;var r=this.lineSeparator().length;return this.iter(this.first,e.line,function(e){t+=e.text.length+r}),t},copy:function(e){var t=new Ds(O(this,this.first,this.first+this.size),this.modeOption,this.first,this.lineSep,this.direction);return t.scrollTop=this.scrollTop,t.scrollLeft=this.scrollLeft,t.sel=this.sel,t.extend=!1,e&&(t.history.undoDepth=this.history.undoDepth,t.setHistory(this.getHistory())),t},linkedDoc:function(e){e||(e={});var t=this.first,r=this.first+this.size;null!=e.from&&e.from>t&&(t=e.from),null!=e.to&&e.to<r&&(r=e.to);var n=new Ds(O(this,t,r),e.mode||this.modeOption,t,this.lineSep,this.direction);return e.sharedHist&&(n.history=this.history),(this.linked||(this.linked=[])).push({doc:n,sharedHist:e.sharedHist}),n.linked=[{doc:this,isParent:!0,sharedHist:e.sharedHist}],Yi(n,Xi(this)),n},unlinkDoc:function(e){var t=this;if(e instanceof jo&&(e=e.doc),this.linked)for(var r=0;r<this.linked.length;++r)if(t.linked[r].doc==e){t.linked.splice(r,1),e.unlinkDoc(t),_i(Xi(t));break}if(e.history==this.history){var n=[e.id];$n(e,function(e){return n.push(e.id)},!0),e.history=new Jn(null),e.history.done=fi(this.history.done,n),e.history.undone=fi(this.history.undone,n)}},iterLinkedDocs:function(e){$n(this,e)},getMode:function(){return this.mode},getEditor:function(){return this.cm},splitLines:function(e){return this.lineSep?e.split(this.lineSep):es(e)},lineSeparator:function(){return this.lineSep||"\n"},setDirection:gn(function(e){"rtl"!=e&&(e="ltr"),e!=this.direction&&(this.direction=e,this.iter(function(e){return e.order=null}),this.cm&&Qn(this.cm))})}),Ds.prototype.eachLine=Ds.prototype.iter;for(var Hs=0,Fs=!1,Es={3:"Enter",8:"Backspace",9:"Tab",13:"Enter",16:"Shift",17:"Ctrl",18:"Alt",19:"Pause",20:"CapsLock",27:"Esc",32:"Space",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"Left",38:"Up",39:"Right",40:"Down",44:"PrintScrn",45:"Insert",46:"Delete",59:";",61:"=",91:"Mod",92:"Mod",93:"Mod",106:"*",107:"=",109:"-",110:".",111:"/",127:"Delete",173:"-",186:";",187:"=",188:",",189:"-",190:".",191:"/",192:"`",219:"[",220:"\\",221:"]",222:"'",63232:"Up",63233:"Down",63234:"Left",63235:"Right",63272:"Delete",63273:"Home",63275:"End",63276:"PageUp",63277:"PageDown",63302:"Insert"},Ps=0;Ps<10;Ps++)Es[Ps+48]=Es[Ps+96]=String(Ps);for(var Is=65;Is<=90;Is++)Es[Is]=String.fromCharCode(Is);for(var zs=1;zs<=12;zs++)Es[zs+111]=Es[zs+63235]="F"+zs;var Rs={};Rs.basic={Left:"goCharLeft",Right:"goCharRight",Up:"goLineUp",Down:"goLineDown",End:"goLineEnd",Home:"goLineStartSmart",PageUp:"goPageUp",PageDown:"goPageDown",Delete:"delCharAfter",Backspace:"delCharBefore","Shift-Backspace":"delCharBefore",Tab:"defaultTab","Shift-Tab":"indentAuto",Enter:"newlineAndIndent",Insert:"toggleOverwrite",Esc:"singleSelection"},Rs.pcDefault={"Ctrl-A":"selectAll","Ctrl-D":"deleteLine","Ctrl-Z":"undo","Shift-Ctrl-Z":"redo","Ctrl-Y":"redo","Ctrl-Home":"goDocStart","Ctrl-End":"goDocEnd","Ctrl-Up":"goLineUp","Ctrl-Down":"goLineDown","Ctrl-Left":"goGroupLeft","Ctrl-Right":"goGroupRight","Alt-Left":"goLineStart","Alt-Right":"goLineEnd","Ctrl-Backspace":"delGroupBefore","Ctrl-Delete":"delGroupAfter","Ctrl-S":"save","Ctrl-F":"find","Ctrl-G":"findNext","Shift-Ctrl-G":"findPrev","Shift-Ctrl-F":"replace","Shift-Ctrl-R":"replaceAll","Ctrl-[":"indentLess","Ctrl-]":"indentMore","Ctrl-U":"undoSelection","Shift-Ctrl-U":"redoSelection","Alt-U":"redoSelection",fallthrough:"basic"},Rs.emacsy={"Ctrl-F":"goCharRight","Ctrl-B":"goCharLeft","Ctrl-P":"goLineUp","Ctrl-N":"goLineDown","Alt-F":"goWordRight","Alt-B":"goWordLeft","Ctrl-A":"goLineStart","Ctrl-E":"goLineEnd","Ctrl-V":"goPageDown","Shift-Ctrl-V":"goPageUp","Ctrl-D":"delCharAfter","Ctrl-H":"delCharBefore","Alt-D":"delWordAfter","Alt-Backspace":"delWordBefore","Ctrl-K":"killLine","Ctrl-T":"transposeChars","Ctrl-O":"openLine"},Rs.macDefault={"Cmd-A":"selectAll","Cmd-D":"deleteLine","Cmd-Z":"undo","Shift-Cmd-Z":"redo","Cmd-Y":"redo","Cmd-Home":"goDocStart","Cmd-Up":"goDocStart","Cmd-End":"goDocEnd","Cmd-Down":"goDocEnd","Alt-Left":"goGroupLeft","Alt-Right":"goGroupRight","Cmd-Left":"goLineLeft","Cmd-Right":"goLineRight","Alt-Backspace":"delGroupBefore","Ctrl-Alt-Backspace":"delGroupAfter","Alt-Delete":"delGroupAfter","Cmd-S":"save","Cmd-F":"find","Cmd-G":"findNext","Shift-Cmd-G":"findPrev","Cmd-Alt-F":"replace","Shift-Cmd-Alt-F":"replaceAll","Cmd-[":"indentLess","Cmd-]":"indentMore","Cmd-Backspace":"delWrappedLineLeft","Cmd-Delete":"delWrappedLineRight","Cmd-U":"undoSelection","Shift-Cmd-U":"redoSelection","Ctrl-Up":"goDocStart","Ctrl-Down":"goDocEnd",fallthrough:["basic","emacsy"]},Rs.default=Ml?Rs.macDefault:Rs.pcDefault;var Bs={selectAll:Mi,singleSelection:function(e){return e.setSelection(e.getCursor("anchor"),e.getCursor("head"),Gl)},killLine:function(e){return co(e,function(t){if(t.empty()){var r=M(e.doc,t.head.line).text.length;return t.head.ch==r&&t.head.line<e.lastLine()?{from:t.head,to:E(t.head.line+1,0)}:{from:t.head,to:E(t.head.line,r)}}return{from:t.from(),to:t.to()}})},deleteLine:function(e){return co(e,function(t){return{from:E(t.from().line,0),to:U(e.doc,E(t.to().line+1,0))}})},delLineLeft:function(e){return co(e,function(e){return{from:E(e.from().line,0),to:e.from()}})},delWrappedLineLeft:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5;return{from:e.coordsChar({left:0,top:r},"div"),to:t.from()}})},delWrappedLineRight:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5,n=e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div");return{from:t.from(),to:n}})},undo:function(e){return e.undo()},redo:function(e){return e.redo()},undoSelection:function(e){return e.undoSelection()},redoSelection:function(e){return e.redoSelection()},goDocStart:function(e){return e.extendSelection(E(e.firstLine(),0))},goDocEnd:function(e){return e.extendSelection(E(e.lastLine()))},goLineStart:function(e){return e.extendSelectionsBy(function(t){return vo(e,t.head.line)},{origin:"+move",bias:1})},goLineStartSmart:function(e){return e.extendSelectionsBy(function(t){return yo(e,t.head)},{origin:"+move",bias:1})},goLineEnd:function(e){return e.extendSelectionsBy(function(t){return mo(e,t.head.line)},{origin:"+move",bias:-1})},goLineRight:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div")},Vl)},goLineLeft:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:0,top:r},"div")},Vl)},goLineLeftSmart:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5,n=e.coordsChar({left:0,top:r},"div");return n.ch<e.getLine(n.line).search(/\S/)?yo(e,t.head):n},Vl)},goLineUp:function(e){return e.moveV(-1,"line")},goLineDown:function(e){return e.moveV(1,"line")},goPageUp:function(e){return e.moveV(-1,"page")},goPageDown:function(e){return e.moveV(1,"page")},goCharLeft:function(e){return e.moveH(-1,"char")},goCharRight:function(e){return e.moveH(1,"char")},goColumnLeft:function(e){return e.moveH(-1,"column")},goColumnRight:function(e){return e.moveH(1,"column")},goWordLeft:function(e){return e.moveH(-1,"word")},goGroupRight:function(e){return e.moveH(1,"group")},goGroupLeft:function(e){return e.moveH(-1,"group")},goWordRight:function(e){return e.moveH(1,"word")},delCharBefore:function(e){return e.deleteH(-1,"char")},delCharAfter:function(e){return e.deleteH(1,"char")},delWordBefore:function(e){return e.deleteH(-1,"word")},delWordAfter:function(e){return e.deleteH(1,"word")},delGroupBefore:function(e){return e.deleteH(-1,"group")},delGroupAfter:function(e){return e.deleteH(1,"group")},indentAuto:function(e){return e.indentSelection("smart")},indentMore:function(e){return e.indentSelection("add")},indentLess:function(e){return e.indentSelection("subtract")},insertTab:function(e){return e.replaceSelection("\t")},insertSoftTab:function(e){for(var t=[],r=e.listSelections(),n=e.options.tabSize,i=0;i<r.length;i++){var o=r[i].from(),l=f(e.getLine(o.line),o.ch,n);t.push(p(n-l%n))}e.replaceSelections(t)},defaultTab:function(e){e.somethingSelected()?e.indentSelection("add"):e.execCommand("insertTab")},transposeChars:function(e){return hn(e,function(){for(var t=e.listSelections(),r=[],n=0;n<t.length;n++)if(t[n].empty()){var i=t[n].head,o=M(e.doc,i.line).text;if(o)if(i.ch==o.length&&(i=new E(i.line,i.ch-1)),i.ch>0)i=new E(i.line,i.ch+1),e.replaceRange(o.charAt(i.ch-1)+o.charAt(i.ch-2),E(i.line,i.ch-2),i,"+transpose");else if(i.line>e.doc.first){var l=M(e.doc,i.line-1).text;l&&(i=new E(i.line,1),e.replaceRange(o.charAt(0)+e.doc.lineSeparator()+l.charAt(l.length-1),E(i.line-1,l.length-1),i,"+transpose"))}r.push(new Ts(i,i))}e.setSelections(r)})},newlineAndIndent:function(e){return hn(e,function(){for(var t=e.listSelections(),r=t.length-1;r>=0;r--)e.replaceRange(e.doc.lineSeparator(),t[r].anchor,t[r].head,"+input");t=e.listSelections();for(var n=0;n<t.length;n++)e.indentLine(t[n].from().line,null,!0);jr(e)})},openLine:function(e){return e.replaceSelection("\n","start")},toggleOverwrite:function(e){return e.toggleOverwrite()}},Gs=new Pl,Us=null,Vs=function(e,t,r){this.time=e,this.pos=t,this.button=r};Vs.prototype.compare=function(e,t,r){return this.time+400>e&&0==P(t,this.pos)&&r==this.button};var Ks,js,Xs={toString:function(){return"CodeMirror.Init"}},Ys={},_s={};jo.defaults=Ys,jo.optionHandlers=_s;var $s=[];jo.defineInitHook=function(e){return $s.push(e)};var qs=null,Zs=function(e){this.cm=e,this.lastAnchorNode=this.lastAnchorOffset=this.lastFocusNode=this.lastFocusOffset=null,this.polling=new Pl,this.composing=null,this.gracePeriod=!1,this.readDOMTimeout=null};Zs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()}),"cut"==e.type&&i.replaceSelection("",null,"cut");else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type&&i.operation(function(){i.setSelections(t.ranges,0,Gl),i.replaceSelection("",null,"cut")})}if(e.clipboardData){e.clipboardData.clearData();var r=qs.text.join("\n");if(e.clipboardData.setData("Text",r),e.clipboardData.getData("Text")==r)return void e.preventDefault()}var l=el(),s=l.firstChild;i.display.lineSpace.insertBefore(l,i.display.lineSpace.firstChild),s.value=qs.text.join("\n");var a=document.activeElement;El(s),setTimeout(function(){i.display.lineSpace.removeChild(l),a.focus(),a==o&&n.showPrimarySelection()},50)}}var r=this,n=this,i=n.cm,o=n.div=e.lineDiv;Jo(o,i.options.spellcheck),Ql(o,"paste",function(e){Me(i,e)||qo(e,i)||vl<=11&&setTimeout(dn(i,function(){return r.updateFromDOM()}),20)}),Ql(o,"compositionstart",function(e){r.composing={data:e.data,done:!1}}),Ql(o,"compositionupdate",function(e){r.composing||(r.composing={data:e.data,done:!1})}),Ql(o,"compositionend",function(e){r.composing&&(e.data!=r.composing.data&&r.readFromDOMSoon(),r.composing.done=!0)}),Ql(o,"touchstart",function(){return n.forceCompositionEnd()}),Ql(o,"input",function(){r.composing||r.readFromDOMSoon()}),Ql(o,"copy",t),Ql(o,"cut",t)},Zs.prototype.prepareSelection=function(){var e=Tr(this.cm,!1);return e.focus=this.cm.state.focused,e},Zs.prototype.showSelection=function(e,t){e&&this.cm.display.view.length&&((e.focus||t)&&this.showPrimarySelection(),this.showMultipleSelections(e))},Zs.prototype.showPrimarySelection=function(){var e=window.getSelection(),t=this.cm,r=t.doc.sel.primary(),n=r.from(),i=r.to();if(t.display.viewTo==t.display.viewFrom||n.line>=t.display.viewTo||i.line<t.display.viewFrom)e.removeAllRanges();else{var o=sl(t,e.anchorNode,e.anchorOffset),l=sl(t,e.focusNode,e.focusOffset);if(!o||o.bad||!l||l.bad||0!=P(B(o,l),n)||0!=P(R(o,l),i)){var s=t.display.view,a=n.line>=t.display.viewFrom&&nl(t,n)||{node:s[0].measure.map[2],offset:0},u=i.line<t.display.viewTo&&nl(t,i);if(!u){var c=s[s.length-1].measure,f=c.maps?c.maps[c.maps.length-1]:c.map;u={node:f[f.length-1],offset:f[f.length-2]-f[f.length-3]}}if(a&&u){var h,d=e.rangeCount&&e.getRangeAt(0);try{h=Wl(a.node,a.offset,u.offset,u.node)}catch(e){}h&&(!fl&&t.state.focused?(e.collapse(a.node,a.offset),h.collapsed||(e.removeAllRanges(),e.addRange(h))):(e.removeAllRanges(),e.addRange(h)),d&&null==e.anchorNode?e.addRange(d):fl&&this.startGracePeriod()),this.rememberSelection()}else e.removeAllRanges()}}},Zs.prototype.startGracePeriod=function(){var e=this;clearTimeout(this.gracePeriod),this.gracePeriod=setTimeout(function(){e.gracePeriod=!1,e.selectionChanged()&&e.cm.operation(function(){return e.cm.curOp.selectionChanged=!0})},20)},Zs.prototype.showMultipleSelections=function(e){r(this.cm.display.cursorDiv,e.cursors),r(this.cm.display.selectionDiv,e.selection)},Zs.prototype.rememberSelection=function(){var e=window.getSelection();this.lastAnchorNode=e.anchorNode,this.lastAnchorOffset=e.anchorOffset,this.lastFocusNode=e.focusNode,this.lastFocusOffset=e.focusOffset},Zs.prototype.selectionInEditor=function(){var e=window.getSelection();if(!e.rangeCount)return!1;var t=e.getRangeAt(0).commonAncestorContainer;return o(this.div,t)},Zs.prototype.focus=function(){"nocursor"!=this.cm.options.readOnly&&(this.selectionInEditor()||this.showSelection(this.prepareSelection(),!0),this.div.focus())},Zs.prototype.blur=function(){this.div.blur()},Zs.prototype.getField=function(){return this.div},Zs.prototype.supportsTouch=function(){return!0},Zs.prototype.receivedFocus=function(){function e(){t.cm.state.focused&&(t.pollSelection(),t.polling.set(t.cm.options.pollInterval,e))}var t=this;this.selectionInEditor()?this.pollSelection():hn(this.cm,function(){return t.cm.curOp.selectionChanged=!0}),this.polling.set(this.cm.options.pollInterval,e)},Zs.prototype.selectionChanged=function(){var e=window.getSelection();return e.anchorNode!=this.lastAnchorNode||e.anchorOffset!=this.lastAnchorOffset||e.focusNode!=this.lastFocusNode||e.focusOffset!=this.lastFocusOffset},Zs.prototype.pollSelection=function(){if(null==this.readDOMTimeout&&!this.gracePeriod&&this.selectionChanged()){var e=window.getSelection(),t=this.cm;if(kl&&bl&&this.cm.options.gutters.length&&il(e.anchorNode))return this.cm.triggerOnKeyDown({type:"keydown",keyCode:8,preventDefault:Math.abs}),this.blur(),void this.focus();if(!this.composing){this.rememberSelection();var r=sl(t,e.anchorNode,e.anchorOffset),n=sl(t,e.focusNode,e.focusOffset);r&&n&&hn(t,function(){bi(t.doc,Rn(r,n),Gl),(r.bad||n.bad)&&(t.curOp.selectionChanged=!0)})}}},Zs.prototype.pollContent=function(){null!=this.readDOMTimeout&&(clearTimeout(this.readDOMTimeout),this.readDOMTimeout=null);var e=this.cm,t=e.display,r=e.doc.sel.primary(),n=r.from(),i=r.to();if(0==n.ch&&n.line>e.firstLine()&&(n=E(n.line-1,M(e.doc,n.line-1).length)),i.ch==M(e.doc,i.line).text.length&&i.line<e.lastLine()&&(i=E(i.line+1,0)),n.line<t.viewFrom||i.line>t.viewTo-1)return!1;var o,l,s;n.line==t.viewFrom||0==(o=Lr(e,n.line))?(l=W(t.view[0].line),s=t.view[0].node):(l=W(t.view[o].line),s=t.view[o-1].node.nextSibling);var a,u,c=Lr(e,i.line);if(c==t.view.length-1?(a=t.viewTo-1,u=t.lineDiv.lastChild):(a=W(t.view[c+1].line)-1,u=t.view[c+1].node.previousSibling),!s)return!1;for(var f=e.doc.splitLines(ll(e,s,u,l,a)),h=N(e.doc,E(l,0),E(a,M(e.doc,a).text.length));f.length>1&&h.length>1;)if(g(f)==g(h))f.pop(),h.pop(),a--;else{if(f[0]!=h[0])break;f.shift(),h.shift(),l++}for(var d=0,p=0,v=f[0],m=h[0],y=Math.min(v.length,m.length);d<y&&v.charCodeAt(d)==m.charCodeAt(d);)++d;for(var b=g(f),w=g(h),x=Math.min(b.length-(1==f.length?d:0),w.length-(1==h.length?d:0));p<x&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)++p;if(1==f.length&&1==h.length&&l==n.line)for(;d&&d>n.ch&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)d--,p++;f[f.length-1]=b.slice(0,b.length-p).replace(/^\u200b+/,""),f[0]=f[0].slice(d).replace(/\u200b+$/,"");var C=E(l,d),S=E(a,h.length?g(h).length-p:0);return f.length>1||f[0]||P(C,S)?(Ei(e.doc,f,C,S,"+input"),!0):void 0},Zs.prototype.ensurePolled=function(){this.forceCompositionEnd()},Zs.prototype.reset=function(){this.forceCompositionEnd()},Zs.prototype.forceCompositionEnd=function(){this.composing&&(clearTimeout(this.readDOMTimeout),this.composing=null,this.updateFromDOM(),this.div.blur(),this.div.focus())},Zs.prototype.readFromDOMSoon=function(){var e=this;null==this.readDOMTimeout&&(this.readDOMTimeout=setTimeout(function(){if(e.readDOMTimeout=null,e.composing){if(!e.composing.done)return;e.composing=null}e.updateFromDOM()},80))},Zs.prototype.updateFromDOM=function(){var e=this;!this.cm.isReadOnly()&&this.pollContent()||hn(this.cm,function(){return vn(e.cm)})},Zs.prototype.setUneditable=function(e){e.contentEditable="false"},Zs.prototype.onKeyPress=function(e){0!=e.charCode&&(e.preventDefault(),this.cm.isReadOnly()||dn(this.cm,$o)(this.cm,String.fromCharCode(null==e.charCode?e.keyCode:e.charCode),0))},Zs.prototype.readOnlyChanged=function(e){this.div.contentEditable=String("nocursor"!=e)},Zs.prototype.onContextMenu=function(){},Zs.prototype.resetPosition=function(){},Zs.prototype.needsContentAttribute=!0;var Qs=function(e){this.cm=e,this.prevInput="",this.pollingFast=!1,this.polling=new Pl,this.hasSelection=!1,this.composing=null};Qs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()});else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type?i.setSelections(t.ranges,null,Gl):(n.prevInput="",l.value=t.text.join("\n"),El(l))}"cut"==e.type&&(i.state.cutIncoming=!0)}}var r=this,n=this,i=this.cm,o=this.wrapper=el(),l=this.textarea=o.firstChild;e.wrapper.insertBefore(o,e.wrapper.firstChild),Ll&&(l.style.width="0px"),Ql(l,"input",function(){gl&&vl>=9&&r.hasSelection&&(r.hasSelection=null),n.poll()}),Ql(l,"paste",function(e){Me(i,e)||qo(e,i)||(i.state.pasteIncoming=!0,n.fastPoll())}),Ql(l,"cut",t),Ql(l,"copy",t),Ql(e.scroller,"paste",function(t){Ft(e,t)||Me(i,t)||(i.state.pasteIncoming=!0,n.focus())}),Ql(e.lineSpace,"selectstart",function(t){Ft(e,t)||We(t)}),Ql(l,"compositionstart",function(){var e=i.getCursor("from");n.composing&&n.composing.range.clear(),n.composing={start:e,range:i.markText(e,i.getCursor("to"),{className:"CodeMirror-composing"})}}),Ql(l,"compositionend",function(){n.composing&&(n.poll(),n.composing.range.clear(),n.composing=null)})},Qs.prototype.prepareSelection=function(){var e=this.cm,t=e.display,r=e.doc,n=Tr(e);if(e.options.moveInputWithCursor){var i=sr(e,r.sel.primary().head,"div"),o=t.wrapper.getBoundingClientRect(),l=t.lineDiv.getBoundingClientRect();n.teTop=Math.max(0,Math.min(t.wrapper.clientHeight-10,i.top+l.top-o.top)),n.teLeft=Math.max(0,Math.min(t.wrapper.clientWidth-10,i.left+l.left-o.left))}return n},Qs.prototype.showSelection=function(e){var t=this.cm.display;r(t.cursorDiv,e.cursors),r(t.selectionDiv,e.selection),null!=e.teTop&&(this.wrapper.style.top=e.teTop+"px",this.wrapper.style.left=e.teLeft+"px")},Qs.prototype.reset=function(e){if(!this.contextMenuPending&&!this.composing){var t=this.cm;if(t.somethingSelected()){this.prevInput="";var r=t.getSelection();this.textarea.value=r,t.state.focused&&El(this.textarea),gl&&vl>=9&&(this.hasSelection=r)}else e||(this.prevInput=this.textarea.value="",gl&&vl>=9&&(this.hasSelection=null))}},Qs.prototype.getField=function(){return this.textarea},Qs.prototype.supportsTouch=function(){return!1},Qs.prototype.focus=function(){if("nocursor"!=this.cm.options.readOnly&&(!Tl||l()!=this.textarea))try{this.textarea.focus()}catch(e){}},Qs.prototype.blur=function(){this.textarea.blur()},Qs.prototype.resetPosition=function(){this.wrapper.style.top=this.wrapper.style.left=0},Qs.prototype.receivedFocus=function(){this.slowPoll()},Qs.prototype.slowPoll=function(){var e=this;this.pollingFast||this.polling.set(this.cm.options.pollInterval,function(){e.poll(),e.cm.state.focused&&e.slowPoll()})},Qs.prototype.fastPoll=function(){function e(){r.poll()||t?(r.pollingFast=!1,r.slowPoll()):(t=!0,r.polling.set(60,e))}var t=!1,r=this;r.pollingFast=!0,r.polling.set(20,e)},Qs.prototype.poll=function(){var e=this,t=this.cm,r=this.textarea,n=this.prevInput;if(this.contextMenuPending||!t.state.focused||ts(r)&&!n&&!this.composing||t.isReadOnly()||t.options.disableInput||t.state.keySeq)return!1;var i=r.value;if(i==n&&!t.somethingSelected())return!1;if(gl&&vl>=9&&this.hasSelection===i||Ml&&/[\uf700-\uf7ff]/.test(i))return t.display.input.reset(),!1;if(t.doc.sel==t.display.selForContextMenu){var o=i.charCodeAt(0);if(8203!=o||n||(n="​"),8666==o)return this.reset(),this.cm.execCommand("undo")}for(var l=0,s=Math.min(n.length,i.length);l<s&&n.charCodeAt(l)==i.charCodeAt(l);)++l;return hn(t,function(){$o(t,i.slice(l),n.length-l,null,e.composing?"*compose":null),i.length>1e3||i.indexOf("\n")>-1?r.value=e.prevInput="":e.prevInput=i,e.composing&&(e.composing.range.clear(),e.composing.range=t.markText(e.composing.start,t.getCursor("to"),{className:"CodeMirror-composing"}))}),!0},Qs.prototype.ensurePolled=function(){this.pollingFast&&this.poll()&&(this.pollingFast=!1)},Qs.prototype.onKeyPress=function(){gl&&vl>=9&&(this.hasSelection=null),this.fastPoll()},Qs.prototype.onContextMenu=function(e){function t(){if(null!=l.selectionStart){var e=i.somethingSelected(),t="​"+(e?l.value:"");l.value="⇚",l.value=t,n.prevInput=e?"":"​",l.selectionStart=1,l.selectionEnd=t.length,o.selForContextMenu=i.doc.sel}}function r(){if(n.contextMenuPending=!1,n.wrapper.style.cssText=c,l.style.cssText=u,gl&&vl<9&&o.scrollbars.setScrollTop(o.scroller.scrollTop=a),null!=l.selectionStart){(!gl||gl&&vl<9)&&t();var e=0,r=function(){o.selForContextMenu==i.doc.sel&&0==l.selectionStart&&l.selectionEnd>0&&"​"==n.prevInput?dn(i,Mi)(i):e++<10?o.detectingSelectAll=setTimeout(r,500):(o.selForContextMenu=null,o.input.reset())};o.detectingSelectAll=setTimeout(r,200)}}var n=this,i=n.cm,o=i.display,l=n.textarea,s=Sr(i,e),a=o.scroller.scrollTop;if(s&&!wl){i.options.resetSelectionOnContextMenu&&-1==i.doc.sel.contains(s)&&dn(i,bi)(i.doc,Rn(s),Gl);var u=l.style.cssText,c=n.wrapper.style.cssText;n.wrapper.style.cssText="position: absolute";var f=n.wrapper.getBoundingClientRect();l.style.cssText="position: absolute; width: 30px; height: 30px;\n      top: "+(e.clientY-f.top-5)+"px; left: "+(e.clientX-f.left-5)+"px;\n      z-index: 1000; background: "+(gl?"rgba(255, 255, 255, .05)":"transparent")+";\n      outline: none; border-width: 0; outline: none; overflow: hidden; opacity: .05; filter: alpha(opacity=5);";var h;if(ml&&(h=window.scrollY),o.input.focus(),ml&&window.scrollTo(null,h),o.input.reset(),i.somethingSelected()||(l.value=n.prevInput=" "),n.contextMenuPending=!0,o.selForContextMenu=i.doc.sel,clearTimeout(o.detectingSelectAll),gl&&vl>=9&&t(),Hl){Fe(e);var d=function(){ke(window,"mouseup",d),setTimeout(r,20)};Ql(window,"mouseup",d)}else setTimeout(r,50)}},Qs.prototype.readOnlyChanged=function(e){e||this.reset(),this.textarea.disabled="nocursor"==e},Qs.prototype.setUneditable=function(){},Qs.prototype.needsContentAttribute=!1,function(e){function t(t,n,i,o){e.defaults[t]=n,i&&(r[t]=o?function(e,t,r){r!=Xs&&i(e,t,r)}:i)}var r=e.optionHandlers;e.defineOption=t,e.Init=Xs,t("value","",function(e,t){return e.setValue(t)},!0),t("mode",null,function(e,t){e.doc.modeOption=t,jn(e)},!0),t("indentUnit",2,jn,!0),t("indentWithTabs",!1),t("smartIndent",!0),t("tabSize",4,function(e){Xn(e),er(e),vn(e)},!0),t("lineSeparator",null,function(e,t){if(e.doc.lineSep=t,t){var r=[],n=e.doc.first;e.doc.iter(function(e){for(var i=0;;){var o=e.text.indexOf(t,i);if(-1==o)break;i=o+t.length,r.push(E(n,o))}n++});for(var i=r.length-1;i>=0;i--)Ei(e.doc,t,r[i],E(r[i].line,r[i].ch+t.length))}}),t("specialChars",/[\u0000-\u001f\u007f-\u009f\u00ad\u061c\u200b-\u200f\u2028\u2029\ufeff]/g,function(e,t,r){e.state.specialChars=new RegExp(t.source+(t.test("\t")?"":"|\t"),"g"),r!=Xs&&e.refresh()}),t("specialCharPlaceholder",at,function(e){return e.refresh()},!0),t("electricChars",!0),t("inputStyle",Tl?"contenteditable":"textarea",function(){throw new Error("inputStyle can not (yet) be changed in a running editor")},!0),t("spellcheck",!1,function(e,t){return e.getInputField().spellcheck=t},!0),t("rtlMoveVisually",!Ol),t("wholeLineUpdateBefore",!0),t("theme","default",function(e){Go(e),Uo(e)},!0),t("keyMap","default",function(e,t,r){var n=uo(t),i=r!=Xs&&uo(r);i&&i.detach&&i.detach(e,n),n.attach&&n.attach(e,i||null)}),t("extraKeys",null),t("configureMouse",null),t("lineWrapping",!1,Ko,!0),t("gutters",[],function(e){Fn(e.options),Uo(e)},!0),t("fixedGutter",!0,function(e,t){e.display.gutters.style.left=t?wr(e.display)+"px":"0",e.refresh()},!0),t("coverGutterNextToScrollbar",!1,function(e){return en(e)},!0),t("scrollbarStyle","native",function(e){rn(e),en(e),e.display.scrollbars.setScrollTop(e.doc.scrollTop),e.display.scrollbars.setScrollLeft(e.doc.scrollLeft)},!0),t("lineNumbers",!1,function(e){Fn(e.options),Uo(e)},!0),t("firstLineNumber",1,Uo,!0),t("lineNumberFormatter",function(e){return e},Uo,!0),t("showCursorWhenSelecting",!1,kr,!0),t("resetSelectionOnContextMenu",!0),t("lineWiseCopyCut",!0),t("pasteLinesPerSelection",!0),t("readOnly",!1,function(e,t){"nocursor"==t&&(Fr(e),e.display.input.blur()),e.display.input.readOnlyChanged(t)}),t("disableInput",!1,function(e,t){t||e.display.input.reset()},!0),t("dragDrop",!0,Vo),t("allowDropFileTypes",null),t("cursorBlinkRate",530),t("cursorScrollMargin",0),t("cursorHeight",1,kr,!0),t("singleCursorHeightPerLine",!0,kr,!0),t("workTime",100),t("workDelay",100),t("flattenSpans",!0,Xn,!0),t("addModeClass",!1,Xn,!0),t("pollInterval",100),t("undoDepth",200,function(e,t){return e.doc.history.undoDepth=t}),t("historyEventDelay",1250),t("viewportMargin",10,function(e){return e.refresh()},!0),t("maxHighlightLength",1e4,Xn,!0),t("moveInputWithCursor",!0,function(e,t){t||e.display.input.resetPosition()}),t("tabindex",null,function(e,t){return e.display.input.getField().tabIndex=t||""}),t("autofocus",null),t("direction","ltr",function(e,t){return e.doc.setDirection(t)},!0)}(jo),function(e){var t=e.optionHandlers,r=e.helpers={};e.prototype={constructor:e,focus:function(){window.focus(),this.display.input.focus()},setOption:function(e,r){var n=this.options,i=n[e];n[e]==r&&"mode"!=e||(n[e]=r,t.hasOwnProperty(e)&&dn(this,t[e])(this,r,i),Te(this,"optionChange",this,e))},getOption:function(e){return this.options[e]},getDoc:function(){return this.doc},addKeyMap:function(e,t){this.state.keyMaps[t?"push":"unshift"](uo(e))},removeKeyMap:function(e){for(var t=this.state.keyMaps,r=0;r<t.length;++r)if(t[r]==e||t[r].name==e)return t.splice(r,1),!0},addOverlay:pn(function(t,r){var n=t.token?t:e.getMode(this.options,t);if(n.startState)throw new Error("Overlays may not be stateful.");m(this.state.overlays,{mode:n,modeSpec:t,opaque:r&&r.opaque,priority:r&&r.priority||0},function(e){return e.priority}),this.state.modeGen++,vn(this)}),removeOverlay:pn(function(e){for(var t=this,r=this.state.overlays,n=0;n<r.length;++n){var i=r[n].modeSpec;if(i==e||"string"==typeof e&&i.name==e)return r.splice(n,1),t.state.modeGen++,void vn(t)}}),indentLine:pn(function(e,t,r){"string"!=typeof t&&"number"!=typeof t&&(t=null==t?this.options.smartIndent?"smart":"prev":t?"add":"subtract"),H(this.doc,e)&&Yo(this,e,t,r)}),indentSelection:pn(function(e){for(var t=this,r=this.doc.sel.ranges,n=-1,i=0;i<r.length;i++){var o=r[i];if(o.empty())o.head.line>n&&(Yo(t,o.head.line,e,!0),n=o.head.line,i==t.doc.sel.primIndex&&jr(t));else{var l=o.from(),s=o.to(),a=Math.max(n,l.line);n=Math.min(t.lastLine(),s.line-(s.ch?0:1))+1;for(var u=a;u<n;++u)Yo(t,u,e);var c=t.doc.sel.ranges;0==l.ch&&r.length==c.length&&c[i].from().ch>0&&gi(t.doc,i,new Ts(l,c[i].to()),Gl)}}}),getTokenAt:function(e,t){return Je(this,e,t)},getLineTokens:function(e,t){return Je(this,E(e),t,!0)},getTokenTypeAt:function(e){e=U(this.doc,e);var t,r=_e(this,M(this.doc,e.line)),n=0,i=(r.length-1)/2,o=e.ch;if(0==o)t=r[2];else for(;;){var l=n+i>>1;if((l?r[2*l-1]:0)>=o)i=l;else{if(!(r[2*l+1]<o)){t=r[2*l+2];break}n=l+1}}var s=t?t.indexOf("overlay "):-1;return s<0?t:0==s?null:t.slice(0,s-1)},getModeAt:function(t){var r=this.doc.mode;return r.innerMode?e.innerMode(r,this.getTokenAt(t).state).mode:r},getHelper:function(e,t){return this.getHelpers(e,t)[0]},getHelpers:function(e,t){var n=this,i=[];if(!r.hasOwnProperty(t))return i;var o=r[t],l=this.getModeAt(e);if("string"==typeof l[t])o[l[t]]&&i.push(o[l[t]]);else if(l[t])for(var s=0;s<l[t].length;s++){var a=o[l[t][s]];a&&i.push(a)}else l.helperType&&o[l.helperType]?i.push(o[l.helperType]):o[l.name]&&i.push(o[l.name]);for(var u=0;u<o._global.length;u++){var c=o._global[u];c.pred(l,n)&&-1==h(i,c.val)&&i.push(c.val)}return i},getStateAfter:function(e,t){var r=this.doc;return e=G(r,null==e?r.first+r.size-1:e),$e(this,e+1,t).state},cursorCoords:function(e,t){var r,n=this.doc.sel.primary();return r=null==e?n.head:"object"==typeof e?U(this.doc,e):e?n.from():n.to(),sr(this,r,t||"page")},charCoords:function(e,t){return lr(this,U(this.doc,e),t||"page")},coordsChar:function(e,t){return e=or(this,e,t||"page"),cr(this,e.left,e.top)},lineAtHeight:function(e,t){return e=or(this,{top:e,left:0},t||"page").top,D(this.doc,e+this.display.viewOffset)},heightAtLine:function(e,t,r){var n,i=!1;if("number"==typeof e){var o=this.doc.first+this.doc.size-1;e<this.doc.first?e=this.doc.first:e>o&&(e=o,i=!0),n=M(this.doc,e)}else n=e;return ir(this,n,{top:0,left:0},t||"page",r||i).top+(i?this.doc.height-ye(n):0)},defaultTextHeight:function(){return mr(this.display)},defaultCharWidth:function(){return yr(this.display)},getViewport:function(){return{from:this.display.viewFrom,to:this.display.viewTo}},addWidget:function(e,t,r,n,i){var o=this.display,l=(e=sr(this,U(this.doc,e))).bottom,s=e.left;if(t.style.position="absolute",t.setAttribute("cm-ignore-events","true"),this.display.input.setUneditable(t),o.sizer.appendChild(t),"over"==n)l=e.top;else if("above"==n||"near"==n){var a=Math.max(o.wrapper.clientHeight,this.doc.height),u=Math.max(o.sizer.clientWidth,o.lineSpace.clientWidth);("above"==n||e.bottom+t.offsetHeight>a)&&e.top>t.offsetHeight?l=e.top-t.offsetHeight:e.bottom+t.offsetHeight<=a&&(l=e.bottom),s+t.offsetWidth>u&&(s=u-t.offsetWidth)}t.style.top=l+"px",t.style.left=t.style.right="","right"==i?(s=o.sizer.clientWidth-t.offsetWidth,t.style.right="0px"):("left"==i?s=0:"middle"==i&&(s=(o.sizer.clientWidth-t.offsetWidth)/2),t.style.left=s+"px"),r&&Ur(this,{left:s,top:l,right:s+t.offsetWidth,bottom:l+t.offsetHeight})},triggerOnKeyDown:pn(Lo),triggerOnKeyPress:pn(Mo),triggerOnKeyUp:To,triggerOnMouseDown:pn(Oo),execCommand:function(e){if(Bs.hasOwnProperty(e))return Bs[e].call(null,this)},triggerElectric:pn(function(e){Zo(this,e)}),findPosH:function(e,t,r,n){var i=this,o=1;t<0&&(o=-1,t=-t);for(var l=U(this.doc,e),s=0;s<t&&!(l=tl(i.doc,l,o,r,n)).hitSide;++s);return l},moveH:pn(function(e,t){var r=this;this.extendSelectionsBy(function(n){return r.display.shift||r.doc.extend||n.empty()?tl(r.doc,n.head,e,t,r.options.rtlMoveVisually):e<0?n.from():n.to()},Vl)}),deleteH:pn(function(e,t){var r=this.doc.sel,n=this.doc;r.somethingSelected()?n.replaceSelection("",null,"+delete"):co(this,function(r){var i=tl(n,r.head,e,t,!1);return e<0?{from:i,to:r.head}:{from:r.head,to:i}})}),findPosV:function(e,t,r,n){var i=this,o=1,l=n;t<0&&(o=-1,t=-t);for(var s=U(this.doc,e),a=0;a<t;++a){var u=sr(i,s,"div");if(null==l?l=u.left:u.left=l,(s=rl(i,u,o,r)).hitSide)break}return s},moveV:pn(function(e,t){var r=this,n=this.doc,i=[],o=!this.display.shift&&!n.extend&&n.sel.somethingSelected();if(n.extendSelectionsBy(function(l){if(o)return e<0?l.from():l.to();var s=sr(r,l.head,"div");null!=l.goalColumn&&(s.left=l.goalColumn),i.push(s.left);var a=rl(r,s,e,t);return"page"==t&&l==n.sel.primary()&&Kr(r,lr(r,a,"div").top-s.top),a},Vl),i.length)for(var l=0;l<n.sel.ranges.length;l++)n.sel.ranges[l].goalColumn=i[l]}),findWordAt:function(e){var t=M(this.doc,e.line).text,r=e.ch,n=e.ch;if(t){var i=this.getHelper(e,"wordChars");"before"!=e.sticky&&n!=t.length||!r?++n:--r;for(var o=t.charAt(r),l=x(o,i)?function(e){return x(e,i)}:/\s/.test(o)?function(e){return/\s/.test(e)}:function(e){return!/\s/.test(e)&&!x(e)};r>0&&l(t.charAt(r-1));)--r;for(;n<t.length&&l(t.charAt(n));)++n}return new Ts(E(e.line,r),E(e.line,n))},toggleOverwrite:function(e){null!=e&&e==this.state.overwrite||((this.state.overwrite=!this.state.overwrite)?s(this.display.cursorDiv,"CodeMirror-overwrite"):Fl(this.display.cursorDiv,"CodeMirror-overwrite"),Te(this,"overwriteToggle",this,this.state.overwrite))},hasFocus:function(){return this.display.input.getField()==l()},isReadOnly:function(){return!(!this.options.readOnly&&!this.doc.cantEdit)},scrollTo:pn(function(e,t){Xr(this,e,t)}),getScrollInfo:function(){var e=this.display.scroller;return{left:e.scrollLeft,top:e.scrollTop,height:e.scrollHeight-zt(this)-this.display.barHeight,width:e.scrollWidth-zt(this)-this.display.barWidth,clientHeight:Bt(this),clientWidth:Rt(this)}},scrollIntoView:pn(function(e,t){null==e?(e={from:this.doc.sel.primary().head,to:null},null==t&&(t=this.options.cursorScrollMargin)):"number"==typeof e?e={from:E(e,0),to:null}:null==e.from&&(e={from:e,to:null}),e.to||(e.to=e.from),e.margin=t||0,null!=e.from.line?Yr(this,e):$r(this,e.from,e.to,e.margin)}),setSize:pn(function(e,t){var r=this,n=function(e){return"number"==typeof e||/^\d+$/.test(String(e))?e+"px":e};null!=e&&(this.display.wrapper.style.width=n(e)),null!=t&&(this.display.wrapper.style.height=n(t)),this.options.lineWrapping&&Jt(this);var i=this.display.viewFrom;this.doc.iter(i,this.display.viewTo,function(e){if(e.widgets)for(var t=0;t<e.widgets.length;t++)if(e.widgets[t].noHScroll){mn(r,i,"widget");break}++i}),this.curOp.forceUpdate=!0,Te(this,"refresh",this)}),operation:function(e){return hn(this,e)},startOperation:function(){return nn(this)},endOperation:function(){return on(this)},refresh:pn(function(){var e=this.display.cachedTextHeight;vn(this),this.curOp.forceUpdate=!0,er(this),Xr(this,this.doc.scrollLeft,this.doc.scrollTop),Wn(this),(null==e||Math.abs(e-mr(this.display))>.5)&&Cr(this),Te(this,"refresh",this)}),swapDoc:pn(function(e){var t=this.doc;return t.cm=null,qn(this,e),er(this),this.display.input.reset(),Xr(this,e.scrollLeft,e.scrollTop),this.curOp.forceScroll=!0,bt(this,"swapDoc",this,t),t}),getInputField:function(){return this.display.input.getField()},getWrapperElement:function(){return this.display.wrapper},getScrollerElement:function(){return this.display.scroller},getGutterElement:function(){return this.display.gutters}},Ae(e),e.registerHelper=function(t,n,i){r.hasOwnProperty(t)||(r[t]=e[t]={_global:[]}),r[t][n]=i},e.registerGlobalHelper=function(t,n,i,o){e.registerHelper(t,n,o),r[t]._global.push({pred:i,val:o})}}(jo);var Js="iter insert remove copy getEditor constructor".split(" ");for(var ea in Ds.prototype)Ds.prototype.hasOwnProperty(ea)&&h(Js,ea)<0&&(jo.prototype[ea]=function(e){return function(){return e.apply(this.doc,arguments)}}(Ds.prototype[ea]));return Ae(Ds),jo.inputStyles={textarea:Qs,contenteditable:Zs},jo.defineMode=function(e){jo.defaults.mode||"null"==e||(jo.defaults.mode=e),Be.apply(this,arguments)},jo.defineMIME=function(e,t){os[e]=t},jo.defineMode("null",function(){return{token:function(e){return e.skipToEnd()}}}),jo.defineMIME("text/plain","null"),jo.defineExtension=function(e,t){jo.prototype[e]=t},jo.defineDocExtension=function(e,t){Ds.prototype[e]=t},jo.fromTextArea=function(e,t){function r(){e.value=a.getValue()}if(t=t?c(t):{},t.value=e.value,!t.tabindex&&e.tabIndex&&(t.tabindex=e.tabIndex),!t.placeholder&&e.placeholder&&(t.placeholder=e.placeholder),null==t.autofocus){var n=l();t.autofocus=n==e||null!=e.getAttribute("autofocus")&&n==document.body}var i;if(e.form&&(Ql(e.form,"submit",r),!t.leaveSubmitMethodAlone)){var o=e.form;i=o.submit;try{var s=o.submit=function(){r(),o.submit=i,o.submit(),o.submit=s}}catch(e){}}t.finishInit=function(t){t.save=r,t.getTextArea=function(){return e},t.toTextArea=function(){t.toTextArea=isNaN,r(),e.parentNode.removeChild(t.getWrapperElement()),e.style.display="",e.form&&(ke(e.form,"submit",r),"function"==typeof e.form.submit&&(e.form.submit=i))}},e.style.display="none";var a=jo(function(t){return e.parentNode.insertBefore(t,e.nextSibling)},t);return a},function(e){e.off=ke,e.on=Ql,e.wheelEventPixels=Pn,e.Doc=Ds,e.splitLines=es,e.countColumn=f,e.findColumn=d,e.isWordChar=w,e.Pass=Bl,e.signal=Te,e.Line=fs,e.changeEnd=Bn,e.scrollbarModel=ws,e.Pos=E,e.cmpPos=P,e.modes=is,e.mimeModes=os,e.resolveMode=Ge,e.getMode=Ue,e.modeExtensions=ls,e.extendMode=Ve,e.copyState=Ke,e.startState=Xe,e.innerMode=je,e.commands=Bs,e.keyMap=Rs,e.keyName=ao,e.isModifierKey=lo,e.lookupKey=oo,e.normalizeKeyMap=io,e.StringStream=ss,e.SharedTextMarker=As,e.TextMarker=Os,e.LineWidget=Ms,e.e_preventDefault=We,e.e_stopPropagation=De,e.e_stop=Fe,e.addClass=s,e.contains=o,e.rmClass=Fl,e.keyNames=Es}(jo),jo.version="5.30.0",jo});
      !function(e){"object"==typeof exports&&"object"==typeof module?e(require("../../lib/codemirror")):"function"==typeof define&&define.amd?define(["../../lib/codemirror"],e):e(CodeMirror)}(function(e){"use strict";function t(e,t,n,r,o,a){this.indented=e,this.column=t,this.type=n,this.info=r,this.align=o,this.prev=a}function n(e,n,r,o){var a=e.indented;return e.context&&"statement"==e.context.type&&"statement"!=r&&(a=e.context.indented),e.context=new t(a,n,r,o,null,e.context)}function r(e){var t=e.context.type;return")"!=t&&"]"!=t&&"}"!=t||(e.indented=e.context.indented),e.context=e.context.prev}function o(e,t,n){return"variable"==t.prevToken||"type"==t.prevToken||(!!/\S(?:[^- ]>|[*\]])\s*$|\*$/.test(e.string.slice(0,n))||(!(!t.typeAtEndOfLine||e.column()!=e.indentation())||void 0))}function a(e){for(;;){if(!e||"top"==e.type)return!0;if("}"==e.type&&"namespace"!=e.prev.info)return!1;e=e.prev}}function i(e){for(var t={},n=e.split(" "),r=0;r<n.length;++r)t[n[r]]=!0;return t}function l(e,t){return"function"==typeof e?e(t):e.propertyIsEnumerable(t)}function s(e,t){if(!t.startOfLine)return!1;for(var n,r=null;n=e.peek();){if("\\"==n&&e.match(/^.$/)){r=s;break}if("/"==n&&e.match(/^\/[\/\*]/,!1))break;e.next()}return t.tokenize=r,"meta"}function c(e,t){return"type"==t.prevToken&&"type"}function u(e){return e.eatWhile(/[\w\.']/),"number"}function d(e,t){if(e.backUp(1),e.match(/(R|u8R|uR|UR|LR)/)){var n=e.match(/"([^\s\\()]{0,16})\(/);return!!n&&(t.cpp11RawStringDelim=n[1],t.tokenize=m,m(e,t))}return e.match(/(u8|u|U|L)/)?!!e.match(/["']/,!1)&&"string":(e.next(),!1)}function f(e){var t=/(\w+)::~?(\w+)$/.exec(e);return t&&t[1]==t[2]}function p(e,t){for(var n;null!=(n=e.next());)if('"'==n&&!e.eat('"')){t.tokenize=null;break}return"string"}function m(e,t){var n=t.cpp11RawStringDelim.replace(/[^\w\s]/g,"\\$&");return e.match(new RegExp(".*?\\)"+n+'"'))?t.tokenize=null:e.skipToEnd(),"string"}function h(t,n){function r(e){if(e)for(var t in e)e.hasOwnProperty(t)&&o.push(t)}"string"==typeof t&&(t=[t]);var o=[];r(n.keywords),r(n.types),r(n.builtin),r(n.atoms),o.length&&(n.helperType=t[0],e.registerHelper("hintWords",t[0],o));for(var a=0;a<t.length;++a)e.defineMIME(t[a],n)}function g(e,t){for(var n=!1;!e.eol();){if(!n&&e.match('"""')){t.tokenize=null;break}n="\\"==e.next()&&!n}return"string"}function y(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!e&&!o&&t.match('"')){a=!0;break}if(e&&t.match('"""')){a=!0;break}r=t.next(),!o&&"$"==r&&t.match("{")&&t.skipTo("}"),o=!o&&"\\"==r&&!e}return!a&&e||(n.tokenize=null),"string"}}function x(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!o&&t.match('"')&&("single"==e||t.match('""'))){a=!0;break}if(!o&&t.match("``")){w=x(e),a=!0;break}r=t.next(),o="single"==e&&!o&&"\\"==r}return a&&(n.tokenize=null),"string"}}e.defineMode("clike",function(i,s){function c(e,t){var n=e.next();if(S[n]){var r=S[n](e,t);if(!1!==r)return r}if('"'==n||"'"==n)return t.tokenize=u(n),t.tokenize(e,t);if(D.test(n))return p=n,null;if(L.test(n)){if(e.backUp(1),e.match(I))return"number";e.next()}if("/"==n){if(e.eat("*"))return t.tokenize=d,d(e,t);if(e.eat("/"))return e.skipToEnd(),"comment"}if(F.test(n)){for(;!e.match(/^\/[\/*]/,!1)&&e.eat(F););return"operator"}if(e.eatWhile(z),P)for(;e.match(P);)e.eatWhile(z);var o=e.current();return l(x,o)?(l(w,o)&&(p="newstatement"),l(v,o)&&(m=!0),"keyword"):l(b,o)?"type":l(k,o)?(l(w,o)&&(p="newstatement"),"builtin"):l(_,o)?"atom":"variable"}function u(e){return function(t,n){for(var r,o=!1,a=!1;null!=(r=t.next());){if(r==e&&!o){a=!0;break}o=!o&&"\\"==r}return(a||!o&&!C)&&(n.tokenize=null),"string"}}function d(e,t){for(var n,r=!1;n=e.next();){if("/"==n&&r){t.tokenize=null;break}r="*"==n}return"comment"}function f(e,t){s.typeFirstDefinitions&&e.eol()&&a(t.context)&&(t.typeAtEndOfLine=o(e,t,e.pos))}var p,m,h=i.indentUnit,g=s.statementIndentUnit||h,y=s.dontAlignCalls,x=s.keywords||{},b=s.types||{},k=s.builtin||{},w=s.blockKeywords||{},v=s.defKeywords||{},_=s.atoms||{},S=s.hooks||{},C=s.multiLineStrings,T=!1!==s.indentStatements,M=!1!==s.indentSwitch,P=s.namespaceSeparator,D=s.isPunctuationChar||/[\[\]{}\(\),;\:\.]/,L=s.numberStart||/[\d\.]/,I=s.number||/^(?:0x[a-f\d]+|0b[01]+|(?:\d+\.?\d*|\.\d+)(?:e[-+]?\d+)?)(u|ll?|l|f)?/i,F=s.isOperatorChar||/[+\-*&%=<>!?|\/]/,z=s.isIdentifierChar||/[\w\$_\xa1-\uffff]/;return{startState:function(e){return{tokenize:null,context:new t((e||0)-h,0,"top",null,!1),indented:0,startOfLine:!0,prevToken:null}},token:function(e,t){var i=t.context;if(e.sol()&&(null==i.align&&(i.align=!1),t.indented=e.indentation(),t.startOfLine=!0),e.eatSpace())return f(e,t),null;p=m=null;var l=(t.tokenize||c)(e,t);if("comment"==l||"meta"==l)return l;if(null==i.align&&(i.align=!0),";"==p||":"==p||","==p&&e.match(/^\s*(?:\/\/.*)?$/,!1))for(;"statement"==t.context.type;)r(t);else if("{"==p)n(t,e.column(),"}");else if("["==p)n(t,e.column(),"]");else if("("==p)n(t,e.column(),")");else if("}"==p){for(;"statement"==i.type;)i=r(t);for("}"==i.type&&(i=r(t));"statement"==i.type;)i=r(t)}else p==i.type?r(t):T&&(("}"==i.type||"top"==i.type)&&";"!=p||"statement"==i.type&&"newstatement"==p)&&n(t,e.column(),"statement",e.current());if("variable"==l&&("def"==t.prevToken||s.typeFirstDefinitions&&o(e,t,e.start)&&a(t.context)&&e.match(/^\s*\(/,!1))&&(l="def"),S.token){var u=S.token(e,t,l);void 0!==u&&(l=u)}return"def"==l&&!1===s.styleDefs&&(l="variable"),t.startOfLine=!1,t.prevToken=m?"def":l||p,f(e,t),l},indent:function(t,n){if(t.tokenize!=c&&null!=t.tokenize||t.typeAtEndOfLine)return e.Pass;var r=t.context,o=n&&n.charAt(0);if("statement"==r.type&&"}"==o&&(r=r.prev),s.dontIndentStatements)for(;"statement"==r.type&&s.dontIndentStatements.test(r.info);)r=r.prev;if(S.indent){var a=S.indent(t,r,n);if("number"==typeof a)return a}var i=o==r.type,l=r.prev&&"switch"==r.prev.info;if(s.allmanIndentation&&/[{(]/.test(o)){for(;"top"!=r.type&&"}"!=r.type;)r=r.prev;return r.indented}return"statement"==r.type?r.indented+("{"==o?0:g):!r.align||y&&")"==r.type?")"!=r.type||i?r.indented+(i?0:h)+(i||!l||/^(?:case|default)\b/.test(n)?0:h):r.indented+g:r.column+(i?0:1)},electricInput:M?/^\s*(?:case .*?:|default:|\{\}?|\})$/:/^\s*[{}]$/,blockCommentStart:"/*",blockCommentEnd:"*/",lineComment:"//",fold:"brace"}});var b="auto if break case register continue return default do sizeof static else struct switch extern typedef union for goto while enum const volatile",k="int long char short double float unsigned signed void size_t ptrdiff_t";h(["text/x-csrc","text/x-c","text/x-chdr"],{name:"clike",keywords:i(b),types:i(k+" bool _Complex _Bool float_t double_t intptr_t intmax_t int8_t int16_t int32_t int64_t uintptr_t uintmax_t uint8_t uint16_t uint32_t uint64_t"),blockKeywords:i("case do else for if switch while struct"),defKeywords:i("struct"),typeFirstDefinitions:!0,atoms:i("null true false"),hooks:{"#":s,"*":c},modeProps:{fold:["brace","include"]}}),h(["text/x-c++src","text/x-c++hdr"],{name:"clike",keywords:i(b+" asm dynamic_cast namespace reinterpret_cast try explicit new static_cast typeid catch operator template typename class friend private this using const_cast inline public throw virtual delete mutable protected alignas alignof constexpr decltype nullptr noexcept thread_local final static_assert override"),types:i(k+" bool wchar_t"),blockKeywords:i("catch class do else finally for if struct switch try while"),defKeywords:i("class namespace struct enum union"),typeFirstDefinitions:!0,atoms:i("true false null"),dontIndentStatements:/^template$/,isIdentifierChar:/[\w\$_~\xa1-\uffff]/,hooks:{"#":s,"*":c,u:d,U:d,L:d,R:d,0:u,1:u,2:u,3:u,4:u,5:u,6:u,7:u,8:u,9:u,token:function(e,t,n){if("variable"==n&&"("==e.peek()&&(";"==t.prevToken||null==t.prevToken||"}"==t.prevToken)&&f(e.current()))return"def"}},namespaceSeparator:"::",modeProps:{fold:["brace","include"]}}),h("text/x-java",{name:"clike",keywords:i("abstract assert break case catch class const continue default do else enum extends final finally float for goto if implements import instanceof interface native new package private protected public return static strictfp super switch synchronized this throw throws transient try volatile while @interface"),types:i("byte short int long float double boolean char void Boolean Byte Character Double Float Integer Long Number Object Short String StringBuffer StringBuilder Void"),blockKeywords:i("catch class do else finally for if switch try while"),defKeywords:i("class interface package enum @interface"),typeFirstDefinitions:!0,atoms:i("true false null"),number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,hooks:{"@":function(e){return!e.match("interface",!1)&&(e.eatWhile(/[\w\$_]/),"meta")}},modeProps:{fold:["brace","import"]}}),h("text/x-csharp",{name:"clike",keywords:i("abstract as async await base break case catch checked class const continue default delegate do else enum event explicit extern finally fixed for foreach goto if implicit in interface internal is lock namespace new operator out override params private protected public readonly ref return sealed sizeof stackalloc static struct switch this throw try typeof unchecked unsafe using virtual void volatile while add alias ascending descending dynamic from get global group into join let orderby partial remove select set value var yield"),types:i("Action Boolean Byte Char DateTime DateTimeOffset Decimal Double Func Guid Int16 Int32 Int64 Object SByte Single String Task TimeSpan UInt16 UInt32 UInt64 bool byte char decimal double short int long object sbyte float string ushort uint ulong"),blockKeywords:i("catch class do else finally for foreach if struct switch try while"),defKeywords:i("class interface namespace struct var"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"@":function(e,t){return e.eat('"')?(t.tokenize=p,p(e,t)):(e.eatWhile(/[\w\$_]/),"meta")}}}),h("text/x-scala",{name:"clike",keywords:i("abstract case catch class def do else extends final finally for forSome if implicit import lazy match new null object override package private protected return sealed super this throw trait try type val var while with yield _ assert assume require print println printf readLine readBoolean readByte readShort readChar readInt readLong readFloat readDouble"),types:i("AnyVal App Application Array BufferedIterator BigDecimal BigInt Char Console Either Enumeration Equiv Error Exception Fractional Function IndexedSeq Int Integral Iterable Iterator List Map Numeric Nil NotNull Option Ordered Ordering PartialFunction PartialOrdering Product Proxy Range Responder Seq Serializable Set Specializable Stream StringBuilder StringContext Symbol Throwable Traversable TraversableOnce Tuple Unit Vector Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),multiLineStrings:!0,blockKeywords:i("catch class enum do else finally for forSome if match switch try while"),defKeywords:i("class enum def object package trait type val var"),atoms:i("true false null"),indentStatements:!1,indentSwitch:!1,isOperatorChar:/[+\-*&%=<>!?|\/#:@]/,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return!!e.match('""')&&(t.tokenize=g,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},"=":function(e,n){var r=n.context;return!("}"!=r.type||!r.align||!e.eat(">"))&&(n.context=new t(r.indented,r.column,r.type,r.info,null,r.prev),"operator")}},modeProps:{closeBrackets:{triples:'"'}}}),h("text/x-kotlin",{name:"clike",keywords:i("package as typealias class interface this super val var fun for is in This throw return break continue object if else while do try when !in !is as? file import where by get set abstract enum open inner override private public internal protected catch finally out final vararg reified dynamic companion constructor init sealed field property receiver param sparam lateinit data inline noinline tailrec external annotation crossinline const operator infix suspend"),types:i("Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),intendSwitch:!1,indentStatements:!1,multiLineStrings:!0,number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,blockKeywords:i("catch class do else finally for if where try while enum"),defKeywords:i("class val var object package interface fun"),atoms:i("true false null this"),hooks:{'"':function(e,t){return t.tokenize=y(e.match('""')),t.tokenize(e,t)}},modeProps:{closeBrackets:{triples:'"'}}}),h(["x-shader/x-vertex","x-shader/x-fragment"],{name:"clike",keywords:i("sampler1D sampler2D sampler3D samplerCube sampler1DShadow sampler2DShadow const attribute uniform varying break continue discard return for while do if else struct in out inout"),types:i("float int bool void vec2 vec3 vec4 ivec2 ivec3 ivec4 bvec2 bvec3 bvec4 mat2 mat3 mat4"),blockKeywords:i("for while do if else struct"),builtin:i("radians degrees sin cos tan asin acos atan pow exp log exp2 sqrt inversesqrt abs sign floor ceil fract mod min max clamp mix step smoothstep length distance dot cross normalize ftransform faceforward reflect refract matrixCompMult lessThan lessThanEqual greaterThan greaterThanEqual equal notEqual any all not texture1D texture1DProj texture1DLod texture1DProjLod texture2D texture2DProj texture2DLod texture2DProjLod texture3D texture3DProj texture3DLod texture3DProjLod textureCube textureCubeLod shadow1D shadow2D shadow1DProj shadow2DProj shadow1DLod shadow2DLod shadow1DProjLod shadow2DProjLod dFdx dFdy fwidth noise1 noise2 noise3 noise4"),atoms:i("true false gl_FragColor gl_SecondaryColor gl_Normal gl_Vertex gl_MultiTexCoord0 gl_MultiTexCoord1 gl_MultiTexCoord2 gl_MultiTexCoord3 gl_MultiTexCoord4 gl_MultiTexCoord5 gl_MultiTexCoord6 gl_MultiTexCoord7 gl_FogCoord gl_PointCoord gl_Position gl_PointSize gl_ClipVertex gl_FrontColor gl_BackColor gl_FrontSecondaryColor gl_BackSecondaryColor gl_TexCoord gl_FogFragCoord gl_FragCoord gl_FrontFacing gl_FragData gl_FragDepth gl_ModelViewMatrix gl_ProjectionMatrix gl_ModelViewProjectionMatrix gl_TextureMatrix gl_NormalMatrix gl_ModelViewMatrixInverse gl_ProjectionMatrixInverse gl_ModelViewProjectionMatrixInverse gl_TexureMatrixTranspose gl_ModelViewMatrixInverseTranspose gl_ProjectionMatrixInverseTranspose gl_ModelViewProjectionMatrixInverseTranspose gl_TextureMatrixInverseTranspose gl_NormalScale gl_DepthRange gl_ClipPlane gl_Point gl_FrontMaterial gl_BackMaterial gl_LightSource gl_LightModel gl_FrontLightModelProduct gl_BackLightModelProduct gl_TextureColor gl_EyePlaneS gl_EyePlaneT gl_EyePlaneR gl_EyePlaneQ gl_FogParameters gl_MaxLights gl_MaxClipPlanes gl_MaxTextureUnits gl_MaxTextureCoords gl_MaxVertexAttribs gl_MaxVertexUniformComponents gl_MaxVaryingFloats gl_MaxVertexTextureImageUnits gl_MaxTextureImageUnits gl_MaxFragmentUniformComponents gl_MaxCombineTextureImageUnits gl_MaxDrawBuffers"),indentSwitch:!1,hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-nesc",{name:"clike",keywords:i(b+"as atomic async call command component components configuration event generic implementation includes interface module new norace nx_struct nx_union post provides signal task uses abstract extends"),types:i(k),blockKeywords:i("case do else for if switch while struct"),atoms:i("null true false"),hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-objectivec",{name:"clike",keywords:i(b+"inline restrict _Bool _Complex _Imaginary BOOL Class bycopy byref id IMP in inout nil oneway out Protocol SEL self super atomic nonatomic retain copy readwrite readonly"),types:i(k),atoms:i("YES NO NULL NILL ON OFF true false"),hooks:{"@":function(e){return e.eatWhile(/[\w\$]/),"keyword"},"#":s,indent:function(e,t,n){if("statement"==t.type&&/^@\w/.test(n))return t.indented}},modeProps:{fold:"brace"}}),h("text/x-squirrel",{name:"clike",keywords:i("base break clone continue const default delete enum extends function in class foreach local resume return this throw typeof yield constructor instanceof static"),types:i(k),blockKeywords:i("case catch class else for foreach if switch try while"),defKeywords:i("function local class"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"#":s},modeProps:{fold:["brace","include"]}});var w=null;h("text/x-ceylon",{name:"clike",keywords:i("abstracts alias assembly assert assign break case catch class continue dynamic else exists extends finally for function given if import in interface is let module new nonempty object of out outer package return satisfies super switch then this throw try value void while"),types:function(e){var t=e.charAt(0);return t===t.toUpperCase()&&t!==t.toLowerCase()},blockKeywords:i("case catch class dynamic else finally for function if interface module new object switch try while"),defKeywords:i("class dynamic function interface module object package value"),builtin:i("abstract actual aliased annotation by default deprecated doc final formal late license native optional sealed see serializable shared suppressWarnings tagged throws variable"),isPunctuationChar:/[\[\]{}\(\),;\:\.`]/,isOperatorChar:/[+\-*&%=<>!?|^~:\/]/,numberStart:/[\d#$]/,number:/^(?:#[\da-fA-F_]+|\$[01_]+|[\d_]+[kMGTPmunpf]?|[\d_]+\.[\d_]+(?:[eE][-+]?\d+|[kMGTPmunpf]|)|)/i,multiLineStrings:!0,typeFirstDefinitions:!0,atoms:i("true false null larger smaller equal empty finished"),indentSwitch:!1,styleDefs:!1,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return t.tokenize=x(e.match('""')?"triple":"single"),t.tokenize(e,t)},"`":function(e,t){return!(!w||!e.match("`"))&&(t.tokenize=w,w=null,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},token:function(e,t,n){if(("variable"==n||"type"==n)&&"."==t.prevToken)return"variable-2"}},modeProps:{fold:["brace","import"],closeBrackets:{triples:'"'}}})});
      // -------------------------------------------------------------------------
//  Part of the CodeChecker project, under the Apache License v2.0 with
//  LLVM Exceptions. See LICENSE for license information.
//  SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
// -------------------------------------------------------------------------

var BugViewer = {
  _files : [],
  _reports : [],
  _lineWidgets : [],
  _navigationMenuItems : [],
  _sourceFileData : null,
  _currentReport : null,
  _lastBugEvent  : null,

  init : function (files, reports) {
    this._files = files;
    this._reports = reports;

    this.initEscapeChars();
  },

  initEscapeChars : function () {
    this.escapeChars = {
      ' ' : 'nbsp',
      '<' : 'lt',
      '>' : 'gt',
      '"' : 'quot',
      '&' : 'amp'
    };

    var regexString = '[';
    for (var key in this.escapeChars) {
      regexString += key;
    }
    regexString += ']';

    this.escapeRegExp = new RegExp( regexString, 'g');
  },

  escapeHTML : function (str) {
    var that = this;

    return str.replace(this.escapeRegExp, function (m) {
      return '&' + that.escapeChars[m] + ';';
    });
  },

  initByUrl : function () {
    if (!this._reports) return;

    var state = {};
    window.location.hash.substr(1).split('&').forEach(function (s) {
      var parts = s.split('=');
      state[parts[0]] = parts[1];
    });

    for (var key in this._reports) {
      var report = this._reports[key];
      if (report.reportHash === state['reportHash']) {
        this.navigate(report);
        return;
      }
    }

    this.navigate(this._reports[0]);
  },

  create : function () {
    this._content = document.getElementById('editor-wrapper');
    this._filepath = document.getElementById('file-path');
    this._checkerName = document.getElementById('checker-name');
    this._reviewStatusWrapper =
      document.getElementById('review-status-wrapper');
    this._reviewStatus = document.getElementById('review-status');
    this._editor = document.getElementById('editor');

    this._codeMirror = CodeMirror(this._editor, {
      mode: 'text/x-c++src',
      matchBrackets : true,
      lineNumbers : true,
      readOnly : true,
      foldGutter : true,
      extraKeys : {},
      viewportMargin : 100
    });

    this._createNavigationMenu();
  },

  navigate : function (report, item) {
    if (!item) {
      var items = this._navigationMenuItems.filter(function (navItem) {
        return navItem.report.reportHash === report.reportHash;
      });

      if (!items.length) return;

      item = items[0].widget;
    }

    this._selectedReport.classList.remove('active');
    this._selectedReport = item;
    this._selectedReport.classList.add('active');
    this.setReport(report);
  },

  _createNavigationMenu : function () {
    var that = this;

    var nav = document.getElementById('report-nav');
    var list = document.createElement('ul');
    this._reports.forEach(function (report) {
      var events = report['events'];
      var lastBugEvent = events[events.length - 1];
      var item = document.createElement('li');

      var severity = document.createElement('i');
      severity.className = 'severity-' + report.severity.toLowerCase();

      item.appendChild(severity);
      item.appendChild(document.createTextNode(lastBugEvent.message));

      item.addEventListener('click', function () {
        that.navigate(report, item);
      })
      list.appendChild(item);
      that._navigationMenuItems.push({ report : report, widget : item });
    });

    if (!this._selectedReport && list.childNodes.length) {
      this._selectedReport = list.childNodes[0];
      this._selectedReport.classList.add('active');
    }

    nav.appendChild(list);
  },

  setReport : function (report) {
    this._currentReport = report;
    var events = report['events'];
    var lastBugEvent = events[events.length - 1];
    this.setCurrentBugEvent(lastBugEvent, events.length - 1);
    this.setCheckerName(report.checkerName);
    this.setReviewStatus(report.reviewStatus);

    window.location.hash = '#reportHash=' + report.reportHash;
  },

  setCurrentBugEvent : function (event, idx) {
    this._currentBugEvent = event;
    this.setSourceFileData(this._files[event.location.file]);
    this.drawBugPath();

    this.jumpTo(event.location.line, 0);
    this.highlightBugEvent(event, idx);
  },

  highlightBugEvent : function (event, idx) {
    this._lineWidgets.forEach(function (widget) {
      var lineIdx = widget.node.getAttribute('idx');
      if (parseInt(lineIdx) === idx) {
        widget.node.classList.add('current');
      }
    });
  },

  setCheckerName : function (checkerName) {
    this._checkerName.innerHTML = checkerName;
  },

  setReviewStatus : function (status) {
    if (status) {
      var className =
        'review-status-' + status.toLowerCase().split(' ').join('-');
      this._reviewStatus.className = "review-status " + className;

      this._reviewStatus.innerHTML = status;
      this._reviewStatusWrapper.style.display = 'block';
    } else {
      this._reviewStatusWrapper.style.display = 'none';
    }
  },

  setSourceFileData : function (file) {
    if (this._sourceFileData && file.id === this._sourceFileData.id) {
      return;
    }

    this._sourceFileData = file;
    this._filepath.innerHTML = file.path;
    this._codeMirror.doc.setValue(file.content);
    this._refresh();
  },

  _refresh : function () {
    var that = this;
    setTimeout(function () {
      var fullHeight = parseInt(that._content.clientHeight);
      var headerHeight = that._filepath.clientHeight;

      that._codeMirror.setSize('auto', fullHeight - headerHeight);
      that._codeMirror.refresh();
    }, 200);
  },

  clearBubbles : function () {
    this._lineWidgets.forEach(function (widget) { widget.clear(); });
    this._lineWidgets = [];
  },

  getMessage : function (event, kind) {
    if (kind === 'macro') {
      var name = 'macro expansion' + (event.name ? ': ' + event.name : '');

      return '<span class="tag macro">' + name + '</span>'
        + this.escapeHTML(event.expansion).replace(/(?:\r\n|\r|\n)/g, '<br>');
    } else if (kind === 'note') {
      return '<span class="tag note">note</span>'
        +  this.escapeHTML(event.message).replace(/(?:\r\n|\r|\n)/g, '<br>');
    }
  },

  addExtraPathEvents : function (events, kind) {
    var that = this;

    if (!events) {
      return;
    }

    events.forEach(function (event) {
      if (event.location.file !== that._currentBugEvent.location.file) {
        return;
      }

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + kind);

      var msg = document.createElement('span');
      msg.innerHTML = that.getMessage(event, kind);
      element.appendChild(msg);

      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  drawBugPath : function () {
    var that = this;

    this.clearBubbles();

    this.addExtraPathEvents(this._currentReport.macros, 'macro');
    this.addExtraPathEvents(this._currentReport.notes, 'note');

    // Processing bug path events.
    var currentEvents = this._currentReport.events;
    currentEvents.forEach(function (event, step) {
      if (event.location.file !== that._currentBugEvent.location.file)
        return;

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';
      var type = step === currentEvents.length - 1 ? 'error' : 'info';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + type);
      element.setAttribute('idx', step);

      var enumeration = document.createElement('span');
      enumeration.setAttribute('class', 'checker-enum ' + type);
      enumeration.innerHTML = step + 1;

      if (currentEvents.length > 1)
        element.appendChild(enumeration);

      var prevBugEvent = step - 1;
      if (step > 0) {
        var prevBug = document.createElement('span');
        prevBug.setAttribute('class', 'arrow left-arrow');
        prevBug.addEventListener('click', function () {
          var event = currentEvents[prevBugEvent];
          that.setCurrentBugEvent(event, prevBugEvent);
        });
        element.appendChild(prevBug);
      }

      var msg = document.createElement('span');
      msg.innerHTML = that.escapeHTML(event.message)
        .replace(/(?:\r\n|\r|\n)/g, '<br>');

      element.appendChild(msg);

      var nextBugEvent = step + 1;
      if (nextBugEvent < currentEvents.length) {
        var nextBug = document.createElement('span');
        nextBug.setAttribute('class', 'arrow right-arrow');
        nextBug.addEventListener('click', function () {
          var event = currentEvents[nextBugEvent];
          that.setCurrentBugEvent(event, nextBugEvent);
        });
        element.appendChild(nextBug);
      }


      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  jumpTo : function (line, column) {
    var that = this;

    setTimeout(function () {
      var selPosPixel
        = that._codeMirror.charCoords({ line : line, ch : column }, 'local');
      var editorSize = {
        width  : that._editor.clientWidth,
        height : that._editor.clientHeight
      };

      that._codeMirror.scrollIntoView({
        top    : selPosPixel.top - 100,
        bottom : selPosPixel.top + editorSize.height - 150,
        left   : selPosPixel.left < editorSize.width - 100
               ? 0
               : selPosPixel.left - 50,
        right  : selPosPixel.left < editorSize.width - 100
               ? 10
               : selPosPixel.left + editorSize.width - 100
      });
    }, 0);
  }
}


      var data = {"files": {"0": {"id": 0, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/APInt.h", "content": "//===-- llvm/ADT/APInt.h - For Arbitrary Precision Integer -----*- C++ -*--===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n///\n/// \\file\n/// This file implements a class to represent arbitrary precision\n/// integral constant values and operations on them.\n///\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_ADT_APINT_H\n#define LLVM_ADT_APINT_H\n\n#include \"llvm/Support/Compiler.h\"\n#include \"llvm/Support/MathExtras.h\"\n#include <cassert>\n#include <climits>\n#include <cstring>\n#include <string>\n\nnamespace llvm {\nclass FoldingSetNodeID;\nclass StringRef;\nclass hash_code;\nclass raw_ostream;\n\ntemplate <typename T> class SmallVectorImpl;\ntemplate <typename T> class ArrayRef;\ntemplate <typename T> class Optional;\ntemplate <typename T> struct DenseMapInfo;\n\nclass APInt;\n\ninline APInt operator-(APInt);\n\n//===----------------------------------------------------------------------===//\n//                              APInt Class\n//===----------------------------------------------------------------------===//\n\n/// Class for arbitrary precision integers.\n///\n/// APInt is a functional replacement for common case unsigned integer type like\n/// \"unsigned\", \"unsigned long\" or \"uint64_t\", but also allows non-byte-width\n/// integer sizes and large integer value types such as 3-bits, 15-bits, or more\n/// than 64-bits of precision. APInt provides a variety of arithmetic operators\n/// and methods to manipulate integer values of any bit-width. It supports both\n/// the typical integer arithmetic and comparison operations as well as bitwise\n/// manipulation.\n///\n/// The class has several invariants worth noting:\n///   * All bit, byte, and word positions are zero-based.\n///   * Once the bit width is set, it doesn't change except by the Truncate,\n///     SignExtend, or ZeroExtend operations.\n///   * All binary operators must be on APInt instances of the same bit width.\n///     Attempting to use these operators on instances with different bit\n///     widths will yield an assertion.\n///   * The value is stored canonically as an unsigned value. For operations\n///     where it makes a difference, there are both signed and unsigned variants\n///     of the operation. For example, sdiv and udiv. However, because the bit\n///     widths must be the same, operations such as Mul and Add produce the same\n///     results regardless of whether the values are interpreted as signed or\n///     not.\n///   * In general, the class tries to follow the style of computation that LLVM\n///     uses in its IR. This simplifies its use for LLVM.\n///\nclass LLVM_NODISCARD APInt {\npublic:\n  typedef uint64_t WordType;\n\n  /// This enum is used to hold the constants we needed for APInt.\n  enum : unsigned {\n    /// Byte size of a word.\n    APINT_WORD_SIZE = sizeof(WordType),\n    /// Bits in a word.\n    APINT_BITS_PER_WORD = APINT_WORD_SIZE * CHAR_BIT\n  };\n\n  enum class Rounding {\n    DOWN,\n    TOWARD_ZERO,\n    UP,\n  };\n\n  static constexpr WordType WORDTYPE_MAX = ~WordType(0);\n\nprivate:\n  /// This union is used to store the integer value. When the\n  /// integer bit-width <= 64, it uses VAL, otherwise it uses pVal.\n  union {\n    uint64_t VAL;   ///< Used to store the <= 64 bits integer value.\n    uint64_t *pVal; ///< Used to store the >64 bits integer value.\n  } U;\n\n  unsigned BitWidth; ///< The number of bits in this APInt.\n\n  friend struct DenseMapInfo<APInt>;\n\n  friend class APSInt;\n\n  /// Fast internal constructor\n  ///\n  /// This constructor is used only internally for speed of construction of\n  /// temporaries. It is unsafe for general use so it is not public.\n  APInt(uint64_t *val, unsigned bits) : BitWidth(bits) {\n    U.pVal = val;\n  }\n\n  /// Determine if this APInt just has one word to store value.\n  ///\n  /// \\returns true if the number of bits <= 64, false otherwise.\n  bool isSingleWord() const { return BitWidth <= APINT_BITS_PER_WORD; }\n\n  /// Determine which word a bit is in.\n  ///\n  /// \\returns the word position for the specified bit position.\n  static unsigned whichWord(unsigned bitPosition) {\n    return bitPosition / APINT_BITS_PER_WORD;\n  }\n\n  /// Determine which bit in a word a bit is in.\n  ///\n  /// \\returns the bit position in a word for the specified bit position\n  /// in the APInt.\n  static unsigned whichBit(unsigned bitPosition) {\n    return bitPosition % APINT_BITS_PER_WORD;\n  }\n\n  /// Get a single bit mask.\n  ///\n  /// \\returns a uint64_t with only bit at \"whichBit(bitPosition)\" set\n  /// This method generates and returns a uint64_t (word) mask for a single\n  /// bit at a specific bit position. This is used to mask the bit in the\n  /// corresponding word.\n  static uint64_t maskBit(unsigned bitPosition) {\n    return 1ULL << whichBit(bitPosition);\n  }\n\n  /// Clear unused high order bits\n  ///\n  /// This method is used internally to clear the top \"N\" bits in the high order\n  /// word that are not used by the APInt. This is needed after the most\n  /// significant word is assigned a value to ensure that those bits are\n  /// zero'd out.\n  APInt &clearUnusedBits() {\n    // Compute how many bits are used in the final word\n    unsigned WordBits = ((BitWidth-1) % APINT_BITS_PER_WORD) + 1;\n\n    // Mask out the high bits.\n    uint64_t mask = WORDTYPE_MAX >> (APINT_BITS_PER_WORD - WordBits);\n    if (isSingleWord())\n      U.VAL &= mask;\n    else\n      U.pVal[getNumWords() - 1] &= mask;\n    return *this;\n  }\n\n  /// Get the word corresponding to a bit position\n  /// \\returns the corresponding word for the specified bit position.\n  uint64_t getWord(unsigned bitPosition) const {\n    return isSingleWord() ? U.VAL : U.pVal[whichWord(bitPosition)];\n  }\n\n  /// Utility method to change the bit width of this APInt to new bit width,\n  /// allocating and/or deallocating as necessary. There is no guarantee on the\n  /// value of any bits upon return. Caller should populate the bits after.\n  void reallocate(unsigned NewBitWidth);\n\n  /// Convert a char array into an APInt\n  ///\n  /// \\param radix 2, 8, 10, 16, or 36\n  /// Converts a string into a number.  The string must be non-empty\n  /// and well-formed as a number of the given base. The bit-width\n  /// must be sufficient to hold the result.\n  ///\n  /// This is used by the constructors that take string arguments.\n  ///\n  /// StringRef::getAsInteger is superficially similar but (1) does\n  /// not assume that the string is well-formed and (2) grows the\n  /// result to hold the input.\n  void fromString(unsigned numBits, StringRef str, uint8_t radix);\n\n  /// An internal division function for dividing APInts.\n  ///\n  /// This is used by the toString method to divide by the radix. It simply\n  /// provides a more convenient form of divide for internal use since KnuthDiv\n  /// has specific constraints on its inputs. If those constraints are not met\n  /// then it provides a simpler form of divide.\n  static void divide(const WordType *LHS, unsigned lhsWords,\n                     const WordType *RHS, unsigned rhsWords, WordType *Quotient,\n                     WordType *Remainder);\n\n  /// out-of-line slow case for inline constructor\n  void initSlowCase(uint64_t val, bool isSigned);\n\n  /// shared code between two array constructors\n  void initFromArray(ArrayRef<uint64_t> array);\n\n  /// out-of-line slow case for inline copy constructor\n  void initSlowCase(const APInt &that);\n\n  /// out-of-line slow case for shl\n  void shlSlowCase(unsigned ShiftAmt);\n\n  /// out-of-line slow case for lshr.\n  void lshrSlowCase(unsigned ShiftAmt);\n\n  /// out-of-line slow case for ashr.\n  void ashrSlowCase(unsigned ShiftAmt);\n\n  /// out-of-line slow case for operator=\n  void AssignSlowCase(const APInt &RHS);\n\n  /// out-of-line slow case for operator==\n  bool EqualSlowCase(const APInt &RHS) const LLVM_READONLY;\n\n  /// out-of-line slow case for countLeadingZeros\n  unsigned countLeadingZerosSlowCase() const LLVM_READONLY;\n\n  /// out-of-line slow case for countLeadingOnes.\n  unsigned countLeadingOnesSlowCase() const LLVM_READONLY;\n\n  /// out-of-line slow case for countTrailingZeros.\n  unsigned countTrailingZerosSlowCase() const LLVM_READONLY;\n\n  /// out-of-line slow case for countTrailingOnes\n  unsigned countTrailingOnesSlowCase() const LLVM_READONLY;\n\n  /// out-of-line slow case for countPopulation\n  unsigned countPopulationSlowCase() const LLVM_READONLY;\n\n  /// out-of-line slow case for intersects.\n  bool intersectsSlowCase(const APInt &RHS) const LLVM_READONLY;\n\n  /// out-of-line slow case for isSubsetOf.\n  bool isSubsetOfSlowCase(const APInt &RHS) const LLVM_READONLY;\n\n  /// out-of-line slow case for setBits.\n  void setBitsSlowCase(unsigned loBit, unsigned hiBit);\n\n  /// out-of-line slow case for flipAllBits.\n  void flipAllBitsSlowCase();\n\n  /// out-of-line slow case for operator&=.\n  void AndAssignSlowCase(const APInt& RHS);\n\n  /// out-of-line slow case for operator|=.\n  void OrAssignSlowCase(const APInt& RHS);\n\n  /// out-of-line slow case for operator^=.\n  void XorAssignSlowCase(const APInt& RHS);\n\n  /// Unsigned comparison. Returns -1, 0, or 1 if this APInt is less than, equal\n  /// to, or greater than RHS.\n  int compare(const APInt &RHS) const LLVM_READONLY;\n\n  /// Signed comparison. Returns -1, 0, or 1 if this APInt is less than, equal\n  /// to, or greater than RHS.\n  int compareSigned(const APInt &RHS) const LLVM_READONLY;\n\npublic:\n  /// \\name Constructors\n  /// @{\n\n  /// Create a new APInt of numBits width, initialized as val.\n  ///\n  /// If isSigned is true then val is treated as if it were a signed value\n  /// (i.e. as an int64_t) and the appropriate sign extension to the bit width\n  /// will be done. Otherwise, no sign extension occurs (high order bits beyond\n  /// the range of val are zero filled).\n  ///\n  /// \\param numBits the bit width of the constructed APInt\n  /// \\param val the initial value of the APInt\n  /// \\param isSigned how to treat signedness of val\n  APInt(unsigned numBits, uint64_t val, bool isSigned = false)\n      : BitWidth(numBits) {\n    assert(BitWidth && \"bitwidth too small\");\n    if (isSingleWord()) {\n      U.VAL = val;\n      clearUnusedBits();\n    } else {\n      initSlowCase(val, isSigned);\n    }\n  }\n\n  /// Construct an APInt of numBits width, initialized as bigVal[].\n  ///\n  /// Note that bigVal.size() can be smaller or larger than the corresponding\n  /// bit width but any extraneous bits will be dropped.\n  ///\n  /// \\param numBits the bit width of the constructed APInt\n  /// \\param bigVal a sequence of words to form the initial value of the APInt\n  APInt(unsigned numBits, ArrayRef<uint64_t> bigVal);\n\n  /// Equivalent to APInt(numBits, ArrayRef<uint64_t>(bigVal, numWords)), but\n  /// deprecated because this constructor is prone to ambiguity with the\n  /// APInt(unsigned, uint64_t, bool) constructor.\n  ///\n  /// If this overload is ever deleted, care should be taken to prevent calls\n  /// from being incorrectly captured by the APInt(unsigned, uint64_t, bool)\n  /// constructor.\n  APInt(unsigned numBits, unsigned numWords, const uint64_t bigVal[]);\n\n  /// Construct an APInt from a string representation.\n  ///\n  /// This constructor interprets the string \\p str in the given radix. The\n  /// interpretation stops when the first character that is not suitable for the\n  /// radix is encountered, or the end of the string. Acceptable radix values\n  /// are 2, 8, 10, 16, and 36. It is an error for the value implied by the\n  /// string to require more bits than numBits.\n  ///\n  /// \\param numBits the bit width of the constructed APInt\n  /// \\param str the string to be interpreted\n  /// \\param radix the radix to use for the conversion\n  APInt(unsigned numBits, StringRef str, uint8_t radix);\n\n  /// Simply makes *this a copy of that.\n  /// Copy Constructor.\n  APInt(const APInt &that) : BitWidth(that.BitWidth) {\n    if (isSingleWord())\n      U.VAL = that.U.VAL;\n    else\n      initSlowCase(that);\n  }\n\n  /// Move Constructor.\n  APInt(APInt &&that) : BitWidth(that.BitWidth) {\n    memcpy(&U, &that.U, sizeof(U));\n    that.BitWidth = 0;\n  }\n\n  /// Destructor.\n  ~APInt() {\n    if (needsCleanup())\n      delete[] U.pVal;\n  }\n\n  /// Default constructor that creates an uninteresting APInt\n  /// representing a 1-bit zero value.\n  ///\n  /// This is useful for object deserialization (pair this with the static\n  ///  method Read).\n  explicit APInt() : BitWidth(1) { U.VAL = 0; }\n\n  /// Returns whether this instance allocated memory.\n  bool needsCleanup() const { return !isSingleWord(); }\n\n  /// Used to insert APInt objects, or objects that contain APInt objects, into\n  ///  FoldingSets.\n  void Profile(FoldingSetNodeID &id) const;\n\n  /// @}\n  /// \\name Value Tests\n  /// @{\n\n  /// Determine sign of this APInt.\n  ///\n  /// This tests the high bit of this APInt to determine if it is set.\n  ///\n  /// \\returns true if this APInt is negative, false otherwise\n  bool isNegative() const { return (*this)[BitWidth - 1]; }\n\n  /// Determine if this APInt Value is non-negative (>= 0)\n  ///\n  /// This tests the high bit of the APInt to determine if it is unset.\n  bool isNonNegative() const { return !isNegative(); }\n\n  /// Determine if sign bit of this APInt is set.\n  ///\n  /// This tests the high bit of this APInt to determine if it is set.\n  ///\n  /// \\returns true if this APInt has its sign bit set, false otherwise.\n  bool isSignBitSet() const { return (*this)[BitWidth-1]; }\n\n  /// Determine if sign bit of this APInt is clear.\n  ///\n  /// This tests the high bit of this APInt to determine if it is clear.\n  ///\n  /// \\returns true if this APInt has its sign bit clear, false otherwise.\n  bool isSignBitClear() const { return !isSignBitSet(); }\n\n  /// Determine if this APInt Value is positive.\n  ///\n  /// This tests if the value of this APInt is positive (> 0). Note\n  /// that 0 is not a positive value.\n  ///\n  /// \\returns true if this APInt is positive.\n  bool isStrictlyPositive() const { return isNonNegative() && !isNullValue(); }\n\n  /// Determine if this APInt Value is non-positive (<= 0).\n  ///\n  /// \\returns true if this APInt is non-positive.\n  bool isNonPositive() const { return !isStrictlyPositive(); }\n\n  /// Determine if all bits are set\n  ///\n  /// This checks to see if the value has all bits of the APInt are set or not.\n  bool isAllOnesValue() const {\n    if (isSingleWord())\n      return U.VAL == WORDTYPE_MAX >> (APINT_BITS_PER_WORD - BitWidth);\n    return countTrailingOnesSlowCase() == BitWidth;\n  }\n\n  /// Determine if all bits are clear\n  ///\n  /// This checks to see if the value has all bits of the APInt are clear or\n  /// not.\n  bool isNullValue() const { return !*this; }\n\n  /// Determine if this is a value of 1.\n  ///\n  /// This checks to see if the value of this APInt is one.\n  bool isOneValue() const {\n    if (isSingleWord())\n      return U.VAL == 1;\n    return countLeadingZerosSlowCase() == BitWidth - 1;\n  }\n\n  /// Determine if this is the largest unsigned value.\n  ///\n  /// This checks to see if the value of this APInt is the maximum unsigned\n  /// value for the APInt's bit width.\n  bool isMaxValue() const { return isAllOnesValue(); }\n\n  /// Determine if this is the largest signed value.\n  ///\n  /// This checks to see if the value of this APInt is the maximum signed\n  /// value for the APInt's bit width.\n  bool isMaxSignedValue() const {\n    if (isSingleWord())\n      return U.VAL == ((WordType(1) << (BitWidth - 1)) - 1);\n    return !isNegative() && countTrailingOnesSlowCase() == BitWidth - 1;\n  }\n\n  /// Determine if this is the smallest unsigned value.\n  ///\n  /// This checks to see if the value of this APInt is the minimum unsigned\n  /// value for the APInt's bit width.\n  bool isMinValue() const { return isNullValue(); }\n\n  /// Determine if this is the smallest signed value.\n  ///\n  /// This checks to see if the value of this APInt is the minimum signed\n  /// value for the APInt's bit width.\n  bool isMinSignedValue() const {\n    if (isSingleWord())\n      return U.VAL == (WordType(1) << (BitWidth - 1));\n    return isNegative() && countTrailingZerosSlowCase() == BitWidth - 1;\n  }\n\n  /// Check if this APInt has an N-bits unsigned integer value.\n  bool isIntN(unsigned N) const {\n    assert(N && \"N == 0 ???\");\n    return getActiveBits() <= N;\n  }\n\n  /// Check if this APInt has an N-bits signed integer value.\n  bool isSignedIntN(unsigned N) const {\n    assert(N && \"N == 0 ???\");\n    return getMinSignedBits() <= N;\n  }\n\n  /// Check if this APInt's value is a power of two greater than zero.\n  ///\n  /// \\returns true if the argument APInt value is a power of two > 0.\n  bool isPowerOf2() const {\n    if (isSingleWord())\n      return isPowerOf2_64(U.VAL);\n    return countPopulationSlowCase() == 1;\n  }\n\n  /// Check if the APInt's value is returned by getSignMask.\n  ///\n  /// \\returns true if this is the value returned by getSignMask.\n  bool isSignMask() const { return isMinSignedValue(); }\n\n  /// Convert APInt to a boolean value.\n  ///\n  /// This converts the APInt to a boolean value as a test against zero.\n  bool getBoolValue() const { return !!*this; }\n\n  /// If this value is smaller than the specified limit, return it, otherwise\n  /// return the limit value.  This causes the value to saturate to the limit.\n  uint64_t getLimitedValue(uint64_t Limit = UINT64_MAX) const {\n    return ugt(Limit) ? Limit : getZExtValue();\n  }\n\n  /// Check if the APInt consists of a repeated bit pattern.\n  ///\n  /// e.g. 0x01010101 satisfies isSplat(8).\n  /// \\param SplatSizeInBits The size of the pattern in bits. Must divide bit\n  /// width without remainder.\n  bool isSplat(unsigned SplatSizeInBits) const;\n\n  /// \\returns true if this APInt value is a sequence of \\param numBits ones\n  /// starting at the least significant bit with the remainder zero.\n  bool isMask(unsigned numBits) const {\n    assert(numBits != 0 && \"numBits must be non-zero\");\n    assert(numBits <= BitWidth && \"numBits out of range\");\n    if (isSingleWord())\n      return U.VAL == (WORDTYPE_MAX >> (APINT_BITS_PER_WORD - numBits));\n    unsigned Ones = countTrailingOnesSlowCase();\n    return (numBits == Ones) &&\n           ((Ones + countLeadingZerosSlowCase()) == BitWidth);\n  }\n\n  /// \\returns true if this APInt is a non-empty sequence of ones starting at\n  /// the least significant bit with the remainder zero.\n  /// Ex. isMask(0x0000FFFFU) == true.\n  bool isMask() const {\n    if (isSingleWord())\n      return isMask_64(U.VAL);\n    unsigned Ones = countTrailingOnesSlowCase();\n    return (Ones > 0) && ((Ones + countLeadingZerosSlowCase()) == BitWidth);\n  }\n\n  /// Return true if this APInt value contains a sequence of ones with\n  /// the remainder zero.\n  bool isShiftedMask() const {\n    if (isSingleWord())\n      return isShiftedMask_64(U.VAL);\n    unsigned Ones = countPopulationSlowCase();\n    unsigned LeadZ = countLeadingZerosSlowCase();\n    return (Ones + LeadZ + countTrailingZeros()) == BitWidth;\n  }\n\n  /// @}\n  /// \\name Value Generators\n  /// @{\n\n  /// Gets maximum unsigned value of APInt for specific bit width.\n  static APInt getMaxValue(unsigned numBits) {\n    return getAllOnesValue(numBits);\n  }\n\n  /// Gets maximum signed value of APInt for a specific bit width.\n  static APInt getSignedMaxValue(unsigned numBits) {\n    APInt API = getAllOnesValue(numBits);\n    API.clearBit(numBits - 1);\n    return API;\n  }\n\n  /// Gets minimum unsigned value of APInt for a specific bit width.\n  static APInt getMinValue(unsigned numBits) { return APInt(numBits, 0); }\n\n  /// Gets minimum signed value of APInt for a specific bit width.\n  static APInt getSignedMinValue(unsigned numBits) {\n    APInt API(numBits, 0);\n    API.setBit(numBits - 1);\n    return API;\n  }\n\n  /// Get the SignMask for a specific bit width.\n  ///\n  /// This is just a wrapper function of getSignedMinValue(), and it helps code\n  /// readability when we want to get a SignMask.\n  static APInt getSignMask(unsigned BitWidth) {\n    return getSignedMinValue(BitWidth);\n  }\n\n  /// Get the all-ones value.\n  ///\n  /// \\returns the all-ones value for an APInt of the specified bit-width.\n  static APInt getAllOnesValue(unsigned numBits) {\n    return APInt(numBits, WORDTYPE_MAX, true);\n  }\n\n  /// Get the '0' value.\n  ///\n  /// \\returns the '0' value for an APInt of the specified bit-width.\n  static APInt getNullValue(unsigned numBits) { return APInt(numBits, 0); }\n\n  /// Compute an APInt containing numBits highbits from this APInt.\n  ///\n  /// Get an APInt with the same BitWidth as this APInt, just zero mask\n  /// the low bits and right shift to the least significant bit.\n  ///\n  /// \\returns the high \"numBits\" bits of this APInt.\n  APInt getHiBits(unsigned numBits) const;\n\n  /// Compute an APInt containing numBits lowbits from this APInt.\n  ///\n  /// Get an APInt with the same BitWidth as this APInt, just zero mask\n  /// the high bits.\n  ///\n  /// \\returns the low \"numBits\" bits of this APInt.\n  APInt getLoBits(unsigned numBits) const;\n\n  /// Return an APInt with exactly one bit set in the result.\n  static APInt getOneBitSet(unsigned numBits, unsigned BitNo) {\n    APInt Res(numBits, 0);\n    Res.setBit(BitNo);\n    return Res;\n  }\n\n  /// Get a value with a block of bits set.\n  ///\n  /// Constructs an APInt value that has a contiguous range of bits set. The\n  /// bits from loBit (inclusive) to hiBit (exclusive) will be set. All other\n  /// bits will be zero. For example, with parameters(32, 0, 16) you would get\n  /// 0x0000FFFF. Please call getBitsSetWithWrap if \\p loBit may be greater than\n  /// \\p hiBit.\n  ///\n  /// \\param numBits the intended bit width of the result\n  /// \\param loBit the index of the lowest bit set.\n  /// \\param hiBit the index of the highest bit set.\n  ///\n  /// \\returns An APInt value with the requested bits set.\n  static APInt getBitsSet(unsigned numBits, unsigned loBit, unsigned hiBit) {\n    assert(loBit <= hiBit && \"loBit greater than hiBit\");\n    APInt Res(numBits, 0);\n    Res.setBits(loBit, hiBit);\n    return Res;\n  }\n\n  /// Wrap version of getBitsSet.\n  /// If \\p hiBit is bigger than \\p loBit, this is same with getBitsSet.\n  /// If \\p hiBit is not bigger than \\p loBit, the set bits \"wrap\". For example,\n  /// with parameters (32, 28, 4), you would get 0xF000000F.\n  /// If \\p hiBit is equal to \\p loBit, you would get a result with all bits\n  /// set.\n  static APInt getBitsSetWithWrap(unsigned numBits, unsigned loBit,\n                                  unsigned hiBit) {\n    APInt Res(numBits, 0);\n    Res.setBitsWithWrap(loBit, hiBit);\n    return Res;\n  }\n\n  /// Get a value with upper bits starting at loBit set.\n  ///\n  /// Constructs an APInt value that has a contiguous range of bits set. The\n  /// bits from loBit (inclusive) to numBits (exclusive) will be set. All other\n  /// bits will be zero. For example, with parameters(32, 12) you would get\n  /// 0xFFFFF000.\n  ///\n  /// \\param numBits the intended bit width of the result\n  /// \\param loBit the index of the lowest bit to set.\n  ///\n  /// \\returns An APInt value with the requested bits set.\n  static APInt getBitsSetFrom(unsigned numBits, unsigned loBit) {\n    APInt Res(numBits, 0);\n    Res.setBitsFrom(loBit);\n    return Res;\n  }\n\n  /// Get a value with high bits set\n  ///\n  /// Constructs an APInt value that has the top hiBitsSet bits set.\n  ///\n  /// \\param numBits the bitwidth of the result\n  /// \\param hiBitsSet the number of high-order bits set in the result.\n  static APInt getHighBitsSet(unsigned numBits, unsigned hiBitsSet) {\n    APInt Res(numBits, 0);\n    Res.setHighBits(hiBitsSet);\n    return Res;\n  }\n\n  /// Get a value with low bits set\n  ///\n  /// Constructs an APInt value that has the bottom loBitsSet bits set.\n  ///\n  /// \\param numBits the bitwidth of the result\n  /// \\param loBitsSet the number of low-order bits set in the result.\n  static APInt getLowBitsSet(unsigned numBits, unsigned loBitsSet) {\n    APInt Res(numBits, 0);\n    Res.setLowBits(loBitsSet);\n    return Res;\n  }\n\n  /// Return a value containing V broadcasted over NewLen bits.\n  static APInt getSplat(unsigned NewLen, const APInt &V);\n\n  /// Determine if two APInts have the same value, after zero-extending\n  /// one of them (if needed!) to ensure that the bit-widths match.\n  static bool isSameValue(const APInt &I1, const APInt &I2) {\n    if (I1.getBitWidth() == I2.getBitWidth())\n      return I1 == I2;\n\n    if (I1.getBitWidth() > I2.getBitWidth())\n      return I1 == I2.zext(I1.getBitWidth());\n\n    return I1.zext(I2.getBitWidth()) == I2;\n  }\n\n  /// Overload to compute a hash_code for an APInt value.\n  friend hash_code hash_value(const APInt &Arg);\n\n  /// This function returns a pointer to the internal storage of the APInt.\n  /// This is useful for writing out the APInt in binary form without any\n  /// conversions.\n  const uint64_t *getRawData() const {\n    if (isSingleWord())\n      return &U.VAL;\n    return &U.pVal[0];\n  }\n\n  /// @}\n  /// \\name Unary Operators\n  /// @{\n\n  /// Postfix increment operator.\n  ///\n  /// Increments *this by 1.\n  ///\n  /// \\returns a new APInt value representing the original value of *this.\n  const APInt operator++(int) {\n    APInt API(*this);\n    ++(*this);\n    return API;\n  }\n\n  /// Prefix increment operator.\n  ///\n  /// \\returns *this incremented by one\n  APInt &operator++();\n\n  /// Postfix decrement operator.\n  ///\n  /// Decrements *this by 1.\n  ///\n  /// \\returns a new APInt value representing the original value of *this.\n  const APInt operator--(int) {\n    APInt API(*this);\n    --(*this);\n    return API;\n  }\n\n  /// Prefix decrement operator.\n  ///\n  /// \\returns *this decremented by one.\n  APInt &operator--();\n\n  /// Logical negation operator.\n  ///\n  /// Performs logical negation operation on this APInt.\n  ///\n  /// \\returns true if *this is zero, false otherwise.\n  bool operator!() const {\n    if (isSingleWord())\n      return U.VAL == 0;\n    return countLeadingZerosSlowCase() == BitWidth;\n  }\n\n  /// @}\n  /// \\name Assignment Operators\n  /// @{\n\n  /// Copy assignment operator.\n  ///\n  /// \\returns *this after assignment of RHS.\n  APInt &operator=(const APInt &RHS) {\n    // If the bitwidths are the same, we can avoid mucking with memory\n    if (isSingleWord() && RHS.isSingleWord()) {\n      U.VAL = RHS.U.VAL;\n      BitWidth = RHS.BitWidth;\n      return clearUnusedBits();\n    }\n\n    AssignSlowCase(RHS);\n    return *this;\n  }\n\n  /// Move assignment operator.\n  APInt &operator=(APInt &&that) {\n#ifdef EXPENSIVE_CHECKS\n    // Some std::shuffle implementations still do self-assignment.\n    if (this == &that)\n      return *this;\n#endif\n    assert(this != &that && \"Self-move not supported\");\n    if (!isSingleWord())\n      delete[] U.pVal;\n\n    // Use memcpy so that type based alias analysis sees both VAL and pVal\n    // as modified.\n    memcpy(&U, &that.U, sizeof(U));\n\n    BitWidth = that.BitWidth;\n    that.BitWidth = 0;\n\n    return *this;\n  }\n\n  /// Assignment operator.\n  ///\n  /// The RHS value is assigned to *this. If the significant bits in RHS exceed\n  /// the bit width, the excess bits are truncated. If the bit width is larger\n  /// than 64, the value is zero filled in the unspecified high order bits.\n  ///\n  /// \\returns *this after assignment of RHS value.\n  APInt &operator=(uint64_t RHS) {\n    if (isSingleWord()) {\n      U.VAL = RHS;\n      return clearUnusedBits();\n    }\n    U.pVal[0] = RHS;\n    memset(U.pVal + 1, 0, (getNumWords() - 1) * APINT_WORD_SIZE);\n    return *this;\n  }\n\n  /// Bitwise AND assignment operator.\n  ///\n  /// Performs a bitwise AND operation on this APInt and RHS. The result is\n  /// assigned to *this.\n  ///\n  /// \\returns *this after ANDing with RHS.\n  APInt &operator&=(const APInt &RHS) {\n    assert(BitWidth == RHS.BitWidth && \"Bit widths must be the same\");\n    if (isSingleWord())\n      U.VAL &= RHS.U.VAL;\n    else\n      AndAssignSlowCase(RHS);\n    return *this;\n  }\n\n  /// Bitwise AND assignment operator.\n  ///\n  /// Performs a bitwise AND operation on this APInt and RHS. RHS is\n  /// logically zero-extended or truncated to match the bit-width of\n  /// the LHS.\n  APInt &operator&=(uint64_t RHS) {\n    if (isSingleWord()) {\n      U.VAL &= RHS;\n      return *this;\n    }\n    U.pVal[0] &= RHS;\n    memset(U.pVal+1, 0, (getNumWords() - 1) * APINT_WORD_SIZE);\n    return *this;\n  }\n\n  /// Bitwise OR assignment operator.\n  ///\n  /// Performs a bitwise OR operation on this APInt and RHS. The result is\n  /// assigned *this;\n  ///\n  /// \\returns *this after ORing with RHS.\n  APInt &operator|=(const APInt &RHS) {\n    assert(BitWidth == RHS.BitWidth && \"Bit widths must be the same\");\n    if (isSingleWord())\n      U.VAL |= RHS.U.VAL;\n    else\n      OrAssignSlowCase(RHS);\n    return *this;\n  }\n\n  /// Bitwise OR assignment operator.\n  ///\n  /// Performs a bitwise OR operation on this APInt and RHS. RHS is\n  /// logically zero-extended or truncated to match the bit-width of\n  /// the LHS.\n  APInt &operator|=(uint64_t RHS) {\n    if (isSingleWord()) {\n      U.VAL |= RHS;\n      return clearUnusedBits();\n    }\n    U.pVal[0] |= RHS;\n    return *this;\n  }\n\n  /// Bitwise XOR assignment operator.\n  ///\n  /// Performs a bitwise XOR operation on this APInt and RHS. The result is\n  /// assigned to *this.\n  ///\n  /// \\returns *this after XORing with RHS.\n  APInt &operator^=(const APInt &RHS) {\n    assert(BitWidth == RHS.BitWidth && \"Bit widths must be the same\");\n    if (isSingleWord())\n      U.VAL ^= RHS.U.VAL;\n    else\n      XorAssignSlowCase(RHS);\n    return *this;\n  }\n\n  /// Bitwise XOR assignment operator.\n  ///\n  /// Performs a bitwise XOR operation on this APInt and RHS. RHS is\n  /// logically zero-extended or truncated to match the bit-width of\n  /// the LHS.\n  APInt &operator^=(uint64_t RHS) {\n    if (isSingleWord()) {\n      U.VAL ^= RHS;\n      return clearUnusedBits();\n    }\n    U.pVal[0] ^= RHS;\n    return *this;\n  }\n\n  /// Multiplication assignment operator.\n  ///\n  /// Multiplies this APInt by RHS and assigns the result to *this.\n  ///\n  /// \\returns *this\n  APInt &operator*=(const APInt &RHS);\n  APInt &operator*=(uint64_t RHS);\n\n  /// Addition assignment operator.\n  ///\n  /// Adds RHS to *this and assigns the result to *this.\n  ///\n  /// \\returns *this\n  APInt &operator+=(const APInt &RHS);\n  APInt &operator+=(uint64_t RHS);\n\n  /// Subtraction assignment operator.\n  ///\n  /// Subtracts RHS from *this and assigns the result to *this.\n  ///\n  /// \\returns *this\n  APInt &operator-=(const APInt &RHS);\n  APInt &operator-=(uint64_t RHS);\n\n  /// Left-shift assignment function.\n  ///\n  /// Shifts *this left by shiftAmt and assigns the result to *this.\n  ///\n  /// \\returns *this after shifting left by ShiftAmt\n  APInt &operator<<=(unsigned ShiftAmt) {\n    assert(ShiftAmt <= BitWidth && \"Invalid shift amount\");\n    if (isSingleWord()) {\n      if (ShiftAmt == BitWidth)\n        U.VAL = 0;\n      else\n        U.VAL <<= ShiftAmt;\n      return clearUnusedBits();\n    }\n    shlSlowCase(ShiftAmt);\n    return *this;\n  }\n\n  /// Left-shift assignment function.\n  ///\n  /// Shifts *this left by shiftAmt and assigns the result to *this.\n  ///\n  /// \\returns *this after shifting left by ShiftAmt\n  APInt &operator<<=(const APInt &ShiftAmt);\n\n  /// @}\n  /// \\name Binary Operators\n  /// @{\n\n  /// Multiplication operator.\n  ///\n  /// Multiplies this APInt by RHS and returns the result.\n  APInt operator*(const APInt &RHS) const;\n\n  /// Left logical shift operator.\n  ///\n  /// Shifts this APInt left by \\p Bits and returns the result.\n  APInt operator<<(unsigned Bits) const { return shl(Bits); }\n\n  /// Left logical shift operator.\n  ///\n  /// Shifts this APInt left by \\p Bits and returns the result.\n  APInt operator<<(const APInt &Bits) const { return shl(Bits); }\n\n  /// Arithmetic right-shift function.\n  ///\n  /// Arithmetic right-shift this APInt by shiftAmt.\n  APInt ashr(unsigned ShiftAmt) const {\n    APInt R(*this);\n    R.ashrInPlace(ShiftAmt);\n    return R;\n  }\n\n  /// Arithmetic right-shift this APInt by ShiftAmt in place.\n  void ashrInPlace(unsigned ShiftAmt) {\n    assert(ShiftAmt <= BitWidth && \"Invalid shift amount\");\n    if (isSingleWord()) {\n      int64_t SExtVAL = SignExtend64(U.VAL, BitWidth);\n      if (ShiftAmt == BitWidth)\n        U.VAL = SExtVAL >> (APINT_BITS_PER_WORD - 1); // Fill with sign bit.\n      else\n        U.VAL = SExtVAL >> ShiftAmt;\n      clearUnusedBits();\n      return;\n    }\n    ashrSlowCase(ShiftAmt);\n  }\n\n  /// Logical right-shift function.\n  ///\n  /// Logical right-shift this APInt by shiftAmt.\n  APInt lshr(unsigned shiftAmt) const {\n    APInt R(*this);\n    R.lshrInPlace(shiftAmt);\n    return R;\n  }\n\n  /// Logical right-shift this APInt by ShiftAmt in place.\n  void lshrInPlace(unsigned ShiftAmt) {\n    assert(ShiftAmt <= BitWidth && \"Invalid shift amount\");\n    if (isSingleWord()) {\n      if (ShiftAmt == BitWidth)\n        U.VAL = 0;\n      else\n        U.VAL >>= ShiftAmt;\n      return;\n    }\n    lshrSlowCase(ShiftAmt);\n  }\n\n  /// Left-shift function.\n  ///\n  /// Left-shift this APInt by shiftAmt.\n  APInt shl(unsigned shiftAmt) const {\n    APInt R(*this);\n    R <<= shiftAmt;\n    return R;\n  }\n\n  /// Rotate left by rotateAmt.\n  APInt rotl(unsigned rotateAmt) const;\n\n  /// Rotate right by rotateAmt.\n  APInt rotr(unsigned rotateAmt) const;\n\n  /// Arithmetic right-shift function.\n  ///\n  /// Arithmetic right-shift this APInt by shiftAmt.\n  APInt ashr(const APInt &ShiftAmt) const {\n    APInt R(*this);\n    R.ashrInPlace(ShiftAmt);\n    return R;\n  }\n\n  /// Arithmetic right-shift this APInt by shiftAmt in place.\n  void ashrInPlace(const APInt &shiftAmt);\n\n  /// Logical right-shift function.\n  ///\n  /// Logical right-shift this APInt by shiftAmt.\n  APInt lshr(const APInt &ShiftAmt) const {\n    APInt R(*this);\n    R.lshrInPlace(ShiftAmt);\n    return R;\n  }\n\n  /// Logical right-shift this APInt by ShiftAmt in place.\n  void lshrInPlace(const APInt &ShiftAmt);\n\n  /// Left-shift function.\n  ///\n  /// Left-shift this APInt by shiftAmt.\n  APInt shl(const APInt &ShiftAmt) const {\n    APInt R(*this);\n    R <<= ShiftAmt;\n    return R;\n  }\n\n  /// Rotate left by rotateAmt.\n  APInt rotl(const APInt &rotateAmt) const;\n\n  /// Rotate right by rotateAmt.\n  APInt rotr(const APInt &rotateAmt) const;\n\n  /// Unsigned division operation.\n  ///\n  /// Perform an unsigned divide operation on this APInt by RHS. Both this and\n  /// RHS are treated as unsigned quantities for purposes of this division.\n  ///\n  /// \\returns a new APInt value containing the division result, rounded towards\n  /// zero.\n  APInt udiv(const APInt &RHS) const;\n  APInt udiv(uint64_t RHS) const;\n\n  /// Signed division function for APInt.\n  ///\n  /// Signed divide this APInt by APInt RHS.\n  ///\n  /// The result is rounded towards zero.\n  APInt sdiv(const APInt &RHS) const;\n  APInt sdiv(int64_t RHS) const;\n\n  /// Unsigned remainder operation.\n  ///\n  /// Perform an unsigned remainder operation on this APInt with RHS being the\n  /// divisor. Both this and RHS are treated as unsigned quantities for purposes\n  /// of this operation. Note that this is a true remainder operation and not a\n  /// modulo operation because the sign follows the sign of the dividend which\n  /// is *this.\n  ///\n  /// \\returns a new APInt value containing the remainder result\n  APInt urem(const APInt &RHS) const;\n  uint64_t urem(uint64_t RHS) const;\n\n  /// Function for signed remainder operation.\n  ///\n  /// Signed remainder operation on APInt.\n  APInt srem(const APInt &RHS) const;\n  int64_t srem(int64_t RHS) const;\n\n  /// Dual division/remainder interface.\n  ///\n  /// Sometimes it is convenient to divide two APInt values and obtain both the\n  /// quotient and remainder. This function does both operations in the same\n  /// computation making it a little more efficient. The pair of input arguments\n  /// may overlap with the pair of output arguments. It is safe to call\n  /// udivrem(X, Y, X, Y), for example.\n  static void udivrem(const APInt &LHS, const APInt &RHS, APInt &Quotient,\n                      APInt &Remainder);\n  static void udivrem(const APInt &LHS, uint64_t RHS, APInt &Quotient,\n                      uint64_t &Remainder);\n\n  static void sdivrem(const APInt &LHS, const APInt &RHS, APInt &Quotient,\n                      APInt &Remainder);\n  static void sdivrem(const APInt &LHS, int64_t RHS, APInt &Quotient,\n                      int64_t &Remainder);\n\n  // Operations that return overflow indicators.\n  APInt sadd_ov(const APInt &RHS, bool &Overflow) const;\n  APInt uadd_ov(const APInt &RHS, bool &Overflow) const;\n  APInt ssub_ov(const APInt &RHS, bool &Overflow) const;\n  APInt usub_ov(const APInt &RHS, bool &Overflow) const;\n  APInt sdiv_ov(const APInt &RHS, bool &Overflow) const;\n  APInt smul_ov(const APInt &RHS, bool &Overflow) const;\n  APInt umul_ov(const APInt &RHS, bool &Overflow) const;\n  APInt sshl_ov(const APInt &Amt, bool &Overflow) const;\n  APInt ushl_ov(const APInt &Amt, bool &Overflow) const;\n\n  // Operations that saturate\n  APInt sadd_sat(const APInt &RHS) const;\n  APInt uadd_sat(const APInt &RHS) const;\n  APInt ssub_sat(const APInt &RHS) const;\n  APInt usub_sat(const APInt &RHS) const;\n  APInt smul_sat(const APInt &RHS) const;\n  APInt umul_sat(const APInt &RHS) const;\n  APInt sshl_sat(const APInt &RHS) const;\n  APInt ushl_sat(const APInt &RHS) const;\n\n  /// Array-indexing support.\n  ///\n  /// \\returns the bit value at bitPosition\n  bool operator[](unsigned bitPosition) const {\n    assert(bitPosition < getBitWidth() && \"Bit position out of bounds!\");\n    return (maskBit(bitPosition) & getWord(bitPosition)) != 0;\n  }\n\n  /// @}\n  /// \\name Comparison Operators\n  /// @{\n\n  /// Equality operator.\n  ///\n  /// Compares this APInt with RHS for the validity of the equality\n  /// relationship.\n  bool operator==(const APInt &RHS) const {\n    assert(BitWidth == RHS.BitWidth && \"Comparison requires equal bit widths\");\n    if (isSingleWord())\n      return U.VAL == RHS.U.VAL;\n    return EqualSlowCase(RHS);\n  }\n\n  /// Equality operator.\n  ///\n  /// Compares this APInt with a uint64_t for the validity of the equality\n  /// relationship.\n  ///\n  /// \\returns true if *this == Val\n  bool operator==(uint64_t Val) const {\n    return (isSingleWord() || getActiveBits() <= 64) && getZExtValue() == Val;\n  }\n\n  /// Equality comparison.\n  ///\n  /// Compares this APInt with RHS for the validity of the equality\n  /// relationship.\n  ///\n  /// \\returns true if *this == Val\n  bool eq(const APInt &RHS) const { return (*this) == RHS; }\n\n  /// Inequality operator.\n  ///\n  /// Compares this APInt with RHS for the validity of the inequality\n  /// relationship.\n  ///\n  /// \\returns true if *this != Val\n  bool operator!=(const APInt &RHS) const { return !((*this) == RHS); }\n\n  /// Inequality operator.\n  ///\n  /// Compares this APInt with a uint64_t for the validity of the inequality\n  /// relationship.\n  ///\n  /// \\returns true if *this != Val\n  bool operator!=(uint64_t Val) const { return !((*this) == Val); }\n\n  /// Inequality comparison\n  ///\n  /// Compares this APInt with RHS for the validity of the inequality\n  /// relationship.\n  ///\n  /// \\returns true if *this != Val\n  bool ne(const APInt &RHS) const { return !((*this) == RHS); }\n\n  /// Unsigned less than comparison\n  ///\n  /// Regards both *this and RHS as unsigned quantities and compares them for\n  /// the validity of the less-than relationship.\n  ///\n  /// \\returns true if *this < RHS when both are considered unsigned.\n  bool ult(const APInt &RHS) const { return compare(RHS) < 0; }\n\n  /// Unsigned less than comparison\n  ///\n  /// Regards both *this as an unsigned quantity and compares it with RHS for\n  /// the validity of the less-than relationship.\n  ///\n  /// \\returns true if *this < RHS when considered unsigned.\n  bool ult(uint64_t RHS) const {\n    // Only need to check active bits if not a single word.\n    return (isSingleWord() || getActiveBits() <= 64) && getZExtValue() < RHS;\n  }\n\n  /// Signed less than comparison\n  ///\n  /// Regards both *this and RHS as signed quantities and compares them for\n  /// validity of the less-than relationship.\n  ///\n  /// \\returns true if *this < RHS when both are considered signed.\n  bool slt(const APInt &RHS) const { return compareSigned(RHS) < 0; }\n\n  /// Signed less than comparison\n  ///\n  /// Regards both *this as a signed quantity and compares it with RHS for\n  /// the validity of the less-than relationship.\n  ///\n  /// \\returns true if *this < RHS when considered signed.\n  bool slt(int64_t RHS) const {\n    return (!isSingleWord() && getMinSignedBits() > 64) ? isNegative()\n                                                        : getSExtValue() < RHS;\n  }\n\n  /// Unsigned less or equal comparison\n  ///\n  /// Regards both *this and RHS as unsigned quantities and compares them for\n  /// validity of the less-or-equal relationship.\n  ///\n  /// \\returns true if *this <= RHS when both are considered unsigned.\n  bool ule(const APInt &RHS) const { return compare(RHS) <= 0; }\n\n  /// Unsigned less or equal comparison\n  ///\n  /// Regards both *this as an unsigned quantity and compares it with RHS for\n  /// the validity of the less-or-equal relationship.\n  ///\n  /// \\returns true if *this <= RHS when considered unsigned.\n  bool ule(uint64_t RHS) const { return !ugt(RHS); }\n\n  /// Signed less or equal comparison\n  ///\n  /// Regards both *this and RHS as signed quantities and compares them for\n  /// validity of the less-or-equal relationship.\n  ///\n  /// \\returns true if *this <= RHS when both are considered signed.\n  bool sle(const APInt &RHS) const { return compareSigned(RHS) <= 0; }\n\n  /// Signed less or equal comparison\n  ///\n  /// Regards both *this as a signed quantity and compares it with RHS for the\n  /// validity of the less-or-equal relationship.\n  ///\n  /// \\returns true if *this <= RHS when considered signed.\n  bool sle(uint64_t RHS) const { return !sgt(RHS); }\n\n  /// Unsigned greater than comparison\n  ///\n  /// Regards both *this and RHS as unsigned quantities and compares them for\n  /// the validity of the greater-than relationship.\n  ///\n  /// \\returns true if *this > RHS when both are considered unsigned.\n  bool ugt(const APInt &RHS) const { return !ule(RHS); }\n\n  /// Unsigned greater than comparison\n  ///\n  /// Regards both *this as an unsigned quantity and compares it with RHS for\n  /// the validity of the greater-than relationship.\n  ///\n  /// \\returns true if *this > RHS when considered unsigned.\n  bool ugt(uint64_t RHS) const {\n    // Only need to check active bits if not a single word.\n    return (!isSingleWord() && getActiveBits() > 64) || getZExtValue() > RHS;\n  }\n\n  /// Signed greater than comparison\n  ///\n  /// Regards both *this and RHS as signed quantities and compares them for the\n  /// validity of the greater-than relationship.\n  ///\n  /// \\returns true if *this > RHS when both are considered signed.\n  bool sgt(const APInt &RHS) const { return !sle(RHS); }\n\n  /// Signed greater than comparison\n  ///\n  /// Regards both *this as a signed quantity and compares it with RHS for\n  /// the validity of the greater-than relationship.\n  ///\n  /// \\returns true if *this > RHS when considered signed.\n  bool sgt(int64_t RHS) const {\n    return (!isSingleWord() && getMinSignedBits() > 64) ? !isNegative()\n                                                        : getSExtValue() > RHS;\n  }\n\n  /// Unsigned greater or equal comparison\n  ///\n  /// Regards both *this and RHS as unsigned quantities and compares them for\n  /// validity of the greater-or-equal relationship.\n  ///\n  /// \\returns true if *this >= RHS when both are considered unsigned.\n  bool uge(const APInt &RHS) const { return !ult(RHS); }\n\n  /// Unsigned greater or equal comparison\n  ///\n  /// Regards both *this as an unsigned quantity and compares it with RHS for\n  /// the validity of the greater-or-equal relationship.\n  ///\n  /// \\returns true if *this >= RHS when considered unsigned.\n  bool uge(uint64_t RHS) const { return !ult(RHS); }\n\n  /// Signed greater or equal comparison\n  ///\n  /// Regards both *this and RHS as signed quantities and compares them for\n  /// validity of the greater-or-equal relationship.\n  ///\n  /// \\returns true if *this >= RHS when both are considered signed.\n  bool sge(const APInt &RHS) const { return !slt(RHS); }\n\n  /// Signed greater or equal comparison\n  ///\n  /// Regards both *this as a signed quantity and compares it with RHS for\n  /// the validity of the greater-or-equal relationship.\n  ///\n  /// \\returns true if *this >= RHS when considered signed.\n  bool sge(int64_t RHS) const { return !slt(RHS); }\n\n  /// This operation tests if there are any pairs of corresponding bits\n  /// between this APInt and RHS that are both set.\n  bool intersects(const APInt &RHS) const {\n    assert(BitWidth == RHS.BitWidth && \"Bit widths must be the same\");\n    if (isSingleWord())\n      return (U.VAL & RHS.U.VAL) != 0;\n    return intersectsSlowCase(RHS);\n  }\n\n  /// This operation checks that all bits set in this APInt are also set in RHS.\n  bool isSubsetOf(const APInt &RHS) const {\n    assert(BitWidth == RHS.BitWidth && \"Bit widths must be the same\");\n    if (isSingleWord())\n      return (U.VAL & ~RHS.U.VAL) == 0;\n    return isSubsetOfSlowCase(RHS);\n  }\n\n  /// @}\n  /// \\name Resizing Operators\n  /// @{\n\n  /// Truncate to new width.\n  ///\n  /// Truncate the APInt to a specified width. It is an error to specify a width\n  /// that is greater than or equal to the current width.\n  APInt trunc(unsigned width) const;\n\n  /// Truncate to new width with unsigned saturation.\n  ///\n  /// If the APInt, treated as unsigned integer, can be losslessly truncated to\n  /// the new bitwidth, then return truncated APInt. Else, return max value.\n  APInt truncUSat(unsigned width) const;\n\n  /// Truncate to new width with signed saturation.\n  ///\n  /// If this APInt, treated as signed integer, can be losslessly truncated to\n  /// the new bitwidth, then return truncated APInt. Else, return either\n  /// signed min value if the APInt was negative, or signed max value.\n  APInt truncSSat(unsigned width) const;\n\n  /// Sign extend to a new width.\n  ///\n  /// This operation sign extends the APInt to a new width. If the high order\n  /// bit is set, the fill on the left will be done with 1 bits, otherwise zero.\n  /// It is an error to specify a width that is less than or equal to the\n  /// current width.\n  APInt sext(unsigned width) const;\n\n  /// Zero extend to a new width.\n  ///\n  /// This operation zero extends the APInt to a new width. The high order bits\n  /// are filled with 0 bits.  It is an error to specify a width that is less\n  /// than or equal to the current width.\n  APInt zext(unsigned width) const;\n\n  /// Sign extend or truncate to width\n  ///\n  /// Make this APInt have the bit width given by \\p width. The value is sign\n  /// extended, truncated, or left alone to make it that width.\n  APInt sextOrTrunc(unsigned width) const;\n\n  /// Zero extend or truncate to width\n  ///\n  /// Make this APInt have the bit width given by \\p width. The value is zero\n  /// extended, truncated, or left alone to make it that width.\n  APInt zextOrTrunc(unsigned width) const;\n\n  /// Truncate to width\n  ///\n  /// Make this APInt have the bit width given by \\p width. The value is\n  /// truncated or left alone to make it that width.\n  APInt truncOrSelf(unsigned width) const;\n\n  /// Sign extend or truncate to width\n  ///\n  /// Make this APInt have the bit width given by \\p width. The value is sign\n  /// extended, or left alone to make it that width.\n  APInt sextOrSelf(unsigned width) const;\n\n  /// Zero extend or truncate to width\n  ///\n  /// Make this APInt have the bit width given by \\p width. The value is zero\n  /// extended, or left alone to make it that width.\n  APInt zextOrSelf(unsigned width) const;\n\n  /// @}\n  /// \\name Bit Manipulation Operators\n  /// @{\n\n  /// Set every bit to 1.\n  void setAllBits() {\n    if (isSingleWord())\n      U.VAL = WORDTYPE_MAX;\n    else\n      // Set all the bits in all the words.\n      memset(U.pVal, -1, getNumWords() * APINT_WORD_SIZE);\n    // Clear the unused ones\n    clearUnusedBits();\n  }\n\n  /// Set a given bit to 1.\n  ///\n  /// Set the given bit to 1 whose position is given as \"bitPosition\".\n  void setBit(unsigned BitPosition) {\n    assert(BitPosition < BitWidth && \"BitPosition out of range\");\n    WordType Mask = maskBit(BitPosition);\n    if (isSingleWord())\n      U.VAL |= Mask;\n    else\n      U.pVal[whichWord(BitPosition)] |= Mask;\n  }\n\n  /// Set the sign bit to 1.\n  void setSignBit() {\n    setBit(BitWidth - 1);\n  }\n\n  /// Set a given bit to a given value.\n  void setBitVal(unsigned BitPosition, bool BitValue) {\n    if (BitValue)\n      setBit(BitPosition);\n    else\n      clearBit(BitPosition);\n  }\n\n  /// Set the bits from loBit (inclusive) to hiBit (exclusive) to 1.\n  /// This function handles \"wrap\" case when \\p loBit >= \\p hiBit, and calls\n  /// setBits when \\p loBit < \\p hiBit.\n  /// For \\p loBit == \\p hiBit wrap case, set every bit to 1.\n  void setBitsWithWrap(unsigned loBit, unsigned hiBit) {\n    assert(hiBit <= BitWidth && \"hiBit out of range\");\n    assert(loBit <= BitWidth && \"loBit out of range\");\n    if (loBit < hiBit) {\n      setBits(loBit, hiBit);\n      return;\n    }\n    setLowBits(hiBit);\n    setHighBits(BitWidth - loBit);\n  }\n\n  /// Set the bits from loBit (inclusive) to hiBit (exclusive) to 1.\n  /// This function handles case when \\p loBit <= \\p hiBit.\n  void setBits(unsigned loBit, unsigned hiBit) {\n    assert(hiBit <= BitWidth && \"hiBit out of range\");\n    assert(loBit <= BitWidth && \"loBit out of range\");\n    assert(loBit <= hiBit && \"loBit greater than hiBit\");\n    if (loBit == hiBit)\n      return;\n    if (loBit < APINT_BITS_PER_WORD && hiBit <= APINT_BITS_PER_WORD) {\n      uint64_t mask = WORDTYPE_MAX >> (APINT_BITS_PER_WORD - (hiBit - loBit));\n      mask <<= loBit;\n      if (isSingleWord())\n        U.VAL |= mask;\n      else\n        U.pVal[0] |= mask;\n    } else {\n      setBitsSlowCase(loBit, hiBit);\n    }\n  }\n\n  /// Set the top bits starting from loBit.\n  void setBitsFrom(unsigned loBit) {\n    return setBits(loBit, BitWidth);\n  }\n\n  /// Set the bottom loBits bits.\n  void setLowBits(unsigned loBits) {\n    return setBits(0, loBits);\n  }\n\n  /// Set the top hiBits bits.\n  void setHighBits(unsigned hiBits) {\n    return setBits(BitWidth - hiBits, BitWidth);\n  }\n\n  /// Set every bit to 0.\n  void clearAllBits() {\n    if (isSingleWord())\n      U.VAL = 0;\n    else\n      memset(U.pVal, 0, getNumWords() * APINT_WORD_SIZE);\n  }\n\n  /// Set a given bit to 0.\n  ///\n  /// Set the given bit to 0 whose position is given as \"bitPosition\".\n  void clearBit(unsigned BitPosition) {\n    assert(BitPosition < BitWidth && \"BitPosition out of range\");\n    WordType Mask = ~maskBit(BitPosition);\n    if (isSingleWord())\n      U.VAL &= Mask;\n    else\n      U.pVal[whichWord(BitPosition)] &= Mask;\n  }\n\n  /// Set bottom loBits bits to 0.\n  void clearLowBits(unsigned loBits) {\n    assert(loBits <= BitWidth && \"More bits than bitwidth\");\n    APInt Keep = getHighBitsSet(BitWidth, BitWidth - loBits);\n    *this &= Keep;\n  }\n\n  /// Set the sign bit to 0.\n  void clearSignBit() {\n    clearBit(BitWidth - 1);\n  }\n\n  /// Toggle every bit to its opposite value.\n  void flipAllBits() {\n    if (isSingleWord()) {\n      U.VAL ^= WORDTYPE_MAX;\n      clearUnusedBits();\n    } else {\n      flipAllBitsSlowCase();\n    }\n  }\n\n  /// Toggles a given bit to its opposite value.\n  ///\n  /// Toggle a given bit to its opposite value whose position is given\n  /// as \"bitPosition\".\n  void flipBit(unsigned bitPosition);\n\n  /// Negate this APInt in place.\n  void negate() {\n    flipAllBits();\n    ++(*this);\n  }\n\n  /// Insert the bits from a smaller APInt starting at bitPosition.\n  void insertBits(const APInt &SubBits, unsigned bitPosition);\n  void insertBits(uint64_t SubBits, unsigned bitPosition, unsigned numBits);\n\n  /// Return an APInt with the extracted bits [bitPosition,bitPosition+numBits).\n  APInt extractBits(unsigned numBits, unsigned bitPosition) const;\n  uint64_t extractBitsAsZExtValue(unsigned numBits, unsigned bitPosition) const;\n\n  /// @}\n  /// \\name Value Characterization Functions\n  /// @{\n\n  /// Return the number of bits in the APInt.\n  unsigned getBitWidth() const { return BitWidth; }\n\n  /// Get the number of words.\n  ///\n  /// Here one word's bitwidth equals to that of uint64_t.\n  ///\n  /// \\returns the number of words to hold the integer value of this APInt.\n  unsigned getNumWords() const { return getNumWords(BitWidth); }\n\n  /// Get the number of words.\n  ///\n  /// *NOTE* Here one word's bitwidth equals to that of uint64_t.\n  ///\n  /// \\returns the number of words to hold the integer value with a given bit\n  /// width.\n  static unsigned getNumWords(unsigned BitWidth) {\n    return ((uint64_t)BitWidth + APINT_BITS_PER_WORD - 1) / APINT_BITS_PER_WORD;\n  }\n\n  /// Compute the number of active bits in the value\n  ///\n  /// This function returns the number of active bits which is defined as the\n  /// bit width minus the number of leading zeros. This is used in several\n  /// computations to see how \"wide\" the value is.\n  unsigned getActiveBits() const { return BitWidth - countLeadingZeros(); }\n\n  /// Compute the number of active words in the value of this APInt.\n  ///\n  /// This is used in conjunction with getActiveData to extract the raw value of\n  /// the APInt.\n  unsigned getActiveWords() const {\n    unsigned numActiveBits = getActiveBits();\n    return numActiveBits ? whichWord(numActiveBits - 1) + 1 : 1;\n  }\n\n  /// Get the minimum bit size for this signed APInt\n  ///\n  /// Computes the minimum bit width for this APInt while considering it to be a\n  /// signed (and probably negative) value. If the value is not negative, this\n  /// function returns the same value as getActiveBits()+1. Otherwise, it\n  /// returns the smallest bit width that will retain the negative value. For\n  /// example, -1 can be written as 0b1 or 0xFFFFFFFFFF. 0b1 is shorter and so\n  /// for -1, this function will always return 1.\n  unsigned getMinSignedBits() const { return BitWidth - getNumSignBits() + 1; }\n\n  /// Get zero extended value\n  ///\n  /// This method attempts to return the value of this APInt as a zero extended\n  /// uint64_t. The bitwidth must be <= 64 or the value must fit within a\n  /// uint64_t. Otherwise an assertion will result.\n  uint64_t getZExtValue() const {\n    if (isSingleWord())\n      return U.VAL;\n    assert(getActiveBits() <= 64 && \"Too many bits for uint64_t\");\n    return U.pVal[0];\n  }\n\n  /// Get sign extended value\n  ///\n  /// This method attempts to return the value of this APInt as a sign extended\n  /// int64_t. The bit width must be <= 64 or the value must fit within an\n  /// int64_t. Otherwise an assertion will result.\n  int64_t getSExtValue() const {\n    if (isSingleWord())\n      return SignExtend64(U.VAL, BitWidth);\n    assert(getMinSignedBits() <= 64 && \"Too many bits for int64_t\");\n    return int64_t(U.pVal[0]);\n  }\n\n  /// Get bits required for string value.\n  ///\n  /// This method determines how many bits are required to hold the APInt\n  /// equivalent of the string given by \\p str.\n  static unsigned getBitsNeeded(StringRef str, uint8_t radix);\n\n  /// The APInt version of the countLeadingZeros functions in\n  ///   MathExtras.h.\n  ///\n  /// It counts the number of zeros from the most significant bit to the first\n  /// one bit.\n  ///\n  /// \\returns BitWidth if the value is zero, otherwise returns the number of\n  ///   zeros from the most significant bit to the first one bits.\n  unsigned countLeadingZeros() const {\n    if (isSingleWord()) {\n      unsigned unusedBits = APINT_BITS_PER_WORD - BitWidth;\n      return llvm::countLeadingZeros(U.VAL) - unusedBits;\n    }\n    return countLeadingZerosSlowCase();\n  }\n\n  /// Count the number of leading one bits.\n  ///\n  /// This function is an APInt version of the countLeadingOnes\n  /// functions in MathExtras.h. It counts the number of ones from the most\n  /// significant bit to the first zero bit.\n  ///\n  /// \\returns 0 if the high order bit is not set, otherwise returns the number\n  /// of 1 bits from the most significant to the least\n  unsigned countLeadingOnes() const {\n    if (isSingleWord())\n      return llvm::countLeadingOnes(U.VAL << (APINT_BITS_PER_WORD - BitWidth));\n    return countLeadingOnesSlowCase();\n  }\n\n  /// Computes the number of leading bits of this APInt that are equal to its\n  /// sign bit.\n  unsigned getNumSignBits() const {\n    return isNegative() ? countLeadingOnes() : countLeadingZeros();\n  }\n\n  /// Count the number of trailing zero bits.\n  ///\n  /// This function is an APInt version of the countTrailingZeros\n  /// functions in MathExtras.h. It counts the number of zeros from the least\n  /// significant bit to the first set bit.\n  ///\n  /// \\returns BitWidth if the value is zero, otherwise returns the number of\n  /// zeros from the least significant bit to the first one bit.\n  unsigned countTrailingZeros() const {\n    if (isSingleWord())\n      return std::min(unsigned(llvm::countTrailingZeros(U.VAL)), BitWidth);\n    return countTrailingZerosSlowCase();\n  }\n\n  /// Count the number of trailing one bits.\n  ///\n  /// This function is an APInt version of the countTrailingOnes\n  /// functions in MathExtras.h. It counts the number of ones from the least\n  /// significant bit to the first zero bit.\n  ///\n  /// \\returns BitWidth if the value is all ones, otherwise returns the number\n  /// of ones from the least significant bit to the first zero bit.\n  unsigned countTrailingOnes() const {\n    if (isSingleWord())\n      return llvm::countTrailingOnes(U.VAL);\n    return countTrailingOnesSlowCase();\n  }\n\n  /// Count the number of bits set.\n  ///\n  /// This function is an APInt version of the countPopulation functions\n  /// in MathExtras.h. It counts the number of 1 bits in the APInt value.\n  ///\n  /// \\returns 0 if the value is zero, otherwise returns the number of set bits.\n  unsigned countPopulation() const {\n    if (isSingleWord())\n      return llvm::countPopulation(U.VAL);\n    return countPopulationSlowCase();\n  }\n\n  /// @}\n  /// \\name Conversion Functions\n  /// @{\n  void print(raw_ostream &OS, bool isSigned) const;\n\n  /// Converts an APInt to a string and append it to Str.  Str is commonly a\n  /// SmallString.\n  void toString(SmallVectorImpl<char> &Str, unsigned Radix, bool Signed,\n                bool formatAsCLiteral = false) const;\n\n  /// Considers the APInt to be unsigned and converts it into a string in the\n  /// radix given. The radix can be 2, 8, 10 16, or 36.\n  void toStringUnsigned(SmallVectorImpl<char> &Str, unsigned Radix = 10) const {\n    toString(Str, Radix, false, false);\n  }\n\n  /// Considers the APInt to be signed and converts it into a string in the\n  /// radix given. The radix can be 2, 8, 10, 16, or 36.\n  void toStringSigned(SmallVectorImpl<char> &Str, unsigned Radix = 10) const {\n    toString(Str, Radix, true, false);\n  }\n\n  /// Return the APInt as a std::string.\n  ///\n  /// Note that this is an inefficient method.  It is better to pass in a\n  /// SmallVector/SmallString to the methods above to avoid thrashing the heap\n  /// for the string.\n  std::string toString(unsigned Radix, bool Signed) const;\n\n  /// \\returns a byte-swapped representation of this APInt Value.\n  APInt byteSwap() const;\n\n  /// \\returns the value with the bit representation reversed of this APInt\n  /// Value.\n  APInt reverseBits() const;\n\n  /// Converts this APInt to a double value.\n  double roundToDouble(bool isSigned) const;\n\n  /// Converts this unsigned APInt to a double value.\n  double roundToDouble() const { return roundToDouble(false); }\n\n  /// Converts this signed APInt to a double value.\n  double signedRoundToDouble() const { return roundToDouble(true); }\n\n  /// Converts APInt bits to a double\n  ///\n  /// The conversion does not do a translation from integer to double, it just\n  /// re-interprets the bits as a double. Note that it is valid to do this on\n  /// any bit width. Exactly 64 bits will be translated.\n  double bitsToDouble() const {\n    return BitsToDouble(getWord(0));\n  }\n\n  /// Converts APInt bits to a float\n  ///\n  /// The conversion does not do a translation from integer to float, it just\n  /// re-interprets the bits as a float. Note that it is valid to do this on\n  /// any bit width. Exactly 32 bits will be translated.\n  float bitsToFloat() const {\n    return BitsToFloat(static_cast<uint32_t>(getWord(0)));\n  }\n\n  /// Converts a double to APInt bits.\n  ///\n  /// The conversion does not do a translation from double to integer, it just\n  /// re-interprets the bits of the double.\n  static APInt doubleToBits(double V) {\n    return APInt(sizeof(double) * CHAR_BIT, DoubleToBits(V));\n  }\n\n  /// Converts a float to APInt bits.\n  ///\n  /// The conversion does not do a translation from float to integer, it just\n  /// re-interprets the bits of the float.\n  static APInt floatToBits(float V) {\n    return APInt(sizeof(float) * CHAR_BIT, FloatToBits(V));\n  }\n\n  /// @}\n  /// \\name Mathematics Operations\n  /// @{\n\n  /// \\returns the floor log base 2 of this APInt.\n  unsigned logBase2() const { return getActiveBits() -  1; }\n\n  /// \\returns the ceil log base 2 of this APInt.\n  unsigned ceilLogBase2() const {\n    APInt temp(*this);\n    --temp;\n    return temp.getActiveBits();\n  }\n\n  /// \\returns the nearest log base 2 of this APInt. Ties round up.\n  ///\n  /// NOTE: When we have a BitWidth of 1, we define:\n  ///\n  ///   log2(0) = UINT32_MAX\n  ///   log2(1) = 0\n  ///\n  /// to get around any mathematical concerns resulting from\n  /// referencing 2 in a space where 2 does no exist.\n  unsigned nearestLogBase2() const {\n    // Special case when we have a bitwidth of 1. If VAL is 1, then we\n    // get 0. If VAL is 0, we get WORDTYPE_MAX which gets truncated to\n    // UINT32_MAX.\n    if (BitWidth == 1)\n      return U.VAL - 1;\n\n    // Handle the zero case.\n    if (isNullValue())\n      return UINT32_MAX;\n\n    // The non-zero case is handled by computing:\n    //\n    //   nearestLogBase2(x) = logBase2(x) + x[logBase2(x)-1].\n    //\n    // where x[i] is referring to the value of the ith bit of x.\n    unsigned lg = logBase2();\n    return lg + unsigned((*this)[lg - 1]);\n  }\n\n  /// \\returns the log base 2 of this APInt if its an exact power of two, -1\n  /// otherwise\n  int32_t exactLogBase2() const {\n    if (!isPowerOf2())\n      return -1;\n    return logBase2();\n  }\n\n  /// Compute the square root\n  APInt sqrt() const;\n\n  /// Get the absolute value;\n  ///\n  /// If *this is < 0 then return -(*this), otherwise *this;\n  APInt abs() const {\n    if (isNegative())\n      return -(*this);\n    return *this;\n  }\n\n  /// \\returns the multiplicative inverse for a given modulo.\n  APInt multiplicativeInverse(const APInt &modulo) const;\n\n  /// @}\n  /// \\name Support for division by constant\n  /// @{\n\n  /// Calculate the magic number for signed division by a constant.\n  struct ms;\n  ms magic() const;\n\n  /// Calculate the magic number for unsigned division by a constant.\n  struct mu;\n  mu magicu(unsigned LeadingZeros = 0) const;\n\n  /// @}\n  /// \\name Building-block Operations for APInt and APFloat\n  /// @{\n\n  // These building block operations operate on a representation of arbitrary\n  // precision, two's-complement, bignum integer values. They should be\n  // sufficient to implement APInt and APFloat bignum requirements. Inputs are\n  // generally a pointer to the base of an array of integer parts, representing\n  // an unsigned bignum, and a count of how many parts there are.\n\n  /// Sets the least significant part of a bignum to the input value, and zeroes\n  /// out higher parts.\n  static void tcSet(WordType *, WordType, unsigned);\n\n  /// Assign one bignum to another.\n  static void tcAssign(WordType *, const WordType *, unsigned);\n\n  /// Returns true if a bignum is zero, false otherwise.\n  static bool tcIsZero(const WordType *, unsigned);\n\n  /// Extract the given bit of a bignum; returns 0 or 1.  Zero-based.\n  static int tcExtractBit(const WordType *, unsigned bit);\n\n  /// Copy the bit vector of width srcBITS from SRC, starting at bit srcLSB, to\n  /// DST, of dstCOUNT parts, such that the bit srcLSB becomes the least\n  /// significant bit of DST.  All high bits above srcBITS in DST are\n  /// zero-filled.\n  static void tcExtract(WordType *, unsigned dstCount,\n                        const WordType *, unsigned srcBits,\n                        unsigned srcLSB);\n\n  /// Set the given bit of a bignum.  Zero-based.\n  static void tcSetBit(WordType *, unsigned bit);\n\n  /// Clear the given bit of a bignum.  Zero-based.\n  static void tcClearBit(WordType *, unsigned bit);\n\n  /// Returns the bit number of the least or most significant set bit of a\n  /// number.  If the input number has no bits set -1U is returned.\n  static unsigned tcLSB(const WordType *, unsigned n);\n  static unsigned tcMSB(const WordType *parts, unsigned n);\n\n  /// Negate a bignum in-place.\n  static void tcNegate(WordType *, unsigned);\n\n  /// DST += RHS + CARRY where CARRY is zero or one.  Returns the carry flag.\n  static WordType tcAdd(WordType *, const WordType *,\n                        WordType carry, unsigned);\n  /// DST += RHS.  Returns the carry flag.\n  static WordType tcAddPart(WordType *, WordType, unsigned);\n\n  /// DST -= RHS + CARRY where CARRY is zero or one. Returns the carry flag.\n  static WordType tcSubtract(WordType *, const WordType *,\n                             WordType carry, unsigned);\n  /// DST -= RHS.  Returns the carry flag.\n  static WordType tcSubtractPart(WordType *, WordType, unsigned);\n\n  /// DST += SRC * MULTIPLIER + PART   if add is true\n  /// DST  = SRC * MULTIPLIER + PART   if add is false\n  ///\n  /// Requires 0 <= DSTPARTS <= SRCPARTS + 1.  If DST overlaps SRC they must\n  /// start at the same point, i.e. DST == SRC.\n  ///\n  /// If DSTPARTS == SRC_PARTS + 1 no overflow occurs and zero is returned.\n  /// Otherwise DST is filled with the least significant DSTPARTS parts of the\n  /// result, and if all of the omitted higher parts were zero return zero,\n  /// otherwise overflow occurred and return one.\n  static int tcMultiplyPart(WordType *dst, const WordType *src,\n                            WordType multiplier, WordType carry,\n                            unsigned srcParts, unsigned dstParts,\n                            bool add);\n\n  /// DST = LHS * RHS, where DST has the same width as the operands and is\n  /// filled with the least significant parts of the result.  Returns one if\n  /// overflow occurred, otherwise zero.  DST must be disjoint from both\n  /// operands.\n  static int tcMultiply(WordType *, const WordType *, const WordType *,\n                        unsigned);\n\n  /// DST = LHS * RHS, where DST has width the sum of the widths of the\n  /// operands. No overflow occurs. DST must be disjoint from both operands.\n  static void tcFullMultiply(WordType *, const WordType *,\n                             const WordType *, unsigned, unsigned);\n\n  /// If RHS is zero LHS and REMAINDER are left unchanged, return one.\n  /// Otherwise set LHS to LHS / RHS with the fractional part discarded, set\n  /// REMAINDER to the remainder, return zero.  i.e.\n  ///\n  ///  OLD_LHS = RHS * LHS + REMAINDER\n  ///\n  /// SCRATCH is a bignum of the same size as the operands and result for use by\n  /// the routine; its contents need not be initialized and are destroyed.  LHS,\n  /// REMAINDER and SCRATCH must be distinct.\n  static int tcDivide(WordType *lhs, const WordType *rhs,\n                      WordType *remainder, WordType *scratch,\n                      unsigned parts);\n\n  /// Shift a bignum left Count bits. Shifted in bits are zero. There are no\n  /// restrictions on Count.\n  static void tcShiftLeft(WordType *, unsigned Words, unsigned Count);\n\n  /// Shift a bignum right Count bits.  Shifted in bits are zero.  There are no\n  /// restrictions on Count.\n  static void tcShiftRight(WordType *, unsigned Words, unsigned Count);\n\n  /// The obvious AND, OR and XOR and complement operations.\n  static void tcAnd(WordType *, const WordType *, unsigned);\n  static void tcOr(WordType *, const WordType *, unsigned);\n  static void tcXor(WordType *, const WordType *, unsigned);\n  static void tcComplement(WordType *, unsigned);\n\n  /// Comparison (unsigned) of two bignums.\n  static int tcCompare(const WordType *, const WordType *, unsigned);\n\n  /// Increment a bignum in-place.  Return the carry flag.\n  static WordType tcIncrement(WordType *dst, unsigned parts) {\n    return tcAddPart(dst, 1, parts);\n  }\n\n  /// Decrement a bignum in-place.  Return the borrow flag.\n  static WordType tcDecrement(WordType *dst, unsigned parts) {\n    return tcSubtractPart(dst, 1, parts);\n  }\n\n  /// Set the least significant BITS and clear the rest.\n  static void tcSetLeastSignificantBits(WordType *, unsigned, unsigned bits);\n\n  /// debug method\n  void dump() const;\n\n  /// @}\n};\n\n/// Magic data for optimising signed division by a constant.\nstruct APInt::ms {\n  APInt m;    ///< magic number\n  unsigned s; ///< shift amount\n};\n\n/// Magic data for optimising unsigned division by a constant.\nstruct APInt::mu {\n  APInt m;    ///< magic number\n  bool a;     ///< add indicator\n  unsigned s; ///< shift amount\n};\n\ninline bool operator==(uint64_t V1, const APInt &V2) { return V2 == V1; }\n\ninline bool operator!=(uint64_t V1, const APInt &V2) { return V2 != V1; }\n\n/// Unary bitwise complement operator.\n///\n/// \\returns an APInt that is the bitwise complement of \\p v.\ninline APInt operator~(APInt v) {\n  v.flipAllBits();\n  return v;\n}\n\ninline APInt operator&(APInt a, const APInt &b) {\n  a &= b;\n  return a;\n}\n\ninline APInt operator&(const APInt &a, APInt &&b) {\n  b &= a;\n  return std::move(b);\n}\n\ninline APInt operator&(APInt a, uint64_t RHS) {\n  a &= RHS;\n  return a;\n}\n\ninline APInt operator&(uint64_t LHS, APInt b) {\n  b &= LHS;\n  return b;\n}\n\ninline APInt operator|(APInt a, const APInt &b) {\n  a |= b;\n  return a;\n}\n\ninline APInt operator|(const APInt &a, APInt &&b) {\n  b |= a;\n  return std::move(b);\n}\n\ninline APInt operator|(APInt a, uint64_t RHS) {\n  a |= RHS;\n  return a;\n}\n\ninline APInt operator|(uint64_t LHS, APInt b) {\n  b |= LHS;\n  return b;\n}\n\ninline APInt operator^(APInt a, const APInt &b) {\n  a ^= b;\n  return a;\n}\n\ninline APInt operator^(const APInt &a, APInt &&b) {\n  b ^= a;\n  return std::move(b);\n}\n\ninline APInt operator^(APInt a, uint64_t RHS) {\n  a ^= RHS;\n  return a;\n}\n\ninline APInt operator^(uint64_t LHS, APInt b) {\n  b ^= LHS;\n  return b;\n}\n\ninline raw_ostream &operator<<(raw_ostream &OS, const APInt &I) {\n  I.print(OS, true);\n  return OS;\n}\n\ninline APInt operator-(APInt v) {\n  v.negate();\n  return v;\n}\n\ninline APInt operator+(APInt a, const APInt &b) {\n  a += b;\n  return a;\n}\n\ninline APInt operator+(const APInt &a, APInt &&b) {\n  b += a;\n  return std::move(b);\n}\n\ninline APInt operator+(APInt a, uint64_t RHS) {\n  a += RHS;\n  return a;\n}\n\ninline APInt operator+(uint64_t LHS, APInt b) {\n  b += LHS;\n  return b;\n}\n\ninline APInt operator-(APInt a, const APInt &b) {\n  a -= b;\n  return a;\n}\n\ninline APInt operator-(const APInt &a, APInt &&b) {\n  b.negate();\n  b += a;\n  return std::move(b);\n}\n\ninline APInt operator-(APInt a, uint64_t RHS) {\n  a -= RHS;\n  return a;\n}\n\ninline APInt operator-(uint64_t LHS, APInt b) {\n  b.negate();\n  b += LHS;\n  return b;\n}\n\ninline APInt operator*(APInt a, uint64_t RHS) {\n  a *= RHS;\n  return a;\n}\n\ninline APInt operator*(uint64_t LHS, APInt b) {\n  b *= LHS;\n  return b;\n}\n\n\nnamespace APIntOps {\n\n/// Determine the smaller of two APInts considered to be signed.\ninline const APInt &smin(const APInt &A, const APInt &B) {\n  return A.slt(B) ? A : B;\n}\n\n/// Determine the larger of two APInts considered to be signed.\ninline const APInt &smax(const APInt &A, const APInt &B) {\n  return A.sgt(B) ? A : B;\n}\n\n/// Determine the smaller of two APInts considered to be signed.\ninline const APInt &umin(const APInt &A, const APInt &B) {\n  return A.ult(B) ? A : B;\n}\n\n/// Determine the larger of two APInts considered to be unsigned.\ninline const APInt &umax(const APInt &A, const APInt &B) {\n  return A.ugt(B) ? A : B;\n}\n\n/// Compute GCD of two unsigned APInt values.\n///\n/// This function returns the greatest common divisor of the two APInt values\n/// using Stein's algorithm.\n///\n/// \\returns the greatest common divisor of A and B.\nAPInt GreatestCommonDivisor(APInt A, APInt B);\n\n/// Converts the given APInt to a double value.\n///\n/// Treats the APInt as an unsigned value for conversion purposes.\ninline double RoundAPIntToDouble(const APInt &APIVal) {\n  return APIVal.roundToDouble();\n}\n\n/// Converts the given APInt to a double value.\n///\n/// Treats the APInt as a signed value for conversion purposes.\ninline double RoundSignedAPIntToDouble(const APInt &APIVal) {\n  return APIVal.signedRoundToDouble();\n}\n\n/// Converts the given APInt to a float vlalue.\ninline float RoundAPIntToFloat(const APInt &APIVal) {\n  return float(RoundAPIntToDouble(APIVal));\n}\n\n/// Converts the given APInt to a float value.\n///\n/// Treats the APInt as a signed value for conversion purposes.\ninline float RoundSignedAPIntToFloat(const APInt &APIVal) {\n  return float(APIVal.signedRoundToDouble());\n}\n\n/// Converts the given double value into a APInt.\n///\n/// This function convert a double value to an APInt value.\nAPInt RoundDoubleToAPInt(double Double, unsigned width);\n\n/// Converts a float value into a APInt.\n///\n/// Converts a float value into an APInt value.\ninline APInt RoundFloatToAPInt(float Float, unsigned width) {\n  return RoundDoubleToAPInt(double(Float), width);\n}\n\n/// Return A unsign-divided by B, rounded by the given rounding mode.\nAPInt RoundingUDiv(const APInt &A, const APInt &B, APInt::Rounding RM);\n\n/// Return A sign-divided by B, rounded by the given rounding mode.\nAPInt RoundingSDiv(const APInt &A, const APInt &B, APInt::Rounding RM);\n\n/// Let q(n) = An^2 + Bn + C, and BW = bit width of the value range\n/// (e.g. 32 for i32).\n/// This function finds the smallest number n, such that\n/// (a) n >= 0 and q(n) = 0, or\n/// (b) n >= 1 and q(n-1) and q(n), when evaluated in the set of all\n///     integers, belong to two different intervals [Rk, Rk+R),\n///     where R = 2^BW, and k is an integer.\n/// The idea here is to find when q(n) \"overflows\" 2^BW, while at the\n/// same time \"allowing\" subtraction. In unsigned modulo arithmetic a\n/// subtraction (treated as addition of negated numbers) would always\n/// count as an overflow, but here we want to allow values to decrease\n/// and increase as long as they are within the same interval.\n/// Specifically, adding of two negative numbers should not cause an\n/// overflow (as long as the magnitude does not exceed the bit width).\n/// On the other hand, given a positive number, adding a negative\n/// number to it can give a negative result, which would cause the\n/// value to go from [-2^BW, 0) to [0, 2^BW). In that sense, zero is\n/// treated as a special case of an overflow.\n///\n/// This function returns None if after finding k that minimizes the\n/// positive solution to q(n) = kR, both solutions are contained between\n/// two consecutive integers.\n///\n/// There are cases where q(n) > T, and q(n+1) < T (assuming evaluation\n/// in arithmetic modulo 2^BW, and treating the values as signed) by the\n/// virtue of *signed* overflow. This function will *not* find such an n,\n/// however it may find a value of n satisfying the inequalities due to\n/// an *unsigned* overflow (if the values are treated as unsigned).\n/// To find a solution for a signed overflow, treat it as a problem of\n/// finding an unsigned overflow with a range with of BW-1.\n///\n/// The returned value may have a different bit width from the input\n/// coefficients.\nOptional<APInt> SolveQuadraticEquationWrap(APInt A, APInt B, APInt C,\n                                           unsigned RangeWidth);\n\n/// Compare two values, and if they are different, return the position of the\n/// most significant bit that is different in the values.\nOptional<unsigned> GetMostSignificantDifferentBit(const APInt &A,\n                                                  const APInt &B);\n\n} // End of APIntOps namespace\n\n// See friend declaration above. This additional declaration is required in\n// order to compile LLVM with IBM xlC compiler.\nhash_code hash_value(const APInt &Arg);\n\n/// StoreIntToMemory - Fills the StoreBytes bytes of memory starting from Dst\n/// with the integer held in IntVal.\nvoid StoreIntToMemory(const APInt &IntVal, uint8_t *Dst, unsigned StoreBytes);\n\n/// LoadIntFromMemory - Loads the integer stored in the LoadBytes bytes starting\n/// from Src into IntVal, which is assumed to be wide enough and to hold zero.\nvoid LoadIntFromMemory(APInt &IntVal, const uint8_t *Src, unsigned LoadBytes);\n\n} // namespace llvm\n\n#endif\n"}, "1": {"id": 1, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/APSInt.h", "content": "//===-- llvm/ADT/APSInt.h - Arbitrary Precision Signed Int -----*- C++ -*--===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// This file implements the APSInt class, which is a simple class that\n// represents an arbitrary sized integer that knows its signedness.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_ADT_APSINT_H\n#define LLVM_ADT_APSINT_H\n\n#include \"llvm/ADT/APInt.h\"\n\nnamespace llvm {\n\n/// An arbitrary precision integer that knows its signedness.\nclass LLVM_NODISCARD APSInt : public APInt {\n  bool IsUnsigned;\n\npublic:\n  /// Default constructor that creates an uninitialized APInt.\n  explicit APSInt() : IsUnsigned(false) {}\n\n  /// Create an APSInt with the specified width, default to unsigned.\n  explicit APSInt(uint32_t BitWidth, bool isUnsigned = true)\n   : APInt(BitWidth, 0), IsUnsigned(isUnsigned) {}\n\n  explicit APSInt(APInt I, bool isUnsigned = true)\n   : APInt(std::move(I)), IsUnsigned(isUnsigned) {}\n\n  /// Construct an APSInt from a string representation.\n  ///\n  /// This constructor interprets the string \\p Str using the radix of 10.\n  /// The interpretation stops at the end of the string. The bit width of the\n  /// constructed APSInt is determined automatically.\n  ///\n  /// \\param Str the string to be interpreted.\n  explicit APSInt(StringRef Str);\n\n  /// Determine sign of this APSInt.\n  ///\n  /// \\returns true if this APSInt is negative, false otherwise\n  bool isNegative() const { return isSigned() && APInt::isNegative(); }\n\n  /// Determine if this APSInt Value is non-negative (>= 0)\n  ///\n  /// \\returns true if this APSInt is non-negative, false otherwise\n  bool isNonNegative() const { return !isNegative(); }\n\n  /// Determine if this APSInt Value is positive.\n  ///\n  /// This tests if the value of this APSInt is positive (> 0). Note\n  /// that 0 is not a positive value.\n  ///\n  /// \\returns true if this APSInt is positive.\n  bool isStrictlyPositive() const { return isNonNegative() && !isNullValue(); }\n\n  APSInt &operator=(APInt RHS) {\n    // Retain our current sign.\n    APInt::operator=(std::move(RHS));\n    return *this;\n  }\n\n  APSInt &operator=(uint64_t RHS) {\n    // Retain our current sign.\n    APInt::operator=(RHS);\n    return *this;\n  }\n\n  // Query sign information.\n  bool isSigned() const { return !IsUnsigned; }\n  bool isUnsigned() const { return IsUnsigned; }\n  void setIsUnsigned(bool Val) { IsUnsigned = Val; }\n  void setIsSigned(bool Val) { IsUnsigned = !Val; }\n\n  /// Append this APSInt to the specified SmallString.\n  void toString(SmallVectorImpl<char> &Str, unsigned Radix = 10) const {\n    APInt::toString(Str, Radix, isSigned());\n  }\n  /// Converts an APInt to a std::string.  This is an inefficient\n  /// method; you should prefer passing in a SmallString instead.\n  std::string toString(unsigned Radix) const {\n    return APInt::toString(Radix, isSigned());\n  }\n  using APInt::toString;\n\n  /// Get the correctly-extended \\c int64_t value.\n  int64_t getExtValue() const {\n    assert(getMinSignedBits() <= 64 && \"Too many bits for int64_t\");\n    return isSigned() ? getSExtValue() : getZExtValue();\n  }\n\n  APSInt trunc(uint32_t width) const {\n    return APSInt(APInt::trunc(width), IsUnsigned);\n  }\n\n  APSInt extend(uint32_t width) const {\n    if (IsUnsigned)\n      return APSInt(zext(width), IsUnsigned);\n    else\n      return APSInt(sext(width), IsUnsigned);\n  }\n\n  APSInt extOrTrunc(uint32_t width) const {\n    if (IsUnsigned)\n      return APSInt(zextOrTrunc(width), IsUnsigned);\n    else\n      return APSInt(sextOrTrunc(width), IsUnsigned);\n  }\n\n  const APSInt &operator%=(const APSInt &RHS) {\n    assert(IsUnsigned == RHS.IsUnsigned && \"Signedness mismatch!\");\n    if (IsUnsigned)\n      *this = urem(RHS);\n    else\n      *this = srem(RHS);\n    return *this;\n  }\n  const APSInt &operator/=(const APSInt &RHS) {\n    assert(IsUnsigned == RHS.IsUnsigned && \"Signedness mismatch!\");\n    if (IsUnsigned)\n      *this = udiv(RHS);\n    else\n      *this = sdiv(RHS);\n    return *this;\n  }\n  APSInt operator%(const APSInt &RHS) const {\n    assert(IsUnsigned == RHS.IsUnsigned && \"Signedness mismatch!\");\n    return IsUnsigned ? APSInt(urem(RHS), true) : APSInt(srem(RHS), false);\n  }\n  APSInt operator/(const APSInt &RHS) const {\n    assert(IsUnsigned == RHS.IsUnsigned && \"Signedness mismatch!\");\n    return IsUnsigned ? APSInt(udiv(RHS), true) : APSInt(sdiv(RHS), false);\n  }\n\n  APSInt operator>>(unsigned Amt) const {\n    return IsUnsigned ? APSInt(lshr(Amt), true) : APSInt(ashr(Amt), false);\n  }\n  APSInt& operator>>=(unsigned Amt) {\n    if (IsUnsigned)\n      lshrInPlace(Amt);\n    else\n      ashrInPlace(Amt);\n    return *this;\n  }\n\n  inline bool operator<(const APSInt& RHS) const {\n    assert(IsUnsigned == RHS.IsUnsigned && \"Signedness mismatch!\");\n    return IsUnsigned ? ult(RHS) : slt(RHS);\n  }\n  inline bool operator>(const APSInt& RHS) const {\n    assert(IsUnsigned == RHS.IsUnsigned && \"Signedness mismatch!\");\n    return IsUnsigned ? ugt(RHS) : sgt(RHS);\n  }\n  inline bool operator<=(const APSInt& RHS) const {\n    assert(IsUnsigned == RHS.IsUnsigned && \"Signedness mismatch!\");\n    return IsUnsigned ? ule(RHS) : sle(RHS);\n  }\n  inline bool operator>=(const APSInt& RHS) const {\n    assert(IsUnsigned == RHS.IsUnsigned && \"Signedness mismatch!\");\n    return IsUnsigned ? uge(RHS) : sge(RHS);\n  }\n  inline bool operator==(const APSInt& RHS) const {\n    assert(IsUnsigned == RHS.IsUnsigned && \"Signedness mismatch!\");\n    return eq(RHS);\n  }\n  inline bool operator!=(const APSInt& RHS) const {\n    return !((*this) == RHS);\n  }\n\n  bool operator==(int64_t RHS) const {\n    return compareValues(*this, get(RHS)) == 0;\n  }\n  bool operator!=(int64_t RHS) const {\n    return compareValues(*this, get(RHS)) != 0;\n  }\n  bool operator<=(int64_t RHS) const {\n    return compareValues(*this, get(RHS)) <= 0;\n  }\n  bool operator>=(int64_t RHS) const {\n    return compareValues(*this, get(RHS)) >= 0;\n  }\n  bool operator<(int64_t RHS) const {\n    return compareValues(*this, get(RHS)) < 0;\n  }\n  bool operator>(int64_t RHS) const {\n    return compareValues(*this, get(RHS)) > 0;\n  }\n\n  // The remaining operators just wrap the logic of APInt, but retain the\n  // signedness information.\n\n  APSInt operator<<(unsigned Bits) const {\n    return APSInt(static_cast<const APInt&>(*this) << Bits, IsUnsigned);\n  }\n  APSInt& operator<<=(unsigned Amt) {\n    static_cast<APInt&>(*this) <<= Amt;\n    return *this;\n  }\n\n  APSInt& operator++() {\n    ++(static_cast<APInt&>(*this));\n    return *this;\n  }\n  APSInt& operator--() {\n    --(static_cast<APInt&>(*this));\n    return *this;\n  }\n  APSInt operator++(int) {\n    return APSInt(++static_cast<APInt&>(*this), IsUnsigned);\n  }\n  APSInt operator--(int) {\n    return APSInt(--static_cast<APInt&>(*this), IsUnsigned);\n  }\n  APSInt operator-() const {\n    return APSInt(-static_cast<const APInt&>(*this), IsUnsigned);\n  }\n  APSInt& operator+=(const APSInt& RHS) {\n    assert(IsUnsigned == RHS.IsUnsigned && \"Signedness mismatch!\");\n    static_cast<APInt&>(*this) += RHS;\n    return *this;\n  }\n  APSInt& operator-=(const APSInt& RHS) {\n    assert(IsUnsigned == RHS.IsUnsigned && \"Signedness mismatch!\");\n    static_cast<APInt&>(*this) -= RHS;\n    return *this;\n  }\n  APSInt& operator*=(const APSInt& RHS) {\n    assert(IsUnsigned == RHS.IsUnsigned && \"Signedness mismatch!\");\n    static_cast<APInt&>(*this) *= RHS;\n    return *this;\n  }\n  APSInt& operator&=(const APSInt& RHS) {\n    assert(IsUnsigned == RHS.IsUnsigned && \"Signedness mismatch!\");\n    static_cast<APInt&>(*this) &= RHS;\n    return *this;\n  }\n  APSInt& operator|=(const APSInt& RHS) {\n    assert(IsUnsigned == RHS.IsUnsigned && \"Signedness mismatch!\");\n    static_cast<APInt&>(*this) |= RHS;\n    return *this;\n  }\n  APSInt& operator^=(const APSInt& RHS) {\n    assert(IsUnsigned == RHS.IsUnsigned && \"Signedness mismatch!\");\n    static_cast<APInt&>(*this) ^= RHS;\n    return *this;\n  }\n\n  APSInt operator&(const APSInt& RHS) const {\n    assert(IsUnsigned == RHS.IsUnsigned && \"Signedness mismatch!\");\n    return APSInt(static_cast<const APInt&>(*this) & RHS, IsUnsigned);\n  }\n\n  APSInt operator|(const APSInt& RHS) const {\n    assert(IsUnsigned == RHS.IsUnsigned && \"Signedness mismatch!\");\n    return APSInt(static_cast<const APInt&>(*this) | RHS, IsUnsigned);\n  }\n\n  APSInt operator^(const APSInt &RHS) const {\n    assert(IsUnsigned == RHS.IsUnsigned && \"Signedness mismatch!\");\n    return APSInt(static_cast<const APInt&>(*this) ^ RHS, IsUnsigned);\n  }\n\n  APSInt operator*(const APSInt& RHS) const {\n    assert(IsUnsigned == RHS.IsUnsigned && \"Signedness mismatch!\");\n    return APSInt(static_cast<const APInt&>(*this) * RHS, IsUnsigned);\n  }\n  APSInt operator+(const APSInt& RHS) const {\n    assert(IsUnsigned == RHS.IsUnsigned && \"Signedness mismatch!\");\n    return APSInt(static_cast<const APInt&>(*this) + RHS, IsUnsigned);\n  }\n  APSInt operator-(const APSInt& RHS) const {\n    assert(IsUnsigned == RHS.IsUnsigned && \"Signedness mismatch!\");\n    return APSInt(static_cast<const APInt&>(*this) - RHS, IsUnsigned);\n  }\n  APSInt operator~() const {\n    return APSInt(~static_cast<const APInt&>(*this), IsUnsigned);\n  }\n\n  /// Return the APSInt representing the maximum integer value with the given\n  /// bit width and signedness.\n  static APSInt getMaxValue(uint32_t numBits, bool Unsigned) {\n    return APSInt(Unsigned ? APInt::getMaxValue(numBits)\n                           : APInt::getSignedMaxValue(numBits), Unsigned);\n  }\n\n  /// Return the APSInt representing the minimum integer value with the given\n  /// bit width and signedness.\n  static APSInt getMinValue(uint32_t numBits, bool Unsigned) {\n    return APSInt(Unsigned ? APInt::getMinValue(numBits)\n                           : APInt::getSignedMinValue(numBits), Unsigned);\n  }\n\n  /// Determine if two APSInts have the same value, zero- or\n  /// sign-extending as needed.\n  static bool isSameValue(const APSInt &I1, const APSInt &I2) {\n    return !compareValues(I1, I2);\n  }\n\n  /// Compare underlying values of two numbers.\n  static int compareValues(const APSInt &I1, const APSInt &I2) {\n    if (I1.getBitWidth() == I2.getBitWidth() && I1.isSigned() == I2.isSigned())\n      return I1.IsUnsigned ? I1.compare(I2) : I1.compareSigned(I2);\n\n    // Check for a bit-width mismatch.\n    if (I1.getBitWidth() > I2.getBitWidth())\n      return compareValues(I1, I2.extend(I1.getBitWidth()));\n    if (I2.getBitWidth() > I1.getBitWidth())\n      return compareValues(I1.extend(I2.getBitWidth()), I2);\n\n    // We have a signedness mismatch. Check for negative values and do an\n    // unsigned compare if both are positive.\n    if (I1.isSigned()) {\n      assert(!I2.isSigned() && \"Expected signed mismatch\");\n      if (I1.isNegative())\n        return -1;\n    } else {\n      assert(I2.isSigned() && \"Expected signed mismatch\");\n      if (I2.isNegative())\n        return 1;\n    }\n\n    return I1.compare(I2);\n  }\n\n  static APSInt get(int64_t X) { return APSInt(APInt(64, X), false); }\n  static APSInt getUnsigned(uint64_t X) { return APSInt(APInt(64, X), true); }\n\n  /// Used to insert APSInt objects, or objects that contain APSInt objects,\n  /// into FoldingSets.\n  void Profile(FoldingSetNodeID& ID) const;\n};\n\ninline bool operator==(int64_t V1, const APSInt &V2) { return V2 == V1; }\ninline bool operator!=(int64_t V1, const APSInt &V2) { return V2 != V1; }\ninline bool operator<=(int64_t V1, const APSInt &V2) { return V2 >= V1; }\ninline bool operator>=(int64_t V1, const APSInt &V2) { return V2 <= V1; }\ninline bool operator<(int64_t V1, const APSInt &V2) { return V2 > V1; }\ninline bool operator>(int64_t V1, const APSInt &V2) { return V2 < V1; }\n\ninline raw_ostream &operator<<(raw_ostream &OS, const APSInt &I) {\n  I.print(OS, I.isSigned());\n  return OS;\n}\n\n} // end namespace llvm\n\n#endif\n"}, "2": {"id": 2, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/ArrayRef.h", "content": "//===- ArrayRef.h - Array Reference Wrapper ---------------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_ADT_ARRAYREF_H\n#define LLVM_ADT_ARRAYREF_H\n\n#include \"llvm/ADT/Hashing.h\"\n#include \"llvm/ADT/None.h\"\n#include \"llvm/ADT/SmallVector.h\"\n#include \"llvm/ADT/STLExtras.h\"\n#include \"llvm/Support/Compiler.h\"\n#include <algorithm>\n#include <array>\n#include <cassert>\n#include <cstddef>\n#include <initializer_list>\n#include <iterator>\n#include <memory>\n#include <type_traits>\n#include <vector>\n\nnamespace llvm {\n\n  /// ArrayRef - Represent a constant reference to an array (0 or more elements\n  /// consecutively in memory), i.e. a start pointer and a length.  It allows\n  /// various APIs to take consecutive elements easily and conveniently.\n  ///\n  /// This class does not own the underlying data, it is expected to be used in\n  /// situations where the data resides in some other buffer, whose lifetime\n  /// extends past that of the ArrayRef. For this reason, it is not in general\n  /// safe to store an ArrayRef.\n  ///\n  /// This is intended to be trivially copyable, so it should be passed by\n  /// value.\n  template<typename T>\n  class LLVM_GSL_POINTER LLVM_NODISCARD ArrayRef {\n  public:\n    using value_type = T;\n    using pointer = value_type *;\n    using const_pointer = const value_type *;\n    using reference = value_type &;\n    using const_reference = const value_type &;\n    using iterator = const_pointer;\n    using const_iterator = const_pointer;\n    using reverse_iterator = std::reverse_iterator<iterator>;\n    using const_reverse_iterator = std::reverse_iterator<const_iterator>;\n    using size_type = size_t;\n    using difference_type = ptrdiff_t;\n\n  private:\n    /// The start of the array, in an external buffer.\n    const T *Data = nullptr;\n\n    /// The number of elements.\n    size_type Length = 0;\n\n  public:\n    /// @name Constructors\n    /// @{\n\n    /// Construct an empty ArrayRef.\n    /*implicit*/ ArrayRef() = default;\n\n    /// Construct an empty ArrayRef from None.\n    /*implicit*/ ArrayRef(NoneType) {}\n\n    /// Construct an ArrayRef from a single element.\n    /*implicit*/ ArrayRef(const T &OneElt)\n      : Data(&OneElt), Length(1) {}\n\n    /// Construct an ArrayRef from a pointer and length.\n    /*implicit*/ ArrayRef(const T *data, size_t length)\n      : Data(data), Length(length) {}\n\n    /// Construct an ArrayRef from a range.\n    ArrayRef(const T *begin, const T *end)\n      : Data(begin), Length(end - begin) {}\n\n    /// Construct an ArrayRef from a SmallVector. This is templated in order to\n    /// avoid instantiating SmallVectorTemplateCommon<T> whenever we\n    /// copy-construct an ArrayRef.\n    template<typename U>\n    /*implicit*/ ArrayRef(const SmallVectorTemplateCommon<T, U> &Vec)\n      : Data(Vec.data()), Length(Vec.size()) {\n    }\n\n    /// Construct an ArrayRef from a std::vector.\n    template<typename A>\n    /*implicit*/ ArrayRef(const std::vector<T, A> &Vec)\n      : Data(Vec.data()), Length(Vec.size()) {}\n\n    /// Construct an ArrayRef from a std::array\n    template <size_t N>\n    /*implicit*/ constexpr ArrayRef(const std::array<T, N> &Arr)\n        : Data(Arr.data()), Length(N) {}\n\n    /// Construct an ArrayRef from a C array.\n    template <size_t N>\n    /*implicit*/ constexpr ArrayRef(const T (&Arr)[N]) : Data(Arr), Length(N) {}\n\n    /// Construct an ArrayRef from a std::initializer_list.\n#if LLVM_GNUC_PREREQ(9, 0, 0)\n// Disable gcc's warning in this constructor as it generates an enormous amount\n// of messages. Anyone using ArrayRef should already be aware of the fact that\n// it does not do lifetime extension.\n#pragma GCC diagnostic push\n#pragma GCC diagnostic ignored \"-Winit-list-lifetime\"\n#endif\n    /*implicit*/ ArrayRef(const std::initializer_list<T> &Vec)\n    : Data(Vec.begin() == Vec.end() ? (T*)nullptr : Vec.begin()),\n      Length(Vec.size()) {}\n#if LLVM_GNUC_PREREQ(9, 0, 0)\n#pragma GCC diagnostic pop\n#endif\n\n    /// Construct an ArrayRef<const T*> from ArrayRef<T*>. This uses SFINAE to\n    /// ensure that only ArrayRefs of pointers can be converted.\n    template <typename U>\n    ArrayRef(const ArrayRef<U *> &A,\n             std::enable_if_t<std::is_convertible<U *const *, T const *>::value>\n                 * = nullptr)\n        : Data(A.data()), Length(A.size()) {}\n\n    /// Construct an ArrayRef<const T*> from a SmallVector<T*>. This is\n    /// templated in order to avoid instantiating SmallVectorTemplateCommon<T>\n    /// whenever we copy-construct an ArrayRef.\n    template <typename U, typename DummyT>\n    /*implicit*/ ArrayRef(\n        const SmallVectorTemplateCommon<U *, DummyT> &Vec,\n        std::enable_if_t<std::is_convertible<U *const *, T const *>::value> * =\n            nullptr)\n        : Data(Vec.data()), Length(Vec.size()) {}\n\n    /// Construct an ArrayRef<const T*> from std::vector<T*>. This uses SFINAE\n    /// to ensure that only vectors of pointers can be converted.\n    template <typename U, typename A>\n    ArrayRef(const std::vector<U *, A> &Vec,\n             std::enable_if_t<std::is_convertible<U *const *, T const *>::value>\n                 * = 0)\n        : Data(Vec.data()), Length(Vec.size()) {}\n\n    /// @}\n    /// @name Simple Operations\n    /// @{\n\n    iterator begin() const { return Data; }\n    iterator end() const { return Data + Length; }\n\n    reverse_iterator rbegin() const { return reverse_iterator(end()); }\n    reverse_iterator rend() const { return reverse_iterator(begin()); }\n\n    /// empty - Check if the array is empty.\n    bool empty() const { return Length == 0; }\n\n    const T *data() const { return Data; }\n\n    /// size - Get the array size.\n    size_t size() const { return Length; }\n\n    /// front - Get the first element.\n    const T &front() const {\n      assert(!empty());\n      return Data[0];\n    }\n\n    /// back - Get the last element.\n    const T &back() const {\n      assert(!empty());\n      return Data[Length-1];\n    }\n\n    // copy - Allocate copy in Allocator and return ArrayRef<T> to it.\n    template <typename Allocator> ArrayRef<T> copy(Allocator &A) {\n      T *Buff = A.template Allocate<T>(Length);\n      std::uninitialized_copy(begin(), end(), Buff);\n      return ArrayRef<T>(Buff, Length);\n    }\n\n    /// equals - Check for element-wise equality.\n    bool equals(ArrayRef RHS) const {\n      if (Length != RHS.Length)\n        return false;\n      return std::equal(begin(), end(), RHS.begin());\n    }\n\n    /// slice(n, m) - Chop off the first N elements of the array, and keep M\n    /// elements in the array.\n    ArrayRef<T> slice(size_t N, size_t M) const {\n      assert(N+M <= size() && \"Invalid specifier\");\n      return ArrayRef<T>(data()+N, M);\n    }\n\n    /// slice(n) - Chop off the first N elements of the array.\n    ArrayRef<T> slice(size_t N) const { return slice(N, size() - N); }\n\n    /// Drop the first \\p N elements of the array.\n    ArrayRef<T> drop_front(size_t N = 1) const {\n      assert(size() >= N && \"Dropping more elements than exist\");\n      return slice(N, size() - N);\n    }\n\n    /// Drop the last \\p N elements of the array.\n    ArrayRef<T> drop_back(size_t N = 1) const {\n      assert(size() >= N && \"Dropping more elements than exist\");\n      return slice(0, size() - N);\n    }\n\n    /// Return a copy of *this with the first N elements satisfying the\n    /// given predicate removed.\n    template <class PredicateT> ArrayRef<T> drop_while(PredicateT Pred) const {\n      return ArrayRef<T>(find_if_not(*this, Pred), end());\n    }\n\n    /// Return a copy of *this with the first N elements not satisfying\n    /// the given predicate removed.\n    template <class PredicateT> ArrayRef<T> drop_until(PredicateT Pred) const {\n      return ArrayRef<T>(find_if(*this, Pred), end());\n    }\n\n    /// Return a copy of *this with only the first \\p N elements.\n    ArrayRef<T> take_front(size_t N = 1) const {\n      if (N >= size())\n        return *this;\n      return drop_back(size() - N);\n    }\n\n    /// Return a copy of *this with only the last \\p N elements.\n    ArrayRef<T> take_back(size_t N = 1) const {\n      if (N >= size())\n        return *this;\n      return drop_front(size() - N);\n    }\n\n    /// Return the first N elements of this Array that satisfy the given\n    /// predicate.\n    template <class PredicateT> ArrayRef<T> take_while(PredicateT Pred) const {\n      return ArrayRef<T>(begin(), find_if_not(*this, Pred));\n    }\n\n    /// Return the first N elements of this Array that don't satisfy the\n    /// given predicate.\n    template <class PredicateT> ArrayRef<T> take_until(PredicateT Pred) const {\n      return ArrayRef<T>(begin(), find_if(*this, Pred));\n    }\n\n    /// @}\n    /// @name Operator Overloads\n    /// @{\n    const T &operator[](size_t Index) const {\n      assert(Index < Length && \"Invalid index!\");\n      return Data[Index];\n    }\n\n    /// Disallow accidental assignment from a temporary.\n    ///\n    /// The declaration here is extra complicated so that \"arrayRef = {}\"\n    /// continues to select the move assignment operator.\n    template <typename U>\n    std::enable_if_t<std::is_same<U, T>::value, ArrayRef<T>> &\n    operator=(U &&Temporary) = delete;\n\n    /// Disallow accidental assignment from a temporary.\n    ///\n    /// The declaration here is extra complicated so that \"arrayRef = {}\"\n    /// continues to select the move assignment operator.\n    template <typename U>\n    std::enable_if_t<std::is_same<U, T>::value, ArrayRef<T>> &\n    operator=(std::initializer_list<U>) = delete;\n\n    /// @}\n    /// @name Expensive Operations\n    /// @{\n    std::vector<T> vec() const {\n      return std::vector<T>(Data, Data+Length);\n    }\n\n    /// @}\n    /// @name Conversion operators\n    /// @{\n    operator std::vector<T>() const {\n      return std::vector<T>(Data, Data+Length);\n    }\n\n    /// @}\n  };\n\n  /// MutableArrayRef - Represent a mutable reference to an array (0 or more\n  /// elements consecutively in memory), i.e. a start pointer and a length.  It\n  /// allows various APIs to take and modify consecutive elements easily and\n  /// conveniently.\n  ///\n  /// This class does not own the underlying data, it is expected to be used in\n  /// situations where the data resides in some other buffer, whose lifetime\n  /// extends past that of the MutableArrayRef. For this reason, it is not in\n  /// general safe to store a MutableArrayRef.\n  ///\n  /// This is intended to be trivially copyable, so it should be passed by\n  /// value.\n  template<typename T>\n  class LLVM_NODISCARD MutableArrayRef : public ArrayRef<T> {\n  public:\n    using value_type = T;\n    using pointer = value_type *;\n    using const_pointer = const value_type *;\n    using reference = value_type &;\n    using const_reference = const value_type &;\n    using iterator = pointer;\n    using const_iterator = const_pointer;\n    using reverse_iterator = std::reverse_iterator<iterator>;\n    using const_reverse_iterator = std::reverse_iterator<const_iterator>;\n    using size_type = size_t;\n    using difference_type = ptrdiff_t;\n\n    /// Construct an empty MutableArrayRef.\n    /*implicit*/ MutableArrayRef() = default;\n\n    /// Construct an empty MutableArrayRef from None.\n    /*implicit*/ MutableArrayRef(NoneType) : ArrayRef<T>() {}\n\n    /// Construct a MutableArrayRef from a single element.\n    /*implicit*/ MutableArrayRef(T &OneElt) : ArrayRef<T>(OneElt) {}\n\n    /// Construct a MutableArrayRef from a pointer and length.\n    /*implicit*/ MutableArrayRef(T *data, size_t length)\n      : ArrayRef<T>(data, length) {}\n\n    /// Construct a MutableArrayRef from a range.\n    MutableArrayRef(T *begin, T *end) : ArrayRef<T>(begin, end) {}\n\n    /// Construct a MutableArrayRef from a SmallVector.\n    /*implicit*/ MutableArrayRef(SmallVectorImpl<T> &Vec)\n    : ArrayRef<T>(Vec) {}\n\n    /// Construct a MutableArrayRef from a std::vector.\n    /*implicit*/ MutableArrayRef(std::vector<T> &Vec)\n    : ArrayRef<T>(Vec) {}\n\n    /// Construct a MutableArrayRef from a std::array\n    template <size_t N>\n    /*implicit*/ constexpr MutableArrayRef(std::array<T, N> &Arr)\n        : ArrayRef<T>(Arr) {}\n\n    /// Construct a MutableArrayRef from a C array.\n    template <size_t N>\n    /*implicit*/ constexpr MutableArrayRef(T (&Arr)[N]) : ArrayRef<T>(Arr) {}\n\n    T *data() const { return const_cast<T*>(ArrayRef<T>::data()); }\n\n    iterator begin() const { return data(); }\n    iterator end() const { return data() + this->size(); }\n\n    reverse_iterator rbegin() const { return reverse_iterator(end()); }\n    reverse_iterator rend() const { return reverse_iterator(begin()); }\n\n    /// front - Get the first element.\n    T &front() const {\n      assert(!this->empty());\n      return data()[0];\n    }\n\n    /// back - Get the last element.\n    T &back() const {\n      assert(!this->empty());\n      return data()[this->size()-1];\n    }\n\n    /// slice(n, m) - Chop off the first N elements of the array, and keep M\n    /// elements in the array.\n    MutableArrayRef<T> slice(size_t N, size_t M) const {\n      assert(N + M <= this->size() && \"Invalid specifier\");\n      return MutableArrayRef<T>(this->data() + N, M);\n    }\n\n    /// slice(n) - Chop off the first N elements of the array.\n    MutableArrayRef<T> slice(size_t N) const {\n      return slice(N, this->size() - N);\n    }\n\n    /// Drop the first \\p N elements of the array.\n    MutableArrayRef<T> drop_front(size_t N = 1) const {\n      assert(this->size() >= N && \"Dropping more elements than exist\");\n      return slice(N, this->size() - N);\n    }\n\n    MutableArrayRef<T> drop_back(size_t N = 1) const {\n      assert(this->size() >= N && \"Dropping more elements than exist\");\n      return slice(0, this->size() - N);\n    }\n\n    /// Return a copy of *this with the first N elements satisfying the\n    /// given predicate removed.\n    template <class PredicateT>\n    MutableArrayRef<T> drop_while(PredicateT Pred) const {\n      return MutableArrayRef<T>(find_if_not(*this, Pred), end());\n    }\n\n    /// Return a copy of *this with the first N elements not satisfying\n    /// the given predicate removed.\n    template <class PredicateT>\n    MutableArrayRef<T> drop_until(PredicateT Pred) const {\n      return MutableArrayRef<T>(find_if(*this, Pred), end());\n    }\n\n    /// Return a copy of *this with only the first \\p N elements.\n    MutableArrayRef<T> take_front(size_t N = 1) const {\n      if (N >= this->size())\n        return *this;\n      return drop_back(this->size() - N);\n    }\n\n    /// Return a copy of *this with only the last \\p N elements.\n    MutableArrayRef<T> take_back(size_t N = 1) const {\n      if (N >= this->size())\n        return *this;\n      return drop_front(this->size() - N);\n    }\n\n    /// Return the first N elements of this Array that satisfy the given\n    /// predicate.\n    template <class PredicateT>\n    MutableArrayRef<T> take_while(PredicateT Pred) const {\n      return MutableArrayRef<T>(begin(), find_if_not(*this, Pred));\n    }\n\n    /// Return the first N elements of this Array that don't satisfy the\n    /// given predicate.\n    template <class PredicateT>\n    MutableArrayRef<T> take_until(PredicateT Pred) const {\n      return MutableArrayRef<T>(begin(), find_if(*this, Pred));\n    }\n\n    /// @}\n    /// @name Operator Overloads\n    /// @{\n    T &operator[](size_t Index) const {\n      assert(Index < this->size() && \"Invalid index!\");\n      return data()[Index];\n    }\n  };\n\n  /// This is a MutableArrayRef that owns its array.\n  template <typename T> class OwningArrayRef : public MutableArrayRef<T> {\n  public:\n    OwningArrayRef() = default;\n    OwningArrayRef(size_t Size) : MutableArrayRef<T>(new T[Size], Size) {}\n\n    OwningArrayRef(ArrayRef<T> Data)\n        : MutableArrayRef<T>(new T[Data.size()], Data.size()) {\n      std::copy(Data.begin(), Data.end(), this->begin());\n    }\n\n    OwningArrayRef(OwningArrayRef &&Other) { *this = std::move(Other); }\n\n    OwningArrayRef &operator=(OwningArrayRef &&Other) {\n      delete[] this->data();\n      this->MutableArrayRef<T>::operator=(Other);\n      Other.MutableArrayRef<T>::operator=(MutableArrayRef<T>());\n      return *this;\n    }\n\n    ~OwningArrayRef() { delete[] this->data(); }\n  };\n\n  /// @name ArrayRef Convenience constructors\n  /// @{\n\n  /// Construct an ArrayRef from a single element.\n  template<typename T>\n  ArrayRef<T> makeArrayRef(const T &OneElt) {\n    return OneElt;\n  }\n\n  /// Construct an ArrayRef from a pointer and length.\n  template<typename T>\n  ArrayRef<T> makeArrayRef(const T *data, size_t length) {\n    return ArrayRef<T>(data, length);\n  }\n\n  /// Construct an ArrayRef from a range.\n  template<typename T>\n  ArrayRef<T> makeArrayRef(const T *begin, const T *end) {\n    return ArrayRef<T>(begin, end);\n  }\n\n  /// Construct an ArrayRef from a SmallVector.\n  template <typename T>\n  ArrayRef<T> makeArrayRef(const SmallVectorImpl<T> &Vec) {\n    return Vec;\n  }\n\n  /// Construct an ArrayRef from a SmallVector.\n  template <typename T, unsigned N>\n  ArrayRef<T> makeArrayRef(const SmallVector<T, N> &Vec) {\n    return Vec;\n  }\n\n  /// Construct an ArrayRef from a std::vector.\n  template<typename T>\n  ArrayRef<T> makeArrayRef(const std::vector<T> &Vec) {\n    return Vec;\n  }\n\n  /// Construct an ArrayRef from a std::array.\n  template <typename T, std::size_t N>\n  ArrayRef<T> makeArrayRef(const std::array<T, N> &Arr) {\n    return Arr;\n  }\n\n  /// Construct an ArrayRef from an ArrayRef (no-op) (const)\n  template <typename T> ArrayRef<T> makeArrayRef(const ArrayRef<T> &Vec) {\n    return Vec;\n  }\n\n  /// Construct an ArrayRef from an ArrayRef (no-op)\n  template <typename T> ArrayRef<T> &makeArrayRef(ArrayRef<T> &Vec) {\n    return Vec;\n  }\n\n  /// Construct an ArrayRef from a C array.\n  template<typename T, size_t N>\n  ArrayRef<T> makeArrayRef(const T (&Arr)[N]) {\n    return ArrayRef<T>(Arr);\n  }\n\n  /// Construct a MutableArrayRef from a single element.\n  template<typename T>\n  MutableArrayRef<T> makeMutableArrayRef(T &OneElt) {\n    return OneElt;\n  }\n\n  /// Construct a MutableArrayRef from a pointer and length.\n  template<typename T>\n  MutableArrayRef<T> makeMutableArrayRef(T *data, size_t length) {\n    return MutableArrayRef<T>(data, length);\n  }\n\n  /// @}\n  /// @name ArrayRef Comparison Operators\n  /// @{\n\n  template<typename T>\n  inline bool operator==(ArrayRef<T> LHS, ArrayRef<T> RHS) {\n    return LHS.equals(RHS);\n  }\n\n  template <typename T>\n  inline bool operator==(SmallVectorImpl<T> &LHS, ArrayRef<T> RHS) {\n    return ArrayRef<T>(LHS).equals(RHS);\n  }\n\n  template <typename T>\n  inline bool operator!=(ArrayRef<T> LHS, ArrayRef<T> RHS) {\n    return !(LHS == RHS);\n  }\n\n  template <typename T>\n  inline bool operator!=(SmallVectorImpl<T> &LHS, ArrayRef<T> RHS) {\n    return !(LHS == RHS);\n  }\n\n  /// @}\n\n  template <typename T> hash_code hash_value(ArrayRef<T> S) {\n    return hash_combine_range(S.begin(), S.end());\n  }\n\n} // end namespace llvm\n\n#endif // LLVM_ADT_ARRAYREF_H\n"}, "3": {"id": 3, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/BitVector.h", "content": "//===- llvm/ADT/BitVector.h - Bit vectors -----------------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// This file implements the BitVector class.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_ADT_BITVECTOR_H\n#define LLVM_ADT_BITVECTOR_H\n\n#include \"llvm/ADT/ArrayRef.h\"\n#include \"llvm/ADT/DenseMapInfo.h\"\n#include \"llvm/ADT/iterator_range.h\"\n#include \"llvm/Support/MathExtras.h\"\n#include <algorithm>\n#include <cassert>\n#include <climits>\n#include <cstdint>\n#include <cstdlib>\n#include <cstring>\n#include <utility>\n\nnamespace llvm {\n\n/// ForwardIterator for the bits that are set.\n/// Iterators get invalidated when resize / reserve is called.\ntemplate <typename BitVectorT> class const_set_bits_iterator_impl {\n  const BitVectorT &Parent;\n  int Current = 0;\n\n  void advance() {\n    assert(Current != -1 && \"Trying to advance past end.\");\n    Current = Parent.find_next(Current);\n  }\n\npublic:\n  const_set_bits_iterator_impl(const BitVectorT &Parent, int Current)\n      : Parent(Parent), Current(Current) {}\n  explicit const_set_bits_iterator_impl(const BitVectorT &Parent)\n      : const_set_bits_iterator_impl(Parent, Parent.find_first()) {}\n  const_set_bits_iterator_impl(const const_set_bits_iterator_impl &) = default;\n\n  const_set_bits_iterator_impl operator++(int) {\n    auto Prev = *this;\n    advance();\n    return Prev;\n  }\n\n  const_set_bits_iterator_impl &operator++() {\n    advance();\n    return *this;\n  }\n\n  unsigned operator*() const { return Current; }\n\n  bool operator==(const const_set_bits_iterator_impl &Other) const {\n    assert(&Parent == &Other.Parent &&\n           \"Comparing iterators from different BitVectors\");\n    return Current == Other.Current;\n  }\n\n  bool operator!=(const const_set_bits_iterator_impl &Other) const {\n    assert(&Parent == &Other.Parent &&\n           \"Comparing iterators from different BitVectors\");\n    return Current != Other.Current;\n  }\n};\n\nclass BitVector {\n  typedef uintptr_t BitWord;\n\n  enum { BITWORD_SIZE = (unsigned)sizeof(BitWord) * CHAR_BIT };\n\n  static_assert(BITWORD_SIZE == 64 || BITWORD_SIZE == 32,\n                \"Unsupported word size\");\n\n  MutableArrayRef<BitWord> Bits; // Actual bits.\n  unsigned Size;                 // Size of bitvector in bits.\n\npublic:\n  typedef unsigned size_type;\n  // Encapsulation of a single bit.\n  class reference {\n    friend class BitVector;\n\n    BitWord *WordRef;\n    unsigned BitPos;\n\n  public:\n    reference(BitVector &b, unsigned Idx) {\n      WordRef = &b.Bits[Idx / BITWORD_SIZE];\n      BitPos = Idx % BITWORD_SIZE;\n    }\n\n    reference() = delete;\n    reference(const reference&) = default;\n\n    reference &operator=(reference t) {\n      *this = bool(t);\n      return *this;\n    }\n\n    reference& operator=(bool t) {\n      if (t)\n        *WordRef |= BitWord(1) << BitPos;\n      else\n        *WordRef &= ~(BitWord(1) << BitPos);\n      return *this;\n    }\n\n    operator bool() const {\n      return ((*WordRef) & (BitWord(1) << BitPos)) != 0;\n    }\n  };\n\n  typedef const_set_bits_iterator_impl<BitVector> const_set_bits_iterator;\n  typedef const_set_bits_iterator set_iterator;\n\n  const_set_bits_iterator set_bits_begin() const {\n    return const_set_bits_iterator(*this);\n  }\n  const_set_bits_iterator set_bits_end() const {\n    return const_set_bits_iterator(*this, -1);\n  }\n  iterator_range<const_set_bits_iterator> set_bits() const {\n    return make_range(set_bits_begin(), set_bits_end());\n  }\n\n  /// BitVector default ctor - Creates an empty bitvector.\n  BitVector() : Size(0) {}\n\n  /// BitVector ctor - Creates a bitvector of specified number of bits. All\n  /// bits are initialized to the specified value.\n  explicit BitVector(unsigned s, bool t = false) : Size(s) {\n    size_t Capacity = NumBitWords(s);\n    Bits = allocate(Capacity);\n    init_words(Bits, t);\n    if (t)\n      clear_unused_bits();\n  }\n\n  /// BitVector copy ctor.\n  BitVector(const BitVector &RHS) : Size(RHS.size()) {\n    if (Size == 0) {\n      Bits = MutableArrayRef<BitWord>();\n      return;\n    }\n\n    size_t Capacity = NumBitWords(RHS.size());\n    Bits = allocate(Capacity);\n    std::memcpy(Bits.data(), RHS.Bits.data(), Capacity * sizeof(BitWord));\n  }\n\n  BitVector(BitVector &&RHS) : Bits(RHS.Bits), Size(RHS.Size) {\n    RHS.Bits = MutableArrayRef<BitWord>();\n    RHS.Size = 0;\n  }\n\n  ~BitVector() { std::free(Bits.data()); }\n\n  /// empty - Tests whether there are no bits in this bitvector.\n  bool empty() const { return Size == 0; }\n\n  /// size - Returns the number of bits in this bitvector.\n  size_type size() const { return Size; }\n\n  /// count - Returns the number of bits which are set.\n  size_type count() const {\n    unsigned NumBits = 0;\n    for (unsigned i = 0; i < NumBitWords(size()); ++i)\n      NumBits += countPopulation(Bits[i]);\n    return NumBits;\n  }\n\n  /// any - Returns true if any bit is set.\n  bool any() const {\n    for (unsigned i = 0; i < NumBitWords(size()); ++i)\n      if (Bits[i] != 0)\n        return true;\n    return false;\n  }\n\n  /// all - Returns true if all bits are set.\n  bool all() const {\n    for (unsigned i = 0; i < Size / BITWORD_SIZE; ++i)\n      if (Bits[i] != ~BitWord(0))\n        return false;\n\n    // If bits remain check that they are ones. The unused bits are always zero.\n    if (unsigned Remainder = Size % BITWORD_SIZE)\n      return Bits[Size / BITWORD_SIZE] == (BitWord(1) << Remainder) - 1;\n\n    return true;\n  }\n\n  /// none - Returns true if none of the bits are set.\n  bool none() const {\n    return !any();\n  }\n\n  /// find_first_in - Returns the index of the first set / unset bit,\n  /// depending on \\p Set, in the range [Begin, End).\n  /// Returns -1 if all bits in the range are unset / set.\n  int find_first_in(unsigned Begin, unsigned End, bool Set = true) const {\n    assert(Begin <= End && End <= Size);\n    if (Begin == End)\n      return -1;\n\n    unsigned FirstWord = Begin / BITWORD_SIZE;\n    unsigned LastWord = (End - 1) / BITWORD_SIZE;\n\n    // Check subsequent words.\n    // The code below is based on search for the first _set_ bit. If\n    // we're searching for the first _unset_, we just take the\n    // complement of each word before we use it and apply\n    // the same method.\n    for (unsigned i = FirstWord; i <= LastWord; ++i) {\n      BitWord Copy = Bits[i];\n      if (!Set)\n        Copy = ~Copy;\n\n      if (i == FirstWord) {\n        unsigned FirstBit = Begin % BITWORD_SIZE;\n        Copy &= maskTrailingZeros<BitWord>(FirstBit);\n      }\n\n      if (i == LastWord) {\n        unsigned LastBit = (End - 1) % BITWORD_SIZE;\n        Copy &= maskTrailingOnes<BitWord>(LastBit + 1);\n      }\n      if (Copy != 0)\n        return i * BITWORD_SIZE + countTrailingZeros(Copy);\n    }\n    return -1;\n  }\n\n  /// find_last_in - Returns the index of the last set bit in the range\n  /// [Begin, End).  Returns -1 if all bits in the range are unset.\n  int find_last_in(unsigned Begin, unsigned End) const {\n    assert(Begin <= End && End <= Size);\n    if (Begin == End)\n      return -1;\n\n    unsigned LastWord = (End - 1) / BITWORD_SIZE;\n    unsigned FirstWord = Begin / BITWORD_SIZE;\n\n    for (unsigned i = LastWord + 1; i >= FirstWord + 1; --i) {\n      unsigned CurrentWord = i - 1;\n\n      BitWord Copy = Bits[CurrentWord];\n      if (CurrentWord == LastWord) {\n        unsigned LastBit = (End - 1) % BITWORD_SIZE;\n        Copy &= maskTrailingOnes<BitWord>(LastBit + 1);\n      }\n\n      if (CurrentWord == FirstWord) {\n        unsigned FirstBit = Begin % BITWORD_SIZE;\n        Copy &= maskTrailingZeros<BitWord>(FirstBit);\n      }\n\n      if (Copy != 0)\n        return (CurrentWord + 1) * BITWORD_SIZE - countLeadingZeros(Copy) - 1;\n    }\n\n    return -1;\n  }\n\n  /// find_first_unset_in - Returns the index of the first unset bit in the\n  /// range [Begin, End).  Returns -1 if all bits in the range are set.\n  int find_first_unset_in(unsigned Begin, unsigned End) const {\n    return find_first_in(Begin, End, /* Set = */ false);\n  }\n\n  /// find_last_unset_in - Returns the index of the last unset bit in the\n  /// range [Begin, End).  Returns -1 if all bits in the range are set.\n  int find_last_unset_in(unsigned Begin, unsigned End) const {\n    assert(Begin <= End && End <= Size);\n    if (Begin == End)\n      return -1;\n\n    unsigned LastWord = (End - 1) / BITWORD_SIZE;\n    unsigned FirstWord = Begin / BITWORD_SIZE;\n\n    for (unsigned i = LastWord + 1; i >= FirstWord + 1; --i) {\n      unsigned CurrentWord = i - 1;\n\n      BitWord Copy = Bits[CurrentWord];\n      if (CurrentWord == LastWord) {\n        unsigned LastBit = (End - 1) % BITWORD_SIZE;\n        Copy |= maskTrailingZeros<BitWord>(LastBit + 1);\n      }\n\n      if (CurrentWord == FirstWord) {\n        unsigned FirstBit = Begin % BITWORD_SIZE;\n        Copy |= maskTrailingOnes<BitWord>(FirstBit);\n      }\n\n      if (Copy != ~BitWord(0)) {\n        unsigned Result =\n            (CurrentWord + 1) * BITWORD_SIZE - countLeadingOnes(Copy) - 1;\n        return Result < Size ? Result : -1;\n      }\n    }\n    return -1;\n  }\n\n  /// find_first - Returns the index of the first set bit, -1 if none\n  /// of the bits are set.\n  int find_first() const { return find_first_in(0, Size); }\n\n  /// find_last - Returns the index of the last set bit, -1 if none of the bits\n  /// are set.\n  int find_last() const { return find_last_in(0, Size); }\n\n  /// find_next - Returns the index of the next set bit following the\n  /// \"Prev\" bit. Returns -1 if the next set bit is not found.\n  int find_next(unsigned Prev) const { return find_first_in(Prev + 1, Size); }\n\n  /// find_prev - Returns the index of the first set bit that precedes the\n  /// the bit at \\p PriorTo.  Returns -1 if all previous bits are unset.\n  int find_prev(unsigned PriorTo) const { return find_last_in(0, PriorTo); }\n\n  /// find_first_unset - Returns the index of the first unset bit, -1 if all\n  /// of the bits are set.\n  int find_first_unset() const { return find_first_unset_in(0, Size); }\n\n  /// find_next_unset - Returns the index of the next unset bit following the\n  /// \"Prev\" bit.  Returns -1 if all remaining bits are set.\n  int find_next_unset(unsigned Prev) const {\n    return find_first_unset_in(Prev + 1, Size);\n  }\n\n  /// find_last_unset - Returns the index of the last unset bit, -1 if all of\n  /// the bits are set.\n  int find_last_unset() const { return find_last_unset_in(0, Size); }\n\n  /// find_prev_unset - Returns the index of the first unset bit that precedes\n  /// the bit at \\p PriorTo.  Returns -1 if all previous bits are set.\n  int find_prev_unset(unsigned PriorTo) {\n    return find_last_unset_in(0, PriorTo);\n  }\n\n  /// clear - Removes all bits from the bitvector. Does not change capacity.\n  void clear() {\n    Size = 0;\n  }\n\n  /// resize - Grow or shrink the bitvector.\n  void resize(unsigned N, bool t = false) {\n    if (N > getBitCapacity()) {\n      unsigned OldCapacity = Bits.size();\n      grow(N);\n      init_words(Bits.drop_front(OldCapacity), t);\n    }\n\n    // Set any old unused bits that are now included in the BitVector. This\n    // may set bits that are not included in the new vector, but we will clear\n    // them back out below.\n    if (N > Size)\n      set_unused_bits(t);\n\n    // Update the size, and clear out any bits that are now unused\n    unsigned OldSize = Size;\n    Size = N;\n    if (t || N < OldSize)\n      clear_unused_bits();\n  }\n\n  void reserve(unsigned N) {\n    if (N > getBitCapacity())\n      grow(N);\n  }\n\n  // Set, reset, flip\n  BitVector &set() {\n    init_words(Bits, true);\n    clear_unused_bits();\n    return *this;\n  }\n\n  BitVector &set(unsigned Idx) {\n    assert(Bits.data() && \"Bits never allocated\");\n    Bits[Idx / BITWORD_SIZE] |= BitWord(1) << (Idx % BITWORD_SIZE);\n    return *this;\n  }\n\n  /// set - Efficiently set a range of bits in [I, E)\n  BitVector &set(unsigned I, unsigned E) {\n    assert(I <= E && \"Attempted to set backwards range!\");\n    assert(E <= size() && \"Attempted to set out-of-bounds range!\");\n\n    if (I == E) return *this;\n\n    if (I / BITWORD_SIZE == E / BITWORD_SIZE) {\n      BitWord EMask = BitWord(1) << (E % BITWORD_SIZE);\n      BitWord IMask = BitWord(1) << (I % BITWORD_SIZE);\n      BitWord Mask = EMask - IMask;\n      Bits[I / BITWORD_SIZE] |= Mask;\n      return *this;\n    }\n\n    BitWord PrefixMask = ~BitWord(0) << (I % BITWORD_SIZE);\n    Bits[I / BITWORD_SIZE] |= PrefixMask;\n    I = alignTo(I, BITWORD_SIZE);\n\n    for (; I + BITWORD_SIZE <= E; I += BITWORD_SIZE)\n      Bits[I / BITWORD_SIZE] = ~BitWord(0);\n\n    BitWord PostfixMask = (BitWord(1) << (E % BITWORD_SIZE)) - 1;\n    if (I < E)\n      Bits[I / BITWORD_SIZE] |= PostfixMask;\n\n    return *this;\n  }\n\n  BitVector &reset() {\n    init_words(Bits, false);\n    return *this;\n  }\n\n  BitVector &reset(unsigned Idx) {\n    Bits[Idx / BITWORD_SIZE] &= ~(BitWord(1) << (Idx % BITWORD_SIZE));\n    return *this;\n  }\n\n  /// reset - Efficiently reset a range of bits in [I, E)\n  BitVector &reset(unsigned I, unsigned E) {\n    assert(I <= E && \"Attempted to reset backwards range!\");\n    assert(E <= size() && \"Attempted to reset out-of-bounds range!\");\n\n    if (I == E) return *this;\n\n    if (I / BITWORD_SIZE == E / BITWORD_SIZE) {\n      BitWord EMask = BitWord(1) << (E % BITWORD_SIZE);\n      BitWord IMask = BitWord(1) << (I % BITWORD_SIZE);\n      BitWord Mask = EMask - IMask;\n      Bits[I / BITWORD_SIZE] &= ~Mask;\n      return *this;\n    }\n\n    BitWord PrefixMask = ~BitWord(0) << (I % BITWORD_SIZE);\n    Bits[I / BITWORD_SIZE] &= ~PrefixMask;\n    I = alignTo(I, BITWORD_SIZE);\n\n    for (; I + BITWORD_SIZE <= E; I += BITWORD_SIZE)\n      Bits[I / BITWORD_SIZE] = BitWord(0);\n\n    BitWord PostfixMask = (BitWord(1) << (E % BITWORD_SIZE)) - 1;\n    if (I < E)\n      Bits[I / BITWORD_SIZE] &= ~PostfixMask;\n\n    return *this;\n  }\n\n  BitVector &flip() {\n    for (unsigned i = 0; i < NumBitWords(size()); ++i)\n      Bits[i] = ~Bits[i];\n    clear_unused_bits();\n    return *this;\n  }\n\n  BitVector &flip(unsigned Idx) {\n    Bits[Idx / BITWORD_SIZE] ^= BitWord(1) << (Idx % BITWORD_SIZE);\n    return *this;\n  }\n\n  // Indexing.\n  reference operator[](unsigned Idx) {\n    assert (Idx < Size && \"Out-of-bounds Bit access.\");\n    return reference(*this, Idx);\n  }\n\n  bool operator[](unsigned Idx) const {\n    assert (Idx < Size && \"Out-of-bounds Bit access.\");\n    BitWord Mask = BitWord(1) << (Idx % BITWORD_SIZE);\n    return (Bits[Idx / BITWORD_SIZE] & Mask) != 0;\n  }\n\n  bool test(unsigned Idx) const {\n    return (*this)[Idx];\n  }\n\n  // Push single bit to end of vector.\n  void push_back(bool Val) {\n    unsigned OldSize = Size;\n    unsigned NewSize = Size + 1;\n\n    // Resize, which will insert zeros.\n    // If we already fit then the unused bits will be already zero.\n    if (NewSize > getBitCapacity())\n      resize(NewSize, false);\n    else\n      Size = NewSize;\n\n    // If true, set single bit.\n    if (Val)\n      set(OldSize);\n  }\n\n  /// Test if any common bits are set.\n  bool anyCommon(const BitVector &RHS) const {\n    unsigned ThisWords = NumBitWords(size());\n    unsigned RHSWords  = NumBitWords(RHS.size());\n    for (unsigned i = 0, e = std::min(ThisWords, RHSWords); i != e; ++i)\n      if (Bits[i] & RHS.Bits[i])\n        return true;\n    return false;\n  }\n\n  // Comparison operators.\n  bool operator==(const BitVector &RHS) const {\n    if (size() != RHS.size())\n      return false;\n    unsigned NumWords = NumBitWords(size());\n    return Bits.take_front(NumWords) == RHS.Bits.take_front(NumWords);\n  }\n\n  bool operator!=(const BitVector &RHS) const {\n    return !(*this == RHS);\n  }\n\n  /// Intersection, union, disjoint union.\n  BitVector &operator&=(const BitVector &RHS) {\n    unsigned ThisWords = NumBitWords(size());\n    unsigned RHSWords  = NumBitWords(RHS.size());\n    unsigned i;\n    for (i = 0; i != std::min(ThisWords, RHSWords); ++i)\n      Bits[i] &= RHS.Bits[i];\n\n    // Any bits that are just in this bitvector become zero, because they aren't\n    // in the RHS bit vector.  Any words only in RHS are ignored because they\n    // are already zero in the LHS.\n    for (; i != ThisWords; ++i)\n      Bits[i] = 0;\n\n    return *this;\n  }\n\n  /// reset - Reset bits that are set in RHS. Same as *this &= ~RHS.\n  BitVector &reset(const BitVector &RHS) {\n    unsigned ThisWords = NumBitWords(size());\n    unsigned RHSWords  = NumBitWords(RHS.size());\n    unsigned i;\n    for (i = 0; i != std::min(ThisWords, RHSWords); ++i)\n      Bits[i] &= ~RHS.Bits[i];\n    return *this;\n  }\n\n  /// test - Check if (This - RHS) is zero.\n  /// This is the same as reset(RHS) and any().\n  bool test(const BitVector &RHS) const {\n    unsigned ThisWords = NumBitWords(size());\n    unsigned RHSWords  = NumBitWords(RHS.size());\n    unsigned i;\n    for (i = 0; i != std::min(ThisWords, RHSWords); ++i)\n      if ((Bits[i] & ~RHS.Bits[i]) != 0)\n        return true;\n\n    for (; i != ThisWords ; ++i)\n      if (Bits[i] != 0)\n        return true;\n\n    return false;\n  }\n\n  BitVector &operator|=(const BitVector &RHS) {\n    if (size() < RHS.size())\n      resize(RHS.size());\n    for (size_t i = 0, e = NumBitWords(RHS.size()); i != e; ++i)\n      Bits[i] |= RHS.Bits[i];\n    return *this;\n  }\n\n  BitVector &operator^=(const BitVector &RHS) {\n    if (size() < RHS.size())\n      resize(RHS.size());\n    for (size_t i = 0, e = NumBitWords(RHS.size()); i != e; ++i)\n      Bits[i] ^= RHS.Bits[i];\n    return *this;\n  }\n\n  BitVector &operator>>=(unsigned N) {\n    assert(N <= Size);\n    if (LLVM_UNLIKELY(empty() || N == 0))\n      return *this;\n\n    unsigned NumWords = NumBitWords(Size);\n    assert(NumWords >= 1);\n\n    wordShr(N / BITWORD_SIZE);\n\n    unsigned BitDistance = N % BITWORD_SIZE;\n    if (BitDistance == 0)\n      return *this;\n\n    // When the shift size is not a multiple of the word size, then we have\n    // a tricky situation where each word in succession needs to extract some\n    // of the bits from the next word and or them into this word while\n    // shifting this word to make room for the new bits.  This has to be done\n    // for every word in the array.\n\n    // Since we're shifting each word right, some bits will fall off the end\n    // of each word to the right, and empty space will be created on the left.\n    // The final word in the array will lose bits permanently, so starting at\n    // the beginning, work forwards shifting each word to the right, and\n    // OR'ing in the bits from the end of the next word to the beginning of\n    // the current word.\n\n    // Example:\n    //   Starting with {0xAABBCCDD, 0xEEFF0011, 0x22334455} and shifting right\n    //   by 4 bits.\n    // Step 1: Word[0] >>= 4           ; 0x0ABBCCDD\n    // Step 2: Word[0] |= 0x10000000   ; 0x1ABBCCDD\n    // Step 3: Word[1] >>= 4           ; 0x0EEFF001\n    // Step 4: Word[1] |= 0x50000000   ; 0x5EEFF001\n    // Step 5: Word[2] >>= 4           ; 0x02334455\n    // Result: { 0x1ABBCCDD, 0x5EEFF001, 0x02334455 }\n    const BitWord Mask = maskTrailingOnes<BitWord>(BitDistance);\n    const unsigned LSH = BITWORD_SIZE - BitDistance;\n\n    for (unsigned I = 0; I < NumWords - 1; ++I) {\n      Bits[I] >>= BitDistance;\n      Bits[I] |= (Bits[I + 1] & Mask) << LSH;\n    }\n\n    Bits[NumWords - 1] >>= BitDistance;\n\n    return *this;\n  }\n\n  BitVector &operator<<=(unsigned N) {\n    assert(N <= Size);\n    if (LLVM_UNLIKELY(empty() || N == 0))\n      return *this;\n\n    unsigned NumWords = NumBitWords(Size);\n    assert(NumWords >= 1);\n\n    wordShl(N / BITWORD_SIZE);\n\n    unsigned BitDistance = N % BITWORD_SIZE;\n    if (BitDistance == 0)\n      return *this;\n\n    // When the shift size is not a multiple of the word size, then we have\n    // a tricky situation where each word in succession needs to extract some\n    // of the bits from the previous word and or them into this word while\n    // shifting this word to make room for the new bits.  This has to be done\n    // for every word in the array.  This is similar to the algorithm outlined\n    // in operator>>=, but backwards.\n\n    // Since we're shifting each word left, some bits will fall off the end\n    // of each word to the left, and empty space will be created on the right.\n    // The first word in the array will lose bits permanently, so starting at\n    // the end, work backwards shifting each word to the left, and OR'ing\n    // in the bits from the end of the next word to the beginning of the\n    // current word.\n\n    // Example:\n    //   Starting with {0xAABBCCDD, 0xEEFF0011, 0x22334455} and shifting left\n    //   by 4 bits.\n    // Step 1: Word[2] <<= 4           ; 0x23344550\n    // Step 2: Word[2] |= 0x0000000E   ; 0x2334455E\n    // Step 3: Word[1] <<= 4           ; 0xEFF00110\n    // Step 4: Word[1] |= 0x0000000A   ; 0xEFF0011A\n    // Step 5: Word[0] <<= 4           ; 0xABBCCDD0\n    // Result: { 0xABBCCDD0, 0xEFF0011A, 0x2334455E }\n    const BitWord Mask = maskLeadingOnes<BitWord>(BitDistance);\n    const unsigned RSH = BITWORD_SIZE - BitDistance;\n\n    for (int I = NumWords - 1; I > 0; --I) {\n      Bits[I] <<= BitDistance;\n      Bits[I] |= (Bits[I - 1] & Mask) >> RSH;\n    }\n    Bits[0] <<= BitDistance;\n    clear_unused_bits();\n\n    return *this;\n  }\n\n  // Assignment operator.\n  const BitVector &operator=(const BitVector &RHS) {\n    if (this == &RHS) return *this;\n\n    Size = RHS.size();\n\n    // Handle tombstone when the BitVector is a key of a DenseHash.\n    if (RHS.isInvalid()) {\n      std::free(Bits.data());\n      Bits = None;\n      return *this;\n    }\n\n    unsigned RHSWords = NumBitWords(Size);\n    if (Size <= getBitCapacity()) {\n      if (Size)\n        std::memcpy(Bits.data(), RHS.Bits.data(), RHSWords * sizeof(BitWord));\n      clear_unused_bits();\n      return *this;\n    }\n\n    // Grow the bitvector to have enough elements.\n    unsigned NewCapacity = RHSWords;\n    assert(NewCapacity > 0 && \"negative capacity?\");\n    auto NewBits = allocate(NewCapacity);\n    std::memcpy(NewBits.data(), RHS.Bits.data(), NewCapacity * sizeof(BitWord));\n\n    // Destroy the old bits.\n    std::free(Bits.data());\n    Bits = NewBits;\n\n    return *this;\n  }\n\n  const BitVector &operator=(BitVector &&RHS) {\n    if (this == &RHS) return *this;\n\n    std::free(Bits.data());\n    Bits = RHS.Bits;\n    Size = RHS.Size;\n\n    RHS.Bits = MutableArrayRef<BitWord>();\n    RHS.Size = 0;\n\n    return *this;\n  }\n\n  void swap(BitVector &RHS) {\n    std::swap(Bits, RHS.Bits);\n    std::swap(Size, RHS.Size);\n  }\n\n  void invalid() {\n    assert(!Size && Bits.empty());\n    Size = (unsigned)-1;\n  }\n  bool isInvalid() const { return Size == (unsigned)-1; }\n\n  ArrayRef<BitWord> getData() const {\n    return Bits.take_front(NumBitWords(size()));\n  }\n\n  //===--------------------------------------------------------------------===//\n  // Portable bit mask operations.\n  //===--------------------------------------------------------------------===//\n  //\n  // These methods all operate on arrays of uint32_t, each holding 32 bits. The\n  // fixed word size makes it easier to work with literal bit vector constants\n  // in portable code.\n  //\n  // The LSB in each word is the lowest numbered bit.  The size of a portable\n  // bit mask is always a whole multiple of 32 bits.  If no bit mask size is\n  // given, the bit mask is assumed to cover the entire BitVector.\n\n  /// setBitsInMask - Add '1' bits from Mask to this vector. Don't resize.\n  /// This computes \"*this |= Mask\".\n  void setBitsInMask(const uint32_t *Mask, unsigned MaskWords = ~0u) {\n    applyMask<true, false>(Mask, MaskWords);\n  }\n\n  /// clearBitsInMask - Clear any bits in this vector that are set in Mask.\n  /// Don't resize. This computes \"*this &= ~Mask\".\n  void clearBitsInMask(const uint32_t *Mask, unsigned MaskWords = ~0u) {\n    applyMask<false, false>(Mask, MaskWords);\n  }\n\n  /// setBitsNotInMask - Add a bit to this vector for every '0' bit in Mask.\n  /// Don't resize.  This computes \"*this |= ~Mask\".\n  void setBitsNotInMask(const uint32_t *Mask, unsigned MaskWords = ~0u) {\n    applyMask<true, true>(Mask, MaskWords);\n  }\n\n  /// clearBitsNotInMask - Clear a bit in this vector for every '0' bit in Mask.\n  /// Don't resize.  This computes \"*this &= Mask\".\n  void clearBitsNotInMask(const uint32_t *Mask, unsigned MaskWords = ~0u) {\n    applyMask<false, true>(Mask, MaskWords);\n  }\n\nprivate:\n  /// Perform a logical left shift of \\p Count words by moving everything\n  /// \\p Count words to the right in memory.\n  ///\n  /// While confusing, words are stored from least significant at Bits[0] to\n  /// most significant at Bits[NumWords-1].  A logical shift left, however,\n  /// moves the current least significant bit to a higher logical index, and\n  /// fills the previous least significant bits with 0.  Thus, we actually\n  /// need to move the bytes of the memory to the right, not to the left.\n  /// Example:\n  ///   Words = [0xBBBBAAAA, 0xDDDDFFFF, 0x00000000, 0xDDDD0000]\n  /// represents a BitVector where 0xBBBBAAAA contain the least significant\n  /// bits.  So if we want to shift the BitVector left by 2 words, we need to\n  /// turn this into 0x00000000 0x00000000 0xBBBBAAAA 0xDDDDFFFF by using a\n  /// memmove which moves right, not left.\n  void wordShl(uint32_t Count) {\n    if (Count == 0)\n      return;\n\n    uint32_t NumWords = NumBitWords(Size);\n\n    auto Src = Bits.take_front(NumWords).drop_back(Count);\n    auto Dest = Bits.take_front(NumWords).drop_front(Count);\n\n    // Since we always move Word-sized chunks of data with src and dest both\n    // aligned to a word-boundary, we don't need to worry about endianness\n    // here.\n    std::memmove(Dest.begin(), Src.begin(), Dest.size() * sizeof(BitWord));\n    std::memset(Bits.data(), 0, Count * sizeof(BitWord));\n    clear_unused_bits();\n  }\n\n  /// Perform a logical right shift of \\p Count words by moving those\n  /// words to the left in memory.  See wordShl for more information.\n  ///\n  void wordShr(uint32_t Count) {\n    if (Count == 0)\n      return;\n\n    uint32_t NumWords = NumBitWords(Size);\n\n    auto Src = Bits.take_front(NumWords).drop_front(Count);\n    auto Dest = Bits.take_front(NumWords).drop_back(Count);\n    assert(Dest.size() == Src.size());\n\n    std::memmove(Dest.begin(), Src.begin(), Dest.size() * sizeof(BitWord));\n    std::memset(Dest.end(), 0, Count * sizeof(BitWord));\n  }\n\n  MutableArrayRef<BitWord> allocate(size_t NumWords) {\n    BitWord *RawBits = static_cast<BitWord *>(\n        safe_malloc(NumWords * sizeof(BitWord)));\n    return MutableArrayRef<BitWord>(RawBits, NumWords);\n  }\n\n  int next_unset_in_word(int WordIndex, BitWord Word) const {\n    unsigned Result = WordIndex * BITWORD_SIZE + countTrailingOnes(Word);\n    return Result < size() ? Result : -1;\n  }\n\n  unsigned NumBitWords(unsigned S) const {\n    return (S + BITWORD_SIZE-1) / BITWORD_SIZE;\n  }\n\n  // Set the unused bits in the high words.\n  void set_unused_bits(bool t = true) {\n    //  Set high words first.\n    unsigned UsedWords = NumBitWords(Size);\n    if (Bits.size() > UsedWords)\n      init_words(Bits.drop_front(UsedWords), t);\n\n    //  Then set any stray high bits of the last used word.\n    unsigned ExtraBits = Size % BITWORD_SIZE;\n    if (ExtraBits) {\n      BitWord ExtraBitMask = ~BitWord(0) << ExtraBits;\n      if (t)\n        Bits[UsedWords-1] |= ExtraBitMask;\n      else\n        Bits[UsedWords-1] &= ~ExtraBitMask;\n    }\n  }\n\n  // Clear the unused bits in the high words.\n  void clear_unused_bits() {\n    set_unused_bits(false);\n  }\n\n  void grow(unsigned NewSize) {\n    size_t NewCapacity = std::max<size_t>(NumBitWords(NewSize), Bits.size() * 2);\n    assert(NewCapacity > 0 && \"realloc-ing zero space\");\n    BitWord *NewBits = static_cast<BitWord *>(\n        safe_realloc(Bits.data(), NewCapacity * sizeof(BitWord)));\n    Bits = MutableArrayRef<BitWord>(NewBits, NewCapacity);\n    clear_unused_bits();\n  }\n\n  void init_words(MutableArrayRef<BitWord> B, bool t) {\n    if (B.size() > 0)\n      memset(B.data(), 0 - (int)t, B.size() * sizeof(BitWord));\n  }\n\n  template<bool AddBits, bool InvertMask>\n  void applyMask(const uint32_t *Mask, unsigned MaskWords) {\n    static_assert(BITWORD_SIZE % 32 == 0, \"Unsupported BitWord size.\");\n    MaskWords = std::min(MaskWords, (size() + 31) / 32);\n    const unsigned Scale = BITWORD_SIZE / 32;\n    unsigned i;\n    for (i = 0; MaskWords >= Scale; ++i, MaskWords -= Scale) {\n      BitWord BW = Bits[i];\n      // This inner loop should unroll completely when BITWORD_SIZE > 32.\n      for (unsigned b = 0; b != BITWORD_SIZE; b += 32) {\n        uint32_t M = *Mask++;\n        if (InvertMask) M = ~M;\n        if (AddBits) BW |=   BitWord(M) << b;\n        else         BW &= ~(BitWord(M) << b);\n      }\n      Bits[i] = BW;\n    }\n    for (unsigned b = 0; MaskWords; b += 32, --MaskWords) {\n      uint32_t M = *Mask++;\n      if (InvertMask) M = ~M;\n      if (AddBits) Bits[i] |=   BitWord(M) << b;\n      else         Bits[i] &= ~(BitWord(M) << b);\n    }\n    if (AddBits)\n      clear_unused_bits();\n  }\n\npublic:\n  /// Return the size (in bytes) of the bit vector.\n  size_t getMemorySize() const { return Bits.size() * sizeof(BitWord); }\n  size_t getBitCapacity() const { return Bits.size() * BITWORD_SIZE; }\n};\n\ninline size_t capacity_in_bytes(const BitVector &X) {\n  return X.getMemorySize();\n}\n\ntemplate <> struct DenseMapInfo<BitVector> {\n  static inline BitVector getEmptyKey() { return BitVector(); }\n  static inline BitVector getTombstoneKey() {\n    BitVector V;\n    V.invalid();\n    return V;\n  }\n  static unsigned getHashValue(const BitVector &V) {\n    return DenseMapInfo<std::pair<unsigned, ArrayRef<uintptr_t>>>::getHashValue(\n        std::make_pair(V.size(), V.getData()));\n  }\n  static bool isEqual(const BitVector &LHS, const BitVector &RHS) {\n    if (LHS.isInvalid() || RHS.isInvalid())\n      return LHS.isInvalid() == RHS.isInvalid();\n    return LHS == RHS;\n  }\n};\n} // end namespace llvm\n\nnamespace std {\n  /// Implement std::swap in terms of BitVector swap.\n  inline void\n  swap(llvm::BitVector &LHS, llvm::BitVector &RHS) {\n    LHS.swap(RHS);\n  }\n} // end namespace std\n\n#endif // LLVM_ADT_BITVECTOR_H\n"}, "4": {"id": 4, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/EpochTracker.h", "content": "//===- llvm/ADT/EpochTracker.h - ADT epoch tracking --------------*- C++ -*-==//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// This file defines the DebugEpochBase and DebugEpochBase::HandleBase classes.\n// These can be used to write iterators that are fail-fast when LLVM is built\n// with asserts enabled.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_ADT_EPOCHTRACKER_H\n#define LLVM_ADT_EPOCHTRACKER_H\n\n#include \"llvm/Config/abi-breaking.h\"\n\n#include <cstdint>\n\nnamespace llvm {\n\n#if LLVM_ENABLE_ABI_BREAKING_CHECKS\n\n/// A base class for data structure classes wishing to make iterators\n/// (\"handles\") pointing into themselves fail-fast.  When building without\n/// asserts, this class is empty and does nothing.\n///\n/// DebugEpochBase does not by itself track handles pointing into itself.  The\n/// expectation is that routines touching the handles will poll on\n/// isHandleInSync at appropriate points to assert that the handle they're using\n/// is still valid.\n///\nclass DebugEpochBase {\n  uint64_t Epoch;\n\npublic:\n  DebugEpochBase() : Epoch(0) {}\n\n  /// Calling incrementEpoch invalidates all handles pointing into the\n  /// calling instance.\n  void incrementEpoch() { ++Epoch; }\n\n  /// The destructor calls incrementEpoch to make use-after-free bugs\n  /// more likely to crash deterministically.\n  ~DebugEpochBase() { incrementEpoch(); }\n\n  /// A base class for iterator classes (\"handles\") that wish to poll for\n  /// iterator invalidating modifications in the underlying data structure.\n  /// When LLVM is built without asserts, this class is empty and does nothing.\n  ///\n  /// HandleBase does not track the parent data structure by itself.  It expects\n  /// the routines modifying the data structure to call incrementEpoch when they\n  /// make an iterator-invalidating modification.\n  ///\n  class HandleBase {\n    const uint64_t *EpochAddress;\n    uint64_t EpochAtCreation;\n\n  public:\n    HandleBase() : EpochAddress(nullptr), EpochAtCreation(UINT64_MAX) {}\n\n    explicit HandleBase(const DebugEpochBase *Parent)\n        : EpochAddress(&Parent->Epoch), EpochAtCreation(Parent->Epoch) {}\n\n    /// Returns true if the DebugEpochBase this Handle is linked to has\n    /// not called incrementEpoch on itself since the creation of this\n    /// HandleBase instance.\n    bool isHandleInSync() const { return *EpochAddress == EpochAtCreation; }\n\n    /// Returns a pointer to the epoch word stored in the data structure\n    /// this handle points into.  Can be used to check if two iterators point\n    /// into the same data structure.\n    const void *getEpochAddress() const { return EpochAddress; }\n  };\n};\n\n#else\n\nclass DebugEpochBase {\npublic:\n  void incrementEpoch() {}\n\n  class HandleBase {\n  public:\n    HandleBase() = default;\n    explicit HandleBase(const DebugEpochBase *) {}\n    bool isHandleInSync() const { return true; }\n    const void *getEpochAddress() const { return nullptr; }\n  };\n};\n\n#endif // LLVM_ENABLE_ABI_BREAKING_CHECKS\n\n} // namespace llvm\n\n#endif\n"}, "5": {"id": 5, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/Hashing.h", "content": "//===-- llvm/ADT/Hashing.h - Utilities for hashing --------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// This file implements the newly proposed standard C++ interfaces for hashing\n// arbitrary data and building hash functions for user-defined types. This\n// interface was originally proposed in N3333[1] and is currently under review\n// for inclusion in a future TR and/or standard.\n//\n// The primary interfaces provide are comprised of one type and three functions:\n//\n//  -- 'hash_code' class is an opaque type representing the hash code for some\n//     data. It is the intended product of hashing, and can be used to implement\n//     hash tables, checksumming, and other common uses of hashes. It is not an\n//     integer type (although it can be converted to one) because it is risky\n//     to assume much about the internals of a hash_code. In particular, each\n//     execution of the program has a high probability of producing a different\n//     hash_code for a given input. Thus their values are not stable to save or\n//     persist, and should only be used during the execution for the\n//     construction of hashing datastructures.\n//\n//  -- 'hash_value' is a function designed to be overloaded for each\n//     user-defined type which wishes to be used within a hashing context. It\n//     should be overloaded within the user-defined type's namespace and found\n//     via ADL. Overloads for primitive types are provided by this library.\n//\n//  -- 'hash_combine' and 'hash_combine_range' are functions designed to aid\n//      programmers in easily and intuitively combining a set of data into\n//      a single hash_code for their object. They should only logically be used\n//      within the implementation of a 'hash_value' routine or similar context.\n//\n// Note that 'hash_combine_range' contains very special logic for hashing\n// a contiguous array of integers or pointers. This logic is *extremely* fast,\n// on a modern Intel \"Gainestown\" Xeon (Nehalem uarch) @2.2 GHz, these were\n// benchmarked at over 6.5 GiB/s for large keys, and <20 cycles/hash for keys\n// under 32-bytes.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_ADT_HASHING_H\n#define LLVM_ADT_HASHING_H\n\n#include \"llvm/Support/DataTypes.h\"\n#include \"llvm/Support/ErrorHandling.h\"\n#include \"llvm/Support/SwapByteOrder.h\"\n#include \"llvm/Support/type_traits.h\"\n#include <algorithm>\n#include <cassert>\n#include <cstring>\n#include <string>\n#include <tuple>\n#include <utility>\n\nnamespace llvm {\n\n/// An opaque object representing a hash code.\n///\n/// This object represents the result of hashing some entity. It is intended to\n/// be used to implement hashtables or other hashing-based data structures.\n/// While it wraps and exposes a numeric value, this value should not be\n/// trusted to be stable or predictable across processes or executions.\n///\n/// In order to obtain the hash_code for an object 'x':\n/// \\code\n///   using llvm::hash_value;\n///   llvm::hash_code code = hash_value(x);\n/// \\endcode\nclass hash_code {\n  size_t value;\n\npublic:\n  /// Default construct a hash_code.\n  /// Note that this leaves the value uninitialized.\n  hash_code() = default;\n\n  /// Form a hash code directly from a numerical value.\n  hash_code(size_t value) : value(value) {}\n\n  /// Convert the hash code to its numerical value for use.\n  /*explicit*/ operator size_t() const { return value; }\n\n  friend bool operator==(const hash_code &lhs, const hash_code &rhs) {\n    return lhs.value == rhs.value;\n  }\n  friend bool operator!=(const hash_code &lhs, const hash_code &rhs) {\n    return lhs.value != rhs.value;\n  }\n\n  /// Allow a hash_code to be directly run through hash_value.\n  friend size_t hash_value(const hash_code &code) { return code.value; }\n};\n\n/// Compute a hash_code for any integer value.\n///\n/// Note that this function is intended to compute the same hash_code for\n/// a particular value without regard to the pre-promotion type. This is in\n/// contrast to hash_combine which may produce different hash_codes for\n/// differing argument types even if they would implicit promote to a common\n/// type without changing the value.\ntemplate <typename T>\nstd::enable_if_t<is_integral_or_enum<T>::value, hash_code> hash_value(T value);\n\n/// Compute a hash_code for a pointer's address.\n///\n/// N.B.: This hashes the *address*. Not the value and not the type.\ntemplate <typename T> hash_code hash_value(const T *ptr);\n\n/// Compute a hash_code for a pair of objects.\ntemplate <typename T, typename U>\nhash_code hash_value(const std::pair<T, U> &arg);\n\n/// Compute a hash_code for a tuple.\ntemplate <typename... Ts>\nhash_code hash_value(const std::tuple<Ts...> &arg);\n\n/// Compute a hash_code for a standard string.\ntemplate <typename T>\nhash_code hash_value(const std::basic_string<T> &arg);\n\n\n/// Override the execution seed with a fixed value.\n///\n/// This hashing library uses a per-execution seed designed to change on each\n/// run with high probability in order to ensure that the hash codes are not\n/// attackable and to ensure that output which is intended to be stable does\n/// not rely on the particulars of the hash codes produced.\n///\n/// That said, there are use cases where it is important to be able to\n/// reproduce *exactly* a specific behavior. To that end, we provide a function\n/// which will forcibly set the seed to a fixed value. This must be done at the\n/// start of the program, before any hashes are computed. Also, it cannot be\n/// undone. This makes it thread-hostile and very hard to use outside of\n/// immediately on start of a simple program designed for reproducible\n/// behavior.\nvoid set_fixed_execution_hash_seed(uint64_t fixed_value);\n\n\n// All of the implementation details of actually computing the various hash\n// code values are held within this namespace. These routines are included in\n// the header file mainly to allow inlining and constant propagation.\nnamespace hashing {\nnamespace detail {\n\ninline uint64_t fetch64(const char *p) {\n  uint64_t result;\n  memcpy(&result, p, sizeof(result));\n  if (sys::IsBigEndianHost)\n    sys::swapByteOrder(result);\n  return result;\n}\n\ninline uint32_t fetch32(const char *p) {\n  uint32_t result;\n  memcpy(&result, p, sizeof(result));\n  if (sys::IsBigEndianHost)\n    sys::swapByteOrder(result);\n  return result;\n}\n\n/// Some primes between 2^63 and 2^64 for various uses.\nstatic constexpr uint64_t k0 = 0xc3a5c85c97cb3127ULL;\nstatic constexpr uint64_t k1 = 0xb492b66fbe98f273ULL;\nstatic constexpr uint64_t k2 = 0x9ae16a3b2f90404fULL;\nstatic constexpr uint64_t k3 = 0xc949d7c7509e6557ULL;\n\n/// Bitwise right rotate.\n/// Normally this will compile to a single instruction, especially if the\n/// shift is a manifest constant.\ninline uint64_t rotate(uint64_t val, size_t shift) {\n  // Avoid shifting by 64: doing so yields an undefined result.\n  return shift == 0 ? val : ((val >> shift) | (val << (64 - shift)));\n}\n\ninline uint64_t shift_mix(uint64_t val) {\n  return val ^ (val >> 47);\n}\n\ninline uint64_t hash_16_bytes(uint64_t low, uint64_t high) {\n  // Murmur-inspired hashing.\n  const uint64_t kMul = 0x9ddfea08eb382d69ULL;\n  uint64_t a = (low ^ high) * kMul;\n  a ^= (a >> 47);\n  uint64_t b = (high ^ a) * kMul;\n  b ^= (b >> 47);\n  b *= kMul;\n  return b;\n}\n\ninline uint64_t hash_1to3_bytes(const char *s, size_t len, uint64_t seed) {\n  uint8_t a = s[0];\n  uint8_t b = s[len >> 1];\n  uint8_t c = s[len - 1];\n  uint32_t y = static_cast<uint32_t>(a) + (static_cast<uint32_t>(b) << 8);\n  uint32_t z = static_cast<uint32_t>(len) + (static_cast<uint32_t>(c) << 2);\n  return shift_mix(y * k2 ^ z * k3 ^ seed) * k2;\n}\n\ninline uint64_t hash_4to8_bytes(const char *s, size_t len, uint64_t seed) {\n  uint64_t a = fetch32(s);\n  return hash_16_bytes(len + (a << 3), seed ^ fetch32(s + len - 4));\n}\n\ninline uint64_t hash_9to16_bytes(const char *s, size_t len, uint64_t seed) {\n  uint64_t a = fetch64(s);\n  uint64_t b = fetch64(s + len - 8);\n  return hash_16_bytes(seed ^ a, rotate(b + len, len)) ^ b;\n}\n\ninline uint64_t hash_17to32_bytes(const char *s, size_t len, uint64_t seed) {\n  uint64_t a = fetch64(s) * k1;\n  uint64_t b = fetch64(s + 8);\n  uint64_t c = fetch64(s + len - 8) * k2;\n  uint64_t d = fetch64(s + len - 16) * k0;\n  return hash_16_bytes(rotate(a - b, 43) + rotate(c ^ seed, 30) + d,\n                       a + rotate(b ^ k3, 20) - c + len + seed);\n}\n\ninline uint64_t hash_33to64_bytes(const char *s, size_t len, uint64_t seed) {\n  uint64_t z = fetch64(s + 24);\n  uint64_t a = fetch64(s) + (len + fetch64(s + len - 16)) * k0;\n  uint64_t b = rotate(a + z, 52);\n  uint64_t c = rotate(a, 37);\n  a += fetch64(s + 8);\n  c += rotate(a, 7);\n  a += fetch64(s + 16);\n  uint64_t vf = a + z;\n  uint64_t vs = b + rotate(a, 31) + c;\n  a = fetch64(s + 16) + fetch64(s + len - 32);\n  z = fetch64(s + len - 8);\n  b = rotate(a + z, 52);\n  c = rotate(a, 37);\n  a += fetch64(s + len - 24);\n  c += rotate(a, 7);\n  a += fetch64(s + len - 16);\n  uint64_t wf = a + z;\n  uint64_t ws = b + rotate(a, 31) + c;\n  uint64_t r = shift_mix((vf + ws) * k2 + (wf + vs) * k0);\n  return shift_mix((seed ^ (r * k0)) + vs) * k2;\n}\n\ninline uint64_t hash_short(const char *s, size_t length, uint64_t seed) {\n  if (length >= 4 && length <= 8)\n    return hash_4to8_bytes(s, length, seed);\n  if (length > 8 && length <= 16)\n    return hash_9to16_bytes(s, length, seed);\n  if (length > 16 && length <= 32)\n    return hash_17to32_bytes(s, length, seed);\n  if (length > 32)\n    return hash_33to64_bytes(s, length, seed);\n  if (length != 0)\n    return hash_1to3_bytes(s, length, seed);\n\n  return k2 ^ seed;\n}\n\n/// The intermediate state used during hashing.\n/// Currently, the algorithm for computing hash codes is based on CityHash and\n/// keeps 56 bytes of arbitrary state.\nstruct hash_state {\n  uint64_t h0 = 0, h1 = 0, h2 = 0, h3 = 0, h4 = 0, h5 = 0, h6 = 0;\n\n  /// Create a new hash_state structure and initialize it based on the\n  /// seed and the first 64-byte chunk.\n  /// This effectively performs the initial mix.\n  static hash_state create(const char *s, uint64_t seed) {\n    hash_state state = {\n      0, seed, hash_16_bytes(seed, k1), rotate(seed ^ k1, 49),\n      seed * k1, shift_mix(seed), 0 };\n    state.h6 = hash_16_bytes(state.h4, state.h5);\n    state.mix(s);\n    return state;\n  }\n\n  /// Mix 32-bytes from the input sequence into the 16-bytes of 'a'\n  /// and 'b', including whatever is already in 'a' and 'b'.\n  static void mix_32_bytes(const char *s, uint64_t &a, uint64_t &b) {\n    a += fetch64(s);\n    uint64_t c = fetch64(s + 24);\n    b = rotate(b + a + c, 21);\n    uint64_t d = a;\n    a += fetch64(s + 8) + fetch64(s + 16);\n    b += rotate(a, 44) + d;\n    a += c;\n  }\n\n  /// Mix in a 64-byte buffer of data.\n  /// We mix all 64 bytes even when the chunk length is smaller, but we\n  /// record the actual length.\n  void mix(const char *s) {\n    h0 = rotate(h0 + h1 + h3 + fetch64(s + 8), 37) * k1;\n    h1 = rotate(h1 + h4 + fetch64(s + 48), 42) * k1;\n    h0 ^= h6;\n    h1 += h3 + fetch64(s + 40);\n    h2 = rotate(h2 + h5, 33) * k1;\n    h3 = h4 * k1;\n    h4 = h0 + h5;\n    mix_32_bytes(s, h3, h4);\n    h5 = h2 + h6;\n    h6 = h1 + fetch64(s + 16);\n    mix_32_bytes(s + 32, h5, h6);\n    std::swap(h2, h0);\n  }\n\n  /// Compute the final 64-bit hash code value based on the current\n  /// state and the length of bytes hashed.\n  uint64_t finalize(size_t length) {\n    return hash_16_bytes(hash_16_bytes(h3, h5) + shift_mix(h1) * k1 + h2,\n                         hash_16_bytes(h4, h6) + shift_mix(length) * k1 + h0);\n  }\n};\n\n\n/// A global, fixed seed-override variable.\n///\n/// This variable can be set using the \\see llvm::set_fixed_execution_seed\n/// function. See that function for details. Do not, under any circumstances,\n/// set or read this variable.\nextern uint64_t fixed_seed_override;\n\ninline uint64_t get_execution_seed() {\n  // FIXME: This needs to be a per-execution seed. This is just a placeholder\n  // implementation. Switching to a per-execution seed is likely to flush out\n  // instability bugs and so will happen as its own commit.\n  //\n  // However, if there is a fixed seed override set the first time this is\n  // called, return that instead of the per-execution seed.\n  const uint64_t seed_prime = 0xff51afd7ed558ccdULL;\n  static uint64_t seed = fixed_seed_override ? fixed_seed_override : seed_prime;\n  return seed;\n}\n\n\n/// Trait to indicate whether a type's bits can be hashed directly.\n///\n/// A type trait which is true if we want to combine values for hashing by\n/// reading the underlying data. It is false if values of this type must\n/// first be passed to hash_value, and the resulting hash_codes combined.\n//\n// FIXME: We want to replace is_integral_or_enum and is_pointer here with\n// a predicate which asserts that comparing the underlying storage of two\n// values of the type for equality is equivalent to comparing the two values\n// for equality. For all the platforms we care about, this holds for integers\n// and pointers, but there are platforms where it doesn't and we would like to\n// support user-defined types which happen to satisfy this property.\ntemplate <typename T> struct is_hashable_data\n  : std::integral_constant<bool, ((is_integral_or_enum<T>::value ||\n                                   std::is_pointer<T>::value) &&\n                                  64 % sizeof(T) == 0)> {};\n\n// Special case std::pair to detect when both types are viable and when there\n// is no alignment-derived padding in the pair. This is a bit of a lie because\n// std::pair isn't truly POD, but it's close enough in all reasonable\n// implementations for our use case of hashing the underlying data.\ntemplate <typename T, typename U> struct is_hashable_data<std::pair<T, U> >\n  : std::integral_constant<bool, (is_hashable_data<T>::value &&\n                                  is_hashable_data<U>::value &&\n                                  (sizeof(T) + sizeof(U)) ==\n                                   sizeof(std::pair<T, U>))> {};\n\n/// Helper to get the hashable data representation for a type.\n/// This variant is enabled when the type itself can be used.\ntemplate <typename T>\nstd::enable_if_t<is_hashable_data<T>::value, T>\nget_hashable_data(const T &value) {\n  return value;\n}\n/// Helper to get the hashable data representation for a type.\n/// This variant is enabled when we must first call hash_value and use the\n/// result as our data.\ntemplate <typename T>\nstd::enable_if_t<!is_hashable_data<T>::value, size_t>\nget_hashable_data(const T &value) {\n  using ::llvm::hash_value;\n  return hash_value(value);\n}\n\n/// Helper to store data from a value into a buffer and advance the\n/// pointer into that buffer.\n///\n/// This routine first checks whether there is enough space in the provided\n/// buffer, and if not immediately returns false. If there is space, it\n/// copies the underlying bytes of value into the buffer, advances the\n/// buffer_ptr past the copied bytes, and returns true.\ntemplate <typename T>\nbool store_and_advance(char *&buffer_ptr, char *buffer_end, const T& value,\n                       size_t offset = 0) {\n  size_t store_size = sizeof(value) - offset;\n  if (buffer_ptr + store_size > buffer_end)\n    return false;\n  const char *value_data = reinterpret_cast<const char *>(&value);\n  memcpy(buffer_ptr, value_data + offset, store_size);\n  buffer_ptr += store_size;\n  return true;\n}\n\n/// Implement the combining of integral values into a hash_code.\n///\n/// This overload is selected when the value type of the iterator is\n/// integral. Rather than computing a hash_code for each object and then\n/// combining them, this (as an optimization) directly combines the integers.\ntemplate <typename InputIteratorT>\nhash_code hash_combine_range_impl(InputIteratorT first, InputIteratorT last) {\n  const uint64_t seed = get_execution_seed();\n  char buffer[64], *buffer_ptr = buffer;\n  char *const buffer_end = std::end(buffer);\n  while (first != last && store_and_advance(buffer_ptr, buffer_end,\n                                            get_hashable_data(*first)))\n    ++first;\n  if (first == last)\n    return hash_short(buffer, buffer_ptr - buffer, seed);\n  assert(buffer_ptr == buffer_end);\n\n  hash_state state = state.create(buffer, seed);\n  size_t length = 64;\n  while (first != last) {\n    // Fill up the buffer. We don't clear it, which re-mixes the last round\n    // when only a partial 64-byte chunk is left.\n    buffer_ptr = buffer;\n    while (first != last && store_and_advance(buffer_ptr, buffer_end,\n                                              get_hashable_data(*first)))\n      ++first;\n\n    // Rotate the buffer if we did a partial fill in order to simulate doing\n    // a mix of the last 64-bytes. That is how the algorithm works when we\n    // have a contiguous byte sequence, and we want to emulate that here.\n    std::rotate(buffer, buffer_ptr, buffer_end);\n\n    // Mix this chunk into the current state.\n    state.mix(buffer);\n    length += buffer_ptr - buffer;\n  };\n\n  return state.finalize(length);\n}\n\n/// Implement the combining of integral values into a hash_code.\n///\n/// This overload is selected when the value type of the iterator is integral\n/// and when the input iterator is actually a pointer. Rather than computing\n/// a hash_code for each object and then combining them, this (as an\n/// optimization) directly combines the integers. Also, because the integers\n/// are stored in contiguous memory, this routine avoids copying each value\n/// and directly reads from the underlying memory.\ntemplate <typename ValueT>\nstd::enable_if_t<is_hashable_data<ValueT>::value, hash_code>\nhash_combine_range_impl(ValueT *first, ValueT *last) {\n  const uint64_t seed = get_execution_seed();\n  const char *s_begin = reinterpret_cast<const char *>(first);\n  const char *s_end = reinterpret_cast<const char *>(last);\n  const size_t length = std::distance(s_begin, s_end);\n  if (length <= 64)\n    return hash_short(s_begin, length, seed);\n\n  const char *s_aligned_end = s_begin + (length & ~63);\n  hash_state state = state.create(s_begin, seed);\n  s_begin += 64;\n  while (s_begin != s_aligned_end) {\n    state.mix(s_begin);\n    s_begin += 64;\n  }\n  if (length & 63)\n    state.mix(s_end - 64);\n\n  return state.finalize(length);\n}\n\n} // namespace detail\n} // namespace hashing\n\n\n/// Compute a hash_code for a sequence of values.\n///\n/// This hashes a sequence of values. It produces the same hash_code as\n/// 'hash_combine(a, b, c, ...)', but can run over arbitrary sized sequences\n/// and is significantly faster given pointers and types which can be hashed as\n/// a sequence of bytes.\ntemplate <typename InputIteratorT>\nhash_code hash_combine_range(InputIteratorT first, InputIteratorT last) {\n  return ::llvm::hashing::detail::hash_combine_range_impl(first, last);\n}\n\n\n// Implementation details for hash_combine.\nnamespace hashing {\nnamespace detail {\n\n/// Helper class to manage the recursive combining of hash_combine\n/// arguments.\n///\n/// This class exists to manage the state and various calls involved in the\n/// recursive combining of arguments used in hash_combine. It is particularly\n/// useful at minimizing the code in the recursive calls to ease the pain\n/// caused by a lack of variadic functions.\nstruct hash_combine_recursive_helper {\n  char buffer[64] = {};\n  hash_state state;\n  const uint64_t seed;\n\npublic:\n  /// Construct a recursive hash combining helper.\n  ///\n  /// This sets up the state for a recursive hash combine, including getting\n  /// the seed and buffer setup.\n  hash_combine_recursive_helper()\n    : seed(get_execution_seed()) {}\n\n  /// Combine one chunk of data into the current in-flight hash.\n  ///\n  /// This merges one chunk of data into the hash. First it tries to buffer\n  /// the data. If the buffer is full, it hashes the buffer into its\n  /// hash_state, empties it, and then merges the new chunk in. This also\n  /// handles cases where the data straddles the end of the buffer.\n  template <typename T>\n  char *combine_data(size_t &length, char *buffer_ptr, char *buffer_end, T data) {\n    if (!store_and_advance(buffer_ptr, buffer_end, data)) {\n      // Check for skew which prevents the buffer from being packed, and do\n      // a partial store into the buffer to fill it. This is only a concern\n      // with the variadic combine because that formation can have varying\n      // argument types.\n      size_t partial_store_size = buffer_end - buffer_ptr;\n      memcpy(buffer_ptr, &data, partial_store_size);\n\n      // If the store fails, our buffer is full and ready to hash. We have to\n      // either initialize the hash state (on the first full buffer) or mix\n      // this buffer into the existing hash state. Length tracks the *hashed*\n      // length, not the buffered length.\n      if (length == 0) {\n        state = state.create(buffer, seed);\n        length = 64;\n      } else {\n        // Mix this chunk into the current state and bump length up by 64.\n        state.mix(buffer);\n        length += 64;\n      }\n      // Reset the buffer_ptr to the head of the buffer for the next chunk of\n      // data.\n      buffer_ptr = buffer;\n\n      // Try again to store into the buffer -- this cannot fail as we only\n      // store types smaller than the buffer.\n      if (!store_and_advance(buffer_ptr, buffer_end, data,\n                             partial_store_size))\n        llvm_unreachable(\"buffer smaller than stored type\");\n    }\n    return buffer_ptr;\n  }\n\n  /// Recursive, variadic combining method.\n  ///\n  /// This function recurses through each argument, combining that argument\n  /// into a single hash.\n  template <typename T, typename ...Ts>\n  hash_code combine(size_t length, char *buffer_ptr, char *buffer_end,\n                    const T &arg, const Ts &...args) {\n    buffer_ptr = combine_data(length, buffer_ptr, buffer_end, get_hashable_data(arg));\n\n    // Recurse to the next argument.\n    return combine(length, buffer_ptr, buffer_end, args...);\n  }\n\n  /// Base case for recursive, variadic combining.\n  ///\n  /// The base case when combining arguments recursively is reached when all\n  /// arguments have been handled. It flushes the remaining buffer and\n  /// constructs a hash_code.\n  hash_code combine(size_t length, char *buffer_ptr, char *buffer_end) {\n    // Check whether the entire set of values fit in the buffer. If so, we'll\n    // use the optimized short hashing routine and skip state entirely.\n    if (length == 0)\n      return hash_short(buffer, buffer_ptr - buffer, seed);\n\n    // Mix the final buffer, rotating it if we did a partial fill in order to\n    // simulate doing a mix of the last 64-bytes. That is how the algorithm\n    // works when we have a contiguous byte sequence, and we want to emulate\n    // that here.\n    std::rotate(buffer, buffer_ptr, buffer_end);\n\n    // Mix this chunk into the current state.\n    state.mix(buffer);\n    length += buffer_ptr - buffer;\n\n    return state.finalize(length);\n  }\n};\n\n} // namespace detail\n} // namespace hashing\n\n/// Combine values into a single hash_code.\n///\n/// This routine accepts a varying number of arguments of any type. It will\n/// attempt to combine them into a single hash_code. For user-defined types it\n/// attempts to call a \\see hash_value overload (via ADL) for the type. For\n/// integer and pointer types it directly combines their data into the\n/// resulting hash_code.\n///\n/// The result is suitable for returning from a user's hash_value\n/// *implementation* for their user-defined type. Consumers of a type should\n/// *not* call this routine, they should instead call 'hash_value'.\ntemplate <typename ...Ts> hash_code hash_combine(const Ts &...args) {\n  // Recursively hash each argument using a helper class.\n  ::llvm::hashing::detail::hash_combine_recursive_helper helper;\n  return helper.combine(0, helper.buffer, helper.buffer + 64, args...);\n}\n\n// Implementation details for implementations of hash_value overloads provided\n// here.\nnamespace hashing {\nnamespace detail {\n\n/// Helper to hash the value of a single integer.\n///\n/// Overloads for smaller integer types are not provided to ensure consistent\n/// behavior in the presence of integral promotions. Essentially,\n/// \"hash_value('4')\" and \"hash_value('0' + 4)\" should be the same.\ninline hash_code hash_integer_value(uint64_t value) {\n  // Similar to hash_4to8_bytes but using a seed instead of length.\n  const uint64_t seed = get_execution_seed();\n  const char *s = reinterpret_cast<const char *>(&value);\n  const uint64_t a = fetch32(s);\n  return hash_16_bytes(seed + (a << 3), fetch32(s + 4));\n}\n\n} // namespace detail\n} // namespace hashing\n\n// Declared and documented above, but defined here so that any of the hashing\n// infrastructure is available.\ntemplate <typename T>\nstd::enable_if_t<is_integral_or_enum<T>::value, hash_code> hash_value(T value) {\n  return ::llvm::hashing::detail::hash_integer_value(\n      static_cast<uint64_t>(value));\n}\n\n// Declared and documented above, but defined here so that any of the hashing\n// infrastructure is available.\ntemplate <typename T> hash_code hash_value(const T *ptr) {\n  return ::llvm::hashing::detail::hash_integer_value(\n    reinterpret_cast<uintptr_t>(ptr));\n}\n\n// Declared and documented above, but defined here so that any of the hashing\n// infrastructure is available.\ntemplate <typename T, typename U>\nhash_code hash_value(const std::pair<T, U> &arg) {\n  return hash_combine(arg.first, arg.second);\n}\n\n// Implementation details for the hash_value overload for std::tuple<...>(...).\nnamespace hashing {\nnamespace detail {\n\ntemplate <typename... Ts, std::size_t... Indices>\nhash_code hash_value_tuple_helper(const std::tuple<Ts...> &arg,\n                                  std::index_sequence<Indices...> indices) {\n  return hash_combine(std::get<Indices>(arg)...);\n}\n\n} // namespace detail\n} // namespace hashing\n\ntemplate <typename... Ts>\nhash_code hash_value(const std::tuple<Ts...> &arg) {\n  // TODO: Use std::apply when LLVM starts using C++17.\n  return ::llvm::hashing::detail::hash_value_tuple_helper(\n      arg, typename std::index_sequence_for<Ts...>());\n}\n\n// Declared and documented above, but defined here so that any of the hashing\n// infrastructure is available.\ntemplate <typename T>\nhash_code hash_value(const std::basic_string<T> &arg) {\n  return hash_combine_range(arg.begin(), arg.end());\n}\n\n} // namespace llvm\n\n#endif\n"}, "6": {"id": 6, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/Optional.h", "content": "//===- Optional.h - Simple variant for passing optional values --*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n//  This file provides Optional, a template class modeled in the spirit of\n//  OCaml's 'opt' variant.  The idea is to strongly type whether or not\n//  a value can be optional.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_ADT_OPTIONAL_H\n#define LLVM_ADT_OPTIONAL_H\n\n#include \"llvm/ADT/Hashing.h\"\n#include \"llvm/ADT/None.h\"\n#include \"llvm/Support/Compiler.h\"\n#include \"llvm/Support/type_traits.h\"\n#include <cassert>\n#include <memory>\n#include <new>\n#include <utility>\n\nnamespace llvm {\n\nclass raw_ostream;\n\nnamespace optional_detail {\n\nstruct in_place_t {};\n\n/// Storage for any type.\n//\n// The specialization condition intentionally uses\n// llvm::is_trivially_copy_constructible instead of\n// std::is_trivially_copy_constructible.  GCC versions prior to 7.4 may\n// instantiate the copy constructor of `T` when\n// std::is_trivially_copy_constructible is instantiated.  This causes\n// compilation to fail if we query the trivially copy constructible property of\n// a class which is not copy constructible.\n//\n// The current implementation of OptionalStorage insists that in order to use\n// the trivial specialization, the value_type must be trivially copy\n// constructible and trivially copy assignable due to =default implementations\n// of the copy/move constructor/assignment.  It does not follow that this is\n// necessarily the case std::is_trivially_copyable is true (hence the expanded\n// specialization condition).\n//\n// The move constructible / assignable conditions emulate the remaining behavior\n// of std::is_trivially_copyable.\ntemplate <typename T, bool = (llvm::is_trivially_copy_constructible<T>::value &&\n                              std::is_trivially_copy_assignable<T>::value &&\n                              (std::is_trivially_move_constructible<T>::value ||\n                               !std::is_move_constructible<T>::value) &&\n                              (std::is_trivially_move_assignable<T>::value ||\n                               !std::is_move_assignable<T>::value))>\nclass OptionalStorage {\n  union {\n    char empty;\n    T value;\n  };\n  bool hasVal;\n\npublic:\n  ~OptionalStorage() { reset(); }\n\n  constexpr OptionalStorage() noexcept : empty(), hasVal(false) {}\n\n  constexpr OptionalStorage(OptionalStorage const &other) : OptionalStorage() {\n    if (other.hasValue()) {\n      emplace(other.value);\n    }\n  }\n  constexpr OptionalStorage(OptionalStorage &&other) : OptionalStorage() {\n    if (other.hasValue()) {\n      emplace(std::move(other.value));\n    }\n  }\n\n  template <class... Args>\n  constexpr explicit OptionalStorage(in_place_t, Args &&... args)\n      : value(std::forward<Args>(args)...), hasVal(true) {}\n\n  void reset() noexcept {\n    if (hasVal) {\n      value.~T();\n      hasVal = false;\n    }\n  }\n\n  constexpr bool hasValue() const noexcept { return hasVal; }\n\n  T &getValue() LLVM_LVALUE_FUNCTION noexcept {\n    assert(hasVal);\n    return value;\n  }\n  constexpr T const &getValue() const LLVM_LVALUE_FUNCTION noexcept {\n    assert(hasVal);\n    return value;\n  }\n#if LLVM_HAS_RVALUE_REFERENCE_THIS\n  T &&getValue() && noexcept {\n    assert(hasVal);\n    return std::move(value);\n  }\n#endif\n\n  template <class... Args> void emplace(Args &&... args) {\n    reset();\n    ::new ((void *)std::addressof(value)) T(std::forward<Args>(args)...);\n    hasVal = true;\n  }\n\n  OptionalStorage &operator=(T const &y) {\n    if (hasValue()) {\n      value = y;\n    } else {\n      ::new ((void *)std::addressof(value)) T(y);\n      hasVal = true;\n    }\n    return *this;\n  }\n  OptionalStorage &operator=(T &&y) {\n    if (hasValue()) {\n      value = std::move(y);\n    } else {\n      ::new ((void *)std::addressof(value)) T(std::move(y));\n      hasVal = true;\n    }\n    return *this;\n  }\n\n  OptionalStorage &operator=(OptionalStorage const &other) {\n    if (other.hasValue()) {\n      if (hasValue()) {\n        value = other.value;\n      } else {\n        ::new ((void *)std::addressof(value)) T(other.value);\n        hasVal = true;\n      }\n    } else {\n      reset();\n    }\n    return *this;\n  }\n\n  OptionalStorage &operator=(OptionalStorage &&other) {\n    if (other.hasValue()) {\n      if (hasValue()) {\n        value = std::move(other.value);\n      } else {\n        ::new ((void *)std::addressof(value)) T(std::move(other.value));\n        hasVal = true;\n      }\n    } else {\n      reset();\n    }\n    return *this;\n  }\n};\n\ntemplate <typename T> class OptionalStorage<T, true> {\n  union {\n    char empty;\n    T value;\n  };\n  bool hasVal = false;\n\npublic:\n  ~OptionalStorage() = default;\n\n  constexpr OptionalStorage() noexcept : empty{} {}\n\n  constexpr OptionalStorage(OptionalStorage const &other) = default;\n  constexpr OptionalStorage(OptionalStorage &&other) = default;\n\n  OptionalStorage &operator=(OptionalStorage const &other) = default;\n  OptionalStorage &operator=(OptionalStorage &&other) = default;\n\n  template <class... Args>\n  constexpr explicit OptionalStorage(in_place_t, Args &&... args)\n      : value(std::forward<Args>(args)...), hasVal(true) {}\n\n  void reset() noexcept {\n    if (hasVal) {\n      value.~T();\n      hasVal = false;\n    }\n  }\n\n  constexpr bool hasValue() const noexcept { return hasVal; }\n\n  T &getValue() LLVM_LVALUE_FUNCTION noexcept {\n    assert(hasVal);\n    return value;\n  }\n  constexpr T const &getValue() const LLVM_LVALUE_FUNCTION noexcept {\n    assert(hasVal);\n    return value;\n  }\n#if LLVM_HAS_RVALUE_REFERENCE_THIS\n  T &&getValue() && noexcept {\n    assert(hasVal);\n    return std::move(value);\n  }\n#endif\n\n  template <class... Args> void emplace(Args &&... args) {\n    reset();\n    ::new ((void *)std::addressof(value)) T(std::forward<Args>(args)...);\n    hasVal = true;\n  }\n\n  OptionalStorage &operator=(T const &y) {\n    if (hasValue()) {\n      value = y;\n    } else {\n      ::new ((void *)std::addressof(value)) T(y);\n      hasVal = true;\n    }\n    return *this;\n  }\n  OptionalStorage &operator=(T &&y) {\n    if (hasValue()) {\n      value = std::move(y);\n    } else {\n      ::new ((void *)std::addressof(value)) T(std::move(y));\n      hasVal = true;\n    }\n    return *this;\n  }\n};\n\n} // namespace optional_detail\n\ntemplate <typename T> class Optional {\n  optional_detail::OptionalStorage<T> Storage;\n\npublic:\n  using value_type = T;\n\n  constexpr Optional() {}\n  constexpr Optional(NoneType) {}\n\n  constexpr Optional(const T &y) : Storage(optional_detail::in_place_t{}, y) {}\n  constexpr Optional(const Optional &O) = default;\n\n  constexpr Optional(T &&y)\n      : Storage(optional_detail::in_place_t{}, std::move(y)) {}\n  constexpr Optional(Optional &&O) = default;\n\n  Optional &operator=(T &&y) {\n    Storage = std::move(y);\n    return *this;\n  }\n  Optional &operator=(Optional &&O) = default;\n\n  /// Create a new object by constructing it in place with the given arguments.\n  template <typename... ArgTypes> void emplace(ArgTypes &&... Args) {\n    Storage.emplace(std::forward<ArgTypes>(Args)...);\n  }\n\n  static constexpr Optional create(const T *y) {\n    return y ? Optional(*y) : Optional();\n  }\n\n  Optional &operator=(const T &y) {\n    Storage = y;\n    return *this;\n  }\n  Optional &operator=(const Optional &O) = default;\n\n  void reset() { Storage.reset(); }\n\n  constexpr const T *getPointer() const { return &Storage.getValue(); }\n  T *getPointer() { return &Storage.getValue(); }\n  constexpr const T &getValue() const LLVM_LVALUE_FUNCTION {\n    return Storage.getValue();\n  }\n  T &getValue() LLVM_LVALUE_FUNCTION { return Storage.getValue(); }\n\n  constexpr explicit operator bool() const { return hasValue(); }\n  constexpr bool hasValue() const { return Storage.hasValue(); }\n  constexpr const T *operator->() const { return getPointer(); }\n  T *operator->() { return getPointer(); }\n  constexpr const T &operator*() const LLVM_LVALUE_FUNCTION {\n    return getValue();\n  }\n  T &operator*() LLVM_LVALUE_FUNCTION { return getValue(); }\n\n  template <typename U>\n  constexpr T getValueOr(U &&value) const LLVM_LVALUE_FUNCTION {\n    return hasValue() ? getValue() : std::forward<U>(value);\n  }\n\n  /// Apply a function to the value if present; otherwise return None.\n  template <class Function>\n  auto map(const Function &F) const LLVM_LVALUE_FUNCTION\n      -> Optional<decltype(F(getValue()))> {\n    if (*this) return F(getValue());\n    return None;\n  }\n\n#if LLVM_HAS_RVALUE_REFERENCE_THIS\n  T &&getValue() && { return std::move(Storage.getValue()); }\n  T &&operator*() && { return std::move(Storage.getValue()); }\n\n  template <typename U>\n  T getValueOr(U &&value) && {\n    return hasValue() ? std::move(getValue()) : std::forward<U>(value);\n  }\n\n  /// Apply a function to the value if present; otherwise return None.\n  template <class Function>\n  auto map(const Function &F) &&\n      -> Optional<decltype(F(std::move(*this).getValue()))> {\n    if (*this) return F(std::move(*this).getValue());\n    return None;\n  }\n#endif\n};\n\ntemplate <class T> llvm::hash_code hash_value(const Optional<T> &O) {\n  return O ? hash_combine(true, *O) : hash_value(false);\n}\n\ntemplate <typename T, typename U>\nconstexpr bool operator==(const Optional<T> &X, const Optional<U> &Y) {\n  if (X && Y)\n    return *X == *Y;\n  return X.hasValue() == Y.hasValue();\n}\n\ntemplate <typename T, typename U>\nconstexpr bool operator!=(const Optional<T> &X, const Optional<U> &Y) {\n  return !(X == Y);\n}\n\ntemplate <typename T, typename U>\nconstexpr bool operator<(const Optional<T> &X, const Optional<U> &Y) {\n  if (X && Y)\n    return *X < *Y;\n  return X.hasValue() < Y.hasValue();\n}\n\ntemplate <typename T, typename U>\nconstexpr bool operator<=(const Optional<T> &X, const Optional<U> &Y) {\n  return !(Y < X);\n}\n\ntemplate <typename T, typename U>\nconstexpr bool operator>(const Optional<T> &X, const Optional<U> &Y) {\n  return Y < X;\n}\n\ntemplate <typename T, typename U>\nconstexpr bool operator>=(const Optional<T> &X, const Optional<U> &Y) {\n  return !(X < Y);\n}\n\ntemplate <typename T>\nconstexpr bool operator==(const Optional<T> &X, NoneType) {\n  return !X;\n}\n\ntemplate <typename T>\nconstexpr bool operator==(NoneType, const Optional<T> &X) {\n  return X == None;\n}\n\ntemplate <typename T>\nconstexpr bool operator!=(const Optional<T> &X, NoneType) {\n  return !(X == None);\n}\n\ntemplate <typename T>\nconstexpr bool operator!=(NoneType, const Optional<T> &X) {\n  return X != None;\n}\n\ntemplate <typename T> constexpr bool operator<(const Optional<T> &X, NoneType) {\n  return false;\n}\n\ntemplate <typename T> constexpr bool operator<(NoneType, const Optional<T> &X) {\n  return X.hasValue();\n}\n\ntemplate <typename T>\nconstexpr bool operator<=(const Optional<T> &X, NoneType) {\n  return !(None < X);\n}\n\ntemplate <typename T>\nconstexpr bool operator<=(NoneType, const Optional<T> &X) {\n  return !(X < None);\n}\n\ntemplate <typename T> constexpr bool operator>(const Optional<T> &X, NoneType) {\n  return None < X;\n}\n\ntemplate <typename T> constexpr bool operator>(NoneType, const Optional<T> &X) {\n  return X < None;\n}\n\ntemplate <typename T>\nconstexpr bool operator>=(const Optional<T> &X, NoneType) {\n  return None <= X;\n}\n\ntemplate <typename T>\nconstexpr bool operator>=(NoneType, const Optional<T> &X) {\n  return X <= None;\n}\n\ntemplate <typename T>\nconstexpr bool operator==(const Optional<T> &X, const T &Y) {\n  return X && *X == Y;\n}\n\ntemplate <typename T>\nconstexpr bool operator==(const T &X, const Optional<T> &Y) {\n  return Y && X == *Y;\n}\n\ntemplate <typename T>\nconstexpr bool operator!=(const Optional<T> &X, const T &Y) {\n  return !(X == Y);\n}\n\ntemplate <typename T>\nconstexpr bool operator!=(const T &X, const Optional<T> &Y) {\n  return !(X == Y);\n}\n\ntemplate <typename T>\nconstexpr bool operator<(const Optional<T> &X, const T &Y) {\n  return !X || *X < Y;\n}\n\ntemplate <typename T>\nconstexpr bool operator<(const T &X, const Optional<T> &Y) {\n  return Y && X < *Y;\n}\n\ntemplate <typename T>\nconstexpr bool operator<=(const Optional<T> &X, const T &Y) {\n  return !(Y < X);\n}\n\ntemplate <typename T>\nconstexpr bool operator<=(const T &X, const Optional<T> &Y) {\n  return !(Y < X);\n}\n\ntemplate <typename T>\nconstexpr bool operator>(const Optional<T> &X, const T &Y) {\n  return Y < X;\n}\n\ntemplate <typename T>\nconstexpr bool operator>(const T &X, const Optional<T> &Y) {\n  return Y < X;\n}\n\ntemplate <typename T>\nconstexpr bool operator>=(const Optional<T> &X, const T &Y) {\n  return !(X < Y);\n}\n\ntemplate <typename T>\nconstexpr bool operator>=(const T &X, const Optional<T> &Y) {\n  return !(X < Y);\n}\n\nraw_ostream &operator<<(raw_ostream &OS, NoneType);\n\ntemplate <typename T, typename = decltype(std::declval<raw_ostream &>()\n                                          << std::declval<const T &>())>\nraw_ostream &operator<<(raw_ostream &OS, const Optional<T> &O) {\n  if (O)\n    OS << *O;\n  else\n    OS << None;\n  return OS;\n}\n\n} // end namespace llvm\n\n#endif // LLVM_ADT_OPTIONAL_H\n"}, "7": {"id": 7, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/STLExtras.h", "content": "//===- llvm/ADT/STLExtras.h - Useful STL related functions ------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// This file contains some templates that are useful if you are working with the\n// STL at all.\n//\n// No library is required when using these functions.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_ADT_STLEXTRAS_H\n#define LLVM_ADT_STLEXTRAS_H\n\n#include \"llvm/ADT/Optional.h\"\n#include \"llvm/ADT/iterator.h\"\n#include \"llvm/ADT/iterator_range.h\"\n#include \"llvm/Config/abi-breaking.h\"\n#include \"llvm/Support/ErrorHandling.h\"\n#include <algorithm>\n#include <cassert>\n#include <cstddef>\n#include <cstdint>\n#include <cstdlib>\n#include <functional>\n#include <initializer_list>\n#include <iterator>\n#include <limits>\n#include <memory>\n#include <tuple>\n#include <type_traits>\n#include <utility>\n\n#ifdef EXPENSIVE_CHECKS\n#include <random> // for std::mt19937\n#endif\n\nnamespace llvm {\n\n// Only used by compiler if both template types are the same.  Useful when\n// using SFINAE to test for the existence of member functions.\ntemplate <typename T, T> struct SameType;\n\nnamespace detail {\n\ntemplate <typename RangeT>\nusing IterOfRange = decltype(std::begin(std::declval<RangeT &>()));\n\ntemplate <typename RangeT>\nusing ValueOfRange = typename std::remove_reference<decltype(\n    *std::begin(std::declval<RangeT &>()))>::type;\n\n} // end namespace detail\n\n//===----------------------------------------------------------------------===//\n//     Extra additions to <type_traits>\n//===----------------------------------------------------------------------===//\n\ntemplate <typename T>\nstruct negation : std::integral_constant<bool, !bool(T::value)> {};\n\ntemplate <typename...> struct conjunction : std::true_type {};\ntemplate <typename B1> struct conjunction<B1> : B1 {};\ntemplate <typename B1, typename... Bn>\nstruct conjunction<B1, Bn...>\n    : std::conditional<bool(B1::value), conjunction<Bn...>, B1>::type {};\n\ntemplate <typename T> struct make_const_ptr {\n  using type =\n      typename std::add_pointer<typename std::add_const<T>::type>::type;\n};\n\ntemplate <typename T> struct make_const_ref {\n  using type = typename std::add_lvalue_reference<\n      typename std::add_const<T>::type>::type;\n};\n\n/// Utilities for detecting if a given trait holds for some set of arguments\n/// 'Args'. For example, the given trait could be used to detect if a given type\n/// has a copy assignment operator:\n///   template<class T>\n///   using has_copy_assign_t = decltype(std::declval<T&>()\n///                                                 = std::declval<const T&>());\n///   bool fooHasCopyAssign = is_detected<has_copy_assign_t, FooClass>::value;\nnamespace detail {\ntemplate <typename...> using void_t = void;\ntemplate <class, template <class...> class Op, class... Args> struct detector {\n  using value_t = std::false_type;\n};\ntemplate <template <class...> class Op, class... Args>\nstruct detector<void_t<Op<Args...>>, Op, Args...> {\n  using value_t = std::true_type;\n};\n} // end namespace detail\n\ntemplate <template <class...> class Op, class... Args>\nusing is_detected = typename detail::detector<void, Op, Args...>::value_t;\n\n/// Check if a Callable type can be invoked with the given set of arg types.\nnamespace detail {\ntemplate <typename Callable, typename... Args>\nusing is_invocable =\n    decltype(std::declval<Callable &>()(std::declval<Args>()...));\n} // namespace detail\n\ntemplate <typename Callable, typename... Args>\nusing is_invocable = is_detected<detail::is_invocable, Callable, Args...>;\n\n/// This class provides various trait information about a callable object.\n///   * To access the number of arguments: Traits::num_args\n///   * To access the type of an argument: Traits::arg_t<Index>\n///   * To access the type of the result:  Traits::result_t\ntemplate <typename T, bool isClass = std::is_class<T>::value>\nstruct function_traits : public function_traits<decltype(&T::operator())> {};\n\n/// Overload for class function types.\ntemplate <typename ClassType, typename ReturnType, typename... Args>\nstruct function_traits<ReturnType (ClassType::*)(Args...) const, false> {\n  /// The number of arguments to this function.\n  enum { num_args = sizeof...(Args) };\n\n  /// The result type of this function.\n  using result_t = ReturnType;\n\n  /// The type of an argument to this function.\n  template <size_t Index>\n  using arg_t = typename std::tuple_element<Index, std::tuple<Args...>>::type;\n};\n/// Overload for class function types.\ntemplate <typename ClassType, typename ReturnType, typename... Args>\nstruct function_traits<ReturnType (ClassType::*)(Args...), false>\n    : function_traits<ReturnType (ClassType::*)(Args...) const> {};\n/// Overload for non-class function types.\ntemplate <typename ReturnType, typename... Args>\nstruct function_traits<ReturnType (*)(Args...), false> {\n  /// The number of arguments to this function.\n  enum { num_args = sizeof...(Args) };\n\n  /// The result type of this function.\n  using result_t = ReturnType;\n\n  /// The type of an argument to this function.\n  template <size_t i>\n  using arg_t = typename std::tuple_element<i, std::tuple<Args...>>::type;\n};\n/// Overload for non-class function type references.\ntemplate <typename ReturnType, typename... Args>\nstruct function_traits<ReturnType (&)(Args...), false>\n    : public function_traits<ReturnType (*)(Args...)> {};\n\n//===----------------------------------------------------------------------===//\n//     Extra additions to <functional>\n//===----------------------------------------------------------------------===//\n\ntemplate <class Ty> struct identity {\n  using argument_type = Ty;\n\n  Ty &operator()(Ty &self) const {\n    return self;\n  }\n  const Ty &operator()(const Ty &self) const {\n    return self;\n  }\n};\n\n/// An efficient, type-erasing, non-owning reference to a callable. This is\n/// intended for use as the type of a function parameter that is not used\n/// after the function in question returns.\n///\n/// This class does not own the callable, so it is not in general safe to store\n/// a function_ref.\ntemplate<typename Fn> class function_ref;\n\ntemplate<typename Ret, typename ...Params>\nclass function_ref<Ret(Params...)> {\n  Ret (*callback)(intptr_t callable, Params ...params) = nullptr;\n  intptr_t callable;\n\n  template<typename Callable>\n  static Ret callback_fn(intptr_t callable, Params ...params) {\n    return (*reinterpret_cast<Callable*>(callable))(\n        std::forward<Params>(params)...);\n  }\n\npublic:\n  function_ref() = default;\n  function_ref(std::nullptr_t) {}\n\n  template <typename Callable>\n  function_ref(\n      Callable &&callable,\n      // This is not the copy-constructor.\n      std::enable_if_t<\n          !std::is_same<std::remove_cv_t<std::remove_reference_t<Callable>>,\n                        function_ref>::value> * = nullptr,\n      // Functor must be callable and return a suitable type.\n      std::enable_if_t<std::is_void<Ret>::value ||\n                       std::is_convertible<decltype(std::declval<Callable>()(\n                                               std::declval<Params>()...)),\n                                           Ret>::value> * = nullptr)\n      : callback(callback_fn<typename std::remove_reference<Callable>::type>),\n        callable(reinterpret_cast<intptr_t>(&callable)) {}\n\n  Ret operator()(Params ...params) const {\n    return callback(callable, std::forward<Params>(params)...);\n  }\n\n  explicit operator bool() const { return callback; }\n};\n\n//===----------------------------------------------------------------------===//\n//     Extra additions to <iterator>\n//===----------------------------------------------------------------------===//\n\nnamespace adl_detail {\n\nusing std::begin;\n\ntemplate <typename ContainerTy>\ndecltype(auto) adl_begin(ContainerTy &&container) {\n  return begin(std::forward<ContainerTy>(container));\n}\n\nusing std::end;\n\ntemplate <typename ContainerTy>\ndecltype(auto) adl_end(ContainerTy &&container) {\n  return end(std::forward<ContainerTy>(container));\n}\n\nusing std::swap;\n\ntemplate <typename T>\nvoid adl_swap(T &&lhs, T &&rhs) noexcept(noexcept(swap(std::declval<T>(),\n                                                       std::declval<T>()))) {\n  swap(std::forward<T>(lhs), std::forward<T>(rhs));\n}\n\n} // end namespace adl_detail\n\ntemplate <typename ContainerTy>\ndecltype(auto) adl_begin(ContainerTy &&container) {\n  return adl_detail::adl_begin(std::forward<ContainerTy>(container));\n}\n\ntemplate <typename ContainerTy>\ndecltype(auto) adl_end(ContainerTy &&container) {\n  return adl_detail::adl_end(std::forward<ContainerTy>(container));\n}\n\ntemplate <typename T>\nvoid adl_swap(T &&lhs, T &&rhs) noexcept(\n    noexcept(adl_detail::adl_swap(std::declval<T>(), std::declval<T>()))) {\n  adl_detail::adl_swap(std::forward<T>(lhs), std::forward<T>(rhs));\n}\n\n/// Test whether \\p RangeOrContainer is empty. Similar to C++17 std::empty.\ntemplate <typename T>\nconstexpr bool empty(const T &RangeOrContainer) {\n  return adl_begin(RangeOrContainer) == adl_end(RangeOrContainer);\n}\n\n/// Returns true if the given container only contains a single element.\ntemplate <typename ContainerTy> bool hasSingleElement(ContainerTy &&C) {\n  auto B = std::begin(C), E = std::end(C);\n  return B != E && std::next(B) == E;\n}\n\n/// Return a range covering \\p RangeOrContainer with the first N elements\n/// excluded.\ntemplate <typename T> auto drop_begin(T &&RangeOrContainer, size_t N = 1) {\n  return make_range(std::next(adl_begin(RangeOrContainer), N),\n                    adl_end(RangeOrContainer));\n}\n\n// mapped_iterator - This is a simple iterator adapter that causes a function to\n// be applied whenever operator* is invoked on the iterator.\n\ntemplate <typename ItTy, typename FuncTy,\n          typename FuncReturnTy =\n            decltype(std::declval<FuncTy>()(*std::declval<ItTy>()))>\nclass mapped_iterator\n    : public iterator_adaptor_base<\n             mapped_iterator<ItTy, FuncTy>, ItTy,\n             typename std::iterator_traits<ItTy>::iterator_category,\n             typename std::remove_reference<FuncReturnTy>::type> {\npublic:\n  mapped_iterator(ItTy U, FuncTy F)\n    : mapped_iterator::iterator_adaptor_base(std::move(U)), F(std::move(F)) {}\n\n  ItTy getCurrent() { return this->I; }\n\n  FuncReturnTy operator*() const { return F(*this->I); }\n\nprivate:\n  FuncTy F;\n};\n\n// map_iterator - Provide a convenient way to create mapped_iterators, just like\n// make_pair is useful for creating pairs...\ntemplate <class ItTy, class FuncTy>\ninline mapped_iterator<ItTy, FuncTy> map_iterator(ItTy I, FuncTy F) {\n  return mapped_iterator<ItTy, FuncTy>(std::move(I), std::move(F));\n}\n\ntemplate <class ContainerTy, class FuncTy>\nauto map_range(ContainerTy &&C, FuncTy F) {\n  return make_range(map_iterator(C.begin(), F), map_iterator(C.end(), F));\n}\n\n/// Helper to determine if type T has a member called rbegin().\ntemplate <typename Ty> class has_rbegin_impl {\n  using yes = char[1];\n  using no = char[2];\n\n  template <typename Inner>\n  static yes& test(Inner *I, decltype(I->rbegin()) * = nullptr);\n\n  template <typename>\n  static no& test(...);\n\npublic:\n  static const bool value = sizeof(test<Ty>(nullptr)) == sizeof(yes);\n};\n\n/// Metafunction to determine if T& or T has a member called rbegin().\ntemplate <typename Ty>\nstruct has_rbegin : has_rbegin_impl<typename std::remove_reference<Ty>::type> {\n};\n\n// Returns an iterator_range over the given container which iterates in reverse.\n// Note that the container must have rbegin()/rend() methods for this to work.\ntemplate <typename ContainerTy>\nauto reverse(ContainerTy &&C,\n             std::enable_if_t<has_rbegin<ContainerTy>::value> * = nullptr) {\n  return make_range(C.rbegin(), C.rend());\n}\n\n// Returns a std::reverse_iterator wrapped around the given iterator.\ntemplate <typename IteratorTy>\nstd::reverse_iterator<IteratorTy> make_reverse_iterator(IteratorTy It) {\n  return std::reverse_iterator<IteratorTy>(It);\n}\n\n// Returns an iterator_range over the given container which iterates in reverse.\n// Note that the container must have begin()/end() methods which return\n// bidirectional iterators for this to work.\ntemplate <typename ContainerTy>\nauto reverse(ContainerTy &&C,\n             std::enable_if_t<!has_rbegin<ContainerTy>::value> * = nullptr) {\n  return make_range(llvm::make_reverse_iterator(std::end(C)),\n                    llvm::make_reverse_iterator(std::begin(C)));\n}\n\n/// An iterator adaptor that filters the elements of given inner iterators.\n///\n/// The predicate parameter should be a callable object that accepts the wrapped\n/// iterator's reference type and returns a bool. When incrementing or\n/// decrementing the iterator, it will call the predicate on each element and\n/// skip any where it returns false.\n///\n/// \\code\n///   int A[] = { 1, 2, 3, 4 };\n///   auto R = make_filter_range(A, [](int N) { return N % 2 == 1; });\n///   // R contains { 1, 3 }.\n/// \\endcode\n///\n/// Note: filter_iterator_base implements support for forward iteration.\n/// filter_iterator_impl exists to provide support for bidirectional iteration,\n/// conditional on whether the wrapped iterator supports it.\ntemplate <typename WrappedIteratorT, typename PredicateT, typename IterTag>\nclass filter_iterator_base\n    : public iterator_adaptor_base<\n          filter_iterator_base<WrappedIteratorT, PredicateT, IterTag>,\n          WrappedIteratorT,\n          typename std::common_type<\n              IterTag, typename std::iterator_traits<\n                           WrappedIteratorT>::iterator_category>::type> {\n  using BaseT = iterator_adaptor_base<\n      filter_iterator_base<WrappedIteratorT, PredicateT, IterTag>,\n      WrappedIteratorT,\n      typename std::common_type<\n          IterTag, typename std::iterator_traits<\n                       WrappedIteratorT>::iterator_category>::type>;\n\nprotected:\n  WrappedIteratorT End;\n  PredicateT Pred;\n\n  void findNextValid() {\n    while (this->I != End && !Pred(*this->I))\n      BaseT::operator++();\n  }\n\n  // Construct the iterator. The begin iterator needs to know where the end\n  // is, so that it can properly stop when it gets there. The end iterator only\n  // needs the predicate to support bidirectional iteration.\n  filter_iterator_base(WrappedIteratorT Begin, WrappedIteratorT End,\n                       PredicateT Pred)\n      : BaseT(Begin), End(End), Pred(Pred) {\n    findNextValid();\n  }\n\npublic:\n  using BaseT::operator++;\n\n  filter_iterator_base &operator++() {\n    BaseT::operator++();\n    findNextValid();\n    return *this;\n  }\n};\n\n/// Specialization of filter_iterator_base for forward iteration only.\ntemplate <typename WrappedIteratorT, typename PredicateT,\n          typename IterTag = std::forward_iterator_tag>\nclass filter_iterator_impl\n    : public filter_iterator_base<WrappedIteratorT, PredicateT, IterTag> {\n  using BaseT = filter_iterator_base<WrappedIteratorT, PredicateT, IterTag>;\n\npublic:\n  filter_iterator_impl(WrappedIteratorT Begin, WrappedIteratorT End,\n                       PredicateT Pred)\n      : BaseT(Begin, End, Pred) {}\n};\n\n/// Specialization of filter_iterator_base for bidirectional iteration.\ntemplate <typename WrappedIteratorT, typename PredicateT>\nclass filter_iterator_impl<WrappedIteratorT, PredicateT,\n                           std::bidirectional_iterator_tag>\n    : public filter_iterator_base<WrappedIteratorT, PredicateT,\n                                  std::bidirectional_iterator_tag> {\n  using BaseT = filter_iterator_base<WrappedIteratorT, PredicateT,\n                                     std::bidirectional_iterator_tag>;\n  void findPrevValid() {\n    while (!this->Pred(*this->I))\n      BaseT::operator--();\n  }\n\npublic:\n  using BaseT::operator--;\n\n  filter_iterator_impl(WrappedIteratorT Begin, WrappedIteratorT End,\n                       PredicateT Pred)\n      : BaseT(Begin, End, Pred) {}\n\n  filter_iterator_impl &operator--() {\n    BaseT::operator--();\n    findPrevValid();\n    return *this;\n  }\n};\n\nnamespace detail {\n\ntemplate <bool is_bidirectional> struct fwd_or_bidi_tag_impl {\n  using type = std::forward_iterator_tag;\n};\n\ntemplate <> struct fwd_or_bidi_tag_impl<true> {\n  using type = std::bidirectional_iterator_tag;\n};\n\n/// Helper which sets its type member to forward_iterator_tag if the category\n/// of \\p IterT does not derive from bidirectional_iterator_tag, and to\n/// bidirectional_iterator_tag otherwise.\ntemplate <typename IterT> struct fwd_or_bidi_tag {\n  using type = typename fwd_or_bidi_tag_impl<std::is_base_of<\n      std::bidirectional_iterator_tag,\n      typename std::iterator_traits<IterT>::iterator_category>::value>::type;\n};\n\n} // namespace detail\n\n/// Defines filter_iterator to a suitable specialization of\n/// filter_iterator_impl, based on the underlying iterator's category.\ntemplate <typename WrappedIteratorT, typename PredicateT>\nusing filter_iterator = filter_iterator_impl<\n    WrappedIteratorT, PredicateT,\n    typename detail::fwd_or_bidi_tag<WrappedIteratorT>::type>;\n\n/// Convenience function that takes a range of elements and a predicate,\n/// and return a new filter_iterator range.\n///\n/// FIXME: Currently if RangeT && is a rvalue reference to a temporary, the\n/// lifetime of that temporary is not kept by the returned range object, and the\n/// temporary is going to be dropped on the floor after the make_iterator_range\n/// full expression that contains this function call.\ntemplate <typename RangeT, typename PredicateT>\niterator_range<filter_iterator<detail::IterOfRange<RangeT>, PredicateT>>\nmake_filter_range(RangeT &&Range, PredicateT Pred) {\n  using FilterIteratorT =\n      filter_iterator<detail::IterOfRange<RangeT>, PredicateT>;\n  return make_range(\n      FilterIteratorT(std::begin(std::forward<RangeT>(Range)),\n                      std::end(std::forward<RangeT>(Range)), Pred),\n      FilterIteratorT(std::end(std::forward<RangeT>(Range)),\n                      std::end(std::forward<RangeT>(Range)), Pred));\n}\n\n/// A pseudo-iterator adaptor that is designed to implement \"early increment\"\n/// style loops.\n///\n/// This is *not a normal iterator* and should almost never be used directly. It\n/// is intended primarily to be used with range based for loops and some range\n/// algorithms.\n///\n/// The iterator isn't quite an `OutputIterator` or an `InputIterator` but\n/// somewhere between them. The constraints of these iterators are:\n///\n/// - On construction or after being incremented, it is comparable and\n///   dereferencable. It is *not* incrementable.\n/// - After being dereferenced, it is neither comparable nor dereferencable, it\n///   is only incrementable.\n///\n/// This means you can only dereference the iterator once, and you can only\n/// increment it once between dereferences.\ntemplate <typename WrappedIteratorT>\nclass early_inc_iterator_impl\n    : public iterator_adaptor_base<early_inc_iterator_impl<WrappedIteratorT>,\n                                   WrappedIteratorT, std::input_iterator_tag> {\n  using BaseT =\n      iterator_adaptor_base<early_inc_iterator_impl<WrappedIteratorT>,\n                            WrappedIteratorT, std::input_iterator_tag>;\n\n  using PointerT = typename std::iterator_traits<WrappedIteratorT>::pointer;\n\nprotected:\n#if LLVM_ENABLE_ABI_BREAKING_CHECKS\n  bool IsEarlyIncremented = false;\n#endif\n\npublic:\n  early_inc_iterator_impl(WrappedIteratorT I) : BaseT(I) {}\n\n  using BaseT::operator*;\n  decltype(*std::declval<WrappedIteratorT>()) operator*() {\n#if LLVM_ENABLE_ABI_BREAKING_CHECKS\n    assert(!IsEarlyIncremented && \"Cannot dereference twice!\");\n    IsEarlyIncremented = true;\n#endif\n    return *(this->I)++;\n  }\n\n  using BaseT::operator++;\n  early_inc_iterator_impl &operator++() {\n#if LLVM_ENABLE_ABI_BREAKING_CHECKS\n    assert(IsEarlyIncremented && \"Cannot increment before dereferencing!\");\n    IsEarlyIncremented = false;\n#endif\n    return *this;\n  }\n\n  friend bool operator==(const early_inc_iterator_impl &LHS,\n                         const early_inc_iterator_impl &RHS) {\n#if LLVM_ENABLE_ABI_BREAKING_CHECKS\n    assert(!LHS.IsEarlyIncremented && \"Cannot compare after dereferencing!\");\n#endif\n    return (const BaseT &)LHS == (const BaseT &)RHS;\n  }\n};\n\n/// Make a range that does early increment to allow mutation of the underlying\n/// range without disrupting iteration.\n///\n/// The underlying iterator will be incremented immediately after it is\n/// dereferenced, allowing deletion of the current node or insertion of nodes to\n/// not disrupt iteration provided they do not invalidate the *next* iterator --\n/// the current iterator can be invalidated.\n///\n/// This requires a very exact pattern of use that is only really suitable to\n/// range based for loops and other range algorithms that explicitly guarantee\n/// to dereference exactly once each element, and to increment exactly once each\n/// element.\ntemplate <typename RangeT>\niterator_range<early_inc_iterator_impl<detail::IterOfRange<RangeT>>>\nmake_early_inc_range(RangeT &&Range) {\n  using EarlyIncIteratorT =\n      early_inc_iterator_impl<detail::IterOfRange<RangeT>>;\n  return make_range(EarlyIncIteratorT(std::begin(std::forward<RangeT>(Range))),\n                    EarlyIncIteratorT(std::end(std::forward<RangeT>(Range))));\n}\n\n// forward declarations required by zip_shortest/zip_first/zip_longest\ntemplate <typename R, typename UnaryPredicate>\nbool all_of(R &&range, UnaryPredicate P);\ntemplate <typename R, typename UnaryPredicate>\nbool any_of(R &&range, UnaryPredicate P);\n\nnamespace detail {\n\nusing std::declval;\n\n// We have to alias this since inlining the actual type at the usage site\n// in the parameter list of iterator_facade_base<> below ICEs MSVC 2017.\ntemplate<typename... Iters> struct ZipTupleType {\n  using type = std::tuple<decltype(*declval<Iters>())...>;\n};\n\ntemplate <typename ZipType, typename... Iters>\nusing zip_traits = iterator_facade_base<\n    ZipType, typename std::common_type<std::bidirectional_iterator_tag,\n                                       typename std::iterator_traits<\n                                           Iters>::iterator_category...>::type,\n    // ^ TODO: Implement random access methods.\n    typename ZipTupleType<Iters...>::type,\n    typename std::iterator_traits<typename std::tuple_element<\n        0, std::tuple<Iters...>>::type>::difference_type,\n    // ^ FIXME: This follows boost::make_zip_iterator's assumption that all\n    // inner iterators have the same difference_type. It would fail if, for\n    // instance, the second field's difference_type were non-numeric while the\n    // first is.\n    typename ZipTupleType<Iters...>::type *,\n    typename ZipTupleType<Iters...>::type>;\n\ntemplate <typename ZipType, typename... Iters>\nstruct zip_common : public zip_traits<ZipType, Iters...> {\n  using Base = zip_traits<ZipType, Iters...>;\n  using value_type = typename Base::value_type;\n\n  std::tuple<Iters...> iterators;\n\nprotected:\n  template <size_t... Ns> value_type deref(std::index_sequence<Ns...>) const {\n    return value_type(*std::get<Ns>(iterators)...);\n  }\n\n  template <size_t... Ns>\n  decltype(iterators) tup_inc(std::index_sequence<Ns...>) const {\n    return std::tuple<Iters...>(std::next(std::get<Ns>(iterators))...);\n  }\n\n  template <size_t... Ns>\n  decltype(iterators) tup_dec(std::index_sequence<Ns...>) const {\n    return std::tuple<Iters...>(std::prev(std::get<Ns>(iterators))...);\n  }\n\npublic:\n  zip_common(Iters &&... ts) : iterators(std::forward<Iters>(ts)...) {}\n\n  value_type operator*() { return deref(std::index_sequence_for<Iters...>{}); }\n\n  const value_type operator*() const {\n    return deref(std::index_sequence_for<Iters...>{});\n  }\n\n  ZipType &operator++() {\n    iterators = tup_inc(std::index_sequence_for<Iters...>{});\n    return *reinterpret_cast<ZipType *>(this);\n  }\n\n  ZipType &operator--() {\n    static_assert(Base::IsBidirectional,\n                  \"All inner iterators must be at least bidirectional.\");\n    iterators = tup_dec(std::index_sequence_for<Iters...>{});\n    return *reinterpret_cast<ZipType *>(this);\n  }\n};\n\ntemplate <typename... Iters>\nstruct zip_first : public zip_common<zip_first<Iters...>, Iters...> {\n  using Base = zip_common<zip_first<Iters...>, Iters...>;\n\n  bool operator==(const zip_first<Iters...> &other) const {\n    return std::get<0>(this->iterators) == std::get<0>(other.iterators);\n  }\n\n  zip_first(Iters &&... ts) : Base(std::forward<Iters>(ts)...) {}\n};\n\ntemplate <typename... Iters>\nclass zip_shortest : public zip_common<zip_shortest<Iters...>, Iters...> {\n  template <size_t... Ns>\n  bool test(const zip_shortest<Iters...> &other,\n            std::index_sequence<Ns...>) const {\n    return all_of(std::initializer_list<bool>{std::get<Ns>(this->iterators) !=\n                                              std::get<Ns>(other.iterators)...},\n                  identity<bool>{});\n  }\n\npublic:\n  using Base = zip_common<zip_shortest<Iters...>, Iters...>;\n\n  zip_shortest(Iters &&... ts) : Base(std::forward<Iters>(ts)...) {}\n\n  bool operator==(const zip_shortest<Iters...> &other) const {\n    return !test(other, std::index_sequence_for<Iters...>{});\n  }\n};\n\ntemplate <template <typename...> class ItType, typename... Args> class zippy {\npublic:\n  using iterator = ItType<decltype(std::begin(std::declval<Args>()))...>;\n  using iterator_category = typename iterator::iterator_category;\n  using value_type = typename iterator::value_type;\n  using difference_type = typename iterator::difference_type;\n  using pointer = typename iterator::pointer;\n  using reference = typename iterator::reference;\n\nprivate:\n  std::tuple<Args...> ts;\n\n  template <size_t... Ns>\n  iterator begin_impl(std::index_sequence<Ns...>) const {\n    return iterator(std::begin(std::get<Ns>(ts))...);\n  }\n  template <size_t... Ns> iterator end_impl(std::index_sequence<Ns...>) const {\n    return iterator(std::end(std::get<Ns>(ts))...);\n  }\n\npublic:\n  zippy(Args &&... ts_) : ts(std::forward<Args>(ts_)...) {}\n\n  iterator begin() const {\n    return begin_impl(std::index_sequence_for<Args...>{});\n  }\n  iterator end() const { return end_impl(std::index_sequence_for<Args...>{}); }\n};\n\n} // end namespace detail\n\n/// zip iterator for two or more iteratable types.\ntemplate <typename T, typename U, typename... Args>\ndetail::zippy<detail::zip_shortest, T, U, Args...> zip(T &&t, U &&u,\n                                                       Args &&... args) {\n  return detail::zippy<detail::zip_shortest, T, U, Args...>(\n      std::forward<T>(t), std::forward<U>(u), std::forward<Args>(args)...);\n}\n\n/// zip iterator that, for the sake of efficiency, assumes the first iteratee to\n/// be the shortest.\ntemplate <typename T, typename U, typename... Args>\ndetail::zippy<detail::zip_first, T, U, Args...> zip_first(T &&t, U &&u,\n                                                          Args &&... args) {\n  return detail::zippy<detail::zip_first, T, U, Args...>(\n      std::forward<T>(t), std::forward<U>(u), std::forward<Args>(args)...);\n}\n\nnamespace detail {\ntemplate <typename Iter>\nIter next_or_end(const Iter &I, const Iter &End) {\n  if (I == End)\n    return End;\n  return std::next(I);\n}\n\ntemplate <typename Iter>\nauto deref_or_none(const Iter &I, const Iter &End) -> llvm::Optional<\n    std::remove_const_t<std::remove_reference_t<decltype(*I)>>> {\n  if (I == End)\n    return None;\n  return *I;\n}\n\ntemplate <typename Iter> struct ZipLongestItemType {\n  using type =\n      llvm::Optional<typename std::remove_const<typename std::remove_reference<\n          decltype(*std::declval<Iter>())>::type>::type>;\n};\n\ntemplate <typename... Iters> struct ZipLongestTupleType {\n  using type = std::tuple<typename ZipLongestItemType<Iters>::type...>;\n};\n\ntemplate <typename... Iters>\nclass zip_longest_iterator\n    : public iterator_facade_base<\n          zip_longest_iterator<Iters...>,\n          typename std::common_type<\n              std::forward_iterator_tag,\n              typename std::iterator_traits<Iters>::iterator_category...>::type,\n          typename ZipLongestTupleType<Iters...>::type,\n          typename std::iterator_traits<typename std::tuple_element<\n              0, std::tuple<Iters...>>::type>::difference_type,\n          typename ZipLongestTupleType<Iters...>::type *,\n          typename ZipLongestTupleType<Iters...>::type> {\npublic:\n  using value_type = typename ZipLongestTupleType<Iters...>::type;\n\nprivate:\n  std::tuple<Iters...> iterators;\n  std::tuple<Iters...> end_iterators;\n\n  template <size_t... Ns>\n  bool test(const zip_longest_iterator<Iters...> &other,\n            std::index_sequence<Ns...>) const {\n    return llvm::any_of(\n        std::initializer_list<bool>{std::get<Ns>(this->iterators) !=\n                                    std::get<Ns>(other.iterators)...},\n        identity<bool>{});\n  }\n\n  template <size_t... Ns> value_type deref(std::index_sequence<Ns...>) const {\n    return value_type(\n        deref_or_none(std::get<Ns>(iterators), std::get<Ns>(end_iterators))...);\n  }\n\n  template <size_t... Ns>\n  decltype(iterators) tup_inc(std::index_sequence<Ns...>) const {\n    return std::tuple<Iters...>(\n        next_or_end(std::get<Ns>(iterators), std::get<Ns>(end_iterators))...);\n  }\n\npublic:\n  zip_longest_iterator(std::pair<Iters &&, Iters &&>... ts)\n      : iterators(std::forward<Iters>(ts.first)...),\n        end_iterators(std::forward<Iters>(ts.second)...) {}\n\n  value_type operator*() { return deref(std::index_sequence_for<Iters...>{}); }\n\n  value_type operator*() const {\n    return deref(std::index_sequence_for<Iters...>{});\n  }\n\n  zip_longest_iterator<Iters...> &operator++() {\n    iterators = tup_inc(std::index_sequence_for<Iters...>{});\n    return *this;\n  }\n\n  bool operator==(const zip_longest_iterator<Iters...> &other) const {\n    return !test(other, std::index_sequence_for<Iters...>{});\n  }\n};\n\ntemplate <typename... Args> class zip_longest_range {\npublic:\n  using iterator =\n      zip_longest_iterator<decltype(adl_begin(std::declval<Args>()))...>;\n  using iterator_category = typename iterator::iterator_category;\n  using value_type = typename iterator::value_type;\n  using difference_type = typename iterator::difference_type;\n  using pointer = typename iterator::pointer;\n  using reference = typename iterator::reference;\n\nprivate:\n  std::tuple<Args...> ts;\n\n  template <size_t... Ns>\n  iterator begin_impl(std::index_sequence<Ns...>) const {\n    return iterator(std::make_pair(adl_begin(std::get<Ns>(ts)),\n                                   adl_end(std::get<Ns>(ts)))...);\n  }\n\n  template <size_t... Ns> iterator end_impl(std::index_sequence<Ns...>) const {\n    return iterator(std::make_pair(adl_end(std::get<Ns>(ts)),\n                                   adl_end(std::get<Ns>(ts)))...);\n  }\n\npublic:\n  zip_longest_range(Args &&... ts_) : ts(std::forward<Args>(ts_)...) {}\n\n  iterator begin() const {\n    return begin_impl(std::index_sequence_for<Args...>{});\n  }\n  iterator end() const { return end_impl(std::index_sequence_for<Args...>{}); }\n};\n} // namespace detail\n\n/// Iterate over two or more iterators at the same time. Iteration continues\n/// until all iterators reach the end. The llvm::Optional only contains a value\n/// if the iterator has not reached the end.\ntemplate <typename T, typename U, typename... Args>\ndetail::zip_longest_range<T, U, Args...> zip_longest(T &&t, U &&u,\n                                                     Args &&... args) {\n  return detail::zip_longest_range<T, U, Args...>(\n      std::forward<T>(t), std::forward<U>(u), std::forward<Args>(args)...);\n}\n\n/// Iterator wrapper that concatenates sequences together.\n///\n/// This can concatenate different iterators, even with different types, into\n/// a single iterator provided the value types of all the concatenated\n/// iterators expose `reference` and `pointer` types that can be converted to\n/// `ValueT &` and `ValueT *` respectively. It doesn't support more\n/// interesting/customized pointer or reference types.\n///\n/// Currently this only supports forward or higher iterator categories as\n/// inputs and always exposes a forward iterator interface.\ntemplate <typename ValueT, typename... IterTs>\nclass concat_iterator\n    : public iterator_facade_base<concat_iterator<ValueT, IterTs...>,\n                                  std::forward_iterator_tag, ValueT> {\n  using BaseT = typename concat_iterator::iterator_facade_base;\n\n  /// We store both the current and end iterators for each concatenated\n  /// sequence in a tuple of pairs.\n  ///\n  /// Note that something like iterator_range seems nice at first here, but the\n  /// range properties are of little benefit and end up getting in the way\n  /// because we need to do mutation on the current iterators.\n  std::tuple<IterTs...> Begins;\n  std::tuple<IterTs...> Ends;\n\n  /// Attempts to increment a specific iterator.\n  ///\n  /// Returns true if it was able to increment the iterator. Returns false if\n  /// the iterator is already at the end iterator.\n  template <size_t Index> bool incrementHelper() {\n    auto &Begin = std::get<Index>(Begins);\n    auto &End = std::get<Index>(Ends);\n    if (Begin == End)\n      return false;\n\n    ++Begin;\n    return true;\n  }\n\n  /// Increments the first non-end iterator.\n  ///\n  /// It is an error to call this with all iterators at the end.\n  template <size_t... Ns> void increment(std::index_sequence<Ns...>) {\n    // Build a sequence of functions to increment each iterator if possible.\n    bool (concat_iterator::*IncrementHelperFns[])() = {\n        &concat_iterator::incrementHelper<Ns>...};\n\n    // Loop over them, and stop as soon as we succeed at incrementing one.\n    for (auto &IncrementHelperFn : IncrementHelperFns)\n      if ((this->*IncrementHelperFn)())\n        return;\n\n    llvm_unreachable(\"Attempted to increment an end concat iterator!\");\n  }\n\n  /// Returns null if the specified iterator is at the end. Otherwise,\n  /// dereferences the iterator and returns the address of the resulting\n  /// reference.\n  template <size_t Index> ValueT *getHelper() const {\n    auto &Begin = std::get<Index>(Begins);\n    auto &End = std::get<Index>(Ends);\n    if (Begin == End)\n      return nullptr;\n\n    return &*Begin;\n  }\n\n  /// Finds the first non-end iterator, dereferences, and returns the resulting\n  /// reference.\n  ///\n  /// It is an error to call this with all iterators at the end.\n  template <size_t... Ns> ValueT &get(std::index_sequence<Ns...>) const {\n    // Build a sequence of functions to get from iterator if possible.\n    ValueT *(concat_iterator::*GetHelperFns[])() const = {\n        &concat_iterator::getHelper<Ns>...};\n\n    // Loop over them, and return the first result we find.\n    for (auto &GetHelperFn : GetHelperFns)\n      if (ValueT *P = (this->*GetHelperFn)())\n        return *P;\n\n    llvm_unreachable(\"Attempted to get a pointer from an end concat iterator!\");\n  }\n\npublic:\n  /// Constructs an iterator from a sequence of ranges.\n  ///\n  /// We need the full range to know how to switch between each of the\n  /// iterators.\n  template <typename... RangeTs>\n  explicit concat_iterator(RangeTs &&... Ranges)\n      : Begins(std::begin(Ranges)...), Ends(std::end(Ranges)...) {}\n\n  using BaseT::operator++;\n\n  concat_iterator &operator++() {\n    increment(std::index_sequence_for<IterTs...>());\n    return *this;\n  }\n\n  ValueT &operator*() const {\n    return get(std::index_sequence_for<IterTs...>());\n  }\n\n  bool operator==(const concat_iterator &RHS) const {\n    return Begins == RHS.Begins && Ends == RHS.Ends;\n  }\n};\n\nnamespace detail {\n\n/// Helper to store a sequence of ranges being concatenated and access them.\n///\n/// This is designed to facilitate providing actual storage when temporaries\n/// are passed into the constructor such that we can use it as part of range\n/// based for loops.\ntemplate <typename ValueT, typename... RangeTs> class concat_range {\npublic:\n  using iterator =\n      concat_iterator<ValueT,\n                      decltype(std::begin(std::declval<RangeTs &>()))...>;\n\nprivate:\n  std::tuple<RangeTs...> Ranges;\n\n  template <size_t... Ns> iterator begin_impl(std::index_sequence<Ns...>) {\n    return iterator(std::get<Ns>(Ranges)...);\n  }\n  template <size_t... Ns> iterator end_impl(std::index_sequence<Ns...>) {\n    return iterator(make_range(std::end(std::get<Ns>(Ranges)),\n                               std::end(std::get<Ns>(Ranges)))...);\n  }\n\npublic:\n  concat_range(RangeTs &&... Ranges)\n      : Ranges(std::forward<RangeTs>(Ranges)...) {}\n\n  iterator begin() { return begin_impl(std::index_sequence_for<RangeTs...>{}); }\n  iterator end() { return end_impl(std::index_sequence_for<RangeTs...>{}); }\n};\n\n} // end namespace detail\n\n/// Concatenated range across two or more ranges.\n///\n/// The desired value type must be explicitly specified.\ntemplate <typename ValueT, typename... RangeTs>\ndetail::concat_range<ValueT, RangeTs...> concat(RangeTs &&... Ranges) {\n  static_assert(sizeof...(RangeTs) > 1,\n                \"Need more than one range to concatenate!\");\n  return detail::concat_range<ValueT, RangeTs...>(\n      std::forward<RangeTs>(Ranges)...);\n}\n\n/// A utility class used to implement an iterator that contains some base object\n/// and an index. The iterator moves the index but keeps the base constant.\ntemplate <typename DerivedT, typename BaseT, typename T,\n          typename PointerT = T *, typename ReferenceT = T &>\nclass indexed_accessor_iterator\n    : public llvm::iterator_facade_base<DerivedT,\n                                        std::random_access_iterator_tag, T,\n                                        std::ptrdiff_t, PointerT, ReferenceT> {\npublic:\n  ptrdiff_t operator-(const indexed_accessor_iterator &rhs) const {\n    assert(base == rhs.base && \"incompatible iterators\");\n    return index - rhs.index;\n  }\n  bool operator==(const indexed_accessor_iterator &rhs) const {\n    return base == rhs.base && index == rhs.index;\n  }\n  bool operator<(const indexed_accessor_iterator &rhs) const {\n    assert(base == rhs.base && \"incompatible iterators\");\n    return index < rhs.index;\n  }\n\n  DerivedT &operator+=(ptrdiff_t offset) {\n    this->index += offset;\n    return static_cast<DerivedT &>(*this);\n  }\n  DerivedT &operator-=(ptrdiff_t offset) {\n    this->index -= offset;\n    return static_cast<DerivedT &>(*this);\n  }\n\n  /// Returns the current index of the iterator.\n  ptrdiff_t getIndex() const { return index; }\n\n  /// Returns the current base of the iterator.\n  const BaseT &getBase() const { return base; }\n\nprotected:\n  indexed_accessor_iterator(BaseT base, ptrdiff_t index)\n      : base(base), index(index) {}\n  BaseT base;\n  ptrdiff_t index;\n};\n\nnamespace detail {\n/// The class represents the base of a range of indexed_accessor_iterators. It\n/// provides support for many different range functionalities, e.g.\n/// drop_front/slice/etc.. Derived range classes must implement the following\n/// static methods:\n///   * ReferenceT dereference_iterator(const BaseT &base, ptrdiff_t index)\n///     - Dereference an iterator pointing to the base object at the given\n///       index.\n///   * BaseT offset_base(const BaseT &base, ptrdiff_t index)\n///     - Return a new base that is offset from the provide base by 'index'\n///       elements.\ntemplate <typename DerivedT, typename BaseT, typename T,\n          typename PointerT = T *, typename ReferenceT = T &>\nclass indexed_accessor_range_base {\npublic:\n  using RangeBaseT =\n      indexed_accessor_range_base<DerivedT, BaseT, T, PointerT, ReferenceT>;\n\n  /// An iterator element of this range.\n  class iterator : public indexed_accessor_iterator<iterator, BaseT, T,\n                                                    PointerT, ReferenceT> {\n  public:\n    // Index into this iterator, invoking a static method on the derived type.\n    ReferenceT operator*() const {\n      return DerivedT::dereference_iterator(this->getBase(), this->getIndex());\n    }\n\n  private:\n    iterator(BaseT owner, ptrdiff_t curIndex)\n        : indexed_accessor_iterator<iterator, BaseT, T, PointerT, ReferenceT>(\n              owner, curIndex) {}\n\n    /// Allow access to the constructor.\n    friend indexed_accessor_range_base<DerivedT, BaseT, T, PointerT,\n                                       ReferenceT>;\n  };\n\n  indexed_accessor_range_base(iterator begin, iterator end)\n      : base(offset_base(begin.getBase(), begin.getIndex())),\n        count(end.getIndex() - begin.getIndex()) {}\n  indexed_accessor_range_base(const iterator_range<iterator> &range)\n      : indexed_accessor_range_base(range.begin(), range.end()) {}\n  indexed_accessor_range_base(BaseT base, ptrdiff_t count)\n      : base(base), count(count) {}\n\n  iterator begin() const { return iterator(base, 0); }\n  iterator end() const { return iterator(base, count); }\n  ReferenceT operator[](size_t Index) const {\n    assert(Index < size() && \"invalid index for value range\");\n    return DerivedT::dereference_iterator(base, static_cast<ptrdiff_t>(Index));\n  }\n  ReferenceT front() const {\n    assert(!empty() && \"expected non-empty range\");\n    return (*this)[0];\n  }\n  ReferenceT back() const {\n    assert(!empty() && \"expected non-empty range\");\n    return (*this)[size() - 1];\n  }\n\n  /// Compare this range with another.\n  template <typename OtherT> bool operator==(const OtherT &other) const {\n    return size() ==\n               static_cast<size_t>(std::distance(other.begin(), other.end())) &&\n           std::equal(begin(), end(), other.begin());\n  }\n  template <typename OtherT> bool operator!=(const OtherT &other) const {\n    return !(*this == other);\n  }\n\n  /// Return the size of this range.\n  size_t size() const { return count; }\n\n  /// Return if the range is empty.\n  bool empty() const { return size() == 0; }\n\n  /// Drop the first N elements, and keep M elements.\n  DerivedT slice(size_t n, size_t m) const {\n    assert(n + m <= size() && \"invalid size specifiers\");\n    return DerivedT(offset_base(base, n), m);\n  }\n\n  /// Drop the first n elements.\n  DerivedT drop_front(size_t n = 1) const {\n    assert(size() >= n && \"Dropping more elements than exist\");\n    return slice(n, size() - n);\n  }\n  /// Drop the last n elements.\n  DerivedT drop_back(size_t n = 1) const {\n    assert(size() >= n && \"Dropping more elements than exist\");\n    return DerivedT(base, size() - n);\n  }\n\n  /// Take the first n elements.\n  DerivedT take_front(size_t n = 1) const {\n    return n < size() ? drop_back(size() - n)\n                      : static_cast<const DerivedT &>(*this);\n  }\n\n  /// Take the last n elements.\n  DerivedT take_back(size_t n = 1) const {\n    return n < size() ? drop_front(size() - n)\n                      : static_cast<const DerivedT &>(*this);\n  }\n\n  /// Allow conversion to any type accepting an iterator_range.\n  template <typename RangeT, typename = std::enable_if_t<std::is_constructible<\n                                 RangeT, iterator_range<iterator>>::value>>\n  operator RangeT() const {\n    return RangeT(iterator_range<iterator>(*this));\n  }\n\n  /// Returns the base of this range.\n  const BaseT &getBase() const { return base; }\n\nprivate:\n  /// Offset the given base by the given amount.\n  static BaseT offset_base(const BaseT &base, size_t n) {\n    return n == 0 ? base : DerivedT::offset_base(base, n);\n  }\n\nprotected:\n  indexed_accessor_range_base(const indexed_accessor_range_base &) = default;\n  indexed_accessor_range_base(indexed_accessor_range_base &&) = default;\n  indexed_accessor_range_base &\n  operator=(const indexed_accessor_range_base &) = default;\n\n  /// The base that owns the provided range of values.\n  BaseT base;\n  /// The size from the owning range.\n  ptrdiff_t count;\n};\n} // end namespace detail\n\n/// This class provides an implementation of a range of\n/// indexed_accessor_iterators where the base is not indexable. Ranges with\n/// bases that are offsetable should derive from indexed_accessor_range_base\n/// instead. Derived range classes are expected to implement the following\n/// static method:\n///   * ReferenceT dereference(const BaseT &base, ptrdiff_t index)\n///     - Dereference an iterator pointing to a parent base at the given index.\ntemplate <typename DerivedT, typename BaseT, typename T,\n          typename PointerT = T *, typename ReferenceT = T &>\nclass indexed_accessor_range\n    : public detail::indexed_accessor_range_base<\n          DerivedT, std::pair<BaseT, ptrdiff_t>, T, PointerT, ReferenceT> {\npublic:\n  indexed_accessor_range(BaseT base, ptrdiff_t startIndex, ptrdiff_t count)\n      : detail::indexed_accessor_range_base<\n            DerivedT, std::pair<BaseT, ptrdiff_t>, T, PointerT, ReferenceT>(\n            std::make_pair(base, startIndex), count) {}\n  using detail::indexed_accessor_range_base<\n      DerivedT, std::pair<BaseT, ptrdiff_t>, T, PointerT,\n      ReferenceT>::indexed_accessor_range_base;\n\n  /// Returns the current base of the range.\n  const BaseT &getBase() const { return this->base.first; }\n\n  /// Returns the current start index of the range.\n  ptrdiff_t getStartIndex() const { return this->base.second; }\n\n  /// See `detail::indexed_accessor_range_base` for details.\n  static std::pair<BaseT, ptrdiff_t>\n  offset_base(const std::pair<BaseT, ptrdiff_t> &base, ptrdiff_t index) {\n    // We encode the internal base as a pair of the derived base and a start\n    // index into the derived base.\n    return std::make_pair(base.first, base.second + index);\n  }\n  /// See `detail::indexed_accessor_range_base` for details.\n  static ReferenceT\n  dereference_iterator(const std::pair<BaseT, ptrdiff_t> &base,\n                       ptrdiff_t index) {\n    return DerivedT::dereference(base.first, base.second + index);\n  }\n};\n\n/// Given a container of pairs, return a range over the first elements.\ntemplate <typename ContainerTy> auto make_first_range(ContainerTy &&c) {\n  return llvm::map_range(\n      std::forward<ContainerTy>(c),\n      [](decltype((*std::begin(c))) elt) -> decltype((elt.first)) {\n        return elt.first;\n      });\n}\n\n/// Given a container of pairs, return a range over the second elements.\ntemplate <typename ContainerTy> auto make_second_range(ContainerTy &&c) {\n  return llvm::map_range(\n      std::forward<ContainerTy>(c),\n      [](decltype((*std::begin(c))) elt) -> decltype((elt.second)) {\n        return elt.second;\n      });\n}\n\n//===----------------------------------------------------------------------===//\n//     Extra additions to <utility>\n//===----------------------------------------------------------------------===//\n\n/// Function object to check whether the first component of a std::pair\n/// compares less than the first component of another std::pair.\nstruct less_first {\n  template <typename T> bool operator()(const T &lhs, const T &rhs) const {\n    return lhs.first < rhs.first;\n  }\n};\n\n/// Function object to check whether the second component of a std::pair\n/// compares less than the second component of another std::pair.\nstruct less_second {\n  template <typename T> bool operator()(const T &lhs, const T &rhs) const {\n    return lhs.second < rhs.second;\n  }\n};\n\n/// \\brief Function object to apply a binary function to the first component of\n/// a std::pair.\ntemplate<typename FuncTy>\nstruct on_first {\n  FuncTy func;\n\n  template <typename T>\n  decltype(auto) operator()(const T &lhs, const T &rhs) const {\n    return func(lhs.first, rhs.first);\n  }\n};\n\n/// Utility type to build an inheritance chain that makes it easy to rank\n/// overload candidates.\ntemplate <int N> struct rank : rank<N - 1> {};\ntemplate <> struct rank<0> {};\n\n/// traits class for checking whether type T is one of any of the given\n/// types in the variadic list.\ntemplate <typename T, typename... Ts> struct is_one_of {\n  static const bool value = false;\n};\n\ntemplate <typename T, typename U, typename... Ts>\nstruct is_one_of<T, U, Ts...> {\n  static const bool value =\n      std::is_same<T, U>::value || is_one_of<T, Ts...>::value;\n};\n\n/// traits class for checking whether type T is a base class for all\n///  the given types in the variadic list.\ntemplate <typename T, typename... Ts> struct are_base_of {\n  static const bool value = true;\n};\n\ntemplate <typename T, typename U, typename... Ts>\nstruct are_base_of<T, U, Ts...> {\n  static const bool value =\n      std::is_base_of<T, U>::value && are_base_of<T, Ts...>::value;\n};\n\n//===----------------------------------------------------------------------===//\n//     Extra additions for arrays\n//===----------------------------------------------------------------------===//\n\n// We have a copy here so that LLVM behaves the same when using different\n// standard libraries.\ntemplate <class Iterator, class RNG>\nvoid shuffle(Iterator first, Iterator last, RNG &&g) {\n  // It would be better to use a std::uniform_int_distribution,\n  // but that would be stdlib dependent.\n  typedef\n      typename std::iterator_traits<Iterator>::difference_type difference_type;\n  for (auto size = last - first; size > 1; ++first, (void)--size) {\n    difference_type offset = g() % size;\n    // Avoid self-assignment due to incorrect assertions in libstdc++\n    // containers (https://gcc.gnu.org/bugzilla/show_bug.cgi?id=85828).\n    if (offset != difference_type(0))\n      std::iter_swap(first, first + offset);\n  }\n}\n\n/// Find the length of an array.\ntemplate <class T, std::size_t N>\nconstexpr inline size_t array_lengthof(T (&)[N]) {\n  return N;\n}\n\n/// Adapt std::less<T> for array_pod_sort.\ntemplate<typename T>\ninline int array_pod_sort_comparator(const void *P1, const void *P2) {\n  if (std::less<T>()(*reinterpret_cast<const T*>(P1),\n                     *reinterpret_cast<const T*>(P2)))\n    return -1;\n  if (std::less<T>()(*reinterpret_cast<const T*>(P2),\n                     *reinterpret_cast<const T*>(P1)))\n    return 1;\n  return 0;\n}\n\n/// get_array_pod_sort_comparator - This is an internal helper function used to\n/// get type deduction of T right.\ntemplate<typename T>\ninline int (*get_array_pod_sort_comparator(const T &))\n             (const void*, const void*) {\n  return array_pod_sort_comparator<T>;\n}\n\n#ifdef EXPENSIVE_CHECKS\nnamespace detail {\n\ninline unsigned presortShuffleEntropy() {\n  static unsigned Result(std::random_device{}());\n  return Result;\n}\n\ntemplate <class IteratorTy>\ninline void presortShuffle(IteratorTy Start, IteratorTy End) {\n  std::mt19937 Generator(presortShuffleEntropy());\n  llvm::shuffle(Start, End, Generator);\n}\n\n} // end namespace detail\n#endif\n\n/// array_pod_sort - This sorts an array with the specified start and end\n/// extent.  This is just like std::sort, except that it calls qsort instead of\n/// using an inlined template.  qsort is slightly slower than std::sort, but\n/// most sorts are not performance critical in LLVM and std::sort has to be\n/// template instantiated for each type, leading to significant measured code\n/// bloat.  This function should generally be used instead of std::sort where\n/// possible.\n///\n/// This function assumes that you have simple POD-like types that can be\n/// compared with std::less and can be moved with memcpy.  If this isn't true,\n/// you should use std::sort.\n///\n/// NOTE: If qsort_r were portable, we could allow a custom comparator and\n/// default to std::less.\ntemplate<class IteratorTy>\ninline void array_pod_sort(IteratorTy Start, IteratorTy End) {\n  // Don't inefficiently call qsort with one element or trigger undefined\n  // behavior with an empty sequence.\n  auto NElts = End - Start;\n  if (NElts <= 1) return;\n#ifdef EXPENSIVE_CHECKS\n  detail::presortShuffle<IteratorTy>(Start, End);\n#endif\n  qsort(&*Start, NElts, sizeof(*Start), get_array_pod_sort_comparator(*Start));\n}\n\ntemplate <class IteratorTy>\ninline void array_pod_sort(\n    IteratorTy Start, IteratorTy End,\n    int (*Compare)(\n        const typename std::iterator_traits<IteratorTy>::value_type *,\n        const typename std::iterator_traits<IteratorTy>::value_type *)) {\n  // Don't inefficiently call qsort with one element or trigger undefined\n  // behavior with an empty sequence.\n  auto NElts = End - Start;\n  if (NElts <= 1) return;\n#ifdef EXPENSIVE_CHECKS\n  detail::presortShuffle<IteratorTy>(Start, End);\n#endif\n  qsort(&*Start, NElts, sizeof(*Start),\n        reinterpret_cast<int (*)(const void *, const void *)>(Compare));\n}\n\nnamespace detail {\ntemplate <typename T>\n// We can use qsort if the iterator type is a pointer and the underlying value\n// is trivially copyable.\nusing sort_trivially_copyable = conjunction<\n    std::is_pointer<T>,\n    std::is_trivially_copyable<typename std::iterator_traits<T>::value_type>>;\n} // namespace detail\n\n// Provide wrappers to std::sort which shuffle the elements before sorting\n// to help uncover non-deterministic behavior (PR35135).\ntemplate <typename IteratorTy,\n          std::enable_if_t<!detail::sort_trivially_copyable<IteratorTy>::value,\n                           int> = 0>\ninline void sort(IteratorTy Start, IteratorTy End) {\n#ifdef EXPENSIVE_CHECKS\n  detail::presortShuffle<IteratorTy>(Start, End);\n#endif\n  std::sort(Start, End);\n}\n\n// Forward trivially copyable types to array_pod_sort. This avoids a large\n// amount of code bloat for a minor performance hit.\ntemplate <typename IteratorTy,\n          std::enable_if_t<detail::sort_trivially_copyable<IteratorTy>::value,\n                           int> = 0>\ninline void sort(IteratorTy Start, IteratorTy End) {\n  array_pod_sort(Start, End);\n}\n\ntemplate <typename Container> inline void sort(Container &&C) {\n  llvm::sort(adl_begin(C), adl_end(C));\n}\n\ntemplate <typename IteratorTy, typename Compare>\ninline void sort(IteratorTy Start, IteratorTy End, Compare Comp) {\n#ifdef EXPENSIVE_CHECKS\n  detail::presortShuffle<IteratorTy>(Start, End);\n#endif\n  std::sort(Start, End, Comp);\n}\n\ntemplate <typename Container, typename Compare>\ninline void sort(Container &&C, Compare Comp) {\n  llvm::sort(adl_begin(C), adl_end(C), Comp);\n}\n\n//===----------------------------------------------------------------------===//\n//     Extra additions to <algorithm>\n//===----------------------------------------------------------------------===//\n\n/// Get the size of a range. This is a wrapper function around std::distance\n/// which is only enabled when the operation is O(1).\ntemplate <typename R>\nauto size(R &&Range,\n          std::enable_if_t<\n              std::is_base_of<std::random_access_iterator_tag,\n                              typename std::iterator_traits<decltype(\n                                  Range.begin())>::iterator_category>::value,\n              void> * = nullptr) {\n  return std::distance(Range.begin(), Range.end());\n}\n\n/// Provide wrappers to std::for_each which take ranges instead of having to\n/// pass begin/end explicitly.\ntemplate <typename R, typename UnaryFunction>\nUnaryFunction for_each(R &&Range, UnaryFunction F) {\n  return std::for_each(adl_begin(Range), adl_end(Range), F);\n}\n\n/// Provide wrappers to std::all_of which take ranges instead of having to pass\n/// begin/end explicitly.\ntemplate <typename R, typename UnaryPredicate>\nbool all_of(R &&Range, UnaryPredicate P) {\n  return std::all_of(adl_begin(Range), adl_end(Range), P);\n}\n\n/// Provide wrappers to std::any_of which take ranges instead of having to pass\n/// begin/end explicitly.\ntemplate <typename R, typename UnaryPredicate>\nbool any_of(R &&Range, UnaryPredicate P) {\n  return std::any_of(adl_begin(Range), adl_end(Range), P);\n}\n\n/// Provide wrappers to std::none_of which take ranges instead of having to pass\n/// begin/end explicitly.\ntemplate <typename R, typename UnaryPredicate>\nbool none_of(R &&Range, UnaryPredicate P) {\n  return std::none_of(adl_begin(Range), adl_end(Range), P);\n}\n\n/// Provide wrappers to std::find which take ranges instead of having to pass\n/// begin/end explicitly.\ntemplate <typename R, typename T> auto find(R &&Range, const T &Val) {\n  return std::find(adl_begin(Range), adl_end(Range), Val);\n}\n\n/// Provide wrappers to std::find_if which take ranges instead of having to pass\n/// begin/end explicitly.\ntemplate <typename R, typename UnaryPredicate>\nauto find_if(R &&Range, UnaryPredicate P) {\n  return std::find_if(adl_begin(Range), adl_end(Range), P);\n}\n\ntemplate <typename R, typename UnaryPredicate>\nauto find_if_not(R &&Range, UnaryPredicate P) {\n  return std::find_if_not(adl_begin(Range), adl_end(Range), P);\n}\n\n/// Provide wrappers to std::remove_if which take ranges instead of having to\n/// pass begin/end explicitly.\ntemplate <typename R, typename UnaryPredicate>\nauto remove_if(R &&Range, UnaryPredicate P) {\n  return std::remove_if(adl_begin(Range), adl_end(Range), P);\n}\n\n/// Provide wrappers to std::copy_if which take ranges instead of having to\n/// pass begin/end explicitly.\ntemplate <typename R, typename OutputIt, typename UnaryPredicate>\nOutputIt copy_if(R &&Range, OutputIt Out, UnaryPredicate P) {\n  return std::copy_if(adl_begin(Range), adl_end(Range), Out, P);\n}\n\ntemplate <typename R, typename OutputIt>\nOutputIt copy(R &&Range, OutputIt Out) {\n  return std::copy(adl_begin(Range), adl_end(Range), Out);\n}\n\n/// Provide wrappers to std::move which take ranges instead of having to\n/// pass begin/end explicitly.\ntemplate <typename R, typename OutputIt>\nOutputIt move(R &&Range, OutputIt Out) {\n  return std::move(adl_begin(Range), adl_end(Range), Out);\n}\n\n/// Wrapper function around std::find to detect if an element exists\n/// in a container.\ntemplate <typename R, typename E>\nbool is_contained(R &&Range, const E &Element) {\n  return std::find(adl_begin(Range), adl_end(Range), Element) != adl_end(Range);\n}\n\n/// Wrapper function around std::is_sorted to check if elements in a range \\p R\n/// are sorted with respect to a comparator \\p C.\ntemplate <typename R, typename Compare> bool is_sorted(R &&Range, Compare C) {\n  return std::is_sorted(adl_begin(Range), adl_end(Range), C);\n}\n\n/// Wrapper function around std::is_sorted to check if elements in a range \\p R\n/// are sorted in non-descending order.\ntemplate <typename R> bool is_sorted(R &&Range) {\n  return std::is_sorted(adl_begin(Range), adl_end(Range));\n}\n\n/// Wrapper function around std::count to count the number of times an element\n/// \\p Element occurs in the given range \\p Range.\ntemplate <typename R, typename E> auto count(R &&Range, const E &Element) {\n  return std::count(adl_begin(Range), adl_end(Range), Element);\n}\n\n/// Wrapper function around std::count_if to count the number of times an\n/// element satisfying a given predicate occurs in a range.\ntemplate <typename R, typename UnaryPredicate>\nauto count_if(R &&Range, UnaryPredicate P) {\n  return std::count_if(adl_begin(Range), adl_end(Range), P);\n}\n\n/// Wrapper function around std::transform to apply a function to a range and\n/// store the result elsewhere.\ntemplate <typename R, typename OutputIt, typename UnaryFunction>\nOutputIt transform(R &&Range, OutputIt d_first, UnaryFunction F) {\n  return std::transform(adl_begin(Range), adl_end(Range), d_first, F);\n}\n\n/// Provide wrappers to std::partition which take ranges instead of having to\n/// pass begin/end explicitly.\ntemplate <typename R, typename UnaryPredicate>\nauto partition(R &&Range, UnaryPredicate P) {\n  return std::partition(adl_begin(Range), adl_end(Range), P);\n}\n\n/// Provide wrappers to std::lower_bound which take ranges instead of having to\n/// pass begin/end explicitly.\ntemplate <typename R, typename T> auto lower_bound(R &&Range, T &&Value) {\n  return std::lower_bound(adl_begin(Range), adl_end(Range),\n                          std::forward<T>(Value));\n}\n\ntemplate <typename R, typename T, typename Compare>\nauto lower_bound(R &&Range, T &&Value, Compare C) {\n  return std::lower_bound(adl_begin(Range), adl_end(Range),\n                          std::forward<T>(Value), C);\n}\n\n/// Provide wrappers to std::upper_bound which take ranges instead of having to\n/// pass begin/end explicitly.\ntemplate <typename R, typename T> auto upper_bound(R &&Range, T &&Value) {\n  return std::upper_bound(adl_begin(Range), adl_end(Range),\n                          std::forward<T>(Value));\n}\n\ntemplate <typename R, typename T, typename Compare>\nauto upper_bound(R &&Range, T &&Value, Compare C) {\n  return std::upper_bound(adl_begin(Range), adl_end(Range),\n                          std::forward<T>(Value), C);\n}\n\ntemplate <typename R>\nvoid stable_sort(R &&Range) {\n  std::stable_sort(adl_begin(Range), adl_end(Range));\n}\n\ntemplate <typename R, typename Compare>\nvoid stable_sort(R &&Range, Compare C) {\n  std::stable_sort(adl_begin(Range), adl_end(Range), C);\n}\n\n/// Binary search for the first iterator in a range where a predicate is false.\n/// Requires that C is always true below some limit, and always false above it.\ntemplate <typename R, typename Predicate,\n          typename Val = decltype(*adl_begin(std::declval<R>()))>\nauto partition_point(R &&Range, Predicate P) {\n  return std::partition_point(adl_begin(Range), adl_end(Range), P);\n}\n\n/// Wrapper function around std::equal to detect if all elements\n/// in a container are same.\ntemplate <typename R>\nbool is_splat(R &&Range) {\n  size_t range_size = size(Range);\n  return range_size != 0 && (range_size == 1 ||\n         std::equal(adl_begin(Range) + 1, adl_end(Range), adl_begin(Range)));\n}\n\n/// Provide a container algorithm similar to C++ Library Fundamentals v2's\n/// `erase_if` which is equivalent to:\n///\n///   C.erase(remove_if(C, pred), C.end());\n///\n/// This version works for any container with an erase method call accepting\n/// two iterators.\ntemplate <typename Container, typename UnaryPredicate>\nvoid erase_if(Container &C, UnaryPredicate P) {\n  C.erase(remove_if(C, P), C.end());\n}\n\n/// Wrapper function to remove a value from a container:\n///\n/// C.erase(remove(C.begin(), C.end(), V), C.end());\ntemplate <typename Container, typename ValueType>\nvoid erase_value(Container &C, ValueType V) {\n  C.erase(std::remove(C.begin(), C.end(), V), C.end());\n}\n\n/// Wrapper function to append a range to a container.\n///\n/// C.insert(C.end(), R.begin(), R.end());\ntemplate <typename Container, typename Range>\ninline void append_range(Container &C, Range &&R) {\n  C.insert(C.end(), R.begin(), R.end());\n}\n\n/// Given a sequence container Cont, replace the range [ContIt, ContEnd) with\n/// the range [ValIt, ValEnd) (which is not from the same container).\ntemplate<typename Container, typename RandomAccessIterator>\nvoid replace(Container &Cont, typename Container::iterator ContIt,\n             typename Container::iterator ContEnd, RandomAccessIterator ValIt,\n             RandomAccessIterator ValEnd) {\n  while (true) {\n    if (ValIt == ValEnd) {\n      Cont.erase(ContIt, ContEnd);\n      return;\n    } else if (ContIt == ContEnd) {\n      Cont.insert(ContIt, ValIt, ValEnd);\n      return;\n    }\n    *ContIt++ = *ValIt++;\n  }\n}\n\n/// Given a sequence container Cont, replace the range [ContIt, ContEnd) with\n/// the range R.\ntemplate<typename Container, typename Range = std::initializer_list<\n                                 typename Container::value_type>>\nvoid replace(Container &Cont, typename Container::iterator ContIt,\n             typename Container::iterator ContEnd, Range R) {\n  replace(Cont, ContIt, ContEnd, R.begin(), R.end());\n}\n\n/// An STL-style algorithm similar to std::for_each that applies a second\n/// functor between every pair of elements.\n///\n/// This provides the control flow logic to, for example, print a\n/// comma-separated list:\n/// \\code\n///   interleave(names.begin(), names.end(),\n///              [&](StringRef name) { os << name; },\n///              [&] { os << \", \"; });\n/// \\endcode\ntemplate <typename ForwardIterator, typename UnaryFunctor,\n          typename NullaryFunctor,\n          typename = typename std::enable_if<\n              !std::is_constructible<StringRef, UnaryFunctor>::value &&\n              !std::is_constructible<StringRef, NullaryFunctor>::value>::type>\ninline void interleave(ForwardIterator begin, ForwardIterator end,\n                       UnaryFunctor each_fn, NullaryFunctor between_fn) {\n  if (begin == end)\n    return;\n  each_fn(*begin);\n  ++begin;\n  for (; begin != end; ++begin) {\n    between_fn();\n    each_fn(*begin);\n  }\n}\n\ntemplate <typename Container, typename UnaryFunctor, typename NullaryFunctor,\n          typename = typename std::enable_if<\n              !std::is_constructible<StringRef, UnaryFunctor>::value &&\n              !std::is_constructible<StringRef, NullaryFunctor>::value>::type>\ninline void interleave(const Container &c, UnaryFunctor each_fn,\n                       NullaryFunctor between_fn) {\n  interleave(c.begin(), c.end(), each_fn, between_fn);\n}\n\n/// Overload of interleave for the common case of string separator.\ntemplate <typename Container, typename UnaryFunctor, typename StreamT,\n          typename T = detail::ValueOfRange<Container>>\ninline void interleave(const Container &c, StreamT &os, UnaryFunctor each_fn,\n                       const StringRef &separator) {\n  interleave(c.begin(), c.end(), each_fn, [&] { os << separator; });\n}\ntemplate <typename Container, typename StreamT,\n          typename T = detail::ValueOfRange<Container>>\ninline void interleave(const Container &c, StreamT &os,\n                       const StringRef &separator) {\n  interleave(\n      c, os, [&](const T &a) { os << a; }, separator);\n}\n\ntemplate <typename Container, typename UnaryFunctor, typename StreamT,\n          typename T = detail::ValueOfRange<Container>>\ninline void interleaveComma(const Container &c, StreamT &os,\n                            UnaryFunctor each_fn) {\n  interleave(c, os, each_fn, \", \");\n}\ntemplate <typename Container, typename StreamT,\n          typename T = detail::ValueOfRange<Container>>\ninline void interleaveComma(const Container &c, StreamT &os) {\n  interleaveComma(c, os, [&](const T &a) { os << a; });\n}\n\n//===----------------------------------------------------------------------===//\n//     Extra additions to <memory>\n//===----------------------------------------------------------------------===//\n\nstruct FreeDeleter {\n  void operator()(void* v) {\n    ::free(v);\n  }\n};\n\ntemplate<typename First, typename Second>\nstruct pair_hash {\n  size_t operator()(const std::pair<First, Second> &P) const {\n    return std::hash<First>()(P.first) * 31 + std::hash<Second>()(P.second);\n  }\n};\n\n/// Binary functor that adapts to any other binary functor after dereferencing\n/// operands.\ntemplate <typename T> struct deref {\n  T func;\n\n  // Could be further improved to cope with non-derivable functors and\n  // non-binary functors (should be a variadic template member function\n  // operator()).\n  template <typename A, typename B> auto operator()(A &lhs, B &rhs) const {\n    assert(lhs);\n    assert(rhs);\n    return func(*lhs, *rhs);\n  }\n};\n\nnamespace detail {\n\ntemplate <typename R> class enumerator_iter;\n\ntemplate <typename R> struct result_pair {\n  using value_reference =\n      typename std::iterator_traits<IterOfRange<R>>::reference;\n\n  friend class enumerator_iter<R>;\n\n  result_pair() = default;\n  result_pair(std::size_t Index, IterOfRange<R> Iter)\n      : Index(Index), Iter(Iter) {}\n\n  result_pair(const result_pair<R> &Other)\n      : Index(Other.Index), Iter(Other.Iter) {}\n  result_pair &operator=(const result_pair &Other) {\n    Index = Other.Index;\n    Iter = Other.Iter;\n    return *this;\n  }\n\n  std::size_t index() const { return Index; }\n  const value_reference value() const { return *Iter; }\n  value_reference value() { return *Iter; }\n\nprivate:\n  std::size_t Index = std::numeric_limits<std::size_t>::max();\n  IterOfRange<R> Iter;\n};\n\ntemplate <typename R>\nclass enumerator_iter\n    : public iterator_facade_base<\n          enumerator_iter<R>, std::forward_iterator_tag, result_pair<R>,\n          typename std::iterator_traits<IterOfRange<R>>::difference_type,\n          typename std::iterator_traits<IterOfRange<R>>::pointer,\n          typename std::iterator_traits<IterOfRange<R>>::reference> {\n  using result_type = result_pair<R>;\n\npublic:\n  explicit enumerator_iter(IterOfRange<R> EndIter)\n      : Result(std::numeric_limits<size_t>::max(), EndIter) {}\n\n  enumerator_iter(std::size_t Index, IterOfRange<R> Iter)\n      : Result(Index, Iter) {}\n\n  result_type &operator*() { return Result; }\n  const result_type &operator*() const { return Result; }\n\n  enumerator_iter &operator++() {\n    assert(Result.Index != std::numeric_limits<size_t>::max());\n    ++Result.Iter;\n    ++Result.Index;\n    return *this;\n  }\n\n  bool operator==(const enumerator_iter &RHS) const {\n    // Don't compare indices here, only iterators.  It's possible for an end\n    // iterator to have different indices depending on whether it was created\n    // by calling std::end() versus incrementing a valid iterator.\n    return Result.Iter == RHS.Result.Iter;\n  }\n\n  enumerator_iter(const enumerator_iter &Other) : Result(Other.Result) {}\n  enumerator_iter &operator=(const enumerator_iter &Other) {\n    Result = Other.Result;\n    return *this;\n  }\n\nprivate:\n  result_type Result;\n};\n\ntemplate <typename R> class enumerator {\npublic:\n  explicit enumerator(R &&Range) : TheRange(std::forward<R>(Range)) {}\n\n  enumerator_iter<R> begin() {\n    return enumerator_iter<R>(0, std::begin(TheRange));\n  }\n\n  enumerator_iter<R> end() {\n    return enumerator_iter<R>(std::end(TheRange));\n  }\n\nprivate:\n  R TheRange;\n};\n\n} // end namespace detail\n\n/// Given an input range, returns a new range whose values are are pair (A,B)\n/// such that A is the 0-based index of the item in the sequence, and B is\n/// the value from the original sequence.  Example:\n///\n/// std::vector<char> Items = {'A', 'B', 'C', 'D'};\n/// for (auto X : enumerate(Items)) {\n///   printf(\"Item %d - %c\\n\", X.index(), X.value());\n/// }\n///\n/// Output:\n///   Item 0 - A\n///   Item 1 - B\n///   Item 2 - C\n///   Item 3 - D\n///\ntemplate <typename R> detail::enumerator<R> enumerate(R &&TheRange) {\n  return detail::enumerator<R>(std::forward<R>(TheRange));\n}\n\nnamespace detail {\n\ntemplate <typename F, typename Tuple, std::size_t... I>\ndecltype(auto) apply_tuple_impl(F &&f, Tuple &&t, std::index_sequence<I...>) {\n  return std::forward<F>(f)(std::get<I>(std::forward<Tuple>(t))...);\n}\n\n} // end namespace detail\n\n/// Given an input tuple (a1, a2, ..., an), pass the arguments of the\n/// tuple variadically to f as if by calling f(a1, a2, ..., an) and\n/// return the result.\ntemplate <typename F, typename Tuple>\ndecltype(auto) apply_tuple(F &&f, Tuple &&t) {\n  using Indices = std::make_index_sequence<\n      std::tuple_size<typename std::decay<Tuple>::type>::value>;\n\n  return detail::apply_tuple_impl(std::forward<F>(f), std::forward<Tuple>(t),\n                                  Indices{});\n}\n\n/// Return true if the sequence [Begin, End) has exactly N items. Runs in O(N)\n/// time. Not meant for use with random-access iterators.\n/// Can optionally take a predicate to filter lazily some items.\ntemplate <typename IterTy,\n          typename Pred = bool (*)(const decltype(*std::declval<IterTy>()) &)>\nbool hasNItems(\n    IterTy &&Begin, IterTy &&End, unsigned N,\n    Pred &&ShouldBeCounted =\n        [](const decltype(*std::declval<IterTy>()) &) { return true; },\n    std::enable_if_t<\n        !std::is_base_of<std::random_access_iterator_tag,\n                         typename std::iterator_traits<std::remove_reference_t<\n                             decltype(Begin)>>::iterator_category>::value,\n        void> * = nullptr) {\n  for (; N; ++Begin) {\n    if (Begin == End)\n      return false; // Too few.\n    N -= ShouldBeCounted(*Begin);\n  }\n  for (; Begin != End; ++Begin)\n    if (ShouldBeCounted(*Begin))\n      return false; // Too many.\n  return true;\n}\n\n/// Return true if the sequence [Begin, End) has N or more items. Runs in O(N)\n/// time. Not meant for use with random-access iterators.\n/// Can optionally take a predicate to lazily filter some items.\ntemplate <typename IterTy,\n          typename Pred = bool (*)(const decltype(*std::declval<IterTy>()) &)>\nbool hasNItemsOrMore(\n    IterTy &&Begin, IterTy &&End, unsigned N,\n    Pred &&ShouldBeCounted =\n        [](const decltype(*std::declval<IterTy>()) &) { return true; },\n    std::enable_if_t<\n        !std::is_base_of<std::random_access_iterator_tag,\n                         typename std::iterator_traits<std::remove_reference_t<\n                             decltype(Begin)>>::iterator_category>::value,\n        void> * = nullptr) {\n  for (; N; ++Begin) {\n    if (Begin == End)\n      return false; // Too few.\n    N -= ShouldBeCounted(*Begin);\n  }\n  return true;\n}\n\n/// Returns true if the sequence [Begin, End) has N or less items. Can\n/// optionally take a predicate to lazily filter some items.\ntemplate <typename IterTy,\n          typename Pred = bool (*)(const decltype(*std::declval<IterTy>()) &)>\nbool hasNItemsOrLess(\n    IterTy &&Begin, IterTy &&End, unsigned N,\n    Pred &&ShouldBeCounted = [](const decltype(*std::declval<IterTy>()) &) {\n      return true;\n    }) {\n  assert(N != std::numeric_limits<unsigned>::max());\n  return !hasNItemsOrMore(Begin, End, N + 1, ShouldBeCounted);\n}\n\n/// Returns true if the given container has exactly N items\ntemplate <typename ContainerTy> bool hasNItems(ContainerTy &&C, unsigned N) {\n  return hasNItems(std::begin(C), std::end(C), N);\n}\n\n/// Returns true if the given container has N or more items\ntemplate <typename ContainerTy>\nbool hasNItemsOrMore(ContainerTy &&C, unsigned N) {\n  return hasNItemsOrMore(std::begin(C), std::end(C), N);\n}\n\n/// Returns true if the given container has N or less items\ntemplate <typename ContainerTy>\nbool hasNItemsOrLess(ContainerTy &&C, unsigned N) {\n  return hasNItemsOrLess(std::begin(C), std::end(C), N);\n}\n\n/// Returns a raw pointer that represents the same address as the argument.\n///\n/// This implementation can be removed once we move to C++20 where it's defined\n/// as std::to_address().\n///\n/// The std::pointer_traits<>::to_address(p) variations of these overloads has\n/// not been implemented.\ntemplate <class Ptr> auto to_address(const Ptr &P) { return P.operator->(); }\ntemplate <class T> constexpr T *to_address(T *P) { return P; }\n\n} // end namespace llvm\n\n#endif // LLVM_ADT_STLEXTRAS_H\n"}, "8": {"id": 8, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/SmallPtrSet.h", "content": "//===- llvm/ADT/SmallPtrSet.h - 'Normally small' pointer set ----*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// This file defines the SmallPtrSet class.  See the doxygen comment for\n// SmallPtrSetImplBase for more details on the algorithm used.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_ADT_SMALLPTRSET_H\n#define LLVM_ADT_SMALLPTRSET_H\n\n#include \"llvm/ADT/EpochTracker.h\"\n#include \"llvm/Support/Compiler.h\"\n#include \"llvm/Support/ReverseIteration.h\"\n#include \"llvm/Support/type_traits.h\"\n#include <cassert>\n#include <cstddef>\n#include <cstdlib>\n#include <cstring>\n#include <initializer_list>\n#include <iterator>\n#include <utility>\n\nnamespace llvm {\n\n/// SmallPtrSetImplBase - This is the common code shared among all the\n/// SmallPtrSet<>'s, which is almost everything.  SmallPtrSet has two modes, one\n/// for small and one for large sets.\n///\n/// Small sets use an array of pointers allocated in the SmallPtrSet object,\n/// which is treated as a simple array of pointers.  When a pointer is added to\n/// the set, the array is scanned to see if the element already exists, if not\n/// the element is 'pushed back' onto the array.  If we run out of space in the\n/// array, we grow into the 'large set' case.  SmallSet should be used when the\n/// sets are often small.  In this case, no memory allocation is used, and only\n/// light-weight and cache-efficient scanning is used.\n///\n/// Large sets use a classic exponentially-probed hash table.  Empty buckets are\n/// represented with an illegal pointer value (-1) to allow null pointers to be\n/// inserted.  Tombstones are represented with another illegal pointer value\n/// (-2), to allow deletion.  The hash table is resized when the table is 3/4 or\n/// more.  When this happens, the table is doubled in size.\n///\nclass SmallPtrSetImplBase : public DebugEpochBase {\n  friend class SmallPtrSetIteratorImpl;\n\nprotected:\n  /// SmallArray - Points to a fixed size set of buckets, used in 'small mode'.\n  const void **SmallArray;\n  /// CurArray - This is the current set of buckets.  If equal to SmallArray,\n  /// then the set is in 'small mode'.\n  const void **CurArray;\n  /// CurArraySize - The allocated size of CurArray, always a power of two.\n  unsigned CurArraySize;\n\n  /// Number of elements in CurArray that contain a value or are a tombstone.\n  /// If small, all these elements are at the beginning of CurArray and the rest\n  /// is uninitialized.\n  unsigned NumNonEmpty;\n  /// Number of tombstones in CurArray.\n  unsigned NumTombstones;\n\n  // Helpers to copy and move construct a SmallPtrSet.\n  SmallPtrSetImplBase(const void **SmallStorage,\n                      const SmallPtrSetImplBase &that);\n  SmallPtrSetImplBase(const void **SmallStorage, unsigned SmallSize,\n                      SmallPtrSetImplBase &&that);\n\n  explicit SmallPtrSetImplBase(const void **SmallStorage, unsigned SmallSize)\n      : SmallArray(SmallStorage), CurArray(SmallStorage),\n        CurArraySize(SmallSize), NumNonEmpty(0), NumTombstones(0) {\n    assert(SmallSize && (SmallSize & (SmallSize-1)) == 0 &&\n           \"Initial size must be a power of two!\");\n  }\n\n  ~SmallPtrSetImplBase() {\n    if (!isSmall())\n      free(CurArray);\n  }\n\npublic:\n  using size_type = unsigned;\n\n  SmallPtrSetImplBase &operator=(const SmallPtrSetImplBase &) = delete;\n\n  LLVM_NODISCARD bool empty() const { return size() == 0; }\n  size_type size() const { return NumNonEmpty - NumTombstones; }\n\n  void clear() {\n    incrementEpoch();\n    // If the capacity of the array is huge, and the # elements used is small,\n    // shrink the array.\n    if (!isSmall()) {\n      if (size() * 4 < CurArraySize && CurArraySize > 32)\n        return shrink_and_clear();\n      // Fill the array with empty markers.\n      memset(CurArray, -1, CurArraySize * sizeof(void *));\n    }\n\n    NumNonEmpty = 0;\n    NumTombstones = 0;\n  }\n\nprotected:\n  static void *getTombstoneMarker() { return reinterpret_cast<void*>(-2); }\n\n  static void *getEmptyMarker() {\n    // Note that -1 is chosen to make clear() efficiently implementable with\n    // memset and because it's not a valid pointer value.\n    return reinterpret_cast<void*>(-1);\n  }\n\n  const void **EndPointer() const {\n    return isSmall() ? CurArray + NumNonEmpty : CurArray + CurArraySize;\n  }\n\n  /// insert_imp - This returns true if the pointer was new to the set, false if\n  /// it was already in the set.  This is hidden from the client so that the\n  /// derived class can check that the right type of pointer is passed in.\n  std::pair<const void *const *, bool> insert_imp(const void *Ptr) {\n    if (isSmall()) {\n      // Check to see if it is already in the set.\n      const void **LastTombstone = nullptr;\n      for (const void **APtr = SmallArray, **E = SmallArray + NumNonEmpty;\n           APtr != E; ++APtr) {\n        const void *Value = *APtr;\n        if (Value == Ptr)\n          return std::make_pair(APtr, false);\n        if (Value == getTombstoneMarker())\n          LastTombstone = APtr;\n      }\n\n      // Did we find any tombstone marker?\n      if (LastTombstone != nullptr) {\n        *LastTombstone = Ptr;\n        --NumTombstones;\n        incrementEpoch();\n        return std::make_pair(LastTombstone, true);\n      }\n\n      // Nope, there isn't.  If we stay small, just 'pushback' now.\n      if (NumNonEmpty < CurArraySize) {\n        SmallArray[NumNonEmpty++] = Ptr;\n        incrementEpoch();\n        return std::make_pair(SmallArray + (NumNonEmpty - 1), true);\n      }\n      // Otherwise, hit the big set case, which will call grow.\n    }\n    return insert_imp_big(Ptr);\n  }\n\n  /// erase_imp - If the set contains the specified pointer, remove it and\n  /// return true, otherwise return false.  This is hidden from the client so\n  /// that the derived class can check that the right type of pointer is passed\n  /// in.\n  bool erase_imp(const void * Ptr) {\n    const void *const *P = find_imp(Ptr);\n    if (P == EndPointer())\n      return false;\n\n    const void **Loc = const_cast<const void **>(P);\n    assert(*Loc == Ptr && \"broken find!\");\n    *Loc = getTombstoneMarker();\n    NumTombstones++;\n    return true;\n  }\n\n  /// Returns the raw pointer needed to construct an iterator.  If element not\n  /// found, this will be EndPointer.  Otherwise, it will be a pointer to the\n  /// slot which stores Ptr;\n  const void *const * find_imp(const void * Ptr) const {\n    if (isSmall()) {\n      // Linear search for the item.\n      for (const void *const *APtr = SmallArray,\n                      *const *E = SmallArray + NumNonEmpty; APtr != E; ++APtr)\n        if (*APtr == Ptr)\n          return APtr;\n      return EndPointer();\n    }\n\n    // Big set case.\n    auto *Bucket = FindBucketFor(Ptr);\n    if (*Bucket == Ptr)\n      return Bucket;\n    return EndPointer();\n  }\n\nprivate:\n  bool isSmall() const { return CurArray == SmallArray; }\n\n  std::pair<const void *const *, bool> insert_imp_big(const void *Ptr);\n\n  const void * const *FindBucketFor(const void *Ptr) const;\n  void shrink_and_clear();\n\n  /// Grow - Allocate a larger backing store for the buckets and move it over.\n  void Grow(unsigned NewSize);\n\nprotected:\n  /// swap - Swaps the elements of two sets.\n  /// Note: This method assumes that both sets have the same small size.\n  void swap(SmallPtrSetImplBase &RHS);\n\n  void CopyFrom(const SmallPtrSetImplBase &RHS);\n  void MoveFrom(unsigned SmallSize, SmallPtrSetImplBase &&RHS);\n\nprivate:\n  /// Code shared by MoveFrom() and move constructor.\n  void MoveHelper(unsigned SmallSize, SmallPtrSetImplBase &&RHS);\n  /// Code shared by CopyFrom() and copy constructor.\n  void CopyHelper(const SmallPtrSetImplBase &RHS);\n};\n\n/// SmallPtrSetIteratorImpl - This is the common base class shared between all\n/// instances of SmallPtrSetIterator.\nclass SmallPtrSetIteratorImpl {\nprotected:\n  const void *const *Bucket;\n  const void *const *End;\n\npublic:\n  explicit SmallPtrSetIteratorImpl(const void *const *BP, const void*const *E)\n    : Bucket(BP), End(E) {\n    if (shouldReverseIterate()) {\n      RetreatIfNotValid();\n      return;\n    }\n    AdvanceIfNotValid();\n  }\n\n  bool operator==(const SmallPtrSetIteratorImpl &RHS) const {\n    return Bucket == RHS.Bucket;\n  }\n  bool operator!=(const SmallPtrSetIteratorImpl &RHS) const {\n    return Bucket != RHS.Bucket;\n  }\n\nprotected:\n  /// AdvanceIfNotValid - If the current bucket isn't valid, advance to a bucket\n  /// that is.   This is guaranteed to stop because the end() bucket is marked\n  /// valid.\n  void AdvanceIfNotValid() {\n    assert(Bucket <= End);\n    while (Bucket != End &&\n           (*Bucket == SmallPtrSetImplBase::getEmptyMarker() ||\n            *Bucket == SmallPtrSetImplBase::getTombstoneMarker()))\n      ++Bucket;\n  }\n  void RetreatIfNotValid() {\n    assert(Bucket >= End);\n    while (Bucket != End &&\n           (Bucket[-1] == SmallPtrSetImplBase::getEmptyMarker() ||\n            Bucket[-1] == SmallPtrSetImplBase::getTombstoneMarker())) {\n      --Bucket;\n    }\n  }\n};\n\n/// SmallPtrSetIterator - This implements a const_iterator for SmallPtrSet.\ntemplate <typename PtrTy>\nclass SmallPtrSetIterator : public SmallPtrSetIteratorImpl,\n                            DebugEpochBase::HandleBase {\n  using PtrTraits = PointerLikeTypeTraits<PtrTy>;\n\npublic:\n  using value_type = PtrTy;\n  using reference = PtrTy;\n  using pointer = PtrTy;\n  using difference_type = std::ptrdiff_t;\n  using iterator_category = std::forward_iterator_tag;\n\n  explicit SmallPtrSetIterator(const void *const *BP, const void *const *E,\n                               const DebugEpochBase &Epoch)\n      : SmallPtrSetIteratorImpl(BP, E), DebugEpochBase::HandleBase(&Epoch) {}\n\n  // Most methods are provided by the base class.\n\n  const PtrTy operator*() const {\n    assert(isHandleInSync() && \"invalid iterator access!\");\n    if (shouldReverseIterate()) {\n      assert(Bucket > End);\n      return PtrTraits::getFromVoidPointer(const_cast<void *>(Bucket[-1]));\n    }\n    assert(Bucket < End);\n    return PtrTraits::getFromVoidPointer(const_cast<void*>(*Bucket));\n  }\n\n  inline SmallPtrSetIterator& operator++() {          // Preincrement\n    assert(isHandleInSync() && \"invalid iterator access!\");\n    if (shouldReverseIterate()) {\n      --Bucket;\n      RetreatIfNotValid();\n      return *this;\n    }\n    ++Bucket;\n    AdvanceIfNotValid();\n    return *this;\n  }\n\n  SmallPtrSetIterator operator++(int) {        // Postincrement\n    SmallPtrSetIterator tmp = *this;\n    ++*this;\n    return tmp;\n  }\n};\n\n/// RoundUpToPowerOfTwo - This is a helper template that rounds N up to the next\n/// power of two (which means N itself if N is already a power of two).\ntemplate<unsigned N>\nstruct RoundUpToPowerOfTwo;\n\n/// RoundUpToPowerOfTwoH - If N is not a power of two, increase it.  This is a\n/// helper template used to implement RoundUpToPowerOfTwo.\ntemplate<unsigned N, bool isPowerTwo>\nstruct RoundUpToPowerOfTwoH {\n  enum { Val = N };\n};\ntemplate<unsigned N>\nstruct RoundUpToPowerOfTwoH<N, false> {\n  enum {\n    // We could just use NextVal = N+1, but this converges faster.  N|(N-1) sets\n    // the right-most zero bits to one all at once, e.g. 0b0011000 -> 0b0011111.\n    Val = RoundUpToPowerOfTwo<(N|(N-1)) + 1>::Val\n  };\n};\n\ntemplate<unsigned N>\nstruct RoundUpToPowerOfTwo {\n  enum { Val = RoundUpToPowerOfTwoH<N, (N&(N-1)) == 0>::Val };\n};\n\n/// A templated base class for \\c SmallPtrSet which provides the\n/// typesafe interface that is common across all small sizes.\n///\n/// This is particularly useful for passing around between interface boundaries\n/// to avoid encoding a particular small size in the interface boundary.\ntemplate <typename PtrType>\nclass SmallPtrSetImpl : public SmallPtrSetImplBase {\n  using ConstPtrType = typename add_const_past_pointer<PtrType>::type;\n  using PtrTraits = PointerLikeTypeTraits<PtrType>;\n  using ConstPtrTraits = PointerLikeTypeTraits<ConstPtrType>;\n\nprotected:\n  // Forward constructors to the base.\n  using SmallPtrSetImplBase::SmallPtrSetImplBase;\n\npublic:\n  using iterator = SmallPtrSetIterator<PtrType>;\n  using const_iterator = SmallPtrSetIterator<PtrType>;\n  using key_type = ConstPtrType;\n  using value_type = PtrType;\n\n  SmallPtrSetImpl(const SmallPtrSetImpl &) = delete;\n\n  /// Inserts Ptr if and only if there is no element in the container equal to\n  /// Ptr. The bool component of the returned pair is true if and only if the\n  /// insertion takes place, and the iterator component of the pair points to\n  /// the element equal to Ptr.\n  std::pair<iterator, bool> insert(PtrType Ptr) {\n    auto p = insert_imp(PtrTraits::getAsVoidPointer(Ptr));\n    return std::make_pair(makeIterator(p.first), p.second);\n  }\n\n  /// Insert the given pointer with an iterator hint that is ignored. This is\n  /// identical to calling insert(Ptr), but allows SmallPtrSet to be used by\n  /// std::insert_iterator and std::inserter().\n  iterator insert(iterator, PtrType Ptr) {\n    return insert(Ptr).first;\n  }\n\n  /// erase - If the set contains the specified pointer, remove it and return\n  /// true, otherwise return false.\n  bool erase(PtrType Ptr) {\n    return erase_imp(PtrTraits::getAsVoidPointer(Ptr));\n  }\n  /// count - Return 1 if the specified pointer is in the set, 0 otherwise.\n  size_type count(ConstPtrType Ptr) const {\n    return find_imp(ConstPtrTraits::getAsVoidPointer(Ptr)) != EndPointer();\n  }\n  iterator find(ConstPtrType Ptr) const {\n    return makeIterator(find_imp(ConstPtrTraits::getAsVoidPointer(Ptr)));\n  }\n  bool contains(ConstPtrType Ptr) const {\n    return find_imp(ConstPtrTraits::getAsVoidPointer(Ptr)) != EndPointer();\n  }\n\n  template <typename IterT>\n  void insert(IterT I, IterT E) {\n    for (; I != E; ++I)\n      insert(*I);\n  }\n\n  void insert(std::initializer_list<PtrType> IL) {\n    insert(IL.begin(), IL.end());\n  }\n\n  iterator begin() const {\n    if (shouldReverseIterate())\n      return makeIterator(EndPointer() - 1);\n    return makeIterator(CurArray);\n  }\n  iterator end() const { return makeIterator(EndPointer()); }\n\nprivate:\n  /// Create an iterator that dereferences to same place as the given pointer.\n  iterator makeIterator(const void *const *P) const {\n    if (shouldReverseIterate())\n      return iterator(P == EndPointer() ? CurArray : P + 1, CurArray, *this);\n    return iterator(P, EndPointer(), *this);\n  }\n};\n\n/// Equality comparison for SmallPtrSet.\n///\n/// Iterates over elements of LHS confirming that each value from LHS is also in\n/// RHS, and that no additional values are in RHS.\ntemplate <typename PtrType>\nbool operator==(const SmallPtrSetImpl<PtrType> &LHS,\n                const SmallPtrSetImpl<PtrType> &RHS) {\n  if (LHS.size() != RHS.size())\n    return false;\n\n  for (const auto *KV : LHS)\n    if (!RHS.count(KV))\n      return false;\n\n  return true;\n}\n\n/// Inequality comparison for SmallPtrSet.\n///\n/// Equivalent to !(LHS == RHS).\ntemplate <typename PtrType>\nbool operator!=(const SmallPtrSetImpl<PtrType> &LHS,\n                const SmallPtrSetImpl<PtrType> &RHS) {\n  return !(LHS == RHS);\n}\n\n/// SmallPtrSet - This class implements a set which is optimized for holding\n/// SmallSize or less elements.  This internally rounds up SmallSize to the next\n/// power of two if it is not already a power of two.  See the comments above\n/// SmallPtrSetImplBase for details of the algorithm.\ntemplate<class PtrType, unsigned SmallSize>\nclass SmallPtrSet : public SmallPtrSetImpl<PtrType> {\n  // In small mode SmallPtrSet uses linear search for the elements, so it is\n  // not a good idea to choose this value too high. You may consider using a\n  // DenseSet<> instead if you expect many elements in the set.\n  static_assert(SmallSize <= 32, \"SmallSize should be small\");\n\n  using BaseT = SmallPtrSetImpl<PtrType>;\n\n  // Make sure that SmallSize is a power of two, round up if not.\n  enum { SmallSizePowTwo = RoundUpToPowerOfTwo<SmallSize>::Val };\n  /// SmallStorage - Fixed size storage used in 'small mode'.\n  const void *SmallStorage[SmallSizePowTwo];\n\npublic:\n  SmallPtrSet() : BaseT(SmallStorage, SmallSizePowTwo) {}\n  SmallPtrSet(const SmallPtrSet &that) : BaseT(SmallStorage, that) {}\n  SmallPtrSet(SmallPtrSet &&that)\n      : BaseT(SmallStorage, SmallSizePowTwo, std::move(that)) {}\n\n  template<typename It>\n  SmallPtrSet(It I, It E) : BaseT(SmallStorage, SmallSizePowTwo) {\n    this->insert(I, E);\n  }\n\n  SmallPtrSet(std::initializer_list<PtrType> IL)\n      : BaseT(SmallStorage, SmallSizePowTwo) {\n    this->insert(IL.begin(), IL.end());\n  }\n\n  SmallPtrSet<PtrType, SmallSize> &\n  operator=(const SmallPtrSet<PtrType, SmallSize> &RHS) {\n    if (&RHS != this)\n      this->CopyFrom(RHS);\n    return *this;\n  }\n\n  SmallPtrSet<PtrType, SmallSize> &\n  operator=(SmallPtrSet<PtrType, SmallSize> &&RHS) {\n    if (&RHS != this)\n      this->MoveFrom(SmallSizePowTwo, std::move(RHS));\n    return *this;\n  }\n\n  SmallPtrSet<PtrType, SmallSize> &\n  operator=(std::initializer_list<PtrType> IL) {\n    this->clear();\n    this->insert(IL.begin(), IL.end());\n    return *this;\n  }\n\n  /// swap - Swaps the elements of two sets.\n  void swap(SmallPtrSet<PtrType, SmallSize> &RHS) {\n    SmallPtrSetImplBase::swap(RHS);\n  }\n};\n\n} // end namespace llvm\n\nnamespace std {\n\n  /// Implement std::swap in terms of SmallPtrSet swap.\n  template<class T, unsigned N>\n  inline void swap(llvm::SmallPtrSet<T, N> &LHS, llvm::SmallPtrSet<T, N> &RHS) {\n    LHS.swap(RHS);\n  }\n\n} // end namespace std\n\n#endif // LLVM_ADT_SMALLPTRSET_H\n"}, "9": {"id": 9, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/SmallString.h", "content": "//===- llvm/ADT/SmallString.h - 'Normally small' strings --------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// This file defines the SmallString class.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_ADT_SMALLSTRING_H\n#define LLVM_ADT_SMALLSTRING_H\n\n#include \"llvm/ADT/SmallVector.h\"\n#include \"llvm/ADT/StringRef.h\"\n#include <cstddef>\n\nnamespace llvm {\n\n/// SmallString - A SmallString is just a SmallVector with methods and accessors\n/// that make it work better as a string (e.g. operator+ etc).\ntemplate<unsigned InternalLen>\nclass SmallString : public SmallVector<char, InternalLen> {\npublic:\n  /// Default ctor - Initialize to empty.\n  SmallString() = default;\n\n  /// Initialize from a StringRef.\n  SmallString(StringRef S) : SmallVector<char, InternalLen>(S.begin(), S.end()) {}\n\n  /// Initialize by concatenating a list of StringRefs.\n  SmallString(std::initializer_list<StringRef> Refs)\n      : SmallVector<char, InternalLen>() {\n    this->append(Refs);\n  }\n\n  /// Initialize with a range.\n  template<typename ItTy>\n  SmallString(ItTy S, ItTy E) : SmallVector<char, InternalLen>(S, E) {}\n\n  /// @}\n  /// @name String Assignment\n  /// @{\n\n  using SmallVector<char, InternalLen>::assign;\n\n  /// Assign from a StringRef.\n  void assign(StringRef RHS) {\n    SmallVectorImpl<char>::assign(RHS.begin(), RHS.end());\n  }\n\n  /// Assign from a list of StringRefs.\n  void assign(std::initializer_list<StringRef> Refs) {\n    this->clear();\n    append(Refs);\n  }\n\n  /// @}\n  /// @name String Concatenation\n  /// @{\n\n  using SmallVector<char, InternalLen>::append;\n\n  /// Append from a StringRef.\n  void append(StringRef RHS) {\n    SmallVectorImpl<char>::append(RHS.begin(), RHS.end());\n  }\n\n  /// Append from a list of StringRefs.\n  void append(std::initializer_list<StringRef> Refs) {\n    size_t SizeNeeded = this->size();\n    for (const StringRef &Ref : Refs)\n      SizeNeeded += Ref.size();\n    this->reserve(SizeNeeded);\n    auto CurEnd = this->end();\n    for (const StringRef &Ref : Refs) {\n      this->uninitialized_copy(Ref.begin(), Ref.end(), CurEnd);\n      CurEnd += Ref.size();\n    }\n    this->set_size(SizeNeeded);\n  }\n\n  /// @}\n  /// @name String Comparison\n  /// @{\n\n  /// Check for string equality.  This is more efficient than compare() when\n  /// the relative ordering of inequal strings isn't needed.\n  bool equals(StringRef RHS) const {\n    return str().equals(RHS);\n  }\n\n  /// Check for string equality, ignoring case.\n  bool equals_lower(StringRef RHS) const {\n    return str().equals_lower(RHS);\n  }\n\n  /// Compare two strings; the result is -1, 0, or 1 if this string is\n  /// lexicographically less than, equal to, or greater than the \\p RHS.\n  int compare(StringRef RHS) const {\n    return str().compare(RHS);\n  }\n\n  /// compare_lower - Compare two strings, ignoring case.\n  int compare_lower(StringRef RHS) const {\n    return str().compare_lower(RHS);\n  }\n\n  /// compare_numeric - Compare two strings, treating sequences of digits as\n  /// numbers.\n  int compare_numeric(StringRef RHS) const {\n    return str().compare_numeric(RHS);\n  }\n\n  /// @}\n  /// @name String Predicates\n  /// @{\n\n  /// startswith - Check if this string starts with the given \\p Prefix.\n  bool startswith(StringRef Prefix) const {\n    return str().startswith(Prefix);\n  }\n\n  /// endswith - Check if this string ends with the given \\p Suffix.\n  bool endswith(StringRef Suffix) const {\n    return str().endswith(Suffix);\n  }\n\n  /// @}\n  /// @name String Searching\n  /// @{\n\n  /// find - Search for the first character \\p C in the string.\n  ///\n  /// \\return - The index of the first occurrence of \\p C, or npos if not\n  /// found.\n  size_t find(char C, size_t From = 0) const {\n    return str().find(C, From);\n  }\n\n  /// Search for the first string \\p Str in the string.\n  ///\n  /// \\returns The index of the first occurrence of \\p Str, or npos if not\n  /// found.\n  size_t find(StringRef Str, size_t From = 0) const {\n    return str().find(Str, From);\n  }\n\n  /// Search for the last character \\p C in the string.\n  ///\n  /// \\returns The index of the last occurrence of \\p C, or npos if not\n  /// found.\n  size_t rfind(char C, size_t From = StringRef::npos) const {\n    return str().rfind(C, From);\n  }\n\n  /// Search for the last string \\p Str in the string.\n  ///\n  /// \\returns The index of the last occurrence of \\p Str, or npos if not\n  /// found.\n  size_t rfind(StringRef Str) const {\n    return str().rfind(Str);\n  }\n\n  /// Find the first character in the string that is \\p C, or npos if not\n  /// found. Same as find.\n  size_t find_first_of(char C, size_t From = 0) const {\n    return str().find_first_of(C, From);\n  }\n\n  /// Find the first character in the string that is in \\p Chars, or npos if\n  /// not found.\n  ///\n  /// Complexity: O(size() + Chars.size())\n  size_t find_first_of(StringRef Chars, size_t From = 0) const {\n    return str().find_first_of(Chars, From);\n  }\n\n  /// Find the first character in the string that is not \\p C or npos if not\n  /// found.\n  size_t find_first_not_of(char C, size_t From = 0) const {\n    return str().find_first_not_of(C, From);\n  }\n\n  /// Find the first character in the string that is not in the string\n  /// \\p Chars, or npos if not found.\n  ///\n  /// Complexity: O(size() + Chars.size())\n  size_t find_first_not_of(StringRef Chars, size_t From = 0) const {\n    return str().find_first_not_of(Chars, From);\n  }\n\n  /// Find the last character in the string that is \\p C, or npos if not\n  /// found.\n  size_t find_last_of(char C, size_t From = StringRef::npos) const {\n    return str().find_last_of(C, From);\n  }\n\n  /// Find the last character in the string that is in \\p C, or npos if not\n  /// found.\n  ///\n  /// Complexity: O(size() + Chars.size())\n  size_t find_last_of(\n      StringRef Chars, size_t From = StringRef::npos) const {\n    return str().find_last_of(Chars, From);\n  }\n\n  /// @}\n  /// @name Helpful Algorithms\n  /// @{\n\n  /// Return the number of occurrences of \\p C in the string.\n  size_t count(char C) const {\n    return str().count(C);\n  }\n\n  /// Return the number of non-overlapped occurrences of \\p Str in the\n  /// string.\n  size_t count(StringRef Str) const {\n    return str().count(Str);\n  }\n\n  /// @}\n  /// @name Substring Operations\n  /// @{\n\n  /// Return a reference to the substring from [Start, Start + N).\n  ///\n  /// \\param Start The index of the starting character in the substring; if\n  /// the index is npos or greater than the length of the string then the\n  /// empty substring will be returned.\n  ///\n  /// \\param N The number of characters to included in the substring. If \\p N\n  /// exceeds the number of characters remaining in the string, the string\n  /// suffix (starting with \\p Start) will be returned.\n  StringRef substr(size_t Start, size_t N = StringRef::npos) const {\n    return str().substr(Start, N);\n  }\n\n  /// Return a reference to the substring from [Start, End).\n  ///\n  /// \\param Start The index of the starting character in the substring; if\n  /// the index is npos or greater than the length of the string then the\n  /// empty substring will be returned.\n  ///\n  /// \\param End The index following the last character to include in the\n  /// substring. If this is npos, or less than \\p Start, or exceeds the\n  /// number of characters remaining in the string, the string suffix\n  /// (starting with \\p Start) will be returned.\n  StringRef slice(size_t Start, size_t End) const {\n    return str().slice(Start, End);\n  }\n\n  // Extra methods.\n\n  /// Explicit conversion to StringRef.\n  StringRef str() const { return StringRef(this->data(), this->size()); }\n\n  // TODO: Make this const, if it's safe...\n  const char* c_str() {\n    this->push_back(0);\n    this->pop_back();\n    return this->data();\n  }\n\n  /// Implicit conversion to StringRef.\n  operator StringRef() const { return str(); }\n\n  explicit operator std::string() const {\n    return std::string(this->data(), this->size());\n  }\n\n  // Extra operators.\n  SmallString &operator=(StringRef RHS) {\n    this->assign(RHS);\n    return *this;\n  }\n\n  SmallString &operator+=(StringRef RHS) {\n    this->append(RHS.begin(), RHS.end());\n    return *this;\n  }\n  SmallString &operator+=(char C) {\n    this->push_back(C);\n    return *this;\n  }\n};\n\n} // end namespace llvm\n\n#endif // LLVM_ADT_SMALLSTRING_H\n"}, "10": {"id": 10, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/SmallVector.h", "content": "//===- llvm/ADT/SmallVector.h - 'Normally small' vectors --------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// This file defines the SmallVector class.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_ADT_SMALLVECTOR_H\n#define LLVM_ADT_SMALLVECTOR_H\n\n#include \"llvm/ADT/iterator_range.h\"\n#include \"llvm/Support/Compiler.h\"\n#include \"llvm/Support/ErrorHandling.h\"\n#include \"llvm/Support/MathExtras.h\"\n#include \"llvm/Support/MemAlloc.h\"\n#include \"llvm/Support/type_traits.h\"\n#include <algorithm>\n#include <cassert>\n#include <cstddef>\n#include <cstdlib>\n#include <cstring>\n#include <initializer_list>\n#include <iterator>\n#include <limits>\n#include <memory>\n#include <new>\n#include <type_traits>\n#include <utility>\n\nnamespace llvm {\n\n/// This is all the stuff common to all SmallVectors.\n///\n/// The template parameter specifies the type which should be used to hold the\n/// Size and Capacity of the SmallVector, so it can be adjusted.\n/// Using 32 bit size is desirable to shrink the size of the SmallVector.\n/// Using 64 bit size is desirable for cases like SmallVector<char>, where a\n/// 32 bit size would limit the vector to ~4GB. SmallVectors are used for\n/// buffering bitcode output - which can exceed 4GB.\ntemplate <class Size_T> class SmallVectorBase {\nprotected:\n  void *BeginX;\n  Size_T Size = 0, Capacity;\n\n  /// The maximum value of the Size_T used.\n  static constexpr size_t SizeTypeMax() {\n    return std::numeric_limits<Size_T>::max();\n  }\n\n  SmallVectorBase() = delete;\n  SmallVectorBase(void *FirstEl, size_t TotalCapacity)\n      : BeginX(FirstEl), Capacity(TotalCapacity) {}\n\n  /// This is a helper for \\a grow() that's out of line to reduce code\n  /// duplication.  This function will report a fatal error if it can't grow at\n  /// least to \\p MinSize.\n  void *mallocForGrow(size_t MinSize, size_t TSize, size_t &NewCapacity);\n\n  /// This is an implementation of the grow() method which only works\n  /// on POD-like data types and is out of line to reduce code duplication.\n  /// This function will report a fatal error if it cannot increase capacity.\n  void grow_pod(void *FirstEl, size_t MinSize, size_t TSize);\n\npublic:\n  size_t size() const { return Size; }\n  size_t capacity() const { return Capacity; }\n\n  LLVM_NODISCARD bool empty() const { return !Size; }\n\n  /// Set the array size to \\p N, which the current array must have enough\n  /// capacity for.\n  ///\n  /// This does not construct or destroy any elements in the vector.\n  ///\n  /// Clients can use this in conjunction with capacity() to write past the end\n  /// of the buffer when they know that more elements are available, and only\n  /// update the size later. This avoids the cost of value initializing elements\n  /// which will only be overwritten.\n  void set_size(size_t N) {\n    assert(N <= capacity());\n    Size = N;\n  }\n};\n\ntemplate <class T>\nusing SmallVectorSizeType =\n    typename std::conditional<sizeof(T) < 4 && sizeof(void *) >= 8, uint64_t,\n                              uint32_t>::type;\n\n/// Figure out the offset of the first element.\ntemplate <class T, typename = void> struct SmallVectorAlignmentAndSize {\n  alignas(SmallVectorBase<SmallVectorSizeType<T>>) char Base[sizeof(\n      SmallVectorBase<SmallVectorSizeType<T>>)];\n  alignas(T) char FirstEl[sizeof(T)];\n};\n\n/// This is the part of SmallVectorTemplateBase which does not depend on whether\n/// the type T is a POD. The extra dummy template argument is used by ArrayRef\n/// to avoid unnecessarily requiring T to be complete.\ntemplate <typename T, typename = void>\nclass SmallVectorTemplateCommon\n    : public SmallVectorBase<SmallVectorSizeType<T>> {\n  using Base = SmallVectorBase<SmallVectorSizeType<T>>;\n\n  /// Find the address of the first element.  For this pointer math to be valid\n  /// with small-size of 0 for T with lots of alignment, it's important that\n  /// SmallVectorStorage is properly-aligned even for small-size of 0.\n  void *getFirstEl() const {\n    return const_cast<void *>(reinterpret_cast<const void *>(\n        reinterpret_cast<const char *>(this) +\n        offsetof(SmallVectorAlignmentAndSize<T>, FirstEl)));\n  }\n  // Space after 'FirstEl' is clobbered, do not add any instance vars after it.\n\nprotected:\n  SmallVectorTemplateCommon(size_t Size) : Base(getFirstEl(), Size) {}\n\n  void grow_pod(size_t MinSize, size_t TSize) {\n    Base::grow_pod(getFirstEl(), MinSize, TSize);\n  }\n\n  /// Return true if this is a smallvector which has not had dynamic\n  /// memory allocated for it.\n  bool isSmall() const { return this->BeginX == getFirstEl(); }\n\n  /// Put this vector in a state of being small.\n  void resetToSmall() {\n    this->BeginX = getFirstEl();\n    this->Size = this->Capacity = 0; // FIXME: Setting Capacity to 0 is suspect.\n  }\n\n  /// Return true if V is an internal reference to the given range.\n  bool isReferenceToRange(const void *V, const void *First, const void *Last) const {\n    // Use std::less to avoid UB.\n    std::less<> LessThan;\n    return !LessThan(V, First) && LessThan(V, Last);\n  }\n\n  /// Return true if V is an internal reference to this vector.\n  bool isReferenceToStorage(const void *V) const {\n    return isReferenceToRange(V, this->begin(), this->end());\n  }\n\n  /// Return true if First and Last form a valid (possibly empty) range in this\n  /// vector's storage.\n  bool isRangeInStorage(const void *First, const void *Last) const {\n    // Use std::less to avoid UB.\n    std::less<> LessThan;\n    return !LessThan(First, this->begin()) && !LessThan(Last, First) &&\n           !LessThan(this->end(), Last);\n  }\n\n  /// Return true unless Elt will be invalidated by resizing the vector to\n  /// NewSize.\n  bool isSafeToReferenceAfterResize(const void *Elt, size_t NewSize) {\n    // Past the end.\n    if (LLVM_LIKELY(!isReferenceToStorage(Elt)))\n      return true;\n\n    // Return false if Elt will be destroyed by shrinking.\n    if (NewSize <= this->size())\n      return Elt < this->begin() + NewSize;\n\n    // Return false if we need to grow.\n    return NewSize <= this->capacity();\n  }\n\n  /// Check whether Elt will be invalidated by resizing the vector to NewSize.\n  void assertSafeToReferenceAfterResize(const void *Elt, size_t NewSize) {\n    assert(isSafeToReferenceAfterResize(Elt, NewSize) &&\n           \"Attempting to reference an element of the vector in an operation \"\n           \"that invalidates it\");\n  }\n\n  /// Check whether Elt will be invalidated by increasing the size of the\n  /// vector by N.\n  void assertSafeToAdd(const void *Elt, size_t N = 1) {\n    this->assertSafeToReferenceAfterResize(Elt, this->size() + N);\n  }\n\n  /// Check whether any part of the range will be invalidated by clearing.\n  void assertSafeToReferenceAfterClear(const T *From, const T *To) {\n    if (From == To)\n      return;\n    this->assertSafeToReferenceAfterResize(From, 0);\n    this->assertSafeToReferenceAfterResize(To - 1, 0);\n  }\n  template <\n      class ItTy,\n      std::enable_if_t<!std::is_same<std::remove_const_t<ItTy>, T *>::value,\n                       bool> = false>\n  void assertSafeToReferenceAfterClear(ItTy, ItTy) {}\n\n  /// Check whether any part of the range will be invalidated by growing.\n  void assertSafeToAddRange(const T *From, const T *To) {\n    if (From == To)\n      return;\n    this->assertSafeToAdd(From, To - From);\n    this->assertSafeToAdd(To - 1, To - From);\n  }\n  template <\n      class ItTy,\n      std::enable_if_t<!std::is_same<std::remove_const_t<ItTy>, T *>::value,\n                       bool> = false>\n  void assertSafeToAddRange(ItTy, ItTy) {}\n\n  /// Reserve enough space to add one element, and return the updated element\n  /// pointer in case it was a reference to the storage.\n  template <class U>\n  static const T *reserveForParamAndGetAddressImpl(U *This, const T &Elt,\n                                                   size_t N) {\n    size_t NewSize = This->size() + N;\n    if (LLVM_LIKELY(NewSize <= This->capacity()))\n      return &Elt;\n\n    bool ReferencesStorage = false;\n    int64_t Index = -1;\n    if (!U::TakesParamByValue) {\n      if (LLVM_UNLIKELY(This->isReferenceToStorage(&Elt))) {\n        ReferencesStorage = true;\n        Index = &Elt - This->begin();\n      }\n    }\n    This->grow(NewSize);\n    return ReferencesStorage ? This->begin() + Index : &Elt;\n  }\n\npublic:\n  using size_type = size_t;\n  using difference_type = ptrdiff_t;\n  using value_type = T;\n  using iterator = T *;\n  using const_iterator = const T *;\n\n  using const_reverse_iterator = std::reverse_iterator<const_iterator>;\n  using reverse_iterator = std::reverse_iterator<iterator>;\n\n  using reference = T &;\n  using const_reference = const T &;\n  using pointer = T *;\n  using const_pointer = const T *;\n\n  using Base::capacity;\n  using Base::empty;\n  using Base::size;\n\n  // forward iterator creation methods.\n  iterator begin() { return (iterator)this->BeginX; }\n  const_iterator begin() const { return (const_iterator)this->BeginX; }\n  iterator end() { return begin() + size(); }\n  const_iterator end() const { return begin() + size(); }\n\n  // reverse iterator creation methods.\n  reverse_iterator rbegin()            { return reverse_iterator(end()); }\n  const_reverse_iterator rbegin() const{ return const_reverse_iterator(end()); }\n  reverse_iterator rend()              { return reverse_iterator(begin()); }\n  const_reverse_iterator rend() const { return const_reverse_iterator(begin());}\n\n  size_type size_in_bytes() const { return size() * sizeof(T); }\n  size_type max_size() const {\n    return std::min(this->SizeTypeMax(), size_type(-1) / sizeof(T));\n  }\n\n  size_t capacity_in_bytes() const { return capacity() * sizeof(T); }\n\n  /// Return a pointer to the vector's buffer, even if empty().\n  pointer data() { return pointer(begin()); }\n  /// Return a pointer to the vector's buffer, even if empty().\n  const_pointer data() const { return const_pointer(begin()); }\n\n  reference operator[](size_type idx) {\n    assert(idx < size());\n    return begin()[idx];\n  }\n  const_reference operator[](size_type idx) const {\n    assert(idx < size());\n    return begin()[idx];\n  }\n\n  reference front() {\n    assert(!empty());\n    return begin()[0];\n  }\n  const_reference front() const {\n    assert(!empty());\n    return begin()[0];\n  }\n\n  reference back() {\n    assert(!empty());\n    return end()[-1];\n  }\n  const_reference back() const {\n    assert(!empty());\n    return end()[-1];\n  }\n};\n\n/// SmallVectorTemplateBase<TriviallyCopyable = false> - This is where we put\n/// method implementations that are designed to work with non-trivial T's.\n///\n/// We approximate is_trivially_copyable with trivial move/copy construction and\n/// trivial destruction. While the standard doesn't specify that you're allowed\n/// copy these types with memcpy, there is no way for the type to observe this.\n/// This catches the important case of std::pair<POD, POD>, which is not\n/// trivially assignable.\ntemplate <typename T, bool = (is_trivially_copy_constructible<T>::value) &&\n                             (is_trivially_move_constructible<T>::value) &&\n                             std::is_trivially_destructible<T>::value>\nclass SmallVectorTemplateBase : public SmallVectorTemplateCommon<T> {\n  friend class SmallVectorTemplateCommon<T>;\n\nprotected:\n  static constexpr bool TakesParamByValue = false;\n  using ValueParamT = const T &;\n\n  SmallVectorTemplateBase(size_t Size) : SmallVectorTemplateCommon<T>(Size) {}\n\n  static void destroy_range(T *S, T *E) {\n    while (S != E) {\n      --E;\n      E->~T();\n    }\n  }\n\n  /// Move the range [I, E) into the uninitialized memory starting with \"Dest\",\n  /// constructing elements as needed.\n  template<typename It1, typename It2>\n  static void uninitialized_move(It1 I, It1 E, It2 Dest) {\n    std::uninitialized_copy(std::make_move_iterator(I),\n                            std::make_move_iterator(E), Dest);\n  }\n\n  /// Copy the range [I, E) onto the uninitialized memory starting with \"Dest\",\n  /// constructing elements as needed.\n  template<typename It1, typename It2>\n  static void uninitialized_copy(It1 I, It1 E, It2 Dest) {\n    std::uninitialized_copy(I, E, Dest);\n  }\n\n  /// Grow the allocated memory (without initializing new elements), doubling\n  /// the size of the allocated memory. Guarantees space for at least one more\n  /// element, or MinSize more elements if specified.\n  void grow(size_t MinSize = 0);\n\n  /// Create a new allocation big enough for \\p MinSize and pass back its size\n  /// in \\p NewCapacity. This is the first section of \\a grow().\n  T *mallocForGrow(size_t MinSize, size_t &NewCapacity) {\n    return static_cast<T *>(\n        SmallVectorBase<SmallVectorSizeType<T>>::mallocForGrow(\n            MinSize, sizeof(T), NewCapacity));\n  }\n\n  /// Move existing elements over to the new allocation \\p NewElts, the middle\n  /// section of \\a grow().\n  void moveElementsForGrow(T *NewElts);\n\n  /// Transfer ownership of the allocation, finishing up \\a grow().\n  void takeAllocationForGrow(T *NewElts, size_t NewCapacity);\n\n  /// Reserve enough space to add one element, and return the updated element\n  /// pointer in case it was a reference to the storage.\n  const T *reserveForParamAndGetAddress(const T &Elt, size_t N = 1) {\n    return this->reserveForParamAndGetAddressImpl(this, Elt, N);\n  }\n\n  /// Reserve enough space to add one element, and return the updated element\n  /// pointer in case it was a reference to the storage.\n  T *reserveForParamAndGetAddress(T &Elt, size_t N = 1) {\n    return const_cast<T *>(\n        this->reserveForParamAndGetAddressImpl(this, Elt, N));\n  }\n\n  static T &&forward_value_param(T &&V) { return std::move(V); }\n  static const T &forward_value_param(const T &V) { return V; }\n\n  void growAndAssign(size_t NumElts, const T &Elt) {\n    // Grow manually in case Elt is an internal reference.\n    size_t NewCapacity;\n    T *NewElts = mallocForGrow(NumElts, NewCapacity);\n    std::uninitialized_fill_n(NewElts, NumElts, Elt);\n    this->destroy_range(this->begin(), this->end());\n    takeAllocationForGrow(NewElts, NewCapacity);\n    this->set_size(NumElts);\n  }\n\n  template <typename... ArgTypes> T &growAndEmplaceBack(ArgTypes &&... Args) {\n    // Grow manually in case one of Args is an internal reference.\n    size_t NewCapacity;\n    T *NewElts = mallocForGrow(0, NewCapacity);\n    ::new ((void *)(NewElts + this->size())) T(std::forward<ArgTypes>(Args)...);\n    moveElementsForGrow(NewElts);\n    takeAllocationForGrow(NewElts, NewCapacity);\n    this->set_size(this->size() + 1);\n    return this->back();\n  }\n\npublic:\n  void push_back(const T &Elt) {\n    const T *EltPtr = reserveForParamAndGetAddress(Elt);\n    ::new ((void *)this->end()) T(*EltPtr);\n    this->set_size(this->size() + 1);\n  }\n\n  void push_back(T &&Elt) {\n    T *EltPtr = reserveForParamAndGetAddress(Elt);\n    ::new ((void *)this->end()) T(::std::move(*EltPtr));\n    this->set_size(this->size() + 1);\n  }\n\n  void pop_back() {\n    this->set_size(this->size() - 1);\n    this->end()->~T();\n  }\n};\n\n// Define this out-of-line to dissuade the C++ compiler from inlining it.\ntemplate <typename T, bool TriviallyCopyable>\nvoid SmallVectorTemplateBase<T, TriviallyCopyable>::grow(size_t MinSize) {\n  size_t NewCapacity;\n  T *NewElts = mallocForGrow(MinSize, NewCapacity);\n  moveElementsForGrow(NewElts);\n  takeAllocationForGrow(NewElts, NewCapacity);\n}\n\n// Define this out-of-line to dissuade the C++ compiler from inlining it.\ntemplate <typename T, bool TriviallyCopyable>\nvoid SmallVectorTemplateBase<T, TriviallyCopyable>::moveElementsForGrow(\n    T *NewElts) {\n  // Move the elements over.\n  this->uninitialized_move(this->begin(), this->end(), NewElts);\n\n  // Destroy the original elements.\n  destroy_range(this->begin(), this->end());\n}\n\n// Define this out-of-line to dissuade the C++ compiler from inlining it.\ntemplate <typename T, bool TriviallyCopyable>\nvoid SmallVectorTemplateBase<T, TriviallyCopyable>::takeAllocationForGrow(\n    T *NewElts, size_t NewCapacity) {\n  // If this wasn't grown from the inline copy, deallocate the old space.\n  if (!this->isSmall())\n    free(this->begin());\n\n  this->BeginX = NewElts;\n  this->Capacity = NewCapacity;\n}\n\n/// SmallVectorTemplateBase<TriviallyCopyable = true> - This is where we put\n/// method implementations that are designed to work with trivially copyable\n/// T's. This allows using memcpy in place of copy/move construction and\n/// skipping destruction.\ntemplate <typename T>\nclass SmallVectorTemplateBase<T, true> : public SmallVectorTemplateCommon<T> {\n  friend class SmallVectorTemplateCommon<T>;\n\nprotected:\n  /// True if it's cheap enough to take parameters by value. Doing so avoids\n  /// overhead related to mitigations for reference invalidation.\n  static constexpr bool TakesParamByValue = sizeof(T) <= 2 * sizeof(void *);\n\n  /// Either const T& or T, depending on whether it's cheap enough to take\n  /// parameters by value.\n  using ValueParamT =\n      typename std::conditional<TakesParamByValue, T, const T &>::type;\n\n  SmallVectorTemplateBase(size_t Size) : SmallVectorTemplateCommon<T>(Size) {}\n\n  // No need to do a destroy loop for POD's.\n  static void destroy_range(T *, T *) {}\n\n  /// Move the range [I, E) onto the uninitialized memory\n  /// starting with \"Dest\", constructing elements into it as needed.\n  template<typename It1, typename It2>\n  static void uninitialized_move(It1 I, It1 E, It2 Dest) {\n    // Just do a copy.\n    uninitialized_copy(I, E, Dest);\n  }\n\n  /// Copy the range [I, E) onto the uninitialized memory\n  /// starting with \"Dest\", constructing elements into it as needed.\n  template<typename It1, typename It2>\n  static void uninitialized_copy(It1 I, It1 E, It2 Dest) {\n    // Arbitrary iterator types; just use the basic implementation.\n    std::uninitialized_copy(I, E, Dest);\n  }\n\n  /// Copy the range [I, E) onto the uninitialized memory\n  /// starting with \"Dest\", constructing elements into it as needed.\n  template <typename T1, typename T2>\n  static void uninitialized_copy(\n      T1 *I, T1 *E, T2 *Dest,\n      std::enable_if_t<std::is_same<typename std::remove_const<T1>::type,\n                                    T2>::value> * = nullptr) {\n    // Use memcpy for PODs iterated by pointers (which includes SmallVector\n    // iterators): std::uninitialized_copy optimizes to memmove, but we can\n    // use memcpy here. Note that I and E are iterators and thus might be\n    // invalid for memcpy if they are equal.\n    if (I != E)\n      memcpy(reinterpret_cast<void *>(Dest), I, (E - I) * sizeof(T));\n  }\n\n  /// Double the size of the allocated memory, guaranteeing space for at\n  /// least one more element or MinSize if specified.\n  void grow(size_t MinSize = 0) { this->grow_pod(MinSize, sizeof(T)); }\n\n  /// Reserve enough space to add one element, and return the updated element\n  /// pointer in case it was a reference to the storage.\n  const T *reserveForParamAndGetAddress(const T &Elt, size_t N = 1) {\n    return this->reserveForParamAndGetAddressImpl(this, Elt, N);\n  }\n\n  /// Reserve enough space to add one element, and return the updated element\n  /// pointer in case it was a reference to the storage.\n  T *reserveForParamAndGetAddress(T &Elt, size_t N = 1) {\n    return const_cast<T *>(\n        this->reserveForParamAndGetAddressImpl(this, Elt, N));\n  }\n\n  /// Copy \\p V or return a reference, depending on \\a ValueParamT.\n  static ValueParamT forward_value_param(ValueParamT V) { return V; }\n\n  void growAndAssign(size_t NumElts, T Elt) {\n    // Elt has been copied in case it's an internal reference, side-stepping\n    // reference invalidation problems without losing the realloc optimization.\n    this->set_size(0);\n    this->grow(NumElts);\n    std::uninitialized_fill_n(this->begin(), NumElts, Elt);\n    this->set_size(NumElts);\n  }\n\n  template <typename... ArgTypes> T &growAndEmplaceBack(ArgTypes &&... Args) {\n    // Use push_back with a copy in case Args has an internal reference,\n    // side-stepping reference invalidation problems without losing the realloc\n    // optimization.\n    push_back(T(std::forward<ArgTypes>(Args)...));\n    return this->back();\n  }\n\npublic:\n  void push_back(ValueParamT Elt) {\n    const T *EltPtr = reserveForParamAndGetAddress(Elt);\n    memcpy(reinterpret_cast<void *>(this->end()), EltPtr, sizeof(T));\n    this->set_size(this->size() + 1);\n  }\n\n  void pop_back() { this->set_size(this->size() - 1); }\n};\n\n/// This class consists of common code factored out of the SmallVector class to\n/// reduce code duplication based on the SmallVector 'N' template parameter.\ntemplate <typename T>\nclass SmallVectorImpl : public SmallVectorTemplateBase<T> {\n  using SuperClass = SmallVectorTemplateBase<T>;\n\npublic:\n  using iterator = typename SuperClass::iterator;\n  using const_iterator = typename SuperClass::const_iterator;\n  using reference = typename SuperClass::reference;\n  using size_type = typename SuperClass::size_type;\n\nprotected:\n  using SmallVectorTemplateBase<T>::TakesParamByValue;\n  using ValueParamT = typename SuperClass::ValueParamT;\n\n  // Default ctor - Initialize to empty.\n  explicit SmallVectorImpl(unsigned N)\n      : SmallVectorTemplateBase<T>(N) {}\n\npublic:\n  SmallVectorImpl(const SmallVectorImpl &) = delete;\n\n  ~SmallVectorImpl() {\n    // Subclass has already destructed this vector's elements.\n    // If this wasn't grown from the inline copy, deallocate the old space.\n    if (!this->isSmall())\n      free(this->begin());\n  }\n\n  void clear() {\n    this->destroy_range(this->begin(), this->end());\n    this->Size = 0;\n  }\n\nprivate:\n  template <bool ForOverwrite> void resizeImpl(size_type N) {\n    if (N < this->size()) {\n      this->pop_back_n(this->size() - N);\n    } else if (N > this->size()) {\n      this->reserve(N);\n      for (auto I = this->end(), E = this->begin() + N; I != E; ++I)\n        if (ForOverwrite)\n          new (&*I) T;\n        else\n          new (&*I) T();\n      this->set_size(N);\n    }\n  }\n\npublic:\n  void resize(size_type N) { resizeImpl<false>(N); }\n\n  /// Like resize, but \\ref T is POD, the new values won't be initialized.\n  void resize_for_overwrite(size_type N) { resizeImpl<true>(N); }\n\n  void resize(size_type N, ValueParamT NV) {\n    if (N == this->size())\n      return;\n\n    if (N < this->size()) {\n      this->pop_back_n(this->size() - N);\n      return;\n    }\n\n    // N > this->size(). Defer to append.\n    this->append(N - this->size(), NV);\n  }\n\n  void reserve(size_type N) {\n    if (this->capacity() < N)\n      this->grow(N);\n  }\n\n  void pop_back_n(size_type NumItems) {\n    assert(this->size() >= NumItems);\n    this->destroy_range(this->end() - NumItems, this->end());\n    this->set_size(this->size() - NumItems);\n  }\n\n  LLVM_NODISCARD T pop_back_val() {\n    T Result = ::std::move(this->back());\n    this->pop_back();\n    return Result;\n  }\n\n  void swap(SmallVectorImpl &RHS);\n\n  /// Add the specified range to the end of the SmallVector.\n  template <typename in_iter,\n            typename = std::enable_if_t<std::is_convertible<\n                typename std::iterator_traits<in_iter>::iterator_category,\n                std::input_iterator_tag>::value>>\n  void append(in_iter in_start, in_iter in_end) {\n    this->assertSafeToAddRange(in_start, in_end);\n    size_type NumInputs = std::distance(in_start, in_end);\n    this->reserve(this->size() + NumInputs);\n    this->uninitialized_copy(in_start, in_end, this->end());\n    this->set_size(this->size() + NumInputs);\n  }\n\n  /// Append \\p NumInputs copies of \\p Elt to the end.\n  void append(size_type NumInputs, ValueParamT Elt) {\n    const T *EltPtr = this->reserveForParamAndGetAddress(Elt, NumInputs);\n    std::uninitialized_fill_n(this->end(), NumInputs, *EltPtr);\n    this->set_size(this->size() + NumInputs);\n  }\n\n  void append(std::initializer_list<T> IL) {\n    append(IL.begin(), IL.end());\n  }\n\n  void append(const SmallVectorImpl &RHS) { append(RHS.begin(), RHS.end()); }\n\n  void assign(size_type NumElts, ValueParamT Elt) {\n    // Note that Elt could be an internal reference.\n    if (NumElts > this->capacity()) {\n      this->growAndAssign(NumElts, Elt);\n      return;\n    }\n\n    // Assign over existing elements.\n    std::fill_n(this->begin(), std::min(NumElts, this->size()), Elt);\n    if (NumElts > this->size())\n      std::uninitialized_fill_n(this->end(), NumElts - this->size(), Elt);\n    else if (NumElts < this->size())\n      this->destroy_range(this->begin() + NumElts, this->end());\n    this->set_size(NumElts);\n  }\n\n  // FIXME: Consider assigning over existing elements, rather than clearing &\n  // re-initializing them - for all assign(...) variants.\n\n  template <typename in_iter,\n            typename = std::enable_if_t<std::is_convertible<\n                typename std::iterator_traits<in_iter>::iterator_category,\n                std::input_iterator_tag>::value>>\n  void assign(in_iter in_start, in_iter in_end) {\n    this->assertSafeToReferenceAfterClear(in_start, in_end);\n    clear();\n    append(in_start, in_end);\n  }\n\n  void assign(std::initializer_list<T> IL) {\n    clear();\n    append(IL);\n  }\n\n  void assign(const SmallVectorImpl &RHS) { assign(RHS.begin(), RHS.end()); }\n\n  iterator erase(const_iterator CI) {\n    // Just cast away constness because this is a non-const member function.\n    iterator I = const_cast<iterator>(CI);\n\n    assert(this->isReferenceToStorage(CI) && \"Iterator to erase is out of bounds.\");\n\n    iterator N = I;\n    // Shift all elts down one.\n    std::move(I+1, this->end(), I);\n    // Drop the last elt.\n    this->pop_back();\n    return(N);\n  }\n\n  iterator erase(const_iterator CS, const_iterator CE) {\n    // Just cast away constness because this is a non-const member function.\n    iterator S = const_cast<iterator>(CS);\n    iterator E = const_cast<iterator>(CE);\n\n    assert(this->isRangeInStorage(S, E) && \"Range to erase is out of bounds.\");\n\n    iterator N = S;\n    // Shift all elts down.\n    iterator I = std::move(E, this->end(), S);\n    // Drop the last elts.\n    this->destroy_range(I, this->end());\n    this->set_size(I - this->begin());\n    return(N);\n  }\n\nprivate:\n  template <class ArgType> iterator insert_one_impl(iterator I, ArgType &&Elt) {\n    // Callers ensure that ArgType is derived from T.\n    static_assert(\n        std::is_same<std::remove_const_t<std::remove_reference_t<ArgType>>,\n                     T>::value,\n        \"ArgType must be derived from T!\");\n\n    if (I == this->end()) {  // Important special case for empty vector.\n      this->push_back(::std::forward<ArgType>(Elt));\n      return this->end()-1;\n    }\n\n    assert(this->isReferenceToStorage(I) && \"Insertion iterator is out of bounds.\");\n\n    // Grow if necessary.\n    size_t Index = I - this->begin();\n    std::remove_reference_t<ArgType> *EltPtr =\n        this->reserveForParamAndGetAddress(Elt);\n    I = this->begin() + Index;\n\n    ::new ((void*) this->end()) T(::std::move(this->back()));\n    // Push everything else over.\n    std::move_backward(I, this->end()-1, this->end());\n    this->set_size(this->size() + 1);\n\n    // If we just moved the element we're inserting, be sure to update\n    // the reference (never happens if TakesParamByValue).\n    static_assert(!TakesParamByValue || std::is_same<ArgType, T>::value,\n                  \"ArgType must be 'T' when taking by value!\");\n    if (!TakesParamByValue && this->isReferenceToRange(EltPtr, I, this->end()))\n      ++EltPtr;\n\n    *I = ::std::forward<ArgType>(*EltPtr);\n    return I;\n  }\n\npublic:\n  iterator insert(iterator I, T &&Elt) {\n    return insert_one_impl(I, this->forward_value_param(std::move(Elt)));\n  }\n\n  iterator insert(iterator I, const T &Elt) {\n    return insert_one_impl(I, this->forward_value_param(Elt));\n  }\n\n  iterator insert(iterator I, size_type NumToInsert, ValueParamT Elt) {\n    // Convert iterator to elt# to avoid invalidating iterator when we reserve()\n    size_t InsertElt = I - this->begin();\n\n    if (I == this->end()) {  // Important special case for empty vector.\n      append(NumToInsert, Elt);\n      return this->begin()+InsertElt;\n    }\n\n    assert(this->isReferenceToStorage(I) && \"Insertion iterator is out of bounds.\");\n\n    // Ensure there is enough space, and get the (maybe updated) address of\n    // Elt.\n    const T *EltPtr = this->reserveForParamAndGetAddress(Elt, NumToInsert);\n\n    // Uninvalidate the iterator.\n    I = this->begin()+InsertElt;\n\n    // If there are more elements between the insertion point and the end of the\n    // range than there are being inserted, we can use a simple approach to\n    // insertion.  Since we already reserved space, we know that this won't\n    // reallocate the vector.\n    if (size_t(this->end()-I) >= NumToInsert) {\n      T *OldEnd = this->end();\n      append(std::move_iterator<iterator>(this->end() - NumToInsert),\n             std::move_iterator<iterator>(this->end()));\n\n      // Copy the existing elements that get replaced.\n      std::move_backward(I, OldEnd-NumToInsert, OldEnd);\n\n      // If we just moved the element we're inserting, be sure to update\n      // the reference (never happens if TakesParamByValue).\n      if (!TakesParamByValue && I <= EltPtr && EltPtr < this->end())\n        EltPtr += NumToInsert;\n\n      std::fill_n(I, NumToInsert, *EltPtr);\n      return I;\n    }\n\n    // Otherwise, we're inserting more elements than exist already, and we're\n    // not inserting at the end.\n\n    // Move over the elements that we're about to overwrite.\n    T *OldEnd = this->end();\n    this->set_size(this->size() + NumToInsert);\n    size_t NumOverwritten = OldEnd-I;\n    this->uninitialized_move(I, OldEnd, this->end()-NumOverwritten);\n\n    // If we just moved the element we're inserting, be sure to update\n    // the reference (never happens if TakesParamByValue).\n    if (!TakesParamByValue && I <= EltPtr && EltPtr < this->end())\n      EltPtr += NumToInsert;\n\n    // Replace the overwritten part.\n    std::fill_n(I, NumOverwritten, *EltPtr);\n\n    // Insert the non-overwritten middle part.\n    std::uninitialized_fill_n(OldEnd, NumToInsert - NumOverwritten, *EltPtr);\n    return I;\n  }\n\n  template <typename ItTy,\n            typename = std::enable_if_t<std::is_convertible<\n                typename std::iterator_traits<ItTy>::iterator_category,\n                std::input_iterator_tag>::value>>\n  iterator insert(iterator I, ItTy From, ItTy To) {\n    // Convert iterator to elt# to avoid invalidating iterator when we reserve()\n    size_t InsertElt = I - this->begin();\n\n    if (I == this->end()) {  // Important special case for empty vector.\n      append(From, To);\n      return this->begin()+InsertElt;\n    }\n\n    assert(this->isReferenceToStorage(I) && \"Insertion iterator is out of bounds.\");\n\n    // Check that the reserve that follows doesn't invalidate the iterators.\n    this->assertSafeToAddRange(From, To);\n\n    size_t NumToInsert = std::distance(From, To);\n\n    // Ensure there is enough space.\n    reserve(this->size() + NumToInsert);\n\n    // Uninvalidate the iterator.\n    I = this->begin()+InsertElt;\n\n    // If there are more elements between the insertion point and the end of the\n    // range than there are being inserted, we can use a simple approach to\n    // insertion.  Since we already reserved space, we know that this won't\n    // reallocate the vector.\n    if (size_t(this->end()-I) >= NumToInsert) {\n      T *OldEnd = this->end();\n      append(std::move_iterator<iterator>(this->end() - NumToInsert),\n             std::move_iterator<iterator>(this->end()));\n\n      // Copy the existing elements that get replaced.\n      std::move_backward(I, OldEnd-NumToInsert, OldEnd);\n\n      std::copy(From, To, I);\n      return I;\n    }\n\n    // Otherwise, we're inserting more elements than exist already, and we're\n    // not inserting at the end.\n\n    // Move over the elements that we're about to overwrite.\n    T *OldEnd = this->end();\n    this->set_size(this->size() + NumToInsert);\n    size_t NumOverwritten = OldEnd-I;\n    this->uninitialized_move(I, OldEnd, this->end()-NumOverwritten);\n\n    // Replace the overwritten part.\n    for (T *J = I; NumOverwritten > 0; --NumOverwritten) {\n      *J = *From;\n      ++J; ++From;\n    }\n\n    // Insert the non-overwritten middle part.\n    this->uninitialized_copy(From, To, OldEnd);\n    return I;\n  }\n\n  void insert(iterator I, std::initializer_list<T> IL) {\n    insert(I, IL.begin(), IL.end());\n  }\n\n  template <typename... ArgTypes> reference emplace_back(ArgTypes &&... Args) {\n    if (LLVM_UNLIKELY(this->size() >= this->capacity()))\n      return this->growAndEmplaceBack(std::forward<ArgTypes>(Args)...);\n\n    ::new ((void *)this->end()) T(std::forward<ArgTypes>(Args)...);\n    this->set_size(this->size() + 1);\n    return this->back();\n  }\n\n  SmallVectorImpl &operator=(const SmallVectorImpl &RHS);\n\n  SmallVectorImpl &operator=(SmallVectorImpl &&RHS);\n\n  bool operator==(const SmallVectorImpl &RHS) const {\n    if (this->size() != RHS.size()) return false;\n    return std::equal(this->begin(), this->end(), RHS.begin());\n  }\n  bool operator!=(const SmallVectorImpl &RHS) const {\n    return !(*this == RHS);\n  }\n\n  bool operator<(const SmallVectorImpl &RHS) const {\n    return std::lexicographical_compare(this->begin(), this->end(),\n                                        RHS.begin(), RHS.end());\n  }\n};\n\ntemplate <typename T>\nvoid SmallVectorImpl<T>::swap(SmallVectorImpl<T> &RHS) {\n  if (this == &RHS) return;\n\n  // We can only avoid copying elements if neither vector is small.\n  if (!this->isSmall() && !RHS.isSmall()) {\n    std::swap(this->BeginX, RHS.BeginX);\n    std::swap(this->Size, RHS.Size);\n    std::swap(this->Capacity, RHS.Capacity);\n    return;\n  }\n  this->reserve(RHS.size());\n  RHS.reserve(this->size());\n\n  // Swap the shared elements.\n  size_t NumShared = this->size();\n  if (NumShared > RHS.size()) NumShared = RHS.size();\n  for (size_type i = 0; i != NumShared; ++i)\n    std::swap((*this)[i], RHS[i]);\n\n  // Copy over the extra elts.\n  if (this->size() > RHS.size()) {\n    size_t EltDiff = this->size() - RHS.size();\n    this->uninitialized_copy(this->begin()+NumShared, this->end(), RHS.end());\n    RHS.set_size(RHS.size() + EltDiff);\n    this->destroy_range(this->begin()+NumShared, this->end());\n    this->set_size(NumShared);\n  } else if (RHS.size() > this->size()) {\n    size_t EltDiff = RHS.size() - this->size();\n    this->uninitialized_copy(RHS.begin()+NumShared, RHS.end(), this->end());\n    this->set_size(this->size() + EltDiff);\n    this->destroy_range(RHS.begin()+NumShared, RHS.end());\n    RHS.set_size(NumShared);\n  }\n}\n\ntemplate <typename T>\nSmallVectorImpl<T> &SmallVectorImpl<T>::\n  operator=(const SmallVectorImpl<T> &RHS) {\n  // Avoid self-assignment.\n  if (this == &RHS) return *this;\n\n  // If we already have sufficient space, assign the common elements, then\n  // destroy any excess.\n  size_t RHSSize = RHS.size();\n  size_t CurSize = this->size();\n  if (CurSize >= RHSSize) {\n    // Assign common elements.\n    iterator NewEnd;\n    if (RHSSize)\n      NewEnd = std::copy(RHS.begin(), RHS.begin()+RHSSize, this->begin());\n    else\n      NewEnd = this->begin();\n\n    // Destroy excess elements.\n    this->destroy_range(NewEnd, this->end());\n\n    // Trim.\n    this->set_size(RHSSize);\n    return *this;\n  }\n\n  // If we have to grow to have enough elements, destroy the current elements.\n  // This allows us to avoid copying them during the grow.\n  // FIXME: don't do this if they're efficiently moveable.\n  if (this->capacity() < RHSSize) {\n    // Destroy current elements.\n    this->clear();\n    CurSize = 0;\n    this->grow(RHSSize);\n  } else if (CurSize) {\n    // Otherwise, use assignment for the already-constructed elements.\n    std::copy(RHS.begin(), RHS.begin()+CurSize, this->begin());\n  }\n\n  // Copy construct the new elements in place.\n  this->uninitialized_copy(RHS.begin()+CurSize, RHS.end(),\n                           this->begin()+CurSize);\n\n  // Set end.\n  this->set_size(RHSSize);\n  return *this;\n}\n\ntemplate <typename T>\nSmallVectorImpl<T> &SmallVectorImpl<T>::operator=(SmallVectorImpl<T> &&RHS) {\n  // Avoid self-assignment.\n  if (this == &RHS) return *this;\n\n  // If the RHS isn't small, clear this vector and then steal its buffer.\n  if (!RHS.isSmall()) {\n    this->destroy_range(this->begin(), this->end());\n    if (!this->isSmall()) free(this->begin());\n    this->BeginX = RHS.BeginX;\n    this->Size = RHS.Size;\n    this->Capacity = RHS.Capacity;\n    RHS.resetToSmall();\n    return *this;\n  }\n\n  // If we already have sufficient space, assign the common elements, then\n  // destroy any excess.\n  size_t RHSSize = RHS.size();\n  size_t CurSize = this->size();\n  if (CurSize >= RHSSize) {\n    // Assign common elements.\n    iterator NewEnd = this->begin();\n    if (RHSSize)\n      NewEnd = std::move(RHS.begin(), RHS.end(), NewEnd);\n\n    // Destroy excess elements and trim the bounds.\n    this->destroy_range(NewEnd, this->end());\n    this->set_size(RHSSize);\n\n    // Clear the RHS.\n    RHS.clear();\n\n    return *this;\n  }\n\n  // If we have to grow to have enough elements, destroy the current elements.\n  // This allows us to avoid copying them during the grow.\n  // FIXME: this may not actually make any sense if we can efficiently move\n  // elements.\n  if (this->capacity() < RHSSize) {\n    // Destroy current elements.\n    this->clear();\n    CurSize = 0;\n    this->grow(RHSSize);\n  } else if (CurSize) {\n    // Otherwise, use assignment for the already-constructed elements.\n    std::move(RHS.begin(), RHS.begin()+CurSize, this->begin());\n  }\n\n  // Move-construct the new elements in place.\n  this->uninitialized_move(RHS.begin()+CurSize, RHS.end(),\n                           this->begin()+CurSize);\n\n  // Set end.\n  this->set_size(RHSSize);\n\n  RHS.clear();\n  return *this;\n}\n\n/// Storage for the SmallVector elements.  This is specialized for the N=0 case\n/// to avoid allocating unnecessary storage.\ntemplate <typename T, unsigned N>\nstruct SmallVectorStorage {\n  alignas(T) char InlineElts[N * sizeof(T)];\n};\n\n/// We need the storage to be properly aligned even for small-size of 0 so that\n/// the pointer math in \\a SmallVectorTemplateCommon::getFirstEl() is\n/// well-defined.\ntemplate <typename T> struct alignas(T) SmallVectorStorage<T, 0> {};\n\n/// Forward declaration of SmallVector so that\n/// calculateSmallVectorDefaultInlinedElements can reference\n/// `sizeof(SmallVector<T, 0>)`.\ntemplate <typename T, unsigned N> class LLVM_GSL_OWNER SmallVector;\n\n/// Helper class for calculating the default number of inline elements for\n/// `SmallVector<T>`.\n///\n/// This should be migrated to a constexpr function when our minimum\n/// compiler support is enough for multi-statement constexpr functions.\ntemplate <typename T> struct CalculateSmallVectorDefaultInlinedElements {\n  // Parameter controlling the default number of inlined elements\n  // for `SmallVector<T>`.\n  //\n  // The default number of inlined elements ensures that\n  // 1. There is at least one inlined element.\n  // 2. `sizeof(SmallVector<T>) <= kPreferredSmallVectorSizeof` unless\n  // it contradicts 1.\n  static constexpr size_t kPreferredSmallVectorSizeof = 64;\n\n  // static_assert that sizeof(T) is not \"too big\".\n  //\n  // Because our policy guarantees at least one inlined element, it is possible\n  // for an arbitrarily large inlined element to allocate an arbitrarily large\n  // amount of inline storage. We generally consider it an antipattern for a\n  // SmallVector to allocate an excessive amount of inline storage, so we want\n  // to call attention to these cases and make sure that users are making an\n  // intentional decision if they request a lot of inline storage.\n  //\n  // We want this assertion to trigger in pathological cases, but otherwise\n  // not be too easy to hit. To accomplish that, the cutoff is actually somewhat\n  // larger than kPreferredSmallVectorSizeof (otherwise,\n  // `SmallVector<SmallVector<T>>` would be one easy way to trip it, and that\n  // pattern seems useful in practice).\n  //\n  // One wrinkle is that this assertion is in theory non-portable, since\n  // sizeof(T) is in general platform-dependent. However, we don't expect this\n  // to be much of an issue, because most LLVM development happens on 64-bit\n  // hosts, and therefore sizeof(T) is expected to *decrease* when compiled for\n  // 32-bit hosts, dodging the issue. The reverse situation, where development\n  // happens on a 32-bit host and then fails due to sizeof(T) *increasing* on a\n  // 64-bit host, is expected to be very rare.\n  static_assert(\n      sizeof(T) <= 256,\n      \"You are trying to use a default number of inlined elements for \"\n      \"`SmallVector<T>` but `sizeof(T)` is really big! Please use an \"\n      \"explicit number of inlined elements with `SmallVector<T, N>` to make \"\n      \"sure you really want that much inline storage.\");\n\n  // Discount the size of the header itself when calculating the maximum inline\n  // bytes.\n  static constexpr size_t PreferredInlineBytes =\n      kPreferredSmallVectorSizeof - sizeof(SmallVector<T, 0>);\n  static constexpr size_t NumElementsThatFit = PreferredInlineBytes / sizeof(T);\n  static constexpr size_t value =\n      NumElementsThatFit == 0 ? 1 : NumElementsThatFit;\n};\n\n/// This is a 'vector' (really, a variable-sized array), optimized\n/// for the case when the array is small.  It contains some number of elements\n/// in-place, which allows it to avoid heap allocation when the actual number of\n/// elements is below that threshold.  This allows normal \"small\" cases to be\n/// fast without losing generality for large inputs.\n///\n/// \\note\n/// In the absence of a well-motivated choice for the number of inlined\n/// elements \\p N, it is recommended to use \\c SmallVector<T> (that is,\n/// omitting the \\p N). This will choose a default number of inlined elements\n/// reasonable for allocation on the stack (for example, trying to keep \\c\n/// sizeof(SmallVector<T>) around 64 bytes).\n///\n/// \\warning This does not attempt to be exception safe.\n///\n/// \\see https://llvm.org/docs/ProgrammersManual.html#llvm-adt-smallvector-h\ntemplate <typename T,\n          unsigned N = CalculateSmallVectorDefaultInlinedElements<T>::value>\nclass LLVM_GSL_OWNER SmallVector : public SmallVectorImpl<T>,\n                                   SmallVectorStorage<T, N> {\npublic:\n  SmallVector() : SmallVectorImpl<T>(N) {}\n\n  ~SmallVector() {\n    // Destroy the constructed elements in the vector.\n    this->destroy_range(this->begin(), this->end());\n  }\n\n  explicit SmallVector(size_t Size, const T &Value = T())\n    : SmallVectorImpl<T>(N) {\n    this->assign(Size, Value);\n  }\n\n  template <typename ItTy,\n            typename = std::enable_if_t<std::is_convertible<\n                typename std::iterator_traits<ItTy>::iterator_category,\n                std::input_iterator_tag>::value>>\n  SmallVector(ItTy S, ItTy E) : SmallVectorImpl<T>(N) {\n    this->append(S, E);\n  }\n\n  template <typename RangeTy>\n  explicit SmallVector(const iterator_range<RangeTy> &R)\n      : SmallVectorImpl<T>(N) {\n    this->append(R.begin(), R.end());\n  }\n\n  SmallVector(std::initializer_list<T> IL) : SmallVectorImpl<T>(N) {\n    this->assign(IL);\n  }\n\n  SmallVector(const SmallVector &RHS) : SmallVectorImpl<T>(N) {\n    if (!RHS.empty())\n      SmallVectorImpl<T>::operator=(RHS);\n  }\n\n  SmallVector &operator=(const SmallVector &RHS) {\n    SmallVectorImpl<T>::operator=(RHS);\n    return *this;\n  }\n\n  SmallVector(SmallVector &&RHS) : SmallVectorImpl<T>(N) {\n    if (!RHS.empty())\n      SmallVectorImpl<T>::operator=(::std::move(RHS));\n  }\n\n  SmallVector(SmallVectorImpl<T> &&RHS) : SmallVectorImpl<T>(N) {\n    if (!RHS.empty())\n      SmallVectorImpl<T>::operator=(::std::move(RHS));\n  }\n\n  SmallVector &operator=(SmallVector &&RHS) {\n    SmallVectorImpl<T>::operator=(::std::move(RHS));\n    return *this;\n  }\n\n  SmallVector &operator=(SmallVectorImpl<T> &&RHS) {\n    SmallVectorImpl<T>::operator=(::std::move(RHS));\n    return *this;\n  }\n\n  SmallVector &operator=(std::initializer_list<T> IL) {\n    this->assign(IL);\n    return *this;\n  }\n};\n\ntemplate <typename T, unsigned N>\ninline size_t capacity_in_bytes(const SmallVector<T, N> &X) {\n  return X.capacity_in_bytes();\n}\n\n/// Given a range of type R, iterate the entire range and return a\n/// SmallVector with elements of the vector.  This is useful, for example,\n/// when you want to iterate a range and then sort the results.\ntemplate <unsigned Size, typename R>\nSmallVector<typename std::remove_const<typename std::remove_reference<\n                decltype(*std::begin(std::declval<R &>()))>::type>::type,\n            Size>\nto_vector(R &&Range) {\n  return {std::begin(Range), std::end(Range)};\n}\n\n} // end namespace llvm\n\nnamespace std {\n\n  /// Implement std::swap in terms of SmallVector swap.\n  template<typename T>\n  inline void\n  swap(llvm::SmallVectorImpl<T> &LHS, llvm::SmallVectorImpl<T> &RHS) {\n    LHS.swap(RHS);\n  }\n\n  /// Implement std::swap in terms of SmallVector swap.\n  template<typename T, unsigned N>\n  inline void\n  swap(llvm::SmallVector<T, N> &LHS, llvm::SmallVector<T, N> &RHS) {\n    LHS.swap(RHS);\n  }\n\n} // end namespace std\n\n#endif // LLVM_ADT_SMALLVECTOR_H\n"}, "11": {"id": 11, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/StringMap.h", "content": "//===- StringMap.h - String Hash table map interface ------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// This file defines the StringMap class.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_ADT_STRINGMAP_H\n#define LLVM_ADT_STRINGMAP_H\n\n#include \"llvm/ADT/StringMapEntry.h\"\n#include \"llvm/Support/AllocatorBase.h\"\n#include \"llvm/Support/PointerLikeTypeTraits.h\"\n#include <initializer_list>\n#include <iterator>\n\nnamespace llvm {\n\ntemplate <typename ValueTy> class StringMapConstIterator;\ntemplate <typename ValueTy> class StringMapIterator;\ntemplate <typename ValueTy> class StringMapKeyIterator;\n\n/// StringMapImpl - This is the base class of StringMap that is shared among\n/// all of its instantiations.\nclass StringMapImpl {\nprotected:\n  // Array of NumBuckets pointers to entries, null pointers are holes.\n  // TheTable[NumBuckets] contains a sentinel value for easy iteration. Followed\n  // by an array of the actual hash values as unsigned integers.\n  StringMapEntryBase **TheTable = nullptr;\n  unsigned NumBuckets = 0;\n  unsigned NumItems = 0;\n  unsigned NumTombstones = 0;\n  unsigned ItemSize;\n\nprotected:\n  explicit StringMapImpl(unsigned itemSize) : ItemSize(itemSize) {}\n  StringMapImpl(StringMapImpl &&RHS)\n      : TheTable(RHS.TheTable), NumBuckets(RHS.NumBuckets),\n        NumItems(RHS.NumItems), NumTombstones(RHS.NumTombstones),\n        ItemSize(RHS.ItemSize) {\n    RHS.TheTable = nullptr;\n    RHS.NumBuckets = 0;\n    RHS.NumItems = 0;\n    RHS.NumTombstones = 0;\n  }\n\n  StringMapImpl(unsigned InitSize, unsigned ItemSize);\n  unsigned RehashTable(unsigned BucketNo = 0);\n\n  /// LookupBucketFor - Look up the bucket that the specified string should end\n  /// up in.  If it already exists as a key in the map, the Item pointer for the\n  /// specified bucket will be non-null.  Otherwise, it will be null.  In either\n  /// case, the FullHashValue field of the bucket will be set to the hash value\n  /// of the string.\n  unsigned LookupBucketFor(StringRef Key);\n\n  /// FindKey - Look up the bucket that contains the specified key. If it exists\n  /// in the map, return the bucket number of the key.  Otherwise return -1.\n  /// This does not modify the map.\n  int FindKey(StringRef Key) const;\n\n  /// RemoveKey - Remove the specified StringMapEntry from the table, but do not\n  /// delete it.  This aborts if the value isn't in the table.\n  void RemoveKey(StringMapEntryBase *V);\n\n  /// RemoveKey - Remove the StringMapEntry for the specified key from the\n  /// table, returning it.  If the key is not in the table, this returns null.\n  StringMapEntryBase *RemoveKey(StringRef Key);\n\n  /// Allocate the table with the specified number of buckets and otherwise\n  /// setup the map as empty.\n  void init(unsigned Size);\n\npublic:\n  static constexpr uintptr_t TombstoneIntVal =\n      static_cast<uintptr_t>(-1)\n      << PointerLikeTypeTraits<StringMapEntryBase *>::NumLowBitsAvailable;\n\n  static StringMapEntryBase *getTombstoneVal() {\n    return reinterpret_cast<StringMapEntryBase *>(TombstoneIntVal);\n  }\n\n  unsigned getNumBuckets() const { return NumBuckets; }\n  unsigned getNumItems() const { return NumItems; }\n\n  bool empty() const { return NumItems == 0; }\n  unsigned size() const { return NumItems; }\n\n  void swap(StringMapImpl &Other) {\n    std::swap(TheTable, Other.TheTable);\n    std::swap(NumBuckets, Other.NumBuckets);\n    std::swap(NumItems, Other.NumItems);\n    std::swap(NumTombstones, Other.NumTombstones);\n  }\n};\n\n/// StringMap - This is an unconventional map that is specialized for handling\n/// keys that are \"strings\", which are basically ranges of bytes. This does some\n/// funky memory allocation and hashing things to make it extremely efficient,\n/// storing the string data *after* the value in the map.\ntemplate <typename ValueTy, typename AllocatorTy = MallocAllocator>\nclass StringMap : public StringMapImpl {\n  AllocatorTy Allocator;\n\npublic:\n  using MapEntryTy = StringMapEntry<ValueTy>;\n\n  StringMap() : StringMapImpl(static_cast<unsigned>(sizeof(MapEntryTy))) {}\n\n  explicit StringMap(unsigned InitialSize)\n      : StringMapImpl(InitialSize, static_cast<unsigned>(sizeof(MapEntryTy))) {}\n\n  explicit StringMap(AllocatorTy A)\n      : StringMapImpl(static_cast<unsigned>(sizeof(MapEntryTy))), Allocator(A) {\n  }\n\n  StringMap(unsigned InitialSize, AllocatorTy A)\n      : StringMapImpl(InitialSize, static_cast<unsigned>(sizeof(MapEntryTy))),\n        Allocator(A) {}\n\n  StringMap(std::initializer_list<std::pair<StringRef, ValueTy>> List)\n      : StringMapImpl(List.size(), static_cast<unsigned>(sizeof(MapEntryTy))) {\n    for (const auto &P : List) {\n      insert(P);\n    }\n  }\n\n  StringMap(StringMap &&RHS)\n      : StringMapImpl(std::move(RHS)), Allocator(std::move(RHS.Allocator)) {}\n\n  StringMap(const StringMap &RHS)\n      : StringMapImpl(static_cast<unsigned>(sizeof(MapEntryTy))),\n        Allocator(RHS.Allocator) {\n    if (RHS.empty())\n      return;\n\n    // Allocate TheTable of the same size as RHS's TheTable, and set the\n    // sentinel appropriately (and NumBuckets).\n    init(RHS.NumBuckets);\n    unsigned *HashTable = (unsigned *)(TheTable + NumBuckets + 1),\n             *RHSHashTable = (unsigned *)(RHS.TheTable + NumBuckets + 1);\n\n    NumItems = RHS.NumItems;\n    NumTombstones = RHS.NumTombstones;\n    for (unsigned I = 0, E = NumBuckets; I != E; ++I) {\n      StringMapEntryBase *Bucket = RHS.TheTable[I];\n      if (!Bucket || Bucket == getTombstoneVal()) {\n        TheTable[I] = Bucket;\n        continue;\n      }\n\n      TheTable[I] = MapEntryTy::Create(\n          static_cast<MapEntryTy *>(Bucket)->getKey(), Allocator,\n          static_cast<MapEntryTy *>(Bucket)->getValue());\n      HashTable[I] = RHSHashTable[I];\n    }\n\n    // Note that here we've copied everything from the RHS into this object,\n    // tombstones included. We could, instead, have re-probed for each key to\n    // instantiate this new object without any tombstone buckets. The\n    // assumption here is that items are rarely deleted from most StringMaps,\n    // and so tombstones are rare, so the cost of re-probing for all inputs is\n    // not worthwhile.\n  }\n\n  StringMap &operator=(StringMap RHS) {\n    StringMapImpl::swap(RHS);\n    std::swap(Allocator, RHS.Allocator);\n    return *this;\n  }\n\n  ~StringMap() {\n    // Delete all the elements in the map, but don't reset the elements\n    // to default values.  This is a copy of clear(), but avoids unnecessary\n    // work not required in the destructor.\n    if (!empty()) {\n      for (unsigned I = 0, E = NumBuckets; I != E; ++I) {\n        StringMapEntryBase *Bucket = TheTable[I];\n        if (Bucket && Bucket != getTombstoneVal()) {\n          static_cast<MapEntryTy *>(Bucket)->Destroy(Allocator);\n        }\n      }\n    }\n    free(TheTable);\n  }\n\n  AllocatorTy &getAllocator() { return Allocator; }\n  const AllocatorTy &getAllocator() const { return Allocator; }\n\n  using key_type = const char *;\n  using mapped_type = ValueTy;\n  using value_type = StringMapEntry<ValueTy>;\n  using size_type = size_t;\n\n  using const_iterator = StringMapConstIterator<ValueTy>;\n  using iterator = StringMapIterator<ValueTy>;\n\n  iterator begin() { return iterator(TheTable, NumBuckets == 0); }\n  iterator end() { return iterator(TheTable + NumBuckets, true); }\n  const_iterator begin() const {\n    return const_iterator(TheTable, NumBuckets == 0);\n  }\n  const_iterator end() const {\n    return const_iterator(TheTable + NumBuckets, true);\n  }\n\n  iterator_range<StringMapKeyIterator<ValueTy>> keys() const {\n    return make_range(StringMapKeyIterator<ValueTy>(begin()),\n                      StringMapKeyIterator<ValueTy>(end()));\n  }\n\n  iterator find(StringRef Key) {\n    int Bucket = FindKey(Key);\n    if (Bucket == -1)\n      return end();\n    return iterator(TheTable + Bucket, true);\n  }\n\n  const_iterator find(StringRef Key) const {\n    int Bucket = FindKey(Key);\n    if (Bucket == -1)\n      return end();\n    return const_iterator(TheTable + Bucket, true);\n  }\n\n  /// lookup - Return the entry for the specified key, or a default\n  /// constructed value if no such entry exists.\n  ValueTy lookup(StringRef Key) const {\n    const_iterator it = find(Key);\n    if (it != end())\n      return it->second;\n    return ValueTy();\n  }\n\n  /// Lookup the ValueTy for the \\p Key, or create a default constructed value\n  /// if the key is not in the map.\n  ValueTy &operator[](StringRef Key) { return try_emplace(Key).first->second; }\n\n  /// count - Return 1 if the element is in the map, 0 otherwise.\n  size_type count(StringRef Key) const { return find(Key) == end() ? 0 : 1; }\n\n  template <typename InputTy>\n  size_type count(const StringMapEntry<InputTy> &MapEntry) const {\n    return count(MapEntry.getKey());\n  }\n\n  /// equal - check whether both of the containers are equal.\n  bool operator==(const StringMap &RHS) const {\n    if (size() != RHS.size())\n      return false;\n\n    for (const auto &KeyValue : *this) {\n      auto FindInRHS = RHS.find(KeyValue.getKey());\n\n      if (FindInRHS == RHS.end())\n        return false;\n\n      if (!(KeyValue.getValue() == FindInRHS->getValue()))\n        return false;\n    }\n\n    return true;\n  }\n\n  bool operator!=(const StringMap &RHS) const { return !(*this == RHS); }\n\n  /// insert - Insert the specified key/value pair into the map.  If the key\n  /// already exists in the map, return false and ignore the request, otherwise\n  /// insert it and return true.\n  bool insert(MapEntryTy *KeyValue) {\n    unsigned BucketNo = LookupBucketFor(KeyValue->getKey());\n    StringMapEntryBase *&Bucket = TheTable[BucketNo];\n    if (Bucket && Bucket != getTombstoneVal())\n      return false; // Already exists in map.\n\n    if (Bucket == getTombstoneVal())\n      --NumTombstones;\n    Bucket = KeyValue;\n    ++NumItems;\n    assert(NumItems + NumTombstones <= NumBuckets);\n\n    RehashTable();\n    return true;\n  }\n\n  /// insert - Inserts the specified key/value pair into the map if the key\n  /// isn't already in the map. The bool component of the returned pair is true\n  /// if and only if the insertion takes place, and the iterator component of\n  /// the pair points to the element with key equivalent to the key of the pair.\n  std::pair<iterator, bool> insert(std::pair<StringRef, ValueTy> KV) {\n    return try_emplace(KV.first, std::move(KV.second));\n  }\n\n  /// Inserts an element or assigns to the current element if the key already\n  /// exists. The return type is the same as try_emplace.\n  template <typename V>\n  std::pair<iterator, bool> insert_or_assign(StringRef Key, V &&Val) {\n    auto Ret = try_emplace(Key, std::forward<V>(Val));\n    if (!Ret.second)\n      Ret.first->second = std::forward<V>(Val);\n    return Ret;\n  }\n\n  /// Emplace a new element for the specified key into the map if the key isn't\n  /// already in the map. The bool component of the returned pair is true\n  /// if and only if the insertion takes place, and the iterator component of\n  /// the pair points to the element with key equivalent to the key of the pair.\n  template <typename... ArgsTy>\n  std::pair<iterator, bool> try_emplace(StringRef Key, ArgsTy &&... Args) {\n    unsigned BucketNo = LookupBucketFor(Key);\n    StringMapEntryBase *&Bucket = TheTable[BucketNo];\n    if (Bucket && Bucket != getTombstoneVal())\n      return std::make_pair(iterator(TheTable + BucketNo, false),\n                            false); // Already exists in map.\n\n    if (Bucket == getTombstoneVal())\n      --NumTombstones;\n    Bucket = MapEntryTy::Create(Key, Allocator, std::forward<ArgsTy>(Args)...);\n    ++NumItems;\n    assert(NumItems + NumTombstones <= NumBuckets);\n\n    BucketNo = RehashTable(BucketNo);\n    return std::make_pair(iterator(TheTable + BucketNo, false), true);\n  }\n\n  // clear - Empties out the StringMap\n  void clear() {\n    if (empty())\n      return;\n\n    // Zap all values, resetting the keys back to non-present (not tombstone),\n    // which is safe because we're removing all elements.\n    for (unsigned I = 0, E = NumBuckets; I != E; ++I) {\n      StringMapEntryBase *&Bucket = TheTable[I];\n      if (Bucket && Bucket != getTombstoneVal()) {\n        static_cast<MapEntryTy *>(Bucket)->Destroy(Allocator);\n      }\n      Bucket = nullptr;\n    }\n\n    NumItems = 0;\n    NumTombstones = 0;\n  }\n\n  /// remove - Remove the specified key/value pair from the map, but do not\n  /// erase it.  This aborts if the key is not in the map.\n  void remove(MapEntryTy *KeyValue) { RemoveKey(KeyValue); }\n\n  void erase(iterator I) {\n    MapEntryTy &V = *I;\n    remove(&V);\n    V.Destroy(Allocator);\n  }\n\n  bool erase(StringRef Key) {\n    iterator I = find(Key);\n    if (I == end())\n      return false;\n    erase(I);\n    return true;\n  }\n};\n\ntemplate <typename DerivedTy, typename ValueTy>\nclass StringMapIterBase\n    : public iterator_facade_base<DerivedTy, std::forward_iterator_tag,\n                                  ValueTy> {\nprotected:\n  StringMapEntryBase **Ptr = nullptr;\n\npublic:\n  StringMapIterBase() = default;\n\n  explicit StringMapIterBase(StringMapEntryBase **Bucket,\n                             bool NoAdvance = false)\n      : Ptr(Bucket) {\n    if (!NoAdvance)\n      AdvancePastEmptyBuckets();\n  }\n\n  DerivedTy &operator=(const DerivedTy &Other) {\n    Ptr = Other.Ptr;\n    return static_cast<DerivedTy &>(*this);\n  }\n\n  friend bool operator==(const DerivedTy &LHS, const DerivedTy &RHS) {\n    return LHS.Ptr == RHS.Ptr;\n  }\n\n  DerivedTy &operator++() { // Preincrement\n    ++Ptr;\n    AdvancePastEmptyBuckets();\n    return static_cast<DerivedTy &>(*this);\n  }\n\n  DerivedTy operator++(int) { // Post-increment\n    DerivedTy Tmp(Ptr);\n    ++*this;\n    return Tmp;\n  }\n\nprivate:\n  void AdvancePastEmptyBuckets() {\n    while (*Ptr == nullptr || *Ptr == StringMapImpl::getTombstoneVal())\n      ++Ptr;\n  }\n};\n\ntemplate <typename ValueTy>\nclass StringMapConstIterator\n    : public StringMapIterBase<StringMapConstIterator<ValueTy>,\n                               const StringMapEntry<ValueTy>> {\n  using base = StringMapIterBase<StringMapConstIterator<ValueTy>,\n                                 const StringMapEntry<ValueTy>>;\n\npublic:\n  StringMapConstIterator() = default;\n  explicit StringMapConstIterator(StringMapEntryBase **Bucket,\n                                  bool NoAdvance = false)\n      : base(Bucket, NoAdvance) {}\n\n  const StringMapEntry<ValueTy> &operator*() const {\n    return *static_cast<const StringMapEntry<ValueTy> *>(*this->Ptr);\n  }\n};\n\ntemplate <typename ValueTy>\nclass StringMapIterator : public StringMapIterBase<StringMapIterator<ValueTy>,\n                                                   StringMapEntry<ValueTy>> {\n  using base =\n      StringMapIterBase<StringMapIterator<ValueTy>, StringMapEntry<ValueTy>>;\n\npublic:\n  StringMapIterator() = default;\n  explicit StringMapIterator(StringMapEntryBase **Bucket,\n                             bool NoAdvance = false)\n      : base(Bucket, NoAdvance) {}\n\n  StringMapEntry<ValueTy> &operator*() const {\n    return *static_cast<StringMapEntry<ValueTy> *>(*this->Ptr);\n  }\n\n  operator StringMapConstIterator<ValueTy>() const {\n    return StringMapConstIterator<ValueTy>(this->Ptr, true);\n  }\n};\n\ntemplate <typename ValueTy>\nclass StringMapKeyIterator\n    : public iterator_adaptor_base<StringMapKeyIterator<ValueTy>,\n                                   StringMapConstIterator<ValueTy>,\n                                   std::forward_iterator_tag, StringRef> {\n  using base = iterator_adaptor_base<StringMapKeyIterator<ValueTy>,\n                                     StringMapConstIterator<ValueTy>,\n                                     std::forward_iterator_tag, StringRef>;\n\npublic:\n  StringMapKeyIterator() = default;\n  explicit StringMapKeyIterator(StringMapConstIterator<ValueTy> Iter)\n      : base(std::move(Iter)) {}\n\n  StringRef &operator*() {\n    Key = this->wrapped()->getKey();\n    return Key;\n  }\n\nprivate:\n  StringRef Key;\n};\n\n} // end namespace llvm\n\n#endif // LLVM_ADT_STRINGMAP_H\n"}, "12": {"id": 12, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/StringMapEntry.h", "content": "//===- StringMapEntry.h - String Hash table map interface -------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// This file defines the StringMapEntry class - it is intended to be a low\n// dependency implementation detail of StringMap that is more suitable for\n// inclusion in public headers than StringMap.h itself is.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_ADT_STRINGMAPENTRY_H\n#define LLVM_ADT_STRINGMAPENTRY_H\n\n#include \"llvm/ADT/StringRef.h\"\n\nnamespace llvm {\n\n/// StringMapEntryBase - Shared base class of StringMapEntry instances.\nclass StringMapEntryBase {\n  size_t keyLength;\n\npublic:\n  explicit StringMapEntryBase(size_t keyLength) : keyLength(keyLength) {}\n\n  size_t getKeyLength() const { return keyLength; }\n};\n\n/// StringMapEntryStorage - Holds the value in a StringMapEntry.\n///\n/// Factored out into a separate base class to make it easier to specialize.\n/// This is primarily intended to support StringSet, which doesn't need a value\n/// stored at all.\ntemplate <typename ValueTy>\nclass StringMapEntryStorage : public StringMapEntryBase {\npublic:\n  ValueTy second;\n\n  explicit StringMapEntryStorage(size_t keyLength)\n      : StringMapEntryBase(keyLength), second() {}\n  template <typename... InitTy>\n  StringMapEntryStorage(size_t keyLength, InitTy &&... initVals)\n      : StringMapEntryBase(keyLength),\n        second(std::forward<InitTy>(initVals)...) {}\n  StringMapEntryStorage(StringMapEntryStorage &e) = delete;\n\n  const ValueTy &getValue() const { return second; }\n  ValueTy &getValue() { return second; }\n\n  void setValue(const ValueTy &V) { second = V; }\n};\n\ntemplate <> class StringMapEntryStorage<NoneType> : public StringMapEntryBase {\npublic:\n  explicit StringMapEntryStorage(size_t keyLength, NoneType none = None)\n      : StringMapEntryBase(keyLength) {}\n  StringMapEntryStorage(StringMapEntryStorage &entry) = delete;\n\n  NoneType getValue() const { return None; }\n};\n\n/// StringMapEntry - This is used to represent one value that is inserted into\n/// a StringMap.  It contains the Value itself and the key: the string length\n/// and data.\ntemplate <typename ValueTy>\nclass StringMapEntry final : public StringMapEntryStorage<ValueTy> {\npublic:\n  using StringMapEntryStorage<ValueTy>::StringMapEntryStorage;\n\n  StringRef getKey() const {\n    return StringRef(getKeyData(), this->getKeyLength());\n  }\n\n  /// getKeyData - Return the start of the string data that is the key for this\n  /// value.  The string data is always stored immediately after the\n  /// StringMapEntry object.\n  const char *getKeyData() const {\n    return reinterpret_cast<const char *>(this + 1);\n  }\n\n  StringRef first() const {\n    return StringRef(getKeyData(), this->getKeyLength());\n  }\n\n  /// Create a StringMapEntry for the specified key construct the value using\n  /// \\p InitiVals.\n  template <typename AllocatorTy, typename... InitTy>\n  static StringMapEntry *Create(StringRef key, AllocatorTy &allocator,\n                                InitTy &&... initVals) {\n    size_t keyLength = key.size();\n\n    // Allocate a new item with space for the string at the end and a null\n    // terminator.\n    size_t allocSize = sizeof(StringMapEntry) + keyLength + 1;\n    size_t alignment = alignof(StringMapEntry);\n\n    StringMapEntry *newItem =\n        static_cast<StringMapEntry *>(allocator.Allocate(allocSize, alignment));\n    assert(newItem && \"Unhandled out-of-memory\");\n\n    // Construct the value.\n    new (newItem) StringMapEntry(keyLength, std::forward<InitTy>(initVals)...);\n\n    // Copy the string information.\n    char *strBuffer = const_cast<char *>(newItem->getKeyData());\n    if (keyLength > 0)\n      memcpy(strBuffer, key.data(), keyLength);\n    strBuffer[keyLength] = 0; // Null terminate for convenience of clients.\n    return newItem;\n  }\n\n  /// GetStringMapEntryFromKeyData - Given key data that is known to be embedded\n  /// into a StringMapEntry, return the StringMapEntry itself.\n  static StringMapEntry &GetStringMapEntryFromKeyData(const char *keyData) {\n    char *ptr = const_cast<char *>(keyData) - sizeof(StringMapEntry<ValueTy>);\n    return *reinterpret_cast<StringMapEntry *>(ptr);\n  }\n\n  /// Destroy - Destroy this StringMapEntry, releasing memory back to the\n  /// specified allocator.\n  template <typename AllocatorTy> void Destroy(AllocatorTy &allocator) {\n    // Free memory referenced by the item.\n    size_t AllocSize = sizeof(StringMapEntry) + this->getKeyLength() + 1;\n    this->~StringMapEntry();\n    allocator.Deallocate(static_cast<void *>(this), AllocSize,\n                         alignof(StringMapEntry));\n  }\n};\n\n} // end namespace llvm\n\n#endif // LLVM_ADT_STRINGMAPENTRY_H\n"}, "13": {"id": 13, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/StringRef.h", "content": "//===- StringRef.h - Constant String Reference Wrapper ----------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_ADT_STRINGREF_H\n#define LLVM_ADT_STRINGREF_H\n\n#include \"llvm/ADT/STLExtras.h\"\n#include \"llvm/ADT/iterator_range.h\"\n#include \"llvm/Support/Compiler.h\"\n#include <algorithm>\n#include <cassert>\n#include <cstddef>\n#include <cstring>\n#include <limits>\n#include <string>\n#if __cplusplus > 201402L\n#include <string_view>\n#endif\n#include <type_traits>\n#include <utility>\n\n// Declare the __builtin_strlen intrinsic for MSVC so it can be used in\n// constexpr context.\n#if defined(_MSC_VER)\nextern \"C\" size_t __builtin_strlen(const char *);\n#endif\n\nnamespace llvm {\n\n  class APInt;\n  class hash_code;\n  template <typename T> class SmallVectorImpl;\n  class StringRef;\n\n  /// Helper functions for StringRef::getAsInteger.\n  bool getAsUnsignedInteger(StringRef Str, unsigned Radix,\n                            unsigned long long &Result);\n\n  bool getAsSignedInteger(StringRef Str, unsigned Radix, long long &Result);\n\n  bool consumeUnsignedInteger(StringRef &Str, unsigned Radix,\n                              unsigned long long &Result);\n  bool consumeSignedInteger(StringRef &Str, unsigned Radix, long long &Result);\n\n  /// StringRef - Represent a constant reference to a string, i.e. a character\n  /// array and a length, which need not be null terminated.\n  ///\n  /// This class does not own the string data, it is expected to be used in\n  /// situations where the character data resides in some other buffer, whose\n  /// lifetime extends past that of the StringRef. For this reason, it is not in\n  /// general safe to store a StringRef.\n  class LLVM_GSL_POINTER StringRef {\n  public:\n    static constexpr size_t npos = ~size_t(0);\n\n    using iterator = const char *;\n    using const_iterator = const char *;\n    using size_type = size_t;\n\n  private:\n    /// The start of the string, in an external buffer.\n    const char *Data = nullptr;\n\n    /// The length of the string.\n    size_t Length = 0;\n\n    // Workaround memcmp issue with null pointers (undefined behavior)\n    // by providing a specialized version\n    static int compareMemory(const char *Lhs, const char *Rhs, size_t Length) {\n      if (Length == 0) { return 0; }\n      return ::memcmp(Lhs,Rhs,Length);\n    }\n\n    // Constexpr version of std::strlen.\n    static constexpr size_t strLen(const char *Str) {\n#if __cplusplus > 201402L\n      return std::char_traits<char>::length(Str);\n#elif __has_builtin(__builtin_strlen) || defined(__GNUC__) || \\\n    (defined(_MSC_VER) && _MSC_VER >= 1916)\n      return __builtin_strlen(Str);\n#else\n      const char *Begin = Str;\n      while (*Str != '\\0')\n        ++Str;\n      return Str - Begin;\n#endif\n    }\n\n  public:\n    /// @name Constructors\n    /// @{\n\n    /// Construct an empty string ref.\n    /*implicit*/ StringRef() = default;\n\n    /// Disable conversion from nullptr.  This prevents things like\n    /// if (S == nullptr)\n    StringRef(std::nullptr_t) = delete;\n\n    /// Construct a string ref from a cstring.\n    /*implicit*/ constexpr StringRef(const char *Str)\n        : Data(Str), Length(Str ? strLen(Str) : 0) {}\n\n    /// Construct a string ref from a pointer and length.\n    /*implicit*/ constexpr StringRef(const char *data, size_t length)\n        : Data(data), Length(length) {}\n\n    /// Construct a string ref from an std::string.\n    /*implicit*/ StringRef(const std::string &Str)\n      : Data(Str.data()), Length(Str.length()) {}\n\n#if __cplusplus > 201402L\n    /// Construct a string ref from an std::string_view.\n    /*implicit*/ constexpr StringRef(std::string_view Str)\n        : Data(Str.data()), Length(Str.size()) {}\n#endif\n\n    static StringRef withNullAsEmpty(const char *data) {\n      return StringRef(data ? data : \"\");\n    }\n\n    /// @}\n    /// @name Iterators\n    /// @{\n\n    iterator begin() const { return Data; }\n\n    iterator end() const { return Data + Length; }\n\n    const unsigned char *bytes_begin() const {\n      return reinterpret_cast<const unsigned char *>(begin());\n    }\n    const unsigned char *bytes_end() const {\n      return reinterpret_cast<const unsigned char *>(end());\n    }\n    iterator_range<const unsigned char *> bytes() const {\n      return make_range(bytes_begin(), bytes_end());\n    }\n\n    /// @}\n    /// @name String Operations\n    /// @{\n\n    /// data - Get a pointer to the start of the string (which may not be null\n    /// terminated).\n    LLVM_NODISCARD\n    const char *data() const { return Data; }\n\n    /// empty - Check if the string is empty.\n    LLVM_NODISCARD\n    bool empty() const { return Length == 0; }\n\n    /// size - Get the string size.\n    LLVM_NODISCARD\n    size_t size() const { return Length; }\n\n    /// front - Get the first character in the string.\n    LLVM_NODISCARD\n    char front() const {\n      assert(!empty());\n      return Data[0];\n    }\n\n    /// back - Get the last character in the string.\n    LLVM_NODISCARD\n    char back() const {\n      assert(!empty());\n      return Data[Length-1];\n    }\n\n    // copy - Allocate copy in Allocator and return StringRef to it.\n    template <typename Allocator>\n    LLVM_NODISCARD StringRef copy(Allocator &A) const {\n      // Don't request a length 0 copy from the allocator.\n      if (empty())\n        return StringRef();\n      char *S = A.template Allocate<char>(Length);\n      std::copy(begin(), end(), S);\n      return StringRef(S, Length);\n    }\n\n    /// equals - Check for string equality, this is more efficient than\n    /// compare() when the relative ordering of inequal strings isn't needed.\n    LLVM_NODISCARD\n    bool equals(StringRef RHS) const {\n      return (Length == RHS.Length &&\n              compareMemory(Data, RHS.Data, RHS.Length) == 0);\n    }\n\n    /// equals_lower - Check for string equality, ignoring case.\n    LLVM_NODISCARD\n    bool equals_lower(StringRef RHS) const {\n      return Length == RHS.Length && compare_lower(RHS) == 0;\n    }\n\n    /// compare - Compare two strings; the result is -1, 0, or 1 if this string\n    /// is lexicographically less than, equal to, or greater than the \\p RHS.\n    LLVM_NODISCARD\n    int compare(StringRef RHS) const {\n      // Check the prefix for a mismatch.\n      if (int Res = compareMemory(Data, RHS.Data, std::min(Length, RHS.Length)))\n        return Res < 0 ? -1 : 1;\n\n      // Otherwise the prefixes match, so we only need to check the lengths.\n      if (Length == RHS.Length)\n        return 0;\n      return Length < RHS.Length ? -1 : 1;\n    }\n\n    /// compare_lower - Compare two strings, ignoring case.\n    LLVM_NODISCARD\n    int compare_lower(StringRef RHS) const;\n\n    /// compare_numeric - Compare two strings, treating sequences of digits as\n    /// numbers.\n    LLVM_NODISCARD\n    int compare_numeric(StringRef RHS) const;\n\n    /// Determine the edit distance between this string and another\n    /// string.\n    ///\n    /// \\param Other the string to compare this string against.\n    ///\n    /// \\param AllowReplacements whether to allow character\n    /// replacements (change one character into another) as a single\n    /// operation, rather than as two operations (an insertion and a\n    /// removal).\n    ///\n    /// \\param MaxEditDistance If non-zero, the maximum edit distance that\n    /// this routine is allowed to compute. If the edit distance will exceed\n    /// that maximum, returns \\c MaxEditDistance+1.\n    ///\n    /// \\returns the minimum number of character insertions, removals,\n    /// or (if \\p AllowReplacements is \\c true) replacements needed to\n    /// transform one of the given strings into the other. If zero,\n    /// the strings are identical.\n    LLVM_NODISCARD\n    unsigned edit_distance(StringRef Other, bool AllowReplacements = true,\n                           unsigned MaxEditDistance = 0) const;\n\n    /// str - Get the contents as an std::string.\n    LLVM_NODISCARD\n    std::string str() const {\n      if (!Data) return std::string();\n      return std::string(Data, Length);\n    }\n\n    /// @}\n    /// @name Operator Overloads\n    /// @{\n\n    LLVM_NODISCARD\n    char operator[](size_t Index) const {\n      assert(Index < Length && \"Invalid index!\");\n      return Data[Index];\n    }\n\n    /// Disallow accidental assignment from a temporary std::string.\n    ///\n    /// The declaration here is extra complicated so that `stringRef = {}`\n    /// and `stringRef = \"abc\"` continue to select the move assignment operator.\n    template <typename T>\n    std::enable_if_t<std::is_same<T, std::string>::value, StringRef> &\n    operator=(T &&Str) = delete;\n\n    /// @}\n    /// @name Type Conversions\n    /// @{\n\n    explicit operator std::string() const { return str(); }\n\n#if __cplusplus > 201402L\n    operator std::string_view() const {\n      return std::string_view(data(), size());\n    }\n#endif\n\n    /// @}\n    /// @name String Predicates\n    /// @{\n\n    /// Check if this string starts with the given \\p Prefix.\n    LLVM_NODISCARD\n    bool startswith(StringRef Prefix) const {\n      return Length >= Prefix.Length &&\n             compareMemory(Data, Prefix.Data, Prefix.Length) == 0;\n    }\n\n    /// Check if this string starts with the given \\p Prefix, ignoring case.\n    LLVM_NODISCARD\n    bool startswith_lower(StringRef Prefix) const;\n\n    /// Check if this string ends with the given \\p Suffix.\n    LLVM_NODISCARD\n    bool endswith(StringRef Suffix) const {\n      return Length >= Suffix.Length &&\n        compareMemory(end() - Suffix.Length, Suffix.Data, Suffix.Length) == 0;\n    }\n\n    /// Check if this string ends with the given \\p Suffix, ignoring case.\n    LLVM_NODISCARD\n    bool endswith_lower(StringRef Suffix) const;\n\n    /// @}\n    /// @name String Searching\n    /// @{\n\n    /// Search for the first character \\p C in the string.\n    ///\n    /// \\returns The index of the first occurrence of \\p C, or npos if not\n    /// found.\n    LLVM_NODISCARD\n    size_t find(char C, size_t From = 0) const {\n      size_t FindBegin = std::min(From, Length);\n      if (FindBegin < Length) { // Avoid calling memchr with nullptr.\n        // Just forward to memchr, which is faster than a hand-rolled loop.\n        if (const void *P = ::memchr(Data + FindBegin, C, Length - FindBegin))\n          return static_cast<const char *>(P) - Data;\n      }\n      return npos;\n    }\n\n    /// Search for the first character \\p C in the string, ignoring case.\n    ///\n    /// \\returns The index of the first occurrence of \\p C, or npos if not\n    /// found.\n    LLVM_NODISCARD\n    size_t find_lower(char C, size_t From = 0) const;\n\n    /// Search for the first character satisfying the predicate \\p F\n    ///\n    /// \\returns The index of the first character satisfying \\p F starting from\n    /// \\p From, or npos if not found.\n    LLVM_NODISCARD\n    size_t find_if(function_ref<bool(char)> F, size_t From = 0) const {\n      StringRef S = drop_front(From);\n      while (!S.empty()) {\n        if (F(S.front()))\n          return size() - S.size();\n        S = S.drop_front();\n      }\n      return npos;\n    }\n\n    /// Search for the first character not satisfying the predicate \\p F\n    ///\n    /// \\returns The index of the first character not satisfying \\p F starting\n    /// from \\p From, or npos if not found.\n    LLVM_NODISCARD\n    size_t find_if_not(function_ref<bool(char)> F, size_t From = 0) const {\n      return find_if([F](char c) { return !F(c); }, From);\n    }\n\n    /// Search for the first string \\p Str in the string.\n    ///\n    /// \\returns The index of the first occurrence of \\p Str, or npos if not\n    /// found.\n    LLVM_NODISCARD\n    size_t find(StringRef Str, size_t From = 0) const;\n\n    /// Search for the first string \\p Str in the string, ignoring case.\n    ///\n    /// \\returns The index of the first occurrence of \\p Str, or npos if not\n    /// found.\n    LLVM_NODISCARD\n    size_t find_lower(StringRef Str, size_t From = 0) const;\n\n    /// Search for the last character \\p C in the string.\n    ///\n    /// \\returns The index of the last occurrence of \\p C, or npos if not\n    /// found.\n    LLVM_NODISCARD\n    size_t rfind(char C, size_t From = npos) const {\n      From = std::min(From, Length);\n      size_t i = From;\n      while (i != 0) {\n        --i;\n        if (Data[i] == C)\n          return i;\n      }\n      return npos;\n    }\n\n    /// Search for the last character \\p C in the string, ignoring case.\n    ///\n    /// \\returns The index of the last occurrence of \\p C, or npos if not\n    /// found.\n    LLVM_NODISCARD\n    size_t rfind_lower(char C, size_t From = npos) const;\n\n    /// Search for the last string \\p Str in the string.\n    ///\n    /// \\returns The index of the last occurrence of \\p Str, or npos if not\n    /// found.\n    LLVM_NODISCARD\n    size_t rfind(StringRef Str) const;\n\n    /// Search for the last string \\p Str in the string, ignoring case.\n    ///\n    /// \\returns The index of the last occurrence of \\p Str, or npos if not\n    /// found.\n    LLVM_NODISCARD\n    size_t rfind_lower(StringRef Str) const;\n\n    /// Find the first character in the string that is \\p C, or npos if not\n    /// found. Same as find.\n    LLVM_NODISCARD\n    size_t find_first_of(char C, size_t From = 0) const {\n      return find(C, From);\n    }\n\n    /// Find the first character in the string that is in \\p Chars, or npos if\n    /// not found.\n    ///\n    /// Complexity: O(size() + Chars.size())\n    LLVM_NODISCARD\n    size_t find_first_of(StringRef Chars, size_t From = 0) const;\n\n    /// Find the first character in the string that is not \\p C or npos if not\n    /// found.\n    LLVM_NODISCARD\n    size_t find_first_not_of(char C, size_t From = 0) const;\n\n    /// Find the first character in the string that is not in the string\n    /// \\p Chars, or npos if not found.\n    ///\n    /// Complexity: O(size() + Chars.size())\n    LLVM_NODISCARD\n    size_t find_first_not_of(StringRef Chars, size_t From = 0) const;\n\n    /// Find the last character in the string that is \\p C, or npos if not\n    /// found.\n    LLVM_NODISCARD\n    size_t find_last_of(char C, size_t From = npos) const {\n      return rfind(C, From);\n    }\n\n    /// Find the last character in the string that is in \\p C, or npos if not\n    /// found.\n    ///\n    /// Complexity: O(size() + Chars.size())\n    LLVM_NODISCARD\n    size_t find_last_of(StringRef Chars, size_t From = npos) const;\n\n    /// Find the last character in the string that is not \\p C, or npos if not\n    /// found.\n    LLVM_NODISCARD\n    size_t find_last_not_of(char C, size_t From = npos) const;\n\n    /// Find the last character in the string that is not in \\p Chars, or\n    /// npos if not found.\n    ///\n    /// Complexity: O(size() + Chars.size())\n    LLVM_NODISCARD\n    size_t find_last_not_of(StringRef Chars, size_t From = npos) const;\n\n    /// Return true if the given string is a substring of *this, and false\n    /// otherwise.\n    LLVM_NODISCARD\n    bool contains(StringRef Other) const { return find(Other) != npos; }\n\n    /// Return true if the given character is contained in *this, and false\n    /// otherwise.\n    LLVM_NODISCARD\n    bool contains(char C) const { return find_first_of(C) != npos; }\n\n    /// Return true if the given string is a substring of *this, and false\n    /// otherwise.\n    LLVM_NODISCARD\n    bool contains_lower(StringRef Other) const {\n      return find_lower(Other) != npos;\n    }\n\n    /// Return true if the given character is contained in *this, and false\n    /// otherwise.\n    LLVM_NODISCARD\n    bool contains_lower(char C) const { return find_lower(C) != npos; }\n\n    /// @}\n    /// @name Helpful Algorithms\n    /// @{\n\n    /// Return the number of occurrences of \\p C in the string.\n    LLVM_NODISCARD\n    size_t count(char C) const {\n      size_t Count = 0;\n      for (size_t i = 0, e = Length; i != e; ++i)\n        if (Data[i] == C)\n          ++Count;\n      return Count;\n    }\n\n    /// Return the number of non-overlapped occurrences of \\p Str in\n    /// the string.\n    size_t count(StringRef Str) const;\n\n    /// Parse the current string as an integer of the specified radix.  If\n    /// \\p Radix is specified as zero, this does radix autosensing using\n    /// extended C rules: 0 is octal, 0x is hex, 0b is binary.\n    ///\n    /// If the string is invalid or if only a subset of the string is valid,\n    /// this returns true to signify the error.  The string is considered\n    /// erroneous if empty or if it overflows T.\n    template <typename T>\n    std::enable_if_t<std::numeric_limits<T>::is_signed, bool>\n    getAsInteger(unsigned Radix, T &Result) const {\n      long long LLVal;\n      if (getAsSignedInteger(*this, Radix, LLVal) ||\n            static_cast<T>(LLVal) != LLVal)\n        return true;\n      Result = LLVal;\n      return false;\n    }\n\n    template <typename T>\n    std::enable_if_t<!std::numeric_limits<T>::is_signed, bool>\n    getAsInteger(unsigned Radix, T &Result) const {\n      unsigned long long ULLVal;\n      // The additional cast to unsigned long long is required to avoid the\n      // Visual C++ warning C4805: '!=' : unsafe mix of type 'bool' and type\n      // 'unsigned __int64' when instantiating getAsInteger with T = bool.\n      if (getAsUnsignedInteger(*this, Radix, ULLVal) ||\n          static_cast<unsigned long long>(static_cast<T>(ULLVal)) != ULLVal)\n        return true;\n      Result = ULLVal;\n      return false;\n    }\n\n    /// Parse the current string as an integer of the specified radix.  If\n    /// \\p Radix is specified as zero, this does radix autosensing using\n    /// extended C rules: 0 is octal, 0x is hex, 0b is binary.\n    ///\n    /// If the string does not begin with a number of the specified radix,\n    /// this returns true to signify the error. The string is considered\n    /// erroneous if empty or if it overflows T.\n    /// The portion of the string representing the discovered numeric value\n    /// is removed from the beginning of the string.\n    template <typename T>\n    std::enable_if_t<std::numeric_limits<T>::is_signed, bool>\n    consumeInteger(unsigned Radix, T &Result) {\n      long long LLVal;\n      if (consumeSignedInteger(*this, Radix, LLVal) ||\n          static_cast<long long>(static_cast<T>(LLVal)) != LLVal)\n        return true;\n      Result = LLVal;\n      return false;\n    }\n\n    template <typename T>\n    std::enable_if_t<!std::numeric_limits<T>::is_signed, bool>\n    consumeInteger(unsigned Radix, T &Result) {\n      unsigned long long ULLVal;\n      if (consumeUnsignedInteger(*this, Radix, ULLVal) ||\n          static_cast<unsigned long long>(static_cast<T>(ULLVal)) != ULLVal)\n        return true;\n      Result = ULLVal;\n      return false;\n    }\n\n    /// Parse the current string as an integer of the specified \\p Radix, or of\n    /// an autosensed radix if the \\p Radix given is 0.  The current value in\n    /// \\p Result is discarded, and the storage is changed to be wide enough to\n    /// store the parsed integer.\n    ///\n    /// \\returns true if the string does not solely consist of a valid\n    /// non-empty number in the appropriate base.\n    ///\n    /// APInt::fromString is superficially similar but assumes the\n    /// string is well-formed in the given radix.\n    bool getAsInteger(unsigned Radix, APInt &Result) const;\n\n    /// Parse the current string as an IEEE double-precision floating\n    /// point value.  The string must be a well-formed double.\n    ///\n    /// If \\p AllowInexact is false, the function will fail if the string\n    /// cannot be represented exactly.  Otherwise, the function only fails\n    /// in case of an overflow or underflow, or an invalid floating point\n    /// representation.\n    bool getAsDouble(double &Result, bool AllowInexact = true) const;\n\n    /// @}\n    /// @name String Operations\n    /// @{\n\n    // Convert the given ASCII string to lowercase.\n    LLVM_NODISCARD\n    std::string lower() const;\n\n    /// Convert the given ASCII string to uppercase.\n    LLVM_NODISCARD\n    std::string upper() const;\n\n    /// @}\n    /// @name Substring Operations\n    /// @{\n\n    /// Return a reference to the substring from [Start, Start + N).\n    ///\n    /// \\param Start The index of the starting character in the substring; if\n    /// the index is npos or greater than the length of the string then the\n    /// empty substring will be returned.\n    ///\n    /// \\param N The number of characters to included in the substring. If N\n    /// exceeds the number of characters remaining in the string, the string\n    /// suffix (starting with \\p Start) will be returned.\n    LLVM_NODISCARD\n    StringRef substr(size_t Start, size_t N = npos) const {\n      Start = std::min(Start, Length);\n      return StringRef(Data + Start, std::min(N, Length - Start));\n    }\n\n    /// Return a StringRef equal to 'this' but with only the first \\p N\n    /// elements remaining.  If \\p N is greater than the length of the\n    /// string, the entire string is returned.\n    LLVM_NODISCARD\n    StringRef take_front(size_t N = 1) const {\n      if (N >= size())\n        return *this;\n      return drop_back(size() - N);\n    }\n\n    /// Return a StringRef equal to 'this' but with only the last \\p N\n    /// elements remaining.  If \\p N is greater than the length of the\n    /// string, the entire string is returned.\n    LLVM_NODISCARD\n    StringRef take_back(size_t N = 1) const {\n      if (N >= size())\n        return *this;\n      return drop_front(size() - N);\n    }\n\n    /// Return the longest prefix of 'this' such that every character\n    /// in the prefix satisfies the given predicate.\n    LLVM_NODISCARD\n    StringRef take_while(function_ref<bool(char)> F) const {\n      return substr(0, find_if_not(F));\n    }\n\n    /// Return the longest prefix of 'this' such that no character in\n    /// the prefix satisfies the given predicate.\n    LLVM_NODISCARD\n    StringRef take_until(function_ref<bool(char)> F) const {\n      return substr(0, find_if(F));\n    }\n\n    /// Return a StringRef equal to 'this' but with the first \\p N elements\n    /// dropped.\n    LLVM_NODISCARD\n    StringRef drop_front(size_t N = 1) const {\n      assert(size() >= N && \"Dropping more elements than exist\");\n      return substr(N);\n    }\n\n    /// Return a StringRef equal to 'this' but with the last \\p N elements\n    /// dropped.\n    LLVM_NODISCARD\n    StringRef drop_back(size_t N = 1) const {\n      assert(size() >= N && \"Dropping more elements than exist\");\n      return substr(0, size()-N);\n    }\n\n    /// Return a StringRef equal to 'this', but with all characters satisfying\n    /// the given predicate dropped from the beginning of the string.\n    LLVM_NODISCARD\n    StringRef drop_while(function_ref<bool(char)> F) const {\n      return substr(find_if_not(F));\n    }\n\n    /// Return a StringRef equal to 'this', but with all characters not\n    /// satisfying the given predicate dropped from the beginning of the string.\n    LLVM_NODISCARD\n    StringRef drop_until(function_ref<bool(char)> F) const {\n      return substr(find_if(F));\n    }\n\n    /// Returns true if this StringRef has the given prefix and removes that\n    /// prefix.\n    bool consume_front(StringRef Prefix) {\n      if (!startswith(Prefix))\n        return false;\n\n      *this = drop_front(Prefix.size());\n      return true;\n    }\n\n    /// Returns true if this StringRef has the given suffix and removes that\n    /// suffix.\n    bool consume_back(StringRef Suffix) {\n      if (!endswith(Suffix))\n        return false;\n\n      *this = drop_back(Suffix.size());\n      return true;\n    }\n\n    /// Return a reference to the substring from [Start, End).\n    ///\n    /// \\param Start The index of the starting character in the substring; if\n    /// the index is npos or greater than the length of the string then the\n    /// empty substring will be returned.\n    ///\n    /// \\param End The index following the last character to include in the\n    /// substring. If this is npos or exceeds the number of characters\n    /// remaining in the string, the string suffix (starting with \\p Start)\n    /// will be returned. If this is less than \\p Start, an empty string will\n    /// be returned.\n    LLVM_NODISCARD\n    StringRef slice(size_t Start, size_t End) const {\n      Start = std::min(Start, Length);\n      End = std::min(std::max(Start, End), Length);\n      return StringRef(Data + Start, End - Start);\n    }\n\n    /// Split into two substrings around the first occurrence of a separator\n    /// character.\n    ///\n    /// If \\p Separator is in the string, then the result is a pair (LHS, RHS)\n    /// such that (*this == LHS + Separator + RHS) is true and RHS is\n    /// maximal. If \\p Separator is not in the string, then the result is a\n    /// pair (LHS, RHS) where (*this == LHS) and (RHS == \"\").\n    ///\n    /// \\param Separator The character to split on.\n    /// \\returns The split substrings.\n    LLVM_NODISCARD\n    std::pair<StringRef, StringRef> split(char Separator) const {\n      return split(StringRef(&Separator, 1));\n    }\n\n    /// Split into two substrings around the first occurrence of a separator\n    /// string.\n    ///\n    /// If \\p Separator is in the string, then the result is a pair (LHS, RHS)\n    /// such that (*this == LHS + Separator + RHS) is true and RHS is\n    /// maximal. If \\p Separator is not in the string, then the result is a\n    /// pair (LHS, RHS) where (*this == LHS) and (RHS == \"\").\n    ///\n    /// \\param Separator - The string to split on.\n    /// \\return - The split substrings.\n    LLVM_NODISCARD\n    std::pair<StringRef, StringRef> split(StringRef Separator) const {\n      size_t Idx = find(Separator);\n      if (Idx == npos)\n        return std::make_pair(*this, StringRef());\n      return std::make_pair(slice(0, Idx), slice(Idx + Separator.size(), npos));\n    }\n\n    /// Split into two substrings around the last occurrence of a separator\n    /// string.\n    ///\n    /// If \\p Separator is in the string, then the result is a pair (LHS, RHS)\n    /// such that (*this == LHS + Separator + RHS) is true and RHS is\n    /// minimal. If \\p Separator is not in the string, then the result is a\n    /// pair (LHS, RHS) where (*this == LHS) and (RHS == \"\").\n    ///\n    /// \\param Separator - The string to split on.\n    /// \\return - The split substrings.\n    LLVM_NODISCARD\n    std::pair<StringRef, StringRef> rsplit(StringRef Separator) const {\n      size_t Idx = rfind(Separator);\n      if (Idx == npos)\n        return std::make_pair(*this, StringRef());\n      return std::make_pair(slice(0, Idx), slice(Idx + Separator.size(), npos));\n    }\n\n    /// Split into substrings around the occurrences of a separator string.\n    ///\n    /// Each substring is stored in \\p A. If \\p MaxSplit is >= 0, at most\n    /// \\p MaxSplit splits are done and consequently <= \\p MaxSplit + 1\n    /// elements are added to A.\n    /// If \\p KeepEmpty is false, empty strings are not added to \\p A. They\n    /// still count when considering \\p MaxSplit\n    /// An useful invariant is that\n    /// Separator.join(A) == *this if MaxSplit == -1 and KeepEmpty == true\n    ///\n    /// \\param A - Where to put the substrings.\n    /// \\param Separator - The string to split on.\n    /// \\param MaxSplit - The maximum number of times the string is split.\n    /// \\param KeepEmpty - True if empty substring should be added.\n    void split(SmallVectorImpl<StringRef> &A,\n               StringRef Separator, int MaxSplit = -1,\n               bool KeepEmpty = true) const;\n\n    /// Split into substrings around the occurrences of a separator character.\n    ///\n    /// Each substring is stored in \\p A. If \\p MaxSplit is >= 0, at most\n    /// \\p MaxSplit splits are done and consequently <= \\p MaxSplit + 1\n    /// elements are added to A.\n    /// If \\p KeepEmpty is false, empty strings are not added to \\p A. They\n    /// still count when considering \\p MaxSplit\n    /// An useful invariant is that\n    /// Separator.join(A) == *this if MaxSplit == -1 and KeepEmpty == true\n    ///\n    /// \\param A - Where to put the substrings.\n    /// \\param Separator - The string to split on.\n    /// \\param MaxSplit - The maximum number of times the string is split.\n    /// \\param KeepEmpty - True if empty substring should be added.\n    void split(SmallVectorImpl<StringRef> &A, char Separator, int MaxSplit = -1,\n               bool KeepEmpty = true) const;\n\n    /// Split into two substrings around the last occurrence of a separator\n    /// character.\n    ///\n    /// If \\p Separator is in the string, then the result is a pair (LHS, RHS)\n    /// such that (*this == LHS + Separator + RHS) is true and RHS is\n    /// minimal. If \\p Separator is not in the string, then the result is a\n    /// pair (LHS, RHS) where (*this == LHS) and (RHS == \"\").\n    ///\n    /// \\param Separator - The character to split on.\n    /// \\return - The split substrings.\n    LLVM_NODISCARD\n    std::pair<StringRef, StringRef> rsplit(char Separator) const {\n      return rsplit(StringRef(&Separator, 1));\n    }\n\n    /// Return string with consecutive \\p Char characters starting from the\n    /// the left removed.\n    LLVM_NODISCARD\n    StringRef ltrim(char Char) const {\n      return drop_front(std::min(Length, find_first_not_of(Char)));\n    }\n\n    /// Return string with consecutive characters in \\p Chars starting from\n    /// the left removed.\n    LLVM_NODISCARD\n    StringRef ltrim(StringRef Chars = \" \\t\\n\\v\\f\\r\") const {\n      return drop_front(std::min(Length, find_first_not_of(Chars)));\n    }\n\n    /// Return string with consecutive \\p Char characters starting from the\n    /// right removed.\n    LLVM_NODISCARD\n    StringRef rtrim(char Char) const {\n      return drop_back(Length - std::min(Length, find_last_not_of(Char) + 1));\n    }\n\n    /// Return string with consecutive characters in \\p Chars starting from\n    /// the right removed.\n    LLVM_NODISCARD\n    StringRef rtrim(StringRef Chars = \" \\t\\n\\v\\f\\r\") const {\n      return drop_back(Length - std::min(Length, find_last_not_of(Chars) + 1));\n    }\n\n    /// Return string with consecutive \\p Char characters starting from the\n    /// left and right removed.\n    LLVM_NODISCARD\n    StringRef trim(char Char) const {\n      return ltrim(Char).rtrim(Char);\n    }\n\n    /// Return string with consecutive characters in \\p Chars starting from\n    /// the left and right removed.\n    LLVM_NODISCARD\n    StringRef trim(StringRef Chars = \" \\t\\n\\v\\f\\r\") const {\n      return ltrim(Chars).rtrim(Chars);\n    }\n\n    /// @}\n  };\n\n  /// A wrapper around a string literal that serves as a proxy for constructing\n  /// global tables of StringRefs with the length computed at compile time.\n  /// In order to avoid the invocation of a global constructor, StringLiteral\n  /// should *only* be used in a constexpr context, as such:\n  ///\n  /// constexpr StringLiteral S(\"test\");\n  ///\n  class StringLiteral : public StringRef {\n  private:\n    constexpr StringLiteral(const char *Str, size_t N) : StringRef(Str, N) {\n    }\n\n  public:\n    template <size_t N>\n    constexpr StringLiteral(const char (&Str)[N])\n#if defined(__clang__) && __has_attribute(enable_if)\n#pragma clang diagnostic push\n#pragma clang diagnostic ignored \"-Wgcc-compat\"\n        __attribute((enable_if(__builtin_strlen(Str) == N - 1,\n                               \"invalid string literal\")))\n#pragma clang diagnostic pop\n#endif\n        : StringRef(Str, N - 1) {\n    }\n\n    // Explicit construction for strings like \"foo\\0bar\".\n    template <size_t N>\n    static constexpr StringLiteral withInnerNUL(const char (&Str)[N]) {\n      return StringLiteral(Str, N - 1);\n    }\n  };\n\n  /// @name StringRef Comparison Operators\n  /// @{\n\n  inline bool operator==(StringRef LHS, StringRef RHS) {\n    return LHS.equals(RHS);\n  }\n\n  inline bool operator!=(StringRef LHS, StringRef RHS) { return !(LHS == RHS); }\n\n  inline bool operator<(StringRef LHS, StringRef RHS) {\n    return LHS.compare(RHS) == -1;\n  }\n\n  inline bool operator<=(StringRef LHS, StringRef RHS) {\n    return LHS.compare(RHS) != 1;\n  }\n\n  inline bool operator>(StringRef LHS, StringRef RHS) {\n    return LHS.compare(RHS) == 1;\n  }\n\n  inline bool operator>=(StringRef LHS, StringRef RHS) {\n    return LHS.compare(RHS) != -1;\n  }\n\n  inline std::string &operator+=(std::string &buffer, StringRef string) {\n    return buffer.append(string.data(), string.size());\n  }\n\n  /// @}\n\n  /// Compute a hash_code for a StringRef.\n  LLVM_NODISCARD\n  hash_code hash_value(StringRef S);\n\n} // end namespace llvm\n\n#endif // LLVM_ADT_STRINGREF_H\n"}, "14": {"id": 14, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/Twine.h", "content": "//===- Twine.h - Fast Temporary String Concatenation ------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_ADT_TWINE_H\n#define LLVM_ADT_TWINE_H\n\n#include \"llvm/ADT/SmallVector.h\"\n#include \"llvm/ADT/StringRef.h\"\n#include \"llvm/Support/ErrorHandling.h\"\n#include <cassert>\n#include <cstdint>\n#include <string>\n\nnamespace llvm {\n\n  class formatv_object_base;\n  class raw_ostream;\n\n  /// Twine - A lightweight data structure for efficiently representing the\n  /// concatenation of temporary values as strings.\n  ///\n  /// A Twine is a kind of rope, it represents a concatenated string using a\n  /// binary-tree, where the string is the preorder of the nodes. Since the\n  /// Twine can be efficiently rendered into a buffer when its result is used,\n  /// it avoids the cost of generating temporary values for intermediate string\n  /// results -- particularly in cases when the Twine result is never\n  /// required. By explicitly tracking the type of leaf nodes, we can also avoid\n  /// the creation of temporary strings for conversions operations (such as\n  /// appending an integer to a string).\n  ///\n  /// A Twine is not intended for use directly and should not be stored, its\n  /// implementation relies on the ability to store pointers to temporary stack\n  /// objects which may be deallocated at the end of a statement. Twines should\n  /// only be used accepted as const references in arguments, when an API wishes\n  /// to accept possibly-concatenated strings.\n  ///\n  /// Twines support a special 'null' value, which always concatenates to form\n  /// itself, and renders as an empty string. This can be returned from APIs to\n  /// effectively nullify any concatenations performed on the result.\n  ///\n  /// \\b Implementation\n  ///\n  /// Given the nature of a Twine, it is not possible for the Twine's\n  /// concatenation method to construct interior nodes; the result must be\n  /// represented inside the returned value. For this reason a Twine object\n  /// actually holds two values, the left- and right-hand sides of a\n  /// concatenation. We also have nullary Twine objects, which are effectively\n  /// sentinel values that represent empty strings.\n  ///\n  /// Thus, a Twine can effectively have zero, one, or two children. The \\see\n  /// isNullary(), \\see isUnary(), and \\see isBinary() predicates exist for\n  /// testing the number of children.\n  ///\n  /// We maintain a number of invariants on Twine objects (FIXME: Why):\n  ///  - Nullary twines are always represented with their Kind on the left-hand\n  ///    side, and the Empty kind on the right-hand side.\n  ///  - Unary twines are always represented with the value on the left-hand\n  ///    side, and the Empty kind on the right-hand side.\n  ///  - If a Twine has another Twine as a child, that child should always be\n  ///    binary (otherwise it could have been folded into the parent).\n  ///\n  /// These invariants are check by \\see isValid().\n  ///\n  /// \\b Efficiency Considerations\n  ///\n  /// The Twine is designed to yield efficient and small code for common\n  /// situations. For this reason, the concat() method is inlined so that\n  /// concatenations of leaf nodes can be optimized into stores directly into a\n  /// single stack allocated object.\n  ///\n  /// In practice, not all compilers can be trusted to optimize concat() fully,\n  /// so we provide two additional methods (and accompanying operator+\n  /// overloads) to guarantee that particularly important cases (cstring plus\n  /// StringRef) codegen as desired.\n  class Twine {\n    /// NodeKind - Represent the type of an argument.\n    enum NodeKind : unsigned char {\n      /// An empty string; the result of concatenating anything with it is also\n      /// empty.\n      NullKind,\n\n      /// The empty string.\n      EmptyKind,\n\n      /// A pointer to a Twine instance.\n      TwineKind,\n\n      /// A pointer to a C string instance.\n      CStringKind,\n\n      /// A pointer to an std::string instance.\n      StdStringKind,\n\n      /// A pointer to a StringRef instance.\n      StringRefKind,\n\n      /// A pointer to a SmallString instance.\n      SmallStringKind,\n\n      /// A pointer to a formatv_object_base instance.\n      FormatvObjectKind,\n\n      /// A char value, to render as a character.\n      CharKind,\n\n      /// An unsigned int value, to render as an unsigned decimal integer.\n      DecUIKind,\n\n      /// An int value, to render as a signed decimal integer.\n      DecIKind,\n\n      /// A pointer to an unsigned long value, to render as an unsigned decimal\n      /// integer.\n      DecULKind,\n\n      /// A pointer to a long value, to render as a signed decimal integer.\n      DecLKind,\n\n      /// A pointer to an unsigned long long value, to render as an unsigned\n      /// decimal integer.\n      DecULLKind,\n\n      /// A pointer to a long long value, to render as a signed decimal integer.\n      DecLLKind,\n\n      /// A pointer to a uint64_t value, to render as an unsigned hexadecimal\n      /// integer.\n      UHexKind\n    };\n\n    union Child\n    {\n      const Twine *twine;\n      const char *cString;\n      const std::string *stdString;\n      const StringRef *stringRef;\n      const SmallVectorImpl<char> *smallString;\n      const formatv_object_base *formatvObject;\n      char character;\n      unsigned int decUI;\n      int decI;\n      const unsigned long *decUL;\n      const long *decL;\n      const unsigned long long *decULL;\n      const long long *decLL;\n      const uint64_t *uHex;\n    };\n\n    /// LHS - The prefix in the concatenation, which may be uninitialized for\n    /// Null or Empty kinds.\n    Child LHS;\n\n    /// RHS - The suffix in the concatenation, which may be uninitialized for\n    /// Null or Empty kinds.\n    Child RHS;\n\n    /// LHSKind - The NodeKind of the left hand side, \\see getLHSKind().\n    NodeKind LHSKind = EmptyKind;\n\n    /// RHSKind - The NodeKind of the right hand side, \\see getRHSKind().\n    NodeKind RHSKind = EmptyKind;\n\n    /// Construct a nullary twine; the kind must be NullKind or EmptyKind.\n    explicit Twine(NodeKind Kind) : LHSKind(Kind) {\n      assert(isNullary() && \"Invalid kind!\");\n    }\n\n    /// Construct a binary twine.\n    explicit Twine(const Twine &LHS, const Twine &RHS)\n        : LHSKind(TwineKind), RHSKind(TwineKind) {\n      this->LHS.twine = &LHS;\n      this->RHS.twine = &RHS;\n      assert(isValid() && \"Invalid twine!\");\n    }\n\n    /// Construct a twine from explicit values.\n    explicit Twine(Child LHS, NodeKind LHSKind, Child RHS, NodeKind RHSKind)\n        : LHS(LHS), RHS(RHS), LHSKind(LHSKind), RHSKind(RHSKind) {\n      assert(isValid() && \"Invalid twine!\");\n    }\n\n    /// Check for the null twine.\n    bool isNull() const {\n      return getLHSKind() == NullKind;\n    }\n\n    /// Check for the empty twine.\n    bool isEmpty() const {\n      return getLHSKind() == EmptyKind;\n    }\n\n    /// Check if this is a nullary twine (null or empty).\n    bool isNullary() const {\n      return isNull() || isEmpty();\n    }\n\n    /// Check if this is a unary twine.\n    bool isUnary() const {\n      return getRHSKind() == EmptyKind && !isNullary();\n    }\n\n    /// Check if this is a binary twine.\n    bool isBinary() const {\n      return getLHSKind() != NullKind && getRHSKind() != EmptyKind;\n    }\n\n    /// Check if this is a valid twine (satisfying the invariants on\n    /// order and number of arguments).\n    bool isValid() const {\n      // Nullary twines always have Empty on the RHS.\n      if (isNullary() && getRHSKind() != EmptyKind)\n        return false;\n\n      // Null should never appear on the RHS.\n      if (getRHSKind() == NullKind)\n        return false;\n\n      // The RHS cannot be non-empty if the LHS is empty.\n      if (getRHSKind() != EmptyKind && getLHSKind() == EmptyKind)\n        return false;\n\n      // A twine child should always be binary.\n      if (getLHSKind() == TwineKind &&\n          !LHS.twine->isBinary())\n        return false;\n      if (getRHSKind() == TwineKind &&\n          !RHS.twine->isBinary())\n        return false;\n\n      return true;\n    }\n\n    /// Get the NodeKind of the left-hand side.\n    NodeKind getLHSKind() const { return LHSKind; }\n\n    /// Get the NodeKind of the right-hand side.\n    NodeKind getRHSKind() const { return RHSKind; }\n\n    /// Print one child from a twine.\n    void printOneChild(raw_ostream &OS, Child Ptr, NodeKind Kind) const;\n\n    /// Print the representation of one child from a twine.\n    void printOneChildRepr(raw_ostream &OS, Child Ptr,\n                           NodeKind Kind) const;\n\n  public:\n    /// @name Constructors\n    /// @{\n\n    /// Construct from an empty string.\n    /*implicit*/ Twine() {\n      assert(isValid() && \"Invalid twine!\");\n    }\n\n    Twine(const Twine &) = default;\n\n    /// Construct from a C string.\n    ///\n    /// We take care here to optimize \"\" into the empty twine -- this will be\n    /// optimized out for string constants. This allows Twine arguments have\n    /// default \"\" values, without introducing unnecessary string constants.\n    /*implicit*/ Twine(const char *Str) {\n      if (Str[0] != '\\0') {\n        LHS.cString = Str;\n        LHSKind = CStringKind;\n      } else\n        LHSKind = EmptyKind;\n\n      assert(isValid() && \"Invalid twine!\");\n    }\n    /// Delete the implicit conversion from nullptr as Twine(const char *)\n    /// cannot take nullptr.\n    /*implicit*/ Twine(std::nullptr_t) = delete;\n\n    /// Construct from an std::string.\n    /*implicit*/ Twine(const std::string &Str) : LHSKind(StdStringKind) {\n      LHS.stdString = &Str;\n      assert(isValid() && \"Invalid twine!\");\n    }\n\n    /// Construct from a StringRef.\n    /*implicit*/ Twine(const StringRef &Str) : LHSKind(StringRefKind) {\n      LHS.stringRef = &Str;\n      assert(isValid() && \"Invalid twine!\");\n    }\n\n    /// Construct from a SmallString.\n    /*implicit*/ Twine(const SmallVectorImpl<char> &Str)\n        : LHSKind(SmallStringKind) {\n      LHS.smallString = &Str;\n      assert(isValid() && \"Invalid twine!\");\n    }\n\n    /// Construct from a formatv_object_base.\n    /*implicit*/ Twine(const formatv_object_base &Fmt)\n        : LHSKind(FormatvObjectKind) {\n      LHS.formatvObject = &Fmt;\n      assert(isValid() && \"Invalid twine!\");\n    }\n\n    /// Construct from a char.\n    explicit Twine(char Val) : LHSKind(CharKind) {\n      LHS.character = Val;\n    }\n\n    /// Construct from a signed char.\n    explicit Twine(signed char Val) : LHSKind(CharKind) {\n      LHS.character = static_cast<char>(Val);\n    }\n\n    /// Construct from an unsigned char.\n    explicit Twine(unsigned char Val) : LHSKind(CharKind) {\n      LHS.character = static_cast<char>(Val);\n    }\n\n    /// Construct a twine to print \\p Val as an unsigned decimal integer.\n    explicit Twine(unsigned Val) : LHSKind(DecUIKind) {\n      LHS.decUI = Val;\n    }\n\n    /// Construct a twine to print \\p Val as a signed decimal integer.\n    explicit Twine(int Val) : LHSKind(DecIKind) {\n      LHS.decI = Val;\n    }\n\n    /// Construct a twine to print \\p Val as an unsigned decimal integer.\n    explicit Twine(const unsigned long &Val) : LHSKind(DecULKind) {\n      LHS.decUL = &Val;\n    }\n\n    /// Construct a twine to print \\p Val as a signed decimal integer.\n    explicit Twine(const long &Val) : LHSKind(DecLKind) {\n      LHS.decL = &Val;\n    }\n\n    /// Construct a twine to print \\p Val as an unsigned decimal integer.\n    explicit Twine(const unsigned long long &Val) : LHSKind(DecULLKind) {\n      LHS.decULL = &Val;\n    }\n\n    /// Construct a twine to print \\p Val as a signed decimal integer.\n    explicit Twine(const long long &Val) : LHSKind(DecLLKind) {\n      LHS.decLL = &Val;\n    }\n\n    // FIXME: Unfortunately, to make sure this is as efficient as possible we\n    // need extra binary constructors from particular types. We can't rely on\n    // the compiler to be smart enough to fold operator+()/concat() down to the\n    // right thing. Yet.\n\n    /// Construct as the concatenation of a C string and a StringRef.\n    /*implicit*/ Twine(const char *LHS, const StringRef &RHS)\n        : LHSKind(CStringKind), RHSKind(StringRefKind) {\n      this->LHS.cString = LHS;\n      this->RHS.stringRef = &RHS;\n      assert(isValid() && \"Invalid twine!\");\n    }\n\n    /// Construct as the concatenation of a StringRef and a C string.\n    /*implicit*/ Twine(const StringRef &LHS, const char *RHS)\n        : LHSKind(StringRefKind), RHSKind(CStringKind) {\n      this->LHS.stringRef = &LHS;\n      this->RHS.cString = RHS;\n      assert(isValid() && \"Invalid twine!\");\n    }\n\n    /// Since the intended use of twines is as temporary objects, assignments\n    /// when concatenating might cause undefined behavior or stack corruptions\n    Twine &operator=(const Twine &) = delete;\n\n    /// Create a 'null' string, which is an empty string that always\n    /// concatenates to form another empty string.\n    static Twine createNull() {\n      return Twine(NullKind);\n    }\n\n    /// @}\n    /// @name Numeric Conversions\n    /// @{\n\n    // Construct a twine to print \\p Val as an unsigned hexadecimal integer.\n    static Twine utohexstr(const uint64_t &Val) {\n      Child LHS, RHS;\n      LHS.uHex = &Val;\n      RHS.twine = nullptr;\n      return Twine(LHS, UHexKind, RHS, EmptyKind);\n    }\n\n    /// @}\n    /// @name Predicate Operations\n    /// @{\n\n    /// Check if this twine is trivially empty; a false return value does not\n    /// necessarily mean the twine is empty.\n    bool isTriviallyEmpty() const {\n      return isNullary();\n    }\n\n    /// Return true if this twine can be dynamically accessed as a single\n    /// StringRef value with getSingleStringRef().\n    bool isSingleStringRef() const {\n      if (getRHSKind() != EmptyKind) return false;\n\n      switch (getLHSKind()) {\n      case EmptyKind:\n      case CStringKind:\n      case StdStringKind:\n      case StringRefKind:\n      case SmallStringKind:\n        return true;\n      default:\n        return false;\n      }\n    }\n\n    /// @}\n    /// @name String Operations\n    /// @{\n\n    Twine concat(const Twine &Suffix) const;\n\n    /// @}\n    /// @name Output & Conversion.\n    /// @{\n\n    /// Return the twine contents as a std::string.\n    std::string str() const;\n\n    /// Append the concatenated string into the given SmallString or SmallVector.\n    void toVector(SmallVectorImpl<char> &Out) const;\n\n    /// This returns the twine as a single StringRef.  This method is only valid\n    /// if isSingleStringRef() is true.\n    StringRef getSingleStringRef() const {\n      assert(isSingleStringRef() &&\"This cannot be had as a single stringref!\");\n      switch (getLHSKind()) {\n      default: llvm_unreachable(\"Out of sync with isSingleStringRef\");\n      case EmptyKind:      return StringRef();\n      case CStringKind:    return StringRef(LHS.cString);\n      case StdStringKind:  return StringRef(*LHS.stdString);\n      case StringRefKind:  return *LHS.stringRef;\n      case SmallStringKind:\n        return StringRef(LHS.smallString->data(), LHS.smallString->size());\n      }\n    }\n\n    /// This returns the twine as a single StringRef if it can be\n    /// represented as such. Otherwise the twine is written into the given\n    /// SmallVector and a StringRef to the SmallVector's data is returned.\n    StringRef toStringRef(SmallVectorImpl<char> &Out) const {\n      if (isSingleStringRef())\n        return getSingleStringRef();\n      toVector(Out);\n      return StringRef(Out.data(), Out.size());\n    }\n\n    /// This returns the twine as a single null terminated StringRef if it\n    /// can be represented as such. Otherwise the twine is written into the\n    /// given SmallVector and a StringRef to the SmallVector's data is returned.\n    ///\n    /// The returned StringRef's size does not include the null terminator.\n    StringRef toNullTerminatedStringRef(SmallVectorImpl<char> &Out) const;\n\n    /// Write the concatenated string represented by this twine to the\n    /// stream \\p OS.\n    void print(raw_ostream &OS) const;\n\n    /// Dump the concatenated string represented by this twine to stderr.\n    void dump() const;\n\n    /// Write the representation of this twine to the stream \\p OS.\n    void printRepr(raw_ostream &OS) const;\n\n    /// Dump the representation of this twine to stderr.\n    void dumpRepr() const;\n\n    /// @}\n  };\n\n  /// @name Twine Inline Implementations\n  /// @{\n\n  inline Twine Twine::concat(const Twine &Suffix) const {\n    // Concatenation with null is null.\n    if (isNull() || Suffix.isNull())\n      return Twine(NullKind);\n\n    // Concatenation with empty yields the other side.\n    if (isEmpty())\n      return Suffix;\n    if (Suffix.isEmpty())\n      return *this;\n\n    // Otherwise we need to create a new node, taking care to fold in unary\n    // twines.\n    Child NewLHS, NewRHS;\n    NewLHS.twine = this;\n    NewRHS.twine = &Suffix;\n    NodeKind NewLHSKind = TwineKind, NewRHSKind = TwineKind;\n    if (isUnary()) {\n      NewLHS = LHS;\n      NewLHSKind = getLHSKind();\n    }\n    if (Suffix.isUnary()) {\n      NewRHS = Suffix.LHS;\n      NewRHSKind = Suffix.getLHSKind();\n    }\n\n    return Twine(NewLHS, NewLHSKind, NewRHS, NewRHSKind);\n  }\n\n  inline Twine operator+(const Twine &LHS, const Twine &RHS) {\n    return LHS.concat(RHS);\n  }\n\n  /// Additional overload to guarantee simplified codegen; this is equivalent to\n  /// concat().\n\n  inline Twine operator+(const char *LHS, const StringRef &RHS) {\n    return Twine(LHS, RHS);\n  }\n\n  /// Additional overload to guarantee simplified codegen; this is equivalent to\n  /// concat().\n\n  inline Twine operator+(const StringRef &LHS, const char *RHS) {\n    return Twine(LHS, RHS);\n  }\n\n  inline raw_ostream &operator<<(raw_ostream &OS, const Twine &RHS) {\n    RHS.print(OS);\n    return OS;\n  }\n\n  /// @}\n\n} // end namespace llvm\n\n#endif // LLVM_ADT_TWINE_H\n"}, "15": {"id": 15, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/iterator_range.h", "content": "//===- iterator_range.h - A range adaptor for iterators ---------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n/// \\file\n/// This provides a very simple, boring adaptor for a begin and end iterator\n/// into a range type. This should be used to build range views that work well\n/// with range based for loops and range based constructors.\n///\n/// Note that code here follows more standards-based coding conventions as it\n/// is mirroring proposed interfaces for standardization.\n///\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_ADT_ITERATOR_RANGE_H\n#define LLVM_ADT_ITERATOR_RANGE_H\n\n#include <utility>\n\nnamespace llvm {\n\n/// A range adaptor for a pair of iterators.\n///\n/// This just wraps two iterators into a range-compatible interface. Nothing\n/// fancy at all.\ntemplate <typename IteratorT>\nclass iterator_range {\n  IteratorT begin_iterator, end_iterator;\n\npublic:\n  //TODO: Add SFINAE to test that the Container's iterators match the range's\n  //      iterators.\n  template <typename Container>\n  iterator_range(Container &&c)\n  //TODO: Consider ADL/non-member begin/end calls.\n      : begin_iterator(c.begin()), end_iterator(c.end()) {}\n  iterator_range(IteratorT begin_iterator, IteratorT end_iterator)\n      : begin_iterator(std::move(begin_iterator)),\n        end_iterator(std::move(end_iterator)) {}\n\n  IteratorT begin() const { return begin_iterator; }\n  IteratorT end() const { return end_iterator; }\n  bool empty() const { return begin_iterator == end_iterator; }\n};\n\n/// Convenience function for iterating over sub-ranges.\n///\n/// This provides a bit of syntactic sugar to make using sub-ranges\n/// in for loops a bit easier. Analogous to std::make_pair().\ntemplate <class T> iterator_range<T> make_range(T x, T y) {\n  return iterator_range<T>(std::move(x), std::move(y));\n}\n\ntemplate <typename T> iterator_range<T> make_range(std::pair<T, T> p) {\n  return iterator_range<T>(std::move(p.first), std::move(p.second));\n}\n\n}\n\n#endif\n"}, "16": {"id": 16, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/FileCheck/FileCheck.h", "content": "//==-- llvm/FileCheck/FileCheck.h --------------------------------*- C++ -*-==//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n/// \\file This file has some utilities to use FileCheck as an API\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_FILECHECK_FILECHECK_H\n#define LLVM_FILECHECK_FILECHECK_H\n\n#include \"llvm/ADT/StringRef.h\"\n#include \"llvm/Support/MemoryBuffer.h\"\n#include \"llvm/Support/Regex.h\"\n#include \"llvm/Support/SourceMgr.h\"\n#include <bitset>\n#include <string>\n#include <vector>\n\nnamespace llvm {\n\n/// Contains info about various FileCheck options.\nstruct FileCheckRequest {\n  std::vector<StringRef> CheckPrefixes;\n  std::vector<StringRef> CommentPrefixes;\n  bool NoCanonicalizeWhiteSpace = false;\n  std::vector<StringRef> ImplicitCheckNot;\n  std::vector<StringRef> GlobalDefines;\n  bool AllowEmptyInput = false;\n  bool AllowUnusedPrefixes = false;\n  bool MatchFullLines = false;\n  bool IgnoreCase = false;\n  bool IsDefaultCheckPrefix = false;\n  bool EnableVarScope = false;\n  bool AllowDeprecatedDagOverlap = false;\n  bool Verbose = false;\n  bool VerboseVerbose = false;\n};\n\nnamespace Check {\n\nenum FileCheckKind {\n  CheckNone = 0,\n  CheckPlain,\n  CheckNext,\n  CheckSame,\n  CheckNot,\n  CheckDAG,\n  CheckLabel,\n  CheckEmpty,\n  CheckComment,\n\n  /// Indicates the pattern only matches the end of file. This is used for\n  /// trailing CHECK-NOTs.\n  CheckEOF,\n\n  /// Marks when parsing found a -NOT check combined with another CHECK suffix.\n  CheckBadNot,\n\n  /// Marks when parsing found a -COUNT directive with invalid count value.\n  CheckBadCount\n};\n\nenum FileCheckKindModifier {\n  /// Modifies directive to perform literal match.\n  ModifierLiteral = 0,\n\n  // The number of modifier.\n  Size\n};\n\nclass FileCheckType {\n  FileCheckKind Kind;\n  int Count; ///< optional Count for some checks\n  /// Modifers for the check directive.\n  std::bitset<FileCheckKindModifier::Size> Modifiers;\n\npublic:\n  FileCheckType(FileCheckKind Kind = CheckNone)\n      : Kind(Kind), Count(1), Modifiers() {}\n  FileCheckType(const FileCheckType &) = default;\n  FileCheckType &operator=(const FileCheckType &) = default;\n\n  operator FileCheckKind() const { return Kind; }\n\n  int getCount() const { return Count; }\n  FileCheckType &setCount(int C);\n\n  bool isLiteralMatch() const {\n    return Modifiers[FileCheckKindModifier::ModifierLiteral];\n  }\n  FileCheckType &setLiteralMatch(bool Literal = true) {\n    Modifiers.set(FileCheckKindModifier::ModifierLiteral, Literal);\n    return *this;\n  }\n\n  // \\returns a description of \\p Prefix.\n  std::string getDescription(StringRef Prefix) const;\n\n  // \\returns a description of \\p Modifiers.\n  std::string getModifiersDescription() const;\n};\n} // namespace Check\n\n/// Summary of a FileCheck diagnostic.\nstruct FileCheckDiag {\n  /// What is the FileCheck directive for this diagnostic?\n  Check::FileCheckType CheckTy;\n  /// Where is the FileCheck directive for this diagnostic?\n  SMLoc CheckLoc;\n  /// What type of match result does this diagnostic describe?\n  ///\n  /// A directive's supplied pattern is said to be either expected or excluded\n  /// depending on whether the pattern must have or must not have a match in\n  /// order for the directive to succeed.  For example, a CHECK directive's\n  /// pattern is expected, and a CHECK-NOT directive's pattern is excluded.\n  /// All match result types whose names end with \"Excluded\" are for excluded\n  /// patterns, and all others are for expected patterns.\n  ///\n  /// There might be more than one match result for a single pattern.  For\n  /// example, there might be several discarded matches\n  /// (MatchFoundButDiscarded) before either a good match\n  /// (MatchFoundAndExpected) or a failure to match (MatchNoneButExpected),\n  /// and there might be a fuzzy match (MatchFuzzy) after the latter.\n  enum MatchType {\n    /// Indicates a good match for an expected pattern.\n    MatchFoundAndExpected,\n    /// Indicates a match for an excluded pattern.\n    MatchFoundButExcluded,\n    /// Indicates a match for an expected pattern, but the match is on the\n    /// wrong line.\n    MatchFoundButWrongLine,\n    /// Indicates a discarded match for an expected pattern.\n    MatchFoundButDiscarded,\n    /// Indicates no match for an excluded pattern.\n    MatchNoneAndExcluded,\n    /// Indicates no match for an expected pattern, but this might follow good\n    /// matches when multiple matches are expected for the pattern, or it might\n    /// follow discarded matches for the pattern.\n    MatchNoneButExpected,\n    /// Indicates a fuzzy match that serves as a suggestion for the next\n    /// intended match for an expected pattern with too few or no good matches.\n    MatchFuzzy,\n  } MatchTy;\n  /// The search range if MatchTy is MatchNoneAndExcluded or\n  /// MatchNoneButExpected, or the match range otherwise.\n  unsigned InputStartLine;\n  unsigned InputStartCol;\n  unsigned InputEndLine;\n  unsigned InputEndCol;\n  /// A note to replace the one normally indicated by MatchTy, or the empty\n  /// string if none.\n  std::string Note;\n  FileCheckDiag(const SourceMgr &SM, const Check::FileCheckType &CheckTy,\n                SMLoc CheckLoc, MatchType MatchTy, SMRange InputRange,\n                StringRef Note = \"\");\n};\n\nclass FileCheckPatternContext;\nstruct FileCheckString;\n\n/// FileCheck class takes the request and exposes various methods that\n/// use information from the request.\nclass FileCheck {\n  FileCheckRequest Req;\n  std::unique_ptr<FileCheckPatternContext> PatternContext;\n  // C++17 TODO: make this a plain std::vector.\n  std::unique_ptr<std::vector<FileCheckString>> CheckStrings;\n\npublic:\n  explicit FileCheck(FileCheckRequest Req);\n  ~FileCheck();\n\n  // Combines the check prefixes into a single regex so that we can efficiently\n  // scan for any of the set.\n  //\n  // The semantics are that the longest-match wins which matches our regex\n  // library.\n  Regex buildCheckPrefixRegex();\n\n  /// Reads the check file from \\p Buffer and records the expected strings it\n  /// contains. Errors are reported against \\p SM.\n  ///\n  /// Only expected strings whose prefix is one of those listed in \\p PrefixRE\n  /// are recorded. \\returns true in case of an error, false otherwise.\n  ///\n  /// If \\p ImpPatBufferIDRange, then the range (inclusive start, exclusive end)\n  /// of IDs for source buffers added to \\p SM for implicit patterns are\n  /// recorded in it.  The range is empty if there are none.\n  bool\n  readCheckFile(SourceMgr &SM, StringRef Buffer, Regex &PrefixRE,\n                std::pair<unsigned, unsigned> *ImpPatBufferIDRange = nullptr);\n\n  bool ValidateCheckPrefixes();\n\n  /// Canonicalizes whitespaces in the file. Line endings are replaced with\n  /// UNIX-style '\\n'.\n  StringRef CanonicalizeFile(MemoryBuffer &MB,\n                             SmallVectorImpl<char> &OutputBuffer);\n\n  /// Checks the input to FileCheck provided in the \\p Buffer against the\n  /// expected strings read from the check file and record diagnostics emitted\n  /// in \\p Diags. Errors are recorded against \\p SM.\n  ///\n  /// \\returns false if the input fails to satisfy the checks.\n  bool checkInput(SourceMgr &SM, StringRef Buffer,\n                  std::vector<FileCheckDiag> *Diags = nullptr);\n};\n\n} // namespace llvm\n\n#endif\n"}, "17": {"id": 17, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/AlignOf.h", "content": "//===--- AlignOf.h - Portable calculation of type alignment -----*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// This file defines the AlignedCharArrayUnion class.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_SUPPORT_ALIGNOF_H\n#define LLVM_SUPPORT_ALIGNOF_H\n\n#include <type_traits>\n\nnamespace llvm {\n\n/// A suitably aligned and sized character array member which can hold elements\n/// of any type.\n///\n/// This template is equivalent to std::aligned_union_t<1, ...>, but we cannot\n/// use it due to a bug in the MSVC x86 compiler:\n/// https://github.com/microsoft/STL/issues/1533\n/// Using `alignas` here works around the bug.\ntemplate <typename T, typename... Ts> struct AlignedCharArrayUnion {\n  using AlignedUnion = std::aligned_union_t<1, T, Ts...>;\n  alignas(alignof(AlignedUnion)) char buffer[sizeof(AlignedUnion)];\n};\n\n} // end namespace llvm\n\n#endif // LLVM_SUPPORT_ALIGNOF_H\n"}, "18": {"id": 18, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/Alignment.h", "content": "//===-- llvm/Support/Alignment.h - Useful alignment functions ---*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// This file contains types to represent alignments.\n// They are instrumented to guarantee some invariants are preserved and prevent\n// invalid manipulations.\n//\n// - Align represents an alignment in bytes, it is always set and always a valid\n// power of two, its minimum value is 1 which means no alignment requirements.\n//\n// - MaybeAlign is an optional type, it may be undefined or set. When it's set\n// you can get the underlying Align type by using the getValue() method.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_SUPPORT_ALIGNMENT_H_\n#define LLVM_SUPPORT_ALIGNMENT_H_\n\n#include \"llvm/ADT/Optional.h\"\n#include \"llvm/Support/MathExtras.h\"\n#include <cassert>\n#ifndef NDEBUG\n#include <string>\n#endif // NDEBUG\n\nnamespace llvm {\n\n#define ALIGN_CHECK_ISPOSITIVE(decl)                                           \\\n  assert(decl > 0 && (#decl \" should be defined\"))\n\n/// This struct is a compact representation of a valid (non-zero power of two)\n/// alignment.\n/// It is suitable for use as static global constants.\nstruct Align {\nprivate:\n  uint8_t ShiftValue = 0; /// The log2 of the required alignment.\n                          /// ShiftValue is less than 64 by construction.\n\n  friend struct MaybeAlign;\n  friend unsigned Log2(Align);\n  friend bool operator==(Align Lhs, Align Rhs);\n  friend bool operator!=(Align Lhs, Align Rhs);\n  friend bool operator<=(Align Lhs, Align Rhs);\n  friend bool operator>=(Align Lhs, Align Rhs);\n  friend bool operator<(Align Lhs, Align Rhs);\n  friend bool operator>(Align Lhs, Align Rhs);\n  friend unsigned encode(struct MaybeAlign A);\n  friend struct MaybeAlign decodeMaybeAlign(unsigned Value);\n\n  /// A trivial type to allow construction of constexpr Align.\n  /// This is currently needed to workaround a bug in GCC 5.3 which prevents\n  /// definition of constexpr assign operators.\n  /// https://stackoverflow.com/questions/46756288/explicitly-defaulted-function-cannot-be-declared-as-constexpr-because-the-implic\n  /// FIXME: Remove this, make all assign operators constexpr and introduce user\n  /// defined literals when we don't have to support GCC 5.3 anymore.\n  /// https://llvm.org/docs/GettingStarted.html#getting-a-modern-host-c-toolchain\n  struct LogValue {\n    uint8_t Log;\n  };\n\npublic:\n  /// Default is byte-aligned.\n  constexpr Align() = default;\n  /// Do not perform checks in case of copy/move construct/assign, because the\n  /// checks have been performed when building `Other`.\n  constexpr Align(const Align &Other) = default;\n  constexpr Align(Align &&Other) = default;\n  Align &operator=(const Align &Other) = default;\n  Align &operator=(Align &&Other) = default;\n\n  explicit Align(uint64_t Value) {\n    assert(Value > 0 && \"Value must not be 0\");\n    assert(llvm::isPowerOf2_64(Value) && \"Alignment is not a power of 2\");\n    ShiftValue = Log2_64(Value);\n    assert(ShiftValue < 64 && \"Broken invariant\");\n  }\n\n  /// This is a hole in the type system and should not be abused.\n  /// Needed to interact with C for instance.\n  uint64_t value() const { return uint64_t(1) << ShiftValue; }\n\n  /// Returns a default constructed Align which corresponds to no alignment.\n  /// It was decided to deprecate Align::None because it's too close to\n  /// llvm::None which can be used to initialize `MaybeAlign`.\n  /// MaybeAlign = llvm::None means unspecified alignment,\n  /// Align = Align::None() means alignment of one byte.\n  LLVM_ATTRIBUTE_DEPRECATED(constexpr static const Align None(),\n                            \"Use Align() or Align(1) instead\") {\n    return Align();\n  }\n\n  /// Allow constructions of constexpr Align.\n  template <size_t kValue> constexpr static LogValue Constant() {\n    return LogValue{static_cast<uint8_t>(CTLog2<kValue>())};\n  }\n\n  /// Allow constructions of constexpr Align from types.\n  /// Compile time equivalent to Align(alignof(T)).\n  template <typename T> constexpr static LogValue Of() {\n    return Constant<std::alignment_of<T>::value>();\n  }\n\n  /// Constexpr constructor from LogValue type.\n  constexpr Align(LogValue CA) : ShiftValue(CA.Log) {}\n};\n\n/// Treats the value 0 as a 1, so Align is always at least 1.\ninline Align assumeAligned(uint64_t Value) {\n  return Value ? Align(Value) : Align();\n}\n\n/// This struct is a compact representation of a valid (power of two) or\n/// undefined (0) alignment.\nstruct MaybeAlign : public llvm::Optional<Align> {\nprivate:\n  using UP = llvm::Optional<Align>;\n\npublic:\n  /// Default is undefined.\n  MaybeAlign() = default;\n  /// Do not perform checks in case of copy/move construct/assign, because the\n  /// checks have been performed when building `Other`.\n  MaybeAlign(const MaybeAlign &Other) = default;\n  MaybeAlign &operator=(const MaybeAlign &Other) = default;\n  MaybeAlign(MaybeAlign &&Other) = default;\n  MaybeAlign &operator=(MaybeAlign &&Other) = default;\n\n  /// Use llvm::Optional<Align> constructor.\n  using UP::UP;\n\n  explicit MaybeAlign(uint64_t Value) {\n    assert((Value == 0 || llvm::isPowerOf2_64(Value)) &&\n           \"Alignment is neither 0 nor a power of 2\");\n    if (Value)\n      emplace(Value);\n  }\n\n  /// For convenience, returns a valid alignment or 1 if undefined.\n  Align valueOrOne() const { return hasValue() ? getValue() : Align(); }\n};\n\n/// Checks that SizeInBytes is a multiple of the alignment.\ninline bool isAligned(Align Lhs, uint64_t SizeInBytes) {\n  return SizeInBytes % Lhs.value() == 0;\n}\n\n/// Checks that Addr is a multiple of the alignment.\ninline bool isAddrAligned(Align Lhs, const void *Addr) {\n  return isAligned(Lhs, reinterpret_cast<uintptr_t>(Addr));\n}\n\n/// Returns a multiple of A needed to store `Size` bytes.\ninline uint64_t alignTo(uint64_t Size, Align A) {\n  const uint64_t Value = A.value();\n  // The following line is equivalent to `(Size + Value - 1) / Value * Value`.\n\n  // The division followed by a multiplication can be thought of as a right\n  // shift followed by a left shift which zeros out the extra bits produced in\n  // the bump; `~(Value - 1)` is a mask where all those bits being zeroed out\n  // are just zero.\n\n  // Most compilers can generate this code but the pattern may be missed when\n  // multiple functions gets inlined.\n  return (Size + Value - 1) & ~(Value - 1U);\n}\n\n/// If non-zero \\p Skew is specified, the return value will be a minimal integer\n/// that is greater than or equal to \\p Size and equal to \\p A * N + \\p Skew for\n/// some integer N. If \\p Skew is larger than \\p A, its value is adjusted to '\\p\n/// Skew mod \\p A'.\n///\n/// Examples:\n/// \\code\n///   alignTo(5, Align(8), 7) = 7\n///   alignTo(17, Align(8), 1) = 17\n///   alignTo(~0LL, Align(8), 3) = 3\n/// \\endcode\ninline uint64_t alignTo(uint64_t Size, Align A, uint64_t Skew) {\n  const uint64_t Value = A.value();\n  Skew %= Value;\n  return ((Size + Value - 1 - Skew) & ~(Value - 1U)) + Skew;\n}\n\n/// Returns a multiple of A needed to store `Size` bytes.\n/// Returns `Size` if current alignment is undefined.\ninline uint64_t alignTo(uint64_t Size, MaybeAlign A) {\n  return A ? alignTo(Size, A.getValue()) : Size;\n}\n\n/// Aligns `Addr` to `Alignment` bytes, rounding up.\ninline uintptr_t alignAddr(const void *Addr, Align Alignment) {\n  uintptr_t ArithAddr = reinterpret_cast<uintptr_t>(Addr);\n  assert(static_cast<uintptr_t>(ArithAddr + Alignment.value() - 1) >=\n             ArithAddr &&\n         \"Overflow\");\n  return alignTo(ArithAddr, Alignment);\n}\n\n/// Returns the offset to the next integer (mod 2**64) that is greater than\n/// or equal to \\p Value and is a multiple of \\p Align.\ninline uint64_t offsetToAlignment(uint64_t Value, Align Alignment) {\n  return alignTo(Value, Alignment) - Value;\n}\n\n/// Returns the necessary adjustment for aligning `Addr` to `Alignment`\n/// bytes, rounding up.\ninline uint64_t offsetToAlignedAddr(const void *Addr, Align Alignment) {\n  return offsetToAlignment(reinterpret_cast<uintptr_t>(Addr), Alignment);\n}\n\n/// Returns the log2 of the alignment.\ninline unsigned Log2(Align A) { return A.ShiftValue; }\n\n/// Returns the alignment that satisfies both alignments.\n/// Same semantic as MinAlign.\ninline Align commonAlignment(Align A, Align B) { return std::min(A, B); }\n\n/// Returns the alignment that satisfies both alignments.\n/// Same semantic as MinAlign.\ninline Align commonAlignment(Align A, uint64_t Offset) {\n  return Align(MinAlign(A.value(), Offset));\n}\n\n/// Returns the alignment that satisfies both alignments.\n/// Same semantic as MinAlign.\ninline MaybeAlign commonAlignment(MaybeAlign A, MaybeAlign B) {\n  return A && B ? commonAlignment(*A, *B) : A ? A : B;\n}\n\n/// Returns the alignment that satisfies both alignments.\n/// Same semantic as MinAlign.\ninline MaybeAlign commonAlignment(MaybeAlign A, uint64_t Offset) {\n  return MaybeAlign(MinAlign((*A).value(), Offset));\n}\n\n/// Returns a representation of the alignment that encodes undefined as 0.\ninline unsigned encode(MaybeAlign A) { return A ? A->ShiftValue + 1 : 0; }\n\n/// Dual operation of the encode function above.\ninline MaybeAlign decodeMaybeAlign(unsigned Value) {\n  if (Value == 0)\n    return MaybeAlign();\n  Align Out;\n  Out.ShiftValue = Value - 1;\n  return Out;\n}\n\n/// Returns a representation of the alignment, the encoded value is positive by\n/// definition.\ninline unsigned encode(Align A) { return encode(MaybeAlign(A)); }\n\n/// Comparisons between Align and scalars. Rhs must be positive.\ninline bool operator==(Align Lhs, uint64_t Rhs) {\n  ALIGN_CHECK_ISPOSITIVE(Rhs);\n  return Lhs.value() == Rhs;\n}\ninline bool operator!=(Align Lhs, uint64_t Rhs) {\n  ALIGN_CHECK_ISPOSITIVE(Rhs);\n  return Lhs.value() != Rhs;\n}\ninline bool operator<=(Align Lhs, uint64_t Rhs) {\n  ALIGN_CHECK_ISPOSITIVE(Rhs);\n  return Lhs.value() <= Rhs;\n}\ninline bool operator>=(Align Lhs, uint64_t Rhs) {\n  ALIGN_CHECK_ISPOSITIVE(Rhs);\n  return Lhs.value() >= Rhs;\n}\ninline bool operator<(Align Lhs, uint64_t Rhs) {\n  ALIGN_CHECK_ISPOSITIVE(Rhs);\n  return Lhs.value() < Rhs;\n}\ninline bool operator>(Align Lhs, uint64_t Rhs) {\n  ALIGN_CHECK_ISPOSITIVE(Rhs);\n  return Lhs.value() > Rhs;\n}\n\n/// Comparisons between MaybeAlign and scalars.\ninline bool operator==(MaybeAlign Lhs, uint64_t Rhs) {\n  return Lhs ? (*Lhs).value() == Rhs : Rhs == 0;\n}\ninline bool operator!=(MaybeAlign Lhs, uint64_t Rhs) {\n  return Lhs ? (*Lhs).value() != Rhs : Rhs != 0;\n}\n\n/// Comparisons operators between Align.\ninline bool operator==(Align Lhs, Align Rhs) {\n  return Lhs.ShiftValue == Rhs.ShiftValue;\n}\ninline bool operator!=(Align Lhs, Align Rhs) {\n  return Lhs.ShiftValue != Rhs.ShiftValue;\n}\ninline bool operator<=(Align Lhs, Align Rhs) {\n  return Lhs.ShiftValue <= Rhs.ShiftValue;\n}\ninline bool operator>=(Align Lhs, Align Rhs) {\n  return Lhs.ShiftValue >= Rhs.ShiftValue;\n}\ninline bool operator<(Align Lhs, Align Rhs) {\n  return Lhs.ShiftValue < Rhs.ShiftValue;\n}\ninline bool operator>(Align Lhs, Align Rhs) {\n  return Lhs.ShiftValue > Rhs.ShiftValue;\n}\n\n// Don't allow relational comparisons with MaybeAlign.\nbool operator<=(Align Lhs, MaybeAlign Rhs) = delete;\nbool operator>=(Align Lhs, MaybeAlign Rhs) = delete;\nbool operator<(Align Lhs, MaybeAlign Rhs) = delete;\nbool operator>(Align Lhs, MaybeAlign Rhs) = delete;\n\nbool operator<=(MaybeAlign Lhs, Align Rhs) = delete;\nbool operator>=(MaybeAlign Lhs, Align Rhs) = delete;\nbool operator<(MaybeAlign Lhs, Align Rhs) = delete;\nbool operator>(MaybeAlign Lhs, Align Rhs) = delete;\n\nbool operator<=(MaybeAlign Lhs, MaybeAlign Rhs) = delete;\nbool operator>=(MaybeAlign Lhs, MaybeAlign Rhs) = delete;\nbool operator<(MaybeAlign Lhs, MaybeAlign Rhs) = delete;\nbool operator>(MaybeAlign Lhs, MaybeAlign Rhs) = delete;\n\ninline Align operator*(Align Lhs, uint64_t Rhs) {\n  assert(Rhs > 0 && \"Rhs must be positive\");\n  return Align(Lhs.value() * Rhs);\n}\n\ninline MaybeAlign operator*(MaybeAlign Lhs, uint64_t Rhs) {\n  assert(Rhs > 0 && \"Rhs must be positive\");\n  return Lhs ? Lhs.getValue() * Rhs : MaybeAlign();\n}\n\ninline Align operator/(Align Lhs, uint64_t Divisor) {\n  assert(llvm::isPowerOf2_64(Divisor) &&\n         \"Divisor must be positive and a power of 2\");\n  assert(Lhs != 1 && \"Can't halve byte alignment\");\n  return Align(Lhs.value() / Divisor);\n}\n\ninline MaybeAlign operator/(MaybeAlign Lhs, uint64_t Divisor) {\n  assert(llvm::isPowerOf2_64(Divisor) &&\n         \"Divisor must be positive and a power of 2\");\n  return Lhs ? Lhs.getValue() / Divisor : MaybeAlign();\n}\n\ninline Align max(MaybeAlign Lhs, Align Rhs) {\n  return Lhs && *Lhs > Rhs ? *Lhs : Rhs;\n}\n\ninline Align max(Align Lhs, MaybeAlign Rhs) {\n  return Rhs && *Rhs > Lhs ? *Rhs : Lhs;\n}\n\n#ifndef NDEBUG\n// For usage in LLVM_DEBUG macros.\ninline std::string DebugStr(const Align &A) {\n  return std::to_string(A.value());\n}\n// For usage in LLVM_DEBUG macros.\ninline std::string DebugStr(const MaybeAlign &MA) {\n  if (MA)\n    return std::to_string(MA->value());\n  return \"None\";\n}\n#endif // NDEBUG\n\n#undef ALIGN_CHECK_ISPOSITIVE\n\n} // namespace llvm\n\n#endif // LLVM_SUPPORT_ALIGNMENT_H_\n"}, "19": {"id": 19, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/AllocatorBase.h", "content": "//===- AllocatorBase.h - Simple memory allocation abstraction ---*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n/// \\file\n///\n/// This file defines MallocAllocator. MallocAllocator conforms to the LLVM\n/// \"Allocator\" concept which consists of an Allocate method accepting a size\n/// and alignment, and a Deallocate accepting a pointer and size. Further, the\n/// LLVM \"Allocator\" concept has overloads of Allocate and Deallocate for\n/// setting size and alignment based on the final type. These overloads are\n/// typically provided by a base class template \\c AllocatorBase.\n///\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_SUPPORT_ALLOCATORBASE_H\n#define LLVM_SUPPORT_ALLOCATORBASE_H\n\n#include \"llvm/Support/Compiler.h\"\n#include \"llvm/Support/MemAlloc.h\"\n\nnamespace llvm {\n\n/// CRTP base class providing obvious overloads for the core \\c\n/// Allocate() methods of LLVM-style allocators.\n///\n/// This base class both documents the full public interface exposed by all\n/// LLVM-style allocators, and redirects all of the overloads to a single core\n/// set of methods which the derived class must define.\ntemplate <typename DerivedT> class AllocatorBase {\npublic:\n  /// Allocate \\a Size bytes of \\a Alignment aligned memory. This method\n  /// must be implemented by \\c DerivedT.\n  void *Allocate(size_t Size, size_t Alignment) {\n#ifdef __clang__\n    static_assert(static_cast<void *(AllocatorBase::*)(size_t, size_t)>(\n                      &AllocatorBase::Allocate) !=\n                      static_cast<void *(DerivedT::*)(size_t, size_t)>(\n                          &DerivedT::Allocate),\n                  \"Class derives from AllocatorBase without implementing the \"\n                  \"core Allocate(size_t, size_t) overload!\");\n#endif\n    return static_cast<DerivedT *>(this)->Allocate(Size, Alignment);\n  }\n\n  /// Deallocate \\a Ptr to \\a Size bytes of memory allocated by this\n  /// allocator.\n  void Deallocate(const void *Ptr, size_t Size, size_t Alignment) {\n#ifdef __clang__\n    static_assert(\n        static_cast<void (AllocatorBase::*)(const void *, size_t, size_t)>(\n            &AllocatorBase::Deallocate) !=\n            static_cast<void (DerivedT::*)(const void *, size_t, size_t)>(\n                &DerivedT::Deallocate),\n        \"Class derives from AllocatorBase without implementing the \"\n        \"core Deallocate(void *) overload!\");\n#endif\n    return static_cast<DerivedT *>(this)->Deallocate(Ptr, Size, Alignment);\n  }\n\n  // The rest of these methods are helpers that redirect to one of the above\n  // core methods.\n\n  /// Allocate space for a sequence of objects without constructing them.\n  template <typename T> T *Allocate(size_t Num = 1) {\n    return static_cast<T *>(Allocate(Num * sizeof(T), alignof(T)));\n  }\n\n  /// Deallocate space for a sequence of objects without constructing them.\n  template <typename T>\n  std::enable_if_t<!std::is_same<std::remove_cv_t<T>, void>::value, void>\n  Deallocate(T *Ptr, size_t Num = 1) {\n    Deallocate(static_cast<const void *>(Ptr), Num * sizeof(T), alignof(T));\n  }\n};\n\nclass MallocAllocator : public AllocatorBase<MallocAllocator> {\npublic:\n  void Reset() {}\n\n  LLVM_ATTRIBUTE_RETURNS_NONNULL void *Allocate(size_t Size, size_t Alignment) {\n    return allocate_buffer(Size, Alignment);\n  }\n\n  // Pull in base class overloads.\n  using AllocatorBase<MallocAllocator>::Allocate;\n\n  void Deallocate(const void *Ptr, size_t Size, size_t Alignment) {\n    deallocate_buffer(const_cast<void *>(Ptr), Size, Alignment);\n  }\n\n  // Pull in base class overloads.\n  using AllocatorBase<MallocAllocator>::Deallocate;\n\n  void PrintStats() const {}\n};\n\n} // namespace llvm\n\n#endif // LLVM_SUPPORT_ALLOCATORBASE_H\n"}, "20": {"id": 20, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/CommandLine.h", "content": "//===- llvm/Support/CommandLine.h - Command line handler --------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// This class implements a command line argument processor that is useful when\n// creating a tool.  It provides a simple, minimalistic interface that is easily\n// extensible and supports nonlocal (library) command line options.\n//\n// Note that rather than trying to figure out what this code does, you should\n// read the library documentation located in docs/CommandLine.html or looks at\n// the many example usages in tools/*/*.cpp\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_SUPPORT_COMMANDLINE_H\n#define LLVM_SUPPORT_COMMANDLINE_H\n\n#include \"llvm/ADT/ArrayRef.h\"\n#include \"llvm/ADT/None.h\"\n#include \"llvm/ADT/Optional.h\"\n#include \"llvm/ADT/STLExtras.h\"\n#include \"llvm/ADT/SmallPtrSet.h\"\n#include \"llvm/ADT/SmallVector.h\"\n#include \"llvm/ADT/StringMap.h\"\n#include \"llvm/ADT/StringRef.h\"\n#include \"llvm/ADT/Twine.h\"\n#include \"llvm/ADT/iterator_range.h\"\n#include \"llvm/Support/ErrorHandling.h\"\n#include \"llvm/Support/ManagedStatic.h\"\n#include \"llvm/Support/VirtualFileSystem.h\"\n#include \"llvm/Support/raw_ostream.h\"\n#include <cassert>\n#include <climits>\n#include <cstddef>\n#include <functional>\n#include <initializer_list>\n#include <string>\n#include <type_traits>\n#include <vector>\n\nnamespace llvm {\n\nclass StringSaver;\n\n/// cl Namespace - This namespace contains all of the command line option\n/// processing machinery.  It is intentionally a short name to make qualified\n/// usage concise.\nnamespace cl {\n\n//===----------------------------------------------------------------------===//\n// ParseCommandLineOptions - Command line option processing entry point.\n//\n// Returns true on success. Otherwise, this will print the error message to\n// stderr and exit if \\p Errs is not set (nullptr by default), or print the\n// error message to \\p Errs and return false if \\p Errs is provided.\n//\n// If EnvVar is not nullptr, command-line options are also parsed from the\n// environment variable named by EnvVar.  Precedence is given to occurrences\n// from argv.  This precedence is currently implemented by parsing argv after\n// the environment variable, so it is only implemented correctly for options\n// that give precedence to later occurrences.  If your program supports options\n// that give precedence to earlier occurrences, you will need to extend this\n// function to support it correctly.\nbool ParseCommandLineOptions(int argc, const char *const *argv,\n                             StringRef Overview = \"\",\n                             raw_ostream *Errs = nullptr,\n                             const char *EnvVar = nullptr,\n                             bool LongOptionsUseDoubleDash = false);\n\n// Function pointer type for printing version information.\nusing VersionPrinterTy = std::function<void(raw_ostream &)>;\n\n///===---------------------------------------------------------------------===//\n/// SetVersionPrinter - Override the default (LLVM specific) version printer\n///                     used to print out the version when --version is given\n///                     on the command line. This allows other systems using the\n///                     CommandLine utilities to print their own version string.\nvoid SetVersionPrinter(VersionPrinterTy func);\n\n///===---------------------------------------------------------------------===//\n/// AddExtraVersionPrinter - Add an extra printer to use in addition to the\n///                          default one. This can be called multiple times,\n///                          and each time it adds a new function to the list\n///                          which will be called after the basic LLVM version\n///                          printing is complete. Each can then add additional\n///                          information specific to the tool.\nvoid AddExtraVersionPrinter(VersionPrinterTy func);\n\n// PrintOptionValues - Print option values.\n// With -print-options print the difference between option values and defaults.\n// With -print-all-options print all option values.\n// (Currently not perfect, but best-effort.)\nvoid PrintOptionValues();\n\n// Forward declaration - AddLiteralOption needs to be up here to make gcc happy.\nclass Option;\n\n/// Adds a new option for parsing and provides the option it refers to.\n///\n/// \\param O pointer to the option\n/// \\param Name the string name for the option to handle during parsing\n///\n/// Literal options are used by some parsers to register special option values.\n/// This is how the PassNameParser registers pass names for opt.\nvoid AddLiteralOption(Option &O, StringRef Name);\n\n//===----------------------------------------------------------------------===//\n// Flags permitted to be passed to command line arguments\n//\n\nenum NumOccurrencesFlag { // Flags for the number of occurrences allowed\n  Optional = 0x00,        // Zero or One occurrence\n  ZeroOrMore = 0x01,      // Zero or more occurrences allowed\n  Required = 0x02,        // One occurrence required\n  OneOrMore = 0x03,       // One or more occurrences required\n\n  // ConsumeAfter - Indicates that this option is fed anything that follows the\n  // last positional argument required by the application (it is an error if\n  // there are zero positional arguments, and a ConsumeAfter option is used).\n  // Thus, for example, all arguments to LLI are processed until a filename is\n  // found.  Once a filename is found, all of the succeeding arguments are\n  // passed, unprocessed, to the ConsumeAfter option.\n  //\n  ConsumeAfter = 0x04\n};\n\nenum ValueExpected { // Is a value required for the option?\n  // zero reserved for the unspecified value\n  ValueOptional = 0x01,  // The value can appear... or not\n  ValueRequired = 0x02,  // The value is required to appear!\n  ValueDisallowed = 0x03 // A value may not be specified (for flags)\n};\n\nenum OptionHidden {   // Control whether -help shows this option\n  NotHidden = 0x00,   // Option included in -help & -help-hidden\n  Hidden = 0x01,      // -help doesn't, but -help-hidden does\n  ReallyHidden = 0x02 // Neither -help nor -help-hidden show this arg\n};\n\n// Formatting flags - This controls special features that the option might have\n// that cause it to be parsed differently...\n//\n// Prefix - This option allows arguments that are otherwise unrecognized to be\n// matched by options that are a prefix of the actual value.  This is useful for\n// cases like a linker, where options are typically of the form '-lfoo' or\n// '-L../../include' where -l or -L are the actual flags.  When prefix is\n// enabled, and used, the value for the flag comes from the suffix of the\n// argument.\n//\n// AlwaysPrefix - Only allow the behavior enabled by the Prefix flag and reject\n// the Option=Value form.\n//\n\nenum FormattingFlags {\n  NormalFormatting = 0x00, // Nothing special\n  Positional = 0x01,       // Is a positional argument, no '-' required\n  Prefix = 0x02,           // Can this option directly prefix its value?\n  AlwaysPrefix = 0x03      // Can this option only directly prefix its value?\n};\n\nenum MiscFlags {             // Miscellaneous flags to adjust argument\n  CommaSeparated = 0x01,     // Should this cl::list split between commas?\n  PositionalEatsArgs = 0x02, // Should this positional cl::list eat -args?\n  Sink = 0x04,               // Should this cl::list eat all unknown options?\n\n  // Grouping - Can this option group with other options?\n  // If this is enabled, multiple letter options are allowed to bunch together\n  // with only a single hyphen for the whole group.  This allows emulation\n  // of the behavior that ls uses for example: ls -la === ls -l -a\n  Grouping = 0x08,\n\n  // Default option\n  DefaultOption = 0x10\n};\n\n//===----------------------------------------------------------------------===//\n// Option Category class\n//\nclass OptionCategory {\nprivate:\n  StringRef const Name;\n  StringRef const Description;\n\n  void registerCategory();\n\npublic:\n  OptionCategory(StringRef const Name,\n                 StringRef const Description = \"\")\n      : Name(Name), Description(Description) {\n    registerCategory();\n  }\n\n  StringRef getName() const { return Name; }\n  StringRef getDescription() const { return Description; }\n};\n\n// The general Option Category (used as default category).\nextern OptionCategory GeneralCategory;\n\n//===----------------------------------------------------------------------===//\n// SubCommand class\n//\nclass SubCommand {\nprivate:\n  StringRef Name;\n  StringRef Description;\n\nprotected:\n  void registerSubCommand();\n  void unregisterSubCommand();\n\npublic:\n  SubCommand(StringRef Name, StringRef Description = \"\")\n      : Name(Name), Description(Description) {\n        registerSubCommand();\n  }\n  SubCommand() = default;\n\n  void reset();\n\n  explicit operator bool() const;\n\n  StringRef getName() const { return Name; }\n  StringRef getDescription() const { return Description; }\n\n  SmallVector<Option *, 4> PositionalOpts;\n  SmallVector<Option *, 4> SinkOpts;\n  StringMap<Option *> OptionsMap;\n\n  Option *ConsumeAfterOpt = nullptr; // The ConsumeAfter option if it exists.\n};\n\n// A special subcommand representing no subcommand\nextern ManagedStatic<SubCommand> TopLevelSubCommand;\n\n// A special subcommand that can be used to put an option into all subcommands.\nextern ManagedStatic<SubCommand> AllSubCommands;\n\n//===----------------------------------------------------------------------===//\n// Option Base class\n//\nclass Option {\n  friend class alias;\n\n  // handleOccurrences - Overriden by subclasses to handle the value passed into\n  // an argument.  Should return true if there was an error processing the\n  // argument and the program should exit.\n  //\n  virtual bool handleOccurrence(unsigned pos, StringRef ArgName,\n                                StringRef Arg) = 0;\n\n  virtual enum ValueExpected getValueExpectedFlagDefault() const {\n    return ValueOptional;\n  }\n\n  // Out of line virtual function to provide home for the class.\n  virtual void anchor();\n\n  uint16_t NumOccurrences; // The number of times specified\n  // Occurrences, HiddenFlag, and Formatting are all enum types but to avoid\n  // problems with signed enums in bitfields.\n  uint16_t Occurrences : 3; // enum NumOccurrencesFlag\n  // not using the enum type for 'Value' because zero is an implementation\n  // detail representing the non-value\n  uint16_t Value : 2;\n  uint16_t HiddenFlag : 2; // enum OptionHidden\n  uint16_t Formatting : 2; // enum FormattingFlags\n  uint16_t Misc : 5;\n  uint16_t FullyInitialized : 1; // Has addArgument been called?\n  uint16_t Position;             // Position of last occurrence of the option\n  uint16_t AdditionalVals;       // Greater than 0 for multi-valued option.\n\npublic:\n  StringRef ArgStr;   // The argument string itself (ex: \"help\", \"o\")\n  StringRef HelpStr;  // The descriptive text message for -help\n  StringRef ValueStr; // String describing what the value of this option is\n  SmallVector<OptionCategory *, 1>\n      Categories;                    // The Categories this option belongs to\n  SmallPtrSet<SubCommand *, 1> Subs; // The subcommands this option belongs to.\n\n  inline enum NumOccurrencesFlag getNumOccurrencesFlag() const {\n    return (enum NumOccurrencesFlag)Occurrences;\n  }\n\n  inline enum ValueExpected getValueExpectedFlag() const {\n    return Value ? ((enum ValueExpected)Value) : getValueExpectedFlagDefault();\n  }\n\n  inline enum OptionHidden getOptionHiddenFlag() const {\n    return (enum OptionHidden)HiddenFlag;\n  }\n\n  inline enum FormattingFlags getFormattingFlag() const {\n    return (enum FormattingFlags)Formatting;\n  }\n\n  inline unsigned getMiscFlags() const { return Misc; }\n  inline unsigned getPosition() const { return Position; }\n  inline unsigned getNumAdditionalVals() const { return AdditionalVals; }\n\n  // hasArgStr - Return true if the argstr != \"\"\n  bool hasArgStr() const { return !ArgStr.empty(); }\n  bool isPositional() const { return getFormattingFlag() == cl::Positional; }\n  bool isSink() const { return getMiscFlags() & cl::Sink; }\n  bool isDefaultOption() const { return getMiscFlags() & cl::DefaultOption; }\n\n  bool isConsumeAfter() const {\n    return getNumOccurrencesFlag() == cl::ConsumeAfter;\n  }\n\n  bool isInAllSubCommands() const {\n    return any_of(Subs, [](const SubCommand *SC) {\n      return SC == &*AllSubCommands;\n    });\n  }\n\n  //-------------------------------------------------------------------------===\n  // Accessor functions set by OptionModifiers\n  //\n  void setArgStr(StringRef S);\n  void setDescription(StringRef S) { HelpStr = S; }\n  void setValueStr(StringRef S) { ValueStr = S; }\n  void setNumOccurrencesFlag(enum NumOccurrencesFlag Val) { Occurrences = Val; }\n  void setValueExpectedFlag(enum ValueExpected Val) { Value = Val; }\n  void setHiddenFlag(enum OptionHidden Val) { HiddenFlag = Val; }\n  void setFormattingFlag(enum FormattingFlags V) { Formatting = V; }\n  void setMiscFlag(enum MiscFlags M) { Misc |= M; }\n  void setPosition(unsigned pos) { Position = pos; }\n  void addCategory(OptionCategory &C);\n  void addSubCommand(SubCommand &S) { Subs.insert(&S); }\n\nprotected:\n  explicit Option(enum NumOccurrencesFlag OccurrencesFlag,\n                  enum OptionHidden Hidden)\n      : NumOccurrences(0), Occurrences(OccurrencesFlag), Value(0),\n        HiddenFlag(Hidden), Formatting(NormalFormatting), Misc(0),\n        FullyInitialized(false), Position(0), AdditionalVals(0) {\n    Categories.push_back(&GeneralCategory);\n  }\n\n  inline void setNumAdditionalVals(unsigned n) { AdditionalVals = n; }\n\npublic:\n  virtual ~Option() = default;\n\n  // addArgument - Register this argument with the commandline system.\n  //\n  void addArgument();\n\n  /// Unregisters this option from the CommandLine system.\n  ///\n  /// This option must have been the last option registered.\n  /// For testing purposes only.\n  void removeArgument();\n\n  // Return the width of the option tag for printing...\n  virtual size_t getOptionWidth() const = 0;\n\n  // printOptionInfo - Print out information about this option.  The\n  // to-be-maintained width is specified.\n  //\n  virtual void printOptionInfo(size_t GlobalWidth) const = 0;\n\n  virtual void printOptionValue(size_t GlobalWidth, bool Force) const = 0;\n\n  virtual void setDefault() = 0;\n\n  // Prints the help string for an option.\n  //\n  // This maintains the Indent for multi-line descriptions.\n  // FirstLineIndentedBy is the count of chars of the first line\n  //      i.e. the one containing the --<option name>.\n  static void printHelpStr(StringRef HelpStr, size_t Indent,\n                           size_t FirstLineIndentedBy);\n\n  // Prints the help string for an enum value.\n  //\n  // This maintains the Indent for multi-line descriptions.\n  // FirstLineIndentedBy is the count of chars of the first line\n  //      i.e. the one containing the =<value>.\n  static void printEnumValHelpStr(StringRef HelpStr, size_t Indent,\n                                  size_t FirstLineIndentedBy);\n\n  virtual void getExtraOptionNames(SmallVectorImpl<StringRef> &) {}\n\n  // addOccurrence - Wrapper around handleOccurrence that enforces Flags.\n  //\n  virtual bool addOccurrence(unsigned pos, StringRef ArgName, StringRef Value,\n                             bool MultiArg = false);\n\n  // Prints option name followed by message.  Always returns true.\n  bool error(const Twine &Message, StringRef ArgName = StringRef(), raw_ostream &Errs = llvm::errs());\n  bool error(const Twine &Message, raw_ostream &Errs) {\n    return error(Message, StringRef(), Errs);\n  }\n\n  inline int getNumOccurrences() const { return NumOccurrences; }\n  void reset();\n};\n\n//===----------------------------------------------------------------------===//\n// Command line option modifiers that can be used to modify the behavior of\n// command line option parsers...\n//\n\n// desc - Modifier to set the description shown in the -help output...\nstruct desc {\n  StringRef Desc;\n\n  desc(StringRef Str) : Desc(Str) {}\n\n  void apply(Option &O) const { O.setDescription(Desc); }\n};\n\n// value_desc - Modifier to set the value description shown in the -help\n// output...\nstruct value_desc {\n  StringRef Desc;\n\n  value_desc(StringRef Str) : Desc(Str) {}\n\n  void apply(Option &O) const { O.setValueStr(Desc); }\n};\n\n// init - Specify a default (initial) value for the command line argument, if\n// the default constructor for the argument type does not give you what you\n// want.  This is only valid on \"opt\" arguments, not on \"list\" arguments.\n//\ntemplate <class Ty> struct initializer {\n  const Ty &Init;\n  initializer(const Ty &Val) : Init(Val) {}\n\n  template <class Opt> void apply(Opt &O) const { O.setInitialValue(Init); }\n};\n\ntemplate <class Ty> initializer<Ty> init(const Ty &Val) {\n  return initializer<Ty>(Val);\n}\n\n// location - Allow the user to specify which external variable they want to\n// store the results of the command line argument processing into, if they don't\n// want to store it in the option itself.\n//\ntemplate <class Ty> struct LocationClass {\n  Ty &Loc;\n\n  LocationClass(Ty &L) : Loc(L) {}\n\n  template <class Opt> void apply(Opt &O) const { O.setLocation(O, Loc); }\n};\n\ntemplate <class Ty> LocationClass<Ty> location(Ty &L) {\n  return LocationClass<Ty>(L);\n}\n\n// cat - Specifiy the Option category for the command line argument to belong\n// to.\nstruct cat {\n  OptionCategory &Category;\n\n  cat(OptionCategory &c) : Category(c) {}\n\n  template <class Opt> void apply(Opt &O) const { O.addCategory(Category); }\n};\n\n// sub - Specify the subcommand that this option belongs to.\nstruct sub {\n  SubCommand &Sub;\n\n  sub(SubCommand &S) : Sub(S) {}\n\n  template <class Opt> void apply(Opt &O) const { O.addSubCommand(Sub); }\n};\n\n// Specify a callback function to be called when an option is seen.\n// Can be used to set other options automatically.\ntemplate <typename R, typename Ty> struct cb {\n  std::function<R(Ty)> CB;\n\n  cb(std::function<R(Ty)> CB) : CB(CB) {}\n\n  template <typename Opt> void apply(Opt &O) const { O.setCallback(CB); }\n};\n\nnamespace detail {\ntemplate <typename F>\nstruct callback_traits : public callback_traits<decltype(&F::operator())> {};\n\ntemplate <typename R, typename C, typename... Args>\nstruct callback_traits<R (C::*)(Args...) const> {\n  using result_type = R;\n  using arg_type = std::tuple_element_t<0, std::tuple<Args...>>;\n  static_assert(sizeof...(Args) == 1, \"callback function must have one and only one parameter\");\n  static_assert(std::is_same<result_type, void>::value,\n                \"callback return type must be void\");\n  static_assert(std::is_lvalue_reference<arg_type>::value &&\n                    std::is_const<std::remove_reference_t<arg_type>>::value,\n                \"callback arg_type must be a const lvalue reference\");\n};\n} // namespace detail\n\ntemplate <typename F>\ncb<typename detail::callback_traits<F>::result_type,\n   typename detail::callback_traits<F>::arg_type>\ncallback(F CB) {\n  using result_type = typename detail::callback_traits<F>::result_type;\n  using arg_type = typename detail::callback_traits<F>::arg_type;\n  return cb<result_type, arg_type>(CB);\n}\n\n//===----------------------------------------------------------------------===//\n// OptionValue class\n\n// Support value comparison outside the template.\nstruct GenericOptionValue {\n  virtual bool compare(const GenericOptionValue &V) const = 0;\n\nprotected:\n  GenericOptionValue() = default;\n  GenericOptionValue(const GenericOptionValue&) = default;\n  GenericOptionValue &operator=(const GenericOptionValue &) = default;\n  ~GenericOptionValue() = default;\n\nprivate:\n  virtual void anchor();\n};\n\ntemplate <class DataType> struct OptionValue;\n\n// The default value safely does nothing. Option value printing is only\n// best-effort.\ntemplate <class DataType, bool isClass>\nstruct OptionValueBase : public GenericOptionValue {\n  // Temporary storage for argument passing.\n  using WrapperType = OptionValue<DataType>;\n\n  bool hasValue() const { return false; }\n\n  const DataType &getValue() const { llvm_unreachable(\"no default value\"); }\n\n  // Some options may take their value from a different data type.\n  template <class DT> void setValue(const DT & /*V*/) {}\n\n  bool compare(const DataType & /*V*/) const { return false; }\n\n  bool compare(const GenericOptionValue & /*V*/) const override {\n    return false;\n  }\n\nprotected:\n  ~OptionValueBase() = default;\n};\n\n// Simple copy of the option value.\ntemplate <class DataType> class OptionValueCopy : public GenericOptionValue {\n  DataType Value;\n  bool Valid = false;\n\nprotected:\n  OptionValueCopy(const OptionValueCopy&) = default;\n  OptionValueCopy &operator=(const OptionValueCopy &) = default;\n  ~OptionValueCopy() = default;\n\npublic:\n  OptionValueCopy() = default;\n\n  bool hasValue() const { return Valid; }\n\n  const DataType &getValue() const {\n    assert(Valid && \"invalid option value\");\n    return Value;\n  }\n\n  void setValue(const DataType &V) {\n    Valid = true;\n    Value = V;\n  }\n\n  bool compare(const DataType &V) const { return Valid && (Value != V); }\n\n  bool compare(const GenericOptionValue &V) const override {\n    const OptionValueCopy<DataType> &VC =\n        static_cast<const OptionValueCopy<DataType> &>(V);\n    if (!VC.hasValue())\n      return false;\n    return compare(VC.getValue());\n  }\n};\n\n// Non-class option values.\ntemplate <class DataType>\nstruct OptionValueBase<DataType, false> : OptionValueCopy<DataType> {\n  using WrapperType = DataType;\n\nprotected:\n  OptionValueBase() = default;\n  OptionValueBase(const OptionValueBase&) = default;\n  OptionValueBase &operator=(const OptionValueBase &) = default;\n  ~OptionValueBase() = default;\n};\n\n// Top-level option class.\ntemplate <class DataType>\nstruct OptionValue final\n    : OptionValueBase<DataType, std::is_class<DataType>::value> {\n  OptionValue() = default;\n\n  OptionValue(const DataType &V) { this->setValue(V); }\n\n  // Some options may take their value from a different data type.\n  template <class DT> OptionValue<DataType> &operator=(const DT &V) {\n    this->setValue(V);\n    return *this;\n  }\n};\n\n// Other safe-to-copy-by-value common option types.\nenum boolOrDefault { BOU_UNSET, BOU_TRUE, BOU_FALSE };\ntemplate <>\nstruct OptionValue<cl::boolOrDefault> final\n    : OptionValueCopy<cl::boolOrDefault> {\n  using WrapperType = cl::boolOrDefault;\n\n  OptionValue() = default;\n\n  OptionValue(const cl::boolOrDefault &V) { this->setValue(V); }\n\n  OptionValue<cl::boolOrDefault> &operator=(const cl::boolOrDefault &V) {\n    setValue(V);\n    return *this;\n  }\n\nprivate:\n  void anchor() override;\n};\n\ntemplate <>\nstruct OptionValue<std::string> final : OptionValueCopy<std::string> {\n  using WrapperType = StringRef;\n\n  OptionValue() = default;\n\n  OptionValue(const std::string &V) { this->setValue(V); }\n\n  OptionValue<std::string> &operator=(const std::string &V) {\n    setValue(V);\n    return *this;\n  }\n\nprivate:\n  void anchor() override;\n};\n\n//===----------------------------------------------------------------------===//\n// Enum valued command line option\n//\n\n// This represents a single enum value, using \"int\" as the underlying type.\nstruct OptionEnumValue {\n  StringRef Name;\n  int Value;\n  StringRef Description;\n};\n\n#define clEnumVal(ENUMVAL, DESC)                                               \\\n  llvm::cl::OptionEnumValue { #ENUMVAL, int(ENUMVAL), DESC }\n#define clEnumValN(ENUMVAL, FLAGNAME, DESC)                                    \\\n  llvm::cl::OptionEnumValue { FLAGNAME, int(ENUMVAL), DESC }\n\n// values - For custom data types, allow specifying a group of values together\n// as the values that go into the mapping that the option handler uses.\n//\nclass ValuesClass {\n  // Use a vector instead of a map, because the lists should be short,\n  // the overhead is less, and most importantly, it keeps them in the order\n  // inserted so we can print our option out nicely.\n  SmallVector<OptionEnumValue, 4> Values;\n\npublic:\n  ValuesClass(std::initializer_list<OptionEnumValue> Options)\n      : Values(Options) {}\n\n  template <class Opt> void apply(Opt &O) const {\n    for (const auto &Value : Values)\n      O.getParser().addLiteralOption(Value.Name, Value.Value,\n                                     Value.Description);\n  }\n};\n\n/// Helper to build a ValuesClass by forwarding a variable number of arguments\n/// as an initializer list to the ValuesClass constructor.\ntemplate <typename... OptsTy> ValuesClass values(OptsTy... Options) {\n  return ValuesClass({Options...});\n}\n\n//===----------------------------------------------------------------------===//\n// parser class - Parameterizable parser for different data types.  By default,\n// known data types (string, int, bool) have specialized parsers, that do what\n// you would expect.  The default parser, used for data types that are not\n// built-in, uses a mapping table to map specific options to values, which is\n// used, among other things, to handle enum types.\n\n//--------------------------------------------------\n// generic_parser_base - This class holds all the non-generic code that we do\n// not need replicated for every instance of the generic parser.  This also\n// allows us to put stuff into CommandLine.cpp\n//\nclass generic_parser_base {\nprotected:\n  class GenericOptionInfo {\n  public:\n    GenericOptionInfo(StringRef name, StringRef helpStr)\n        : Name(name), HelpStr(helpStr) {}\n    StringRef Name;\n    StringRef HelpStr;\n  };\n\npublic:\n  generic_parser_base(Option &O) : Owner(O) {}\n\n  virtual ~generic_parser_base() = default;\n  // Base class should have virtual-destructor\n\n  // getNumOptions - Virtual function implemented by generic subclass to\n  // indicate how many entries are in Values.\n  //\n  virtual unsigned getNumOptions() const = 0;\n\n  // getOption - Return option name N.\n  virtual StringRef getOption(unsigned N) const = 0;\n\n  // getDescription - Return description N\n  virtual StringRef getDescription(unsigned N) const = 0;\n\n  // Return the width of the option tag for printing...\n  virtual size_t getOptionWidth(const Option &O) const;\n\n  virtual const GenericOptionValue &getOptionValue(unsigned N) const = 0;\n\n  // printOptionInfo - Print out information about this option.  The\n  // to-be-maintained width is specified.\n  //\n  virtual void printOptionInfo(const Option &O, size_t GlobalWidth) const;\n\n  void printGenericOptionDiff(const Option &O, const GenericOptionValue &V,\n                              const GenericOptionValue &Default,\n                              size_t GlobalWidth) const;\n\n  // printOptionDiff - print the value of an option and it's default.\n  //\n  // Template definition ensures that the option and default have the same\n  // DataType (via the same AnyOptionValue).\n  template <class AnyOptionValue>\n  void printOptionDiff(const Option &O, const AnyOptionValue &V,\n                       const AnyOptionValue &Default,\n                       size_t GlobalWidth) const {\n    printGenericOptionDiff(O, V, Default, GlobalWidth);\n  }\n\n  void initialize() {}\n\n  void getExtraOptionNames(SmallVectorImpl<StringRef> &OptionNames) {\n    // If there has been no argstr specified, that means that we need to add an\n    // argument for every possible option.  This ensures that our options are\n    // vectored to us.\n    if (!Owner.hasArgStr())\n      for (unsigned i = 0, e = getNumOptions(); i != e; ++i)\n        OptionNames.push_back(getOption(i));\n  }\n\n  enum ValueExpected getValueExpectedFlagDefault() const {\n    // If there is an ArgStr specified, then we are of the form:\n    //\n    //    -opt=O2   or   -opt O2  or  -optO2\n    //\n    // In which case, the value is required.  Otherwise if an arg str has not\n    // been specified, we are of the form:\n    //\n    //    -O2 or O2 or -la (where -l and -a are separate options)\n    //\n    // If this is the case, we cannot allow a value.\n    //\n    if (Owner.hasArgStr())\n      return ValueRequired;\n    else\n      return ValueDisallowed;\n  }\n\n  // findOption - Return the option number corresponding to the specified\n  // argument string.  If the option is not found, getNumOptions() is returned.\n  //\n  unsigned findOption(StringRef Name);\n\nprotected:\n  Option &Owner;\n};\n\n// Default parser implementation - This implementation depends on having a\n// mapping of recognized options to values of some sort.  In addition to this,\n// each entry in the mapping also tracks a help message that is printed with the\n// command line option for -help.  Because this is a simple mapping parser, the\n// data type can be any unsupported type.\n//\ntemplate <class DataType> class parser : public generic_parser_base {\nprotected:\n  class OptionInfo : public GenericOptionInfo {\n  public:\n    OptionInfo(StringRef name, DataType v, StringRef helpStr)\n        : GenericOptionInfo(name, helpStr), V(v) {}\n\n    OptionValue<DataType> V;\n  };\n  SmallVector<OptionInfo, 8> Values;\n\npublic:\n  parser(Option &O) : generic_parser_base(O) {}\n\n  using parser_data_type = DataType;\n\n  // Implement virtual functions needed by generic_parser_base\n  unsigned getNumOptions() const override { return unsigned(Values.size()); }\n  StringRef getOption(unsigned N) const override { return Values[N].Name; }\n  StringRef getDescription(unsigned N) const override {\n    return Values[N].HelpStr;\n  }\n\n  // getOptionValue - Return the value of option name N.\n  const GenericOptionValue &getOptionValue(unsigned N) const override {\n    return Values[N].V;\n  }\n\n  // parse - Return true on error.\n  bool parse(Option &O, StringRef ArgName, StringRef Arg, DataType &V) {\n    StringRef ArgVal;\n    if (Owner.hasArgStr())\n      ArgVal = Arg;\n    else\n      ArgVal = ArgName;\n\n    for (size_t i = 0, e = Values.size(); i != e; ++i)\n      if (Values[i].Name == ArgVal) {\n        V = Values[i].V.getValue();\n        return false;\n      }\n\n    return O.error(\"Cannot find option named '\" + ArgVal + \"'!\");\n  }\n\n  /// addLiteralOption - Add an entry to the mapping table.\n  ///\n  template <class DT>\n  void addLiteralOption(StringRef Name, const DT &V, StringRef HelpStr) {\n    assert(findOption(Name) == Values.size() && \"Option already exists!\");\n    OptionInfo X(Name, static_cast<DataType>(V), HelpStr);\n    Values.push_back(X);\n    AddLiteralOption(Owner, Name);\n  }\n\n  /// removeLiteralOption - Remove the specified option.\n  ///\n  void removeLiteralOption(StringRef Name) {\n    unsigned N = findOption(Name);\n    assert(N != Values.size() && \"Option not found!\");\n    Values.erase(Values.begin() + N);\n  }\n};\n\n//--------------------------------------------------\n// basic_parser - Super class of parsers to provide boilerplate code\n//\nclass basic_parser_impl { // non-template implementation of basic_parser<t>\npublic:\n  basic_parser_impl(Option &) {}\n\n  virtual ~basic_parser_impl() {}\n\n  enum ValueExpected getValueExpectedFlagDefault() const {\n    return ValueRequired;\n  }\n\n  void getExtraOptionNames(SmallVectorImpl<StringRef> &) {}\n\n  void initialize() {}\n\n  // Return the width of the option tag for printing...\n  size_t getOptionWidth(const Option &O) const;\n\n  // printOptionInfo - Print out information about this option.  The\n  // to-be-maintained width is specified.\n  //\n  void printOptionInfo(const Option &O, size_t GlobalWidth) const;\n\n  // printOptionNoValue - Print a placeholder for options that don't yet support\n  // printOptionDiff().\n  void printOptionNoValue(const Option &O, size_t GlobalWidth) const;\n\n  // getValueName - Overload in subclass to provide a better default value.\n  virtual StringRef getValueName() const { return \"value\"; }\n\n  // An out-of-line virtual method to provide a 'home' for this class.\n  virtual void anchor();\n\nprotected:\n  // A helper for basic_parser::printOptionDiff.\n  void printOptionName(const Option &O, size_t GlobalWidth) const;\n};\n\n// basic_parser - The real basic parser is just a template wrapper that provides\n// a typedef for the provided data type.\n//\ntemplate <class DataType> class basic_parser : public basic_parser_impl {\npublic:\n  using parser_data_type = DataType;\n  using OptVal = OptionValue<DataType>;\n\n  basic_parser(Option &O) : basic_parser_impl(O) {}\n};\n\n//--------------------------------------------------\n// parser<bool>\n//\ntemplate <> class parser<bool> : public basic_parser<bool> {\npublic:\n  parser(Option &O) : basic_parser(O) {}\n\n  // parse - Return true on error.\n  bool parse(Option &O, StringRef ArgName, StringRef Arg, bool &Val);\n\n  void initialize() {}\n\n  enum ValueExpected getValueExpectedFlagDefault() const {\n    return ValueOptional;\n  }\n\n  // getValueName - Do not print =<value> at all.\n  StringRef getValueName() const override { return StringRef(); }\n\n  void printOptionDiff(const Option &O, bool V, OptVal Default,\n                       size_t GlobalWidth) const;\n\n  // An out-of-line virtual method to provide a 'home' for this class.\n  void anchor() override;\n};\n\nextern template class basic_parser<bool>;\n\n//--------------------------------------------------\n// parser<boolOrDefault>\ntemplate <> class parser<boolOrDefault> : public basic_parser<boolOrDefault> {\npublic:\n  parser(Option &O) : basic_parser(O) {}\n\n  // parse - Return true on error.\n  bool parse(Option &O, StringRef ArgName, StringRef Arg, boolOrDefault &Val);\n\n  enum ValueExpected getValueExpectedFlagDefault() const {\n    return ValueOptional;\n  }\n\n  // getValueName - Do not print =<value> at all.\n  StringRef getValueName() const override { return StringRef(); }\n\n  void printOptionDiff(const Option &O, boolOrDefault V, OptVal Default,\n                       size_t GlobalWidth) const;\n\n  // An out-of-line virtual method to provide a 'home' for this class.\n  void anchor() override;\n};\n\nextern template class basic_parser<boolOrDefault>;\n\n//--------------------------------------------------\n// parser<int>\n//\ntemplate <> class parser<int> : public basic_parser<int> {\npublic:\n  parser(Option &O) : basic_parser(O) {}\n\n  // parse - Return true on error.\n  bool parse(Option &O, StringRef ArgName, StringRef Arg, int &Val);\n\n  // getValueName - Overload in subclass to provide a better default value.\n  StringRef getValueName() const override { return \"int\"; }\n\n  void printOptionDiff(const Option &O, int V, OptVal Default,\n                       size_t GlobalWidth) const;\n\n  // An out-of-line virtual method to provide a 'home' for this class.\n  void anchor() override;\n};\n\nextern template class basic_parser<int>;\n\n//--------------------------------------------------\n// parser<long>\n//\ntemplate <> class parser<long> final : public basic_parser<long> {\npublic:\n  parser(Option &O) : basic_parser(O) {}\n\n  // parse - Return true on error.\n  bool parse(Option &O, StringRef ArgName, StringRef Arg, long &Val);\n\n  // getValueName - Overload in subclass to provide a better default value.\n  StringRef getValueName() const override { return \"long\"; }\n\n  void printOptionDiff(const Option &O, long V, OptVal Default,\n                       size_t GlobalWidth) const;\n\n  // An out-of-line virtual method to provide a 'home' for this class.\n  void anchor() override;\n};\n\nextern template class basic_parser<long>;\n\n//--------------------------------------------------\n// parser<long long>\n//\ntemplate <> class parser<long long> : public basic_parser<long long> {\npublic:\n  parser(Option &O) : basic_parser(O) {}\n\n  // parse - Return true on error.\n  bool parse(Option &O, StringRef ArgName, StringRef Arg, long long &Val);\n\n  // getValueName - Overload in subclass to provide a better default value.\n  StringRef getValueName() const override { return \"long\"; }\n\n  void printOptionDiff(const Option &O, long long V, OptVal Default,\n                       size_t GlobalWidth) const;\n\n  // An out-of-line virtual method to provide a 'home' for this class.\n  void anchor() override;\n};\n\nextern template class basic_parser<long long>;\n\n//--------------------------------------------------\n// parser<unsigned>\n//\ntemplate <> class parser<unsigned> : public basic_parser<unsigned> {\npublic:\n  parser(Option &O) : basic_parser(O) {}\n\n  // parse - Return true on error.\n  bool parse(Option &O, StringRef ArgName, StringRef Arg, unsigned &Val);\n\n  // getValueName - Overload in subclass to provide a better default value.\n  StringRef getValueName() const override { return \"uint\"; }\n\n  void printOptionDiff(const Option &O, unsigned V, OptVal Default,\n                       size_t GlobalWidth) const;\n\n  // An out-of-line virtual method to provide a 'home' for this class.\n  void anchor() override;\n};\n\nextern template class basic_parser<unsigned>;\n\n//--------------------------------------------------\n// parser<unsigned long>\n//\ntemplate <>\nclass parser<unsigned long> final : public basic_parser<unsigned long> {\npublic:\n  parser(Option &O) : basic_parser(O) {}\n\n  // parse - Return true on error.\n  bool parse(Option &O, StringRef ArgName, StringRef Arg, unsigned long &Val);\n\n  // getValueName - Overload in subclass to provide a better default value.\n  StringRef getValueName() const override { return \"ulong\"; }\n\n  void printOptionDiff(const Option &O, unsigned long V, OptVal Default,\n                       size_t GlobalWidth) const;\n\n  // An out-of-line virtual method to provide a 'home' for this class.\n  void anchor() override;\n};\n\nextern template class basic_parser<unsigned long>;\n\n//--------------------------------------------------\n// parser<unsigned long long>\n//\ntemplate <>\nclass parser<unsigned long long> : public basic_parser<unsigned long long> {\npublic:\n  parser(Option &O) : basic_parser(O) {}\n\n  // parse - Return true on error.\n  bool parse(Option &O, StringRef ArgName, StringRef Arg,\n             unsigned long long &Val);\n\n  // getValueName - Overload in subclass to provide a better default value.\n  StringRef getValueName() const override { return \"ulong\"; }\n\n  void printOptionDiff(const Option &O, unsigned long long V, OptVal Default,\n                       size_t GlobalWidth) const;\n\n  // An out-of-line virtual method to provide a 'home' for this class.\n  void anchor() override;\n};\n\nextern template class basic_parser<unsigned long long>;\n\n//--------------------------------------------------\n// parser<double>\n//\ntemplate <> class parser<double> : public basic_parser<double> {\npublic:\n  parser(Option &O) : basic_parser(O) {}\n\n  // parse - Return true on error.\n  bool parse(Option &O, StringRef ArgName, StringRef Arg, double &Val);\n\n  // getValueName - Overload in subclass to provide a better default value.\n  StringRef getValueName() const override { return \"number\"; }\n\n  void printOptionDiff(const Option &O, double V, OptVal Default,\n                       size_t GlobalWidth) const;\n\n  // An out-of-line virtual method to provide a 'home' for this class.\n  void anchor() override;\n};\n\nextern template class basic_parser<double>;\n\n//--------------------------------------------------\n// parser<float>\n//\ntemplate <> class parser<float> : public basic_parser<float> {\npublic:\n  parser(Option &O) : basic_parser(O) {}\n\n  // parse - Return true on error.\n  bool parse(Option &O, StringRef ArgName, StringRef Arg, float &Val);\n\n  // getValueName - Overload in subclass to provide a better default value.\n  StringRef getValueName() const override { return \"number\"; }\n\n  void printOptionDiff(const Option &O, float V, OptVal Default,\n                       size_t GlobalWidth) const;\n\n  // An out-of-line virtual method to provide a 'home' for this class.\n  void anchor() override;\n};\n\nextern template class basic_parser<float>;\n\n//--------------------------------------------------\n// parser<std::string>\n//\ntemplate <> class parser<std::string> : public basic_parser<std::string> {\npublic:\n  parser(Option &O) : basic_parser(O) {}\n\n  // parse - Return true on error.\n  bool parse(Option &, StringRef, StringRef Arg, std::string &Value) {\n    Value = Arg.str();\n    return false;\n  }\n\n  // getValueName - Overload in subclass to provide a better default value.\n  StringRef getValueName() const override { return \"string\"; }\n\n  void printOptionDiff(const Option &O, StringRef V, const OptVal &Default,\n                       size_t GlobalWidth) const;\n\n  // An out-of-line virtual method to provide a 'home' for this class.\n  void anchor() override;\n};\n\nextern template class basic_parser<std::string>;\n\n//--------------------------------------------------\n// parser<char>\n//\ntemplate <> class parser<char> : public basic_parser<char> {\npublic:\n  parser(Option &O) : basic_parser(O) {}\n\n  // parse - Return true on error.\n  bool parse(Option &, StringRef, StringRef Arg, char &Value) {\n    Value = Arg[0];\n    return false;\n  }\n\n  // getValueName - Overload in subclass to provide a better default value.\n  StringRef getValueName() const override { return \"char\"; }\n\n  void printOptionDiff(const Option &O, char V, OptVal Default,\n                       size_t GlobalWidth) const;\n\n  // An out-of-line virtual method to provide a 'home' for this class.\n  void anchor() override;\n};\n\nextern template class basic_parser<char>;\n\n//--------------------------------------------------\n// PrintOptionDiff\n//\n// This collection of wrappers is the intermediary between class opt and class\n// parser to handle all the template nastiness.\n\n// This overloaded function is selected by the generic parser.\ntemplate <class ParserClass, class DT>\nvoid printOptionDiff(const Option &O, const generic_parser_base &P, const DT &V,\n                     const OptionValue<DT> &Default, size_t GlobalWidth) {\n  OptionValue<DT> OV = V;\n  P.printOptionDiff(O, OV, Default, GlobalWidth);\n}\n\n// This is instantiated for basic parsers when the parsed value has a different\n// type than the option value. e.g. HelpPrinter.\ntemplate <class ParserDT, class ValDT> struct OptionDiffPrinter {\n  void print(const Option &O, const parser<ParserDT> &P, const ValDT & /*V*/,\n             const OptionValue<ValDT> & /*Default*/, size_t GlobalWidth) {\n    P.printOptionNoValue(O, GlobalWidth);\n  }\n};\n\n// This is instantiated for basic parsers when the parsed value has the same\n// type as the option value.\ntemplate <class DT> struct OptionDiffPrinter<DT, DT> {\n  void print(const Option &O, const parser<DT> &P, const DT &V,\n             const OptionValue<DT> &Default, size_t GlobalWidth) {\n    P.printOptionDiff(O, V, Default, GlobalWidth);\n  }\n};\n\n// This overloaded function is selected by the basic parser, which may parse a\n// different type than the option type.\ntemplate <class ParserClass, class ValDT>\nvoid printOptionDiff(\n    const Option &O,\n    const basic_parser<typename ParserClass::parser_data_type> &P,\n    const ValDT &V, const OptionValue<ValDT> &Default, size_t GlobalWidth) {\n\n  OptionDiffPrinter<typename ParserClass::parser_data_type, ValDT> printer;\n  printer.print(O, static_cast<const ParserClass &>(P), V, Default,\n                GlobalWidth);\n}\n\n//===----------------------------------------------------------------------===//\n// applicator class - This class is used because we must use partial\n// specialization to handle literal string arguments specially (const char* does\n// not correctly respond to the apply method).  Because the syntax to use this\n// is a pain, we have the 'apply' method below to handle the nastiness...\n//\ntemplate <class Mod> struct applicator {\n  template <class Opt> static void opt(const Mod &M, Opt &O) { M.apply(O); }\n};\n\n// Handle const char* as a special case...\ntemplate <unsigned n> struct applicator<char[n]> {\n  template <class Opt> static void opt(StringRef Str, Opt &O) {\n    O.setArgStr(Str);\n  }\n};\ntemplate <unsigned n> struct applicator<const char[n]> {\n  template <class Opt> static void opt(StringRef Str, Opt &O) {\n    O.setArgStr(Str);\n  }\n};\ntemplate <> struct applicator<StringRef > {\n  template <class Opt> static void opt(StringRef Str, Opt &O) {\n    O.setArgStr(Str);\n  }\n};\n\ntemplate <> struct applicator<NumOccurrencesFlag> {\n  static void opt(NumOccurrencesFlag N, Option &O) {\n    O.setNumOccurrencesFlag(N);\n  }\n};\n\ntemplate <> struct applicator<ValueExpected> {\n  static void opt(ValueExpected VE, Option &O) { O.setValueExpectedFlag(VE); }\n};\n\ntemplate <> struct applicator<OptionHidden> {\n  static void opt(OptionHidden OH, Option &O) { O.setHiddenFlag(OH); }\n};\n\ntemplate <> struct applicator<FormattingFlags> {\n  static void opt(FormattingFlags FF, Option &O) { O.setFormattingFlag(FF); }\n};\n\ntemplate <> struct applicator<MiscFlags> {\n  static void opt(MiscFlags MF, Option &O) {\n    assert((MF != Grouping || O.ArgStr.size() == 1) &&\n           \"cl::Grouping can only apply to single charater Options.\");\n    O.setMiscFlag(MF);\n  }\n};\n\n// apply method - Apply modifiers to an option in a type safe way.\ntemplate <class Opt, class Mod, class... Mods>\nvoid apply(Opt *O, const Mod &M, const Mods &... Ms) {\n  applicator<Mod>::opt(M, *O);\n  apply(O, Ms...);\n}\n\ntemplate <class Opt, class Mod> void apply(Opt *O, const Mod &M) {\n  applicator<Mod>::opt(M, *O);\n}\n\n//===----------------------------------------------------------------------===//\n// opt_storage class\n\n// Default storage class definition: external storage.  This implementation\n// assumes the user will specify a variable to store the data into with the\n// cl::location(x) modifier.\n//\ntemplate <class DataType, bool ExternalStorage, bool isClass>\nclass opt_storage {\n  DataType *Location = nullptr; // Where to store the object...\n  OptionValue<DataType> Default;\n\n  void check_location() const {\n    assert(Location && \"cl::location(...) not specified for a command \"\n                       \"line option with external storage, \"\n                       \"or cl::init specified before cl::location()!!\");\n  }\n\npublic:\n  opt_storage() = default;\n\n  bool setLocation(Option &O, DataType &L) {\n    if (Location)\n      return O.error(\"cl::location(x) specified more than once!\");\n    Location = &L;\n    Default = L;\n    return false;\n  }\n\n  template <class T> void setValue(const T &V, bool initial = false) {\n    check_location();\n    *Location = V;\n    if (initial)\n      Default = V;\n  }\n\n  DataType &getValue() {\n    check_location();\n    return *Location;\n  }\n  const DataType &getValue() const {\n    check_location();\n    return *Location;\n  }\n\n  operator DataType() const { return this->getValue(); }\n\n  const OptionValue<DataType> &getDefault() const { return Default; }\n};\n\n// Define how to hold a class type object, such as a string.  Since we can\n// inherit from a class, we do so.  This makes us exactly compatible with the\n// object in all cases that it is used.\n//\ntemplate <class DataType>\nclass opt_storage<DataType, false, true> : public DataType {\npublic:\n  OptionValue<DataType> Default;\n\n  template <class T> void setValue(const T &V, bool initial = false) {\n    DataType::operator=(V);\n    if (initial)\n      Default = V;\n  }\n\n  DataType &getValue() { return *this; }\n  const DataType &getValue() const { return *this; }\n\n  const OptionValue<DataType> &getDefault() const { return Default; }\n};\n\n// Define a partial specialization to handle things we cannot inherit from.  In\n// this case, we store an instance through containment, and overload operators\n// to get at the value.\n//\ntemplate <class DataType> class opt_storage<DataType, false, false> {\npublic:\n  DataType Value;\n  OptionValue<DataType> Default;\n\n  // Make sure we initialize the value with the default constructor for the\n  // type.\n  opt_storage() : Value(DataType()), Default(DataType()) {}\n\n  template <class T> void setValue(const T &V, bool initial = false) {\n    Value = V;\n    if (initial)\n      Default = V;\n  }\n  DataType &getValue() { return Value; }\n  DataType getValue() const { return Value; }\n\n  const OptionValue<DataType> &getDefault() const { return Default; }\n\n  operator DataType() const { return getValue(); }\n\n  // If the datatype is a pointer, support -> on it.\n  DataType operator->() const { return Value; }\n};\n\n//===----------------------------------------------------------------------===//\n// opt - A scalar command line option.\n//\ntemplate <class DataType, bool ExternalStorage = false,\n          class ParserClass = parser<DataType>>\nclass opt : public Option,\n            public opt_storage<DataType, ExternalStorage,\n                               std::is_class<DataType>::value> {\n  ParserClass Parser;\n\n  bool handleOccurrence(unsigned pos, StringRef ArgName,\n                        StringRef Arg) override {\n    typename ParserClass::parser_data_type Val =\n        typename ParserClass::parser_data_type();\n    if (Parser.parse(*this, ArgName, Arg, Val))\n      return true; // Parse error!\n    this->setValue(Val);\n    this->setPosition(pos);\n    Callback(Val);\n    return false;\n  }\n\n  enum ValueExpected getValueExpectedFlagDefault() const override {\n    return Parser.getValueExpectedFlagDefault();\n  }\n\n  void getExtraOptionNames(SmallVectorImpl<StringRef> &OptionNames) override {\n    return Parser.getExtraOptionNames(OptionNames);\n  }\n\n  // Forward printing stuff to the parser...\n  size_t getOptionWidth() const override {\n    return Parser.getOptionWidth(*this);\n  }\n\n  void printOptionInfo(size_t GlobalWidth) const override {\n    Parser.printOptionInfo(*this, GlobalWidth);\n  }\n\n  void printOptionValue(size_t GlobalWidth, bool Force) const override {\n    if (Force || this->getDefault().compare(this->getValue())) {\n      cl::printOptionDiff<ParserClass>(*this, Parser, this->getValue(),\n                                       this->getDefault(), GlobalWidth);\n    }\n  }\n\n  template <class T,\n            class = std::enable_if_t<std::is_assignable<T &, T>::value>>\n  void setDefaultImpl() {\n    const OptionValue<DataType> &V = this->getDefault();\n    if (V.hasValue())\n      this->setValue(V.getValue());\n  }\n\n  template <class T,\n            class = std::enable_if_t<!std::is_assignable<T &, T>::value>>\n  void setDefaultImpl(...) {}\n\n  void setDefault() override { setDefaultImpl<DataType>(); }\n\n  void done() {\n    addArgument();\n    Parser.initialize();\n  }\n\npublic:\n  // Command line options should not be copyable\n  opt(const opt &) = delete;\n  opt &operator=(const opt &) = delete;\n\n  // setInitialValue - Used by the cl::init modifier...\n  void setInitialValue(const DataType &V) { this->setValue(V, true); }\n\n  ParserClass &getParser() { return Parser; }\n\n  template <class T> DataType &operator=(const T &Val) {\n    this->setValue(Val);\n    Callback(Val);\n    return this->getValue();\n  }\n\n  template <class... Mods>\n  explicit opt(const Mods &... Ms)\n      : Option(llvm::cl::Optional, NotHidden), Parser(*this) {\n    apply(this, Ms...);\n    done();\n  }\n\n  void setCallback(\n      std::function<void(const typename ParserClass::parser_data_type &)> CB) {\n    Callback = CB;\n  }\n\n  std::function<void(const typename ParserClass::parser_data_type &)> Callback =\n      [](const typename ParserClass::parser_data_type &) {};\n};\n\nextern template class opt<unsigned>;\nextern template class opt<int>;\nextern template class opt<std::string>;\nextern template class opt<char>;\nextern template class opt<bool>;\n\n//===----------------------------------------------------------------------===//\n// list_storage class\n\n// Default storage class definition: external storage.  This implementation\n// assumes the user will specify a variable to store the data into with the\n// cl::location(x) modifier.\n//\ntemplate <class DataType, class StorageClass> class list_storage {\n  StorageClass *Location = nullptr; // Where to store the object...\n\npublic:\n  list_storage() = default;\n\n  void clear() {}\n\n  bool setLocation(Option &O, StorageClass &L) {\n    if (Location)\n      return O.error(\"cl::location(x) specified more than once!\");\n    Location = &L;\n    return false;\n  }\n\n  template <class T> void addValue(const T &V) {\n    assert(Location != 0 && \"cl::location(...) not specified for a command \"\n                            \"line option with external storage!\");\n    Location->push_back(V);\n  }\n};\n\n// Define how to hold a class type object, such as a string.\n// Originally this code inherited from std::vector. In transitioning to a new\n// API for command line options we should change this. The new implementation\n// of this list_storage specialization implements the minimum subset of the\n// std::vector API required for all the current clients.\n//\n// FIXME: Reduce this API to a more narrow subset of std::vector\n//\ntemplate <class DataType> class list_storage<DataType, bool> {\n  std::vector<DataType> Storage;\n\npublic:\n  using iterator = typename std::vector<DataType>::iterator;\n\n  iterator begin() { return Storage.begin(); }\n  iterator end() { return Storage.end(); }\n\n  using const_iterator = typename std::vector<DataType>::const_iterator;\n\n  const_iterator begin() const { return Storage.begin(); }\n  const_iterator end() const { return Storage.end(); }\n\n  using size_type = typename std::vector<DataType>::size_type;\n\n  size_type size() const { return Storage.size(); }\n\n  bool empty() const { return Storage.empty(); }\n\n  void push_back(const DataType &value) { Storage.push_back(value); }\n  void push_back(DataType &&value) { Storage.push_back(value); }\n\n  using reference = typename std::vector<DataType>::reference;\n  using const_reference = typename std::vector<DataType>::const_reference;\n\n  reference operator[](size_type pos) { return Storage[pos]; }\n  const_reference operator[](size_type pos) const { return Storage[pos]; }\n\n  void clear() {\n    Storage.clear();\n  }\n\n  iterator erase(const_iterator pos) { return Storage.erase(pos); }\n  iterator erase(const_iterator first, const_iterator last) {\n    return Storage.erase(first, last);\n  }\n\n  iterator erase(iterator pos) { return Storage.erase(pos); }\n  iterator erase(iterator first, iterator last) {\n    return Storage.erase(first, last);\n  }\n\n  iterator insert(const_iterator pos, const DataType &value) {\n    return Storage.insert(pos, value);\n  }\n  iterator insert(const_iterator pos, DataType &&value) {\n    return Storage.insert(pos, value);\n  }\n\n  iterator insert(iterator pos, const DataType &value) {\n    return Storage.insert(pos, value);\n  }\n  iterator insert(iterator pos, DataType &&value) {\n    return Storage.insert(pos, value);\n  }\n\n  reference front() { return Storage.front(); }\n  const_reference front() const { return Storage.front(); }\n\n  operator std::vector<DataType> &() { return Storage; }\n  operator ArrayRef<DataType>() const { return Storage; }\n  std::vector<DataType> *operator&() { return &Storage; }\n  const std::vector<DataType> *operator&() const { return &Storage; }\n\n  template <class T> void addValue(const T &V) { Storage.push_back(V); }\n};\n\n//===----------------------------------------------------------------------===//\n// list - A list of command line options.\n//\ntemplate <class DataType, class StorageClass = bool,\n          class ParserClass = parser<DataType>>\nclass list : public Option, public list_storage<DataType, StorageClass> {\n  std::vector<unsigned> Positions;\n  ParserClass Parser;\n\n  enum ValueExpected getValueExpectedFlagDefault() const override {\n    return Parser.getValueExpectedFlagDefault();\n  }\n\n  void getExtraOptionNames(SmallVectorImpl<StringRef> &OptionNames) override {\n    return Parser.getExtraOptionNames(OptionNames);\n  }\n\n  bool handleOccurrence(unsigned pos, StringRef ArgName,\n                        StringRef Arg) override {\n    typename ParserClass::parser_data_type Val =\n        typename ParserClass::parser_data_type();\n    if (Parser.parse(*this, ArgName, Arg, Val))\n      return true; // Parse Error!\n    list_storage<DataType, StorageClass>::addValue(Val);\n    setPosition(pos);\n    Positions.push_back(pos);\n    Callback(Val);\n    return false;\n  }\n\n  // Forward printing stuff to the parser...\n  size_t getOptionWidth() const override {\n    return Parser.getOptionWidth(*this);\n  }\n\n  void printOptionInfo(size_t GlobalWidth) const override {\n    Parser.printOptionInfo(*this, GlobalWidth);\n  }\n\n  // Unimplemented: list options don't currently store their default value.\n  void printOptionValue(size_t /*GlobalWidth*/, bool /*Force*/) const override {\n  }\n\n  void setDefault() override {\n    Positions.clear();\n    list_storage<DataType, StorageClass>::clear();\n  }\n\n  void done() {\n    addArgument();\n    Parser.initialize();\n  }\n\npublic:\n  // Command line options should not be copyable\n  list(const list &) = delete;\n  list &operator=(const list &) = delete;\n\n  ParserClass &getParser() { return Parser; }\n\n  unsigned getPosition(unsigned optnum) const {\n    assert(optnum < this->size() && \"Invalid option index\");\n    return Positions[optnum];\n  }\n\n  void setNumAdditionalVals(unsigned n) { Option::setNumAdditionalVals(n); }\n\n  template <class... Mods>\n  explicit list(const Mods &... Ms)\n      : Option(ZeroOrMore, NotHidden), Parser(*this) {\n    apply(this, Ms...);\n    done();\n  }\n\n  void setCallback(\n      std::function<void(const typename ParserClass::parser_data_type &)> CB) {\n    Callback = CB;\n  }\n\n  std::function<void(const typename ParserClass::parser_data_type &)> Callback =\n      [](const typename ParserClass::parser_data_type &) {};\n};\n\n// multi_val - Modifier to set the number of additional values.\nstruct multi_val {\n  unsigned AdditionalVals;\n  explicit multi_val(unsigned N) : AdditionalVals(N) {}\n\n  template <typename D, typename S, typename P>\n  void apply(list<D, S, P> &L) const {\n    L.setNumAdditionalVals(AdditionalVals);\n  }\n};\n\n//===----------------------------------------------------------------------===//\n// bits_storage class\n\n// Default storage class definition: external storage.  This implementation\n// assumes the user will specify a variable to store the data into with the\n// cl::location(x) modifier.\n//\ntemplate <class DataType, class StorageClass> class bits_storage {\n  unsigned *Location = nullptr; // Where to store the bits...\n\n  template <class T> static unsigned Bit(const T &V) {\n    unsigned BitPos = reinterpret_cast<unsigned>(V);\n    assert(BitPos < sizeof(unsigned) * CHAR_BIT &&\n           \"enum exceeds width of bit vector!\");\n    return 1 << BitPos;\n  }\n\npublic:\n  bits_storage() = default;\n\n  bool setLocation(Option &O, unsigned &L) {\n    if (Location)\n      return O.error(\"cl::location(x) specified more than once!\");\n    Location = &L;\n    return false;\n  }\n\n  template <class T> void addValue(const T &V) {\n    assert(Location != 0 && \"cl::location(...) not specified for a command \"\n                            \"line option with external storage!\");\n    *Location |= Bit(V);\n  }\n\n  unsigned getBits() { return *Location; }\n\n  template <class T> bool isSet(const T &V) {\n    return (*Location & Bit(V)) != 0;\n  }\n};\n\n// Define how to hold bits.  Since we can inherit from a class, we do so.\n// This makes us exactly compatible with the bits in all cases that it is used.\n//\ntemplate <class DataType> class bits_storage<DataType, bool> {\n  unsigned Bits; // Where to store the bits...\n\n  template <class T> static unsigned Bit(const T &V) {\n    unsigned BitPos = (unsigned)V;\n    assert(BitPos < sizeof(unsigned) * CHAR_BIT &&\n           \"enum exceeds width of bit vector!\");\n    return 1 << BitPos;\n  }\n\npublic:\n  template <class T> void addValue(const T &V) { Bits |= Bit(V); }\n\n  unsigned getBits() { return Bits; }\n\n  template <class T> bool isSet(const T &V) { return (Bits & Bit(V)) != 0; }\n};\n\n//===----------------------------------------------------------------------===//\n// bits - A bit vector of command options.\n//\ntemplate <class DataType, class Storage = bool,\n          class ParserClass = parser<DataType>>\nclass bits : public Option, public bits_storage<DataType, Storage> {\n  std::vector<unsigned> Positions;\n  ParserClass Parser;\n\n  enum ValueExpected getValueExpectedFlagDefault() const override {\n    return Parser.getValueExpectedFlagDefault();\n  }\n\n  void getExtraOptionNames(SmallVectorImpl<StringRef> &OptionNames) override {\n    return Parser.getExtraOptionNames(OptionNames);\n  }\n\n  bool handleOccurrence(unsigned pos, StringRef ArgName,\n                        StringRef Arg) override {\n    typename ParserClass::parser_data_type Val =\n        typename ParserClass::parser_data_type();\n    if (Parser.parse(*this, ArgName, Arg, Val))\n      return true; // Parse Error!\n    this->addValue(Val);\n    setPosition(pos);\n    Positions.push_back(pos);\n    Callback(Val);\n    return false;\n  }\n\n  // Forward printing stuff to the parser...\n  size_t getOptionWidth() const override {\n    return Parser.getOptionWidth(*this);\n  }\n\n  void printOptionInfo(size_t GlobalWidth) const override {\n    Parser.printOptionInfo(*this, GlobalWidth);\n  }\n\n  // Unimplemented: bits options don't currently store their default values.\n  void printOptionValue(size_t /*GlobalWidth*/, bool /*Force*/) const override {\n  }\n\n  void setDefault() override {}\n\n  void done() {\n    addArgument();\n    Parser.initialize();\n  }\n\npublic:\n  // Command line options should not be copyable\n  bits(const bits &) = delete;\n  bits &operator=(const bits &) = delete;\n\n  ParserClass &getParser() { return Parser; }\n\n  unsigned getPosition(unsigned optnum) const {\n    assert(optnum < this->size() && \"Invalid option index\");\n    return Positions[optnum];\n  }\n\n  template <class... Mods>\n  explicit bits(const Mods &... Ms)\n      : Option(ZeroOrMore, NotHidden), Parser(*this) {\n    apply(this, Ms...);\n    done();\n  }\n\n  void setCallback(\n      std::function<void(const typename ParserClass::parser_data_type &)> CB) {\n    Callback = CB;\n  }\n\n  std::function<void(const typename ParserClass::parser_data_type &)> Callback =\n      [](const typename ParserClass::parser_data_type &) {};\n};\n\n//===----------------------------------------------------------------------===//\n// Aliased command line option (alias this name to a preexisting name)\n//\n\nclass alias : public Option {\n  Option *AliasFor;\n\n  bool handleOccurrence(unsigned pos, StringRef /*ArgName*/,\n                        StringRef Arg) override {\n    return AliasFor->handleOccurrence(pos, AliasFor->ArgStr, Arg);\n  }\n\n  bool addOccurrence(unsigned pos, StringRef /*ArgName*/, StringRef Value,\n                     bool MultiArg = false) override {\n    return AliasFor->addOccurrence(pos, AliasFor->ArgStr, Value, MultiArg);\n  }\n\n  // Handle printing stuff...\n  size_t getOptionWidth() const override;\n  void printOptionInfo(size_t GlobalWidth) const override;\n\n  // Aliases do not need to print their values.\n  void printOptionValue(size_t /*GlobalWidth*/, bool /*Force*/) const override {\n  }\n\n  void setDefault() override { AliasFor->setDefault(); }\n\n  ValueExpected getValueExpectedFlagDefault() const override {\n    return AliasFor->getValueExpectedFlag();\n  }\n\n  void done() {\n    if (!hasArgStr())\n      error(\"cl::alias must have argument name specified!\");\n    if (!AliasFor)\n      error(\"cl::alias must have an cl::aliasopt(option) specified!\");\n    if (!Subs.empty())\n      error(\"cl::alias must not have cl::sub(), aliased option's cl::sub() will be used!\");\n    Subs = AliasFor->Subs;\n    Categories = AliasFor->Categories;\n    addArgument();\n  }\n\npublic:\n  // Command line options should not be copyable\n  alias(const alias &) = delete;\n  alias &operator=(const alias &) = delete;\n\n  void setAliasFor(Option &O) {\n    if (AliasFor)\n      error(\"cl::alias must only have one cl::aliasopt(...) specified!\");\n    AliasFor = &O;\n  }\n\n  template <class... Mods>\n  explicit alias(const Mods &... Ms)\n      : Option(Optional, Hidden), AliasFor(nullptr) {\n    apply(this, Ms...);\n    done();\n  }\n};\n\n// aliasfor - Modifier to set the option an alias aliases.\nstruct aliasopt {\n  Option &Opt;\n\n  explicit aliasopt(Option &O) : Opt(O) {}\n\n  void apply(alias &A) const { A.setAliasFor(Opt); }\n};\n\n// extrahelp - provide additional help at the end of the normal help\n// output. All occurrences of cl::extrahelp will be accumulated and\n// printed to stderr at the end of the regular help, just before\n// exit is called.\nstruct extrahelp {\n  StringRef morehelp;\n\n  explicit extrahelp(StringRef help);\n};\n\nvoid PrintVersionMessage();\n\n/// This function just prints the help message, exactly the same way as if the\n/// -help or -help-hidden option had been given on the command line.\n///\n/// \\param Hidden if true will print hidden options\n/// \\param Categorized if true print options in categories\nvoid PrintHelpMessage(bool Hidden = false, bool Categorized = false);\n\n//===----------------------------------------------------------------------===//\n// Public interface for accessing registered options.\n//\n\n/// Use this to get a StringMap to all registered named options\n/// (e.g. -help).\n///\n/// \\return A reference to the StringMap used by the cl APIs to parse options.\n///\n/// Access to unnamed arguments (i.e. positional) are not provided because\n/// it is expected that the client already has access to these.\n///\n/// Typical usage:\n/// \\code\n/// main(int argc,char* argv[]) {\n/// StringMap<llvm::cl::Option*> &opts = llvm::cl::getRegisteredOptions();\n/// assert(opts.count(\"help\") == 1)\n/// opts[\"help\"]->setDescription(\"Show alphabetical help information\")\n/// // More code\n/// llvm::cl::ParseCommandLineOptions(argc,argv);\n/// //More code\n/// }\n/// \\endcode\n///\n/// This interface is useful for modifying options in libraries that are out of\n/// the control of the client. The options should be modified before calling\n/// llvm::cl::ParseCommandLineOptions().\n///\n/// Hopefully this API can be deprecated soon. Any situation where options need\n/// to be modified by tools or libraries should be handled by sane APIs rather\n/// than just handing around a global list.\nStringMap<Option *> &getRegisteredOptions(SubCommand &Sub = *TopLevelSubCommand);\n\n/// Use this to get all registered SubCommands from the provided parser.\n///\n/// \\return A range of all SubCommand pointers registered with the parser.\n///\n/// Typical usage:\n/// \\code\n/// main(int argc, char* argv[]) {\n///   llvm::cl::ParseCommandLineOptions(argc, argv);\n///   for (auto* S : llvm::cl::getRegisteredSubcommands()) {\n///     if (*S) {\n///       std::cout << \"Executing subcommand: \" << S->getName() << std::endl;\n///       // Execute some function based on the name...\n///     }\n///   }\n/// }\n/// \\endcode\n///\n/// This interface is useful for defining subcommands in libraries and\n/// the dispatch from a single point (like in the main function).\niterator_range<typename SmallPtrSet<SubCommand *, 4>::iterator>\ngetRegisteredSubcommands();\n\n//===----------------------------------------------------------------------===//\n// Standalone command line processing utilities.\n//\n\n/// Tokenizes a command line that can contain escapes and quotes.\n//\n/// The quoting rules match those used by GCC and other tools that use\n/// libiberty's buildargv() or expandargv() utilities, and do not match bash.\n/// They differ from buildargv() on treatment of backslashes that do not escape\n/// a special character to make it possible to accept most Windows file paths.\n///\n/// \\param [in] Source The string to be split on whitespace with quotes.\n/// \\param [in] Saver Delegates back to the caller for saving parsed strings.\n/// \\param [in] MarkEOLs true if tokenizing a response file and you want end of\n/// lines and end of the response file to be marked with a nullptr string.\n/// \\param [out] NewArgv All parsed strings are appended to NewArgv.\nvoid TokenizeGNUCommandLine(StringRef Source, StringSaver &Saver,\n                            SmallVectorImpl<const char *> &NewArgv,\n                            bool MarkEOLs = false);\n\n/// Tokenizes a Windows command line which may contain quotes and escaped\n/// quotes.\n///\n/// See MSDN docs for CommandLineToArgvW for information on the quoting rules.\n/// http://msdn.microsoft.com/en-us/library/windows/desktop/17w5ykft(v=vs.85).aspx\n///\n/// \\param [in] Source The string to be split on whitespace with quotes.\n/// \\param [in] Saver Delegates back to the caller for saving parsed strings.\n/// \\param [in] MarkEOLs true if tokenizing a response file and you want end of\n/// lines and end of the response file to be marked with a nullptr string.\n/// \\param [out] NewArgv All parsed strings are appended to NewArgv.\nvoid TokenizeWindowsCommandLine(StringRef Source, StringSaver &Saver,\n                                SmallVectorImpl<const char *> &NewArgv,\n                                bool MarkEOLs = false);\n\n/// Tokenizes a Windows command line while attempting to avoid copies. If no\n/// quoting or escaping was used, this produces substrings of the original\n/// string. If a token requires unquoting, it will be allocated with the\n/// StringSaver.\nvoid TokenizeWindowsCommandLineNoCopy(StringRef Source, StringSaver &Saver,\n                                      SmallVectorImpl<StringRef> &NewArgv);\n\n/// String tokenization function type.  Should be compatible with either\n/// Windows or Unix command line tokenizers.\nusing TokenizerCallback = void (*)(StringRef Source, StringSaver &Saver,\n                                   SmallVectorImpl<const char *> &NewArgv,\n                                   bool MarkEOLs);\n\n/// Tokenizes content of configuration file.\n///\n/// \\param [in] Source The string representing content of config file.\n/// \\param [in] Saver Delegates back to the caller for saving parsed strings.\n/// \\param [out] NewArgv All parsed strings are appended to NewArgv.\n/// \\param [in] MarkEOLs Added for compatibility with TokenizerCallback.\n///\n/// It works like TokenizeGNUCommandLine with ability to skip comment lines.\n///\nvoid tokenizeConfigFile(StringRef Source, StringSaver &Saver,\n                        SmallVectorImpl<const char *> &NewArgv,\n                        bool MarkEOLs = false);\n\n/// Reads command line options from the given configuration file.\n///\n/// \\param [in] CfgFileName Path to configuration file.\n/// \\param [in] Saver  Objects that saves allocated strings.\n/// \\param [out] Argv Array to which the read options are added.\n/// \\return true if the file was successfully read.\n///\n/// It reads content of the specified file, tokenizes it and expands \"@file\"\n/// commands resolving file names in them relative to the directory where\n/// CfgFilename resides.\n///\nbool readConfigFile(StringRef CfgFileName, StringSaver &Saver,\n                    SmallVectorImpl<const char *> &Argv);\n\n/// Expand response files on a command line recursively using the given\n/// StringSaver and tokenization strategy.  Argv should contain the command line\n/// before expansion and will be modified in place. If requested, Argv will\n/// also be populated with nullptrs indicating where each response file line\n/// ends, which is useful for the \"/link\" argument that needs to consume all\n/// remaining arguments only until the next end of line, when in a response\n/// file.\n///\n/// \\param [in] Saver Delegates back to the caller for saving parsed strings.\n/// \\param [in] Tokenizer Tokenization strategy. Typically Unix or Windows.\n/// \\param [in,out] Argv Command line into which to expand response files.\n/// \\param [in] MarkEOLs Mark end of lines and the end of the response file\n/// with nullptrs in the Argv vector.\n/// \\param [in] RelativeNames true if names of nested response files must be\n/// resolved relative to including file.\n/// \\param [in] FS File system used for all file access when running the tool.\n/// \\param [in] CurrentDir Path used to resolve relative rsp files. If set to\n/// None, process' cwd is used instead.\n/// \\return true if all @files were expanded successfully or there were none.\nbool ExpandResponseFiles(\n    StringSaver &Saver, TokenizerCallback Tokenizer,\n    SmallVectorImpl<const char *> &Argv, bool MarkEOLs = false,\n    bool RelativeNames = false,\n    llvm::vfs::FileSystem &FS = *llvm::vfs::getRealFileSystem(),\n    llvm::Optional<llvm::StringRef> CurrentDir = llvm::None);\n\n/// A convenience helper which concatenates the options specified by the\n/// environment variable EnvVar and command line options, then expands response\n/// files recursively. The tokenizer is a predefined GNU or Windows one.\n/// \\return true if all @files were expanded successfully or there were none.\nbool expandResponseFiles(int Argc, const char *const *Argv, const char *EnvVar,\n                         StringSaver &Saver,\n                         SmallVectorImpl<const char *> &NewArgv);\n\n/// Mark all options not part of this category as cl::ReallyHidden.\n///\n/// \\param Category the category of options to keep displaying\n///\n/// Some tools (like clang-format) like to be able to hide all options that are\n/// not specific to the tool. This function allows a tool to specify a single\n/// option category to display in the -help output.\nvoid HideUnrelatedOptions(cl::OptionCategory &Category,\n                          SubCommand &Sub = *TopLevelSubCommand);\n\n/// Mark all options not part of the categories as cl::ReallyHidden.\n///\n/// \\param Categories the categories of options to keep displaying.\n///\n/// Some tools (like clang-format) like to be able to hide all options that are\n/// not specific to the tool. This function allows a tool to specify a single\n/// option category to display in the -help output.\nvoid HideUnrelatedOptions(ArrayRef<const cl::OptionCategory *> Categories,\n                          SubCommand &Sub = *TopLevelSubCommand);\n\n/// Reset all command line options to a state that looks as if they have\n/// never appeared on the command line.  This is useful for being able to parse\n/// a command line multiple times (especially useful for writing tests).\nvoid ResetAllOptionOccurrences();\n\n/// Reset the command line parser back to its initial state.  This\n/// removes\n/// all options, categories, and subcommands and returns the parser to a state\n/// where no options are supported.\nvoid ResetCommandLineParser();\n\n/// Parses `Arg` into the option handler `Handler`.\nbool ProvidePositionalOption(Option *Handler, StringRef Arg, int i);\n\n} // end namespace cl\n\n} // end namespace llvm\n\n#endif // LLVM_SUPPORT_COMMANDLINE_H\n"}, "21": {"id": 21, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/Error.h", "content": "//===- llvm/Support/Error.h - Recoverable error handling --------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// This file defines an API used to report recoverable errors.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_SUPPORT_ERROR_H\n#define LLVM_SUPPORT_ERROR_H\n\n#include \"llvm-c/Error.h\"\n#include \"llvm/ADT/STLExtras.h\"\n#include \"llvm/ADT/SmallVector.h\"\n#include \"llvm/ADT/StringExtras.h\"\n#include \"llvm/ADT/Twine.h\"\n#include \"llvm/Config/abi-breaking.h\"\n#include \"llvm/Support/AlignOf.h\"\n#include \"llvm/Support/Compiler.h\"\n#include \"llvm/Support/Debug.h\"\n#include \"llvm/Support/ErrorHandling.h\"\n#include \"llvm/Support/ErrorOr.h\"\n#include \"llvm/Support/Format.h\"\n#include \"llvm/Support/raw_ostream.h\"\n#include <algorithm>\n#include <cassert>\n#include <cstdint>\n#include <cstdlib>\n#include <functional>\n#include <memory>\n#include <new>\n#include <string>\n#include <system_error>\n#include <type_traits>\n#include <utility>\n#include <vector>\n\nnamespace llvm {\n\nclass ErrorSuccess;\n\n/// Base class for error info classes. Do not extend this directly: Extend\n/// the ErrorInfo template subclass instead.\nclass ErrorInfoBase {\npublic:\n  virtual ~ErrorInfoBase() = default;\n\n  /// Print an error message to an output stream.\n  virtual void log(raw_ostream &OS) const = 0;\n\n  /// Return the error message as a string.\n  virtual std::string message() const {\n    std::string Msg;\n    raw_string_ostream OS(Msg);\n    log(OS);\n    return OS.str();\n  }\n\n  /// Convert this error to a std::error_code.\n  ///\n  /// This is a temporary crutch to enable interaction with code still\n  /// using std::error_code. It will be removed in the future.\n  virtual std::error_code convertToErrorCode() const = 0;\n\n  // Returns the class ID for this type.\n  static const void *classID() { return &ID; }\n\n  // Returns the class ID for the dynamic type of this ErrorInfoBase instance.\n  virtual const void *dynamicClassID() const = 0;\n\n  // Check whether this instance is a subclass of the class identified by\n  // ClassID.\n  virtual bool isA(const void *const ClassID) const {\n    return ClassID == classID();\n  }\n\n  // Check whether this instance is a subclass of ErrorInfoT.\n  template <typename ErrorInfoT> bool isA() const {\n    return isA(ErrorInfoT::classID());\n  }\n\nprivate:\n  virtual void anchor();\n\n  static char ID;\n};\n\n/// Lightweight error class with error context and mandatory checking.\n///\n/// Instances of this class wrap a ErrorInfoBase pointer. Failure states\n/// are represented by setting the pointer to a ErrorInfoBase subclass\n/// instance containing information describing the failure. Success is\n/// represented by a null pointer value.\n///\n/// Instances of Error also contains a 'Checked' flag, which must be set\n/// before the destructor is called, otherwise the destructor will trigger a\n/// runtime error. This enforces at runtime the requirement that all Error\n/// instances be checked or returned to the caller.\n///\n/// There are two ways to set the checked flag, depending on what state the\n/// Error instance is in. For Error instances indicating success, it\n/// is sufficient to invoke the boolean conversion operator. E.g.:\n///\n///   @code{.cpp}\n///   Error foo(<...>);\n///\n///   if (auto E = foo(<...>))\n///     return E; // <- Return E if it is in the error state.\n///   // We have verified that E was in the success state. It can now be safely\n///   // destroyed.\n///   @endcode\n///\n/// A success value *can not* be dropped. For example, just calling 'foo(<...>)'\n/// without testing the return value will raise a runtime error, even if foo\n/// returns success.\n///\n/// For Error instances representing failure, you must use either the\n/// handleErrors or handleAllErrors function with a typed handler. E.g.:\n///\n///   @code{.cpp}\n///   class MyErrorInfo : public ErrorInfo<MyErrorInfo> {\n///     // Custom error info.\n///   };\n///\n///   Error foo(<...>) { return make_error<MyErrorInfo>(...); }\n///\n///   auto E = foo(<...>); // <- foo returns failure with MyErrorInfo.\n///   auto NewE =\n///     handleErrors(E,\n///       [](const MyErrorInfo &M) {\n///         // Deal with the error.\n///       },\n///       [](std::unique_ptr<OtherError> M) -> Error {\n///         if (canHandle(*M)) {\n///           // handle error.\n///           return Error::success();\n///         }\n///         // Couldn't handle this error instance. Pass it up the stack.\n///         return Error(std::move(M));\n///       );\n///   // Note - we must check or return NewE in case any of the handlers\n///   // returned a new error.\n///   @endcode\n///\n/// The handleAllErrors function is identical to handleErrors, except\n/// that it has a void return type, and requires all errors to be handled and\n/// no new errors be returned. It prevents errors (assuming they can all be\n/// handled) from having to be bubbled all the way to the top-level.\n///\n/// *All* Error instances must be checked before destruction, even if\n/// they're moved-assigned or constructed from Success values that have already\n/// been checked. This enforces checking through all levels of the call stack.\nclass LLVM_NODISCARD Error {\n  // ErrorList needs to be able to yank ErrorInfoBase pointers out of Errors\n  // to add to the error list. It can't rely on handleErrors for this, since\n  // handleErrors does not support ErrorList handlers.\n  friend class ErrorList;\n\n  // handleErrors needs to be able to set the Checked flag.\n  template <typename... HandlerTs>\n  friend Error handleErrors(Error E, HandlerTs &&... Handlers);\n\n  // Expected<T> needs to be able to steal the payload when constructed from an\n  // error.\n  template <typename T> friend class Expected;\n\n  // wrap needs to be able to steal the payload.\n  friend LLVMErrorRef wrap(Error);\n\nprotected:\n  /// Create a success value. Prefer using 'Error::success()' for readability\n  Error() {\n    setPtr(nullptr);\n    setChecked(false);\n  }\n\npublic:\n  /// Create a success value.\n  static ErrorSuccess success();\n\n  // Errors are not copy-constructable.\n  Error(const Error &Other) = delete;\n\n  /// Move-construct an error value. The newly constructed error is considered\n  /// unchecked, even if the source error had been checked. The original error\n  /// becomes a checked Success value, regardless of its original state.\n  Error(Error &&Other) {\n    setChecked(true);\n    *this = std::move(Other);\n  }\n\n  /// Create an error value. Prefer using the 'make_error' function, but\n  /// this constructor can be useful when \"re-throwing\" errors from handlers.\n  Error(std::unique_ptr<ErrorInfoBase> Payload) {\n    setPtr(Payload.release());\n    setChecked(false);\n  }\n\n  // Errors are not copy-assignable.\n  Error &operator=(const Error &Other) = delete;\n\n  /// Move-assign an error value. The current error must represent success, you\n  /// you cannot overwrite an unhandled error. The current error is then\n  /// considered unchecked. The source error becomes a checked success value,\n  /// regardless of its original state.\n  Error &operator=(Error &&Other) {\n    // Don't allow overwriting of unchecked values.\n    assertIsChecked();\n    setPtr(Other.getPtr());\n\n    // This Error is unchecked, even if the source error was checked.\n    setChecked(false);\n\n    // Null out Other's payload and set its checked bit.\n    Other.setPtr(nullptr);\n    Other.setChecked(true);\n\n    return *this;\n  }\n\n  /// Destroy a Error. Fails with a call to abort() if the error is\n  /// unchecked.\n  ~Error() {\n    assertIsChecked();\n    delete getPtr();\n  }\n\n  /// Bool conversion. Returns true if this Error is in a failure state,\n  /// and false if it is in an accept state. If the error is in a Success state\n  /// it will be considered checked.\n  explicit operator bool() {\n    setChecked(getPtr() == nullptr);\n    return getPtr() != nullptr;\n  }\n\n  /// Check whether one error is a subclass of another.\n  template <typename ErrT> bool isA() const {\n    return getPtr() && getPtr()->isA(ErrT::classID());\n  }\n\n  /// Returns the dynamic class id of this error, or null if this is a success\n  /// value.\n  const void* dynamicClassID() const {\n    if (!getPtr())\n      return nullptr;\n    return getPtr()->dynamicClassID();\n  }\n\nprivate:\n#if LLVM_ENABLE_ABI_BREAKING_CHECKS\n  // assertIsChecked() happens very frequently, but under normal circumstances\n  // is supposed to be a no-op.  So we want it to be inlined, but having a bunch\n  // of debug prints can cause the function to be too large for inlining.  So\n  // it's important that we define this function out of line so that it can't be\n  // inlined.\n  LLVM_ATTRIBUTE_NORETURN\n  void fatalUncheckedError() const;\n#endif\n\n  void assertIsChecked() {\n#if LLVM_ENABLE_ABI_BREAKING_CHECKS\n    if (LLVM_UNLIKELY(!getChecked() || getPtr()))\n      fatalUncheckedError();\n#endif\n  }\n\n  ErrorInfoBase *getPtr() const {\n#if LLVM_ENABLE_ABI_BREAKING_CHECKS\n    return reinterpret_cast<ErrorInfoBase*>(\n             reinterpret_cast<uintptr_t>(Payload) &\n             ~static_cast<uintptr_t>(0x1));\n#else\n    return Payload;\n#endif\n  }\n\n  void setPtr(ErrorInfoBase *EI) {\n#if LLVM_ENABLE_ABI_BREAKING_CHECKS\n    Payload = reinterpret_cast<ErrorInfoBase*>(\n                (reinterpret_cast<uintptr_t>(EI) &\n                 ~static_cast<uintptr_t>(0x1)) |\n                (reinterpret_cast<uintptr_t>(Payload) & 0x1));\n#else\n    Payload = EI;\n#endif\n  }\n\n  bool getChecked() const {\n#if LLVM_ENABLE_ABI_BREAKING_CHECKS\n    return (reinterpret_cast<uintptr_t>(Payload) & 0x1) == 0;\n#else\n    return true;\n#endif\n  }\n\n  void setChecked(bool V) {\n#if LLVM_ENABLE_ABI_BREAKING_CHECKS\n    Payload = reinterpret_cast<ErrorInfoBase*>(\n                (reinterpret_cast<uintptr_t>(Payload) &\n                  ~static_cast<uintptr_t>(0x1)) |\n                  (V ? 0 : 1));\n#endif\n  }\n\n  std::unique_ptr<ErrorInfoBase> takePayload() {\n    std::unique_ptr<ErrorInfoBase> Tmp(getPtr());\n    setPtr(nullptr);\n    setChecked(true);\n    return Tmp;\n  }\n\n  friend raw_ostream &operator<<(raw_ostream &OS, const Error &E) {\n    if (auto P = E.getPtr())\n      P->log(OS);\n    else\n      OS << \"success\";\n    return OS;\n  }\n\n  ErrorInfoBase *Payload = nullptr;\n};\n\n/// Subclass of Error for the sole purpose of identifying the success path in\n/// the type system. This allows to catch invalid conversion to Expected<T> at\n/// compile time.\nclass ErrorSuccess final : public Error {};\n\ninline ErrorSuccess Error::success() { return ErrorSuccess(); }\n\n/// Make a Error instance representing failure using the given error info\n/// type.\ntemplate <typename ErrT, typename... ArgTs> Error make_error(ArgTs &&... Args) {\n  return Error(std::make_unique<ErrT>(std::forward<ArgTs>(Args)...));\n}\n\n/// Base class for user error types. Users should declare their error types\n/// like:\n///\n/// class MyError : public ErrorInfo<MyError> {\n///   ....\n/// };\n///\n/// This class provides an implementation of the ErrorInfoBase::kind\n/// method, which is used by the Error RTTI system.\ntemplate <typename ThisErrT, typename ParentErrT = ErrorInfoBase>\nclass ErrorInfo : public ParentErrT {\npublic:\n  using ParentErrT::ParentErrT; // inherit constructors\n\n  static const void *classID() { return &ThisErrT::ID; }\n\n  const void *dynamicClassID() const override { return &ThisErrT::ID; }\n\n  bool isA(const void *const ClassID) const override {\n    return ClassID == classID() || ParentErrT::isA(ClassID);\n  }\n};\n\n/// Special ErrorInfo subclass representing a list of ErrorInfos.\n/// Instances of this class are constructed by joinError.\nclass ErrorList final : public ErrorInfo<ErrorList> {\n  // handleErrors needs to be able to iterate the payload list of an\n  // ErrorList.\n  template <typename... HandlerTs>\n  friend Error handleErrors(Error E, HandlerTs &&... Handlers);\n\n  // joinErrors is implemented in terms of join.\n  friend Error joinErrors(Error, Error);\n\npublic:\n  void log(raw_ostream &OS) const override {\n    OS << \"Multiple errors:\\n\";\n    for (auto &ErrPayload : Payloads) {\n      ErrPayload->log(OS);\n      OS << \"\\n\";\n    }\n  }\n\n  std::error_code convertToErrorCode() const override;\n\n  // Used by ErrorInfo::classID.\n  static char ID;\n\nprivate:\n  ErrorList(std::unique_ptr<ErrorInfoBase> Payload1,\n            std::unique_ptr<ErrorInfoBase> Payload2) {\n    assert(!Payload1->isA<ErrorList>() && !Payload2->isA<ErrorList>() &&\n           \"ErrorList constructor payloads should be singleton errors\");\n    Payloads.push_back(std::move(Payload1));\n    Payloads.push_back(std::move(Payload2));\n  }\n\n  static Error join(Error E1, Error E2) {\n    if (!E1)\n      return E2;\n    if (!E2)\n      return E1;\n    if (E1.isA<ErrorList>()) {\n      auto &E1List = static_cast<ErrorList &>(*E1.getPtr());\n      if (E2.isA<ErrorList>()) {\n        auto E2Payload = E2.takePayload();\n        auto &E2List = static_cast<ErrorList &>(*E2Payload);\n        for (auto &Payload : E2List.Payloads)\n          E1List.Payloads.push_back(std::move(Payload));\n      } else\n        E1List.Payloads.push_back(E2.takePayload());\n\n      return E1;\n    }\n    if (E2.isA<ErrorList>()) {\n      auto &E2List = static_cast<ErrorList &>(*E2.getPtr());\n      E2List.Payloads.insert(E2List.Payloads.begin(), E1.takePayload());\n      return E2;\n    }\n    return Error(std::unique_ptr<ErrorList>(\n        new ErrorList(E1.takePayload(), E2.takePayload())));\n  }\n\n  std::vector<std::unique_ptr<ErrorInfoBase>> Payloads;\n};\n\n/// Concatenate errors. The resulting Error is unchecked, and contains the\n/// ErrorInfo(s), if any, contained in E1, followed by the\n/// ErrorInfo(s), if any, contained in E2.\ninline Error joinErrors(Error E1, Error E2) {\n  return ErrorList::join(std::move(E1), std::move(E2));\n}\n\n/// Tagged union holding either a T or a Error.\n///\n/// This class parallels ErrorOr, but replaces error_code with Error. Since\n/// Error cannot be copied, this class replaces getError() with\n/// takeError(). It also adds an bool errorIsA<ErrT>() method for testing the\n/// error class type.\ntemplate <class T> class LLVM_NODISCARD Expected {\n  template <class T1> friend class ExpectedAsOutParameter;\n  template <class OtherT> friend class Expected;\n\n  static constexpr bool isRef = std::is_reference<T>::value;\n\n  using wrap = std::reference_wrapper<std::remove_reference_t<T>>;\n\n  using error_type = std::unique_ptr<ErrorInfoBase>;\n\npublic:\n  using storage_type = std::conditional_t<isRef, wrap, T>;\n  using value_type = T;\n\nprivate:\n  using reference = std::remove_reference_t<T> &;\n  using const_reference = const std::remove_reference_t<T> &;\n  using pointer = std::remove_reference_t<T> *;\n  using const_pointer = const std::remove_reference_t<T> *;\n\npublic:\n  /// Create an Expected<T> error value from the given Error.\n  Expected(Error Err)\n      : HasError(true)\n#if LLVM_ENABLE_ABI_BREAKING_CHECKS\n        // Expected is unchecked upon construction in Debug builds.\n        , Unchecked(true)\n#endif\n  {\n    assert(Err && \"Cannot create Expected<T> from Error success value.\");\n    new (getErrorStorage()) error_type(Err.takePayload());\n  }\n\n  /// Forbid to convert from Error::success() implicitly, this avoids having\n  /// Expected<T> foo() { return Error::success(); } which compiles otherwise\n  /// but triggers the assertion above.\n  Expected(ErrorSuccess) = delete;\n\n  /// Create an Expected<T> success value from the given OtherT value, which\n  /// must be convertible to T.\n  template <typename OtherT>\n  Expected(OtherT &&Val,\n           std::enable_if_t<std::is_convertible<OtherT, T>::value> * = nullptr)\n      : HasError(false)\n#if LLVM_ENABLE_ABI_BREAKING_CHECKS\n        // Expected is unchecked upon construction in Debug builds.\n        ,\n        Unchecked(true)\n#endif\n  {\n    new (getStorage()) storage_type(std::forward<OtherT>(Val));\n  }\n\n  /// Move construct an Expected<T> value.\n  Expected(Expected &&Other) { moveConstruct(std::move(Other)); }\n\n  /// Move construct an Expected<T> value from an Expected<OtherT>, where OtherT\n  /// must be convertible to T.\n  template <class OtherT>\n  Expected(\n      Expected<OtherT> &&Other,\n      std::enable_if_t<std::is_convertible<OtherT, T>::value> * = nullptr) {\n    moveConstruct(std::move(Other));\n  }\n\n  /// Move construct an Expected<T> value from an Expected<OtherT>, where OtherT\n  /// isn't convertible to T.\n  template <class OtherT>\n  explicit Expected(\n      Expected<OtherT> &&Other,\n      std::enable_if_t<!std::is_convertible<OtherT, T>::value> * = nullptr) {\n    moveConstruct(std::move(Other));\n  }\n\n  /// Move-assign from another Expected<T>.\n  Expected &operator=(Expected &&Other) {\n    moveAssign(std::move(Other));\n    return *this;\n  }\n\n  /// Destroy an Expected<T>.\n  ~Expected() {\n    assertIsChecked();\n    if (!HasError)\n      getStorage()->~storage_type();\n    else\n      getErrorStorage()->~error_type();\n  }\n\n  /// Return false if there is an error.\n  explicit operator bool() {\n#if LLVM_ENABLE_ABI_BREAKING_CHECKS\n    Unchecked = HasError;\n#endif\n    return !HasError;\n  }\n\n  /// Returns a reference to the stored T value.\n  reference get() {\n    assertIsChecked();\n    return *getStorage();\n  }\n\n  /// Returns a const reference to the stored T value.\n  const_reference get() const {\n    assertIsChecked();\n    return const_cast<Expected<T> *>(this)->get();\n  }\n\n  /// Check that this Expected<T> is an error of type ErrT.\n  template <typename ErrT> bool errorIsA() const {\n    return HasError && (*getErrorStorage())->template isA<ErrT>();\n  }\n\n  /// Take ownership of the stored error.\n  /// After calling this the Expected<T> is in an indeterminate state that can\n  /// only be safely destructed. No further calls (beside the destructor) should\n  /// be made on the Expected<T> value.\n  Error takeError() {\n#if LLVM_ENABLE_ABI_BREAKING_CHECKS\n    Unchecked = false;\n#endif\n    return HasError ? Error(std::move(*getErrorStorage())) : Error::success();\n  }\n\n  /// Returns a pointer to the stored T value.\n  pointer operator->() {\n    assertIsChecked();\n    return toPointer(getStorage());\n  }\n\n  /// Returns a const pointer to the stored T value.\n  const_pointer operator->() const {\n    assertIsChecked();\n    return toPointer(getStorage());\n  }\n\n  /// Returns a reference to the stored T value.\n  reference operator*() {\n    assertIsChecked();\n    return *getStorage();\n  }\n\n  /// Returns a const reference to the stored T value.\n  const_reference operator*() const {\n    assertIsChecked();\n    return *getStorage();\n  }\n\nprivate:\n  template <class T1>\n  static bool compareThisIfSameType(const T1 &a, const T1 &b) {\n    return &a == &b;\n  }\n\n  template <class T1, class T2>\n  static bool compareThisIfSameType(const T1 &a, const T2 &b) {\n    return false;\n  }\n\n  template <class OtherT> void moveConstruct(Expected<OtherT> &&Other) {\n    HasError = Other.HasError;\n#if LLVM_ENABLE_ABI_BREAKING_CHECKS\n    Unchecked = true;\n    Other.Unchecked = false;\n#endif\n\n    if (!HasError)\n      new (getStorage()) storage_type(std::move(*Other.getStorage()));\n    else\n      new (getErrorStorage()) error_type(std::move(*Other.getErrorStorage()));\n  }\n\n  template <class OtherT> void moveAssign(Expected<OtherT> &&Other) {\n    assertIsChecked();\n\n    if (compareThisIfSameType(*this, Other))\n      return;\n\n    this->~Expected();\n    new (this) Expected(std::move(Other));\n  }\n\n  pointer toPointer(pointer Val) { return Val; }\n\n  const_pointer toPointer(const_pointer Val) const { return Val; }\n\n  pointer toPointer(wrap *Val) { return &Val->get(); }\n\n  const_pointer toPointer(const wrap *Val) const { return &Val->get(); }\n\n  storage_type *getStorage() {\n    assert(!HasError && \"Cannot get value when an error exists!\");\n    return reinterpret_cast<storage_type *>(&TStorage);\n  }\n\n  const storage_type *getStorage() const {\n    assert(!HasError && \"Cannot get value when an error exists!\");\n    return reinterpret_cast<const storage_type *>(&TStorage);\n  }\n\n  error_type *getErrorStorage() {\n    assert(HasError && \"Cannot get error when a value exists!\");\n    return reinterpret_cast<error_type *>(&ErrorStorage);\n  }\n\n  const error_type *getErrorStorage() const {\n    assert(HasError && \"Cannot get error when a value exists!\");\n    return reinterpret_cast<const error_type *>(&ErrorStorage);\n  }\n\n  // Used by ExpectedAsOutParameter to reset the checked flag.\n  void setUnchecked() {\n#if LLVM_ENABLE_ABI_BREAKING_CHECKS\n    Unchecked = true;\n#endif\n  }\n\n#if LLVM_ENABLE_ABI_BREAKING_CHECKS\n  LLVM_ATTRIBUTE_NORETURN\n  LLVM_ATTRIBUTE_NOINLINE\n  void fatalUncheckedExpected() const {\n    dbgs() << \"Expected<T> must be checked before access or destruction.\\n\";\n    if (HasError) {\n      dbgs() << \"Unchecked Expected<T> contained error:\\n\";\n      (*getErrorStorage())->log(dbgs());\n    } else\n      dbgs() << \"Expected<T> value was in success state. (Note: Expected<T> \"\n                \"values in success mode must still be checked prior to being \"\n                \"destroyed).\\n\";\n    abort();\n  }\n#endif\n\n  void assertIsChecked() {\n#if LLVM_ENABLE_ABI_BREAKING_CHECKS\n    if (LLVM_UNLIKELY(Unchecked))\n      fatalUncheckedExpected();\n#endif\n  }\n\n  union {\n    AlignedCharArrayUnion<storage_type> TStorage;\n    AlignedCharArrayUnion<error_type> ErrorStorage;\n  };\n  bool HasError : 1;\n#if LLVM_ENABLE_ABI_BREAKING_CHECKS\n  bool Unchecked : 1;\n#endif\n};\n\n/// Report a serious error, calling any installed error handler. See\n/// ErrorHandling.h.\nLLVM_ATTRIBUTE_NORETURN void report_fatal_error(Error Err,\n                                                bool gen_crash_diag = true);\n\n/// Report a fatal error if Err is a failure value.\n///\n/// This function can be used to wrap calls to fallible functions ONLY when it\n/// is known that the Error will always be a success value. E.g.\n///\n///   @code{.cpp}\n///   // foo only attempts the fallible operation if DoFallibleOperation is\n///   // true. If DoFallibleOperation is false then foo always returns\n///   // Error::success().\n///   Error foo(bool DoFallibleOperation);\n///\n///   cantFail(foo(false));\n///   @endcode\ninline void cantFail(Error Err, const char *Msg = nullptr) {\n  if (Err) {\n    if (!Msg)\n      Msg = \"Failure value returned from cantFail wrapped call\";\n#ifndef NDEBUG\n    std::string Str;\n    raw_string_ostream OS(Str);\n    OS << Msg << \"\\n\" << Err;\n    Msg = OS.str().c_str();\n#endif\n    llvm_unreachable(Msg);\n  }\n}\n\n/// Report a fatal error if ValOrErr is a failure value, otherwise unwraps and\n/// returns the contained value.\n///\n/// This function can be used to wrap calls to fallible functions ONLY when it\n/// is known that the Error will always be a success value. E.g.\n///\n///   @code{.cpp}\n///   // foo only attempts the fallible operation if DoFallibleOperation is\n///   // true. If DoFallibleOperation is false then foo always returns an int.\n///   Expected<int> foo(bool DoFallibleOperation);\n///\n///   int X = cantFail(foo(false));\n///   @endcode\ntemplate <typename T>\nT cantFail(Expected<T> ValOrErr, const char *Msg = nullptr) {\n  if (ValOrErr)\n    return std::move(*ValOrErr);\n  else {\n    if (!Msg)\n      Msg = \"Failure value returned from cantFail wrapped call\";\n#ifndef NDEBUG\n    std::string Str;\n    raw_string_ostream OS(Str);\n    auto E = ValOrErr.takeError();\n    OS << Msg << \"\\n\" << E;\n    Msg = OS.str().c_str();\n#endif\n    llvm_unreachable(Msg);\n  }\n}\n\n/// Report a fatal error if ValOrErr is a failure value, otherwise unwraps and\n/// returns the contained reference.\n///\n/// This function can be used to wrap calls to fallible functions ONLY when it\n/// is known that the Error will always be a success value. E.g.\n///\n///   @code{.cpp}\n///   // foo only attempts the fallible operation if DoFallibleOperation is\n///   // true. If DoFallibleOperation is false then foo always returns a Bar&.\n///   Expected<Bar&> foo(bool DoFallibleOperation);\n///\n///   Bar &X = cantFail(foo(false));\n///   @endcode\ntemplate <typename T>\nT& cantFail(Expected<T&> ValOrErr, const char *Msg = nullptr) {\n  if (ValOrErr)\n    return *ValOrErr;\n  else {\n    if (!Msg)\n      Msg = \"Failure value returned from cantFail wrapped call\";\n#ifndef NDEBUG\n    std::string Str;\n    raw_string_ostream OS(Str);\n    auto E = ValOrErr.takeError();\n    OS << Msg << \"\\n\" << E;\n    Msg = OS.str().c_str();\n#endif\n    llvm_unreachable(Msg);\n  }\n}\n\n/// Helper for testing applicability of, and applying, handlers for\n/// ErrorInfo types.\ntemplate <typename HandlerT>\nclass ErrorHandlerTraits\n    : public ErrorHandlerTraits<decltype(\n          &std::remove_reference<HandlerT>::type::operator())> {};\n\n// Specialization functions of the form 'Error (const ErrT&)'.\ntemplate <typename ErrT> class ErrorHandlerTraits<Error (&)(ErrT &)> {\npublic:\n  static bool appliesTo(const ErrorInfoBase &E) {\n    return E.template isA<ErrT>();\n  }\n\n  template <typename HandlerT>\n  static Error apply(HandlerT &&H, std::unique_ptr<ErrorInfoBase> E) {\n    assert(appliesTo(*E) && \"Applying incorrect handler\");\n    return H(static_cast<ErrT &>(*E));\n  }\n};\n\n// Specialization functions of the form 'void (const ErrT&)'.\ntemplate <typename ErrT> class ErrorHandlerTraits<void (&)(ErrT &)> {\npublic:\n  static bool appliesTo(const ErrorInfoBase &E) {\n    return E.template isA<ErrT>();\n  }\n\n  template <typename HandlerT>\n  static Error apply(HandlerT &&H, std::unique_ptr<ErrorInfoBase> E) {\n    assert(appliesTo(*E) && \"Applying incorrect handler\");\n    H(static_cast<ErrT &>(*E));\n    return Error::success();\n  }\n};\n\n/// Specialization for functions of the form 'Error (std::unique_ptr<ErrT>)'.\ntemplate <typename ErrT>\nclass ErrorHandlerTraits<Error (&)(std::unique_ptr<ErrT>)> {\npublic:\n  static bool appliesTo(const ErrorInfoBase &E) {\n    return E.template isA<ErrT>();\n  }\n\n  template <typename HandlerT>\n  static Error apply(HandlerT &&H, std::unique_ptr<ErrorInfoBase> E) {\n    assert(appliesTo(*E) && \"Applying incorrect handler\");\n    std::unique_ptr<ErrT> SubE(static_cast<ErrT *>(E.release()));\n    return H(std::move(SubE));\n  }\n};\n\n/// Specialization for functions of the form 'void (std::unique_ptr<ErrT>)'.\ntemplate <typename ErrT>\nclass ErrorHandlerTraits<void (&)(std::unique_ptr<ErrT>)> {\npublic:\n  static bool appliesTo(const ErrorInfoBase &E) {\n    return E.template isA<ErrT>();\n  }\n\n  template <typename HandlerT>\n  static Error apply(HandlerT &&H, std::unique_ptr<ErrorInfoBase> E) {\n    assert(appliesTo(*E) && \"Applying incorrect handler\");\n    std::unique_ptr<ErrT> SubE(static_cast<ErrT *>(E.release()));\n    H(std::move(SubE));\n    return Error::success();\n  }\n};\n\n// Specialization for member functions of the form 'RetT (const ErrT&)'.\ntemplate <typename C, typename RetT, typename ErrT>\nclass ErrorHandlerTraits<RetT (C::*)(ErrT &)>\n    : public ErrorHandlerTraits<RetT (&)(ErrT &)> {};\n\n// Specialization for member functions of the form 'RetT (const ErrT&) const'.\ntemplate <typename C, typename RetT, typename ErrT>\nclass ErrorHandlerTraits<RetT (C::*)(ErrT &) const>\n    : public ErrorHandlerTraits<RetT (&)(ErrT &)> {};\n\n// Specialization for member functions of the form 'RetT (const ErrT&)'.\ntemplate <typename C, typename RetT, typename ErrT>\nclass ErrorHandlerTraits<RetT (C::*)(const ErrT &)>\n    : public ErrorHandlerTraits<RetT (&)(ErrT &)> {};\n\n// Specialization for member functions of the form 'RetT (const ErrT&) const'.\ntemplate <typename C, typename RetT, typename ErrT>\nclass ErrorHandlerTraits<RetT (C::*)(const ErrT &) const>\n    : public ErrorHandlerTraits<RetT (&)(ErrT &)> {};\n\n/// Specialization for member functions of the form\n/// 'RetT (std::unique_ptr<ErrT>)'.\ntemplate <typename C, typename RetT, typename ErrT>\nclass ErrorHandlerTraits<RetT (C::*)(std::unique_ptr<ErrT>)>\n    : public ErrorHandlerTraits<RetT (&)(std::unique_ptr<ErrT>)> {};\n\n/// Specialization for member functions of the form\n/// 'RetT (std::unique_ptr<ErrT>) const'.\ntemplate <typename C, typename RetT, typename ErrT>\nclass ErrorHandlerTraits<RetT (C::*)(std::unique_ptr<ErrT>) const>\n    : public ErrorHandlerTraits<RetT (&)(std::unique_ptr<ErrT>)> {};\n\ninline Error handleErrorImpl(std::unique_ptr<ErrorInfoBase> Payload) {\n  return Error(std::move(Payload));\n}\n\ntemplate <typename HandlerT, typename... HandlerTs>\nError handleErrorImpl(std::unique_ptr<ErrorInfoBase> Payload,\n                      HandlerT &&Handler, HandlerTs &&... Handlers) {\n  if (ErrorHandlerTraits<HandlerT>::appliesTo(*Payload))\n    return ErrorHandlerTraits<HandlerT>::apply(std::forward<HandlerT>(Handler),\n                                               std::move(Payload));\n  return handleErrorImpl(std::move(Payload),\n                         std::forward<HandlerTs>(Handlers)...);\n}\n\n/// Pass the ErrorInfo(s) contained in E to their respective handlers. Any\n/// unhandled errors (or Errors returned by handlers) are re-concatenated and\n/// returned.\n/// Because this function returns an error, its result must also be checked\n/// or returned. If you intend to handle all errors use handleAllErrors\n/// (which returns void, and will abort() on unhandled errors) instead.\ntemplate <typename... HandlerTs>\nError handleErrors(Error E, HandlerTs &&... Hs) {\n  if (!E)\n    return Error::success();\n\n  std::unique_ptr<ErrorInfoBase> Payload = E.takePayload();\n\n  if (Payload->isA<ErrorList>()) {\n    ErrorList &List = static_cast<ErrorList &>(*Payload);\n    Error R;\n    for (auto &P : List.Payloads)\n      R = ErrorList::join(\n          std::move(R),\n          handleErrorImpl(std::move(P), std::forward<HandlerTs>(Hs)...));\n    return R;\n  }\n\n  return handleErrorImpl(std::move(Payload), std::forward<HandlerTs>(Hs)...);\n}\n\n/// Behaves the same as handleErrors, except that by contract all errors\n/// *must* be handled by the given handlers (i.e. there must be no remaining\n/// errors after running the handlers, or llvm_unreachable is called).\ntemplate <typename... HandlerTs>\nvoid handleAllErrors(Error E, HandlerTs &&... Handlers) {\n  cantFail(handleErrors(std::move(E), std::forward<HandlerTs>(Handlers)...));\n}\n\n/// Check that E is a non-error, then drop it.\n/// If E is an error, llvm_unreachable will be called.\ninline void handleAllErrors(Error E) {\n  cantFail(std::move(E));\n}\n\n/// Handle any errors (if present) in an Expected<T>, then try a recovery path.\n///\n/// If the incoming value is a success value it is returned unmodified. If it\n/// is a failure value then it the contained error is passed to handleErrors.\n/// If handleErrors is able to handle the error then the RecoveryPath functor\n/// is called to supply the final result. If handleErrors is not able to\n/// handle all errors then the unhandled errors are returned.\n///\n/// This utility enables the follow pattern:\n///\n///   @code{.cpp}\n///   enum FooStrategy { Aggressive, Conservative };\n///   Expected<Foo> foo(FooStrategy S);\n///\n///   auto ResultOrErr =\n///     handleExpected(\n///       foo(Aggressive),\n///       []() { return foo(Conservative); },\n///       [](AggressiveStrategyError&) {\n///         // Implicitly conusme this - we'll recover by using a conservative\n///         // strategy.\n///       });\n///\n///   @endcode\ntemplate <typename T, typename RecoveryFtor, typename... HandlerTs>\nExpected<T> handleExpected(Expected<T> ValOrErr, RecoveryFtor &&RecoveryPath,\n                           HandlerTs &&... Handlers) {\n  if (ValOrErr)\n    return ValOrErr;\n\n  if (auto Err = handleErrors(ValOrErr.takeError(),\n                              std::forward<HandlerTs>(Handlers)...))\n    return std::move(Err);\n\n  return RecoveryPath();\n}\n\n/// Log all errors (if any) in E to OS. If there are any errors, ErrorBanner\n/// will be printed before the first one is logged. A newline will be printed\n/// after each error.\n///\n/// This function is compatible with the helpers from Support/WithColor.h. You\n/// can pass any of them as the OS. Please consider using them instead of\n/// including 'error: ' in the ErrorBanner.\n///\n/// This is useful in the base level of your program to allow clean termination\n/// (allowing clean deallocation of resources, etc.), while reporting error\n/// information to the user.\nvoid logAllUnhandledErrors(Error E, raw_ostream &OS, Twine ErrorBanner = {});\n\n/// Write all error messages (if any) in E to a string. The newline character\n/// is used to separate error messages.\ninline std::string toString(Error E) {\n  SmallVector<std::string, 2> Errors;\n  handleAllErrors(std::move(E), [&Errors](const ErrorInfoBase &EI) {\n    Errors.push_back(EI.message());\n  });\n  return join(Errors.begin(), Errors.end(), \"\\n\");\n}\n\n/// Consume a Error without doing anything. This method should be used\n/// only where an error can be considered a reasonable and expected return\n/// value.\n///\n/// Uses of this method are potentially indicative of design problems: If it's\n/// legitimate to do nothing while processing an \"error\", the error-producer\n/// might be more clearly refactored to return an Optional<T>.\ninline void consumeError(Error Err) {\n  handleAllErrors(std::move(Err), [](const ErrorInfoBase &) {});\n}\n\n/// Convert an Expected to an Optional without doing anything. This method\n/// should be used only where an error can be considered a reasonable and\n/// expected return value.\n///\n/// Uses of this method are potentially indicative of problems: perhaps the\n/// error should be propagated further, or the error-producer should just\n/// return an Optional in the first place.\ntemplate <typename T> Optional<T> expectedToOptional(Expected<T> &&E) {\n  if (E)\n    return std::move(*E);\n  consumeError(E.takeError());\n  return None;\n}\n\n/// Helper for converting an Error to a bool.\n///\n/// This method returns true if Err is in an error state, or false if it is\n/// in a success state.  Puts Err in a checked state in both cases (unlike\n/// Error::operator bool(), which only does this for success states).\ninline bool errorToBool(Error Err) {\n  bool IsError = static_cast<bool>(Err);\n  if (IsError)\n    consumeError(std::move(Err));\n  return IsError;\n}\n\n/// Helper for Errors used as out-parameters.\n///\n/// This helper is for use with the Error-as-out-parameter idiom, where an error\n/// is passed to a function or method by reference, rather than being returned.\n/// In such cases it is helpful to set the checked bit on entry to the function\n/// so that the error can be written to (unchecked Errors abort on assignment)\n/// and clear the checked bit on exit so that clients cannot accidentally forget\n/// to check the result. This helper performs these actions automatically using\n/// RAII:\n///\n///   @code{.cpp}\n///   Result foo(Error &Err) {\n///     ErrorAsOutParameter ErrAsOutParam(&Err); // 'Checked' flag set\n///     // <body of foo>\n///     // <- 'Checked' flag auto-cleared when ErrAsOutParam is destructed.\n///   }\n///   @endcode\n///\n/// ErrorAsOutParameter takes an Error* rather than Error& so that it can be\n/// used with optional Errors (Error pointers that are allowed to be null). If\n/// ErrorAsOutParameter took an Error reference, an instance would have to be\n/// created inside every condition that verified that Error was non-null. By\n/// taking an Error pointer we can just create one instance at the top of the\n/// function.\nclass ErrorAsOutParameter {\npublic:\n  ErrorAsOutParameter(Error *Err) : Err(Err) {\n    // Raise the checked bit if Err is success.\n    if (Err)\n      (void)!!*Err;\n  }\n\n  ~ErrorAsOutParameter() {\n    // Clear the checked bit.\n    if (Err && !*Err)\n      *Err = Error::success();\n  }\n\nprivate:\n  Error *Err;\n};\n\n/// Helper for Expected<T>s used as out-parameters.\n///\n/// See ErrorAsOutParameter.\ntemplate <typename T>\nclass ExpectedAsOutParameter {\npublic:\n  ExpectedAsOutParameter(Expected<T> *ValOrErr)\n    : ValOrErr(ValOrErr) {\n    if (ValOrErr)\n      (void)!!*ValOrErr;\n  }\n\n  ~ExpectedAsOutParameter() {\n    if (ValOrErr)\n      ValOrErr->setUnchecked();\n  }\n\nprivate:\n  Expected<T> *ValOrErr;\n};\n\n/// This class wraps a std::error_code in a Error.\n///\n/// This is useful if you're writing an interface that returns a Error\n/// (or Expected) and you want to call code that still returns\n/// std::error_codes.\nclass ECError : public ErrorInfo<ECError> {\n  friend Error errorCodeToError(std::error_code);\n\n  virtual void anchor() override;\n\npublic:\n  void setErrorCode(std::error_code EC) { this->EC = EC; }\n  std::error_code convertToErrorCode() const override { return EC; }\n  void log(raw_ostream &OS) const override { OS << EC.message(); }\n\n  // Used by ErrorInfo::classID.\n  static char ID;\n\nprotected:\n  ECError() = default;\n  ECError(std::error_code EC) : EC(EC) {}\n\n  std::error_code EC;\n};\n\n/// The value returned by this function can be returned from convertToErrorCode\n/// for Error values where no sensible translation to std::error_code exists.\n/// It should only be used in this situation, and should never be used where a\n/// sensible conversion to std::error_code is available, as attempts to convert\n/// to/from this error will result in a fatal error. (i.e. it is a programmatic\n///error to try to convert such a value).\nstd::error_code inconvertibleErrorCode();\n\n/// Helper for converting an std::error_code to a Error.\nError errorCodeToError(std::error_code EC);\n\n/// Helper for converting an ECError to a std::error_code.\n///\n/// This method requires that Err be Error() or an ECError, otherwise it\n/// will trigger a call to abort().\nstd::error_code errorToErrorCode(Error Err);\n\n/// Convert an ErrorOr<T> to an Expected<T>.\ntemplate <typename T> Expected<T> errorOrToExpected(ErrorOr<T> &&EO) {\n  if (auto EC = EO.getError())\n    return errorCodeToError(EC);\n  return std::move(*EO);\n}\n\n/// Convert an Expected<T> to an ErrorOr<T>.\ntemplate <typename T> ErrorOr<T> expectedToErrorOr(Expected<T> &&E) {\n  if (auto Err = E.takeError())\n    return errorToErrorCode(std::move(Err));\n  return std::move(*E);\n}\n\n/// This class wraps a string in an Error.\n///\n/// StringError is useful in cases where the client is not expected to be able\n/// to consume the specific error message programmatically (for example, if the\n/// error message is to be presented to the user).\n///\n/// StringError can also be used when additional information is to be printed\n/// along with a error_code message. Depending on the constructor called, this\n/// class can either display:\n///    1. the error_code message (ECError behavior)\n///    2. a string\n///    3. the error_code message and a string\n///\n/// These behaviors are useful when subtyping is required; for example, when a\n/// specific library needs an explicit error type. In the example below,\n/// PDBError is derived from StringError:\n///\n///   @code{.cpp}\n///   Expected<int> foo() {\n///      return llvm::make_error<PDBError>(pdb_error_code::dia_failed_loading,\n///                                        \"Additional information\");\n///   }\n///   @endcode\n///\nclass StringError : public ErrorInfo<StringError> {\npublic:\n  static char ID;\n\n  // Prints EC + S and converts to EC\n  StringError(std::error_code EC, const Twine &S = Twine());\n\n  // Prints S and converts to EC\n  StringError(const Twine &S, std::error_code EC);\n\n  void log(raw_ostream &OS) const override;\n  std::error_code convertToErrorCode() const override;\n\n  const std::string &getMessage() const { return Msg; }\n\nprivate:\n  std::string Msg;\n  std::error_code EC;\n  const bool PrintMsgOnly = false;\n};\n\n/// Create formatted StringError object.\ntemplate <typename... Ts>\ninline Error createStringError(std::error_code EC, char const *Fmt,\n                               const Ts &... Vals) {\n  std::string Buffer;\n  raw_string_ostream Stream(Buffer);\n  Stream << format(Fmt, Vals...);\n  return make_error<StringError>(Stream.str(), EC);\n}\n\nError createStringError(std::error_code EC, char const *Msg);\n\ninline Error createStringError(std::error_code EC, const Twine &S) {\n  return createStringError(EC, S.str().c_str());\n}\n\ntemplate <typename... Ts>\ninline Error createStringError(std::errc EC, char const *Fmt,\n                               const Ts &... Vals) {\n  return createStringError(std::make_error_code(EC), Fmt, Vals...);\n}\n\n/// This class wraps a filename and another Error.\n///\n/// In some cases, an error needs to live along a 'source' name, in order to\n/// show more detailed information to the user.\nclass FileError final : public ErrorInfo<FileError> {\n\n  friend Error createFileError(const Twine &, Error);\n  friend Error createFileError(const Twine &, size_t, Error);\n\npublic:\n  void log(raw_ostream &OS) const override {\n    assert(Err && !FileName.empty() && \"Trying to log after takeError().\");\n    OS << \"'\" << FileName << \"': \";\n    if (Line.hasValue())\n      OS << \"line \" << Line.getValue() << \": \";\n    Err->log(OS);\n  }\n\n  StringRef getFileName() { return FileName; }\n\n  Error takeError() { return Error(std::move(Err)); }\n\n  std::error_code convertToErrorCode() const override;\n\n  // Used by ErrorInfo::classID.\n  static char ID;\n\nprivate:\n  FileError(const Twine &F, Optional<size_t> LineNum,\n            std::unique_ptr<ErrorInfoBase> E) {\n    assert(E && \"Cannot create FileError from Error success value.\");\n    assert(!F.isTriviallyEmpty() &&\n           \"The file name provided to FileError must not be empty.\");\n    FileName = F.str();\n    Err = std::move(E);\n    Line = std::move(LineNum);\n  }\n\n  static Error build(const Twine &F, Optional<size_t> Line, Error E) {\n    std::unique_ptr<ErrorInfoBase> Payload;\n    handleAllErrors(std::move(E),\n                    [&](std::unique_ptr<ErrorInfoBase> EIB) -> Error {\n                      Payload = std::move(EIB);\n                      return Error::success();\n                    });\n    return Error(\n        std::unique_ptr<FileError>(new FileError(F, Line, std::move(Payload))));\n  }\n\n  std::string FileName;\n  Optional<size_t> Line;\n  std::unique_ptr<ErrorInfoBase> Err;\n};\n\n/// Concatenate a source file path and/or name with an Error. The resulting\n/// Error is unchecked.\ninline Error createFileError(const Twine &F, Error E) {\n  return FileError::build(F, Optional<size_t>(), std::move(E));\n}\n\n/// Concatenate a source file path and/or name with line number and an Error.\n/// The resulting Error is unchecked.\ninline Error createFileError(const Twine &F, size_t Line, Error E) {\n  return FileError::build(F, Optional<size_t>(Line), std::move(E));\n}\n\n/// Concatenate a source file path and/or name with a std::error_code \n/// to form an Error object.\ninline Error createFileError(const Twine &F, std::error_code EC) {\n  return createFileError(F, errorCodeToError(EC));\n}\n\n/// Concatenate a source file path and/or name with line number and\n/// std::error_code to form an Error object.\ninline Error createFileError(const Twine &F, size_t Line, std::error_code EC) {\n  return createFileError(F, Line, errorCodeToError(EC));\n}\n\nError createFileError(const Twine &F, ErrorSuccess) = delete;\n\n/// Helper for check-and-exit error handling.\n///\n/// For tool use only. NOT FOR USE IN LIBRARY CODE.\n///\nclass ExitOnError {\npublic:\n  /// Create an error on exit helper.\n  ExitOnError(std::string Banner = \"\", int DefaultErrorExitCode = 1)\n      : Banner(std::move(Banner)),\n        GetExitCode([=](const Error &) { return DefaultErrorExitCode; }) {}\n\n  /// Set the banner string for any errors caught by operator().\n  void setBanner(std::string Banner) { this->Banner = std::move(Banner); }\n\n  /// Set the exit-code mapper function.\n  void setExitCodeMapper(std::function<int(const Error &)> GetExitCode) {\n    this->GetExitCode = std::move(GetExitCode);\n  }\n\n  /// Check Err. If it's in a failure state log the error(s) and exit.\n  void operator()(Error Err) const { checkError(std::move(Err)); }\n\n  /// Check E. If it's in a success state then return the contained value. If\n  /// it's in a failure state log the error(s) and exit.\n  template <typename T> T operator()(Expected<T> &&E) const {\n    checkError(E.takeError());\n    return std::move(*E);\n  }\n\n  /// Check E. If it's in a success state then return the contained reference. If\n  /// it's in a failure state log the error(s) and exit.\n  template <typename T> T& operator()(Expected<T&> &&E) const {\n    checkError(E.takeError());\n    return *E;\n  }\n\nprivate:\n  void checkError(Error Err) const {\n    if (Err) {\n      int ExitCode = GetExitCode(Err);\n      logAllUnhandledErrors(std::move(Err), errs(), Banner);\n      exit(ExitCode);\n    }\n  }\n\n  std::string Banner;\n  std::function<int(const Error &)> GetExitCode;\n};\n\n/// Conversion from Error to LLVMErrorRef for C error bindings.\ninline LLVMErrorRef wrap(Error Err) {\n  return reinterpret_cast<LLVMErrorRef>(Err.takePayload().release());\n}\n\n/// Conversion from LLVMErrorRef to Error for C error bindings.\ninline Error unwrap(LLVMErrorRef ErrRef) {\n  return Error(std::unique_ptr<ErrorInfoBase>(\n      reinterpret_cast<ErrorInfoBase *>(ErrRef)));\n}\n\n} // end namespace llvm\n\n#endif // LLVM_SUPPORT_ERROR_H\n"}, "22": {"id": 22, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/ErrorOr.h", "content": "//===- llvm/Support/ErrorOr.h - Error Smart Pointer -------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n///\n/// \\file\n///\n/// Provides ErrorOr<T> smart pointer.\n///\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_SUPPORT_ERROROR_H\n#define LLVM_SUPPORT_ERROROR_H\n\n#include \"llvm/Support/AlignOf.h\"\n#include <cassert>\n#include <system_error>\n#include <type_traits>\n#include <utility>\n\nnamespace llvm {\n\n/// Represents either an error or a value T.\n///\n/// ErrorOr<T> is a pointer-like class that represents the result of an\n/// operation. The result is either an error, or a value of type T. This is\n/// designed to emulate the usage of returning a pointer where nullptr indicates\n/// failure. However instead of just knowing that the operation failed, we also\n/// have an error_code and optional user data that describes why it failed.\n///\n/// It is used like the following.\n/// \\code\n///   ErrorOr<Buffer> getBuffer();\n///\n///   auto buffer = getBuffer();\n///   if (error_code ec = buffer.getError())\n///     return ec;\n///   buffer->write(\"adena\");\n/// \\endcode\n///\n///\n/// Implicit conversion to bool returns true if there is a usable value. The\n/// unary * and -> operators provide pointer like access to the value. Accessing\n/// the value when there is an error has undefined behavior.\n///\n/// When T is a reference type the behavior is slightly different. The reference\n/// is held in a std::reference_wrapper<std::remove_reference<T>::type>, and\n/// there is special handling to make operator -> work as if T was not a\n/// reference.\n///\n/// T cannot be a rvalue reference.\ntemplate<class T>\nclass ErrorOr {\n  template <class OtherT> friend class ErrorOr;\n\n  static constexpr bool isRef = std::is_reference<T>::value;\n\n  using wrap = std::reference_wrapper<std::remove_reference_t<T>>;\n\npublic:\n  using storage_type = std::conditional_t<isRef, wrap, T>;\n\nprivate:\n  using reference = std::remove_reference_t<T> &;\n  using const_reference = const std::remove_reference_t<T> &;\n  using pointer = std::remove_reference_t<T> *;\n  using const_pointer = const std::remove_reference_t<T> *;\n\npublic:\n  template <class E>\n  ErrorOr(E ErrorCode,\n          std::enable_if_t<std::is_error_code_enum<E>::value ||\n                               std::is_error_condition_enum<E>::value,\n                           void *> = nullptr)\n      : HasError(true) {\n    new (getErrorStorage()) std::error_code(make_error_code(ErrorCode));\n  }\n\n  ErrorOr(std::error_code EC) : HasError(true) {\n    new (getErrorStorage()) std::error_code(EC);\n  }\n\n  template <class OtherT>\n  ErrorOr(OtherT &&Val,\n          std::enable_if_t<std::is_convertible<OtherT, T>::value> * = nullptr)\n      : HasError(false) {\n    new (getStorage()) storage_type(std::forward<OtherT>(Val));\n  }\n\n  ErrorOr(const ErrorOr &Other) {\n    copyConstruct(Other);\n  }\n\n  template <class OtherT>\n  ErrorOr(const ErrorOr<OtherT> &Other,\n          std::enable_if_t<std::is_convertible<OtherT, T>::value> * = nullptr) {\n    copyConstruct(Other);\n  }\n\n  template <class OtherT>\n  explicit ErrorOr(\n      const ErrorOr<OtherT> &Other,\n      std::enable_if_t<!std::is_convertible<OtherT, const T &>::value> * =\n          nullptr) {\n    copyConstruct(Other);\n  }\n\n  ErrorOr(ErrorOr &&Other) {\n    moveConstruct(std::move(Other));\n  }\n\n  template <class OtherT>\n  ErrorOr(ErrorOr<OtherT> &&Other,\n          std::enable_if_t<std::is_convertible<OtherT, T>::value> * = nullptr) {\n    moveConstruct(std::move(Other));\n  }\n\n  // This might eventually need SFINAE but it's more complex than is_convertible\n  // & I'm too lazy to write it right now.\n  template <class OtherT>\n  explicit ErrorOr(\n      ErrorOr<OtherT> &&Other,\n      std::enable_if_t<!std::is_convertible<OtherT, T>::value> * = nullptr) {\n    moveConstruct(std::move(Other));\n  }\n\n  ErrorOr &operator=(const ErrorOr &Other) {\n    copyAssign(Other);\n    return *this;\n  }\n\n  ErrorOr &operator=(ErrorOr &&Other) {\n    moveAssign(std::move(Other));\n    return *this;\n  }\n\n  ~ErrorOr() {\n    if (!HasError)\n      getStorage()->~storage_type();\n  }\n\n  /// Return false if there is an error.\n  explicit operator bool() const {\n    return !HasError;\n  }\n\n  reference get() { return *getStorage(); }\n  const_reference get() const { return const_cast<ErrorOr<T> *>(this)->get(); }\n\n  std::error_code getError() const {\n    return HasError ? *getErrorStorage() : std::error_code();\n  }\n\n  pointer operator ->() {\n    return toPointer(getStorage());\n  }\n\n  const_pointer operator->() const { return toPointer(getStorage()); }\n\n  reference operator *() {\n    return *getStorage();\n  }\n\n  const_reference operator*() const { return *getStorage(); }\n\nprivate:\n  template <class OtherT>\n  void copyConstruct(const ErrorOr<OtherT> &Other) {\n    if (!Other.HasError) {\n      // Get the other value.\n      HasError = false;\n      new (getStorage()) storage_type(*Other.getStorage());\n    } else {\n      // Get other's error.\n      HasError = true;\n      new (getErrorStorage()) std::error_code(Other.getError());\n    }\n  }\n\n  template <class T1>\n  static bool compareThisIfSameType(const T1 &a, const T1 &b) {\n    return &a == &b;\n  }\n\n  template <class T1, class T2>\n  static bool compareThisIfSameType(const T1 &a, const T2 &b) {\n    return false;\n  }\n\n  template <class OtherT>\n  void copyAssign(const ErrorOr<OtherT> &Other) {\n    if (compareThisIfSameType(*this, Other))\n      return;\n\n    this->~ErrorOr();\n    new (this) ErrorOr(Other);\n  }\n\n  template <class OtherT>\n  void moveConstruct(ErrorOr<OtherT> &&Other) {\n    if (!Other.HasError) {\n      // Get the other value.\n      HasError = false;\n      new (getStorage()) storage_type(std::move(*Other.getStorage()));\n    } else {\n      // Get other's error.\n      HasError = true;\n      new (getErrorStorage()) std::error_code(Other.getError());\n    }\n  }\n\n  template <class OtherT>\n  void moveAssign(ErrorOr<OtherT> &&Other) {\n    if (compareThisIfSameType(*this, Other))\n      return;\n\n    this->~ErrorOr();\n    new (this) ErrorOr(std::move(Other));\n  }\n\n  pointer toPointer(pointer Val) {\n    return Val;\n  }\n\n  const_pointer toPointer(const_pointer Val) const { return Val; }\n\n  pointer toPointer(wrap *Val) {\n    return &Val->get();\n  }\n\n  const_pointer toPointer(const wrap *Val) const { return &Val->get(); }\n\n  storage_type *getStorage() {\n    assert(!HasError && \"Cannot get value when an error exists!\");\n    return reinterpret_cast<storage_type *>(&TStorage);\n  }\n\n  const storage_type *getStorage() const {\n    assert(!HasError && \"Cannot get value when an error exists!\");\n    return reinterpret_cast<const storage_type *>(&TStorage);\n  }\n\n  std::error_code *getErrorStorage() {\n    assert(HasError && \"Cannot get error when a value exists!\");\n    return reinterpret_cast<std::error_code *>(&ErrorStorage);\n  }\n\n  const std::error_code *getErrorStorage() const {\n    return const_cast<ErrorOr<T> *>(this)->getErrorStorage();\n  }\n\n  union {\n    AlignedCharArrayUnion<storage_type> TStorage;\n    AlignedCharArrayUnion<std::error_code> ErrorStorage;\n  };\n  bool HasError : 1;\n};\n\ntemplate <class T, class E>\nstd::enable_if_t<std::is_error_code_enum<E>::value ||\n                     std::is_error_condition_enum<E>::value,\n                 bool>\noperator==(const ErrorOr<T> &Err, E Code) {\n  return Err.getError() == Code;\n}\n\n} // end namespace llvm\n\n#endif // LLVM_SUPPORT_ERROROR_H\n"}, "23": {"id": 23, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/FileSystem.h", "content": "//===- llvm/Support/FileSystem.h - File System OS Concept -------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// This file declares the llvm::sys::fs namespace. It is designed after\n// TR2/boost filesystem (v3), but modified to remove exception handling and the\n// path class.\n//\n// All functions return an error_code and their actual work via the last out\n// argument. The out argument is defined if and only if errc::success is\n// returned. A function may return any error code in the generic or system\n// category. However, they shall be equivalent to any error conditions listed\n// in each functions respective documentation if the condition applies. [ note:\n// this does not guarantee that error_code will be in the set of explicitly\n// listed codes, but it does guarantee that if any of the explicitly listed\n// errors occur, the correct error_code will be used ]. All functions may\n// return errc::not_enough_memory if there is not enough memory to complete the\n// operation.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_SUPPORT_FILESYSTEM_H\n#define LLVM_SUPPORT_FILESYSTEM_H\n\n#include \"llvm/ADT/SmallString.h\"\n#include \"llvm/ADT/StringRef.h\"\n#include \"llvm/ADT/Twine.h\"\n#include \"llvm/Config/llvm-config.h\"\n#include \"llvm/Support/Chrono.h\"\n#include \"llvm/Support/Error.h\"\n#include \"llvm/Support/ErrorHandling.h\"\n#include \"llvm/Support/ErrorOr.h\"\n#include \"llvm/Support/FileSystem/UniqueID.h\"\n#include \"llvm/Support/MD5.h\"\n#include <cassert>\n#include <cstdint>\n#include <ctime>\n#include <memory>\n#include <stack>\n#include <string>\n#include <system_error>\n#include <vector>\n\n#ifdef HAVE_SYS_STAT_H\n#include <sys/stat.h>\n#endif\n\nnamespace llvm {\nnamespace sys {\nnamespace fs {\n\n#if defined(_WIN32)\n// A Win32 HANDLE is a typedef of void*\nusing file_t = void *;\n#else\nusing file_t = int;\n#endif\n\nextern const file_t kInvalidFile;\n\n/// An enumeration for the file system's view of the type.\nenum class file_type {\n  status_error,\n  file_not_found,\n  regular_file,\n  directory_file,\n  symlink_file,\n  block_file,\n  character_file,\n  fifo_file,\n  socket_file,\n  type_unknown\n};\n\n/// space_info - Self explanatory.\nstruct space_info {\n  uint64_t capacity;\n  uint64_t free;\n  uint64_t available;\n};\n\nenum perms {\n  no_perms = 0,\n  owner_read = 0400,\n  owner_write = 0200,\n  owner_exe = 0100,\n  owner_all = owner_read | owner_write | owner_exe,\n  group_read = 040,\n  group_write = 020,\n  group_exe = 010,\n  group_all = group_read | group_write | group_exe,\n  others_read = 04,\n  others_write = 02,\n  others_exe = 01,\n  others_all = others_read | others_write | others_exe,\n  all_read = owner_read | group_read | others_read,\n  all_write = owner_write | group_write | others_write,\n  all_exe = owner_exe | group_exe | others_exe,\n  all_all = owner_all | group_all | others_all,\n  set_uid_on_exe = 04000,\n  set_gid_on_exe = 02000,\n  sticky_bit = 01000,\n  all_perms = all_all | set_uid_on_exe | set_gid_on_exe | sticky_bit,\n  perms_not_known = 0xFFFF\n};\n\n// Helper functions so that you can use & and | to manipulate perms bits:\ninline perms operator|(perms l, perms r) {\n  return static_cast<perms>(static_cast<unsigned short>(l) |\n                            static_cast<unsigned short>(r));\n}\ninline perms operator&(perms l, perms r) {\n  return static_cast<perms>(static_cast<unsigned short>(l) &\n                            static_cast<unsigned short>(r));\n}\ninline perms &operator|=(perms &l, perms r) {\n  l = l | r;\n  return l;\n}\ninline perms &operator&=(perms &l, perms r) {\n  l = l & r;\n  return l;\n}\ninline perms operator~(perms x) {\n  // Avoid UB by explicitly truncating the (unsigned) ~ result.\n  return static_cast<perms>(\n      static_cast<unsigned short>(~static_cast<unsigned short>(x)));\n}\n\n/// Represents the result of a call to directory_iterator::status(). This is a\n/// subset of the information returned by a regular sys::fs::status() call, and\n/// represents the information provided by Windows FileFirstFile/FindNextFile.\nclass basic_file_status {\nprotected:\n  #if defined(LLVM_ON_UNIX)\n  time_t fs_st_atime = 0;\n  time_t fs_st_mtime = 0;\n  uint32_t fs_st_atime_nsec = 0;\n  uint32_t fs_st_mtime_nsec = 0;\n  uid_t fs_st_uid = 0;\n  gid_t fs_st_gid = 0;\n  off_t fs_st_size = 0;\n  #elif defined (_WIN32)\n  uint32_t LastAccessedTimeHigh = 0;\n  uint32_t LastAccessedTimeLow = 0;\n  uint32_t LastWriteTimeHigh = 0;\n  uint32_t LastWriteTimeLow = 0;\n  uint32_t FileSizeHigh = 0;\n  uint32_t FileSizeLow = 0;\n  #endif\n  file_type Type = file_type::status_error;\n  perms Perms = perms_not_known;\n\npublic:\n  basic_file_status() = default;\n\n  explicit basic_file_status(file_type Type) : Type(Type) {}\n\n  #if defined(LLVM_ON_UNIX)\n  basic_file_status(file_type Type, perms Perms, time_t ATime,\n                    uint32_t ATimeNSec, time_t MTime, uint32_t MTimeNSec,\n                    uid_t UID, gid_t GID, off_t Size)\n      : fs_st_atime(ATime), fs_st_mtime(MTime),\n        fs_st_atime_nsec(ATimeNSec), fs_st_mtime_nsec(MTimeNSec),\n        fs_st_uid(UID), fs_st_gid(GID),\n        fs_st_size(Size), Type(Type), Perms(Perms) {}\n#elif defined(_WIN32)\n  basic_file_status(file_type Type, perms Perms, uint32_t LastAccessTimeHigh,\n                    uint32_t LastAccessTimeLow, uint32_t LastWriteTimeHigh,\n                    uint32_t LastWriteTimeLow, uint32_t FileSizeHigh,\n                    uint32_t FileSizeLow)\n      : LastAccessedTimeHigh(LastAccessTimeHigh),\n        LastAccessedTimeLow(LastAccessTimeLow),\n        LastWriteTimeHigh(LastWriteTimeHigh),\n        LastWriteTimeLow(LastWriteTimeLow), FileSizeHigh(FileSizeHigh),\n        FileSizeLow(FileSizeLow), Type(Type), Perms(Perms) {}\n  #endif\n\n  // getters\n  file_type type() const { return Type; }\n  perms permissions() const { return Perms; }\n\n  /// The file access time as reported from the underlying file system.\n  ///\n  /// Also see comments on \\c getLastModificationTime() related to the precision\n  /// of the returned value.\n  TimePoint<> getLastAccessedTime() const;\n\n  /// The file modification time as reported from the underlying file system.\n  ///\n  /// The returned value allows for nanosecond precision but the actual\n  /// resolution is an implementation detail of the underlying file system.\n  /// There is no guarantee for what kind of resolution you can expect, the\n  /// resolution can differ across platforms and even across mountpoints on the\n  /// same machine.\n  TimePoint<> getLastModificationTime() const;\n\n  #if defined(LLVM_ON_UNIX)\n  uint32_t getUser() const { return fs_st_uid; }\n  uint32_t getGroup() const { return fs_st_gid; }\n  uint64_t getSize() const { return fs_st_size; }\n  #elif defined (_WIN32)\n  uint32_t getUser() const {\n    return 9999; // Not applicable to Windows, so...\n  }\n\n  uint32_t getGroup() const {\n    return 9999; // Not applicable to Windows, so...\n  }\n\n  uint64_t getSize() const {\n    return (uint64_t(FileSizeHigh) << 32) + FileSizeLow;\n  }\n  #endif\n\n  // setters\n  void type(file_type v) { Type = v; }\n  void permissions(perms p) { Perms = p; }\n};\n\n/// Represents the result of a call to sys::fs::status().\nclass file_status : public basic_file_status {\n  friend bool equivalent(file_status A, file_status B);\n\n  #if defined(LLVM_ON_UNIX)\n  dev_t fs_st_dev = 0;\n  nlink_t fs_st_nlinks = 0;\n  ino_t fs_st_ino = 0;\n  #elif defined (_WIN32)\n  uint32_t NumLinks = 0;\n  uint32_t VolumeSerialNumber = 0;\n  uint32_t FileIndexHigh = 0;\n  uint32_t FileIndexLow = 0;\n  #endif\n\npublic:\n  file_status() = default;\n\n  explicit file_status(file_type Type) : basic_file_status(Type) {}\n\n  #if defined(LLVM_ON_UNIX)\n  file_status(file_type Type, perms Perms, dev_t Dev, nlink_t Links, ino_t Ino,\n              time_t ATime, uint32_t ATimeNSec,\n              time_t MTime, uint32_t MTimeNSec,\n              uid_t UID, gid_t GID, off_t Size)\n      : basic_file_status(Type, Perms, ATime, ATimeNSec, MTime, MTimeNSec,\n                          UID, GID, Size),\n        fs_st_dev(Dev), fs_st_nlinks(Links), fs_st_ino(Ino) {}\n  #elif defined(_WIN32)\n  file_status(file_type Type, perms Perms, uint32_t LinkCount,\n              uint32_t LastAccessTimeHigh, uint32_t LastAccessTimeLow,\n              uint32_t LastWriteTimeHigh, uint32_t LastWriteTimeLow,\n              uint32_t VolumeSerialNumber, uint32_t FileSizeHigh,\n              uint32_t FileSizeLow, uint32_t FileIndexHigh,\n              uint32_t FileIndexLow)\n      : basic_file_status(Type, Perms, LastAccessTimeHigh, LastAccessTimeLow,\n                          LastWriteTimeHigh, LastWriteTimeLow, FileSizeHigh,\n                          FileSizeLow),\n        NumLinks(LinkCount), VolumeSerialNumber(VolumeSerialNumber),\n        FileIndexHigh(FileIndexHigh), FileIndexLow(FileIndexLow) {}\n  #endif\n\n  UniqueID getUniqueID() const;\n  uint32_t getLinkCount() const;\n};\n\n/// @}\n/// @name Physical Operators\n/// @{\n\n/// Make \\a path an absolute path.\n///\n/// Makes \\a path absolute using the \\a current_directory if it is not already.\n/// An empty \\a path will result in the \\a current_directory.\n///\n/// /absolute/path   => /absolute/path\n/// relative/../path => <current-directory>/relative/../path\n///\n/// @param path A path that is modified to be an absolute path.\nvoid make_absolute(const Twine &current_directory, SmallVectorImpl<char> &path);\n\n/// Make \\a path an absolute path.\n///\n/// Makes \\a path absolute using the current directory if it is not already. An\n/// empty \\a path will result in the current directory.\n///\n/// /absolute/path   => /absolute/path\n/// relative/../path => <current-directory>/relative/../path\n///\n/// @param path A path that is modified to be an absolute path.\n/// @returns errc::success if \\a path has been made absolute, otherwise a\n///          platform-specific error_code.\nstd::error_code make_absolute(SmallVectorImpl<char> &path);\n\n/// Create all the non-existent directories in path.\n///\n/// @param path Directories to create.\n/// @returns errc::success if is_directory(path), otherwise a platform\n///          specific error_code. If IgnoreExisting is false, also returns\n///          error if the directory already existed.\nstd::error_code create_directories(const Twine &path,\n                                   bool IgnoreExisting = true,\n                                   perms Perms = owner_all | group_all);\n\n/// Create the directory in path.\n///\n/// @param path Directory to create.\n/// @returns errc::success if is_directory(path), otherwise a platform\n///          specific error_code. If IgnoreExisting is false, also returns\n///          error if the directory already existed.\nstd::error_code create_directory(const Twine &path, bool IgnoreExisting = true,\n                                 perms Perms = owner_all | group_all);\n\n/// Create a link from \\a from to \\a to.\n///\n/// The link may be a soft or a hard link, depending on the platform. The caller\n/// may not assume which one. Currently on windows it creates a hard link since\n/// soft links require extra privileges. On unix, it creates a soft link since\n/// hard links don't work on SMB file systems.\n///\n/// @param to The path to hard link to.\n/// @param from The path to hard link from. This is created.\n/// @returns errc::success if the link was created, otherwise a platform\n/// specific error_code.\nstd::error_code create_link(const Twine &to, const Twine &from);\n\n/// Create a hard link from \\a from to \\a to, or return an error.\n///\n/// @param to The path to hard link to.\n/// @param from The path to hard link from. This is created.\n/// @returns errc::success if the link was created, otherwise a platform\n/// specific error_code.\nstd::error_code create_hard_link(const Twine &to, const Twine &from);\n\n/// Collapse all . and .. patterns, resolve all symlinks, and optionally\n///        expand ~ expressions to the user's home directory.\n///\n/// @param path The path to resolve.\n/// @param output The location to store the resolved path.\n/// @param expand_tilde If true, resolves ~ expressions to the user's home\n///                     directory.\nstd::error_code real_path(const Twine &path, SmallVectorImpl<char> &output,\n                          bool expand_tilde = false);\n\n/// Expands ~ expressions to the user's home directory. On Unix ~user\n/// directories are resolved as well.\n///\n/// @param path The path to resolve.\nvoid expand_tilde(const Twine &path, SmallVectorImpl<char> &output);\n\n/// Get the current path.\n///\n/// @param result Holds the current path on return.\n/// @returns errc::success if the current path has been stored in result,\n///          otherwise a platform-specific error_code.\nstd::error_code current_path(SmallVectorImpl<char> &result);\n\n/// Set the current path.\n///\n/// @param path The path to set.\n/// @returns errc::success if the current path was successfully set,\n///          otherwise a platform-specific error_code.\nstd::error_code set_current_path(const Twine &path);\n\n/// Remove path. Equivalent to POSIX remove().\n///\n/// @param path Input path.\n/// @returns errc::success if path has been removed or didn't exist, otherwise a\n///          platform-specific error code. If IgnoreNonExisting is false, also\n///          returns error if the file didn't exist.\nstd::error_code remove(const Twine &path, bool IgnoreNonExisting = true);\n\n/// Recursively delete a directory.\n///\n/// @param path Input path.\n/// @returns errc::success if path has been removed or didn't exist, otherwise a\n///          platform-specific error code.\nstd::error_code remove_directories(const Twine &path, bool IgnoreErrors = true);\n\n/// Rename \\a from to \\a to.\n///\n/// Files are renamed as if by POSIX rename(), except that on Windows there may\n/// be a short interval of time during which the destination file does not\n/// exist.\n///\n/// @param from The path to rename from.\n/// @param to The path to rename to. This is created.\nstd::error_code rename(const Twine &from, const Twine &to);\n\n/// Copy the contents of \\a From to \\a To.\n///\n/// @param From The path to copy from.\n/// @param To The path to copy to. This is created.\nstd::error_code copy_file(const Twine &From, const Twine &To);\n\n/// Copy the contents of \\a From to \\a To.\n///\n/// @param From The path to copy from.\n/// @param ToFD The open file descriptor of the destination file.\nstd::error_code copy_file(const Twine &From, int ToFD);\n\n/// Resize path to size. File is resized as if by POSIX truncate().\n///\n/// @param FD Input file descriptor.\n/// @param Size Size to resize to.\n/// @returns errc::success if \\a path has been resized to \\a size, otherwise a\n///          platform-specific error_code.\nstd::error_code resize_file(int FD, uint64_t Size);\n\n/// Compute an MD5 hash of a file's contents.\n///\n/// @param FD Input file descriptor.\n/// @returns An MD5Result with the hash computed, if successful, otherwise a\n///          std::error_code.\nErrorOr<MD5::MD5Result> md5_contents(int FD);\n\n/// Version of compute_md5 that doesn't require an open file descriptor.\nErrorOr<MD5::MD5Result> md5_contents(const Twine &Path);\n\n/// @}\n/// @name Physical Observers\n/// @{\n\n/// Does file exist?\n///\n/// @param status A basic_file_status previously returned from stat.\n/// @returns True if the file represented by status exists, false if it does\n///          not.\nbool exists(const basic_file_status &status);\n\nenum class AccessMode { Exist, Write, Execute };\n\n/// Can the file be accessed?\n///\n/// @param Path Input path.\n/// @returns errc::success if the path can be accessed, otherwise a\n///          platform-specific error_code.\nstd::error_code access(const Twine &Path, AccessMode Mode);\n\n/// Does file exist?\n///\n/// @param Path Input path.\n/// @returns True if it exists, false otherwise.\ninline bool exists(const Twine &Path) {\n  return !access(Path, AccessMode::Exist);\n}\n\n/// Can we execute this file?\n///\n/// @param Path Input path.\n/// @returns True if we can execute it, false otherwise.\nbool can_execute(const Twine &Path);\n\n/// Can we write this file?\n///\n/// @param Path Input path.\n/// @returns True if we can write to it, false otherwise.\ninline bool can_write(const Twine &Path) {\n  return !access(Path, AccessMode::Write);\n}\n\n/// Do file_status's represent the same thing?\n///\n/// @param A Input file_status.\n/// @param B Input file_status.\n///\n/// assert(status_known(A) || status_known(B));\n///\n/// @returns True if A and B both represent the same file system entity, false\n///          otherwise.\nbool equivalent(file_status A, file_status B);\n\n/// Do paths represent the same thing?\n///\n/// assert(status_known(A) || status_known(B));\n///\n/// @param A Input path A.\n/// @param B Input path B.\n/// @param result Set to true if stat(A) and stat(B) have the same device and\n///               inode (or equivalent).\n/// @returns errc::success if result has been successfully set, otherwise a\n///          platform-specific error_code.\nstd::error_code equivalent(const Twine &A, const Twine &B, bool &result);\n\n/// Simpler version of equivalent for clients that don't need to\n///        differentiate between an error and false.\ninline bool equivalent(const Twine &A, const Twine &B) {\n  bool result;\n  return !equivalent(A, B, result) && result;\n}\n\n/// Is the file mounted on a local filesystem?\n///\n/// @param path Input path.\n/// @param result Set to true if \\a path is on fixed media such as a hard disk,\n///               false if it is not.\n/// @returns errc::success if result has been successfully set, otherwise a\n///          platform specific error_code.\nstd::error_code is_local(const Twine &path, bool &result);\n\n/// Version of is_local accepting an open file descriptor.\nstd::error_code is_local(int FD, bool &result);\n\n/// Simpler version of is_local for clients that don't need to\n///        differentiate between an error and false.\ninline bool is_local(const Twine &Path) {\n  bool Result;\n  return !is_local(Path, Result) && Result;\n}\n\n/// Simpler version of is_local accepting an open file descriptor for\n///        clients that don't need to differentiate between an error and false.\ninline bool is_local(int FD) {\n  bool Result;\n  return !is_local(FD, Result) && Result;\n}\n\n/// Does status represent a directory?\n///\n/// @param Path The path to get the type of.\n/// @param Follow For symbolic links, indicates whether to return the file type\n///               of the link itself, or of the target.\n/// @returns A value from the file_type enumeration indicating the type of file.\nfile_type get_file_type(const Twine &Path, bool Follow = true);\n\n/// Does status represent a directory?\n///\n/// @param status A basic_file_status previously returned from status.\n/// @returns status.type() == file_type::directory_file.\nbool is_directory(const basic_file_status &status);\n\n/// Is path a directory?\n///\n/// @param path Input path.\n/// @param result Set to true if \\a path is a directory (after following\n///               symlinks, false if it is not. Undefined otherwise.\n/// @returns errc::success if result has been successfully set, otherwise a\n///          platform-specific error_code.\nstd::error_code is_directory(const Twine &path, bool &result);\n\n/// Simpler version of is_directory for clients that don't need to\n///        differentiate between an error and false.\ninline bool is_directory(const Twine &Path) {\n  bool Result;\n  return !is_directory(Path, Result) && Result;\n}\n\n/// Does status represent a regular file?\n///\n/// @param status A basic_file_status previously returned from status.\n/// @returns status_known(status) && status.type() == file_type::regular_file.\nbool is_regular_file(const basic_file_status &status);\n\n/// Is path a regular file?\n///\n/// @param path Input path.\n/// @param result Set to true if \\a path is a regular file (after following\n///               symlinks), false if it is not. Undefined otherwise.\n/// @returns errc::success if result has been successfully set, otherwise a\n///          platform-specific error_code.\nstd::error_code is_regular_file(const Twine &path, bool &result);\n\n/// Simpler version of is_regular_file for clients that don't need to\n///        differentiate between an error and false.\ninline bool is_regular_file(const Twine &Path) {\n  bool Result;\n  if (is_regular_file(Path, Result))\n    return false;\n  return Result;\n}\n\n/// Does status represent a symlink file?\n///\n/// @param status A basic_file_status previously returned from status.\n/// @returns status_known(status) && status.type() == file_type::symlink_file.\nbool is_symlink_file(const basic_file_status &status);\n\n/// Is path a symlink file?\n///\n/// @param path Input path.\n/// @param result Set to true if \\a path is a symlink file, false if it is not.\n///               Undefined otherwise.\n/// @returns errc::success if result has been successfully set, otherwise a\n///          platform-specific error_code.\nstd::error_code is_symlink_file(const Twine &path, bool &result);\n\n/// Simpler version of is_symlink_file for clients that don't need to\n///        differentiate between an error and false.\ninline bool is_symlink_file(const Twine &Path) {\n  bool Result;\n  if (is_symlink_file(Path, Result))\n    return false;\n  return Result;\n}\n\n/// Does this status represent something that exists but is not a\n///        directory or regular file?\n///\n/// @param status A basic_file_status previously returned from status.\n/// @returns exists(s) && !is_regular_file(s) && !is_directory(s)\nbool is_other(const basic_file_status &status);\n\n/// Is path something that exists but is not a directory,\n///        regular file, or symlink?\n///\n/// @param path Input path.\n/// @param result Set to true if \\a path exists, but is not a directory, regular\n///               file, or a symlink, false if it does not. Undefined otherwise.\n/// @returns errc::success if result has been successfully set, otherwise a\n///          platform-specific error_code.\nstd::error_code is_other(const Twine &path, bool &result);\n\n/// Get file status as if by POSIX stat().\n///\n/// @param path Input path.\n/// @param result Set to the file status.\n/// @param follow When true, follows symlinks.  Otherwise, the symlink itself is\n///               statted.\n/// @returns errc::success if result has been successfully set, otherwise a\n///          platform-specific error_code.\nstd::error_code status(const Twine &path, file_status &result,\n                       bool follow = true);\n\n/// A version for when a file descriptor is already available.\nstd::error_code status(int FD, file_status &Result);\n\n#ifdef _WIN32\n/// A version for when a file descriptor is already available.\nstd::error_code status(file_t FD, file_status &Result);\n#endif\n\n/// Get file creation mode mask of the process.\n///\n/// @returns Mask reported by umask(2)\n/// @note There is no umask on Windows. This function returns 0 always\n///       on Windows. This function does not return an error_code because\n///       umask(2) never fails. It is not thread safe.\nunsigned getUmask();\n\n/// Set file permissions.\n///\n/// @param Path File to set permissions on.\n/// @param Permissions New file permissions.\n/// @returns errc::success if the permissions were successfully set, otherwise\n///          a platform-specific error_code.\n/// @note On Windows, all permissions except *_write are ignored. Using any of\n///       owner_write, group_write, or all_write will make the file writable.\n///       Otherwise, the file will be marked as read-only.\nstd::error_code setPermissions(const Twine &Path, perms Permissions);\n\n/// Vesion of setPermissions accepting a file descriptor.\n/// TODO Delete the path based overload once we implement the FD based overload\n/// on Windows.\nstd::error_code setPermissions(int FD, perms Permissions);\n\n/// Get file permissions.\n///\n/// @param Path File to get permissions from.\n/// @returns the permissions if they were successfully retrieved, otherwise a\n///          platform-specific error_code.\n/// @note On Windows, if the file does not have the FILE_ATTRIBUTE_READONLY\n///       attribute, all_all will be returned. Otherwise, all_read | all_exe\n///       will be returned.\nErrorOr<perms> getPermissions(const Twine &Path);\n\n/// Get file size.\n///\n/// @param Path Input path.\n/// @param Result Set to the size of the file in \\a Path.\n/// @returns errc::success if result has been successfully set, otherwise a\n///          platform-specific error_code.\ninline std::error_code file_size(const Twine &Path, uint64_t &Result) {\n  file_status Status;\n  std::error_code EC = status(Path, Status);\n  if (EC)\n    return EC;\n  Result = Status.getSize();\n  return std::error_code();\n}\n\n/// Set the file modification and access time.\n///\n/// @returns errc::success if the file times were successfully set, otherwise a\n///          platform-specific error_code or errc::function_not_supported on\n///          platforms where the functionality isn't available.\nstd::error_code setLastAccessAndModificationTime(int FD, TimePoint<> AccessTime,\n                                                 TimePoint<> ModificationTime);\n\n/// Simpler version that sets both file modification and access time to the same\n/// time.\ninline std::error_code setLastAccessAndModificationTime(int FD,\n                                                        TimePoint<> Time) {\n  return setLastAccessAndModificationTime(FD, Time, Time);\n}\n\n/// Is status available?\n///\n/// @param s Input file status.\n/// @returns True if status() != status_error.\nbool status_known(const basic_file_status &s);\n\n/// Is status available?\n///\n/// @param path Input path.\n/// @param result Set to true if status() != status_error.\n/// @returns errc::success if result has been successfully set, otherwise a\n///          platform-specific error_code.\nstd::error_code status_known(const Twine &path, bool &result);\n\nenum CreationDisposition : unsigned {\n  /// CD_CreateAlways - When opening a file:\n  ///   * If it already exists, truncate it.\n  ///   * If it does not already exist, create a new file.\n  CD_CreateAlways = 0,\n\n  /// CD_CreateNew - When opening a file:\n  ///   * If it already exists, fail.\n  ///   * If it does not already exist, create a new file.\n  CD_CreateNew = 1,\n\n  /// CD_OpenExisting - When opening a file:\n  ///   * If it already exists, open the file with the offset set to 0.\n  ///   * If it does not already exist, fail.\n  CD_OpenExisting = 2,\n\n  /// CD_OpenAlways - When opening a file:\n  ///   * If it already exists, open the file with the offset set to 0.\n  ///   * If it does not already exist, create a new file.\n  CD_OpenAlways = 3,\n};\n\nenum FileAccess : unsigned {\n  FA_Read = 1,\n  FA_Write = 2,\n};\n\nenum OpenFlags : unsigned {\n  OF_None = 0,\n  F_None = 0, // For compatibility\n\n  /// The file should be opened in text mode on platforms that make this\n  /// distinction.\n  OF_Text = 1,\n  F_Text = 1, // For compatibility\n\n  /// The file should be opened in append mode.\n  OF_Append = 2,\n  F_Append = 2, // For compatibility\n\n  /// Delete the file on close. Only makes a difference on windows.\n  OF_Delete = 4,\n\n  /// When a child process is launched, this file should remain open in the\n  /// child process.\n  OF_ChildInherit = 8,\n\n  /// Force files Atime to be updated on access. Only makes a difference on windows.\n  OF_UpdateAtime = 16,\n};\n\n/// Create a potentially unique file name but does not create it.\n///\n/// Generates a unique path suitable for a temporary file but does not\n/// open or create the file. The name is based on \\a Model with '%'\n/// replaced by a random char in [0-9a-f]. If \\a MakeAbsolute is true\n/// then the system's temp directory is prepended first. If \\a MakeAbsolute\n/// is false the current directory will be used instead.\n///\n/// This function does not check if the file exists. If you want to be sure\n/// that the file does not yet exist, you should use use enough '%' characters\n/// in your model to ensure this. Each '%' gives 4-bits of entropy so you can\n/// use 32 of them to get 128 bits of entropy.\n///\n/// Example: clang-%%-%%-%%-%%-%%.s => clang-a0-b1-c2-d3-e4.s\n///\n/// @param Model Name to base unique path off of.\n/// @param ResultPath Set to the file's path.\n/// @param MakeAbsolute Whether to use the system temp directory.\nvoid createUniquePath(const Twine &Model, SmallVectorImpl<char> &ResultPath,\n                      bool MakeAbsolute);\n\n/// Create a uniquely named file.\n///\n/// Generates a unique path suitable for a temporary file and then opens it as a\n/// file. The name is based on \\a Model with '%' replaced by a random char in\n/// [0-9a-f]. If \\a Model is not an absolute path, the temporary file will be\n/// created in the current directory.\n///\n/// Example: clang-%%-%%-%%-%%-%%.s => clang-a0-b1-c2-d3-e4.s\n///\n/// This is an atomic operation. Either the file is created and opened, or the\n/// file system is left untouched.\n///\n/// The intended use is for files that are to be kept, possibly after\n/// renaming them. For example, when running 'clang -c foo.o', the file can\n/// be first created as foo-abc123.o and then renamed.\n///\n/// @param Model Name to base unique path off of.\n/// @param ResultFD Set to the opened file's file descriptor.\n/// @param ResultPath Set to the opened file's absolute path.\n/// @returns errc::success if Result{FD,Path} have been successfully set,\n///          otherwise a platform-specific error_code.\nstd::error_code createUniqueFile(const Twine &Model, int &ResultFD,\n                                 SmallVectorImpl<char> &ResultPath,\n                                 unsigned Mode = all_read | all_write);\n\n/// Simpler version for clients that don't want an open file. An empty\n/// file will still be created.\nstd::error_code createUniqueFile(const Twine &Model,\n                                 SmallVectorImpl<char> &ResultPath,\n                                 unsigned Mode = all_read | all_write);\n\n/// Represents a temporary file.\n///\n/// The temporary file must be eventually discarded or given a final name and\n/// kept.\n///\n/// The destructor doesn't implicitly discard because there is no way to\n/// properly handle errors in a destructor.\nclass TempFile {\n  bool Done = false;\n  TempFile(StringRef Name, int FD);\n\npublic:\n  /// This creates a temporary file with createUniqueFile and schedules it for\n  /// deletion with sys::RemoveFileOnSignal.\n  static Expected<TempFile> create(const Twine &Model,\n                                   unsigned Mode = all_read | all_write);\n  TempFile(TempFile &&Other);\n  TempFile &operator=(TempFile &&Other);\n\n  // Name of the temporary file.\n  std::string TmpName;\n\n  // The open file descriptor.\n  int FD = -1;\n\n  // Keep this with the given name.\n  Error keep(const Twine &Name);\n\n  // Keep this with the temporary name.\n  Error keep();\n\n  // Delete the file.\n  Error discard();\n\n  // This checks that keep or delete was called.\n  ~TempFile();\n};\n\n/// Create a file in the system temporary directory.\n///\n/// The filename is of the form prefix-random_chars.suffix. Since the directory\n/// is not know to the caller, Prefix and Suffix cannot have path separators.\n/// The files are created with mode 0600.\n///\n/// This should be used for things like a temporary .s that is removed after\n/// running the assembler.\nstd::error_code createTemporaryFile(const Twine &Prefix, StringRef Suffix,\n                                    int &ResultFD,\n                                    SmallVectorImpl<char> &ResultPath);\n\n/// Simpler version for clients that don't want an open file. An empty\n/// file will still be created.\nstd::error_code createTemporaryFile(const Twine &Prefix, StringRef Suffix,\n                                    SmallVectorImpl<char> &ResultPath);\n\nstd::error_code createUniqueDirectory(const Twine &Prefix,\n                                      SmallVectorImpl<char> &ResultPath);\n\n/// Get a unique name, not currently exisiting in the filesystem. Subject\n/// to race conditions, prefer to use createUniqueFile instead.\n///\n/// Similar to createUniqueFile, but instead of creating a file only\n/// checks if it exists. This function is subject to race conditions, if you\n/// want to use the returned name to actually create a file, use\n/// createUniqueFile instead.\nstd::error_code getPotentiallyUniqueFileName(const Twine &Model,\n                                             SmallVectorImpl<char> &ResultPath);\n\n/// Get a unique temporary file name, not currently exisiting in the\n/// filesystem. Subject to race conditions, prefer to use createTemporaryFile\n/// instead.\n///\n/// Similar to createTemporaryFile, but instead of creating a file only\n/// checks if it exists. This function is subject to race conditions, if you\n/// want to use the returned name to actually create a file, use\n/// createTemporaryFile instead.\nstd::error_code\ngetPotentiallyUniqueTempFileName(const Twine &Prefix, StringRef Suffix,\n                                 SmallVectorImpl<char> &ResultPath);\n\ninline OpenFlags operator|(OpenFlags A, OpenFlags B) {\n  return OpenFlags(unsigned(A) | unsigned(B));\n}\n\ninline OpenFlags &operator|=(OpenFlags &A, OpenFlags B) {\n  A = A | B;\n  return A;\n}\n\ninline FileAccess operator|(FileAccess A, FileAccess B) {\n  return FileAccess(unsigned(A) | unsigned(B));\n}\n\ninline FileAccess &operator|=(FileAccess &A, FileAccess B) {\n  A = A | B;\n  return A;\n}\n\n/// @brief Opens a file with the specified creation disposition, access mode,\n/// and flags and returns a file descriptor.\n///\n/// The caller is responsible for closing the file descriptor once they are\n/// finished with it.\n///\n/// @param Name The path of the file to open, relative or absolute.\n/// @param ResultFD If the file could be opened successfully, its descriptor\n///                 is stored in this location. Otherwise, this is set to -1.\n/// @param Disp Value specifying the existing-file behavior.\n/// @param Access Value specifying whether to open the file in read, write, or\n///               read-write mode.\n/// @param Flags Additional flags.\n/// @param Mode The access permissions of the file, represented in octal.\n/// @returns errc::success if \\a Name has been opened, otherwise a\n///          platform-specific error_code.\nstd::error_code openFile(const Twine &Name, int &ResultFD,\n                         CreationDisposition Disp, FileAccess Access,\n                         OpenFlags Flags, unsigned Mode = 0666);\n\n/// @brief Opens a file with the specified creation disposition, access mode,\n/// and flags and returns a platform-specific file object.\n///\n/// The caller is responsible for closing the file object once they are\n/// finished with it.\n///\n/// @param Name The path of the file to open, relative or absolute.\n/// @param Disp Value specifying the existing-file behavior.\n/// @param Access Value specifying whether to open the file in read, write, or\n///               read-write mode.\n/// @param Flags Additional flags.\n/// @param Mode The access permissions of the file, represented in octal.\n/// @returns errc::success if \\a Name has been opened, otherwise a\n///          platform-specific error_code.\nExpected<file_t> openNativeFile(const Twine &Name, CreationDisposition Disp,\n                                FileAccess Access, OpenFlags Flags,\n                                unsigned Mode = 0666);\n\n/// Converts from a Posix file descriptor number to a native file handle.\n/// On Windows, this retreives the underlying handle. On non-Windows, this is a\n/// no-op.\nfile_t convertFDToNativeFile(int FD);\n\n#ifndef _WIN32\ninline file_t convertFDToNativeFile(int FD) { return FD; }\n#endif\n\n/// Return an open handle to standard in. On Unix, this is typically FD 0.\n/// Returns kInvalidFile when the stream is closed.\nfile_t getStdinHandle();\n\n/// Return an open handle to standard out. On Unix, this is typically FD 1.\n/// Returns kInvalidFile when the stream is closed.\nfile_t getStdoutHandle();\n\n/// Return an open handle to standard error. On Unix, this is typically FD 2.\n/// Returns kInvalidFile when the stream is closed.\nfile_t getStderrHandle();\n\n/// Reads \\p Buf.size() bytes from \\p FileHandle into \\p Buf. Returns the number\n/// of bytes actually read. On Unix, this is equivalent to `return ::read(FD,\n/// Buf.data(), Buf.size())`, with error reporting. Returns 0 when reaching EOF.\n///\n/// @param FileHandle File to read from.\n/// @param Buf Buffer to read into.\n/// @returns The number of bytes read, or error.\nExpected<size_t> readNativeFile(file_t FileHandle, MutableArrayRef<char> Buf);\n\n/// Reads \\p Buf.size() bytes from \\p FileHandle at offset \\p Offset into \\p\n/// Buf. If 'pread' is available, this will use that, otherwise it will use\n/// 'lseek'. Returns the number of bytes actually read. Returns 0 when reaching\n/// EOF.\n///\n/// @param FileHandle File to read from.\n/// @param Buf Buffer to read into.\n/// @param Offset Offset into the file at which the read should occur.\n/// @returns The number of bytes read, or error.\nExpected<size_t> readNativeFileSlice(file_t FileHandle,\n                                     MutableArrayRef<char> Buf,\n                                     uint64_t Offset);\n\n/// @brief Opens the file with the given name in a write-only or read-write\n/// mode, returning its open file descriptor. If the file does not exist, it\n/// is created.\n///\n/// The caller is responsible for closing the file descriptor once they are\n/// finished with it.\n///\n/// @param Name The path of the file to open, relative or absolute.\n/// @param ResultFD If the file could be opened successfully, its descriptor\n///                 is stored in this location. Otherwise, this is set to -1.\n/// @param Flags Additional flags used to determine whether the file should be\n///              opened in, for example, read-write or in write-only mode.\n/// @param Mode The access permissions of the file, represented in octal.\n/// @returns errc::success if \\a Name has been opened, otherwise a\n///          platform-specific error_code.\ninline std::error_code\nopenFileForWrite(const Twine &Name, int &ResultFD,\n                 CreationDisposition Disp = CD_CreateAlways,\n                 OpenFlags Flags = OF_None, unsigned Mode = 0666) {\n  return openFile(Name, ResultFD, Disp, FA_Write, Flags, Mode);\n}\n\n/// @brief Opens the file with the given name in a write-only or read-write\n/// mode, returning its open file descriptor. If the file does not exist, it\n/// is created.\n///\n/// The caller is responsible for closing the freeing the file once they are\n/// finished with it.\n///\n/// @param Name The path of the file to open, relative or absolute.\n/// @param Flags Additional flags used to determine whether the file should be\n///              opened in, for example, read-write or in write-only mode.\n/// @param Mode The access permissions of the file, represented in octal.\n/// @returns a platform-specific file descriptor if \\a Name has been opened,\n///          otherwise an error object.\ninline Expected<file_t> openNativeFileForWrite(const Twine &Name,\n                                               CreationDisposition Disp,\n                                               OpenFlags Flags,\n                                               unsigned Mode = 0666) {\n  return openNativeFile(Name, Disp, FA_Write, Flags, Mode);\n}\n\n/// @brief Opens the file with the given name in a write-only or read-write\n/// mode, returning its open file descriptor. If the file does not exist, it\n/// is created.\n///\n/// The caller is responsible for closing the file descriptor once they are\n/// finished with it.\n///\n/// @param Name The path of the file to open, relative or absolute.\n/// @param ResultFD If the file could be opened successfully, its descriptor\n///                 is stored in this location. Otherwise, this is set to -1.\n/// @param Flags Additional flags used to determine whether the file should be\n///              opened in, for example, read-write or in write-only mode.\n/// @param Mode The access permissions of the file, represented in octal.\n/// @returns errc::success if \\a Name has been opened, otherwise a\n///          platform-specific error_code.\ninline std::error_code openFileForReadWrite(const Twine &Name, int &ResultFD,\n                                            CreationDisposition Disp,\n                                            OpenFlags Flags,\n                                            unsigned Mode = 0666) {\n  return openFile(Name, ResultFD, Disp, FA_Write | FA_Read, Flags, Mode);\n}\n\n/// @brief Opens the file with the given name in a write-only or read-write\n/// mode, returning its open file descriptor. If the file does not exist, it\n/// is created.\n///\n/// The caller is responsible for closing the freeing the file once they are\n/// finished with it.\n///\n/// @param Name The path of the file to open, relative or absolute.\n/// @param Flags Additional flags used to determine whether the file should be\n///              opened in, for example, read-write or in write-only mode.\n/// @param Mode The access permissions of the file, represented in octal.\n/// @returns a platform-specific file descriptor if \\a Name has been opened,\n///          otherwise an error object.\ninline Expected<file_t> openNativeFileForReadWrite(const Twine &Name,\n                                                   CreationDisposition Disp,\n                                                   OpenFlags Flags,\n                                                   unsigned Mode = 0666) {\n  return openNativeFile(Name, Disp, FA_Write | FA_Read, Flags, Mode);\n}\n\n/// @brief Opens the file with the given name in a read-only mode, returning\n/// its open file descriptor.\n///\n/// The caller is responsible for closing the file descriptor once they are\n/// finished with it.\n///\n/// @param Name The path of the file to open, relative or absolute.\n/// @param ResultFD If the file could be opened successfully, its descriptor\n///                 is stored in this location. Otherwise, this is set to -1.\n/// @param RealPath If nonnull, extra work is done to determine the real path\n///                 of the opened file, and that path is stored in this\n///                 location.\n/// @returns errc::success if \\a Name has been opened, otherwise a\n///          platform-specific error_code.\nstd::error_code openFileForRead(const Twine &Name, int &ResultFD,\n                                OpenFlags Flags = OF_None,\n                                SmallVectorImpl<char> *RealPath = nullptr);\n\n/// @brief Opens the file with the given name in a read-only mode, returning\n/// its open file descriptor.\n///\n/// The caller is responsible for closing the freeing the file once they are\n/// finished with it.\n///\n/// @param Name The path of the file to open, relative or absolute.\n/// @param RealPath If nonnull, extra work is done to determine the real path\n///                 of the opened file, and that path is stored in this\n///                 location.\n/// @returns a platform-specific file descriptor if \\a Name has been opened,\n///          otherwise an error object.\nExpected<file_t>\nopenNativeFileForRead(const Twine &Name, OpenFlags Flags = OF_None,\n                      SmallVectorImpl<char> *RealPath = nullptr);\n\n/// Try to locks the file during the specified time.\n///\n/// This function implements advisory locking on entire file. If it returns\n/// <em>errc::success</em>, the file is locked by the calling process. Until the\n/// process unlocks the file by calling \\a unlockFile, all attempts to lock the\n/// same file will fail/block. The process that locked the file may assume that\n/// none of other processes read or write this file, provided that all processes\n/// lock the file prior to accessing its content.\n///\n/// @param FD      The descriptor representing the file to lock.\n/// @param Timeout Time in milliseconds that the process should wait before\n///                reporting lock failure. Zero value means try to get lock only\n///                once.\n/// @returns errc::success if lock is successfully obtained,\n/// errc::no_lock_available if the file cannot be locked, or platform-specific\n/// error_code otherwise.\n///\n/// @note Care should be taken when using this function in a multithreaded\n/// context, as it may not prevent other threads in the same process from\n/// obtaining a lock on the same file, even if they are using a different file\n/// descriptor.\nstd::error_code\ntryLockFile(int FD,\n            std::chrono::milliseconds Timeout = std::chrono::milliseconds(0));\n\n/// Lock the file.\n///\n/// This function acts as @ref tryLockFile but it waits infinitely.\nstd::error_code lockFile(int FD);\n\n/// Unlock the file.\n///\n/// @param FD The descriptor representing the file to unlock.\n/// @returns errc::success if lock is successfully released or platform-specific\n/// error_code otherwise.\nstd::error_code unlockFile(int FD);\n\n/// @brief Close the file object.  This should be used instead of ::close for\n/// portability. On error, the caller should assume the file is closed, as is\n/// the case for Process::SafelyCloseFileDescriptor\n///\n/// @param F On input, this is the file to close.  On output, the file is\n/// set to kInvalidFile.\n///\n/// @returns An error code if closing the file failed. Typically, an error here\n/// means that the filesystem may have failed to perform some buffered writes.\nstd::error_code closeFile(file_t &F);\n\n#ifdef LLVM_ON_UNIX\n/// @brief Change ownership of a file.\n///\n/// @param Owner The owner of the file to change to.\n/// @param Group The group of the file to change to.\n/// @returns errc::success if successfully updated file ownership, otherwise an\n///          error code is returned.\nstd::error_code changeFileOwnership(int FD, uint32_t Owner, uint32_t Group);\n#endif\n\n/// RAII class that facilitates file locking.\nclass FileLocker {\n  int FD; ///< Locked file handle.\n  FileLocker(int FD) : FD(FD) {}\n  friend class llvm::raw_fd_ostream;\n\npublic:\n  FileLocker(const FileLocker &L) = delete;\n  FileLocker(FileLocker &&L) : FD(L.FD) { L.FD = -1; }\n  ~FileLocker() {\n    if (FD != -1)\n      unlockFile(FD);\n  }\n  FileLocker &operator=(FileLocker &&L) {\n    FD = L.FD;\n    L.FD = -1;\n    return *this;\n  }\n  FileLocker &operator=(const FileLocker &L) = delete;\n  std::error_code unlock() {\n    if (FD != -1) {\n      std::error_code Result = unlockFile(FD);\n      FD = -1;\n      return Result;\n    }\n    return std::error_code();\n  }\n};\n\nstd::error_code getUniqueID(const Twine Path, UniqueID &Result);\n\n/// Get disk space usage information.\n///\n/// Note: Users must be careful about \"Time Of Check, Time Of Use\" kind of bug.\n/// Note: Windows reports results according to the quota allocated to the user.\n///\n/// @param Path Input path.\n/// @returns a space_info structure filled with the capacity, free, and\n/// available space on the device \\a Path is on. A platform specific error_code\n/// is returned on error.\nErrorOr<space_info> disk_space(const Twine &Path);\n\n/// This class represents a memory mapped file. It is based on\n/// boost::iostreams::mapped_file.\nclass mapped_file_region {\npublic:\n  enum mapmode {\n    readonly, ///< May only access map via const_data as read only.\n    readwrite, ///< May access map via data and modify it. Written to path.\n    priv ///< May modify via data, but changes are lost on destruction.\n  };\n\nprivate:\n  /// Platform-specific mapping state.\n  size_t Size;\n  void *Mapping;\n#ifdef _WIN32\n  sys::fs::file_t FileHandle;\n#endif\n  mapmode Mode;\n\n  std::error_code init(sys::fs::file_t FD, uint64_t Offset, mapmode Mode);\n\npublic:\n  mapped_file_region() = delete;\n  mapped_file_region(mapped_file_region&) = delete;\n  mapped_file_region &operator =(mapped_file_region&) = delete;\n\n  /// \\param fd An open file descriptor to map. Does not take ownership of fd.\n  mapped_file_region(sys::fs::file_t fd, mapmode mode, size_t length, uint64_t offset,\n                     std::error_code &ec);\n\n  ~mapped_file_region();\n\n  size_t size() const;\n  char *data() const;\n\n  /// Get a const view of the data. Modifying this memory has undefined\n  /// behavior.\n  const char *const_data() const;\n\n  /// \\returns The minimum alignment offset must be.\n  static int alignment();\n};\n\n/// Return the path to the main executable, given the value of argv[0] from\n/// program startup and the address of main itself. In extremis, this function\n/// may fail and return an empty path.\nstd::string getMainExecutable(const char *argv0, void *MainExecAddr);\n\n/// @}\n/// @name Iterators\n/// @{\n\n/// directory_entry - A single entry in a directory.\nclass directory_entry {\n  // FIXME: different platforms make different information available \"for free\"\n  // when traversing a directory. The design of this class wraps most of the\n  // information in basic_file_status, so on platforms where we can't populate\n  // that whole structure, callers end up paying for a stat().\n  // std::filesystem::directory_entry may be a better model.\n  std::string Path;\n  file_type Type = file_type::type_unknown; // Most platforms can provide this.\n  bool FollowSymlinks = true;               // Affects the behavior of status().\n  basic_file_status Status;                 // If available.\n\npublic:\n  explicit directory_entry(const Twine &Path, bool FollowSymlinks = true,\n                           file_type Type = file_type::type_unknown,\n                           basic_file_status Status = basic_file_status())\n      : Path(Path.str()), Type(Type), FollowSymlinks(FollowSymlinks),\n        Status(Status) {}\n\n  directory_entry() = default;\n\n  void replace_filename(const Twine &Filename, file_type Type,\n                        basic_file_status Status = basic_file_status());\n\n  const std::string &path() const { return Path; }\n  // Get basic information about entry file (a subset of fs::status()).\n  // On most platforms this is a stat() call.\n  // On windows the information was already retrieved from the directory.\n  ErrorOr<basic_file_status> status() const;\n  // Get the type of this file.\n  // On most platforms (Linux/Mac/Windows/BSD), this was already retrieved.\n  // On some platforms (e.g. Solaris) this is a stat() call.\n  file_type type() const {\n    if (Type != file_type::type_unknown)\n      return Type;\n    auto S = status();\n    return S ? S->type() : file_type::type_unknown;\n  }\n\n  bool operator==(const directory_entry& RHS) const { return Path == RHS.Path; }\n  bool operator!=(const directory_entry& RHS) const { return !(*this == RHS); }\n  bool operator< (const directory_entry& RHS) const;\n  bool operator<=(const directory_entry& RHS) const;\n  bool operator> (const directory_entry& RHS) const;\n  bool operator>=(const directory_entry& RHS) const;\n};\n\nnamespace detail {\n\n  struct DirIterState;\n\n  std::error_code directory_iterator_construct(DirIterState &, StringRef, bool);\n  std::error_code directory_iterator_increment(DirIterState &);\n  std::error_code directory_iterator_destruct(DirIterState &);\n\n  /// Keeps state for the directory_iterator.\n  struct DirIterState {\n    ~DirIterState() {\n      directory_iterator_destruct(*this);\n    }\n\n    intptr_t IterationHandle = 0;\n    directory_entry CurrentEntry;\n  };\n\n} // end namespace detail\n\n/// directory_iterator - Iterates through the entries in path. There is no\n/// operator++ because we need an error_code. If it's really needed we can make\n/// it call report_fatal_error on error.\nclass directory_iterator {\n  std::shared_ptr<detail::DirIterState> State;\n  bool FollowSymlinks = true;\n\npublic:\n  explicit directory_iterator(const Twine &path, std::error_code &ec,\n                              bool follow_symlinks = true)\n      : FollowSymlinks(follow_symlinks) {\n    State = std::make_shared<detail::DirIterState>();\n    SmallString<128> path_storage;\n    ec = detail::directory_iterator_construct(\n        *State, path.toStringRef(path_storage), FollowSymlinks);\n  }\n\n  explicit directory_iterator(const directory_entry &de, std::error_code &ec,\n                              bool follow_symlinks = true)\n      : FollowSymlinks(follow_symlinks) {\n    State = std::make_shared<detail::DirIterState>();\n    ec = detail::directory_iterator_construct(\n        *State, de.path(), FollowSymlinks);\n  }\n\n  /// Construct end iterator.\n  directory_iterator() = default;\n\n  // No operator++ because we need error_code.\n  directory_iterator &increment(std::error_code &ec) {\n    ec = directory_iterator_increment(*State);\n    return *this;\n  }\n\n  const directory_entry &operator*() const { return State->CurrentEntry; }\n  const directory_entry *operator->() const { return &State->CurrentEntry; }\n\n  bool operator==(const directory_iterator &RHS) const {\n    if (State == RHS.State)\n      return true;\n    if (!RHS.State)\n      return State->CurrentEntry == directory_entry();\n    if (!State)\n      return RHS.State->CurrentEntry == directory_entry();\n    return State->CurrentEntry == RHS.State->CurrentEntry;\n  }\n\n  bool operator!=(const directory_iterator &RHS) const {\n    return !(*this == RHS);\n  }\n};\n\nnamespace detail {\n\n  /// Keeps state for the recursive_directory_iterator.\n  struct RecDirIterState {\n    std::stack<directory_iterator, std::vector<directory_iterator>> Stack;\n    uint16_t Level = 0;\n    bool HasNoPushRequest = false;\n  };\n\n} // end namespace detail\n\n/// recursive_directory_iterator - Same as directory_iterator except for it\n/// recurses down into child directories.\nclass recursive_directory_iterator {\n  std::shared_ptr<detail::RecDirIterState> State;\n  bool Follow;\n\npublic:\n  recursive_directory_iterator() = default;\n  explicit recursive_directory_iterator(const Twine &path, std::error_code &ec,\n                                        bool follow_symlinks = true)\n      : State(std::make_shared<detail::RecDirIterState>()),\n        Follow(follow_symlinks) {\n    State->Stack.push(directory_iterator(path, ec, Follow));\n    if (State->Stack.top() == directory_iterator())\n      State.reset();\n  }\n\n  // No operator++ because we need error_code.\n  recursive_directory_iterator &increment(std::error_code &ec) {\n    const directory_iterator end_itr = {};\n\n    if (State->HasNoPushRequest)\n      State->HasNoPushRequest = false;\n    else {\n      file_type type = State->Stack.top()->type();\n      if (type == file_type::symlink_file && Follow) {\n        // Resolve the symlink: is it a directory to recurse into?\n        ErrorOr<basic_file_status> status = State->Stack.top()->status();\n        if (status)\n          type = status->type();\n        // Otherwise broken symlink, and we'll continue.\n      }\n      if (type == file_type::directory_file) {\n        State->Stack.push(directory_iterator(*State->Stack.top(), ec, Follow));\n        if (State->Stack.top() != end_itr) {\n          ++State->Level;\n          return *this;\n        }\n        State->Stack.pop();\n      }\n    }\n\n    while (!State->Stack.empty()\n           && State->Stack.top().increment(ec) == end_itr) {\n      State->Stack.pop();\n      --State->Level;\n    }\n\n    // Check if we are done. If so, create an end iterator.\n    if (State->Stack.empty())\n      State.reset();\n\n    return *this;\n  }\n\n  const directory_entry &operator*() const { return *State->Stack.top(); }\n  const directory_entry *operator->() const { return &*State->Stack.top(); }\n\n  // observers\n  /// Gets the current level. Starting path is at level 0.\n  int level() const { return State->Level; }\n\n  /// Returns true if no_push has been called for this directory_entry.\n  bool no_push_request() const { return State->HasNoPushRequest; }\n\n  // modifiers\n  /// Goes up one level if Level > 0.\n  void pop() {\n    assert(State && \"Cannot pop an end iterator!\");\n    assert(State->Level > 0 && \"Cannot pop an iterator with level < 1\");\n\n    const directory_iterator end_itr = {};\n    std::error_code ec;\n    do {\n      if (ec)\n        report_fatal_error(\"Error incrementing directory iterator.\");\n      State->Stack.pop();\n      --State->Level;\n    } while (!State->Stack.empty()\n             && State->Stack.top().increment(ec) == end_itr);\n\n    // Check if we are done. If so, create an end iterator.\n    if (State->Stack.empty())\n      State.reset();\n  }\n\n  /// Does not go down into the current directory_entry.\n  void no_push() { State->HasNoPushRequest = true; }\n\n  bool operator==(const recursive_directory_iterator &RHS) const {\n    return State == RHS.State;\n  }\n\n  bool operator!=(const recursive_directory_iterator &RHS) const {\n    return !(*this == RHS);\n  }\n};\n\n/// @}\n\n} // end namespace fs\n} // end namespace sys\n} // end namespace llvm\n\n#endif // LLVM_SUPPORT_FILESYSTEM_H\n"}, "24": {"id": 24, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/FileSystem/UniqueID.h", "content": "//===- llvm/Support/FileSystem/UniqueID.h - UniqueID for files --*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// This file is cut out of llvm/Support/FileSystem.h to allow UniqueID to be\n// reused without bloating the includes.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_SUPPORT_FILESYSTEM_UNIQUEID_H\n#define LLVM_SUPPORT_FILESYSTEM_UNIQUEID_H\n\n#include <cstdint>\n\nnamespace llvm {\nnamespace sys {\nnamespace fs {\n\nclass UniqueID {\n  uint64_t Device;\n  uint64_t File;\n\npublic:\n  UniqueID() = default;\n  UniqueID(uint64_t Device, uint64_t File) : Device(Device), File(File) {}\n\n  bool operator==(const UniqueID &Other) const {\n    return Device == Other.Device && File == Other.File;\n  }\n  bool operator!=(const UniqueID &Other) const { return !(*this == Other); }\n  bool operator<(const UniqueID &Other) const {\n    /// Don't use std::tie since it bloats the compile time of this header.\n    if (Device < Other.Device)\n      return true;\n    if (Other.Device < Device)\n      return false;\n    return File < Other.File;\n  }\n\n  uint64_t getDevice() const { return Device; }\n  uint64_t getFile() const { return File; }\n};\n\n} // end namespace fs\n} // end namespace sys\n} // end namespace llvm\n\n#endif // LLVM_SUPPORT_FILESYSTEM_UNIQUEID_H\n"}, "25": {"id": 25, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/Format.h", "content": "//===- Format.h - Efficient printf-style formatting for streams -*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// This file implements the format() function, which can be used with other\n// LLVM subsystems to provide printf-style formatting.  This gives all the power\n// and risk of printf.  This can be used like this (with raw_ostreams as an\n// example):\n//\n//    OS << \"mynumber: \" << format(\"%4.5f\", 1234.412) << '\\n';\n//\n// Or if you prefer:\n//\n//  OS << format(\"mynumber: %4.5f\\n\", 1234.412);\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_SUPPORT_FORMAT_H\n#define LLVM_SUPPORT_FORMAT_H\n\n#include \"llvm/ADT/ArrayRef.h\"\n#include \"llvm/ADT/STLExtras.h\"\n#include \"llvm/ADT/StringRef.h\"\n#include \"llvm/Support/DataTypes.h\"\n#include <cassert>\n#include <cstdio>\n#include <tuple>\n#include <utility>\n\nnamespace llvm {\n\n/// This is a helper class used for handling formatted output.  It is the\n/// abstract base class of a templated derived class.\nclass format_object_base {\nprotected:\n  const char *Fmt;\n  ~format_object_base() = default; // Disallow polymorphic deletion.\n  format_object_base(const format_object_base &) = default;\n  virtual void home(); // Out of line virtual method.\n\n  /// Call snprintf() for this object, on the given buffer and size.\n  virtual int snprint(char *Buffer, unsigned BufferSize) const = 0;\n\npublic:\n  format_object_base(const char *fmt) : Fmt(fmt) {}\n\n  /// Format the object into the specified buffer.  On success, this returns\n  /// the length of the formatted string.  If the buffer is too small, this\n  /// returns a length to retry with, which will be larger than BufferSize.\n  unsigned print(char *Buffer, unsigned BufferSize) const {\n    assert(BufferSize && \"Invalid buffer size!\");\n\n    // Print the string, leaving room for the terminating null.\n    int N = snprint(Buffer, BufferSize);\n\n    // VC++ and old GlibC return negative on overflow, just double the size.\n    if (N < 0)\n      return BufferSize * 2;\n\n    // Other implementations yield number of bytes needed, not including the\n    // final '\\0'.\n    if (unsigned(N) >= BufferSize)\n      return N + 1;\n\n    // Otherwise N is the length of output (not including the final '\\0').\n    return N;\n  }\n};\n\n/// These are templated helper classes used by the format function that\n/// capture the object to be formatted and the format string. When actually\n/// printed, this synthesizes the string into a temporary buffer provided and\n/// returns whether or not it is big enough.\n\n// Helper to validate that format() parameters are scalars or pointers.\ntemplate <typename... Args> struct validate_format_parameters;\ntemplate <typename Arg, typename... Args>\nstruct validate_format_parameters<Arg, Args...> {\n  static_assert(std::is_scalar<Arg>::value,\n                \"format can't be used with non fundamental / non pointer type\");\n  validate_format_parameters() { validate_format_parameters<Args...>(); }\n};\ntemplate <> struct validate_format_parameters<> {};\n\ntemplate <typename... Ts>\nclass format_object final : public format_object_base {\n  std::tuple<Ts...> Vals;\n\n  template <std::size_t... Is>\n  int snprint_tuple(char *Buffer, unsigned BufferSize,\n                    std::index_sequence<Is...>) const {\n#ifdef _MSC_VER\n    return _snprintf(Buffer, BufferSize, Fmt, std::get<Is>(Vals)...);\n#else\n    return snprintf(Buffer, BufferSize, Fmt, std::get<Is>(Vals)...);\n#endif\n  }\n\npublic:\n  format_object(const char *fmt, const Ts &... vals)\n      : format_object_base(fmt), Vals(vals...) {\n    validate_format_parameters<Ts...>();\n  }\n\n  int snprint(char *Buffer, unsigned BufferSize) const override {\n    return snprint_tuple(Buffer, BufferSize, std::index_sequence_for<Ts...>());\n  }\n};\n\n/// These are helper functions used to produce formatted output.  They use\n/// template type deduction to construct the appropriate instance of the\n/// format_object class to simplify their construction.\n///\n/// This is typically used like:\n/// \\code\n///   OS << format(\"%0.4f\", myfloat) << '\\n';\n/// \\endcode\n\ntemplate <typename... Ts>\ninline format_object<Ts...> format(const char *Fmt, const Ts &... Vals) {\n  return format_object<Ts...>(Fmt, Vals...);\n}\n\n/// This is a helper class for left_justify, right_justify, and center_justify.\nclass FormattedString {\npublic:\n  enum Justification { JustifyNone, JustifyLeft, JustifyRight, JustifyCenter };\n  FormattedString(StringRef S, unsigned W, Justification J)\n      : Str(S), Width(W), Justify(J) {}\n\nprivate:\n  StringRef Str;\n  unsigned Width;\n  Justification Justify;\n  friend class raw_ostream;\n};\n\n/// left_justify - append spaces after string so total output is\n/// \\p Width characters.  If \\p Str is larger that \\p Width, full string\n/// is written with no padding.\ninline FormattedString left_justify(StringRef Str, unsigned Width) {\n  return FormattedString(Str, Width, FormattedString::JustifyLeft);\n}\n\n/// right_justify - add spaces before string so total output is\n/// \\p Width characters.  If \\p Str is larger that \\p Width, full string\n/// is written with no padding.\ninline FormattedString right_justify(StringRef Str, unsigned Width) {\n  return FormattedString(Str, Width, FormattedString::JustifyRight);\n}\n\n/// center_justify - add spaces before and after string so total output is\n/// \\p Width characters.  If \\p Str is larger that \\p Width, full string\n/// is written with no padding.\ninline FormattedString center_justify(StringRef Str, unsigned Width) {\n  return FormattedString(Str, Width, FormattedString::JustifyCenter);\n}\n\n/// This is a helper class used for format_hex() and format_decimal().\nclass FormattedNumber {\n  uint64_t HexValue;\n  int64_t DecValue;\n  unsigned Width;\n  bool Hex;\n  bool Upper;\n  bool HexPrefix;\n  friend class raw_ostream;\n\npublic:\n  FormattedNumber(uint64_t HV, int64_t DV, unsigned W, bool H, bool U,\n                  bool Prefix)\n      : HexValue(HV), DecValue(DV), Width(W), Hex(H), Upper(U),\n        HexPrefix(Prefix) {}\n};\n\n/// format_hex - Output \\p N as a fixed width hexadecimal. If number will not\n/// fit in width, full number is still printed.  Examples:\n///   OS << format_hex(255, 4)              => 0xff\n///   OS << format_hex(255, 4, true)        => 0xFF\n///   OS << format_hex(255, 6)              => 0x00ff\n///   OS << format_hex(255, 2)              => 0xff\ninline FormattedNumber format_hex(uint64_t N, unsigned Width,\n                                  bool Upper = false) {\n  assert(Width <= 18 && \"hex width must be <= 18\");\n  return FormattedNumber(N, 0, Width, true, Upper, true);\n}\n\n/// format_hex_no_prefix - Output \\p N as a fixed width hexadecimal. Does not\n/// prepend '0x' to the outputted string.  If number will not fit in width,\n/// full number is still printed.  Examples:\n///   OS << format_hex_no_prefix(255, 2)              => ff\n///   OS << format_hex_no_prefix(255, 2, true)        => FF\n///   OS << format_hex_no_prefix(255, 4)              => 00ff\n///   OS << format_hex_no_prefix(255, 1)              => ff\ninline FormattedNumber format_hex_no_prefix(uint64_t N, unsigned Width,\n                                            bool Upper = false) {\n  assert(Width <= 16 && \"hex width must be <= 16\");\n  return FormattedNumber(N, 0, Width, true, Upper, false);\n}\n\n/// format_decimal - Output \\p N as a right justified, fixed-width decimal. If\n/// number will not fit in width, full number is still printed.  Examples:\n///   OS << format_decimal(0, 5)     => \"    0\"\n///   OS << format_decimal(255, 5)   => \"  255\"\n///   OS << format_decimal(-1, 3)    => \" -1\"\n///   OS << format_decimal(12345, 3) => \"12345\"\ninline FormattedNumber format_decimal(int64_t N, unsigned Width) {\n  return FormattedNumber(0, N, Width, false, false, false);\n}\n\nclass FormattedBytes {\n  ArrayRef<uint8_t> Bytes;\n\n  // If not None, display offsets for each line relative to starting value.\n  Optional<uint64_t> FirstByteOffset;\n  uint32_t IndentLevel;  // Number of characters to indent each line.\n  uint32_t NumPerLine;   // Number of bytes to show per line.\n  uint8_t ByteGroupSize; // How many hex bytes are grouped without spaces\n  bool Upper;            // Show offset and hex bytes as upper case.\n  bool ASCII;            // Show the ASCII bytes for the hex bytes to the right.\n  friend class raw_ostream;\n\npublic:\n  FormattedBytes(ArrayRef<uint8_t> B, uint32_t IL, Optional<uint64_t> O,\n                 uint32_t NPL, uint8_t BGS, bool U, bool A)\n      : Bytes(B), FirstByteOffset(O), IndentLevel(IL), NumPerLine(NPL),\n        ByteGroupSize(BGS), Upper(U), ASCII(A) {\n\n    if (ByteGroupSize > NumPerLine)\n      ByteGroupSize = NumPerLine;\n  }\n};\n\ninline FormattedBytes\nformat_bytes(ArrayRef<uint8_t> Bytes, Optional<uint64_t> FirstByteOffset = None,\n             uint32_t NumPerLine = 16, uint8_t ByteGroupSize = 4,\n             uint32_t IndentLevel = 0, bool Upper = false) {\n  return FormattedBytes(Bytes, IndentLevel, FirstByteOffset, NumPerLine,\n                        ByteGroupSize, Upper, false);\n}\n\ninline FormattedBytes\nformat_bytes_with_ascii(ArrayRef<uint8_t> Bytes,\n                        Optional<uint64_t> FirstByteOffset = None,\n                        uint32_t NumPerLine = 16, uint8_t ByteGroupSize = 4,\n                        uint32_t IndentLevel = 0, bool Upper = false) {\n  return FormattedBytes(Bytes, IndentLevel, FirstByteOffset, NumPerLine,\n                        ByteGroupSize, Upper, true);\n}\n\n} // end namespace llvm\n\n#endif\n"}, "26": {"id": 26, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/MD5.h", "content": "/* -*- C++ -*-\n * This code is derived from (original license follows):\n *\n * This is an OpenSSL-compatible implementation of the RSA Data Security, Inc.\n * MD5 Message-Digest Algorithm (RFC 1321).\n *\n * Homepage:\n * http://openwall.info/wiki/people/solar/software/public-domain-source-code/md5\n *\n * Author:\n * Alexander Peslyak, better known as Solar Designer <solar at openwall.com>\n *\n * This software was written by Alexander Peslyak in 2001.  No copyright is\n * claimed, and the software is hereby placed in the public domain.\n * In case this attempt to disclaim copyright and place the software in the\n * public domain is deemed null and void, then the software is\n * Copyright (c) 2001 Alexander Peslyak and it is hereby released to the\n * general public under the following terms:\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted.\n *\n * There's ABSOLUTELY NO WARRANTY, express or implied.\n *\n * See md5.c for more information.\n */\n\n#ifndef LLVM_SUPPORT_MD5_H\n#define LLVM_SUPPORT_MD5_H\n\n#include \"llvm/ADT/StringRef.h\"\n#include \"llvm/Support/Endian.h\"\n#include <array>\n#include <cstdint>\n\nnamespace llvm {\n\ntemplate <unsigned N> class SmallString;\ntemplate <typename T> class ArrayRef;\n\nclass MD5 {\n  // Any 32-bit or wider unsigned integer data type will do.\n  typedef uint32_t MD5_u32plus;\n\n  MD5_u32plus a = 0x67452301;\n  MD5_u32plus b = 0xefcdab89;\n  MD5_u32plus c = 0x98badcfe;\n  MD5_u32plus d = 0x10325476;\n  MD5_u32plus hi = 0;\n  MD5_u32plus lo = 0;\n  uint8_t buffer[64];\n  MD5_u32plus block[16];\n\npublic:\n  struct MD5Result {\n    std::array<uint8_t, 16> Bytes;\n\n    operator std::array<uint8_t, 16>() const { return Bytes; }\n\n    const uint8_t &operator[](size_t I) const { return Bytes[I]; }\n    uint8_t &operator[](size_t I) { return Bytes[I]; }\n\n    SmallString<32> digest() const;\n\n    uint64_t low() const {\n      // Our MD5 implementation returns the result in little endian, so the low\n      // word is first.\n      using namespace support;\n      return endian::read<uint64_t, little, unaligned>(Bytes.data());\n    }\n\n    uint64_t high() const {\n      using namespace support;\n      return endian::read<uint64_t, little, unaligned>(Bytes.data() + 8);\n    }\n    std::pair<uint64_t, uint64_t> words() const {\n      using namespace support;\n      return std::make_pair(high(), low());\n    }\n  };\n\n  MD5();\n\n  /// Updates the hash for the byte stream provided.\n  void update(ArrayRef<uint8_t> Data);\n\n  /// Updates the hash for the StringRef provided.\n  void update(StringRef Str);\n\n  /// Finishes off the hash and puts the result in result.\n  void final(MD5Result &Result);\n\n  /// Translates the bytes in \\p Res to a hex string that is\n  /// deposited into \\p Str. The result will be of length 32.\n  static void stringifyResult(MD5Result &Result, SmallString<32> &Str);\n\n  /// Computes the hash for a given bytes.\n  static std::array<uint8_t, 16> hash(ArrayRef<uint8_t> Data);\n\nprivate:\n  const uint8_t *body(ArrayRef<uint8_t> Data);\n};\n\ninline bool operator==(const MD5::MD5Result &LHS, const MD5::MD5Result &RHS) {\n  return LHS.Bytes == RHS.Bytes;\n}\n\n/// Helper to compute and return lower 64 bits of the given string's MD5 hash.\ninline uint64_t MD5Hash(StringRef Str) {\n  using namespace support;\n\n  MD5 Hash;\n  Hash.update(Str);\n  MD5::MD5Result Result;\n  Hash.final(Result);\n  // Return the least significant word.\n  return Result.low();\n}\n\n} // end namespace llvm\n\n#endif // LLVM_SUPPORT_MD5_H\n"}, "27": {"id": 27, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/PrettyStackTrace.h", "content": "//===- llvm/Support/PrettyStackTrace.h - Pretty Crash Handling --*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// This file defines the PrettyStackTraceEntry class, which is used to make\n// crashes give more contextual information about what the program was doing\n// when it crashed.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_SUPPORT_PRETTYSTACKTRACE_H\n#define LLVM_SUPPORT_PRETTYSTACKTRACE_H\n\n#include \"llvm/ADT/SmallVector.h\"\n#include \"llvm/Support/Compiler.h\"\n\nnamespace llvm {\n  class raw_ostream;\n\n  /// Enables dumping a \"pretty\" stack trace when the program crashes.\n  ///\n  /// \\see PrettyStackTraceEntry\n  void EnablePrettyStackTrace();\n\n  /// Enables (or disables) dumping a \"pretty\" stack trace when the user sends\n  /// SIGINFO or SIGUSR1 to the current process.\n  ///\n  /// This is a per-thread decision so that a program can choose to print stack\n  /// traces only on a primary thread, or on all threads that use\n  /// PrettyStackTraceEntry.\n  ///\n  /// \\see EnablePrettyStackTrace\n  /// \\see PrettyStackTraceEntry\n  void EnablePrettyStackTraceOnSigInfoForThisThread(bool ShouldEnable = true);\n\n  /// Replaces the generic bug report message that is output upon\n  /// a crash.\n  void setBugReportMsg(const char *Msg);\n\n  /// Get the bug report message that will be output upon a crash.\n  const char *getBugReportMsg();\n\n  /// PrettyStackTraceEntry - This class is used to represent a frame of the\n  /// \"pretty\" stack trace that is dumped when a program crashes. You can define\n  /// subclasses of this and declare them on the program stack: when they are\n  /// constructed and destructed, they will add their symbolic frames to a\n  /// virtual stack trace.  This gets dumped out if the program crashes.\n  class PrettyStackTraceEntry {\n    friend PrettyStackTraceEntry *ReverseStackTrace(PrettyStackTraceEntry *);\n\n    PrettyStackTraceEntry *NextEntry;\n    PrettyStackTraceEntry(const PrettyStackTraceEntry &) = delete;\n    void operator=(const PrettyStackTraceEntry &) = delete;\n  public:\n    PrettyStackTraceEntry();\n    virtual ~PrettyStackTraceEntry();\n\n    /// print - Emit information about this stack frame to OS.\n    virtual void print(raw_ostream &OS) const = 0;\n\n    /// getNextEntry - Return the next entry in the list of frames.\n    const PrettyStackTraceEntry *getNextEntry() const { return NextEntry; }\n  };\n\n  /// PrettyStackTraceString - This object prints a specified string (which\n  /// should not contain newlines) to the stream as the stack trace when a crash\n  /// occurs.\n  class PrettyStackTraceString : public PrettyStackTraceEntry {\n    const char *Str;\n  public:\n    PrettyStackTraceString(const char *str) : Str(str) {}\n    void print(raw_ostream &OS) const override;\n  };\n\n  /// PrettyStackTraceFormat - This object prints a string (which may use\n  /// printf-style formatting but should not contain newlines) to the stream\n  /// as the stack trace when a crash occurs.\n  class PrettyStackTraceFormat : public PrettyStackTraceEntry {\n    llvm::SmallVector<char, 32> Str;\n  public:\n    PrettyStackTraceFormat(const char *Format, ...);\n    void print(raw_ostream &OS) const override;\n  };\n\n  /// PrettyStackTraceProgram - This object prints a specified program arguments\n  /// to the stream as the stack trace when a crash occurs.\n  class PrettyStackTraceProgram : public PrettyStackTraceEntry {\n    int ArgC;\n    const char *const *ArgV;\n  public:\n    PrettyStackTraceProgram(int argc, const char * const*argv)\n      : ArgC(argc), ArgV(argv) {\n      EnablePrettyStackTrace();\n    }\n    void print(raw_ostream &OS) const override;\n  };\n\n  /// Returns the topmost element of the \"pretty\" stack state.\n  const void *SavePrettyStackState();\n\n  /// Restores the topmost element of the \"pretty\" stack state to State, which\n  /// should come from a previous call to SavePrettyStackState().  This is\n  /// useful when using a CrashRecoveryContext in code that also uses\n  /// PrettyStackTraceEntries, to make sure the stack that's printed if a crash\n  /// happens after a crash that's been recovered by CrashRecoveryContext\n  /// doesn't have frames on it that were added in code unwound by the\n  /// CrashRecoveryContext.\n  void RestorePrettyStackState(const void *State);\n\n} // end namespace llvm\n\n#endif\n"}, "28": {"id": 28, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/SMLoc.h", "content": "//===- SMLoc.h - Source location for use with diagnostics -------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// This file declares the SMLoc class.  This class encapsulates a location in\n// source code for use in diagnostics.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_SUPPORT_SMLOC_H\n#define LLVM_SUPPORT_SMLOC_H\n\n#include \"llvm/ADT/None.h\"\n#include <cassert>\n\nnamespace llvm {\n\n/// Represents a location in source code.\nclass SMLoc {\n  const char *Ptr = nullptr;\n\npublic:\n  SMLoc() = default;\n\n  bool isValid() const { return Ptr != nullptr; }\n\n  bool operator==(const SMLoc &RHS) const { return RHS.Ptr == Ptr; }\n  bool operator!=(const SMLoc &RHS) const { return RHS.Ptr != Ptr; }\n\n  const char *getPointer() const { return Ptr; }\n\n  static SMLoc getFromPointer(const char *Ptr) {\n    SMLoc L;\n    L.Ptr = Ptr;\n    return L;\n  }\n};\n\n/// Represents a range in source code.\n///\n/// SMRange is implemented using a half-open range, as is the convention in C++.\n/// In the string \"abc\", the range [1,3) represents the substring \"bc\", and the\n/// range [2,2) represents an empty range between the characters \"b\" and \"c\".\nclass SMRange {\npublic:\n  SMLoc Start, End;\n\n  SMRange() = default;\n  SMRange(NoneType) {}\n  SMRange(SMLoc St, SMLoc En) : Start(St), End(En) {\n    assert(Start.isValid() == End.isValid() &&\n           \"Start and End should either both be valid or both be invalid!\");\n  }\n\n  bool isValid() const { return Start.isValid(); }\n};\n\n} // end namespace llvm\n\n#endif // LLVM_SUPPORT_SMLOC_H\n"}, "29": {"id": 29, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/SourceMgr.h", "content": "//===- SourceMgr.h - Manager for Source Buffers & Diagnostics ---*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// This file declares the SMDiagnostic and SourceMgr classes.  This\n// provides a simple substrate for diagnostics, #include handling, and other low\n// level things for simple parsers.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_SUPPORT_SOURCEMGR_H\n#define LLVM_SUPPORT_SOURCEMGR_H\n\n#include \"llvm/ADT/SmallVector.h\"\n#include \"llvm/Support/MemoryBuffer.h\"\n#include \"llvm/Support/SMLoc.h\"\n#include <vector>\n\nnamespace llvm {\n\nclass raw_ostream;\nclass SMDiagnostic;\nclass SMFixIt;\n\n/// This owns the files read by a parser, handles include stacks,\n/// and handles diagnostic wrangling.\nclass SourceMgr {\npublic:\n  enum DiagKind {\n    DK_Error,\n    DK_Warning,\n    DK_Remark,\n    DK_Note,\n  };\n\n  /// Clients that want to handle their own diagnostics in a custom way can\n  /// register a function pointer+context as a diagnostic handler.\n  /// It gets called each time PrintMessage is invoked.\n  using DiagHandlerTy = void (*)(const SMDiagnostic &, void *Context);\n\nprivate:\n  struct SrcBuffer {\n    /// The memory buffer for the file.\n    std::unique_ptr<MemoryBuffer> Buffer;\n\n    /// Vector of offsets into Buffer at which there are line-endings\n    /// (lazily populated). Once populated, the '\\n' that marks the end of\n    /// line number N from [1..] is at Buffer[OffsetCache[N-1]]. Since\n    /// these offsets are in sorted (ascending) order, they can be\n    /// binary-searched for the first one after any given offset (eg. an\n    /// offset corresponding to a particular SMLoc).\n    ///\n    /// Since we're storing offsets into relatively small files (often smaller\n    /// than 2^8 or 2^16 bytes), we select the offset vector element type\n    /// dynamically based on the size of Buffer.\n    mutable void *OffsetCache = nullptr;\n\n    /// Look up a given \\p Ptr in in the buffer, determining which line it came\n    /// from.\n    unsigned getLineNumber(const char *Ptr) const;\n    template <typename T>\n    unsigned getLineNumberSpecialized(const char *Ptr) const;\n\n    /// Return a pointer to the first character of the specified line number or\n    /// null if the line number is invalid.\n    const char *getPointerForLineNumber(unsigned LineNo) const;\n    template <typename T>\n    const char *getPointerForLineNumberSpecialized(unsigned LineNo) const;\n\n    /// This is the location of the parent include, or null if at the top level.\n    SMLoc IncludeLoc;\n\n    SrcBuffer() = default;\n    SrcBuffer(SrcBuffer &&);\n    SrcBuffer(const SrcBuffer &) = delete;\n    SrcBuffer &operator=(const SrcBuffer &) = delete;\n    ~SrcBuffer();\n  };\n\n  /// This is all of the buffers that we are reading from.\n  std::vector<SrcBuffer> Buffers;\n\n  // This is the list of directories we should search for include files in.\n  std::vector<std::string> IncludeDirectories;\n\n  DiagHandlerTy DiagHandler = nullptr;\n  void *DiagContext = nullptr;\n\n  bool isValidBufferID(unsigned i) const { return i && i <= Buffers.size(); }\n\npublic:\n  SourceMgr() = default;\n  SourceMgr(const SourceMgr &) = delete;\n  SourceMgr &operator=(const SourceMgr &) = delete;\n  SourceMgr(SourceMgr &&) = default;\n  SourceMgr &operator=(SourceMgr &&) = default;\n  ~SourceMgr() = default;\n\n  void setIncludeDirs(const std::vector<std::string> &Dirs) {\n    IncludeDirectories = Dirs;\n  }\n\n  /// Specify a diagnostic handler to be invoked every time PrintMessage is\n  /// called. \\p Ctx is passed into the handler when it is invoked.\n  void setDiagHandler(DiagHandlerTy DH, void *Ctx = nullptr) {\n    DiagHandler = DH;\n    DiagContext = Ctx;\n  }\n\n  DiagHandlerTy getDiagHandler() const { return DiagHandler; }\n  void *getDiagContext() const { return DiagContext; }\n\n  const SrcBuffer &getBufferInfo(unsigned i) const {\n    assert(isValidBufferID(i));\n    return Buffers[i - 1];\n  }\n\n  const MemoryBuffer *getMemoryBuffer(unsigned i) const {\n    assert(isValidBufferID(i));\n    return Buffers[i - 1].Buffer.get();\n  }\n\n  unsigned getNumBuffers() const { return Buffers.size(); }\n\n  unsigned getMainFileID() const {\n    assert(getNumBuffers());\n    return 1;\n  }\n\n  SMLoc getParentIncludeLoc(unsigned i) const {\n    assert(isValidBufferID(i));\n    return Buffers[i - 1].IncludeLoc;\n  }\n\n  /// Add a new source buffer to this source manager. This takes ownership of\n  /// the memory buffer.\n  unsigned AddNewSourceBuffer(std::unique_ptr<MemoryBuffer> F,\n                              SMLoc IncludeLoc) {\n    SrcBuffer NB;\n    NB.Buffer = std::move(F);\n    NB.IncludeLoc = IncludeLoc;\n    Buffers.push_back(std::move(NB));\n    return Buffers.size();\n  }\n\n  /// Search for a file with the specified name in the current directory or in\n  /// one of the IncludeDirs.\n  ///\n  /// If no file is found, this returns 0, otherwise it returns the buffer ID\n  /// of the stacked file. The full path to the included file can be found in\n  /// \\p IncludedFile.\n  unsigned AddIncludeFile(const std::string &Filename, SMLoc IncludeLoc,\n                          std::string &IncludedFile);\n\n  /// Return the ID of the buffer containing the specified location.\n  ///\n  /// 0 is returned if the buffer is not found.\n  unsigned FindBufferContainingLoc(SMLoc Loc) const;\n\n  /// Find the line number for the specified location in the specified file.\n  /// This is not a fast method.\n  unsigned FindLineNumber(SMLoc Loc, unsigned BufferID = 0) const {\n    return getLineAndColumn(Loc, BufferID).first;\n  }\n\n  /// Find the line and column number for the specified location in the\n  /// specified file. This is not a fast method.\n  std::pair<unsigned, unsigned> getLineAndColumn(SMLoc Loc,\n                                                 unsigned BufferID = 0) const;\n\n  /// Get a string with the \\p SMLoc filename and line number\n  /// formatted in the standard style.\n  std::string getFormattedLocationNoOffset(SMLoc Loc,\n                                           bool IncludePath = false) const;\n\n  /// Given a line and column number in a mapped buffer, turn it into an SMLoc.\n  /// This will return a null SMLoc if the line/column location is invalid.\n  SMLoc FindLocForLineAndColumn(unsigned BufferID, unsigned LineNo,\n                                unsigned ColNo);\n\n  /// Emit a message about the specified location with the specified string.\n  ///\n  /// \\param ShowColors Display colored messages if output is a terminal and\n  /// the default error handler is used.\n  void PrintMessage(raw_ostream &OS, SMLoc Loc, DiagKind Kind, const Twine &Msg,\n                    ArrayRef<SMRange> Ranges = {},\n                    ArrayRef<SMFixIt> FixIts = {},\n                    bool ShowColors = true) const;\n\n  /// Emits a diagnostic to llvm::errs().\n  void PrintMessage(SMLoc Loc, DiagKind Kind, const Twine &Msg,\n                    ArrayRef<SMRange> Ranges = {},\n                    ArrayRef<SMFixIt> FixIts = {},\n                    bool ShowColors = true) const;\n\n  /// Emits a manually-constructed diagnostic to the given output stream.\n  ///\n  /// \\param ShowColors Display colored messages if output is a terminal and\n  /// the default error handler is used.\n  void PrintMessage(raw_ostream &OS, const SMDiagnostic &Diagnostic,\n                    bool ShowColors = true) const;\n\n  /// Return an SMDiagnostic at the specified location with the specified\n  /// string.\n  ///\n  /// \\param Msg If non-null, the kind of message (e.g., \"error\") which is\n  /// prefixed to the message.\n  SMDiagnostic GetMessage(SMLoc Loc, DiagKind Kind, const Twine &Msg,\n                          ArrayRef<SMRange> Ranges = {},\n                          ArrayRef<SMFixIt> FixIts = {}) const;\n\n  /// Prints the names of included files and the line of the file they were\n  /// included from. A diagnostic handler can use this before printing its\n  /// custom formatted message.\n  ///\n  /// \\param IncludeLoc The location of the include.\n  /// \\param OS the raw_ostream to print on.\n  void PrintIncludeStack(SMLoc IncludeLoc, raw_ostream &OS) const;\n};\n\n/// Represents a single fixit, a replacement of one range of text with another.\nclass SMFixIt {\n  SMRange Range;\n\n  std::string Text;\n\npublic:\n  SMFixIt(SMRange R, const Twine &Replacement);\n\n  SMFixIt(SMLoc Loc, const Twine &Replacement)\n      : SMFixIt(SMRange(Loc, Loc), Replacement) {}\n\n  StringRef getText() const { return Text; }\n  SMRange getRange() const { return Range; }\n\n  bool operator<(const SMFixIt &Other) const {\n    if (Range.Start.getPointer() != Other.Range.Start.getPointer())\n      return Range.Start.getPointer() < Other.Range.Start.getPointer();\n    if (Range.End.getPointer() != Other.Range.End.getPointer())\n      return Range.End.getPointer() < Other.Range.End.getPointer();\n    return Text < Other.Text;\n  }\n};\n\n/// Instances of this class encapsulate one diagnostic report, allowing\n/// printing to a raw_ostream as a caret diagnostic.\nclass SMDiagnostic {\n  const SourceMgr *SM = nullptr;\n  SMLoc Loc;\n  std::string Filename;\n  int LineNo = 0;\n  int ColumnNo = 0;\n  SourceMgr::DiagKind Kind = SourceMgr::DK_Error;\n  std::string Message, LineContents;\n  std::vector<std::pair<unsigned, unsigned>> Ranges;\n  SmallVector<SMFixIt, 4> FixIts;\n\npublic:\n  // Null diagnostic.\n  SMDiagnostic() = default;\n  // Diagnostic with no location (e.g. file not found, command line arg error).\n  SMDiagnostic(StringRef filename, SourceMgr::DiagKind Knd, StringRef Msg)\n      : Filename(filename), LineNo(-1), ColumnNo(-1), Kind(Knd), Message(Msg) {}\n\n  // Diagnostic with a location.\n  SMDiagnostic(const SourceMgr &sm, SMLoc L, StringRef FN, int Line, int Col,\n               SourceMgr::DiagKind Kind, StringRef Msg, StringRef LineStr,\n               ArrayRef<std::pair<unsigned, unsigned>> Ranges,\n               ArrayRef<SMFixIt> FixIts = {});\n\n  const SourceMgr *getSourceMgr() const { return SM; }\n  SMLoc getLoc() const { return Loc; }\n  StringRef getFilename() const { return Filename; }\n  int getLineNo() const { return LineNo; }\n  int getColumnNo() const { return ColumnNo; }\n  SourceMgr::DiagKind getKind() const { return Kind; }\n  StringRef getMessage() const { return Message; }\n  StringRef getLineContents() const { return LineContents; }\n  ArrayRef<std::pair<unsigned, unsigned>> getRanges() const { return Ranges; }\n\n  void addFixIt(const SMFixIt &Hint) { FixIts.push_back(Hint); }\n\n  ArrayRef<SMFixIt> getFixIts() const { return FixIts; }\n\n  void print(const char *ProgName, raw_ostream &S, bool ShowColors = true,\n             bool ShowKindLabel = true) const;\n};\n\n} // end namespace llvm\n\n#endif // LLVM_SUPPORT_SOURCEMGR_H\n"}, "30": {"id": 30, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/SwapByteOrder.h", "content": "//===- SwapByteOrder.h - Generic and optimized byte swaps -------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// This file declares generic and optimized functions to swap the byte order of\n// an integral type.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_SUPPORT_SWAPBYTEORDER_H\n#define LLVM_SUPPORT_SWAPBYTEORDER_H\n\n#include <cstddef>\n#include <cstdint>\n#include <type_traits>\n#if defined(_MSC_VER) && !defined(_DEBUG)\n#include <stdlib.h>\n#endif\n\n#if defined(__linux__) || defined(__GNU__) || defined(__HAIKU__) ||            \\\n    defined(__Fuchsia__) || defined(__EMSCRIPTEN__)\n#include <endian.h>\n#elif defined(_AIX)\n#include <sys/machine.h>\n#elif defined(__sun)\n/* Solaris provides _BIG_ENDIAN/_LITTLE_ENDIAN selector in sys/types.h */\n#include <sys/types.h>\n#define BIG_ENDIAN 4321\n#define LITTLE_ENDIAN 1234\n#if defined(_BIG_ENDIAN)\n#define BYTE_ORDER BIG_ENDIAN\n#else\n#define BYTE_ORDER LITTLE_ENDIAN\n#endif\n#elif defined(__MVS__)\n#define BIG_ENDIAN 4321\n#define LITTLE_ENDIAN 1234\n#define BYTE_ORDER BIG_ENDIAN\n#else\n#if !defined(BYTE_ORDER) && !defined(_WIN32)\n#include <machine/endian.h>\n#endif\n#endif\n\nnamespace llvm {\n\n/// ByteSwap_16 - This function returns a byte-swapped representation of\n/// the 16-bit argument.\ninline uint16_t ByteSwap_16(uint16_t value) {\n#if defined(_MSC_VER) && !defined(_DEBUG)\n  // The DLL version of the runtime lacks these functions (bug!?), but in a\n  // release build they're replaced with BSWAP instructions anyway.\n  return _byteswap_ushort(value);\n#else\n  uint16_t Hi = value << 8;\n  uint16_t Lo = value >> 8;\n  return Hi | Lo;\n#endif\n}\n\n/// This function returns a byte-swapped representation of the 32-bit argument.\ninline uint32_t ByteSwap_32(uint32_t value) {\n#if defined(__llvm__) || (defined(__GNUC__) && !defined(__ICC))\n  return __builtin_bswap32(value);\n#elif defined(_MSC_VER) && !defined(_DEBUG)\n  return _byteswap_ulong(value);\n#else\n  uint32_t Byte0 = value & 0x000000FF;\n  uint32_t Byte1 = value & 0x0000FF00;\n  uint32_t Byte2 = value & 0x00FF0000;\n  uint32_t Byte3 = value & 0xFF000000;\n  return (Byte0 << 24) | (Byte1 << 8) | (Byte2 >> 8) | (Byte3 >> 24);\n#endif\n}\n\n/// This function returns a byte-swapped representation of the 64-bit argument.\ninline uint64_t ByteSwap_64(uint64_t value) {\n#if defined(__llvm__) || (defined(__GNUC__) && !defined(__ICC))\n  return __builtin_bswap64(value);\n#elif defined(_MSC_VER) && !defined(_DEBUG)\n  return _byteswap_uint64(value);\n#else\n  uint64_t Hi = ByteSwap_32(uint32_t(value));\n  uint32_t Lo = ByteSwap_32(uint32_t(value >> 32));\n  return (Hi << 32) | Lo;\n#endif\n}\n\nnamespace sys {\n\n#if defined(BYTE_ORDER) && defined(BIG_ENDIAN) && BYTE_ORDER == BIG_ENDIAN\nconstexpr bool IsBigEndianHost = true;\n#else\nconstexpr bool IsBigEndianHost = false;\n#endif\n\nstatic const bool IsLittleEndianHost = !IsBigEndianHost;\n\ninline unsigned char  getSwappedBytes(unsigned char C) { return C; }\ninline   signed char  getSwappedBytes(signed char C) { return C; }\ninline          char  getSwappedBytes(char C) { return C; }\n\ninline unsigned short getSwappedBytes(unsigned short C) { return ByteSwap_16(C); }\ninline   signed short getSwappedBytes(  signed short C) { return ByteSwap_16(C); }\n\ninline unsigned int   getSwappedBytes(unsigned int   C) { return ByteSwap_32(C); }\ninline   signed int   getSwappedBytes(  signed int   C) { return ByteSwap_32(C); }\n\ninline unsigned long getSwappedBytes(unsigned long C) {\n  // Handle LLP64 and LP64 platforms.\n  return sizeof(long) == sizeof(int) ? ByteSwap_32((uint32_t)C)\n                                     : ByteSwap_64((uint64_t)C);\n}\ninline signed long getSwappedBytes(signed long C) {\n  // Handle LLP64 and LP64 platforms.\n  return sizeof(long) == sizeof(int) ? ByteSwap_32((uint32_t)C)\n                                     : ByteSwap_64((uint64_t)C);\n}\n\ninline unsigned long long getSwappedBytes(unsigned long long C) {\n  return ByteSwap_64(C);\n}\ninline signed long long getSwappedBytes(signed long long C) {\n  return ByteSwap_64(C);\n}\n\ninline float getSwappedBytes(float C) {\n  union {\n    uint32_t i;\n    float f;\n  } in, out;\n  in.f = C;\n  out.i = ByteSwap_32(in.i);\n  return out.f;\n}\n\ninline double getSwappedBytes(double C) {\n  union {\n    uint64_t i;\n    double d;\n  } in, out;\n  in.d = C;\n  out.i = ByteSwap_64(in.i);\n  return out.d;\n}\n\ntemplate <typename T>\ninline std::enable_if_t<std::is_enum<T>::value, T> getSwappedBytes(T C) {\n  return static_cast<T>(\n      getSwappedBytes(static_cast<std::underlying_type_t<T>>(C)));\n}\n\ntemplate<typename T>\ninline void swapByteOrder(T &Value) {\n  Value = getSwappedBytes(Value);\n}\n\n} // end namespace sys\n} // end namespace llvm\n\n#endif\n"}, "31": {"id": 31, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/VirtualFileSystem.h", "content": "//===- VirtualFileSystem.h - Virtual File System Layer ----------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n/// \\file\n/// Defines the virtual file system interface vfs::FileSystem.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_SUPPORT_VIRTUALFILESYSTEM_H\n#define LLVM_SUPPORT_VIRTUALFILESYSTEM_H\n\n#include \"llvm/ADT/IntrusiveRefCntPtr.h\"\n#include \"llvm/ADT/None.h\"\n#include \"llvm/ADT/Optional.h\"\n#include \"llvm/ADT/SmallVector.h\"\n#include \"llvm/ADT/StringRef.h\"\n#include \"llvm/Support/Chrono.h\"\n#include \"llvm/Support/ErrorOr.h\"\n#include \"llvm/Support/FileSystem.h\"\n#include \"llvm/Support/Path.h\"\n#include \"llvm/Support/SourceMgr.h\"\n#include <cassert>\n#include <cstdint>\n#include <ctime>\n#include <memory>\n#include <stack>\n#include <string>\n#include <system_error>\n#include <utility>\n#include <vector>\n\nnamespace llvm {\n\nclass MemoryBuffer;\nclass MemoryBufferRef;\nclass Twine;\n\nnamespace vfs {\n\n/// The result of a \\p status operation.\nclass Status {\n  std::string Name;\n  llvm::sys::fs::UniqueID UID;\n  llvm::sys::TimePoint<> MTime;\n  uint32_t User;\n  uint32_t Group;\n  uint64_t Size;\n  llvm::sys::fs::file_type Type = llvm::sys::fs::file_type::status_error;\n  llvm::sys::fs::perms Perms;\n\npublic:\n  // FIXME: remove when files support multiple names\n  bool IsVFSMapped = false;\n\n  Status() = default;\n  Status(const llvm::sys::fs::file_status &Status);\n  Status(const Twine &Name, llvm::sys::fs::UniqueID UID,\n         llvm::sys::TimePoint<> MTime, uint32_t User, uint32_t Group,\n         uint64_t Size, llvm::sys::fs::file_type Type,\n         llvm::sys::fs::perms Perms);\n\n  /// Get a copy of a Status with a different name.\n  static Status copyWithNewName(const Status &In, const Twine &NewName);\n  static Status copyWithNewName(const llvm::sys::fs::file_status &In,\n                                const Twine &NewName);\n\n  /// Returns the name that should be used for this file or directory.\n  StringRef getName() const { return Name; }\n\n  /// @name Status interface from llvm::sys::fs\n  /// @{\n  llvm::sys::fs::file_type getType() const { return Type; }\n  llvm::sys::fs::perms getPermissions() const { return Perms; }\n  llvm::sys::TimePoint<> getLastModificationTime() const { return MTime; }\n  llvm::sys::fs::UniqueID getUniqueID() const { return UID; }\n  uint32_t getUser() const { return User; }\n  uint32_t getGroup() const { return Group; }\n  uint64_t getSize() const { return Size; }\n  /// @}\n  /// @name Status queries\n  /// These are static queries in llvm::sys::fs.\n  /// @{\n  bool equivalent(const Status &Other) const;\n  bool isDirectory() const;\n  bool isRegularFile() const;\n  bool isOther() const;\n  bool isSymlink() const;\n  bool isStatusKnown() const;\n  bool exists() const;\n  /// @}\n};\n\n/// Represents an open file.\nclass File {\npublic:\n  /// Destroy the file after closing it (if open).\n  /// Sub-classes should generally call close() inside their destructors.  We\n  /// cannot do that from the base class, since close is virtual.\n  virtual ~File();\n\n  /// Get the status of the file.\n  virtual llvm::ErrorOr<Status> status() = 0;\n\n  /// Get the name of the file\n  virtual llvm::ErrorOr<std::string> getName() {\n    if (auto Status = status())\n      return Status->getName().str();\n    else\n      return Status.getError();\n  }\n\n  /// Get the contents of the file as a \\p MemoryBuffer.\n  virtual llvm::ErrorOr<std::unique_ptr<llvm::MemoryBuffer>>\n  getBuffer(const Twine &Name, int64_t FileSize = -1,\n            bool RequiresNullTerminator = true, bool IsVolatile = false) = 0;\n\n  /// Closes the file.\n  virtual std::error_code close() = 0;\n};\n\n/// A member of a directory, yielded by a directory_iterator.\n/// Only information available on most platforms is included.\nclass directory_entry {\n  std::string Path;\n  llvm::sys::fs::file_type Type = llvm::sys::fs::file_type::type_unknown;\n\npublic:\n  directory_entry() = default;\n  directory_entry(std::string Path, llvm::sys::fs::file_type Type)\n      : Path(std::move(Path)), Type(Type) {}\n\n  llvm::StringRef path() const { return Path; }\n  llvm::sys::fs::file_type type() const { return Type; }\n};\n\nnamespace detail {\n\n/// An interface for virtual file systems to provide an iterator over the\n/// (non-recursive) contents of a directory.\nstruct DirIterImpl {\n  virtual ~DirIterImpl();\n\n  /// Sets \\c CurrentEntry to the next entry in the directory on success,\n  /// to directory_entry() at end,  or returns a system-defined \\c error_code.\n  virtual std::error_code increment() = 0;\n\n  directory_entry CurrentEntry;\n};\n\n} // namespace detail\n\n/// An input iterator over the entries in a virtual path, similar to\n/// llvm::sys::fs::directory_iterator.\nclass directory_iterator {\n  std::shared_ptr<detail::DirIterImpl> Impl; // Input iterator semantics on copy\n\npublic:\n  directory_iterator(std::shared_ptr<detail::DirIterImpl> I)\n      : Impl(std::move(I)) {\n    assert(Impl.get() != nullptr && \"requires non-null implementation\");\n    if (Impl->CurrentEntry.path().empty())\n      Impl.reset(); // Normalize the end iterator to Impl == nullptr.\n  }\n\n  /// Construct an 'end' iterator.\n  directory_iterator() = default;\n\n  /// Equivalent to operator++, with an error code.\n  directory_iterator &increment(std::error_code &EC) {\n    assert(Impl && \"attempting to increment past end\");\n    EC = Impl->increment();\n    if (Impl->CurrentEntry.path().empty())\n      Impl.reset(); // Normalize the end iterator to Impl == nullptr.\n    return *this;\n  }\n\n  const directory_entry &operator*() const { return Impl->CurrentEntry; }\n  const directory_entry *operator->() const { return &Impl->CurrentEntry; }\n\n  bool operator==(const directory_iterator &RHS) const {\n    if (Impl && RHS.Impl)\n      return Impl->CurrentEntry.path() == RHS.Impl->CurrentEntry.path();\n    return !Impl && !RHS.Impl;\n  }\n  bool operator!=(const directory_iterator &RHS) const {\n    return !(*this == RHS);\n  }\n};\n\nclass FileSystem;\n\nnamespace detail {\n\n/// Keeps state for the recursive_directory_iterator.\nstruct RecDirIterState {\n  std::stack<directory_iterator, std::vector<directory_iterator>> Stack;\n  bool HasNoPushRequest = false;\n};\n\n} // end namespace detail\n\n/// An input iterator over the recursive contents of a virtual path,\n/// similar to llvm::sys::fs::recursive_directory_iterator.\nclass recursive_directory_iterator {\n  FileSystem *FS;\n  std::shared_ptr<detail::RecDirIterState>\n      State; // Input iterator semantics on copy.\n\npublic:\n  recursive_directory_iterator(FileSystem &FS, const Twine &Path,\n                               std::error_code &EC);\n\n  /// Construct an 'end' iterator.\n  recursive_directory_iterator() = default;\n\n  /// Equivalent to operator++, with an error code.\n  recursive_directory_iterator &increment(std::error_code &EC);\n\n  const directory_entry &operator*() const { return *State->Stack.top(); }\n  const directory_entry *operator->() const { return &*State->Stack.top(); }\n\n  bool operator==(const recursive_directory_iterator &Other) const {\n    return State == Other.State; // identity\n  }\n  bool operator!=(const recursive_directory_iterator &RHS) const {\n    return !(*this == RHS);\n  }\n\n  /// Gets the current level. Starting path is at level 0.\n  int level() const {\n    assert(!State->Stack.empty() &&\n           \"Cannot get level without any iteration state\");\n    return State->Stack.size() - 1;\n  }\n\n  void no_push() { State->HasNoPushRequest = true; }\n};\n\n/// The virtual file system interface.\nclass FileSystem : public llvm::ThreadSafeRefCountedBase<FileSystem> {\npublic:\n  virtual ~FileSystem();\n\n  /// Get the status of the entry at \\p Path, if one exists.\n  virtual llvm::ErrorOr<Status> status(const Twine &Path) = 0;\n\n  /// Get a \\p File object for the file at \\p Path, if one exists.\n  virtual llvm::ErrorOr<std::unique_ptr<File>>\n  openFileForRead(const Twine &Path) = 0;\n\n  /// This is a convenience method that opens a file, gets its content and then\n  /// closes the file.\n  llvm::ErrorOr<std::unique_ptr<llvm::MemoryBuffer>>\n  getBufferForFile(const Twine &Name, int64_t FileSize = -1,\n                   bool RequiresNullTerminator = true, bool IsVolatile = false);\n\n  /// Get a directory_iterator for \\p Dir.\n  /// \\note The 'end' iterator is directory_iterator().\n  virtual directory_iterator dir_begin(const Twine &Dir,\n                                       std::error_code &EC) = 0;\n\n  /// Set the working directory. This will affect all following operations on\n  /// this file system and may propagate down for nested file systems.\n  virtual std::error_code setCurrentWorkingDirectory(const Twine &Path) = 0;\n\n  /// Get the working directory of this file system.\n  virtual llvm::ErrorOr<std::string> getCurrentWorkingDirectory() const = 0;\n\n  /// Gets real path of \\p Path e.g. collapse all . and .. patterns, resolve\n  /// symlinks. For real file system, this uses `llvm::sys::fs::real_path`.\n  /// This returns errc::operation_not_permitted if not implemented by subclass.\n  virtual std::error_code getRealPath(const Twine &Path,\n                                      SmallVectorImpl<char> &Output) const;\n\n  /// Check whether a file exists. Provided for convenience.\n  bool exists(const Twine &Path);\n\n  /// Is the file mounted on a local filesystem?\n  virtual std::error_code isLocal(const Twine &Path, bool &Result);\n\n  /// Make \\a Path an absolute path.\n  ///\n  /// Makes \\a Path absolute using the current directory if it is not already.\n  /// An empty \\a Path will result in the current directory.\n  ///\n  /// /absolute/path   => /absolute/path\n  /// relative/../path => <current-directory>/relative/../path\n  ///\n  /// \\param Path A path that is modified to be an absolute path.\n  /// \\returns success if \\a path has been made absolute, otherwise a\n  ///          platform-specific error_code.\n  virtual std::error_code makeAbsolute(SmallVectorImpl<char> &Path) const;\n};\n\n/// Gets an \\p vfs::FileSystem for the 'real' file system, as seen by\n/// the operating system.\n/// The working directory is linked to the process's working directory.\n/// (This is usually thread-hostile).\nIntrusiveRefCntPtr<FileSystem> getRealFileSystem();\n\n/// Create an \\p vfs::FileSystem for the 'real' file system, as seen by\n/// the operating system.\n/// It has its own working directory, independent of (but initially equal to)\n/// that of the process.\nstd::unique_ptr<FileSystem> createPhysicalFileSystem();\n\n/// A file system that allows overlaying one \\p AbstractFileSystem on top\n/// of another.\n///\n/// Consists of a stack of >=1 \\p FileSystem objects, which are treated as being\n/// one merged file system. When there is a directory that exists in more than\n/// one file system, the \\p OverlayFileSystem contains a directory containing\n/// the union of their contents.  The attributes (permissions, etc.) of the\n/// top-most (most recently added) directory are used.  When there is a file\n/// that exists in more than one file system, the file in the top-most file\n/// system overrides the other(s).\nclass OverlayFileSystem : public FileSystem {\n  using FileSystemList = SmallVector<IntrusiveRefCntPtr<FileSystem>, 1>;\n\n  /// The stack of file systems, implemented as a list in order of\n  /// their addition.\n  FileSystemList FSList;\n\npublic:\n  OverlayFileSystem(IntrusiveRefCntPtr<FileSystem> Base);\n\n  /// Pushes a file system on top of the stack.\n  void pushOverlay(IntrusiveRefCntPtr<FileSystem> FS);\n\n  llvm::ErrorOr<Status> status(const Twine &Path) override;\n  llvm::ErrorOr<std::unique_ptr<File>>\n  openFileForRead(const Twine &Path) override;\n  directory_iterator dir_begin(const Twine &Dir, std::error_code &EC) override;\n  llvm::ErrorOr<std::string> getCurrentWorkingDirectory() const override;\n  std::error_code setCurrentWorkingDirectory(const Twine &Path) override;\n  std::error_code isLocal(const Twine &Path, bool &Result) override;\n  std::error_code getRealPath(const Twine &Path,\n                              SmallVectorImpl<char> &Output) const override;\n\n  using iterator = FileSystemList::reverse_iterator;\n  using const_iterator = FileSystemList::const_reverse_iterator;\n  using reverse_iterator = FileSystemList::iterator;\n  using const_reverse_iterator = FileSystemList::const_iterator;\n\n  /// Get an iterator pointing to the most recently added file system.\n  iterator overlays_begin() { return FSList.rbegin(); }\n  const_iterator overlays_begin() const { return FSList.rbegin(); }\n\n  /// Get an iterator pointing one-past the least recently added file system.\n  iterator overlays_end() { return FSList.rend(); }\n  const_iterator overlays_end() const { return FSList.rend(); }\n\n  /// Get an iterator pointing to the least recently added file system.\n  reverse_iterator overlays_rbegin() { return FSList.begin(); }\n  const_reverse_iterator overlays_rbegin() const { return FSList.begin(); }\n\n  /// Get an iterator pointing one-past the most recently added file system.\n  reverse_iterator overlays_rend() { return FSList.end(); }\n  const_reverse_iterator overlays_rend() const { return FSList.end(); }\n};\n\n/// By default, this delegates all calls to the underlying file system. This\n/// is useful when derived file systems want to override some calls and still\n/// proxy other calls.\nclass ProxyFileSystem : public FileSystem {\npublic:\n  explicit ProxyFileSystem(IntrusiveRefCntPtr<FileSystem> FS)\n      : FS(std::move(FS)) {}\n\n  llvm::ErrorOr<Status> status(const Twine &Path) override {\n    return FS->status(Path);\n  }\n  llvm::ErrorOr<std::unique_ptr<File>>\n  openFileForRead(const Twine &Path) override {\n    return FS->openFileForRead(Path);\n  }\n  directory_iterator dir_begin(const Twine &Dir, std::error_code &EC) override {\n    return FS->dir_begin(Dir, EC);\n  }\n  llvm::ErrorOr<std::string> getCurrentWorkingDirectory() const override {\n    return FS->getCurrentWorkingDirectory();\n  }\n  std::error_code setCurrentWorkingDirectory(const Twine &Path) override {\n    return FS->setCurrentWorkingDirectory(Path);\n  }\n  std::error_code getRealPath(const Twine &Path,\n                              SmallVectorImpl<char> &Output) const override {\n    return FS->getRealPath(Path, Output);\n  }\n  std::error_code isLocal(const Twine &Path, bool &Result) override {\n    return FS->isLocal(Path, Result);\n  }\n\nprotected:\n  FileSystem &getUnderlyingFS() { return *FS; }\n\nprivate:\n  IntrusiveRefCntPtr<FileSystem> FS;\n\n  virtual void anchor();\n};\n\nnamespace detail {\n\nclass InMemoryDirectory;\nclass InMemoryFile;\n\n} // namespace detail\n\n/// An in-memory file system.\nclass InMemoryFileSystem : public FileSystem {\n  std::unique_ptr<detail::InMemoryDirectory> Root;\n  std::string WorkingDirectory;\n  bool UseNormalizedPaths = true;\n\n  /// If HardLinkTarget is non-null, a hardlink is created to the To path which\n  /// must be a file. If it is null then it adds the file as the public addFile.\n  bool addFile(const Twine &Path, time_t ModificationTime,\n               std::unique_ptr<llvm::MemoryBuffer> Buffer,\n               Optional<uint32_t> User, Optional<uint32_t> Group,\n               Optional<llvm::sys::fs::file_type> Type,\n               Optional<llvm::sys::fs::perms> Perms,\n               const detail::InMemoryFile *HardLinkTarget);\n\npublic:\n  explicit InMemoryFileSystem(bool UseNormalizedPaths = true);\n  ~InMemoryFileSystem() override;\n\n  /// Add a file containing a buffer or a directory to the VFS with a\n  /// path. The VFS owns the buffer.  If present, User, Group, Type\n  /// and Perms apply to the newly-created file or directory.\n  /// \\return true if the file or directory was successfully added,\n  /// false if the file or directory already exists in the file system with\n  /// different contents.\n  bool addFile(const Twine &Path, time_t ModificationTime,\n               std::unique_ptr<llvm::MemoryBuffer> Buffer,\n               Optional<uint32_t> User = None, Optional<uint32_t> Group = None,\n               Optional<llvm::sys::fs::file_type> Type = None,\n               Optional<llvm::sys::fs::perms> Perms = None);\n\n  /// Add a hard link to a file.\n  /// Here hard links are not intended to be fully equivalent to the classical\n  /// filesystem. Both the hard link and the file share the same buffer and\n  /// status (and thus have the same UniqueID). Because of this there is no way\n  /// to distinguish between the link and the file after the link has been\n  /// added.\n  ///\n  /// The To path must be an existing file or a hardlink. The From file must not\n  /// have been added before. The To Path must not be a directory. The From Node\n  /// is added as a hard link which points to the resolved file of To Node.\n  /// \\return true if the above condition is satisfied and hardlink was\n  /// successfully created, false otherwise.\n  bool addHardLink(const Twine &From, const Twine &To);\n\n  /// Add a buffer to the VFS with a path. The VFS does not own the buffer.\n  /// If present, User, Group, Type and Perms apply to the newly-created file\n  /// or directory.\n  /// \\return true if the file or directory was successfully added,\n  /// false if the file or directory already exists in the file system with\n  /// different contents.\n  bool addFileNoOwn(const Twine &Path, time_t ModificationTime,\n                    const llvm::MemoryBufferRef &Buffer,\n                    Optional<uint32_t> User = None,\n                    Optional<uint32_t> Group = None,\n                    Optional<llvm::sys::fs::file_type> Type = None,\n                    Optional<llvm::sys::fs::perms> Perms = None);\n\n  std::string toString() const;\n\n  /// Return true if this file system normalizes . and .. in paths.\n  bool useNormalizedPaths() const { return UseNormalizedPaths; }\n\n  llvm::ErrorOr<Status> status(const Twine &Path) override;\n  llvm::ErrorOr<std::unique_ptr<File>>\n  openFileForRead(const Twine &Path) override;\n  directory_iterator dir_begin(const Twine &Dir, std::error_code &EC) override;\n\n  llvm::ErrorOr<std::string> getCurrentWorkingDirectory() const override {\n    return WorkingDirectory;\n  }\n  /// Canonicalizes \\p Path by combining with the current working\n  /// directory and normalizing the path (e.g. remove dots). If the current\n  /// working directory is not set, this returns errc::operation_not_permitted.\n  ///\n  /// This doesn't resolve symlinks as they are not supported in in-memory file\n  /// system.\n  std::error_code getRealPath(const Twine &Path,\n                              SmallVectorImpl<char> &Output) const override;\n  std::error_code isLocal(const Twine &Path, bool &Result) override;\n  std::error_code setCurrentWorkingDirectory(const Twine &Path) override;\n};\n\n/// Get a globally unique ID for a virtual file or directory.\nllvm::sys::fs::UniqueID getNextVirtualUniqueID();\n\n/// Gets a \\p FileSystem for a virtual file system described in YAML\n/// format.\nstd::unique_ptr<FileSystem>\ngetVFSFromYAML(std::unique_ptr<llvm::MemoryBuffer> Buffer,\n               llvm::SourceMgr::DiagHandlerTy DiagHandler,\n               StringRef YAMLFilePath, void *DiagContext = nullptr,\n               IntrusiveRefCntPtr<FileSystem> ExternalFS = getRealFileSystem());\n\nstruct YAMLVFSEntry {\n  template <typename T1, typename T2>\n  YAMLVFSEntry(T1 &&VPath, T2 &&RPath, bool IsDirectory = false)\n      : VPath(std::forward<T1>(VPath)), RPath(std::forward<T2>(RPath)),\n        IsDirectory(IsDirectory) {}\n  std::string VPath;\n  std::string RPath;\n  bool IsDirectory = false;\n};\n\nclass RedirectingFSDirIterImpl;\nclass RedirectingFileSystemParser;\n\n/// A virtual file system parsed from a YAML file.\n///\n/// Currently, this class allows creating virtual files and directories. Virtual\n/// files map to existing external files in \\c ExternalFS, and virtual\n/// directories may either map to existing directories in \\c ExternalFS or list\n/// their contents in the form of other virtual directories and/or files.\n///\n/// The basic structure of the parsed file is:\n/// \\verbatim\n/// {\n///   'version': <version number>,\n///   <optional configuration>\n///   'roots': [\n///              <directory entries>\n///            ]\n/// }\n/// \\endverbatim\n///\n/// All configuration options are optional.\n///   'case-sensitive': <boolean, default=(true for Posix, false for Windows)>\n///   'use-external-names': <boolean, default=true>\n///   'overlay-relative': <boolean, default=false>\n///   'fallthrough': <boolean, default=true>\n///\n/// Virtual directories that list their contents are represented as\n/// \\verbatim\n/// {\n///   'type': 'directory',\n///   'name': <string>,\n///   'contents': [ <file or directory entries> ]\n/// }\n/// \\endverbatim\n///\n/// The default attributes for such virtual directories are:\n/// \\verbatim\n/// MTime = now() when created\n/// Perms = 0777\n/// User = Group = 0\n/// Size = 0\n/// UniqueID = unspecified unique value\n/// \\endverbatim\n///\n/// When a path prefix matches such a directory, the next component in the path\n/// is matched against the entries in the 'contents' array.\n///\n/// Re-mapped directories, on the other hand, are represented as\n/// /// \\verbatim\n/// {\n///   'type': 'directory-remap',\n///   'name': <string>,\n///   'use-external-name': <boolean>, # Optional\n///   'external-contents': <path to external directory>\n/// }\n/// \\endverbatim\n///\n/// and inherit their attributes from the external directory. When a path\n/// prefix matches such an entry, the unmatched components are appended to the\n/// 'external-contents' path, and the resulting path is looked up in the\n/// external file system instead.\n///\n/// Re-mapped files are represented as\n/// \\verbatim\n/// {\n///   'type': 'file',\n///   'name': <string>,\n///   'use-external-name': <boolean>, # Optional\n///   'external-contents': <path to external file>\n/// }\n/// \\endverbatim\n///\n/// Their attributes and file contents are determined by looking up the file at\n/// their 'external-contents' path in the external file system.\n///\n/// For 'file', 'directory' and 'directory-remap' entries the 'name' field may\n/// contain multiple path components (e.g. /path/to/file). However, any\n/// directory in such a path that contains more than one child must be uniquely\n/// represented by a 'directory' entry.\nclass RedirectingFileSystem : public vfs::FileSystem {\npublic:\n  enum EntryKind { EK_Directory, EK_DirectoryRemap, EK_File };\n  enum NameKind { NK_NotSet, NK_External, NK_Virtual };\n\n  /// A single file or directory in the VFS.\n  class Entry {\n    EntryKind Kind;\n    std::string Name;\n\n  public:\n    Entry(EntryKind K, StringRef Name) : Kind(K), Name(Name) {}\n    virtual ~Entry() = default;\n\n    StringRef getName() const { return Name; }\n    EntryKind getKind() const { return Kind; }\n  };\n\n  /// A directory in the vfs with explicitly specified contents.\n  class DirectoryEntry : public Entry {\n    std::vector<std::unique_ptr<Entry>> Contents;\n    Status S;\n\n  public:\n    /// Constructs a directory entry with explicitly specified contents.\n    DirectoryEntry(StringRef Name, std::vector<std::unique_ptr<Entry>> Contents,\n                   Status S)\n        : Entry(EK_Directory, Name), Contents(std::move(Contents)),\n          S(std::move(S)) {}\n\n    /// Constructs an empty directory entry.\n    DirectoryEntry(StringRef Name, Status S)\n        : Entry(EK_Directory, Name), S(std::move(S)) {}\n\n    Status getStatus() { return S; }\n\n    void addContent(std::unique_ptr<Entry> Content) {\n      Contents.push_back(std::move(Content));\n    }\n\n    Entry *getLastContent() const { return Contents.back().get(); }\n\n    using iterator = decltype(Contents)::iterator;\n\n    iterator contents_begin() { return Contents.begin(); }\n    iterator contents_end() { return Contents.end(); }\n\n    static bool classof(const Entry *E) { return E->getKind() == EK_Directory; }\n  };\n\n  /// A file or directory in the vfs that is mapped to a file or directory in\n  /// the external filesystem.\n  class RemapEntry : public Entry {\n    std::string ExternalContentsPath;\n    NameKind UseName;\n\n  protected:\n    RemapEntry(EntryKind K, StringRef Name, StringRef ExternalContentsPath,\n               NameKind UseName)\n        : Entry(K, Name), ExternalContentsPath(ExternalContentsPath),\n          UseName(UseName) {}\n\n  public:\n    StringRef getExternalContentsPath() const { return ExternalContentsPath; }\n\n    /// Whether to use the external path as the name for this file or directory.\n    bool useExternalName(bool GlobalUseExternalName) const {\n      return UseName == NK_NotSet ? GlobalUseExternalName\n                                  : (UseName == NK_External);\n    }\n\n    NameKind getUseName() const { return UseName; }\n\n    static bool classof(const Entry *E) {\n      switch (E->getKind()) {\n      case EK_DirectoryRemap:\n        LLVM_FALLTHROUGH;\n      case EK_File:\n        return true;\n      case EK_Directory:\n        return false;\n      }\n      llvm_unreachable(\"invalid entry kind\");\n    }\n  };\n\n  /// A directory in the vfs that maps to a directory in the external file\n  /// system.\n  class DirectoryRemapEntry : public RemapEntry {\n  public:\n    DirectoryRemapEntry(StringRef Name, StringRef ExternalContentsPath,\n                        NameKind UseName)\n        : RemapEntry(EK_DirectoryRemap, Name, ExternalContentsPath, UseName) {}\n\n    static bool classof(const Entry *E) {\n      return E->getKind() == EK_DirectoryRemap;\n    }\n  };\n\n  /// A file in the vfs that maps to a file in the external file system.\n  class FileEntry : public RemapEntry {\n  public:\n    FileEntry(StringRef Name, StringRef ExternalContentsPath, NameKind UseName)\n        : RemapEntry(EK_File, Name, ExternalContentsPath, UseName) {}\n\n    static bool classof(const Entry *E) { return E->getKind() == EK_File; }\n  };\n\n  /// Represents the result of a path lookup into the RedirectingFileSystem.\n  struct LookupResult {\n    /// The entry the looked-up path corresponds to.\n    Entry *E;\n\n  private:\n    /// When the found Entry is a DirectoryRemapEntry, stores the path in the\n    /// external file system that the looked-up path in the virtual file system\n    //  corresponds to.\n    Optional<std::string> ExternalRedirect;\n\n  public:\n    LookupResult(Entry *E, sys::path::const_iterator Start,\n                 sys::path::const_iterator End);\n\n    /// If the found Entry maps the the input path to a path in the external\n    /// file system (i.e. it is a FileEntry or DirectoryRemapEntry), returns\n    /// that path.\n    Optional<StringRef> getExternalRedirect() const {\n      if (isa<DirectoryRemapEntry>(E))\n        return StringRef(*ExternalRedirect);\n      if (auto *FE = dyn_cast<FileEntry>(E))\n        return FE->getExternalContentsPath();\n      return None;\n    }\n  };\n\nprivate:\n  friend class RedirectingFSDirIterImpl;\n  friend class RedirectingFileSystemParser;\n\n  bool shouldUseExternalFS() const { return IsFallthrough; }\n\n  /// Canonicalize path by removing \".\", \"..\", \"./\", components. This is\n  /// a VFS request, do not bother about symlinks in the path components\n  /// but canonicalize in order to perform the correct entry search.\n  std::error_code makeCanonical(SmallVectorImpl<char> &Path) const;\n\n  /// Whether to fall back to the external file system when an operation fails\n  /// with the given error code on a path associated with the provided Entry.\n  bool shouldFallBackToExternalFS(std::error_code EC, Entry *E = nullptr) const;\n\n  // In a RedirectingFileSystem, keys can be specified in Posix or Windows\n  // style (or even a mixture of both), so this comparison helper allows\n  // slashes (representing a root) to match backslashes (and vice versa).  Note\n  // that, other than the root, path components should not contain slashes or\n  // backslashes.\n  bool pathComponentMatches(llvm::StringRef lhs, llvm::StringRef rhs) const {\n    if ((CaseSensitive ? lhs.equals(rhs) : lhs.equals_lower(rhs)))\n      return true;\n    return (lhs == \"/\" && rhs == \"\\\\\") || (lhs == \"\\\\\" && rhs == \"/\");\n  }\n\n  /// The root(s) of the virtual file system.\n  std::vector<std::unique_ptr<Entry>> Roots;\n\n  /// The current working directory of the file system.\n  std::string WorkingDirectory;\n\n  /// The file system to use for external references.\n  IntrusiveRefCntPtr<FileSystem> ExternalFS;\n\n  /// If IsRelativeOverlay is set, this represents the directory\n  /// path that should be prefixed to each 'external-contents' entry\n  /// when reading from YAML files.\n  std::string ExternalContentsPrefixDir;\n\n  /// @name Configuration\n  /// @{\n\n  /// Whether to perform case-sensitive comparisons.\n  ///\n  /// Currently, case-insensitive matching only works correctly with ASCII.\n  bool CaseSensitive =\n#ifdef _WIN32\n      false;\n#else\n      true;\n#endif\n\n  /// IsRelativeOverlay marks whether a ExternalContentsPrefixDir path must\n  /// be prefixed in every 'external-contents' when reading from YAML files.\n  bool IsRelativeOverlay = false;\n\n  /// Whether to use to use the value of 'external-contents' for the\n  /// names of files.  This global value is overridable on a per-file basis.\n  bool UseExternalNames = true;\n\n  /// Whether to attempt a file lookup in external file system after it wasn't\n  /// found in VFS.\n  bool IsFallthrough = true;\n  /// @}\n\n  RedirectingFileSystem(IntrusiveRefCntPtr<FileSystem> ExternalFS);\n\n  /// Looks up the path <tt>[Start, End)</tt> in \\p From, possibly recursing\n  /// into the contents of \\p From if it is a directory. Returns a LookupResult\n  /// giving the matched entry and, if that entry is a FileEntry or\n  /// DirectoryRemapEntry, the path it redirects to in the external file system.\n  ErrorOr<LookupResult> lookupPathImpl(llvm::sys::path::const_iterator Start,\n                                       llvm::sys::path::const_iterator End,\n                                       Entry *From) const;\n\n  /// Get the status for a path with the provided \\c LookupResult.\n  ErrorOr<Status> status(const Twine &Path, const LookupResult &Result);\n\npublic:\n  /// Looks up \\p Path in \\c Roots and returns a LookupResult giving the\n  /// matched entry and, if the entry was a FileEntry or DirectoryRemapEntry,\n  /// the path it redirects to in the external file system.\n  ErrorOr<LookupResult> lookupPath(StringRef Path) const;\n\n  /// Parses \\p Buffer, which is expected to be in YAML format and\n  /// returns a virtual file system representing its contents.\n  static std::unique_ptr<RedirectingFileSystem>\n  create(std::unique_ptr<MemoryBuffer> Buffer,\n         SourceMgr::DiagHandlerTy DiagHandler, StringRef YAMLFilePath,\n         void *DiagContext, IntrusiveRefCntPtr<FileSystem> ExternalFS);\n\n  /// Redirect each of the remapped files from first to second.\n  static std::unique_ptr<RedirectingFileSystem>\n  create(ArrayRef<std::pair<std::string, std::string>> RemappedFiles,\n         bool UseExternalNames, FileSystem &ExternalFS);\n\n  ErrorOr<Status> status(const Twine &Path) override;\n  ErrorOr<std::unique_ptr<File>> openFileForRead(const Twine &Path) override;\n\n  std::error_code getRealPath(const Twine &Path,\n                              SmallVectorImpl<char> &Output) const override;\n\n  llvm::ErrorOr<std::string> getCurrentWorkingDirectory() const override;\n\n  std::error_code setCurrentWorkingDirectory(const Twine &Path) override;\n\n  std::error_code isLocal(const Twine &Path, bool &Result) override;\n\n  std::error_code makeAbsolute(SmallVectorImpl<char> &Path) const override;\n\n  directory_iterator dir_begin(const Twine &Dir, std::error_code &EC) override;\n\n  void setExternalContentsPrefixDir(StringRef PrefixDir);\n\n  StringRef getExternalContentsPrefixDir() const;\n\n  void setFallthrough(bool Fallthrough);\n\n  std::vector<llvm::StringRef> getRoots() const;\n\n  void dump(raw_ostream &OS) const;\n  void dumpEntry(raw_ostream &OS, Entry *E, int NumSpaces = 0) const;\n#if !defined(NDEBUG) || defined(LLVM_ENABLE_DUMP)\n  LLVM_DUMP_METHOD void dump() const;\n#endif\n};\n\n/// Collect all pairs of <virtual path, real path> entries from the\n/// \\p YAMLFilePath. This is used by the module dependency collector to forward\n/// the entries into the reproducer output VFS YAML file.\nvoid collectVFSFromYAML(\n    std::unique_ptr<llvm::MemoryBuffer> Buffer,\n    llvm::SourceMgr::DiagHandlerTy DiagHandler, StringRef YAMLFilePath,\n    SmallVectorImpl<YAMLVFSEntry> &CollectedEntries,\n    void *DiagContext = nullptr,\n    IntrusiveRefCntPtr<FileSystem> ExternalFS = getRealFileSystem());\n\nclass YAMLVFSWriter {\n  std::vector<YAMLVFSEntry> Mappings;\n  Optional<bool> IsCaseSensitive;\n  Optional<bool> IsOverlayRelative;\n  Optional<bool> UseExternalNames;\n  std::string OverlayDir;\n\n  void addEntry(StringRef VirtualPath, StringRef RealPath, bool IsDirectory);\n\npublic:\n  YAMLVFSWriter() = default;\n\n  void addFileMapping(StringRef VirtualPath, StringRef RealPath);\n  void addDirectoryMapping(StringRef VirtualPath, StringRef RealPath);\n\n  void setCaseSensitivity(bool CaseSensitive) {\n    IsCaseSensitive = CaseSensitive;\n  }\n\n  void setUseExternalNames(bool UseExtNames) { UseExternalNames = UseExtNames; }\n\n  void setOverlayDir(StringRef OverlayDirectory) {\n    IsOverlayRelative = true;\n    OverlayDir.assign(OverlayDirectory.str());\n  }\n\n  const std::vector<YAMLVFSEntry> &getMappings() const { return Mappings; }\n\n  void write(llvm::raw_ostream &OS);\n};\n\n} // namespace vfs\n} // namespace llvm\n\n#endif // LLVM_SUPPORT_VIRTUALFILESYSTEM_H\n"}, "32": {"id": 32, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/raw_ostream.h", "content": "//===--- raw_ostream.h - Raw output stream ----------------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n//  This file defines the raw_ostream class.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_SUPPORT_RAW_OSTREAM_H\n#define LLVM_SUPPORT_RAW_OSTREAM_H\n\n#include \"llvm/ADT/SmallVector.h\"\n#include \"llvm/ADT/StringRef.h\"\n#include \"llvm/Support/DataTypes.h\"\n#include <cassert>\n#include <chrono>\n#include <cstddef>\n#include <cstdint>\n#include <cstring>\n#include <string>\n#include <system_error>\n#include <type_traits>\n\nnamespace llvm {\n\nclass formatv_object_base;\nclass format_object_base;\nclass FormattedString;\nclass FormattedNumber;\nclass FormattedBytes;\ntemplate <class T> class LLVM_NODISCARD Expected;\n\nnamespace sys {\nnamespace fs {\nenum FileAccess : unsigned;\nenum OpenFlags : unsigned;\nenum CreationDisposition : unsigned;\nclass FileLocker;\n} // end namespace fs\n} // end namespace sys\n\n/// This class implements an extremely fast bulk output stream that can *only*\n/// output to a stream.  It does not support seeking, reopening, rewinding, line\n/// buffered disciplines etc. It is a simple buffer that outputs\n/// a chunk at a time.\nclass raw_ostream {\npublic:\n  // Class kinds to support LLVM-style RTTI.\n  enum class OStreamKind {\n    OK_OStream,\n    OK_FDStream,\n  };\n\nprivate:\n  OStreamKind Kind;\n\n  /// The buffer is handled in such a way that the buffer is\n  /// uninitialized, unbuffered, or out of space when OutBufCur >=\n  /// OutBufEnd. Thus a single comparison suffices to determine if we\n  /// need to take the slow path to write a single character.\n  ///\n  /// The buffer is in one of three states:\n  ///  1. Unbuffered (BufferMode == Unbuffered)\n  ///  1. Uninitialized (BufferMode != Unbuffered && OutBufStart == 0).\n  ///  2. Buffered (BufferMode != Unbuffered && OutBufStart != 0 &&\n  ///               OutBufEnd - OutBufStart >= 1).\n  ///\n  /// If buffered, then the raw_ostream owns the buffer if (BufferMode ==\n  /// InternalBuffer); otherwise the buffer has been set via SetBuffer and is\n  /// managed by the subclass.\n  ///\n  /// If a subclass installs an external buffer using SetBuffer then it can wait\n  /// for a \\see write_impl() call to handle the data which has been put into\n  /// this buffer.\n  char *OutBufStart, *OutBufEnd, *OutBufCur;\n  bool ColorEnabled = false;\n\n  /// Optional stream this stream is tied to. If this stream is written to, the\n  /// tied-to stream will be flushed first.\n  raw_ostream *TiedStream = nullptr;\n\n  enum class BufferKind {\n    Unbuffered = 0,\n    InternalBuffer,\n    ExternalBuffer\n  } BufferMode;\n\npublic:\n  // color order matches ANSI escape sequence, don't change\n  enum class Colors {\n    BLACK = 0,\n    RED,\n    GREEN,\n    YELLOW,\n    BLUE,\n    MAGENTA,\n    CYAN,\n    WHITE,\n    SAVEDCOLOR,\n    RESET,\n  };\n\n  static constexpr Colors BLACK = Colors::BLACK;\n  static constexpr Colors RED = Colors::RED;\n  static constexpr Colors GREEN = Colors::GREEN;\n  static constexpr Colors YELLOW = Colors::YELLOW;\n  static constexpr Colors BLUE = Colors::BLUE;\n  static constexpr Colors MAGENTA = Colors::MAGENTA;\n  static constexpr Colors CYAN = Colors::CYAN;\n  static constexpr Colors WHITE = Colors::WHITE;\n  static constexpr Colors SAVEDCOLOR = Colors::SAVEDCOLOR;\n  static constexpr Colors RESET = Colors::RESET;\n\n  explicit raw_ostream(bool unbuffered = false,\n                       OStreamKind K = OStreamKind::OK_OStream)\n      : Kind(K), BufferMode(unbuffered ? BufferKind::Unbuffered\n                                       : BufferKind::InternalBuffer) {\n    // Start out ready to flush.\n    OutBufStart = OutBufEnd = OutBufCur = nullptr;\n  }\n\n  raw_ostream(const raw_ostream &) = delete;\n  void operator=(const raw_ostream &) = delete;\n\n  virtual ~raw_ostream();\n\n  /// tell - Return the current offset with the file.\n  uint64_t tell() const { return current_pos() + GetNumBytesInBuffer(); }\n\n  OStreamKind get_kind() const { return Kind; }\n\n  //===--------------------------------------------------------------------===//\n  // Configuration Interface\n  //===--------------------------------------------------------------------===//\n\n  /// If possible, pre-allocate \\p ExtraSize bytes for stream data.\n  /// i.e. it extends internal buffers to keep additional ExtraSize bytes.\n  /// So that the stream could keep at least tell() + ExtraSize bytes\n  /// without re-allocations. reserveExtraSpace() does not change\n  /// the size/data of the stream.\n  virtual void reserveExtraSpace(uint64_t ExtraSize) {}\n\n  /// Set the stream to be buffered, with an automatically determined buffer\n  /// size.\n  void SetBuffered();\n\n  /// Set the stream to be buffered, using the specified buffer size.\n  void SetBufferSize(size_t Size) {\n    flush();\n    SetBufferAndMode(new char[Size], Size, BufferKind::InternalBuffer);\n  }\n\n  size_t GetBufferSize() const {\n    // If we're supposed to be buffered but haven't actually gotten around\n    // to allocating the buffer yet, return the value that would be used.\n    if (BufferMode != BufferKind::Unbuffered && OutBufStart == nullptr)\n      return preferred_buffer_size();\n\n    // Otherwise just return the size of the allocated buffer.\n    return OutBufEnd - OutBufStart;\n  }\n\n  /// Set the stream to be unbuffered. When unbuffered, the stream will flush\n  /// after every write. This routine will also flush the buffer immediately\n  /// when the stream is being set to unbuffered.\n  void SetUnbuffered() {\n    flush();\n    SetBufferAndMode(nullptr, 0, BufferKind::Unbuffered);\n  }\n\n  size_t GetNumBytesInBuffer() const {\n    return OutBufCur - OutBufStart;\n  }\n\n  //===--------------------------------------------------------------------===//\n  // Data Output Interface\n  //===--------------------------------------------------------------------===//\n\n  void flush() {\n    if (OutBufCur != OutBufStart)\n      flush_nonempty();\n  }\n\n  raw_ostream &operator<<(char C) {\n    if (OutBufCur >= OutBufEnd)\n      return write(C);\n    *OutBufCur++ = C;\n    return *this;\n  }\n\n  raw_ostream &operator<<(unsigned char C) {\n    if (OutBufCur >= OutBufEnd)\n      return write(C);\n    *OutBufCur++ = C;\n    return *this;\n  }\n\n  raw_ostream &operator<<(signed char C) {\n    if (OutBufCur >= OutBufEnd)\n      return write(C);\n    *OutBufCur++ = C;\n    return *this;\n  }\n\n  raw_ostream &operator<<(StringRef Str) {\n    // Inline fast path, particularly for strings with a known length.\n    size_t Size = Str.size();\n\n    // Make sure we can use the fast path.\n    if (Size > (size_t)(OutBufEnd - OutBufCur))\n      return write(Str.data(), Size);\n\n    if (Size) {\n      memcpy(OutBufCur, Str.data(), Size);\n      OutBufCur += Size;\n    }\n    return *this;\n  }\n\n  raw_ostream &operator<<(const char *Str) {\n    // Inline fast path, particularly for constant strings where a sufficiently\n    // smart compiler will simplify strlen.\n\n    return this->operator<<(StringRef(Str));\n  }\n\n  raw_ostream &operator<<(const std::string &Str) {\n    // Avoid the fast path, it would only increase code size for a marginal win.\n    return write(Str.data(), Str.length());\n  }\n\n  raw_ostream &operator<<(const SmallVectorImpl<char> &Str) {\n    return write(Str.data(), Str.size());\n  }\n\n  raw_ostream &operator<<(unsigned long N);\n  raw_ostream &operator<<(long N);\n  raw_ostream &operator<<(unsigned long long N);\n  raw_ostream &operator<<(long long N);\n  raw_ostream &operator<<(const void *P);\n\n  raw_ostream &operator<<(unsigned int N) {\n    return this->operator<<(static_cast<unsigned long>(N));\n  }\n\n  raw_ostream &operator<<(int N) {\n    return this->operator<<(static_cast<long>(N));\n  }\n\n  raw_ostream &operator<<(double N);\n\n  /// Output \\p N in hexadecimal, without any prefix or padding.\n  raw_ostream &write_hex(unsigned long long N);\n\n  // Change the foreground color of text.\n  raw_ostream &operator<<(Colors C);\n\n  /// Output a formatted UUID with dash separators.\n  using uuid_t = uint8_t[16];\n  raw_ostream &write_uuid(const uuid_t UUID);\n\n  /// Output \\p Str, turning '\\\\', '\\t', '\\n', '\"', and anything that doesn't\n  /// satisfy llvm::isPrint into an escape sequence.\n  raw_ostream &write_escaped(StringRef Str, bool UseHexEscapes = false);\n\n  raw_ostream &write(unsigned char C);\n  raw_ostream &write(const char *Ptr, size_t Size);\n\n  // Formatted output, see the format() function in Support/Format.h.\n  raw_ostream &operator<<(const format_object_base &Fmt);\n\n  // Formatted output, see the leftJustify() function in Support/Format.h.\n  raw_ostream &operator<<(const FormattedString &);\n\n  // Formatted output, see the formatHex() function in Support/Format.h.\n  raw_ostream &operator<<(const FormattedNumber &);\n\n  // Formatted output, see the formatv() function in Support/FormatVariadic.h.\n  raw_ostream &operator<<(const formatv_object_base &);\n\n  // Formatted output, see the format_bytes() function in Support/Format.h.\n  raw_ostream &operator<<(const FormattedBytes &);\n\n  /// indent - Insert 'NumSpaces' spaces.\n  raw_ostream &indent(unsigned NumSpaces);\n\n  /// write_zeros - Insert 'NumZeros' nulls.\n  raw_ostream &write_zeros(unsigned NumZeros);\n\n  /// Changes the foreground color of text that will be output from this point\n  /// forward.\n  /// @param Color ANSI color to use, the special SAVEDCOLOR can be used to\n  /// change only the bold attribute, and keep colors untouched\n  /// @param Bold bold/brighter text, default false\n  /// @param BG if true change the background, default: change foreground\n  /// @returns itself so it can be used within << invocations\n  virtual raw_ostream &changeColor(enum Colors Color, bool Bold = false,\n                                   bool BG = false);\n\n  /// Resets the colors to terminal defaults. Call this when you are done\n  /// outputting colored text, or before program exit.\n  virtual raw_ostream &resetColor();\n\n  /// Reverses the foreground and background colors.\n  virtual raw_ostream &reverseColor();\n\n  /// This function determines if this stream is connected to a \"tty\" or\n  /// \"console\" window. That is, the output would be displayed to the user\n  /// rather than being put on a pipe or stored in a file.\n  virtual bool is_displayed() const { return false; }\n\n  /// This function determines if this stream is displayed and supports colors.\n  /// The result is unaffected by calls to enable_color().\n  virtual bool has_colors() const { return is_displayed(); }\n\n  // Enable or disable colors. Once enable_colors(false) is called,\n  // changeColor() has no effect until enable_colors(true) is called.\n  virtual void enable_colors(bool enable) { ColorEnabled = enable; }\n\n  /// Tie this stream to the specified stream. Replaces any existing tied-to\n  /// stream. Specifying a nullptr unties the stream.\n  void tie(raw_ostream *TieTo) { TiedStream = TieTo; }\n\n  //===--------------------------------------------------------------------===//\n  // Subclass Interface\n  //===--------------------------------------------------------------------===//\n\nprivate:\n  /// The is the piece of the class that is implemented by subclasses.  This\n  /// writes the \\p Size bytes starting at\n  /// \\p Ptr to the underlying stream.\n  ///\n  /// This function is guaranteed to only be called at a point at which it is\n  /// safe for the subclass to install a new buffer via SetBuffer.\n  ///\n  /// \\param Ptr The start of the data to be written. For buffered streams this\n  /// is guaranteed to be the start of the buffer.\n  ///\n  /// \\param Size The number of bytes to be written.\n  ///\n  /// \\invariant { Size > 0 }\n  virtual void write_impl(const char *Ptr, size_t Size) = 0;\n\n  /// Return the current position within the stream, not counting the bytes\n  /// currently in the buffer.\n  virtual uint64_t current_pos() const = 0;\n\nprotected:\n  /// Use the provided buffer as the raw_ostream buffer. This is intended for\n  /// use only by subclasses which can arrange for the output to go directly\n  /// into the desired output buffer, instead of being copied on each flush.\n  void SetBuffer(char *BufferStart, size_t Size) {\n    SetBufferAndMode(BufferStart, Size, BufferKind::ExternalBuffer);\n  }\n\n  /// Return an efficient buffer size for the underlying output mechanism.\n  virtual size_t preferred_buffer_size() const;\n\n  /// Return the beginning of the current stream buffer, or 0 if the stream is\n  /// unbuffered.\n  const char *getBufferStart() const { return OutBufStart; }\n\n  //===--------------------------------------------------------------------===//\n  // Private Interface\n  //===--------------------------------------------------------------------===//\nprivate:\n  /// Install the given buffer and mode.\n  void SetBufferAndMode(char *BufferStart, size_t Size, BufferKind Mode);\n\n  /// Flush the current buffer, which is known to be non-empty. This outputs the\n  /// currently buffered data and resets the buffer to empty.\n  void flush_nonempty();\n\n  /// Copy data into the buffer. Size must not be greater than the number of\n  /// unused bytes in the buffer.\n  void copy_to_buffer(const char *Ptr, size_t Size);\n\n  /// Compute whether colors should be used and do the necessary work such as\n  /// flushing. The result is affected by calls to enable_color().\n  bool prepare_colors();\n\n  /// Flush the tied-to stream (if present) and then write the required data.\n  void flush_tied_then_write(const char *Ptr, size_t Size);\n\n  virtual void anchor();\n};\n\n/// Call the appropriate insertion operator, given an rvalue reference to a\n/// raw_ostream object and return a stream of the same type as the argument.\ntemplate <typename OStream, typename T>\nstd::enable_if_t<!std::is_reference<OStream>::value &&\n                     std::is_base_of<raw_ostream, OStream>::value,\n                 OStream &&>\noperator<<(OStream &&OS, const T &Value) {\n  OS << Value;\n  return std::move(OS);\n}\n\n/// An abstract base class for streams implementations that also support a\n/// pwrite operation. This is useful for code that can mostly stream out data,\n/// but needs to patch in a header that needs to know the output size.\nclass raw_pwrite_stream : public raw_ostream {\n  virtual void pwrite_impl(const char *Ptr, size_t Size, uint64_t Offset) = 0;\n  void anchor() override;\n\npublic:\n  explicit raw_pwrite_stream(bool Unbuffered = false,\n                             OStreamKind K = OStreamKind::OK_OStream)\n      : raw_ostream(Unbuffered, K) {}\n  void pwrite(const char *Ptr, size_t Size, uint64_t Offset) {\n#ifndef NDEBUG\n    uint64_t Pos = tell();\n    // /dev/null always reports a pos of 0, so we cannot perform this check\n    // in that case.\n    if (Pos)\n      assert(Size + Offset <= Pos && \"We don't support extending the stream\");\n#endif\n    pwrite_impl(Ptr, Size, Offset);\n  }\n};\n\n//===----------------------------------------------------------------------===//\n// File Output Streams\n//===----------------------------------------------------------------------===//\n\n/// A raw_ostream that writes to a file descriptor.\n///\nclass raw_fd_ostream : public raw_pwrite_stream {\n  int FD;\n  bool ShouldClose;\n  bool SupportsSeeking = false;\n  mutable Optional<bool> HasColors;\n\n#ifdef _WIN32\n  /// True if this fd refers to a Windows console device. Mintty and other\n  /// terminal emulators are TTYs, but they are not consoles.\n  bool IsWindowsConsole = false;\n#endif\n\n  std::error_code EC;\n\n  uint64_t pos = 0;\n\n  /// See raw_ostream::write_impl.\n  void write_impl(const char *Ptr, size_t Size) override;\n\n  void pwrite_impl(const char *Ptr, size_t Size, uint64_t Offset) override;\n\n  /// Return the current position within the stream, not counting the bytes\n  /// currently in the buffer.\n  uint64_t current_pos() const override { return pos; }\n\n  /// Determine an efficient buffer size.\n  size_t preferred_buffer_size() const override;\n\n  void anchor() override;\n\nprotected:\n  /// Set the flag indicating that an output error has been encountered.\n  void error_detected(std::error_code EC) { this->EC = EC; }\n\n  /// Return the file descriptor.\n  int get_fd() const { return FD; }\n\n  // Update the file position by increasing \\p Delta.\n  void inc_pos(uint64_t Delta) { pos += Delta; }\n\npublic:\n  /// Open the specified file for writing. If an error occurs, information\n  /// about the error is put into EC, and the stream should be immediately\n  /// destroyed;\n  /// \\p Flags allows optional flags to control how the file will be opened.\n  ///\n  /// As a special case, if Filename is \"-\", then the stream will use\n  /// STDOUT_FILENO instead of opening a file. This will not close the stdout\n  /// descriptor.\n  raw_fd_ostream(StringRef Filename, std::error_code &EC);\n  raw_fd_ostream(StringRef Filename, std::error_code &EC,\n                 sys::fs::CreationDisposition Disp);\n  raw_fd_ostream(StringRef Filename, std::error_code &EC,\n                 sys::fs::FileAccess Access);\n  raw_fd_ostream(StringRef Filename, std::error_code &EC,\n                 sys::fs::OpenFlags Flags);\n  raw_fd_ostream(StringRef Filename, std::error_code &EC,\n                 sys::fs::CreationDisposition Disp, sys::fs::FileAccess Access,\n                 sys::fs::OpenFlags Flags);\n\n  /// FD is the file descriptor that this writes to.  If ShouldClose is true,\n  /// this closes the file when the stream is destroyed. If FD is for stdout or\n  /// stderr, it will not be closed.\n  raw_fd_ostream(int fd, bool shouldClose, bool unbuffered = false,\n                 OStreamKind K = OStreamKind::OK_OStream);\n\n  ~raw_fd_ostream() override;\n\n  /// Manually flush the stream and close the file. Note that this does not call\n  /// fsync.\n  void close();\n\n  bool supportsSeeking() const { return SupportsSeeking; }\n\n  /// Flushes the stream and repositions the underlying file descriptor position\n  /// to the offset specified from the beginning of the file.\n  uint64_t seek(uint64_t off);\n\n  bool is_displayed() const override;\n\n  bool has_colors() const override;\n\n  std::error_code error() const { return EC; }\n\n  /// Return the value of the flag in this raw_fd_ostream indicating whether an\n  /// output error has been encountered.\n  /// This doesn't implicitly flush any pending output.  Also, it doesn't\n  /// guarantee to detect all errors unless the stream has been closed.\n  bool has_error() const { return bool(EC); }\n\n  /// Set the flag read by has_error() to false. If the error flag is set at the\n  /// time when this raw_ostream's destructor is called, report_fatal_error is\n  /// called to report the error. Use clear_error() after handling the error to\n  /// avoid this behavior.\n  ///\n  ///   \"Errors should never pass silently.\n  ///    Unless explicitly silenced.\"\n  ///      - from The Zen of Python, by Tim Peters\n  ///\n  void clear_error() { EC = std::error_code(); }\n\n  /// Locks the underlying file.\n  ///\n  /// @returns RAII object that releases the lock upon leaving the scope, if the\n  ///          locking was successful. Otherwise returns corresponding\n  ///          error code.\n  ///\n  /// The function blocks the current thread until the lock become available or\n  /// error occurs.\n  ///\n  /// Possible use of this function may be as follows:\n  ///\n  ///   @code{.cpp}\n  ///   if (auto L = stream.lock()) {\n  ///     // ... do action that require file to be locked.\n  ///   } else {\n  ///     handleAllErrors(std::move(L.takeError()), [&](ErrorInfoBase &EIB) {\n  ///       // ... handle lock error.\n  ///     });\n  ///   }\n  ///   @endcode\n  LLVM_NODISCARD Expected<sys::fs::FileLocker> lock();\n\n  /// Tries to lock the underlying file within the specified period.\n  ///\n  /// @returns RAII object that releases the lock upon leaving the scope, if the\n  ///          locking was successful. Otherwise returns corresponding\n  ///          error code.\n  ///\n  /// It is used as @ref lock.\n  LLVM_NODISCARD\n  Expected<sys::fs::FileLocker> tryLockFor(std::chrono::milliseconds Timeout);\n};\n\n/// This returns a reference to a raw_fd_ostream for standard output. Use it\n/// like: outs() << \"foo\" << \"bar\";\nraw_fd_ostream &outs();\n\n/// This returns a reference to a raw_ostream for standard error.\n/// Use it like: errs() << \"foo\" << \"bar\";\n/// By default, the stream is tied to stdout to ensure stdout is flushed before\n/// stderr is written, to ensure the error messages are written in their\n/// expected place.\nraw_fd_ostream &errs();\n\n/// This returns a reference to a raw_ostream which simply discards output.\nraw_ostream &nulls();\n\n//===----------------------------------------------------------------------===//\n// File Streams\n//===----------------------------------------------------------------------===//\n\n/// A raw_ostream of a file for reading/writing/seeking.\n///\nclass raw_fd_stream : public raw_fd_ostream {\npublic:\n  /// Open the specified file for reading/writing/seeking. If an error occurs,\n  /// information about the error is put into EC, and the stream should be\n  /// immediately destroyed.\n  raw_fd_stream(StringRef Filename, std::error_code &EC);\n\n  /// This reads the \\p Size bytes into a buffer pointed by \\p Ptr.\n  ///\n  /// \\param Ptr The start of the buffer to hold data to be read.\n  ///\n  /// \\param Size The number of bytes to be read.\n  ///\n  /// On success, the number of bytes read is returned, and the file position is\n  /// advanced by this number. On error, -1 is returned, use error() to get the\n  /// error code.\n  ssize_t read(char *Ptr, size_t Size);\n\n  /// Check if \\p OS is a pointer of type raw_fd_stream*.\n  static bool classof(const raw_ostream *OS);\n};\n\n//===----------------------------------------------------------------------===//\n// Output Stream Adaptors\n//===----------------------------------------------------------------------===//\n\n/// A raw_ostream that writes to an std::string.  This is a simple adaptor\n/// class. This class does not encounter output errors.\nclass raw_string_ostream : public raw_ostream {\n  std::string &OS;\n\n  /// See raw_ostream::write_impl.\n  void write_impl(const char *Ptr, size_t Size) override;\n\n  /// Return the current position within the stream, not counting the bytes\n  /// currently in the buffer.\n  uint64_t current_pos() const override { return OS.size(); }\n\npublic:\n  explicit raw_string_ostream(std::string &O) : OS(O) {\n    SetUnbuffered();\n  }\n  ~raw_string_ostream() override;\n\n  /// Flushes the stream contents to the target string and returns  the string's\n  /// reference.\n  std::string& str() {\n    flush();\n    return OS;\n  }\n\n  void reserveExtraSpace(uint64_t ExtraSize) override {\n    OS.reserve(tell() + ExtraSize);\n  }\n};\n\n/// A raw_ostream that writes to an SmallVector or SmallString.  This is a\n/// simple adaptor class. This class does not encounter output errors.\n/// raw_svector_ostream operates without a buffer, delegating all memory\n/// management to the SmallString. Thus the SmallString is always up-to-date,\n/// may be used directly and there is no need to call flush().\nclass raw_svector_ostream : public raw_pwrite_stream {\n  SmallVectorImpl<char> &OS;\n\n  /// See raw_ostream::write_impl.\n  void write_impl(const char *Ptr, size_t Size) override;\n\n  void pwrite_impl(const char *Ptr, size_t Size, uint64_t Offset) override;\n\n  /// Return the current position within the stream.\n  uint64_t current_pos() const override;\n\npublic:\n  /// Construct a new raw_svector_ostream.\n  ///\n  /// \\param O The vector to write to; this should generally have at least 128\n  /// bytes free to avoid any extraneous memory overhead.\n  explicit raw_svector_ostream(SmallVectorImpl<char> &O) : OS(O) {\n    SetUnbuffered();\n  }\n\n  ~raw_svector_ostream() override = default;\n\n  void flush() = delete;\n\n  /// Return a StringRef for the vector contents.\n  StringRef str() const { return StringRef(OS.data(), OS.size()); }\n\n  void reserveExtraSpace(uint64_t ExtraSize) override {\n    OS.reserve(tell() + ExtraSize);\n  }\n};\n\n/// A raw_ostream that discards all output.\nclass raw_null_ostream : public raw_pwrite_stream {\n  /// See raw_ostream::write_impl.\n  void write_impl(const char *Ptr, size_t size) override;\n  void pwrite_impl(const char *Ptr, size_t Size, uint64_t Offset) override;\n\n  /// Return the current position within the stream, not counting the bytes\n  /// currently in the buffer.\n  uint64_t current_pos() const override;\n\npublic:\n  explicit raw_null_ostream() = default;\n  ~raw_null_ostream() override;\n};\n\nclass buffer_ostream : public raw_svector_ostream {\n  raw_ostream &OS;\n  SmallVector<char, 0> Buffer;\n\n  virtual void anchor() override;\n\npublic:\n  buffer_ostream(raw_ostream &OS) : raw_svector_ostream(Buffer), OS(OS) {}\n  ~buffer_ostream() override { OS << str(); }\n};\n\nclass buffer_unique_ostream : public raw_svector_ostream {\n  std::unique_ptr<raw_ostream> OS;\n  SmallVector<char, 0> Buffer;\n\n  virtual void anchor() override;\n\npublic:\n  buffer_unique_ostream(std::unique_ptr<raw_ostream> OS)\n      : raw_svector_ostream(Buffer), OS(std::move(OS)) {}\n  ~buffer_unique_ostream() override { *OS << str(); }\n};\n\n} // end namespace llvm\n\n#endif // LLVM_SUPPORT_RAW_OSTREAM_H\n"}, "33": {"id": 33, "path": "/home/vsts/work/1/llvm-project/llvm/utils/FileCheck/FileCheck.cpp", "content": "//===- FileCheck.cpp - Check that File's Contents match what is expected --===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// FileCheck does a line-by line check of a file that validates whether it\n// contains the expected content.  This is useful for regression tests etc.\n//\n// This program exits with an exit status of 2 on error, exit status of 0 if\n// the file matched the expected contents, and exit status of 1 if it did not\n// contain the expected contents.\n//\n//===----------------------------------------------------------------------===//\n\n#include \"llvm/FileCheck/FileCheck.h\"\n#include \"llvm/Support/CommandLine.h\"\n#include \"llvm/Support/InitLLVM.h\"\n#include \"llvm/Support/Process.h\"\n#include \"llvm/Support/WithColor.h\"\n#include \"llvm/Support/raw_ostream.h\"\n#include <cmath>\nusing namespace llvm;\n\nstatic cl::extrahelp FileCheckOptsEnv(\n    \"\\nOptions are parsed from the environment variable FILECHECK_OPTS and\\n\"\n    \"from the command line.\\n\");\n\nstatic cl::opt<std::string>\n    CheckFilename(cl::Positional, cl::desc(\"<check-file>\"), cl::Optional);\n\nstatic cl::opt<std::string>\n    InputFilename(\"input-file\", cl::desc(\"File to check (defaults to stdin)\"),\n                  cl::init(\"-\"), cl::value_desc(\"filename\"));\n\nstatic cl::list<std::string> CheckPrefixes(\n    \"check-prefix\",\n    cl::desc(\"Prefix to use from check file (defaults to 'CHECK')\"));\nstatic cl::alias CheckPrefixesAlias(\n    \"check-prefixes\", cl::aliasopt(CheckPrefixes), cl::CommaSeparated,\n    cl::NotHidden,\n    cl::desc(\n        \"Alias for -check-prefix permitting multiple comma separated values\"));\n\nstatic cl::list<std::string> CommentPrefixes(\n    \"comment-prefixes\", cl::CommaSeparated, cl::Hidden,\n    cl::desc(\"Comma-separated list of comment prefixes to use from check file\\n\"\n             \"(defaults to 'COM,RUN'). Please avoid using this feature in\\n\"\n             \"LLVM's LIT-based test suites, which should be easier to\\n\"\n             \"maintain if they all follow a consistent comment style. This\\n\"\n             \"feature is meant for non-LIT test suites using FileCheck.\"));\n\nstatic cl::opt<bool> NoCanonicalizeWhiteSpace(\n    \"strict-whitespace\",\n    cl::desc(\"Do not treat all horizontal whitespace as equivalent\"));\n\nstatic cl::opt<bool> IgnoreCase(\n    \"ignore-case\",\n    cl::desc(\"Use case-insensitive matching\"));\n\nstatic cl::list<std::string> ImplicitCheckNot(\n    \"implicit-check-not\",\n    cl::desc(\"Add an implicit negative check with this pattern to every\\n\"\n             \"positive check. This can be used to ensure that no instances of\\n\"\n             \"this pattern occur which are not matched by a positive pattern\"),\n    cl::value_desc(\"pattern\"));\n\nstatic cl::list<std::string>\n    GlobalDefines(\"D\", cl::AlwaysPrefix,\n                  cl::desc(\"Define a variable to be used in capture patterns.\"),\n                  cl::value_desc(\"VAR=VALUE\"));\n\nstatic cl::opt<bool> AllowEmptyInput(\n    \"allow-empty\", cl::init(false),\n    cl::desc(\"Allow the input file to be empty. This is useful when making\\n\"\n             \"checks that some error message does not occur, for example.\"));\n\nstatic cl::opt<bool> AllowUnusedPrefixes(\n    \"allow-unused-prefixes\", cl::init(false), cl::ZeroOrMore,\n    cl::desc(\"Allow prefixes to be specified but not appear in the test.\"));\n\nstatic cl::opt<bool> MatchFullLines(\n    \"match-full-lines\", cl::init(false),\n    cl::desc(\"Require all positive matches to cover an entire input line.\\n\"\n             \"Allows leading and trailing whitespace if --strict-whitespace\\n\"\n             \"is not also passed.\"));\n\nstatic cl::opt<bool> EnableVarScope(\n    \"enable-var-scope\", cl::init(false),\n    cl::desc(\"Enables scope for regex variables. Variables with names that\\n\"\n             \"do not start with '$' will be reset at the beginning of\\n\"\n             \"each CHECK-LABEL block.\"));\n\nstatic cl::opt<bool> AllowDeprecatedDagOverlap(\n    \"allow-deprecated-dag-overlap\", cl::init(false),\n    cl::desc(\"Enable overlapping among matches in a group of consecutive\\n\"\n             \"CHECK-DAG directives.  This option is deprecated and is only\\n\"\n             \"provided for convenience as old tests are migrated to the new\\n\"\n             \"non-overlapping CHECK-DAG implementation.\\n\"));\n\nstatic cl::opt<bool> Verbose(\n    \"v\", cl::init(false), cl::ZeroOrMore,\n    cl::desc(\"Print directive pattern matches, or add them to the input dump\\n\"\n             \"if enabled.\\n\"));\n\nstatic cl::opt<bool> VerboseVerbose(\n    \"vv\", cl::init(false), cl::ZeroOrMore,\n    cl::desc(\"Print information helpful in diagnosing internal FileCheck\\n\"\n             \"issues, or add it to the input dump if enabled.  Implies\\n\"\n             \"-v.\\n\"));\n\n// The order of DumpInputValue members affects their precedence, as documented\n// for -dump-input below.\nenum DumpInputValue {\n  DumpInputNever,\n  DumpInputFail,\n  DumpInputAlways,\n  DumpInputHelp\n};\n\nstatic cl::list<DumpInputValue> DumpInputs(\n    \"dump-input\",\n    cl::desc(\"Dump input to stderr, adding annotations representing\\n\"\n             \"currently enabled diagnostics.  When there are multiple\\n\"\n             \"occurrences of this option, the <value> that appears earliest\\n\"\n             \"in the list below has precedence.  The default is 'fail'.\\n\"),\n    cl::value_desc(\"mode\"),\n    cl::values(clEnumValN(DumpInputHelp, \"help\", \"Explain input dump and quit\"),\n               clEnumValN(DumpInputAlways, \"always\", \"Always dump input\"),\n               clEnumValN(DumpInputFail, \"fail\", \"Dump input on failure\"),\n               clEnumValN(DumpInputNever, \"never\", \"Never dump input\")));\n\n// The order of DumpInputFilterValue members affects their precedence, as\n// documented for -dump-input-filter below.\nenum DumpInputFilterValue {\n  DumpInputFilterError,\n  DumpInputFilterAnnotation,\n  DumpInputFilterAnnotationFull,\n  DumpInputFilterAll\n};\n\nstatic cl::list<DumpInputFilterValue> DumpInputFilters(\n    \"dump-input-filter\",\n    cl::desc(\"In the dump requested by -dump-input, print only input lines of\\n\"\n             \"kind <value> plus any context specified by -dump-input-context.\\n\"\n             \"When there are multiple occurrences of this option, the <value>\\n\"\n             \"that appears earliest in the list below has precedence.  The\\n\"\n             \"default is 'error' when -dump-input=fail, and it's 'all' when\\n\"\n             \"-dump-input=always.\\n\"),\n    cl::values(clEnumValN(DumpInputFilterAll, \"all\", \"All input lines\"),\n               clEnumValN(DumpInputFilterAnnotationFull, \"annotation-full\",\n                          \"Input lines with annotations\"),\n               clEnumValN(DumpInputFilterAnnotation, \"annotation\",\n                          \"Input lines with starting points of annotations\"),\n               clEnumValN(DumpInputFilterError, \"error\",\n                          \"Input lines with starting points of error \"\n                          \"annotations\")));\n\nstatic cl::list<unsigned> DumpInputContexts(\n    \"dump-input-context\", cl::value_desc(\"N\"),\n    cl::desc(\"In the dump requested by -dump-input, print <N> input lines\\n\"\n             \"before and <N> input lines after any lines specified by\\n\"\n             \"-dump-input-filter.  When there are multiple occurrences of\\n\"\n             \"this option, the largest specified <N> has precedence.  The\\n\"\n             \"default is 5.\\n\"));\n\ntypedef cl::list<std::string>::const_iterator prefix_iterator;\n\n\n\n\n\n\n\nstatic void DumpCommandLine(int argc, char **argv) {\n  errs() << \"FileCheck command line: \";\n  for (int I = 0; I < argc; I++)\n    errs() << \" \" << argv[I];\n  errs() << \"\\n\";\n}\n\nstruct MarkerStyle {\n  /// The starting char (before tildes) for marking the line.\n  char Lead;\n  /// What color to use for this annotation.\n  raw_ostream::Colors Color;\n  /// A note to follow the marker, or empty string if none.\n  std::string Note;\n  /// Does this marker indicate inclusion by -dump-input-filter=error?\n  bool FiltersAsError;\n  MarkerStyle() {}\n  MarkerStyle(char Lead, raw_ostream::Colors Color,\n              const std::string &Note = \"\", bool FiltersAsError = false)\n      : Lead(Lead), Color(Color), Note(Note), FiltersAsError(FiltersAsError) {\n    assert((!FiltersAsError || !Note.empty()) &&\n           \"expected error diagnostic to have note\");\n  }\n};\n\nstatic MarkerStyle GetMarker(FileCheckDiag::MatchType MatchTy) {\n  switch (MatchTy) {\n  case FileCheckDiag::MatchFoundAndExpected:\n    return MarkerStyle('^', raw_ostream::GREEN);\n  case FileCheckDiag::MatchFoundButExcluded:\n    return MarkerStyle('!', raw_ostream::RED, \"error: no match expected\",\n                       /*FiltersAsError=*/true);\n  case FileCheckDiag::MatchFoundButWrongLine:\n    return MarkerStyle('!', raw_ostream::RED, \"error: match on wrong line\",\n                       /*FiltersAsError=*/true);\n  case FileCheckDiag::MatchFoundButDiscarded:\n    return MarkerStyle('!', raw_ostream::CYAN,\n                       \"discard: overlaps earlier match\");\n  case FileCheckDiag::MatchNoneAndExcluded:\n    return MarkerStyle('X', raw_ostream::GREEN);\n  case FileCheckDiag::MatchNoneButExpected:\n    return MarkerStyle('X', raw_ostream::RED, \"error: no match found\",\n                       /*FiltersAsError=*/true);\n  case FileCheckDiag::MatchFuzzy:\n    return MarkerStyle('?', raw_ostream::MAGENTA, \"possible intended match\",\n                       /*FiltersAsError=*/true);\n  }\n  llvm_unreachable_internal(\"unexpected match type\");\n}\n\nstatic void DumpInputAnnotationHelp(raw_ostream &OS) {\n  OS << \"The following description was requested by -dump-input=help to\\n\"\n     << \"explain the input dump printed by FileCheck.\\n\"\n     << \"\\n\"\n     << \"Related command-line options:\\n\"\n     << \"\\n\"\n     << \"  - -dump-input=<value> enables or disables the input dump\\n\"\n     << \"  - -dump-input-filter=<value> filters the input lines\\n\"\n     << \"  - -dump-input-context=<N> adjusts the context of filtered lines\\n\"\n     << \"  - -v and -vv add more annotations\\n\"\n     << \"  - -color forces colors to be enabled both in the dump and below\\n\"\n     << \"  - -help documents the above options in more detail\\n\"\n     << \"\\n\"\n     << \"These options can also be set via FILECHECK_OPTS.  For example, for\\n\"\n     << \"maximum debugging output on failures:\\n\"\n     << \"\\n\"\n     << \"  $ FILECHECK_OPTS='-dump-input-filter=all -vv -color' ninja check\\n\"\n     << \"\\n\"\n     << \"Input dump annotation format:\\n\"\n     << \"\\n\";\n\n  // Labels for input lines.\n  OS << \"  - \";\n  WithColor(OS, raw_ostream::SAVEDCOLOR, true) << \"L:\";\n  OS << \"     labels line number L of the input file\\n\"\n     << \"           An extra space is added after each input line to represent\"\n     << \" the\\n\"\n     << \"           newline character\\n\";\n\n  // Labels for annotation lines.\n  OS << \"  - \";\n  WithColor(OS, raw_ostream::SAVEDCOLOR, true) << \"T:L\";\n  OS << \"    labels the only match result for either (1) a pattern of type T\"\n     << \" from\\n\"\n     << \"           line L of the check file if L is an integer or (2) the\"\n     << \" I-th implicit\\n\"\n     << \"           pattern if L is \\\"imp\\\" followed by an integer \"\n     << \"I (index origin one)\\n\";\n  OS << \"  - \";\n  WithColor(OS, raw_ostream::SAVEDCOLOR, true) << \"T:L'N\";\n  OS << \"  labels the Nth match result for such a pattern\\n\";\n\n  // Markers on annotation lines.\n  OS << \"  - \";\n  WithColor(OS, raw_ostream::SAVEDCOLOR, true) << \"^~~\";\n  OS << \"    marks good match (reported if -v)\\n\"\n     << \"  - \";\n  WithColor(OS, raw_ostream::SAVEDCOLOR, true) << \"!~~\";\n  OS << \"    marks bad match, such as:\\n\"\n     << \"           - CHECK-NEXT on same line as previous match (error)\\n\"\n     << \"           - CHECK-NOT found (error)\\n\"\n     << \"           - CHECK-DAG overlapping match (discarded, reported if \"\n     << \"-vv)\\n\"\n     << \"  - \";\n  WithColor(OS, raw_ostream::SAVEDCOLOR, true) << \"X~~\";\n  OS << \"    marks search range when no match is found, such as:\\n\"\n     << \"           - CHECK-NEXT not found (error)\\n\"\n     << \"           - CHECK-NOT not found (success, reported if -vv)\\n\"\n     << \"           - CHECK-DAG not found after discarded matches (error)\\n\"\n     << \"  - \";\n  WithColor(OS, raw_ostream::SAVEDCOLOR, true) << \"?\";\n  OS << \"      marks fuzzy match when no match is found\\n\";\n\n  // Elided lines.\n  OS << \"  - \";\n  WithColor(OS, raw_ostream::SAVEDCOLOR, true) << \"...\";\n  OS << \"    indicates elided input lines and annotations, as specified by\\n\"\n     << \"           -dump-input-filter and -dump-input-context\\n\";\n\n  // Colors.\n  OS << \"  - colors \";\n  WithColor(OS, raw_ostream::GREEN, true) << \"success\";\n  OS << \", \";\n  WithColor(OS, raw_ostream::RED, true) << \"error\";\n  OS << \", \";\n  WithColor(OS, raw_ostream::MAGENTA, true) << \"fuzzy match\";\n  OS << \", \";\n  WithColor(OS, raw_ostream::CYAN, true, false) << \"discarded match\";\n  OS << \", \";\n  WithColor(OS, raw_ostream::CYAN, true, true) << \"unmatched input\";\n  OS << \"\\n\";\n}\n\n/// An annotation for a single input line.\nstruct InputAnnotation {\n  /// The index of the match result across all checks\n  unsigned DiagIndex;\n  /// The label for this annotation.\n  std::string Label;\n  /// Is this the initial fragment of a diagnostic that has been broken across\n  /// multiple lines?\n  bool IsFirstLine;\n  /// What input line (one-origin indexing) this annotation marks.  This might\n  /// be different from the starting line of the original diagnostic if\n  /// !IsFirstLine.\n  unsigned InputLine;\n  /// The column range (one-origin indexing, open end) in which to mark the\n  /// input line.  If InputEndCol is UINT_MAX, treat it as the last column\n  /// before the newline.\n  unsigned InputStartCol, InputEndCol;\n  /// The marker to use.\n  MarkerStyle Marker;\n  /// Whether this annotation represents a good match for an expected pattern.\n  bool FoundAndExpectedMatch;\n};\n\n/// Get an abbreviation for the check type.\nstatic std::string GetCheckTypeAbbreviation(Check::FileCheckType Ty) {\n  switch (Ty) {\n  case Check::CheckPlain:\n    if (Ty.getCount() > 1)\n      return \"count\";\n    return \"check\";\n  case Check::CheckNext:\n    return \"next\";\n  case Check::CheckSame:\n    return \"same\";\n  case Check::CheckNot:\n    return \"not\";\n  case Check::CheckDAG:\n    return \"dag\";\n  case Check::CheckLabel:\n    return \"label\";\n  case Check::CheckEmpty:\n    return \"empty\";\n  case Check::CheckComment:\n    return \"com\";\n  case Check::CheckEOF:\n    return \"eof\";\n  case Check::CheckBadNot:\n    return \"bad-not\";\n  case Check::CheckBadCount:\n    return \"bad-count\";\n  case Check::CheckNone:\n    llvm_unreachable(\"invalid FileCheckType\");\n  }\n  llvm_unreachable(\"unknown FileCheckType\");\n}\n\nstatic void\nBuildInputAnnotations(const SourceMgr &SM, unsigned CheckFileBufferID,\n                      const std::pair<unsigned, unsigned> &ImpPatBufferIDRange,\n                      const std::vector<FileCheckDiag> &Diags,\n                      std::vector<InputAnnotation> &Annotations,\n                      unsigned &LabelWidth) {\n  // How many diagnostics have we seen so far?\n  unsigned DiagCount = 0;\n  // How many diagnostics has the current check seen so far?\n  unsigned CheckDiagCount = 0;\n  // What's the widest label?\n  LabelWidth = 0;\n  for (auto DiagItr = Diags.begin(), DiagEnd = Diags.end(); DiagItr != DiagEnd;\n       ++DiagItr) {\n    InputAnnotation A;\n    A.DiagIndex = DiagCount++;\n\n    // Build label, which uniquely identifies this check result.\n    unsigned CheckBufferID = SM.FindBufferContainingLoc(DiagItr->CheckLoc);\n    auto CheckLineAndCol =\n        SM.getLineAndColumn(DiagItr->CheckLoc, CheckBufferID);\n    llvm::raw_string_ostream Label(A.Label);\n    Label << GetCheckTypeAbbreviation(DiagItr->CheckTy) << \":\";\n    if (CheckBufferID == CheckFileBufferID)\n      Label << CheckLineAndCol.first;\n    else if (ImpPatBufferIDRange.first <= CheckBufferID &&\n             CheckBufferID < ImpPatBufferIDRange.second)\n      Label << \"imp\" << (CheckBufferID - ImpPatBufferIDRange.first + 1);\n    else\n      llvm_unreachable(\"expected diagnostic's check location to be either in \"\n                       \"the check file or for an implicit pattern\");\n    unsigned CheckDiagIndex = UINT_MAX;\n    auto DiagNext = std::next(DiagItr);\n    if (DiagNext != DiagEnd && DiagItr->CheckTy == DiagNext->CheckTy &&\n        DiagItr->CheckLoc == DiagNext->CheckLoc)\n      CheckDiagIndex = CheckDiagCount++;\n    else if (CheckDiagCount) {\n      CheckDiagIndex = CheckDiagCount;\n      CheckDiagCount = 0;\n    }\n    if (CheckDiagIndex != UINT_MAX)\n      Label << \"'\" << CheckDiagIndex;\n    Label.flush();\n    LabelWidth = std::max((std::string::size_type)LabelWidth, A.Label.size());\n\n    A.Marker = GetMarker(DiagItr->MatchTy);\n    if (!DiagItr->Note.empty()) {\n      A.Marker.Note = DiagItr->Note;\n      // It's less confusing if notes that don't actually have ranges don't have\n      // markers.  For example, a marker for 'with \"VAR\" equal to \"5\"' would\n      // seem to indicate where \"VAR\" matches, but the location we actually have\n      // for the marker simply points to the start of the match/search range for\n      // the full pattern of which the substitution is potentially just one\n      // component.\n      if (DiagItr->InputStartLine == DiagItr->InputEndLine &&\n          DiagItr->InputStartCol == DiagItr->InputEndCol)\n        A.Marker.Lead = ' ';\n    }\n    A.FoundAndExpectedMatch =\n        DiagItr->MatchTy == FileCheckDiag::MatchFoundAndExpected;\n\n    // Compute the mark location, and break annotation into multiple\n    // annotations if it spans multiple lines.\n    A.IsFirstLine = true;\n    A.InputLine = DiagItr->InputStartLine;\n    A.InputStartCol = DiagItr->InputStartCol;\n    if (DiagItr->InputStartLine == DiagItr->InputEndLine) {\n      // Sometimes ranges are empty in order to indicate a specific point, but\n      // that would mean nothing would be marked, so adjust the range to\n      // include the following character.\n      A.InputEndCol =\n          std::max(DiagItr->InputStartCol + 1, DiagItr->InputEndCol);\n      Annotations.push_back(A);\n    } else {\n      assert(DiagItr->InputStartLine < DiagItr->InputEndLine &&\n             \"expected input range not to be inverted\");\n      A.InputEndCol = UINT_MAX;\n      Annotations.push_back(A);\n      for (unsigned L = DiagItr->InputStartLine + 1, E = DiagItr->InputEndLine;\n           L <= E; ++L) {\n        // If a range ends before the first column on a line, then it has no\n        // characters on that line, so there's nothing to render.\n        if (DiagItr->InputEndCol == 1 && L == E)\n          break;\n        InputAnnotation B;\n        B.DiagIndex = A.DiagIndex;\n        B.Label = A.Label;\n        B.IsFirstLine = false;\n        B.InputLine = L;\n        B.Marker = A.Marker;\n        B.Marker.Lead = '~';\n        B.Marker.Note = \"\";\n        B.InputStartCol = 1;\n        if (L != E)\n          B.InputEndCol = UINT_MAX;\n        else\n          B.InputEndCol = DiagItr->InputEndCol;\n        B.FoundAndExpectedMatch = A.FoundAndExpectedMatch;\n        Annotations.push_back(B);\n      }\n    }\n  }\n}\n\nstatic unsigned FindInputLineInFilter(\n    DumpInputFilterValue DumpInputFilter, unsigned CurInputLine,\n    const std::vector<InputAnnotation>::iterator &AnnotationBeg,\n    const std::vector<InputAnnotation>::iterator &AnnotationEnd) {\n  if (DumpInputFilter == DumpInputFilterAll)\n    return CurInputLine;\n  for (auto AnnotationItr = AnnotationBeg; AnnotationItr != AnnotationEnd;\n       ++AnnotationItr) {\n    switch (DumpInputFilter) {\n    case DumpInputFilterAll:\n      llvm_unreachable(\"unexpected DumpInputFilterAll\");\n      break;\n    case DumpInputFilterAnnotationFull:\n      return AnnotationItr->InputLine;\n    case DumpInputFilterAnnotation:\n      if (AnnotationItr->IsFirstLine)\n        return AnnotationItr->InputLine;\n      break;\n    case DumpInputFilterError:\n      if (AnnotationItr->IsFirstLine && AnnotationItr->Marker.FiltersAsError)\n        return AnnotationItr->InputLine;\n      break;\n    }\n  }\n  return UINT_MAX;\n}\n\n/// To OS, print a vertical ellipsis (right-justified at LabelWidth) if it would\n/// occupy less lines than ElidedLines, but print ElidedLines otherwise.  Either\n/// way, clear ElidedLines.  Thus, if ElidedLines is empty, do nothing.\nstatic void DumpEllipsisOrElidedLines(raw_ostream &OS, std::string &ElidedLines,\n                                      unsigned LabelWidth) {\n  if (ElidedLines.empty())\n    return;\n  unsigned EllipsisLines = 3;\n  if (EllipsisLines < StringRef(ElidedLines).count('\\n')) {\n    for (unsigned i = 0; i < EllipsisLines; ++i) {\n      WithColor(OS, raw_ostream::BLACK, /*Bold=*/true)\n          << right_justify(\".\", LabelWidth);\n      OS << '\\n';\n    }\n  } else\n    OS << ElidedLines;\n  ElidedLines.clear();\n}\n\nstatic void DumpAnnotatedInput(raw_ostream &OS, const FileCheckRequest &Req,\n                               DumpInputFilterValue DumpInputFilter,\n                               unsigned DumpInputContext,\n                               StringRef InputFileText,\n                               std::vector<InputAnnotation> &Annotations,\n                               unsigned LabelWidth) {\n  OS << \"Input was:\\n<<<<<<\\n\";\n\n  // Sort annotations.\n  llvm::sort(Annotations,\n             [](const InputAnnotation &A, const InputAnnotation &B) {\n               // 1. Sort annotations in the order of the input lines.\n               //\n               // This makes it easier to find relevant annotations while\n               // iterating input lines in the implementation below.  FileCheck\n               // does not always produce diagnostics in the order of input\n               // lines due to, for example, CHECK-DAG and CHECK-NOT.\n               if (A.InputLine != B.InputLine)\n                 return A.InputLine < B.InputLine;\n               // 2. Sort annotations in the temporal order FileCheck produced\n               // their associated diagnostics.\n               //\n               // This sort offers several benefits:\n               //\n               // A. On a single input line, the order of annotations reflects\n               //    the FileCheck logic for processing directives/patterns.\n               //    This can be helpful in understanding cases in which the\n               //    order of the associated directives/patterns in the check\n               //    file or on the command line either (i) does not match the\n               //    temporal order in which FileCheck looks for matches for the\n               //    directives/patterns (due to, for example, CHECK-LABEL,\n               //    CHECK-NOT, or `--implicit-check-not`) or (ii) does match\n               //    that order but does not match the order of those\n               //    diagnostics along an input line (due to, for example,\n               //    CHECK-DAG).\n               //\n               //    On the other hand, because our presentation format presents\n               //    input lines in order, there's no clear way to offer the\n               //    same benefit across input lines.  For consistency, it might\n               //    then seem worthwhile to have annotations on a single line\n               //    also sorted in input order (that is, by input column).\n               //    However, in practice, this appears to be more confusing\n               //    than helpful.  Perhaps it's intuitive to expect annotations\n               //    to be listed in the temporal order in which they were\n               //    produced except in cases the presentation format obviously\n               //    and inherently cannot support it (that is, across input\n               //    lines).\n               //\n               // B. When diagnostics' annotations are split among multiple\n               //    input lines, the user must track them from one input line\n               //    to the next.  One property of the sort chosen here is that\n               //    it facilitates the user in this regard by ensuring the\n               //    following: when comparing any two input lines, a\n               //    diagnostic's annotations are sorted in the same position\n               //    relative to all other diagnostics' annotations.\n               return A.DiagIndex < B.DiagIndex;\n             });\n\n  // Compute the width of the label column.\n  const unsigned char *InputFilePtr = InputFileText.bytes_begin(),\n                      *InputFileEnd = InputFileText.bytes_end();\n  unsigned LineCount = InputFileText.count('\\n');\n  if (InputFileEnd[-1] != '\\n')\n    ++LineCount;\n  unsigned LineNoWidth = std::log10(LineCount) + 1;\n  // +3 below adds spaces (1) to the left of the (right-aligned) line numbers\n  // on input lines and (2) to the right of the (left-aligned) labels on\n  // annotation lines so that input lines and annotation lines are more\n  // visually distinct.  For example, the spaces on the annotation lines ensure\n  // that input line numbers and check directive line numbers never align\n  // horizontally.  Those line numbers might not even be for the same file.\n  // One space would be enough to achieve that, but more makes it even easier\n  // to see.\n  LabelWidth = std::max(LabelWidth, LineNoWidth) + 3;\n\n  // Print annotated input lines.\n  unsigned PrevLineInFilter = 0; // 0 means none so far\n  unsigned NextLineInFilter = 0; // 0 means uncomputed, UINT_MAX means none\n  std::string ElidedLines;\n  raw_string_ostream ElidedLinesOS(ElidedLines);\n  ColorMode TheColorMode =\n      WithColor(OS).colorsEnabled() ? ColorMode::Enable : ColorMode::Disable;\n  if (TheColorMode == ColorMode::Enable)\n    ElidedLinesOS.enable_colors(true);\n  auto AnnotationItr = Annotations.begin(), AnnotationEnd = Annotations.end();\n  for (unsigned Line = 1;\n       InputFilePtr != InputFileEnd || AnnotationItr != AnnotationEnd;\n       ++Line) {\n    const unsigned char *InputFileLine = InputFilePtr;\n\n    // Compute the previous and next line included by the filter.\n    if (NextLineInFilter < Line)\n      NextLineInFilter = FindInputLineInFilter(DumpInputFilter, Line,\n                                               AnnotationItr, AnnotationEnd);\n    assert(NextLineInFilter && \"expected NextLineInFilter to be computed\");\n    if (NextLineInFilter == Line)\n      PrevLineInFilter = Line;\n\n    // Elide this input line and its annotations if it's not within the\n    // context specified by -dump-input-context of an input line included by\n    // -dump-input-filter.  However, in case the resulting ellipsis would occupy\n    // more lines than the input lines and annotations it elides, buffer the\n    // elided lines and annotations so we can print them instead.\n    raw_ostream *LineOS = &OS;\n    if ((!PrevLineInFilter || PrevLineInFilter + DumpInputContext < Line) &&\n        (NextLineInFilter == UINT_MAX ||\n         Line + DumpInputContext < NextLineInFilter))\n      LineOS = &ElidedLinesOS;\n    else {\n      LineOS = &OS;\n      DumpEllipsisOrElidedLines(OS, ElidedLinesOS.str(), LabelWidth);\n    }\n\n    // Print right-aligned line number.\n    WithColor(*LineOS, raw_ostream::BLACK, /*Bold=*/true, /*BF=*/false,\n              TheColorMode)\n        << format_decimal(Line, LabelWidth) << \": \";\n\n    // For the case where -v and colors are enabled, find the annotations for\n    // good matches for expected patterns in order to highlight everything\n    // else in the line.  There are no such annotations if -v is disabled.\n    std::vector<InputAnnotation> FoundAndExpectedMatches;\n    if (Req.Verbose && TheColorMode == ColorMode::Enable) {\n      for (auto I = AnnotationItr; I != AnnotationEnd && I->InputLine == Line;\n           ++I) {\n        if (I->FoundAndExpectedMatch)\n          FoundAndExpectedMatches.push_back(*I);\n      }\n    }\n\n    // Print numbered line with highlighting where there are no matches for\n    // expected patterns.\n    bool Newline = false;\n    {\n      WithColor COS(*LineOS, raw_ostream::SAVEDCOLOR, /*Bold=*/false,\n                    /*BG=*/false, TheColorMode);\n      bool InMatch = false;\n      if (Req.Verbose)\n        COS.changeColor(raw_ostream::CYAN, true, true);\n      for (unsigned Col = 1; InputFilePtr != InputFileEnd && !Newline; ++Col) {\n        bool WasInMatch = InMatch;\n        InMatch = false;\n        for (auto M : FoundAndExpectedMatches) {\n          if (M.InputStartCol <= Col && Col < M.InputEndCol) {\n            InMatch = true;\n            break;\n          }\n        }\n        if (!WasInMatch && InMatch)\n          COS.resetColor();\n        else if (WasInMatch && !InMatch)\n          COS.changeColor(raw_ostream::CYAN, true, true);\n        if (*InputFilePtr == '\\n') {\n          Newline = true;\n          COS << ' ';\n        } else\n          COS << *InputFilePtr;\n        ++InputFilePtr;\n      }\n    }\n    *LineOS << '\\n';\n    unsigned InputLineWidth = InputFilePtr - InputFileLine;\n\n    // Print any annotations.\n    while (AnnotationItr != AnnotationEnd &&\n           AnnotationItr->InputLine == Line) {\n      WithColor COS(*LineOS, AnnotationItr->Marker.Color, /*Bold=*/true,\n                    /*BG=*/false, TheColorMode);\n      // The two spaces below are where the \": \" appears on input lines.\n      COS << left_justify(AnnotationItr->Label, LabelWidth) << \"  \";\n      unsigned Col;\n      for (Col = 1; Col < AnnotationItr->InputStartCol; ++Col)\n        COS << ' ';\n      COS << AnnotationItr->Marker.Lead;\n      // If InputEndCol=UINT_MAX, stop at InputLineWidth.\n      for (++Col; Col < AnnotationItr->InputEndCol && Col <= InputLineWidth;\n           ++Col)\n        COS << '~';\n      const std::string &Note = AnnotationItr->Marker.Note;\n      if (!Note.empty()) {\n        // Put the note at the end of the input line.  If we were to instead\n        // put the note right after the marker, subsequent annotations for the\n        // same input line might appear to mark this note instead of the input\n        // line.\n        for (; Col <= InputLineWidth; ++Col)\n          COS << ' ';\n        COS << ' ' << Note;\n      }\n      COS << '\\n';\n      ++AnnotationItr;\n    }\n  }\n  DumpEllipsisOrElidedLines(OS, ElidedLinesOS.str(), LabelWidth);\n\n  OS << \">>>>>>\\n\";\n}\n\nint main(int argc, char **argv) {\n  // Enable use of ANSI color codes because FileCheck is using them to\n  // highlight text.\n  llvm::sys::Process::UseANSIEscapeCodes(true);\n\n  InitLLVM X(argc, argv);\n  cl::ParseCommandLineOptions(argc, argv, /*Overview*/ \"\", /*Errs*/ nullptr,\n                              \"FILECHECK_OPTS\");\n\n  // Select -dump-input* values.  The -help documentation specifies the default\n  // value and which value to choose if an option is specified multiple times.\n  // In the latter case, the general rule of thumb is to choose the value that\n  // provides the most information.\n  DumpInputValue DumpInput =\n      DumpInputs.empty()\n          ? DumpInputFail\n          : *std::max_element(DumpInputs.begin(), DumpInputs.end());\n  DumpInputFilterValue DumpInputFilter;\n  if (DumpInputFilters.empty())\n    DumpInputFilter = DumpInput == DumpInputAlways ? DumpInputFilterAll\n                                                   : DumpInputFilterError;\n  else\n    DumpInputFilter =\n        *std::max_element(DumpInputFilters.begin(), DumpInputFilters.end());\n  unsigned DumpInputContext = DumpInputContexts.empty()\n                                  ? 5\n                                  : *std::max_element(DumpInputContexts.begin(),\n                                                      DumpInputContexts.end());\n\n  if (DumpInput == DumpInputHelp) {\n    DumpInputAnnotationHelp(outs());\n    return 0;\n  }\n  if (CheckFilename.empty()) {\n    errs() << \"<check-file> not specified\\n\";\n    return 2;\n  }\n\n  FileCheckRequest Req;\n  append_range(Req.CheckPrefixes, CheckPrefixes);\n\n  append_range(Req.CommentPrefixes, CommentPrefixes);\n\n  append_range(Req.ImplicitCheckNot, ImplicitCheckNot);\n\n  bool GlobalDefineError = false;\n  for (StringRef G : GlobalDefines) {\n    size_t EqIdx = G.find('=');\n    if (EqIdx == std::string::npos) {\n      errs() << \"Missing equal sign in command-line definition '-D\" << G\n             << \"'\\n\";\n      GlobalDefineError = true;\n      continue;\n    }\n    if (EqIdx == 0) {\n      errs() << \"Missing variable name in command-line definition '-D\" << G\n             << \"'\\n\";\n      GlobalDefineError = true;\n      continue;\n    }\n    Req.GlobalDefines.push_back(G);\n  }\n  if (GlobalDefineError)\n    return 2;\n\n  Req.AllowEmptyInput = AllowEmptyInput;\n  Req.AllowUnusedPrefixes = AllowUnusedPrefixes;\n  Req.EnableVarScope = EnableVarScope;\n  Req.AllowDeprecatedDagOverlap = AllowDeprecatedDagOverlap;\n  Req.Verbose = Verbose;\n  Req.VerboseVerbose = VerboseVerbose;\n  Req.NoCanonicalizeWhiteSpace = NoCanonicalizeWhiteSpace;\n  Req.MatchFullLines = MatchFullLines;\n  Req.IgnoreCase = IgnoreCase;\n\n  if (VerboseVerbose)\n    Req.Verbose = true;\n\n  FileCheck FC(Req);\n  if (!FC.ValidateCheckPrefixes())\n    return 2;\n\n  Regex PrefixRE = FC.buildCheckPrefixRegex();\n  std::string REError;\n  if (!PrefixRE.isValid(REError)) {\n    errs() << \"Unable to combine check-prefix strings into a prefix regular \"\n              \"expression! This is likely a bug in FileCheck's verification of \"\n              \"the check-prefix strings. Regular expression parsing failed \"\n              \"with the following error: \"\n           << REError << \"\\n\";\n    return 2;\n  }\n\n  SourceMgr SM;\n\n  // Read the expected strings from the check file.\n  ErrorOr<std::unique_ptr<MemoryBuffer>> CheckFileOrErr =\n      MemoryBuffer::getFileOrSTDIN(CheckFilename);\n  if (std::error_code EC = CheckFileOrErr.getError()) {\n    errs() << \"Could not open check file '\" << CheckFilename\n           << \"': \" << EC.message() << '\\n';\n    return 2;\n  }\n  MemoryBuffer &CheckFile = *CheckFileOrErr.get();\n\n  SmallString<4096> CheckFileBuffer;\n  StringRef CheckFileText = FC.CanonicalizeFile(CheckFile, CheckFileBuffer);\n\n  unsigned CheckFileBufferID =\n      SM.AddNewSourceBuffer(MemoryBuffer::getMemBuffer(\n                                CheckFileText, CheckFile.getBufferIdentifier()),\n                            SMLoc());\n\n  std::pair<unsigned, unsigned> ImpPatBufferIDRange;\n  if (FC.readCheckFile(SM, CheckFileText, PrefixRE, &ImpPatBufferIDRange))\n    return 2;\n\n  // Open the file to check and add it to SourceMgr.\n  ErrorOr<std::unique_ptr<MemoryBuffer>> InputFileOrErr =\n      MemoryBuffer::getFileOrSTDIN(InputFilename);\n  if (InputFilename == \"-\")\n    InputFilename = \"<stdin>\"; // Overwrite for improved diagnostic messages\n  if (std::error_code EC = InputFileOrErr.getError()) {\n    errs() << \"Could not open input file '\" << InputFilename\n           << \"': \" << EC.message() << '\\n';\n    return 2;\n  }\n  MemoryBuffer &InputFile = *InputFileOrErr.get();\n\n  if (InputFile.getBufferSize() == 0 && !AllowEmptyInput) {\n    errs() << \"FileCheck error: '\" << InputFilename << \"' is empty.\\n\";\n    DumpCommandLine(argc, argv);\n    return 2;\n  }\n\n  SmallString<4096> InputFileBuffer;\n  StringRef InputFileText = FC.CanonicalizeFile(InputFile, InputFileBuffer);\n\n  SM.AddNewSourceBuffer(MemoryBuffer::getMemBuffer(\n                            InputFileText, InputFile.getBufferIdentifier()),\n                        SMLoc());\n\n  std::vector<FileCheckDiag> Diags;\n  int ExitCode = FC.checkInput(SM, InputFileText,\n                               DumpInput == DumpInputNever ? nullptr : &Diags)\n                     ? EXIT_SUCCESS\n                     : 1;\n  if (DumpInput == DumpInputAlways ||\n      (ExitCode == 1 && DumpInput == DumpInputFail)) {\n    errs() << \"\\n\"\n           << \"Input file: \" << InputFilename << \"\\n\"\n           << \"Check file: \" << CheckFilename << \"\\n\"\n           << \"\\n\"\n           << \"-dump-input=help explains the following input dump.\\n\"\n           << \"\\n\";\n    std::vector<InputAnnotation> Annotations;\n    unsigned LabelWidth;\n    BuildInputAnnotations(SM, CheckFileBufferID, ImpPatBufferIDRange, Diags,\n                          Annotations, LabelWidth);\n    DumpAnnotatedInput(errs(), Req, DumpInputFilter, DumpInputContext,\n                       InputFileText, Annotations, LabelWidth);\n  }\n\n  return ExitCode;\n}\n"}}, "reports": [{"events": [{"location": {"col": 29, "file": 0, "line": 33}, "message": "destructor '~Optional' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/APInt.h", "reportHash": "ca107360a67bb90acc0886b7a800d778", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 0, "line": 93}, "message": "default constructor '' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/APInt.h", "reportHash": "321061e27268518405588f9f8b1c3560", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 0, "line": 93}, "message": "destructor '~' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/APInt.h", "reportHash": "f79bc63e906fc6c220190e9233dee1bd", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 22, "file": 1, "line": 22}, "message": "destructor '~APSInt' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/APSInt.h", "reportHash": "489d34dfc702ff671e8c864167ba5d7b", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 41, "file": 2, "line": 41}, "message": "destructor '~ArrayRef' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/ArrayRef.h", "reportHash": "b622c2571a4efc346852bd65271a03e8", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 41, "file": 2, "line": 41}, "message": "move assignment operator 'operator=' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/ArrayRef.h", "reportHash": "4474a6ff0dd2ae926247a1bd628f9a72", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 41, "file": 2, "line": 41}, "message": "move constructor 'ArrayRef' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/ArrayRef.h", "reportHash": "da3b7b9d23b763c2b617c9f38a5adc1f", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 24, "file": 2, "line": 305}, "message": "destructor '~MutableArrayRef' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/ArrayRef.h", "reportHash": "1957c6f57e01068773f7df2ec7919cfb", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 24, "file": 2, "line": 305}, "message": "move assignment operator 'operator=' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/ArrayRef.h", "reportHash": "260ac2d1159cadf6ca6cb12be01edf3c", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 24, "file": 2, "line": 305}, "message": "move constructor 'MutableArrayRef' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/ArrayRef.h", "reportHash": "be4b2f508e0becce58bfb5f456bc0528", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 38, "file": 3, "line": 32}, "message": "destructor '~const_set_bits_iterator_impl' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/BitVector.h", "reportHash": "23bd485e23f1abf8cd9b108346b3348a", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 9, "file": 3, "line": 88}, "message": "destructor '~reference' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/BitVector.h", "reportHash": "3ee1898cfd0fbc72db564f0a4b3a3a41", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 4, "line": 81}, "message": "default constructor 'DebugEpochBase' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/EpochTracker.h", "reportHash": "4381c7b18101150135dba46b9d868b09", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 4, "line": 81}, "message": "destructor '~DebugEpochBase' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/EpochTracker.h", "reportHash": "ed0746baa3123a123c687a890659b8ae", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 9, "file": 4, "line": 85}, "message": "destructor '~HandleBase' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/EpochTracker.h", "reportHash": "33fc68deabe911beb4de142b4fe22e6c", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 9, "file": 4, "line": 85}, "message": "move assignment operator 'operator=' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/EpochTracker.h", "reportHash": "97200e1d6fe1dcd962a58eec105f8a29", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 9, "file": 4, "line": 85}, "message": "move constructor 'HandleBase' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/EpochTracker.h", "reportHash": "237344cdaf09430fbfa1957d64c46688", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 5, "line": 72}, "message": "destructor '~hash_code' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/Hashing.h", "reportHash": "129d46410f1aed4291299541f768959e", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 5, "line": 72}, "message": "move constructor 'hash_code' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/Hashing.h", "reportHash": "720666abacd4f575e6ed45a4647a4511", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 5, "line": 263}, "message": "default constructor 'hash_state' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/Hashing.h", "reportHash": "59ca397a8a95a8b98fbbb52c0c1653e8", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 5, "line": 263}, "message": "destructor '~hash_state' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/Hashing.h", "reportHash": "c3d14561bb4a98d3e77fe2a166084b4e", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 5, "line": 263}, "message": "move assignment operator 'operator=' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/Hashing.h", "reportHash": "ca7923f7ae99554c73a78ff7174f5704", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 5, "line": 263}, "message": "move constructor 'hash_state' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/Hashing.h", "reportHash": "2c479a04d0249644241a449d98235567", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 6, "line": 33}, "message": "destructor '~in_place_t' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/Optional.h", "reportHash": "c5b18e0f83466f41f6ee238bdfe6a283", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 6, "line": 33}, "message": "move constructor 'in_place_t' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/Optional.h", "reportHash": "7cf3a54d2484285ece3ef2bf88cf59d0", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 6, "line": 61}, "message": "destructor '~' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/Optional.h", "reportHash": "085ccc1226f53a8c6c5289dc4379d736", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 13, "file": 6, "line": 70}, "message": "mark 'noexcept'"}, {"location": {"col": 13, "file": 6, "line": 70}, "message": "default constructor 'OptionalStorage' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/Optional.h", "reportHash": "2a1f1b18bd15068af7a826023d0ae71f", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 13, "file": 6, "line": 70}, "message": "mark 'noexcept'"}, {"location": {"col": 13, "file": 6, "line": 70}, "message": "default constructor 'OptionalStorage<T, >' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/Optional.h", "reportHash": "592f933e7d23a6c3626204919f170cb5", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 6, "line": 166}, "message": "destructor '~' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/Optional.h", "reportHash": "085ccc1226f53a8c6c5289dc4379d736", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 6, "line": 166}, "message": "move assignment operator 'operator=' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/Optional.h", "reportHash": "2d71223f53acd5abef7a5a1b860b747a", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 6, "line": 166}, "message": "move constructor '' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/Optional.h", "reportHash": "0a1bfbf140414202b613801d0df9fc34", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 13, "file": 6, "line": 175}, "message": "mark 'noexcept'"}, {"location": {"col": 13, "file": 6, "line": 175}, "message": "default constructor 'OptionalStorage' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/Optional.h", "reportHash": "ac9a582040e00783f860dedb3c09b1c2", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 13, "file": 6, "line": 175}, "message": "mark 'noexcept'"}, {"location": {"col": 13, "file": 6, "line": 175}, "message": "default constructor 'OptionalStorage<type-parameter-0-0, true>' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/Optional.h", "reportHash": "5582bdac0bd8959d1821dfcd12757a79", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 29, "file": 6, "line": 239}, "message": "destructor '~Optional' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/Optional.h", "reportHash": "6d049687cdf1d97163461266f513119d", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 28, "file": 7, "line": 159}, "message": "destructor '~identity' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/STLExtras.h", "reportHash": "362669b3197c5e0fa527d18dc5d36e66", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 28, "file": 7, "line": 159}, "message": "move constructor 'identity' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/STLExtras.h", "reportHash": "e3d569666571c994d5c06fddc77836fa", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 7, "line": 179}, "message": "destructor '~function_ref' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/STLExtras.h", "reportHash": "7fd8d7a9494e30290a546e0bfb4004df", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 7, "line": 179}, "message": "move constructor 'function_ref' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/STLExtras.h", "reportHash": "6b28fcaeac4f1cdd045d848a6189c36f", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 8, "line": 221}, "message": "destructor '~SmallPtrSetIteratorImpl' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/SmallPtrSet.h", "reportHash": "7a1292a06ee0d55dac8800daec3735a9", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 8, "line": 221}, "message": "move assignment operator 'operator=' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/SmallPtrSet.h", "reportHash": "4a48ef9cb35ff7a7673a44d5572ef8c4", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 8, "line": 221}, "message": "move constructor 'SmallPtrSetIteratorImpl' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/SmallPtrSet.h", "reportHash": "f9424cd1f2dc88d065261c3f95d53b82", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 8, "line": 266}, "message": "destructor '~SmallPtrSetIterator' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/SmallPtrSet.h", "reportHash": "8b838994028e5af8a0db070503f8e95b", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 8, "line": 266}, "message": "move assignment operator 'operator=' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/SmallPtrSet.h", "reportHash": "5777399a3e89297f213f15835dc9fb84", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 8, "line": 266}, "message": "move constructor 'SmallPtrSetIterator' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/SmallPtrSet.h", "reportHash": "2ab7709ae1f8ad72b890f51d75f188e2", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 8, "line": 343}, "message": "destructor '~SmallPtrSetImpl' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/SmallPtrSet.h", "reportHash": "4fc45ae5c087df894d3f911008f909ab", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 8, "line": 449}, "message": "destructor '~SmallPtrSet' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/SmallPtrSet.h", "reportHash": "fdf5a1f8b605a3cb012784e45982e833", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 9, "line": 25}, "message": "destructor '~SmallString' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/SmallString.h", "reportHash": "616790e2a7f33394f773fb3c90d4c571", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 31, "file": 10, "line": 45}, "message": "destructor '~SmallVectorBase' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/SmallVector.h", "reportHash": "14b3ec935c919c0860382d6ae85b87c9", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 10, "line": 106}, "message": "destructor '~SmallVectorTemplateCommon' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/SmallVector.h", "reportHash": "48ff608d5e9884aa985d4556363204eb", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 10, "line": 315}, "message": "destructor '~SmallVectorTemplateBase' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/SmallVector.h", "reportHash": "6bf5b3187a4f2174d832d21041ba415f", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 10, "line": 459}, "message": "destructor '~SmallVectorTemplateBase' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/SmallVector.h", "reportHash": "7d619f04871462634e0487acd0d7dd1c", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 10, "line": 1083}, "message": "default constructor 'SmallVectorStorage' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/SmallVector.h", "reportHash": "9bc15112621dd6744f4ae76415b13bce", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 10, "line": 1083}, "message": "destructor '~SmallVectorStorage' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/SmallVector.h", "reportHash": "41c16698baedad2cb9e7ff758365659b", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 41, "file": 10, "line": 1090}, "message": "default constructor 'SmallVectorStorage' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/SmallVector.h", "reportHash": "b346bc3e6f6172509c5e8e525f142022", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 41, "file": 10, "line": 1090}, "message": "destructor '~SmallVectorStorage' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/SmallVector.h", "reportHash": "4c6bc481f555181fa743f0ba57ec5860", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 11, "line": 30}, "message": "destructor '~StringMapImpl' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/StringMap.h", "reportHash": "722727f4251e9031d4e843a0425eae9e", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 12, "line": 23}, "message": "destructor '~StringMapEntryBase' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/StringMapEntry.h", "reportHash": "ee7196f343e9cb9294a16f165a622b04", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 12, "line": 38}, "message": "destructor '~StringMapEntryStorage' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/StringMapEntry.h", "reportHash": "df06e9a169f17867a14ca951504a6db2", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 12, "line": 69}, "message": "destructor '~StringMapEntry' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/StringMapEntry.h", "reportHash": "9f8fdabdf65cd5be5c103261a407957d", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 26, "file": 13, "line": 57}, "message": "destructor '~StringRef' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/StringRef.h", "reportHash": "7ee83ff7d25dbd75ace9d947ede42141", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 26, "file": 13, "line": 57}, "message": "move assignment operator 'operator=' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/StringRef.h", "reportHash": "e75f45ad8fb1c7f99e15d96c2f92b14d", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 26, "file": 13, "line": 57}, "message": "move constructor 'StringRef' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/StringRef.h", "reportHash": "bf47563a914041654f754816a42e65c8", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 22, "file": 13, "line": 356}, "message": "destructor '~' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/StringRef.h", "reportHash": "9878b9766b05fa749fd6f1ae132e90e0", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 9, "file": 13, "line": 872}, "message": "destructor '~StringLiteral' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/StringRef.h", "reportHash": "a4fb76c6f8dda463911e36f1ebf75150", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 9, "file": 13, "line": 872}, "message": "move constructor 'StringLiteral' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/StringRef.h", "reportHash": "5fcd6e5fb85a4cecd607124a2c84b377", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 9, "file": 14, "line": 80}, "message": "destructor '~Twine' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/Twine.h", "reportHash": "09df2c5c6385f9f5348b522dc8565bc7", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 11, "file": 14, "line": 136}, "message": "default constructor 'Child' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/Twine.h", "reportHash": "6078915124bb35e19e1517b718834c7c", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 11, "file": 14, "line": 136}, "message": "destructor '~Child' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/Twine.h", "reportHash": "a0ac70a6942a4491c5244fbd47c6ec40", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 15, "line": 30}, "message": "destructor '~iterator_range' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/iterator_range.h", "reportHash": "abdba9cdccc5ca871ce1da235e99909d", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 15, "line": 30}, "message": "move constructor 'iterator_range' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/iterator_range.h", "reportHash": "f8bb81851e4a6fceaeef5124727cbb6a", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 16, "line": 27}, "message": "default constructor 'FileCheckRequest' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/FileCheck/FileCheck.h", "reportHash": "d6dbf7426315299b04124ffdb7190603", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 16, "line": 27}, "message": "destructor '~FileCheckRequest' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/FileCheck/FileCheck.h", "reportHash": "81f425801b0e6178a47994d8364f1e40", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 16, "line": 76}, "message": "destructor '~FileCheckType' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/FileCheck/FileCheck.h", "reportHash": "5cff79e0ff0ffaafa2487d20e5402f37", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 16, "line": 110}, "message": "destructor '~FileCheckDiag' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/FileCheck/FileCheck.h", "reportHash": "ee02faf957bcf01c2345cb1b2f598fb8", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 46, "file": 17, "line": 27}, "message": "destructor '~AlignedCharArrayUnion' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/AlignOf.h", "reportHash": "b46714c40abcbc8e39110f996270326c", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 18, "line": 39}, "message": "destructor '~Align' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/Alignment.h", "reportHash": "5fe40c47bba72f74912b79d2432fa8aa", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 10, "file": 18, "line": 62}, "message": "destructor '~LogValue' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/Alignment.h", "reportHash": "9866eb95c01304e977d8afd58e0ae85c", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 10, "file": 18, "line": 62}, "message": "move constructor 'LogValue' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/Alignment.h", "reportHash": "4b8249570485d81dda2d04dabbfd0928", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 18, "line": 119}, "message": "destructor '~MaybeAlign' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/Alignment.h", "reportHash": "fcf7d30e051b96f5cd8ccffc93d9ce8a", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 36, "file": 19, "line": 33}, "message": "default constructor 'AllocatorBase' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/AllocatorBase.h", "reportHash": "1f8a192f2566fc5364dcbe41ecda92b5", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 36, "file": 19, "line": 33}, "message": "destructor '~AllocatorBase' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/AllocatorBase.h", "reportHash": "96189349f2b1224b6365c7a234e2d721", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 19, "line": 80}, "message": "default constructor 'MallocAllocator' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/AllocatorBase.h", "reportHash": "c98ea37c5c6ed59cb284eb457fe1756a", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 19, "line": 80}, "message": "destructor '~MallocAllocator' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/AllocatorBase.h", "reportHash": "af7a8fd9489338064021dc463f53df8c", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 20, "line": 207}, "message": "destructor '~SubCommand' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/CommandLine.h", "reportHash": "d6c870ab19f5beb9123016825ff5981e", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 25, "file": 20, "line": 316}, "message": "destructor '~' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/CommandLine.h", "reportHash": "737c4ed9dab977fae263332a5ea58a40", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 25, "file": 20, "line": 316}, "message": "move constructor '' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/CommandLine.h", "reportHash": "2ad85a2a33c537419d5bbe76a39db171", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 20, "line": 411}, "message": "destructor '~desc' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/CommandLine.h", "reportHash": "9cc3ef17a15a78cc3f662b4caa73c325", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 20, "line": 421}, "message": "destructor '~value_desc' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/CommandLine.h", "reportHash": "011d13be50544c7306d817dfbc93eb28", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 28, "file": 20, "line": 433}, "message": "destructor '~initializer' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/CommandLine.h", "reportHash": "edb6674e89e93d308adeabd186bf78fb", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 28, "file": 20, "line": 433}, "message": "move constructor 'initializer' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/CommandLine.h", "reportHash": "3a10f60ec2ed08b4e981244a2bbf7f57", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 20, "line": 608}, "message": "destructor '~OptionValue' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/CommandLine.h", "reportHash": "96ffdd75a572bb00ee9fe13d4c262822", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 20, "line": 608}, "message": "move assignment operator 'operator=' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/CommandLine.h", "reportHash": "4750b1be472a1f7159d6771aa588726b", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 20, "line": 608}, "message": "move constructor 'OptionValue' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/CommandLine.h", "reportHash": "813d37434e3d2e13f522183cffb7e750", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 20, "line": 642}, "message": "destructor '~OptionValue' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/CommandLine.h", "reportHash": "c5725be57f994da118a04cb4aea118bb", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 20, "line": 663}, "message": "destructor '~OptionEnumValue' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/CommandLine.h", "reportHash": "2197dcebf75d19a4f379c8dfdace59c1", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 20, "line": 663}, "message": "move assignment operator 'operator=' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/CommandLine.h", "reportHash": "77b1fef40b39df69ed17c8668c0348e4", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 20, "line": 663}, "message": "move constructor 'OptionEnumValue' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/CommandLine.h", "reportHash": "7fe0c28f99e20a72e8027785472572a2", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 20, "line": 677}, "message": "destructor '~ValuesClass' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/CommandLine.h", "reportHash": "f82c7cb2d00c1bed7c64dbd2d6506d4e", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 9, "file": 20, "line": 714}, "message": "destructor '~GenericOptionInfo' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/CommandLine.h", "reportHash": "1b02a5e002a7a68e59f9d9bbdbca7d33", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 9, "file": 20, "line": 714}, "message": "move assignment operator 'operator=' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/CommandLine.h", "reportHash": "098c605b680079b96ff51f37f811a9f8", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 9, "file": 20, "line": 714}, "message": "move constructor 'GenericOptionInfo' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/CommandLine.h", "reportHash": "ab6813b7da52b9e6d153bd3f02d7f46d", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 33, "file": 20, "line": 808}, "message": "destructor '~parser' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/CommandLine.h", "reportHash": "8ff51bec1a44bb718ae49f084e7c27c7", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 9, "file": 20, "line": 810}, "message": "destructor '~OptionInfo' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/CommandLine.h", "reportHash": "b6dafee6e4989c0a63da9f3af14f182f", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 9, "file": 20, "line": 810}, "message": "move assignment operator 'operator=' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/CommandLine.h", "reportHash": "4272a7798b18740123d865828cd9f324", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 9, "file": 20, "line": 810}, "message": "move constructor 'OptionInfo' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/CommandLine.h", "reportHash": "b8e742876c34db237ce495fa6f4363ea", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 33, "file": 20, "line": 915}, "message": "destructor '~basic_parser' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/CommandLine.h", "reportHash": "0192ea523502e161495fe0cc59f38ecc", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 19, "file": 20, "line": 926}, "message": "destructor '~parser' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/CommandLine.h", "reportHash": "75077bd9d2fcf76ab510796690c7de63", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 19, "file": 20, "line": 953}, "message": "destructor '~parser' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/CommandLine.h", "reportHash": "bd5ed2171c3c89a5c4df010d1056e057", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 19, "file": 20, "line": 979}, "message": "destructor '~parser' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/CommandLine.h", "reportHash": "e59b568a27675c77c8e9863ecd685981", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 19, "file": 20, "line": 1001}, "message": "destructor '~parser' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/CommandLine.h", "reportHash": "032d0b65509cd2b6db6b1fc93fb9f31d", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 19, "file": 20, "line": 1023}, "message": "destructor '~parser' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/CommandLine.h", "reportHash": "c9f0a4f21da0848e7bb995f3ccdb73d8", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 19, "file": 20, "line": 1045}, "message": "destructor '~parser' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/CommandLine.h", "reportHash": "bc7a32152e8917a14aa762012934f0df", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 20, "line": 1068}, "message": "destructor '~parser' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/CommandLine.h", "reportHash": "6352b12436e1339e79d1d96f8df8fe80", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 20, "line": 1091}, "message": "destructor '~parser' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/CommandLine.h", "reportHash": "a71947bbbad7d31ccbd2c8afad2e44c0", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 19, "file": 20, "line": 1114}, "message": "destructor '~parser' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/CommandLine.h", "reportHash": "0d10484ffaaba9170785461b85c526ea", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 19, "file": 20, "line": 1136}, "message": "destructor '~parser' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/CommandLine.h", "reportHash": "df5e8314bf541aa5ac60d3d06d6ba960", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 19, "file": 20, "line": 1158}, "message": "destructor '~parser' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/CommandLine.h", "reportHash": "f1214525cf7d0b5f6222a349b0139cae", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 19, "file": 20, "line": 1183}, "message": "destructor '~parser' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/CommandLine.h", "reportHash": "da43e98ee95d78503925a140b471e58a", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 20, "line": 1322}, "message": "destructor '~opt_storage' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/CommandLine.h", "reportHash": "b0323e468d6801c92fb0384c36753e89", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 20, "line": 1369}, "message": "default constructor 'opt_storage' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/CommandLine.h", "reportHash": "18fbb46e65802c62ea30d48ae7a14751", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 33, "file": 20, "line": 1389}, "message": "destructor '~opt_storage' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/CommandLine.h", "reportHash": "92032fa7d7d771ee64560ee5270093a1", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 20, "line": 1508}, "message": "destructor '~' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/CommandLine.h", "reportHash": "e5292c8ec4aba8d47b53e7c978ddaa90", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 20, "line": 1508}, "message": "move constructor '' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/CommandLine.h", "reportHash": "3027738aef5b4d21532c2fd143a47d43", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 23, "file": 20, "line": 1513}, "message": "destructor '~opt' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/CommandLine.h", "reportHash": "a8f6de2e037d0188be330e9384906f7e", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 23, "file": 20, "line": 1515}, "message": "destructor '~opt' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/CommandLine.h", "reportHash": "eb4f79f3f0c838a6759f69751ee6067d", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 53, "file": 20, "line": 1524}, "message": "destructor '~list_storage' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/CommandLine.h", "reportHash": "55f13906b26548c0738d67a9289e356b", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 33, "file": 20, "line": 1554}, "message": "default constructor 'list_storage' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/CommandLine.h", "reportHash": "7ebeb640b6a7e1778ac94f08de363ca0", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 20, "line": 1627}, "message": "destructor '~list' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/CommandLine.h", "reportHash": "9936e569e28668c60a50a04c9740ebf9", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 20, "line": 1702}, "message": "destructor '~' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/CommandLine.h", "reportHash": "e5292c8ec4aba8d47b53e7c978ddaa90", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 20, "line": 1702}, "message": "move constructor '' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/CommandLine.h", "reportHash": "3027738aef5b4d21532c2fd143a47d43", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 20, "line": 1859}, "message": "destructor '~alias' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/CommandLine.h", "reportHash": "48bb4462acfeba2b8cda63f8b9188023", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 20, "line": 1918}, "message": "destructor '~aliasopt' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/CommandLine.h", "reportHash": "03ef06793a2c5e4d87370417bd66bad0", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 21, "line": 48}, "message": "default constructor 'ErrorInfoBase' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/Error.h", "reportHash": "ae310ad6341ae6c6f5d1e16e4e1ccd79", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 21, "line": 330}, "message": "destructor '~ErrorSuccess' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/Error.h", "reportHash": "bf35d5012ea0cd62c18a721337b73f5b", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 21, "line": 350}, "message": "default constructor 'ErrorInfo' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/Error.h", "reportHash": "4cd9afe91da2755becf8227ff9fd9e48", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 21, "line": 350}, "message": "destructor '~ErrorInfo' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/Error.h", "reportHash": "d6c06dcfd89501997b635c9c7ebb4bb1", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 21, "line": 365}, "message": "destructor '~ErrorList' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/Error.h", "reportHash": "db2f4b232debc7f84b55f2493362bdaa", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 21, "line": 680}, "message": "destructor '~' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/Error.h", "reportHash": "f64041b79e242103c03e65b86b910889", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 33, "file": 21, "line": 993}, "message": "destructor '~' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/Error.h", "reportHash": "7b80d7927e3a67335f4d975250fd7938", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 35, "file": 21, "line": 1007}, "message": "destructor '~' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/Error.h", "reportHash": "019a091981ccc7f8005be37f15085509", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 21, "line": 1104}, "message": "destructor '~ECError' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/Error.h", "reportHash": "cf79d17153c5e005dc0f3fc46682e08a", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 21, "line": 1226}, "message": "destructor '~FileError' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/Error.h", "reportHash": "008ffabc5dfae1891f79d30eefe4c069", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 21, "file": 21, "line": 1263}, "message": "destructor '~' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/Error.h", "reportHash": "b2ea4d2223b04e6ac0c2ac8bcedbfa84", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 21, "file": 21, "line": 1311}, "message": "destructor '~' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/Error.h", "reportHash": "4f118db16989b6a6edcc75fe3c010e20", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 21, "file": 21, "line": 1311}, "message": "move constructor '' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/Error.h", "reportHash": "0694ac2c658c8f24aed2f569d1813b45", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 22, "line": 255}, "message": "destructor '~' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/ErrorOr.h", "reportHash": "9451dbb6f643a8638586f654d2c45cbc", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 23, "line": 137}, "message": "destructor '~basic_file_status' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/FileSystem.h", "reportHash": "abbbf79bc0c681792ca1eeabecda81b5", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 23, "line": 137}, "message": "move constructor 'basic_file_status' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/FileSystem.h", "reportHash": "28c6b3a0bfe1fb8c19ebb2444aad4f4a", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 23, "line": 1267}, "message": "destructor '~directory_entry' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/FileSystem.h", "reportHash": "609881bb488ff0c91b78de39763c38a4", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 10, "file": 23, "line": 1322}, "message": "default constructor 'DirIterState' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/FileSystem.h", "reportHash": "84679020e73ebf7d2a530f65369a92b2", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 23, "line": 1336}, "message": "destructor '~directory_iterator' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/FileSystem.h", "reportHash": "fa2b9c2366987c0792abae4b1dd0c6a4", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 23, "line": 1336}, "message": "move assignment operator 'operator=' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/FileSystem.h", "reportHash": "4bc3cd15e9cd0294f6a6b1c782efbfac", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 23, "line": 1336}, "message": "move constructor 'directory_iterator' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/FileSystem.h", "reportHash": "e63c4eda43f79621d4dcf1acf29f3866", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 10, "file": 23, "line": 1388}, "message": "destructor '~RecDirIterState' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/FileSystem.h", "reportHash": "712faaf026431dc1f58870ce40939ad5", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 24, "line": 23}, "message": "destructor '~UniqueID' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/FileSystem/UniqueID.h", "reportHash": "226c1b73216a941f382e2e6be63686fd", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 24, "line": 23}, "message": "move constructor 'UniqueID' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/FileSystem/UniqueID.h", "reportHash": "7c72dcd2ef8ef4e7a4bb927297affe77", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 25, "line": 129}, "message": "destructor '~FormattedString' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/Format.h", "reportHash": "db3c099de5930e991c2b085d6de99cd4", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 25, "line": 129}, "message": "move constructor 'FormattedString' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/Format.h", "reportHash": "2e7c456579c461e9c194c470a71a08e4", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 25, "line": 164}, "message": "destructor '~FormattedNumber' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/Format.h", "reportHash": "f418d1d8d22ae0e74fd837c1551bc39d", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 25, "line": 164}, "message": "move constructor 'FormattedNumber' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/Format.h", "reportHash": "839066c7b59edaaf40a71f180ddfb499", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 25, "line": 215}, "message": "destructor '~FormattedBytes' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/Format.h", "reportHash": "c22f30776c3f54b52caf6cd2d0887b51", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 25, "line": 215}, "message": "move constructor 'FormattedBytes' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/Format.h", "reportHash": "7f7aff7d09dba7bdb1292ef44574c5fb", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 29, "file": 26, "line": 38}, "message": "destructor '~SmallString' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/MD5.h", "reportHash": "f6d4576933e864f994709d521131f2e6", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 10, "file": 26, "line": 55}, "message": "default constructor 'MD5Result' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/MD5.h", "reportHash": "1ebf6cd200b7553b56b2549e93104c16", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 9, "file": 27, "line": 72}, "message": "destructor '~PrettyStackTraceString' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/PrettyStackTrace.h", "reportHash": "5b56a7452cd2a98d0d500df4b08e7311", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 9, "file": 27, "line": 91}, "message": "destructor '~PrettyStackTraceProgram' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/PrettyStackTrace.h", "reportHash": "b5265a8b43b1a5d929e8ed0b535c2fa6", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 28, "line": 23}, "message": "destructor '~SMLoc' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/SMLoc.h", "reportHash": "a9a691dbbd3a4396b5884193a4c10d65", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 28, "line": 23}, "message": "move assignment operator 'operator=' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/SMLoc.h", "reportHash": "ea0f79211fe8398f7fdaaf1ea3fd8705", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 28, "line": 23}, "message": "move constructor 'SMLoc' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/SMLoc.h", "reportHash": "d548896c660dadcccbae7fbb9083088a", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 28, "line": 48}, "message": "destructor '~SMRange' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/SMLoc.h", "reportHash": "b2fbbf70b48fa910433c4e25581ff351", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 28, "line": 48}, "message": "move assignment operator 'operator=' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/SMLoc.h", "reportHash": "62a6ed66e55ceaacecc72a98603d6ddd", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 28, "line": 48}, "message": "move constructor 'SMRange' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/SMLoc.h", "reportHash": "de344be3f407aeeaf41b184f49703b92", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 29, "line": 226}, "message": "destructor '~SMFixIt' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/SourceMgr.h", "reportHash": "ac618fecd76305199d2c2c8615e180de", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 29, "line": 226}, "message": "move assignment operator 'operator=' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/SourceMgr.h", "reportHash": "8a30e401695f86c5d879db34fd65e112", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 29, "line": 226}, "message": "move constructor 'SMFixIt' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/SourceMgr.h", "reportHash": "894fb3ba74cd795b0ba173b27c3448e0", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 30, "line": 132}, "message": "default constructor '' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/SwapByteOrder.h", "reportHash": "d1100b7e9f11096b3cc6e26df641e687", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 30, "line": 142}, "message": "default constructor '' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/SwapByteOrder.h", "reportHash": "d1100b7e9f11096b3cc6e26df641e687", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 31, "line": 46}, "message": "destructor '~Status' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/VirtualFileSystem.h", "reportHash": "1c18ad62ecfc931f54f83e7acaa0ec37", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 31, "line": 46}, "message": "move constructor 'Status' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/VirtualFileSystem.h", "reportHash": "98b6a5eafb9835835c9e955bc7359f00", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 31, "line": 159}, "message": "destructor '~directory_iterator' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/VirtualFileSystem.h", "reportHash": "80962ed5e6a3bec05c1343f6d188f288", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 31, "line": 159}, "message": "move constructor 'directory_iterator' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/VirtualFileSystem.h", "reportHash": "b6fb39ab05e3e262b9d85c8ee2f0ed3e", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 31, "line": 245}, "message": "default constructor 'FileSystem' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/VirtualFileSystem.h", "reportHash": "74e917918905b66968f71e4072ecfbcb", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 31, "line": 370}, "message": "destructor '~ProxyFileSystem' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/VirtualFileSystem.h", "reportHash": "8fdaaa58c6a55cb51b6154ef609e19d6", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 9, "file": 31, "line": 618}, "message": "destructor '~DirectoryEntry' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/VirtualFileSystem.h", "reportHash": "f645a8d9e918bcfe6b5875b48605cbdd", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 9, "file": 31, "line": 651}, "message": "destructor '~RemapEntry' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/VirtualFileSystem.h", "reportHash": "efced7c4041283fd200d0db54bf5e323", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 9, "file": 31, "line": 687}, "message": "destructor '~DirectoryRemapEntry' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/VirtualFileSystem.h", "reportHash": "e01e326e99c1360197f31431a7505772", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 9, "file": 31, "line": 699}, "message": "destructor '~FileEntry' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/VirtualFileSystem.h", "reportHash": "177dd8e1e361ae9c97dc0c8685ef94dd", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 32, "line": 406}, "message": "destructor '~raw_pwrite_stream' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/raw_ostream.h", "reportHash": "cf0c20938e6332f40252e6181d428aea", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 33, "line": 184}, "message": "destructor '~MarkerStyle' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/utils/FileCheck/FileCheck.cpp", "reportHash": "c2a550787c0c202857b1f68f31db7642", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 33, "line": 184}, "message": "move assignment operator 'operator=' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/utils/FileCheck/FileCheck.cpp", "reportHash": "9910b0a80ad8a2a3847f13f531fc72fe", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 33, "line": 184}, "message": "move constructor 'MarkerStyle' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/utils/FileCheck/FileCheck.cpp", "reportHash": "a31dfd3342592b529ac4e9de3f4d46c2", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 33, "line": 311}, "message": "destructor '~InputAnnotation' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/utils/FileCheck/FileCheck.cpp", "reportHash": "d3f5e5bf90c724c12e0f89340ebb84eb", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 33, "line": 311}, "message": "move assignment operator 'operator=' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/utils/FileCheck/FileCheck.cpp", "reportHash": "53dfd9e654cf1d686a4e41e935f9f195", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 33, "line": 311}, "message": "move constructor 'InputAnnotation' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/utils/FileCheck/FileCheck.cpp", "reportHash": "ef6f1c5ae1712d993ca43a68c7d0b85b", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 14, "file": 33, "line": 526}, "message": "destructor '~' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/utils/FileCheck/FileCheck.cpp", "reportHash": "551ed0008a370f7d7d1ee79a1c56cdba", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 14, "file": 33, "line": 526}, "message": "move constructor '' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/utils/FileCheck/FileCheck.cpp", "reportHash": "71ab0f8b4c6bc7c21d411bcd8369b857", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}]};
      window.onload = function() {
        if (!browserCompatible) {
          setNonCompatibleBrowserMessage();
        } else {
          BugViewer.init(data.files, data.reports);
          BugViewer.create();
          BugViewer.initByUrl();
        }
      };
    </script>
  </head>
  <body>
  <div class="container">
    <div id="content">
      <div id="side-bar">
        <div class="header">
          <a href="index.html" class="button">&#8249; Return to List</a>
        </div>
        <div id="report-nav">
          <div class="header">Reports</div>
        </div>
      </div>
      <div id="editor-wrapper">
        <div class="header">
          <div id="file">
            <span class="label">File:</span>
            <span id="file-path"></span>
          </div>
          <div id="checker">
            <span class="label">Checker name:</span>
            <span id="checker-name"></span>
          </div>
          <div id="review-status-wrapper">
            <span class="label">Review status:</span>
            <span id="review-status"></span>
          </div>
        </div>
        <div id="editor"></div>
      </div>
    </div>
  </div>
  </body>
</html>
