<!DOCTYPE html>
<html>
  <head>
    <title>Plist HTML Viewer</title>

    <meta charset="UTF-8">

    <style type="text/css">
      .CodeMirror{font-family:monospace;height:300px;color:#000;direction:ltr}.CodeMirror-lines{padding:4px 0}.CodeMirror pre{padding:0 4px}.CodeMirror-gutter-filler,.CodeMirror-scrollbar-filler{background-color:#fff}.CodeMirror-gutters{border-right:1px solid #ddd;background-color:#f7f7f7;white-space:nowrap}.CodeMirror-linenumber{padding:0 3px 0 5px;min-width:20px;text-align:right;color:#999;white-space:nowrap}.CodeMirror-guttermarker{color:#000}.CodeMirror-guttermarker-subtle{color:#999}.CodeMirror-cursor{border-left:1px solid #000;border-right:none;width:0}.CodeMirror div.CodeMirror-secondarycursor{border-left:1px solid silver}.cm-fat-cursor .CodeMirror-cursor{width:auto;border:0!important;background:#7e7}.cm-fat-cursor div.CodeMirror-cursors{z-index:1}.cm-animate-fat-cursor{width:auto;border:0;-webkit-animation:blink 1.06s steps(1) infinite;-moz-animation:blink 1.06s steps(1) infinite;animation:blink 1.06s steps(1) infinite;background-color:#7e7}@-moz-keyframes blink{50%{background-color:transparent}}@-webkit-keyframes blink{50%{background-color:transparent}}@keyframes blink{50%{background-color:transparent}}.cm-tab{display:inline-block;text-decoration:inherit}.CodeMirror-rulers{position:absolute;left:0;right:0;top:-50px;bottom:-20px;overflow:hidden}.CodeMirror-ruler{border-left:1px solid #ccc;top:0;bottom:0;position:absolute}.cm-s-default .cm-header{color:#00f}.cm-s-default .cm-quote{color:#090}.cm-negative{color:#d44}.cm-positive{color:#292}.cm-header,.cm-strong{font-weight:700}.cm-em{font-style:italic}.cm-link{text-decoration:underline}.cm-strikethrough{text-decoration:line-through}.cm-s-default .cm-keyword{color:#708}.cm-s-default .cm-atom{color:#219}.cm-s-default .cm-number{color:#164}.cm-s-default .cm-def{color:#00f}.cm-s-default .cm-variable-2{color:#05a}.cm-s-default .cm-type,.cm-s-default .cm-variable-3{color:#085}.cm-s-default .cm-comment{color:#a50}.cm-s-default .cm-string{color:#a11}.cm-s-default .cm-string-2{color:#f50}.cm-s-default .cm-meta{color:#555}.cm-s-default .cm-qualifier{color:#555}.cm-s-default .cm-builtin{color:#30a}.cm-s-default .cm-bracket{color:#997}.cm-s-default .cm-tag{color:#170}.cm-s-default .cm-attribute{color:#00c}.cm-s-default .cm-hr{color:#999}.cm-s-default .cm-link{color:#00c}.cm-s-default .cm-error{color:red}.cm-invalidchar{color:red}.CodeMirror-composing{border-bottom:2px solid}div.CodeMirror span.CodeMirror-matchingbracket{color:#0f0}div.CodeMirror span.CodeMirror-nonmatchingbracket{color:#f22}.CodeMirror-matchingtag{background:rgba(255,150,0,.3)}.CodeMirror-activeline-background{background:#e8f2ff}.CodeMirror{position:relative;overflow:hidden;background:#fff}.CodeMirror-scroll{overflow:scroll!important;margin-bottom:-30px;margin-right:-30px;padding-bottom:30px;height:100%;outline:0;position:relative}.CodeMirror-sizer{position:relative;border-right:30px solid transparent}.CodeMirror-gutter-filler,.CodeMirror-hscrollbar,.CodeMirror-scrollbar-filler,.CodeMirror-vscrollbar{position:absolute;z-index:6;display:none}.CodeMirror-vscrollbar{right:0;top:0;overflow-x:hidden;overflow-y:scroll}.CodeMirror-hscrollbar{bottom:0;left:0;overflow-y:hidden;overflow-x:scroll}.CodeMirror-scrollbar-filler{right:0;bottom:0}.CodeMirror-gutter-filler{left:0;bottom:0}.CodeMirror-gutters{position:absolute;left:0;top:0;min-height:100%;z-index:3}.CodeMirror-gutter{white-space:normal;height:100%;display:inline-block;vertical-align:top;margin-bottom:-30px}.CodeMirror-gutter-wrapper{position:absolute;z-index:4;background:0 0!important;border:none!important}.CodeMirror-gutter-background{position:absolute;top:0;bottom:0;z-index:4}.CodeMirror-gutter-elt{position:absolute;cursor:default;z-index:4}.CodeMirror-gutter-wrapper ::selection{background-color:transparent}.CodeMirror-gutter-wrapper ::-moz-selection{background-color:transparent}.CodeMirror-lines{cursor:text;min-height:1px}.CodeMirror pre{-moz-border-radius:0;-webkit-border-radius:0;border-radius:0;border-width:0;background:0 0;font-family:inherit;font-size:inherit;margin:0;white-space:pre;word-wrap:normal;line-height:inherit;color:inherit;z-index:2;position:relative;overflow:visible;-webkit-tap-highlight-color:transparent;-webkit-font-variant-ligatures:contextual;font-variant-ligatures:contextual}.CodeMirror-wrap pre{word-wrap:break-word;white-space:pre-wrap;word-break:normal}.CodeMirror-linebackground{position:absolute;left:0;right:0;top:0;bottom:0;z-index:0}.CodeMirror-linewidget{position:relative;z-index:2;overflow:auto}.CodeMirror-rtl pre{direction:rtl}.CodeMirror-code{outline:0}.CodeMirror-gutter,.CodeMirror-gutters,.CodeMirror-linenumber,.CodeMirror-scroll,.CodeMirror-sizer{-moz-box-sizing:content-box;box-sizing:content-box}.CodeMirror-measure{position:absolute;width:100%;height:0;overflow:hidden;visibility:hidden}.CodeMirror-cursor{position:absolute;pointer-events:none}.CodeMirror-measure pre{position:static}div.CodeMirror-cursors{visibility:hidden;position:relative;z-index:3}div.CodeMirror-dragcursors{visibility:visible}.CodeMirror-focused div.CodeMirror-cursors{visibility:visible}.CodeMirror-selected{background:#d9d9d9}.CodeMirror-focused .CodeMirror-selected{background:#d7d4f0}.CodeMirror-crosshair{cursor:crosshair}.CodeMirror-line::selection,.CodeMirror-line>span::selection,.CodeMirror-line>span>span::selection{background:#d7d4f0}.CodeMirror-line::-moz-selection,.CodeMirror-line>span::-moz-selection,.CodeMirror-line>span>span::-moz-selection{background:#d7d4f0}.cm-searching{background-color:#ffa;background-color:rgba(255,255,0,.4)}.cm-force-border{padding-right:.1px}@media print{.CodeMirror div.CodeMirror-cursors{visibility:hidden}}.cm-tab-wrap-hack:after{content:''}span.CodeMirror-selectedtext{background:0 0}
/*# sourceMappingURL=codemirror.min.css.map */

      .severity-low {
  background-color: #669603;
}

.severity-low:after {
  content : 'L';
}

.severity-unspecified {
  background-color: #666666;
}

.severity-unspecified:after {
  content : 'U';
}

.severity-style {
  background-color: #9932cc;
}

.severity-style:after {
  content : 'S';
}

.severity-medium {
  background-color: #a9d323;
  color: black;
}

.severity-medium:after {
  content : 'M';
}

.severity-high {
  background-color: #ffa800;
}

.severity-high:after {
  content : 'H';
}

.severity-critical {
  background-color: #e92625;
}

.severity-critical:after {
  content : 'C';
}

i[class*="severity-"] {
  line-height: normal;
  text-transform: capitalize;
  font-size: 0.8em;
  font-weight: bold;
  color: white;
  display: inline-block;
  width: 16px;
  height: 16px;
  text-align: center;
  font-family: sans-serif;
}

      html, body {
  width: 100%;
  height: 100%;
  padding: 0px;
  margin: 0px;
}

div.container {
  padding: 10px;
}

#content {
  height: 100%;
  display: block;
  overflow: hidden;
}

#content > div {
  margin: 10px;
  overflow: hidden;
  border: 1px solid #ddd;
  border-radius: 3px;
  overflow: hidden;
  height: 97%;
}

.button {
  background-color: #f1f1f1;
  text-decoration: none;
  display: inline-block;
  padding: 8px 16px;
  color: black;
  cursor: pointer;
}

.button:hover {
  background-color: #ddd;
  color: black;
}

.review-status {
  color: white;
  text-align: center;
}

.review-status-confirmed {
  background-color: #e92625;
}

.review-status-false-positive {
  background-color: grey;
}

.review-status-intentional {
  background-color: #669603;
}

      div.container {
  width: 100%;
  height: 100%;
  padding: 0px;
}

#editor-wrapper {
  margin: 10px;
}

#side-bar {
  float: left;
  width: 260px;
  margin: 0px;
}

#report-nav ul {
  list-style-type: none;
  padding: 0;
  margin: 0;
  overflow-y: auto;
  height: 100%;
}

#report-nav ul > li {
  padding: .4em;
  background-color: #fff;
  border-bottom: 1px solid rgba(0,0,0,.125);
  text-align: left;
  overflow: hidden;
  white-space: nowrap;
  text-overflow: ellipsis;
}

#report-nav ul > li.active {
  background-color: #427ea9;
  color: white;
}

#report-nav ul > li:hover {
  background-color: #427ea9;
  color: white;
  cursor: pointer;
}

#report-nav ul a {
  text-decoration: none;
}

#report-nav i[class*="severity-"] {
  margin-right: 5px;
}

.header {
  border-bottom: 1px solid lightgrey;
  font-family: monospace;
  padding: 10px;
  background-color: #fafbfc;
  border-bottom: 1px solid #e1e4e8;
  border-top-left-radius: 2px;
  border-top-right-radius: 2px;
}

#report-nav .header {
  font-weight: bold;
}

#editor-wrapper .header > div {
  padding-top: 2px;
}

#file-path,
#checker-name {
  color: #195ea2;
}

#review-status {
  padding: 0px 5px;
}

#file-path {
  font-family: monospace;
}

.check-msg {
  display: inline-block;
  padding: 3px 6px;
  margin: 1px;
  -webkit-border-radius: 5px;
  -moz-border-radius: 5px;
  border-radius: 5px;
}

.check-msg.info {
  color: #00546f;
  background-color: #bfdfe9;
  border: 1px solid #87a8b3;
}

.check-msg.error {
  background-color: #f2dede;
  color: #a94442;
  border: 1px solid #ebcccc;
}

.check-msg.macro {
  background-color: #d7dac2;
  color: #4f5c6d;
  border: 1px solid #d7dac2;
}

.check-msg.note {
  background-color: #d7d7d7;
  color: #4f5c6d;
  border: 1px solid #bfbfbf;
}

.check-msg.current {
  border: 2px dashed #3692ff;
}

.check-msg .tag {
  padding: 1px 5px;
  text-align: center;
  border-radius: 2px;
  margin-right: 5px;
  text-decoration: inherit;
}

.check-msg .tag.macro {
  background-color: #83876a;
  color: white;
  text-transform: capitalize;
}

.check-msg .tag.note {
  background-color: #9299a1;
  color: white;
  text-transform: capitalize;
}

.checker-enum {
  color: white;
  padding: 1px 5px;
  text-align: center;
  border-radius: 25px;
  margin-right: 5px;
  text-decoration: inherit;
}

.checker-enum.info {
  background-color: #427ea9;
}

.checker-enum.error {
  background-color: #a94442;
}

.arrow {
  border: solid black;
  border-width: 0 3px 3px 0;
  display: inline-block;
  padding: 3px;
  cursor: pointer;
  margin: 0px 5px;
}

.arrow:hover {
  border: solid #437ea8;
  border-width: 0 3px 3px 0;
}

.left-arrow {
  transform: rotate(135deg);
  -webkit-transform: rotate(135deg);
}

.right-arrow {
  transform: rotate(-45deg);
  -webkit-transform: rotate(-45deg);
}

    </style>

    <script type="text/javascript">
      function setNonCompatibleBrowserMessage() {
  document.body.innerHTML =
    '<h2 style="margin-left: 20px;">Your browser is not compatible with CodeChecker Viewer!</h2> \
     <p style="margin-left: 20px;">The version required for the following browsers are:</p> \
     <ul style="margin-left: 20px;"> \
     <li>Internet Explorer: version 9 or newer</li> \
     <li>Firefox: version 22.0 or newer</li> \
     </ul>';
}

// http://stackoverflow.com/questions/5916900/how-can-you-detect-the-version-of-a-browser
var browserVersion = (function(){
  var ua = navigator.userAgent, tem,
    M = ua.match(/(opera|chrome|safari|firefox|msie|trident(?=\/))\/?\s*(\d+)/i) || [];

  if (/trident/i.test(M[1])) {
    tem = /\brv[ :]+(\d+)/g.exec(ua) || [];
    return 'IE ' + (tem[1] || '');
  }

  if (M[1] === 'Chrome') {
    tem = ua.match(/\b(OPR|Edge)\/(\d+)/);
    if (tem != null) return tem.slice(1).join(' ').replace('OPR', 'Opera');
  }

  M = M[2] ? [M[1], M[2]] : [navigator.appName, navigator.appVersion, '-?'];
  if ((tem = ua.match(/version\/(\d+)/i)) != null) M.splice(1, 1, tem[1]);
    return M.join(' ');
})();

var pos = browserVersion.indexOf(' ');
var browser = browserVersion.substr(0, pos);
var version = parseInt(browserVersion.substr(pos + 1));

var browserCompatible
  = browser === 'Firefox'
  ? version >= 22
  : browser === 'IE'
  ? version >= 9
  : true;


      /* MIT License

Copyright (C) 2017 by Marijn Haverbeke <marijnh@gmail.com> and others

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
 */
      !function(e,t){"object"==typeof exports&&"undefined"!=typeof module?module.exports=t():"function"==typeof define&&define.amd?define(t):e.CodeMirror=t()}(this,function(){"use strict";function e(e){return new RegExp("(^|\\s)"+e+"(?:$|\\s)\\s*")}function t(e){for(var t=e.childNodes.length;t>0;--t)e.removeChild(e.firstChild);return e}function r(e,r){return t(e).appendChild(r)}function n(e,t,r,n){var i=document.createElement(e);if(r&&(i.className=r),n&&(i.style.cssText=n),"string"==typeof t)i.appendChild(document.createTextNode(t));else if(t)for(var o=0;o<t.length;++o)i.appendChild(t[o]);return i}function i(e,t,r,i){var o=n(e,t,r,i);return o.setAttribute("role","presentation"),o}function o(e,t){if(3==t.nodeType&&(t=t.parentNode),e.contains)return e.contains(t);do{if(11==t.nodeType&&(t=t.host),t==e)return!0}while(t=t.parentNode)}function l(){var e;try{e=document.activeElement}catch(t){e=document.body||null}for(;e&&e.shadowRoot&&e.shadowRoot.activeElement;)e=e.shadowRoot.activeElement;return e}function s(t,r){var n=t.className;e(r).test(n)||(t.className+=(n?" ":"")+r)}function a(t,r){for(var n=t.split(" "),i=0;i<n.length;i++)n[i]&&!e(n[i]).test(r)&&(r+=" "+n[i]);return r}function u(e){var t=Array.prototype.slice.call(arguments,1);return function(){return e.apply(null,t)}}function c(e,t,r){t||(t={});for(var n in e)!e.hasOwnProperty(n)||!1===r&&t.hasOwnProperty(n)||(t[n]=e[n]);return t}function f(e,t,r,n,i){null==t&&-1==(t=e.search(/[^\s\u00a0]/))&&(t=e.length);for(var o=n||0,l=i||0;;){var s=e.indexOf("\t",o);if(s<0||s>=t)return l+(t-o);l+=s-o,l+=r-l%r,o=s+1}}function h(e,t){for(var r=0;r<e.length;++r)if(e[r]==t)return r;return-1}function d(e,t,r){for(var n=0,i=0;;){var o=e.indexOf("\t",n);-1==o&&(o=e.length);var l=o-n;if(o==e.length||i+l>=t)return n+Math.min(l,t-i);if(i+=o-n,i+=r-i%r,n=o+1,i>=t)return n}}function p(e){for(;Kl.length<=e;)Kl.push(g(Kl)+" ");return Kl[e]}function g(e){return e[e.length-1]}function v(e,t){for(var r=[],n=0;n<e.length;n++)r[n]=t(e[n],n);return r}function m(e,t,r){for(var n=0,i=r(t);n<e.length&&r(e[n])<=i;)n++;e.splice(n,0,t)}function y(){}function b(e,t){var r;return Object.create?r=Object.create(e):(y.prototype=e,r=new y),t&&c(t,r),r}function w(e){return/\w/.test(e)||e>""&&(e.toUpperCase()!=e.toLowerCase()||jl.test(e))}function x(e,t){return t?!!(t.source.indexOf("\\w")>-1&&w(e))||t.test(e):w(e)}function C(e){for(var t in e)if(e.hasOwnProperty(t)&&e[t])return!1;return!0}function S(e){return e.charCodeAt(0)>=768&&Xl.test(e)}function L(e,t,r){for(;(r<0?t>0:t<e.length)&&S(e.charAt(t));)t+=r;return t}function k(e,t,r){for(var n=t>r?-1:1;;){if(t==r)return t;var i=(t+r)/2,o=n<0?Math.ceil(i):Math.floor(i);if(o==t)return e(o)?t:r;e(o)?r=o:t=o+n}}function T(e,t,r){var o=this;this.input=r,o.scrollbarFiller=n("div",null,"CodeMirror-scrollbar-filler"),o.scrollbarFiller.setAttribute("cm-not-content","true"),o.gutterFiller=n("div",null,"CodeMirror-gutter-filler"),o.gutterFiller.setAttribute("cm-not-content","true"),o.lineDiv=i("div",null,"CodeMirror-code"),o.selectionDiv=n("div",null,null,"position: relative; z-index: 1"),o.cursorDiv=n("div",null,"CodeMirror-cursors"),o.measure=n("div",null,"CodeMirror-measure"),o.lineMeasure=n("div",null,"CodeMirror-measure"),o.lineSpace=i("div",[o.measure,o.lineMeasure,o.selectionDiv,o.cursorDiv,o.lineDiv],null,"position: relative; outline: none");var l=i("div",[o.lineSpace],"CodeMirror-lines");o.mover=n("div",[l],null,"position: relative"),o.sizer=n("div",[o.mover],"CodeMirror-sizer"),o.sizerWidth=null,o.heightForcer=n("div",null,null,"position: absolute; height: "+Rl+"px; width: 1px;"),o.gutters=n("div",null,"CodeMirror-gutters"),o.lineGutter=null,o.scroller=n("div",[o.sizer,o.heightForcer,o.gutters],"CodeMirror-scroll"),o.scroller.setAttribute("tabIndex","-1"),o.wrapper=n("div",[o.scrollbarFiller,o.gutterFiller,o.scroller],"CodeMirror"),gl&&vl<8&&(o.gutters.style.zIndex=-1,o.scroller.style.paddingRight=0),ml||fl&&Tl||(o.scroller.draggable=!0),e&&(e.appendChild?e.appendChild(o.wrapper):e(o.wrapper)),o.viewFrom=o.viewTo=t.first,o.reportedViewFrom=o.reportedViewTo=t.first,o.view=[],o.renderedView=null,o.externalMeasured=null,o.viewOffset=0,o.lastWrapHeight=o.lastWrapWidth=0,o.updateLineNumbers=null,o.nativeBarWidth=o.barHeight=o.barWidth=0,o.scrollbarsClipped=!1,o.lineNumWidth=o.lineNumInnerWidth=o.lineNumChars=null,o.alignWidgets=!1,o.cachedCharWidth=o.cachedTextHeight=o.cachedPaddingH=null,o.maxLine=null,o.maxLineLength=0,o.maxLineChanged=!1,o.wheelDX=o.wheelDY=o.wheelStartX=o.wheelStartY=null,o.shift=!1,o.selForContextMenu=null,o.activeTouch=null,r.init(o)}function M(e,t){if((t-=e.first)<0||t>=e.size)throw new Error("There is no line "+(t+e.first)+" in the document.");for(var r=e;!r.lines;)for(var n=0;;++n){var i=r.children[n],o=i.chunkSize();if(t<o){r=i;break}t-=o}return r.lines[t]}function N(e,t,r){var n=[],i=t.line;return e.iter(t.line,r.line+1,function(e){var o=e.text;i==r.line&&(o=o.slice(0,r.ch)),i==t.line&&(o=o.slice(t.ch)),n.push(o),++i}),n}function O(e,t,r){var n=[];return e.iter(t,r,function(e){n.push(e.text)}),n}function A(e,t){var r=t-e.height;if(r)for(var n=e;n;n=n.parent)n.height+=r}function W(e){if(null==e.parent)return null;for(var t=e.parent,r=h(t.lines,e),n=t.parent;n;t=n,n=n.parent)for(var i=0;n.children[i]!=t;++i)r+=n.children[i].chunkSize();return r+t.first}function D(e,t){var r=e.first;e:do{for(var n=0;n<e.children.length;++n){var i=e.children[n],o=i.height;if(t<o){e=i;continue e}t-=o,r+=i.chunkSize()}return r}while(!e.lines);for(var l=0;l<e.lines.length;++l){var s=e.lines[l].height;if(t<s)break;t-=s}return r+l}function H(e,t){return t>=e.first&&t<e.first+e.size}function F(e,t){return String(e.lineNumberFormatter(t+e.firstLineNumber))}function E(e,t,r){if(void 0===r&&(r=null),!(this instanceof E))return new E(e,t,r);this.line=e,this.ch=t,this.sticky=r}function P(e,t){return e.line-t.line||e.ch-t.ch}function I(e,t){return e.sticky==t.sticky&&0==P(e,t)}function z(e){return E(e.line,e.ch)}function R(e,t){return P(e,t)<0?t:e}function B(e,t){return P(e,t)<0?e:t}function G(e,t){return Math.max(e.first,Math.min(t,e.first+e.size-1))}function U(e,t){if(t.line<e.first)return E(e.first,0);var r=e.first+e.size-1;return t.line>r?E(r,M(e,r).text.length):V(t,M(e,t.line).text.length)}function V(e,t){var r=e.ch;return null==r||r>t?E(e.line,t):r<0?E(e.line,0):e}function K(e,t){for(var r=[],n=0;n<t.length;n++)r[n]=U(e,t[n]);return r}function j(){Yl=!0}function X(){_l=!0}function Y(e,t,r){this.marker=e,this.from=t,this.to=r}function _(e,t){if(e)for(var r=0;r<e.length;++r){var n=e[r];if(n.marker==t)return n}}function $(e,t){for(var r,n=0;n<e.length;++n)e[n]!=t&&(r||(r=[])).push(e[n]);return r}function q(e,t){e.markedSpans=e.markedSpans?e.markedSpans.concat([t]):[t],t.marker.attachLine(e)}function Z(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t)||o.from==t&&"bookmark"==l.type&&(!r||!o.marker.insertLeft)){var s=null==o.to||(l.inclusiveRight?o.to>=t:o.to>t);(n||(n=[])).push(new Y(l,o.from,s?null:o.to))}}return n}function Q(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.to||(l.inclusiveRight?o.to>=t:o.to>t)||o.from==t&&"bookmark"==l.type&&(!r||o.marker.insertLeft)){var s=null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t);(n||(n=[])).push(new Y(l,s?null:o.from-t,null==o.to?null:o.to-t))}}return n}function J(e,t){if(t.full)return null;var r=H(e,t.from.line)&&M(e,t.from.line).markedSpans,n=H(e,t.to.line)&&M(e,t.to.line).markedSpans;if(!r&&!n)return null;var i=t.from.ch,o=t.to.ch,l=0==P(t.from,t.to),s=Z(r,i,l),a=Q(n,o,l),u=1==t.text.length,c=g(t.text).length+(u?i:0);if(s)for(var f=0;f<s.length;++f){var h=s[f];if(null==h.to){var d=_(a,h.marker);d?u&&(h.to=null==d.to?null:d.to+c):h.to=i}}if(a)for(var p=0;p<a.length;++p){var v=a[p];null!=v.to&&(v.to+=c),null==v.from?_(s,v.marker)||(v.from=c,u&&(s||(s=[])).push(v)):(v.from+=c,u&&(s||(s=[])).push(v))}s&&(s=ee(s)),a&&a!=s&&(a=ee(a));var m=[s];if(!u){var y,b=t.text.length-2;if(b>0&&s)for(var w=0;w<s.length;++w)null==s[w].to&&(y||(y=[])).push(new Y(s[w].marker,null,null));for(var x=0;x<b;++x)m.push(y);m.push(a)}return m}function ee(e){for(var t=0;t<e.length;++t){var r=e[t];null!=r.from&&r.from==r.to&&!1!==r.marker.clearWhenEmpty&&e.splice(t--,1)}return e.length?e:null}function te(e,t,r){var n=null;if(e.iter(t.line,r.line+1,function(e){if(e.markedSpans)for(var t=0;t<e.markedSpans.length;++t){var r=e.markedSpans[t].marker;!r.readOnly||n&&-1!=h(n,r)||(n||(n=[])).push(r)}}),!n)return null;for(var i=[{from:t,to:r}],o=0;o<n.length;++o)for(var l=n[o],s=l.find(0),a=0;a<i.length;++a){var u=i[a];if(!(P(u.to,s.from)<0||P(u.from,s.to)>0)){var c=[a,1],f=P(u.from,s.from),d=P(u.to,s.to);(f<0||!l.inclusiveLeft&&!f)&&c.push({from:u.from,to:s.from}),(d>0||!l.inclusiveRight&&!d)&&c.push({from:s.to,to:u.to}),i.splice.apply(i,c),a+=c.length-3}}return i}function re(e){var t=e.markedSpans;if(t){for(var r=0;r<t.length;++r)t[r].marker.detachLine(e);e.markedSpans=null}}function ne(e,t){if(t){for(var r=0;r<t.length;++r)t[r].marker.attachLine(e);e.markedSpans=t}}function ie(e){return e.inclusiveLeft?-1:0}function oe(e){return e.inclusiveRight?1:0}function le(e,t){var r=e.lines.length-t.lines.length;if(0!=r)return r;var n=e.find(),i=t.find(),o=P(n.from,i.from)||ie(e)-ie(t);if(o)return-o;var l=P(n.to,i.to)||oe(e)-oe(t);return l||t.id-e.id}function se(e,t){var r,n=_l&&e.markedSpans;if(n)for(var i=void 0,o=0;o<n.length;++o)(i=n[o]).marker.collapsed&&null==(t?i.from:i.to)&&(!r||le(r,i.marker)<0)&&(r=i.marker);return r}function ae(e){return se(e,!0)}function ue(e){return se(e,!1)}function ce(e,t,r,n,i){var o=M(e,t),l=_l&&o.markedSpans;if(l)for(var s=0;s<l.length;++s){var a=l[s];if(a.marker.collapsed){var u=a.marker.find(0),c=P(u.from,r)||ie(a.marker)-ie(i),f=P(u.to,n)||oe(a.marker)-oe(i);if(!(c>=0&&f<=0||c<=0&&f>=0)&&(c<=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.to,r)>=0:P(u.to,r)>0)||c>=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.from,n)<=0:P(u.from,n)<0)))return!0}}}function fe(e){for(var t;t=ae(e);)e=t.find(-1,!0).line;return e}function he(e){for(var t;t=ue(e);)e=t.find(1,!0).line;return e}function de(e){for(var t,r;t=ue(e);)e=t.find(1,!0).line,(r||(r=[])).push(e);return r}function pe(e,t){var r=M(e,t),n=fe(r);return r==n?t:W(n)}function ge(e,t){if(t>e.lastLine())return t;var r,n=M(e,t);if(!ve(e,n))return t;for(;r=ue(n);)n=r.find(1,!0).line;return W(n)+1}function ve(e,t){var r=_l&&t.markedSpans;if(r)for(var n=void 0,i=0;i<r.length;++i)if((n=r[i]).marker.collapsed){if(null==n.from)return!0;if(!n.marker.widgetNode&&0==n.from&&n.marker.inclusiveLeft&&me(e,t,n))return!0}}function me(e,t,r){if(null==r.to){var n=r.marker.find(1,!0);return me(e,n.line,_(n.line.markedSpans,r.marker))}if(r.marker.inclusiveRight&&r.to==t.text.length)return!0;for(var i=void 0,o=0;o<t.markedSpans.length;++o)if((i=t.markedSpans[o]).marker.collapsed&&!i.marker.widgetNode&&i.from==r.to&&(null==i.to||i.to!=r.from)&&(i.marker.inclusiveLeft||r.marker.inclusiveRight)&&me(e,t,i))return!0}function ye(e){for(var t=0,r=(e=fe(e)).parent,n=0;n<r.lines.length;++n){var i=r.lines[n];if(i==e)break;t+=i.height}for(var o=r.parent;o;r=o,o=r.parent)for(var l=0;l<o.children.length;++l){var s=o.children[l];if(s==r)break;t+=s.height}return t}function be(e){if(0==e.height)return 0;for(var t,r=e.text.length,n=e;t=ae(n);){var i=t.find(0,!0);n=i.from.line,r+=i.from.ch-i.to.ch}for(n=e;t=ue(n);){var o=t.find(0,!0);r-=n.text.length-o.from.ch,r+=(n=o.to.line).text.length-o.to.ch}return r}function we(e){var t=e.display,r=e.doc;t.maxLine=M(r,r.first),t.maxLineLength=be(t.maxLine),t.maxLineChanged=!0,r.iter(function(e){var r=be(e);r>t.maxLineLength&&(t.maxLineLength=r,t.maxLine=e)})}function xe(e,t,r,n){if(!e)return n(t,r,"ltr",0);for(var i=!1,o=0;o<e.length;++o){var l=e[o];(l.from<r&&l.to>t||t==r&&l.to==t)&&(n(Math.max(l.from,t),Math.min(l.to,r),1==l.level?"rtl":"ltr",o),i=!0)}i||n(t,r,"ltr")}function Ce(e,t,r){var n;$l=null;for(var i=0;i<e.length;++i){var o=e[i];if(o.from<t&&o.to>t)return i;o.to==t&&(o.from!=o.to&&"before"==r?n=i:$l=i),o.from==t&&(o.from!=o.to&&"before"!=r?n=i:$l=i)}return null!=n?n:$l}function Se(e,t){var r=e.order;return null==r&&(r=e.order=ql(e.text,t)),r}function Le(e,t){return e._handlers&&e._handlers[t]||Zl}function ke(e,t,r){if(e.removeEventListener)e.removeEventListener(t,r,!1);else if(e.detachEvent)e.detachEvent("on"+t,r);else{var n=e._handlers,i=n&&n[t];if(i){var o=h(i,r);o>-1&&(n[t]=i.slice(0,o).concat(i.slice(o+1)))}}}function Te(e,t){var r=Le(e,t);if(r.length)for(var n=Array.prototype.slice.call(arguments,2),i=0;i<r.length;++i)r[i].apply(null,n)}function Me(e,t,r){return"string"==typeof t&&(t={type:t,preventDefault:function(){this.defaultPrevented=!0}}),Te(e,r||t.type,e,t),He(t)||t.codemirrorIgnore}function Ne(e){var t=e._handlers&&e._handlers.cursorActivity;if(t)for(var r=e.curOp.cursorActivityHandlers||(e.curOp.cursorActivityHandlers=[]),n=0;n<t.length;++n)-1==h(r,t[n])&&r.push(t[n])}function Oe(e,t){return Le(e,t).length>0}function Ae(e){e.prototype.on=function(e,t){Ql(this,e,t)},e.prototype.off=function(e,t){ke(this,e,t)}}function We(e){e.preventDefault?e.preventDefault():e.returnValue=!1}function De(e){e.stopPropagation?e.stopPropagation():e.cancelBubble=!0}function He(e){return null!=e.defaultPrevented?e.defaultPrevented:0==e.returnValue}function Fe(e){We(e),De(e)}function Ee(e){return e.target||e.srcElement}function Pe(e){var t=e.which;return null==t&&(1&e.button?t=1:2&e.button?t=3:4&e.button&&(t=2)),Ml&&e.ctrlKey&&1==t&&(t=3),t}function Ie(e){if(null==Il){var t=n("span","​");r(e,n("span",[t,document.createTextNode("x")])),0!=e.firstChild.offsetHeight&&(Il=t.offsetWidth<=1&&t.offsetHeight>2&&!(gl&&vl<8))}var i=Il?n("span","​"):n("span"," ",null,"display: inline-block; width: 1px; margin-right: -1px");return i.setAttribute("cm-text",""),i}function ze(e){if(null!=zl)return zl;var n=r(e,document.createTextNode("AخA")),i=Wl(n,0,1).getBoundingClientRect(),o=Wl(n,1,2).getBoundingClientRect();return t(e),!(!i||i.left==i.right)&&(zl=o.right-i.right<3)}function Re(e){if(null!=ns)return ns;var t=r(e,n("span","x")),i=t.getBoundingClientRect(),o=Wl(t,0,1).getBoundingClientRect();return ns=Math.abs(i.left-o.left)>1}function Be(e,t){arguments.length>2&&(t.dependencies=Array.prototype.slice.call(arguments,2)),is[e]=t}function Ge(e){if("string"==typeof e&&os.hasOwnProperty(e))e=os[e];else if(e&&"string"==typeof e.name&&os.hasOwnProperty(e.name)){var t=os[e.name];"string"==typeof t&&(t={name:t}),(e=b(t,e)).name=t.name}else{if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+xml$/.test(e))return Ge("application/xml");if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+json$/.test(e))return Ge("application/json")}return"string"==typeof e?{name:e}:e||{name:"null"}}function Ue(e,t){t=Ge(t);var r=is[t.name];if(!r)return Ue(e,"text/plain");var n=r(e,t);if(ls.hasOwnProperty(t.name)){var i=ls[t.name];for(var o in i)i.hasOwnProperty(o)&&(n.hasOwnProperty(o)&&(n["_"+o]=n[o]),n[o]=i[o])}if(n.name=t.name,t.helperType&&(n.helperType=t.helperType),t.modeProps)for(var l in t.modeProps)n[l]=t.modeProps[l];return n}function Ve(e,t){c(t,ls.hasOwnProperty(e)?ls[e]:ls[e]={})}function Ke(e,t){if(!0===t)return t;if(e.copyState)return e.copyState(t);var r={};for(var n in t){var i=t[n];i instanceof Array&&(i=i.concat([])),r[n]=i}return r}function je(e,t){for(var r;e.innerMode&&(r=e.innerMode(t))&&r.mode!=e;)t=r.state,e=r.mode;return r||{mode:e,state:t}}function Xe(e,t,r){return!e.startState||e.startState(t,r)}function Ye(e,t,r,n){var i=[e.state.modeGen],o={};tt(e,t.text,e.doc.mode,r,function(e,t){return i.push(e,t)},o,n);for(var l=r.state,s=0;s<e.state.overlays.length;++s)!function(n){var l=e.state.overlays[n],s=1,a=0;r.state=!0,tt(e,t.text,l.mode,r,function(e,t){for(var r=s;a<e;){var n=i[s];n>e&&i.splice(s,1,e,i[s+1],n),s+=2,a=Math.min(e,n)}if(t)if(l.opaque)i.splice(r,s-r,e,"overlay "+t),s=r+2;else for(;r<s;r+=2){var o=i[r+1];i[r+1]=(o?o+" ":"")+"overlay "+t}},o)}(s);return r.state=l,{styles:i,classes:o.bgClass||o.textClass?o:null}}function _e(e,t,r){if(!t.styles||t.styles[0]!=e.state.modeGen){var n=$e(e,W(t)),i=t.text.length>e.options.maxHighlightLength&&Ke(e.doc.mode,n.state),o=Ye(e,t,n);i&&(n.state=i),t.stateAfter=n.save(!i),t.styles=o.styles,o.classes?t.styleClasses=o.classes:t.styleClasses&&(t.styleClasses=null),r===e.doc.highlightFrontier&&(e.doc.modeFrontier=Math.max(e.doc.modeFrontier,++e.doc.highlightFrontier))}return t.styles}function $e(e,t,r){var n=e.doc,i=e.display;if(!n.mode.startState)return new us(n,!0,t);var o=rt(e,t,r),l=o>n.first&&M(n,o-1).stateAfter,s=l?us.fromSaved(n,l,o):new us(n,Xe(n.mode),o);return n.iter(o,t,function(r){qe(e,r.text,s);var n=s.line;r.stateAfter=n==t-1||n%5==0||n>=i.viewFrom&&n<i.viewTo?s.save():null,s.nextLine()}),r&&(n.modeFrontier=s.line),s}function qe(e,t,r,n){var i=e.doc.mode,o=new ss(t,e.options.tabSize,r);for(o.start=o.pos=n||0,""==t&&Ze(i,r.state);!o.eol();)Qe(i,o,r.state),o.start=o.pos}function Ze(e,t){if(e.blankLine)return e.blankLine(t);if(e.innerMode){var r=je(e,t);return r.mode.blankLine?r.mode.blankLine(r.state):void 0}}function Qe(e,t,r,n){for(var i=0;i<10;i++){n&&(n[0]=je(e,r).mode);var o=e.token(t,r);if(t.pos>t.start)return o}throw new Error("Mode "+e.name+" failed to advance stream.")}function Je(e,t,r,n){var i,o,l=e.doc,s=l.mode,a=M(l,(t=U(l,t)).line),u=$e(e,t.line,r),c=new ss(a.text,e.options.tabSize,u);for(n&&(o=[]);(n||c.pos<t.ch)&&!c.eol();)c.start=c.pos,i=Qe(s,c,u.state),n&&o.push(new cs(c,i,Ke(l.mode,u.state)));return n?o:new cs(c,i,u.state)}function et(e,t){if(e)for(;;){var r=e.match(/(?:^|\s+)line-(background-)?(\S+)/);if(!r)break;e=e.slice(0,r.index)+e.slice(r.index+r[0].length);var n=r[1]?"bgClass":"textClass";null==t[n]?t[n]=r[2]:new RegExp("(?:^|s)"+r[2]+"(?:$|s)").test(t[n])||(t[n]+=" "+r[2])}return e}function tt(e,t,r,n,i,o,l){var s=r.flattenSpans;null==s&&(s=e.options.flattenSpans);var a,u=0,c=null,f=new ss(t,e.options.tabSize,n),h=e.options.addModeClass&&[null];for(""==t&&et(Ze(r,n.state),o);!f.eol();){if(f.pos>e.options.maxHighlightLength?(s=!1,l&&qe(e,t,n,f.pos),f.pos=t.length,a=null):a=et(Qe(r,f,n.state,h),o),h){var d=h[0].name;d&&(a="m-"+(a?d+" "+a:d))}if(!s||c!=a){for(;u<f.start;)i(u=Math.min(f.start,u+5e3),c);c=a}f.start=f.pos}for(;u<f.pos;){var p=Math.min(f.pos,u+5e3);i(p,c),u=p}}function rt(e,t,r){for(var n,i,o=e.doc,l=r?-1:t-(e.doc.mode.innerMode?1e3:100),s=t;s>l;--s){if(s<=o.first)return o.first;var a=M(o,s-1),u=a.stateAfter;if(u&&(!r||s+(u instanceof as?u.lookAhead:0)<=o.modeFrontier))return s;var c=f(a.text,null,e.options.tabSize);(null==i||n>c)&&(i=s-1,n=c)}return i}function nt(e,t){if(e.modeFrontier=Math.min(e.modeFrontier,t),!(e.highlightFrontier<t-10)){for(var r=e.first,n=t-1;n>r;n--){var i=M(e,n).stateAfter;if(i&&(!(i instanceof as)||n+i.lookAhead<t)){r=n+1;break}}e.highlightFrontier=Math.min(e.highlightFrontier,r)}}function it(e,t,r,n){e.text=t,e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null),null!=e.order&&(e.order=null),re(e),ne(e,r);var i=n?n(e):1;i!=e.height&&A(e,i)}function ot(e){e.parent=null,re(e)}function lt(e,t){if(!e||/^\s*$/.test(e))return null;var r=t.addModeClass?ps:ds;return r[e]||(r[e]=e.replace(/\S+/g,"cm-$&"))}function st(e,t){var r=i("span",null,null,ml?"padding-right: .1px":null),n={pre:i("pre",[r],"CodeMirror-line"),content:r,col:0,pos:0,cm:e,trailingSpace:!1,splitSpaces:(gl||ml)&&e.getOption("lineWrapping")};t.measure={};for(var o=0;o<=(t.rest?t.rest.length:0);o++){var l=o?t.rest[o-1]:t.line,s=void 0;n.pos=0,n.addToken=ut,ze(e.display.measure)&&(s=Se(l,e.doc.direction))&&(n.addToken=ft(n.addToken,s)),n.map=[],dt(l,n,_e(e,l,t!=e.display.externalMeasured&&W(l))),l.styleClasses&&(l.styleClasses.bgClass&&(n.bgClass=a(l.styleClasses.bgClass,n.bgClass||"")),l.styleClasses.textClass&&(n.textClass=a(l.styleClasses.textClass,n.textClass||""))),0==n.map.length&&n.map.push(0,0,n.content.appendChild(Ie(e.display.measure))),0==o?(t.measure.map=n.map,t.measure.cache={}):((t.measure.maps||(t.measure.maps=[])).push(n.map),(t.measure.caches||(t.measure.caches=[])).push({}))}if(ml){var u=n.content.lastChild;(/\bcm-tab\b/.test(u.className)||u.querySelector&&u.querySelector(".cm-tab"))&&(n.content.className="cm-tab-wrap-hack")}return Te(e,"renderLine",e,t.line,n.pre),n.pre.className&&(n.textClass=a(n.pre.className,n.textClass||"")),n}function at(e){var t=n("span","•","cm-invalidchar");return t.title="\\u"+e.charCodeAt(0).toString(16),t.setAttribute("aria-label",t.title),t}function ut(e,t,r,i,o,l,s){if(t){var a,u=e.splitSpaces?ct(t,e.trailingSpace):t,c=e.cm.state.specialChars,f=!1;if(c.test(t)){a=document.createDocumentFragment();for(var h=0;;){c.lastIndex=h;var d=c.exec(t),g=d?d.index-h:t.length-h;if(g){var v=document.createTextNode(u.slice(h,h+g));gl&&vl<9?a.appendChild(n("span",[v])):a.appendChild(v),e.map.push(e.pos,e.pos+g,v),e.col+=g,e.pos+=g}if(!d)break;h+=g+1;var m=void 0;if("\t"==d[0]){var y=e.cm.options.tabSize,b=y-e.col%y;(m=a.appendChild(n("span",p(b),"cm-tab"))).setAttribute("role","presentation"),m.setAttribute("cm-text","\t"),e.col+=b}else"\r"==d[0]||"\n"==d[0]?((m=a.appendChild(n("span","\r"==d[0]?"␍":"␤","cm-invalidchar"))).setAttribute("cm-text",d[0]),e.col+=1):((m=e.cm.options.specialCharPlaceholder(d[0])).setAttribute("cm-text",d[0]),gl&&vl<9?a.appendChild(n("span",[m])):a.appendChild(m),e.col+=1);e.map.push(e.pos,e.pos+1,m),e.pos++}}else e.col+=t.length,a=document.createTextNode(u),e.map.push(e.pos,e.pos+t.length,a),gl&&vl<9&&(f=!0),e.pos+=t.length;if(e.trailingSpace=32==u.charCodeAt(t.length-1),r||i||o||f||s){var w=r||"";i&&(w+=i),o&&(w+=o);var x=n("span",[a],w,s);return l&&(x.title=l),e.content.appendChild(x)}e.content.appendChild(a)}}function ct(e,t){if(e.length>1&&!/  /.test(e))return e;for(var r=t,n="",i=0;i<e.length;i++){var o=e.charAt(i);" "!=o||!r||i!=e.length-1&&32!=e.charCodeAt(i+1)||(o=" "),n+=o,r=" "==o}return n}function ft(e,t){return function(r,n,i,o,l,s,a){i=i?i+" cm-force-border":"cm-force-border";for(var u=r.pos,c=u+n.length;;){for(var f=void 0,h=0;h<t.length&&!((f=t[h]).to>u&&f.from<=u);h++);if(f.to>=c)return e(r,n,i,o,l,s,a);e(r,n.slice(0,f.to-u),i,o,null,s,a),o=null,n=n.slice(f.to-u),u=f.to}}}function ht(e,t,r,n){var i=!n&&r.widgetNode;i&&e.map.push(e.pos,e.pos+t,i),!n&&e.cm.display.input.needsContentAttribute&&(i||(i=e.content.appendChild(document.createElement("span"))),i.setAttribute("cm-marker",r.id)),i&&(e.cm.display.input.setUneditable(i),e.content.appendChild(i)),e.pos+=t,e.trailingSpace=!1}function dt(e,t,r){var n=e.markedSpans,i=e.text,o=0;if(n)for(var l,s,a,u,c,f,h,d=i.length,p=0,g=1,v="",m=0;;){if(m==p){a=u=c=f=s="",h=null,m=1/0;for(var y=[],b=void 0,w=0;w<n.length;++w){var x=n[w],C=x.marker;"bookmark"==C.type&&x.from==p&&C.widgetNode?y.push(C):x.from<=p&&(null==x.to||x.to>p||C.collapsed&&x.to==p&&x.from==p)?(null!=x.to&&x.to!=p&&m>x.to&&(m=x.to,u=""),C.className&&(a+=" "+C.className),C.css&&(s=(s?s+";":"")+C.css),C.startStyle&&x.from==p&&(c+=" "+C.startStyle),C.endStyle&&x.to==m&&(b||(b=[])).push(C.endStyle,x.to),C.title&&!f&&(f=C.title),C.collapsed&&(!h||le(h.marker,C)<0)&&(h=x)):x.from>p&&m>x.from&&(m=x.from)}if(b)for(var S=0;S<b.length;S+=2)b[S+1]==m&&(u+=" "+b[S]);if(!h||h.from==p)for(var L=0;L<y.length;++L)ht(t,0,y[L]);if(h&&(h.from||0)==p){if(ht(t,(null==h.to?d+1:h.to)-p,h.marker,null==h.from),null==h.to)return;h.to==p&&(h=!1)}}if(p>=d)break;for(var k=Math.min(d,m);;){if(v){var T=p+v.length;if(!h){var M=T>k?v.slice(0,k-p):v;t.addToken(t,M,l?l+a:a,c,p+M.length==m?u:"",f,s)}if(T>=k){v=v.slice(k-p),p=k;break}p=T,c=""}v=i.slice(o,o=r[g++]),l=lt(r[g++],t.cm.options)}}else for(var N=1;N<r.length;N+=2)t.addToken(t,i.slice(o,o=r[N]),lt(r[N+1],t.cm.options))}function pt(e,t,r){this.line=t,this.rest=de(t),this.size=this.rest?W(g(this.rest))-r+1:1,this.node=this.text=null,this.hidden=ve(e,t)}function gt(e,t,r){for(var n,i=[],o=t;o<r;o=n){var l=new pt(e.doc,M(e.doc,o),o);n=o+l.size,i.push(l)}return i}function vt(e){gs?gs.ops.push(e):e.ownsGroup=gs={ops:[e],delayedCallbacks:[]}}function mt(e){var t=e.delayedCallbacks,r=0;do{for(;r<t.length;r++)t[r].call(null);for(var n=0;n<e.ops.length;n++){var i=e.ops[n];if(i.cursorActivityHandlers)for(;i.cursorActivityCalled<i.cursorActivityHandlers.length;)i.cursorActivityHandlers[i.cursorActivityCalled++].call(null,i.cm)}}while(r<t.length)}function yt(e,t){var r=e.ownsGroup;if(r)try{mt(r)}finally{gs=null,t(r)}}function bt(e,t){var r=Le(e,t);if(r.length){var n,i=Array.prototype.slice.call(arguments,2);gs?n=gs.delayedCallbacks:vs?n=vs:(n=vs=[],setTimeout(wt,0));for(var o=0;o<r.length;++o)!function(e){n.push(function(){return r[e].apply(null,i)})}(o)}}function wt(){var e=vs;vs=null;for(var t=0;t<e.length;++t)e[t]()}function xt(e,t,r,n){for(var i=0;i<t.changes.length;i++){var o=t.changes[i];"text"==o?kt(e,t):"gutter"==o?Mt(e,t,r,n):"class"==o?Tt(e,t):"widget"==o&&Nt(e,t,n)}t.changes=null}function Ct(e){return e.node==e.text&&(e.node=n("div",null,null,"position: relative"),e.text.parentNode&&e.text.parentNode.replaceChild(e.node,e.text),e.node.appendChild(e.text),gl&&vl<8&&(e.node.style.zIndex=2)),e.node}function St(e,t){var r=t.bgClass?t.bgClass+" "+(t.line.bgClass||""):t.line.bgClass;if(r&&(r+=" CodeMirror-linebackground"),t.background)r?t.background.className=r:(t.background.parentNode.removeChild(t.background),t.background=null);else if(r){var i=Ct(t);t.background=i.insertBefore(n("div",null,r),i.firstChild),e.display.input.setUneditable(t.background)}}function Lt(e,t){var r=e.display.externalMeasured;return r&&r.line==t.line?(e.display.externalMeasured=null,t.measure=r.measure,r.built):st(e,t)}function kt(e,t){var r=t.text.className,n=Lt(e,t);t.text==t.node&&(t.node=n.pre),t.text.parentNode.replaceChild(n.pre,t.text),t.text=n.pre,n.bgClass!=t.bgClass||n.textClass!=t.textClass?(t.bgClass=n.bgClass,t.textClass=n.textClass,Tt(e,t)):r&&(t.text.className=r)}function Tt(e,t){St(e,t),t.line.wrapClass?Ct(t).className=t.line.wrapClass:t.node!=t.text&&(t.node.className="");var r=t.textClass?t.textClass+" "+(t.line.textClass||""):t.line.textClass;t.text.className=r||""}function Mt(e,t,r,i){if(t.gutter&&(t.node.removeChild(t.gutter),t.gutter=null),t.gutterBackground&&(t.node.removeChild(t.gutterBackground),t.gutterBackground=null),t.line.gutterClass){var o=Ct(t);t.gutterBackground=n("div",null,"CodeMirror-gutter-background "+t.line.gutterClass,"left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px; width: "+i.gutterTotalWidth+"px"),e.display.input.setUneditable(t.gutterBackground),o.insertBefore(t.gutterBackground,t.text)}var l=t.line.gutterMarkers;if(e.options.lineNumbers||l){var s=Ct(t),a=t.gutter=n("div",null,"CodeMirror-gutter-wrapper","left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px");if(e.display.input.setUneditable(a),s.insertBefore(a,t.text),t.line.gutterClass&&(a.className+=" "+t.line.gutterClass),!e.options.lineNumbers||l&&l["CodeMirror-linenumbers"]||(t.lineNumber=a.appendChild(n("div",F(e.options,r),"CodeMirror-linenumber CodeMirror-gutter-elt","left: "+i.gutterLeft["CodeMirror-linenumbers"]+"px; width: "+e.display.lineNumInnerWidth+"px"))),l)for(var u=0;u<e.options.gutters.length;++u){var c=e.options.gutters[u],f=l.hasOwnProperty(c)&&l[c];f&&a.appendChild(n("div",[f],"CodeMirror-gutter-elt","left: "+i.gutterLeft[c]+"px; width: "+i.gutterWidth[c]+"px"))}}}function Nt(e,t,r){t.alignable&&(t.alignable=null);for(var n=t.node.firstChild,i=void 0;n;n=i)i=n.nextSibling,"CodeMirror-linewidget"==n.className&&t.node.removeChild(n);At(e,t,r)}function Ot(e,t,r,n){var i=Lt(e,t);return t.text=t.node=i.pre,i.bgClass&&(t.bgClass=i.bgClass),i.textClass&&(t.textClass=i.textClass),Tt(e,t),Mt(e,t,r,n),At(e,t,n),t.node}function At(e,t,r){if(Wt(e,t.line,t,r,!0),t.rest)for(var n=0;n<t.rest.length;n++)Wt(e,t.rest[n],t,r,!1)}function Wt(e,t,r,i,o){if(t.widgets)for(var l=Ct(r),s=0,a=t.widgets;s<a.length;++s){var u=a[s],c=n("div",[u.node],"CodeMirror-linewidget");u.handleMouseEvents||c.setAttribute("cm-ignore-events","true"),Dt(u,c,r,i),e.display.input.setUneditable(c),o&&u.above?l.insertBefore(c,r.gutter||r.text):l.appendChild(c),bt(u,"redraw")}}function Dt(e,t,r,n){if(e.noHScroll){(r.alignable||(r.alignable=[])).push(t);var i=n.wrapperWidth;t.style.left=n.fixedPos+"px",e.coverGutter||(i-=n.gutterTotalWidth,t.style.paddingLeft=n.gutterTotalWidth+"px"),t.style.width=i+"px"}e.coverGutter&&(t.style.zIndex=5,t.style.position="relative",e.noHScroll||(t.style.marginLeft=-n.gutterTotalWidth+"px"))}function Ht(e){if(null!=e.height)return e.height;var t=e.doc.cm;if(!t)return 0;if(!o(document.body,e.node)){var i="position: relative;";e.coverGutter&&(i+="margin-left: -"+t.display.gutters.offsetWidth+"px;"),e.noHScroll&&(i+="width: "+t.display.wrapper.clientWidth+"px;"),r(t.display.measure,n("div",[e.node],null,i))}return e.height=e.node.parentNode.offsetHeight}function Ft(e,t){for(var r=Ee(t);r!=e.wrapper;r=r.parentNode)if(!r||1==r.nodeType&&"true"==r.getAttribute("cm-ignore-events")||r.parentNode==e.sizer&&r!=e.mover)return!0}function Et(e){return e.lineSpace.offsetTop}function Pt(e){return e.mover.offsetHeight-e.lineSpace.offsetHeight}function It(e){if(e.cachedPaddingH)return e.cachedPaddingH;var t=r(e.measure,n("pre","x")),i=window.getComputedStyle?window.getComputedStyle(t):t.currentStyle,o={left:parseInt(i.paddingLeft),right:parseInt(i.paddingRight)};return isNaN(o.left)||isNaN(o.right)||(e.cachedPaddingH=o),o}function zt(e){return Rl-e.display.nativeBarWidth}function Rt(e){return e.display.scroller.clientWidth-zt(e)-e.display.barWidth}function Bt(e){return e.display.scroller.clientHeight-zt(e)-e.display.barHeight}function Gt(e,t,r){var n=e.options.lineWrapping,i=n&&Rt(e);if(!t.measure.heights||n&&t.measure.width!=i){var o=t.measure.heights=[];if(n){t.measure.width=i;for(var l=t.text.firstChild.getClientRects(),s=0;s<l.length-1;s++){var a=l[s],u=l[s+1];Math.abs(a.bottom-u.bottom)>2&&o.push((a.bottom+u.top)/2-r.top)}}o.push(r.bottom-r.top)}}function Ut(e,t,r){if(e.line==t)return{map:e.measure.map,cache:e.measure.cache};for(var n=0;n<e.rest.length;n++)if(e.rest[n]==t)return{map:e.measure.maps[n],cache:e.measure.caches[n]};for(var i=0;i<e.rest.length;i++)if(W(e.rest[i])>r)return{map:e.measure.maps[i],cache:e.measure.caches[i],before:!0}}function Vt(e,t){var n=W(t=fe(t)),i=e.display.externalMeasured=new pt(e.doc,t,n);i.lineN=n;var o=i.built=st(e,i);return i.text=o.pre,r(e.display.lineMeasure,o.pre),i}function Kt(e,t,r,n){return Yt(e,Xt(e,t),r,n)}function jt(e,t){if(t>=e.display.viewFrom&&t<e.display.viewTo)return e.display.view[Lr(e,t)];var r=e.display.externalMeasured;return r&&t>=r.lineN&&t<r.lineN+r.size?r:void 0}function Xt(e,t){var r=W(t),n=jt(e,r);n&&!n.text?n=null:n&&n.changes&&(xt(e,n,r,br(e)),e.curOp.forceUpdate=!0),n||(n=Vt(e,t));var i=Ut(n,t,r);return{line:t,view:n,rect:null,map:i.map,cache:i.cache,before:i.before,hasHeights:!1}}function Yt(e,t,r,n,i){t.before&&(r=-1);var o,l=r+(n||"");return t.cache.hasOwnProperty(l)?o=t.cache[l]:(t.rect||(t.rect=t.view.text.getBoundingClientRect()),t.hasHeights||(Gt(e,t.view,t.rect),t.hasHeights=!0),(o=qt(e,t,r,n)).bogus||(t.cache[l]=o)),{left:o.left,right:o.right,top:i?o.rtop:o.top,bottom:i?o.rbottom:o.bottom}}function _t(e,t,r){for(var n,i,o,l,s,a,u=0;u<e.length;u+=3)if(s=e[u],a=e[u+1],t<s?(i=0,o=1,l="left"):t<a?o=(i=t-s)+1:(u==e.length-3||t==a&&e[u+3]>t)&&(i=(o=a-s)-1,t>=a&&(l="right")),null!=i){if(n=e[u+2],s==a&&r==(n.insertLeft?"left":"right")&&(l=r),"left"==r&&0==i)for(;u&&e[u-2]==e[u-3]&&e[u-1].insertLeft;)n=e[2+(u-=3)],l="left";if("right"==r&&i==a-s)for(;u<e.length-3&&e[u+3]==e[u+4]&&!e[u+5].insertLeft;)n=e[(u+=3)+2],l="right";break}return{node:n,start:i,end:o,collapse:l,coverStart:s,coverEnd:a}}function $t(e,t){var r=ms;if("left"==t)for(var n=0;n<e.length&&(r=e[n]).left==r.right;n++);else for(var i=e.length-1;i>=0&&(r=e[i]).left==r.right;i--);return r}function qt(e,t,r,n){var i,o=_t(t.map,r,n),l=o.node,s=o.start,a=o.end,u=o.collapse;if(3==l.nodeType){for(var c=0;c<4;c++){for(;s&&S(t.line.text.charAt(o.coverStart+s));)--s;for(;o.coverStart+a<o.coverEnd&&S(t.line.text.charAt(o.coverStart+a));)++a;if((i=gl&&vl<9&&0==s&&a==o.coverEnd-o.coverStart?l.parentNode.getBoundingClientRect():$t(Wl(l,s,a).getClientRects(),n)).left||i.right||0==s)break;a=s,s-=1,u="right"}gl&&vl<11&&(i=Zt(e.display.measure,i))}else{s>0&&(u=n="right");var f;i=e.options.lineWrapping&&(f=l.getClientRects()).length>1?f["right"==n?f.length-1:0]:l.getBoundingClientRect()}if(gl&&vl<9&&!s&&(!i||!i.left&&!i.right)){var h=l.parentNode.getClientRects()[0];i=h?{left:h.left,right:h.left+yr(e.display),top:h.top,bottom:h.bottom}:ms}for(var d=i.top-t.rect.top,p=i.bottom-t.rect.top,g=(d+p)/2,v=t.view.measure.heights,m=0;m<v.length-1&&!(g<v[m]);m++);var y=m?v[m-1]:0,b=v[m],w={left:("right"==u?i.right:i.left)-t.rect.left,right:("left"==u?i.left:i.right)-t.rect.left,top:y,bottom:b};return i.left||i.right||(w.bogus=!0),e.options.singleCursorHeightPerLine||(w.rtop=d,w.rbottom=p),w}function Zt(e,t){if(!window.screen||null==screen.logicalXDPI||screen.logicalXDPI==screen.deviceXDPI||!Re(e))return t;var r=screen.logicalXDPI/screen.deviceXDPI,n=screen.logicalYDPI/screen.deviceYDPI;return{left:t.left*r,right:t.right*r,top:t.top*n,bottom:t.bottom*n}}function Qt(e){if(e.measure&&(e.measure.cache={},e.measure.heights=null,e.rest))for(var t=0;t<e.rest.length;t++)e.measure.caches[t]={}}function Jt(e){e.display.externalMeasure=null,t(e.display.lineMeasure);for(var r=0;r<e.display.view.length;r++)Qt(e.display.view[r])}function er(e){Jt(e),e.display.cachedCharWidth=e.display.cachedTextHeight=e.display.cachedPaddingH=null,e.options.lineWrapping||(e.display.maxLineChanged=!0),e.display.lineNumChars=null}function tr(){return bl&&kl?-(document.body.getBoundingClientRect().left-parseInt(getComputedStyle(document.body).marginLeft)):window.pageXOffset||(document.documentElement||document.body).scrollLeft}function rr(){return bl&&kl?-(document.body.getBoundingClientRect().top-parseInt(getComputedStyle(document.body).marginTop)):window.pageYOffset||(document.documentElement||document.body).scrollTop}function nr(e){var t=0;if(e.widgets)for(var r=0;r<e.widgets.length;++r)e.widgets[r].above&&(t+=Ht(e.widgets[r]));return t}function ir(e,t,r,n,i){if(!i){var o=nr(t);r.top+=o,r.bottom+=o}if("line"==n)return r;n||(n="local");var l=ye(t);if("local"==n?l+=Et(e.display):l-=e.display.viewOffset,"page"==n||"window"==n){var s=e.display.lineSpace.getBoundingClientRect();l+=s.top+("window"==n?0:rr());var a=s.left+("window"==n?0:tr());r.left+=a,r.right+=a}return r.top+=l,r.bottom+=l,r}function or(e,t,r){if("div"==r)return t;var n=t.left,i=t.top;if("page"==r)n-=tr(),i-=rr();else if("local"==r||!r){var o=e.display.sizer.getBoundingClientRect();n+=o.left,i+=o.top}var l=e.display.lineSpace.getBoundingClientRect();return{left:n-l.left,top:i-l.top}}function lr(e,t,r,n,i){return n||(n=M(e.doc,t.line)),ir(e,n,Kt(e,n,t.ch,i),r)}function sr(e,t,r,n,i,o){function l(t,l){var s=Yt(e,i,t,l?"right":"left",o);return l?s.left=s.right:s.right=s.left,ir(e,n,s,r)}function s(e,t,r){var n=1==a[t].level;return l(r?e-1:e,n!=r)}n=n||M(e.doc,t.line),i||(i=Xt(e,n));var a=Se(n,e.doc.direction),u=t.ch,c=t.sticky;if(u>=n.text.length?(u=n.text.length,c="before"):u<=0&&(u=0,c="after"),!a)return l("before"==c?u-1:u,"before"==c);var f=Ce(a,u,c),h=$l,d=s(u,f,"before"==c);return null!=h&&(d.other=s(u,h,"before"!=c)),d}function ar(e,t){var r=0;t=U(e.doc,t),e.options.lineWrapping||(r=yr(e.display)*t.ch);var n=M(e.doc,t.line),i=ye(n)+Et(e.display);return{left:r,right:r,top:i,bottom:i+n.height}}function ur(e,t,r,n,i){var o=E(e,t,r);return o.xRel=i,n&&(o.outside=!0),o}function cr(e,t,r){var n=e.doc;if((r+=e.display.viewOffset)<0)return ur(n.first,0,null,!0,-1);var i=D(n,r),o=n.first+n.size-1;if(i>o)return ur(n.first+n.size-1,M(n,o).text.length,null,!0,1);t<0&&(t=0);for(var l=M(n,i);;){var s=pr(e,l,i,t,r),a=ue(l),u=a&&a.find(0,!0);if(!a||!(s.ch>u.from.ch||s.ch==u.from.ch&&s.xRel>0))return s;i=W(l=u.to.line)}}function fr(e,t,r,n){n-=nr(t);var i=t.text.length,o=k(function(t){return Yt(e,r,t-1).bottom<=n},i,0);return i=k(function(t){return Yt(e,r,t).top>n},o,i),{begin:o,end:i}}function hr(e,t,r,n){return r||(r=Xt(e,t)),fr(e,t,r,ir(e,t,Yt(e,r,n),"line").top)}function dr(e,t,r,n){return!(e.bottom<=r)&&(e.top>r||(n?e.left:e.right)>t)}function pr(e,t,r,n,i){i-=ye(t);var o=Xt(e,t),l=nr(t),s=0,a=t.text.length,u=!0,c=Se(t,e.doc.direction);if(c){var f=(e.options.lineWrapping?vr:gr)(e,t,r,o,c,n,i);s=(u=1!=f.level)?f.from:f.to-1,a=u?f.to:f.from-1}var h,d,p=null,g=null,v=k(function(t){var r=Yt(e,o,t);return r.top+=l,r.bottom+=l,!!dr(r,n,i,!1)&&(r.top<=i&&r.left<=n&&(p=t,g=r),!0)},s,a),m=!1;if(g){var y=n-g.left<g.right-n,b=y==u;v=p+(b?0:1),d=b?"after":"before",h=y?g.left:g.right}else{u||v!=a&&v!=s||v++,d=0==v?"after":v==t.text.length?"before":Yt(e,o,v-(u?1:0)).bottom+l<=i==u?"after":"before";var w=sr(e,E(r,v,d),"line",t,o);h=w.left,m=i<w.top||i>=w.bottom}return v=L(t.text,v,1),ur(r,v,d,m,n-h)}function gr(e,t,r,n,i,o,l){var s=k(function(s){var a=i[s],u=1!=a.level;return dr(sr(e,E(r,u?a.to:a.from,u?"before":"after"),"line",t,n),o,l,!0)},0,i.length-1),a=i[s];if(s>0){var u=1!=a.level,c=sr(e,E(r,u?a.from:a.to,u?"after":"before"),"line",t,n);dr(c,o,l,!0)&&c.top>l&&(a=i[s-1])}return a}function vr(e,t,r,n,i,o,l){for(var s=fr(e,t,n,l),a=s.begin,u=s.end,c=null,f=null,h=0;h<i.length;h++){var d=i[h];if(!(d.from>=u||d.to<=a)){var p=Yt(e,n,1!=d.level?Math.min(u,d.to)-1:Math.max(a,d.from)).right,g=p<o?o-p+1e9:p-o;(!c||f>g)&&(c=d,f=g)}}return c||(c=i[i.length-1]),c.from<a&&(c={from:a,to:c.to,level:c.level}),c.to>u&&(c={from:c.from,to:u,level:c.level}),c}function mr(e){if(null!=e.cachedTextHeight)return e.cachedTextHeight;if(null==hs){hs=n("pre");for(var i=0;i<49;++i)hs.appendChild(document.createTextNode("x")),hs.appendChild(n("br"));hs.appendChild(document.createTextNode("x"))}r(e.measure,hs);var o=hs.offsetHeight/50;return o>3&&(e.cachedTextHeight=o),t(e.measure),o||1}function yr(e){if(null!=e.cachedCharWidth)return e.cachedCharWidth;var t=n("span","xxxxxxxxxx"),i=n("pre",[t]);r(e.measure,i);var o=t.getBoundingClientRect(),l=(o.right-o.left)/10;return l>2&&(e.cachedCharWidth=l),l||10}function br(e){for(var t=e.display,r={},n={},i=t.gutters.clientLeft,o=t.gutters.firstChild,l=0;o;o=o.nextSibling,++l)r[e.options.gutters[l]]=o.offsetLeft+o.clientLeft+i,n[e.options.gutters[l]]=o.clientWidth;return{fixedPos:wr(t),gutterTotalWidth:t.gutters.offsetWidth,gutterLeft:r,gutterWidth:n,wrapperWidth:t.wrapper.clientWidth}}function wr(e){return e.scroller.getBoundingClientRect().left-e.sizer.getBoundingClientRect().left}function xr(e){var t=mr(e.display),r=e.options.lineWrapping,n=r&&Math.max(5,e.display.scroller.clientWidth/yr(e.display)-3);return function(i){if(ve(e.doc,i))return 0;var o=0;if(i.widgets)for(var l=0;l<i.widgets.length;l++)i.widgets[l].height&&(o+=i.widgets[l].height);return r?o+(Math.ceil(i.text.length/n)||1)*t:o+t}}function Cr(e){var t=e.doc,r=xr(e);t.iter(function(e){var t=r(e);t!=e.height&&A(e,t)})}function Sr(e,t,r,n){var i=e.display;if(!r&&"true"==Ee(t).getAttribute("cm-not-content"))return null;var o,l,s=i.lineSpace.getBoundingClientRect();try{o=t.clientX-s.left,l=t.clientY-s.top}catch(t){return null}var a,u=cr(e,o,l);if(n&&1==u.xRel&&(a=M(e.doc,u.line).text).length==u.ch){var c=f(a,a.length,e.options.tabSize)-a.length;u=E(u.line,Math.max(0,Math.round((o-It(e.display).left)/yr(e.display))-c))}return u}function Lr(e,t){if(t>=e.display.viewTo)return null;if((t-=e.display.viewFrom)<0)return null;for(var r=e.display.view,n=0;n<r.length;n++)if((t-=r[n].size)<0)return n}function kr(e){e.display.input.showSelection(e.display.input.prepareSelection())}function Tr(e,t){void 0===t&&(t=!0);for(var r=e.doc,n={},i=n.cursors=document.createDocumentFragment(),o=n.selection=document.createDocumentFragment(),l=0;l<r.sel.ranges.length;l++)if(t||l!=r.sel.primIndex){var s=r.sel.ranges[l];if(!(s.from().line>=e.display.viewTo||s.to().line<e.display.viewFrom)){var a=s.empty();(a||e.options.showCursorWhenSelecting)&&Mr(e,s.head,i),a||Or(e,s,o)}}return n}function Mr(e,t,r){var i=sr(e,t,"div",null,null,!e.options.singleCursorHeightPerLine),o=r.appendChild(n("div"," ","CodeMirror-cursor"));if(o.style.left=i.left+"px",o.style.top=i.top+"px",o.style.height=Math.max(0,i.bottom-i.top)*e.options.cursorHeight+"px",i.other){var l=r.appendChild(n("div"," ","CodeMirror-cursor CodeMirror-secondarycursor"));l.style.display="",l.style.left=i.other.left+"px",l.style.top=i.other.top+"px",l.style.height=.85*(i.other.bottom-i.other.top)+"px"}}function Nr(e,t){return e.top-t.top||e.left-t.left}function Or(e,t,r){function i(e,t,r,i){t<0&&(t=0),t=Math.round(t),i=Math.round(i),a.appendChild(n("div",null,"CodeMirror-selected","position: absolute; left: "+e+"px;\n                             top: "+t+"px; width: "+(null==r?f-e:r)+"px;\n                             height: "+(i-t)+"px"))}function o(t,r,n){function o(r,n){return lr(e,E(t,r),"div",u,n)}var l,a,u=M(s,t),h=u.text.length,d=Se(u,s.direction);return xe(d,r||0,null==n?h:n,function(t,s,p,g){var v=o(t,"ltr"==p?"left":"right"),m=o(s-1,"ltr"==p?"right":"left");if("ltr"==p){var y=null==r&&0==t?c:v.left,b=null==n&&s==h?f:m.right;m.top-v.top<=3?i(y,m.top,b-y,m.bottom):(i(y,v.top,null,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top),i(c,m.top,m.right,m.bottom))}else if(t<s){var w=null==r&&0==t?f:v.right,x=null==n&&s==h?c:m.left;if(m.top-v.top<=3)i(x,m.top,w-x,m.bottom);else{var C=c;if(g){var S=hr(e,u,null,t).end;C=o(S-(/\s/.test(u.text.charAt(S-1))?2:1),"left").left}i(C,v.top,w-C,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top);var L=null;d.length,L=o(hr(e,u,null,s).begin,"right").right-x,i(x,m.top,L,m.bottom)}}(!l||Nr(v,l)<0)&&(l=v),Nr(m,l)<0&&(l=m),(!a||Nr(v,a)<0)&&(a=v),Nr(m,a)<0&&(a=m)}),{start:l,end:a}}var l=e.display,s=e.doc,a=document.createDocumentFragment(),u=It(e.display),c=u.left,f=Math.max(l.sizerWidth,Rt(e)-l.sizer.offsetLeft)-u.right,h=t.from(),d=t.to();if(h.line==d.line)o(h.line,h.ch,d.ch);else{var p=M(s,h.line),g=M(s,d.line),v=fe(p)==fe(g),m=o(h.line,h.ch,v?p.text.length+1:null).end,y=o(d.line,v?0:null,d.ch).start;v&&(m.top<y.top-2?(i(m.right,m.top,null,m.bottom),i(c,y.top,y.left,y.bottom)):i(m.right,m.top,y.left-m.right,m.bottom)),m.bottom<y.top&&i(c,m.bottom,null,y.top)}r.appendChild(a)}function Ar(e){if(e.state.focused){var t=e.display;clearInterval(t.blinker);var r=!0;t.cursorDiv.style.visibility="",e.options.cursorBlinkRate>0?t.blinker=setInterval(function(){return t.cursorDiv.style.visibility=(r=!r)?"":"hidden"},e.options.cursorBlinkRate):e.options.cursorBlinkRate<0&&(t.cursorDiv.style.visibility="hidden")}}function Wr(e){e.state.focused||(e.display.input.focus(),Hr(e))}function Dr(e){e.state.delayingBlurEvent=!0,setTimeout(function(){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1,Fr(e))},100)}function Hr(e,t){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1),"nocursor"!=e.options.readOnly&&(e.state.focused||(Te(e,"focus",e,t),e.state.focused=!0,s(e.display.wrapper,"CodeMirror-focused"),e.curOp||e.display.selForContextMenu==e.doc.sel||(e.display.input.reset(),ml&&setTimeout(function(){return e.display.input.reset(!0)},20)),e.display.input.receivedFocus()),Ar(e))}function Fr(e,t){e.state.delayingBlurEvent||(e.state.focused&&(Te(e,"blur",e,t),e.state.focused=!1,Fl(e.display.wrapper,"CodeMirror-focused")),clearInterval(e.display.blinker),setTimeout(function(){e.state.focused||(e.display.shift=!1)},150))}function Er(e){for(var t=e.display,r=t.lineDiv.offsetTop,n=0;n<t.view.length;n++){var i=t.view[n],o=void 0;if(!i.hidden){if(gl&&vl<8){var l=i.node.offsetTop+i.node.offsetHeight;o=l-r,r=l}else{var s=i.node.getBoundingClientRect();o=s.bottom-s.top}var a=i.line.height-o;if(o<2&&(o=mr(t)),(a>.005||a<-.005)&&(A(i.line,o),Pr(i.line),i.rest))for(var u=0;u<i.rest.length;u++)Pr(i.rest[u])}}}function Pr(e){if(e.widgets)for(var t=0;t<e.widgets.length;++t)e.widgets[t].height=e.widgets[t].node.parentNode.offsetHeight}function Ir(e,t,r){var n=r&&null!=r.top?Math.max(0,r.top):e.scroller.scrollTop;n=Math.floor(n-Et(e));var i=r&&null!=r.bottom?r.bottom:n+e.wrapper.clientHeight,o=D(t,n),l=D(t,i);if(r&&r.ensure){var s=r.ensure.from.line,a=r.ensure.to.line;s<o?(o=s,l=D(t,ye(M(t,s))+e.wrapper.clientHeight)):Math.min(a,t.lastLine())>=l&&(o=D(t,ye(M(t,a))-e.wrapper.clientHeight),l=a)}return{from:o,to:Math.max(l,o+1)}}function zr(e){var t=e.display,r=t.view;if(t.alignWidgets||t.gutters.firstChild&&e.options.fixedGutter){for(var n=wr(t)-t.scroller.scrollLeft+e.doc.scrollLeft,i=t.gutters.offsetWidth,o=n+"px",l=0;l<r.length;l++)if(!r[l].hidden){e.options.fixedGutter&&(r[l].gutter&&(r[l].gutter.style.left=o),r[l].gutterBackground&&(r[l].gutterBackground.style.left=o));var s=r[l].alignable;if(s)for(var a=0;a<s.length;a++)s[a].style.left=o}e.options.fixedGutter&&(t.gutters.style.left=n+i+"px")}}function Rr(e){if(!e.options.lineNumbers)return!1;var t=e.doc,r=F(e.options,t.first+t.size-1),i=e.display;if(r.length!=i.lineNumChars){var o=i.measure.appendChild(n("div",[n("div",r)],"CodeMirror-linenumber CodeMirror-gutter-elt")),l=o.firstChild.offsetWidth,s=o.offsetWidth-l;return i.lineGutter.style.width="",i.lineNumInnerWidth=Math.max(l,i.lineGutter.offsetWidth-s)+1,i.lineNumWidth=i.lineNumInnerWidth+s,i.lineNumChars=i.lineNumInnerWidth?r.length:-1,i.lineGutter.style.width=i.lineNumWidth+"px",Wn(e),!0}return!1}function Br(e,t){if(!Me(e,"scrollCursorIntoView")){var r=e.display,i=r.sizer.getBoundingClientRect(),o=null;if(t.top+i.top<0?o=!0:t.bottom+i.top>(window.innerHeight||document.documentElement.clientHeight)&&(o=!1),null!=o&&!Sl){var l=n("div","​",null,"position: absolute;\n                         top: "+(t.top-r.viewOffset-Et(e.display))+"px;\n                         height: "+(t.bottom-t.top+zt(e)+r.barHeight)+"px;\n                         left: "+t.left+"px; width: "+Math.max(2,t.right-t.left)+"px;");e.display.lineSpace.appendChild(l),l.scrollIntoView(o),e.display.lineSpace.removeChild(l)}}}function Gr(e,t,r,n){null==n&&(n=0);var i;e.options.lineWrapping||t!=r||(r="before"==(t=t.ch?E(t.line,"before"==t.sticky?t.ch-1:t.ch,"after"):t).sticky?E(t.line,t.ch+1,"before"):t);for(var o=0;o<5;o++){var l=!1,s=sr(e,t),a=r&&r!=t?sr(e,r):s,u=Vr(e,i={left:Math.min(s.left,a.left),top:Math.min(s.top,a.top)-n,right:Math.max(s.left,a.left),bottom:Math.max(s.bottom,a.bottom)+n}),c=e.doc.scrollTop,f=e.doc.scrollLeft;if(null!=u.scrollTop&&(qr(e,u.scrollTop),Math.abs(e.doc.scrollTop-c)>1&&(l=!0)),null!=u.scrollLeft&&(Qr(e,u.scrollLeft),Math.abs(e.doc.scrollLeft-f)>1&&(l=!0)),!l)break}return i}function Ur(e,t){var r=Vr(e,t);null!=r.scrollTop&&qr(e,r.scrollTop),null!=r.scrollLeft&&Qr(e,r.scrollLeft)}function Vr(e,t){var r=e.display,n=mr(e.display);t.top<0&&(t.top=0);var i=e.curOp&&null!=e.curOp.scrollTop?e.curOp.scrollTop:r.scroller.scrollTop,o=Bt(e),l={};t.bottom-t.top>o&&(t.bottom=t.top+o);var s=e.doc.height+Pt(r),a=t.top<n,u=t.bottom>s-n;if(t.top<i)l.scrollTop=a?0:t.top;else if(t.bottom>i+o){var c=Math.min(t.top,(u?s:t.bottom)-o);c!=i&&(l.scrollTop=c)}var f=e.curOp&&null!=e.curOp.scrollLeft?e.curOp.scrollLeft:r.scroller.scrollLeft,h=Rt(e)-(e.options.fixedGutter?r.gutters.offsetWidth:0),d=t.right-t.left>h;return d&&(t.right=t.left+h),t.left<10?l.scrollLeft=0:t.left<f?l.scrollLeft=Math.max(0,t.left-(d?0:10)):t.right>h+f-3&&(l.scrollLeft=t.right+(d?0:10)-h),l}function Kr(e,t){null!=t&&(_r(e),e.curOp.scrollTop=(null==e.curOp.scrollTop?e.doc.scrollTop:e.curOp.scrollTop)+t)}function jr(e){_r(e);var t=e.getCursor();e.curOp.scrollToPos={from:t,to:t,margin:e.options.cursorScrollMargin}}function Xr(e,t,r){null==t&&null==r||_r(e),null!=t&&(e.curOp.scrollLeft=t),null!=r&&(e.curOp.scrollTop=r)}function Yr(e,t){_r(e),e.curOp.scrollToPos=t}function _r(e){var t=e.curOp.scrollToPos;t&&(e.curOp.scrollToPos=null,$r(e,ar(e,t.from),ar(e,t.to),t.margin))}function $r(e,t,r,n){var i=Vr(e,{left:Math.min(t.left,r.left),top:Math.min(t.top,r.top)-n,right:Math.max(t.right,r.right),bottom:Math.max(t.bottom,r.bottom)+n});Xr(e,i.scrollLeft,i.scrollTop)}function qr(e,t){Math.abs(e.doc.scrollTop-t)<2||(fl||On(e,{top:t}),Zr(e,t,!0),fl&&On(e),Cn(e,100))}function Zr(e,t,r){t=Math.min(e.display.scroller.scrollHeight-e.display.scroller.clientHeight,t),(e.display.scroller.scrollTop!=t||r)&&(e.doc.scrollTop=t,e.display.scrollbars.setScrollTop(t),e.display.scroller.scrollTop!=t&&(e.display.scroller.scrollTop=t))}function Qr(e,t,r,n){t=Math.min(t,e.display.scroller.scrollWidth-e.display.scroller.clientWidth),(r?t==e.doc.scrollLeft:Math.abs(e.doc.scrollLeft-t)<2)&&!n||(e.doc.scrollLeft=t,zr(e),e.display.scroller.scrollLeft!=t&&(e.display.scroller.scrollLeft=t),e.display.scrollbars.setScrollLeft(t))}function Jr(e){var t=e.display,r=t.gutters.offsetWidth,n=Math.round(e.doc.height+Pt(e.display));return{clientHeight:t.scroller.clientHeight,viewHeight:t.wrapper.clientHeight,scrollWidth:t.scroller.scrollWidth,clientWidth:t.scroller.clientWidth,viewWidth:t.wrapper.clientWidth,barLeft:e.options.fixedGutter?r:0,docHeight:n,scrollHeight:n+zt(e)+t.barHeight,nativeBarWidth:t.nativeBarWidth,gutterWidth:r}}function en(e,t){t||(t=Jr(e));var r=e.display.barWidth,n=e.display.barHeight;tn(e,t);for(var i=0;i<4&&r!=e.display.barWidth||n!=e.display.barHeight;i++)r!=e.display.barWidth&&e.options.lineWrapping&&Er(e),tn(e,Jr(e)),r=e.display.barWidth,n=e.display.barHeight}function tn(e,t){var r=e.display,n=r.scrollbars.update(t);r.sizer.style.paddingRight=(r.barWidth=n.right)+"px",r.sizer.style.paddingBottom=(r.barHeight=n.bottom)+"px",r.heightForcer.style.borderBottom=n.bottom+"px solid transparent",n.right&&n.bottom?(r.scrollbarFiller.style.display="block",r.scrollbarFiller.style.height=n.bottom+"px",r.scrollbarFiller.style.width=n.right+"px"):r.scrollbarFiller.style.display="",n.bottom&&e.options.coverGutterNextToScrollbar&&e.options.fixedGutter?(r.gutterFiller.style.display="block",r.gutterFiller.style.height=n.bottom+"px",r.gutterFiller.style.width=t.gutterWidth+"px"):r.gutterFiller.style.display=""}function rn(e){e.display.scrollbars&&(e.display.scrollbars.clear(),e.display.scrollbars.addClass&&Fl(e.display.wrapper,e.display.scrollbars.addClass)),e.display.scrollbars=new ws[e.options.scrollbarStyle](function(t){e.display.wrapper.insertBefore(t,e.display.scrollbarFiller),Ql(t,"mousedown",function(){e.state.focused&&setTimeout(function(){return e.display.input.focus()},0)}),t.setAttribute("cm-not-content","true")},function(t,r){"horizontal"==r?Qr(e,t):qr(e,t)},e),e.display.scrollbars.addClass&&s(e.display.wrapper,e.display.scrollbars.addClass)}function nn(e){e.curOp={cm:e,viewChanged:!1,startHeight:e.doc.height,forceUpdate:!1,updateInput:null,typing:!1,changeObjs:null,cursorActivityHandlers:null,cursorActivityCalled:0,selectionChanged:!1,updateMaxLine:!1,scrollLeft:null,scrollTop:null,scrollToPos:null,focus:!1,id:++xs},vt(e.curOp)}function on(e){yt(e.curOp,function(e){for(var t=0;t<e.ops.length;t++)e.ops[t].cm.curOp=null;ln(e)})}function ln(e){for(var t=e.ops,r=0;r<t.length;r++)sn(t[r]);for(var n=0;n<t.length;n++)an(t[n]);for(var i=0;i<t.length;i++)un(t[i]);for(var o=0;o<t.length;o++)cn(t[o]);for(var l=0;l<t.length;l++)fn(t[l])}function sn(e){var t=e.cm,r=t.display;Ln(t),e.updateMaxLine&&we(t),e.mustUpdate=e.viewChanged||e.forceUpdate||null!=e.scrollTop||e.scrollToPos&&(e.scrollToPos.from.line<r.viewFrom||e.scrollToPos.to.line>=r.viewTo)||r.maxLineChanged&&t.options.lineWrapping,e.update=e.mustUpdate&&new Cs(t,e.mustUpdate&&{top:e.scrollTop,ensure:e.scrollToPos},e.forceUpdate)}function an(e){e.updatedDisplay=e.mustUpdate&&Mn(e.cm,e.update)}function un(e){var t=e.cm,r=t.display;e.updatedDisplay&&Er(t),e.barMeasure=Jr(t),r.maxLineChanged&&!t.options.lineWrapping&&(e.adjustWidthTo=Kt(t,r.maxLine,r.maxLine.text.length).left+3,t.display.sizerWidth=e.adjustWidthTo,e.barMeasure.scrollWidth=Math.max(r.scroller.clientWidth,r.sizer.offsetLeft+e.adjustWidthTo+zt(t)+t.display.barWidth),e.maxScrollLeft=Math.max(0,r.sizer.offsetLeft+e.adjustWidthTo-Rt(t))),(e.updatedDisplay||e.selectionChanged)&&(e.preparedSelection=r.input.prepareSelection())}function cn(e){var t=e.cm;null!=e.adjustWidthTo&&(t.display.sizer.style.minWidth=e.adjustWidthTo+"px",e.maxScrollLeft<t.doc.scrollLeft&&Qr(t,Math.min(t.display.scroller.scrollLeft,e.maxScrollLeft),!0),t.display.maxLineChanged=!1);var r=e.focus&&e.focus==l();e.preparedSelection&&t.display.input.showSelection(e.preparedSelection,r),(e.updatedDisplay||e.startHeight!=t.doc.height)&&en(t,e.barMeasure),e.updatedDisplay&&Dn(t,e.barMeasure),e.selectionChanged&&Ar(t),t.state.focused&&e.updateInput&&t.display.input.reset(e.typing),r&&Wr(e.cm)}function fn(e){var t=e.cm,r=t.display,n=t.doc;e.updatedDisplay&&Nn(t,e.update),null==r.wheelStartX||null==e.scrollTop&&null==e.scrollLeft&&!e.scrollToPos||(r.wheelStartX=r.wheelStartY=null),null!=e.scrollTop&&Zr(t,e.scrollTop,e.forceScroll),null!=e.scrollLeft&&Qr(t,e.scrollLeft,!0,!0),e.scrollToPos&&Br(t,Gr(t,U(n,e.scrollToPos.from),U(n,e.scrollToPos.to),e.scrollToPos.margin));var i=e.maybeHiddenMarkers,o=e.maybeUnhiddenMarkers;if(i)for(var l=0;l<i.length;++l)i[l].lines.length||Te(i[l],"hide");if(o)for(var s=0;s<o.length;++s)o[s].lines.length&&Te(o[s],"unhide");r.wrapper.offsetHeight&&(n.scrollTop=t.display.scroller.scrollTop),e.changeObjs&&Te(t,"changes",t,e.changeObjs),e.update&&e.update.finish()}function hn(e,t){if(e.curOp)return t();nn(e);try{return t()}finally{on(e)}}function dn(e,t){return function(){if(e.curOp)return t.apply(e,arguments);nn(e);try{return t.apply(e,arguments)}finally{on(e)}}}function pn(e){return function(){if(this.curOp)return e.apply(this,arguments);nn(this);try{return e.apply(this,arguments)}finally{on(this)}}}function gn(e){return function(){var t=this.cm;if(!t||t.curOp)return e.apply(this,arguments);nn(t);try{return e.apply(this,arguments)}finally{on(t)}}}function vn(e,t,r,n){null==t&&(t=e.doc.first),null==r&&(r=e.doc.first+e.doc.size),n||(n=0);var i=e.display;if(n&&r<i.viewTo&&(null==i.updateLineNumbers||i.updateLineNumbers>t)&&(i.updateLineNumbers=t),e.curOp.viewChanged=!0,t>=i.viewTo)_l&&pe(e.doc,t)<i.viewTo&&yn(e);else if(r<=i.viewFrom)_l&&ge(e.doc,r+n)>i.viewFrom?yn(e):(i.viewFrom+=n,i.viewTo+=n);else if(t<=i.viewFrom&&r>=i.viewTo)yn(e);else if(t<=i.viewFrom){var o=bn(e,r,r+n,1);o?(i.view=i.view.slice(o.index),i.viewFrom=o.lineN,i.viewTo+=n):yn(e)}else if(r>=i.viewTo){var l=bn(e,t,t,-1);l?(i.view=i.view.slice(0,l.index),i.viewTo=l.lineN):yn(e)}else{var s=bn(e,t,t,-1),a=bn(e,r,r+n,1);s&&a?(i.view=i.view.slice(0,s.index).concat(gt(e,s.lineN,a.lineN)).concat(i.view.slice(a.index)),i.viewTo+=n):yn(e)}var u=i.externalMeasured;u&&(r<u.lineN?u.lineN+=n:t<u.lineN+u.size&&(i.externalMeasured=null))}function mn(e,t,r){e.curOp.viewChanged=!0;var n=e.display,i=e.display.externalMeasured;if(i&&t>=i.lineN&&t<i.lineN+i.size&&(n.externalMeasured=null),!(t<n.viewFrom||t>=n.viewTo)){var o=n.view[Lr(e,t)];if(null!=o.node){var l=o.changes||(o.changes=[]);-1==h(l,r)&&l.push(r)}}}function yn(e){e.display.viewFrom=e.display.viewTo=e.doc.first,e.display.view=[],e.display.viewOffset=0}function bn(e,t,r,n){var i,o=Lr(e,t),l=e.display.view;if(!_l||r==e.doc.first+e.doc.size)return{index:o,lineN:r};for(var s=e.display.viewFrom,a=0;a<o;a++)s+=l[a].size;if(s!=t){if(n>0){if(o==l.length-1)return null;i=s+l[o].size-t,o++}else i=s-t;t+=i,r+=i}for(;pe(e.doc,r)!=r;){if(o==(n<0?0:l.length-1))return null;r+=n*l[o-(n<0?1:0)].size,o+=n}return{index:o,lineN:r}}function wn(e,t,r){var n=e.display;0==n.view.length||t>=n.viewTo||r<=n.viewFrom?(n.view=gt(e,t,r),n.viewFrom=t):(n.viewFrom>t?n.view=gt(e,t,n.viewFrom).concat(n.view):n.viewFrom<t&&(n.view=n.view.slice(Lr(e,t))),n.viewFrom=t,n.viewTo<r?n.view=n.view.concat(gt(e,n.viewTo,r)):n.viewTo>r&&(n.view=n.view.slice(0,Lr(e,r)))),n.viewTo=r}function xn(e){for(var t=e.display.view,r=0,n=0;n<t.length;n++){var i=t[n];i.hidden||i.node&&!i.changes||++r}return r}function Cn(e,t){e.doc.highlightFrontier<e.display.viewTo&&e.state.highlight.set(t,u(Sn,e))}function Sn(e){var t=e.doc;if(!(t.highlightFrontier>=e.display.viewTo)){var r=+new Date+e.options.workTime,n=$e(e,t.highlightFrontier),i=[];t.iter(n.line,Math.min(t.first+t.size,e.display.viewTo+500),function(o){if(n.line>=e.display.viewFrom){var l=o.styles,s=o.text.length>e.options.maxHighlightLength?Ke(t.mode,n.state):null,a=Ye(e,o,n,!0);s&&(n.state=s),o.styles=a.styles;var u=o.styleClasses,c=a.classes;c?o.styleClasses=c:u&&(o.styleClasses=null);for(var f=!l||l.length!=o.styles.length||u!=c&&(!u||!c||u.bgClass!=c.bgClass||u.textClass!=c.textClass),h=0;!f&&h<l.length;++h)f=l[h]!=o.styles[h];f&&i.push(n.line),o.stateAfter=n.save(),n.nextLine()}else o.text.length<=e.options.maxHighlightLength&&qe(e,o.text,n),o.stateAfter=n.line%5==0?n.save():null,n.nextLine();if(+new Date>r)return Cn(e,e.options.workDelay),!0}),t.highlightFrontier=n.line,t.modeFrontier=Math.max(t.modeFrontier,n.line),i.length&&hn(e,function(){for(var t=0;t<i.length;t++)mn(e,i[t],"text")})}}function Ln(e){var t=e.display;!t.scrollbarsClipped&&t.scroller.offsetWidth&&(t.nativeBarWidth=t.scroller.offsetWidth-t.scroller.clientWidth,t.heightForcer.style.height=zt(e)+"px",t.sizer.style.marginBottom=-t.nativeBarWidth+"px",t.sizer.style.borderRightWidth=zt(e)+"px",t.scrollbarsClipped=!0)}function kn(e){if(e.hasFocus())return null;var t=l();if(!t||!o(e.display.lineDiv,t))return null;var r={activeElt:t};if(window.getSelection){var n=window.getSelection();n.anchorNode&&n.extend&&o(e.display.lineDiv,n.anchorNode)&&(r.anchorNode=n.anchorNode,r.anchorOffset=n.anchorOffset,r.focusNode=n.focusNode,r.focusOffset=n.focusOffset)}return r}function Tn(e){if(e&&e.activeElt&&e.activeElt!=l()&&(e.activeElt.focus(),e.anchorNode&&o(document.body,e.anchorNode)&&o(document.body,e.focusNode))){var t=window.getSelection(),r=document.createRange();r.setEnd(e.anchorNode,e.anchorOffset),r.collapse(!1),t.removeAllRanges(),t.addRange(r),t.extend(e.focusNode,e.focusOffset)}}function Mn(e,r){var n=e.display,i=e.doc;if(r.editorIsHidden)return yn(e),!1;if(!r.force&&r.visible.from>=n.viewFrom&&r.visible.to<=n.viewTo&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo)&&n.renderedView==n.view&&0==xn(e))return!1;Rr(e)&&(yn(e),r.dims=br(e));var o=i.first+i.size,l=Math.max(r.visible.from-e.options.viewportMargin,i.first),s=Math.min(o,r.visible.to+e.options.viewportMargin);n.viewFrom<l&&l-n.viewFrom<20&&(l=Math.max(i.first,n.viewFrom)),n.viewTo>s&&n.viewTo-s<20&&(s=Math.min(o,n.viewTo)),_l&&(l=pe(e.doc,l),s=ge(e.doc,s));var a=l!=n.viewFrom||s!=n.viewTo||n.lastWrapHeight!=r.wrapperHeight||n.lastWrapWidth!=r.wrapperWidth;wn(e,l,s),n.viewOffset=ye(M(e.doc,n.viewFrom)),e.display.mover.style.top=n.viewOffset+"px";var u=xn(e);if(!a&&0==u&&!r.force&&n.renderedView==n.view&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo))return!1;var c=kn(e);return u>4&&(n.lineDiv.style.display="none"),An(e,n.updateLineNumbers,r.dims),u>4&&(n.lineDiv.style.display=""),n.renderedView=n.view,Tn(c),t(n.cursorDiv),t(n.selectionDiv),n.gutters.style.height=n.sizer.style.minHeight=0,a&&(n.lastWrapHeight=r.wrapperHeight,n.lastWrapWidth=r.wrapperWidth,Cn(e,400)),n.updateLineNumbers=null,!0}function Nn(e,t){for(var r=t.viewport,n=!0;(n&&e.options.lineWrapping&&t.oldDisplayWidth!=Rt(e)||(r&&null!=r.top&&(r={top:Math.min(e.doc.height+Pt(e.display)-Bt(e),r.top)}),t.visible=Ir(e.display,e.doc,r),!(t.visible.from>=e.display.viewFrom&&t.visible.to<=e.display.viewTo)))&&Mn(e,t);n=!1){Er(e);var i=Jr(e);kr(e),en(e,i),Dn(e,i),t.force=!1}t.signal(e,"update",e),e.display.viewFrom==e.display.reportedViewFrom&&e.display.viewTo==e.display.reportedViewTo||(t.signal(e,"viewportChange",e,e.display.viewFrom,e.display.viewTo),e.display.reportedViewFrom=e.display.viewFrom,e.display.reportedViewTo=e.display.viewTo)}function On(e,t){var r=new Cs(e,t);if(Mn(e,r)){Er(e),Nn(e,r);var n=Jr(e);kr(e),en(e,n),Dn(e,n),r.finish()}}function An(e,r,n){function i(t){var r=t.nextSibling;return ml&&Ml&&e.display.currentWheelTarget==t?t.style.display="none":t.parentNode.removeChild(t),r}for(var o=e.display,l=e.options.lineNumbers,s=o.lineDiv,a=s.firstChild,u=o.view,c=o.viewFrom,f=0;f<u.length;f++){var d=u[f];if(d.hidden);else if(d.node&&d.node.parentNode==s){for(;a!=d.node;)a=i(a);var p=l&&null!=r&&r<=c&&d.lineNumber;d.changes&&(h(d.changes,"gutter")>-1&&(p=!1),xt(e,d,c,n)),p&&(t(d.lineNumber),d.lineNumber.appendChild(document.createTextNode(F(e.options,c)))),a=d.node.nextSibling}else{var g=Ot(e,d,c,n);s.insertBefore(g,a)}c+=d.size}for(;a;)a=i(a)}function Wn(e){var t=e.display.gutters.offsetWidth;e.display.sizer.style.marginLeft=t+"px"}function Dn(e,t){e.display.sizer.style.minHeight=t.docHeight+"px",e.display.heightForcer.style.top=t.docHeight+"px",e.display.gutters.style.height=t.docHeight+e.display.barHeight+zt(e)+"px"}function Hn(e){var r=e.display.gutters,i=e.options.gutters;t(r);for(var o=0;o<i.length;++o){var l=i[o],s=r.appendChild(n("div",null,"CodeMirror-gutter "+l));"CodeMirror-linenumbers"==l&&(e.display.lineGutter=s,s.style.width=(e.display.lineNumWidth||1)+"px")}r.style.display=o?"":"none",Wn(e)}function Fn(e){var t=h(e.gutters,"CodeMirror-linenumbers");-1==t&&e.lineNumbers?e.gutters=e.gutters.concat(["CodeMirror-linenumbers"]):t>-1&&!e.lineNumbers&&(e.gutters=e.gutters.slice(0),e.gutters.splice(t,1))}function En(e){var t=e.wheelDeltaX,r=e.wheelDeltaY;return null==t&&e.detail&&e.axis==e.HORIZONTAL_AXIS&&(t=e.detail),null==r&&e.detail&&e.axis==e.VERTICAL_AXIS?r=e.detail:null==r&&(r=e.wheelDelta),{x:t,y:r}}function Pn(e){var t=En(e);return t.x*=Ls,t.y*=Ls,t}function In(e,t){var r=En(t),n=r.x,i=r.y,o=e.display,l=o.scroller,s=l.scrollWidth>l.clientWidth,a=l.scrollHeight>l.clientHeight;if(n&&s||i&&a){if(i&&Ml&&ml)e:for(var u=t.target,c=o.view;u!=l;u=u.parentNode)for(var f=0;f<c.length;f++)if(c[f].node==u){e.display.currentWheelTarget=u;break e}if(n&&!fl&&!wl&&null!=Ls)return i&&a&&qr(e,Math.max(0,l.scrollTop+i*Ls)),Qr(e,Math.max(0,l.scrollLeft+n*Ls)),(!i||i&&a)&&We(t),void(o.wheelStartX=null);if(i&&null!=Ls){var h=i*Ls,d=e.doc.scrollTop,p=d+o.wrapper.clientHeight;h<0?d=Math.max(0,d+h-50):p=Math.min(e.doc.height,p+h+50),On(e,{top:d,bottom:p})}Ss<20&&(null==o.wheelStartX?(o.wheelStartX=l.scrollLeft,o.wheelStartY=l.scrollTop,o.wheelDX=n,o.wheelDY=i,setTimeout(function(){if(null!=o.wheelStartX){var e=l.scrollLeft-o.wheelStartX,t=l.scrollTop-o.wheelStartY,r=t&&o.wheelDY&&t/o.wheelDY||e&&o.wheelDX&&e/o.wheelDX;o.wheelStartX=o.wheelStartY=null,r&&(Ls=(Ls*Ss+r)/(Ss+1),++Ss)}},200)):(o.wheelDX+=n,o.wheelDY+=i))}}function zn(e,t){var r=e[t];e.sort(function(e,t){return P(e.from(),t.from())}),t=h(e,r);for(var n=1;n<e.length;n++){var i=e[n],o=e[n-1];if(P(o.to(),i.from())>=0){var l=B(o.from(),i.from()),s=R(o.to(),i.to()),a=o.empty()?i.from()==i.head:o.from()==o.head;n<=t&&--t,e.splice(--n,2,new Ts(a?s:l,a?l:s))}}return new ks(e,t)}function Rn(e,t){return new ks([new Ts(e,t||e)],0)}function Bn(e){return e.text?E(e.from.line+e.text.length-1,g(e.text).length+(1==e.text.length?e.from.ch:0)):e.to}function Gn(e,t){if(P(e,t.from)<0)return e;if(P(e,t.to)<=0)return Bn(t);var r=e.line+t.text.length-(t.to.line-t.from.line)-1,n=e.ch;return e.line==t.to.line&&(n+=Bn(t).ch-t.to.ch),E(r,n)}function Un(e,t){for(var r=[],n=0;n<e.sel.ranges.length;n++){var i=e.sel.ranges[n];r.push(new Ts(Gn(i.anchor,t),Gn(i.head,t)))}return zn(r,e.sel.primIndex)}function Vn(e,t,r){return e.line==t.line?E(r.line,e.ch-t.ch+r.ch):E(r.line+(e.line-t.line),e.ch)}function Kn(e,t,r){for(var n=[],i=E(e.first,0),o=i,l=0;l<t.length;l++){var s=t[l],a=Vn(s.from,i,o),u=Vn(Bn(s),i,o);if(i=s.to,o=u,"around"==r){var c=e.sel.ranges[l],f=P(c.head,c.anchor)<0;n[l]=new Ts(f?u:a,f?a:u)}else n[l]=new Ts(a,a)}return new ks(n,e.sel.primIndex)}function jn(e){e.doc.mode=Ue(e.options,e.doc.modeOption),Xn(e)}function Xn(e){e.doc.iter(function(e){e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null)}),e.doc.modeFrontier=e.doc.highlightFrontier=e.doc.first,Cn(e,100),e.state.modeGen++,e.curOp&&vn(e)}function Yn(e,t){return 0==t.from.ch&&0==t.to.ch&&""==g(t.text)&&(!e.cm||e.cm.options.wholeLineUpdateBefore)}function _n(e,t,r,n){function i(e){return r?r[e]:null}function o(e,r,i){it(e,r,i,n),bt(e,"change",e,t)}function l(e,t){for(var r=[],o=e;o<t;++o)r.push(new fs(u[o],i(o),n));return r}var s=t.from,a=t.to,u=t.text,c=M(e,s.line),f=M(e,a.line),h=g(u),d=i(u.length-1),p=a.line-s.line;if(t.full)e.insert(0,l(0,u.length)),e.remove(u.length,e.size-u.length);else if(Yn(e,t)){var v=l(0,u.length-1);o(f,f.text,d),p&&e.remove(s.line,p),v.length&&e.insert(s.line,v)}else if(c==f)if(1==u.length)o(c,c.text.slice(0,s.ch)+h+c.text.slice(a.ch),d);else{var m=l(1,u.length-1);m.push(new fs(h+c.text.slice(a.ch),d,n)),o(c,c.text.slice(0,s.ch)+u[0],i(0)),e.insert(s.line+1,m)}else if(1==u.length)o(c,c.text.slice(0,s.ch)+u[0]+f.text.slice(a.ch),i(0)),e.remove(s.line+1,p);else{o(c,c.text.slice(0,s.ch)+u[0],i(0)),o(f,h+f.text.slice(a.ch),d);var y=l(1,u.length-1);p>1&&e.remove(s.line+1,p-1),e.insert(s.line+1,y)}bt(e,"change",e,t)}function $n(e,t,r){function n(e,i,o){if(e.linked)for(var l=0;l<e.linked.length;++l){var s=e.linked[l];if(s.doc!=i){var a=o&&s.sharedHist;r&&!a||(t(s.doc,a),n(s.doc,e,a))}}}n(e,null,!0)}function qn(e,t){if(t.cm)throw new Error("This document is already in use.");e.doc=t,t.cm=e,Cr(e),jn(e),Zn(e),e.options.lineWrapping||we(e),e.options.mode=t.modeOption,vn(e)}function Zn(e){("rtl"==e.doc.direction?s:Fl)(e.display.lineDiv,"CodeMirror-rtl")}function Qn(e){hn(e,function(){Zn(e),vn(e)})}function Jn(e){this.done=[],this.undone=[],this.undoDepth=1/0,this.lastModTime=this.lastSelTime=0,this.lastOp=this.lastSelOp=null,this.lastOrigin=this.lastSelOrigin=null,this.generation=this.maxGeneration=e||1}function ei(e,t){var r={from:z(t.from),to:Bn(t),text:N(e,t.from,t.to)};return si(e,r,t.from.line,t.to.line+1),$n(e,function(e){return si(e,r,t.from.line,t.to.line+1)},!0),r}function ti(e){for(;e.length&&g(e).ranges;)e.pop()}function ri(e,t){return t?(ti(e.done),g(e.done)):e.done.length&&!g(e.done).ranges?g(e.done):e.done.length>1&&!e.done[e.done.length-2].ranges?(e.done.pop(),g(e.done)):void 0}function ni(e,t,r,n){var i=e.history;i.undone.length=0;var o,l,s=+new Date;if((i.lastOp==n||i.lastOrigin==t.origin&&t.origin&&("+"==t.origin.charAt(0)&&e.cm&&i.lastModTime>s-e.cm.options.historyEventDelay||"*"==t.origin.charAt(0)))&&(o=ri(i,i.lastOp==n)))l=g(o.changes),0==P(t.from,t.to)&&0==P(t.from,l.to)?l.to=Bn(t):o.changes.push(ei(e,t));else{var a=g(i.done);for(a&&a.ranges||li(e.sel,i.done),o={changes:[ei(e,t)],generation:i.generation},i.done.push(o);i.done.length>i.undoDepth;)i.done.shift(),i.done[0].ranges||i.done.shift()}i.done.push(r),i.generation=++i.maxGeneration,i.lastModTime=i.lastSelTime=s,i.lastOp=i.lastSelOp=n,i.lastOrigin=i.lastSelOrigin=t.origin,l||Te(e,"historyAdded")}function ii(e,t,r,n){var i=t.charAt(0);return"*"==i||"+"==i&&r.ranges.length==n.ranges.length&&r.somethingSelected()==n.somethingSelected()&&new Date-e.history.lastSelTime<=(e.cm?e.cm.options.historyEventDelay:500)}function oi(e,t,r,n){var i=e.history,o=n&&n.origin;r==i.lastSelOp||o&&i.lastSelOrigin==o&&(i.lastModTime==i.lastSelTime&&i.lastOrigin==o||ii(e,o,g(i.done),t))?i.done[i.done.length-1]=t:li(t,i.done),i.lastSelTime=+new Date,i.lastSelOrigin=o,i.lastSelOp=r,n&&!1!==n.clearRedo&&ti(i.undone)}function li(e,t){var r=g(t);r&&r.ranges&&r.equals(e)||t.push(e)}function si(e,t,r,n){var i=t["spans_"+e.id],o=0;e.iter(Math.max(e.first,r),Math.min(e.first+e.size,n),function(r){r.markedSpans&&((i||(i=t["spans_"+e.id]={}))[o]=r.markedSpans),++o})}function ai(e){if(!e)return null;for(var t,r=0;r<e.length;++r)e[r].marker.explicitlyCleared?t||(t=e.slice(0,r)):t&&t.push(e[r]);return t?t.length?t:null:e}function ui(e,t){var r=t["spans_"+e.id];if(!r)return null;for(var n=[],i=0;i<t.text.length;++i)n.push(ai(r[i]));return n}function ci(e,t){var r=ui(e,t),n=J(e,t);if(!r)return n;if(!n)return r;for(var i=0;i<r.length;++i){var o=r[i],l=n[i];if(o&&l)e:for(var s=0;s<l.length;++s){for(var a=l[s],u=0;u<o.length;++u)if(o[u].marker==a.marker)continue e;o.push(a)}else l&&(r[i]=l)}return r}function fi(e,t,r){for(var n=[],i=0;i<e.length;++i){var o=e[i];if(o.ranges)n.push(r?ks.prototype.deepCopy.call(o):o);else{var l=o.changes,s=[];n.push({changes:s});for(var a=0;a<l.length;++a){var u=l[a],c=void 0;if(s.push({from:u.from,to:u.to,text:u.text}),t)for(var f in u)(c=f.match(/^spans_(\d+)$/))&&h(t,Number(c[1]))>-1&&(g(s)[f]=u[f],delete u[f])}}}return n}function hi(e,t,r,n){if(n){var i=e.anchor;if(r){var o=P(t,i)<0;o!=P(r,i)<0?(i=t,t=r):o!=P(t,r)<0&&(t=r)}return new Ts(i,t)}return new Ts(r||t,t)}function di(e,t,r,n,i){null==i&&(i=e.cm&&(e.cm.display.shift||e.extend)),bi(e,new ks([hi(e.sel.primary(),t,r,i)],0),n)}function pi(e,t,r){for(var n=[],i=e.cm&&(e.cm.display.shift||e.extend),o=0;o<e.sel.ranges.length;o++)n[o]=hi(e.sel.ranges[o],t[o],null,i);bi(e,zn(n,e.sel.primIndex),r)}function gi(e,t,r,n){var i=e.sel.ranges.slice(0);i[t]=r,bi(e,zn(i,e.sel.primIndex),n)}function vi(e,t,r,n){bi(e,Rn(t,r),n)}function mi(e,t,r){var n={ranges:t.ranges,update:function(t){var r=this;this.ranges=[];for(var n=0;n<t.length;n++)r.ranges[n]=new Ts(U(e,t[n].anchor),U(e,t[n].head))},origin:r&&r.origin};return Te(e,"beforeSelectionChange",e,n),e.cm&&Te(e.cm,"beforeSelectionChange",e.cm,n),n.ranges!=t.ranges?zn(n.ranges,n.ranges.length-1):t}function yi(e,t,r){var n=e.history.done,i=g(n);i&&i.ranges?(n[n.length-1]=t,wi(e,t,r)):bi(e,t,r)}function bi(e,t,r){wi(e,t,r),oi(e,e.sel,e.cm?e.cm.curOp.id:NaN,r)}function wi(e,t,r){(Oe(e,"beforeSelectionChange")||e.cm&&Oe(e.cm,"beforeSelectionChange"))&&(t=mi(e,t,r)),xi(e,Si(e,t,r&&r.bias||(P(t.primary().head,e.sel.primary().head)<0?-1:1),!0)),r&&!1===r.scroll||!e.cm||jr(e.cm)}function xi(e,t){t.equals(e.sel)||(e.sel=t,e.cm&&(e.cm.curOp.updateInput=e.cm.curOp.selectionChanged=!0,Ne(e.cm)),bt(e,"cursorActivity",e))}function Ci(e){xi(e,Si(e,e.sel,null,!1))}function Si(e,t,r,n){for(var i,o=0;o<t.ranges.length;o++){var l=t.ranges[o],s=t.ranges.length==e.sel.ranges.length&&e.sel.ranges[o],a=ki(e,l.anchor,s&&s.anchor,r,n),u=ki(e,l.head,s&&s.head,r,n);(i||a!=l.anchor||u!=l.head)&&(i||(i=t.ranges.slice(0,o)),i[o]=new Ts(a,u))}return i?zn(i,t.primIndex):t}function Li(e,t,r,n,i){var o=M(e,t.line);if(o.markedSpans)for(var l=0;l<o.markedSpans.length;++l){var s=o.markedSpans[l],a=s.marker;if((null==s.from||(a.inclusiveLeft?s.from<=t.ch:s.from<t.ch))&&(null==s.to||(a.inclusiveRight?s.to>=t.ch:s.to>t.ch))){if(i&&(Te(a,"beforeCursorEnter"),a.explicitlyCleared)){if(o.markedSpans){--l;continue}break}if(!a.atomic)continue;if(r){var u=a.find(n<0?1:-1),c=void 0;if((n<0?a.inclusiveRight:a.inclusiveLeft)&&(u=Ti(e,u,-n,u&&u.line==t.line?o:null)),u&&u.line==t.line&&(c=P(u,r))&&(n<0?c<0:c>0))return Li(e,u,t,n,i)}var f=a.find(n<0?-1:1);return(n<0?a.inclusiveLeft:a.inclusiveRight)&&(f=Ti(e,f,n,f.line==t.line?o:null)),f?Li(e,f,t,n,i):null}}return t}function ki(e,t,r,n,i){var o=n||1,l=Li(e,t,r,o,i)||!i&&Li(e,t,r,o,!0)||Li(e,t,r,-o,i)||!i&&Li(e,t,r,-o,!0);return l||(e.cantEdit=!0,E(e.first,0))}function Ti(e,t,r,n){return r<0&&0==t.ch?t.line>e.first?U(e,E(t.line-1)):null:r>0&&t.ch==(n||M(e,t.line)).text.length?t.line<e.first+e.size-1?E(t.line+1,0):null:new E(t.line,t.ch+r)}function Mi(e){e.setSelection(E(e.firstLine(),0),E(e.lastLine()),Gl)}function Ni(e,t,r){var n={canceled:!1,from:t.from,to:t.to,text:t.text,origin:t.origin,cancel:function(){return n.canceled=!0}};return r&&(n.update=function(t,r,i,o){t&&(n.from=U(e,t)),r&&(n.to=U(e,r)),i&&(n.text=i),void 0!==o&&(n.origin=o)}),Te(e,"beforeChange",e,n),e.cm&&Te(e.cm,"beforeChange",e.cm,n),n.canceled?null:{from:n.from,to:n.to,text:n.text,origin:n.origin}}function Oi(e,t,r){if(e.cm){if(!e.cm.curOp)return dn(e.cm,Oi)(e,t,r);if(e.cm.state.suppressEdits)return}if(!(Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"))||(t=Ni(e,t,!0))){var n=Yl&&!r&&te(e,t.from,t.to);if(n)for(var i=n.length-1;i>=0;--i)Ai(e,{from:n[i].from,to:n[i].to,text:i?[""]:t.text,origin:t.origin});else Ai(e,t)}}function Ai(e,t){if(1!=t.text.length||""!=t.text[0]||0!=P(t.from,t.to)){var r=Un(e,t);ni(e,t,r,e.cm?e.cm.curOp.id:NaN),Hi(e,t,r,J(e,t));var n=[];$n(e,function(e,r){r||-1!=h(n,e.history)||(zi(e.history,t),n.push(e.history)),Hi(e,t,null,J(e,t))})}}function Wi(e,t,r){if(!e.cm||!e.cm.state.suppressEdits||r){for(var n,i=e.history,o=e.sel,l="undo"==t?i.done:i.undone,s="undo"==t?i.undone:i.done,a=0;a<l.length&&(n=l[a],r?!n.ranges||n.equals(e.sel):n.ranges);a++);if(a!=l.length){for(i.lastOrigin=i.lastSelOrigin=null;(n=l.pop()).ranges;){if(li(n,s),r&&!n.equals(e.sel))return void bi(e,n,{clearRedo:!1});o=n}var u=[];li(o,s),s.push({changes:u,generation:i.generation}),i.generation=n.generation||++i.maxGeneration;for(var c=Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"),f=n.changes.length-1;f>=0;--f){var d=function(r){var i=n.changes[r];if(i.origin=t,c&&!Ni(e,i,!1))return l.length=0,{};u.push(ei(e,i));var o=r?Un(e,i):g(l);Hi(e,i,o,ci(e,i)),!r&&e.cm&&e.cm.scrollIntoView({from:i.from,to:Bn(i)});var s=[];$n(e,function(e,t){t||-1!=h(s,e.history)||(zi(e.history,i),s.push(e.history)),Hi(e,i,null,ci(e,i))})}(f);if(d)return d.v}}}}function Di(e,t){if(0!=t&&(e.first+=t,e.sel=new ks(v(e.sel.ranges,function(e){return new Ts(E(e.anchor.line+t,e.anchor.ch),E(e.head.line+t,e.head.ch))}),e.sel.primIndex),e.cm)){vn(e.cm,e.first,e.first-t,t);for(var r=e.cm.display,n=r.viewFrom;n<r.viewTo;n++)mn(e.cm,n,"gutter")}}function Hi(e,t,r,n){if(e.cm&&!e.cm.curOp)return dn(e.cm,Hi)(e,t,r,n);if(t.to.line<e.first)Di(e,t.text.length-1-(t.to.line-t.from.line));else if(!(t.from.line>e.lastLine())){if(t.from.line<e.first){var i=t.text.length-1-(e.first-t.from.line);Di(e,i),t={from:E(e.first,0),to:E(t.to.line+i,t.to.ch),text:[g(t.text)],origin:t.origin}}var o=e.lastLine();t.to.line>o&&(t={from:t.from,to:E(o,M(e,o).text.length),text:[t.text[0]],origin:t.origin}),t.removed=N(e,t.from,t.to),r||(r=Un(e,t)),e.cm?Fi(e.cm,t,n):_n(e,t,n),wi(e,r,Gl)}}function Fi(e,t,r){var n=e.doc,i=e.display,o=t.from,l=t.to,s=!1,a=o.line;e.options.lineWrapping||(a=W(fe(M(n,o.line))),n.iter(a,l.line+1,function(e){if(e==i.maxLine)return s=!0,!0})),n.sel.contains(t.from,t.to)>-1&&Ne(e),_n(n,t,r,xr(e)),e.options.lineWrapping||(n.iter(a,o.line+t.text.length,function(e){var t=be(e);t>i.maxLineLength&&(i.maxLine=e,i.maxLineLength=t,i.maxLineChanged=!0,s=!1)}),s&&(e.curOp.updateMaxLine=!0)),nt(n,o.line),Cn(e,400);var u=t.text.length-(l.line-o.line)-1;t.full?vn(e):o.line!=l.line||1!=t.text.length||Yn(e.doc,t)?vn(e,o.line,l.line+1,u):mn(e,o.line,"text");var c=Oe(e,"changes"),f=Oe(e,"change");if(f||c){var h={from:o,to:l,text:t.text,removed:t.removed,origin:t.origin};f&&bt(e,"change",e,h),c&&(e.curOp.changeObjs||(e.curOp.changeObjs=[])).push(h)}e.display.selForContextMenu=null}function Ei(e,t,r,n,i){if(n||(n=r),P(n,r)<0){var o;r=(o=[n,r])[0],n=o[1]}"string"==typeof t&&(t=e.splitLines(t)),Oi(e,{from:r,to:n,text:t,origin:i})}function Pi(e,t,r,n){r<e.line?e.line+=n:t<e.line&&(e.line=t,e.ch=0)}function Ii(e,t,r,n){for(var i=0;i<e.length;++i){var o=e[i],l=!0;if(o.ranges){o.copied||((o=e[i]=o.deepCopy()).copied=!0);for(var s=0;s<o.ranges.length;s++)Pi(o.ranges[s].anchor,t,r,n),Pi(o.ranges[s].head,t,r,n)}else{for(var a=0;a<o.changes.length;++a){var u=o.changes[a];if(r<u.from.line)u.from=E(u.from.line+n,u.from.ch),u.to=E(u.to.line+n,u.to.ch);else if(t<=u.to.line){l=!1;break}}l||(e.splice(0,i+1),i=0)}}}function zi(e,t){var r=t.from.line,n=t.to.line,i=t.text.length-(n-r)-1;Ii(e.done,r,n,i),Ii(e.undone,r,n,i)}function Ri(e,t,r,n){var i=t,o=t;return"number"==typeof t?o=M(e,G(e,t)):i=W(t),null==i?null:(n(o,i)&&e.cm&&mn(e.cm,i,r),o)}function Bi(e){var t=this;this.lines=e,this.parent=null;for(var r=0,n=0;n<e.length;++n)e[n].parent=t,r+=e[n].height;this.height=r}function Gi(e){var t=this;this.children=e;for(var r=0,n=0,i=0;i<e.length;++i){var o=e[i];r+=o.chunkSize(),n+=o.height,o.parent=t}this.size=r,this.height=n,this.parent=null}function Ui(e,t,r){ye(t)<(e.curOp&&e.curOp.scrollTop||e.doc.scrollTop)&&Kr(e,r)}function Vi(e,t,r,n){var i=new Ms(e,r,n),o=e.cm;return o&&i.noHScroll&&(o.display.alignWidgets=!0),Ri(e,t,"widget",function(t){var r=t.widgets||(t.widgets=[]);if(null==i.insertAt?r.push(i):r.splice(Math.min(r.length-1,Math.max(0,i.insertAt)),0,i),i.line=t,o&&!ve(e,t)){var n=ye(t)<e.scrollTop;A(t,t.height+Ht(i)),n&&Kr(o,i.height),o.curOp.forceUpdate=!0}return!0}),bt(o,"lineWidgetAdded",o,i,"number"==typeof t?t:W(t)),i}function Ki(e,t,r,n,o){if(n&&n.shared)return ji(e,t,r,n,o);if(e.cm&&!e.cm.curOp)return dn(e.cm,Ki)(e,t,r,n,o);var l=new Os(e,o),s=P(t,r);if(n&&c(n,l,!1),s>0||0==s&&!1!==l.clearWhenEmpty)return l;if(l.replacedWith&&(l.collapsed=!0,l.widgetNode=i("span",[l.replacedWith],"CodeMirror-widget"),n.handleMouseEvents||l.widgetNode.setAttribute("cm-ignore-events","true"),n.insertLeft&&(l.widgetNode.insertLeft=!0)),l.collapsed){if(ce(e,t.line,t,r,l)||t.line!=r.line&&ce(e,r.line,t,r,l))throw new Error("Inserting collapsed marker partially overlapping an existing one");X()}l.addToHistory&&ni(e,{from:t,to:r,origin:"markText"},e.sel,NaN);var a,u=t.line,f=e.cm;if(e.iter(u,r.line+1,function(e){f&&l.collapsed&&!f.options.lineWrapping&&fe(e)==f.display.maxLine&&(a=!0),l.collapsed&&u!=t.line&&A(e,0),q(e,new Y(l,u==t.line?t.ch:null,u==r.line?r.ch:null)),++u}),l.collapsed&&e.iter(t.line,r.line+1,function(t){ve(e,t)&&A(t,0)}),l.clearOnEnter&&Ql(l,"beforeCursorEnter",function(){return l.clear()}),l.readOnly&&(j(),(e.history.done.length||e.history.undone.length)&&e.clearHistory()),l.collapsed&&(l.id=++Ns,l.atomic=!0),f){if(a&&(f.curOp.updateMaxLine=!0),l.collapsed)vn(f,t.line,r.line+1);else if(l.className||l.title||l.startStyle||l.endStyle||l.css)for(var h=t.line;h<=r.line;h++)mn(f,h,"text");l.atomic&&Ci(f.doc),bt(f,"markerAdded",f,l)}return l}function ji(e,t,r,n,i){(n=c(n)).shared=!1;var o=[Ki(e,t,r,n,i)],l=o[0],s=n.widgetNode;return $n(e,function(e){s&&(n.widgetNode=s.cloneNode(!0)),o.push(Ki(e,U(e,t),U(e,r),n,i));for(var a=0;a<e.linked.length;++a)if(e.linked[a].isParent)return;l=g(o)}),new As(o,l)}function Xi(e){return e.findMarks(E(e.first,0),e.clipPos(E(e.lastLine())),function(e){return e.parent})}function Yi(e,t){for(var r=0;r<t.length;r++){var n=t[r],i=n.find(),o=e.clipPos(i.from),l=e.clipPos(i.to);if(P(o,l)){var s=Ki(e,o,l,n.primary,n.primary.type);n.markers.push(s),s.parent=n}}}function _i(e){for(var t=0;t<e.length;t++)!function(t){var r=e[t],n=[r.primary.doc];$n(r.primary.doc,function(e){return n.push(e)});for(var i=0;i<r.markers.length;i++){var o=r.markers[i];-1==h(n,o.doc)&&(o.parent=null,r.markers.splice(i--,1))}}(t)}function $i(e){var t=this;if(Qi(t),!Me(t,e)&&!Ft(t.display,e)){We(e),gl&&(Hs=+new Date);var r=Sr(t,e,!0),n=e.dataTransfer.files;if(r&&!t.isReadOnly())if(n&&n.length&&window.FileReader&&window.File)for(var i=n.length,o=Array(i),l=0,s=0;s<i;++s)!function(e,n){if(!t.options.allowDropFileTypes||-1!=h(t.options.allowDropFileTypes,e.type)){var s=new FileReader;s.onload=dn(t,function(){var e=s.result;if(/[\x00-\x08\x0e-\x1f]{2}/.test(e)&&(e=""),o[n]=e,++l==i){var a={from:r=U(t.doc,r),to:r,text:t.doc.splitLines(o.join(t.doc.lineSeparator())),origin:"paste"};Oi(t.doc,a),yi(t.doc,Rn(r,Bn(a)))}}),s.readAsText(e)}}(n[s],s);else{if(t.state.draggingText&&t.doc.sel.contains(r)>-1)return t.state.draggingText(e),void setTimeout(function(){return t.display.input.focus()},20);try{var a=e.dataTransfer.getData("Text");if(a){var u;if(t.state.draggingText&&!t.state.draggingText.copy&&(u=t.listSelections()),wi(t.doc,Rn(r,r)),u)for(var c=0;c<u.length;++c)Ei(t.doc,"",u[c].anchor,u[c].head,"drag");t.replaceSelection(a,"around","paste"),t.display.input.focus()}}catch(e){}}}}function qi(e,t){if(gl&&(!e.state.draggingText||+new Date-Hs<100))Fe(t);else if(!Me(e,t)&&!Ft(e.display,t)&&(t.dataTransfer.setData("Text",e.getSelection()),t.dataTransfer.effectAllowed="copyMove",t.dataTransfer.setDragImage&&!xl)){var r=n("img",null,null,"position: fixed; left: 0; top: 0;");r.src="data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==",wl&&(r.width=r.height=1,e.display.wrapper.appendChild(r),r._top=r.offsetTop),t.dataTransfer.setDragImage(r,0,0),wl&&r.parentNode.removeChild(r)}}function Zi(e,t){var i=Sr(e,t);if(i){var o=document.createDocumentFragment();Mr(e,i,o),e.display.dragCursor||(e.display.dragCursor=n("div",null,"CodeMirror-cursors CodeMirror-dragcursors"),e.display.lineSpace.insertBefore(e.display.dragCursor,e.display.cursorDiv)),r(e.display.dragCursor,o)}}function Qi(e){e.display.dragCursor&&(e.display.lineSpace.removeChild(e.display.dragCursor),e.display.dragCursor=null)}function Ji(e){if(document.getElementsByClassName)for(var t=document.getElementsByClassName("CodeMirror"),r=0;r<t.length;r++){var n=t[r].CodeMirror;n&&e(n)}}function eo(){Fs||(to(),Fs=!0)}function to(){var e;Ql(window,"resize",function(){null==e&&(e=setTimeout(function(){e=null,Ji(ro)},100))}),Ql(window,"blur",function(){return Ji(Fr)})}function ro(e){var t=e.display;t.lastWrapHeight==t.wrapper.clientHeight&&t.lastWrapWidth==t.wrapper.clientWidth||(t.cachedCharWidth=t.cachedTextHeight=t.cachedPaddingH=null,t.scrollbarsClipped=!1,e.setSize())}function no(e){var t=e.split(/-(?!$)/);e=t[t.length-1];for(var r,n,i,o,l=0;l<t.length-1;l++){var s=t[l];if(/^(cmd|meta|m)$/i.test(s))o=!0;else if(/^a(lt)?$/i.test(s))r=!0;else if(/^(c|ctrl|control)$/i.test(s))n=!0;else{if(!/^s(hift)?$/i.test(s))throw new Error("Unrecognized modifier name: "+s);i=!0}}return r&&(e="Alt-"+e),n&&(e="Ctrl-"+e),o&&(e="Cmd-"+e),i&&(e="Shift-"+e),e}function io(e){var t={};for(var r in e)if(e.hasOwnProperty(r)){var n=e[r];if(/^(name|fallthrough|(de|at)tach)$/.test(r))continue;if("..."==n){delete e[r];continue}for(var i=v(r.split(" "),no),o=0;o<i.length;o++){var l=void 0,s=void 0;o==i.length-1?(s=i.join(" "),l=n):(s=i.slice(0,o+1).join(" "),l="...");var a=t[s];if(a){if(a!=l)throw new Error("Inconsistent bindings for "+s)}else t[s]=l}delete e[r]}for(var u in t)e[u]=t[u];return e}function oo(e,t,r,n){var i=(t=uo(t)).call?t.call(e,n):t[e];if(!1===i)return"nothing";if("..."===i)return"multi";if(null!=i&&r(i))return"handled";if(t.fallthrough){if("[object Array]"!=Object.prototype.toString.call(t.fallthrough))return oo(e,t.fallthrough,r,n);for(var o=0;o<t.fallthrough.length;o++){var l=oo(e,t.fallthrough[o],r,n);if(l)return l}}}function lo(e){var t="string"==typeof e?e:Es[e.keyCode];return"Ctrl"==t||"Alt"==t||"Shift"==t||"Mod"==t}function so(e,t,r){var n=e;return t.altKey&&"Alt"!=n&&(e="Alt-"+e),(Dl?t.metaKey:t.ctrlKey)&&"Ctrl"!=n&&(e="Ctrl-"+e),(Dl?t.ctrlKey:t.metaKey)&&"Cmd"!=n&&(e="Cmd-"+e),!r&&t.shiftKey&&"Shift"!=n&&(e="Shift-"+e),e}function ao(e,t){if(wl&&34==e.keyCode&&e.char)return!1;var r=Es[e.keyCode];return null!=r&&!e.altGraphKey&&so(r,e,t)}function uo(e){return"string"==typeof e?Rs[e]:e}function co(e,t){for(var r=e.doc.sel.ranges,n=[],i=0;i<r.length;i++){for(var o=t(r[i]);n.length&&P(o.from,g(n).to)<=0;){var l=n.pop();if(P(l.from,o.from)<0){o.from=l.from;break}}n.push(o)}hn(e,function(){for(var t=n.length-1;t>=0;t--)Ei(e.doc,"",n[t].from,n[t].to,"+delete");jr(e)})}function fo(e,t,r){var n=L(e.text,t+r,r);return n<0||n>e.text.length?null:n}function ho(e,t,r){var n=fo(e,t.ch,r);return null==n?null:new E(t.line,n,r<0?"after":"before")}function po(e,t,r,n,i){if(e){var o=Se(r,t.doc.direction);if(o){var l,s=i<0?g(o):o[0],a=i<0==(1==s.level)?"after":"before";if(s.level>0){var u=Xt(t,r);l=i<0?r.text.length-1:0;var c=Yt(t,u,l).top;l=k(function(e){return Yt(t,u,e).top==c},i<0==(1==s.level)?s.from:s.to-1,l),"before"==a&&(l=fo(r,l,1))}else l=i<0?s.to:s.from;return new E(n,l,a)}}return new E(n,i<0?r.text.length:0,i<0?"before":"after")}function go(e,t,r,n){var i=Se(t,e.doc.direction);if(!i)return ho(t,r,n);r.ch>=t.text.length?(r.ch=t.text.length,r.sticky="before"):r.ch<=0&&(r.ch=0,r.sticky="after");var o=Ce(i,r.ch,r.sticky),l=i[o];if("ltr"==e.doc.direction&&l.level%2==0&&(n>0?l.to>r.ch:l.from<r.ch))return ho(t,r,n);var s,a=function(e,r){return fo(t,e instanceof E?e.ch:e,r)},u=function(r){return e.options.lineWrapping?(s=s||Xt(e,t),hr(e,t,s,r)):{begin:0,end:t.text.length}},c=u("before"==r.sticky?a(r,-1):r.ch);if("rtl"==e.doc.direction||1==l.level){var f=1==l.level==n<0,h=a(r,f?1:-1);if(null!=h&&(f?h<=l.to&&h<=c.end:h>=l.from&&h>=c.begin)){var d=f?"before":"after";return new E(r.line,h,d)}}var p=function(e,t,n){for(var o=function(e,t){return t?new E(r.line,a(e,1),"before"):new E(r.line,e,"after")};e>=0&&e<i.length;e+=t){var l=i[e],s=t>0==(1!=l.level),u=s?n.begin:a(n.end,-1);if(l.from<=u&&u<l.to)return o(u,s);if(u=s?l.from:a(l.to,-1),n.begin<=u&&u<n.end)return o(u,s)}},g=p(o+n,n,c);if(g)return g;var v=n>0?c.end:a(c.begin,-1);return null==v||n>0&&v==t.text.length||!(g=p(n>0?0:i.length-1,n,u(v)))?null:g}function vo(e,t){var r=M(e.doc,t),n=fe(r);return n!=r&&(t=W(n)),po(!0,e,n,t,1)}function mo(e,t){var r=M(e.doc,t),n=he(r);return n!=r&&(t=W(n)),po(!0,e,r,t,-1)}function yo(e,t){var r=vo(e,t.line),n=M(e.doc,r.line),i=Se(n,e.doc.direction);if(!i||0==i[0].level){var o=Math.max(0,n.text.search(/\S/)),l=t.line==r.line&&t.ch<=o&&t.ch;return E(r.line,l?0:o,r.sticky)}return r}function bo(e,t,r){if("string"==typeof t&&!(t=Bs[t]))return!1;e.display.input.ensurePolled();var n=e.display.shift,i=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),r&&(e.display.shift=!1),i=t(e)!=Bl}finally{e.display.shift=n,e.state.suppressEdits=!1}return i}function wo(e,t,r){for(var n=0;n<e.state.keyMaps.length;n++){var i=oo(t,e.state.keyMaps[n],r,e);if(i)return i}return e.options.extraKeys&&oo(t,e.options.extraKeys,r,e)||oo(t,e.options.keyMap,r,e)}function xo(e,t,r,n){var i=e.state.keySeq;if(i){if(lo(t))return"handled";Gs.set(50,function(){e.state.keySeq==i&&(e.state.keySeq=null,e.display.input.reset())}),t=i+" "+t}var o=wo(e,t,n);return"multi"==o&&(e.state.keySeq=t),"handled"==o&&bt(e,"keyHandled",e,t,r),"handled"!=o&&"multi"!=o||(We(r),Ar(e)),i&&!o&&/\'$/.test(t)?(We(r),!0):!!o}function Co(e,t){var r=ao(t,!0);return!!r&&(t.shiftKey&&!e.state.keySeq?xo(e,"Shift-"+r,t,function(t){return bo(e,t,!0)})||xo(e,r,t,function(t){if("string"==typeof t?/^go[A-Z]/.test(t):t.motion)return bo(e,t)}):xo(e,r,t,function(t){return bo(e,t)}))}function So(e,t,r){return xo(e,"'"+r+"'",t,function(t){return bo(e,t,!0)})}function Lo(e){var t=this;if(t.curOp.focus=l(),!Me(t,e)){gl&&vl<11&&27==e.keyCode&&(e.returnValue=!1);var r=e.keyCode;t.display.shift=16==r||e.shiftKey;var n=Co(t,e);wl&&(Us=n?r:null,!n&&88==r&&!rs&&(Ml?e.metaKey:e.ctrlKey)&&t.replaceSelection("",null,"cut")),18!=r||/\bCodeMirror-crosshair\b/.test(t.display.lineDiv.className)||ko(t)}}function ko(e){function t(e){18!=e.keyCode&&e.altKey||(Fl(r,"CodeMirror-crosshair"),ke(document,"keyup",t),ke(document,"mouseover",t))}var r=e.display.lineDiv;s(r,"CodeMirror-crosshair"),Ql(document,"keyup",t),Ql(document,"mouseover",t)}function To(e){16==e.keyCode&&(this.doc.sel.shift=!1),Me(this,e)}function Mo(e){var t=this;if(!(Ft(t.display,e)||Me(t,e)||e.ctrlKey&&!e.altKey||Ml&&e.metaKey)){var r=e.keyCode,n=e.charCode;if(wl&&r==Us)return Us=null,void We(e);if(!wl||e.which&&!(e.which<10)||!Co(t,e)){var i=String.fromCharCode(null==n?r:n);"\b"!=i&&(So(t,e,i)||t.display.input.onKeyPress(e))}}}function No(e,t){var r=+new Date;return js&&js.compare(r,e,t)?(Ks=js=null,"triple"):Ks&&Ks.compare(r,e,t)?(js=new Vs(r,e,t),Ks=null,"double"):(Ks=new Vs(r,e,t),js=null,"single")}function Oo(e){var t=this,r=t.display;if(!(Me(t,e)||r.activeTouch&&r.input.supportsTouch()))if(r.input.ensurePolled(),r.shift=e.shiftKey,Ft(r,e))ml||(r.scroller.draggable=!1,setTimeout(function(){return r.scroller.draggable=!0},100));else if(!zo(t,e)){var n=Sr(t,e),i=Pe(e),o=n?No(n,i):"single";window.focus(),1==i&&t.state.selectingText&&t.state.selectingText(e),n&&Ao(t,i,n,o,e)||(1==i?n?Do(t,n,o,e):Ee(e)==r.scroller&&We(e):2==i?(n&&di(t.doc,n),setTimeout(function(){return r.input.focus()},20)):3==i&&(Hl?Ro(t,e):Dr(t)))}}function Ao(e,t,r,n,i){var o="Click";return"double"==n?o="Double"+o:"triple"==n&&(o="Triple"+o),o=(1==t?"Left":2==t?"Middle":"Right")+o,xo(e,so(o,i),i,function(t){if("string"==typeof t&&(t=Bs[t]),!t)return!1;var n=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),n=t(e,r)!=Bl}finally{e.state.suppressEdits=!1}return n})}function Wo(e,t,r){var n=e.getOption("configureMouse"),i=n?n(e,t,r):{};if(null==i.unit){var o=Nl?r.shiftKey&&r.metaKey:r.altKey;i.unit=o?"rectangle":"single"==t?"char":"double"==t?"word":"line"}return(null==i.extend||e.doc.extend)&&(i.extend=e.doc.extend||r.shiftKey),null==i.addNew&&(i.addNew=Ml?r.metaKey:r.ctrlKey),null==i.moveOnDrag&&(i.moveOnDrag=!(Ml?r.altKey:r.ctrlKey)),i}function Do(e,t,r,n){gl?setTimeout(u(Wr,e),0):e.curOp.focus=l();var i,o=Wo(e,r,n),s=e.doc.sel;e.options.dragDrop&&Jl&&!e.isReadOnly()&&"single"==r&&(i=s.contains(t))>-1&&(P((i=s.ranges[i]).from(),t)<0||t.xRel>0)&&(P(i.to(),t)>0||t.xRel<0)?Ho(e,n,t,o):Eo(e,n,t,o)}function Ho(e,t,r,n){var i=e.display,o=!1,l=dn(e,function(t){ml&&(i.scroller.draggable=!1),e.state.draggingText=!1,ke(document,"mouseup",l),ke(document,"mousemove",s),ke(i.scroller,"dragstart",a),ke(i.scroller,"drop",l),o||(We(t),n.addNew||di(e.doc,r,null,null,n.extend),ml||gl&&9==vl?setTimeout(function(){document.body.focus(),i.input.focus()},20):i.input.focus())}),s=function(e){o=o||Math.abs(t.clientX-e.clientX)+Math.abs(t.clientY-e.clientY)>=10},a=function(){return o=!0};ml&&(i.scroller.draggable=!0),e.state.draggingText=l,l.copy=!n.moveOnDrag,i.scroller.dragDrop&&i.scroller.dragDrop(),Ql(document,"mouseup",l),Ql(document,"mousemove",s),Ql(i.scroller,"dragstart",a),Ql(i.scroller,"drop",l),Dr(e),setTimeout(function(){return i.input.focus()},20)}function Fo(e,t,r){if("char"==r)return new Ts(t,t);if("word"==r)return e.findWordAt(t);if("line"==r)return new Ts(E(t.line,0),U(e.doc,E(t.line+1,0)));var n=r(e,t);return new Ts(n.from,n.to)}function Eo(e,t,r,n){function i(t){if(0!=P(m,t))if(m=t,"rectangle"==n.unit){for(var i=[],o=e.options.tabSize,l=f(M(u,r.line).text,r.ch,o),s=f(M(u,t.line).text,t.ch,o),a=Math.min(l,s),g=Math.max(l,s),v=Math.min(r.line,t.line),y=Math.min(e.lastLine(),Math.max(r.line,t.line));v<=y;v++){var b=M(u,v).text,w=d(b,a,o);a==g?i.push(new Ts(E(v,w),E(v,w))):b.length>w&&i.push(new Ts(E(v,w),E(v,d(b,g,o))))}i.length||i.push(new Ts(r,r)),bi(u,zn(p.ranges.slice(0,h).concat(i),h),{origin:"*mouse",scroll:!1}),e.scrollIntoView(t)}else{var x,C=c,S=Fo(e,t,n.unit),L=C.anchor;P(S.anchor,L)>0?(x=S.head,L=B(C.from(),S.anchor)):(x=S.anchor,L=R(C.to(),S.head));var k=p.ranges.slice(0);k[h]=Po(e,new Ts(U(u,L),x)),bi(u,zn(k,h),Ul)}}function o(t){var r=++b,s=Sr(e,t,!0,"rectangle"==n.unit);if(s)if(0!=P(s,m)){e.curOp.focus=l(),i(s);var c=Ir(a,u);(s.line>=c.to||s.line<c.from)&&setTimeout(dn(e,function(){b==r&&o(t)}),150)}else{var f=t.clientY<y.top?-20:t.clientY>y.bottom?20:0;f&&setTimeout(dn(e,function(){b==r&&(a.scroller.scrollTop+=f,o(t))}),50)}}function s(t){e.state.selectingText=!1,b=1/0,We(t),a.input.focus(),ke(document,"mousemove",w),ke(document,"mouseup",x),u.history.lastSelOrigin=null}var a=e.display,u=e.doc;We(t);var c,h,p=u.sel,g=p.ranges;if(n.addNew&&!n.extend?(h=u.sel.contains(r),c=h>-1?g[h]:new Ts(r,r)):(c=u.sel.primary(),h=u.sel.primIndex),"rectangle"==n.unit)n.addNew||(c=new Ts(r,r)),r=Sr(e,t,!0,!0),h=-1;else{var v=Fo(e,r,n.unit);c=n.extend?hi(c,v.anchor,v.head,n.extend):v}n.addNew?-1==h?(h=g.length,bi(u,zn(g.concat([c]),h),{scroll:!1,origin:"*mouse"})):g.length>1&&g[h].empty()&&"char"==n.unit&&!n.extend?(bi(u,zn(g.slice(0,h).concat(g.slice(h+1)),0),{scroll:!1,origin:"*mouse"}),p=u.sel):gi(u,h,c,Ul):(h=0,bi(u,new ks([c],0),Ul),p=u.sel);var m=r,y=a.wrapper.getBoundingClientRect(),b=0,w=dn(e,function(e){Pe(e)?o(e):s(e)}),x=dn(e,s);e.state.selectingText=x,Ql(document,"mousemove",w),Ql(document,"mouseup",x)}function Po(e,t){var r=t.anchor,n=t.head,i=M(e.doc,r.line);if(0==P(r,n)&&r.sticky==n.sticky)return t;var o=Se(i);if(!o)return t;var l=Ce(o,r.ch,r.sticky),s=o[l];if(s.from!=r.ch&&s.to!=r.ch)return t;var a=l+(s.from==r.ch==(1!=s.level)?0:1);if(0==a||a==o.length)return t;var u;if(n.line!=r.line)u=(n.line-r.line)*("ltr"==e.doc.direction?1:-1)>0;else{var c=Ce(o,n.ch,n.sticky),f=c-l||(n.ch-r.ch)*(1==s.level?-1:1);u=c==a-1||c==a?f<0:f>0}var h=o[a+(u?-1:0)],d=u==(1==h.level),p=d?h.from:h.to,g=d?"after":"before";return r.ch==p&&r.sticky==g?t:new Ts(new E(r.line,p,g),n)}function Io(e,t,r,n){var i,o;if(t.touches)i=t.touches[0].clientX,o=t.touches[0].clientY;else try{i=t.clientX,o=t.clientY}catch(t){return!1}if(i>=Math.floor(e.display.gutters.getBoundingClientRect().right))return!1;n&&We(t);var l=e.display,s=l.lineDiv.getBoundingClientRect();if(o>s.bottom||!Oe(e,r))return He(t);o-=s.top-l.viewOffset;for(var a=0;a<e.options.gutters.length;++a){var u=l.gutters.childNodes[a];if(u&&u.getBoundingClientRect().right>=i)return Te(e,r,e,D(e.doc,o),e.options.gutters[a],t),He(t)}}function zo(e,t){return Io(e,t,"gutterClick",!0)}function Ro(e,t){Ft(e.display,t)||Bo(e,t)||Me(e,t,"contextmenu")||e.display.input.onContextMenu(t)}function Bo(e,t){return!!Oe(e,"gutterContextMenu")&&Io(e,t,"gutterContextMenu",!1)}function Go(e){e.display.wrapper.className=e.display.wrapper.className.replace(/\s*cm-s-\S+/g,"")+e.options.theme.replace(/(^|\s)\s*/g," cm-s-"),er(e)}function Uo(e){Hn(e),vn(e),zr(e)}function Vo(e,t,r){if(!t!=!(r&&r!=Xs)){var n=e.display.dragFunctions,i=t?Ql:ke;i(e.display.scroller,"dragstart",n.start),i(e.display.scroller,"dragenter",n.enter),i(e.display.scroller,"dragover",n.over),i(e.display.scroller,"dragleave",n.leave),i(e.display.scroller,"drop",n.drop)}}function Ko(e){e.options.lineWrapping?(s(e.display.wrapper,"CodeMirror-wrap"),e.display.sizer.style.minWidth="",e.display.sizerWidth=null):(Fl(e.display.wrapper,"CodeMirror-wrap"),we(e)),Cr(e),vn(e),er(e),setTimeout(function(){return en(e)},100)}function jo(e,t){var r=this;if(!(this instanceof jo))return new jo(e,t);this.options=t=t?c(t):{},c(Ys,t,!1),Fn(t);var n=t.value;"string"==typeof n&&(n=new Ds(n,t.mode,null,t.lineSeparator,t.direction)),this.doc=n;var i=new jo.inputStyles[t.inputStyle](this),o=this.display=new T(e,n,i);o.wrapper.CodeMirror=this,Hn(this),Go(this),t.lineWrapping&&(this.display.wrapper.className+=" CodeMirror-wrap"),rn(this),this.state={keyMaps:[],overlays:[],modeGen:0,overwrite:!1,delayingBlurEvent:!1,focused:!1,suppressEdits:!1,pasteIncoming:!1,cutIncoming:!1,selectingText:!1,draggingText:!1,highlight:new Pl,keySeq:null,specialChars:null},t.autofocus&&!Tl&&o.input.focus(),gl&&vl<11&&setTimeout(function(){return r.display.input.reset(!0)},20),Xo(this),eo(),nn(this),this.curOp.forceUpdate=!0,qn(this,n),t.autofocus&&!Tl||this.hasFocus()?setTimeout(u(Hr,this),20):Fr(this);for(var l in _s)_s.hasOwnProperty(l)&&_s[l](r,t[l],Xs);Rr(this),t.finishInit&&t.finishInit(this);for(var s=0;s<$s.length;++s)$s[s](r);on(this),ml&&t.lineWrapping&&"optimizelegibility"==getComputedStyle(o.lineDiv).textRendering&&(o.lineDiv.style.textRendering="auto")}function Xo(e){function t(){i.activeTouch&&(o=setTimeout(function(){return i.activeTouch=null},1e3),(l=i.activeTouch).end=+new Date)}function r(e){if(1!=e.touches.length)return!1;var t=e.touches[0];return t.radiusX<=1&&t.radiusY<=1}function n(e,t){if(null==t.left)return!0;var r=t.left-e.left,n=t.top-e.top;return r*r+n*n>400}var i=e.display;Ql(i.scroller,"mousedown",dn(e,Oo)),gl&&vl<11?Ql(i.scroller,"dblclick",dn(e,function(t){if(!Me(e,t)){var r=Sr(e,t);if(r&&!zo(e,t)&&!Ft(e.display,t)){We(t);var n=e.findWordAt(r);di(e.doc,n.anchor,n.head)}}})):Ql(i.scroller,"dblclick",function(t){return Me(e,t)||We(t)}),Hl||Ql(i.scroller,"contextmenu",function(t){return Ro(e,t)});var o,l={end:0};Ql(i.scroller,"touchstart",function(t){if(!Me(e,t)&&!r(t)&&!zo(e,t)){i.input.ensurePolled(),clearTimeout(o);var n=+new Date;i.activeTouch={start:n,moved:!1,prev:n-l.end<=300?l:null},1==t.touches.length&&(i.activeTouch.left=t.touches[0].pageX,i.activeTouch.top=t.touches[0].pageY)}}),Ql(i.scroller,"touchmove",function(){i.activeTouch&&(i.activeTouch.moved=!0)}),Ql(i.scroller,"touchend",function(r){var o=i.activeTouch;if(o&&!Ft(i,r)&&null!=o.left&&!o.moved&&new Date-o.start<300){var l,s=e.coordsChar(i.activeTouch,"page");l=!o.prev||n(o,o.prev)?new Ts(s,s):!o.prev.prev||n(o,o.prev.prev)?e.findWordAt(s):new Ts(E(s.line,0),U(e.doc,E(s.line+1,0))),e.setSelection(l.anchor,l.head),e.focus(),We(r)}t()}),Ql(i.scroller,"touchcancel",t),Ql(i.scroller,"scroll",function(){i.scroller.clientHeight&&(qr(e,i.scroller.scrollTop),Qr(e,i.scroller.scrollLeft,!0),Te(e,"scroll",e))}),Ql(i.scroller,"mousewheel",function(t){return In(e,t)}),Ql(i.scroller,"DOMMouseScroll",function(t){return In(e,t)}),Ql(i.wrapper,"scroll",function(){return i.wrapper.scrollTop=i.wrapper.scrollLeft=0}),i.dragFunctions={enter:function(t){Me(e,t)||Fe(t)},over:function(t){Me(e,t)||(Zi(e,t),Fe(t))},start:function(t){return qi(e,t)},drop:dn(e,$i),leave:function(t){Me(e,t)||Qi(e)}};var s=i.input.getField();Ql(s,"keyup",function(t){return To.call(e,t)}),Ql(s,"keydown",dn(e,Lo)),Ql(s,"keypress",dn(e,Mo)),Ql(s,"focus",function(t){return Hr(e,t)}),Ql(s,"blur",function(t){return Fr(e,t)})}function Yo(e,t,r,n){var i,o=e.doc;null==r&&(r="add"),"smart"==r&&(o.mode.indent?i=$e(e,t).state:r="prev");var l=e.options.tabSize,s=M(o,t),a=f(s.text,null,l);s.stateAfter&&(s.stateAfter=null);var u,c=s.text.match(/^\s*/)[0];if(n||/\S/.test(s.text)){if("smart"==r&&((u=o.mode.indent(i,s.text.slice(c.length),s.text))==Bl||u>150)){if(!n)return;r="prev"}}else u=0,r="not";"prev"==r?u=t>o.first?f(M(o,t-1).text,null,l):0:"add"==r?u=a+e.options.indentUnit:"subtract"==r?u=a-e.options.indentUnit:"number"==typeof r&&(u=a+r),u=Math.max(0,u);var h="",d=0;if(e.options.indentWithTabs)for(var g=Math.floor(u/l);g;--g)d+=l,h+="\t";if(d<u&&(h+=p(u-d)),h!=c)return Ei(o,h,E(t,0),E(t,c.length),"+input"),s.stateAfter=null,!0;for(var v=0;v<o.sel.ranges.length;v++){var m=o.sel.ranges[v];if(m.head.line==t&&m.head.ch<c.length){var y=E(t,c.length);gi(o,v,new Ts(y,y));break}}}function _o(e){qs=e}function $o(e,t,r,n,i){var o=e.doc;e.display.shift=!1,n||(n=o.sel);var l=e.state.pasteIncoming||"paste"==i,s=es(t),a=null;if(l&&n.ranges.length>1)if(qs&&qs.text.join("\n")==t){if(n.ranges.length%qs.text.length==0){a=[];for(var u=0;u<qs.text.length;u++)a.push(o.splitLines(qs.text[u]))}}else s.length==n.ranges.length&&e.options.pasteLinesPerSelection&&(a=v(s,function(e){return[e]}));for(var c,f=n.ranges.length-1;f>=0;f--){var h=n.ranges[f],d=h.from(),p=h.to();h.empty()&&(r&&r>0?d=E(d.line,d.ch-r):e.state.overwrite&&!l?p=E(p.line,Math.min(M(o,p.line).text.length,p.ch+g(s).length)):qs&&qs.lineWise&&qs.text.join("\n")==t&&(d=p=E(d.line,0))),c=e.curOp.updateInput;var m={from:d,to:p,text:a?a[f%a.length]:s,origin:i||(l?"paste":e.state.cutIncoming?"cut":"+input")};Oi(e.doc,m),bt(e,"inputRead",e,m)}t&&!l&&Zo(e,t),jr(e),e.curOp.updateInput=c,e.curOp.typing=!0,e.state.pasteIncoming=e.state.cutIncoming=!1}function qo(e,t){var r=e.clipboardData&&e.clipboardData.getData("Text");if(r)return e.preventDefault(),t.isReadOnly()||t.options.disableInput||hn(t,function(){return $o(t,r,0,null,"paste")}),!0}function Zo(e,t){if(e.options.electricChars&&e.options.smartIndent)for(var r=e.doc.sel,n=r.ranges.length-1;n>=0;n--){var i=r.ranges[n];if(!(i.head.ch>100||n&&r.ranges[n-1].head.line==i.head.line)){var o=e.getModeAt(i.head),l=!1;if(o.electricChars){for(var s=0;s<o.electricChars.length;s++)if(t.indexOf(o.electricChars.charAt(s))>-1){l=Yo(e,i.head.line,"smart");break}}else o.electricInput&&o.electricInput.test(M(e.doc,i.head.line).text.slice(0,i.head.ch))&&(l=Yo(e,i.head.line,"smart"));l&&bt(e,"electricInput",e,i.head.line)}}}function Qo(e){for(var t=[],r=[],n=0;n<e.doc.sel.ranges.length;n++){var i=e.doc.sel.ranges[n].head.line,o={anchor:E(i,0),head:E(i+1,0)};r.push(o),t.push(e.getRange(o.anchor,o.head))}return{text:t,ranges:r}}function Jo(e,t){e.setAttribute("autocorrect","off"),e.setAttribute("autocapitalize","off"),e.setAttribute("spellcheck",!!t)}function el(){var e=n("textarea",null,null,"position: absolute; bottom: -1em; padding: 0; width: 1px; height: 1em; outline: none"),t=n("div",[e],null,"overflow: hidden; position: relative; width: 3px; height: 0px;");return ml?e.style.width="1000px":e.setAttribute("wrap","off"),Ll&&(e.style.border="1px solid black"),Jo(e),t}function tl(e,t,r,n,i){function o(){var n=t.line+r;return!(n<e.first||n>=e.first+e.size)&&(t=new E(n,t.ch,t.sticky),u=M(e,n))}function l(n){var l;if(null==(l=i?go(e.cm,u,t,r):ho(u,t,r))){if(n||!o())return!1;t=po(i,e.cm,u,t.line,r)}else t=l;return!0}var s=t,a=r,u=M(e,t.line);if("char"==n)l();else if("column"==n)l(!0);else if("word"==n||"group"==n)for(var c=null,f="group"==n,h=e.cm&&e.cm.getHelper(t,"wordChars"),d=!0;!(r<0)||l(!d);d=!1){var p=u.text.charAt(t.ch)||"\n",g=x(p,h)?"w":f&&"\n"==p?"n":!f||/\s/.test(p)?null:"p";if(!f||d||g||(g="s"),c&&c!=g){r<0&&(r=1,l(),t.sticky="after");break}if(g&&(c=g),r>0&&!l(!d))break}var v=ki(e,t,s,a,!0);return I(s,v)&&(v.hitSide=!0),v}function rl(e,t,r,n){var i,o=e.doc,l=t.left;if("page"==n){var s=Math.min(e.display.wrapper.clientHeight,window.innerHeight||document.documentElement.clientHeight),a=Math.max(s-.5*mr(e.display),3);i=(r>0?t.bottom:t.top)+r*a}else"line"==n&&(i=r>0?t.bottom+3:t.top-3);for(var u;(u=cr(e,l,i)).outside;){if(r<0?i<=0:i>=o.height){u.hitSide=!0;break}i+=5*r}return u}function nl(e,t){var r=jt(e,t.line);if(!r||r.hidden)return null;var n=M(e.doc,t.line),i=Ut(r,n,t.line),o=Se(n,e.doc.direction),l="left";o&&(l=Ce(o,t.ch)%2?"right":"left");var s=_t(i.map,t.ch,l);return s.offset="right"==s.collapse?s.end:s.start,s}function il(e){for(var t=e;t;t=t.parentNode)if(/CodeMirror-gutter-wrapper/.test(t.className))return!0;return!1}function ol(e,t){return t&&(e.bad=!0),e}function ll(e,t,r,n,i){function o(e){return function(t){return t.id==e}}function l(){c&&(u+=f,c=!1)}function s(e){e&&(l(),u+=e)}function a(t){if(1==t.nodeType){var r=t.getAttribute("cm-text");if(null!=r)return void s(r||t.textContent.replace(/\u200b/g,""));var u,h=t.getAttribute("cm-marker");if(h){var d=e.findMarks(E(n,0),E(i+1,0),o(+h));return void(d.length&&(u=d[0].find(0))&&s(N(e.doc,u.from,u.to).join(f)))}if("false"==t.getAttribute("contenteditable"))return;var p=/^(pre|div|p)$/i.test(t.nodeName);p&&l();for(var g=0;g<t.childNodes.length;g++)a(t.childNodes[g]);p&&(c=!0)}else 3==t.nodeType&&s(t.nodeValue)}for(var u="",c=!1,f=e.doc.lineSeparator();a(t),t!=r;)t=t.nextSibling;return u}function sl(e,t,r){var n;if(t==e.display.lineDiv){if(!(n=e.display.lineDiv.childNodes[r]))return ol(e.clipPos(E(e.display.viewTo-1)),!0);t=null,r=0}else for(n=t;;n=n.parentNode){if(!n||n==e.display.lineDiv)return null;if(n.parentNode&&n.parentNode==e.display.lineDiv)break}for(var i=0;i<e.display.view.length;i++){var o=e.display.view[i];if(o.node==n)return al(o,t,r)}}function al(e,t,r){function n(t,r,n){for(var i=-1;i<(f?f.length:0);i++)for(var o=i<0?c.map:f[i],l=0;l<o.length;l+=3){var s=o[l+2];if(s==t||s==r){var a=W(i<0?e.line:e.rest[i]),u=o[l]+n;return(n<0||s!=t)&&(u=o[l+(n?1:0)]),E(a,u)}}}var i=e.text.firstChild,l=!1;if(!t||!o(i,t))return ol(E(W(e.line),0),!0);if(t==i&&(l=!0,t=i.childNodes[r],r=0,!t)){var s=e.rest?g(e.rest):e.line;return ol(E(W(s),s.text.length),l)}var a=3==t.nodeType?t:null,u=t;for(a||1!=t.childNodes.length||3!=t.firstChild.nodeType||(a=t.firstChild,r&&(r=a.nodeValue.length));u.parentNode!=i;)u=u.parentNode;var c=e.measure,f=c.maps,h=n(a,u,r);if(h)return ol(h,l);for(var d=u.nextSibling,p=a?a.nodeValue.length-r:0;d;d=d.nextSibling){if(h=n(d,d.firstChild,0))return ol(E(h.line,h.ch-p),l);p+=d.textContent.length}for(var v=u.previousSibling,m=r;v;v=v.previousSibling){if(h=n(v,v.firstChild,-1))return ol(E(h.line,h.ch+m),l);m+=v.textContent.length}}var ul=navigator.userAgent,cl=navigator.platform,fl=/gecko\/\d/i.test(ul),hl=/MSIE \d/.test(ul),dl=/Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(ul),pl=/Edge\/(\d+)/.exec(ul),gl=hl||dl||pl,vl=gl&&(hl?document.documentMode||6:+(pl||dl)[1]),ml=!pl&&/WebKit\//.test(ul),yl=ml&&/Qt\/\d+\.\d+/.test(ul),bl=!pl&&/Chrome\//.test(ul),wl=/Opera\//.test(ul),xl=/Apple Computer/.test(navigator.vendor),Cl=/Mac OS X 1\d\D([8-9]|\d\d)\D/.test(ul),Sl=/PhantomJS/.test(ul),Ll=!pl&&/AppleWebKit/.test(ul)&&/Mobile\/\w+/.test(ul),kl=/Android/.test(ul),Tl=Ll||kl||/webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(ul),Ml=Ll||/Mac/.test(cl),Nl=/\bCrOS\b/.test(ul),Ol=/win/i.test(cl),Al=wl&&ul.match(/Version\/(\d*\.\d*)/);Al&&(Al=Number(Al[1])),Al&&Al>=15&&(wl=!1,ml=!0);var Wl,Dl=Ml&&(yl||wl&&(null==Al||Al<12.11)),Hl=fl||gl&&vl>=9,Fl=function(t,r){var n=t.className,i=e(r).exec(n);if(i){var o=n.slice(i.index+i[0].length);t.className=n.slice(0,i.index)+(o?i[1]+o:"")}};Wl=document.createRange?function(e,t,r,n){var i=document.createRange();return i.setEnd(n||e,r),i.setStart(e,t),i}:function(e,t,r){var n=document.body.createTextRange();try{n.moveToElementText(e.parentNode)}catch(e){return n}return n.collapse(!0),n.moveEnd("character",r),n.moveStart("character",t),n};var El=function(e){e.select()};Ll?El=function(e){e.selectionStart=0,e.selectionEnd=e.value.length}:gl&&(El=function(e){try{e.select()}catch(e){}});var Pl=function(){this.id=null};Pl.prototype.set=function(e,t){clearTimeout(this.id),this.id=setTimeout(t,e)};var Il,zl,Rl=30,Bl={toString:function(){return"CodeMirror.Pass"}},Gl={scroll:!1},Ul={origin:"*mouse"},Vl={origin:"+move"},Kl=[""],jl=/[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/,Xl=/[\u0300-\u036f\u0483-\u0489\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u065e\u0670\u06d6-\u06dc\u06de-\u06e4\u06e7\u06e8\u06ea-\u06ed\u0711\u0730-\u074a\u07a6-\u07b0\u07eb-\u07f3\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0900-\u0902\u093c\u0941-\u0948\u094d\u0951-\u0955\u0962\u0963\u0981\u09bc\u09be\u09c1-\u09c4\u09cd\u09d7\u09e2\u09e3\u0a01\u0a02\u0a3c\u0a41\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a70\u0a71\u0a75\u0a81\u0a82\u0abc\u0ac1-\u0ac5\u0ac7\u0ac8\u0acd\u0ae2\u0ae3\u0b01\u0b3c\u0b3e\u0b3f\u0b41-\u0b44\u0b4d\u0b56\u0b57\u0b62\u0b63\u0b82\u0bbe\u0bc0\u0bcd\u0bd7\u0c3e-\u0c40\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0cbc\u0cbf\u0cc2\u0cc6\u0ccc\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0d3e\u0d41-\u0d44\u0d4d\u0d57\u0d62\u0d63\u0dca\u0dcf\u0dd2-\u0dd4\u0dd6\u0ddf\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0eb1\u0eb4-\u0eb9\u0ebb\u0ebc\u0ec8-\u0ecd\u0f18\u0f19\u0f35\u0f37\u0f39\u0f71-\u0f7e\u0f80-\u0f84\u0f86\u0f87\u0f90-\u0f97\u0f99-\u0fbc\u0fc6\u102d-\u1030\u1032-\u1037\u1039\u103a\u103d\u103e\u1058\u1059\u105e-\u1060\u1071-\u1074\u1082\u1085\u1086\u108d\u109d\u135f\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b7-\u17bd\u17c6\u17c9-\u17d3\u17dd\u180b-\u180d\u18a9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193b\u1a17\u1a18\u1a56\u1a58-\u1a5e\u1a60\u1a62\u1a65-\u1a6c\u1a73-\u1a7c\u1a7f\u1b00-\u1b03\u1b34\u1b36-\u1b3a\u1b3c\u1b42\u1b6b-\u1b73\u1b80\u1b81\u1ba2-\u1ba5\u1ba8\u1ba9\u1c2c-\u1c33\u1c36\u1c37\u1cd0-\u1cd2\u1cd4-\u1ce0\u1ce2-\u1ce8\u1ced\u1dc0-\u1de6\u1dfd-\u1dff\u200c\u200d\u20d0-\u20f0\u2cef-\u2cf1\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua66f-\ua672\ua67c\ua67d\ua6f0\ua6f1\ua802\ua806\ua80b\ua825\ua826\ua8c4\ua8e0-\ua8f1\ua926-\ua92d\ua947-\ua951\ua980-\ua982\ua9b3\ua9b6-\ua9b9\ua9bc\uaa29-\uaa2e\uaa31\uaa32\uaa35\uaa36\uaa43\uaa4c\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uabe5\uabe8\uabed\udc00-\udfff\ufb1e\ufe00-\ufe0f\ufe20-\ufe26\uff9e\uff9f]/,Yl=!1,_l=!1,$l=null,ql=function(){function e(e){return e<=247?r.charAt(e):1424<=e&&e<=1524?"R":1536<=e&&e<=1785?n.charAt(e-1536):1774<=e&&e<=2220?"r":8192<=e&&e<=8203?"w":8204==e?"b":"L"}function t(e,t,r){this.level=e,this.from=t,this.to=r}var r="bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLN",n="nnnnnnNNr%%r,rNNmmmmmmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmmmnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmnNmmmmmmrrmmNmmmmrr1111111111",i=/[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/,o=/[stwN]/,l=/[LRr]/,s=/[Lb1n]/,a=/[1n]/;return function(r,n){var u="ltr"==n?"L":"R";if(0==r.length||"ltr"==n&&!i.test(r))return!1;for(var c=r.length,f=[],h=0;h<c;++h)f.push(e(r.charCodeAt(h)));for(var d=0,p=u;d<c;++d){var v=f[d];"m"==v?f[d]=p:p=v}for(var m=0,y=u;m<c;++m){var b=f[m];"1"==b&&"r"==y?f[m]="n":l.test(b)&&(y=b,"r"==b&&(f[m]="R"))}for(var w=1,x=f[0];w<c-1;++w){var C=f[w];"+"==C&&"1"==x&&"1"==f[w+1]?f[w]="1":","!=C||x!=f[w+1]||"1"!=x&&"n"!=x||(f[w]=x),x=C}for(var S=0;S<c;++S){var L=f[S];if(","==L)f[S]="N";else if("%"==L){var k=void 0;for(k=S+1;k<c&&"%"==f[k];++k);for(var T=S&&"!"==f[S-1]||k<c&&"1"==f[k]?"1":"N",M=S;M<k;++M)f[M]=T;S=k-1}}for(var N=0,O=u;N<c;++N){var A=f[N];"L"==O&&"1"==A?f[N]="L":l.test(A)&&(O=A)}for(var W=0;W<c;++W)if(o.test(f[W])){var D=void 0;for(D=W+1;D<c&&o.test(f[D]);++D);for(var H="L"==(W?f[W-1]:u),F=H==("L"==(D<c?f[D]:u))?H?"L":"R":u,E=W;E<D;++E)f[E]=F;W=D-1}for(var P,I=[],z=0;z<c;)if(s.test(f[z])){var R=z;for(++z;z<c&&s.test(f[z]);++z);I.push(new t(0,R,z))}else{var B=z,G=I.length;for(++z;z<c&&"L"!=f[z];++z);for(var U=B;U<z;)if(a.test(f[U])){B<U&&I.splice(G,0,new t(1,B,U));var V=U;for(++U;U<z&&a.test(f[U]);++U);I.splice(G,0,new t(2,V,U)),B=U}else++U;B<z&&I.splice(G,0,new t(1,B,z))}return 1==I[0].level&&(P=r.match(/^\s+/))&&(I[0].from=P[0].length,I.unshift(new t(0,0,P[0].length))),1==g(I).level&&(P=r.match(/\s+$/))&&(g(I).to-=P[0].length,I.push(new t(0,c-P[0].length,c))),"rtl"==n?I.reverse():I}}(),Zl=[],Ql=function(e,t,r){if(e.addEventListener)e.addEventListener(t,r,!1);else if(e.attachEvent)e.attachEvent("on"+t,r);else{var n=e._handlers||(e._handlers={});n[t]=(n[t]||Zl).concat(r)}},Jl=function(){if(gl&&vl<9)return!1;var e=n("div");return"draggable"in e||"dragDrop"in e}(),es=3!="\n\nb".split(/\n/).length?function(e){for(var t=0,r=[],n=e.length;t<=n;){var i=e.indexOf("\n",t);-1==i&&(i=e.length);var o=e.slice(t,"\r"==e.charAt(i-1)?i-1:i),l=o.indexOf("\r");-1!=l?(r.push(o.slice(0,l)),t+=l+1):(r.push(o),t=i+1)}return r}:function(e){return e.split(/\r\n?|\n/)},ts=window.getSelection?function(e){try{return e.selectionStart!=e.selectionEnd}catch(e){return!1}}:function(e){var t;try{t=e.ownerDocument.selection.createRange()}catch(e){}return!(!t||t.parentElement()!=e)&&0!=t.compareEndPoints("StartToEnd",t)},rs=function(){var e=n("div");return"oncopy"in e||(e.setAttribute("oncopy","return;"),"function"==typeof e.oncopy)}(),ns=null,is={},os={},ls={},ss=function(e,t,r){this.pos=this.start=0,this.string=e,this.tabSize=t||8,this.lastColumnPos=this.lastColumnValue=0,this.lineStart=0,this.lineOracle=r};ss.prototype.eol=function(){return this.pos>=this.string.length},ss.prototype.sol=function(){return this.pos==this.lineStart},ss.prototype.peek=function(){return this.string.charAt(this.pos)||void 0},ss.prototype.next=function(){if(this.pos<this.string.length)return this.string.charAt(this.pos++)},ss.prototype.eat=function(e){var t=this.string.charAt(this.pos);if("string"==typeof e?t==e:t&&(e.test?e.test(t):e(t)))return++this.pos,t},ss.prototype.eatWhile=function(e){for(var t=this.pos;this.eat(e););return this.pos>t},ss.prototype.eatSpace=function(){for(var e=this,t=this.pos;/[\s\u00a0]/.test(this.string.charAt(this.pos));)++e.pos;return this.pos>t},ss.prototype.skipToEnd=function(){this.pos=this.string.length},ss.prototype.skipTo=function(e){var t=this.string.indexOf(e,this.pos);if(t>-1)return this.pos=t,!0},ss.prototype.backUp=function(e){this.pos-=e},ss.prototype.column=function(){return this.lastColumnPos<this.start&&(this.lastColumnValue=f(this.string,this.start,this.tabSize,this.lastColumnPos,this.lastColumnValue),this.lastColumnPos=this.start),this.lastColumnValue-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.indentation=function(){return f(this.string,null,this.tabSize)-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.match=function(e,t,r){if("string"!=typeof e){var n=this.string.slice(this.pos).match(e);return n&&n.index>0?null:(n&&!1!==t&&(this.pos+=n[0].length),n)}var i=function(e){return r?e.toLowerCase():e};if(i(this.string.substr(this.pos,e.length))==i(e))return!1!==t&&(this.pos+=e.length),!0},ss.prototype.current=function(){return this.string.slice(this.start,this.pos)},ss.prototype.hideFirstChars=function(e,t){this.lineStart+=e;try{return t()}finally{this.lineStart-=e}},ss.prototype.lookAhead=function(e){var t=this.lineOracle;return t&&t.lookAhead(e)};var as=function(e,t){this.state=e,this.lookAhead=t},us=function(e,t,r,n){this.state=t,this.doc=e,this.line=r,this.maxLookAhead=n||0};us.prototype.lookAhead=function(e){var t=this.doc.getLine(this.line+e);return null!=t&&e>this.maxLookAhead&&(this.maxLookAhead=e),t},us.prototype.nextLine=function(){this.line++,this.maxLookAhead>0&&this.maxLookAhead--},us.fromSaved=function(e,t,r){return t instanceof as?new us(e,Ke(e.mode,t.state),r,t.lookAhead):new us(e,Ke(e.mode,t),r)},us.prototype.save=function(e){var t=!1!==e?Ke(this.doc.mode,this.state):this.state;return this.maxLookAhead>0?new as(t,this.maxLookAhead):t};var cs=function(e,t,r){this.start=e.start,this.end=e.pos,this.string=e.current(),this.type=t||null,this.state=r},fs=function(e,t,r){this.text=e,ne(this,t),this.height=r?r(this):1};fs.prototype.lineNo=function(){return W(this)},Ae(fs);var hs,ds={},ps={},gs=null,vs=null,ms={left:0,right:0,top:0,bottom:0},ys=function(e,t,r){this.cm=r;var i=this.vert=n("div",[n("div",null,null,"min-width: 1px")],"CodeMirror-vscrollbar"),o=this.horiz=n("div",[n("div",null,null,"height: 100%; min-height: 1px")],"CodeMirror-hscrollbar");e(i),e(o),Ql(i,"scroll",function(){i.clientHeight&&t(i.scrollTop,"vertical")}),Ql(o,"scroll",function(){o.clientWidth&&t(o.scrollLeft,"horizontal")}),this.checkedZeroWidth=!1,gl&&vl<8&&(this.horiz.style.minHeight=this.vert.style.minWidth="18px")};ys.prototype.update=function(e){var t=e.scrollWidth>e.clientWidth+1,r=e.scrollHeight>e.clientHeight+1,n=e.nativeBarWidth;if(r){this.vert.style.display="block",this.vert.style.bottom=t?n+"px":"0";var i=e.viewHeight-(t?n:0);this.vert.firstChild.style.height=Math.max(0,e.scrollHeight-e.clientHeight+i)+"px"}else this.vert.style.display="",this.vert.firstChild.style.height="0";if(t){this.horiz.style.display="block",this.horiz.style.right=r?n+"px":"0",this.horiz.style.left=e.barLeft+"px";var o=e.viewWidth-e.barLeft-(r?n:0);this.horiz.firstChild.style.width=Math.max(0,e.scrollWidth-e.clientWidth+o)+"px"}else this.horiz.style.display="",this.horiz.firstChild.style.width="0";return!this.checkedZeroWidth&&e.clientHeight>0&&(0==n&&this.zeroWidthHack(),this.checkedZeroWidth=!0),{right:r?n:0,bottom:t?n:0}},ys.prototype.setScrollLeft=function(e){this.horiz.scrollLeft!=e&&(this.horiz.scrollLeft=e),this.disableHoriz&&this.enableZeroWidthBar(this.horiz,this.disableHoriz,"horiz")},ys.prototype.setScrollTop=function(e){this.vert.scrollTop!=e&&(this.vert.scrollTop=e),this.disableVert&&this.enableZeroWidthBar(this.vert,this.disableVert,"vert")},ys.prototype.zeroWidthHack=function(){var e=Ml&&!Cl?"12px":"18px";this.horiz.style.height=this.vert.style.width=e,this.horiz.style.pointerEvents=this.vert.style.pointerEvents="none",this.disableHoriz=new Pl,this.disableVert=new Pl},ys.prototype.enableZeroWidthBar=function(e,t,r){function n(){var i=e.getBoundingClientRect();("vert"==r?document.elementFromPoint(i.right-1,(i.top+i.bottom)/2):document.elementFromPoint((i.right+i.left)/2,i.bottom-1))!=e?e.style.pointerEvents="none":t.set(1e3,n)}e.style.pointerEvents="auto",t.set(1e3,n)},ys.prototype.clear=function(){var e=this.horiz.parentNode;e.removeChild(this.horiz),e.removeChild(this.vert)};var bs=function(){};bs.prototype.update=function(){return{bottom:0,right:0}},bs.prototype.setScrollLeft=function(){},bs.prototype.setScrollTop=function(){},bs.prototype.clear=function(){};var ws={native:ys,null:bs},xs=0,Cs=function(e,t,r){var n=e.display;this.viewport=t,this.visible=Ir(n,e.doc,t),this.editorIsHidden=!n.wrapper.offsetWidth,this.wrapperHeight=n.wrapper.clientHeight,this.wrapperWidth=n.wrapper.clientWidth,this.oldDisplayWidth=Rt(e),this.force=r,this.dims=br(e),this.events=[]};Cs.prototype.signal=function(e,t){Oe(e,t)&&this.events.push(arguments)},Cs.prototype.finish=function(){for(var e=this,t=0;t<this.events.length;t++)Te.apply(null,e.events[t])};var Ss=0,Ls=null;gl?Ls=-.53:fl?Ls=15:bl?Ls=-.7:xl&&(Ls=-1/3);var ks=function(e,t){this.ranges=e,this.primIndex=t};ks.prototype.primary=function(){return this.ranges[this.primIndex]},ks.prototype.equals=function(e){var t=this;if(e==this)return!0;if(e.primIndex!=this.primIndex||e.ranges.length!=this.ranges.length)return!1;for(var r=0;r<this.ranges.length;r++){var n=t.ranges[r],i=e.ranges[r];if(!I(n.anchor,i.anchor)||!I(n.head,i.head))return!1}return!0},ks.prototype.deepCopy=function(){for(var e=this,t=[],r=0;r<this.ranges.length;r++)t[r]=new Ts(z(e.ranges[r].anchor),z(e.ranges[r].head));return new ks(t,this.primIndex)},ks.prototype.somethingSelected=function(){for(var e=this,t=0;t<this.ranges.length;t++)if(!e.ranges[t].empty())return!0;return!1},ks.prototype.contains=function(e,t){var r=this;t||(t=e);for(var n=0;n<this.ranges.length;n++){var i=r.ranges[n];if(P(t,i.from())>=0&&P(e,i.to())<=0)return n}return-1};var Ts=function(e,t){this.anchor=e,this.head=t};Ts.prototype.from=function(){return B(this.anchor,this.head)},Ts.prototype.to=function(){return R(this.anchor,this.head)},Ts.prototype.empty=function(){return this.head.line==this.anchor.line&&this.head.ch==this.anchor.ch},Bi.prototype={chunkSize:function(){return this.lines.length},removeInner:function(e,t){for(var r=this,n=e,i=e+t;n<i;++n){var o=r.lines[n];r.height-=o.height,ot(o),bt(o,"delete")}this.lines.splice(e,t)},collapse:function(e){e.push.apply(e,this.lines)},insertInner:function(e,t,r){var n=this;this.height+=r,this.lines=this.lines.slice(0,e).concat(t).concat(this.lines.slice(e));for(var i=0;i<t.length;++i)t[i].parent=n},iterN:function(e,t,r){for(var n=this,i=e+t;e<i;++e)if(r(n.lines[e]))return!0}},Gi.prototype={chunkSize:function(){return this.size},removeInner:function(e,t){var r=this;this.size-=t;for(var n=0;n<this.children.length;++n){var i=r.children[n],o=i.chunkSize();if(e<o){var l=Math.min(t,o-e),s=i.height;if(i.removeInner(e,l),r.height-=s-i.height,o==l&&(r.children.splice(n--,1),i.parent=null),0==(t-=l))break;e=0}else e-=o}if(this.size-t<25&&(this.children.length>1||!(this.children[0]instanceof Bi))){var a=[];this.collapse(a),this.children=[new Bi(a)],this.children[0].parent=this}},collapse:function(e){for(var t=this,r=0;r<this.children.length;++r)t.children[r].collapse(e)},insertInner:function(e,t,r){var n=this;this.size+=t.length,this.height+=r;for(var i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<=l){if(o.insertInner(e,t,r),o.lines&&o.lines.length>50){for(var s=o.lines.length%25+25,a=s;a<o.lines.length;){var u=new Bi(o.lines.slice(a,a+=25));o.height-=u.height,n.children.splice(++i,0,u),u.parent=n}o.lines=o.lines.slice(0,s),n.maybeSpill()}break}e-=l}},maybeSpill:function(){if(!(this.children.length<=10)){var e=this;do{var t=new Gi(e.children.splice(e.children.length-5,5));if(e.parent){e.size-=t.size,e.height-=t.height;var r=h(e.parent.children,e);e.parent.children.splice(r+1,0,t)}else{var n=new Gi(e.children);n.parent=e,e.children=[n,t],e=n}t.parent=e.parent}while(e.children.length>10);e.parent.maybeSpill()}},iterN:function(e,t,r){for(var n=this,i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<l){var s=Math.min(t,l-e);if(o.iterN(e,s,r))return!0;if(0==(t-=s))break;e=0}else e-=l}}};var Ms=function(e,t,r){var n=this;if(r)for(var i in r)r.hasOwnProperty(i)&&(n[i]=r[i]);this.doc=e,this.node=t};Ms.prototype.clear=function(){var e=this,t=this.doc.cm,r=this.line.widgets,n=this.line,i=W(n);if(null!=i&&r){for(var o=0;o<r.length;++o)r[o]==e&&r.splice(o--,1);r.length||(n.widgets=null);var l=Ht(this);A(n,Math.max(0,n.height-l)),t&&(hn(t,function(){Ui(t,n,-l),mn(t,i,"widget")}),bt(t,"lineWidgetCleared",t,this,i))}},Ms.prototype.changed=function(){var e=this,t=this.height,r=this.doc.cm,n=this.line;this.height=null;var i=Ht(this)-t;i&&(A(n,n.height+i),r&&hn(r,function(){r.curOp.forceUpdate=!0,Ui(r,n,i),bt(r,"lineWidgetChanged",r,e,W(n))}))},Ae(Ms);var Ns=0,Os=function(e,t){this.lines=[],this.type=t,this.doc=e,this.id=++Ns};Os.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){var t=this.doc.cm,r=t&&!t.curOp;if(r&&nn(t),Oe(this,"clear")){var n=this.find();n&&bt(this,"clear",n.from,n.to)}for(var i=null,o=null,l=0;l<this.lines.length;++l){var s=e.lines[l],a=_(s.markedSpans,e);t&&!e.collapsed?mn(t,W(s),"text"):t&&(null!=a.to&&(o=W(s)),null!=a.from&&(i=W(s))),s.markedSpans=$(s.markedSpans,a),null==a.from&&e.collapsed&&!ve(e.doc,s)&&t&&A(s,mr(t.display))}if(t&&this.collapsed&&!t.options.lineWrapping)for(var u=0;u<this.lines.length;++u){var c=fe(e.lines[u]),f=be(c);f>t.display.maxLineLength&&(t.display.maxLine=c,t.display.maxLineLength=f,t.display.maxLineChanged=!0)}null!=i&&t&&this.collapsed&&vn(t,i,o+1),this.lines.length=0,this.explicitlyCleared=!0,this.atomic&&this.doc.cantEdit&&(this.doc.cantEdit=!1,t&&Ci(t.doc)),t&&bt(t,"markerCleared",t,this,i,o),r&&on(t),this.parent&&this.parent.clear()}},Os.prototype.find=function(e,t){var r=this;null==e&&"bookmark"==this.type&&(e=1);for(var n,i,o=0;o<this.lines.length;++o){var l=r.lines[o],s=_(l.markedSpans,r);if(null!=s.from&&(n=E(t?l:W(l),s.from),-1==e))return n;if(null!=s.to&&(i=E(t?l:W(l),s.to),1==e))return i}return n&&{from:n,to:i}},Os.prototype.changed=function(){var e=this,t=this.find(-1,!0),r=this,n=this.doc.cm;t&&n&&hn(n,function(){var i=t.line,o=W(t.line),l=jt(n,o);if(l&&(Qt(l),n.curOp.selectionChanged=n.curOp.forceUpdate=!0),n.curOp.updateMaxLine=!0,!ve(r.doc,i)&&null!=r.height){var s=r.height;r.height=null;var a=Ht(r)-s;a&&A(i,i.height+a)}bt(n,"markerChanged",n,e)})},Os.prototype.attachLine=function(e){if(!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;t.maybeHiddenMarkers&&-1!=h(t.maybeHiddenMarkers,this)||(t.maybeUnhiddenMarkers||(t.maybeUnhiddenMarkers=[])).push(this)}this.lines.push(e)},Os.prototype.detachLine=function(e){if(this.lines.splice(h(this.lines,e),1),!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;(t.maybeHiddenMarkers||(t.maybeHiddenMarkers=[])).push(this)}},Ae(Os);var As=function(e,t){var r=this;this.markers=e,this.primary=t;for(var n=0;n<e.length;++n)e[n].parent=r};As.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){this.explicitlyCleared=!0;for(var t=0;t<this.markers.length;++t)e.markers[t].clear();bt(this,"clear")}},As.prototype.find=function(e,t){return this.primary.find(e,t)},Ae(As);var Ws=0,Ds=function(e,t,r,n,i){if(!(this instanceof Ds))return new Ds(e,t,r,n,i);null==r&&(r=0),Gi.call(this,[new Bi([new fs("",null)])]),this.first=r,this.scrollTop=this.scrollLeft=0,this.cantEdit=!1,this.cleanGeneration=1,this.modeFrontier=this.highlightFrontier=r;var o=E(r,0);this.sel=Rn(o),this.history=new Jn(null),this.id=++Ws,this.modeOption=t,this.lineSep=n,this.direction="rtl"==i?"rtl":"ltr",this.extend=!1,"string"==typeof e&&(e=this.splitLines(e)),_n(this,{from:o,to:o,text:e}),bi(this,Rn(o),Gl)};Ds.prototype=b(Gi.prototype,{constructor:Ds,iter:function(e,t,r){r?this.iterN(e-this.first,t-e,r):this.iterN(this.first,this.first+this.size,e)},insert:function(e,t){for(var r=0,n=0;n<t.length;++n)r+=t[n].height;this.insertInner(e-this.first,t,r)},remove:function(e,t){this.removeInner(e-this.first,t)},getValue:function(e){var t=O(this,this.first,this.first+this.size);return!1===e?t:t.join(e||this.lineSeparator())},setValue:gn(function(e){var t=E(this.first,0),r=this.first+this.size-1;Oi(this,{from:t,to:E(r,M(this,r).text.length),text:this.splitLines(e),origin:"setValue",full:!0},!0),this.cm&&Xr(this.cm,0,0),bi(this,Rn(t),Gl)}),replaceRange:function(e,t,r,n){Ei(this,e,t=U(this,t),r=r?U(this,r):t,n)},getRange:function(e,t,r){var n=N(this,U(this,e),U(this,t));return!1===r?n:n.join(r||this.lineSeparator())},getLine:function(e){var t=this.getLineHandle(e);return t&&t.text},getLineHandle:function(e){if(H(this,e))return M(this,e)},getLineNumber:function(e){return W(e)},getLineHandleVisualStart:function(e){return"number"==typeof e&&(e=M(this,e)),fe(e)},lineCount:function(){return this.size},firstLine:function(){return this.first},lastLine:function(){return this.first+this.size-1},clipPos:function(e){return U(this,e)},getCursor:function(e){var t=this.sel.primary();return null==e||"head"==e?t.head:"anchor"==e?t.anchor:"end"==e||"to"==e||!1===e?t.to():t.from()},listSelections:function(){return this.sel.ranges},somethingSelected:function(){return this.sel.somethingSelected()},setCursor:gn(function(e,t,r){vi(this,U(this,"number"==typeof e?E(e,t||0):e),null,r)}),setSelection:gn(function(e,t,r){vi(this,U(this,e),U(this,t||e),r)}),extendSelection:gn(function(e,t,r){di(this,U(this,e),t&&U(this,t),r)}),extendSelections:gn(function(e,t){pi(this,K(this,e),t)}),extendSelectionsBy:gn(function(e,t){pi(this,K(this,v(this.sel.ranges,e)),t)}),setSelections:gn(function(e,t,r){var n=this;if(e.length){for(var i=[],o=0;o<e.length;o++)i[o]=new Ts(U(n,e[o].anchor),U(n,e[o].head));null==t&&(t=Math.min(e.length-1,this.sel.primIndex)),bi(this,zn(i,t),r)}}),addSelection:gn(function(e,t,r){var n=this.sel.ranges.slice(0);n.push(new Ts(U(this,e),U(this,t||e))),bi(this,zn(n,n.length-1),r)}),getSelection:function(e){for(var t,r=this,n=this.sel.ranges,i=0;i<n.length;i++){var o=N(r,n[i].from(),n[i].to());t=t?t.concat(o):o}return!1===e?t:t.join(e||this.lineSeparator())},getSelections:function(e){for(var t=this,r=[],n=this.sel.ranges,i=0;i<n.length;i++){var o=N(t,n[i].from(),n[i].to());!1!==e&&(o=o.join(e||t.lineSeparator())),r[i]=o}return r},replaceSelection:function(e,t,r){for(var n=[],i=0;i<this.sel.ranges.length;i++)n[i]=e;this.replaceSelections(n,t,r||"+input")},replaceSelections:gn(function(e,t,r){for(var n=this,i=[],o=this.sel,l=0;l<o.ranges.length;l++){var s=o.ranges[l];i[l]={from:s.from(),to:s.to(),text:n.splitLines(e[l]),origin:r}}for(var a=t&&"end"!=t&&Kn(this,i,t),u=i.length-1;u>=0;u--)Oi(n,i[u]);a?yi(this,a):this.cm&&jr(this.cm)}),undo:gn(function(){Wi(this,"undo")}),redo:gn(function(){Wi(this,"redo")}),undoSelection:gn(function(){Wi(this,"undo",!0)}),redoSelection:gn(function(){Wi(this,"redo",!0)}),setExtending:function(e){this.extend=e},getExtending:function(){return this.extend},historySize:function(){for(var e=this.history,t=0,r=0,n=0;n<e.done.length;n++)e.done[n].ranges||++t;for(var i=0;i<e.undone.length;i++)e.undone[i].ranges||++r;return{undo:t,redo:r}},clearHistory:function(){this.history=new Jn(this.history.maxGeneration)},markClean:function(){this.cleanGeneration=this.changeGeneration(!0)},changeGeneration:function(e){return e&&(this.history.lastOp=this.history.lastSelOp=this.history.lastOrigin=null),this.history.generation},isClean:function(e){return this.history.generation==(e||this.cleanGeneration)},getHistory:function(){return{done:fi(this.history.done),undone:fi(this.history.undone)}},setHistory:function(e){var t=this.history=new Jn(this.history.maxGeneration);t.done=fi(e.done.slice(0),null,!0),t.undone=fi(e.undone.slice(0),null,!0)},setGutterMarker:gn(function(e,t,r){return Ri(this,e,"gutter",function(e){var n=e.gutterMarkers||(e.gutterMarkers={});return n[t]=r,!r&&C(n)&&(e.gutterMarkers=null),!0})}),clearGutter:gn(function(e){var t=this;this.iter(function(r){r.gutterMarkers&&r.gutterMarkers[e]&&Ri(t,r,"gutter",function(){return r.gutterMarkers[e]=null,C(r.gutterMarkers)&&(r.gutterMarkers=null),!0})})}),lineInfo:function(e){var t;if("number"==typeof e){if(!H(this,e))return null;if(t=e,!(e=M(this,e)))return null}else if(null==(t=W(e)))return null;return{line:t,handle:e,text:e.text,gutterMarkers:e.gutterMarkers,textClass:e.textClass,bgClass:e.bgClass,wrapClass:e.wrapClass,widgets:e.widgets}},addLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass";if(t[i]){if(e(n).test(t[i]))return!1;t[i]+=" "+n}else t[i]=n;return!0})}),removeLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass",o=t[i];if(!o)return!1;if(null==n)t[i]=null;else{var l=o.match(e(n));if(!l)return!1;var s=l.index+l[0].length;t[i]=o.slice(0,l.index)+(l.index&&s!=o.length?" ":"")+o.slice(s)||null}return!0})}),addLineWidget:gn(function(e,t,r){return Vi(this,e,t,r)}),removeLineWidget:function(e){e.clear()},markText:function(e,t,r){return Ki(this,U(this,e),U(this,t),r,r&&r.type||"range")},setBookmark:function(e,t){var r={replacedWith:t&&(null==t.nodeType?t.widget:t),insertLeft:t&&t.insertLeft,clearWhenEmpty:!1,shared:t&&t.shared,handleMouseEvents:t&&t.handleMouseEvents};return e=U(this,e),Ki(this,e,e,r,"bookmark")},findMarksAt:function(e){var t=[],r=M(this,(e=U(this,e)).line).markedSpans;if(r)for(var n=0;n<r.length;++n){var i=r[n];(null==i.from||i.from<=e.ch)&&(null==i.to||i.to>=e.ch)&&t.push(i.marker.parent||i.marker)}return t},findMarks:function(e,t,r){e=U(this,e),t=U(this,t);var n=[],i=e.line;return this.iter(e.line,t.line+1,function(o){var l=o.markedSpans;if(l)for(var s=0;s<l.length;s++){var a=l[s];null!=a.to&&i==e.line&&e.ch>=a.to||null==a.from&&i!=e.line||null!=a.from&&i==t.line&&a.from>=t.ch||r&&!r(a.marker)||n.push(a.marker.parent||a.marker)}++i}),n},getAllMarks:function(){var e=[];return this.iter(function(t){var r=t.markedSpans;if(r)for(var n=0;n<r.length;++n)null!=r[n].from&&e.push(r[n].marker)}),e},posFromIndex:function(e){var t,r=this.first,n=this.lineSeparator().length;return this.iter(function(i){var o=i.text.length+n;if(o>e)return t=e,!0;e-=o,++r}),U(this,E(r,t))},indexFromPos:function(e){var t=(e=U(this,e)).ch;if(e.line<this.first||e.ch<0)return 0;var r=this.lineSeparator().length;return this.iter(this.first,e.line,function(e){t+=e.text.length+r}),t},copy:function(e){var t=new Ds(O(this,this.first,this.first+this.size),this.modeOption,this.first,this.lineSep,this.direction);return t.scrollTop=this.scrollTop,t.scrollLeft=this.scrollLeft,t.sel=this.sel,t.extend=!1,e&&(t.history.undoDepth=this.history.undoDepth,t.setHistory(this.getHistory())),t},linkedDoc:function(e){e||(e={});var t=this.first,r=this.first+this.size;null!=e.from&&e.from>t&&(t=e.from),null!=e.to&&e.to<r&&(r=e.to);var n=new Ds(O(this,t,r),e.mode||this.modeOption,t,this.lineSep,this.direction);return e.sharedHist&&(n.history=this.history),(this.linked||(this.linked=[])).push({doc:n,sharedHist:e.sharedHist}),n.linked=[{doc:this,isParent:!0,sharedHist:e.sharedHist}],Yi(n,Xi(this)),n},unlinkDoc:function(e){var t=this;if(e instanceof jo&&(e=e.doc),this.linked)for(var r=0;r<this.linked.length;++r)if(t.linked[r].doc==e){t.linked.splice(r,1),e.unlinkDoc(t),_i(Xi(t));break}if(e.history==this.history){var n=[e.id];$n(e,function(e){return n.push(e.id)},!0),e.history=new Jn(null),e.history.done=fi(this.history.done,n),e.history.undone=fi(this.history.undone,n)}},iterLinkedDocs:function(e){$n(this,e)},getMode:function(){return this.mode},getEditor:function(){return this.cm},splitLines:function(e){return this.lineSep?e.split(this.lineSep):es(e)},lineSeparator:function(){return this.lineSep||"\n"},setDirection:gn(function(e){"rtl"!=e&&(e="ltr"),e!=this.direction&&(this.direction=e,this.iter(function(e){return e.order=null}),this.cm&&Qn(this.cm))})}),Ds.prototype.eachLine=Ds.prototype.iter;for(var Hs=0,Fs=!1,Es={3:"Enter",8:"Backspace",9:"Tab",13:"Enter",16:"Shift",17:"Ctrl",18:"Alt",19:"Pause",20:"CapsLock",27:"Esc",32:"Space",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"Left",38:"Up",39:"Right",40:"Down",44:"PrintScrn",45:"Insert",46:"Delete",59:";",61:"=",91:"Mod",92:"Mod",93:"Mod",106:"*",107:"=",109:"-",110:".",111:"/",127:"Delete",173:"-",186:";",187:"=",188:",",189:"-",190:".",191:"/",192:"`",219:"[",220:"\\",221:"]",222:"'",63232:"Up",63233:"Down",63234:"Left",63235:"Right",63272:"Delete",63273:"Home",63275:"End",63276:"PageUp",63277:"PageDown",63302:"Insert"},Ps=0;Ps<10;Ps++)Es[Ps+48]=Es[Ps+96]=String(Ps);for(var Is=65;Is<=90;Is++)Es[Is]=String.fromCharCode(Is);for(var zs=1;zs<=12;zs++)Es[zs+111]=Es[zs+63235]="F"+zs;var Rs={};Rs.basic={Left:"goCharLeft",Right:"goCharRight",Up:"goLineUp",Down:"goLineDown",End:"goLineEnd",Home:"goLineStartSmart",PageUp:"goPageUp",PageDown:"goPageDown",Delete:"delCharAfter",Backspace:"delCharBefore","Shift-Backspace":"delCharBefore",Tab:"defaultTab","Shift-Tab":"indentAuto",Enter:"newlineAndIndent",Insert:"toggleOverwrite",Esc:"singleSelection"},Rs.pcDefault={"Ctrl-A":"selectAll","Ctrl-D":"deleteLine","Ctrl-Z":"undo","Shift-Ctrl-Z":"redo","Ctrl-Y":"redo","Ctrl-Home":"goDocStart","Ctrl-End":"goDocEnd","Ctrl-Up":"goLineUp","Ctrl-Down":"goLineDown","Ctrl-Left":"goGroupLeft","Ctrl-Right":"goGroupRight","Alt-Left":"goLineStart","Alt-Right":"goLineEnd","Ctrl-Backspace":"delGroupBefore","Ctrl-Delete":"delGroupAfter","Ctrl-S":"save","Ctrl-F":"find","Ctrl-G":"findNext","Shift-Ctrl-G":"findPrev","Shift-Ctrl-F":"replace","Shift-Ctrl-R":"replaceAll","Ctrl-[":"indentLess","Ctrl-]":"indentMore","Ctrl-U":"undoSelection","Shift-Ctrl-U":"redoSelection","Alt-U":"redoSelection",fallthrough:"basic"},Rs.emacsy={"Ctrl-F":"goCharRight","Ctrl-B":"goCharLeft","Ctrl-P":"goLineUp","Ctrl-N":"goLineDown","Alt-F":"goWordRight","Alt-B":"goWordLeft","Ctrl-A":"goLineStart","Ctrl-E":"goLineEnd","Ctrl-V":"goPageDown","Shift-Ctrl-V":"goPageUp","Ctrl-D":"delCharAfter","Ctrl-H":"delCharBefore","Alt-D":"delWordAfter","Alt-Backspace":"delWordBefore","Ctrl-K":"killLine","Ctrl-T":"transposeChars","Ctrl-O":"openLine"},Rs.macDefault={"Cmd-A":"selectAll","Cmd-D":"deleteLine","Cmd-Z":"undo","Shift-Cmd-Z":"redo","Cmd-Y":"redo","Cmd-Home":"goDocStart","Cmd-Up":"goDocStart","Cmd-End":"goDocEnd","Cmd-Down":"goDocEnd","Alt-Left":"goGroupLeft","Alt-Right":"goGroupRight","Cmd-Left":"goLineLeft","Cmd-Right":"goLineRight","Alt-Backspace":"delGroupBefore","Ctrl-Alt-Backspace":"delGroupAfter","Alt-Delete":"delGroupAfter","Cmd-S":"save","Cmd-F":"find","Cmd-G":"findNext","Shift-Cmd-G":"findPrev","Cmd-Alt-F":"replace","Shift-Cmd-Alt-F":"replaceAll","Cmd-[":"indentLess","Cmd-]":"indentMore","Cmd-Backspace":"delWrappedLineLeft","Cmd-Delete":"delWrappedLineRight","Cmd-U":"undoSelection","Shift-Cmd-U":"redoSelection","Ctrl-Up":"goDocStart","Ctrl-Down":"goDocEnd",fallthrough:["basic","emacsy"]},Rs.default=Ml?Rs.macDefault:Rs.pcDefault;var Bs={selectAll:Mi,singleSelection:function(e){return e.setSelection(e.getCursor("anchor"),e.getCursor("head"),Gl)},killLine:function(e){return co(e,function(t){if(t.empty()){var r=M(e.doc,t.head.line).text.length;return t.head.ch==r&&t.head.line<e.lastLine()?{from:t.head,to:E(t.head.line+1,0)}:{from:t.head,to:E(t.head.line,r)}}return{from:t.from(),to:t.to()}})},deleteLine:function(e){return co(e,function(t){return{from:E(t.from().line,0),to:U(e.doc,E(t.to().line+1,0))}})},delLineLeft:function(e){return co(e,function(e){return{from:E(e.from().line,0),to:e.from()}})},delWrappedLineLeft:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5;return{from:e.coordsChar({left:0,top:r},"div"),to:t.from()}})},delWrappedLineRight:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5,n=e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div");return{from:t.from(),to:n}})},undo:function(e){return e.undo()},redo:function(e){return e.redo()},undoSelection:function(e){return e.undoSelection()},redoSelection:function(e){return e.redoSelection()},goDocStart:function(e){return e.extendSelection(E(e.firstLine(),0))},goDocEnd:function(e){return e.extendSelection(E(e.lastLine()))},goLineStart:function(e){return e.extendSelectionsBy(function(t){return vo(e,t.head.line)},{origin:"+move",bias:1})},goLineStartSmart:function(e){return e.extendSelectionsBy(function(t){return yo(e,t.head)},{origin:"+move",bias:1})},goLineEnd:function(e){return e.extendSelectionsBy(function(t){return mo(e,t.head.line)},{origin:"+move",bias:-1})},goLineRight:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div")},Vl)},goLineLeft:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:0,top:r},"div")},Vl)},goLineLeftSmart:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5,n=e.coordsChar({left:0,top:r},"div");return n.ch<e.getLine(n.line).search(/\S/)?yo(e,t.head):n},Vl)},goLineUp:function(e){return e.moveV(-1,"line")},goLineDown:function(e){return e.moveV(1,"line")},goPageUp:function(e){return e.moveV(-1,"page")},goPageDown:function(e){return e.moveV(1,"page")},goCharLeft:function(e){return e.moveH(-1,"char")},goCharRight:function(e){return e.moveH(1,"char")},goColumnLeft:function(e){return e.moveH(-1,"column")},goColumnRight:function(e){return e.moveH(1,"column")},goWordLeft:function(e){return e.moveH(-1,"word")},goGroupRight:function(e){return e.moveH(1,"group")},goGroupLeft:function(e){return e.moveH(-1,"group")},goWordRight:function(e){return e.moveH(1,"word")},delCharBefore:function(e){return e.deleteH(-1,"char")},delCharAfter:function(e){return e.deleteH(1,"char")},delWordBefore:function(e){return e.deleteH(-1,"word")},delWordAfter:function(e){return e.deleteH(1,"word")},delGroupBefore:function(e){return e.deleteH(-1,"group")},delGroupAfter:function(e){return e.deleteH(1,"group")},indentAuto:function(e){return e.indentSelection("smart")},indentMore:function(e){return e.indentSelection("add")},indentLess:function(e){return e.indentSelection("subtract")},insertTab:function(e){return e.replaceSelection("\t")},insertSoftTab:function(e){for(var t=[],r=e.listSelections(),n=e.options.tabSize,i=0;i<r.length;i++){var o=r[i].from(),l=f(e.getLine(o.line),o.ch,n);t.push(p(n-l%n))}e.replaceSelections(t)},defaultTab:function(e){e.somethingSelected()?e.indentSelection("add"):e.execCommand("insertTab")},transposeChars:function(e){return hn(e,function(){for(var t=e.listSelections(),r=[],n=0;n<t.length;n++)if(t[n].empty()){var i=t[n].head,o=M(e.doc,i.line).text;if(o)if(i.ch==o.length&&(i=new E(i.line,i.ch-1)),i.ch>0)i=new E(i.line,i.ch+1),e.replaceRange(o.charAt(i.ch-1)+o.charAt(i.ch-2),E(i.line,i.ch-2),i,"+transpose");else if(i.line>e.doc.first){var l=M(e.doc,i.line-1).text;l&&(i=new E(i.line,1),e.replaceRange(o.charAt(0)+e.doc.lineSeparator()+l.charAt(l.length-1),E(i.line-1,l.length-1),i,"+transpose"))}r.push(new Ts(i,i))}e.setSelections(r)})},newlineAndIndent:function(e){return hn(e,function(){for(var t=e.listSelections(),r=t.length-1;r>=0;r--)e.replaceRange(e.doc.lineSeparator(),t[r].anchor,t[r].head,"+input");t=e.listSelections();for(var n=0;n<t.length;n++)e.indentLine(t[n].from().line,null,!0);jr(e)})},openLine:function(e){return e.replaceSelection("\n","start")},toggleOverwrite:function(e){return e.toggleOverwrite()}},Gs=new Pl,Us=null,Vs=function(e,t,r){this.time=e,this.pos=t,this.button=r};Vs.prototype.compare=function(e,t,r){return this.time+400>e&&0==P(t,this.pos)&&r==this.button};var Ks,js,Xs={toString:function(){return"CodeMirror.Init"}},Ys={},_s={};jo.defaults=Ys,jo.optionHandlers=_s;var $s=[];jo.defineInitHook=function(e){return $s.push(e)};var qs=null,Zs=function(e){this.cm=e,this.lastAnchorNode=this.lastAnchorOffset=this.lastFocusNode=this.lastFocusOffset=null,this.polling=new Pl,this.composing=null,this.gracePeriod=!1,this.readDOMTimeout=null};Zs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()}),"cut"==e.type&&i.replaceSelection("",null,"cut");else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type&&i.operation(function(){i.setSelections(t.ranges,0,Gl),i.replaceSelection("",null,"cut")})}if(e.clipboardData){e.clipboardData.clearData();var r=qs.text.join("\n");if(e.clipboardData.setData("Text",r),e.clipboardData.getData("Text")==r)return void e.preventDefault()}var l=el(),s=l.firstChild;i.display.lineSpace.insertBefore(l,i.display.lineSpace.firstChild),s.value=qs.text.join("\n");var a=document.activeElement;El(s),setTimeout(function(){i.display.lineSpace.removeChild(l),a.focus(),a==o&&n.showPrimarySelection()},50)}}var r=this,n=this,i=n.cm,o=n.div=e.lineDiv;Jo(o,i.options.spellcheck),Ql(o,"paste",function(e){Me(i,e)||qo(e,i)||vl<=11&&setTimeout(dn(i,function(){return r.updateFromDOM()}),20)}),Ql(o,"compositionstart",function(e){r.composing={data:e.data,done:!1}}),Ql(o,"compositionupdate",function(e){r.composing||(r.composing={data:e.data,done:!1})}),Ql(o,"compositionend",function(e){r.composing&&(e.data!=r.composing.data&&r.readFromDOMSoon(),r.composing.done=!0)}),Ql(o,"touchstart",function(){return n.forceCompositionEnd()}),Ql(o,"input",function(){r.composing||r.readFromDOMSoon()}),Ql(o,"copy",t),Ql(o,"cut",t)},Zs.prototype.prepareSelection=function(){var e=Tr(this.cm,!1);return e.focus=this.cm.state.focused,e},Zs.prototype.showSelection=function(e,t){e&&this.cm.display.view.length&&((e.focus||t)&&this.showPrimarySelection(),this.showMultipleSelections(e))},Zs.prototype.showPrimarySelection=function(){var e=window.getSelection(),t=this.cm,r=t.doc.sel.primary(),n=r.from(),i=r.to();if(t.display.viewTo==t.display.viewFrom||n.line>=t.display.viewTo||i.line<t.display.viewFrom)e.removeAllRanges();else{var o=sl(t,e.anchorNode,e.anchorOffset),l=sl(t,e.focusNode,e.focusOffset);if(!o||o.bad||!l||l.bad||0!=P(B(o,l),n)||0!=P(R(o,l),i)){var s=t.display.view,a=n.line>=t.display.viewFrom&&nl(t,n)||{node:s[0].measure.map[2],offset:0},u=i.line<t.display.viewTo&&nl(t,i);if(!u){var c=s[s.length-1].measure,f=c.maps?c.maps[c.maps.length-1]:c.map;u={node:f[f.length-1],offset:f[f.length-2]-f[f.length-3]}}if(a&&u){var h,d=e.rangeCount&&e.getRangeAt(0);try{h=Wl(a.node,a.offset,u.offset,u.node)}catch(e){}h&&(!fl&&t.state.focused?(e.collapse(a.node,a.offset),h.collapsed||(e.removeAllRanges(),e.addRange(h))):(e.removeAllRanges(),e.addRange(h)),d&&null==e.anchorNode?e.addRange(d):fl&&this.startGracePeriod()),this.rememberSelection()}else e.removeAllRanges()}}},Zs.prototype.startGracePeriod=function(){var e=this;clearTimeout(this.gracePeriod),this.gracePeriod=setTimeout(function(){e.gracePeriod=!1,e.selectionChanged()&&e.cm.operation(function(){return e.cm.curOp.selectionChanged=!0})},20)},Zs.prototype.showMultipleSelections=function(e){r(this.cm.display.cursorDiv,e.cursors),r(this.cm.display.selectionDiv,e.selection)},Zs.prototype.rememberSelection=function(){var e=window.getSelection();this.lastAnchorNode=e.anchorNode,this.lastAnchorOffset=e.anchorOffset,this.lastFocusNode=e.focusNode,this.lastFocusOffset=e.focusOffset},Zs.prototype.selectionInEditor=function(){var e=window.getSelection();if(!e.rangeCount)return!1;var t=e.getRangeAt(0).commonAncestorContainer;return o(this.div,t)},Zs.prototype.focus=function(){"nocursor"!=this.cm.options.readOnly&&(this.selectionInEditor()||this.showSelection(this.prepareSelection(),!0),this.div.focus())},Zs.prototype.blur=function(){this.div.blur()},Zs.prototype.getField=function(){return this.div},Zs.prototype.supportsTouch=function(){return!0},Zs.prototype.receivedFocus=function(){function e(){t.cm.state.focused&&(t.pollSelection(),t.polling.set(t.cm.options.pollInterval,e))}var t=this;this.selectionInEditor()?this.pollSelection():hn(this.cm,function(){return t.cm.curOp.selectionChanged=!0}),this.polling.set(this.cm.options.pollInterval,e)},Zs.prototype.selectionChanged=function(){var e=window.getSelection();return e.anchorNode!=this.lastAnchorNode||e.anchorOffset!=this.lastAnchorOffset||e.focusNode!=this.lastFocusNode||e.focusOffset!=this.lastFocusOffset},Zs.prototype.pollSelection=function(){if(null==this.readDOMTimeout&&!this.gracePeriod&&this.selectionChanged()){var e=window.getSelection(),t=this.cm;if(kl&&bl&&this.cm.options.gutters.length&&il(e.anchorNode))return this.cm.triggerOnKeyDown({type:"keydown",keyCode:8,preventDefault:Math.abs}),this.blur(),void this.focus();if(!this.composing){this.rememberSelection();var r=sl(t,e.anchorNode,e.anchorOffset),n=sl(t,e.focusNode,e.focusOffset);r&&n&&hn(t,function(){bi(t.doc,Rn(r,n),Gl),(r.bad||n.bad)&&(t.curOp.selectionChanged=!0)})}}},Zs.prototype.pollContent=function(){null!=this.readDOMTimeout&&(clearTimeout(this.readDOMTimeout),this.readDOMTimeout=null);var e=this.cm,t=e.display,r=e.doc.sel.primary(),n=r.from(),i=r.to();if(0==n.ch&&n.line>e.firstLine()&&(n=E(n.line-1,M(e.doc,n.line-1).length)),i.ch==M(e.doc,i.line).text.length&&i.line<e.lastLine()&&(i=E(i.line+1,0)),n.line<t.viewFrom||i.line>t.viewTo-1)return!1;var o,l,s;n.line==t.viewFrom||0==(o=Lr(e,n.line))?(l=W(t.view[0].line),s=t.view[0].node):(l=W(t.view[o].line),s=t.view[o-1].node.nextSibling);var a,u,c=Lr(e,i.line);if(c==t.view.length-1?(a=t.viewTo-1,u=t.lineDiv.lastChild):(a=W(t.view[c+1].line)-1,u=t.view[c+1].node.previousSibling),!s)return!1;for(var f=e.doc.splitLines(ll(e,s,u,l,a)),h=N(e.doc,E(l,0),E(a,M(e.doc,a).text.length));f.length>1&&h.length>1;)if(g(f)==g(h))f.pop(),h.pop(),a--;else{if(f[0]!=h[0])break;f.shift(),h.shift(),l++}for(var d=0,p=0,v=f[0],m=h[0],y=Math.min(v.length,m.length);d<y&&v.charCodeAt(d)==m.charCodeAt(d);)++d;for(var b=g(f),w=g(h),x=Math.min(b.length-(1==f.length?d:0),w.length-(1==h.length?d:0));p<x&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)++p;if(1==f.length&&1==h.length&&l==n.line)for(;d&&d>n.ch&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)d--,p++;f[f.length-1]=b.slice(0,b.length-p).replace(/^\u200b+/,""),f[0]=f[0].slice(d).replace(/\u200b+$/,"");var C=E(l,d),S=E(a,h.length?g(h).length-p:0);return f.length>1||f[0]||P(C,S)?(Ei(e.doc,f,C,S,"+input"),!0):void 0},Zs.prototype.ensurePolled=function(){this.forceCompositionEnd()},Zs.prototype.reset=function(){this.forceCompositionEnd()},Zs.prototype.forceCompositionEnd=function(){this.composing&&(clearTimeout(this.readDOMTimeout),this.composing=null,this.updateFromDOM(),this.div.blur(),this.div.focus())},Zs.prototype.readFromDOMSoon=function(){var e=this;null==this.readDOMTimeout&&(this.readDOMTimeout=setTimeout(function(){if(e.readDOMTimeout=null,e.composing){if(!e.composing.done)return;e.composing=null}e.updateFromDOM()},80))},Zs.prototype.updateFromDOM=function(){var e=this;!this.cm.isReadOnly()&&this.pollContent()||hn(this.cm,function(){return vn(e.cm)})},Zs.prototype.setUneditable=function(e){e.contentEditable="false"},Zs.prototype.onKeyPress=function(e){0!=e.charCode&&(e.preventDefault(),this.cm.isReadOnly()||dn(this.cm,$o)(this.cm,String.fromCharCode(null==e.charCode?e.keyCode:e.charCode),0))},Zs.prototype.readOnlyChanged=function(e){this.div.contentEditable=String("nocursor"!=e)},Zs.prototype.onContextMenu=function(){},Zs.prototype.resetPosition=function(){},Zs.prototype.needsContentAttribute=!0;var Qs=function(e){this.cm=e,this.prevInput="",this.pollingFast=!1,this.polling=new Pl,this.hasSelection=!1,this.composing=null};Qs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()});else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type?i.setSelections(t.ranges,null,Gl):(n.prevInput="",l.value=t.text.join("\n"),El(l))}"cut"==e.type&&(i.state.cutIncoming=!0)}}var r=this,n=this,i=this.cm,o=this.wrapper=el(),l=this.textarea=o.firstChild;e.wrapper.insertBefore(o,e.wrapper.firstChild),Ll&&(l.style.width="0px"),Ql(l,"input",function(){gl&&vl>=9&&r.hasSelection&&(r.hasSelection=null),n.poll()}),Ql(l,"paste",function(e){Me(i,e)||qo(e,i)||(i.state.pasteIncoming=!0,n.fastPoll())}),Ql(l,"cut",t),Ql(l,"copy",t),Ql(e.scroller,"paste",function(t){Ft(e,t)||Me(i,t)||(i.state.pasteIncoming=!0,n.focus())}),Ql(e.lineSpace,"selectstart",function(t){Ft(e,t)||We(t)}),Ql(l,"compositionstart",function(){var e=i.getCursor("from");n.composing&&n.composing.range.clear(),n.composing={start:e,range:i.markText(e,i.getCursor("to"),{className:"CodeMirror-composing"})}}),Ql(l,"compositionend",function(){n.composing&&(n.poll(),n.composing.range.clear(),n.composing=null)})},Qs.prototype.prepareSelection=function(){var e=this.cm,t=e.display,r=e.doc,n=Tr(e);if(e.options.moveInputWithCursor){var i=sr(e,r.sel.primary().head,"div"),o=t.wrapper.getBoundingClientRect(),l=t.lineDiv.getBoundingClientRect();n.teTop=Math.max(0,Math.min(t.wrapper.clientHeight-10,i.top+l.top-o.top)),n.teLeft=Math.max(0,Math.min(t.wrapper.clientWidth-10,i.left+l.left-o.left))}return n},Qs.prototype.showSelection=function(e){var t=this.cm.display;r(t.cursorDiv,e.cursors),r(t.selectionDiv,e.selection),null!=e.teTop&&(this.wrapper.style.top=e.teTop+"px",this.wrapper.style.left=e.teLeft+"px")},Qs.prototype.reset=function(e){if(!this.contextMenuPending&&!this.composing){var t=this.cm;if(t.somethingSelected()){this.prevInput="";var r=t.getSelection();this.textarea.value=r,t.state.focused&&El(this.textarea),gl&&vl>=9&&(this.hasSelection=r)}else e||(this.prevInput=this.textarea.value="",gl&&vl>=9&&(this.hasSelection=null))}},Qs.prototype.getField=function(){return this.textarea},Qs.prototype.supportsTouch=function(){return!1},Qs.prototype.focus=function(){if("nocursor"!=this.cm.options.readOnly&&(!Tl||l()!=this.textarea))try{this.textarea.focus()}catch(e){}},Qs.prototype.blur=function(){this.textarea.blur()},Qs.prototype.resetPosition=function(){this.wrapper.style.top=this.wrapper.style.left=0},Qs.prototype.receivedFocus=function(){this.slowPoll()},Qs.prototype.slowPoll=function(){var e=this;this.pollingFast||this.polling.set(this.cm.options.pollInterval,function(){e.poll(),e.cm.state.focused&&e.slowPoll()})},Qs.prototype.fastPoll=function(){function e(){r.poll()||t?(r.pollingFast=!1,r.slowPoll()):(t=!0,r.polling.set(60,e))}var t=!1,r=this;r.pollingFast=!0,r.polling.set(20,e)},Qs.prototype.poll=function(){var e=this,t=this.cm,r=this.textarea,n=this.prevInput;if(this.contextMenuPending||!t.state.focused||ts(r)&&!n&&!this.composing||t.isReadOnly()||t.options.disableInput||t.state.keySeq)return!1;var i=r.value;if(i==n&&!t.somethingSelected())return!1;if(gl&&vl>=9&&this.hasSelection===i||Ml&&/[\uf700-\uf7ff]/.test(i))return t.display.input.reset(),!1;if(t.doc.sel==t.display.selForContextMenu){var o=i.charCodeAt(0);if(8203!=o||n||(n="​"),8666==o)return this.reset(),this.cm.execCommand("undo")}for(var l=0,s=Math.min(n.length,i.length);l<s&&n.charCodeAt(l)==i.charCodeAt(l);)++l;return hn(t,function(){$o(t,i.slice(l),n.length-l,null,e.composing?"*compose":null),i.length>1e3||i.indexOf("\n")>-1?r.value=e.prevInput="":e.prevInput=i,e.composing&&(e.composing.range.clear(),e.composing.range=t.markText(e.composing.start,t.getCursor("to"),{className:"CodeMirror-composing"}))}),!0},Qs.prototype.ensurePolled=function(){this.pollingFast&&this.poll()&&(this.pollingFast=!1)},Qs.prototype.onKeyPress=function(){gl&&vl>=9&&(this.hasSelection=null),this.fastPoll()},Qs.prototype.onContextMenu=function(e){function t(){if(null!=l.selectionStart){var e=i.somethingSelected(),t="​"+(e?l.value:"");l.value="⇚",l.value=t,n.prevInput=e?"":"​",l.selectionStart=1,l.selectionEnd=t.length,o.selForContextMenu=i.doc.sel}}function r(){if(n.contextMenuPending=!1,n.wrapper.style.cssText=c,l.style.cssText=u,gl&&vl<9&&o.scrollbars.setScrollTop(o.scroller.scrollTop=a),null!=l.selectionStart){(!gl||gl&&vl<9)&&t();var e=0,r=function(){o.selForContextMenu==i.doc.sel&&0==l.selectionStart&&l.selectionEnd>0&&"​"==n.prevInput?dn(i,Mi)(i):e++<10?o.detectingSelectAll=setTimeout(r,500):(o.selForContextMenu=null,o.input.reset())};o.detectingSelectAll=setTimeout(r,200)}}var n=this,i=n.cm,o=i.display,l=n.textarea,s=Sr(i,e),a=o.scroller.scrollTop;if(s&&!wl){i.options.resetSelectionOnContextMenu&&-1==i.doc.sel.contains(s)&&dn(i,bi)(i.doc,Rn(s),Gl);var u=l.style.cssText,c=n.wrapper.style.cssText;n.wrapper.style.cssText="position: absolute";var f=n.wrapper.getBoundingClientRect();l.style.cssText="position: absolute; width: 30px; height: 30px;\n      top: "+(e.clientY-f.top-5)+"px; left: "+(e.clientX-f.left-5)+"px;\n      z-index: 1000; background: "+(gl?"rgba(255, 255, 255, .05)":"transparent")+";\n      outline: none; border-width: 0; outline: none; overflow: hidden; opacity: .05; filter: alpha(opacity=5);";var h;if(ml&&(h=window.scrollY),o.input.focus(),ml&&window.scrollTo(null,h),o.input.reset(),i.somethingSelected()||(l.value=n.prevInput=" "),n.contextMenuPending=!0,o.selForContextMenu=i.doc.sel,clearTimeout(o.detectingSelectAll),gl&&vl>=9&&t(),Hl){Fe(e);var d=function(){ke(window,"mouseup",d),setTimeout(r,20)};Ql(window,"mouseup",d)}else setTimeout(r,50)}},Qs.prototype.readOnlyChanged=function(e){e||this.reset(),this.textarea.disabled="nocursor"==e},Qs.prototype.setUneditable=function(){},Qs.prototype.needsContentAttribute=!1,function(e){function t(t,n,i,o){e.defaults[t]=n,i&&(r[t]=o?function(e,t,r){r!=Xs&&i(e,t,r)}:i)}var r=e.optionHandlers;e.defineOption=t,e.Init=Xs,t("value","",function(e,t){return e.setValue(t)},!0),t("mode",null,function(e,t){e.doc.modeOption=t,jn(e)},!0),t("indentUnit",2,jn,!0),t("indentWithTabs",!1),t("smartIndent",!0),t("tabSize",4,function(e){Xn(e),er(e),vn(e)},!0),t("lineSeparator",null,function(e,t){if(e.doc.lineSep=t,t){var r=[],n=e.doc.first;e.doc.iter(function(e){for(var i=0;;){var o=e.text.indexOf(t,i);if(-1==o)break;i=o+t.length,r.push(E(n,o))}n++});for(var i=r.length-1;i>=0;i--)Ei(e.doc,t,r[i],E(r[i].line,r[i].ch+t.length))}}),t("specialChars",/[\u0000-\u001f\u007f-\u009f\u00ad\u061c\u200b-\u200f\u2028\u2029\ufeff]/g,function(e,t,r){e.state.specialChars=new RegExp(t.source+(t.test("\t")?"":"|\t"),"g"),r!=Xs&&e.refresh()}),t("specialCharPlaceholder",at,function(e){return e.refresh()},!0),t("electricChars",!0),t("inputStyle",Tl?"contenteditable":"textarea",function(){throw new Error("inputStyle can not (yet) be changed in a running editor")},!0),t("spellcheck",!1,function(e,t){return e.getInputField().spellcheck=t},!0),t("rtlMoveVisually",!Ol),t("wholeLineUpdateBefore",!0),t("theme","default",function(e){Go(e),Uo(e)},!0),t("keyMap","default",function(e,t,r){var n=uo(t),i=r!=Xs&&uo(r);i&&i.detach&&i.detach(e,n),n.attach&&n.attach(e,i||null)}),t("extraKeys",null),t("configureMouse",null),t("lineWrapping",!1,Ko,!0),t("gutters",[],function(e){Fn(e.options),Uo(e)},!0),t("fixedGutter",!0,function(e,t){e.display.gutters.style.left=t?wr(e.display)+"px":"0",e.refresh()},!0),t("coverGutterNextToScrollbar",!1,function(e){return en(e)},!0),t("scrollbarStyle","native",function(e){rn(e),en(e),e.display.scrollbars.setScrollTop(e.doc.scrollTop),e.display.scrollbars.setScrollLeft(e.doc.scrollLeft)},!0),t("lineNumbers",!1,function(e){Fn(e.options),Uo(e)},!0),t("firstLineNumber",1,Uo,!0),t("lineNumberFormatter",function(e){return e},Uo,!0),t("showCursorWhenSelecting",!1,kr,!0),t("resetSelectionOnContextMenu",!0),t("lineWiseCopyCut",!0),t("pasteLinesPerSelection",!0),t("readOnly",!1,function(e,t){"nocursor"==t&&(Fr(e),e.display.input.blur()),e.display.input.readOnlyChanged(t)}),t("disableInput",!1,function(e,t){t||e.display.input.reset()},!0),t("dragDrop",!0,Vo),t("allowDropFileTypes",null),t("cursorBlinkRate",530),t("cursorScrollMargin",0),t("cursorHeight",1,kr,!0),t("singleCursorHeightPerLine",!0,kr,!0),t("workTime",100),t("workDelay",100),t("flattenSpans",!0,Xn,!0),t("addModeClass",!1,Xn,!0),t("pollInterval",100),t("undoDepth",200,function(e,t){return e.doc.history.undoDepth=t}),t("historyEventDelay",1250),t("viewportMargin",10,function(e){return e.refresh()},!0),t("maxHighlightLength",1e4,Xn,!0),t("moveInputWithCursor",!0,function(e,t){t||e.display.input.resetPosition()}),t("tabindex",null,function(e,t){return e.display.input.getField().tabIndex=t||""}),t("autofocus",null),t("direction","ltr",function(e,t){return e.doc.setDirection(t)},!0)}(jo),function(e){var t=e.optionHandlers,r=e.helpers={};e.prototype={constructor:e,focus:function(){window.focus(),this.display.input.focus()},setOption:function(e,r){var n=this.options,i=n[e];n[e]==r&&"mode"!=e||(n[e]=r,t.hasOwnProperty(e)&&dn(this,t[e])(this,r,i),Te(this,"optionChange",this,e))},getOption:function(e){return this.options[e]},getDoc:function(){return this.doc},addKeyMap:function(e,t){this.state.keyMaps[t?"push":"unshift"](uo(e))},removeKeyMap:function(e){for(var t=this.state.keyMaps,r=0;r<t.length;++r)if(t[r]==e||t[r].name==e)return t.splice(r,1),!0},addOverlay:pn(function(t,r){var n=t.token?t:e.getMode(this.options,t);if(n.startState)throw new Error("Overlays may not be stateful.");m(this.state.overlays,{mode:n,modeSpec:t,opaque:r&&r.opaque,priority:r&&r.priority||0},function(e){return e.priority}),this.state.modeGen++,vn(this)}),removeOverlay:pn(function(e){for(var t=this,r=this.state.overlays,n=0;n<r.length;++n){var i=r[n].modeSpec;if(i==e||"string"==typeof e&&i.name==e)return r.splice(n,1),t.state.modeGen++,void vn(t)}}),indentLine:pn(function(e,t,r){"string"!=typeof t&&"number"!=typeof t&&(t=null==t?this.options.smartIndent?"smart":"prev":t?"add":"subtract"),H(this.doc,e)&&Yo(this,e,t,r)}),indentSelection:pn(function(e){for(var t=this,r=this.doc.sel.ranges,n=-1,i=0;i<r.length;i++){var o=r[i];if(o.empty())o.head.line>n&&(Yo(t,o.head.line,e,!0),n=o.head.line,i==t.doc.sel.primIndex&&jr(t));else{var l=o.from(),s=o.to(),a=Math.max(n,l.line);n=Math.min(t.lastLine(),s.line-(s.ch?0:1))+1;for(var u=a;u<n;++u)Yo(t,u,e);var c=t.doc.sel.ranges;0==l.ch&&r.length==c.length&&c[i].from().ch>0&&gi(t.doc,i,new Ts(l,c[i].to()),Gl)}}}),getTokenAt:function(e,t){return Je(this,e,t)},getLineTokens:function(e,t){return Je(this,E(e),t,!0)},getTokenTypeAt:function(e){e=U(this.doc,e);var t,r=_e(this,M(this.doc,e.line)),n=0,i=(r.length-1)/2,o=e.ch;if(0==o)t=r[2];else for(;;){var l=n+i>>1;if((l?r[2*l-1]:0)>=o)i=l;else{if(!(r[2*l+1]<o)){t=r[2*l+2];break}n=l+1}}var s=t?t.indexOf("overlay "):-1;return s<0?t:0==s?null:t.slice(0,s-1)},getModeAt:function(t){var r=this.doc.mode;return r.innerMode?e.innerMode(r,this.getTokenAt(t).state).mode:r},getHelper:function(e,t){return this.getHelpers(e,t)[0]},getHelpers:function(e,t){var n=this,i=[];if(!r.hasOwnProperty(t))return i;var o=r[t],l=this.getModeAt(e);if("string"==typeof l[t])o[l[t]]&&i.push(o[l[t]]);else if(l[t])for(var s=0;s<l[t].length;s++){var a=o[l[t][s]];a&&i.push(a)}else l.helperType&&o[l.helperType]?i.push(o[l.helperType]):o[l.name]&&i.push(o[l.name]);for(var u=0;u<o._global.length;u++){var c=o._global[u];c.pred(l,n)&&-1==h(i,c.val)&&i.push(c.val)}return i},getStateAfter:function(e,t){var r=this.doc;return e=G(r,null==e?r.first+r.size-1:e),$e(this,e+1,t).state},cursorCoords:function(e,t){var r,n=this.doc.sel.primary();return r=null==e?n.head:"object"==typeof e?U(this.doc,e):e?n.from():n.to(),sr(this,r,t||"page")},charCoords:function(e,t){return lr(this,U(this.doc,e),t||"page")},coordsChar:function(e,t){return e=or(this,e,t||"page"),cr(this,e.left,e.top)},lineAtHeight:function(e,t){return e=or(this,{top:e,left:0},t||"page").top,D(this.doc,e+this.display.viewOffset)},heightAtLine:function(e,t,r){var n,i=!1;if("number"==typeof e){var o=this.doc.first+this.doc.size-1;e<this.doc.first?e=this.doc.first:e>o&&(e=o,i=!0),n=M(this.doc,e)}else n=e;return ir(this,n,{top:0,left:0},t||"page",r||i).top+(i?this.doc.height-ye(n):0)},defaultTextHeight:function(){return mr(this.display)},defaultCharWidth:function(){return yr(this.display)},getViewport:function(){return{from:this.display.viewFrom,to:this.display.viewTo}},addWidget:function(e,t,r,n,i){var o=this.display,l=(e=sr(this,U(this.doc,e))).bottom,s=e.left;if(t.style.position="absolute",t.setAttribute("cm-ignore-events","true"),this.display.input.setUneditable(t),o.sizer.appendChild(t),"over"==n)l=e.top;else if("above"==n||"near"==n){var a=Math.max(o.wrapper.clientHeight,this.doc.height),u=Math.max(o.sizer.clientWidth,o.lineSpace.clientWidth);("above"==n||e.bottom+t.offsetHeight>a)&&e.top>t.offsetHeight?l=e.top-t.offsetHeight:e.bottom+t.offsetHeight<=a&&(l=e.bottom),s+t.offsetWidth>u&&(s=u-t.offsetWidth)}t.style.top=l+"px",t.style.left=t.style.right="","right"==i?(s=o.sizer.clientWidth-t.offsetWidth,t.style.right="0px"):("left"==i?s=0:"middle"==i&&(s=(o.sizer.clientWidth-t.offsetWidth)/2),t.style.left=s+"px"),r&&Ur(this,{left:s,top:l,right:s+t.offsetWidth,bottom:l+t.offsetHeight})},triggerOnKeyDown:pn(Lo),triggerOnKeyPress:pn(Mo),triggerOnKeyUp:To,triggerOnMouseDown:pn(Oo),execCommand:function(e){if(Bs.hasOwnProperty(e))return Bs[e].call(null,this)},triggerElectric:pn(function(e){Zo(this,e)}),findPosH:function(e,t,r,n){var i=this,o=1;t<0&&(o=-1,t=-t);for(var l=U(this.doc,e),s=0;s<t&&!(l=tl(i.doc,l,o,r,n)).hitSide;++s);return l},moveH:pn(function(e,t){var r=this;this.extendSelectionsBy(function(n){return r.display.shift||r.doc.extend||n.empty()?tl(r.doc,n.head,e,t,r.options.rtlMoveVisually):e<0?n.from():n.to()},Vl)}),deleteH:pn(function(e,t){var r=this.doc.sel,n=this.doc;r.somethingSelected()?n.replaceSelection("",null,"+delete"):co(this,function(r){var i=tl(n,r.head,e,t,!1);return e<0?{from:i,to:r.head}:{from:r.head,to:i}})}),findPosV:function(e,t,r,n){var i=this,o=1,l=n;t<0&&(o=-1,t=-t);for(var s=U(this.doc,e),a=0;a<t;++a){var u=sr(i,s,"div");if(null==l?l=u.left:u.left=l,(s=rl(i,u,o,r)).hitSide)break}return s},moveV:pn(function(e,t){var r=this,n=this.doc,i=[],o=!this.display.shift&&!n.extend&&n.sel.somethingSelected();if(n.extendSelectionsBy(function(l){if(o)return e<0?l.from():l.to();var s=sr(r,l.head,"div");null!=l.goalColumn&&(s.left=l.goalColumn),i.push(s.left);var a=rl(r,s,e,t);return"page"==t&&l==n.sel.primary()&&Kr(r,lr(r,a,"div").top-s.top),a},Vl),i.length)for(var l=0;l<n.sel.ranges.length;l++)n.sel.ranges[l].goalColumn=i[l]}),findWordAt:function(e){var t=M(this.doc,e.line).text,r=e.ch,n=e.ch;if(t){var i=this.getHelper(e,"wordChars");"before"!=e.sticky&&n!=t.length||!r?++n:--r;for(var o=t.charAt(r),l=x(o,i)?function(e){return x(e,i)}:/\s/.test(o)?function(e){return/\s/.test(e)}:function(e){return!/\s/.test(e)&&!x(e)};r>0&&l(t.charAt(r-1));)--r;for(;n<t.length&&l(t.charAt(n));)++n}return new Ts(E(e.line,r),E(e.line,n))},toggleOverwrite:function(e){null!=e&&e==this.state.overwrite||((this.state.overwrite=!this.state.overwrite)?s(this.display.cursorDiv,"CodeMirror-overwrite"):Fl(this.display.cursorDiv,"CodeMirror-overwrite"),Te(this,"overwriteToggle",this,this.state.overwrite))},hasFocus:function(){return this.display.input.getField()==l()},isReadOnly:function(){return!(!this.options.readOnly&&!this.doc.cantEdit)},scrollTo:pn(function(e,t){Xr(this,e,t)}),getScrollInfo:function(){var e=this.display.scroller;return{left:e.scrollLeft,top:e.scrollTop,height:e.scrollHeight-zt(this)-this.display.barHeight,width:e.scrollWidth-zt(this)-this.display.barWidth,clientHeight:Bt(this),clientWidth:Rt(this)}},scrollIntoView:pn(function(e,t){null==e?(e={from:this.doc.sel.primary().head,to:null},null==t&&(t=this.options.cursorScrollMargin)):"number"==typeof e?e={from:E(e,0),to:null}:null==e.from&&(e={from:e,to:null}),e.to||(e.to=e.from),e.margin=t||0,null!=e.from.line?Yr(this,e):$r(this,e.from,e.to,e.margin)}),setSize:pn(function(e,t){var r=this,n=function(e){return"number"==typeof e||/^\d+$/.test(String(e))?e+"px":e};null!=e&&(this.display.wrapper.style.width=n(e)),null!=t&&(this.display.wrapper.style.height=n(t)),this.options.lineWrapping&&Jt(this);var i=this.display.viewFrom;this.doc.iter(i,this.display.viewTo,function(e){if(e.widgets)for(var t=0;t<e.widgets.length;t++)if(e.widgets[t].noHScroll){mn(r,i,"widget");break}++i}),this.curOp.forceUpdate=!0,Te(this,"refresh",this)}),operation:function(e){return hn(this,e)},startOperation:function(){return nn(this)},endOperation:function(){return on(this)},refresh:pn(function(){var e=this.display.cachedTextHeight;vn(this),this.curOp.forceUpdate=!0,er(this),Xr(this,this.doc.scrollLeft,this.doc.scrollTop),Wn(this),(null==e||Math.abs(e-mr(this.display))>.5)&&Cr(this),Te(this,"refresh",this)}),swapDoc:pn(function(e){var t=this.doc;return t.cm=null,qn(this,e),er(this),this.display.input.reset(),Xr(this,e.scrollLeft,e.scrollTop),this.curOp.forceScroll=!0,bt(this,"swapDoc",this,t),t}),getInputField:function(){return this.display.input.getField()},getWrapperElement:function(){return this.display.wrapper},getScrollerElement:function(){return this.display.scroller},getGutterElement:function(){return this.display.gutters}},Ae(e),e.registerHelper=function(t,n,i){r.hasOwnProperty(t)||(r[t]=e[t]={_global:[]}),r[t][n]=i},e.registerGlobalHelper=function(t,n,i,o){e.registerHelper(t,n,o),r[t]._global.push({pred:i,val:o})}}(jo);var Js="iter insert remove copy getEditor constructor".split(" ");for(var ea in Ds.prototype)Ds.prototype.hasOwnProperty(ea)&&h(Js,ea)<0&&(jo.prototype[ea]=function(e){return function(){return e.apply(this.doc,arguments)}}(Ds.prototype[ea]));return Ae(Ds),jo.inputStyles={textarea:Qs,contenteditable:Zs},jo.defineMode=function(e){jo.defaults.mode||"null"==e||(jo.defaults.mode=e),Be.apply(this,arguments)},jo.defineMIME=function(e,t){os[e]=t},jo.defineMode("null",function(){return{token:function(e){return e.skipToEnd()}}}),jo.defineMIME("text/plain","null"),jo.defineExtension=function(e,t){jo.prototype[e]=t},jo.defineDocExtension=function(e,t){Ds.prototype[e]=t},jo.fromTextArea=function(e,t){function r(){e.value=a.getValue()}if(t=t?c(t):{},t.value=e.value,!t.tabindex&&e.tabIndex&&(t.tabindex=e.tabIndex),!t.placeholder&&e.placeholder&&(t.placeholder=e.placeholder),null==t.autofocus){var n=l();t.autofocus=n==e||null!=e.getAttribute("autofocus")&&n==document.body}var i;if(e.form&&(Ql(e.form,"submit",r),!t.leaveSubmitMethodAlone)){var o=e.form;i=o.submit;try{var s=o.submit=function(){r(),o.submit=i,o.submit(),o.submit=s}}catch(e){}}t.finishInit=function(t){t.save=r,t.getTextArea=function(){return e},t.toTextArea=function(){t.toTextArea=isNaN,r(),e.parentNode.removeChild(t.getWrapperElement()),e.style.display="",e.form&&(ke(e.form,"submit",r),"function"==typeof e.form.submit&&(e.form.submit=i))}},e.style.display="none";var a=jo(function(t){return e.parentNode.insertBefore(t,e.nextSibling)},t);return a},function(e){e.off=ke,e.on=Ql,e.wheelEventPixels=Pn,e.Doc=Ds,e.splitLines=es,e.countColumn=f,e.findColumn=d,e.isWordChar=w,e.Pass=Bl,e.signal=Te,e.Line=fs,e.changeEnd=Bn,e.scrollbarModel=ws,e.Pos=E,e.cmpPos=P,e.modes=is,e.mimeModes=os,e.resolveMode=Ge,e.getMode=Ue,e.modeExtensions=ls,e.extendMode=Ve,e.copyState=Ke,e.startState=Xe,e.innerMode=je,e.commands=Bs,e.keyMap=Rs,e.keyName=ao,e.isModifierKey=lo,e.lookupKey=oo,e.normalizeKeyMap=io,e.StringStream=ss,e.SharedTextMarker=As,e.TextMarker=Os,e.LineWidget=Ms,e.e_preventDefault=We,e.e_stopPropagation=De,e.e_stop=Fe,e.addClass=s,e.contains=o,e.rmClass=Fl,e.keyNames=Es}(jo),jo.version="5.30.0",jo});
      !function(e){"object"==typeof exports&&"object"==typeof module?e(require("../../lib/codemirror")):"function"==typeof define&&define.amd?define(["../../lib/codemirror"],e):e(CodeMirror)}(function(e){"use strict";function t(e,t,n,r,o,a){this.indented=e,this.column=t,this.type=n,this.info=r,this.align=o,this.prev=a}function n(e,n,r,o){var a=e.indented;return e.context&&"statement"==e.context.type&&"statement"!=r&&(a=e.context.indented),e.context=new t(a,n,r,o,null,e.context)}function r(e){var t=e.context.type;return")"!=t&&"]"!=t&&"}"!=t||(e.indented=e.context.indented),e.context=e.context.prev}function o(e,t,n){return"variable"==t.prevToken||"type"==t.prevToken||(!!/\S(?:[^- ]>|[*\]])\s*$|\*$/.test(e.string.slice(0,n))||(!(!t.typeAtEndOfLine||e.column()!=e.indentation())||void 0))}function a(e){for(;;){if(!e||"top"==e.type)return!0;if("}"==e.type&&"namespace"!=e.prev.info)return!1;e=e.prev}}function i(e){for(var t={},n=e.split(" "),r=0;r<n.length;++r)t[n[r]]=!0;return t}function l(e,t){return"function"==typeof e?e(t):e.propertyIsEnumerable(t)}function s(e,t){if(!t.startOfLine)return!1;for(var n,r=null;n=e.peek();){if("\\"==n&&e.match(/^.$/)){r=s;break}if("/"==n&&e.match(/^\/[\/\*]/,!1))break;e.next()}return t.tokenize=r,"meta"}function c(e,t){return"type"==t.prevToken&&"type"}function u(e){return e.eatWhile(/[\w\.']/),"number"}function d(e,t){if(e.backUp(1),e.match(/(R|u8R|uR|UR|LR)/)){var n=e.match(/"([^\s\\()]{0,16})\(/);return!!n&&(t.cpp11RawStringDelim=n[1],t.tokenize=m,m(e,t))}return e.match(/(u8|u|U|L)/)?!!e.match(/["']/,!1)&&"string":(e.next(),!1)}function f(e){var t=/(\w+)::~?(\w+)$/.exec(e);return t&&t[1]==t[2]}function p(e,t){for(var n;null!=(n=e.next());)if('"'==n&&!e.eat('"')){t.tokenize=null;break}return"string"}function m(e,t){var n=t.cpp11RawStringDelim.replace(/[^\w\s]/g,"\\$&");return e.match(new RegExp(".*?\\)"+n+'"'))?t.tokenize=null:e.skipToEnd(),"string"}function h(t,n){function r(e){if(e)for(var t in e)e.hasOwnProperty(t)&&o.push(t)}"string"==typeof t&&(t=[t]);var o=[];r(n.keywords),r(n.types),r(n.builtin),r(n.atoms),o.length&&(n.helperType=t[0],e.registerHelper("hintWords",t[0],o));for(var a=0;a<t.length;++a)e.defineMIME(t[a],n)}function g(e,t){for(var n=!1;!e.eol();){if(!n&&e.match('"""')){t.tokenize=null;break}n="\\"==e.next()&&!n}return"string"}function y(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!e&&!o&&t.match('"')){a=!0;break}if(e&&t.match('"""')){a=!0;break}r=t.next(),!o&&"$"==r&&t.match("{")&&t.skipTo("}"),o=!o&&"\\"==r&&!e}return!a&&e||(n.tokenize=null),"string"}}function x(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!o&&t.match('"')&&("single"==e||t.match('""'))){a=!0;break}if(!o&&t.match("``")){w=x(e),a=!0;break}r=t.next(),o="single"==e&&!o&&"\\"==r}return a&&(n.tokenize=null),"string"}}e.defineMode("clike",function(i,s){function c(e,t){var n=e.next();if(S[n]){var r=S[n](e,t);if(!1!==r)return r}if('"'==n||"'"==n)return t.tokenize=u(n),t.tokenize(e,t);if(D.test(n))return p=n,null;if(L.test(n)){if(e.backUp(1),e.match(I))return"number";e.next()}if("/"==n){if(e.eat("*"))return t.tokenize=d,d(e,t);if(e.eat("/"))return e.skipToEnd(),"comment"}if(F.test(n)){for(;!e.match(/^\/[\/*]/,!1)&&e.eat(F););return"operator"}if(e.eatWhile(z),P)for(;e.match(P);)e.eatWhile(z);var o=e.current();return l(x,o)?(l(w,o)&&(p="newstatement"),l(v,o)&&(m=!0),"keyword"):l(b,o)?"type":l(k,o)?(l(w,o)&&(p="newstatement"),"builtin"):l(_,o)?"atom":"variable"}function u(e){return function(t,n){for(var r,o=!1,a=!1;null!=(r=t.next());){if(r==e&&!o){a=!0;break}o=!o&&"\\"==r}return(a||!o&&!C)&&(n.tokenize=null),"string"}}function d(e,t){for(var n,r=!1;n=e.next();){if("/"==n&&r){t.tokenize=null;break}r="*"==n}return"comment"}function f(e,t){s.typeFirstDefinitions&&e.eol()&&a(t.context)&&(t.typeAtEndOfLine=o(e,t,e.pos))}var p,m,h=i.indentUnit,g=s.statementIndentUnit||h,y=s.dontAlignCalls,x=s.keywords||{},b=s.types||{},k=s.builtin||{},w=s.blockKeywords||{},v=s.defKeywords||{},_=s.atoms||{},S=s.hooks||{},C=s.multiLineStrings,T=!1!==s.indentStatements,M=!1!==s.indentSwitch,P=s.namespaceSeparator,D=s.isPunctuationChar||/[\[\]{}\(\),;\:\.]/,L=s.numberStart||/[\d\.]/,I=s.number||/^(?:0x[a-f\d]+|0b[01]+|(?:\d+\.?\d*|\.\d+)(?:e[-+]?\d+)?)(u|ll?|l|f)?/i,F=s.isOperatorChar||/[+\-*&%=<>!?|\/]/,z=s.isIdentifierChar||/[\w\$_\xa1-\uffff]/;return{startState:function(e){return{tokenize:null,context:new t((e||0)-h,0,"top",null,!1),indented:0,startOfLine:!0,prevToken:null}},token:function(e,t){var i=t.context;if(e.sol()&&(null==i.align&&(i.align=!1),t.indented=e.indentation(),t.startOfLine=!0),e.eatSpace())return f(e,t),null;p=m=null;var l=(t.tokenize||c)(e,t);if("comment"==l||"meta"==l)return l;if(null==i.align&&(i.align=!0),";"==p||":"==p||","==p&&e.match(/^\s*(?:\/\/.*)?$/,!1))for(;"statement"==t.context.type;)r(t);else if("{"==p)n(t,e.column(),"}");else if("["==p)n(t,e.column(),"]");else if("("==p)n(t,e.column(),")");else if("}"==p){for(;"statement"==i.type;)i=r(t);for("}"==i.type&&(i=r(t));"statement"==i.type;)i=r(t)}else p==i.type?r(t):T&&(("}"==i.type||"top"==i.type)&&";"!=p||"statement"==i.type&&"newstatement"==p)&&n(t,e.column(),"statement",e.current());if("variable"==l&&("def"==t.prevToken||s.typeFirstDefinitions&&o(e,t,e.start)&&a(t.context)&&e.match(/^\s*\(/,!1))&&(l="def"),S.token){var u=S.token(e,t,l);void 0!==u&&(l=u)}return"def"==l&&!1===s.styleDefs&&(l="variable"),t.startOfLine=!1,t.prevToken=m?"def":l||p,f(e,t),l},indent:function(t,n){if(t.tokenize!=c&&null!=t.tokenize||t.typeAtEndOfLine)return e.Pass;var r=t.context,o=n&&n.charAt(0);if("statement"==r.type&&"}"==o&&(r=r.prev),s.dontIndentStatements)for(;"statement"==r.type&&s.dontIndentStatements.test(r.info);)r=r.prev;if(S.indent){var a=S.indent(t,r,n);if("number"==typeof a)return a}var i=o==r.type,l=r.prev&&"switch"==r.prev.info;if(s.allmanIndentation&&/[{(]/.test(o)){for(;"top"!=r.type&&"}"!=r.type;)r=r.prev;return r.indented}return"statement"==r.type?r.indented+("{"==o?0:g):!r.align||y&&")"==r.type?")"!=r.type||i?r.indented+(i?0:h)+(i||!l||/^(?:case|default)\b/.test(n)?0:h):r.indented+g:r.column+(i?0:1)},electricInput:M?/^\s*(?:case .*?:|default:|\{\}?|\})$/:/^\s*[{}]$/,blockCommentStart:"/*",blockCommentEnd:"*/",lineComment:"//",fold:"brace"}});var b="auto if break case register continue return default do sizeof static else struct switch extern typedef union for goto while enum const volatile",k="int long char short double float unsigned signed void size_t ptrdiff_t";h(["text/x-csrc","text/x-c","text/x-chdr"],{name:"clike",keywords:i(b),types:i(k+" bool _Complex _Bool float_t double_t intptr_t intmax_t int8_t int16_t int32_t int64_t uintptr_t uintmax_t uint8_t uint16_t uint32_t uint64_t"),blockKeywords:i("case do else for if switch while struct"),defKeywords:i("struct"),typeFirstDefinitions:!0,atoms:i("null true false"),hooks:{"#":s,"*":c},modeProps:{fold:["brace","include"]}}),h(["text/x-c++src","text/x-c++hdr"],{name:"clike",keywords:i(b+" asm dynamic_cast namespace reinterpret_cast try explicit new static_cast typeid catch operator template typename class friend private this using const_cast inline public throw virtual delete mutable protected alignas alignof constexpr decltype nullptr noexcept thread_local final static_assert override"),types:i(k+" bool wchar_t"),blockKeywords:i("catch class do else finally for if struct switch try while"),defKeywords:i("class namespace struct enum union"),typeFirstDefinitions:!0,atoms:i("true false null"),dontIndentStatements:/^template$/,isIdentifierChar:/[\w\$_~\xa1-\uffff]/,hooks:{"#":s,"*":c,u:d,U:d,L:d,R:d,0:u,1:u,2:u,3:u,4:u,5:u,6:u,7:u,8:u,9:u,token:function(e,t,n){if("variable"==n&&"("==e.peek()&&(";"==t.prevToken||null==t.prevToken||"}"==t.prevToken)&&f(e.current()))return"def"}},namespaceSeparator:"::",modeProps:{fold:["brace","include"]}}),h("text/x-java",{name:"clike",keywords:i("abstract assert break case catch class const continue default do else enum extends final finally float for goto if implements import instanceof interface native new package private protected public return static strictfp super switch synchronized this throw throws transient try volatile while @interface"),types:i("byte short int long float double boolean char void Boolean Byte Character Double Float Integer Long Number Object Short String StringBuffer StringBuilder Void"),blockKeywords:i("catch class do else finally for if switch try while"),defKeywords:i("class interface package enum @interface"),typeFirstDefinitions:!0,atoms:i("true false null"),number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,hooks:{"@":function(e){return!e.match("interface",!1)&&(e.eatWhile(/[\w\$_]/),"meta")}},modeProps:{fold:["brace","import"]}}),h("text/x-csharp",{name:"clike",keywords:i("abstract as async await base break case catch checked class const continue default delegate do else enum event explicit extern finally fixed for foreach goto if implicit in interface internal is lock namespace new operator out override params private protected public readonly ref return sealed sizeof stackalloc static struct switch this throw try typeof unchecked unsafe using virtual void volatile while add alias ascending descending dynamic from get global group into join let orderby partial remove select set value var yield"),types:i("Action Boolean Byte Char DateTime DateTimeOffset Decimal Double Func Guid Int16 Int32 Int64 Object SByte Single String Task TimeSpan UInt16 UInt32 UInt64 bool byte char decimal double short int long object sbyte float string ushort uint ulong"),blockKeywords:i("catch class do else finally for foreach if struct switch try while"),defKeywords:i("class interface namespace struct var"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"@":function(e,t){return e.eat('"')?(t.tokenize=p,p(e,t)):(e.eatWhile(/[\w\$_]/),"meta")}}}),h("text/x-scala",{name:"clike",keywords:i("abstract case catch class def do else extends final finally for forSome if implicit import lazy match new null object override package private protected return sealed super this throw trait try type val var while with yield _ assert assume require print println printf readLine readBoolean readByte readShort readChar readInt readLong readFloat readDouble"),types:i("AnyVal App Application Array BufferedIterator BigDecimal BigInt Char Console Either Enumeration Equiv Error Exception Fractional Function IndexedSeq Int Integral Iterable Iterator List Map Numeric Nil NotNull Option Ordered Ordering PartialFunction PartialOrdering Product Proxy Range Responder Seq Serializable Set Specializable Stream StringBuilder StringContext Symbol Throwable Traversable TraversableOnce Tuple Unit Vector Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),multiLineStrings:!0,blockKeywords:i("catch class enum do else finally for forSome if match switch try while"),defKeywords:i("class enum def object package trait type val var"),atoms:i("true false null"),indentStatements:!1,indentSwitch:!1,isOperatorChar:/[+\-*&%=<>!?|\/#:@]/,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return!!e.match('""')&&(t.tokenize=g,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},"=":function(e,n){var r=n.context;return!("}"!=r.type||!r.align||!e.eat(">"))&&(n.context=new t(r.indented,r.column,r.type,r.info,null,r.prev),"operator")}},modeProps:{closeBrackets:{triples:'"'}}}),h("text/x-kotlin",{name:"clike",keywords:i("package as typealias class interface this super val var fun for is in This throw return break continue object if else while do try when !in !is as? file import where by get set abstract enum open inner override private public internal protected catch finally out final vararg reified dynamic companion constructor init sealed field property receiver param sparam lateinit data inline noinline tailrec external annotation crossinline const operator infix suspend"),types:i("Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),intendSwitch:!1,indentStatements:!1,multiLineStrings:!0,number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,blockKeywords:i("catch class do else finally for if where try while enum"),defKeywords:i("class val var object package interface fun"),atoms:i("true false null this"),hooks:{'"':function(e,t){return t.tokenize=y(e.match('""')),t.tokenize(e,t)}},modeProps:{closeBrackets:{triples:'"'}}}),h(["x-shader/x-vertex","x-shader/x-fragment"],{name:"clike",keywords:i("sampler1D sampler2D sampler3D samplerCube sampler1DShadow sampler2DShadow const attribute uniform varying break continue discard return for while do if else struct in out inout"),types:i("float int bool void vec2 vec3 vec4 ivec2 ivec3 ivec4 bvec2 bvec3 bvec4 mat2 mat3 mat4"),blockKeywords:i("for while do if else struct"),builtin:i("radians degrees sin cos tan asin acos atan pow exp log exp2 sqrt inversesqrt abs sign floor ceil fract mod min max clamp mix step smoothstep length distance dot cross normalize ftransform faceforward reflect refract matrixCompMult lessThan lessThanEqual greaterThan greaterThanEqual equal notEqual any all not texture1D texture1DProj texture1DLod texture1DProjLod texture2D texture2DProj texture2DLod texture2DProjLod texture3D texture3DProj texture3DLod texture3DProjLod textureCube textureCubeLod shadow1D shadow2D shadow1DProj shadow2DProj shadow1DLod shadow2DLod shadow1DProjLod shadow2DProjLod dFdx dFdy fwidth noise1 noise2 noise3 noise4"),atoms:i("true false gl_FragColor gl_SecondaryColor gl_Normal gl_Vertex gl_MultiTexCoord0 gl_MultiTexCoord1 gl_MultiTexCoord2 gl_MultiTexCoord3 gl_MultiTexCoord4 gl_MultiTexCoord5 gl_MultiTexCoord6 gl_MultiTexCoord7 gl_FogCoord gl_PointCoord gl_Position gl_PointSize gl_ClipVertex gl_FrontColor gl_BackColor gl_FrontSecondaryColor gl_BackSecondaryColor gl_TexCoord gl_FogFragCoord gl_FragCoord gl_FrontFacing gl_FragData gl_FragDepth gl_ModelViewMatrix gl_ProjectionMatrix gl_ModelViewProjectionMatrix gl_TextureMatrix gl_NormalMatrix gl_ModelViewMatrixInverse gl_ProjectionMatrixInverse gl_ModelViewProjectionMatrixInverse gl_TexureMatrixTranspose gl_ModelViewMatrixInverseTranspose gl_ProjectionMatrixInverseTranspose gl_ModelViewProjectionMatrixInverseTranspose gl_TextureMatrixInverseTranspose gl_NormalScale gl_DepthRange gl_ClipPlane gl_Point gl_FrontMaterial gl_BackMaterial gl_LightSource gl_LightModel gl_FrontLightModelProduct gl_BackLightModelProduct gl_TextureColor gl_EyePlaneS gl_EyePlaneT gl_EyePlaneR gl_EyePlaneQ gl_FogParameters gl_MaxLights gl_MaxClipPlanes gl_MaxTextureUnits gl_MaxTextureCoords gl_MaxVertexAttribs gl_MaxVertexUniformComponents gl_MaxVaryingFloats gl_MaxVertexTextureImageUnits gl_MaxTextureImageUnits gl_MaxFragmentUniformComponents gl_MaxCombineTextureImageUnits gl_MaxDrawBuffers"),indentSwitch:!1,hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-nesc",{name:"clike",keywords:i(b+"as atomic async call command component components configuration event generic implementation includes interface module new norace nx_struct nx_union post provides signal task uses abstract extends"),types:i(k),blockKeywords:i("case do else for if switch while struct"),atoms:i("null true false"),hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-objectivec",{name:"clike",keywords:i(b+"inline restrict _Bool _Complex _Imaginary BOOL Class bycopy byref id IMP in inout nil oneway out Protocol SEL self super atomic nonatomic retain copy readwrite readonly"),types:i(k),atoms:i("YES NO NULL NILL ON OFF true false"),hooks:{"@":function(e){return e.eatWhile(/[\w\$]/),"keyword"},"#":s,indent:function(e,t,n){if("statement"==t.type&&/^@\w/.test(n))return t.indented}},modeProps:{fold:"brace"}}),h("text/x-squirrel",{name:"clike",keywords:i("base break clone continue const default delete enum extends function in class foreach local resume return this throw typeof yield constructor instanceof static"),types:i(k),blockKeywords:i("case catch class else for foreach if switch try while"),defKeywords:i("function local class"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"#":s},modeProps:{fold:["brace","include"]}});var w=null;h("text/x-ceylon",{name:"clike",keywords:i("abstracts alias assembly assert assign break case catch class continue dynamic else exists extends finally for function given if import in interface is let module new nonempty object of out outer package return satisfies super switch then this throw try value void while"),types:function(e){var t=e.charAt(0);return t===t.toUpperCase()&&t!==t.toLowerCase()},blockKeywords:i("case catch class dynamic else finally for function if interface module new object switch try while"),defKeywords:i("class dynamic function interface module object package value"),builtin:i("abstract actual aliased annotation by default deprecated doc final formal late license native optional sealed see serializable shared suppressWarnings tagged throws variable"),isPunctuationChar:/[\[\]{}\(\),;\:\.`]/,isOperatorChar:/[+\-*&%=<>!?|^~:\/]/,numberStart:/[\d#$]/,number:/^(?:#[\da-fA-F_]+|\$[01_]+|[\d_]+[kMGTPmunpf]?|[\d_]+\.[\d_]+(?:[eE][-+]?\d+|[kMGTPmunpf]|)|)/i,multiLineStrings:!0,typeFirstDefinitions:!0,atoms:i("true false null larger smaller equal empty finished"),indentSwitch:!1,styleDefs:!1,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return t.tokenize=x(e.match('""')?"triple":"single"),t.tokenize(e,t)},"`":function(e,t){return!(!w||!e.match("`"))&&(t.tokenize=w,w=null,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},token:function(e,t,n){if(("variable"==n||"type"==n)&&"."==t.prevToken)return"variable-2"}},modeProps:{fold:["brace","import"],closeBrackets:{triples:'"'}}})});
      // -------------------------------------------------------------------------
//  Part of the CodeChecker project, under the Apache License v2.0 with
//  LLVM Exceptions. See LICENSE for license information.
//  SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
// -------------------------------------------------------------------------

var BugViewer = {
  _files : [],
  _reports : [],
  _lineWidgets : [],
  _navigationMenuItems : [],
  _sourceFileData : null,
  _currentReport : null,
  _lastBugEvent  : null,

  init : function (files, reports) {
    this._files = files;
    this._reports = reports;

    this.initEscapeChars();
  },

  initEscapeChars : function () {
    this.escapeChars = {
      ' ' : 'nbsp',
      '<' : 'lt',
      '>' : 'gt',
      '"' : 'quot',
      '&' : 'amp'
    };

    var regexString = '[';
    for (var key in this.escapeChars) {
      regexString += key;
    }
    regexString += ']';

    this.escapeRegExp = new RegExp( regexString, 'g');
  },

  escapeHTML : function (str) {
    var that = this;

    return str.replace(this.escapeRegExp, function (m) {
      return '&' + that.escapeChars[m] + ';';
    });
  },

  initByUrl : function () {
    if (!this._reports) return;

    var state = {};
    window.location.hash.substr(1).split('&').forEach(function (s) {
      var parts = s.split('=');
      state[parts[0]] = parts[1];
    });

    for (var key in this._reports) {
      var report = this._reports[key];
      if (report.reportHash === state['reportHash']) {
        this.navigate(report);
        return;
      }
    }

    this.navigate(this._reports[0]);
  },

  create : function () {
    this._content = document.getElementById('editor-wrapper');
    this._filepath = document.getElementById('file-path');
    this._checkerName = document.getElementById('checker-name');
    this._reviewStatusWrapper =
      document.getElementById('review-status-wrapper');
    this._reviewStatus = document.getElementById('review-status');
    this._editor = document.getElementById('editor');

    this._codeMirror = CodeMirror(this._editor, {
      mode: 'text/x-c++src',
      matchBrackets : true,
      lineNumbers : true,
      readOnly : true,
      foldGutter : true,
      extraKeys : {},
      viewportMargin : 100
    });

    this._createNavigationMenu();
  },

  navigate : function (report, item) {
    if (!item) {
      var items = this._navigationMenuItems.filter(function (navItem) {
        return navItem.report.reportHash === report.reportHash;
      });

      if (!items.length) return;

      item = items[0].widget;
    }

    this._selectedReport.classList.remove('active');
    this._selectedReport = item;
    this._selectedReport.classList.add('active');
    this.setReport(report);
  },

  _createNavigationMenu : function () {
    var that = this;

    var nav = document.getElementById('report-nav');
    var list = document.createElement('ul');
    this._reports.forEach(function (report) {
      var events = report['events'];
      var lastBugEvent = events[events.length - 1];
      var item = document.createElement('li');

      var severity = document.createElement('i');
      severity.className = 'severity-' + report.severity.toLowerCase();

      item.appendChild(severity);
      item.appendChild(document.createTextNode(lastBugEvent.message));

      item.addEventListener('click', function () {
        that.navigate(report, item);
      })
      list.appendChild(item);
      that._navigationMenuItems.push({ report : report, widget : item });
    });

    if (!this._selectedReport && list.childNodes.length) {
      this._selectedReport = list.childNodes[0];
      this._selectedReport.classList.add('active');
    }

    nav.appendChild(list);
  },

  setReport : function (report) {
    this._currentReport = report;
    var events = report['events'];
    var lastBugEvent = events[events.length - 1];
    this.setCurrentBugEvent(lastBugEvent, events.length - 1);
    this.setCheckerName(report.checkerName);
    this.setReviewStatus(report.reviewStatus);

    window.location.hash = '#reportHash=' + report.reportHash;
  },

  setCurrentBugEvent : function (event, idx) {
    this._currentBugEvent = event;
    this.setSourceFileData(this._files[event.location.file]);
    this.drawBugPath();

    this.jumpTo(event.location.line, 0);
    this.highlightBugEvent(event, idx);
  },

  highlightBugEvent : function (event, idx) {
    this._lineWidgets.forEach(function (widget) {
      var lineIdx = widget.node.getAttribute('idx');
      if (parseInt(lineIdx) === idx) {
        widget.node.classList.add('current');
      }
    });
  },

  setCheckerName : function (checkerName) {
    this._checkerName.innerHTML = checkerName;
  },

  setReviewStatus : function (status) {
    if (status) {
      var className =
        'review-status-' + status.toLowerCase().split(' ').join('-');
      this._reviewStatus.className = "review-status " + className;

      this._reviewStatus.innerHTML = status;
      this._reviewStatusWrapper.style.display = 'block';
    } else {
      this._reviewStatusWrapper.style.display = 'none';
    }
  },

  setSourceFileData : function (file) {
    if (this._sourceFileData && file.id === this._sourceFileData.id) {
      return;
    }

    this._sourceFileData = file;
    this._filepath.innerHTML = file.path;
    this._codeMirror.doc.setValue(file.content);
    this._refresh();
  },

  _refresh : function () {
    var that = this;
    setTimeout(function () {
      var fullHeight = parseInt(that._content.clientHeight);
      var headerHeight = that._filepath.clientHeight;

      that._codeMirror.setSize('auto', fullHeight - headerHeight);
      that._codeMirror.refresh();
    }, 200);
  },

  clearBubbles : function () {
    this._lineWidgets.forEach(function (widget) { widget.clear(); });
    this._lineWidgets = [];
  },

  getMessage : function (event, kind) {
    if (kind === 'macro') {
      var name = 'macro expansion' + (event.name ? ': ' + event.name : '');

      return '<span class="tag macro">' + name + '</span>'
        + this.escapeHTML(event.expansion).replace(/(?:\r\n|\r|\n)/g, '<br>');
    } else if (kind === 'note') {
      return '<span class="tag note">note</span>'
        +  this.escapeHTML(event.message).replace(/(?:\r\n|\r|\n)/g, '<br>');
    }
  },

  addExtraPathEvents : function (events, kind) {
    var that = this;

    if (!events) {
      return;
    }

    events.forEach(function (event) {
      if (event.location.file !== that._currentBugEvent.location.file) {
        return;
      }

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + kind);

      var msg = document.createElement('span');
      msg.innerHTML = that.getMessage(event, kind);
      element.appendChild(msg);

      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  drawBugPath : function () {
    var that = this;

    this.clearBubbles();

    this.addExtraPathEvents(this._currentReport.macros, 'macro');
    this.addExtraPathEvents(this._currentReport.notes, 'note');

    // Processing bug path events.
    var currentEvents = this._currentReport.events;
    currentEvents.forEach(function (event, step) {
      if (event.location.file !== that._currentBugEvent.location.file)
        return;

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';
      var type = step === currentEvents.length - 1 ? 'error' : 'info';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + type);
      element.setAttribute('idx', step);

      var enumeration = document.createElement('span');
      enumeration.setAttribute('class', 'checker-enum ' + type);
      enumeration.innerHTML = step + 1;

      if (currentEvents.length > 1)
        element.appendChild(enumeration);

      var prevBugEvent = step - 1;
      if (step > 0) {
        var prevBug = document.createElement('span');
        prevBug.setAttribute('class', 'arrow left-arrow');
        prevBug.addEventListener('click', function () {
          var event = currentEvents[prevBugEvent];
          that.setCurrentBugEvent(event, prevBugEvent);
        });
        element.appendChild(prevBug);
      }

      var msg = document.createElement('span');
      msg.innerHTML = that.escapeHTML(event.message)
        .replace(/(?:\r\n|\r|\n)/g, '<br>');

      element.appendChild(msg);

      var nextBugEvent = step + 1;
      if (nextBugEvent < currentEvents.length) {
        var nextBug = document.createElement('span');
        nextBug.setAttribute('class', 'arrow right-arrow');
        nextBug.addEventListener('click', function () {
          var event = currentEvents[nextBugEvent];
          that.setCurrentBugEvent(event, nextBugEvent);
        });
        element.appendChild(nextBug);
      }


      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  jumpTo : function (line, column) {
    var that = this;

    setTimeout(function () {
      var selPosPixel
        = that._codeMirror.charCoords({ line : line, ch : column }, 'local');
      var editorSize = {
        width  : that._editor.clientWidth,
        height : that._editor.clientHeight
      };

      that._codeMirror.scrollIntoView({
        top    : selPosPixel.top - 100,
        bottom : selPosPixel.top + editorSize.height - 150,
        left   : selPosPixel.left < editorSize.width - 100
               ? 0
               : selPosPixel.left - 50,
        right  : selPosPixel.left < editorSize.width - 100
               ? 10
               : selPosPixel.left + editorSize.width - 100
      });
    }, 0);
  }
}


      var data = {"files": {"18": {"id": 18, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/SparseBitVector.h", "content": "//===- llvm/ADT/SparseBitVector.h - Efficient Sparse BitVector --*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// This file defines the SparseBitVector class.  See the doxygen comment for\n// SparseBitVector for more details on the algorithm used.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_ADT_SPARSEBITVECTOR_H\n#define LLVM_ADT_SPARSEBITVECTOR_H\n\n#include \"llvm/Support/ErrorHandling.h\"\n#include \"llvm/Support/MathExtras.h\"\n#include \"llvm/Support/raw_ostream.h\"\n#include <cassert>\n#include <climits>\n#include <cstring>\n#include <iterator>\n#include <list>\n\nnamespace llvm {\n\n/// SparseBitVector is an implementation of a bitvector that is sparse by only\n/// storing the elements that have non-zero bits set.  In order to make this\n/// fast for the most common cases, SparseBitVector is implemented as a linked\n/// list of SparseBitVectorElements.  We maintain a pointer to the last\n/// SparseBitVectorElement accessed (in the form of a list iterator), in order\n/// to make multiple in-order test/set constant time after the first one is\n/// executed.  Note that using vectors to store SparseBitVectorElement's does\n/// not work out very well because it causes insertion in the middle to take\n/// enormous amounts of time with a large amount of bits.  Other structures that\n/// have better worst cases for insertion in the middle (various balanced trees,\n/// etc) do not perform as well in practice as a linked list with this iterator\n/// kept up to date.  They are also significantly more memory intensive.\n\ntemplate <unsigned ElementSize = 128> struct SparseBitVectorElement {\npublic:\n  using BitWord = unsigned long;\n  using size_type = unsigned;\n  enum {\n    BITWORD_SIZE = sizeof(BitWord) * CHAR_BIT,\n    BITWORDS_PER_ELEMENT = (ElementSize + BITWORD_SIZE - 1) / BITWORD_SIZE,\n    BITS_PER_ELEMENT = ElementSize\n  };\n\nprivate:\n  // Index of Element in terms of where first bit starts.\n  unsigned ElementIndex;\n  BitWord Bits[BITWORDS_PER_ELEMENT];\n\n  SparseBitVectorElement() {\n    ElementIndex = ~0U;\n    memset(&Bits[0], 0, sizeof (BitWord) * BITWORDS_PER_ELEMENT);\n  }\n\npublic:\n  explicit SparseBitVectorElement(unsigned Idx) {\n    ElementIndex = Idx;\n    memset(&Bits[0], 0, sizeof (BitWord) * BITWORDS_PER_ELEMENT);\n  }\n\n  // Comparison.\n  bool operator==(const SparseBitVectorElement &RHS) const {\n    if (ElementIndex != RHS.ElementIndex)\n      return false;\n    for (unsigned i = 0; i < BITWORDS_PER_ELEMENT; ++i)\n      if (Bits[i] != RHS.Bits[i])\n        return false;\n    return true;\n  }\n\n  bool operator!=(const SparseBitVectorElement &RHS) const {\n    return !(*this == RHS);\n  }\n\n  // Return the bits that make up word Idx in our element.\n  BitWord word(unsigned Idx) const {\n    assert(Idx < BITWORDS_PER_ELEMENT);\n    return Bits[Idx];\n  }\n\n  unsigned index() const {\n    return ElementIndex;\n  }\n\n  bool empty() const {\n    for (unsigned i = 0; i < BITWORDS_PER_ELEMENT; ++i)\n      if (Bits[i])\n        return false;\n    return true;\n  }\n\n  void set(unsigned Idx) {\n    Bits[Idx / BITWORD_SIZE] |= 1L << (Idx % BITWORD_SIZE);\n  }\n\n  bool test_and_set(unsigned Idx) {\n    bool old = test(Idx);\n    if (!old) {\n      set(Idx);\n      return true;\n    }\n    return false;\n  }\n\n  void reset(unsigned Idx) {\n    Bits[Idx / BITWORD_SIZE] &= ~(1L << (Idx % BITWORD_SIZE));\n  }\n\n  bool test(unsigned Idx) const {\n    return Bits[Idx / BITWORD_SIZE] & (1L << (Idx % BITWORD_SIZE));\n  }\n\n  size_type count() const {\n    unsigned NumBits = 0;\n    for (unsigned i = 0; i < BITWORDS_PER_ELEMENT; ++i)\n      NumBits += countPopulation(Bits[i]);\n    return NumBits;\n  }\n\n  /// find_first - Returns the index of the first set bit.\n  int find_first() const {\n    for (unsigned i = 0; i < BITWORDS_PER_ELEMENT; ++i)\n      if (Bits[i] != 0)\n        return i * BITWORD_SIZE + countTrailingZeros(Bits[i]);\n    llvm_unreachable(\"Illegal empty element\");\n  }\n\n  /// find_last - Returns the index of the last set bit.\n  int find_last() const {\n    for (unsigned I = 0; I < BITWORDS_PER_ELEMENT; ++I) {\n      unsigned Idx = BITWORDS_PER_ELEMENT - I - 1;\n      if (Bits[Idx] != 0)\n        return Idx * BITWORD_SIZE + BITWORD_SIZE -\n               countLeadingZeros(Bits[Idx]) - 1;\n    }\n    llvm_unreachable(\"Illegal empty element\");\n  }\n\n  /// find_next - Returns the index of the next set bit starting from the\n  /// \"Curr\" bit. Returns -1 if the next set bit is not found.\n  int find_next(unsigned Curr) const {\n    if (Curr >= BITS_PER_ELEMENT)\n      return -1;\n\n    unsigned WordPos = Curr / BITWORD_SIZE;\n    unsigned BitPos = Curr % BITWORD_SIZE;\n    BitWord Copy = Bits[WordPos];\n    assert(WordPos <= BITWORDS_PER_ELEMENT\n           && \"Word Position outside of element\");\n\n    // Mask off previous bits.\n    Copy &= ~0UL << BitPos;\n\n    if (Copy != 0)\n      return WordPos * BITWORD_SIZE + countTrailingZeros(Copy);\n\n    // Check subsequent words.\n    for (unsigned i = WordPos+1; i < BITWORDS_PER_ELEMENT; ++i)\n      if (Bits[i] != 0)\n        return i * BITWORD_SIZE + countTrailingZeros(Bits[i]);\n    return -1;\n  }\n\n  // Union this element with RHS and return true if this one changed.\n  bool unionWith(const SparseBitVectorElement &RHS) {\n    bool changed = false;\n    for (unsigned i = 0; i < BITWORDS_PER_ELEMENT; ++i) {\n      BitWord old = changed ? 0 : Bits[i];\n\n      Bits[i] |= RHS.Bits[i];\n      if (!changed && old != Bits[i])\n        changed = true;\n    }\n    return changed;\n  }\n\n  // Return true if we have any bits in common with RHS\n  bool intersects(const SparseBitVectorElement &RHS) const {\n    for (unsigned i = 0; i < BITWORDS_PER_ELEMENT; ++i) {\n      if (RHS.Bits[i] & Bits[i])\n        return true;\n    }\n    return false;\n  }\n\n  // Intersect this Element with RHS and return true if this one changed.\n  // BecameZero is set to true if this element became all-zero bits.\n  bool intersectWith(const SparseBitVectorElement &RHS,\n                     bool &BecameZero) {\n    bool changed = false;\n    bool allzero = true;\n\n    BecameZero = false;\n    for (unsigned i = 0; i < BITWORDS_PER_ELEMENT; ++i) {\n      BitWord old = changed ? 0 : Bits[i];\n\n      Bits[i] &= RHS.Bits[i];\n      if (Bits[i] != 0)\n        allzero = false;\n\n      if (!changed && old != Bits[i])\n        changed = true;\n    }\n    BecameZero = allzero;\n    return changed;\n  }\n\n  // Intersect this Element with the complement of RHS and return true if this\n  // one changed.  BecameZero is set to true if this element became all-zero\n  // bits.\n  bool intersectWithComplement(const SparseBitVectorElement &RHS,\n                               bool &BecameZero) {\n    bool changed = false;\n    bool allzero = true;\n\n    BecameZero = false;\n    for (unsigned i = 0; i < BITWORDS_PER_ELEMENT; ++i) {\n      BitWord old = changed ? 0 : Bits[i];\n\n      Bits[i] &= ~RHS.Bits[i];\n      if (Bits[i] != 0)\n        allzero = false;\n\n      if (!changed && old != Bits[i])\n        changed = true;\n    }\n    BecameZero = allzero;\n    return changed;\n  }\n\n  // Three argument version of intersectWithComplement that intersects\n  // RHS1 & ~RHS2 into this element\n  void intersectWithComplement(const SparseBitVectorElement &RHS1,\n                               const SparseBitVectorElement &RHS2,\n                               bool &BecameZero) {\n    bool allzero = true;\n\n    BecameZero = false;\n    for (unsigned i = 0; i < BITWORDS_PER_ELEMENT; ++i) {\n      Bits[i] = RHS1.Bits[i] & ~RHS2.Bits[i];\n      if (Bits[i] != 0)\n        allzero = false;\n    }\n    BecameZero = allzero;\n  }\n};\n\ntemplate <unsigned ElementSize = 128>\nclass SparseBitVector {\n  using ElementList = std::list<SparseBitVectorElement<ElementSize>>;\n  using ElementListIter = typename ElementList::iterator;\n  using ElementListConstIter = typename ElementList::const_iterator;\n  enum {\n    BITWORD_SIZE = SparseBitVectorElement<ElementSize>::BITWORD_SIZE\n  };\n\n  ElementList Elements;\n  // Pointer to our current Element. This has no visible effect on the external\n  // state of a SparseBitVector, it's just used to improve performance in the\n  // common case of testing/modifying bits with similar indices.\n  mutable ElementListIter CurrElementIter;\n\n  // This is like std::lower_bound, except we do linear searching from the\n  // current position.\n  ElementListIter FindLowerBoundImpl(unsigned ElementIndex) const {\n\n    // We cache a non-const iterator so we're forced to resort to const_cast to\n    // get the begin/end in the case where 'this' is const. To avoid duplication\n    // of code with the only difference being whether the const cast is present\n    // 'this' is always const in this particular function and we sort out the\n    // difference in FindLowerBound and FindLowerBoundConst.\n    ElementListIter Begin =\n        const_cast<SparseBitVector<ElementSize> *>(this)->Elements.begin();\n    ElementListIter End =\n        const_cast<SparseBitVector<ElementSize> *>(this)->Elements.end();\n\n    if (Elements.empty()) {\n      CurrElementIter = Begin;\n      return CurrElementIter;\n    }\n\n    // Make sure our current iterator is valid.\n    if (CurrElementIter == End)\n      --CurrElementIter;\n\n    // Search from our current iterator, either backwards or forwards,\n    // depending on what element we are looking for.\n    ElementListIter ElementIter = CurrElementIter;\n    if (CurrElementIter->index() == ElementIndex) {\n      return ElementIter;\n    } else if (CurrElementIter->index() > ElementIndex) {\n      while (ElementIter != Begin\n             && ElementIter->index() > ElementIndex)\n        --ElementIter;\n    } else {\n      while (ElementIter != End &&\n             ElementIter->index() < ElementIndex)\n        ++ElementIter;\n    }\n    CurrElementIter = ElementIter;\n    return ElementIter;\n  }\n  ElementListConstIter FindLowerBoundConst(unsigned ElementIndex) const {\n    return FindLowerBoundImpl(ElementIndex);\n  }\n  ElementListIter FindLowerBound(unsigned ElementIndex) {\n    return FindLowerBoundImpl(ElementIndex);\n  }\n\n  // Iterator to walk set bits in the bitmap.  This iterator is a lot uglier\n  // than it would be, in order to be efficient.\n  class SparseBitVectorIterator {\n  private:\n    bool AtEnd;\n\n    const SparseBitVector<ElementSize> *BitVector = nullptr;\n\n    // Current element inside of bitmap.\n    ElementListConstIter Iter;\n\n    // Current bit number inside of our bitmap.\n    unsigned BitNumber;\n\n    // Current word number inside of our element.\n    unsigned WordNumber;\n\n    // Current bits from the element.\n    typename SparseBitVectorElement<ElementSize>::BitWord Bits;\n\n    // Move our iterator to the first non-zero bit in the bitmap.\n    void AdvanceToFirstNonZero() {\n      if (AtEnd)\n        return;\n      if (BitVector->Elements.empty()) {\n        AtEnd = true;\n        return;\n      }\n      Iter = BitVector->Elements.begin();\n      BitNumber = Iter->index() * ElementSize;\n      unsigned BitPos = Iter->find_first();\n      BitNumber += BitPos;\n      WordNumber = (BitNumber % ElementSize) / BITWORD_SIZE;\n      Bits = Iter->word(WordNumber);\n      Bits >>= BitPos % BITWORD_SIZE;\n    }\n\n    // Move our iterator to the next non-zero bit.\n    void AdvanceToNextNonZero() {\n      if (AtEnd)\n        return;\n\n      while (Bits && !(Bits & 1)) {\n        Bits >>= 1;\n        BitNumber += 1;\n      }\n\n      // See if we ran out of Bits in this word.\n      if (!Bits) {\n        int NextSetBitNumber = Iter->find_next(BitNumber % ElementSize) ;\n        // If we ran out of set bits in this element, move to next element.\n        if (NextSetBitNumber == -1 || (BitNumber % ElementSize == 0)) {\n          ++Iter;\n          WordNumber = 0;\n\n          // We may run out of elements in the bitmap.\n          if (Iter == BitVector->Elements.end()) {\n            AtEnd = true;\n            return;\n          }\n          // Set up for next non-zero word in bitmap.\n          BitNumber = Iter->index() * ElementSize;\n          NextSetBitNumber = Iter->find_first();\n          BitNumber += NextSetBitNumber;\n          WordNumber = (BitNumber % ElementSize) / BITWORD_SIZE;\n          Bits = Iter->word(WordNumber);\n          Bits >>= NextSetBitNumber % BITWORD_SIZE;\n        } else {\n          WordNumber = (NextSetBitNumber % ElementSize) / BITWORD_SIZE;\n          Bits = Iter->word(WordNumber);\n          Bits >>= NextSetBitNumber % BITWORD_SIZE;\n          BitNumber = Iter->index() * ElementSize;\n          BitNumber += NextSetBitNumber;\n        }\n      }\n    }\n\n  public:\n    SparseBitVectorIterator() = default;\n\n    SparseBitVectorIterator(const SparseBitVector<ElementSize> *RHS,\n                            bool end = false):BitVector(RHS) {\n      Iter = BitVector->Elements.begin();\n      BitNumber = 0;\n      Bits = 0;\n      WordNumber = ~0;\n      AtEnd = end;\n      AdvanceToFirstNonZero();\n    }\n\n    // Preincrement.\n    inline SparseBitVectorIterator& operator++() {\n      ++BitNumber;\n      Bits >>= 1;\n      AdvanceToNextNonZero();\n      return *this;\n    }\n\n    // Postincrement.\n    inline SparseBitVectorIterator operator++(int) {\n      SparseBitVectorIterator tmp = *this;\n      ++*this;\n      return tmp;\n    }\n\n    // Return the current set bit number.\n    unsigned operator*() const {\n      return BitNumber;\n    }\n\n    bool operator==(const SparseBitVectorIterator &RHS) const {\n      // If they are both at the end, ignore the rest of the fields.\n      if (AtEnd && RHS.AtEnd)\n        return true;\n      // Otherwise they are the same if they have the same bit number and\n      // bitmap.\n      return AtEnd == RHS.AtEnd && RHS.BitNumber == BitNumber;\n    }\n\n    bool operator!=(const SparseBitVectorIterator &RHS) const {\n      return !(*this == RHS);\n    }\n  };\n\npublic:\n  using iterator = SparseBitVectorIterator;\n\n  SparseBitVector() : Elements(), CurrElementIter(Elements.begin()) {}\n\n  SparseBitVector(const SparseBitVector &RHS)\n      : Elements(RHS.Elements), CurrElementIter(Elements.begin()) {}\n  SparseBitVector(SparseBitVector &&RHS)\n      : Elements(std::move(RHS.Elements)), CurrElementIter(Elements.begin()) {}\n\n  // Clear.\n  void clear() {\n    Elements.clear();\n  }\n\n  // Assignment\n  SparseBitVector& operator=(const SparseBitVector& RHS) {\n    if (this == &RHS)\n      return *this;\n\n    Elements = RHS.Elements;\n    CurrElementIter = Elements.begin();\n    return *this;\n  }\n  SparseBitVector &operator=(SparseBitVector &&RHS) {\n    Elements = std::move(RHS.Elements);\n    CurrElementIter = Elements.begin();\n    return *this;\n  }\n\n  // Test, Reset, and Set a bit in the bitmap.\n  bool test(unsigned Idx) const {\n    if (Elements.empty())\n      return false;\n\n    unsigned ElementIndex = Idx / ElementSize;\n    ElementListConstIter ElementIter = FindLowerBoundConst(ElementIndex);\n\n    // If we can't find an element that is supposed to contain this bit, there\n    // is nothing more to do.\n    if (ElementIter == Elements.end() ||\n        ElementIter->index() != ElementIndex)\n      return false;\n    return ElementIter->test(Idx % ElementSize);\n  }\n\n  void reset(unsigned Idx) {\n    if (Elements.empty())\n      return;\n\n    unsigned ElementIndex = Idx / ElementSize;\n    ElementListIter ElementIter = FindLowerBound(ElementIndex);\n\n    // If we can't find an element that is supposed to contain this bit, there\n    // is nothing more to do.\n    if (ElementIter == Elements.end() ||\n        ElementIter->index() != ElementIndex)\n      return;\n    ElementIter->reset(Idx % ElementSize);\n\n    // When the element is zeroed out, delete it.\n    if (ElementIter->empty()) {\n      ++CurrElementIter;\n      Elements.erase(ElementIter);\n    }\n  }\n\n  void set(unsigned Idx) {\n    unsigned ElementIndex = Idx / ElementSize;\n    ElementListIter ElementIter;\n    if (Elements.empty()) {\n      ElementIter = Elements.emplace(Elements.end(), ElementIndex);\n    } else {\n      ElementIter = FindLowerBound(ElementIndex);\n\n      if (ElementIter == Elements.end() ||\n          ElementIter->index() != ElementIndex) {\n        // We may have hit the beginning of our SparseBitVector, in which case,\n        // we may need to insert right after this element, which requires moving\n        // the current iterator forward one, because insert does insert before.\n        if (ElementIter != Elements.end() &&\n            ElementIter->index() < ElementIndex)\n          ++ElementIter;\n        ElementIter = Elements.emplace(ElementIter, ElementIndex);\n      }\n    }\n    CurrElementIter = ElementIter;\n\n    ElementIter->set(Idx % ElementSize);\n  }\n\n  bool test_and_set(unsigned Idx) {\n    bool old = test(Idx);\n    if (!old) {\n      set(Idx);\n      return true;\n    }\n    return false;\n  }\n\n  bool operator!=(const SparseBitVector &RHS) const {\n    return !(*this == RHS);\n  }\n\n  bool operator==(const SparseBitVector &RHS) const {\n    ElementListConstIter Iter1 = Elements.begin();\n    ElementListConstIter Iter2 = RHS.Elements.begin();\n\n    for (; Iter1 != Elements.end() && Iter2 != RHS.Elements.end();\n         ++Iter1, ++Iter2) {\n      if (*Iter1 != *Iter2)\n        return false;\n    }\n    return Iter1 == Elements.end() && Iter2 == RHS.Elements.end();\n  }\n\n  // Union our bitmap with the RHS and return true if we changed.\n  bool operator|=(const SparseBitVector &RHS) {\n    if (this == &RHS)\n      return false;\n\n    bool changed = false;\n    ElementListIter Iter1 = Elements.begin();\n    ElementListConstIter Iter2 = RHS.Elements.begin();\n\n    // If RHS is empty, we are done\n    if (RHS.Elements.empty())\n      return false;\n\n    while (Iter2 != RHS.Elements.end()) {\n      if (Iter1 == Elements.end() || Iter1->index() > Iter2->index()) {\n        Elements.insert(Iter1, *Iter2);\n        ++Iter2;\n        changed = true;\n      } else if (Iter1->index() == Iter2->index()) {\n        changed |= Iter1->unionWith(*Iter2);\n        ++Iter1;\n        ++Iter2;\n      } else {\n        ++Iter1;\n      }\n    }\n    CurrElementIter = Elements.begin();\n    return changed;\n  }\n\n  // Intersect our bitmap with the RHS and return true if ours changed.\n  bool operator&=(const SparseBitVector &RHS) {\n    if (this == &RHS)\n      return false;\n\n    bool changed = false;\n    ElementListIter Iter1 = Elements.begin();\n    ElementListConstIter Iter2 = RHS.Elements.begin();\n\n    // Check if both bitmaps are empty.\n    if (Elements.empty() && RHS.Elements.empty())\n      return false;\n\n    // Loop through, intersecting as we go, erasing elements when necessary.\n    while (Iter2 != RHS.Elements.end()) {\n      if (Iter1 == Elements.end()) {\n        CurrElementIter = Elements.begin();\n        return changed;\n      }\n\n      if (Iter1->index() > Iter2->index()) {\n        ++Iter2;\n      } else if (Iter1->index() == Iter2->index()) {\n        bool BecameZero;\n        changed |= Iter1->intersectWith(*Iter2, BecameZero);\n        if (BecameZero) {\n          ElementListIter IterTmp = Iter1;\n          ++Iter1;\n          Elements.erase(IterTmp);\n        } else {\n          ++Iter1;\n        }\n        ++Iter2;\n      } else {\n        ElementListIter IterTmp = Iter1;\n        ++Iter1;\n        Elements.erase(IterTmp);\n        changed = true;\n      }\n    }\n    if (Iter1 != Elements.end()) {\n      Elements.erase(Iter1, Elements.end());\n      changed = true;\n    }\n    CurrElementIter = Elements.begin();\n    return changed;\n  }\n\n  // Intersect our bitmap with the complement of the RHS and return true\n  // if ours changed.\n  bool intersectWithComplement(const SparseBitVector &RHS) {\n    if (this == &RHS) {\n      if (!empty()) {\n        clear();\n        return true;\n      }\n      return false;\n    }\n\n    bool changed = false;\n    ElementListIter Iter1 = Elements.begin();\n    ElementListConstIter Iter2 = RHS.Elements.begin();\n\n    // If either our bitmap or RHS is empty, we are done\n    if (Elements.empty() || RHS.Elements.empty())\n      return false;\n\n    // Loop through, intersecting as we go, erasing elements when necessary.\n    while (Iter2 != RHS.Elements.end()) {\n      if (Iter1 == Elements.end()) {\n        CurrElementIter = Elements.begin();\n        return changed;\n      }\n\n      if (Iter1->index() > Iter2->index()) {\n        ++Iter2;\n      } else if (Iter1->index() == Iter2->index()) {\n        bool BecameZero;\n        changed |= Iter1->intersectWithComplement(*Iter2, BecameZero);\n        if (BecameZero) {\n          ElementListIter IterTmp = Iter1;\n          ++Iter1;\n          Elements.erase(IterTmp);\n        } else {\n          ++Iter1;\n        }\n        ++Iter2;\n      } else {\n        ++Iter1;\n      }\n    }\n    CurrElementIter = Elements.begin();\n    return changed;\n  }\n\n  bool intersectWithComplement(const SparseBitVector<ElementSize> *RHS) const {\n    return intersectWithComplement(*RHS);\n  }\n\n  //  Three argument version of intersectWithComplement.\n  //  Result of RHS1 & ~RHS2 is stored into this bitmap.\n  void intersectWithComplement(const SparseBitVector<ElementSize> &RHS1,\n                               const SparseBitVector<ElementSize> &RHS2)\n  {\n    if (this == &RHS1) {\n      intersectWithComplement(RHS2);\n      return;\n    } else if (this == &RHS2) {\n      SparseBitVector RHS2Copy(RHS2);\n      intersectWithComplement(RHS1, RHS2Copy);\n      return;\n    }\n\n    Elements.clear();\n    CurrElementIter = Elements.begin();\n    ElementListConstIter Iter1 = RHS1.Elements.begin();\n    ElementListConstIter Iter2 = RHS2.Elements.begin();\n\n    // If RHS1 is empty, we are done\n    // If RHS2 is empty, we still have to copy RHS1\n    if (RHS1.Elements.empty())\n      return;\n\n    // Loop through, intersecting as we go, erasing elements when necessary.\n    while (Iter2 != RHS2.Elements.end()) {\n      if (Iter1 == RHS1.Elements.end())\n        return;\n\n      if (Iter1->index() > Iter2->index()) {\n        ++Iter2;\n      } else if (Iter1->index() == Iter2->index()) {\n        bool BecameZero = false;\n        Elements.emplace_back(Iter1->index());\n        Elements.back().intersectWithComplement(*Iter1, *Iter2, BecameZero);\n        if (BecameZero)\n          Elements.pop_back();\n        ++Iter1;\n        ++Iter2;\n      } else {\n        Elements.push_back(*Iter1++);\n      }\n    }\n\n    // copy the remaining elements\n    std::copy(Iter1, RHS1.Elements.end(), std::back_inserter(Elements));\n  }\n\n  void intersectWithComplement(const SparseBitVector<ElementSize> *RHS1,\n                               const SparseBitVector<ElementSize> *RHS2) {\n    intersectWithComplement(*RHS1, *RHS2);\n  }\n\n  bool intersects(const SparseBitVector<ElementSize> *RHS) const {\n    return intersects(*RHS);\n  }\n\n  // Return true if we share any bits in common with RHS\n  bool intersects(const SparseBitVector<ElementSize> &RHS) const {\n    ElementListConstIter Iter1 = Elements.begin();\n    ElementListConstIter Iter2 = RHS.Elements.begin();\n\n    // Check if both bitmaps are empty.\n    if (Elements.empty() && RHS.Elements.empty())\n      return false;\n\n    // Loop through, intersecting stopping when we hit bits in common.\n    while (Iter2 != RHS.Elements.end()) {\n      if (Iter1 == Elements.end())\n        return false;\n\n      if (Iter1->index() > Iter2->index()) {\n        ++Iter2;\n      } else if (Iter1->index() == Iter2->index()) {\n        if (Iter1->intersects(*Iter2))\n          return true;\n        ++Iter1;\n        ++Iter2;\n      } else {\n        ++Iter1;\n      }\n    }\n    return false;\n  }\n\n  // Return true iff all bits set in this SparseBitVector are\n  // also set in RHS.\n  bool contains(const SparseBitVector<ElementSize> &RHS) const {\n    SparseBitVector<ElementSize> Result(*this);\n    Result &= RHS;\n    return (Result == RHS);\n  }\n\n  // Return the first set bit in the bitmap.  Return -1 if no bits are set.\n  int find_first() const {\n    if (Elements.empty())\n      return -1;\n    const SparseBitVectorElement<ElementSize> &First = *(Elements.begin());\n    return (First.index() * ElementSize) + First.find_first();\n  }\n\n  // Return the last set bit in the bitmap.  Return -1 if no bits are set.\n  int find_last() const {\n    if (Elements.empty())\n      return -1;\n    const SparseBitVectorElement<ElementSize> &Last = *(Elements.rbegin());\n    return (Last.index() * ElementSize) + Last.find_last();\n  }\n\n  // Return true if the SparseBitVector is empty\n  bool empty() const {\n    return Elements.empty();\n  }\n\n  unsigned count() const {\n    unsigned BitCount = 0;\n    for (ElementListConstIter Iter = Elements.begin();\n         Iter != Elements.end();\n         ++Iter)\n      BitCount += Iter->count();\n\n    return BitCount;\n  }\n\n  iterator begin() const {\n    return iterator(this);\n  }\n\n  iterator end() const {\n    return iterator(this, true);\n  }\n};\n\n// Convenience functions to allow Or and And without dereferencing in the user\n// code.\n\ntemplate <unsigned ElementSize>\ninline bool operator |=(SparseBitVector<ElementSize> &LHS,\n                        const SparseBitVector<ElementSize> *RHS) {\n  return LHS |= *RHS;\n}\n\ntemplate <unsigned ElementSize>\ninline bool operator |=(SparseBitVector<ElementSize> *LHS,\n                        const SparseBitVector<ElementSize> &RHS) {\n  return LHS->operator|=(RHS);\n}\n\ntemplate <unsigned ElementSize>\ninline bool operator &=(SparseBitVector<ElementSize> *LHS,\n                        const SparseBitVector<ElementSize> &RHS) {\n  return LHS->operator&=(RHS);\n}\n\ntemplate <unsigned ElementSize>\ninline bool operator &=(SparseBitVector<ElementSize> &LHS,\n                        const SparseBitVector<ElementSize> *RHS) {\n  return LHS &= *RHS;\n}\n\n// Convenience functions for infix union, intersection, difference operators.\n\ntemplate <unsigned ElementSize>\ninline SparseBitVector<ElementSize>\noperator|(const SparseBitVector<ElementSize> &LHS,\n          const SparseBitVector<ElementSize> &RHS) {\n  SparseBitVector<ElementSize> Result(LHS);\n  Result |= RHS;\n  return Result;\n}\n\ntemplate <unsigned ElementSize>\ninline SparseBitVector<ElementSize>\noperator&(const SparseBitVector<ElementSize> &LHS,\n          const SparseBitVector<ElementSize> &RHS) {\n  SparseBitVector<ElementSize> Result(LHS);\n  Result &= RHS;\n  return Result;\n}\n\ntemplate <unsigned ElementSize>\ninline SparseBitVector<ElementSize>\noperator-(const SparseBitVector<ElementSize> &LHS,\n          const SparseBitVector<ElementSize> &RHS) {\n  SparseBitVector<ElementSize> Result;\n  Result.intersectWithComplement(LHS, RHS);\n  return Result;\n}\n\n// Dump a SparseBitVector to a stream\ntemplate <unsigned ElementSize>\nvoid dump(const SparseBitVector<ElementSize> &LHS, raw_ostream &out) {\n  out << \"[\";\n\n  typename SparseBitVector<ElementSize>::iterator bi = LHS.begin(),\n    be = LHS.end();\n  if (bi != be) {\n    out << *bi;\n    for (++bi; bi != be; ++bi) {\n      out << \" \" << *bi;\n    }\n  }\n  out << \"]\\n\";\n}\n\n} // end namespace llvm\n\n#endif // LLVM_ADT_SPARSEBITVECTOR_H\n"}, "31": {"id": 31, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/DebugInfo/CodeView/DebugFrameDataSubsection.h", "content": "//===- DebugFrameDataSubsection.h ------------------------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_DEBUGINFO_CODEVIEW_DEBUGFRAMEDATASUBSECTION_H\n#define LLVM_DEBUGINFO_CODEVIEW_DEBUGFRAMEDATASUBSECTION_H\n\n#include \"llvm/DebugInfo/CodeView/CodeView.h\"\n#include \"llvm/DebugInfo/CodeView/DebugSubsection.h\"\n#include \"llvm/Support/BinaryStreamReader.h\"\n#include \"llvm/Support/Endian.h\"\n#include \"llvm/Support/Error.h\"\n\nnamespace llvm {\nnamespace codeview {\nclass DebugFrameDataSubsectionRef final : public DebugSubsectionRef {\npublic:\n  DebugFrameDataSubsectionRef()\n      : DebugSubsectionRef(DebugSubsectionKind::FrameData) {}\n  static bool classof(const DebugSubsection *S) {\n    return S->kind() == DebugSubsectionKind::FrameData;\n  }\n\n  Error initialize(BinaryStreamReader Reader);\n  Error initialize(BinaryStreamRef Stream);\n\n  FixedStreamArray<FrameData>::Iterator begin() const { return Frames.begin(); }\n  FixedStreamArray<FrameData>::Iterator end() const { return Frames.end(); }\n\n  const support::ulittle32_t *getRelocPtr() const { return RelocPtr; }\n\nprivate:\n  const support::ulittle32_t *RelocPtr = nullptr;\n  FixedStreamArray<FrameData> Frames;\n};\n\nclass DebugFrameDataSubsection final : public DebugSubsection {\npublic:\n  DebugFrameDataSubsection(bool IncludeRelocPtr)\n      : DebugSubsection(DebugSubsectionKind::FrameData),\n        IncludeRelocPtr(IncludeRelocPtr) {}\n  static bool classof(const DebugSubsection *S) {\n    return S->kind() == DebugSubsectionKind::FrameData;\n  }\n\n  uint32_t calculateSerializedSize() const override;\n  Error commit(BinaryStreamWriter &Writer) const override;\n\n  void addFrameData(const FrameData &Frame);\n  void setFrames(ArrayRef<FrameData> Frames);\n\nprivate:\n  bool IncludeRelocPtr = false;\n  std::vector<FrameData> Frames;\n};\n}\n}\n\n#endif\n"}, "35": {"id": 35, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/DebugInfo/CodeView/GUID.h", "content": "//===- GUID.h ---------------------------------------------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_DEBUGINFO_CODEVIEW_GUID_H\n#define LLVM_DEBUGINFO_CODEVIEW_GUID_H\n\n#include <cstdint>\n#include <cstring>\n\nnamespace llvm {\nclass raw_ostream;\n\nnamespace codeview {\n\n/// This represents the 'GUID' type from windows.h.\nstruct GUID {\n  uint8_t Guid[16];\n};\n\ninline bool operator==(const GUID &LHS, const GUID &RHS) {\n  return 0 == ::memcmp(LHS.Guid, RHS.Guid, sizeof(LHS.Guid));\n}\n\ninline bool operator<(const GUID &LHS, const GUID &RHS) {\n  return ::memcmp(LHS.Guid, RHS.Guid, sizeof(LHS.Guid)) < 0;\n}\n\ninline bool operator<=(const GUID &LHS, const GUID &RHS) {\n  return ::memcmp(LHS.Guid, RHS.Guid, sizeof(LHS.Guid)) <= 0;\n}\n\ninline bool operator>(const GUID &LHS, const GUID &RHS) {\n  return !(LHS <= RHS);\n}\n\ninline bool operator>=(const GUID &LHS, const GUID &RHS) {\n  return !(LHS < RHS);\n}\n\ninline bool operator!=(const GUID &LHS, const GUID &RHS) {\n  return !(LHS == RHS);\n}\n\nraw_ostream &operator<<(raw_ostream &OS, const GUID &Guid);\n\n} // namespace codeview\n} // namespace llvm\n\n#endif\n"}, "38": {"id": 38, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/DebugInfo/CodeView/StringsAndChecksums.h", "content": "//===- StringsAndChecksums.h ------------------------------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_DEBUGINFO_CODEVIEW_STRINGSANDCHECKSUMS_H\n#define LLVM_DEBUGINFO_CODEVIEW_STRINGSANDCHECKSUMS_H\n\n#include \"llvm/DebugInfo/CodeView/CodeView.h\"\n#include \"llvm/DebugInfo/CodeView/DebugChecksumsSubsection.h\"\n#include \"llvm/DebugInfo/CodeView/DebugStringTableSubsection.h\"\n#include \"llvm/DebugInfo/CodeView/DebugSubsectionRecord.h\"\n#include <memory>\n\nnamespace llvm {\nnamespace codeview {\n\nclass StringsAndChecksumsRef {\npublic:\n  // If no subsections are known about initially, we find as much as we can.\n  StringsAndChecksumsRef();\n\n  // If only a string table subsection is given, we find a checksums subsection.\n  explicit StringsAndChecksumsRef(const DebugStringTableSubsectionRef &Strings);\n\n  // If both subsections are given, we don't need to find anything.\n  StringsAndChecksumsRef(const DebugStringTableSubsectionRef &Strings,\n                         const DebugChecksumsSubsectionRef &Checksums);\n\n  void setStrings(const DebugStringTableSubsectionRef &Strings);\n  void setChecksums(const DebugChecksumsSubsectionRef &CS);\n\n  void reset();\n  void resetStrings();\n  void resetChecksums();\n\n  template <typename T> void initialize(T &&FragmentRange) {\n    for (const DebugSubsectionRecord &R : FragmentRange) {\n      if (Strings && Checksums)\n        return;\n      if (R.kind() == DebugSubsectionKind::FileChecksums) {\n        initializeChecksums(R);\n        continue;\n      }\n      if (R.kind() == DebugSubsectionKind::StringTable && !Strings) {\n        // While in practice we should never encounter a string table even\n        // though the string table is already initialized, in theory it's\n        // possible.  PDBs are supposed to have one global string table and\n        // then this subsection should not appear.  Whereas object files are\n        // supposed to have this subsection appear exactly once.  However,\n        // for testing purposes it's nice to be able to test this subsection\n        // independently of one format or the other, so for some tests we\n        // manually construct a PDB that contains this subsection in addition\n        // to a global string table.\n        initializeStrings(R);\n        continue;\n      }\n    }\n  }\n\n  const DebugStringTableSubsectionRef &strings() const { return *Strings; }\n  const DebugChecksumsSubsectionRef &checksums() const { return *Checksums; }\n\n  bool hasStrings() const { return Strings != nullptr; }\n  bool hasChecksums() const { return Checksums != nullptr; }\n\nprivate:\n  void initializeStrings(const DebugSubsectionRecord &SR);\n  void initializeChecksums(const DebugSubsectionRecord &FCR);\n\n  std::shared_ptr<DebugStringTableSubsectionRef> OwnedStrings;\n  std::shared_ptr<DebugChecksumsSubsectionRef> OwnedChecksums;\n\n  const DebugStringTableSubsectionRef *Strings = nullptr;\n  const DebugChecksumsSubsectionRef *Checksums = nullptr;\n};\n\nclass StringsAndChecksums {\npublic:\n  using StringsPtr = std::shared_ptr<DebugStringTableSubsection>;\n  using ChecksumsPtr = std::shared_ptr<DebugChecksumsSubsection>;\n\n  // If no subsections are known about initially, we find as much as we can.\n  StringsAndChecksums() = default;\n\n  void setStrings(const StringsPtr &SP) { Strings = SP; }\n  void setChecksums(const ChecksumsPtr &CP) { Checksums = CP; }\n\n  const StringsPtr &strings() const { return Strings; }\n  const ChecksumsPtr &checksums() const { return Checksums; }\n\n  bool hasStrings() const { return Strings != nullptr; }\n  bool hasChecksums() const { return Checksums != nullptr; }\n\nprivate:\n  StringsPtr Strings;\n  ChecksumsPtr Checksums;\n};\n\n} // end namespace codeview\n} // end namespace llvm\n\n#endif // LLVM_DEBUGINFO_CODEVIEW_STRINGSANDCHECKSUMS_H\n"}, "46": {"id": 46, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/DebugInfo/MSF/MSFCommon.h", "content": "//===- MSFCommon.h - Common types and functions for MSF files ---*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_DEBUGINFO_MSF_MSFCOMMON_H\n#define LLVM_DEBUGINFO_MSF_MSFCOMMON_H\n\n#include \"llvm/ADT/ArrayRef.h\"\n#include \"llvm/ADT/BitVector.h\"\n#include \"llvm/Support/Endian.h\"\n#include \"llvm/Support/Error.h\"\n#include \"llvm/Support/MathExtras.h\"\n#include <cstdint>\n#include <vector>\n\nnamespace llvm {\nnamespace msf {\n\nstatic const char Magic[] = {'M',  'i',  'c',    'r', 'o', 's',  'o',  'f',\n                             't',  ' ',  'C',    '/', 'C', '+',  '+',  ' ',\n                             'M',  'S',  'F',    ' ', '7', '.',  '0',  '0',\n                             '\\r', '\\n', '\\x1a', 'D', 'S', '\\0', '\\0', '\\0'};\n\n// The superblock is overlaid at the beginning of the file (offset 0).\n// It starts with a magic header and is followed by information which\n// describes the layout of the file system.\nstruct SuperBlock {\n  char MagicBytes[sizeof(Magic)];\n  // The file system is split into a variable number of fixed size elements.\n  // These elements are referred to as blocks.  The size of a block may vary\n  // from system to system.\n  support::ulittle32_t BlockSize;\n  // The index of the free block map.\n  support::ulittle32_t FreeBlockMapBlock;\n  // This contains the number of blocks resident in the file system.  In\n  // practice, NumBlocks * BlockSize is equivalent to the size of the MSF\n  // file.\n  support::ulittle32_t NumBlocks;\n  // This contains the number of bytes which make up the directory.\n  support::ulittle32_t NumDirectoryBytes;\n  // This field's purpose is not yet known.\n  support::ulittle32_t Unknown1;\n  // This contains the block # of the block map.\n  support::ulittle32_t BlockMapAddr;\n};\n\nstruct MSFLayout {\n  MSFLayout() = default;\n\n  uint32_t mainFpmBlock() const {\n    assert(SB->FreeBlockMapBlock == 1 || SB->FreeBlockMapBlock == 2);\n    return SB->FreeBlockMapBlock;\n  }\n\n  uint32_t alternateFpmBlock() const {\n    // If mainFpmBlock is 1, this is 2.  If mainFpmBlock is 2, this is 1.\n    return 3U - mainFpmBlock();\n  }\n\n  const SuperBlock *SB = nullptr;\n  BitVector FreePageMap;\n  ArrayRef<support::ulittle32_t> DirectoryBlocks;\n  ArrayRef<support::ulittle32_t> StreamSizes;\n  std::vector<ArrayRef<support::ulittle32_t>> StreamMap;\n};\n\n/// Describes the layout of a stream in an MSF layout.  A \"stream\" here\n/// is defined as any logical unit of data which may be arranged inside the MSF\n/// file as a sequence of (possibly discontiguous) blocks.  When we want to read\n/// from a particular MSF Stream, we fill out a stream layout structure and the\n/// reader uses it to determine which blocks in the underlying MSF file contain\n/// the data, so that it can be pieced together in the right order.\nclass MSFStreamLayout {\npublic:\n  uint32_t Length;\n  std::vector<support::ulittle32_t> Blocks;\n};\n\n/// Determine the layout of the FPM stream, given the MSF layout.  An FPM\n/// stream spans 1 or more blocks, each at equally spaced intervals throughout\n/// the file.\nMSFStreamLayout getFpmStreamLayout(const MSFLayout &Msf,\n                                   bool IncludeUnusedFpmData = false,\n                                   bool AltFpm = false);\n\ninline bool isValidBlockSize(uint32_t Size) {\n  switch (Size) {\n  case 512:\n  case 1024:\n  case 2048:\n  case 4096:\n    return true;\n  }\n  return false;\n}\n\n// Super Block, Fpm0, Fpm1, and Block Map\ninline uint32_t getMinimumBlockCount() { return 4; }\n\n// Super Block, Fpm0, and Fpm1 are reserved.  The Block Map, although required\n// need not be at block 3.\ninline uint32_t getFirstUnreservedBlock() { return 3; }\n\ninline uint64_t bytesToBlocks(uint64_t NumBytes, uint64_t BlockSize) {\n  return divideCeil(NumBytes, BlockSize);\n}\n\ninline uint64_t blockToOffset(uint64_t BlockNumber, uint64_t BlockSize) {\n  return BlockNumber * BlockSize;\n}\n\ninline uint32_t getFpmIntervalLength(const MSFLayout &L) {\n  return L.SB->BlockSize;\n}\n\n/// Given an MSF with the specified block size and number of blocks, determine\n/// how many pieces the specified Fpm is split into.\n/// \\p BlockSize - the block size of the MSF\n/// \\p NumBlocks - the total number of blocks in the MSF\n/// \\p IncludeUnusedFpmData - When true, this will count every block that is\n///    both in the file and matches the form of an FPM block, even if some of\n///    those FPM blocks are unused (a single FPM block can describe the\n///    allocation status of up to 32,767 blocks, although one appears only\n///    every 4,096 blocks).  So there are 8x as many blocks that match the\n///    form as there are blocks that are necessary to describe the allocation\n///    status of the file.  When this parameter is false, these extraneous\n///    trailing blocks are not counted.\ninline uint32_t getNumFpmIntervals(uint32_t BlockSize, uint32_t NumBlocks,\n                                   bool IncludeUnusedFpmData, int FpmNumber) {\n  assert(FpmNumber == 1 || FpmNumber == 2);\n  if (IncludeUnusedFpmData) {\n    // This calculation determines how many times a number of the form\n    // BlockSize * k + N appears in the range [0, NumBlocks).  We only need to\n    // do this when unused data is included, since the number of blocks dwarfs\n    // the number of fpm blocks.\n    return divideCeil(NumBlocks - FpmNumber, BlockSize);\n  }\n\n  // We want the minimum number of intervals required, where each interval can\n  // represent BlockSize * 8 blocks.\n  return divideCeil(NumBlocks, 8 * BlockSize);\n}\n\ninline uint32_t getNumFpmIntervals(const MSFLayout &L,\n                                   bool IncludeUnusedFpmData = false,\n                                   bool AltFpm = false) {\n  return getNumFpmIntervals(L.SB->BlockSize, L.SB->NumBlocks,\n                            IncludeUnusedFpmData,\n                            AltFpm ? L.alternateFpmBlock() : L.mainFpmBlock());\n}\n\nError validateSuperBlock(const SuperBlock &SB);\n\n} // end namespace msf\n} // end namespace llvm\n\n#endif // LLVM_DEBUGINFO_MSF_MSFCOMMON_H\n"}, "49": {"id": 49, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/DebugInfo/PDB/Native/DbiModuleDescriptorBuilder.h", "content": "//===- DbiModuleDescriptorBuilder.h - PDB module information ----*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_DEBUGINFO_PDB_NATIVE_DBIMODULEDESCRIPTORBUILDER_H\n#define LLVM_DEBUGINFO_PDB_NATIVE_DBIMODULEDESCRIPTORBUILDER_H\n\n#include \"llvm/ADT/StringRef.h\"\n#include \"llvm/DebugInfo/CodeView/DebugChecksumsSubsection.h\"\n#include \"llvm/DebugInfo/CodeView/DebugInlineeLinesSubsection.h\"\n#include \"llvm/DebugInfo/CodeView/DebugLinesSubsection.h\"\n#include \"llvm/DebugInfo/CodeView/DebugSubsectionRecord.h\"\n#include \"llvm/DebugInfo/CodeView/SymbolRecord.h\"\n#include \"llvm/DebugInfo/PDB/Native/RawTypes.h\"\n#include \"llvm/Support/Error.h\"\n#include <cstdint>\n#include <string>\n#include <vector>\n\nnamespace llvm {\nclass BinaryStreamWriter;\n\nnamespace codeview {\nclass DebugSubsectionRecordBuilder;\n}\n\nnamespace msf {\nclass MSFBuilder;\nstruct MSFLayout;\n}\nnamespace pdb {\n\n// Represents merged or unmerged symbols. Merged symbols can be written to the\n// output file as is, but unmerged symbols must be rewritten first. In either\n// case, the size must be known up front.\nstruct SymbolListWrapper {\n  explicit SymbolListWrapper(ArrayRef<uint8_t> Syms)\n      : SymPtr(const_cast<uint8_t *>(Syms.data())), SymSize(Syms.size()),\n        NeedsToBeMerged(false) {}\n  explicit SymbolListWrapper(void *SymSrc, uint32_t Length)\n      : SymPtr(SymSrc), SymSize(Length), NeedsToBeMerged(true) {}\n\n  ArrayRef<uint8_t> asArray() const {\n    return ArrayRef<uint8_t>(static_cast<const uint8_t *>(SymPtr), SymSize);\n  }\n\n  uint32_t size() const { return SymSize; }\n\n  void *SymPtr = nullptr;\n  uint32_t SymSize = 0;\n  bool NeedsToBeMerged = false;\n};\n\n/// Represents a string table reference at some offset in the module symbol\n/// stream.\nstruct StringTableFixup {\n  uint32_t StrTabOffset = 0;\n  uint32_t SymOffsetOfReference = 0;\n};\n\nclass DbiModuleDescriptorBuilder {\n  friend class DbiStreamBuilder;\n\npublic:\n  DbiModuleDescriptorBuilder(StringRef ModuleName, uint32_t ModIndex,\n                             msf::MSFBuilder &Msf);\n  ~DbiModuleDescriptorBuilder();\n\n  DbiModuleDescriptorBuilder(const DbiModuleDescriptorBuilder &) = delete;\n  DbiModuleDescriptorBuilder &\n  operator=(const DbiModuleDescriptorBuilder &) = delete;\n\n  void setPdbFilePathNI(uint32_t NI);\n  void setObjFileName(StringRef Name);\n\n  // Callback to merge one source of unmerged symbols.\n  using MergeSymbolsCallback = Error (*)(void *Ctx, void *Symbols,\n                                         BinaryStreamWriter &Writer);\n\n  void setMergeSymbolsCallback(void *Ctx, MergeSymbolsCallback Callback) {\n    MergeSymsCtx = Ctx;\n    MergeSymsCallback = Callback;\n  }\n\n  void setStringTableFixups(std::vector<StringTableFixup> &&Fixups) {\n    StringTableFixups = std::move(Fixups);\n  }\n\n  void setFirstSectionContrib(const SectionContrib &SC);\n  void addSymbol(codeview::CVSymbol Symbol);\n  void addSymbolsInBulk(ArrayRef<uint8_t> BulkSymbols);\n\n  // Add symbols of known size which will be merged (rewritten) when committing\n  // the PDB to disk.\n  void addUnmergedSymbols(void *SymSrc, uint32_t SymLength);\n\n  void\n  addDebugSubsection(std::shared_ptr<codeview::DebugSubsection> Subsection);\n\n  void\n  addDebugSubsection(const codeview::DebugSubsectionRecord &SubsectionContents);\n\n  uint16_t getStreamIndex() const;\n  StringRef getModuleName() const { return ModuleName; }\n  StringRef getObjFileName() const { return ObjFileName; }\n\n  unsigned getModuleIndex() const { return Layout.Mod; }\n\n  ArrayRef<std::string> source_files() const {\n    return makeArrayRef(SourceFiles);\n  }\n\n  uint32_t calculateSerializedLength() const;\n\n  /// Return the offset within the module symbol stream of the next symbol\n  /// record passed to addSymbol. Add four to account for the signature.\n  uint32_t getNextSymbolOffset() const { return SymbolByteSize + 4; }\n\n  void finalize();\n  Error finalizeMsfLayout();\n\n  /// Commit the DBI descriptor to the DBI stream.\n  Error commit(BinaryStreamWriter &ModiWriter);\n\n  /// Commit the accumulated symbols to the module symbol stream. Safe to call\n  /// in parallel on different DbiModuleDescriptorBuilder objects. Only modifies\n  /// the pre-allocated stream in question.\n  Error commitSymbolStream(const msf::MSFLayout &MsfLayout,\n                           WritableBinaryStreamRef MsfBuffer);\n\nprivate:\n  uint32_t calculateC13DebugInfoSize() const;\n\n  void addSourceFile(StringRef Path);\n  msf::MSFBuilder &MSF;\n\n  uint32_t SymbolByteSize = 0;\n  uint32_t PdbFilePathNI = 0;\n  std::string ModuleName;\n  std::string ObjFileName;\n  std::vector<std::string> SourceFiles;\n  std::vector<SymbolListWrapper> Symbols;\n\n  void *MergeSymsCtx = nullptr;\n  MergeSymbolsCallback MergeSymsCallback = nullptr;\n\n  std::vector<StringTableFixup> StringTableFixups;\n\n  std::vector<codeview::DebugSubsectionRecordBuilder> C13Builders;\n\n  ModuleInfoHeader Layout;\n};\n\n} // end namespace pdb\n\n} // end namespace llvm\n\n#endif // LLVM_DEBUGINFO_PDB_NATIVE_DBIMODULEDESCRIPTORBUILDER_H\n"}, "50": {"id": 50, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/DebugInfo/PDB/Native/DbiStreamBuilder.h", "content": "//===- DbiStreamBuilder.h - PDB Dbi Stream Creation -------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_DEBUGINFO_PDB_NATIVE_DBISTREAMBUILDER_H\n#define LLVM_DEBUGINFO_PDB_NATIVE_DBISTREAMBUILDER_H\n\n#include \"llvm/ADT/Optional.h\"\n#include \"llvm/ADT/StringSet.h\"\n#include \"llvm/BinaryFormat/COFF.h\"\n#include \"llvm/Support/Error.h\"\n\n#include \"llvm/DebugInfo/CodeView/DebugFrameDataSubsection.h\"\n#include \"llvm/DebugInfo/PDB/Native/PDBFile.h\"\n#include \"llvm/DebugInfo/PDB/Native/PDBStringTableBuilder.h\"\n#include \"llvm/DebugInfo/PDB/Native/RawConstants.h\"\n#include \"llvm/DebugInfo/PDB/PDBTypes.h\"\n#include \"llvm/Support/BinaryByteStream.h\"\n#include \"llvm/Support/BinaryStreamReader.h\"\n#include \"llvm/Support/Endian.h\"\n\nnamespace llvm {\nnamespace codeview {\nstruct FrameData;\n}\nnamespace msf {\nclass MSFBuilder;\n}\nnamespace object {\nstruct coff_section;\nstruct FpoData;\n}\nnamespace pdb {\nclass DbiStream;\nstruct DbiStreamHeader;\nclass DbiModuleDescriptorBuilder;\nclass PDBFile;\n\nclass DbiStreamBuilder {\npublic:\n  DbiStreamBuilder(msf::MSFBuilder &Msf);\n  ~DbiStreamBuilder();\n\n  DbiStreamBuilder(const DbiStreamBuilder &) = delete;\n  DbiStreamBuilder &operator=(const DbiStreamBuilder &) = delete;\n\n  void setVersionHeader(PdbRaw_DbiVer V);\n  void setAge(uint32_t A);\n  void setBuildNumber(uint16_t B);\n  void setBuildNumber(uint8_t Major, uint8_t Minor);\n  void setPdbDllVersion(uint16_t V);\n  void setPdbDllRbld(uint16_t R);\n  void setFlags(uint16_t F);\n  void setMachineType(PDB_Machine M);\n  void setMachineType(COFF::MachineTypes M);\n\n  // Add given bytes as a new stream.\n  Error addDbgStream(pdb::DbgHeaderType Type, ArrayRef<uint8_t> Data);\n\n  uint32_t addECName(StringRef Name);\n\n  uint32_t calculateSerializedLength() const;\n\n  void setGlobalsStreamIndex(uint32_t Index);\n  void setPublicsStreamIndex(uint32_t Index);\n  void setSymbolRecordStreamIndex(uint32_t Index);\n  void addNewFpoData(const codeview::FrameData &FD);\n  void addOldFpoData(const object::FpoData &Fpo);\n\n  Expected<DbiModuleDescriptorBuilder &> addModuleInfo(StringRef ModuleName);\n  Error addModuleSourceFile(DbiModuleDescriptorBuilder &Module, StringRef File);\n  Expected<uint32_t> getSourceFileNameIndex(StringRef FileName);\n\n  Error finalizeMsfLayout();\n\n  Error commit(const msf::MSFLayout &Layout, WritableBinaryStreamRef MsfBuffer);\n\n  void addSectionContrib(const SectionContrib &SC) {\n    SectionContribs.emplace_back(SC);\n  }\n\n  // Populate the Section Map from COFF section headers.\n  void createSectionMap(ArrayRef<llvm::object::coff_section> SecHdrs);\n\nprivate:\n  struct DebugStream {\n    std::function<Error(BinaryStreamWriter &)> WriteFn;\n    uint32_t Size = 0;\n    uint16_t StreamNumber = kInvalidStreamIndex;\n  };\n\n  Error finalize();\n  uint32_t calculateModiSubstreamSize() const;\n  uint32_t calculateNamesOffset() const;\n  uint32_t calculateSectionContribsStreamSize() const;\n  uint32_t calculateSectionMapStreamSize() const;\n  uint32_t calculateFileInfoSubstreamSize() const;\n  uint32_t calculateNamesBufferSize() const;\n  uint32_t calculateDbgStreamsSize() const;\n\n  Error generateFileInfoSubstream();\n\n  msf::MSFBuilder &Msf;\n  BumpPtrAllocator &Allocator;\n\n  Optional<PdbRaw_DbiVer> VerHeader;\n  uint32_t Age;\n  uint16_t BuildNumber;\n  uint16_t PdbDllVersion;\n  uint16_t PdbDllRbld;\n  uint16_t Flags;\n  PDB_Machine MachineType;\n  uint32_t GlobalsStreamIndex = kInvalidStreamIndex;\n  uint32_t PublicsStreamIndex = kInvalidStreamIndex;\n  uint32_t SymRecordStreamIndex = kInvalidStreamIndex;\n\n  const DbiStreamHeader *Header;\n\n  std::vector<std::unique_ptr<DbiModuleDescriptorBuilder>> ModiList;\n\n  Optional<codeview::DebugFrameDataSubsection> NewFpoData;\n  std::vector<object::FpoData> OldFpoData;\n\n  StringMap<uint32_t> SourceFileNames;\n\n  PDBStringTableBuilder ECNamesBuilder;\n  WritableBinaryStreamRef NamesBuffer;\n  MutableBinaryByteStream FileInfoBuffer;\n  std::vector<SectionContrib> SectionContribs;\n  std::vector<SecMapEntry> SectionMap;\n  std::array<Optional<DebugStream>, (int)DbgHeaderType::Max> DbgStreams;\n};\n}\n}\n\n#endif\n"}, "51": {"id": 51, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/DebugInfo/PDB/Native/HashTable.h", "content": "//===- HashTable.h - PDB Hash Table -----------------------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_DEBUGINFO_PDB_NATIVE_HASHTABLE_H\n#define LLVM_DEBUGINFO_PDB_NATIVE_HASHTABLE_H\n\n#include \"llvm/ADT/SparseBitVector.h\"\n#include \"llvm/ADT/iterator.h\"\n#include \"llvm/DebugInfo/PDB/Native/RawError.h\"\n#include \"llvm/Support/BinaryStreamReader.h\"\n#include \"llvm/Support/BinaryStreamWriter.h\"\n#include \"llvm/Support/Endian.h\"\n#include \"llvm/Support/Error.h\"\n#include <cstdint>\n#include <iterator>\n#include <utility>\n#include <vector>\n\nnamespace llvm {\n\nclass BinaryStreamReader;\nclass BinaryStreamWriter;\n\nnamespace pdb {\n\nError readSparseBitVector(BinaryStreamReader &Stream, SparseBitVector<> &V);\nError writeSparseBitVector(BinaryStreamWriter &Writer, SparseBitVector<> &Vec);\n\ntemplate <typename ValueT> class HashTable;\n\ntemplate <typename ValueT>\nclass HashTableIterator\n    : public iterator_facade_base<HashTableIterator<ValueT>,\n                                  std::forward_iterator_tag,\n                                  const std::pair<uint32_t, ValueT>> {\n  friend HashTable<ValueT>;\n\n  HashTableIterator(const HashTable<ValueT> &Map, uint32_t Index,\n                    bool IsEnd)\n      : Map(&Map), Index(Index), IsEnd(IsEnd) {}\n\npublic:\n  HashTableIterator(const HashTable<ValueT> &Map) : Map(&Map) {\n    int I = Map.Present.find_first();\n    if (I == -1) {\n      Index = 0;\n      IsEnd = true;\n    } else {\n      Index = static_cast<uint32_t>(I);\n      IsEnd = false;\n    }\n  }\n\n  HashTableIterator(const HashTableIterator &R) = default;\n  HashTableIterator &operator=(const HashTableIterator &R) {\n    Map = R.Map;\n    return *this;\n  }\n  bool operator==(const HashTableIterator &R) const {\n    if (IsEnd && R.IsEnd)\n      return true;\n    if (IsEnd != R.IsEnd)\n      return false;\n\n    return (Map == R.Map) && (Index == R.Index);\n  }\n  const std::pair<uint32_t, ValueT> &operator*() const {\n    assert(Map->Present.test(Index));\n    return Map->Buckets[Index];\n  }\n\n  // Implement postfix op++ in terms of prefix op++ by using the superclass\n  // implementation.\n  using iterator_facade_base<HashTableIterator<ValueT>,\n                             std::forward_iterator_tag,\n                             const std::pair<uint32_t, ValueT>>::operator++;\n  HashTableIterator &operator++() {\n    while (Index < Map->Buckets.size()) {\n      ++Index;\n      if (Map->Present.test(Index))\n        return *this;\n    }\n\n    IsEnd = true;\n    return *this;\n  }\n\nprivate:\n  bool isEnd() const { return IsEnd; }\n  uint32_t index() const { return Index; }\n\n  const HashTable<ValueT> *Map;\n  uint32_t Index;\n  bool IsEnd;\n};\n\ntemplate <typename ValueT>\nclass HashTable {\n  struct Header {\n    support::ulittle32_t Size;\n    support::ulittle32_t Capacity;\n  };\n\n  using BucketList = std::vector<std::pair<uint32_t, ValueT>>;\n\npublic:\n  using const_iterator = HashTableIterator<ValueT>;\n  friend const_iterator;\n\n  HashTable() { Buckets.resize(8); }\n  explicit HashTable(uint32_t Capacity) {\n    Buckets.resize(Capacity);\n  }\n\n  Error load(BinaryStreamReader &Stream) {\n    const Header *H;\n    if (auto EC = Stream.readObject(H))\n      return EC;\n    if (H->Capacity == 0)\n      return make_error<RawError>(raw_error_code::corrupt_file,\n                                  \"Invalid Hash Table Capacity\");\n    if (H->Size > maxLoad(H->Capacity))\n      return make_error<RawError>(raw_error_code::corrupt_file,\n                                  \"Invalid Hash Table Size\");\n\n    Buckets.resize(H->Capacity);\n\n    if (auto EC = readSparseBitVector(Stream, Present))\n      return EC;\n    if (Present.count() != H->Size)\n      return make_error<RawError>(raw_error_code::corrupt_file,\n                                  \"Present bit vector does not match size!\");\n\n    if (auto EC = readSparseBitVector(Stream, Deleted))\n      return EC;\n    if (Present.intersects(Deleted))\n      return make_error<RawError>(raw_error_code::corrupt_file,\n                                  \"Present bit vector intersects deleted!\");\n\n    for (uint32_t P : Present) {\n      if (auto EC = Stream.readInteger(Buckets[P].first))\n        return EC;\n      const ValueT *Value;\n      if (auto EC = Stream.readObject(Value))\n        return EC;\n      Buckets[P].second = *Value;\n    }\n\n    return Error::success();\n  }\n\n  uint32_t calculateSerializedLength() const {\n    uint32_t Size = sizeof(Header);\n\n    constexpr int BitsPerWord = 8 * sizeof(uint32_t);\n\n    int NumBitsP = Present.find_last() + 1;\n    int NumBitsD = Deleted.find_last() + 1;\n\n    uint32_t NumWordsP = alignTo(NumBitsP, BitsPerWord) / BitsPerWord;\n    uint32_t NumWordsD = alignTo(NumBitsD, BitsPerWord) / BitsPerWord;\n\n    // Present bit set number of words (4 bytes), followed by that many actual\n    // words (4 bytes each).\n    Size += sizeof(uint32_t);\n    Size += NumWordsP * sizeof(uint32_t);\n\n    // Deleted bit set number of words (4 bytes), followed by that many actual\n    // words (4 bytes each).\n    Size += sizeof(uint32_t);\n    Size += NumWordsD * sizeof(uint32_t);\n\n    // One (Key, ValueT) pair for each entry Present.\n    Size += (sizeof(uint32_t) + sizeof(ValueT)) * size();\n\n    return Size;\n  }\n\n  Error commit(BinaryStreamWriter &Writer) const {\n    Header H;\n    H.Size = size();\n    H.Capacity = capacity();\n    if (auto EC = Writer.writeObject(H))\n      return EC;\n\n    if (auto EC = writeSparseBitVector(Writer, Present))\n      return EC;\n\n    if (auto EC = writeSparseBitVector(Writer, Deleted))\n      return EC;\n\n    for (const auto &Entry : *this) {\n      if (auto EC = Writer.writeInteger(Entry.first))\n        return EC;\n      if (auto EC = Writer.writeObject(Entry.second))\n        return EC;\n    }\n    return Error::success();\n  }\n\n  void clear() {\n    Buckets.resize(8);\n    Present.clear();\n    Deleted.clear();\n  }\n\n  bool empty() const { return size() == 0; }\n  uint32_t capacity() const { return Buckets.size(); }\n  uint32_t size() const { return Present.count(); }\n\n  const_iterator begin() const { return const_iterator(*this); }\n  const_iterator end() const { return const_iterator(*this, 0, true); }\n\n  /// Find the entry whose key has the specified hash value, using the specified\n  /// traits defining hash function and equality.\n  template <typename Key, typename TraitsT>\n  const_iterator find_as(const Key &K, TraitsT &Traits) const {\n    uint32_t H = Traits.hashLookupKey(K) % capacity();\n    uint32_t I = H;\n    Optional<uint32_t> FirstUnused;\n    do {\n      if (isPresent(I)) {\n        if (Traits.storageKeyToLookupKey(Buckets[I].first) == K)\n          return const_iterator(*this, I, false);\n      } else {\n        if (!FirstUnused)\n          FirstUnused = I;\n        // Insertion occurs via linear probing from the slot hint, and will be\n        // inserted at the first empty / deleted location.  Therefore, if we are\n        // probing and find a location that is neither present nor deleted, then\n        // nothing must have EVER been inserted at this location, and thus it is\n        // not possible for a matching value to occur later.\n        if (!isDeleted(I))\n          break;\n      }\n      I = (I + 1) % capacity();\n    } while (I != H);\n\n    // The only way FirstUnused would not be set is if every single entry in the\n    // table were Present.  But this would violate the load factor constraints\n    // that we impose, so it should never happen.\n    assert(FirstUnused);\n    return const_iterator(*this, *FirstUnused, true);\n  }\n\n  /// Set the entry using a key type that the specified Traits can convert\n  /// from a real key to an internal key.\n  template <typename Key, typename TraitsT>\n  bool set_as(const Key &K, ValueT V, TraitsT &Traits) {\n    return set_as_internal(K, std::move(V), Traits, None);\n  }\n\n  template <typename Key, typename TraitsT>\n  ValueT get(const Key &K, TraitsT &Traits) const {\n    auto Iter = find_as(K, Traits);\n    assert(Iter != end());\n    return (*Iter).second;\n  }\n\nprotected:\n  bool isPresent(uint32_t K) const { return Present.test(K); }\n  bool isDeleted(uint32_t K) const { return Deleted.test(K); }\n\n  BucketList Buckets;\n  mutable SparseBitVector<> Present;\n  mutable SparseBitVector<> Deleted;\n\nprivate:\n  /// Set the entry using a key type that the specified Traits can convert\n  /// from a real key to an internal key.\n  template <typename Key, typename TraitsT>\n  bool set_as_internal(const Key &K, ValueT V, TraitsT &Traits,\n                       Optional<uint32_t> InternalKey) {\n    auto Entry = find_as(K, Traits);\n    if (Entry != end()) {\n      assert(isPresent(Entry.index()));\n      assert(Traits.storageKeyToLookupKey(Buckets[Entry.index()].first) == K);\n      // We're updating, no need to do anything special.\n      Buckets[Entry.index()].second = V;\n      return false;\n    }\n\n    auto &B = Buckets[Entry.index()];\n    assert(!isPresent(Entry.index()));\n    assert(Entry.isEnd());\n    B.first = InternalKey ? *InternalKey : Traits.lookupKeyToStorageKey(K);\n    B.second = V;\n    Present.set(Entry.index());\n    Deleted.reset(Entry.index());\n\n    grow(Traits);\n\n    assert((find_as(K, Traits)) != end());\n    return true;\n  }\n\n  static uint32_t maxLoad(uint32_t capacity) { return capacity * 2 / 3 + 1; }\n\n  template <typename TraitsT>\n  void grow(TraitsT &Traits) {\n    uint32_t S = size();\n    uint32_t MaxLoad = maxLoad(capacity());\n    if (S < maxLoad(capacity()))\n      return;\n    assert(capacity() != UINT32_MAX && \"Can't grow Hash table!\");\n\n    uint32_t NewCapacity = (capacity() <= INT32_MAX) ? MaxLoad * 2 : UINT32_MAX;\n\n    // Growing requires rebuilding the table and re-hashing every item.  Make a\n    // copy with a larger capacity, insert everything into the copy, then swap\n    // it in.\n    HashTable NewMap(NewCapacity);\n    for (auto I : Present) {\n      auto LookupKey = Traits.storageKeyToLookupKey(Buckets[I].first);\n      NewMap.set_as_internal(LookupKey, Buckets[I].second, Traits,\n                             Buckets[I].first);\n    }\n\n    Buckets.swap(NewMap.Buckets);\n    std::swap(Present, NewMap.Present);\n    std::swap(Deleted, NewMap.Deleted);\n    assert(capacity() == NewCapacity);\n    assert(size() == S);\n  }\n};\n\n} // end namespace pdb\n\n} // end namespace llvm\n\n#endif // LLVM_DEBUGINFO_PDB_NATIVE_HASHTABLE_H\n"}, "52": {"id": 52, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/DebugInfo/PDB/Native/NamedStreamMap.h", "content": "//===- NamedStreamMap.h - PDB Named Stream Map ------------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_DEBUGINFO_PDB_NATIVE_NAMEDSTREAMMAP_H\n#define LLVM_DEBUGINFO_PDB_NATIVE_NAMEDSTREAMMAP_H\n\n#include \"llvm/ADT/Optional.h\"\n#include \"llvm/ADT/StringMap.h\"\n#include \"llvm/ADT/StringRef.h\"\n#include \"llvm/ADT/iterator_range.h\"\n#include \"llvm/DebugInfo/PDB/Native/HashTable.h\"\n#include \"llvm/Support/Error.h\"\n#include <cstdint>\n\nnamespace llvm {\n\nclass BinaryStreamReader;\nclass BinaryStreamWriter;\n\nnamespace pdb {\n\nclass NamedStreamMap;\n\nstruct NamedStreamMapTraits {\n  NamedStreamMap *NS;\n\n  explicit NamedStreamMapTraits(NamedStreamMap &NS);\n  uint16_t hashLookupKey(StringRef S) const;\n  StringRef storageKeyToLookupKey(uint32_t Offset) const;\n  uint32_t lookupKeyToStorageKey(StringRef S);\n};\n\nclass NamedStreamMap {\n  friend class NamedStreamMapBuilder;\n\npublic:\n  NamedStreamMap();\n\n  Error load(BinaryStreamReader &Stream);\n  Error commit(BinaryStreamWriter &Writer) const;\n  uint32_t calculateSerializedLength() const;\n\n  uint32_t size() const;\n  bool get(StringRef Stream, uint32_t &StreamNo) const;\n  void set(StringRef Stream, uint32_t StreamNo);\n\n  uint32_t appendStringData(StringRef S);\n  StringRef getString(uint32_t Offset) const;\n  uint32_t hashString(uint32_t Offset) const;\n\n  StringMap<uint32_t> entries() const;\n\nprivate:\n  NamedStreamMapTraits HashTraits;\n  /// Closed hash table from Offset -> StreamNumber, where Offset is the offset\n  /// of the stream name in NamesBuffer.\n  HashTable<support::ulittle32_t> OffsetIndexMap;\n\n  /// Buffer of string data.\n  std::vector<char> NamesBuffer;\n};\n\n} // end namespace pdb\n\n} // end namespace llvm\n\n#endif // LLVM_DEBUGINFO_PDB_NATIVE_NAMEDSTREAMMAP_H\n"}, "54": {"id": 54, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/DebugInfo/PDB/Native/PDBFileBuilder.h", "content": "//===- PDBFileBuilder.h - PDB File Creation ---------------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_DEBUGINFO_PDB_NATIVE_PDBFILEBUILDER_H\n#define LLVM_DEBUGINFO_PDB_NATIVE_PDBFILEBUILDER_H\n\n#include \"llvm/ADT/ArrayRef.h\"\n#include \"llvm/ADT/Optional.h\"\n#include \"llvm/ADT/SmallVector.h\"\n#include \"llvm/DebugInfo/PDB/Native/NamedStreamMap.h\"\n#include \"llvm/DebugInfo/PDB/Native/PDBFile.h\"\n#include \"llvm/DebugInfo/PDB/Native/PDBStringTableBuilder.h\"\n#include \"llvm/DebugInfo/PDB/Native/RawConstants.h\"\n#include \"llvm/DebugInfo/PDB/Native/RawTypes.h\"\n#include \"llvm/Support/Allocator.h\"\n#include \"llvm/Support/Endian.h\"\n#include \"llvm/Support/Error.h\"\n#include \"llvm/Support/MemoryBuffer.h\"\n#include <memory>\n\nnamespace llvm {\nnamespace msf {\nclass MSFBuilder;\n}\nnamespace pdb {\nclass DbiStreamBuilder;\nclass InfoStreamBuilder;\nclass GSIStreamBuilder;\nclass TpiStreamBuilder;\n\nclass PDBFileBuilder {\npublic:\n  explicit PDBFileBuilder(BumpPtrAllocator &Allocator);\n  ~PDBFileBuilder();\n  PDBFileBuilder(const PDBFileBuilder &) = delete;\n  PDBFileBuilder &operator=(const PDBFileBuilder &) = delete;\n\n  Error initialize(uint32_t BlockSize);\n\n  msf::MSFBuilder &getMsfBuilder();\n  InfoStreamBuilder &getInfoBuilder();\n  DbiStreamBuilder &getDbiBuilder();\n  TpiStreamBuilder &getTpiBuilder();\n  TpiStreamBuilder &getIpiBuilder();\n  PDBStringTableBuilder &getStringTableBuilder();\n  GSIStreamBuilder &getGsiBuilder();\n\n  // If HashPDBContentsToGUID is true on the InfoStreamBuilder, Guid is filled\n  // with the computed PDB GUID on return.\n  Error commit(StringRef Filename, codeview::GUID *Guid);\n\n  Expected<uint32_t> getNamedStreamIndex(StringRef Name) const;\n  Error addNamedStream(StringRef Name, StringRef Data);\n  void addInjectedSource(StringRef Name, std::unique_ptr<MemoryBuffer> Buffer);\n\nprivate:\n  struct InjectedSourceDescriptor {\n    // The full name of the stream that contains the contents of this injected\n    // source.  This is built as a concatenation of the literal \"/src/files\"\n    // plus the \"vname\".\n    std::string StreamName;\n\n    // The exact name of the file name as specified by the user.\n    uint32_t NameIndex;\n\n    // The string table index of the \"vname\" of the file.  As far as we\n    // understand, this is the same as the name, except it is lowercased and\n    // forward slashes are converted to backslashes.\n    uint32_t VNameIndex;\n    std::unique_ptr<MemoryBuffer> Content;\n  };\n\n  Error finalizeMsfLayout();\n  Expected<uint32_t> allocateNamedStream(StringRef Name, uint32_t Size);\n\n  void commitInjectedSources(WritableBinaryStream &MsfBuffer,\n                             const msf::MSFLayout &Layout);\n  void commitSrcHeaderBlock(WritableBinaryStream &MsfBuffer,\n                            const msf::MSFLayout &Layout);\n\n  BumpPtrAllocator &Allocator;\n\n  std::unique_ptr<msf::MSFBuilder> Msf;\n  std::unique_ptr<InfoStreamBuilder> Info;\n  std::unique_ptr<DbiStreamBuilder> Dbi;\n  std::unique_ptr<GSIStreamBuilder> Gsi;\n  std::unique_ptr<TpiStreamBuilder> Tpi;\n  std::unique_ptr<TpiStreamBuilder> Ipi;\n\n  PDBStringTableBuilder Strings;\n  StringTableHashTraits InjectedSourceHashTraits;\n  HashTable<SrcHeaderBlockEntry> InjectedSourceTable;\n\n  SmallVector<InjectedSourceDescriptor, 2> InjectedSources;\n\n  NamedStreamMap NamedStreams;\n  DenseMap<uint32_t, std::string> NamedStreamData;\n};\n}\n}\n\n#endif\n"}, "55": {"id": 55, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/DebugInfo/PDB/Native/PDBStringTableBuilder.h", "content": "//===- PDBStringTableBuilder.h - PDB String Table Builder -------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// This file creates the \"/names\" stream.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_DEBUGINFO_PDB_NATIVE_PDBSTRINGTABLEBUILDER_H\n#define LLVM_DEBUGINFO_PDB_NATIVE_PDBSTRINGTABLEBUILDER_H\n\n#include \"llvm/ADT/StringRef.h\"\n#include \"llvm/DebugInfo/CodeView/DebugStringTableSubsection.h\"\n#include \"llvm/Support/Error.h\"\n#include <cstdint>\n\nnamespace llvm {\nclass BinaryStreamWriter;\nclass WritableBinaryStreamRef;\n\nnamespace msf {\nstruct MSFLayout;\n}\n\nnamespace pdb {\n\nclass PDBFileBuilder;\nclass PDBStringTableBuilder;\n\nstruct StringTableHashTraits {\n  PDBStringTableBuilder *Table;\n\n  explicit StringTableHashTraits(PDBStringTableBuilder &Table);\n  uint32_t hashLookupKey(StringRef S) const;\n  StringRef storageKeyToLookupKey(uint32_t Offset) const;\n  uint32_t lookupKeyToStorageKey(StringRef S);\n};\n\nclass PDBStringTableBuilder {\npublic:\n  // If string S does not exist in the string table, insert it.\n  // Returns the ID for S.\n  uint32_t insert(StringRef S);\n\n  uint32_t getIdForString(StringRef S) const;\n  StringRef getStringForId(uint32_t Id) const;\n\n  uint32_t calculateSerializedSize() const;\n  Error commit(BinaryStreamWriter &Writer) const;\n\n  void setStrings(const codeview::DebugStringTableSubsection &Strings);\n\nprivate:\n  uint32_t calculateHashTableSize() const;\n  Error writeHeader(BinaryStreamWriter &Writer) const;\n  Error writeStrings(BinaryStreamWriter &Writer) const;\n  Error writeHashTable(BinaryStreamWriter &Writer) const;\n  Error writeEpilogue(BinaryStreamWriter &Writer) const;\n\n  codeview::DebugStringTableSubsection Strings;\n};\n\n} // end namespace pdb\n} // end namespace llvm\n\n#endif // LLVM_DEBUGINFO_PDB_NATIVE_PDBSTRINGTABLEBUILDER_H\n"}, "57": {"id": 57, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/DebugInfo/PDB/Native/RawTypes.h", "content": "//===- RawTypes.h -----------------------------------------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_DEBUGINFO_PDB_NATIVE_RAWTYPES_H\n#define LLVM_DEBUGINFO_PDB_NATIVE_RAWTYPES_H\n\n#include \"llvm/DebugInfo/CodeView/GUID.h\"\n#include \"llvm/DebugInfo/CodeView/TypeRecord.h\"\n#include \"llvm/Support/Endian.h\"\n\nnamespace llvm {\nnamespace pdb {\n// This struct is defined as \"SO\" in langapi/include/pdb.h.\nstruct SectionOffset {\n  support::ulittle32_t Off;\n  support::ulittle16_t Isect;\n  char Padding[2];\n};\n\n/// Header of the hash tables found in the globals and publics sections.\n/// Based on GSIHashHdr in\n/// https://github.com/Microsoft/microsoft-pdb/blob/master/PDB/dbi/gsi.h\nstruct GSIHashHeader {\n  enum : unsigned {\n    HdrSignature = ~0U,\n    HdrVersion = 0xeffe0000 + 19990810,\n  };\n  support::ulittle32_t VerSignature;\n  support::ulittle32_t VerHdr;\n  support::ulittle32_t HrSize;\n  support::ulittle32_t NumBuckets;\n};\n\n// This is HRFile.\nstruct PSHashRecord {\n  support::ulittle32_t Off; // Offset in the symbol record stream\n  support::ulittle32_t CRef;\n};\n\n// This struct is defined as `SC` in include/dbicommon.h\nstruct SectionContrib {\n  support::ulittle16_t ISect;\n  char Padding[2];\n  support::little32_t Off;\n  support::little32_t Size;\n  support::ulittle32_t Characteristics;\n  support::ulittle16_t Imod;\n  char Padding2[2];\n  support::ulittle32_t DataCrc;\n  support::ulittle32_t RelocCrc;\n};\n\n// This struct is defined as `SC2` in include/dbicommon.h\nstruct SectionContrib2 {\n  // To guarantee SectionContrib2 is standard layout, we cannot use inheritance.\n  SectionContrib Base;\n  support::ulittle32_t ISectCoff;\n};\n\n// This corresponds to the `OMFSegMap` structure.\nstruct SecMapHeader {\n  support::ulittle16_t SecCount;    // Number of segment descriptors in table\n  support::ulittle16_t SecCountLog; // Number of logical segment descriptors\n};\n\n// This corresponds to the `OMFSegMapDesc` structure.  The definition is not\n// present in the reference implementation, but the layout is derived from\n// code that accesses the fields.\nstruct SecMapEntry {\n  support::ulittle16_t Flags; // Descriptor flags.  See OMFSegDescFlags\n  support::ulittle16_t Ovl;   // Logical overlay number.\n  support::ulittle16_t Group; // Group index into descriptor array.\n  support::ulittle16_t Frame;\n  support::ulittle16_t SecName;       // Byte index of the segment or group name\n                                      // in the sstSegName table, or 0xFFFF.\n  support::ulittle16_t ClassName;     // Byte index of the class name in the\n                                      // sstSegName table, or 0xFFFF.\n  support::ulittle32_t Offset;        // Byte offset of the logical segment\n                                      // within the specified physical segment.\n                                      // If group is set in flags, offset is the\n                                      // offset of the group.\n  support::ulittle32_t SecByteLength; // Byte count of the segment or group.\n};\n\n/// Some of the values are stored in bitfields.  Since this needs to be portable\n/// across compilers and architectures (big / little endian in particular) we\n/// can't use the actual structures below, but must instead do the shifting\n/// and masking ourselves.  The struct definitions are provided for reference.\nstruct DbiFlags {\n  ///  uint16_t IncrementalLinking : 1; // True if linked incrementally\n  ///  uint16_t IsStripped : 1;         // True if private symbols were\n  ///  stripped.\n  ///  uint16_t HasCTypes : 1;          // True if linked with /debug:ctypes.\n  ///  uint16_t Reserved : 13;\n  static const uint16_t FlagIncrementalMask = 0x0001;\n  static const uint16_t FlagStrippedMask = 0x0002;\n  static const uint16_t FlagHasCTypesMask = 0x0004;\n};\n\nstruct DbiBuildNo {\n  ///  uint16_t MinorVersion : 8;\n  ///  uint16_t MajorVersion : 7;\n  ///  uint16_t NewVersionFormat : 1;\n  static const uint16_t BuildMinorMask = 0x00FF;\n  static const uint16_t BuildMinorShift = 0;\n\n  static const uint16_t BuildMajorMask = 0x7F00;\n  static const uint16_t BuildMajorShift = 8;\n\n  static const uint16_t NewVersionFormatMask = 0x8000;\n};\n\n/// The fixed size header that appears at the beginning of the DBI Stream.\nstruct DbiStreamHeader {\n  support::little32_t VersionSignature;\n  support::ulittle32_t VersionHeader;\n\n  /// How \"old\" is this DBI Stream. Should match the age of the PDB InfoStream.\n  support::ulittle32_t Age;\n\n  /// Global symbol stream #\n  support::ulittle16_t GlobalSymbolStreamIndex;\n\n  /// See DbiBuildNo structure.\n  support::ulittle16_t BuildNumber;\n\n  /// Public symbols stream #\n  support::ulittle16_t PublicSymbolStreamIndex;\n\n  /// version of mspdbNNN.dll\n  support::ulittle16_t PdbDllVersion;\n\n  /// Symbol records stream #\n  support::ulittle16_t SymRecordStreamIndex;\n\n  /// rbld number of mspdbNNN.dll\n  support::ulittle16_t PdbDllRbld;\n\n  /// Size of module info stream\n  support::little32_t ModiSubstreamSize;\n\n  /// Size of sec. contrib stream\n  support::little32_t SecContrSubstreamSize;\n\n  /// Size of sec. map substream\n  support::little32_t SectionMapSize;\n\n  /// Size of file info substream\n  support::little32_t FileInfoSize;\n\n  /// Size of type server map\n  support::little32_t TypeServerSize;\n\n  /// Index of MFC Type Server\n  support::ulittle32_t MFCTypeServerIndex;\n\n  /// Size of DbgHeader info\n  support::little32_t OptionalDbgHdrSize;\n\n  /// Size of EC stream (what is EC?)\n  support::little32_t ECSubstreamSize;\n\n  /// See DbiFlags enum.\n  support::ulittle16_t Flags;\n\n  /// See PDB_MachineType enum.\n  support::ulittle16_t MachineType;\n\n  /// Pad to 64 bytes\n  support::ulittle32_t Reserved;\n};\nstatic_assert(sizeof(DbiStreamHeader) == 64, \"Invalid DbiStreamHeader size!\");\n\n/// The header preceding the File Info Substream of the DBI stream.\nstruct FileInfoSubstreamHeader {\n  /// Total # of modules, should match number of records in the ModuleInfo\n  /// substream.\n  support::ulittle16_t NumModules;\n\n  /// Total # of source files. This value is not accurate because PDB actually\n  /// supports more than 64k source files, so we ignore it and compute the value\n  /// from other stream fields.\n  support::ulittle16_t NumSourceFiles;\n\n  /// Following this header the File Info Substream is laid out as follows:\n  ///   ulittle16_t ModIndices[NumModules];\n  ///   ulittle16_t ModFileCounts[NumModules];\n  ///   ulittle32_t FileNameOffsets[NumSourceFiles];\n  ///   char Names[][NumSourceFiles];\n  /// with the caveat that `NumSourceFiles` cannot be trusted, so\n  /// it is computed by summing the `ModFileCounts` array.\n};\n\nstruct ModInfoFlags {\n  ///  uint16_t fWritten : 1;   // True if DbiModuleDescriptor is dirty\n  ///  uint16_t fECEnabled : 1; // Is EC symbolic info present?  (What is EC?)\n  ///  uint16_t unused : 6;     // Reserved\n  ///  uint16_t iTSM : 8;       // Type Server Index for this module\n  static const uint16_t HasECFlagMask = 0x2;\n\n  static const uint16_t TypeServerIndexMask = 0xFF00;\n  static const uint16_t TypeServerIndexShift = 8;\n};\n\n/// The header preceding each entry in the Module Info substream of the DBI\n/// stream.  Corresponds to the type MODI in the reference implementation.\nstruct ModuleInfoHeader {\n  /// Currently opened module. This field is a pointer in the reference\n  /// implementation, but that won't work on 64-bit systems, and anyway it\n  /// doesn't make sense to read a pointer from a file. For now it is unused,\n  /// so just ignore it.\n  support::ulittle32_t Mod;\n\n  /// First section contribution of this module.\n  SectionContrib SC;\n\n  /// See ModInfoFlags definition.\n  support::ulittle16_t Flags;\n\n  /// Stream Number of module debug info\n  support::ulittle16_t ModDiStream;\n\n  /// Size of local symbol debug info in above stream\n  support::ulittle32_t SymBytes;\n\n  /// Size of C11 line number info in above stream\n  support::ulittle32_t C11Bytes;\n\n  /// Size of C13 line number info in above stream\n  support::ulittle32_t C13Bytes;\n\n  /// Number of files contributing to this module\n  support::ulittle16_t NumFiles;\n\n  /// Padding so the next field is 4-byte aligned.\n  char Padding1[2];\n\n  /// Array of [0..NumFiles) DBI name buffer offsets.  In the reference\n  /// implementation this field is a pointer.  But since you can't portably\n  /// serialize a pointer, on 64-bit platforms they copy all the values except\n  /// this one into the 32-bit version of the struct and use that for\n  /// serialization.  Regardless, this field is unused, it is only there to\n  /// store a pointer that can be accessed at runtime.\n  support::ulittle32_t FileNameOffs;\n\n  /// Name Index for src file name\n  support::ulittle32_t SrcFileNameNI;\n\n  /// Name Index for path to compiler PDB\n  support::ulittle32_t PdbFilePathNI;\n\n  /// Following this header are two zero terminated strings.\n  /// char ModuleName[];\n  /// char ObjFileName[];\n};\n\n// This is PSGSIHDR struct defined in\n// https://github.com/Microsoft/microsoft-pdb/blob/master/PDB/dbi/gsi.h\nstruct PublicsStreamHeader {\n  support::ulittle32_t SymHash;\n  support::ulittle32_t AddrMap;\n  support::ulittle32_t NumThunks;\n  support::ulittle32_t SizeOfThunk;\n  support::ulittle16_t ISectThunkTable;\n  char Padding[2];\n  support::ulittle32_t OffThunkTable;\n  support::ulittle32_t NumSections;\n};\n\n// The header preceding the global TPI stream.\n// This corresponds to `HDR` in PDB/dbi/tpi.h.\nstruct TpiStreamHeader {\n  struct EmbeddedBuf {\n    support::little32_t Off;\n    support::ulittle32_t Length;\n  };\n\n  support::ulittle32_t Version;\n  support::ulittle32_t HeaderSize;\n  support::ulittle32_t TypeIndexBegin;\n  support::ulittle32_t TypeIndexEnd;\n  support::ulittle32_t TypeRecordBytes;\n\n  // The following members correspond to `TpiHash` in PDB/dbi/tpi.h.\n  support::ulittle16_t HashStreamIndex;\n  support::ulittle16_t HashAuxStreamIndex;\n  support::ulittle32_t HashKeySize;\n  support::ulittle32_t NumHashBuckets;\n\n  EmbeddedBuf HashValueBuffer;\n  EmbeddedBuf IndexOffsetBuffer;\n  EmbeddedBuf HashAdjBuffer;\n};\n\nconst uint32_t MinTpiHashBuckets = 0x1000;\nconst uint32_t MaxTpiHashBuckets = 0x40000;\n\n/// The header preceding the global PDB Stream (Stream 1)\nstruct InfoStreamHeader {\n  support::ulittle32_t Version;\n  support::ulittle32_t Signature;\n  support::ulittle32_t Age;\n  codeview::GUID Guid;\n};\n\n/// The header preceding the /names stream.\nstruct PDBStringTableHeader {\n  support::ulittle32_t Signature;   // PDBStringTableSignature\n  support::ulittle32_t HashVersion; // 1 or 2\n  support::ulittle32_t ByteSize;    // Number of bytes of names buffer.\n};\n\nconst uint32_t PDBStringTableSignature = 0xEFFEEFFE;\n\n/// The header preceding the /src/headerblock stream.\nstruct SrcHeaderBlockHeader {\n  support::ulittle32_t Version; // PdbRaw_SrcHeaderBlockVer enumeration.\n  support::ulittle32_t Size;    // Size of entire stream.\n  uint64_t FileTime;            // Time stamp (Windows FILETIME format).\n  support::ulittle32_t Age;     // Age\n  uint8_t Padding[44];          // Pad to 64 bytes.\n};\nstatic_assert(sizeof(SrcHeaderBlockHeader) == 64, \"Incorrect struct size!\");\n\n/// A single file record entry within the /src/headerblock stream.\nstruct SrcHeaderBlockEntry {\n  support::ulittle32_t Size;     // Record Length.\n  support::ulittle32_t Version;  // PdbRaw_SrcHeaderBlockVer enumeration.\n  support::ulittle32_t CRC;      // CRC of the original file contents.\n  support::ulittle32_t FileSize; // Size of original source file.\n  support::ulittle32_t FileNI;   // String table index of file name.\n  support::ulittle32_t ObjNI;    // String table index of object name.\n  support::ulittle32_t VFileNI;  // String table index of virtual file name.\n  uint8_t Compression;           // PDB_SourceCompression enumeration.\n  uint8_t IsVirtual;             // Is this a virtual file (injected)?\n  short Padding;                 // Pad to 4 bytes.\n  char Reserved[8];\n};\nstatic_assert(sizeof(SrcHeaderBlockEntry) == 40, \"Incorrect struct size!\");\n\n} // namespace pdb\n} // namespace llvm\n\n#endif\n"}, "63": {"id": 63, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/DebugInfo/PDB/PDBSymbolPublicSymbol.h", "content": "//===- PDBSymbolPublicSymbol.h - public symbol info -------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_DEBUGINFO_PDB_PDBSYMBOLPUBLICSYMBOL_H\n#define LLVM_DEBUGINFO_PDB_PDBSYMBOLPUBLICSYMBOL_H\n\n#include \"PDBSymbol.h\"\n#include \"PDBTypes.h\"\n\nnamespace llvm {\n\nclass raw_ostream;\nnamespace pdb {\n\nclass PDBSymbolPublicSymbol : public PDBSymbol {\n  DECLARE_PDB_SYMBOL_CONCRETE_TYPE(PDB_SymType::PublicSymbol)\npublic:\n  void dump(PDBSymDumper &Dumper) const override;\n\n  FORWARD_SYMBOL_METHOD(getAddressOffset)\n  FORWARD_SYMBOL_METHOD(getAddressSection)\n  FORWARD_SYMBOL_METHOD(isCode)\n  FORWARD_SYMBOL_METHOD(isFunction)\n  FORWARD_SYMBOL_METHOD(getLength)\n  FORWARD_SYMBOL_ID_METHOD(getLexicalParent)\n  FORWARD_SYMBOL_METHOD(getLocationType)\n  FORWARD_SYMBOL_METHOD(isManagedCode)\n  FORWARD_SYMBOL_METHOD(isMSILCode)\n  FORWARD_SYMBOL_METHOD(getName)\n  FORWARD_SYMBOL_METHOD(getRelativeVirtualAddress)\n  FORWARD_SYMBOL_METHOD(getVirtualAddress)\n  FORWARD_SYMBOL_METHOD(getUndecoratedName)\n};\n\n} // namespace llvm\n}\n\n#endif // LLVM_DEBUGINFO_PDB_PDBSYMBOLPUBLICSYMBOL_H\n"}, "64": {"id": 64, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/DebugInfo/PDB/PDBSymbolThunk.h", "content": "//===- PDBSymbolThunk.h - Support for querying PDB thunks ---------------*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_DEBUGINFO_PDB_PDBSYMBOLTHUNK_H\n#define LLVM_DEBUGINFO_PDB_PDBSYMBOLTHUNK_H\n\n#include \"PDBSymbol.h\"\n#include \"PDBTypes.h\"\n\nnamespace llvm {\n\nclass raw_ostream;\nnamespace pdb {\n\nclass PDBSymbolThunk : public PDBSymbol {\n  DECLARE_PDB_SYMBOL_CONCRETE_TYPE(PDB_SymType::Thunk)\npublic:\n  void dump(PDBSymDumper &Dumper) const override;\n\n  FORWARD_SYMBOL_METHOD(getAccess)\n  FORWARD_SYMBOL_METHOD(getAddressOffset)\n  FORWARD_SYMBOL_METHOD(getAddressSection)\n  FORWARD_SYMBOL_ID_METHOD(getClassParent)\n  FORWARD_SYMBOL_METHOD(isConstType)\n  FORWARD_SYMBOL_METHOD(isIntroVirtualFunction)\n  FORWARD_SYMBOL_METHOD(isStatic)\n  FORWARD_SYMBOL_METHOD(getLength)\n  FORWARD_SYMBOL_ID_METHOD(getLexicalParent)\n  FORWARD_SYMBOL_METHOD(getName)\n  FORWARD_SYMBOL_METHOD(isPureVirtual)\n  FORWARD_SYMBOL_METHOD(getRelativeVirtualAddress)\n  FORWARD_SYMBOL_METHOD(getTargetOffset)\n  FORWARD_SYMBOL_METHOD(getTargetRelativeVirtualAddress)\n  FORWARD_SYMBOL_METHOD(getTargetVirtualAddress)\n  FORWARD_SYMBOL_METHOD(getTargetSection)\n  FORWARD_SYMBOL_METHOD(getThunkOrdinal)\n  FORWARD_SYMBOL_ID_METHOD(getType)\n  FORWARD_SYMBOL_METHOD(isUnalignedType)\n  FORWARD_SYMBOL_METHOD(isVirtual)\n  FORWARD_SYMBOL_METHOD(getVirtualAddress)\n  FORWARD_SYMBOL_METHOD(getVirtualBaseOffset)\n  FORWARD_SYMBOL_METHOD(isVolatileType)\n};\n} // namespace llvm\n}\n\n#endif // LLVM_DEBUGINFO_PDB_PDBSYMBOLTHUNK_H\n"}, "66": {"id": 66, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/DebugInfo/PDB/PDBSymbolTypeEnum.h", "content": "//===- PDBSymbolTypeEnum.h - enum type info ---------------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_DEBUGINFO_PDB_PDBSYMBOLTYPEENUM_H\n#define LLVM_DEBUGINFO_PDB_PDBSYMBOLTYPEENUM_H\n\n#include \"IPDBLineNumber.h\"\n#include \"PDBSymbol.h\"\n#include \"PDBSymbolTypeBuiltin.h\"\n#include \"PDBTypes.h\"\n\nnamespace llvm {\n\nclass raw_ostream;\nnamespace pdb {\n\nclass PDBSymbolTypeEnum : public PDBSymbol {\n  DECLARE_PDB_SYMBOL_CONCRETE_TYPE(PDB_SymType::Enum)\npublic:\n  void dump(PDBSymDumper &Dumper) const override;\n\n  FORWARD_SYMBOL_METHOD(getBuiltinType)\n  FORWARD_SYMBOL_ID_METHOD(getClassParent)\n  FORWARD_SYMBOL_METHOD(hasConstructor)\n  FORWARD_SYMBOL_METHOD(isConstType)\n  FORWARD_SYMBOL_METHOD(hasAssignmentOperator)\n  FORWARD_SYMBOL_METHOD(hasCastOperator)\n  FORWARD_SYMBOL_METHOD(hasNestedTypes)\n  FORWARD_SYMBOL_METHOD(getLength)\n  FORWARD_SYMBOL_ID_METHOD(getLexicalParent)\n  FORWARD_SYMBOL_ID_METHOD(getUnmodifiedType)\n  FORWARD_SYMBOL_METHOD(getName)\n  FORWARD_SYMBOL_METHOD(getSrcLineOnTypeDefn)\n  FORWARD_SYMBOL_METHOD(isNested)\n  FORWARD_SYMBOL_METHOD(hasOverloadedOperator)\n  FORWARD_SYMBOL_METHOD(isPacked)\n  FORWARD_SYMBOL_METHOD(isScoped)\n  FORWARD_CONCRETE_SYMBOL_ID_METHOD_WITH_NAME(PDBSymbolTypeBuiltin, getType,\n                                              getUnderlyingType)\n  FORWARD_SYMBOL_METHOD(isUnalignedType)\n  FORWARD_SYMBOL_METHOD(isVolatileType)\n};\n\n} // namespace llvm\n}\n\n#endif // LLVM_DEBUGINFO_PDB_PDBSYMBOLTYPEENUM_H\n"}, "68": {"id": 68, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/DebugInfo/PDB/PDBSymbolTypeTypedef.h", "content": "//===- PDBSymbolTypeTypedef.h - typedef type info ---------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_DEBUGINFO_PDB_PDBSYMBOLTYPETYPEDEF_H\n#define LLVM_DEBUGINFO_PDB_PDBSYMBOLTYPETYPEDEF_H\n\n#include \"PDBSymbol.h\"\n#include \"PDBTypes.h\"\n\nnamespace llvm {\n\nclass raw_ostream;\nnamespace pdb {\n\nclass PDBSymbolTypeTypedef : public PDBSymbol {\n  DECLARE_PDB_SYMBOL_CONCRETE_TYPE(PDB_SymType::Typedef)\npublic:\n  void dump(PDBSymDumper &Dumper) const override;\n\n  FORWARD_SYMBOL_METHOD(getBuiltinType)\n  FORWARD_SYMBOL_ID_METHOD(getClassParent)\n  FORWARD_SYMBOL_METHOD(hasConstructor)\n  FORWARD_SYMBOL_METHOD(isConstType)\n  FORWARD_SYMBOL_METHOD(hasAssignmentOperator)\n  FORWARD_SYMBOL_METHOD(hasCastOperator)\n  FORWARD_SYMBOL_METHOD(hasNestedTypes)\n  FORWARD_SYMBOL_METHOD(getLength)\n  FORWARD_SYMBOL_ID_METHOD(getLexicalParent)\n  FORWARD_SYMBOL_METHOD(getName)\n  FORWARD_SYMBOL_METHOD(isNested)\n  FORWARD_SYMBOL_METHOD(hasOverloadedOperator)\n  FORWARD_SYMBOL_METHOD(isPacked)\n  FORWARD_SYMBOL_METHOD(isReference)\n  FORWARD_SYMBOL_METHOD(isScoped)\n  FORWARD_SYMBOL_ID_METHOD(getType)\n  FORWARD_SYMBOL_METHOD(getUdtKind)\n  FORWARD_SYMBOL_METHOD(isUnalignedType)\n  FORWARD_SYMBOL_ID_METHOD(getVirtualTableShape)\n  FORWARD_SYMBOL_METHOD(isVolatileType)\n};\n\n} // namespace llvm\n}\n\n#endif // LLVM_DEBUGINFO_PDB_PDBSYMBOLTYPETYPEDEF_H\n"}, "86": {"id": 86, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/CommandLine.h", "content": "//===- llvm/Support/CommandLine.h - Command line handler --------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// This class implements a command line argument processor that is useful when\n// creating a tool.  It provides a simple, minimalistic interface that is easily\n// extensible and supports nonlocal (library) command line options.\n//\n// Note that rather than trying to figure out what this code does, you should\n// read the library documentation located in docs/CommandLine.html or looks at\n// the many example usages in tools/*/*.cpp\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_SUPPORT_COMMANDLINE_H\n#define LLVM_SUPPORT_COMMANDLINE_H\n\n#include \"llvm/ADT/ArrayRef.h\"\n#include \"llvm/ADT/None.h\"\n#include \"llvm/ADT/Optional.h\"\n#include \"llvm/ADT/STLExtras.h\"\n#include \"llvm/ADT/SmallPtrSet.h\"\n#include \"llvm/ADT/SmallVector.h\"\n#include \"llvm/ADT/StringMap.h\"\n#include \"llvm/ADT/StringRef.h\"\n#include \"llvm/ADT/Twine.h\"\n#include \"llvm/ADT/iterator_range.h\"\n#include \"llvm/Support/ErrorHandling.h\"\n#include \"llvm/Support/ManagedStatic.h\"\n#include \"llvm/Support/VirtualFileSystem.h\"\n#include \"llvm/Support/raw_ostream.h\"\n#include <cassert>\n#include <climits>\n#include <cstddef>\n#include <functional>\n#include <initializer_list>\n#include <string>\n#include <type_traits>\n#include <vector>\n\nnamespace llvm {\n\nclass StringSaver;\n\n/// cl Namespace - This namespace contains all of the command line option\n/// processing machinery.  It is intentionally a short name to make qualified\n/// usage concise.\nnamespace cl {\n\n//===----------------------------------------------------------------------===//\n// ParseCommandLineOptions - Command line option processing entry point.\n//\n// Returns true on success. Otherwise, this will print the error message to\n// stderr and exit if \\p Errs is not set (nullptr by default), or print the\n// error message to \\p Errs and return false if \\p Errs is provided.\n//\n// If EnvVar is not nullptr, command-line options are also parsed from the\n// environment variable named by EnvVar.  Precedence is given to occurrences\n// from argv.  This precedence is currently implemented by parsing argv after\n// the environment variable, so it is only implemented correctly for options\n// that give precedence to later occurrences.  If your program supports options\n// that give precedence to earlier occurrences, you will need to extend this\n// function to support it correctly.\nbool ParseCommandLineOptions(int argc, const char *const *argv,\n                             StringRef Overview = \"\",\n                             raw_ostream *Errs = nullptr,\n                             const char *EnvVar = nullptr,\n                             bool LongOptionsUseDoubleDash = false);\n\n// Function pointer type for printing version information.\nusing VersionPrinterTy = std::function<void(raw_ostream &)>;\n\n///===---------------------------------------------------------------------===//\n/// SetVersionPrinter - Override the default (LLVM specific) version printer\n///                     used to print out the version when --version is given\n///                     on the command line. This allows other systems using the\n///                     CommandLine utilities to print their own version string.\nvoid SetVersionPrinter(VersionPrinterTy func);\n\n///===---------------------------------------------------------------------===//\n/// AddExtraVersionPrinter - Add an extra printer to use in addition to the\n///                          default one. This can be called multiple times,\n///                          and each time it adds a new function to the list\n///                          which will be called after the basic LLVM version\n///                          printing is complete. Each can then add additional\n///                          information specific to the tool.\nvoid AddExtraVersionPrinter(VersionPrinterTy func);\n\n// PrintOptionValues - Print option values.\n// With -print-options print the difference between option values and defaults.\n// With -print-all-options print all option values.\n// (Currently not perfect, but best-effort.)\nvoid PrintOptionValues();\n\n// Forward declaration - AddLiteralOption needs to be up here to make gcc happy.\nclass Option;\n\n/// Adds a new option for parsing and provides the option it refers to.\n///\n/// \\param O pointer to the option\n/// \\param Name the string name for the option to handle during parsing\n///\n/// Literal options are used by some parsers to register special option values.\n/// This is how the PassNameParser registers pass names for opt.\nvoid AddLiteralOption(Option &O, StringRef Name);\n\n//===----------------------------------------------------------------------===//\n// Flags permitted to be passed to command line arguments\n//\n\nenum NumOccurrencesFlag { // Flags for the number of occurrences allowed\n  Optional = 0x00,        // Zero or One occurrence\n  ZeroOrMore = 0x01,      // Zero or more occurrences allowed\n  Required = 0x02,        // One occurrence required\n  OneOrMore = 0x03,       // One or more occurrences required\n\n  // ConsumeAfter - Indicates that this option is fed anything that follows the\n  // last positional argument required by the application (it is an error if\n  // there are zero positional arguments, and a ConsumeAfter option is used).\n  // Thus, for example, all arguments to LLI are processed until a filename is\n  // found.  Once a filename is found, all of the succeeding arguments are\n  // passed, unprocessed, to the ConsumeAfter option.\n  //\n  ConsumeAfter = 0x04\n};\n\nenum ValueExpected { // Is a value required for the option?\n  // zero reserved for the unspecified value\n  ValueOptional = 0x01,  // The value can appear... or not\n  ValueRequired = 0x02,  // The value is required to appear!\n  ValueDisallowed = 0x03 // A value may not be specified (for flags)\n};\n\nenum OptionHidden {   // Control whether -help shows this option\n  NotHidden = 0x00,   // Option included in -help & -help-hidden\n  Hidden = 0x01,      // -help doesn't, but -help-hidden does\n  ReallyHidden = 0x02 // Neither -help nor -help-hidden show this arg\n};\n\n// Formatting flags - This controls special features that the option might have\n// that cause it to be parsed differently...\n//\n// Prefix - This option allows arguments that are otherwise unrecognized to be\n// matched by options that are a prefix of the actual value.  This is useful for\n// cases like a linker, where options are typically of the form '-lfoo' or\n// '-L../../include' where -l or -L are the actual flags.  When prefix is\n// enabled, and used, the value for the flag comes from the suffix of the\n// argument.\n//\n// AlwaysPrefix - Only allow the behavior enabled by the Prefix flag and reject\n// the Option=Value form.\n//\n\nenum FormattingFlags {\n  NormalFormatting = 0x00, // Nothing special\n  Positional = 0x01,       // Is a positional argument, no '-' required\n  Prefix = 0x02,           // Can this option directly prefix its value?\n  AlwaysPrefix = 0x03      // Can this option only directly prefix its value?\n};\n\nenum MiscFlags {             // Miscellaneous flags to adjust argument\n  CommaSeparated = 0x01,     // Should this cl::list split between commas?\n  PositionalEatsArgs = 0x02, // Should this positional cl::list eat -args?\n  Sink = 0x04,               // Should this cl::list eat all unknown options?\n\n  // Grouping - Can this option group with other options?\n  // If this is enabled, multiple letter options are allowed to bunch together\n  // with only a single hyphen for the whole group.  This allows emulation\n  // of the behavior that ls uses for example: ls -la === ls -l -a\n  Grouping = 0x08,\n\n  // Default option\n  DefaultOption = 0x10\n};\n\n//===----------------------------------------------------------------------===//\n// Option Category class\n//\nclass OptionCategory {\nprivate:\n  StringRef const Name;\n  StringRef const Description;\n\n  void registerCategory();\n\npublic:\n  OptionCategory(StringRef const Name,\n                 StringRef const Description = \"\")\n      : Name(Name), Description(Description) {\n    registerCategory();\n  }\n\n  StringRef getName() const { return Name; }\n  StringRef getDescription() const { return Description; }\n};\n\n// The general Option Category (used as default category).\nextern OptionCategory GeneralCategory;\n\n//===----------------------------------------------------------------------===//\n// SubCommand class\n//\nclass SubCommand {\nprivate:\n  StringRef Name;\n  StringRef Description;\n\nprotected:\n  void registerSubCommand();\n  void unregisterSubCommand();\n\npublic:\n  SubCommand(StringRef Name, StringRef Description = \"\")\n      : Name(Name), Description(Description) {\n        registerSubCommand();\n  }\n  SubCommand() = default;\n\n  void reset();\n\n  explicit operator bool() const;\n\n  StringRef getName() const { return Name; }\n  StringRef getDescription() const { return Description; }\n\n  SmallVector<Option *, 4> PositionalOpts;\n  SmallVector<Option *, 4> SinkOpts;\n  StringMap<Option *> OptionsMap;\n\n  Option *ConsumeAfterOpt = nullptr; // The ConsumeAfter option if it exists.\n};\n\n// A special subcommand representing no subcommand\nextern ManagedStatic<SubCommand> TopLevelSubCommand;\n\n// A special subcommand that can be used to put an option into all subcommands.\nextern ManagedStatic<SubCommand> AllSubCommands;\n\n//===----------------------------------------------------------------------===//\n// Option Base class\n//\nclass Option {\n  friend class alias;\n\n  // handleOccurrences - Overriden by subclasses to handle the value passed into\n  // an argument.  Should return true if there was an error processing the\n  // argument and the program should exit.\n  //\n  virtual bool handleOccurrence(unsigned pos, StringRef ArgName,\n                                StringRef Arg) = 0;\n\n  virtual enum ValueExpected getValueExpectedFlagDefault() const {\n    return ValueOptional;\n  }\n\n  // Out of line virtual function to provide home for the class.\n  virtual void anchor();\n\n  uint16_t NumOccurrences; // The number of times specified\n  // Occurrences, HiddenFlag, and Formatting are all enum types but to avoid\n  // problems with signed enums in bitfields.\n  uint16_t Occurrences : 3; // enum NumOccurrencesFlag\n  // not using the enum type for 'Value' because zero is an implementation\n  // detail representing the non-value\n  uint16_t Value : 2;\n  uint16_t HiddenFlag : 2; // enum OptionHidden\n  uint16_t Formatting : 2; // enum FormattingFlags\n  uint16_t Misc : 5;\n  uint16_t FullyInitialized : 1; // Has addArgument been called?\n  uint16_t Position;             // Position of last occurrence of the option\n  uint16_t AdditionalVals;       // Greater than 0 for multi-valued option.\n\npublic:\n  StringRef ArgStr;   // The argument string itself (ex: \"help\", \"o\")\n  StringRef HelpStr;  // The descriptive text message for -help\n  StringRef ValueStr; // String describing what the value of this option is\n  SmallVector<OptionCategory *, 1>\n      Categories;                    // The Categories this option belongs to\n  SmallPtrSet<SubCommand *, 1> Subs; // The subcommands this option belongs to.\n\n  inline enum NumOccurrencesFlag getNumOccurrencesFlag() const {\n    return (enum NumOccurrencesFlag)Occurrences;\n  }\n\n  inline enum ValueExpected getValueExpectedFlag() const {\n    return Value ? ((enum ValueExpected)Value) : getValueExpectedFlagDefault();\n  }\n\n  inline enum OptionHidden getOptionHiddenFlag() const {\n    return (enum OptionHidden)HiddenFlag;\n  }\n\n  inline enum FormattingFlags getFormattingFlag() const {\n    return (enum FormattingFlags)Formatting;\n  }\n\n  inline unsigned getMiscFlags() const { return Misc; }\n  inline unsigned getPosition() const { return Position; }\n  inline unsigned getNumAdditionalVals() const { return AdditionalVals; }\n\n  // hasArgStr - Return true if the argstr != \"\"\n  bool hasArgStr() const { return !ArgStr.empty(); }\n  bool isPositional() const { return getFormattingFlag() == cl::Positional; }\n  bool isSink() const { return getMiscFlags() & cl::Sink; }\n  bool isDefaultOption() const { return getMiscFlags() & cl::DefaultOption; }\n\n  bool isConsumeAfter() const {\n    return getNumOccurrencesFlag() == cl::ConsumeAfter;\n  }\n\n  bool isInAllSubCommands() const {\n    return any_of(Subs, [](const SubCommand *SC) {\n      return SC == &*AllSubCommands;\n    });\n  }\n\n  //-------------------------------------------------------------------------===\n  // Accessor functions set by OptionModifiers\n  //\n  void setArgStr(StringRef S);\n  void setDescription(StringRef S) { HelpStr = S; }\n  void setValueStr(StringRef S) { ValueStr = S; }\n  void setNumOccurrencesFlag(enum NumOccurrencesFlag Val) { Occurrences = Val; }\n  void setValueExpectedFlag(enum ValueExpected Val) { Value = Val; }\n  void setHiddenFlag(enum OptionHidden Val) { HiddenFlag = Val; }\n  void setFormattingFlag(enum FormattingFlags V) { Formatting = V; }\n  void setMiscFlag(enum MiscFlags M) { Misc |= M; }\n  void setPosition(unsigned pos) { Position = pos; }\n  void addCategory(OptionCategory &C);\n  void addSubCommand(SubCommand &S) { Subs.insert(&S); }\n\nprotected:\n  explicit Option(enum NumOccurrencesFlag OccurrencesFlag,\n                  enum OptionHidden Hidden)\n      : NumOccurrences(0), Occurrences(OccurrencesFlag), Value(0),\n        HiddenFlag(Hidden), Formatting(NormalFormatting), Misc(0),\n        FullyInitialized(false), Position(0), AdditionalVals(0) {\n    Categories.push_back(&GeneralCategory);\n  }\n\n  inline void setNumAdditionalVals(unsigned n) { AdditionalVals = n; }\n\npublic:\n  virtual ~Option() = default;\n\n  // addArgument - Register this argument with the commandline system.\n  //\n  void addArgument();\n\n  /// Unregisters this option from the CommandLine system.\n  ///\n  /// This option must have been the last option registered.\n  /// For testing purposes only.\n  void removeArgument();\n\n  // Return the width of the option tag for printing...\n  virtual size_t getOptionWidth() const = 0;\n\n  // printOptionInfo - Print out information about this option.  The\n  // to-be-maintained width is specified.\n  //\n  virtual void printOptionInfo(size_t GlobalWidth) const = 0;\n\n  virtual void printOptionValue(size_t GlobalWidth, bool Force) const = 0;\n\n  virtual void setDefault() = 0;\n\n  // Prints the help string for an option.\n  //\n  // This maintains the Indent for multi-line descriptions.\n  // FirstLineIndentedBy is the count of chars of the first line\n  //      i.e. the one containing the --<option name>.\n  static void printHelpStr(StringRef HelpStr, size_t Indent,\n                           size_t FirstLineIndentedBy);\n\n  // Prints the help string for an enum value.\n  //\n  // This maintains the Indent for multi-line descriptions.\n  // FirstLineIndentedBy is the count of chars of the first line\n  //      i.e. the one containing the =<value>.\n  static void printEnumValHelpStr(StringRef HelpStr, size_t Indent,\n                                  size_t FirstLineIndentedBy);\n\n  virtual void getExtraOptionNames(SmallVectorImpl<StringRef> &) {}\n\n  // addOccurrence - Wrapper around handleOccurrence that enforces Flags.\n  //\n  virtual bool addOccurrence(unsigned pos, StringRef ArgName, StringRef Value,\n                             bool MultiArg = false);\n\n  // Prints option name followed by message.  Always returns true.\n  bool error(const Twine &Message, StringRef ArgName = StringRef(), raw_ostream &Errs = llvm::errs());\n  bool error(const Twine &Message, raw_ostream &Errs) {\n    return error(Message, StringRef(), Errs);\n  }\n\n  inline int getNumOccurrences() const { return NumOccurrences; }\n  void reset();\n};\n\n//===----------------------------------------------------------------------===//\n// Command line option modifiers that can be used to modify the behavior of\n// command line option parsers...\n//\n\n// desc - Modifier to set the description shown in the -help output...\nstruct desc {\n  StringRef Desc;\n\n  desc(StringRef Str) : Desc(Str) {}\n\n  void apply(Option &O) const { O.setDescription(Desc); }\n};\n\n// value_desc - Modifier to set the value description shown in the -help\n// output...\nstruct value_desc {\n  StringRef Desc;\n\n  value_desc(StringRef Str) : Desc(Str) {}\n\n  void apply(Option &O) const { O.setValueStr(Desc); }\n};\n\n// init - Specify a default (initial) value for the command line argument, if\n// the default constructor for the argument type does not give you what you\n// want.  This is only valid on \"opt\" arguments, not on \"list\" arguments.\n//\ntemplate <class Ty> struct initializer {\n  const Ty &Init;\n  initializer(const Ty &Val) : Init(Val) {}\n\n  template <class Opt> void apply(Opt &O) const { O.setInitialValue(Init); }\n};\n\ntemplate <class Ty> initializer<Ty> init(const Ty &Val) {\n  return initializer<Ty>(Val);\n}\n\n// location - Allow the user to specify which external variable they want to\n// store the results of the command line argument processing into, if they don't\n// want to store it in the option itself.\n//\ntemplate <class Ty> struct LocationClass {\n  Ty &Loc;\n\n  LocationClass(Ty &L) : Loc(L) {}\n\n  template <class Opt> void apply(Opt &O) const { O.setLocation(O, Loc); }\n};\n\ntemplate <class Ty> LocationClass<Ty> location(Ty &L) {\n  return LocationClass<Ty>(L);\n}\n\n// cat - Specifiy the Option category for the command line argument to belong\n// to.\nstruct cat {\n  OptionCategory &Category;\n\n  cat(OptionCategory &c) : Category(c) {}\n\n  template <class Opt> void apply(Opt &O) const { O.addCategory(Category); }\n};\n\n// sub - Specify the subcommand that this option belongs to.\nstruct sub {\n  SubCommand &Sub;\n\n  sub(SubCommand &S) : Sub(S) {}\n\n  template <class Opt> void apply(Opt &O) const { O.addSubCommand(Sub); }\n};\n\n// Specify a callback function to be called when an option is seen.\n// Can be used to set other options automatically.\ntemplate <typename R, typename Ty> struct cb {\n  std::function<R(Ty)> CB;\n\n  cb(std::function<R(Ty)> CB) : CB(CB) {}\n\n  template <typename Opt> void apply(Opt &O) const { O.setCallback(CB); }\n};\n\nnamespace detail {\ntemplate <typename F>\nstruct callback_traits : public callback_traits<decltype(&F::operator())> {};\n\ntemplate <typename R, typename C, typename... Args>\nstruct callback_traits<R (C::*)(Args...) const> {\n  using result_type = R;\n  using arg_type = std::tuple_element_t<0, std::tuple<Args...>>;\n  static_assert(sizeof...(Args) == 1, \"callback function must have one and only one parameter\");\n  static_assert(std::is_same<result_type, void>::value,\n                \"callback return type must be void\");\n  static_assert(std::is_lvalue_reference<arg_type>::value &&\n                    std::is_const<std::remove_reference_t<arg_type>>::value,\n                \"callback arg_type must be a const lvalue reference\");\n};\n} // namespace detail\n\ntemplate <typename F>\ncb<typename detail::callback_traits<F>::result_type,\n   typename detail::callback_traits<F>::arg_type>\ncallback(F CB) {\n  using result_type = typename detail::callback_traits<F>::result_type;\n  using arg_type = typename detail::callback_traits<F>::arg_type;\n  return cb<result_type, arg_type>(CB);\n}\n\n//===----------------------------------------------------------------------===//\n// OptionValue class\n\n// Support value comparison outside the template.\nstruct GenericOptionValue {\n  virtual bool compare(const GenericOptionValue &V) const = 0;\n\nprotected:\n  GenericOptionValue() = default;\n  GenericOptionValue(const GenericOptionValue&) = default;\n  GenericOptionValue &operator=(const GenericOptionValue &) = default;\n  ~GenericOptionValue() = default;\n\nprivate:\n  virtual void anchor();\n};\n\ntemplate <class DataType> struct OptionValue;\n\n// The default value safely does nothing. Option value printing is only\n// best-effort.\ntemplate <class DataType, bool isClass>\nstruct OptionValueBase : public GenericOptionValue {\n  // Temporary storage for argument passing.\n  using WrapperType = OptionValue<DataType>;\n\n  bool hasValue() const { return false; }\n\n  const DataType &getValue() const { llvm_unreachable(\"no default value\"); }\n\n  // Some options may take their value from a different data type.\n  template <class DT> void setValue(const DT & /*V*/) {}\n\n  bool compare(const DataType & /*V*/) const { return false; }\n\n  bool compare(const GenericOptionValue & /*V*/) const override {\n    return false;\n  }\n\nprotected:\n  ~OptionValueBase() = default;\n};\n\n// Simple copy of the option value.\ntemplate <class DataType> class OptionValueCopy : public GenericOptionValue {\n  DataType Value;\n  bool Valid = false;\n\nprotected:\n  OptionValueCopy(const OptionValueCopy&) = default;\n  OptionValueCopy &operator=(const OptionValueCopy &) = default;\n  ~OptionValueCopy() = default;\n\npublic:\n  OptionValueCopy() = default;\n\n  bool hasValue() const { return Valid; }\n\n  const DataType &getValue() const {\n    assert(Valid && \"invalid option value\");\n    return Value;\n  }\n\n  void setValue(const DataType &V) {\n    Valid = true;\n    Value = V;\n  }\n\n  bool compare(const DataType &V) const { return Valid && (Value != V); }\n\n  bool compare(const GenericOptionValue &V) const override {\n    const OptionValueCopy<DataType> &VC =\n        static_cast<const OptionValueCopy<DataType> &>(V);\n    if (!VC.hasValue())\n      return false;\n    return compare(VC.getValue());\n  }\n};\n\n// Non-class option values.\ntemplate <class DataType>\nstruct OptionValueBase<DataType, false> : OptionValueCopy<DataType> {\n  using WrapperType = DataType;\n\nprotected:\n  OptionValueBase() = default;\n  OptionValueBase(const OptionValueBase&) = default;\n  OptionValueBase &operator=(const OptionValueBase &) = default;\n  ~OptionValueBase() = default;\n};\n\n// Top-level option class.\ntemplate <class DataType>\nstruct OptionValue final\n    : OptionValueBase<DataType, std::is_class<DataType>::value> {\n  OptionValue() = default;\n\n  OptionValue(const DataType &V) { this->setValue(V); }\n\n  // Some options may take their value from a different data type.\n  template <class DT> OptionValue<DataType> &operator=(const DT &V) {\n    this->setValue(V);\n    return *this;\n  }\n};\n\n// Other safe-to-copy-by-value common option types.\nenum boolOrDefault { BOU_UNSET, BOU_TRUE, BOU_FALSE };\ntemplate <>\nstruct OptionValue<cl::boolOrDefault> final\n    : OptionValueCopy<cl::boolOrDefault> {\n  using WrapperType = cl::boolOrDefault;\n\n  OptionValue() = default;\n\n  OptionValue(const cl::boolOrDefault &V) { this->setValue(V); }\n\n  OptionValue<cl::boolOrDefault> &operator=(const cl::boolOrDefault &V) {\n    setValue(V);\n    return *this;\n  }\n\nprivate:\n  void anchor() override;\n};\n\ntemplate <>\nstruct OptionValue<std::string> final : OptionValueCopy<std::string> {\n  using WrapperType = StringRef;\n\n  OptionValue() = default;\n\n  OptionValue(const std::string &V) { this->setValue(V); }\n\n  OptionValue<std::string> &operator=(const std::string &V) {\n    setValue(V);\n    return *this;\n  }\n\nprivate:\n  void anchor() override;\n};\n\n//===----------------------------------------------------------------------===//\n// Enum valued command line option\n//\n\n// This represents a single enum value, using \"int\" as the underlying type.\nstruct OptionEnumValue {\n  StringRef Name;\n  int Value;\n  StringRef Description;\n};\n\n#define clEnumVal(ENUMVAL, DESC)                                               \\\n  llvm::cl::OptionEnumValue { #ENUMVAL, int(ENUMVAL), DESC }\n#define clEnumValN(ENUMVAL, FLAGNAME, DESC)                                    \\\n  llvm::cl::OptionEnumValue { FLAGNAME, int(ENUMVAL), DESC }\n\n// values - For custom data types, allow specifying a group of values together\n// as the values that go into the mapping that the option handler uses.\n//\nclass ValuesClass {\n  // Use a vector instead of a map, because the lists should be short,\n  // the overhead is less, and most importantly, it keeps them in the order\n  // inserted so we can print our option out nicely.\n  SmallVector<OptionEnumValue, 4> Values;\n\npublic:\n  ValuesClass(std::initializer_list<OptionEnumValue> Options)\n      : Values(Options) {}\n\n  template <class Opt> void apply(Opt &O) const {\n    for (const auto &Value : Values)\n      O.getParser().addLiteralOption(Value.Name, Value.Value,\n                                     Value.Description);\n  }\n};\n\n/// Helper to build a ValuesClass by forwarding a variable number of arguments\n/// as an initializer list to the ValuesClass constructor.\ntemplate <typename... OptsTy> ValuesClass values(OptsTy... Options) {\n  return ValuesClass({Options...});\n}\n\n//===----------------------------------------------------------------------===//\n// parser class - Parameterizable parser for different data types.  By default,\n// known data types (string, int, bool) have specialized parsers, that do what\n// you would expect.  The default parser, used for data types that are not\n// built-in, uses a mapping table to map specific options to values, which is\n// used, among other things, to handle enum types.\n\n//--------------------------------------------------\n// generic_parser_base - This class holds all the non-generic code that we do\n// not need replicated for every instance of the generic parser.  This also\n// allows us to put stuff into CommandLine.cpp\n//\nclass generic_parser_base {\nprotected:\n  class GenericOptionInfo {\n  public:\n    GenericOptionInfo(StringRef name, StringRef helpStr)\n        : Name(name), HelpStr(helpStr) {}\n    StringRef Name;\n    StringRef HelpStr;\n  };\n\npublic:\n  generic_parser_base(Option &O) : Owner(O) {}\n\n  virtual ~generic_parser_base() = default;\n  // Base class should have virtual-destructor\n\n  // getNumOptions - Virtual function implemented by generic subclass to\n  // indicate how many entries are in Values.\n  //\n  virtual unsigned getNumOptions() const = 0;\n\n  // getOption - Return option name N.\n  virtual StringRef getOption(unsigned N) const = 0;\n\n  // getDescription - Return description N\n  virtual StringRef getDescription(unsigned N) const = 0;\n\n  // Return the width of the option tag for printing...\n  virtual size_t getOptionWidth(const Option &O) const;\n\n  virtual const GenericOptionValue &getOptionValue(unsigned N) const = 0;\n\n  // printOptionInfo - Print out information about this option.  The\n  // to-be-maintained width is specified.\n  //\n  virtual void printOptionInfo(const Option &O, size_t GlobalWidth) const;\n\n  void printGenericOptionDiff(const Option &O, const GenericOptionValue &V,\n                              const GenericOptionValue &Default,\n                              size_t GlobalWidth) const;\n\n  // printOptionDiff - print the value of an option and it's default.\n  //\n  // Template definition ensures that the option and default have the same\n  // DataType (via the same AnyOptionValue).\n  template <class AnyOptionValue>\n  void printOptionDiff(const Option &O, const AnyOptionValue &V,\n                       const AnyOptionValue &Default,\n                       size_t GlobalWidth) const {\n    printGenericOptionDiff(O, V, Default, GlobalWidth);\n  }\n\n  void initialize() {}\n\n  void getExtraOptionNames(SmallVectorImpl<StringRef> &OptionNames) {\n    // If there has been no argstr specified, that means that we need to add an\n    // argument for every possible option.  This ensures that our options are\n    // vectored to us.\n    if (!Owner.hasArgStr())\n      for (unsigned i = 0, e = getNumOptions(); i != e; ++i)\n        OptionNames.push_back(getOption(i));\n  }\n\n  enum ValueExpected getValueExpectedFlagDefault() const {\n    // If there is an ArgStr specified, then we are of the form:\n    //\n    //    -opt=O2   or   -opt O2  or  -optO2\n    //\n    // In which case, the value is required.  Otherwise if an arg str has not\n    // been specified, we are of the form:\n    //\n    //    -O2 or O2 or -la (where -l and -a are separate options)\n    //\n    // If this is the case, we cannot allow a value.\n    //\n    if (Owner.hasArgStr())\n      return ValueRequired;\n    else\n      return ValueDisallowed;\n  }\n\n  // findOption - Return the option number corresponding to the specified\n  // argument string.  If the option is not found, getNumOptions() is returned.\n  //\n  unsigned findOption(StringRef Name);\n\nprotected:\n  Option &Owner;\n};\n\n// Default parser implementation - This implementation depends on having a\n// mapping of recognized options to values of some sort.  In addition to this,\n// each entry in the mapping also tracks a help message that is printed with the\n// command line option for -help.  Because this is a simple mapping parser, the\n// data type can be any unsupported type.\n//\ntemplate <class DataType> class parser : public generic_parser_base {\nprotected:\n  class OptionInfo : public GenericOptionInfo {\n  public:\n    OptionInfo(StringRef name, DataType v, StringRef helpStr)\n        : GenericOptionInfo(name, helpStr), V(v) {}\n\n    OptionValue<DataType> V;\n  };\n  SmallVector<OptionInfo, 8> Values;\n\npublic:\n  parser(Option &O) : generic_parser_base(O) {}\n\n  using parser_data_type = DataType;\n\n  // Implement virtual functions needed by generic_parser_base\n  unsigned getNumOptions() const override { return unsigned(Values.size()); }\n  StringRef getOption(unsigned N) const override { return Values[N].Name; }\n  StringRef getDescription(unsigned N) const override {\n    return Values[N].HelpStr;\n  }\n\n  // getOptionValue - Return the value of option name N.\n  const GenericOptionValue &getOptionValue(unsigned N) const override {\n    return Values[N].V;\n  }\n\n  // parse - Return true on error.\n  bool parse(Option &O, StringRef ArgName, StringRef Arg, DataType &V) {\n    StringRef ArgVal;\n    if (Owner.hasArgStr())\n      ArgVal = Arg;\n    else\n      ArgVal = ArgName;\n\n    for (size_t i = 0, e = Values.size(); i != e; ++i)\n      if (Values[i].Name == ArgVal) {\n        V = Values[i].V.getValue();\n        return false;\n      }\n\n    return O.error(\"Cannot find option named '\" + ArgVal + \"'!\");\n  }\n\n  /// addLiteralOption - Add an entry to the mapping table.\n  ///\n  template <class DT>\n  void addLiteralOption(StringRef Name, const DT &V, StringRef HelpStr) {\n    assert(findOption(Name) == Values.size() && \"Option already exists!\");\n    OptionInfo X(Name, static_cast<DataType>(V), HelpStr);\n    Values.push_back(X);\n    AddLiteralOption(Owner, Name);\n  }\n\n  /// removeLiteralOption - Remove the specified option.\n  ///\n  void removeLiteralOption(StringRef Name) {\n    unsigned N = findOption(Name);\n    assert(N != Values.size() && \"Option not found!\");\n    Values.erase(Values.begin() + N);\n  }\n};\n\n//--------------------------------------------------\n// basic_parser - Super class of parsers to provide boilerplate code\n//\nclass basic_parser_impl { // non-template implementation of basic_parser<t>\npublic:\n  basic_parser_impl(Option &) {}\n\n  virtual ~basic_parser_impl() {}\n\n  enum ValueExpected getValueExpectedFlagDefault() const {\n    return ValueRequired;\n  }\n\n  void getExtraOptionNames(SmallVectorImpl<StringRef> &) {}\n\n  void initialize() {}\n\n  // Return the width of the option tag for printing...\n  size_t getOptionWidth(const Option &O) const;\n\n  // printOptionInfo - Print out information about this option.  The\n  // to-be-maintained width is specified.\n  //\n  void printOptionInfo(const Option &O, size_t GlobalWidth) const;\n\n  // printOptionNoValue - Print a placeholder for options that don't yet support\n  // printOptionDiff().\n  void printOptionNoValue(const Option &O, size_t GlobalWidth) const;\n\n  // getValueName - Overload in subclass to provide a better default value.\n  virtual StringRef getValueName() const { return \"value\"; }\n\n  // An out-of-line virtual method to provide a 'home' for this class.\n  virtual void anchor();\n\nprotected:\n  // A helper for basic_parser::printOptionDiff.\n  void printOptionName(const Option &O, size_t GlobalWidth) const;\n};\n\n// basic_parser - The real basic parser is just a template wrapper that provides\n// a typedef for the provided data type.\n//\ntemplate <class DataType> class basic_parser : public basic_parser_impl {\npublic:\n  using parser_data_type = DataType;\n  using OptVal = OptionValue<DataType>;\n\n  basic_parser(Option &O) : basic_parser_impl(O) {}\n};\n\n//--------------------------------------------------\n// parser<bool>\n//\ntemplate <> class parser<bool> : public basic_parser<bool> {\npublic:\n  parser(Option &O) : basic_parser(O) {}\n\n  // parse - Return true on error.\n  bool parse(Option &O, StringRef ArgName, StringRef Arg, bool &Val);\n\n  void initialize() {}\n\n  enum ValueExpected getValueExpectedFlagDefault() const {\n    return ValueOptional;\n  }\n\n  // getValueName - Do not print =<value> at all.\n  StringRef getValueName() const override { return StringRef(); }\n\n  void printOptionDiff(const Option &O, bool V, OptVal Default,\n                       size_t GlobalWidth) const;\n\n  // An out-of-line virtual method to provide a 'home' for this class.\n  void anchor() override;\n};\n\nextern template class basic_parser<bool>;\n\n//--------------------------------------------------\n// parser<boolOrDefault>\ntemplate <> class parser<boolOrDefault> : public basic_parser<boolOrDefault> {\npublic:\n  parser(Option &O) : basic_parser(O) {}\n\n  // parse - Return true on error.\n  bool parse(Option &O, StringRef ArgName, StringRef Arg, boolOrDefault &Val);\n\n  enum ValueExpected getValueExpectedFlagDefault() const {\n    return ValueOptional;\n  }\n\n  // getValueName - Do not print =<value> at all.\n  StringRef getValueName() const override { return StringRef(); }\n\n  void printOptionDiff(const Option &O, boolOrDefault V, OptVal Default,\n                       size_t GlobalWidth) const;\n\n  // An out-of-line virtual method to provide a 'home' for this class.\n  void anchor() override;\n};\n\nextern template class basic_parser<boolOrDefault>;\n\n//--------------------------------------------------\n// parser<int>\n//\ntemplate <> class parser<int> : public basic_parser<int> {\npublic:\n  parser(Option &O) : basic_parser(O) {}\n\n  // parse - Return true on error.\n  bool parse(Option &O, StringRef ArgName, StringRef Arg, int &Val);\n\n  // getValueName - Overload in subclass to provide a better default value.\n  StringRef getValueName() const override { return \"int\"; }\n\n  void printOptionDiff(const Option &O, int V, OptVal Default,\n                       size_t GlobalWidth) const;\n\n  // An out-of-line virtual method to provide a 'home' for this class.\n  void anchor() override;\n};\n\nextern template class basic_parser<int>;\n\n//--------------------------------------------------\n// parser<long>\n//\ntemplate <> class parser<long> final : public basic_parser<long> {\npublic:\n  parser(Option &O) : basic_parser(O) {}\n\n  // parse - Return true on error.\n  bool parse(Option &O, StringRef ArgName, StringRef Arg, long &Val);\n\n  // getValueName - Overload in subclass to provide a better default value.\n  StringRef getValueName() const override { return \"long\"; }\n\n  void printOptionDiff(const Option &O, long V, OptVal Default,\n                       size_t GlobalWidth) const;\n\n  // An out-of-line virtual method to provide a 'home' for this class.\n  void anchor() override;\n};\n\nextern template class basic_parser<long>;\n\n//--------------------------------------------------\n// parser<long long>\n//\ntemplate <> class parser<long long> : public basic_parser<long long> {\npublic:\n  parser(Option &O) : basic_parser(O) {}\n\n  // parse - Return true on error.\n  bool parse(Option &O, StringRef ArgName, StringRef Arg, long long &Val);\n\n  // getValueName - Overload in subclass to provide a better default value.\n  StringRef getValueName() const override { return \"long\"; }\n\n  void printOptionDiff(const Option &O, long long V, OptVal Default,\n                       size_t GlobalWidth) const;\n\n  // An out-of-line virtual method to provide a 'home' for this class.\n  void anchor() override;\n};\n\nextern template class basic_parser<long long>;\n\n//--------------------------------------------------\n// parser<unsigned>\n//\ntemplate <> class parser<unsigned> : public basic_parser<unsigned> {\npublic:\n  parser(Option &O) : basic_parser(O) {}\n\n  // parse - Return true on error.\n  bool parse(Option &O, StringRef ArgName, StringRef Arg, unsigned &Val);\n\n  // getValueName - Overload in subclass to provide a better default value.\n  StringRef getValueName() const override { return \"uint\"; }\n\n  void printOptionDiff(const Option &O, unsigned V, OptVal Default,\n                       size_t GlobalWidth) const;\n\n  // An out-of-line virtual method to provide a 'home' for this class.\n  void anchor() override;\n};\n\nextern template class basic_parser<unsigned>;\n\n//--------------------------------------------------\n// parser<unsigned long>\n//\ntemplate <>\nclass parser<unsigned long> final : public basic_parser<unsigned long> {\npublic:\n  parser(Option &O) : basic_parser(O) {}\n\n  // parse - Return true on error.\n  bool parse(Option &O, StringRef ArgName, StringRef Arg, unsigned long &Val);\n\n  // getValueName - Overload in subclass to provide a better default value.\n  StringRef getValueName() const override { return \"ulong\"; }\n\n  void printOptionDiff(const Option &O, unsigned long V, OptVal Default,\n                       size_t GlobalWidth) const;\n\n  // An out-of-line virtual method to provide a 'home' for this class.\n  void anchor() override;\n};\n\nextern template class basic_parser<unsigned long>;\n\n//--------------------------------------------------\n// parser<unsigned long long>\n//\ntemplate <>\nclass parser<unsigned long long> : public basic_parser<unsigned long long> {\npublic:\n  parser(Option &O) : basic_parser(O) {}\n\n  // parse - Return true on error.\n  bool parse(Option &O, StringRef ArgName, StringRef Arg,\n             unsigned long long &Val);\n\n  // getValueName - Overload in subclass to provide a better default value.\n  StringRef getValueName() const override { return \"ulong\"; }\n\n  void printOptionDiff(const Option &O, unsigned long long V, OptVal Default,\n                       size_t GlobalWidth) const;\n\n  // An out-of-line virtual method to provide a 'home' for this class.\n  void anchor() override;\n};\n\nextern template class basic_parser<unsigned long long>;\n\n//--------------------------------------------------\n// parser<double>\n//\ntemplate <> class parser<double> : public basic_parser<double> {\npublic:\n  parser(Option &O) : basic_parser(O) {}\n\n  // parse - Return true on error.\n  bool parse(Option &O, StringRef ArgName, StringRef Arg, double &Val);\n\n  // getValueName - Overload in subclass to provide a better default value.\n  StringRef getValueName() const override { return \"number\"; }\n\n  void printOptionDiff(const Option &O, double V, OptVal Default,\n                       size_t GlobalWidth) const;\n\n  // An out-of-line virtual method to provide a 'home' for this class.\n  void anchor() override;\n};\n\nextern template class basic_parser<double>;\n\n//--------------------------------------------------\n// parser<float>\n//\ntemplate <> class parser<float> : public basic_parser<float> {\npublic:\n  parser(Option &O) : basic_parser(O) {}\n\n  // parse - Return true on error.\n  bool parse(Option &O, StringRef ArgName, StringRef Arg, float &Val);\n\n  // getValueName - Overload in subclass to provide a better default value.\n  StringRef getValueName() const override { return \"number\"; }\n\n  void printOptionDiff(const Option &O, float V, OptVal Default,\n                       size_t GlobalWidth) const;\n\n  // An out-of-line virtual method to provide a 'home' for this class.\n  void anchor() override;\n};\n\nextern template class basic_parser<float>;\n\n//--------------------------------------------------\n// parser<std::string>\n//\ntemplate <> class parser<std::string> : public basic_parser<std::string> {\npublic:\n  parser(Option &O) : basic_parser(O) {}\n\n  // parse - Return true on error.\n  bool parse(Option &, StringRef, StringRef Arg, std::string &Value) {\n    Value = Arg.str();\n    return false;\n  }\n\n  // getValueName - Overload in subclass to provide a better default value.\n  StringRef getValueName() const override { return \"string\"; }\n\n  void printOptionDiff(const Option &O, StringRef V, const OptVal &Default,\n                       size_t GlobalWidth) const;\n\n  // An out-of-line virtual method to provide a 'home' for this class.\n  void anchor() override;\n};\n\nextern template class basic_parser<std::string>;\n\n//--------------------------------------------------\n// parser<char>\n//\ntemplate <> class parser<char> : public basic_parser<char> {\npublic:\n  parser(Option &O) : basic_parser(O) {}\n\n  // parse - Return true on error.\n  bool parse(Option &, StringRef, StringRef Arg, char &Value) {\n    Value = Arg[0];\n    return false;\n  }\n\n  // getValueName - Overload in subclass to provide a better default value.\n  StringRef getValueName() const override { return \"char\"; }\n\n  void printOptionDiff(const Option &O, char V, OptVal Default,\n                       size_t GlobalWidth) const;\n\n  // An out-of-line virtual method to provide a 'home' for this class.\n  void anchor() override;\n};\n\nextern template class basic_parser<char>;\n\n//--------------------------------------------------\n// PrintOptionDiff\n//\n// This collection of wrappers is the intermediary between class opt and class\n// parser to handle all the template nastiness.\n\n// This overloaded function is selected by the generic parser.\ntemplate <class ParserClass, class DT>\nvoid printOptionDiff(const Option &O, const generic_parser_base &P, const DT &V,\n                     const OptionValue<DT> &Default, size_t GlobalWidth) {\n  OptionValue<DT> OV = V;\n  P.printOptionDiff(O, OV, Default, GlobalWidth);\n}\n\n// This is instantiated for basic parsers when the parsed value has a different\n// type than the option value. e.g. HelpPrinter.\ntemplate <class ParserDT, class ValDT> struct OptionDiffPrinter {\n  void print(const Option &O, const parser<ParserDT> &P, const ValDT & /*V*/,\n             const OptionValue<ValDT> & /*Default*/, size_t GlobalWidth) {\n    P.printOptionNoValue(O, GlobalWidth);\n  }\n};\n\n// This is instantiated for basic parsers when the parsed value has the same\n// type as the option value.\ntemplate <class DT> struct OptionDiffPrinter<DT, DT> {\n  void print(const Option &O, const parser<DT> &P, const DT &V,\n             const OptionValue<DT> &Default, size_t GlobalWidth) {\n    P.printOptionDiff(O, V, Default, GlobalWidth);\n  }\n};\n\n// This overloaded function is selected by the basic parser, which may parse a\n// different type than the option type.\ntemplate <class ParserClass, class ValDT>\nvoid printOptionDiff(\n    const Option &O,\n    const basic_parser<typename ParserClass::parser_data_type> &P,\n    const ValDT &V, const OptionValue<ValDT> &Default, size_t GlobalWidth) {\n\n  OptionDiffPrinter<typename ParserClass::parser_data_type, ValDT> printer;\n  printer.print(O, static_cast<const ParserClass &>(P), V, Default,\n                GlobalWidth);\n}\n\n//===----------------------------------------------------------------------===//\n// applicator class - This class is used because we must use partial\n// specialization to handle literal string arguments specially (const char* does\n// not correctly respond to the apply method).  Because the syntax to use this\n// is a pain, we have the 'apply' method below to handle the nastiness...\n//\ntemplate <class Mod> struct applicator {\n  template <class Opt> static void opt(const Mod &M, Opt &O) { M.apply(O); }\n};\n\n// Handle const char* as a special case...\ntemplate <unsigned n> struct applicator<char[n]> {\n  template <class Opt> static void opt(StringRef Str, Opt &O) {\n    O.setArgStr(Str);\n  }\n};\ntemplate <unsigned n> struct applicator<const char[n]> {\n  template <class Opt> static void opt(StringRef Str, Opt &O) {\n    O.setArgStr(Str);\n  }\n};\ntemplate <> struct applicator<StringRef > {\n  template <class Opt> static void opt(StringRef Str, Opt &O) {\n    O.setArgStr(Str);\n  }\n};\n\ntemplate <> struct applicator<NumOccurrencesFlag> {\n  static void opt(NumOccurrencesFlag N, Option &O) {\n    O.setNumOccurrencesFlag(N);\n  }\n};\n\ntemplate <> struct applicator<ValueExpected> {\n  static void opt(ValueExpected VE, Option &O) { O.setValueExpectedFlag(VE); }\n};\n\ntemplate <> struct applicator<OptionHidden> {\n  static void opt(OptionHidden OH, Option &O) { O.setHiddenFlag(OH); }\n};\n\ntemplate <> struct applicator<FormattingFlags> {\n  static void opt(FormattingFlags FF, Option &O) { O.setFormattingFlag(FF); }\n};\n\ntemplate <> struct applicator<MiscFlags> {\n  static void opt(MiscFlags MF, Option &O) {\n    assert((MF != Grouping || O.ArgStr.size() == 1) &&\n           \"cl::Grouping can only apply to single charater Options.\");\n    O.setMiscFlag(MF);\n  }\n};\n\n// apply method - Apply modifiers to an option in a type safe way.\ntemplate <class Opt, class Mod, class... Mods>\nvoid apply(Opt *O, const Mod &M, const Mods &... Ms) {\n  applicator<Mod>::opt(M, *O);\n  apply(O, Ms...);\n}\n\ntemplate <class Opt, class Mod> void apply(Opt *O, const Mod &M) {\n  applicator<Mod>::opt(M, *O);\n}\n\n//===----------------------------------------------------------------------===//\n// opt_storage class\n\n// Default storage class definition: external storage.  This implementation\n// assumes the user will specify a variable to store the data into with the\n// cl::location(x) modifier.\n//\ntemplate <class DataType, bool ExternalStorage, bool isClass>\nclass opt_storage {\n  DataType *Location = nullptr; // Where to store the object...\n  OptionValue<DataType> Default;\n\n  void check_location() const {\n    assert(Location && \"cl::location(...) not specified for a command \"\n                       \"line option with external storage, \"\n                       \"or cl::init specified before cl::location()!!\");\n  }\n\npublic:\n  opt_storage() = default;\n\n  bool setLocation(Option &O, DataType &L) {\n    if (Location)\n      return O.error(\"cl::location(x) specified more than once!\");\n    Location = &L;\n    Default = L;\n    return false;\n  }\n\n  template <class T> void setValue(const T &V, bool initial = false) {\n    check_location();\n    *Location = V;\n    if (initial)\n      Default = V;\n  }\n\n  DataType &getValue() {\n    check_location();\n    return *Location;\n  }\n  const DataType &getValue() const {\n    check_location();\n    return *Location;\n  }\n\n  operator DataType() const { return this->getValue(); }\n\n  const OptionValue<DataType> &getDefault() const { return Default; }\n};\n\n// Define how to hold a class type object, such as a string.  Since we can\n// inherit from a class, we do so.  This makes us exactly compatible with the\n// object in all cases that it is used.\n//\ntemplate <class DataType>\nclass opt_storage<DataType, false, true> : public DataType {\npublic:\n  OptionValue<DataType> Default;\n\n  template <class T> void setValue(const T &V, bool initial = false) {\n    DataType::operator=(V);\n    if (initial)\n      Default = V;\n  }\n\n  DataType &getValue() { return *this; }\n  const DataType &getValue() const { return *this; }\n\n  const OptionValue<DataType> &getDefault() const { return Default; }\n};\n\n// Define a partial specialization to handle things we cannot inherit from.  In\n// this case, we store an instance through containment, and overload operators\n// to get at the value.\n//\ntemplate <class DataType> class opt_storage<DataType, false, false> {\npublic:\n  DataType Value;\n  OptionValue<DataType> Default;\n\n  // Make sure we initialize the value with the default constructor for the\n  // type.\n  opt_storage() : Value(DataType()), Default(DataType()) {}\n\n  template <class T> void setValue(const T &V, bool initial = false) {\n    Value = V;\n    if (initial)\n      Default = V;\n  }\n  DataType &getValue() { return Value; }\n  DataType getValue() const { return Value; }\n\n  const OptionValue<DataType> &getDefault() const { return Default; }\n\n  operator DataType() const { return getValue(); }\n\n  // If the datatype is a pointer, support -> on it.\n  DataType operator->() const { return Value; }\n};\n\n//===----------------------------------------------------------------------===//\n// opt - A scalar command line option.\n//\ntemplate <class DataType, bool ExternalStorage = false,\n          class ParserClass = parser<DataType>>\nclass opt : public Option,\n            public opt_storage<DataType, ExternalStorage,\n                               std::is_class<DataType>::value> {\n  ParserClass Parser;\n\n  bool handleOccurrence(unsigned pos, StringRef ArgName,\n                        StringRef Arg) override {\n    typename ParserClass::parser_data_type Val =\n        typename ParserClass::parser_data_type();\n    if (Parser.parse(*this, ArgName, Arg, Val))\n      return true; // Parse error!\n    this->setValue(Val);\n    this->setPosition(pos);\n    Callback(Val);\n    return false;\n  }\n\n  enum ValueExpected getValueExpectedFlagDefault() const override {\n    return Parser.getValueExpectedFlagDefault();\n  }\n\n  void getExtraOptionNames(SmallVectorImpl<StringRef> &OptionNames) override {\n    return Parser.getExtraOptionNames(OptionNames);\n  }\n\n  // Forward printing stuff to the parser...\n  size_t getOptionWidth() const override {\n    return Parser.getOptionWidth(*this);\n  }\n\n  void printOptionInfo(size_t GlobalWidth) const override {\n    Parser.printOptionInfo(*this, GlobalWidth);\n  }\n\n  void printOptionValue(size_t GlobalWidth, bool Force) const override {\n    if (Force || this->getDefault().compare(this->getValue())) {\n      cl::printOptionDiff<ParserClass>(*this, Parser, this->getValue(),\n                                       this->getDefault(), GlobalWidth);\n    }\n  }\n\n  template <class T,\n            class = std::enable_if_t<std::is_assignable<T &, T>::value>>\n  void setDefaultImpl() {\n    const OptionValue<DataType> &V = this->getDefault();\n    if (V.hasValue())\n      this->setValue(V.getValue());\n  }\n\n  template <class T,\n            class = std::enable_if_t<!std::is_assignable<T &, T>::value>>\n  void setDefaultImpl(...) {}\n\n  void setDefault() override { setDefaultImpl<DataType>(); }\n\n  void done() {\n    addArgument();\n    Parser.initialize();\n  }\n\npublic:\n  // Command line options should not be copyable\n  opt(const opt &) = delete;\n  opt &operator=(const opt &) = delete;\n\n  // setInitialValue - Used by the cl::init modifier...\n  void setInitialValue(const DataType &V) { this->setValue(V, true); }\n\n  ParserClass &getParser() { return Parser; }\n\n  template <class T> DataType &operator=(const T &Val) {\n    this->setValue(Val);\n    Callback(Val);\n    return this->getValue();\n  }\n\n  template <class... Mods>\n  explicit opt(const Mods &... Ms)\n      : Option(llvm::cl::Optional, NotHidden), Parser(*this) {\n    apply(this, Ms...);\n    done();\n  }\n\n  void setCallback(\n      std::function<void(const typename ParserClass::parser_data_type &)> CB) {\n    Callback = CB;\n  }\n\n  std::function<void(const typename ParserClass::parser_data_type &)> Callback =\n      [](const typename ParserClass::parser_data_type &) {};\n};\n\nextern template class opt<unsigned>;\nextern template class opt<int>;\nextern template class opt<std::string>;\nextern template class opt<char>;\nextern template class opt<bool>;\n\n//===----------------------------------------------------------------------===//\n// list_storage class\n\n// Default storage class definition: external storage.  This implementation\n// assumes the user will specify a variable to store the data into with the\n// cl::location(x) modifier.\n//\ntemplate <class DataType, class StorageClass> class list_storage {\n  StorageClass *Location = nullptr; // Where to store the object...\n\npublic:\n  list_storage() = default;\n\n  void clear() {}\n\n  bool setLocation(Option &O, StorageClass &L) {\n    if (Location)\n      return O.error(\"cl::location(x) specified more than once!\");\n    Location = &L;\n    return false;\n  }\n\n  template <class T> void addValue(const T &V) {\n    assert(Location != 0 && \"cl::location(...) not specified for a command \"\n                            \"line option with external storage!\");\n    Location->push_back(V);\n  }\n};\n\n// Define how to hold a class type object, such as a string.\n// Originally this code inherited from std::vector. In transitioning to a new\n// API for command line options we should change this. The new implementation\n// of this list_storage specialization implements the minimum subset of the\n// std::vector API required for all the current clients.\n//\n// FIXME: Reduce this API to a more narrow subset of std::vector\n//\ntemplate <class DataType> class list_storage<DataType, bool> {\n  std::vector<DataType> Storage;\n\npublic:\n  using iterator = typename std::vector<DataType>::iterator;\n\n  iterator begin() { return Storage.begin(); }\n  iterator end() { return Storage.end(); }\n\n  using const_iterator = typename std::vector<DataType>::const_iterator;\n\n  const_iterator begin() const { return Storage.begin(); }\n  const_iterator end() const { return Storage.end(); }\n\n  using size_type = typename std::vector<DataType>::size_type;\n\n  size_type size() const { return Storage.size(); }\n\n  bool empty() const { return Storage.empty(); }\n\n  void push_back(const DataType &value) { Storage.push_back(value); }\n  void push_back(DataType &&value) { Storage.push_back(value); }\n\n  using reference = typename std::vector<DataType>::reference;\n  using const_reference = typename std::vector<DataType>::const_reference;\n\n  reference operator[](size_type pos) { return Storage[pos]; }\n  const_reference operator[](size_type pos) const { return Storage[pos]; }\n\n  void clear() {\n    Storage.clear();\n  }\n\n  iterator erase(const_iterator pos) { return Storage.erase(pos); }\n  iterator erase(const_iterator first, const_iterator last) {\n    return Storage.erase(first, last);\n  }\n\n  iterator erase(iterator pos) { return Storage.erase(pos); }\n  iterator erase(iterator first, iterator last) {\n    return Storage.erase(first, last);\n  }\n\n  iterator insert(const_iterator pos, const DataType &value) {\n    return Storage.insert(pos, value);\n  }\n  iterator insert(const_iterator pos, DataType &&value) {\n    return Storage.insert(pos, value);\n  }\n\n  iterator insert(iterator pos, const DataType &value) {\n    return Storage.insert(pos, value);\n  }\n  iterator insert(iterator pos, DataType &&value) {\n    return Storage.insert(pos, value);\n  }\n\n  reference front() { return Storage.front(); }\n  const_reference front() const { return Storage.front(); }\n\n  operator std::vector<DataType> &() { return Storage; }\n  operator ArrayRef<DataType>() const { return Storage; }\n  std::vector<DataType> *operator&() { return &Storage; }\n  const std::vector<DataType> *operator&() const { return &Storage; }\n\n  template <class T> void addValue(const T &V) { Storage.push_back(V); }\n};\n\n//===----------------------------------------------------------------------===//\n// list - A list of command line options.\n//\ntemplate <class DataType, class StorageClass = bool,\n          class ParserClass = parser<DataType>>\nclass list : public Option, public list_storage<DataType, StorageClass> {\n  std::vector<unsigned> Positions;\n  ParserClass Parser;\n\n  enum ValueExpected getValueExpectedFlagDefault() const override {\n    return Parser.getValueExpectedFlagDefault();\n  }\n\n  void getExtraOptionNames(SmallVectorImpl<StringRef> &OptionNames) override {\n    return Parser.getExtraOptionNames(OptionNames);\n  }\n\n  bool handleOccurrence(unsigned pos, StringRef ArgName,\n                        StringRef Arg) override {\n    typename ParserClass::parser_data_type Val =\n        typename ParserClass::parser_data_type();\n    if (Parser.parse(*this, ArgName, Arg, Val))\n      return true; // Parse Error!\n    list_storage<DataType, StorageClass>::addValue(Val);\n    setPosition(pos);\n    Positions.push_back(pos);\n    Callback(Val);\n    return false;\n  }\n\n  // Forward printing stuff to the parser...\n  size_t getOptionWidth() const override {\n    return Parser.getOptionWidth(*this);\n  }\n\n  void printOptionInfo(size_t GlobalWidth) const override {\n    Parser.printOptionInfo(*this, GlobalWidth);\n  }\n\n  // Unimplemented: list options don't currently store their default value.\n  void printOptionValue(size_t /*GlobalWidth*/, bool /*Force*/) const override {\n  }\n\n  void setDefault() override {\n    Positions.clear();\n    list_storage<DataType, StorageClass>::clear();\n  }\n\n  void done() {\n    addArgument();\n    Parser.initialize();\n  }\n\npublic:\n  // Command line options should not be copyable\n  list(const list &) = delete;\n  list &operator=(const list &) = delete;\n\n  ParserClass &getParser() { return Parser; }\n\n  unsigned getPosition(unsigned optnum) const {\n    assert(optnum < this->size() && \"Invalid option index\");\n    return Positions[optnum];\n  }\n\n  void setNumAdditionalVals(unsigned n) { Option::setNumAdditionalVals(n); }\n\n  template <class... Mods>\n  explicit list(const Mods &... Ms)\n      : Option(ZeroOrMore, NotHidden), Parser(*this) {\n    apply(this, Ms...);\n    done();\n  }\n\n  void setCallback(\n      std::function<void(const typename ParserClass::parser_data_type &)> CB) {\n    Callback = CB;\n  }\n\n  std::function<void(const typename ParserClass::parser_data_type &)> Callback =\n      [](const typename ParserClass::parser_data_type &) {};\n};\n\n// multi_val - Modifier to set the number of additional values.\nstruct multi_val {\n  unsigned AdditionalVals;\n  explicit multi_val(unsigned N) : AdditionalVals(N) {}\n\n  template <typename D, typename S, typename P>\n  void apply(list<D, S, P> &L) const {\n    L.setNumAdditionalVals(AdditionalVals);\n  }\n};\n\n//===----------------------------------------------------------------------===//\n// bits_storage class\n\n// Default storage class definition: external storage.  This implementation\n// assumes the user will specify a variable to store the data into with the\n// cl::location(x) modifier.\n//\ntemplate <class DataType, class StorageClass> class bits_storage {\n  unsigned *Location = nullptr; // Where to store the bits...\n\n  template <class T> static unsigned Bit(const T &V) {\n    unsigned BitPos = reinterpret_cast<unsigned>(V);\n    assert(BitPos < sizeof(unsigned) * CHAR_BIT &&\n           \"enum exceeds width of bit vector!\");\n    return 1 << BitPos;\n  }\n\npublic:\n  bits_storage() = default;\n\n  bool setLocation(Option &O, unsigned &L) {\n    if (Location)\n      return O.error(\"cl::location(x) specified more than once!\");\n    Location = &L;\n    return false;\n  }\n\n  template <class T> void addValue(const T &V) {\n    assert(Location != 0 && \"cl::location(...) not specified for a command \"\n                            \"line option with external storage!\");\n    *Location |= Bit(V);\n  }\n\n  unsigned getBits() { return *Location; }\n\n  template <class T> bool isSet(const T &V) {\n    return (*Location & Bit(V)) != 0;\n  }\n};\n\n// Define how to hold bits.  Since we can inherit from a class, we do so.\n// This makes us exactly compatible with the bits in all cases that it is used.\n//\ntemplate <class DataType> class bits_storage<DataType, bool> {\n  unsigned Bits; // Where to store the bits...\n\n  template <class T> static unsigned Bit(const T &V) {\n    unsigned BitPos = (unsigned)V;\n    assert(BitPos < sizeof(unsigned) * CHAR_BIT &&\n           \"enum exceeds width of bit vector!\");\n    return 1 << BitPos;\n  }\n\npublic:\n  template <class T> void addValue(const T &V) { Bits |= Bit(V); }\n\n  unsigned getBits() { return Bits; }\n\n  template <class T> bool isSet(const T &V) { return (Bits & Bit(V)) != 0; }\n};\n\n//===----------------------------------------------------------------------===//\n// bits - A bit vector of command options.\n//\ntemplate <class DataType, class Storage = bool,\n          class ParserClass = parser<DataType>>\nclass bits : public Option, public bits_storage<DataType, Storage> {\n  std::vector<unsigned> Positions;\n  ParserClass Parser;\n\n  enum ValueExpected getValueExpectedFlagDefault() const override {\n    return Parser.getValueExpectedFlagDefault();\n  }\n\n  void getExtraOptionNames(SmallVectorImpl<StringRef> &OptionNames) override {\n    return Parser.getExtraOptionNames(OptionNames);\n  }\n\n  bool handleOccurrence(unsigned pos, StringRef ArgName,\n                        StringRef Arg) override {\n    typename ParserClass::parser_data_type Val =\n        typename ParserClass::parser_data_type();\n    if (Parser.parse(*this, ArgName, Arg, Val))\n      return true; // Parse Error!\n    this->addValue(Val);\n    setPosition(pos);\n    Positions.push_back(pos);\n    Callback(Val);\n    return false;\n  }\n\n  // Forward printing stuff to the parser...\n  size_t getOptionWidth() const override {\n    return Parser.getOptionWidth(*this);\n  }\n\n  void printOptionInfo(size_t GlobalWidth) const override {\n    Parser.printOptionInfo(*this, GlobalWidth);\n  }\n\n  // Unimplemented: bits options don't currently store their default values.\n  void printOptionValue(size_t /*GlobalWidth*/, bool /*Force*/) const override {\n  }\n\n  void setDefault() override {}\n\n  void done() {\n    addArgument();\n    Parser.initialize();\n  }\n\npublic:\n  // Command line options should not be copyable\n  bits(const bits &) = delete;\n  bits &operator=(const bits &) = delete;\n\n  ParserClass &getParser() { return Parser; }\n\n  unsigned getPosition(unsigned optnum) const {\n    assert(optnum < this->size() && \"Invalid option index\");\n    return Positions[optnum];\n  }\n\n  template <class... Mods>\n  explicit bits(const Mods &... Ms)\n      : Option(ZeroOrMore, NotHidden), Parser(*this) {\n    apply(this, Ms...);\n    done();\n  }\n\n  void setCallback(\n      std::function<void(const typename ParserClass::parser_data_type &)> CB) {\n    Callback = CB;\n  }\n\n  std::function<void(const typename ParserClass::parser_data_type &)> Callback =\n      [](const typename ParserClass::parser_data_type &) {};\n};\n\n//===----------------------------------------------------------------------===//\n// Aliased command line option (alias this name to a preexisting name)\n//\n\nclass alias : public Option {\n  Option *AliasFor;\n\n  bool handleOccurrence(unsigned pos, StringRef /*ArgName*/,\n                        StringRef Arg) override {\n    return AliasFor->handleOccurrence(pos, AliasFor->ArgStr, Arg);\n  }\n\n  bool addOccurrence(unsigned pos, StringRef /*ArgName*/, StringRef Value,\n                     bool MultiArg = false) override {\n    return AliasFor->addOccurrence(pos, AliasFor->ArgStr, Value, MultiArg);\n  }\n\n  // Handle printing stuff...\n  size_t getOptionWidth() const override;\n  void printOptionInfo(size_t GlobalWidth) const override;\n\n  // Aliases do not need to print their values.\n  void printOptionValue(size_t /*GlobalWidth*/, bool /*Force*/) const override {\n  }\n\n  void setDefault() override { AliasFor->setDefault(); }\n\n  ValueExpected getValueExpectedFlagDefault() const override {\n    return AliasFor->getValueExpectedFlag();\n  }\n\n  void done() {\n    if (!hasArgStr())\n      error(\"cl::alias must have argument name specified!\");\n    if (!AliasFor)\n      error(\"cl::alias must have an cl::aliasopt(option) specified!\");\n    if (!Subs.empty())\n      error(\"cl::alias must not have cl::sub(), aliased option's cl::sub() will be used!\");\n    Subs = AliasFor->Subs;\n    Categories = AliasFor->Categories;\n    addArgument();\n  }\n\npublic:\n  // Command line options should not be copyable\n  alias(const alias &) = delete;\n  alias &operator=(const alias &) = delete;\n\n  void setAliasFor(Option &O) {\n    if (AliasFor)\n      error(\"cl::alias must only have one cl::aliasopt(...) specified!\");\n    AliasFor = &O;\n  }\n\n  template <class... Mods>\n  explicit alias(const Mods &... Ms)\n      : Option(Optional, Hidden), AliasFor(nullptr) {\n    apply(this, Ms...);\n    done();\n  }\n};\n\n// aliasfor - Modifier to set the option an alias aliases.\nstruct aliasopt {\n  Option &Opt;\n\n  explicit aliasopt(Option &O) : Opt(O) {}\n\n  void apply(alias &A) const { A.setAliasFor(Opt); }\n};\n\n// extrahelp - provide additional help at the end of the normal help\n// output. All occurrences of cl::extrahelp will be accumulated and\n// printed to stderr at the end of the regular help, just before\n// exit is called.\nstruct extrahelp {\n  StringRef morehelp;\n\n  explicit extrahelp(StringRef help);\n};\n\nvoid PrintVersionMessage();\n\n/// This function just prints the help message, exactly the same way as if the\n/// -help or -help-hidden option had been given on the command line.\n///\n/// \\param Hidden if true will print hidden options\n/// \\param Categorized if true print options in categories\nvoid PrintHelpMessage(bool Hidden = false, bool Categorized = false);\n\n//===----------------------------------------------------------------------===//\n// Public interface for accessing registered options.\n//\n\n/// Use this to get a StringMap to all registered named options\n/// (e.g. -help).\n///\n/// \\return A reference to the StringMap used by the cl APIs to parse options.\n///\n/// Access to unnamed arguments (i.e. positional) are not provided because\n/// it is expected that the client already has access to these.\n///\n/// Typical usage:\n/// \\code\n/// main(int argc,char* argv[]) {\n/// StringMap<llvm::cl::Option*> &opts = llvm::cl::getRegisteredOptions();\n/// assert(opts.count(\"help\") == 1)\n/// opts[\"help\"]->setDescription(\"Show alphabetical help information\")\n/// // More code\n/// llvm::cl::ParseCommandLineOptions(argc,argv);\n/// //More code\n/// }\n/// \\endcode\n///\n/// This interface is useful for modifying options in libraries that are out of\n/// the control of the client. The options should be modified before calling\n/// llvm::cl::ParseCommandLineOptions().\n///\n/// Hopefully this API can be deprecated soon. Any situation where options need\n/// to be modified by tools or libraries should be handled by sane APIs rather\n/// than just handing around a global list.\nStringMap<Option *> &getRegisteredOptions(SubCommand &Sub = *TopLevelSubCommand);\n\n/// Use this to get all registered SubCommands from the provided parser.\n///\n/// \\return A range of all SubCommand pointers registered with the parser.\n///\n/// Typical usage:\n/// \\code\n/// main(int argc, char* argv[]) {\n///   llvm::cl::ParseCommandLineOptions(argc, argv);\n///   for (auto* S : llvm::cl::getRegisteredSubcommands()) {\n///     if (*S) {\n///       std::cout << \"Executing subcommand: \" << S->getName() << std::endl;\n///       // Execute some function based on the name...\n///     }\n///   }\n/// }\n/// \\endcode\n///\n/// This interface is useful for defining subcommands in libraries and\n/// the dispatch from a single point (like in the main function).\niterator_range<typename SmallPtrSet<SubCommand *, 4>::iterator>\ngetRegisteredSubcommands();\n\n//===----------------------------------------------------------------------===//\n// Standalone command line processing utilities.\n//\n\n/// Tokenizes a command line that can contain escapes and quotes.\n//\n/// The quoting rules match those used by GCC and other tools that use\n/// libiberty's buildargv() or expandargv() utilities, and do not match bash.\n/// They differ from buildargv() on treatment of backslashes that do not escape\n/// a special character to make it possible to accept most Windows file paths.\n///\n/// \\param [in] Source The string to be split on whitespace with quotes.\n/// \\param [in] Saver Delegates back to the caller for saving parsed strings.\n/// \\param [in] MarkEOLs true if tokenizing a response file and you want end of\n/// lines and end of the response file to be marked with a nullptr string.\n/// \\param [out] NewArgv All parsed strings are appended to NewArgv.\nvoid TokenizeGNUCommandLine(StringRef Source, StringSaver &Saver,\n                            SmallVectorImpl<const char *> &NewArgv,\n                            bool MarkEOLs = false);\n\n/// Tokenizes a Windows command line which may contain quotes and escaped\n/// quotes.\n///\n/// See MSDN docs for CommandLineToArgvW for information on the quoting rules.\n/// http://msdn.microsoft.com/en-us/library/windows/desktop/17w5ykft(v=vs.85).aspx\n///\n/// \\param [in] Source The string to be split on whitespace with quotes.\n/// \\param [in] Saver Delegates back to the caller for saving parsed strings.\n/// \\param [in] MarkEOLs true if tokenizing a response file and you want end of\n/// lines and end of the response file to be marked with a nullptr string.\n/// \\param [out] NewArgv All parsed strings are appended to NewArgv.\nvoid TokenizeWindowsCommandLine(StringRef Source, StringSaver &Saver,\n                                SmallVectorImpl<const char *> &NewArgv,\n                                bool MarkEOLs = false);\n\n/// Tokenizes a Windows command line while attempting to avoid copies. If no\n/// quoting or escaping was used, this produces substrings of the original\n/// string. If a token requires unquoting, it will be allocated with the\n/// StringSaver.\nvoid TokenizeWindowsCommandLineNoCopy(StringRef Source, StringSaver &Saver,\n                                      SmallVectorImpl<StringRef> &NewArgv);\n\n/// String tokenization function type.  Should be compatible with either\n/// Windows or Unix command line tokenizers.\nusing TokenizerCallback = void (*)(StringRef Source, StringSaver &Saver,\n                                   SmallVectorImpl<const char *> &NewArgv,\n                                   bool MarkEOLs);\n\n/// Tokenizes content of configuration file.\n///\n/// \\param [in] Source The string representing content of config file.\n/// \\param [in] Saver Delegates back to the caller for saving parsed strings.\n/// \\param [out] NewArgv All parsed strings are appended to NewArgv.\n/// \\param [in] MarkEOLs Added for compatibility with TokenizerCallback.\n///\n/// It works like TokenizeGNUCommandLine with ability to skip comment lines.\n///\nvoid tokenizeConfigFile(StringRef Source, StringSaver &Saver,\n                        SmallVectorImpl<const char *> &NewArgv,\n                        bool MarkEOLs = false);\n\n/// Reads command line options from the given configuration file.\n///\n/// \\param [in] CfgFileName Path to configuration file.\n/// \\param [in] Saver  Objects that saves allocated strings.\n/// \\param [out] Argv Array to which the read options are added.\n/// \\return true if the file was successfully read.\n///\n/// It reads content of the specified file, tokenizes it and expands \"@file\"\n/// commands resolving file names in them relative to the directory where\n/// CfgFilename resides.\n///\nbool readConfigFile(StringRef CfgFileName, StringSaver &Saver,\n                    SmallVectorImpl<const char *> &Argv);\n\n/// Expand response files on a command line recursively using the given\n/// StringSaver and tokenization strategy.  Argv should contain the command line\n/// before expansion and will be modified in place. If requested, Argv will\n/// also be populated with nullptrs indicating where each response file line\n/// ends, which is useful for the \"/link\" argument that needs to consume all\n/// remaining arguments only until the next end of line, when in a response\n/// file.\n///\n/// \\param [in] Saver Delegates back to the caller for saving parsed strings.\n/// \\param [in] Tokenizer Tokenization strategy. Typically Unix or Windows.\n/// \\param [in,out] Argv Command line into which to expand response files.\n/// \\param [in] MarkEOLs Mark end of lines and the end of the response file\n/// with nullptrs in the Argv vector.\n/// \\param [in] RelativeNames true if names of nested response files must be\n/// resolved relative to including file.\n/// \\param [in] FS File system used for all file access when running the tool.\n/// \\param [in] CurrentDir Path used to resolve relative rsp files. If set to\n/// None, process' cwd is used instead.\n/// \\return true if all @files were expanded successfully or there were none.\nbool ExpandResponseFiles(\n    StringSaver &Saver, TokenizerCallback Tokenizer,\n    SmallVectorImpl<const char *> &Argv, bool MarkEOLs = false,\n    bool RelativeNames = false,\n    llvm::vfs::FileSystem &FS = *llvm::vfs::getRealFileSystem(),\n    llvm::Optional<llvm::StringRef> CurrentDir = llvm::None);\n\n/// A convenience helper which concatenates the options specified by the\n/// environment variable EnvVar and command line options, then expands response\n/// files recursively. The tokenizer is a predefined GNU or Windows one.\n/// \\return true if all @files were expanded successfully or there were none.\nbool expandResponseFiles(int Argc, const char *const *Argv, const char *EnvVar,\n                         StringSaver &Saver,\n                         SmallVectorImpl<const char *> &NewArgv);\n\n/// Mark all options not part of this category as cl::ReallyHidden.\n///\n/// \\param Category the category of options to keep displaying\n///\n/// Some tools (like clang-format) like to be able to hide all options that are\n/// not specific to the tool. This function allows a tool to specify a single\n/// option category to display in the -help output.\nvoid HideUnrelatedOptions(cl::OptionCategory &Category,\n                          SubCommand &Sub = *TopLevelSubCommand);\n\n/// Mark all options not part of the categories as cl::ReallyHidden.\n///\n/// \\param Categories the categories of options to keep displaying.\n///\n/// Some tools (like clang-format) like to be able to hide all options that are\n/// not specific to the tool. This function allows a tool to specify a single\n/// option category to display in the -help output.\nvoid HideUnrelatedOptions(ArrayRef<const cl::OptionCategory *> Categories,\n                          SubCommand &Sub = *TopLevelSubCommand);\n\n/// Reset all command line options to a state that looks as if they have\n/// never appeared on the command line.  This is useful for being able to parse\n/// a command line multiple times (especially useful for writing tests).\nvoid ResetAllOptionOccurrences();\n\n/// Reset the command line parser back to its initial state.  This\n/// removes\n/// all options, categories, and subcommands and returns the parser to a state\n/// where no options are supported.\nvoid ResetCommandLineParser();\n\n/// Parses `Arg` into the option handler `Handler`.\nbool ProvidePositionalOption(Option *Handler, StringRef Arg, int i);\n\n} // end namespace cl\n\n} // end namespace llvm\n\n#endif // LLVM_SUPPORT_COMMANDLINE_H\n"}, "109": {"id": 109, "path": "/home/vsts/work/1/llvm-project/llvm/tools/llvm-pdbutil/BytesOutputStyle.h", "content": "//===- BytesOutputStyle.h ------------------------------------- *- C++ --*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_TOOLS_LLVMPDBDUMP_BYTESOUTPUTSTYLE_H\n#define LLVM_TOOLS_LLVMPDBDUMP_BYTESOUTPUTSTYLE_H\n\n#include \"LinePrinter.h\"\n#include \"OutputStyle.h\"\n#include \"StreamUtil.h\"\n\n#include \"llvm/Support/Error.h\"\n\nnamespace llvm {\n\nnamespace codeview {\nclass LazyRandomTypeCollection;\n}\n\nnamespace pdb {\n\nclass PDBFile;\n\nclass BytesOutputStyle : public OutputStyle {\npublic:\n  BytesOutputStyle(PDBFile &File);\n\n  Error dump() override;\n\nprivate:\n  void dumpNameMap();\n  void dumpBlockRanges(uint32_t Min, uint32_t Max);\n  void dumpByteRanges(uint32_t Min, uint32_t Max);\n  void dumpFpm();\n  void dumpStreamBytes();\n\n  void dumpSectionContributions();\n  void dumpSectionMap();\n  void dumpModuleInfos();\n  void dumpFileInfo();\n  void dumpTypeServerMap();\n  void dumpECData();\n\n  void dumpModuleSyms();\n  void dumpModuleC11();\n  void dumpModuleC13();\n\n  void dumpTypeIndex(uint32_t StreamIdx, ArrayRef<uint32_t> Indices);\n\n  Expected<codeview::LazyRandomTypeCollection &>\n  initializeTypes(uint32_t StreamIdx);\n\n  std::unique_ptr<codeview::LazyRandomTypeCollection> TpiTypes;\n  std::unique_ptr<codeview::LazyRandomTypeCollection> IpiTypes;\n\n  PDBFile &File;\n  LinePrinter P;\n  ExitOnError Err;\n  SmallVector<StreamInfo, 8> StreamPurposes;\n};\n} // namespace pdb\n} // namespace llvm\n\n#endif\n"}, "110": {"id": 110, "path": "/home/vsts/work/1/llvm-project/llvm/tools/llvm-pdbutil/DumpOutputStyle.h", "content": "//===- DumpOutputStyle.h -------------------------------------- *- C++ --*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_TOOLS_LLVMPDBDUMP_DUMPOUTPUTSTYLE_H\n#define LLVM_TOOLS_LLVMPDBDUMP_DUMPOUTPUTSTYLE_H\n\n#include \"LinePrinter.h\"\n#include \"OutputStyle.h\"\n#include \"StreamUtil.h\"\n\n#include \"llvm/ADT/DenseMap.h\"\n#include \"llvm/ADT/Optional.h\"\n#include \"llvm/ADT/SmallVector.h\"\n#include \"llvm/DebugInfo/PDB/Native/RawConstants.h\"\n\n#include <string>\n\nnamespace llvm {\nclass BitVector;\n\nnamespace codeview {\nclass LazyRandomTypeCollection;\n}\n\nnamespace object {\nclass COFFObjectFile;\n}\n\nnamespace pdb {\nclass GSIHashTable;\nclass InputFile;\nclass TypeReferenceTracker;\n\nstruct StatCollection {\n  struct Stat {\n    Stat() {}\n    Stat(uint32_t Count, uint32_t Size) : Count(Count), Size(Size) {}\n    uint32_t Count = 0;\n    uint32_t Size = 0;\n\n    void update(uint32_t RecordSize) {\n      ++Count;\n      Size += RecordSize;\n    }\n  };\n\n  using KindAndStat = std::pair<uint32_t, Stat>;\n\n  void update(uint32_t Kind, uint32_t RecordSize) {\n    Totals.update(RecordSize);\n    auto Iter = Individual.try_emplace(Kind, 1, RecordSize);\n    if (!Iter.second)\n      Iter.first->second.update(RecordSize);\n  }\n  Stat Totals;\n  DenseMap<uint32_t, Stat> Individual;\n\n  std::vector<KindAndStat> getStatsSortedBySize() const;\n};\n\nclass DumpOutputStyle : public OutputStyle {\n\npublic:\n  DumpOutputStyle(InputFile &File);\n  ~DumpOutputStyle() override;\n\n  Error dump() override;\n\nprivate:\n  PDBFile &getPdb();\n  object::COFFObjectFile &getObj();\n\n  void printStreamNotValidForObj();\n  void printStreamNotPresent(StringRef StreamName);\n\n  Error dumpFileSummary();\n  Error dumpStreamSummary();\n  Error dumpSymbolStats();\n  Error dumpUdtStats();\n  Error dumpTypeStats();\n  Error dumpNamedStreams();\n  Error dumpStringTable();\n  Error dumpStringTableFromPdb();\n  Error dumpStringTableFromObj();\n  Error dumpLines();\n  Error dumpInlineeLines();\n  Error dumpXmi();\n  Error dumpXme();\n  Error dumpFpo();\n  Error dumpOldFpo(PDBFile &File);\n  Error dumpNewFpo(PDBFile &File);\n  Error dumpTpiStream(uint32_t StreamIdx);\n  Error dumpTypesFromObjectFile();\n  Error dumpTypeRefStats();\n  Error dumpModules();\n  Error dumpModuleFiles();\n  Error dumpModuleSymsForPdb();\n  Error dumpModuleSymsForObj();\n  Error dumpGSIRecords();\n  Error dumpGlobals();\n  Error dumpPublics();\n  Error dumpSymbolsFromGSI(const GSIHashTable &Table, bool HashExtras);\n  Error dumpSectionHeaders();\n  Error dumpSectionContribs();\n  Error dumpSectionMap();\n\n  void dumpSectionHeaders(StringRef Label, DbgHeaderType Type);\n\n  InputFile &File;\n  std::unique_ptr<TypeReferenceTracker> RefTracker;\n  LinePrinter P;\n  SmallVector<StreamInfo, 32> StreamPurposes;\n};\n} // namespace pdb\n} // namespace llvm\n\n#endif\n"}, "111": {"id": 111, "path": "/home/vsts/work/1/llvm-project/llvm/tools/llvm-pdbutil/ExplainOutputStyle.h", "content": "//===- ExplainOutputStyle.h ----------------------------------- *- C++ --*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_TOOLS_LLVMPDBDUMP_EXPLAINOUTPUTSTYLE_H\n#define LLVM_TOOLS_LLVMPDBDUMP_EXPLAINOUTPUTSTYLE_H\n\n#include \"LinePrinter.h\"\n#include \"OutputStyle.h\"\n\n#include <string>\n\nnamespace llvm {\n\nnamespace pdb {\n\nclass DbiStream;\nclass InfoStream;\nclass InputFile;\n\nclass ExplainOutputStyle : public OutputStyle {\n\npublic:\n  ExplainOutputStyle(InputFile &File, uint64_t FileOffset);\n\n  Error dump() override;\n\nprivate:\n  Error explainPdbFile();\n  Error explainBinaryFile();\n\n  bool explainPdbBlockStatus();\n\n  bool isPdbFpm1() const;\n  bool isPdbFpm2() const;\n\n  bool isPdbSuperBlock() const;\n  bool isPdbFpmBlock() const;\n  bool isPdbBlockMapBlock() const;\n  bool isPdbStreamDirectoryBlock() const;\n  Optional<uint32_t> getPdbBlockStreamIndex() const;\n\n  void explainPdbSuperBlockOffset();\n  void explainPdbFpmBlockOffset();\n  void explainPdbBlockMapOffset();\n  void explainPdbStreamDirectoryOffset();\n  void explainPdbStreamOffset(uint32_t Stream);\n  void explainPdbUnknownBlock();\n\n  void explainStreamOffset(DbiStream &Stream, uint32_t OffsetInStream);\n  void explainStreamOffset(InfoStream &Stream, uint32_t OffsetInStream);\n\n  uint32_t pdbBlockIndex() const;\n  uint32_t pdbBlockOffset() const;\n\n  InputFile &File;\n  const uint64_t FileOffset;\n  LinePrinter P;\n};\n} // namespace pdb\n} // namespace llvm\n\n#endif\n"}, "112": {"id": 112, "path": "/home/vsts/work/1/llvm-project/llvm/tools/llvm-pdbutil/LinePrinter.h", "content": "//===- LinePrinter.h ------------------------------------------ *- C++ --*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_TOOLS_LLVMPDBDUMP_LINEPRINTER_H\n#define LLVM_TOOLS_LLVMPDBDUMP_LINEPRINTER_H\n\n#include \"llvm/ADT/ArrayRef.h\"\n#include \"llvm/ADT/StringRef.h\"\n#include \"llvm/ADT/Twine.h\"\n#include \"llvm/Support/BinaryStreamRef.h\"\n#include \"llvm/Support/FormatVariadic.h\"\n#include \"llvm/Support/Regex.h\"\n#include \"llvm/Support/raw_ostream.h\"\n\n#include <list>\n\nnamespace llvm {\nclass BinaryStreamReader;\nnamespace msf {\nclass MSFStreamLayout;\n} // namespace msf\nnamespace pdb {\n\nclass ClassLayout;\nclass PDBFile;\n\nclass LinePrinter {\n  friend class WithColor;\n\npublic:\n  LinePrinter(int Indent, bool UseColor, raw_ostream &Stream);\n\n  void Indent(uint32_t Amount = 0);\n  void Unindent(uint32_t Amount = 0);\n  void NewLine();\n\n  void printLine(const Twine &T);\n  void print(const Twine &T);\n  template <typename... Ts> void formatLine(const char *Fmt, Ts &&... Items) {\n    printLine(formatv(Fmt, std::forward<Ts>(Items)...));\n  }\n  template <typename... Ts> void format(const char *Fmt, Ts &&... Items) {\n    print(formatv(Fmt, std::forward<Ts>(Items)...));\n  }\n\n  void formatBinary(StringRef Label, ArrayRef<uint8_t> Data,\n                    uint32_t StartOffset);\n  void formatBinary(StringRef Label, ArrayRef<uint8_t> Data, uint64_t BaseAddr,\n                    uint32_t StartOffset);\n\n  void formatMsfStreamData(StringRef Label, PDBFile &File, uint32_t StreamIdx,\n                           StringRef StreamPurpose, uint32_t Offset,\n                           uint32_t Size);\n  void formatMsfStreamData(StringRef Label, PDBFile &File,\n                           const msf::MSFStreamLayout &Stream,\n                           BinarySubstreamRef Substream);\n  void formatMsfStreamBlocks(PDBFile &File, const msf::MSFStreamLayout &Stream);\n\n  bool hasColor() const { return UseColor; }\n  raw_ostream &getStream() { return OS; }\n  int getIndentLevel() const { return CurrentIndent; }\n\n  bool IsClassExcluded(const ClassLayout &Class);\n  bool IsTypeExcluded(llvm::StringRef TypeName, uint32_t Size);\n  bool IsSymbolExcluded(llvm::StringRef SymbolName);\n  bool IsCompilandExcluded(llvm::StringRef CompilandName);\n\nprivate:\n  template <typename Iter>\n  void SetFilters(std::list<Regex> &List, Iter Begin, Iter End) {\n    List.clear();\n    for (; Begin != End; ++Begin)\n      List.emplace_back(StringRef(*Begin));\n  }\n\n  raw_ostream &OS;\n  int IndentSpaces;\n  int CurrentIndent;\n  bool UseColor;\n\n  std::list<Regex> ExcludeCompilandFilters;\n  std::list<Regex> ExcludeTypeFilters;\n  std::list<Regex> ExcludeSymbolFilters;\n\n  std::list<Regex> IncludeCompilandFilters;\n  std::list<Regex> IncludeTypeFilters;\n  std::list<Regex> IncludeSymbolFilters;\n};\n\nstruct PrintScope {\n  explicit PrintScope(LinePrinter &P, uint32_t IndentLevel)\n      : P(P), IndentLevel(IndentLevel) {}\n  explicit PrintScope(const PrintScope &Other, uint32_t LabelWidth)\n      : P(Other.P), IndentLevel(Other.IndentLevel), LabelWidth(LabelWidth) {}\n\n  LinePrinter &P;\n  uint32_t IndentLevel;\n  uint32_t LabelWidth = 0;\n};\n\ninline Optional<PrintScope> withLabelWidth(const Optional<PrintScope> &Scope,\n                                           uint32_t W) {\n  if (!Scope)\n    return None;\n  return PrintScope{*Scope, W};\n}\n\nstruct AutoIndent {\n  explicit AutoIndent(LinePrinter &L, uint32_t Amount = 0)\n      : L(&L), Amount(Amount) {\n    L.Indent(Amount);\n  }\n  explicit AutoIndent(const Optional<PrintScope> &Scope) {\n    if (Scope.hasValue()) {\n      L = &Scope->P;\n      Amount = Scope->IndentLevel;\n    }\n  }\n  ~AutoIndent() {\n    if (L)\n      L->Unindent(Amount);\n  }\n\n  LinePrinter *L = nullptr;\n  uint32_t Amount = 0;\n};\n\ntemplate <class T>\ninline raw_ostream &operator<<(LinePrinter &Printer, const T &Item) {\n  return Printer.getStream() << Item;\n}\n\nenum class PDB_ColorItem {\n  None,\n  Address,\n  Type,\n  Comment,\n  Padding,\n  Keyword,\n  Offset,\n  Identifier,\n  Path,\n  SectionHeader,\n  LiteralValue,\n  Register,\n};\n\nclass WithColor {\npublic:\n  WithColor(LinePrinter &P, PDB_ColorItem C);\n  ~WithColor();\n\n  raw_ostream &get() { return OS; }\n\nprivate:\n  void applyColor(PDB_ColorItem C);\n  raw_ostream &OS;\n  bool UseColor;\n};\n}\n}\n\n#endif\n"}, "113": {"id": 113, "path": "/home/vsts/work/1/llvm-project/llvm/tools/llvm-pdbutil/PdbYaml.h", "content": "//===- PdbYAML.h ---------------------------------------------- *- C++ --*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_TOOLS_LLVMPDBDUMP_PDBYAML_H\n#define LLVM_TOOLS_LLVMPDBDUMP_PDBYAML_H\n\n#include \"OutputStyle.h\"\n\n#include \"llvm/ADT/Optional.h\"\n#include \"llvm/DebugInfo/CodeView/SymbolRecord.h\"\n#include \"llvm/DebugInfo/CodeView/TypeRecord.h\"\n#include \"llvm/DebugInfo/MSF/MSFCommon.h\"\n#include \"llvm/DebugInfo/PDB/Native/PDBFile.h\"\n#include \"llvm/DebugInfo/PDB/Native/RawConstants.h\"\n#include \"llvm/DebugInfo/PDB/PDBTypes.h\"\n#include \"llvm/ObjectYAML/CodeViewYAMLDebugSections.h\"\n#include \"llvm/ObjectYAML/CodeViewYAMLSymbols.h\"\n#include \"llvm/ObjectYAML/CodeViewYAMLTypes.h\"\n#include \"llvm/Support/Endian.h\"\n#include \"llvm/Support/YAMLTraits.h\"\n\n#include <vector>\n\nnamespace llvm {\nnamespace codeview {\nclass DebugStringTableSubsection;\n}\nnamespace pdb {\n\nnamespace yaml {\nstruct SerializationContext;\n\nstruct MSFHeaders {\n  msf::SuperBlock SuperBlock;\n  uint32_t NumDirectoryBlocks = 0;\n  std::vector<uint32_t> DirectoryBlocks;\n  uint32_t NumStreams = 0;\n  uint32_t FileSize = 0;\n};\n\nstruct StreamBlockList {\n  std::vector<uint32_t> Blocks;\n};\n\nstruct NamedStreamMapping {\n  StringRef StreamName;\n  uint32_t StreamNumber;\n};\n\nstruct PdbInfoStream {\n  PdbRaw_ImplVer Version = PdbImplVC70;\n  uint32_t Signature = 0;\n  uint32_t Age = 1;\n  codeview::GUID Guid;\n  std::vector<PdbRaw_FeatureSig> Features;\n  std::vector<NamedStreamMapping> NamedStreams;\n};\n\nstruct PdbModiStream {\n  uint32_t Signature;\n  std::vector<CodeViewYAML::SymbolRecord> Symbols;\n};\n\nstruct PdbDbiModuleInfo {\n  StringRef Obj;\n  StringRef Mod;\n  std::vector<StringRef> SourceFiles;\n  std::vector<CodeViewYAML::YAMLDebugSubsection> Subsections;\n  Optional<PdbModiStream> Modi;\n};\n\nstruct PdbDbiStream {\n  PdbRaw_DbiVer VerHeader = PdbDbiV70;\n  uint32_t Age = 1;\n  uint16_t BuildNumber = 0;\n  uint32_t PdbDllVersion = 0;\n  uint16_t PdbDllRbld = 0;\n  uint16_t Flags = 1;\n  PDB_Machine MachineType = PDB_Machine::x86;\n\n  std::vector<PdbDbiModuleInfo> ModInfos;\n};\n\nstruct PdbTpiStream {\n  PdbRaw_TpiVer Version = PdbTpiV80;\n  std::vector<CodeViewYAML::LeafRecord> Records;\n};\n\nstruct PdbPublicsStream {\n  std::vector<CodeViewYAML::SymbolRecord> PubSyms;\n};\n\nstruct PdbObject {\n  explicit PdbObject(BumpPtrAllocator &Allocator) : Allocator(Allocator) {}\n\n  Optional<MSFHeaders> Headers;\n  Optional<std::vector<uint32_t>> StreamSizes;\n  Optional<std::vector<StreamBlockList>> StreamMap;\n  Optional<PdbInfoStream> PdbStream;\n  Optional<PdbDbiStream> DbiStream;\n  Optional<PdbTpiStream> TpiStream;\n  Optional<PdbTpiStream> IpiStream;\n  Optional<PdbPublicsStream> PublicsStream;\n\n  Optional<std::vector<StringRef>> StringTable;\n\n  BumpPtrAllocator &Allocator;\n};\n}\n}\n}\n\nLLVM_YAML_DECLARE_MAPPING_TRAITS(pdb::yaml::PdbObject)\nLLVM_YAML_DECLARE_MAPPING_TRAITS(pdb::yaml::MSFHeaders)\nLLVM_YAML_DECLARE_MAPPING_TRAITS(msf::SuperBlock)\nLLVM_YAML_DECLARE_MAPPING_TRAITS(pdb::yaml::StreamBlockList)\nLLVM_YAML_DECLARE_MAPPING_TRAITS(pdb::yaml::PdbInfoStream)\nLLVM_YAML_DECLARE_MAPPING_TRAITS(pdb::yaml::PdbDbiStream)\nLLVM_YAML_DECLARE_MAPPING_TRAITS(pdb::yaml::PdbTpiStream)\nLLVM_YAML_DECLARE_MAPPING_TRAITS(pdb::yaml::PdbPublicsStream)\nLLVM_YAML_DECLARE_MAPPING_TRAITS(pdb::yaml::NamedStreamMapping)\nLLVM_YAML_DECLARE_MAPPING_TRAITS(pdb::yaml::PdbModiStream)\nLLVM_YAML_DECLARE_MAPPING_TRAITS(pdb::yaml::PdbDbiModuleInfo)\n\n#endif // LLVM_TOOLS_LLVMPDBDUMP_PDBYAML_H\n"}, "114": {"id": 114, "path": "/home/vsts/work/1/llvm-project/llvm/tools/llvm-pdbutil/PrettyClassDefinitionDumper.h", "content": "//===- PrettyClassDefinitionDumper.h ----------------------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_TOOLS_LLVMPDBDUMP_PRETTYCLASSDEFINITIONDUMPER_H\n#define LLVM_TOOLS_LLVMPDBDUMP_PRETTYCLASSDEFINITIONDUMPER_H\n\n#include \"llvm/ADT/BitVector.h\"\n\n#include \"llvm/DebugInfo/PDB/PDBSymDumper.h\"\n#include \"llvm/DebugInfo/PDB/PDBSymbolData.h\"\n#include \"llvm/DebugInfo/PDB/PDBSymbolFunc.h\"\n\n#include <list>\n#include <memory>\n#include <unordered_map>\n\nnamespace llvm {\nclass BitVector;\n\nnamespace pdb {\n\nclass ClassLayout;\nclass LinePrinter;\n\nclass ClassDefinitionDumper : public PDBSymDumper {\npublic:\n  ClassDefinitionDumper(LinePrinter &P);\n\n  void start(const PDBSymbolTypeUDT &Class);\n  void start(const ClassLayout &Class);\n\nprivate:\n  void prettyPrintClassIntro(const ClassLayout &Class);\n  void prettyPrintClassOutro(const ClassLayout &Class);\n\n  LinePrinter &Printer;\n  bool DumpedAnything = false;\n};\n}\n}\n#endif\n"}, "116": {"id": 116, "path": "/home/vsts/work/1/llvm-project/llvm/tools/llvm-pdbutil/PrettyEnumDumper.h", "content": "//===- PrettyEnumDumper.h ---------------------------------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_TOOLS_LLVMPDBDUMP_PRETTYENUMDUMPER_H\n#define LLVM_TOOLS_LLVMPDBDUMP_PRETTYENUMDUMPER_H\n\n#include \"llvm/DebugInfo/PDB/PDBSymDumper.h\"\n\nnamespace llvm {\nnamespace pdb {\n\nclass LinePrinter;\n\nclass EnumDumper : public PDBSymDumper {\npublic:\n  EnumDumper(LinePrinter &P);\n\n  void start(const PDBSymbolTypeEnum &Symbol);\n\nprivate:\n  LinePrinter &Printer;\n};\n}\n}\n#endif\n"}, "117": {"id": 117, "path": "/home/vsts/work/1/llvm-project/llvm/tools/llvm-pdbutil/PrettyExternalSymbolDumper.h", "content": "//===- PrettyExternalSymbolDumper.h --------------------------- *- C++ --*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_TOOLS_LLVMPDBDUMP_PRETTYEXTERNALSYMBOLDUMPER_H\n#define LLVM_TOOLS_LLVMPDBDUMP_PRETTYEXTERNALSYMBOLDUMPER_H\n\n#include \"llvm/DebugInfo/PDB/PDBSymDumper.h\"\n\nnamespace llvm {\nnamespace pdb {\n\nclass LinePrinter;\n\nclass ExternalSymbolDumper : public PDBSymDumper {\npublic:\n  ExternalSymbolDumper(LinePrinter &P);\n\n  void start(const PDBSymbolExe &Symbol);\n\n  void dump(const PDBSymbolPublicSymbol &Symbol) override;\n\nprivate:\n  LinePrinter &Printer;\n};\n}\n}\n\n#endif\n"}, "121": {"id": 121, "path": "/home/vsts/work/1/llvm-project/llvm/tools/llvm-pdbutil/PrettyVariableDumper.h", "content": "//===- PrettyVariableDumper.h - PDBSymDumper variable dumper ----*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_TOOLS_LLVMPDBDUMP_PRETTYVARIABLEDUMPER_H\n#define LLVM_TOOLS_LLVMPDBDUMP_PRETTYVARIABLEDUMPER_H\n\n#include \"llvm/DebugInfo/PDB/PDBSymDumper.h\"\n\nnamespace llvm {\n\nclass StringRef;\n\nnamespace pdb {\n\nclass LinePrinter;\n\nclass VariableDumper : public PDBSymDumper {\npublic:\n  VariableDumper(LinePrinter &P);\n\n  void start(const PDBSymbolData &Var, uint32_t Offset = 0);\n  void start(const PDBSymbolTypeVTable &Var, uint32_t Offset = 0);\n  void startVbptr(uint32_t Offset, uint32_t Size);\n\n  void dump(const PDBSymbolTypeArray &Symbol) override;\n  void dump(const PDBSymbolTypeBuiltin &Symbol) override;\n  void dump(const PDBSymbolTypeEnum &Symbol) override;\n  void dump(const PDBSymbolTypeFunctionSig &Symbol) override;\n  void dump(const PDBSymbolTypePointer &Symbol) override;\n  void dump(const PDBSymbolTypeTypedef &Symbol) override;\n  void dump(const PDBSymbolTypeUDT &Symbol) override;\n\n  void dumpRight(const PDBSymbolTypeArray &Symbol) override;\n  void dumpRight(const PDBSymbolTypeFunctionSig &Symbol) override;\n  void dumpRight(const PDBSymbolTypePointer &Symbol) override;\n\nprivate:\n  void dumpSymbolTypeAndName(const PDBSymbol &Type, StringRef Name);\n\n  LinePrinter &Printer;\n};\n}\n}\n#endif\n"}, "122": {"id": 122, "path": "/home/vsts/work/1/llvm-project/llvm/tools/llvm-pdbutil/StreamUtil.h", "content": "//===- Streamutil.h - PDB stream utilities ----------------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_TOOLS_LLVMPDBDUMP_STREAMUTIL_H\n#define LLVM_TOOLS_LLVMPDBDUMP_STREAMUTIL_H\n\n#include \"llvm/ADT/Optional.h\"\n#include \"llvm/ADT/SmallVector.h\"\n#include \"llvm/ADT/StringRef.h\"\n\n#include <string>\n\nnamespace llvm {\nnamespace pdb {\nclass PDBFile;\nenum class StreamPurpose {\n  NamedStream,\n  ModuleStream,\n  Symbols,\n  PDB,\n  DBI,\n  TPI,\n  IPI,\n  GlobalHash,\n  PublicHash,\n  TpiHash,\n  IpiHash,\n  Other\n};\n\nstruct StreamInfo {\npublic:\n  StreamInfo() {}\n\n  uint32_t getModuleIndex() const { return *ModuleIndex; }\n  StreamPurpose getPurpose() const { return Purpose; }\n  StringRef getShortName() const { return Name; }\n  uint32_t getStreamIndex() const { return StreamIndex; }\n  std::string getLongName() const;\n\n  static StreamInfo createStream(StreamPurpose Purpose, StringRef Name,\n                                 uint32_t StreamIndex);\n  static StreamInfo createModuleStream(StringRef Module, uint32_t StreamIndex,\n                                       uint32_t Modi);\n\nprivate:\n  StreamPurpose Purpose;\n  uint32_t StreamIndex;\n  std::string Name;\n  Optional<uint32_t> ModuleIndex;\n};\n\nvoid discoverStreamPurposes(PDBFile &File,\n                            SmallVectorImpl<StreamInfo> &Streams);\n}\n}\n\n#endif\n"}, "123": {"id": 123, "path": "/home/vsts/work/1/llvm-project/llvm/tools/llvm-pdbutil/YAMLOutputStyle.h", "content": "//===- YAMLOutputStyle.h -------------------------------------- *- C++ --*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_TOOLS_LLVMPDBDUMP_YAMLOUTPUTSTYLE_H\n#define LLVM_TOOLS_LLVMPDBDUMP_YAMLOUTPUTSTYLE_H\n\n#include \"OutputStyle.h\"\n#include \"PdbYaml.h\"\n\n#include \"llvm/Support/ScopedPrinter.h\"\n#include \"llvm/Support/YAMLTraits.h\"\n\nnamespace llvm {\nnamespace pdb {\nclass ModuleDebugStreamRef;\n\nclass YAMLOutputStyle : public OutputStyle {\npublic:\n  YAMLOutputStyle(PDBFile &File);\n\n  Error dump() override;\n\nprivate:\n  Error dumpStringTable();\n  Error dumpFileHeaders();\n  Error dumpStreamMetadata();\n  Error dumpStreamDirectory();\n  Error dumpPDBStream();\n  Error dumpDbiStream();\n  Error dumpTpiStream();\n  Error dumpIpiStream();\n  Error dumpPublics();\n\n  void flush();\n\n  PDBFile &File;\n  llvm::yaml::Output Out;\n\n  yaml::PdbObject Obj;\n};\n} // namespace pdb\n} // namespace llvm\n\n#endif // LLVM_TOOLS_LLVMPDBDUMP_YAMLOUTPUTSTYLE_H\n"}, "124": {"id": 124, "path": "/home/vsts/work/1/llvm-project/llvm/tools/llvm-pdbutil/llvm-pdbutil.cpp", "content": "//===- llvm-pdbutil.cpp - Dump debug info from a PDB file -------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// Dumps debug information present in PDB files.\n//\n//===----------------------------------------------------------------------===//\n\n#include \"llvm-pdbutil.h\"\n\n#include \"BytesOutputStyle.h\"\n#include \"DumpOutputStyle.h\"\n#include \"ExplainOutputStyle.h\"\n#include \"InputFile.h\"\n#include \"LinePrinter.h\"\n#include \"OutputStyle.h\"\n#include \"PrettyClassDefinitionDumper.h\"\n#include \"PrettyCompilandDumper.h\"\n#include \"PrettyEnumDumper.h\"\n#include \"PrettyExternalSymbolDumper.h\"\n#include \"PrettyFunctionDumper.h\"\n#include \"PrettyTypeDumper.h\"\n#include \"PrettyTypedefDumper.h\"\n#include \"PrettyVariableDumper.h\"\n#include \"YAMLOutputStyle.h\"\n\n#include \"llvm/ADT/ArrayRef.h\"\n#include \"llvm/ADT/BitVector.h\"\n#include \"llvm/ADT/DenseMap.h\"\n#include \"llvm/ADT/STLExtras.h\"\n#include \"llvm/ADT/StringExtras.h\"\n#include \"llvm/BinaryFormat/Magic.h\"\n#include \"llvm/Config/config.h\"\n#include \"llvm/DebugInfo/CodeView/AppendingTypeTableBuilder.h\"\n#include \"llvm/DebugInfo/CodeView/DebugChecksumsSubsection.h\"\n#include \"llvm/DebugInfo/CodeView/DebugInlineeLinesSubsection.h\"\n#include \"llvm/DebugInfo/CodeView/DebugLinesSubsection.h\"\n#include \"llvm/DebugInfo/CodeView/LazyRandomTypeCollection.h\"\n#include \"llvm/DebugInfo/CodeView/MergingTypeTableBuilder.h\"\n#include \"llvm/DebugInfo/CodeView/StringsAndChecksums.h\"\n#include \"llvm/DebugInfo/CodeView/TypeStreamMerger.h\"\n#include \"llvm/DebugInfo/MSF/MSFBuilder.h\"\n#include \"llvm/DebugInfo/PDB/IPDBEnumChildren.h\"\n#include \"llvm/DebugInfo/PDB/IPDBInjectedSource.h\"\n#include \"llvm/DebugInfo/PDB/IPDBRawSymbol.h\"\n#include \"llvm/DebugInfo/PDB/IPDBSession.h\"\n#include \"llvm/DebugInfo/PDB/Native/DbiModuleDescriptorBuilder.h\"\n#include \"llvm/DebugInfo/PDB/Native/DbiStreamBuilder.h\"\n#include \"llvm/DebugInfo/PDB/Native/InfoStream.h\"\n#include \"llvm/DebugInfo/PDB/Native/InfoStreamBuilder.h\"\n#include \"llvm/DebugInfo/PDB/Native/NativeSession.h\"\n#include \"llvm/DebugInfo/PDB/Native/PDBFile.h\"\n#include \"llvm/DebugInfo/PDB/Native/PDBFileBuilder.h\"\n#include \"llvm/DebugInfo/PDB/Native/PDBStringTableBuilder.h\"\n#include \"llvm/DebugInfo/PDB/Native/RawConstants.h\"\n#include \"llvm/DebugInfo/PDB/Native/RawError.h\"\n#include \"llvm/DebugInfo/PDB/Native/TpiStream.h\"\n#include \"llvm/DebugInfo/PDB/Native/TpiStreamBuilder.h\"\n#include \"llvm/DebugInfo/PDB/PDB.h\"\n#include \"llvm/DebugInfo/PDB/PDBSymbolCompiland.h\"\n#include \"llvm/DebugInfo/PDB/PDBSymbolData.h\"\n#include \"llvm/DebugInfo/PDB/PDBSymbolExe.h\"\n#include \"llvm/DebugInfo/PDB/PDBSymbolFunc.h\"\n#include \"llvm/DebugInfo/PDB/PDBSymbolPublicSymbol.h\"\n#include \"llvm/DebugInfo/PDB/PDBSymbolThunk.h\"\n#include \"llvm/DebugInfo/PDB/PDBSymbolTypeEnum.h\"\n#include \"llvm/DebugInfo/PDB/PDBSymbolTypeFunctionArg.h\"\n#include \"llvm/DebugInfo/PDB/PDBSymbolTypeFunctionSig.h\"\n#include \"llvm/DebugInfo/PDB/PDBSymbolTypeTypedef.h\"\n#include \"llvm/DebugInfo/PDB/PDBSymbolTypeUDT.h\"\n#include \"llvm/Support/BinaryByteStream.h\"\n#include \"llvm/Support/COM.h\"\n#include \"llvm/Support/CommandLine.h\"\n#include \"llvm/Support/ConvertUTF.h\"\n#include \"llvm/Support/FileOutputBuffer.h\"\n#include \"llvm/Support/FileSystem.h\"\n#include \"llvm/Support/Format.h\"\n#include \"llvm/Support/InitLLVM.h\"\n#include \"llvm/Support/LineIterator.h\"\n#include \"llvm/Support/ManagedStatic.h\"\n#include \"llvm/Support/MemoryBuffer.h\"\n#include \"llvm/Support/Path.h\"\n#include \"llvm/Support/PrettyStackTrace.h\"\n#include \"llvm/Support/Process.h\"\n#include \"llvm/Support/Regex.h\"\n#include \"llvm/Support/ScopedPrinter.h\"\n#include \"llvm/Support/Signals.h\"\n#include \"llvm/Support/raw_ostream.h\"\n\nusing namespace llvm;\nusing namespace llvm::codeview;\nusing namespace llvm::msf;\nusing namespace llvm::pdb;\n\nnamespace opts {\n\ncl::SubCommand DumpSubcommand(\"dump\", \"Dump MSF and CodeView debug info\");\ncl::SubCommand BytesSubcommand(\"bytes\", \"Dump raw bytes from the PDB file\");\n\ncl::SubCommand DiaDumpSubcommand(\"diadump\",\n                                 \"Dump debug information using a DIA-like API\");\n\ncl::SubCommand\n    PrettySubcommand(\"pretty\",\n                     \"Dump semantic information about types and symbols\");\n\ncl::SubCommand\n    YamlToPdbSubcommand(\"yaml2pdb\",\n                        \"Generate a PDB file from a YAML description\");\ncl::SubCommand\n    PdbToYamlSubcommand(\"pdb2yaml\",\n                        \"Generate a detailed YAML description of a PDB File\");\n\ncl::SubCommand MergeSubcommand(\"merge\",\n                               \"Merge multiple PDBs into a single PDB\");\n\ncl::SubCommand ExplainSubcommand(\"explain\",\n                                 \"Explain the meaning of a file offset\");\n\ncl::SubCommand ExportSubcommand(\"export\",\n                                \"Write binary data from a stream to a file\");\n\ncl::OptionCategory TypeCategory(\"Symbol Type Options\");\ncl::OptionCategory FilterCategory(\"Filtering and Sorting Options\");\ncl::OptionCategory OtherOptions(\"Other Options\");\n\ncl::ValuesClass ChunkValues = cl::values(\n    clEnumValN(ModuleSubsection::CrossScopeExports, \"cme\",\n               \"Cross module exports (DEBUG_S_CROSSSCOPEEXPORTS subsection)\"),\n    clEnumValN(ModuleSubsection::CrossScopeImports, \"cmi\",\n               \"Cross module imports (DEBUG_S_CROSSSCOPEIMPORTS subsection)\"),\n    clEnumValN(ModuleSubsection::FileChecksums, \"fc\",\n               \"File checksums (DEBUG_S_CHECKSUMS subsection)\"),\n    clEnumValN(ModuleSubsection::InlineeLines, \"ilines\",\n               \"Inlinee lines (DEBUG_S_INLINEELINES subsection)\"),\n    clEnumValN(ModuleSubsection::Lines, \"lines\",\n               \"Lines (DEBUG_S_LINES subsection)\"),\n    clEnumValN(ModuleSubsection::StringTable, \"strings\",\n               \"String Table (DEBUG_S_STRINGTABLE subsection) (not \"\n               \"typically present in PDB file)\"),\n    clEnumValN(ModuleSubsection::FrameData, \"frames\",\n               \"Frame Data (DEBUG_S_FRAMEDATA subsection)\"),\n    clEnumValN(ModuleSubsection::Symbols, \"symbols\",\n               \"Symbols (DEBUG_S_SYMBOLS subsection) (not typically \"\n               \"present in PDB file)\"),\n    clEnumValN(ModuleSubsection::CoffSymbolRVAs, \"rvas\",\n               \"COFF Symbol RVAs (DEBUG_S_COFF_SYMBOL_RVA subsection)\"),\n    clEnumValN(ModuleSubsection::Unknown, \"unknown\",\n               \"Any subsection not covered by another option\"),\n    clEnumValN(ModuleSubsection::All, \"all\", \"All known subsections\"));\n\nnamespace diadump {\ncl::list<std::string> InputFilenames(cl::Positional,\n                                     cl::desc(\"<input PDB files>\"),\n                                     cl::OneOrMore, cl::sub(DiaDumpSubcommand));\n\ncl::opt<bool> Native(\"native\", cl::desc(\"Use native PDB reader instead of DIA\"),\n                     cl::sub(DiaDumpSubcommand));\n\nstatic cl::opt<bool>\n    ShowClassHierarchy(\"hierarchy\", cl::desc(\"Show lexical and class parents\"),\n                       cl::sub(DiaDumpSubcommand));\nstatic cl::opt<bool> NoSymIndexIds(\n    \"no-ids\",\n    cl::desc(\"Don't show any SymIndexId fields (overrides -hierarchy)\"),\n    cl::sub(DiaDumpSubcommand));\n\nstatic cl::opt<bool>\n    Recurse(\"recurse\",\n            cl::desc(\"When dumping a SymIndexId, dump the full details of the \"\n                     \"corresponding record\"),\n            cl::sub(DiaDumpSubcommand));\n\nstatic cl::opt<bool> Enums(\"enums\", cl::desc(\"Dump enum types\"),\n                           cl::sub(DiaDumpSubcommand));\nstatic cl::opt<bool> Pointers(\"pointers\", cl::desc(\"Dump enum types\"),\n                              cl::sub(DiaDumpSubcommand));\nstatic cl::opt<bool> UDTs(\"udts\", cl::desc(\"Dump udt types\"),\n                          cl::sub(DiaDumpSubcommand));\nstatic cl::opt<bool> Compilands(\"compilands\",\n                                cl::desc(\"Dump compiland information\"),\n                                cl::sub(DiaDumpSubcommand));\nstatic cl::opt<bool> Funcsigs(\"funcsigs\",\n                              cl::desc(\"Dump function signature information\"),\n                              cl::sub(DiaDumpSubcommand));\nstatic cl::opt<bool> Arrays(\"arrays\", cl::desc(\"Dump array types\"),\n                            cl::sub(DiaDumpSubcommand));\nstatic cl::opt<bool> VTShapes(\"vtshapes\", cl::desc(\"Dump virtual table shapes\"),\n                              cl::sub(DiaDumpSubcommand));\nstatic cl::opt<bool> Typedefs(\"typedefs\", cl::desc(\"Dump typedefs\"),\n                              cl::sub(DiaDumpSubcommand));\n} // namespace diadump\n\nnamespace pretty {\ncl::list<std::string> InputFilenames(cl::Positional,\n                                     cl::desc(\"<input PDB files>\"),\n                                     cl::OneOrMore, cl::sub(PrettySubcommand));\n\ncl::opt<bool> InjectedSources(\"injected-sources\",\n                              cl::desc(\"Display injected sources\"),\n                              cl::cat(OtherOptions), cl::sub(PrettySubcommand));\ncl::opt<bool> ShowInjectedSourceContent(\n    \"injected-source-content\",\n    cl::desc(\"When displaying an injected source, display the file content\"),\n    cl::cat(OtherOptions), cl::sub(PrettySubcommand));\n\ncl::list<std::string> WithName(\n    \"with-name\",\n    cl::desc(\"Display any symbol or type with the specified exact name\"),\n    cl::cat(TypeCategory), cl::ZeroOrMore, cl::sub(PrettySubcommand));\n\ncl::opt<bool> Compilands(\"compilands\", cl::desc(\"Display compilands\"),\n                         cl::cat(TypeCategory), cl::sub(PrettySubcommand));\ncl::opt<bool> Symbols(\"module-syms\",\n                      cl::desc(\"Display symbols for each compiland\"),\n                      cl::cat(TypeCategory), cl::sub(PrettySubcommand));\ncl::opt<bool> Globals(\"globals\", cl::desc(\"Dump global symbols\"),\n                      cl::cat(TypeCategory), cl::sub(PrettySubcommand));\ncl::opt<bool> Externals(\"externals\", cl::desc(\"Dump external symbols\"),\n                        cl::cat(TypeCategory), cl::sub(PrettySubcommand));\ncl::list<SymLevel> SymTypes(\n    \"sym-types\", cl::desc(\"Type of symbols to dump (default all)\"),\n    cl::cat(TypeCategory), cl::sub(PrettySubcommand), cl::ZeroOrMore,\n    cl::values(\n        clEnumValN(SymLevel::Thunks, \"thunks\", \"Display thunk symbols\"),\n        clEnumValN(SymLevel::Data, \"data\", \"Display data symbols\"),\n        clEnumValN(SymLevel::Functions, \"funcs\", \"Display function symbols\"),\n        clEnumValN(SymLevel::All, \"all\", \"Display all symbols (default)\")));\n\ncl::opt<bool>\n    Types(\"types\",\n          cl::desc(\"Display all types (implies -classes, -enums, -typedefs)\"),\n          cl::cat(TypeCategory), cl::sub(PrettySubcommand));\ncl::opt<bool> Classes(\"classes\", cl::desc(\"Display class types\"),\n                      cl::cat(TypeCategory), cl::sub(PrettySubcommand));\ncl::opt<bool> Enums(\"enums\", cl::desc(\"Display enum types\"),\n                    cl::cat(TypeCategory), cl::sub(PrettySubcommand));\ncl::opt<bool> Typedefs(\"typedefs\", cl::desc(\"Display typedef types\"),\n                       cl::cat(TypeCategory), cl::sub(PrettySubcommand));\ncl::opt<bool> Funcsigs(\"funcsigs\", cl::desc(\"Display function signatures\"),\n                       cl::cat(TypeCategory), cl::sub(PrettySubcommand));\ncl::opt<bool> Pointers(\"pointers\", cl::desc(\"Display pointer types\"),\n                       cl::cat(TypeCategory), cl::sub(PrettySubcommand));\ncl::opt<bool> Arrays(\"arrays\", cl::desc(\"Display arrays\"),\n                     cl::cat(TypeCategory), cl::sub(PrettySubcommand));\ncl::opt<bool> VTShapes(\"vtshapes\", cl::desc(\"Display vftable shapes\"),\n                       cl::cat(TypeCategory), cl::sub(PrettySubcommand));\n\ncl::opt<SymbolSortMode> SymbolOrder(\n    \"symbol-order\", cl::desc(\"symbol sort order\"),\n    cl::init(SymbolSortMode::None),\n    cl::values(clEnumValN(SymbolSortMode::None, \"none\",\n                          \"Undefined / no particular sort order\"),\n               clEnumValN(SymbolSortMode::Name, \"name\", \"Sort symbols by name\"),\n               clEnumValN(SymbolSortMode::Size, \"size\",\n                          \"Sort symbols by size\")),\n    cl::cat(TypeCategory), cl::sub(PrettySubcommand));\n\ncl::opt<ClassSortMode> ClassOrder(\n    \"class-order\", cl::desc(\"Class sort order\"), cl::init(ClassSortMode::None),\n    cl::values(\n        clEnumValN(ClassSortMode::None, \"none\",\n                   \"Undefined / no particular sort order\"),\n        clEnumValN(ClassSortMode::Name, \"name\", \"Sort classes by name\"),\n        clEnumValN(ClassSortMode::Size, \"size\", \"Sort classes by size\"),\n        clEnumValN(ClassSortMode::Padding, \"padding\",\n                   \"Sort classes by amount of padding\"),\n        clEnumValN(ClassSortMode::PaddingPct, \"padding-pct\",\n                   \"Sort classes by percentage of space consumed by padding\"),\n        clEnumValN(ClassSortMode::PaddingImmediate, \"padding-imm\",\n                   \"Sort classes by amount of immediate padding\"),\n        clEnumValN(ClassSortMode::PaddingPctImmediate, \"padding-pct-imm\",\n                   \"Sort classes by percentage of space consumed by immediate \"\n                   \"padding\")),\n    cl::cat(TypeCategory), cl::sub(PrettySubcommand));\n\ncl::opt<ClassDefinitionFormat> ClassFormat(\n    \"class-definitions\", cl::desc(\"Class definition format\"),\n    cl::init(ClassDefinitionFormat::All),\n    cl::values(\n        clEnumValN(ClassDefinitionFormat::All, \"all\",\n                   \"Display all class members including data, constants, \"\n                   \"typedefs, functions, etc\"),\n        clEnumValN(ClassDefinitionFormat::Layout, \"layout\",\n                   \"Only display members that contribute to class size.\"),\n        clEnumValN(ClassDefinitionFormat::None, \"none\",\n                   \"Don't display class definitions\")),\n    cl::cat(TypeCategory), cl::sub(PrettySubcommand));\ncl::opt<uint32_t> ClassRecursionDepth(\n    \"class-recurse-depth\", cl::desc(\"Class recursion depth (0=no limit)\"),\n    cl::init(0), cl::cat(TypeCategory), cl::sub(PrettySubcommand));\n\ncl::opt<bool> Lines(\"lines\", cl::desc(\"Line tables\"), cl::cat(TypeCategory),\n                    cl::sub(PrettySubcommand));\ncl::opt<bool>\n    All(\"all\", cl::desc(\"Implies all other options in 'Symbol Types' category\"),\n        cl::cat(TypeCategory), cl::sub(PrettySubcommand));\n\ncl::opt<uint64_t> LoadAddress(\n    \"load-address\",\n    cl::desc(\"Assume the module is loaded at the specified address\"),\n    cl::cat(OtherOptions), cl::sub(PrettySubcommand));\ncl::opt<bool> Native(\"native\", cl::desc(\"Use native PDB reader instead of DIA\"),\n                     cl::cat(OtherOptions), cl::sub(PrettySubcommand));\ncl::opt<cl::boolOrDefault>\n    ColorOutput(\"color-output\",\n                cl::desc(\"Override use of color (default = isatty)\"),\n                cl::cat(OtherOptions), cl::sub(PrettySubcommand));\ncl::list<std::string> ExcludeTypes(\n    \"exclude-types\", cl::desc(\"Exclude types by regular expression\"),\n    cl::ZeroOrMore, cl::cat(FilterCategory), cl::sub(PrettySubcommand));\ncl::list<std::string> ExcludeSymbols(\n    \"exclude-symbols\", cl::desc(\"Exclude symbols by regular expression\"),\n    cl::ZeroOrMore, cl::cat(FilterCategory), cl::sub(PrettySubcommand));\ncl::list<std::string> ExcludeCompilands(\n    \"exclude-compilands\", cl::desc(\"Exclude compilands by regular expression\"),\n    cl::ZeroOrMore, cl::cat(FilterCategory), cl::sub(PrettySubcommand));\n\ncl::list<std::string> IncludeTypes(\n    \"include-types\",\n    cl::desc(\"Include only types which match a regular expression\"),\n    cl::ZeroOrMore, cl::cat(FilterCategory), cl::sub(PrettySubcommand));\ncl::list<std::string> IncludeSymbols(\n    \"include-symbols\",\n    cl::desc(\"Include only symbols which match a regular expression\"),\n    cl::ZeroOrMore, cl::cat(FilterCategory), cl::sub(PrettySubcommand));\ncl::list<std::string> IncludeCompilands(\n    \"include-compilands\",\n    cl::desc(\"Include only compilands those which match a regular expression\"),\n    cl::ZeroOrMore, cl::cat(FilterCategory), cl::sub(PrettySubcommand));\ncl::opt<uint32_t> SizeThreshold(\n    \"min-type-size\", cl::desc(\"Displays only those types which are greater \"\n                              \"than or equal to the specified size.\"),\n    cl::init(0), cl::cat(FilterCategory), cl::sub(PrettySubcommand));\ncl::opt<uint32_t> PaddingThreshold(\n    \"min-class-padding\", cl::desc(\"Displays only those classes which have at \"\n                                  \"least the specified amount of padding.\"),\n    cl::init(0), cl::cat(FilterCategory), cl::sub(PrettySubcommand));\ncl::opt<uint32_t> ImmediatePaddingThreshold(\n    \"min-class-padding-imm\",\n    cl::desc(\"Displays only those classes which have at least the specified \"\n             \"amount of immediate padding, ignoring padding internal to bases \"\n             \"and aggregates.\"),\n    cl::init(0), cl::cat(FilterCategory), cl::sub(PrettySubcommand));\n\ncl::opt<bool> ExcludeCompilerGenerated(\n    \"no-compiler-generated\",\n    cl::desc(\"Don't show compiler generated types and symbols\"),\n    cl::cat(FilterCategory), cl::sub(PrettySubcommand));\ncl::opt<bool>\n    ExcludeSystemLibraries(\"no-system-libs\",\n                           cl::desc(\"Don't show symbols from system libraries\"),\n                           cl::cat(FilterCategory), cl::sub(PrettySubcommand));\n\ncl::opt<bool> NoEnumDefs(\"no-enum-definitions\",\n                         cl::desc(\"Don't display full enum definitions\"),\n                         cl::cat(FilterCategory), cl::sub(PrettySubcommand));\n}\n\ncl::OptionCategory FileOptions(\"Module & File Options\");\n\nnamespace bytes {\ncl::OptionCategory MsfBytes(\"MSF File Options\");\ncl::OptionCategory DbiBytes(\"Dbi Stream Options\");\ncl::OptionCategory PdbBytes(\"PDB Stream Options\");\ncl::OptionCategory Types(\"Type Options\");\ncl::OptionCategory ModuleCategory(\"Module Options\");\n\nllvm::Optional<NumberRange> DumpBlockRange;\nllvm::Optional<NumberRange> DumpByteRange;\n\ncl::opt<std::string> DumpBlockRangeOpt(\n    \"block-range\", cl::value_desc(\"start[-end]\"),\n    cl::desc(\"Dump binary data from specified range of blocks.\"),\n    cl::sub(BytesSubcommand), cl::cat(MsfBytes));\n\ncl::opt<std::string>\n    DumpByteRangeOpt(\"byte-range\", cl::value_desc(\"start[-end]\"),\n                     cl::desc(\"Dump binary data from specified range of bytes\"),\n                     cl::sub(BytesSubcommand), cl::cat(MsfBytes));\n\ncl::list<std::string>\n    DumpStreamData(\"stream-data\", cl::CommaSeparated, cl::ZeroOrMore,\n                   cl::desc(\"Dump binary data from specified streams.  Format \"\n                            \"is SN[:Start][@Size]\"),\n                   cl::sub(BytesSubcommand), cl::cat(MsfBytes));\n\ncl::opt<bool> NameMap(\"name-map\", cl::desc(\"Dump bytes of PDB Name Map\"),\n                      cl::sub(BytesSubcommand), cl::cat(PdbBytes));\ncl::opt<bool> Fpm(\"fpm\", cl::desc(\"Dump free page map\"),\n                  cl::sub(BytesSubcommand), cl::cat(MsfBytes));\n\ncl::opt<bool> SectionContributions(\"sc\", cl::desc(\"Dump section contributions\"),\n                                   cl::sub(BytesSubcommand), cl::cat(DbiBytes));\ncl::opt<bool> SectionMap(\"sm\", cl::desc(\"Dump section map\"),\n                         cl::sub(BytesSubcommand), cl::cat(DbiBytes));\ncl::opt<bool> ModuleInfos(\"modi\", cl::desc(\"Dump module info\"),\n                          cl::sub(BytesSubcommand), cl::cat(DbiBytes));\ncl::opt<bool> FileInfo(\"files\", cl::desc(\"Dump source file info\"),\n                       cl::sub(BytesSubcommand), cl::cat(DbiBytes));\ncl::opt<bool> TypeServerMap(\"type-server\", cl::desc(\"Dump type server map\"),\n                            cl::sub(BytesSubcommand), cl::cat(DbiBytes));\ncl::opt<bool> ECData(\"ec\", cl::desc(\"Dump edit and continue map\"),\n                     cl::sub(BytesSubcommand), cl::cat(DbiBytes));\n\ncl::list<uint32_t>\n    TypeIndex(\"type\",\n              cl::desc(\"Dump the type record with the given type index\"),\n              cl::ZeroOrMore, cl::CommaSeparated, cl::sub(BytesSubcommand),\n              cl::cat(TypeCategory));\ncl::list<uint32_t>\n    IdIndex(\"id\", cl::desc(\"Dump the id record with the given type index\"),\n            cl::ZeroOrMore, cl::CommaSeparated, cl::sub(BytesSubcommand),\n            cl::cat(TypeCategory));\n\ncl::opt<uint32_t> ModuleIndex(\n    \"mod\",\n    cl::desc(\n        \"Limit options in the Modules category to the specified module index\"),\n    cl::Optional, cl::sub(BytesSubcommand), cl::cat(ModuleCategory));\ncl::opt<bool> ModuleSyms(\"syms\", cl::desc(\"Dump symbol record substream\"),\n                         cl::sub(BytesSubcommand), cl::cat(ModuleCategory));\ncl::opt<bool> ModuleC11(\"c11-chunks\", cl::Hidden,\n                        cl::desc(\"Dump C11 CodeView debug chunks\"),\n                        cl::sub(BytesSubcommand), cl::cat(ModuleCategory));\ncl::opt<bool> ModuleC13(\"chunks\",\n                        cl::desc(\"Dump C13 CodeView debug chunk subsection\"),\n                        cl::sub(BytesSubcommand), cl::cat(ModuleCategory));\ncl::opt<bool> SplitChunks(\n    \"split-chunks\",\n    cl::desc(\n        \"When dumping debug chunks, show a different section for each chunk\"),\n    cl::sub(BytesSubcommand), cl::cat(ModuleCategory));\ncl::list<std::string> InputFilenames(cl::Positional,\n                                     cl::desc(\"<input PDB files>\"),\n                                     cl::OneOrMore, cl::sub(BytesSubcommand));\n\n} // namespace bytes\n\nnamespace dump {\n\ncl::OptionCategory MsfOptions(\"MSF Container Options\");\ncl::OptionCategory TypeOptions(\"Type Record Options\");\ncl::OptionCategory SymbolOptions(\"Symbol Options\");\ncl::OptionCategory MiscOptions(\"Miscellaneous Options\");\n\n// MSF OPTIONS\ncl::opt<bool> DumpSummary(\"summary\", cl::desc(\"dump file summary\"),\n                          cl::cat(MsfOptions), cl::sub(DumpSubcommand));\ncl::opt<bool> DumpStreams(\"streams\",\n                          cl::desc(\"dump summary of the PDB streams\"),\n                          cl::cat(MsfOptions), cl::sub(DumpSubcommand));\ncl::opt<bool> DumpStreamBlocks(\n    \"stream-blocks\",\n    cl::desc(\"Add block information to the output of -streams\"),\n    cl::cat(MsfOptions), cl::sub(DumpSubcommand));\ncl::opt<bool> DumpSymbolStats(\n    \"sym-stats\",\n    cl::desc(\"Dump a detailed breakdown of symbol usage/size for each module\"),\n    cl::cat(MsfOptions), cl::sub(DumpSubcommand));\ncl::opt<bool> DumpTypeStats(\n    \"type-stats\",\n    cl::desc(\"Dump a detailed breakdown of type usage/size\"),\n    cl::cat(MsfOptions), cl::sub(DumpSubcommand));\ncl::opt<bool> DumpIDStats(\n    \"id-stats\",\n    cl::desc(\"Dump a detailed breakdown of IPI types usage/size\"),\n    cl::cat(MsfOptions), cl::sub(DumpSubcommand));\ncl::opt<bool> DumpUdtStats(\n    \"udt-stats\",\n    cl::desc(\"Dump a detailed breakdown of S_UDT record usage / stats\"),\n    cl::cat(MsfOptions), cl::sub(DumpSubcommand));\n\n// TYPE OPTIONS\ncl::opt<bool> DumpTypes(\"types\",\n                        cl::desc(\"dump CodeView type records from TPI stream\"),\n                        cl::cat(TypeOptions), cl::sub(DumpSubcommand));\ncl::opt<bool> DumpTypeData(\n    \"type-data\",\n    cl::desc(\"dump CodeView type record raw bytes from TPI stream\"),\n    cl::cat(TypeOptions), cl::sub(DumpSubcommand));\ncl::opt<bool>\n    DumpTypeRefStats(\"type-ref-stats\",\n                     cl::desc(\"dump statistics on the number and size of types \"\n                              \"transitively referenced by symbol records\"),\n                     cl::cat(TypeOptions), cl::sub(DumpSubcommand));\n\ncl::opt<bool> DumpTypeExtras(\"type-extras\",\n                             cl::desc(\"dump type hashes and index offsets\"),\n                             cl::cat(TypeOptions), cl::sub(DumpSubcommand));\n\ncl::opt<bool> DontResolveForwardRefs(\n    \"dont-resolve-forward-refs\",\n    cl::desc(\"When dumping type records for classes, unions, enums, and \"\n             \"structs, don't try to resolve forward references\"),\n    cl::cat(TypeOptions), cl::sub(DumpSubcommand));\n\ncl::list<uint32_t> DumpTypeIndex(\n    \"type-index\", cl::ZeroOrMore, cl::CommaSeparated,\n    cl::desc(\"only dump types with the specified hexadecimal type index\"),\n    cl::cat(TypeOptions), cl::sub(DumpSubcommand));\n\ncl::opt<bool> DumpIds(\"ids\",\n                      cl::desc(\"dump CodeView type records from IPI stream\"),\n                      cl::cat(TypeOptions), cl::sub(DumpSubcommand));\ncl::opt<bool>\n    DumpIdData(\"id-data\",\n               cl::desc(\"dump CodeView type record raw bytes from IPI stream\"),\n               cl::cat(TypeOptions), cl::sub(DumpSubcommand));\n\ncl::opt<bool> DumpIdExtras(\"id-extras\",\n                           cl::desc(\"dump id hashes and index offsets\"),\n                           cl::cat(TypeOptions), cl::sub(DumpSubcommand));\ncl::list<uint32_t> DumpIdIndex(\n    \"id-index\", cl::ZeroOrMore, cl::CommaSeparated,\n    cl::desc(\"only dump ids with the specified hexadecimal type index\"),\n    cl::cat(TypeOptions), cl::sub(DumpSubcommand));\n\ncl::opt<bool> DumpTypeDependents(\n    \"dependents\",\n    cl::desc(\"In conjunection with -type-index and -id-index, dumps the entire \"\n             \"dependency graph for the specified index instead of \"\n             \"just the single record with the specified index\"),\n    cl::cat(TypeOptions), cl::sub(DumpSubcommand));\n\n// SYMBOL OPTIONS\ncl::opt<bool> DumpGlobals(\"globals\", cl::desc(\"dump Globals symbol records\"),\n                          cl::cat(SymbolOptions), cl::sub(DumpSubcommand));\ncl::opt<bool> DumpGlobalExtras(\"global-extras\", cl::desc(\"dump Globals hashes\"),\n                               cl::cat(SymbolOptions), cl::sub(DumpSubcommand));\ncl::list<std::string> DumpGlobalNames(\n    \"global-name\",\n    cl::desc(\n        \"With -globals, only dump globals whose name matches the given value\"),\n    cl::cat(SymbolOptions), cl::sub(DumpSubcommand), cl::ZeroOrMore);\ncl::opt<bool> DumpPublics(\"publics\", cl::desc(\"dump Publics stream data\"),\n                          cl::cat(SymbolOptions), cl::sub(DumpSubcommand));\ncl::opt<bool> DumpPublicExtras(\"public-extras\",\n                               cl::desc(\"dump Publics hashes and address maps\"),\n                               cl::cat(SymbolOptions), cl::sub(DumpSubcommand));\ncl::opt<bool>\n    DumpGSIRecords(\"gsi-records\",\n                   cl::desc(\"dump public / global common record stream\"),\n                   cl::cat(SymbolOptions), cl::sub(DumpSubcommand));\ncl::opt<bool> DumpSymbols(\"symbols\", cl::desc(\"dump module symbols\"),\n                          cl::cat(SymbolOptions), cl::sub(DumpSubcommand));\n\ncl::opt<bool>\n    DumpSymRecordBytes(\"sym-data\",\n                       cl::desc(\"dump CodeView symbol record raw bytes\"),\n                       cl::cat(SymbolOptions), cl::sub(DumpSubcommand));\n\ncl::opt<bool> DumpFpo(\"fpo\", cl::desc(\"dump FPO records\"),\n                      cl::cat(SymbolOptions), cl::sub(DumpSubcommand));\n\n// MODULE & FILE OPTIONS\ncl::opt<bool> DumpModules(\"modules\", cl::desc(\"dump compiland information\"),\n                          cl::cat(FileOptions), cl::sub(DumpSubcommand));\ncl::opt<bool> DumpModuleFiles(\n    \"files\",\n    cl::desc(\"Dump the source files that contribute to each module's.\"),\n    cl::cat(FileOptions), cl::sub(DumpSubcommand));\ncl::opt<bool> DumpLines(\n    \"l\",\n    cl::desc(\"dump source file/line information (DEBUG_S_LINES subsection)\"),\n    cl::cat(FileOptions), cl::sub(DumpSubcommand));\ncl::opt<bool> DumpInlineeLines(\n    \"il\",\n    cl::desc(\"dump inlinee line information (DEBUG_S_INLINEELINES subsection)\"),\n    cl::cat(FileOptions), cl::sub(DumpSubcommand));\ncl::opt<bool> DumpXmi(\n    \"xmi\",\n    cl::desc(\n        \"dump cross module imports (DEBUG_S_CROSSSCOPEIMPORTS subsection)\"),\n    cl::cat(FileOptions), cl::sub(DumpSubcommand));\ncl::opt<bool> DumpXme(\n    \"xme\",\n    cl::desc(\n        \"dump cross module exports (DEBUG_S_CROSSSCOPEEXPORTS subsection)\"),\n    cl::cat(FileOptions), cl::sub(DumpSubcommand));\ncl::opt<uint32_t> DumpModi(\"modi\", cl::Optional,\n                           cl::desc(\"For all options that iterate over \"\n                                    \"modules, limit to the specified module\"),\n                           cl::cat(FileOptions), cl::sub(DumpSubcommand));\ncl::opt<bool> JustMyCode(\"jmc\", cl::Optional,\n                         cl::desc(\"For all options that iterate over modules, \"\n                                  \"ignore modules from system libraries\"),\n                         cl::cat(FileOptions), cl::sub(DumpSubcommand));\n\n// MISCELLANEOUS OPTIONS\ncl::opt<bool> DumpNamedStreams(\"named-streams\",\n                               cl::desc(\"dump PDB named stream table\"),\n                               cl::cat(MiscOptions), cl::sub(DumpSubcommand));\n\ncl::opt<bool> DumpStringTable(\"string-table\", cl::desc(\"dump PDB String Table\"),\n                              cl::cat(MiscOptions), cl::sub(DumpSubcommand));\ncl::opt<bool> DumpStringTableDetails(\"string-table-details\",\n                                     cl::desc(\"dump PDB String Table Details\"),\n                                     cl::cat(MiscOptions),\n                                     cl::sub(DumpSubcommand));\n\ncl::opt<bool> DumpSectionContribs(\"section-contribs\",\n                                  cl::desc(\"dump section contributions\"),\n                                  cl::cat(MiscOptions),\n                                  cl::sub(DumpSubcommand));\ncl::opt<bool> DumpSectionMap(\"section-map\", cl::desc(\"dump section map\"),\n                             cl::cat(MiscOptions), cl::sub(DumpSubcommand));\ncl::opt<bool> DumpSectionHeaders(\"section-headers\",\n                                 cl::desc(\"Dump image section headers\"),\n                                 cl::cat(MiscOptions), cl::sub(DumpSubcommand));\n\ncl::opt<bool> RawAll(\"all\", cl::desc(\"Implies most other options.\"),\n                     cl::cat(MiscOptions), cl::sub(DumpSubcommand));\n\ncl::list<std::string> InputFilenames(cl::Positional,\n                                     cl::desc(\"<input PDB files>\"),\n                                     cl::OneOrMore, cl::sub(DumpSubcommand));\n}\n\nnamespace yaml2pdb {\ncl::opt<std::string>\n    YamlPdbOutputFile(\"pdb\", cl::desc(\"the name of the PDB file to write\"),\n                      cl::sub(YamlToPdbSubcommand));\n\ncl::opt<std::string> InputFilename(cl::Positional,\n                                   cl::desc(\"<input YAML file>\"), cl::Required,\n                                   cl::sub(YamlToPdbSubcommand));\n}\n\nnamespace pdb2yaml {\ncl::opt<bool> All(\"all\",\n                  cl::desc(\"Dump everything we know how to dump.\"),\n                  cl::sub(PdbToYamlSubcommand), cl::init(false));\ncl::opt<bool> NoFileHeaders(\"no-file-headers\",\n                            cl::desc(\"Do not dump MSF file headers\"),\n                            cl::sub(PdbToYamlSubcommand), cl::init(false));\ncl::opt<bool> Minimal(\"minimal\",\n                      cl::desc(\"Don't write fields with default values\"),\n                      cl::sub(PdbToYamlSubcommand), cl::init(false));\n\ncl::opt<bool> StreamMetadata(\n    \"stream-metadata\",\n    cl::desc(\"Dump the number of streams and each stream's size\"),\n    cl::sub(PdbToYamlSubcommand), cl::init(false));\ncl::opt<bool> StreamDirectory(\n    \"stream-directory\",\n    cl::desc(\"Dump each stream's block map (implies -stream-metadata)\"),\n    cl::sub(PdbToYamlSubcommand), cl::init(false));\ncl::opt<bool> PdbStream(\"pdb-stream\",\n                        cl::desc(\"Dump the PDB Stream (Stream 1)\"),\n                        cl::sub(PdbToYamlSubcommand), cl::init(false));\n\ncl::opt<bool> StringTable(\"string-table\", cl::desc(\"Dump the PDB String Table\"),\n                          cl::sub(PdbToYamlSubcommand), cl::init(false));\n\ncl::opt<bool> DbiStream(\"dbi-stream\",\n                        cl::desc(\"Dump the DBI Stream Headers (Stream 2)\"),\n                        cl::sub(PdbToYamlSubcommand), cl::init(false));\n\ncl::opt<bool> TpiStream(\"tpi-stream\",\n                        cl::desc(\"Dump the TPI Stream (Stream 3)\"),\n                        cl::sub(PdbToYamlSubcommand), cl::init(false));\n\ncl::opt<bool> IpiStream(\"ipi-stream\",\n                        cl::desc(\"Dump the IPI Stream (Stream 5)\"),\n                        cl::sub(PdbToYamlSubcommand), cl::init(false));\n\ncl::opt<bool> PublicsStream(\"publics-stream\",\n                            cl::desc(\"Dump the Publics Stream\"),\n                            cl::sub(PdbToYamlSubcommand), cl::init(false));\n\n// MODULE & FILE OPTIONS\ncl::opt<bool> DumpModules(\"modules\", cl::desc(\"dump compiland information\"),\n                          cl::cat(FileOptions), cl::sub(PdbToYamlSubcommand));\ncl::opt<bool> DumpModuleFiles(\"module-files\", cl::desc(\"dump file information\"),\n                              cl::cat(FileOptions),\n                              cl::sub(PdbToYamlSubcommand));\ncl::list<ModuleSubsection> DumpModuleSubsections(\n    \"subsections\", cl::ZeroOrMore, cl::CommaSeparated,\n    cl::desc(\"dump subsections from each module's debug stream\"), ChunkValues,\n    cl::cat(FileOptions), cl::sub(PdbToYamlSubcommand));\ncl::opt<bool> DumpModuleSyms(\"module-syms\", cl::desc(\"dump module symbols\"),\n                             cl::cat(FileOptions),\n                             cl::sub(PdbToYamlSubcommand));\n\ncl::list<std::string> InputFilename(cl::Positional,\n                                    cl::desc(\"<input PDB file>\"), cl::Required,\n                                    cl::sub(PdbToYamlSubcommand));\n} // namespace pdb2yaml\n\nnamespace merge {\ncl::list<std::string> InputFilenames(cl::Positional,\n                                     cl::desc(\"<input PDB files>\"),\n                                     cl::OneOrMore, cl::sub(MergeSubcommand));\ncl::opt<std::string>\n    PdbOutputFile(\"pdb\", cl::desc(\"the name of the PDB file to write\"),\n                  cl::sub(MergeSubcommand));\n}\n\nnamespace explain {\ncl::list<std::string> InputFilename(cl::Positional,\n                                    cl::desc(\"<input PDB file>\"), cl::Required,\n                                    cl::sub(ExplainSubcommand));\n\ncl::list<uint64_t> Offsets(\"offset\", cl::desc(\"The file offset to explain\"),\n                           cl::sub(ExplainSubcommand), cl::OneOrMore);\n\ncl::opt<InputFileType> InputType(\n    \"input-type\", cl::desc(\"Specify how to interpret the input file\"),\n    cl::init(InputFileType::PDBFile), cl::Optional, cl::sub(ExplainSubcommand),\n    cl::values(clEnumValN(InputFileType::PDBFile, \"pdb-file\",\n                          \"Treat input as a PDB file (default)\"),\n               clEnumValN(InputFileType::PDBStream, \"pdb-stream\",\n                          \"Treat input as raw contents of PDB stream\"),\n               clEnumValN(InputFileType::DBIStream, \"dbi-stream\",\n                          \"Treat input as raw contents of DBI stream\"),\n               clEnumValN(InputFileType::Names, \"names-stream\",\n                          \"Treat input as raw contents of /names named stream\"),\n               clEnumValN(InputFileType::ModuleStream, \"mod-stream\",\n                          \"Treat input as raw contents of a module stream\")));\n} // namespace explain\n\nnamespace exportstream {\ncl::list<std::string> InputFilename(cl::Positional,\n                                    cl::desc(\"<input PDB file>\"), cl::Required,\n                                    cl::sub(ExportSubcommand));\ncl::opt<std::string> OutputFile(\"out\",\n                                cl::desc(\"The file to write the stream to\"),\n                                cl::Required, cl::sub(ExportSubcommand));\ncl::opt<std::string>\n    Stream(\"stream\", cl::Required,\n           cl::desc(\"The index or name of the stream whose contents to export\"),\n           cl::sub(ExportSubcommand));\ncl::opt<bool> ForceName(\"name\",\n                        cl::desc(\"Force the interpretation of -stream as a \"\n                                 \"string, even if it is a valid integer\"),\n                        cl::sub(ExportSubcommand), cl::Optional,\n                        cl::init(false));\n} // namespace exportstream\n}\n\nstatic ExitOnError ExitOnErr;\n\nstatic void yamlToPdb(StringRef Path) {\n  BumpPtrAllocator Allocator;\n  ErrorOr<std::unique_ptr<MemoryBuffer>> ErrorOrBuffer =\n      MemoryBuffer::getFileOrSTDIN(Path, /*FileSize=*/-1,\n                                   /*RequiresNullTerminator=*/false);\n\n  if (ErrorOrBuffer.getError()) {\n    ExitOnErr(createFileError(Path, errorCodeToError(ErrorOrBuffer.getError())));\n  }\n\n  std::unique_ptr<MemoryBuffer> &Buffer = ErrorOrBuffer.get();\n\n  llvm::yaml::Input In(Buffer->getBuffer());\n  pdb::yaml::PdbObject YamlObj(Allocator);\n  In >> YamlObj;\n\n  PDBFileBuilder Builder(Allocator);\n\n  uint32_t BlockSize = 4096;\n  if (YamlObj.Headers.hasValue())\n    BlockSize = YamlObj.Headers->SuperBlock.BlockSize;\n  ExitOnErr(Builder.initialize(BlockSize));\n  // Add each of the reserved streams.  We ignore stream metadata in the\n  // yaml, because we will reconstruct our own view of the streams.  For\n  // example, the YAML may say that there were 20 streams in the original\n  // PDB, but maybe we only dump a subset of those 20 streams, so we will\n  // have fewer, and the ones we do have may end up with different indices\n  // than the ones in the original PDB.  So we just start with a clean slate.\n  for (uint32_t I = 0; I < kSpecialStreamCount; ++I)\n    ExitOnErr(Builder.getMsfBuilder().addStream(0));\n\n  StringsAndChecksums Strings;\n  Strings.setStrings(std::make_shared<DebugStringTableSubsection>());\n\n  if (YamlObj.StringTable.hasValue()) {\n    for (auto S : *YamlObj.StringTable)\n      Strings.strings()->insert(S);\n  }\n\n  pdb::yaml::PdbInfoStream DefaultInfoStream;\n  pdb::yaml::PdbDbiStream DefaultDbiStream;\n  pdb::yaml::PdbTpiStream DefaultTpiStream;\n  pdb::yaml::PdbTpiStream DefaultIpiStream;\n\n  const auto &Info = YamlObj.PdbStream.getValueOr(DefaultInfoStream);\n\n  auto &InfoBuilder = Builder.getInfoBuilder();\n  InfoBuilder.setAge(Info.Age);\n  InfoBuilder.setGuid(Info.Guid);\n  InfoBuilder.setSignature(Info.Signature);\n  InfoBuilder.setVersion(Info.Version);\n  for (auto F : Info.Features)\n    InfoBuilder.addFeature(F);\n\n  const auto &Dbi = YamlObj.DbiStream.getValueOr(DefaultDbiStream);\n  auto &DbiBuilder = Builder.getDbiBuilder();\n  DbiBuilder.setAge(Dbi.Age);\n  DbiBuilder.setBuildNumber(Dbi.BuildNumber);\n  DbiBuilder.setFlags(Dbi.Flags);\n  DbiBuilder.setMachineType(Dbi.MachineType);\n  DbiBuilder.setPdbDllRbld(Dbi.PdbDllRbld);\n  DbiBuilder.setPdbDllVersion(Dbi.PdbDllVersion);\n  DbiBuilder.setVersionHeader(Dbi.VerHeader);\n  for (const auto &MI : Dbi.ModInfos) {\n    auto &ModiBuilder = ExitOnErr(DbiBuilder.addModuleInfo(MI.Mod));\n    ModiBuilder.setObjFileName(MI.Obj);\n\n    for (auto S : MI.SourceFiles)\n      ExitOnErr(DbiBuilder.addModuleSourceFile(ModiBuilder, S));\n    if (MI.Modi.hasValue()) {\n      const auto &ModiStream = *MI.Modi;\n      for (auto Symbol : ModiStream.Symbols) {\n        ModiBuilder.addSymbol(\n            Symbol.toCodeViewSymbol(Allocator, CodeViewContainer::Pdb));\n      }\n    }\n\n    // Each module has its own checksum subsection, so scan for it every time.\n    Strings.setChecksums(nullptr);\n    CodeViewYAML::initializeStringsAndChecksums(MI.Subsections, Strings);\n\n    auto CodeViewSubsections = ExitOnErr(CodeViewYAML::toCodeViewSubsectionList(\n        Allocator, MI.Subsections, Strings));\n    for (auto &SS : CodeViewSubsections) {\n      ModiBuilder.addDebugSubsection(SS);\n    }\n  }\n\n  auto &TpiBuilder = Builder.getTpiBuilder();\n  const auto &Tpi = YamlObj.TpiStream.getValueOr(DefaultTpiStream);\n  TpiBuilder.setVersionHeader(Tpi.Version);\n  AppendingTypeTableBuilder TS(Allocator);\n  for (const auto &R : Tpi.Records) {\n    CVType Type = R.toCodeViewRecord(TS);\n    TpiBuilder.addTypeRecord(Type.RecordData, None);\n  }\n\n  const auto &Ipi = YamlObj.IpiStream.getValueOr(DefaultIpiStream);\n  auto &IpiBuilder = Builder.getIpiBuilder();\n  IpiBuilder.setVersionHeader(Ipi.Version);\n  for (const auto &R : Ipi.Records) {\n    CVType Type = R.toCodeViewRecord(TS);\n    IpiBuilder.addTypeRecord(Type.RecordData, None);\n  }\n\n  Builder.getStringTableBuilder().setStrings(*Strings.strings());\n\n  codeview::GUID IgnoredOutGuid;\n  ExitOnErr(Builder.commit(opts::yaml2pdb::YamlPdbOutputFile, &IgnoredOutGuid));\n}\n\nstatic PDBFile &loadPDB(StringRef Path, std::unique_ptr<IPDBSession> &Session) {\n  ExitOnErr(loadDataForPDB(PDB_ReaderType::Native, Path, Session));\n\n  NativeSession *NS = static_cast<NativeSession *>(Session.get());\n  return NS->getPDBFile();\n}\n\nstatic void pdb2Yaml(StringRef Path) {\n  std::unique_ptr<IPDBSession> Session;\n  auto &File = loadPDB(Path, Session);\n\n  auto O = std::make_unique<YAMLOutputStyle>(File);\n  O = std::make_unique<YAMLOutputStyle>(File);\n\n  ExitOnErr(O->dump());\n}\n\nstatic void dumpRaw(StringRef Path) {\n  InputFile IF = ExitOnErr(InputFile::open(Path));\n\n  auto O = std::make_unique<DumpOutputStyle>(IF);\n  ExitOnErr(O->dump());\n}\n\nstatic void dumpBytes(StringRef Path) {\n  std::unique_ptr<IPDBSession> Session;\n  auto &File = loadPDB(Path, Session);\n\n  auto O = std::make_unique<BytesOutputStyle>(File);\n\n  ExitOnErr(O->dump());\n}\n\nbool opts::pretty::shouldDumpSymLevel(SymLevel Search) {\n  if (SymTypes.empty())\n    return true;\n  if (llvm::is_contained(SymTypes, Search))\n    return true;\n  if (llvm::is_contained(SymTypes, SymLevel::All))\n    return true;\n  return false;\n}\n\nuint32_t llvm::pdb::getTypeLength(const PDBSymbolData &Symbol) {\n  auto SymbolType = Symbol.getType();\n  const IPDBRawSymbol &RawType = SymbolType->getRawSymbol();\n\n  return RawType.getLength();\n}\n\nbool opts::pretty::compareFunctionSymbols(\n    const std::unique_ptr<PDBSymbolFunc> &F1,\n    const std::unique_ptr<PDBSymbolFunc> &F2) {\n  assert(opts::pretty::SymbolOrder != opts::pretty::SymbolSortMode::None);\n\n  if (opts::pretty::SymbolOrder == opts::pretty::SymbolSortMode::Name)\n    return F1->getName() < F2->getName();\n\n  // Note that we intentionally sort in descending order on length, since\n  // long functions are more interesting than short functions.\n  return F1->getLength() > F2->getLength();\n}\n\nbool opts::pretty::compareDataSymbols(\n    const std::unique_ptr<PDBSymbolData> &F1,\n    const std::unique_ptr<PDBSymbolData> &F2) {\n  assert(opts::pretty::SymbolOrder != opts::pretty::SymbolSortMode::None);\n\n  if (opts::pretty::SymbolOrder == opts::pretty::SymbolSortMode::Name)\n    return F1->getName() < F2->getName();\n\n  // Note that we intentionally sort in descending order on length, since\n  // large types are more interesting than short ones.\n  return getTypeLength(*F1) > getTypeLength(*F2);\n}\n\nstatic std::string stringOr(std::string Str, std::string IfEmpty) {\n  return (Str.empty()) ? IfEmpty : Str;\n}\n\nstatic void dumpInjectedSources(LinePrinter &Printer, IPDBSession &Session) {\n  auto Sources = Session.getInjectedSources();\n  if (!Sources || !Sources->getChildCount()) {\n    Printer.printLine(\"There are no injected sources.\");\n    return;\n  }\n\n  while (auto IS = Sources->getNext()) {\n    Printer.NewLine();\n    std::string File = stringOr(IS->getFileName(), \"<null>\");\n    uint64_t Size = IS->getCodeByteSize();\n    std::string Obj = stringOr(IS->getObjectFileName(), \"<null>\");\n    std::string VFName = stringOr(IS->getVirtualFileName(), \"<null>\");\n    uint32_t CRC = IS->getCrc32();\n\n    WithColor(Printer, PDB_ColorItem::Path).get() << File;\n    Printer << \" (\";\n    WithColor(Printer, PDB_ColorItem::LiteralValue).get() << Size;\n    Printer << \" bytes): \";\n    WithColor(Printer, PDB_ColorItem::Keyword).get() << \"obj\";\n    Printer << \"=\";\n    WithColor(Printer, PDB_ColorItem::Path).get() << Obj;\n    Printer << \", \";\n    WithColor(Printer, PDB_ColorItem::Keyword).get() << \"vname\";\n    Printer << \"=\";\n    WithColor(Printer, PDB_ColorItem::Path).get() << VFName;\n    Printer << \", \";\n    WithColor(Printer, PDB_ColorItem::Keyword).get() << \"crc\";\n    Printer << \"=\";\n    WithColor(Printer, PDB_ColorItem::LiteralValue).get() << CRC;\n    Printer << \", \";\n    WithColor(Printer, PDB_ColorItem::Keyword).get() << \"compression\";\n    Printer << \"=\";\n    dumpPDBSourceCompression(\n        WithColor(Printer, PDB_ColorItem::LiteralValue).get(),\n        IS->getCompression());\n\n    if (!opts::pretty::ShowInjectedSourceContent)\n      continue;\n\n    // Set the indent level to 0 when printing file content.\n    int Indent = Printer.getIndentLevel();\n    Printer.Unindent(Indent);\n\n    if (IS->getCompression() == PDB_SourceCompression::None)\n      Printer.printLine(IS->getCode());\n    else\n      Printer.formatBinary(\"Compressed data\",\n                           arrayRefFromStringRef(IS->getCode()),\n                           /*StartOffset=*/0);\n\n    // Re-indent back to the original level.\n    Printer.Indent(Indent);\n  }\n}\n\ntemplate <typename OuterT, typename ChildT>\nvoid diaDumpChildren(PDBSymbol &Outer, PdbSymbolIdField Ids,\n                     PdbSymbolIdField Recurse) {\n  OuterT *ConcreteOuter = dyn_cast<OuterT>(&Outer);\n  if (!ConcreteOuter)\n    return;\n\n  auto Children = ConcreteOuter->template findAllChildren<ChildT>();\n  while (auto Child = Children->getNext()) {\n    outs() << \"  {\";\n    Child->defaultDump(outs(), 4, Ids, Recurse);\n    outs() << \"\\n  }\\n\";\n  }\n}\n\nstatic void dumpDia(StringRef Path) {\n  std::unique_ptr<IPDBSession> Session;\n\n  const auto ReaderType =\n      opts::diadump::Native ? PDB_ReaderType::Native : PDB_ReaderType::DIA;\n  ExitOnErr(loadDataForPDB(ReaderType, Path, Session));\n\n  auto GlobalScope = Session->getGlobalScope();\n\n  std::vector<PDB_SymType> SymTypes;\n\n  if (opts::diadump::Compilands)\n    SymTypes.push_back(PDB_SymType::Compiland);\n  if (opts::diadump::Enums)\n    SymTypes.push_back(PDB_SymType::Enum);\n  if (opts::diadump::Pointers)\n    SymTypes.push_back(PDB_SymType::PointerType);\n  if (opts::diadump::UDTs)\n    SymTypes.push_back(PDB_SymType::UDT);\n  if (opts::diadump::Funcsigs)\n    SymTypes.push_back(PDB_SymType::FunctionSig);\n  if (opts::diadump::Arrays)\n    SymTypes.push_back(PDB_SymType::ArrayType);\n  if (opts::diadump::VTShapes)\n    SymTypes.push_back(PDB_SymType::VTableShape);\n  if (opts::diadump::Typedefs)\n    SymTypes.push_back(PDB_SymType::Typedef);\n  PdbSymbolIdField Ids = opts::diadump::NoSymIndexIds ? PdbSymbolIdField::None\n                                                      : PdbSymbolIdField::All;\n\n  PdbSymbolIdField Recurse = PdbSymbolIdField::None;\n  if (opts::diadump::Recurse)\n    Recurse = PdbSymbolIdField::All;\n  if (!opts::diadump::ShowClassHierarchy)\n    Ids &= ~(PdbSymbolIdField::ClassParent | PdbSymbolIdField::LexicalParent);\n\n  for (PDB_SymType ST : SymTypes) {\n    auto Children = GlobalScope->findAllChildren(ST);\n    while (auto Child = Children->getNext()) {\n      outs() << \"{\";\n      Child->defaultDump(outs(), 2, Ids, Recurse);\n\n      diaDumpChildren<PDBSymbolTypeEnum, PDBSymbolData>(*Child, Ids, Recurse);\n      outs() << \"\\n}\\n\";\n    }\n  }\n}\n\nstatic void dumpPretty(StringRef Path) {\n  std::unique_ptr<IPDBSession> Session;\n\n  const auto ReaderType =\n      opts::pretty::Native ? PDB_ReaderType::Native : PDB_ReaderType::DIA;\n  ExitOnErr(loadDataForPDB(ReaderType, Path, Session));\n\n  if (opts::pretty::LoadAddress)\n    Session->setLoadAddress(opts::pretty::LoadAddress);\n\n  auto &Stream = outs();\n  const bool UseColor = opts::pretty::ColorOutput == cl::BOU_UNSET\n                            ? Stream.has_colors()\n                            : opts::pretty::ColorOutput == cl::BOU_TRUE;\n  LinePrinter Printer(2, UseColor, Stream);\n\n  auto GlobalScope(Session->getGlobalScope());\n  if (!GlobalScope)\n    return;\n  std::string FileName(GlobalScope->getSymbolsFileName());\n\n  WithColor(Printer, PDB_ColorItem::None).get() << \"Summary for \";\n  WithColor(Printer, PDB_ColorItem::Path).get() << FileName;\n  Printer.Indent();\n  uint64_t FileSize = 0;\n\n  Printer.NewLine();\n  WithColor(Printer, PDB_ColorItem::Identifier).get() << \"Size\";\n  if (!sys::fs::file_size(FileName, FileSize)) {\n    Printer << \": \" << FileSize << \" bytes\";\n  } else {\n    Printer << \": (Unable to obtain file size)\";\n  }\n\n  Printer.NewLine();\n  WithColor(Printer, PDB_ColorItem::Identifier).get() << \"Guid\";\n  Printer << \": \" << GlobalScope->getGuid();\n\n  Printer.NewLine();\n  WithColor(Printer, PDB_ColorItem::Identifier).get() << \"Age\";\n  Printer << \": \" << GlobalScope->getAge();\n\n  Printer.NewLine();\n  WithColor(Printer, PDB_ColorItem::Identifier).get() << \"Attributes\";\n  Printer << \": \";\n  if (GlobalScope->hasCTypes())\n    outs() << \"HasCTypes \";\n  if (GlobalScope->hasPrivateSymbols())\n    outs() << \"HasPrivateSymbols \";\n  Printer.Unindent();\n\n  if (!opts::pretty::WithName.empty()) {\n    Printer.NewLine();\n    WithColor(Printer, PDB_ColorItem::SectionHeader).get()\n        << \"---SYMBOLS & TYPES BY NAME---\";\n\n    for (StringRef Name : opts::pretty::WithName) {\n      auto Symbols = GlobalScope->findChildren(\n          PDB_SymType::None, Name, PDB_NameSearchFlags::NS_CaseSensitive);\n      if (!Symbols || Symbols->getChildCount() == 0) {\n        Printer.formatLine(\"[not found] - {0}\", Name);\n        continue;\n      }\n      Printer.formatLine(\"[{0} occurrences] - {1}\", Symbols->getChildCount(),\n                         Name);\n\n      AutoIndent Indent(Printer);\n      Printer.NewLine();\n\n      while (auto Symbol = Symbols->getNext()) {\n        switch (Symbol->getSymTag()) {\n        case PDB_SymType::Typedef: {\n          TypedefDumper TD(Printer);\n          std::unique_ptr<PDBSymbolTypeTypedef> T =\n              llvm::unique_dyn_cast<PDBSymbolTypeTypedef>(std::move(Symbol));\n          TD.start(*T);\n          break;\n        }\n        case PDB_SymType::Enum: {\n          EnumDumper ED(Printer);\n          std::unique_ptr<PDBSymbolTypeEnum> E =\n              llvm::unique_dyn_cast<PDBSymbolTypeEnum>(std::move(Symbol));\n          ED.start(*E);\n          break;\n        }\n        case PDB_SymType::UDT: {\n          ClassDefinitionDumper CD(Printer);\n          std::unique_ptr<PDBSymbolTypeUDT> C =\n              llvm::unique_dyn_cast<PDBSymbolTypeUDT>(std::move(Symbol));\n          CD.start(*C);\n          break;\n        }\n        case PDB_SymType::BaseClass:\n        case PDB_SymType::Friend: {\n          TypeDumper TD(Printer);\n          Symbol->dump(TD);\n          break;\n        }\n        case PDB_SymType::Function: {\n          FunctionDumper FD(Printer);\n          std::unique_ptr<PDBSymbolFunc> F =\n              llvm::unique_dyn_cast<PDBSymbolFunc>(std::move(Symbol));\n          FD.start(*F, FunctionDumper::PointerType::None);\n          break;\n        }\n        case PDB_SymType::Data: {\n          VariableDumper VD(Printer);\n          std::unique_ptr<PDBSymbolData> D =\n              llvm::unique_dyn_cast<PDBSymbolData>(std::move(Symbol));\n          VD.start(*D);\n          break;\n        }\n        case PDB_SymType::PublicSymbol: {\n          ExternalSymbolDumper ED(Printer);\n          std::unique_ptr<PDBSymbolPublicSymbol> PS =\n              llvm::unique_dyn_cast<PDBSymbolPublicSymbol>(std::move(Symbol));\n          ED.dump(*PS);\n          break;\n        }\n        default:\n          llvm_unreachable(\"Unexpected symbol tag!\");\n        }\n      }\n    }\n    llvm::outs().flush();\n  }\n\n  if (opts::pretty::Compilands) {\n    Printer.NewLine();\n    WithColor(Printer, PDB_ColorItem::SectionHeader).get()\n        << \"---COMPILANDS---\";\n    auto Compilands = GlobalScope->findAllChildren<PDBSymbolCompiland>();\n\n    if (Compilands) {\n      Printer.Indent();\n      CompilandDumper Dumper(Printer);\n      CompilandDumpFlags options = CompilandDumper::Flags::None;\n      if (opts::pretty::Lines)\n        options = options | CompilandDumper::Flags::Lines;\n      while (auto Compiland = Compilands->getNext())\n        Dumper.start(*Compiland, options);\n      Printer.Unindent();\n    }\n  }\n\n  if (opts::pretty::Classes || opts::pretty::Enums || opts::pretty::Typedefs ||\n      opts::pretty::Funcsigs || opts::pretty::Pointers ||\n      opts::pretty::Arrays || opts::pretty::VTShapes) {\n    Printer.NewLine();\n    WithColor(Printer, PDB_ColorItem::SectionHeader).get() << \"---TYPES---\";\n    Printer.Indent();\n    TypeDumper Dumper(Printer);\n    Dumper.start(*GlobalScope);\n    Printer.Unindent();\n  }\n\n  if (opts::pretty::Symbols) {\n    Printer.NewLine();\n    WithColor(Printer, PDB_ColorItem::SectionHeader).get() << \"---SYMBOLS---\";\n    if (auto Compilands = GlobalScope->findAllChildren<PDBSymbolCompiland>()) {\n      Printer.Indent();\n      CompilandDumper Dumper(Printer);\n      while (auto Compiland = Compilands->getNext())\n        Dumper.start(*Compiland, true);\n      Printer.Unindent();\n    }\n  }\n\n  if (opts::pretty::Globals) {\n    Printer.NewLine();\n    WithColor(Printer, PDB_ColorItem::SectionHeader).get() << \"---GLOBALS---\";\n    Printer.Indent();\n    if (shouldDumpSymLevel(opts::pretty::SymLevel::Functions)) {\n      if (auto Functions = GlobalScope->findAllChildren<PDBSymbolFunc>()) {\n        FunctionDumper Dumper(Printer);\n        if (opts::pretty::SymbolOrder == opts::pretty::SymbolSortMode::None) {\n          while (auto Function = Functions->getNext()) {\n            Printer.NewLine();\n            Dumper.start(*Function, FunctionDumper::PointerType::None);\n          }\n        } else {\n          std::vector<std::unique_ptr<PDBSymbolFunc>> Funcs;\n          while (auto Func = Functions->getNext())\n            Funcs.push_back(std::move(Func));\n          llvm::sort(Funcs, opts::pretty::compareFunctionSymbols);\n          for (const auto &Func : Funcs) {\n            Printer.NewLine();\n            Dumper.start(*Func, FunctionDumper::PointerType::None);\n          }\n        }\n      }\n    }\n    if (shouldDumpSymLevel(opts::pretty::SymLevel::Data)) {\n      if (auto Vars = GlobalScope->findAllChildren<PDBSymbolData>()) {\n        VariableDumper Dumper(Printer);\n        if (opts::pretty::SymbolOrder == opts::pretty::SymbolSortMode::None) {\n          while (auto Var = Vars->getNext())\n            Dumper.start(*Var);\n        } else {\n          std::vector<std::unique_ptr<PDBSymbolData>> Datas;\n          while (auto Var = Vars->getNext())\n            Datas.push_back(std::move(Var));\n          llvm::sort(Datas, opts::pretty::compareDataSymbols);\n          for (const auto &Var : Datas)\n            Dumper.start(*Var);\n        }\n      }\n    }\n    if (shouldDumpSymLevel(opts::pretty::SymLevel::Thunks)) {\n      if (auto Thunks = GlobalScope->findAllChildren<PDBSymbolThunk>()) {\n        CompilandDumper Dumper(Printer);\n        while (auto Thunk = Thunks->getNext())\n          Dumper.dump(*Thunk);\n      }\n    }\n    Printer.Unindent();\n  }\n  if (opts::pretty::Externals) {\n    Printer.NewLine();\n    WithColor(Printer, PDB_ColorItem::SectionHeader).get() << \"---EXTERNALS---\";\n    Printer.Indent();\n    ExternalSymbolDumper Dumper(Printer);\n    Dumper.start(*GlobalScope);\n  }\n  if (opts::pretty::Lines) {\n    Printer.NewLine();\n  }\n  if (opts::pretty::InjectedSources) {\n    Printer.NewLine();\n    WithColor(Printer, PDB_ColorItem::SectionHeader).get()\n        << \"---INJECTED SOURCES---\";\n    AutoIndent Indent1(Printer);\n    dumpInjectedSources(Printer, *Session);\n  }\n\n  Printer.NewLine();\n  outs().flush();\n}\n\nstatic void mergePdbs() {\n  BumpPtrAllocator Allocator;\n  MergingTypeTableBuilder MergedTpi(Allocator);\n  MergingTypeTableBuilder MergedIpi(Allocator);\n\n  // Create a Tpi and Ipi type table with all types from all input files.\n  for (const auto &Path : opts::merge::InputFilenames) {\n    std::unique_ptr<IPDBSession> Session;\n    auto &File = loadPDB(Path, Session);\n    SmallVector<TypeIndex, 128> TypeMap;\n    SmallVector<TypeIndex, 128> IdMap;\n    if (File.hasPDBTpiStream()) {\n      auto &Tpi = ExitOnErr(File.getPDBTpiStream());\n      ExitOnErr(\n          codeview::mergeTypeRecords(MergedTpi, TypeMap, Tpi.typeArray()));\n    }\n    if (File.hasPDBIpiStream()) {\n      auto &Ipi = ExitOnErr(File.getPDBIpiStream());\n      ExitOnErr(codeview::mergeIdRecords(MergedIpi, TypeMap, IdMap,\n                                         Ipi.typeArray()));\n    }\n  }\n\n  // Then write the PDB.\n  PDBFileBuilder Builder(Allocator);\n  ExitOnErr(Builder.initialize(4096));\n  // Add each of the reserved streams.  We might not put any data in them,\n  // but at least they have to be present.\n  for (uint32_t I = 0; I < kSpecialStreamCount; ++I)\n    ExitOnErr(Builder.getMsfBuilder().addStream(0));\n\n  auto &DestTpi = Builder.getTpiBuilder();\n  auto &DestIpi = Builder.getIpiBuilder();\n  MergedTpi.ForEachRecord([&DestTpi](TypeIndex TI, const CVType &Type) {\n    DestTpi.addTypeRecord(Type.RecordData, None);\n  });\n  MergedIpi.ForEachRecord([&DestIpi](TypeIndex TI, const CVType &Type) {\n    DestIpi.addTypeRecord(Type.RecordData, None);\n  });\n  Builder.getInfoBuilder().addFeature(PdbRaw_FeatureSig::VC140);\n\n  SmallString<64> OutFile(opts::merge::PdbOutputFile);\n  if (OutFile.empty()) {\n    OutFile = opts::merge::InputFilenames[0];\n    llvm::sys::path::replace_extension(OutFile, \"merged.pdb\");\n  }\n\n  codeview::GUID IgnoredOutGuid;\n  ExitOnErr(Builder.commit(OutFile, &IgnoredOutGuid));\n}\n\nstatic void explain() {\n  std::unique_ptr<IPDBSession> Session;\n  InputFile IF =\n      ExitOnErr(InputFile::open(opts::explain::InputFilename.front(), true));\n\n  for (uint64_t Off : opts::explain::Offsets) {\n    auto O = std::make_unique<ExplainOutputStyle>(IF, Off);\n\n    ExitOnErr(O->dump());\n  }\n}\n\nstatic void exportStream() {\n  std::unique_ptr<IPDBSession> Session;\n  PDBFile &File = loadPDB(opts::exportstream::InputFilename.front(), Session);\n\n  std::unique_ptr<MappedBlockStream> SourceStream;\n  uint32_t Index = 0;\n  bool Success = false;\n  std::string OutFileName = opts::exportstream::OutputFile;\n\n  if (!opts::exportstream::ForceName) {\n    // First try to parse it as an integer, if it fails fall back to treating it\n    // as a named stream.\n    if (to_integer(opts::exportstream::Stream, Index)) {\n      if (Index >= File.getNumStreams()) {\n        errs() << \"Error: \" << Index << \" is not a valid stream index.\\n\";\n        exit(1);\n      }\n      Success = true;\n      outs() << \"Dumping contents of stream index \" << Index << \" to file \"\n             << OutFileName << \".\\n\";\n    }\n  }\n\n  if (!Success) {\n    InfoStream &IS = cantFail(File.getPDBInfoStream());\n    Index = ExitOnErr(IS.getNamedStreamIndex(opts::exportstream::Stream));\n    outs() << \"Dumping contents of stream '\" << opts::exportstream::Stream\n           << \"' (index \" << Index << \") to file \" << OutFileName << \".\\n\";\n  }\n\n  SourceStream = File.createIndexedStream(Index);\n  auto OutFile = ExitOnErr(\n      FileOutputBuffer::create(OutFileName, SourceStream->getLength()));\n  FileBufferByteStream DestStream(std::move(OutFile), llvm::support::little);\n  BinaryStreamWriter Writer(DestStream);\n  ExitOnErr(Writer.writeStreamRef(*SourceStream));\n  ExitOnErr(DestStream.commit());\n}\n\nstatic bool parseRange(StringRef Str,\n                       Optional<opts::bytes::NumberRange> &Parsed) {\n  if (Str.empty())\n    return true;\n\n  llvm::Regex R(\"^([^-]+)(-([^-]+))?$\");\n  llvm::SmallVector<llvm::StringRef, 2> Matches;\n  if (!R.match(Str, &Matches))\n    return false;\n\n  Parsed.emplace();\n  if (!to_integer(Matches[1], Parsed->Min))\n    return false;\n\n  if (!Matches[3].empty()) {\n    Parsed->Max.emplace();\n    if (!to_integer(Matches[3], *Parsed->Max))\n      return false;\n  }\n  return true;\n}\n\nstatic void simplifyChunkList(llvm::cl::list<opts::ModuleSubsection> &Chunks) {\n  // If this list contains \"All\" plus some other stuff, remove the other stuff\n  // and just keep \"All\" in the list.\n  if (!llvm::is_contained(Chunks, opts::ModuleSubsection::All))\n    return;\n  Chunks.reset();\n  Chunks.push_back(opts::ModuleSubsection::All);\n}\n\nint main(int Argc, const char **Argv) {\n  InitLLVM X(Argc, Argv);\n  ExitOnErr.setBanner(\"llvm-pdbutil: \");\n\n  cl::ParseCommandLineOptions(Argc, Argv, \"LLVM PDB Dumper\\n\");\n\n  if (opts::BytesSubcommand) {\n    if (!parseRange(opts::bytes::DumpBlockRangeOpt,\n                    opts::bytes::DumpBlockRange)) {\n      errs() << \"Argument '\" << opts::bytes::DumpBlockRangeOpt\n             << \"' invalid format.\\n\";\n      errs().flush();\n      exit(1);\n    }\n    if (!parseRange(opts::bytes::DumpByteRangeOpt,\n                    opts::bytes::DumpByteRange)) {\n      errs() << \"Argument '\" << opts::bytes::DumpByteRangeOpt\n             << \"' invalid format.\\n\";\n      errs().flush();\n      exit(1);\n    }\n  }\n\n  if (opts::DumpSubcommand) {\n    if (opts::dump::RawAll) {\n      opts::dump::DumpGlobals = true;\n      opts::dump::DumpFpo = true;\n      opts::dump::DumpInlineeLines = true;\n      opts::dump::DumpIds = true;\n      opts::dump::DumpIdExtras = true;\n      opts::dump::DumpLines = true;\n      opts::dump::DumpModules = true;\n      opts::dump::DumpModuleFiles = true;\n      opts::dump::DumpPublics = true;\n      opts::dump::DumpSectionContribs = true;\n      opts::dump::DumpSectionHeaders = true;\n      opts::dump::DumpSectionMap = true;\n      opts::dump::DumpStreams = true;\n      opts::dump::DumpStreamBlocks = true;\n      opts::dump::DumpStringTable = true;\n      opts::dump::DumpStringTableDetails = true;\n      opts::dump::DumpSummary = true;\n      opts::dump::DumpSymbols = true;\n      opts::dump::DumpSymbolStats = true;\n      opts::dump::DumpTypes = true;\n      opts::dump::DumpTypeExtras = true;\n      opts::dump::DumpUdtStats = true;\n      opts::dump::DumpXme = true;\n      opts::dump::DumpXmi = true;\n    }\n  }\n  if (opts::PdbToYamlSubcommand) {\n    if (opts::pdb2yaml::All) {\n      opts::pdb2yaml::StreamMetadata = true;\n      opts::pdb2yaml::StreamDirectory = true;\n      opts::pdb2yaml::PdbStream = true;\n      opts::pdb2yaml::StringTable = true;\n      opts::pdb2yaml::DbiStream = true;\n      opts::pdb2yaml::TpiStream = true;\n      opts::pdb2yaml::IpiStream = true;\n      opts::pdb2yaml::PublicsStream = true;\n      opts::pdb2yaml::DumpModules = true;\n      opts::pdb2yaml::DumpModuleFiles = true;\n      opts::pdb2yaml::DumpModuleSyms = true;\n      opts::pdb2yaml::DumpModuleSubsections.push_back(\n          opts::ModuleSubsection::All);\n    }\n    simplifyChunkList(opts::pdb2yaml::DumpModuleSubsections);\n\n    if (opts::pdb2yaml::DumpModuleSyms || opts::pdb2yaml::DumpModuleFiles)\n      opts::pdb2yaml::DumpModules = true;\n\n    if (opts::pdb2yaml::DumpModules)\n      opts::pdb2yaml::DbiStream = true;\n  }\n\n  llvm::sys::InitializeCOMRAII COM(llvm::sys::COMThreadingMode::MultiThreaded);\n\n  if (opts::PdbToYamlSubcommand) {\n    pdb2Yaml(opts::pdb2yaml::InputFilename.front());\n  } else if (opts::YamlToPdbSubcommand) {\n    if (opts::yaml2pdb::YamlPdbOutputFile.empty()) {\n      SmallString<16> OutputFilename(opts::yaml2pdb::InputFilename.getValue());\n      sys::path::replace_extension(OutputFilename, \".pdb\");\n      opts::yaml2pdb::YamlPdbOutputFile = std::string(OutputFilename.str());\n    }\n    yamlToPdb(opts::yaml2pdb::InputFilename);\n  } else if (opts::DiaDumpSubcommand) {\n    llvm::for_each(opts::diadump::InputFilenames, dumpDia);\n  } else if (opts::PrettySubcommand) {\n    if (opts::pretty::Lines)\n      opts::pretty::Compilands = true;\n\n    if (opts::pretty::All) {\n      opts::pretty::Compilands = true;\n      opts::pretty::Symbols = true;\n      opts::pretty::Globals = true;\n      opts::pretty::Types = true;\n      opts::pretty::Externals = true;\n      opts::pretty::Lines = true;\n    }\n\n    if (opts::pretty::Types) {\n      opts::pretty::Classes = true;\n      opts::pretty::Typedefs = true;\n      opts::pretty::Enums = true;\n      opts::pretty::Pointers = true;\n      opts::pretty::Funcsigs = true;\n    }\n\n    // When adding filters for excluded compilands and types, we need to\n    // remember that these are regexes.  So special characters such as * and \\\n    // need to be escaped in the regex.  In the case of a literal \\, this means\n    // it needs to be escaped again in the C++.  So matching a single \\ in the\n    // input requires 4 \\es in the C++.\n    if (opts::pretty::ExcludeCompilerGenerated) {\n      opts::pretty::ExcludeTypes.push_back(\"__vc_attributes\");\n      opts::pretty::ExcludeCompilands.push_back(\"\\\\* Linker \\\\*\");\n    }\n    if (opts::pretty::ExcludeSystemLibraries) {\n      opts::pretty::ExcludeCompilands.push_back(\n          \"f:\\\\\\\\binaries\\\\\\\\Intermediate\\\\\\\\vctools\\\\\\\\crt_bld\");\n      opts::pretty::ExcludeCompilands.push_back(\"f:\\\\\\\\dd\\\\\\\\vctools\\\\\\\\crt\");\n      opts::pretty::ExcludeCompilands.push_back(\n          \"d:\\\\\\\\th.obj.x86fre\\\\\\\\minkernel\");\n    }\n    llvm::for_each(opts::pretty::InputFilenames, dumpPretty);\n  } else if (opts::DumpSubcommand) {\n    llvm::for_each(opts::dump::InputFilenames, dumpRaw);\n  } else if (opts::BytesSubcommand) {\n    llvm::for_each(opts::bytes::InputFilenames, dumpBytes);\n  } else if (opts::MergeSubcommand) {\n    if (opts::merge::InputFilenames.size() < 2) {\n      errs() << \"merge subcommand requires at least 2 input files.\\n\";\n      exit(1);\n    }\n    mergePdbs();\n  } else if (opts::ExplainSubcommand) {\n    explain();\n  } else if (opts::ExportSubcommand) {\n    exportStream();\n  }\n\n  outs().flush();\n  return 0;\n}\n"}, "125": {"id": 125, "path": "/home/vsts/work/1/llvm-project/llvm/tools/llvm-pdbutil/llvm-pdbutil.h", "content": "//===- llvm-pdbutil.h ----------------------------------------- *- C++ --*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_TOOLS_LLVMPDBDUMP_LLVMPDBDUMP_H\n#define LLVM_TOOLS_LLVMPDBDUMP_LLVMPDBDUMP_H\n\n#include \"llvm/ADT/DenseMap.h\"\n#include \"llvm/ADT/Optional.h\"\n#include \"llvm/ADT/PointerUnion.h\"\n#include \"llvm/Support/CommandLine.h\"\n#include \"llvm/Support/raw_ostream.h\"\n\n#include <memory>\n#include <stdint.h>\n\nnamespace llvm {\nnamespace object {\nclass COFFObjectFile;\n}\nnamespace pdb {\nclass PDBSymbolData;\nclass PDBSymbolFunc;\nclass PDBFile;\nuint32_t getTypeLength(const PDBSymbolData &Symbol);\n}\ntypedef llvm::PointerUnion<object::COFFObjectFile *, pdb::PDBFile *>\n    PdbOrCoffObj;\n}\n\nnamespace opts {\n\nenum class DumpLevel { None, Basic, Verbose };\n\nenum class ModuleSubsection {\n  Unknown,\n  Lines,\n  FileChecksums,\n  InlineeLines,\n  CrossScopeImports,\n  CrossScopeExports,\n  StringTable,\n  Symbols,\n  FrameData,\n  CoffSymbolRVAs,\n  All\n};\n\nnamespace pretty {\n\nenum class ClassDefinitionFormat { None, Layout, All };\nenum class ClassSortMode {\n  None,\n  Name,\n  Size,\n  Padding,\n  PaddingPct,\n  PaddingImmediate,\n  PaddingPctImmediate\n};\n\nenum class SymbolSortMode { None, Name, Size };\n\nenum class SymLevel { Functions, Data, Thunks, All };\n\nbool shouldDumpSymLevel(SymLevel Level);\nbool compareFunctionSymbols(\n    const std::unique_ptr<llvm::pdb::PDBSymbolFunc> &F1,\n    const std::unique_ptr<llvm::pdb::PDBSymbolFunc> &F2);\nbool compareDataSymbols(const std::unique_ptr<llvm::pdb::PDBSymbolData> &F1,\n                        const std::unique_ptr<llvm::pdb::PDBSymbolData> &F2);\n\nextern llvm::cl::list<std::string> WithName;\n\nextern llvm::cl::opt<bool> Compilands;\nextern llvm::cl::opt<bool> Symbols;\nextern llvm::cl::opt<bool> Globals;\nextern llvm::cl::opt<bool> Classes;\nextern llvm::cl::opt<bool> Enums;\nextern llvm::cl::opt<bool> Funcsigs;\nextern llvm::cl::opt<bool> Arrays;\nextern llvm::cl::opt<bool> Typedefs;\nextern llvm::cl::opt<bool> Pointers;\nextern llvm::cl::opt<bool> VTShapes;\nextern llvm::cl::opt<bool> All;\nextern llvm::cl::opt<bool> ExcludeCompilerGenerated;\n\nextern llvm::cl::opt<bool> NoEnumDefs;\nextern llvm::cl::list<std::string> ExcludeTypes;\nextern llvm::cl::list<std::string> ExcludeSymbols;\nextern llvm::cl::list<std::string> ExcludeCompilands;\nextern llvm::cl::list<std::string> IncludeTypes;\nextern llvm::cl::list<std::string> IncludeSymbols;\nextern llvm::cl::list<std::string> IncludeCompilands;\nextern llvm::cl::opt<SymbolSortMode> SymbolOrder;\nextern llvm::cl::opt<ClassSortMode> ClassOrder;\nextern llvm::cl::opt<uint32_t> SizeThreshold;\nextern llvm::cl::opt<uint32_t> PaddingThreshold;\nextern llvm::cl::opt<uint32_t> ImmediatePaddingThreshold;\nextern llvm::cl::opt<ClassDefinitionFormat> ClassFormat;\nextern llvm::cl::opt<uint32_t> ClassRecursionDepth;\n}\n\nnamespace bytes {\nstruct NumberRange {\n  uint64_t Min;\n  llvm::Optional<uint64_t> Max;\n};\n\nextern llvm::Optional<NumberRange> DumpBlockRange;\nextern llvm::Optional<NumberRange> DumpByteRange;\nextern llvm::cl::list<std::string> DumpStreamData;\nextern llvm::cl::opt<bool> NameMap;\nextern llvm::cl::opt<bool> Fpm;\n\nextern llvm::cl::opt<bool> SectionContributions;\nextern llvm::cl::opt<bool> SectionMap;\nextern llvm::cl::opt<bool> ModuleInfos;\nextern llvm::cl::opt<bool> FileInfo;\nextern llvm::cl::opt<bool> TypeServerMap;\nextern llvm::cl::opt<bool> ECData;\n\nextern llvm::cl::list<uint32_t> TypeIndex;\nextern llvm::cl::list<uint32_t> IdIndex;\n\nextern llvm::cl::opt<uint32_t> ModuleIndex;\nextern llvm::cl::opt<bool> ModuleSyms;\nextern llvm::cl::opt<bool> ModuleC11;\nextern llvm::cl::opt<bool> ModuleC13;\nextern llvm::cl::opt<bool> SplitChunks;\n} // namespace bytes\n\nnamespace dump {\n\nextern llvm::cl::opt<bool> DumpSummary;\nextern llvm::cl::opt<bool> DumpFpm;\nextern llvm::cl::opt<bool> DumpStreams;\nextern llvm::cl::opt<bool> DumpSymbolStats;\nextern llvm::cl::opt<bool> DumpTypeStats;\nextern llvm::cl::opt<bool> DumpIDStats;\nextern llvm::cl::opt<bool> DumpUdtStats;\nextern llvm::cl::opt<bool> DumpStreamBlocks;\n\nextern llvm::cl::opt<bool> DumpLines;\nextern llvm::cl::opt<bool> DumpInlineeLines;\nextern llvm::cl::opt<bool> DumpXmi;\nextern llvm::cl::opt<bool> DumpXme;\nextern llvm::cl::opt<bool> DumpNamedStreams;\nextern llvm::cl::opt<bool> DumpStringTable;\nextern llvm::cl::opt<bool> DumpStringTableDetails;\nextern llvm::cl::opt<bool> DumpTypes;\nextern llvm::cl::opt<bool> DumpTypeData;\nextern llvm::cl::opt<bool> DumpTypeExtras;\nextern llvm::cl::list<uint32_t> DumpTypeIndex;\nextern llvm::cl::opt<bool> DumpTypeDependents;\nextern llvm::cl::opt<bool> DumpTypeRefStats;\nextern llvm::cl::opt<bool> DumpSectionHeaders;\n\nextern llvm::cl::opt<bool> DumpIds;\nextern llvm::cl::opt<bool> DumpIdData;\nextern llvm::cl::opt<bool> DumpIdExtras;\nextern llvm::cl::list<uint32_t> DumpIdIndex;\nextern llvm::cl::opt<uint32_t> DumpModi;\nextern llvm::cl::opt<bool> JustMyCode;\nextern llvm::cl::opt<bool> DontResolveForwardRefs;\nextern llvm::cl::opt<bool> DumpSymbols;\nextern llvm::cl::opt<bool> DumpSymRecordBytes;\nextern llvm::cl::opt<bool> DumpGSIRecords;\nextern llvm::cl::opt<bool> DumpGlobals;\nextern llvm::cl::list<std::string> DumpGlobalNames;\nextern llvm::cl::opt<bool> DumpGlobalExtras;\nextern llvm::cl::opt<bool> DumpPublics;\nextern llvm::cl::opt<bool> DumpPublicExtras;\nextern llvm::cl::opt<bool> DumpSectionContribs;\nextern llvm::cl::opt<bool> DumpSectionMap;\nextern llvm::cl::opt<bool> DumpModules;\nextern llvm::cl::opt<bool> DumpModuleFiles;\nextern llvm::cl::opt<bool> DumpFpo;\nextern llvm::cl::opt<bool> RawAll;\n}\n\nnamespace pdb2yaml {\nextern llvm::cl::opt<bool> All;\nextern llvm::cl::opt<bool> NoFileHeaders;\nextern llvm::cl::opt<bool> Minimal;\nextern llvm::cl::opt<bool> StreamMetadata;\nextern llvm::cl::opt<bool> StreamDirectory;\nextern llvm::cl::opt<bool> StringTable;\nextern llvm::cl::opt<bool> PdbStream;\nextern llvm::cl::opt<bool> DbiStream;\nextern llvm::cl::opt<bool> TpiStream;\nextern llvm::cl::opt<bool> IpiStream;\nextern llvm::cl::opt<bool> PublicsStream;\nextern llvm::cl::list<std::string> InputFilename;\nextern llvm::cl::opt<bool> DumpModules;\nextern llvm::cl::opt<bool> DumpModuleFiles;\nextern llvm::cl::list<ModuleSubsection> DumpModuleSubsections;\nextern llvm::cl::opt<bool> DumpModuleSyms;\n} // namespace pdb2yaml\n\nnamespace explain {\nenum class InputFileType { PDBFile, PDBStream, DBIStream, Names, ModuleStream };\n\nextern llvm::cl::list<std::string> InputFilename;\nextern llvm::cl::list<uint64_t> Offsets;\nextern llvm::cl::opt<InputFileType> InputType;\n} // namespace explain\n\nnamespace exportstream {\nextern llvm::cl::opt<std::string> OutputFile;\nextern llvm::cl::opt<std::string> Stream;\nextern llvm::cl::opt<bool> ForceName;\n} // namespace exportstream\n}\n\n#endif\n"}}, "reports": [{"events": [{"location": {"col": 7, "file": 18, "line": 255}, "message": "destructor '~SparseBitVector' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/SparseBitVector.h", "reportHash": "be9ab5391b2c8ab802a80f5120a57139", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 31, "line": 41}, "message": "move assignment operator 'operator=' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/DebugInfo/CodeView/DebugFrameDataSubsection.h", "reportHash": "bdd3382e77e8dff0687fe67de0fc6e40", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 31, "line": 41}, "message": "move constructor 'DebugFrameDataSubsection' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/DebugInfo/CodeView/DebugFrameDataSubsection.h", "reportHash": "d29845b5c8d5063d1e0fac623e719d4e", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 35, "line": 21}, "message": "move assignment operator 'operator=' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/DebugInfo/CodeView/GUID.h", "reportHash": "f42f873c87a79567f3d6ea3720b7ded6", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 38, "line": 81}, "message": "destructor '~StringsAndChecksums' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/DebugInfo/CodeView/StringsAndChecksums.h", "reportHash": "baead28beed9f582b23a8285be2ebe03", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 46, "line": 31}, "message": "destructor '~SuperBlock' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/DebugInfo/MSF/MSFCommon.h", "reportHash": "85c784ffd644f982296be5cacb8357aa", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 46, "line": 31}, "message": "move assignment operator 'operator=' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/DebugInfo/MSF/MSFCommon.h", "reportHash": "cf9e512bb61a261ab64b75a42422e3bf", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 46, "line": 31}, "message": "move constructor 'SuperBlock' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/DebugInfo/MSF/MSFCommon.h", "reportHash": "5d21225c1eac960a976d1bbcc9ee199e", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 49, "line": 60}, "message": "destructor '~StringTableFixup' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/DebugInfo/PDB/Native/DbiModuleDescriptorBuilder.h", "reportHash": "95f2ae0b04a52292ed6e3d361dc05ebf", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 10, "file": 50, "line": 90}, "message": "destructor '~DebugStream' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/DebugInfo/PDB/Native/DbiStreamBuilder.h", "reportHash": "176ba4179fc4b8bd2c1764035793f1db", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 10, "file": 50, "line": 90}, "message": "move assignment operator 'operator=' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/DebugInfo/PDB/Native/DbiStreamBuilder.h", "reportHash": "5aae17e5d8d4ef83c81a98ce631a2769", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 10, "file": 50, "line": 90}, "message": "move constructor 'DebugStream' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/DebugInfo/PDB/Native/DbiStreamBuilder.h", "reportHash": "b84f22e20bb429b64561d5c720159e86", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 51, "line": 103}, "message": "destructor '~HashTable' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/DebugInfo/PDB/Native/HashTable.h", "reportHash": "289bfe805aeb3f2db1e0ea389e5a0363", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 52, "line": 29}, "message": "destructor '~NamedStreamMapTraits' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/DebugInfo/PDB/Native/NamedStreamMap.h", "reportHash": "87c3f0c5bec8adbf45b39f5af3e6f08d", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 52, "line": 38}, "message": "destructor '~NamedStreamMap' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/DebugInfo/PDB/Native/NamedStreamMap.h", "reportHash": "3e4929d3786cace4e6ff19380f3deefd", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 10, "file": 54, "line": 62}, "message": "destructor '~InjectedSourceDescriptor' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/DebugInfo/PDB/Native/PDBFileBuilder.h", "reportHash": "e932cf197a4ac9a93a95fd9c107a082c", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 55, "line": 34}, "message": "destructor '~StringTableHashTraits' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/DebugInfo/PDB/Native/PDBStringTableBuilder.h", "reportHash": "62abec467156982aec84f3da9a8ba850", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 55, "line": 43}, "message": "destructor '~PDBStringTableBuilder' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/DebugInfo/PDB/Native/PDBStringTableBuilder.h", "reportHash": "fc0d7ff07efbdbecc09faba68333a675", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 57, "line": 46}, "message": "destructor '~SectionContrib' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/DebugInfo/PDB/Native/RawTypes.h", "reportHash": "e281f19692ffc3af7f4a5517fa6a2ffa", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 57, "line": 46}, "message": "move assignment operator 'operator=' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/DebugInfo/PDB/Native/RawTypes.h", "reportHash": "2cb321690329273cc349373a457bb4e2", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 57, "line": 46}, "message": "move constructor 'SectionContrib' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/DebugInfo/PDB/Native/RawTypes.h", "reportHash": "4a7b86a4d67e66ee0e377f49487cf949", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 63, "line": 20}, "message": "destructor '~PDBSymbolPublicSymbol' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/DebugInfo/PDB/PDBSymbolPublicSymbol.h", "reportHash": "cf2f9d5f7e96588c146674d058705593", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 64, "line": 20}, "message": "destructor '~PDBSymbolThunk' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/DebugInfo/PDB/PDBSymbolThunk.h", "reportHash": "80b3dd8c77ab1ca7d2d488775b7e40c1", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 66, "line": 22}, "message": "destructor '~PDBSymbolTypeEnum' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/DebugInfo/PDB/PDBSymbolTypeEnum.h", "reportHash": "026f3dc784e40b2c410b10541e9ad722", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 68, "line": 20}, "message": "destructor '~PDBSymbolTypeTypedef' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/DebugInfo/PDB/PDBSymbolTypeTypedef.h", "reportHash": "59cfc48c0e65ecd71235b08bd7fd5ae5", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 86, "line": 471}, "message": "destructor '~sub' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/CommandLine.h", "reportHash": "2f33d1bdef816de254f1d67bbe564b5d", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 109, "line": 28}, "message": "destructor '~BytesOutputStyle' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/tools/llvm-pdbutil/BytesOutputStyle.h", "reportHash": "35d10820722013f5967398d4fa1ee5c8", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 10, "file": 110, "line": 40}, "message": "destructor '~Stat' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/tools/llvm-pdbutil/DumpOutputStyle.h", "reportHash": "3953fbe94f6533f1d656cc3950559fa4", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 10, "file": 110, "line": 40}, "message": "move assignment operator 'operator=' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/tools/llvm-pdbutil/DumpOutputStyle.h", "reportHash": "065c45262f1eee38b2f721e2ab1e557f", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 10, "file": 110, "line": 40}, "message": "move constructor 'Stat' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/tools/llvm-pdbutil/DumpOutputStyle.h", "reportHash": "84eadee8bd586fdb577e8fd7e5a4fac2", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 111, "line": 25}, "message": "destructor '~ExplainOutputStyle' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/tools/llvm-pdbutil/ExplainOutputStyle.h", "reportHash": "15e1615d9b1c746d1651f42fa1c89d76", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 112, "line": 32}, "message": "destructor '~LinePrinter' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/tools/llvm-pdbutil/LinePrinter.h", "reportHash": "ea2565cddac84ed095ffecbe93663689", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 113, "line": 38}, "message": "destructor '~MSFHeaders' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/tools/llvm-pdbutil/PdbYaml.h", "reportHash": "e9aacdf99ca4276b1f1b87a762a563b1", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 113, "line": 38}, "message": "move assignment operator 'operator=' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/tools/llvm-pdbutil/PdbYaml.h", "reportHash": "e661e4b7a204c43af7e79f6f85f0fd23", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 113, "line": 38}, "message": "move constructor 'MSFHeaders' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/tools/llvm-pdbutil/PdbYaml.h", "reportHash": "c9cc3beeb267eb9dc02ec4c9851b9800", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 113, "line": 46}, "message": "destructor '~StreamBlockList' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/tools/llvm-pdbutil/PdbYaml.h", "reportHash": "91a641bfd1b59858f4c9ff8c0627f929", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 113, "line": 50}, "message": "destructor '~NamedStreamMapping' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/tools/llvm-pdbutil/PdbYaml.h", "reportHash": "d513e0f866892f03f9827c6a44bd46b0", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 113, "line": 55}, "message": "default constructor 'PdbInfoStream' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/tools/llvm-pdbutil/PdbYaml.h", "reportHash": "de6b197867609a34fd3d95f27aa5f222", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 113, "line": 55}, "message": "destructor '~PdbInfoStream' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/tools/llvm-pdbutil/PdbYaml.h", "reportHash": "dc8f74fffc921ccad2f3b85fdc8d0a03", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 113, "line": 55}, "message": "move assignment operator 'operator=' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/tools/llvm-pdbutil/PdbYaml.h", "reportHash": "f936fe4a42f2fcd36b98205884df437a", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 113, "line": 55}, "message": "move constructor 'PdbInfoStream' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/tools/llvm-pdbutil/PdbYaml.h", "reportHash": "46c2f36530ab3888d0df48a53491d820", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 113, "line": 64}, "message": "destructor '~PdbModiStream' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/tools/llvm-pdbutil/PdbYaml.h", "reportHash": "86c573f9d5a0eff5e1bccb4e647a8594", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 113, "line": 64}, "message": "move assignment operator 'operator=' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/tools/llvm-pdbutil/PdbYaml.h", "reportHash": "3fb197921cce5a7c65448bd23bdf4bb3", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 113, "line": 64}, "message": "move constructor 'PdbModiStream' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/tools/llvm-pdbutil/PdbYaml.h", "reportHash": "91e7113412a74f562df6e790db6506a1", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 113, "line": 69}, "message": "destructor '~PdbDbiModuleInfo' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/tools/llvm-pdbutil/PdbYaml.h", "reportHash": "3d5b61f371a9f68760a1f5f4f7f983ea", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 113, "line": 77}, "message": "default constructor 'PdbDbiStream' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/tools/llvm-pdbutil/PdbYaml.h", "reportHash": "7cbac339f8c45a41bb6ecf651f41fb78", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 113, "line": 77}, "message": "destructor '~PdbDbiStream' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/tools/llvm-pdbutil/PdbYaml.h", "reportHash": "3c98add6b0bfc5f9d8a5cbf260846118", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 113, "line": 77}, "message": "move assignment operator 'operator=' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/tools/llvm-pdbutil/PdbYaml.h", "reportHash": "3de700aacdfd12f86d07e780ba3e2ebb", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 113, "line": 77}, "message": "move constructor 'PdbDbiStream' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/tools/llvm-pdbutil/PdbYaml.h", "reportHash": "2a1fdd818c2d897b35e7942f80021237", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 113, "line": 89}, "message": "default constructor 'PdbTpiStream' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/tools/llvm-pdbutil/PdbYaml.h", "reportHash": "711ec37a54d43b69636840f479e60acd", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 113, "line": 89}, "message": "destructor '~PdbTpiStream' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/tools/llvm-pdbutil/PdbYaml.h", "reportHash": "f743651688362ab71d4c963a29717204", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 113, "line": 89}, "message": "move assignment operator 'operator=' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/tools/llvm-pdbutil/PdbYaml.h", "reportHash": "792327f79c421c0e71e34deccde4d191", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 113, "line": 89}, "message": "move constructor 'PdbTpiStream' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/tools/llvm-pdbutil/PdbYaml.h", "reportHash": "c8f4ae3bafa8e323b55e6db8c33343d1", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 113, "line": 94}, "message": "destructor '~PdbPublicsStream' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/tools/llvm-pdbutil/PdbYaml.h", "reportHash": "7890ed3f43f1176cac301bbcb51b200c", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 113, "line": 94}, "message": "move assignment operator 'operator=' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/tools/llvm-pdbutil/PdbYaml.h", "reportHash": "982d6cd5e2188a3cd8ce9c16f0e3c9dd", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 113, "line": 94}, "message": "move constructor 'PdbPublicsStream' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/tools/llvm-pdbutil/PdbYaml.h", "reportHash": "0320e3ce182bf09dc4081321b7f431e8", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 113, "line": 98}, "message": "destructor '~PdbObject' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/tools/llvm-pdbutil/PdbYaml.h", "reportHash": "e0a23500a784bf03f30c107d0b4f2923", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 114, "line": 30}, "message": "destructor '~ClassDefinitionDumper' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/tools/llvm-pdbutil/PrettyClassDefinitionDumper.h", "reportHash": "281d5eb5cbf8d40cb7eb7dd3d420e72d", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 116, "line": 19}, "message": "destructor '~EnumDumper' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/tools/llvm-pdbutil/PrettyEnumDumper.h", "reportHash": "50c1227436b671dee70408a6e56e8232", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 117, "line": 19}, "message": "destructor '~ExternalSymbolDumper' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/tools/llvm-pdbutil/PrettyExternalSymbolDumper.h", "reportHash": "53d3ca99b3a7ca91e27f9a0dffc76259", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 121, "line": 22}, "message": "destructor '~VariableDumper' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/tools/llvm-pdbutil/PrettyVariableDumper.h", "reportHash": "44555a8935346ec0de7e1c682094b31d", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 122, "line": 36}, "message": "destructor '~StreamInfo' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/tools/llvm-pdbutil/StreamUtil.h", "reportHash": "5b0d74f1fc5937caccd2fa7ae641e54e", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 123, "line": 22}, "message": "destructor '~YAMLOutputStyle' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/tools/llvm-pdbutil/YAMLOutputStyle.h", "reportHash": "7e95b29b57967e67273426707a076185", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 27, "file": 124, "line": 1330}, "message": "destructor '~' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/tools/llvm-pdbutil/llvm-pdbutil.cpp", "reportHash": "79acafedf101a18aeeda5d0b2a6a12cb", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 27, "file": 124, "line": 1330}, "message": "move constructor '' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/tools/llvm-pdbutil/llvm-pdbutil.cpp", "reportHash": "92412a2fb9b5828f932a83f5d7e2b4a8", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 27, "file": 124, "line": 1333}, "message": "destructor '~' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/tools/llvm-pdbutil/llvm-pdbutil.cpp", "reportHash": "52df6a885aac95275e213e8f97987747", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 27, "file": 124, "line": 1333}, "message": "move constructor '' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/tools/llvm-pdbutil/llvm-pdbutil.cpp", "reportHash": "9a6459bd611fde0167e7cf093dfa4745", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 125, "line": 109}, "message": "destructor '~NumberRange' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/tools/llvm-pdbutil/llvm-pdbutil.h", "reportHash": "f07cfeb04bf2f65b7a01f9b00088798a", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 125, "line": 109}, "message": "move assignment operator 'operator=' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/tools/llvm-pdbutil/llvm-pdbutil.h", "reportHash": "53a83b934856f7fcc5df852743fdc3b8", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 125, "line": 109}, "message": "move constructor 'NumberRange' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/tools/llvm-pdbutil/llvm-pdbutil.h", "reportHash": "09811bab4c22a90646b8bd85f105eb2d", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}]};
      window.onload = function() {
        if (!browserCompatible) {
          setNonCompatibleBrowserMessage();
        } else {
          BugViewer.init(data.files, data.reports);
          BugViewer.create();
          BugViewer.initByUrl();
        }
      };
    </script>
  </head>
  <body>
  <div class="container">
    <div id="content">
      <div id="side-bar">
        <div class="header">
          <a href="index.html" class="button">&#8249; Return to List</a>
        </div>
        <div id="report-nav">
          <div class="header">Reports</div>
        </div>
      </div>
      <div id="editor-wrapper">
        <div class="header">
          <div id="file">
            <span class="label">File:</span>
            <span id="file-path"></span>
          </div>
          <div id="checker">
            <span class="label">Checker name:</span>
            <span id="checker-name"></span>
          </div>
          <div id="review-status-wrapper">
            <span class="label">Review status:</span>
            <span id="review-status"></span>
          </div>
        </div>
        <div id="editor"></div>
      </div>
    </div>
  </div>
  </body>
</html>
