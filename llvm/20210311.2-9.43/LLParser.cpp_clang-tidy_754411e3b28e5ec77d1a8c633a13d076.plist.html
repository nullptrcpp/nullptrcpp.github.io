<!DOCTYPE html>
<html>
  <head>
    <title>Plist HTML Viewer</title>

    <meta charset="UTF-8">

    <style type="text/css">
      .CodeMirror{font-family:monospace;height:300px;color:#000;direction:ltr}.CodeMirror-lines{padding:4px 0}.CodeMirror pre{padding:0 4px}.CodeMirror-gutter-filler,.CodeMirror-scrollbar-filler{background-color:#fff}.CodeMirror-gutters{border-right:1px solid #ddd;background-color:#f7f7f7;white-space:nowrap}.CodeMirror-linenumber{padding:0 3px 0 5px;min-width:20px;text-align:right;color:#999;white-space:nowrap}.CodeMirror-guttermarker{color:#000}.CodeMirror-guttermarker-subtle{color:#999}.CodeMirror-cursor{border-left:1px solid #000;border-right:none;width:0}.CodeMirror div.CodeMirror-secondarycursor{border-left:1px solid silver}.cm-fat-cursor .CodeMirror-cursor{width:auto;border:0!important;background:#7e7}.cm-fat-cursor div.CodeMirror-cursors{z-index:1}.cm-animate-fat-cursor{width:auto;border:0;-webkit-animation:blink 1.06s steps(1) infinite;-moz-animation:blink 1.06s steps(1) infinite;animation:blink 1.06s steps(1) infinite;background-color:#7e7}@-moz-keyframes blink{50%{background-color:transparent}}@-webkit-keyframes blink{50%{background-color:transparent}}@keyframes blink{50%{background-color:transparent}}.cm-tab{display:inline-block;text-decoration:inherit}.CodeMirror-rulers{position:absolute;left:0;right:0;top:-50px;bottom:-20px;overflow:hidden}.CodeMirror-ruler{border-left:1px solid #ccc;top:0;bottom:0;position:absolute}.cm-s-default .cm-header{color:#00f}.cm-s-default .cm-quote{color:#090}.cm-negative{color:#d44}.cm-positive{color:#292}.cm-header,.cm-strong{font-weight:700}.cm-em{font-style:italic}.cm-link{text-decoration:underline}.cm-strikethrough{text-decoration:line-through}.cm-s-default .cm-keyword{color:#708}.cm-s-default .cm-atom{color:#219}.cm-s-default .cm-number{color:#164}.cm-s-default .cm-def{color:#00f}.cm-s-default .cm-variable-2{color:#05a}.cm-s-default .cm-type,.cm-s-default .cm-variable-3{color:#085}.cm-s-default .cm-comment{color:#a50}.cm-s-default .cm-string{color:#a11}.cm-s-default .cm-string-2{color:#f50}.cm-s-default .cm-meta{color:#555}.cm-s-default .cm-qualifier{color:#555}.cm-s-default .cm-builtin{color:#30a}.cm-s-default .cm-bracket{color:#997}.cm-s-default .cm-tag{color:#170}.cm-s-default .cm-attribute{color:#00c}.cm-s-default .cm-hr{color:#999}.cm-s-default .cm-link{color:#00c}.cm-s-default .cm-error{color:red}.cm-invalidchar{color:red}.CodeMirror-composing{border-bottom:2px solid}div.CodeMirror span.CodeMirror-matchingbracket{color:#0f0}div.CodeMirror span.CodeMirror-nonmatchingbracket{color:#f22}.CodeMirror-matchingtag{background:rgba(255,150,0,.3)}.CodeMirror-activeline-background{background:#e8f2ff}.CodeMirror{position:relative;overflow:hidden;background:#fff}.CodeMirror-scroll{overflow:scroll!important;margin-bottom:-30px;margin-right:-30px;padding-bottom:30px;height:100%;outline:0;position:relative}.CodeMirror-sizer{position:relative;border-right:30px solid transparent}.CodeMirror-gutter-filler,.CodeMirror-hscrollbar,.CodeMirror-scrollbar-filler,.CodeMirror-vscrollbar{position:absolute;z-index:6;display:none}.CodeMirror-vscrollbar{right:0;top:0;overflow-x:hidden;overflow-y:scroll}.CodeMirror-hscrollbar{bottom:0;left:0;overflow-y:hidden;overflow-x:scroll}.CodeMirror-scrollbar-filler{right:0;bottom:0}.CodeMirror-gutter-filler{left:0;bottom:0}.CodeMirror-gutters{position:absolute;left:0;top:0;min-height:100%;z-index:3}.CodeMirror-gutter{white-space:normal;height:100%;display:inline-block;vertical-align:top;margin-bottom:-30px}.CodeMirror-gutter-wrapper{position:absolute;z-index:4;background:0 0!important;border:none!important}.CodeMirror-gutter-background{position:absolute;top:0;bottom:0;z-index:4}.CodeMirror-gutter-elt{position:absolute;cursor:default;z-index:4}.CodeMirror-gutter-wrapper ::selection{background-color:transparent}.CodeMirror-gutter-wrapper ::-moz-selection{background-color:transparent}.CodeMirror-lines{cursor:text;min-height:1px}.CodeMirror pre{-moz-border-radius:0;-webkit-border-radius:0;border-radius:0;border-width:0;background:0 0;font-family:inherit;font-size:inherit;margin:0;white-space:pre;word-wrap:normal;line-height:inherit;color:inherit;z-index:2;position:relative;overflow:visible;-webkit-tap-highlight-color:transparent;-webkit-font-variant-ligatures:contextual;font-variant-ligatures:contextual}.CodeMirror-wrap pre{word-wrap:break-word;white-space:pre-wrap;word-break:normal}.CodeMirror-linebackground{position:absolute;left:0;right:0;top:0;bottom:0;z-index:0}.CodeMirror-linewidget{position:relative;z-index:2;overflow:auto}.CodeMirror-rtl pre{direction:rtl}.CodeMirror-code{outline:0}.CodeMirror-gutter,.CodeMirror-gutters,.CodeMirror-linenumber,.CodeMirror-scroll,.CodeMirror-sizer{-moz-box-sizing:content-box;box-sizing:content-box}.CodeMirror-measure{position:absolute;width:100%;height:0;overflow:hidden;visibility:hidden}.CodeMirror-cursor{position:absolute;pointer-events:none}.CodeMirror-measure pre{position:static}div.CodeMirror-cursors{visibility:hidden;position:relative;z-index:3}div.CodeMirror-dragcursors{visibility:visible}.CodeMirror-focused div.CodeMirror-cursors{visibility:visible}.CodeMirror-selected{background:#d9d9d9}.CodeMirror-focused .CodeMirror-selected{background:#d7d4f0}.CodeMirror-crosshair{cursor:crosshair}.CodeMirror-line::selection,.CodeMirror-line>span::selection,.CodeMirror-line>span>span::selection{background:#d7d4f0}.CodeMirror-line::-moz-selection,.CodeMirror-line>span::-moz-selection,.CodeMirror-line>span>span::-moz-selection{background:#d7d4f0}.cm-searching{background-color:#ffa;background-color:rgba(255,255,0,.4)}.cm-force-border{padding-right:.1px}@media print{.CodeMirror div.CodeMirror-cursors{visibility:hidden}}.cm-tab-wrap-hack:after{content:''}span.CodeMirror-selectedtext{background:0 0}
/*# sourceMappingURL=codemirror.min.css.map */

      .severity-low {
  background-color: #669603;
}

.severity-low:after {
  content : 'L';
}

.severity-unspecified {
  background-color: #666666;
}

.severity-unspecified:after {
  content : 'U';
}

.severity-style {
  background-color: #9932cc;
}

.severity-style:after {
  content : 'S';
}

.severity-medium {
  background-color: #a9d323;
  color: black;
}

.severity-medium:after {
  content : 'M';
}

.severity-high {
  background-color: #ffa800;
}

.severity-high:after {
  content : 'H';
}

.severity-critical {
  background-color: #e92625;
}

.severity-critical:after {
  content : 'C';
}

i[class*="severity-"] {
  line-height: normal;
  text-transform: capitalize;
  font-size: 0.8em;
  font-weight: bold;
  color: white;
  display: inline-block;
  width: 16px;
  height: 16px;
  text-align: center;
  font-family: sans-serif;
}

      html, body {
  width: 100%;
  height: 100%;
  padding: 0px;
  margin: 0px;
}

div.container {
  padding: 10px;
}

#content {
  height: 100%;
  display: block;
  overflow: hidden;
}

#content > div {
  margin: 10px;
  overflow: hidden;
  border: 1px solid #ddd;
  border-radius: 3px;
  overflow: hidden;
  height: 97%;
}

.button {
  background-color: #f1f1f1;
  text-decoration: none;
  display: inline-block;
  padding: 8px 16px;
  color: black;
  cursor: pointer;
}

.button:hover {
  background-color: #ddd;
  color: black;
}

.review-status {
  color: white;
  text-align: center;
}

.review-status-confirmed {
  background-color: #e92625;
}

.review-status-false-positive {
  background-color: grey;
}

.review-status-intentional {
  background-color: #669603;
}

      div.container {
  width: 100%;
  height: 100%;
  padding: 0px;
}

#editor-wrapper {
  margin: 10px;
}

#side-bar {
  float: left;
  width: 260px;
  margin: 0px;
}

#report-nav ul {
  list-style-type: none;
  padding: 0;
  margin: 0;
  overflow-y: auto;
  height: 100%;
}

#report-nav ul > li {
  padding: .4em;
  background-color: #fff;
  border-bottom: 1px solid rgba(0,0,0,.125);
  text-align: left;
  overflow: hidden;
  white-space: nowrap;
  text-overflow: ellipsis;
}

#report-nav ul > li.active {
  background-color: #427ea9;
  color: white;
}

#report-nav ul > li:hover {
  background-color: #427ea9;
  color: white;
  cursor: pointer;
}

#report-nav ul a {
  text-decoration: none;
}

#report-nav i[class*="severity-"] {
  margin-right: 5px;
}

.header {
  border-bottom: 1px solid lightgrey;
  font-family: monospace;
  padding: 10px;
  background-color: #fafbfc;
  border-bottom: 1px solid #e1e4e8;
  border-top-left-radius: 2px;
  border-top-right-radius: 2px;
}

#report-nav .header {
  font-weight: bold;
}

#editor-wrapper .header > div {
  padding-top: 2px;
}

#file-path,
#checker-name {
  color: #195ea2;
}

#review-status {
  padding: 0px 5px;
}

#file-path {
  font-family: monospace;
}

.check-msg {
  display: inline-block;
  padding: 3px 6px;
  margin: 1px;
  -webkit-border-radius: 5px;
  -moz-border-radius: 5px;
  border-radius: 5px;
}

.check-msg.info {
  color: #00546f;
  background-color: #bfdfe9;
  border: 1px solid #87a8b3;
}

.check-msg.error {
  background-color: #f2dede;
  color: #a94442;
  border: 1px solid #ebcccc;
}

.check-msg.macro {
  background-color: #d7dac2;
  color: #4f5c6d;
  border: 1px solid #d7dac2;
}

.check-msg.note {
  background-color: #d7d7d7;
  color: #4f5c6d;
  border: 1px solid #bfbfbf;
}

.check-msg.current {
  border: 2px dashed #3692ff;
}

.check-msg .tag {
  padding: 1px 5px;
  text-align: center;
  border-radius: 2px;
  margin-right: 5px;
  text-decoration: inherit;
}

.check-msg .tag.macro {
  background-color: #83876a;
  color: white;
  text-transform: capitalize;
}

.check-msg .tag.note {
  background-color: #9299a1;
  color: white;
  text-transform: capitalize;
}

.checker-enum {
  color: white;
  padding: 1px 5px;
  text-align: center;
  border-radius: 25px;
  margin-right: 5px;
  text-decoration: inherit;
}

.checker-enum.info {
  background-color: #427ea9;
}

.checker-enum.error {
  background-color: #a94442;
}

.arrow {
  border: solid black;
  border-width: 0 3px 3px 0;
  display: inline-block;
  padding: 3px;
  cursor: pointer;
  margin: 0px 5px;
}

.arrow:hover {
  border: solid #437ea8;
  border-width: 0 3px 3px 0;
}

.left-arrow {
  transform: rotate(135deg);
  -webkit-transform: rotate(135deg);
}

.right-arrow {
  transform: rotate(-45deg);
  -webkit-transform: rotate(-45deg);
}

    </style>

    <script type="text/javascript">
      function setNonCompatibleBrowserMessage() {
  document.body.innerHTML =
    '<h2 style="margin-left: 20px;">Your browser is not compatible with CodeChecker Viewer!</h2> \
     <p style="margin-left: 20px;">The version required for the following browsers are:</p> \
     <ul style="margin-left: 20px;"> \
     <li>Internet Explorer: version 9 or newer</li> \
     <li>Firefox: version 22.0 or newer</li> \
     </ul>';
}

// http://stackoverflow.com/questions/5916900/how-can-you-detect-the-version-of-a-browser
var browserVersion = (function(){
  var ua = navigator.userAgent, tem,
    M = ua.match(/(opera|chrome|safari|firefox|msie|trident(?=\/))\/?\s*(\d+)/i) || [];

  if (/trident/i.test(M[1])) {
    tem = /\brv[ :]+(\d+)/g.exec(ua) || [];
    return 'IE ' + (tem[1] || '');
  }

  if (M[1] === 'Chrome') {
    tem = ua.match(/\b(OPR|Edge)\/(\d+)/);
    if (tem != null) return tem.slice(1).join(' ').replace('OPR', 'Opera');
  }

  M = M[2] ? [M[1], M[2]] : [navigator.appName, navigator.appVersion, '-?'];
  if ((tem = ua.match(/version\/(\d+)/i)) != null) M.splice(1, 1, tem[1]);
    return M.join(' ');
})();

var pos = browserVersion.indexOf(' ');
var browser = browserVersion.substr(0, pos);
var version = parseInt(browserVersion.substr(pos + 1));

var browserCompatible
  = browser === 'Firefox'
  ? version >= 22
  : browser === 'IE'
  ? version >= 9
  : true;


      /* MIT License

Copyright (C) 2017 by Marijn Haverbeke <marijnh@gmail.com> and others

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
 */
      !function(e,t){"object"==typeof exports&&"undefined"!=typeof module?module.exports=t():"function"==typeof define&&define.amd?define(t):e.CodeMirror=t()}(this,function(){"use strict";function e(e){return new RegExp("(^|\\s)"+e+"(?:$|\\s)\\s*")}function t(e){for(var t=e.childNodes.length;t>0;--t)e.removeChild(e.firstChild);return e}function r(e,r){return t(e).appendChild(r)}function n(e,t,r,n){var i=document.createElement(e);if(r&&(i.className=r),n&&(i.style.cssText=n),"string"==typeof t)i.appendChild(document.createTextNode(t));else if(t)for(var o=0;o<t.length;++o)i.appendChild(t[o]);return i}function i(e,t,r,i){var o=n(e,t,r,i);return o.setAttribute("role","presentation"),o}function o(e,t){if(3==t.nodeType&&(t=t.parentNode),e.contains)return e.contains(t);do{if(11==t.nodeType&&(t=t.host),t==e)return!0}while(t=t.parentNode)}function l(){var e;try{e=document.activeElement}catch(t){e=document.body||null}for(;e&&e.shadowRoot&&e.shadowRoot.activeElement;)e=e.shadowRoot.activeElement;return e}function s(t,r){var n=t.className;e(r).test(n)||(t.className+=(n?" ":"")+r)}function a(t,r){for(var n=t.split(" "),i=0;i<n.length;i++)n[i]&&!e(n[i]).test(r)&&(r+=" "+n[i]);return r}function u(e){var t=Array.prototype.slice.call(arguments,1);return function(){return e.apply(null,t)}}function c(e,t,r){t||(t={});for(var n in e)!e.hasOwnProperty(n)||!1===r&&t.hasOwnProperty(n)||(t[n]=e[n]);return t}function f(e,t,r,n,i){null==t&&-1==(t=e.search(/[^\s\u00a0]/))&&(t=e.length);for(var o=n||0,l=i||0;;){var s=e.indexOf("\t",o);if(s<0||s>=t)return l+(t-o);l+=s-o,l+=r-l%r,o=s+1}}function h(e,t){for(var r=0;r<e.length;++r)if(e[r]==t)return r;return-1}function d(e,t,r){for(var n=0,i=0;;){var o=e.indexOf("\t",n);-1==o&&(o=e.length);var l=o-n;if(o==e.length||i+l>=t)return n+Math.min(l,t-i);if(i+=o-n,i+=r-i%r,n=o+1,i>=t)return n}}function p(e){for(;Kl.length<=e;)Kl.push(g(Kl)+" ");return Kl[e]}function g(e){return e[e.length-1]}function v(e,t){for(var r=[],n=0;n<e.length;n++)r[n]=t(e[n],n);return r}function m(e,t,r){for(var n=0,i=r(t);n<e.length&&r(e[n])<=i;)n++;e.splice(n,0,t)}function y(){}function b(e,t){var r;return Object.create?r=Object.create(e):(y.prototype=e,r=new y),t&&c(t,r),r}function w(e){return/\w/.test(e)||e>""&&(e.toUpperCase()!=e.toLowerCase()||jl.test(e))}function x(e,t){return t?!!(t.source.indexOf("\\w")>-1&&w(e))||t.test(e):w(e)}function C(e){for(var t in e)if(e.hasOwnProperty(t)&&e[t])return!1;return!0}function S(e){return e.charCodeAt(0)>=768&&Xl.test(e)}function L(e,t,r){for(;(r<0?t>0:t<e.length)&&S(e.charAt(t));)t+=r;return t}function k(e,t,r){for(var n=t>r?-1:1;;){if(t==r)return t;var i=(t+r)/2,o=n<0?Math.ceil(i):Math.floor(i);if(o==t)return e(o)?t:r;e(o)?r=o:t=o+n}}function T(e,t,r){var o=this;this.input=r,o.scrollbarFiller=n("div",null,"CodeMirror-scrollbar-filler"),o.scrollbarFiller.setAttribute("cm-not-content","true"),o.gutterFiller=n("div",null,"CodeMirror-gutter-filler"),o.gutterFiller.setAttribute("cm-not-content","true"),o.lineDiv=i("div",null,"CodeMirror-code"),o.selectionDiv=n("div",null,null,"position: relative; z-index: 1"),o.cursorDiv=n("div",null,"CodeMirror-cursors"),o.measure=n("div",null,"CodeMirror-measure"),o.lineMeasure=n("div",null,"CodeMirror-measure"),o.lineSpace=i("div",[o.measure,o.lineMeasure,o.selectionDiv,o.cursorDiv,o.lineDiv],null,"position: relative; outline: none");var l=i("div",[o.lineSpace],"CodeMirror-lines");o.mover=n("div",[l],null,"position: relative"),o.sizer=n("div",[o.mover],"CodeMirror-sizer"),o.sizerWidth=null,o.heightForcer=n("div",null,null,"position: absolute; height: "+Rl+"px; width: 1px;"),o.gutters=n("div",null,"CodeMirror-gutters"),o.lineGutter=null,o.scroller=n("div",[o.sizer,o.heightForcer,o.gutters],"CodeMirror-scroll"),o.scroller.setAttribute("tabIndex","-1"),o.wrapper=n("div",[o.scrollbarFiller,o.gutterFiller,o.scroller],"CodeMirror"),gl&&vl<8&&(o.gutters.style.zIndex=-1,o.scroller.style.paddingRight=0),ml||fl&&Tl||(o.scroller.draggable=!0),e&&(e.appendChild?e.appendChild(o.wrapper):e(o.wrapper)),o.viewFrom=o.viewTo=t.first,o.reportedViewFrom=o.reportedViewTo=t.first,o.view=[],o.renderedView=null,o.externalMeasured=null,o.viewOffset=0,o.lastWrapHeight=o.lastWrapWidth=0,o.updateLineNumbers=null,o.nativeBarWidth=o.barHeight=o.barWidth=0,o.scrollbarsClipped=!1,o.lineNumWidth=o.lineNumInnerWidth=o.lineNumChars=null,o.alignWidgets=!1,o.cachedCharWidth=o.cachedTextHeight=o.cachedPaddingH=null,o.maxLine=null,o.maxLineLength=0,o.maxLineChanged=!1,o.wheelDX=o.wheelDY=o.wheelStartX=o.wheelStartY=null,o.shift=!1,o.selForContextMenu=null,o.activeTouch=null,r.init(o)}function M(e,t){if((t-=e.first)<0||t>=e.size)throw new Error("There is no line "+(t+e.first)+" in the document.");for(var r=e;!r.lines;)for(var n=0;;++n){var i=r.children[n],o=i.chunkSize();if(t<o){r=i;break}t-=o}return r.lines[t]}function N(e,t,r){var n=[],i=t.line;return e.iter(t.line,r.line+1,function(e){var o=e.text;i==r.line&&(o=o.slice(0,r.ch)),i==t.line&&(o=o.slice(t.ch)),n.push(o),++i}),n}function O(e,t,r){var n=[];return e.iter(t,r,function(e){n.push(e.text)}),n}function A(e,t){var r=t-e.height;if(r)for(var n=e;n;n=n.parent)n.height+=r}function W(e){if(null==e.parent)return null;for(var t=e.parent,r=h(t.lines,e),n=t.parent;n;t=n,n=n.parent)for(var i=0;n.children[i]!=t;++i)r+=n.children[i].chunkSize();return r+t.first}function D(e,t){var r=e.first;e:do{for(var n=0;n<e.children.length;++n){var i=e.children[n],o=i.height;if(t<o){e=i;continue e}t-=o,r+=i.chunkSize()}return r}while(!e.lines);for(var l=0;l<e.lines.length;++l){var s=e.lines[l].height;if(t<s)break;t-=s}return r+l}function H(e,t){return t>=e.first&&t<e.first+e.size}function F(e,t){return String(e.lineNumberFormatter(t+e.firstLineNumber))}function E(e,t,r){if(void 0===r&&(r=null),!(this instanceof E))return new E(e,t,r);this.line=e,this.ch=t,this.sticky=r}function P(e,t){return e.line-t.line||e.ch-t.ch}function I(e,t){return e.sticky==t.sticky&&0==P(e,t)}function z(e){return E(e.line,e.ch)}function R(e,t){return P(e,t)<0?t:e}function B(e,t){return P(e,t)<0?e:t}function G(e,t){return Math.max(e.first,Math.min(t,e.first+e.size-1))}function U(e,t){if(t.line<e.first)return E(e.first,0);var r=e.first+e.size-1;return t.line>r?E(r,M(e,r).text.length):V(t,M(e,t.line).text.length)}function V(e,t){var r=e.ch;return null==r||r>t?E(e.line,t):r<0?E(e.line,0):e}function K(e,t){for(var r=[],n=0;n<t.length;n++)r[n]=U(e,t[n]);return r}function j(){Yl=!0}function X(){_l=!0}function Y(e,t,r){this.marker=e,this.from=t,this.to=r}function _(e,t){if(e)for(var r=0;r<e.length;++r){var n=e[r];if(n.marker==t)return n}}function $(e,t){for(var r,n=0;n<e.length;++n)e[n]!=t&&(r||(r=[])).push(e[n]);return r}function q(e,t){e.markedSpans=e.markedSpans?e.markedSpans.concat([t]):[t],t.marker.attachLine(e)}function Z(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t)||o.from==t&&"bookmark"==l.type&&(!r||!o.marker.insertLeft)){var s=null==o.to||(l.inclusiveRight?o.to>=t:o.to>t);(n||(n=[])).push(new Y(l,o.from,s?null:o.to))}}return n}function Q(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.to||(l.inclusiveRight?o.to>=t:o.to>t)||o.from==t&&"bookmark"==l.type&&(!r||o.marker.insertLeft)){var s=null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t);(n||(n=[])).push(new Y(l,s?null:o.from-t,null==o.to?null:o.to-t))}}return n}function J(e,t){if(t.full)return null;var r=H(e,t.from.line)&&M(e,t.from.line).markedSpans,n=H(e,t.to.line)&&M(e,t.to.line).markedSpans;if(!r&&!n)return null;var i=t.from.ch,o=t.to.ch,l=0==P(t.from,t.to),s=Z(r,i,l),a=Q(n,o,l),u=1==t.text.length,c=g(t.text).length+(u?i:0);if(s)for(var f=0;f<s.length;++f){var h=s[f];if(null==h.to){var d=_(a,h.marker);d?u&&(h.to=null==d.to?null:d.to+c):h.to=i}}if(a)for(var p=0;p<a.length;++p){var v=a[p];null!=v.to&&(v.to+=c),null==v.from?_(s,v.marker)||(v.from=c,u&&(s||(s=[])).push(v)):(v.from+=c,u&&(s||(s=[])).push(v))}s&&(s=ee(s)),a&&a!=s&&(a=ee(a));var m=[s];if(!u){var y,b=t.text.length-2;if(b>0&&s)for(var w=0;w<s.length;++w)null==s[w].to&&(y||(y=[])).push(new Y(s[w].marker,null,null));for(var x=0;x<b;++x)m.push(y);m.push(a)}return m}function ee(e){for(var t=0;t<e.length;++t){var r=e[t];null!=r.from&&r.from==r.to&&!1!==r.marker.clearWhenEmpty&&e.splice(t--,1)}return e.length?e:null}function te(e,t,r){var n=null;if(e.iter(t.line,r.line+1,function(e){if(e.markedSpans)for(var t=0;t<e.markedSpans.length;++t){var r=e.markedSpans[t].marker;!r.readOnly||n&&-1!=h(n,r)||(n||(n=[])).push(r)}}),!n)return null;for(var i=[{from:t,to:r}],o=0;o<n.length;++o)for(var l=n[o],s=l.find(0),a=0;a<i.length;++a){var u=i[a];if(!(P(u.to,s.from)<0||P(u.from,s.to)>0)){var c=[a,1],f=P(u.from,s.from),d=P(u.to,s.to);(f<0||!l.inclusiveLeft&&!f)&&c.push({from:u.from,to:s.from}),(d>0||!l.inclusiveRight&&!d)&&c.push({from:s.to,to:u.to}),i.splice.apply(i,c),a+=c.length-3}}return i}function re(e){var t=e.markedSpans;if(t){for(var r=0;r<t.length;++r)t[r].marker.detachLine(e);e.markedSpans=null}}function ne(e,t){if(t){for(var r=0;r<t.length;++r)t[r].marker.attachLine(e);e.markedSpans=t}}function ie(e){return e.inclusiveLeft?-1:0}function oe(e){return e.inclusiveRight?1:0}function le(e,t){var r=e.lines.length-t.lines.length;if(0!=r)return r;var n=e.find(),i=t.find(),o=P(n.from,i.from)||ie(e)-ie(t);if(o)return-o;var l=P(n.to,i.to)||oe(e)-oe(t);return l||t.id-e.id}function se(e,t){var r,n=_l&&e.markedSpans;if(n)for(var i=void 0,o=0;o<n.length;++o)(i=n[o]).marker.collapsed&&null==(t?i.from:i.to)&&(!r||le(r,i.marker)<0)&&(r=i.marker);return r}function ae(e){return se(e,!0)}function ue(e){return se(e,!1)}function ce(e,t,r,n,i){var o=M(e,t),l=_l&&o.markedSpans;if(l)for(var s=0;s<l.length;++s){var a=l[s];if(a.marker.collapsed){var u=a.marker.find(0),c=P(u.from,r)||ie(a.marker)-ie(i),f=P(u.to,n)||oe(a.marker)-oe(i);if(!(c>=0&&f<=0||c<=0&&f>=0)&&(c<=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.to,r)>=0:P(u.to,r)>0)||c>=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.from,n)<=0:P(u.from,n)<0)))return!0}}}function fe(e){for(var t;t=ae(e);)e=t.find(-1,!0).line;return e}function he(e){for(var t;t=ue(e);)e=t.find(1,!0).line;return e}function de(e){for(var t,r;t=ue(e);)e=t.find(1,!0).line,(r||(r=[])).push(e);return r}function pe(e,t){var r=M(e,t),n=fe(r);return r==n?t:W(n)}function ge(e,t){if(t>e.lastLine())return t;var r,n=M(e,t);if(!ve(e,n))return t;for(;r=ue(n);)n=r.find(1,!0).line;return W(n)+1}function ve(e,t){var r=_l&&t.markedSpans;if(r)for(var n=void 0,i=0;i<r.length;++i)if((n=r[i]).marker.collapsed){if(null==n.from)return!0;if(!n.marker.widgetNode&&0==n.from&&n.marker.inclusiveLeft&&me(e,t,n))return!0}}function me(e,t,r){if(null==r.to){var n=r.marker.find(1,!0);return me(e,n.line,_(n.line.markedSpans,r.marker))}if(r.marker.inclusiveRight&&r.to==t.text.length)return!0;for(var i=void 0,o=0;o<t.markedSpans.length;++o)if((i=t.markedSpans[o]).marker.collapsed&&!i.marker.widgetNode&&i.from==r.to&&(null==i.to||i.to!=r.from)&&(i.marker.inclusiveLeft||r.marker.inclusiveRight)&&me(e,t,i))return!0}function ye(e){for(var t=0,r=(e=fe(e)).parent,n=0;n<r.lines.length;++n){var i=r.lines[n];if(i==e)break;t+=i.height}for(var o=r.parent;o;r=o,o=r.parent)for(var l=0;l<o.children.length;++l){var s=o.children[l];if(s==r)break;t+=s.height}return t}function be(e){if(0==e.height)return 0;for(var t,r=e.text.length,n=e;t=ae(n);){var i=t.find(0,!0);n=i.from.line,r+=i.from.ch-i.to.ch}for(n=e;t=ue(n);){var o=t.find(0,!0);r-=n.text.length-o.from.ch,r+=(n=o.to.line).text.length-o.to.ch}return r}function we(e){var t=e.display,r=e.doc;t.maxLine=M(r,r.first),t.maxLineLength=be(t.maxLine),t.maxLineChanged=!0,r.iter(function(e){var r=be(e);r>t.maxLineLength&&(t.maxLineLength=r,t.maxLine=e)})}function xe(e,t,r,n){if(!e)return n(t,r,"ltr",0);for(var i=!1,o=0;o<e.length;++o){var l=e[o];(l.from<r&&l.to>t||t==r&&l.to==t)&&(n(Math.max(l.from,t),Math.min(l.to,r),1==l.level?"rtl":"ltr",o),i=!0)}i||n(t,r,"ltr")}function Ce(e,t,r){var n;$l=null;for(var i=0;i<e.length;++i){var o=e[i];if(o.from<t&&o.to>t)return i;o.to==t&&(o.from!=o.to&&"before"==r?n=i:$l=i),o.from==t&&(o.from!=o.to&&"before"!=r?n=i:$l=i)}return null!=n?n:$l}function Se(e,t){var r=e.order;return null==r&&(r=e.order=ql(e.text,t)),r}function Le(e,t){return e._handlers&&e._handlers[t]||Zl}function ke(e,t,r){if(e.removeEventListener)e.removeEventListener(t,r,!1);else if(e.detachEvent)e.detachEvent("on"+t,r);else{var n=e._handlers,i=n&&n[t];if(i){var o=h(i,r);o>-1&&(n[t]=i.slice(0,o).concat(i.slice(o+1)))}}}function Te(e,t){var r=Le(e,t);if(r.length)for(var n=Array.prototype.slice.call(arguments,2),i=0;i<r.length;++i)r[i].apply(null,n)}function Me(e,t,r){return"string"==typeof t&&(t={type:t,preventDefault:function(){this.defaultPrevented=!0}}),Te(e,r||t.type,e,t),He(t)||t.codemirrorIgnore}function Ne(e){var t=e._handlers&&e._handlers.cursorActivity;if(t)for(var r=e.curOp.cursorActivityHandlers||(e.curOp.cursorActivityHandlers=[]),n=0;n<t.length;++n)-1==h(r,t[n])&&r.push(t[n])}function Oe(e,t){return Le(e,t).length>0}function Ae(e){e.prototype.on=function(e,t){Ql(this,e,t)},e.prototype.off=function(e,t){ke(this,e,t)}}function We(e){e.preventDefault?e.preventDefault():e.returnValue=!1}function De(e){e.stopPropagation?e.stopPropagation():e.cancelBubble=!0}function He(e){return null!=e.defaultPrevented?e.defaultPrevented:0==e.returnValue}function Fe(e){We(e),De(e)}function Ee(e){return e.target||e.srcElement}function Pe(e){var t=e.which;return null==t&&(1&e.button?t=1:2&e.button?t=3:4&e.button&&(t=2)),Ml&&e.ctrlKey&&1==t&&(t=3),t}function Ie(e){if(null==Il){var t=n("span","​");r(e,n("span",[t,document.createTextNode("x")])),0!=e.firstChild.offsetHeight&&(Il=t.offsetWidth<=1&&t.offsetHeight>2&&!(gl&&vl<8))}var i=Il?n("span","​"):n("span"," ",null,"display: inline-block; width: 1px; margin-right: -1px");return i.setAttribute("cm-text",""),i}function ze(e){if(null!=zl)return zl;var n=r(e,document.createTextNode("AخA")),i=Wl(n,0,1).getBoundingClientRect(),o=Wl(n,1,2).getBoundingClientRect();return t(e),!(!i||i.left==i.right)&&(zl=o.right-i.right<3)}function Re(e){if(null!=ns)return ns;var t=r(e,n("span","x")),i=t.getBoundingClientRect(),o=Wl(t,0,1).getBoundingClientRect();return ns=Math.abs(i.left-o.left)>1}function Be(e,t){arguments.length>2&&(t.dependencies=Array.prototype.slice.call(arguments,2)),is[e]=t}function Ge(e){if("string"==typeof e&&os.hasOwnProperty(e))e=os[e];else if(e&&"string"==typeof e.name&&os.hasOwnProperty(e.name)){var t=os[e.name];"string"==typeof t&&(t={name:t}),(e=b(t,e)).name=t.name}else{if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+xml$/.test(e))return Ge("application/xml");if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+json$/.test(e))return Ge("application/json")}return"string"==typeof e?{name:e}:e||{name:"null"}}function Ue(e,t){t=Ge(t);var r=is[t.name];if(!r)return Ue(e,"text/plain");var n=r(e,t);if(ls.hasOwnProperty(t.name)){var i=ls[t.name];for(var o in i)i.hasOwnProperty(o)&&(n.hasOwnProperty(o)&&(n["_"+o]=n[o]),n[o]=i[o])}if(n.name=t.name,t.helperType&&(n.helperType=t.helperType),t.modeProps)for(var l in t.modeProps)n[l]=t.modeProps[l];return n}function Ve(e,t){c(t,ls.hasOwnProperty(e)?ls[e]:ls[e]={})}function Ke(e,t){if(!0===t)return t;if(e.copyState)return e.copyState(t);var r={};for(var n in t){var i=t[n];i instanceof Array&&(i=i.concat([])),r[n]=i}return r}function je(e,t){for(var r;e.innerMode&&(r=e.innerMode(t))&&r.mode!=e;)t=r.state,e=r.mode;return r||{mode:e,state:t}}function Xe(e,t,r){return!e.startState||e.startState(t,r)}function Ye(e,t,r,n){var i=[e.state.modeGen],o={};tt(e,t.text,e.doc.mode,r,function(e,t){return i.push(e,t)},o,n);for(var l=r.state,s=0;s<e.state.overlays.length;++s)!function(n){var l=e.state.overlays[n],s=1,a=0;r.state=!0,tt(e,t.text,l.mode,r,function(e,t){for(var r=s;a<e;){var n=i[s];n>e&&i.splice(s,1,e,i[s+1],n),s+=2,a=Math.min(e,n)}if(t)if(l.opaque)i.splice(r,s-r,e,"overlay "+t),s=r+2;else for(;r<s;r+=2){var o=i[r+1];i[r+1]=(o?o+" ":"")+"overlay "+t}},o)}(s);return r.state=l,{styles:i,classes:o.bgClass||o.textClass?o:null}}function _e(e,t,r){if(!t.styles||t.styles[0]!=e.state.modeGen){var n=$e(e,W(t)),i=t.text.length>e.options.maxHighlightLength&&Ke(e.doc.mode,n.state),o=Ye(e,t,n);i&&(n.state=i),t.stateAfter=n.save(!i),t.styles=o.styles,o.classes?t.styleClasses=o.classes:t.styleClasses&&(t.styleClasses=null),r===e.doc.highlightFrontier&&(e.doc.modeFrontier=Math.max(e.doc.modeFrontier,++e.doc.highlightFrontier))}return t.styles}function $e(e,t,r){var n=e.doc,i=e.display;if(!n.mode.startState)return new us(n,!0,t);var o=rt(e,t,r),l=o>n.first&&M(n,o-1).stateAfter,s=l?us.fromSaved(n,l,o):new us(n,Xe(n.mode),o);return n.iter(o,t,function(r){qe(e,r.text,s);var n=s.line;r.stateAfter=n==t-1||n%5==0||n>=i.viewFrom&&n<i.viewTo?s.save():null,s.nextLine()}),r&&(n.modeFrontier=s.line),s}function qe(e,t,r,n){var i=e.doc.mode,o=new ss(t,e.options.tabSize,r);for(o.start=o.pos=n||0,""==t&&Ze(i,r.state);!o.eol();)Qe(i,o,r.state),o.start=o.pos}function Ze(e,t){if(e.blankLine)return e.blankLine(t);if(e.innerMode){var r=je(e,t);return r.mode.blankLine?r.mode.blankLine(r.state):void 0}}function Qe(e,t,r,n){for(var i=0;i<10;i++){n&&(n[0]=je(e,r).mode);var o=e.token(t,r);if(t.pos>t.start)return o}throw new Error("Mode "+e.name+" failed to advance stream.")}function Je(e,t,r,n){var i,o,l=e.doc,s=l.mode,a=M(l,(t=U(l,t)).line),u=$e(e,t.line,r),c=new ss(a.text,e.options.tabSize,u);for(n&&(o=[]);(n||c.pos<t.ch)&&!c.eol();)c.start=c.pos,i=Qe(s,c,u.state),n&&o.push(new cs(c,i,Ke(l.mode,u.state)));return n?o:new cs(c,i,u.state)}function et(e,t){if(e)for(;;){var r=e.match(/(?:^|\s+)line-(background-)?(\S+)/);if(!r)break;e=e.slice(0,r.index)+e.slice(r.index+r[0].length);var n=r[1]?"bgClass":"textClass";null==t[n]?t[n]=r[2]:new RegExp("(?:^|s)"+r[2]+"(?:$|s)").test(t[n])||(t[n]+=" "+r[2])}return e}function tt(e,t,r,n,i,o,l){var s=r.flattenSpans;null==s&&(s=e.options.flattenSpans);var a,u=0,c=null,f=new ss(t,e.options.tabSize,n),h=e.options.addModeClass&&[null];for(""==t&&et(Ze(r,n.state),o);!f.eol();){if(f.pos>e.options.maxHighlightLength?(s=!1,l&&qe(e,t,n,f.pos),f.pos=t.length,a=null):a=et(Qe(r,f,n.state,h),o),h){var d=h[0].name;d&&(a="m-"+(a?d+" "+a:d))}if(!s||c!=a){for(;u<f.start;)i(u=Math.min(f.start,u+5e3),c);c=a}f.start=f.pos}for(;u<f.pos;){var p=Math.min(f.pos,u+5e3);i(p,c),u=p}}function rt(e,t,r){for(var n,i,o=e.doc,l=r?-1:t-(e.doc.mode.innerMode?1e3:100),s=t;s>l;--s){if(s<=o.first)return o.first;var a=M(o,s-1),u=a.stateAfter;if(u&&(!r||s+(u instanceof as?u.lookAhead:0)<=o.modeFrontier))return s;var c=f(a.text,null,e.options.tabSize);(null==i||n>c)&&(i=s-1,n=c)}return i}function nt(e,t){if(e.modeFrontier=Math.min(e.modeFrontier,t),!(e.highlightFrontier<t-10)){for(var r=e.first,n=t-1;n>r;n--){var i=M(e,n).stateAfter;if(i&&(!(i instanceof as)||n+i.lookAhead<t)){r=n+1;break}}e.highlightFrontier=Math.min(e.highlightFrontier,r)}}function it(e,t,r,n){e.text=t,e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null),null!=e.order&&(e.order=null),re(e),ne(e,r);var i=n?n(e):1;i!=e.height&&A(e,i)}function ot(e){e.parent=null,re(e)}function lt(e,t){if(!e||/^\s*$/.test(e))return null;var r=t.addModeClass?ps:ds;return r[e]||(r[e]=e.replace(/\S+/g,"cm-$&"))}function st(e,t){var r=i("span",null,null,ml?"padding-right: .1px":null),n={pre:i("pre",[r],"CodeMirror-line"),content:r,col:0,pos:0,cm:e,trailingSpace:!1,splitSpaces:(gl||ml)&&e.getOption("lineWrapping")};t.measure={};for(var o=0;o<=(t.rest?t.rest.length:0);o++){var l=o?t.rest[o-1]:t.line,s=void 0;n.pos=0,n.addToken=ut,ze(e.display.measure)&&(s=Se(l,e.doc.direction))&&(n.addToken=ft(n.addToken,s)),n.map=[],dt(l,n,_e(e,l,t!=e.display.externalMeasured&&W(l))),l.styleClasses&&(l.styleClasses.bgClass&&(n.bgClass=a(l.styleClasses.bgClass,n.bgClass||"")),l.styleClasses.textClass&&(n.textClass=a(l.styleClasses.textClass,n.textClass||""))),0==n.map.length&&n.map.push(0,0,n.content.appendChild(Ie(e.display.measure))),0==o?(t.measure.map=n.map,t.measure.cache={}):((t.measure.maps||(t.measure.maps=[])).push(n.map),(t.measure.caches||(t.measure.caches=[])).push({}))}if(ml){var u=n.content.lastChild;(/\bcm-tab\b/.test(u.className)||u.querySelector&&u.querySelector(".cm-tab"))&&(n.content.className="cm-tab-wrap-hack")}return Te(e,"renderLine",e,t.line,n.pre),n.pre.className&&(n.textClass=a(n.pre.className,n.textClass||"")),n}function at(e){var t=n("span","•","cm-invalidchar");return t.title="\\u"+e.charCodeAt(0).toString(16),t.setAttribute("aria-label",t.title),t}function ut(e,t,r,i,o,l,s){if(t){var a,u=e.splitSpaces?ct(t,e.trailingSpace):t,c=e.cm.state.specialChars,f=!1;if(c.test(t)){a=document.createDocumentFragment();for(var h=0;;){c.lastIndex=h;var d=c.exec(t),g=d?d.index-h:t.length-h;if(g){var v=document.createTextNode(u.slice(h,h+g));gl&&vl<9?a.appendChild(n("span",[v])):a.appendChild(v),e.map.push(e.pos,e.pos+g,v),e.col+=g,e.pos+=g}if(!d)break;h+=g+1;var m=void 0;if("\t"==d[0]){var y=e.cm.options.tabSize,b=y-e.col%y;(m=a.appendChild(n("span",p(b),"cm-tab"))).setAttribute("role","presentation"),m.setAttribute("cm-text","\t"),e.col+=b}else"\r"==d[0]||"\n"==d[0]?((m=a.appendChild(n("span","\r"==d[0]?"␍":"␤","cm-invalidchar"))).setAttribute("cm-text",d[0]),e.col+=1):((m=e.cm.options.specialCharPlaceholder(d[0])).setAttribute("cm-text",d[0]),gl&&vl<9?a.appendChild(n("span",[m])):a.appendChild(m),e.col+=1);e.map.push(e.pos,e.pos+1,m),e.pos++}}else e.col+=t.length,a=document.createTextNode(u),e.map.push(e.pos,e.pos+t.length,a),gl&&vl<9&&(f=!0),e.pos+=t.length;if(e.trailingSpace=32==u.charCodeAt(t.length-1),r||i||o||f||s){var w=r||"";i&&(w+=i),o&&(w+=o);var x=n("span",[a],w,s);return l&&(x.title=l),e.content.appendChild(x)}e.content.appendChild(a)}}function ct(e,t){if(e.length>1&&!/  /.test(e))return e;for(var r=t,n="",i=0;i<e.length;i++){var o=e.charAt(i);" "!=o||!r||i!=e.length-1&&32!=e.charCodeAt(i+1)||(o=" "),n+=o,r=" "==o}return n}function ft(e,t){return function(r,n,i,o,l,s,a){i=i?i+" cm-force-border":"cm-force-border";for(var u=r.pos,c=u+n.length;;){for(var f=void 0,h=0;h<t.length&&!((f=t[h]).to>u&&f.from<=u);h++);if(f.to>=c)return e(r,n,i,o,l,s,a);e(r,n.slice(0,f.to-u),i,o,null,s,a),o=null,n=n.slice(f.to-u),u=f.to}}}function ht(e,t,r,n){var i=!n&&r.widgetNode;i&&e.map.push(e.pos,e.pos+t,i),!n&&e.cm.display.input.needsContentAttribute&&(i||(i=e.content.appendChild(document.createElement("span"))),i.setAttribute("cm-marker",r.id)),i&&(e.cm.display.input.setUneditable(i),e.content.appendChild(i)),e.pos+=t,e.trailingSpace=!1}function dt(e,t,r){var n=e.markedSpans,i=e.text,o=0;if(n)for(var l,s,a,u,c,f,h,d=i.length,p=0,g=1,v="",m=0;;){if(m==p){a=u=c=f=s="",h=null,m=1/0;for(var y=[],b=void 0,w=0;w<n.length;++w){var x=n[w],C=x.marker;"bookmark"==C.type&&x.from==p&&C.widgetNode?y.push(C):x.from<=p&&(null==x.to||x.to>p||C.collapsed&&x.to==p&&x.from==p)?(null!=x.to&&x.to!=p&&m>x.to&&(m=x.to,u=""),C.className&&(a+=" "+C.className),C.css&&(s=(s?s+";":"")+C.css),C.startStyle&&x.from==p&&(c+=" "+C.startStyle),C.endStyle&&x.to==m&&(b||(b=[])).push(C.endStyle,x.to),C.title&&!f&&(f=C.title),C.collapsed&&(!h||le(h.marker,C)<0)&&(h=x)):x.from>p&&m>x.from&&(m=x.from)}if(b)for(var S=0;S<b.length;S+=2)b[S+1]==m&&(u+=" "+b[S]);if(!h||h.from==p)for(var L=0;L<y.length;++L)ht(t,0,y[L]);if(h&&(h.from||0)==p){if(ht(t,(null==h.to?d+1:h.to)-p,h.marker,null==h.from),null==h.to)return;h.to==p&&(h=!1)}}if(p>=d)break;for(var k=Math.min(d,m);;){if(v){var T=p+v.length;if(!h){var M=T>k?v.slice(0,k-p):v;t.addToken(t,M,l?l+a:a,c,p+M.length==m?u:"",f,s)}if(T>=k){v=v.slice(k-p),p=k;break}p=T,c=""}v=i.slice(o,o=r[g++]),l=lt(r[g++],t.cm.options)}}else for(var N=1;N<r.length;N+=2)t.addToken(t,i.slice(o,o=r[N]),lt(r[N+1],t.cm.options))}function pt(e,t,r){this.line=t,this.rest=de(t),this.size=this.rest?W(g(this.rest))-r+1:1,this.node=this.text=null,this.hidden=ve(e,t)}function gt(e,t,r){for(var n,i=[],o=t;o<r;o=n){var l=new pt(e.doc,M(e.doc,o),o);n=o+l.size,i.push(l)}return i}function vt(e){gs?gs.ops.push(e):e.ownsGroup=gs={ops:[e],delayedCallbacks:[]}}function mt(e){var t=e.delayedCallbacks,r=0;do{for(;r<t.length;r++)t[r].call(null);for(var n=0;n<e.ops.length;n++){var i=e.ops[n];if(i.cursorActivityHandlers)for(;i.cursorActivityCalled<i.cursorActivityHandlers.length;)i.cursorActivityHandlers[i.cursorActivityCalled++].call(null,i.cm)}}while(r<t.length)}function yt(e,t){var r=e.ownsGroup;if(r)try{mt(r)}finally{gs=null,t(r)}}function bt(e,t){var r=Le(e,t);if(r.length){var n,i=Array.prototype.slice.call(arguments,2);gs?n=gs.delayedCallbacks:vs?n=vs:(n=vs=[],setTimeout(wt,0));for(var o=0;o<r.length;++o)!function(e){n.push(function(){return r[e].apply(null,i)})}(o)}}function wt(){var e=vs;vs=null;for(var t=0;t<e.length;++t)e[t]()}function xt(e,t,r,n){for(var i=0;i<t.changes.length;i++){var o=t.changes[i];"text"==o?kt(e,t):"gutter"==o?Mt(e,t,r,n):"class"==o?Tt(e,t):"widget"==o&&Nt(e,t,n)}t.changes=null}function Ct(e){return e.node==e.text&&(e.node=n("div",null,null,"position: relative"),e.text.parentNode&&e.text.parentNode.replaceChild(e.node,e.text),e.node.appendChild(e.text),gl&&vl<8&&(e.node.style.zIndex=2)),e.node}function St(e,t){var r=t.bgClass?t.bgClass+" "+(t.line.bgClass||""):t.line.bgClass;if(r&&(r+=" CodeMirror-linebackground"),t.background)r?t.background.className=r:(t.background.parentNode.removeChild(t.background),t.background=null);else if(r){var i=Ct(t);t.background=i.insertBefore(n("div",null,r),i.firstChild),e.display.input.setUneditable(t.background)}}function Lt(e,t){var r=e.display.externalMeasured;return r&&r.line==t.line?(e.display.externalMeasured=null,t.measure=r.measure,r.built):st(e,t)}function kt(e,t){var r=t.text.className,n=Lt(e,t);t.text==t.node&&(t.node=n.pre),t.text.parentNode.replaceChild(n.pre,t.text),t.text=n.pre,n.bgClass!=t.bgClass||n.textClass!=t.textClass?(t.bgClass=n.bgClass,t.textClass=n.textClass,Tt(e,t)):r&&(t.text.className=r)}function Tt(e,t){St(e,t),t.line.wrapClass?Ct(t).className=t.line.wrapClass:t.node!=t.text&&(t.node.className="");var r=t.textClass?t.textClass+" "+(t.line.textClass||""):t.line.textClass;t.text.className=r||""}function Mt(e,t,r,i){if(t.gutter&&(t.node.removeChild(t.gutter),t.gutter=null),t.gutterBackground&&(t.node.removeChild(t.gutterBackground),t.gutterBackground=null),t.line.gutterClass){var o=Ct(t);t.gutterBackground=n("div",null,"CodeMirror-gutter-background "+t.line.gutterClass,"left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px; width: "+i.gutterTotalWidth+"px"),e.display.input.setUneditable(t.gutterBackground),o.insertBefore(t.gutterBackground,t.text)}var l=t.line.gutterMarkers;if(e.options.lineNumbers||l){var s=Ct(t),a=t.gutter=n("div",null,"CodeMirror-gutter-wrapper","left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px");if(e.display.input.setUneditable(a),s.insertBefore(a,t.text),t.line.gutterClass&&(a.className+=" "+t.line.gutterClass),!e.options.lineNumbers||l&&l["CodeMirror-linenumbers"]||(t.lineNumber=a.appendChild(n("div",F(e.options,r),"CodeMirror-linenumber CodeMirror-gutter-elt","left: "+i.gutterLeft["CodeMirror-linenumbers"]+"px; width: "+e.display.lineNumInnerWidth+"px"))),l)for(var u=0;u<e.options.gutters.length;++u){var c=e.options.gutters[u],f=l.hasOwnProperty(c)&&l[c];f&&a.appendChild(n("div",[f],"CodeMirror-gutter-elt","left: "+i.gutterLeft[c]+"px; width: "+i.gutterWidth[c]+"px"))}}}function Nt(e,t,r){t.alignable&&(t.alignable=null);for(var n=t.node.firstChild,i=void 0;n;n=i)i=n.nextSibling,"CodeMirror-linewidget"==n.className&&t.node.removeChild(n);At(e,t,r)}function Ot(e,t,r,n){var i=Lt(e,t);return t.text=t.node=i.pre,i.bgClass&&(t.bgClass=i.bgClass),i.textClass&&(t.textClass=i.textClass),Tt(e,t),Mt(e,t,r,n),At(e,t,n),t.node}function At(e,t,r){if(Wt(e,t.line,t,r,!0),t.rest)for(var n=0;n<t.rest.length;n++)Wt(e,t.rest[n],t,r,!1)}function Wt(e,t,r,i,o){if(t.widgets)for(var l=Ct(r),s=0,a=t.widgets;s<a.length;++s){var u=a[s],c=n("div",[u.node],"CodeMirror-linewidget");u.handleMouseEvents||c.setAttribute("cm-ignore-events","true"),Dt(u,c,r,i),e.display.input.setUneditable(c),o&&u.above?l.insertBefore(c,r.gutter||r.text):l.appendChild(c),bt(u,"redraw")}}function Dt(e,t,r,n){if(e.noHScroll){(r.alignable||(r.alignable=[])).push(t);var i=n.wrapperWidth;t.style.left=n.fixedPos+"px",e.coverGutter||(i-=n.gutterTotalWidth,t.style.paddingLeft=n.gutterTotalWidth+"px"),t.style.width=i+"px"}e.coverGutter&&(t.style.zIndex=5,t.style.position="relative",e.noHScroll||(t.style.marginLeft=-n.gutterTotalWidth+"px"))}function Ht(e){if(null!=e.height)return e.height;var t=e.doc.cm;if(!t)return 0;if(!o(document.body,e.node)){var i="position: relative;";e.coverGutter&&(i+="margin-left: -"+t.display.gutters.offsetWidth+"px;"),e.noHScroll&&(i+="width: "+t.display.wrapper.clientWidth+"px;"),r(t.display.measure,n("div",[e.node],null,i))}return e.height=e.node.parentNode.offsetHeight}function Ft(e,t){for(var r=Ee(t);r!=e.wrapper;r=r.parentNode)if(!r||1==r.nodeType&&"true"==r.getAttribute("cm-ignore-events")||r.parentNode==e.sizer&&r!=e.mover)return!0}function Et(e){return e.lineSpace.offsetTop}function Pt(e){return e.mover.offsetHeight-e.lineSpace.offsetHeight}function It(e){if(e.cachedPaddingH)return e.cachedPaddingH;var t=r(e.measure,n("pre","x")),i=window.getComputedStyle?window.getComputedStyle(t):t.currentStyle,o={left:parseInt(i.paddingLeft),right:parseInt(i.paddingRight)};return isNaN(o.left)||isNaN(o.right)||(e.cachedPaddingH=o),o}function zt(e){return Rl-e.display.nativeBarWidth}function Rt(e){return e.display.scroller.clientWidth-zt(e)-e.display.barWidth}function Bt(e){return e.display.scroller.clientHeight-zt(e)-e.display.barHeight}function Gt(e,t,r){var n=e.options.lineWrapping,i=n&&Rt(e);if(!t.measure.heights||n&&t.measure.width!=i){var o=t.measure.heights=[];if(n){t.measure.width=i;for(var l=t.text.firstChild.getClientRects(),s=0;s<l.length-1;s++){var a=l[s],u=l[s+1];Math.abs(a.bottom-u.bottom)>2&&o.push((a.bottom+u.top)/2-r.top)}}o.push(r.bottom-r.top)}}function Ut(e,t,r){if(e.line==t)return{map:e.measure.map,cache:e.measure.cache};for(var n=0;n<e.rest.length;n++)if(e.rest[n]==t)return{map:e.measure.maps[n],cache:e.measure.caches[n]};for(var i=0;i<e.rest.length;i++)if(W(e.rest[i])>r)return{map:e.measure.maps[i],cache:e.measure.caches[i],before:!0}}function Vt(e,t){var n=W(t=fe(t)),i=e.display.externalMeasured=new pt(e.doc,t,n);i.lineN=n;var o=i.built=st(e,i);return i.text=o.pre,r(e.display.lineMeasure,o.pre),i}function Kt(e,t,r,n){return Yt(e,Xt(e,t),r,n)}function jt(e,t){if(t>=e.display.viewFrom&&t<e.display.viewTo)return e.display.view[Lr(e,t)];var r=e.display.externalMeasured;return r&&t>=r.lineN&&t<r.lineN+r.size?r:void 0}function Xt(e,t){var r=W(t),n=jt(e,r);n&&!n.text?n=null:n&&n.changes&&(xt(e,n,r,br(e)),e.curOp.forceUpdate=!0),n||(n=Vt(e,t));var i=Ut(n,t,r);return{line:t,view:n,rect:null,map:i.map,cache:i.cache,before:i.before,hasHeights:!1}}function Yt(e,t,r,n,i){t.before&&(r=-1);var o,l=r+(n||"");return t.cache.hasOwnProperty(l)?o=t.cache[l]:(t.rect||(t.rect=t.view.text.getBoundingClientRect()),t.hasHeights||(Gt(e,t.view,t.rect),t.hasHeights=!0),(o=qt(e,t,r,n)).bogus||(t.cache[l]=o)),{left:o.left,right:o.right,top:i?o.rtop:o.top,bottom:i?o.rbottom:o.bottom}}function _t(e,t,r){for(var n,i,o,l,s,a,u=0;u<e.length;u+=3)if(s=e[u],a=e[u+1],t<s?(i=0,o=1,l="left"):t<a?o=(i=t-s)+1:(u==e.length-3||t==a&&e[u+3]>t)&&(i=(o=a-s)-1,t>=a&&(l="right")),null!=i){if(n=e[u+2],s==a&&r==(n.insertLeft?"left":"right")&&(l=r),"left"==r&&0==i)for(;u&&e[u-2]==e[u-3]&&e[u-1].insertLeft;)n=e[2+(u-=3)],l="left";if("right"==r&&i==a-s)for(;u<e.length-3&&e[u+3]==e[u+4]&&!e[u+5].insertLeft;)n=e[(u+=3)+2],l="right";break}return{node:n,start:i,end:o,collapse:l,coverStart:s,coverEnd:a}}function $t(e,t){var r=ms;if("left"==t)for(var n=0;n<e.length&&(r=e[n]).left==r.right;n++);else for(var i=e.length-1;i>=0&&(r=e[i]).left==r.right;i--);return r}function qt(e,t,r,n){var i,o=_t(t.map,r,n),l=o.node,s=o.start,a=o.end,u=o.collapse;if(3==l.nodeType){for(var c=0;c<4;c++){for(;s&&S(t.line.text.charAt(o.coverStart+s));)--s;for(;o.coverStart+a<o.coverEnd&&S(t.line.text.charAt(o.coverStart+a));)++a;if((i=gl&&vl<9&&0==s&&a==o.coverEnd-o.coverStart?l.parentNode.getBoundingClientRect():$t(Wl(l,s,a).getClientRects(),n)).left||i.right||0==s)break;a=s,s-=1,u="right"}gl&&vl<11&&(i=Zt(e.display.measure,i))}else{s>0&&(u=n="right");var f;i=e.options.lineWrapping&&(f=l.getClientRects()).length>1?f["right"==n?f.length-1:0]:l.getBoundingClientRect()}if(gl&&vl<9&&!s&&(!i||!i.left&&!i.right)){var h=l.parentNode.getClientRects()[0];i=h?{left:h.left,right:h.left+yr(e.display),top:h.top,bottom:h.bottom}:ms}for(var d=i.top-t.rect.top,p=i.bottom-t.rect.top,g=(d+p)/2,v=t.view.measure.heights,m=0;m<v.length-1&&!(g<v[m]);m++);var y=m?v[m-1]:0,b=v[m],w={left:("right"==u?i.right:i.left)-t.rect.left,right:("left"==u?i.left:i.right)-t.rect.left,top:y,bottom:b};return i.left||i.right||(w.bogus=!0),e.options.singleCursorHeightPerLine||(w.rtop=d,w.rbottom=p),w}function Zt(e,t){if(!window.screen||null==screen.logicalXDPI||screen.logicalXDPI==screen.deviceXDPI||!Re(e))return t;var r=screen.logicalXDPI/screen.deviceXDPI,n=screen.logicalYDPI/screen.deviceYDPI;return{left:t.left*r,right:t.right*r,top:t.top*n,bottom:t.bottom*n}}function Qt(e){if(e.measure&&(e.measure.cache={},e.measure.heights=null,e.rest))for(var t=0;t<e.rest.length;t++)e.measure.caches[t]={}}function Jt(e){e.display.externalMeasure=null,t(e.display.lineMeasure);for(var r=0;r<e.display.view.length;r++)Qt(e.display.view[r])}function er(e){Jt(e),e.display.cachedCharWidth=e.display.cachedTextHeight=e.display.cachedPaddingH=null,e.options.lineWrapping||(e.display.maxLineChanged=!0),e.display.lineNumChars=null}function tr(){return bl&&kl?-(document.body.getBoundingClientRect().left-parseInt(getComputedStyle(document.body).marginLeft)):window.pageXOffset||(document.documentElement||document.body).scrollLeft}function rr(){return bl&&kl?-(document.body.getBoundingClientRect().top-parseInt(getComputedStyle(document.body).marginTop)):window.pageYOffset||(document.documentElement||document.body).scrollTop}function nr(e){var t=0;if(e.widgets)for(var r=0;r<e.widgets.length;++r)e.widgets[r].above&&(t+=Ht(e.widgets[r]));return t}function ir(e,t,r,n,i){if(!i){var o=nr(t);r.top+=o,r.bottom+=o}if("line"==n)return r;n||(n="local");var l=ye(t);if("local"==n?l+=Et(e.display):l-=e.display.viewOffset,"page"==n||"window"==n){var s=e.display.lineSpace.getBoundingClientRect();l+=s.top+("window"==n?0:rr());var a=s.left+("window"==n?0:tr());r.left+=a,r.right+=a}return r.top+=l,r.bottom+=l,r}function or(e,t,r){if("div"==r)return t;var n=t.left,i=t.top;if("page"==r)n-=tr(),i-=rr();else if("local"==r||!r){var o=e.display.sizer.getBoundingClientRect();n+=o.left,i+=o.top}var l=e.display.lineSpace.getBoundingClientRect();return{left:n-l.left,top:i-l.top}}function lr(e,t,r,n,i){return n||(n=M(e.doc,t.line)),ir(e,n,Kt(e,n,t.ch,i),r)}function sr(e,t,r,n,i,o){function l(t,l){var s=Yt(e,i,t,l?"right":"left",o);return l?s.left=s.right:s.right=s.left,ir(e,n,s,r)}function s(e,t,r){var n=1==a[t].level;return l(r?e-1:e,n!=r)}n=n||M(e.doc,t.line),i||(i=Xt(e,n));var a=Se(n,e.doc.direction),u=t.ch,c=t.sticky;if(u>=n.text.length?(u=n.text.length,c="before"):u<=0&&(u=0,c="after"),!a)return l("before"==c?u-1:u,"before"==c);var f=Ce(a,u,c),h=$l,d=s(u,f,"before"==c);return null!=h&&(d.other=s(u,h,"before"!=c)),d}function ar(e,t){var r=0;t=U(e.doc,t),e.options.lineWrapping||(r=yr(e.display)*t.ch);var n=M(e.doc,t.line),i=ye(n)+Et(e.display);return{left:r,right:r,top:i,bottom:i+n.height}}function ur(e,t,r,n,i){var o=E(e,t,r);return o.xRel=i,n&&(o.outside=!0),o}function cr(e,t,r){var n=e.doc;if((r+=e.display.viewOffset)<0)return ur(n.first,0,null,!0,-1);var i=D(n,r),o=n.first+n.size-1;if(i>o)return ur(n.first+n.size-1,M(n,o).text.length,null,!0,1);t<0&&(t=0);for(var l=M(n,i);;){var s=pr(e,l,i,t,r),a=ue(l),u=a&&a.find(0,!0);if(!a||!(s.ch>u.from.ch||s.ch==u.from.ch&&s.xRel>0))return s;i=W(l=u.to.line)}}function fr(e,t,r,n){n-=nr(t);var i=t.text.length,o=k(function(t){return Yt(e,r,t-1).bottom<=n},i,0);return i=k(function(t){return Yt(e,r,t).top>n},o,i),{begin:o,end:i}}function hr(e,t,r,n){return r||(r=Xt(e,t)),fr(e,t,r,ir(e,t,Yt(e,r,n),"line").top)}function dr(e,t,r,n){return!(e.bottom<=r)&&(e.top>r||(n?e.left:e.right)>t)}function pr(e,t,r,n,i){i-=ye(t);var o=Xt(e,t),l=nr(t),s=0,a=t.text.length,u=!0,c=Se(t,e.doc.direction);if(c){var f=(e.options.lineWrapping?vr:gr)(e,t,r,o,c,n,i);s=(u=1!=f.level)?f.from:f.to-1,a=u?f.to:f.from-1}var h,d,p=null,g=null,v=k(function(t){var r=Yt(e,o,t);return r.top+=l,r.bottom+=l,!!dr(r,n,i,!1)&&(r.top<=i&&r.left<=n&&(p=t,g=r),!0)},s,a),m=!1;if(g){var y=n-g.left<g.right-n,b=y==u;v=p+(b?0:1),d=b?"after":"before",h=y?g.left:g.right}else{u||v!=a&&v!=s||v++,d=0==v?"after":v==t.text.length?"before":Yt(e,o,v-(u?1:0)).bottom+l<=i==u?"after":"before";var w=sr(e,E(r,v,d),"line",t,o);h=w.left,m=i<w.top||i>=w.bottom}return v=L(t.text,v,1),ur(r,v,d,m,n-h)}function gr(e,t,r,n,i,o,l){var s=k(function(s){var a=i[s],u=1!=a.level;return dr(sr(e,E(r,u?a.to:a.from,u?"before":"after"),"line",t,n),o,l,!0)},0,i.length-1),a=i[s];if(s>0){var u=1!=a.level,c=sr(e,E(r,u?a.from:a.to,u?"after":"before"),"line",t,n);dr(c,o,l,!0)&&c.top>l&&(a=i[s-1])}return a}function vr(e,t,r,n,i,o,l){for(var s=fr(e,t,n,l),a=s.begin,u=s.end,c=null,f=null,h=0;h<i.length;h++){var d=i[h];if(!(d.from>=u||d.to<=a)){var p=Yt(e,n,1!=d.level?Math.min(u,d.to)-1:Math.max(a,d.from)).right,g=p<o?o-p+1e9:p-o;(!c||f>g)&&(c=d,f=g)}}return c||(c=i[i.length-1]),c.from<a&&(c={from:a,to:c.to,level:c.level}),c.to>u&&(c={from:c.from,to:u,level:c.level}),c}function mr(e){if(null!=e.cachedTextHeight)return e.cachedTextHeight;if(null==hs){hs=n("pre");for(var i=0;i<49;++i)hs.appendChild(document.createTextNode("x")),hs.appendChild(n("br"));hs.appendChild(document.createTextNode("x"))}r(e.measure,hs);var o=hs.offsetHeight/50;return o>3&&(e.cachedTextHeight=o),t(e.measure),o||1}function yr(e){if(null!=e.cachedCharWidth)return e.cachedCharWidth;var t=n("span","xxxxxxxxxx"),i=n("pre",[t]);r(e.measure,i);var o=t.getBoundingClientRect(),l=(o.right-o.left)/10;return l>2&&(e.cachedCharWidth=l),l||10}function br(e){for(var t=e.display,r={},n={},i=t.gutters.clientLeft,o=t.gutters.firstChild,l=0;o;o=o.nextSibling,++l)r[e.options.gutters[l]]=o.offsetLeft+o.clientLeft+i,n[e.options.gutters[l]]=o.clientWidth;return{fixedPos:wr(t),gutterTotalWidth:t.gutters.offsetWidth,gutterLeft:r,gutterWidth:n,wrapperWidth:t.wrapper.clientWidth}}function wr(e){return e.scroller.getBoundingClientRect().left-e.sizer.getBoundingClientRect().left}function xr(e){var t=mr(e.display),r=e.options.lineWrapping,n=r&&Math.max(5,e.display.scroller.clientWidth/yr(e.display)-3);return function(i){if(ve(e.doc,i))return 0;var o=0;if(i.widgets)for(var l=0;l<i.widgets.length;l++)i.widgets[l].height&&(o+=i.widgets[l].height);return r?o+(Math.ceil(i.text.length/n)||1)*t:o+t}}function Cr(e){var t=e.doc,r=xr(e);t.iter(function(e){var t=r(e);t!=e.height&&A(e,t)})}function Sr(e,t,r,n){var i=e.display;if(!r&&"true"==Ee(t).getAttribute("cm-not-content"))return null;var o,l,s=i.lineSpace.getBoundingClientRect();try{o=t.clientX-s.left,l=t.clientY-s.top}catch(t){return null}var a,u=cr(e,o,l);if(n&&1==u.xRel&&(a=M(e.doc,u.line).text).length==u.ch){var c=f(a,a.length,e.options.tabSize)-a.length;u=E(u.line,Math.max(0,Math.round((o-It(e.display).left)/yr(e.display))-c))}return u}function Lr(e,t){if(t>=e.display.viewTo)return null;if((t-=e.display.viewFrom)<0)return null;for(var r=e.display.view,n=0;n<r.length;n++)if((t-=r[n].size)<0)return n}function kr(e){e.display.input.showSelection(e.display.input.prepareSelection())}function Tr(e,t){void 0===t&&(t=!0);for(var r=e.doc,n={},i=n.cursors=document.createDocumentFragment(),o=n.selection=document.createDocumentFragment(),l=0;l<r.sel.ranges.length;l++)if(t||l!=r.sel.primIndex){var s=r.sel.ranges[l];if(!(s.from().line>=e.display.viewTo||s.to().line<e.display.viewFrom)){var a=s.empty();(a||e.options.showCursorWhenSelecting)&&Mr(e,s.head,i),a||Or(e,s,o)}}return n}function Mr(e,t,r){var i=sr(e,t,"div",null,null,!e.options.singleCursorHeightPerLine),o=r.appendChild(n("div"," ","CodeMirror-cursor"));if(o.style.left=i.left+"px",o.style.top=i.top+"px",o.style.height=Math.max(0,i.bottom-i.top)*e.options.cursorHeight+"px",i.other){var l=r.appendChild(n("div"," ","CodeMirror-cursor CodeMirror-secondarycursor"));l.style.display="",l.style.left=i.other.left+"px",l.style.top=i.other.top+"px",l.style.height=.85*(i.other.bottom-i.other.top)+"px"}}function Nr(e,t){return e.top-t.top||e.left-t.left}function Or(e,t,r){function i(e,t,r,i){t<0&&(t=0),t=Math.round(t),i=Math.round(i),a.appendChild(n("div",null,"CodeMirror-selected","position: absolute; left: "+e+"px;\n                             top: "+t+"px; width: "+(null==r?f-e:r)+"px;\n                             height: "+(i-t)+"px"))}function o(t,r,n){function o(r,n){return lr(e,E(t,r),"div",u,n)}var l,a,u=M(s,t),h=u.text.length,d=Se(u,s.direction);return xe(d,r||0,null==n?h:n,function(t,s,p,g){var v=o(t,"ltr"==p?"left":"right"),m=o(s-1,"ltr"==p?"right":"left");if("ltr"==p){var y=null==r&&0==t?c:v.left,b=null==n&&s==h?f:m.right;m.top-v.top<=3?i(y,m.top,b-y,m.bottom):(i(y,v.top,null,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top),i(c,m.top,m.right,m.bottom))}else if(t<s){var w=null==r&&0==t?f:v.right,x=null==n&&s==h?c:m.left;if(m.top-v.top<=3)i(x,m.top,w-x,m.bottom);else{var C=c;if(g){var S=hr(e,u,null,t).end;C=o(S-(/\s/.test(u.text.charAt(S-1))?2:1),"left").left}i(C,v.top,w-C,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top);var L=null;d.length,L=o(hr(e,u,null,s).begin,"right").right-x,i(x,m.top,L,m.bottom)}}(!l||Nr(v,l)<0)&&(l=v),Nr(m,l)<0&&(l=m),(!a||Nr(v,a)<0)&&(a=v),Nr(m,a)<0&&(a=m)}),{start:l,end:a}}var l=e.display,s=e.doc,a=document.createDocumentFragment(),u=It(e.display),c=u.left,f=Math.max(l.sizerWidth,Rt(e)-l.sizer.offsetLeft)-u.right,h=t.from(),d=t.to();if(h.line==d.line)o(h.line,h.ch,d.ch);else{var p=M(s,h.line),g=M(s,d.line),v=fe(p)==fe(g),m=o(h.line,h.ch,v?p.text.length+1:null).end,y=o(d.line,v?0:null,d.ch).start;v&&(m.top<y.top-2?(i(m.right,m.top,null,m.bottom),i(c,y.top,y.left,y.bottom)):i(m.right,m.top,y.left-m.right,m.bottom)),m.bottom<y.top&&i(c,m.bottom,null,y.top)}r.appendChild(a)}function Ar(e){if(e.state.focused){var t=e.display;clearInterval(t.blinker);var r=!0;t.cursorDiv.style.visibility="",e.options.cursorBlinkRate>0?t.blinker=setInterval(function(){return t.cursorDiv.style.visibility=(r=!r)?"":"hidden"},e.options.cursorBlinkRate):e.options.cursorBlinkRate<0&&(t.cursorDiv.style.visibility="hidden")}}function Wr(e){e.state.focused||(e.display.input.focus(),Hr(e))}function Dr(e){e.state.delayingBlurEvent=!0,setTimeout(function(){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1,Fr(e))},100)}function Hr(e,t){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1),"nocursor"!=e.options.readOnly&&(e.state.focused||(Te(e,"focus",e,t),e.state.focused=!0,s(e.display.wrapper,"CodeMirror-focused"),e.curOp||e.display.selForContextMenu==e.doc.sel||(e.display.input.reset(),ml&&setTimeout(function(){return e.display.input.reset(!0)},20)),e.display.input.receivedFocus()),Ar(e))}function Fr(e,t){e.state.delayingBlurEvent||(e.state.focused&&(Te(e,"blur",e,t),e.state.focused=!1,Fl(e.display.wrapper,"CodeMirror-focused")),clearInterval(e.display.blinker),setTimeout(function(){e.state.focused||(e.display.shift=!1)},150))}function Er(e){for(var t=e.display,r=t.lineDiv.offsetTop,n=0;n<t.view.length;n++){var i=t.view[n],o=void 0;if(!i.hidden){if(gl&&vl<8){var l=i.node.offsetTop+i.node.offsetHeight;o=l-r,r=l}else{var s=i.node.getBoundingClientRect();o=s.bottom-s.top}var a=i.line.height-o;if(o<2&&(o=mr(t)),(a>.005||a<-.005)&&(A(i.line,o),Pr(i.line),i.rest))for(var u=0;u<i.rest.length;u++)Pr(i.rest[u])}}}function Pr(e){if(e.widgets)for(var t=0;t<e.widgets.length;++t)e.widgets[t].height=e.widgets[t].node.parentNode.offsetHeight}function Ir(e,t,r){var n=r&&null!=r.top?Math.max(0,r.top):e.scroller.scrollTop;n=Math.floor(n-Et(e));var i=r&&null!=r.bottom?r.bottom:n+e.wrapper.clientHeight,o=D(t,n),l=D(t,i);if(r&&r.ensure){var s=r.ensure.from.line,a=r.ensure.to.line;s<o?(o=s,l=D(t,ye(M(t,s))+e.wrapper.clientHeight)):Math.min(a,t.lastLine())>=l&&(o=D(t,ye(M(t,a))-e.wrapper.clientHeight),l=a)}return{from:o,to:Math.max(l,o+1)}}function zr(e){var t=e.display,r=t.view;if(t.alignWidgets||t.gutters.firstChild&&e.options.fixedGutter){for(var n=wr(t)-t.scroller.scrollLeft+e.doc.scrollLeft,i=t.gutters.offsetWidth,o=n+"px",l=0;l<r.length;l++)if(!r[l].hidden){e.options.fixedGutter&&(r[l].gutter&&(r[l].gutter.style.left=o),r[l].gutterBackground&&(r[l].gutterBackground.style.left=o));var s=r[l].alignable;if(s)for(var a=0;a<s.length;a++)s[a].style.left=o}e.options.fixedGutter&&(t.gutters.style.left=n+i+"px")}}function Rr(e){if(!e.options.lineNumbers)return!1;var t=e.doc,r=F(e.options,t.first+t.size-1),i=e.display;if(r.length!=i.lineNumChars){var o=i.measure.appendChild(n("div",[n("div",r)],"CodeMirror-linenumber CodeMirror-gutter-elt")),l=o.firstChild.offsetWidth,s=o.offsetWidth-l;return i.lineGutter.style.width="",i.lineNumInnerWidth=Math.max(l,i.lineGutter.offsetWidth-s)+1,i.lineNumWidth=i.lineNumInnerWidth+s,i.lineNumChars=i.lineNumInnerWidth?r.length:-1,i.lineGutter.style.width=i.lineNumWidth+"px",Wn(e),!0}return!1}function Br(e,t){if(!Me(e,"scrollCursorIntoView")){var r=e.display,i=r.sizer.getBoundingClientRect(),o=null;if(t.top+i.top<0?o=!0:t.bottom+i.top>(window.innerHeight||document.documentElement.clientHeight)&&(o=!1),null!=o&&!Sl){var l=n("div","​",null,"position: absolute;\n                         top: "+(t.top-r.viewOffset-Et(e.display))+"px;\n                         height: "+(t.bottom-t.top+zt(e)+r.barHeight)+"px;\n                         left: "+t.left+"px; width: "+Math.max(2,t.right-t.left)+"px;");e.display.lineSpace.appendChild(l),l.scrollIntoView(o),e.display.lineSpace.removeChild(l)}}}function Gr(e,t,r,n){null==n&&(n=0);var i;e.options.lineWrapping||t!=r||(r="before"==(t=t.ch?E(t.line,"before"==t.sticky?t.ch-1:t.ch,"after"):t).sticky?E(t.line,t.ch+1,"before"):t);for(var o=0;o<5;o++){var l=!1,s=sr(e,t),a=r&&r!=t?sr(e,r):s,u=Vr(e,i={left:Math.min(s.left,a.left),top:Math.min(s.top,a.top)-n,right:Math.max(s.left,a.left),bottom:Math.max(s.bottom,a.bottom)+n}),c=e.doc.scrollTop,f=e.doc.scrollLeft;if(null!=u.scrollTop&&(qr(e,u.scrollTop),Math.abs(e.doc.scrollTop-c)>1&&(l=!0)),null!=u.scrollLeft&&(Qr(e,u.scrollLeft),Math.abs(e.doc.scrollLeft-f)>1&&(l=!0)),!l)break}return i}function Ur(e,t){var r=Vr(e,t);null!=r.scrollTop&&qr(e,r.scrollTop),null!=r.scrollLeft&&Qr(e,r.scrollLeft)}function Vr(e,t){var r=e.display,n=mr(e.display);t.top<0&&(t.top=0);var i=e.curOp&&null!=e.curOp.scrollTop?e.curOp.scrollTop:r.scroller.scrollTop,o=Bt(e),l={};t.bottom-t.top>o&&(t.bottom=t.top+o);var s=e.doc.height+Pt(r),a=t.top<n,u=t.bottom>s-n;if(t.top<i)l.scrollTop=a?0:t.top;else if(t.bottom>i+o){var c=Math.min(t.top,(u?s:t.bottom)-o);c!=i&&(l.scrollTop=c)}var f=e.curOp&&null!=e.curOp.scrollLeft?e.curOp.scrollLeft:r.scroller.scrollLeft,h=Rt(e)-(e.options.fixedGutter?r.gutters.offsetWidth:0),d=t.right-t.left>h;return d&&(t.right=t.left+h),t.left<10?l.scrollLeft=0:t.left<f?l.scrollLeft=Math.max(0,t.left-(d?0:10)):t.right>h+f-3&&(l.scrollLeft=t.right+(d?0:10)-h),l}function Kr(e,t){null!=t&&(_r(e),e.curOp.scrollTop=(null==e.curOp.scrollTop?e.doc.scrollTop:e.curOp.scrollTop)+t)}function jr(e){_r(e);var t=e.getCursor();e.curOp.scrollToPos={from:t,to:t,margin:e.options.cursorScrollMargin}}function Xr(e,t,r){null==t&&null==r||_r(e),null!=t&&(e.curOp.scrollLeft=t),null!=r&&(e.curOp.scrollTop=r)}function Yr(e,t){_r(e),e.curOp.scrollToPos=t}function _r(e){var t=e.curOp.scrollToPos;t&&(e.curOp.scrollToPos=null,$r(e,ar(e,t.from),ar(e,t.to),t.margin))}function $r(e,t,r,n){var i=Vr(e,{left:Math.min(t.left,r.left),top:Math.min(t.top,r.top)-n,right:Math.max(t.right,r.right),bottom:Math.max(t.bottom,r.bottom)+n});Xr(e,i.scrollLeft,i.scrollTop)}function qr(e,t){Math.abs(e.doc.scrollTop-t)<2||(fl||On(e,{top:t}),Zr(e,t,!0),fl&&On(e),Cn(e,100))}function Zr(e,t,r){t=Math.min(e.display.scroller.scrollHeight-e.display.scroller.clientHeight,t),(e.display.scroller.scrollTop!=t||r)&&(e.doc.scrollTop=t,e.display.scrollbars.setScrollTop(t),e.display.scroller.scrollTop!=t&&(e.display.scroller.scrollTop=t))}function Qr(e,t,r,n){t=Math.min(t,e.display.scroller.scrollWidth-e.display.scroller.clientWidth),(r?t==e.doc.scrollLeft:Math.abs(e.doc.scrollLeft-t)<2)&&!n||(e.doc.scrollLeft=t,zr(e),e.display.scroller.scrollLeft!=t&&(e.display.scroller.scrollLeft=t),e.display.scrollbars.setScrollLeft(t))}function Jr(e){var t=e.display,r=t.gutters.offsetWidth,n=Math.round(e.doc.height+Pt(e.display));return{clientHeight:t.scroller.clientHeight,viewHeight:t.wrapper.clientHeight,scrollWidth:t.scroller.scrollWidth,clientWidth:t.scroller.clientWidth,viewWidth:t.wrapper.clientWidth,barLeft:e.options.fixedGutter?r:0,docHeight:n,scrollHeight:n+zt(e)+t.barHeight,nativeBarWidth:t.nativeBarWidth,gutterWidth:r}}function en(e,t){t||(t=Jr(e));var r=e.display.barWidth,n=e.display.barHeight;tn(e,t);for(var i=0;i<4&&r!=e.display.barWidth||n!=e.display.barHeight;i++)r!=e.display.barWidth&&e.options.lineWrapping&&Er(e),tn(e,Jr(e)),r=e.display.barWidth,n=e.display.barHeight}function tn(e,t){var r=e.display,n=r.scrollbars.update(t);r.sizer.style.paddingRight=(r.barWidth=n.right)+"px",r.sizer.style.paddingBottom=(r.barHeight=n.bottom)+"px",r.heightForcer.style.borderBottom=n.bottom+"px solid transparent",n.right&&n.bottom?(r.scrollbarFiller.style.display="block",r.scrollbarFiller.style.height=n.bottom+"px",r.scrollbarFiller.style.width=n.right+"px"):r.scrollbarFiller.style.display="",n.bottom&&e.options.coverGutterNextToScrollbar&&e.options.fixedGutter?(r.gutterFiller.style.display="block",r.gutterFiller.style.height=n.bottom+"px",r.gutterFiller.style.width=t.gutterWidth+"px"):r.gutterFiller.style.display=""}function rn(e){e.display.scrollbars&&(e.display.scrollbars.clear(),e.display.scrollbars.addClass&&Fl(e.display.wrapper,e.display.scrollbars.addClass)),e.display.scrollbars=new ws[e.options.scrollbarStyle](function(t){e.display.wrapper.insertBefore(t,e.display.scrollbarFiller),Ql(t,"mousedown",function(){e.state.focused&&setTimeout(function(){return e.display.input.focus()},0)}),t.setAttribute("cm-not-content","true")},function(t,r){"horizontal"==r?Qr(e,t):qr(e,t)},e),e.display.scrollbars.addClass&&s(e.display.wrapper,e.display.scrollbars.addClass)}function nn(e){e.curOp={cm:e,viewChanged:!1,startHeight:e.doc.height,forceUpdate:!1,updateInput:null,typing:!1,changeObjs:null,cursorActivityHandlers:null,cursorActivityCalled:0,selectionChanged:!1,updateMaxLine:!1,scrollLeft:null,scrollTop:null,scrollToPos:null,focus:!1,id:++xs},vt(e.curOp)}function on(e){yt(e.curOp,function(e){for(var t=0;t<e.ops.length;t++)e.ops[t].cm.curOp=null;ln(e)})}function ln(e){for(var t=e.ops,r=0;r<t.length;r++)sn(t[r]);for(var n=0;n<t.length;n++)an(t[n]);for(var i=0;i<t.length;i++)un(t[i]);for(var o=0;o<t.length;o++)cn(t[o]);for(var l=0;l<t.length;l++)fn(t[l])}function sn(e){var t=e.cm,r=t.display;Ln(t),e.updateMaxLine&&we(t),e.mustUpdate=e.viewChanged||e.forceUpdate||null!=e.scrollTop||e.scrollToPos&&(e.scrollToPos.from.line<r.viewFrom||e.scrollToPos.to.line>=r.viewTo)||r.maxLineChanged&&t.options.lineWrapping,e.update=e.mustUpdate&&new Cs(t,e.mustUpdate&&{top:e.scrollTop,ensure:e.scrollToPos},e.forceUpdate)}function an(e){e.updatedDisplay=e.mustUpdate&&Mn(e.cm,e.update)}function un(e){var t=e.cm,r=t.display;e.updatedDisplay&&Er(t),e.barMeasure=Jr(t),r.maxLineChanged&&!t.options.lineWrapping&&(e.adjustWidthTo=Kt(t,r.maxLine,r.maxLine.text.length).left+3,t.display.sizerWidth=e.adjustWidthTo,e.barMeasure.scrollWidth=Math.max(r.scroller.clientWidth,r.sizer.offsetLeft+e.adjustWidthTo+zt(t)+t.display.barWidth),e.maxScrollLeft=Math.max(0,r.sizer.offsetLeft+e.adjustWidthTo-Rt(t))),(e.updatedDisplay||e.selectionChanged)&&(e.preparedSelection=r.input.prepareSelection())}function cn(e){var t=e.cm;null!=e.adjustWidthTo&&(t.display.sizer.style.minWidth=e.adjustWidthTo+"px",e.maxScrollLeft<t.doc.scrollLeft&&Qr(t,Math.min(t.display.scroller.scrollLeft,e.maxScrollLeft),!0),t.display.maxLineChanged=!1);var r=e.focus&&e.focus==l();e.preparedSelection&&t.display.input.showSelection(e.preparedSelection,r),(e.updatedDisplay||e.startHeight!=t.doc.height)&&en(t,e.barMeasure),e.updatedDisplay&&Dn(t,e.barMeasure),e.selectionChanged&&Ar(t),t.state.focused&&e.updateInput&&t.display.input.reset(e.typing),r&&Wr(e.cm)}function fn(e){var t=e.cm,r=t.display,n=t.doc;e.updatedDisplay&&Nn(t,e.update),null==r.wheelStartX||null==e.scrollTop&&null==e.scrollLeft&&!e.scrollToPos||(r.wheelStartX=r.wheelStartY=null),null!=e.scrollTop&&Zr(t,e.scrollTop,e.forceScroll),null!=e.scrollLeft&&Qr(t,e.scrollLeft,!0,!0),e.scrollToPos&&Br(t,Gr(t,U(n,e.scrollToPos.from),U(n,e.scrollToPos.to),e.scrollToPos.margin));var i=e.maybeHiddenMarkers,o=e.maybeUnhiddenMarkers;if(i)for(var l=0;l<i.length;++l)i[l].lines.length||Te(i[l],"hide");if(o)for(var s=0;s<o.length;++s)o[s].lines.length&&Te(o[s],"unhide");r.wrapper.offsetHeight&&(n.scrollTop=t.display.scroller.scrollTop),e.changeObjs&&Te(t,"changes",t,e.changeObjs),e.update&&e.update.finish()}function hn(e,t){if(e.curOp)return t();nn(e);try{return t()}finally{on(e)}}function dn(e,t){return function(){if(e.curOp)return t.apply(e,arguments);nn(e);try{return t.apply(e,arguments)}finally{on(e)}}}function pn(e){return function(){if(this.curOp)return e.apply(this,arguments);nn(this);try{return e.apply(this,arguments)}finally{on(this)}}}function gn(e){return function(){var t=this.cm;if(!t||t.curOp)return e.apply(this,arguments);nn(t);try{return e.apply(this,arguments)}finally{on(t)}}}function vn(e,t,r,n){null==t&&(t=e.doc.first),null==r&&(r=e.doc.first+e.doc.size),n||(n=0);var i=e.display;if(n&&r<i.viewTo&&(null==i.updateLineNumbers||i.updateLineNumbers>t)&&(i.updateLineNumbers=t),e.curOp.viewChanged=!0,t>=i.viewTo)_l&&pe(e.doc,t)<i.viewTo&&yn(e);else if(r<=i.viewFrom)_l&&ge(e.doc,r+n)>i.viewFrom?yn(e):(i.viewFrom+=n,i.viewTo+=n);else if(t<=i.viewFrom&&r>=i.viewTo)yn(e);else if(t<=i.viewFrom){var o=bn(e,r,r+n,1);o?(i.view=i.view.slice(o.index),i.viewFrom=o.lineN,i.viewTo+=n):yn(e)}else if(r>=i.viewTo){var l=bn(e,t,t,-1);l?(i.view=i.view.slice(0,l.index),i.viewTo=l.lineN):yn(e)}else{var s=bn(e,t,t,-1),a=bn(e,r,r+n,1);s&&a?(i.view=i.view.slice(0,s.index).concat(gt(e,s.lineN,a.lineN)).concat(i.view.slice(a.index)),i.viewTo+=n):yn(e)}var u=i.externalMeasured;u&&(r<u.lineN?u.lineN+=n:t<u.lineN+u.size&&(i.externalMeasured=null))}function mn(e,t,r){e.curOp.viewChanged=!0;var n=e.display,i=e.display.externalMeasured;if(i&&t>=i.lineN&&t<i.lineN+i.size&&(n.externalMeasured=null),!(t<n.viewFrom||t>=n.viewTo)){var o=n.view[Lr(e,t)];if(null!=o.node){var l=o.changes||(o.changes=[]);-1==h(l,r)&&l.push(r)}}}function yn(e){e.display.viewFrom=e.display.viewTo=e.doc.first,e.display.view=[],e.display.viewOffset=0}function bn(e,t,r,n){var i,o=Lr(e,t),l=e.display.view;if(!_l||r==e.doc.first+e.doc.size)return{index:o,lineN:r};for(var s=e.display.viewFrom,a=0;a<o;a++)s+=l[a].size;if(s!=t){if(n>0){if(o==l.length-1)return null;i=s+l[o].size-t,o++}else i=s-t;t+=i,r+=i}for(;pe(e.doc,r)!=r;){if(o==(n<0?0:l.length-1))return null;r+=n*l[o-(n<0?1:0)].size,o+=n}return{index:o,lineN:r}}function wn(e,t,r){var n=e.display;0==n.view.length||t>=n.viewTo||r<=n.viewFrom?(n.view=gt(e,t,r),n.viewFrom=t):(n.viewFrom>t?n.view=gt(e,t,n.viewFrom).concat(n.view):n.viewFrom<t&&(n.view=n.view.slice(Lr(e,t))),n.viewFrom=t,n.viewTo<r?n.view=n.view.concat(gt(e,n.viewTo,r)):n.viewTo>r&&(n.view=n.view.slice(0,Lr(e,r)))),n.viewTo=r}function xn(e){for(var t=e.display.view,r=0,n=0;n<t.length;n++){var i=t[n];i.hidden||i.node&&!i.changes||++r}return r}function Cn(e,t){e.doc.highlightFrontier<e.display.viewTo&&e.state.highlight.set(t,u(Sn,e))}function Sn(e){var t=e.doc;if(!(t.highlightFrontier>=e.display.viewTo)){var r=+new Date+e.options.workTime,n=$e(e,t.highlightFrontier),i=[];t.iter(n.line,Math.min(t.first+t.size,e.display.viewTo+500),function(o){if(n.line>=e.display.viewFrom){var l=o.styles,s=o.text.length>e.options.maxHighlightLength?Ke(t.mode,n.state):null,a=Ye(e,o,n,!0);s&&(n.state=s),o.styles=a.styles;var u=o.styleClasses,c=a.classes;c?o.styleClasses=c:u&&(o.styleClasses=null);for(var f=!l||l.length!=o.styles.length||u!=c&&(!u||!c||u.bgClass!=c.bgClass||u.textClass!=c.textClass),h=0;!f&&h<l.length;++h)f=l[h]!=o.styles[h];f&&i.push(n.line),o.stateAfter=n.save(),n.nextLine()}else o.text.length<=e.options.maxHighlightLength&&qe(e,o.text,n),o.stateAfter=n.line%5==0?n.save():null,n.nextLine();if(+new Date>r)return Cn(e,e.options.workDelay),!0}),t.highlightFrontier=n.line,t.modeFrontier=Math.max(t.modeFrontier,n.line),i.length&&hn(e,function(){for(var t=0;t<i.length;t++)mn(e,i[t],"text")})}}function Ln(e){var t=e.display;!t.scrollbarsClipped&&t.scroller.offsetWidth&&(t.nativeBarWidth=t.scroller.offsetWidth-t.scroller.clientWidth,t.heightForcer.style.height=zt(e)+"px",t.sizer.style.marginBottom=-t.nativeBarWidth+"px",t.sizer.style.borderRightWidth=zt(e)+"px",t.scrollbarsClipped=!0)}function kn(e){if(e.hasFocus())return null;var t=l();if(!t||!o(e.display.lineDiv,t))return null;var r={activeElt:t};if(window.getSelection){var n=window.getSelection();n.anchorNode&&n.extend&&o(e.display.lineDiv,n.anchorNode)&&(r.anchorNode=n.anchorNode,r.anchorOffset=n.anchorOffset,r.focusNode=n.focusNode,r.focusOffset=n.focusOffset)}return r}function Tn(e){if(e&&e.activeElt&&e.activeElt!=l()&&(e.activeElt.focus(),e.anchorNode&&o(document.body,e.anchorNode)&&o(document.body,e.focusNode))){var t=window.getSelection(),r=document.createRange();r.setEnd(e.anchorNode,e.anchorOffset),r.collapse(!1),t.removeAllRanges(),t.addRange(r),t.extend(e.focusNode,e.focusOffset)}}function Mn(e,r){var n=e.display,i=e.doc;if(r.editorIsHidden)return yn(e),!1;if(!r.force&&r.visible.from>=n.viewFrom&&r.visible.to<=n.viewTo&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo)&&n.renderedView==n.view&&0==xn(e))return!1;Rr(e)&&(yn(e),r.dims=br(e));var o=i.first+i.size,l=Math.max(r.visible.from-e.options.viewportMargin,i.first),s=Math.min(o,r.visible.to+e.options.viewportMargin);n.viewFrom<l&&l-n.viewFrom<20&&(l=Math.max(i.first,n.viewFrom)),n.viewTo>s&&n.viewTo-s<20&&(s=Math.min(o,n.viewTo)),_l&&(l=pe(e.doc,l),s=ge(e.doc,s));var a=l!=n.viewFrom||s!=n.viewTo||n.lastWrapHeight!=r.wrapperHeight||n.lastWrapWidth!=r.wrapperWidth;wn(e,l,s),n.viewOffset=ye(M(e.doc,n.viewFrom)),e.display.mover.style.top=n.viewOffset+"px";var u=xn(e);if(!a&&0==u&&!r.force&&n.renderedView==n.view&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo))return!1;var c=kn(e);return u>4&&(n.lineDiv.style.display="none"),An(e,n.updateLineNumbers,r.dims),u>4&&(n.lineDiv.style.display=""),n.renderedView=n.view,Tn(c),t(n.cursorDiv),t(n.selectionDiv),n.gutters.style.height=n.sizer.style.minHeight=0,a&&(n.lastWrapHeight=r.wrapperHeight,n.lastWrapWidth=r.wrapperWidth,Cn(e,400)),n.updateLineNumbers=null,!0}function Nn(e,t){for(var r=t.viewport,n=!0;(n&&e.options.lineWrapping&&t.oldDisplayWidth!=Rt(e)||(r&&null!=r.top&&(r={top:Math.min(e.doc.height+Pt(e.display)-Bt(e),r.top)}),t.visible=Ir(e.display,e.doc,r),!(t.visible.from>=e.display.viewFrom&&t.visible.to<=e.display.viewTo)))&&Mn(e,t);n=!1){Er(e);var i=Jr(e);kr(e),en(e,i),Dn(e,i),t.force=!1}t.signal(e,"update",e),e.display.viewFrom==e.display.reportedViewFrom&&e.display.viewTo==e.display.reportedViewTo||(t.signal(e,"viewportChange",e,e.display.viewFrom,e.display.viewTo),e.display.reportedViewFrom=e.display.viewFrom,e.display.reportedViewTo=e.display.viewTo)}function On(e,t){var r=new Cs(e,t);if(Mn(e,r)){Er(e),Nn(e,r);var n=Jr(e);kr(e),en(e,n),Dn(e,n),r.finish()}}function An(e,r,n){function i(t){var r=t.nextSibling;return ml&&Ml&&e.display.currentWheelTarget==t?t.style.display="none":t.parentNode.removeChild(t),r}for(var o=e.display,l=e.options.lineNumbers,s=o.lineDiv,a=s.firstChild,u=o.view,c=o.viewFrom,f=0;f<u.length;f++){var d=u[f];if(d.hidden);else if(d.node&&d.node.parentNode==s){for(;a!=d.node;)a=i(a);var p=l&&null!=r&&r<=c&&d.lineNumber;d.changes&&(h(d.changes,"gutter")>-1&&(p=!1),xt(e,d,c,n)),p&&(t(d.lineNumber),d.lineNumber.appendChild(document.createTextNode(F(e.options,c)))),a=d.node.nextSibling}else{var g=Ot(e,d,c,n);s.insertBefore(g,a)}c+=d.size}for(;a;)a=i(a)}function Wn(e){var t=e.display.gutters.offsetWidth;e.display.sizer.style.marginLeft=t+"px"}function Dn(e,t){e.display.sizer.style.minHeight=t.docHeight+"px",e.display.heightForcer.style.top=t.docHeight+"px",e.display.gutters.style.height=t.docHeight+e.display.barHeight+zt(e)+"px"}function Hn(e){var r=e.display.gutters,i=e.options.gutters;t(r);for(var o=0;o<i.length;++o){var l=i[o],s=r.appendChild(n("div",null,"CodeMirror-gutter "+l));"CodeMirror-linenumbers"==l&&(e.display.lineGutter=s,s.style.width=(e.display.lineNumWidth||1)+"px")}r.style.display=o?"":"none",Wn(e)}function Fn(e){var t=h(e.gutters,"CodeMirror-linenumbers");-1==t&&e.lineNumbers?e.gutters=e.gutters.concat(["CodeMirror-linenumbers"]):t>-1&&!e.lineNumbers&&(e.gutters=e.gutters.slice(0),e.gutters.splice(t,1))}function En(e){var t=e.wheelDeltaX,r=e.wheelDeltaY;return null==t&&e.detail&&e.axis==e.HORIZONTAL_AXIS&&(t=e.detail),null==r&&e.detail&&e.axis==e.VERTICAL_AXIS?r=e.detail:null==r&&(r=e.wheelDelta),{x:t,y:r}}function Pn(e){var t=En(e);return t.x*=Ls,t.y*=Ls,t}function In(e,t){var r=En(t),n=r.x,i=r.y,o=e.display,l=o.scroller,s=l.scrollWidth>l.clientWidth,a=l.scrollHeight>l.clientHeight;if(n&&s||i&&a){if(i&&Ml&&ml)e:for(var u=t.target,c=o.view;u!=l;u=u.parentNode)for(var f=0;f<c.length;f++)if(c[f].node==u){e.display.currentWheelTarget=u;break e}if(n&&!fl&&!wl&&null!=Ls)return i&&a&&qr(e,Math.max(0,l.scrollTop+i*Ls)),Qr(e,Math.max(0,l.scrollLeft+n*Ls)),(!i||i&&a)&&We(t),void(o.wheelStartX=null);if(i&&null!=Ls){var h=i*Ls,d=e.doc.scrollTop,p=d+o.wrapper.clientHeight;h<0?d=Math.max(0,d+h-50):p=Math.min(e.doc.height,p+h+50),On(e,{top:d,bottom:p})}Ss<20&&(null==o.wheelStartX?(o.wheelStartX=l.scrollLeft,o.wheelStartY=l.scrollTop,o.wheelDX=n,o.wheelDY=i,setTimeout(function(){if(null!=o.wheelStartX){var e=l.scrollLeft-o.wheelStartX,t=l.scrollTop-o.wheelStartY,r=t&&o.wheelDY&&t/o.wheelDY||e&&o.wheelDX&&e/o.wheelDX;o.wheelStartX=o.wheelStartY=null,r&&(Ls=(Ls*Ss+r)/(Ss+1),++Ss)}},200)):(o.wheelDX+=n,o.wheelDY+=i))}}function zn(e,t){var r=e[t];e.sort(function(e,t){return P(e.from(),t.from())}),t=h(e,r);for(var n=1;n<e.length;n++){var i=e[n],o=e[n-1];if(P(o.to(),i.from())>=0){var l=B(o.from(),i.from()),s=R(o.to(),i.to()),a=o.empty()?i.from()==i.head:o.from()==o.head;n<=t&&--t,e.splice(--n,2,new Ts(a?s:l,a?l:s))}}return new ks(e,t)}function Rn(e,t){return new ks([new Ts(e,t||e)],0)}function Bn(e){return e.text?E(e.from.line+e.text.length-1,g(e.text).length+(1==e.text.length?e.from.ch:0)):e.to}function Gn(e,t){if(P(e,t.from)<0)return e;if(P(e,t.to)<=0)return Bn(t);var r=e.line+t.text.length-(t.to.line-t.from.line)-1,n=e.ch;return e.line==t.to.line&&(n+=Bn(t).ch-t.to.ch),E(r,n)}function Un(e,t){for(var r=[],n=0;n<e.sel.ranges.length;n++){var i=e.sel.ranges[n];r.push(new Ts(Gn(i.anchor,t),Gn(i.head,t)))}return zn(r,e.sel.primIndex)}function Vn(e,t,r){return e.line==t.line?E(r.line,e.ch-t.ch+r.ch):E(r.line+(e.line-t.line),e.ch)}function Kn(e,t,r){for(var n=[],i=E(e.first,0),o=i,l=0;l<t.length;l++){var s=t[l],a=Vn(s.from,i,o),u=Vn(Bn(s),i,o);if(i=s.to,o=u,"around"==r){var c=e.sel.ranges[l],f=P(c.head,c.anchor)<0;n[l]=new Ts(f?u:a,f?a:u)}else n[l]=new Ts(a,a)}return new ks(n,e.sel.primIndex)}function jn(e){e.doc.mode=Ue(e.options,e.doc.modeOption),Xn(e)}function Xn(e){e.doc.iter(function(e){e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null)}),e.doc.modeFrontier=e.doc.highlightFrontier=e.doc.first,Cn(e,100),e.state.modeGen++,e.curOp&&vn(e)}function Yn(e,t){return 0==t.from.ch&&0==t.to.ch&&""==g(t.text)&&(!e.cm||e.cm.options.wholeLineUpdateBefore)}function _n(e,t,r,n){function i(e){return r?r[e]:null}function o(e,r,i){it(e,r,i,n),bt(e,"change",e,t)}function l(e,t){for(var r=[],o=e;o<t;++o)r.push(new fs(u[o],i(o),n));return r}var s=t.from,a=t.to,u=t.text,c=M(e,s.line),f=M(e,a.line),h=g(u),d=i(u.length-1),p=a.line-s.line;if(t.full)e.insert(0,l(0,u.length)),e.remove(u.length,e.size-u.length);else if(Yn(e,t)){var v=l(0,u.length-1);o(f,f.text,d),p&&e.remove(s.line,p),v.length&&e.insert(s.line,v)}else if(c==f)if(1==u.length)o(c,c.text.slice(0,s.ch)+h+c.text.slice(a.ch),d);else{var m=l(1,u.length-1);m.push(new fs(h+c.text.slice(a.ch),d,n)),o(c,c.text.slice(0,s.ch)+u[0],i(0)),e.insert(s.line+1,m)}else if(1==u.length)o(c,c.text.slice(0,s.ch)+u[0]+f.text.slice(a.ch),i(0)),e.remove(s.line+1,p);else{o(c,c.text.slice(0,s.ch)+u[0],i(0)),o(f,h+f.text.slice(a.ch),d);var y=l(1,u.length-1);p>1&&e.remove(s.line+1,p-1),e.insert(s.line+1,y)}bt(e,"change",e,t)}function $n(e,t,r){function n(e,i,o){if(e.linked)for(var l=0;l<e.linked.length;++l){var s=e.linked[l];if(s.doc!=i){var a=o&&s.sharedHist;r&&!a||(t(s.doc,a),n(s.doc,e,a))}}}n(e,null,!0)}function qn(e,t){if(t.cm)throw new Error("This document is already in use.");e.doc=t,t.cm=e,Cr(e),jn(e),Zn(e),e.options.lineWrapping||we(e),e.options.mode=t.modeOption,vn(e)}function Zn(e){("rtl"==e.doc.direction?s:Fl)(e.display.lineDiv,"CodeMirror-rtl")}function Qn(e){hn(e,function(){Zn(e),vn(e)})}function Jn(e){this.done=[],this.undone=[],this.undoDepth=1/0,this.lastModTime=this.lastSelTime=0,this.lastOp=this.lastSelOp=null,this.lastOrigin=this.lastSelOrigin=null,this.generation=this.maxGeneration=e||1}function ei(e,t){var r={from:z(t.from),to:Bn(t),text:N(e,t.from,t.to)};return si(e,r,t.from.line,t.to.line+1),$n(e,function(e){return si(e,r,t.from.line,t.to.line+1)},!0),r}function ti(e){for(;e.length&&g(e).ranges;)e.pop()}function ri(e,t){return t?(ti(e.done),g(e.done)):e.done.length&&!g(e.done).ranges?g(e.done):e.done.length>1&&!e.done[e.done.length-2].ranges?(e.done.pop(),g(e.done)):void 0}function ni(e,t,r,n){var i=e.history;i.undone.length=0;var o,l,s=+new Date;if((i.lastOp==n||i.lastOrigin==t.origin&&t.origin&&("+"==t.origin.charAt(0)&&e.cm&&i.lastModTime>s-e.cm.options.historyEventDelay||"*"==t.origin.charAt(0)))&&(o=ri(i,i.lastOp==n)))l=g(o.changes),0==P(t.from,t.to)&&0==P(t.from,l.to)?l.to=Bn(t):o.changes.push(ei(e,t));else{var a=g(i.done);for(a&&a.ranges||li(e.sel,i.done),o={changes:[ei(e,t)],generation:i.generation},i.done.push(o);i.done.length>i.undoDepth;)i.done.shift(),i.done[0].ranges||i.done.shift()}i.done.push(r),i.generation=++i.maxGeneration,i.lastModTime=i.lastSelTime=s,i.lastOp=i.lastSelOp=n,i.lastOrigin=i.lastSelOrigin=t.origin,l||Te(e,"historyAdded")}function ii(e,t,r,n){var i=t.charAt(0);return"*"==i||"+"==i&&r.ranges.length==n.ranges.length&&r.somethingSelected()==n.somethingSelected()&&new Date-e.history.lastSelTime<=(e.cm?e.cm.options.historyEventDelay:500)}function oi(e,t,r,n){var i=e.history,o=n&&n.origin;r==i.lastSelOp||o&&i.lastSelOrigin==o&&(i.lastModTime==i.lastSelTime&&i.lastOrigin==o||ii(e,o,g(i.done),t))?i.done[i.done.length-1]=t:li(t,i.done),i.lastSelTime=+new Date,i.lastSelOrigin=o,i.lastSelOp=r,n&&!1!==n.clearRedo&&ti(i.undone)}function li(e,t){var r=g(t);r&&r.ranges&&r.equals(e)||t.push(e)}function si(e,t,r,n){var i=t["spans_"+e.id],o=0;e.iter(Math.max(e.first,r),Math.min(e.first+e.size,n),function(r){r.markedSpans&&((i||(i=t["spans_"+e.id]={}))[o]=r.markedSpans),++o})}function ai(e){if(!e)return null;for(var t,r=0;r<e.length;++r)e[r].marker.explicitlyCleared?t||(t=e.slice(0,r)):t&&t.push(e[r]);return t?t.length?t:null:e}function ui(e,t){var r=t["spans_"+e.id];if(!r)return null;for(var n=[],i=0;i<t.text.length;++i)n.push(ai(r[i]));return n}function ci(e,t){var r=ui(e,t),n=J(e,t);if(!r)return n;if(!n)return r;for(var i=0;i<r.length;++i){var o=r[i],l=n[i];if(o&&l)e:for(var s=0;s<l.length;++s){for(var a=l[s],u=0;u<o.length;++u)if(o[u].marker==a.marker)continue e;o.push(a)}else l&&(r[i]=l)}return r}function fi(e,t,r){for(var n=[],i=0;i<e.length;++i){var o=e[i];if(o.ranges)n.push(r?ks.prototype.deepCopy.call(o):o);else{var l=o.changes,s=[];n.push({changes:s});for(var a=0;a<l.length;++a){var u=l[a],c=void 0;if(s.push({from:u.from,to:u.to,text:u.text}),t)for(var f in u)(c=f.match(/^spans_(\d+)$/))&&h(t,Number(c[1]))>-1&&(g(s)[f]=u[f],delete u[f])}}}return n}function hi(e,t,r,n){if(n){var i=e.anchor;if(r){var o=P(t,i)<0;o!=P(r,i)<0?(i=t,t=r):o!=P(t,r)<0&&(t=r)}return new Ts(i,t)}return new Ts(r||t,t)}function di(e,t,r,n,i){null==i&&(i=e.cm&&(e.cm.display.shift||e.extend)),bi(e,new ks([hi(e.sel.primary(),t,r,i)],0),n)}function pi(e,t,r){for(var n=[],i=e.cm&&(e.cm.display.shift||e.extend),o=0;o<e.sel.ranges.length;o++)n[o]=hi(e.sel.ranges[o],t[o],null,i);bi(e,zn(n,e.sel.primIndex),r)}function gi(e,t,r,n){var i=e.sel.ranges.slice(0);i[t]=r,bi(e,zn(i,e.sel.primIndex),n)}function vi(e,t,r,n){bi(e,Rn(t,r),n)}function mi(e,t,r){var n={ranges:t.ranges,update:function(t){var r=this;this.ranges=[];for(var n=0;n<t.length;n++)r.ranges[n]=new Ts(U(e,t[n].anchor),U(e,t[n].head))},origin:r&&r.origin};return Te(e,"beforeSelectionChange",e,n),e.cm&&Te(e.cm,"beforeSelectionChange",e.cm,n),n.ranges!=t.ranges?zn(n.ranges,n.ranges.length-1):t}function yi(e,t,r){var n=e.history.done,i=g(n);i&&i.ranges?(n[n.length-1]=t,wi(e,t,r)):bi(e,t,r)}function bi(e,t,r){wi(e,t,r),oi(e,e.sel,e.cm?e.cm.curOp.id:NaN,r)}function wi(e,t,r){(Oe(e,"beforeSelectionChange")||e.cm&&Oe(e.cm,"beforeSelectionChange"))&&(t=mi(e,t,r)),xi(e,Si(e,t,r&&r.bias||(P(t.primary().head,e.sel.primary().head)<0?-1:1),!0)),r&&!1===r.scroll||!e.cm||jr(e.cm)}function xi(e,t){t.equals(e.sel)||(e.sel=t,e.cm&&(e.cm.curOp.updateInput=e.cm.curOp.selectionChanged=!0,Ne(e.cm)),bt(e,"cursorActivity",e))}function Ci(e){xi(e,Si(e,e.sel,null,!1))}function Si(e,t,r,n){for(var i,o=0;o<t.ranges.length;o++){var l=t.ranges[o],s=t.ranges.length==e.sel.ranges.length&&e.sel.ranges[o],a=ki(e,l.anchor,s&&s.anchor,r,n),u=ki(e,l.head,s&&s.head,r,n);(i||a!=l.anchor||u!=l.head)&&(i||(i=t.ranges.slice(0,o)),i[o]=new Ts(a,u))}return i?zn(i,t.primIndex):t}function Li(e,t,r,n,i){var o=M(e,t.line);if(o.markedSpans)for(var l=0;l<o.markedSpans.length;++l){var s=o.markedSpans[l],a=s.marker;if((null==s.from||(a.inclusiveLeft?s.from<=t.ch:s.from<t.ch))&&(null==s.to||(a.inclusiveRight?s.to>=t.ch:s.to>t.ch))){if(i&&(Te(a,"beforeCursorEnter"),a.explicitlyCleared)){if(o.markedSpans){--l;continue}break}if(!a.atomic)continue;if(r){var u=a.find(n<0?1:-1),c=void 0;if((n<0?a.inclusiveRight:a.inclusiveLeft)&&(u=Ti(e,u,-n,u&&u.line==t.line?o:null)),u&&u.line==t.line&&(c=P(u,r))&&(n<0?c<0:c>0))return Li(e,u,t,n,i)}var f=a.find(n<0?-1:1);return(n<0?a.inclusiveLeft:a.inclusiveRight)&&(f=Ti(e,f,n,f.line==t.line?o:null)),f?Li(e,f,t,n,i):null}}return t}function ki(e,t,r,n,i){var o=n||1,l=Li(e,t,r,o,i)||!i&&Li(e,t,r,o,!0)||Li(e,t,r,-o,i)||!i&&Li(e,t,r,-o,!0);return l||(e.cantEdit=!0,E(e.first,0))}function Ti(e,t,r,n){return r<0&&0==t.ch?t.line>e.first?U(e,E(t.line-1)):null:r>0&&t.ch==(n||M(e,t.line)).text.length?t.line<e.first+e.size-1?E(t.line+1,0):null:new E(t.line,t.ch+r)}function Mi(e){e.setSelection(E(e.firstLine(),0),E(e.lastLine()),Gl)}function Ni(e,t,r){var n={canceled:!1,from:t.from,to:t.to,text:t.text,origin:t.origin,cancel:function(){return n.canceled=!0}};return r&&(n.update=function(t,r,i,o){t&&(n.from=U(e,t)),r&&(n.to=U(e,r)),i&&(n.text=i),void 0!==o&&(n.origin=o)}),Te(e,"beforeChange",e,n),e.cm&&Te(e.cm,"beforeChange",e.cm,n),n.canceled?null:{from:n.from,to:n.to,text:n.text,origin:n.origin}}function Oi(e,t,r){if(e.cm){if(!e.cm.curOp)return dn(e.cm,Oi)(e,t,r);if(e.cm.state.suppressEdits)return}if(!(Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"))||(t=Ni(e,t,!0))){var n=Yl&&!r&&te(e,t.from,t.to);if(n)for(var i=n.length-1;i>=0;--i)Ai(e,{from:n[i].from,to:n[i].to,text:i?[""]:t.text,origin:t.origin});else Ai(e,t)}}function Ai(e,t){if(1!=t.text.length||""!=t.text[0]||0!=P(t.from,t.to)){var r=Un(e,t);ni(e,t,r,e.cm?e.cm.curOp.id:NaN),Hi(e,t,r,J(e,t));var n=[];$n(e,function(e,r){r||-1!=h(n,e.history)||(zi(e.history,t),n.push(e.history)),Hi(e,t,null,J(e,t))})}}function Wi(e,t,r){if(!e.cm||!e.cm.state.suppressEdits||r){for(var n,i=e.history,o=e.sel,l="undo"==t?i.done:i.undone,s="undo"==t?i.undone:i.done,a=0;a<l.length&&(n=l[a],r?!n.ranges||n.equals(e.sel):n.ranges);a++);if(a!=l.length){for(i.lastOrigin=i.lastSelOrigin=null;(n=l.pop()).ranges;){if(li(n,s),r&&!n.equals(e.sel))return void bi(e,n,{clearRedo:!1});o=n}var u=[];li(o,s),s.push({changes:u,generation:i.generation}),i.generation=n.generation||++i.maxGeneration;for(var c=Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"),f=n.changes.length-1;f>=0;--f){var d=function(r){var i=n.changes[r];if(i.origin=t,c&&!Ni(e,i,!1))return l.length=0,{};u.push(ei(e,i));var o=r?Un(e,i):g(l);Hi(e,i,o,ci(e,i)),!r&&e.cm&&e.cm.scrollIntoView({from:i.from,to:Bn(i)});var s=[];$n(e,function(e,t){t||-1!=h(s,e.history)||(zi(e.history,i),s.push(e.history)),Hi(e,i,null,ci(e,i))})}(f);if(d)return d.v}}}}function Di(e,t){if(0!=t&&(e.first+=t,e.sel=new ks(v(e.sel.ranges,function(e){return new Ts(E(e.anchor.line+t,e.anchor.ch),E(e.head.line+t,e.head.ch))}),e.sel.primIndex),e.cm)){vn(e.cm,e.first,e.first-t,t);for(var r=e.cm.display,n=r.viewFrom;n<r.viewTo;n++)mn(e.cm,n,"gutter")}}function Hi(e,t,r,n){if(e.cm&&!e.cm.curOp)return dn(e.cm,Hi)(e,t,r,n);if(t.to.line<e.first)Di(e,t.text.length-1-(t.to.line-t.from.line));else if(!(t.from.line>e.lastLine())){if(t.from.line<e.first){var i=t.text.length-1-(e.first-t.from.line);Di(e,i),t={from:E(e.first,0),to:E(t.to.line+i,t.to.ch),text:[g(t.text)],origin:t.origin}}var o=e.lastLine();t.to.line>o&&(t={from:t.from,to:E(o,M(e,o).text.length),text:[t.text[0]],origin:t.origin}),t.removed=N(e,t.from,t.to),r||(r=Un(e,t)),e.cm?Fi(e.cm,t,n):_n(e,t,n),wi(e,r,Gl)}}function Fi(e,t,r){var n=e.doc,i=e.display,o=t.from,l=t.to,s=!1,a=o.line;e.options.lineWrapping||(a=W(fe(M(n,o.line))),n.iter(a,l.line+1,function(e){if(e==i.maxLine)return s=!0,!0})),n.sel.contains(t.from,t.to)>-1&&Ne(e),_n(n,t,r,xr(e)),e.options.lineWrapping||(n.iter(a,o.line+t.text.length,function(e){var t=be(e);t>i.maxLineLength&&(i.maxLine=e,i.maxLineLength=t,i.maxLineChanged=!0,s=!1)}),s&&(e.curOp.updateMaxLine=!0)),nt(n,o.line),Cn(e,400);var u=t.text.length-(l.line-o.line)-1;t.full?vn(e):o.line!=l.line||1!=t.text.length||Yn(e.doc,t)?vn(e,o.line,l.line+1,u):mn(e,o.line,"text");var c=Oe(e,"changes"),f=Oe(e,"change");if(f||c){var h={from:o,to:l,text:t.text,removed:t.removed,origin:t.origin};f&&bt(e,"change",e,h),c&&(e.curOp.changeObjs||(e.curOp.changeObjs=[])).push(h)}e.display.selForContextMenu=null}function Ei(e,t,r,n,i){if(n||(n=r),P(n,r)<0){var o;r=(o=[n,r])[0],n=o[1]}"string"==typeof t&&(t=e.splitLines(t)),Oi(e,{from:r,to:n,text:t,origin:i})}function Pi(e,t,r,n){r<e.line?e.line+=n:t<e.line&&(e.line=t,e.ch=0)}function Ii(e,t,r,n){for(var i=0;i<e.length;++i){var o=e[i],l=!0;if(o.ranges){o.copied||((o=e[i]=o.deepCopy()).copied=!0);for(var s=0;s<o.ranges.length;s++)Pi(o.ranges[s].anchor,t,r,n),Pi(o.ranges[s].head,t,r,n)}else{for(var a=0;a<o.changes.length;++a){var u=o.changes[a];if(r<u.from.line)u.from=E(u.from.line+n,u.from.ch),u.to=E(u.to.line+n,u.to.ch);else if(t<=u.to.line){l=!1;break}}l||(e.splice(0,i+1),i=0)}}}function zi(e,t){var r=t.from.line,n=t.to.line,i=t.text.length-(n-r)-1;Ii(e.done,r,n,i),Ii(e.undone,r,n,i)}function Ri(e,t,r,n){var i=t,o=t;return"number"==typeof t?o=M(e,G(e,t)):i=W(t),null==i?null:(n(o,i)&&e.cm&&mn(e.cm,i,r),o)}function Bi(e){var t=this;this.lines=e,this.parent=null;for(var r=0,n=0;n<e.length;++n)e[n].parent=t,r+=e[n].height;this.height=r}function Gi(e){var t=this;this.children=e;for(var r=0,n=0,i=0;i<e.length;++i){var o=e[i];r+=o.chunkSize(),n+=o.height,o.parent=t}this.size=r,this.height=n,this.parent=null}function Ui(e,t,r){ye(t)<(e.curOp&&e.curOp.scrollTop||e.doc.scrollTop)&&Kr(e,r)}function Vi(e,t,r,n){var i=new Ms(e,r,n),o=e.cm;return o&&i.noHScroll&&(o.display.alignWidgets=!0),Ri(e,t,"widget",function(t){var r=t.widgets||(t.widgets=[]);if(null==i.insertAt?r.push(i):r.splice(Math.min(r.length-1,Math.max(0,i.insertAt)),0,i),i.line=t,o&&!ve(e,t)){var n=ye(t)<e.scrollTop;A(t,t.height+Ht(i)),n&&Kr(o,i.height),o.curOp.forceUpdate=!0}return!0}),bt(o,"lineWidgetAdded",o,i,"number"==typeof t?t:W(t)),i}function Ki(e,t,r,n,o){if(n&&n.shared)return ji(e,t,r,n,o);if(e.cm&&!e.cm.curOp)return dn(e.cm,Ki)(e,t,r,n,o);var l=new Os(e,o),s=P(t,r);if(n&&c(n,l,!1),s>0||0==s&&!1!==l.clearWhenEmpty)return l;if(l.replacedWith&&(l.collapsed=!0,l.widgetNode=i("span",[l.replacedWith],"CodeMirror-widget"),n.handleMouseEvents||l.widgetNode.setAttribute("cm-ignore-events","true"),n.insertLeft&&(l.widgetNode.insertLeft=!0)),l.collapsed){if(ce(e,t.line,t,r,l)||t.line!=r.line&&ce(e,r.line,t,r,l))throw new Error("Inserting collapsed marker partially overlapping an existing one");X()}l.addToHistory&&ni(e,{from:t,to:r,origin:"markText"},e.sel,NaN);var a,u=t.line,f=e.cm;if(e.iter(u,r.line+1,function(e){f&&l.collapsed&&!f.options.lineWrapping&&fe(e)==f.display.maxLine&&(a=!0),l.collapsed&&u!=t.line&&A(e,0),q(e,new Y(l,u==t.line?t.ch:null,u==r.line?r.ch:null)),++u}),l.collapsed&&e.iter(t.line,r.line+1,function(t){ve(e,t)&&A(t,0)}),l.clearOnEnter&&Ql(l,"beforeCursorEnter",function(){return l.clear()}),l.readOnly&&(j(),(e.history.done.length||e.history.undone.length)&&e.clearHistory()),l.collapsed&&(l.id=++Ns,l.atomic=!0),f){if(a&&(f.curOp.updateMaxLine=!0),l.collapsed)vn(f,t.line,r.line+1);else if(l.className||l.title||l.startStyle||l.endStyle||l.css)for(var h=t.line;h<=r.line;h++)mn(f,h,"text");l.atomic&&Ci(f.doc),bt(f,"markerAdded",f,l)}return l}function ji(e,t,r,n,i){(n=c(n)).shared=!1;var o=[Ki(e,t,r,n,i)],l=o[0],s=n.widgetNode;return $n(e,function(e){s&&(n.widgetNode=s.cloneNode(!0)),o.push(Ki(e,U(e,t),U(e,r),n,i));for(var a=0;a<e.linked.length;++a)if(e.linked[a].isParent)return;l=g(o)}),new As(o,l)}function Xi(e){return e.findMarks(E(e.first,0),e.clipPos(E(e.lastLine())),function(e){return e.parent})}function Yi(e,t){for(var r=0;r<t.length;r++){var n=t[r],i=n.find(),o=e.clipPos(i.from),l=e.clipPos(i.to);if(P(o,l)){var s=Ki(e,o,l,n.primary,n.primary.type);n.markers.push(s),s.parent=n}}}function _i(e){for(var t=0;t<e.length;t++)!function(t){var r=e[t],n=[r.primary.doc];$n(r.primary.doc,function(e){return n.push(e)});for(var i=0;i<r.markers.length;i++){var o=r.markers[i];-1==h(n,o.doc)&&(o.parent=null,r.markers.splice(i--,1))}}(t)}function $i(e){var t=this;if(Qi(t),!Me(t,e)&&!Ft(t.display,e)){We(e),gl&&(Hs=+new Date);var r=Sr(t,e,!0),n=e.dataTransfer.files;if(r&&!t.isReadOnly())if(n&&n.length&&window.FileReader&&window.File)for(var i=n.length,o=Array(i),l=0,s=0;s<i;++s)!function(e,n){if(!t.options.allowDropFileTypes||-1!=h(t.options.allowDropFileTypes,e.type)){var s=new FileReader;s.onload=dn(t,function(){var e=s.result;if(/[\x00-\x08\x0e-\x1f]{2}/.test(e)&&(e=""),o[n]=e,++l==i){var a={from:r=U(t.doc,r),to:r,text:t.doc.splitLines(o.join(t.doc.lineSeparator())),origin:"paste"};Oi(t.doc,a),yi(t.doc,Rn(r,Bn(a)))}}),s.readAsText(e)}}(n[s],s);else{if(t.state.draggingText&&t.doc.sel.contains(r)>-1)return t.state.draggingText(e),void setTimeout(function(){return t.display.input.focus()},20);try{var a=e.dataTransfer.getData("Text");if(a){var u;if(t.state.draggingText&&!t.state.draggingText.copy&&(u=t.listSelections()),wi(t.doc,Rn(r,r)),u)for(var c=0;c<u.length;++c)Ei(t.doc,"",u[c].anchor,u[c].head,"drag");t.replaceSelection(a,"around","paste"),t.display.input.focus()}}catch(e){}}}}function qi(e,t){if(gl&&(!e.state.draggingText||+new Date-Hs<100))Fe(t);else if(!Me(e,t)&&!Ft(e.display,t)&&(t.dataTransfer.setData("Text",e.getSelection()),t.dataTransfer.effectAllowed="copyMove",t.dataTransfer.setDragImage&&!xl)){var r=n("img",null,null,"position: fixed; left: 0; top: 0;");r.src="data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==",wl&&(r.width=r.height=1,e.display.wrapper.appendChild(r),r._top=r.offsetTop),t.dataTransfer.setDragImage(r,0,0),wl&&r.parentNode.removeChild(r)}}function Zi(e,t){var i=Sr(e,t);if(i){var o=document.createDocumentFragment();Mr(e,i,o),e.display.dragCursor||(e.display.dragCursor=n("div",null,"CodeMirror-cursors CodeMirror-dragcursors"),e.display.lineSpace.insertBefore(e.display.dragCursor,e.display.cursorDiv)),r(e.display.dragCursor,o)}}function Qi(e){e.display.dragCursor&&(e.display.lineSpace.removeChild(e.display.dragCursor),e.display.dragCursor=null)}function Ji(e){if(document.getElementsByClassName)for(var t=document.getElementsByClassName("CodeMirror"),r=0;r<t.length;r++){var n=t[r].CodeMirror;n&&e(n)}}function eo(){Fs||(to(),Fs=!0)}function to(){var e;Ql(window,"resize",function(){null==e&&(e=setTimeout(function(){e=null,Ji(ro)},100))}),Ql(window,"blur",function(){return Ji(Fr)})}function ro(e){var t=e.display;t.lastWrapHeight==t.wrapper.clientHeight&&t.lastWrapWidth==t.wrapper.clientWidth||(t.cachedCharWidth=t.cachedTextHeight=t.cachedPaddingH=null,t.scrollbarsClipped=!1,e.setSize())}function no(e){var t=e.split(/-(?!$)/);e=t[t.length-1];for(var r,n,i,o,l=0;l<t.length-1;l++){var s=t[l];if(/^(cmd|meta|m)$/i.test(s))o=!0;else if(/^a(lt)?$/i.test(s))r=!0;else if(/^(c|ctrl|control)$/i.test(s))n=!0;else{if(!/^s(hift)?$/i.test(s))throw new Error("Unrecognized modifier name: "+s);i=!0}}return r&&(e="Alt-"+e),n&&(e="Ctrl-"+e),o&&(e="Cmd-"+e),i&&(e="Shift-"+e),e}function io(e){var t={};for(var r in e)if(e.hasOwnProperty(r)){var n=e[r];if(/^(name|fallthrough|(de|at)tach)$/.test(r))continue;if("..."==n){delete e[r];continue}for(var i=v(r.split(" "),no),o=0;o<i.length;o++){var l=void 0,s=void 0;o==i.length-1?(s=i.join(" "),l=n):(s=i.slice(0,o+1).join(" "),l="...");var a=t[s];if(a){if(a!=l)throw new Error("Inconsistent bindings for "+s)}else t[s]=l}delete e[r]}for(var u in t)e[u]=t[u];return e}function oo(e,t,r,n){var i=(t=uo(t)).call?t.call(e,n):t[e];if(!1===i)return"nothing";if("..."===i)return"multi";if(null!=i&&r(i))return"handled";if(t.fallthrough){if("[object Array]"!=Object.prototype.toString.call(t.fallthrough))return oo(e,t.fallthrough,r,n);for(var o=0;o<t.fallthrough.length;o++){var l=oo(e,t.fallthrough[o],r,n);if(l)return l}}}function lo(e){var t="string"==typeof e?e:Es[e.keyCode];return"Ctrl"==t||"Alt"==t||"Shift"==t||"Mod"==t}function so(e,t,r){var n=e;return t.altKey&&"Alt"!=n&&(e="Alt-"+e),(Dl?t.metaKey:t.ctrlKey)&&"Ctrl"!=n&&(e="Ctrl-"+e),(Dl?t.ctrlKey:t.metaKey)&&"Cmd"!=n&&(e="Cmd-"+e),!r&&t.shiftKey&&"Shift"!=n&&(e="Shift-"+e),e}function ao(e,t){if(wl&&34==e.keyCode&&e.char)return!1;var r=Es[e.keyCode];return null!=r&&!e.altGraphKey&&so(r,e,t)}function uo(e){return"string"==typeof e?Rs[e]:e}function co(e,t){for(var r=e.doc.sel.ranges,n=[],i=0;i<r.length;i++){for(var o=t(r[i]);n.length&&P(o.from,g(n).to)<=0;){var l=n.pop();if(P(l.from,o.from)<0){o.from=l.from;break}}n.push(o)}hn(e,function(){for(var t=n.length-1;t>=0;t--)Ei(e.doc,"",n[t].from,n[t].to,"+delete");jr(e)})}function fo(e,t,r){var n=L(e.text,t+r,r);return n<0||n>e.text.length?null:n}function ho(e,t,r){var n=fo(e,t.ch,r);return null==n?null:new E(t.line,n,r<0?"after":"before")}function po(e,t,r,n,i){if(e){var o=Se(r,t.doc.direction);if(o){var l,s=i<0?g(o):o[0],a=i<0==(1==s.level)?"after":"before";if(s.level>0){var u=Xt(t,r);l=i<0?r.text.length-1:0;var c=Yt(t,u,l).top;l=k(function(e){return Yt(t,u,e).top==c},i<0==(1==s.level)?s.from:s.to-1,l),"before"==a&&(l=fo(r,l,1))}else l=i<0?s.to:s.from;return new E(n,l,a)}}return new E(n,i<0?r.text.length:0,i<0?"before":"after")}function go(e,t,r,n){var i=Se(t,e.doc.direction);if(!i)return ho(t,r,n);r.ch>=t.text.length?(r.ch=t.text.length,r.sticky="before"):r.ch<=0&&(r.ch=0,r.sticky="after");var o=Ce(i,r.ch,r.sticky),l=i[o];if("ltr"==e.doc.direction&&l.level%2==0&&(n>0?l.to>r.ch:l.from<r.ch))return ho(t,r,n);var s,a=function(e,r){return fo(t,e instanceof E?e.ch:e,r)},u=function(r){return e.options.lineWrapping?(s=s||Xt(e,t),hr(e,t,s,r)):{begin:0,end:t.text.length}},c=u("before"==r.sticky?a(r,-1):r.ch);if("rtl"==e.doc.direction||1==l.level){var f=1==l.level==n<0,h=a(r,f?1:-1);if(null!=h&&(f?h<=l.to&&h<=c.end:h>=l.from&&h>=c.begin)){var d=f?"before":"after";return new E(r.line,h,d)}}var p=function(e,t,n){for(var o=function(e,t){return t?new E(r.line,a(e,1),"before"):new E(r.line,e,"after")};e>=0&&e<i.length;e+=t){var l=i[e],s=t>0==(1!=l.level),u=s?n.begin:a(n.end,-1);if(l.from<=u&&u<l.to)return o(u,s);if(u=s?l.from:a(l.to,-1),n.begin<=u&&u<n.end)return o(u,s)}},g=p(o+n,n,c);if(g)return g;var v=n>0?c.end:a(c.begin,-1);return null==v||n>0&&v==t.text.length||!(g=p(n>0?0:i.length-1,n,u(v)))?null:g}function vo(e,t){var r=M(e.doc,t),n=fe(r);return n!=r&&(t=W(n)),po(!0,e,n,t,1)}function mo(e,t){var r=M(e.doc,t),n=he(r);return n!=r&&(t=W(n)),po(!0,e,r,t,-1)}function yo(e,t){var r=vo(e,t.line),n=M(e.doc,r.line),i=Se(n,e.doc.direction);if(!i||0==i[0].level){var o=Math.max(0,n.text.search(/\S/)),l=t.line==r.line&&t.ch<=o&&t.ch;return E(r.line,l?0:o,r.sticky)}return r}function bo(e,t,r){if("string"==typeof t&&!(t=Bs[t]))return!1;e.display.input.ensurePolled();var n=e.display.shift,i=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),r&&(e.display.shift=!1),i=t(e)!=Bl}finally{e.display.shift=n,e.state.suppressEdits=!1}return i}function wo(e,t,r){for(var n=0;n<e.state.keyMaps.length;n++){var i=oo(t,e.state.keyMaps[n],r,e);if(i)return i}return e.options.extraKeys&&oo(t,e.options.extraKeys,r,e)||oo(t,e.options.keyMap,r,e)}function xo(e,t,r,n){var i=e.state.keySeq;if(i){if(lo(t))return"handled";Gs.set(50,function(){e.state.keySeq==i&&(e.state.keySeq=null,e.display.input.reset())}),t=i+" "+t}var o=wo(e,t,n);return"multi"==o&&(e.state.keySeq=t),"handled"==o&&bt(e,"keyHandled",e,t,r),"handled"!=o&&"multi"!=o||(We(r),Ar(e)),i&&!o&&/\'$/.test(t)?(We(r),!0):!!o}function Co(e,t){var r=ao(t,!0);return!!r&&(t.shiftKey&&!e.state.keySeq?xo(e,"Shift-"+r,t,function(t){return bo(e,t,!0)})||xo(e,r,t,function(t){if("string"==typeof t?/^go[A-Z]/.test(t):t.motion)return bo(e,t)}):xo(e,r,t,function(t){return bo(e,t)}))}function So(e,t,r){return xo(e,"'"+r+"'",t,function(t){return bo(e,t,!0)})}function Lo(e){var t=this;if(t.curOp.focus=l(),!Me(t,e)){gl&&vl<11&&27==e.keyCode&&(e.returnValue=!1);var r=e.keyCode;t.display.shift=16==r||e.shiftKey;var n=Co(t,e);wl&&(Us=n?r:null,!n&&88==r&&!rs&&(Ml?e.metaKey:e.ctrlKey)&&t.replaceSelection("",null,"cut")),18!=r||/\bCodeMirror-crosshair\b/.test(t.display.lineDiv.className)||ko(t)}}function ko(e){function t(e){18!=e.keyCode&&e.altKey||(Fl(r,"CodeMirror-crosshair"),ke(document,"keyup",t),ke(document,"mouseover",t))}var r=e.display.lineDiv;s(r,"CodeMirror-crosshair"),Ql(document,"keyup",t),Ql(document,"mouseover",t)}function To(e){16==e.keyCode&&(this.doc.sel.shift=!1),Me(this,e)}function Mo(e){var t=this;if(!(Ft(t.display,e)||Me(t,e)||e.ctrlKey&&!e.altKey||Ml&&e.metaKey)){var r=e.keyCode,n=e.charCode;if(wl&&r==Us)return Us=null,void We(e);if(!wl||e.which&&!(e.which<10)||!Co(t,e)){var i=String.fromCharCode(null==n?r:n);"\b"!=i&&(So(t,e,i)||t.display.input.onKeyPress(e))}}}function No(e,t){var r=+new Date;return js&&js.compare(r,e,t)?(Ks=js=null,"triple"):Ks&&Ks.compare(r,e,t)?(js=new Vs(r,e,t),Ks=null,"double"):(Ks=new Vs(r,e,t),js=null,"single")}function Oo(e){var t=this,r=t.display;if(!(Me(t,e)||r.activeTouch&&r.input.supportsTouch()))if(r.input.ensurePolled(),r.shift=e.shiftKey,Ft(r,e))ml||(r.scroller.draggable=!1,setTimeout(function(){return r.scroller.draggable=!0},100));else if(!zo(t,e)){var n=Sr(t,e),i=Pe(e),o=n?No(n,i):"single";window.focus(),1==i&&t.state.selectingText&&t.state.selectingText(e),n&&Ao(t,i,n,o,e)||(1==i?n?Do(t,n,o,e):Ee(e)==r.scroller&&We(e):2==i?(n&&di(t.doc,n),setTimeout(function(){return r.input.focus()},20)):3==i&&(Hl?Ro(t,e):Dr(t)))}}function Ao(e,t,r,n,i){var o="Click";return"double"==n?o="Double"+o:"triple"==n&&(o="Triple"+o),o=(1==t?"Left":2==t?"Middle":"Right")+o,xo(e,so(o,i),i,function(t){if("string"==typeof t&&(t=Bs[t]),!t)return!1;var n=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),n=t(e,r)!=Bl}finally{e.state.suppressEdits=!1}return n})}function Wo(e,t,r){var n=e.getOption("configureMouse"),i=n?n(e,t,r):{};if(null==i.unit){var o=Nl?r.shiftKey&&r.metaKey:r.altKey;i.unit=o?"rectangle":"single"==t?"char":"double"==t?"word":"line"}return(null==i.extend||e.doc.extend)&&(i.extend=e.doc.extend||r.shiftKey),null==i.addNew&&(i.addNew=Ml?r.metaKey:r.ctrlKey),null==i.moveOnDrag&&(i.moveOnDrag=!(Ml?r.altKey:r.ctrlKey)),i}function Do(e,t,r,n){gl?setTimeout(u(Wr,e),0):e.curOp.focus=l();var i,o=Wo(e,r,n),s=e.doc.sel;e.options.dragDrop&&Jl&&!e.isReadOnly()&&"single"==r&&(i=s.contains(t))>-1&&(P((i=s.ranges[i]).from(),t)<0||t.xRel>0)&&(P(i.to(),t)>0||t.xRel<0)?Ho(e,n,t,o):Eo(e,n,t,o)}function Ho(e,t,r,n){var i=e.display,o=!1,l=dn(e,function(t){ml&&(i.scroller.draggable=!1),e.state.draggingText=!1,ke(document,"mouseup",l),ke(document,"mousemove",s),ke(i.scroller,"dragstart",a),ke(i.scroller,"drop",l),o||(We(t),n.addNew||di(e.doc,r,null,null,n.extend),ml||gl&&9==vl?setTimeout(function(){document.body.focus(),i.input.focus()},20):i.input.focus())}),s=function(e){o=o||Math.abs(t.clientX-e.clientX)+Math.abs(t.clientY-e.clientY)>=10},a=function(){return o=!0};ml&&(i.scroller.draggable=!0),e.state.draggingText=l,l.copy=!n.moveOnDrag,i.scroller.dragDrop&&i.scroller.dragDrop(),Ql(document,"mouseup",l),Ql(document,"mousemove",s),Ql(i.scroller,"dragstart",a),Ql(i.scroller,"drop",l),Dr(e),setTimeout(function(){return i.input.focus()},20)}function Fo(e,t,r){if("char"==r)return new Ts(t,t);if("word"==r)return e.findWordAt(t);if("line"==r)return new Ts(E(t.line,0),U(e.doc,E(t.line+1,0)));var n=r(e,t);return new Ts(n.from,n.to)}function Eo(e,t,r,n){function i(t){if(0!=P(m,t))if(m=t,"rectangle"==n.unit){for(var i=[],o=e.options.tabSize,l=f(M(u,r.line).text,r.ch,o),s=f(M(u,t.line).text,t.ch,o),a=Math.min(l,s),g=Math.max(l,s),v=Math.min(r.line,t.line),y=Math.min(e.lastLine(),Math.max(r.line,t.line));v<=y;v++){var b=M(u,v).text,w=d(b,a,o);a==g?i.push(new Ts(E(v,w),E(v,w))):b.length>w&&i.push(new Ts(E(v,w),E(v,d(b,g,o))))}i.length||i.push(new Ts(r,r)),bi(u,zn(p.ranges.slice(0,h).concat(i),h),{origin:"*mouse",scroll:!1}),e.scrollIntoView(t)}else{var x,C=c,S=Fo(e,t,n.unit),L=C.anchor;P(S.anchor,L)>0?(x=S.head,L=B(C.from(),S.anchor)):(x=S.anchor,L=R(C.to(),S.head));var k=p.ranges.slice(0);k[h]=Po(e,new Ts(U(u,L),x)),bi(u,zn(k,h),Ul)}}function o(t){var r=++b,s=Sr(e,t,!0,"rectangle"==n.unit);if(s)if(0!=P(s,m)){e.curOp.focus=l(),i(s);var c=Ir(a,u);(s.line>=c.to||s.line<c.from)&&setTimeout(dn(e,function(){b==r&&o(t)}),150)}else{var f=t.clientY<y.top?-20:t.clientY>y.bottom?20:0;f&&setTimeout(dn(e,function(){b==r&&(a.scroller.scrollTop+=f,o(t))}),50)}}function s(t){e.state.selectingText=!1,b=1/0,We(t),a.input.focus(),ke(document,"mousemove",w),ke(document,"mouseup",x),u.history.lastSelOrigin=null}var a=e.display,u=e.doc;We(t);var c,h,p=u.sel,g=p.ranges;if(n.addNew&&!n.extend?(h=u.sel.contains(r),c=h>-1?g[h]:new Ts(r,r)):(c=u.sel.primary(),h=u.sel.primIndex),"rectangle"==n.unit)n.addNew||(c=new Ts(r,r)),r=Sr(e,t,!0,!0),h=-1;else{var v=Fo(e,r,n.unit);c=n.extend?hi(c,v.anchor,v.head,n.extend):v}n.addNew?-1==h?(h=g.length,bi(u,zn(g.concat([c]),h),{scroll:!1,origin:"*mouse"})):g.length>1&&g[h].empty()&&"char"==n.unit&&!n.extend?(bi(u,zn(g.slice(0,h).concat(g.slice(h+1)),0),{scroll:!1,origin:"*mouse"}),p=u.sel):gi(u,h,c,Ul):(h=0,bi(u,new ks([c],0),Ul),p=u.sel);var m=r,y=a.wrapper.getBoundingClientRect(),b=0,w=dn(e,function(e){Pe(e)?o(e):s(e)}),x=dn(e,s);e.state.selectingText=x,Ql(document,"mousemove",w),Ql(document,"mouseup",x)}function Po(e,t){var r=t.anchor,n=t.head,i=M(e.doc,r.line);if(0==P(r,n)&&r.sticky==n.sticky)return t;var o=Se(i);if(!o)return t;var l=Ce(o,r.ch,r.sticky),s=o[l];if(s.from!=r.ch&&s.to!=r.ch)return t;var a=l+(s.from==r.ch==(1!=s.level)?0:1);if(0==a||a==o.length)return t;var u;if(n.line!=r.line)u=(n.line-r.line)*("ltr"==e.doc.direction?1:-1)>0;else{var c=Ce(o,n.ch,n.sticky),f=c-l||(n.ch-r.ch)*(1==s.level?-1:1);u=c==a-1||c==a?f<0:f>0}var h=o[a+(u?-1:0)],d=u==(1==h.level),p=d?h.from:h.to,g=d?"after":"before";return r.ch==p&&r.sticky==g?t:new Ts(new E(r.line,p,g),n)}function Io(e,t,r,n){var i,o;if(t.touches)i=t.touches[0].clientX,o=t.touches[0].clientY;else try{i=t.clientX,o=t.clientY}catch(t){return!1}if(i>=Math.floor(e.display.gutters.getBoundingClientRect().right))return!1;n&&We(t);var l=e.display,s=l.lineDiv.getBoundingClientRect();if(o>s.bottom||!Oe(e,r))return He(t);o-=s.top-l.viewOffset;for(var a=0;a<e.options.gutters.length;++a){var u=l.gutters.childNodes[a];if(u&&u.getBoundingClientRect().right>=i)return Te(e,r,e,D(e.doc,o),e.options.gutters[a],t),He(t)}}function zo(e,t){return Io(e,t,"gutterClick",!0)}function Ro(e,t){Ft(e.display,t)||Bo(e,t)||Me(e,t,"contextmenu")||e.display.input.onContextMenu(t)}function Bo(e,t){return!!Oe(e,"gutterContextMenu")&&Io(e,t,"gutterContextMenu",!1)}function Go(e){e.display.wrapper.className=e.display.wrapper.className.replace(/\s*cm-s-\S+/g,"")+e.options.theme.replace(/(^|\s)\s*/g," cm-s-"),er(e)}function Uo(e){Hn(e),vn(e),zr(e)}function Vo(e,t,r){if(!t!=!(r&&r!=Xs)){var n=e.display.dragFunctions,i=t?Ql:ke;i(e.display.scroller,"dragstart",n.start),i(e.display.scroller,"dragenter",n.enter),i(e.display.scroller,"dragover",n.over),i(e.display.scroller,"dragleave",n.leave),i(e.display.scroller,"drop",n.drop)}}function Ko(e){e.options.lineWrapping?(s(e.display.wrapper,"CodeMirror-wrap"),e.display.sizer.style.minWidth="",e.display.sizerWidth=null):(Fl(e.display.wrapper,"CodeMirror-wrap"),we(e)),Cr(e),vn(e),er(e),setTimeout(function(){return en(e)},100)}function jo(e,t){var r=this;if(!(this instanceof jo))return new jo(e,t);this.options=t=t?c(t):{},c(Ys,t,!1),Fn(t);var n=t.value;"string"==typeof n&&(n=new Ds(n,t.mode,null,t.lineSeparator,t.direction)),this.doc=n;var i=new jo.inputStyles[t.inputStyle](this),o=this.display=new T(e,n,i);o.wrapper.CodeMirror=this,Hn(this),Go(this),t.lineWrapping&&(this.display.wrapper.className+=" CodeMirror-wrap"),rn(this),this.state={keyMaps:[],overlays:[],modeGen:0,overwrite:!1,delayingBlurEvent:!1,focused:!1,suppressEdits:!1,pasteIncoming:!1,cutIncoming:!1,selectingText:!1,draggingText:!1,highlight:new Pl,keySeq:null,specialChars:null},t.autofocus&&!Tl&&o.input.focus(),gl&&vl<11&&setTimeout(function(){return r.display.input.reset(!0)},20),Xo(this),eo(),nn(this),this.curOp.forceUpdate=!0,qn(this,n),t.autofocus&&!Tl||this.hasFocus()?setTimeout(u(Hr,this),20):Fr(this);for(var l in _s)_s.hasOwnProperty(l)&&_s[l](r,t[l],Xs);Rr(this),t.finishInit&&t.finishInit(this);for(var s=0;s<$s.length;++s)$s[s](r);on(this),ml&&t.lineWrapping&&"optimizelegibility"==getComputedStyle(o.lineDiv).textRendering&&(o.lineDiv.style.textRendering="auto")}function Xo(e){function t(){i.activeTouch&&(o=setTimeout(function(){return i.activeTouch=null},1e3),(l=i.activeTouch).end=+new Date)}function r(e){if(1!=e.touches.length)return!1;var t=e.touches[0];return t.radiusX<=1&&t.radiusY<=1}function n(e,t){if(null==t.left)return!0;var r=t.left-e.left,n=t.top-e.top;return r*r+n*n>400}var i=e.display;Ql(i.scroller,"mousedown",dn(e,Oo)),gl&&vl<11?Ql(i.scroller,"dblclick",dn(e,function(t){if(!Me(e,t)){var r=Sr(e,t);if(r&&!zo(e,t)&&!Ft(e.display,t)){We(t);var n=e.findWordAt(r);di(e.doc,n.anchor,n.head)}}})):Ql(i.scroller,"dblclick",function(t){return Me(e,t)||We(t)}),Hl||Ql(i.scroller,"contextmenu",function(t){return Ro(e,t)});var o,l={end:0};Ql(i.scroller,"touchstart",function(t){if(!Me(e,t)&&!r(t)&&!zo(e,t)){i.input.ensurePolled(),clearTimeout(o);var n=+new Date;i.activeTouch={start:n,moved:!1,prev:n-l.end<=300?l:null},1==t.touches.length&&(i.activeTouch.left=t.touches[0].pageX,i.activeTouch.top=t.touches[0].pageY)}}),Ql(i.scroller,"touchmove",function(){i.activeTouch&&(i.activeTouch.moved=!0)}),Ql(i.scroller,"touchend",function(r){var o=i.activeTouch;if(o&&!Ft(i,r)&&null!=o.left&&!o.moved&&new Date-o.start<300){var l,s=e.coordsChar(i.activeTouch,"page");l=!o.prev||n(o,o.prev)?new Ts(s,s):!o.prev.prev||n(o,o.prev.prev)?e.findWordAt(s):new Ts(E(s.line,0),U(e.doc,E(s.line+1,0))),e.setSelection(l.anchor,l.head),e.focus(),We(r)}t()}),Ql(i.scroller,"touchcancel",t),Ql(i.scroller,"scroll",function(){i.scroller.clientHeight&&(qr(e,i.scroller.scrollTop),Qr(e,i.scroller.scrollLeft,!0),Te(e,"scroll",e))}),Ql(i.scroller,"mousewheel",function(t){return In(e,t)}),Ql(i.scroller,"DOMMouseScroll",function(t){return In(e,t)}),Ql(i.wrapper,"scroll",function(){return i.wrapper.scrollTop=i.wrapper.scrollLeft=0}),i.dragFunctions={enter:function(t){Me(e,t)||Fe(t)},over:function(t){Me(e,t)||(Zi(e,t),Fe(t))},start:function(t){return qi(e,t)},drop:dn(e,$i),leave:function(t){Me(e,t)||Qi(e)}};var s=i.input.getField();Ql(s,"keyup",function(t){return To.call(e,t)}),Ql(s,"keydown",dn(e,Lo)),Ql(s,"keypress",dn(e,Mo)),Ql(s,"focus",function(t){return Hr(e,t)}),Ql(s,"blur",function(t){return Fr(e,t)})}function Yo(e,t,r,n){var i,o=e.doc;null==r&&(r="add"),"smart"==r&&(o.mode.indent?i=$e(e,t).state:r="prev");var l=e.options.tabSize,s=M(o,t),a=f(s.text,null,l);s.stateAfter&&(s.stateAfter=null);var u,c=s.text.match(/^\s*/)[0];if(n||/\S/.test(s.text)){if("smart"==r&&((u=o.mode.indent(i,s.text.slice(c.length),s.text))==Bl||u>150)){if(!n)return;r="prev"}}else u=0,r="not";"prev"==r?u=t>o.first?f(M(o,t-1).text,null,l):0:"add"==r?u=a+e.options.indentUnit:"subtract"==r?u=a-e.options.indentUnit:"number"==typeof r&&(u=a+r),u=Math.max(0,u);var h="",d=0;if(e.options.indentWithTabs)for(var g=Math.floor(u/l);g;--g)d+=l,h+="\t";if(d<u&&(h+=p(u-d)),h!=c)return Ei(o,h,E(t,0),E(t,c.length),"+input"),s.stateAfter=null,!0;for(var v=0;v<o.sel.ranges.length;v++){var m=o.sel.ranges[v];if(m.head.line==t&&m.head.ch<c.length){var y=E(t,c.length);gi(o,v,new Ts(y,y));break}}}function _o(e){qs=e}function $o(e,t,r,n,i){var o=e.doc;e.display.shift=!1,n||(n=o.sel);var l=e.state.pasteIncoming||"paste"==i,s=es(t),a=null;if(l&&n.ranges.length>1)if(qs&&qs.text.join("\n")==t){if(n.ranges.length%qs.text.length==0){a=[];for(var u=0;u<qs.text.length;u++)a.push(o.splitLines(qs.text[u]))}}else s.length==n.ranges.length&&e.options.pasteLinesPerSelection&&(a=v(s,function(e){return[e]}));for(var c,f=n.ranges.length-1;f>=0;f--){var h=n.ranges[f],d=h.from(),p=h.to();h.empty()&&(r&&r>0?d=E(d.line,d.ch-r):e.state.overwrite&&!l?p=E(p.line,Math.min(M(o,p.line).text.length,p.ch+g(s).length)):qs&&qs.lineWise&&qs.text.join("\n")==t&&(d=p=E(d.line,0))),c=e.curOp.updateInput;var m={from:d,to:p,text:a?a[f%a.length]:s,origin:i||(l?"paste":e.state.cutIncoming?"cut":"+input")};Oi(e.doc,m),bt(e,"inputRead",e,m)}t&&!l&&Zo(e,t),jr(e),e.curOp.updateInput=c,e.curOp.typing=!0,e.state.pasteIncoming=e.state.cutIncoming=!1}function qo(e,t){var r=e.clipboardData&&e.clipboardData.getData("Text");if(r)return e.preventDefault(),t.isReadOnly()||t.options.disableInput||hn(t,function(){return $o(t,r,0,null,"paste")}),!0}function Zo(e,t){if(e.options.electricChars&&e.options.smartIndent)for(var r=e.doc.sel,n=r.ranges.length-1;n>=0;n--){var i=r.ranges[n];if(!(i.head.ch>100||n&&r.ranges[n-1].head.line==i.head.line)){var o=e.getModeAt(i.head),l=!1;if(o.electricChars){for(var s=0;s<o.electricChars.length;s++)if(t.indexOf(o.electricChars.charAt(s))>-1){l=Yo(e,i.head.line,"smart");break}}else o.electricInput&&o.electricInput.test(M(e.doc,i.head.line).text.slice(0,i.head.ch))&&(l=Yo(e,i.head.line,"smart"));l&&bt(e,"electricInput",e,i.head.line)}}}function Qo(e){for(var t=[],r=[],n=0;n<e.doc.sel.ranges.length;n++){var i=e.doc.sel.ranges[n].head.line,o={anchor:E(i,0),head:E(i+1,0)};r.push(o),t.push(e.getRange(o.anchor,o.head))}return{text:t,ranges:r}}function Jo(e,t){e.setAttribute("autocorrect","off"),e.setAttribute("autocapitalize","off"),e.setAttribute("spellcheck",!!t)}function el(){var e=n("textarea",null,null,"position: absolute; bottom: -1em; padding: 0; width: 1px; height: 1em; outline: none"),t=n("div",[e],null,"overflow: hidden; position: relative; width: 3px; height: 0px;");return ml?e.style.width="1000px":e.setAttribute("wrap","off"),Ll&&(e.style.border="1px solid black"),Jo(e),t}function tl(e,t,r,n,i){function o(){var n=t.line+r;return!(n<e.first||n>=e.first+e.size)&&(t=new E(n,t.ch,t.sticky),u=M(e,n))}function l(n){var l;if(null==(l=i?go(e.cm,u,t,r):ho(u,t,r))){if(n||!o())return!1;t=po(i,e.cm,u,t.line,r)}else t=l;return!0}var s=t,a=r,u=M(e,t.line);if("char"==n)l();else if("column"==n)l(!0);else if("word"==n||"group"==n)for(var c=null,f="group"==n,h=e.cm&&e.cm.getHelper(t,"wordChars"),d=!0;!(r<0)||l(!d);d=!1){var p=u.text.charAt(t.ch)||"\n",g=x(p,h)?"w":f&&"\n"==p?"n":!f||/\s/.test(p)?null:"p";if(!f||d||g||(g="s"),c&&c!=g){r<0&&(r=1,l(),t.sticky="after");break}if(g&&(c=g),r>0&&!l(!d))break}var v=ki(e,t,s,a,!0);return I(s,v)&&(v.hitSide=!0),v}function rl(e,t,r,n){var i,o=e.doc,l=t.left;if("page"==n){var s=Math.min(e.display.wrapper.clientHeight,window.innerHeight||document.documentElement.clientHeight),a=Math.max(s-.5*mr(e.display),3);i=(r>0?t.bottom:t.top)+r*a}else"line"==n&&(i=r>0?t.bottom+3:t.top-3);for(var u;(u=cr(e,l,i)).outside;){if(r<0?i<=0:i>=o.height){u.hitSide=!0;break}i+=5*r}return u}function nl(e,t){var r=jt(e,t.line);if(!r||r.hidden)return null;var n=M(e.doc,t.line),i=Ut(r,n,t.line),o=Se(n,e.doc.direction),l="left";o&&(l=Ce(o,t.ch)%2?"right":"left");var s=_t(i.map,t.ch,l);return s.offset="right"==s.collapse?s.end:s.start,s}function il(e){for(var t=e;t;t=t.parentNode)if(/CodeMirror-gutter-wrapper/.test(t.className))return!0;return!1}function ol(e,t){return t&&(e.bad=!0),e}function ll(e,t,r,n,i){function o(e){return function(t){return t.id==e}}function l(){c&&(u+=f,c=!1)}function s(e){e&&(l(),u+=e)}function a(t){if(1==t.nodeType){var r=t.getAttribute("cm-text");if(null!=r)return void s(r||t.textContent.replace(/\u200b/g,""));var u,h=t.getAttribute("cm-marker");if(h){var d=e.findMarks(E(n,0),E(i+1,0),o(+h));return void(d.length&&(u=d[0].find(0))&&s(N(e.doc,u.from,u.to).join(f)))}if("false"==t.getAttribute("contenteditable"))return;var p=/^(pre|div|p)$/i.test(t.nodeName);p&&l();for(var g=0;g<t.childNodes.length;g++)a(t.childNodes[g]);p&&(c=!0)}else 3==t.nodeType&&s(t.nodeValue)}for(var u="",c=!1,f=e.doc.lineSeparator();a(t),t!=r;)t=t.nextSibling;return u}function sl(e,t,r){var n;if(t==e.display.lineDiv){if(!(n=e.display.lineDiv.childNodes[r]))return ol(e.clipPos(E(e.display.viewTo-1)),!0);t=null,r=0}else for(n=t;;n=n.parentNode){if(!n||n==e.display.lineDiv)return null;if(n.parentNode&&n.parentNode==e.display.lineDiv)break}for(var i=0;i<e.display.view.length;i++){var o=e.display.view[i];if(o.node==n)return al(o,t,r)}}function al(e,t,r){function n(t,r,n){for(var i=-1;i<(f?f.length:0);i++)for(var o=i<0?c.map:f[i],l=0;l<o.length;l+=3){var s=o[l+2];if(s==t||s==r){var a=W(i<0?e.line:e.rest[i]),u=o[l]+n;return(n<0||s!=t)&&(u=o[l+(n?1:0)]),E(a,u)}}}var i=e.text.firstChild,l=!1;if(!t||!o(i,t))return ol(E(W(e.line),0),!0);if(t==i&&(l=!0,t=i.childNodes[r],r=0,!t)){var s=e.rest?g(e.rest):e.line;return ol(E(W(s),s.text.length),l)}var a=3==t.nodeType?t:null,u=t;for(a||1!=t.childNodes.length||3!=t.firstChild.nodeType||(a=t.firstChild,r&&(r=a.nodeValue.length));u.parentNode!=i;)u=u.parentNode;var c=e.measure,f=c.maps,h=n(a,u,r);if(h)return ol(h,l);for(var d=u.nextSibling,p=a?a.nodeValue.length-r:0;d;d=d.nextSibling){if(h=n(d,d.firstChild,0))return ol(E(h.line,h.ch-p),l);p+=d.textContent.length}for(var v=u.previousSibling,m=r;v;v=v.previousSibling){if(h=n(v,v.firstChild,-1))return ol(E(h.line,h.ch+m),l);m+=v.textContent.length}}var ul=navigator.userAgent,cl=navigator.platform,fl=/gecko\/\d/i.test(ul),hl=/MSIE \d/.test(ul),dl=/Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(ul),pl=/Edge\/(\d+)/.exec(ul),gl=hl||dl||pl,vl=gl&&(hl?document.documentMode||6:+(pl||dl)[1]),ml=!pl&&/WebKit\//.test(ul),yl=ml&&/Qt\/\d+\.\d+/.test(ul),bl=!pl&&/Chrome\//.test(ul),wl=/Opera\//.test(ul),xl=/Apple Computer/.test(navigator.vendor),Cl=/Mac OS X 1\d\D([8-9]|\d\d)\D/.test(ul),Sl=/PhantomJS/.test(ul),Ll=!pl&&/AppleWebKit/.test(ul)&&/Mobile\/\w+/.test(ul),kl=/Android/.test(ul),Tl=Ll||kl||/webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(ul),Ml=Ll||/Mac/.test(cl),Nl=/\bCrOS\b/.test(ul),Ol=/win/i.test(cl),Al=wl&&ul.match(/Version\/(\d*\.\d*)/);Al&&(Al=Number(Al[1])),Al&&Al>=15&&(wl=!1,ml=!0);var Wl,Dl=Ml&&(yl||wl&&(null==Al||Al<12.11)),Hl=fl||gl&&vl>=9,Fl=function(t,r){var n=t.className,i=e(r).exec(n);if(i){var o=n.slice(i.index+i[0].length);t.className=n.slice(0,i.index)+(o?i[1]+o:"")}};Wl=document.createRange?function(e,t,r,n){var i=document.createRange();return i.setEnd(n||e,r),i.setStart(e,t),i}:function(e,t,r){var n=document.body.createTextRange();try{n.moveToElementText(e.parentNode)}catch(e){return n}return n.collapse(!0),n.moveEnd("character",r),n.moveStart("character",t),n};var El=function(e){e.select()};Ll?El=function(e){e.selectionStart=0,e.selectionEnd=e.value.length}:gl&&(El=function(e){try{e.select()}catch(e){}});var Pl=function(){this.id=null};Pl.prototype.set=function(e,t){clearTimeout(this.id),this.id=setTimeout(t,e)};var Il,zl,Rl=30,Bl={toString:function(){return"CodeMirror.Pass"}},Gl={scroll:!1},Ul={origin:"*mouse"},Vl={origin:"+move"},Kl=[""],jl=/[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/,Xl=/[\u0300-\u036f\u0483-\u0489\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u065e\u0670\u06d6-\u06dc\u06de-\u06e4\u06e7\u06e8\u06ea-\u06ed\u0711\u0730-\u074a\u07a6-\u07b0\u07eb-\u07f3\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0900-\u0902\u093c\u0941-\u0948\u094d\u0951-\u0955\u0962\u0963\u0981\u09bc\u09be\u09c1-\u09c4\u09cd\u09d7\u09e2\u09e3\u0a01\u0a02\u0a3c\u0a41\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a70\u0a71\u0a75\u0a81\u0a82\u0abc\u0ac1-\u0ac5\u0ac7\u0ac8\u0acd\u0ae2\u0ae3\u0b01\u0b3c\u0b3e\u0b3f\u0b41-\u0b44\u0b4d\u0b56\u0b57\u0b62\u0b63\u0b82\u0bbe\u0bc0\u0bcd\u0bd7\u0c3e-\u0c40\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0cbc\u0cbf\u0cc2\u0cc6\u0ccc\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0d3e\u0d41-\u0d44\u0d4d\u0d57\u0d62\u0d63\u0dca\u0dcf\u0dd2-\u0dd4\u0dd6\u0ddf\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0eb1\u0eb4-\u0eb9\u0ebb\u0ebc\u0ec8-\u0ecd\u0f18\u0f19\u0f35\u0f37\u0f39\u0f71-\u0f7e\u0f80-\u0f84\u0f86\u0f87\u0f90-\u0f97\u0f99-\u0fbc\u0fc6\u102d-\u1030\u1032-\u1037\u1039\u103a\u103d\u103e\u1058\u1059\u105e-\u1060\u1071-\u1074\u1082\u1085\u1086\u108d\u109d\u135f\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b7-\u17bd\u17c6\u17c9-\u17d3\u17dd\u180b-\u180d\u18a9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193b\u1a17\u1a18\u1a56\u1a58-\u1a5e\u1a60\u1a62\u1a65-\u1a6c\u1a73-\u1a7c\u1a7f\u1b00-\u1b03\u1b34\u1b36-\u1b3a\u1b3c\u1b42\u1b6b-\u1b73\u1b80\u1b81\u1ba2-\u1ba5\u1ba8\u1ba9\u1c2c-\u1c33\u1c36\u1c37\u1cd0-\u1cd2\u1cd4-\u1ce0\u1ce2-\u1ce8\u1ced\u1dc0-\u1de6\u1dfd-\u1dff\u200c\u200d\u20d0-\u20f0\u2cef-\u2cf1\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua66f-\ua672\ua67c\ua67d\ua6f0\ua6f1\ua802\ua806\ua80b\ua825\ua826\ua8c4\ua8e0-\ua8f1\ua926-\ua92d\ua947-\ua951\ua980-\ua982\ua9b3\ua9b6-\ua9b9\ua9bc\uaa29-\uaa2e\uaa31\uaa32\uaa35\uaa36\uaa43\uaa4c\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uabe5\uabe8\uabed\udc00-\udfff\ufb1e\ufe00-\ufe0f\ufe20-\ufe26\uff9e\uff9f]/,Yl=!1,_l=!1,$l=null,ql=function(){function e(e){return e<=247?r.charAt(e):1424<=e&&e<=1524?"R":1536<=e&&e<=1785?n.charAt(e-1536):1774<=e&&e<=2220?"r":8192<=e&&e<=8203?"w":8204==e?"b":"L"}function t(e,t,r){this.level=e,this.from=t,this.to=r}var r="bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLN",n="nnnnnnNNr%%r,rNNmmmmmmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmmmnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmnNmmmmmmrrmmNmmmmrr1111111111",i=/[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/,o=/[stwN]/,l=/[LRr]/,s=/[Lb1n]/,a=/[1n]/;return function(r,n){var u="ltr"==n?"L":"R";if(0==r.length||"ltr"==n&&!i.test(r))return!1;for(var c=r.length,f=[],h=0;h<c;++h)f.push(e(r.charCodeAt(h)));for(var d=0,p=u;d<c;++d){var v=f[d];"m"==v?f[d]=p:p=v}for(var m=0,y=u;m<c;++m){var b=f[m];"1"==b&&"r"==y?f[m]="n":l.test(b)&&(y=b,"r"==b&&(f[m]="R"))}for(var w=1,x=f[0];w<c-1;++w){var C=f[w];"+"==C&&"1"==x&&"1"==f[w+1]?f[w]="1":","!=C||x!=f[w+1]||"1"!=x&&"n"!=x||(f[w]=x),x=C}for(var S=0;S<c;++S){var L=f[S];if(","==L)f[S]="N";else if("%"==L){var k=void 0;for(k=S+1;k<c&&"%"==f[k];++k);for(var T=S&&"!"==f[S-1]||k<c&&"1"==f[k]?"1":"N",M=S;M<k;++M)f[M]=T;S=k-1}}for(var N=0,O=u;N<c;++N){var A=f[N];"L"==O&&"1"==A?f[N]="L":l.test(A)&&(O=A)}for(var W=0;W<c;++W)if(o.test(f[W])){var D=void 0;for(D=W+1;D<c&&o.test(f[D]);++D);for(var H="L"==(W?f[W-1]:u),F=H==("L"==(D<c?f[D]:u))?H?"L":"R":u,E=W;E<D;++E)f[E]=F;W=D-1}for(var P,I=[],z=0;z<c;)if(s.test(f[z])){var R=z;for(++z;z<c&&s.test(f[z]);++z);I.push(new t(0,R,z))}else{var B=z,G=I.length;for(++z;z<c&&"L"!=f[z];++z);for(var U=B;U<z;)if(a.test(f[U])){B<U&&I.splice(G,0,new t(1,B,U));var V=U;for(++U;U<z&&a.test(f[U]);++U);I.splice(G,0,new t(2,V,U)),B=U}else++U;B<z&&I.splice(G,0,new t(1,B,z))}return 1==I[0].level&&(P=r.match(/^\s+/))&&(I[0].from=P[0].length,I.unshift(new t(0,0,P[0].length))),1==g(I).level&&(P=r.match(/\s+$/))&&(g(I).to-=P[0].length,I.push(new t(0,c-P[0].length,c))),"rtl"==n?I.reverse():I}}(),Zl=[],Ql=function(e,t,r){if(e.addEventListener)e.addEventListener(t,r,!1);else if(e.attachEvent)e.attachEvent("on"+t,r);else{var n=e._handlers||(e._handlers={});n[t]=(n[t]||Zl).concat(r)}},Jl=function(){if(gl&&vl<9)return!1;var e=n("div");return"draggable"in e||"dragDrop"in e}(),es=3!="\n\nb".split(/\n/).length?function(e){for(var t=0,r=[],n=e.length;t<=n;){var i=e.indexOf("\n",t);-1==i&&(i=e.length);var o=e.slice(t,"\r"==e.charAt(i-1)?i-1:i),l=o.indexOf("\r");-1!=l?(r.push(o.slice(0,l)),t+=l+1):(r.push(o),t=i+1)}return r}:function(e){return e.split(/\r\n?|\n/)},ts=window.getSelection?function(e){try{return e.selectionStart!=e.selectionEnd}catch(e){return!1}}:function(e){var t;try{t=e.ownerDocument.selection.createRange()}catch(e){}return!(!t||t.parentElement()!=e)&&0!=t.compareEndPoints("StartToEnd",t)},rs=function(){var e=n("div");return"oncopy"in e||(e.setAttribute("oncopy","return;"),"function"==typeof e.oncopy)}(),ns=null,is={},os={},ls={},ss=function(e,t,r){this.pos=this.start=0,this.string=e,this.tabSize=t||8,this.lastColumnPos=this.lastColumnValue=0,this.lineStart=0,this.lineOracle=r};ss.prototype.eol=function(){return this.pos>=this.string.length},ss.prototype.sol=function(){return this.pos==this.lineStart},ss.prototype.peek=function(){return this.string.charAt(this.pos)||void 0},ss.prototype.next=function(){if(this.pos<this.string.length)return this.string.charAt(this.pos++)},ss.prototype.eat=function(e){var t=this.string.charAt(this.pos);if("string"==typeof e?t==e:t&&(e.test?e.test(t):e(t)))return++this.pos,t},ss.prototype.eatWhile=function(e){for(var t=this.pos;this.eat(e););return this.pos>t},ss.prototype.eatSpace=function(){for(var e=this,t=this.pos;/[\s\u00a0]/.test(this.string.charAt(this.pos));)++e.pos;return this.pos>t},ss.prototype.skipToEnd=function(){this.pos=this.string.length},ss.prototype.skipTo=function(e){var t=this.string.indexOf(e,this.pos);if(t>-1)return this.pos=t,!0},ss.prototype.backUp=function(e){this.pos-=e},ss.prototype.column=function(){return this.lastColumnPos<this.start&&(this.lastColumnValue=f(this.string,this.start,this.tabSize,this.lastColumnPos,this.lastColumnValue),this.lastColumnPos=this.start),this.lastColumnValue-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.indentation=function(){return f(this.string,null,this.tabSize)-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.match=function(e,t,r){if("string"!=typeof e){var n=this.string.slice(this.pos).match(e);return n&&n.index>0?null:(n&&!1!==t&&(this.pos+=n[0].length),n)}var i=function(e){return r?e.toLowerCase():e};if(i(this.string.substr(this.pos,e.length))==i(e))return!1!==t&&(this.pos+=e.length),!0},ss.prototype.current=function(){return this.string.slice(this.start,this.pos)},ss.prototype.hideFirstChars=function(e,t){this.lineStart+=e;try{return t()}finally{this.lineStart-=e}},ss.prototype.lookAhead=function(e){var t=this.lineOracle;return t&&t.lookAhead(e)};var as=function(e,t){this.state=e,this.lookAhead=t},us=function(e,t,r,n){this.state=t,this.doc=e,this.line=r,this.maxLookAhead=n||0};us.prototype.lookAhead=function(e){var t=this.doc.getLine(this.line+e);return null!=t&&e>this.maxLookAhead&&(this.maxLookAhead=e),t},us.prototype.nextLine=function(){this.line++,this.maxLookAhead>0&&this.maxLookAhead--},us.fromSaved=function(e,t,r){return t instanceof as?new us(e,Ke(e.mode,t.state),r,t.lookAhead):new us(e,Ke(e.mode,t),r)},us.prototype.save=function(e){var t=!1!==e?Ke(this.doc.mode,this.state):this.state;return this.maxLookAhead>0?new as(t,this.maxLookAhead):t};var cs=function(e,t,r){this.start=e.start,this.end=e.pos,this.string=e.current(),this.type=t||null,this.state=r},fs=function(e,t,r){this.text=e,ne(this,t),this.height=r?r(this):1};fs.prototype.lineNo=function(){return W(this)},Ae(fs);var hs,ds={},ps={},gs=null,vs=null,ms={left:0,right:0,top:0,bottom:0},ys=function(e,t,r){this.cm=r;var i=this.vert=n("div",[n("div",null,null,"min-width: 1px")],"CodeMirror-vscrollbar"),o=this.horiz=n("div",[n("div",null,null,"height: 100%; min-height: 1px")],"CodeMirror-hscrollbar");e(i),e(o),Ql(i,"scroll",function(){i.clientHeight&&t(i.scrollTop,"vertical")}),Ql(o,"scroll",function(){o.clientWidth&&t(o.scrollLeft,"horizontal")}),this.checkedZeroWidth=!1,gl&&vl<8&&(this.horiz.style.minHeight=this.vert.style.minWidth="18px")};ys.prototype.update=function(e){var t=e.scrollWidth>e.clientWidth+1,r=e.scrollHeight>e.clientHeight+1,n=e.nativeBarWidth;if(r){this.vert.style.display="block",this.vert.style.bottom=t?n+"px":"0";var i=e.viewHeight-(t?n:0);this.vert.firstChild.style.height=Math.max(0,e.scrollHeight-e.clientHeight+i)+"px"}else this.vert.style.display="",this.vert.firstChild.style.height="0";if(t){this.horiz.style.display="block",this.horiz.style.right=r?n+"px":"0",this.horiz.style.left=e.barLeft+"px";var o=e.viewWidth-e.barLeft-(r?n:0);this.horiz.firstChild.style.width=Math.max(0,e.scrollWidth-e.clientWidth+o)+"px"}else this.horiz.style.display="",this.horiz.firstChild.style.width="0";return!this.checkedZeroWidth&&e.clientHeight>0&&(0==n&&this.zeroWidthHack(),this.checkedZeroWidth=!0),{right:r?n:0,bottom:t?n:0}},ys.prototype.setScrollLeft=function(e){this.horiz.scrollLeft!=e&&(this.horiz.scrollLeft=e),this.disableHoriz&&this.enableZeroWidthBar(this.horiz,this.disableHoriz,"horiz")},ys.prototype.setScrollTop=function(e){this.vert.scrollTop!=e&&(this.vert.scrollTop=e),this.disableVert&&this.enableZeroWidthBar(this.vert,this.disableVert,"vert")},ys.prototype.zeroWidthHack=function(){var e=Ml&&!Cl?"12px":"18px";this.horiz.style.height=this.vert.style.width=e,this.horiz.style.pointerEvents=this.vert.style.pointerEvents="none",this.disableHoriz=new Pl,this.disableVert=new Pl},ys.prototype.enableZeroWidthBar=function(e,t,r){function n(){var i=e.getBoundingClientRect();("vert"==r?document.elementFromPoint(i.right-1,(i.top+i.bottom)/2):document.elementFromPoint((i.right+i.left)/2,i.bottom-1))!=e?e.style.pointerEvents="none":t.set(1e3,n)}e.style.pointerEvents="auto",t.set(1e3,n)},ys.prototype.clear=function(){var e=this.horiz.parentNode;e.removeChild(this.horiz),e.removeChild(this.vert)};var bs=function(){};bs.prototype.update=function(){return{bottom:0,right:0}},bs.prototype.setScrollLeft=function(){},bs.prototype.setScrollTop=function(){},bs.prototype.clear=function(){};var ws={native:ys,null:bs},xs=0,Cs=function(e,t,r){var n=e.display;this.viewport=t,this.visible=Ir(n,e.doc,t),this.editorIsHidden=!n.wrapper.offsetWidth,this.wrapperHeight=n.wrapper.clientHeight,this.wrapperWidth=n.wrapper.clientWidth,this.oldDisplayWidth=Rt(e),this.force=r,this.dims=br(e),this.events=[]};Cs.prototype.signal=function(e,t){Oe(e,t)&&this.events.push(arguments)},Cs.prototype.finish=function(){for(var e=this,t=0;t<this.events.length;t++)Te.apply(null,e.events[t])};var Ss=0,Ls=null;gl?Ls=-.53:fl?Ls=15:bl?Ls=-.7:xl&&(Ls=-1/3);var ks=function(e,t){this.ranges=e,this.primIndex=t};ks.prototype.primary=function(){return this.ranges[this.primIndex]},ks.prototype.equals=function(e){var t=this;if(e==this)return!0;if(e.primIndex!=this.primIndex||e.ranges.length!=this.ranges.length)return!1;for(var r=0;r<this.ranges.length;r++){var n=t.ranges[r],i=e.ranges[r];if(!I(n.anchor,i.anchor)||!I(n.head,i.head))return!1}return!0},ks.prototype.deepCopy=function(){for(var e=this,t=[],r=0;r<this.ranges.length;r++)t[r]=new Ts(z(e.ranges[r].anchor),z(e.ranges[r].head));return new ks(t,this.primIndex)},ks.prototype.somethingSelected=function(){for(var e=this,t=0;t<this.ranges.length;t++)if(!e.ranges[t].empty())return!0;return!1},ks.prototype.contains=function(e,t){var r=this;t||(t=e);for(var n=0;n<this.ranges.length;n++){var i=r.ranges[n];if(P(t,i.from())>=0&&P(e,i.to())<=0)return n}return-1};var Ts=function(e,t){this.anchor=e,this.head=t};Ts.prototype.from=function(){return B(this.anchor,this.head)},Ts.prototype.to=function(){return R(this.anchor,this.head)},Ts.prototype.empty=function(){return this.head.line==this.anchor.line&&this.head.ch==this.anchor.ch},Bi.prototype={chunkSize:function(){return this.lines.length},removeInner:function(e,t){for(var r=this,n=e,i=e+t;n<i;++n){var o=r.lines[n];r.height-=o.height,ot(o),bt(o,"delete")}this.lines.splice(e,t)},collapse:function(e){e.push.apply(e,this.lines)},insertInner:function(e,t,r){var n=this;this.height+=r,this.lines=this.lines.slice(0,e).concat(t).concat(this.lines.slice(e));for(var i=0;i<t.length;++i)t[i].parent=n},iterN:function(e,t,r){for(var n=this,i=e+t;e<i;++e)if(r(n.lines[e]))return!0}},Gi.prototype={chunkSize:function(){return this.size},removeInner:function(e,t){var r=this;this.size-=t;for(var n=0;n<this.children.length;++n){var i=r.children[n],o=i.chunkSize();if(e<o){var l=Math.min(t,o-e),s=i.height;if(i.removeInner(e,l),r.height-=s-i.height,o==l&&(r.children.splice(n--,1),i.parent=null),0==(t-=l))break;e=0}else e-=o}if(this.size-t<25&&(this.children.length>1||!(this.children[0]instanceof Bi))){var a=[];this.collapse(a),this.children=[new Bi(a)],this.children[0].parent=this}},collapse:function(e){for(var t=this,r=0;r<this.children.length;++r)t.children[r].collapse(e)},insertInner:function(e,t,r){var n=this;this.size+=t.length,this.height+=r;for(var i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<=l){if(o.insertInner(e,t,r),o.lines&&o.lines.length>50){for(var s=o.lines.length%25+25,a=s;a<o.lines.length;){var u=new Bi(o.lines.slice(a,a+=25));o.height-=u.height,n.children.splice(++i,0,u),u.parent=n}o.lines=o.lines.slice(0,s),n.maybeSpill()}break}e-=l}},maybeSpill:function(){if(!(this.children.length<=10)){var e=this;do{var t=new Gi(e.children.splice(e.children.length-5,5));if(e.parent){e.size-=t.size,e.height-=t.height;var r=h(e.parent.children,e);e.parent.children.splice(r+1,0,t)}else{var n=new Gi(e.children);n.parent=e,e.children=[n,t],e=n}t.parent=e.parent}while(e.children.length>10);e.parent.maybeSpill()}},iterN:function(e,t,r){for(var n=this,i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<l){var s=Math.min(t,l-e);if(o.iterN(e,s,r))return!0;if(0==(t-=s))break;e=0}else e-=l}}};var Ms=function(e,t,r){var n=this;if(r)for(var i in r)r.hasOwnProperty(i)&&(n[i]=r[i]);this.doc=e,this.node=t};Ms.prototype.clear=function(){var e=this,t=this.doc.cm,r=this.line.widgets,n=this.line,i=W(n);if(null!=i&&r){for(var o=0;o<r.length;++o)r[o]==e&&r.splice(o--,1);r.length||(n.widgets=null);var l=Ht(this);A(n,Math.max(0,n.height-l)),t&&(hn(t,function(){Ui(t,n,-l),mn(t,i,"widget")}),bt(t,"lineWidgetCleared",t,this,i))}},Ms.prototype.changed=function(){var e=this,t=this.height,r=this.doc.cm,n=this.line;this.height=null;var i=Ht(this)-t;i&&(A(n,n.height+i),r&&hn(r,function(){r.curOp.forceUpdate=!0,Ui(r,n,i),bt(r,"lineWidgetChanged",r,e,W(n))}))},Ae(Ms);var Ns=0,Os=function(e,t){this.lines=[],this.type=t,this.doc=e,this.id=++Ns};Os.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){var t=this.doc.cm,r=t&&!t.curOp;if(r&&nn(t),Oe(this,"clear")){var n=this.find();n&&bt(this,"clear",n.from,n.to)}for(var i=null,o=null,l=0;l<this.lines.length;++l){var s=e.lines[l],a=_(s.markedSpans,e);t&&!e.collapsed?mn(t,W(s),"text"):t&&(null!=a.to&&(o=W(s)),null!=a.from&&(i=W(s))),s.markedSpans=$(s.markedSpans,a),null==a.from&&e.collapsed&&!ve(e.doc,s)&&t&&A(s,mr(t.display))}if(t&&this.collapsed&&!t.options.lineWrapping)for(var u=0;u<this.lines.length;++u){var c=fe(e.lines[u]),f=be(c);f>t.display.maxLineLength&&(t.display.maxLine=c,t.display.maxLineLength=f,t.display.maxLineChanged=!0)}null!=i&&t&&this.collapsed&&vn(t,i,o+1),this.lines.length=0,this.explicitlyCleared=!0,this.atomic&&this.doc.cantEdit&&(this.doc.cantEdit=!1,t&&Ci(t.doc)),t&&bt(t,"markerCleared",t,this,i,o),r&&on(t),this.parent&&this.parent.clear()}},Os.prototype.find=function(e,t){var r=this;null==e&&"bookmark"==this.type&&(e=1);for(var n,i,o=0;o<this.lines.length;++o){var l=r.lines[o],s=_(l.markedSpans,r);if(null!=s.from&&(n=E(t?l:W(l),s.from),-1==e))return n;if(null!=s.to&&(i=E(t?l:W(l),s.to),1==e))return i}return n&&{from:n,to:i}},Os.prototype.changed=function(){var e=this,t=this.find(-1,!0),r=this,n=this.doc.cm;t&&n&&hn(n,function(){var i=t.line,o=W(t.line),l=jt(n,o);if(l&&(Qt(l),n.curOp.selectionChanged=n.curOp.forceUpdate=!0),n.curOp.updateMaxLine=!0,!ve(r.doc,i)&&null!=r.height){var s=r.height;r.height=null;var a=Ht(r)-s;a&&A(i,i.height+a)}bt(n,"markerChanged",n,e)})},Os.prototype.attachLine=function(e){if(!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;t.maybeHiddenMarkers&&-1!=h(t.maybeHiddenMarkers,this)||(t.maybeUnhiddenMarkers||(t.maybeUnhiddenMarkers=[])).push(this)}this.lines.push(e)},Os.prototype.detachLine=function(e){if(this.lines.splice(h(this.lines,e),1),!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;(t.maybeHiddenMarkers||(t.maybeHiddenMarkers=[])).push(this)}},Ae(Os);var As=function(e,t){var r=this;this.markers=e,this.primary=t;for(var n=0;n<e.length;++n)e[n].parent=r};As.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){this.explicitlyCleared=!0;for(var t=0;t<this.markers.length;++t)e.markers[t].clear();bt(this,"clear")}},As.prototype.find=function(e,t){return this.primary.find(e,t)},Ae(As);var Ws=0,Ds=function(e,t,r,n,i){if(!(this instanceof Ds))return new Ds(e,t,r,n,i);null==r&&(r=0),Gi.call(this,[new Bi([new fs("",null)])]),this.first=r,this.scrollTop=this.scrollLeft=0,this.cantEdit=!1,this.cleanGeneration=1,this.modeFrontier=this.highlightFrontier=r;var o=E(r,0);this.sel=Rn(o),this.history=new Jn(null),this.id=++Ws,this.modeOption=t,this.lineSep=n,this.direction="rtl"==i?"rtl":"ltr",this.extend=!1,"string"==typeof e&&(e=this.splitLines(e)),_n(this,{from:o,to:o,text:e}),bi(this,Rn(o),Gl)};Ds.prototype=b(Gi.prototype,{constructor:Ds,iter:function(e,t,r){r?this.iterN(e-this.first,t-e,r):this.iterN(this.first,this.first+this.size,e)},insert:function(e,t){for(var r=0,n=0;n<t.length;++n)r+=t[n].height;this.insertInner(e-this.first,t,r)},remove:function(e,t){this.removeInner(e-this.first,t)},getValue:function(e){var t=O(this,this.first,this.first+this.size);return!1===e?t:t.join(e||this.lineSeparator())},setValue:gn(function(e){var t=E(this.first,0),r=this.first+this.size-1;Oi(this,{from:t,to:E(r,M(this,r).text.length),text:this.splitLines(e),origin:"setValue",full:!0},!0),this.cm&&Xr(this.cm,0,0),bi(this,Rn(t),Gl)}),replaceRange:function(e,t,r,n){Ei(this,e,t=U(this,t),r=r?U(this,r):t,n)},getRange:function(e,t,r){var n=N(this,U(this,e),U(this,t));return!1===r?n:n.join(r||this.lineSeparator())},getLine:function(e){var t=this.getLineHandle(e);return t&&t.text},getLineHandle:function(e){if(H(this,e))return M(this,e)},getLineNumber:function(e){return W(e)},getLineHandleVisualStart:function(e){return"number"==typeof e&&(e=M(this,e)),fe(e)},lineCount:function(){return this.size},firstLine:function(){return this.first},lastLine:function(){return this.first+this.size-1},clipPos:function(e){return U(this,e)},getCursor:function(e){var t=this.sel.primary();return null==e||"head"==e?t.head:"anchor"==e?t.anchor:"end"==e||"to"==e||!1===e?t.to():t.from()},listSelections:function(){return this.sel.ranges},somethingSelected:function(){return this.sel.somethingSelected()},setCursor:gn(function(e,t,r){vi(this,U(this,"number"==typeof e?E(e,t||0):e),null,r)}),setSelection:gn(function(e,t,r){vi(this,U(this,e),U(this,t||e),r)}),extendSelection:gn(function(e,t,r){di(this,U(this,e),t&&U(this,t),r)}),extendSelections:gn(function(e,t){pi(this,K(this,e),t)}),extendSelectionsBy:gn(function(e,t){pi(this,K(this,v(this.sel.ranges,e)),t)}),setSelections:gn(function(e,t,r){var n=this;if(e.length){for(var i=[],o=0;o<e.length;o++)i[o]=new Ts(U(n,e[o].anchor),U(n,e[o].head));null==t&&(t=Math.min(e.length-1,this.sel.primIndex)),bi(this,zn(i,t),r)}}),addSelection:gn(function(e,t,r){var n=this.sel.ranges.slice(0);n.push(new Ts(U(this,e),U(this,t||e))),bi(this,zn(n,n.length-1),r)}),getSelection:function(e){for(var t,r=this,n=this.sel.ranges,i=0;i<n.length;i++){var o=N(r,n[i].from(),n[i].to());t=t?t.concat(o):o}return!1===e?t:t.join(e||this.lineSeparator())},getSelections:function(e){for(var t=this,r=[],n=this.sel.ranges,i=0;i<n.length;i++){var o=N(t,n[i].from(),n[i].to());!1!==e&&(o=o.join(e||t.lineSeparator())),r[i]=o}return r},replaceSelection:function(e,t,r){for(var n=[],i=0;i<this.sel.ranges.length;i++)n[i]=e;this.replaceSelections(n,t,r||"+input")},replaceSelections:gn(function(e,t,r){for(var n=this,i=[],o=this.sel,l=0;l<o.ranges.length;l++){var s=o.ranges[l];i[l]={from:s.from(),to:s.to(),text:n.splitLines(e[l]),origin:r}}for(var a=t&&"end"!=t&&Kn(this,i,t),u=i.length-1;u>=0;u--)Oi(n,i[u]);a?yi(this,a):this.cm&&jr(this.cm)}),undo:gn(function(){Wi(this,"undo")}),redo:gn(function(){Wi(this,"redo")}),undoSelection:gn(function(){Wi(this,"undo",!0)}),redoSelection:gn(function(){Wi(this,"redo",!0)}),setExtending:function(e){this.extend=e},getExtending:function(){return this.extend},historySize:function(){for(var e=this.history,t=0,r=0,n=0;n<e.done.length;n++)e.done[n].ranges||++t;for(var i=0;i<e.undone.length;i++)e.undone[i].ranges||++r;return{undo:t,redo:r}},clearHistory:function(){this.history=new Jn(this.history.maxGeneration)},markClean:function(){this.cleanGeneration=this.changeGeneration(!0)},changeGeneration:function(e){return e&&(this.history.lastOp=this.history.lastSelOp=this.history.lastOrigin=null),this.history.generation},isClean:function(e){return this.history.generation==(e||this.cleanGeneration)},getHistory:function(){return{done:fi(this.history.done),undone:fi(this.history.undone)}},setHistory:function(e){var t=this.history=new Jn(this.history.maxGeneration);t.done=fi(e.done.slice(0),null,!0),t.undone=fi(e.undone.slice(0),null,!0)},setGutterMarker:gn(function(e,t,r){return Ri(this,e,"gutter",function(e){var n=e.gutterMarkers||(e.gutterMarkers={});return n[t]=r,!r&&C(n)&&(e.gutterMarkers=null),!0})}),clearGutter:gn(function(e){var t=this;this.iter(function(r){r.gutterMarkers&&r.gutterMarkers[e]&&Ri(t,r,"gutter",function(){return r.gutterMarkers[e]=null,C(r.gutterMarkers)&&(r.gutterMarkers=null),!0})})}),lineInfo:function(e){var t;if("number"==typeof e){if(!H(this,e))return null;if(t=e,!(e=M(this,e)))return null}else if(null==(t=W(e)))return null;return{line:t,handle:e,text:e.text,gutterMarkers:e.gutterMarkers,textClass:e.textClass,bgClass:e.bgClass,wrapClass:e.wrapClass,widgets:e.widgets}},addLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass";if(t[i]){if(e(n).test(t[i]))return!1;t[i]+=" "+n}else t[i]=n;return!0})}),removeLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass",o=t[i];if(!o)return!1;if(null==n)t[i]=null;else{var l=o.match(e(n));if(!l)return!1;var s=l.index+l[0].length;t[i]=o.slice(0,l.index)+(l.index&&s!=o.length?" ":"")+o.slice(s)||null}return!0})}),addLineWidget:gn(function(e,t,r){return Vi(this,e,t,r)}),removeLineWidget:function(e){e.clear()},markText:function(e,t,r){return Ki(this,U(this,e),U(this,t),r,r&&r.type||"range")},setBookmark:function(e,t){var r={replacedWith:t&&(null==t.nodeType?t.widget:t),insertLeft:t&&t.insertLeft,clearWhenEmpty:!1,shared:t&&t.shared,handleMouseEvents:t&&t.handleMouseEvents};return e=U(this,e),Ki(this,e,e,r,"bookmark")},findMarksAt:function(e){var t=[],r=M(this,(e=U(this,e)).line).markedSpans;if(r)for(var n=0;n<r.length;++n){var i=r[n];(null==i.from||i.from<=e.ch)&&(null==i.to||i.to>=e.ch)&&t.push(i.marker.parent||i.marker)}return t},findMarks:function(e,t,r){e=U(this,e),t=U(this,t);var n=[],i=e.line;return this.iter(e.line,t.line+1,function(o){var l=o.markedSpans;if(l)for(var s=0;s<l.length;s++){var a=l[s];null!=a.to&&i==e.line&&e.ch>=a.to||null==a.from&&i!=e.line||null!=a.from&&i==t.line&&a.from>=t.ch||r&&!r(a.marker)||n.push(a.marker.parent||a.marker)}++i}),n},getAllMarks:function(){var e=[];return this.iter(function(t){var r=t.markedSpans;if(r)for(var n=0;n<r.length;++n)null!=r[n].from&&e.push(r[n].marker)}),e},posFromIndex:function(e){var t,r=this.first,n=this.lineSeparator().length;return this.iter(function(i){var o=i.text.length+n;if(o>e)return t=e,!0;e-=o,++r}),U(this,E(r,t))},indexFromPos:function(e){var t=(e=U(this,e)).ch;if(e.line<this.first||e.ch<0)return 0;var r=this.lineSeparator().length;return this.iter(this.first,e.line,function(e){t+=e.text.length+r}),t},copy:function(e){var t=new Ds(O(this,this.first,this.first+this.size),this.modeOption,this.first,this.lineSep,this.direction);return t.scrollTop=this.scrollTop,t.scrollLeft=this.scrollLeft,t.sel=this.sel,t.extend=!1,e&&(t.history.undoDepth=this.history.undoDepth,t.setHistory(this.getHistory())),t},linkedDoc:function(e){e||(e={});var t=this.first,r=this.first+this.size;null!=e.from&&e.from>t&&(t=e.from),null!=e.to&&e.to<r&&(r=e.to);var n=new Ds(O(this,t,r),e.mode||this.modeOption,t,this.lineSep,this.direction);return e.sharedHist&&(n.history=this.history),(this.linked||(this.linked=[])).push({doc:n,sharedHist:e.sharedHist}),n.linked=[{doc:this,isParent:!0,sharedHist:e.sharedHist}],Yi(n,Xi(this)),n},unlinkDoc:function(e){var t=this;if(e instanceof jo&&(e=e.doc),this.linked)for(var r=0;r<this.linked.length;++r)if(t.linked[r].doc==e){t.linked.splice(r,1),e.unlinkDoc(t),_i(Xi(t));break}if(e.history==this.history){var n=[e.id];$n(e,function(e){return n.push(e.id)},!0),e.history=new Jn(null),e.history.done=fi(this.history.done,n),e.history.undone=fi(this.history.undone,n)}},iterLinkedDocs:function(e){$n(this,e)},getMode:function(){return this.mode},getEditor:function(){return this.cm},splitLines:function(e){return this.lineSep?e.split(this.lineSep):es(e)},lineSeparator:function(){return this.lineSep||"\n"},setDirection:gn(function(e){"rtl"!=e&&(e="ltr"),e!=this.direction&&(this.direction=e,this.iter(function(e){return e.order=null}),this.cm&&Qn(this.cm))})}),Ds.prototype.eachLine=Ds.prototype.iter;for(var Hs=0,Fs=!1,Es={3:"Enter",8:"Backspace",9:"Tab",13:"Enter",16:"Shift",17:"Ctrl",18:"Alt",19:"Pause",20:"CapsLock",27:"Esc",32:"Space",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"Left",38:"Up",39:"Right",40:"Down",44:"PrintScrn",45:"Insert",46:"Delete",59:";",61:"=",91:"Mod",92:"Mod",93:"Mod",106:"*",107:"=",109:"-",110:".",111:"/",127:"Delete",173:"-",186:";",187:"=",188:",",189:"-",190:".",191:"/",192:"`",219:"[",220:"\\",221:"]",222:"'",63232:"Up",63233:"Down",63234:"Left",63235:"Right",63272:"Delete",63273:"Home",63275:"End",63276:"PageUp",63277:"PageDown",63302:"Insert"},Ps=0;Ps<10;Ps++)Es[Ps+48]=Es[Ps+96]=String(Ps);for(var Is=65;Is<=90;Is++)Es[Is]=String.fromCharCode(Is);for(var zs=1;zs<=12;zs++)Es[zs+111]=Es[zs+63235]="F"+zs;var Rs={};Rs.basic={Left:"goCharLeft",Right:"goCharRight",Up:"goLineUp",Down:"goLineDown",End:"goLineEnd",Home:"goLineStartSmart",PageUp:"goPageUp",PageDown:"goPageDown",Delete:"delCharAfter",Backspace:"delCharBefore","Shift-Backspace":"delCharBefore",Tab:"defaultTab","Shift-Tab":"indentAuto",Enter:"newlineAndIndent",Insert:"toggleOverwrite",Esc:"singleSelection"},Rs.pcDefault={"Ctrl-A":"selectAll","Ctrl-D":"deleteLine","Ctrl-Z":"undo","Shift-Ctrl-Z":"redo","Ctrl-Y":"redo","Ctrl-Home":"goDocStart","Ctrl-End":"goDocEnd","Ctrl-Up":"goLineUp","Ctrl-Down":"goLineDown","Ctrl-Left":"goGroupLeft","Ctrl-Right":"goGroupRight","Alt-Left":"goLineStart","Alt-Right":"goLineEnd","Ctrl-Backspace":"delGroupBefore","Ctrl-Delete":"delGroupAfter","Ctrl-S":"save","Ctrl-F":"find","Ctrl-G":"findNext","Shift-Ctrl-G":"findPrev","Shift-Ctrl-F":"replace","Shift-Ctrl-R":"replaceAll","Ctrl-[":"indentLess","Ctrl-]":"indentMore","Ctrl-U":"undoSelection","Shift-Ctrl-U":"redoSelection","Alt-U":"redoSelection",fallthrough:"basic"},Rs.emacsy={"Ctrl-F":"goCharRight","Ctrl-B":"goCharLeft","Ctrl-P":"goLineUp","Ctrl-N":"goLineDown","Alt-F":"goWordRight","Alt-B":"goWordLeft","Ctrl-A":"goLineStart","Ctrl-E":"goLineEnd","Ctrl-V":"goPageDown","Shift-Ctrl-V":"goPageUp","Ctrl-D":"delCharAfter","Ctrl-H":"delCharBefore","Alt-D":"delWordAfter","Alt-Backspace":"delWordBefore","Ctrl-K":"killLine","Ctrl-T":"transposeChars","Ctrl-O":"openLine"},Rs.macDefault={"Cmd-A":"selectAll","Cmd-D":"deleteLine","Cmd-Z":"undo","Shift-Cmd-Z":"redo","Cmd-Y":"redo","Cmd-Home":"goDocStart","Cmd-Up":"goDocStart","Cmd-End":"goDocEnd","Cmd-Down":"goDocEnd","Alt-Left":"goGroupLeft","Alt-Right":"goGroupRight","Cmd-Left":"goLineLeft","Cmd-Right":"goLineRight","Alt-Backspace":"delGroupBefore","Ctrl-Alt-Backspace":"delGroupAfter","Alt-Delete":"delGroupAfter","Cmd-S":"save","Cmd-F":"find","Cmd-G":"findNext","Shift-Cmd-G":"findPrev","Cmd-Alt-F":"replace","Shift-Cmd-Alt-F":"replaceAll","Cmd-[":"indentLess","Cmd-]":"indentMore","Cmd-Backspace":"delWrappedLineLeft","Cmd-Delete":"delWrappedLineRight","Cmd-U":"undoSelection","Shift-Cmd-U":"redoSelection","Ctrl-Up":"goDocStart","Ctrl-Down":"goDocEnd",fallthrough:["basic","emacsy"]},Rs.default=Ml?Rs.macDefault:Rs.pcDefault;var Bs={selectAll:Mi,singleSelection:function(e){return e.setSelection(e.getCursor("anchor"),e.getCursor("head"),Gl)},killLine:function(e){return co(e,function(t){if(t.empty()){var r=M(e.doc,t.head.line).text.length;return t.head.ch==r&&t.head.line<e.lastLine()?{from:t.head,to:E(t.head.line+1,0)}:{from:t.head,to:E(t.head.line,r)}}return{from:t.from(),to:t.to()}})},deleteLine:function(e){return co(e,function(t){return{from:E(t.from().line,0),to:U(e.doc,E(t.to().line+1,0))}})},delLineLeft:function(e){return co(e,function(e){return{from:E(e.from().line,0),to:e.from()}})},delWrappedLineLeft:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5;return{from:e.coordsChar({left:0,top:r},"div"),to:t.from()}})},delWrappedLineRight:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5,n=e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div");return{from:t.from(),to:n}})},undo:function(e){return e.undo()},redo:function(e){return e.redo()},undoSelection:function(e){return e.undoSelection()},redoSelection:function(e){return e.redoSelection()},goDocStart:function(e){return e.extendSelection(E(e.firstLine(),0))},goDocEnd:function(e){return e.extendSelection(E(e.lastLine()))},goLineStart:function(e){return e.extendSelectionsBy(function(t){return vo(e,t.head.line)},{origin:"+move",bias:1})},goLineStartSmart:function(e){return e.extendSelectionsBy(function(t){return yo(e,t.head)},{origin:"+move",bias:1})},goLineEnd:function(e){return e.extendSelectionsBy(function(t){return mo(e,t.head.line)},{origin:"+move",bias:-1})},goLineRight:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div")},Vl)},goLineLeft:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:0,top:r},"div")},Vl)},goLineLeftSmart:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5,n=e.coordsChar({left:0,top:r},"div");return n.ch<e.getLine(n.line).search(/\S/)?yo(e,t.head):n},Vl)},goLineUp:function(e){return e.moveV(-1,"line")},goLineDown:function(e){return e.moveV(1,"line")},goPageUp:function(e){return e.moveV(-1,"page")},goPageDown:function(e){return e.moveV(1,"page")},goCharLeft:function(e){return e.moveH(-1,"char")},goCharRight:function(e){return e.moveH(1,"char")},goColumnLeft:function(e){return e.moveH(-1,"column")},goColumnRight:function(e){return e.moveH(1,"column")},goWordLeft:function(e){return e.moveH(-1,"word")},goGroupRight:function(e){return e.moveH(1,"group")},goGroupLeft:function(e){return e.moveH(-1,"group")},goWordRight:function(e){return e.moveH(1,"word")},delCharBefore:function(e){return e.deleteH(-1,"char")},delCharAfter:function(e){return e.deleteH(1,"char")},delWordBefore:function(e){return e.deleteH(-1,"word")},delWordAfter:function(e){return e.deleteH(1,"word")},delGroupBefore:function(e){return e.deleteH(-1,"group")},delGroupAfter:function(e){return e.deleteH(1,"group")},indentAuto:function(e){return e.indentSelection("smart")},indentMore:function(e){return e.indentSelection("add")},indentLess:function(e){return e.indentSelection("subtract")},insertTab:function(e){return e.replaceSelection("\t")},insertSoftTab:function(e){for(var t=[],r=e.listSelections(),n=e.options.tabSize,i=0;i<r.length;i++){var o=r[i].from(),l=f(e.getLine(o.line),o.ch,n);t.push(p(n-l%n))}e.replaceSelections(t)},defaultTab:function(e){e.somethingSelected()?e.indentSelection("add"):e.execCommand("insertTab")},transposeChars:function(e){return hn(e,function(){for(var t=e.listSelections(),r=[],n=0;n<t.length;n++)if(t[n].empty()){var i=t[n].head,o=M(e.doc,i.line).text;if(o)if(i.ch==o.length&&(i=new E(i.line,i.ch-1)),i.ch>0)i=new E(i.line,i.ch+1),e.replaceRange(o.charAt(i.ch-1)+o.charAt(i.ch-2),E(i.line,i.ch-2),i,"+transpose");else if(i.line>e.doc.first){var l=M(e.doc,i.line-1).text;l&&(i=new E(i.line,1),e.replaceRange(o.charAt(0)+e.doc.lineSeparator()+l.charAt(l.length-1),E(i.line-1,l.length-1),i,"+transpose"))}r.push(new Ts(i,i))}e.setSelections(r)})},newlineAndIndent:function(e){return hn(e,function(){for(var t=e.listSelections(),r=t.length-1;r>=0;r--)e.replaceRange(e.doc.lineSeparator(),t[r].anchor,t[r].head,"+input");t=e.listSelections();for(var n=0;n<t.length;n++)e.indentLine(t[n].from().line,null,!0);jr(e)})},openLine:function(e){return e.replaceSelection("\n","start")},toggleOverwrite:function(e){return e.toggleOverwrite()}},Gs=new Pl,Us=null,Vs=function(e,t,r){this.time=e,this.pos=t,this.button=r};Vs.prototype.compare=function(e,t,r){return this.time+400>e&&0==P(t,this.pos)&&r==this.button};var Ks,js,Xs={toString:function(){return"CodeMirror.Init"}},Ys={},_s={};jo.defaults=Ys,jo.optionHandlers=_s;var $s=[];jo.defineInitHook=function(e){return $s.push(e)};var qs=null,Zs=function(e){this.cm=e,this.lastAnchorNode=this.lastAnchorOffset=this.lastFocusNode=this.lastFocusOffset=null,this.polling=new Pl,this.composing=null,this.gracePeriod=!1,this.readDOMTimeout=null};Zs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()}),"cut"==e.type&&i.replaceSelection("",null,"cut");else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type&&i.operation(function(){i.setSelections(t.ranges,0,Gl),i.replaceSelection("",null,"cut")})}if(e.clipboardData){e.clipboardData.clearData();var r=qs.text.join("\n");if(e.clipboardData.setData("Text",r),e.clipboardData.getData("Text")==r)return void e.preventDefault()}var l=el(),s=l.firstChild;i.display.lineSpace.insertBefore(l,i.display.lineSpace.firstChild),s.value=qs.text.join("\n");var a=document.activeElement;El(s),setTimeout(function(){i.display.lineSpace.removeChild(l),a.focus(),a==o&&n.showPrimarySelection()},50)}}var r=this,n=this,i=n.cm,o=n.div=e.lineDiv;Jo(o,i.options.spellcheck),Ql(o,"paste",function(e){Me(i,e)||qo(e,i)||vl<=11&&setTimeout(dn(i,function(){return r.updateFromDOM()}),20)}),Ql(o,"compositionstart",function(e){r.composing={data:e.data,done:!1}}),Ql(o,"compositionupdate",function(e){r.composing||(r.composing={data:e.data,done:!1})}),Ql(o,"compositionend",function(e){r.composing&&(e.data!=r.composing.data&&r.readFromDOMSoon(),r.composing.done=!0)}),Ql(o,"touchstart",function(){return n.forceCompositionEnd()}),Ql(o,"input",function(){r.composing||r.readFromDOMSoon()}),Ql(o,"copy",t),Ql(o,"cut",t)},Zs.prototype.prepareSelection=function(){var e=Tr(this.cm,!1);return e.focus=this.cm.state.focused,e},Zs.prototype.showSelection=function(e,t){e&&this.cm.display.view.length&&((e.focus||t)&&this.showPrimarySelection(),this.showMultipleSelections(e))},Zs.prototype.showPrimarySelection=function(){var e=window.getSelection(),t=this.cm,r=t.doc.sel.primary(),n=r.from(),i=r.to();if(t.display.viewTo==t.display.viewFrom||n.line>=t.display.viewTo||i.line<t.display.viewFrom)e.removeAllRanges();else{var o=sl(t,e.anchorNode,e.anchorOffset),l=sl(t,e.focusNode,e.focusOffset);if(!o||o.bad||!l||l.bad||0!=P(B(o,l),n)||0!=P(R(o,l),i)){var s=t.display.view,a=n.line>=t.display.viewFrom&&nl(t,n)||{node:s[0].measure.map[2],offset:0},u=i.line<t.display.viewTo&&nl(t,i);if(!u){var c=s[s.length-1].measure,f=c.maps?c.maps[c.maps.length-1]:c.map;u={node:f[f.length-1],offset:f[f.length-2]-f[f.length-3]}}if(a&&u){var h,d=e.rangeCount&&e.getRangeAt(0);try{h=Wl(a.node,a.offset,u.offset,u.node)}catch(e){}h&&(!fl&&t.state.focused?(e.collapse(a.node,a.offset),h.collapsed||(e.removeAllRanges(),e.addRange(h))):(e.removeAllRanges(),e.addRange(h)),d&&null==e.anchorNode?e.addRange(d):fl&&this.startGracePeriod()),this.rememberSelection()}else e.removeAllRanges()}}},Zs.prototype.startGracePeriod=function(){var e=this;clearTimeout(this.gracePeriod),this.gracePeriod=setTimeout(function(){e.gracePeriod=!1,e.selectionChanged()&&e.cm.operation(function(){return e.cm.curOp.selectionChanged=!0})},20)},Zs.prototype.showMultipleSelections=function(e){r(this.cm.display.cursorDiv,e.cursors),r(this.cm.display.selectionDiv,e.selection)},Zs.prototype.rememberSelection=function(){var e=window.getSelection();this.lastAnchorNode=e.anchorNode,this.lastAnchorOffset=e.anchorOffset,this.lastFocusNode=e.focusNode,this.lastFocusOffset=e.focusOffset},Zs.prototype.selectionInEditor=function(){var e=window.getSelection();if(!e.rangeCount)return!1;var t=e.getRangeAt(0).commonAncestorContainer;return o(this.div,t)},Zs.prototype.focus=function(){"nocursor"!=this.cm.options.readOnly&&(this.selectionInEditor()||this.showSelection(this.prepareSelection(),!0),this.div.focus())},Zs.prototype.blur=function(){this.div.blur()},Zs.prototype.getField=function(){return this.div},Zs.prototype.supportsTouch=function(){return!0},Zs.prototype.receivedFocus=function(){function e(){t.cm.state.focused&&(t.pollSelection(),t.polling.set(t.cm.options.pollInterval,e))}var t=this;this.selectionInEditor()?this.pollSelection():hn(this.cm,function(){return t.cm.curOp.selectionChanged=!0}),this.polling.set(this.cm.options.pollInterval,e)},Zs.prototype.selectionChanged=function(){var e=window.getSelection();return e.anchorNode!=this.lastAnchorNode||e.anchorOffset!=this.lastAnchorOffset||e.focusNode!=this.lastFocusNode||e.focusOffset!=this.lastFocusOffset},Zs.prototype.pollSelection=function(){if(null==this.readDOMTimeout&&!this.gracePeriod&&this.selectionChanged()){var e=window.getSelection(),t=this.cm;if(kl&&bl&&this.cm.options.gutters.length&&il(e.anchorNode))return this.cm.triggerOnKeyDown({type:"keydown",keyCode:8,preventDefault:Math.abs}),this.blur(),void this.focus();if(!this.composing){this.rememberSelection();var r=sl(t,e.anchorNode,e.anchorOffset),n=sl(t,e.focusNode,e.focusOffset);r&&n&&hn(t,function(){bi(t.doc,Rn(r,n),Gl),(r.bad||n.bad)&&(t.curOp.selectionChanged=!0)})}}},Zs.prototype.pollContent=function(){null!=this.readDOMTimeout&&(clearTimeout(this.readDOMTimeout),this.readDOMTimeout=null);var e=this.cm,t=e.display,r=e.doc.sel.primary(),n=r.from(),i=r.to();if(0==n.ch&&n.line>e.firstLine()&&(n=E(n.line-1,M(e.doc,n.line-1).length)),i.ch==M(e.doc,i.line).text.length&&i.line<e.lastLine()&&(i=E(i.line+1,0)),n.line<t.viewFrom||i.line>t.viewTo-1)return!1;var o,l,s;n.line==t.viewFrom||0==(o=Lr(e,n.line))?(l=W(t.view[0].line),s=t.view[0].node):(l=W(t.view[o].line),s=t.view[o-1].node.nextSibling);var a,u,c=Lr(e,i.line);if(c==t.view.length-1?(a=t.viewTo-1,u=t.lineDiv.lastChild):(a=W(t.view[c+1].line)-1,u=t.view[c+1].node.previousSibling),!s)return!1;for(var f=e.doc.splitLines(ll(e,s,u,l,a)),h=N(e.doc,E(l,0),E(a,M(e.doc,a).text.length));f.length>1&&h.length>1;)if(g(f)==g(h))f.pop(),h.pop(),a--;else{if(f[0]!=h[0])break;f.shift(),h.shift(),l++}for(var d=0,p=0,v=f[0],m=h[0],y=Math.min(v.length,m.length);d<y&&v.charCodeAt(d)==m.charCodeAt(d);)++d;for(var b=g(f),w=g(h),x=Math.min(b.length-(1==f.length?d:0),w.length-(1==h.length?d:0));p<x&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)++p;if(1==f.length&&1==h.length&&l==n.line)for(;d&&d>n.ch&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)d--,p++;f[f.length-1]=b.slice(0,b.length-p).replace(/^\u200b+/,""),f[0]=f[0].slice(d).replace(/\u200b+$/,"");var C=E(l,d),S=E(a,h.length?g(h).length-p:0);return f.length>1||f[0]||P(C,S)?(Ei(e.doc,f,C,S,"+input"),!0):void 0},Zs.prototype.ensurePolled=function(){this.forceCompositionEnd()},Zs.prototype.reset=function(){this.forceCompositionEnd()},Zs.prototype.forceCompositionEnd=function(){this.composing&&(clearTimeout(this.readDOMTimeout),this.composing=null,this.updateFromDOM(),this.div.blur(),this.div.focus())},Zs.prototype.readFromDOMSoon=function(){var e=this;null==this.readDOMTimeout&&(this.readDOMTimeout=setTimeout(function(){if(e.readDOMTimeout=null,e.composing){if(!e.composing.done)return;e.composing=null}e.updateFromDOM()},80))},Zs.prototype.updateFromDOM=function(){var e=this;!this.cm.isReadOnly()&&this.pollContent()||hn(this.cm,function(){return vn(e.cm)})},Zs.prototype.setUneditable=function(e){e.contentEditable="false"},Zs.prototype.onKeyPress=function(e){0!=e.charCode&&(e.preventDefault(),this.cm.isReadOnly()||dn(this.cm,$o)(this.cm,String.fromCharCode(null==e.charCode?e.keyCode:e.charCode),0))},Zs.prototype.readOnlyChanged=function(e){this.div.contentEditable=String("nocursor"!=e)},Zs.prototype.onContextMenu=function(){},Zs.prototype.resetPosition=function(){},Zs.prototype.needsContentAttribute=!0;var Qs=function(e){this.cm=e,this.prevInput="",this.pollingFast=!1,this.polling=new Pl,this.hasSelection=!1,this.composing=null};Qs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()});else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type?i.setSelections(t.ranges,null,Gl):(n.prevInput="",l.value=t.text.join("\n"),El(l))}"cut"==e.type&&(i.state.cutIncoming=!0)}}var r=this,n=this,i=this.cm,o=this.wrapper=el(),l=this.textarea=o.firstChild;e.wrapper.insertBefore(o,e.wrapper.firstChild),Ll&&(l.style.width="0px"),Ql(l,"input",function(){gl&&vl>=9&&r.hasSelection&&(r.hasSelection=null),n.poll()}),Ql(l,"paste",function(e){Me(i,e)||qo(e,i)||(i.state.pasteIncoming=!0,n.fastPoll())}),Ql(l,"cut",t),Ql(l,"copy",t),Ql(e.scroller,"paste",function(t){Ft(e,t)||Me(i,t)||(i.state.pasteIncoming=!0,n.focus())}),Ql(e.lineSpace,"selectstart",function(t){Ft(e,t)||We(t)}),Ql(l,"compositionstart",function(){var e=i.getCursor("from");n.composing&&n.composing.range.clear(),n.composing={start:e,range:i.markText(e,i.getCursor("to"),{className:"CodeMirror-composing"})}}),Ql(l,"compositionend",function(){n.composing&&(n.poll(),n.composing.range.clear(),n.composing=null)})},Qs.prototype.prepareSelection=function(){var e=this.cm,t=e.display,r=e.doc,n=Tr(e);if(e.options.moveInputWithCursor){var i=sr(e,r.sel.primary().head,"div"),o=t.wrapper.getBoundingClientRect(),l=t.lineDiv.getBoundingClientRect();n.teTop=Math.max(0,Math.min(t.wrapper.clientHeight-10,i.top+l.top-o.top)),n.teLeft=Math.max(0,Math.min(t.wrapper.clientWidth-10,i.left+l.left-o.left))}return n},Qs.prototype.showSelection=function(e){var t=this.cm.display;r(t.cursorDiv,e.cursors),r(t.selectionDiv,e.selection),null!=e.teTop&&(this.wrapper.style.top=e.teTop+"px",this.wrapper.style.left=e.teLeft+"px")},Qs.prototype.reset=function(e){if(!this.contextMenuPending&&!this.composing){var t=this.cm;if(t.somethingSelected()){this.prevInput="";var r=t.getSelection();this.textarea.value=r,t.state.focused&&El(this.textarea),gl&&vl>=9&&(this.hasSelection=r)}else e||(this.prevInput=this.textarea.value="",gl&&vl>=9&&(this.hasSelection=null))}},Qs.prototype.getField=function(){return this.textarea},Qs.prototype.supportsTouch=function(){return!1},Qs.prototype.focus=function(){if("nocursor"!=this.cm.options.readOnly&&(!Tl||l()!=this.textarea))try{this.textarea.focus()}catch(e){}},Qs.prototype.blur=function(){this.textarea.blur()},Qs.prototype.resetPosition=function(){this.wrapper.style.top=this.wrapper.style.left=0},Qs.prototype.receivedFocus=function(){this.slowPoll()},Qs.prototype.slowPoll=function(){var e=this;this.pollingFast||this.polling.set(this.cm.options.pollInterval,function(){e.poll(),e.cm.state.focused&&e.slowPoll()})},Qs.prototype.fastPoll=function(){function e(){r.poll()||t?(r.pollingFast=!1,r.slowPoll()):(t=!0,r.polling.set(60,e))}var t=!1,r=this;r.pollingFast=!0,r.polling.set(20,e)},Qs.prototype.poll=function(){var e=this,t=this.cm,r=this.textarea,n=this.prevInput;if(this.contextMenuPending||!t.state.focused||ts(r)&&!n&&!this.composing||t.isReadOnly()||t.options.disableInput||t.state.keySeq)return!1;var i=r.value;if(i==n&&!t.somethingSelected())return!1;if(gl&&vl>=9&&this.hasSelection===i||Ml&&/[\uf700-\uf7ff]/.test(i))return t.display.input.reset(),!1;if(t.doc.sel==t.display.selForContextMenu){var o=i.charCodeAt(0);if(8203!=o||n||(n="​"),8666==o)return this.reset(),this.cm.execCommand("undo")}for(var l=0,s=Math.min(n.length,i.length);l<s&&n.charCodeAt(l)==i.charCodeAt(l);)++l;return hn(t,function(){$o(t,i.slice(l),n.length-l,null,e.composing?"*compose":null),i.length>1e3||i.indexOf("\n")>-1?r.value=e.prevInput="":e.prevInput=i,e.composing&&(e.composing.range.clear(),e.composing.range=t.markText(e.composing.start,t.getCursor("to"),{className:"CodeMirror-composing"}))}),!0},Qs.prototype.ensurePolled=function(){this.pollingFast&&this.poll()&&(this.pollingFast=!1)},Qs.prototype.onKeyPress=function(){gl&&vl>=9&&(this.hasSelection=null),this.fastPoll()},Qs.prototype.onContextMenu=function(e){function t(){if(null!=l.selectionStart){var e=i.somethingSelected(),t="​"+(e?l.value:"");l.value="⇚",l.value=t,n.prevInput=e?"":"​",l.selectionStart=1,l.selectionEnd=t.length,o.selForContextMenu=i.doc.sel}}function r(){if(n.contextMenuPending=!1,n.wrapper.style.cssText=c,l.style.cssText=u,gl&&vl<9&&o.scrollbars.setScrollTop(o.scroller.scrollTop=a),null!=l.selectionStart){(!gl||gl&&vl<9)&&t();var e=0,r=function(){o.selForContextMenu==i.doc.sel&&0==l.selectionStart&&l.selectionEnd>0&&"​"==n.prevInput?dn(i,Mi)(i):e++<10?o.detectingSelectAll=setTimeout(r,500):(o.selForContextMenu=null,o.input.reset())};o.detectingSelectAll=setTimeout(r,200)}}var n=this,i=n.cm,o=i.display,l=n.textarea,s=Sr(i,e),a=o.scroller.scrollTop;if(s&&!wl){i.options.resetSelectionOnContextMenu&&-1==i.doc.sel.contains(s)&&dn(i,bi)(i.doc,Rn(s),Gl);var u=l.style.cssText,c=n.wrapper.style.cssText;n.wrapper.style.cssText="position: absolute";var f=n.wrapper.getBoundingClientRect();l.style.cssText="position: absolute; width: 30px; height: 30px;\n      top: "+(e.clientY-f.top-5)+"px; left: "+(e.clientX-f.left-5)+"px;\n      z-index: 1000; background: "+(gl?"rgba(255, 255, 255, .05)":"transparent")+";\n      outline: none; border-width: 0; outline: none; overflow: hidden; opacity: .05; filter: alpha(opacity=5);";var h;if(ml&&(h=window.scrollY),o.input.focus(),ml&&window.scrollTo(null,h),o.input.reset(),i.somethingSelected()||(l.value=n.prevInput=" "),n.contextMenuPending=!0,o.selForContextMenu=i.doc.sel,clearTimeout(o.detectingSelectAll),gl&&vl>=9&&t(),Hl){Fe(e);var d=function(){ke(window,"mouseup",d),setTimeout(r,20)};Ql(window,"mouseup",d)}else setTimeout(r,50)}},Qs.prototype.readOnlyChanged=function(e){e||this.reset(),this.textarea.disabled="nocursor"==e},Qs.prototype.setUneditable=function(){},Qs.prototype.needsContentAttribute=!1,function(e){function t(t,n,i,o){e.defaults[t]=n,i&&(r[t]=o?function(e,t,r){r!=Xs&&i(e,t,r)}:i)}var r=e.optionHandlers;e.defineOption=t,e.Init=Xs,t("value","",function(e,t){return e.setValue(t)},!0),t("mode",null,function(e,t){e.doc.modeOption=t,jn(e)},!0),t("indentUnit",2,jn,!0),t("indentWithTabs",!1),t("smartIndent",!0),t("tabSize",4,function(e){Xn(e),er(e),vn(e)},!0),t("lineSeparator",null,function(e,t){if(e.doc.lineSep=t,t){var r=[],n=e.doc.first;e.doc.iter(function(e){for(var i=0;;){var o=e.text.indexOf(t,i);if(-1==o)break;i=o+t.length,r.push(E(n,o))}n++});for(var i=r.length-1;i>=0;i--)Ei(e.doc,t,r[i],E(r[i].line,r[i].ch+t.length))}}),t("specialChars",/[\u0000-\u001f\u007f-\u009f\u00ad\u061c\u200b-\u200f\u2028\u2029\ufeff]/g,function(e,t,r){e.state.specialChars=new RegExp(t.source+(t.test("\t")?"":"|\t"),"g"),r!=Xs&&e.refresh()}),t("specialCharPlaceholder",at,function(e){return e.refresh()},!0),t("electricChars",!0),t("inputStyle",Tl?"contenteditable":"textarea",function(){throw new Error("inputStyle can not (yet) be changed in a running editor")},!0),t("spellcheck",!1,function(e,t){return e.getInputField().spellcheck=t},!0),t("rtlMoveVisually",!Ol),t("wholeLineUpdateBefore",!0),t("theme","default",function(e){Go(e),Uo(e)},!0),t("keyMap","default",function(e,t,r){var n=uo(t),i=r!=Xs&&uo(r);i&&i.detach&&i.detach(e,n),n.attach&&n.attach(e,i||null)}),t("extraKeys",null),t("configureMouse",null),t("lineWrapping",!1,Ko,!0),t("gutters",[],function(e){Fn(e.options),Uo(e)},!0),t("fixedGutter",!0,function(e,t){e.display.gutters.style.left=t?wr(e.display)+"px":"0",e.refresh()},!0),t("coverGutterNextToScrollbar",!1,function(e){return en(e)},!0),t("scrollbarStyle","native",function(e){rn(e),en(e),e.display.scrollbars.setScrollTop(e.doc.scrollTop),e.display.scrollbars.setScrollLeft(e.doc.scrollLeft)},!0),t("lineNumbers",!1,function(e){Fn(e.options),Uo(e)},!0),t("firstLineNumber",1,Uo,!0),t("lineNumberFormatter",function(e){return e},Uo,!0),t("showCursorWhenSelecting",!1,kr,!0),t("resetSelectionOnContextMenu",!0),t("lineWiseCopyCut",!0),t("pasteLinesPerSelection",!0),t("readOnly",!1,function(e,t){"nocursor"==t&&(Fr(e),e.display.input.blur()),e.display.input.readOnlyChanged(t)}),t("disableInput",!1,function(e,t){t||e.display.input.reset()},!0),t("dragDrop",!0,Vo),t("allowDropFileTypes",null),t("cursorBlinkRate",530),t("cursorScrollMargin",0),t("cursorHeight",1,kr,!0),t("singleCursorHeightPerLine",!0,kr,!0),t("workTime",100),t("workDelay",100),t("flattenSpans",!0,Xn,!0),t("addModeClass",!1,Xn,!0),t("pollInterval",100),t("undoDepth",200,function(e,t){return e.doc.history.undoDepth=t}),t("historyEventDelay",1250),t("viewportMargin",10,function(e){return e.refresh()},!0),t("maxHighlightLength",1e4,Xn,!0),t("moveInputWithCursor",!0,function(e,t){t||e.display.input.resetPosition()}),t("tabindex",null,function(e,t){return e.display.input.getField().tabIndex=t||""}),t("autofocus",null),t("direction","ltr",function(e,t){return e.doc.setDirection(t)},!0)}(jo),function(e){var t=e.optionHandlers,r=e.helpers={};e.prototype={constructor:e,focus:function(){window.focus(),this.display.input.focus()},setOption:function(e,r){var n=this.options,i=n[e];n[e]==r&&"mode"!=e||(n[e]=r,t.hasOwnProperty(e)&&dn(this,t[e])(this,r,i),Te(this,"optionChange",this,e))},getOption:function(e){return this.options[e]},getDoc:function(){return this.doc},addKeyMap:function(e,t){this.state.keyMaps[t?"push":"unshift"](uo(e))},removeKeyMap:function(e){for(var t=this.state.keyMaps,r=0;r<t.length;++r)if(t[r]==e||t[r].name==e)return t.splice(r,1),!0},addOverlay:pn(function(t,r){var n=t.token?t:e.getMode(this.options,t);if(n.startState)throw new Error("Overlays may not be stateful.");m(this.state.overlays,{mode:n,modeSpec:t,opaque:r&&r.opaque,priority:r&&r.priority||0},function(e){return e.priority}),this.state.modeGen++,vn(this)}),removeOverlay:pn(function(e){for(var t=this,r=this.state.overlays,n=0;n<r.length;++n){var i=r[n].modeSpec;if(i==e||"string"==typeof e&&i.name==e)return r.splice(n,1),t.state.modeGen++,void vn(t)}}),indentLine:pn(function(e,t,r){"string"!=typeof t&&"number"!=typeof t&&(t=null==t?this.options.smartIndent?"smart":"prev":t?"add":"subtract"),H(this.doc,e)&&Yo(this,e,t,r)}),indentSelection:pn(function(e){for(var t=this,r=this.doc.sel.ranges,n=-1,i=0;i<r.length;i++){var o=r[i];if(o.empty())o.head.line>n&&(Yo(t,o.head.line,e,!0),n=o.head.line,i==t.doc.sel.primIndex&&jr(t));else{var l=o.from(),s=o.to(),a=Math.max(n,l.line);n=Math.min(t.lastLine(),s.line-(s.ch?0:1))+1;for(var u=a;u<n;++u)Yo(t,u,e);var c=t.doc.sel.ranges;0==l.ch&&r.length==c.length&&c[i].from().ch>0&&gi(t.doc,i,new Ts(l,c[i].to()),Gl)}}}),getTokenAt:function(e,t){return Je(this,e,t)},getLineTokens:function(e,t){return Je(this,E(e),t,!0)},getTokenTypeAt:function(e){e=U(this.doc,e);var t,r=_e(this,M(this.doc,e.line)),n=0,i=(r.length-1)/2,o=e.ch;if(0==o)t=r[2];else for(;;){var l=n+i>>1;if((l?r[2*l-1]:0)>=o)i=l;else{if(!(r[2*l+1]<o)){t=r[2*l+2];break}n=l+1}}var s=t?t.indexOf("overlay "):-1;return s<0?t:0==s?null:t.slice(0,s-1)},getModeAt:function(t){var r=this.doc.mode;return r.innerMode?e.innerMode(r,this.getTokenAt(t).state).mode:r},getHelper:function(e,t){return this.getHelpers(e,t)[0]},getHelpers:function(e,t){var n=this,i=[];if(!r.hasOwnProperty(t))return i;var o=r[t],l=this.getModeAt(e);if("string"==typeof l[t])o[l[t]]&&i.push(o[l[t]]);else if(l[t])for(var s=0;s<l[t].length;s++){var a=o[l[t][s]];a&&i.push(a)}else l.helperType&&o[l.helperType]?i.push(o[l.helperType]):o[l.name]&&i.push(o[l.name]);for(var u=0;u<o._global.length;u++){var c=o._global[u];c.pred(l,n)&&-1==h(i,c.val)&&i.push(c.val)}return i},getStateAfter:function(e,t){var r=this.doc;return e=G(r,null==e?r.first+r.size-1:e),$e(this,e+1,t).state},cursorCoords:function(e,t){var r,n=this.doc.sel.primary();return r=null==e?n.head:"object"==typeof e?U(this.doc,e):e?n.from():n.to(),sr(this,r,t||"page")},charCoords:function(e,t){return lr(this,U(this.doc,e),t||"page")},coordsChar:function(e,t){return e=or(this,e,t||"page"),cr(this,e.left,e.top)},lineAtHeight:function(e,t){return e=or(this,{top:e,left:0},t||"page").top,D(this.doc,e+this.display.viewOffset)},heightAtLine:function(e,t,r){var n,i=!1;if("number"==typeof e){var o=this.doc.first+this.doc.size-1;e<this.doc.first?e=this.doc.first:e>o&&(e=o,i=!0),n=M(this.doc,e)}else n=e;return ir(this,n,{top:0,left:0},t||"page",r||i).top+(i?this.doc.height-ye(n):0)},defaultTextHeight:function(){return mr(this.display)},defaultCharWidth:function(){return yr(this.display)},getViewport:function(){return{from:this.display.viewFrom,to:this.display.viewTo}},addWidget:function(e,t,r,n,i){var o=this.display,l=(e=sr(this,U(this.doc,e))).bottom,s=e.left;if(t.style.position="absolute",t.setAttribute("cm-ignore-events","true"),this.display.input.setUneditable(t),o.sizer.appendChild(t),"over"==n)l=e.top;else if("above"==n||"near"==n){var a=Math.max(o.wrapper.clientHeight,this.doc.height),u=Math.max(o.sizer.clientWidth,o.lineSpace.clientWidth);("above"==n||e.bottom+t.offsetHeight>a)&&e.top>t.offsetHeight?l=e.top-t.offsetHeight:e.bottom+t.offsetHeight<=a&&(l=e.bottom),s+t.offsetWidth>u&&(s=u-t.offsetWidth)}t.style.top=l+"px",t.style.left=t.style.right="","right"==i?(s=o.sizer.clientWidth-t.offsetWidth,t.style.right="0px"):("left"==i?s=0:"middle"==i&&(s=(o.sizer.clientWidth-t.offsetWidth)/2),t.style.left=s+"px"),r&&Ur(this,{left:s,top:l,right:s+t.offsetWidth,bottom:l+t.offsetHeight})},triggerOnKeyDown:pn(Lo),triggerOnKeyPress:pn(Mo),triggerOnKeyUp:To,triggerOnMouseDown:pn(Oo),execCommand:function(e){if(Bs.hasOwnProperty(e))return Bs[e].call(null,this)},triggerElectric:pn(function(e){Zo(this,e)}),findPosH:function(e,t,r,n){var i=this,o=1;t<0&&(o=-1,t=-t);for(var l=U(this.doc,e),s=0;s<t&&!(l=tl(i.doc,l,o,r,n)).hitSide;++s);return l},moveH:pn(function(e,t){var r=this;this.extendSelectionsBy(function(n){return r.display.shift||r.doc.extend||n.empty()?tl(r.doc,n.head,e,t,r.options.rtlMoveVisually):e<0?n.from():n.to()},Vl)}),deleteH:pn(function(e,t){var r=this.doc.sel,n=this.doc;r.somethingSelected()?n.replaceSelection("",null,"+delete"):co(this,function(r){var i=tl(n,r.head,e,t,!1);return e<0?{from:i,to:r.head}:{from:r.head,to:i}})}),findPosV:function(e,t,r,n){var i=this,o=1,l=n;t<0&&(o=-1,t=-t);for(var s=U(this.doc,e),a=0;a<t;++a){var u=sr(i,s,"div");if(null==l?l=u.left:u.left=l,(s=rl(i,u,o,r)).hitSide)break}return s},moveV:pn(function(e,t){var r=this,n=this.doc,i=[],o=!this.display.shift&&!n.extend&&n.sel.somethingSelected();if(n.extendSelectionsBy(function(l){if(o)return e<0?l.from():l.to();var s=sr(r,l.head,"div");null!=l.goalColumn&&(s.left=l.goalColumn),i.push(s.left);var a=rl(r,s,e,t);return"page"==t&&l==n.sel.primary()&&Kr(r,lr(r,a,"div").top-s.top),a},Vl),i.length)for(var l=0;l<n.sel.ranges.length;l++)n.sel.ranges[l].goalColumn=i[l]}),findWordAt:function(e){var t=M(this.doc,e.line).text,r=e.ch,n=e.ch;if(t){var i=this.getHelper(e,"wordChars");"before"!=e.sticky&&n!=t.length||!r?++n:--r;for(var o=t.charAt(r),l=x(o,i)?function(e){return x(e,i)}:/\s/.test(o)?function(e){return/\s/.test(e)}:function(e){return!/\s/.test(e)&&!x(e)};r>0&&l(t.charAt(r-1));)--r;for(;n<t.length&&l(t.charAt(n));)++n}return new Ts(E(e.line,r),E(e.line,n))},toggleOverwrite:function(e){null!=e&&e==this.state.overwrite||((this.state.overwrite=!this.state.overwrite)?s(this.display.cursorDiv,"CodeMirror-overwrite"):Fl(this.display.cursorDiv,"CodeMirror-overwrite"),Te(this,"overwriteToggle",this,this.state.overwrite))},hasFocus:function(){return this.display.input.getField()==l()},isReadOnly:function(){return!(!this.options.readOnly&&!this.doc.cantEdit)},scrollTo:pn(function(e,t){Xr(this,e,t)}),getScrollInfo:function(){var e=this.display.scroller;return{left:e.scrollLeft,top:e.scrollTop,height:e.scrollHeight-zt(this)-this.display.barHeight,width:e.scrollWidth-zt(this)-this.display.barWidth,clientHeight:Bt(this),clientWidth:Rt(this)}},scrollIntoView:pn(function(e,t){null==e?(e={from:this.doc.sel.primary().head,to:null},null==t&&(t=this.options.cursorScrollMargin)):"number"==typeof e?e={from:E(e,0),to:null}:null==e.from&&(e={from:e,to:null}),e.to||(e.to=e.from),e.margin=t||0,null!=e.from.line?Yr(this,e):$r(this,e.from,e.to,e.margin)}),setSize:pn(function(e,t){var r=this,n=function(e){return"number"==typeof e||/^\d+$/.test(String(e))?e+"px":e};null!=e&&(this.display.wrapper.style.width=n(e)),null!=t&&(this.display.wrapper.style.height=n(t)),this.options.lineWrapping&&Jt(this);var i=this.display.viewFrom;this.doc.iter(i,this.display.viewTo,function(e){if(e.widgets)for(var t=0;t<e.widgets.length;t++)if(e.widgets[t].noHScroll){mn(r,i,"widget");break}++i}),this.curOp.forceUpdate=!0,Te(this,"refresh",this)}),operation:function(e){return hn(this,e)},startOperation:function(){return nn(this)},endOperation:function(){return on(this)},refresh:pn(function(){var e=this.display.cachedTextHeight;vn(this),this.curOp.forceUpdate=!0,er(this),Xr(this,this.doc.scrollLeft,this.doc.scrollTop),Wn(this),(null==e||Math.abs(e-mr(this.display))>.5)&&Cr(this),Te(this,"refresh",this)}),swapDoc:pn(function(e){var t=this.doc;return t.cm=null,qn(this,e),er(this),this.display.input.reset(),Xr(this,e.scrollLeft,e.scrollTop),this.curOp.forceScroll=!0,bt(this,"swapDoc",this,t),t}),getInputField:function(){return this.display.input.getField()},getWrapperElement:function(){return this.display.wrapper},getScrollerElement:function(){return this.display.scroller},getGutterElement:function(){return this.display.gutters}},Ae(e),e.registerHelper=function(t,n,i){r.hasOwnProperty(t)||(r[t]=e[t]={_global:[]}),r[t][n]=i},e.registerGlobalHelper=function(t,n,i,o){e.registerHelper(t,n,o),r[t]._global.push({pred:i,val:o})}}(jo);var Js="iter insert remove copy getEditor constructor".split(" ");for(var ea in Ds.prototype)Ds.prototype.hasOwnProperty(ea)&&h(Js,ea)<0&&(jo.prototype[ea]=function(e){return function(){return e.apply(this.doc,arguments)}}(Ds.prototype[ea]));return Ae(Ds),jo.inputStyles={textarea:Qs,contenteditable:Zs},jo.defineMode=function(e){jo.defaults.mode||"null"==e||(jo.defaults.mode=e),Be.apply(this,arguments)},jo.defineMIME=function(e,t){os[e]=t},jo.defineMode("null",function(){return{token:function(e){return e.skipToEnd()}}}),jo.defineMIME("text/plain","null"),jo.defineExtension=function(e,t){jo.prototype[e]=t},jo.defineDocExtension=function(e,t){Ds.prototype[e]=t},jo.fromTextArea=function(e,t){function r(){e.value=a.getValue()}if(t=t?c(t):{},t.value=e.value,!t.tabindex&&e.tabIndex&&(t.tabindex=e.tabIndex),!t.placeholder&&e.placeholder&&(t.placeholder=e.placeholder),null==t.autofocus){var n=l();t.autofocus=n==e||null!=e.getAttribute("autofocus")&&n==document.body}var i;if(e.form&&(Ql(e.form,"submit",r),!t.leaveSubmitMethodAlone)){var o=e.form;i=o.submit;try{var s=o.submit=function(){r(),o.submit=i,o.submit(),o.submit=s}}catch(e){}}t.finishInit=function(t){t.save=r,t.getTextArea=function(){return e},t.toTextArea=function(){t.toTextArea=isNaN,r(),e.parentNode.removeChild(t.getWrapperElement()),e.style.display="",e.form&&(ke(e.form,"submit",r),"function"==typeof e.form.submit&&(e.form.submit=i))}},e.style.display="none";var a=jo(function(t){return e.parentNode.insertBefore(t,e.nextSibling)},t);return a},function(e){e.off=ke,e.on=Ql,e.wheelEventPixels=Pn,e.Doc=Ds,e.splitLines=es,e.countColumn=f,e.findColumn=d,e.isWordChar=w,e.Pass=Bl,e.signal=Te,e.Line=fs,e.changeEnd=Bn,e.scrollbarModel=ws,e.Pos=E,e.cmpPos=P,e.modes=is,e.mimeModes=os,e.resolveMode=Ge,e.getMode=Ue,e.modeExtensions=ls,e.extendMode=Ve,e.copyState=Ke,e.startState=Xe,e.innerMode=je,e.commands=Bs,e.keyMap=Rs,e.keyName=ao,e.isModifierKey=lo,e.lookupKey=oo,e.normalizeKeyMap=io,e.StringStream=ss,e.SharedTextMarker=As,e.TextMarker=Os,e.LineWidget=Ms,e.e_preventDefault=We,e.e_stopPropagation=De,e.e_stop=Fe,e.addClass=s,e.contains=o,e.rmClass=Fl,e.keyNames=Es}(jo),jo.version="5.30.0",jo});
      !function(e){"object"==typeof exports&&"object"==typeof module?e(require("../../lib/codemirror")):"function"==typeof define&&define.amd?define(["../../lib/codemirror"],e):e(CodeMirror)}(function(e){"use strict";function t(e,t,n,r,o,a){this.indented=e,this.column=t,this.type=n,this.info=r,this.align=o,this.prev=a}function n(e,n,r,o){var a=e.indented;return e.context&&"statement"==e.context.type&&"statement"!=r&&(a=e.context.indented),e.context=new t(a,n,r,o,null,e.context)}function r(e){var t=e.context.type;return")"!=t&&"]"!=t&&"}"!=t||(e.indented=e.context.indented),e.context=e.context.prev}function o(e,t,n){return"variable"==t.prevToken||"type"==t.prevToken||(!!/\S(?:[^- ]>|[*\]])\s*$|\*$/.test(e.string.slice(0,n))||(!(!t.typeAtEndOfLine||e.column()!=e.indentation())||void 0))}function a(e){for(;;){if(!e||"top"==e.type)return!0;if("}"==e.type&&"namespace"!=e.prev.info)return!1;e=e.prev}}function i(e){for(var t={},n=e.split(" "),r=0;r<n.length;++r)t[n[r]]=!0;return t}function l(e,t){return"function"==typeof e?e(t):e.propertyIsEnumerable(t)}function s(e,t){if(!t.startOfLine)return!1;for(var n,r=null;n=e.peek();){if("\\"==n&&e.match(/^.$/)){r=s;break}if("/"==n&&e.match(/^\/[\/\*]/,!1))break;e.next()}return t.tokenize=r,"meta"}function c(e,t){return"type"==t.prevToken&&"type"}function u(e){return e.eatWhile(/[\w\.']/),"number"}function d(e,t){if(e.backUp(1),e.match(/(R|u8R|uR|UR|LR)/)){var n=e.match(/"([^\s\\()]{0,16})\(/);return!!n&&(t.cpp11RawStringDelim=n[1],t.tokenize=m,m(e,t))}return e.match(/(u8|u|U|L)/)?!!e.match(/["']/,!1)&&"string":(e.next(),!1)}function f(e){var t=/(\w+)::~?(\w+)$/.exec(e);return t&&t[1]==t[2]}function p(e,t){for(var n;null!=(n=e.next());)if('"'==n&&!e.eat('"')){t.tokenize=null;break}return"string"}function m(e,t){var n=t.cpp11RawStringDelim.replace(/[^\w\s]/g,"\\$&");return e.match(new RegExp(".*?\\)"+n+'"'))?t.tokenize=null:e.skipToEnd(),"string"}function h(t,n){function r(e){if(e)for(var t in e)e.hasOwnProperty(t)&&o.push(t)}"string"==typeof t&&(t=[t]);var o=[];r(n.keywords),r(n.types),r(n.builtin),r(n.atoms),o.length&&(n.helperType=t[0],e.registerHelper("hintWords",t[0],o));for(var a=0;a<t.length;++a)e.defineMIME(t[a],n)}function g(e,t){for(var n=!1;!e.eol();){if(!n&&e.match('"""')){t.tokenize=null;break}n="\\"==e.next()&&!n}return"string"}function y(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!e&&!o&&t.match('"')){a=!0;break}if(e&&t.match('"""')){a=!0;break}r=t.next(),!o&&"$"==r&&t.match("{")&&t.skipTo("}"),o=!o&&"\\"==r&&!e}return!a&&e||(n.tokenize=null),"string"}}function x(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!o&&t.match('"')&&("single"==e||t.match('""'))){a=!0;break}if(!o&&t.match("``")){w=x(e),a=!0;break}r=t.next(),o="single"==e&&!o&&"\\"==r}return a&&(n.tokenize=null),"string"}}e.defineMode("clike",function(i,s){function c(e,t){var n=e.next();if(S[n]){var r=S[n](e,t);if(!1!==r)return r}if('"'==n||"'"==n)return t.tokenize=u(n),t.tokenize(e,t);if(D.test(n))return p=n,null;if(L.test(n)){if(e.backUp(1),e.match(I))return"number";e.next()}if("/"==n){if(e.eat("*"))return t.tokenize=d,d(e,t);if(e.eat("/"))return e.skipToEnd(),"comment"}if(F.test(n)){for(;!e.match(/^\/[\/*]/,!1)&&e.eat(F););return"operator"}if(e.eatWhile(z),P)for(;e.match(P);)e.eatWhile(z);var o=e.current();return l(x,o)?(l(w,o)&&(p="newstatement"),l(v,o)&&(m=!0),"keyword"):l(b,o)?"type":l(k,o)?(l(w,o)&&(p="newstatement"),"builtin"):l(_,o)?"atom":"variable"}function u(e){return function(t,n){for(var r,o=!1,a=!1;null!=(r=t.next());){if(r==e&&!o){a=!0;break}o=!o&&"\\"==r}return(a||!o&&!C)&&(n.tokenize=null),"string"}}function d(e,t){for(var n,r=!1;n=e.next();){if("/"==n&&r){t.tokenize=null;break}r="*"==n}return"comment"}function f(e,t){s.typeFirstDefinitions&&e.eol()&&a(t.context)&&(t.typeAtEndOfLine=o(e,t,e.pos))}var p,m,h=i.indentUnit,g=s.statementIndentUnit||h,y=s.dontAlignCalls,x=s.keywords||{},b=s.types||{},k=s.builtin||{},w=s.blockKeywords||{},v=s.defKeywords||{},_=s.atoms||{},S=s.hooks||{},C=s.multiLineStrings,T=!1!==s.indentStatements,M=!1!==s.indentSwitch,P=s.namespaceSeparator,D=s.isPunctuationChar||/[\[\]{}\(\),;\:\.]/,L=s.numberStart||/[\d\.]/,I=s.number||/^(?:0x[a-f\d]+|0b[01]+|(?:\d+\.?\d*|\.\d+)(?:e[-+]?\d+)?)(u|ll?|l|f)?/i,F=s.isOperatorChar||/[+\-*&%=<>!?|\/]/,z=s.isIdentifierChar||/[\w\$_\xa1-\uffff]/;return{startState:function(e){return{tokenize:null,context:new t((e||0)-h,0,"top",null,!1),indented:0,startOfLine:!0,prevToken:null}},token:function(e,t){var i=t.context;if(e.sol()&&(null==i.align&&(i.align=!1),t.indented=e.indentation(),t.startOfLine=!0),e.eatSpace())return f(e,t),null;p=m=null;var l=(t.tokenize||c)(e,t);if("comment"==l||"meta"==l)return l;if(null==i.align&&(i.align=!0),";"==p||":"==p||","==p&&e.match(/^\s*(?:\/\/.*)?$/,!1))for(;"statement"==t.context.type;)r(t);else if("{"==p)n(t,e.column(),"}");else if("["==p)n(t,e.column(),"]");else if("("==p)n(t,e.column(),")");else if("}"==p){for(;"statement"==i.type;)i=r(t);for("}"==i.type&&(i=r(t));"statement"==i.type;)i=r(t)}else p==i.type?r(t):T&&(("}"==i.type||"top"==i.type)&&";"!=p||"statement"==i.type&&"newstatement"==p)&&n(t,e.column(),"statement",e.current());if("variable"==l&&("def"==t.prevToken||s.typeFirstDefinitions&&o(e,t,e.start)&&a(t.context)&&e.match(/^\s*\(/,!1))&&(l="def"),S.token){var u=S.token(e,t,l);void 0!==u&&(l=u)}return"def"==l&&!1===s.styleDefs&&(l="variable"),t.startOfLine=!1,t.prevToken=m?"def":l||p,f(e,t),l},indent:function(t,n){if(t.tokenize!=c&&null!=t.tokenize||t.typeAtEndOfLine)return e.Pass;var r=t.context,o=n&&n.charAt(0);if("statement"==r.type&&"}"==o&&(r=r.prev),s.dontIndentStatements)for(;"statement"==r.type&&s.dontIndentStatements.test(r.info);)r=r.prev;if(S.indent){var a=S.indent(t,r,n);if("number"==typeof a)return a}var i=o==r.type,l=r.prev&&"switch"==r.prev.info;if(s.allmanIndentation&&/[{(]/.test(o)){for(;"top"!=r.type&&"}"!=r.type;)r=r.prev;return r.indented}return"statement"==r.type?r.indented+("{"==o?0:g):!r.align||y&&")"==r.type?")"!=r.type||i?r.indented+(i?0:h)+(i||!l||/^(?:case|default)\b/.test(n)?0:h):r.indented+g:r.column+(i?0:1)},electricInput:M?/^\s*(?:case .*?:|default:|\{\}?|\})$/:/^\s*[{}]$/,blockCommentStart:"/*",blockCommentEnd:"*/",lineComment:"//",fold:"brace"}});var b="auto if break case register continue return default do sizeof static else struct switch extern typedef union for goto while enum const volatile",k="int long char short double float unsigned signed void size_t ptrdiff_t";h(["text/x-csrc","text/x-c","text/x-chdr"],{name:"clike",keywords:i(b),types:i(k+" bool _Complex _Bool float_t double_t intptr_t intmax_t int8_t int16_t int32_t int64_t uintptr_t uintmax_t uint8_t uint16_t uint32_t uint64_t"),blockKeywords:i("case do else for if switch while struct"),defKeywords:i("struct"),typeFirstDefinitions:!0,atoms:i("null true false"),hooks:{"#":s,"*":c},modeProps:{fold:["brace","include"]}}),h(["text/x-c++src","text/x-c++hdr"],{name:"clike",keywords:i(b+" asm dynamic_cast namespace reinterpret_cast try explicit new static_cast typeid catch operator template typename class friend private this using const_cast inline public throw virtual delete mutable protected alignas alignof constexpr decltype nullptr noexcept thread_local final static_assert override"),types:i(k+" bool wchar_t"),blockKeywords:i("catch class do else finally for if struct switch try while"),defKeywords:i("class namespace struct enum union"),typeFirstDefinitions:!0,atoms:i("true false null"),dontIndentStatements:/^template$/,isIdentifierChar:/[\w\$_~\xa1-\uffff]/,hooks:{"#":s,"*":c,u:d,U:d,L:d,R:d,0:u,1:u,2:u,3:u,4:u,5:u,6:u,7:u,8:u,9:u,token:function(e,t,n){if("variable"==n&&"("==e.peek()&&(";"==t.prevToken||null==t.prevToken||"}"==t.prevToken)&&f(e.current()))return"def"}},namespaceSeparator:"::",modeProps:{fold:["brace","include"]}}),h("text/x-java",{name:"clike",keywords:i("abstract assert break case catch class const continue default do else enum extends final finally float for goto if implements import instanceof interface native new package private protected public return static strictfp super switch synchronized this throw throws transient try volatile while @interface"),types:i("byte short int long float double boolean char void Boolean Byte Character Double Float Integer Long Number Object Short String StringBuffer StringBuilder Void"),blockKeywords:i("catch class do else finally for if switch try while"),defKeywords:i("class interface package enum @interface"),typeFirstDefinitions:!0,atoms:i("true false null"),number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,hooks:{"@":function(e){return!e.match("interface",!1)&&(e.eatWhile(/[\w\$_]/),"meta")}},modeProps:{fold:["brace","import"]}}),h("text/x-csharp",{name:"clike",keywords:i("abstract as async await base break case catch checked class const continue default delegate do else enum event explicit extern finally fixed for foreach goto if implicit in interface internal is lock namespace new operator out override params private protected public readonly ref return sealed sizeof stackalloc static struct switch this throw try typeof unchecked unsafe using virtual void volatile while add alias ascending descending dynamic from get global group into join let orderby partial remove select set value var yield"),types:i("Action Boolean Byte Char DateTime DateTimeOffset Decimal Double Func Guid Int16 Int32 Int64 Object SByte Single String Task TimeSpan UInt16 UInt32 UInt64 bool byte char decimal double short int long object sbyte float string ushort uint ulong"),blockKeywords:i("catch class do else finally for foreach if struct switch try while"),defKeywords:i("class interface namespace struct var"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"@":function(e,t){return e.eat('"')?(t.tokenize=p,p(e,t)):(e.eatWhile(/[\w\$_]/),"meta")}}}),h("text/x-scala",{name:"clike",keywords:i("abstract case catch class def do else extends final finally for forSome if implicit import lazy match new null object override package private protected return sealed super this throw trait try type val var while with yield _ assert assume require print println printf readLine readBoolean readByte readShort readChar readInt readLong readFloat readDouble"),types:i("AnyVal App Application Array BufferedIterator BigDecimal BigInt Char Console Either Enumeration Equiv Error Exception Fractional Function IndexedSeq Int Integral Iterable Iterator List Map Numeric Nil NotNull Option Ordered Ordering PartialFunction PartialOrdering Product Proxy Range Responder Seq Serializable Set Specializable Stream StringBuilder StringContext Symbol Throwable Traversable TraversableOnce Tuple Unit Vector Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),multiLineStrings:!0,blockKeywords:i("catch class enum do else finally for forSome if match switch try while"),defKeywords:i("class enum def object package trait type val var"),atoms:i("true false null"),indentStatements:!1,indentSwitch:!1,isOperatorChar:/[+\-*&%=<>!?|\/#:@]/,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return!!e.match('""')&&(t.tokenize=g,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},"=":function(e,n){var r=n.context;return!("}"!=r.type||!r.align||!e.eat(">"))&&(n.context=new t(r.indented,r.column,r.type,r.info,null,r.prev),"operator")}},modeProps:{closeBrackets:{triples:'"'}}}),h("text/x-kotlin",{name:"clike",keywords:i("package as typealias class interface this super val var fun for is in This throw return break continue object if else while do try when !in !is as? file import where by get set abstract enum open inner override private public internal protected catch finally out final vararg reified dynamic companion constructor init sealed field property receiver param sparam lateinit data inline noinline tailrec external annotation crossinline const operator infix suspend"),types:i("Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),intendSwitch:!1,indentStatements:!1,multiLineStrings:!0,number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,blockKeywords:i("catch class do else finally for if where try while enum"),defKeywords:i("class val var object package interface fun"),atoms:i("true false null this"),hooks:{'"':function(e,t){return t.tokenize=y(e.match('""')),t.tokenize(e,t)}},modeProps:{closeBrackets:{triples:'"'}}}),h(["x-shader/x-vertex","x-shader/x-fragment"],{name:"clike",keywords:i("sampler1D sampler2D sampler3D samplerCube sampler1DShadow sampler2DShadow const attribute uniform varying break continue discard return for while do if else struct in out inout"),types:i("float int bool void vec2 vec3 vec4 ivec2 ivec3 ivec4 bvec2 bvec3 bvec4 mat2 mat3 mat4"),blockKeywords:i("for while do if else struct"),builtin:i("radians degrees sin cos tan asin acos atan pow exp log exp2 sqrt inversesqrt abs sign floor ceil fract mod min max clamp mix step smoothstep length distance dot cross normalize ftransform faceforward reflect refract matrixCompMult lessThan lessThanEqual greaterThan greaterThanEqual equal notEqual any all not texture1D texture1DProj texture1DLod texture1DProjLod texture2D texture2DProj texture2DLod texture2DProjLod texture3D texture3DProj texture3DLod texture3DProjLod textureCube textureCubeLod shadow1D shadow2D shadow1DProj shadow2DProj shadow1DLod shadow2DLod shadow1DProjLod shadow2DProjLod dFdx dFdy fwidth noise1 noise2 noise3 noise4"),atoms:i("true false gl_FragColor gl_SecondaryColor gl_Normal gl_Vertex gl_MultiTexCoord0 gl_MultiTexCoord1 gl_MultiTexCoord2 gl_MultiTexCoord3 gl_MultiTexCoord4 gl_MultiTexCoord5 gl_MultiTexCoord6 gl_MultiTexCoord7 gl_FogCoord gl_PointCoord gl_Position gl_PointSize gl_ClipVertex gl_FrontColor gl_BackColor gl_FrontSecondaryColor gl_BackSecondaryColor gl_TexCoord gl_FogFragCoord gl_FragCoord gl_FrontFacing gl_FragData gl_FragDepth gl_ModelViewMatrix gl_ProjectionMatrix gl_ModelViewProjectionMatrix gl_TextureMatrix gl_NormalMatrix gl_ModelViewMatrixInverse gl_ProjectionMatrixInverse gl_ModelViewProjectionMatrixInverse gl_TexureMatrixTranspose gl_ModelViewMatrixInverseTranspose gl_ProjectionMatrixInverseTranspose gl_ModelViewProjectionMatrixInverseTranspose gl_TextureMatrixInverseTranspose gl_NormalScale gl_DepthRange gl_ClipPlane gl_Point gl_FrontMaterial gl_BackMaterial gl_LightSource gl_LightModel gl_FrontLightModelProduct gl_BackLightModelProduct gl_TextureColor gl_EyePlaneS gl_EyePlaneT gl_EyePlaneR gl_EyePlaneQ gl_FogParameters gl_MaxLights gl_MaxClipPlanes gl_MaxTextureUnits gl_MaxTextureCoords gl_MaxVertexAttribs gl_MaxVertexUniformComponents gl_MaxVaryingFloats gl_MaxVertexTextureImageUnits gl_MaxTextureImageUnits gl_MaxFragmentUniformComponents gl_MaxCombineTextureImageUnits gl_MaxDrawBuffers"),indentSwitch:!1,hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-nesc",{name:"clike",keywords:i(b+"as atomic async call command component components configuration event generic implementation includes interface module new norace nx_struct nx_union post provides signal task uses abstract extends"),types:i(k),blockKeywords:i("case do else for if switch while struct"),atoms:i("null true false"),hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-objectivec",{name:"clike",keywords:i(b+"inline restrict _Bool _Complex _Imaginary BOOL Class bycopy byref id IMP in inout nil oneway out Protocol SEL self super atomic nonatomic retain copy readwrite readonly"),types:i(k),atoms:i("YES NO NULL NILL ON OFF true false"),hooks:{"@":function(e){return e.eatWhile(/[\w\$]/),"keyword"},"#":s,indent:function(e,t,n){if("statement"==t.type&&/^@\w/.test(n))return t.indented}},modeProps:{fold:"brace"}}),h("text/x-squirrel",{name:"clike",keywords:i("base break clone continue const default delete enum extends function in class foreach local resume return this throw typeof yield constructor instanceof static"),types:i(k),blockKeywords:i("case catch class else for foreach if switch try while"),defKeywords:i("function local class"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"#":s},modeProps:{fold:["brace","include"]}});var w=null;h("text/x-ceylon",{name:"clike",keywords:i("abstracts alias assembly assert assign break case catch class continue dynamic else exists extends finally for function given if import in interface is let module new nonempty object of out outer package return satisfies super switch then this throw try value void while"),types:function(e){var t=e.charAt(0);return t===t.toUpperCase()&&t!==t.toLowerCase()},blockKeywords:i("case catch class dynamic else finally for function if interface module new object switch try while"),defKeywords:i("class dynamic function interface module object package value"),builtin:i("abstract actual aliased annotation by default deprecated doc final formal late license native optional sealed see serializable shared suppressWarnings tagged throws variable"),isPunctuationChar:/[\[\]{}\(\),;\:\.`]/,isOperatorChar:/[+\-*&%=<>!?|^~:\/]/,numberStart:/[\d#$]/,number:/^(?:#[\da-fA-F_]+|\$[01_]+|[\d_]+[kMGTPmunpf]?|[\d_]+\.[\d_]+(?:[eE][-+]?\d+|[kMGTPmunpf]|)|)/i,multiLineStrings:!0,typeFirstDefinitions:!0,atoms:i("true false null larger smaller equal empty finished"),indentSwitch:!1,styleDefs:!1,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return t.tokenize=x(e.match('""')?"triple":"single"),t.tokenize(e,t)},"`":function(e,t){return!(!w||!e.match("`"))&&(t.tokenize=w,w=null,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},token:function(e,t,n){if(("variable"==n||"type"==n)&&"."==t.prevToken)return"variable-2"}},modeProps:{fold:["brace","import"],closeBrackets:{triples:'"'}}})});
      // -------------------------------------------------------------------------
//  Part of the CodeChecker project, under the Apache License v2.0 with
//  LLVM Exceptions. See LICENSE for license information.
//  SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
// -------------------------------------------------------------------------

var BugViewer = {
  _files : [],
  _reports : [],
  _lineWidgets : [],
  _navigationMenuItems : [],
  _sourceFileData : null,
  _currentReport : null,
  _lastBugEvent  : null,

  init : function (files, reports) {
    this._files = files;
    this._reports = reports;

    this.initEscapeChars();
  },

  initEscapeChars : function () {
    this.escapeChars = {
      ' ' : 'nbsp',
      '<' : 'lt',
      '>' : 'gt',
      '"' : 'quot',
      '&' : 'amp'
    };

    var regexString = '[';
    for (var key in this.escapeChars) {
      regexString += key;
    }
    regexString += ']';

    this.escapeRegExp = new RegExp( regexString, 'g');
  },

  escapeHTML : function (str) {
    var that = this;

    return str.replace(this.escapeRegExp, function (m) {
      return '&' + that.escapeChars[m] + ';';
    });
  },

  initByUrl : function () {
    if (!this._reports) return;

    var state = {};
    window.location.hash.substr(1).split('&').forEach(function (s) {
      var parts = s.split('=');
      state[parts[0]] = parts[1];
    });

    for (var key in this._reports) {
      var report = this._reports[key];
      if (report.reportHash === state['reportHash']) {
        this.navigate(report);
        return;
      }
    }

    this.navigate(this._reports[0]);
  },

  create : function () {
    this._content = document.getElementById('editor-wrapper');
    this._filepath = document.getElementById('file-path');
    this._checkerName = document.getElementById('checker-name');
    this._reviewStatusWrapper =
      document.getElementById('review-status-wrapper');
    this._reviewStatus = document.getElementById('review-status');
    this._editor = document.getElementById('editor');

    this._codeMirror = CodeMirror(this._editor, {
      mode: 'text/x-c++src',
      matchBrackets : true,
      lineNumbers : true,
      readOnly : true,
      foldGutter : true,
      extraKeys : {},
      viewportMargin : 100
    });

    this._createNavigationMenu();
  },

  navigate : function (report, item) {
    if (!item) {
      var items = this._navigationMenuItems.filter(function (navItem) {
        return navItem.report.reportHash === report.reportHash;
      });

      if (!items.length) return;

      item = items[0].widget;
    }

    this._selectedReport.classList.remove('active');
    this._selectedReport = item;
    this._selectedReport.classList.add('active');
    this.setReport(report);
  },

  _createNavigationMenu : function () {
    var that = this;

    var nav = document.getElementById('report-nav');
    var list = document.createElement('ul');
    this._reports.forEach(function (report) {
      var events = report['events'];
      var lastBugEvent = events[events.length - 1];
      var item = document.createElement('li');

      var severity = document.createElement('i');
      severity.className = 'severity-' + report.severity.toLowerCase();

      item.appendChild(severity);
      item.appendChild(document.createTextNode(lastBugEvent.message));

      item.addEventListener('click', function () {
        that.navigate(report, item);
      })
      list.appendChild(item);
      that._navigationMenuItems.push({ report : report, widget : item });
    });

    if (!this._selectedReport && list.childNodes.length) {
      this._selectedReport = list.childNodes[0];
      this._selectedReport.classList.add('active');
    }

    nav.appendChild(list);
  },

  setReport : function (report) {
    this._currentReport = report;
    var events = report['events'];
    var lastBugEvent = events[events.length - 1];
    this.setCurrentBugEvent(lastBugEvent, events.length - 1);
    this.setCheckerName(report.checkerName);
    this.setReviewStatus(report.reviewStatus);

    window.location.hash = '#reportHash=' + report.reportHash;
  },

  setCurrentBugEvent : function (event, idx) {
    this._currentBugEvent = event;
    this.setSourceFileData(this._files[event.location.file]);
    this.drawBugPath();

    this.jumpTo(event.location.line, 0);
    this.highlightBugEvent(event, idx);
  },

  highlightBugEvent : function (event, idx) {
    this._lineWidgets.forEach(function (widget) {
      var lineIdx = widget.node.getAttribute('idx');
      if (parseInt(lineIdx) === idx) {
        widget.node.classList.add('current');
      }
    });
  },

  setCheckerName : function (checkerName) {
    this._checkerName.innerHTML = checkerName;
  },

  setReviewStatus : function (status) {
    if (status) {
      var className =
        'review-status-' + status.toLowerCase().split(' ').join('-');
      this._reviewStatus.className = "review-status " + className;

      this._reviewStatus.innerHTML = status;
      this._reviewStatusWrapper.style.display = 'block';
    } else {
      this._reviewStatusWrapper.style.display = 'none';
    }
  },

  setSourceFileData : function (file) {
    if (this._sourceFileData && file.id === this._sourceFileData.id) {
      return;
    }

    this._sourceFileData = file;
    this._filepath.innerHTML = file.path;
    this._codeMirror.doc.setValue(file.content);
    this._refresh();
  },

  _refresh : function () {
    var that = this;
    setTimeout(function () {
      var fullHeight = parseInt(that._content.clientHeight);
      var headerHeight = that._filepath.clientHeight;

      that._codeMirror.setSize('auto', fullHeight - headerHeight);
      that._codeMirror.refresh();
    }, 200);
  },

  clearBubbles : function () {
    this._lineWidgets.forEach(function (widget) { widget.clear(); });
    this._lineWidgets = [];
  },

  getMessage : function (event, kind) {
    if (kind === 'macro') {
      var name = 'macro expansion' + (event.name ? ': ' + event.name : '');

      return '<span class="tag macro">' + name + '</span>'
        + this.escapeHTML(event.expansion).replace(/(?:\r\n|\r|\n)/g, '<br>');
    } else if (kind === 'note') {
      return '<span class="tag note">note</span>'
        +  this.escapeHTML(event.message).replace(/(?:\r\n|\r|\n)/g, '<br>');
    }
  },

  addExtraPathEvents : function (events, kind) {
    var that = this;

    if (!events) {
      return;
    }

    events.forEach(function (event) {
      if (event.location.file !== that._currentBugEvent.location.file) {
        return;
      }

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + kind);

      var msg = document.createElement('span');
      msg.innerHTML = that.getMessage(event, kind);
      element.appendChild(msg);

      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  drawBugPath : function () {
    var that = this;

    this.clearBubbles();

    this.addExtraPathEvents(this._currentReport.macros, 'macro');
    this.addExtraPathEvents(this._currentReport.notes, 'note');

    // Processing bug path events.
    var currentEvents = this._currentReport.events;
    currentEvents.forEach(function (event, step) {
      if (event.location.file !== that._currentBugEvent.location.file)
        return;

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';
      var type = step === currentEvents.length - 1 ? 'error' : 'info';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + type);
      element.setAttribute('idx', step);

      var enumeration = document.createElement('span');
      enumeration.setAttribute('class', 'checker-enum ' + type);
      enumeration.innerHTML = step + 1;

      if (currentEvents.length > 1)
        element.appendChild(enumeration);

      var prevBugEvent = step - 1;
      if (step > 0) {
        var prevBug = document.createElement('span');
        prevBug.setAttribute('class', 'arrow left-arrow');
        prevBug.addEventListener('click', function () {
          var event = currentEvents[prevBugEvent];
          that.setCurrentBugEvent(event, prevBugEvent);
        });
        element.appendChild(prevBug);
      }

      var msg = document.createElement('span');
      msg.innerHTML = that.escapeHTML(event.message)
        .replace(/(?:\r\n|\r|\n)/g, '<br>');

      element.appendChild(msg);

      var nextBugEvent = step + 1;
      if (nextBugEvent < currentEvents.length) {
        var nextBug = document.createElement('span');
        nextBug.setAttribute('class', 'arrow right-arrow');
        nextBug.addEventListener('click', function () {
          var event = currentEvents[nextBugEvent];
          that.setCurrentBugEvent(event, nextBugEvent);
        });
        element.appendChild(nextBug);
      }


      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  jumpTo : function (line, column) {
    var that = this;

    setTimeout(function () {
      var selPosPixel
        = that._codeMirror.charCoords({ line : line, ch : column }, 'local');
      var editorSize = {
        width  : that._editor.clientWidth,
        height : that._editor.clientHeight
      };

      that._codeMirror.scrollIntoView({
        top    : selPosPixel.top - 100,
        bottom : selPosPixel.top + editorSize.height - 150,
        left   : selPosPixel.left < editorSize.width - 100
               ? 0
               : selPosPixel.left - 50,
        right  : selPosPixel.left < editorSize.width - 100
               ? 10
               : selPosPixel.left + editorSize.width - 100
      });
    }, 0);
  }
}


      var data = {"files": {"27": {"id": 27, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/IR/ModuleSummaryIndex.h", "content": "//===- llvm/ModuleSummaryIndex.h - Module Summary Index ---------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n/// @file\n/// ModuleSummaryIndex.h This file contains the declarations the classes that\n///  hold the module index and summary for function importing.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_IR_MODULESUMMARYINDEX_H\n#define LLVM_IR_MODULESUMMARYINDEX_H\n\n#include \"llvm/ADT/ArrayRef.h\"\n#include \"llvm/ADT/DenseMap.h\"\n#include \"llvm/ADT/STLExtras.h\"\n#include \"llvm/ADT/SmallString.h\"\n#include \"llvm/ADT/StringExtras.h\"\n#include \"llvm/ADT/StringMap.h\"\n#include \"llvm/ADT/StringRef.h\"\n#include \"llvm/ADT/TinyPtrVector.h\"\n#include \"llvm/IR/ConstantRange.h\"\n#include \"llvm/IR/GlobalValue.h\"\n#include \"llvm/IR/Module.h\"\n#include \"llvm/Support/Allocator.h\"\n#include \"llvm/Support/MathExtras.h\"\n#include \"llvm/Support/ScaledNumber.h\"\n#include \"llvm/Support/StringSaver.h\"\n#include \"llvm/Support/raw_ostream.h\"\n#include <algorithm>\n#include <array>\n#include <cassert>\n#include <cstddef>\n#include <cstdint>\n#include <map>\n#include <memory>\n#include <set>\n#include <string>\n#include <utility>\n#include <vector>\n\nnamespace llvm {\n\nnamespace yaml {\n\ntemplate <typename T> struct MappingTraits;\n\n} // end namespace yaml\n\n/// Class to accumulate and hold information about a callee.\nstruct CalleeInfo {\n  enum class HotnessType : uint8_t {\n    Unknown = 0,\n    Cold = 1,\n    None = 2,\n    Hot = 3,\n    Critical = 4\n  };\n\n  // The size of the bit-field might need to be adjusted if more values are\n  // added to HotnessType enum.\n  uint32_t Hotness : 3;\n\n  /// The value stored in RelBlockFreq has to be interpreted as the digits of\n  /// a scaled number with a scale of \\p -ScaleShift.\n  uint32_t RelBlockFreq : 29;\n  static constexpr int32_t ScaleShift = 8;\n  static constexpr uint64_t MaxRelBlockFreq = (1 << 29) - 1;\n\n  CalleeInfo()\n      : Hotness(static_cast<uint32_t>(HotnessType::Unknown)), RelBlockFreq(0) {}\n  explicit CalleeInfo(HotnessType Hotness, uint64_t RelBF)\n      : Hotness(static_cast<uint32_t>(Hotness)), RelBlockFreq(RelBF) {}\n\n  void updateHotness(const HotnessType OtherHotness) {\n    Hotness = std::max(Hotness, static_cast<uint32_t>(OtherHotness));\n  }\n\n  HotnessType getHotness() const { return HotnessType(Hotness); }\n\n  /// Update \\p RelBlockFreq from \\p BlockFreq and \\p EntryFreq\n  ///\n  /// BlockFreq is divided by EntryFreq and added to RelBlockFreq. To represent\n  /// fractional values, the result is represented as a fixed point number with\n  /// scale of -ScaleShift.\n  void updateRelBlockFreq(uint64_t BlockFreq, uint64_t EntryFreq) {\n    if (EntryFreq == 0)\n      return;\n    using Scaled64 = ScaledNumber<uint64_t>;\n    Scaled64 Temp(BlockFreq, ScaleShift);\n    Temp /= Scaled64::get(EntryFreq);\n\n    uint64_t Sum =\n        SaturatingAdd<uint64_t>(Temp.toInt<uint64_t>(), RelBlockFreq);\n    Sum = std::min(Sum, uint64_t(MaxRelBlockFreq));\n    RelBlockFreq = static_cast<uint32_t>(Sum);\n  }\n};\n\ninline const char *getHotnessName(CalleeInfo::HotnessType HT) {\n  switch (HT) {\n  case CalleeInfo::HotnessType::Unknown:\n    return \"unknown\";\n  case CalleeInfo::HotnessType::Cold:\n    return \"cold\";\n  case CalleeInfo::HotnessType::None:\n    return \"none\";\n  case CalleeInfo::HotnessType::Hot:\n    return \"hot\";\n  case CalleeInfo::HotnessType::Critical:\n    return \"critical\";\n  }\n  llvm_unreachable(\"invalid hotness\");\n}\n\nclass GlobalValueSummary;\n\nusing GlobalValueSummaryList = std::vector<std::unique_ptr<GlobalValueSummary>>;\n\nstruct alignas(8) GlobalValueSummaryInfo {\n  union NameOrGV {\n    NameOrGV(bool HaveGVs) {\n      if (HaveGVs)\n        GV = nullptr;\n      else\n        Name = \"\";\n    }\n\n    /// The GlobalValue corresponding to this summary. This is only used in\n    /// per-module summaries and when the IR is available. E.g. when module\n    /// analysis is being run, or when parsing both the IR and the summary\n    /// from assembly.\n    const GlobalValue *GV;\n\n    /// Summary string representation. This StringRef points to BC module\n    /// string table and is valid until module data is stored in memory.\n    /// This is guaranteed to happen until runThinLTOBackend function is\n    /// called, so it is safe to use this field during thin link. This field\n    /// is only valid if summary index was loaded from BC file.\n    StringRef Name;\n  } U;\n\n  GlobalValueSummaryInfo(bool HaveGVs) : U(HaveGVs) {}\n\n  /// List of global value summary structures for a particular value held\n  /// in the GlobalValueMap. Requires a vector in the case of multiple\n  /// COMDAT values of the same name.\n  GlobalValueSummaryList SummaryList;\n};\n\n/// Map from global value GUID to corresponding summary structures. Use a\n/// std::map rather than a DenseMap so that pointers to the map's value_type\n/// (which are used by ValueInfo) are not invalidated by insertion. Also it will\n/// likely incur less overhead, as the value type is not very small and the size\n/// of the map is unknown, resulting in inefficiencies due to repeated\n/// insertions and resizing.\nusing GlobalValueSummaryMapTy =\n    std::map<GlobalValue::GUID, GlobalValueSummaryInfo>;\n\n/// Struct that holds a reference to a particular GUID in a global value\n/// summary.\nstruct ValueInfo {\n  enum Flags { HaveGV = 1, ReadOnly = 2, WriteOnly = 4 };\n  PointerIntPair<const GlobalValueSummaryMapTy::value_type *, 3, int>\n      RefAndFlags;\n\n  ValueInfo() = default;\n  ValueInfo(bool HaveGVs, const GlobalValueSummaryMapTy::value_type *R) {\n    RefAndFlags.setPointer(R);\n    RefAndFlags.setInt(HaveGVs);\n  }\n\n  explicit operator bool() const { return getRef(); }\n\n  GlobalValue::GUID getGUID() const { return getRef()->first; }\n  const GlobalValue *getValue() const {\n    assert(haveGVs());\n    return getRef()->second.U.GV;\n  }\n\n  ArrayRef<std::unique_ptr<GlobalValueSummary>> getSummaryList() const {\n    return getRef()->second.SummaryList;\n  }\n\n  StringRef name() const {\n    return haveGVs() ? getRef()->second.U.GV->getName()\n                     : getRef()->second.U.Name;\n  }\n\n  bool haveGVs() const { return RefAndFlags.getInt() & HaveGV; }\n  bool isReadOnly() const {\n    assert(isValidAccessSpecifier());\n    return RefAndFlags.getInt() & ReadOnly;\n  }\n  bool isWriteOnly() const {\n    assert(isValidAccessSpecifier());\n    return RefAndFlags.getInt() & WriteOnly;\n  }\n  unsigned getAccessSpecifier() const {\n    assert(isValidAccessSpecifier());\n    return RefAndFlags.getInt() & (ReadOnly | WriteOnly);\n  }\n  bool isValidAccessSpecifier() const {\n    unsigned BadAccessMask = ReadOnly | WriteOnly;\n    return (RefAndFlags.getInt() & BadAccessMask) != BadAccessMask;\n  }\n  void setReadOnly() {\n    // We expect ro/wo attribute to set only once during\n    // ValueInfo lifetime.\n    assert(getAccessSpecifier() == 0);\n    RefAndFlags.setInt(RefAndFlags.getInt() | ReadOnly);\n  }\n  void setWriteOnly() {\n    assert(getAccessSpecifier() == 0);\n    RefAndFlags.setInt(RefAndFlags.getInt() | WriteOnly);\n  }\n\n  const GlobalValueSummaryMapTy::value_type *getRef() const {\n    return RefAndFlags.getPointer();\n  }\n\n  /// Returns the most constraining visibility among summaries. The\n  /// visibilities, ordered from least to most constraining, are: default,\n  /// protected and hidden.\n  GlobalValue::VisibilityTypes getELFVisibility() const;\n\n  /// Checks if all summaries are DSO local (have the flag set). When DSOLocal\n  /// propagation has been done, set the parameter to enable fast check.\n  bool isDSOLocal(bool WithDSOLocalPropagation = false) const;\n\n  /// Checks if all copies are eligible for auto-hiding (have flag set).\n  bool canAutoHide() const;\n};\n\ninline raw_ostream &operator<<(raw_ostream &OS, const ValueInfo &VI) {\n  OS << VI.getGUID();\n  if (!VI.name().empty())\n    OS << \" (\" << VI.name() << \")\";\n  return OS;\n}\n\ninline bool operator==(const ValueInfo &A, const ValueInfo &B) {\n  assert(A.getRef() && B.getRef() &&\n         \"Need ValueInfo with non-null Ref for comparison\");\n  return A.getRef() == B.getRef();\n}\n\ninline bool operator!=(const ValueInfo &A, const ValueInfo &B) {\n  assert(A.getRef() && B.getRef() &&\n         \"Need ValueInfo with non-null Ref for comparison\");\n  return A.getRef() != B.getRef();\n}\n\ninline bool operator<(const ValueInfo &A, const ValueInfo &B) {\n  assert(A.getRef() && B.getRef() &&\n         \"Need ValueInfo with non-null Ref to compare GUIDs\");\n  return A.getGUID() < B.getGUID();\n}\n\ntemplate <> struct DenseMapInfo<ValueInfo> {\n  static inline ValueInfo getEmptyKey() {\n    return ValueInfo(false, (GlobalValueSummaryMapTy::value_type *)-8);\n  }\n\n  static inline ValueInfo getTombstoneKey() {\n    return ValueInfo(false, (GlobalValueSummaryMapTy::value_type *)-16);\n  }\n\n  static inline bool isSpecialKey(ValueInfo V) {\n    return V == getTombstoneKey() || V == getEmptyKey();\n  }\n\n  static bool isEqual(ValueInfo L, ValueInfo R) {\n    // We are not supposed to mix ValueInfo(s) with different HaveGVs flag\n    // in a same container.\n    assert(isSpecialKey(L) || isSpecialKey(R) || (L.haveGVs() == R.haveGVs()));\n    return L.getRef() == R.getRef();\n  }\n  static unsigned getHashValue(ValueInfo I) { return (uintptr_t)I.getRef(); }\n};\n\n/// Function and variable summary information to aid decisions and\n/// implementation of importing.\nclass GlobalValueSummary {\npublic:\n  /// Sububclass discriminator (for dyn_cast<> et al.)\n  enum SummaryKind : unsigned { AliasKind, FunctionKind, GlobalVarKind };\n\n  /// Group flags (Linkage, NotEligibleToImport, etc.) as a bitfield.\n  struct GVFlags {\n    /// The linkage type of the associated global value.\n    ///\n    /// One use is to flag values that have local linkage types and need to\n    /// have module identifier appended before placing into the combined\n    /// index, to disambiguate from other values with the same name.\n    /// In the future this will be used to update and optimize linkage\n    /// types based on global summary-based analysis.\n    unsigned Linkage : 4;\n\n    /// Indicates the visibility.\n    unsigned Visibility : 2;\n\n    /// Indicate if the global value cannot be imported (e.g. it cannot\n    /// be renamed or references something that can't be renamed).\n    unsigned NotEligibleToImport : 1;\n\n    /// In per-module summary, indicate that the global value must be considered\n    /// a live root for index-based liveness analysis. Used for special LLVM\n    /// values such as llvm.global_ctors that the linker does not know about.\n    ///\n    /// In combined summary, indicate that the global value is live.\n    unsigned Live : 1;\n\n    /// Indicates that the linker resolved the symbol to a definition from\n    /// within the same linkage unit.\n    unsigned DSOLocal : 1;\n\n    /// In the per-module summary, indicates that the global value is\n    /// linkonce_odr and global unnamed addr (so eligible for auto-hiding\n    /// via hidden visibility). In the combined summary, indicates that the\n    /// prevailing linkonce_odr copy can be auto-hidden via hidden visibility\n    /// when it is upgraded to weak_odr in the backend. This is legal when\n    /// all copies are eligible for auto-hiding (i.e. all copies were\n    /// linkonce_odr global unnamed addr. If any copy is not (e.g. it was\n    /// originally weak_odr, we cannot auto-hide the prevailing copy as it\n    /// means the symbol was externally visible.\n    unsigned CanAutoHide : 1;\n\n    /// Convenience Constructors\n    explicit GVFlags(GlobalValue::LinkageTypes Linkage,\n                     GlobalValue::VisibilityTypes Visibility,\n                     bool NotEligibleToImport, bool Live, bool IsLocal,\n                     bool CanAutoHide)\n        : Linkage(Linkage), Visibility(Visibility),\n          NotEligibleToImport(NotEligibleToImport), Live(Live),\n          DSOLocal(IsLocal), CanAutoHide(CanAutoHide) {}\n  };\n\nprivate:\n  /// Kind of summary for use in dyn_cast<> et al.\n  SummaryKind Kind;\n\n  GVFlags Flags;\n\n  /// This is the hash of the name of the symbol in the original file. It is\n  /// identical to the GUID for global symbols, but differs for local since the\n  /// GUID includes the module level id in the hash.\n  GlobalValue::GUID OriginalName = 0;\n\n  /// Path of module IR containing value's definition, used to locate\n  /// module during importing.\n  ///\n  /// This is only used during parsing of the combined index, or when\n  /// parsing the per-module index for creation of the combined summary index,\n  /// not during writing of the per-module index which doesn't contain a\n  /// module path string table.\n  StringRef ModulePath;\n\n  /// List of values referenced by this global value's definition\n  /// (either by the initializer of a global variable, or referenced\n  /// from within a function). This does not include functions called, which\n  /// are listed in the derived FunctionSummary object.\n  std::vector<ValueInfo> RefEdgeList;\n\nprotected:\n  GlobalValueSummary(SummaryKind K, GVFlags Flags, std::vector<ValueInfo> Refs)\n      : Kind(K), Flags(Flags), RefEdgeList(std::move(Refs)) {\n    assert((K != AliasKind || Refs.empty()) &&\n           \"Expect no references for AliasSummary\");\n  }\n\npublic:\n  virtual ~GlobalValueSummary() = default;\n\n  /// Returns the hash of the original name, it is identical to the GUID for\n  /// externally visible symbols, but not for local ones.\n  GlobalValue::GUID getOriginalName() const { return OriginalName; }\n\n  /// Initialize the original name hash in this summary.\n  void setOriginalName(GlobalValue::GUID Name) { OriginalName = Name; }\n\n  /// Which kind of summary subclass this is.\n  SummaryKind getSummaryKind() const { return Kind; }\n\n  /// Set the path to the module containing this function, for use in\n  /// the combined index.\n  void setModulePath(StringRef ModPath) { ModulePath = ModPath; }\n\n  /// Get the path to the module containing this function.\n  StringRef modulePath() const { return ModulePath; }\n\n  /// Get the flags for this GlobalValue (see \\p struct GVFlags).\n  GVFlags flags() const { return Flags; }\n\n  /// Return linkage type recorded for this global value.\n  GlobalValue::LinkageTypes linkage() const {\n    return static_cast<GlobalValue::LinkageTypes>(Flags.Linkage);\n  }\n\n  /// Sets the linkage to the value determined by global summary-based\n  /// optimization. Will be applied in the ThinLTO backends.\n  void setLinkage(GlobalValue::LinkageTypes Linkage) {\n    Flags.Linkage = Linkage;\n  }\n\n  /// Return true if this global value can't be imported.\n  bool notEligibleToImport() const { return Flags.NotEligibleToImport; }\n\n  bool isLive() const { return Flags.Live; }\n\n  void setLive(bool Live) { Flags.Live = Live; }\n\n  void setDSOLocal(bool Local) { Flags.DSOLocal = Local; }\n\n  bool isDSOLocal() const { return Flags.DSOLocal; }\n\n  void setCanAutoHide(bool CanAutoHide) { Flags.CanAutoHide = CanAutoHide; }\n\n  bool canAutoHide() const { return Flags.CanAutoHide; }\n\n  GlobalValue::VisibilityTypes getVisibility() const {\n    return (GlobalValue::VisibilityTypes)Flags.Visibility;\n  }\n  void setVisibility(GlobalValue::VisibilityTypes Vis) {\n    Flags.Visibility = (unsigned)Vis;\n  }\n\n  /// Flag that this global value cannot be imported.\n  void setNotEligibleToImport() { Flags.NotEligibleToImport = true; }\n\n  /// Return the list of values referenced by this global value definition.\n  ArrayRef<ValueInfo> refs() const { return RefEdgeList; }\n\n  /// If this is an alias summary, returns the summary of the aliased object (a\n  /// global variable or function), otherwise returns itself.\n  GlobalValueSummary *getBaseObject();\n  const GlobalValueSummary *getBaseObject() const;\n\n  friend class ModuleSummaryIndex;\n};\n\n/// Alias summary information.\nclass AliasSummary : public GlobalValueSummary {\n  ValueInfo AliaseeValueInfo;\n\n  /// This is the Aliasee in the same module as alias (could get from VI, trades\n  /// memory for time). Note that this pointer may be null (and the value info\n  /// empty) when we have a distributed index where the alias is being imported\n  /// (as a copy of the aliasee), but the aliasee is not.\n  GlobalValueSummary *AliaseeSummary;\n\npublic:\n  AliasSummary(GVFlags Flags)\n      : GlobalValueSummary(AliasKind, Flags, ArrayRef<ValueInfo>{}),\n        AliaseeSummary(nullptr) {}\n\n  /// Check if this is an alias summary.\n  static bool classof(const GlobalValueSummary *GVS) {\n    return GVS->getSummaryKind() == AliasKind;\n  }\n\n  void setAliasee(ValueInfo &AliaseeVI, GlobalValueSummary *Aliasee) {\n    AliaseeValueInfo = AliaseeVI;\n    AliaseeSummary = Aliasee;\n  }\n\n  bool hasAliasee() const {\n    assert(!!AliaseeSummary == (AliaseeValueInfo &&\n                                !AliaseeValueInfo.getSummaryList().empty()) &&\n           \"Expect to have both aliasee summary and summary list or neither\");\n    return !!AliaseeSummary;\n  }\n\n  const GlobalValueSummary &getAliasee() const {\n    assert(AliaseeSummary && \"Unexpected missing aliasee summary\");\n    return *AliaseeSummary;\n  }\n\n  GlobalValueSummary &getAliasee() {\n    return const_cast<GlobalValueSummary &>(\n                         static_cast<const AliasSummary *>(this)->getAliasee());\n  }\n  ValueInfo getAliaseeVI() const {\n    assert(AliaseeValueInfo && \"Unexpected missing aliasee\");\n    return AliaseeValueInfo;\n  }\n  GlobalValue::GUID getAliaseeGUID() const {\n    assert(AliaseeValueInfo && \"Unexpected missing aliasee\");\n    return AliaseeValueInfo.getGUID();\n  }\n};\n\nconst inline GlobalValueSummary *GlobalValueSummary::getBaseObject() const {\n  if (auto *AS = dyn_cast<AliasSummary>(this))\n    return &AS->getAliasee();\n  return this;\n}\n\ninline GlobalValueSummary *GlobalValueSummary::getBaseObject() {\n  if (auto *AS = dyn_cast<AliasSummary>(this))\n    return &AS->getAliasee();\n  return this;\n}\n\n/// Function summary information to aid decisions and implementation of\n/// importing.\nclass FunctionSummary : public GlobalValueSummary {\npublic:\n  /// <CalleeValueInfo, CalleeInfo> call edge pair.\n  using EdgeTy = std::pair<ValueInfo, CalleeInfo>;\n\n  /// Types for -force-summary-edges-cold debugging option.\n  enum ForceSummaryHotnessType : unsigned {\n    FSHT_None,\n    FSHT_AllNonCritical,\n    FSHT_All\n  };\n\n  /// An \"identifier\" for a virtual function. This contains the type identifier\n  /// represented as a GUID and the offset from the address point to the virtual\n  /// function pointer, where \"address point\" is as defined in the Itanium ABI:\n  /// https://itanium-cxx-abi.github.io/cxx-abi/abi.html#vtable-general\n  struct VFuncId {\n    GlobalValue::GUID GUID;\n    uint64_t Offset;\n  };\n\n  /// A specification for a virtual function call with all constant integer\n  /// arguments. This is used to perform virtual constant propagation on the\n  /// summary.\n  struct ConstVCall {\n    VFuncId VFunc;\n    std::vector<uint64_t> Args;\n  };\n\n  /// All type identifier related information. Because these fields are\n  /// relatively uncommon we only allocate space for them if necessary.\n  struct TypeIdInfo {\n    /// List of type identifiers used by this function in llvm.type.test\n    /// intrinsics referenced by something other than an llvm.assume intrinsic,\n    /// represented as GUIDs.\n    std::vector<GlobalValue::GUID> TypeTests;\n\n    /// List of virtual calls made by this function using (respectively)\n    /// llvm.assume(llvm.type.test) or llvm.type.checked.load intrinsics that do\n    /// not have all constant integer arguments.\n    std::vector<VFuncId> TypeTestAssumeVCalls, TypeCheckedLoadVCalls;\n\n    /// List of virtual calls made by this function using (respectively)\n    /// llvm.assume(llvm.type.test) or llvm.type.checked.load intrinsics with\n    /// all constant integer arguments.\n    std::vector<ConstVCall> TypeTestAssumeConstVCalls,\n        TypeCheckedLoadConstVCalls;\n  };\n\n  /// Flags specific to function summaries.\n  struct FFlags {\n    // Function attribute flags. Used to track if a function accesses memory,\n    // recurses or aliases.\n    unsigned ReadNone : 1;\n    unsigned ReadOnly : 1;\n    unsigned NoRecurse : 1;\n    unsigned ReturnDoesNotAlias : 1;\n\n    // Indicate if the global value cannot be inlined.\n    unsigned NoInline : 1;\n    // Indicate if function should be always inlined.\n    unsigned AlwaysInline : 1;\n  };\n\n  /// Describes the uses of a parameter by the function.\n  struct ParamAccess {\n    static constexpr uint32_t RangeWidth = 64;\n\n    /// Describes the use of a value in a call instruction, specifying the\n    /// call's target, the value's parameter number, and the possible range of\n    /// offsets from the beginning of the value that are passed.\n    struct Call {\n      uint64_t ParamNo = 0;\n      ValueInfo Callee;\n      ConstantRange Offsets{/*BitWidth=*/RangeWidth, /*isFullSet=*/true};\n\n      Call() = default;\n      Call(uint64_t ParamNo, ValueInfo Callee, const ConstantRange &Offsets)\n          : ParamNo(ParamNo), Callee(Callee), Offsets(Offsets) {}\n    };\n\n    uint64_t ParamNo = 0;\n    /// The range contains byte offsets from the parameter pointer which\n    /// accessed by the function. In the per-module summary, it only includes\n    /// accesses made by the function instructions. In the combined summary, it\n    /// also includes accesses by nested function calls.\n    ConstantRange Use{/*BitWidth=*/RangeWidth, /*isFullSet=*/true};\n    /// In the per-module summary, it summarizes the byte offset applied to each\n    /// pointer parameter before passing to each corresponding callee.\n    /// In the combined summary, it's empty and information is propagated by\n    /// inter-procedural analysis and applied to the Use field.\n    std::vector<Call> Calls;\n\n    ParamAccess() = default;\n    ParamAccess(uint64_t ParamNo, const ConstantRange &Use)\n        : ParamNo(ParamNo), Use(Use) {}\n  };\n\n  /// Create an empty FunctionSummary (with specified call edges).\n  /// Used to represent external nodes and the dummy root node.\n  static FunctionSummary\n  makeDummyFunctionSummary(std::vector<FunctionSummary::EdgeTy> Edges) {\n    return FunctionSummary(\n        FunctionSummary::GVFlags(\n            GlobalValue::LinkageTypes::AvailableExternallyLinkage,\n            GlobalValue::DefaultVisibility,\n            /*NotEligibleToImport=*/true, /*Live=*/true, /*IsLocal=*/false,\n            /*CanAutoHide=*/false),\n        /*NumInsts=*/0, FunctionSummary::FFlags{}, /*EntryCount=*/0,\n        std::vector<ValueInfo>(), std::move(Edges),\n        std::vector<GlobalValue::GUID>(),\n        std::vector<FunctionSummary::VFuncId>(),\n        std::vector<FunctionSummary::VFuncId>(),\n        std::vector<FunctionSummary::ConstVCall>(),\n        std::vector<FunctionSummary::ConstVCall>(),\n        std::vector<FunctionSummary::ParamAccess>());\n  }\n\n  /// A dummy node to reference external functions that aren't in the index\n  static FunctionSummary ExternalNode;\n\nprivate:\n  /// Number of instructions (ignoring debug instructions, e.g.) computed\n  /// during the initial compile step when the summary index is first built.\n  unsigned InstCount;\n\n  /// Function summary specific flags.\n  FFlags FunFlags;\n\n  /// The synthesized entry count of the function.\n  /// This is only populated during ThinLink phase and remains unused while\n  /// generating per-module summaries.\n  uint64_t EntryCount = 0;\n\n  /// List of <CalleeValueInfo, CalleeInfo> call edge pairs from this function.\n  std::vector<EdgeTy> CallGraphEdgeList;\n\n  std::unique_ptr<TypeIdInfo> TIdInfo;\n\n  /// Uses for every parameter to this function.\n  using ParamAccessesTy = std::vector<ParamAccess>;\n  std::unique_ptr<ParamAccessesTy> ParamAccesses;\n\npublic:\n  FunctionSummary(GVFlags Flags, unsigned NumInsts, FFlags FunFlags,\n                  uint64_t EntryCount, std::vector<ValueInfo> Refs,\n                  std::vector<EdgeTy> CGEdges,\n                  std::vector<GlobalValue::GUID> TypeTests,\n                  std::vector<VFuncId> TypeTestAssumeVCalls,\n                  std::vector<VFuncId> TypeCheckedLoadVCalls,\n                  std::vector<ConstVCall> TypeTestAssumeConstVCalls,\n                  std::vector<ConstVCall> TypeCheckedLoadConstVCalls,\n                  std::vector<ParamAccess> Params)\n      : GlobalValueSummary(FunctionKind, Flags, std::move(Refs)),\n        InstCount(NumInsts), FunFlags(FunFlags), EntryCount(EntryCount),\n        CallGraphEdgeList(std::move(CGEdges)) {\n    if (!TypeTests.empty() || !TypeTestAssumeVCalls.empty() ||\n        !TypeCheckedLoadVCalls.empty() || !TypeTestAssumeConstVCalls.empty() ||\n        !TypeCheckedLoadConstVCalls.empty())\n      TIdInfo = std::make_unique<TypeIdInfo>(\n          TypeIdInfo{std::move(TypeTests), std::move(TypeTestAssumeVCalls),\n                     std::move(TypeCheckedLoadVCalls),\n                     std::move(TypeTestAssumeConstVCalls),\n                     std::move(TypeCheckedLoadConstVCalls)});\n    if (!Params.empty())\n      ParamAccesses = std::make_unique<ParamAccessesTy>(std::move(Params));\n  }\n  // Gets the number of readonly and writeonly refs in RefEdgeList\n  std::pair<unsigned, unsigned> specialRefCounts() const;\n\n  /// Check if this is a function summary.\n  static bool classof(const GlobalValueSummary *GVS) {\n    return GVS->getSummaryKind() == FunctionKind;\n  }\n\n  /// Get function summary flags.\n  FFlags fflags() const { return FunFlags; }\n\n  /// Get the instruction count recorded for this function.\n  unsigned instCount() const { return InstCount; }\n\n  /// Get the synthetic entry count for this function.\n  uint64_t entryCount() const { return EntryCount; }\n\n  /// Set the synthetic entry count for this function.\n  void setEntryCount(uint64_t EC) { EntryCount = EC; }\n\n  /// Return the list of <CalleeValueInfo, CalleeInfo> pairs.\n  ArrayRef<EdgeTy> calls() const { return CallGraphEdgeList; }\n\n  void addCall(EdgeTy E) { CallGraphEdgeList.push_back(E); }\n\n  /// Returns the list of type identifiers used by this function in\n  /// llvm.type.test intrinsics other than by an llvm.assume intrinsic,\n  /// represented as GUIDs.\n  ArrayRef<GlobalValue::GUID> type_tests() const {\n    if (TIdInfo)\n      return TIdInfo->TypeTests;\n    return {};\n  }\n\n  /// Returns the list of virtual calls made by this function using\n  /// llvm.assume(llvm.type.test) intrinsics that do not have all constant\n  /// integer arguments.\n  ArrayRef<VFuncId> type_test_assume_vcalls() const {\n    if (TIdInfo)\n      return TIdInfo->TypeTestAssumeVCalls;\n    return {};\n  }\n\n  /// Returns the list of virtual calls made by this function using\n  /// llvm.type.checked.load intrinsics that do not have all constant integer\n  /// arguments.\n  ArrayRef<VFuncId> type_checked_load_vcalls() const {\n    if (TIdInfo)\n      return TIdInfo->TypeCheckedLoadVCalls;\n    return {};\n  }\n\n  /// Returns the list of virtual calls made by this function using\n  /// llvm.assume(llvm.type.test) intrinsics with all constant integer\n  /// arguments.\n  ArrayRef<ConstVCall> type_test_assume_const_vcalls() const {\n    if (TIdInfo)\n      return TIdInfo->TypeTestAssumeConstVCalls;\n    return {};\n  }\n\n  /// Returns the list of virtual calls made by this function using\n  /// llvm.type.checked.load intrinsics with all constant integer arguments.\n  ArrayRef<ConstVCall> type_checked_load_const_vcalls() const {\n    if (TIdInfo)\n      return TIdInfo->TypeCheckedLoadConstVCalls;\n    return {};\n  }\n\n  /// Returns the list of known uses of pointer parameters.\n  ArrayRef<ParamAccess> paramAccesses() const {\n    if (ParamAccesses)\n      return *ParamAccesses;\n    return {};\n  }\n\n  /// Sets the list of known uses of pointer parameters.\n  void setParamAccesses(std::vector<ParamAccess> NewParams) {\n    if (NewParams.empty())\n      ParamAccesses.reset();\n    else if (ParamAccesses)\n      *ParamAccesses = std::move(NewParams);\n    else\n      ParamAccesses = std::make_unique<ParamAccessesTy>(std::move(NewParams));\n  }\n\n  /// Add a type test to the summary. This is used by WholeProgramDevirt if we\n  /// were unable to devirtualize a checked call.\n  void addTypeTest(GlobalValue::GUID Guid) {\n    if (!TIdInfo)\n      TIdInfo = std::make_unique<TypeIdInfo>();\n    TIdInfo->TypeTests.push_back(Guid);\n  }\n\n  const TypeIdInfo *getTypeIdInfo() const { return TIdInfo.get(); };\n\n  friend struct GraphTraits<ValueInfo>;\n};\n\ntemplate <> struct DenseMapInfo<FunctionSummary::VFuncId> {\n  static FunctionSummary::VFuncId getEmptyKey() { return {0, uint64_t(-1)}; }\n\n  static FunctionSummary::VFuncId getTombstoneKey() {\n    return {0, uint64_t(-2)};\n  }\n\n  static bool isEqual(FunctionSummary::VFuncId L, FunctionSummary::VFuncId R) {\n    return L.GUID == R.GUID && L.Offset == R.Offset;\n  }\n\n  static unsigned getHashValue(FunctionSummary::VFuncId I) { return I.GUID; }\n};\n\ntemplate <> struct DenseMapInfo<FunctionSummary::ConstVCall> {\n  static FunctionSummary::ConstVCall getEmptyKey() {\n    return {{0, uint64_t(-1)}, {}};\n  }\n\n  static FunctionSummary::ConstVCall getTombstoneKey() {\n    return {{0, uint64_t(-2)}, {}};\n  }\n\n  static bool isEqual(FunctionSummary::ConstVCall L,\n                      FunctionSummary::ConstVCall R) {\n    return DenseMapInfo<FunctionSummary::VFuncId>::isEqual(L.VFunc, R.VFunc) &&\n           L.Args == R.Args;\n  }\n\n  static unsigned getHashValue(FunctionSummary::ConstVCall I) {\n    return I.VFunc.GUID;\n  }\n};\n\n/// The ValueInfo and offset for a function within a vtable definition\n/// initializer array.\nstruct VirtFuncOffset {\n  VirtFuncOffset(ValueInfo VI, uint64_t Offset)\n      : FuncVI(VI), VTableOffset(Offset) {}\n\n  ValueInfo FuncVI;\n  uint64_t VTableOffset;\n};\n/// List of functions referenced by a particular vtable definition.\nusing VTableFuncList = std::vector<VirtFuncOffset>;\n\n/// Global variable summary information to aid decisions and\n/// implementation of importing.\n///\n/// Global variable summary has two extra flag, telling if it is\n/// readonly or writeonly. Both readonly and writeonly variables\n/// can be optimized in the backed: readonly variables can be\n/// const-folded, while writeonly vars can be completely eliminated\n/// together with corresponding stores. We let both things happen\n/// by means of internalizing such variables after ThinLTO import.\nclass GlobalVarSummary : public GlobalValueSummary {\nprivate:\n  /// For vtable definitions this holds the list of functions and\n  /// their corresponding offsets within the initializer array.\n  std::unique_ptr<VTableFuncList> VTableFuncs;\n\npublic:\n  struct GVarFlags {\n    GVarFlags(bool ReadOnly, bool WriteOnly, bool Constant,\n              GlobalObject::VCallVisibility Vis)\n        : MaybeReadOnly(ReadOnly), MaybeWriteOnly(WriteOnly),\n          Constant(Constant), VCallVisibility(Vis) {}\n\n    // If true indicates that this global variable might be accessed\n    // purely by non-volatile load instructions. This in turn means\n    // it can be internalized in source and destination modules during\n    // thin LTO import because it neither modified nor its address\n    // is taken.\n    unsigned MaybeReadOnly : 1;\n    // If true indicates that variable is possibly only written to, so\n    // its value isn't loaded and its address isn't taken anywhere.\n    // False, when 'Constant' attribute is set.\n    unsigned MaybeWriteOnly : 1;\n    // Indicates that value is a compile-time constant. Global variable\n    // can be 'Constant' while not being 'ReadOnly' on several occasions:\n    // - it is volatile, (e.g mapped device address)\n    // - its address is taken, meaning that unlike 'ReadOnly' vars we can't\n    //   internalize it.\n    // Constant variables are always imported thus giving compiler an\n    // opportunity to make some extra optimizations. Readonly constants\n    // are also internalized.\n    unsigned Constant : 1;\n    // Set from metadata on vtable definitions during the module summary\n    // analysis.\n    unsigned VCallVisibility : 2;\n  } VarFlags;\n\n  GlobalVarSummary(GVFlags Flags, GVarFlags VarFlags,\n                   std::vector<ValueInfo> Refs)\n      : GlobalValueSummary(GlobalVarKind, Flags, std::move(Refs)),\n        VarFlags(VarFlags) {}\n\n  /// Check if this is a global variable summary.\n  static bool classof(const GlobalValueSummary *GVS) {\n    return GVS->getSummaryKind() == GlobalVarKind;\n  }\n\n  GVarFlags varflags() const { return VarFlags; }\n  void setReadOnly(bool RO) { VarFlags.MaybeReadOnly = RO; }\n  void setWriteOnly(bool WO) { VarFlags.MaybeWriteOnly = WO; }\n  bool maybeReadOnly() const { return VarFlags.MaybeReadOnly; }\n  bool maybeWriteOnly() const { return VarFlags.MaybeWriteOnly; }\n  bool isConstant() const { return VarFlags.Constant; }\n  void setVCallVisibility(GlobalObject::VCallVisibility Vis) {\n    VarFlags.VCallVisibility = Vis;\n  }\n  GlobalObject::VCallVisibility getVCallVisibility() const {\n    return (GlobalObject::VCallVisibility)VarFlags.VCallVisibility;\n  }\n\n  void setVTableFuncs(VTableFuncList Funcs) {\n    assert(!VTableFuncs);\n    VTableFuncs = std::make_unique<VTableFuncList>(std::move(Funcs));\n  }\n\n  ArrayRef<VirtFuncOffset> vTableFuncs() const {\n    if (VTableFuncs)\n      return *VTableFuncs;\n    return {};\n  }\n};\n\nstruct TypeTestResolution {\n  /// Specifies which kind of type check we should emit for this byte array.\n  /// See http://clang.llvm.org/docs/ControlFlowIntegrityDesign.html for full\n  /// details on each kind of check; the enumerators are described with\n  /// reference to that document.\n  enum Kind {\n    Unsat,     ///< Unsatisfiable type (i.e. no global has this type metadata)\n    ByteArray, ///< Test a byte array (first example)\n    Inline,    ///< Inlined bit vector (\"Short Inline Bit Vectors\")\n    Single,    ///< Single element (last example in \"Short Inline Bit Vectors\")\n    AllOnes,   ///< All-ones bit vector (\"Eliminating Bit Vector Checks for\n               ///  All-Ones Bit Vectors\")\n    Unknown,   ///< Unknown (analysis not performed, don't lower)\n  } TheKind = Unknown;\n\n  /// Range of size-1 expressed as a bit width. For example, if the size is in\n  /// range [1,256], this number will be 8. This helps generate the most compact\n  /// instruction sequences.\n  unsigned SizeM1BitWidth = 0;\n\n  // The following fields are only used if the target does not support the use\n  // of absolute symbols to store constants. Their meanings are the same as the\n  // corresponding fields in LowerTypeTestsModule::TypeIdLowering in\n  // LowerTypeTests.cpp.\n\n  uint64_t AlignLog2 = 0;\n  uint64_t SizeM1 = 0;\n  uint8_t BitMask = 0;\n  uint64_t InlineBits = 0;\n};\n\nstruct WholeProgramDevirtResolution {\n  enum Kind {\n    Indir,        ///< Just do a regular virtual call\n    SingleImpl,   ///< Single implementation devirtualization\n    BranchFunnel, ///< When retpoline mitigation is enabled, use a branch funnel\n                  ///< that is defined in the merged module. Otherwise same as\n                  ///< Indir.\n  } TheKind = Indir;\n\n  std::string SingleImplName;\n\n  struct ByArg {\n    enum Kind {\n      Indir,            ///< Just do a regular virtual call\n      UniformRetVal,    ///< Uniform return value optimization\n      UniqueRetVal,     ///< Unique return value optimization\n      VirtualConstProp, ///< Virtual constant propagation\n    } TheKind = Indir;\n\n    /// Additional information for the resolution:\n    /// - UniformRetVal: the uniform return value.\n    /// - UniqueRetVal: the return value associated with the unique vtable (0 or\n    ///   1).\n    uint64_t Info = 0;\n\n    // The following fields are only used if the target does not support the use\n    // of absolute symbols to store constants.\n\n    uint32_t Byte = 0;\n    uint32_t Bit = 0;\n  };\n\n  /// Resolutions for calls with all constant integer arguments (excluding the\n  /// first argument, \"this\"), where the key is the argument vector.\n  std::map<std::vector<uint64_t>, ByArg> ResByArg;\n};\n\nstruct TypeIdSummary {\n  TypeTestResolution TTRes;\n\n  /// Mapping from byte offset to whole-program devirt resolution for that\n  /// (typeid, byte offset) pair.\n  std::map<uint64_t, WholeProgramDevirtResolution> WPDRes;\n};\n\n/// 160 bits SHA1\nusing ModuleHash = std::array<uint32_t, 5>;\n\n/// Type used for iterating through the global value summary map.\nusing const_gvsummary_iterator = GlobalValueSummaryMapTy::const_iterator;\nusing gvsummary_iterator = GlobalValueSummaryMapTy::iterator;\n\n/// String table to hold/own module path strings, which additionally holds the\n/// module ID assigned to each module during the plugin step, as well as a hash\n/// of the module. The StringMap makes a copy of and owns inserted strings.\nusing ModulePathStringTableTy = StringMap<std::pair<uint64_t, ModuleHash>>;\n\n/// Map of global value GUID to its summary, used to identify values defined in\n/// a particular module, and provide efficient access to their summary.\nusing GVSummaryMapTy = DenseMap<GlobalValue::GUID, GlobalValueSummary *>;\n\n/// Map of a type GUID to type id string and summary (multimap used\n/// in case of GUID conflicts).\nusing TypeIdSummaryMapTy =\n    std::multimap<GlobalValue::GUID, std::pair<std::string, TypeIdSummary>>;\n\n/// The following data structures summarize type metadata information.\n/// For type metadata overview see https://llvm.org/docs/TypeMetadata.html.\n/// Each type metadata includes both the type identifier and the offset of\n/// the address point of the type (the address held by objects of that type\n/// which may not be the beginning of the virtual table). Vtable definitions\n/// are decorated with type metadata for the types they are compatible with.\n///\n/// Holds information about vtable definitions decorated with type metadata:\n/// the vtable definition value and its address point offset in a type\n/// identifier metadata it is decorated (compatible) with.\nstruct TypeIdOffsetVtableInfo {\n  TypeIdOffsetVtableInfo(uint64_t Offset, ValueInfo VI)\n      : AddressPointOffset(Offset), VTableVI(VI) {}\n\n  uint64_t AddressPointOffset;\n  ValueInfo VTableVI;\n};\n/// List of vtable definitions decorated by a particular type identifier,\n/// and their corresponding offsets in that type identifier's metadata.\n/// Note that each type identifier may be compatible with multiple vtables, due\n/// to inheritance, which is why this is a vector.\nusing TypeIdCompatibleVtableInfo = std::vector<TypeIdOffsetVtableInfo>;\n\n/// Class to hold module path string table and global value map,\n/// and encapsulate methods for operating on them.\nclass ModuleSummaryIndex {\nprivate:\n  /// Map from value name to list of summary instances for values of that\n  /// name (may be duplicates in the COMDAT case, e.g.).\n  GlobalValueSummaryMapTy GlobalValueMap;\n\n  /// Holds strings for combined index, mapping to the corresponding module ID.\n  ModulePathStringTableTy ModulePathStringTable;\n\n  /// Mapping from type identifier GUIDs to type identifier and its summary\n  /// information. Produced by thin link.\n  TypeIdSummaryMapTy TypeIdMap;\n\n  /// Mapping from type identifier to information about vtables decorated\n  /// with that type identifier's metadata. Produced by per module summary\n  /// analysis and consumed by thin link. For more information, see description\n  /// above where TypeIdCompatibleVtableInfo is defined.\n  std::map<std::string, TypeIdCompatibleVtableInfo, std::less<>>\n      TypeIdCompatibleVtableMap;\n\n  /// Mapping from original ID to GUID. If original ID can map to multiple\n  /// GUIDs, it will be mapped to 0.\n  std::map<GlobalValue::GUID, GlobalValue::GUID> OidGuidMap;\n\n  /// Indicates that summary-based GlobalValue GC has run, and values with\n  /// GVFlags::Live==false are really dead. Otherwise, all values must be\n  /// considered live.\n  bool WithGlobalValueDeadStripping = false;\n\n  /// Indicates that summary-based attribute propagation has run and\n  /// GVarFlags::MaybeReadonly / GVarFlags::MaybeWriteonly are really\n  /// read/write only.\n  bool WithAttributePropagation = false;\n\n  /// Indicates that summary-based DSOLocal propagation has run and the flag in\n  /// every summary of a GV is synchronized.\n  bool WithDSOLocalPropagation = false;\n\n  /// Indicates that summary-based synthetic entry count propagation has run\n  bool HasSyntheticEntryCounts = false;\n\n  /// Indicates that distributed backend should skip compilation of the\n  /// module. Flag is suppose to be set by distributed ThinLTO indexing\n  /// when it detected that the module is not needed during the final\n  /// linking. As result distributed backend should just output a minimal\n  /// valid object file.\n  bool SkipModuleByDistributedBackend = false;\n\n  /// If true then we're performing analysis of IR module, or parsing along with\n  /// the IR from assembly. The value of 'false' means we're reading summary\n  /// from BC or YAML source. Affects the type of value stored in NameOrGV\n  /// union.\n  bool HaveGVs;\n\n  // True if the index was created for a module compiled with -fsplit-lto-unit.\n  bool EnableSplitLTOUnit;\n\n  // True if some of the modules were compiled with -fsplit-lto-unit and\n  // some were not. Set when the combined index is created during the thin link.\n  bool PartiallySplitLTOUnits = false;\n\n  /// True if some of the FunctionSummary contains a ParamAccess.\n  bool HasParamAccess = false;\n\n  std::set<std::string> CfiFunctionDefs;\n  std::set<std::string> CfiFunctionDecls;\n\n  // Used in cases where we want to record the name of a global, but\n  // don't have the string owned elsewhere (e.g. the Strtab on a module).\n  StringSaver Saver;\n  BumpPtrAllocator Alloc;\n\n  // The total number of basic blocks in the module in the per-module summary or\n  // the total number of basic blocks in the LTO unit in the combined index.\n  uint64_t BlockCount;\n\n  // YAML I/O support.\n  friend yaml::MappingTraits<ModuleSummaryIndex>;\n\n  GlobalValueSummaryMapTy::value_type *\n  getOrInsertValuePtr(GlobalValue::GUID GUID) {\n    return &*GlobalValueMap.emplace(GUID, GlobalValueSummaryInfo(HaveGVs))\n                 .first;\n  }\n\npublic:\n  // See HaveGVs variable comment.\n  ModuleSummaryIndex(bool HaveGVs, bool EnableSplitLTOUnit = false)\n      : HaveGVs(HaveGVs), EnableSplitLTOUnit(EnableSplitLTOUnit), Saver(Alloc),\n        BlockCount(0) {}\n\n  // Current version for the module summary in bitcode files.\n  // The BitcodeSummaryVersion should be bumped whenever we introduce changes\n  // in the way some record are interpreted, like flags for instance.\n  // Note that incrementing this may require changes in both BitcodeReader.cpp\n  // and BitcodeWriter.cpp.\n  static constexpr uint64_t BitcodeSummaryVersion = 9;\n\n  // Regular LTO module name for ASM writer\n  static constexpr const char *getRegularLTOModuleName() {\n    return \"[Regular LTO]\";\n  }\n\n  bool haveGVs() const { return HaveGVs; }\n\n  uint64_t getFlags() const;\n  void setFlags(uint64_t Flags);\n\n  uint64_t getBlockCount() const { return BlockCount; }\n  void addBlockCount(uint64_t C) { BlockCount += C; }\n  void setBlockCount(uint64_t C) { BlockCount = C; }\n\n  gvsummary_iterator begin() { return GlobalValueMap.begin(); }\n  const_gvsummary_iterator begin() const { return GlobalValueMap.begin(); }\n  gvsummary_iterator end() { return GlobalValueMap.end(); }\n  const_gvsummary_iterator end() const { return GlobalValueMap.end(); }\n  size_t size() const { return GlobalValueMap.size(); }\n\n  /// Convenience function for doing a DFS on a ValueInfo. Marks the function in\n  /// the FunctionHasParent map.\n  static void discoverNodes(ValueInfo V,\n                            std::map<ValueInfo, bool> &FunctionHasParent) {\n    if (!V.getSummaryList().size())\n      return; // skip external functions that don't have summaries\n\n    // Mark discovered if we haven't yet\n    auto S = FunctionHasParent.emplace(V, false);\n\n    // Stop if we've already discovered this node\n    if (!S.second)\n      return;\n\n    FunctionSummary *F =\n        dyn_cast<FunctionSummary>(V.getSummaryList().front().get());\n    assert(F != nullptr && \"Expected FunctionSummary node\");\n\n    for (auto &C : F->calls()) {\n      // Insert node if necessary\n      auto S = FunctionHasParent.emplace(C.first, true);\n\n      // Skip nodes that we're sure have parents\n      if (!S.second && S.first->second)\n        continue;\n\n      if (S.second)\n        discoverNodes(C.first, FunctionHasParent);\n      else\n        S.first->second = true;\n    }\n  }\n\n  // Calculate the callgraph root\n  FunctionSummary calculateCallGraphRoot() {\n    // Functions that have a parent will be marked in FunctionHasParent pair.\n    // Once we've marked all functions, the functions in the map that are false\n    // have no parent (so they're the roots)\n    std::map<ValueInfo, bool> FunctionHasParent;\n\n    for (auto &S : *this) {\n      // Skip external functions\n      if (!S.second.SummaryList.size() ||\n          !isa<FunctionSummary>(S.second.SummaryList.front().get()))\n        continue;\n      discoverNodes(ValueInfo(HaveGVs, &S), FunctionHasParent);\n    }\n\n    std::vector<FunctionSummary::EdgeTy> Edges;\n    // create edges to all roots in the Index\n    for (auto &P : FunctionHasParent) {\n      if (P.second)\n        continue; // skip over non-root nodes\n      Edges.push_back(std::make_pair(P.first, CalleeInfo{}));\n    }\n    if (Edges.empty()) {\n      // Failed to find root - return an empty node\n      return FunctionSummary::makeDummyFunctionSummary({});\n    }\n    auto CallGraphRoot = FunctionSummary::makeDummyFunctionSummary(Edges);\n    return CallGraphRoot;\n  }\n\n  bool withGlobalValueDeadStripping() const {\n    return WithGlobalValueDeadStripping;\n  }\n  void setWithGlobalValueDeadStripping() {\n    WithGlobalValueDeadStripping = true;\n  }\n\n  bool withAttributePropagation() const { return WithAttributePropagation; }\n  void setWithAttributePropagation() {\n    WithAttributePropagation = true;\n  }\n\n  bool withDSOLocalPropagation() const { return WithDSOLocalPropagation; }\n  void setWithDSOLocalPropagation() { WithDSOLocalPropagation = true; }\n\n  bool isReadOnly(const GlobalVarSummary *GVS) const {\n    return WithAttributePropagation && GVS->maybeReadOnly();\n  }\n  bool isWriteOnly(const GlobalVarSummary *GVS) const {\n    return WithAttributePropagation && GVS->maybeWriteOnly();\n  }\n\n  bool hasSyntheticEntryCounts() const { return HasSyntheticEntryCounts; }\n  void setHasSyntheticEntryCounts() { HasSyntheticEntryCounts = true; }\n\n  bool skipModuleByDistributedBackend() const {\n    return SkipModuleByDistributedBackend;\n  }\n  void setSkipModuleByDistributedBackend() {\n    SkipModuleByDistributedBackend = true;\n  }\n\n  bool enableSplitLTOUnit() const { return EnableSplitLTOUnit; }\n  void setEnableSplitLTOUnit() { EnableSplitLTOUnit = true; }\n\n  bool partiallySplitLTOUnits() const { return PartiallySplitLTOUnits; }\n  void setPartiallySplitLTOUnits() { PartiallySplitLTOUnits = true; }\n\n  bool hasParamAccess() const { return HasParamAccess; }\n\n  bool isGlobalValueLive(const GlobalValueSummary *GVS) const {\n    return !WithGlobalValueDeadStripping || GVS->isLive();\n  }\n  bool isGUIDLive(GlobalValue::GUID GUID) const;\n\n  /// Return a ValueInfo for the index value_type (convenient when iterating\n  /// index).\n  ValueInfo getValueInfo(const GlobalValueSummaryMapTy::value_type &R) const {\n    return ValueInfo(HaveGVs, &R);\n  }\n\n  /// Return a ValueInfo for GUID if it exists, otherwise return ValueInfo().\n  ValueInfo getValueInfo(GlobalValue::GUID GUID) const {\n    auto I = GlobalValueMap.find(GUID);\n    return ValueInfo(HaveGVs, I == GlobalValueMap.end() ? nullptr : &*I);\n  }\n\n  /// Return a ValueInfo for \\p GUID.\n  ValueInfo getOrInsertValueInfo(GlobalValue::GUID GUID) {\n    return ValueInfo(HaveGVs, getOrInsertValuePtr(GUID));\n  }\n\n  // Save a string in the Index. Use before passing Name to\n  // getOrInsertValueInfo when the string isn't owned elsewhere (e.g. on the\n  // module's Strtab).\n  StringRef saveString(StringRef String) { return Saver.save(String); }\n\n  /// Return a ValueInfo for \\p GUID setting value \\p Name.\n  ValueInfo getOrInsertValueInfo(GlobalValue::GUID GUID, StringRef Name) {\n    assert(!HaveGVs);\n    auto VP = getOrInsertValuePtr(GUID);\n    VP->second.U.Name = Name;\n    return ValueInfo(HaveGVs, VP);\n  }\n\n  /// Return a ValueInfo for \\p GV and mark it as belonging to GV.\n  ValueInfo getOrInsertValueInfo(const GlobalValue *GV) {\n    assert(HaveGVs);\n    auto VP = getOrInsertValuePtr(GV->getGUID());\n    VP->second.U.GV = GV;\n    return ValueInfo(HaveGVs, VP);\n  }\n\n  /// Return the GUID for \\p OriginalId in the OidGuidMap.\n  GlobalValue::GUID getGUIDFromOriginalID(GlobalValue::GUID OriginalID) const {\n    const auto I = OidGuidMap.find(OriginalID);\n    return I == OidGuidMap.end() ? 0 : I->second;\n  }\n\n  std::set<std::string> &cfiFunctionDefs() { return CfiFunctionDefs; }\n  const std::set<std::string> &cfiFunctionDefs() const { return CfiFunctionDefs; }\n\n  std::set<std::string> &cfiFunctionDecls() { return CfiFunctionDecls; }\n  const std::set<std::string> &cfiFunctionDecls() const { return CfiFunctionDecls; }\n\n  /// Add a global value summary for a value.\n  void addGlobalValueSummary(const GlobalValue &GV,\n                             std::unique_ptr<GlobalValueSummary> Summary) {\n    addGlobalValueSummary(getOrInsertValueInfo(&GV), std::move(Summary));\n  }\n\n  /// Add a global value summary for a value of the given name.\n  void addGlobalValueSummary(StringRef ValueName,\n                             std::unique_ptr<GlobalValueSummary> Summary) {\n    addGlobalValueSummary(getOrInsertValueInfo(GlobalValue::getGUID(ValueName)),\n                          std::move(Summary));\n  }\n\n  /// Add a global value summary for the given ValueInfo.\n  void addGlobalValueSummary(ValueInfo VI,\n                             std::unique_ptr<GlobalValueSummary> Summary) {\n    if (const FunctionSummary *FS = dyn_cast<FunctionSummary>(Summary.get()))\n      HasParamAccess |= !FS->paramAccesses().empty();\n    addOriginalName(VI.getGUID(), Summary->getOriginalName());\n    // Here we have a notionally const VI, but the value it points to is owned\n    // by the non-const *this.\n    const_cast<GlobalValueSummaryMapTy::value_type *>(VI.getRef())\n        ->second.SummaryList.push_back(std::move(Summary));\n  }\n\n  /// Add an original name for the value of the given GUID.\n  void addOriginalName(GlobalValue::GUID ValueGUID,\n                       GlobalValue::GUID OrigGUID) {\n    if (OrigGUID == 0 || ValueGUID == OrigGUID)\n      return;\n    if (OidGuidMap.count(OrigGUID) && OidGuidMap[OrigGUID] != ValueGUID)\n      OidGuidMap[OrigGUID] = 0;\n    else\n      OidGuidMap[OrigGUID] = ValueGUID;\n  }\n\n  /// Find the summary for ValueInfo \\p VI in module \\p ModuleId, or nullptr if\n  /// not found.\n  GlobalValueSummary *findSummaryInModule(ValueInfo VI, StringRef ModuleId) const {\n    auto SummaryList = VI.getSummaryList();\n    auto Summary =\n        llvm::find_if(SummaryList,\n                      [&](const std::unique_ptr<GlobalValueSummary> &Summary) {\n                        return Summary->modulePath() == ModuleId;\n                      });\n    if (Summary == SummaryList.end())\n      return nullptr;\n    return Summary->get();\n  }\n\n  /// Find the summary for global \\p GUID in module \\p ModuleId, or nullptr if\n  /// not found.\n  GlobalValueSummary *findSummaryInModule(GlobalValue::GUID ValueGUID,\n                                          StringRef ModuleId) const {\n    auto CalleeInfo = getValueInfo(ValueGUID);\n    if (!CalleeInfo)\n      return nullptr; // This function does not have a summary\n    return findSummaryInModule(CalleeInfo, ModuleId);\n  }\n\n  /// Returns the first GlobalValueSummary for \\p GV, asserting that there\n  /// is only one if \\p PerModuleIndex.\n  GlobalValueSummary *getGlobalValueSummary(const GlobalValue &GV,\n                                            bool PerModuleIndex = true) const {\n    assert(GV.hasName() && \"Can't get GlobalValueSummary for GV with no name\");\n    return getGlobalValueSummary(GV.getGUID(), PerModuleIndex);\n  }\n\n  /// Returns the first GlobalValueSummary for \\p ValueGUID, asserting that\n  /// there\n  /// is only one if \\p PerModuleIndex.\n  GlobalValueSummary *getGlobalValueSummary(GlobalValue::GUID ValueGUID,\n                                            bool PerModuleIndex = true) const;\n\n  /// Table of modules, containing module hash and id.\n  const StringMap<std::pair<uint64_t, ModuleHash>> &modulePaths() const {\n    return ModulePathStringTable;\n  }\n\n  /// Table of modules, containing hash and id.\n  StringMap<std::pair<uint64_t, ModuleHash>> &modulePaths() {\n    return ModulePathStringTable;\n  }\n\n  /// Get the module ID recorded for the given module path.\n  uint64_t getModuleId(const StringRef ModPath) const {\n    return ModulePathStringTable.lookup(ModPath).first;\n  }\n\n  /// Get the module SHA1 hash recorded for the given module path.\n  const ModuleHash &getModuleHash(const StringRef ModPath) const {\n    auto It = ModulePathStringTable.find(ModPath);\n    assert(It != ModulePathStringTable.end() && \"Module not registered\");\n    return It->second.second;\n  }\n\n  /// Convenience method for creating a promoted global name\n  /// for the given value name of a local, and its original module's ID.\n  static std::string getGlobalNameForLocal(StringRef Name, ModuleHash ModHash) {\n    SmallString<256> NewName(Name);\n    NewName += \".llvm.\";\n    NewName += utostr((uint64_t(ModHash[0]) << 32) |\n                      ModHash[1]); // Take the first 64 bits\n    return std::string(NewName.str());\n  }\n\n  /// Helper to obtain the unpromoted name for a global value (or the original\n  /// name if not promoted). Split off the rightmost \".llvm.${hash}\" suffix,\n  /// because it is possible in certain clients (not clang at the moment) for\n  /// two rounds of ThinLTO optimization and therefore promotion to occur.\n  static StringRef getOriginalNameBeforePromote(StringRef Name) {\n    std::pair<StringRef, StringRef> Pair = Name.rsplit(\".llvm.\");\n    return Pair.first;\n  }\n\n  typedef ModulePathStringTableTy::value_type ModuleInfo;\n\n  /// Add a new module with the given \\p Hash, mapped to the given \\p\n  /// ModID, and return a reference to the module.\n  ModuleInfo *addModule(StringRef ModPath, uint64_t ModId,\n                        ModuleHash Hash = ModuleHash{{0}}) {\n    return &*ModulePathStringTable.insert({ModPath, {ModId, Hash}}).first;\n  }\n\n  /// Return module entry for module with the given \\p ModPath.\n  ModuleInfo *getModule(StringRef ModPath) {\n    auto It = ModulePathStringTable.find(ModPath);\n    assert(It != ModulePathStringTable.end() && \"Module not registered\");\n    return &*It;\n  }\n\n  /// Check if the given Module has any functions available for exporting\n  /// in the index. We consider any module present in the ModulePathStringTable\n  /// to have exported functions.\n  bool hasExportedFunctions(const Module &M) const {\n    return ModulePathStringTable.count(M.getModuleIdentifier());\n  }\n\n  const TypeIdSummaryMapTy &typeIds() const { return TypeIdMap; }\n\n  /// Return an existing or new TypeIdSummary entry for \\p TypeId.\n  /// This accessor can mutate the map and therefore should not be used in\n  /// the ThinLTO backends.\n  TypeIdSummary &getOrInsertTypeIdSummary(StringRef TypeId) {\n    auto TidIter = TypeIdMap.equal_range(GlobalValue::getGUID(TypeId));\n    for (auto It = TidIter.first; It != TidIter.second; ++It)\n      if (It->second.first == TypeId)\n        return It->second.second;\n    auto It = TypeIdMap.insert(\n        {GlobalValue::getGUID(TypeId), {std::string(TypeId), TypeIdSummary()}});\n    return It->second.second;\n  }\n\n  /// This returns either a pointer to the type id summary (if present in the\n  /// summary map) or null (if not present). This may be used when importing.\n  const TypeIdSummary *getTypeIdSummary(StringRef TypeId) const {\n    auto TidIter = TypeIdMap.equal_range(GlobalValue::getGUID(TypeId));\n    for (auto It = TidIter.first; It != TidIter.second; ++It)\n      if (It->second.first == TypeId)\n        return &It->second.second;\n    return nullptr;\n  }\n\n  TypeIdSummary *getTypeIdSummary(StringRef TypeId) {\n    return const_cast<TypeIdSummary *>(\n        static_cast<const ModuleSummaryIndex *>(this)->getTypeIdSummary(\n            TypeId));\n  }\n\n  const auto &typeIdCompatibleVtableMap() const {\n    return TypeIdCompatibleVtableMap;\n  }\n\n  /// Return an existing or new TypeIdCompatibleVtableMap entry for \\p TypeId.\n  /// This accessor can mutate the map and therefore should not be used in\n  /// the ThinLTO backends.\n  TypeIdCompatibleVtableInfo &\n  getOrInsertTypeIdCompatibleVtableSummary(StringRef TypeId) {\n    return TypeIdCompatibleVtableMap[std::string(TypeId)];\n  }\n\n  /// For the given \\p TypeId, this returns the TypeIdCompatibleVtableMap\n  /// entry if present in the summary map. This may be used when importing.\n  Optional<TypeIdCompatibleVtableInfo>\n  getTypeIdCompatibleVtableSummary(StringRef TypeId) const {\n    auto I = TypeIdCompatibleVtableMap.find(TypeId);\n    if (I == TypeIdCompatibleVtableMap.end())\n      return None;\n    return I->second;\n  }\n\n  /// Collect for the given module the list of functions it defines\n  /// (GUID -> Summary).\n  void collectDefinedFunctionsForModule(StringRef ModulePath,\n                                        GVSummaryMapTy &GVSummaryMap) const;\n\n  /// Collect for each module the list of Summaries it defines (GUID ->\n  /// Summary).\n  template <class Map>\n  void\n  collectDefinedGVSummariesPerModule(Map &ModuleToDefinedGVSummaries) const {\n    for (auto &GlobalList : *this) {\n      auto GUID = GlobalList.first;\n      for (auto &Summary : GlobalList.second.SummaryList) {\n        ModuleToDefinedGVSummaries[Summary->modulePath()][GUID] = Summary.get();\n      }\n    }\n  }\n\n  /// Print to an output stream.\n  void print(raw_ostream &OS, bool IsForDebug = false) const;\n\n  /// Dump to stderr (for debugging).\n  void dump() const;\n\n  /// Export summary to dot file for GraphViz.\n  void\n  exportToDot(raw_ostream &OS,\n              const DenseSet<GlobalValue::GUID> &GUIDPreservedSymbols) const;\n\n  /// Print out strongly connected components for debugging.\n  void dumpSCCs(raw_ostream &OS);\n\n  /// Do the access attribute and DSOLocal propagation in combined index.\n  void propagateAttributes(const DenseSet<GlobalValue::GUID> &PreservedSymbols);\n\n  /// Checks if we can import global variable from another module.\n  bool canImportGlobalVar(GlobalValueSummary *S, bool AnalyzeRefs) const;\n};\n\n/// GraphTraits definition to build SCC for the index\ntemplate <> struct GraphTraits<ValueInfo> {\n  typedef ValueInfo NodeRef;\n  using EdgeRef = FunctionSummary::EdgeTy &;\n\n  static NodeRef valueInfoFromEdge(FunctionSummary::EdgeTy &P) {\n    return P.first;\n  }\n  using ChildIteratorType =\n      mapped_iterator<std::vector<FunctionSummary::EdgeTy>::iterator,\n                      decltype(&valueInfoFromEdge)>;\n\n  using ChildEdgeIteratorType = std::vector<FunctionSummary::EdgeTy>::iterator;\n\n  static NodeRef getEntryNode(ValueInfo V) { return V; }\n\n  static ChildIteratorType child_begin(NodeRef N) {\n    if (!N.getSummaryList().size()) // handle external function\n      return ChildIteratorType(\n          FunctionSummary::ExternalNode.CallGraphEdgeList.begin(),\n          &valueInfoFromEdge);\n    FunctionSummary *F =\n        cast<FunctionSummary>(N.getSummaryList().front()->getBaseObject());\n    return ChildIteratorType(F->CallGraphEdgeList.begin(), &valueInfoFromEdge);\n  }\n\n  static ChildIteratorType child_end(NodeRef N) {\n    if (!N.getSummaryList().size()) // handle external function\n      return ChildIteratorType(\n          FunctionSummary::ExternalNode.CallGraphEdgeList.end(),\n          &valueInfoFromEdge);\n    FunctionSummary *F =\n        cast<FunctionSummary>(N.getSummaryList().front()->getBaseObject());\n    return ChildIteratorType(F->CallGraphEdgeList.end(), &valueInfoFromEdge);\n  }\n\n  static ChildEdgeIteratorType child_edge_begin(NodeRef N) {\n    if (!N.getSummaryList().size()) // handle external function\n      return FunctionSummary::ExternalNode.CallGraphEdgeList.begin();\n\n    FunctionSummary *F =\n        cast<FunctionSummary>(N.getSummaryList().front()->getBaseObject());\n    return F->CallGraphEdgeList.begin();\n  }\n\n  static ChildEdgeIteratorType child_edge_end(NodeRef N) {\n    if (!N.getSummaryList().size()) // handle external function\n      return FunctionSummary::ExternalNode.CallGraphEdgeList.end();\n\n    FunctionSummary *F =\n        cast<FunctionSummary>(N.getSummaryList().front()->getBaseObject());\n    return F->CallGraphEdgeList.end();\n  }\n\n  static NodeRef edge_dest(EdgeRef E) { return E.first; }\n};\n\ntemplate <>\nstruct GraphTraits<ModuleSummaryIndex *> : public GraphTraits<ValueInfo> {\n  static NodeRef getEntryNode(ModuleSummaryIndex *I) {\n    std::unique_ptr<GlobalValueSummary> Root =\n        std::make_unique<FunctionSummary>(I->calculateCallGraphRoot());\n    GlobalValueSummaryInfo G(I->haveGVs());\n    G.SummaryList.push_back(std::move(Root));\n    static auto P =\n        GlobalValueSummaryMapTy::value_type(GlobalValue::GUID(0), std::move(G));\n    return ValueInfo(I->haveGVs(), &P);\n  }\n};\n} // end namespace llvm\n\n#endif // LLVM_IR_MODULESUMMARYINDEX_H\n"}, "37": {"id": 37, "path": "/home/vsts/work/1/llvm-project/llvm/lib/AsmParser/LLLexer.h", "content": "//===- LLLexer.h - Lexer for LLVM Assembly Files ----------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// This class represents the Lexer for .ll files.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_LIB_ASMPARSER_LLLEXER_H\n#define LLVM_LIB_ASMPARSER_LLLEXER_H\n\n#include \"LLToken.h\"\n#include \"llvm/ADT/APFloat.h\"\n#include \"llvm/ADT/APSInt.h\"\n#include \"llvm/Support/SMLoc.h\"\n#include <string>\n\nnamespace llvm {\n  class Type;\n  class SMDiagnostic;\n  class SourceMgr;\n  class LLVMContext;\n\n  class LLLexer {\n    const char *CurPtr;\n    StringRef CurBuf;\n    SMDiagnostic &ErrorInfo;\n    SourceMgr &SM;\n    LLVMContext &Context;\n\n    // Information about the current token.\n    const char *TokStart;\n    lltok::Kind CurKind;\n    std::string StrVal;\n    unsigned UIntVal;\n    Type *TyVal;\n    APFloat APFloatVal;\n    APSInt  APSIntVal;\n\n    // When false (default), an identifier ending in ':' is a label token.\n    // When true, the ':' is treated as a separate token.\n    bool IgnoreColonInIdentifiers;\n\n  public:\n    explicit LLLexer(StringRef StartBuf, SourceMgr &SM, SMDiagnostic &,\n                     LLVMContext &C);\n\n    lltok::Kind Lex() {\n      return CurKind = LexToken();\n    }\n\n    typedef SMLoc LocTy;\n    LocTy getLoc() const { return SMLoc::getFromPointer(TokStart); }\n    lltok::Kind getKind() const { return CurKind; }\n    const std::string &getStrVal() const { return StrVal; }\n    Type *getTyVal() const { return TyVal; }\n    unsigned getUIntVal() const { return UIntVal; }\n    const APSInt &getAPSIntVal() const { return APSIntVal; }\n    const APFloat &getAPFloatVal() const { return APFloatVal; }\n\n    void setIgnoreColonInIdentifiers(bool val) {\n      IgnoreColonInIdentifiers = val;\n    }\n\n    bool Error(LocTy ErrorLoc, const Twine &Msg) const;\n    bool Error(const Twine &Msg) const { return Error(getLoc(), Msg); }\n\n    void Warning(LocTy WarningLoc, const Twine &Msg) const;\n    void Warning(const Twine &Msg) const { return Warning(getLoc(), Msg); }\n\n  private:\n    lltok::Kind LexToken();\n\n    int getNextChar();\n    void SkipLineComment();\n    lltok::Kind ReadString(lltok::Kind kind);\n    bool ReadVarName();\n\n    lltok::Kind LexIdentifier();\n    lltok::Kind LexDigitOrNegative();\n    lltok::Kind LexPositive();\n    lltok::Kind LexAt();\n    lltok::Kind LexDollar();\n    lltok::Kind LexExclaim();\n    lltok::Kind LexPercent();\n    lltok::Kind LexUIntID(lltok::Kind Token);\n    lltok::Kind LexVar(lltok::Kind Var, lltok::Kind VarID);\n    lltok::Kind LexQuote();\n    lltok::Kind Lex0x();\n    lltok::Kind LexHash();\n    lltok::Kind LexCaret();\n\n    uint64_t atoull(const char *Buffer, const char *End);\n    uint64_t HexIntToVal(const char *Buffer, const char *End);\n    void HexToIntPair(const char *Buffer, const char *End, uint64_t Pair[2]);\n    void FP80HexToIntPair(const char *Buffer, const char *End, uint64_t Pair[2]);\n  };\n} // end namespace llvm\n\n#endif\n"}, "38": {"id": 38, "path": "/home/vsts/work/1/llvm-project/llvm/lib/AsmParser/LLParser.cpp", "content": "//===-- LLParser.cpp - Parser Class ---------------------------------------===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n//  This file defines the parser class for .ll files.\n//\n//===----------------------------------------------------------------------===//\n\n#include \"LLParser.h\"\n#include \"LLToken.h\"\n#include \"llvm/ADT/APSInt.h\"\n#include \"llvm/ADT/DenseMap.h\"\n#include \"llvm/ADT/None.h\"\n#include \"llvm/ADT/STLExtras.h\"\n#include \"llvm/ADT/SmallPtrSet.h\"\n#include \"llvm/AsmParser/SlotMapping.h\"\n#include \"llvm/BinaryFormat/Dwarf.h\"\n#include \"llvm/IR/Argument.h\"\n#include \"llvm/IR/AutoUpgrade.h\"\n#include \"llvm/IR/BasicBlock.h\"\n#include \"llvm/IR/CallingConv.h\"\n#include \"llvm/IR/Comdat.h\"\n#include \"llvm/IR/ConstantRange.h\"\n#include \"llvm/IR/Constants.h\"\n#include \"llvm/IR/DebugInfoMetadata.h\"\n#include \"llvm/IR/DerivedTypes.h\"\n#include \"llvm/IR/Function.h\"\n#include \"llvm/IR/GlobalIFunc.h\"\n#include \"llvm/IR/GlobalObject.h\"\n#include \"llvm/IR/InlineAsm.h\"\n#include \"llvm/IR/Intrinsics.h\"\n#include \"llvm/IR/LLVMContext.h\"\n#include \"llvm/IR/Metadata.h\"\n#include \"llvm/IR/Module.h\"\n#include \"llvm/IR/Value.h\"\n#include \"llvm/IR/ValueSymbolTable.h\"\n#include \"llvm/Support/Casting.h\"\n#include \"llvm/Support/ErrorHandling.h\"\n#include \"llvm/Support/MathExtras.h\"\n#include \"llvm/Support/SaveAndRestore.h\"\n#include \"llvm/Support/raw_ostream.h\"\n#include <algorithm>\n#include <cassert>\n#include <cstring>\n#include <iterator>\n#include <vector>\n\nusing namespace llvm;\n\nstatic std::string getTypeString(Type *T) {\n  std::string Result;\n  raw_string_ostream Tmp(Result);\n  Tmp << *T;\n  return Tmp.str();\n}\n\n/// Run: module ::= toplevelentity*\nbool LLParser::Run(bool UpgradeDebugInfo,\n                   DataLayoutCallbackTy DataLayoutCallback) {\n  // Prime the lexer.\n  Lex.Lex();\n\n  if (Context.shouldDiscardValueNames())\n    return error(\n        Lex.getLoc(),\n        \"Can't read textual IR with a Context that discards named Values\");\n\n  if (M) {\n    if (parseTargetDefinitions())\n      return true;\n\n    if (auto LayoutOverride = DataLayoutCallback(M->getTargetTriple()))\n      M->setDataLayout(*LayoutOverride);\n  }\n\n  return parseTopLevelEntities() || validateEndOfModule(UpgradeDebugInfo) ||\n         validateEndOfIndex();\n}\n\nbool LLParser::parseStandaloneConstantValue(Constant *&C,\n                                            const SlotMapping *Slots) {\n  restoreParsingState(Slots);\n  Lex.Lex();\n\n  Type *Ty = nullptr;\n  if (parseType(Ty) || parseConstantValue(Ty, C))\n    return true;\n  if (Lex.getKind() != lltok::Eof)\n    return error(Lex.getLoc(), \"expected end of string\");\n  return false;\n}\n\nbool LLParser::parseTypeAtBeginning(Type *&Ty, unsigned &Read,\n                                    const SlotMapping *Slots) {\n  restoreParsingState(Slots);\n  Lex.Lex();\n\n  Read = 0;\n  SMLoc Start = Lex.getLoc();\n  Ty = nullptr;\n  if (parseType(Ty))\n    return true;\n  SMLoc End = Lex.getLoc();\n  Read = End.getPointer() - Start.getPointer();\n\n  return false;\n}\n\nvoid LLParser::restoreParsingState(const SlotMapping *Slots) {\n  if (!Slots)\n    return;\n  NumberedVals = Slots->GlobalValues;\n  NumberedMetadata = Slots->MetadataNodes;\n  for (const auto &I : Slots->NamedTypes)\n    NamedTypes.insert(\n        std::make_pair(I.getKey(), std::make_pair(I.second, LocTy())));\n  for (const auto &I : Slots->Types)\n    NumberedTypes.insert(\n        std::make_pair(I.first, std::make_pair(I.second, LocTy())));\n}\n\n/// validateEndOfModule - Do final validity and sanity checks at the end of the\n/// module.\nbool LLParser::validateEndOfModule(bool UpgradeDebugInfo) {\n  if (!M)\n    return false;\n  // Handle any function attribute group forward references.\n  for (const auto &RAG : ForwardRefAttrGroups) {\n    Value *V = RAG.first;\n    const std::vector<unsigned> &Attrs = RAG.second;\n    AttrBuilder B;\n\n    for (const auto &Attr : Attrs)\n      B.merge(NumberedAttrBuilders[Attr]);\n\n    if (Function *Fn = dyn_cast<Function>(V)) {\n      AttributeList AS = Fn->getAttributes();\n      AttrBuilder FnAttrs(AS.getFnAttributes());\n      AS = AS.removeAttributes(Context, AttributeList::FunctionIndex);\n\n      FnAttrs.merge(B);\n\n      // If the alignment was parsed as an attribute, move to the alignment\n      // field.\n      if (FnAttrs.hasAlignmentAttr()) {\n        Fn->setAlignment(FnAttrs.getAlignment());\n        FnAttrs.removeAttribute(Attribute::Alignment);\n      }\n\n      AS = AS.addAttributes(Context, AttributeList::FunctionIndex,\n                            AttributeSet::get(Context, FnAttrs));\n      Fn->setAttributes(AS);\n    } else if (CallInst *CI = dyn_cast<CallInst>(V)) {\n      AttributeList AS = CI->getAttributes();\n      AttrBuilder FnAttrs(AS.getFnAttributes());\n      AS = AS.removeAttributes(Context, AttributeList::FunctionIndex);\n      FnAttrs.merge(B);\n      AS = AS.addAttributes(Context, AttributeList::FunctionIndex,\n                            AttributeSet::get(Context, FnAttrs));\n      CI->setAttributes(AS);\n    } else if (InvokeInst *II = dyn_cast<InvokeInst>(V)) {\n      AttributeList AS = II->getAttributes();\n      AttrBuilder FnAttrs(AS.getFnAttributes());\n      AS = AS.removeAttributes(Context, AttributeList::FunctionIndex);\n      FnAttrs.merge(B);\n      AS = AS.addAttributes(Context, AttributeList::FunctionIndex,\n                            AttributeSet::get(Context, FnAttrs));\n      II->setAttributes(AS);\n    } else if (CallBrInst *CBI = dyn_cast<CallBrInst>(V)) {\n      AttributeList AS = CBI->getAttributes();\n      AttrBuilder FnAttrs(AS.getFnAttributes());\n      AS = AS.removeAttributes(Context, AttributeList::FunctionIndex);\n      FnAttrs.merge(B);\n      AS = AS.addAttributes(Context, AttributeList::FunctionIndex,\n                            AttributeSet::get(Context, FnAttrs));\n      CBI->setAttributes(AS);\n    } else if (auto *GV = dyn_cast<GlobalVariable>(V)) {\n      AttrBuilder Attrs(GV->getAttributes());\n      Attrs.merge(B);\n      GV->setAttributes(AttributeSet::get(Context,Attrs));\n    } else {\n      llvm_unreachable(\"invalid object with forward attribute group reference\");\n    }\n  }\n\n  // If there are entries in ForwardRefBlockAddresses at this point, the\n  // function was never defined.\n  if (!ForwardRefBlockAddresses.empty())\n    return error(ForwardRefBlockAddresses.begin()->first.Loc,\n                 \"expected function name in blockaddress\");\n\n  for (const auto &NT : NumberedTypes)\n    if (NT.second.second.isValid())\n      return error(NT.second.second,\n                   \"use of undefined type '%\" + Twine(NT.first) + \"'\");\n\n  for (StringMap<std::pair<Type*, LocTy> >::iterator I =\n       NamedTypes.begin(), E = NamedTypes.end(); I != E; ++I)\n    if (I->second.second.isValid())\n      return error(I->second.second,\n                   \"use of undefined type named '\" + I->getKey() + \"'\");\n\n  if (!ForwardRefComdats.empty())\n    return error(ForwardRefComdats.begin()->second,\n                 \"use of undefined comdat '$\" +\n                     ForwardRefComdats.begin()->first + \"'\");\n\n  if (!ForwardRefVals.empty())\n    return error(ForwardRefVals.begin()->second.second,\n                 \"use of undefined value '@\" + ForwardRefVals.begin()->first +\n                     \"'\");\n\n  if (!ForwardRefValIDs.empty())\n    return error(ForwardRefValIDs.begin()->second.second,\n                 \"use of undefined value '@\" +\n                     Twine(ForwardRefValIDs.begin()->first) + \"'\");\n\n  if (!ForwardRefMDNodes.empty())\n    return error(ForwardRefMDNodes.begin()->second.second,\n                 \"use of undefined metadata '!\" +\n                     Twine(ForwardRefMDNodes.begin()->first) + \"'\");\n\n  // Resolve metadata cycles.\n  for (auto &N : NumberedMetadata) {\n    if (N.second && !N.second->isResolved())\n      N.second->resolveCycles();\n  }\n\n  for (auto *Inst : InstsWithTBAATag) {\n    MDNode *MD = Inst->getMetadata(LLVMContext::MD_tbaa);\n    assert(MD && \"UpgradeInstWithTBAATag should have a TBAA tag\");\n    auto *UpgradedMD = UpgradeTBAANode(*MD);\n    if (MD != UpgradedMD)\n      Inst->setMetadata(LLVMContext::MD_tbaa, UpgradedMD);\n  }\n\n  // Look for intrinsic functions and CallInst that need to be upgraded\n  for (Module::iterator FI = M->begin(), FE = M->end(); FI != FE; )\n    UpgradeCallsToIntrinsic(&*FI++); // must be post-increment, as we remove\n\n  // Some types could be renamed during loading if several modules are\n  // loaded in the same LLVMContext (LTO scenario). In this case we should\n  // remangle intrinsics names as well.\n  for (Module::iterator FI = M->begin(), FE = M->end(); FI != FE; ) {\n    Function *F = &*FI++;\n    if (auto Remangled = Intrinsic::remangleIntrinsicFunction(F)) {\n      F->replaceAllUsesWith(Remangled.getValue());\n      F->eraseFromParent();\n    }\n  }\n\n  if (UpgradeDebugInfo)\n    llvm::UpgradeDebugInfo(*M);\n\n  UpgradeModuleFlags(*M);\n  UpgradeSectionAttributes(*M);\n\n  if (!Slots)\n    return false;\n  // Initialize the slot mapping.\n  // Because by this point we've parsed and validated everything, we can \"steal\"\n  // the mapping from LLParser as it doesn't need it anymore.\n  Slots->GlobalValues = std::move(NumberedVals);\n  Slots->MetadataNodes = std::move(NumberedMetadata);\n  for (const auto &I : NamedTypes)\n    Slots->NamedTypes.insert(std::make_pair(I.getKey(), I.second.first));\n  for (const auto &I : NumberedTypes)\n    Slots->Types.insert(std::make_pair(I.first, I.second.first));\n\n  return false;\n}\n\n/// Do final validity and sanity checks at the end of the index.\nbool LLParser::validateEndOfIndex() {\n  if (!Index)\n    return false;\n\n  if (!ForwardRefValueInfos.empty())\n    return error(ForwardRefValueInfos.begin()->second.front().second,\n                 \"use of undefined summary '^\" +\n                     Twine(ForwardRefValueInfos.begin()->first) + \"'\");\n\n  if (!ForwardRefAliasees.empty())\n    return error(ForwardRefAliasees.begin()->second.front().second,\n                 \"use of undefined summary '^\" +\n                     Twine(ForwardRefAliasees.begin()->first) + \"'\");\n\n  if (!ForwardRefTypeIds.empty())\n    return error(ForwardRefTypeIds.begin()->second.front().second,\n                 \"use of undefined type id summary '^\" +\n                     Twine(ForwardRefTypeIds.begin()->first) + \"'\");\n\n  return false;\n}\n\n//===----------------------------------------------------------------------===//\n// Top-Level Entities\n//===----------------------------------------------------------------------===//\n\nbool LLParser::parseTargetDefinitions() {\n  while (true) {\n    switch (Lex.getKind()) {\n    case lltok::kw_target:\n      if (parseTargetDefinition())\n        return true;\n      break;\n    case lltok::kw_source_filename:\n      if (parseSourceFileName())\n        return true;\n      break;\n    default:\n      return false;\n    }\n  }\n}\n\nbool LLParser::parseTopLevelEntities() {\n  // If there is no Module, then parse just the summary index entries.\n  if (!M) {\n    while (true) {\n      switch (Lex.getKind()) {\n      case lltok::Eof:\n        return false;\n      case lltok::SummaryID:\n        if (parseSummaryEntry())\n          return true;\n        break;\n      case lltok::kw_source_filename:\n        if (parseSourceFileName())\n          return true;\n        break;\n      default:\n        // Skip everything else\n        Lex.Lex();\n      }\n    }\n  }\n  while (true) {\n    switch (Lex.getKind()) {\n    default:\n      return tokError(\"expected top-level entity\");\n    case lltok::Eof: return false;\n    case lltok::kw_declare:\n      if (parseDeclare())\n        return true;\n      break;\n    case lltok::kw_define:\n      if (parseDefine())\n        return true;\n      break;\n    case lltok::kw_module:\n      if (parseModuleAsm())\n        return true;\n      break;\n    case lltok::kw_deplibs:\n      if (parseDepLibs())\n        return true;\n      break;\n    case lltok::LocalVarID:\n      if (parseUnnamedType())\n        return true;\n      break;\n    case lltok::LocalVar:\n      if (parseNamedType())\n        return true;\n      break;\n    case lltok::GlobalID:\n      if (parseUnnamedGlobal())\n        return true;\n      break;\n    case lltok::GlobalVar:\n      if (parseNamedGlobal())\n        return true;\n      break;\n    case lltok::ComdatVar:  if (parseComdat()) return true; break;\n    case lltok::exclaim:\n      if (parseStandaloneMetadata())\n        return true;\n      break;\n    case lltok::SummaryID:\n      if (parseSummaryEntry())\n        return true;\n      break;\n    case lltok::MetadataVar:\n      if (parseNamedMetadata())\n        return true;\n      break;\n    case lltok::kw_attributes:\n      if (parseUnnamedAttrGrp())\n        return true;\n      break;\n    case lltok::kw_uselistorder:\n      if (parseUseListOrder())\n        return true;\n      break;\n    case lltok::kw_uselistorder_bb:\n      if (parseUseListOrderBB())\n        return true;\n      break;\n    }\n  }\n}\n\n/// toplevelentity\n///   ::= 'module' 'asm' STRINGCONSTANT\nbool LLParser::parseModuleAsm() {\n  assert(Lex.getKind() == lltok::kw_module);\n  Lex.Lex();\n\n  std::string AsmStr;\n  if (parseToken(lltok::kw_asm, \"expected 'module asm'\") ||\n      parseStringConstant(AsmStr))\n    return true;\n\n  M->appendModuleInlineAsm(AsmStr);\n  return false;\n}\n\n/// toplevelentity\n///   ::= 'target' 'triple' '=' STRINGCONSTANT\n///   ::= 'target' 'datalayout' '=' STRINGCONSTANT\nbool LLParser::parseTargetDefinition() {\n  assert(Lex.getKind() == lltok::kw_target);\n  std::string Str;\n  switch (Lex.Lex()) {\n  default:\n    return tokError(\"unknown target property\");\n  case lltok::kw_triple:\n    Lex.Lex();\n    if (parseToken(lltok::equal, \"expected '=' after target triple\") ||\n        parseStringConstant(Str))\n      return true;\n    M->setTargetTriple(Str);\n    return false;\n  case lltok::kw_datalayout:\n    Lex.Lex();\n    if (parseToken(lltok::equal, \"expected '=' after target datalayout\") ||\n        parseStringConstant(Str))\n      return true;\n    M->setDataLayout(Str);\n    return false;\n  }\n}\n\n/// toplevelentity\n///   ::= 'source_filename' '=' STRINGCONSTANT\nbool LLParser::parseSourceFileName() {\n  assert(Lex.getKind() == lltok::kw_source_filename);\n  Lex.Lex();\n  if (parseToken(lltok::equal, \"expected '=' after source_filename\") ||\n      parseStringConstant(SourceFileName))\n    return true;\n  if (M)\n    M->setSourceFileName(SourceFileName);\n  return false;\n}\n\n/// toplevelentity\n///   ::= 'deplibs' '=' '[' ']'\n///   ::= 'deplibs' '=' '[' STRINGCONSTANT (',' STRINGCONSTANT)* ']'\n/// FIXME: Remove in 4.0. Currently parse, but ignore.\nbool LLParser::parseDepLibs() {\n  assert(Lex.getKind() == lltok::kw_deplibs);\n  Lex.Lex();\n  if (parseToken(lltok::equal, \"expected '=' after deplibs\") ||\n      parseToken(lltok::lsquare, \"expected '=' after deplibs\"))\n    return true;\n\n  if (EatIfPresent(lltok::rsquare))\n    return false;\n\n  do {\n    std::string Str;\n    if (parseStringConstant(Str))\n      return true;\n  } while (EatIfPresent(lltok::comma));\n\n  return parseToken(lltok::rsquare, \"expected ']' at end of list\");\n}\n\n/// parseUnnamedType:\n///   ::= LocalVarID '=' 'type' type\nbool LLParser::parseUnnamedType() {\n  LocTy TypeLoc = Lex.getLoc();\n  unsigned TypeID = Lex.getUIntVal();\n  Lex.Lex(); // eat LocalVarID;\n\n  if (parseToken(lltok::equal, \"expected '=' after name\") ||\n      parseToken(lltok::kw_type, \"expected 'type' after '='\"))\n    return true;\n\n  Type *Result = nullptr;\n  if (parseStructDefinition(TypeLoc, \"\", NumberedTypes[TypeID], Result))\n    return true;\n\n  if (!isa<StructType>(Result)) {\n    std::pair<Type*, LocTy> &Entry = NumberedTypes[TypeID];\n    if (Entry.first)\n      return error(TypeLoc, \"non-struct types may not be recursive\");\n    Entry.first = Result;\n    Entry.second = SMLoc();\n  }\n\n  return false;\n}\n\n/// toplevelentity\n///   ::= LocalVar '=' 'type' type\nbool LLParser::parseNamedType() {\n  std::string Name = Lex.getStrVal();\n  LocTy NameLoc = Lex.getLoc();\n  Lex.Lex();  // eat LocalVar.\n\n  if (parseToken(lltok::equal, \"expected '=' after name\") ||\n      parseToken(lltok::kw_type, \"expected 'type' after name\"))\n    return true;\n\n  Type *Result = nullptr;\n  if (parseStructDefinition(NameLoc, Name, NamedTypes[Name], Result))\n    return true;\n\n  if (!isa<StructType>(Result)) {\n    std::pair<Type*, LocTy> &Entry = NamedTypes[Name];\n    if (Entry.first)\n      return error(NameLoc, \"non-struct types may not be recursive\");\n    Entry.first = Result;\n    Entry.second = SMLoc();\n  }\n\n  return false;\n}\n\n/// toplevelentity\n///   ::= 'declare' FunctionHeader\nbool LLParser::parseDeclare() {\n  assert(Lex.getKind() == lltok::kw_declare);\n  Lex.Lex();\n\n  std::vector<std::pair<unsigned, MDNode *>> MDs;\n  while (Lex.getKind() == lltok::MetadataVar) {\n    unsigned MDK;\n    MDNode *N;\n    if (parseMetadataAttachment(MDK, N))\n      return true;\n    MDs.push_back({MDK, N});\n  }\n\n  Function *F;\n  if (parseFunctionHeader(F, false))\n    return true;\n  for (auto &MD : MDs)\n    F->addMetadata(MD.first, *MD.second);\n  return false;\n}\n\n/// toplevelentity\n///   ::= 'define' FunctionHeader (!dbg !56)* '{' ...\nbool LLParser::parseDefine() {\n  assert(Lex.getKind() == lltok::kw_define);\n  Lex.Lex();\n\n  Function *F;\n  return parseFunctionHeader(F, true) || parseOptionalFunctionMetadata(*F) ||\n         parseFunctionBody(*F);\n}\n\n/// parseGlobalType\n///   ::= 'constant'\n///   ::= 'global'\nbool LLParser::parseGlobalType(bool &IsConstant) {\n  if (Lex.getKind() == lltok::kw_constant)\n    IsConstant = true;\n  else if (Lex.getKind() == lltok::kw_global)\n    IsConstant = false;\n  else {\n    IsConstant = false;\n    return tokError(\"expected 'global' or 'constant'\");\n  }\n  Lex.Lex();\n  return false;\n}\n\nbool LLParser::parseOptionalUnnamedAddr(\n    GlobalVariable::UnnamedAddr &UnnamedAddr) {\n  if (EatIfPresent(lltok::kw_unnamed_addr))\n    UnnamedAddr = GlobalValue::UnnamedAddr::Global;\n  else if (EatIfPresent(lltok::kw_local_unnamed_addr))\n    UnnamedAddr = GlobalValue::UnnamedAddr::Local;\n  else\n    UnnamedAddr = GlobalValue::UnnamedAddr::None;\n  return false;\n}\n\n/// parseUnnamedGlobal:\n///   OptionalVisibility (ALIAS | IFUNC) ...\n///   OptionalLinkage OptionalPreemptionSpecifier OptionalVisibility\n///   OptionalDLLStorageClass\n///                                                     ...   -> global variable\n///   GlobalID '=' OptionalVisibility (ALIAS | IFUNC) ...\n///   GlobalID '=' OptionalLinkage OptionalPreemptionSpecifier\n///   OptionalVisibility\n///                OptionalDLLStorageClass\n///                                                     ...   -> global variable\nbool LLParser::parseUnnamedGlobal() {\n  unsigned VarID = NumberedVals.size();\n  std::string Name;\n  LocTy NameLoc = Lex.getLoc();\n\n  // Handle the GlobalID form.\n  if (Lex.getKind() == lltok::GlobalID) {\n    if (Lex.getUIntVal() != VarID)\n      return error(Lex.getLoc(),\n                   \"variable expected to be numbered '%\" + Twine(VarID) + \"'\");\n    Lex.Lex(); // eat GlobalID;\n\n    if (parseToken(lltok::equal, \"expected '=' after name\"))\n      return true;\n  }\n\n  bool HasLinkage;\n  unsigned Linkage, Visibility, DLLStorageClass;\n  bool DSOLocal;\n  GlobalVariable::ThreadLocalMode TLM;\n  GlobalVariable::UnnamedAddr UnnamedAddr;\n  if (parseOptionalLinkage(Linkage, HasLinkage, Visibility, DLLStorageClass,\n                           DSOLocal) ||\n      parseOptionalThreadLocal(TLM) || parseOptionalUnnamedAddr(UnnamedAddr))\n    return true;\n\n  if (Lex.getKind() != lltok::kw_alias && Lex.getKind() != lltok::kw_ifunc)\n    return parseGlobal(Name, NameLoc, Linkage, HasLinkage, Visibility,\n                       DLLStorageClass, DSOLocal, TLM, UnnamedAddr);\n\n  return parseIndirectSymbol(Name, NameLoc, Linkage, Visibility,\n                             DLLStorageClass, DSOLocal, TLM, UnnamedAddr);\n}\n\n/// parseNamedGlobal:\n///   GlobalVar '=' OptionalVisibility (ALIAS | IFUNC) ...\n///   GlobalVar '=' OptionalLinkage OptionalPreemptionSpecifier\n///                 OptionalVisibility OptionalDLLStorageClass\n///                                                     ...   -> global variable\nbool LLParser::parseNamedGlobal() {\n  assert(Lex.getKind() == lltok::GlobalVar);\n  LocTy NameLoc = Lex.getLoc();\n  std::string Name = Lex.getStrVal();\n  Lex.Lex();\n\n  bool HasLinkage;\n  unsigned Linkage, Visibility, DLLStorageClass;\n  bool DSOLocal;\n  GlobalVariable::ThreadLocalMode TLM;\n  GlobalVariable::UnnamedAddr UnnamedAddr;\n  if (parseToken(lltok::equal, \"expected '=' in global variable\") ||\n      parseOptionalLinkage(Linkage, HasLinkage, Visibility, DLLStorageClass,\n                           DSOLocal) ||\n      parseOptionalThreadLocal(TLM) || parseOptionalUnnamedAddr(UnnamedAddr))\n    return true;\n\n  if (Lex.getKind() != lltok::kw_alias && Lex.getKind() != lltok::kw_ifunc)\n    return parseGlobal(Name, NameLoc, Linkage, HasLinkage, Visibility,\n                       DLLStorageClass, DSOLocal, TLM, UnnamedAddr);\n\n  return parseIndirectSymbol(Name, NameLoc, Linkage, Visibility,\n                             DLLStorageClass, DSOLocal, TLM, UnnamedAddr);\n}\n\nbool LLParser::parseComdat() {\n  assert(Lex.getKind() == lltok::ComdatVar);\n  std::string Name = Lex.getStrVal();\n  LocTy NameLoc = Lex.getLoc();\n  Lex.Lex();\n\n  if (parseToken(lltok::equal, \"expected '=' here\"))\n    return true;\n\n  if (parseToken(lltok::kw_comdat, \"expected comdat keyword\"))\n    return tokError(\"expected comdat type\");\n\n  Comdat::SelectionKind SK;\n  switch (Lex.getKind()) {\n  default:\n    return tokError(\"unknown selection kind\");\n  case lltok::kw_any:\n    SK = Comdat::Any;\n    break;\n  case lltok::kw_exactmatch:\n    SK = Comdat::ExactMatch;\n    break;\n  case lltok::kw_largest:\n    SK = Comdat::Largest;\n    break;\n  case lltok::kw_noduplicates:\n    SK = Comdat::NoDuplicates;\n    break;\n  case lltok::kw_samesize:\n    SK = Comdat::SameSize;\n    break;\n  }\n  Lex.Lex();\n\n  // See if the comdat was forward referenced, if so, use the comdat.\n  Module::ComdatSymTabType &ComdatSymTab = M->getComdatSymbolTable();\n  Module::ComdatSymTabType::iterator I = ComdatSymTab.find(Name);\n  if (I != ComdatSymTab.end() && !ForwardRefComdats.erase(Name))\n    return error(NameLoc, \"redefinition of comdat '$\" + Name + \"'\");\n\n  Comdat *C;\n  if (I != ComdatSymTab.end())\n    C = &I->second;\n  else\n    C = M->getOrInsertComdat(Name);\n  C->setSelectionKind(SK);\n\n  return false;\n}\n\n// MDString:\n//   ::= '!' STRINGCONSTANT\nbool LLParser::parseMDString(MDString *&Result) {\n  std::string Str;\n  if (parseStringConstant(Str))\n    return true;\n  Result = MDString::get(Context, Str);\n  return false;\n}\n\n// MDNode:\n//   ::= '!' MDNodeNumber\nbool LLParser::parseMDNodeID(MDNode *&Result) {\n  // !{ ..., !42, ... }\n  LocTy IDLoc = Lex.getLoc();\n  unsigned MID = 0;\n  if (parseUInt32(MID))\n    return true;\n\n  // If not a forward reference, just return it now.\n  if (NumberedMetadata.count(MID)) {\n    Result = NumberedMetadata[MID];\n    return false;\n  }\n\n  // Otherwise, create MDNode forward reference.\n  auto &FwdRef = ForwardRefMDNodes[MID];\n  FwdRef = std::make_pair(MDTuple::getTemporary(Context, None), IDLoc);\n\n  Result = FwdRef.first.get();\n  NumberedMetadata[MID].reset(Result);\n  return false;\n}\n\n/// parseNamedMetadata:\n///   !foo = !{ !1, !2 }\nbool LLParser::parseNamedMetadata() {\n  assert(Lex.getKind() == lltok::MetadataVar);\n  std::string Name = Lex.getStrVal();\n  Lex.Lex();\n\n  if (parseToken(lltok::equal, \"expected '=' here\") ||\n      parseToken(lltok::exclaim, \"Expected '!' here\") ||\n      parseToken(lltok::lbrace, \"Expected '{' here\"))\n    return true;\n\n  NamedMDNode *NMD = M->getOrInsertNamedMetadata(Name);\n  if (Lex.getKind() != lltok::rbrace)\n    do {\n      MDNode *N = nullptr;\n      // parse DIExpressions inline as a special case. They are still MDNodes,\n      // so they can still appear in named metadata. Remove this logic if they\n      // become plain Metadata.\n      if (Lex.getKind() == lltok::MetadataVar &&\n          Lex.getStrVal() == \"DIExpression\") {\n        if (parseDIExpression(N, /*IsDistinct=*/false))\n          return true;\n        // DIArgLists should only appear inline in a function, as they may\n        // contain LocalAsMetadata arguments which require a function context.\n      } else if (Lex.getKind() == lltok::MetadataVar &&\n                 Lex.getStrVal() == \"DIArgList\") {\n        return tokError(\"found DIArgList outside of function\");\n      } else if (parseToken(lltok::exclaim, \"Expected '!' here\") ||\n                 parseMDNodeID(N)) {\n        return true;\n      }\n      NMD->addOperand(N);\n    } while (EatIfPresent(lltok::comma));\n\n  return parseToken(lltok::rbrace, \"expected end of metadata node\");\n}\n\n/// parseStandaloneMetadata:\n///   !42 = !{...}\nbool LLParser::parseStandaloneMetadata() {\n  assert(Lex.getKind() == lltok::exclaim);\n  Lex.Lex();\n  unsigned MetadataID = 0;\n\n  MDNode *Init;\n  if (parseUInt32(MetadataID) || parseToken(lltok::equal, \"expected '=' here\"))\n    return true;\n\n  // Detect common error, from old metadata syntax.\n  if (Lex.getKind() == lltok::Type)\n    return tokError(\"unexpected type in metadata definition\");\n\n  bool IsDistinct = EatIfPresent(lltok::kw_distinct);\n  if (Lex.getKind() == lltok::MetadataVar) {\n    if (parseSpecializedMDNode(Init, IsDistinct))\n      return true;\n  } else if (parseToken(lltok::exclaim, \"Expected '!' here\") ||\n             parseMDTuple(Init, IsDistinct))\n    return true;\n\n  // See if this was forward referenced, if so, handle it.\n  auto FI = ForwardRefMDNodes.find(MetadataID);\n  if (FI != ForwardRefMDNodes.end()) {\n    FI->second.first->replaceAllUsesWith(Init);\n    ForwardRefMDNodes.erase(FI);\n\n    assert(NumberedMetadata[MetadataID] == Init && \"Tracking VH didn't work\");\n  } else {\n    if (NumberedMetadata.count(MetadataID))\n      return tokError(\"Metadata id is already used\");\n    NumberedMetadata[MetadataID].reset(Init);\n  }\n\n  return false;\n}\n\n// Skips a single module summary entry.\nbool LLParser::skipModuleSummaryEntry() {\n  // Each module summary entry consists of a tag for the entry\n  // type, followed by a colon, then the fields which may be surrounded by\n  // nested sets of parentheses. The \"tag:\" looks like a Label. Once parsing\n  // support is in place we will look for the tokens corresponding to the\n  // expected tags.\n  if (Lex.getKind() != lltok::kw_gv && Lex.getKind() != lltok::kw_module &&\n      Lex.getKind() != lltok::kw_typeid && Lex.getKind() != lltok::kw_flags &&\n      Lex.getKind() != lltok::kw_blockcount)\n    return tokError(\n        \"Expected 'gv', 'module', 'typeid', 'flags' or 'blockcount' at the \"\n        \"start of summary entry\");\n  if (Lex.getKind() == lltok::kw_flags)\n    return parseSummaryIndexFlags();\n  if (Lex.getKind() == lltok::kw_blockcount)\n    return parseBlockCount();\n  Lex.Lex();\n  if (parseToken(lltok::colon, \"expected ':' at start of summary entry\") ||\n      parseToken(lltok::lparen, \"expected '(' at start of summary entry\"))\n    return true;\n  // Now walk through the parenthesized entry, until the number of open\n  // parentheses goes back down to 0 (the first '(' was parsed above).\n  unsigned NumOpenParen = 1;\n  do {\n    switch (Lex.getKind()) {\n    case lltok::lparen:\n      NumOpenParen++;\n      break;\n    case lltok::rparen:\n      NumOpenParen--;\n      break;\n    case lltok::Eof:\n      return tokError(\"found end of file while parsing summary entry\");\n    default:\n      // Skip everything in between parentheses.\n      break;\n    }\n    Lex.Lex();\n  } while (NumOpenParen > 0);\n  return false;\n}\n\n/// SummaryEntry\n///   ::= SummaryID '=' GVEntry | ModuleEntry | TypeIdEntry\nbool LLParser::parseSummaryEntry() {\n  assert(Lex.getKind() == lltok::SummaryID);\n  unsigned SummaryID = Lex.getUIntVal();\n\n  // For summary entries, colons should be treated as distinct tokens,\n  // not an indication of the end of a label token.\n  Lex.setIgnoreColonInIdentifiers(true);\n\n  Lex.Lex();\n  if (parseToken(lltok::equal, \"expected '=' here\"))\n    return true;\n\n  // If we don't have an index object, skip the summary entry.\n  if (!Index)\n    return skipModuleSummaryEntry();\n\n  bool result = false;\n  switch (Lex.getKind()) {\n  case lltok::kw_gv:\n    result = parseGVEntry(SummaryID);\n    break;\n  case lltok::kw_module:\n    result = parseModuleEntry(SummaryID);\n    break;\n  case lltok::kw_typeid:\n    result = parseTypeIdEntry(SummaryID);\n    break;\n  case lltok::kw_typeidCompatibleVTable:\n    result = parseTypeIdCompatibleVtableEntry(SummaryID);\n    break;\n  case lltok::kw_flags:\n    result = parseSummaryIndexFlags();\n    break;\n  case lltok::kw_blockcount:\n    result = parseBlockCount();\n    break;\n  default:\n    result = error(Lex.getLoc(), \"unexpected summary kind\");\n    break;\n  }\n  Lex.setIgnoreColonInIdentifiers(false);\n  return result;\n}\n\nstatic bool isValidVisibilityForLinkage(unsigned V, unsigned L) {\n  return !GlobalValue::isLocalLinkage((GlobalValue::LinkageTypes)L) ||\n         (GlobalValue::VisibilityTypes)V == GlobalValue::DefaultVisibility;\n}\n\n// If there was an explicit dso_local, update GV. In the absence of an explicit\n// dso_local we keep the default value.\nstatic void maybeSetDSOLocal(bool DSOLocal, GlobalValue &GV) {\n  if (DSOLocal)\n    GV.setDSOLocal(true);\n}\n\n/// parseIndirectSymbol:\n///   ::= GlobalVar '=' OptionalLinkage OptionalPreemptionSpecifier\n///                     OptionalVisibility OptionalDLLStorageClass\n///                     OptionalThreadLocal OptionalUnnamedAddr\n///                     'alias|ifunc' IndirectSymbol IndirectSymbolAttr*\n///\n/// IndirectSymbol\n///   ::= TypeAndValue\n///\n/// IndirectSymbolAttr\n///   ::= ',' 'partition' StringConstant\n///\n/// Everything through OptionalUnnamedAddr has already been parsed.\n///\nbool LLParser::parseIndirectSymbol(const std::string &Name, LocTy NameLoc,\n                                   unsigned L, unsigned Visibility,\n                                   unsigned DLLStorageClass, bool DSOLocal,\n                                   GlobalVariable::ThreadLocalMode TLM,\n                                   GlobalVariable::UnnamedAddr UnnamedAddr) {\n  bool IsAlias;\n  if (Lex.getKind() == lltok::kw_alias)\n    IsAlias = true;\n  else if (Lex.getKind() == lltok::kw_ifunc)\n    IsAlias = false;\n  else\n    llvm_unreachable(\"Not an alias or ifunc!\");\n  Lex.Lex();\n\n  GlobalValue::LinkageTypes Linkage = (GlobalValue::LinkageTypes) L;\n\n  if(IsAlias && !GlobalAlias::isValidLinkage(Linkage))\n    return error(NameLoc, \"invalid linkage type for alias\");\n\n  if (!isValidVisibilityForLinkage(Visibility, L))\n    return error(NameLoc,\n                 \"symbol with local linkage must have default visibility\");\n\n  Type *Ty;\n  LocTy ExplicitTypeLoc = Lex.getLoc();\n  if (parseType(Ty) ||\n      parseToken(lltok::comma, \"expected comma after alias or ifunc's type\"))\n    return true;\n\n  Constant *Aliasee;\n  LocTy AliaseeLoc = Lex.getLoc();\n  if (Lex.getKind() != lltok::kw_bitcast &&\n      Lex.getKind() != lltok::kw_getelementptr &&\n      Lex.getKind() != lltok::kw_addrspacecast &&\n      Lex.getKind() != lltok::kw_inttoptr) {\n    if (parseGlobalTypeAndValue(Aliasee))\n      return true;\n  } else {\n    // The bitcast dest type is not present, it is implied by the dest type.\n    ValID ID;\n    if (parseValID(ID))\n      return true;\n    if (ID.Kind != ValID::t_Constant)\n      return error(AliaseeLoc, \"invalid aliasee\");\n    Aliasee = ID.ConstantVal;\n  }\n\n  Type *AliaseeType = Aliasee->getType();\n  auto *PTy = dyn_cast<PointerType>(AliaseeType);\n  if (!PTy)\n    return error(AliaseeLoc, \"An alias or ifunc must have pointer type\");\n  unsigned AddrSpace = PTy->getAddressSpace();\n\n  if (IsAlias && Ty != PTy->getElementType())\n    return error(ExplicitTypeLoc,\n                 \"explicit pointee type doesn't match operand's pointee type\");\n\n  if (!IsAlias && !PTy->getElementType()->isFunctionTy())\n    return error(ExplicitTypeLoc,\n                 \"explicit pointee type should be a function type\");\n\n  GlobalValue *GVal = nullptr;\n\n  // See if the alias was forward referenced, if so, prepare to replace the\n  // forward reference.\n  if (!Name.empty()) {\n    GVal = M->getNamedValue(Name);\n    if (GVal) {\n      if (!ForwardRefVals.erase(Name))\n        return error(NameLoc, \"redefinition of global '@\" + Name + \"'\");\n    }\n  } else {\n    auto I = ForwardRefValIDs.find(NumberedVals.size());\n    if (I != ForwardRefValIDs.end()) {\n      GVal = I->second.first;\n      ForwardRefValIDs.erase(I);\n    }\n  }\n\n  // Okay, create the alias but do not insert it into the module yet.\n  std::unique_ptr<GlobalIndirectSymbol> GA;\n  if (IsAlias)\n    GA.reset(GlobalAlias::create(Ty, AddrSpace,\n                                 (GlobalValue::LinkageTypes)Linkage, Name,\n                                 Aliasee, /*Parent*/ nullptr));\n  else\n    GA.reset(GlobalIFunc::create(Ty, AddrSpace,\n                                 (GlobalValue::LinkageTypes)Linkage, Name,\n                                 Aliasee, /*Parent*/ nullptr));\n  GA->setThreadLocalMode(TLM);\n  GA->setVisibility((GlobalValue::VisibilityTypes)Visibility);\n  GA->setDLLStorageClass((GlobalValue::DLLStorageClassTypes)DLLStorageClass);\n  GA->setUnnamedAddr(UnnamedAddr);\n  maybeSetDSOLocal(DSOLocal, *GA);\n\n  // At this point we've parsed everything except for the IndirectSymbolAttrs.\n  // Now parse them if there are any.\n  while (Lex.getKind() == lltok::comma) {\n    Lex.Lex();\n\n    if (Lex.getKind() == lltok::kw_partition) {\n      Lex.Lex();\n      GA->setPartition(Lex.getStrVal());\n      if (parseToken(lltok::StringConstant, \"expected partition string\"))\n        return true;\n    } else {\n      return tokError(\"unknown alias or ifunc property!\");\n    }\n  }\n\n  if (Name.empty())\n    NumberedVals.push_back(GA.get());\n\n  if (GVal) {\n    // Verify that types agree.\n    if (GVal->getType() != GA->getType())\n      return error(\n          ExplicitTypeLoc,\n          \"forward reference and definition of alias have different types\");\n\n    // If they agree, just RAUW the old value with the alias and remove the\n    // forward ref info.\n    GVal->replaceAllUsesWith(GA.get());\n    GVal->eraseFromParent();\n  }\n\n  // Insert into the module, we know its name won't collide now.\n  if (IsAlias)\n    M->getAliasList().push_back(cast<GlobalAlias>(GA.get()));\n  else\n    M->getIFuncList().push_back(cast<GlobalIFunc>(GA.get()));\n  assert(GA->getName() == Name && \"Should not be a name conflict!\");\n\n  // The module owns this now\n  GA.release();\n\n  return false;\n}\n\n/// parseGlobal\n///   ::= GlobalVar '=' OptionalLinkage OptionalPreemptionSpecifier\n///       OptionalVisibility OptionalDLLStorageClass\n///       OptionalThreadLocal OptionalUnnamedAddr OptionalAddrSpace\n///       OptionalExternallyInitialized GlobalType Type Const OptionalAttrs\n///   ::= OptionalLinkage OptionalPreemptionSpecifier OptionalVisibility\n///       OptionalDLLStorageClass OptionalThreadLocal OptionalUnnamedAddr\n///       OptionalAddrSpace OptionalExternallyInitialized GlobalType Type\n///       Const OptionalAttrs\n///\n/// Everything up to and including OptionalUnnamedAddr has been parsed\n/// already.\n///\nbool LLParser::parseGlobal(const std::string &Name, LocTy NameLoc,\n                           unsigned Linkage, bool HasLinkage,\n                           unsigned Visibility, unsigned DLLStorageClass,\n                           bool DSOLocal, GlobalVariable::ThreadLocalMode TLM,\n                           GlobalVariable::UnnamedAddr UnnamedAddr) {\n  if (!isValidVisibilityForLinkage(Visibility, Linkage))\n    return error(NameLoc,\n                 \"symbol with local linkage must have default visibility\");\n\n  unsigned AddrSpace;\n  bool IsConstant, IsExternallyInitialized;\n  LocTy IsExternallyInitializedLoc;\n  LocTy TyLoc;\n\n  Type *Ty = nullptr;\n  if (parseOptionalAddrSpace(AddrSpace) ||\n      parseOptionalToken(lltok::kw_externally_initialized,\n                         IsExternallyInitialized,\n                         &IsExternallyInitializedLoc) ||\n      parseGlobalType(IsConstant) || parseType(Ty, TyLoc))\n    return true;\n\n  // If the linkage is specified and is external, then no initializer is\n  // present.\n  Constant *Init = nullptr;\n  if (!HasLinkage ||\n      !GlobalValue::isValidDeclarationLinkage(\n          (GlobalValue::LinkageTypes)Linkage)) {\n    if (parseGlobalValue(Ty, Init))\n      return true;\n  }\n\n  if (Ty->isFunctionTy() || !PointerType::isValidElementType(Ty))\n    return error(TyLoc, \"invalid type for global variable\");\n\n  GlobalValue *GVal = nullptr;\n\n  // See if the global was forward referenced, if so, use the global.\n  if (!Name.empty()) {\n    GVal = M->getNamedValue(Name);\n    if (GVal) {\n      if (!ForwardRefVals.erase(Name))\n        return error(NameLoc, \"redefinition of global '@\" + Name + \"'\");\n    }\n  } else {\n    auto I = ForwardRefValIDs.find(NumberedVals.size());\n    if (I != ForwardRefValIDs.end()) {\n      GVal = I->second.first;\n      ForwardRefValIDs.erase(I);\n    }\n  }\n\n  GlobalVariable *GV;\n  if (!GVal) {\n    GV = new GlobalVariable(*M, Ty, false, GlobalValue::ExternalLinkage, nullptr,\n                            Name, nullptr, GlobalVariable::NotThreadLocal,\n                            AddrSpace);\n  } else {\n    if (GVal->getValueType() != Ty)\n      return error(\n          TyLoc,\n          \"forward reference and definition of global have different types\");\n\n    GV = cast<GlobalVariable>(GVal);\n\n    // Move the forward-reference to the correct spot in the module.\n    M->getGlobalList().splice(M->global_end(), M->getGlobalList(), GV);\n  }\n\n  if (Name.empty())\n    NumberedVals.push_back(GV);\n\n  // Set the parsed properties on the global.\n  if (Init)\n    GV->setInitializer(Init);\n  GV->setConstant(IsConstant);\n  GV->setLinkage((GlobalValue::LinkageTypes)Linkage);\n  maybeSetDSOLocal(DSOLocal, *GV);\n  GV->setVisibility((GlobalValue::VisibilityTypes)Visibility);\n  GV->setDLLStorageClass((GlobalValue::DLLStorageClassTypes)DLLStorageClass);\n  GV->setExternallyInitialized(IsExternallyInitialized);\n  GV->setThreadLocalMode(TLM);\n  GV->setUnnamedAddr(UnnamedAddr);\n\n  // parse attributes on the global.\n  while (Lex.getKind() == lltok::comma) {\n    Lex.Lex();\n\n    if (Lex.getKind() == lltok::kw_section) {\n      Lex.Lex();\n      GV->setSection(Lex.getStrVal());\n      if (parseToken(lltok::StringConstant, \"expected global section string\"))\n        return true;\n    } else if (Lex.getKind() == lltok::kw_partition) {\n      Lex.Lex();\n      GV->setPartition(Lex.getStrVal());\n      if (parseToken(lltok::StringConstant, \"expected partition string\"))\n        return true;\n    } else if (Lex.getKind() == lltok::kw_align) {\n      MaybeAlign Alignment;\n      if (parseOptionalAlignment(Alignment))\n        return true;\n      GV->setAlignment(Alignment);\n    } else if (Lex.getKind() == lltok::MetadataVar) {\n      if (parseGlobalObjectMetadataAttachment(*GV))\n        return true;\n    } else {\n      Comdat *C;\n      if (parseOptionalComdat(Name, C))\n        return true;\n      if (C)\n        GV->setComdat(C);\n      else\n        return tokError(\"unknown global variable property!\");\n    }\n  }\n\n  AttrBuilder Attrs;\n  LocTy BuiltinLoc;\n  std::vector<unsigned> FwdRefAttrGrps;\n  if (parseFnAttributeValuePairs(Attrs, FwdRefAttrGrps, false, BuiltinLoc))\n    return true;\n  if (Attrs.hasAttributes() || !FwdRefAttrGrps.empty()) {\n    GV->setAttributes(AttributeSet::get(Context, Attrs));\n    ForwardRefAttrGroups[GV] = FwdRefAttrGrps;\n  }\n\n  return false;\n}\n\n/// parseUnnamedAttrGrp\n///   ::= 'attributes' AttrGrpID '=' '{' AttrValPair+ '}'\nbool LLParser::parseUnnamedAttrGrp() {\n  assert(Lex.getKind() == lltok::kw_attributes);\n  LocTy AttrGrpLoc = Lex.getLoc();\n  Lex.Lex();\n\n  if (Lex.getKind() != lltok::AttrGrpID)\n    return tokError(\"expected attribute group id\");\n\n  unsigned VarID = Lex.getUIntVal();\n  std::vector<unsigned> unused;\n  LocTy BuiltinLoc;\n  Lex.Lex();\n\n  if (parseToken(lltok::equal, \"expected '=' here\") ||\n      parseToken(lltok::lbrace, \"expected '{' here\") ||\n      parseFnAttributeValuePairs(NumberedAttrBuilders[VarID], unused, true,\n                                 BuiltinLoc) ||\n      parseToken(lltok::rbrace, \"expected end of attribute group\"))\n    return true;\n\n  if (!NumberedAttrBuilders[VarID].hasAttributes())\n    return error(AttrGrpLoc, \"attribute group has no attributes\");\n\n  return false;\n}\n\n/// parseFnAttributeValuePairs\n///   ::= <attr> | <attr> '=' <value>\nbool LLParser::parseFnAttributeValuePairs(AttrBuilder &B,\n                                          std::vector<unsigned> &FwdRefAttrGrps,\n                                          bool inAttrGrp, LocTy &BuiltinLoc) {\n  bool HaveError = false;\n\n  B.clear();\n\n  while (true) {\n    lltok::Kind Token = Lex.getKind();\n    if (Token == lltok::kw_builtin)\n      BuiltinLoc = Lex.getLoc();\n    switch (Token) {\n    default:\n      if (!inAttrGrp) return HaveError;\n      return error(Lex.getLoc(), \"unterminated attribute group\");\n    case lltok::rbrace:\n      // Finished.\n      return false;\n\n    case lltok::AttrGrpID: {\n      // Allow a function to reference an attribute group:\n      //\n      //   define void @foo() #1 { ... }\n      if (inAttrGrp)\n        HaveError |= error(\n            Lex.getLoc(),\n            \"cannot have an attribute group reference in an attribute group\");\n\n      unsigned AttrGrpNum = Lex.getUIntVal();\n      if (inAttrGrp) break;\n\n      // Save the reference to the attribute group. We'll fill it in later.\n      FwdRefAttrGrps.push_back(AttrGrpNum);\n      break;\n    }\n    // Target-dependent attributes:\n    case lltok::StringConstant: {\n      if (parseStringAttribute(B))\n        return true;\n      continue;\n    }\n\n    // Target-independent attributes:\n    case lltok::kw_align: {\n      // As a hack, we allow function alignment to be initially parsed as an\n      // attribute on a function declaration/definition or added to an attribute\n      // group and later moved to the alignment field.\n      MaybeAlign Alignment;\n      if (inAttrGrp) {\n        Lex.Lex();\n        uint32_t Value = 0;\n        if (parseToken(lltok::equal, \"expected '=' here\") || parseUInt32(Value))\n          return true;\n        Alignment = Align(Value);\n      } else {\n        if (parseOptionalAlignment(Alignment))\n          return true;\n      }\n      B.addAlignmentAttr(Alignment);\n      continue;\n    }\n    case lltok::kw_alignstack: {\n      unsigned Alignment;\n      if (inAttrGrp) {\n        Lex.Lex();\n        if (parseToken(lltok::equal, \"expected '=' here\") ||\n            parseUInt32(Alignment))\n          return true;\n      } else {\n        if (parseOptionalStackAlignment(Alignment))\n          return true;\n      }\n      B.addStackAlignmentAttr(Alignment);\n      continue;\n    }\n    case lltok::kw_allocsize: {\n      unsigned ElemSizeArg;\n      Optional<unsigned> NumElemsArg;\n      // inAttrGrp doesn't matter; we only support allocsize(a[, b])\n      if (parseAllocSizeArguments(ElemSizeArg, NumElemsArg))\n        return true;\n      B.addAllocSizeAttr(ElemSizeArg, NumElemsArg);\n      continue;\n    }\n    case lltok::kw_alwaysinline: B.addAttribute(Attribute::AlwaysInline); break;\n    case lltok::kw_argmemonly: B.addAttribute(Attribute::ArgMemOnly); break;\n    case lltok::kw_builtin: B.addAttribute(Attribute::Builtin); break;\n    case lltok::kw_cold: B.addAttribute(Attribute::Cold); break;\n    case lltok::kw_hot: B.addAttribute(Attribute::Hot); break;\n    case lltok::kw_convergent: B.addAttribute(Attribute::Convergent); break;\n    case lltok::kw_inaccessiblememonly:\n      B.addAttribute(Attribute::InaccessibleMemOnly); break;\n    case lltok::kw_inaccessiblemem_or_argmemonly:\n      B.addAttribute(Attribute::InaccessibleMemOrArgMemOnly); break;\n    case lltok::kw_inlinehint: B.addAttribute(Attribute::InlineHint); break;\n    case lltok::kw_jumptable: B.addAttribute(Attribute::JumpTable); break;\n    case lltok::kw_minsize: B.addAttribute(Attribute::MinSize); break;\n    case lltok::kw_mustprogress:\n      B.addAttribute(Attribute::MustProgress);\n      break;\n    case lltok::kw_naked: B.addAttribute(Attribute::Naked); break;\n    case lltok::kw_nobuiltin: B.addAttribute(Attribute::NoBuiltin); break;\n    case lltok::kw_nocallback:\n      B.addAttribute(Attribute::NoCallback);\n      break;\n    case lltok::kw_noduplicate: B.addAttribute(Attribute::NoDuplicate); break;\n    case lltok::kw_nofree: B.addAttribute(Attribute::NoFree); break;\n    case lltok::kw_noimplicitfloat:\n      B.addAttribute(Attribute::NoImplicitFloat); break;\n    case lltok::kw_noinline: B.addAttribute(Attribute::NoInline); break;\n    case lltok::kw_nonlazybind: B.addAttribute(Attribute::NonLazyBind); break;\n    case lltok::kw_nomerge: B.addAttribute(Attribute::NoMerge); break;\n    case lltok::kw_noredzone: B.addAttribute(Attribute::NoRedZone); break;\n    case lltok::kw_noreturn: B.addAttribute(Attribute::NoReturn); break;\n    case lltok::kw_nosync: B.addAttribute(Attribute::NoSync); break;\n    case lltok::kw_nocf_check: B.addAttribute(Attribute::NoCfCheck); break;\n    case lltok::kw_noprofile: B.addAttribute(Attribute::NoProfile); break;\n    case lltok::kw_norecurse: B.addAttribute(Attribute::NoRecurse); break;\n    case lltok::kw_nounwind: B.addAttribute(Attribute::NoUnwind); break;\n    case lltok::kw_null_pointer_is_valid:\n      B.addAttribute(Attribute::NullPointerIsValid); break;\n    case lltok::kw_optforfuzzing:\n      B.addAttribute(Attribute::OptForFuzzing); break;\n    case lltok::kw_optnone: B.addAttribute(Attribute::OptimizeNone); break;\n    case lltok::kw_optsize: B.addAttribute(Attribute::OptimizeForSize); break;\n    case lltok::kw_readnone: B.addAttribute(Attribute::ReadNone); break;\n    case lltok::kw_readonly: B.addAttribute(Attribute::ReadOnly); break;\n    case lltok::kw_returns_twice:\n      B.addAttribute(Attribute::ReturnsTwice); break;\n    case lltok::kw_speculatable: B.addAttribute(Attribute::Speculatable); break;\n    case lltok::kw_ssp: B.addAttribute(Attribute::StackProtect); break;\n    case lltok::kw_sspreq: B.addAttribute(Attribute::StackProtectReq); break;\n    case lltok::kw_sspstrong:\n      B.addAttribute(Attribute::StackProtectStrong); break;\n    case lltok::kw_safestack: B.addAttribute(Attribute::SafeStack); break;\n    case lltok::kw_shadowcallstack:\n      B.addAttribute(Attribute::ShadowCallStack); break;\n    case lltok::kw_sanitize_address:\n      B.addAttribute(Attribute::SanitizeAddress); break;\n    case lltok::kw_sanitize_hwaddress:\n      B.addAttribute(Attribute::SanitizeHWAddress); break;\n    case lltok::kw_sanitize_memtag:\n      B.addAttribute(Attribute::SanitizeMemTag); break;\n    case lltok::kw_sanitize_thread:\n      B.addAttribute(Attribute::SanitizeThread); break;\n    case lltok::kw_sanitize_memory:\n      B.addAttribute(Attribute::SanitizeMemory); break;\n    case lltok::kw_speculative_load_hardening:\n      B.addAttribute(Attribute::SpeculativeLoadHardening);\n      break;\n    case lltok::kw_strictfp: B.addAttribute(Attribute::StrictFP); break;\n    case lltok::kw_uwtable: B.addAttribute(Attribute::UWTable); break;\n    case lltok::kw_willreturn: B.addAttribute(Attribute::WillReturn); break;\n    case lltok::kw_writeonly: B.addAttribute(Attribute::WriteOnly); break;\n    case lltok::kw_preallocated: {\n      Type *Ty;\n      if (parsePreallocated(Ty))\n        return true;\n      B.addPreallocatedAttr(Ty);\n      break;\n    }\n\n    // error handling.\n    case lltok::kw_inreg:\n    case lltok::kw_signext:\n    case lltok::kw_zeroext:\n      HaveError |=\n          error(Lex.getLoc(), \"invalid use of attribute on a function\");\n      break;\n    case lltok::kw_byval:\n    case lltok::kw_dereferenceable:\n    case lltok::kw_dereferenceable_or_null:\n    case lltok::kw_inalloca:\n    case lltok::kw_nest:\n    case lltok::kw_noalias:\n    case lltok::kw_noundef:\n    case lltok::kw_nocapture:\n    case lltok::kw_nonnull:\n    case lltok::kw_returned:\n    case lltok::kw_sret:\n    case lltok::kw_swifterror:\n    case lltok::kw_swiftself:\n    case lltok::kw_immarg:\n    case lltok::kw_byref:\n      HaveError |=\n          error(Lex.getLoc(),\n                \"invalid use of parameter-only attribute on a function\");\n      break;\n    }\n\n    // parsePreallocated() consumes token\n    if (Token != lltok::kw_preallocated)\n      Lex.Lex();\n  }\n}\n\n//===----------------------------------------------------------------------===//\n// GlobalValue Reference/Resolution Routines.\n//===----------------------------------------------------------------------===//\n\nstatic inline GlobalValue *createGlobalFwdRef(Module *M, PointerType *PTy,\n                                              const std::string &Name) {\n  if (auto *FT = dyn_cast<FunctionType>(PTy->getElementType()))\n    return Function::Create(FT, GlobalValue::ExternalWeakLinkage,\n                            PTy->getAddressSpace(), Name, M);\n  else\n    return new GlobalVariable(*M, PTy->getElementType(), false,\n                              GlobalValue::ExternalWeakLinkage, nullptr, Name,\n                              nullptr, GlobalVariable::NotThreadLocal,\n                              PTy->getAddressSpace());\n}\n\nValue *LLParser::checkValidVariableType(LocTy Loc, const Twine &Name, Type *Ty,\n                                        Value *Val, bool IsCall) {\n  if (Val->getType() == Ty)\n    return Val;\n  // For calls we also accept variables in the program address space.\n  Type *SuggestedTy = Ty;\n  if (IsCall && isa<PointerType>(Ty)) {\n    Type *TyInProgAS = cast<PointerType>(Ty)->getElementType()->getPointerTo(\n        M->getDataLayout().getProgramAddressSpace());\n    SuggestedTy = TyInProgAS;\n    if (Val->getType() == TyInProgAS)\n      return Val;\n  }\n  if (Ty->isLabelTy())\n    error(Loc, \"'\" + Name + \"' is not a basic block\");\n  else\n    error(Loc, \"'\" + Name + \"' defined with type '\" +\n                   getTypeString(Val->getType()) + \"' but expected '\" +\n                   getTypeString(SuggestedTy) + \"'\");\n  return nullptr;\n}\n\n/// getGlobalVal - Get a value with the specified name or ID, creating a\n/// forward reference record if needed.  This can return null if the value\n/// exists but does not have the right type.\nGlobalValue *LLParser::getGlobalVal(const std::string &Name, Type *Ty,\n                                    LocTy Loc, bool IsCall) {\n  PointerType *PTy = dyn_cast<PointerType>(Ty);\n  if (!PTy) {\n    error(Loc, \"global variable reference must have pointer type\");\n    return nullptr;\n  }\n\n  // Look this name up in the normal function symbol table.\n  GlobalValue *Val =\n    cast_or_null<GlobalValue>(M->getValueSymbolTable().lookup(Name));\n\n  // If this is a forward reference for the value, see if we already created a\n  // forward ref record.\n  if (!Val) {\n    auto I = ForwardRefVals.find(Name);\n    if (I != ForwardRefVals.end())\n      Val = I->second.first;\n  }\n\n  // If we have the value in the symbol table or fwd-ref table, return it.\n  if (Val)\n    return cast_or_null<GlobalValue>(\n        checkValidVariableType(Loc, \"@\" + Name, Ty, Val, IsCall));\n\n  // Otherwise, create a new forward reference for this value and remember it.\n  GlobalValue *FwdVal = createGlobalFwdRef(M, PTy, Name);\n  ForwardRefVals[Name] = std::make_pair(FwdVal, Loc);\n  return FwdVal;\n}\n\nGlobalValue *LLParser::getGlobalVal(unsigned ID, Type *Ty, LocTy Loc,\n                                    bool IsCall) {\n  PointerType *PTy = dyn_cast<PointerType>(Ty);\n  if (!PTy) {\n    error(Loc, \"global variable reference must have pointer type\");\n    return nullptr;\n  }\n\n  GlobalValue *Val = ID < NumberedVals.size() ? NumberedVals[ID] : nullptr;\n\n  // If this is a forward reference for the value, see if we already created a\n  // forward ref record.\n  if (!Val) {\n    auto I = ForwardRefValIDs.find(ID);\n    if (I != ForwardRefValIDs.end())\n      Val = I->second.first;\n  }\n\n  // If we have the value in the symbol table or fwd-ref table, return it.\n  if (Val)\n    return cast_or_null<GlobalValue>(\n        checkValidVariableType(Loc, \"@\" + Twine(ID), Ty, Val, IsCall));\n\n  // Otherwise, create a new forward reference for this value and remember it.\n  GlobalValue *FwdVal = createGlobalFwdRef(M, PTy, \"\");\n  ForwardRefValIDs[ID] = std::make_pair(FwdVal, Loc);\n  return FwdVal;\n}\n\n//===----------------------------------------------------------------------===//\n// Comdat Reference/Resolution Routines.\n//===----------------------------------------------------------------------===//\n\nComdat *LLParser::getComdat(const std::string &Name, LocTy Loc) {\n  // Look this name up in the comdat symbol table.\n  Module::ComdatSymTabType &ComdatSymTab = M->getComdatSymbolTable();\n  Module::ComdatSymTabType::iterator I = ComdatSymTab.find(Name);\n  if (I != ComdatSymTab.end())\n    return &I->second;\n\n  // Otherwise, create a new forward reference for this value and remember it.\n  Comdat *C = M->getOrInsertComdat(Name);\n  ForwardRefComdats[Name] = Loc;\n  return C;\n}\n\n//===----------------------------------------------------------------------===//\n// Helper Routines.\n//===----------------------------------------------------------------------===//\n\n/// parseToken - If the current token has the specified kind, eat it and return\n/// success.  Otherwise, emit the specified error and return failure.\nbool LLParser::parseToken(lltok::Kind T, const char *ErrMsg) {\n  if (Lex.getKind() != T)\n    return tokError(ErrMsg);\n  Lex.Lex();\n  return false;\n}\n\n/// parseStringConstant\n///   ::= StringConstant\nbool LLParser::parseStringConstant(std::string &Result) {\n  if (Lex.getKind() != lltok::StringConstant)\n    return tokError(\"expected string constant\");\n  Result = Lex.getStrVal();\n  Lex.Lex();\n  return false;\n}\n\n/// parseUInt32\n///   ::= uint32\nbool LLParser::parseUInt32(uint32_t &Val) {\n  if (Lex.getKind() != lltok::APSInt || Lex.getAPSIntVal().isSigned())\n    return tokError(\"expected integer\");\n  uint64_t Val64 = Lex.getAPSIntVal().getLimitedValue(0xFFFFFFFFULL+1);\n  if (Val64 != unsigned(Val64))\n    return tokError(\"expected 32-bit integer (too large)\");\n  Val = Val64;\n  Lex.Lex();\n  return false;\n}\n\n/// parseUInt64\n///   ::= uint64\nbool LLParser::parseUInt64(uint64_t &Val) {\n  if (Lex.getKind() != lltok::APSInt || Lex.getAPSIntVal().isSigned())\n    return tokError(\"expected integer\");\n  Val = Lex.getAPSIntVal().getLimitedValue();\n  Lex.Lex();\n  return false;\n}\n\n/// parseTLSModel\n///   := 'localdynamic'\n///   := 'initialexec'\n///   := 'localexec'\nbool LLParser::parseTLSModel(GlobalVariable::ThreadLocalMode &TLM) {\n  switch (Lex.getKind()) {\n    default:\n      return tokError(\"expected localdynamic, initialexec or localexec\");\n    case lltok::kw_localdynamic:\n      TLM = GlobalVariable::LocalDynamicTLSModel;\n      break;\n    case lltok::kw_initialexec:\n      TLM = GlobalVariable::InitialExecTLSModel;\n      break;\n    case lltok::kw_localexec:\n      TLM = GlobalVariable::LocalExecTLSModel;\n      break;\n  }\n\n  Lex.Lex();\n  return false;\n}\n\n/// parseOptionalThreadLocal\n///   := /*empty*/\n///   := 'thread_local'\n///   := 'thread_local' '(' tlsmodel ')'\nbool LLParser::parseOptionalThreadLocal(GlobalVariable::ThreadLocalMode &TLM) {\n  TLM = GlobalVariable::NotThreadLocal;\n  if (!EatIfPresent(lltok::kw_thread_local))\n    return false;\n\n  TLM = GlobalVariable::GeneralDynamicTLSModel;\n  if (Lex.getKind() == lltok::lparen) {\n    Lex.Lex();\n    return parseTLSModel(TLM) ||\n           parseToken(lltok::rparen, \"expected ')' after thread local model\");\n  }\n  return false;\n}\n\n/// parseOptionalAddrSpace\n///   := /*empty*/\n///   := 'addrspace' '(' uint32 ')'\nbool LLParser::parseOptionalAddrSpace(unsigned &AddrSpace, unsigned DefaultAS) {\n  AddrSpace = DefaultAS;\n  if (!EatIfPresent(lltok::kw_addrspace))\n    return false;\n  return parseToken(lltok::lparen, \"expected '(' in address space\") ||\n         parseUInt32(AddrSpace) ||\n         parseToken(lltok::rparen, \"expected ')' in address space\");\n}\n\n/// parseStringAttribute\n///   := StringConstant\n///   := StringConstant '=' StringConstant\nbool LLParser::parseStringAttribute(AttrBuilder &B) {\n  std::string Attr = Lex.getStrVal();\n  Lex.Lex();\n  std::string Val;\n  if (EatIfPresent(lltok::equal) && parseStringConstant(Val))\n    return true;\n  B.addAttribute(Attr, Val);\n  return false;\n}\n\n/// parseOptionalParamAttrs - parse a potentially empty list of parameter\n/// attributes.\nbool LLParser::parseOptionalParamAttrs(AttrBuilder &B) {\n  bool HaveError = false;\n\n  B.clear();\n\n  while (true) {\n    lltok::Kind Token = Lex.getKind();\n    switch (Token) {\n    default:  // End of attributes.\n      return HaveError;\n    case lltok::StringConstant: {\n      if (parseStringAttribute(B))\n        return true;\n      continue;\n    }\n    case lltok::kw_align: {\n      MaybeAlign Alignment;\n      if (parseOptionalAlignment(Alignment, true))\n        return true;\n      B.addAlignmentAttr(Alignment);\n      continue;\n    }\n    case lltok::kw_byval: {\n      Type *Ty;\n      if (parseRequiredTypeAttr(Ty, lltok::kw_byval))\n        return true;\n      B.addByValAttr(Ty);\n      continue;\n    }\n    case lltok::kw_sret: {\n      Type *Ty;\n      if (parseRequiredTypeAttr(Ty, lltok::kw_sret))\n        return true;\n      B.addStructRetAttr(Ty);\n      continue;\n    }\n    case lltok::kw_preallocated: {\n      Type *Ty;\n      if (parsePreallocated(Ty))\n        return true;\n      B.addPreallocatedAttr(Ty);\n      continue;\n    }\n    case lltok::kw_dereferenceable: {\n      uint64_t Bytes;\n      if (parseOptionalDerefAttrBytes(lltok::kw_dereferenceable, Bytes))\n        return true;\n      B.addDereferenceableAttr(Bytes);\n      continue;\n    }\n    case lltok::kw_dereferenceable_or_null: {\n      uint64_t Bytes;\n      if (parseOptionalDerefAttrBytes(lltok::kw_dereferenceable_or_null, Bytes))\n        return true;\n      B.addDereferenceableOrNullAttr(Bytes);\n      continue;\n    }\n    case lltok::kw_byref: {\n      Type *Ty;\n      if (parseByRef(Ty))\n        return true;\n      B.addByRefAttr(Ty);\n      continue;\n    }\n    case lltok::kw_inalloca:        B.addAttribute(Attribute::InAlloca); break;\n    case lltok::kw_inreg:           B.addAttribute(Attribute::InReg); break;\n    case lltok::kw_nest:            B.addAttribute(Attribute::Nest); break;\n    case lltok::kw_noundef:\n      B.addAttribute(Attribute::NoUndef);\n      break;\n    case lltok::kw_noalias:         B.addAttribute(Attribute::NoAlias); break;\n    case lltok::kw_nocapture:       B.addAttribute(Attribute::NoCapture); break;\n    case lltok::kw_nofree:          B.addAttribute(Attribute::NoFree); break;\n    case lltok::kw_nonnull:         B.addAttribute(Attribute::NonNull); break;\n    case lltok::kw_readnone:        B.addAttribute(Attribute::ReadNone); break;\n    case lltok::kw_readonly:        B.addAttribute(Attribute::ReadOnly); break;\n    case lltok::kw_returned:        B.addAttribute(Attribute::Returned); break;\n    case lltok::kw_signext:         B.addAttribute(Attribute::SExt); break;\n    case lltok::kw_swifterror:      B.addAttribute(Attribute::SwiftError); break;\n    case lltok::kw_swiftself:       B.addAttribute(Attribute::SwiftSelf); break;\n    case lltok::kw_writeonly:       B.addAttribute(Attribute::WriteOnly); break;\n    case lltok::kw_zeroext:         B.addAttribute(Attribute::ZExt); break;\n    case lltok::kw_immarg:          B.addAttribute(Attribute::ImmArg); break;\n\n    case lltok::kw_alignstack:\n    case lltok::kw_alwaysinline:\n    case lltok::kw_argmemonly:\n    case lltok::kw_builtin:\n    case lltok::kw_inlinehint:\n    case lltok::kw_jumptable:\n    case lltok::kw_minsize:\n    case lltok::kw_mustprogress:\n    case lltok::kw_naked:\n    case lltok::kw_nobuiltin:\n    case lltok::kw_noduplicate:\n    case lltok::kw_noimplicitfloat:\n    case lltok::kw_noinline:\n    case lltok::kw_nonlazybind:\n    case lltok::kw_nomerge:\n    case lltok::kw_noprofile:\n    case lltok::kw_noredzone:\n    case lltok::kw_noreturn:\n    case lltok::kw_nocf_check:\n    case lltok::kw_nounwind:\n    case lltok::kw_optforfuzzing:\n    case lltok::kw_optnone:\n    case lltok::kw_optsize:\n    case lltok::kw_returns_twice:\n    case lltok::kw_sanitize_address:\n    case lltok::kw_sanitize_hwaddress:\n    case lltok::kw_sanitize_memtag:\n    case lltok::kw_sanitize_memory:\n    case lltok::kw_sanitize_thread:\n    case lltok::kw_speculative_load_hardening:\n    case lltok::kw_ssp:\n    case lltok::kw_sspreq:\n    case lltok::kw_sspstrong:\n    case lltok::kw_safestack:\n    case lltok::kw_shadowcallstack:\n    case lltok::kw_strictfp:\n    case lltok::kw_uwtable:\n      HaveError |=\n          error(Lex.getLoc(), \"invalid use of function-only attribute\");\n      break;\n    }\n\n    Lex.Lex();\n  }\n}\n\n/// parseOptionalReturnAttrs - parse a potentially empty list of return\n/// attributes.\nbool LLParser::parseOptionalReturnAttrs(AttrBuilder &B) {\n  bool HaveError = false;\n\n  B.clear();\n\n  while (true) {\n    lltok::Kind Token = Lex.getKind();\n    switch (Token) {\n    default:  // End of attributes.\n      return HaveError;\n    case lltok::StringConstant: {\n      if (parseStringAttribute(B))\n        return true;\n      continue;\n    }\n    case lltok::kw_dereferenceable: {\n      uint64_t Bytes;\n      if (parseOptionalDerefAttrBytes(lltok::kw_dereferenceable, Bytes))\n        return true;\n      B.addDereferenceableAttr(Bytes);\n      continue;\n    }\n    case lltok::kw_dereferenceable_or_null: {\n      uint64_t Bytes;\n      if (parseOptionalDerefAttrBytes(lltok::kw_dereferenceable_or_null, Bytes))\n        return true;\n      B.addDereferenceableOrNullAttr(Bytes);\n      continue;\n    }\n    case lltok::kw_align: {\n      MaybeAlign Alignment;\n      if (parseOptionalAlignment(Alignment))\n        return true;\n      B.addAlignmentAttr(Alignment);\n      continue;\n    }\n    case lltok::kw_inreg:           B.addAttribute(Attribute::InReg); break;\n    case lltok::kw_noalias:         B.addAttribute(Attribute::NoAlias); break;\n    case lltok::kw_noundef:\n      B.addAttribute(Attribute::NoUndef);\n      break;\n    case lltok::kw_nonnull:         B.addAttribute(Attribute::NonNull); break;\n    case lltok::kw_signext:         B.addAttribute(Attribute::SExt); break;\n    case lltok::kw_zeroext:         B.addAttribute(Attribute::ZExt); break;\n\n    // error handling.\n    case lltok::kw_byval:\n    case lltok::kw_inalloca:\n    case lltok::kw_nest:\n    case lltok::kw_nocapture:\n    case lltok::kw_returned:\n    case lltok::kw_sret:\n    case lltok::kw_swifterror:\n    case lltok::kw_swiftself:\n    case lltok::kw_immarg:\n    case lltok::kw_byref:\n      HaveError |=\n          error(Lex.getLoc(), \"invalid use of parameter-only attribute\");\n      break;\n\n    case lltok::kw_alignstack:\n    case lltok::kw_alwaysinline:\n    case lltok::kw_argmemonly:\n    case lltok::kw_builtin:\n    case lltok::kw_cold:\n    case lltok::kw_inlinehint:\n    case lltok::kw_jumptable:\n    case lltok::kw_minsize:\n    case lltok::kw_mustprogress:\n    case lltok::kw_naked:\n    case lltok::kw_nobuiltin:\n    case lltok::kw_noduplicate:\n    case lltok::kw_noimplicitfloat:\n    case lltok::kw_noinline:\n    case lltok::kw_nonlazybind:\n    case lltok::kw_nomerge:\n    case lltok::kw_noprofile:\n    case lltok::kw_noredzone:\n    case lltok::kw_noreturn:\n    case lltok::kw_nocf_check:\n    case lltok::kw_nounwind:\n    case lltok::kw_optforfuzzing:\n    case lltok::kw_optnone:\n    case lltok::kw_optsize:\n    case lltok::kw_returns_twice:\n    case lltok::kw_sanitize_address:\n    case lltok::kw_sanitize_hwaddress:\n    case lltok::kw_sanitize_memtag:\n    case lltok::kw_sanitize_memory:\n    case lltok::kw_sanitize_thread:\n    case lltok::kw_speculative_load_hardening:\n    case lltok::kw_ssp:\n    case lltok::kw_sspreq:\n    case lltok::kw_sspstrong:\n    case lltok::kw_safestack:\n    case lltok::kw_shadowcallstack:\n    case lltok::kw_strictfp:\n    case lltok::kw_uwtable:\n      HaveError |=\n          error(Lex.getLoc(), \"invalid use of function-only attribute\");\n      break;\n    case lltok::kw_readnone:\n    case lltok::kw_readonly:\n      HaveError |=\n          error(Lex.getLoc(), \"invalid use of attribute on return type\");\n      break;\n    case lltok::kw_preallocated:\n      HaveError |=\n          error(Lex.getLoc(),\n                \"invalid use of parameter-only/call site-only attribute\");\n      break;\n    }\n\n    Lex.Lex();\n  }\n}\n\nstatic unsigned parseOptionalLinkageAux(lltok::Kind Kind, bool &HasLinkage) {\n  HasLinkage = true;\n  switch (Kind) {\n  default:\n    HasLinkage = false;\n    return GlobalValue::ExternalLinkage;\n  case lltok::kw_private:\n    return GlobalValue::PrivateLinkage;\n  case lltok::kw_internal:\n    return GlobalValue::InternalLinkage;\n  case lltok::kw_weak:\n    return GlobalValue::WeakAnyLinkage;\n  case lltok::kw_weak_odr:\n    return GlobalValue::WeakODRLinkage;\n  case lltok::kw_linkonce:\n    return GlobalValue::LinkOnceAnyLinkage;\n  case lltok::kw_linkonce_odr:\n    return GlobalValue::LinkOnceODRLinkage;\n  case lltok::kw_available_externally:\n    return GlobalValue::AvailableExternallyLinkage;\n  case lltok::kw_appending:\n    return GlobalValue::AppendingLinkage;\n  case lltok::kw_common:\n    return GlobalValue::CommonLinkage;\n  case lltok::kw_extern_weak:\n    return GlobalValue::ExternalWeakLinkage;\n  case lltok::kw_external:\n    return GlobalValue::ExternalLinkage;\n  }\n}\n\n/// parseOptionalLinkage\n///   ::= /*empty*/\n///   ::= 'private'\n///   ::= 'internal'\n///   ::= 'weak'\n///   ::= 'weak_odr'\n///   ::= 'linkonce'\n///   ::= 'linkonce_odr'\n///   ::= 'available_externally'\n///   ::= 'appending'\n///   ::= 'common'\n///   ::= 'extern_weak'\n///   ::= 'external'\nbool LLParser::parseOptionalLinkage(unsigned &Res, bool &HasLinkage,\n                                    unsigned &Visibility,\n                                    unsigned &DLLStorageClass, bool &DSOLocal) {\n  Res = parseOptionalLinkageAux(Lex.getKind(), HasLinkage);\n  if (HasLinkage)\n    Lex.Lex();\n  parseOptionalDSOLocal(DSOLocal);\n  parseOptionalVisibility(Visibility);\n  parseOptionalDLLStorageClass(DLLStorageClass);\n\n  if (DSOLocal && DLLStorageClass == GlobalValue::DLLImportStorageClass) {\n    return error(Lex.getLoc(), \"dso_location and DLL-StorageClass mismatch\");\n  }\n\n  return false;\n}\n\nvoid LLParser::parseOptionalDSOLocal(bool &DSOLocal) {\n  switch (Lex.getKind()) {\n  default:\n    DSOLocal = false;\n    break;\n  case lltok::kw_dso_local:\n    DSOLocal = true;\n    Lex.Lex();\n    break;\n  case lltok::kw_dso_preemptable:\n    DSOLocal = false;\n    Lex.Lex();\n    break;\n  }\n}\n\n/// parseOptionalVisibility\n///   ::= /*empty*/\n///   ::= 'default'\n///   ::= 'hidden'\n///   ::= 'protected'\n///\nvoid LLParser::parseOptionalVisibility(unsigned &Res) {\n  switch (Lex.getKind()) {\n  default:\n    Res = GlobalValue::DefaultVisibility;\n    return;\n  case lltok::kw_default:\n    Res = GlobalValue::DefaultVisibility;\n    break;\n  case lltok::kw_hidden:\n    Res = GlobalValue::HiddenVisibility;\n    break;\n  case lltok::kw_protected:\n    Res = GlobalValue::ProtectedVisibility;\n    break;\n  }\n  Lex.Lex();\n}\n\n/// parseOptionalDLLStorageClass\n///   ::= /*empty*/\n///   ::= 'dllimport'\n///   ::= 'dllexport'\n///\nvoid LLParser::parseOptionalDLLStorageClass(unsigned &Res) {\n  switch (Lex.getKind()) {\n  default:\n    Res = GlobalValue::DefaultStorageClass;\n    return;\n  case lltok::kw_dllimport:\n    Res = GlobalValue::DLLImportStorageClass;\n    break;\n  case lltok::kw_dllexport:\n    Res = GlobalValue::DLLExportStorageClass;\n    break;\n  }\n  Lex.Lex();\n}\n\n/// parseOptionalCallingConv\n///   ::= /*empty*/\n///   ::= 'ccc'\n///   ::= 'fastcc'\n///   ::= 'intel_ocl_bicc'\n///   ::= 'coldcc'\n///   ::= 'cfguard_checkcc'\n///   ::= 'x86_stdcallcc'\n///   ::= 'x86_fastcallcc'\n///   ::= 'x86_thiscallcc'\n///   ::= 'x86_vectorcallcc'\n///   ::= 'arm_apcscc'\n///   ::= 'arm_aapcscc'\n///   ::= 'arm_aapcs_vfpcc'\n///   ::= 'aarch64_vector_pcs'\n///   ::= 'aarch64_sve_vector_pcs'\n///   ::= 'msp430_intrcc'\n///   ::= 'avr_intrcc'\n///   ::= 'avr_signalcc'\n///   ::= 'ptx_kernel'\n///   ::= 'ptx_device'\n///   ::= 'spir_func'\n///   ::= 'spir_kernel'\n///   ::= 'x86_64_sysvcc'\n///   ::= 'win64cc'\n///   ::= 'webkit_jscc'\n///   ::= 'anyregcc'\n///   ::= 'preserve_mostcc'\n///   ::= 'preserve_allcc'\n///   ::= 'ghccc'\n///   ::= 'swiftcc'\n///   ::= 'x86_intrcc'\n///   ::= 'hhvmcc'\n///   ::= 'hhvm_ccc'\n///   ::= 'cxx_fast_tlscc'\n///   ::= 'amdgpu_vs'\n///   ::= 'amdgpu_ls'\n///   ::= 'amdgpu_hs'\n///   ::= 'amdgpu_es'\n///   ::= 'amdgpu_gs'\n///   ::= 'amdgpu_ps'\n///   ::= 'amdgpu_cs'\n///   ::= 'amdgpu_kernel'\n///   ::= 'tailcc'\n///   ::= 'cc' UINT\n///\nbool LLParser::parseOptionalCallingConv(unsigned &CC) {\n  switch (Lex.getKind()) {\n  default:                       CC = CallingConv::C; return false;\n  case lltok::kw_ccc:            CC = CallingConv::C; break;\n  case lltok::kw_fastcc:         CC = CallingConv::Fast; break;\n  case lltok::kw_coldcc:         CC = CallingConv::Cold; break;\n  case lltok::kw_cfguard_checkcc: CC = CallingConv::CFGuard_Check; break;\n  case lltok::kw_x86_stdcallcc:  CC = CallingConv::X86_StdCall; break;\n  case lltok::kw_x86_fastcallcc: CC = CallingConv::X86_FastCall; break;\n  case lltok::kw_x86_regcallcc:  CC = CallingConv::X86_RegCall; break;\n  case lltok::kw_x86_thiscallcc: CC = CallingConv::X86_ThisCall; break;\n  case lltok::kw_x86_vectorcallcc:CC = CallingConv::X86_VectorCall; break;\n  case lltok::kw_arm_apcscc:     CC = CallingConv::ARM_APCS; break;\n  case lltok::kw_arm_aapcscc:    CC = CallingConv::ARM_AAPCS; break;\n  case lltok::kw_arm_aapcs_vfpcc:CC = CallingConv::ARM_AAPCS_VFP; break;\n  case lltok::kw_aarch64_vector_pcs:CC = CallingConv::AArch64_VectorCall; break;\n  case lltok::kw_aarch64_sve_vector_pcs:\n    CC = CallingConv::AArch64_SVE_VectorCall;\n    break;\n  case lltok::kw_msp430_intrcc:  CC = CallingConv::MSP430_INTR; break;\n  case lltok::kw_avr_intrcc:     CC = CallingConv::AVR_INTR; break;\n  case lltok::kw_avr_signalcc:   CC = CallingConv::AVR_SIGNAL; break;\n  case lltok::kw_ptx_kernel:     CC = CallingConv::PTX_Kernel; break;\n  case lltok::kw_ptx_device:     CC = CallingConv::PTX_Device; break;\n  case lltok::kw_spir_kernel:    CC = CallingConv::SPIR_KERNEL; break;\n  case lltok::kw_spir_func:      CC = CallingConv::SPIR_FUNC; break;\n  case lltok::kw_intel_ocl_bicc: CC = CallingConv::Intel_OCL_BI; break;\n  case lltok::kw_x86_64_sysvcc:  CC = CallingConv::X86_64_SysV; break;\n  case lltok::kw_win64cc:        CC = CallingConv::Win64; break;\n  case lltok::kw_webkit_jscc:    CC = CallingConv::WebKit_JS; break;\n  case lltok::kw_anyregcc:       CC = CallingConv::AnyReg; break;\n  case lltok::kw_preserve_mostcc:CC = CallingConv::PreserveMost; break;\n  case lltok::kw_preserve_allcc: CC = CallingConv::PreserveAll; break;\n  case lltok::kw_ghccc:          CC = CallingConv::GHC; break;\n  case lltok::kw_swiftcc:        CC = CallingConv::Swift; break;\n  case lltok::kw_x86_intrcc:     CC = CallingConv::X86_INTR; break;\n  case lltok::kw_hhvmcc:         CC = CallingConv::HHVM; break;\n  case lltok::kw_hhvm_ccc:       CC = CallingConv::HHVM_C; break;\n  case lltok::kw_cxx_fast_tlscc: CC = CallingConv::CXX_FAST_TLS; break;\n  case lltok::kw_amdgpu_vs:      CC = CallingConv::AMDGPU_VS; break;\n  case lltok::kw_amdgpu_gfx:     CC = CallingConv::AMDGPU_Gfx; break;\n  case lltok::kw_amdgpu_ls:      CC = CallingConv::AMDGPU_LS; break;\n  case lltok::kw_amdgpu_hs:      CC = CallingConv::AMDGPU_HS; break;\n  case lltok::kw_amdgpu_es:      CC = CallingConv::AMDGPU_ES; break;\n  case lltok::kw_amdgpu_gs:      CC = CallingConv::AMDGPU_GS; break;\n  case lltok::kw_amdgpu_ps:      CC = CallingConv::AMDGPU_PS; break;\n  case lltok::kw_amdgpu_cs:      CC = CallingConv::AMDGPU_CS; break;\n  case lltok::kw_amdgpu_kernel:  CC = CallingConv::AMDGPU_KERNEL; break;\n  case lltok::kw_tailcc:         CC = CallingConv::Tail; break;\n  case lltok::kw_cc: {\n      Lex.Lex();\n      return parseUInt32(CC);\n    }\n  }\n\n  Lex.Lex();\n  return false;\n}\n\n/// parseMetadataAttachment\n///   ::= !dbg !42\nbool LLParser::parseMetadataAttachment(unsigned &Kind, MDNode *&MD) {\n  assert(Lex.getKind() == lltok::MetadataVar && \"Expected metadata attachment\");\n\n  std::string Name = Lex.getStrVal();\n  Kind = M->getMDKindID(Name);\n  Lex.Lex();\n\n  return parseMDNode(MD);\n}\n\n/// parseInstructionMetadata\n///   ::= !dbg !42 (',' !dbg !57)*\nbool LLParser::parseInstructionMetadata(Instruction &Inst) {\n  do {\n    if (Lex.getKind() != lltok::MetadataVar)\n      return tokError(\"expected metadata after comma\");\n\n    unsigned MDK;\n    MDNode *N;\n    if (parseMetadataAttachment(MDK, N))\n      return true;\n\n    Inst.setMetadata(MDK, N);\n    if (MDK == LLVMContext::MD_tbaa)\n      InstsWithTBAATag.push_back(&Inst);\n\n    // If this is the end of the list, we're done.\n  } while (EatIfPresent(lltok::comma));\n  return false;\n}\n\n/// parseGlobalObjectMetadataAttachment\n///   ::= !dbg !57\nbool LLParser::parseGlobalObjectMetadataAttachment(GlobalObject &GO) {\n  unsigned MDK;\n  MDNode *N;\n  if (parseMetadataAttachment(MDK, N))\n    return true;\n\n  GO.addMetadata(MDK, *N);\n  return false;\n}\n\n/// parseOptionalFunctionMetadata\n///   ::= (!dbg !57)*\nbool LLParser::parseOptionalFunctionMetadata(Function &F) {\n  while (Lex.getKind() == lltok::MetadataVar)\n    if (parseGlobalObjectMetadataAttachment(F))\n      return true;\n  return false;\n}\n\n/// parseOptionalAlignment\n///   ::= /* empty */\n///   ::= 'align' 4\nbool LLParser::parseOptionalAlignment(MaybeAlign &Alignment, bool AllowParens) {\n  Alignment = None;\n  if (!EatIfPresent(lltok::kw_align))\n    return false;\n  LocTy AlignLoc = Lex.getLoc();\n  uint32_t Value = 0;\n\n  LocTy ParenLoc = Lex.getLoc();\n  bool HaveParens = false;\n  if (AllowParens) {\n    if (EatIfPresent(lltok::lparen))\n      HaveParens = true;\n  }\n\n  if (parseUInt32(Value))\n    return true;\n\n  if (HaveParens && !EatIfPresent(lltok::rparen))\n    return error(ParenLoc, \"expected ')'\");\n\n  if (!isPowerOf2_32(Value))\n    return error(AlignLoc, \"alignment is not a power of two\");\n  if (Value > Value::MaximumAlignment)\n    return error(AlignLoc, \"huge alignments are not supported yet\");\n  Alignment = Align(Value);\n  return false;\n}\n\n/// parseOptionalDerefAttrBytes\n///   ::= /* empty */\n///   ::= AttrKind '(' 4 ')'\n///\n/// where AttrKind is either 'dereferenceable' or 'dereferenceable_or_null'.\nbool LLParser::parseOptionalDerefAttrBytes(lltok::Kind AttrKind,\n                                           uint64_t &Bytes) {\n  assert((AttrKind == lltok::kw_dereferenceable ||\n          AttrKind == lltok::kw_dereferenceable_or_null) &&\n         \"contract!\");\n\n  Bytes = 0;\n  if (!EatIfPresent(AttrKind))\n    return false;\n  LocTy ParenLoc = Lex.getLoc();\n  if (!EatIfPresent(lltok::lparen))\n    return error(ParenLoc, \"expected '('\");\n  LocTy DerefLoc = Lex.getLoc();\n  if (parseUInt64(Bytes))\n    return true;\n  ParenLoc = Lex.getLoc();\n  if (!EatIfPresent(lltok::rparen))\n    return error(ParenLoc, \"expected ')'\");\n  if (!Bytes)\n    return error(DerefLoc, \"dereferenceable bytes must be non-zero\");\n  return false;\n}\n\n/// parseOptionalCommaAlign\n///   ::=\n///   ::= ',' align 4\n///\n/// This returns with AteExtraComma set to true if it ate an excess comma at the\n/// end.\nbool LLParser::parseOptionalCommaAlign(MaybeAlign &Alignment,\n                                       bool &AteExtraComma) {\n  AteExtraComma = false;\n  while (EatIfPresent(lltok::comma)) {\n    // Metadata at the end is an early exit.\n    if (Lex.getKind() == lltok::MetadataVar) {\n      AteExtraComma = true;\n      return false;\n    }\n\n    if (Lex.getKind() != lltok::kw_align)\n      return error(Lex.getLoc(), \"expected metadata or 'align'\");\n\n    if (parseOptionalAlignment(Alignment))\n      return true;\n  }\n\n  return false;\n}\n\n/// parseOptionalCommaAddrSpace\n///   ::=\n///   ::= ',' addrspace(1)\n///\n/// This returns with AteExtraComma set to true if it ate an excess comma at the\n/// end.\nbool LLParser::parseOptionalCommaAddrSpace(unsigned &AddrSpace, LocTy &Loc,\n                                           bool &AteExtraComma) {\n  AteExtraComma = false;\n  while (EatIfPresent(lltok::comma)) {\n    // Metadata at the end is an early exit.\n    if (Lex.getKind() == lltok::MetadataVar) {\n      AteExtraComma = true;\n      return false;\n    }\n\n    Loc = Lex.getLoc();\n    if (Lex.getKind() != lltok::kw_addrspace)\n      return error(Lex.getLoc(), \"expected metadata or 'addrspace'\");\n\n    if (parseOptionalAddrSpace(AddrSpace))\n      return true;\n  }\n\n  return false;\n}\n\nbool LLParser::parseAllocSizeArguments(unsigned &BaseSizeArg,\n                                       Optional<unsigned> &HowManyArg) {\n  Lex.Lex();\n\n  auto StartParen = Lex.getLoc();\n  if (!EatIfPresent(lltok::lparen))\n    return error(StartParen, \"expected '('\");\n\n  if (parseUInt32(BaseSizeArg))\n    return true;\n\n  if (EatIfPresent(lltok::comma)) {\n    auto HowManyAt = Lex.getLoc();\n    unsigned HowMany;\n    if (parseUInt32(HowMany))\n      return true;\n    if (HowMany == BaseSizeArg)\n      return error(HowManyAt,\n                   \"'allocsize' indices can't refer to the same parameter\");\n    HowManyArg = HowMany;\n  } else\n    HowManyArg = None;\n\n  auto EndParen = Lex.getLoc();\n  if (!EatIfPresent(lltok::rparen))\n    return error(EndParen, \"expected ')'\");\n  return false;\n}\n\n/// parseScopeAndOrdering\n///   if isAtomic: ::= SyncScope? AtomicOrdering\n///   else: ::=\n///\n/// This sets Scope and Ordering to the parsed values.\nbool LLParser::parseScopeAndOrdering(bool IsAtomic, SyncScope::ID &SSID,\n                                     AtomicOrdering &Ordering) {\n  if (!IsAtomic)\n    return false;\n\n  return parseScope(SSID) || parseOrdering(Ordering);\n}\n\n/// parseScope\n///   ::= syncscope(\"singlethread\" | \"<target scope>\")?\n///\n/// This sets synchronization scope ID to the ID of the parsed value.\nbool LLParser::parseScope(SyncScope::ID &SSID) {\n  SSID = SyncScope::System;\n  if (EatIfPresent(lltok::kw_syncscope)) {\n    auto StartParenAt = Lex.getLoc();\n    if (!EatIfPresent(lltok::lparen))\n      return error(StartParenAt, \"Expected '(' in syncscope\");\n\n    std::string SSN;\n    auto SSNAt = Lex.getLoc();\n    if (parseStringConstant(SSN))\n      return error(SSNAt, \"Expected synchronization scope name\");\n\n    auto EndParenAt = Lex.getLoc();\n    if (!EatIfPresent(lltok::rparen))\n      return error(EndParenAt, \"Expected ')' in syncscope\");\n\n    SSID = Context.getOrInsertSyncScopeID(SSN);\n  }\n\n  return false;\n}\n\n/// parseOrdering\n///   ::= AtomicOrdering\n///\n/// This sets Ordering to the parsed value.\nbool LLParser::parseOrdering(AtomicOrdering &Ordering) {\n  switch (Lex.getKind()) {\n  default:\n    return tokError(\"Expected ordering on atomic instruction\");\n  case lltok::kw_unordered: Ordering = AtomicOrdering::Unordered; break;\n  case lltok::kw_monotonic: Ordering = AtomicOrdering::Monotonic; break;\n  // Not specified yet:\n  // case lltok::kw_consume: Ordering = AtomicOrdering::Consume; break;\n  case lltok::kw_acquire: Ordering = AtomicOrdering::Acquire; break;\n  case lltok::kw_release: Ordering = AtomicOrdering::Release; break;\n  case lltok::kw_acq_rel: Ordering = AtomicOrdering::AcquireRelease; break;\n  case lltok::kw_seq_cst:\n    Ordering = AtomicOrdering::SequentiallyConsistent;\n    break;\n  }\n  Lex.Lex();\n  return false;\n}\n\n/// parseOptionalStackAlignment\n///   ::= /* empty */\n///   ::= 'alignstack' '(' 4 ')'\nbool LLParser::parseOptionalStackAlignment(unsigned &Alignment) {\n  Alignment = 0;\n  if (!EatIfPresent(lltok::kw_alignstack))\n    return false;\n  LocTy ParenLoc = Lex.getLoc();\n  if (!EatIfPresent(lltok::lparen))\n    return error(ParenLoc, \"expected '('\");\n  LocTy AlignLoc = Lex.getLoc();\n  if (parseUInt32(Alignment))\n    return true;\n  ParenLoc = Lex.getLoc();\n  if (!EatIfPresent(lltok::rparen))\n    return error(ParenLoc, \"expected ')'\");\n  if (!isPowerOf2_32(Alignment))\n    return error(AlignLoc, \"stack alignment is not a power of two\");\n  return false;\n}\n\n/// parseIndexList - This parses the index list for an insert/extractvalue\n/// instruction.  This sets AteExtraComma in the case where we eat an extra\n/// comma at the end of the line and find that it is followed by metadata.\n/// Clients that don't allow metadata can call the version of this function that\n/// only takes one argument.\n///\n/// parseIndexList\n///    ::=  (',' uint32)+\n///\nbool LLParser::parseIndexList(SmallVectorImpl<unsigned> &Indices,\n                              bool &AteExtraComma) {\n  AteExtraComma = false;\n\n  if (Lex.getKind() != lltok::comma)\n    return tokError(\"expected ',' as start of index list\");\n\n  while (EatIfPresent(lltok::comma)) {\n    if (Lex.getKind() == lltok::MetadataVar) {\n      if (Indices.empty())\n        return tokError(\"expected index\");\n      AteExtraComma = true;\n      return false;\n    }\n    unsigned Idx = 0;\n    if (parseUInt32(Idx))\n      return true;\n    Indices.push_back(Idx);\n  }\n\n  return false;\n}\n\n//===----------------------------------------------------------------------===//\n// Type Parsing.\n//===----------------------------------------------------------------------===//\n\n/// parseType - parse a type.\nbool LLParser::parseType(Type *&Result, const Twine &Msg, bool AllowVoid) {\n  SMLoc TypeLoc = Lex.getLoc();\n  switch (Lex.getKind()) {\n  default:\n    return tokError(Msg);\n  case lltok::Type:\n    // Type ::= 'float' | 'void' (etc)\n    Result = Lex.getTyVal();\n    Lex.Lex();\n    break;\n  case lltok::lbrace:\n    // Type ::= StructType\n    if (parseAnonStructType(Result, false))\n      return true;\n    break;\n  case lltok::lsquare:\n    // Type ::= '[' ... ']'\n    Lex.Lex(); // eat the lsquare.\n    if (parseArrayVectorType(Result, false))\n      return true;\n    break;\n  case lltok::less: // Either vector or packed struct.\n    // Type ::= '<' ... '>'\n    Lex.Lex();\n    if (Lex.getKind() == lltok::lbrace) {\n      if (parseAnonStructType(Result, true) ||\n          parseToken(lltok::greater, \"expected '>' at end of packed struct\"))\n        return true;\n    } else if (parseArrayVectorType(Result, true))\n      return true;\n    break;\n  case lltok::LocalVar: {\n    // Type ::= %foo\n    std::pair<Type*, LocTy> &Entry = NamedTypes[Lex.getStrVal()];\n\n    // If the type hasn't been defined yet, create a forward definition and\n    // remember where that forward def'n was seen (in case it never is defined).\n    if (!Entry.first) {\n      Entry.first = StructType::create(Context, Lex.getStrVal());\n      Entry.second = Lex.getLoc();\n    }\n    Result = Entry.first;\n    Lex.Lex();\n    break;\n  }\n\n  case lltok::LocalVarID: {\n    // Type ::= %4\n    std::pair<Type*, LocTy> &Entry = NumberedTypes[Lex.getUIntVal()];\n\n    // If the type hasn't been defined yet, create a forward definition and\n    // remember where that forward def'n was seen (in case it never is defined).\n    if (!Entry.first) {\n      Entry.first = StructType::create(Context);\n      Entry.second = Lex.getLoc();\n    }\n    Result = Entry.first;\n    Lex.Lex();\n    break;\n  }\n  }\n\n  // parse the type suffixes.\n  while (true) {\n    switch (Lex.getKind()) {\n    // End of type.\n    default:\n      if (!AllowVoid && Result->isVoidTy())\n        return error(TypeLoc, \"void type only allowed for function results\");\n      return false;\n\n    // Type ::= Type '*'\n    case lltok::star:\n      if (Result->isLabelTy())\n        return tokError(\"basic block pointers are invalid\");\n      if (Result->isVoidTy())\n        return tokError(\"pointers to void are invalid - use i8* instead\");\n      if (!PointerType::isValidElementType(Result))\n        return tokError(\"pointer to this type is invalid\");\n      Result = PointerType::getUnqual(Result);\n      Lex.Lex();\n      break;\n\n    // Type ::= Type 'addrspace' '(' uint32 ')' '*'\n    case lltok::kw_addrspace: {\n      if (Result->isLabelTy())\n        return tokError(\"basic block pointers are invalid\");\n      if (Result->isVoidTy())\n        return tokError(\"pointers to void are invalid; use i8* instead\");\n      if (!PointerType::isValidElementType(Result))\n        return tokError(\"pointer to this type is invalid\");\n      unsigned AddrSpace;\n      if (parseOptionalAddrSpace(AddrSpace) ||\n          parseToken(lltok::star, \"expected '*' in address space\"))\n        return true;\n\n      Result = PointerType::get(Result, AddrSpace);\n      break;\n    }\n\n    /// Types '(' ArgTypeListI ')' OptFuncAttrs\n    case lltok::lparen:\n      if (parseFunctionType(Result))\n        return true;\n      break;\n    }\n  }\n}\n\n/// parseParameterList\n///    ::= '(' ')'\n///    ::= '(' Arg (',' Arg)* ')'\n///  Arg\n///    ::= Type OptionalAttributes Value OptionalAttributes\nbool LLParser::parseParameterList(SmallVectorImpl<ParamInfo> &ArgList,\n                                  PerFunctionState &PFS, bool IsMustTailCall,\n                                  bool InVarArgsFunc) {\n  if (parseToken(lltok::lparen, \"expected '(' in call\"))\n    return true;\n\n  while (Lex.getKind() != lltok::rparen) {\n    // If this isn't the first argument, we need a comma.\n    if (!ArgList.empty() &&\n        parseToken(lltok::comma, \"expected ',' in argument list\"))\n      return true;\n\n    // parse an ellipsis if this is a musttail call in a variadic function.\n    if (Lex.getKind() == lltok::dotdotdot) {\n      const char *Msg = \"unexpected ellipsis in argument list for \";\n      if (!IsMustTailCall)\n        return tokError(Twine(Msg) + \"non-musttail call\");\n      if (!InVarArgsFunc)\n        return tokError(Twine(Msg) + \"musttail call in non-varargs function\");\n      Lex.Lex();  // Lex the '...', it is purely for readability.\n      return parseToken(lltok::rparen, \"expected ')' at end of argument list\");\n    }\n\n    // parse the argument.\n    LocTy ArgLoc;\n    Type *ArgTy = nullptr;\n    AttrBuilder ArgAttrs;\n    Value *V;\n    if (parseType(ArgTy, ArgLoc))\n      return true;\n\n    if (ArgTy->isMetadataTy()) {\n      if (parseMetadataAsValue(V, PFS))\n        return true;\n    } else {\n      // Otherwise, handle normal operands.\n      if (parseOptionalParamAttrs(ArgAttrs) || parseValue(ArgTy, V, PFS))\n        return true;\n    }\n    ArgList.push_back(ParamInfo(\n        ArgLoc, V, AttributeSet::get(V->getContext(), ArgAttrs)));\n  }\n\n  if (IsMustTailCall && InVarArgsFunc)\n    return tokError(\"expected '...' at end of argument list for musttail call \"\n                    \"in varargs function\");\n\n  Lex.Lex();  // Lex the ')'.\n  return false;\n}\n\n/// parseRequiredTypeAttr\n///   ::= attrname(<ty>)\nbool LLParser::parseRequiredTypeAttr(Type *&Result, lltok::Kind AttrName) {\n  Result = nullptr;\n  if (!EatIfPresent(AttrName))\n    return true;\n  if (!EatIfPresent(lltok::lparen))\n    return error(Lex.getLoc(), \"expected '('\");\n  if (parseType(Result))\n    return true;\n  if (!EatIfPresent(lltok::rparen))\n    return error(Lex.getLoc(), \"expected ')'\");\n  return false;\n}\n\n/// parsePreallocated\n///   ::= preallocated(<ty>)\nbool LLParser::parsePreallocated(Type *&Result) {\n  return parseRequiredTypeAttr(Result, lltok::kw_preallocated);\n}\n\n/// parseByRef\n///   ::= byref(<type>)\nbool LLParser::parseByRef(Type *&Result) {\n  return parseRequiredTypeAttr(Result, lltok::kw_byref);\n}\n\n/// parseOptionalOperandBundles\n///    ::= /*empty*/\n///    ::= '[' OperandBundle [, OperandBundle ]* ']'\n///\n/// OperandBundle\n///    ::= bundle-tag '(' ')'\n///    ::= bundle-tag '(' Type Value [, Type Value ]* ')'\n///\n/// bundle-tag ::= String Constant\nbool LLParser::parseOptionalOperandBundles(\n    SmallVectorImpl<OperandBundleDef> &BundleList, PerFunctionState &PFS) {\n  LocTy BeginLoc = Lex.getLoc();\n  if (!EatIfPresent(lltok::lsquare))\n    return false;\n\n  while (Lex.getKind() != lltok::rsquare) {\n    // If this isn't the first operand bundle, we need a comma.\n    if (!BundleList.empty() &&\n        parseToken(lltok::comma, \"expected ',' in input list\"))\n      return true;\n\n    std::string Tag;\n    if (parseStringConstant(Tag))\n      return true;\n\n    if (parseToken(lltok::lparen, \"expected '(' in operand bundle\"))\n      return true;\n\n    std::vector<Value *> Inputs;\n    while (Lex.getKind() != lltok::rparen) {\n      // If this isn't the first input, we need a comma.\n      if (!Inputs.empty() &&\n          parseToken(lltok::comma, \"expected ',' in input list\"))\n        return true;\n\n      Type *Ty = nullptr;\n      Value *Input = nullptr;\n      if (parseType(Ty) || parseValue(Ty, Input, PFS))\n        return true;\n      Inputs.push_back(Input);\n    }\n\n    BundleList.emplace_back(std::move(Tag), std::move(Inputs));\n\n    Lex.Lex(); // Lex the ')'.\n  }\n\n  if (BundleList.empty())\n    return error(BeginLoc, \"operand bundle set must not be empty\");\n\n  Lex.Lex(); // Lex the ']'.\n  return false;\n}\n\n/// parseArgumentList - parse the argument list for a function type or function\n/// prototype.\n///   ::= '(' ArgTypeListI ')'\n/// ArgTypeListI\n///   ::= /*empty*/\n///   ::= '...'\n///   ::= ArgTypeList ',' '...'\n///   ::= ArgType (',' ArgType)*\n///\nbool LLParser::parseArgumentList(SmallVectorImpl<ArgInfo> &ArgList,\n                                 bool &IsVarArg) {\n  unsigned CurValID = 0;\n  IsVarArg = false;\n  assert(Lex.getKind() == lltok::lparen);\n  Lex.Lex(); // eat the (.\n\n  if (Lex.getKind() == lltok::rparen) {\n    // empty\n  } else if (Lex.getKind() == lltok::dotdotdot) {\n    IsVarArg = true;\n    Lex.Lex();\n  } else {\n    LocTy TypeLoc = Lex.getLoc();\n    Type *ArgTy = nullptr;\n    AttrBuilder Attrs;\n    std::string Name;\n\n    if (parseType(ArgTy) || parseOptionalParamAttrs(Attrs))\n      return true;\n\n    if (ArgTy->isVoidTy())\n      return error(TypeLoc, \"argument can not have void type\");\n\n    if (Lex.getKind() == lltok::LocalVar) {\n      Name = Lex.getStrVal();\n      Lex.Lex();\n    } else if (Lex.getKind() == lltok::LocalVarID) {\n      if (Lex.getUIntVal() != CurValID)\n        return error(TypeLoc, \"argument expected to be numbered '%\" +\n                                  Twine(CurValID) + \"'\");\n      ++CurValID;\n      Lex.Lex();\n    }\n\n    if (!FunctionType::isValidArgumentType(ArgTy))\n      return error(TypeLoc, \"invalid type for function argument\");\n\n    ArgList.emplace_back(TypeLoc, ArgTy,\n                         AttributeSet::get(ArgTy->getContext(), Attrs),\n                         std::move(Name));\n\n    while (EatIfPresent(lltok::comma)) {\n      // Handle ... at end of arg list.\n      if (EatIfPresent(lltok::dotdotdot)) {\n        IsVarArg = true;\n        break;\n      }\n\n      // Otherwise must be an argument type.\n      TypeLoc = Lex.getLoc();\n      if (parseType(ArgTy) || parseOptionalParamAttrs(Attrs))\n        return true;\n\n      if (ArgTy->isVoidTy())\n        return error(TypeLoc, \"argument can not have void type\");\n\n      if (Lex.getKind() == lltok::LocalVar) {\n        Name = Lex.getStrVal();\n        Lex.Lex();\n      } else {\n        if (Lex.getKind() == lltok::LocalVarID) {\n          if (Lex.getUIntVal() != CurValID)\n            return error(TypeLoc, \"argument expected to be numbered '%\" +\n                                      Twine(CurValID) + \"'\");\n          Lex.Lex();\n        }\n        ++CurValID;\n        Name = \"\";\n      }\n\n      if (!ArgTy->isFirstClassType())\n        return error(TypeLoc, \"invalid type for function argument\");\n\n      ArgList.emplace_back(TypeLoc, ArgTy,\n                           AttributeSet::get(ArgTy->getContext(), Attrs),\n                           std::move(Name));\n    }\n  }\n\n  return parseToken(lltok::rparen, \"expected ')' at end of argument list\");\n}\n\n/// parseFunctionType\n///  ::= Type ArgumentList OptionalAttrs\nbool LLParser::parseFunctionType(Type *&Result) {\n  assert(Lex.getKind() == lltok::lparen);\n\n  if (!FunctionType::isValidReturnType(Result))\n    return tokError(\"invalid function return type\");\n\n  SmallVector<ArgInfo, 8> ArgList;\n  bool IsVarArg;\n  if (parseArgumentList(ArgList, IsVarArg))\n    return true;\n\n  // Reject names on the arguments lists.\n  for (unsigned i = 0, e = ArgList.size(); i != e; ++i) {\n    if (!ArgList[i].Name.empty())\n      return error(ArgList[i].Loc, \"argument name invalid in function type\");\n    if (ArgList[i].Attrs.hasAttributes())\n      return error(ArgList[i].Loc,\n                   \"argument attributes invalid in function type\");\n  }\n\n  SmallVector<Type*, 16> ArgListTy;\n  for (unsigned i = 0, e = ArgList.size(); i != e; ++i)\n    ArgListTy.push_back(ArgList[i].Ty);\n\n  Result = FunctionType::get(Result, ArgListTy, IsVarArg);\n  return false;\n}\n\n/// parseAnonStructType - parse an anonymous struct type, which is inlined into\n/// other structs.\nbool LLParser::parseAnonStructType(Type *&Result, bool Packed) {\n  SmallVector<Type*, 8> Elts;\n  if (parseStructBody(Elts))\n    return true;\n\n  Result = StructType::get(Context, Elts, Packed);\n  return false;\n}\n\n/// parseStructDefinition - parse a struct in a 'type' definition.\nbool LLParser::parseStructDefinition(SMLoc TypeLoc, StringRef Name,\n                                     std::pair<Type *, LocTy> &Entry,\n                                     Type *&ResultTy) {\n  // If the type was already defined, diagnose the redefinition.\n  if (Entry.first && !Entry.second.isValid())\n    return error(TypeLoc, \"redefinition of type\");\n\n  // If we have opaque, just return without filling in the definition for the\n  // struct.  This counts as a definition as far as the .ll file goes.\n  if (EatIfPresent(lltok::kw_opaque)) {\n    // This type is being defined, so clear the location to indicate this.\n    Entry.second = SMLoc();\n\n    // If this type number has never been uttered, create it.\n    if (!Entry.first)\n      Entry.first = StructType::create(Context, Name);\n    ResultTy = Entry.first;\n    return false;\n  }\n\n  // If the type starts with '<', then it is either a packed struct or a vector.\n  bool isPacked = EatIfPresent(lltok::less);\n\n  // If we don't have a struct, then we have a random type alias, which we\n  // accept for compatibility with old files.  These types are not allowed to be\n  // forward referenced and not allowed to be recursive.\n  if (Lex.getKind() != lltok::lbrace) {\n    if (Entry.first)\n      return error(TypeLoc, \"forward references to non-struct type\");\n\n    ResultTy = nullptr;\n    if (isPacked)\n      return parseArrayVectorType(ResultTy, true);\n    return parseType(ResultTy);\n  }\n\n  // This type is being defined, so clear the location to indicate this.\n  Entry.second = SMLoc();\n\n  // If this type number has never been uttered, create it.\n  if (!Entry.first)\n    Entry.first = StructType::create(Context, Name);\n\n  StructType *STy = cast<StructType>(Entry.first);\n\n  SmallVector<Type*, 8> Body;\n  if (parseStructBody(Body) ||\n      (isPacked && parseToken(lltok::greater, \"expected '>' in packed struct\")))\n    return true;\n\n  STy->setBody(Body, isPacked);\n  ResultTy = STy;\n  return false;\n}\n\n/// parseStructType: Handles packed and unpacked types.  </> parsed elsewhere.\n///   StructType\n///     ::= '{' '}'\n///     ::= '{' Type (',' Type)* '}'\n///     ::= '<' '{' '}' '>'\n///     ::= '<' '{' Type (',' Type)* '}' '>'\nbool LLParser::parseStructBody(SmallVectorImpl<Type *> &Body) {\n  assert(Lex.getKind() == lltok::lbrace);\n  Lex.Lex(); // Consume the '{'\n\n  // Handle the empty struct.\n  if (EatIfPresent(lltok::rbrace))\n    return false;\n\n  LocTy EltTyLoc = Lex.getLoc();\n  Type *Ty = nullptr;\n  if (parseType(Ty))\n    return true;\n  Body.push_back(Ty);\n\n  if (!StructType::isValidElementType(Ty))\n    return error(EltTyLoc, \"invalid element type for struct\");\n\n  while (EatIfPresent(lltok::comma)) {\n    EltTyLoc = Lex.getLoc();\n    if (parseType(Ty))\n      return true;\n\n    if (!StructType::isValidElementType(Ty))\n      return error(EltTyLoc, \"invalid element type for struct\");\n\n    Body.push_back(Ty);\n  }\n\n  return parseToken(lltok::rbrace, \"expected '}' at end of struct\");\n}\n\n/// parseArrayVectorType - parse an array or vector type, assuming the first\n/// token has already been consumed.\n///   Type\n///     ::= '[' APSINTVAL 'x' Types ']'\n///     ::= '<' APSINTVAL 'x' Types '>'\n///     ::= '<' 'vscale' 'x' APSINTVAL 'x' Types '>'\nbool LLParser::parseArrayVectorType(Type *&Result, bool IsVector) {\n  bool Scalable = false;\n\n  if (IsVector && Lex.getKind() == lltok::kw_vscale) {\n    Lex.Lex(); // consume the 'vscale'\n    if (parseToken(lltok::kw_x, \"expected 'x' after vscale\"))\n      return true;\n\n    Scalable = true;\n  }\n\n  if (Lex.getKind() != lltok::APSInt || Lex.getAPSIntVal().isSigned() ||\n      Lex.getAPSIntVal().getBitWidth() > 64)\n    return tokError(\"expected number in address space\");\n\n  LocTy SizeLoc = Lex.getLoc();\n  uint64_t Size = Lex.getAPSIntVal().getZExtValue();\n  Lex.Lex();\n\n  if (parseToken(lltok::kw_x, \"expected 'x' after element count\"))\n    return true;\n\n  LocTy TypeLoc = Lex.getLoc();\n  Type *EltTy = nullptr;\n  if (parseType(EltTy))\n    return true;\n\n  if (parseToken(IsVector ? lltok::greater : lltok::rsquare,\n                 \"expected end of sequential type\"))\n    return true;\n\n  if (IsVector) {\n    if (Size == 0)\n      return error(SizeLoc, \"zero element vector is illegal\");\n    if ((unsigned)Size != Size)\n      return error(SizeLoc, \"size too large for vector\");\n    if (!VectorType::isValidElementType(EltTy))\n      return error(TypeLoc, \"invalid vector element type\");\n    Result = VectorType::get(EltTy, unsigned(Size), Scalable);\n  } else {\n    if (!ArrayType::isValidElementType(EltTy))\n      return error(TypeLoc, \"invalid array element type\");\n    Result = ArrayType::get(EltTy, Size);\n  }\n  return false;\n}\n\n//===----------------------------------------------------------------------===//\n// Function Semantic Analysis.\n//===----------------------------------------------------------------------===//\n\nLLParser::PerFunctionState::PerFunctionState(LLParser &p, Function &f,\n                                             int functionNumber)\n  : P(p), F(f), FunctionNumber(functionNumber) {\n\n  // Insert unnamed arguments into the NumberedVals list.\n  for (Argument &A : F.args())\n    if (!A.hasName())\n      NumberedVals.push_back(&A);\n}\n\nLLParser::PerFunctionState::~PerFunctionState() {\n  // If there were any forward referenced non-basicblock values, delete them.\n\n  for (const auto &P : ForwardRefVals) {\n    if (isa<BasicBlock>(P.second.first))\n      continue;\n    P.second.first->replaceAllUsesWith(\n        UndefValue::get(P.second.first->getType()));\n    P.second.first->deleteValue();\n  }\n\n  for (const auto &P : ForwardRefValIDs) {\n    if (isa<BasicBlock>(P.second.first))\n      continue;\n    P.second.first->replaceAllUsesWith(\n        UndefValue::get(P.second.first->getType()));\n    P.second.first->deleteValue();\n  }\n}\n\nbool LLParser::PerFunctionState::finishFunction() {\n  if (!ForwardRefVals.empty())\n    return P.error(ForwardRefVals.begin()->second.second,\n                   \"use of undefined value '%\" + ForwardRefVals.begin()->first +\n                       \"'\");\n  if (!ForwardRefValIDs.empty())\n    return P.error(ForwardRefValIDs.begin()->second.second,\n                   \"use of undefined value '%\" +\n                       Twine(ForwardRefValIDs.begin()->first) + \"'\");\n  return false;\n}\n\n/// getVal - Get a value with the specified name or ID, creating a\n/// forward reference record if needed.  This can return null if the value\n/// exists but does not have the right type.\nValue *LLParser::PerFunctionState::getVal(const std::string &Name, Type *Ty,\n                                          LocTy Loc, bool IsCall) {\n  // Look this name up in the normal function symbol table.\n  Value *Val = F.getValueSymbolTable()->lookup(Name);\n\n  // If this is a forward reference for the value, see if we already created a\n  // forward ref record.\n  if (!Val) {\n    auto I = ForwardRefVals.find(Name);\n    if (I != ForwardRefVals.end())\n      Val = I->second.first;\n  }\n\n  // If we have the value in the symbol table or fwd-ref table, return it.\n  if (Val)\n    return P.checkValidVariableType(Loc, \"%\" + Name, Ty, Val, IsCall);\n\n  // Don't make placeholders with invalid type.\n  if (!Ty->isFirstClassType()) {\n    P.error(Loc, \"invalid use of a non-first-class type\");\n    return nullptr;\n  }\n\n  // Otherwise, create a new forward reference for this value and remember it.\n  Value *FwdVal;\n  if (Ty->isLabelTy()) {\n    FwdVal = BasicBlock::Create(F.getContext(), Name, &F);\n  } else {\n    FwdVal = new Argument(Ty, Name);\n  }\n\n  ForwardRefVals[Name] = std::make_pair(FwdVal, Loc);\n  return FwdVal;\n}\n\nValue *LLParser::PerFunctionState::getVal(unsigned ID, Type *Ty, LocTy Loc,\n                                          bool IsCall) {\n  // Look this name up in the normal function symbol table.\n  Value *Val = ID < NumberedVals.size() ? NumberedVals[ID] : nullptr;\n\n  // If this is a forward reference for the value, see if we already created a\n  // forward ref record.\n  if (!Val) {\n    auto I = ForwardRefValIDs.find(ID);\n    if (I != ForwardRefValIDs.end())\n      Val = I->second.first;\n  }\n\n  // If we have the value in the symbol table or fwd-ref table, return it.\n  if (Val)\n    return P.checkValidVariableType(Loc, \"%\" + Twine(ID), Ty, Val, IsCall);\n\n  if (!Ty->isFirstClassType()) {\n    P.error(Loc, \"invalid use of a non-first-class type\");\n    return nullptr;\n  }\n\n  // Otherwise, create a new forward reference for this value and remember it.\n  Value *FwdVal;\n  if (Ty->isLabelTy()) {\n    FwdVal = BasicBlock::Create(F.getContext(), \"\", &F);\n  } else {\n    FwdVal = new Argument(Ty);\n  }\n\n  ForwardRefValIDs[ID] = std::make_pair(FwdVal, Loc);\n  return FwdVal;\n}\n\n/// setInstName - After an instruction is parsed and inserted into its\n/// basic block, this installs its name.\nbool LLParser::PerFunctionState::setInstName(int NameID,\n                                             const std::string &NameStr,\n                                             LocTy NameLoc, Instruction *Inst) {\n  // If this instruction has void type, it cannot have a name or ID specified.\n  if (Inst->getType()->isVoidTy()) {\n    if (NameID != -1 || !NameStr.empty())\n      return P.error(NameLoc, \"instructions returning void cannot have a name\");\n    return false;\n  }\n\n  // If this was a numbered instruction, verify that the instruction is the\n  // expected value and resolve any forward references.\n  if (NameStr.empty()) {\n    // If neither a name nor an ID was specified, just use the next ID.\n    if (NameID == -1)\n      NameID = NumberedVals.size();\n\n    if (unsigned(NameID) != NumberedVals.size())\n      return P.error(NameLoc, \"instruction expected to be numbered '%\" +\n                                  Twine(NumberedVals.size()) + \"'\");\n\n    auto FI = ForwardRefValIDs.find(NameID);\n    if (FI != ForwardRefValIDs.end()) {\n      Value *Sentinel = FI->second.first;\n      if (Sentinel->getType() != Inst->getType())\n        return P.error(NameLoc, \"instruction forward referenced with type '\" +\n                                    getTypeString(FI->second.first->getType()) +\n                                    \"'\");\n\n      Sentinel->replaceAllUsesWith(Inst);\n      Sentinel->deleteValue();\n      ForwardRefValIDs.erase(FI);\n    }\n\n    NumberedVals.push_back(Inst);\n    return false;\n  }\n\n  // Otherwise, the instruction had a name.  Resolve forward refs and set it.\n  auto FI = ForwardRefVals.find(NameStr);\n  if (FI != ForwardRefVals.end()) {\n    Value *Sentinel = FI->second.first;\n    if (Sentinel->getType() != Inst->getType())\n      return P.error(NameLoc, \"instruction forward referenced with type '\" +\n                                  getTypeString(FI->second.first->getType()) +\n                                  \"'\");\n\n    Sentinel->replaceAllUsesWith(Inst);\n    Sentinel->deleteValue();\n    ForwardRefVals.erase(FI);\n  }\n\n  // Set the name on the instruction.\n  Inst->setName(NameStr);\n\n  if (Inst->getName() != NameStr)\n    return P.error(NameLoc, \"multiple definition of local value named '\" +\n                                NameStr + \"'\");\n  return false;\n}\n\n/// getBB - Get a basic block with the specified name or ID, creating a\n/// forward reference record if needed.\nBasicBlock *LLParser::PerFunctionState::getBB(const std::string &Name,\n                                              LocTy Loc) {\n  return dyn_cast_or_null<BasicBlock>(\n      getVal(Name, Type::getLabelTy(F.getContext()), Loc, /*IsCall=*/false));\n}\n\nBasicBlock *LLParser::PerFunctionState::getBB(unsigned ID, LocTy Loc) {\n  return dyn_cast_or_null<BasicBlock>(\n      getVal(ID, Type::getLabelTy(F.getContext()), Loc, /*IsCall=*/false));\n}\n\n/// defineBB - Define the specified basic block, which is either named or\n/// unnamed.  If there is an error, this returns null otherwise it returns\n/// the block being defined.\nBasicBlock *LLParser::PerFunctionState::defineBB(const std::string &Name,\n                                                 int NameID, LocTy Loc) {\n  BasicBlock *BB;\n  if (Name.empty()) {\n    if (NameID != -1 && unsigned(NameID) != NumberedVals.size()) {\n      P.error(Loc, \"label expected to be numbered '\" +\n                       Twine(NumberedVals.size()) + \"'\");\n      return nullptr;\n    }\n    BB = getBB(NumberedVals.size(), Loc);\n    if (!BB) {\n      P.error(Loc, \"unable to create block numbered '\" +\n                       Twine(NumberedVals.size()) + \"'\");\n      return nullptr;\n    }\n  } else {\n    BB = getBB(Name, Loc);\n    if (!BB) {\n      P.error(Loc, \"unable to create block named '\" + Name + \"'\");\n      return nullptr;\n    }\n  }\n\n  // Move the block to the end of the function.  Forward ref'd blocks are\n  // inserted wherever they happen to be referenced.\n  F.getBasicBlockList().splice(F.end(), F.getBasicBlockList(), BB);\n\n  // Remove the block from forward ref sets.\n  if (Name.empty()) {\n    ForwardRefValIDs.erase(NumberedVals.size());\n    NumberedVals.push_back(BB);\n  } else {\n    // BB forward references are already in the function symbol table.\n    ForwardRefVals.erase(Name);\n  }\n\n  return BB;\n}\n\n//===----------------------------------------------------------------------===//\n// Constants.\n//===----------------------------------------------------------------------===//\n\n/// parseValID - parse an abstract value that doesn't necessarily have a\n/// type implied.  For example, if we parse \"4\" we don't know what integer type\n/// it has.  The value will later be combined with its type and checked for\n/// sanity.  PFS is used to convert function-local operands of metadata (since\n/// metadata operands are not just parsed here but also converted to values).\n/// PFS can be null when we are not parsing metadata values inside a function.\nbool LLParser::parseValID(ValID &ID, PerFunctionState *PFS) {\n  ID.Loc = Lex.getLoc();\n  switch (Lex.getKind()) {\n  default:\n    return tokError(\"expected value token\");\n  case lltok::GlobalID:  // @42\n    ID.UIntVal = Lex.getUIntVal();\n    ID.Kind = ValID::t_GlobalID;\n    break;\n  case lltok::GlobalVar:  // @foo\n    ID.StrVal = Lex.getStrVal();\n    ID.Kind = ValID::t_GlobalName;\n    break;\n  case lltok::LocalVarID:  // %42\n    ID.UIntVal = Lex.getUIntVal();\n    ID.Kind = ValID::t_LocalID;\n    break;\n  case lltok::LocalVar:  // %foo\n    ID.StrVal = Lex.getStrVal();\n    ID.Kind = ValID::t_LocalName;\n    break;\n  case lltok::APSInt:\n    ID.APSIntVal = Lex.getAPSIntVal();\n    ID.Kind = ValID::t_APSInt;\n    break;\n  case lltok::APFloat:\n    ID.APFloatVal = Lex.getAPFloatVal();\n    ID.Kind = ValID::t_APFloat;\n    break;\n  case lltok::kw_true:\n    ID.ConstantVal = ConstantInt::getTrue(Context);\n    ID.Kind = ValID::t_Constant;\n    break;\n  case lltok::kw_false:\n    ID.ConstantVal = ConstantInt::getFalse(Context);\n    ID.Kind = ValID::t_Constant;\n    break;\n  case lltok::kw_null: ID.Kind = ValID::t_Null; break;\n  case lltok::kw_undef: ID.Kind = ValID::t_Undef; break;\n  case lltok::kw_poison: ID.Kind = ValID::t_Poison; break;\n  case lltok::kw_zeroinitializer: ID.Kind = ValID::t_Zero; break;\n  case lltok::kw_none: ID.Kind = ValID::t_None; break;\n\n  case lltok::lbrace: {\n    // ValID ::= '{' ConstVector '}'\n    Lex.Lex();\n    SmallVector<Constant*, 16> Elts;\n    if (parseGlobalValueVector(Elts) ||\n        parseToken(lltok::rbrace, \"expected end of struct constant\"))\n      return true;\n\n    ID.ConstantStructElts = std::make_unique<Constant *[]>(Elts.size());\n    ID.UIntVal = Elts.size();\n    memcpy(ID.ConstantStructElts.get(), Elts.data(),\n           Elts.size() * sizeof(Elts[0]));\n    ID.Kind = ValID::t_ConstantStruct;\n    return false;\n  }\n  case lltok::less: {\n    // ValID ::= '<' ConstVector '>'         --> Vector.\n    // ValID ::= '<' '{' ConstVector '}' '>' --> Packed Struct.\n    Lex.Lex();\n    bool isPackedStruct = EatIfPresent(lltok::lbrace);\n\n    SmallVector<Constant*, 16> Elts;\n    LocTy FirstEltLoc = Lex.getLoc();\n    if (parseGlobalValueVector(Elts) ||\n        (isPackedStruct &&\n         parseToken(lltok::rbrace, \"expected end of packed struct\")) ||\n        parseToken(lltok::greater, \"expected end of constant\"))\n      return true;\n\n    if (isPackedStruct) {\n      ID.ConstantStructElts = std::make_unique<Constant *[]>(Elts.size());\n      memcpy(ID.ConstantStructElts.get(), Elts.data(),\n             Elts.size() * sizeof(Elts[0]));\n      ID.UIntVal = Elts.size();\n      ID.Kind = ValID::t_PackedConstantStruct;\n      return false;\n    }\n\n    if (Elts.empty())\n      return error(ID.Loc, \"constant vector must not be empty\");\n\n    if (!Elts[0]->getType()->isIntegerTy() &&\n        !Elts[0]->getType()->isFloatingPointTy() &&\n        !Elts[0]->getType()->isPointerTy())\n      return error(\n          FirstEltLoc,\n          \"vector elements must have integer, pointer or floating point type\");\n\n    // Verify that all the vector elements have the same type.\n    for (unsigned i = 1, e = Elts.size(); i != e; ++i)\n      if (Elts[i]->getType() != Elts[0]->getType())\n        return error(FirstEltLoc, \"vector element #\" + Twine(i) +\n                                      \" is not of type '\" +\n                                      getTypeString(Elts[0]->getType()));\n\n    ID.ConstantVal = ConstantVector::get(Elts);\n    ID.Kind = ValID::t_Constant;\n    return false;\n  }\n  case lltok::lsquare: {   // Array Constant\n    Lex.Lex();\n    SmallVector<Constant*, 16> Elts;\n    LocTy FirstEltLoc = Lex.getLoc();\n    if (parseGlobalValueVector(Elts) ||\n        parseToken(lltok::rsquare, \"expected end of array constant\"))\n      return true;\n\n    // Handle empty element.\n    if (Elts.empty()) {\n      // Use undef instead of an array because it's inconvenient to determine\n      // the element type at this point, there being no elements to examine.\n      ID.Kind = ValID::t_EmptyArray;\n      return false;\n    }\n\n    if (!Elts[0]->getType()->isFirstClassType())\n      return error(FirstEltLoc, \"invalid array element type: \" +\n                                    getTypeString(Elts[0]->getType()));\n\n    ArrayType *ATy = ArrayType::get(Elts[0]->getType(), Elts.size());\n\n    // Verify all elements are correct type!\n    for (unsigned i = 0, e = Elts.size(); i != e; ++i) {\n      if (Elts[i]->getType() != Elts[0]->getType())\n        return error(FirstEltLoc, \"array element #\" + Twine(i) +\n                                      \" is not of type '\" +\n                                      getTypeString(Elts[0]->getType()));\n    }\n\n    ID.ConstantVal = ConstantArray::get(ATy, Elts);\n    ID.Kind = ValID::t_Constant;\n    return false;\n  }\n  case lltok::kw_c:  // c \"foo\"\n    Lex.Lex();\n    ID.ConstantVal = ConstantDataArray::getString(Context, Lex.getStrVal(),\n                                                  false);\n    if (parseToken(lltok::StringConstant, \"expected string\"))\n      return true;\n    ID.Kind = ValID::t_Constant;\n    return false;\n\n  case lltok::kw_asm: {\n    // ValID ::= 'asm' SideEffect? AlignStack? IntelDialect? STRINGCONSTANT ','\n    //             STRINGCONSTANT\n    bool HasSideEffect, AlignStack, AsmDialect;\n    Lex.Lex();\n    if (parseOptionalToken(lltok::kw_sideeffect, HasSideEffect) ||\n        parseOptionalToken(lltok::kw_alignstack, AlignStack) ||\n        parseOptionalToken(lltok::kw_inteldialect, AsmDialect) ||\n        parseStringConstant(ID.StrVal) ||\n        parseToken(lltok::comma, \"expected comma in inline asm expression\") ||\n        parseToken(lltok::StringConstant, \"expected constraint string\"))\n      return true;\n    ID.StrVal2 = Lex.getStrVal();\n    ID.UIntVal = unsigned(HasSideEffect) | (unsigned(AlignStack)<<1) |\n      (unsigned(AsmDialect)<<2);\n    ID.Kind = ValID::t_InlineAsm;\n    return false;\n  }\n\n  case lltok::kw_blockaddress: {\n    // ValID ::= 'blockaddress' '(' @foo ',' %bar ')'\n    Lex.Lex();\n\n    ValID Fn, Label;\n\n    if (parseToken(lltok::lparen, \"expected '(' in block address expression\") ||\n        parseValID(Fn) ||\n        parseToken(lltok::comma,\n                   \"expected comma in block address expression\") ||\n        parseValID(Label) ||\n        parseToken(lltok::rparen, \"expected ')' in block address expression\"))\n      return true;\n\n    if (Fn.Kind != ValID::t_GlobalID && Fn.Kind != ValID::t_GlobalName)\n      return error(Fn.Loc, \"expected function name in blockaddress\");\n    if (Label.Kind != ValID::t_LocalID && Label.Kind != ValID::t_LocalName)\n      return error(Label.Loc, \"expected basic block name in blockaddress\");\n\n    // Try to find the function (but skip it if it's forward-referenced).\n    GlobalValue *GV = nullptr;\n    if (Fn.Kind == ValID::t_GlobalID) {\n      if (Fn.UIntVal < NumberedVals.size())\n        GV = NumberedVals[Fn.UIntVal];\n    } else if (!ForwardRefVals.count(Fn.StrVal)) {\n      GV = M->getNamedValue(Fn.StrVal);\n    }\n    Function *F = nullptr;\n    if (GV) {\n      // Confirm that it's actually a function with a definition.\n      if (!isa<Function>(GV))\n        return error(Fn.Loc, \"expected function name in blockaddress\");\n      F = cast<Function>(GV);\n      if (F->isDeclaration())\n        return error(Fn.Loc, \"cannot take blockaddress inside a declaration\");\n    }\n\n    if (!F) {\n      // Make a global variable as a placeholder for this reference.\n      GlobalValue *&FwdRef =\n          ForwardRefBlockAddresses.insert(std::make_pair(\n                                              std::move(Fn),\n                                              std::map<ValID, GlobalValue *>()))\n              .first->second.insert(std::make_pair(std::move(Label), nullptr))\n              .first->second;\n      if (!FwdRef)\n        FwdRef = new GlobalVariable(*M, Type::getInt8Ty(Context), false,\n                                    GlobalValue::InternalLinkage, nullptr, \"\");\n      ID.ConstantVal = FwdRef;\n      ID.Kind = ValID::t_Constant;\n      return false;\n    }\n\n    // We found the function; now find the basic block.  Don't use PFS, since we\n    // might be inside a constant expression.\n    BasicBlock *BB;\n    if (BlockAddressPFS && F == &BlockAddressPFS->getFunction()) {\n      if (Label.Kind == ValID::t_LocalID)\n        BB = BlockAddressPFS->getBB(Label.UIntVal, Label.Loc);\n      else\n        BB = BlockAddressPFS->getBB(Label.StrVal, Label.Loc);\n      if (!BB)\n        return error(Label.Loc, \"referenced value is not a basic block\");\n    } else {\n      if (Label.Kind == ValID::t_LocalID)\n        return error(Label.Loc, \"cannot take address of numeric label after \"\n                                \"the function is defined\");\n      BB = dyn_cast_or_null<BasicBlock>(\n          F->getValueSymbolTable()->lookup(Label.StrVal));\n      if (!BB)\n        return error(Label.Loc, \"referenced value is not a basic block\");\n    }\n\n    ID.ConstantVal = BlockAddress::get(F, BB);\n    ID.Kind = ValID::t_Constant;\n    return false;\n  }\n\n  case lltok::kw_dso_local_equivalent: {\n    // ValID ::= 'dso_local_equivalent' @foo\n    Lex.Lex();\n\n    ValID Fn;\n\n    if (parseValID(Fn))\n      return true;\n\n    if (Fn.Kind != ValID::t_GlobalID && Fn.Kind != ValID::t_GlobalName)\n      return error(Fn.Loc,\n                   \"expected global value name in dso_local_equivalent\");\n\n    // Try to find the function (but skip it if it's forward-referenced).\n    GlobalValue *GV = nullptr;\n    if (Fn.Kind == ValID::t_GlobalID) {\n      if (Fn.UIntVal < NumberedVals.size())\n        GV = NumberedVals[Fn.UIntVal];\n    } else if (!ForwardRefVals.count(Fn.StrVal)) {\n      GV = M->getNamedValue(Fn.StrVal);\n    }\n\n    assert(GV && \"Could not find a corresponding global variable\");\n\n    if (!GV->getValueType()->isFunctionTy())\n      return error(Fn.Loc, \"expected a function, alias to function, or ifunc \"\n                           \"in dso_local_equivalent\");\n\n    ID.ConstantVal = DSOLocalEquivalent::get(GV);\n    ID.Kind = ValID::t_Constant;\n    return false;\n  }\n\n  case lltok::kw_trunc:\n  case lltok::kw_zext:\n  case lltok::kw_sext:\n  case lltok::kw_fptrunc:\n  case lltok::kw_fpext:\n  case lltok::kw_bitcast:\n  case lltok::kw_addrspacecast:\n  case lltok::kw_uitofp:\n  case lltok::kw_sitofp:\n  case lltok::kw_fptoui:\n  case lltok::kw_fptosi:\n  case lltok::kw_inttoptr:\n  case lltok::kw_ptrtoint: {\n    unsigned Opc = Lex.getUIntVal();\n    Type *DestTy = nullptr;\n    Constant *SrcVal;\n    Lex.Lex();\n    if (parseToken(lltok::lparen, \"expected '(' after constantexpr cast\") ||\n        parseGlobalTypeAndValue(SrcVal) ||\n        parseToken(lltok::kw_to, \"expected 'to' in constantexpr cast\") ||\n        parseType(DestTy) ||\n        parseToken(lltok::rparen, \"expected ')' at end of constantexpr cast\"))\n      return true;\n    if (!CastInst::castIsValid((Instruction::CastOps)Opc, SrcVal, DestTy))\n      return error(ID.Loc, \"invalid cast opcode for cast from '\" +\n                               getTypeString(SrcVal->getType()) + \"' to '\" +\n                               getTypeString(DestTy) + \"'\");\n    ID.ConstantVal = ConstantExpr::getCast((Instruction::CastOps)Opc,\n                                                 SrcVal, DestTy);\n    ID.Kind = ValID::t_Constant;\n    return false;\n  }\n  case lltok::kw_extractvalue: {\n    Lex.Lex();\n    Constant *Val;\n    SmallVector<unsigned, 4> Indices;\n    if (parseToken(lltok::lparen,\n                   \"expected '(' in extractvalue constantexpr\") ||\n        parseGlobalTypeAndValue(Val) || parseIndexList(Indices) ||\n        parseToken(lltok::rparen, \"expected ')' in extractvalue constantexpr\"))\n      return true;\n\n    if (!Val->getType()->isAggregateType())\n      return error(ID.Loc, \"extractvalue operand must be aggregate type\");\n    if (!ExtractValueInst::getIndexedType(Val->getType(), Indices))\n      return error(ID.Loc, \"invalid indices for extractvalue\");\n    ID.ConstantVal = ConstantExpr::getExtractValue(Val, Indices);\n    ID.Kind = ValID::t_Constant;\n    return false;\n  }\n  case lltok::kw_insertvalue: {\n    Lex.Lex();\n    Constant *Val0, *Val1;\n    SmallVector<unsigned, 4> Indices;\n    if (parseToken(lltok::lparen, \"expected '(' in insertvalue constantexpr\") ||\n        parseGlobalTypeAndValue(Val0) ||\n        parseToken(lltok::comma,\n                   \"expected comma in insertvalue constantexpr\") ||\n        parseGlobalTypeAndValue(Val1) || parseIndexList(Indices) ||\n        parseToken(lltok::rparen, \"expected ')' in insertvalue constantexpr\"))\n      return true;\n    if (!Val0->getType()->isAggregateType())\n      return error(ID.Loc, \"insertvalue operand must be aggregate type\");\n    Type *IndexedType =\n        ExtractValueInst::getIndexedType(Val0->getType(), Indices);\n    if (!IndexedType)\n      return error(ID.Loc, \"invalid indices for insertvalue\");\n    if (IndexedType != Val1->getType())\n      return error(ID.Loc, \"insertvalue operand and field disagree in type: '\" +\n                               getTypeString(Val1->getType()) +\n                               \"' instead of '\" + getTypeString(IndexedType) +\n                               \"'\");\n    ID.ConstantVal = ConstantExpr::getInsertValue(Val0, Val1, Indices);\n    ID.Kind = ValID::t_Constant;\n    return false;\n  }\n  case lltok::kw_icmp:\n  case lltok::kw_fcmp: {\n    unsigned PredVal, Opc = Lex.getUIntVal();\n    Constant *Val0, *Val1;\n    Lex.Lex();\n    if (parseCmpPredicate(PredVal, Opc) ||\n        parseToken(lltok::lparen, \"expected '(' in compare constantexpr\") ||\n        parseGlobalTypeAndValue(Val0) ||\n        parseToken(lltok::comma, \"expected comma in compare constantexpr\") ||\n        parseGlobalTypeAndValue(Val1) ||\n        parseToken(lltok::rparen, \"expected ')' in compare constantexpr\"))\n      return true;\n\n    if (Val0->getType() != Val1->getType())\n      return error(ID.Loc, \"compare operands must have the same type\");\n\n    CmpInst::Predicate Pred = (CmpInst::Predicate)PredVal;\n\n    if (Opc == Instruction::FCmp) {\n      if (!Val0->getType()->isFPOrFPVectorTy())\n        return error(ID.Loc, \"fcmp requires floating point operands\");\n      ID.ConstantVal = ConstantExpr::getFCmp(Pred, Val0, Val1);\n    } else {\n      assert(Opc == Instruction::ICmp && \"Unexpected opcode for CmpInst!\");\n      if (!Val0->getType()->isIntOrIntVectorTy() &&\n          !Val0->getType()->isPtrOrPtrVectorTy())\n        return error(ID.Loc, \"icmp requires pointer or integer operands\");\n      ID.ConstantVal = ConstantExpr::getICmp(Pred, Val0, Val1);\n    }\n    ID.Kind = ValID::t_Constant;\n    return false;\n  }\n\n  // Unary Operators.\n  case lltok::kw_fneg: {\n    unsigned Opc = Lex.getUIntVal();\n    Constant *Val;\n    Lex.Lex();\n    if (parseToken(lltok::lparen, \"expected '(' in unary constantexpr\") ||\n        parseGlobalTypeAndValue(Val) ||\n        parseToken(lltok::rparen, \"expected ')' in unary constantexpr\"))\n      return true;\n\n    // Check that the type is valid for the operator.\n    switch (Opc) {\n    case Instruction::FNeg:\n      if (!Val->getType()->isFPOrFPVectorTy())\n        return error(ID.Loc, \"constexpr requires fp operands\");\n      break;\n    default: llvm_unreachable(\"Unknown unary operator!\");\n    }\n    unsigned Flags = 0;\n    Constant *C = ConstantExpr::get(Opc, Val, Flags);\n    ID.ConstantVal = C;\n    ID.Kind = ValID::t_Constant;\n    return false;\n  }\n  // Binary Operators.\n  case lltok::kw_add:\n  case lltok::kw_fadd:\n  case lltok::kw_sub:\n  case lltok::kw_fsub:\n  case lltok::kw_mul:\n  case lltok::kw_fmul:\n  case lltok::kw_udiv:\n  case lltok::kw_sdiv:\n  case lltok::kw_fdiv:\n  case lltok::kw_urem:\n  case lltok::kw_srem:\n  case lltok::kw_frem:\n  case lltok::kw_shl:\n  case lltok::kw_lshr:\n  case lltok::kw_ashr: {\n    bool NUW = false;\n    bool NSW = false;\n    bool Exact = false;\n    unsigned Opc = Lex.getUIntVal();\n    Constant *Val0, *Val1;\n    Lex.Lex();\n    if (Opc == Instruction::Add || Opc == Instruction::Sub ||\n        Opc == Instruction::Mul || Opc == Instruction::Shl) {\n      if (EatIfPresent(lltok::kw_nuw))\n        NUW = true;\n      if (EatIfPresent(lltok::kw_nsw)) {\n        NSW = true;\n        if (EatIfPresent(lltok::kw_nuw))\n          NUW = true;\n      }\n    } else if (Opc == Instruction::SDiv || Opc == Instruction::UDiv ||\n               Opc == Instruction::LShr || Opc == Instruction::AShr) {\n      if (EatIfPresent(lltok::kw_exact))\n        Exact = true;\n    }\n    if (parseToken(lltok::lparen, \"expected '(' in binary constantexpr\") ||\n        parseGlobalTypeAndValue(Val0) ||\n        parseToken(lltok::comma, \"expected comma in binary constantexpr\") ||\n        parseGlobalTypeAndValue(Val1) ||\n        parseToken(lltok::rparen, \"expected ')' in binary constantexpr\"))\n      return true;\n    if (Val0->getType() != Val1->getType())\n      return error(ID.Loc, \"operands of constexpr must have same type\");\n    // Check that the type is valid for the operator.\n    switch (Opc) {\n    case Instruction::Add:\n    case Instruction::Sub:\n    case Instruction::Mul:\n    case Instruction::UDiv:\n    case Instruction::SDiv:\n    case Instruction::URem:\n    case Instruction::SRem:\n    case Instruction::Shl:\n    case Instruction::AShr:\n    case Instruction::LShr:\n      if (!Val0->getType()->isIntOrIntVectorTy())\n        return error(ID.Loc, \"constexpr requires integer operands\");\n      break;\n    case Instruction::FAdd:\n    case Instruction::FSub:\n    case Instruction::FMul:\n    case Instruction::FDiv:\n    case Instruction::FRem:\n      if (!Val0->getType()->isFPOrFPVectorTy())\n        return error(ID.Loc, \"constexpr requires fp operands\");\n      break;\n    default: llvm_unreachable(\"Unknown binary operator!\");\n    }\n    unsigned Flags = 0;\n    if (NUW)   Flags |= OverflowingBinaryOperator::NoUnsignedWrap;\n    if (NSW)   Flags |= OverflowingBinaryOperator::NoSignedWrap;\n    if (Exact) Flags |= PossiblyExactOperator::IsExact;\n    Constant *C = ConstantExpr::get(Opc, Val0, Val1, Flags);\n    ID.ConstantVal = C;\n    ID.Kind = ValID::t_Constant;\n    return false;\n  }\n\n  // Logical Operations\n  case lltok::kw_and:\n  case lltok::kw_or:\n  case lltok::kw_xor: {\n    unsigned Opc = Lex.getUIntVal();\n    Constant *Val0, *Val1;\n    Lex.Lex();\n    if (parseToken(lltok::lparen, \"expected '(' in logical constantexpr\") ||\n        parseGlobalTypeAndValue(Val0) ||\n        parseToken(lltok::comma, \"expected comma in logical constantexpr\") ||\n        parseGlobalTypeAndValue(Val1) ||\n        parseToken(lltok::rparen, \"expected ')' in logical constantexpr\"))\n      return true;\n    if (Val0->getType() != Val1->getType())\n      return error(ID.Loc, \"operands of constexpr must have same type\");\n    if (!Val0->getType()->isIntOrIntVectorTy())\n      return error(ID.Loc,\n                   \"constexpr requires integer or integer vector operands\");\n    ID.ConstantVal = ConstantExpr::get(Opc, Val0, Val1);\n    ID.Kind = ValID::t_Constant;\n    return false;\n  }\n\n  case lltok::kw_getelementptr:\n  case lltok::kw_shufflevector:\n  case lltok::kw_insertelement:\n  case lltok::kw_extractelement:\n  case lltok::kw_select: {\n    unsigned Opc = Lex.getUIntVal();\n    SmallVector<Constant*, 16> Elts;\n    bool InBounds = false;\n    Type *Ty;\n    Lex.Lex();\n\n    if (Opc == Instruction::GetElementPtr)\n      InBounds = EatIfPresent(lltok::kw_inbounds);\n\n    if (parseToken(lltok::lparen, \"expected '(' in constantexpr\"))\n      return true;\n\n    LocTy ExplicitTypeLoc = Lex.getLoc();\n    if (Opc == Instruction::GetElementPtr) {\n      if (parseType(Ty) ||\n          parseToken(lltok::comma, \"expected comma after getelementptr's type\"))\n        return true;\n    }\n\n    Optional<unsigned> InRangeOp;\n    if (parseGlobalValueVector(\n            Elts, Opc == Instruction::GetElementPtr ? &InRangeOp : nullptr) ||\n        parseToken(lltok::rparen, \"expected ')' in constantexpr\"))\n      return true;\n\n    if (Opc == Instruction::GetElementPtr) {\n      if (Elts.size() == 0 ||\n          !Elts[0]->getType()->isPtrOrPtrVectorTy())\n        return error(ID.Loc, \"base of getelementptr must be a pointer\");\n\n      Type *BaseType = Elts[0]->getType();\n      auto *BasePointerType = cast<PointerType>(BaseType->getScalarType());\n      if (Ty != BasePointerType->getElementType())\n        return error(\n            ExplicitTypeLoc,\n            \"explicit pointee type doesn't match operand's pointee type\");\n\n      unsigned GEPWidth =\n          BaseType->isVectorTy()\n              ? cast<FixedVectorType>(BaseType)->getNumElements()\n              : 0;\n\n      ArrayRef<Constant *> Indices(Elts.begin() + 1, Elts.end());\n      for (Constant *Val : Indices) {\n        Type *ValTy = Val->getType();\n        if (!ValTy->isIntOrIntVectorTy())\n          return error(ID.Loc, \"getelementptr index must be an integer\");\n        if (auto *ValVTy = dyn_cast<VectorType>(ValTy)) {\n          unsigned ValNumEl = cast<FixedVectorType>(ValVTy)->getNumElements();\n          if (GEPWidth && (ValNumEl != GEPWidth))\n            return error(\n                ID.Loc,\n                \"getelementptr vector index has a wrong number of elements\");\n          // GEPWidth may have been unknown because the base is a scalar,\n          // but it is known now.\n          GEPWidth = ValNumEl;\n        }\n      }\n\n      SmallPtrSet<Type*, 4> Visited;\n      if (!Indices.empty() && !Ty->isSized(&Visited))\n        return error(ID.Loc, \"base element of getelementptr must be sized\");\n\n      if (!GetElementPtrInst::getIndexedType(Ty, Indices))\n        return error(ID.Loc, \"invalid getelementptr indices\");\n\n      if (InRangeOp) {\n        if (*InRangeOp == 0)\n          return error(ID.Loc,\n                       \"inrange keyword may not appear on pointer operand\");\n        --*InRangeOp;\n      }\n\n      ID.ConstantVal = ConstantExpr::getGetElementPtr(Ty, Elts[0], Indices,\n                                                      InBounds, InRangeOp);\n    } else if (Opc == Instruction::Select) {\n      if (Elts.size() != 3)\n        return error(ID.Loc, \"expected three operands to select\");\n      if (const char *Reason = SelectInst::areInvalidOperands(Elts[0], Elts[1],\n                                                              Elts[2]))\n        return error(ID.Loc, Reason);\n      ID.ConstantVal = ConstantExpr::getSelect(Elts[0], Elts[1], Elts[2]);\n    } else if (Opc == Instruction::ShuffleVector) {\n      if (Elts.size() != 3)\n        return error(ID.Loc, \"expected three operands to shufflevector\");\n      if (!ShuffleVectorInst::isValidOperands(Elts[0], Elts[1], Elts[2]))\n        return error(ID.Loc, \"invalid operands to shufflevector\");\n      SmallVector<int, 16> Mask;\n      ShuffleVectorInst::getShuffleMask(cast<Constant>(Elts[2]), Mask);\n      ID.ConstantVal = ConstantExpr::getShuffleVector(Elts[0], Elts[1], Mask);\n    } else if (Opc == Instruction::ExtractElement) {\n      if (Elts.size() != 2)\n        return error(ID.Loc, \"expected two operands to extractelement\");\n      if (!ExtractElementInst::isValidOperands(Elts[0], Elts[1]))\n        return error(ID.Loc, \"invalid extractelement operands\");\n      ID.ConstantVal = ConstantExpr::getExtractElement(Elts[0], Elts[1]);\n    } else {\n      assert(Opc == Instruction::InsertElement && \"Unknown opcode\");\n      if (Elts.size() != 3)\n        return error(ID.Loc, \"expected three operands to insertelement\");\n      if (!InsertElementInst::isValidOperands(Elts[0], Elts[1], Elts[2]))\n        return error(ID.Loc, \"invalid insertelement operands\");\n      ID.ConstantVal =\n                 ConstantExpr::getInsertElement(Elts[0], Elts[1],Elts[2]);\n    }\n\n    ID.Kind = ValID::t_Constant;\n    return false;\n  }\n  }\n\n  Lex.Lex();\n  return false;\n}\n\n/// parseGlobalValue - parse a global value with the specified type.\nbool LLParser::parseGlobalValue(Type *Ty, Constant *&C) {\n  C = nullptr;\n  ValID ID;\n  Value *V = nullptr;\n  bool Parsed = parseValID(ID) ||\n                convertValIDToValue(Ty, ID, V, nullptr, /*IsCall=*/false);\n  if (V && !(C = dyn_cast<Constant>(V)))\n    return error(ID.Loc, \"global values must be constants\");\n  return Parsed;\n}\n\nbool LLParser::parseGlobalTypeAndValue(Constant *&V) {\n  Type *Ty = nullptr;\n  return parseType(Ty) || parseGlobalValue(Ty, V);\n}\n\nbool LLParser::parseOptionalComdat(StringRef GlobalName, Comdat *&C) {\n  C = nullptr;\n\n  LocTy KwLoc = Lex.getLoc();\n  if (!EatIfPresent(lltok::kw_comdat))\n    return false;\n\n  if (EatIfPresent(lltok::lparen)) {\n    if (Lex.getKind() != lltok::ComdatVar)\n      return tokError(\"expected comdat variable\");\n    C = getComdat(Lex.getStrVal(), Lex.getLoc());\n    Lex.Lex();\n    if (parseToken(lltok::rparen, \"expected ')' after comdat var\"))\n      return true;\n  } else {\n    if (GlobalName.empty())\n      return tokError(\"comdat cannot be unnamed\");\n    C = getComdat(std::string(GlobalName), KwLoc);\n  }\n\n  return false;\n}\n\n/// parseGlobalValueVector\n///   ::= /*empty*/\n///   ::= [inrange] TypeAndValue (',' [inrange] TypeAndValue)*\nbool LLParser::parseGlobalValueVector(SmallVectorImpl<Constant *> &Elts,\n                                      Optional<unsigned> *InRangeOp) {\n  // Empty list.\n  if (Lex.getKind() == lltok::rbrace ||\n      Lex.getKind() == lltok::rsquare ||\n      Lex.getKind() == lltok::greater ||\n      Lex.getKind() == lltok::rparen)\n    return false;\n\n  do {\n    if (InRangeOp && !*InRangeOp && EatIfPresent(lltok::kw_inrange))\n      *InRangeOp = Elts.size();\n\n    Constant *C;\n    if (parseGlobalTypeAndValue(C))\n      return true;\n    Elts.push_back(C);\n  } while (EatIfPresent(lltok::comma));\n\n  return false;\n}\n\nbool LLParser::parseMDTuple(MDNode *&MD, bool IsDistinct) {\n  SmallVector<Metadata *, 16> Elts;\n  if (parseMDNodeVector(Elts))\n    return true;\n\n  MD = (IsDistinct ? MDTuple::getDistinct : MDTuple::get)(Context, Elts);\n  return false;\n}\n\n/// MDNode:\n///  ::= !{ ... }\n///  ::= !7\n///  ::= !DILocation(...)\nbool LLParser::parseMDNode(MDNode *&N) {\n  if (Lex.getKind() == lltok::MetadataVar)\n    return parseSpecializedMDNode(N);\n\n  return parseToken(lltok::exclaim, \"expected '!' here\") || parseMDNodeTail(N);\n}\n\nbool LLParser::parseMDNodeTail(MDNode *&N) {\n  // !{ ... }\n  if (Lex.getKind() == lltok::lbrace)\n    return parseMDTuple(N);\n\n  // !42\n  return parseMDNodeID(N);\n}\n\nnamespace {\n\n/// Structure to represent an optional metadata field.\ntemplate <class FieldTy> struct MDFieldImpl {\n  typedef MDFieldImpl ImplTy;\n  FieldTy Val;\n  bool Seen;\n\n  void assign(FieldTy Val) {\n    Seen = true;\n    this->Val = std::move(Val);\n  }\n\n  explicit MDFieldImpl(FieldTy Default)\n      : Val(std::move(Default)), Seen(false) {}\n};\n\n/// Structure to represent an optional metadata field that\n/// can be of either type (A or B) and encapsulates the\n/// MD<typeofA>Field and MD<typeofB>Field structs, so not\n/// to reimplement the specifics for representing each Field.\ntemplate <class FieldTypeA, class FieldTypeB> struct MDEitherFieldImpl {\n  typedef MDEitherFieldImpl<FieldTypeA, FieldTypeB> ImplTy;\n  FieldTypeA A;\n  FieldTypeB B;\n  bool Seen;\n\n  enum {\n    IsInvalid = 0,\n    IsTypeA = 1,\n    IsTypeB = 2\n  } WhatIs;\n\n  void assign(FieldTypeA A) {\n    Seen = true;\n    this->A = std::move(A);\n    WhatIs = IsTypeA;\n  }\n\n  void assign(FieldTypeB B) {\n    Seen = true;\n    this->B = std::move(B);\n    WhatIs = IsTypeB;\n  }\n\n  explicit MDEitherFieldImpl(FieldTypeA DefaultA, FieldTypeB DefaultB)\n      : A(std::move(DefaultA)), B(std::move(DefaultB)), Seen(false),\n        WhatIs(IsInvalid) {}\n};\n\nstruct MDUnsignedField : public MDFieldImpl<uint64_t> {\n  uint64_t Max;\n\n  MDUnsignedField(uint64_t Default = 0, uint64_t Max = UINT64_MAX)\n      : ImplTy(Default), Max(Max) {}\n};\n\nstruct LineField : public MDUnsignedField {\n  LineField() : MDUnsignedField(0, UINT32_MAX) {}\n};\n\nstruct ColumnField : public MDUnsignedField {\n  ColumnField() : MDUnsignedField(0, UINT16_MAX) {}\n};\n\nstruct DwarfTagField : public MDUnsignedField {\n  DwarfTagField() : MDUnsignedField(0, dwarf::DW_TAG_hi_user) {}\n  DwarfTagField(dwarf::Tag DefaultTag)\n      : MDUnsignedField(DefaultTag, dwarf::DW_TAG_hi_user) {}\n};\n\nstruct DwarfMacinfoTypeField : public MDUnsignedField {\n  DwarfMacinfoTypeField() : MDUnsignedField(0, dwarf::DW_MACINFO_vendor_ext) {}\n  DwarfMacinfoTypeField(dwarf::MacinfoRecordType DefaultType)\n    : MDUnsignedField(DefaultType, dwarf::DW_MACINFO_vendor_ext) {}\n};\n\nstruct DwarfAttEncodingField : public MDUnsignedField {\n  DwarfAttEncodingField() : MDUnsignedField(0, dwarf::DW_ATE_hi_user) {}\n};\n\nstruct DwarfVirtualityField : public MDUnsignedField {\n  DwarfVirtualityField() : MDUnsignedField(0, dwarf::DW_VIRTUALITY_max) {}\n};\n\nstruct DwarfLangField : public MDUnsignedField {\n  DwarfLangField() : MDUnsignedField(0, dwarf::DW_LANG_hi_user) {}\n};\n\nstruct DwarfCCField : public MDUnsignedField {\n  DwarfCCField() : MDUnsignedField(0, dwarf::DW_CC_hi_user) {}\n};\n\nstruct EmissionKindField : public MDUnsignedField {\n  EmissionKindField() : MDUnsignedField(0, DICompileUnit::LastEmissionKind) {}\n};\n\nstruct NameTableKindField : public MDUnsignedField {\n  NameTableKindField()\n      : MDUnsignedField(\n            0, (unsigned)\n                   DICompileUnit::DebugNameTableKind::LastDebugNameTableKind) {}\n};\n\nstruct DIFlagField : public MDFieldImpl<DINode::DIFlags> {\n  DIFlagField() : MDFieldImpl(DINode::FlagZero) {}\n};\n\nstruct DISPFlagField : public MDFieldImpl<DISubprogram::DISPFlags> {\n  DISPFlagField() : MDFieldImpl(DISubprogram::SPFlagZero) {}\n};\n\nstruct MDAPSIntField : public MDFieldImpl<APSInt> {\n  MDAPSIntField() : ImplTy(APSInt()) {}\n};\n\nstruct MDSignedField : public MDFieldImpl<int64_t> {\n  int64_t Min;\n  int64_t Max;\n\n  MDSignedField(int64_t Default = 0)\n      : ImplTy(Default), Min(INT64_MIN), Max(INT64_MAX) {}\n  MDSignedField(int64_t Default, int64_t Min, int64_t Max)\n      : ImplTy(Default), Min(Min), Max(Max) {}\n};\n\nstruct MDBoolField : public MDFieldImpl<bool> {\n  MDBoolField(bool Default = false) : ImplTy(Default) {}\n};\n\nstruct MDField : public MDFieldImpl<Metadata *> {\n  bool AllowNull;\n\n  MDField(bool AllowNull = true) : ImplTy(nullptr), AllowNull(AllowNull) {}\n};\n\nstruct MDConstant : public MDFieldImpl<ConstantAsMetadata *> {\n  MDConstant() : ImplTy(nullptr) {}\n};\n\nstruct MDStringField : public MDFieldImpl<MDString *> {\n  bool AllowEmpty;\n  MDStringField(bool AllowEmpty = true)\n      : ImplTy(nullptr), AllowEmpty(AllowEmpty) {}\n};\n\nstruct MDFieldList : public MDFieldImpl<SmallVector<Metadata *, 4>> {\n  MDFieldList() : ImplTy(SmallVector<Metadata *, 4>()) {}\n};\n\nstruct ChecksumKindField : public MDFieldImpl<DIFile::ChecksumKind> {\n  ChecksumKindField(DIFile::ChecksumKind CSKind) : ImplTy(CSKind) {}\n};\n\nstruct MDSignedOrMDField : MDEitherFieldImpl<MDSignedField, MDField> {\n  MDSignedOrMDField(int64_t Default = 0, bool AllowNull = true)\n      : ImplTy(MDSignedField(Default), MDField(AllowNull)) {}\n\n  MDSignedOrMDField(int64_t Default, int64_t Min, int64_t Max,\n                    bool AllowNull = true)\n      : ImplTy(MDSignedField(Default, Min, Max), MDField(AllowNull)) {}\n\n  bool isMDSignedField() const { return WhatIs == IsTypeA; }\n  bool isMDField() const { return WhatIs == IsTypeB; }\n  int64_t getMDSignedValue() const {\n    assert(isMDSignedField() && \"Wrong field type\");\n    return A.Val;\n  }\n  Metadata *getMDFieldValue() const {\n    assert(isMDField() && \"Wrong field type\");\n    return B.Val;\n  }\n};\n\nstruct MDSignedOrUnsignedField\n    : MDEitherFieldImpl<MDSignedField, MDUnsignedField> {\n  MDSignedOrUnsignedField() : ImplTy(MDSignedField(0), MDUnsignedField(0)) {}\n\n  bool isMDSignedField() const { return WhatIs == IsTypeA; }\n  bool isMDUnsignedField() const { return WhatIs == IsTypeB; }\n  int64_t getMDSignedValue() const {\n    assert(isMDSignedField() && \"Wrong field type\");\n    return A.Val;\n  }\n  uint64_t getMDUnsignedValue() const {\n    assert(isMDUnsignedField() && \"Wrong field type\");\n    return B.Val;\n  }\n};\n\n} // end anonymous namespace\n\nnamespace llvm {\n\ntemplate <>\nbool LLParser::parseMDField(LocTy Loc, StringRef Name, MDAPSIntField &Result) {\n  if (Lex.getKind() != lltok::APSInt)\n    return tokError(\"expected integer\");\n\n  Result.assign(Lex.getAPSIntVal());\n  Lex.Lex();\n  return false;\n}\n\ntemplate <>\nbool LLParser::parseMDField(LocTy Loc, StringRef Name,\n                            MDUnsignedField &Result) {\n  if (Lex.getKind() != lltok::APSInt || Lex.getAPSIntVal().isSigned())\n    return tokError(\"expected unsigned integer\");\n\n  auto &U = Lex.getAPSIntVal();\n  if (U.ugt(Result.Max))\n    return tokError(\"value for '\" + Name + \"' too large, limit is \" +\n                    Twine(Result.Max));\n  Result.assign(U.getZExtValue());\n  assert(Result.Val <= Result.Max && \"Expected value in range\");\n  Lex.Lex();\n  return false;\n}\n\ntemplate <>\nbool LLParser::parseMDField(LocTy Loc, StringRef Name, LineField &Result) {\n  return parseMDField(Loc, Name, static_cast<MDUnsignedField &>(Result));\n}\ntemplate <>\nbool LLParser::parseMDField(LocTy Loc, StringRef Name, ColumnField &Result) {\n  return parseMDField(Loc, Name, static_cast<MDUnsignedField &>(Result));\n}\n\ntemplate <>\nbool LLParser::parseMDField(LocTy Loc, StringRef Name, DwarfTagField &Result) {\n  if (Lex.getKind() == lltok::APSInt)\n    return parseMDField(Loc, Name, static_cast<MDUnsignedField &>(Result));\n\n  if (Lex.getKind() != lltok::DwarfTag)\n    return tokError(\"expected DWARF tag\");\n\n  unsigned Tag = dwarf::getTag(Lex.getStrVal());\n  if (Tag == dwarf::DW_TAG_invalid)\n    return tokError(\"invalid DWARF tag\" + Twine(\" '\") + Lex.getStrVal() + \"'\");\n  assert(Tag <= Result.Max && \"Expected valid DWARF tag\");\n\n  Result.assign(Tag);\n  Lex.Lex();\n  return false;\n}\n\ntemplate <>\nbool LLParser::parseMDField(LocTy Loc, StringRef Name,\n                            DwarfMacinfoTypeField &Result) {\n  if (Lex.getKind() == lltok::APSInt)\n    return parseMDField(Loc, Name, static_cast<MDUnsignedField &>(Result));\n\n  if (Lex.getKind() != lltok::DwarfMacinfo)\n    return tokError(\"expected DWARF macinfo type\");\n\n  unsigned Macinfo = dwarf::getMacinfo(Lex.getStrVal());\n  if (Macinfo == dwarf::DW_MACINFO_invalid)\n    return tokError(\"invalid DWARF macinfo type\" + Twine(\" '\") +\n                    Lex.getStrVal() + \"'\");\n  assert(Macinfo <= Result.Max && \"Expected valid DWARF macinfo type\");\n\n  Result.assign(Macinfo);\n  Lex.Lex();\n  return false;\n}\n\ntemplate <>\nbool LLParser::parseMDField(LocTy Loc, StringRef Name,\n                            DwarfVirtualityField &Result) {\n  if (Lex.getKind() == lltok::APSInt)\n    return parseMDField(Loc, Name, static_cast<MDUnsignedField &>(Result));\n\n  if (Lex.getKind() != lltok::DwarfVirtuality)\n    return tokError(\"expected DWARF virtuality code\");\n\n  unsigned Virtuality = dwarf::getVirtuality(Lex.getStrVal());\n  if (Virtuality == dwarf::DW_VIRTUALITY_invalid)\n    return tokError(\"invalid DWARF virtuality code\" + Twine(\" '\") +\n                    Lex.getStrVal() + \"'\");\n  assert(Virtuality <= Result.Max && \"Expected valid DWARF virtuality code\");\n  Result.assign(Virtuality);\n  Lex.Lex();\n  return false;\n}\n\ntemplate <>\nbool LLParser::parseMDField(LocTy Loc, StringRef Name, DwarfLangField &Result) {\n  if (Lex.getKind() == lltok::APSInt)\n    return parseMDField(Loc, Name, static_cast<MDUnsignedField &>(Result));\n\n  if (Lex.getKind() != lltok::DwarfLang)\n    return tokError(\"expected DWARF language\");\n\n  unsigned Lang = dwarf::getLanguage(Lex.getStrVal());\n  if (!Lang)\n    return tokError(\"invalid DWARF language\" + Twine(\" '\") + Lex.getStrVal() +\n                    \"'\");\n  assert(Lang <= Result.Max && \"Expected valid DWARF language\");\n  Result.assign(Lang);\n  Lex.Lex();\n  return false;\n}\n\ntemplate <>\nbool LLParser::parseMDField(LocTy Loc, StringRef Name, DwarfCCField &Result) {\n  if (Lex.getKind() == lltok::APSInt)\n    return parseMDField(Loc, Name, static_cast<MDUnsignedField &>(Result));\n\n  if (Lex.getKind() != lltok::DwarfCC)\n    return tokError(\"expected DWARF calling convention\");\n\n  unsigned CC = dwarf::getCallingConvention(Lex.getStrVal());\n  if (!CC)\n    return tokError(\"invalid DWARF calling convention\" + Twine(\" '\") +\n                    Lex.getStrVal() + \"'\");\n  assert(CC <= Result.Max && \"Expected valid DWARF calling convention\");\n  Result.assign(CC);\n  Lex.Lex();\n  return false;\n}\n\ntemplate <>\nbool LLParser::parseMDField(LocTy Loc, StringRef Name,\n                            EmissionKindField &Result) {\n  if (Lex.getKind() == lltok::APSInt)\n    return parseMDField(Loc, Name, static_cast<MDUnsignedField &>(Result));\n\n  if (Lex.getKind() != lltok::EmissionKind)\n    return tokError(\"expected emission kind\");\n\n  auto Kind = DICompileUnit::getEmissionKind(Lex.getStrVal());\n  if (!Kind)\n    return tokError(\"invalid emission kind\" + Twine(\" '\") + Lex.getStrVal() +\n                    \"'\");\n  assert(*Kind <= Result.Max && \"Expected valid emission kind\");\n  Result.assign(*Kind);\n  Lex.Lex();\n  return false;\n}\n\ntemplate <>\nbool LLParser::parseMDField(LocTy Loc, StringRef Name,\n                            NameTableKindField &Result) {\n  if (Lex.getKind() == lltok::APSInt)\n    return parseMDField(Loc, Name, static_cast<MDUnsignedField &>(Result));\n\n  if (Lex.getKind() != lltok::NameTableKind)\n    return tokError(\"expected nameTable kind\");\n\n  auto Kind = DICompileUnit::getNameTableKind(Lex.getStrVal());\n  if (!Kind)\n    return tokError(\"invalid nameTable kind\" + Twine(\" '\") + Lex.getStrVal() +\n                    \"'\");\n  assert(((unsigned)*Kind) <= Result.Max && \"Expected valid nameTable kind\");\n  Result.assign((unsigned)*Kind);\n  Lex.Lex();\n  return false;\n}\n\ntemplate <>\nbool LLParser::parseMDField(LocTy Loc, StringRef Name,\n                            DwarfAttEncodingField &Result) {\n  if (Lex.getKind() == lltok::APSInt)\n    return parseMDField(Loc, Name, static_cast<MDUnsignedField &>(Result));\n\n  if (Lex.getKind() != lltok::DwarfAttEncoding)\n    return tokError(\"expected DWARF type attribute encoding\");\n\n  unsigned Encoding = dwarf::getAttributeEncoding(Lex.getStrVal());\n  if (!Encoding)\n    return tokError(\"invalid DWARF type attribute encoding\" + Twine(\" '\") +\n                    Lex.getStrVal() + \"'\");\n  assert(Encoding <= Result.Max && \"Expected valid DWARF language\");\n  Result.assign(Encoding);\n  Lex.Lex();\n  return false;\n}\n\n/// DIFlagField\n///  ::= uint32\n///  ::= DIFlagVector\n///  ::= DIFlagVector '|' DIFlagFwdDecl '|' uint32 '|' DIFlagPublic\ntemplate <>\nbool LLParser::parseMDField(LocTy Loc, StringRef Name, DIFlagField &Result) {\n\n  // parser for a single flag.\n  auto parseFlag = [&](DINode::DIFlags &Val) {\n    if (Lex.getKind() == lltok::APSInt && !Lex.getAPSIntVal().isSigned()) {\n      uint32_t TempVal = static_cast<uint32_t>(Val);\n      bool Res = parseUInt32(TempVal);\n      Val = static_cast<DINode::DIFlags>(TempVal);\n      return Res;\n    }\n\n    if (Lex.getKind() != lltok::DIFlag)\n      return tokError(\"expected debug info flag\");\n\n    Val = DINode::getFlag(Lex.getStrVal());\n    if (!Val)\n      return tokError(Twine(\"invalid debug info flag flag '\") +\n                      Lex.getStrVal() + \"'\");\n    Lex.Lex();\n    return false;\n  };\n\n  // parse the flags and combine them together.\n  DINode::DIFlags Combined = DINode::FlagZero;\n  do {\n    DINode::DIFlags Val;\n    if (parseFlag(Val))\n      return true;\n    Combined |= Val;\n  } while (EatIfPresent(lltok::bar));\n\n  Result.assign(Combined);\n  return false;\n}\n\n/// DISPFlagField\n///  ::= uint32\n///  ::= DISPFlagVector\n///  ::= DISPFlagVector '|' DISPFlag* '|' uint32\ntemplate <>\nbool LLParser::parseMDField(LocTy Loc, StringRef Name, DISPFlagField &Result) {\n\n  // parser for a single flag.\n  auto parseFlag = [&](DISubprogram::DISPFlags &Val) {\n    if (Lex.getKind() == lltok::APSInt && !Lex.getAPSIntVal().isSigned()) {\n      uint32_t TempVal = static_cast<uint32_t>(Val);\n      bool Res = parseUInt32(TempVal);\n      Val = static_cast<DISubprogram::DISPFlags>(TempVal);\n      return Res;\n    }\n\n    if (Lex.getKind() != lltok::DISPFlag)\n      return tokError(\"expected debug info flag\");\n\n    Val = DISubprogram::getFlag(Lex.getStrVal());\n    if (!Val)\n      return tokError(Twine(\"invalid subprogram debug info flag '\") +\n                      Lex.getStrVal() + \"'\");\n    Lex.Lex();\n    return false;\n  };\n\n  // parse the flags and combine them together.\n  DISubprogram::DISPFlags Combined = DISubprogram::SPFlagZero;\n  do {\n    DISubprogram::DISPFlags Val;\n    if (parseFlag(Val))\n      return true;\n    Combined |= Val;\n  } while (EatIfPresent(lltok::bar));\n\n  Result.assign(Combined);\n  return false;\n}\n\ntemplate <>\nbool LLParser::parseMDField(LocTy Loc, StringRef Name, MDSignedField &Result) {\n  if (Lex.getKind() != lltok::APSInt)\n    return tokError(\"expected signed integer\");\n\n  auto &S = Lex.getAPSIntVal();\n  if (S < Result.Min)\n    return tokError(\"value for '\" + Name + \"' too small, limit is \" +\n                    Twine(Result.Min));\n  if (S > Result.Max)\n    return tokError(\"value for '\" + Name + \"' too large, limit is \" +\n                    Twine(Result.Max));\n  Result.assign(S.getExtValue());\n  assert(Result.Val >= Result.Min && \"Expected value in range\");\n  assert(Result.Val <= Result.Max && \"Expected value in range\");\n  Lex.Lex();\n  return false;\n}\n\ntemplate <>\nbool LLParser::parseMDField(LocTy Loc, StringRef Name, MDBoolField &Result) {\n  switch (Lex.getKind()) {\n  default:\n    return tokError(\"expected 'true' or 'false'\");\n  case lltok::kw_true:\n    Result.assign(true);\n    break;\n  case lltok::kw_false:\n    Result.assign(false);\n    break;\n  }\n  Lex.Lex();\n  return false;\n}\n\ntemplate <>\nbool LLParser::parseMDField(LocTy Loc, StringRef Name, MDField &Result) {\n  if (Lex.getKind() == lltok::kw_null) {\n    if (!Result.AllowNull)\n      return tokError(\"'\" + Name + \"' cannot be null\");\n    Lex.Lex();\n    Result.assign(nullptr);\n    return false;\n  }\n\n  Metadata *MD;\n  if (parseMetadata(MD, nullptr))\n    return true;\n\n  Result.assign(MD);\n  return false;\n}\n\ntemplate <>\nbool LLParser::parseMDField(LocTy Loc, StringRef Name,\n                            MDSignedOrMDField &Result) {\n  // Try to parse a signed int.\n  if (Lex.getKind() == lltok::APSInt) {\n    MDSignedField Res = Result.A;\n    if (!parseMDField(Loc, Name, Res)) {\n      Result.assign(Res);\n      return false;\n    }\n    return true;\n  }\n\n  // Otherwise, try to parse as an MDField.\n  MDField Res = Result.B;\n  if (!parseMDField(Loc, Name, Res)) {\n    Result.assign(Res);\n    return false;\n  }\n\n  return true;\n}\n\ntemplate <>\nbool LLParser::parseMDField(LocTy Loc, StringRef Name, MDStringField &Result) {\n  LocTy ValueLoc = Lex.getLoc();\n  std::string S;\n  if (parseStringConstant(S))\n    return true;\n\n  if (!Result.AllowEmpty && S.empty())\n    return error(ValueLoc, \"'\" + Name + \"' cannot be empty\");\n\n  Result.assign(S.empty() ? nullptr : MDString::get(Context, S));\n  return false;\n}\n\ntemplate <>\nbool LLParser::parseMDField(LocTy Loc, StringRef Name, MDFieldList &Result) {\n  SmallVector<Metadata *, 4> MDs;\n  if (parseMDNodeVector(MDs))\n    return true;\n\n  Result.assign(std::move(MDs));\n  return false;\n}\n\ntemplate <>\nbool LLParser::parseMDField(LocTy Loc, StringRef Name,\n                            ChecksumKindField &Result) {\n  Optional<DIFile::ChecksumKind> CSKind =\n      DIFile::getChecksumKind(Lex.getStrVal());\n\n  if (Lex.getKind() != lltok::ChecksumKind || !CSKind)\n    return tokError(\"invalid checksum kind\" + Twine(\" '\") + Lex.getStrVal() +\n                    \"'\");\n\n  Result.assign(*CSKind);\n  Lex.Lex();\n  return false;\n}\n\n} // end namespace llvm\n\ntemplate <class ParserTy>\nbool LLParser::parseMDFieldsImplBody(ParserTy ParseField) {\n  do {\n    if (Lex.getKind() != lltok::LabelStr)\n      return tokError(\"expected field label here\");\n\n    if (ParseField())\n      return true;\n  } while (EatIfPresent(lltok::comma));\n\n  return false;\n}\n\ntemplate <class ParserTy>\nbool LLParser::parseMDFieldsImpl(ParserTy ParseField, LocTy &ClosingLoc) {\n  assert(Lex.getKind() == lltok::MetadataVar && \"Expected metadata type name\");\n  Lex.Lex();\n\n  if (parseToken(lltok::lparen, \"expected '(' here\"))\n    return true;\n  if (Lex.getKind() != lltok::rparen)\n    if (parseMDFieldsImplBody(ParseField))\n      return true;\n\n  ClosingLoc = Lex.getLoc();\n  return parseToken(lltok::rparen, \"expected ')' here\");\n}\n\ntemplate <class FieldTy>\nbool LLParser::parseMDField(StringRef Name, FieldTy &Result) {\n  if (Result.Seen)\n    return tokError(\"field '\" + Name + \"' cannot be specified more than once\");\n\n  LocTy Loc = Lex.getLoc();\n  Lex.Lex();\n  return parseMDField(Loc, Name, Result);\n}\n\nbool LLParser::parseSpecializedMDNode(MDNode *&N, bool IsDistinct) {\n  assert(Lex.getKind() == lltok::MetadataVar && \"Expected metadata type name\");\n\n#define HANDLE_SPECIALIZED_MDNODE_LEAF(CLASS)                                  \\\n  if (Lex.getStrVal() == #CLASS)                                               \\\n    return parse##CLASS(N, IsDistinct);\n#include \"llvm/IR/Metadata.def\"\n\n  return tokError(\"expected metadata type\");\n}\n\n#define DECLARE_FIELD(NAME, TYPE, INIT) TYPE NAME INIT\n#define NOP_FIELD(NAME, TYPE, INIT)\n#define REQUIRE_FIELD(NAME, TYPE, INIT)                                        \\\n  if (!NAME.Seen)                                                              \\\n    return error(ClosingLoc, \"missing required field '\" #NAME \"'\");\n#define PARSE_MD_FIELD(NAME, TYPE, DEFAULT)                                    \\\n  if (Lex.getStrVal() == #NAME)                                                \\\n    return parseMDField(#NAME, NAME);\n#define PARSE_MD_FIELDS()                                                      \\\n  VISIT_MD_FIELDS(DECLARE_FIELD, DECLARE_FIELD)                                \\\n  do {                                                                         \\\n    LocTy ClosingLoc;                                                          \\\n    if (parseMDFieldsImpl(                                                     \\\n            [&]() -> bool {                                                    \\\n              VISIT_MD_FIELDS(PARSE_MD_FIELD, PARSE_MD_FIELD)                  \\\n              return tokError(Twine(\"invalid field '\") + Lex.getStrVal() +     \\\n                              \"'\");                                            \\\n            },                                                                 \\\n            ClosingLoc))                                                       \\\n      return true;                                                             \\\n    VISIT_MD_FIELDS(NOP_FIELD, REQUIRE_FIELD)                                  \\\n  } while (false)\n#define GET_OR_DISTINCT(CLASS, ARGS)                                           \\\n  (IsDistinct ? CLASS::getDistinct ARGS : CLASS::get ARGS)\n\n/// parseDILocationFields:\n///   ::= !DILocation(line: 43, column: 8, scope: !5, inlinedAt: !6,\n///   isImplicitCode: true)\nbool LLParser::parseDILocation(MDNode *&Result, bool IsDistinct) {\n#define VISIT_MD_FIELDS(OPTIONAL, REQUIRED)                                    \\\n  OPTIONAL(line, LineField, );                                                 \\\n  OPTIONAL(column, ColumnField, );                                             \\\n  REQUIRED(scope, MDField, (/* AllowNull */ false));                           \\\n  OPTIONAL(inlinedAt, MDField, );                                              \\\n  OPTIONAL(isImplicitCode, MDBoolField, (false));\n  PARSE_MD_FIELDS();\n#undef VISIT_MD_FIELDS\n\n  Result =\n      GET_OR_DISTINCT(DILocation, (Context, line.Val, column.Val, scope.Val,\n                                   inlinedAt.Val, isImplicitCode.Val));\n  return false;\n}\n\n/// parseGenericDINode:\n///   ::= !GenericDINode(tag: 15, header: \"...\", operands: {...})\nbool LLParser::parseGenericDINode(MDNode *&Result, bool IsDistinct) {\n#define VISIT_MD_FIELDS(OPTIONAL, REQUIRED)                                    \\\n  REQUIRED(tag, DwarfTagField, );                                              \\\n  OPTIONAL(header, MDStringField, );                                           \\\n  OPTIONAL(operands, MDFieldList, );\n  PARSE_MD_FIELDS();\n#undef VISIT_MD_FIELDS\n\n  Result = GET_OR_DISTINCT(GenericDINode,\n                           (Context, tag.Val, header.Val, operands.Val));\n  return false;\n}\n\n/// parseDISubrange:\n///   ::= !DISubrange(count: 30, lowerBound: 2)\n///   ::= !DISubrange(count: !node, lowerBound: 2)\n///   ::= !DISubrange(lowerBound: !node1, upperBound: !node2, stride: !node3)\nbool LLParser::parseDISubrange(MDNode *&Result, bool IsDistinct) {\n#define VISIT_MD_FIELDS(OPTIONAL, REQUIRED)                                    \\\n  OPTIONAL(count, MDSignedOrMDField, (-1, -1, INT64_MAX, false));              \\\n  OPTIONAL(lowerBound, MDSignedOrMDField, );                                   \\\n  OPTIONAL(upperBound, MDSignedOrMDField, );                                   \\\n  OPTIONAL(stride, MDSignedOrMDField, );\n  PARSE_MD_FIELDS();\n#undef VISIT_MD_FIELDS\n\n  Metadata *Count = nullptr;\n  Metadata *LowerBound = nullptr;\n  Metadata *UpperBound = nullptr;\n  Metadata *Stride = nullptr;\n  if (count.isMDSignedField())\n    Count = ConstantAsMetadata::get(ConstantInt::getSigned(\n        Type::getInt64Ty(Context), count.getMDSignedValue()));\n  else if (count.isMDField())\n    Count = count.getMDFieldValue();\n\n  auto convToMetadata = [&](MDSignedOrMDField Bound) -> Metadata * {\n    if (Bound.isMDSignedField())\n      return ConstantAsMetadata::get(ConstantInt::getSigned(\n          Type::getInt64Ty(Context), Bound.getMDSignedValue()));\n    if (Bound.isMDField())\n      return Bound.getMDFieldValue();\n    return nullptr;\n  };\n\n  LowerBound = convToMetadata(lowerBound);\n  UpperBound = convToMetadata(upperBound);\n  Stride = convToMetadata(stride);\n\n  Result = GET_OR_DISTINCT(DISubrange,\n                           (Context, Count, LowerBound, UpperBound, Stride));\n\n  return false;\n}\n\n/// parseDIGenericSubrange:\n///   ::= !DIGenericSubrange(lowerBound: !node1, upperBound: !node2, stride:\n///   !node3)\nbool LLParser::parseDIGenericSubrange(MDNode *&Result, bool IsDistinct) {\n#define VISIT_MD_FIELDS(OPTIONAL, REQUIRED)                                    \\\n  OPTIONAL(count, MDSignedOrMDField, );                                        \\\n  OPTIONAL(lowerBound, MDSignedOrMDField, );                                   \\\n  OPTIONAL(upperBound, MDSignedOrMDField, );                                   \\\n  OPTIONAL(stride, MDSignedOrMDField, );\n  PARSE_MD_FIELDS();\n#undef VISIT_MD_FIELDS\n\n  auto ConvToMetadata = [&](MDSignedOrMDField Bound) -> Metadata * {\n    if (Bound.isMDSignedField())\n      return DIExpression::get(\n          Context, {dwarf::DW_OP_consts,\n                    static_cast<uint64_t>(Bound.getMDSignedValue())});\n    if (Bound.isMDField())\n      return Bound.getMDFieldValue();\n    return nullptr;\n  };\n\n  Metadata *Count = ConvToMetadata(count);\n  Metadata *LowerBound = ConvToMetadata(lowerBound);\n  Metadata *UpperBound = ConvToMetadata(upperBound);\n  Metadata *Stride = ConvToMetadata(stride);\n\n  Result = GET_OR_DISTINCT(DIGenericSubrange,\n                           (Context, Count, LowerBound, UpperBound, Stride));\n\n  return false;\n}\n\n/// parseDIEnumerator:\n///   ::= !DIEnumerator(value: 30, isUnsigned: true, name: \"SomeKind\")\nbool LLParser::parseDIEnumerator(MDNode *&Result, bool IsDistinct) {\n#define VISIT_MD_FIELDS(OPTIONAL, REQUIRED)                                    \\\n  REQUIRED(name, MDStringField, );                                             \\\n  REQUIRED(value, MDAPSIntField, );                                            \\\n  OPTIONAL(isUnsigned, MDBoolField, (false));\n  PARSE_MD_FIELDS();\n#undef VISIT_MD_FIELDS\n\n  if (isUnsigned.Val && value.Val.isNegative())\n    return tokError(\"unsigned enumerator with negative value\");\n\n  APSInt Value(value.Val);\n  // Add a leading zero so that unsigned values with the msb set are not\n  // mistaken for negative values when used for signed enumerators.\n  if (!isUnsigned.Val && value.Val.isUnsigned() && value.Val.isSignBitSet())\n    Value = Value.zext(Value.getBitWidth() + 1);\n\n  Result =\n      GET_OR_DISTINCT(DIEnumerator, (Context, Value, isUnsigned.Val, name.Val));\n\n  return false;\n}\n\n/// parseDIBasicType:\n///   ::= !DIBasicType(tag: DW_TAG_base_type, name: \"int\", size: 32, align: 32,\n///                    encoding: DW_ATE_encoding, flags: 0)\nbool LLParser::parseDIBasicType(MDNode *&Result, bool IsDistinct) {\n#define VISIT_MD_FIELDS(OPTIONAL, REQUIRED)                                    \\\n  OPTIONAL(tag, DwarfTagField, (dwarf::DW_TAG_base_type));                     \\\n  OPTIONAL(name, MDStringField, );                                             \\\n  OPTIONAL(size, MDUnsignedField, (0, UINT64_MAX));                            \\\n  OPTIONAL(align, MDUnsignedField, (0, UINT32_MAX));                           \\\n  OPTIONAL(encoding, DwarfAttEncodingField, );                                 \\\n  OPTIONAL(flags, DIFlagField, );\n  PARSE_MD_FIELDS();\n#undef VISIT_MD_FIELDS\n\n  Result = GET_OR_DISTINCT(DIBasicType, (Context, tag.Val, name.Val, size.Val,\n                                         align.Val, encoding.Val, flags.Val));\n  return false;\n}\n\n/// parseDIStringType:\n///   ::= !DIStringType(name: \"character(4)\", size: 32, align: 32)\nbool LLParser::parseDIStringType(MDNode *&Result, bool IsDistinct) {\n#define VISIT_MD_FIELDS(OPTIONAL, REQUIRED)                                    \\\n  OPTIONAL(tag, DwarfTagField, (dwarf::DW_TAG_string_type));                   \\\n  OPTIONAL(name, MDStringField, );                                             \\\n  OPTIONAL(stringLength, MDField, );                                           \\\n  OPTIONAL(stringLengthExpression, MDField, );                                 \\\n  OPTIONAL(size, MDUnsignedField, (0, UINT64_MAX));                            \\\n  OPTIONAL(align, MDUnsignedField, (0, UINT32_MAX));                           \\\n  OPTIONAL(encoding, DwarfAttEncodingField, );\n  PARSE_MD_FIELDS();\n#undef VISIT_MD_FIELDS\n\n  Result = GET_OR_DISTINCT(DIStringType,\n                           (Context, tag.Val, name.Val, stringLength.Val,\n                            stringLengthExpression.Val, size.Val, align.Val,\n                            encoding.Val));\n  return false;\n}\n\n/// parseDIDerivedType:\n///   ::= !DIDerivedType(tag: DW_TAG_pointer_type, name: \"int\", file: !0,\n///                      line: 7, scope: !1, baseType: !2, size: 32,\n///                      align: 32, offset: 0, flags: 0, extraData: !3,\n///                      dwarfAddressSpace: 3)\nbool LLParser::parseDIDerivedType(MDNode *&Result, bool IsDistinct) {\n#define VISIT_MD_FIELDS(OPTIONAL, REQUIRED)                                    \\\n  REQUIRED(tag, DwarfTagField, );                                              \\\n  OPTIONAL(name, MDStringField, );                                             \\\n  OPTIONAL(file, MDField, );                                                   \\\n  OPTIONAL(line, LineField, );                                                 \\\n  OPTIONAL(scope, MDField, );                                                  \\\n  REQUIRED(baseType, MDField, );                                               \\\n  OPTIONAL(size, MDUnsignedField, (0, UINT64_MAX));                            \\\n  OPTIONAL(align, MDUnsignedField, (0, UINT32_MAX));                           \\\n  OPTIONAL(offset, MDUnsignedField, (0, UINT64_MAX));                          \\\n  OPTIONAL(flags, DIFlagField, );                                              \\\n  OPTIONAL(extraData, MDField, );                                              \\\n  OPTIONAL(dwarfAddressSpace, MDUnsignedField, (UINT32_MAX, UINT32_MAX));\n  PARSE_MD_FIELDS();\n#undef VISIT_MD_FIELDS\n\n  Optional<unsigned> DWARFAddressSpace;\n  if (dwarfAddressSpace.Val != UINT32_MAX)\n    DWARFAddressSpace = dwarfAddressSpace.Val;\n\n  Result = GET_OR_DISTINCT(DIDerivedType,\n                           (Context, tag.Val, name.Val, file.Val, line.Val,\n                            scope.Val, baseType.Val, size.Val, align.Val,\n                            offset.Val, DWARFAddressSpace, flags.Val,\n                            extraData.Val));\n  return false;\n}\n\nbool LLParser::parseDICompositeType(MDNode *&Result, bool IsDistinct) {\n#define VISIT_MD_FIELDS(OPTIONAL, REQUIRED)                                    \\\n  REQUIRED(tag, DwarfTagField, );                                              \\\n  OPTIONAL(name, MDStringField, );                                             \\\n  OPTIONAL(file, MDField, );                                                   \\\n  OPTIONAL(line, LineField, );                                                 \\\n  OPTIONAL(scope, MDField, );                                                  \\\n  OPTIONAL(baseType, MDField, );                                               \\\n  OPTIONAL(size, MDUnsignedField, (0, UINT64_MAX));                            \\\n  OPTIONAL(align, MDUnsignedField, (0, UINT32_MAX));                           \\\n  OPTIONAL(offset, MDUnsignedField, (0, UINT64_MAX));                          \\\n  OPTIONAL(flags, DIFlagField, );                                              \\\n  OPTIONAL(elements, MDField, );                                               \\\n  OPTIONAL(runtimeLang, DwarfLangField, );                                     \\\n  OPTIONAL(vtableHolder, MDField, );                                           \\\n  OPTIONAL(templateParams, MDField, );                                         \\\n  OPTIONAL(identifier, MDStringField, );                                       \\\n  OPTIONAL(discriminator, MDField, );                                          \\\n  OPTIONAL(dataLocation, MDField, );                                           \\\n  OPTIONAL(associated, MDField, );                                             \\\n  OPTIONAL(allocated, MDField, );                                              \\\n  OPTIONAL(rank, MDSignedOrMDField, );\n  PARSE_MD_FIELDS();\n#undef VISIT_MD_FIELDS\n\n  Metadata *Rank = nullptr;\n  if (rank.isMDSignedField())\n    Rank = ConstantAsMetadata::get(ConstantInt::getSigned(\n        Type::getInt64Ty(Context), rank.getMDSignedValue()));\n  else if (rank.isMDField())\n    Rank = rank.getMDFieldValue();\n\n  // If this has an identifier try to build an ODR type.\n  if (identifier.Val)\n    if (auto *CT = DICompositeType::buildODRType(\n            Context, *identifier.Val, tag.Val, name.Val, file.Val, line.Val,\n            scope.Val, baseType.Val, size.Val, align.Val, offset.Val, flags.Val,\n            elements.Val, runtimeLang.Val, vtableHolder.Val, templateParams.Val,\n            discriminator.Val, dataLocation.Val, associated.Val, allocated.Val,\n            Rank)) {\n      Result = CT;\n      return false;\n    }\n\n  // Create a new node, and save it in the context if it belongs in the type\n  // map.\n  Result = GET_OR_DISTINCT(\n      DICompositeType,\n      (Context, tag.Val, name.Val, file.Val, line.Val, scope.Val, baseType.Val,\n       size.Val, align.Val, offset.Val, flags.Val, elements.Val,\n       runtimeLang.Val, vtableHolder.Val, templateParams.Val, identifier.Val,\n       discriminator.Val, dataLocation.Val, associated.Val, allocated.Val,\n       Rank));\n  return false;\n}\n\nbool LLParser::parseDISubroutineType(MDNode *&Result, bool IsDistinct) {\n#define VISIT_MD_FIELDS(OPTIONAL, REQUIRED)                                    \\\n  OPTIONAL(flags, DIFlagField, );                                              \\\n  OPTIONAL(cc, DwarfCCField, );                                                \\\n  REQUIRED(types, MDField, );\n  PARSE_MD_FIELDS();\n#undef VISIT_MD_FIELDS\n\n  Result = GET_OR_DISTINCT(DISubroutineType,\n                           (Context, flags.Val, cc.Val, types.Val));\n  return false;\n}\n\n/// parseDIFileType:\n///   ::= !DIFileType(filename: \"path/to/file\", directory: \"/path/to/dir\",\n///                   checksumkind: CSK_MD5,\n///                   checksum: \"000102030405060708090a0b0c0d0e0f\",\n///                   source: \"source file contents\")\nbool LLParser::parseDIFile(MDNode *&Result, bool IsDistinct) {\n  // The default constructed value for checksumkind is required, but will never\n  // be used, as the parser checks if the field was actually Seen before using\n  // the Val.\n#define VISIT_MD_FIELDS(OPTIONAL, REQUIRED)                                    \\\n  REQUIRED(filename, MDStringField, );                                         \\\n  REQUIRED(directory, MDStringField, );                                        \\\n  OPTIONAL(checksumkind, ChecksumKindField, (DIFile::CSK_MD5));                \\\n  OPTIONAL(checksum, MDStringField, );                                         \\\n  OPTIONAL(source, MDStringField, );\n  PARSE_MD_FIELDS();\n#undef VISIT_MD_FIELDS\n\n  Optional<DIFile::ChecksumInfo<MDString *>> OptChecksum;\n  if (checksumkind.Seen && checksum.Seen)\n    OptChecksum.emplace(checksumkind.Val, checksum.Val);\n  else if (checksumkind.Seen || checksum.Seen)\n    return Lex.Error(\"'checksumkind' and 'checksum' must be provided together\");\n\n  Optional<MDString *> OptSource;\n  if (source.Seen)\n    OptSource = source.Val;\n  Result = GET_OR_DISTINCT(DIFile, (Context, filename.Val, directory.Val,\n                                    OptChecksum, OptSource));\n  return false;\n}\n\n/// parseDICompileUnit:\n///   ::= !DICompileUnit(language: DW_LANG_C99, file: !0, producer: \"clang\",\n///                      isOptimized: true, flags: \"-O2\", runtimeVersion: 1,\n///                      splitDebugFilename: \"abc.debug\",\n///                      emissionKind: FullDebug, enums: !1, retainedTypes: !2,\n///                      globals: !4, imports: !5, macros: !6, dwoId: 0x0abcd,\n///                      sysroot: \"/\", sdk: \"MacOSX.sdk\")\nbool LLParser::parseDICompileUnit(MDNode *&Result, bool IsDistinct) {\n  if (!IsDistinct)\n    return Lex.Error(\"missing 'distinct', required for !DICompileUnit\");\n\n#define VISIT_MD_FIELDS(OPTIONAL, REQUIRED)                                    \\\n  REQUIRED(language, DwarfLangField, );                                        \\\n  REQUIRED(file, MDField, (/* AllowNull */ false));                            \\\n  OPTIONAL(producer, MDStringField, );                                         \\\n  OPTIONAL(isOptimized, MDBoolField, );                                        \\\n  OPTIONAL(flags, MDStringField, );                                            \\\n  OPTIONAL(runtimeVersion, MDUnsignedField, (0, UINT32_MAX));                  \\\n  OPTIONAL(splitDebugFilename, MDStringField, );                               \\\n  OPTIONAL(emissionKind, EmissionKindField, );                                 \\\n  OPTIONAL(enums, MDField, );                                                  \\\n  OPTIONAL(retainedTypes, MDField, );                                          \\\n  OPTIONAL(globals, MDField, );                                                \\\n  OPTIONAL(imports, MDField, );                                                \\\n  OPTIONAL(macros, MDField, );                                                 \\\n  OPTIONAL(dwoId, MDUnsignedField, );                                          \\\n  OPTIONAL(splitDebugInlining, MDBoolField, = true);                           \\\n  OPTIONAL(debugInfoForProfiling, MDBoolField, = false);                       \\\n  OPTIONAL(nameTableKind, NameTableKindField, );                               \\\n  OPTIONAL(rangesBaseAddress, MDBoolField, = false);                           \\\n  OPTIONAL(sysroot, MDStringField, );                                          \\\n  OPTIONAL(sdk, MDStringField, );\n  PARSE_MD_FIELDS();\n#undef VISIT_MD_FIELDS\n\n  Result = DICompileUnit::getDistinct(\n      Context, language.Val, file.Val, producer.Val, isOptimized.Val, flags.Val,\n      runtimeVersion.Val, splitDebugFilename.Val, emissionKind.Val, enums.Val,\n      retainedTypes.Val, globals.Val, imports.Val, macros.Val, dwoId.Val,\n      splitDebugInlining.Val, debugInfoForProfiling.Val, nameTableKind.Val,\n      rangesBaseAddress.Val, sysroot.Val, sdk.Val);\n  return false;\n}\n\n/// parseDISubprogram:\n///   ::= !DISubprogram(scope: !0, name: \"foo\", linkageName: \"_Zfoo\",\n///                     file: !1, line: 7, type: !2, isLocal: false,\n///                     isDefinition: true, scopeLine: 8, containingType: !3,\n///                     virtuality: DW_VIRTUALTIY_pure_virtual,\n///                     virtualIndex: 10, thisAdjustment: 4, flags: 11,\n///                     spFlags: 10, isOptimized: false, templateParams: !4,\n///                     declaration: !5, retainedNodes: !6, thrownTypes: !7)\nbool LLParser::parseDISubprogram(MDNode *&Result, bool IsDistinct) {\n  auto Loc = Lex.getLoc();\n#define VISIT_MD_FIELDS(OPTIONAL, REQUIRED)                                    \\\n  OPTIONAL(scope, MDField, );                                                  \\\n  OPTIONAL(name, MDStringField, );                                             \\\n  OPTIONAL(linkageName, MDStringField, );                                      \\\n  OPTIONAL(file, MDField, );                                                   \\\n  OPTIONAL(line, LineField, );                                                 \\\n  OPTIONAL(type, MDField, );                                                   \\\n  OPTIONAL(isLocal, MDBoolField, );                                            \\\n  OPTIONAL(isDefinition, MDBoolField, (true));                                 \\\n  OPTIONAL(scopeLine, LineField, );                                            \\\n  OPTIONAL(containingType, MDField, );                                         \\\n  OPTIONAL(virtuality, DwarfVirtualityField, );                                \\\n  OPTIONAL(virtualIndex, MDUnsignedField, (0, UINT32_MAX));                    \\\n  OPTIONAL(thisAdjustment, MDSignedField, (0, INT32_MIN, INT32_MAX));          \\\n  OPTIONAL(flags, DIFlagField, );                                              \\\n  OPTIONAL(spFlags, DISPFlagField, );                                          \\\n  OPTIONAL(isOptimized, MDBoolField, );                                        \\\n  OPTIONAL(unit, MDField, );                                                   \\\n  OPTIONAL(templateParams, MDField, );                                         \\\n  OPTIONAL(declaration, MDField, );                                            \\\n  OPTIONAL(retainedNodes, MDField, );                                          \\\n  OPTIONAL(thrownTypes, MDField, );\n  PARSE_MD_FIELDS();\n#undef VISIT_MD_FIELDS\n\n  // An explicit spFlags field takes precedence over individual fields in\n  // older IR versions.\n  DISubprogram::DISPFlags SPFlags =\n      spFlags.Seen ? spFlags.Val\n                   : DISubprogram::toSPFlags(isLocal.Val, isDefinition.Val,\n                                             isOptimized.Val, virtuality.Val);\n  if ((SPFlags & DISubprogram::SPFlagDefinition) && !IsDistinct)\n    return Lex.Error(\n        Loc,\n        \"missing 'distinct', required for !DISubprogram that is a Definition\");\n  Result = GET_OR_DISTINCT(\n      DISubprogram,\n      (Context, scope.Val, name.Val, linkageName.Val, file.Val, line.Val,\n       type.Val, scopeLine.Val, containingType.Val, virtualIndex.Val,\n       thisAdjustment.Val, flags.Val, SPFlags, unit.Val, templateParams.Val,\n       declaration.Val, retainedNodes.Val, thrownTypes.Val));\n  return false;\n}\n\n/// parseDILexicalBlock:\n///   ::= !DILexicalBlock(scope: !0, file: !2, line: 7, column: 9)\nbool LLParser::parseDILexicalBlock(MDNode *&Result, bool IsDistinct) {\n#define VISIT_MD_FIELDS(OPTIONAL, REQUIRED)                                    \\\n  REQUIRED(scope, MDField, (/* AllowNull */ false));                           \\\n  OPTIONAL(file, MDField, );                                                   \\\n  OPTIONAL(line, LineField, );                                                 \\\n  OPTIONAL(column, ColumnField, );\n  PARSE_MD_FIELDS();\n#undef VISIT_MD_FIELDS\n\n  Result = GET_OR_DISTINCT(\n      DILexicalBlock, (Context, scope.Val, file.Val, line.Val, column.Val));\n  return false;\n}\n\n/// parseDILexicalBlockFile:\n///   ::= !DILexicalBlockFile(scope: !0, file: !2, discriminator: 9)\nbool LLParser::parseDILexicalBlockFile(MDNode *&Result, bool IsDistinct) {\n#define VISIT_MD_FIELDS(OPTIONAL, REQUIRED)                                    \\\n  REQUIRED(scope, MDField, (/* AllowNull */ false));                           \\\n  OPTIONAL(file, MDField, );                                                   \\\n  REQUIRED(discriminator, MDUnsignedField, (0, UINT32_MAX));\n  PARSE_MD_FIELDS();\n#undef VISIT_MD_FIELDS\n\n  Result = GET_OR_DISTINCT(DILexicalBlockFile,\n                           (Context, scope.Val, file.Val, discriminator.Val));\n  return false;\n}\n\n/// parseDICommonBlock:\n///   ::= !DICommonBlock(scope: !0, file: !2, name: \"COMMON name\", line: 9)\nbool LLParser::parseDICommonBlock(MDNode *&Result, bool IsDistinct) {\n#define VISIT_MD_FIELDS(OPTIONAL, REQUIRED)                                    \\\n  REQUIRED(scope, MDField, );                                                  \\\n  OPTIONAL(declaration, MDField, );                                            \\\n  OPTIONAL(name, MDStringField, );                                             \\\n  OPTIONAL(file, MDField, );                                                   \\\n  OPTIONAL(line, LineField, );\n  PARSE_MD_FIELDS();\n#undef VISIT_MD_FIELDS\n\n  Result = GET_OR_DISTINCT(DICommonBlock,\n                           (Context, scope.Val, declaration.Val, name.Val,\n                            file.Val, line.Val));\n  return false;\n}\n\n/// parseDINamespace:\n///   ::= !DINamespace(scope: !0, file: !2, name: \"SomeNamespace\", line: 9)\nbool LLParser::parseDINamespace(MDNode *&Result, bool IsDistinct) {\n#define VISIT_MD_FIELDS(OPTIONAL, REQUIRED)                                    \\\n  REQUIRED(scope, MDField, );                                                  \\\n  OPTIONAL(name, MDStringField, );                                             \\\n  OPTIONAL(exportSymbols, MDBoolField, );\n  PARSE_MD_FIELDS();\n#undef VISIT_MD_FIELDS\n\n  Result = GET_OR_DISTINCT(DINamespace,\n                           (Context, scope.Val, name.Val, exportSymbols.Val));\n  return false;\n}\n\n/// parseDIMacro:\n///   ::= !DIMacro(macinfo: type, line: 9, name: \"SomeMacro\", value:\n///   \"SomeValue\")\nbool LLParser::parseDIMacro(MDNode *&Result, bool IsDistinct) {\n#define VISIT_MD_FIELDS(OPTIONAL, REQUIRED)                                    \\\n  REQUIRED(type, DwarfMacinfoTypeField, );                                     \\\n  OPTIONAL(line, LineField, );                                                 \\\n  REQUIRED(name, MDStringField, );                                             \\\n  OPTIONAL(value, MDStringField, );\n  PARSE_MD_FIELDS();\n#undef VISIT_MD_FIELDS\n\n  Result = GET_OR_DISTINCT(DIMacro,\n                           (Context, type.Val, line.Val, name.Val, value.Val));\n  return false;\n}\n\n/// parseDIMacroFile:\n///   ::= !DIMacroFile(line: 9, file: !2, nodes: !3)\nbool LLParser::parseDIMacroFile(MDNode *&Result, bool IsDistinct) {\n#define VISIT_MD_FIELDS(OPTIONAL, REQUIRED)                                    \\\n  OPTIONAL(type, DwarfMacinfoTypeField, (dwarf::DW_MACINFO_start_file));       \\\n  OPTIONAL(line, LineField, );                                                 \\\n  REQUIRED(file, MDField, );                                                   \\\n  OPTIONAL(nodes, MDField, );\n  PARSE_MD_FIELDS();\n#undef VISIT_MD_FIELDS\n\n  Result = GET_OR_DISTINCT(DIMacroFile,\n                           (Context, type.Val, line.Val, file.Val, nodes.Val));\n  return false;\n}\n\n/// parseDIModule:\n///   ::= !DIModule(scope: !0, name: \"SomeModule\", configMacros:\n///   \"-DNDEBUG\", includePath: \"/usr/include\", apinotes: \"module.apinotes\",\n///   file: !1, line: 4, isDecl: false)\nbool LLParser::parseDIModule(MDNode *&Result, bool IsDistinct) {\n#define VISIT_MD_FIELDS(OPTIONAL, REQUIRED)                                    \\\n  REQUIRED(scope, MDField, );                                                  \\\n  REQUIRED(name, MDStringField, );                                             \\\n  OPTIONAL(configMacros, MDStringField, );                                     \\\n  OPTIONAL(includePath, MDStringField, );                                      \\\n  OPTIONAL(apinotes, MDStringField, );                                         \\\n  OPTIONAL(file, MDField, );                                                   \\\n  OPTIONAL(line, LineField, );                                                 \\\n  OPTIONAL(isDecl, MDBoolField, );\n  PARSE_MD_FIELDS();\n#undef VISIT_MD_FIELDS\n\n  Result = GET_OR_DISTINCT(DIModule, (Context, file.Val, scope.Val, name.Val,\n                                      configMacros.Val, includePath.Val,\n                                      apinotes.Val, line.Val, isDecl.Val));\n  return false;\n}\n\n/// parseDITemplateTypeParameter:\n///   ::= !DITemplateTypeParameter(name: \"Ty\", type: !1, defaulted: false)\nbool LLParser::parseDITemplateTypeParameter(MDNode *&Result, bool IsDistinct) {\n#define VISIT_MD_FIELDS(OPTIONAL, REQUIRED)                                    \\\n  OPTIONAL(name, MDStringField, );                                             \\\n  REQUIRED(type, MDField, );                                                   \\\n  OPTIONAL(defaulted, MDBoolField, );\n  PARSE_MD_FIELDS();\n#undef VISIT_MD_FIELDS\n\n  Result = GET_OR_DISTINCT(DITemplateTypeParameter,\n                           (Context, name.Val, type.Val, defaulted.Val));\n  return false;\n}\n\n/// parseDITemplateValueParameter:\n///   ::= !DITemplateValueParameter(tag: DW_TAG_template_value_parameter,\n///                                 name: \"V\", type: !1, defaulted: false,\n///                                 value: i32 7)\nbool LLParser::parseDITemplateValueParameter(MDNode *&Result, bool IsDistinct) {\n#define VISIT_MD_FIELDS(OPTIONAL, REQUIRED)                                    \\\n  OPTIONAL(tag, DwarfTagField, (dwarf::DW_TAG_template_value_parameter));      \\\n  OPTIONAL(name, MDStringField, );                                             \\\n  OPTIONAL(type, MDField, );                                                   \\\n  OPTIONAL(defaulted, MDBoolField, );                                          \\\n  REQUIRED(value, MDField, );\n\n  PARSE_MD_FIELDS();\n#undef VISIT_MD_FIELDS\n\n  Result = GET_OR_DISTINCT(\n      DITemplateValueParameter,\n      (Context, tag.Val, name.Val, type.Val, defaulted.Val, value.Val));\n  return false;\n}\n\n/// parseDIGlobalVariable:\n///   ::= !DIGlobalVariable(scope: !0, name: \"foo\", linkageName: \"foo\",\n///                         file: !1, line: 7, type: !2, isLocal: false,\n///                         isDefinition: true, templateParams: !3,\n///                         declaration: !4, align: 8)\nbool LLParser::parseDIGlobalVariable(MDNode *&Result, bool IsDistinct) {\n#define VISIT_MD_FIELDS(OPTIONAL, REQUIRED)                                    \\\n  REQUIRED(name, MDStringField, (/* AllowEmpty */ false));                     \\\n  OPTIONAL(scope, MDField, );                                                  \\\n  OPTIONAL(linkageName, MDStringField, );                                      \\\n  OPTIONAL(file, MDField, );                                                   \\\n  OPTIONAL(line, LineField, );                                                 \\\n  OPTIONAL(type, MDField, );                                                   \\\n  OPTIONAL(isLocal, MDBoolField, );                                            \\\n  OPTIONAL(isDefinition, MDBoolField, (true));                                 \\\n  OPTIONAL(templateParams, MDField, );                                         \\\n  OPTIONAL(declaration, MDField, );                                            \\\n  OPTIONAL(align, MDUnsignedField, (0, UINT32_MAX));\n  PARSE_MD_FIELDS();\n#undef VISIT_MD_FIELDS\n\n  Result =\n      GET_OR_DISTINCT(DIGlobalVariable,\n                      (Context, scope.Val, name.Val, linkageName.Val, file.Val,\n                       line.Val, type.Val, isLocal.Val, isDefinition.Val,\n                       declaration.Val, templateParams.Val, align.Val));\n  return false;\n}\n\n/// parseDILocalVariable:\n///   ::= !DILocalVariable(arg: 7, scope: !0, name: \"foo\",\n///                        file: !1, line: 7, type: !2, arg: 2, flags: 7,\n///                        align: 8)\n///   ::= !DILocalVariable(scope: !0, name: \"foo\",\n///                        file: !1, line: 7, type: !2, arg: 2, flags: 7,\n///                        align: 8)\nbool LLParser::parseDILocalVariable(MDNode *&Result, bool IsDistinct) {\n#define VISIT_MD_FIELDS(OPTIONAL, REQUIRED)                                    \\\n  REQUIRED(scope, MDField, (/* AllowNull */ false));                           \\\n  OPTIONAL(name, MDStringField, );                                             \\\n  OPTIONAL(arg, MDUnsignedField, (0, UINT16_MAX));                             \\\n  OPTIONAL(file, MDField, );                                                   \\\n  OPTIONAL(line, LineField, );                                                 \\\n  OPTIONAL(type, MDField, );                                                   \\\n  OPTIONAL(flags, DIFlagField, );                                              \\\n  OPTIONAL(align, MDUnsignedField, (0, UINT32_MAX));\n  PARSE_MD_FIELDS();\n#undef VISIT_MD_FIELDS\n\n  Result = GET_OR_DISTINCT(DILocalVariable,\n                           (Context, scope.Val, name.Val, file.Val, line.Val,\n                            type.Val, arg.Val, flags.Val, align.Val));\n  return false;\n}\n\n/// parseDILabel:\n///   ::= !DILabel(scope: !0, name: \"foo\", file: !1, line: 7)\nbool LLParser::parseDILabel(MDNode *&Result, bool IsDistinct) {\n#define VISIT_MD_FIELDS(OPTIONAL, REQUIRED)                                    \\\n  REQUIRED(scope, MDField, (/* AllowNull */ false));                           \\\n  REQUIRED(name, MDStringField, );                                             \\\n  REQUIRED(file, MDField, );                                                   \\\n  REQUIRED(line, LineField, );\n  PARSE_MD_FIELDS();\n#undef VISIT_MD_FIELDS\n\n  Result = GET_OR_DISTINCT(DILabel,\n                           (Context, scope.Val, name.Val, file.Val, line.Val));\n  return false;\n}\n\n/// parseDIExpression:\n///   ::= !DIExpression(0, 7, -1)\nbool LLParser::parseDIExpression(MDNode *&Result, bool IsDistinct) {\n  assert(Lex.getKind() == lltok::MetadataVar && \"Expected metadata type name\");\n  Lex.Lex();\n\n  if (parseToken(lltok::lparen, \"expected '(' here\"))\n    return true;\n\n  SmallVector<uint64_t, 8> Elements;\n  if (Lex.getKind() != lltok::rparen)\n    do {\n      if (Lex.getKind() == lltok::DwarfOp) {\n        if (unsigned Op = dwarf::getOperationEncoding(Lex.getStrVal())) {\n          Lex.Lex();\n          Elements.push_back(Op);\n          continue;\n        }\n        return tokError(Twine(\"invalid DWARF op '\") + Lex.getStrVal() + \"'\");\n      }\n\n      if (Lex.getKind() == lltok::DwarfAttEncoding) {\n        if (unsigned Op = dwarf::getAttributeEncoding(Lex.getStrVal())) {\n          Lex.Lex();\n          Elements.push_back(Op);\n          continue;\n        }\n        return tokError(Twine(\"invalid DWARF attribute encoding '\") +\n                        Lex.getStrVal() + \"'\");\n      }\n\n      if (Lex.getKind() != lltok::APSInt || Lex.getAPSIntVal().isSigned())\n        return tokError(\"expected unsigned integer\");\n\n      auto &U = Lex.getAPSIntVal();\n      if (U.ugt(UINT64_MAX))\n        return tokError(\"element too large, limit is \" + Twine(UINT64_MAX));\n      Elements.push_back(U.getZExtValue());\n      Lex.Lex();\n    } while (EatIfPresent(lltok::comma));\n\n  if (parseToken(lltok::rparen, \"expected ')' here\"))\n    return true;\n\n  Result = GET_OR_DISTINCT(DIExpression, (Context, Elements));\n  return false;\n}\n\nbool LLParser::parseDIArgList(MDNode *&Result, bool IsDistinct) {\n  return parseDIArgList(Result, IsDistinct, nullptr);\n}\n/// ParseDIArgList:\n///   ::= !DIArgList(i32 7, i64 %0)\nbool LLParser::parseDIArgList(MDNode *&Result, bool IsDistinct,\n                              PerFunctionState *PFS) {\n  assert(PFS && \"Expected valid function state\");\n  assert(Lex.getKind() == lltok::MetadataVar && \"Expected metadata type name\");\n  Lex.Lex();\n\n  if (parseToken(lltok::lparen, \"expected '(' here\"))\n    return true;\n\n  SmallVector<ValueAsMetadata *, 4> Args;\n  if (Lex.getKind() != lltok::rparen)\n    do {\n      Metadata *MD;\n      if (parseValueAsMetadata(MD, \"expected value-as-metadata operand\", PFS))\n        return true;\n      Args.push_back(dyn_cast<ValueAsMetadata>(MD));\n    } while (EatIfPresent(lltok::comma));\n\n  if (parseToken(lltok::rparen, \"expected ')' here\"))\n    return true;\n\n  Result = GET_OR_DISTINCT(DIArgList, (Context, Args));\n  return false;\n}\n\n/// parseDIGlobalVariableExpression:\n///   ::= !DIGlobalVariableExpression(var: !0, expr: !1)\nbool LLParser::parseDIGlobalVariableExpression(MDNode *&Result,\n                                               bool IsDistinct) {\n#define VISIT_MD_FIELDS(OPTIONAL, REQUIRED)                                    \\\n  REQUIRED(var, MDField, );                                                    \\\n  REQUIRED(expr, MDField, );\n  PARSE_MD_FIELDS();\n#undef VISIT_MD_FIELDS\n\n  Result =\n      GET_OR_DISTINCT(DIGlobalVariableExpression, (Context, var.Val, expr.Val));\n  return false;\n}\n\n/// parseDIObjCProperty:\n///   ::= !DIObjCProperty(name: \"foo\", file: !1, line: 7, setter: \"setFoo\",\n///                       getter: \"getFoo\", attributes: 7, type: !2)\nbool LLParser::parseDIObjCProperty(MDNode *&Result, bool IsDistinct) {\n#define VISIT_MD_FIELDS(OPTIONAL, REQUIRED)                                    \\\n  OPTIONAL(name, MDStringField, );                                             \\\n  OPTIONAL(file, MDField, );                                                   \\\n  OPTIONAL(line, LineField, );                                                 \\\n  OPTIONAL(setter, MDStringField, );                                           \\\n  OPTIONAL(getter, MDStringField, );                                           \\\n  OPTIONAL(attributes, MDUnsignedField, (0, UINT32_MAX));                      \\\n  OPTIONAL(type, MDField, );\n  PARSE_MD_FIELDS();\n#undef VISIT_MD_FIELDS\n\n  Result = GET_OR_DISTINCT(DIObjCProperty,\n                           (Context, name.Val, file.Val, line.Val, setter.Val,\n                            getter.Val, attributes.Val, type.Val));\n  return false;\n}\n\n/// parseDIImportedEntity:\n///   ::= !DIImportedEntity(tag: DW_TAG_imported_module, scope: !0, entity: !1,\n///                         line: 7, name: \"foo\")\nbool LLParser::parseDIImportedEntity(MDNode *&Result, bool IsDistinct) {\n#define VISIT_MD_FIELDS(OPTIONAL, REQUIRED)                                    \\\n  REQUIRED(tag, DwarfTagField, );                                              \\\n  REQUIRED(scope, MDField, );                                                  \\\n  OPTIONAL(entity, MDField, );                                                 \\\n  OPTIONAL(file, MDField, );                                                   \\\n  OPTIONAL(line, LineField, );                                                 \\\n  OPTIONAL(name, MDStringField, );\n  PARSE_MD_FIELDS();\n#undef VISIT_MD_FIELDS\n\n  Result = GET_OR_DISTINCT(\n      DIImportedEntity,\n      (Context, tag.Val, scope.Val, entity.Val, file.Val, line.Val, name.Val));\n  return false;\n}\n\n#undef PARSE_MD_FIELD\n#undef NOP_FIELD\n#undef REQUIRE_FIELD\n#undef DECLARE_FIELD\n\n/// parseMetadataAsValue\n///  ::= metadata i32 %local\n///  ::= metadata i32 @global\n///  ::= metadata i32 7\n///  ::= metadata !0\n///  ::= metadata !{...}\n///  ::= metadata !\"string\"\nbool LLParser::parseMetadataAsValue(Value *&V, PerFunctionState &PFS) {\n  // Note: the type 'metadata' has already been parsed.\n  Metadata *MD;\n  if (parseMetadata(MD, &PFS))\n    return true;\n\n  V = MetadataAsValue::get(Context, MD);\n  return false;\n}\n\n/// parseValueAsMetadata\n///  ::= i32 %local\n///  ::= i32 @global\n///  ::= i32 7\nbool LLParser::parseValueAsMetadata(Metadata *&MD, const Twine &TypeMsg,\n                                    PerFunctionState *PFS) {\n  Type *Ty;\n  LocTy Loc;\n  if (parseType(Ty, TypeMsg, Loc))\n    return true;\n  if (Ty->isMetadataTy())\n    return error(Loc, \"invalid metadata-value-metadata roundtrip\");\n\n  Value *V;\n  if (parseValue(Ty, V, PFS))\n    return true;\n\n  MD = ValueAsMetadata::get(V);\n  return false;\n}\n\n/// parseMetadata\n///  ::= i32 %local\n///  ::= i32 @global\n///  ::= i32 7\n///  ::= !42\n///  ::= !{...}\n///  ::= !\"string\"\n///  ::= !DILocation(...)\nbool LLParser::parseMetadata(Metadata *&MD, PerFunctionState *PFS) {\n  if (Lex.getKind() == lltok::MetadataVar) {\n    MDNode *N;\n    // DIArgLists are a special case, as they are a list of ValueAsMetadata and\n    // so parsing this requires a Function State.\n    if (Lex.getStrVal() == \"DIArgList\") {\n      if (parseDIArgList(N, false, PFS))\n        return true;\n    } else if (parseSpecializedMDNode(N)) {\n      return true;\n    }\n    MD = N;\n    return false;\n  }\n\n  // ValueAsMetadata:\n  // <type> <value>\n  if (Lex.getKind() != lltok::exclaim)\n    return parseValueAsMetadata(MD, \"expected metadata operand\", PFS);\n\n  // '!'.\n  assert(Lex.getKind() == lltok::exclaim && \"Expected '!' here\");\n  Lex.Lex();\n\n  // MDString:\n  //   ::= '!' STRINGCONSTANT\n  if (Lex.getKind() == lltok::StringConstant) {\n    MDString *S;\n    if (parseMDString(S))\n      return true;\n    MD = S;\n    return false;\n  }\n\n  // MDNode:\n  // !{ ... }\n  // !7\n  MDNode *N;\n  if (parseMDNodeTail(N))\n    return true;\n  MD = N;\n  return false;\n}\n\n//===----------------------------------------------------------------------===//\n// Function Parsing.\n//===----------------------------------------------------------------------===//\n\nbool LLParser::convertValIDToValue(Type *Ty, ValID &ID, Value *&V,\n                                   PerFunctionState *PFS, bool IsCall) {\n  if (Ty->isFunctionTy())\n    return error(ID.Loc, \"functions are not values, refer to them as pointers\");\n\n  switch (ID.Kind) {\n  case ValID::t_LocalID:\n    if (!PFS)\n      return error(ID.Loc, \"invalid use of function-local name\");\n    V = PFS->getVal(ID.UIntVal, Ty, ID.Loc, IsCall);\n    return V == nullptr;\n  case ValID::t_LocalName:\n    if (!PFS)\n      return error(ID.Loc, \"invalid use of function-local name\");\n    V = PFS->getVal(ID.StrVal, Ty, ID.Loc, IsCall);\n    return V == nullptr;\n  case ValID::t_InlineAsm: {\n    if (!ID.FTy || !InlineAsm::Verify(ID.FTy, ID.StrVal2))\n      return error(ID.Loc, \"invalid type for inline asm constraint string\");\n    V = InlineAsm::get(ID.FTy, ID.StrVal, ID.StrVal2, ID.UIntVal & 1,\n                       (ID.UIntVal >> 1) & 1,\n                       (InlineAsm::AsmDialect(ID.UIntVal >> 2)));\n    return false;\n  }\n  case ValID::t_GlobalName:\n    V = getGlobalVal(ID.StrVal, Ty, ID.Loc, IsCall);\n    return V == nullptr;\n  case ValID::t_GlobalID:\n    V = getGlobalVal(ID.UIntVal, Ty, ID.Loc, IsCall);\n    return V == nullptr;\n  case ValID::t_APSInt:\n    if (!Ty->isIntegerTy())\n      return error(ID.Loc, \"integer constant must have integer type\");\n    ID.APSIntVal = ID.APSIntVal.extOrTrunc(Ty->getPrimitiveSizeInBits());\n    V = ConstantInt::get(Context, ID.APSIntVal);\n    return false;\n  case ValID::t_APFloat:\n    if (!Ty->isFloatingPointTy() ||\n        !ConstantFP::isValueValidForType(Ty, ID.APFloatVal))\n      return error(ID.Loc, \"floating point constant invalid for type\");\n\n    // The lexer has no type info, so builds all half, bfloat, float, and double\n    // FP constants as double.  Fix this here.  Long double does not need this.\n    if (&ID.APFloatVal.getSemantics() == &APFloat::IEEEdouble()) {\n      // Check for signaling before potentially converting and losing that info.\n      bool IsSNAN = ID.APFloatVal.isSignaling();\n      bool Ignored;\n      if (Ty->isHalfTy())\n        ID.APFloatVal.convert(APFloat::IEEEhalf(), APFloat::rmNearestTiesToEven,\n                              &Ignored);\n      else if (Ty->isBFloatTy())\n        ID.APFloatVal.convert(APFloat::BFloat(), APFloat::rmNearestTiesToEven,\n                              &Ignored);\n      else if (Ty->isFloatTy())\n        ID.APFloatVal.convert(APFloat::IEEEsingle(), APFloat::rmNearestTiesToEven,\n                              &Ignored);\n      if (IsSNAN) {\n        // The convert call above may quiet an SNaN, so manufacture another\n        // SNaN. The bitcast works because the payload (significand) parameter\n        // is truncated to fit.\n        APInt Payload = ID.APFloatVal.bitcastToAPInt();\n        ID.APFloatVal = APFloat::getSNaN(ID.APFloatVal.getSemantics(),\n                                         ID.APFloatVal.isNegative(), &Payload);\n      }\n    }\n    V = ConstantFP::get(Context, ID.APFloatVal);\n\n    if (V->getType() != Ty)\n      return error(ID.Loc, \"floating point constant does not have type '\" +\n                               getTypeString(Ty) + \"'\");\n\n    return false;\n  case ValID::t_Null:\n    if (!Ty->isPointerTy())\n      return error(ID.Loc, \"null must be a pointer type\");\n    V = ConstantPointerNull::get(cast<PointerType>(Ty));\n    return false;\n  case ValID::t_Undef:\n    // FIXME: LabelTy should not be a first-class type.\n    if (!Ty->isFirstClassType() || Ty->isLabelTy())\n      return error(ID.Loc, \"invalid type for undef constant\");\n    V = UndefValue::get(Ty);\n    return false;\n  case ValID::t_EmptyArray:\n    if (!Ty->isArrayTy() || cast<ArrayType>(Ty)->getNumElements() != 0)\n      return error(ID.Loc, \"invalid empty array initializer\");\n    V = UndefValue::get(Ty);\n    return false;\n  case ValID::t_Zero:\n    // FIXME: LabelTy should not be a first-class type.\n    if (!Ty->isFirstClassType() || Ty->isLabelTy())\n      return error(ID.Loc, \"invalid type for null constant\");\n    V = Constant::getNullValue(Ty);\n    return false;\n  case ValID::t_None:\n    if (!Ty->isTokenTy())\n      return error(ID.Loc, \"invalid type for none constant\");\n    V = Constant::getNullValue(Ty);\n    return false;\n  case ValID::t_Poison:\n    // FIXME: LabelTy should not be a first-class type.\n    if (!Ty->isFirstClassType() || Ty->isLabelTy())\n      return error(ID.Loc, \"invalid type for poison constant\");\n    V = PoisonValue::get(Ty);\n    return false;\n  case ValID::t_Constant:\n    if (ID.ConstantVal->getType() != Ty)\n      return error(ID.Loc, \"constant expression type mismatch\");\n    V = ID.ConstantVal;\n    return false;\n  case ValID::t_ConstantStruct:\n  case ValID::t_PackedConstantStruct:\n    if (StructType *ST = dyn_cast<StructType>(Ty)) {\n      if (ST->getNumElements() != ID.UIntVal)\n        return error(ID.Loc,\n                     \"initializer with struct type has wrong # elements\");\n      if (ST->isPacked() != (ID.Kind == ValID::t_PackedConstantStruct))\n        return error(ID.Loc, \"packed'ness of initializer and type don't match\");\n\n      // Verify that the elements are compatible with the structtype.\n      for (unsigned i = 0, e = ID.UIntVal; i != e; ++i)\n        if (ID.ConstantStructElts[i]->getType() != ST->getElementType(i))\n          return error(\n              ID.Loc,\n              \"element \" + Twine(i) +\n                  \" of struct initializer doesn't match struct element type\");\n\n      V = ConstantStruct::get(\n          ST, makeArrayRef(ID.ConstantStructElts.get(), ID.UIntVal));\n    } else\n      return error(ID.Loc, \"constant expression type mismatch\");\n    return false;\n  }\n  llvm_unreachable(\"Invalid ValID\");\n}\n\nbool LLParser::parseConstantValue(Type *Ty, Constant *&C) {\n  C = nullptr;\n  ValID ID;\n  auto Loc = Lex.getLoc();\n  if (parseValID(ID, /*PFS=*/nullptr))\n    return true;\n  switch (ID.Kind) {\n  case ValID::t_APSInt:\n  case ValID::t_APFloat:\n  case ValID::t_Undef:\n  case ValID::t_Constant:\n  case ValID::t_ConstantStruct:\n  case ValID::t_PackedConstantStruct: {\n    Value *V;\n    if (convertValIDToValue(Ty, ID, V, /*PFS=*/nullptr, /*IsCall=*/false))\n      return true;\n    assert(isa<Constant>(V) && \"Expected a constant value\");\n    C = cast<Constant>(V);\n    return false;\n  }\n  case ValID::t_Null:\n    C = Constant::getNullValue(Ty);\n    return false;\n  default:\n    return error(Loc, \"expected a constant value\");\n  }\n}\n\nbool LLParser::parseValue(Type *Ty, Value *&V, PerFunctionState *PFS) {\n  V = nullptr;\n  ValID ID;\n  return parseValID(ID, PFS) ||\n         convertValIDToValue(Ty, ID, V, PFS, /*IsCall=*/false);\n}\n\nbool LLParser::parseTypeAndValue(Value *&V, PerFunctionState *PFS) {\n  Type *Ty = nullptr;\n  return parseType(Ty) || parseValue(Ty, V, PFS);\n}\n\nbool LLParser::parseTypeAndBasicBlock(BasicBlock *&BB, LocTy &Loc,\n                                      PerFunctionState &PFS) {\n  Value *V;\n  Loc = Lex.getLoc();\n  if (parseTypeAndValue(V, PFS))\n    return true;\n  if (!isa<BasicBlock>(V))\n    return error(Loc, \"expected a basic block\");\n  BB = cast<BasicBlock>(V);\n  return false;\n}\n\n/// FunctionHeader\n///   ::= OptionalLinkage OptionalPreemptionSpecifier OptionalVisibility\n///       OptionalCallingConv OptRetAttrs OptUnnamedAddr Type GlobalName\n///       '(' ArgList ')' OptAddrSpace OptFuncAttrs OptSection OptionalAlign\n///       OptGC OptionalPrefix OptionalPrologue OptPersonalityFn\nbool LLParser::parseFunctionHeader(Function *&Fn, bool IsDefine) {\n  // parse the linkage.\n  LocTy LinkageLoc = Lex.getLoc();\n  unsigned Linkage;\n  unsigned Visibility;\n  unsigned DLLStorageClass;\n  bool DSOLocal;\n  AttrBuilder RetAttrs;\n  unsigned CC;\n  bool HasLinkage;\n  Type *RetType = nullptr;\n  LocTy RetTypeLoc = Lex.getLoc();\n  if (parseOptionalLinkage(Linkage, HasLinkage, Visibility, DLLStorageClass,\n                           DSOLocal) ||\n      parseOptionalCallingConv(CC) || parseOptionalReturnAttrs(RetAttrs) ||\n      parseType(RetType, RetTypeLoc, true /*void allowed*/))\n    return true;\n\n  // Verify that the linkage is ok.\n  switch ((GlobalValue::LinkageTypes)Linkage) {\n  case GlobalValue::ExternalLinkage:\n    break; // always ok.\n  case GlobalValue::ExternalWeakLinkage:\n    if (IsDefine)\n      return error(LinkageLoc, \"invalid linkage for function definition\");\n    break;\n  case GlobalValue::PrivateLinkage:\n  case GlobalValue::InternalLinkage:\n  case GlobalValue::AvailableExternallyLinkage:\n  case GlobalValue::LinkOnceAnyLinkage:\n  case GlobalValue::LinkOnceODRLinkage:\n  case GlobalValue::WeakAnyLinkage:\n  case GlobalValue::WeakODRLinkage:\n    if (!IsDefine)\n      return error(LinkageLoc, \"invalid linkage for function declaration\");\n    break;\n  case GlobalValue::AppendingLinkage:\n  case GlobalValue::CommonLinkage:\n    return error(LinkageLoc, \"invalid function linkage type\");\n  }\n\n  if (!isValidVisibilityForLinkage(Visibility, Linkage))\n    return error(LinkageLoc,\n                 \"symbol with local linkage must have default visibility\");\n\n  if (!FunctionType::isValidReturnType(RetType))\n    return error(RetTypeLoc, \"invalid function return type\");\n\n  LocTy NameLoc = Lex.getLoc();\n\n  std::string FunctionName;\n  if (Lex.getKind() == lltok::GlobalVar) {\n    FunctionName = Lex.getStrVal();\n  } else if (Lex.getKind() == lltok::GlobalID) {     // @42 is ok.\n    unsigned NameID = Lex.getUIntVal();\n\n    if (NameID != NumberedVals.size())\n      return tokError(\"function expected to be numbered '%\" +\n                      Twine(NumberedVals.size()) + \"'\");\n  } else {\n    return tokError(\"expected function name\");\n  }\n\n  Lex.Lex();\n\n  if (Lex.getKind() != lltok::lparen)\n    return tokError(\"expected '(' in function argument list\");\n\n  SmallVector<ArgInfo, 8> ArgList;\n  bool IsVarArg;\n  AttrBuilder FuncAttrs;\n  std::vector<unsigned> FwdRefAttrGrps;\n  LocTy BuiltinLoc;\n  std::string Section;\n  std::string Partition;\n  MaybeAlign Alignment;\n  std::string GC;\n  GlobalValue::UnnamedAddr UnnamedAddr = GlobalValue::UnnamedAddr::None;\n  unsigned AddrSpace = 0;\n  Constant *Prefix = nullptr;\n  Constant *Prologue = nullptr;\n  Constant *PersonalityFn = nullptr;\n  Comdat *C;\n\n  if (parseArgumentList(ArgList, IsVarArg) ||\n      parseOptionalUnnamedAddr(UnnamedAddr) ||\n      parseOptionalProgramAddrSpace(AddrSpace) ||\n      parseFnAttributeValuePairs(FuncAttrs, FwdRefAttrGrps, false,\n                                 BuiltinLoc) ||\n      (EatIfPresent(lltok::kw_section) && parseStringConstant(Section)) ||\n      (EatIfPresent(lltok::kw_partition) && parseStringConstant(Partition)) ||\n      parseOptionalComdat(FunctionName, C) ||\n      parseOptionalAlignment(Alignment) ||\n      (EatIfPresent(lltok::kw_gc) && parseStringConstant(GC)) ||\n      (EatIfPresent(lltok::kw_prefix) && parseGlobalTypeAndValue(Prefix)) ||\n      (EatIfPresent(lltok::kw_prologue) && parseGlobalTypeAndValue(Prologue)) ||\n      (EatIfPresent(lltok::kw_personality) &&\n       parseGlobalTypeAndValue(PersonalityFn)))\n    return true;\n\n  if (FuncAttrs.contains(Attribute::Builtin))\n    return error(BuiltinLoc, \"'builtin' attribute not valid on function\");\n\n  // If the alignment was parsed as an attribute, move to the alignment field.\n  if (FuncAttrs.hasAlignmentAttr()) {\n    Alignment = FuncAttrs.getAlignment();\n    FuncAttrs.removeAttribute(Attribute::Alignment);\n  }\n\n  // Okay, if we got here, the function is syntactically valid.  Convert types\n  // and do semantic checks.\n  std::vector<Type*> ParamTypeList;\n  SmallVector<AttributeSet, 8> Attrs;\n\n  for (unsigned i = 0, e = ArgList.size(); i != e; ++i) {\n    ParamTypeList.push_back(ArgList[i].Ty);\n    Attrs.push_back(ArgList[i].Attrs);\n  }\n\n  AttributeList PAL =\n      AttributeList::get(Context, AttributeSet::get(Context, FuncAttrs),\n                         AttributeSet::get(Context, RetAttrs), Attrs);\n\n  if (PAL.hasAttribute(1, Attribute::StructRet) && !RetType->isVoidTy())\n    return error(RetTypeLoc, \"functions with 'sret' argument must return void\");\n\n  FunctionType *FT = FunctionType::get(RetType, ParamTypeList, IsVarArg);\n  PointerType *PFT = PointerType::get(FT, AddrSpace);\n\n  Fn = nullptr;\n  if (!FunctionName.empty()) {\n    // If this was a definition of a forward reference, remove the definition\n    // from the forward reference table and fill in the forward ref.\n    auto FRVI = ForwardRefVals.find(FunctionName);\n    if (FRVI != ForwardRefVals.end()) {\n      Fn = M->getFunction(FunctionName);\n      if (!Fn)\n        return error(FRVI->second.second, \"invalid forward reference to \"\n                                          \"function as global value!\");\n      if (Fn->getType() != PFT)\n        return error(FRVI->second.second,\n                     \"invalid forward reference to \"\n                     \"function '\" +\n                         FunctionName +\n                         \"' with wrong type: \"\n                         \"expected '\" +\n                         getTypeString(PFT) + \"' but was '\" +\n                         getTypeString(Fn->getType()) + \"'\");\n      ForwardRefVals.erase(FRVI);\n    } else if ((Fn = M->getFunction(FunctionName))) {\n      // Reject redefinitions.\n      return error(NameLoc,\n                   \"invalid redefinition of function '\" + FunctionName + \"'\");\n    } else if (M->getNamedValue(FunctionName)) {\n      return error(NameLoc, \"redefinition of function '@\" + FunctionName + \"'\");\n    }\n\n  } else {\n    // If this is a definition of a forward referenced function, make sure the\n    // types agree.\n    auto I = ForwardRefValIDs.find(NumberedVals.size());\n    if (I != ForwardRefValIDs.end()) {\n      Fn = cast<Function>(I->second.first);\n      if (Fn->getType() != PFT)\n        return error(NameLoc, \"type of definition and forward reference of '@\" +\n                                  Twine(NumberedVals.size()) +\n                                  \"' disagree: \"\n                                  \"expected '\" +\n                                  getTypeString(PFT) + \"' but was '\" +\n                                  getTypeString(Fn->getType()) + \"'\");\n      ForwardRefValIDs.erase(I);\n    }\n  }\n\n  if (!Fn)\n    Fn = Function::Create(FT, GlobalValue::ExternalLinkage, AddrSpace,\n                          FunctionName, M);\n  else // Move the forward-reference to the correct spot in the module.\n    M->getFunctionList().splice(M->end(), M->getFunctionList(), Fn);\n\n  assert(Fn->getAddressSpace() == AddrSpace && \"Created function in wrong AS\");\n\n  if (FunctionName.empty())\n    NumberedVals.push_back(Fn);\n\n  Fn->setLinkage((GlobalValue::LinkageTypes)Linkage);\n  maybeSetDSOLocal(DSOLocal, *Fn);\n  Fn->setVisibility((GlobalValue::VisibilityTypes)Visibility);\n  Fn->setDLLStorageClass((GlobalValue::DLLStorageClassTypes)DLLStorageClass);\n  Fn->setCallingConv(CC);\n  Fn->setAttributes(PAL);\n  Fn->setUnnamedAddr(UnnamedAddr);\n  Fn->setAlignment(MaybeAlign(Alignment));\n  Fn->setSection(Section);\n  Fn->setPartition(Partition);\n  Fn->setComdat(C);\n  Fn->setPersonalityFn(PersonalityFn);\n  if (!GC.empty()) Fn->setGC(GC);\n  Fn->setPrefixData(Prefix);\n  Fn->setPrologueData(Prologue);\n  ForwardRefAttrGroups[Fn] = FwdRefAttrGrps;\n\n  // Add all of the arguments we parsed to the function.\n  Function::arg_iterator ArgIt = Fn->arg_begin();\n  for (unsigned i = 0, e = ArgList.size(); i != e; ++i, ++ArgIt) {\n    // If the argument has a name, insert it into the argument symbol table.\n    if (ArgList[i].Name.empty()) continue;\n\n    // Set the name, if it conflicted, it will be auto-renamed.\n    ArgIt->setName(ArgList[i].Name);\n\n    if (ArgIt->getName() != ArgList[i].Name)\n      return error(ArgList[i].Loc,\n                   \"redefinition of argument '%\" + ArgList[i].Name + \"'\");\n  }\n\n  if (IsDefine)\n    return false;\n\n  // Check the declaration has no block address forward references.\n  ValID ID;\n  if (FunctionName.empty()) {\n    ID.Kind = ValID::t_GlobalID;\n    ID.UIntVal = NumberedVals.size() - 1;\n  } else {\n    ID.Kind = ValID::t_GlobalName;\n    ID.StrVal = FunctionName;\n  }\n  auto Blocks = ForwardRefBlockAddresses.find(ID);\n  if (Blocks != ForwardRefBlockAddresses.end())\n    return error(Blocks->first.Loc,\n                 \"cannot take blockaddress inside a declaration\");\n  return false;\n}\n\nbool LLParser::PerFunctionState::resolveForwardRefBlockAddresses() {\n  ValID ID;\n  if (FunctionNumber == -1) {\n    ID.Kind = ValID::t_GlobalName;\n    ID.StrVal = std::string(F.getName());\n  } else {\n    ID.Kind = ValID::t_GlobalID;\n    ID.UIntVal = FunctionNumber;\n  }\n\n  auto Blocks = P.ForwardRefBlockAddresses.find(ID);\n  if (Blocks == P.ForwardRefBlockAddresses.end())\n    return false;\n\n  for (const auto &I : Blocks->second) {\n    const ValID &BBID = I.first;\n    GlobalValue *GV = I.second;\n\n    assert((BBID.Kind == ValID::t_LocalID || BBID.Kind == ValID::t_LocalName) &&\n           \"Expected local id or name\");\n    BasicBlock *BB;\n    if (BBID.Kind == ValID::t_LocalName)\n      BB = getBB(BBID.StrVal, BBID.Loc);\n    else\n      BB = getBB(BBID.UIntVal, BBID.Loc);\n    if (!BB)\n      return P.error(BBID.Loc, \"referenced value is not a basic block\");\n\n    GV->replaceAllUsesWith(BlockAddress::get(&F, BB));\n    GV->eraseFromParent();\n  }\n\n  P.ForwardRefBlockAddresses.erase(Blocks);\n  return false;\n}\n\n/// parseFunctionBody\n///   ::= '{' BasicBlock+ UseListOrderDirective* '}'\nbool LLParser::parseFunctionBody(Function &Fn) {\n  if (Lex.getKind() != lltok::lbrace)\n    return tokError(\"expected '{' in function body\");\n  Lex.Lex();  // eat the {.\n\n  int FunctionNumber = -1;\n  if (!Fn.hasName()) FunctionNumber = NumberedVals.size()-1;\n\n  PerFunctionState PFS(*this, Fn, FunctionNumber);\n\n  // Resolve block addresses and allow basic blocks to be forward-declared\n  // within this function.\n  if (PFS.resolveForwardRefBlockAddresses())\n    return true;\n  SaveAndRestore<PerFunctionState *> ScopeExit(BlockAddressPFS, &PFS);\n\n  // We need at least one basic block.\n  if (Lex.getKind() == lltok::rbrace || Lex.getKind() == lltok::kw_uselistorder)\n    return tokError(\"function body requires at least one basic block\");\n\n  while (Lex.getKind() != lltok::rbrace &&\n         Lex.getKind() != lltok::kw_uselistorder)\n    if (parseBasicBlock(PFS))\n      return true;\n\n  while (Lex.getKind() != lltok::rbrace)\n    if (parseUseListOrder(&PFS))\n      return true;\n\n  // Eat the }.\n  Lex.Lex();\n\n  // Verify function is ok.\n  return PFS.finishFunction();\n}\n\n/// parseBasicBlock\n///   ::= (LabelStr|LabelID)? Instruction*\nbool LLParser::parseBasicBlock(PerFunctionState &PFS) {\n  // If this basic block starts out with a name, remember it.\n  std::string Name;\n  int NameID = -1;\n  LocTy NameLoc = Lex.getLoc();\n  if (Lex.getKind() == lltok::LabelStr) {\n    Name = Lex.getStrVal();\n    Lex.Lex();\n  } else if (Lex.getKind() == lltok::LabelID) {\n    NameID = Lex.getUIntVal();\n    Lex.Lex();\n  }\n\n  BasicBlock *BB = PFS.defineBB(Name, NameID, NameLoc);\n  if (!BB)\n    return true;\n\n  std::string NameStr;\n\n  // parse the instructions in this block until we get a terminator.\n  Instruction *Inst;\n  do {\n    // This instruction may have three possibilities for a name: a) none\n    // specified, b) name specified \"%foo =\", c) number specified: \"%4 =\".\n    LocTy NameLoc = Lex.getLoc();\n    int NameID = -1;\n    NameStr = \"\";\n\n    if (Lex.getKind() == lltok::LocalVarID) {\n      NameID = Lex.getUIntVal();\n      Lex.Lex();\n      if (parseToken(lltok::equal, \"expected '=' after instruction id\"))\n        return true;\n    } else if (Lex.getKind() == lltok::LocalVar) {\n      NameStr = Lex.getStrVal();\n      Lex.Lex();\n      if (parseToken(lltok::equal, \"expected '=' after instruction name\"))\n        return true;\n    }\n\n    switch (parseInstruction(Inst, BB, PFS)) {\n    default:\n      llvm_unreachable(\"Unknown parseInstruction result!\");\n    case InstError: return true;\n    case InstNormal:\n      BB->getInstList().push_back(Inst);\n\n      // With a normal result, we check to see if the instruction is followed by\n      // a comma and metadata.\n      if (EatIfPresent(lltok::comma))\n        if (parseInstructionMetadata(*Inst))\n          return true;\n      break;\n    case InstExtraComma:\n      BB->getInstList().push_back(Inst);\n\n      // If the instruction parser ate an extra comma at the end of it, it\n      // *must* be followed by metadata.\n      if (parseInstructionMetadata(*Inst))\n        return true;\n      break;\n    }\n\n    // Set the name on the instruction.\n    if (PFS.setInstName(NameID, NameStr, NameLoc, Inst))\n      return true;\n  } while (!Inst->isTerminator());\n\n  return false;\n}\n\n//===----------------------------------------------------------------------===//\n// Instruction Parsing.\n//===----------------------------------------------------------------------===//\n\n/// parseInstruction - parse one of the many different instructions.\n///\nint LLParser::parseInstruction(Instruction *&Inst, BasicBlock *BB,\n                               PerFunctionState &PFS) {\n  lltok::Kind Token = Lex.getKind();\n  if (Token == lltok::Eof)\n    return tokError(\"found end of file when expecting more instructions\");\n  LocTy Loc = Lex.getLoc();\n  unsigned KeywordVal = Lex.getUIntVal();\n  Lex.Lex();  // Eat the keyword.\n\n  switch (Token) {\n  default:\n    return error(Loc, \"expected instruction opcode\");\n  // Terminator Instructions.\n  case lltok::kw_unreachable: Inst = new UnreachableInst(Context); return false;\n  case lltok::kw_ret:\n    return parseRet(Inst, BB, PFS);\n  case lltok::kw_br:\n    return parseBr(Inst, PFS);\n  case lltok::kw_switch:\n    return parseSwitch(Inst, PFS);\n  case lltok::kw_indirectbr:\n    return parseIndirectBr(Inst, PFS);\n  case lltok::kw_invoke:\n    return parseInvoke(Inst, PFS);\n  case lltok::kw_resume:\n    return parseResume(Inst, PFS);\n  case lltok::kw_cleanupret:\n    return parseCleanupRet(Inst, PFS);\n  case lltok::kw_catchret:\n    return parseCatchRet(Inst, PFS);\n  case lltok::kw_catchswitch:\n    return parseCatchSwitch(Inst, PFS);\n  case lltok::kw_catchpad:\n    return parseCatchPad(Inst, PFS);\n  case lltok::kw_cleanuppad:\n    return parseCleanupPad(Inst, PFS);\n  case lltok::kw_callbr:\n    return parseCallBr(Inst, PFS);\n  // Unary Operators.\n  case lltok::kw_fneg: {\n    FastMathFlags FMF = EatFastMathFlagsIfPresent();\n    int Res = parseUnaryOp(Inst, PFS, KeywordVal, /*IsFP*/ true);\n    if (Res != 0)\n      return Res;\n    if (FMF.any())\n      Inst->setFastMathFlags(FMF);\n    return false;\n  }\n  // Binary Operators.\n  case lltok::kw_add:\n  case lltok::kw_sub:\n  case lltok::kw_mul:\n  case lltok::kw_shl: {\n    bool NUW = EatIfPresent(lltok::kw_nuw);\n    bool NSW = EatIfPresent(lltok::kw_nsw);\n    if (!NUW) NUW = EatIfPresent(lltok::kw_nuw);\n\n    if (parseArithmetic(Inst, PFS, KeywordVal, /*IsFP*/ false))\n      return true;\n\n    if (NUW) cast<BinaryOperator>(Inst)->setHasNoUnsignedWrap(true);\n    if (NSW) cast<BinaryOperator>(Inst)->setHasNoSignedWrap(true);\n    return false;\n  }\n  case lltok::kw_fadd:\n  case lltok::kw_fsub:\n  case lltok::kw_fmul:\n  case lltok::kw_fdiv:\n  case lltok::kw_frem: {\n    FastMathFlags FMF = EatFastMathFlagsIfPresent();\n    int Res = parseArithmetic(Inst, PFS, KeywordVal, /*IsFP*/ true);\n    if (Res != 0)\n      return Res;\n    if (FMF.any())\n      Inst->setFastMathFlags(FMF);\n    return 0;\n  }\n\n  case lltok::kw_sdiv:\n  case lltok::kw_udiv:\n  case lltok::kw_lshr:\n  case lltok::kw_ashr: {\n    bool Exact = EatIfPresent(lltok::kw_exact);\n\n    if (parseArithmetic(Inst, PFS, KeywordVal, /*IsFP*/ false))\n      return true;\n    if (Exact) cast<BinaryOperator>(Inst)->setIsExact(true);\n    return false;\n  }\n\n  case lltok::kw_urem:\n  case lltok::kw_srem:\n    return parseArithmetic(Inst, PFS, KeywordVal,\n                           /*IsFP*/ false);\n  case lltok::kw_and:\n  case lltok::kw_or:\n  case lltok::kw_xor:\n    return parseLogical(Inst, PFS, KeywordVal);\n  case lltok::kw_icmp:\n    return parseCompare(Inst, PFS, KeywordVal);\n  case lltok::kw_fcmp: {\n    FastMathFlags FMF = EatFastMathFlagsIfPresent();\n    int Res = parseCompare(Inst, PFS, KeywordVal);\n    if (Res != 0)\n      return Res;\n    if (FMF.any())\n      Inst->setFastMathFlags(FMF);\n    return 0;\n  }\n\n  // Casts.\n  case lltok::kw_trunc:\n  case lltok::kw_zext:\n  case lltok::kw_sext:\n  case lltok::kw_fptrunc:\n  case lltok::kw_fpext:\n  case lltok::kw_bitcast:\n  case lltok::kw_addrspacecast:\n  case lltok::kw_uitofp:\n  case lltok::kw_sitofp:\n  case lltok::kw_fptoui:\n  case lltok::kw_fptosi:\n  case lltok::kw_inttoptr:\n  case lltok::kw_ptrtoint:\n    return parseCast(Inst, PFS, KeywordVal);\n  // Other.\n  case lltok::kw_select: {\n    FastMathFlags FMF = EatFastMathFlagsIfPresent();\n    int Res = parseSelect(Inst, PFS);\n    if (Res != 0)\n      return Res;\n    if (FMF.any()) {\n      if (!isa<FPMathOperator>(Inst))\n        return error(Loc, \"fast-math-flags specified for select without \"\n                          \"floating-point scalar or vector return type\");\n      Inst->setFastMathFlags(FMF);\n    }\n    return 0;\n  }\n  case lltok::kw_va_arg:\n    return parseVAArg(Inst, PFS);\n  case lltok::kw_extractelement:\n    return parseExtractElement(Inst, PFS);\n  case lltok::kw_insertelement:\n    return parseInsertElement(Inst, PFS);\n  case lltok::kw_shufflevector:\n    return parseShuffleVector(Inst, PFS);\n  case lltok::kw_phi: {\n    FastMathFlags FMF = EatFastMathFlagsIfPresent();\n    int Res = parsePHI(Inst, PFS);\n    if (Res != 0)\n      return Res;\n    if (FMF.any()) {\n      if (!isa<FPMathOperator>(Inst))\n        return error(Loc, \"fast-math-flags specified for phi without \"\n                          \"floating-point scalar or vector return type\");\n      Inst->setFastMathFlags(FMF);\n    }\n    return 0;\n  }\n  case lltok::kw_landingpad:\n    return parseLandingPad(Inst, PFS);\n  case lltok::kw_freeze:\n    return parseFreeze(Inst, PFS);\n  // Call.\n  case lltok::kw_call:\n    return parseCall(Inst, PFS, CallInst::TCK_None);\n  case lltok::kw_tail:\n    return parseCall(Inst, PFS, CallInst::TCK_Tail);\n  case lltok::kw_musttail:\n    return parseCall(Inst, PFS, CallInst::TCK_MustTail);\n  case lltok::kw_notail:\n    return parseCall(Inst, PFS, CallInst::TCK_NoTail);\n  // Memory.\n  case lltok::kw_alloca:\n    return parseAlloc(Inst, PFS);\n  case lltok::kw_load:\n    return parseLoad(Inst, PFS);\n  case lltok::kw_store:\n    return parseStore(Inst, PFS);\n  case lltok::kw_cmpxchg:\n    return parseCmpXchg(Inst, PFS);\n  case lltok::kw_atomicrmw:\n    return parseAtomicRMW(Inst, PFS);\n  case lltok::kw_fence:\n    return parseFence(Inst, PFS);\n  case lltok::kw_getelementptr:\n    return parseGetElementPtr(Inst, PFS);\n  case lltok::kw_extractvalue:\n    return parseExtractValue(Inst, PFS);\n  case lltok::kw_insertvalue:\n    return parseInsertValue(Inst, PFS);\n  }\n}\n\n/// parseCmpPredicate - parse an integer or fp predicate, based on Kind.\nbool LLParser::parseCmpPredicate(unsigned &P, unsigned Opc) {\n  if (Opc == Instruction::FCmp) {\n    switch (Lex.getKind()) {\n    default:\n      return tokError(\"expected fcmp predicate (e.g. 'oeq')\");\n    case lltok::kw_oeq: P = CmpInst::FCMP_OEQ; break;\n    case lltok::kw_one: P = CmpInst::FCMP_ONE; break;\n    case lltok::kw_olt: P = CmpInst::FCMP_OLT; break;\n    case lltok::kw_ogt: P = CmpInst::FCMP_OGT; break;\n    case lltok::kw_ole: P = CmpInst::FCMP_OLE; break;\n    case lltok::kw_oge: P = CmpInst::FCMP_OGE; break;\n    case lltok::kw_ord: P = CmpInst::FCMP_ORD; break;\n    case lltok::kw_uno: P = CmpInst::FCMP_UNO; break;\n    case lltok::kw_ueq: P = CmpInst::FCMP_UEQ; break;\n    case lltok::kw_une: P = CmpInst::FCMP_UNE; break;\n    case lltok::kw_ult: P = CmpInst::FCMP_ULT; break;\n    case lltok::kw_ugt: P = CmpInst::FCMP_UGT; break;\n    case lltok::kw_ule: P = CmpInst::FCMP_ULE; break;\n    case lltok::kw_uge: P = CmpInst::FCMP_UGE; break;\n    case lltok::kw_true: P = CmpInst::FCMP_TRUE; break;\n    case lltok::kw_false: P = CmpInst::FCMP_FALSE; break;\n    }\n  } else {\n    switch (Lex.getKind()) {\n    default:\n      return tokError(\"expected icmp predicate (e.g. 'eq')\");\n    case lltok::kw_eq:  P = CmpInst::ICMP_EQ; break;\n    case lltok::kw_ne:  P = CmpInst::ICMP_NE; break;\n    case lltok::kw_slt: P = CmpInst::ICMP_SLT; break;\n    case lltok::kw_sgt: P = CmpInst::ICMP_SGT; break;\n    case lltok::kw_sle: P = CmpInst::ICMP_SLE; break;\n    case lltok::kw_sge: P = CmpInst::ICMP_SGE; break;\n    case lltok::kw_ult: P = CmpInst::ICMP_ULT; break;\n    case lltok::kw_ugt: P = CmpInst::ICMP_UGT; break;\n    case lltok::kw_ule: P = CmpInst::ICMP_ULE; break;\n    case lltok::kw_uge: P = CmpInst::ICMP_UGE; break;\n    }\n  }\n  Lex.Lex();\n  return false;\n}\n\n//===----------------------------------------------------------------------===//\n// Terminator Instructions.\n//===----------------------------------------------------------------------===//\n\n/// parseRet - parse a return instruction.\n///   ::= 'ret' void (',' !dbg, !1)*\n///   ::= 'ret' TypeAndValue (',' !dbg, !1)*\nbool LLParser::parseRet(Instruction *&Inst, BasicBlock *BB,\n                        PerFunctionState &PFS) {\n  SMLoc TypeLoc = Lex.getLoc();\n  Type *Ty = nullptr;\n  if (parseType(Ty, true /*void allowed*/))\n    return true;\n\n  Type *ResType = PFS.getFunction().getReturnType();\n\n  if (Ty->isVoidTy()) {\n    if (!ResType->isVoidTy())\n      return error(TypeLoc, \"value doesn't match function result type '\" +\n                                getTypeString(ResType) + \"'\");\n\n    Inst = ReturnInst::Create(Context);\n    return false;\n  }\n\n  Value *RV;\n  if (parseValue(Ty, RV, PFS))\n    return true;\n\n  if (ResType != RV->getType())\n    return error(TypeLoc, \"value doesn't match function result type '\" +\n                              getTypeString(ResType) + \"'\");\n\n  Inst = ReturnInst::Create(Context, RV);\n  return false;\n}\n\n/// parseBr\n///   ::= 'br' TypeAndValue\n///   ::= 'br' TypeAndValue ',' TypeAndValue ',' TypeAndValue\nbool LLParser::parseBr(Instruction *&Inst, PerFunctionState &PFS) {\n  LocTy Loc, Loc2;\n  Value *Op0;\n  BasicBlock *Op1, *Op2;\n  if (parseTypeAndValue(Op0, Loc, PFS))\n    return true;\n\n  if (BasicBlock *BB = dyn_cast<BasicBlock>(Op0)) {\n    Inst = BranchInst::Create(BB);\n    return false;\n  }\n\n  if (Op0->getType() != Type::getInt1Ty(Context))\n    return error(Loc, \"branch condition must have 'i1' type\");\n\n  if (parseToken(lltok::comma, \"expected ',' after branch condition\") ||\n      parseTypeAndBasicBlock(Op1, Loc, PFS) ||\n      parseToken(lltok::comma, \"expected ',' after true destination\") ||\n      parseTypeAndBasicBlock(Op2, Loc2, PFS))\n    return true;\n\n  Inst = BranchInst::Create(Op1, Op2, Op0);\n  return false;\n}\n\n/// parseSwitch\n///  Instruction\n///    ::= 'switch' TypeAndValue ',' TypeAndValue '[' JumpTable ']'\n///  JumpTable\n///    ::= (TypeAndValue ',' TypeAndValue)*\nbool LLParser::parseSwitch(Instruction *&Inst, PerFunctionState &PFS) {\n  LocTy CondLoc, BBLoc;\n  Value *Cond;\n  BasicBlock *DefaultBB;\n  if (parseTypeAndValue(Cond, CondLoc, PFS) ||\n      parseToken(lltok::comma, \"expected ',' after switch condition\") ||\n      parseTypeAndBasicBlock(DefaultBB, BBLoc, PFS) ||\n      parseToken(lltok::lsquare, \"expected '[' with switch table\"))\n    return true;\n\n  if (!Cond->getType()->isIntegerTy())\n    return error(CondLoc, \"switch condition must have integer type\");\n\n  // parse the jump table pairs.\n  SmallPtrSet<Value*, 32> SeenCases;\n  SmallVector<std::pair<ConstantInt*, BasicBlock*>, 32> Table;\n  while (Lex.getKind() != lltok::rsquare) {\n    Value *Constant;\n    BasicBlock *DestBB;\n\n    if (parseTypeAndValue(Constant, CondLoc, PFS) ||\n        parseToken(lltok::comma, \"expected ',' after case value\") ||\n        parseTypeAndBasicBlock(DestBB, PFS))\n      return true;\n\n    if (!SeenCases.insert(Constant).second)\n      return error(CondLoc, \"duplicate case value in switch\");\n    if (!isa<ConstantInt>(Constant))\n      return error(CondLoc, \"case value is not a constant integer\");\n\n    Table.push_back(std::make_pair(cast<ConstantInt>(Constant), DestBB));\n  }\n\n  Lex.Lex();  // Eat the ']'.\n\n  SwitchInst *SI = SwitchInst::Create(Cond, DefaultBB, Table.size());\n  for (unsigned i = 0, e = Table.size(); i != e; ++i)\n    SI->addCase(Table[i].first, Table[i].second);\n  Inst = SI;\n  return false;\n}\n\n/// parseIndirectBr\n///  Instruction\n///    ::= 'indirectbr' TypeAndValue ',' '[' LabelList ']'\nbool LLParser::parseIndirectBr(Instruction *&Inst, PerFunctionState &PFS) {\n  LocTy AddrLoc;\n  Value *Address;\n  if (parseTypeAndValue(Address, AddrLoc, PFS) ||\n      parseToken(lltok::comma, \"expected ',' after indirectbr address\") ||\n      parseToken(lltok::lsquare, \"expected '[' with indirectbr\"))\n    return true;\n\n  if (!Address->getType()->isPointerTy())\n    return error(AddrLoc, \"indirectbr address must have pointer type\");\n\n  // parse the destination list.\n  SmallVector<BasicBlock*, 16> DestList;\n\n  if (Lex.getKind() != lltok::rsquare) {\n    BasicBlock *DestBB;\n    if (parseTypeAndBasicBlock(DestBB, PFS))\n      return true;\n    DestList.push_back(DestBB);\n\n    while (EatIfPresent(lltok::comma)) {\n      if (parseTypeAndBasicBlock(DestBB, PFS))\n        return true;\n      DestList.push_back(DestBB);\n    }\n  }\n\n  if (parseToken(lltok::rsquare, \"expected ']' at end of block list\"))\n    return true;\n\n  IndirectBrInst *IBI = IndirectBrInst::Create(Address, DestList.size());\n  for (unsigned i = 0, e = DestList.size(); i != e; ++i)\n    IBI->addDestination(DestList[i]);\n  Inst = IBI;\n  return false;\n}\n\n/// parseInvoke\n///   ::= 'invoke' OptionalCallingConv OptionalAttrs Type Value ParamList\n///       OptionalAttrs 'to' TypeAndValue 'unwind' TypeAndValue\nbool LLParser::parseInvoke(Instruction *&Inst, PerFunctionState &PFS) {\n  LocTy CallLoc = Lex.getLoc();\n  AttrBuilder RetAttrs, FnAttrs;\n  std::vector<unsigned> FwdRefAttrGrps;\n  LocTy NoBuiltinLoc;\n  unsigned CC;\n  unsigned InvokeAddrSpace;\n  Type *RetType = nullptr;\n  LocTy RetTypeLoc;\n  ValID CalleeID;\n  SmallVector<ParamInfo, 16> ArgList;\n  SmallVector<OperandBundleDef, 2> BundleList;\n\n  BasicBlock *NormalBB, *UnwindBB;\n  if (parseOptionalCallingConv(CC) || parseOptionalReturnAttrs(RetAttrs) ||\n      parseOptionalProgramAddrSpace(InvokeAddrSpace) ||\n      parseType(RetType, RetTypeLoc, true /*void allowed*/) ||\n      parseValID(CalleeID) || parseParameterList(ArgList, PFS) ||\n      parseFnAttributeValuePairs(FnAttrs, FwdRefAttrGrps, false,\n                                 NoBuiltinLoc) ||\n      parseOptionalOperandBundles(BundleList, PFS) ||\n      parseToken(lltok::kw_to, \"expected 'to' in invoke\") ||\n      parseTypeAndBasicBlock(NormalBB, PFS) ||\n      parseToken(lltok::kw_unwind, \"expected 'unwind' in invoke\") ||\n      parseTypeAndBasicBlock(UnwindBB, PFS))\n    return true;\n\n  // If RetType is a non-function pointer type, then this is the short syntax\n  // for the call, which means that RetType is just the return type.  Infer the\n  // rest of the function argument types from the arguments that are present.\n  FunctionType *Ty = dyn_cast<FunctionType>(RetType);\n  if (!Ty) {\n    // Pull out the types of all of the arguments...\n    std::vector<Type*> ParamTypes;\n    for (unsigned i = 0, e = ArgList.size(); i != e; ++i)\n      ParamTypes.push_back(ArgList[i].V->getType());\n\n    if (!FunctionType::isValidReturnType(RetType))\n      return error(RetTypeLoc, \"Invalid result type for LLVM function\");\n\n    Ty = FunctionType::get(RetType, ParamTypes, false);\n  }\n\n  CalleeID.FTy = Ty;\n\n  // Look up the callee.\n  Value *Callee;\n  if (convertValIDToValue(PointerType::get(Ty, InvokeAddrSpace), CalleeID,\n                          Callee, &PFS, /*IsCall=*/true))\n    return true;\n\n  // Set up the Attribute for the function.\n  SmallVector<Value *, 8> Args;\n  SmallVector<AttributeSet, 8> ArgAttrs;\n\n  // Loop through FunctionType's arguments and ensure they are specified\n  // correctly.  Also, gather any parameter attributes.\n  FunctionType::param_iterator I = Ty->param_begin();\n  FunctionType::param_iterator E = Ty->param_end();\n  for (unsigned i = 0, e = ArgList.size(); i != e; ++i) {\n    Type *ExpectedTy = nullptr;\n    if (I != E) {\n      ExpectedTy = *I++;\n    } else if (!Ty->isVarArg()) {\n      return error(ArgList[i].Loc, \"too many arguments specified\");\n    }\n\n    if (ExpectedTy && ExpectedTy != ArgList[i].V->getType())\n      return error(ArgList[i].Loc, \"argument is not of expected type '\" +\n                                       getTypeString(ExpectedTy) + \"'\");\n    Args.push_back(ArgList[i].V);\n    ArgAttrs.push_back(ArgList[i].Attrs);\n  }\n\n  if (I != E)\n    return error(CallLoc, \"not enough parameters specified for call\");\n\n  if (FnAttrs.hasAlignmentAttr())\n    return error(CallLoc, \"invoke instructions may not have an alignment\");\n\n  // Finish off the Attribute and check them\n  AttributeList PAL =\n      AttributeList::get(Context, AttributeSet::get(Context, FnAttrs),\n                         AttributeSet::get(Context, RetAttrs), ArgAttrs);\n\n  InvokeInst *II =\n      InvokeInst::Create(Ty, Callee, NormalBB, UnwindBB, Args, BundleList);\n  II->setCallingConv(CC);\n  II->setAttributes(PAL);\n  ForwardRefAttrGroups[II] = FwdRefAttrGrps;\n  Inst = II;\n  return false;\n}\n\n/// parseResume\n///   ::= 'resume' TypeAndValue\nbool LLParser::parseResume(Instruction *&Inst, PerFunctionState &PFS) {\n  Value *Exn; LocTy ExnLoc;\n  if (parseTypeAndValue(Exn, ExnLoc, PFS))\n    return true;\n\n  ResumeInst *RI = ResumeInst::Create(Exn);\n  Inst = RI;\n  return false;\n}\n\nbool LLParser::parseExceptionArgs(SmallVectorImpl<Value *> &Args,\n                                  PerFunctionState &PFS) {\n  if (parseToken(lltok::lsquare, \"expected '[' in catchpad/cleanuppad\"))\n    return true;\n\n  while (Lex.getKind() != lltok::rsquare) {\n    // If this isn't the first argument, we need a comma.\n    if (!Args.empty() &&\n        parseToken(lltok::comma, \"expected ',' in argument list\"))\n      return true;\n\n    // parse the argument.\n    LocTy ArgLoc;\n    Type *ArgTy = nullptr;\n    if (parseType(ArgTy, ArgLoc))\n      return true;\n\n    Value *V;\n    if (ArgTy->isMetadataTy()) {\n      if (parseMetadataAsValue(V, PFS))\n        return true;\n    } else {\n      if (parseValue(ArgTy, V, PFS))\n        return true;\n    }\n    Args.push_back(V);\n  }\n\n  Lex.Lex();  // Lex the ']'.\n  return false;\n}\n\n/// parseCleanupRet\n///   ::= 'cleanupret' from Value unwind ('to' 'caller' | TypeAndValue)\nbool LLParser::parseCleanupRet(Instruction *&Inst, PerFunctionState &PFS) {\n  Value *CleanupPad = nullptr;\n\n  if (parseToken(lltok::kw_from, \"expected 'from' after cleanupret\"))\n    return true;\n\n  if (parseValue(Type::getTokenTy(Context), CleanupPad, PFS))\n    return true;\n\n  if (parseToken(lltok::kw_unwind, \"expected 'unwind' in cleanupret\"))\n    return true;\n\n  BasicBlock *UnwindBB = nullptr;\n  if (Lex.getKind() == lltok::kw_to) {\n    Lex.Lex();\n    if (parseToken(lltok::kw_caller, \"expected 'caller' in cleanupret\"))\n      return true;\n  } else {\n    if (parseTypeAndBasicBlock(UnwindBB, PFS)) {\n      return true;\n    }\n  }\n\n  Inst = CleanupReturnInst::Create(CleanupPad, UnwindBB);\n  return false;\n}\n\n/// parseCatchRet\n///   ::= 'catchret' from Parent Value 'to' TypeAndValue\nbool LLParser::parseCatchRet(Instruction *&Inst, PerFunctionState &PFS) {\n  Value *CatchPad = nullptr;\n\n  if (parseToken(lltok::kw_from, \"expected 'from' after catchret\"))\n    return true;\n\n  if (parseValue(Type::getTokenTy(Context), CatchPad, PFS))\n    return true;\n\n  BasicBlock *BB;\n  if (parseToken(lltok::kw_to, \"expected 'to' in catchret\") ||\n      parseTypeAndBasicBlock(BB, PFS))\n    return true;\n\n  Inst = CatchReturnInst::Create(CatchPad, BB);\n  return false;\n}\n\n/// parseCatchSwitch\n///   ::= 'catchswitch' within Parent\nbool LLParser::parseCatchSwitch(Instruction *&Inst, PerFunctionState &PFS) {\n  Value *ParentPad;\n\n  if (parseToken(lltok::kw_within, \"expected 'within' after catchswitch\"))\n    return true;\n\n  if (Lex.getKind() != lltok::kw_none && Lex.getKind() != lltok::LocalVar &&\n      Lex.getKind() != lltok::LocalVarID)\n    return tokError(\"expected scope value for catchswitch\");\n\n  if (parseValue(Type::getTokenTy(Context), ParentPad, PFS))\n    return true;\n\n  if (parseToken(lltok::lsquare, \"expected '[' with catchswitch labels\"))\n    return true;\n\n  SmallVector<BasicBlock *, 32> Table;\n  do {\n    BasicBlock *DestBB;\n    if (parseTypeAndBasicBlock(DestBB, PFS))\n      return true;\n    Table.push_back(DestBB);\n  } while (EatIfPresent(lltok::comma));\n\n  if (parseToken(lltok::rsquare, \"expected ']' after catchswitch labels\"))\n    return true;\n\n  if (parseToken(lltok::kw_unwind, \"expected 'unwind' after catchswitch scope\"))\n    return true;\n\n  BasicBlock *UnwindBB = nullptr;\n  if (EatIfPresent(lltok::kw_to)) {\n    if (parseToken(lltok::kw_caller, \"expected 'caller' in catchswitch\"))\n      return true;\n  } else {\n    if (parseTypeAndBasicBlock(UnwindBB, PFS))\n      return true;\n  }\n\n  auto *CatchSwitch =\n      CatchSwitchInst::Create(ParentPad, UnwindBB, Table.size());\n  for (BasicBlock *DestBB : Table)\n    CatchSwitch->addHandler(DestBB);\n  Inst = CatchSwitch;\n  return false;\n}\n\n/// parseCatchPad\n///   ::= 'catchpad' ParamList 'to' TypeAndValue 'unwind' TypeAndValue\nbool LLParser::parseCatchPad(Instruction *&Inst, PerFunctionState &PFS) {\n  Value *CatchSwitch = nullptr;\n\n  if (parseToken(lltok::kw_within, \"expected 'within' after catchpad\"))\n    return true;\n\n  if (Lex.getKind() != lltok::LocalVar && Lex.getKind() != lltok::LocalVarID)\n    return tokError(\"expected scope value for catchpad\");\n\n  if (parseValue(Type::getTokenTy(Context), CatchSwitch, PFS))\n    return true;\n\n  SmallVector<Value *, 8> Args;\n  if (parseExceptionArgs(Args, PFS))\n    return true;\n\n  Inst = CatchPadInst::Create(CatchSwitch, Args);\n  return false;\n}\n\n/// parseCleanupPad\n///   ::= 'cleanuppad' within Parent ParamList\nbool LLParser::parseCleanupPad(Instruction *&Inst, PerFunctionState &PFS) {\n  Value *ParentPad = nullptr;\n\n  if (parseToken(lltok::kw_within, \"expected 'within' after cleanuppad\"))\n    return true;\n\n  if (Lex.getKind() != lltok::kw_none && Lex.getKind() != lltok::LocalVar &&\n      Lex.getKind() != lltok::LocalVarID)\n    return tokError(\"expected scope value for cleanuppad\");\n\n  if (parseValue(Type::getTokenTy(Context), ParentPad, PFS))\n    return true;\n\n  SmallVector<Value *, 8> Args;\n  if (parseExceptionArgs(Args, PFS))\n    return true;\n\n  Inst = CleanupPadInst::Create(ParentPad, Args);\n  return false;\n}\n\n//===----------------------------------------------------------------------===//\n// Unary Operators.\n//===----------------------------------------------------------------------===//\n\n/// parseUnaryOp\n///  ::= UnaryOp TypeAndValue ',' Value\n///\n/// If IsFP is false, then any integer operand is allowed, if it is true, any fp\n/// operand is allowed.\nbool LLParser::parseUnaryOp(Instruction *&Inst, PerFunctionState &PFS,\n                            unsigned Opc, bool IsFP) {\n  LocTy Loc; Value *LHS;\n  if (parseTypeAndValue(LHS, Loc, PFS))\n    return true;\n\n  bool Valid = IsFP ? LHS->getType()->isFPOrFPVectorTy()\n                    : LHS->getType()->isIntOrIntVectorTy();\n\n  if (!Valid)\n    return error(Loc, \"invalid operand type for instruction\");\n\n  Inst = UnaryOperator::Create((Instruction::UnaryOps)Opc, LHS);\n  return false;\n}\n\n/// parseCallBr\n///   ::= 'callbr' OptionalCallingConv OptionalAttrs Type Value ParamList\n///       OptionalAttrs OptionalOperandBundles 'to' TypeAndValue\n///       '[' LabelList ']'\nbool LLParser::parseCallBr(Instruction *&Inst, PerFunctionState &PFS) {\n  LocTy CallLoc = Lex.getLoc();\n  AttrBuilder RetAttrs, FnAttrs;\n  std::vector<unsigned> FwdRefAttrGrps;\n  LocTy NoBuiltinLoc;\n  unsigned CC;\n  Type *RetType = nullptr;\n  LocTy RetTypeLoc;\n  ValID CalleeID;\n  SmallVector<ParamInfo, 16> ArgList;\n  SmallVector<OperandBundleDef, 2> BundleList;\n\n  BasicBlock *DefaultDest;\n  if (parseOptionalCallingConv(CC) || parseOptionalReturnAttrs(RetAttrs) ||\n      parseType(RetType, RetTypeLoc, true /*void allowed*/) ||\n      parseValID(CalleeID) || parseParameterList(ArgList, PFS) ||\n      parseFnAttributeValuePairs(FnAttrs, FwdRefAttrGrps, false,\n                                 NoBuiltinLoc) ||\n      parseOptionalOperandBundles(BundleList, PFS) ||\n      parseToken(lltok::kw_to, \"expected 'to' in callbr\") ||\n      parseTypeAndBasicBlock(DefaultDest, PFS) ||\n      parseToken(lltok::lsquare, \"expected '[' in callbr\"))\n    return true;\n\n  // parse the destination list.\n  SmallVector<BasicBlock *, 16> IndirectDests;\n\n  if (Lex.getKind() != lltok::rsquare) {\n    BasicBlock *DestBB;\n    if (parseTypeAndBasicBlock(DestBB, PFS))\n      return true;\n    IndirectDests.push_back(DestBB);\n\n    while (EatIfPresent(lltok::comma)) {\n      if (parseTypeAndBasicBlock(DestBB, PFS))\n        return true;\n      IndirectDests.push_back(DestBB);\n    }\n  }\n\n  if (parseToken(lltok::rsquare, \"expected ']' at end of block list\"))\n    return true;\n\n  // If RetType is a non-function pointer type, then this is the short syntax\n  // for the call, which means that RetType is just the return type.  Infer the\n  // rest of the function argument types from the arguments that are present.\n  FunctionType *Ty = dyn_cast<FunctionType>(RetType);\n  if (!Ty) {\n    // Pull out the types of all of the arguments...\n    std::vector<Type *> ParamTypes;\n    for (unsigned i = 0, e = ArgList.size(); i != e; ++i)\n      ParamTypes.push_back(ArgList[i].V->getType());\n\n    if (!FunctionType::isValidReturnType(RetType))\n      return error(RetTypeLoc, \"Invalid result type for LLVM function\");\n\n    Ty = FunctionType::get(RetType, ParamTypes, false);\n  }\n\n  CalleeID.FTy = Ty;\n\n  // Look up the callee.\n  Value *Callee;\n  if (convertValIDToValue(PointerType::getUnqual(Ty), CalleeID, Callee, &PFS,\n                          /*IsCall=*/true))\n    return true;\n\n  // Set up the Attribute for the function.\n  SmallVector<Value *, 8> Args;\n  SmallVector<AttributeSet, 8> ArgAttrs;\n\n  // Loop through FunctionType's arguments and ensure they are specified\n  // correctly.  Also, gather any parameter attributes.\n  FunctionType::param_iterator I = Ty->param_begin();\n  FunctionType::param_iterator E = Ty->param_end();\n  for (unsigned i = 0, e = ArgList.size(); i != e; ++i) {\n    Type *ExpectedTy = nullptr;\n    if (I != E) {\n      ExpectedTy = *I++;\n    } else if (!Ty->isVarArg()) {\n      return error(ArgList[i].Loc, \"too many arguments specified\");\n    }\n\n    if (ExpectedTy && ExpectedTy != ArgList[i].V->getType())\n      return error(ArgList[i].Loc, \"argument is not of expected type '\" +\n                                       getTypeString(ExpectedTy) + \"'\");\n    Args.push_back(ArgList[i].V);\n    ArgAttrs.push_back(ArgList[i].Attrs);\n  }\n\n  if (I != E)\n    return error(CallLoc, \"not enough parameters specified for call\");\n\n  if (FnAttrs.hasAlignmentAttr())\n    return error(CallLoc, \"callbr instructions may not have an alignment\");\n\n  // Finish off the Attribute and check them\n  AttributeList PAL =\n      AttributeList::get(Context, AttributeSet::get(Context, FnAttrs),\n                         AttributeSet::get(Context, RetAttrs), ArgAttrs);\n\n  CallBrInst *CBI =\n      CallBrInst::Create(Ty, Callee, DefaultDest, IndirectDests, Args,\n                         BundleList);\n  CBI->setCallingConv(CC);\n  CBI->setAttributes(PAL);\n  ForwardRefAttrGroups[CBI] = FwdRefAttrGrps;\n  Inst = CBI;\n  return false;\n}\n\n//===----------------------------------------------------------------------===//\n// Binary Operators.\n//===----------------------------------------------------------------------===//\n\n/// parseArithmetic\n///  ::= ArithmeticOps TypeAndValue ',' Value\n///\n/// If IsFP is false, then any integer operand is allowed, if it is true, any fp\n/// operand is allowed.\nbool LLParser::parseArithmetic(Instruction *&Inst, PerFunctionState &PFS,\n                               unsigned Opc, bool IsFP) {\n  LocTy Loc; Value *LHS, *RHS;\n  if (parseTypeAndValue(LHS, Loc, PFS) ||\n      parseToken(lltok::comma, \"expected ',' in arithmetic operation\") ||\n      parseValue(LHS->getType(), RHS, PFS))\n    return true;\n\n  bool Valid = IsFP ? LHS->getType()->isFPOrFPVectorTy()\n                    : LHS->getType()->isIntOrIntVectorTy();\n\n  if (!Valid)\n    return error(Loc, \"invalid operand type for instruction\");\n\n  Inst = BinaryOperator::Create((Instruction::BinaryOps)Opc, LHS, RHS);\n  return false;\n}\n\n/// parseLogical\n///  ::= ArithmeticOps TypeAndValue ',' Value {\nbool LLParser::parseLogical(Instruction *&Inst, PerFunctionState &PFS,\n                            unsigned Opc) {\n  LocTy Loc; Value *LHS, *RHS;\n  if (parseTypeAndValue(LHS, Loc, PFS) ||\n      parseToken(lltok::comma, \"expected ',' in logical operation\") ||\n      parseValue(LHS->getType(), RHS, PFS))\n    return true;\n\n  if (!LHS->getType()->isIntOrIntVectorTy())\n    return error(Loc,\n                 \"instruction requires integer or integer vector operands\");\n\n  Inst = BinaryOperator::Create((Instruction::BinaryOps)Opc, LHS, RHS);\n  return false;\n}\n\n/// parseCompare\n///  ::= 'icmp' IPredicates TypeAndValue ',' Value\n///  ::= 'fcmp' FPredicates TypeAndValue ',' Value\nbool LLParser::parseCompare(Instruction *&Inst, PerFunctionState &PFS,\n                            unsigned Opc) {\n  // parse the integer/fp comparison predicate.\n  LocTy Loc;\n  unsigned Pred;\n  Value *LHS, *RHS;\n  if (parseCmpPredicate(Pred, Opc) || parseTypeAndValue(LHS, Loc, PFS) ||\n      parseToken(lltok::comma, \"expected ',' after compare value\") ||\n      parseValue(LHS->getType(), RHS, PFS))\n    return true;\n\n  if (Opc == Instruction::FCmp) {\n    if (!LHS->getType()->isFPOrFPVectorTy())\n      return error(Loc, \"fcmp requires floating point operands\");\n    Inst = new FCmpInst(CmpInst::Predicate(Pred), LHS, RHS);\n  } else {\n    assert(Opc == Instruction::ICmp && \"Unknown opcode for CmpInst!\");\n    if (!LHS->getType()->isIntOrIntVectorTy() &&\n        !LHS->getType()->isPtrOrPtrVectorTy())\n      return error(Loc, \"icmp requires integer operands\");\n    Inst = new ICmpInst(CmpInst::Predicate(Pred), LHS, RHS);\n  }\n  return false;\n}\n\n//===----------------------------------------------------------------------===//\n// Other Instructions.\n//===----------------------------------------------------------------------===//\n\n/// parseCast\n///   ::= CastOpc TypeAndValue 'to' Type\nbool LLParser::parseCast(Instruction *&Inst, PerFunctionState &PFS,\n                         unsigned Opc) {\n  LocTy Loc;\n  Value *Op;\n  Type *DestTy = nullptr;\n  if (parseTypeAndValue(Op, Loc, PFS) ||\n      parseToken(lltok::kw_to, \"expected 'to' after cast value\") ||\n      parseType(DestTy))\n    return true;\n\n  if (!CastInst::castIsValid((Instruction::CastOps)Opc, Op, DestTy)) {\n    CastInst::castIsValid((Instruction::CastOps)Opc, Op, DestTy);\n    return error(Loc, \"invalid cast opcode for cast from '\" +\n                          getTypeString(Op->getType()) + \"' to '\" +\n                          getTypeString(DestTy) + \"'\");\n  }\n  Inst = CastInst::Create((Instruction::CastOps)Opc, Op, DestTy);\n  return false;\n}\n\n/// parseSelect\n///   ::= 'select' TypeAndValue ',' TypeAndValue ',' TypeAndValue\nbool LLParser::parseSelect(Instruction *&Inst, PerFunctionState &PFS) {\n  LocTy Loc;\n  Value *Op0, *Op1, *Op2;\n  if (parseTypeAndValue(Op0, Loc, PFS) ||\n      parseToken(lltok::comma, \"expected ',' after select condition\") ||\n      parseTypeAndValue(Op1, PFS) ||\n      parseToken(lltok::comma, \"expected ',' after select value\") ||\n      parseTypeAndValue(Op2, PFS))\n    return true;\n\n  if (const char *Reason = SelectInst::areInvalidOperands(Op0, Op1, Op2))\n    return error(Loc, Reason);\n\n  Inst = SelectInst::Create(Op0, Op1, Op2);\n  return false;\n}\n\n/// parseVAArg\n///   ::= 'va_arg' TypeAndValue ',' Type\nbool LLParser::parseVAArg(Instruction *&Inst, PerFunctionState &PFS) {\n  Value *Op;\n  Type *EltTy = nullptr;\n  LocTy TypeLoc;\n  if (parseTypeAndValue(Op, PFS) ||\n      parseToken(lltok::comma, \"expected ',' after vaarg operand\") ||\n      parseType(EltTy, TypeLoc))\n    return true;\n\n  if (!EltTy->isFirstClassType())\n    return error(TypeLoc, \"va_arg requires operand with first class type\");\n\n  Inst = new VAArgInst(Op, EltTy);\n  return false;\n}\n\n/// parseExtractElement\n///   ::= 'extractelement' TypeAndValue ',' TypeAndValue\nbool LLParser::parseExtractElement(Instruction *&Inst, PerFunctionState &PFS) {\n  LocTy Loc;\n  Value *Op0, *Op1;\n  if (parseTypeAndValue(Op0, Loc, PFS) ||\n      parseToken(lltok::comma, \"expected ',' after extract value\") ||\n      parseTypeAndValue(Op1, PFS))\n    return true;\n\n  if (!ExtractElementInst::isValidOperands(Op0, Op1))\n    return error(Loc, \"invalid extractelement operands\");\n\n  Inst = ExtractElementInst::Create(Op0, Op1);\n  return false;\n}\n\n/// parseInsertElement\n///   ::= 'insertelement' TypeAndValue ',' TypeAndValue ',' TypeAndValue\nbool LLParser::parseInsertElement(Instruction *&Inst, PerFunctionState &PFS) {\n  LocTy Loc;\n  Value *Op0, *Op1, *Op2;\n  if (parseTypeAndValue(Op0, Loc, PFS) ||\n      parseToken(lltok::comma, \"expected ',' after insertelement value\") ||\n      parseTypeAndValue(Op1, PFS) ||\n      parseToken(lltok::comma, \"expected ',' after insertelement value\") ||\n      parseTypeAndValue(Op2, PFS))\n    return true;\n\n  if (!InsertElementInst::isValidOperands(Op0, Op1, Op2))\n    return error(Loc, \"invalid insertelement operands\");\n\n  Inst = InsertElementInst::Create(Op0, Op1, Op2);\n  return false;\n}\n\n/// parseShuffleVector\n///   ::= 'shufflevector' TypeAndValue ',' TypeAndValue ',' TypeAndValue\nbool LLParser::parseShuffleVector(Instruction *&Inst, PerFunctionState &PFS) {\n  LocTy Loc;\n  Value *Op0, *Op1, *Op2;\n  if (parseTypeAndValue(Op0, Loc, PFS) ||\n      parseToken(lltok::comma, \"expected ',' after shuffle mask\") ||\n      parseTypeAndValue(Op1, PFS) ||\n      parseToken(lltok::comma, \"expected ',' after shuffle value\") ||\n      parseTypeAndValue(Op2, PFS))\n    return true;\n\n  if (!ShuffleVectorInst::isValidOperands(Op0, Op1, Op2))\n    return error(Loc, \"invalid shufflevector operands\");\n\n  Inst = new ShuffleVectorInst(Op0, Op1, Op2);\n  return false;\n}\n\n/// parsePHI\n///   ::= 'phi' Type '[' Value ',' Value ']' (',' '[' Value ',' Value ']')*\nint LLParser::parsePHI(Instruction *&Inst, PerFunctionState &PFS) {\n  Type *Ty = nullptr;  LocTy TypeLoc;\n  Value *Op0, *Op1;\n\n  if (parseType(Ty, TypeLoc) ||\n      parseToken(lltok::lsquare, \"expected '[' in phi value list\") ||\n      parseValue(Ty, Op0, PFS) ||\n      parseToken(lltok::comma, \"expected ',' after insertelement value\") ||\n      parseValue(Type::getLabelTy(Context), Op1, PFS) ||\n      parseToken(lltok::rsquare, \"expected ']' in phi value list\"))\n    return true;\n\n  bool AteExtraComma = false;\n  SmallVector<std::pair<Value*, BasicBlock*>, 16> PHIVals;\n\n  while (true) {\n    PHIVals.push_back(std::make_pair(Op0, cast<BasicBlock>(Op1)));\n\n    if (!EatIfPresent(lltok::comma))\n      break;\n\n    if (Lex.getKind() == lltok::MetadataVar) {\n      AteExtraComma = true;\n      break;\n    }\n\n    if (parseToken(lltok::lsquare, \"expected '[' in phi value list\") ||\n        parseValue(Ty, Op0, PFS) ||\n        parseToken(lltok::comma, \"expected ',' after insertelement value\") ||\n        parseValue(Type::getLabelTy(Context), Op1, PFS) ||\n        parseToken(lltok::rsquare, \"expected ']' in phi value list\"))\n      return true;\n  }\n\n  if (!Ty->isFirstClassType())\n    return error(TypeLoc, \"phi node must have first class type\");\n\n  PHINode *PN = PHINode::Create(Ty, PHIVals.size());\n  for (unsigned i = 0, e = PHIVals.size(); i != e; ++i)\n    PN->addIncoming(PHIVals[i].first, PHIVals[i].second);\n  Inst = PN;\n  return AteExtraComma ? InstExtraComma : InstNormal;\n}\n\n/// parseLandingPad\n///   ::= 'landingpad' Type 'personality' TypeAndValue 'cleanup'? Clause+\n/// Clause\n///   ::= 'catch' TypeAndValue\n///   ::= 'filter'\n///   ::= 'filter' TypeAndValue ( ',' TypeAndValue )*\nbool LLParser::parseLandingPad(Instruction *&Inst, PerFunctionState &PFS) {\n  Type *Ty = nullptr; LocTy TyLoc;\n\n  if (parseType(Ty, TyLoc))\n    return true;\n\n  std::unique_ptr<LandingPadInst> LP(LandingPadInst::Create(Ty, 0));\n  LP->setCleanup(EatIfPresent(lltok::kw_cleanup));\n\n  while (Lex.getKind() == lltok::kw_catch || Lex.getKind() == lltok::kw_filter){\n    LandingPadInst::ClauseType CT;\n    if (EatIfPresent(lltok::kw_catch))\n      CT = LandingPadInst::Catch;\n    else if (EatIfPresent(lltok::kw_filter))\n      CT = LandingPadInst::Filter;\n    else\n      return tokError(\"expected 'catch' or 'filter' clause type\");\n\n    Value *V;\n    LocTy VLoc;\n    if (parseTypeAndValue(V, VLoc, PFS))\n      return true;\n\n    // A 'catch' type expects a non-array constant. A filter clause expects an\n    // array constant.\n    if (CT == LandingPadInst::Catch) {\n      if (isa<ArrayType>(V->getType()))\n        error(VLoc, \"'catch' clause has an invalid type\");\n    } else {\n      if (!isa<ArrayType>(V->getType()))\n        error(VLoc, \"'filter' clause has an invalid type\");\n    }\n\n    Constant *CV = dyn_cast<Constant>(V);\n    if (!CV)\n      return error(VLoc, \"clause argument must be a constant\");\n    LP->addClause(CV);\n  }\n\n  Inst = LP.release();\n  return false;\n}\n\n/// parseFreeze\n///   ::= 'freeze' Type Value\nbool LLParser::parseFreeze(Instruction *&Inst, PerFunctionState &PFS) {\n  LocTy Loc;\n  Value *Op;\n  if (parseTypeAndValue(Op, Loc, PFS))\n    return true;\n\n  Inst = new FreezeInst(Op);\n  return false;\n}\n\n/// parseCall\n///   ::= 'call' OptionalFastMathFlags OptionalCallingConv\n///           OptionalAttrs Type Value ParameterList OptionalAttrs\n///   ::= 'tail' 'call' OptionalFastMathFlags OptionalCallingConv\n///           OptionalAttrs Type Value ParameterList OptionalAttrs\n///   ::= 'musttail' 'call' OptionalFastMathFlags OptionalCallingConv\n///           OptionalAttrs Type Value ParameterList OptionalAttrs\n///   ::= 'notail' 'call'  OptionalFastMathFlags OptionalCallingConv\n///           OptionalAttrs Type Value ParameterList OptionalAttrs\nbool LLParser::parseCall(Instruction *&Inst, PerFunctionState &PFS,\n                         CallInst::TailCallKind TCK) {\n  AttrBuilder RetAttrs, FnAttrs;\n  std::vector<unsigned> FwdRefAttrGrps;\n  LocTy BuiltinLoc;\n  unsigned CallAddrSpace;\n  unsigned CC;\n  Type *RetType = nullptr;\n  LocTy RetTypeLoc;\n  ValID CalleeID;\n  SmallVector<ParamInfo, 16> ArgList;\n  SmallVector<OperandBundleDef, 2> BundleList;\n  LocTy CallLoc = Lex.getLoc();\n\n  if (TCK != CallInst::TCK_None &&\n      parseToken(lltok::kw_call,\n                 \"expected 'tail call', 'musttail call', or 'notail call'\"))\n    return true;\n\n  FastMathFlags FMF = EatFastMathFlagsIfPresent();\n\n  if (parseOptionalCallingConv(CC) || parseOptionalReturnAttrs(RetAttrs) ||\n      parseOptionalProgramAddrSpace(CallAddrSpace) ||\n      parseType(RetType, RetTypeLoc, true /*void allowed*/) ||\n      parseValID(CalleeID) ||\n      parseParameterList(ArgList, PFS, TCK == CallInst::TCK_MustTail,\n                         PFS.getFunction().isVarArg()) ||\n      parseFnAttributeValuePairs(FnAttrs, FwdRefAttrGrps, false, BuiltinLoc) ||\n      parseOptionalOperandBundles(BundleList, PFS))\n    return true;\n\n  // If RetType is a non-function pointer type, then this is the short syntax\n  // for the call, which means that RetType is just the return type.  Infer the\n  // rest of the function argument types from the arguments that are present.\n  FunctionType *Ty = dyn_cast<FunctionType>(RetType);\n  if (!Ty) {\n    // Pull out the types of all of the arguments...\n    std::vector<Type*> ParamTypes;\n    for (unsigned i = 0, e = ArgList.size(); i != e; ++i)\n      ParamTypes.push_back(ArgList[i].V->getType());\n\n    if (!FunctionType::isValidReturnType(RetType))\n      return error(RetTypeLoc, \"Invalid result type for LLVM function\");\n\n    Ty = FunctionType::get(RetType, ParamTypes, false);\n  }\n\n  CalleeID.FTy = Ty;\n\n  // Look up the callee.\n  Value *Callee;\n  if (convertValIDToValue(PointerType::get(Ty, CallAddrSpace), CalleeID, Callee,\n                          &PFS, /*IsCall=*/true))\n    return true;\n\n  // Set up the Attribute for the function.\n  SmallVector<AttributeSet, 8> Attrs;\n\n  SmallVector<Value*, 8> Args;\n\n  // Loop through FunctionType's arguments and ensure they are specified\n  // correctly.  Also, gather any parameter attributes.\n  FunctionType::param_iterator I = Ty->param_begin();\n  FunctionType::param_iterator E = Ty->param_end();\n  for (unsigned i = 0, e = ArgList.size(); i != e; ++i) {\n    Type *ExpectedTy = nullptr;\n    if (I != E) {\n      ExpectedTy = *I++;\n    } else if (!Ty->isVarArg()) {\n      return error(ArgList[i].Loc, \"too many arguments specified\");\n    }\n\n    if (ExpectedTy && ExpectedTy != ArgList[i].V->getType())\n      return error(ArgList[i].Loc, \"argument is not of expected type '\" +\n                                       getTypeString(ExpectedTy) + \"'\");\n    Args.push_back(ArgList[i].V);\n    Attrs.push_back(ArgList[i].Attrs);\n  }\n\n  if (I != E)\n    return error(CallLoc, \"not enough parameters specified for call\");\n\n  if (FnAttrs.hasAlignmentAttr())\n    return error(CallLoc, \"call instructions may not have an alignment\");\n\n  // Finish off the Attribute and check them\n  AttributeList PAL =\n      AttributeList::get(Context, AttributeSet::get(Context, FnAttrs),\n                         AttributeSet::get(Context, RetAttrs), Attrs);\n\n  CallInst *CI = CallInst::Create(Ty, Callee, Args, BundleList);\n  CI->setTailCallKind(TCK);\n  CI->setCallingConv(CC);\n  if (FMF.any()) {\n    if (!isa<FPMathOperator>(CI)) {\n      CI->deleteValue();\n      return error(CallLoc, \"fast-math-flags specified for call without \"\n                            \"floating-point scalar or vector return type\");\n    }\n    CI->setFastMathFlags(FMF);\n  }\n  CI->setAttributes(PAL);\n  ForwardRefAttrGroups[CI] = FwdRefAttrGrps;\n  Inst = CI;\n  return false;\n}\n\n//===----------------------------------------------------------------------===//\n// Memory Instructions.\n//===----------------------------------------------------------------------===//\n\n/// parseAlloc\n///   ::= 'alloca' 'inalloca'? 'swifterror'? Type (',' TypeAndValue)?\n///       (',' 'align' i32)? (',', 'addrspace(n))?\nint LLParser::parseAlloc(Instruction *&Inst, PerFunctionState &PFS) {\n  Value *Size = nullptr;\n  LocTy SizeLoc, TyLoc, ASLoc;\n  MaybeAlign Alignment;\n  unsigned AddrSpace = 0;\n  Type *Ty = nullptr;\n\n  bool IsInAlloca = EatIfPresent(lltok::kw_inalloca);\n  bool IsSwiftError = EatIfPresent(lltok::kw_swifterror);\n\n  if (parseType(Ty, TyLoc))\n    return true;\n\n  if (Ty->isFunctionTy() || !PointerType::isValidElementType(Ty))\n    return error(TyLoc, \"invalid type for alloca\");\n\n  bool AteExtraComma = false;\n  if (EatIfPresent(lltok::comma)) {\n    if (Lex.getKind() == lltok::kw_align) {\n      if (parseOptionalAlignment(Alignment))\n        return true;\n      if (parseOptionalCommaAddrSpace(AddrSpace, ASLoc, AteExtraComma))\n        return true;\n    } else if (Lex.getKind() == lltok::kw_addrspace) {\n      ASLoc = Lex.getLoc();\n      if (parseOptionalAddrSpace(AddrSpace))\n        return true;\n    } else if (Lex.getKind() == lltok::MetadataVar) {\n      AteExtraComma = true;\n    } else {\n      if (parseTypeAndValue(Size, SizeLoc, PFS))\n        return true;\n      if (EatIfPresent(lltok::comma)) {\n        if (Lex.getKind() == lltok::kw_align) {\n          if (parseOptionalAlignment(Alignment))\n            return true;\n          if (parseOptionalCommaAddrSpace(AddrSpace, ASLoc, AteExtraComma))\n            return true;\n        } else if (Lex.getKind() == lltok::kw_addrspace) {\n          ASLoc = Lex.getLoc();\n          if (parseOptionalAddrSpace(AddrSpace))\n            return true;\n        } else if (Lex.getKind() == lltok::MetadataVar) {\n          AteExtraComma = true;\n        }\n      }\n    }\n  }\n\n  if (Size && !Size->getType()->isIntegerTy())\n    return error(SizeLoc, \"element count must have integer type\");\n\n  SmallPtrSet<Type *, 4> Visited;\n  if (!Alignment && !Ty->isSized(&Visited))\n    return error(TyLoc, \"Cannot allocate unsized type\");\n  if (!Alignment)\n    Alignment = M->getDataLayout().getPrefTypeAlign(Ty);\n  AllocaInst *AI = new AllocaInst(Ty, AddrSpace, Size, *Alignment);\n  AI->setUsedWithInAlloca(IsInAlloca);\n  AI->setSwiftError(IsSwiftError);\n  Inst = AI;\n  return AteExtraComma ? InstExtraComma : InstNormal;\n}\n\n/// parseLoad\n///   ::= 'load' 'volatile'? TypeAndValue (',' 'align' i32)?\n///   ::= 'load' 'atomic' 'volatile'? TypeAndValue\n///       'singlethread'? AtomicOrdering (',' 'align' i32)?\nint LLParser::parseLoad(Instruction *&Inst, PerFunctionState &PFS) {\n  Value *Val; LocTy Loc;\n  MaybeAlign Alignment;\n  bool AteExtraComma = false;\n  bool isAtomic = false;\n  AtomicOrdering Ordering = AtomicOrdering::NotAtomic;\n  SyncScope::ID SSID = SyncScope::System;\n\n  if (Lex.getKind() == lltok::kw_atomic) {\n    isAtomic = true;\n    Lex.Lex();\n  }\n\n  bool isVolatile = false;\n  if (Lex.getKind() == lltok::kw_volatile) {\n    isVolatile = true;\n    Lex.Lex();\n  }\n\n  Type *Ty;\n  LocTy ExplicitTypeLoc = Lex.getLoc();\n  if (parseType(Ty) ||\n      parseToken(lltok::comma, \"expected comma after load's type\") ||\n      parseTypeAndValue(Val, Loc, PFS) ||\n      parseScopeAndOrdering(isAtomic, SSID, Ordering) ||\n      parseOptionalCommaAlign(Alignment, AteExtraComma))\n    return true;\n\n  if (!Val->getType()->isPointerTy() || !Ty->isFirstClassType())\n    return error(Loc, \"load operand must be a pointer to a first class type\");\n  if (isAtomic && !Alignment)\n    return error(Loc, \"atomic load must have explicit non-zero alignment\");\n  if (Ordering == AtomicOrdering::Release ||\n      Ordering == AtomicOrdering::AcquireRelease)\n    return error(Loc, \"atomic load cannot use Release ordering\");\n\n  if (Ty != cast<PointerType>(Val->getType())->getElementType())\n    return error(ExplicitTypeLoc,\n                 \"explicit pointee type doesn't match operand's pointee type\");\n  SmallPtrSet<Type *, 4> Visited;\n  if (!Alignment && !Ty->isSized(&Visited))\n    return error(ExplicitTypeLoc, \"loading unsized types is not allowed\");\n  if (!Alignment)\n    Alignment = M->getDataLayout().getABITypeAlign(Ty);\n  Inst = new LoadInst(Ty, Val, \"\", isVolatile, *Alignment, Ordering, SSID);\n  return AteExtraComma ? InstExtraComma : InstNormal;\n}\n\n/// parseStore\n\n///   ::= 'store' 'volatile'? TypeAndValue ',' TypeAndValue (',' 'align' i32)?\n///   ::= 'store' 'atomic' 'volatile'? TypeAndValue ',' TypeAndValue\n///       'singlethread'? AtomicOrdering (',' 'align' i32)?\nint LLParser::parseStore(Instruction *&Inst, PerFunctionState &PFS) {\n  Value *Val, *Ptr; LocTy Loc, PtrLoc;\n  MaybeAlign Alignment;\n  bool AteExtraComma = false;\n  bool isAtomic = false;\n  AtomicOrdering Ordering = AtomicOrdering::NotAtomic;\n  SyncScope::ID SSID = SyncScope::System;\n\n  if (Lex.getKind() == lltok::kw_atomic) {\n    isAtomic = true;\n    Lex.Lex();\n  }\n\n  bool isVolatile = false;\n  if (Lex.getKind() == lltok::kw_volatile) {\n    isVolatile = true;\n    Lex.Lex();\n  }\n\n  if (parseTypeAndValue(Val, Loc, PFS) ||\n      parseToken(lltok::comma, \"expected ',' after store operand\") ||\n      parseTypeAndValue(Ptr, PtrLoc, PFS) ||\n      parseScopeAndOrdering(isAtomic, SSID, Ordering) ||\n      parseOptionalCommaAlign(Alignment, AteExtraComma))\n    return true;\n\n  if (!Ptr->getType()->isPointerTy())\n    return error(PtrLoc, \"store operand must be a pointer\");\n  if (!Val->getType()->isFirstClassType())\n    return error(Loc, \"store operand must be a first class value\");\n  if (cast<PointerType>(Ptr->getType())->getElementType() != Val->getType())\n    return error(Loc, \"stored value and pointer type do not match\");\n  if (isAtomic && !Alignment)\n    return error(Loc, \"atomic store must have explicit non-zero alignment\");\n  if (Ordering == AtomicOrdering::Acquire ||\n      Ordering == AtomicOrdering::AcquireRelease)\n    return error(Loc, \"atomic store cannot use Acquire ordering\");\n  SmallPtrSet<Type *, 4> Visited;\n  if (!Alignment && !Val->getType()->isSized(&Visited))\n    return error(Loc, \"storing unsized types is not allowed\");\n  if (!Alignment)\n    Alignment = M->getDataLayout().getABITypeAlign(Val->getType());\n\n  Inst = new StoreInst(Val, Ptr, isVolatile, *Alignment, Ordering, SSID);\n  return AteExtraComma ? InstExtraComma : InstNormal;\n}\n\n/// parseCmpXchg\n///   ::= 'cmpxchg' 'weak'? 'volatile'? TypeAndValue ',' TypeAndValue ','\n///       TypeAndValue 'singlethread'? AtomicOrdering AtomicOrdering ','\n///       'Align'?\nint LLParser::parseCmpXchg(Instruction *&Inst, PerFunctionState &PFS) {\n  Value *Ptr, *Cmp, *New; LocTy PtrLoc, CmpLoc, NewLoc;\n  bool AteExtraComma = false;\n  AtomicOrdering SuccessOrdering = AtomicOrdering::NotAtomic;\n  AtomicOrdering FailureOrdering = AtomicOrdering::NotAtomic;\n  SyncScope::ID SSID = SyncScope::System;\n  bool isVolatile = false;\n  bool isWeak = false;\n  MaybeAlign Alignment;\n\n  if (EatIfPresent(lltok::kw_weak))\n    isWeak = true;\n\n  if (EatIfPresent(lltok::kw_volatile))\n    isVolatile = true;\n\n  if (parseTypeAndValue(Ptr, PtrLoc, PFS) ||\n      parseToken(lltok::comma, \"expected ',' after cmpxchg address\") ||\n      parseTypeAndValue(Cmp, CmpLoc, PFS) ||\n      parseToken(lltok::comma, \"expected ',' after cmpxchg cmp operand\") ||\n      parseTypeAndValue(New, NewLoc, PFS) ||\n      parseScopeAndOrdering(true /*Always atomic*/, SSID, SuccessOrdering) ||\n      parseOrdering(FailureOrdering) ||\n      parseOptionalCommaAlign(Alignment, AteExtraComma))\n    return true;\n\n  if (SuccessOrdering == AtomicOrdering::Unordered ||\n      FailureOrdering == AtomicOrdering::Unordered)\n    return tokError(\"cmpxchg cannot be unordered\");\n  if (isStrongerThan(FailureOrdering, SuccessOrdering))\n    return tokError(\"cmpxchg failure argument shall be no stronger than the \"\n                    \"success argument\");\n  if (FailureOrdering == AtomicOrdering::Release ||\n      FailureOrdering == AtomicOrdering::AcquireRelease)\n    return tokError(\n        \"cmpxchg failure ordering cannot include release semantics\");\n  if (!Ptr->getType()->isPointerTy())\n    return error(PtrLoc, \"cmpxchg operand must be a pointer\");\n  if (cast<PointerType>(Ptr->getType())->getElementType() != Cmp->getType())\n    return error(CmpLoc, \"compare value and pointer type do not match\");\n  if (cast<PointerType>(Ptr->getType())->getElementType() != New->getType())\n    return error(NewLoc, \"new value and pointer type do not match\");\n  if (!New->getType()->isFirstClassType())\n    return error(NewLoc, \"cmpxchg operand must be a first class value\");\n\n  const Align DefaultAlignment(\n      PFS.getFunction().getParent()->getDataLayout().getTypeStoreSize(\n          Cmp->getType()));\n\n  AtomicCmpXchgInst *CXI = new AtomicCmpXchgInst(\n      Ptr, Cmp, New, Alignment.getValueOr(DefaultAlignment), SuccessOrdering,\n      FailureOrdering, SSID);\n  CXI->setVolatile(isVolatile);\n  CXI->setWeak(isWeak);\n\n  Inst = CXI;\n  return AteExtraComma ? InstExtraComma : InstNormal;\n}\n\n/// parseAtomicRMW\n///   ::= 'atomicrmw' 'volatile'? BinOp TypeAndValue ',' TypeAndValue\n///       'singlethread'? AtomicOrdering\nint LLParser::parseAtomicRMW(Instruction *&Inst, PerFunctionState &PFS) {\n  Value *Ptr, *Val; LocTy PtrLoc, ValLoc;\n  bool AteExtraComma = false;\n  AtomicOrdering Ordering = AtomicOrdering::NotAtomic;\n  SyncScope::ID SSID = SyncScope::System;\n  bool isVolatile = false;\n  bool IsFP = false;\n  AtomicRMWInst::BinOp Operation;\n  MaybeAlign Alignment;\n\n  if (EatIfPresent(lltok::kw_volatile))\n    isVolatile = true;\n\n  switch (Lex.getKind()) {\n  default:\n    return tokError(\"expected binary operation in atomicrmw\");\n  case lltok::kw_xchg: Operation = AtomicRMWInst::Xchg; break;\n  case lltok::kw_add: Operation = AtomicRMWInst::Add; break;\n  case lltok::kw_sub: Operation = AtomicRMWInst::Sub; break;\n  case lltok::kw_and: Operation = AtomicRMWInst::And; break;\n  case lltok::kw_nand: Operation = AtomicRMWInst::Nand; break;\n  case lltok::kw_or: Operation = AtomicRMWInst::Or; break;\n  case lltok::kw_xor: Operation = AtomicRMWInst::Xor; break;\n  case lltok::kw_max: Operation = AtomicRMWInst::Max; break;\n  case lltok::kw_min: Operation = AtomicRMWInst::Min; break;\n  case lltok::kw_umax: Operation = AtomicRMWInst::UMax; break;\n  case lltok::kw_umin: Operation = AtomicRMWInst::UMin; break;\n  case lltok::kw_fadd:\n    Operation = AtomicRMWInst::FAdd;\n    IsFP = true;\n    break;\n  case lltok::kw_fsub:\n    Operation = AtomicRMWInst::FSub;\n    IsFP = true;\n    break;\n  }\n  Lex.Lex();  // Eat the operation.\n\n  if (parseTypeAndValue(Ptr, PtrLoc, PFS) ||\n      parseToken(lltok::comma, \"expected ',' after atomicrmw address\") ||\n      parseTypeAndValue(Val, ValLoc, PFS) ||\n      parseScopeAndOrdering(true /*Always atomic*/, SSID, Ordering) ||\n      parseOptionalCommaAlign(Alignment, AteExtraComma))\n    return true;\n\n  if (Ordering == AtomicOrdering::Unordered)\n    return tokError(\"atomicrmw cannot be unordered\");\n  if (!Ptr->getType()->isPointerTy())\n    return error(PtrLoc, \"atomicrmw operand must be a pointer\");\n  if (cast<PointerType>(Ptr->getType())->getElementType() != Val->getType())\n    return error(ValLoc, \"atomicrmw value and pointer type do not match\");\n\n  if (Operation == AtomicRMWInst::Xchg) {\n    if (!Val->getType()->isIntegerTy() &&\n        !Val->getType()->isFloatingPointTy()) {\n      return error(ValLoc,\n                   \"atomicrmw \" + AtomicRMWInst::getOperationName(Operation) +\n                       \" operand must be an integer or floating point type\");\n    }\n  } else if (IsFP) {\n    if (!Val->getType()->isFloatingPointTy()) {\n      return error(ValLoc, \"atomicrmw \" +\n                               AtomicRMWInst::getOperationName(Operation) +\n                               \" operand must be a floating point type\");\n    }\n  } else {\n    if (!Val->getType()->isIntegerTy()) {\n      return error(ValLoc, \"atomicrmw \" +\n                               AtomicRMWInst::getOperationName(Operation) +\n                               \" operand must be an integer\");\n    }\n  }\n\n  unsigned Size = Val->getType()->getPrimitiveSizeInBits();\n  if (Size < 8 || (Size & (Size - 1)))\n    return error(ValLoc, \"atomicrmw operand must be power-of-two byte-sized\"\n                         \" integer\");\n  const Align DefaultAlignment(\n      PFS.getFunction().getParent()->getDataLayout().getTypeStoreSize(\n          Val->getType()));\n  AtomicRMWInst *RMWI =\n      new AtomicRMWInst(Operation, Ptr, Val,\n                        Alignment.getValueOr(DefaultAlignment), Ordering, SSID);\n  RMWI->setVolatile(isVolatile);\n  Inst = RMWI;\n  return AteExtraComma ? InstExtraComma : InstNormal;\n}\n\n/// parseFence\n///   ::= 'fence' 'singlethread'? AtomicOrdering\nint LLParser::parseFence(Instruction *&Inst, PerFunctionState &PFS) {\n  AtomicOrdering Ordering = AtomicOrdering::NotAtomic;\n  SyncScope::ID SSID = SyncScope::System;\n  if (parseScopeAndOrdering(true /*Always atomic*/, SSID, Ordering))\n    return true;\n\n  if (Ordering == AtomicOrdering::Unordered)\n    return tokError(\"fence cannot be unordered\");\n  if (Ordering == AtomicOrdering::Monotonic)\n    return tokError(\"fence cannot be monotonic\");\n\n  Inst = new FenceInst(Context, Ordering, SSID);\n  return InstNormal;\n}\n\n/// parseGetElementPtr\n///   ::= 'getelementptr' 'inbounds'? TypeAndValue (',' TypeAndValue)*\nint LLParser::parseGetElementPtr(Instruction *&Inst, PerFunctionState &PFS) {\n  Value *Ptr = nullptr;\n  Value *Val = nullptr;\n  LocTy Loc, EltLoc;\n\n  bool InBounds = EatIfPresent(lltok::kw_inbounds);\n\n  Type *Ty = nullptr;\n  LocTy ExplicitTypeLoc = Lex.getLoc();\n  if (parseType(Ty) ||\n      parseToken(lltok::comma, \"expected comma after getelementptr's type\") ||\n      parseTypeAndValue(Ptr, Loc, PFS))\n    return true;\n\n  Type *BaseType = Ptr->getType();\n  PointerType *BasePointerType = dyn_cast<PointerType>(BaseType->getScalarType());\n  if (!BasePointerType)\n    return error(Loc, \"base of getelementptr must be a pointer\");\n\n  if (Ty != BasePointerType->getElementType())\n    return error(ExplicitTypeLoc,\n                 \"explicit pointee type doesn't match operand's pointee type\");\n\n  SmallVector<Value*, 16> Indices;\n  bool AteExtraComma = false;\n  // GEP returns a vector of pointers if at least one of parameters is a vector.\n  // All vector parameters should have the same vector width.\n  ElementCount GEPWidth = BaseType->isVectorTy()\n                              ? cast<VectorType>(BaseType)->getElementCount()\n                              : ElementCount::getFixed(0);\n\n  while (EatIfPresent(lltok::comma)) {\n    if (Lex.getKind() == lltok::MetadataVar) {\n      AteExtraComma = true;\n      break;\n    }\n    if (parseTypeAndValue(Val, EltLoc, PFS))\n      return true;\n    if (!Val->getType()->isIntOrIntVectorTy())\n      return error(EltLoc, \"getelementptr index must be an integer\");\n\n    if (auto *ValVTy = dyn_cast<VectorType>(Val->getType())) {\n      ElementCount ValNumEl = ValVTy->getElementCount();\n      if (GEPWidth != ElementCount::getFixed(0) && GEPWidth != ValNumEl)\n        return error(\n            EltLoc,\n            \"getelementptr vector index has a wrong number of elements\");\n      GEPWidth = ValNumEl;\n    }\n    Indices.push_back(Val);\n  }\n\n  SmallPtrSet<Type*, 4> Visited;\n  if (!Indices.empty() && !Ty->isSized(&Visited))\n    return error(Loc, \"base element of getelementptr must be sized\");\n\n  if (!GetElementPtrInst::getIndexedType(Ty, Indices))\n    return error(Loc, \"invalid getelementptr indices\");\n  Inst = GetElementPtrInst::Create(Ty, Ptr, Indices);\n  if (InBounds)\n    cast<GetElementPtrInst>(Inst)->setIsInBounds(true);\n  return AteExtraComma ? InstExtraComma : InstNormal;\n}\n\n/// parseExtractValue\n///   ::= 'extractvalue' TypeAndValue (',' uint32)+\nint LLParser::parseExtractValue(Instruction *&Inst, PerFunctionState &PFS) {\n  Value *Val; LocTy Loc;\n  SmallVector<unsigned, 4> Indices;\n  bool AteExtraComma;\n  if (parseTypeAndValue(Val, Loc, PFS) ||\n      parseIndexList(Indices, AteExtraComma))\n    return true;\n\n  if (!Val->getType()->isAggregateType())\n    return error(Loc, \"extractvalue operand must be aggregate type\");\n\n  if (!ExtractValueInst::getIndexedType(Val->getType(), Indices))\n    return error(Loc, \"invalid indices for extractvalue\");\n  Inst = ExtractValueInst::Create(Val, Indices);\n  return AteExtraComma ? InstExtraComma : InstNormal;\n}\n\n/// parseInsertValue\n///   ::= 'insertvalue' TypeAndValue ',' TypeAndValue (',' uint32)+\nint LLParser::parseInsertValue(Instruction *&Inst, PerFunctionState &PFS) {\n  Value *Val0, *Val1; LocTy Loc0, Loc1;\n  SmallVector<unsigned, 4> Indices;\n  bool AteExtraComma;\n  if (parseTypeAndValue(Val0, Loc0, PFS) ||\n      parseToken(lltok::comma, \"expected comma after insertvalue operand\") ||\n      parseTypeAndValue(Val1, Loc1, PFS) ||\n      parseIndexList(Indices, AteExtraComma))\n    return true;\n\n  if (!Val0->getType()->isAggregateType())\n    return error(Loc0, \"insertvalue operand must be aggregate type\");\n\n  Type *IndexedType = ExtractValueInst::getIndexedType(Val0->getType(), Indices);\n  if (!IndexedType)\n    return error(Loc0, \"invalid indices for insertvalue\");\n  if (IndexedType != Val1->getType())\n    return error(Loc1, \"insertvalue operand and field disagree in type: '\" +\n                           getTypeString(Val1->getType()) + \"' instead of '\" +\n                           getTypeString(IndexedType) + \"'\");\n  Inst = InsertValueInst::Create(Val0, Val1, Indices);\n  return AteExtraComma ? InstExtraComma : InstNormal;\n}\n\n//===----------------------------------------------------------------------===//\n// Embedded metadata.\n//===----------------------------------------------------------------------===//\n\n/// parseMDNodeVector\n///   ::= { Element (',' Element)* }\n/// Element\n///   ::= 'null' | TypeAndValue\nbool LLParser::parseMDNodeVector(SmallVectorImpl<Metadata *> &Elts) {\n  if (parseToken(lltok::lbrace, \"expected '{' here\"))\n    return true;\n\n  // Check for an empty list.\n  if (EatIfPresent(lltok::rbrace))\n    return false;\n\n  do {\n    // Null is a special case since it is typeless.\n    if (EatIfPresent(lltok::kw_null)) {\n      Elts.push_back(nullptr);\n      continue;\n    }\n\n    Metadata *MD;\n    if (parseMetadata(MD, nullptr))\n      return true;\n    Elts.push_back(MD);\n  } while (EatIfPresent(lltok::comma));\n\n  return parseToken(lltok::rbrace, \"expected end of metadata node\");\n}\n\n//===----------------------------------------------------------------------===//\n// Use-list order directives.\n//===----------------------------------------------------------------------===//\nbool LLParser::sortUseListOrder(Value *V, ArrayRef<unsigned> Indexes,\n                                SMLoc Loc) {\n  if (V->use_empty())\n    return error(Loc, \"value has no uses\");\n\n  unsigned NumUses = 0;\n  SmallDenseMap<const Use *, unsigned, 16> Order;\n  for (const Use &U : V->uses()) {\n    if (++NumUses > Indexes.size())\n      break;\n    Order[&U] = Indexes[NumUses - 1];\n  }\n  if (NumUses < 2)\n    return error(Loc, \"value only has one use\");\n  if (Order.size() != Indexes.size() || NumUses > Indexes.size())\n    return error(Loc,\n                 \"wrong number of indexes, expected \" + Twine(V->getNumUses()));\n\n  V->sortUseList([&](const Use &L, const Use &R) {\n    return Order.lookup(&L) < Order.lookup(&R);\n  });\n  return false;\n}\n\n/// parseUseListOrderIndexes\n///   ::= '{' uint32 (',' uint32)+ '}'\nbool LLParser::parseUseListOrderIndexes(SmallVectorImpl<unsigned> &Indexes) {\n  SMLoc Loc = Lex.getLoc();\n  if (parseToken(lltok::lbrace, \"expected '{' here\"))\n    return true;\n  if (Lex.getKind() == lltok::rbrace)\n    return Lex.Error(\"expected non-empty list of uselistorder indexes\");\n\n  // Use Offset, Max, and IsOrdered to check consistency of indexes.  The\n  // indexes should be distinct numbers in the range [0, size-1], and should\n  // not be in order.\n  unsigned Offset = 0;\n  unsigned Max = 0;\n  bool IsOrdered = true;\n  assert(Indexes.empty() && \"Expected empty order vector\");\n  do {\n    unsigned Index;\n    if (parseUInt32(Index))\n      return true;\n\n    // Update consistency checks.\n    Offset += Index - Indexes.size();\n    Max = std::max(Max, Index);\n    IsOrdered &= Index == Indexes.size();\n\n    Indexes.push_back(Index);\n  } while (EatIfPresent(lltok::comma));\n\n  if (parseToken(lltok::rbrace, \"expected '}' here\"))\n    return true;\n\n  if (Indexes.size() < 2)\n    return error(Loc, \"expected >= 2 uselistorder indexes\");\n  if (Offset != 0 || Max >= Indexes.size())\n    return error(Loc,\n                 \"expected distinct uselistorder indexes in range [0, size)\");\n  if (IsOrdered)\n    return error(Loc, \"expected uselistorder indexes to change the order\");\n\n  return false;\n}\n\n/// parseUseListOrder\n///   ::= 'uselistorder' Type Value ',' UseListOrderIndexes\nbool LLParser::parseUseListOrder(PerFunctionState *PFS) {\n  SMLoc Loc = Lex.getLoc();\n  if (parseToken(lltok::kw_uselistorder, \"expected uselistorder directive\"))\n    return true;\n\n  Value *V;\n  SmallVector<unsigned, 16> Indexes;\n  if (parseTypeAndValue(V, PFS) ||\n      parseToken(lltok::comma, \"expected comma in uselistorder directive\") ||\n      parseUseListOrderIndexes(Indexes))\n    return true;\n\n  return sortUseListOrder(V, Indexes, Loc);\n}\n\n/// parseUseListOrderBB\n///   ::= 'uselistorder_bb' @foo ',' %bar ',' UseListOrderIndexes\nbool LLParser::parseUseListOrderBB() {\n  assert(Lex.getKind() == lltok::kw_uselistorder_bb);\n  SMLoc Loc = Lex.getLoc();\n  Lex.Lex();\n\n  ValID Fn, Label;\n  SmallVector<unsigned, 16> Indexes;\n  if (parseValID(Fn) ||\n      parseToken(lltok::comma, \"expected comma in uselistorder_bb directive\") ||\n      parseValID(Label) ||\n      parseToken(lltok::comma, \"expected comma in uselistorder_bb directive\") ||\n      parseUseListOrderIndexes(Indexes))\n    return true;\n\n  // Check the function.\n  GlobalValue *GV;\n  if (Fn.Kind == ValID::t_GlobalName)\n    GV = M->getNamedValue(Fn.StrVal);\n  else if (Fn.Kind == ValID::t_GlobalID)\n    GV = Fn.UIntVal < NumberedVals.size() ? NumberedVals[Fn.UIntVal] : nullptr;\n  else\n    return error(Fn.Loc, \"expected function name in uselistorder_bb\");\n  if (!GV)\n    return error(Fn.Loc,\n                 \"invalid function forward reference in uselistorder_bb\");\n  auto *F = dyn_cast<Function>(GV);\n  if (!F)\n    return error(Fn.Loc, \"expected function name in uselistorder_bb\");\n  if (F->isDeclaration())\n    return error(Fn.Loc, \"invalid declaration in uselistorder_bb\");\n\n  // Check the basic block.\n  if (Label.Kind == ValID::t_LocalID)\n    return error(Label.Loc, \"invalid numeric label in uselistorder_bb\");\n  if (Label.Kind != ValID::t_LocalName)\n    return error(Label.Loc, \"expected basic block name in uselistorder_bb\");\n  Value *V = F->getValueSymbolTable()->lookup(Label.StrVal);\n  if (!V)\n    return error(Label.Loc, \"invalid basic block in uselistorder_bb\");\n  if (!isa<BasicBlock>(V))\n    return error(Label.Loc, \"expected basic block in uselistorder_bb\");\n\n  return sortUseListOrder(V, Indexes, Loc);\n}\n\n/// ModuleEntry\n///   ::= 'module' ':' '(' 'path' ':' STRINGCONSTANT ',' 'hash' ':' Hash ')'\n/// Hash ::= '(' UInt32 ',' UInt32 ',' UInt32 ',' UInt32 ',' UInt32 ')'\nbool LLParser::parseModuleEntry(unsigned ID) {\n  assert(Lex.getKind() == lltok::kw_module);\n  Lex.Lex();\n\n  std::string Path;\n  if (parseToken(lltok::colon, \"expected ':' here\") ||\n      parseToken(lltok::lparen, \"expected '(' here\") ||\n      parseToken(lltok::kw_path, \"expected 'path' here\") ||\n      parseToken(lltok::colon, \"expected ':' here\") ||\n      parseStringConstant(Path) ||\n      parseToken(lltok::comma, \"expected ',' here\") ||\n      parseToken(lltok::kw_hash, \"expected 'hash' here\") ||\n      parseToken(lltok::colon, \"expected ':' here\") ||\n      parseToken(lltok::lparen, \"expected '(' here\"))\n    return true;\n\n  ModuleHash Hash;\n  if (parseUInt32(Hash[0]) || parseToken(lltok::comma, \"expected ',' here\") ||\n      parseUInt32(Hash[1]) || parseToken(lltok::comma, \"expected ',' here\") ||\n      parseUInt32(Hash[2]) || parseToken(lltok::comma, \"expected ',' here\") ||\n      parseUInt32(Hash[3]) || parseToken(lltok::comma, \"expected ',' here\") ||\n      parseUInt32(Hash[4]))\n    return true;\n\n  if (parseToken(lltok::rparen, \"expected ')' here\") ||\n      parseToken(lltok::rparen, \"expected ')' here\"))\n    return true;\n\n  auto ModuleEntry = Index->addModule(Path, ID, Hash);\n  ModuleIdMap[ID] = ModuleEntry->first();\n\n  return false;\n}\n\n/// TypeIdEntry\n///   ::= 'typeid' ':' '(' 'name' ':' STRINGCONSTANT ',' TypeIdSummary ')'\nbool LLParser::parseTypeIdEntry(unsigned ID) {\n  assert(Lex.getKind() == lltok::kw_typeid);\n  Lex.Lex();\n\n  std::string Name;\n  if (parseToken(lltok::colon, \"expected ':' here\") ||\n      parseToken(lltok::lparen, \"expected '(' here\") ||\n      parseToken(lltok::kw_name, \"expected 'name' here\") ||\n      parseToken(lltok::colon, \"expected ':' here\") ||\n      parseStringConstant(Name))\n    return true;\n\n  TypeIdSummary &TIS = Index->getOrInsertTypeIdSummary(Name);\n  if (parseToken(lltok::comma, \"expected ',' here\") ||\n      parseTypeIdSummary(TIS) || parseToken(lltok::rparen, \"expected ')' here\"))\n    return true;\n\n  // Check if this ID was forward referenced, and if so, update the\n  // corresponding GUIDs.\n  auto FwdRefTIDs = ForwardRefTypeIds.find(ID);\n  if (FwdRefTIDs != ForwardRefTypeIds.end()) {\n    for (auto TIDRef : FwdRefTIDs->second) {\n      assert(!*TIDRef.first &&\n             \"Forward referenced type id GUID expected to be 0\");\n      *TIDRef.first = GlobalValue::getGUID(Name);\n    }\n    ForwardRefTypeIds.erase(FwdRefTIDs);\n  }\n\n  return false;\n}\n\n/// TypeIdSummary\n///   ::= 'summary' ':' '(' TypeTestResolution [',' OptionalWpdResolutions]? ')'\nbool LLParser::parseTypeIdSummary(TypeIdSummary &TIS) {\n  if (parseToken(lltok::kw_summary, \"expected 'summary' here\") ||\n      parseToken(lltok::colon, \"expected ':' here\") ||\n      parseToken(lltok::lparen, \"expected '(' here\") ||\n      parseTypeTestResolution(TIS.TTRes))\n    return true;\n\n  if (EatIfPresent(lltok::comma)) {\n    // Expect optional wpdResolutions field\n    if (parseOptionalWpdResolutions(TIS.WPDRes))\n      return true;\n  }\n\n  if (parseToken(lltok::rparen, \"expected ')' here\"))\n    return true;\n\n  return false;\n}\n\nstatic ValueInfo EmptyVI =\n    ValueInfo(false, (GlobalValueSummaryMapTy::value_type *)-8);\n\n/// TypeIdCompatibleVtableEntry\n///   ::= 'typeidCompatibleVTable' ':' '(' 'name' ':' STRINGCONSTANT ','\n///   TypeIdCompatibleVtableInfo\n///   ')'\nbool LLParser::parseTypeIdCompatibleVtableEntry(unsigned ID) {\n  assert(Lex.getKind() == lltok::kw_typeidCompatibleVTable);\n  Lex.Lex();\n\n  std::string Name;\n  if (parseToken(lltok::colon, \"expected ':' here\") ||\n      parseToken(lltok::lparen, \"expected '(' here\") ||\n      parseToken(lltok::kw_name, \"expected 'name' here\") ||\n      parseToken(lltok::colon, \"expected ':' here\") ||\n      parseStringConstant(Name))\n    return true;\n\n  TypeIdCompatibleVtableInfo &TI =\n      Index->getOrInsertTypeIdCompatibleVtableSummary(Name);\n  if (parseToken(lltok::comma, \"expected ',' here\") ||\n      parseToken(lltok::kw_summary, \"expected 'summary' here\") ||\n      parseToken(lltok::colon, \"expected ':' here\") ||\n      parseToken(lltok::lparen, \"expected '(' here\"))\n    return true;\n\n  IdToIndexMapType IdToIndexMap;\n  // parse each call edge\n  do {\n    uint64_t Offset;\n    if (parseToken(lltok::lparen, \"expected '(' here\") ||\n        parseToken(lltok::kw_offset, \"expected 'offset' here\") ||\n        parseToken(lltok::colon, \"expected ':' here\") || parseUInt64(Offset) ||\n        parseToken(lltok::comma, \"expected ',' here\"))\n      return true;\n\n    LocTy Loc = Lex.getLoc();\n    unsigned GVId;\n    ValueInfo VI;\n    if (parseGVReference(VI, GVId))\n      return true;\n\n    // Keep track of the TypeIdCompatibleVtableInfo array index needing a\n    // forward reference. We will save the location of the ValueInfo needing an\n    // update, but can only do so once the std::vector is finalized.\n    if (VI == EmptyVI)\n      IdToIndexMap[GVId].push_back(std::make_pair(TI.size(), Loc));\n    TI.push_back({Offset, VI});\n\n    if (parseToken(lltok::rparen, \"expected ')' in call\"))\n      return true;\n  } while (EatIfPresent(lltok::comma));\n\n  // Now that the TI vector is finalized, it is safe to save the locations\n  // of any forward GV references that need updating later.\n  for (auto I : IdToIndexMap) {\n    auto &Infos = ForwardRefValueInfos[I.first];\n    for (auto P : I.second) {\n      assert(TI[P.first].VTableVI == EmptyVI &&\n             \"Forward referenced ValueInfo expected to be empty\");\n      Infos.emplace_back(&TI[P.first].VTableVI, P.second);\n    }\n  }\n\n  if (parseToken(lltok::rparen, \"expected ')' here\") ||\n      parseToken(lltok::rparen, \"expected ')' here\"))\n    return true;\n\n  // Check if this ID was forward referenced, and if so, update the\n  // corresponding GUIDs.\n  auto FwdRefTIDs = ForwardRefTypeIds.find(ID);\n  if (FwdRefTIDs != ForwardRefTypeIds.end()) {\n    for (auto TIDRef : FwdRefTIDs->second) {\n      assert(!*TIDRef.first &&\n             \"Forward referenced type id GUID expected to be 0\");\n      *TIDRef.first = GlobalValue::getGUID(Name);\n    }\n    ForwardRefTypeIds.erase(FwdRefTIDs);\n  }\n\n  return false;\n}\n\n/// TypeTestResolution\n///   ::= 'typeTestRes' ':' '(' 'kind' ':'\n///         ( 'unsat' | 'byteArray' | 'inline' | 'single' | 'allOnes' ) ','\n///         'sizeM1BitWidth' ':' SizeM1BitWidth [',' 'alignLog2' ':' UInt64]?\n///         [',' 'sizeM1' ':' UInt64]? [',' 'bitMask' ':' UInt8]?\n///         [',' 'inlinesBits' ':' UInt64]? ')'\nbool LLParser::parseTypeTestResolution(TypeTestResolution &TTRes) {\n  if (parseToken(lltok::kw_typeTestRes, \"expected 'typeTestRes' here\") ||\n      parseToken(lltok::colon, \"expected ':' here\") ||\n      parseToken(lltok::lparen, \"expected '(' here\") ||\n      parseToken(lltok::kw_kind, \"expected 'kind' here\") ||\n      parseToken(lltok::colon, \"expected ':' here\"))\n    return true;\n\n  switch (Lex.getKind()) {\n  case lltok::kw_unknown:\n    TTRes.TheKind = TypeTestResolution::Unknown;\n    break;\n  case lltok::kw_unsat:\n    TTRes.TheKind = TypeTestResolution::Unsat;\n    break;\n  case lltok::kw_byteArray:\n    TTRes.TheKind = TypeTestResolution::ByteArray;\n    break;\n  case lltok::kw_inline:\n    TTRes.TheKind = TypeTestResolution::Inline;\n    break;\n  case lltok::kw_single:\n    TTRes.TheKind = TypeTestResolution::Single;\n    break;\n  case lltok::kw_allOnes:\n    TTRes.TheKind = TypeTestResolution::AllOnes;\n    break;\n  default:\n    return error(Lex.getLoc(), \"unexpected TypeTestResolution kind\");\n  }\n  Lex.Lex();\n\n  if (parseToken(lltok::comma, \"expected ',' here\") ||\n      parseToken(lltok::kw_sizeM1BitWidth, \"expected 'sizeM1BitWidth' here\") ||\n      parseToken(lltok::colon, \"expected ':' here\") ||\n      parseUInt32(TTRes.SizeM1BitWidth))\n    return true;\n\n  // parse optional fields\n  while (EatIfPresent(lltok::comma)) {\n    switch (Lex.getKind()) {\n    case lltok::kw_alignLog2:\n      Lex.Lex();\n      if (parseToken(lltok::colon, \"expected ':'\") ||\n          parseUInt64(TTRes.AlignLog2))\n        return true;\n      break;\n    case lltok::kw_sizeM1:\n      Lex.Lex();\n      if (parseToken(lltok::colon, \"expected ':'\") || parseUInt64(TTRes.SizeM1))\n        return true;\n      break;\n    case lltok::kw_bitMask: {\n      unsigned Val;\n      Lex.Lex();\n      if (parseToken(lltok::colon, \"expected ':'\") || parseUInt32(Val))\n        return true;\n      assert(Val <= 0xff);\n      TTRes.BitMask = (uint8_t)Val;\n      break;\n    }\n    case lltok::kw_inlineBits:\n      Lex.Lex();\n      if (parseToken(lltok::colon, \"expected ':'\") ||\n          parseUInt64(TTRes.InlineBits))\n        return true;\n      break;\n    default:\n      return error(Lex.getLoc(), \"expected optional TypeTestResolution field\");\n    }\n  }\n\n  if (parseToken(lltok::rparen, \"expected ')' here\"))\n    return true;\n\n  return false;\n}\n\n/// OptionalWpdResolutions\n///   ::= 'wpsResolutions' ':' '(' WpdResolution [',' WpdResolution]* ')'\n/// WpdResolution ::= '(' 'offset' ':' UInt64 ',' WpdRes ')'\nbool LLParser::parseOptionalWpdResolutions(\n    std::map<uint64_t, WholeProgramDevirtResolution> &WPDResMap) {\n  if (parseToken(lltok::kw_wpdResolutions, \"expected 'wpdResolutions' here\") ||\n      parseToken(lltok::colon, \"expected ':' here\") ||\n      parseToken(lltok::lparen, \"expected '(' here\"))\n    return true;\n\n  do {\n    uint64_t Offset;\n    WholeProgramDevirtResolution WPDRes;\n    if (parseToken(lltok::lparen, \"expected '(' here\") ||\n        parseToken(lltok::kw_offset, \"expected 'offset' here\") ||\n        parseToken(lltok::colon, \"expected ':' here\") || parseUInt64(Offset) ||\n        parseToken(lltok::comma, \"expected ',' here\") || parseWpdRes(WPDRes) ||\n        parseToken(lltok::rparen, \"expected ')' here\"))\n      return true;\n    WPDResMap[Offset] = WPDRes;\n  } while (EatIfPresent(lltok::comma));\n\n  if (parseToken(lltok::rparen, \"expected ')' here\"))\n    return true;\n\n  return false;\n}\n\n/// WpdRes\n///   ::= 'wpdRes' ':' '(' 'kind' ':' 'indir'\n///         [',' OptionalResByArg]? ')'\n///   ::= 'wpdRes' ':' '(' 'kind' ':' 'singleImpl'\n///         ',' 'singleImplName' ':' STRINGCONSTANT ','\n///         [',' OptionalResByArg]? ')'\n///   ::= 'wpdRes' ':' '(' 'kind' ':' 'branchFunnel'\n///         [',' OptionalResByArg]? ')'\nbool LLParser::parseWpdRes(WholeProgramDevirtResolution &WPDRes) {\n  if (parseToken(lltok::kw_wpdRes, \"expected 'wpdRes' here\") ||\n      parseToken(lltok::colon, \"expected ':' here\") ||\n      parseToken(lltok::lparen, \"expected '(' here\") ||\n      parseToken(lltok::kw_kind, \"expected 'kind' here\") ||\n      parseToken(lltok::colon, \"expected ':' here\"))\n    return true;\n\n  switch (Lex.getKind()) {\n  case lltok::kw_indir:\n    WPDRes.TheKind = WholeProgramDevirtResolution::Indir;\n    break;\n  case lltok::kw_singleImpl:\n    WPDRes.TheKind = WholeProgramDevirtResolution::SingleImpl;\n    break;\n  case lltok::kw_branchFunnel:\n    WPDRes.TheKind = WholeProgramDevirtResolution::BranchFunnel;\n    break;\n  default:\n    return error(Lex.getLoc(), \"unexpected WholeProgramDevirtResolution kind\");\n  }\n  Lex.Lex();\n\n  // parse optional fields\n  while (EatIfPresent(lltok::comma)) {\n    switch (Lex.getKind()) {\n    case lltok::kw_singleImplName:\n      Lex.Lex();\n      if (parseToken(lltok::colon, \"expected ':' here\") ||\n          parseStringConstant(WPDRes.SingleImplName))\n        return true;\n      break;\n    case lltok::kw_resByArg:\n      if (parseOptionalResByArg(WPDRes.ResByArg))\n        return true;\n      break;\n    default:\n      return error(Lex.getLoc(),\n                   \"expected optional WholeProgramDevirtResolution field\");\n    }\n  }\n\n  if (parseToken(lltok::rparen, \"expected ')' here\"))\n    return true;\n\n  return false;\n}\n\n/// OptionalResByArg\n///   ::= 'wpdRes' ':' '(' ResByArg[, ResByArg]* ')'\n/// ResByArg ::= Args ',' 'byArg' ':' '(' 'kind' ':'\n///                ( 'indir' | 'uniformRetVal' | 'UniqueRetVal' |\n///                  'virtualConstProp' )\n///                [',' 'info' ':' UInt64]? [',' 'byte' ':' UInt32]?\n///                [',' 'bit' ':' UInt32]? ')'\nbool LLParser::parseOptionalResByArg(\n    std::map<std::vector<uint64_t>, WholeProgramDevirtResolution::ByArg>\n        &ResByArg) {\n  if (parseToken(lltok::kw_resByArg, \"expected 'resByArg' here\") ||\n      parseToken(lltok::colon, \"expected ':' here\") ||\n      parseToken(lltok::lparen, \"expected '(' here\"))\n    return true;\n\n  do {\n    std::vector<uint64_t> Args;\n    if (parseArgs(Args) || parseToken(lltok::comma, \"expected ',' here\") ||\n        parseToken(lltok::kw_byArg, \"expected 'byArg here\") ||\n        parseToken(lltok::colon, \"expected ':' here\") ||\n        parseToken(lltok::lparen, \"expected '(' here\") ||\n        parseToken(lltok::kw_kind, \"expected 'kind' here\") ||\n        parseToken(lltok::colon, \"expected ':' here\"))\n      return true;\n\n    WholeProgramDevirtResolution::ByArg ByArg;\n    switch (Lex.getKind()) {\n    case lltok::kw_indir:\n      ByArg.TheKind = WholeProgramDevirtResolution::ByArg::Indir;\n      break;\n    case lltok::kw_uniformRetVal:\n      ByArg.TheKind = WholeProgramDevirtResolution::ByArg::UniformRetVal;\n      break;\n    case lltok::kw_uniqueRetVal:\n      ByArg.TheKind = WholeProgramDevirtResolution::ByArg::UniqueRetVal;\n      break;\n    case lltok::kw_virtualConstProp:\n      ByArg.TheKind = WholeProgramDevirtResolution::ByArg::VirtualConstProp;\n      break;\n    default:\n      return error(Lex.getLoc(),\n                   \"unexpected WholeProgramDevirtResolution::ByArg kind\");\n    }\n    Lex.Lex();\n\n    // parse optional fields\n    while (EatIfPresent(lltok::comma)) {\n      switch (Lex.getKind()) {\n      case lltok::kw_info:\n        Lex.Lex();\n        if (parseToken(lltok::colon, \"expected ':' here\") ||\n            parseUInt64(ByArg.Info))\n          return true;\n        break;\n      case lltok::kw_byte:\n        Lex.Lex();\n        if (parseToken(lltok::colon, \"expected ':' here\") ||\n            parseUInt32(ByArg.Byte))\n          return true;\n        break;\n      case lltok::kw_bit:\n        Lex.Lex();\n        if (parseToken(lltok::colon, \"expected ':' here\") ||\n            parseUInt32(ByArg.Bit))\n          return true;\n        break;\n      default:\n        return error(Lex.getLoc(),\n                     \"expected optional whole program devirt field\");\n      }\n    }\n\n    if (parseToken(lltok::rparen, \"expected ')' here\"))\n      return true;\n\n    ResByArg[Args] = ByArg;\n  } while (EatIfPresent(lltok::comma));\n\n  if (parseToken(lltok::rparen, \"expected ')' here\"))\n    return true;\n\n  return false;\n}\n\n/// OptionalResByArg\n///   ::= 'args' ':' '(' UInt64[, UInt64]* ')'\nbool LLParser::parseArgs(std::vector<uint64_t> &Args) {\n  if (parseToken(lltok::kw_args, \"expected 'args' here\") ||\n      parseToken(lltok::colon, \"expected ':' here\") ||\n      parseToken(lltok::lparen, \"expected '(' here\"))\n    return true;\n\n  do {\n    uint64_t Val;\n    if (parseUInt64(Val))\n      return true;\n    Args.push_back(Val);\n  } while (EatIfPresent(lltok::comma));\n\n  if (parseToken(lltok::rparen, \"expected ')' here\"))\n    return true;\n\n  return false;\n}\n\nstatic const auto FwdVIRef = (GlobalValueSummaryMapTy::value_type *)-8;\n\nstatic void resolveFwdRef(ValueInfo *Fwd, ValueInfo &Resolved) {\n  bool ReadOnly = Fwd->isReadOnly();\n  bool WriteOnly = Fwd->isWriteOnly();\n  assert(!(ReadOnly && WriteOnly));\n  *Fwd = Resolved;\n  if (ReadOnly)\n    Fwd->setReadOnly();\n  if (WriteOnly)\n    Fwd->setWriteOnly();\n}\n\n/// Stores the given Name/GUID and associated summary into the Index.\n/// Also updates any forward references to the associated entry ID.\nvoid LLParser::addGlobalValueToIndex(\n    std::string Name, GlobalValue::GUID GUID, GlobalValue::LinkageTypes Linkage,\n    unsigned ID, std::unique_ptr<GlobalValueSummary> Summary) {\n  // First create the ValueInfo utilizing the Name or GUID.\n  ValueInfo VI;\n  if (GUID != 0) {\n    assert(Name.empty());\n    VI = Index->getOrInsertValueInfo(GUID);\n  } else {\n    assert(!Name.empty());\n    if (M) {\n      auto *GV = M->getNamedValue(Name);\n      assert(GV);\n      VI = Index->getOrInsertValueInfo(GV);\n    } else {\n      assert(\n          (!GlobalValue::isLocalLinkage(Linkage) || !SourceFileName.empty()) &&\n          \"Need a source_filename to compute GUID for local\");\n      GUID = GlobalValue::getGUID(\n          GlobalValue::getGlobalIdentifier(Name, Linkage, SourceFileName));\n      VI = Index->getOrInsertValueInfo(GUID, Index->saveString(Name));\n    }\n  }\n\n  // Resolve forward references from calls/refs\n  auto FwdRefVIs = ForwardRefValueInfos.find(ID);\n  if (FwdRefVIs != ForwardRefValueInfos.end()) {\n    for (auto VIRef : FwdRefVIs->second) {\n      assert(VIRef.first->getRef() == FwdVIRef &&\n             \"Forward referenced ValueInfo expected to be empty\");\n      resolveFwdRef(VIRef.first, VI);\n    }\n    ForwardRefValueInfos.erase(FwdRefVIs);\n  }\n\n  // Resolve forward references from aliases\n  auto FwdRefAliasees = ForwardRefAliasees.find(ID);\n  if (FwdRefAliasees != ForwardRefAliasees.end()) {\n    for (auto AliaseeRef : FwdRefAliasees->second) {\n      assert(!AliaseeRef.first->hasAliasee() &&\n             \"Forward referencing alias already has aliasee\");\n      assert(Summary && \"Aliasee must be a definition\");\n      AliaseeRef.first->setAliasee(VI, Summary.get());\n    }\n    ForwardRefAliasees.erase(FwdRefAliasees);\n  }\n\n  // Add the summary if one was provided.\n  if (Summary)\n    Index->addGlobalValueSummary(VI, std::move(Summary));\n\n  // Save the associated ValueInfo for use in later references by ID.\n  if (ID == NumberedValueInfos.size())\n    NumberedValueInfos.push_back(VI);\n  else {\n    // Handle non-continuous numbers (to make test simplification easier).\n    if (ID > NumberedValueInfos.size())\n      NumberedValueInfos.resize(ID + 1);\n    NumberedValueInfos[ID] = VI;\n  }\n}\n\n/// parseSummaryIndexFlags\n///   ::= 'flags' ':' UInt64\nbool LLParser::parseSummaryIndexFlags() {\n  assert(Lex.getKind() == lltok::kw_flags);\n  Lex.Lex();\n\n  if (parseToken(lltok::colon, \"expected ':' here\"))\n    return true;\n  uint64_t Flags;\n  if (parseUInt64(Flags))\n    return true;\n  if (Index)\n    Index->setFlags(Flags);\n  return false;\n}\n\n/// parseBlockCount\n///   ::= 'blockcount' ':' UInt64\nbool LLParser::parseBlockCount() {\n  assert(Lex.getKind() == lltok::kw_blockcount);\n  Lex.Lex();\n\n  if (parseToken(lltok::colon, \"expected ':' here\"))\n    return true;\n  uint64_t BlockCount;\n  if (parseUInt64(BlockCount))\n    return true;\n  if (Index)\n    Index->setBlockCount(BlockCount);\n  return false;\n}\n\n/// parseGVEntry\n///   ::= 'gv' ':' '(' ('name' ':' STRINGCONSTANT | 'guid' ':' UInt64)\n///         [',' 'summaries' ':' Summary[',' Summary]* ]? ')'\n/// Summary ::= '(' (FunctionSummary | VariableSummary | AliasSummary) ')'\nbool LLParser::parseGVEntry(unsigned ID) {\n  assert(Lex.getKind() == lltok::kw_gv);\n  Lex.Lex();\n\n  if (parseToken(lltok::colon, \"expected ':' here\") ||\n      parseToken(lltok::lparen, \"expected '(' here\"))\n    return true;\n\n  std::string Name;\n  GlobalValue::GUID GUID = 0;\n  switch (Lex.getKind()) {\n  case lltok::kw_name:\n    Lex.Lex();\n    if (parseToken(lltok::colon, \"expected ':' here\") ||\n        parseStringConstant(Name))\n      return true;\n    // Can't create GUID/ValueInfo until we have the linkage.\n    break;\n  case lltok::kw_guid:\n    Lex.Lex();\n    if (parseToken(lltok::colon, \"expected ':' here\") || parseUInt64(GUID))\n      return true;\n    break;\n  default:\n    return error(Lex.getLoc(), \"expected name or guid tag\");\n  }\n\n  if (!EatIfPresent(lltok::comma)) {\n    // No summaries. Wrap up.\n    if (parseToken(lltok::rparen, \"expected ')' here\"))\n      return true;\n    // This was created for a call to an external or indirect target.\n    // A GUID with no summary came from a VALUE_GUID record, dummy GUID\n    // created for indirect calls with VP. A Name with no GUID came from\n    // an external definition. We pass ExternalLinkage since that is only\n    // used when the GUID must be computed from Name, and in that case\n    // the symbol must have external linkage.\n    addGlobalValueToIndex(Name, GUID, GlobalValue::ExternalLinkage, ID,\n                          nullptr);\n    return false;\n  }\n\n  // Have a list of summaries\n  if (parseToken(lltok::kw_summaries, \"expected 'summaries' here\") ||\n      parseToken(lltok::colon, \"expected ':' here\") ||\n      parseToken(lltok::lparen, \"expected '(' here\"))\n    return true;\n  do {\n    switch (Lex.getKind()) {\n    case lltok::kw_function:\n      if (parseFunctionSummary(Name, GUID, ID))\n        return true;\n      break;\n    case lltok::kw_variable:\n      if (parseVariableSummary(Name, GUID, ID))\n        return true;\n      break;\n    case lltok::kw_alias:\n      if (parseAliasSummary(Name, GUID, ID))\n        return true;\n      break;\n    default:\n      return error(Lex.getLoc(), \"expected summary type\");\n    }\n  } while (EatIfPresent(lltok::comma));\n\n  if (parseToken(lltok::rparen, \"expected ')' here\") ||\n      parseToken(lltok::rparen, \"expected ')' here\"))\n    return true;\n\n  return false;\n}\n\n/// FunctionSummary\n///   ::= 'function' ':' '(' 'module' ':' ModuleReference ',' GVFlags\n///         ',' 'insts' ':' UInt32 [',' OptionalFFlags]? [',' OptionalCalls]?\n///         [',' OptionalTypeIdInfo]? [',' OptionalParamAccesses]?\n///         [',' OptionalRefs]? ')'\nbool LLParser::parseFunctionSummary(std::string Name, GlobalValue::GUID GUID,\n                                    unsigned ID) {\n  assert(Lex.getKind() == lltok::kw_function);\n  Lex.Lex();\n\n  StringRef ModulePath;\n  GlobalValueSummary::GVFlags GVFlags = GlobalValueSummary::GVFlags(\n      GlobalValue::ExternalLinkage, GlobalValue::DefaultVisibility,\n      /*NotEligibleToImport=*/false,\n      /*Live=*/false, /*IsLocal=*/false, /*CanAutoHide=*/false);\n  unsigned InstCount;\n  std::vector<FunctionSummary::EdgeTy> Calls;\n  FunctionSummary::TypeIdInfo TypeIdInfo;\n  std::vector<FunctionSummary::ParamAccess> ParamAccesses;\n  std::vector<ValueInfo> Refs;\n  // Default is all-zeros (conservative values).\n  FunctionSummary::FFlags FFlags = {};\n  if (parseToken(lltok::colon, \"expected ':' here\") ||\n      parseToken(lltok::lparen, \"expected '(' here\") ||\n      parseModuleReference(ModulePath) ||\n      parseToken(lltok::comma, \"expected ',' here\") || parseGVFlags(GVFlags) ||\n      parseToken(lltok::comma, \"expected ',' here\") ||\n      parseToken(lltok::kw_insts, \"expected 'insts' here\") ||\n      parseToken(lltok::colon, \"expected ':' here\") || parseUInt32(InstCount))\n    return true;\n\n  // parse optional fields\n  while (EatIfPresent(lltok::comma)) {\n    switch (Lex.getKind()) {\n    case lltok::kw_funcFlags:\n      if (parseOptionalFFlags(FFlags))\n        return true;\n      break;\n    case lltok::kw_calls:\n      if (parseOptionalCalls(Calls))\n        return true;\n      break;\n    case lltok::kw_typeIdInfo:\n      if (parseOptionalTypeIdInfo(TypeIdInfo))\n        return true;\n      break;\n    case lltok::kw_refs:\n      if (parseOptionalRefs(Refs))\n        return true;\n      break;\n    case lltok::kw_params:\n      if (parseOptionalParamAccesses(ParamAccesses))\n        return true;\n      break;\n    default:\n      return error(Lex.getLoc(), \"expected optional function summary field\");\n    }\n  }\n\n  if (parseToken(lltok::rparen, \"expected ')' here\"))\n    return true;\n\n  auto FS = std::make_unique<FunctionSummary>(\n      GVFlags, InstCount, FFlags, /*EntryCount=*/0, std::move(Refs),\n      std::move(Calls), std::move(TypeIdInfo.TypeTests),\n      std::move(TypeIdInfo.TypeTestAssumeVCalls),\n      std::move(TypeIdInfo.TypeCheckedLoadVCalls),\n      std::move(TypeIdInfo.TypeTestAssumeConstVCalls),\n      std::move(TypeIdInfo.TypeCheckedLoadConstVCalls),\n      std::move(ParamAccesses));\n\n  FS->setModulePath(ModulePath);\n\n  addGlobalValueToIndex(Name, GUID, (GlobalValue::LinkageTypes)GVFlags.Linkage,\n                        ID, std::move(FS));\n\n  return false;\n}\n\n/// VariableSummary\n///   ::= 'variable' ':' '(' 'module' ':' ModuleReference ',' GVFlags\n///         [',' OptionalRefs]? ')'\nbool LLParser::parseVariableSummary(std::string Name, GlobalValue::GUID GUID,\n                                    unsigned ID) {\n  assert(Lex.getKind() == lltok::kw_variable);\n  Lex.Lex();\n\n  StringRef ModulePath;\n  GlobalValueSummary::GVFlags GVFlags = GlobalValueSummary::GVFlags(\n      GlobalValue::ExternalLinkage, GlobalValue::DefaultVisibility,\n      /*NotEligibleToImport=*/false,\n      /*Live=*/false, /*IsLocal=*/false, /*CanAutoHide=*/false);\n  GlobalVarSummary::GVarFlags GVarFlags(/*ReadOnly*/ false,\n                                        /* WriteOnly */ false,\n                                        /* Constant */ false,\n                                        GlobalObject::VCallVisibilityPublic);\n  std::vector<ValueInfo> Refs;\n  VTableFuncList VTableFuncs;\n  if (parseToken(lltok::colon, \"expected ':' here\") ||\n      parseToken(lltok::lparen, \"expected '(' here\") ||\n      parseModuleReference(ModulePath) ||\n      parseToken(lltok::comma, \"expected ',' here\") || parseGVFlags(GVFlags) ||\n      parseToken(lltok::comma, \"expected ',' here\") ||\n      parseGVarFlags(GVarFlags))\n    return true;\n\n  // parse optional fields\n  while (EatIfPresent(lltok::comma)) {\n    switch (Lex.getKind()) {\n    case lltok::kw_vTableFuncs:\n      if (parseOptionalVTableFuncs(VTableFuncs))\n        return true;\n      break;\n    case lltok::kw_refs:\n      if (parseOptionalRefs(Refs))\n        return true;\n      break;\n    default:\n      return error(Lex.getLoc(), \"expected optional variable summary field\");\n    }\n  }\n\n  if (parseToken(lltok::rparen, \"expected ')' here\"))\n    return true;\n\n  auto GS =\n      std::make_unique<GlobalVarSummary>(GVFlags, GVarFlags, std::move(Refs));\n\n  GS->setModulePath(ModulePath);\n  GS->setVTableFuncs(std::move(VTableFuncs));\n\n  addGlobalValueToIndex(Name, GUID, (GlobalValue::LinkageTypes)GVFlags.Linkage,\n                        ID, std::move(GS));\n\n  return false;\n}\n\n/// AliasSummary\n///   ::= 'alias' ':' '(' 'module' ':' ModuleReference ',' GVFlags ','\n///         'aliasee' ':' GVReference ')'\nbool LLParser::parseAliasSummary(std::string Name, GlobalValue::GUID GUID,\n                                 unsigned ID) {\n  assert(Lex.getKind() == lltok::kw_alias);\n  LocTy Loc = Lex.getLoc();\n  Lex.Lex();\n\n  StringRef ModulePath;\n  GlobalValueSummary::GVFlags GVFlags = GlobalValueSummary::GVFlags(\n      GlobalValue::ExternalLinkage, GlobalValue::DefaultVisibility,\n      /*NotEligibleToImport=*/false,\n      /*Live=*/false, /*IsLocal=*/false, /*CanAutoHide=*/false);\n  if (parseToken(lltok::colon, \"expected ':' here\") ||\n      parseToken(lltok::lparen, \"expected '(' here\") ||\n      parseModuleReference(ModulePath) ||\n      parseToken(lltok::comma, \"expected ',' here\") || parseGVFlags(GVFlags) ||\n      parseToken(lltok::comma, \"expected ',' here\") ||\n      parseToken(lltok::kw_aliasee, \"expected 'aliasee' here\") ||\n      parseToken(lltok::colon, \"expected ':' here\"))\n    return true;\n\n  ValueInfo AliaseeVI;\n  unsigned GVId;\n  if (parseGVReference(AliaseeVI, GVId))\n    return true;\n\n  if (parseToken(lltok::rparen, \"expected ')' here\"))\n    return true;\n\n  auto AS = std::make_unique<AliasSummary>(GVFlags);\n\n  AS->setModulePath(ModulePath);\n\n  // Record forward reference if the aliasee is not parsed yet.\n  if (AliaseeVI.getRef() == FwdVIRef) {\n    ForwardRefAliasees[GVId].emplace_back(AS.get(), Loc);\n  } else {\n    auto Summary = Index->findSummaryInModule(AliaseeVI, ModulePath);\n    assert(Summary && \"Aliasee must be a definition\");\n    AS->setAliasee(AliaseeVI, Summary);\n  }\n\n  addGlobalValueToIndex(Name, GUID, (GlobalValue::LinkageTypes)GVFlags.Linkage,\n                        ID, std::move(AS));\n\n  return false;\n}\n\n/// Flag\n///   ::= [0|1]\nbool LLParser::parseFlag(unsigned &Val) {\n  if (Lex.getKind() != lltok::APSInt || Lex.getAPSIntVal().isSigned())\n    return tokError(\"expected integer\");\n  Val = (unsigned)Lex.getAPSIntVal().getBoolValue();\n  Lex.Lex();\n  return false;\n}\n\n/// OptionalFFlags\n///   := 'funcFlags' ':' '(' ['readNone' ':' Flag]?\n///        [',' 'readOnly' ':' Flag]? [',' 'noRecurse' ':' Flag]?\n///        [',' 'returnDoesNotAlias' ':' Flag]? ')'\n///        [',' 'noInline' ':' Flag]? ')'\n///        [',' 'alwaysInline' ':' Flag]? ')'\n\nbool LLParser::parseOptionalFFlags(FunctionSummary::FFlags &FFlags) {\n  assert(Lex.getKind() == lltok::kw_funcFlags);\n  Lex.Lex();\n\n  if (parseToken(lltok::colon, \"expected ':' in funcFlags\") |\n      parseToken(lltok::lparen, \"expected '(' in funcFlags\"))\n    return true;\n\n  do {\n    unsigned Val = 0;\n    switch (Lex.getKind()) {\n    case lltok::kw_readNone:\n      Lex.Lex();\n      if (parseToken(lltok::colon, \"expected ':'\") || parseFlag(Val))\n        return true;\n      FFlags.ReadNone = Val;\n      break;\n    case lltok::kw_readOnly:\n      Lex.Lex();\n      if (parseToken(lltok::colon, \"expected ':'\") || parseFlag(Val))\n        return true;\n      FFlags.ReadOnly = Val;\n      break;\n    case lltok::kw_noRecurse:\n      Lex.Lex();\n      if (parseToken(lltok::colon, \"expected ':'\") || parseFlag(Val))\n        return true;\n      FFlags.NoRecurse = Val;\n      break;\n    case lltok::kw_returnDoesNotAlias:\n      Lex.Lex();\n      if (parseToken(lltok::colon, \"expected ':'\") || parseFlag(Val))\n        return true;\n      FFlags.ReturnDoesNotAlias = Val;\n      break;\n    case lltok::kw_noInline:\n      Lex.Lex();\n      if (parseToken(lltok::colon, \"expected ':'\") || parseFlag(Val))\n        return true;\n      FFlags.NoInline = Val;\n      break;\n    case lltok::kw_alwaysInline:\n      Lex.Lex();\n      if (parseToken(lltok::colon, \"expected ':'\") || parseFlag(Val))\n        return true;\n      FFlags.AlwaysInline = Val;\n      break;\n    default:\n      return error(Lex.getLoc(), \"expected function flag type\");\n    }\n  } while (EatIfPresent(lltok::comma));\n\n  if (parseToken(lltok::rparen, \"expected ')' in funcFlags\"))\n    return true;\n\n  return false;\n}\n\n/// OptionalCalls\n///   := 'calls' ':' '(' Call [',' Call]* ')'\n/// Call ::= '(' 'callee' ':' GVReference\n///            [( ',' 'hotness' ':' Hotness | ',' 'relbf' ':' UInt32 )]? ')'\nbool LLParser::parseOptionalCalls(std::vector<FunctionSummary::EdgeTy> &Calls) {\n  assert(Lex.getKind() == lltok::kw_calls);\n  Lex.Lex();\n\n  if (parseToken(lltok::colon, \"expected ':' in calls\") |\n      parseToken(lltok::lparen, \"expected '(' in calls\"))\n    return true;\n\n  IdToIndexMapType IdToIndexMap;\n  // parse each call edge\n  do {\n    ValueInfo VI;\n    if (parseToken(lltok::lparen, \"expected '(' in call\") ||\n        parseToken(lltok::kw_callee, \"expected 'callee' in call\") ||\n        parseToken(lltok::colon, \"expected ':'\"))\n      return true;\n\n    LocTy Loc = Lex.getLoc();\n    unsigned GVId;\n    if (parseGVReference(VI, GVId))\n      return true;\n\n    CalleeInfo::HotnessType Hotness = CalleeInfo::HotnessType::Unknown;\n    unsigned RelBF = 0;\n    if (EatIfPresent(lltok::comma)) {\n      // Expect either hotness or relbf\n      if (EatIfPresent(lltok::kw_hotness)) {\n        if (parseToken(lltok::colon, \"expected ':'\") || parseHotness(Hotness))\n          return true;\n      } else {\n        if (parseToken(lltok::kw_relbf, \"expected relbf\") ||\n            parseToken(lltok::colon, \"expected ':'\") || parseUInt32(RelBF))\n          return true;\n      }\n    }\n    // Keep track of the Call array index needing a forward reference.\n    // We will save the location of the ValueInfo needing an update, but\n    // can only do so once the std::vector is finalized.\n    if (VI.getRef() == FwdVIRef)\n      IdToIndexMap[GVId].push_back(std::make_pair(Calls.size(), Loc));\n    Calls.push_back(FunctionSummary::EdgeTy{VI, CalleeInfo(Hotness, RelBF)});\n\n    if (parseToken(lltok::rparen, \"expected ')' in call\"))\n      return true;\n  } while (EatIfPresent(lltok::comma));\n\n  // Now that the Calls vector is finalized, it is safe to save the locations\n  // of any forward GV references that need updating later.\n  for (auto I : IdToIndexMap) {\n    auto &Infos = ForwardRefValueInfos[I.first];\n    for (auto P : I.second) {\n      assert(Calls[P.first].first.getRef() == FwdVIRef &&\n             \"Forward referenced ValueInfo expected to be empty\");\n      Infos.emplace_back(&Calls[P.first].first, P.second);\n    }\n  }\n\n  if (parseToken(lltok::rparen, \"expected ')' in calls\"))\n    return true;\n\n  return false;\n}\n\n/// Hotness\n///   := ('unknown'|'cold'|'none'|'hot'|'critical')\nbool LLParser::parseHotness(CalleeInfo::HotnessType &Hotness) {\n  switch (Lex.getKind()) {\n  case lltok::kw_unknown:\n    Hotness = CalleeInfo::HotnessType::Unknown;\n    break;\n  case lltok::kw_cold:\n    Hotness = CalleeInfo::HotnessType::Cold;\n    break;\n  case lltok::kw_none:\n    Hotness = CalleeInfo::HotnessType::None;\n    break;\n  case lltok::kw_hot:\n    Hotness = CalleeInfo::HotnessType::Hot;\n    break;\n  case lltok::kw_critical:\n    Hotness = CalleeInfo::HotnessType::Critical;\n    break;\n  default:\n    return error(Lex.getLoc(), \"invalid call edge hotness\");\n  }\n  Lex.Lex();\n  return false;\n}\n\n/// OptionalVTableFuncs\n///   := 'vTableFuncs' ':' '(' VTableFunc [',' VTableFunc]* ')'\n/// VTableFunc ::= '(' 'virtFunc' ':' GVReference ',' 'offset' ':' UInt64 ')'\nbool LLParser::parseOptionalVTableFuncs(VTableFuncList &VTableFuncs) {\n  assert(Lex.getKind() == lltok::kw_vTableFuncs);\n  Lex.Lex();\n\n  if (parseToken(lltok::colon, \"expected ':' in vTableFuncs\") |\n      parseToken(lltok::lparen, \"expected '(' in vTableFuncs\"))\n    return true;\n\n  IdToIndexMapType IdToIndexMap;\n  // parse each virtual function pair\n  do {\n    ValueInfo VI;\n    if (parseToken(lltok::lparen, \"expected '(' in vTableFunc\") ||\n        parseToken(lltok::kw_virtFunc, \"expected 'callee' in vTableFunc\") ||\n        parseToken(lltok::colon, \"expected ':'\"))\n      return true;\n\n    LocTy Loc = Lex.getLoc();\n    unsigned GVId;\n    if (parseGVReference(VI, GVId))\n      return true;\n\n    uint64_t Offset;\n    if (parseToken(lltok::comma, \"expected comma\") ||\n        parseToken(lltok::kw_offset, \"expected offset\") ||\n        parseToken(lltok::colon, \"expected ':'\") || parseUInt64(Offset))\n      return true;\n\n    // Keep track of the VTableFuncs array index needing a forward reference.\n    // We will save the location of the ValueInfo needing an update, but\n    // can only do so once the std::vector is finalized.\n    if (VI == EmptyVI)\n      IdToIndexMap[GVId].push_back(std::make_pair(VTableFuncs.size(), Loc));\n    VTableFuncs.push_back({VI, Offset});\n\n    if (parseToken(lltok::rparen, \"expected ')' in vTableFunc\"))\n      return true;\n  } while (EatIfPresent(lltok::comma));\n\n  // Now that the VTableFuncs vector is finalized, it is safe to save the\n  // locations of any forward GV references that need updating later.\n  for (auto I : IdToIndexMap) {\n    auto &Infos = ForwardRefValueInfos[I.first];\n    for (auto P : I.second) {\n      assert(VTableFuncs[P.first].FuncVI == EmptyVI &&\n             \"Forward referenced ValueInfo expected to be empty\");\n      Infos.emplace_back(&VTableFuncs[P.first].FuncVI, P.second);\n    }\n  }\n\n  if (parseToken(lltok::rparen, \"expected ')' in vTableFuncs\"))\n    return true;\n\n  return false;\n}\n\n/// ParamNo := 'param' ':' UInt64\nbool LLParser::parseParamNo(uint64_t &ParamNo) {\n  if (parseToken(lltok::kw_param, \"expected 'param' here\") ||\n      parseToken(lltok::colon, \"expected ':' here\") || parseUInt64(ParamNo))\n    return true;\n  return false;\n}\n\n/// ParamAccessOffset := 'offset' ':' '[' APSINTVAL ',' APSINTVAL ']'\nbool LLParser::parseParamAccessOffset(ConstantRange &Range) {\n  APSInt Lower;\n  APSInt Upper;\n  auto ParseAPSInt = [&](APSInt &Val) {\n    if (Lex.getKind() != lltok::APSInt)\n      return tokError(\"expected integer\");\n    Val = Lex.getAPSIntVal();\n    Val = Val.extOrTrunc(FunctionSummary::ParamAccess::RangeWidth);\n    Val.setIsSigned(true);\n    Lex.Lex();\n    return false;\n  };\n  if (parseToken(lltok::kw_offset, \"expected 'offset' here\") ||\n      parseToken(lltok::colon, \"expected ':' here\") ||\n      parseToken(lltok::lsquare, \"expected '[' here\") || ParseAPSInt(Lower) ||\n      parseToken(lltok::comma, \"expected ',' here\") || ParseAPSInt(Upper) ||\n      parseToken(lltok::rsquare, \"expected ']' here\"))\n    return true;\n\n  ++Upper;\n  Range =\n      (Lower == Upper && !Lower.isMaxValue())\n          ? ConstantRange::getEmpty(FunctionSummary::ParamAccess::RangeWidth)\n          : ConstantRange(Lower, Upper);\n\n  return false;\n}\n\n/// ParamAccessCall\n///   := '(' 'callee' ':' GVReference ',' ParamNo ',' ParamAccessOffset ')'\nbool LLParser::parseParamAccessCall(FunctionSummary::ParamAccess::Call &Call,\n                                    IdLocListType &IdLocList) {\n  if (parseToken(lltok::lparen, \"expected '(' here\") ||\n      parseToken(lltok::kw_callee, \"expected 'callee' here\") ||\n      parseToken(lltok::colon, \"expected ':' here\"))\n    return true;\n\n  unsigned GVId;\n  ValueInfo VI;\n  LocTy Loc = Lex.getLoc();\n  if (parseGVReference(VI, GVId))\n    return true;\n\n  Call.Callee = VI;\n  IdLocList.emplace_back(GVId, Loc);\n\n  if (parseToken(lltok::comma, \"expected ',' here\") ||\n      parseParamNo(Call.ParamNo) ||\n      parseToken(lltok::comma, \"expected ',' here\") ||\n      parseParamAccessOffset(Call.Offsets))\n    return true;\n\n  if (parseToken(lltok::rparen, \"expected ')' here\"))\n    return true;\n\n  return false;\n}\n\n/// ParamAccess\n///   := '(' ParamNo ',' ParamAccessOffset [',' OptionalParamAccessCalls]? ')'\n/// OptionalParamAccessCalls := '(' Call [',' Call]* ')'\nbool LLParser::parseParamAccess(FunctionSummary::ParamAccess &Param,\n                                IdLocListType &IdLocList) {\n  if (parseToken(lltok::lparen, \"expected '(' here\") ||\n      parseParamNo(Param.ParamNo) ||\n      parseToken(lltok::comma, \"expected ',' here\") ||\n      parseParamAccessOffset(Param.Use))\n    return true;\n\n  if (EatIfPresent(lltok::comma)) {\n    if (parseToken(lltok::kw_calls, \"expected 'calls' here\") ||\n        parseToken(lltok::colon, \"expected ':' here\") ||\n        parseToken(lltok::lparen, \"expected '(' here\"))\n      return true;\n    do {\n      FunctionSummary::ParamAccess::Call Call;\n      if (parseParamAccessCall(Call, IdLocList))\n        return true;\n      Param.Calls.push_back(Call);\n    } while (EatIfPresent(lltok::comma));\n\n    if (parseToken(lltok::rparen, \"expected ')' here\"))\n      return true;\n  }\n\n  if (parseToken(lltok::rparen, \"expected ')' here\"))\n    return true;\n\n  return false;\n}\n\n/// OptionalParamAccesses\n///   := 'params' ':' '(' ParamAccess [',' ParamAccess]* ')'\nbool LLParser::parseOptionalParamAccesses(\n    std::vector<FunctionSummary::ParamAccess> &Params) {\n  assert(Lex.getKind() == lltok::kw_params);\n  Lex.Lex();\n\n  if (parseToken(lltok::colon, \"expected ':' here\") ||\n      parseToken(lltok::lparen, \"expected '(' here\"))\n    return true;\n\n  IdLocListType VContexts;\n  size_t CallsNum = 0;\n  do {\n    FunctionSummary::ParamAccess ParamAccess;\n    if (parseParamAccess(ParamAccess, VContexts))\n      return true;\n    CallsNum += ParamAccess.Calls.size();\n    assert(VContexts.size() == CallsNum);\n    Params.emplace_back(std::move(ParamAccess));\n  } while (EatIfPresent(lltok::comma));\n\n  if (parseToken(lltok::rparen, \"expected ')' here\"))\n    return true;\n\n  // Now that the Params is finalized, it is safe to save the locations\n  // of any forward GV references that need updating later.\n  IdLocListType::const_iterator ItContext = VContexts.begin();\n  for (auto &PA : Params) {\n    for (auto &C : PA.Calls) {\n      if (C.Callee.getRef() == FwdVIRef)\n        ForwardRefValueInfos[ItContext->first].emplace_back(&C.Callee,\n                                                            ItContext->second);\n      ++ItContext;\n    }\n  }\n  assert(ItContext == VContexts.end());\n\n  return false;\n}\n\n/// OptionalRefs\n///   := 'refs' ':' '(' GVReference [',' GVReference]* ')'\nbool LLParser::parseOptionalRefs(std::vector<ValueInfo> &Refs) {\n  assert(Lex.getKind() == lltok::kw_refs);\n  Lex.Lex();\n\n  if (parseToken(lltok::colon, \"expected ':' in refs\") ||\n      parseToken(lltok::lparen, \"expected '(' in refs\"))\n    return true;\n\n  struct ValueContext {\n    ValueInfo VI;\n    unsigned GVId;\n    LocTy Loc;\n  };\n  std::vector<ValueContext> VContexts;\n  // parse each ref edge\n  do {\n    ValueContext VC;\n    VC.Loc = Lex.getLoc();\n    if (parseGVReference(VC.VI, VC.GVId))\n      return true;\n    VContexts.push_back(VC);\n  } while (EatIfPresent(lltok::comma));\n\n  // Sort value contexts so that ones with writeonly\n  // and readonly ValueInfo  are at the end of VContexts vector.\n  // See FunctionSummary::specialRefCounts()\n  llvm::sort(VContexts, [](const ValueContext &VC1, const ValueContext &VC2) {\n    return VC1.VI.getAccessSpecifier() < VC2.VI.getAccessSpecifier();\n  });\n\n  IdToIndexMapType IdToIndexMap;\n  for (auto &VC : VContexts) {\n    // Keep track of the Refs array index needing a forward reference.\n    // We will save the location of the ValueInfo needing an update, but\n    // can only do so once the std::vector is finalized.\n    if (VC.VI.getRef() == FwdVIRef)\n      IdToIndexMap[VC.GVId].push_back(std::make_pair(Refs.size(), VC.Loc));\n    Refs.push_back(VC.VI);\n  }\n\n  // Now that the Refs vector is finalized, it is safe to save the locations\n  // of any forward GV references that need updating later.\n  for (auto I : IdToIndexMap) {\n    auto &Infos = ForwardRefValueInfos[I.first];\n    for (auto P : I.second) {\n      assert(Refs[P.first].getRef() == FwdVIRef &&\n             \"Forward referenced ValueInfo expected to be empty\");\n      Infos.emplace_back(&Refs[P.first], P.second);\n    }\n  }\n\n  if (parseToken(lltok::rparen, \"expected ')' in refs\"))\n    return true;\n\n  return false;\n}\n\n/// OptionalTypeIdInfo\n///   := 'typeidinfo' ':' '(' [',' TypeTests]? [',' TypeTestAssumeVCalls]?\n///         [',' TypeCheckedLoadVCalls]?  [',' TypeTestAssumeConstVCalls]?\n///         [',' TypeCheckedLoadConstVCalls]? ')'\nbool LLParser::parseOptionalTypeIdInfo(\n    FunctionSummary::TypeIdInfo &TypeIdInfo) {\n  assert(Lex.getKind() == lltok::kw_typeIdInfo);\n  Lex.Lex();\n\n  if (parseToken(lltok::colon, \"expected ':' here\") ||\n      parseToken(lltok::lparen, \"expected '(' in typeIdInfo\"))\n    return true;\n\n  do {\n    switch (Lex.getKind()) {\n    case lltok::kw_typeTests:\n      if (parseTypeTests(TypeIdInfo.TypeTests))\n        return true;\n      break;\n    case lltok::kw_typeTestAssumeVCalls:\n      if (parseVFuncIdList(lltok::kw_typeTestAssumeVCalls,\n                           TypeIdInfo.TypeTestAssumeVCalls))\n        return true;\n      break;\n    case lltok::kw_typeCheckedLoadVCalls:\n      if (parseVFuncIdList(lltok::kw_typeCheckedLoadVCalls,\n                           TypeIdInfo.TypeCheckedLoadVCalls))\n        return true;\n      break;\n    case lltok::kw_typeTestAssumeConstVCalls:\n      if (parseConstVCallList(lltok::kw_typeTestAssumeConstVCalls,\n                              TypeIdInfo.TypeTestAssumeConstVCalls))\n        return true;\n      break;\n    case lltok::kw_typeCheckedLoadConstVCalls:\n      if (parseConstVCallList(lltok::kw_typeCheckedLoadConstVCalls,\n                              TypeIdInfo.TypeCheckedLoadConstVCalls))\n        return true;\n      break;\n    default:\n      return error(Lex.getLoc(), \"invalid typeIdInfo list type\");\n    }\n  } while (EatIfPresent(lltok::comma));\n\n  if (parseToken(lltok::rparen, \"expected ')' in typeIdInfo\"))\n    return true;\n\n  return false;\n}\n\n/// TypeTests\n///   ::= 'typeTests' ':' '(' (SummaryID | UInt64)\n///         [',' (SummaryID | UInt64)]* ')'\nbool LLParser::parseTypeTests(std::vector<GlobalValue::GUID> &TypeTests) {\n  assert(Lex.getKind() == lltok::kw_typeTests);\n  Lex.Lex();\n\n  if (parseToken(lltok::colon, \"expected ':' here\") ||\n      parseToken(lltok::lparen, \"expected '(' in typeIdInfo\"))\n    return true;\n\n  IdToIndexMapType IdToIndexMap;\n  do {\n    GlobalValue::GUID GUID = 0;\n    if (Lex.getKind() == lltok::SummaryID) {\n      unsigned ID = Lex.getUIntVal();\n      LocTy Loc = Lex.getLoc();\n      // Keep track of the TypeTests array index needing a forward reference.\n      // We will save the location of the GUID needing an update, but\n      // can only do so once the std::vector is finalized.\n      IdToIndexMap[ID].push_back(std::make_pair(TypeTests.size(), Loc));\n      Lex.Lex();\n    } else if (parseUInt64(GUID))\n      return true;\n    TypeTests.push_back(GUID);\n  } while (EatIfPresent(lltok::comma));\n\n  // Now that the TypeTests vector is finalized, it is safe to save the\n  // locations of any forward GV references that need updating later.\n  for (auto I : IdToIndexMap) {\n    auto &Ids = ForwardRefTypeIds[I.first];\n    for (auto P : I.second) {\n      assert(TypeTests[P.first] == 0 &&\n             \"Forward referenced type id GUID expected to be 0\");\n      Ids.emplace_back(&TypeTests[P.first], P.second);\n    }\n  }\n\n  if (parseToken(lltok::rparen, \"expected ')' in typeIdInfo\"))\n    return true;\n\n  return false;\n}\n\n/// VFuncIdList\n///   ::= Kind ':' '(' VFuncId [',' VFuncId]* ')'\nbool LLParser::parseVFuncIdList(\n    lltok::Kind Kind, std::vector<FunctionSummary::VFuncId> &VFuncIdList) {\n  assert(Lex.getKind() == Kind);\n  Lex.Lex();\n\n  if (parseToken(lltok::colon, \"expected ':' here\") ||\n      parseToken(lltok::lparen, \"expected '(' here\"))\n    return true;\n\n  IdToIndexMapType IdToIndexMap;\n  do {\n    FunctionSummary::VFuncId VFuncId;\n    if (parseVFuncId(VFuncId, IdToIndexMap, VFuncIdList.size()))\n      return true;\n    VFuncIdList.push_back(VFuncId);\n  } while (EatIfPresent(lltok::comma));\n\n  if (parseToken(lltok::rparen, \"expected ')' here\"))\n    return true;\n\n  // Now that the VFuncIdList vector is finalized, it is safe to save the\n  // locations of any forward GV references that need updating later.\n  for (auto I : IdToIndexMap) {\n    auto &Ids = ForwardRefTypeIds[I.first];\n    for (auto P : I.second) {\n      assert(VFuncIdList[P.first].GUID == 0 &&\n             \"Forward referenced type id GUID expected to be 0\");\n      Ids.emplace_back(&VFuncIdList[P.first].GUID, P.second);\n    }\n  }\n\n  return false;\n}\n\n/// ConstVCallList\n///   ::= Kind ':' '(' ConstVCall [',' ConstVCall]* ')'\nbool LLParser::parseConstVCallList(\n    lltok::Kind Kind,\n    std::vector<FunctionSummary::ConstVCall> &ConstVCallList) {\n  assert(Lex.getKind() == Kind);\n  Lex.Lex();\n\n  if (parseToken(lltok::colon, \"expected ':' here\") ||\n      parseToken(lltok::lparen, \"expected '(' here\"))\n    return true;\n\n  IdToIndexMapType IdToIndexMap;\n  do {\n    FunctionSummary::ConstVCall ConstVCall;\n    if (parseConstVCall(ConstVCall, IdToIndexMap, ConstVCallList.size()))\n      return true;\n    ConstVCallList.push_back(ConstVCall);\n  } while (EatIfPresent(lltok::comma));\n\n  if (parseToken(lltok::rparen, \"expected ')' here\"))\n    return true;\n\n  // Now that the ConstVCallList vector is finalized, it is safe to save the\n  // locations of any forward GV references that need updating later.\n  for (auto I : IdToIndexMap) {\n    auto &Ids = ForwardRefTypeIds[I.first];\n    for (auto P : I.second) {\n      assert(ConstVCallList[P.first].VFunc.GUID == 0 &&\n             \"Forward referenced type id GUID expected to be 0\");\n      Ids.emplace_back(&ConstVCallList[P.first].VFunc.GUID, P.second);\n    }\n  }\n\n  return false;\n}\n\n/// ConstVCall\n///   ::= '(' VFuncId ',' Args ')'\nbool LLParser::parseConstVCall(FunctionSummary::ConstVCall &ConstVCall,\n                               IdToIndexMapType &IdToIndexMap, unsigned Index) {\n  if (parseToken(lltok::lparen, \"expected '(' here\") ||\n      parseVFuncId(ConstVCall.VFunc, IdToIndexMap, Index))\n    return true;\n\n  if (EatIfPresent(lltok::comma))\n    if (parseArgs(ConstVCall.Args))\n      return true;\n\n  if (parseToken(lltok::rparen, \"expected ')' here\"))\n    return true;\n\n  return false;\n}\n\n/// VFuncId\n///   ::= 'vFuncId' ':' '(' (SummaryID | 'guid' ':' UInt64) ','\n///         'offset' ':' UInt64 ')'\nbool LLParser::parseVFuncId(FunctionSummary::VFuncId &VFuncId,\n                            IdToIndexMapType &IdToIndexMap, unsigned Index) {\n  assert(Lex.getKind() == lltok::kw_vFuncId);\n  Lex.Lex();\n\n  if (parseToken(lltok::colon, \"expected ':' here\") ||\n      parseToken(lltok::lparen, \"expected '(' here\"))\n    return true;\n\n  if (Lex.getKind() == lltok::SummaryID) {\n    VFuncId.GUID = 0;\n    unsigned ID = Lex.getUIntVal();\n    LocTy Loc = Lex.getLoc();\n    // Keep track of the array index needing a forward reference.\n    // We will save the location of the GUID needing an update, but\n    // can only do so once the caller's std::vector is finalized.\n    IdToIndexMap[ID].push_back(std::make_pair(Index, Loc));\n    Lex.Lex();\n  } else if (parseToken(lltok::kw_guid, \"expected 'guid' here\") ||\n             parseToken(lltok::colon, \"expected ':' here\") ||\n             parseUInt64(VFuncId.GUID))\n    return true;\n\n  if (parseToken(lltok::comma, \"expected ',' here\") ||\n      parseToken(lltok::kw_offset, \"expected 'offset' here\") ||\n      parseToken(lltok::colon, \"expected ':' here\") ||\n      parseUInt64(VFuncId.Offset) ||\n      parseToken(lltok::rparen, \"expected ')' here\"))\n    return true;\n\n  return false;\n}\n\n/// GVFlags\n///   ::= 'flags' ':' '(' 'linkage' ':' OptionalLinkageAux ','\n///         'visibility' ':' Flag 'notEligibleToImport' ':' Flag ','\n///         'live' ':' Flag ',' 'dsoLocal' ':' Flag ','\n///         'canAutoHide' ':' Flag ',' ')'\nbool LLParser::parseGVFlags(GlobalValueSummary::GVFlags &GVFlags) {\n  assert(Lex.getKind() == lltok::kw_flags);\n  Lex.Lex();\n\n  if (parseToken(lltok::colon, \"expected ':' here\") ||\n      parseToken(lltok::lparen, \"expected '(' here\"))\n    return true;\n\n  do {\n    unsigned Flag = 0;\n    switch (Lex.getKind()) {\n    case lltok::kw_linkage:\n      Lex.Lex();\n      if (parseToken(lltok::colon, \"expected ':'\"))\n        return true;\n      bool HasLinkage;\n      GVFlags.Linkage = parseOptionalLinkageAux(Lex.getKind(), HasLinkage);\n      assert(HasLinkage && \"Linkage not optional in summary entry\");\n      Lex.Lex();\n      break;\n    case lltok::kw_visibility:\n      Lex.Lex();\n      if (parseToken(lltok::colon, \"expected ':'\"))\n        return true;\n      parseOptionalVisibility(Flag);\n      GVFlags.Visibility = Flag;\n      break;\n    case lltok::kw_notEligibleToImport:\n      Lex.Lex();\n      if (parseToken(lltok::colon, \"expected ':'\") || parseFlag(Flag))\n        return true;\n      GVFlags.NotEligibleToImport = Flag;\n      break;\n    case lltok::kw_live:\n      Lex.Lex();\n      if (parseToken(lltok::colon, \"expected ':'\") || parseFlag(Flag))\n        return true;\n      GVFlags.Live = Flag;\n      break;\n    case lltok::kw_dsoLocal:\n      Lex.Lex();\n      if (parseToken(lltok::colon, \"expected ':'\") || parseFlag(Flag))\n        return true;\n      GVFlags.DSOLocal = Flag;\n      break;\n    case lltok::kw_canAutoHide:\n      Lex.Lex();\n      if (parseToken(lltok::colon, \"expected ':'\") || parseFlag(Flag))\n        return true;\n      GVFlags.CanAutoHide = Flag;\n      break;\n    default:\n      return error(Lex.getLoc(), \"expected gv flag type\");\n    }\n  } while (EatIfPresent(lltok::comma));\n\n  if (parseToken(lltok::rparen, \"expected ')' here\"))\n    return true;\n\n  return false;\n}\n\n/// GVarFlags\n///   ::= 'varFlags' ':' '(' 'readonly' ':' Flag\n///                      ',' 'writeonly' ':' Flag\n///                      ',' 'constant' ':' Flag ')'\nbool LLParser::parseGVarFlags(GlobalVarSummary::GVarFlags &GVarFlags) {\n  assert(Lex.getKind() == lltok::kw_varFlags);\n  Lex.Lex();\n\n  if (parseToken(lltok::colon, \"expected ':' here\") ||\n      parseToken(lltok::lparen, \"expected '(' here\"))\n    return true;\n\n  auto ParseRest = [this](unsigned int &Val) {\n    Lex.Lex();\n    if (parseToken(lltok::colon, \"expected ':'\"))\n      return true;\n    return parseFlag(Val);\n  };\n\n  do {\n    unsigned Flag = 0;\n    switch (Lex.getKind()) {\n    case lltok::kw_readonly:\n      if (ParseRest(Flag))\n        return true;\n      GVarFlags.MaybeReadOnly = Flag;\n      break;\n    case lltok::kw_writeonly:\n      if (ParseRest(Flag))\n        return true;\n      GVarFlags.MaybeWriteOnly = Flag;\n      break;\n    case lltok::kw_constant:\n      if (ParseRest(Flag))\n        return true;\n      GVarFlags.Constant = Flag;\n      break;\n    case lltok::kw_vcall_visibility:\n      if (ParseRest(Flag))\n        return true;\n      GVarFlags.VCallVisibility = Flag;\n      break;\n    default:\n      return error(Lex.getLoc(), \"expected gvar flag type\");\n    }\n  } while (EatIfPresent(lltok::comma));\n  return parseToken(lltok::rparen, \"expected ')' here\");\n}\n\n/// ModuleReference\n///   ::= 'module' ':' UInt\nbool LLParser::parseModuleReference(StringRef &ModulePath) {\n  // parse module id.\n  if (parseToken(lltok::kw_module, \"expected 'module' here\") ||\n      parseToken(lltok::colon, \"expected ':' here\") ||\n      parseToken(lltok::SummaryID, \"expected module ID\"))\n    return true;\n\n  unsigned ModuleID = Lex.getUIntVal();\n  auto I = ModuleIdMap.find(ModuleID);\n  // We should have already parsed all module IDs\n  assert(I != ModuleIdMap.end());\n  ModulePath = I->second;\n  return false;\n}\n\n/// GVReference\n///   ::= SummaryID\nbool LLParser::parseGVReference(ValueInfo &VI, unsigned &GVId) {\n  bool WriteOnly = false, ReadOnly = EatIfPresent(lltok::kw_readonly);\n  if (!ReadOnly)\n    WriteOnly = EatIfPresent(lltok::kw_writeonly);\n  if (parseToken(lltok::SummaryID, \"expected GV ID\"))\n    return true;\n\n  GVId = Lex.getUIntVal();\n  // Check if we already have a VI for this GV\n  if (GVId < NumberedValueInfos.size()) {\n    assert(NumberedValueInfos[GVId].getRef() != FwdVIRef);\n    VI = NumberedValueInfos[GVId];\n  } else\n    // We will create a forward reference to the stored location.\n    VI = ValueInfo(false, FwdVIRef);\n\n  if (ReadOnly)\n    VI.setReadOnly();\n  if (WriteOnly)\n    VI.setWriteOnly();\n  return false;\n}\n"}}, "reports": [{"events": [{"location": {"col": 10, "file": 27, "line": 294}, "message": "move constructor 'GVFlags' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/IR/ModuleSummaryIndex.h", "reportHash": "b9a3bff1964baf607a8b69d4b4a7cd7e", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 10, "file": 27, "line": 527}, "message": "default constructor 'VFuncId' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/IR/ModuleSummaryIndex.h", "reportHash": "59137c2561b5106e990aeb23627b6e7e", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 10, "file": 27, "line": 535}, "message": "default constructor 'ConstVCall' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/IR/ModuleSummaryIndex.h", "reportHash": "cab11d104f3e5abf3e69b72e7357fed6", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 10, "file": 27, "line": 542}, "message": "default constructor 'TypeIdInfo' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/IR/ModuleSummaryIndex.h", "reportHash": "ef06d8a119447fbfd70b38fd30c24ccf", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 27, "line": 935}, "message": "default constructor 'WholeProgramDevirtResolution' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/IR/ModuleSummaryIndex.h", "reportHash": "2a0ccd7eb3c21237857a2ca151c3549b", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 10, "file": 27, "line": 946}, "message": "default constructor 'ByArg' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/IR/ModuleSummaryIndex.h", "reportHash": "c2f4f0546f17704a5ccccad647247321", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 9, "file": 37, "line": 28}, "message": "destructor '~LLLexer' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/lib/AsmParser/LLLexer.h", "reportHash": "52171c1384418df0e91177a8b7989c1a", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 38, "line": 4099}, "message": "destructor '~MDBoolField' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/lib/AsmParser/LLParser.cpp", "reportHash": "9fda5a970932c233c42e7217d7e01e93", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 38, "line": 4099}, "message": "move constructor 'MDBoolField' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/lib/AsmParser/LLParser.cpp", "reportHash": "5201c4a1edd80dd82a7ed3fffb3d9cfd", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 20, "file": 38, "line": 4360}, "message": "destructor '~' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/lib/AsmParser/LLParser.cpp", "reportHash": "a92deff81a220f42af25cb53e8cedde0", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 20, "file": 38, "line": 4360}, "message": "move constructor '' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/lib/AsmParser/LLParser.cpp", "reportHash": "5b84ed8ac2b5c28dad7d860553915230", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 20, "file": 38, "line": 4400}, "message": "destructor '~' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/lib/AsmParser/LLParser.cpp", "reportHash": "16f4d11074587857abe18be0e67c8d6a", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 20, "file": 38, "line": 4400}, "message": "move constructor '' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/lib/AsmParser/LLParser.cpp", "reportHash": "97860bca49db4068c39b433fbf413ccf", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 13, "file": 38, "line": 4611}, "message": "expanded from macro 'PARSE_MD_FIELDS'"}, {"location": {"col": 3, "file": 38, "line": 4633}, "message": "destructor '~' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/lib/AsmParser/LLParser.cpp", "reportHash": "a90e2e1cc3feb297ff7707c7b72dfca4", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 13, "file": 38, "line": 4611}, "message": "expanded from macro 'PARSE_MD_FIELDS'"}, {"location": {"col": 3, "file": 38, "line": 4649}, "message": "destructor '~' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/lib/AsmParser/LLParser.cpp", "reportHash": "a90e2e1cc3feb297ff7707c7b72dfca4", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 13, "file": 38, "line": 4611}, "message": "expanded from macro 'PARSE_MD_FIELDS'"}, {"location": {"col": 3, "file": 38, "line": 4667}, "message": "destructor '~' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/lib/AsmParser/LLParser.cpp", "reportHash": "a90e2e1cc3feb297ff7707c7b72dfca4", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 25, "file": 38, "line": 4680}, "message": "destructor '~' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/lib/AsmParser/LLParser.cpp", "reportHash": "ea4c2dae19397d3a820a96bf7cc6b768", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 25, "file": 38, "line": 4680}, "message": "move constructor '' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/lib/AsmParser/LLParser.cpp", "reportHash": "01a8cccfefcfc151c10c38736e77fa5e", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 13, "file": 38, "line": 4611}, "message": "expanded from macro 'PARSE_MD_FIELDS'"}, {"location": {"col": 3, "file": 38, "line": 4708}, "message": "destructor '~' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/lib/AsmParser/LLParser.cpp", "reportHash": "a90e2e1cc3feb297ff7707c7b72dfca4", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 25, "file": 38, "line": 4711}, "message": "destructor '~' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/lib/AsmParser/LLParser.cpp", "reportHash": "62c362089d2bdb21ef65a93b3f93bdf5", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 25, "file": 38, "line": 4711}, "message": "move constructor '' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/lib/AsmParser/LLParser.cpp", "reportHash": "bfbabb4c03b309da074621ca97b84032", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 13, "file": 38, "line": 4611}, "message": "expanded from macro 'PARSE_MD_FIELDS'"}, {"location": {"col": 3, "file": 38, "line": 4739}, "message": "destructor '~' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/lib/AsmParser/LLParser.cpp", "reportHash": "a90e2e1cc3feb297ff7707c7b72dfca4", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 13, "file": 38, "line": 4611}, "message": "expanded from macro 'PARSE_MD_FIELDS'"}, {"location": {"col": 3, "file": 38, "line": 4768}, "message": "destructor '~' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/lib/AsmParser/LLParser.cpp", "reportHash": "a90e2e1cc3feb297ff7707c7b72dfca4", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 13, "file": 38, "line": 4611}, "message": "expanded from macro 'PARSE_MD_FIELDS'"}, {"location": {"col": 3, "file": 38, "line": 4787}, "message": "destructor '~' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/lib/AsmParser/LLParser.cpp", "reportHash": "a90e2e1cc3feb297ff7707c7b72dfca4", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 13, "file": 38, "line": 4611}, "message": "expanded from macro 'PARSE_MD_FIELDS'"}, {"location": {"col": 3, "file": 38, "line": 4816}, "message": "destructor '~' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/lib/AsmParser/LLParser.cpp", "reportHash": "a90e2e1cc3feb297ff7707c7b72dfca4", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 13, "file": 38, "line": 4611}, "message": "expanded from macro 'PARSE_MD_FIELDS'"}, {"location": {"col": 3, "file": 38, "line": 4853}, "message": "destructor '~' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/lib/AsmParser/LLParser.cpp", "reportHash": "a90e2e1cc3feb297ff7707c7b72dfca4", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 13, "file": 38, "line": 4611}, "message": "expanded from macro 'PARSE_MD_FIELDS'"}, {"location": {"col": 3, "file": 38, "line": 4892}, "message": "destructor '~' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/lib/AsmParser/LLParser.cpp", "reportHash": "a90e2e1cc3feb297ff7707c7b72dfca4", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 13, "file": 38, "line": 4611}, "message": "expanded from macro 'PARSE_MD_FIELDS'"}, {"location": {"col": 3, "file": 38, "line": 4915}, "message": "destructor '~' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/lib/AsmParser/LLParser.cpp", "reportHash": "a90e2e1cc3feb297ff7707c7b72dfca4", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 13, "file": 38, "line": 4611}, "message": "expanded from macro 'PARSE_MD_FIELDS'"}, {"location": {"col": 3, "file": 38, "line": 4964}, "message": "destructor '~' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/lib/AsmParser/LLParser.cpp", "reportHash": "a90e2e1cc3feb297ff7707c7b72dfca4", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 13, "file": 38, "line": 4611}, "message": "expanded from macro 'PARSE_MD_FIELDS'"}, {"location": {"col": 3, "file": 38, "line": 5008}, "message": "destructor '~' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/lib/AsmParser/LLParser.cpp", "reportHash": "a90e2e1cc3feb297ff7707c7b72dfca4", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 13, "file": 38, "line": 4611}, "message": "expanded from macro 'PARSE_MD_FIELDS'"}, {"location": {"col": 3, "file": 38, "line": 5038}, "message": "destructor '~' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/lib/AsmParser/LLParser.cpp", "reportHash": "a90e2e1cc3feb297ff7707c7b72dfca4", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 13, "file": 38, "line": 4611}, "message": "expanded from macro 'PARSE_MD_FIELDS'"}, {"location": {"col": 3, "file": 38, "line": 5053}, "message": "destructor '~' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/lib/AsmParser/LLParser.cpp", "reportHash": "a90e2e1cc3feb297ff7707c7b72dfca4", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 13, "file": 38, "line": 4611}, "message": "expanded from macro 'PARSE_MD_FIELDS'"}, {"location": {"col": 3, "file": 38, "line": 5070}, "message": "destructor '~' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/lib/AsmParser/LLParser.cpp", "reportHash": "a90e2e1cc3feb297ff7707c7b72dfca4", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 13, "file": 38, "line": 4611}, "message": "expanded from macro 'PARSE_MD_FIELDS'"}, {"location": {"col": 3, "file": 38, "line": 5086}, "message": "destructor '~' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/lib/AsmParser/LLParser.cpp", "reportHash": "a90e2e1cc3feb297ff7707c7b72dfca4", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 13, "file": 38, "line": 4611}, "message": "expanded from macro 'PARSE_MD_FIELDS'"}, {"location": {"col": 3, "file": 38, "line": 5103}, "message": "destructor '~' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/lib/AsmParser/LLParser.cpp", "reportHash": "a90e2e1cc3feb297ff7707c7b72dfca4", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 13, "file": 38, "line": 4611}, "message": "expanded from macro 'PARSE_MD_FIELDS'"}, {"location": {"col": 3, "file": 38, "line": 5119}, "message": "destructor '~' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/lib/AsmParser/LLParser.cpp", "reportHash": "a90e2e1cc3feb297ff7707c7b72dfca4", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 13, "file": 38, "line": 4611}, "message": "expanded from macro 'PARSE_MD_FIELDS'"}, {"location": {"col": 3, "file": 38, "line": 5141}, "message": "destructor '~' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/lib/AsmParser/LLParser.cpp", "reportHash": "a90e2e1cc3feb297ff7707c7b72dfca4", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 13, "file": 38, "line": 4611}, "message": "expanded from macro 'PARSE_MD_FIELDS'"}, {"location": {"col": 3, "file": 38, "line": 5157}, "message": "destructor '~' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/lib/AsmParser/LLParser.cpp", "reportHash": "a90e2e1cc3feb297ff7707c7b72dfca4", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 13, "file": 38, "line": 4611}, "message": "expanded from macro 'PARSE_MD_FIELDS'"}, {"location": {"col": 3, "file": 38, "line": 5177}, "message": "destructor '~' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/lib/AsmParser/LLParser.cpp", "reportHash": "a90e2e1cc3feb297ff7707c7b72dfca4", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 13, "file": 38, "line": 4611}, "message": "expanded from macro 'PARSE_MD_FIELDS'"}, {"location": {"col": 3, "file": 38, "line": 5204}, "message": "destructor '~' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/lib/AsmParser/LLParser.cpp", "reportHash": "a90e2e1cc3feb297ff7707c7b72dfca4", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 13, "file": 38, "line": 4611}, "message": "expanded from macro 'PARSE_MD_FIELDS'"}, {"location": {"col": 3, "file": 38, "line": 5232}, "message": "destructor '~' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/lib/AsmParser/LLParser.cpp", "reportHash": "a90e2e1cc3feb297ff7707c7b72dfca4", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 13, "file": 38, "line": 4611}, "message": "expanded from macro 'PARSE_MD_FIELDS'"}, {"location": {"col": 3, "file": 38, "line": 5249}, "message": "destructor '~' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/lib/AsmParser/LLParser.cpp", "reportHash": "a90e2e1cc3feb297ff7707c7b72dfca4", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 13, "file": 38, "line": 4611}, "message": "expanded from macro 'PARSE_MD_FIELDS'"}, {"location": {"col": 3, "file": 38, "line": 5342}, "message": "destructor '~' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/lib/AsmParser/LLParser.cpp", "reportHash": "a90e2e1cc3feb297ff7707c7b72dfca4", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 13, "file": 38, "line": 4611}, "message": "expanded from macro 'PARSE_MD_FIELDS'"}, {"location": {"col": 3, "file": 38, "line": 5362}, "message": "destructor '~' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/lib/AsmParser/LLParser.cpp", "reportHash": "a90e2e1cc3feb297ff7707c7b72dfca4", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 13, "file": 38, "line": 4611}, "message": "expanded from macro 'PARSE_MD_FIELDS'"}, {"location": {"col": 3, "file": 38, "line": 5382}, "message": "destructor '~' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/lib/AsmParser/LLParser.cpp", "reportHash": "a90e2e1cc3feb297ff7707c7b72dfca4", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 18, "file": 38, "line": 7809}, "message": "destructor '~' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/lib/AsmParser/LLParser.cpp", "reportHash": "34ce47ca2902f97d54574dec74aa3c89", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 22, "file": 38, "line": 8983}, "message": "destructor '~' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/lib/AsmParser/LLParser.cpp", "reportHash": "7858dc15e13b23c1e113cacab38dde5e", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 22, "file": 38, "line": 8983}, "message": "move constructor '' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/lib/AsmParser/LLParser.cpp", "reportHash": "469d8aa54de41d043212be468fbb8917", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 10, "file": 38, "line": 9122}, "message": "default constructor 'ValueContext' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/lib/AsmParser/LLParser.cpp", "reportHash": "7525002cc73f79f9c5d1747d797e0e11", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 20, "file": 38, "line": 9471}, "message": "destructor '~' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/lib/AsmParser/LLParser.cpp", "reportHash": "5a844cac5e70cd84b726bfcc5a7c8434", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 20, "file": 38, "line": 9471}, "message": "move constructor '' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/lib/AsmParser/LLParser.cpp", "reportHash": "ae3b55afd414b9b44db1f8d12ad10558", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}]};
      window.onload = function() {
        if (!browserCompatible) {
          setNonCompatibleBrowserMessage();
        } else {
          BugViewer.init(data.files, data.reports);
          BugViewer.create();
          BugViewer.initByUrl();
        }
      };
    </script>
  </head>
  <body>
  <div class="container">
    <div id="content">
      <div id="side-bar">
        <div class="header">
          <a href="index.html" class="button">&#8249; Return to List</a>
        </div>
        <div id="report-nav">
          <div class="header">Reports</div>
        </div>
      </div>
      <div id="editor-wrapper">
        <div class="header">
          <div id="file">
            <span class="label">File:</span>
            <span id="file-path"></span>
          </div>
          <div id="checker">
            <span class="label">Checker name:</span>
            <span id="checker-name"></span>
          </div>
          <div id="review-status-wrapper">
            <span class="label">Review status:</span>
            <span id="review-status"></span>
          </div>
        </div>
        <div id="editor"></div>
      </div>
    </div>
  </div>
  </body>
</html>
