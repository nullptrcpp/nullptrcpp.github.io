<!DOCTYPE html>
<html>
  <head>
    <title>Plist HTML Viewer</title>

    <meta charset="UTF-8">

    <style type="text/css">
      .CodeMirror{font-family:monospace;height:300px;color:#000;direction:ltr}.CodeMirror-lines{padding:4px 0}.CodeMirror pre{padding:0 4px}.CodeMirror-gutter-filler,.CodeMirror-scrollbar-filler{background-color:#fff}.CodeMirror-gutters{border-right:1px solid #ddd;background-color:#f7f7f7;white-space:nowrap}.CodeMirror-linenumber{padding:0 3px 0 5px;min-width:20px;text-align:right;color:#999;white-space:nowrap}.CodeMirror-guttermarker{color:#000}.CodeMirror-guttermarker-subtle{color:#999}.CodeMirror-cursor{border-left:1px solid #000;border-right:none;width:0}.CodeMirror div.CodeMirror-secondarycursor{border-left:1px solid silver}.cm-fat-cursor .CodeMirror-cursor{width:auto;border:0!important;background:#7e7}.cm-fat-cursor div.CodeMirror-cursors{z-index:1}.cm-animate-fat-cursor{width:auto;border:0;-webkit-animation:blink 1.06s steps(1) infinite;-moz-animation:blink 1.06s steps(1) infinite;animation:blink 1.06s steps(1) infinite;background-color:#7e7}@-moz-keyframes blink{50%{background-color:transparent}}@-webkit-keyframes blink{50%{background-color:transparent}}@keyframes blink{50%{background-color:transparent}}.cm-tab{display:inline-block;text-decoration:inherit}.CodeMirror-rulers{position:absolute;left:0;right:0;top:-50px;bottom:-20px;overflow:hidden}.CodeMirror-ruler{border-left:1px solid #ccc;top:0;bottom:0;position:absolute}.cm-s-default .cm-header{color:#00f}.cm-s-default .cm-quote{color:#090}.cm-negative{color:#d44}.cm-positive{color:#292}.cm-header,.cm-strong{font-weight:700}.cm-em{font-style:italic}.cm-link{text-decoration:underline}.cm-strikethrough{text-decoration:line-through}.cm-s-default .cm-keyword{color:#708}.cm-s-default .cm-atom{color:#219}.cm-s-default .cm-number{color:#164}.cm-s-default .cm-def{color:#00f}.cm-s-default .cm-variable-2{color:#05a}.cm-s-default .cm-type,.cm-s-default .cm-variable-3{color:#085}.cm-s-default .cm-comment{color:#a50}.cm-s-default .cm-string{color:#a11}.cm-s-default .cm-string-2{color:#f50}.cm-s-default .cm-meta{color:#555}.cm-s-default .cm-qualifier{color:#555}.cm-s-default .cm-builtin{color:#30a}.cm-s-default .cm-bracket{color:#997}.cm-s-default .cm-tag{color:#170}.cm-s-default .cm-attribute{color:#00c}.cm-s-default .cm-hr{color:#999}.cm-s-default .cm-link{color:#00c}.cm-s-default .cm-error{color:red}.cm-invalidchar{color:red}.CodeMirror-composing{border-bottom:2px solid}div.CodeMirror span.CodeMirror-matchingbracket{color:#0f0}div.CodeMirror span.CodeMirror-nonmatchingbracket{color:#f22}.CodeMirror-matchingtag{background:rgba(255,150,0,.3)}.CodeMirror-activeline-background{background:#e8f2ff}.CodeMirror{position:relative;overflow:hidden;background:#fff}.CodeMirror-scroll{overflow:scroll!important;margin-bottom:-30px;margin-right:-30px;padding-bottom:30px;height:100%;outline:0;position:relative}.CodeMirror-sizer{position:relative;border-right:30px solid transparent}.CodeMirror-gutter-filler,.CodeMirror-hscrollbar,.CodeMirror-scrollbar-filler,.CodeMirror-vscrollbar{position:absolute;z-index:6;display:none}.CodeMirror-vscrollbar{right:0;top:0;overflow-x:hidden;overflow-y:scroll}.CodeMirror-hscrollbar{bottom:0;left:0;overflow-y:hidden;overflow-x:scroll}.CodeMirror-scrollbar-filler{right:0;bottom:0}.CodeMirror-gutter-filler{left:0;bottom:0}.CodeMirror-gutters{position:absolute;left:0;top:0;min-height:100%;z-index:3}.CodeMirror-gutter{white-space:normal;height:100%;display:inline-block;vertical-align:top;margin-bottom:-30px}.CodeMirror-gutter-wrapper{position:absolute;z-index:4;background:0 0!important;border:none!important}.CodeMirror-gutter-background{position:absolute;top:0;bottom:0;z-index:4}.CodeMirror-gutter-elt{position:absolute;cursor:default;z-index:4}.CodeMirror-gutter-wrapper ::selection{background-color:transparent}.CodeMirror-gutter-wrapper ::-moz-selection{background-color:transparent}.CodeMirror-lines{cursor:text;min-height:1px}.CodeMirror pre{-moz-border-radius:0;-webkit-border-radius:0;border-radius:0;border-width:0;background:0 0;font-family:inherit;font-size:inherit;margin:0;white-space:pre;word-wrap:normal;line-height:inherit;color:inherit;z-index:2;position:relative;overflow:visible;-webkit-tap-highlight-color:transparent;-webkit-font-variant-ligatures:contextual;font-variant-ligatures:contextual}.CodeMirror-wrap pre{word-wrap:break-word;white-space:pre-wrap;word-break:normal}.CodeMirror-linebackground{position:absolute;left:0;right:0;top:0;bottom:0;z-index:0}.CodeMirror-linewidget{position:relative;z-index:2;overflow:auto}.CodeMirror-rtl pre{direction:rtl}.CodeMirror-code{outline:0}.CodeMirror-gutter,.CodeMirror-gutters,.CodeMirror-linenumber,.CodeMirror-scroll,.CodeMirror-sizer{-moz-box-sizing:content-box;box-sizing:content-box}.CodeMirror-measure{position:absolute;width:100%;height:0;overflow:hidden;visibility:hidden}.CodeMirror-cursor{position:absolute;pointer-events:none}.CodeMirror-measure pre{position:static}div.CodeMirror-cursors{visibility:hidden;position:relative;z-index:3}div.CodeMirror-dragcursors{visibility:visible}.CodeMirror-focused div.CodeMirror-cursors{visibility:visible}.CodeMirror-selected{background:#d9d9d9}.CodeMirror-focused .CodeMirror-selected{background:#d7d4f0}.CodeMirror-crosshair{cursor:crosshair}.CodeMirror-line::selection,.CodeMirror-line>span::selection,.CodeMirror-line>span>span::selection{background:#d7d4f0}.CodeMirror-line::-moz-selection,.CodeMirror-line>span::-moz-selection,.CodeMirror-line>span>span::-moz-selection{background:#d7d4f0}.cm-searching{background-color:#ffa;background-color:rgba(255,255,0,.4)}.cm-force-border{padding-right:.1px}@media print{.CodeMirror div.CodeMirror-cursors{visibility:hidden}}.cm-tab-wrap-hack:after{content:''}span.CodeMirror-selectedtext{background:0 0}
/*# sourceMappingURL=codemirror.min.css.map */

      .severity-low {
  background-color: #669603;
}

.severity-low:after {
  content : 'L';
}

.severity-unspecified {
  background-color: #666666;
}

.severity-unspecified:after {
  content : 'U';
}

.severity-style {
  background-color: #9932cc;
}

.severity-style:after {
  content : 'S';
}

.severity-medium {
  background-color: #a9d323;
  color: black;
}

.severity-medium:after {
  content : 'M';
}

.severity-high {
  background-color: #ffa800;
}

.severity-high:after {
  content : 'H';
}

.severity-critical {
  background-color: #e92625;
}

.severity-critical:after {
  content : 'C';
}

i[class*="severity-"] {
  line-height: normal;
  text-transform: capitalize;
  font-size: 0.8em;
  font-weight: bold;
  color: white;
  display: inline-block;
  width: 16px;
  height: 16px;
  text-align: center;
  font-family: sans-serif;
}

      html, body {
  width: 100%;
  height: 100%;
  padding: 0px;
  margin: 0px;
}

div.container {
  padding: 10px;
}

#content {
  height: 100%;
  display: block;
  overflow: hidden;
}

#content > div {
  margin: 10px;
  overflow: hidden;
  border: 1px solid #ddd;
  border-radius: 3px;
  overflow: hidden;
  height: 97%;
}

.button {
  background-color: #f1f1f1;
  text-decoration: none;
  display: inline-block;
  padding: 8px 16px;
  color: black;
  cursor: pointer;
}

.button:hover {
  background-color: #ddd;
  color: black;
}

.review-status {
  color: white;
  text-align: center;
}

.review-status-confirmed {
  background-color: #e92625;
}

.review-status-false-positive {
  background-color: grey;
}

.review-status-intentional {
  background-color: #669603;
}

      div.container {
  width: 100%;
  height: 100%;
  padding: 0px;
}

#editor-wrapper {
  margin: 10px;
}

#side-bar {
  float: left;
  width: 260px;
  margin: 0px;
}

#report-nav ul {
  list-style-type: none;
  padding: 0;
  margin: 0;
  overflow-y: auto;
  height: 100%;
}

#report-nav ul > li {
  padding: .4em;
  background-color: #fff;
  border-bottom: 1px solid rgba(0,0,0,.125);
  text-align: left;
  overflow: hidden;
  white-space: nowrap;
  text-overflow: ellipsis;
}

#report-nav ul > li.active {
  background-color: #427ea9;
  color: white;
}

#report-nav ul > li:hover {
  background-color: #427ea9;
  color: white;
  cursor: pointer;
}

#report-nav ul a {
  text-decoration: none;
}

#report-nav i[class*="severity-"] {
  margin-right: 5px;
}

.header {
  border-bottom: 1px solid lightgrey;
  font-family: monospace;
  padding: 10px;
  background-color: #fafbfc;
  border-bottom: 1px solid #e1e4e8;
  border-top-left-radius: 2px;
  border-top-right-radius: 2px;
}

#report-nav .header {
  font-weight: bold;
}

#editor-wrapper .header > div {
  padding-top: 2px;
}

#file-path,
#checker-name {
  color: #195ea2;
}

#review-status {
  padding: 0px 5px;
}

#file-path {
  font-family: monospace;
}

.check-msg {
  display: inline-block;
  padding: 3px 6px;
  margin: 1px;
  -webkit-border-radius: 5px;
  -moz-border-radius: 5px;
  border-radius: 5px;
}

.check-msg.info {
  color: #00546f;
  background-color: #bfdfe9;
  border: 1px solid #87a8b3;
}

.check-msg.error {
  background-color: #f2dede;
  color: #a94442;
  border: 1px solid #ebcccc;
}

.check-msg.macro {
  background-color: #d7dac2;
  color: #4f5c6d;
  border: 1px solid #d7dac2;
}

.check-msg.note {
  background-color: #d7d7d7;
  color: #4f5c6d;
  border: 1px solid #bfbfbf;
}

.check-msg.current {
  border: 2px dashed #3692ff;
}

.check-msg .tag {
  padding: 1px 5px;
  text-align: center;
  border-radius: 2px;
  margin-right: 5px;
  text-decoration: inherit;
}

.check-msg .tag.macro {
  background-color: #83876a;
  color: white;
  text-transform: capitalize;
}

.check-msg .tag.note {
  background-color: #9299a1;
  color: white;
  text-transform: capitalize;
}

.checker-enum {
  color: white;
  padding: 1px 5px;
  text-align: center;
  border-radius: 25px;
  margin-right: 5px;
  text-decoration: inherit;
}

.checker-enum.info {
  background-color: #427ea9;
}

.checker-enum.error {
  background-color: #a94442;
}

.arrow {
  border: solid black;
  border-width: 0 3px 3px 0;
  display: inline-block;
  padding: 3px;
  cursor: pointer;
  margin: 0px 5px;
}

.arrow:hover {
  border: solid #437ea8;
  border-width: 0 3px 3px 0;
}

.left-arrow {
  transform: rotate(135deg);
  -webkit-transform: rotate(135deg);
}

.right-arrow {
  transform: rotate(-45deg);
  -webkit-transform: rotate(-45deg);
}

    </style>

    <script type="text/javascript">
      function setNonCompatibleBrowserMessage() {
  document.body.innerHTML =
    '<h2 style="margin-left: 20px;">Your browser is not compatible with CodeChecker Viewer!</h2> \
     <p style="margin-left: 20px;">The version required for the following browsers are:</p> \
     <ul style="margin-left: 20px;"> \
     <li>Internet Explorer: version 9 or newer</li> \
     <li>Firefox: version 22.0 or newer</li> \
     </ul>';
}

// http://stackoverflow.com/questions/5916900/how-can-you-detect-the-version-of-a-browser
var browserVersion = (function(){
  var ua = navigator.userAgent, tem,
    M = ua.match(/(opera|chrome|safari|firefox|msie|trident(?=\/))\/?\s*(\d+)/i) || [];

  if (/trident/i.test(M[1])) {
    tem = /\brv[ :]+(\d+)/g.exec(ua) || [];
    return 'IE ' + (tem[1] || '');
  }

  if (M[1] === 'Chrome') {
    tem = ua.match(/\b(OPR|Edge)\/(\d+)/);
    if (tem != null) return tem.slice(1).join(' ').replace('OPR', 'Opera');
  }

  M = M[2] ? [M[1], M[2]] : [navigator.appName, navigator.appVersion, '-?'];
  if ((tem = ua.match(/version\/(\d+)/i)) != null) M.splice(1, 1, tem[1]);
    return M.join(' ');
})();

var pos = browserVersion.indexOf(' ');
var browser = browserVersion.substr(0, pos);
var version = parseInt(browserVersion.substr(pos + 1));

var browserCompatible
  = browser === 'Firefox'
  ? version >= 22
  : browser === 'IE'
  ? version >= 9
  : true;


      /* MIT License

Copyright (C) 2017 by Marijn Haverbeke <marijnh@gmail.com> and others

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
 */
      !function(e,t){"object"==typeof exports&&"undefined"!=typeof module?module.exports=t():"function"==typeof define&&define.amd?define(t):e.CodeMirror=t()}(this,function(){"use strict";function e(e){return new RegExp("(^|\\s)"+e+"(?:$|\\s)\\s*")}function t(e){for(var t=e.childNodes.length;t>0;--t)e.removeChild(e.firstChild);return e}function r(e,r){return t(e).appendChild(r)}function n(e,t,r,n){var i=document.createElement(e);if(r&&(i.className=r),n&&(i.style.cssText=n),"string"==typeof t)i.appendChild(document.createTextNode(t));else if(t)for(var o=0;o<t.length;++o)i.appendChild(t[o]);return i}function i(e,t,r,i){var o=n(e,t,r,i);return o.setAttribute("role","presentation"),o}function o(e,t){if(3==t.nodeType&&(t=t.parentNode),e.contains)return e.contains(t);do{if(11==t.nodeType&&(t=t.host),t==e)return!0}while(t=t.parentNode)}function l(){var e;try{e=document.activeElement}catch(t){e=document.body||null}for(;e&&e.shadowRoot&&e.shadowRoot.activeElement;)e=e.shadowRoot.activeElement;return e}function s(t,r){var n=t.className;e(r).test(n)||(t.className+=(n?" ":"")+r)}function a(t,r){for(var n=t.split(" "),i=0;i<n.length;i++)n[i]&&!e(n[i]).test(r)&&(r+=" "+n[i]);return r}function u(e){var t=Array.prototype.slice.call(arguments,1);return function(){return e.apply(null,t)}}function c(e,t,r){t||(t={});for(var n in e)!e.hasOwnProperty(n)||!1===r&&t.hasOwnProperty(n)||(t[n]=e[n]);return t}function f(e,t,r,n,i){null==t&&-1==(t=e.search(/[^\s\u00a0]/))&&(t=e.length);for(var o=n||0,l=i||0;;){var s=e.indexOf("\t",o);if(s<0||s>=t)return l+(t-o);l+=s-o,l+=r-l%r,o=s+1}}function h(e,t){for(var r=0;r<e.length;++r)if(e[r]==t)return r;return-1}function d(e,t,r){for(var n=0,i=0;;){var o=e.indexOf("\t",n);-1==o&&(o=e.length);var l=o-n;if(o==e.length||i+l>=t)return n+Math.min(l,t-i);if(i+=o-n,i+=r-i%r,n=o+1,i>=t)return n}}function p(e){for(;Kl.length<=e;)Kl.push(g(Kl)+" ");return Kl[e]}function g(e){return e[e.length-1]}function v(e,t){for(var r=[],n=0;n<e.length;n++)r[n]=t(e[n],n);return r}function m(e,t,r){for(var n=0,i=r(t);n<e.length&&r(e[n])<=i;)n++;e.splice(n,0,t)}function y(){}function b(e,t){var r;return Object.create?r=Object.create(e):(y.prototype=e,r=new y),t&&c(t,r),r}function w(e){return/\w/.test(e)||e>""&&(e.toUpperCase()!=e.toLowerCase()||jl.test(e))}function x(e,t){return t?!!(t.source.indexOf("\\w")>-1&&w(e))||t.test(e):w(e)}function C(e){for(var t in e)if(e.hasOwnProperty(t)&&e[t])return!1;return!0}function S(e){return e.charCodeAt(0)>=768&&Xl.test(e)}function L(e,t,r){for(;(r<0?t>0:t<e.length)&&S(e.charAt(t));)t+=r;return t}function k(e,t,r){for(var n=t>r?-1:1;;){if(t==r)return t;var i=(t+r)/2,o=n<0?Math.ceil(i):Math.floor(i);if(o==t)return e(o)?t:r;e(o)?r=o:t=o+n}}function T(e,t,r){var o=this;this.input=r,o.scrollbarFiller=n("div",null,"CodeMirror-scrollbar-filler"),o.scrollbarFiller.setAttribute("cm-not-content","true"),o.gutterFiller=n("div",null,"CodeMirror-gutter-filler"),o.gutterFiller.setAttribute("cm-not-content","true"),o.lineDiv=i("div",null,"CodeMirror-code"),o.selectionDiv=n("div",null,null,"position: relative; z-index: 1"),o.cursorDiv=n("div",null,"CodeMirror-cursors"),o.measure=n("div",null,"CodeMirror-measure"),o.lineMeasure=n("div",null,"CodeMirror-measure"),o.lineSpace=i("div",[o.measure,o.lineMeasure,o.selectionDiv,o.cursorDiv,o.lineDiv],null,"position: relative; outline: none");var l=i("div",[o.lineSpace],"CodeMirror-lines");o.mover=n("div",[l],null,"position: relative"),o.sizer=n("div",[o.mover],"CodeMirror-sizer"),o.sizerWidth=null,o.heightForcer=n("div",null,null,"position: absolute; height: "+Rl+"px; width: 1px;"),o.gutters=n("div",null,"CodeMirror-gutters"),o.lineGutter=null,o.scroller=n("div",[o.sizer,o.heightForcer,o.gutters],"CodeMirror-scroll"),o.scroller.setAttribute("tabIndex","-1"),o.wrapper=n("div",[o.scrollbarFiller,o.gutterFiller,o.scroller],"CodeMirror"),gl&&vl<8&&(o.gutters.style.zIndex=-1,o.scroller.style.paddingRight=0),ml||fl&&Tl||(o.scroller.draggable=!0),e&&(e.appendChild?e.appendChild(o.wrapper):e(o.wrapper)),o.viewFrom=o.viewTo=t.first,o.reportedViewFrom=o.reportedViewTo=t.first,o.view=[],o.renderedView=null,o.externalMeasured=null,o.viewOffset=0,o.lastWrapHeight=o.lastWrapWidth=0,o.updateLineNumbers=null,o.nativeBarWidth=o.barHeight=o.barWidth=0,o.scrollbarsClipped=!1,o.lineNumWidth=o.lineNumInnerWidth=o.lineNumChars=null,o.alignWidgets=!1,o.cachedCharWidth=o.cachedTextHeight=o.cachedPaddingH=null,o.maxLine=null,o.maxLineLength=0,o.maxLineChanged=!1,o.wheelDX=o.wheelDY=o.wheelStartX=o.wheelStartY=null,o.shift=!1,o.selForContextMenu=null,o.activeTouch=null,r.init(o)}function M(e,t){if((t-=e.first)<0||t>=e.size)throw new Error("There is no line "+(t+e.first)+" in the document.");for(var r=e;!r.lines;)for(var n=0;;++n){var i=r.children[n],o=i.chunkSize();if(t<o){r=i;break}t-=o}return r.lines[t]}function N(e,t,r){var n=[],i=t.line;return e.iter(t.line,r.line+1,function(e){var o=e.text;i==r.line&&(o=o.slice(0,r.ch)),i==t.line&&(o=o.slice(t.ch)),n.push(o),++i}),n}function O(e,t,r){var n=[];return e.iter(t,r,function(e){n.push(e.text)}),n}function A(e,t){var r=t-e.height;if(r)for(var n=e;n;n=n.parent)n.height+=r}function W(e){if(null==e.parent)return null;for(var t=e.parent,r=h(t.lines,e),n=t.parent;n;t=n,n=n.parent)for(var i=0;n.children[i]!=t;++i)r+=n.children[i].chunkSize();return r+t.first}function D(e,t){var r=e.first;e:do{for(var n=0;n<e.children.length;++n){var i=e.children[n],o=i.height;if(t<o){e=i;continue e}t-=o,r+=i.chunkSize()}return r}while(!e.lines);for(var l=0;l<e.lines.length;++l){var s=e.lines[l].height;if(t<s)break;t-=s}return r+l}function H(e,t){return t>=e.first&&t<e.first+e.size}function F(e,t){return String(e.lineNumberFormatter(t+e.firstLineNumber))}function E(e,t,r){if(void 0===r&&(r=null),!(this instanceof E))return new E(e,t,r);this.line=e,this.ch=t,this.sticky=r}function P(e,t){return e.line-t.line||e.ch-t.ch}function I(e,t){return e.sticky==t.sticky&&0==P(e,t)}function z(e){return E(e.line,e.ch)}function R(e,t){return P(e,t)<0?t:e}function B(e,t){return P(e,t)<0?e:t}function G(e,t){return Math.max(e.first,Math.min(t,e.first+e.size-1))}function U(e,t){if(t.line<e.first)return E(e.first,0);var r=e.first+e.size-1;return t.line>r?E(r,M(e,r).text.length):V(t,M(e,t.line).text.length)}function V(e,t){var r=e.ch;return null==r||r>t?E(e.line,t):r<0?E(e.line,0):e}function K(e,t){for(var r=[],n=0;n<t.length;n++)r[n]=U(e,t[n]);return r}function j(){Yl=!0}function X(){_l=!0}function Y(e,t,r){this.marker=e,this.from=t,this.to=r}function _(e,t){if(e)for(var r=0;r<e.length;++r){var n=e[r];if(n.marker==t)return n}}function $(e,t){for(var r,n=0;n<e.length;++n)e[n]!=t&&(r||(r=[])).push(e[n]);return r}function q(e,t){e.markedSpans=e.markedSpans?e.markedSpans.concat([t]):[t],t.marker.attachLine(e)}function Z(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t)||o.from==t&&"bookmark"==l.type&&(!r||!o.marker.insertLeft)){var s=null==o.to||(l.inclusiveRight?o.to>=t:o.to>t);(n||(n=[])).push(new Y(l,o.from,s?null:o.to))}}return n}function Q(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.to||(l.inclusiveRight?o.to>=t:o.to>t)||o.from==t&&"bookmark"==l.type&&(!r||o.marker.insertLeft)){var s=null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t);(n||(n=[])).push(new Y(l,s?null:o.from-t,null==o.to?null:o.to-t))}}return n}function J(e,t){if(t.full)return null;var r=H(e,t.from.line)&&M(e,t.from.line).markedSpans,n=H(e,t.to.line)&&M(e,t.to.line).markedSpans;if(!r&&!n)return null;var i=t.from.ch,o=t.to.ch,l=0==P(t.from,t.to),s=Z(r,i,l),a=Q(n,o,l),u=1==t.text.length,c=g(t.text).length+(u?i:0);if(s)for(var f=0;f<s.length;++f){var h=s[f];if(null==h.to){var d=_(a,h.marker);d?u&&(h.to=null==d.to?null:d.to+c):h.to=i}}if(a)for(var p=0;p<a.length;++p){var v=a[p];null!=v.to&&(v.to+=c),null==v.from?_(s,v.marker)||(v.from=c,u&&(s||(s=[])).push(v)):(v.from+=c,u&&(s||(s=[])).push(v))}s&&(s=ee(s)),a&&a!=s&&(a=ee(a));var m=[s];if(!u){var y,b=t.text.length-2;if(b>0&&s)for(var w=0;w<s.length;++w)null==s[w].to&&(y||(y=[])).push(new Y(s[w].marker,null,null));for(var x=0;x<b;++x)m.push(y);m.push(a)}return m}function ee(e){for(var t=0;t<e.length;++t){var r=e[t];null!=r.from&&r.from==r.to&&!1!==r.marker.clearWhenEmpty&&e.splice(t--,1)}return e.length?e:null}function te(e,t,r){var n=null;if(e.iter(t.line,r.line+1,function(e){if(e.markedSpans)for(var t=0;t<e.markedSpans.length;++t){var r=e.markedSpans[t].marker;!r.readOnly||n&&-1!=h(n,r)||(n||(n=[])).push(r)}}),!n)return null;for(var i=[{from:t,to:r}],o=0;o<n.length;++o)for(var l=n[o],s=l.find(0),a=0;a<i.length;++a){var u=i[a];if(!(P(u.to,s.from)<0||P(u.from,s.to)>0)){var c=[a,1],f=P(u.from,s.from),d=P(u.to,s.to);(f<0||!l.inclusiveLeft&&!f)&&c.push({from:u.from,to:s.from}),(d>0||!l.inclusiveRight&&!d)&&c.push({from:s.to,to:u.to}),i.splice.apply(i,c),a+=c.length-3}}return i}function re(e){var t=e.markedSpans;if(t){for(var r=0;r<t.length;++r)t[r].marker.detachLine(e);e.markedSpans=null}}function ne(e,t){if(t){for(var r=0;r<t.length;++r)t[r].marker.attachLine(e);e.markedSpans=t}}function ie(e){return e.inclusiveLeft?-1:0}function oe(e){return e.inclusiveRight?1:0}function le(e,t){var r=e.lines.length-t.lines.length;if(0!=r)return r;var n=e.find(),i=t.find(),o=P(n.from,i.from)||ie(e)-ie(t);if(o)return-o;var l=P(n.to,i.to)||oe(e)-oe(t);return l||t.id-e.id}function se(e,t){var r,n=_l&&e.markedSpans;if(n)for(var i=void 0,o=0;o<n.length;++o)(i=n[o]).marker.collapsed&&null==(t?i.from:i.to)&&(!r||le(r,i.marker)<0)&&(r=i.marker);return r}function ae(e){return se(e,!0)}function ue(e){return se(e,!1)}function ce(e,t,r,n,i){var o=M(e,t),l=_l&&o.markedSpans;if(l)for(var s=0;s<l.length;++s){var a=l[s];if(a.marker.collapsed){var u=a.marker.find(0),c=P(u.from,r)||ie(a.marker)-ie(i),f=P(u.to,n)||oe(a.marker)-oe(i);if(!(c>=0&&f<=0||c<=0&&f>=0)&&(c<=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.to,r)>=0:P(u.to,r)>0)||c>=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.from,n)<=0:P(u.from,n)<0)))return!0}}}function fe(e){for(var t;t=ae(e);)e=t.find(-1,!0).line;return e}function he(e){for(var t;t=ue(e);)e=t.find(1,!0).line;return e}function de(e){for(var t,r;t=ue(e);)e=t.find(1,!0).line,(r||(r=[])).push(e);return r}function pe(e,t){var r=M(e,t),n=fe(r);return r==n?t:W(n)}function ge(e,t){if(t>e.lastLine())return t;var r,n=M(e,t);if(!ve(e,n))return t;for(;r=ue(n);)n=r.find(1,!0).line;return W(n)+1}function ve(e,t){var r=_l&&t.markedSpans;if(r)for(var n=void 0,i=0;i<r.length;++i)if((n=r[i]).marker.collapsed){if(null==n.from)return!0;if(!n.marker.widgetNode&&0==n.from&&n.marker.inclusiveLeft&&me(e,t,n))return!0}}function me(e,t,r){if(null==r.to){var n=r.marker.find(1,!0);return me(e,n.line,_(n.line.markedSpans,r.marker))}if(r.marker.inclusiveRight&&r.to==t.text.length)return!0;for(var i=void 0,o=0;o<t.markedSpans.length;++o)if((i=t.markedSpans[o]).marker.collapsed&&!i.marker.widgetNode&&i.from==r.to&&(null==i.to||i.to!=r.from)&&(i.marker.inclusiveLeft||r.marker.inclusiveRight)&&me(e,t,i))return!0}function ye(e){for(var t=0,r=(e=fe(e)).parent,n=0;n<r.lines.length;++n){var i=r.lines[n];if(i==e)break;t+=i.height}for(var o=r.parent;o;r=o,o=r.parent)for(var l=0;l<o.children.length;++l){var s=o.children[l];if(s==r)break;t+=s.height}return t}function be(e){if(0==e.height)return 0;for(var t,r=e.text.length,n=e;t=ae(n);){var i=t.find(0,!0);n=i.from.line,r+=i.from.ch-i.to.ch}for(n=e;t=ue(n);){var o=t.find(0,!0);r-=n.text.length-o.from.ch,r+=(n=o.to.line).text.length-o.to.ch}return r}function we(e){var t=e.display,r=e.doc;t.maxLine=M(r,r.first),t.maxLineLength=be(t.maxLine),t.maxLineChanged=!0,r.iter(function(e){var r=be(e);r>t.maxLineLength&&(t.maxLineLength=r,t.maxLine=e)})}function xe(e,t,r,n){if(!e)return n(t,r,"ltr",0);for(var i=!1,o=0;o<e.length;++o){var l=e[o];(l.from<r&&l.to>t||t==r&&l.to==t)&&(n(Math.max(l.from,t),Math.min(l.to,r),1==l.level?"rtl":"ltr",o),i=!0)}i||n(t,r,"ltr")}function Ce(e,t,r){var n;$l=null;for(var i=0;i<e.length;++i){var o=e[i];if(o.from<t&&o.to>t)return i;o.to==t&&(o.from!=o.to&&"before"==r?n=i:$l=i),o.from==t&&(o.from!=o.to&&"before"!=r?n=i:$l=i)}return null!=n?n:$l}function Se(e,t){var r=e.order;return null==r&&(r=e.order=ql(e.text,t)),r}function Le(e,t){return e._handlers&&e._handlers[t]||Zl}function ke(e,t,r){if(e.removeEventListener)e.removeEventListener(t,r,!1);else if(e.detachEvent)e.detachEvent("on"+t,r);else{var n=e._handlers,i=n&&n[t];if(i){var o=h(i,r);o>-1&&(n[t]=i.slice(0,o).concat(i.slice(o+1)))}}}function Te(e,t){var r=Le(e,t);if(r.length)for(var n=Array.prototype.slice.call(arguments,2),i=0;i<r.length;++i)r[i].apply(null,n)}function Me(e,t,r){return"string"==typeof t&&(t={type:t,preventDefault:function(){this.defaultPrevented=!0}}),Te(e,r||t.type,e,t),He(t)||t.codemirrorIgnore}function Ne(e){var t=e._handlers&&e._handlers.cursorActivity;if(t)for(var r=e.curOp.cursorActivityHandlers||(e.curOp.cursorActivityHandlers=[]),n=0;n<t.length;++n)-1==h(r,t[n])&&r.push(t[n])}function Oe(e,t){return Le(e,t).length>0}function Ae(e){e.prototype.on=function(e,t){Ql(this,e,t)},e.prototype.off=function(e,t){ke(this,e,t)}}function We(e){e.preventDefault?e.preventDefault():e.returnValue=!1}function De(e){e.stopPropagation?e.stopPropagation():e.cancelBubble=!0}function He(e){return null!=e.defaultPrevented?e.defaultPrevented:0==e.returnValue}function Fe(e){We(e),De(e)}function Ee(e){return e.target||e.srcElement}function Pe(e){var t=e.which;return null==t&&(1&e.button?t=1:2&e.button?t=3:4&e.button&&(t=2)),Ml&&e.ctrlKey&&1==t&&(t=3),t}function Ie(e){if(null==Il){var t=n("span","​");r(e,n("span",[t,document.createTextNode("x")])),0!=e.firstChild.offsetHeight&&(Il=t.offsetWidth<=1&&t.offsetHeight>2&&!(gl&&vl<8))}var i=Il?n("span","​"):n("span"," ",null,"display: inline-block; width: 1px; margin-right: -1px");return i.setAttribute("cm-text",""),i}function ze(e){if(null!=zl)return zl;var n=r(e,document.createTextNode("AخA")),i=Wl(n,0,1).getBoundingClientRect(),o=Wl(n,1,2).getBoundingClientRect();return t(e),!(!i||i.left==i.right)&&(zl=o.right-i.right<3)}function Re(e){if(null!=ns)return ns;var t=r(e,n("span","x")),i=t.getBoundingClientRect(),o=Wl(t,0,1).getBoundingClientRect();return ns=Math.abs(i.left-o.left)>1}function Be(e,t){arguments.length>2&&(t.dependencies=Array.prototype.slice.call(arguments,2)),is[e]=t}function Ge(e){if("string"==typeof e&&os.hasOwnProperty(e))e=os[e];else if(e&&"string"==typeof e.name&&os.hasOwnProperty(e.name)){var t=os[e.name];"string"==typeof t&&(t={name:t}),(e=b(t,e)).name=t.name}else{if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+xml$/.test(e))return Ge("application/xml");if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+json$/.test(e))return Ge("application/json")}return"string"==typeof e?{name:e}:e||{name:"null"}}function Ue(e,t){t=Ge(t);var r=is[t.name];if(!r)return Ue(e,"text/plain");var n=r(e,t);if(ls.hasOwnProperty(t.name)){var i=ls[t.name];for(var o in i)i.hasOwnProperty(o)&&(n.hasOwnProperty(o)&&(n["_"+o]=n[o]),n[o]=i[o])}if(n.name=t.name,t.helperType&&(n.helperType=t.helperType),t.modeProps)for(var l in t.modeProps)n[l]=t.modeProps[l];return n}function Ve(e,t){c(t,ls.hasOwnProperty(e)?ls[e]:ls[e]={})}function Ke(e,t){if(!0===t)return t;if(e.copyState)return e.copyState(t);var r={};for(var n in t){var i=t[n];i instanceof Array&&(i=i.concat([])),r[n]=i}return r}function je(e,t){for(var r;e.innerMode&&(r=e.innerMode(t))&&r.mode!=e;)t=r.state,e=r.mode;return r||{mode:e,state:t}}function Xe(e,t,r){return!e.startState||e.startState(t,r)}function Ye(e,t,r,n){var i=[e.state.modeGen],o={};tt(e,t.text,e.doc.mode,r,function(e,t){return i.push(e,t)},o,n);for(var l=r.state,s=0;s<e.state.overlays.length;++s)!function(n){var l=e.state.overlays[n],s=1,a=0;r.state=!0,tt(e,t.text,l.mode,r,function(e,t){for(var r=s;a<e;){var n=i[s];n>e&&i.splice(s,1,e,i[s+1],n),s+=2,a=Math.min(e,n)}if(t)if(l.opaque)i.splice(r,s-r,e,"overlay "+t),s=r+2;else for(;r<s;r+=2){var o=i[r+1];i[r+1]=(o?o+" ":"")+"overlay "+t}},o)}(s);return r.state=l,{styles:i,classes:o.bgClass||o.textClass?o:null}}function _e(e,t,r){if(!t.styles||t.styles[0]!=e.state.modeGen){var n=$e(e,W(t)),i=t.text.length>e.options.maxHighlightLength&&Ke(e.doc.mode,n.state),o=Ye(e,t,n);i&&(n.state=i),t.stateAfter=n.save(!i),t.styles=o.styles,o.classes?t.styleClasses=o.classes:t.styleClasses&&(t.styleClasses=null),r===e.doc.highlightFrontier&&(e.doc.modeFrontier=Math.max(e.doc.modeFrontier,++e.doc.highlightFrontier))}return t.styles}function $e(e,t,r){var n=e.doc,i=e.display;if(!n.mode.startState)return new us(n,!0,t);var o=rt(e,t,r),l=o>n.first&&M(n,o-1).stateAfter,s=l?us.fromSaved(n,l,o):new us(n,Xe(n.mode),o);return n.iter(o,t,function(r){qe(e,r.text,s);var n=s.line;r.stateAfter=n==t-1||n%5==0||n>=i.viewFrom&&n<i.viewTo?s.save():null,s.nextLine()}),r&&(n.modeFrontier=s.line),s}function qe(e,t,r,n){var i=e.doc.mode,o=new ss(t,e.options.tabSize,r);for(o.start=o.pos=n||0,""==t&&Ze(i,r.state);!o.eol();)Qe(i,o,r.state),o.start=o.pos}function Ze(e,t){if(e.blankLine)return e.blankLine(t);if(e.innerMode){var r=je(e,t);return r.mode.blankLine?r.mode.blankLine(r.state):void 0}}function Qe(e,t,r,n){for(var i=0;i<10;i++){n&&(n[0]=je(e,r).mode);var o=e.token(t,r);if(t.pos>t.start)return o}throw new Error("Mode "+e.name+" failed to advance stream.")}function Je(e,t,r,n){var i,o,l=e.doc,s=l.mode,a=M(l,(t=U(l,t)).line),u=$e(e,t.line,r),c=new ss(a.text,e.options.tabSize,u);for(n&&(o=[]);(n||c.pos<t.ch)&&!c.eol();)c.start=c.pos,i=Qe(s,c,u.state),n&&o.push(new cs(c,i,Ke(l.mode,u.state)));return n?o:new cs(c,i,u.state)}function et(e,t){if(e)for(;;){var r=e.match(/(?:^|\s+)line-(background-)?(\S+)/);if(!r)break;e=e.slice(0,r.index)+e.slice(r.index+r[0].length);var n=r[1]?"bgClass":"textClass";null==t[n]?t[n]=r[2]:new RegExp("(?:^|s)"+r[2]+"(?:$|s)").test(t[n])||(t[n]+=" "+r[2])}return e}function tt(e,t,r,n,i,o,l){var s=r.flattenSpans;null==s&&(s=e.options.flattenSpans);var a,u=0,c=null,f=new ss(t,e.options.tabSize,n),h=e.options.addModeClass&&[null];for(""==t&&et(Ze(r,n.state),o);!f.eol();){if(f.pos>e.options.maxHighlightLength?(s=!1,l&&qe(e,t,n,f.pos),f.pos=t.length,a=null):a=et(Qe(r,f,n.state,h),o),h){var d=h[0].name;d&&(a="m-"+(a?d+" "+a:d))}if(!s||c!=a){for(;u<f.start;)i(u=Math.min(f.start,u+5e3),c);c=a}f.start=f.pos}for(;u<f.pos;){var p=Math.min(f.pos,u+5e3);i(p,c),u=p}}function rt(e,t,r){for(var n,i,o=e.doc,l=r?-1:t-(e.doc.mode.innerMode?1e3:100),s=t;s>l;--s){if(s<=o.first)return o.first;var a=M(o,s-1),u=a.stateAfter;if(u&&(!r||s+(u instanceof as?u.lookAhead:0)<=o.modeFrontier))return s;var c=f(a.text,null,e.options.tabSize);(null==i||n>c)&&(i=s-1,n=c)}return i}function nt(e,t){if(e.modeFrontier=Math.min(e.modeFrontier,t),!(e.highlightFrontier<t-10)){for(var r=e.first,n=t-1;n>r;n--){var i=M(e,n).stateAfter;if(i&&(!(i instanceof as)||n+i.lookAhead<t)){r=n+1;break}}e.highlightFrontier=Math.min(e.highlightFrontier,r)}}function it(e,t,r,n){e.text=t,e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null),null!=e.order&&(e.order=null),re(e),ne(e,r);var i=n?n(e):1;i!=e.height&&A(e,i)}function ot(e){e.parent=null,re(e)}function lt(e,t){if(!e||/^\s*$/.test(e))return null;var r=t.addModeClass?ps:ds;return r[e]||(r[e]=e.replace(/\S+/g,"cm-$&"))}function st(e,t){var r=i("span",null,null,ml?"padding-right: .1px":null),n={pre:i("pre",[r],"CodeMirror-line"),content:r,col:0,pos:0,cm:e,trailingSpace:!1,splitSpaces:(gl||ml)&&e.getOption("lineWrapping")};t.measure={};for(var o=0;o<=(t.rest?t.rest.length:0);o++){var l=o?t.rest[o-1]:t.line,s=void 0;n.pos=0,n.addToken=ut,ze(e.display.measure)&&(s=Se(l,e.doc.direction))&&(n.addToken=ft(n.addToken,s)),n.map=[],dt(l,n,_e(e,l,t!=e.display.externalMeasured&&W(l))),l.styleClasses&&(l.styleClasses.bgClass&&(n.bgClass=a(l.styleClasses.bgClass,n.bgClass||"")),l.styleClasses.textClass&&(n.textClass=a(l.styleClasses.textClass,n.textClass||""))),0==n.map.length&&n.map.push(0,0,n.content.appendChild(Ie(e.display.measure))),0==o?(t.measure.map=n.map,t.measure.cache={}):((t.measure.maps||(t.measure.maps=[])).push(n.map),(t.measure.caches||(t.measure.caches=[])).push({}))}if(ml){var u=n.content.lastChild;(/\bcm-tab\b/.test(u.className)||u.querySelector&&u.querySelector(".cm-tab"))&&(n.content.className="cm-tab-wrap-hack")}return Te(e,"renderLine",e,t.line,n.pre),n.pre.className&&(n.textClass=a(n.pre.className,n.textClass||"")),n}function at(e){var t=n("span","•","cm-invalidchar");return t.title="\\u"+e.charCodeAt(0).toString(16),t.setAttribute("aria-label",t.title),t}function ut(e,t,r,i,o,l,s){if(t){var a,u=e.splitSpaces?ct(t,e.trailingSpace):t,c=e.cm.state.specialChars,f=!1;if(c.test(t)){a=document.createDocumentFragment();for(var h=0;;){c.lastIndex=h;var d=c.exec(t),g=d?d.index-h:t.length-h;if(g){var v=document.createTextNode(u.slice(h,h+g));gl&&vl<9?a.appendChild(n("span",[v])):a.appendChild(v),e.map.push(e.pos,e.pos+g,v),e.col+=g,e.pos+=g}if(!d)break;h+=g+1;var m=void 0;if("\t"==d[0]){var y=e.cm.options.tabSize,b=y-e.col%y;(m=a.appendChild(n("span",p(b),"cm-tab"))).setAttribute("role","presentation"),m.setAttribute("cm-text","\t"),e.col+=b}else"\r"==d[0]||"\n"==d[0]?((m=a.appendChild(n("span","\r"==d[0]?"␍":"␤","cm-invalidchar"))).setAttribute("cm-text",d[0]),e.col+=1):((m=e.cm.options.specialCharPlaceholder(d[0])).setAttribute("cm-text",d[0]),gl&&vl<9?a.appendChild(n("span",[m])):a.appendChild(m),e.col+=1);e.map.push(e.pos,e.pos+1,m),e.pos++}}else e.col+=t.length,a=document.createTextNode(u),e.map.push(e.pos,e.pos+t.length,a),gl&&vl<9&&(f=!0),e.pos+=t.length;if(e.trailingSpace=32==u.charCodeAt(t.length-1),r||i||o||f||s){var w=r||"";i&&(w+=i),o&&(w+=o);var x=n("span",[a],w,s);return l&&(x.title=l),e.content.appendChild(x)}e.content.appendChild(a)}}function ct(e,t){if(e.length>1&&!/  /.test(e))return e;for(var r=t,n="",i=0;i<e.length;i++){var o=e.charAt(i);" "!=o||!r||i!=e.length-1&&32!=e.charCodeAt(i+1)||(o=" "),n+=o,r=" "==o}return n}function ft(e,t){return function(r,n,i,o,l,s,a){i=i?i+" cm-force-border":"cm-force-border";for(var u=r.pos,c=u+n.length;;){for(var f=void 0,h=0;h<t.length&&!((f=t[h]).to>u&&f.from<=u);h++);if(f.to>=c)return e(r,n,i,o,l,s,a);e(r,n.slice(0,f.to-u),i,o,null,s,a),o=null,n=n.slice(f.to-u),u=f.to}}}function ht(e,t,r,n){var i=!n&&r.widgetNode;i&&e.map.push(e.pos,e.pos+t,i),!n&&e.cm.display.input.needsContentAttribute&&(i||(i=e.content.appendChild(document.createElement("span"))),i.setAttribute("cm-marker",r.id)),i&&(e.cm.display.input.setUneditable(i),e.content.appendChild(i)),e.pos+=t,e.trailingSpace=!1}function dt(e,t,r){var n=e.markedSpans,i=e.text,o=0;if(n)for(var l,s,a,u,c,f,h,d=i.length,p=0,g=1,v="",m=0;;){if(m==p){a=u=c=f=s="",h=null,m=1/0;for(var y=[],b=void 0,w=0;w<n.length;++w){var x=n[w],C=x.marker;"bookmark"==C.type&&x.from==p&&C.widgetNode?y.push(C):x.from<=p&&(null==x.to||x.to>p||C.collapsed&&x.to==p&&x.from==p)?(null!=x.to&&x.to!=p&&m>x.to&&(m=x.to,u=""),C.className&&(a+=" "+C.className),C.css&&(s=(s?s+";":"")+C.css),C.startStyle&&x.from==p&&(c+=" "+C.startStyle),C.endStyle&&x.to==m&&(b||(b=[])).push(C.endStyle,x.to),C.title&&!f&&(f=C.title),C.collapsed&&(!h||le(h.marker,C)<0)&&(h=x)):x.from>p&&m>x.from&&(m=x.from)}if(b)for(var S=0;S<b.length;S+=2)b[S+1]==m&&(u+=" "+b[S]);if(!h||h.from==p)for(var L=0;L<y.length;++L)ht(t,0,y[L]);if(h&&(h.from||0)==p){if(ht(t,(null==h.to?d+1:h.to)-p,h.marker,null==h.from),null==h.to)return;h.to==p&&(h=!1)}}if(p>=d)break;for(var k=Math.min(d,m);;){if(v){var T=p+v.length;if(!h){var M=T>k?v.slice(0,k-p):v;t.addToken(t,M,l?l+a:a,c,p+M.length==m?u:"",f,s)}if(T>=k){v=v.slice(k-p),p=k;break}p=T,c=""}v=i.slice(o,o=r[g++]),l=lt(r[g++],t.cm.options)}}else for(var N=1;N<r.length;N+=2)t.addToken(t,i.slice(o,o=r[N]),lt(r[N+1],t.cm.options))}function pt(e,t,r){this.line=t,this.rest=de(t),this.size=this.rest?W(g(this.rest))-r+1:1,this.node=this.text=null,this.hidden=ve(e,t)}function gt(e,t,r){for(var n,i=[],o=t;o<r;o=n){var l=new pt(e.doc,M(e.doc,o),o);n=o+l.size,i.push(l)}return i}function vt(e){gs?gs.ops.push(e):e.ownsGroup=gs={ops:[e],delayedCallbacks:[]}}function mt(e){var t=e.delayedCallbacks,r=0;do{for(;r<t.length;r++)t[r].call(null);for(var n=0;n<e.ops.length;n++){var i=e.ops[n];if(i.cursorActivityHandlers)for(;i.cursorActivityCalled<i.cursorActivityHandlers.length;)i.cursorActivityHandlers[i.cursorActivityCalled++].call(null,i.cm)}}while(r<t.length)}function yt(e,t){var r=e.ownsGroup;if(r)try{mt(r)}finally{gs=null,t(r)}}function bt(e,t){var r=Le(e,t);if(r.length){var n,i=Array.prototype.slice.call(arguments,2);gs?n=gs.delayedCallbacks:vs?n=vs:(n=vs=[],setTimeout(wt,0));for(var o=0;o<r.length;++o)!function(e){n.push(function(){return r[e].apply(null,i)})}(o)}}function wt(){var e=vs;vs=null;for(var t=0;t<e.length;++t)e[t]()}function xt(e,t,r,n){for(var i=0;i<t.changes.length;i++){var o=t.changes[i];"text"==o?kt(e,t):"gutter"==o?Mt(e,t,r,n):"class"==o?Tt(e,t):"widget"==o&&Nt(e,t,n)}t.changes=null}function Ct(e){return e.node==e.text&&(e.node=n("div",null,null,"position: relative"),e.text.parentNode&&e.text.parentNode.replaceChild(e.node,e.text),e.node.appendChild(e.text),gl&&vl<8&&(e.node.style.zIndex=2)),e.node}function St(e,t){var r=t.bgClass?t.bgClass+" "+(t.line.bgClass||""):t.line.bgClass;if(r&&(r+=" CodeMirror-linebackground"),t.background)r?t.background.className=r:(t.background.parentNode.removeChild(t.background),t.background=null);else if(r){var i=Ct(t);t.background=i.insertBefore(n("div",null,r),i.firstChild),e.display.input.setUneditable(t.background)}}function Lt(e,t){var r=e.display.externalMeasured;return r&&r.line==t.line?(e.display.externalMeasured=null,t.measure=r.measure,r.built):st(e,t)}function kt(e,t){var r=t.text.className,n=Lt(e,t);t.text==t.node&&(t.node=n.pre),t.text.parentNode.replaceChild(n.pre,t.text),t.text=n.pre,n.bgClass!=t.bgClass||n.textClass!=t.textClass?(t.bgClass=n.bgClass,t.textClass=n.textClass,Tt(e,t)):r&&(t.text.className=r)}function Tt(e,t){St(e,t),t.line.wrapClass?Ct(t).className=t.line.wrapClass:t.node!=t.text&&(t.node.className="");var r=t.textClass?t.textClass+" "+(t.line.textClass||""):t.line.textClass;t.text.className=r||""}function Mt(e,t,r,i){if(t.gutter&&(t.node.removeChild(t.gutter),t.gutter=null),t.gutterBackground&&(t.node.removeChild(t.gutterBackground),t.gutterBackground=null),t.line.gutterClass){var o=Ct(t);t.gutterBackground=n("div",null,"CodeMirror-gutter-background "+t.line.gutterClass,"left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px; width: "+i.gutterTotalWidth+"px"),e.display.input.setUneditable(t.gutterBackground),o.insertBefore(t.gutterBackground,t.text)}var l=t.line.gutterMarkers;if(e.options.lineNumbers||l){var s=Ct(t),a=t.gutter=n("div",null,"CodeMirror-gutter-wrapper","left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px");if(e.display.input.setUneditable(a),s.insertBefore(a,t.text),t.line.gutterClass&&(a.className+=" "+t.line.gutterClass),!e.options.lineNumbers||l&&l["CodeMirror-linenumbers"]||(t.lineNumber=a.appendChild(n("div",F(e.options,r),"CodeMirror-linenumber CodeMirror-gutter-elt","left: "+i.gutterLeft["CodeMirror-linenumbers"]+"px; width: "+e.display.lineNumInnerWidth+"px"))),l)for(var u=0;u<e.options.gutters.length;++u){var c=e.options.gutters[u],f=l.hasOwnProperty(c)&&l[c];f&&a.appendChild(n("div",[f],"CodeMirror-gutter-elt","left: "+i.gutterLeft[c]+"px; width: "+i.gutterWidth[c]+"px"))}}}function Nt(e,t,r){t.alignable&&(t.alignable=null);for(var n=t.node.firstChild,i=void 0;n;n=i)i=n.nextSibling,"CodeMirror-linewidget"==n.className&&t.node.removeChild(n);At(e,t,r)}function Ot(e,t,r,n){var i=Lt(e,t);return t.text=t.node=i.pre,i.bgClass&&(t.bgClass=i.bgClass),i.textClass&&(t.textClass=i.textClass),Tt(e,t),Mt(e,t,r,n),At(e,t,n),t.node}function At(e,t,r){if(Wt(e,t.line,t,r,!0),t.rest)for(var n=0;n<t.rest.length;n++)Wt(e,t.rest[n],t,r,!1)}function Wt(e,t,r,i,o){if(t.widgets)for(var l=Ct(r),s=0,a=t.widgets;s<a.length;++s){var u=a[s],c=n("div",[u.node],"CodeMirror-linewidget");u.handleMouseEvents||c.setAttribute("cm-ignore-events","true"),Dt(u,c,r,i),e.display.input.setUneditable(c),o&&u.above?l.insertBefore(c,r.gutter||r.text):l.appendChild(c),bt(u,"redraw")}}function Dt(e,t,r,n){if(e.noHScroll){(r.alignable||(r.alignable=[])).push(t);var i=n.wrapperWidth;t.style.left=n.fixedPos+"px",e.coverGutter||(i-=n.gutterTotalWidth,t.style.paddingLeft=n.gutterTotalWidth+"px"),t.style.width=i+"px"}e.coverGutter&&(t.style.zIndex=5,t.style.position="relative",e.noHScroll||(t.style.marginLeft=-n.gutterTotalWidth+"px"))}function Ht(e){if(null!=e.height)return e.height;var t=e.doc.cm;if(!t)return 0;if(!o(document.body,e.node)){var i="position: relative;";e.coverGutter&&(i+="margin-left: -"+t.display.gutters.offsetWidth+"px;"),e.noHScroll&&(i+="width: "+t.display.wrapper.clientWidth+"px;"),r(t.display.measure,n("div",[e.node],null,i))}return e.height=e.node.parentNode.offsetHeight}function Ft(e,t){for(var r=Ee(t);r!=e.wrapper;r=r.parentNode)if(!r||1==r.nodeType&&"true"==r.getAttribute("cm-ignore-events")||r.parentNode==e.sizer&&r!=e.mover)return!0}function Et(e){return e.lineSpace.offsetTop}function Pt(e){return e.mover.offsetHeight-e.lineSpace.offsetHeight}function It(e){if(e.cachedPaddingH)return e.cachedPaddingH;var t=r(e.measure,n("pre","x")),i=window.getComputedStyle?window.getComputedStyle(t):t.currentStyle,o={left:parseInt(i.paddingLeft),right:parseInt(i.paddingRight)};return isNaN(o.left)||isNaN(o.right)||(e.cachedPaddingH=o),o}function zt(e){return Rl-e.display.nativeBarWidth}function Rt(e){return e.display.scroller.clientWidth-zt(e)-e.display.barWidth}function Bt(e){return e.display.scroller.clientHeight-zt(e)-e.display.barHeight}function Gt(e,t,r){var n=e.options.lineWrapping,i=n&&Rt(e);if(!t.measure.heights||n&&t.measure.width!=i){var o=t.measure.heights=[];if(n){t.measure.width=i;for(var l=t.text.firstChild.getClientRects(),s=0;s<l.length-1;s++){var a=l[s],u=l[s+1];Math.abs(a.bottom-u.bottom)>2&&o.push((a.bottom+u.top)/2-r.top)}}o.push(r.bottom-r.top)}}function Ut(e,t,r){if(e.line==t)return{map:e.measure.map,cache:e.measure.cache};for(var n=0;n<e.rest.length;n++)if(e.rest[n]==t)return{map:e.measure.maps[n],cache:e.measure.caches[n]};for(var i=0;i<e.rest.length;i++)if(W(e.rest[i])>r)return{map:e.measure.maps[i],cache:e.measure.caches[i],before:!0}}function Vt(e,t){var n=W(t=fe(t)),i=e.display.externalMeasured=new pt(e.doc,t,n);i.lineN=n;var o=i.built=st(e,i);return i.text=o.pre,r(e.display.lineMeasure,o.pre),i}function Kt(e,t,r,n){return Yt(e,Xt(e,t),r,n)}function jt(e,t){if(t>=e.display.viewFrom&&t<e.display.viewTo)return e.display.view[Lr(e,t)];var r=e.display.externalMeasured;return r&&t>=r.lineN&&t<r.lineN+r.size?r:void 0}function Xt(e,t){var r=W(t),n=jt(e,r);n&&!n.text?n=null:n&&n.changes&&(xt(e,n,r,br(e)),e.curOp.forceUpdate=!0),n||(n=Vt(e,t));var i=Ut(n,t,r);return{line:t,view:n,rect:null,map:i.map,cache:i.cache,before:i.before,hasHeights:!1}}function Yt(e,t,r,n,i){t.before&&(r=-1);var o,l=r+(n||"");return t.cache.hasOwnProperty(l)?o=t.cache[l]:(t.rect||(t.rect=t.view.text.getBoundingClientRect()),t.hasHeights||(Gt(e,t.view,t.rect),t.hasHeights=!0),(o=qt(e,t,r,n)).bogus||(t.cache[l]=o)),{left:o.left,right:o.right,top:i?o.rtop:o.top,bottom:i?o.rbottom:o.bottom}}function _t(e,t,r){for(var n,i,o,l,s,a,u=0;u<e.length;u+=3)if(s=e[u],a=e[u+1],t<s?(i=0,o=1,l="left"):t<a?o=(i=t-s)+1:(u==e.length-3||t==a&&e[u+3]>t)&&(i=(o=a-s)-1,t>=a&&(l="right")),null!=i){if(n=e[u+2],s==a&&r==(n.insertLeft?"left":"right")&&(l=r),"left"==r&&0==i)for(;u&&e[u-2]==e[u-3]&&e[u-1].insertLeft;)n=e[2+(u-=3)],l="left";if("right"==r&&i==a-s)for(;u<e.length-3&&e[u+3]==e[u+4]&&!e[u+5].insertLeft;)n=e[(u+=3)+2],l="right";break}return{node:n,start:i,end:o,collapse:l,coverStart:s,coverEnd:a}}function $t(e,t){var r=ms;if("left"==t)for(var n=0;n<e.length&&(r=e[n]).left==r.right;n++);else for(var i=e.length-1;i>=0&&(r=e[i]).left==r.right;i--);return r}function qt(e,t,r,n){var i,o=_t(t.map,r,n),l=o.node,s=o.start,a=o.end,u=o.collapse;if(3==l.nodeType){for(var c=0;c<4;c++){for(;s&&S(t.line.text.charAt(o.coverStart+s));)--s;for(;o.coverStart+a<o.coverEnd&&S(t.line.text.charAt(o.coverStart+a));)++a;if((i=gl&&vl<9&&0==s&&a==o.coverEnd-o.coverStart?l.parentNode.getBoundingClientRect():$t(Wl(l,s,a).getClientRects(),n)).left||i.right||0==s)break;a=s,s-=1,u="right"}gl&&vl<11&&(i=Zt(e.display.measure,i))}else{s>0&&(u=n="right");var f;i=e.options.lineWrapping&&(f=l.getClientRects()).length>1?f["right"==n?f.length-1:0]:l.getBoundingClientRect()}if(gl&&vl<9&&!s&&(!i||!i.left&&!i.right)){var h=l.parentNode.getClientRects()[0];i=h?{left:h.left,right:h.left+yr(e.display),top:h.top,bottom:h.bottom}:ms}for(var d=i.top-t.rect.top,p=i.bottom-t.rect.top,g=(d+p)/2,v=t.view.measure.heights,m=0;m<v.length-1&&!(g<v[m]);m++);var y=m?v[m-1]:0,b=v[m],w={left:("right"==u?i.right:i.left)-t.rect.left,right:("left"==u?i.left:i.right)-t.rect.left,top:y,bottom:b};return i.left||i.right||(w.bogus=!0),e.options.singleCursorHeightPerLine||(w.rtop=d,w.rbottom=p),w}function Zt(e,t){if(!window.screen||null==screen.logicalXDPI||screen.logicalXDPI==screen.deviceXDPI||!Re(e))return t;var r=screen.logicalXDPI/screen.deviceXDPI,n=screen.logicalYDPI/screen.deviceYDPI;return{left:t.left*r,right:t.right*r,top:t.top*n,bottom:t.bottom*n}}function Qt(e){if(e.measure&&(e.measure.cache={},e.measure.heights=null,e.rest))for(var t=0;t<e.rest.length;t++)e.measure.caches[t]={}}function Jt(e){e.display.externalMeasure=null,t(e.display.lineMeasure);for(var r=0;r<e.display.view.length;r++)Qt(e.display.view[r])}function er(e){Jt(e),e.display.cachedCharWidth=e.display.cachedTextHeight=e.display.cachedPaddingH=null,e.options.lineWrapping||(e.display.maxLineChanged=!0),e.display.lineNumChars=null}function tr(){return bl&&kl?-(document.body.getBoundingClientRect().left-parseInt(getComputedStyle(document.body).marginLeft)):window.pageXOffset||(document.documentElement||document.body).scrollLeft}function rr(){return bl&&kl?-(document.body.getBoundingClientRect().top-parseInt(getComputedStyle(document.body).marginTop)):window.pageYOffset||(document.documentElement||document.body).scrollTop}function nr(e){var t=0;if(e.widgets)for(var r=0;r<e.widgets.length;++r)e.widgets[r].above&&(t+=Ht(e.widgets[r]));return t}function ir(e,t,r,n,i){if(!i){var o=nr(t);r.top+=o,r.bottom+=o}if("line"==n)return r;n||(n="local");var l=ye(t);if("local"==n?l+=Et(e.display):l-=e.display.viewOffset,"page"==n||"window"==n){var s=e.display.lineSpace.getBoundingClientRect();l+=s.top+("window"==n?0:rr());var a=s.left+("window"==n?0:tr());r.left+=a,r.right+=a}return r.top+=l,r.bottom+=l,r}function or(e,t,r){if("div"==r)return t;var n=t.left,i=t.top;if("page"==r)n-=tr(),i-=rr();else if("local"==r||!r){var o=e.display.sizer.getBoundingClientRect();n+=o.left,i+=o.top}var l=e.display.lineSpace.getBoundingClientRect();return{left:n-l.left,top:i-l.top}}function lr(e,t,r,n,i){return n||(n=M(e.doc,t.line)),ir(e,n,Kt(e,n,t.ch,i),r)}function sr(e,t,r,n,i,o){function l(t,l){var s=Yt(e,i,t,l?"right":"left",o);return l?s.left=s.right:s.right=s.left,ir(e,n,s,r)}function s(e,t,r){var n=1==a[t].level;return l(r?e-1:e,n!=r)}n=n||M(e.doc,t.line),i||(i=Xt(e,n));var a=Se(n,e.doc.direction),u=t.ch,c=t.sticky;if(u>=n.text.length?(u=n.text.length,c="before"):u<=0&&(u=0,c="after"),!a)return l("before"==c?u-1:u,"before"==c);var f=Ce(a,u,c),h=$l,d=s(u,f,"before"==c);return null!=h&&(d.other=s(u,h,"before"!=c)),d}function ar(e,t){var r=0;t=U(e.doc,t),e.options.lineWrapping||(r=yr(e.display)*t.ch);var n=M(e.doc,t.line),i=ye(n)+Et(e.display);return{left:r,right:r,top:i,bottom:i+n.height}}function ur(e,t,r,n,i){var o=E(e,t,r);return o.xRel=i,n&&(o.outside=!0),o}function cr(e,t,r){var n=e.doc;if((r+=e.display.viewOffset)<0)return ur(n.first,0,null,!0,-1);var i=D(n,r),o=n.first+n.size-1;if(i>o)return ur(n.first+n.size-1,M(n,o).text.length,null,!0,1);t<0&&(t=0);for(var l=M(n,i);;){var s=pr(e,l,i,t,r),a=ue(l),u=a&&a.find(0,!0);if(!a||!(s.ch>u.from.ch||s.ch==u.from.ch&&s.xRel>0))return s;i=W(l=u.to.line)}}function fr(e,t,r,n){n-=nr(t);var i=t.text.length,o=k(function(t){return Yt(e,r,t-1).bottom<=n},i,0);return i=k(function(t){return Yt(e,r,t).top>n},o,i),{begin:o,end:i}}function hr(e,t,r,n){return r||(r=Xt(e,t)),fr(e,t,r,ir(e,t,Yt(e,r,n),"line").top)}function dr(e,t,r,n){return!(e.bottom<=r)&&(e.top>r||(n?e.left:e.right)>t)}function pr(e,t,r,n,i){i-=ye(t);var o=Xt(e,t),l=nr(t),s=0,a=t.text.length,u=!0,c=Se(t,e.doc.direction);if(c){var f=(e.options.lineWrapping?vr:gr)(e,t,r,o,c,n,i);s=(u=1!=f.level)?f.from:f.to-1,a=u?f.to:f.from-1}var h,d,p=null,g=null,v=k(function(t){var r=Yt(e,o,t);return r.top+=l,r.bottom+=l,!!dr(r,n,i,!1)&&(r.top<=i&&r.left<=n&&(p=t,g=r),!0)},s,a),m=!1;if(g){var y=n-g.left<g.right-n,b=y==u;v=p+(b?0:1),d=b?"after":"before",h=y?g.left:g.right}else{u||v!=a&&v!=s||v++,d=0==v?"after":v==t.text.length?"before":Yt(e,o,v-(u?1:0)).bottom+l<=i==u?"after":"before";var w=sr(e,E(r,v,d),"line",t,o);h=w.left,m=i<w.top||i>=w.bottom}return v=L(t.text,v,1),ur(r,v,d,m,n-h)}function gr(e,t,r,n,i,o,l){var s=k(function(s){var a=i[s],u=1!=a.level;return dr(sr(e,E(r,u?a.to:a.from,u?"before":"after"),"line",t,n),o,l,!0)},0,i.length-1),a=i[s];if(s>0){var u=1!=a.level,c=sr(e,E(r,u?a.from:a.to,u?"after":"before"),"line",t,n);dr(c,o,l,!0)&&c.top>l&&(a=i[s-1])}return a}function vr(e,t,r,n,i,o,l){for(var s=fr(e,t,n,l),a=s.begin,u=s.end,c=null,f=null,h=0;h<i.length;h++){var d=i[h];if(!(d.from>=u||d.to<=a)){var p=Yt(e,n,1!=d.level?Math.min(u,d.to)-1:Math.max(a,d.from)).right,g=p<o?o-p+1e9:p-o;(!c||f>g)&&(c=d,f=g)}}return c||(c=i[i.length-1]),c.from<a&&(c={from:a,to:c.to,level:c.level}),c.to>u&&(c={from:c.from,to:u,level:c.level}),c}function mr(e){if(null!=e.cachedTextHeight)return e.cachedTextHeight;if(null==hs){hs=n("pre");for(var i=0;i<49;++i)hs.appendChild(document.createTextNode("x")),hs.appendChild(n("br"));hs.appendChild(document.createTextNode("x"))}r(e.measure,hs);var o=hs.offsetHeight/50;return o>3&&(e.cachedTextHeight=o),t(e.measure),o||1}function yr(e){if(null!=e.cachedCharWidth)return e.cachedCharWidth;var t=n("span","xxxxxxxxxx"),i=n("pre",[t]);r(e.measure,i);var o=t.getBoundingClientRect(),l=(o.right-o.left)/10;return l>2&&(e.cachedCharWidth=l),l||10}function br(e){for(var t=e.display,r={},n={},i=t.gutters.clientLeft,o=t.gutters.firstChild,l=0;o;o=o.nextSibling,++l)r[e.options.gutters[l]]=o.offsetLeft+o.clientLeft+i,n[e.options.gutters[l]]=o.clientWidth;return{fixedPos:wr(t),gutterTotalWidth:t.gutters.offsetWidth,gutterLeft:r,gutterWidth:n,wrapperWidth:t.wrapper.clientWidth}}function wr(e){return e.scroller.getBoundingClientRect().left-e.sizer.getBoundingClientRect().left}function xr(e){var t=mr(e.display),r=e.options.lineWrapping,n=r&&Math.max(5,e.display.scroller.clientWidth/yr(e.display)-3);return function(i){if(ve(e.doc,i))return 0;var o=0;if(i.widgets)for(var l=0;l<i.widgets.length;l++)i.widgets[l].height&&(o+=i.widgets[l].height);return r?o+(Math.ceil(i.text.length/n)||1)*t:o+t}}function Cr(e){var t=e.doc,r=xr(e);t.iter(function(e){var t=r(e);t!=e.height&&A(e,t)})}function Sr(e,t,r,n){var i=e.display;if(!r&&"true"==Ee(t).getAttribute("cm-not-content"))return null;var o,l,s=i.lineSpace.getBoundingClientRect();try{o=t.clientX-s.left,l=t.clientY-s.top}catch(t){return null}var a,u=cr(e,o,l);if(n&&1==u.xRel&&(a=M(e.doc,u.line).text).length==u.ch){var c=f(a,a.length,e.options.tabSize)-a.length;u=E(u.line,Math.max(0,Math.round((o-It(e.display).left)/yr(e.display))-c))}return u}function Lr(e,t){if(t>=e.display.viewTo)return null;if((t-=e.display.viewFrom)<0)return null;for(var r=e.display.view,n=0;n<r.length;n++)if((t-=r[n].size)<0)return n}function kr(e){e.display.input.showSelection(e.display.input.prepareSelection())}function Tr(e,t){void 0===t&&(t=!0);for(var r=e.doc,n={},i=n.cursors=document.createDocumentFragment(),o=n.selection=document.createDocumentFragment(),l=0;l<r.sel.ranges.length;l++)if(t||l!=r.sel.primIndex){var s=r.sel.ranges[l];if(!(s.from().line>=e.display.viewTo||s.to().line<e.display.viewFrom)){var a=s.empty();(a||e.options.showCursorWhenSelecting)&&Mr(e,s.head,i),a||Or(e,s,o)}}return n}function Mr(e,t,r){var i=sr(e,t,"div",null,null,!e.options.singleCursorHeightPerLine),o=r.appendChild(n("div"," ","CodeMirror-cursor"));if(o.style.left=i.left+"px",o.style.top=i.top+"px",o.style.height=Math.max(0,i.bottom-i.top)*e.options.cursorHeight+"px",i.other){var l=r.appendChild(n("div"," ","CodeMirror-cursor CodeMirror-secondarycursor"));l.style.display="",l.style.left=i.other.left+"px",l.style.top=i.other.top+"px",l.style.height=.85*(i.other.bottom-i.other.top)+"px"}}function Nr(e,t){return e.top-t.top||e.left-t.left}function Or(e,t,r){function i(e,t,r,i){t<0&&(t=0),t=Math.round(t),i=Math.round(i),a.appendChild(n("div",null,"CodeMirror-selected","position: absolute; left: "+e+"px;\n                             top: "+t+"px; width: "+(null==r?f-e:r)+"px;\n                             height: "+(i-t)+"px"))}function o(t,r,n){function o(r,n){return lr(e,E(t,r),"div",u,n)}var l,a,u=M(s,t),h=u.text.length,d=Se(u,s.direction);return xe(d,r||0,null==n?h:n,function(t,s,p,g){var v=o(t,"ltr"==p?"left":"right"),m=o(s-1,"ltr"==p?"right":"left");if("ltr"==p){var y=null==r&&0==t?c:v.left,b=null==n&&s==h?f:m.right;m.top-v.top<=3?i(y,m.top,b-y,m.bottom):(i(y,v.top,null,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top),i(c,m.top,m.right,m.bottom))}else if(t<s){var w=null==r&&0==t?f:v.right,x=null==n&&s==h?c:m.left;if(m.top-v.top<=3)i(x,m.top,w-x,m.bottom);else{var C=c;if(g){var S=hr(e,u,null,t).end;C=o(S-(/\s/.test(u.text.charAt(S-1))?2:1),"left").left}i(C,v.top,w-C,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top);var L=null;d.length,L=o(hr(e,u,null,s).begin,"right").right-x,i(x,m.top,L,m.bottom)}}(!l||Nr(v,l)<0)&&(l=v),Nr(m,l)<0&&(l=m),(!a||Nr(v,a)<0)&&(a=v),Nr(m,a)<0&&(a=m)}),{start:l,end:a}}var l=e.display,s=e.doc,a=document.createDocumentFragment(),u=It(e.display),c=u.left,f=Math.max(l.sizerWidth,Rt(e)-l.sizer.offsetLeft)-u.right,h=t.from(),d=t.to();if(h.line==d.line)o(h.line,h.ch,d.ch);else{var p=M(s,h.line),g=M(s,d.line),v=fe(p)==fe(g),m=o(h.line,h.ch,v?p.text.length+1:null).end,y=o(d.line,v?0:null,d.ch).start;v&&(m.top<y.top-2?(i(m.right,m.top,null,m.bottom),i(c,y.top,y.left,y.bottom)):i(m.right,m.top,y.left-m.right,m.bottom)),m.bottom<y.top&&i(c,m.bottom,null,y.top)}r.appendChild(a)}function Ar(e){if(e.state.focused){var t=e.display;clearInterval(t.blinker);var r=!0;t.cursorDiv.style.visibility="",e.options.cursorBlinkRate>0?t.blinker=setInterval(function(){return t.cursorDiv.style.visibility=(r=!r)?"":"hidden"},e.options.cursorBlinkRate):e.options.cursorBlinkRate<0&&(t.cursorDiv.style.visibility="hidden")}}function Wr(e){e.state.focused||(e.display.input.focus(),Hr(e))}function Dr(e){e.state.delayingBlurEvent=!0,setTimeout(function(){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1,Fr(e))},100)}function Hr(e,t){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1),"nocursor"!=e.options.readOnly&&(e.state.focused||(Te(e,"focus",e,t),e.state.focused=!0,s(e.display.wrapper,"CodeMirror-focused"),e.curOp||e.display.selForContextMenu==e.doc.sel||(e.display.input.reset(),ml&&setTimeout(function(){return e.display.input.reset(!0)},20)),e.display.input.receivedFocus()),Ar(e))}function Fr(e,t){e.state.delayingBlurEvent||(e.state.focused&&(Te(e,"blur",e,t),e.state.focused=!1,Fl(e.display.wrapper,"CodeMirror-focused")),clearInterval(e.display.blinker),setTimeout(function(){e.state.focused||(e.display.shift=!1)},150))}function Er(e){for(var t=e.display,r=t.lineDiv.offsetTop,n=0;n<t.view.length;n++){var i=t.view[n],o=void 0;if(!i.hidden){if(gl&&vl<8){var l=i.node.offsetTop+i.node.offsetHeight;o=l-r,r=l}else{var s=i.node.getBoundingClientRect();o=s.bottom-s.top}var a=i.line.height-o;if(o<2&&(o=mr(t)),(a>.005||a<-.005)&&(A(i.line,o),Pr(i.line),i.rest))for(var u=0;u<i.rest.length;u++)Pr(i.rest[u])}}}function Pr(e){if(e.widgets)for(var t=0;t<e.widgets.length;++t)e.widgets[t].height=e.widgets[t].node.parentNode.offsetHeight}function Ir(e,t,r){var n=r&&null!=r.top?Math.max(0,r.top):e.scroller.scrollTop;n=Math.floor(n-Et(e));var i=r&&null!=r.bottom?r.bottom:n+e.wrapper.clientHeight,o=D(t,n),l=D(t,i);if(r&&r.ensure){var s=r.ensure.from.line,a=r.ensure.to.line;s<o?(o=s,l=D(t,ye(M(t,s))+e.wrapper.clientHeight)):Math.min(a,t.lastLine())>=l&&(o=D(t,ye(M(t,a))-e.wrapper.clientHeight),l=a)}return{from:o,to:Math.max(l,o+1)}}function zr(e){var t=e.display,r=t.view;if(t.alignWidgets||t.gutters.firstChild&&e.options.fixedGutter){for(var n=wr(t)-t.scroller.scrollLeft+e.doc.scrollLeft,i=t.gutters.offsetWidth,o=n+"px",l=0;l<r.length;l++)if(!r[l].hidden){e.options.fixedGutter&&(r[l].gutter&&(r[l].gutter.style.left=o),r[l].gutterBackground&&(r[l].gutterBackground.style.left=o));var s=r[l].alignable;if(s)for(var a=0;a<s.length;a++)s[a].style.left=o}e.options.fixedGutter&&(t.gutters.style.left=n+i+"px")}}function Rr(e){if(!e.options.lineNumbers)return!1;var t=e.doc,r=F(e.options,t.first+t.size-1),i=e.display;if(r.length!=i.lineNumChars){var o=i.measure.appendChild(n("div",[n("div",r)],"CodeMirror-linenumber CodeMirror-gutter-elt")),l=o.firstChild.offsetWidth,s=o.offsetWidth-l;return i.lineGutter.style.width="",i.lineNumInnerWidth=Math.max(l,i.lineGutter.offsetWidth-s)+1,i.lineNumWidth=i.lineNumInnerWidth+s,i.lineNumChars=i.lineNumInnerWidth?r.length:-1,i.lineGutter.style.width=i.lineNumWidth+"px",Wn(e),!0}return!1}function Br(e,t){if(!Me(e,"scrollCursorIntoView")){var r=e.display,i=r.sizer.getBoundingClientRect(),o=null;if(t.top+i.top<0?o=!0:t.bottom+i.top>(window.innerHeight||document.documentElement.clientHeight)&&(o=!1),null!=o&&!Sl){var l=n("div","​",null,"position: absolute;\n                         top: "+(t.top-r.viewOffset-Et(e.display))+"px;\n                         height: "+(t.bottom-t.top+zt(e)+r.barHeight)+"px;\n                         left: "+t.left+"px; width: "+Math.max(2,t.right-t.left)+"px;");e.display.lineSpace.appendChild(l),l.scrollIntoView(o),e.display.lineSpace.removeChild(l)}}}function Gr(e,t,r,n){null==n&&(n=0);var i;e.options.lineWrapping||t!=r||(r="before"==(t=t.ch?E(t.line,"before"==t.sticky?t.ch-1:t.ch,"after"):t).sticky?E(t.line,t.ch+1,"before"):t);for(var o=0;o<5;o++){var l=!1,s=sr(e,t),a=r&&r!=t?sr(e,r):s,u=Vr(e,i={left:Math.min(s.left,a.left),top:Math.min(s.top,a.top)-n,right:Math.max(s.left,a.left),bottom:Math.max(s.bottom,a.bottom)+n}),c=e.doc.scrollTop,f=e.doc.scrollLeft;if(null!=u.scrollTop&&(qr(e,u.scrollTop),Math.abs(e.doc.scrollTop-c)>1&&(l=!0)),null!=u.scrollLeft&&(Qr(e,u.scrollLeft),Math.abs(e.doc.scrollLeft-f)>1&&(l=!0)),!l)break}return i}function Ur(e,t){var r=Vr(e,t);null!=r.scrollTop&&qr(e,r.scrollTop),null!=r.scrollLeft&&Qr(e,r.scrollLeft)}function Vr(e,t){var r=e.display,n=mr(e.display);t.top<0&&(t.top=0);var i=e.curOp&&null!=e.curOp.scrollTop?e.curOp.scrollTop:r.scroller.scrollTop,o=Bt(e),l={};t.bottom-t.top>o&&(t.bottom=t.top+o);var s=e.doc.height+Pt(r),a=t.top<n,u=t.bottom>s-n;if(t.top<i)l.scrollTop=a?0:t.top;else if(t.bottom>i+o){var c=Math.min(t.top,(u?s:t.bottom)-o);c!=i&&(l.scrollTop=c)}var f=e.curOp&&null!=e.curOp.scrollLeft?e.curOp.scrollLeft:r.scroller.scrollLeft,h=Rt(e)-(e.options.fixedGutter?r.gutters.offsetWidth:0),d=t.right-t.left>h;return d&&(t.right=t.left+h),t.left<10?l.scrollLeft=0:t.left<f?l.scrollLeft=Math.max(0,t.left-(d?0:10)):t.right>h+f-3&&(l.scrollLeft=t.right+(d?0:10)-h),l}function Kr(e,t){null!=t&&(_r(e),e.curOp.scrollTop=(null==e.curOp.scrollTop?e.doc.scrollTop:e.curOp.scrollTop)+t)}function jr(e){_r(e);var t=e.getCursor();e.curOp.scrollToPos={from:t,to:t,margin:e.options.cursorScrollMargin}}function Xr(e,t,r){null==t&&null==r||_r(e),null!=t&&(e.curOp.scrollLeft=t),null!=r&&(e.curOp.scrollTop=r)}function Yr(e,t){_r(e),e.curOp.scrollToPos=t}function _r(e){var t=e.curOp.scrollToPos;t&&(e.curOp.scrollToPos=null,$r(e,ar(e,t.from),ar(e,t.to),t.margin))}function $r(e,t,r,n){var i=Vr(e,{left:Math.min(t.left,r.left),top:Math.min(t.top,r.top)-n,right:Math.max(t.right,r.right),bottom:Math.max(t.bottom,r.bottom)+n});Xr(e,i.scrollLeft,i.scrollTop)}function qr(e,t){Math.abs(e.doc.scrollTop-t)<2||(fl||On(e,{top:t}),Zr(e,t,!0),fl&&On(e),Cn(e,100))}function Zr(e,t,r){t=Math.min(e.display.scroller.scrollHeight-e.display.scroller.clientHeight,t),(e.display.scroller.scrollTop!=t||r)&&(e.doc.scrollTop=t,e.display.scrollbars.setScrollTop(t),e.display.scroller.scrollTop!=t&&(e.display.scroller.scrollTop=t))}function Qr(e,t,r,n){t=Math.min(t,e.display.scroller.scrollWidth-e.display.scroller.clientWidth),(r?t==e.doc.scrollLeft:Math.abs(e.doc.scrollLeft-t)<2)&&!n||(e.doc.scrollLeft=t,zr(e),e.display.scroller.scrollLeft!=t&&(e.display.scroller.scrollLeft=t),e.display.scrollbars.setScrollLeft(t))}function Jr(e){var t=e.display,r=t.gutters.offsetWidth,n=Math.round(e.doc.height+Pt(e.display));return{clientHeight:t.scroller.clientHeight,viewHeight:t.wrapper.clientHeight,scrollWidth:t.scroller.scrollWidth,clientWidth:t.scroller.clientWidth,viewWidth:t.wrapper.clientWidth,barLeft:e.options.fixedGutter?r:0,docHeight:n,scrollHeight:n+zt(e)+t.barHeight,nativeBarWidth:t.nativeBarWidth,gutterWidth:r}}function en(e,t){t||(t=Jr(e));var r=e.display.barWidth,n=e.display.barHeight;tn(e,t);for(var i=0;i<4&&r!=e.display.barWidth||n!=e.display.barHeight;i++)r!=e.display.barWidth&&e.options.lineWrapping&&Er(e),tn(e,Jr(e)),r=e.display.barWidth,n=e.display.barHeight}function tn(e,t){var r=e.display,n=r.scrollbars.update(t);r.sizer.style.paddingRight=(r.barWidth=n.right)+"px",r.sizer.style.paddingBottom=(r.barHeight=n.bottom)+"px",r.heightForcer.style.borderBottom=n.bottom+"px solid transparent",n.right&&n.bottom?(r.scrollbarFiller.style.display="block",r.scrollbarFiller.style.height=n.bottom+"px",r.scrollbarFiller.style.width=n.right+"px"):r.scrollbarFiller.style.display="",n.bottom&&e.options.coverGutterNextToScrollbar&&e.options.fixedGutter?(r.gutterFiller.style.display="block",r.gutterFiller.style.height=n.bottom+"px",r.gutterFiller.style.width=t.gutterWidth+"px"):r.gutterFiller.style.display=""}function rn(e){e.display.scrollbars&&(e.display.scrollbars.clear(),e.display.scrollbars.addClass&&Fl(e.display.wrapper,e.display.scrollbars.addClass)),e.display.scrollbars=new ws[e.options.scrollbarStyle](function(t){e.display.wrapper.insertBefore(t,e.display.scrollbarFiller),Ql(t,"mousedown",function(){e.state.focused&&setTimeout(function(){return e.display.input.focus()},0)}),t.setAttribute("cm-not-content","true")},function(t,r){"horizontal"==r?Qr(e,t):qr(e,t)},e),e.display.scrollbars.addClass&&s(e.display.wrapper,e.display.scrollbars.addClass)}function nn(e){e.curOp={cm:e,viewChanged:!1,startHeight:e.doc.height,forceUpdate:!1,updateInput:null,typing:!1,changeObjs:null,cursorActivityHandlers:null,cursorActivityCalled:0,selectionChanged:!1,updateMaxLine:!1,scrollLeft:null,scrollTop:null,scrollToPos:null,focus:!1,id:++xs},vt(e.curOp)}function on(e){yt(e.curOp,function(e){for(var t=0;t<e.ops.length;t++)e.ops[t].cm.curOp=null;ln(e)})}function ln(e){for(var t=e.ops,r=0;r<t.length;r++)sn(t[r]);for(var n=0;n<t.length;n++)an(t[n]);for(var i=0;i<t.length;i++)un(t[i]);for(var o=0;o<t.length;o++)cn(t[o]);for(var l=0;l<t.length;l++)fn(t[l])}function sn(e){var t=e.cm,r=t.display;Ln(t),e.updateMaxLine&&we(t),e.mustUpdate=e.viewChanged||e.forceUpdate||null!=e.scrollTop||e.scrollToPos&&(e.scrollToPos.from.line<r.viewFrom||e.scrollToPos.to.line>=r.viewTo)||r.maxLineChanged&&t.options.lineWrapping,e.update=e.mustUpdate&&new Cs(t,e.mustUpdate&&{top:e.scrollTop,ensure:e.scrollToPos},e.forceUpdate)}function an(e){e.updatedDisplay=e.mustUpdate&&Mn(e.cm,e.update)}function un(e){var t=e.cm,r=t.display;e.updatedDisplay&&Er(t),e.barMeasure=Jr(t),r.maxLineChanged&&!t.options.lineWrapping&&(e.adjustWidthTo=Kt(t,r.maxLine,r.maxLine.text.length).left+3,t.display.sizerWidth=e.adjustWidthTo,e.barMeasure.scrollWidth=Math.max(r.scroller.clientWidth,r.sizer.offsetLeft+e.adjustWidthTo+zt(t)+t.display.barWidth),e.maxScrollLeft=Math.max(0,r.sizer.offsetLeft+e.adjustWidthTo-Rt(t))),(e.updatedDisplay||e.selectionChanged)&&(e.preparedSelection=r.input.prepareSelection())}function cn(e){var t=e.cm;null!=e.adjustWidthTo&&(t.display.sizer.style.minWidth=e.adjustWidthTo+"px",e.maxScrollLeft<t.doc.scrollLeft&&Qr(t,Math.min(t.display.scroller.scrollLeft,e.maxScrollLeft),!0),t.display.maxLineChanged=!1);var r=e.focus&&e.focus==l();e.preparedSelection&&t.display.input.showSelection(e.preparedSelection,r),(e.updatedDisplay||e.startHeight!=t.doc.height)&&en(t,e.barMeasure),e.updatedDisplay&&Dn(t,e.barMeasure),e.selectionChanged&&Ar(t),t.state.focused&&e.updateInput&&t.display.input.reset(e.typing),r&&Wr(e.cm)}function fn(e){var t=e.cm,r=t.display,n=t.doc;e.updatedDisplay&&Nn(t,e.update),null==r.wheelStartX||null==e.scrollTop&&null==e.scrollLeft&&!e.scrollToPos||(r.wheelStartX=r.wheelStartY=null),null!=e.scrollTop&&Zr(t,e.scrollTop,e.forceScroll),null!=e.scrollLeft&&Qr(t,e.scrollLeft,!0,!0),e.scrollToPos&&Br(t,Gr(t,U(n,e.scrollToPos.from),U(n,e.scrollToPos.to),e.scrollToPos.margin));var i=e.maybeHiddenMarkers,o=e.maybeUnhiddenMarkers;if(i)for(var l=0;l<i.length;++l)i[l].lines.length||Te(i[l],"hide");if(o)for(var s=0;s<o.length;++s)o[s].lines.length&&Te(o[s],"unhide");r.wrapper.offsetHeight&&(n.scrollTop=t.display.scroller.scrollTop),e.changeObjs&&Te(t,"changes",t,e.changeObjs),e.update&&e.update.finish()}function hn(e,t){if(e.curOp)return t();nn(e);try{return t()}finally{on(e)}}function dn(e,t){return function(){if(e.curOp)return t.apply(e,arguments);nn(e);try{return t.apply(e,arguments)}finally{on(e)}}}function pn(e){return function(){if(this.curOp)return e.apply(this,arguments);nn(this);try{return e.apply(this,arguments)}finally{on(this)}}}function gn(e){return function(){var t=this.cm;if(!t||t.curOp)return e.apply(this,arguments);nn(t);try{return e.apply(this,arguments)}finally{on(t)}}}function vn(e,t,r,n){null==t&&(t=e.doc.first),null==r&&(r=e.doc.first+e.doc.size),n||(n=0);var i=e.display;if(n&&r<i.viewTo&&(null==i.updateLineNumbers||i.updateLineNumbers>t)&&(i.updateLineNumbers=t),e.curOp.viewChanged=!0,t>=i.viewTo)_l&&pe(e.doc,t)<i.viewTo&&yn(e);else if(r<=i.viewFrom)_l&&ge(e.doc,r+n)>i.viewFrom?yn(e):(i.viewFrom+=n,i.viewTo+=n);else if(t<=i.viewFrom&&r>=i.viewTo)yn(e);else if(t<=i.viewFrom){var o=bn(e,r,r+n,1);o?(i.view=i.view.slice(o.index),i.viewFrom=o.lineN,i.viewTo+=n):yn(e)}else if(r>=i.viewTo){var l=bn(e,t,t,-1);l?(i.view=i.view.slice(0,l.index),i.viewTo=l.lineN):yn(e)}else{var s=bn(e,t,t,-1),a=bn(e,r,r+n,1);s&&a?(i.view=i.view.slice(0,s.index).concat(gt(e,s.lineN,a.lineN)).concat(i.view.slice(a.index)),i.viewTo+=n):yn(e)}var u=i.externalMeasured;u&&(r<u.lineN?u.lineN+=n:t<u.lineN+u.size&&(i.externalMeasured=null))}function mn(e,t,r){e.curOp.viewChanged=!0;var n=e.display,i=e.display.externalMeasured;if(i&&t>=i.lineN&&t<i.lineN+i.size&&(n.externalMeasured=null),!(t<n.viewFrom||t>=n.viewTo)){var o=n.view[Lr(e,t)];if(null!=o.node){var l=o.changes||(o.changes=[]);-1==h(l,r)&&l.push(r)}}}function yn(e){e.display.viewFrom=e.display.viewTo=e.doc.first,e.display.view=[],e.display.viewOffset=0}function bn(e,t,r,n){var i,o=Lr(e,t),l=e.display.view;if(!_l||r==e.doc.first+e.doc.size)return{index:o,lineN:r};for(var s=e.display.viewFrom,a=0;a<o;a++)s+=l[a].size;if(s!=t){if(n>0){if(o==l.length-1)return null;i=s+l[o].size-t,o++}else i=s-t;t+=i,r+=i}for(;pe(e.doc,r)!=r;){if(o==(n<0?0:l.length-1))return null;r+=n*l[o-(n<0?1:0)].size,o+=n}return{index:o,lineN:r}}function wn(e,t,r){var n=e.display;0==n.view.length||t>=n.viewTo||r<=n.viewFrom?(n.view=gt(e,t,r),n.viewFrom=t):(n.viewFrom>t?n.view=gt(e,t,n.viewFrom).concat(n.view):n.viewFrom<t&&(n.view=n.view.slice(Lr(e,t))),n.viewFrom=t,n.viewTo<r?n.view=n.view.concat(gt(e,n.viewTo,r)):n.viewTo>r&&(n.view=n.view.slice(0,Lr(e,r)))),n.viewTo=r}function xn(e){for(var t=e.display.view,r=0,n=0;n<t.length;n++){var i=t[n];i.hidden||i.node&&!i.changes||++r}return r}function Cn(e,t){e.doc.highlightFrontier<e.display.viewTo&&e.state.highlight.set(t,u(Sn,e))}function Sn(e){var t=e.doc;if(!(t.highlightFrontier>=e.display.viewTo)){var r=+new Date+e.options.workTime,n=$e(e,t.highlightFrontier),i=[];t.iter(n.line,Math.min(t.first+t.size,e.display.viewTo+500),function(o){if(n.line>=e.display.viewFrom){var l=o.styles,s=o.text.length>e.options.maxHighlightLength?Ke(t.mode,n.state):null,a=Ye(e,o,n,!0);s&&(n.state=s),o.styles=a.styles;var u=o.styleClasses,c=a.classes;c?o.styleClasses=c:u&&(o.styleClasses=null);for(var f=!l||l.length!=o.styles.length||u!=c&&(!u||!c||u.bgClass!=c.bgClass||u.textClass!=c.textClass),h=0;!f&&h<l.length;++h)f=l[h]!=o.styles[h];f&&i.push(n.line),o.stateAfter=n.save(),n.nextLine()}else o.text.length<=e.options.maxHighlightLength&&qe(e,o.text,n),o.stateAfter=n.line%5==0?n.save():null,n.nextLine();if(+new Date>r)return Cn(e,e.options.workDelay),!0}),t.highlightFrontier=n.line,t.modeFrontier=Math.max(t.modeFrontier,n.line),i.length&&hn(e,function(){for(var t=0;t<i.length;t++)mn(e,i[t],"text")})}}function Ln(e){var t=e.display;!t.scrollbarsClipped&&t.scroller.offsetWidth&&(t.nativeBarWidth=t.scroller.offsetWidth-t.scroller.clientWidth,t.heightForcer.style.height=zt(e)+"px",t.sizer.style.marginBottom=-t.nativeBarWidth+"px",t.sizer.style.borderRightWidth=zt(e)+"px",t.scrollbarsClipped=!0)}function kn(e){if(e.hasFocus())return null;var t=l();if(!t||!o(e.display.lineDiv,t))return null;var r={activeElt:t};if(window.getSelection){var n=window.getSelection();n.anchorNode&&n.extend&&o(e.display.lineDiv,n.anchorNode)&&(r.anchorNode=n.anchorNode,r.anchorOffset=n.anchorOffset,r.focusNode=n.focusNode,r.focusOffset=n.focusOffset)}return r}function Tn(e){if(e&&e.activeElt&&e.activeElt!=l()&&(e.activeElt.focus(),e.anchorNode&&o(document.body,e.anchorNode)&&o(document.body,e.focusNode))){var t=window.getSelection(),r=document.createRange();r.setEnd(e.anchorNode,e.anchorOffset),r.collapse(!1),t.removeAllRanges(),t.addRange(r),t.extend(e.focusNode,e.focusOffset)}}function Mn(e,r){var n=e.display,i=e.doc;if(r.editorIsHidden)return yn(e),!1;if(!r.force&&r.visible.from>=n.viewFrom&&r.visible.to<=n.viewTo&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo)&&n.renderedView==n.view&&0==xn(e))return!1;Rr(e)&&(yn(e),r.dims=br(e));var o=i.first+i.size,l=Math.max(r.visible.from-e.options.viewportMargin,i.first),s=Math.min(o,r.visible.to+e.options.viewportMargin);n.viewFrom<l&&l-n.viewFrom<20&&(l=Math.max(i.first,n.viewFrom)),n.viewTo>s&&n.viewTo-s<20&&(s=Math.min(o,n.viewTo)),_l&&(l=pe(e.doc,l),s=ge(e.doc,s));var a=l!=n.viewFrom||s!=n.viewTo||n.lastWrapHeight!=r.wrapperHeight||n.lastWrapWidth!=r.wrapperWidth;wn(e,l,s),n.viewOffset=ye(M(e.doc,n.viewFrom)),e.display.mover.style.top=n.viewOffset+"px";var u=xn(e);if(!a&&0==u&&!r.force&&n.renderedView==n.view&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo))return!1;var c=kn(e);return u>4&&(n.lineDiv.style.display="none"),An(e,n.updateLineNumbers,r.dims),u>4&&(n.lineDiv.style.display=""),n.renderedView=n.view,Tn(c),t(n.cursorDiv),t(n.selectionDiv),n.gutters.style.height=n.sizer.style.minHeight=0,a&&(n.lastWrapHeight=r.wrapperHeight,n.lastWrapWidth=r.wrapperWidth,Cn(e,400)),n.updateLineNumbers=null,!0}function Nn(e,t){for(var r=t.viewport,n=!0;(n&&e.options.lineWrapping&&t.oldDisplayWidth!=Rt(e)||(r&&null!=r.top&&(r={top:Math.min(e.doc.height+Pt(e.display)-Bt(e),r.top)}),t.visible=Ir(e.display,e.doc,r),!(t.visible.from>=e.display.viewFrom&&t.visible.to<=e.display.viewTo)))&&Mn(e,t);n=!1){Er(e);var i=Jr(e);kr(e),en(e,i),Dn(e,i),t.force=!1}t.signal(e,"update",e),e.display.viewFrom==e.display.reportedViewFrom&&e.display.viewTo==e.display.reportedViewTo||(t.signal(e,"viewportChange",e,e.display.viewFrom,e.display.viewTo),e.display.reportedViewFrom=e.display.viewFrom,e.display.reportedViewTo=e.display.viewTo)}function On(e,t){var r=new Cs(e,t);if(Mn(e,r)){Er(e),Nn(e,r);var n=Jr(e);kr(e),en(e,n),Dn(e,n),r.finish()}}function An(e,r,n){function i(t){var r=t.nextSibling;return ml&&Ml&&e.display.currentWheelTarget==t?t.style.display="none":t.parentNode.removeChild(t),r}for(var o=e.display,l=e.options.lineNumbers,s=o.lineDiv,a=s.firstChild,u=o.view,c=o.viewFrom,f=0;f<u.length;f++){var d=u[f];if(d.hidden);else if(d.node&&d.node.parentNode==s){for(;a!=d.node;)a=i(a);var p=l&&null!=r&&r<=c&&d.lineNumber;d.changes&&(h(d.changes,"gutter")>-1&&(p=!1),xt(e,d,c,n)),p&&(t(d.lineNumber),d.lineNumber.appendChild(document.createTextNode(F(e.options,c)))),a=d.node.nextSibling}else{var g=Ot(e,d,c,n);s.insertBefore(g,a)}c+=d.size}for(;a;)a=i(a)}function Wn(e){var t=e.display.gutters.offsetWidth;e.display.sizer.style.marginLeft=t+"px"}function Dn(e,t){e.display.sizer.style.minHeight=t.docHeight+"px",e.display.heightForcer.style.top=t.docHeight+"px",e.display.gutters.style.height=t.docHeight+e.display.barHeight+zt(e)+"px"}function Hn(e){var r=e.display.gutters,i=e.options.gutters;t(r);for(var o=0;o<i.length;++o){var l=i[o],s=r.appendChild(n("div",null,"CodeMirror-gutter "+l));"CodeMirror-linenumbers"==l&&(e.display.lineGutter=s,s.style.width=(e.display.lineNumWidth||1)+"px")}r.style.display=o?"":"none",Wn(e)}function Fn(e){var t=h(e.gutters,"CodeMirror-linenumbers");-1==t&&e.lineNumbers?e.gutters=e.gutters.concat(["CodeMirror-linenumbers"]):t>-1&&!e.lineNumbers&&(e.gutters=e.gutters.slice(0),e.gutters.splice(t,1))}function En(e){var t=e.wheelDeltaX,r=e.wheelDeltaY;return null==t&&e.detail&&e.axis==e.HORIZONTAL_AXIS&&(t=e.detail),null==r&&e.detail&&e.axis==e.VERTICAL_AXIS?r=e.detail:null==r&&(r=e.wheelDelta),{x:t,y:r}}function Pn(e){var t=En(e);return t.x*=Ls,t.y*=Ls,t}function In(e,t){var r=En(t),n=r.x,i=r.y,o=e.display,l=o.scroller,s=l.scrollWidth>l.clientWidth,a=l.scrollHeight>l.clientHeight;if(n&&s||i&&a){if(i&&Ml&&ml)e:for(var u=t.target,c=o.view;u!=l;u=u.parentNode)for(var f=0;f<c.length;f++)if(c[f].node==u){e.display.currentWheelTarget=u;break e}if(n&&!fl&&!wl&&null!=Ls)return i&&a&&qr(e,Math.max(0,l.scrollTop+i*Ls)),Qr(e,Math.max(0,l.scrollLeft+n*Ls)),(!i||i&&a)&&We(t),void(o.wheelStartX=null);if(i&&null!=Ls){var h=i*Ls,d=e.doc.scrollTop,p=d+o.wrapper.clientHeight;h<0?d=Math.max(0,d+h-50):p=Math.min(e.doc.height,p+h+50),On(e,{top:d,bottom:p})}Ss<20&&(null==o.wheelStartX?(o.wheelStartX=l.scrollLeft,o.wheelStartY=l.scrollTop,o.wheelDX=n,o.wheelDY=i,setTimeout(function(){if(null!=o.wheelStartX){var e=l.scrollLeft-o.wheelStartX,t=l.scrollTop-o.wheelStartY,r=t&&o.wheelDY&&t/o.wheelDY||e&&o.wheelDX&&e/o.wheelDX;o.wheelStartX=o.wheelStartY=null,r&&(Ls=(Ls*Ss+r)/(Ss+1),++Ss)}},200)):(o.wheelDX+=n,o.wheelDY+=i))}}function zn(e,t){var r=e[t];e.sort(function(e,t){return P(e.from(),t.from())}),t=h(e,r);for(var n=1;n<e.length;n++){var i=e[n],o=e[n-1];if(P(o.to(),i.from())>=0){var l=B(o.from(),i.from()),s=R(o.to(),i.to()),a=o.empty()?i.from()==i.head:o.from()==o.head;n<=t&&--t,e.splice(--n,2,new Ts(a?s:l,a?l:s))}}return new ks(e,t)}function Rn(e,t){return new ks([new Ts(e,t||e)],0)}function Bn(e){return e.text?E(e.from.line+e.text.length-1,g(e.text).length+(1==e.text.length?e.from.ch:0)):e.to}function Gn(e,t){if(P(e,t.from)<0)return e;if(P(e,t.to)<=0)return Bn(t);var r=e.line+t.text.length-(t.to.line-t.from.line)-1,n=e.ch;return e.line==t.to.line&&(n+=Bn(t).ch-t.to.ch),E(r,n)}function Un(e,t){for(var r=[],n=0;n<e.sel.ranges.length;n++){var i=e.sel.ranges[n];r.push(new Ts(Gn(i.anchor,t),Gn(i.head,t)))}return zn(r,e.sel.primIndex)}function Vn(e,t,r){return e.line==t.line?E(r.line,e.ch-t.ch+r.ch):E(r.line+(e.line-t.line),e.ch)}function Kn(e,t,r){for(var n=[],i=E(e.first,0),o=i,l=0;l<t.length;l++){var s=t[l],a=Vn(s.from,i,o),u=Vn(Bn(s),i,o);if(i=s.to,o=u,"around"==r){var c=e.sel.ranges[l],f=P(c.head,c.anchor)<0;n[l]=new Ts(f?u:a,f?a:u)}else n[l]=new Ts(a,a)}return new ks(n,e.sel.primIndex)}function jn(e){e.doc.mode=Ue(e.options,e.doc.modeOption),Xn(e)}function Xn(e){e.doc.iter(function(e){e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null)}),e.doc.modeFrontier=e.doc.highlightFrontier=e.doc.first,Cn(e,100),e.state.modeGen++,e.curOp&&vn(e)}function Yn(e,t){return 0==t.from.ch&&0==t.to.ch&&""==g(t.text)&&(!e.cm||e.cm.options.wholeLineUpdateBefore)}function _n(e,t,r,n){function i(e){return r?r[e]:null}function o(e,r,i){it(e,r,i,n),bt(e,"change",e,t)}function l(e,t){for(var r=[],o=e;o<t;++o)r.push(new fs(u[o],i(o),n));return r}var s=t.from,a=t.to,u=t.text,c=M(e,s.line),f=M(e,a.line),h=g(u),d=i(u.length-1),p=a.line-s.line;if(t.full)e.insert(0,l(0,u.length)),e.remove(u.length,e.size-u.length);else if(Yn(e,t)){var v=l(0,u.length-1);o(f,f.text,d),p&&e.remove(s.line,p),v.length&&e.insert(s.line,v)}else if(c==f)if(1==u.length)o(c,c.text.slice(0,s.ch)+h+c.text.slice(a.ch),d);else{var m=l(1,u.length-1);m.push(new fs(h+c.text.slice(a.ch),d,n)),o(c,c.text.slice(0,s.ch)+u[0],i(0)),e.insert(s.line+1,m)}else if(1==u.length)o(c,c.text.slice(0,s.ch)+u[0]+f.text.slice(a.ch),i(0)),e.remove(s.line+1,p);else{o(c,c.text.slice(0,s.ch)+u[0],i(0)),o(f,h+f.text.slice(a.ch),d);var y=l(1,u.length-1);p>1&&e.remove(s.line+1,p-1),e.insert(s.line+1,y)}bt(e,"change",e,t)}function $n(e,t,r){function n(e,i,o){if(e.linked)for(var l=0;l<e.linked.length;++l){var s=e.linked[l];if(s.doc!=i){var a=o&&s.sharedHist;r&&!a||(t(s.doc,a),n(s.doc,e,a))}}}n(e,null,!0)}function qn(e,t){if(t.cm)throw new Error("This document is already in use.");e.doc=t,t.cm=e,Cr(e),jn(e),Zn(e),e.options.lineWrapping||we(e),e.options.mode=t.modeOption,vn(e)}function Zn(e){("rtl"==e.doc.direction?s:Fl)(e.display.lineDiv,"CodeMirror-rtl")}function Qn(e){hn(e,function(){Zn(e),vn(e)})}function Jn(e){this.done=[],this.undone=[],this.undoDepth=1/0,this.lastModTime=this.lastSelTime=0,this.lastOp=this.lastSelOp=null,this.lastOrigin=this.lastSelOrigin=null,this.generation=this.maxGeneration=e||1}function ei(e,t){var r={from:z(t.from),to:Bn(t),text:N(e,t.from,t.to)};return si(e,r,t.from.line,t.to.line+1),$n(e,function(e){return si(e,r,t.from.line,t.to.line+1)},!0),r}function ti(e){for(;e.length&&g(e).ranges;)e.pop()}function ri(e,t){return t?(ti(e.done),g(e.done)):e.done.length&&!g(e.done).ranges?g(e.done):e.done.length>1&&!e.done[e.done.length-2].ranges?(e.done.pop(),g(e.done)):void 0}function ni(e,t,r,n){var i=e.history;i.undone.length=0;var o,l,s=+new Date;if((i.lastOp==n||i.lastOrigin==t.origin&&t.origin&&("+"==t.origin.charAt(0)&&e.cm&&i.lastModTime>s-e.cm.options.historyEventDelay||"*"==t.origin.charAt(0)))&&(o=ri(i,i.lastOp==n)))l=g(o.changes),0==P(t.from,t.to)&&0==P(t.from,l.to)?l.to=Bn(t):o.changes.push(ei(e,t));else{var a=g(i.done);for(a&&a.ranges||li(e.sel,i.done),o={changes:[ei(e,t)],generation:i.generation},i.done.push(o);i.done.length>i.undoDepth;)i.done.shift(),i.done[0].ranges||i.done.shift()}i.done.push(r),i.generation=++i.maxGeneration,i.lastModTime=i.lastSelTime=s,i.lastOp=i.lastSelOp=n,i.lastOrigin=i.lastSelOrigin=t.origin,l||Te(e,"historyAdded")}function ii(e,t,r,n){var i=t.charAt(0);return"*"==i||"+"==i&&r.ranges.length==n.ranges.length&&r.somethingSelected()==n.somethingSelected()&&new Date-e.history.lastSelTime<=(e.cm?e.cm.options.historyEventDelay:500)}function oi(e,t,r,n){var i=e.history,o=n&&n.origin;r==i.lastSelOp||o&&i.lastSelOrigin==o&&(i.lastModTime==i.lastSelTime&&i.lastOrigin==o||ii(e,o,g(i.done),t))?i.done[i.done.length-1]=t:li(t,i.done),i.lastSelTime=+new Date,i.lastSelOrigin=o,i.lastSelOp=r,n&&!1!==n.clearRedo&&ti(i.undone)}function li(e,t){var r=g(t);r&&r.ranges&&r.equals(e)||t.push(e)}function si(e,t,r,n){var i=t["spans_"+e.id],o=0;e.iter(Math.max(e.first,r),Math.min(e.first+e.size,n),function(r){r.markedSpans&&((i||(i=t["spans_"+e.id]={}))[o]=r.markedSpans),++o})}function ai(e){if(!e)return null;for(var t,r=0;r<e.length;++r)e[r].marker.explicitlyCleared?t||(t=e.slice(0,r)):t&&t.push(e[r]);return t?t.length?t:null:e}function ui(e,t){var r=t["spans_"+e.id];if(!r)return null;for(var n=[],i=0;i<t.text.length;++i)n.push(ai(r[i]));return n}function ci(e,t){var r=ui(e,t),n=J(e,t);if(!r)return n;if(!n)return r;for(var i=0;i<r.length;++i){var o=r[i],l=n[i];if(o&&l)e:for(var s=0;s<l.length;++s){for(var a=l[s],u=0;u<o.length;++u)if(o[u].marker==a.marker)continue e;o.push(a)}else l&&(r[i]=l)}return r}function fi(e,t,r){for(var n=[],i=0;i<e.length;++i){var o=e[i];if(o.ranges)n.push(r?ks.prototype.deepCopy.call(o):o);else{var l=o.changes,s=[];n.push({changes:s});for(var a=0;a<l.length;++a){var u=l[a],c=void 0;if(s.push({from:u.from,to:u.to,text:u.text}),t)for(var f in u)(c=f.match(/^spans_(\d+)$/))&&h(t,Number(c[1]))>-1&&(g(s)[f]=u[f],delete u[f])}}}return n}function hi(e,t,r,n){if(n){var i=e.anchor;if(r){var o=P(t,i)<0;o!=P(r,i)<0?(i=t,t=r):o!=P(t,r)<0&&(t=r)}return new Ts(i,t)}return new Ts(r||t,t)}function di(e,t,r,n,i){null==i&&(i=e.cm&&(e.cm.display.shift||e.extend)),bi(e,new ks([hi(e.sel.primary(),t,r,i)],0),n)}function pi(e,t,r){for(var n=[],i=e.cm&&(e.cm.display.shift||e.extend),o=0;o<e.sel.ranges.length;o++)n[o]=hi(e.sel.ranges[o],t[o],null,i);bi(e,zn(n,e.sel.primIndex),r)}function gi(e,t,r,n){var i=e.sel.ranges.slice(0);i[t]=r,bi(e,zn(i,e.sel.primIndex),n)}function vi(e,t,r,n){bi(e,Rn(t,r),n)}function mi(e,t,r){var n={ranges:t.ranges,update:function(t){var r=this;this.ranges=[];for(var n=0;n<t.length;n++)r.ranges[n]=new Ts(U(e,t[n].anchor),U(e,t[n].head))},origin:r&&r.origin};return Te(e,"beforeSelectionChange",e,n),e.cm&&Te(e.cm,"beforeSelectionChange",e.cm,n),n.ranges!=t.ranges?zn(n.ranges,n.ranges.length-1):t}function yi(e,t,r){var n=e.history.done,i=g(n);i&&i.ranges?(n[n.length-1]=t,wi(e,t,r)):bi(e,t,r)}function bi(e,t,r){wi(e,t,r),oi(e,e.sel,e.cm?e.cm.curOp.id:NaN,r)}function wi(e,t,r){(Oe(e,"beforeSelectionChange")||e.cm&&Oe(e.cm,"beforeSelectionChange"))&&(t=mi(e,t,r)),xi(e,Si(e,t,r&&r.bias||(P(t.primary().head,e.sel.primary().head)<0?-1:1),!0)),r&&!1===r.scroll||!e.cm||jr(e.cm)}function xi(e,t){t.equals(e.sel)||(e.sel=t,e.cm&&(e.cm.curOp.updateInput=e.cm.curOp.selectionChanged=!0,Ne(e.cm)),bt(e,"cursorActivity",e))}function Ci(e){xi(e,Si(e,e.sel,null,!1))}function Si(e,t,r,n){for(var i,o=0;o<t.ranges.length;o++){var l=t.ranges[o],s=t.ranges.length==e.sel.ranges.length&&e.sel.ranges[o],a=ki(e,l.anchor,s&&s.anchor,r,n),u=ki(e,l.head,s&&s.head,r,n);(i||a!=l.anchor||u!=l.head)&&(i||(i=t.ranges.slice(0,o)),i[o]=new Ts(a,u))}return i?zn(i,t.primIndex):t}function Li(e,t,r,n,i){var o=M(e,t.line);if(o.markedSpans)for(var l=0;l<o.markedSpans.length;++l){var s=o.markedSpans[l],a=s.marker;if((null==s.from||(a.inclusiveLeft?s.from<=t.ch:s.from<t.ch))&&(null==s.to||(a.inclusiveRight?s.to>=t.ch:s.to>t.ch))){if(i&&(Te(a,"beforeCursorEnter"),a.explicitlyCleared)){if(o.markedSpans){--l;continue}break}if(!a.atomic)continue;if(r){var u=a.find(n<0?1:-1),c=void 0;if((n<0?a.inclusiveRight:a.inclusiveLeft)&&(u=Ti(e,u,-n,u&&u.line==t.line?o:null)),u&&u.line==t.line&&(c=P(u,r))&&(n<0?c<0:c>0))return Li(e,u,t,n,i)}var f=a.find(n<0?-1:1);return(n<0?a.inclusiveLeft:a.inclusiveRight)&&(f=Ti(e,f,n,f.line==t.line?o:null)),f?Li(e,f,t,n,i):null}}return t}function ki(e,t,r,n,i){var o=n||1,l=Li(e,t,r,o,i)||!i&&Li(e,t,r,o,!0)||Li(e,t,r,-o,i)||!i&&Li(e,t,r,-o,!0);return l||(e.cantEdit=!0,E(e.first,0))}function Ti(e,t,r,n){return r<0&&0==t.ch?t.line>e.first?U(e,E(t.line-1)):null:r>0&&t.ch==(n||M(e,t.line)).text.length?t.line<e.first+e.size-1?E(t.line+1,0):null:new E(t.line,t.ch+r)}function Mi(e){e.setSelection(E(e.firstLine(),0),E(e.lastLine()),Gl)}function Ni(e,t,r){var n={canceled:!1,from:t.from,to:t.to,text:t.text,origin:t.origin,cancel:function(){return n.canceled=!0}};return r&&(n.update=function(t,r,i,o){t&&(n.from=U(e,t)),r&&(n.to=U(e,r)),i&&(n.text=i),void 0!==o&&(n.origin=o)}),Te(e,"beforeChange",e,n),e.cm&&Te(e.cm,"beforeChange",e.cm,n),n.canceled?null:{from:n.from,to:n.to,text:n.text,origin:n.origin}}function Oi(e,t,r){if(e.cm){if(!e.cm.curOp)return dn(e.cm,Oi)(e,t,r);if(e.cm.state.suppressEdits)return}if(!(Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"))||(t=Ni(e,t,!0))){var n=Yl&&!r&&te(e,t.from,t.to);if(n)for(var i=n.length-1;i>=0;--i)Ai(e,{from:n[i].from,to:n[i].to,text:i?[""]:t.text,origin:t.origin});else Ai(e,t)}}function Ai(e,t){if(1!=t.text.length||""!=t.text[0]||0!=P(t.from,t.to)){var r=Un(e,t);ni(e,t,r,e.cm?e.cm.curOp.id:NaN),Hi(e,t,r,J(e,t));var n=[];$n(e,function(e,r){r||-1!=h(n,e.history)||(zi(e.history,t),n.push(e.history)),Hi(e,t,null,J(e,t))})}}function Wi(e,t,r){if(!e.cm||!e.cm.state.suppressEdits||r){for(var n,i=e.history,o=e.sel,l="undo"==t?i.done:i.undone,s="undo"==t?i.undone:i.done,a=0;a<l.length&&(n=l[a],r?!n.ranges||n.equals(e.sel):n.ranges);a++);if(a!=l.length){for(i.lastOrigin=i.lastSelOrigin=null;(n=l.pop()).ranges;){if(li(n,s),r&&!n.equals(e.sel))return void bi(e,n,{clearRedo:!1});o=n}var u=[];li(o,s),s.push({changes:u,generation:i.generation}),i.generation=n.generation||++i.maxGeneration;for(var c=Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"),f=n.changes.length-1;f>=0;--f){var d=function(r){var i=n.changes[r];if(i.origin=t,c&&!Ni(e,i,!1))return l.length=0,{};u.push(ei(e,i));var o=r?Un(e,i):g(l);Hi(e,i,o,ci(e,i)),!r&&e.cm&&e.cm.scrollIntoView({from:i.from,to:Bn(i)});var s=[];$n(e,function(e,t){t||-1!=h(s,e.history)||(zi(e.history,i),s.push(e.history)),Hi(e,i,null,ci(e,i))})}(f);if(d)return d.v}}}}function Di(e,t){if(0!=t&&(e.first+=t,e.sel=new ks(v(e.sel.ranges,function(e){return new Ts(E(e.anchor.line+t,e.anchor.ch),E(e.head.line+t,e.head.ch))}),e.sel.primIndex),e.cm)){vn(e.cm,e.first,e.first-t,t);for(var r=e.cm.display,n=r.viewFrom;n<r.viewTo;n++)mn(e.cm,n,"gutter")}}function Hi(e,t,r,n){if(e.cm&&!e.cm.curOp)return dn(e.cm,Hi)(e,t,r,n);if(t.to.line<e.first)Di(e,t.text.length-1-(t.to.line-t.from.line));else if(!(t.from.line>e.lastLine())){if(t.from.line<e.first){var i=t.text.length-1-(e.first-t.from.line);Di(e,i),t={from:E(e.first,0),to:E(t.to.line+i,t.to.ch),text:[g(t.text)],origin:t.origin}}var o=e.lastLine();t.to.line>o&&(t={from:t.from,to:E(o,M(e,o).text.length),text:[t.text[0]],origin:t.origin}),t.removed=N(e,t.from,t.to),r||(r=Un(e,t)),e.cm?Fi(e.cm,t,n):_n(e,t,n),wi(e,r,Gl)}}function Fi(e,t,r){var n=e.doc,i=e.display,o=t.from,l=t.to,s=!1,a=o.line;e.options.lineWrapping||(a=W(fe(M(n,o.line))),n.iter(a,l.line+1,function(e){if(e==i.maxLine)return s=!0,!0})),n.sel.contains(t.from,t.to)>-1&&Ne(e),_n(n,t,r,xr(e)),e.options.lineWrapping||(n.iter(a,o.line+t.text.length,function(e){var t=be(e);t>i.maxLineLength&&(i.maxLine=e,i.maxLineLength=t,i.maxLineChanged=!0,s=!1)}),s&&(e.curOp.updateMaxLine=!0)),nt(n,o.line),Cn(e,400);var u=t.text.length-(l.line-o.line)-1;t.full?vn(e):o.line!=l.line||1!=t.text.length||Yn(e.doc,t)?vn(e,o.line,l.line+1,u):mn(e,o.line,"text");var c=Oe(e,"changes"),f=Oe(e,"change");if(f||c){var h={from:o,to:l,text:t.text,removed:t.removed,origin:t.origin};f&&bt(e,"change",e,h),c&&(e.curOp.changeObjs||(e.curOp.changeObjs=[])).push(h)}e.display.selForContextMenu=null}function Ei(e,t,r,n,i){if(n||(n=r),P(n,r)<0){var o;r=(o=[n,r])[0],n=o[1]}"string"==typeof t&&(t=e.splitLines(t)),Oi(e,{from:r,to:n,text:t,origin:i})}function Pi(e,t,r,n){r<e.line?e.line+=n:t<e.line&&(e.line=t,e.ch=0)}function Ii(e,t,r,n){for(var i=0;i<e.length;++i){var o=e[i],l=!0;if(o.ranges){o.copied||((o=e[i]=o.deepCopy()).copied=!0);for(var s=0;s<o.ranges.length;s++)Pi(o.ranges[s].anchor,t,r,n),Pi(o.ranges[s].head,t,r,n)}else{for(var a=0;a<o.changes.length;++a){var u=o.changes[a];if(r<u.from.line)u.from=E(u.from.line+n,u.from.ch),u.to=E(u.to.line+n,u.to.ch);else if(t<=u.to.line){l=!1;break}}l||(e.splice(0,i+1),i=0)}}}function zi(e,t){var r=t.from.line,n=t.to.line,i=t.text.length-(n-r)-1;Ii(e.done,r,n,i),Ii(e.undone,r,n,i)}function Ri(e,t,r,n){var i=t,o=t;return"number"==typeof t?o=M(e,G(e,t)):i=W(t),null==i?null:(n(o,i)&&e.cm&&mn(e.cm,i,r),o)}function Bi(e){var t=this;this.lines=e,this.parent=null;for(var r=0,n=0;n<e.length;++n)e[n].parent=t,r+=e[n].height;this.height=r}function Gi(e){var t=this;this.children=e;for(var r=0,n=0,i=0;i<e.length;++i){var o=e[i];r+=o.chunkSize(),n+=o.height,o.parent=t}this.size=r,this.height=n,this.parent=null}function Ui(e,t,r){ye(t)<(e.curOp&&e.curOp.scrollTop||e.doc.scrollTop)&&Kr(e,r)}function Vi(e,t,r,n){var i=new Ms(e,r,n),o=e.cm;return o&&i.noHScroll&&(o.display.alignWidgets=!0),Ri(e,t,"widget",function(t){var r=t.widgets||(t.widgets=[]);if(null==i.insertAt?r.push(i):r.splice(Math.min(r.length-1,Math.max(0,i.insertAt)),0,i),i.line=t,o&&!ve(e,t)){var n=ye(t)<e.scrollTop;A(t,t.height+Ht(i)),n&&Kr(o,i.height),o.curOp.forceUpdate=!0}return!0}),bt(o,"lineWidgetAdded",o,i,"number"==typeof t?t:W(t)),i}function Ki(e,t,r,n,o){if(n&&n.shared)return ji(e,t,r,n,o);if(e.cm&&!e.cm.curOp)return dn(e.cm,Ki)(e,t,r,n,o);var l=new Os(e,o),s=P(t,r);if(n&&c(n,l,!1),s>0||0==s&&!1!==l.clearWhenEmpty)return l;if(l.replacedWith&&(l.collapsed=!0,l.widgetNode=i("span",[l.replacedWith],"CodeMirror-widget"),n.handleMouseEvents||l.widgetNode.setAttribute("cm-ignore-events","true"),n.insertLeft&&(l.widgetNode.insertLeft=!0)),l.collapsed){if(ce(e,t.line,t,r,l)||t.line!=r.line&&ce(e,r.line,t,r,l))throw new Error("Inserting collapsed marker partially overlapping an existing one");X()}l.addToHistory&&ni(e,{from:t,to:r,origin:"markText"},e.sel,NaN);var a,u=t.line,f=e.cm;if(e.iter(u,r.line+1,function(e){f&&l.collapsed&&!f.options.lineWrapping&&fe(e)==f.display.maxLine&&(a=!0),l.collapsed&&u!=t.line&&A(e,0),q(e,new Y(l,u==t.line?t.ch:null,u==r.line?r.ch:null)),++u}),l.collapsed&&e.iter(t.line,r.line+1,function(t){ve(e,t)&&A(t,0)}),l.clearOnEnter&&Ql(l,"beforeCursorEnter",function(){return l.clear()}),l.readOnly&&(j(),(e.history.done.length||e.history.undone.length)&&e.clearHistory()),l.collapsed&&(l.id=++Ns,l.atomic=!0),f){if(a&&(f.curOp.updateMaxLine=!0),l.collapsed)vn(f,t.line,r.line+1);else if(l.className||l.title||l.startStyle||l.endStyle||l.css)for(var h=t.line;h<=r.line;h++)mn(f,h,"text");l.atomic&&Ci(f.doc),bt(f,"markerAdded",f,l)}return l}function ji(e,t,r,n,i){(n=c(n)).shared=!1;var o=[Ki(e,t,r,n,i)],l=o[0],s=n.widgetNode;return $n(e,function(e){s&&(n.widgetNode=s.cloneNode(!0)),o.push(Ki(e,U(e,t),U(e,r),n,i));for(var a=0;a<e.linked.length;++a)if(e.linked[a].isParent)return;l=g(o)}),new As(o,l)}function Xi(e){return e.findMarks(E(e.first,0),e.clipPos(E(e.lastLine())),function(e){return e.parent})}function Yi(e,t){for(var r=0;r<t.length;r++){var n=t[r],i=n.find(),o=e.clipPos(i.from),l=e.clipPos(i.to);if(P(o,l)){var s=Ki(e,o,l,n.primary,n.primary.type);n.markers.push(s),s.parent=n}}}function _i(e){for(var t=0;t<e.length;t++)!function(t){var r=e[t],n=[r.primary.doc];$n(r.primary.doc,function(e){return n.push(e)});for(var i=0;i<r.markers.length;i++){var o=r.markers[i];-1==h(n,o.doc)&&(o.parent=null,r.markers.splice(i--,1))}}(t)}function $i(e){var t=this;if(Qi(t),!Me(t,e)&&!Ft(t.display,e)){We(e),gl&&(Hs=+new Date);var r=Sr(t,e,!0),n=e.dataTransfer.files;if(r&&!t.isReadOnly())if(n&&n.length&&window.FileReader&&window.File)for(var i=n.length,o=Array(i),l=0,s=0;s<i;++s)!function(e,n){if(!t.options.allowDropFileTypes||-1!=h(t.options.allowDropFileTypes,e.type)){var s=new FileReader;s.onload=dn(t,function(){var e=s.result;if(/[\x00-\x08\x0e-\x1f]{2}/.test(e)&&(e=""),o[n]=e,++l==i){var a={from:r=U(t.doc,r),to:r,text:t.doc.splitLines(o.join(t.doc.lineSeparator())),origin:"paste"};Oi(t.doc,a),yi(t.doc,Rn(r,Bn(a)))}}),s.readAsText(e)}}(n[s],s);else{if(t.state.draggingText&&t.doc.sel.contains(r)>-1)return t.state.draggingText(e),void setTimeout(function(){return t.display.input.focus()},20);try{var a=e.dataTransfer.getData("Text");if(a){var u;if(t.state.draggingText&&!t.state.draggingText.copy&&(u=t.listSelections()),wi(t.doc,Rn(r,r)),u)for(var c=0;c<u.length;++c)Ei(t.doc,"",u[c].anchor,u[c].head,"drag");t.replaceSelection(a,"around","paste"),t.display.input.focus()}}catch(e){}}}}function qi(e,t){if(gl&&(!e.state.draggingText||+new Date-Hs<100))Fe(t);else if(!Me(e,t)&&!Ft(e.display,t)&&(t.dataTransfer.setData("Text",e.getSelection()),t.dataTransfer.effectAllowed="copyMove",t.dataTransfer.setDragImage&&!xl)){var r=n("img",null,null,"position: fixed; left: 0; top: 0;");r.src="data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==",wl&&(r.width=r.height=1,e.display.wrapper.appendChild(r),r._top=r.offsetTop),t.dataTransfer.setDragImage(r,0,0),wl&&r.parentNode.removeChild(r)}}function Zi(e,t){var i=Sr(e,t);if(i){var o=document.createDocumentFragment();Mr(e,i,o),e.display.dragCursor||(e.display.dragCursor=n("div",null,"CodeMirror-cursors CodeMirror-dragcursors"),e.display.lineSpace.insertBefore(e.display.dragCursor,e.display.cursorDiv)),r(e.display.dragCursor,o)}}function Qi(e){e.display.dragCursor&&(e.display.lineSpace.removeChild(e.display.dragCursor),e.display.dragCursor=null)}function Ji(e){if(document.getElementsByClassName)for(var t=document.getElementsByClassName("CodeMirror"),r=0;r<t.length;r++){var n=t[r].CodeMirror;n&&e(n)}}function eo(){Fs||(to(),Fs=!0)}function to(){var e;Ql(window,"resize",function(){null==e&&(e=setTimeout(function(){e=null,Ji(ro)},100))}),Ql(window,"blur",function(){return Ji(Fr)})}function ro(e){var t=e.display;t.lastWrapHeight==t.wrapper.clientHeight&&t.lastWrapWidth==t.wrapper.clientWidth||(t.cachedCharWidth=t.cachedTextHeight=t.cachedPaddingH=null,t.scrollbarsClipped=!1,e.setSize())}function no(e){var t=e.split(/-(?!$)/);e=t[t.length-1];for(var r,n,i,o,l=0;l<t.length-1;l++){var s=t[l];if(/^(cmd|meta|m)$/i.test(s))o=!0;else if(/^a(lt)?$/i.test(s))r=!0;else if(/^(c|ctrl|control)$/i.test(s))n=!0;else{if(!/^s(hift)?$/i.test(s))throw new Error("Unrecognized modifier name: "+s);i=!0}}return r&&(e="Alt-"+e),n&&(e="Ctrl-"+e),o&&(e="Cmd-"+e),i&&(e="Shift-"+e),e}function io(e){var t={};for(var r in e)if(e.hasOwnProperty(r)){var n=e[r];if(/^(name|fallthrough|(de|at)tach)$/.test(r))continue;if("..."==n){delete e[r];continue}for(var i=v(r.split(" "),no),o=0;o<i.length;o++){var l=void 0,s=void 0;o==i.length-1?(s=i.join(" "),l=n):(s=i.slice(0,o+1).join(" "),l="...");var a=t[s];if(a){if(a!=l)throw new Error("Inconsistent bindings for "+s)}else t[s]=l}delete e[r]}for(var u in t)e[u]=t[u];return e}function oo(e,t,r,n){var i=(t=uo(t)).call?t.call(e,n):t[e];if(!1===i)return"nothing";if("..."===i)return"multi";if(null!=i&&r(i))return"handled";if(t.fallthrough){if("[object Array]"!=Object.prototype.toString.call(t.fallthrough))return oo(e,t.fallthrough,r,n);for(var o=0;o<t.fallthrough.length;o++){var l=oo(e,t.fallthrough[o],r,n);if(l)return l}}}function lo(e){var t="string"==typeof e?e:Es[e.keyCode];return"Ctrl"==t||"Alt"==t||"Shift"==t||"Mod"==t}function so(e,t,r){var n=e;return t.altKey&&"Alt"!=n&&(e="Alt-"+e),(Dl?t.metaKey:t.ctrlKey)&&"Ctrl"!=n&&(e="Ctrl-"+e),(Dl?t.ctrlKey:t.metaKey)&&"Cmd"!=n&&(e="Cmd-"+e),!r&&t.shiftKey&&"Shift"!=n&&(e="Shift-"+e),e}function ao(e,t){if(wl&&34==e.keyCode&&e.char)return!1;var r=Es[e.keyCode];return null!=r&&!e.altGraphKey&&so(r,e,t)}function uo(e){return"string"==typeof e?Rs[e]:e}function co(e,t){for(var r=e.doc.sel.ranges,n=[],i=0;i<r.length;i++){for(var o=t(r[i]);n.length&&P(o.from,g(n).to)<=0;){var l=n.pop();if(P(l.from,o.from)<0){o.from=l.from;break}}n.push(o)}hn(e,function(){for(var t=n.length-1;t>=0;t--)Ei(e.doc,"",n[t].from,n[t].to,"+delete");jr(e)})}function fo(e,t,r){var n=L(e.text,t+r,r);return n<0||n>e.text.length?null:n}function ho(e,t,r){var n=fo(e,t.ch,r);return null==n?null:new E(t.line,n,r<0?"after":"before")}function po(e,t,r,n,i){if(e){var o=Se(r,t.doc.direction);if(o){var l,s=i<0?g(o):o[0],a=i<0==(1==s.level)?"after":"before";if(s.level>0){var u=Xt(t,r);l=i<0?r.text.length-1:0;var c=Yt(t,u,l).top;l=k(function(e){return Yt(t,u,e).top==c},i<0==(1==s.level)?s.from:s.to-1,l),"before"==a&&(l=fo(r,l,1))}else l=i<0?s.to:s.from;return new E(n,l,a)}}return new E(n,i<0?r.text.length:0,i<0?"before":"after")}function go(e,t,r,n){var i=Se(t,e.doc.direction);if(!i)return ho(t,r,n);r.ch>=t.text.length?(r.ch=t.text.length,r.sticky="before"):r.ch<=0&&(r.ch=0,r.sticky="after");var o=Ce(i,r.ch,r.sticky),l=i[o];if("ltr"==e.doc.direction&&l.level%2==0&&(n>0?l.to>r.ch:l.from<r.ch))return ho(t,r,n);var s,a=function(e,r){return fo(t,e instanceof E?e.ch:e,r)},u=function(r){return e.options.lineWrapping?(s=s||Xt(e,t),hr(e,t,s,r)):{begin:0,end:t.text.length}},c=u("before"==r.sticky?a(r,-1):r.ch);if("rtl"==e.doc.direction||1==l.level){var f=1==l.level==n<0,h=a(r,f?1:-1);if(null!=h&&(f?h<=l.to&&h<=c.end:h>=l.from&&h>=c.begin)){var d=f?"before":"after";return new E(r.line,h,d)}}var p=function(e,t,n){for(var o=function(e,t){return t?new E(r.line,a(e,1),"before"):new E(r.line,e,"after")};e>=0&&e<i.length;e+=t){var l=i[e],s=t>0==(1!=l.level),u=s?n.begin:a(n.end,-1);if(l.from<=u&&u<l.to)return o(u,s);if(u=s?l.from:a(l.to,-1),n.begin<=u&&u<n.end)return o(u,s)}},g=p(o+n,n,c);if(g)return g;var v=n>0?c.end:a(c.begin,-1);return null==v||n>0&&v==t.text.length||!(g=p(n>0?0:i.length-1,n,u(v)))?null:g}function vo(e,t){var r=M(e.doc,t),n=fe(r);return n!=r&&(t=W(n)),po(!0,e,n,t,1)}function mo(e,t){var r=M(e.doc,t),n=he(r);return n!=r&&(t=W(n)),po(!0,e,r,t,-1)}function yo(e,t){var r=vo(e,t.line),n=M(e.doc,r.line),i=Se(n,e.doc.direction);if(!i||0==i[0].level){var o=Math.max(0,n.text.search(/\S/)),l=t.line==r.line&&t.ch<=o&&t.ch;return E(r.line,l?0:o,r.sticky)}return r}function bo(e,t,r){if("string"==typeof t&&!(t=Bs[t]))return!1;e.display.input.ensurePolled();var n=e.display.shift,i=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),r&&(e.display.shift=!1),i=t(e)!=Bl}finally{e.display.shift=n,e.state.suppressEdits=!1}return i}function wo(e,t,r){for(var n=0;n<e.state.keyMaps.length;n++){var i=oo(t,e.state.keyMaps[n],r,e);if(i)return i}return e.options.extraKeys&&oo(t,e.options.extraKeys,r,e)||oo(t,e.options.keyMap,r,e)}function xo(e,t,r,n){var i=e.state.keySeq;if(i){if(lo(t))return"handled";Gs.set(50,function(){e.state.keySeq==i&&(e.state.keySeq=null,e.display.input.reset())}),t=i+" "+t}var o=wo(e,t,n);return"multi"==o&&(e.state.keySeq=t),"handled"==o&&bt(e,"keyHandled",e,t,r),"handled"!=o&&"multi"!=o||(We(r),Ar(e)),i&&!o&&/\'$/.test(t)?(We(r),!0):!!o}function Co(e,t){var r=ao(t,!0);return!!r&&(t.shiftKey&&!e.state.keySeq?xo(e,"Shift-"+r,t,function(t){return bo(e,t,!0)})||xo(e,r,t,function(t){if("string"==typeof t?/^go[A-Z]/.test(t):t.motion)return bo(e,t)}):xo(e,r,t,function(t){return bo(e,t)}))}function So(e,t,r){return xo(e,"'"+r+"'",t,function(t){return bo(e,t,!0)})}function Lo(e){var t=this;if(t.curOp.focus=l(),!Me(t,e)){gl&&vl<11&&27==e.keyCode&&(e.returnValue=!1);var r=e.keyCode;t.display.shift=16==r||e.shiftKey;var n=Co(t,e);wl&&(Us=n?r:null,!n&&88==r&&!rs&&(Ml?e.metaKey:e.ctrlKey)&&t.replaceSelection("",null,"cut")),18!=r||/\bCodeMirror-crosshair\b/.test(t.display.lineDiv.className)||ko(t)}}function ko(e){function t(e){18!=e.keyCode&&e.altKey||(Fl(r,"CodeMirror-crosshair"),ke(document,"keyup",t),ke(document,"mouseover",t))}var r=e.display.lineDiv;s(r,"CodeMirror-crosshair"),Ql(document,"keyup",t),Ql(document,"mouseover",t)}function To(e){16==e.keyCode&&(this.doc.sel.shift=!1),Me(this,e)}function Mo(e){var t=this;if(!(Ft(t.display,e)||Me(t,e)||e.ctrlKey&&!e.altKey||Ml&&e.metaKey)){var r=e.keyCode,n=e.charCode;if(wl&&r==Us)return Us=null,void We(e);if(!wl||e.which&&!(e.which<10)||!Co(t,e)){var i=String.fromCharCode(null==n?r:n);"\b"!=i&&(So(t,e,i)||t.display.input.onKeyPress(e))}}}function No(e,t){var r=+new Date;return js&&js.compare(r,e,t)?(Ks=js=null,"triple"):Ks&&Ks.compare(r,e,t)?(js=new Vs(r,e,t),Ks=null,"double"):(Ks=new Vs(r,e,t),js=null,"single")}function Oo(e){var t=this,r=t.display;if(!(Me(t,e)||r.activeTouch&&r.input.supportsTouch()))if(r.input.ensurePolled(),r.shift=e.shiftKey,Ft(r,e))ml||(r.scroller.draggable=!1,setTimeout(function(){return r.scroller.draggable=!0},100));else if(!zo(t,e)){var n=Sr(t,e),i=Pe(e),o=n?No(n,i):"single";window.focus(),1==i&&t.state.selectingText&&t.state.selectingText(e),n&&Ao(t,i,n,o,e)||(1==i?n?Do(t,n,o,e):Ee(e)==r.scroller&&We(e):2==i?(n&&di(t.doc,n),setTimeout(function(){return r.input.focus()},20)):3==i&&(Hl?Ro(t,e):Dr(t)))}}function Ao(e,t,r,n,i){var o="Click";return"double"==n?o="Double"+o:"triple"==n&&(o="Triple"+o),o=(1==t?"Left":2==t?"Middle":"Right")+o,xo(e,so(o,i),i,function(t){if("string"==typeof t&&(t=Bs[t]),!t)return!1;var n=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),n=t(e,r)!=Bl}finally{e.state.suppressEdits=!1}return n})}function Wo(e,t,r){var n=e.getOption("configureMouse"),i=n?n(e,t,r):{};if(null==i.unit){var o=Nl?r.shiftKey&&r.metaKey:r.altKey;i.unit=o?"rectangle":"single"==t?"char":"double"==t?"word":"line"}return(null==i.extend||e.doc.extend)&&(i.extend=e.doc.extend||r.shiftKey),null==i.addNew&&(i.addNew=Ml?r.metaKey:r.ctrlKey),null==i.moveOnDrag&&(i.moveOnDrag=!(Ml?r.altKey:r.ctrlKey)),i}function Do(e,t,r,n){gl?setTimeout(u(Wr,e),0):e.curOp.focus=l();var i,o=Wo(e,r,n),s=e.doc.sel;e.options.dragDrop&&Jl&&!e.isReadOnly()&&"single"==r&&(i=s.contains(t))>-1&&(P((i=s.ranges[i]).from(),t)<0||t.xRel>0)&&(P(i.to(),t)>0||t.xRel<0)?Ho(e,n,t,o):Eo(e,n,t,o)}function Ho(e,t,r,n){var i=e.display,o=!1,l=dn(e,function(t){ml&&(i.scroller.draggable=!1),e.state.draggingText=!1,ke(document,"mouseup",l),ke(document,"mousemove",s),ke(i.scroller,"dragstart",a),ke(i.scroller,"drop",l),o||(We(t),n.addNew||di(e.doc,r,null,null,n.extend),ml||gl&&9==vl?setTimeout(function(){document.body.focus(),i.input.focus()},20):i.input.focus())}),s=function(e){o=o||Math.abs(t.clientX-e.clientX)+Math.abs(t.clientY-e.clientY)>=10},a=function(){return o=!0};ml&&(i.scroller.draggable=!0),e.state.draggingText=l,l.copy=!n.moveOnDrag,i.scroller.dragDrop&&i.scroller.dragDrop(),Ql(document,"mouseup",l),Ql(document,"mousemove",s),Ql(i.scroller,"dragstart",a),Ql(i.scroller,"drop",l),Dr(e),setTimeout(function(){return i.input.focus()},20)}function Fo(e,t,r){if("char"==r)return new Ts(t,t);if("word"==r)return e.findWordAt(t);if("line"==r)return new Ts(E(t.line,0),U(e.doc,E(t.line+1,0)));var n=r(e,t);return new Ts(n.from,n.to)}function Eo(e,t,r,n){function i(t){if(0!=P(m,t))if(m=t,"rectangle"==n.unit){for(var i=[],o=e.options.tabSize,l=f(M(u,r.line).text,r.ch,o),s=f(M(u,t.line).text,t.ch,o),a=Math.min(l,s),g=Math.max(l,s),v=Math.min(r.line,t.line),y=Math.min(e.lastLine(),Math.max(r.line,t.line));v<=y;v++){var b=M(u,v).text,w=d(b,a,o);a==g?i.push(new Ts(E(v,w),E(v,w))):b.length>w&&i.push(new Ts(E(v,w),E(v,d(b,g,o))))}i.length||i.push(new Ts(r,r)),bi(u,zn(p.ranges.slice(0,h).concat(i),h),{origin:"*mouse",scroll:!1}),e.scrollIntoView(t)}else{var x,C=c,S=Fo(e,t,n.unit),L=C.anchor;P(S.anchor,L)>0?(x=S.head,L=B(C.from(),S.anchor)):(x=S.anchor,L=R(C.to(),S.head));var k=p.ranges.slice(0);k[h]=Po(e,new Ts(U(u,L),x)),bi(u,zn(k,h),Ul)}}function o(t){var r=++b,s=Sr(e,t,!0,"rectangle"==n.unit);if(s)if(0!=P(s,m)){e.curOp.focus=l(),i(s);var c=Ir(a,u);(s.line>=c.to||s.line<c.from)&&setTimeout(dn(e,function(){b==r&&o(t)}),150)}else{var f=t.clientY<y.top?-20:t.clientY>y.bottom?20:0;f&&setTimeout(dn(e,function(){b==r&&(a.scroller.scrollTop+=f,o(t))}),50)}}function s(t){e.state.selectingText=!1,b=1/0,We(t),a.input.focus(),ke(document,"mousemove",w),ke(document,"mouseup",x),u.history.lastSelOrigin=null}var a=e.display,u=e.doc;We(t);var c,h,p=u.sel,g=p.ranges;if(n.addNew&&!n.extend?(h=u.sel.contains(r),c=h>-1?g[h]:new Ts(r,r)):(c=u.sel.primary(),h=u.sel.primIndex),"rectangle"==n.unit)n.addNew||(c=new Ts(r,r)),r=Sr(e,t,!0,!0),h=-1;else{var v=Fo(e,r,n.unit);c=n.extend?hi(c,v.anchor,v.head,n.extend):v}n.addNew?-1==h?(h=g.length,bi(u,zn(g.concat([c]),h),{scroll:!1,origin:"*mouse"})):g.length>1&&g[h].empty()&&"char"==n.unit&&!n.extend?(bi(u,zn(g.slice(0,h).concat(g.slice(h+1)),0),{scroll:!1,origin:"*mouse"}),p=u.sel):gi(u,h,c,Ul):(h=0,bi(u,new ks([c],0),Ul),p=u.sel);var m=r,y=a.wrapper.getBoundingClientRect(),b=0,w=dn(e,function(e){Pe(e)?o(e):s(e)}),x=dn(e,s);e.state.selectingText=x,Ql(document,"mousemove",w),Ql(document,"mouseup",x)}function Po(e,t){var r=t.anchor,n=t.head,i=M(e.doc,r.line);if(0==P(r,n)&&r.sticky==n.sticky)return t;var o=Se(i);if(!o)return t;var l=Ce(o,r.ch,r.sticky),s=o[l];if(s.from!=r.ch&&s.to!=r.ch)return t;var a=l+(s.from==r.ch==(1!=s.level)?0:1);if(0==a||a==o.length)return t;var u;if(n.line!=r.line)u=(n.line-r.line)*("ltr"==e.doc.direction?1:-1)>0;else{var c=Ce(o,n.ch,n.sticky),f=c-l||(n.ch-r.ch)*(1==s.level?-1:1);u=c==a-1||c==a?f<0:f>0}var h=o[a+(u?-1:0)],d=u==(1==h.level),p=d?h.from:h.to,g=d?"after":"before";return r.ch==p&&r.sticky==g?t:new Ts(new E(r.line,p,g),n)}function Io(e,t,r,n){var i,o;if(t.touches)i=t.touches[0].clientX,o=t.touches[0].clientY;else try{i=t.clientX,o=t.clientY}catch(t){return!1}if(i>=Math.floor(e.display.gutters.getBoundingClientRect().right))return!1;n&&We(t);var l=e.display,s=l.lineDiv.getBoundingClientRect();if(o>s.bottom||!Oe(e,r))return He(t);o-=s.top-l.viewOffset;for(var a=0;a<e.options.gutters.length;++a){var u=l.gutters.childNodes[a];if(u&&u.getBoundingClientRect().right>=i)return Te(e,r,e,D(e.doc,o),e.options.gutters[a],t),He(t)}}function zo(e,t){return Io(e,t,"gutterClick",!0)}function Ro(e,t){Ft(e.display,t)||Bo(e,t)||Me(e,t,"contextmenu")||e.display.input.onContextMenu(t)}function Bo(e,t){return!!Oe(e,"gutterContextMenu")&&Io(e,t,"gutterContextMenu",!1)}function Go(e){e.display.wrapper.className=e.display.wrapper.className.replace(/\s*cm-s-\S+/g,"")+e.options.theme.replace(/(^|\s)\s*/g," cm-s-"),er(e)}function Uo(e){Hn(e),vn(e),zr(e)}function Vo(e,t,r){if(!t!=!(r&&r!=Xs)){var n=e.display.dragFunctions,i=t?Ql:ke;i(e.display.scroller,"dragstart",n.start),i(e.display.scroller,"dragenter",n.enter),i(e.display.scroller,"dragover",n.over),i(e.display.scroller,"dragleave",n.leave),i(e.display.scroller,"drop",n.drop)}}function Ko(e){e.options.lineWrapping?(s(e.display.wrapper,"CodeMirror-wrap"),e.display.sizer.style.minWidth="",e.display.sizerWidth=null):(Fl(e.display.wrapper,"CodeMirror-wrap"),we(e)),Cr(e),vn(e),er(e),setTimeout(function(){return en(e)},100)}function jo(e,t){var r=this;if(!(this instanceof jo))return new jo(e,t);this.options=t=t?c(t):{},c(Ys,t,!1),Fn(t);var n=t.value;"string"==typeof n&&(n=new Ds(n,t.mode,null,t.lineSeparator,t.direction)),this.doc=n;var i=new jo.inputStyles[t.inputStyle](this),o=this.display=new T(e,n,i);o.wrapper.CodeMirror=this,Hn(this),Go(this),t.lineWrapping&&(this.display.wrapper.className+=" CodeMirror-wrap"),rn(this),this.state={keyMaps:[],overlays:[],modeGen:0,overwrite:!1,delayingBlurEvent:!1,focused:!1,suppressEdits:!1,pasteIncoming:!1,cutIncoming:!1,selectingText:!1,draggingText:!1,highlight:new Pl,keySeq:null,specialChars:null},t.autofocus&&!Tl&&o.input.focus(),gl&&vl<11&&setTimeout(function(){return r.display.input.reset(!0)},20),Xo(this),eo(),nn(this),this.curOp.forceUpdate=!0,qn(this,n),t.autofocus&&!Tl||this.hasFocus()?setTimeout(u(Hr,this),20):Fr(this);for(var l in _s)_s.hasOwnProperty(l)&&_s[l](r,t[l],Xs);Rr(this),t.finishInit&&t.finishInit(this);for(var s=0;s<$s.length;++s)$s[s](r);on(this),ml&&t.lineWrapping&&"optimizelegibility"==getComputedStyle(o.lineDiv).textRendering&&(o.lineDiv.style.textRendering="auto")}function Xo(e){function t(){i.activeTouch&&(o=setTimeout(function(){return i.activeTouch=null},1e3),(l=i.activeTouch).end=+new Date)}function r(e){if(1!=e.touches.length)return!1;var t=e.touches[0];return t.radiusX<=1&&t.radiusY<=1}function n(e,t){if(null==t.left)return!0;var r=t.left-e.left,n=t.top-e.top;return r*r+n*n>400}var i=e.display;Ql(i.scroller,"mousedown",dn(e,Oo)),gl&&vl<11?Ql(i.scroller,"dblclick",dn(e,function(t){if(!Me(e,t)){var r=Sr(e,t);if(r&&!zo(e,t)&&!Ft(e.display,t)){We(t);var n=e.findWordAt(r);di(e.doc,n.anchor,n.head)}}})):Ql(i.scroller,"dblclick",function(t){return Me(e,t)||We(t)}),Hl||Ql(i.scroller,"contextmenu",function(t){return Ro(e,t)});var o,l={end:0};Ql(i.scroller,"touchstart",function(t){if(!Me(e,t)&&!r(t)&&!zo(e,t)){i.input.ensurePolled(),clearTimeout(o);var n=+new Date;i.activeTouch={start:n,moved:!1,prev:n-l.end<=300?l:null},1==t.touches.length&&(i.activeTouch.left=t.touches[0].pageX,i.activeTouch.top=t.touches[0].pageY)}}),Ql(i.scroller,"touchmove",function(){i.activeTouch&&(i.activeTouch.moved=!0)}),Ql(i.scroller,"touchend",function(r){var o=i.activeTouch;if(o&&!Ft(i,r)&&null!=o.left&&!o.moved&&new Date-o.start<300){var l,s=e.coordsChar(i.activeTouch,"page");l=!o.prev||n(o,o.prev)?new Ts(s,s):!o.prev.prev||n(o,o.prev.prev)?e.findWordAt(s):new Ts(E(s.line,0),U(e.doc,E(s.line+1,0))),e.setSelection(l.anchor,l.head),e.focus(),We(r)}t()}),Ql(i.scroller,"touchcancel",t),Ql(i.scroller,"scroll",function(){i.scroller.clientHeight&&(qr(e,i.scroller.scrollTop),Qr(e,i.scroller.scrollLeft,!0),Te(e,"scroll",e))}),Ql(i.scroller,"mousewheel",function(t){return In(e,t)}),Ql(i.scroller,"DOMMouseScroll",function(t){return In(e,t)}),Ql(i.wrapper,"scroll",function(){return i.wrapper.scrollTop=i.wrapper.scrollLeft=0}),i.dragFunctions={enter:function(t){Me(e,t)||Fe(t)},over:function(t){Me(e,t)||(Zi(e,t),Fe(t))},start:function(t){return qi(e,t)},drop:dn(e,$i),leave:function(t){Me(e,t)||Qi(e)}};var s=i.input.getField();Ql(s,"keyup",function(t){return To.call(e,t)}),Ql(s,"keydown",dn(e,Lo)),Ql(s,"keypress",dn(e,Mo)),Ql(s,"focus",function(t){return Hr(e,t)}),Ql(s,"blur",function(t){return Fr(e,t)})}function Yo(e,t,r,n){var i,o=e.doc;null==r&&(r="add"),"smart"==r&&(o.mode.indent?i=$e(e,t).state:r="prev");var l=e.options.tabSize,s=M(o,t),a=f(s.text,null,l);s.stateAfter&&(s.stateAfter=null);var u,c=s.text.match(/^\s*/)[0];if(n||/\S/.test(s.text)){if("smart"==r&&((u=o.mode.indent(i,s.text.slice(c.length),s.text))==Bl||u>150)){if(!n)return;r="prev"}}else u=0,r="not";"prev"==r?u=t>o.first?f(M(o,t-1).text,null,l):0:"add"==r?u=a+e.options.indentUnit:"subtract"==r?u=a-e.options.indentUnit:"number"==typeof r&&(u=a+r),u=Math.max(0,u);var h="",d=0;if(e.options.indentWithTabs)for(var g=Math.floor(u/l);g;--g)d+=l,h+="\t";if(d<u&&(h+=p(u-d)),h!=c)return Ei(o,h,E(t,0),E(t,c.length),"+input"),s.stateAfter=null,!0;for(var v=0;v<o.sel.ranges.length;v++){var m=o.sel.ranges[v];if(m.head.line==t&&m.head.ch<c.length){var y=E(t,c.length);gi(o,v,new Ts(y,y));break}}}function _o(e){qs=e}function $o(e,t,r,n,i){var o=e.doc;e.display.shift=!1,n||(n=o.sel);var l=e.state.pasteIncoming||"paste"==i,s=es(t),a=null;if(l&&n.ranges.length>1)if(qs&&qs.text.join("\n")==t){if(n.ranges.length%qs.text.length==0){a=[];for(var u=0;u<qs.text.length;u++)a.push(o.splitLines(qs.text[u]))}}else s.length==n.ranges.length&&e.options.pasteLinesPerSelection&&(a=v(s,function(e){return[e]}));for(var c,f=n.ranges.length-1;f>=0;f--){var h=n.ranges[f],d=h.from(),p=h.to();h.empty()&&(r&&r>0?d=E(d.line,d.ch-r):e.state.overwrite&&!l?p=E(p.line,Math.min(M(o,p.line).text.length,p.ch+g(s).length)):qs&&qs.lineWise&&qs.text.join("\n")==t&&(d=p=E(d.line,0))),c=e.curOp.updateInput;var m={from:d,to:p,text:a?a[f%a.length]:s,origin:i||(l?"paste":e.state.cutIncoming?"cut":"+input")};Oi(e.doc,m),bt(e,"inputRead",e,m)}t&&!l&&Zo(e,t),jr(e),e.curOp.updateInput=c,e.curOp.typing=!0,e.state.pasteIncoming=e.state.cutIncoming=!1}function qo(e,t){var r=e.clipboardData&&e.clipboardData.getData("Text");if(r)return e.preventDefault(),t.isReadOnly()||t.options.disableInput||hn(t,function(){return $o(t,r,0,null,"paste")}),!0}function Zo(e,t){if(e.options.electricChars&&e.options.smartIndent)for(var r=e.doc.sel,n=r.ranges.length-1;n>=0;n--){var i=r.ranges[n];if(!(i.head.ch>100||n&&r.ranges[n-1].head.line==i.head.line)){var o=e.getModeAt(i.head),l=!1;if(o.electricChars){for(var s=0;s<o.electricChars.length;s++)if(t.indexOf(o.electricChars.charAt(s))>-1){l=Yo(e,i.head.line,"smart");break}}else o.electricInput&&o.electricInput.test(M(e.doc,i.head.line).text.slice(0,i.head.ch))&&(l=Yo(e,i.head.line,"smart"));l&&bt(e,"electricInput",e,i.head.line)}}}function Qo(e){for(var t=[],r=[],n=0;n<e.doc.sel.ranges.length;n++){var i=e.doc.sel.ranges[n].head.line,o={anchor:E(i,0),head:E(i+1,0)};r.push(o),t.push(e.getRange(o.anchor,o.head))}return{text:t,ranges:r}}function Jo(e,t){e.setAttribute("autocorrect","off"),e.setAttribute("autocapitalize","off"),e.setAttribute("spellcheck",!!t)}function el(){var e=n("textarea",null,null,"position: absolute; bottom: -1em; padding: 0; width: 1px; height: 1em; outline: none"),t=n("div",[e],null,"overflow: hidden; position: relative; width: 3px; height: 0px;");return ml?e.style.width="1000px":e.setAttribute("wrap","off"),Ll&&(e.style.border="1px solid black"),Jo(e),t}function tl(e,t,r,n,i){function o(){var n=t.line+r;return!(n<e.first||n>=e.first+e.size)&&(t=new E(n,t.ch,t.sticky),u=M(e,n))}function l(n){var l;if(null==(l=i?go(e.cm,u,t,r):ho(u,t,r))){if(n||!o())return!1;t=po(i,e.cm,u,t.line,r)}else t=l;return!0}var s=t,a=r,u=M(e,t.line);if("char"==n)l();else if("column"==n)l(!0);else if("word"==n||"group"==n)for(var c=null,f="group"==n,h=e.cm&&e.cm.getHelper(t,"wordChars"),d=!0;!(r<0)||l(!d);d=!1){var p=u.text.charAt(t.ch)||"\n",g=x(p,h)?"w":f&&"\n"==p?"n":!f||/\s/.test(p)?null:"p";if(!f||d||g||(g="s"),c&&c!=g){r<0&&(r=1,l(),t.sticky="after");break}if(g&&(c=g),r>0&&!l(!d))break}var v=ki(e,t,s,a,!0);return I(s,v)&&(v.hitSide=!0),v}function rl(e,t,r,n){var i,o=e.doc,l=t.left;if("page"==n){var s=Math.min(e.display.wrapper.clientHeight,window.innerHeight||document.documentElement.clientHeight),a=Math.max(s-.5*mr(e.display),3);i=(r>0?t.bottom:t.top)+r*a}else"line"==n&&(i=r>0?t.bottom+3:t.top-3);for(var u;(u=cr(e,l,i)).outside;){if(r<0?i<=0:i>=o.height){u.hitSide=!0;break}i+=5*r}return u}function nl(e,t){var r=jt(e,t.line);if(!r||r.hidden)return null;var n=M(e.doc,t.line),i=Ut(r,n,t.line),o=Se(n,e.doc.direction),l="left";o&&(l=Ce(o,t.ch)%2?"right":"left");var s=_t(i.map,t.ch,l);return s.offset="right"==s.collapse?s.end:s.start,s}function il(e){for(var t=e;t;t=t.parentNode)if(/CodeMirror-gutter-wrapper/.test(t.className))return!0;return!1}function ol(e,t){return t&&(e.bad=!0),e}function ll(e,t,r,n,i){function o(e){return function(t){return t.id==e}}function l(){c&&(u+=f,c=!1)}function s(e){e&&(l(),u+=e)}function a(t){if(1==t.nodeType){var r=t.getAttribute("cm-text");if(null!=r)return void s(r||t.textContent.replace(/\u200b/g,""));var u,h=t.getAttribute("cm-marker");if(h){var d=e.findMarks(E(n,0),E(i+1,0),o(+h));return void(d.length&&(u=d[0].find(0))&&s(N(e.doc,u.from,u.to).join(f)))}if("false"==t.getAttribute("contenteditable"))return;var p=/^(pre|div|p)$/i.test(t.nodeName);p&&l();for(var g=0;g<t.childNodes.length;g++)a(t.childNodes[g]);p&&(c=!0)}else 3==t.nodeType&&s(t.nodeValue)}for(var u="",c=!1,f=e.doc.lineSeparator();a(t),t!=r;)t=t.nextSibling;return u}function sl(e,t,r){var n;if(t==e.display.lineDiv){if(!(n=e.display.lineDiv.childNodes[r]))return ol(e.clipPos(E(e.display.viewTo-1)),!0);t=null,r=0}else for(n=t;;n=n.parentNode){if(!n||n==e.display.lineDiv)return null;if(n.parentNode&&n.parentNode==e.display.lineDiv)break}for(var i=0;i<e.display.view.length;i++){var o=e.display.view[i];if(o.node==n)return al(o,t,r)}}function al(e,t,r){function n(t,r,n){for(var i=-1;i<(f?f.length:0);i++)for(var o=i<0?c.map:f[i],l=0;l<o.length;l+=3){var s=o[l+2];if(s==t||s==r){var a=W(i<0?e.line:e.rest[i]),u=o[l]+n;return(n<0||s!=t)&&(u=o[l+(n?1:0)]),E(a,u)}}}var i=e.text.firstChild,l=!1;if(!t||!o(i,t))return ol(E(W(e.line),0),!0);if(t==i&&(l=!0,t=i.childNodes[r],r=0,!t)){var s=e.rest?g(e.rest):e.line;return ol(E(W(s),s.text.length),l)}var a=3==t.nodeType?t:null,u=t;for(a||1!=t.childNodes.length||3!=t.firstChild.nodeType||(a=t.firstChild,r&&(r=a.nodeValue.length));u.parentNode!=i;)u=u.parentNode;var c=e.measure,f=c.maps,h=n(a,u,r);if(h)return ol(h,l);for(var d=u.nextSibling,p=a?a.nodeValue.length-r:0;d;d=d.nextSibling){if(h=n(d,d.firstChild,0))return ol(E(h.line,h.ch-p),l);p+=d.textContent.length}for(var v=u.previousSibling,m=r;v;v=v.previousSibling){if(h=n(v,v.firstChild,-1))return ol(E(h.line,h.ch+m),l);m+=v.textContent.length}}var ul=navigator.userAgent,cl=navigator.platform,fl=/gecko\/\d/i.test(ul),hl=/MSIE \d/.test(ul),dl=/Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(ul),pl=/Edge\/(\d+)/.exec(ul),gl=hl||dl||pl,vl=gl&&(hl?document.documentMode||6:+(pl||dl)[1]),ml=!pl&&/WebKit\//.test(ul),yl=ml&&/Qt\/\d+\.\d+/.test(ul),bl=!pl&&/Chrome\//.test(ul),wl=/Opera\//.test(ul),xl=/Apple Computer/.test(navigator.vendor),Cl=/Mac OS X 1\d\D([8-9]|\d\d)\D/.test(ul),Sl=/PhantomJS/.test(ul),Ll=!pl&&/AppleWebKit/.test(ul)&&/Mobile\/\w+/.test(ul),kl=/Android/.test(ul),Tl=Ll||kl||/webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(ul),Ml=Ll||/Mac/.test(cl),Nl=/\bCrOS\b/.test(ul),Ol=/win/i.test(cl),Al=wl&&ul.match(/Version\/(\d*\.\d*)/);Al&&(Al=Number(Al[1])),Al&&Al>=15&&(wl=!1,ml=!0);var Wl,Dl=Ml&&(yl||wl&&(null==Al||Al<12.11)),Hl=fl||gl&&vl>=9,Fl=function(t,r){var n=t.className,i=e(r).exec(n);if(i){var o=n.slice(i.index+i[0].length);t.className=n.slice(0,i.index)+(o?i[1]+o:"")}};Wl=document.createRange?function(e,t,r,n){var i=document.createRange();return i.setEnd(n||e,r),i.setStart(e,t),i}:function(e,t,r){var n=document.body.createTextRange();try{n.moveToElementText(e.parentNode)}catch(e){return n}return n.collapse(!0),n.moveEnd("character",r),n.moveStart("character",t),n};var El=function(e){e.select()};Ll?El=function(e){e.selectionStart=0,e.selectionEnd=e.value.length}:gl&&(El=function(e){try{e.select()}catch(e){}});var Pl=function(){this.id=null};Pl.prototype.set=function(e,t){clearTimeout(this.id),this.id=setTimeout(t,e)};var Il,zl,Rl=30,Bl={toString:function(){return"CodeMirror.Pass"}},Gl={scroll:!1},Ul={origin:"*mouse"},Vl={origin:"+move"},Kl=[""],jl=/[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/,Xl=/[\u0300-\u036f\u0483-\u0489\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u065e\u0670\u06d6-\u06dc\u06de-\u06e4\u06e7\u06e8\u06ea-\u06ed\u0711\u0730-\u074a\u07a6-\u07b0\u07eb-\u07f3\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0900-\u0902\u093c\u0941-\u0948\u094d\u0951-\u0955\u0962\u0963\u0981\u09bc\u09be\u09c1-\u09c4\u09cd\u09d7\u09e2\u09e3\u0a01\u0a02\u0a3c\u0a41\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a70\u0a71\u0a75\u0a81\u0a82\u0abc\u0ac1-\u0ac5\u0ac7\u0ac8\u0acd\u0ae2\u0ae3\u0b01\u0b3c\u0b3e\u0b3f\u0b41-\u0b44\u0b4d\u0b56\u0b57\u0b62\u0b63\u0b82\u0bbe\u0bc0\u0bcd\u0bd7\u0c3e-\u0c40\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0cbc\u0cbf\u0cc2\u0cc6\u0ccc\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0d3e\u0d41-\u0d44\u0d4d\u0d57\u0d62\u0d63\u0dca\u0dcf\u0dd2-\u0dd4\u0dd6\u0ddf\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0eb1\u0eb4-\u0eb9\u0ebb\u0ebc\u0ec8-\u0ecd\u0f18\u0f19\u0f35\u0f37\u0f39\u0f71-\u0f7e\u0f80-\u0f84\u0f86\u0f87\u0f90-\u0f97\u0f99-\u0fbc\u0fc6\u102d-\u1030\u1032-\u1037\u1039\u103a\u103d\u103e\u1058\u1059\u105e-\u1060\u1071-\u1074\u1082\u1085\u1086\u108d\u109d\u135f\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b7-\u17bd\u17c6\u17c9-\u17d3\u17dd\u180b-\u180d\u18a9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193b\u1a17\u1a18\u1a56\u1a58-\u1a5e\u1a60\u1a62\u1a65-\u1a6c\u1a73-\u1a7c\u1a7f\u1b00-\u1b03\u1b34\u1b36-\u1b3a\u1b3c\u1b42\u1b6b-\u1b73\u1b80\u1b81\u1ba2-\u1ba5\u1ba8\u1ba9\u1c2c-\u1c33\u1c36\u1c37\u1cd0-\u1cd2\u1cd4-\u1ce0\u1ce2-\u1ce8\u1ced\u1dc0-\u1de6\u1dfd-\u1dff\u200c\u200d\u20d0-\u20f0\u2cef-\u2cf1\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua66f-\ua672\ua67c\ua67d\ua6f0\ua6f1\ua802\ua806\ua80b\ua825\ua826\ua8c4\ua8e0-\ua8f1\ua926-\ua92d\ua947-\ua951\ua980-\ua982\ua9b3\ua9b6-\ua9b9\ua9bc\uaa29-\uaa2e\uaa31\uaa32\uaa35\uaa36\uaa43\uaa4c\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uabe5\uabe8\uabed\udc00-\udfff\ufb1e\ufe00-\ufe0f\ufe20-\ufe26\uff9e\uff9f]/,Yl=!1,_l=!1,$l=null,ql=function(){function e(e){return e<=247?r.charAt(e):1424<=e&&e<=1524?"R":1536<=e&&e<=1785?n.charAt(e-1536):1774<=e&&e<=2220?"r":8192<=e&&e<=8203?"w":8204==e?"b":"L"}function t(e,t,r){this.level=e,this.from=t,this.to=r}var r="bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLN",n="nnnnnnNNr%%r,rNNmmmmmmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmmmnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmnNmmmmmmrrmmNmmmmrr1111111111",i=/[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/,o=/[stwN]/,l=/[LRr]/,s=/[Lb1n]/,a=/[1n]/;return function(r,n){var u="ltr"==n?"L":"R";if(0==r.length||"ltr"==n&&!i.test(r))return!1;for(var c=r.length,f=[],h=0;h<c;++h)f.push(e(r.charCodeAt(h)));for(var d=0,p=u;d<c;++d){var v=f[d];"m"==v?f[d]=p:p=v}for(var m=0,y=u;m<c;++m){var b=f[m];"1"==b&&"r"==y?f[m]="n":l.test(b)&&(y=b,"r"==b&&(f[m]="R"))}for(var w=1,x=f[0];w<c-1;++w){var C=f[w];"+"==C&&"1"==x&&"1"==f[w+1]?f[w]="1":","!=C||x!=f[w+1]||"1"!=x&&"n"!=x||(f[w]=x),x=C}for(var S=0;S<c;++S){var L=f[S];if(","==L)f[S]="N";else if("%"==L){var k=void 0;for(k=S+1;k<c&&"%"==f[k];++k);for(var T=S&&"!"==f[S-1]||k<c&&"1"==f[k]?"1":"N",M=S;M<k;++M)f[M]=T;S=k-1}}for(var N=0,O=u;N<c;++N){var A=f[N];"L"==O&&"1"==A?f[N]="L":l.test(A)&&(O=A)}for(var W=0;W<c;++W)if(o.test(f[W])){var D=void 0;for(D=W+1;D<c&&o.test(f[D]);++D);for(var H="L"==(W?f[W-1]:u),F=H==("L"==(D<c?f[D]:u))?H?"L":"R":u,E=W;E<D;++E)f[E]=F;W=D-1}for(var P,I=[],z=0;z<c;)if(s.test(f[z])){var R=z;for(++z;z<c&&s.test(f[z]);++z);I.push(new t(0,R,z))}else{var B=z,G=I.length;for(++z;z<c&&"L"!=f[z];++z);for(var U=B;U<z;)if(a.test(f[U])){B<U&&I.splice(G,0,new t(1,B,U));var V=U;for(++U;U<z&&a.test(f[U]);++U);I.splice(G,0,new t(2,V,U)),B=U}else++U;B<z&&I.splice(G,0,new t(1,B,z))}return 1==I[0].level&&(P=r.match(/^\s+/))&&(I[0].from=P[0].length,I.unshift(new t(0,0,P[0].length))),1==g(I).level&&(P=r.match(/\s+$/))&&(g(I).to-=P[0].length,I.push(new t(0,c-P[0].length,c))),"rtl"==n?I.reverse():I}}(),Zl=[],Ql=function(e,t,r){if(e.addEventListener)e.addEventListener(t,r,!1);else if(e.attachEvent)e.attachEvent("on"+t,r);else{var n=e._handlers||(e._handlers={});n[t]=(n[t]||Zl).concat(r)}},Jl=function(){if(gl&&vl<9)return!1;var e=n("div");return"draggable"in e||"dragDrop"in e}(),es=3!="\n\nb".split(/\n/).length?function(e){for(var t=0,r=[],n=e.length;t<=n;){var i=e.indexOf("\n",t);-1==i&&(i=e.length);var o=e.slice(t,"\r"==e.charAt(i-1)?i-1:i),l=o.indexOf("\r");-1!=l?(r.push(o.slice(0,l)),t+=l+1):(r.push(o),t=i+1)}return r}:function(e){return e.split(/\r\n?|\n/)},ts=window.getSelection?function(e){try{return e.selectionStart!=e.selectionEnd}catch(e){return!1}}:function(e){var t;try{t=e.ownerDocument.selection.createRange()}catch(e){}return!(!t||t.parentElement()!=e)&&0!=t.compareEndPoints("StartToEnd",t)},rs=function(){var e=n("div");return"oncopy"in e||(e.setAttribute("oncopy","return;"),"function"==typeof e.oncopy)}(),ns=null,is={},os={},ls={},ss=function(e,t,r){this.pos=this.start=0,this.string=e,this.tabSize=t||8,this.lastColumnPos=this.lastColumnValue=0,this.lineStart=0,this.lineOracle=r};ss.prototype.eol=function(){return this.pos>=this.string.length},ss.prototype.sol=function(){return this.pos==this.lineStart},ss.prototype.peek=function(){return this.string.charAt(this.pos)||void 0},ss.prototype.next=function(){if(this.pos<this.string.length)return this.string.charAt(this.pos++)},ss.prototype.eat=function(e){var t=this.string.charAt(this.pos);if("string"==typeof e?t==e:t&&(e.test?e.test(t):e(t)))return++this.pos,t},ss.prototype.eatWhile=function(e){for(var t=this.pos;this.eat(e););return this.pos>t},ss.prototype.eatSpace=function(){for(var e=this,t=this.pos;/[\s\u00a0]/.test(this.string.charAt(this.pos));)++e.pos;return this.pos>t},ss.prototype.skipToEnd=function(){this.pos=this.string.length},ss.prototype.skipTo=function(e){var t=this.string.indexOf(e,this.pos);if(t>-1)return this.pos=t,!0},ss.prototype.backUp=function(e){this.pos-=e},ss.prototype.column=function(){return this.lastColumnPos<this.start&&(this.lastColumnValue=f(this.string,this.start,this.tabSize,this.lastColumnPos,this.lastColumnValue),this.lastColumnPos=this.start),this.lastColumnValue-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.indentation=function(){return f(this.string,null,this.tabSize)-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.match=function(e,t,r){if("string"!=typeof e){var n=this.string.slice(this.pos).match(e);return n&&n.index>0?null:(n&&!1!==t&&(this.pos+=n[0].length),n)}var i=function(e){return r?e.toLowerCase():e};if(i(this.string.substr(this.pos,e.length))==i(e))return!1!==t&&(this.pos+=e.length),!0},ss.prototype.current=function(){return this.string.slice(this.start,this.pos)},ss.prototype.hideFirstChars=function(e,t){this.lineStart+=e;try{return t()}finally{this.lineStart-=e}},ss.prototype.lookAhead=function(e){var t=this.lineOracle;return t&&t.lookAhead(e)};var as=function(e,t){this.state=e,this.lookAhead=t},us=function(e,t,r,n){this.state=t,this.doc=e,this.line=r,this.maxLookAhead=n||0};us.prototype.lookAhead=function(e){var t=this.doc.getLine(this.line+e);return null!=t&&e>this.maxLookAhead&&(this.maxLookAhead=e),t},us.prototype.nextLine=function(){this.line++,this.maxLookAhead>0&&this.maxLookAhead--},us.fromSaved=function(e,t,r){return t instanceof as?new us(e,Ke(e.mode,t.state),r,t.lookAhead):new us(e,Ke(e.mode,t),r)},us.prototype.save=function(e){var t=!1!==e?Ke(this.doc.mode,this.state):this.state;return this.maxLookAhead>0?new as(t,this.maxLookAhead):t};var cs=function(e,t,r){this.start=e.start,this.end=e.pos,this.string=e.current(),this.type=t||null,this.state=r},fs=function(e,t,r){this.text=e,ne(this,t),this.height=r?r(this):1};fs.prototype.lineNo=function(){return W(this)},Ae(fs);var hs,ds={},ps={},gs=null,vs=null,ms={left:0,right:0,top:0,bottom:0},ys=function(e,t,r){this.cm=r;var i=this.vert=n("div",[n("div",null,null,"min-width: 1px")],"CodeMirror-vscrollbar"),o=this.horiz=n("div",[n("div",null,null,"height: 100%; min-height: 1px")],"CodeMirror-hscrollbar");e(i),e(o),Ql(i,"scroll",function(){i.clientHeight&&t(i.scrollTop,"vertical")}),Ql(o,"scroll",function(){o.clientWidth&&t(o.scrollLeft,"horizontal")}),this.checkedZeroWidth=!1,gl&&vl<8&&(this.horiz.style.minHeight=this.vert.style.minWidth="18px")};ys.prototype.update=function(e){var t=e.scrollWidth>e.clientWidth+1,r=e.scrollHeight>e.clientHeight+1,n=e.nativeBarWidth;if(r){this.vert.style.display="block",this.vert.style.bottom=t?n+"px":"0";var i=e.viewHeight-(t?n:0);this.vert.firstChild.style.height=Math.max(0,e.scrollHeight-e.clientHeight+i)+"px"}else this.vert.style.display="",this.vert.firstChild.style.height="0";if(t){this.horiz.style.display="block",this.horiz.style.right=r?n+"px":"0",this.horiz.style.left=e.barLeft+"px";var o=e.viewWidth-e.barLeft-(r?n:0);this.horiz.firstChild.style.width=Math.max(0,e.scrollWidth-e.clientWidth+o)+"px"}else this.horiz.style.display="",this.horiz.firstChild.style.width="0";return!this.checkedZeroWidth&&e.clientHeight>0&&(0==n&&this.zeroWidthHack(),this.checkedZeroWidth=!0),{right:r?n:0,bottom:t?n:0}},ys.prototype.setScrollLeft=function(e){this.horiz.scrollLeft!=e&&(this.horiz.scrollLeft=e),this.disableHoriz&&this.enableZeroWidthBar(this.horiz,this.disableHoriz,"horiz")},ys.prototype.setScrollTop=function(e){this.vert.scrollTop!=e&&(this.vert.scrollTop=e),this.disableVert&&this.enableZeroWidthBar(this.vert,this.disableVert,"vert")},ys.prototype.zeroWidthHack=function(){var e=Ml&&!Cl?"12px":"18px";this.horiz.style.height=this.vert.style.width=e,this.horiz.style.pointerEvents=this.vert.style.pointerEvents="none",this.disableHoriz=new Pl,this.disableVert=new Pl},ys.prototype.enableZeroWidthBar=function(e,t,r){function n(){var i=e.getBoundingClientRect();("vert"==r?document.elementFromPoint(i.right-1,(i.top+i.bottom)/2):document.elementFromPoint((i.right+i.left)/2,i.bottom-1))!=e?e.style.pointerEvents="none":t.set(1e3,n)}e.style.pointerEvents="auto",t.set(1e3,n)},ys.prototype.clear=function(){var e=this.horiz.parentNode;e.removeChild(this.horiz),e.removeChild(this.vert)};var bs=function(){};bs.prototype.update=function(){return{bottom:0,right:0}},bs.prototype.setScrollLeft=function(){},bs.prototype.setScrollTop=function(){},bs.prototype.clear=function(){};var ws={native:ys,null:bs},xs=0,Cs=function(e,t,r){var n=e.display;this.viewport=t,this.visible=Ir(n,e.doc,t),this.editorIsHidden=!n.wrapper.offsetWidth,this.wrapperHeight=n.wrapper.clientHeight,this.wrapperWidth=n.wrapper.clientWidth,this.oldDisplayWidth=Rt(e),this.force=r,this.dims=br(e),this.events=[]};Cs.prototype.signal=function(e,t){Oe(e,t)&&this.events.push(arguments)},Cs.prototype.finish=function(){for(var e=this,t=0;t<this.events.length;t++)Te.apply(null,e.events[t])};var Ss=0,Ls=null;gl?Ls=-.53:fl?Ls=15:bl?Ls=-.7:xl&&(Ls=-1/3);var ks=function(e,t){this.ranges=e,this.primIndex=t};ks.prototype.primary=function(){return this.ranges[this.primIndex]},ks.prototype.equals=function(e){var t=this;if(e==this)return!0;if(e.primIndex!=this.primIndex||e.ranges.length!=this.ranges.length)return!1;for(var r=0;r<this.ranges.length;r++){var n=t.ranges[r],i=e.ranges[r];if(!I(n.anchor,i.anchor)||!I(n.head,i.head))return!1}return!0},ks.prototype.deepCopy=function(){for(var e=this,t=[],r=0;r<this.ranges.length;r++)t[r]=new Ts(z(e.ranges[r].anchor),z(e.ranges[r].head));return new ks(t,this.primIndex)},ks.prototype.somethingSelected=function(){for(var e=this,t=0;t<this.ranges.length;t++)if(!e.ranges[t].empty())return!0;return!1},ks.prototype.contains=function(e,t){var r=this;t||(t=e);for(var n=0;n<this.ranges.length;n++){var i=r.ranges[n];if(P(t,i.from())>=0&&P(e,i.to())<=0)return n}return-1};var Ts=function(e,t){this.anchor=e,this.head=t};Ts.prototype.from=function(){return B(this.anchor,this.head)},Ts.prototype.to=function(){return R(this.anchor,this.head)},Ts.prototype.empty=function(){return this.head.line==this.anchor.line&&this.head.ch==this.anchor.ch},Bi.prototype={chunkSize:function(){return this.lines.length},removeInner:function(e,t){for(var r=this,n=e,i=e+t;n<i;++n){var o=r.lines[n];r.height-=o.height,ot(o),bt(o,"delete")}this.lines.splice(e,t)},collapse:function(e){e.push.apply(e,this.lines)},insertInner:function(e,t,r){var n=this;this.height+=r,this.lines=this.lines.slice(0,e).concat(t).concat(this.lines.slice(e));for(var i=0;i<t.length;++i)t[i].parent=n},iterN:function(e,t,r){for(var n=this,i=e+t;e<i;++e)if(r(n.lines[e]))return!0}},Gi.prototype={chunkSize:function(){return this.size},removeInner:function(e,t){var r=this;this.size-=t;for(var n=0;n<this.children.length;++n){var i=r.children[n],o=i.chunkSize();if(e<o){var l=Math.min(t,o-e),s=i.height;if(i.removeInner(e,l),r.height-=s-i.height,o==l&&(r.children.splice(n--,1),i.parent=null),0==(t-=l))break;e=0}else e-=o}if(this.size-t<25&&(this.children.length>1||!(this.children[0]instanceof Bi))){var a=[];this.collapse(a),this.children=[new Bi(a)],this.children[0].parent=this}},collapse:function(e){for(var t=this,r=0;r<this.children.length;++r)t.children[r].collapse(e)},insertInner:function(e,t,r){var n=this;this.size+=t.length,this.height+=r;for(var i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<=l){if(o.insertInner(e,t,r),o.lines&&o.lines.length>50){for(var s=o.lines.length%25+25,a=s;a<o.lines.length;){var u=new Bi(o.lines.slice(a,a+=25));o.height-=u.height,n.children.splice(++i,0,u),u.parent=n}o.lines=o.lines.slice(0,s),n.maybeSpill()}break}e-=l}},maybeSpill:function(){if(!(this.children.length<=10)){var e=this;do{var t=new Gi(e.children.splice(e.children.length-5,5));if(e.parent){e.size-=t.size,e.height-=t.height;var r=h(e.parent.children,e);e.parent.children.splice(r+1,0,t)}else{var n=new Gi(e.children);n.parent=e,e.children=[n,t],e=n}t.parent=e.parent}while(e.children.length>10);e.parent.maybeSpill()}},iterN:function(e,t,r){for(var n=this,i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<l){var s=Math.min(t,l-e);if(o.iterN(e,s,r))return!0;if(0==(t-=s))break;e=0}else e-=l}}};var Ms=function(e,t,r){var n=this;if(r)for(var i in r)r.hasOwnProperty(i)&&(n[i]=r[i]);this.doc=e,this.node=t};Ms.prototype.clear=function(){var e=this,t=this.doc.cm,r=this.line.widgets,n=this.line,i=W(n);if(null!=i&&r){for(var o=0;o<r.length;++o)r[o]==e&&r.splice(o--,1);r.length||(n.widgets=null);var l=Ht(this);A(n,Math.max(0,n.height-l)),t&&(hn(t,function(){Ui(t,n,-l),mn(t,i,"widget")}),bt(t,"lineWidgetCleared",t,this,i))}},Ms.prototype.changed=function(){var e=this,t=this.height,r=this.doc.cm,n=this.line;this.height=null;var i=Ht(this)-t;i&&(A(n,n.height+i),r&&hn(r,function(){r.curOp.forceUpdate=!0,Ui(r,n,i),bt(r,"lineWidgetChanged",r,e,W(n))}))},Ae(Ms);var Ns=0,Os=function(e,t){this.lines=[],this.type=t,this.doc=e,this.id=++Ns};Os.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){var t=this.doc.cm,r=t&&!t.curOp;if(r&&nn(t),Oe(this,"clear")){var n=this.find();n&&bt(this,"clear",n.from,n.to)}for(var i=null,o=null,l=0;l<this.lines.length;++l){var s=e.lines[l],a=_(s.markedSpans,e);t&&!e.collapsed?mn(t,W(s),"text"):t&&(null!=a.to&&(o=W(s)),null!=a.from&&(i=W(s))),s.markedSpans=$(s.markedSpans,a),null==a.from&&e.collapsed&&!ve(e.doc,s)&&t&&A(s,mr(t.display))}if(t&&this.collapsed&&!t.options.lineWrapping)for(var u=0;u<this.lines.length;++u){var c=fe(e.lines[u]),f=be(c);f>t.display.maxLineLength&&(t.display.maxLine=c,t.display.maxLineLength=f,t.display.maxLineChanged=!0)}null!=i&&t&&this.collapsed&&vn(t,i,o+1),this.lines.length=0,this.explicitlyCleared=!0,this.atomic&&this.doc.cantEdit&&(this.doc.cantEdit=!1,t&&Ci(t.doc)),t&&bt(t,"markerCleared",t,this,i,o),r&&on(t),this.parent&&this.parent.clear()}},Os.prototype.find=function(e,t){var r=this;null==e&&"bookmark"==this.type&&(e=1);for(var n,i,o=0;o<this.lines.length;++o){var l=r.lines[o],s=_(l.markedSpans,r);if(null!=s.from&&(n=E(t?l:W(l),s.from),-1==e))return n;if(null!=s.to&&(i=E(t?l:W(l),s.to),1==e))return i}return n&&{from:n,to:i}},Os.prototype.changed=function(){var e=this,t=this.find(-1,!0),r=this,n=this.doc.cm;t&&n&&hn(n,function(){var i=t.line,o=W(t.line),l=jt(n,o);if(l&&(Qt(l),n.curOp.selectionChanged=n.curOp.forceUpdate=!0),n.curOp.updateMaxLine=!0,!ve(r.doc,i)&&null!=r.height){var s=r.height;r.height=null;var a=Ht(r)-s;a&&A(i,i.height+a)}bt(n,"markerChanged",n,e)})},Os.prototype.attachLine=function(e){if(!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;t.maybeHiddenMarkers&&-1!=h(t.maybeHiddenMarkers,this)||(t.maybeUnhiddenMarkers||(t.maybeUnhiddenMarkers=[])).push(this)}this.lines.push(e)},Os.prototype.detachLine=function(e){if(this.lines.splice(h(this.lines,e),1),!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;(t.maybeHiddenMarkers||(t.maybeHiddenMarkers=[])).push(this)}},Ae(Os);var As=function(e,t){var r=this;this.markers=e,this.primary=t;for(var n=0;n<e.length;++n)e[n].parent=r};As.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){this.explicitlyCleared=!0;for(var t=0;t<this.markers.length;++t)e.markers[t].clear();bt(this,"clear")}},As.prototype.find=function(e,t){return this.primary.find(e,t)},Ae(As);var Ws=0,Ds=function(e,t,r,n,i){if(!(this instanceof Ds))return new Ds(e,t,r,n,i);null==r&&(r=0),Gi.call(this,[new Bi([new fs("",null)])]),this.first=r,this.scrollTop=this.scrollLeft=0,this.cantEdit=!1,this.cleanGeneration=1,this.modeFrontier=this.highlightFrontier=r;var o=E(r,0);this.sel=Rn(o),this.history=new Jn(null),this.id=++Ws,this.modeOption=t,this.lineSep=n,this.direction="rtl"==i?"rtl":"ltr",this.extend=!1,"string"==typeof e&&(e=this.splitLines(e)),_n(this,{from:o,to:o,text:e}),bi(this,Rn(o),Gl)};Ds.prototype=b(Gi.prototype,{constructor:Ds,iter:function(e,t,r){r?this.iterN(e-this.first,t-e,r):this.iterN(this.first,this.first+this.size,e)},insert:function(e,t){for(var r=0,n=0;n<t.length;++n)r+=t[n].height;this.insertInner(e-this.first,t,r)},remove:function(e,t){this.removeInner(e-this.first,t)},getValue:function(e){var t=O(this,this.first,this.first+this.size);return!1===e?t:t.join(e||this.lineSeparator())},setValue:gn(function(e){var t=E(this.first,0),r=this.first+this.size-1;Oi(this,{from:t,to:E(r,M(this,r).text.length),text:this.splitLines(e),origin:"setValue",full:!0},!0),this.cm&&Xr(this.cm,0,0),bi(this,Rn(t),Gl)}),replaceRange:function(e,t,r,n){Ei(this,e,t=U(this,t),r=r?U(this,r):t,n)},getRange:function(e,t,r){var n=N(this,U(this,e),U(this,t));return!1===r?n:n.join(r||this.lineSeparator())},getLine:function(e){var t=this.getLineHandle(e);return t&&t.text},getLineHandle:function(e){if(H(this,e))return M(this,e)},getLineNumber:function(e){return W(e)},getLineHandleVisualStart:function(e){return"number"==typeof e&&(e=M(this,e)),fe(e)},lineCount:function(){return this.size},firstLine:function(){return this.first},lastLine:function(){return this.first+this.size-1},clipPos:function(e){return U(this,e)},getCursor:function(e){var t=this.sel.primary();return null==e||"head"==e?t.head:"anchor"==e?t.anchor:"end"==e||"to"==e||!1===e?t.to():t.from()},listSelections:function(){return this.sel.ranges},somethingSelected:function(){return this.sel.somethingSelected()},setCursor:gn(function(e,t,r){vi(this,U(this,"number"==typeof e?E(e,t||0):e),null,r)}),setSelection:gn(function(e,t,r){vi(this,U(this,e),U(this,t||e),r)}),extendSelection:gn(function(e,t,r){di(this,U(this,e),t&&U(this,t),r)}),extendSelections:gn(function(e,t){pi(this,K(this,e),t)}),extendSelectionsBy:gn(function(e,t){pi(this,K(this,v(this.sel.ranges,e)),t)}),setSelections:gn(function(e,t,r){var n=this;if(e.length){for(var i=[],o=0;o<e.length;o++)i[o]=new Ts(U(n,e[o].anchor),U(n,e[o].head));null==t&&(t=Math.min(e.length-1,this.sel.primIndex)),bi(this,zn(i,t),r)}}),addSelection:gn(function(e,t,r){var n=this.sel.ranges.slice(0);n.push(new Ts(U(this,e),U(this,t||e))),bi(this,zn(n,n.length-1),r)}),getSelection:function(e){for(var t,r=this,n=this.sel.ranges,i=0;i<n.length;i++){var o=N(r,n[i].from(),n[i].to());t=t?t.concat(o):o}return!1===e?t:t.join(e||this.lineSeparator())},getSelections:function(e){for(var t=this,r=[],n=this.sel.ranges,i=0;i<n.length;i++){var o=N(t,n[i].from(),n[i].to());!1!==e&&(o=o.join(e||t.lineSeparator())),r[i]=o}return r},replaceSelection:function(e,t,r){for(var n=[],i=0;i<this.sel.ranges.length;i++)n[i]=e;this.replaceSelections(n,t,r||"+input")},replaceSelections:gn(function(e,t,r){for(var n=this,i=[],o=this.sel,l=0;l<o.ranges.length;l++){var s=o.ranges[l];i[l]={from:s.from(),to:s.to(),text:n.splitLines(e[l]),origin:r}}for(var a=t&&"end"!=t&&Kn(this,i,t),u=i.length-1;u>=0;u--)Oi(n,i[u]);a?yi(this,a):this.cm&&jr(this.cm)}),undo:gn(function(){Wi(this,"undo")}),redo:gn(function(){Wi(this,"redo")}),undoSelection:gn(function(){Wi(this,"undo",!0)}),redoSelection:gn(function(){Wi(this,"redo",!0)}),setExtending:function(e){this.extend=e},getExtending:function(){return this.extend},historySize:function(){for(var e=this.history,t=0,r=0,n=0;n<e.done.length;n++)e.done[n].ranges||++t;for(var i=0;i<e.undone.length;i++)e.undone[i].ranges||++r;return{undo:t,redo:r}},clearHistory:function(){this.history=new Jn(this.history.maxGeneration)},markClean:function(){this.cleanGeneration=this.changeGeneration(!0)},changeGeneration:function(e){return e&&(this.history.lastOp=this.history.lastSelOp=this.history.lastOrigin=null),this.history.generation},isClean:function(e){return this.history.generation==(e||this.cleanGeneration)},getHistory:function(){return{done:fi(this.history.done),undone:fi(this.history.undone)}},setHistory:function(e){var t=this.history=new Jn(this.history.maxGeneration);t.done=fi(e.done.slice(0),null,!0),t.undone=fi(e.undone.slice(0),null,!0)},setGutterMarker:gn(function(e,t,r){return Ri(this,e,"gutter",function(e){var n=e.gutterMarkers||(e.gutterMarkers={});return n[t]=r,!r&&C(n)&&(e.gutterMarkers=null),!0})}),clearGutter:gn(function(e){var t=this;this.iter(function(r){r.gutterMarkers&&r.gutterMarkers[e]&&Ri(t,r,"gutter",function(){return r.gutterMarkers[e]=null,C(r.gutterMarkers)&&(r.gutterMarkers=null),!0})})}),lineInfo:function(e){var t;if("number"==typeof e){if(!H(this,e))return null;if(t=e,!(e=M(this,e)))return null}else if(null==(t=W(e)))return null;return{line:t,handle:e,text:e.text,gutterMarkers:e.gutterMarkers,textClass:e.textClass,bgClass:e.bgClass,wrapClass:e.wrapClass,widgets:e.widgets}},addLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass";if(t[i]){if(e(n).test(t[i]))return!1;t[i]+=" "+n}else t[i]=n;return!0})}),removeLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass",o=t[i];if(!o)return!1;if(null==n)t[i]=null;else{var l=o.match(e(n));if(!l)return!1;var s=l.index+l[0].length;t[i]=o.slice(0,l.index)+(l.index&&s!=o.length?" ":"")+o.slice(s)||null}return!0})}),addLineWidget:gn(function(e,t,r){return Vi(this,e,t,r)}),removeLineWidget:function(e){e.clear()},markText:function(e,t,r){return Ki(this,U(this,e),U(this,t),r,r&&r.type||"range")},setBookmark:function(e,t){var r={replacedWith:t&&(null==t.nodeType?t.widget:t),insertLeft:t&&t.insertLeft,clearWhenEmpty:!1,shared:t&&t.shared,handleMouseEvents:t&&t.handleMouseEvents};return e=U(this,e),Ki(this,e,e,r,"bookmark")},findMarksAt:function(e){var t=[],r=M(this,(e=U(this,e)).line).markedSpans;if(r)for(var n=0;n<r.length;++n){var i=r[n];(null==i.from||i.from<=e.ch)&&(null==i.to||i.to>=e.ch)&&t.push(i.marker.parent||i.marker)}return t},findMarks:function(e,t,r){e=U(this,e),t=U(this,t);var n=[],i=e.line;return this.iter(e.line,t.line+1,function(o){var l=o.markedSpans;if(l)for(var s=0;s<l.length;s++){var a=l[s];null!=a.to&&i==e.line&&e.ch>=a.to||null==a.from&&i!=e.line||null!=a.from&&i==t.line&&a.from>=t.ch||r&&!r(a.marker)||n.push(a.marker.parent||a.marker)}++i}),n},getAllMarks:function(){var e=[];return this.iter(function(t){var r=t.markedSpans;if(r)for(var n=0;n<r.length;++n)null!=r[n].from&&e.push(r[n].marker)}),e},posFromIndex:function(e){var t,r=this.first,n=this.lineSeparator().length;return this.iter(function(i){var o=i.text.length+n;if(o>e)return t=e,!0;e-=o,++r}),U(this,E(r,t))},indexFromPos:function(e){var t=(e=U(this,e)).ch;if(e.line<this.first||e.ch<0)return 0;var r=this.lineSeparator().length;return this.iter(this.first,e.line,function(e){t+=e.text.length+r}),t},copy:function(e){var t=new Ds(O(this,this.first,this.first+this.size),this.modeOption,this.first,this.lineSep,this.direction);return t.scrollTop=this.scrollTop,t.scrollLeft=this.scrollLeft,t.sel=this.sel,t.extend=!1,e&&(t.history.undoDepth=this.history.undoDepth,t.setHistory(this.getHistory())),t},linkedDoc:function(e){e||(e={});var t=this.first,r=this.first+this.size;null!=e.from&&e.from>t&&(t=e.from),null!=e.to&&e.to<r&&(r=e.to);var n=new Ds(O(this,t,r),e.mode||this.modeOption,t,this.lineSep,this.direction);return e.sharedHist&&(n.history=this.history),(this.linked||(this.linked=[])).push({doc:n,sharedHist:e.sharedHist}),n.linked=[{doc:this,isParent:!0,sharedHist:e.sharedHist}],Yi(n,Xi(this)),n},unlinkDoc:function(e){var t=this;if(e instanceof jo&&(e=e.doc),this.linked)for(var r=0;r<this.linked.length;++r)if(t.linked[r].doc==e){t.linked.splice(r,1),e.unlinkDoc(t),_i(Xi(t));break}if(e.history==this.history){var n=[e.id];$n(e,function(e){return n.push(e.id)},!0),e.history=new Jn(null),e.history.done=fi(this.history.done,n),e.history.undone=fi(this.history.undone,n)}},iterLinkedDocs:function(e){$n(this,e)},getMode:function(){return this.mode},getEditor:function(){return this.cm},splitLines:function(e){return this.lineSep?e.split(this.lineSep):es(e)},lineSeparator:function(){return this.lineSep||"\n"},setDirection:gn(function(e){"rtl"!=e&&(e="ltr"),e!=this.direction&&(this.direction=e,this.iter(function(e){return e.order=null}),this.cm&&Qn(this.cm))})}),Ds.prototype.eachLine=Ds.prototype.iter;for(var Hs=0,Fs=!1,Es={3:"Enter",8:"Backspace",9:"Tab",13:"Enter",16:"Shift",17:"Ctrl",18:"Alt",19:"Pause",20:"CapsLock",27:"Esc",32:"Space",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"Left",38:"Up",39:"Right",40:"Down",44:"PrintScrn",45:"Insert",46:"Delete",59:";",61:"=",91:"Mod",92:"Mod",93:"Mod",106:"*",107:"=",109:"-",110:".",111:"/",127:"Delete",173:"-",186:";",187:"=",188:",",189:"-",190:".",191:"/",192:"`",219:"[",220:"\\",221:"]",222:"'",63232:"Up",63233:"Down",63234:"Left",63235:"Right",63272:"Delete",63273:"Home",63275:"End",63276:"PageUp",63277:"PageDown",63302:"Insert"},Ps=0;Ps<10;Ps++)Es[Ps+48]=Es[Ps+96]=String(Ps);for(var Is=65;Is<=90;Is++)Es[Is]=String.fromCharCode(Is);for(var zs=1;zs<=12;zs++)Es[zs+111]=Es[zs+63235]="F"+zs;var Rs={};Rs.basic={Left:"goCharLeft",Right:"goCharRight",Up:"goLineUp",Down:"goLineDown",End:"goLineEnd",Home:"goLineStartSmart",PageUp:"goPageUp",PageDown:"goPageDown",Delete:"delCharAfter",Backspace:"delCharBefore","Shift-Backspace":"delCharBefore",Tab:"defaultTab","Shift-Tab":"indentAuto",Enter:"newlineAndIndent",Insert:"toggleOverwrite",Esc:"singleSelection"},Rs.pcDefault={"Ctrl-A":"selectAll","Ctrl-D":"deleteLine","Ctrl-Z":"undo","Shift-Ctrl-Z":"redo","Ctrl-Y":"redo","Ctrl-Home":"goDocStart","Ctrl-End":"goDocEnd","Ctrl-Up":"goLineUp","Ctrl-Down":"goLineDown","Ctrl-Left":"goGroupLeft","Ctrl-Right":"goGroupRight","Alt-Left":"goLineStart","Alt-Right":"goLineEnd","Ctrl-Backspace":"delGroupBefore","Ctrl-Delete":"delGroupAfter","Ctrl-S":"save","Ctrl-F":"find","Ctrl-G":"findNext","Shift-Ctrl-G":"findPrev","Shift-Ctrl-F":"replace","Shift-Ctrl-R":"replaceAll","Ctrl-[":"indentLess","Ctrl-]":"indentMore","Ctrl-U":"undoSelection","Shift-Ctrl-U":"redoSelection","Alt-U":"redoSelection",fallthrough:"basic"},Rs.emacsy={"Ctrl-F":"goCharRight","Ctrl-B":"goCharLeft","Ctrl-P":"goLineUp","Ctrl-N":"goLineDown","Alt-F":"goWordRight","Alt-B":"goWordLeft","Ctrl-A":"goLineStart","Ctrl-E":"goLineEnd","Ctrl-V":"goPageDown","Shift-Ctrl-V":"goPageUp","Ctrl-D":"delCharAfter","Ctrl-H":"delCharBefore","Alt-D":"delWordAfter","Alt-Backspace":"delWordBefore","Ctrl-K":"killLine","Ctrl-T":"transposeChars","Ctrl-O":"openLine"},Rs.macDefault={"Cmd-A":"selectAll","Cmd-D":"deleteLine","Cmd-Z":"undo","Shift-Cmd-Z":"redo","Cmd-Y":"redo","Cmd-Home":"goDocStart","Cmd-Up":"goDocStart","Cmd-End":"goDocEnd","Cmd-Down":"goDocEnd","Alt-Left":"goGroupLeft","Alt-Right":"goGroupRight","Cmd-Left":"goLineLeft","Cmd-Right":"goLineRight","Alt-Backspace":"delGroupBefore","Ctrl-Alt-Backspace":"delGroupAfter","Alt-Delete":"delGroupAfter","Cmd-S":"save","Cmd-F":"find","Cmd-G":"findNext","Shift-Cmd-G":"findPrev","Cmd-Alt-F":"replace","Shift-Cmd-Alt-F":"replaceAll","Cmd-[":"indentLess","Cmd-]":"indentMore","Cmd-Backspace":"delWrappedLineLeft","Cmd-Delete":"delWrappedLineRight","Cmd-U":"undoSelection","Shift-Cmd-U":"redoSelection","Ctrl-Up":"goDocStart","Ctrl-Down":"goDocEnd",fallthrough:["basic","emacsy"]},Rs.default=Ml?Rs.macDefault:Rs.pcDefault;var Bs={selectAll:Mi,singleSelection:function(e){return e.setSelection(e.getCursor("anchor"),e.getCursor("head"),Gl)},killLine:function(e){return co(e,function(t){if(t.empty()){var r=M(e.doc,t.head.line).text.length;return t.head.ch==r&&t.head.line<e.lastLine()?{from:t.head,to:E(t.head.line+1,0)}:{from:t.head,to:E(t.head.line,r)}}return{from:t.from(),to:t.to()}})},deleteLine:function(e){return co(e,function(t){return{from:E(t.from().line,0),to:U(e.doc,E(t.to().line+1,0))}})},delLineLeft:function(e){return co(e,function(e){return{from:E(e.from().line,0),to:e.from()}})},delWrappedLineLeft:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5;return{from:e.coordsChar({left:0,top:r},"div"),to:t.from()}})},delWrappedLineRight:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5,n=e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div");return{from:t.from(),to:n}})},undo:function(e){return e.undo()},redo:function(e){return e.redo()},undoSelection:function(e){return e.undoSelection()},redoSelection:function(e){return e.redoSelection()},goDocStart:function(e){return e.extendSelection(E(e.firstLine(),0))},goDocEnd:function(e){return e.extendSelection(E(e.lastLine()))},goLineStart:function(e){return e.extendSelectionsBy(function(t){return vo(e,t.head.line)},{origin:"+move",bias:1})},goLineStartSmart:function(e){return e.extendSelectionsBy(function(t){return yo(e,t.head)},{origin:"+move",bias:1})},goLineEnd:function(e){return e.extendSelectionsBy(function(t){return mo(e,t.head.line)},{origin:"+move",bias:-1})},goLineRight:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div")},Vl)},goLineLeft:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:0,top:r},"div")},Vl)},goLineLeftSmart:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5,n=e.coordsChar({left:0,top:r},"div");return n.ch<e.getLine(n.line).search(/\S/)?yo(e,t.head):n},Vl)},goLineUp:function(e){return e.moveV(-1,"line")},goLineDown:function(e){return e.moveV(1,"line")},goPageUp:function(e){return e.moveV(-1,"page")},goPageDown:function(e){return e.moveV(1,"page")},goCharLeft:function(e){return e.moveH(-1,"char")},goCharRight:function(e){return e.moveH(1,"char")},goColumnLeft:function(e){return e.moveH(-1,"column")},goColumnRight:function(e){return e.moveH(1,"column")},goWordLeft:function(e){return e.moveH(-1,"word")},goGroupRight:function(e){return e.moveH(1,"group")},goGroupLeft:function(e){return e.moveH(-1,"group")},goWordRight:function(e){return e.moveH(1,"word")},delCharBefore:function(e){return e.deleteH(-1,"char")},delCharAfter:function(e){return e.deleteH(1,"char")},delWordBefore:function(e){return e.deleteH(-1,"word")},delWordAfter:function(e){return e.deleteH(1,"word")},delGroupBefore:function(e){return e.deleteH(-1,"group")},delGroupAfter:function(e){return e.deleteH(1,"group")},indentAuto:function(e){return e.indentSelection("smart")},indentMore:function(e){return e.indentSelection("add")},indentLess:function(e){return e.indentSelection("subtract")},insertTab:function(e){return e.replaceSelection("\t")},insertSoftTab:function(e){for(var t=[],r=e.listSelections(),n=e.options.tabSize,i=0;i<r.length;i++){var o=r[i].from(),l=f(e.getLine(o.line),o.ch,n);t.push(p(n-l%n))}e.replaceSelections(t)},defaultTab:function(e){e.somethingSelected()?e.indentSelection("add"):e.execCommand("insertTab")},transposeChars:function(e){return hn(e,function(){for(var t=e.listSelections(),r=[],n=0;n<t.length;n++)if(t[n].empty()){var i=t[n].head,o=M(e.doc,i.line).text;if(o)if(i.ch==o.length&&(i=new E(i.line,i.ch-1)),i.ch>0)i=new E(i.line,i.ch+1),e.replaceRange(o.charAt(i.ch-1)+o.charAt(i.ch-2),E(i.line,i.ch-2),i,"+transpose");else if(i.line>e.doc.first){var l=M(e.doc,i.line-1).text;l&&(i=new E(i.line,1),e.replaceRange(o.charAt(0)+e.doc.lineSeparator()+l.charAt(l.length-1),E(i.line-1,l.length-1),i,"+transpose"))}r.push(new Ts(i,i))}e.setSelections(r)})},newlineAndIndent:function(e){return hn(e,function(){for(var t=e.listSelections(),r=t.length-1;r>=0;r--)e.replaceRange(e.doc.lineSeparator(),t[r].anchor,t[r].head,"+input");t=e.listSelections();for(var n=0;n<t.length;n++)e.indentLine(t[n].from().line,null,!0);jr(e)})},openLine:function(e){return e.replaceSelection("\n","start")},toggleOverwrite:function(e){return e.toggleOverwrite()}},Gs=new Pl,Us=null,Vs=function(e,t,r){this.time=e,this.pos=t,this.button=r};Vs.prototype.compare=function(e,t,r){return this.time+400>e&&0==P(t,this.pos)&&r==this.button};var Ks,js,Xs={toString:function(){return"CodeMirror.Init"}},Ys={},_s={};jo.defaults=Ys,jo.optionHandlers=_s;var $s=[];jo.defineInitHook=function(e){return $s.push(e)};var qs=null,Zs=function(e){this.cm=e,this.lastAnchorNode=this.lastAnchorOffset=this.lastFocusNode=this.lastFocusOffset=null,this.polling=new Pl,this.composing=null,this.gracePeriod=!1,this.readDOMTimeout=null};Zs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()}),"cut"==e.type&&i.replaceSelection("",null,"cut");else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type&&i.operation(function(){i.setSelections(t.ranges,0,Gl),i.replaceSelection("",null,"cut")})}if(e.clipboardData){e.clipboardData.clearData();var r=qs.text.join("\n");if(e.clipboardData.setData("Text",r),e.clipboardData.getData("Text")==r)return void e.preventDefault()}var l=el(),s=l.firstChild;i.display.lineSpace.insertBefore(l,i.display.lineSpace.firstChild),s.value=qs.text.join("\n");var a=document.activeElement;El(s),setTimeout(function(){i.display.lineSpace.removeChild(l),a.focus(),a==o&&n.showPrimarySelection()},50)}}var r=this,n=this,i=n.cm,o=n.div=e.lineDiv;Jo(o,i.options.spellcheck),Ql(o,"paste",function(e){Me(i,e)||qo(e,i)||vl<=11&&setTimeout(dn(i,function(){return r.updateFromDOM()}),20)}),Ql(o,"compositionstart",function(e){r.composing={data:e.data,done:!1}}),Ql(o,"compositionupdate",function(e){r.composing||(r.composing={data:e.data,done:!1})}),Ql(o,"compositionend",function(e){r.composing&&(e.data!=r.composing.data&&r.readFromDOMSoon(),r.composing.done=!0)}),Ql(o,"touchstart",function(){return n.forceCompositionEnd()}),Ql(o,"input",function(){r.composing||r.readFromDOMSoon()}),Ql(o,"copy",t),Ql(o,"cut",t)},Zs.prototype.prepareSelection=function(){var e=Tr(this.cm,!1);return e.focus=this.cm.state.focused,e},Zs.prototype.showSelection=function(e,t){e&&this.cm.display.view.length&&((e.focus||t)&&this.showPrimarySelection(),this.showMultipleSelections(e))},Zs.prototype.showPrimarySelection=function(){var e=window.getSelection(),t=this.cm,r=t.doc.sel.primary(),n=r.from(),i=r.to();if(t.display.viewTo==t.display.viewFrom||n.line>=t.display.viewTo||i.line<t.display.viewFrom)e.removeAllRanges();else{var o=sl(t,e.anchorNode,e.anchorOffset),l=sl(t,e.focusNode,e.focusOffset);if(!o||o.bad||!l||l.bad||0!=P(B(o,l),n)||0!=P(R(o,l),i)){var s=t.display.view,a=n.line>=t.display.viewFrom&&nl(t,n)||{node:s[0].measure.map[2],offset:0},u=i.line<t.display.viewTo&&nl(t,i);if(!u){var c=s[s.length-1].measure,f=c.maps?c.maps[c.maps.length-1]:c.map;u={node:f[f.length-1],offset:f[f.length-2]-f[f.length-3]}}if(a&&u){var h,d=e.rangeCount&&e.getRangeAt(0);try{h=Wl(a.node,a.offset,u.offset,u.node)}catch(e){}h&&(!fl&&t.state.focused?(e.collapse(a.node,a.offset),h.collapsed||(e.removeAllRanges(),e.addRange(h))):(e.removeAllRanges(),e.addRange(h)),d&&null==e.anchorNode?e.addRange(d):fl&&this.startGracePeriod()),this.rememberSelection()}else e.removeAllRanges()}}},Zs.prototype.startGracePeriod=function(){var e=this;clearTimeout(this.gracePeriod),this.gracePeriod=setTimeout(function(){e.gracePeriod=!1,e.selectionChanged()&&e.cm.operation(function(){return e.cm.curOp.selectionChanged=!0})},20)},Zs.prototype.showMultipleSelections=function(e){r(this.cm.display.cursorDiv,e.cursors),r(this.cm.display.selectionDiv,e.selection)},Zs.prototype.rememberSelection=function(){var e=window.getSelection();this.lastAnchorNode=e.anchorNode,this.lastAnchorOffset=e.anchorOffset,this.lastFocusNode=e.focusNode,this.lastFocusOffset=e.focusOffset},Zs.prototype.selectionInEditor=function(){var e=window.getSelection();if(!e.rangeCount)return!1;var t=e.getRangeAt(0).commonAncestorContainer;return o(this.div,t)},Zs.prototype.focus=function(){"nocursor"!=this.cm.options.readOnly&&(this.selectionInEditor()||this.showSelection(this.prepareSelection(),!0),this.div.focus())},Zs.prototype.blur=function(){this.div.blur()},Zs.prototype.getField=function(){return this.div},Zs.prototype.supportsTouch=function(){return!0},Zs.prototype.receivedFocus=function(){function e(){t.cm.state.focused&&(t.pollSelection(),t.polling.set(t.cm.options.pollInterval,e))}var t=this;this.selectionInEditor()?this.pollSelection():hn(this.cm,function(){return t.cm.curOp.selectionChanged=!0}),this.polling.set(this.cm.options.pollInterval,e)},Zs.prototype.selectionChanged=function(){var e=window.getSelection();return e.anchorNode!=this.lastAnchorNode||e.anchorOffset!=this.lastAnchorOffset||e.focusNode!=this.lastFocusNode||e.focusOffset!=this.lastFocusOffset},Zs.prototype.pollSelection=function(){if(null==this.readDOMTimeout&&!this.gracePeriod&&this.selectionChanged()){var e=window.getSelection(),t=this.cm;if(kl&&bl&&this.cm.options.gutters.length&&il(e.anchorNode))return this.cm.triggerOnKeyDown({type:"keydown",keyCode:8,preventDefault:Math.abs}),this.blur(),void this.focus();if(!this.composing){this.rememberSelection();var r=sl(t,e.anchorNode,e.anchorOffset),n=sl(t,e.focusNode,e.focusOffset);r&&n&&hn(t,function(){bi(t.doc,Rn(r,n),Gl),(r.bad||n.bad)&&(t.curOp.selectionChanged=!0)})}}},Zs.prototype.pollContent=function(){null!=this.readDOMTimeout&&(clearTimeout(this.readDOMTimeout),this.readDOMTimeout=null);var e=this.cm,t=e.display,r=e.doc.sel.primary(),n=r.from(),i=r.to();if(0==n.ch&&n.line>e.firstLine()&&(n=E(n.line-1,M(e.doc,n.line-1).length)),i.ch==M(e.doc,i.line).text.length&&i.line<e.lastLine()&&(i=E(i.line+1,0)),n.line<t.viewFrom||i.line>t.viewTo-1)return!1;var o,l,s;n.line==t.viewFrom||0==(o=Lr(e,n.line))?(l=W(t.view[0].line),s=t.view[0].node):(l=W(t.view[o].line),s=t.view[o-1].node.nextSibling);var a,u,c=Lr(e,i.line);if(c==t.view.length-1?(a=t.viewTo-1,u=t.lineDiv.lastChild):(a=W(t.view[c+1].line)-1,u=t.view[c+1].node.previousSibling),!s)return!1;for(var f=e.doc.splitLines(ll(e,s,u,l,a)),h=N(e.doc,E(l,0),E(a,M(e.doc,a).text.length));f.length>1&&h.length>1;)if(g(f)==g(h))f.pop(),h.pop(),a--;else{if(f[0]!=h[0])break;f.shift(),h.shift(),l++}for(var d=0,p=0,v=f[0],m=h[0],y=Math.min(v.length,m.length);d<y&&v.charCodeAt(d)==m.charCodeAt(d);)++d;for(var b=g(f),w=g(h),x=Math.min(b.length-(1==f.length?d:0),w.length-(1==h.length?d:0));p<x&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)++p;if(1==f.length&&1==h.length&&l==n.line)for(;d&&d>n.ch&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)d--,p++;f[f.length-1]=b.slice(0,b.length-p).replace(/^\u200b+/,""),f[0]=f[0].slice(d).replace(/\u200b+$/,"");var C=E(l,d),S=E(a,h.length?g(h).length-p:0);return f.length>1||f[0]||P(C,S)?(Ei(e.doc,f,C,S,"+input"),!0):void 0},Zs.prototype.ensurePolled=function(){this.forceCompositionEnd()},Zs.prototype.reset=function(){this.forceCompositionEnd()},Zs.prototype.forceCompositionEnd=function(){this.composing&&(clearTimeout(this.readDOMTimeout),this.composing=null,this.updateFromDOM(),this.div.blur(),this.div.focus())},Zs.prototype.readFromDOMSoon=function(){var e=this;null==this.readDOMTimeout&&(this.readDOMTimeout=setTimeout(function(){if(e.readDOMTimeout=null,e.composing){if(!e.composing.done)return;e.composing=null}e.updateFromDOM()},80))},Zs.prototype.updateFromDOM=function(){var e=this;!this.cm.isReadOnly()&&this.pollContent()||hn(this.cm,function(){return vn(e.cm)})},Zs.prototype.setUneditable=function(e){e.contentEditable="false"},Zs.prototype.onKeyPress=function(e){0!=e.charCode&&(e.preventDefault(),this.cm.isReadOnly()||dn(this.cm,$o)(this.cm,String.fromCharCode(null==e.charCode?e.keyCode:e.charCode),0))},Zs.prototype.readOnlyChanged=function(e){this.div.contentEditable=String("nocursor"!=e)},Zs.prototype.onContextMenu=function(){},Zs.prototype.resetPosition=function(){},Zs.prototype.needsContentAttribute=!0;var Qs=function(e){this.cm=e,this.prevInput="",this.pollingFast=!1,this.polling=new Pl,this.hasSelection=!1,this.composing=null};Qs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()});else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type?i.setSelections(t.ranges,null,Gl):(n.prevInput="",l.value=t.text.join("\n"),El(l))}"cut"==e.type&&(i.state.cutIncoming=!0)}}var r=this,n=this,i=this.cm,o=this.wrapper=el(),l=this.textarea=o.firstChild;e.wrapper.insertBefore(o,e.wrapper.firstChild),Ll&&(l.style.width="0px"),Ql(l,"input",function(){gl&&vl>=9&&r.hasSelection&&(r.hasSelection=null),n.poll()}),Ql(l,"paste",function(e){Me(i,e)||qo(e,i)||(i.state.pasteIncoming=!0,n.fastPoll())}),Ql(l,"cut",t),Ql(l,"copy",t),Ql(e.scroller,"paste",function(t){Ft(e,t)||Me(i,t)||(i.state.pasteIncoming=!0,n.focus())}),Ql(e.lineSpace,"selectstart",function(t){Ft(e,t)||We(t)}),Ql(l,"compositionstart",function(){var e=i.getCursor("from");n.composing&&n.composing.range.clear(),n.composing={start:e,range:i.markText(e,i.getCursor("to"),{className:"CodeMirror-composing"})}}),Ql(l,"compositionend",function(){n.composing&&(n.poll(),n.composing.range.clear(),n.composing=null)})},Qs.prototype.prepareSelection=function(){var e=this.cm,t=e.display,r=e.doc,n=Tr(e);if(e.options.moveInputWithCursor){var i=sr(e,r.sel.primary().head,"div"),o=t.wrapper.getBoundingClientRect(),l=t.lineDiv.getBoundingClientRect();n.teTop=Math.max(0,Math.min(t.wrapper.clientHeight-10,i.top+l.top-o.top)),n.teLeft=Math.max(0,Math.min(t.wrapper.clientWidth-10,i.left+l.left-o.left))}return n},Qs.prototype.showSelection=function(e){var t=this.cm.display;r(t.cursorDiv,e.cursors),r(t.selectionDiv,e.selection),null!=e.teTop&&(this.wrapper.style.top=e.teTop+"px",this.wrapper.style.left=e.teLeft+"px")},Qs.prototype.reset=function(e){if(!this.contextMenuPending&&!this.composing){var t=this.cm;if(t.somethingSelected()){this.prevInput="";var r=t.getSelection();this.textarea.value=r,t.state.focused&&El(this.textarea),gl&&vl>=9&&(this.hasSelection=r)}else e||(this.prevInput=this.textarea.value="",gl&&vl>=9&&(this.hasSelection=null))}},Qs.prototype.getField=function(){return this.textarea},Qs.prototype.supportsTouch=function(){return!1},Qs.prototype.focus=function(){if("nocursor"!=this.cm.options.readOnly&&(!Tl||l()!=this.textarea))try{this.textarea.focus()}catch(e){}},Qs.prototype.blur=function(){this.textarea.blur()},Qs.prototype.resetPosition=function(){this.wrapper.style.top=this.wrapper.style.left=0},Qs.prototype.receivedFocus=function(){this.slowPoll()},Qs.prototype.slowPoll=function(){var e=this;this.pollingFast||this.polling.set(this.cm.options.pollInterval,function(){e.poll(),e.cm.state.focused&&e.slowPoll()})},Qs.prototype.fastPoll=function(){function e(){r.poll()||t?(r.pollingFast=!1,r.slowPoll()):(t=!0,r.polling.set(60,e))}var t=!1,r=this;r.pollingFast=!0,r.polling.set(20,e)},Qs.prototype.poll=function(){var e=this,t=this.cm,r=this.textarea,n=this.prevInput;if(this.contextMenuPending||!t.state.focused||ts(r)&&!n&&!this.composing||t.isReadOnly()||t.options.disableInput||t.state.keySeq)return!1;var i=r.value;if(i==n&&!t.somethingSelected())return!1;if(gl&&vl>=9&&this.hasSelection===i||Ml&&/[\uf700-\uf7ff]/.test(i))return t.display.input.reset(),!1;if(t.doc.sel==t.display.selForContextMenu){var o=i.charCodeAt(0);if(8203!=o||n||(n="​"),8666==o)return this.reset(),this.cm.execCommand("undo")}for(var l=0,s=Math.min(n.length,i.length);l<s&&n.charCodeAt(l)==i.charCodeAt(l);)++l;return hn(t,function(){$o(t,i.slice(l),n.length-l,null,e.composing?"*compose":null),i.length>1e3||i.indexOf("\n")>-1?r.value=e.prevInput="":e.prevInput=i,e.composing&&(e.composing.range.clear(),e.composing.range=t.markText(e.composing.start,t.getCursor("to"),{className:"CodeMirror-composing"}))}),!0},Qs.prototype.ensurePolled=function(){this.pollingFast&&this.poll()&&(this.pollingFast=!1)},Qs.prototype.onKeyPress=function(){gl&&vl>=9&&(this.hasSelection=null),this.fastPoll()},Qs.prototype.onContextMenu=function(e){function t(){if(null!=l.selectionStart){var e=i.somethingSelected(),t="​"+(e?l.value:"");l.value="⇚",l.value=t,n.prevInput=e?"":"​",l.selectionStart=1,l.selectionEnd=t.length,o.selForContextMenu=i.doc.sel}}function r(){if(n.contextMenuPending=!1,n.wrapper.style.cssText=c,l.style.cssText=u,gl&&vl<9&&o.scrollbars.setScrollTop(o.scroller.scrollTop=a),null!=l.selectionStart){(!gl||gl&&vl<9)&&t();var e=0,r=function(){o.selForContextMenu==i.doc.sel&&0==l.selectionStart&&l.selectionEnd>0&&"​"==n.prevInput?dn(i,Mi)(i):e++<10?o.detectingSelectAll=setTimeout(r,500):(o.selForContextMenu=null,o.input.reset())};o.detectingSelectAll=setTimeout(r,200)}}var n=this,i=n.cm,o=i.display,l=n.textarea,s=Sr(i,e),a=o.scroller.scrollTop;if(s&&!wl){i.options.resetSelectionOnContextMenu&&-1==i.doc.sel.contains(s)&&dn(i,bi)(i.doc,Rn(s),Gl);var u=l.style.cssText,c=n.wrapper.style.cssText;n.wrapper.style.cssText="position: absolute";var f=n.wrapper.getBoundingClientRect();l.style.cssText="position: absolute; width: 30px; height: 30px;\n      top: "+(e.clientY-f.top-5)+"px; left: "+(e.clientX-f.left-5)+"px;\n      z-index: 1000; background: "+(gl?"rgba(255, 255, 255, .05)":"transparent")+";\n      outline: none; border-width: 0; outline: none; overflow: hidden; opacity: .05; filter: alpha(opacity=5);";var h;if(ml&&(h=window.scrollY),o.input.focus(),ml&&window.scrollTo(null,h),o.input.reset(),i.somethingSelected()||(l.value=n.prevInput=" "),n.contextMenuPending=!0,o.selForContextMenu=i.doc.sel,clearTimeout(o.detectingSelectAll),gl&&vl>=9&&t(),Hl){Fe(e);var d=function(){ke(window,"mouseup",d),setTimeout(r,20)};Ql(window,"mouseup",d)}else setTimeout(r,50)}},Qs.prototype.readOnlyChanged=function(e){e||this.reset(),this.textarea.disabled="nocursor"==e},Qs.prototype.setUneditable=function(){},Qs.prototype.needsContentAttribute=!1,function(e){function t(t,n,i,o){e.defaults[t]=n,i&&(r[t]=o?function(e,t,r){r!=Xs&&i(e,t,r)}:i)}var r=e.optionHandlers;e.defineOption=t,e.Init=Xs,t("value","",function(e,t){return e.setValue(t)},!0),t("mode",null,function(e,t){e.doc.modeOption=t,jn(e)},!0),t("indentUnit",2,jn,!0),t("indentWithTabs",!1),t("smartIndent",!0),t("tabSize",4,function(e){Xn(e),er(e),vn(e)},!0),t("lineSeparator",null,function(e,t){if(e.doc.lineSep=t,t){var r=[],n=e.doc.first;e.doc.iter(function(e){for(var i=0;;){var o=e.text.indexOf(t,i);if(-1==o)break;i=o+t.length,r.push(E(n,o))}n++});for(var i=r.length-1;i>=0;i--)Ei(e.doc,t,r[i],E(r[i].line,r[i].ch+t.length))}}),t("specialChars",/[\u0000-\u001f\u007f-\u009f\u00ad\u061c\u200b-\u200f\u2028\u2029\ufeff]/g,function(e,t,r){e.state.specialChars=new RegExp(t.source+(t.test("\t")?"":"|\t"),"g"),r!=Xs&&e.refresh()}),t("specialCharPlaceholder",at,function(e){return e.refresh()},!0),t("electricChars",!0),t("inputStyle",Tl?"contenteditable":"textarea",function(){throw new Error("inputStyle can not (yet) be changed in a running editor")},!0),t("spellcheck",!1,function(e,t){return e.getInputField().spellcheck=t},!0),t("rtlMoveVisually",!Ol),t("wholeLineUpdateBefore",!0),t("theme","default",function(e){Go(e),Uo(e)},!0),t("keyMap","default",function(e,t,r){var n=uo(t),i=r!=Xs&&uo(r);i&&i.detach&&i.detach(e,n),n.attach&&n.attach(e,i||null)}),t("extraKeys",null),t("configureMouse",null),t("lineWrapping",!1,Ko,!0),t("gutters",[],function(e){Fn(e.options),Uo(e)},!0),t("fixedGutter",!0,function(e,t){e.display.gutters.style.left=t?wr(e.display)+"px":"0",e.refresh()},!0),t("coverGutterNextToScrollbar",!1,function(e){return en(e)},!0),t("scrollbarStyle","native",function(e){rn(e),en(e),e.display.scrollbars.setScrollTop(e.doc.scrollTop),e.display.scrollbars.setScrollLeft(e.doc.scrollLeft)},!0),t("lineNumbers",!1,function(e){Fn(e.options),Uo(e)},!0),t("firstLineNumber",1,Uo,!0),t("lineNumberFormatter",function(e){return e},Uo,!0),t("showCursorWhenSelecting",!1,kr,!0),t("resetSelectionOnContextMenu",!0),t("lineWiseCopyCut",!0),t("pasteLinesPerSelection",!0),t("readOnly",!1,function(e,t){"nocursor"==t&&(Fr(e),e.display.input.blur()),e.display.input.readOnlyChanged(t)}),t("disableInput",!1,function(e,t){t||e.display.input.reset()},!0),t("dragDrop",!0,Vo),t("allowDropFileTypes",null),t("cursorBlinkRate",530),t("cursorScrollMargin",0),t("cursorHeight",1,kr,!0),t("singleCursorHeightPerLine",!0,kr,!0),t("workTime",100),t("workDelay",100),t("flattenSpans",!0,Xn,!0),t("addModeClass",!1,Xn,!0),t("pollInterval",100),t("undoDepth",200,function(e,t){return e.doc.history.undoDepth=t}),t("historyEventDelay",1250),t("viewportMargin",10,function(e){return e.refresh()},!0),t("maxHighlightLength",1e4,Xn,!0),t("moveInputWithCursor",!0,function(e,t){t||e.display.input.resetPosition()}),t("tabindex",null,function(e,t){return e.display.input.getField().tabIndex=t||""}),t("autofocus",null),t("direction","ltr",function(e,t){return e.doc.setDirection(t)},!0)}(jo),function(e){var t=e.optionHandlers,r=e.helpers={};e.prototype={constructor:e,focus:function(){window.focus(),this.display.input.focus()},setOption:function(e,r){var n=this.options,i=n[e];n[e]==r&&"mode"!=e||(n[e]=r,t.hasOwnProperty(e)&&dn(this,t[e])(this,r,i),Te(this,"optionChange",this,e))},getOption:function(e){return this.options[e]},getDoc:function(){return this.doc},addKeyMap:function(e,t){this.state.keyMaps[t?"push":"unshift"](uo(e))},removeKeyMap:function(e){for(var t=this.state.keyMaps,r=0;r<t.length;++r)if(t[r]==e||t[r].name==e)return t.splice(r,1),!0},addOverlay:pn(function(t,r){var n=t.token?t:e.getMode(this.options,t);if(n.startState)throw new Error("Overlays may not be stateful.");m(this.state.overlays,{mode:n,modeSpec:t,opaque:r&&r.opaque,priority:r&&r.priority||0},function(e){return e.priority}),this.state.modeGen++,vn(this)}),removeOverlay:pn(function(e){for(var t=this,r=this.state.overlays,n=0;n<r.length;++n){var i=r[n].modeSpec;if(i==e||"string"==typeof e&&i.name==e)return r.splice(n,1),t.state.modeGen++,void vn(t)}}),indentLine:pn(function(e,t,r){"string"!=typeof t&&"number"!=typeof t&&(t=null==t?this.options.smartIndent?"smart":"prev":t?"add":"subtract"),H(this.doc,e)&&Yo(this,e,t,r)}),indentSelection:pn(function(e){for(var t=this,r=this.doc.sel.ranges,n=-1,i=0;i<r.length;i++){var o=r[i];if(o.empty())o.head.line>n&&(Yo(t,o.head.line,e,!0),n=o.head.line,i==t.doc.sel.primIndex&&jr(t));else{var l=o.from(),s=o.to(),a=Math.max(n,l.line);n=Math.min(t.lastLine(),s.line-(s.ch?0:1))+1;for(var u=a;u<n;++u)Yo(t,u,e);var c=t.doc.sel.ranges;0==l.ch&&r.length==c.length&&c[i].from().ch>0&&gi(t.doc,i,new Ts(l,c[i].to()),Gl)}}}),getTokenAt:function(e,t){return Je(this,e,t)},getLineTokens:function(e,t){return Je(this,E(e),t,!0)},getTokenTypeAt:function(e){e=U(this.doc,e);var t,r=_e(this,M(this.doc,e.line)),n=0,i=(r.length-1)/2,o=e.ch;if(0==o)t=r[2];else for(;;){var l=n+i>>1;if((l?r[2*l-1]:0)>=o)i=l;else{if(!(r[2*l+1]<o)){t=r[2*l+2];break}n=l+1}}var s=t?t.indexOf("overlay "):-1;return s<0?t:0==s?null:t.slice(0,s-1)},getModeAt:function(t){var r=this.doc.mode;return r.innerMode?e.innerMode(r,this.getTokenAt(t).state).mode:r},getHelper:function(e,t){return this.getHelpers(e,t)[0]},getHelpers:function(e,t){var n=this,i=[];if(!r.hasOwnProperty(t))return i;var o=r[t],l=this.getModeAt(e);if("string"==typeof l[t])o[l[t]]&&i.push(o[l[t]]);else if(l[t])for(var s=0;s<l[t].length;s++){var a=o[l[t][s]];a&&i.push(a)}else l.helperType&&o[l.helperType]?i.push(o[l.helperType]):o[l.name]&&i.push(o[l.name]);for(var u=0;u<o._global.length;u++){var c=o._global[u];c.pred(l,n)&&-1==h(i,c.val)&&i.push(c.val)}return i},getStateAfter:function(e,t){var r=this.doc;return e=G(r,null==e?r.first+r.size-1:e),$e(this,e+1,t).state},cursorCoords:function(e,t){var r,n=this.doc.sel.primary();return r=null==e?n.head:"object"==typeof e?U(this.doc,e):e?n.from():n.to(),sr(this,r,t||"page")},charCoords:function(e,t){return lr(this,U(this.doc,e),t||"page")},coordsChar:function(e,t){return e=or(this,e,t||"page"),cr(this,e.left,e.top)},lineAtHeight:function(e,t){return e=or(this,{top:e,left:0},t||"page").top,D(this.doc,e+this.display.viewOffset)},heightAtLine:function(e,t,r){var n,i=!1;if("number"==typeof e){var o=this.doc.first+this.doc.size-1;e<this.doc.first?e=this.doc.first:e>o&&(e=o,i=!0),n=M(this.doc,e)}else n=e;return ir(this,n,{top:0,left:0},t||"page",r||i).top+(i?this.doc.height-ye(n):0)},defaultTextHeight:function(){return mr(this.display)},defaultCharWidth:function(){return yr(this.display)},getViewport:function(){return{from:this.display.viewFrom,to:this.display.viewTo}},addWidget:function(e,t,r,n,i){var o=this.display,l=(e=sr(this,U(this.doc,e))).bottom,s=e.left;if(t.style.position="absolute",t.setAttribute("cm-ignore-events","true"),this.display.input.setUneditable(t),o.sizer.appendChild(t),"over"==n)l=e.top;else if("above"==n||"near"==n){var a=Math.max(o.wrapper.clientHeight,this.doc.height),u=Math.max(o.sizer.clientWidth,o.lineSpace.clientWidth);("above"==n||e.bottom+t.offsetHeight>a)&&e.top>t.offsetHeight?l=e.top-t.offsetHeight:e.bottom+t.offsetHeight<=a&&(l=e.bottom),s+t.offsetWidth>u&&(s=u-t.offsetWidth)}t.style.top=l+"px",t.style.left=t.style.right="","right"==i?(s=o.sizer.clientWidth-t.offsetWidth,t.style.right="0px"):("left"==i?s=0:"middle"==i&&(s=(o.sizer.clientWidth-t.offsetWidth)/2),t.style.left=s+"px"),r&&Ur(this,{left:s,top:l,right:s+t.offsetWidth,bottom:l+t.offsetHeight})},triggerOnKeyDown:pn(Lo),triggerOnKeyPress:pn(Mo),triggerOnKeyUp:To,triggerOnMouseDown:pn(Oo),execCommand:function(e){if(Bs.hasOwnProperty(e))return Bs[e].call(null,this)},triggerElectric:pn(function(e){Zo(this,e)}),findPosH:function(e,t,r,n){var i=this,o=1;t<0&&(o=-1,t=-t);for(var l=U(this.doc,e),s=0;s<t&&!(l=tl(i.doc,l,o,r,n)).hitSide;++s);return l},moveH:pn(function(e,t){var r=this;this.extendSelectionsBy(function(n){return r.display.shift||r.doc.extend||n.empty()?tl(r.doc,n.head,e,t,r.options.rtlMoveVisually):e<0?n.from():n.to()},Vl)}),deleteH:pn(function(e,t){var r=this.doc.sel,n=this.doc;r.somethingSelected()?n.replaceSelection("",null,"+delete"):co(this,function(r){var i=tl(n,r.head,e,t,!1);return e<0?{from:i,to:r.head}:{from:r.head,to:i}})}),findPosV:function(e,t,r,n){var i=this,o=1,l=n;t<0&&(o=-1,t=-t);for(var s=U(this.doc,e),a=0;a<t;++a){var u=sr(i,s,"div");if(null==l?l=u.left:u.left=l,(s=rl(i,u,o,r)).hitSide)break}return s},moveV:pn(function(e,t){var r=this,n=this.doc,i=[],o=!this.display.shift&&!n.extend&&n.sel.somethingSelected();if(n.extendSelectionsBy(function(l){if(o)return e<0?l.from():l.to();var s=sr(r,l.head,"div");null!=l.goalColumn&&(s.left=l.goalColumn),i.push(s.left);var a=rl(r,s,e,t);return"page"==t&&l==n.sel.primary()&&Kr(r,lr(r,a,"div").top-s.top),a},Vl),i.length)for(var l=0;l<n.sel.ranges.length;l++)n.sel.ranges[l].goalColumn=i[l]}),findWordAt:function(e){var t=M(this.doc,e.line).text,r=e.ch,n=e.ch;if(t){var i=this.getHelper(e,"wordChars");"before"!=e.sticky&&n!=t.length||!r?++n:--r;for(var o=t.charAt(r),l=x(o,i)?function(e){return x(e,i)}:/\s/.test(o)?function(e){return/\s/.test(e)}:function(e){return!/\s/.test(e)&&!x(e)};r>0&&l(t.charAt(r-1));)--r;for(;n<t.length&&l(t.charAt(n));)++n}return new Ts(E(e.line,r),E(e.line,n))},toggleOverwrite:function(e){null!=e&&e==this.state.overwrite||((this.state.overwrite=!this.state.overwrite)?s(this.display.cursorDiv,"CodeMirror-overwrite"):Fl(this.display.cursorDiv,"CodeMirror-overwrite"),Te(this,"overwriteToggle",this,this.state.overwrite))},hasFocus:function(){return this.display.input.getField()==l()},isReadOnly:function(){return!(!this.options.readOnly&&!this.doc.cantEdit)},scrollTo:pn(function(e,t){Xr(this,e,t)}),getScrollInfo:function(){var e=this.display.scroller;return{left:e.scrollLeft,top:e.scrollTop,height:e.scrollHeight-zt(this)-this.display.barHeight,width:e.scrollWidth-zt(this)-this.display.barWidth,clientHeight:Bt(this),clientWidth:Rt(this)}},scrollIntoView:pn(function(e,t){null==e?(e={from:this.doc.sel.primary().head,to:null},null==t&&(t=this.options.cursorScrollMargin)):"number"==typeof e?e={from:E(e,0),to:null}:null==e.from&&(e={from:e,to:null}),e.to||(e.to=e.from),e.margin=t||0,null!=e.from.line?Yr(this,e):$r(this,e.from,e.to,e.margin)}),setSize:pn(function(e,t){var r=this,n=function(e){return"number"==typeof e||/^\d+$/.test(String(e))?e+"px":e};null!=e&&(this.display.wrapper.style.width=n(e)),null!=t&&(this.display.wrapper.style.height=n(t)),this.options.lineWrapping&&Jt(this);var i=this.display.viewFrom;this.doc.iter(i,this.display.viewTo,function(e){if(e.widgets)for(var t=0;t<e.widgets.length;t++)if(e.widgets[t].noHScroll){mn(r,i,"widget");break}++i}),this.curOp.forceUpdate=!0,Te(this,"refresh",this)}),operation:function(e){return hn(this,e)},startOperation:function(){return nn(this)},endOperation:function(){return on(this)},refresh:pn(function(){var e=this.display.cachedTextHeight;vn(this),this.curOp.forceUpdate=!0,er(this),Xr(this,this.doc.scrollLeft,this.doc.scrollTop),Wn(this),(null==e||Math.abs(e-mr(this.display))>.5)&&Cr(this),Te(this,"refresh",this)}),swapDoc:pn(function(e){var t=this.doc;return t.cm=null,qn(this,e),er(this),this.display.input.reset(),Xr(this,e.scrollLeft,e.scrollTop),this.curOp.forceScroll=!0,bt(this,"swapDoc",this,t),t}),getInputField:function(){return this.display.input.getField()},getWrapperElement:function(){return this.display.wrapper},getScrollerElement:function(){return this.display.scroller},getGutterElement:function(){return this.display.gutters}},Ae(e),e.registerHelper=function(t,n,i){r.hasOwnProperty(t)||(r[t]=e[t]={_global:[]}),r[t][n]=i},e.registerGlobalHelper=function(t,n,i,o){e.registerHelper(t,n,o),r[t]._global.push({pred:i,val:o})}}(jo);var Js="iter insert remove copy getEditor constructor".split(" ");for(var ea in Ds.prototype)Ds.prototype.hasOwnProperty(ea)&&h(Js,ea)<0&&(jo.prototype[ea]=function(e){return function(){return e.apply(this.doc,arguments)}}(Ds.prototype[ea]));return Ae(Ds),jo.inputStyles={textarea:Qs,contenteditable:Zs},jo.defineMode=function(e){jo.defaults.mode||"null"==e||(jo.defaults.mode=e),Be.apply(this,arguments)},jo.defineMIME=function(e,t){os[e]=t},jo.defineMode("null",function(){return{token:function(e){return e.skipToEnd()}}}),jo.defineMIME("text/plain","null"),jo.defineExtension=function(e,t){jo.prototype[e]=t},jo.defineDocExtension=function(e,t){Ds.prototype[e]=t},jo.fromTextArea=function(e,t){function r(){e.value=a.getValue()}if(t=t?c(t):{},t.value=e.value,!t.tabindex&&e.tabIndex&&(t.tabindex=e.tabIndex),!t.placeholder&&e.placeholder&&(t.placeholder=e.placeholder),null==t.autofocus){var n=l();t.autofocus=n==e||null!=e.getAttribute("autofocus")&&n==document.body}var i;if(e.form&&(Ql(e.form,"submit",r),!t.leaveSubmitMethodAlone)){var o=e.form;i=o.submit;try{var s=o.submit=function(){r(),o.submit=i,o.submit(),o.submit=s}}catch(e){}}t.finishInit=function(t){t.save=r,t.getTextArea=function(){return e},t.toTextArea=function(){t.toTextArea=isNaN,r(),e.parentNode.removeChild(t.getWrapperElement()),e.style.display="",e.form&&(ke(e.form,"submit",r),"function"==typeof e.form.submit&&(e.form.submit=i))}},e.style.display="none";var a=jo(function(t){return e.parentNode.insertBefore(t,e.nextSibling)},t);return a},function(e){e.off=ke,e.on=Ql,e.wheelEventPixels=Pn,e.Doc=Ds,e.splitLines=es,e.countColumn=f,e.findColumn=d,e.isWordChar=w,e.Pass=Bl,e.signal=Te,e.Line=fs,e.changeEnd=Bn,e.scrollbarModel=ws,e.Pos=E,e.cmpPos=P,e.modes=is,e.mimeModes=os,e.resolveMode=Ge,e.getMode=Ue,e.modeExtensions=ls,e.extendMode=Ve,e.copyState=Ke,e.startState=Xe,e.innerMode=je,e.commands=Bs,e.keyMap=Rs,e.keyName=ao,e.isModifierKey=lo,e.lookupKey=oo,e.normalizeKeyMap=io,e.StringStream=ss,e.SharedTextMarker=As,e.TextMarker=Os,e.LineWidget=Ms,e.e_preventDefault=We,e.e_stopPropagation=De,e.e_stop=Fe,e.addClass=s,e.contains=o,e.rmClass=Fl,e.keyNames=Es}(jo),jo.version="5.30.0",jo});
      !function(e){"object"==typeof exports&&"object"==typeof module?e(require("../../lib/codemirror")):"function"==typeof define&&define.amd?define(["../../lib/codemirror"],e):e(CodeMirror)}(function(e){"use strict";function t(e,t,n,r,o,a){this.indented=e,this.column=t,this.type=n,this.info=r,this.align=o,this.prev=a}function n(e,n,r,o){var a=e.indented;return e.context&&"statement"==e.context.type&&"statement"!=r&&(a=e.context.indented),e.context=new t(a,n,r,o,null,e.context)}function r(e){var t=e.context.type;return")"!=t&&"]"!=t&&"}"!=t||(e.indented=e.context.indented),e.context=e.context.prev}function o(e,t,n){return"variable"==t.prevToken||"type"==t.prevToken||(!!/\S(?:[^- ]>|[*\]])\s*$|\*$/.test(e.string.slice(0,n))||(!(!t.typeAtEndOfLine||e.column()!=e.indentation())||void 0))}function a(e){for(;;){if(!e||"top"==e.type)return!0;if("}"==e.type&&"namespace"!=e.prev.info)return!1;e=e.prev}}function i(e){for(var t={},n=e.split(" "),r=0;r<n.length;++r)t[n[r]]=!0;return t}function l(e,t){return"function"==typeof e?e(t):e.propertyIsEnumerable(t)}function s(e,t){if(!t.startOfLine)return!1;for(var n,r=null;n=e.peek();){if("\\"==n&&e.match(/^.$/)){r=s;break}if("/"==n&&e.match(/^\/[\/\*]/,!1))break;e.next()}return t.tokenize=r,"meta"}function c(e,t){return"type"==t.prevToken&&"type"}function u(e){return e.eatWhile(/[\w\.']/),"number"}function d(e,t){if(e.backUp(1),e.match(/(R|u8R|uR|UR|LR)/)){var n=e.match(/"([^\s\\()]{0,16})\(/);return!!n&&(t.cpp11RawStringDelim=n[1],t.tokenize=m,m(e,t))}return e.match(/(u8|u|U|L)/)?!!e.match(/["']/,!1)&&"string":(e.next(),!1)}function f(e){var t=/(\w+)::~?(\w+)$/.exec(e);return t&&t[1]==t[2]}function p(e,t){for(var n;null!=(n=e.next());)if('"'==n&&!e.eat('"')){t.tokenize=null;break}return"string"}function m(e,t){var n=t.cpp11RawStringDelim.replace(/[^\w\s]/g,"\\$&");return e.match(new RegExp(".*?\\)"+n+'"'))?t.tokenize=null:e.skipToEnd(),"string"}function h(t,n){function r(e){if(e)for(var t in e)e.hasOwnProperty(t)&&o.push(t)}"string"==typeof t&&(t=[t]);var o=[];r(n.keywords),r(n.types),r(n.builtin),r(n.atoms),o.length&&(n.helperType=t[0],e.registerHelper("hintWords",t[0],o));for(var a=0;a<t.length;++a)e.defineMIME(t[a],n)}function g(e,t){for(var n=!1;!e.eol();){if(!n&&e.match('"""')){t.tokenize=null;break}n="\\"==e.next()&&!n}return"string"}function y(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!e&&!o&&t.match('"')){a=!0;break}if(e&&t.match('"""')){a=!0;break}r=t.next(),!o&&"$"==r&&t.match("{")&&t.skipTo("}"),o=!o&&"\\"==r&&!e}return!a&&e||(n.tokenize=null),"string"}}function x(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!o&&t.match('"')&&("single"==e||t.match('""'))){a=!0;break}if(!o&&t.match("``")){w=x(e),a=!0;break}r=t.next(),o="single"==e&&!o&&"\\"==r}return a&&(n.tokenize=null),"string"}}e.defineMode("clike",function(i,s){function c(e,t){var n=e.next();if(S[n]){var r=S[n](e,t);if(!1!==r)return r}if('"'==n||"'"==n)return t.tokenize=u(n),t.tokenize(e,t);if(D.test(n))return p=n,null;if(L.test(n)){if(e.backUp(1),e.match(I))return"number";e.next()}if("/"==n){if(e.eat("*"))return t.tokenize=d,d(e,t);if(e.eat("/"))return e.skipToEnd(),"comment"}if(F.test(n)){for(;!e.match(/^\/[\/*]/,!1)&&e.eat(F););return"operator"}if(e.eatWhile(z),P)for(;e.match(P);)e.eatWhile(z);var o=e.current();return l(x,o)?(l(w,o)&&(p="newstatement"),l(v,o)&&(m=!0),"keyword"):l(b,o)?"type":l(k,o)?(l(w,o)&&(p="newstatement"),"builtin"):l(_,o)?"atom":"variable"}function u(e){return function(t,n){for(var r,o=!1,a=!1;null!=(r=t.next());){if(r==e&&!o){a=!0;break}o=!o&&"\\"==r}return(a||!o&&!C)&&(n.tokenize=null),"string"}}function d(e,t){for(var n,r=!1;n=e.next();){if("/"==n&&r){t.tokenize=null;break}r="*"==n}return"comment"}function f(e,t){s.typeFirstDefinitions&&e.eol()&&a(t.context)&&(t.typeAtEndOfLine=o(e,t,e.pos))}var p,m,h=i.indentUnit,g=s.statementIndentUnit||h,y=s.dontAlignCalls,x=s.keywords||{},b=s.types||{},k=s.builtin||{},w=s.blockKeywords||{},v=s.defKeywords||{},_=s.atoms||{},S=s.hooks||{},C=s.multiLineStrings,T=!1!==s.indentStatements,M=!1!==s.indentSwitch,P=s.namespaceSeparator,D=s.isPunctuationChar||/[\[\]{}\(\),;\:\.]/,L=s.numberStart||/[\d\.]/,I=s.number||/^(?:0x[a-f\d]+|0b[01]+|(?:\d+\.?\d*|\.\d+)(?:e[-+]?\d+)?)(u|ll?|l|f)?/i,F=s.isOperatorChar||/[+\-*&%=<>!?|\/]/,z=s.isIdentifierChar||/[\w\$_\xa1-\uffff]/;return{startState:function(e){return{tokenize:null,context:new t((e||0)-h,0,"top",null,!1),indented:0,startOfLine:!0,prevToken:null}},token:function(e,t){var i=t.context;if(e.sol()&&(null==i.align&&(i.align=!1),t.indented=e.indentation(),t.startOfLine=!0),e.eatSpace())return f(e,t),null;p=m=null;var l=(t.tokenize||c)(e,t);if("comment"==l||"meta"==l)return l;if(null==i.align&&(i.align=!0),";"==p||":"==p||","==p&&e.match(/^\s*(?:\/\/.*)?$/,!1))for(;"statement"==t.context.type;)r(t);else if("{"==p)n(t,e.column(),"}");else if("["==p)n(t,e.column(),"]");else if("("==p)n(t,e.column(),")");else if("}"==p){for(;"statement"==i.type;)i=r(t);for("}"==i.type&&(i=r(t));"statement"==i.type;)i=r(t)}else p==i.type?r(t):T&&(("}"==i.type||"top"==i.type)&&";"!=p||"statement"==i.type&&"newstatement"==p)&&n(t,e.column(),"statement",e.current());if("variable"==l&&("def"==t.prevToken||s.typeFirstDefinitions&&o(e,t,e.start)&&a(t.context)&&e.match(/^\s*\(/,!1))&&(l="def"),S.token){var u=S.token(e,t,l);void 0!==u&&(l=u)}return"def"==l&&!1===s.styleDefs&&(l="variable"),t.startOfLine=!1,t.prevToken=m?"def":l||p,f(e,t),l},indent:function(t,n){if(t.tokenize!=c&&null!=t.tokenize||t.typeAtEndOfLine)return e.Pass;var r=t.context,o=n&&n.charAt(0);if("statement"==r.type&&"}"==o&&(r=r.prev),s.dontIndentStatements)for(;"statement"==r.type&&s.dontIndentStatements.test(r.info);)r=r.prev;if(S.indent){var a=S.indent(t,r,n);if("number"==typeof a)return a}var i=o==r.type,l=r.prev&&"switch"==r.prev.info;if(s.allmanIndentation&&/[{(]/.test(o)){for(;"top"!=r.type&&"}"!=r.type;)r=r.prev;return r.indented}return"statement"==r.type?r.indented+("{"==o?0:g):!r.align||y&&")"==r.type?")"!=r.type||i?r.indented+(i?0:h)+(i||!l||/^(?:case|default)\b/.test(n)?0:h):r.indented+g:r.column+(i?0:1)},electricInput:M?/^\s*(?:case .*?:|default:|\{\}?|\})$/:/^\s*[{}]$/,blockCommentStart:"/*",blockCommentEnd:"*/",lineComment:"//",fold:"brace"}});var b="auto if break case register continue return default do sizeof static else struct switch extern typedef union for goto while enum const volatile",k="int long char short double float unsigned signed void size_t ptrdiff_t";h(["text/x-csrc","text/x-c","text/x-chdr"],{name:"clike",keywords:i(b),types:i(k+" bool _Complex _Bool float_t double_t intptr_t intmax_t int8_t int16_t int32_t int64_t uintptr_t uintmax_t uint8_t uint16_t uint32_t uint64_t"),blockKeywords:i("case do else for if switch while struct"),defKeywords:i("struct"),typeFirstDefinitions:!0,atoms:i("null true false"),hooks:{"#":s,"*":c},modeProps:{fold:["brace","include"]}}),h(["text/x-c++src","text/x-c++hdr"],{name:"clike",keywords:i(b+" asm dynamic_cast namespace reinterpret_cast try explicit new static_cast typeid catch operator template typename class friend private this using const_cast inline public throw virtual delete mutable protected alignas alignof constexpr decltype nullptr noexcept thread_local final static_assert override"),types:i(k+" bool wchar_t"),blockKeywords:i("catch class do else finally for if struct switch try while"),defKeywords:i("class namespace struct enum union"),typeFirstDefinitions:!0,atoms:i("true false null"),dontIndentStatements:/^template$/,isIdentifierChar:/[\w\$_~\xa1-\uffff]/,hooks:{"#":s,"*":c,u:d,U:d,L:d,R:d,0:u,1:u,2:u,3:u,4:u,5:u,6:u,7:u,8:u,9:u,token:function(e,t,n){if("variable"==n&&"("==e.peek()&&(";"==t.prevToken||null==t.prevToken||"}"==t.prevToken)&&f(e.current()))return"def"}},namespaceSeparator:"::",modeProps:{fold:["brace","include"]}}),h("text/x-java",{name:"clike",keywords:i("abstract assert break case catch class const continue default do else enum extends final finally float for goto if implements import instanceof interface native new package private protected public return static strictfp super switch synchronized this throw throws transient try volatile while @interface"),types:i("byte short int long float double boolean char void Boolean Byte Character Double Float Integer Long Number Object Short String StringBuffer StringBuilder Void"),blockKeywords:i("catch class do else finally for if switch try while"),defKeywords:i("class interface package enum @interface"),typeFirstDefinitions:!0,atoms:i("true false null"),number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,hooks:{"@":function(e){return!e.match("interface",!1)&&(e.eatWhile(/[\w\$_]/),"meta")}},modeProps:{fold:["brace","import"]}}),h("text/x-csharp",{name:"clike",keywords:i("abstract as async await base break case catch checked class const continue default delegate do else enum event explicit extern finally fixed for foreach goto if implicit in interface internal is lock namespace new operator out override params private protected public readonly ref return sealed sizeof stackalloc static struct switch this throw try typeof unchecked unsafe using virtual void volatile while add alias ascending descending dynamic from get global group into join let orderby partial remove select set value var yield"),types:i("Action Boolean Byte Char DateTime DateTimeOffset Decimal Double Func Guid Int16 Int32 Int64 Object SByte Single String Task TimeSpan UInt16 UInt32 UInt64 bool byte char decimal double short int long object sbyte float string ushort uint ulong"),blockKeywords:i("catch class do else finally for foreach if struct switch try while"),defKeywords:i("class interface namespace struct var"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"@":function(e,t){return e.eat('"')?(t.tokenize=p,p(e,t)):(e.eatWhile(/[\w\$_]/),"meta")}}}),h("text/x-scala",{name:"clike",keywords:i("abstract case catch class def do else extends final finally for forSome if implicit import lazy match new null object override package private protected return sealed super this throw trait try type val var while with yield _ assert assume require print println printf readLine readBoolean readByte readShort readChar readInt readLong readFloat readDouble"),types:i("AnyVal App Application Array BufferedIterator BigDecimal BigInt Char Console Either Enumeration Equiv Error Exception Fractional Function IndexedSeq Int Integral Iterable Iterator List Map Numeric Nil NotNull Option Ordered Ordering PartialFunction PartialOrdering Product Proxy Range Responder Seq Serializable Set Specializable Stream StringBuilder StringContext Symbol Throwable Traversable TraversableOnce Tuple Unit Vector Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),multiLineStrings:!0,blockKeywords:i("catch class enum do else finally for forSome if match switch try while"),defKeywords:i("class enum def object package trait type val var"),atoms:i("true false null"),indentStatements:!1,indentSwitch:!1,isOperatorChar:/[+\-*&%=<>!?|\/#:@]/,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return!!e.match('""')&&(t.tokenize=g,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},"=":function(e,n){var r=n.context;return!("}"!=r.type||!r.align||!e.eat(">"))&&(n.context=new t(r.indented,r.column,r.type,r.info,null,r.prev),"operator")}},modeProps:{closeBrackets:{triples:'"'}}}),h("text/x-kotlin",{name:"clike",keywords:i("package as typealias class interface this super val var fun for is in This throw return break continue object if else while do try when !in !is as? file import where by get set abstract enum open inner override private public internal protected catch finally out final vararg reified dynamic companion constructor init sealed field property receiver param sparam lateinit data inline noinline tailrec external annotation crossinline const operator infix suspend"),types:i("Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),intendSwitch:!1,indentStatements:!1,multiLineStrings:!0,number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,blockKeywords:i("catch class do else finally for if where try while enum"),defKeywords:i("class val var object package interface fun"),atoms:i("true false null this"),hooks:{'"':function(e,t){return t.tokenize=y(e.match('""')),t.tokenize(e,t)}},modeProps:{closeBrackets:{triples:'"'}}}),h(["x-shader/x-vertex","x-shader/x-fragment"],{name:"clike",keywords:i("sampler1D sampler2D sampler3D samplerCube sampler1DShadow sampler2DShadow const attribute uniform varying break continue discard return for while do if else struct in out inout"),types:i("float int bool void vec2 vec3 vec4 ivec2 ivec3 ivec4 bvec2 bvec3 bvec4 mat2 mat3 mat4"),blockKeywords:i("for while do if else struct"),builtin:i("radians degrees sin cos tan asin acos atan pow exp log exp2 sqrt inversesqrt abs sign floor ceil fract mod min max clamp mix step smoothstep length distance dot cross normalize ftransform faceforward reflect refract matrixCompMult lessThan lessThanEqual greaterThan greaterThanEqual equal notEqual any all not texture1D texture1DProj texture1DLod texture1DProjLod texture2D texture2DProj texture2DLod texture2DProjLod texture3D texture3DProj texture3DLod texture3DProjLod textureCube textureCubeLod shadow1D shadow2D shadow1DProj shadow2DProj shadow1DLod shadow2DLod shadow1DProjLod shadow2DProjLod dFdx dFdy fwidth noise1 noise2 noise3 noise4"),atoms:i("true false gl_FragColor gl_SecondaryColor gl_Normal gl_Vertex gl_MultiTexCoord0 gl_MultiTexCoord1 gl_MultiTexCoord2 gl_MultiTexCoord3 gl_MultiTexCoord4 gl_MultiTexCoord5 gl_MultiTexCoord6 gl_MultiTexCoord7 gl_FogCoord gl_PointCoord gl_Position gl_PointSize gl_ClipVertex gl_FrontColor gl_BackColor gl_FrontSecondaryColor gl_BackSecondaryColor gl_TexCoord gl_FogFragCoord gl_FragCoord gl_FrontFacing gl_FragData gl_FragDepth gl_ModelViewMatrix gl_ProjectionMatrix gl_ModelViewProjectionMatrix gl_TextureMatrix gl_NormalMatrix gl_ModelViewMatrixInverse gl_ProjectionMatrixInverse gl_ModelViewProjectionMatrixInverse gl_TexureMatrixTranspose gl_ModelViewMatrixInverseTranspose gl_ProjectionMatrixInverseTranspose gl_ModelViewProjectionMatrixInverseTranspose gl_TextureMatrixInverseTranspose gl_NormalScale gl_DepthRange gl_ClipPlane gl_Point gl_FrontMaterial gl_BackMaterial gl_LightSource gl_LightModel gl_FrontLightModelProduct gl_BackLightModelProduct gl_TextureColor gl_EyePlaneS gl_EyePlaneT gl_EyePlaneR gl_EyePlaneQ gl_FogParameters gl_MaxLights gl_MaxClipPlanes gl_MaxTextureUnits gl_MaxTextureCoords gl_MaxVertexAttribs gl_MaxVertexUniformComponents gl_MaxVaryingFloats gl_MaxVertexTextureImageUnits gl_MaxTextureImageUnits gl_MaxFragmentUniformComponents gl_MaxCombineTextureImageUnits gl_MaxDrawBuffers"),indentSwitch:!1,hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-nesc",{name:"clike",keywords:i(b+"as atomic async call command component components configuration event generic implementation includes interface module new norace nx_struct nx_union post provides signal task uses abstract extends"),types:i(k),blockKeywords:i("case do else for if switch while struct"),atoms:i("null true false"),hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-objectivec",{name:"clike",keywords:i(b+"inline restrict _Bool _Complex _Imaginary BOOL Class bycopy byref id IMP in inout nil oneway out Protocol SEL self super atomic nonatomic retain copy readwrite readonly"),types:i(k),atoms:i("YES NO NULL NILL ON OFF true false"),hooks:{"@":function(e){return e.eatWhile(/[\w\$]/),"keyword"},"#":s,indent:function(e,t,n){if("statement"==t.type&&/^@\w/.test(n))return t.indented}},modeProps:{fold:"brace"}}),h("text/x-squirrel",{name:"clike",keywords:i("base break clone continue const default delete enum extends function in class foreach local resume return this throw typeof yield constructor instanceof static"),types:i(k),blockKeywords:i("case catch class else for foreach if switch try while"),defKeywords:i("function local class"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"#":s},modeProps:{fold:["brace","include"]}});var w=null;h("text/x-ceylon",{name:"clike",keywords:i("abstracts alias assembly assert assign break case catch class continue dynamic else exists extends finally for function given if import in interface is let module new nonempty object of out outer package return satisfies super switch then this throw try value void while"),types:function(e){var t=e.charAt(0);return t===t.toUpperCase()&&t!==t.toLowerCase()},blockKeywords:i("case catch class dynamic else finally for function if interface module new object switch try while"),defKeywords:i("class dynamic function interface module object package value"),builtin:i("abstract actual aliased annotation by default deprecated doc final formal late license native optional sealed see serializable shared suppressWarnings tagged throws variable"),isPunctuationChar:/[\[\]{}\(\),;\:\.`]/,isOperatorChar:/[+\-*&%=<>!?|^~:\/]/,numberStart:/[\d#$]/,number:/^(?:#[\da-fA-F_]+|\$[01_]+|[\d_]+[kMGTPmunpf]?|[\d_]+\.[\d_]+(?:[eE][-+]?\d+|[kMGTPmunpf]|)|)/i,multiLineStrings:!0,typeFirstDefinitions:!0,atoms:i("true false null larger smaller equal empty finished"),indentSwitch:!1,styleDefs:!1,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return t.tokenize=x(e.match('""')?"triple":"single"),t.tokenize(e,t)},"`":function(e,t){return!(!w||!e.match("`"))&&(t.tokenize=w,w=null,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},token:function(e,t,n){if(("variable"==n||"type"==n)&&"."==t.prevToken)return"variable-2"}},modeProps:{fold:["brace","import"],closeBrackets:{triples:'"'}}})});
      // -------------------------------------------------------------------------
//  Part of the CodeChecker project, under the Apache License v2.0 with
//  LLVM Exceptions. See LICENSE for license information.
//  SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
// -------------------------------------------------------------------------

var BugViewer = {
  _files : [],
  _reports : [],
  _lineWidgets : [],
  _navigationMenuItems : [],
  _sourceFileData : null,
  _currentReport : null,
  _lastBugEvent  : null,

  init : function (files, reports) {
    this._files = files;
    this._reports = reports;

    this.initEscapeChars();
  },

  initEscapeChars : function () {
    this.escapeChars = {
      ' ' : 'nbsp',
      '<' : 'lt',
      '>' : 'gt',
      '"' : 'quot',
      '&' : 'amp'
    };

    var regexString = '[';
    for (var key in this.escapeChars) {
      regexString += key;
    }
    regexString += ']';

    this.escapeRegExp = new RegExp( regexString, 'g');
  },

  escapeHTML : function (str) {
    var that = this;

    return str.replace(this.escapeRegExp, function (m) {
      return '&' + that.escapeChars[m] + ';';
    });
  },

  initByUrl : function () {
    if (!this._reports) return;

    var state = {};
    window.location.hash.substr(1).split('&').forEach(function (s) {
      var parts = s.split('=');
      state[parts[0]] = parts[1];
    });

    for (var key in this._reports) {
      var report = this._reports[key];
      if (report.reportHash === state['reportHash']) {
        this.navigate(report);
        return;
      }
    }

    this.navigate(this._reports[0]);
  },

  create : function () {
    this._content = document.getElementById('editor-wrapper');
    this._filepath = document.getElementById('file-path');
    this._checkerName = document.getElementById('checker-name');
    this._reviewStatusWrapper =
      document.getElementById('review-status-wrapper');
    this._reviewStatus = document.getElementById('review-status');
    this._editor = document.getElementById('editor');

    this._codeMirror = CodeMirror(this._editor, {
      mode: 'text/x-c++src',
      matchBrackets : true,
      lineNumbers : true,
      readOnly : true,
      foldGutter : true,
      extraKeys : {},
      viewportMargin : 100
    });

    this._createNavigationMenu();
  },

  navigate : function (report, item) {
    if (!item) {
      var items = this._navigationMenuItems.filter(function (navItem) {
        return navItem.report.reportHash === report.reportHash;
      });

      if (!items.length) return;

      item = items[0].widget;
    }

    this._selectedReport.classList.remove('active');
    this._selectedReport = item;
    this._selectedReport.classList.add('active');
    this.setReport(report);
  },

  _createNavigationMenu : function () {
    var that = this;

    var nav = document.getElementById('report-nav');
    var list = document.createElement('ul');
    this._reports.forEach(function (report) {
      var events = report['events'];
      var lastBugEvent = events[events.length - 1];
      var item = document.createElement('li');

      var severity = document.createElement('i');
      severity.className = 'severity-' + report.severity.toLowerCase();

      item.appendChild(severity);
      item.appendChild(document.createTextNode(lastBugEvent.message));

      item.addEventListener('click', function () {
        that.navigate(report, item);
      })
      list.appendChild(item);
      that._navigationMenuItems.push({ report : report, widget : item });
    });

    if (!this._selectedReport && list.childNodes.length) {
      this._selectedReport = list.childNodes[0];
      this._selectedReport.classList.add('active');
    }

    nav.appendChild(list);
  },

  setReport : function (report) {
    this._currentReport = report;
    var events = report['events'];
    var lastBugEvent = events[events.length - 1];
    this.setCurrentBugEvent(lastBugEvent, events.length - 1);
    this.setCheckerName(report.checkerName);
    this.setReviewStatus(report.reviewStatus);

    window.location.hash = '#reportHash=' + report.reportHash;
  },

  setCurrentBugEvent : function (event, idx) {
    this._currentBugEvent = event;
    this.setSourceFileData(this._files[event.location.file]);
    this.drawBugPath();

    this.jumpTo(event.location.line, 0);
    this.highlightBugEvent(event, idx);
  },

  highlightBugEvent : function (event, idx) {
    this._lineWidgets.forEach(function (widget) {
      var lineIdx = widget.node.getAttribute('idx');
      if (parseInt(lineIdx) === idx) {
        widget.node.classList.add('current');
      }
    });
  },

  setCheckerName : function (checkerName) {
    this._checkerName.innerHTML = checkerName;
  },

  setReviewStatus : function (status) {
    if (status) {
      var className =
        'review-status-' + status.toLowerCase().split(' ').join('-');
      this._reviewStatus.className = "review-status " + className;

      this._reviewStatus.innerHTML = status;
      this._reviewStatusWrapper.style.display = 'block';
    } else {
      this._reviewStatusWrapper.style.display = 'none';
    }
  },

  setSourceFileData : function (file) {
    if (this._sourceFileData && file.id === this._sourceFileData.id) {
      return;
    }

    this._sourceFileData = file;
    this._filepath.innerHTML = file.path;
    this._codeMirror.doc.setValue(file.content);
    this._refresh();
  },

  _refresh : function () {
    var that = this;
    setTimeout(function () {
      var fullHeight = parseInt(that._content.clientHeight);
      var headerHeight = that._filepath.clientHeight;

      that._codeMirror.setSize('auto', fullHeight - headerHeight);
      that._codeMirror.refresh();
    }, 200);
  },

  clearBubbles : function () {
    this._lineWidgets.forEach(function (widget) { widget.clear(); });
    this._lineWidgets = [];
  },

  getMessage : function (event, kind) {
    if (kind === 'macro') {
      var name = 'macro expansion' + (event.name ? ': ' + event.name : '');

      return '<span class="tag macro">' + name + '</span>'
        + this.escapeHTML(event.expansion).replace(/(?:\r\n|\r|\n)/g, '<br>');
    } else if (kind === 'note') {
      return '<span class="tag note">note</span>'
        +  this.escapeHTML(event.message).replace(/(?:\r\n|\r|\n)/g, '<br>');
    }
  },

  addExtraPathEvents : function (events, kind) {
    var that = this;

    if (!events) {
      return;
    }

    events.forEach(function (event) {
      if (event.location.file !== that._currentBugEvent.location.file) {
        return;
      }

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + kind);

      var msg = document.createElement('span');
      msg.innerHTML = that.getMessage(event, kind);
      element.appendChild(msg);

      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  drawBugPath : function () {
    var that = this;

    this.clearBubbles();

    this.addExtraPathEvents(this._currentReport.macros, 'macro');
    this.addExtraPathEvents(this._currentReport.notes, 'note');

    // Processing bug path events.
    var currentEvents = this._currentReport.events;
    currentEvents.forEach(function (event, step) {
      if (event.location.file !== that._currentBugEvent.location.file)
        return;

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';
      var type = step === currentEvents.length - 1 ? 'error' : 'info';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + type);
      element.setAttribute('idx', step);

      var enumeration = document.createElement('span');
      enumeration.setAttribute('class', 'checker-enum ' + type);
      enumeration.innerHTML = step + 1;

      if (currentEvents.length > 1)
        element.appendChild(enumeration);

      var prevBugEvent = step - 1;
      if (step > 0) {
        var prevBug = document.createElement('span');
        prevBug.setAttribute('class', 'arrow left-arrow');
        prevBug.addEventListener('click', function () {
          var event = currentEvents[prevBugEvent];
          that.setCurrentBugEvent(event, prevBugEvent);
        });
        element.appendChild(prevBug);
      }

      var msg = document.createElement('span');
      msg.innerHTML = that.escapeHTML(event.message)
        .replace(/(?:\r\n|\r|\n)/g, '<br>');

      element.appendChild(msg);

      var nextBugEvent = step + 1;
      if (nextBugEvent < currentEvents.length) {
        var nextBug = document.createElement('span');
        nextBug.setAttribute('class', 'arrow right-arrow');
        nextBug.addEventListener('click', function () {
          var event = currentEvents[nextBugEvent];
          that.setCurrentBugEvent(event, nextBugEvent);
        });
        element.appendChild(nextBug);
      }


      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  jumpTo : function (line, column) {
    var that = this;

    setTimeout(function () {
      var selPosPixel
        = that._codeMirror.charCoords({ line : line, ch : column }, 'local');
      var editorSize = {
        width  : that._editor.clientWidth,
        height : that._editor.clientHeight
      };

      that._codeMirror.scrollIntoView({
        top    : selPosPixel.top - 100,
        bottom : selPosPixel.top + editorSize.height - 150,
        left   : selPosPixel.left < editorSize.width - 100
               ? 0
               : selPosPixel.left - 50,
        right  : selPosPixel.left < editorSize.width - 100
               ? 10
               : selPosPixel.left + editorSize.width - 100
      });
    }, 0);
  }
}


      var data = {"files": {"20": {"id": 20, "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/TypeLoc.h", "content": "//===- TypeLoc.h - Type Source Info Wrapper ---------------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n/// \\file\n/// Defines the clang::TypeLoc interface and its subclasses.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_CLANG_AST_TYPELOC_H\n#define LLVM_CLANG_AST_TYPELOC_H\n\n#include \"clang/AST/DeclarationName.h\"\n#include \"clang/AST/NestedNameSpecifier.h\"\n#include \"clang/AST/TemplateBase.h\"\n#include \"clang/AST/Type.h\"\n#include \"clang/Basic/LLVM.h\"\n#include \"clang/Basic/SourceLocation.h\"\n#include \"clang/Basic/Specifiers.h\"\n#include \"llvm/ADT/ArrayRef.h\"\n#include \"llvm/Support/Casting.h\"\n#include \"llvm/Support/Compiler.h\"\n#include \"llvm/Support/MathExtras.h\"\n#include <algorithm>\n#include <cassert>\n#include <cstdint>\n#include <cstring>\n\nnamespace clang {\n\nclass Attr;\nclass ASTContext;\nclass CXXRecordDecl;\nclass ConceptDecl;\nclass Expr;\nclass ObjCInterfaceDecl;\nclass ObjCProtocolDecl;\nclass ObjCTypeParamDecl;\nclass ParmVarDecl;\nclass TemplateTypeParmDecl;\nclass UnqualTypeLoc;\nclass UnresolvedUsingTypenameDecl;\n\n// Predeclare all the type nodes.\n#define ABSTRACT_TYPELOC(Class, Base)\n#define TYPELOC(Class, Base) \\\n  class Class##TypeLoc;\n#include \"clang/AST/TypeLocNodes.def\"\n\n/// Base wrapper for a particular \"section\" of type source info.\n///\n/// A client should use the TypeLoc subclasses through castAs()/getAs()\n/// in order to get at the actual information.\nclass TypeLoc {\nprotected:\n  // The correctness of this relies on the property that, for Type *Ty,\n  //   QualType(Ty, 0).getAsOpaquePtr() == (void*) Ty\n  const void *Ty = nullptr;\n  void *Data = nullptr;\n\npublic:\n  TypeLoc() = default;\n  TypeLoc(QualType ty, void *opaqueData)\n      : Ty(ty.getAsOpaquePtr()), Data(opaqueData) {}\n  TypeLoc(const Type *ty, void *opaqueData)\n      : Ty(ty), Data(opaqueData) {}\n\n  /// Convert to the specified TypeLoc type, asserting that this TypeLoc\n  /// is of the desired type.\n  ///\n  /// \\pre T::isKind(*this)\n  template<typename T>\n  T castAs() const {\n    assert(T::isKind(*this));\n    T t;\n    TypeLoc& tl = t;\n    tl = *this;\n    return t;\n  }\n\n  /// Convert to the specified TypeLoc type, returning a null TypeLoc if\n  /// this TypeLoc is not of the desired type.\n  template<typename T>\n  T getAs() const {\n    if (!T::isKind(*this))\n      return {};\n    T t;\n    TypeLoc& tl = t;\n    tl = *this;\n    return t;\n  }\n\n  /// Convert to the specified TypeLoc type, returning a null TypeLoc if\n  /// this TypeLoc is not of the desired type. It will consider type\n  /// adjustments from a type that was written as a T to another type that is\n  /// still canonically a T (ignores parens, attributes, elaborated types, etc).\n  template <typename T>\n  T getAsAdjusted() const;\n\n  /// The kinds of TypeLocs.  Equivalent to the Type::TypeClass enum,\n  /// except it also defines a Qualified enum that corresponds to the\n  /// QualifiedLoc class.\n  enum TypeLocClass {\n#define ABSTRACT_TYPE(Class, Base)\n#define TYPE(Class, Base) \\\n    Class = Type::Class,\n#include \"clang/AST/TypeNodes.inc\"\n    Qualified\n  };\n\n  TypeLocClass getTypeLocClass() const {\n    if (getType().hasLocalQualifiers()) return Qualified;\n    return (TypeLocClass) getType()->getTypeClass();\n  }\n\n  bool isNull() const { return !Ty; }\n  explicit operator bool() const { return Ty; }\n\n  /// Returns the size of type source info data block for the given type.\n  static unsigned getFullDataSizeForType(QualType Ty);\n\n  /// Returns the alignment of type source info data block for\n  /// the given type.\n  static unsigned getLocalAlignmentForType(QualType Ty);\n\n  /// Get the type for which this source info wrapper provides\n  /// information.\n  QualType getType() const {\n    return QualType::getFromOpaquePtr(Ty);\n  }\n\n  const Type *getTypePtr() const {\n    return QualType::getFromOpaquePtr(Ty).getTypePtr();\n  }\n\n  /// Get the pointer where source information is stored.\n  void *getOpaqueData() const {\n    return Data;\n  }\n\n  /// Get the begin source location.\n  SourceLocation getBeginLoc() const;\n\n  /// Get the end source location.\n  SourceLocation getEndLoc() const;\n\n  /// Get the full source range.\n  SourceRange getSourceRange() const LLVM_READONLY {\n    return SourceRange(getBeginLoc(), getEndLoc());\n  }\n\n\n  /// Get the local source range.\n  SourceRange getLocalSourceRange() const {\n    return getLocalSourceRangeImpl(*this);\n  }\n\n  /// Returns the size of the type source info data block.\n  unsigned getFullDataSize() const {\n    return getFullDataSizeForType(getType());\n  }\n\n  /// Get the next TypeLoc pointed by this TypeLoc, e.g for \"int*\" the\n  /// TypeLoc is a PointerLoc and next TypeLoc is for \"int\".\n  TypeLoc getNextTypeLoc() const {\n    return getNextTypeLocImpl(*this);\n  }\n\n  /// Skips past any qualifiers, if this is qualified.\n  UnqualTypeLoc getUnqualifiedLoc() const; // implemented in this header\n\n  TypeLoc IgnoreParens() const;\n\n  /// Find a type with the location of an explicit type qualifier.\n  ///\n  /// The result, if non-null, will be one of:\n  ///   QualifiedTypeLoc\n  ///   AtomicTypeLoc\n  ///   AttributedTypeLoc, for those type attributes that behave as qualifiers\n  TypeLoc findExplicitQualifierLoc() const;\n\n  /// Get the typeloc of an AutoType whose type will be deduced for a variable\n  /// with an initializer of this type. This looks through declarators like\n  /// pointer types, but not through decltype or typedefs.\n  AutoTypeLoc getContainedAutoTypeLoc() const;\n\n  /// Initializes this to state that every location in this\n  /// type is the given location.\n  ///\n  /// This method exists to provide a simple transition for code that\n  /// relies on location-less types.\n  void initialize(ASTContext &Context, SourceLocation Loc) const {\n    initializeImpl(Context, *this, Loc);\n  }\n\n  /// Initializes this by copying its information from another\n  /// TypeLoc of the same type.\n  void initializeFullCopy(TypeLoc Other) {\n    assert(getType() == Other.getType());\n    copy(Other);\n  }\n\n  /// Initializes this by copying its information from another\n  /// TypeLoc of the same type.  The given size must be the full data\n  /// size.\n  void initializeFullCopy(TypeLoc Other, unsigned Size) {\n    assert(getType() == Other.getType());\n    assert(getFullDataSize() == Size);\n    copy(Other);\n  }\n\n  /// Copies the other type loc into this one.\n  void copy(TypeLoc other);\n\n  friend bool operator==(const TypeLoc &LHS, const TypeLoc &RHS) {\n    return LHS.Ty == RHS.Ty && LHS.Data == RHS.Data;\n  }\n\n  friend bool operator!=(const TypeLoc &LHS, const TypeLoc &RHS) {\n    return !(LHS == RHS);\n  }\n\n  /// Find the location of the nullability specifier (__nonnull,\n  /// __nullable, or __null_unspecifier), if there is one.\n  SourceLocation findNullabilityLoc() const;\n\nprivate:\n  static bool isKind(const TypeLoc&) {\n    return true;\n  }\n\n  static void initializeImpl(ASTContext &Context, TypeLoc TL,\n                             SourceLocation Loc);\n  static TypeLoc getNextTypeLocImpl(TypeLoc TL);\n  static TypeLoc IgnoreParensImpl(TypeLoc TL);\n  static SourceRange getLocalSourceRangeImpl(TypeLoc TL);\n};\n\n/// Return the TypeLoc for a type source info.\ninline TypeLoc TypeSourceInfo::getTypeLoc() const {\n  // TODO: is this alignment already sufficient?\n  return TypeLoc(Ty, const_cast<void*>(static_cast<const void*>(this + 1)));\n}\n\n/// Wrapper of type source information for a type with\n/// no direct qualifiers.\nclass UnqualTypeLoc : public TypeLoc {\npublic:\n  UnqualTypeLoc() = default;\n  UnqualTypeLoc(const Type *Ty, void *Data) : TypeLoc(Ty, Data) {}\n\n  const Type *getTypePtr() const {\n    return reinterpret_cast<const Type*>(Ty);\n  }\n\n  TypeLocClass getTypeLocClass() const {\n    return (TypeLocClass) getTypePtr()->getTypeClass();\n  }\n\nprivate:\n  friend class TypeLoc;\n\n  static bool isKind(const TypeLoc &TL) {\n    return !TL.getType().hasLocalQualifiers();\n  }\n};\n\n/// Wrapper of type source information for a type with\n/// non-trivial direct qualifiers.\n///\n/// Currently, we intentionally do not provide source location for\n/// type qualifiers.\nclass QualifiedTypeLoc : public TypeLoc {\npublic:\n  SourceRange getLocalSourceRange() const { return {}; }\n\n  UnqualTypeLoc getUnqualifiedLoc() const {\n    unsigned align =\n        TypeLoc::getLocalAlignmentForType(QualType(getTypePtr(), 0));\n    auto dataInt = reinterpret_cast<uintptr_t>(Data);\n    dataInt = llvm::alignTo(dataInt, align);\n    return UnqualTypeLoc(getTypePtr(), reinterpret_cast<void*>(dataInt));\n  }\n\n  /// Initializes the local data of this type source info block to\n  /// provide no information.\n  void initializeLocal(ASTContext &Context, SourceLocation Loc) {\n    // do nothing\n  }\n\n  void copyLocal(TypeLoc other) {\n    // do nothing\n  }\n\n  TypeLoc getNextTypeLoc() const {\n    return getUnqualifiedLoc();\n  }\n\n  /// Returns the size of the type source info data block that is\n  /// specific to this type.\n  unsigned getLocalDataSize() const {\n    // In fact, we don't currently preserve any location information\n    // for qualifiers.\n    return 0;\n  }\n\n  /// Returns the alignment of the type source info data block that is\n  /// specific to this type.\n  unsigned getLocalDataAlignment() const {\n    // We don't preserve any location information.\n    return 1;\n  }\n\nprivate:\n  friend class TypeLoc;\n\n  static bool isKind(const TypeLoc &TL) {\n    return TL.getType().hasLocalQualifiers();\n  }\n};\n\ninline UnqualTypeLoc TypeLoc::getUnqualifiedLoc() const {\n  if (QualifiedTypeLoc Loc = getAs<QualifiedTypeLoc>())\n    return Loc.getUnqualifiedLoc();\n  return castAs<UnqualTypeLoc>();\n}\n\n/// A metaprogramming base class for TypeLoc classes which correspond\n/// to a particular Type subclass.  It is accepted for a single\n/// TypeLoc class to correspond to multiple Type classes.\n///\n/// \\tparam Base a class from which to derive\n/// \\tparam Derived the class deriving from this one\n/// \\tparam TypeClass the concrete Type subclass associated with this\n///   location type\n/// \\tparam LocalData the structure type of local location data for\n///   this type\n///\n/// TypeLocs with non-constant amounts of local data should override\n/// getExtraLocalDataSize(); getExtraLocalData() will then point to\n/// this extra memory.\n///\n/// TypeLocs with an inner type should define\n///   QualType getInnerType() const\n/// and getInnerTypeLoc() will then point to this inner type's\n/// location data.\n///\n/// A word about hierarchies: this template is not designed to be\n/// derived from multiple times in a hierarchy.  It is also not\n/// designed to be used for classes where subtypes might provide\n/// different amounts of source information.  It should be subclassed\n/// only at the deepest portion of the hierarchy where all children\n/// have identical source information; if that's an abstract type,\n/// then further descendents should inherit from\n/// InheritingConcreteTypeLoc instead.\ntemplate <class Base, class Derived, class TypeClass, class LocalData>\nclass ConcreteTypeLoc : public Base {\n  friend class TypeLoc;\n\n  const Derived *asDerived() const {\n    return static_cast<const Derived*>(this);\n  }\n\n  static bool isKind(const TypeLoc &TL) {\n    return !TL.getType().hasLocalQualifiers() &&\n           Derived::classofType(TL.getTypePtr());\n  }\n\n  static bool classofType(const Type *Ty) {\n    return TypeClass::classof(Ty);\n  }\n\npublic:\n  unsigned getLocalDataAlignment() const {\n    return std::max(unsigned(alignof(LocalData)),\n                    asDerived()->getExtraLocalDataAlignment());\n  }\n\n  unsigned getLocalDataSize() const {\n    unsigned size = sizeof(LocalData);\n    unsigned extraAlign = asDerived()->getExtraLocalDataAlignment();\n    size = llvm::alignTo(size, extraAlign);\n    size += asDerived()->getExtraLocalDataSize();\n    return size;\n  }\n\n  void copyLocal(Derived other) {\n    // Some subclasses have no data to copy.\n    if (asDerived()->getLocalDataSize() == 0) return;\n\n    // Copy the fixed-sized local data.\n    memcpy(getLocalData(), other.getLocalData(), sizeof(LocalData));\n\n    // Copy the variable-sized local data. We need to do this\n    // separately because the padding in the source and the padding in\n    // the destination might be different.\n    memcpy(getExtraLocalData(), other.getExtraLocalData(),\n           asDerived()->getExtraLocalDataSize());\n  }\n\n  TypeLoc getNextTypeLoc() const {\n    return getNextTypeLoc(asDerived()->getInnerType());\n  }\n\n  const TypeClass *getTypePtr() const {\n    return cast<TypeClass>(Base::getTypePtr());\n  }\n\nprotected:\n  unsigned getExtraLocalDataSize() const {\n    return 0;\n  }\n\n  unsigned getExtraLocalDataAlignment() const {\n    return 1;\n  }\n\n  LocalData *getLocalData() const {\n    return static_cast<LocalData*>(Base::Data);\n  }\n\n  /// Gets a pointer past the Info structure; useful for classes with\n  /// local data that can't be captured in the Info (e.g. because it's\n  /// of variable size).\n  void *getExtraLocalData() const {\n    unsigned size = sizeof(LocalData);\n    unsigned extraAlign = asDerived()->getExtraLocalDataAlignment();\n    size = llvm::alignTo(size, extraAlign);\n    return reinterpret_cast<char*>(Base::Data) + size;\n  }\n\n  void *getNonLocalData() const {\n    auto data = reinterpret_cast<uintptr_t>(Base::Data);\n    data += asDerived()->getLocalDataSize();\n    data = llvm::alignTo(data, getNextTypeAlign());\n    return reinterpret_cast<void*>(data);\n  }\n\n  struct HasNoInnerType {};\n  HasNoInnerType getInnerType() const { return HasNoInnerType(); }\n\n  TypeLoc getInnerTypeLoc() const {\n    return TypeLoc(asDerived()->getInnerType(), getNonLocalData());\n  }\n\nprivate:\n  unsigned getInnerTypeSize() const {\n    return getInnerTypeSize(asDerived()->getInnerType());\n  }\n\n  unsigned getInnerTypeSize(HasNoInnerType _) const {\n    return 0;\n  }\n\n  unsigned getInnerTypeSize(QualType _) const {\n    return getInnerTypeLoc().getFullDataSize();\n  }\n\n  unsigned getNextTypeAlign() const {\n    return getNextTypeAlign(asDerived()->getInnerType());\n  }\n\n  unsigned getNextTypeAlign(HasNoInnerType _) const {\n    return 1;\n  }\n\n  unsigned getNextTypeAlign(QualType T) const {\n    return TypeLoc::getLocalAlignmentForType(T);\n  }\n\n  TypeLoc getNextTypeLoc(HasNoInnerType _) const { return {}; }\n\n  TypeLoc getNextTypeLoc(QualType T) const {\n    return TypeLoc(T, getNonLocalData());\n  }\n};\n\n/// A metaprogramming class designed for concrete subtypes of abstract\n/// types where all subtypes share equivalently-structured source\n/// information.  See the note on ConcreteTypeLoc.\ntemplate <class Base, class Derived, class TypeClass>\nclass InheritingConcreteTypeLoc : public Base {\n  friend class TypeLoc;\n\n  static bool classofType(const Type *Ty) {\n    return TypeClass::classof(Ty);\n  }\n\n  static bool isKind(const TypeLoc &TL) {\n    return !TL.getType().hasLocalQualifiers() &&\n           Derived::classofType(TL.getTypePtr());\n  }\n  static bool isKind(const UnqualTypeLoc &TL) {\n    return Derived::classofType(TL.getTypePtr());\n  }\n\npublic:\n  const TypeClass *getTypePtr() const {\n    return cast<TypeClass>(Base::getTypePtr());\n  }\n};\n\nstruct TypeSpecLocInfo {\n  SourceLocation NameLoc;\n};\n\n/// A reasonable base class for TypeLocs that correspond to\n/// types that are written as a type-specifier.\nclass TypeSpecTypeLoc : public ConcreteTypeLoc<UnqualTypeLoc,\n                                               TypeSpecTypeLoc,\n                                               Type,\n                                               TypeSpecLocInfo> {\npublic:\n  enum {\n    LocalDataSize = sizeof(TypeSpecLocInfo),\n    LocalDataAlignment = alignof(TypeSpecLocInfo)\n  };\n\n  SourceLocation getNameLoc() const {\n    return this->getLocalData()->NameLoc;\n  }\n\n  void setNameLoc(SourceLocation Loc) {\n    this->getLocalData()->NameLoc = Loc;\n  }\n\n  SourceRange getLocalSourceRange() const {\n    return SourceRange(getNameLoc(), getNameLoc());\n  }\n\n  void initializeLocal(ASTContext &Context, SourceLocation Loc) {\n    setNameLoc(Loc);\n  }\n\nprivate:\n  friend class TypeLoc;\n\n  static bool isKind(const TypeLoc &TL);\n};\n\nstruct BuiltinLocInfo {\n  SourceRange BuiltinRange;\n};\n\n/// Wrapper for source info for builtin types.\nclass BuiltinTypeLoc : public ConcreteTypeLoc<UnqualTypeLoc,\n                                              BuiltinTypeLoc,\n                                              BuiltinType,\n                                              BuiltinLocInfo> {\npublic:\n  SourceLocation getBuiltinLoc() const {\n    return getLocalData()->BuiltinRange.getBegin();\n  }\n\n  void setBuiltinLoc(SourceLocation Loc) {\n    getLocalData()->BuiltinRange = Loc;\n  }\n\n  void expandBuiltinRange(SourceRange Range) {\n    SourceRange &BuiltinRange = getLocalData()->BuiltinRange;\n    if (!BuiltinRange.getBegin().isValid()) {\n      BuiltinRange = Range;\n    } else {\n      BuiltinRange.setBegin(std::min(Range.getBegin(), BuiltinRange.getBegin()));\n      BuiltinRange.setEnd(std::max(Range.getEnd(), BuiltinRange.getEnd()));\n    }\n  }\n\n  SourceLocation getNameLoc() const { return getBuiltinLoc(); }\n\n  WrittenBuiltinSpecs& getWrittenBuiltinSpecs() {\n    return *(static_cast<WrittenBuiltinSpecs*>(getExtraLocalData()));\n  }\n  const WrittenBuiltinSpecs& getWrittenBuiltinSpecs() const {\n    return *(static_cast<WrittenBuiltinSpecs*>(getExtraLocalData()));\n  }\n\n  bool needsExtraLocalData() const {\n    BuiltinType::Kind bk = getTypePtr()->getKind();\n    return (bk >= BuiltinType::UShort && bk <= BuiltinType::UInt128)\n      || (bk >= BuiltinType::Short && bk <= BuiltinType::Float128)\n      || bk == BuiltinType::UChar\n      || bk == BuiltinType::SChar;\n  }\n\n  unsigned getExtraLocalDataSize() const {\n    return needsExtraLocalData() ? sizeof(WrittenBuiltinSpecs) : 0;\n  }\n\n  unsigned getExtraLocalDataAlignment() const {\n    return needsExtraLocalData() ? alignof(WrittenBuiltinSpecs) : 1;\n  }\n\n  SourceRange getLocalSourceRange() const {\n    return getLocalData()->BuiltinRange;\n  }\n\n  TypeSpecifierSign getWrittenSignSpec() const {\n    if (needsExtraLocalData())\n      return static_cast<TypeSpecifierSign>(getWrittenBuiltinSpecs().Sign);\n    else\n      return TypeSpecifierSign::Unspecified;\n  }\n\n  bool hasWrittenSignSpec() const {\n    return getWrittenSignSpec() != TypeSpecifierSign::Unspecified;\n  }\n\n  void setWrittenSignSpec(TypeSpecifierSign written) {\n    if (needsExtraLocalData())\n      getWrittenBuiltinSpecs().Sign = static_cast<unsigned>(written);\n  }\n\n  TypeSpecifierWidth getWrittenWidthSpec() const {\n    if (needsExtraLocalData())\n      return static_cast<TypeSpecifierWidth>(getWrittenBuiltinSpecs().Width);\n    else\n      return TypeSpecifierWidth::Unspecified;\n  }\n\n  bool hasWrittenWidthSpec() const {\n    return getWrittenWidthSpec() != TypeSpecifierWidth::Unspecified;\n  }\n\n  void setWrittenWidthSpec(TypeSpecifierWidth written) {\n    if (needsExtraLocalData())\n      getWrittenBuiltinSpecs().Width = static_cast<unsigned>(written);\n  }\n\n  TypeSpecifierType getWrittenTypeSpec() const;\n\n  bool hasWrittenTypeSpec() const {\n    return getWrittenTypeSpec() != TST_unspecified;\n  }\n\n  void setWrittenTypeSpec(TypeSpecifierType written) {\n    if (needsExtraLocalData())\n      getWrittenBuiltinSpecs().Type = written;\n  }\n\n  bool hasModeAttr() const {\n    if (needsExtraLocalData())\n      return getWrittenBuiltinSpecs().ModeAttr;\n    else\n      return false;\n  }\n\n  void setModeAttr(bool written) {\n    if (needsExtraLocalData())\n      getWrittenBuiltinSpecs().ModeAttr = written;\n  }\n\n  void initializeLocal(ASTContext &Context, SourceLocation Loc) {\n    setBuiltinLoc(Loc);\n    if (needsExtraLocalData()) {\n      WrittenBuiltinSpecs &wbs = getWrittenBuiltinSpecs();\n      wbs.Sign = static_cast<unsigned>(TypeSpecifierSign::Unspecified);\n      wbs.Width = static_cast<unsigned>(TypeSpecifierWidth::Unspecified);\n      wbs.Type = TST_unspecified;\n      wbs.ModeAttr = false;\n    }\n  }\n};\n\n/// Wrapper for source info for typedefs.\nclass TypedefTypeLoc : public InheritingConcreteTypeLoc<TypeSpecTypeLoc,\n                                                        TypedefTypeLoc,\n                                                        TypedefType> {\npublic:\n  TypedefNameDecl *getTypedefNameDecl() const {\n    return getTypePtr()->getDecl();\n  }\n};\n\n/// Wrapper for source info for injected class names of class\n/// templates.\nclass InjectedClassNameTypeLoc :\n    public InheritingConcreteTypeLoc<TypeSpecTypeLoc,\n                                     InjectedClassNameTypeLoc,\n                                     InjectedClassNameType> {\npublic:\n  CXXRecordDecl *getDecl() const {\n    return getTypePtr()->getDecl();\n  }\n};\n\n/// Wrapper for source info for unresolved typename using decls.\nclass UnresolvedUsingTypeLoc :\n    public InheritingConcreteTypeLoc<TypeSpecTypeLoc,\n                                     UnresolvedUsingTypeLoc,\n                                     UnresolvedUsingType> {\npublic:\n  UnresolvedUsingTypenameDecl *getDecl() const {\n    return getTypePtr()->getDecl();\n  }\n};\n\n/// Wrapper for source info for tag types.  Note that this only\n/// records source info for the name itself; a type written 'struct foo'\n/// should be represented as an ElaboratedTypeLoc.  We currently\n/// only do that when C++ is enabled because of the expense of\n/// creating an ElaboratedType node for so many type references in C.\nclass TagTypeLoc : public InheritingConcreteTypeLoc<TypeSpecTypeLoc,\n                                                    TagTypeLoc,\n                                                    TagType> {\npublic:\n  TagDecl *getDecl() const { return getTypePtr()->getDecl(); }\n\n  /// True if the tag was defined in this type specifier.\n  bool isDefinition() const;\n};\n\n/// Wrapper for source info for record types.\nclass RecordTypeLoc : public InheritingConcreteTypeLoc<TagTypeLoc,\n                                                       RecordTypeLoc,\n                                                       RecordType> {\npublic:\n  RecordDecl *getDecl() const { return getTypePtr()->getDecl(); }\n};\n\n/// Wrapper for source info for enum types.\nclass EnumTypeLoc : public InheritingConcreteTypeLoc<TagTypeLoc,\n                                                     EnumTypeLoc,\n                                                     EnumType> {\npublic:\n  EnumDecl *getDecl() const { return getTypePtr()->getDecl(); }\n};\n\n/// Wrapper for template type parameters.\nclass TemplateTypeParmTypeLoc :\n    public InheritingConcreteTypeLoc<TypeSpecTypeLoc,\n                                     TemplateTypeParmTypeLoc,\n                                     TemplateTypeParmType> {\npublic:\n  TemplateTypeParmDecl *getDecl() const { return getTypePtr()->getDecl(); }\n};\n\nstruct ObjCTypeParamTypeLocInfo {\n  SourceLocation NameLoc;\n};\n\n/// ProtocolLAngleLoc, ProtocolRAngleLoc, and the source locations for\n/// protocol qualifiers are stored after Info.\nclass ObjCTypeParamTypeLoc : public ConcreteTypeLoc<UnqualTypeLoc,\n                                     ObjCTypeParamTypeLoc,\n                                     ObjCTypeParamType,\n                                     ObjCTypeParamTypeLocInfo> {\n  // SourceLocations are stored after Info, one for each protocol qualifier.\n  SourceLocation *getProtocolLocArray() const {\n    return (SourceLocation*)this->getExtraLocalData() + 2;\n  }\n\npublic:\n  ObjCTypeParamDecl *getDecl() const { return getTypePtr()->getDecl(); }\n\n  SourceLocation getNameLoc() const {\n    return this->getLocalData()->NameLoc;\n  }\n\n  void setNameLoc(SourceLocation Loc) {\n    this->getLocalData()->NameLoc = Loc;\n  }\n\n  SourceLocation getProtocolLAngleLoc() const {\n    return getNumProtocols()  ?\n      *((SourceLocation*)this->getExtraLocalData()) :\n      SourceLocation();\n  }\n\n  void setProtocolLAngleLoc(SourceLocation Loc) {\n    *((SourceLocation*)this->getExtraLocalData()) = Loc;\n  }\n\n  SourceLocation getProtocolRAngleLoc() const {\n    return getNumProtocols()  ?\n      *((SourceLocation*)this->getExtraLocalData() + 1) :\n      SourceLocation();\n  }\n\n  void setProtocolRAngleLoc(SourceLocation Loc) {\n    *((SourceLocation*)this->getExtraLocalData() + 1) = Loc;\n  }\n\n  unsigned getNumProtocols() const {\n    return this->getTypePtr()->getNumProtocols();\n  }\n\n  SourceLocation getProtocolLoc(unsigned i) const {\n    assert(i < getNumProtocols() && \"Index is out of bounds!\");\n    return getProtocolLocArray()[i];\n  }\n\n  void setProtocolLoc(unsigned i, SourceLocation Loc) {\n    assert(i < getNumProtocols() && \"Index is out of bounds!\");\n    getProtocolLocArray()[i] = Loc;\n  }\n\n  ObjCProtocolDecl *getProtocol(unsigned i) const {\n    assert(i < getNumProtocols() && \"Index is out of bounds!\");\n    return *(this->getTypePtr()->qual_begin() + i);\n  }\n\n  ArrayRef<SourceLocation> getProtocolLocs() const {\n    return llvm::makeArrayRef(getProtocolLocArray(), getNumProtocols());\n  }\n\n  void initializeLocal(ASTContext &Context, SourceLocation Loc);\n\n  unsigned getExtraLocalDataSize() const {\n    if (!this->getNumProtocols()) return 0;\n    // When there are protocol qualifers, we have LAngleLoc and RAngleLoc\n    // as well.\n    return (this->getNumProtocols() + 2) * sizeof(SourceLocation) ;\n  }\n\n  unsigned getExtraLocalDataAlignment() const {\n    return alignof(SourceLocation);\n  }\n\n  SourceRange getLocalSourceRange() const {\n    SourceLocation start = getNameLoc();\n    SourceLocation end = getProtocolRAngleLoc();\n    if (end.isInvalid()) return SourceRange(start, start);\n    return SourceRange(start, end);\n  }\n};\n\n/// Wrapper for substituted template type parameters.\nclass SubstTemplateTypeParmTypeLoc :\n    public InheritingConcreteTypeLoc<TypeSpecTypeLoc,\n                                     SubstTemplateTypeParmTypeLoc,\n                                     SubstTemplateTypeParmType> {\n};\n\n  /// Wrapper for substituted template type parameters.\nclass SubstTemplateTypeParmPackTypeLoc :\n    public InheritingConcreteTypeLoc<TypeSpecTypeLoc,\n                                     SubstTemplateTypeParmPackTypeLoc,\n                                     SubstTemplateTypeParmPackType> {\n};\n\nstruct AttributedLocInfo {\n  const Attr *TypeAttr;\n};\n\n/// Type source information for an attributed type.\nclass AttributedTypeLoc : public ConcreteTypeLoc<UnqualTypeLoc,\n                                                 AttributedTypeLoc,\n                                                 AttributedType,\n                                                 AttributedLocInfo> {\npublic:\n  attr::Kind getAttrKind() const {\n    return getTypePtr()->getAttrKind();\n  }\n\n  bool isQualifier() const {\n    return getTypePtr()->isQualifier();\n  }\n\n  /// The modified type, which is generally canonically different from\n  /// the attribute type.\n  ///    int main(int, char**) __attribute__((noreturn))\n  ///    ~~~     ~~~~~~~~~~~~~\n  TypeLoc getModifiedLoc() const {\n    return getInnerTypeLoc();\n  }\n\n  /// The type attribute.\n  const Attr *getAttr() const {\n    return getLocalData()->TypeAttr;\n  }\n  void setAttr(const Attr *A) {\n    getLocalData()->TypeAttr = A;\n  }\n\n  template<typename T> const T *getAttrAs() {\n    return dyn_cast_or_null<T>(getAttr());\n  }\n\n  SourceRange getLocalSourceRange() const;\n\n  void initializeLocal(ASTContext &Context, SourceLocation loc) {\n    setAttr(nullptr);\n  }\n\n  QualType getInnerType() const {\n    return getTypePtr()->getModifiedType();\n  }\n};\n\nstruct ObjCObjectTypeLocInfo {\n  SourceLocation TypeArgsLAngleLoc;\n  SourceLocation TypeArgsRAngleLoc;\n  SourceLocation ProtocolLAngleLoc;\n  SourceLocation ProtocolRAngleLoc;\n  bool HasBaseTypeAsWritten;\n};\n\n// A helper class for defining ObjC TypeLocs that can qualified with\n// protocols.\n//\n// TypeClass basically has to be either ObjCInterfaceType or\n// ObjCObjectPointerType.\nclass ObjCObjectTypeLoc : public ConcreteTypeLoc<UnqualTypeLoc,\n                                                 ObjCObjectTypeLoc,\n                                                 ObjCObjectType,\n                                                 ObjCObjectTypeLocInfo> {\n  // TypeSourceInfo*'s are stored after Info, one for each type argument.\n  TypeSourceInfo **getTypeArgLocArray() const {\n    return (TypeSourceInfo**)this->getExtraLocalData();\n  }\n\n  // SourceLocations are stored after the type argument information, one for\n  // each Protocol.\n  SourceLocation *getProtocolLocArray() const {\n    return (SourceLocation*)(getTypeArgLocArray() + getNumTypeArgs());\n  }\n\npublic:\n  SourceLocation getTypeArgsLAngleLoc() const {\n    return this->getLocalData()->TypeArgsLAngleLoc;\n  }\n\n  void setTypeArgsLAngleLoc(SourceLocation Loc) {\n    this->getLocalData()->TypeArgsLAngleLoc = Loc;\n  }\n\n  SourceLocation getTypeArgsRAngleLoc() const {\n    return this->getLocalData()->TypeArgsRAngleLoc;\n  }\n\n  void setTypeArgsRAngleLoc(SourceLocation Loc) {\n    this->getLocalData()->TypeArgsRAngleLoc = Loc;\n  }\n\n  unsigned getNumTypeArgs() const {\n    return this->getTypePtr()->getTypeArgsAsWritten().size();\n  }\n\n  TypeSourceInfo *getTypeArgTInfo(unsigned i) const {\n    assert(i < getNumTypeArgs() && \"Index is out of bounds!\");\n    return getTypeArgLocArray()[i];\n  }\n\n  void setTypeArgTInfo(unsigned i, TypeSourceInfo *TInfo) {\n    assert(i < getNumTypeArgs() && \"Index is out of bounds!\");\n    getTypeArgLocArray()[i] = TInfo;\n  }\n\n  SourceLocation getProtocolLAngleLoc() const {\n    return this->getLocalData()->ProtocolLAngleLoc;\n  }\n\n  void setProtocolLAngleLoc(SourceLocation Loc) {\n    this->getLocalData()->ProtocolLAngleLoc = Loc;\n  }\n\n  SourceLocation getProtocolRAngleLoc() const {\n    return this->getLocalData()->ProtocolRAngleLoc;\n  }\n\n  void setProtocolRAngleLoc(SourceLocation Loc) {\n    this->getLocalData()->ProtocolRAngleLoc = Loc;\n  }\n\n  unsigned getNumProtocols() const {\n    return this->getTypePtr()->getNumProtocols();\n  }\n\n  SourceLocation getProtocolLoc(unsigned i) const {\n    assert(i < getNumProtocols() && \"Index is out of bounds!\");\n    return getProtocolLocArray()[i];\n  }\n\n  void setProtocolLoc(unsigned i, SourceLocation Loc) {\n    assert(i < getNumProtocols() && \"Index is out of bounds!\");\n    getProtocolLocArray()[i] = Loc;\n  }\n\n  ObjCProtocolDecl *getProtocol(unsigned i) const {\n    assert(i < getNumProtocols() && \"Index is out of bounds!\");\n    return *(this->getTypePtr()->qual_begin() + i);\n  }\n\n\n  ArrayRef<SourceLocation> getProtocolLocs() const {\n    return llvm::makeArrayRef(getProtocolLocArray(), getNumProtocols());\n  }\n\n  bool hasBaseTypeAsWritten() const {\n    return getLocalData()->HasBaseTypeAsWritten;\n  }\n\n  void setHasBaseTypeAsWritten(bool HasBaseType) {\n    getLocalData()->HasBaseTypeAsWritten = HasBaseType;\n  }\n\n  TypeLoc getBaseLoc() const {\n    return getInnerTypeLoc();\n  }\n\n  SourceRange getLocalSourceRange() const {\n    SourceLocation start = getTypeArgsLAngleLoc();\n    if (start.isInvalid())\n      start = getProtocolLAngleLoc();\n    SourceLocation end = getProtocolRAngleLoc();\n    if (end.isInvalid())\n      end = getTypeArgsRAngleLoc();\n    return SourceRange(start, end);\n  }\n\n  void initializeLocal(ASTContext &Context, SourceLocation Loc);\n\n  unsigned getExtraLocalDataSize() const {\n    return this->getNumTypeArgs() * sizeof(TypeSourceInfo *)\n         + this->getNumProtocols() * sizeof(SourceLocation);\n  }\n\n  unsigned getExtraLocalDataAlignment() const {\n    static_assert(alignof(ObjCObjectTypeLoc) >= alignof(TypeSourceInfo *),\n                  \"not enough alignment for tail-allocated data\");\n    return alignof(TypeSourceInfo *);\n  }\n\n  QualType getInnerType() const {\n    return getTypePtr()->getBaseType();\n  }\n};\n\nstruct ObjCInterfaceLocInfo {\n  SourceLocation NameLoc;\n  SourceLocation NameEndLoc;\n};\n\n/// Wrapper for source info for ObjC interfaces.\nclass ObjCInterfaceTypeLoc : public ConcreteTypeLoc<ObjCObjectTypeLoc,\n                                                    ObjCInterfaceTypeLoc,\n                                                    ObjCInterfaceType,\n                                                    ObjCInterfaceLocInfo> {\npublic:\n  ObjCInterfaceDecl *getIFaceDecl() const {\n    return getTypePtr()->getDecl();\n  }\n\n  SourceLocation getNameLoc() const {\n    return getLocalData()->NameLoc;\n  }\n\n  void setNameLoc(SourceLocation Loc) {\n    getLocalData()->NameLoc = Loc;\n  }\n\n  SourceRange getLocalSourceRange() const {\n    return SourceRange(getNameLoc(), getNameEndLoc());\n  }\n\n  SourceLocation getNameEndLoc() const {\n    return getLocalData()->NameEndLoc;\n  }\n\n  void setNameEndLoc(SourceLocation Loc) {\n    getLocalData()->NameEndLoc = Loc;\n  }\n\n  void initializeLocal(ASTContext &Context, SourceLocation Loc) {\n    setNameLoc(Loc);\n    setNameEndLoc(Loc);\n  }\n};\n\nstruct MacroQualifiedLocInfo {\n  SourceLocation ExpansionLoc;\n};\n\nclass MacroQualifiedTypeLoc\n    : public ConcreteTypeLoc<UnqualTypeLoc, MacroQualifiedTypeLoc,\n                             MacroQualifiedType, MacroQualifiedLocInfo> {\npublic:\n  void initializeLocal(ASTContext &Context, SourceLocation Loc) {\n    setExpansionLoc(Loc);\n  }\n\n  TypeLoc getInnerLoc() const { return getInnerTypeLoc(); }\n\n  const IdentifierInfo *getMacroIdentifier() const {\n    return getTypePtr()->getMacroIdentifier();\n  }\n\n  SourceLocation getExpansionLoc() const {\n    return this->getLocalData()->ExpansionLoc;\n  }\n\n  void setExpansionLoc(SourceLocation Loc) {\n    this->getLocalData()->ExpansionLoc = Loc;\n  }\n\n  QualType getInnerType() const { return getTypePtr()->getUnderlyingType(); }\n\n  SourceRange getLocalSourceRange() const {\n    return getInnerLoc().getLocalSourceRange();\n  }\n};\n\nstruct ParenLocInfo {\n  SourceLocation LParenLoc;\n  SourceLocation RParenLoc;\n};\n\nclass ParenTypeLoc\n  : public ConcreteTypeLoc<UnqualTypeLoc, ParenTypeLoc, ParenType,\n                           ParenLocInfo> {\npublic:\n  SourceLocation getLParenLoc() const {\n    return this->getLocalData()->LParenLoc;\n  }\n\n  SourceLocation getRParenLoc() const {\n    return this->getLocalData()->RParenLoc;\n  }\n\n  void setLParenLoc(SourceLocation Loc) {\n    this->getLocalData()->LParenLoc = Loc;\n  }\n\n  void setRParenLoc(SourceLocation Loc) {\n    this->getLocalData()->RParenLoc = Loc;\n  }\n\n  SourceRange getLocalSourceRange() const {\n    return SourceRange(getLParenLoc(), getRParenLoc());\n  }\n\n  void initializeLocal(ASTContext &Context, SourceLocation Loc) {\n    setLParenLoc(Loc);\n    setRParenLoc(Loc);\n  }\n\n  TypeLoc getInnerLoc() const {\n    return getInnerTypeLoc();\n  }\n\n  QualType getInnerType() const {\n    return this->getTypePtr()->getInnerType();\n  }\n};\n\ninline TypeLoc TypeLoc::IgnoreParens() const {\n  if (ParenTypeLoc::isKind(*this))\n    return IgnoreParensImpl(*this);\n  return *this;\n}\n\nstruct AdjustedLocInfo {}; // Nothing.\n\nclass AdjustedTypeLoc : public ConcreteTypeLoc<UnqualTypeLoc, AdjustedTypeLoc,\n                                               AdjustedType, AdjustedLocInfo> {\npublic:\n  TypeLoc getOriginalLoc() const {\n    return getInnerTypeLoc();\n  }\n\n  void initializeLocal(ASTContext &Context, SourceLocation Loc) {\n    // do nothing\n  }\n\n  QualType getInnerType() const {\n    // The inner type is the undecayed type, since that's what we have source\n    // location information for.\n    return getTypePtr()->getOriginalType();\n  }\n\n  SourceRange getLocalSourceRange() const { return {}; }\n\n  unsigned getLocalDataSize() const {\n    // sizeof(AdjustedLocInfo) is 1, but we don't need its address to be unique\n    // anyway.  TypeLocBuilder can't handle data sizes of 1.\n    return 0;  // No data.\n  }\n};\n\n/// Wrapper for source info for pointers decayed from arrays and\n/// functions.\nclass DecayedTypeLoc : public InheritingConcreteTypeLoc<\n                           AdjustedTypeLoc, DecayedTypeLoc, DecayedType> {\n};\n\nstruct PointerLikeLocInfo {\n  SourceLocation StarLoc;\n};\n\n/// A base class for\ntemplate <class Derived, class TypeClass, class LocalData = PointerLikeLocInfo>\nclass PointerLikeTypeLoc : public ConcreteTypeLoc<UnqualTypeLoc, Derived,\n                                                  TypeClass, LocalData> {\npublic:\n  SourceLocation getSigilLoc() const {\n    return this->getLocalData()->StarLoc;\n  }\n\n  void setSigilLoc(SourceLocation Loc) {\n    this->getLocalData()->StarLoc = Loc;\n  }\n\n  TypeLoc getPointeeLoc() const {\n    return this->getInnerTypeLoc();\n  }\n\n  SourceRange getLocalSourceRange() const {\n    return SourceRange(getSigilLoc(), getSigilLoc());\n  }\n\n  void initializeLocal(ASTContext &Context, SourceLocation Loc) {\n    setSigilLoc(Loc);\n  }\n\n  QualType getInnerType() const {\n    return this->getTypePtr()->getPointeeType();\n  }\n};\n\n/// Wrapper for source info for pointers.\nclass PointerTypeLoc : public PointerLikeTypeLoc<PointerTypeLoc,\n                                                 PointerType> {\npublic:\n  SourceLocation getStarLoc() const {\n    return getSigilLoc();\n  }\n\n  void setStarLoc(SourceLocation Loc) {\n    setSigilLoc(Loc);\n  }\n};\n\n/// Wrapper for source info for block pointers.\nclass BlockPointerTypeLoc : public PointerLikeTypeLoc<BlockPointerTypeLoc,\n                                                      BlockPointerType> {\npublic:\n  SourceLocation getCaretLoc() const {\n    return getSigilLoc();\n  }\n\n  void setCaretLoc(SourceLocation Loc) {\n    setSigilLoc(Loc);\n  }\n};\n\nstruct MemberPointerLocInfo : public PointerLikeLocInfo {\n  TypeSourceInfo *ClassTInfo;\n};\n\n/// Wrapper for source info for member pointers.\nclass MemberPointerTypeLoc : public PointerLikeTypeLoc<MemberPointerTypeLoc,\n                                                       MemberPointerType,\n                                                       MemberPointerLocInfo> {\npublic:\n  SourceLocation getStarLoc() const {\n    return getSigilLoc();\n  }\n\n  void setStarLoc(SourceLocation Loc) {\n    setSigilLoc(Loc);\n  }\n\n  const Type *getClass() const {\n    return getTypePtr()->getClass();\n  }\n\n  TypeSourceInfo *getClassTInfo() const {\n    return getLocalData()->ClassTInfo;\n  }\n\n  void setClassTInfo(TypeSourceInfo* TI) {\n    getLocalData()->ClassTInfo = TI;\n  }\n\n  void initializeLocal(ASTContext &Context, SourceLocation Loc) {\n    setSigilLoc(Loc);\n    setClassTInfo(nullptr);\n  }\n\n  SourceRange getLocalSourceRange() const {\n    if (TypeSourceInfo *TI = getClassTInfo())\n      return SourceRange(TI->getTypeLoc().getBeginLoc(), getStarLoc());\n    else\n      return SourceRange(getStarLoc());\n  }\n};\n\n/// Wraps an ObjCPointerType with source location information.\nclass ObjCObjectPointerTypeLoc :\n    public PointerLikeTypeLoc<ObjCObjectPointerTypeLoc,\n                              ObjCObjectPointerType> {\npublic:\n  SourceLocation getStarLoc() const {\n    return getSigilLoc();\n  }\n\n  void setStarLoc(SourceLocation Loc) {\n    setSigilLoc(Loc);\n  }\n};\n\nclass ReferenceTypeLoc : public PointerLikeTypeLoc<ReferenceTypeLoc,\n                                                   ReferenceType> {\npublic:\n  QualType getInnerType() const {\n    return getTypePtr()->getPointeeTypeAsWritten();\n  }\n};\n\nclass LValueReferenceTypeLoc :\n    public InheritingConcreteTypeLoc<ReferenceTypeLoc,\n                                     LValueReferenceTypeLoc,\n                                     LValueReferenceType> {\npublic:\n  SourceLocation getAmpLoc() const {\n    return getSigilLoc();\n  }\n\n  void setAmpLoc(SourceLocation Loc) {\n    setSigilLoc(Loc);\n  }\n};\n\nclass RValueReferenceTypeLoc :\n    public InheritingConcreteTypeLoc<ReferenceTypeLoc,\n                                     RValueReferenceTypeLoc,\n                                     RValueReferenceType> {\npublic:\n  SourceLocation getAmpAmpLoc() const {\n    return getSigilLoc();\n  }\n\n  void setAmpAmpLoc(SourceLocation Loc) {\n    setSigilLoc(Loc);\n  }\n};\n\nstruct FunctionLocInfo {\n  SourceLocation LocalRangeBegin;\n  SourceLocation LParenLoc;\n  SourceLocation RParenLoc;\n  SourceLocation LocalRangeEnd;\n};\n\n/// Wrapper for source info for functions.\nclass FunctionTypeLoc : public ConcreteTypeLoc<UnqualTypeLoc,\n                                               FunctionTypeLoc,\n                                               FunctionType,\n                                               FunctionLocInfo> {\n  bool hasExceptionSpec() const {\n    if (auto *FPT = dyn_cast<FunctionProtoType>(getTypePtr())) {\n      return FPT->hasExceptionSpec();\n    }\n    return false;\n  }\n\n  SourceRange *getExceptionSpecRangePtr() const {\n    assert(hasExceptionSpec() && \"No exception spec range\");\n    // After the Info comes the ParmVarDecl array, and after that comes the\n    // exception specification information.\n    return (SourceRange *)(getParmArray() + getNumParams());\n  }\n\npublic:\n  SourceLocation getLocalRangeBegin() const {\n    return getLocalData()->LocalRangeBegin;\n  }\n\n  void setLocalRangeBegin(SourceLocation L) {\n    getLocalData()->LocalRangeBegin = L;\n  }\n\n  SourceLocation getLocalRangeEnd() const {\n    return getLocalData()->LocalRangeEnd;\n  }\n\n  void setLocalRangeEnd(SourceLocation L) {\n    getLocalData()->LocalRangeEnd = L;\n  }\n\n  SourceLocation getLParenLoc() const {\n    return this->getLocalData()->LParenLoc;\n  }\n\n  void setLParenLoc(SourceLocation Loc) {\n    this->getLocalData()->LParenLoc = Loc;\n  }\n\n  SourceLocation getRParenLoc() const {\n    return this->getLocalData()->RParenLoc;\n  }\n\n  void setRParenLoc(SourceLocation Loc) {\n    this->getLocalData()->RParenLoc = Loc;\n  }\n\n  SourceRange getParensRange() const {\n    return SourceRange(getLParenLoc(), getRParenLoc());\n  }\n\n  SourceRange getExceptionSpecRange() const {\n    if (hasExceptionSpec())\n      return *getExceptionSpecRangePtr();\n    return {};\n  }\n\n  void setExceptionSpecRange(SourceRange R) {\n    if (hasExceptionSpec())\n      *getExceptionSpecRangePtr() = R;\n  }\n\n  ArrayRef<ParmVarDecl *> getParams() const {\n    return llvm::makeArrayRef(getParmArray(), getNumParams());\n  }\n\n  // ParmVarDecls* are stored after Info, one for each parameter.\n  ParmVarDecl **getParmArray() const {\n    return (ParmVarDecl**) getExtraLocalData();\n  }\n\n  unsigned getNumParams() const {\n    if (isa<FunctionNoProtoType>(getTypePtr()))\n      return 0;\n    return cast<FunctionProtoType>(getTypePtr())->getNumParams();\n  }\n\n  ParmVarDecl *getParam(unsigned i) const { return getParmArray()[i]; }\n  void setParam(unsigned i, ParmVarDecl *VD) { getParmArray()[i] = VD; }\n\n  TypeLoc getReturnLoc() const {\n    return getInnerTypeLoc();\n  }\n\n  SourceRange getLocalSourceRange() const {\n    return SourceRange(getLocalRangeBegin(), getLocalRangeEnd());\n  }\n\n  void initializeLocal(ASTContext &Context, SourceLocation Loc) {\n    setLocalRangeBegin(Loc);\n    setLParenLoc(Loc);\n    setRParenLoc(Loc);\n    setLocalRangeEnd(Loc);\n    for (unsigned i = 0, e = getNumParams(); i != e; ++i)\n      setParam(i, nullptr);\n    if (hasExceptionSpec())\n      setExceptionSpecRange(Loc);\n  }\n\n  /// Returns the size of the type source info data block that is\n  /// specific to this type.\n  unsigned getExtraLocalDataSize() const {\n    unsigned ExceptSpecSize = hasExceptionSpec() ? sizeof(SourceRange) : 0;\n    return (getNumParams() * sizeof(ParmVarDecl *)) + ExceptSpecSize;\n  }\n\n  unsigned getExtraLocalDataAlignment() const { return alignof(ParmVarDecl *); }\n\n  QualType getInnerType() const { return getTypePtr()->getReturnType(); }\n};\n\nclass FunctionProtoTypeLoc :\n    public InheritingConcreteTypeLoc<FunctionTypeLoc,\n                                     FunctionProtoTypeLoc,\n                                     FunctionProtoType> {\n};\n\nclass FunctionNoProtoTypeLoc :\n    public InheritingConcreteTypeLoc<FunctionTypeLoc,\n                                     FunctionNoProtoTypeLoc,\n                                     FunctionNoProtoType> {\n};\n\nstruct ArrayLocInfo {\n  SourceLocation LBracketLoc, RBracketLoc;\n  Expr *Size;\n};\n\n/// Wrapper for source info for arrays.\nclass ArrayTypeLoc : public ConcreteTypeLoc<UnqualTypeLoc,\n                                            ArrayTypeLoc,\n                                            ArrayType,\n                                            ArrayLocInfo> {\npublic:\n  SourceLocation getLBracketLoc() const {\n    return getLocalData()->LBracketLoc;\n  }\n\n  void setLBracketLoc(SourceLocation Loc) {\n    getLocalData()->LBracketLoc = Loc;\n  }\n\n  SourceLocation getRBracketLoc() const {\n    return getLocalData()->RBracketLoc;\n  }\n\n  void setRBracketLoc(SourceLocation Loc) {\n    getLocalData()->RBracketLoc = Loc;\n  }\n\n  SourceRange getBracketsRange() const {\n    return SourceRange(getLBracketLoc(), getRBracketLoc());\n  }\n\n  Expr *getSizeExpr() const {\n    return getLocalData()->Size;\n  }\n\n  void setSizeExpr(Expr *Size) {\n    getLocalData()->Size = Size;\n  }\n\n  TypeLoc getElementLoc() const {\n    return getInnerTypeLoc();\n  }\n\n  SourceRange getLocalSourceRange() const {\n    return SourceRange(getLBracketLoc(), getRBracketLoc());\n  }\n\n  void initializeLocal(ASTContext &Context, SourceLocation Loc) {\n    setLBracketLoc(Loc);\n    setRBracketLoc(Loc);\n    setSizeExpr(nullptr);\n  }\n\n  QualType getInnerType() const { return getTypePtr()->getElementType(); }\n};\n\nclass ConstantArrayTypeLoc :\n    public InheritingConcreteTypeLoc<ArrayTypeLoc,\n                                     ConstantArrayTypeLoc,\n                                     ConstantArrayType> {\n};\n\nclass IncompleteArrayTypeLoc :\n    public InheritingConcreteTypeLoc<ArrayTypeLoc,\n                                     IncompleteArrayTypeLoc,\n                                     IncompleteArrayType> {\n};\n\nclass DependentSizedArrayTypeLoc :\n    public InheritingConcreteTypeLoc<ArrayTypeLoc,\n                                     DependentSizedArrayTypeLoc,\n                                     DependentSizedArrayType> {\npublic:\n  void initializeLocal(ASTContext &Context, SourceLocation Loc) {\n    ArrayTypeLoc::initializeLocal(Context, Loc);\n    setSizeExpr(getTypePtr()->getSizeExpr());\n  }\n};\n\nclass VariableArrayTypeLoc :\n    public InheritingConcreteTypeLoc<ArrayTypeLoc,\n                                     VariableArrayTypeLoc,\n                                     VariableArrayType> {\n};\n\n// Location information for a TemplateName.  Rudimentary for now.\nstruct TemplateNameLocInfo {\n  SourceLocation NameLoc;\n};\n\nstruct TemplateSpecializationLocInfo : TemplateNameLocInfo {\n  SourceLocation TemplateKWLoc;\n  SourceLocation LAngleLoc;\n  SourceLocation RAngleLoc;\n};\n\nclass TemplateSpecializationTypeLoc :\n    public ConcreteTypeLoc<UnqualTypeLoc,\n                           TemplateSpecializationTypeLoc,\n                           TemplateSpecializationType,\n                           TemplateSpecializationLocInfo> {\npublic:\n  SourceLocation getTemplateKeywordLoc() const {\n    return getLocalData()->TemplateKWLoc;\n  }\n\n  void setTemplateKeywordLoc(SourceLocation Loc) {\n    getLocalData()->TemplateKWLoc = Loc;\n  }\n\n  SourceLocation getLAngleLoc() const {\n    return getLocalData()->LAngleLoc;\n  }\n\n  void setLAngleLoc(SourceLocation Loc) {\n    getLocalData()->LAngleLoc = Loc;\n  }\n\n  SourceLocation getRAngleLoc() const {\n    return getLocalData()->RAngleLoc;\n  }\n\n  void setRAngleLoc(SourceLocation Loc) {\n    getLocalData()->RAngleLoc = Loc;\n  }\n\n  unsigned getNumArgs() const {\n    return getTypePtr()->getNumArgs();\n  }\n\n  void setArgLocInfo(unsigned i, TemplateArgumentLocInfo AI) {\n    getArgInfos()[i] = AI;\n  }\n\n  TemplateArgumentLocInfo getArgLocInfo(unsigned i) const {\n    return getArgInfos()[i];\n  }\n\n  TemplateArgumentLoc getArgLoc(unsigned i) const {\n    return TemplateArgumentLoc(getTypePtr()->getArg(i), getArgLocInfo(i));\n  }\n\n  SourceLocation getTemplateNameLoc() const {\n    return getLocalData()->NameLoc;\n  }\n\n  void setTemplateNameLoc(SourceLocation Loc) {\n    getLocalData()->NameLoc = Loc;\n  }\n\n  /// - Copy the location information from the given info.\n  void copy(TemplateSpecializationTypeLoc Loc) {\n    unsigned size = getFullDataSize();\n    assert(size == Loc.getFullDataSize());\n\n    // We're potentially copying Expr references here.  We don't\n    // bother retaining them because TypeSourceInfos live forever, so\n    // as long as the Expr was retained when originally written into\n    // the TypeLoc, we're okay.\n    memcpy(Data, Loc.Data, size);\n  }\n\n  SourceRange getLocalSourceRange() const {\n    if (getTemplateKeywordLoc().isValid())\n      return SourceRange(getTemplateKeywordLoc(), getRAngleLoc());\n    else\n      return SourceRange(getTemplateNameLoc(), getRAngleLoc());\n  }\n\n  void initializeLocal(ASTContext &Context, SourceLocation Loc) {\n    setTemplateKeywordLoc(Loc);\n    setTemplateNameLoc(Loc);\n    setLAngleLoc(Loc);\n    setRAngleLoc(Loc);\n    initializeArgLocs(Context, getNumArgs(), getTypePtr()->getArgs(),\n                      getArgInfos(), Loc);\n  }\n\n  static void initializeArgLocs(ASTContext &Context, unsigned NumArgs,\n                                const TemplateArgument *Args,\n                                TemplateArgumentLocInfo *ArgInfos,\n                                SourceLocation Loc);\n\n  unsigned getExtraLocalDataSize() const {\n    return getNumArgs() * sizeof(TemplateArgumentLocInfo);\n  }\n\n  unsigned getExtraLocalDataAlignment() const {\n    return alignof(TemplateArgumentLocInfo);\n  }\n\nprivate:\n  TemplateArgumentLocInfo *getArgInfos() const {\n    return static_cast<TemplateArgumentLocInfo*>(getExtraLocalData());\n  }\n};\n\nstruct DependentAddressSpaceLocInfo {\n  Expr *ExprOperand;\n  SourceRange OperandParens;\n  SourceLocation AttrLoc;\n};\n\nclass DependentAddressSpaceTypeLoc\n    : public ConcreteTypeLoc<UnqualTypeLoc,\n                             DependentAddressSpaceTypeLoc,\n                             DependentAddressSpaceType,\n                             DependentAddressSpaceLocInfo> {\npublic:\n  /// The location of the attribute name, i.e.\n  ///    int * __attribute__((address_space(11)))\n  ///                         ^~~~~~~~~~~~~\n  SourceLocation getAttrNameLoc() const {\n    return getLocalData()->AttrLoc;\n  }\n  void setAttrNameLoc(SourceLocation loc) {\n    getLocalData()->AttrLoc = loc;\n  }\n\n  /// The attribute's expression operand, if it has one.\n  ///    int * __attribute__((address_space(11)))\n  ///                                       ^~\n  Expr *getAttrExprOperand() const {\n    return getLocalData()->ExprOperand;\n  }\n  void setAttrExprOperand(Expr *e) {\n    getLocalData()->ExprOperand = e;\n  }\n\n  /// The location of the parentheses around the operand, if there is\n  /// an operand.\n  ///    int * __attribute__((address_space(11)))\n  ///                                      ^  ^\n  SourceRange getAttrOperandParensRange() const {\n    return getLocalData()->OperandParens;\n  }\n  void setAttrOperandParensRange(SourceRange range) {\n    getLocalData()->OperandParens = range;\n  }\n\n  SourceRange getLocalSourceRange() const {\n    SourceRange range(getAttrNameLoc());\n    range.setEnd(getAttrOperandParensRange().getEnd());\n    return range;\n  }\n\n  ///  Returns the type before the address space attribute application\n  ///  area.\n  ///    int * __attribute__((address_space(11))) *\n  ///    ^   ^\n  QualType getInnerType() const {\n    return this->getTypePtr()->getPointeeType();\n  }\n\n  TypeLoc getPointeeTypeLoc() const {\n    return this->getInnerTypeLoc();\n  }\n\n  void initializeLocal(ASTContext &Context, SourceLocation loc) {\n    setAttrNameLoc(loc);\n    setAttrOperandParensRange(loc);\n    setAttrOperandParensRange(SourceRange(loc));\n    setAttrExprOperand(getTypePtr()->getAddrSpaceExpr());\n  }\n};\n\n//===----------------------------------------------------------------------===//\n//\n//  All of these need proper implementations.\n//\n//===----------------------------------------------------------------------===//\n\n// FIXME: size expression and attribute locations (or keyword if we\n// ever fully support altivec syntax).\nstruct VectorTypeLocInfo {\n  SourceLocation NameLoc;\n};\n\nclass VectorTypeLoc : public ConcreteTypeLoc<UnqualTypeLoc, VectorTypeLoc,\n                                             VectorType, VectorTypeLocInfo> {\npublic:\n  SourceLocation getNameLoc() const { return this->getLocalData()->NameLoc; }\n\n  void setNameLoc(SourceLocation Loc) { this->getLocalData()->NameLoc = Loc; }\n\n  SourceRange getLocalSourceRange() const {\n    return SourceRange(getNameLoc(), getNameLoc());\n  }\n\n  void initializeLocal(ASTContext &Context, SourceLocation Loc) {\n    setNameLoc(Loc);\n  }\n\n  TypeLoc getElementLoc() const { return getInnerTypeLoc(); }\n\n  QualType getInnerType() const { return this->getTypePtr()->getElementType(); }\n};\n\n// FIXME: size expression and attribute locations (or keyword if we\n// ever fully support altivec syntax).\nclass DependentVectorTypeLoc\n    : public ConcreteTypeLoc<UnqualTypeLoc, DependentVectorTypeLoc,\n                             DependentVectorType, VectorTypeLocInfo> {\npublic:\n  SourceLocation getNameLoc() const { return this->getLocalData()->NameLoc; }\n\n  void setNameLoc(SourceLocation Loc) { this->getLocalData()->NameLoc = Loc; }\n\n  SourceRange getLocalSourceRange() const {\n    return SourceRange(getNameLoc(), getNameLoc());\n  }\n\n  void initializeLocal(ASTContext &Context, SourceLocation Loc) {\n    setNameLoc(Loc);\n  }\n\n  TypeLoc getElementLoc() const { return getInnerTypeLoc(); }\n\n  QualType getInnerType() const { return this->getTypePtr()->getElementType(); }\n};\n\n// FIXME: size expression and attribute locations.\nclass ExtVectorTypeLoc\n    : public InheritingConcreteTypeLoc<VectorTypeLoc, ExtVectorTypeLoc,\n                                       ExtVectorType> {};\n\n// FIXME: attribute locations.\n// For some reason, this isn't a subtype of VectorType.\nclass DependentSizedExtVectorTypeLoc\n    : public ConcreteTypeLoc<UnqualTypeLoc, DependentSizedExtVectorTypeLoc,\n                             DependentSizedExtVectorType, VectorTypeLocInfo> {\npublic:\n  SourceLocation getNameLoc() const { return this->getLocalData()->NameLoc; }\n\n  void setNameLoc(SourceLocation Loc) { this->getLocalData()->NameLoc = Loc; }\n\n  SourceRange getLocalSourceRange() const {\n    return SourceRange(getNameLoc(), getNameLoc());\n  }\n\n  void initializeLocal(ASTContext &Context, SourceLocation Loc) {\n    setNameLoc(Loc);\n  }\n\n  TypeLoc getElementLoc() const { return getInnerTypeLoc(); }\n\n  QualType getInnerType() const { return this->getTypePtr()->getElementType(); }\n};\n\nstruct MatrixTypeLocInfo {\n  SourceLocation AttrLoc;\n  SourceRange OperandParens;\n  Expr *RowOperand;\n  Expr *ColumnOperand;\n};\n\nclass MatrixTypeLoc : public ConcreteTypeLoc<UnqualTypeLoc, MatrixTypeLoc,\n                                             MatrixType, MatrixTypeLocInfo> {\npublic:\n  /// The location of the attribute name, i.e.\n  ///    float __attribute__((matrix_type(4, 2)))\n  ///                         ^~~~~~~~~~~~~~~~~\n  SourceLocation getAttrNameLoc() const { return getLocalData()->AttrLoc; }\n  void setAttrNameLoc(SourceLocation loc) { getLocalData()->AttrLoc = loc; }\n\n  /// The attribute's row operand, if it has one.\n  ///    float __attribute__((matrix_type(4, 2)))\n  ///                                     ^\n  Expr *getAttrRowOperand() const { return getLocalData()->RowOperand; }\n  void setAttrRowOperand(Expr *e) { getLocalData()->RowOperand = e; }\n\n  /// The attribute's column operand, if it has one.\n  ///    float __attribute__((matrix_type(4, 2)))\n  ///                                        ^\n  Expr *getAttrColumnOperand() const { return getLocalData()->ColumnOperand; }\n  void setAttrColumnOperand(Expr *e) { getLocalData()->ColumnOperand = e; }\n\n  /// The location of the parentheses around the operand, if there is\n  /// an operand.\n  ///    float __attribute__((matrix_type(4, 2)))\n  ///                                    ^    ^\n  SourceRange getAttrOperandParensRange() const {\n    return getLocalData()->OperandParens;\n  }\n  void setAttrOperandParensRange(SourceRange range) {\n    getLocalData()->OperandParens = range;\n  }\n\n  SourceRange getLocalSourceRange() const {\n    SourceRange range(getAttrNameLoc());\n    range.setEnd(getAttrOperandParensRange().getEnd());\n    return range;\n  }\n\n  void initializeLocal(ASTContext &Context, SourceLocation loc) {\n    setAttrNameLoc(loc);\n    setAttrOperandParensRange(loc);\n    setAttrRowOperand(nullptr);\n    setAttrColumnOperand(nullptr);\n  }\n};\n\nclass ConstantMatrixTypeLoc\n    : public InheritingConcreteTypeLoc<MatrixTypeLoc, ConstantMatrixTypeLoc,\n                                       ConstantMatrixType> {};\n\nclass DependentSizedMatrixTypeLoc\n    : public InheritingConcreteTypeLoc<MatrixTypeLoc,\n                                       DependentSizedMatrixTypeLoc,\n                                       DependentSizedMatrixType> {};\n\n// FIXME: location of the '_Complex' keyword.\nclass ComplexTypeLoc : public InheritingConcreteTypeLoc<TypeSpecTypeLoc,\n                                                        ComplexTypeLoc,\n                                                        ComplexType> {\n};\n\nstruct TypeofLocInfo {\n  SourceLocation TypeofLoc;\n  SourceLocation LParenLoc;\n  SourceLocation RParenLoc;\n};\n\nstruct TypeOfExprTypeLocInfo : public TypeofLocInfo {\n};\n\nstruct TypeOfTypeLocInfo : public TypeofLocInfo {\n  TypeSourceInfo* UnderlyingTInfo;\n};\n\ntemplate <class Derived, class TypeClass, class LocalData = TypeofLocInfo>\nclass TypeofLikeTypeLoc\n  : public ConcreteTypeLoc<UnqualTypeLoc, Derived, TypeClass, LocalData> {\npublic:\n  SourceLocation getTypeofLoc() const {\n    return this->getLocalData()->TypeofLoc;\n  }\n\n  void setTypeofLoc(SourceLocation Loc) {\n    this->getLocalData()->TypeofLoc = Loc;\n  }\n\n  SourceLocation getLParenLoc() const {\n    return this->getLocalData()->LParenLoc;\n  }\n\n  void setLParenLoc(SourceLocation Loc) {\n    this->getLocalData()->LParenLoc = Loc;\n  }\n\n  SourceLocation getRParenLoc() const {\n    return this->getLocalData()->RParenLoc;\n  }\n\n  void setRParenLoc(SourceLocation Loc) {\n    this->getLocalData()->RParenLoc = Loc;\n  }\n\n  SourceRange getParensRange() const {\n    return SourceRange(getLParenLoc(), getRParenLoc());\n  }\n\n  void setParensRange(SourceRange range) {\n      setLParenLoc(range.getBegin());\n      setRParenLoc(range.getEnd());\n  }\n\n  SourceRange getLocalSourceRange() const {\n    return SourceRange(getTypeofLoc(), getRParenLoc());\n  }\n\n  void initializeLocal(ASTContext &Context, SourceLocation Loc) {\n    setTypeofLoc(Loc);\n    setLParenLoc(Loc);\n    setRParenLoc(Loc);\n  }\n};\n\nclass TypeOfExprTypeLoc : public TypeofLikeTypeLoc<TypeOfExprTypeLoc,\n                                                   TypeOfExprType,\n                                                   TypeOfExprTypeLocInfo> {\npublic:\n  Expr* getUnderlyingExpr() const {\n    return getTypePtr()->getUnderlyingExpr();\n  }\n\n  // Reimplemented to account for GNU/C++ extension\n  //     typeof unary-expression\n  // where there are no parentheses.\n  SourceRange getLocalSourceRange() const;\n};\n\nclass TypeOfTypeLoc\n  : public TypeofLikeTypeLoc<TypeOfTypeLoc, TypeOfType, TypeOfTypeLocInfo> {\npublic:\n  QualType getUnderlyingType() const {\n    return this->getTypePtr()->getUnderlyingType();\n  }\n\n  TypeSourceInfo* getUnderlyingTInfo() const {\n    return this->getLocalData()->UnderlyingTInfo;\n  }\n\n  void setUnderlyingTInfo(TypeSourceInfo* TI) const {\n    this->getLocalData()->UnderlyingTInfo = TI;\n  }\n\n  void initializeLocal(ASTContext &Context, SourceLocation Loc);\n};\n\n// FIXME: location of the 'decltype' and parens.\nclass DecltypeTypeLoc : public InheritingConcreteTypeLoc<TypeSpecTypeLoc,\n                                                         DecltypeTypeLoc,\n                                                         DecltypeType> {\npublic:\n  Expr *getUnderlyingExpr() const { return getTypePtr()->getUnderlyingExpr(); }\n};\n\nstruct UnaryTransformTypeLocInfo {\n  // FIXME: While there's only one unary transform right now, future ones may\n  // need different representations\n  SourceLocation KWLoc, LParenLoc, RParenLoc;\n  TypeSourceInfo *UnderlyingTInfo;\n};\n\nclass UnaryTransformTypeLoc : public ConcreteTypeLoc<UnqualTypeLoc,\n                                                    UnaryTransformTypeLoc,\n                                                    UnaryTransformType,\n                                                    UnaryTransformTypeLocInfo> {\npublic:\n  SourceLocation getKWLoc() const { return getLocalData()->KWLoc; }\n  void setKWLoc(SourceLocation Loc) { getLocalData()->KWLoc = Loc; }\n\n  SourceLocation getLParenLoc() const { return getLocalData()->LParenLoc; }\n  void setLParenLoc(SourceLocation Loc) { getLocalData()->LParenLoc = Loc; }\n\n  SourceLocation getRParenLoc() const { return getLocalData()->RParenLoc; }\n  void setRParenLoc(SourceLocation Loc) { getLocalData()->RParenLoc = Loc; }\n\n  TypeSourceInfo* getUnderlyingTInfo() const {\n    return getLocalData()->UnderlyingTInfo;\n  }\n\n  void setUnderlyingTInfo(TypeSourceInfo *TInfo) {\n    getLocalData()->UnderlyingTInfo = TInfo;\n  }\n\n  SourceRange getLocalSourceRange() const {\n    return SourceRange(getKWLoc(), getRParenLoc());\n  }\n\n  SourceRange getParensRange() const {\n    return SourceRange(getLParenLoc(), getRParenLoc());\n  }\n\n  void setParensRange(SourceRange Range) {\n    setLParenLoc(Range.getBegin());\n    setRParenLoc(Range.getEnd());\n  }\n\n  void initializeLocal(ASTContext &Context, SourceLocation Loc);\n};\n\nclass DeducedTypeLoc\n    : public InheritingConcreteTypeLoc<TypeSpecTypeLoc, DeducedTypeLoc,\n                                       DeducedType> {};\n\nstruct AutoTypeLocInfo : TypeSpecLocInfo {\n  NestedNameSpecifierLoc NestedNameSpec;\n  SourceLocation TemplateKWLoc;\n  SourceLocation ConceptNameLoc;\n  NamedDecl *FoundDecl;\n  SourceLocation LAngleLoc;\n  SourceLocation RAngleLoc;\n};\n\nclass AutoTypeLoc\n    : public ConcreteTypeLoc<DeducedTypeLoc,\n                             AutoTypeLoc,\n                             AutoType,\n                             AutoTypeLocInfo> {\npublic:\n  AutoTypeKeyword getAutoKeyword() const {\n    return getTypePtr()->getKeyword();\n  }\n\n  bool isConstrained() const {\n    return getTypePtr()->isConstrained();\n  }\n\n  const NestedNameSpecifierLoc &getNestedNameSpecifierLoc() const {\n    return getLocalData()->NestedNameSpec;\n  }\n\n  void setNestedNameSpecifierLoc(NestedNameSpecifierLoc NNS) {\n    getLocalData()->NestedNameSpec = NNS;\n  }\n\n  SourceLocation getTemplateKWLoc() const {\n    return getLocalData()->TemplateKWLoc;\n  }\n\n  void setTemplateKWLoc(SourceLocation Loc) {\n    getLocalData()->TemplateKWLoc = Loc;\n  }\n\n  SourceLocation getConceptNameLoc() const {\n    return getLocalData()->ConceptNameLoc;\n  }\n\n  void setConceptNameLoc(SourceLocation Loc) {\n    getLocalData()->ConceptNameLoc = Loc;\n  }\n\n  NamedDecl *getFoundDecl() const {\n    return getLocalData()->FoundDecl;\n  }\n\n  void setFoundDecl(NamedDecl *D) {\n    getLocalData()->FoundDecl = D;\n  }\n\n  ConceptDecl *getNamedConcept() const {\n    return getTypePtr()->getTypeConstraintConcept();\n  }\n\n  DeclarationNameInfo getConceptNameInfo() const;\n\n  bool hasExplicitTemplateArgs() const {\n    return getLocalData()->LAngleLoc.isValid();\n  }\n\n  SourceLocation getLAngleLoc() const {\n    return this->getLocalData()->LAngleLoc;\n  }\n\n  void setLAngleLoc(SourceLocation Loc) {\n    this->getLocalData()->LAngleLoc = Loc;\n  }\n\n  SourceLocation getRAngleLoc() const {\n    return this->getLocalData()->RAngleLoc;\n  }\n\n  void setRAngleLoc(SourceLocation Loc) {\n    this->getLocalData()->RAngleLoc = Loc;\n  }\n\n  unsigned getNumArgs() const {\n    return getTypePtr()->getNumArgs();\n  }\n\n  void setArgLocInfo(unsigned i, TemplateArgumentLocInfo AI) {\n    getArgInfos()[i] = AI;\n  }\n\n  TemplateArgumentLocInfo getArgLocInfo(unsigned i) const {\n    return getArgInfos()[i];\n  }\n\n  TemplateArgumentLoc getArgLoc(unsigned i) const {\n    return TemplateArgumentLoc(getTypePtr()->getTypeConstraintArguments()[i],\n                               getArgLocInfo(i));\n  }\n\n  SourceRange getLocalSourceRange() const {\n    return{\n        isConstrained()\n          ? (getNestedNameSpecifierLoc()\n               ? getNestedNameSpecifierLoc().getBeginLoc()\n               : (getTemplateKWLoc().isValid()\n                  ? getTemplateKWLoc()\n                  : getConceptNameLoc()))\n          : getNameLoc(),\n        getNameLoc()\n    };\n  }\n\n  void copy(AutoTypeLoc Loc) {\n    unsigned size = getFullDataSize();\n    assert(size == Loc.getFullDataSize());\n    memcpy(Data, Loc.Data, size);\n  }\n\n  void initializeLocal(ASTContext &Context, SourceLocation Loc);\n\n  unsigned getExtraLocalDataSize() const {\n    return getNumArgs() * sizeof(TemplateArgumentLocInfo);\n  }\n\n  unsigned getExtraLocalDataAlignment() const {\n    return alignof(TemplateArgumentLocInfo);\n  }\n\nprivate:\n  TemplateArgumentLocInfo *getArgInfos() const {\n    return static_cast<TemplateArgumentLocInfo*>(getExtraLocalData());\n  }\n};\n\nclass DeducedTemplateSpecializationTypeLoc\n    : public InheritingConcreteTypeLoc<DeducedTypeLoc,\n                                       DeducedTemplateSpecializationTypeLoc,\n                                       DeducedTemplateSpecializationType> {\npublic:\n  SourceLocation getTemplateNameLoc() const {\n    return getNameLoc();\n  }\n\n  void setTemplateNameLoc(SourceLocation Loc) {\n    setNameLoc(Loc);\n  }\n};\n\nstruct ElaboratedLocInfo {\n  SourceLocation ElaboratedKWLoc;\n\n  /// Data associated with the nested-name-specifier location.\n  void *QualifierData;\n};\n\nclass ElaboratedTypeLoc : public ConcreteTypeLoc<UnqualTypeLoc,\n                                                 ElaboratedTypeLoc,\n                                                 ElaboratedType,\n                                                 ElaboratedLocInfo> {\npublic:\n  SourceLocation getElaboratedKeywordLoc() const {\n    return this->getLocalData()->ElaboratedKWLoc;\n  }\n\n  void setElaboratedKeywordLoc(SourceLocation Loc) {\n    this->getLocalData()->ElaboratedKWLoc = Loc;\n  }\n\n  NestedNameSpecifierLoc getQualifierLoc() const {\n    return NestedNameSpecifierLoc(getTypePtr()->getQualifier(),\n                                  getLocalData()->QualifierData);\n  }\n\n  void setQualifierLoc(NestedNameSpecifierLoc QualifierLoc) {\n    assert(QualifierLoc.getNestedNameSpecifier()\n                                            == getTypePtr()->getQualifier() &&\n           \"Inconsistent nested-name-specifier pointer\");\n    getLocalData()->QualifierData = QualifierLoc.getOpaqueData();\n  }\n\n  SourceRange getLocalSourceRange() const {\n    if (getElaboratedKeywordLoc().isValid())\n      if (getQualifierLoc())\n        return SourceRange(getElaboratedKeywordLoc(),\n                           getQualifierLoc().getEndLoc());\n      else\n        return SourceRange(getElaboratedKeywordLoc());\n    else\n      return getQualifierLoc().getSourceRange();\n  }\n\n  void initializeLocal(ASTContext &Context, SourceLocation Loc);\n\n  TypeLoc getNamedTypeLoc() const {\n    return getInnerTypeLoc();\n  }\n\n  QualType getInnerType() const {\n    return getTypePtr()->getNamedType();\n  }\n\n  void copy(ElaboratedTypeLoc Loc) {\n    unsigned size = getFullDataSize();\n    assert(size == Loc.getFullDataSize());\n    memcpy(Data, Loc.Data, size);\n  }\n};\n\n// This is exactly the structure of an ElaboratedTypeLoc whose inner\n// type is some sort of TypeDeclTypeLoc.\nstruct DependentNameLocInfo : ElaboratedLocInfo {\n  SourceLocation NameLoc;\n};\n\nclass DependentNameTypeLoc : public ConcreteTypeLoc<UnqualTypeLoc,\n                                                    DependentNameTypeLoc,\n                                                    DependentNameType,\n                                                    DependentNameLocInfo> {\npublic:\n  SourceLocation getElaboratedKeywordLoc() const {\n    return this->getLocalData()->ElaboratedKWLoc;\n  }\n\n  void setElaboratedKeywordLoc(SourceLocation Loc) {\n    this->getLocalData()->ElaboratedKWLoc = Loc;\n  }\n\n  NestedNameSpecifierLoc getQualifierLoc() const {\n    return NestedNameSpecifierLoc(getTypePtr()->getQualifier(),\n                                  getLocalData()->QualifierData);\n  }\n\n  void setQualifierLoc(NestedNameSpecifierLoc QualifierLoc) {\n    assert(QualifierLoc.getNestedNameSpecifier()\n                                            == getTypePtr()->getQualifier() &&\n           \"Inconsistent nested-name-specifier pointer\");\n    getLocalData()->QualifierData = QualifierLoc.getOpaqueData();\n  }\n\n  SourceLocation getNameLoc() const {\n    return this->getLocalData()->NameLoc;\n  }\n\n  void setNameLoc(SourceLocation Loc) {\n    this->getLocalData()->NameLoc = Loc;\n  }\n\n  SourceRange getLocalSourceRange() const {\n    if (getElaboratedKeywordLoc().isValid())\n      return SourceRange(getElaboratedKeywordLoc(), getNameLoc());\n    else\n      return SourceRange(getQualifierLoc().getBeginLoc(), getNameLoc());\n  }\n\n  void copy(DependentNameTypeLoc Loc) {\n    unsigned size = getFullDataSize();\n    assert(size == Loc.getFullDataSize());\n    memcpy(Data, Loc.Data, size);\n  }\n\n  void initializeLocal(ASTContext &Context, SourceLocation Loc);\n};\n\nstruct DependentTemplateSpecializationLocInfo : DependentNameLocInfo {\n  SourceLocation TemplateKWLoc;\n  SourceLocation LAngleLoc;\n  SourceLocation RAngleLoc;\n  // followed by a TemplateArgumentLocInfo[]\n};\n\nclass DependentTemplateSpecializationTypeLoc :\n    public ConcreteTypeLoc<UnqualTypeLoc,\n                           DependentTemplateSpecializationTypeLoc,\n                           DependentTemplateSpecializationType,\n                           DependentTemplateSpecializationLocInfo> {\npublic:\n  SourceLocation getElaboratedKeywordLoc() const {\n    return this->getLocalData()->ElaboratedKWLoc;\n  }\n\n  void setElaboratedKeywordLoc(SourceLocation Loc) {\n    this->getLocalData()->ElaboratedKWLoc = Loc;\n  }\n\n  NestedNameSpecifierLoc getQualifierLoc() const {\n    if (!getLocalData()->QualifierData)\n      return NestedNameSpecifierLoc();\n\n    return NestedNameSpecifierLoc(getTypePtr()->getQualifier(),\n                                  getLocalData()->QualifierData);\n  }\n\n  void setQualifierLoc(NestedNameSpecifierLoc QualifierLoc) {\n    if (!QualifierLoc) {\n      // Even if we have a nested-name-specifier in the dependent\n      // template specialization type, we won't record the nested-name-specifier\n      // location information when this type-source location information is\n      // part of a nested-name-specifier.\n      getLocalData()->QualifierData = nullptr;\n      return;\n    }\n\n    assert(QualifierLoc.getNestedNameSpecifier()\n                                        == getTypePtr()->getQualifier() &&\n           \"Inconsistent nested-name-specifier pointer\");\n    getLocalData()->QualifierData = QualifierLoc.getOpaqueData();\n  }\n\n  SourceLocation getTemplateKeywordLoc() const {\n    return getLocalData()->TemplateKWLoc;\n  }\n\n  void setTemplateKeywordLoc(SourceLocation Loc) {\n    getLocalData()->TemplateKWLoc = Loc;\n  }\n\n  SourceLocation getTemplateNameLoc() const {\n    return this->getLocalData()->NameLoc;\n  }\n\n  void setTemplateNameLoc(SourceLocation Loc) {\n    this->getLocalData()->NameLoc = Loc;\n  }\n\n  SourceLocation getLAngleLoc() const {\n    return this->getLocalData()->LAngleLoc;\n  }\n\n  void setLAngleLoc(SourceLocation Loc) {\n    this->getLocalData()->LAngleLoc = Loc;\n  }\n\n  SourceLocation getRAngleLoc() const {\n    return this->getLocalData()->RAngleLoc;\n  }\n\n  void setRAngleLoc(SourceLocation Loc) {\n    this->getLocalData()->RAngleLoc = Loc;\n  }\n\n  unsigned getNumArgs() const {\n    return getTypePtr()->getNumArgs();\n  }\n\n  void setArgLocInfo(unsigned i, TemplateArgumentLocInfo AI) {\n    getArgInfos()[i] = AI;\n  }\n\n  TemplateArgumentLocInfo getArgLocInfo(unsigned i) const {\n    return getArgInfos()[i];\n  }\n\n  TemplateArgumentLoc getArgLoc(unsigned i) const {\n    return TemplateArgumentLoc(getTypePtr()->getArg(i), getArgLocInfo(i));\n  }\n\n  SourceRange getLocalSourceRange() const {\n    if (getElaboratedKeywordLoc().isValid())\n      return SourceRange(getElaboratedKeywordLoc(), getRAngleLoc());\n    else if (getQualifierLoc())\n      return SourceRange(getQualifierLoc().getBeginLoc(), getRAngleLoc());\n    else if (getTemplateKeywordLoc().isValid())\n      return SourceRange(getTemplateKeywordLoc(), getRAngleLoc());\n    else\n      return SourceRange(getTemplateNameLoc(), getRAngleLoc());\n  }\n\n  void copy(DependentTemplateSpecializationTypeLoc Loc) {\n    unsigned size = getFullDataSize();\n    assert(size == Loc.getFullDataSize());\n    memcpy(Data, Loc.Data, size);\n  }\n\n  void initializeLocal(ASTContext &Context, SourceLocation Loc);\n\n  unsigned getExtraLocalDataSize() const {\n    return getNumArgs() * sizeof(TemplateArgumentLocInfo);\n  }\n\n  unsigned getExtraLocalDataAlignment() const {\n    return alignof(TemplateArgumentLocInfo);\n  }\n\nprivate:\n  TemplateArgumentLocInfo *getArgInfos() const {\n    return static_cast<TemplateArgumentLocInfo*>(getExtraLocalData());\n  }\n};\n\nstruct PackExpansionTypeLocInfo {\n  SourceLocation EllipsisLoc;\n};\n\nclass PackExpansionTypeLoc\n  : public ConcreteTypeLoc<UnqualTypeLoc, PackExpansionTypeLoc,\n                           PackExpansionType, PackExpansionTypeLocInfo> {\npublic:\n  SourceLocation getEllipsisLoc() const {\n    return this->getLocalData()->EllipsisLoc;\n  }\n\n  void setEllipsisLoc(SourceLocation Loc) {\n    this->getLocalData()->EllipsisLoc = Loc;\n  }\n\n  SourceRange getLocalSourceRange() const {\n    return SourceRange(getEllipsisLoc(), getEllipsisLoc());\n  }\n\n  void initializeLocal(ASTContext &Context, SourceLocation Loc) {\n    setEllipsisLoc(Loc);\n  }\n\n  TypeLoc getPatternLoc() const {\n    return getInnerTypeLoc();\n  }\n\n  QualType getInnerType() const {\n    return this->getTypePtr()->getPattern();\n  }\n};\n\nstruct AtomicTypeLocInfo {\n  SourceLocation KWLoc, LParenLoc, RParenLoc;\n};\n\nclass AtomicTypeLoc : public ConcreteTypeLoc<UnqualTypeLoc, AtomicTypeLoc,\n                                             AtomicType, AtomicTypeLocInfo> {\npublic:\n  TypeLoc getValueLoc() const {\n    return this->getInnerTypeLoc();\n  }\n\n  SourceRange getLocalSourceRange() const {\n    return SourceRange(getKWLoc(), getRParenLoc());\n  }\n\n  SourceLocation getKWLoc() const {\n    return this->getLocalData()->KWLoc;\n  }\n\n  void setKWLoc(SourceLocation Loc) {\n    this->getLocalData()->KWLoc = Loc;\n  }\n\n  SourceLocation getLParenLoc() const {\n    return this->getLocalData()->LParenLoc;\n  }\n\n  void setLParenLoc(SourceLocation Loc) {\n    this->getLocalData()->LParenLoc = Loc;\n  }\n\n  SourceLocation getRParenLoc() const {\n    return this->getLocalData()->RParenLoc;\n  }\n\n  void setRParenLoc(SourceLocation Loc) {\n    this->getLocalData()->RParenLoc = Loc;\n  }\n\n  SourceRange getParensRange() const {\n    return SourceRange(getLParenLoc(), getRParenLoc());\n  }\n\n  void setParensRange(SourceRange Range) {\n    setLParenLoc(Range.getBegin());\n    setRParenLoc(Range.getEnd());\n  }\n\n  void initializeLocal(ASTContext &Context, SourceLocation Loc) {\n    setKWLoc(Loc);\n    setLParenLoc(Loc);\n    setRParenLoc(Loc);\n  }\n\n  QualType getInnerType() const {\n    return this->getTypePtr()->getValueType();\n  }\n};\n\nstruct PipeTypeLocInfo {\n  SourceLocation KWLoc;\n};\n\nclass PipeTypeLoc : public ConcreteTypeLoc<UnqualTypeLoc, PipeTypeLoc, PipeType,\n                                           PipeTypeLocInfo> {\npublic:\n  TypeLoc getValueLoc() const { return this->getInnerTypeLoc(); }\n\n  SourceRange getLocalSourceRange() const { return SourceRange(getKWLoc()); }\n\n  SourceLocation getKWLoc() const { return this->getLocalData()->KWLoc; }\n  void setKWLoc(SourceLocation Loc) { this->getLocalData()->KWLoc = Loc; }\n\n  void initializeLocal(ASTContext &Context, SourceLocation Loc) {\n    setKWLoc(Loc);\n  }\n\n  QualType getInnerType() const { return this->getTypePtr()->getElementType(); }\n};\n\ntemplate <typename T>\ninline T TypeLoc::getAsAdjusted() const {\n  TypeLoc Cur = *this;\n  while (!T::isKind(Cur)) {\n    if (auto PTL = Cur.getAs<ParenTypeLoc>())\n      Cur = PTL.getInnerLoc();\n    else if (auto ATL = Cur.getAs<AttributedTypeLoc>())\n      Cur = ATL.getModifiedLoc();\n    else if (auto ETL = Cur.getAs<ElaboratedTypeLoc>())\n      Cur = ETL.getNamedTypeLoc();\n    else if (auto ATL = Cur.getAs<AdjustedTypeLoc>())\n      Cur = ATL.getOriginalLoc();\n    else if (auto MQL = Cur.getAs<MacroQualifiedTypeLoc>())\n      Cur = MQL.getInnerLoc();\n    else\n      break;\n  }\n  return Cur.getAs<T>();\n}\nclass ExtIntTypeLoc final\n    : public InheritingConcreteTypeLoc<TypeSpecTypeLoc, ExtIntTypeLoc,\n                                        ExtIntType> {};\nclass DependentExtIntTypeLoc final\n    : public InheritingConcreteTypeLoc<TypeSpecTypeLoc, DependentExtIntTypeLoc,\n                                        DependentExtIntType> {};\n\n} // namespace clang\n\n#endif // LLVM_CLANG_AST_TYPELOC_H\n"}, "30": {"id": 30, "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Sema/Initialization.h", "content": "//===- Initialization.h - Semantic Analysis for Initializers ----*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// This file provides supporting data types for initialization of objects.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_CLANG_SEMA_INITIALIZATION_H\n#define LLVM_CLANG_SEMA_INITIALIZATION_H\n\n#include \"clang/AST/ASTContext.h\"\n#include \"clang/AST/Attr.h\"\n#include \"clang/AST/Decl.h\"\n#include \"clang/AST/DeclAccessPair.h\"\n#include \"clang/AST/DeclarationName.h\"\n#include \"clang/AST/Expr.h\"\n#include \"clang/AST/Type.h\"\n#include \"clang/Basic/IdentifierTable.h\"\n#include \"clang/Basic/LLVM.h\"\n#include \"clang/Basic/LangOptions.h\"\n#include \"clang/Basic/SourceLocation.h\"\n#include \"clang/Basic/Specifiers.h\"\n#include \"clang/Sema/Overload.h\"\n#include \"clang/Sema/Ownership.h\"\n#include \"llvm/ADT/ArrayRef.h\"\n#include \"llvm/ADT/SmallVector.h\"\n#include \"llvm/ADT/StringRef.h\"\n#include \"llvm/ADT/iterator_range.h\"\n#include \"llvm/Support/Casting.h\"\n#include <cassert>\n#include <cstdint>\n#include <string>\n\nnamespace clang {\n\nclass APValue;\nclass CXXBaseSpecifier;\nclass CXXConstructorDecl;\nclass ObjCMethodDecl;\nclass Sema;\n\n/// Describes an entity that is being initialized.\nclass alignas(8) InitializedEntity {\npublic:\n  /// Specifies the kind of entity being initialized.\n  enum EntityKind {\n    /// The entity being initialized is a variable.\n    EK_Variable,\n\n    /// The entity being initialized is a function parameter.\n    EK_Parameter,\n\n    /// The entity being initialized is a non-type template parameter.\n    EK_TemplateParameter,\n\n    /// The entity being initialized is the result of a function call.\n    EK_Result,\n\n    /// The entity being initialized is the result of a statement expression.\n    EK_StmtExprResult,\n\n    /// The entity being initialized is an exception object that\n    /// is being thrown.\n    EK_Exception,\n\n    /// The entity being initialized is a non-static data member\n    /// subobject.\n    EK_Member,\n\n    /// The entity being initialized is an element of an array.\n    EK_ArrayElement,\n\n    /// The entity being initialized is an object (or array of\n    /// objects) allocated via new.\n    EK_New,\n\n    /// The entity being initialized is a temporary object.\n    EK_Temporary,\n\n    /// The entity being initialized is a base member subobject.\n    EK_Base,\n\n    /// The initialization is being done by a delegating constructor.\n    EK_Delegating,\n\n    /// The entity being initialized is an element of a vector.\n    /// or vector.\n    EK_VectorElement,\n\n    /// The entity being initialized is a field of block descriptor for\n    /// the copied-in c++ object.\n    EK_BlockElement,\n\n    /// The entity being initialized is a field of block descriptor for the\n    /// copied-in lambda object that's used in the lambda to block conversion.\n    EK_LambdaToBlockConversionBlockElement,\n\n    /// The entity being initialized is the real or imaginary part of a\n    /// complex number.\n    EK_ComplexElement,\n\n    /// The entity being initialized is the field that captures a\n    /// variable in a lambda.\n    EK_LambdaCapture,\n\n    /// The entity being initialized is the initializer for a compound\n    /// literal.\n    EK_CompoundLiteralInit,\n\n    /// The entity being implicitly initialized back to the formal\n    /// result type.\n    EK_RelatedResult,\n\n    /// The entity being initialized is a function parameter; function\n    /// is member of group of audited CF APIs.\n    EK_Parameter_CF_Audited,\n\n    /// The entity being initialized is a structured binding of a\n    /// decomposition declaration.\n    EK_Binding,\n\n    // Note: err_init_conversion_failed in DiagnosticSemaKinds.td uses this\n    // enum as an index for its first %select.  When modifying this list,\n    // that diagnostic text needs to be updated as well.\n  };\n\nprivate:\n  /// The kind of entity being initialized.\n  EntityKind Kind;\n\n  /// If non-NULL, the parent entity in which this\n  /// initialization occurs.\n  const InitializedEntity *Parent = nullptr;\n\n  /// The type of the object or reference being initialized.\n  QualType Type;\n\n  /// The mangling number for the next reference temporary to be created.\n  mutable unsigned ManglingNumber = 0;\n\n  struct LN {\n    /// When Kind == EK_Result, EK_Exception, EK_New, the\n    /// location of the 'return', 'throw', or 'new' keyword,\n    /// respectively. When Kind == EK_Temporary, the location where\n    /// the temporary is being created.\n    SourceLocation Location;\n\n    /// Whether the entity being initialized may end up using the\n    /// named return value optimization (NRVO).\n    bool NRVO;\n  };\n\n  struct VD {\n    /// The VarDecl, FieldDecl, or BindingDecl being initialized.\n    ValueDecl *VariableOrMember;\n\n    /// When Kind == EK_Member, whether this is an implicit member\n    /// initialization in a copy or move constructor. These can perform array\n    /// copies.\n    bool IsImplicitFieldInit;\n\n    /// When Kind == EK_Member, whether this is the initial initialization\n    /// check for a default member initializer.\n    bool IsDefaultMemberInit;\n  };\n\n  struct C {\n    /// The name of the variable being captured by an EK_LambdaCapture.\n    IdentifierInfo *VarID;\n\n    /// The source location at which the capture occurs.\n    SourceLocation Location;\n  };\n\n  union {\n    /// When Kind == EK_Variable, EK_Member, EK_Binding, or\n    /// EK_TemplateParameter, the variable, binding, or template parameter.\n    VD Variable;\n\n    /// When Kind == EK_RelatedResult, the ObjectiveC method where\n    /// result type was implicitly changed to accommodate ARC semantics.\n    ObjCMethodDecl *MethodDecl;\n\n    /// When Kind == EK_Parameter, the ParmVarDecl, with the\n    /// low bit indicating whether the parameter is \"consumed\".\n    uintptr_t Parameter;\n\n    /// When Kind == EK_Temporary or EK_CompoundLiteralInit, the type\n    /// source information for the temporary.\n    TypeSourceInfo *TypeInfo;\n\n    struct LN LocAndNRVO;\n\n    /// When Kind == EK_Base, the base specifier that provides the\n    /// base class. The lower bit specifies whether the base is an inherited\n    /// virtual base.\n    uintptr_t Base;\n\n    /// When Kind == EK_ArrayElement, EK_VectorElement, or\n    /// EK_ComplexElement, the index of the array or vector element being\n    /// initialized.\n    unsigned Index;\n\n    struct C Capture;\n  };\n\n  InitializedEntity() {};\n\n  /// Create the initialization entity for a variable.\n  InitializedEntity(VarDecl *Var, EntityKind EK = EK_Variable)\n      : Kind(EK), Type(Var->getType()), Variable{Var, false, false} {}\n\n  /// Create the initialization entity for the result of a\n  /// function, throwing an object, performing an explicit cast, or\n  /// initializing a parameter for which there is no declaration.\n  InitializedEntity(EntityKind Kind, SourceLocation Loc, QualType Type,\n                    bool NRVO = false)\n      : Kind(Kind), Type(Type) {\n    new (&LocAndNRVO) LN;\n    LocAndNRVO.Location = Loc;\n    LocAndNRVO.NRVO = NRVO;\n  }\n\n  /// Create the initialization entity for a member subobject.\n  InitializedEntity(FieldDecl *Member, const InitializedEntity *Parent,\n                    bool Implicit, bool DefaultMemberInit)\n      : Kind(EK_Member), Parent(Parent), Type(Member->getType()),\n        Variable{Member, Implicit, DefaultMemberInit} {}\n\n  /// Create the initialization entity for an array element.\n  InitializedEntity(ASTContext &Context, unsigned Index,\n                    const InitializedEntity &Parent);\n\n  /// Create the initialization entity for a lambda capture.\n  InitializedEntity(IdentifierInfo *VarID, QualType FieldType, SourceLocation Loc)\n      : Kind(EK_LambdaCapture), Type(FieldType) {\n    new (&Capture) C;\n    Capture.VarID = VarID;\n    Capture.Location = Loc;\n  }\n\npublic:\n  /// Create the initialization entity for a variable.\n  static InitializedEntity InitializeVariable(VarDecl *Var) {\n    return InitializedEntity(Var);\n  }\n\n  /// Create the initialization entity for a parameter.\n  static InitializedEntity InitializeParameter(ASTContext &Context,\n                                               const ParmVarDecl *Parm) {\n    return InitializeParameter(Context, Parm, Parm->getType());\n  }\n\n  /// Create the initialization entity for a parameter, but use\n  /// another type.\n  static InitializedEntity InitializeParameter(ASTContext &Context,\n                                               const ParmVarDecl *Parm,\n                                               QualType Type) {\n    bool Consumed = (Context.getLangOpts().ObjCAutoRefCount &&\n                     Parm->hasAttr<NSConsumedAttr>());\n\n    InitializedEntity Entity;\n    Entity.Kind = EK_Parameter;\n    Entity.Type =\n      Context.getVariableArrayDecayedType(Type.getUnqualifiedType());\n    Entity.Parent = nullptr;\n    Entity.Parameter\n      = (static_cast<uintptr_t>(Consumed) | reinterpret_cast<uintptr_t>(Parm));\n    return Entity;\n  }\n\n  /// Create the initialization entity for a parameter that is\n  /// only known by its type.\n  static InitializedEntity InitializeParameter(ASTContext &Context,\n                                               QualType Type,\n                                               bool Consumed) {\n    InitializedEntity Entity;\n    Entity.Kind = EK_Parameter;\n    Entity.Type = Context.getVariableArrayDecayedType(Type);\n    Entity.Parent = nullptr;\n    Entity.Parameter = (Consumed);\n    return Entity;\n  }\n\n  /// Create the initialization entity for a template parameter.\n  static InitializedEntity\n  InitializeTemplateParameter(QualType T, NonTypeTemplateParmDecl *Param) {\n    InitializedEntity Entity;\n    Entity.Kind = EK_TemplateParameter;\n    Entity.Type = T;\n    Entity.Parent = nullptr;\n    Entity.Variable = {Param, false, false};\n    return Entity;\n  }\n\n  /// Create the initialization entity for the result of a function.\n  static InitializedEntity InitializeResult(SourceLocation ReturnLoc,\n                                            QualType Type, bool NRVO) {\n    return InitializedEntity(EK_Result, ReturnLoc, Type, NRVO);\n  }\n\n  static InitializedEntity InitializeStmtExprResult(SourceLocation ReturnLoc,\n                                            QualType Type) {\n    return InitializedEntity(EK_StmtExprResult, ReturnLoc, Type);\n  }\n\n  static InitializedEntity InitializeBlock(SourceLocation BlockVarLoc,\n                                           QualType Type, bool NRVO) {\n    return InitializedEntity(EK_BlockElement, BlockVarLoc, Type, NRVO);\n  }\n\n  static InitializedEntity InitializeLambdaToBlock(SourceLocation BlockVarLoc,\n                                                   QualType Type, bool NRVO) {\n    return InitializedEntity(EK_LambdaToBlockConversionBlockElement,\n                             BlockVarLoc, Type, NRVO);\n  }\n\n  /// Create the initialization entity for an exception object.\n  static InitializedEntity InitializeException(SourceLocation ThrowLoc,\n                                               QualType Type, bool NRVO) {\n    return InitializedEntity(EK_Exception, ThrowLoc, Type, NRVO);\n  }\n\n  /// Create the initialization entity for an object allocated via new.\n  static InitializedEntity InitializeNew(SourceLocation NewLoc, QualType Type) {\n    return InitializedEntity(EK_New, NewLoc, Type);\n  }\n\n  /// Create the initialization entity for a temporary.\n  static InitializedEntity InitializeTemporary(QualType Type) {\n    return InitializeTemporary(nullptr, Type);\n  }\n\n  /// Create the initialization entity for a temporary.\n  static InitializedEntity InitializeTemporary(TypeSourceInfo *TypeInfo) {\n    return InitializeTemporary(TypeInfo, TypeInfo->getType());\n  }\n\n  /// Create the initialization entity for a temporary.\n  static InitializedEntity InitializeTemporary(TypeSourceInfo *TypeInfo,\n                                               QualType Type) {\n    InitializedEntity Result(EK_Temporary, SourceLocation(), Type);\n    Result.TypeInfo = TypeInfo;\n    return Result;\n  }\n\n  /// Create the initialization entity for a related result.\n  static InitializedEntity InitializeRelatedResult(ObjCMethodDecl *MD,\n                                                   QualType Type) {\n    InitializedEntity Result(EK_RelatedResult, SourceLocation(), Type);\n    Result.MethodDecl = MD;\n    return Result;\n  }\n\n  /// Create the initialization entity for a base class subobject.\n  static InitializedEntity\n  InitializeBase(ASTContext &Context, const CXXBaseSpecifier *Base,\n                 bool IsInheritedVirtualBase,\n                 const InitializedEntity *Parent = nullptr);\n\n  /// Create the initialization entity for a delegated constructor.\n  static InitializedEntity InitializeDelegation(QualType Type) {\n    return InitializedEntity(EK_Delegating, SourceLocation(), Type);\n  }\n\n  /// Create the initialization entity for a member subobject.\n  static InitializedEntity\n  InitializeMember(FieldDecl *Member,\n                   const InitializedEntity *Parent = nullptr,\n                   bool Implicit = false) {\n    return InitializedEntity(Member, Parent, Implicit, false);\n  }\n\n  /// Create the initialization entity for a member subobject.\n  static InitializedEntity\n  InitializeMember(IndirectFieldDecl *Member,\n                   const InitializedEntity *Parent = nullptr,\n                   bool Implicit = false) {\n    return InitializedEntity(Member->getAnonField(), Parent, Implicit, false);\n  }\n\n  /// Create the initialization entity for a default member initializer.\n  static InitializedEntity\n  InitializeMemberFromDefaultMemberInitializer(FieldDecl *Member) {\n    return InitializedEntity(Member, nullptr, false, true);\n  }\n\n  /// Create the initialization entity for an array element.\n  static InitializedEntity InitializeElement(ASTContext &Context,\n                                             unsigned Index,\n                                             const InitializedEntity &Parent) {\n    return InitializedEntity(Context, Index, Parent);\n  }\n\n  /// Create the initialization entity for a structured binding.\n  static InitializedEntity InitializeBinding(VarDecl *Binding) {\n    return InitializedEntity(Binding, EK_Binding);\n  }\n\n  /// Create the initialization entity for a lambda capture.\n  ///\n  /// \\p VarID The name of the entity being captured, or nullptr for 'this'.\n  static InitializedEntity InitializeLambdaCapture(IdentifierInfo *VarID,\n                                                   QualType FieldType,\n                                                   SourceLocation Loc) {\n    return InitializedEntity(VarID, FieldType, Loc);\n  }\n\n  /// Create the entity for a compound literal initializer.\n  static InitializedEntity InitializeCompoundLiteralInit(TypeSourceInfo *TSI) {\n    InitializedEntity Result(EK_CompoundLiteralInit, SourceLocation(),\n                             TSI->getType());\n    Result.TypeInfo = TSI;\n    return Result;\n  }\n\n  /// Determine the kind of initialization.\n  EntityKind getKind() const { return Kind; }\n\n  /// Retrieve the parent of the entity being initialized, when\n  /// the initialization itself is occurring within the context of a\n  /// larger initialization.\n  const InitializedEntity *getParent() const { return Parent; }\n\n  /// Retrieve type being initialized.\n  QualType getType() const { return Type; }\n\n  /// Retrieve complete type-source information for the object being\n  /// constructed, if known.\n  TypeSourceInfo *getTypeSourceInfo() const {\n    if (Kind == EK_Temporary || Kind == EK_CompoundLiteralInit)\n      return TypeInfo;\n\n    return nullptr;\n  }\n\n  /// Retrieve the name of the entity being initialized.\n  DeclarationName getName() const;\n\n  /// Retrieve the variable, parameter, or field being\n  /// initialized.\n  ValueDecl *getDecl() const;\n\n  /// Retrieve the ObjectiveC method being initialized.\n  ObjCMethodDecl *getMethodDecl() const { return MethodDecl; }\n\n  /// Determine whether this initialization allows the named return\n  /// value optimization, which also applies to thrown objects.\n  bool allowsNRVO() const;\n\n  bool isParameterKind() const {\n    return (getKind() == EK_Parameter  ||\n            getKind() == EK_Parameter_CF_Audited);\n  }\n\n  bool isParamOrTemplateParamKind() const {\n    return isParameterKind() || getKind() == EK_TemplateParameter;\n  }\n\n  /// Determine whether this initialization consumes the\n  /// parameter.\n  bool isParameterConsumed() const {\n    assert(isParameterKind() && \"Not a parameter\");\n    return (Parameter & 1);\n  }\n\n  /// Retrieve the base specifier.\n  const CXXBaseSpecifier *getBaseSpecifier() const {\n    assert(getKind() == EK_Base && \"Not a base specifier\");\n    return reinterpret_cast<const CXXBaseSpecifier *>(Base & ~0x1);\n  }\n\n  /// Return whether the base is an inherited virtual base.\n  bool isInheritedVirtualBase() const {\n    assert(getKind() == EK_Base && \"Not a base specifier\");\n    return Base & 0x1;\n  }\n\n  /// Determine whether this is an array new with an unknown bound.\n  bool isVariableLengthArrayNew() const {\n    return getKind() == EK_New && dyn_cast_or_null<IncompleteArrayType>(\n                                      getType()->getAsArrayTypeUnsafe());\n  }\n\n  /// Is this the implicit initialization of a member of a class from\n  /// a defaulted constructor?\n  bool isImplicitMemberInitializer() const {\n    return getKind() == EK_Member && Variable.IsImplicitFieldInit;\n  }\n\n  /// Is this the default member initializer of a member (specified inside\n  /// the class definition)?\n  bool isDefaultMemberInitializer() const {\n    return getKind() == EK_Member && Variable.IsDefaultMemberInit;\n  }\n\n  /// Determine the location of the 'return' keyword when initializing\n  /// the result of a function call.\n  SourceLocation getReturnLoc() const {\n    assert(getKind() == EK_Result && \"No 'return' location!\");\n    return LocAndNRVO.Location;\n  }\n\n  /// Determine the location of the 'throw' keyword when initializing\n  /// an exception object.\n  SourceLocation getThrowLoc() const {\n    assert(getKind() == EK_Exception && \"No 'throw' location!\");\n    return LocAndNRVO.Location;\n  }\n\n  /// If this is an array, vector, or complex number element, get the\n  /// element's index.\n  unsigned getElementIndex() const {\n    assert(getKind() == EK_ArrayElement || getKind() == EK_VectorElement ||\n           getKind() == EK_ComplexElement);\n    return Index;\n  }\n\n  /// If this is already the initializer for an array or vector\n  /// element, sets the element index.\n  void setElementIndex(unsigned Index) {\n    assert(getKind() == EK_ArrayElement || getKind() == EK_VectorElement ||\n           getKind() == EK_ComplexElement);\n    this->Index = Index;\n  }\n\n  /// For a lambda capture, return the capture's name.\n  StringRef getCapturedVarName() const {\n    assert(getKind() == EK_LambdaCapture && \"Not a lambda capture!\");\n    return Capture.VarID ? Capture.VarID->getName() : \"this\";\n  }\n\n  /// Determine the location of the capture when initializing\n  /// field from a captured variable in a lambda.\n  SourceLocation getCaptureLoc() const {\n    assert(getKind() == EK_LambdaCapture && \"Not a lambda capture!\");\n    return Capture.Location;\n  }\n\n  void setParameterCFAudited() {\n    Kind = EK_Parameter_CF_Audited;\n  }\n\n  unsigned allocateManglingNumber() const { return ++ManglingNumber; }\n\n  /// Dump a representation of the initialized entity to standard error,\n  /// for debugging purposes.\n  void dump() const;\n\nprivate:\n  unsigned dumpImpl(raw_ostream &OS) const;\n};\n\n/// Describes the kind of initialization being performed, along with\n/// location information for tokens related to the initialization (equal sign,\n/// parentheses).\nclass InitializationKind {\npublic:\n  /// The kind of initialization being performed.\n  enum InitKind {\n    /// Direct initialization\n    IK_Direct,\n\n    /// Direct list-initialization\n    IK_DirectList,\n\n    /// Copy initialization\n    IK_Copy,\n\n    /// Default initialization\n    IK_Default,\n\n    /// Value initialization\n    IK_Value\n  };\n\nprivate:\n  /// The context of the initialization.\n  enum InitContext {\n    /// Normal context\n    IC_Normal,\n\n    /// Normal context, but allows explicit conversion functionss\n    IC_ExplicitConvs,\n\n    /// Implicit context (value initialization)\n    IC_Implicit,\n\n    /// Static cast context\n    IC_StaticCast,\n\n    /// C-style cast context\n    IC_CStyleCast,\n\n    /// Functional cast context\n    IC_FunctionalCast\n  };\n\n  /// The kind of initialization being performed.\n  InitKind Kind : 8;\n\n  /// The context of the initialization.\n  InitContext Context : 8;\n\n  /// The source locations involved in the initialization.\n  SourceLocation Locations[3];\n\n  InitializationKind(InitKind Kind, InitContext Context, SourceLocation Loc1,\n                     SourceLocation Loc2, SourceLocation Loc3)\n      : Kind(Kind), Context(Context) {\n    Locations[0] = Loc1;\n    Locations[1] = Loc2;\n    Locations[2] = Loc3;\n  }\n\npublic:\n  /// Create a direct initialization.\n  static InitializationKind CreateDirect(SourceLocation InitLoc,\n                                         SourceLocation LParenLoc,\n                                         SourceLocation RParenLoc) {\n    return InitializationKind(IK_Direct, IC_Normal,\n                              InitLoc, LParenLoc, RParenLoc);\n  }\n\n  static InitializationKind CreateDirectList(SourceLocation InitLoc) {\n    return InitializationKind(IK_DirectList, IC_Normal, InitLoc, InitLoc,\n                              InitLoc);\n  }\n\n  static InitializationKind CreateDirectList(SourceLocation InitLoc,\n                                             SourceLocation LBraceLoc,\n                                             SourceLocation RBraceLoc) {\n    return InitializationKind(IK_DirectList, IC_Normal, InitLoc, LBraceLoc,\n                              RBraceLoc);\n  }\n\n  /// Create a direct initialization due to a cast that isn't a C-style\n  /// or functional cast.\n  static InitializationKind CreateCast(SourceRange TypeRange) {\n    return InitializationKind(IK_Direct, IC_StaticCast, TypeRange.getBegin(),\n                              TypeRange.getBegin(), TypeRange.getEnd());\n  }\n\n  /// Create a direct initialization for a C-style cast.\n  static InitializationKind CreateCStyleCast(SourceLocation StartLoc,\n                                             SourceRange TypeRange,\n                                             bool InitList) {\n    // C++ cast syntax doesn't permit init lists, but C compound literals are\n    // exactly that.\n    return InitializationKind(InitList ? IK_DirectList : IK_Direct,\n                              IC_CStyleCast, StartLoc, TypeRange.getBegin(),\n                              TypeRange.getEnd());\n  }\n\n  /// Create a direct initialization for a functional cast.\n  static InitializationKind CreateFunctionalCast(SourceRange TypeRange,\n                                                 bool InitList) {\n    return InitializationKind(InitList ? IK_DirectList : IK_Direct,\n                              IC_FunctionalCast, TypeRange.getBegin(),\n                              TypeRange.getBegin(), TypeRange.getEnd());\n  }\n\n  /// Create a copy initialization.\n  static InitializationKind CreateCopy(SourceLocation InitLoc,\n                                       SourceLocation EqualLoc,\n                                       bool AllowExplicitConvs = false) {\n    return InitializationKind(IK_Copy,\n                              AllowExplicitConvs? IC_ExplicitConvs : IC_Normal,\n                              InitLoc, EqualLoc, EqualLoc);\n  }\n\n  /// Create a default initialization.\n  static InitializationKind CreateDefault(SourceLocation InitLoc) {\n    return InitializationKind(IK_Default, IC_Normal, InitLoc, InitLoc, InitLoc);\n  }\n\n  /// Create a value initialization.\n  static InitializationKind CreateValue(SourceLocation InitLoc,\n                                        SourceLocation LParenLoc,\n                                        SourceLocation RParenLoc,\n                                        bool isImplicit = false) {\n    return InitializationKind(IK_Value, isImplicit ? IC_Implicit : IC_Normal,\n                              InitLoc, LParenLoc, RParenLoc);\n  }\n\n  /// Create an initialization from an initializer (which, for direct\n  /// initialization from a parenthesized list, will be a ParenListExpr).\n  static InitializationKind CreateForInit(SourceLocation Loc, bool DirectInit,\n                                          Expr *Init) {\n    if (!Init) return CreateDefault(Loc);\n    if (!DirectInit)\n      return CreateCopy(Loc, Init->getBeginLoc());\n    if (isa<InitListExpr>(Init))\n      return CreateDirectList(Loc, Init->getBeginLoc(), Init->getEndLoc());\n    return CreateDirect(Loc, Init->getBeginLoc(), Init->getEndLoc());\n  }\n\n  /// Determine the initialization kind.\n  InitKind getKind() const {\n    return Kind;\n  }\n\n  /// Determine whether this initialization is an explicit cast.\n  bool isExplicitCast() const {\n    return Context >= IC_StaticCast;\n  }\n\n  /// Determine whether this initialization is a static cast.\n  bool isStaticCast() const { return Context == IC_StaticCast; }\n\n  /// Determine whether this initialization is a C-style cast.\n  bool isCStyleOrFunctionalCast() const {\n    return Context >= IC_CStyleCast;\n  }\n\n  /// Determine whether this is a C-style cast.\n  bool isCStyleCast() const {\n    return Context == IC_CStyleCast;\n  }\n\n  /// Determine whether this is a functional-style cast.\n  bool isFunctionalCast() const {\n    return Context == IC_FunctionalCast;\n  }\n\n  /// Determine whether this initialization is an implicit\n  /// value-initialization, e.g., as occurs during aggregate\n  /// initialization.\n  bool isImplicitValueInit() const { return Context == IC_Implicit; }\n\n  /// Retrieve the location at which initialization is occurring.\n  SourceLocation getLocation() const { return Locations[0]; }\n\n  /// Retrieve the source range that covers the initialization.\n  SourceRange getRange() const {\n    return SourceRange(Locations[0], Locations[2]);\n  }\n\n  /// Retrieve the location of the equal sign for copy initialization\n  /// (if present).\n  SourceLocation getEqualLoc() const {\n    assert(Kind == IK_Copy && \"Only copy initialization has an '='\");\n    return Locations[1];\n  }\n\n  bool isCopyInit() const { return Kind == IK_Copy; }\n\n  /// Retrieve whether this initialization allows the use of explicit\n  ///        constructors.\n  bool AllowExplicit() const { return !isCopyInit(); }\n\n  /// Retrieve whether this initialization allows the use of explicit\n  /// conversion functions when binding a reference. If the reference is the\n  /// first parameter in a copy or move constructor, such conversions are\n  /// permitted even though we are performing copy-initialization.\n  bool allowExplicitConversionFunctionsInRefBinding() const {\n    return !isCopyInit() || Context == IC_ExplicitConvs;\n  }\n\n  /// Determine whether this initialization has a source range containing the\n  /// locations of open and closing parentheses or braces.\n  bool hasParenOrBraceRange() const {\n    return Kind == IK_Direct || Kind == IK_Value || Kind == IK_DirectList;\n  }\n\n  /// Retrieve the source range containing the locations of the open\n  /// and closing parentheses or braces for value, direct, and direct list\n  /// initializations.\n  SourceRange getParenOrBraceRange() const {\n    assert(hasParenOrBraceRange() && \"Only direct, value, and direct-list \"\n                                     \"initialization have parentheses or \"\n                                     \"braces\");\n    return SourceRange(Locations[1], Locations[2]);\n  }\n};\n\n/// Describes the sequence of initializations required to initialize\n/// a given object or reference with a set of arguments.\nclass InitializationSequence {\npublic:\n  /// Describes the kind of initialization sequence computed.\n  enum SequenceKind {\n    /// A failed initialization sequence. The failure kind tells what\n    /// happened.\n    FailedSequence = 0,\n\n    /// A dependent initialization, which could not be\n    /// type-checked due to the presence of dependent types or\n    /// dependently-typed expressions.\n    DependentSequence,\n\n    /// A normal sequence.\n    NormalSequence\n  };\n\n  /// Describes the kind of a particular step in an initialization\n  /// sequence.\n  enum StepKind {\n    /// Resolve the address of an overloaded function to a specific\n    /// function declaration.\n    SK_ResolveAddressOfOverloadedFunction,\n\n    /// Perform a derived-to-base cast, producing an rvalue.\n    SK_CastDerivedToBaseRValue,\n\n    /// Perform a derived-to-base cast, producing an xvalue.\n    SK_CastDerivedToBaseXValue,\n\n    /// Perform a derived-to-base cast, producing an lvalue.\n    SK_CastDerivedToBaseLValue,\n\n    /// Reference binding to an lvalue.\n    SK_BindReference,\n\n    /// Reference binding to a temporary.\n    SK_BindReferenceToTemporary,\n\n    /// An optional copy of a temporary object to another\n    /// temporary object, which is permitted (but not required) by\n    /// C++98/03 but not C++0x.\n    SK_ExtraneousCopyToTemporary,\n\n    /// Direct-initialization from a reference-related object in the\n    /// final stage of class copy-initialization.\n    SK_FinalCopy,\n\n    /// Perform a user-defined conversion, either via a conversion\n    /// function or via a constructor.\n    SK_UserConversion,\n\n    /// Perform a qualification conversion, producing an rvalue.\n    SK_QualificationConversionRValue,\n\n    /// Perform a qualification conversion, producing an xvalue.\n    SK_QualificationConversionXValue,\n\n    /// Perform a qualification conversion, producing an lvalue.\n    SK_QualificationConversionLValue,\n\n    /// Perform a function reference conversion, see [dcl.init.ref]p4.\n    SK_FunctionReferenceConversion,\n\n    /// Perform a conversion adding _Atomic to a type.\n    SK_AtomicConversion,\n\n    /// Perform an implicit conversion sequence.\n    SK_ConversionSequence,\n\n    /// Perform an implicit conversion sequence without narrowing.\n    SK_ConversionSequenceNoNarrowing,\n\n    /// Perform list-initialization without a constructor.\n    SK_ListInitialization,\n\n    /// Unwrap the single-element initializer list for a reference.\n    SK_UnwrapInitList,\n\n    /// Rewrap the single-element initializer list for a reference.\n    SK_RewrapInitList,\n\n    /// Perform initialization via a constructor.\n    SK_ConstructorInitialization,\n\n    /// Perform initialization via a constructor, taking arguments from\n    /// a single InitListExpr.\n    SK_ConstructorInitializationFromList,\n\n    /// Zero-initialize the object\n    SK_ZeroInitialization,\n\n    /// C assignment\n    SK_CAssignment,\n\n    /// Initialization by string\n    SK_StringInit,\n\n    /// An initialization that \"converts\" an Objective-C object\n    /// (not a point to an object) to another Objective-C object type.\n    SK_ObjCObjectConversion,\n\n    /// Array indexing for initialization by elementwise copy.\n    SK_ArrayLoopIndex,\n\n    /// Array initialization by elementwise copy.\n    SK_ArrayLoopInit,\n\n    /// Array initialization (from an array rvalue).\n    SK_ArrayInit,\n\n    /// Array initialization (from an array rvalue) as a GNU extension.\n    SK_GNUArrayInit,\n\n    /// Array initialization from a parenthesized initializer list.\n    /// This is a GNU C++ extension.\n    SK_ParenthesizedArrayInit,\n\n    /// Pass an object by indirect copy-and-restore.\n    SK_PassByIndirectCopyRestore,\n\n    /// Pass an object by indirect restore.\n    SK_PassByIndirectRestore,\n\n    /// Produce an Objective-C object pointer.\n    SK_ProduceObjCObject,\n\n    /// Construct a std::initializer_list from an initializer list.\n    SK_StdInitializerList,\n\n    /// Perform initialization via a constructor taking a single\n    /// std::initializer_list argument.\n    SK_StdInitializerListConstructorCall,\n\n    /// Initialize an OpenCL sampler from an integer.\n    SK_OCLSamplerInit,\n\n    /// Initialize an opaque OpenCL type (event_t, queue_t, etc.) with zero\n    SK_OCLZeroOpaqueType\n  };\n\n  /// A single step in the initialization sequence.\n  class Step {\n  public:\n    /// The kind of conversion or initialization step we are taking.\n    StepKind Kind;\n\n    // The type that results from this initialization.\n    QualType Type;\n\n    struct F {\n      bool HadMultipleCandidates;\n      FunctionDecl *Function;\n      DeclAccessPair FoundDecl;\n    };\n\n    union {\n      /// When Kind == SK_ResolvedOverloadedFunction or Kind ==\n      /// SK_UserConversion, the function that the expression should be\n      /// resolved to or the conversion function to call, respectively.\n      /// When Kind == SK_ConstructorInitialization or SK_ListConstruction,\n      /// the constructor to be called.\n      ///\n      /// Always a FunctionDecl, plus a Boolean flag telling if it was\n      /// selected from an overloaded set having size greater than 1.\n      /// For conversion decls, the naming class is the source type.\n      /// For construct decls, the naming class is the target type.\n      struct F Function;\n\n      /// When Kind = SK_ConversionSequence, the implicit conversion\n      /// sequence.\n      ImplicitConversionSequence *ICS;\n\n      /// When Kind = SK_RewrapInitList, the syntactic form of the\n      /// wrapping list.\n      InitListExpr *WrappingSyntacticList;\n    };\n\n    void Destroy();\n  };\n\nprivate:\n  /// The kind of initialization sequence computed.\n  enum SequenceKind SequenceKind;\n\n  /// Steps taken by this initialization.\n  SmallVector<Step, 4> Steps;\n\npublic:\n  /// Describes why initialization failed.\n  enum FailureKind {\n    /// Too many initializers provided for a reference.\n    FK_TooManyInitsForReference,\n\n    /// Reference initialized from a parenthesized initializer list.\n    FK_ParenthesizedListInitForReference,\n\n    /// Array must be initialized with an initializer list.\n    FK_ArrayNeedsInitList,\n\n    /// Array must be initialized with an initializer list or a\n    /// string literal.\n    FK_ArrayNeedsInitListOrStringLiteral,\n\n    /// Array must be initialized with an initializer list or a\n    /// wide string literal.\n    FK_ArrayNeedsInitListOrWideStringLiteral,\n\n    /// Initializing a wide char array with narrow string literal.\n    FK_NarrowStringIntoWideCharArray,\n\n    /// Initializing char array with wide string literal.\n    FK_WideStringIntoCharArray,\n\n    /// Initializing wide char array with incompatible wide string\n    /// literal.\n    FK_IncompatWideStringIntoWideChar,\n\n    /// Initializing char8_t array with plain string literal.\n    FK_PlainStringIntoUTF8Char,\n\n    /// Initializing char array with UTF-8 string literal.\n    FK_UTF8StringIntoPlainChar,\n\n    /// Array type mismatch.\n    FK_ArrayTypeMismatch,\n\n    /// Non-constant array initializer\n    FK_NonConstantArrayInit,\n\n    /// Cannot resolve the address of an overloaded function.\n    FK_AddressOfOverloadFailed,\n\n    /// Overloading due to reference initialization failed.\n    FK_ReferenceInitOverloadFailed,\n\n    /// Non-const lvalue reference binding to a temporary.\n    FK_NonConstLValueReferenceBindingToTemporary,\n\n    /// Non-const lvalue reference binding to a bit-field.\n    FK_NonConstLValueReferenceBindingToBitfield,\n\n    /// Non-const lvalue reference binding to a vector element.\n    FK_NonConstLValueReferenceBindingToVectorElement,\n\n    /// Non-const lvalue reference binding to a matrix element.\n    FK_NonConstLValueReferenceBindingToMatrixElement,\n\n    /// Non-const lvalue reference binding to an lvalue of unrelated\n    /// type.\n    FK_NonConstLValueReferenceBindingToUnrelated,\n\n    /// Rvalue reference binding to an lvalue.\n    FK_RValueReferenceBindingToLValue,\n\n    /// Reference binding drops qualifiers.\n    FK_ReferenceInitDropsQualifiers,\n\n    /// Reference with mismatching address space binding to temporary.\n    FK_ReferenceAddrspaceMismatchTemporary,\n\n    /// Reference binding failed.\n    FK_ReferenceInitFailed,\n\n    /// Implicit conversion failed.\n    FK_ConversionFailed,\n\n    /// Implicit conversion failed.\n    FK_ConversionFromPropertyFailed,\n\n    /// Too many initializers for scalar\n    FK_TooManyInitsForScalar,\n\n    /// Scalar initialized from a parenthesized initializer list.\n    FK_ParenthesizedListInitForScalar,\n\n    /// Reference initialization from an initializer list\n    FK_ReferenceBindingToInitList,\n\n    /// Initialization of some unused destination type with an\n    /// initializer list.\n    FK_InitListBadDestinationType,\n\n    /// Overloading for a user-defined conversion failed.\n    FK_UserConversionOverloadFailed,\n\n    /// Overloading for initialization by constructor failed.\n    FK_ConstructorOverloadFailed,\n\n    /// Overloading for list-initialization by constructor failed.\n    FK_ListConstructorOverloadFailed,\n\n    /// Default-initialization of a 'const' object.\n    FK_DefaultInitOfConst,\n\n    /// Initialization of an incomplete type.\n    FK_Incomplete,\n\n    /// Variable-length array must not have an initializer.\n    FK_VariableLengthArrayHasInitializer,\n\n    /// List initialization failed at some point.\n    FK_ListInitializationFailed,\n\n    /// Initializer has a placeholder type which cannot be\n    /// resolved by initialization.\n    FK_PlaceholderType,\n\n    /// Trying to take the address of a function that doesn't support\n    /// having its address taken.\n    FK_AddressOfUnaddressableFunction,\n\n    /// List-copy-initialization chose an explicit constructor.\n    FK_ExplicitConstructor,\n  };\n\nprivate:\n  /// The reason why initialization failed.\n  FailureKind Failure;\n\n  /// The failed result of overload resolution.\n  OverloadingResult FailedOverloadResult;\n\n  /// The candidate set created when initialization failed.\n  OverloadCandidateSet FailedCandidateSet;\n\n  /// The incomplete type that caused a failure.\n  QualType FailedIncompleteType;\n\n  /// The fixit that needs to be applied to make this initialization\n  /// succeed.\n  std::string ZeroInitializationFixit;\n  SourceLocation ZeroInitializationFixitLoc;\n\npublic:\n  /// Call for initializations are invalid but that would be valid\n  /// zero initialzations if Fixit was applied.\n  void SetZeroInitializationFixit(const std::string& Fixit, SourceLocation L) {\n    ZeroInitializationFixit = Fixit;\n    ZeroInitializationFixitLoc = L;\n  }\n\nprivate:\n  /// Prints a follow-up note that highlights the location of\n  /// the initialized entity, if it's remote.\n  void PrintInitLocationNote(Sema &S, const InitializedEntity &Entity);\n\npublic:\n  /// Try to perform initialization of the given entity, creating a\n  /// record of the steps required to perform the initialization.\n  ///\n  /// The generated initialization sequence will either contain enough\n  /// information to diagnose\n  ///\n  /// \\param S the semantic analysis object.\n  ///\n  /// \\param Entity the entity being initialized.\n  ///\n  /// \\param Kind the kind of initialization being performed.\n  ///\n  /// \\param Args the argument(s) provided for initialization.\n  ///\n  /// \\param TopLevelOfInitList true if we are initializing from an expression\n  ///        at the top level inside an initializer list. This disallows\n  ///        narrowing conversions in C++11 onwards.\n  /// \\param TreatUnavailableAsInvalid true if we want to treat unavailable\n  ///        as invalid.\n  InitializationSequence(Sema &S,\n                         const InitializedEntity &Entity,\n                         const InitializationKind &Kind,\n                         MultiExprArg Args,\n                         bool TopLevelOfInitList = false,\n                         bool TreatUnavailableAsInvalid = true);\n  void InitializeFrom(Sema &S, const InitializedEntity &Entity,\n                      const InitializationKind &Kind, MultiExprArg Args,\n                      bool TopLevelOfInitList, bool TreatUnavailableAsInvalid);\n\n  ~InitializationSequence();\n\n  /// Perform the actual initialization of the given entity based on\n  /// the computed initialization sequence.\n  ///\n  /// \\param S the semantic analysis object.\n  ///\n  /// \\param Entity the entity being initialized.\n  ///\n  /// \\param Kind the kind of initialization being performed.\n  ///\n  /// \\param Args the argument(s) provided for initialization, ownership of\n  /// which is transferred into the routine.\n  ///\n  /// \\param ResultType if non-NULL, will be set to the type of the\n  /// initialized object, which is the type of the declaration in most\n  /// cases. However, when the initialized object is a variable of\n  /// incomplete array type and the initializer is an initializer\n  /// list, this type will be set to the completed array type.\n  ///\n  /// \\returns an expression that performs the actual object initialization, if\n  /// the initialization is well-formed. Otherwise, emits diagnostics\n  /// and returns an invalid expression.\n  ExprResult Perform(Sema &S,\n                     const InitializedEntity &Entity,\n                     const InitializationKind &Kind,\n                     MultiExprArg Args,\n                     QualType *ResultType = nullptr);\n\n  /// Diagnose an potentially-invalid initialization sequence.\n  ///\n  /// \\returns true if the initialization sequence was ill-formed,\n  /// false otherwise.\n  bool Diagnose(Sema &S,\n                const InitializedEntity &Entity,\n                const InitializationKind &Kind,\n                ArrayRef<Expr *> Args);\n\n  /// Determine the kind of initialization sequence computed.\n  enum SequenceKind getKind() const { return SequenceKind; }\n\n  /// Set the kind of sequence computed.\n  void setSequenceKind(enum SequenceKind SK) { SequenceKind = SK; }\n\n  /// Determine whether the initialization sequence is valid.\n  explicit operator bool() const { return !Failed(); }\n\n  /// Determine whether the initialization sequence is invalid.\n  bool Failed() const { return SequenceKind == FailedSequence; }\n\n  using step_iterator = SmallVectorImpl<Step>::const_iterator;\n\n  step_iterator step_begin() const { return Steps.begin(); }\n  step_iterator step_end()   const { return Steps.end(); }\n\n  using step_range = llvm::iterator_range<step_iterator>;\n\n  step_range steps() const { return {step_begin(), step_end()}; }\n\n  /// Determine whether this initialization is a direct reference\n  /// binding (C++ [dcl.init.ref]).\n  bool isDirectReferenceBinding() const;\n\n  /// Determine whether this initialization failed due to an ambiguity.\n  bool isAmbiguous() const;\n\n  /// Determine whether this initialization is direct call to a\n  /// constructor.\n  bool isConstructorInitialization() const;\n\n  /// Add a new step in the initialization that resolves the address\n  /// of an overloaded function to a specific function declaration.\n  ///\n  /// \\param Function the function to which the overloaded function reference\n  /// resolves.\n  void AddAddressOverloadResolutionStep(FunctionDecl *Function,\n                                        DeclAccessPair Found,\n                                        bool HadMultipleCandidates);\n\n  /// Add a new step in the initialization that performs a derived-to-\n  /// base cast.\n  ///\n  /// \\param BaseType the base type to which we will be casting.\n  ///\n  /// \\param Category Indicates whether the result will be treated as an\n  /// rvalue, an xvalue, or an lvalue.\n  void AddDerivedToBaseCastStep(QualType BaseType,\n                                ExprValueKind Category);\n\n  /// Add a new step binding a reference to an object.\n  ///\n  /// \\param BindingTemporary True if we are binding a reference to a temporary\n  /// object (thereby extending its lifetime); false if we are binding to an\n  /// lvalue or an lvalue treated as an rvalue.\n  void AddReferenceBindingStep(QualType T, bool BindingTemporary);\n\n  /// Add a new step that makes an extraneous copy of the input\n  /// to a temporary of the same class type.\n  ///\n  /// This extraneous copy only occurs during reference binding in\n  /// C++98/03, where we are permitted (but not required) to introduce\n  /// an extra copy. At a bare minimum, we must check that we could\n  /// call the copy constructor, and produce a diagnostic if the copy\n  /// constructor is inaccessible or no copy constructor matches.\n  //\n  /// \\param T The type of the temporary being created.\n  void AddExtraneousCopyToTemporary(QualType T);\n\n  /// Add a new step that makes a copy of the input to an object of\n  /// the given type, as the final step in class copy-initialization.\n  void AddFinalCopy(QualType T);\n\n  /// Add a new step invoking a conversion function, which is either\n  /// a constructor or a conversion function.\n  void AddUserConversionStep(FunctionDecl *Function,\n                             DeclAccessPair FoundDecl,\n                             QualType T,\n                             bool HadMultipleCandidates);\n\n  /// Add a new step that performs a qualification conversion to the\n  /// given type.\n  void AddQualificationConversionStep(QualType Ty,\n                                     ExprValueKind Category);\n\n  /// Add a new step that performs a function reference conversion to the\n  /// given type.\n  void AddFunctionReferenceConversionStep(QualType Ty);\n\n  /// Add a new step that performs conversion from non-atomic to atomic\n  /// type.\n  void AddAtomicConversionStep(QualType Ty);\n\n  /// Add a new step that applies an implicit conversion sequence.\n  void AddConversionSequenceStep(const ImplicitConversionSequence &ICS,\n                                 QualType T, bool TopLevelOfInitList = false);\n\n  /// Add a list-initialization step.\n  void AddListInitializationStep(QualType T);\n\n  /// Add a constructor-initialization step.\n  ///\n  /// \\param FromInitList The constructor call is syntactically an initializer\n  /// list.\n  /// \\param AsInitList The constructor is called as an init list constructor.\n  void AddConstructorInitializationStep(DeclAccessPair FoundDecl,\n                                        CXXConstructorDecl *Constructor,\n                                        QualType T,\n                                        bool HadMultipleCandidates,\n                                        bool FromInitList, bool AsInitList);\n\n  /// Add a zero-initialization step.\n  void AddZeroInitializationStep(QualType T);\n\n  /// Add a C assignment step.\n  //\n  // FIXME: It isn't clear whether this should ever be needed;\n  // ideally, we would handle everything needed in C in the common\n  // path. However, that isn't the case yet.\n  void AddCAssignmentStep(QualType T);\n\n  /// Add a string init step.\n  void AddStringInitStep(QualType T);\n\n  /// Add an Objective-C object conversion step, which is\n  /// always a no-op.\n  void AddObjCObjectConversionStep(QualType T);\n\n  /// Add an array initialization loop step.\n  void AddArrayInitLoopStep(QualType T, QualType EltTy);\n\n  /// Add an array initialization step.\n  void AddArrayInitStep(QualType T, bool IsGNUExtension);\n\n  /// Add a parenthesized array initialization step.\n  void AddParenthesizedArrayInitStep(QualType T);\n\n  /// Add a step to pass an object by indirect copy-restore.\n  void AddPassByIndirectCopyRestoreStep(QualType T, bool shouldCopy);\n\n  /// Add a step to \"produce\" an Objective-C object (by\n  /// retaining it).\n  void AddProduceObjCObjectStep(QualType T);\n\n  /// Add a step to construct a std::initializer_list object from an\n  /// initializer list.\n  void AddStdInitializerListConstructionStep(QualType T);\n\n  /// Add a step to initialize an OpenCL sampler from an integer\n  /// constant.\n  void AddOCLSamplerInitStep(QualType T);\n\n  /// Add a step to initialzie an OpenCL opaque type (event_t, queue_t, etc.)\n  /// from a zero constant.\n  void AddOCLZeroOpaqueTypeStep(QualType T);\n\n  /// Add steps to unwrap a initializer list for a reference around a\n  /// single element and rewrap it at the end.\n  void RewrapReferenceInitList(QualType T, InitListExpr *Syntactic);\n\n  /// Note that this initialization sequence failed.\n  void SetFailed(FailureKind Failure) {\n    SequenceKind = FailedSequence;\n    this->Failure = Failure;\n    assert((Failure != FK_Incomplete || !FailedIncompleteType.isNull()) &&\n           \"Incomplete type failure requires a type!\");\n  }\n\n  /// Note that this initialization sequence failed due to failed\n  /// overload resolution.\n  void SetOverloadFailure(FailureKind Failure, OverloadingResult Result);\n\n  /// Retrieve a reference to the candidate set when overload\n  /// resolution fails.\n  OverloadCandidateSet &getFailedCandidateSet() {\n    return FailedCandidateSet;\n  }\n\n  /// Get the overloading result, for when the initialization\n  /// sequence failed due to a bad overload.\n  OverloadingResult getFailedOverloadResult() const {\n    return FailedOverloadResult;\n  }\n\n  /// Note that this initialization sequence failed due to an\n  /// incomplete type.\n  void setIncompleteTypeFailure(QualType IncompleteType) {\n    FailedIncompleteType = IncompleteType;\n    SetFailed(FK_Incomplete);\n  }\n\n  /// Determine why initialization failed.\n  FailureKind getFailureKind() const {\n    assert(Failed() && \"Not an initialization failure!\");\n    return Failure;\n  }\n\n  /// Dump a representation of this initialization sequence to\n  /// the given stream, for debugging purposes.\n  void dump(raw_ostream &OS) const;\n\n  /// Dump a representation of this initialization sequence to\n  /// standard error, for debugging purposes.\n  void dump() const;\n};\n\n} // namespace clang\n\n#endif // LLVM_CLANG_SEMA_INITIALIZATION_H\n"}, "31": {"id": 31, "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Sema/Overload.h", "content": "//===- Overload.h - C++ Overloading -----------------------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// This file defines the data structures and types used in C++\n// overload resolution.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_CLANG_SEMA_OVERLOAD_H\n#define LLVM_CLANG_SEMA_OVERLOAD_H\n\n#include \"clang/AST/Decl.h\"\n#include \"clang/AST/DeclAccessPair.h\"\n#include \"clang/AST/DeclBase.h\"\n#include \"clang/AST/DeclCXX.h\"\n#include \"clang/AST/DeclTemplate.h\"\n#include \"clang/AST/Expr.h\"\n#include \"clang/AST/Type.h\"\n#include \"clang/Basic/LLVM.h\"\n#include \"clang/Basic/SourceLocation.h\"\n#include \"clang/Sema/SemaFixItUtils.h\"\n#include \"clang/Sema/TemplateDeduction.h\"\n#include \"llvm/ADT/ArrayRef.h\"\n#include \"llvm/ADT/None.h\"\n#include \"llvm/ADT/STLExtras.h\"\n#include \"llvm/ADT/SmallPtrSet.h\"\n#include \"llvm/ADT/SmallVector.h\"\n#include \"llvm/ADT/StringRef.h\"\n#include \"llvm/Support/AlignOf.h\"\n#include \"llvm/Support/Allocator.h\"\n#include \"llvm/Support/Casting.h\"\n#include \"llvm/Support/ErrorHandling.h\"\n#include <cassert>\n#include <cstddef>\n#include <cstdint>\n#include <utility>\n\nnamespace clang {\n\nclass APValue;\nclass ASTContext;\nclass Sema;\n\n  /// OverloadingResult - Capture the result of performing overload\n  /// resolution.\n  enum OverloadingResult {\n    /// Overload resolution succeeded.\n    OR_Success,\n\n    /// No viable function found.\n    OR_No_Viable_Function,\n\n    /// Ambiguous candidates found.\n    OR_Ambiguous,\n\n    /// Succeeded, but refers to a deleted function.\n    OR_Deleted\n  };\n\n  enum OverloadCandidateDisplayKind {\n    /// Requests that all candidates be shown.  Viable candidates will\n    /// be printed first.\n    OCD_AllCandidates,\n\n    /// Requests that only viable candidates be shown.\n    OCD_ViableCandidates,\n\n    /// Requests that only tied-for-best candidates be shown.\n    OCD_AmbiguousCandidates\n  };\n\n  /// The parameter ordering that will be used for the candidate. This is\n  /// used to represent C++20 binary operator rewrites that reverse the order\n  /// of the arguments. If the parameter ordering is Reversed, the Args list is\n  /// reversed (but obviously the ParamDecls for the function are not).\n  ///\n  /// After forming an OverloadCandidate with reversed parameters, the list\n  /// of conversions will (as always) be indexed by argument, so will be\n  /// in reverse parameter order.\n  enum class OverloadCandidateParamOrder : char { Normal, Reversed };\n\n  /// The kinds of rewrite we perform on overload candidates. Note that the\n  /// values here are chosen to serve as both bitflags and as a rank (lower\n  /// values are preferred by overload resolution).\n  enum OverloadCandidateRewriteKind : unsigned {\n    /// Candidate is not a rewritten candidate.\n    CRK_None = 0x0,\n\n    /// Candidate is a rewritten candidate with a different operator name.\n    CRK_DifferentOperator = 0x1,\n\n    /// Candidate is a rewritten candidate with a reversed order of parameters.\n    CRK_Reversed = 0x2,\n  };\n\n  /// ImplicitConversionKind - The kind of implicit conversion used to\n  /// convert an argument to a parameter's type. The enumerator values\n  /// match with the table titled 'Conversions' in [over.ics.scs] and are listed\n  /// such that better conversion kinds have smaller values.\n  enum ImplicitConversionKind {\n    /// Identity conversion (no conversion)\n    ICK_Identity = 0,\n\n    /// Lvalue-to-rvalue conversion (C++ [conv.lval])\n    ICK_Lvalue_To_Rvalue,\n\n    /// Array-to-pointer conversion (C++ [conv.array])\n    ICK_Array_To_Pointer,\n\n    /// Function-to-pointer (C++ [conv.array])\n    ICK_Function_To_Pointer,\n\n    /// Function pointer conversion (C++17 [conv.fctptr])\n    ICK_Function_Conversion,\n\n    /// Qualification conversions (C++ [conv.qual])\n    ICK_Qualification,\n\n    /// Integral promotions (C++ [conv.prom])\n    ICK_Integral_Promotion,\n\n    /// Floating point promotions (C++ [conv.fpprom])\n    ICK_Floating_Promotion,\n\n    /// Complex promotions (Clang extension)\n    ICK_Complex_Promotion,\n\n    /// Integral conversions (C++ [conv.integral])\n    ICK_Integral_Conversion,\n\n    /// Floating point conversions (C++ [conv.double]\n    ICK_Floating_Conversion,\n\n    /// Complex conversions (C99 6.3.1.6)\n    ICK_Complex_Conversion,\n\n    /// Floating-integral conversions (C++ [conv.fpint])\n    ICK_Floating_Integral,\n\n    /// Pointer conversions (C++ [conv.ptr])\n    ICK_Pointer_Conversion,\n\n    /// Pointer-to-member conversions (C++ [conv.mem])\n    ICK_Pointer_Member,\n\n    /// Boolean conversions (C++ [conv.bool])\n    ICK_Boolean_Conversion,\n\n    /// Conversions between compatible types in C99\n    ICK_Compatible_Conversion,\n\n    /// Derived-to-base (C++ [over.best.ics])\n    ICK_Derived_To_Base,\n\n    /// Vector conversions\n    ICK_Vector_Conversion,\n\n    /// Arm SVE Vector conversions\n    ICK_SVE_Vector_Conversion,\n\n    /// A vector splat from an arithmetic type\n    ICK_Vector_Splat,\n\n    /// Complex-real conversions (C99 6.3.1.7)\n    ICK_Complex_Real,\n\n    /// Block Pointer conversions\n    ICK_Block_Pointer_Conversion,\n\n    /// Transparent Union Conversions\n    ICK_TransparentUnionConversion,\n\n    /// Objective-C ARC writeback conversion\n    ICK_Writeback_Conversion,\n\n    /// Zero constant to event (OpenCL1.2 6.12.10)\n    ICK_Zero_Event_Conversion,\n\n    /// Zero constant to queue\n    ICK_Zero_Queue_Conversion,\n\n    /// Conversions allowed in C, but not C++\n    ICK_C_Only_Conversion,\n\n    /// C-only conversion between pointers with incompatible types\n    ICK_Incompatible_Pointer_Conversion,\n\n    /// The number of conversion kinds\n    ICK_Num_Conversion_Kinds,\n  };\n\n  /// ImplicitConversionRank - The rank of an implicit conversion\n  /// kind. The enumerator values match with Table 9 of (C++\n  /// 13.3.3.1.1) and are listed such that better conversion ranks\n  /// have smaller values.\n  enum ImplicitConversionRank {\n    /// Exact Match\n    ICR_Exact_Match = 0,\n\n    /// Promotion\n    ICR_Promotion,\n\n    /// Conversion\n    ICR_Conversion,\n\n    /// OpenCL Scalar Widening\n    ICR_OCL_Scalar_Widening,\n\n    /// Complex <-> Real conversion\n    ICR_Complex_Real_Conversion,\n\n    /// ObjC ARC writeback conversion\n    ICR_Writeback_Conversion,\n\n    /// Conversion only allowed in the C standard (e.g. void* to char*).\n    ICR_C_Conversion,\n\n    /// Conversion not allowed by the C standard, but that we accept as an\n    /// extension anyway.\n    ICR_C_Conversion_Extension\n  };\n\n  ImplicitConversionRank GetConversionRank(ImplicitConversionKind Kind);\n\n  /// NarrowingKind - The kind of narrowing conversion being performed by a\n  /// standard conversion sequence according to C++11 [dcl.init.list]p7.\n  enum NarrowingKind {\n    /// Not a narrowing conversion.\n    NK_Not_Narrowing,\n\n    /// A narrowing conversion by virtue of the source and destination types.\n    NK_Type_Narrowing,\n\n    /// A narrowing conversion, because a constant expression got narrowed.\n    NK_Constant_Narrowing,\n\n    /// A narrowing conversion, because a non-constant-expression variable might\n    /// have got narrowed.\n    NK_Variable_Narrowing,\n\n    /// Cannot tell whether this is a narrowing conversion because the\n    /// expression is value-dependent.\n    NK_Dependent_Narrowing,\n  };\n\n  /// StandardConversionSequence - represents a standard conversion\n  /// sequence (C++ 13.3.3.1.1). A standard conversion sequence\n  /// contains between zero and three conversions. If a particular\n  /// conversion is not needed, it will be set to the identity conversion\n  /// (ICK_Identity). Note that the three conversions are\n  /// specified as separate members (rather than in an array) so that\n  /// we can keep the size of a standard conversion sequence to a\n  /// single word.\n  class StandardConversionSequence {\n  public:\n    /// First -- The first conversion can be an lvalue-to-rvalue\n    /// conversion, array-to-pointer conversion, or\n    /// function-to-pointer conversion.\n    ImplicitConversionKind First : 8;\n\n    /// Second - The second conversion can be an integral promotion,\n    /// floating point promotion, integral conversion, floating point\n    /// conversion, floating-integral conversion, pointer conversion,\n    /// pointer-to-member conversion, or boolean conversion.\n    ImplicitConversionKind Second : 8;\n\n    /// Third - The third conversion can be a qualification conversion\n    /// or a function conversion.\n    ImplicitConversionKind Third : 8;\n\n    /// Whether this is the deprecated conversion of a\n    /// string literal to a pointer to non-const character data\n    /// (C++ 4.2p2).\n    unsigned DeprecatedStringLiteralToCharPtr : 1;\n\n    /// Whether the qualification conversion involves a change in the\n    /// Objective-C lifetime (for automatic reference counting).\n    unsigned QualificationIncludesObjCLifetime : 1;\n\n    /// IncompatibleObjC - Whether this is an Objective-C conversion\n    /// that we should warn about (if we actually use it).\n    unsigned IncompatibleObjC : 1;\n\n    /// ReferenceBinding - True when this is a reference binding\n    /// (C++ [over.ics.ref]).\n    unsigned ReferenceBinding : 1;\n\n    /// DirectBinding - True when this is a reference binding that is a\n    /// direct binding (C++ [dcl.init.ref]).\n    unsigned DirectBinding : 1;\n\n    /// Whether this is an lvalue reference binding (otherwise, it's\n    /// an rvalue reference binding).\n    unsigned IsLvalueReference : 1;\n\n    /// Whether we're binding to a function lvalue.\n    unsigned BindsToFunctionLvalue : 1;\n\n    /// Whether we're binding to an rvalue.\n    unsigned BindsToRvalue : 1;\n\n    /// Whether this binds an implicit object argument to a\n    /// non-static member function without a ref-qualifier.\n    unsigned BindsImplicitObjectArgumentWithoutRefQualifier : 1;\n\n    /// Whether this binds a reference to an object with a different\n    /// Objective-C lifetime qualifier.\n    unsigned ObjCLifetimeConversionBinding : 1;\n\n    /// FromType - The type that this conversion is converting\n    /// from. This is an opaque pointer that can be translated into a\n    /// QualType.\n    void *FromTypePtr;\n\n    /// ToType - The types that this conversion is converting to in\n    /// each step. This is an opaque pointer that can be translated\n    /// into a QualType.\n    void *ToTypePtrs[3];\n\n    /// CopyConstructor - The copy constructor that is used to perform\n    /// this conversion, when the conversion is actually just the\n    /// initialization of an object via copy constructor. Such\n    /// conversions are either identity conversions or derived-to-base\n    /// conversions.\n    CXXConstructorDecl *CopyConstructor;\n    DeclAccessPair FoundCopyConstructor;\n\n    void setFromType(QualType T) { FromTypePtr = T.getAsOpaquePtr(); }\n\n    void setToType(unsigned Idx, QualType T) {\n      assert(Idx < 3 && \"To type index is out of range\");\n      ToTypePtrs[Idx] = T.getAsOpaquePtr();\n    }\n\n    void setAllToTypes(QualType T) {\n      ToTypePtrs[0] = T.getAsOpaquePtr();\n      ToTypePtrs[1] = ToTypePtrs[0];\n      ToTypePtrs[2] = ToTypePtrs[0];\n    }\n\n    QualType getFromType() const {\n      return QualType::getFromOpaquePtr(FromTypePtr);\n    }\n\n    QualType getToType(unsigned Idx) const {\n      assert(Idx < 3 && \"To type index is out of range\");\n      return QualType::getFromOpaquePtr(ToTypePtrs[Idx]);\n    }\n\n    void setAsIdentityConversion();\n\n    bool isIdentityConversion() const {\n      return Second == ICK_Identity && Third == ICK_Identity;\n    }\n\n    ImplicitConversionRank getRank() const;\n    NarrowingKind\n    getNarrowingKind(ASTContext &Context, const Expr *Converted,\n                     APValue &ConstantValue, QualType &ConstantType,\n                     bool IgnoreFloatToIntegralConversion = false) const;\n    bool isPointerConversionToBool() const;\n    bool isPointerConversionToVoidPointer(ASTContext& Context) const;\n    void dump() const;\n  };\n\n  /// UserDefinedConversionSequence - Represents a user-defined\n  /// conversion sequence (C++ 13.3.3.1.2).\n  struct UserDefinedConversionSequence {\n    /// Represents the standard conversion that occurs before\n    /// the actual user-defined conversion.\n    ///\n    /// C++11 13.3.3.1.2p1:\n    ///   If the user-defined conversion is specified by a constructor\n    ///   (12.3.1), the initial standard conversion sequence converts\n    ///   the source type to the type required by the argument of the\n    ///   constructor. If the user-defined conversion is specified by\n    ///   a conversion function (12.3.2), the initial standard\n    ///   conversion sequence converts the source type to the implicit\n    ///   object parameter of the conversion function.\n    StandardConversionSequence Before;\n\n    /// EllipsisConversion - When this is true, it means user-defined\n    /// conversion sequence starts with a ... (ellipsis) conversion, instead of\n    /// a standard conversion. In this case, 'Before' field must be ignored.\n    // FIXME. I much rather put this as the first field. But there seems to be\n    // a gcc code gen. bug which causes a crash in a test. Putting it here seems\n    // to work around the crash.\n    bool EllipsisConversion : 1;\n\n    /// HadMultipleCandidates - When this is true, it means that the\n    /// conversion function was resolved from an overloaded set having\n    /// size greater than 1.\n    bool HadMultipleCandidates : 1;\n\n    /// After - Represents the standard conversion that occurs after\n    /// the actual user-defined conversion.\n    StandardConversionSequence After;\n\n    /// ConversionFunction - The function that will perform the\n    /// user-defined conversion. Null if the conversion is an\n    /// aggregate initialization from an initializer list.\n    FunctionDecl* ConversionFunction;\n\n    /// The declaration that we found via name lookup, which might be\n    /// the same as \\c ConversionFunction or it might be a using declaration\n    /// that refers to \\c ConversionFunction.\n    DeclAccessPair FoundConversionFunction;\n\n    void dump() const;\n  };\n\n  /// Represents an ambiguous user-defined conversion sequence.\n  struct AmbiguousConversionSequence {\n    using ConversionSet =\n        SmallVector<std::pair<NamedDecl *, FunctionDecl *>, 4>;\n\n    void *FromTypePtr;\n    void *ToTypePtr;\n    char Buffer[sizeof(ConversionSet)];\n\n    QualType getFromType() const {\n      return QualType::getFromOpaquePtr(FromTypePtr);\n    }\n\n    QualType getToType() const {\n      return QualType::getFromOpaquePtr(ToTypePtr);\n    }\n\n    void setFromType(QualType T) { FromTypePtr = T.getAsOpaquePtr(); }\n    void setToType(QualType T) { ToTypePtr = T.getAsOpaquePtr(); }\n\n    ConversionSet &conversions() {\n      return *reinterpret_cast<ConversionSet*>(Buffer);\n    }\n\n    const ConversionSet &conversions() const {\n      return *reinterpret_cast<const ConversionSet*>(Buffer);\n    }\n\n    void addConversion(NamedDecl *Found, FunctionDecl *D) {\n      conversions().push_back(std::make_pair(Found, D));\n    }\n\n    using iterator = ConversionSet::iterator;\n\n    iterator begin() { return conversions().begin(); }\n    iterator end() { return conversions().end(); }\n\n    using const_iterator = ConversionSet::const_iterator;\n\n    const_iterator begin() const { return conversions().begin(); }\n    const_iterator end() const { return conversions().end(); }\n\n    void construct();\n    void destruct();\n    void copyFrom(const AmbiguousConversionSequence &);\n  };\n\n  /// BadConversionSequence - Records information about an invalid\n  /// conversion sequence.\n  struct BadConversionSequence {\n    enum FailureKind {\n      no_conversion,\n      unrelated_class,\n      bad_qualifiers,\n      lvalue_ref_to_rvalue,\n      rvalue_ref_to_lvalue\n    };\n\n    // This can be null, e.g. for implicit object arguments.\n    Expr *FromExpr;\n\n    FailureKind Kind;\n\n  private:\n    // The type we're converting from (an opaque QualType).\n    void *FromTy;\n\n    // The type we're converting to (an opaque QualType).\n    void *ToTy;\n\n  public:\n    void init(FailureKind K, Expr *From, QualType To) {\n      init(K, From->getType(), To);\n      FromExpr = From;\n    }\n\n    void init(FailureKind K, QualType From, QualType To) {\n      Kind = K;\n      FromExpr = nullptr;\n      setFromType(From);\n      setToType(To);\n    }\n\n    QualType getFromType() const { return QualType::getFromOpaquePtr(FromTy); }\n    QualType getToType() const { return QualType::getFromOpaquePtr(ToTy); }\n\n    void setFromExpr(Expr *E) {\n      FromExpr = E;\n      setFromType(E->getType());\n    }\n\n    void setFromType(QualType T) { FromTy = T.getAsOpaquePtr(); }\n    void setToType(QualType T) { ToTy = T.getAsOpaquePtr(); }\n  };\n\n  /// ImplicitConversionSequence - Represents an implicit conversion\n  /// sequence, which may be a standard conversion sequence\n  /// (C++ 13.3.3.1.1), user-defined conversion sequence (C++ 13.3.3.1.2),\n  /// or an ellipsis conversion sequence (C++ 13.3.3.1.3).\n  class ImplicitConversionSequence {\n  public:\n    /// Kind - The kind of implicit conversion sequence. BadConversion\n    /// specifies that there is no conversion from the source type to\n    /// the target type.  AmbiguousConversion represents the unique\n    /// ambiguous conversion (C++0x [over.best.ics]p10).\n    enum Kind {\n      StandardConversion = 0,\n      UserDefinedConversion,\n      AmbiguousConversion,\n      EllipsisConversion,\n      BadConversion\n    };\n\n  private:\n    enum {\n      Uninitialized = BadConversion + 1\n    };\n\n    /// ConversionKind - The kind of implicit conversion sequence.\n    unsigned ConversionKind : 30;\n\n    /// Whether the target is really a std::initializer_list, and the\n    /// sequence only represents the worst element conversion.\n    unsigned StdInitializerListElement : 1;\n\n    void setKind(Kind K) {\n      destruct();\n      ConversionKind = K;\n    }\n\n    void destruct() {\n      if (ConversionKind == AmbiguousConversion) Ambiguous.destruct();\n    }\n\n  public:\n    union {\n      /// When ConversionKind == StandardConversion, provides the\n      /// details of the standard conversion sequence.\n      StandardConversionSequence Standard;\n\n      /// When ConversionKind == UserDefinedConversion, provides the\n      /// details of the user-defined conversion sequence.\n      UserDefinedConversionSequence UserDefined;\n\n      /// When ConversionKind == AmbiguousConversion, provides the\n      /// details of the ambiguous conversion.\n      AmbiguousConversionSequence Ambiguous;\n\n      /// When ConversionKind == BadConversion, provides the details\n      /// of the bad conversion.\n      BadConversionSequence Bad;\n    };\n\n    ImplicitConversionSequence()\n        : ConversionKind(Uninitialized), StdInitializerListElement(false) {\n      Standard.setAsIdentityConversion();\n    }\n\n    ImplicitConversionSequence(const ImplicitConversionSequence &Other)\n        : ConversionKind(Other.ConversionKind),\n          StdInitializerListElement(Other.StdInitializerListElement) {\n      switch (ConversionKind) {\n      case Uninitialized: break;\n      case StandardConversion: Standard = Other.Standard; break;\n      case UserDefinedConversion: UserDefined = Other.UserDefined; break;\n      case AmbiguousConversion: Ambiguous.copyFrom(Other.Ambiguous); break;\n      case EllipsisConversion: break;\n      case BadConversion: Bad = Other.Bad; break;\n      }\n    }\n\n    ImplicitConversionSequence &\n    operator=(const ImplicitConversionSequence &Other) {\n      destruct();\n      new (this) ImplicitConversionSequence(Other);\n      return *this;\n    }\n\n    ~ImplicitConversionSequence() {\n      destruct();\n    }\n\n    Kind getKind() const {\n      assert(isInitialized() && \"querying uninitialized conversion\");\n      return Kind(ConversionKind);\n    }\n\n    /// Return a ranking of the implicit conversion sequence\n    /// kind, where smaller ranks represent better conversion\n    /// sequences.\n    ///\n    /// In particular, this routine gives user-defined conversion\n    /// sequences and ambiguous conversion sequences the same rank,\n    /// per C++ [over.best.ics]p10.\n    unsigned getKindRank() const {\n      switch (getKind()) {\n      case StandardConversion:\n        return 0;\n\n      case UserDefinedConversion:\n      case AmbiguousConversion:\n        return 1;\n\n      case EllipsisConversion:\n        return 2;\n\n      case BadConversion:\n        return 3;\n      }\n\n      llvm_unreachable(\"Invalid ImplicitConversionSequence::Kind!\");\n    }\n\n    bool isBad() const { return getKind() == BadConversion; }\n    bool isStandard() const { return getKind() == StandardConversion; }\n    bool isEllipsis() const { return getKind() == EllipsisConversion; }\n    bool isAmbiguous() const { return getKind() == AmbiguousConversion; }\n    bool isUserDefined() const { return getKind() == UserDefinedConversion; }\n    bool isFailure() const { return isBad() || isAmbiguous(); }\n\n    /// Determines whether this conversion sequence has been\n    /// initialized.  Most operations should never need to query\n    /// uninitialized conversions and should assert as above.\n    bool isInitialized() const { return ConversionKind != Uninitialized; }\n\n    /// Sets this sequence as a bad conversion for an explicit argument.\n    void setBad(BadConversionSequence::FailureKind Failure,\n                Expr *FromExpr, QualType ToType) {\n      setKind(BadConversion);\n      Bad.init(Failure, FromExpr, ToType);\n    }\n\n    /// Sets this sequence as a bad conversion for an implicit argument.\n    void setBad(BadConversionSequence::FailureKind Failure,\n                QualType FromType, QualType ToType) {\n      setKind(BadConversion);\n      Bad.init(Failure, FromType, ToType);\n    }\n\n    void setStandard() { setKind(StandardConversion); }\n    void setEllipsis() { setKind(EllipsisConversion); }\n    void setUserDefined() { setKind(UserDefinedConversion); }\n\n    void setAmbiguous() {\n      if (ConversionKind == AmbiguousConversion) return;\n      ConversionKind = AmbiguousConversion;\n      Ambiguous.construct();\n    }\n\n    void setAsIdentityConversion(QualType T) {\n      setStandard();\n      Standard.setAsIdentityConversion();\n      Standard.setFromType(T);\n      Standard.setAllToTypes(T);\n    }\n\n    /// Whether the target is really a std::initializer_list, and the\n    /// sequence only represents the worst element conversion.\n    bool isStdInitializerListElement() const {\n      return StdInitializerListElement;\n    }\n\n    void setStdInitializerListElement(bool V = true) {\n      StdInitializerListElement = V;\n    }\n\n    /// Form an \"implicit\" conversion sequence from nullptr_t to bool, for a\n    /// direct-initialization of a bool object from nullptr_t.\n    static ImplicitConversionSequence getNullptrToBool(QualType SourceType,\n                                                       QualType DestType,\n                                                       bool NeedLValToRVal) {\n      ImplicitConversionSequence ICS;\n      ICS.setStandard();\n      ICS.Standard.setAsIdentityConversion();\n      ICS.Standard.setFromType(SourceType);\n      if (NeedLValToRVal)\n        ICS.Standard.First = ICK_Lvalue_To_Rvalue;\n      ICS.Standard.setToType(0, SourceType);\n      ICS.Standard.Second = ICK_Boolean_Conversion;\n      ICS.Standard.setToType(1, DestType);\n      ICS.Standard.setToType(2, DestType);\n      return ICS;\n    }\n\n    // The result of a comparison between implicit conversion\n    // sequences. Use Sema::CompareImplicitConversionSequences to\n    // actually perform the comparison.\n    enum CompareKind {\n      Better = -1,\n      Indistinguishable = 0,\n      Worse = 1\n    };\n\n    void DiagnoseAmbiguousConversion(Sema &S,\n                                     SourceLocation CaretLoc,\n                                     const PartialDiagnostic &PDiag) const;\n\n    void dump() const;\n  };\n\n  enum OverloadFailureKind {\n    ovl_fail_too_many_arguments,\n    ovl_fail_too_few_arguments,\n    ovl_fail_bad_conversion,\n    ovl_fail_bad_deduction,\n\n    /// This conversion candidate was not considered because it\n    /// duplicates the work of a trivial or derived-to-base\n    /// conversion.\n    ovl_fail_trivial_conversion,\n\n    /// This conversion candidate was not considered because it is\n    /// an illegal instantiation of a constructor temploid: it is\n    /// callable with one argument, we only have one argument, and\n    /// its first parameter type is exactly the type of the class.\n    ///\n    /// Defining such a constructor directly is illegal, and\n    /// template-argument deduction is supposed to ignore such\n    /// instantiations, but we can still get one with the right\n    /// kind of implicit instantiation.\n    ovl_fail_illegal_constructor,\n\n    /// This conversion candidate is not viable because its result\n    /// type is not implicitly convertible to the desired type.\n    ovl_fail_bad_final_conversion,\n\n    /// This conversion function template specialization candidate is not\n    /// viable because the final conversion was not an exact match.\n    ovl_fail_final_conversion_not_exact,\n\n    /// (CUDA) This candidate was not viable because the callee\n    /// was not accessible from the caller's target (i.e. host->device,\n    /// global->host, device->host).\n    ovl_fail_bad_target,\n\n    /// This candidate function was not viable because an enable_if\n    /// attribute disabled it.\n    ovl_fail_enable_if,\n\n    /// This candidate constructor or conversion function is explicit but\n    /// the context doesn't permit explicit functions.\n    ovl_fail_explicit,\n\n    /// This candidate was not viable because its address could not be taken.\n    ovl_fail_addr_not_available,\n\n    /// This candidate was not viable because its OpenCL extension is disabled.\n    ovl_fail_ext_disabled,\n\n    /// This inherited constructor is not viable because it would slice the\n    /// argument.\n    ovl_fail_inhctor_slice,\n\n    /// This candidate was not viable because it is a non-default multiversioned\n    /// function.\n    ovl_non_default_multiversion_function,\n\n    /// This constructor/conversion candidate fail due to an address space\n    /// mismatch between the object being constructed and the overload\n    /// candidate.\n    ovl_fail_object_addrspace_mismatch,\n\n    /// This candidate was not viable because its associated constraints were\n    /// not satisfied.\n    ovl_fail_constraints_not_satisfied,\n  };\n\n  /// A list of implicit conversion sequences for the arguments of an\n  /// OverloadCandidate.\n  using ConversionSequenceList =\n      llvm::MutableArrayRef<ImplicitConversionSequence>;\n\n  /// OverloadCandidate - A single candidate in an overload set (C++ 13.3).\n  struct OverloadCandidate {\n    /// Function - The actual function that this candidate\n    /// represents. When NULL, this is a built-in candidate\n    /// (C++ [over.oper]) or a surrogate for a conversion to a\n    /// function pointer or reference (C++ [over.call.object]).\n    FunctionDecl *Function;\n\n    /// FoundDecl - The original declaration that was looked up /\n    /// invented / otherwise found, together with its access.\n    /// Might be a UsingShadowDecl or a FunctionTemplateDecl.\n    DeclAccessPair FoundDecl;\n\n    /// BuiltinParamTypes - Provides the parameter types of a built-in overload\n    /// candidate. Only valid when Function is NULL.\n    QualType BuiltinParamTypes[3];\n\n    /// Surrogate - The conversion function for which this candidate\n    /// is a surrogate, but only if IsSurrogate is true.\n    CXXConversionDecl *Surrogate;\n\n    /// The conversion sequences used to convert the function arguments\n    /// to the function parameters. Note that these are indexed by argument,\n    /// so may not match the parameter order of Function.\n    ConversionSequenceList Conversions;\n\n    /// The FixIt hints which can be used to fix the Bad candidate.\n    ConversionFixItGenerator Fix;\n\n    /// Viable - True to indicate that this overload candidate is viable.\n    bool Viable : 1;\n\n    /// Whether this candidate is the best viable function, or tied for being\n    /// the best viable function.\n    ///\n    /// For an ambiguous overload resolution, indicates whether this candidate\n    /// was part of the ambiguity kernel: the minimal non-empty set of viable\n    /// candidates such that all elements of the ambiguity kernel are better\n    /// than all viable candidates not in the ambiguity kernel.\n    bool Best : 1;\n\n    /// IsSurrogate - True to indicate that this candidate is a\n    /// surrogate for a conversion to a function pointer or reference\n    /// (C++ [over.call.object]).\n    bool IsSurrogate : 1;\n\n    /// IgnoreObjectArgument - True to indicate that the first\n    /// argument's conversion, which for this function represents the\n    /// implicit object argument, should be ignored. This will be true\n    /// when the candidate is a static member function (where the\n    /// implicit object argument is just a placeholder) or a\n    /// non-static member function when the call doesn't have an\n    /// object argument.\n    bool IgnoreObjectArgument : 1;\n\n    /// True if the candidate was found using ADL.\n    CallExpr::ADLCallKind IsADLCandidate : 1;\n\n    /// Whether this is a rewritten candidate, and if so, of what kind?\n    unsigned RewriteKind : 2;\n\n    /// FailureKind - The reason why this candidate is not viable.\n    /// Actually an OverloadFailureKind.\n    unsigned char FailureKind;\n\n    /// The number of call arguments that were explicitly provided,\n    /// to be used while performing partial ordering of function templates.\n    unsigned ExplicitCallArguments;\n\n    union {\n      DeductionFailureInfo DeductionFailure;\n\n      /// FinalConversion - For a conversion function (where Function is\n      /// a CXXConversionDecl), the standard conversion that occurs\n      /// after the call to the overload candidate to convert the result\n      /// of calling the conversion function to the required type.\n      StandardConversionSequence FinalConversion;\n    };\n\n    /// Get RewriteKind value in OverloadCandidateRewriteKind type (This\n    /// function is to workaround the spurious GCC bitfield enum warning)\n    OverloadCandidateRewriteKind getRewriteKind() const {\n      return static_cast<OverloadCandidateRewriteKind>(RewriteKind);\n    }\n\n    bool isReversed() const { return getRewriteKind() & CRK_Reversed; }\n\n    /// hasAmbiguousConversion - Returns whether this overload\n    /// candidate requires an ambiguous conversion or not.\n    bool hasAmbiguousConversion() const {\n      for (auto &C : Conversions) {\n        if (!C.isInitialized()) return false;\n        if (C.isAmbiguous()) return true;\n      }\n      return false;\n    }\n\n    bool TryToFixBadConversion(unsigned Idx, Sema &S) {\n      bool CanFix = Fix.tryToFixConversion(\n                      Conversions[Idx].Bad.FromExpr,\n                      Conversions[Idx].Bad.getFromType(),\n                      Conversions[Idx].Bad.getToType(), S);\n\n      // If at least one conversion fails, the candidate cannot be fixed.\n      if (!CanFix)\n        Fix.clear();\n\n      return CanFix;\n    }\n\n    unsigned getNumParams() const {\n      if (IsSurrogate) {\n        QualType STy = Surrogate->getConversionType();\n        while (STy->isPointerType() || STy->isReferenceType())\n          STy = STy->getPointeeType();\n        return STy->castAs<FunctionProtoType>()->getNumParams();\n      }\n      if (Function)\n        return Function->getNumParams();\n      return ExplicitCallArguments;\n    }\n\n  private:\n    friend class OverloadCandidateSet;\n    OverloadCandidate()\n        : IsSurrogate(false), IsADLCandidate(CallExpr::NotADL), RewriteKind(CRK_None) {}\n  };\n\n  /// OverloadCandidateSet - A set of overload candidates, used in C++\n  /// overload resolution (C++ 13.3).\n  class OverloadCandidateSet {\n  public:\n    enum CandidateSetKind {\n      /// Normal lookup.\n      CSK_Normal,\n\n      /// C++ [over.match.oper]:\n      /// Lookup of operator function candidates in a call using operator\n      /// syntax. Candidates that have no parameters of class type will be\n      /// skipped unless there is a parameter of (reference to) enum type and\n      /// the corresponding argument is of the same enum type.\n      CSK_Operator,\n\n      /// C++ [over.match.copy]:\n      /// Copy-initialization of an object of class type by user-defined\n      /// conversion.\n      CSK_InitByUserDefinedConversion,\n\n      /// C++ [over.match.ctor], [over.match.list]\n      /// Initialization of an object of class type by constructor,\n      /// using either a parenthesized or braced list of arguments.\n      CSK_InitByConstructor,\n    };\n\n    /// Information about operator rewrites to consider when adding operator\n    /// functions to a candidate set.\n    struct OperatorRewriteInfo {\n      OperatorRewriteInfo()\n          : OriginalOperator(OO_None), AllowRewrittenCandidates(false) {}\n      OperatorRewriteInfo(OverloadedOperatorKind Op, bool AllowRewritten)\n          : OriginalOperator(Op), AllowRewrittenCandidates(AllowRewritten) {}\n\n      /// The original operator as written in the source.\n      OverloadedOperatorKind OriginalOperator;\n      /// Whether we should include rewritten candidates in the overload set.\n      bool AllowRewrittenCandidates;\n\n      /// Would use of this function result in a rewrite using a different\n      /// operator?\n      bool isRewrittenOperator(const FunctionDecl *FD) {\n        return OriginalOperator &&\n               FD->getDeclName().getCXXOverloadedOperator() != OriginalOperator;\n      }\n\n      bool isAcceptableCandidate(const FunctionDecl *FD) {\n        if (!OriginalOperator)\n          return true;\n\n        // For an overloaded operator, we can have candidates with a different\n        // name in our unqualified lookup set. Make sure we only consider the\n        // ones we're supposed to.\n        OverloadedOperatorKind OO =\n            FD->getDeclName().getCXXOverloadedOperator();\n        return OO && (OO == OriginalOperator ||\n                      (AllowRewrittenCandidates &&\n                       OO == getRewrittenOverloadedOperator(OriginalOperator)));\n      }\n\n      /// Determine the kind of rewrite that should be performed for this\n      /// candidate.\n      OverloadCandidateRewriteKind\n      getRewriteKind(const FunctionDecl *FD, OverloadCandidateParamOrder PO) {\n        OverloadCandidateRewriteKind CRK = CRK_None;\n        if (isRewrittenOperator(FD))\n          CRK = OverloadCandidateRewriteKind(CRK | CRK_DifferentOperator);\n        if (PO == OverloadCandidateParamOrder::Reversed)\n          CRK = OverloadCandidateRewriteKind(CRK | CRK_Reversed);\n        return CRK;\n      }\n\n      /// Determines whether this operator could be implemented by a function\n      /// with reversed parameter order.\n      bool isReversible() {\n        return AllowRewrittenCandidates && OriginalOperator &&\n               (getRewrittenOverloadedOperator(OriginalOperator) != OO_None ||\n                shouldAddReversed(OriginalOperator));\n      }\n\n      /// Determine whether we should consider looking for and adding reversed\n      /// candidates for operator Op.\n      bool shouldAddReversed(OverloadedOperatorKind Op);\n\n      /// Determine whether we should add a rewritten candidate for \\p FD with\n      /// reversed parameter order.\n      bool shouldAddReversed(ASTContext &Ctx, const FunctionDecl *FD);\n    };\n\n  private:\n    SmallVector<OverloadCandidate, 16> Candidates;\n    llvm::SmallPtrSet<uintptr_t, 16> Functions;\n\n    // Allocator for ConversionSequenceLists. We store the first few of these\n    // inline to avoid allocation for small sets.\n    llvm::BumpPtrAllocator SlabAllocator;\n\n    SourceLocation Loc;\n    CandidateSetKind Kind;\n    OperatorRewriteInfo RewriteInfo;\n\n    constexpr static unsigned NumInlineBytes =\n        24 * sizeof(ImplicitConversionSequence);\n    unsigned NumInlineBytesUsed = 0;\n    alignas(void *) char InlineSpace[NumInlineBytes];\n\n    // Address space of the object being constructed.\n    LangAS DestAS = LangAS::Default;\n\n    /// If we have space, allocates from inline storage. Otherwise, allocates\n    /// from the slab allocator.\n    /// FIXME: It would probably be nice to have a SmallBumpPtrAllocator\n    /// instead.\n    /// FIXME: Now that this only allocates ImplicitConversionSequences, do we\n    /// want to un-generalize this?\n    template <typename T>\n    T *slabAllocate(unsigned N) {\n      // It's simpler if this doesn't need to consider alignment.\n      static_assert(alignof(T) == alignof(void *),\n                    \"Only works for pointer-aligned types.\");\n      static_assert(std::is_trivial<T>::value ||\n                        std::is_same<ImplicitConversionSequence, T>::value,\n                    \"Add destruction logic to OverloadCandidateSet::clear().\");\n\n      unsigned NBytes = sizeof(T) * N;\n      if (NBytes > NumInlineBytes - NumInlineBytesUsed)\n        return SlabAllocator.Allocate<T>(N);\n      char *FreeSpaceStart = InlineSpace + NumInlineBytesUsed;\n      assert(uintptr_t(FreeSpaceStart) % alignof(void *) == 0 &&\n             \"Misaligned storage!\");\n\n      NumInlineBytesUsed += NBytes;\n      return reinterpret_cast<T *>(FreeSpaceStart);\n    }\n\n    void destroyCandidates();\n\n    /// Whether diagnostics should be deferred.\n    bool shouldDeferDiags(Sema &S, ArrayRef<Expr *> Args, SourceLocation OpLoc);\n\n  public:\n    OverloadCandidateSet(SourceLocation Loc, CandidateSetKind CSK,\n                         OperatorRewriteInfo RewriteInfo = {})\n        : Loc(Loc), Kind(CSK), RewriteInfo(RewriteInfo) {}\n    OverloadCandidateSet(const OverloadCandidateSet &) = delete;\n    OverloadCandidateSet &operator=(const OverloadCandidateSet &) = delete;\n    ~OverloadCandidateSet() { destroyCandidates(); }\n\n    SourceLocation getLocation() const { return Loc; }\n    CandidateSetKind getKind() const { return Kind; }\n    OperatorRewriteInfo getRewriteInfo() const { return RewriteInfo; }\n\n    /// Determine when this overload candidate will be new to the\n    /// overload set.\n    bool isNewCandidate(Decl *F, OverloadCandidateParamOrder PO =\n                                     OverloadCandidateParamOrder::Normal) {\n      uintptr_t Key = reinterpret_cast<uintptr_t>(F->getCanonicalDecl());\n      Key |= static_cast<uintptr_t>(PO);\n      return Functions.insert(Key).second;\n    }\n\n    /// Exclude a function from being considered by overload resolution.\n    void exclude(Decl *F) {\n      isNewCandidate(F, OverloadCandidateParamOrder::Normal);\n      isNewCandidate(F, OverloadCandidateParamOrder::Reversed);\n    }\n\n    /// Clear out all of the candidates.\n    void clear(CandidateSetKind CSK);\n\n    using iterator = SmallVectorImpl<OverloadCandidate>::iterator;\n\n    iterator begin() { return Candidates.begin(); }\n    iterator end() { return Candidates.end(); }\n\n    size_t size() const { return Candidates.size(); }\n    bool empty() const { return Candidates.empty(); }\n\n    /// Allocate storage for conversion sequences for NumConversions\n    /// conversions.\n    ConversionSequenceList\n    allocateConversionSequences(unsigned NumConversions) {\n      ImplicitConversionSequence *Conversions =\n          slabAllocate<ImplicitConversionSequence>(NumConversions);\n\n      // Construct the new objects.\n      for (unsigned I = 0; I != NumConversions; ++I)\n        new (&Conversions[I]) ImplicitConversionSequence();\n\n      return ConversionSequenceList(Conversions, NumConversions);\n    }\n\n    /// Add a new candidate with NumConversions conversion sequence slots\n    /// to the overload set.\n    OverloadCandidate &addCandidate(unsigned NumConversions = 0,\n                                    ConversionSequenceList Conversions = None) {\n      assert((Conversions.empty() || Conversions.size() == NumConversions) &&\n             \"preallocated conversion sequence has wrong length\");\n\n      Candidates.push_back(OverloadCandidate());\n      OverloadCandidate &C = Candidates.back();\n      C.Conversions = Conversions.empty()\n                          ? allocateConversionSequences(NumConversions)\n                          : Conversions;\n      return C;\n    }\n\n    /// Find the best viable function on this overload set, if it exists.\n    OverloadingResult BestViableFunction(Sema &S, SourceLocation Loc,\n                                         OverloadCandidateSet::iterator& Best);\n\n    SmallVector<OverloadCandidate *, 32> CompleteCandidates(\n        Sema &S, OverloadCandidateDisplayKind OCD, ArrayRef<Expr *> Args,\n        SourceLocation OpLoc = SourceLocation(),\n        llvm::function_ref<bool(OverloadCandidate &)> Filter =\n            [](OverloadCandidate &) { return true; });\n\n    void NoteCandidates(\n        PartialDiagnosticAt PA, Sema &S, OverloadCandidateDisplayKind OCD,\n        ArrayRef<Expr *> Args, StringRef Opc = \"\",\n        SourceLocation Loc = SourceLocation(),\n        llvm::function_ref<bool(OverloadCandidate &)> Filter =\n            [](OverloadCandidate &) { return true; });\n\n    void NoteCandidates(Sema &S, ArrayRef<Expr *> Args,\n                        ArrayRef<OverloadCandidate *> Cands,\n                        StringRef Opc = \"\",\n                        SourceLocation OpLoc = SourceLocation());\n\n    LangAS getDestAS() { return DestAS; }\n\n    void setDestAS(LangAS AS) {\n      assert((Kind == CSK_InitByConstructor ||\n              Kind == CSK_InitByUserDefinedConversion) &&\n             \"can't set the destination address space when not constructing an \"\n             \"object\");\n      DestAS = AS;\n    }\n\n  };\n\n  bool isBetterOverloadCandidate(Sema &S,\n                                 const OverloadCandidate &Cand1,\n                                 const OverloadCandidate &Cand2,\n                                 SourceLocation Loc,\n                                 OverloadCandidateSet::CandidateSetKind Kind);\n\n  struct ConstructorInfo {\n    DeclAccessPair FoundDecl;\n    CXXConstructorDecl *Constructor;\n    FunctionTemplateDecl *ConstructorTmpl;\n\n    explicit operator bool() const { return Constructor; }\n  };\n\n  // FIXME: Add an AddOverloadCandidate / AddTemplateOverloadCandidate overload\n  // that takes one of these.\n  inline ConstructorInfo getConstructorInfo(NamedDecl *ND) {\n    if (isa<UsingDecl>(ND))\n      return ConstructorInfo{};\n\n    // For constructors, the access check is performed against the underlying\n    // declaration, not the found declaration.\n    auto *D = ND->getUnderlyingDecl();\n    ConstructorInfo Info = {DeclAccessPair::make(ND, D->getAccess()), nullptr,\n                            nullptr};\n    Info.ConstructorTmpl = dyn_cast<FunctionTemplateDecl>(D);\n    if (Info.ConstructorTmpl)\n      D = Info.ConstructorTmpl->getTemplatedDecl();\n    Info.Constructor = dyn_cast<CXXConstructorDecl>(D);\n    return Info;\n  }\n\n} // namespace clang\n\n#endif // LLVM_CLANG_SEMA_OVERLOAD_H\n"}, "32": {"id": 32, "path": "/home/vsts/work/1/llvm-project/clang/lib/Sema/SemaExprCXX.cpp", "content": "//===--- SemaExprCXX.cpp - Semantic Analysis for Expressions --------------===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n///\n/// \\file\n/// Implements semantic analysis for C++ expressions.\n///\n//===----------------------------------------------------------------------===//\n\n#include \"clang/Sema/Template.h\"\n#include \"clang/Sema/SemaInternal.h\"\n#include \"TreeTransform.h\"\n#include \"TypeLocBuilder.h\"\n#include \"clang/AST/ASTContext.h\"\n#include \"clang/AST/ASTLambda.h\"\n#include \"clang/AST/CXXInheritance.h\"\n#include \"clang/AST/CharUnits.h\"\n#include \"clang/AST/DeclObjC.h\"\n#include \"clang/AST/ExprCXX.h\"\n#include \"clang/AST/ExprObjC.h\"\n#include \"clang/AST/RecursiveASTVisitor.h\"\n#include \"clang/AST/TypeLoc.h\"\n#include \"clang/Basic/AlignedAllocation.h\"\n#include \"clang/Basic/PartialDiagnostic.h\"\n#include \"clang/Basic/TargetInfo.h\"\n#include \"clang/Lex/Preprocessor.h\"\n#include \"clang/Sema/DeclSpec.h\"\n#include \"clang/Sema/Initialization.h\"\n#include \"clang/Sema/Lookup.h\"\n#include \"clang/Sema/ParsedTemplate.h\"\n#include \"clang/Sema/Scope.h\"\n#include \"clang/Sema/ScopeInfo.h\"\n#include \"clang/Sema/SemaLambda.h\"\n#include \"clang/Sema/TemplateDeduction.h\"\n#include \"llvm/ADT/APInt.h\"\n#include \"llvm/ADT/STLExtras.h\"\n#include \"llvm/Support/ErrorHandling.h\"\nusing namespace clang;\nusing namespace sema;\n\n/// Handle the result of the special case name lookup for inheriting\n/// constructor declarations. 'NS::X::X' and 'NS::X<...>::X' are treated as\n/// constructor names in member using declarations, even if 'X' is not the\n/// name of the corresponding type.\nParsedType Sema::getInheritingConstructorName(CXXScopeSpec &SS,\n                                              SourceLocation NameLoc,\n                                              IdentifierInfo &Name) {\n  NestedNameSpecifier *NNS = SS.getScopeRep();\n\n  // Convert the nested-name-specifier into a type.\n  QualType Type;\n  switch (NNS->getKind()) {\n  case NestedNameSpecifier::TypeSpec:\n  case NestedNameSpecifier::TypeSpecWithTemplate:\n    Type = QualType(NNS->getAsType(), 0);\n    break;\n\n  case NestedNameSpecifier::Identifier:\n    // Strip off the last layer of the nested-name-specifier and build a\n    // typename type for it.\n    assert(NNS->getAsIdentifier() == &Name && \"not a constructor name\");\n    Type = Context.getDependentNameType(ETK_None, NNS->getPrefix(),\n                                        NNS->getAsIdentifier());\n    break;\n\n  case NestedNameSpecifier::Global:\n  case NestedNameSpecifier::Super:\n  case NestedNameSpecifier::Namespace:\n  case NestedNameSpecifier::NamespaceAlias:\n    llvm_unreachable(\"Nested name specifier is not a type for inheriting ctor\");\n  }\n\n  // This reference to the type is located entirely at the location of the\n  // final identifier in the qualified-id.\n  return CreateParsedType(Type,\n                          Context.getTrivialTypeSourceInfo(Type, NameLoc));\n}\n\nParsedType Sema::getConstructorName(IdentifierInfo &II,\n                                    SourceLocation NameLoc,\n                                    Scope *S, CXXScopeSpec &SS,\n                                    bool EnteringContext) {\n  CXXRecordDecl *CurClass = getCurrentClass(S, &SS);\n  assert(CurClass && &II == CurClass->getIdentifier() &&\n         \"not a constructor name\");\n\n  // When naming a constructor as a member of a dependent context (eg, in a\n  // friend declaration or an inherited constructor declaration), form an\n  // unresolved \"typename\" type.\n  if (CurClass->isDependentContext() && !EnteringContext && SS.getScopeRep()) {\n    QualType T = Context.getDependentNameType(ETK_None, SS.getScopeRep(), &II);\n    return ParsedType::make(T);\n  }\n\n  if (SS.isNotEmpty() && RequireCompleteDeclContext(SS, CurClass))\n    return ParsedType();\n\n  // Find the injected-class-name declaration. Note that we make no attempt to\n  // diagnose cases where the injected-class-name is shadowed: the only\n  // declaration that can validly shadow the injected-class-name is a\n  // non-static data member, and if the class contains both a non-static data\n  // member and a constructor then it is ill-formed (we check that in\n  // CheckCompletedCXXClass).\n  CXXRecordDecl *InjectedClassName = nullptr;\n  for (NamedDecl *ND : CurClass->lookup(&II)) {\n    auto *RD = dyn_cast<CXXRecordDecl>(ND);\n    if (RD && RD->isInjectedClassName()) {\n      InjectedClassName = RD;\n      break;\n    }\n  }\n  if (!InjectedClassName) {\n    if (!CurClass->isInvalidDecl()) {\n      // FIXME: RequireCompleteDeclContext doesn't check dependent contexts\n      // properly. Work around it here for now.\n      Diag(SS.getLastQualifierNameLoc(),\n           diag::err_incomplete_nested_name_spec) << CurClass << SS.getRange();\n    }\n    return ParsedType();\n  }\n\n  QualType T = Context.getTypeDeclType(InjectedClassName);\n  DiagnoseUseOfDecl(InjectedClassName, NameLoc);\n  MarkAnyDeclReferenced(NameLoc, InjectedClassName, /*OdrUse=*/false);\n\n  return ParsedType::make(T);\n}\n\nParsedType Sema::getDestructorName(SourceLocation TildeLoc,\n                                   IdentifierInfo &II,\n                                   SourceLocation NameLoc,\n                                   Scope *S, CXXScopeSpec &SS,\n                                   ParsedType ObjectTypePtr,\n                                   bool EnteringContext) {\n  // Determine where to perform name lookup.\n\n  // FIXME: This area of the standard is very messy, and the current\n  // wording is rather unclear about which scopes we search for the\n  // destructor name; see core issues 399 and 555. Issue 399 in\n  // particular shows where the current description of destructor name\n  // lookup is completely out of line with existing practice, e.g.,\n  // this appears to be ill-formed:\n  //\n  //   namespace N {\n  //     template <typename T> struct S {\n  //       ~S();\n  //     };\n  //   }\n  //\n  //   void f(N::S<int>* s) {\n  //     s->N::S<int>::~S();\n  //   }\n  //\n  // See also PR6358 and PR6359.\n  //\n  // For now, we accept all the cases in which the name given could plausibly\n  // be interpreted as a correct destructor name, issuing off-by-default\n  // extension diagnostics on the cases that don't strictly conform to the\n  // C++20 rules. This basically means we always consider looking in the\n  // nested-name-specifier prefix, the complete nested-name-specifier, and\n  // the scope, and accept if we find the expected type in any of the three\n  // places.\n\n  if (SS.isInvalid())\n    return nullptr;\n\n  // Whether we've failed with a diagnostic already.\n  bool Failed = false;\n\n  llvm::SmallVector<NamedDecl*, 8> FoundDecls;\n  llvm::SmallPtrSet<CanonicalDeclPtr<Decl>, 8> FoundDeclSet;\n\n  // If we have an object type, it's because we are in a\n  // pseudo-destructor-expression or a member access expression, and\n  // we know what type we're looking for.\n  QualType SearchType =\n      ObjectTypePtr ? GetTypeFromParser(ObjectTypePtr) : QualType();\n\n  auto CheckLookupResult = [&](LookupResult &Found) -> ParsedType {\n    auto IsAcceptableResult = [&](NamedDecl *D) -> bool {\n      auto *Type = dyn_cast<TypeDecl>(D->getUnderlyingDecl());\n      if (!Type)\n        return false;\n\n      if (SearchType.isNull() || SearchType->isDependentType())\n        return true;\n\n      QualType T = Context.getTypeDeclType(Type);\n      return Context.hasSameUnqualifiedType(T, SearchType);\n    };\n\n    unsigned NumAcceptableResults = 0;\n    for (NamedDecl *D : Found) {\n      if (IsAcceptableResult(D))\n        ++NumAcceptableResults;\n\n      // Don't list a class twice in the lookup failure diagnostic if it's\n      // found by both its injected-class-name and by the name in the enclosing\n      // scope.\n      if (auto *RD = dyn_cast<CXXRecordDecl>(D))\n        if (RD->isInjectedClassName())\n          D = cast<NamedDecl>(RD->getParent());\n\n      if (FoundDeclSet.insert(D).second)\n        FoundDecls.push_back(D);\n    }\n\n    // As an extension, attempt to \"fix\" an ambiguity by erasing all non-type\n    // results, and all non-matching results if we have a search type. It's not\n    // clear what the right behavior is if destructor lookup hits an ambiguity,\n    // but other compilers do generally accept at least some kinds of\n    // ambiguity.\n    if (Found.isAmbiguous() && NumAcceptableResults == 1) {\n      Diag(NameLoc, diag::ext_dtor_name_ambiguous);\n      LookupResult::Filter F = Found.makeFilter();\n      while (F.hasNext()) {\n        NamedDecl *D = F.next();\n        if (auto *TD = dyn_cast<TypeDecl>(D->getUnderlyingDecl()))\n          Diag(D->getLocation(), diag::note_destructor_type_here)\n              << Context.getTypeDeclType(TD);\n        else\n          Diag(D->getLocation(), diag::note_destructor_nontype_here);\n\n        if (!IsAcceptableResult(D))\n          F.erase();\n      }\n      F.done();\n    }\n\n    if (Found.isAmbiguous())\n      Failed = true;\n\n    if (TypeDecl *Type = Found.getAsSingle<TypeDecl>()) {\n      if (IsAcceptableResult(Type)) {\n        QualType T = Context.getTypeDeclType(Type);\n        MarkAnyDeclReferenced(Type->getLocation(), Type, /*OdrUse=*/false);\n        return CreateParsedType(T,\n                                Context.getTrivialTypeSourceInfo(T, NameLoc));\n      }\n    }\n\n    return nullptr;\n  };\n\n  bool IsDependent = false;\n\n  auto LookupInObjectType = [&]() -> ParsedType {\n    if (Failed || SearchType.isNull())\n      return nullptr;\n\n    IsDependent |= SearchType->isDependentType();\n\n    LookupResult Found(*this, &II, NameLoc, LookupDestructorName);\n    DeclContext *LookupCtx = computeDeclContext(SearchType);\n    if (!LookupCtx)\n      return nullptr;\n    LookupQualifiedName(Found, LookupCtx);\n    return CheckLookupResult(Found);\n  };\n\n  auto LookupInNestedNameSpec = [&](CXXScopeSpec &LookupSS) -> ParsedType {\n    if (Failed)\n      return nullptr;\n\n    IsDependent |= isDependentScopeSpecifier(LookupSS);\n    DeclContext *LookupCtx = computeDeclContext(LookupSS, EnteringContext);\n    if (!LookupCtx)\n      return nullptr;\n\n    LookupResult Found(*this, &II, NameLoc, LookupDestructorName);\n    if (RequireCompleteDeclContext(LookupSS, LookupCtx)) {\n      Failed = true;\n      return nullptr;\n    }\n    LookupQualifiedName(Found, LookupCtx);\n    return CheckLookupResult(Found);\n  };\n\n  auto LookupInScope = [&]() -> ParsedType {\n    if (Failed || !S)\n      return nullptr;\n\n    LookupResult Found(*this, &II, NameLoc, LookupDestructorName);\n    LookupName(Found, S);\n    return CheckLookupResult(Found);\n  };\n\n  // C++2a [basic.lookup.qual]p6:\n  //   In a qualified-id of the form\n  //\n  //     nested-name-specifier[opt] type-name :: ~ type-name\n  //\n  //   the second type-name is looked up in the same scope as the first.\n  //\n  // We interpret this as meaning that if you do a dual-scope lookup for the\n  // first name, you also do a dual-scope lookup for the second name, per\n  // C++ [basic.lookup.classref]p4:\n  //\n  //   If the id-expression in a class member access is a qualified-id of the\n  //   form\n  //\n  //     class-name-or-namespace-name :: ...\n  //\n  //   the class-name-or-namespace-name following the . or -> is first looked\n  //   up in the class of the object expression and the name, if found, is used.\n  //   Otherwise, it is looked up in the context of the entire\n  //   postfix-expression.\n  //\n  // This looks in the same scopes as for an unqualified destructor name:\n  //\n  // C++ [basic.lookup.classref]p3:\n  //   If the unqualified-id is ~ type-name, the type-name is looked up\n  //   in the context of the entire postfix-expression. If the type T\n  //   of the object expression is of a class type C, the type-name is\n  //   also looked up in the scope of class C. At least one of the\n  //   lookups shall find a name that refers to cv T.\n  //\n  // FIXME: The intent is unclear here. Should type-name::~type-name look in\n  // the scope anyway if it finds a non-matching name declared in the class?\n  // If both lookups succeed and find a dependent result, which result should\n  // we retain? (Same question for p->~type-name().)\n\n  if (NestedNameSpecifier *Prefix =\n      SS.isSet() ? SS.getScopeRep()->getPrefix() : nullptr) {\n    // This is\n    //\n    //   nested-name-specifier type-name :: ~ type-name\n    //\n    // Look for the second type-name in the nested-name-specifier.\n    CXXScopeSpec PrefixSS;\n    PrefixSS.Adopt(NestedNameSpecifierLoc(Prefix, SS.location_data()));\n    if (ParsedType T = LookupInNestedNameSpec(PrefixSS))\n      return T;\n  } else {\n    // This is one of\n    //\n    //   type-name :: ~ type-name\n    //   ~ type-name\n    //\n    // Look in the scope and (if any) the object type.\n    if (ParsedType T = LookupInScope())\n      return T;\n    if (ParsedType T = LookupInObjectType())\n      return T;\n  }\n\n  if (Failed)\n    return nullptr;\n\n  if (IsDependent) {\n    // We didn't find our type, but that's OK: it's dependent anyway.\n\n    // FIXME: What if we have no nested-name-specifier?\n    QualType T = CheckTypenameType(ETK_None, SourceLocation(),\n                                   SS.getWithLocInContext(Context),\n                                   II, NameLoc);\n    return ParsedType::make(T);\n  }\n\n  // The remaining cases are all non-standard extensions imitating the behavior\n  // of various other compilers.\n  unsigned NumNonExtensionDecls = FoundDecls.size();\n\n  if (SS.isSet()) {\n    // For compatibility with older broken C++ rules and existing code,\n    //\n    //   nested-name-specifier :: ~ type-name\n    //\n    // also looks for type-name within the nested-name-specifier.\n    if (ParsedType T = LookupInNestedNameSpec(SS)) {\n      Diag(SS.getEndLoc(), diag::ext_dtor_named_in_wrong_scope)\n          << SS.getRange()\n          << FixItHint::CreateInsertion(SS.getEndLoc(),\n                                        (\"::\" + II.getName()).str());\n      return T;\n    }\n\n    // For compatibility with other compilers and older versions of Clang,\n    //\n    //   nested-name-specifier type-name :: ~ type-name\n    //\n    // also looks for type-name in the scope. Unfortunately, we can't\n    // reasonably apply this fallback for dependent nested-name-specifiers.\n    if (SS.getScopeRep()->getPrefix()) {\n      if (ParsedType T = LookupInScope()) {\n        Diag(SS.getEndLoc(), diag::ext_qualified_dtor_named_in_lexical_scope)\n            << FixItHint::CreateRemoval(SS.getRange());\n        Diag(FoundDecls.back()->getLocation(), diag::note_destructor_type_here)\n            << GetTypeFromParser(T);\n        return T;\n      }\n    }\n  }\n\n  // We didn't find anything matching; tell the user what we did find (if\n  // anything).\n\n  // Don't tell the user about declarations we shouldn't have found.\n  FoundDecls.resize(NumNonExtensionDecls);\n\n  // List types before non-types.\n  std::stable_sort(FoundDecls.begin(), FoundDecls.end(),\n                   [](NamedDecl *A, NamedDecl *B) {\n                     return isa<TypeDecl>(A->getUnderlyingDecl()) >\n                            isa<TypeDecl>(B->getUnderlyingDecl());\n                   });\n\n  // Suggest a fixit to properly name the destroyed type.\n  auto MakeFixItHint = [&]{\n    const CXXRecordDecl *Destroyed = nullptr;\n    // FIXME: If we have a scope specifier, suggest its last component?\n    if (!SearchType.isNull())\n      Destroyed = SearchType->getAsCXXRecordDecl();\n    else if (S)\n      Destroyed = dyn_cast_or_null<CXXRecordDecl>(S->getEntity());\n    if (Destroyed)\n      return FixItHint::CreateReplacement(SourceRange(NameLoc),\n                                          Destroyed->getNameAsString());\n    return FixItHint();\n  };\n\n  if (FoundDecls.empty()) {\n    // FIXME: Attempt typo-correction?\n    Diag(NameLoc, diag::err_undeclared_destructor_name)\n      << &II << MakeFixItHint();\n  } else if (!SearchType.isNull() && FoundDecls.size() == 1) {\n    if (auto *TD = dyn_cast<TypeDecl>(FoundDecls[0]->getUnderlyingDecl())) {\n      assert(!SearchType.isNull() &&\n             \"should only reject a type result if we have a search type\");\n      QualType T = Context.getTypeDeclType(TD);\n      Diag(NameLoc, diag::err_destructor_expr_type_mismatch)\n          << T << SearchType << MakeFixItHint();\n    } else {\n      Diag(NameLoc, diag::err_destructor_expr_nontype)\n          << &II << MakeFixItHint();\n    }\n  } else {\n    Diag(NameLoc, SearchType.isNull() ? diag::err_destructor_name_nontype\n                                      : diag::err_destructor_expr_mismatch)\n        << &II << SearchType << MakeFixItHint();\n  }\n\n  for (NamedDecl *FoundD : FoundDecls) {\n    if (auto *TD = dyn_cast<TypeDecl>(FoundD->getUnderlyingDecl()))\n      Diag(FoundD->getLocation(), diag::note_destructor_type_here)\n          << Context.getTypeDeclType(TD);\n    else\n      Diag(FoundD->getLocation(), diag::note_destructor_nontype_here)\n          << FoundD;\n  }\n\n  return nullptr;\n}\n\nParsedType Sema::getDestructorTypeForDecltype(const DeclSpec &DS,\n                                              ParsedType ObjectType) {\n  if (DS.getTypeSpecType() == DeclSpec::TST_error)\n    return nullptr;\n\n  if (DS.getTypeSpecType() == DeclSpec::TST_decltype_auto) {\n    Diag(DS.getTypeSpecTypeLoc(), diag::err_decltype_auto_invalid);\n    return nullptr;\n  }\n\n  assert(DS.getTypeSpecType() == DeclSpec::TST_decltype &&\n         \"unexpected type in getDestructorType\");\n  QualType T = BuildDecltypeType(DS.getRepAsExpr(), DS.getTypeSpecTypeLoc());\n\n  // If we know the type of the object, check that the correct destructor\n  // type was named now; we can give better diagnostics this way.\n  QualType SearchType = GetTypeFromParser(ObjectType);\n  if (!SearchType.isNull() && !SearchType->isDependentType() &&\n      !Context.hasSameUnqualifiedType(T, SearchType)) {\n    Diag(DS.getTypeSpecTypeLoc(), diag::err_destructor_expr_type_mismatch)\n      << T << SearchType;\n    return nullptr;\n  }\n\n  return ParsedType::make(T);\n}\n\nbool Sema::checkLiteralOperatorId(const CXXScopeSpec &SS,\n                                  const UnqualifiedId &Name) {\n  assert(Name.getKind() == UnqualifiedIdKind::IK_LiteralOperatorId);\n\n  if (!SS.isValid())\n    return false;\n\n  switch (SS.getScopeRep()->getKind()) {\n  case NestedNameSpecifier::Identifier:\n  case NestedNameSpecifier::TypeSpec:\n  case NestedNameSpecifier::TypeSpecWithTemplate:\n    // Per C++11 [over.literal]p2, literal operators can only be declared at\n    // namespace scope. Therefore, this unqualified-id cannot name anything.\n    // Reject it early, because we have no AST representation for this in the\n    // case where the scope is dependent.\n    Diag(Name.getBeginLoc(), diag::err_literal_operator_id_outside_namespace)\n        << SS.getScopeRep();\n    return true;\n\n  case NestedNameSpecifier::Global:\n  case NestedNameSpecifier::Super:\n  case NestedNameSpecifier::Namespace:\n  case NestedNameSpecifier::NamespaceAlias:\n    return false;\n  }\n\n  llvm_unreachable(\"unknown nested name specifier kind\");\n}\n\n/// Build a C++ typeid expression with a type operand.\nExprResult Sema::BuildCXXTypeId(QualType TypeInfoType,\n                                SourceLocation TypeidLoc,\n                                TypeSourceInfo *Operand,\n                                SourceLocation RParenLoc) {\n  // C++ [expr.typeid]p4:\n  //   The top-level cv-qualifiers of the lvalue expression or the type-id\n  //   that is the operand of typeid are always ignored.\n  //   If the type of the type-id is a class type or a reference to a class\n  //   type, the class shall be completely-defined.\n  Qualifiers Quals;\n  QualType T\n    = Context.getUnqualifiedArrayType(Operand->getType().getNonReferenceType(),\n                                      Quals);\n  if (T->getAs<RecordType>() &&\n      RequireCompleteType(TypeidLoc, T, diag::err_incomplete_typeid))\n    return ExprError();\n\n  if (T->isVariablyModifiedType())\n    return ExprError(Diag(TypeidLoc, diag::err_variably_modified_typeid) << T);\n\n  if (CheckQualifiedFunctionForTypeId(T, TypeidLoc))\n    return ExprError();\n\n  return new (Context) CXXTypeidExpr(TypeInfoType.withConst(), Operand,\n                                     SourceRange(TypeidLoc, RParenLoc));\n}\n\n/// Build a C++ typeid expression with an expression operand.\nExprResult Sema::BuildCXXTypeId(QualType TypeInfoType,\n                                SourceLocation TypeidLoc,\n                                Expr *E,\n                                SourceLocation RParenLoc) {\n  bool WasEvaluated = false;\n  if (E && !E->isTypeDependent()) {\n    if (E->getType()->isPlaceholderType()) {\n      ExprResult result = CheckPlaceholderExpr(E);\n      if (result.isInvalid()) return ExprError();\n      E = result.get();\n    }\n\n    QualType T = E->getType();\n    if (const RecordType *RecordT = T->getAs<RecordType>()) {\n      CXXRecordDecl *RecordD = cast<CXXRecordDecl>(RecordT->getDecl());\n      // C++ [expr.typeid]p3:\n      //   [...] If the type of the expression is a class type, the class\n      //   shall be completely-defined.\n      if (RequireCompleteType(TypeidLoc, T, diag::err_incomplete_typeid))\n        return ExprError();\n\n      // C++ [expr.typeid]p3:\n      //   When typeid is applied to an expression other than an glvalue of a\n      //   polymorphic class type [...] [the] expression is an unevaluated\n      //   operand. [...]\n      if (RecordD->isPolymorphic() && E->isGLValue()) {\n        // The subexpression is potentially evaluated; switch the context\n        // and recheck the subexpression.\n        ExprResult Result = TransformToPotentiallyEvaluated(E);\n        if (Result.isInvalid()) return ExprError();\n        E = Result.get();\n\n        // We require a vtable to query the type at run time.\n        MarkVTableUsed(TypeidLoc, RecordD);\n        WasEvaluated = true;\n      }\n    }\n\n    ExprResult Result = CheckUnevaluatedOperand(E);\n    if (Result.isInvalid())\n      return ExprError();\n    E = Result.get();\n\n    // C++ [expr.typeid]p4:\n    //   [...] If the type of the type-id is a reference to a possibly\n    //   cv-qualified type, the result of the typeid expression refers to a\n    //   std::type_info object representing the cv-unqualified referenced\n    //   type.\n    Qualifiers Quals;\n    QualType UnqualT = Context.getUnqualifiedArrayType(T, Quals);\n    if (!Context.hasSameType(T, UnqualT)) {\n      T = UnqualT;\n      E = ImpCastExprToType(E, UnqualT, CK_NoOp, E->getValueKind()).get();\n    }\n  }\n\n  if (E->getType()->isVariablyModifiedType())\n    return ExprError(Diag(TypeidLoc, diag::err_variably_modified_typeid)\n                     << E->getType());\n  else if (!inTemplateInstantiation() &&\n           E->HasSideEffects(Context, WasEvaluated)) {\n    // The expression operand for typeid is in an unevaluated expression\n    // context, so side effects could result in unintended consequences.\n    Diag(E->getExprLoc(), WasEvaluated\n                              ? diag::warn_side_effects_typeid\n                              : diag::warn_side_effects_unevaluated_context);\n  }\n\n  return new (Context) CXXTypeidExpr(TypeInfoType.withConst(), E,\n                                     SourceRange(TypeidLoc, RParenLoc));\n}\n\n/// ActOnCXXTypeidOfType - Parse typeid( type-id ) or typeid (expression);\nExprResult\nSema::ActOnCXXTypeid(SourceLocation OpLoc, SourceLocation LParenLoc,\n                     bool isType, void *TyOrExpr, SourceLocation RParenLoc) {\n  // typeid is not supported in OpenCL.\n  if (getLangOpts().OpenCLCPlusPlus) {\n    return ExprError(Diag(OpLoc, diag::err_openclcxx_not_supported)\n                     << \"typeid\");\n  }\n\n  // Find the std::type_info type.\n  if (!getStdNamespace())\n    return ExprError(Diag(OpLoc, diag::err_need_header_before_typeid));\n\n  if (!CXXTypeInfoDecl) {\n    IdentifierInfo *TypeInfoII = &PP.getIdentifierTable().get(\"type_info\");\n    LookupResult R(*this, TypeInfoII, SourceLocation(), LookupTagName);\n    LookupQualifiedName(R, getStdNamespace());\n    CXXTypeInfoDecl = R.getAsSingle<RecordDecl>();\n    // Microsoft's typeinfo doesn't have type_info in std but in the global\n    // namespace if _HAS_EXCEPTIONS is defined to 0. See PR13153.\n    if (!CXXTypeInfoDecl && LangOpts.MSVCCompat) {\n      LookupQualifiedName(R, Context.getTranslationUnitDecl());\n      CXXTypeInfoDecl = R.getAsSingle<RecordDecl>();\n    }\n    if (!CXXTypeInfoDecl)\n      return ExprError(Diag(OpLoc, diag::err_need_header_before_typeid));\n  }\n\n  if (!getLangOpts().RTTI) {\n    return ExprError(Diag(OpLoc, diag::err_no_typeid_with_fno_rtti));\n  }\n\n  QualType TypeInfoType = Context.getTypeDeclType(CXXTypeInfoDecl);\n\n  if (isType) {\n    // The operand is a type; handle it as such.\n    TypeSourceInfo *TInfo = nullptr;\n    QualType T = GetTypeFromParser(ParsedType::getFromOpaquePtr(TyOrExpr),\n                                   &TInfo);\n    if (T.isNull())\n      return ExprError();\n\n    if (!TInfo)\n      TInfo = Context.getTrivialTypeSourceInfo(T, OpLoc);\n\n    return BuildCXXTypeId(TypeInfoType, OpLoc, TInfo, RParenLoc);\n  }\n\n  // The operand is an expression.\n  ExprResult Result =\n      BuildCXXTypeId(TypeInfoType, OpLoc, (Expr *)TyOrExpr, RParenLoc);\n\n  if (!getLangOpts().RTTIData && !Result.isInvalid())\n    if (auto *CTE = dyn_cast<CXXTypeidExpr>(Result.get()))\n      if (CTE->isPotentiallyEvaluated() && !CTE->isMostDerived(Context))\n        Diag(OpLoc, diag::warn_no_typeid_with_rtti_disabled)\n            << (getDiagnostics().getDiagnosticOptions().getFormat() ==\n                DiagnosticOptions::MSVC);\n  return Result;\n}\n\n/// Grabs __declspec(uuid()) off a type, or returns 0 if we cannot resolve to\n/// a single GUID.\nstatic void\ngetUuidAttrOfType(Sema &SemaRef, QualType QT,\n                  llvm::SmallSetVector<const UuidAttr *, 1> &UuidAttrs) {\n  // Optionally remove one level of pointer, reference or array indirection.\n  const Type *Ty = QT.getTypePtr();\n  if (QT->isPointerType() || QT->isReferenceType())\n    Ty = QT->getPointeeType().getTypePtr();\n  else if (QT->isArrayType())\n    Ty = Ty->getBaseElementTypeUnsafe();\n\n  const auto *TD = Ty->getAsTagDecl();\n  if (!TD)\n    return;\n\n  if (const auto *Uuid = TD->getMostRecentDecl()->getAttr<UuidAttr>()) {\n    UuidAttrs.insert(Uuid);\n    return;\n  }\n\n  // __uuidof can grab UUIDs from template arguments.\n  if (const auto *CTSD = dyn_cast<ClassTemplateSpecializationDecl>(TD)) {\n    const TemplateArgumentList &TAL = CTSD->getTemplateArgs();\n    for (const TemplateArgument &TA : TAL.asArray()) {\n      const UuidAttr *UuidForTA = nullptr;\n      if (TA.getKind() == TemplateArgument::Type)\n        getUuidAttrOfType(SemaRef, TA.getAsType(), UuidAttrs);\n      else if (TA.getKind() == TemplateArgument::Declaration)\n        getUuidAttrOfType(SemaRef, TA.getAsDecl()->getType(), UuidAttrs);\n\n      if (UuidForTA)\n        UuidAttrs.insert(UuidForTA);\n    }\n  }\n}\n\n/// Build a Microsoft __uuidof expression with a type operand.\nExprResult Sema::BuildCXXUuidof(QualType Type,\n                                SourceLocation TypeidLoc,\n                                TypeSourceInfo *Operand,\n                                SourceLocation RParenLoc) {\n  MSGuidDecl *Guid = nullptr;\n  if (!Operand->getType()->isDependentType()) {\n    llvm::SmallSetVector<const UuidAttr *, 1> UuidAttrs;\n    getUuidAttrOfType(*this, Operand->getType(), UuidAttrs);\n    if (UuidAttrs.empty())\n      return ExprError(Diag(TypeidLoc, diag::err_uuidof_without_guid));\n    if (UuidAttrs.size() > 1)\n      return ExprError(Diag(TypeidLoc, diag::err_uuidof_with_multiple_guids));\n    Guid = UuidAttrs.back()->getGuidDecl();\n  }\n\n  return new (Context)\n      CXXUuidofExpr(Type, Operand, Guid, SourceRange(TypeidLoc, RParenLoc));\n}\n\n/// Build a Microsoft __uuidof expression with an expression operand.\nExprResult Sema::BuildCXXUuidof(QualType Type, SourceLocation TypeidLoc,\n                                Expr *E, SourceLocation RParenLoc) {\n  MSGuidDecl *Guid = nullptr;\n  if (!E->getType()->isDependentType()) {\n    if (E->isNullPointerConstant(Context, Expr::NPC_ValueDependentIsNull)) {\n      // A null pointer results in {00000000-0000-0000-0000-000000000000}.\n      Guid = Context.getMSGuidDecl(MSGuidDecl::Parts{});\n    } else {\n      llvm::SmallSetVector<const UuidAttr *, 1> UuidAttrs;\n      getUuidAttrOfType(*this, E->getType(), UuidAttrs);\n      if (UuidAttrs.empty())\n        return ExprError(Diag(TypeidLoc, diag::err_uuidof_without_guid));\n      if (UuidAttrs.size() > 1)\n        return ExprError(Diag(TypeidLoc, diag::err_uuidof_with_multiple_guids));\n      Guid = UuidAttrs.back()->getGuidDecl();\n    }\n  }\n\n  return new (Context)\n      CXXUuidofExpr(Type, E, Guid, SourceRange(TypeidLoc, RParenLoc));\n}\n\n/// ActOnCXXUuidof - Parse __uuidof( type-id ) or __uuidof (expression);\nExprResult\nSema::ActOnCXXUuidof(SourceLocation OpLoc, SourceLocation LParenLoc,\n                     bool isType, void *TyOrExpr, SourceLocation RParenLoc) {\n  QualType GuidType = Context.getMSGuidType();\n  GuidType.addConst();\n\n  if (isType) {\n    // The operand is a type; handle it as such.\n    TypeSourceInfo *TInfo = nullptr;\n    QualType T = GetTypeFromParser(ParsedType::getFromOpaquePtr(TyOrExpr),\n                                   &TInfo);\n    if (T.isNull())\n      return ExprError();\n\n    if (!TInfo)\n      TInfo = Context.getTrivialTypeSourceInfo(T, OpLoc);\n\n    return BuildCXXUuidof(GuidType, OpLoc, TInfo, RParenLoc);\n  }\n\n  // The operand is an expression.\n  return BuildCXXUuidof(GuidType, OpLoc, (Expr*)TyOrExpr, RParenLoc);\n}\n\n/// ActOnCXXBoolLiteral - Parse {true,false} literals.\nExprResult\nSema::ActOnCXXBoolLiteral(SourceLocation OpLoc, tok::TokenKind Kind) {\n  assert((Kind == tok::kw_true || Kind == tok::kw_false) &&\n         \"Unknown C++ Boolean value!\");\n  return new (Context)\n      CXXBoolLiteralExpr(Kind == tok::kw_true, Context.BoolTy, OpLoc);\n}\n\n/// ActOnCXXNullPtrLiteral - Parse 'nullptr'.\nExprResult\nSema::ActOnCXXNullPtrLiteral(SourceLocation Loc) {\n  return new (Context) CXXNullPtrLiteralExpr(Context.NullPtrTy, Loc);\n}\n\n/// ActOnCXXThrow - Parse throw expressions.\nExprResult\nSema::ActOnCXXThrow(Scope *S, SourceLocation OpLoc, Expr *Ex) {\n  bool IsThrownVarInScope = false;\n  if (Ex) {\n    // C++0x [class.copymove]p31:\n    //   When certain criteria are met, an implementation is allowed to omit the\n    //   copy/move construction of a class object [...]\n    //\n    //     - in a throw-expression, when the operand is the name of a\n    //       non-volatile automatic object (other than a function or catch-\n    //       clause parameter) whose scope does not extend beyond the end of the\n    //       innermost enclosing try-block (if there is one), the copy/move\n    //       operation from the operand to the exception object (15.1) can be\n    //       omitted by constructing the automatic object directly into the\n    //       exception object\n    if (DeclRefExpr *DRE = dyn_cast<DeclRefExpr>(Ex->IgnoreParens()))\n      if (VarDecl *Var = dyn_cast<VarDecl>(DRE->getDecl())) {\n        if (Var->hasLocalStorage() && !Var->getType().isVolatileQualified()) {\n          for( ; S; S = S->getParent()) {\n            if (S->isDeclScope(Var)) {\n              IsThrownVarInScope = true;\n              break;\n            }\n\n            if (S->getFlags() &\n                (Scope::FnScope | Scope::ClassScope | Scope::BlockScope |\n                 Scope::FunctionPrototypeScope | Scope::ObjCMethodScope |\n                 Scope::TryScope))\n              break;\n          }\n        }\n      }\n  }\n\n  return BuildCXXThrow(OpLoc, Ex, IsThrownVarInScope);\n}\n\nExprResult Sema::BuildCXXThrow(SourceLocation OpLoc, Expr *Ex,\n                               bool IsThrownVarInScope) {\n  // Don't report an error if 'throw' is used in system headers.\n  if (!getLangOpts().CXXExceptions &&\n      !getSourceManager().isInSystemHeader(OpLoc) && !getLangOpts().CUDA) {\n    // Delay error emission for the OpenMP device code.\n    targetDiag(OpLoc, diag::err_exceptions_disabled) << \"throw\";\n  }\n\n  // Exceptions aren't allowed in CUDA device code.\n  if (getLangOpts().CUDA)\n    CUDADiagIfDeviceCode(OpLoc, diag::err_cuda_device_exceptions)\n        << \"throw\" << CurrentCUDATarget();\n\n  if (getCurScope() && getCurScope()->isOpenMPSimdDirectiveScope())\n    Diag(OpLoc, diag::err_omp_simd_region_cannot_use_stmt) << \"throw\";\n\n  if (Ex && !Ex->isTypeDependent()) {\n    QualType ExceptionObjectTy = Context.getExceptionObjectType(Ex->getType());\n    if (CheckCXXThrowOperand(OpLoc, ExceptionObjectTy, Ex))\n      return ExprError();\n\n    // Initialize the exception result.  This implicitly weeds out\n    // abstract types or types with inaccessible copy constructors.\n\n    // C++0x [class.copymove]p31:\n    //   When certain criteria are met, an implementation is allowed to omit the\n    //   copy/move construction of a class object [...]\n    //\n    //     - in a throw-expression, when the operand is the name of a\n    //       non-volatile automatic object (other than a function or\n    //       catch-clause\n    //       parameter) whose scope does not extend beyond the end of the\n    //       innermost enclosing try-block (if there is one), the copy/move\n    //       operation from the operand to the exception object (15.1) can be\n    //       omitted by constructing the automatic object directly into the\n    //       exception object\n    const VarDecl *NRVOVariable = nullptr;\n    if (IsThrownVarInScope)\n      NRVOVariable = getCopyElisionCandidate(QualType(), Ex, CES_Strict);\n\n    InitializedEntity Entity = InitializedEntity::InitializeException(\n        OpLoc, ExceptionObjectTy,\n        /*NRVO=*/NRVOVariable != nullptr);\n    ExprResult Res = PerformMoveOrCopyInitialization(\n        Entity, NRVOVariable, QualType(), Ex, IsThrownVarInScope);\n    if (Res.isInvalid())\n      return ExprError();\n    Ex = Res.get();\n  }\n\n  // PPC MMA non-pointer types are not allowed as throw expr types.\n  if (Ex && Context.getTargetInfo().getTriple().isPPC64())\n    CheckPPCMMAType(Ex->getType(), Ex->getBeginLoc());\n\n  return new (Context)\n      CXXThrowExpr(Ex, Context.VoidTy, OpLoc, IsThrownVarInScope);\n}\n\nstatic void\ncollectPublicBases(CXXRecordDecl *RD,\n                   llvm::DenseMap<CXXRecordDecl *, unsigned> &SubobjectsSeen,\n                   llvm::SmallPtrSetImpl<CXXRecordDecl *> &VBases,\n                   llvm::SetVector<CXXRecordDecl *> &PublicSubobjectsSeen,\n                   bool ParentIsPublic) {\n  for (const CXXBaseSpecifier &BS : RD->bases()) {\n    CXXRecordDecl *BaseDecl = BS.getType()->getAsCXXRecordDecl();\n    bool NewSubobject;\n    // Virtual bases constitute the same subobject.  Non-virtual bases are\n    // always distinct subobjects.\n    if (BS.isVirtual())\n      NewSubobject = VBases.insert(BaseDecl).second;\n    else\n      NewSubobject = true;\n\n    if (NewSubobject)\n      ++SubobjectsSeen[BaseDecl];\n\n    // Only add subobjects which have public access throughout the entire chain.\n    bool PublicPath = ParentIsPublic && BS.getAccessSpecifier() == AS_public;\n    if (PublicPath)\n      PublicSubobjectsSeen.insert(BaseDecl);\n\n    // Recurse on to each base subobject.\n    collectPublicBases(BaseDecl, SubobjectsSeen, VBases, PublicSubobjectsSeen,\n                       PublicPath);\n  }\n}\n\nstatic void getUnambiguousPublicSubobjects(\n    CXXRecordDecl *RD, llvm::SmallVectorImpl<CXXRecordDecl *> &Objects) {\n  llvm::DenseMap<CXXRecordDecl *, unsigned> SubobjectsSeen;\n  llvm::SmallSet<CXXRecordDecl *, 2> VBases;\n  llvm::SetVector<CXXRecordDecl *> PublicSubobjectsSeen;\n  SubobjectsSeen[RD] = 1;\n  PublicSubobjectsSeen.insert(RD);\n  collectPublicBases(RD, SubobjectsSeen, VBases, PublicSubobjectsSeen,\n                     /*ParentIsPublic=*/true);\n\n  for (CXXRecordDecl *PublicSubobject : PublicSubobjectsSeen) {\n    // Skip ambiguous objects.\n    if (SubobjectsSeen[PublicSubobject] > 1)\n      continue;\n\n    Objects.push_back(PublicSubobject);\n  }\n}\n\n/// CheckCXXThrowOperand - Validate the operand of a throw.\nbool Sema::CheckCXXThrowOperand(SourceLocation ThrowLoc,\n                                QualType ExceptionObjectTy, Expr *E) {\n  //   If the type of the exception would be an incomplete type or a pointer\n  //   to an incomplete type other than (cv) void the program is ill-formed.\n  QualType Ty = ExceptionObjectTy;\n  bool isPointer = false;\n  if (const PointerType* Ptr = Ty->getAs<PointerType>()) {\n    Ty = Ptr->getPointeeType();\n    isPointer = true;\n  }\n  if (!isPointer || !Ty->isVoidType()) {\n    if (RequireCompleteType(ThrowLoc, Ty,\n                            isPointer ? diag::err_throw_incomplete_ptr\n                                      : diag::err_throw_incomplete,\n                            E->getSourceRange()))\n      return true;\n\n    if (!isPointer && Ty->isSizelessType()) {\n      Diag(ThrowLoc, diag::err_throw_sizeless) << Ty << E->getSourceRange();\n      return true;\n    }\n\n    if (RequireNonAbstractType(ThrowLoc, ExceptionObjectTy,\n                               diag::err_throw_abstract_type, E))\n      return true;\n  }\n\n  // If the exception has class type, we need additional handling.\n  CXXRecordDecl *RD = Ty->getAsCXXRecordDecl();\n  if (!RD)\n    return false;\n\n  // If we are throwing a polymorphic class type or pointer thereof,\n  // exception handling will make use of the vtable.\n  MarkVTableUsed(ThrowLoc, RD);\n\n  // If a pointer is thrown, the referenced object will not be destroyed.\n  if (isPointer)\n    return false;\n\n  // If the class has a destructor, we must be able to call it.\n  if (!RD->hasIrrelevantDestructor()) {\n    if (CXXDestructorDecl *Destructor = LookupDestructor(RD)) {\n      MarkFunctionReferenced(E->getExprLoc(), Destructor);\n      CheckDestructorAccess(E->getExprLoc(), Destructor,\n                            PDiag(diag::err_access_dtor_exception) << Ty);\n      if (DiagnoseUseOfDecl(Destructor, E->getExprLoc()))\n        return true;\n    }\n  }\n\n  // The MSVC ABI creates a list of all types which can catch the exception\n  // object.  This list also references the appropriate copy constructor to call\n  // if the object is caught by value and has a non-trivial copy constructor.\n  if (Context.getTargetInfo().getCXXABI().isMicrosoft()) {\n    // We are only interested in the public, unambiguous bases contained within\n    // the exception object.  Bases which are ambiguous or otherwise\n    // inaccessible are not catchable types.\n    llvm::SmallVector<CXXRecordDecl *, 2> UnambiguousPublicSubobjects;\n    getUnambiguousPublicSubobjects(RD, UnambiguousPublicSubobjects);\n\n    for (CXXRecordDecl *Subobject : UnambiguousPublicSubobjects) {\n      // Attempt to lookup the copy constructor.  Various pieces of machinery\n      // will spring into action, like template instantiation, which means this\n      // cannot be a simple walk of the class's decls.  Instead, we must perform\n      // lookup and overload resolution.\n      CXXConstructorDecl *CD = LookupCopyingConstructor(Subobject, 0);\n      if (!CD || CD->isDeleted())\n        continue;\n\n      // Mark the constructor referenced as it is used by this throw expression.\n      MarkFunctionReferenced(E->getExprLoc(), CD);\n\n      // Skip this copy constructor if it is trivial, we don't need to record it\n      // in the catchable type data.\n      if (CD->isTrivial())\n        continue;\n\n      // The copy constructor is non-trivial, create a mapping from this class\n      // type to this constructor.\n      // N.B.  The selection of copy constructor is not sensitive to this\n      // particular throw-site.  Lookup will be performed at the catch-site to\n      // ensure that the copy constructor is, in fact, accessible (via\n      // friendship or any other means).\n      Context.addCopyConstructorForExceptionObject(Subobject, CD);\n\n      // We don't keep the instantiated default argument expressions around so\n      // we must rebuild them here.\n      for (unsigned I = 1, E = CD->getNumParams(); I != E; ++I) {\n        if (CheckCXXDefaultArgExpr(ThrowLoc, CD, CD->getParamDecl(I)))\n          return true;\n      }\n    }\n  }\n\n  // Under the Itanium C++ ABI, memory for the exception object is allocated by\n  // the runtime with no ability for the compiler to request additional\n  // alignment. Warn if the exception type requires alignment beyond the minimum\n  // guaranteed by the target C++ runtime.\n  if (Context.getTargetInfo().getCXXABI().isItaniumFamily()) {\n    CharUnits TypeAlign = Context.getTypeAlignInChars(Ty);\n    CharUnits ExnObjAlign = Context.getExnObjectAlignment();\n    if (ExnObjAlign < TypeAlign) {\n      Diag(ThrowLoc, diag::warn_throw_underaligned_obj);\n      Diag(ThrowLoc, diag::note_throw_underaligned_obj)\n          << Ty << (unsigned)TypeAlign.getQuantity()\n          << (unsigned)ExnObjAlign.getQuantity();\n    }\n  }\n\n  return false;\n}\n\nstatic QualType adjustCVQualifiersForCXXThisWithinLambda(\n    ArrayRef<FunctionScopeInfo *> FunctionScopes, QualType ThisTy,\n    DeclContext *CurSemaContext, ASTContext &ASTCtx) {\n\n  QualType ClassType = ThisTy->getPointeeType();\n  LambdaScopeInfo *CurLSI = nullptr;\n  DeclContext *CurDC = CurSemaContext;\n\n  // Iterate through the stack of lambdas starting from the innermost lambda to\n  // the outermost lambda, checking if '*this' is ever captured by copy - since\n  // that could change the cv-qualifiers of the '*this' object.\n  // The object referred to by '*this' starts out with the cv-qualifiers of its\n  // member function.  We then start with the innermost lambda and iterate\n  // outward checking to see if any lambda performs a by-copy capture of '*this'\n  // - and if so, any nested lambda must respect the 'constness' of that\n  // capturing lamdbda's call operator.\n  //\n\n  // Since the FunctionScopeInfo stack is representative of the lexical\n  // nesting of the lambda expressions during initial parsing (and is the best\n  // place for querying information about captures about lambdas that are\n  // partially processed) and perhaps during instantiation of function templates\n  // that contain lambda expressions that need to be transformed BUT not\n  // necessarily during instantiation of a nested generic lambda's function call\n  // operator (which might even be instantiated at the end of the TU) - at which\n  // time the DeclContext tree is mature enough to query capture information\n  // reliably - we use a two pronged approach to walk through all the lexically\n  // enclosing lambda expressions:\n  //\n  //  1) Climb down the FunctionScopeInfo stack as long as each item represents\n  //  a Lambda (i.e. LambdaScopeInfo) AND each LSI's 'closure-type' is lexically\n  //  enclosed by the call-operator of the LSI below it on the stack (while\n  //  tracking the enclosing DC for step 2 if needed).  Note the topmost LSI on\n  //  the stack represents the innermost lambda.\n  //\n  //  2) If we run out of enclosing LSI's, check if the enclosing DeclContext\n  //  represents a lambda's call operator.  If it does, we must be instantiating\n  //  a generic lambda's call operator (represented by the Current LSI, and\n  //  should be the only scenario where an inconsistency between the LSI and the\n  //  DeclContext should occur), so climb out the DeclContexts if they\n  //  represent lambdas, while querying the corresponding closure types\n  //  regarding capture information.\n\n  // 1) Climb down the function scope info stack.\n  for (int I = FunctionScopes.size();\n       I-- && isa<LambdaScopeInfo>(FunctionScopes[I]) &&\n       (!CurLSI || !CurLSI->Lambda || CurLSI->Lambda->getDeclContext() ==\n                       cast<LambdaScopeInfo>(FunctionScopes[I])->CallOperator);\n       CurDC = getLambdaAwareParentOfDeclContext(CurDC)) {\n    CurLSI = cast<LambdaScopeInfo>(FunctionScopes[I]);\n\n    if (!CurLSI->isCXXThisCaptured())\n        continue;\n\n    auto C = CurLSI->getCXXThisCapture();\n\n    if (C.isCopyCapture()) {\n      ClassType.removeLocalCVRQualifiers(Qualifiers::CVRMask);\n      if (CurLSI->CallOperator->isConst())\n        ClassType.addConst();\n      return ASTCtx.getPointerType(ClassType);\n    }\n  }\n\n  // 2) We've run out of ScopeInfos but check if CurDC is a lambda (which can\n  // happen during instantiation of its nested generic lambda call operator)\n  if (isLambdaCallOperator(CurDC)) {\n    assert(CurLSI && \"While computing 'this' capture-type for a generic \"\n                     \"lambda, we must have a corresponding LambdaScopeInfo\");\n    assert(isGenericLambdaCallOperatorSpecialization(CurLSI->CallOperator) &&\n           \"While computing 'this' capture-type for a generic lambda, when we \"\n           \"run out of enclosing LSI's, yet the enclosing DC is a \"\n           \"lambda-call-operator we must be (i.e. Current LSI) in a generic \"\n           \"lambda call oeprator\");\n    assert(CurDC == getLambdaAwareParentOfDeclContext(CurLSI->CallOperator));\n\n    auto IsThisCaptured =\n        [](CXXRecordDecl *Closure, bool &IsByCopy, bool &IsConst) {\n      IsConst = false;\n      IsByCopy = false;\n      for (auto &&C : Closure->captures()) {\n        if (C.capturesThis()) {\n          if (C.getCaptureKind() == LCK_StarThis)\n            IsByCopy = true;\n          if (Closure->getLambdaCallOperator()->isConst())\n            IsConst = true;\n          return true;\n        }\n      }\n      return false;\n    };\n\n    bool IsByCopyCapture = false;\n    bool IsConstCapture = false;\n    CXXRecordDecl *Closure = cast<CXXRecordDecl>(CurDC->getParent());\n    while (Closure &&\n           IsThisCaptured(Closure, IsByCopyCapture, IsConstCapture)) {\n      if (IsByCopyCapture) {\n        ClassType.removeLocalCVRQualifiers(Qualifiers::CVRMask);\n        if (IsConstCapture)\n          ClassType.addConst();\n        return ASTCtx.getPointerType(ClassType);\n      }\n      Closure = isLambdaCallOperator(Closure->getParent())\n                    ? cast<CXXRecordDecl>(Closure->getParent()->getParent())\n                    : nullptr;\n    }\n  }\n  return ASTCtx.getPointerType(ClassType);\n}\n\nQualType Sema::getCurrentThisType() {\n  DeclContext *DC = getFunctionLevelDeclContext();\n  QualType ThisTy = CXXThisTypeOverride;\n\n  if (CXXMethodDecl *method = dyn_cast<CXXMethodDecl>(DC)) {\n    if (method && method->isInstance())\n      ThisTy = method->getThisType();\n  }\n\n  if (ThisTy.isNull() && isLambdaCallOperator(CurContext) &&\n      inTemplateInstantiation() && isa<CXXRecordDecl>(DC)) {\n\n    // This is a lambda call operator that is being instantiated as a default\n    // initializer. DC must point to the enclosing class type, so we can recover\n    // the 'this' type from it.\n    QualType ClassTy = Context.getTypeDeclType(cast<CXXRecordDecl>(DC));\n    // There are no cv-qualifiers for 'this' within default initializers,\n    // per [expr.prim.general]p4.\n    ThisTy = Context.getPointerType(ClassTy);\n  }\n\n  // If we are within a lambda's call operator, the cv-qualifiers of 'this'\n  // might need to be adjusted if the lambda or any of its enclosing lambda's\n  // captures '*this' by copy.\n  if (!ThisTy.isNull() && isLambdaCallOperator(CurContext))\n    return adjustCVQualifiersForCXXThisWithinLambda(FunctionScopes, ThisTy,\n                                                    CurContext, Context);\n  return ThisTy;\n}\n\nSema::CXXThisScopeRAII::CXXThisScopeRAII(Sema &S,\n                                         Decl *ContextDecl,\n                                         Qualifiers CXXThisTypeQuals,\n                                         bool Enabled)\n  : S(S), OldCXXThisTypeOverride(S.CXXThisTypeOverride), Enabled(false)\n{\n  if (!Enabled || !ContextDecl)\n    return;\n\n  CXXRecordDecl *Record = nullptr;\n  if (ClassTemplateDecl *Template = dyn_cast<ClassTemplateDecl>(ContextDecl))\n    Record = Template->getTemplatedDecl();\n  else\n    Record = cast<CXXRecordDecl>(ContextDecl);\n\n  QualType T = S.Context.getRecordType(Record);\n  T = S.getASTContext().getQualifiedType(T, CXXThisTypeQuals);\n\n  S.CXXThisTypeOverride = S.Context.getPointerType(T);\n\n  this->Enabled = true;\n}\n\n\nSema::CXXThisScopeRAII::~CXXThisScopeRAII() {\n  if (Enabled) {\n    S.CXXThisTypeOverride = OldCXXThisTypeOverride;\n  }\n}\n\nbool Sema::CheckCXXThisCapture(SourceLocation Loc, const bool Explicit,\n    bool BuildAndDiagnose, const unsigned *const FunctionScopeIndexToStopAt,\n    const bool ByCopy) {\n  // We don't need to capture this in an unevaluated context.\n  if (isUnevaluatedContext() && !Explicit)\n    return true;\n\n  assert((!ByCopy || Explicit) && \"cannot implicitly capture *this by value\");\n\n  const int MaxFunctionScopesIndex = FunctionScopeIndexToStopAt\n                                         ? *FunctionScopeIndexToStopAt\n                                         : FunctionScopes.size() - 1;\n\n  // Check that we can capture the *enclosing object* (referred to by '*this')\n  // by the capturing-entity/closure (lambda/block/etc) at\n  // MaxFunctionScopesIndex-deep on the FunctionScopes stack.\n\n  // Note: The *enclosing object* can only be captured by-value by a\n  // closure that is a lambda, using the explicit notation:\n  //    [*this] { ... }.\n  // Every other capture of the *enclosing object* results in its by-reference\n  // capture.\n\n  // For a closure 'L' (at MaxFunctionScopesIndex in the FunctionScopes\n  // stack), we can capture the *enclosing object* only if:\n  // - 'L' has an explicit byref or byval capture of the *enclosing object*\n  // -  or, 'L' has an implicit capture.\n  // AND\n  //   -- there is no enclosing closure\n  //   -- or, there is some enclosing closure 'E' that has already captured the\n  //      *enclosing object*, and every intervening closure (if any) between 'E'\n  //      and 'L' can implicitly capture the *enclosing object*.\n  //   -- or, every enclosing closure can implicitly capture the\n  //      *enclosing object*\n\n\n  unsigned NumCapturingClosures = 0;\n  for (int idx = MaxFunctionScopesIndex; idx >= 0; idx--) {\n    if (CapturingScopeInfo *CSI =\n            dyn_cast<CapturingScopeInfo>(FunctionScopes[idx])) {\n      if (CSI->CXXThisCaptureIndex != 0) {\n        // 'this' is already being captured; there isn't anything more to do.\n        CSI->Captures[CSI->CXXThisCaptureIndex - 1].markUsed(BuildAndDiagnose);\n        break;\n      }\n      LambdaScopeInfo *LSI = dyn_cast<LambdaScopeInfo>(CSI);\n      if (LSI && isGenericLambdaCallOperatorSpecialization(LSI->CallOperator)) {\n        // This context can't implicitly capture 'this'; fail out.\n        if (BuildAndDiagnose)\n          Diag(Loc, diag::err_this_capture)\n              << (Explicit && idx == MaxFunctionScopesIndex);\n        return true;\n      }\n      if (CSI->ImpCaptureStyle == CapturingScopeInfo::ImpCap_LambdaByref ||\n          CSI->ImpCaptureStyle == CapturingScopeInfo::ImpCap_LambdaByval ||\n          CSI->ImpCaptureStyle == CapturingScopeInfo::ImpCap_Block ||\n          CSI->ImpCaptureStyle == CapturingScopeInfo::ImpCap_CapturedRegion ||\n          (Explicit && idx == MaxFunctionScopesIndex)) {\n        // Regarding (Explicit && idx == MaxFunctionScopesIndex): only the first\n        // iteration through can be an explicit capture, all enclosing closures,\n        // if any, must perform implicit captures.\n\n        // This closure can capture 'this'; continue looking upwards.\n        NumCapturingClosures++;\n        continue;\n      }\n      // This context can't implicitly capture 'this'; fail out.\n      if (BuildAndDiagnose)\n        Diag(Loc, diag::err_this_capture)\n            << (Explicit && idx == MaxFunctionScopesIndex);\n      return true;\n    }\n    break;\n  }\n  if (!BuildAndDiagnose) return false;\n\n  // If we got here, then the closure at MaxFunctionScopesIndex on the\n  // FunctionScopes stack, can capture the *enclosing object*, so capture it\n  // (including implicit by-reference captures in any enclosing closures).\n\n  // In the loop below, respect the ByCopy flag only for the closure requesting\n  // the capture (i.e. first iteration through the loop below).  Ignore it for\n  // all enclosing closure's up to NumCapturingClosures (since they must be\n  // implicitly capturing the *enclosing  object* by reference (see loop\n  // above)).\n  assert((!ByCopy ||\n          dyn_cast<LambdaScopeInfo>(FunctionScopes[MaxFunctionScopesIndex])) &&\n         \"Only a lambda can capture the enclosing object (referred to by \"\n         \"*this) by copy\");\n  QualType ThisTy = getCurrentThisType();\n  for (int idx = MaxFunctionScopesIndex; NumCapturingClosures;\n       --idx, --NumCapturingClosures) {\n    CapturingScopeInfo *CSI = cast<CapturingScopeInfo>(FunctionScopes[idx]);\n\n    // The type of the corresponding data member (not a 'this' pointer if 'by\n    // copy').\n    QualType CaptureType = ThisTy;\n    if (ByCopy) {\n      // If we are capturing the object referred to by '*this' by copy, ignore\n      // any cv qualifiers inherited from the type of the member function for\n      // the type of the closure-type's corresponding data member and any use\n      // of 'this'.\n      CaptureType = ThisTy->getPointeeType();\n      CaptureType.removeLocalCVRQualifiers(Qualifiers::CVRMask);\n    }\n\n    bool isNested = NumCapturingClosures > 1;\n    CSI->addThisCapture(isNested, Loc, CaptureType, ByCopy);\n  }\n  return false;\n}\n\nExprResult Sema::ActOnCXXThis(SourceLocation Loc) {\n  /// C++ 9.3.2: In the body of a non-static member function, the keyword this\n  /// is a non-lvalue expression whose value is the address of the object for\n  /// which the function is called.\n\n  QualType ThisTy = getCurrentThisType();\n  if (ThisTy.isNull())\n    return Diag(Loc, diag::err_invalid_this_use);\n  return BuildCXXThisExpr(Loc, ThisTy, /*IsImplicit=*/false);\n}\n\nExpr *Sema::BuildCXXThisExpr(SourceLocation Loc, QualType Type,\n                             bool IsImplicit) {\n  auto *This = new (Context) CXXThisExpr(Loc, Type, IsImplicit);\n  MarkThisReferenced(This);\n  return This;\n}\n\nvoid Sema::MarkThisReferenced(CXXThisExpr *This) {\n  CheckCXXThisCapture(This->getExprLoc());\n}\n\nbool Sema::isThisOutsideMemberFunctionBody(QualType BaseType) {\n  // If we're outside the body of a member function, then we'll have a specified\n  // type for 'this'.\n  if (CXXThisTypeOverride.isNull())\n    return false;\n\n  // Determine whether we're looking into a class that's currently being\n  // defined.\n  CXXRecordDecl *Class = BaseType->getAsCXXRecordDecl();\n  return Class && Class->isBeingDefined();\n}\n\n/// Parse construction of a specified type.\n/// Can be interpreted either as function-style casting (\"int(x)\")\n/// or class type construction (\"ClassType(x,y,z)\")\n/// or creation of a value-initialized type (\"int()\").\nExprResult\nSema::ActOnCXXTypeConstructExpr(ParsedType TypeRep,\n                                SourceLocation LParenOrBraceLoc,\n                                MultiExprArg exprs,\n                                SourceLocation RParenOrBraceLoc,\n                                bool ListInitialization) {\n  if (!TypeRep)\n    return ExprError();\n\n  TypeSourceInfo *TInfo;\n  QualType Ty = GetTypeFromParser(TypeRep, &TInfo);\n  if (!TInfo)\n    TInfo = Context.getTrivialTypeSourceInfo(Ty, SourceLocation());\n\n  auto Result = BuildCXXTypeConstructExpr(TInfo, LParenOrBraceLoc, exprs,\n                                          RParenOrBraceLoc, ListInitialization);\n  // Avoid creating a non-type-dependent expression that contains typos.\n  // Non-type-dependent expressions are liable to be discarded without\n  // checking for embedded typos.\n  if (!Result.isInvalid() && Result.get()->isInstantiationDependent() &&\n      !Result.get()->isTypeDependent())\n    Result = CorrectDelayedTyposInExpr(Result.get());\n  else if (Result.isInvalid())\n    Result = CreateRecoveryExpr(TInfo->getTypeLoc().getBeginLoc(),\n                                RParenOrBraceLoc, exprs, Ty);\n  return Result;\n}\n\nExprResult\nSema::BuildCXXTypeConstructExpr(TypeSourceInfo *TInfo,\n                                SourceLocation LParenOrBraceLoc,\n                                MultiExprArg Exprs,\n                                SourceLocation RParenOrBraceLoc,\n                                bool ListInitialization) {\n  QualType Ty = TInfo->getType();\n  SourceLocation TyBeginLoc = TInfo->getTypeLoc().getBeginLoc();\n\n  assert((!ListInitialization ||\n          (Exprs.size() == 1 && isa<InitListExpr>(Exprs[0]))) &&\n         \"List initialization must have initializer list as expression.\");\n  SourceRange FullRange = SourceRange(TyBeginLoc, RParenOrBraceLoc);\n\n  InitializedEntity Entity = InitializedEntity::InitializeTemporary(TInfo);\n  InitializationKind Kind =\n      Exprs.size()\n          ? ListInitialization\n                ? InitializationKind::CreateDirectList(\n                      TyBeginLoc, LParenOrBraceLoc, RParenOrBraceLoc)\n                : InitializationKind::CreateDirect(TyBeginLoc, LParenOrBraceLoc,\n                                                   RParenOrBraceLoc)\n          : InitializationKind::CreateValue(TyBeginLoc, LParenOrBraceLoc,\n                                            RParenOrBraceLoc);\n\n  // C++1z [expr.type.conv]p1:\n  //   If the type is a placeholder for a deduced class type, [...perform class\n  //   template argument deduction...]\n  DeducedType *Deduced = Ty->getContainedDeducedType();\n  if (Deduced && isa<DeducedTemplateSpecializationType>(Deduced)) {\n    Ty = DeduceTemplateSpecializationFromInitializer(TInfo, Entity,\n                                                     Kind, Exprs);\n    if (Ty.isNull())\n      return ExprError();\n    Entity = InitializedEntity::InitializeTemporary(TInfo, Ty);\n  }\n\n  if (Ty->isDependentType() || CallExpr::hasAnyTypeDependentArguments(Exprs)) {\n    // FIXME: CXXUnresolvedConstructExpr does not model list-initialization\n    // directly. We work around this by dropping the locations of the braces.\n    SourceRange Locs = ListInitialization\n                           ? SourceRange()\n                           : SourceRange(LParenOrBraceLoc, RParenOrBraceLoc);\n    return CXXUnresolvedConstructExpr::Create(Context, Ty.getNonReferenceType(),\n                                              TInfo, Locs.getBegin(), Exprs,\n                                              Locs.getEnd());\n  }\n\n  // C++ [expr.type.conv]p1:\n  // If the expression list is a parenthesized single expression, the type\n  // conversion expression is equivalent (in definedness, and if defined in\n  // meaning) to the corresponding cast expression.\n  if (Exprs.size() == 1 && !ListInitialization &&\n      !isa<InitListExpr>(Exprs[0])) {\n    Expr *Arg = Exprs[0];\n    return BuildCXXFunctionalCastExpr(TInfo, Ty, LParenOrBraceLoc, Arg,\n                                      RParenOrBraceLoc);\n  }\n\n  //   For an expression of the form T(), T shall not be an array type.\n  QualType ElemTy = Ty;\n  if (Ty->isArrayType()) {\n    if (!ListInitialization)\n      return ExprError(Diag(TyBeginLoc, diag::err_value_init_for_array_type)\n                         << FullRange);\n    ElemTy = Context.getBaseElementType(Ty);\n  }\n\n  // There doesn't seem to be an explicit rule against this but sanity demands\n  // we only construct objects with object types.\n  if (Ty->isFunctionType())\n    return ExprError(Diag(TyBeginLoc, diag::err_init_for_function_type)\n                       << Ty << FullRange);\n\n  // C++17 [expr.type.conv]p2:\n  //   If the type is cv void and the initializer is (), the expression is a\n  //   prvalue of the specified type that performs no initialization.\n  if (!Ty->isVoidType() &&\n      RequireCompleteType(TyBeginLoc, ElemTy,\n                          diag::err_invalid_incomplete_type_use, FullRange))\n    return ExprError();\n\n  //   Otherwise, the expression is a prvalue of the specified type whose\n  //   result object is direct-initialized (11.6) with the initializer.\n  InitializationSequence InitSeq(*this, Entity, Kind, Exprs);\n  ExprResult Result = InitSeq.Perform(*this, Entity, Kind, Exprs);\n\n  if (Result.isInvalid())\n    return Result;\n\n  Expr *Inner = Result.get();\n  if (CXXBindTemporaryExpr *BTE = dyn_cast_or_null<CXXBindTemporaryExpr>(Inner))\n    Inner = BTE->getSubExpr();\n  if (!isa<CXXTemporaryObjectExpr>(Inner) &&\n      !isa<CXXScalarValueInitExpr>(Inner)) {\n    // If we created a CXXTemporaryObjectExpr, that node also represents the\n    // functional cast. Otherwise, create an explicit cast to represent\n    // the syntactic form of a functional-style cast that was used here.\n    //\n    // FIXME: Creating a CXXFunctionalCastExpr around a CXXConstructExpr\n    // would give a more consistent AST representation than using a\n    // CXXTemporaryObjectExpr. It's also weird that the functional cast\n    // is sometimes handled by initialization and sometimes not.\n    QualType ResultType = Result.get()->getType();\n    SourceRange Locs = ListInitialization\n                           ? SourceRange()\n                           : SourceRange(LParenOrBraceLoc, RParenOrBraceLoc);\n    Result = CXXFunctionalCastExpr::Create(\n        Context, ResultType, Expr::getValueKindForType(Ty), TInfo, CK_NoOp,\n        Result.get(), /*Path=*/nullptr, CurFPFeatureOverrides(),\n        Locs.getBegin(), Locs.getEnd());\n  }\n\n  return Result;\n}\n\nbool Sema::isUsualDeallocationFunction(const CXXMethodDecl *Method) {\n  // [CUDA] Ignore this function, if we can't call it.\n  const FunctionDecl *Caller = dyn_cast<FunctionDecl>(CurContext);\n  if (getLangOpts().CUDA) {\n    auto CallPreference = IdentifyCUDAPreference(Caller, Method);\n    // If it's not callable at all, it's not the right function.\n    if (CallPreference < CFP_WrongSide)\n      return false;\n    if (CallPreference == CFP_WrongSide) {\n      // Maybe. We have to check if there are better alternatives.\n      DeclContext::lookup_result R =\n          Method->getDeclContext()->lookup(Method->getDeclName());\n      for (const auto *D : R) {\n        if (const auto *FD = dyn_cast<FunctionDecl>(D)) {\n          if (IdentifyCUDAPreference(Caller, FD) > CFP_WrongSide)\n            return false;\n        }\n      }\n      // We've found no better variants.\n    }\n  }\n\n  SmallVector<const FunctionDecl*, 4> PreventedBy;\n  bool Result = Method->isUsualDeallocationFunction(PreventedBy);\n\n  if (Result || !getLangOpts().CUDA || PreventedBy.empty())\n    return Result;\n\n  // In case of CUDA, return true if none of the 1-argument deallocator\n  // functions are actually callable.\n  return llvm::none_of(PreventedBy, [&](const FunctionDecl *FD) {\n    assert(FD->getNumParams() == 1 &&\n           \"Only single-operand functions should be in PreventedBy\");\n    return IdentifyCUDAPreference(Caller, FD) >= CFP_HostDevice;\n  });\n}\n\n/// Determine whether the given function is a non-placement\n/// deallocation function.\nstatic bool isNonPlacementDeallocationFunction(Sema &S, FunctionDecl *FD) {\n  if (CXXMethodDecl *Method = dyn_cast<CXXMethodDecl>(FD))\n    return S.isUsualDeallocationFunction(Method);\n\n  if (FD->getOverloadedOperator() != OO_Delete &&\n      FD->getOverloadedOperator() != OO_Array_Delete)\n    return false;\n\n  unsigned UsualParams = 1;\n\n  if (S.getLangOpts().SizedDeallocation && UsualParams < FD->getNumParams() &&\n      S.Context.hasSameUnqualifiedType(\n          FD->getParamDecl(UsualParams)->getType(),\n          S.Context.getSizeType()))\n    ++UsualParams;\n\n  if (S.getLangOpts().AlignedAllocation && UsualParams < FD->getNumParams() &&\n      S.Context.hasSameUnqualifiedType(\n          FD->getParamDecl(UsualParams)->getType(),\n          S.Context.getTypeDeclType(S.getStdAlignValT())))\n    ++UsualParams;\n\n  return UsualParams == FD->getNumParams();\n}\n\nnamespace {\n  struct UsualDeallocFnInfo {\n    UsualDeallocFnInfo() : Found(), FD(nullptr) {}\n    UsualDeallocFnInfo(Sema &S, DeclAccessPair Found)\n        : Found(Found), FD(dyn_cast<FunctionDecl>(Found->getUnderlyingDecl())),\n          Destroying(false), HasSizeT(false), HasAlignValT(false),\n          CUDAPref(Sema::CFP_Native) {\n      // A function template declaration is never a usual deallocation function.\n      if (!FD)\n        return;\n      unsigned NumBaseParams = 1;\n      if (FD->isDestroyingOperatorDelete()) {\n        Destroying = true;\n        ++NumBaseParams;\n      }\n\n      if (NumBaseParams < FD->getNumParams() &&\n          S.Context.hasSameUnqualifiedType(\n              FD->getParamDecl(NumBaseParams)->getType(),\n              S.Context.getSizeType())) {\n        ++NumBaseParams;\n        HasSizeT = true;\n      }\n\n      if (NumBaseParams < FD->getNumParams() &&\n          FD->getParamDecl(NumBaseParams)->getType()->isAlignValT()) {\n        ++NumBaseParams;\n        HasAlignValT = true;\n      }\n\n      // In CUDA, determine how much we'd like / dislike to call this.\n      if (S.getLangOpts().CUDA)\n        if (auto *Caller = dyn_cast<FunctionDecl>(S.CurContext))\n          CUDAPref = S.IdentifyCUDAPreference(Caller, FD);\n    }\n\n    explicit operator bool() const { return FD; }\n\n    bool isBetterThan(const UsualDeallocFnInfo &Other, bool WantSize,\n                      bool WantAlign) const {\n      // C++ P0722:\n      //   A destroying operator delete is preferred over a non-destroying\n      //   operator delete.\n      if (Destroying != Other.Destroying)\n        return Destroying;\n\n      // C++17 [expr.delete]p10:\n      //   If the type has new-extended alignment, a function with a parameter\n      //   of type std::align_val_t is preferred; otherwise a function without\n      //   such a parameter is preferred\n      if (HasAlignValT != Other.HasAlignValT)\n        return HasAlignValT == WantAlign;\n\n      if (HasSizeT != Other.HasSizeT)\n        return HasSizeT == WantSize;\n\n      // Use CUDA call preference as a tiebreaker.\n      return CUDAPref > Other.CUDAPref;\n    }\n\n    DeclAccessPair Found;\n    FunctionDecl *FD;\n    bool Destroying, HasSizeT, HasAlignValT;\n    Sema::CUDAFunctionPreference CUDAPref;\n  };\n}\n\n/// Determine whether a type has new-extended alignment. This may be called when\n/// the type is incomplete (for a delete-expression with an incomplete pointee\n/// type), in which case it will conservatively return false if the alignment is\n/// not known.\nstatic bool hasNewExtendedAlignment(Sema &S, QualType AllocType) {\n  return S.getLangOpts().AlignedAllocation &&\n         S.getASTContext().getTypeAlignIfKnown(AllocType) >\n             S.getASTContext().getTargetInfo().getNewAlign();\n}\n\n/// Select the correct \"usual\" deallocation function to use from a selection of\n/// deallocation functions (either global or class-scope).\nstatic UsualDeallocFnInfo resolveDeallocationOverload(\n    Sema &S, LookupResult &R, bool WantSize, bool WantAlign,\n    llvm::SmallVectorImpl<UsualDeallocFnInfo> *BestFns = nullptr) {\n  UsualDeallocFnInfo Best;\n\n  for (auto I = R.begin(), E = R.end(); I != E; ++I) {\n    UsualDeallocFnInfo Info(S, I.getPair());\n    if (!Info || !isNonPlacementDeallocationFunction(S, Info.FD) ||\n        Info.CUDAPref == Sema::CFP_Never)\n      continue;\n\n    if (!Best) {\n      Best = Info;\n      if (BestFns)\n        BestFns->push_back(Info);\n      continue;\n    }\n\n    if (Best.isBetterThan(Info, WantSize, WantAlign))\n      continue;\n\n    //   If more than one preferred function is found, all non-preferred\n    //   functions are eliminated from further consideration.\n    if (BestFns && Info.isBetterThan(Best, WantSize, WantAlign))\n      BestFns->clear();\n\n    Best = Info;\n    if (BestFns)\n      BestFns->push_back(Info);\n  }\n\n  return Best;\n}\n\n/// Determine whether a given type is a class for which 'delete[]' would call\n/// a member 'operator delete[]' with a 'size_t' parameter. This implies that\n/// we need to store the array size (even if the type is\n/// trivially-destructible).\nstatic bool doesUsualArrayDeleteWantSize(Sema &S, SourceLocation loc,\n                                         QualType allocType) {\n  const RecordType *record =\n    allocType->getBaseElementTypeUnsafe()->getAs<RecordType>();\n  if (!record) return false;\n\n  // Try to find an operator delete[] in class scope.\n\n  DeclarationName deleteName =\n    S.Context.DeclarationNames.getCXXOperatorName(OO_Array_Delete);\n  LookupResult ops(S, deleteName, loc, Sema::LookupOrdinaryName);\n  S.LookupQualifiedName(ops, record->getDecl());\n\n  // We're just doing this for information.\n  ops.suppressDiagnostics();\n\n  // Very likely: there's no operator delete[].\n  if (ops.empty()) return false;\n\n  // If it's ambiguous, it should be illegal to call operator delete[]\n  // on this thing, so it doesn't matter if we allocate extra space or not.\n  if (ops.isAmbiguous()) return false;\n\n  // C++17 [expr.delete]p10:\n  //   If the deallocation functions have class scope, the one without a\n  //   parameter of type std::size_t is selected.\n  auto Best = resolveDeallocationOverload(\n      S, ops, /*WantSize*/false,\n      /*WantAlign*/hasNewExtendedAlignment(S, allocType));\n  return Best && Best.HasSizeT;\n}\n\n/// Parsed a C++ 'new' expression (C++ 5.3.4).\n///\n/// E.g.:\n/// @code new (memory) int[size][4] @endcode\n/// or\n/// @code ::new Foo(23, \"hello\") @endcode\n///\n/// \\param StartLoc The first location of the expression.\n/// \\param UseGlobal True if 'new' was prefixed with '::'.\n/// \\param PlacementLParen Opening paren of the placement arguments.\n/// \\param PlacementArgs Placement new arguments.\n/// \\param PlacementRParen Closing paren of the placement arguments.\n/// \\param TypeIdParens If the type is in parens, the source range.\n/// \\param D The type to be allocated, as well as array dimensions.\n/// \\param Initializer The initializing expression or initializer-list, or null\n///   if there is none.\nExprResult\nSema::ActOnCXXNew(SourceLocation StartLoc, bool UseGlobal,\n                  SourceLocation PlacementLParen, MultiExprArg PlacementArgs,\n                  SourceLocation PlacementRParen, SourceRange TypeIdParens,\n                  Declarator &D, Expr *Initializer) {\n  Optional<Expr *> ArraySize;\n  // If the specified type is an array, unwrap it and save the expression.\n  if (D.getNumTypeObjects() > 0 &&\n      D.getTypeObject(0).Kind == DeclaratorChunk::Array) {\n    DeclaratorChunk &Chunk = D.getTypeObject(0);\n    if (D.getDeclSpec().hasAutoTypeSpec())\n      return ExprError(Diag(Chunk.Loc, diag::err_new_array_of_auto)\n        << D.getSourceRange());\n    if (Chunk.Arr.hasStatic)\n      return ExprError(Diag(Chunk.Loc, diag::err_static_illegal_in_new)\n        << D.getSourceRange());\n    if (!Chunk.Arr.NumElts && !Initializer)\n      return ExprError(Diag(Chunk.Loc, diag::err_array_new_needs_size)\n        << D.getSourceRange());\n\n    ArraySize = static_cast<Expr*>(Chunk.Arr.NumElts);\n    D.DropFirstTypeObject();\n  }\n\n  // Every dimension shall be of constant size.\n  if (ArraySize) {\n    for (unsigned I = 0, N = D.getNumTypeObjects(); I < N; ++I) {\n      if (D.getTypeObject(I).Kind != DeclaratorChunk::Array)\n        break;\n\n      DeclaratorChunk::ArrayTypeInfo &Array = D.getTypeObject(I).Arr;\n      if (Expr *NumElts = (Expr *)Array.NumElts) {\n        if (!NumElts->isTypeDependent() && !NumElts->isValueDependent()) {\n          // FIXME: GCC permits constant folding here. We should either do so consistently\n          // or not do so at all, rather than changing behavior in C++14 onwards.\n          if (getLangOpts().CPlusPlus14) {\n            // C++1y [expr.new]p6: Every constant-expression in a noptr-new-declarator\n            //   shall be a converted constant expression (5.19) of type std::size_t\n            //   and shall evaluate to a strictly positive value.\n            llvm::APSInt Value(Context.getIntWidth(Context.getSizeType()));\n            Array.NumElts\n             = CheckConvertedConstantExpression(NumElts, Context.getSizeType(), Value,\n                                                CCEK_ArrayBound)\n                 .get();\n          } else {\n            Array.NumElts =\n                VerifyIntegerConstantExpression(\n                    NumElts, nullptr, diag::err_new_array_nonconst, AllowFold)\n                    .get();\n          }\n          if (!Array.NumElts)\n            return ExprError();\n        }\n      }\n    }\n  }\n\n  TypeSourceInfo *TInfo = GetTypeForDeclarator(D, /*Scope=*/nullptr);\n  QualType AllocType = TInfo->getType();\n  if (D.isInvalidType())\n    return ExprError();\n\n  SourceRange DirectInitRange;\n  if (ParenListExpr *List = dyn_cast_or_null<ParenListExpr>(Initializer))\n    DirectInitRange = List->getSourceRange();\n\n  return BuildCXXNew(SourceRange(StartLoc, D.getEndLoc()), UseGlobal,\n                     PlacementLParen, PlacementArgs, PlacementRParen,\n                     TypeIdParens, AllocType, TInfo, ArraySize, DirectInitRange,\n                     Initializer);\n}\n\nstatic bool isLegalArrayNewInitializer(CXXNewExpr::InitializationStyle Style,\n                                       Expr *Init) {\n  if (!Init)\n    return true;\n  if (ParenListExpr *PLE = dyn_cast<ParenListExpr>(Init))\n    return PLE->getNumExprs() == 0;\n  if (isa<ImplicitValueInitExpr>(Init))\n    return true;\n  else if (CXXConstructExpr *CCE = dyn_cast<CXXConstructExpr>(Init))\n    return !CCE->isListInitialization() &&\n           CCE->getConstructor()->isDefaultConstructor();\n  else if (Style == CXXNewExpr::ListInit) {\n    assert(isa<InitListExpr>(Init) &&\n           \"Shouldn't create list CXXConstructExprs for arrays.\");\n    return true;\n  }\n  return false;\n}\n\nbool\nSema::isUnavailableAlignedAllocationFunction(const FunctionDecl &FD) const {\n  if (!getLangOpts().AlignedAllocationUnavailable)\n    return false;\n  if (FD.isDefined())\n    return false;\n  Optional<unsigned> AlignmentParam;\n  if (FD.isReplaceableGlobalAllocationFunction(&AlignmentParam) &&\n      AlignmentParam.hasValue())\n    return true;\n  return false;\n}\n\n// Emit a diagnostic if an aligned allocation/deallocation function that is not\n// implemented in the standard library is selected.\nvoid Sema::diagnoseUnavailableAlignedAllocation(const FunctionDecl &FD,\n                                                SourceLocation Loc) {\n  if (isUnavailableAlignedAllocationFunction(FD)) {\n    const llvm::Triple &T = getASTContext().getTargetInfo().getTriple();\n    StringRef OSName = AvailabilityAttr::getPlatformNameSourceSpelling(\n        getASTContext().getTargetInfo().getPlatformName());\n    VersionTuple OSVersion = alignedAllocMinVersion(T.getOS());\n\n    OverloadedOperatorKind Kind = FD.getDeclName().getCXXOverloadedOperator();\n    bool IsDelete = Kind == OO_Delete || Kind == OO_Array_Delete;\n    Diag(Loc, diag::err_aligned_allocation_unavailable)\n        << IsDelete << FD.getType().getAsString() << OSName\n        << OSVersion.getAsString() << OSVersion.empty();\n    Diag(Loc, diag::note_silence_aligned_allocation_unavailable);\n  }\n}\n\nExprResult\nSema::BuildCXXNew(SourceRange Range, bool UseGlobal,\n                  SourceLocation PlacementLParen,\n                  MultiExprArg PlacementArgs,\n                  SourceLocation PlacementRParen,\n                  SourceRange TypeIdParens,\n                  QualType AllocType,\n                  TypeSourceInfo *AllocTypeInfo,\n                  Optional<Expr *> ArraySize,\n                  SourceRange DirectInitRange,\n                  Expr *Initializer) {\n  SourceRange TypeRange = AllocTypeInfo->getTypeLoc().getSourceRange();\n  SourceLocation StartLoc = Range.getBegin();\n\n  CXXNewExpr::InitializationStyle initStyle;\n  if (DirectInitRange.isValid()) {\n    assert(Initializer && \"Have parens but no initializer.\");\n    initStyle = CXXNewExpr::CallInit;\n  } else if (Initializer && isa<InitListExpr>(Initializer))\n    initStyle = CXXNewExpr::ListInit;\n  else {\n    assert((!Initializer || isa<ImplicitValueInitExpr>(Initializer) ||\n            isa<CXXConstructExpr>(Initializer)) &&\n           \"Initializer expression that cannot have been implicitly created.\");\n    initStyle = CXXNewExpr::NoInit;\n  }\n\n  Expr **Inits = &Initializer;\n  unsigned NumInits = Initializer ? 1 : 0;\n  if (ParenListExpr *List = dyn_cast_or_null<ParenListExpr>(Initializer)) {\n    assert(initStyle == CXXNewExpr::CallInit && \"paren init for non-call init\");\n    Inits = List->getExprs();\n    NumInits = List->getNumExprs();\n  }\n\n  // C++11 [expr.new]p15:\n  //   A new-expression that creates an object of type T initializes that\n  //   object as follows:\n  InitializationKind Kind\n      //     - If the new-initializer is omitted, the object is default-\n      //       initialized (8.5); if no initialization is performed,\n      //       the object has indeterminate value\n      = initStyle == CXXNewExpr::NoInit\n            ? InitializationKind::CreateDefault(TypeRange.getBegin())\n            //     - Otherwise, the new-initializer is interpreted according to\n            //     the\n            //       initialization rules of 8.5 for direct-initialization.\n            : initStyle == CXXNewExpr::ListInit\n                  ? InitializationKind::CreateDirectList(\n                        TypeRange.getBegin(), Initializer->getBeginLoc(),\n                        Initializer->getEndLoc())\n                  : InitializationKind::CreateDirect(TypeRange.getBegin(),\n                                                     DirectInitRange.getBegin(),\n                                                     DirectInitRange.getEnd());\n\n  // C++11 [dcl.spec.auto]p6. Deduce the type which 'auto' stands in for.\n  auto *Deduced = AllocType->getContainedDeducedType();\n  if (Deduced && isa<DeducedTemplateSpecializationType>(Deduced)) {\n    if (ArraySize)\n      return ExprError(\n          Diag(ArraySize ? (*ArraySize)->getExprLoc() : TypeRange.getBegin(),\n               diag::err_deduced_class_template_compound_type)\n          << /*array*/ 2\n          << (ArraySize ? (*ArraySize)->getSourceRange() : TypeRange));\n\n    InitializedEntity Entity\n      = InitializedEntity::InitializeNew(StartLoc, AllocType);\n    AllocType = DeduceTemplateSpecializationFromInitializer(\n        AllocTypeInfo, Entity, Kind, MultiExprArg(Inits, NumInits));\n    if (AllocType.isNull())\n      return ExprError();\n  } else if (Deduced) {\n    bool Braced = (initStyle == CXXNewExpr::ListInit);\n    if (NumInits == 1) {\n      if (auto p = dyn_cast_or_null<InitListExpr>(Inits[0])) {\n        Inits = p->getInits();\n        NumInits = p->getNumInits();\n        Braced = true;\n      }\n    }\n\n    if (initStyle == CXXNewExpr::NoInit || NumInits == 0)\n      return ExprError(Diag(StartLoc, diag::err_auto_new_requires_ctor_arg)\n                       << AllocType << TypeRange);\n    if (NumInits > 1) {\n      Expr *FirstBad = Inits[1];\n      return ExprError(Diag(FirstBad->getBeginLoc(),\n                            diag::err_auto_new_ctor_multiple_expressions)\n                       << AllocType << TypeRange);\n    }\n    if (Braced && !getLangOpts().CPlusPlus17)\n      Diag(Initializer->getBeginLoc(), diag::ext_auto_new_list_init)\n          << AllocType << TypeRange;\n    Expr *Deduce = Inits[0];\n    QualType DeducedType;\n    if (DeduceAutoType(AllocTypeInfo, Deduce, DeducedType) == DAR_Failed)\n      return ExprError(Diag(StartLoc, diag::err_auto_new_deduction_failure)\n                       << AllocType << Deduce->getType()\n                       << TypeRange << Deduce->getSourceRange());\n    if (DeducedType.isNull())\n      return ExprError();\n    AllocType = DeducedType;\n  }\n\n  // Per C++0x [expr.new]p5, the type being constructed may be a\n  // typedef of an array type.\n  if (!ArraySize) {\n    if (const ConstantArrayType *Array\n                              = Context.getAsConstantArrayType(AllocType)) {\n      ArraySize = IntegerLiteral::Create(Context, Array->getSize(),\n                                         Context.getSizeType(),\n                                         TypeRange.getEnd());\n      AllocType = Array->getElementType();\n    }\n  }\n\n  if (CheckAllocatedType(AllocType, TypeRange.getBegin(), TypeRange))\n    return ExprError();\n\n  // In ARC, infer 'retaining' for the allocated\n  if (getLangOpts().ObjCAutoRefCount &&\n      AllocType.getObjCLifetime() == Qualifiers::OCL_None &&\n      AllocType->isObjCLifetimeType()) {\n    AllocType = Context.getLifetimeQualifiedType(AllocType,\n                                    AllocType->getObjCARCImplicitLifetime());\n  }\n\n  QualType ResultType = Context.getPointerType(AllocType);\n\n  if (ArraySize && *ArraySize &&\n      (*ArraySize)->getType()->isNonOverloadPlaceholderType()) {\n    ExprResult result = CheckPlaceholderExpr(*ArraySize);\n    if (result.isInvalid()) return ExprError();\n    ArraySize = result.get();\n  }\n  // C++98 5.3.4p6: \"The expression in a direct-new-declarator shall have\n  //   integral or enumeration type with a non-negative value.\"\n  // C++11 [expr.new]p6: The expression [...] shall be of integral or unscoped\n  //   enumeration type, or a class type for which a single non-explicit\n  //   conversion function to integral or unscoped enumeration type exists.\n  // C++1y [expr.new]p6: The expression [...] is implicitly converted to\n  //   std::size_t.\n  llvm::Optional<uint64_t> KnownArraySize;\n  if (ArraySize && *ArraySize && !(*ArraySize)->isTypeDependent()) {\n    ExprResult ConvertedSize;\n    if (getLangOpts().CPlusPlus14) {\n      assert(Context.getTargetInfo().getIntWidth() && \"Builtin type of size 0?\");\n\n      ConvertedSize = PerformImplicitConversion(*ArraySize, Context.getSizeType(),\n                                                AA_Converting);\n\n      if (!ConvertedSize.isInvalid() &&\n          (*ArraySize)->getType()->getAs<RecordType>())\n        // Diagnose the compatibility of this conversion.\n        Diag(StartLoc, diag::warn_cxx98_compat_array_size_conversion)\n          << (*ArraySize)->getType() << 0 << \"'size_t'\";\n    } else {\n      class SizeConvertDiagnoser : public ICEConvertDiagnoser {\n      protected:\n        Expr *ArraySize;\n\n      public:\n        SizeConvertDiagnoser(Expr *ArraySize)\n            : ICEConvertDiagnoser(/*AllowScopedEnumerations*/false, false, false),\n              ArraySize(ArraySize) {}\n\n        SemaDiagnosticBuilder diagnoseNotInt(Sema &S, SourceLocation Loc,\n                                             QualType T) override {\n          return S.Diag(Loc, diag::err_array_size_not_integral)\n                   << S.getLangOpts().CPlusPlus11 << T;\n        }\n\n        SemaDiagnosticBuilder diagnoseIncomplete(\n            Sema &S, SourceLocation Loc, QualType T) override {\n          return S.Diag(Loc, diag::err_array_size_incomplete_type)\n                   << T << ArraySize->getSourceRange();\n        }\n\n        SemaDiagnosticBuilder diagnoseExplicitConv(\n            Sema &S, SourceLocation Loc, QualType T, QualType ConvTy) override {\n          return S.Diag(Loc, diag::err_array_size_explicit_conversion) << T << ConvTy;\n        }\n\n        SemaDiagnosticBuilder noteExplicitConv(\n            Sema &S, CXXConversionDecl *Conv, QualType ConvTy) override {\n          return S.Diag(Conv->getLocation(), diag::note_array_size_conversion)\n                   << ConvTy->isEnumeralType() << ConvTy;\n        }\n\n        SemaDiagnosticBuilder diagnoseAmbiguous(\n            Sema &S, SourceLocation Loc, QualType T) override {\n          return S.Diag(Loc, diag::err_array_size_ambiguous_conversion) << T;\n        }\n\n        SemaDiagnosticBuilder noteAmbiguous(\n            Sema &S, CXXConversionDecl *Conv, QualType ConvTy) override {\n          return S.Diag(Conv->getLocation(), diag::note_array_size_conversion)\n                   << ConvTy->isEnumeralType() << ConvTy;\n        }\n\n        SemaDiagnosticBuilder diagnoseConversion(Sema &S, SourceLocation Loc,\n                                                 QualType T,\n                                                 QualType ConvTy) override {\n          return S.Diag(Loc,\n                        S.getLangOpts().CPlusPlus11\n                          ? diag::warn_cxx98_compat_array_size_conversion\n                          : diag::ext_array_size_conversion)\n                   << T << ConvTy->isEnumeralType() << ConvTy;\n        }\n      } SizeDiagnoser(*ArraySize);\n\n      ConvertedSize = PerformContextualImplicitConversion(StartLoc, *ArraySize,\n                                                          SizeDiagnoser);\n    }\n    if (ConvertedSize.isInvalid())\n      return ExprError();\n\n    ArraySize = ConvertedSize.get();\n    QualType SizeType = (*ArraySize)->getType();\n\n    if (!SizeType->isIntegralOrUnscopedEnumerationType())\n      return ExprError();\n\n    // C++98 [expr.new]p7:\n    //   The expression in a direct-new-declarator shall have integral type\n    //   with a non-negative value.\n    //\n    // Let's see if this is a constant < 0. If so, we reject it out of hand,\n    // per CWG1464. Otherwise, if it's not a constant, we must have an\n    // unparenthesized array type.\n    if (!(*ArraySize)->isValueDependent()) {\n      // We've already performed any required implicit conversion to integer or\n      // unscoped enumeration type.\n      // FIXME: Per CWG1464, we are required to check the value prior to\n      // converting to size_t. This will never find a negative array size in\n      // C++14 onwards, because Value is always unsigned here!\n      if (Optional<llvm::APSInt> Value =\n              (*ArraySize)->getIntegerConstantExpr(Context)) {\n        if (Value->isSigned() && Value->isNegative()) {\n          return ExprError(Diag((*ArraySize)->getBeginLoc(),\n                                diag::err_typecheck_negative_array_size)\n                           << (*ArraySize)->getSourceRange());\n        }\n\n        if (!AllocType->isDependentType()) {\n          unsigned ActiveSizeBits = ConstantArrayType::getNumAddressingBits(\n              Context, AllocType, *Value);\n          if (ActiveSizeBits > ConstantArrayType::getMaxSizeBits(Context))\n            return ExprError(\n                Diag((*ArraySize)->getBeginLoc(), diag::err_array_too_large)\n                << Value->toString(10) << (*ArraySize)->getSourceRange());\n        }\n\n        KnownArraySize = Value->getZExtValue();\n      } else if (TypeIdParens.isValid()) {\n        // Can't have dynamic array size when the type-id is in parentheses.\n        Diag((*ArraySize)->getBeginLoc(), diag::ext_new_paren_array_nonconst)\n            << (*ArraySize)->getSourceRange()\n            << FixItHint::CreateRemoval(TypeIdParens.getBegin())\n            << FixItHint::CreateRemoval(TypeIdParens.getEnd());\n\n        TypeIdParens = SourceRange();\n      }\n    }\n\n    // Note that we do *not* convert the argument in any way.  It can\n    // be signed, larger than size_t, whatever.\n  }\n\n  FunctionDecl *OperatorNew = nullptr;\n  FunctionDecl *OperatorDelete = nullptr;\n  unsigned Alignment =\n      AllocType->isDependentType() ? 0 : Context.getTypeAlign(AllocType);\n  unsigned NewAlignment = Context.getTargetInfo().getNewAlign();\n  bool PassAlignment = getLangOpts().AlignedAllocation &&\n                       Alignment > NewAlignment;\n\n  AllocationFunctionScope Scope = UseGlobal ? AFS_Global : AFS_Both;\n  if (!AllocType->isDependentType() &&\n      !Expr::hasAnyTypeDependentArguments(PlacementArgs) &&\n      FindAllocationFunctions(\n          StartLoc, SourceRange(PlacementLParen, PlacementRParen), Scope, Scope,\n          AllocType, ArraySize.hasValue(), PassAlignment, PlacementArgs,\n          OperatorNew, OperatorDelete))\n    return ExprError();\n\n  // If this is an array allocation, compute whether the usual array\n  // deallocation function for the type has a size_t parameter.\n  bool UsualArrayDeleteWantsSize = false;\n  if (ArraySize && !AllocType->isDependentType())\n    UsualArrayDeleteWantsSize =\n        doesUsualArrayDeleteWantSize(*this, StartLoc, AllocType);\n\n  SmallVector<Expr *, 8> AllPlaceArgs;\n  if (OperatorNew) {\n    auto *Proto = OperatorNew->getType()->castAs<FunctionProtoType>();\n    VariadicCallType CallType = Proto->isVariadic() ? VariadicFunction\n                                                    : VariadicDoesNotApply;\n\n    // We've already converted the placement args, just fill in any default\n    // arguments. Skip the first parameter because we don't have a corresponding\n    // argument. Skip the second parameter too if we're passing in the\n    // alignment; we've already filled it in.\n    unsigned NumImplicitArgs = PassAlignment ? 2 : 1;\n    if (GatherArgumentsForCall(PlacementLParen, OperatorNew, Proto,\n                               NumImplicitArgs, PlacementArgs, AllPlaceArgs,\n                               CallType))\n      return ExprError();\n\n    if (!AllPlaceArgs.empty())\n      PlacementArgs = AllPlaceArgs;\n\n    // We would like to perform some checking on the given `operator new` call,\n    // but the PlacementArgs does not contain the implicit arguments,\n    // namely allocation size and maybe allocation alignment,\n    // so we need to conjure them.\n\n    QualType SizeTy = Context.getSizeType();\n    unsigned SizeTyWidth = Context.getTypeSize(SizeTy);\n\n    llvm::APInt SingleEltSize(\n        SizeTyWidth, Context.getTypeSizeInChars(AllocType).getQuantity());\n\n    // How many bytes do we want to allocate here?\n    llvm::Optional<llvm::APInt> AllocationSize;\n    if (!ArraySize.hasValue() && !AllocType->isDependentType()) {\n      // For non-array operator new, we only want to allocate one element.\n      AllocationSize = SingleEltSize;\n    } else if (KnownArraySize.hasValue() && !AllocType->isDependentType()) {\n      // For array operator new, only deal with static array size case.\n      bool Overflow;\n      AllocationSize = llvm::APInt(SizeTyWidth, *KnownArraySize)\n                           .umul_ov(SingleEltSize, Overflow);\n      (void)Overflow;\n      assert(\n          !Overflow &&\n          \"Expected that all the overflows would have been handled already.\");\n    }\n\n    IntegerLiteral AllocationSizeLiteral(\n        Context,\n        AllocationSize.getValueOr(llvm::APInt::getNullValue(SizeTyWidth)),\n        SizeTy, SourceLocation());\n    // Otherwise, if we failed to constant-fold the allocation size, we'll\n    // just give up and pass-in something opaque, that isn't a null pointer.\n    OpaqueValueExpr OpaqueAllocationSize(SourceLocation(), SizeTy, VK_RValue,\n                                         OK_Ordinary, /*SourceExpr=*/nullptr);\n\n    // Let's synthesize the alignment argument in case we will need it.\n    // Since we *really* want to allocate these on stack, this is slightly ugly\n    // because there might not be a `std::align_val_t` type.\n    EnumDecl *StdAlignValT = getStdAlignValT();\n    QualType AlignValT =\n        StdAlignValT ? Context.getTypeDeclType(StdAlignValT) : SizeTy;\n    IntegerLiteral AlignmentLiteral(\n        Context,\n        llvm::APInt(Context.getTypeSize(SizeTy),\n                    Alignment / Context.getCharWidth()),\n        SizeTy, SourceLocation());\n    ImplicitCastExpr DesiredAlignment(ImplicitCastExpr::OnStack, AlignValT,\n                                      CK_IntegralCast, &AlignmentLiteral,\n                                      VK_RValue, FPOptionsOverride());\n\n    // Adjust placement args by prepending conjured size and alignment exprs.\n    llvm::SmallVector<Expr *, 8> CallArgs;\n    CallArgs.reserve(NumImplicitArgs + PlacementArgs.size());\n    CallArgs.emplace_back(AllocationSize.hasValue()\n                              ? static_cast<Expr *>(&AllocationSizeLiteral)\n                              : &OpaqueAllocationSize);\n    if (PassAlignment)\n      CallArgs.emplace_back(&DesiredAlignment);\n    CallArgs.insert(CallArgs.end(), PlacementArgs.begin(), PlacementArgs.end());\n\n    DiagnoseSentinelCalls(OperatorNew, PlacementLParen, CallArgs);\n\n    checkCall(OperatorNew, Proto, /*ThisArg=*/nullptr, CallArgs,\n              /*IsMemberFunction=*/false, StartLoc, Range, CallType);\n\n    // Warn if the type is over-aligned and is being allocated by (unaligned)\n    // global operator new.\n    if (PlacementArgs.empty() && !PassAlignment &&\n        (OperatorNew->isImplicit() ||\n         (OperatorNew->getBeginLoc().isValid() &&\n          getSourceManager().isInSystemHeader(OperatorNew->getBeginLoc())))) {\n      if (Alignment > NewAlignment)\n        Diag(StartLoc, diag::warn_overaligned_type)\n            << AllocType\n            << unsigned(Alignment / Context.getCharWidth())\n            << unsigned(NewAlignment / Context.getCharWidth());\n    }\n  }\n\n  // Array 'new' can't have any initializers except empty parentheses.\n  // Initializer lists are also allowed, in C++11. Rely on the parser for the\n  // dialect distinction.\n  if (ArraySize && !isLegalArrayNewInitializer(initStyle, Initializer)) {\n    SourceRange InitRange(Inits[0]->getBeginLoc(),\n                          Inits[NumInits - 1]->getEndLoc());\n    Diag(StartLoc, diag::err_new_array_init_args) << InitRange;\n    return ExprError();\n  }\n\n  // If we can perform the initialization, and we've not already done so,\n  // do it now.\n  if (!AllocType->isDependentType() &&\n      !Expr::hasAnyTypeDependentArguments(\n          llvm::makeArrayRef(Inits, NumInits))) {\n    // The type we initialize is the complete type, including the array bound.\n    QualType InitType;\n    if (KnownArraySize)\n      InitType = Context.getConstantArrayType(\n          AllocType,\n          llvm::APInt(Context.getTypeSize(Context.getSizeType()),\n                      *KnownArraySize),\n          *ArraySize, ArrayType::Normal, 0);\n    else if (ArraySize)\n      InitType =\n          Context.getIncompleteArrayType(AllocType, ArrayType::Normal, 0);\n    else\n      InitType = AllocType;\n\n    InitializedEntity Entity\n      = InitializedEntity::InitializeNew(StartLoc, InitType);\n    InitializationSequence InitSeq(*this, Entity, Kind,\n                                   MultiExprArg(Inits, NumInits));\n    ExprResult FullInit = InitSeq.Perform(*this, Entity, Kind,\n                                          MultiExprArg(Inits, NumInits));\n    if (FullInit.isInvalid())\n      return ExprError();\n\n    // FullInit is our initializer; strip off CXXBindTemporaryExprs, because\n    // we don't want the initialized object to be destructed.\n    // FIXME: We should not create these in the first place.\n    if (CXXBindTemporaryExpr *Binder =\n            dyn_cast_or_null<CXXBindTemporaryExpr>(FullInit.get()))\n      FullInit = Binder->getSubExpr();\n\n    Initializer = FullInit.get();\n\n    // FIXME: If we have a KnownArraySize, check that the array bound of the\n    // initializer is no greater than that constant value.\n\n    if (ArraySize && !*ArraySize) {\n      auto *CAT = Context.getAsConstantArrayType(Initializer->getType());\n      if (CAT) {\n        // FIXME: Track that the array size was inferred rather than explicitly\n        // specified.\n        ArraySize = IntegerLiteral::Create(\n            Context, CAT->getSize(), Context.getSizeType(), TypeRange.getEnd());\n      } else {\n        Diag(TypeRange.getEnd(), diag::err_new_array_size_unknown_from_init)\n            << Initializer->getSourceRange();\n      }\n    }\n  }\n\n  // Mark the new and delete operators as referenced.\n  if (OperatorNew) {\n    if (DiagnoseUseOfDecl(OperatorNew, StartLoc))\n      return ExprError();\n    MarkFunctionReferenced(StartLoc, OperatorNew);\n  }\n  if (OperatorDelete) {\n    if (DiagnoseUseOfDecl(OperatorDelete, StartLoc))\n      return ExprError();\n    MarkFunctionReferenced(StartLoc, OperatorDelete);\n  }\n\n  return CXXNewExpr::Create(Context, UseGlobal, OperatorNew, OperatorDelete,\n                            PassAlignment, UsualArrayDeleteWantsSize,\n                            PlacementArgs, TypeIdParens, ArraySize, initStyle,\n                            Initializer, ResultType, AllocTypeInfo, Range,\n                            DirectInitRange);\n}\n\n/// Checks that a type is suitable as the allocated type\n/// in a new-expression.\nbool Sema::CheckAllocatedType(QualType AllocType, SourceLocation Loc,\n                              SourceRange R) {\n  // C++ 5.3.4p1: \"[The] type shall be a complete object type, but not an\n  //   abstract class type or array thereof.\n  if (AllocType->isFunctionType())\n    return Diag(Loc, diag::err_bad_new_type)\n      << AllocType << 0 << R;\n  else if (AllocType->isReferenceType())\n    return Diag(Loc, diag::err_bad_new_type)\n      << AllocType << 1 << R;\n  else if (!AllocType->isDependentType() &&\n           RequireCompleteSizedType(\n               Loc, AllocType, diag::err_new_incomplete_or_sizeless_type, R))\n    return true;\n  else if (RequireNonAbstractType(Loc, AllocType,\n                                  diag::err_allocation_of_abstract_type))\n    return true;\n  else if (AllocType->isVariablyModifiedType())\n    return Diag(Loc, diag::err_variably_modified_new_type)\n             << AllocType;\n  else if (AllocType.getAddressSpace() != LangAS::Default &&\n           !getLangOpts().OpenCLCPlusPlus)\n    return Diag(Loc, diag::err_address_space_qualified_new)\n      << AllocType.getUnqualifiedType()\n      << AllocType.getQualifiers().getAddressSpaceAttributePrintValue();\n  else if (getLangOpts().ObjCAutoRefCount) {\n    if (const ArrayType *AT = Context.getAsArrayType(AllocType)) {\n      QualType BaseAllocType = Context.getBaseElementType(AT);\n      if (BaseAllocType.getObjCLifetime() == Qualifiers::OCL_None &&\n          BaseAllocType->isObjCLifetimeType())\n        return Diag(Loc, diag::err_arc_new_array_without_ownership)\n          << BaseAllocType;\n    }\n  }\n\n  return false;\n}\n\nstatic bool resolveAllocationOverload(\n    Sema &S, LookupResult &R, SourceRange Range, SmallVectorImpl<Expr *> &Args,\n    bool &PassAlignment, FunctionDecl *&Operator,\n    OverloadCandidateSet *AlignedCandidates, Expr *AlignArg, bool Diagnose) {\n  OverloadCandidateSet Candidates(R.getNameLoc(),\n                                  OverloadCandidateSet::CSK_Normal);\n  for (LookupResult::iterator Alloc = R.begin(), AllocEnd = R.end();\n       Alloc != AllocEnd; ++Alloc) {\n    // Even member operator new/delete are implicitly treated as\n    // static, so don't use AddMemberCandidate.\n    NamedDecl *D = (*Alloc)->getUnderlyingDecl();\n\n    if (FunctionTemplateDecl *FnTemplate = dyn_cast<FunctionTemplateDecl>(D)) {\n      S.AddTemplateOverloadCandidate(FnTemplate, Alloc.getPair(),\n                                     /*ExplicitTemplateArgs=*/nullptr, Args,\n                                     Candidates,\n                                     /*SuppressUserConversions=*/false);\n      continue;\n    }\n\n    FunctionDecl *Fn = cast<FunctionDecl>(D);\n    S.AddOverloadCandidate(Fn, Alloc.getPair(), Args, Candidates,\n                           /*SuppressUserConversions=*/false);\n  }\n\n  // Do the resolution.\n  OverloadCandidateSet::iterator Best;\n  switch (Candidates.BestViableFunction(S, R.getNameLoc(), Best)) {\n  case OR_Success: {\n    // Got one!\n    FunctionDecl *FnDecl = Best->Function;\n    if (S.CheckAllocationAccess(R.getNameLoc(), Range, R.getNamingClass(),\n                                Best->FoundDecl) == Sema::AR_inaccessible)\n      return true;\n\n    Operator = FnDecl;\n    return false;\n  }\n\n  case OR_No_Viable_Function:\n    // C++17 [expr.new]p13:\n    //   If no matching function is found and the allocated object type has\n    //   new-extended alignment, the alignment argument is removed from the\n    //   argument list, and overload resolution is performed again.\n    if (PassAlignment) {\n      PassAlignment = false;\n      AlignArg = Args[1];\n      Args.erase(Args.begin() + 1);\n      return resolveAllocationOverload(S, R, Range, Args, PassAlignment,\n                                       Operator, &Candidates, AlignArg,\n                                       Diagnose);\n    }\n\n    // MSVC will fall back on trying to find a matching global operator new\n    // if operator new[] cannot be found.  Also, MSVC will leak by not\n    // generating a call to operator delete or operator delete[], but we\n    // will not replicate that bug.\n    // FIXME: Find out how this interacts with the std::align_val_t fallback\n    // once MSVC implements it.\n    if (R.getLookupName().getCXXOverloadedOperator() == OO_Array_New &&\n        S.Context.getLangOpts().MSVCCompat) {\n      R.clear();\n      R.setLookupName(S.Context.DeclarationNames.getCXXOperatorName(OO_New));\n      S.LookupQualifiedName(R, S.Context.getTranslationUnitDecl());\n      // FIXME: This will give bad diagnostics pointing at the wrong functions.\n      return resolveAllocationOverload(S, R, Range, Args, PassAlignment,\n                                       Operator, /*Candidates=*/nullptr,\n                                       /*AlignArg=*/nullptr, Diagnose);\n    }\n\n    if (Diagnose) {\n      // If this is an allocation of the form 'new (p) X' for some object\n      // pointer p (or an expression that will decay to such a pointer),\n      // diagnose the missing inclusion of <new>.\n      if (!R.isClassLookup() && Args.size() == 2 &&\n          (Args[1]->getType()->isObjectPointerType() ||\n           Args[1]->getType()->isArrayType())) {\n        S.Diag(R.getNameLoc(), diag::err_need_header_before_placement_new)\n            << R.getLookupName() << Range;\n        // Listing the candidates is unlikely to be useful; skip it.\n        return true;\n      }\n\n      // Finish checking all candidates before we note any. This checking can\n      // produce additional diagnostics so can't be interleaved with our\n      // emission of notes.\n      //\n      // For an aligned allocation, separately check the aligned and unaligned\n      // candidates with their respective argument lists.\n      SmallVector<OverloadCandidate*, 32> Cands;\n      SmallVector<OverloadCandidate*, 32> AlignedCands;\n      llvm::SmallVector<Expr*, 4> AlignedArgs;\n      if (AlignedCandidates) {\n        auto IsAligned = [](OverloadCandidate &C) {\n          return C.Function->getNumParams() > 1 &&\n                 C.Function->getParamDecl(1)->getType()->isAlignValT();\n        };\n        auto IsUnaligned = [&](OverloadCandidate &C) { return !IsAligned(C); };\n\n        AlignedArgs.reserve(Args.size() + 1);\n        AlignedArgs.push_back(Args[0]);\n        AlignedArgs.push_back(AlignArg);\n        AlignedArgs.append(Args.begin() + 1, Args.end());\n        AlignedCands = AlignedCandidates->CompleteCandidates(\n            S, OCD_AllCandidates, AlignedArgs, R.getNameLoc(), IsAligned);\n\n        Cands = Candidates.CompleteCandidates(S, OCD_AllCandidates, Args,\n                                              R.getNameLoc(), IsUnaligned);\n      } else {\n        Cands = Candidates.CompleteCandidates(S, OCD_AllCandidates, Args,\n                                              R.getNameLoc());\n      }\n\n      S.Diag(R.getNameLoc(), diag::err_ovl_no_viable_function_in_call)\n          << R.getLookupName() << Range;\n      if (AlignedCandidates)\n        AlignedCandidates->NoteCandidates(S, AlignedArgs, AlignedCands, \"\",\n                                          R.getNameLoc());\n      Candidates.NoteCandidates(S, Args, Cands, \"\", R.getNameLoc());\n    }\n    return true;\n\n  case OR_Ambiguous:\n    if (Diagnose) {\n      Candidates.NoteCandidates(\n          PartialDiagnosticAt(R.getNameLoc(),\n                              S.PDiag(diag::err_ovl_ambiguous_call)\n                                  << R.getLookupName() << Range),\n          S, OCD_AmbiguousCandidates, Args);\n    }\n    return true;\n\n  case OR_Deleted: {\n    if (Diagnose) {\n      Candidates.NoteCandidates(\n          PartialDiagnosticAt(R.getNameLoc(),\n                              S.PDiag(diag::err_ovl_deleted_call)\n                                  << R.getLookupName() << Range),\n          S, OCD_AllCandidates, Args);\n    }\n    return true;\n  }\n  }\n  llvm_unreachable(\"Unreachable, bad result from BestViableFunction\");\n}\n\nbool Sema::FindAllocationFunctions(SourceLocation StartLoc, SourceRange Range,\n                                   AllocationFunctionScope NewScope,\n                                   AllocationFunctionScope DeleteScope,\n                                   QualType AllocType, bool IsArray,\n                                   bool &PassAlignment, MultiExprArg PlaceArgs,\n                                   FunctionDecl *&OperatorNew,\n                                   FunctionDecl *&OperatorDelete,\n                                   bool Diagnose) {\n  // --- Choosing an allocation function ---\n  // C++ 5.3.4p8 - 14 & 18\n  // 1) If looking in AFS_Global scope for allocation functions, only look in\n  //    the global scope. Else, if AFS_Class, only look in the scope of the\n  //    allocated class. If AFS_Both, look in both.\n  // 2) If an array size is given, look for operator new[], else look for\n  //   operator new.\n  // 3) The first argument is always size_t. Append the arguments from the\n  //   placement form.\n\n  SmallVector<Expr*, 8> AllocArgs;\n  AllocArgs.reserve((PassAlignment ? 2 : 1) + PlaceArgs.size());\n\n  // We don't care about the actual value of these arguments.\n  // FIXME: Should the Sema create the expression and embed it in the syntax\n  // tree? Or should the consumer just recalculate the value?\n  // FIXME: Using a dummy value will interact poorly with attribute enable_if.\n  IntegerLiteral Size(Context, llvm::APInt::getNullValue(\n                      Context.getTargetInfo().getPointerWidth(0)),\n                      Context.getSizeType(),\n                      SourceLocation());\n  AllocArgs.push_back(&Size);\n\n  QualType AlignValT = Context.VoidTy;\n  if (PassAlignment) {\n    DeclareGlobalNewDelete();\n    AlignValT = Context.getTypeDeclType(getStdAlignValT());\n  }\n  CXXScalarValueInitExpr Align(AlignValT, nullptr, SourceLocation());\n  if (PassAlignment)\n    AllocArgs.push_back(&Align);\n\n  AllocArgs.insert(AllocArgs.end(), PlaceArgs.begin(), PlaceArgs.end());\n\n  // C++ [expr.new]p8:\n  //   If the allocated type is a non-array type, the allocation\n  //   function's name is operator new and the deallocation function's\n  //   name is operator delete. If the allocated type is an array\n  //   type, the allocation function's name is operator new[] and the\n  //   deallocation function's name is operator delete[].\n  DeclarationName NewName = Context.DeclarationNames.getCXXOperatorName(\n      IsArray ? OO_Array_New : OO_New);\n\n  QualType AllocElemType = Context.getBaseElementType(AllocType);\n\n  // Find the allocation function.\n  {\n    LookupResult R(*this, NewName, StartLoc, LookupOrdinaryName);\n\n    // C++1z [expr.new]p9:\n    //   If the new-expression begins with a unary :: operator, the allocation\n    //   function's name is looked up in the global scope. Otherwise, if the\n    //   allocated type is a class type T or array thereof, the allocation\n    //   function's name is looked up in the scope of T.\n    if (AllocElemType->isRecordType() && NewScope != AFS_Global)\n      LookupQualifiedName(R, AllocElemType->getAsCXXRecordDecl());\n\n    // We can see ambiguity here if the allocation function is found in\n    // multiple base classes.\n    if (R.isAmbiguous())\n      return true;\n\n    //   If this lookup fails to find the name, or if the allocated type is not\n    //   a class type, the allocation function's name is looked up in the\n    //   global scope.\n    if (R.empty()) {\n      if (NewScope == AFS_Class)\n        return true;\n\n      LookupQualifiedName(R, Context.getTranslationUnitDecl());\n    }\n\n    if (getLangOpts().OpenCLCPlusPlus && R.empty()) {\n      if (PlaceArgs.empty()) {\n        Diag(StartLoc, diag::err_openclcxx_not_supported) << \"default new\";\n      } else {\n        Diag(StartLoc, diag::err_openclcxx_placement_new);\n      }\n      return true;\n    }\n\n    assert(!R.empty() && \"implicitly declared allocation functions not found\");\n    assert(!R.isAmbiguous() && \"global allocation functions are ambiguous\");\n\n    // We do our own custom access checks below.\n    R.suppressDiagnostics();\n\n    if (resolveAllocationOverload(*this, R, Range, AllocArgs, PassAlignment,\n                                  OperatorNew, /*Candidates=*/nullptr,\n                                  /*AlignArg=*/nullptr, Diagnose))\n      return true;\n  }\n\n  // We don't need an operator delete if we're running under -fno-exceptions.\n  if (!getLangOpts().Exceptions) {\n    OperatorDelete = nullptr;\n    return false;\n  }\n\n  // Note, the name of OperatorNew might have been changed from array to\n  // non-array by resolveAllocationOverload.\n  DeclarationName DeleteName = Context.DeclarationNames.getCXXOperatorName(\n      OperatorNew->getDeclName().getCXXOverloadedOperator() == OO_Array_New\n          ? OO_Array_Delete\n          : OO_Delete);\n\n  // C++ [expr.new]p19:\n  //\n  //   If the new-expression begins with a unary :: operator, the\n  //   deallocation function's name is looked up in the global\n  //   scope. Otherwise, if the allocated type is a class type T or an\n  //   array thereof, the deallocation function's name is looked up in\n  //   the scope of T. If this lookup fails to find the name, or if\n  //   the allocated type is not a class type or array thereof, the\n  //   deallocation function's name is looked up in the global scope.\n  LookupResult FoundDelete(*this, DeleteName, StartLoc, LookupOrdinaryName);\n  if (AllocElemType->isRecordType() && DeleteScope != AFS_Global) {\n    auto *RD =\n        cast<CXXRecordDecl>(AllocElemType->castAs<RecordType>()->getDecl());\n    LookupQualifiedName(FoundDelete, RD);\n  }\n  if (FoundDelete.isAmbiguous())\n    return true; // FIXME: clean up expressions?\n\n  // Filter out any destroying operator deletes. We can't possibly call such a\n  // function in this context, because we're handling the case where the object\n  // was not successfully constructed.\n  // FIXME: This is not covered by the language rules yet.\n  {\n    LookupResult::Filter Filter = FoundDelete.makeFilter();\n    while (Filter.hasNext()) {\n      auto *FD = dyn_cast<FunctionDecl>(Filter.next()->getUnderlyingDecl());\n      if (FD && FD->isDestroyingOperatorDelete())\n        Filter.erase();\n    }\n    Filter.done();\n  }\n\n  bool FoundGlobalDelete = FoundDelete.empty();\n  if (FoundDelete.empty()) {\n    FoundDelete.clear(LookupOrdinaryName);\n\n    if (DeleteScope == AFS_Class)\n      return true;\n\n    DeclareGlobalNewDelete();\n    LookupQualifiedName(FoundDelete, Context.getTranslationUnitDecl());\n  }\n\n  FoundDelete.suppressDiagnostics();\n\n  SmallVector<std::pair<DeclAccessPair,FunctionDecl*>, 2> Matches;\n\n  // Whether we're looking for a placement operator delete is dictated\n  // by whether we selected a placement operator new, not by whether\n  // we had explicit placement arguments.  This matters for things like\n  //   struct A { void *operator new(size_t, int = 0); ... };\n  //   A *a = new A()\n  //\n  // We don't have any definition for what a \"placement allocation function\"\n  // is, but we assume it's any allocation function whose\n  // parameter-declaration-clause is anything other than (size_t).\n  //\n  // FIXME: Should (size_t, std::align_val_t) also be considered non-placement?\n  // This affects whether an exception from the constructor of an overaligned\n  // type uses the sized or non-sized form of aligned operator delete.\n  bool isPlacementNew = !PlaceArgs.empty() || OperatorNew->param_size() != 1 ||\n                        OperatorNew->isVariadic();\n\n  if (isPlacementNew) {\n    // C++ [expr.new]p20:\n    //   A declaration of a placement deallocation function matches the\n    //   declaration of a placement allocation function if it has the\n    //   same number of parameters and, after parameter transformations\n    //   (8.3.5), all parameter types except the first are\n    //   identical. [...]\n    //\n    // To perform this comparison, we compute the function type that\n    // the deallocation function should have, and use that type both\n    // for template argument deduction and for comparison purposes.\n    QualType ExpectedFunctionType;\n    {\n      auto *Proto = OperatorNew->getType()->castAs<FunctionProtoType>();\n\n      SmallVector<QualType, 4> ArgTypes;\n      ArgTypes.push_back(Context.VoidPtrTy);\n      for (unsigned I = 1, N = Proto->getNumParams(); I < N; ++I)\n        ArgTypes.push_back(Proto->getParamType(I));\n\n      FunctionProtoType::ExtProtoInfo EPI;\n      // FIXME: This is not part of the standard's rule.\n      EPI.Variadic = Proto->isVariadic();\n\n      ExpectedFunctionType\n        = Context.getFunctionType(Context.VoidTy, ArgTypes, EPI);\n    }\n\n    for (LookupResult::iterator D = FoundDelete.begin(),\n                             DEnd = FoundDelete.end();\n         D != DEnd; ++D) {\n      FunctionDecl *Fn = nullptr;\n      if (FunctionTemplateDecl *FnTmpl =\n              dyn_cast<FunctionTemplateDecl>((*D)->getUnderlyingDecl())) {\n        // Perform template argument deduction to try to match the\n        // expected function type.\n        TemplateDeductionInfo Info(StartLoc);\n        if (DeduceTemplateArguments(FnTmpl, nullptr, ExpectedFunctionType, Fn,\n                                    Info))\n          continue;\n      } else\n        Fn = cast<FunctionDecl>((*D)->getUnderlyingDecl());\n\n      if (Context.hasSameType(adjustCCAndNoReturn(Fn->getType(),\n                                                  ExpectedFunctionType,\n                                                  /*AdjustExcpetionSpec*/true),\n                              ExpectedFunctionType))\n        Matches.push_back(std::make_pair(D.getPair(), Fn));\n    }\n\n    if (getLangOpts().CUDA)\n      EraseUnwantedCUDAMatches(dyn_cast<FunctionDecl>(CurContext), Matches);\n  } else {\n    // C++1y [expr.new]p22:\n    //   For a non-placement allocation function, the normal deallocation\n    //   function lookup is used\n    //\n    // Per [expr.delete]p10, this lookup prefers a member operator delete\n    // without a size_t argument, but prefers a non-member operator delete\n    // with a size_t where possible (which it always is in this case).\n    llvm::SmallVector<UsualDeallocFnInfo, 4> BestDeallocFns;\n    UsualDeallocFnInfo Selected = resolveDeallocationOverload(\n        *this, FoundDelete, /*WantSize*/ FoundGlobalDelete,\n        /*WantAlign*/ hasNewExtendedAlignment(*this, AllocElemType),\n        &BestDeallocFns);\n    if (Selected)\n      Matches.push_back(std::make_pair(Selected.Found, Selected.FD));\n    else {\n      // If we failed to select an operator, all remaining functions are viable\n      // but ambiguous.\n      for (auto Fn : BestDeallocFns)\n        Matches.push_back(std::make_pair(Fn.Found, Fn.FD));\n    }\n  }\n\n  // C++ [expr.new]p20:\n  //   [...] If the lookup finds a single matching deallocation\n  //   function, that function will be called; otherwise, no\n  //   deallocation function will be called.\n  if (Matches.size() == 1) {\n    OperatorDelete = Matches[0].second;\n\n    // C++1z [expr.new]p23:\n    //   If the lookup finds a usual deallocation function (3.7.4.2)\n    //   with a parameter of type std::size_t and that function, considered\n    //   as a placement deallocation function, would have been\n    //   selected as a match for the allocation function, the program\n    //   is ill-formed.\n    if (getLangOpts().CPlusPlus11 && isPlacementNew &&\n        isNonPlacementDeallocationFunction(*this, OperatorDelete)) {\n      UsualDeallocFnInfo Info(*this,\n                              DeclAccessPair::make(OperatorDelete, AS_public));\n      // Core issue, per mail to core reflector, 2016-10-09:\n      //   If this is a member operator delete, and there is a corresponding\n      //   non-sized member operator delete, this isn't /really/ a sized\n      //   deallocation function, it just happens to have a size_t parameter.\n      bool IsSizedDelete = Info.HasSizeT;\n      if (IsSizedDelete && !FoundGlobalDelete) {\n        auto NonSizedDelete =\n            resolveDeallocationOverload(*this, FoundDelete, /*WantSize*/false,\n                                        /*WantAlign*/Info.HasAlignValT);\n        if (NonSizedDelete && !NonSizedDelete.HasSizeT &&\n            NonSizedDelete.HasAlignValT == Info.HasAlignValT)\n          IsSizedDelete = false;\n      }\n\n      if (IsSizedDelete) {\n        SourceRange R = PlaceArgs.empty()\n                            ? SourceRange()\n                            : SourceRange(PlaceArgs.front()->getBeginLoc(),\n                                          PlaceArgs.back()->getEndLoc());\n        Diag(StartLoc, diag::err_placement_new_non_placement_delete) << R;\n        if (!OperatorDelete->isImplicit())\n          Diag(OperatorDelete->getLocation(), diag::note_previous_decl)\n              << DeleteName;\n      }\n    }\n\n    CheckAllocationAccess(StartLoc, Range, FoundDelete.getNamingClass(),\n                          Matches[0].first);\n  } else if (!Matches.empty()) {\n    // We found multiple suitable operators. Per [expr.new]p20, that means we\n    // call no 'operator delete' function, but we should at least warn the user.\n    // FIXME: Suppress this warning if the construction cannot throw.\n    Diag(StartLoc, diag::warn_ambiguous_suitable_delete_function_found)\n      << DeleteName << AllocElemType;\n\n    for (auto &Match : Matches)\n      Diag(Match.second->getLocation(),\n           diag::note_member_declared_here) << DeleteName;\n  }\n\n  return false;\n}\n\n/// DeclareGlobalNewDelete - Declare the global forms of operator new and\n/// delete. These are:\n/// @code\n///   // C++03:\n///   void* operator new(std::size_t) throw(std::bad_alloc);\n///   void* operator new[](std::size_t) throw(std::bad_alloc);\n///   void operator delete(void *) throw();\n///   void operator delete[](void *) throw();\n///   // C++11:\n///   void* operator new(std::size_t);\n///   void* operator new[](std::size_t);\n///   void operator delete(void *) noexcept;\n///   void operator delete[](void *) noexcept;\n///   // C++1y:\n///   void* operator new(std::size_t);\n///   void* operator new[](std::size_t);\n///   void operator delete(void *) noexcept;\n///   void operator delete[](void *) noexcept;\n///   void operator delete(void *, std::size_t) noexcept;\n///   void operator delete[](void *, std::size_t) noexcept;\n/// @endcode\n/// Note that the placement and nothrow forms of new are *not* implicitly\n/// declared. Their use requires including \\<new\\>.\nvoid Sema::DeclareGlobalNewDelete() {\n  if (GlobalNewDeleteDeclared)\n    return;\n\n  // The implicitly declared new and delete operators\n  // are not supported in OpenCL.\n  if (getLangOpts().OpenCLCPlusPlus)\n    return;\n\n  // C++ [basic.std.dynamic]p2:\n  //   [...] The following allocation and deallocation functions (18.4) are\n  //   implicitly declared in global scope in each translation unit of a\n  //   program\n  //\n  //     C++03:\n  //     void* operator new(std::size_t) throw(std::bad_alloc);\n  //     void* operator new[](std::size_t) throw(std::bad_alloc);\n  //     void  operator delete(void*) throw();\n  //     void  operator delete[](void*) throw();\n  //     C++11:\n  //     void* operator new(std::size_t);\n  //     void* operator new[](std::size_t);\n  //     void  operator delete(void*) noexcept;\n  //     void  operator delete[](void*) noexcept;\n  //     C++1y:\n  //     void* operator new(std::size_t);\n  //     void* operator new[](std::size_t);\n  //     void  operator delete(void*) noexcept;\n  //     void  operator delete[](void*) noexcept;\n  //     void  operator delete(void*, std::size_t) noexcept;\n  //     void  operator delete[](void*, std::size_t) noexcept;\n  //\n  //   These implicit declarations introduce only the function names operator\n  //   new, operator new[], operator delete, operator delete[].\n  //\n  // Here, we need to refer to std::bad_alloc, so we will implicitly declare\n  // \"std\" or \"bad_alloc\" as necessary to form the exception specification.\n  // However, we do not make these implicit declarations visible to name\n  // lookup.\n  if (!StdBadAlloc && !getLangOpts().CPlusPlus11) {\n    // The \"std::bad_alloc\" class has not yet been declared, so build it\n    // implicitly.\n    StdBadAlloc = CXXRecordDecl::Create(Context, TTK_Class,\n                                        getOrCreateStdNamespace(),\n                                        SourceLocation(), SourceLocation(),\n                                      &PP.getIdentifierTable().get(\"bad_alloc\"),\n                                        nullptr);\n    getStdBadAlloc()->setImplicit(true);\n  }\n  if (!StdAlignValT && getLangOpts().AlignedAllocation) {\n    // The \"std::align_val_t\" enum class has not yet been declared, so build it\n    // implicitly.\n    auto *AlignValT = EnumDecl::Create(\n        Context, getOrCreateStdNamespace(), SourceLocation(), SourceLocation(),\n        &PP.getIdentifierTable().get(\"align_val_t\"), nullptr, true, true, true);\n    AlignValT->setIntegerType(Context.getSizeType());\n    AlignValT->setPromotionType(Context.getSizeType());\n    AlignValT->setImplicit(true);\n    StdAlignValT = AlignValT;\n  }\n\n  GlobalNewDeleteDeclared = true;\n\n  QualType VoidPtr = Context.getPointerType(Context.VoidTy);\n  QualType SizeT = Context.getSizeType();\n\n  auto DeclareGlobalAllocationFunctions = [&](OverloadedOperatorKind Kind,\n                                              QualType Return, QualType Param) {\n    llvm::SmallVector<QualType, 3> Params;\n    Params.push_back(Param);\n\n    // Create up to four variants of the function (sized/aligned).\n    bool HasSizedVariant = getLangOpts().SizedDeallocation &&\n                           (Kind == OO_Delete || Kind == OO_Array_Delete);\n    bool HasAlignedVariant = getLangOpts().AlignedAllocation;\n\n    int NumSizeVariants = (HasSizedVariant ? 2 : 1);\n    int NumAlignVariants = (HasAlignedVariant ? 2 : 1);\n    for (int Sized = 0; Sized < NumSizeVariants; ++Sized) {\n      if (Sized)\n        Params.push_back(SizeT);\n\n      for (int Aligned = 0; Aligned < NumAlignVariants; ++Aligned) {\n        if (Aligned)\n          Params.push_back(Context.getTypeDeclType(getStdAlignValT()));\n\n        DeclareGlobalAllocationFunction(\n            Context.DeclarationNames.getCXXOperatorName(Kind), Return, Params);\n\n        if (Aligned)\n          Params.pop_back();\n      }\n    }\n  };\n\n  DeclareGlobalAllocationFunctions(OO_New, VoidPtr, SizeT);\n  DeclareGlobalAllocationFunctions(OO_Array_New, VoidPtr, SizeT);\n  DeclareGlobalAllocationFunctions(OO_Delete, Context.VoidTy, VoidPtr);\n  DeclareGlobalAllocationFunctions(OO_Array_Delete, Context.VoidTy, VoidPtr);\n}\n\n/// DeclareGlobalAllocationFunction - Declares a single implicit global\n/// allocation function if it doesn't already exist.\nvoid Sema::DeclareGlobalAllocationFunction(DeclarationName Name,\n                                           QualType Return,\n                                           ArrayRef<QualType> Params) {\n  DeclContext *GlobalCtx = Context.getTranslationUnitDecl();\n\n  // Check if this function is already declared.\n  DeclContext::lookup_result R = GlobalCtx->lookup(Name);\n  for (DeclContext::lookup_iterator Alloc = R.begin(), AllocEnd = R.end();\n       Alloc != AllocEnd; ++Alloc) {\n    // Only look at non-template functions, as it is the predefined,\n    // non-templated allocation function we are trying to declare here.\n    if (FunctionDecl *Func = dyn_cast<FunctionDecl>(*Alloc)) {\n      if (Func->getNumParams() == Params.size()) {\n        llvm::SmallVector<QualType, 3> FuncParams;\n        for (auto *P : Func->parameters())\n          FuncParams.push_back(\n              Context.getCanonicalType(P->getType().getUnqualifiedType()));\n        if (llvm::makeArrayRef(FuncParams) == Params) {\n          // Make the function visible to name lookup, even if we found it in\n          // an unimported module. It either is an implicitly-declared global\n          // allocation function, or is suppressing that function.\n          Func->setVisibleDespiteOwningModule();\n          return;\n        }\n      }\n    }\n  }\n\n  FunctionProtoType::ExtProtoInfo EPI(Context.getDefaultCallingConvention(\n      /*IsVariadic=*/false, /*IsCXXMethod=*/false, /*IsBuiltin=*/true));\n\n  QualType BadAllocType;\n  bool HasBadAllocExceptionSpec\n    = (Name.getCXXOverloadedOperator() == OO_New ||\n       Name.getCXXOverloadedOperator() == OO_Array_New);\n  if (HasBadAllocExceptionSpec) {\n    if (!getLangOpts().CPlusPlus11) {\n      BadAllocType = Context.getTypeDeclType(getStdBadAlloc());\n      assert(StdBadAlloc && \"Must have std::bad_alloc declared\");\n      EPI.ExceptionSpec.Type = EST_Dynamic;\n      EPI.ExceptionSpec.Exceptions = llvm::makeArrayRef(BadAllocType);\n    }\n  } else {\n    EPI.ExceptionSpec =\n        getLangOpts().CPlusPlus11 ? EST_BasicNoexcept : EST_DynamicNone;\n  }\n\n  auto CreateAllocationFunctionDecl = [&](Attr *ExtraAttr) {\n    QualType FnType = Context.getFunctionType(Return, Params, EPI);\n    FunctionDecl *Alloc = FunctionDecl::Create(\n        Context, GlobalCtx, SourceLocation(), SourceLocation(), Name,\n        FnType, /*TInfo=*/nullptr, SC_None, false, true);\n    Alloc->setImplicit();\n    // Global allocation functions should always be visible.\n    Alloc->setVisibleDespiteOwningModule();\n\n    Alloc->addAttr(VisibilityAttr::CreateImplicit(\n        Context, LangOpts.GlobalAllocationFunctionVisibilityHidden\n                     ? VisibilityAttr::Hidden\n                     : VisibilityAttr::Default));\n\n    llvm::SmallVector<ParmVarDecl *, 3> ParamDecls;\n    for (QualType T : Params) {\n      ParamDecls.push_back(ParmVarDecl::Create(\n          Context, Alloc, SourceLocation(), SourceLocation(), nullptr, T,\n          /*TInfo=*/nullptr, SC_None, nullptr));\n      ParamDecls.back()->setImplicit();\n    }\n    Alloc->setParams(ParamDecls);\n    if (ExtraAttr)\n      Alloc->addAttr(ExtraAttr);\n    AddKnownFunctionAttributesForReplaceableGlobalAllocationFunction(Alloc);\n    Context.getTranslationUnitDecl()->addDecl(Alloc);\n    IdResolver.tryAddTopLevelDecl(Alloc, Name);\n  };\n\n  if (!LangOpts.CUDA)\n    CreateAllocationFunctionDecl(nullptr);\n  else {\n    // Host and device get their own declaration so each can be\n    // defined or re-declared independently.\n    CreateAllocationFunctionDecl(CUDAHostAttr::CreateImplicit(Context));\n    CreateAllocationFunctionDecl(CUDADeviceAttr::CreateImplicit(Context));\n  }\n}\n\nFunctionDecl *Sema::FindUsualDeallocationFunction(SourceLocation StartLoc,\n                                                  bool CanProvideSize,\n                                                  bool Overaligned,\n                                                  DeclarationName Name) {\n  DeclareGlobalNewDelete();\n\n  LookupResult FoundDelete(*this, Name, StartLoc, LookupOrdinaryName);\n  LookupQualifiedName(FoundDelete, Context.getTranslationUnitDecl());\n\n  // FIXME: It's possible for this to result in ambiguity, through a\n  // user-declared variadic operator delete or the enable_if attribute. We\n  // should probably not consider those cases to be usual deallocation\n  // functions. But for now we just make an arbitrary choice in that case.\n  auto Result = resolveDeallocationOverload(*this, FoundDelete, CanProvideSize,\n                                            Overaligned);\n  assert(Result.FD && \"operator delete missing from global scope?\");\n  return Result.FD;\n}\n\nFunctionDecl *Sema::FindDeallocationFunctionForDestructor(SourceLocation Loc,\n                                                          CXXRecordDecl *RD) {\n  DeclarationName Name = Context.DeclarationNames.getCXXOperatorName(OO_Delete);\n\n  FunctionDecl *OperatorDelete = nullptr;\n  if (FindDeallocationFunction(Loc, RD, Name, OperatorDelete))\n    return nullptr;\n  if (OperatorDelete)\n    return OperatorDelete;\n\n  // If there's no class-specific operator delete, look up the global\n  // non-array delete.\n  return FindUsualDeallocationFunction(\n      Loc, true, hasNewExtendedAlignment(*this, Context.getRecordType(RD)),\n      Name);\n}\n\nbool Sema::FindDeallocationFunction(SourceLocation StartLoc, CXXRecordDecl *RD,\n                                    DeclarationName Name,\n                                    FunctionDecl *&Operator, bool Diagnose) {\n  LookupResult Found(*this, Name, StartLoc, LookupOrdinaryName);\n  // Try to find operator delete/operator delete[] in class scope.\n  LookupQualifiedName(Found, RD);\n\n  if (Found.isAmbiguous())\n    return true;\n\n  Found.suppressDiagnostics();\n\n  bool Overaligned = hasNewExtendedAlignment(*this, Context.getRecordType(RD));\n\n  // C++17 [expr.delete]p10:\n  //   If the deallocation functions have class scope, the one without a\n  //   parameter of type std::size_t is selected.\n  llvm::SmallVector<UsualDeallocFnInfo, 4> Matches;\n  resolveDeallocationOverload(*this, Found, /*WantSize*/ false,\n                              /*WantAlign*/ Overaligned, &Matches);\n\n  // If we could find an overload, use it.\n  if (Matches.size() == 1) {\n    Operator = cast<CXXMethodDecl>(Matches[0].FD);\n\n    // FIXME: DiagnoseUseOfDecl?\n    if (Operator->isDeleted()) {\n      if (Diagnose) {\n        Diag(StartLoc, diag::err_deleted_function_use);\n        NoteDeletedFunction(Operator);\n      }\n      return true;\n    }\n\n    if (CheckAllocationAccess(StartLoc, SourceRange(), Found.getNamingClass(),\n                              Matches[0].Found, Diagnose) == AR_inaccessible)\n      return true;\n\n    return false;\n  }\n\n  // We found multiple suitable operators; complain about the ambiguity.\n  // FIXME: The standard doesn't say to do this; it appears that the intent\n  // is that this should never happen.\n  if (!Matches.empty()) {\n    if (Diagnose) {\n      Diag(StartLoc, diag::err_ambiguous_suitable_delete_member_function_found)\n        << Name << RD;\n      for (auto &Match : Matches)\n        Diag(Match.FD->getLocation(), diag::note_member_declared_here) << Name;\n    }\n    return true;\n  }\n\n  // We did find operator delete/operator delete[] declarations, but\n  // none of them were suitable.\n  if (!Found.empty()) {\n    if (Diagnose) {\n      Diag(StartLoc, diag::err_no_suitable_delete_member_function_found)\n        << Name << RD;\n\n      for (NamedDecl *D : Found)\n        Diag(D->getUnderlyingDecl()->getLocation(),\n             diag::note_member_declared_here) << Name;\n    }\n    return true;\n  }\n\n  Operator = nullptr;\n  return false;\n}\n\nnamespace {\n/// Checks whether delete-expression, and new-expression used for\n///  initializing deletee have the same array form.\nclass MismatchingNewDeleteDetector {\npublic:\n  enum MismatchResult {\n    /// Indicates that there is no mismatch or a mismatch cannot be proven.\n    NoMismatch,\n    /// Indicates that variable is initialized with mismatching form of \\a new.\n    VarInitMismatches,\n    /// Indicates that member is initialized with mismatching form of \\a new.\n    MemberInitMismatches,\n    /// Indicates that 1 or more constructors' definitions could not been\n    /// analyzed, and they will be checked again at the end of translation unit.\n    AnalyzeLater\n  };\n\n  /// \\param EndOfTU True, if this is the final analysis at the end of\n  /// translation unit. False, if this is the initial analysis at the point\n  /// delete-expression was encountered.\n  explicit MismatchingNewDeleteDetector(bool EndOfTU)\n      : Field(nullptr), IsArrayForm(false), EndOfTU(EndOfTU),\n        HasUndefinedConstructors(false) {}\n\n  /// Checks whether pointee of a delete-expression is initialized with\n  /// matching form of new-expression.\n  ///\n  /// If return value is \\c VarInitMismatches or \\c MemberInitMismatches at the\n  /// point where delete-expression is encountered, then a warning will be\n  /// issued immediately. If return value is \\c AnalyzeLater at the point where\n  /// delete-expression is seen, then member will be analyzed at the end of\n  /// translation unit. \\c AnalyzeLater is returned iff at least one constructor\n  /// couldn't be analyzed. If at least one constructor initializes the member\n  /// with matching type of new, the return value is \\c NoMismatch.\n  MismatchResult analyzeDeleteExpr(const CXXDeleteExpr *DE);\n  /// Analyzes a class member.\n  /// \\param Field Class member to analyze.\n  /// \\param DeleteWasArrayForm Array form-ness of the delete-expression used\n  /// for deleting the \\p Field.\n  MismatchResult analyzeField(FieldDecl *Field, bool DeleteWasArrayForm);\n  FieldDecl *Field;\n  /// List of mismatching new-expressions used for initialization of the pointee\n  llvm::SmallVector<const CXXNewExpr *, 4> NewExprs;\n  /// Indicates whether delete-expression was in array form.\n  bool IsArrayForm;\n\nprivate:\n  const bool EndOfTU;\n  /// Indicates that there is at least one constructor without body.\n  bool HasUndefinedConstructors;\n  /// Returns \\c CXXNewExpr from given initialization expression.\n  /// \\param E Expression used for initializing pointee in delete-expression.\n  /// E can be a single-element \\c InitListExpr consisting of new-expression.\n  const CXXNewExpr *getNewExprFromInitListOrExpr(const Expr *E);\n  /// Returns whether member is initialized with mismatching form of\n  /// \\c new either by the member initializer or in-class initialization.\n  ///\n  /// If bodies of all constructors are not visible at the end of translation\n  /// unit or at least one constructor initializes member with the matching\n  /// form of \\c new, mismatch cannot be proven, and this function will return\n  /// \\c NoMismatch.\n  MismatchResult analyzeMemberExpr(const MemberExpr *ME);\n  /// Returns whether variable is initialized with mismatching form of\n  /// \\c new.\n  ///\n  /// If variable is initialized with matching form of \\c new or variable is not\n  /// initialized with a \\c new expression, this function will return true.\n  /// If variable is initialized with mismatching form of \\c new, returns false.\n  /// \\param D Variable to analyze.\n  bool hasMatchingVarInit(const DeclRefExpr *D);\n  /// Checks whether the constructor initializes pointee with mismatching\n  /// form of \\c new.\n  ///\n  /// Returns true, if member is initialized with matching form of \\c new in\n  /// member initializer list. Returns false, if member is initialized with the\n  /// matching form of \\c new in this constructor's initializer or given\n  /// constructor isn't defined at the point where delete-expression is seen, or\n  /// member isn't initialized by the constructor.\n  bool hasMatchingNewInCtor(const CXXConstructorDecl *CD);\n  /// Checks whether member is initialized with matching form of\n  /// \\c new in member initializer list.\n  bool hasMatchingNewInCtorInit(const CXXCtorInitializer *CI);\n  /// Checks whether member is initialized with mismatching form of \\c new by\n  /// in-class initializer.\n  MismatchResult analyzeInClassInitializer();\n};\n}\n\nMismatchingNewDeleteDetector::MismatchResult\nMismatchingNewDeleteDetector::analyzeDeleteExpr(const CXXDeleteExpr *DE) {\n  NewExprs.clear();\n  assert(DE && \"Expected delete-expression\");\n  IsArrayForm = DE->isArrayForm();\n  const Expr *E = DE->getArgument()->IgnoreParenImpCasts();\n  if (const MemberExpr *ME = dyn_cast<const MemberExpr>(E)) {\n    return analyzeMemberExpr(ME);\n  } else if (const DeclRefExpr *D = dyn_cast<const DeclRefExpr>(E)) {\n    if (!hasMatchingVarInit(D))\n      return VarInitMismatches;\n  }\n  return NoMismatch;\n}\n\nconst CXXNewExpr *\nMismatchingNewDeleteDetector::getNewExprFromInitListOrExpr(const Expr *E) {\n  assert(E != nullptr && \"Expected a valid initializer expression\");\n  E = E->IgnoreParenImpCasts();\n  if (const InitListExpr *ILE = dyn_cast<const InitListExpr>(E)) {\n    if (ILE->getNumInits() == 1)\n      E = dyn_cast<const CXXNewExpr>(ILE->getInit(0)->IgnoreParenImpCasts());\n  }\n\n  return dyn_cast_or_null<const CXXNewExpr>(E);\n}\n\nbool MismatchingNewDeleteDetector::hasMatchingNewInCtorInit(\n    const CXXCtorInitializer *CI) {\n  const CXXNewExpr *NE = nullptr;\n  if (Field == CI->getMember() &&\n      (NE = getNewExprFromInitListOrExpr(CI->getInit()))) {\n    if (NE->isArray() == IsArrayForm)\n      return true;\n    else\n      NewExprs.push_back(NE);\n  }\n  return false;\n}\n\nbool MismatchingNewDeleteDetector::hasMatchingNewInCtor(\n    const CXXConstructorDecl *CD) {\n  if (CD->isImplicit())\n    return false;\n  const FunctionDecl *Definition = CD;\n  if (!CD->isThisDeclarationADefinition() && !CD->isDefined(Definition)) {\n    HasUndefinedConstructors = true;\n    return EndOfTU;\n  }\n  for (const auto *CI : cast<const CXXConstructorDecl>(Definition)->inits()) {\n    if (hasMatchingNewInCtorInit(CI))\n      return true;\n  }\n  return false;\n}\n\nMismatchingNewDeleteDetector::MismatchResult\nMismatchingNewDeleteDetector::analyzeInClassInitializer() {\n  assert(Field != nullptr && \"This should be called only for members\");\n  const Expr *InitExpr = Field->getInClassInitializer();\n  if (!InitExpr)\n    return EndOfTU ? NoMismatch : AnalyzeLater;\n  if (const CXXNewExpr *NE = getNewExprFromInitListOrExpr(InitExpr)) {\n    if (NE->isArray() != IsArrayForm) {\n      NewExprs.push_back(NE);\n      return MemberInitMismatches;\n    }\n  }\n  return NoMismatch;\n}\n\nMismatchingNewDeleteDetector::MismatchResult\nMismatchingNewDeleteDetector::analyzeField(FieldDecl *Field,\n                                           bool DeleteWasArrayForm) {\n  assert(Field != nullptr && \"Analysis requires a valid class member.\");\n  this->Field = Field;\n  IsArrayForm = DeleteWasArrayForm;\n  const CXXRecordDecl *RD = cast<const CXXRecordDecl>(Field->getParent());\n  for (const auto *CD : RD->ctors()) {\n    if (hasMatchingNewInCtor(CD))\n      return NoMismatch;\n  }\n  if (HasUndefinedConstructors)\n    return EndOfTU ? NoMismatch : AnalyzeLater;\n  if (!NewExprs.empty())\n    return MemberInitMismatches;\n  return Field->hasInClassInitializer() ? analyzeInClassInitializer()\n                                        : NoMismatch;\n}\n\nMismatchingNewDeleteDetector::MismatchResult\nMismatchingNewDeleteDetector::analyzeMemberExpr(const MemberExpr *ME) {\n  assert(ME != nullptr && \"Expected a member expression\");\n  if (FieldDecl *F = dyn_cast<FieldDecl>(ME->getMemberDecl()))\n    return analyzeField(F, IsArrayForm);\n  return NoMismatch;\n}\n\nbool MismatchingNewDeleteDetector::hasMatchingVarInit(const DeclRefExpr *D) {\n  const CXXNewExpr *NE = nullptr;\n  if (const VarDecl *VD = dyn_cast<const VarDecl>(D->getDecl())) {\n    if (VD->hasInit() && (NE = getNewExprFromInitListOrExpr(VD->getInit())) &&\n        NE->isArray() != IsArrayForm) {\n      NewExprs.push_back(NE);\n    }\n  }\n  return NewExprs.empty();\n}\n\nstatic void\nDiagnoseMismatchedNewDelete(Sema &SemaRef, SourceLocation DeleteLoc,\n                            const MismatchingNewDeleteDetector &Detector) {\n  SourceLocation EndOfDelete = SemaRef.getLocForEndOfToken(DeleteLoc);\n  FixItHint H;\n  if (!Detector.IsArrayForm)\n    H = FixItHint::CreateInsertion(EndOfDelete, \"[]\");\n  else {\n    SourceLocation RSquare = Lexer::findLocationAfterToken(\n        DeleteLoc, tok::l_square, SemaRef.getSourceManager(),\n        SemaRef.getLangOpts(), true);\n    if (RSquare.isValid())\n      H = FixItHint::CreateRemoval(SourceRange(EndOfDelete, RSquare));\n  }\n  SemaRef.Diag(DeleteLoc, diag::warn_mismatched_delete_new)\n      << Detector.IsArrayForm << H;\n\n  for (const auto *NE : Detector.NewExprs)\n    SemaRef.Diag(NE->getExprLoc(), diag::note_allocated_here)\n        << Detector.IsArrayForm;\n}\n\nvoid Sema::AnalyzeDeleteExprMismatch(const CXXDeleteExpr *DE) {\n  if (Diags.isIgnored(diag::warn_mismatched_delete_new, SourceLocation()))\n    return;\n  MismatchingNewDeleteDetector Detector(/*EndOfTU=*/false);\n  switch (Detector.analyzeDeleteExpr(DE)) {\n  case MismatchingNewDeleteDetector::VarInitMismatches:\n  case MismatchingNewDeleteDetector::MemberInitMismatches: {\n    DiagnoseMismatchedNewDelete(*this, DE->getBeginLoc(), Detector);\n    break;\n  }\n  case MismatchingNewDeleteDetector::AnalyzeLater: {\n    DeleteExprs[Detector.Field].push_back(\n        std::make_pair(DE->getBeginLoc(), DE->isArrayForm()));\n    break;\n  }\n  case MismatchingNewDeleteDetector::NoMismatch:\n    break;\n  }\n}\n\nvoid Sema::AnalyzeDeleteExprMismatch(FieldDecl *Field, SourceLocation DeleteLoc,\n                                     bool DeleteWasArrayForm) {\n  MismatchingNewDeleteDetector Detector(/*EndOfTU=*/true);\n  switch (Detector.analyzeField(Field, DeleteWasArrayForm)) {\n  case MismatchingNewDeleteDetector::VarInitMismatches:\n    llvm_unreachable(\"This analysis should have been done for class members.\");\n  case MismatchingNewDeleteDetector::AnalyzeLater:\n    llvm_unreachable(\"Analysis cannot be postponed any point beyond end of \"\n                     \"translation unit.\");\n  case MismatchingNewDeleteDetector::MemberInitMismatches:\n    DiagnoseMismatchedNewDelete(*this, DeleteLoc, Detector);\n    break;\n  case MismatchingNewDeleteDetector::NoMismatch:\n    break;\n  }\n}\n\n/// ActOnCXXDelete - Parsed a C++ 'delete' expression (C++ 5.3.5), as in:\n/// @code ::delete ptr; @endcode\n/// or\n/// @code delete [] ptr; @endcode\nExprResult\nSema::ActOnCXXDelete(SourceLocation StartLoc, bool UseGlobal,\n                     bool ArrayForm, Expr *ExE) {\n  // C++ [expr.delete]p1:\n  //   The operand shall have a pointer type, or a class type having a single\n  //   non-explicit conversion function to a pointer type. The result has type\n  //   void.\n  //\n  // DR599 amends \"pointer type\" to \"pointer to object type\" in both cases.\n\n  ExprResult Ex = ExE;\n  FunctionDecl *OperatorDelete = nullptr;\n  bool ArrayFormAsWritten = ArrayForm;\n  bool UsualArrayDeleteWantsSize = false;\n\n  if (!Ex.get()->isTypeDependent()) {\n    // Perform lvalue-to-rvalue cast, if needed.\n    Ex = DefaultLvalueConversion(Ex.get());\n    if (Ex.isInvalid())\n      return ExprError();\n\n    QualType Type = Ex.get()->getType();\n\n    class DeleteConverter : public ContextualImplicitConverter {\n    public:\n      DeleteConverter() : ContextualImplicitConverter(false, true) {}\n\n      bool match(QualType ConvType) override {\n        // FIXME: If we have an operator T* and an operator void*, we must pick\n        // the operator T*.\n        if (const PointerType *ConvPtrType = ConvType->getAs<PointerType>())\n          if (ConvPtrType->getPointeeType()->isIncompleteOrObjectType())\n            return true;\n        return false;\n      }\n\n      SemaDiagnosticBuilder diagnoseNoMatch(Sema &S, SourceLocation Loc,\n                                            QualType T) override {\n        return S.Diag(Loc, diag::err_delete_operand) << T;\n      }\n\n      SemaDiagnosticBuilder diagnoseIncomplete(Sema &S, SourceLocation Loc,\n                                               QualType T) override {\n        return S.Diag(Loc, diag::err_delete_incomplete_class_type) << T;\n      }\n\n      SemaDiagnosticBuilder diagnoseExplicitConv(Sema &S, SourceLocation Loc,\n                                                 QualType T,\n                                                 QualType ConvTy) override {\n        return S.Diag(Loc, diag::err_delete_explicit_conversion) << T << ConvTy;\n      }\n\n      SemaDiagnosticBuilder noteExplicitConv(Sema &S, CXXConversionDecl *Conv,\n                                             QualType ConvTy) override {\n        return S.Diag(Conv->getLocation(), diag::note_delete_conversion)\n          << ConvTy;\n      }\n\n      SemaDiagnosticBuilder diagnoseAmbiguous(Sema &S, SourceLocation Loc,\n                                              QualType T) override {\n        return S.Diag(Loc, diag::err_ambiguous_delete_operand) << T;\n      }\n\n      SemaDiagnosticBuilder noteAmbiguous(Sema &S, CXXConversionDecl *Conv,\n                                          QualType ConvTy) override {\n        return S.Diag(Conv->getLocation(), diag::note_delete_conversion)\n          << ConvTy;\n      }\n\n      SemaDiagnosticBuilder diagnoseConversion(Sema &S, SourceLocation Loc,\n                                               QualType T,\n                                               QualType ConvTy) override {\n        llvm_unreachable(\"conversion functions are permitted\");\n      }\n    } Converter;\n\n    Ex = PerformContextualImplicitConversion(StartLoc, Ex.get(), Converter);\n    if (Ex.isInvalid())\n      return ExprError();\n    Type = Ex.get()->getType();\n    if (!Converter.match(Type))\n      // FIXME: PerformContextualImplicitConversion should return ExprError\n      //        itself in this case.\n      return ExprError();\n\n    QualType Pointee = Type->castAs<PointerType>()->getPointeeType();\n    QualType PointeeElem = Context.getBaseElementType(Pointee);\n\n    if (Pointee.getAddressSpace() != LangAS::Default &&\n        !getLangOpts().OpenCLCPlusPlus)\n      return Diag(Ex.get()->getBeginLoc(),\n                  diag::err_address_space_qualified_delete)\n             << Pointee.getUnqualifiedType()\n             << Pointee.getQualifiers().getAddressSpaceAttributePrintValue();\n\n    CXXRecordDecl *PointeeRD = nullptr;\n    if (Pointee->isVoidType() && !isSFINAEContext()) {\n      // The C++ standard bans deleting a pointer to a non-object type, which\n      // effectively bans deletion of \"void*\". However, most compilers support\n      // this, so we treat it as a warning unless we're in a SFINAE context.\n      Diag(StartLoc, diag::ext_delete_void_ptr_operand)\n        << Type << Ex.get()->getSourceRange();\n    } else if (Pointee->isFunctionType() || Pointee->isVoidType() ||\n               Pointee->isSizelessType()) {\n      return ExprError(Diag(StartLoc, diag::err_delete_operand)\n        << Type << Ex.get()->getSourceRange());\n    } else if (!Pointee->isDependentType()) {\n      // FIXME: This can result in errors if the definition was imported from a\n      // module but is hidden.\n      if (!RequireCompleteType(StartLoc, Pointee,\n                               diag::warn_delete_incomplete, Ex.get())) {\n        if (const RecordType *RT = PointeeElem->getAs<RecordType>())\n          PointeeRD = cast<CXXRecordDecl>(RT->getDecl());\n      }\n    }\n\n    if (Pointee->isArrayType() && !ArrayForm) {\n      Diag(StartLoc, diag::warn_delete_array_type)\n          << Type << Ex.get()->getSourceRange()\n          << FixItHint::CreateInsertion(getLocForEndOfToken(StartLoc), \"[]\");\n      ArrayForm = true;\n    }\n\n    DeclarationName DeleteName = Context.DeclarationNames.getCXXOperatorName(\n                                      ArrayForm ? OO_Array_Delete : OO_Delete);\n\n    if (PointeeRD) {\n      if (!UseGlobal &&\n          FindDeallocationFunction(StartLoc, PointeeRD, DeleteName,\n                                   OperatorDelete))\n        return ExprError();\n\n      // If we're allocating an array of records, check whether the\n      // usual operator delete[] has a size_t parameter.\n      if (ArrayForm) {\n        // If the user specifically asked to use the global allocator,\n        // we'll need to do the lookup into the class.\n        if (UseGlobal)\n          UsualArrayDeleteWantsSize =\n            doesUsualArrayDeleteWantSize(*this, StartLoc, PointeeElem);\n\n        // Otherwise, the usual operator delete[] should be the\n        // function we just found.\n        else if (OperatorDelete && isa<CXXMethodDecl>(OperatorDelete))\n          UsualArrayDeleteWantsSize =\n            UsualDeallocFnInfo(*this,\n                               DeclAccessPair::make(OperatorDelete, AS_public))\n              .HasSizeT;\n      }\n\n      if (!PointeeRD->hasIrrelevantDestructor())\n        if (CXXDestructorDecl *Dtor = LookupDestructor(PointeeRD)) {\n          MarkFunctionReferenced(StartLoc,\n                                    const_cast<CXXDestructorDecl*>(Dtor));\n          if (DiagnoseUseOfDecl(Dtor, StartLoc))\n            return ExprError();\n        }\n\n      CheckVirtualDtorCall(PointeeRD->getDestructor(), StartLoc,\n                           /*IsDelete=*/true, /*CallCanBeVirtual=*/true,\n                           /*WarnOnNonAbstractTypes=*/!ArrayForm,\n                           SourceLocation());\n    }\n\n    if (!OperatorDelete) {\n      if (getLangOpts().OpenCLCPlusPlus) {\n        Diag(StartLoc, diag::err_openclcxx_not_supported) << \"default delete\";\n        return ExprError();\n      }\n\n      bool IsComplete = isCompleteType(StartLoc, Pointee);\n      bool CanProvideSize =\n          IsComplete && (!ArrayForm || UsualArrayDeleteWantsSize ||\n                         Pointee.isDestructedType());\n      bool Overaligned = hasNewExtendedAlignment(*this, Pointee);\n\n      // Look for a global declaration.\n      OperatorDelete = FindUsualDeallocationFunction(StartLoc, CanProvideSize,\n                                                     Overaligned, DeleteName);\n    }\n\n    MarkFunctionReferenced(StartLoc, OperatorDelete);\n\n    // Check access and ambiguity of destructor if we're going to call it.\n    // Note that this is required even for a virtual delete.\n    bool IsVirtualDelete = false;\n    if (PointeeRD) {\n      if (CXXDestructorDecl *Dtor = LookupDestructor(PointeeRD)) {\n        CheckDestructorAccess(Ex.get()->getExprLoc(), Dtor,\n                              PDiag(diag::err_access_dtor) << PointeeElem);\n        IsVirtualDelete = Dtor->isVirtual();\n      }\n    }\n\n    DiagnoseUseOfDecl(OperatorDelete, StartLoc);\n\n    // Convert the operand to the type of the first parameter of operator\n    // delete. This is only necessary if we selected a destroying operator\n    // delete that we are going to call (non-virtually); converting to void*\n    // is trivial and left to AST consumers to handle.\n    QualType ParamType = OperatorDelete->getParamDecl(0)->getType();\n    if (!IsVirtualDelete && !ParamType->getPointeeType()->isVoidType()) {\n      Qualifiers Qs = Pointee.getQualifiers();\n      if (Qs.hasCVRQualifiers()) {\n        // Qualifiers are irrelevant to this conversion; we're only looking\n        // for access and ambiguity.\n        Qs.removeCVRQualifiers();\n        QualType Unqual = Context.getPointerType(\n            Context.getQualifiedType(Pointee.getUnqualifiedType(), Qs));\n        Ex = ImpCastExprToType(Ex.get(), Unqual, CK_NoOp);\n      }\n      Ex = PerformImplicitConversion(Ex.get(), ParamType, AA_Passing);\n      if (Ex.isInvalid())\n        return ExprError();\n    }\n  }\n\n  CXXDeleteExpr *Result = new (Context) CXXDeleteExpr(\n      Context.VoidTy, UseGlobal, ArrayForm, ArrayFormAsWritten,\n      UsualArrayDeleteWantsSize, OperatorDelete, Ex.get(), StartLoc);\n  AnalyzeDeleteExprMismatch(Result);\n  return Result;\n}\n\nstatic bool resolveBuiltinNewDeleteOverload(Sema &S, CallExpr *TheCall,\n                                            bool IsDelete,\n                                            FunctionDecl *&Operator) {\n\n  DeclarationName NewName = S.Context.DeclarationNames.getCXXOperatorName(\n      IsDelete ? OO_Delete : OO_New);\n\n  LookupResult R(S, NewName, TheCall->getBeginLoc(), Sema::LookupOrdinaryName);\n  S.LookupQualifiedName(R, S.Context.getTranslationUnitDecl());\n  assert(!R.empty() && \"implicitly declared allocation functions not found\");\n  assert(!R.isAmbiguous() && \"global allocation functions are ambiguous\");\n\n  // We do our own custom access checks below.\n  R.suppressDiagnostics();\n\n  SmallVector<Expr *, 8> Args(TheCall->arg_begin(), TheCall->arg_end());\n  OverloadCandidateSet Candidates(R.getNameLoc(),\n                                  OverloadCandidateSet::CSK_Normal);\n  for (LookupResult::iterator FnOvl = R.begin(), FnOvlEnd = R.end();\n       FnOvl != FnOvlEnd; ++FnOvl) {\n    // Even member operator new/delete are implicitly treated as\n    // static, so don't use AddMemberCandidate.\n    NamedDecl *D = (*FnOvl)->getUnderlyingDecl();\n\n    if (FunctionTemplateDecl *FnTemplate = dyn_cast<FunctionTemplateDecl>(D)) {\n      S.AddTemplateOverloadCandidate(FnTemplate, FnOvl.getPair(),\n                                     /*ExplicitTemplateArgs=*/nullptr, Args,\n                                     Candidates,\n                                     /*SuppressUserConversions=*/false);\n      continue;\n    }\n\n    FunctionDecl *Fn = cast<FunctionDecl>(D);\n    S.AddOverloadCandidate(Fn, FnOvl.getPair(), Args, Candidates,\n                           /*SuppressUserConversions=*/false);\n  }\n\n  SourceRange Range = TheCall->getSourceRange();\n\n  // Do the resolution.\n  OverloadCandidateSet::iterator Best;\n  switch (Candidates.BestViableFunction(S, R.getNameLoc(), Best)) {\n  case OR_Success: {\n    // Got one!\n    FunctionDecl *FnDecl = Best->Function;\n    assert(R.getNamingClass() == nullptr &&\n           \"class members should not be considered\");\n\n    if (!FnDecl->isReplaceableGlobalAllocationFunction()) {\n      S.Diag(R.getNameLoc(), diag::err_builtin_operator_new_delete_not_usual)\n          << (IsDelete ? 1 : 0) << Range;\n      S.Diag(FnDecl->getLocation(), diag::note_non_usual_function_declared_here)\n          << R.getLookupName() << FnDecl->getSourceRange();\n      return true;\n    }\n\n    Operator = FnDecl;\n    return false;\n  }\n\n  case OR_No_Viable_Function:\n    Candidates.NoteCandidates(\n        PartialDiagnosticAt(R.getNameLoc(),\n                            S.PDiag(diag::err_ovl_no_viable_function_in_call)\n                                << R.getLookupName() << Range),\n        S, OCD_AllCandidates, Args);\n    return true;\n\n  case OR_Ambiguous:\n    Candidates.NoteCandidates(\n        PartialDiagnosticAt(R.getNameLoc(),\n                            S.PDiag(diag::err_ovl_ambiguous_call)\n                                << R.getLookupName() << Range),\n        S, OCD_AmbiguousCandidates, Args);\n    return true;\n\n  case OR_Deleted: {\n    Candidates.NoteCandidates(\n        PartialDiagnosticAt(R.getNameLoc(), S.PDiag(diag::err_ovl_deleted_call)\n                                                << R.getLookupName() << Range),\n        S, OCD_AllCandidates, Args);\n    return true;\n  }\n  }\n  llvm_unreachable(\"Unreachable, bad result from BestViableFunction\");\n}\n\nExprResult\nSema::SemaBuiltinOperatorNewDeleteOverloaded(ExprResult TheCallResult,\n                                             bool IsDelete) {\n  CallExpr *TheCall = cast<CallExpr>(TheCallResult.get());\n  if (!getLangOpts().CPlusPlus) {\n    Diag(TheCall->getExprLoc(), diag::err_builtin_requires_language)\n        << (IsDelete ? \"__builtin_operator_delete\" : \"__builtin_operator_new\")\n        << \"C++\";\n    return ExprError();\n  }\n  // CodeGen assumes it can find the global new and delete to call,\n  // so ensure that they are declared.\n  DeclareGlobalNewDelete();\n\n  FunctionDecl *OperatorNewOrDelete = nullptr;\n  if (resolveBuiltinNewDeleteOverload(*this, TheCall, IsDelete,\n                                      OperatorNewOrDelete))\n    return ExprError();\n  assert(OperatorNewOrDelete && \"should be found\");\n\n  DiagnoseUseOfDecl(OperatorNewOrDelete, TheCall->getExprLoc());\n  MarkFunctionReferenced(TheCall->getExprLoc(), OperatorNewOrDelete);\n\n  TheCall->setType(OperatorNewOrDelete->getReturnType());\n  for (unsigned i = 0; i != TheCall->getNumArgs(); ++i) {\n    QualType ParamTy = OperatorNewOrDelete->getParamDecl(i)->getType();\n    InitializedEntity Entity =\n        InitializedEntity::InitializeParameter(Context, ParamTy, false);\n    ExprResult Arg = PerformCopyInitialization(\n        Entity, TheCall->getArg(i)->getBeginLoc(), TheCall->getArg(i));\n    if (Arg.isInvalid())\n      return ExprError();\n    TheCall->setArg(i, Arg.get());\n  }\n  auto Callee = dyn_cast<ImplicitCastExpr>(TheCall->getCallee());\n  assert(Callee && Callee->getCastKind() == CK_BuiltinFnToFnPtr &&\n         \"Callee expected to be implicit cast to a builtin function pointer\");\n  Callee->setType(OperatorNewOrDelete->getType());\n\n  return TheCallResult;\n}\n\nvoid Sema::CheckVirtualDtorCall(CXXDestructorDecl *dtor, SourceLocation Loc,\n                                bool IsDelete, bool CallCanBeVirtual,\n                                bool WarnOnNonAbstractTypes,\n                                SourceLocation DtorLoc) {\n  if (!dtor || dtor->isVirtual() || !CallCanBeVirtual || isUnevaluatedContext())\n    return;\n\n  // C++ [expr.delete]p3:\n  //   In the first alternative (delete object), if the static type of the\n  //   object to be deleted is different from its dynamic type, the static\n  //   type shall be a base class of the dynamic type of the object to be\n  //   deleted and the static type shall have a virtual destructor or the\n  //   behavior is undefined.\n  //\n  const CXXRecordDecl *PointeeRD = dtor->getParent();\n  // Note: a final class cannot be derived from, no issue there\n  if (!PointeeRD->isPolymorphic() || PointeeRD->hasAttr<FinalAttr>())\n    return;\n\n  // If the superclass is in a system header, there's nothing that can be done.\n  // The `delete` (where we emit the warning) can be in a system header,\n  // what matters for this warning is where the deleted type is defined.\n  if (getSourceManager().isInSystemHeader(PointeeRD->getLocation()))\n    return;\n\n  QualType ClassType = dtor->getThisType()->getPointeeType();\n  if (PointeeRD->isAbstract()) {\n    // If the class is abstract, we warn by default, because we're\n    // sure the code has undefined behavior.\n    Diag(Loc, diag::warn_delete_abstract_non_virtual_dtor) << (IsDelete ? 0 : 1)\n                                                           << ClassType;\n  } else if (WarnOnNonAbstractTypes) {\n    // Otherwise, if this is not an array delete, it's a bit suspect,\n    // but not necessarily wrong.\n    Diag(Loc, diag::warn_delete_non_virtual_dtor) << (IsDelete ? 0 : 1)\n                                                  << ClassType;\n  }\n  if (!IsDelete) {\n    std::string TypeStr;\n    ClassType.getAsStringInternal(TypeStr, getPrintingPolicy());\n    Diag(DtorLoc, diag::note_delete_non_virtual)\n        << FixItHint::CreateInsertion(DtorLoc, TypeStr + \"::\");\n  }\n}\n\nSema::ConditionResult Sema::ActOnConditionVariable(Decl *ConditionVar,\n                                                   SourceLocation StmtLoc,\n                                                   ConditionKind CK) {\n  ExprResult E =\n      CheckConditionVariable(cast<VarDecl>(ConditionVar), StmtLoc, CK);\n  if (E.isInvalid())\n    return ConditionError();\n  return ConditionResult(*this, ConditionVar, MakeFullExpr(E.get(), StmtLoc),\n                         CK == ConditionKind::ConstexprIf);\n}\n\n/// Check the use of the given variable as a C++ condition in an if,\n/// while, do-while, or switch statement.\nExprResult Sema::CheckConditionVariable(VarDecl *ConditionVar,\n                                        SourceLocation StmtLoc,\n                                        ConditionKind CK) {\n  if (ConditionVar->isInvalidDecl())\n    return ExprError();\n\n  QualType T = ConditionVar->getType();\n\n  // C++ [stmt.select]p2:\n  //   The declarator shall not specify a function or an array.\n  if (T->isFunctionType())\n    return ExprError(Diag(ConditionVar->getLocation(),\n                          diag::err_invalid_use_of_function_type)\n                       << ConditionVar->getSourceRange());\n  else if (T->isArrayType())\n    return ExprError(Diag(ConditionVar->getLocation(),\n                          diag::err_invalid_use_of_array_type)\n                     << ConditionVar->getSourceRange());\n\n  ExprResult Condition = BuildDeclRefExpr(\n      ConditionVar, ConditionVar->getType().getNonReferenceType(), VK_LValue,\n      ConditionVar->getLocation());\n\n  switch (CK) {\n  case ConditionKind::Boolean:\n    return CheckBooleanCondition(StmtLoc, Condition.get());\n\n  case ConditionKind::ConstexprIf:\n    return CheckBooleanCondition(StmtLoc, Condition.get(), true);\n\n  case ConditionKind::Switch:\n    return CheckSwitchCondition(StmtLoc, Condition.get());\n  }\n\n  llvm_unreachable(\"unexpected condition kind\");\n}\n\n/// CheckCXXBooleanCondition - Returns true if a conversion to bool is invalid.\nExprResult Sema::CheckCXXBooleanCondition(Expr *CondExpr, bool IsConstexpr) {\n  // C++ 6.4p4:\n  // The value of a condition that is an initialized declaration in a statement\n  // other than a switch statement is the value of the declared variable\n  // implicitly converted to type bool. If that conversion is ill-formed, the\n  // program is ill-formed.\n  // The value of a condition that is an expression is the value of the\n  // expression, implicitly converted to bool.\n  //\n  // FIXME: Return this value to the caller so they don't need to recompute it.\n  llvm::APSInt Value(/*BitWidth*/1);\n  return (IsConstexpr && !CondExpr->isValueDependent())\n             ? CheckConvertedConstantExpression(CondExpr, Context.BoolTy, Value,\n                                                CCEK_ConstexprIf)\n             : PerformContextuallyConvertToBool(CondExpr);\n}\n\n/// Helper function to determine whether this is the (deprecated) C++\n/// conversion from a string literal to a pointer to non-const char or\n/// non-const wchar_t (for narrow and wide string literals,\n/// respectively).\nbool\nSema::IsStringLiteralToNonConstPointerConversion(Expr *From, QualType ToType) {\n  // Look inside the implicit cast, if it exists.\n  if (ImplicitCastExpr *Cast = dyn_cast<ImplicitCastExpr>(From))\n    From = Cast->getSubExpr();\n\n  // A string literal (2.13.4) that is not a wide string literal can\n  // be converted to an rvalue of type \"pointer to char\"; a wide\n  // string literal can be converted to an rvalue of type \"pointer\n  // to wchar_t\" (C++ 4.2p2).\n  if (StringLiteral *StrLit = dyn_cast<StringLiteral>(From->IgnoreParens()))\n    if (const PointerType *ToPtrType = ToType->getAs<PointerType>())\n      if (const BuiltinType *ToPointeeType\n          = ToPtrType->getPointeeType()->getAs<BuiltinType>()) {\n        // This conversion is considered only when there is an\n        // explicit appropriate pointer target type (C++ 4.2p2).\n        if (!ToPtrType->getPointeeType().hasQualifiers()) {\n          switch (StrLit->getKind()) {\n            case StringLiteral::UTF8:\n            case StringLiteral::UTF16:\n            case StringLiteral::UTF32:\n              // We don't allow UTF literals to be implicitly converted\n              break;\n            case StringLiteral::Ascii:\n              return (ToPointeeType->getKind() == BuiltinType::Char_U ||\n                      ToPointeeType->getKind() == BuiltinType::Char_S);\n            case StringLiteral::Wide:\n              return Context.typesAreCompatible(Context.getWideCharType(),\n                                                QualType(ToPointeeType, 0));\n          }\n        }\n      }\n\n  return false;\n}\n\nstatic ExprResult BuildCXXCastArgument(Sema &S,\n                                       SourceLocation CastLoc,\n                                       QualType Ty,\n                                       CastKind Kind,\n                                       CXXMethodDecl *Method,\n                                       DeclAccessPair FoundDecl,\n                                       bool HadMultipleCandidates,\n                                       Expr *From) {\n  switch (Kind) {\n  default: llvm_unreachable(\"Unhandled cast kind!\");\n  case CK_ConstructorConversion: {\n    CXXConstructorDecl *Constructor = cast<CXXConstructorDecl>(Method);\n    SmallVector<Expr*, 8> ConstructorArgs;\n\n    if (S.RequireNonAbstractType(CastLoc, Ty,\n                                 diag::err_allocation_of_abstract_type))\n      return ExprError();\n\n    if (S.CompleteConstructorCall(Constructor, Ty, From, CastLoc,\n                                  ConstructorArgs))\n      return ExprError();\n\n    S.CheckConstructorAccess(CastLoc, Constructor, FoundDecl,\n                             InitializedEntity::InitializeTemporary(Ty));\n    if (S.DiagnoseUseOfDecl(Method, CastLoc))\n      return ExprError();\n\n    ExprResult Result = S.BuildCXXConstructExpr(\n        CastLoc, Ty, FoundDecl, cast<CXXConstructorDecl>(Method),\n        ConstructorArgs, HadMultipleCandidates,\n        /*ListInit*/ false, /*StdInitListInit*/ false, /*ZeroInit*/ false,\n        CXXConstructExpr::CK_Complete, SourceRange());\n    if (Result.isInvalid())\n      return ExprError();\n\n    return S.MaybeBindToTemporary(Result.getAs<Expr>());\n  }\n\n  case CK_UserDefinedConversion: {\n    assert(!From->getType()->isPointerType() && \"Arg can't have pointer type!\");\n\n    S.CheckMemberOperatorAccess(CastLoc, From, /*arg*/ nullptr, FoundDecl);\n    if (S.DiagnoseUseOfDecl(Method, CastLoc))\n      return ExprError();\n\n    // Create an implicit call expr that calls it.\n    CXXConversionDecl *Conv = cast<CXXConversionDecl>(Method);\n    ExprResult Result = S.BuildCXXMemberCallExpr(From, FoundDecl, Conv,\n                                                 HadMultipleCandidates);\n    if (Result.isInvalid())\n      return ExprError();\n    // Record usage of conversion in an implicit cast.\n    Result = ImplicitCastExpr::Create(S.Context, Result.get()->getType(),\n                                      CK_UserDefinedConversion, Result.get(),\n                                      nullptr, Result.get()->getValueKind(),\n                                      S.CurFPFeatureOverrides());\n\n    return S.MaybeBindToTemporary(Result.get());\n  }\n  }\n}\n\n/// PerformImplicitConversion - Perform an implicit conversion of the\n/// expression From to the type ToType using the pre-computed implicit\n/// conversion sequence ICS. Returns the converted\n/// expression. Action is the kind of conversion we're performing,\n/// used in the error message.\nExprResult\nSema::PerformImplicitConversion(Expr *From, QualType ToType,\n                                const ImplicitConversionSequence &ICS,\n                                AssignmentAction Action,\n                                CheckedConversionKind CCK) {\n  // C++ [over.match.oper]p7: [...] operands of class type are converted [...]\n  if (CCK == CCK_ForBuiltinOverloadedOp && !From->getType()->isRecordType())\n    return From;\n\n  switch (ICS.getKind()) {\n  case ImplicitConversionSequence::StandardConversion: {\n    ExprResult Res = PerformImplicitConversion(From, ToType, ICS.Standard,\n                                               Action, CCK);\n    if (Res.isInvalid())\n      return ExprError();\n    From = Res.get();\n    break;\n  }\n\n  case ImplicitConversionSequence::UserDefinedConversion: {\n\n      FunctionDecl *FD = ICS.UserDefined.ConversionFunction;\n      CastKind CastKind;\n      QualType BeforeToType;\n      assert(FD && \"no conversion function for user-defined conversion seq\");\n      if (const CXXConversionDecl *Conv = dyn_cast<CXXConversionDecl>(FD)) {\n        CastKind = CK_UserDefinedConversion;\n\n        // If the user-defined conversion is specified by a conversion function,\n        // the initial standard conversion sequence converts the source type to\n        // the implicit object parameter of the conversion function.\n        BeforeToType = Context.getTagDeclType(Conv->getParent());\n      } else {\n        const CXXConstructorDecl *Ctor = cast<CXXConstructorDecl>(FD);\n        CastKind = CK_ConstructorConversion;\n        // Do no conversion if dealing with ... for the first conversion.\n        if (!ICS.UserDefined.EllipsisConversion) {\n          // If the user-defined conversion is specified by a constructor, the\n          // initial standard conversion sequence converts the source type to\n          // the type required by the argument of the constructor\n          BeforeToType = Ctor->getParamDecl(0)->getType().getNonReferenceType();\n        }\n      }\n      // Watch out for ellipsis conversion.\n      if (!ICS.UserDefined.EllipsisConversion) {\n        ExprResult Res =\n          PerformImplicitConversion(From, BeforeToType,\n                                    ICS.UserDefined.Before, AA_Converting,\n                                    CCK);\n        if (Res.isInvalid())\n          return ExprError();\n        From = Res.get();\n      }\n\n      ExprResult CastArg = BuildCXXCastArgument(\n          *this, From->getBeginLoc(), ToType.getNonReferenceType(), CastKind,\n          cast<CXXMethodDecl>(FD), ICS.UserDefined.FoundConversionFunction,\n          ICS.UserDefined.HadMultipleCandidates, From);\n\n      if (CastArg.isInvalid())\n        return ExprError();\n\n      From = CastArg.get();\n\n      // C++ [over.match.oper]p7:\n      //   [...] the second standard conversion sequence of a user-defined\n      //   conversion sequence is not applied.\n      if (CCK == CCK_ForBuiltinOverloadedOp)\n        return From;\n\n      return PerformImplicitConversion(From, ToType, ICS.UserDefined.After,\n                                       AA_Converting, CCK);\n  }\n\n  case ImplicitConversionSequence::AmbiguousConversion:\n    ICS.DiagnoseAmbiguousConversion(*this, From->getExprLoc(),\n                          PDiag(diag::err_typecheck_ambiguous_condition)\n                            << From->getSourceRange());\n    return ExprError();\n\n  case ImplicitConversionSequence::EllipsisConversion:\n    llvm_unreachable(\"Cannot perform an ellipsis conversion\");\n\n  case ImplicitConversionSequence::BadConversion:\n    Sema::AssignConvertType ConvTy =\n        CheckAssignmentConstraints(From->getExprLoc(), ToType, From->getType());\n    bool Diagnosed = DiagnoseAssignmentResult(\n        ConvTy == Compatible ? Incompatible : ConvTy, From->getExprLoc(),\n        ToType, From->getType(), From, Action);\n    assert(Diagnosed && \"failed to diagnose bad conversion\"); (void)Diagnosed;\n    return ExprError();\n  }\n\n  // Everything went well.\n  return From;\n}\n\n/// PerformImplicitConversion - Perform an implicit conversion of the\n/// expression From to the type ToType by following the standard\n/// conversion sequence SCS. Returns the converted\n/// expression. Flavor is the context in which we're performing this\n/// conversion, for use in error messages.\nExprResult\nSema::PerformImplicitConversion(Expr *From, QualType ToType,\n                                const StandardConversionSequence& SCS,\n                                AssignmentAction Action,\n                                CheckedConversionKind CCK) {\n  bool CStyle = (CCK == CCK_CStyleCast || CCK == CCK_FunctionalCast);\n\n  // Overall FIXME: we are recomputing too many types here and doing far too\n  // much extra work. What this means is that we need to keep track of more\n  // information that is computed when we try the implicit conversion initially,\n  // so that we don't need to recompute anything here.\n  QualType FromType = From->getType();\n\n  if (SCS.CopyConstructor) {\n    // FIXME: When can ToType be a reference type?\n    assert(!ToType->isReferenceType());\n    if (SCS.Second == ICK_Derived_To_Base) {\n      SmallVector<Expr*, 8> ConstructorArgs;\n      if (CompleteConstructorCall(\n              cast<CXXConstructorDecl>(SCS.CopyConstructor), ToType, From,\n              /*FIXME:ConstructLoc*/ SourceLocation(), ConstructorArgs))\n        return ExprError();\n      return BuildCXXConstructExpr(\n          /*FIXME:ConstructLoc*/ SourceLocation(), ToType,\n          SCS.FoundCopyConstructor, SCS.CopyConstructor,\n          ConstructorArgs, /*HadMultipleCandidates*/ false,\n          /*ListInit*/ false, /*StdInitListInit*/ false, /*ZeroInit*/ false,\n          CXXConstructExpr::CK_Complete, SourceRange());\n    }\n    return BuildCXXConstructExpr(\n        /*FIXME:ConstructLoc*/ SourceLocation(), ToType,\n        SCS.FoundCopyConstructor, SCS.CopyConstructor,\n        From, /*HadMultipleCandidates*/ false,\n        /*ListInit*/ false, /*StdInitListInit*/ false, /*ZeroInit*/ false,\n        CXXConstructExpr::CK_Complete, SourceRange());\n  }\n\n  // Resolve overloaded function references.\n  if (Context.hasSameType(FromType, Context.OverloadTy)) {\n    DeclAccessPair Found;\n    FunctionDecl *Fn = ResolveAddressOfOverloadedFunction(From, ToType,\n                                                          true, Found);\n    if (!Fn)\n      return ExprError();\n\n    if (DiagnoseUseOfDecl(Fn, From->getBeginLoc()))\n      return ExprError();\n\n    From = FixOverloadedFunctionReference(From, Found, Fn);\n    FromType = From->getType();\n  }\n\n  // If we're converting to an atomic type, first convert to the corresponding\n  // non-atomic type.\n  QualType ToAtomicType;\n  if (const AtomicType *ToAtomic = ToType->getAs<AtomicType>()) {\n    ToAtomicType = ToType;\n    ToType = ToAtomic->getValueType();\n  }\n\n  QualType InitialFromType = FromType;\n  // Perform the first implicit conversion.\n  switch (SCS.First) {\n  case ICK_Identity:\n    if (const AtomicType *FromAtomic = FromType->getAs<AtomicType>()) {\n      FromType = FromAtomic->getValueType().getUnqualifiedType();\n      From = ImplicitCastExpr::Create(Context, FromType, CK_AtomicToNonAtomic,\n                                      From, /*BasePath=*/nullptr, VK_RValue,\n                                      FPOptionsOverride());\n    }\n    break;\n\n  case ICK_Lvalue_To_Rvalue: {\n    assert(From->getObjectKind() != OK_ObjCProperty);\n    ExprResult FromRes = DefaultLvalueConversion(From);\n    assert(!FromRes.isInvalid() && \"Can't perform deduced conversion?!\");\n    From = FromRes.get();\n    FromType = From->getType();\n    break;\n  }\n\n  case ICK_Array_To_Pointer:\n    FromType = Context.getArrayDecayedType(FromType);\n    From = ImpCastExprToType(From, FromType, CK_ArrayToPointerDecay,\n                             VK_RValue, /*BasePath=*/nullptr, CCK).get();\n    break;\n\n  case ICK_Function_To_Pointer:\n    FromType = Context.getPointerType(FromType);\n    From = ImpCastExprToType(From, FromType, CK_FunctionToPointerDecay,\n                             VK_RValue, /*BasePath=*/nullptr, CCK).get();\n    break;\n\n  default:\n    llvm_unreachable(\"Improper first standard conversion\");\n  }\n\n  // Perform the second implicit conversion\n  switch (SCS.Second) {\n  case ICK_Identity:\n    // C++ [except.spec]p5:\n    //   [For] assignment to and initialization of pointers to functions,\n    //   pointers to member functions, and references to functions: the\n    //   target entity shall allow at least the exceptions allowed by the\n    //   source value in the assignment or initialization.\n    switch (Action) {\n    case AA_Assigning:\n    case AA_Initializing:\n      // Note, function argument passing and returning are initialization.\n    case AA_Passing:\n    case AA_Returning:\n    case AA_Sending:\n    case AA_Passing_CFAudited:\n      if (CheckExceptionSpecCompatibility(From, ToType))\n        return ExprError();\n      break;\n\n    case AA_Casting:\n    case AA_Converting:\n      // Casts and implicit conversions are not initialization, so are not\n      // checked for exception specification mismatches.\n      break;\n    }\n    // Nothing else to do.\n    break;\n\n  case ICK_Integral_Promotion:\n  case ICK_Integral_Conversion:\n    if (ToType->isBooleanType()) {\n      assert(FromType->castAs<EnumType>()->getDecl()->isFixed() &&\n             SCS.Second == ICK_Integral_Promotion &&\n             \"only enums with fixed underlying type can promote to bool\");\n      From = ImpCastExprToType(From, ToType, CK_IntegralToBoolean,\n                               VK_RValue, /*BasePath=*/nullptr, CCK).get();\n    } else {\n      From = ImpCastExprToType(From, ToType, CK_IntegralCast,\n                               VK_RValue, /*BasePath=*/nullptr, CCK).get();\n    }\n    break;\n\n  case ICK_Floating_Promotion:\n  case ICK_Floating_Conversion:\n    From = ImpCastExprToType(From, ToType, CK_FloatingCast,\n                             VK_RValue, /*BasePath=*/nullptr, CCK).get();\n    break;\n\n  case ICK_Complex_Promotion:\n  case ICK_Complex_Conversion: {\n    QualType FromEl = From->getType()->castAs<ComplexType>()->getElementType();\n    QualType ToEl = ToType->castAs<ComplexType>()->getElementType();\n    CastKind CK;\n    if (FromEl->isRealFloatingType()) {\n      if (ToEl->isRealFloatingType())\n        CK = CK_FloatingComplexCast;\n      else\n        CK = CK_FloatingComplexToIntegralComplex;\n    } else if (ToEl->isRealFloatingType()) {\n      CK = CK_IntegralComplexToFloatingComplex;\n    } else {\n      CK = CK_IntegralComplexCast;\n    }\n    From = ImpCastExprToType(From, ToType, CK,\n                             VK_RValue, /*BasePath=*/nullptr, CCK).get();\n    break;\n  }\n\n  case ICK_Floating_Integral:\n    if (ToType->isRealFloatingType())\n      From = ImpCastExprToType(From, ToType, CK_IntegralToFloating,\n                               VK_RValue, /*BasePath=*/nullptr, CCK).get();\n    else\n      From = ImpCastExprToType(From, ToType, CK_FloatingToIntegral,\n                               VK_RValue, /*BasePath=*/nullptr, CCK).get();\n    break;\n\n  case ICK_Compatible_Conversion:\n    From = ImpCastExprToType(From, ToType, CK_NoOp, From->getValueKind(),\n                             /*BasePath=*/nullptr, CCK).get();\n    break;\n\n  case ICK_Writeback_Conversion:\n  case ICK_Pointer_Conversion: {\n    if (SCS.IncompatibleObjC && Action != AA_Casting) {\n      // Diagnose incompatible Objective-C conversions\n      if (Action == AA_Initializing || Action == AA_Assigning)\n        Diag(From->getBeginLoc(),\n             diag::ext_typecheck_convert_incompatible_pointer)\n            << ToType << From->getType() << Action << From->getSourceRange()\n            << 0;\n      else\n        Diag(From->getBeginLoc(),\n             diag::ext_typecheck_convert_incompatible_pointer)\n            << From->getType() << ToType << Action << From->getSourceRange()\n            << 0;\n\n      if (From->getType()->isObjCObjectPointerType() &&\n          ToType->isObjCObjectPointerType())\n        EmitRelatedResultTypeNote(From);\n    } else if (getLangOpts().allowsNonTrivialObjCLifetimeQualifiers() &&\n               !CheckObjCARCUnavailableWeakConversion(ToType,\n                                                      From->getType())) {\n      if (Action == AA_Initializing)\n        Diag(From->getBeginLoc(), diag::err_arc_weak_unavailable_assign);\n      else\n        Diag(From->getBeginLoc(), diag::err_arc_convesion_of_weak_unavailable)\n            << (Action == AA_Casting) << From->getType() << ToType\n            << From->getSourceRange();\n    }\n\n    // Defer address space conversion to the third conversion.\n    QualType FromPteeType = From->getType()->getPointeeType();\n    QualType ToPteeType = ToType->getPointeeType();\n    QualType NewToType = ToType;\n    if (!FromPteeType.isNull() && !ToPteeType.isNull() &&\n        FromPteeType.getAddressSpace() != ToPteeType.getAddressSpace()) {\n      NewToType = Context.removeAddrSpaceQualType(ToPteeType);\n      NewToType = Context.getAddrSpaceQualType(NewToType,\n                                               FromPteeType.getAddressSpace());\n      if (ToType->isObjCObjectPointerType())\n        NewToType = Context.getObjCObjectPointerType(NewToType);\n      else if (ToType->isBlockPointerType())\n        NewToType = Context.getBlockPointerType(NewToType);\n      else\n        NewToType = Context.getPointerType(NewToType);\n    }\n\n    CastKind Kind;\n    CXXCastPath BasePath;\n    if (CheckPointerConversion(From, NewToType, Kind, BasePath, CStyle))\n      return ExprError();\n\n    // Make sure we extend blocks if necessary.\n    // FIXME: doing this here is really ugly.\n    if (Kind == CK_BlockPointerToObjCPointerCast) {\n      ExprResult E = From;\n      (void) PrepareCastToObjCObjectPointer(E);\n      From = E.get();\n    }\n    if (getLangOpts().allowsNonTrivialObjCLifetimeQualifiers())\n      CheckObjCConversion(SourceRange(), NewToType, From, CCK);\n    From = ImpCastExprToType(From, NewToType, Kind, VK_RValue, &BasePath, CCK)\n             .get();\n    break;\n  }\n\n  case ICK_Pointer_Member: {\n    CastKind Kind;\n    CXXCastPath BasePath;\n    if (CheckMemberPointerConversion(From, ToType, Kind, BasePath, CStyle))\n      return ExprError();\n    if (CheckExceptionSpecCompatibility(From, ToType))\n      return ExprError();\n\n    // We may not have been able to figure out what this member pointer resolved\n    // to up until this exact point.  Attempt to lock-in it's inheritance model.\n    if (Context.getTargetInfo().getCXXABI().isMicrosoft()) {\n      (void)isCompleteType(From->getExprLoc(), From->getType());\n      (void)isCompleteType(From->getExprLoc(), ToType);\n    }\n\n    From = ImpCastExprToType(From, ToType, Kind, VK_RValue, &BasePath, CCK)\n             .get();\n    break;\n  }\n\n  case ICK_Boolean_Conversion:\n    // Perform half-to-boolean conversion via float.\n    if (From->getType()->isHalfType()) {\n      From = ImpCastExprToType(From, Context.FloatTy, CK_FloatingCast).get();\n      FromType = Context.FloatTy;\n    }\n\n    From = ImpCastExprToType(From, Context.BoolTy,\n                             ScalarTypeToBooleanCastKind(FromType),\n                             VK_RValue, /*BasePath=*/nullptr, CCK).get();\n    break;\n\n  case ICK_Derived_To_Base: {\n    CXXCastPath BasePath;\n    if (CheckDerivedToBaseConversion(\n            From->getType(), ToType.getNonReferenceType(), From->getBeginLoc(),\n            From->getSourceRange(), &BasePath, CStyle))\n      return ExprError();\n\n    From = ImpCastExprToType(From, ToType.getNonReferenceType(),\n                      CK_DerivedToBase, From->getValueKind(),\n                      &BasePath, CCK).get();\n    break;\n  }\n\n  case ICK_Vector_Conversion:\n    From = ImpCastExprToType(From, ToType, CK_BitCast,\n                             VK_RValue, /*BasePath=*/nullptr, CCK).get();\n    break;\n\n  case ICK_SVE_Vector_Conversion:\n    From = ImpCastExprToType(From, ToType, CK_BitCast, VK_RValue,\n                             /*BasePath=*/nullptr, CCK)\n               .get();\n    break;\n\n  case ICK_Vector_Splat: {\n    // Vector splat from any arithmetic type to a vector.\n    Expr *Elem = prepareVectorSplat(ToType, From).get();\n    From = ImpCastExprToType(Elem, ToType, CK_VectorSplat, VK_RValue,\n                             /*BasePath=*/nullptr, CCK).get();\n    break;\n  }\n\n  case ICK_Complex_Real:\n    // Case 1.  x -> _Complex y\n    if (const ComplexType *ToComplex = ToType->getAs<ComplexType>()) {\n      QualType ElType = ToComplex->getElementType();\n      bool isFloatingComplex = ElType->isRealFloatingType();\n\n      // x -> y\n      if (Context.hasSameUnqualifiedType(ElType, From->getType())) {\n        // do nothing\n      } else if (From->getType()->isRealFloatingType()) {\n        From = ImpCastExprToType(From, ElType,\n                isFloatingComplex ? CK_FloatingCast : CK_FloatingToIntegral).get();\n      } else {\n        assert(From->getType()->isIntegerType());\n        From = ImpCastExprToType(From, ElType,\n                isFloatingComplex ? CK_IntegralToFloating : CK_IntegralCast).get();\n      }\n      // y -> _Complex y\n      From = ImpCastExprToType(From, ToType,\n                   isFloatingComplex ? CK_FloatingRealToComplex\n                                     : CK_IntegralRealToComplex).get();\n\n    // Case 2.  _Complex x -> y\n    } else {\n      auto *FromComplex = From->getType()->castAs<ComplexType>();\n      QualType ElType = FromComplex->getElementType();\n      bool isFloatingComplex = ElType->isRealFloatingType();\n\n      // _Complex x -> x\n      From = ImpCastExprToType(From, ElType,\n                   isFloatingComplex ? CK_FloatingComplexToReal\n                                     : CK_IntegralComplexToReal,\n                               VK_RValue, /*BasePath=*/nullptr, CCK).get();\n\n      // x -> y\n      if (Context.hasSameUnqualifiedType(ElType, ToType)) {\n        // do nothing\n      } else if (ToType->isRealFloatingType()) {\n        From = ImpCastExprToType(From, ToType,\n                   isFloatingComplex ? CK_FloatingCast : CK_IntegralToFloating,\n                                 VK_RValue, /*BasePath=*/nullptr, CCK).get();\n      } else {\n        assert(ToType->isIntegerType());\n        From = ImpCastExprToType(From, ToType,\n                   isFloatingComplex ? CK_FloatingToIntegral : CK_IntegralCast,\n                                 VK_RValue, /*BasePath=*/nullptr, CCK).get();\n      }\n    }\n    break;\n\n  case ICK_Block_Pointer_Conversion: {\n    LangAS AddrSpaceL =\n        ToType->castAs<BlockPointerType>()->getPointeeType().getAddressSpace();\n    LangAS AddrSpaceR =\n        FromType->castAs<BlockPointerType>()->getPointeeType().getAddressSpace();\n    assert(Qualifiers::isAddressSpaceSupersetOf(AddrSpaceL, AddrSpaceR) &&\n           \"Invalid cast\");\n    CastKind Kind =\n        AddrSpaceL != AddrSpaceR ? CK_AddressSpaceConversion : CK_BitCast;\n    From = ImpCastExprToType(From, ToType.getUnqualifiedType(), Kind,\n                             VK_RValue, /*BasePath=*/nullptr, CCK).get();\n    break;\n  }\n\n  case ICK_TransparentUnionConversion: {\n    ExprResult FromRes = From;\n    Sema::AssignConvertType ConvTy =\n      CheckTransparentUnionArgumentConstraints(ToType, FromRes);\n    if (FromRes.isInvalid())\n      return ExprError();\n    From = FromRes.get();\n    assert ((ConvTy == Sema::Compatible) &&\n            \"Improper transparent union conversion\");\n    (void)ConvTy;\n    break;\n  }\n\n  case ICK_Zero_Event_Conversion:\n  case ICK_Zero_Queue_Conversion:\n    From = ImpCastExprToType(From, ToType,\n                             CK_ZeroToOCLOpaqueType,\n                             From->getValueKind()).get();\n    break;\n\n  case ICK_Lvalue_To_Rvalue:\n  case ICK_Array_To_Pointer:\n  case ICK_Function_To_Pointer:\n  case ICK_Function_Conversion:\n  case ICK_Qualification:\n  case ICK_Num_Conversion_Kinds:\n  case ICK_C_Only_Conversion:\n  case ICK_Incompatible_Pointer_Conversion:\n    llvm_unreachable(\"Improper second standard conversion\");\n  }\n\n  switch (SCS.Third) {\n  case ICK_Identity:\n    // Nothing to do.\n    break;\n\n  case ICK_Function_Conversion:\n    // If both sides are functions (or pointers/references to them), there could\n    // be incompatible exception declarations.\n    if (CheckExceptionSpecCompatibility(From, ToType))\n      return ExprError();\n\n    From = ImpCastExprToType(From, ToType, CK_NoOp,\n                             VK_RValue, /*BasePath=*/nullptr, CCK).get();\n    break;\n\n  case ICK_Qualification: {\n    ExprValueKind VK = From->getValueKind();\n    CastKind CK = CK_NoOp;\n\n    if (ToType->isReferenceType() &&\n        ToType->getPointeeType().getAddressSpace() !=\n            From->getType().getAddressSpace())\n      CK = CK_AddressSpaceConversion;\n\n    if (ToType->isPointerType() &&\n        ToType->getPointeeType().getAddressSpace() !=\n            From->getType()->getPointeeType().getAddressSpace())\n      CK = CK_AddressSpaceConversion;\n\n    From = ImpCastExprToType(From, ToType.getNonLValueExprType(Context), CK, VK,\n                             /*BasePath=*/nullptr, CCK)\n               .get();\n\n    if (SCS.DeprecatedStringLiteralToCharPtr &&\n        !getLangOpts().WritableStrings) {\n      Diag(From->getBeginLoc(),\n           getLangOpts().CPlusPlus11\n               ? diag::ext_deprecated_string_literal_conversion\n               : diag::warn_deprecated_string_literal_conversion)\n          << ToType.getNonReferenceType();\n    }\n\n    break;\n  }\n\n  default:\n    llvm_unreachable(\"Improper third standard conversion\");\n  }\n\n  // If this conversion sequence involved a scalar -> atomic conversion, perform\n  // that conversion now.\n  if (!ToAtomicType.isNull()) {\n    assert(Context.hasSameType(\n        ToAtomicType->castAs<AtomicType>()->getValueType(), From->getType()));\n    From = ImpCastExprToType(From, ToAtomicType, CK_NonAtomicToAtomic,\n                             VK_RValue, nullptr, CCK).get();\n  }\n\n  // Materialize a temporary if we're implicitly converting to a reference\n  // type. This is not required by the C++ rules but is necessary to maintain\n  // AST invariants.\n  if (ToType->isReferenceType() && From->isRValue()) {\n    ExprResult Res = TemporaryMaterializationConversion(From);\n    if (Res.isInvalid())\n      return ExprError();\n    From = Res.get();\n  }\n\n  // If this conversion sequence succeeded and involved implicitly converting a\n  // _Nullable type to a _Nonnull one, complain.\n  if (!isCast(CCK))\n    diagnoseNullableToNonnullConversion(ToType, InitialFromType,\n                                        From->getBeginLoc());\n\n  return From;\n}\n\n/// Check the completeness of a type in a unary type trait.\n///\n/// If the particular type trait requires a complete type, tries to complete\n/// it. If completing the type fails, a diagnostic is emitted and false\n/// returned. If completing the type succeeds or no completion was required,\n/// returns true.\nstatic bool CheckUnaryTypeTraitTypeCompleteness(Sema &S, TypeTrait UTT,\n                                                SourceLocation Loc,\n                                                QualType ArgTy) {\n  // C++0x [meta.unary.prop]p3:\n  //   For all of the class templates X declared in this Clause, instantiating\n  //   that template with a template argument that is a class template\n  //   specialization may result in the implicit instantiation of the template\n  //   argument if and only if the semantics of X require that the argument\n  //   must be a complete type.\n  // We apply this rule to all the type trait expressions used to implement\n  // these class templates. We also try to follow any GCC documented behavior\n  // in these expressions to ensure portability of standard libraries.\n  switch (UTT) {\n  default: llvm_unreachable(\"not a UTT\");\n    // is_complete_type somewhat obviously cannot require a complete type.\n  case UTT_IsCompleteType:\n    // Fall-through\n\n    // These traits are modeled on the type predicates in C++0x\n    // [meta.unary.cat] and [meta.unary.comp]. They are not specified as\n    // requiring a complete type, as whether or not they return true cannot be\n    // impacted by the completeness of the type.\n  case UTT_IsVoid:\n  case UTT_IsIntegral:\n  case UTT_IsFloatingPoint:\n  case UTT_IsArray:\n  case UTT_IsPointer:\n  case UTT_IsLvalueReference:\n  case UTT_IsRvalueReference:\n  case UTT_IsMemberFunctionPointer:\n  case UTT_IsMemberObjectPointer:\n  case UTT_IsEnum:\n  case UTT_IsUnion:\n  case UTT_IsClass:\n  case UTT_IsFunction:\n  case UTT_IsReference:\n  case UTT_IsArithmetic:\n  case UTT_IsFundamental:\n  case UTT_IsObject:\n  case UTT_IsScalar:\n  case UTT_IsCompound:\n  case UTT_IsMemberPointer:\n    // Fall-through\n\n    // These traits are modeled on type predicates in C++0x [meta.unary.prop]\n    // which requires some of its traits to have the complete type. However,\n    // the completeness of the type cannot impact these traits' semantics, and\n    // so they don't require it. This matches the comments on these traits in\n    // Table 49.\n  case UTT_IsConst:\n  case UTT_IsVolatile:\n  case UTT_IsSigned:\n  case UTT_IsUnsigned:\n\n  // This type trait always returns false, checking the type is moot.\n  case UTT_IsInterfaceClass:\n    return true;\n\n  // C++14 [meta.unary.prop]:\n  //   If T is a non-union class type, T shall be a complete type.\n  case UTT_IsEmpty:\n  case UTT_IsPolymorphic:\n  case UTT_IsAbstract:\n    if (const auto *RD = ArgTy->getAsCXXRecordDecl())\n      if (!RD->isUnion())\n        return !S.RequireCompleteType(\n            Loc, ArgTy, diag::err_incomplete_type_used_in_type_trait_expr);\n    return true;\n\n  // C++14 [meta.unary.prop]:\n  //   If T is a class type, T shall be a complete type.\n  case UTT_IsFinal:\n  case UTT_IsSealed:\n    if (ArgTy->getAsCXXRecordDecl())\n      return !S.RequireCompleteType(\n          Loc, ArgTy, diag::err_incomplete_type_used_in_type_trait_expr);\n    return true;\n\n  // C++1z [meta.unary.prop]:\n  //   remove_all_extents_t<T> shall be a complete type or cv void.\n  case UTT_IsAggregate:\n  case UTT_IsTrivial:\n  case UTT_IsTriviallyCopyable:\n  case UTT_IsStandardLayout:\n  case UTT_IsPOD:\n  case UTT_IsLiteral:\n  // Per the GCC type traits documentation, T shall be a complete type, cv void,\n  // or an array of unknown bound. But GCC actually imposes the same constraints\n  // as above.\n  case UTT_HasNothrowAssign:\n  case UTT_HasNothrowMoveAssign:\n  case UTT_HasNothrowConstructor:\n  case UTT_HasNothrowCopy:\n  case UTT_HasTrivialAssign:\n  case UTT_HasTrivialMoveAssign:\n  case UTT_HasTrivialDefaultConstructor:\n  case UTT_HasTrivialMoveConstructor:\n  case UTT_HasTrivialCopy:\n  case UTT_HasTrivialDestructor:\n  case UTT_HasVirtualDestructor:\n    ArgTy = QualType(ArgTy->getBaseElementTypeUnsafe(), 0);\n    LLVM_FALLTHROUGH;\n\n  // C++1z [meta.unary.prop]:\n  //   T shall be a complete type, cv void, or an array of unknown bound.\n  case UTT_IsDestructible:\n  case UTT_IsNothrowDestructible:\n  case UTT_IsTriviallyDestructible:\n  case UTT_HasUniqueObjectRepresentations:\n    if (ArgTy->isIncompleteArrayType() || ArgTy->isVoidType())\n      return true;\n\n    return !S.RequireCompleteType(\n        Loc, ArgTy, diag::err_incomplete_type_used_in_type_trait_expr);\n  }\n}\n\nstatic bool HasNoThrowOperator(const RecordType *RT, OverloadedOperatorKind Op,\n                               Sema &Self, SourceLocation KeyLoc, ASTContext &C,\n                               bool (CXXRecordDecl::*HasTrivial)() const,\n                               bool (CXXRecordDecl::*HasNonTrivial)() const,\n                               bool (CXXMethodDecl::*IsDesiredOp)() const)\n{\n  CXXRecordDecl *RD = cast<CXXRecordDecl>(RT->getDecl());\n  if ((RD->*HasTrivial)() && !(RD->*HasNonTrivial)())\n    return true;\n\n  DeclarationName Name = C.DeclarationNames.getCXXOperatorName(Op);\n  DeclarationNameInfo NameInfo(Name, KeyLoc);\n  LookupResult Res(Self, NameInfo, Sema::LookupOrdinaryName);\n  if (Self.LookupQualifiedName(Res, RD)) {\n    bool FoundOperator = false;\n    Res.suppressDiagnostics();\n    for (LookupResult::iterator Op = Res.begin(), OpEnd = Res.end();\n         Op != OpEnd; ++Op) {\n      if (isa<FunctionTemplateDecl>(*Op))\n        continue;\n\n      CXXMethodDecl *Operator = cast<CXXMethodDecl>(*Op);\n      if((Operator->*IsDesiredOp)()) {\n        FoundOperator = true;\n        auto *CPT = Operator->getType()->castAs<FunctionProtoType>();\n        CPT = Self.ResolveExceptionSpec(KeyLoc, CPT);\n        if (!CPT || !CPT->isNothrow())\n          return false;\n      }\n    }\n    return FoundOperator;\n  }\n  return false;\n}\n\nstatic bool EvaluateUnaryTypeTrait(Sema &Self, TypeTrait UTT,\n                                   SourceLocation KeyLoc, QualType T) {\n  assert(!T->isDependentType() && \"Cannot evaluate traits of dependent type\");\n\n  ASTContext &C = Self.Context;\n  switch(UTT) {\n  default: llvm_unreachable(\"not a UTT\");\n    // Type trait expressions corresponding to the primary type category\n    // predicates in C++0x [meta.unary.cat].\n  case UTT_IsVoid:\n    return T->isVoidType();\n  case UTT_IsIntegral:\n    return T->isIntegralType(C);\n  case UTT_IsFloatingPoint:\n    return T->isFloatingType();\n  case UTT_IsArray:\n    return T->isArrayType();\n  case UTT_IsPointer:\n    return T->isAnyPointerType();\n  case UTT_IsLvalueReference:\n    return T->isLValueReferenceType();\n  case UTT_IsRvalueReference:\n    return T->isRValueReferenceType();\n  case UTT_IsMemberFunctionPointer:\n    return T->isMemberFunctionPointerType();\n  case UTT_IsMemberObjectPointer:\n    return T->isMemberDataPointerType();\n  case UTT_IsEnum:\n    return T->isEnumeralType();\n  case UTT_IsUnion:\n    return T->isUnionType();\n  case UTT_IsClass:\n    return T->isClassType() || T->isStructureType() || T->isInterfaceType();\n  case UTT_IsFunction:\n    return T->isFunctionType();\n\n    // Type trait expressions which correspond to the convenient composition\n    // predicates in C++0x [meta.unary.comp].\n  case UTT_IsReference:\n    return T->isReferenceType();\n  case UTT_IsArithmetic:\n    return T->isArithmeticType() && !T->isEnumeralType();\n  case UTT_IsFundamental:\n    return T->isFundamentalType();\n  case UTT_IsObject:\n    return T->isObjectType();\n  case UTT_IsScalar:\n    // Note: semantic analysis depends on Objective-C lifetime types to be\n    // considered scalar types. However, such types do not actually behave\n    // like scalar types at run time (since they may require retain/release\n    // operations), so we report them as non-scalar.\n    if (T->isObjCLifetimeType()) {\n      switch (T.getObjCLifetime()) {\n      case Qualifiers::OCL_None:\n      case Qualifiers::OCL_ExplicitNone:\n        return true;\n\n      case Qualifiers::OCL_Strong:\n      case Qualifiers::OCL_Weak:\n      case Qualifiers::OCL_Autoreleasing:\n        return false;\n      }\n    }\n\n    return T->isScalarType();\n  case UTT_IsCompound:\n    return T->isCompoundType();\n  case UTT_IsMemberPointer:\n    return T->isMemberPointerType();\n\n    // Type trait expressions which correspond to the type property predicates\n    // in C++0x [meta.unary.prop].\n  case UTT_IsConst:\n    return T.isConstQualified();\n  case UTT_IsVolatile:\n    return T.isVolatileQualified();\n  case UTT_IsTrivial:\n    return T.isTrivialType(C);\n  case UTT_IsTriviallyCopyable:\n    return T.isTriviallyCopyableType(C);\n  case UTT_IsStandardLayout:\n    return T->isStandardLayoutType();\n  case UTT_IsPOD:\n    return T.isPODType(C);\n  case UTT_IsLiteral:\n    return T->isLiteralType(C);\n  case UTT_IsEmpty:\n    if (const CXXRecordDecl *RD = T->getAsCXXRecordDecl())\n      return !RD->isUnion() && RD->isEmpty();\n    return false;\n  case UTT_IsPolymorphic:\n    if (const CXXRecordDecl *RD = T->getAsCXXRecordDecl())\n      return !RD->isUnion() && RD->isPolymorphic();\n    return false;\n  case UTT_IsAbstract:\n    if (const CXXRecordDecl *RD = T->getAsCXXRecordDecl())\n      return !RD->isUnion() && RD->isAbstract();\n    return false;\n  case UTT_IsAggregate:\n    // Report vector extensions and complex types as aggregates because they\n    // support aggregate initialization. GCC mirrors this behavior for vectors\n    // but not _Complex.\n    return T->isAggregateType() || T->isVectorType() || T->isExtVectorType() ||\n           T->isAnyComplexType();\n  // __is_interface_class only returns true when CL is invoked in /CLR mode and\n  // even then only when it is used with the 'interface struct ...' syntax\n  // Clang doesn't support /CLR which makes this type trait moot.\n  case UTT_IsInterfaceClass:\n    return false;\n  case UTT_IsFinal:\n  case UTT_IsSealed:\n    if (const CXXRecordDecl *RD = T->getAsCXXRecordDecl())\n      return RD->hasAttr<FinalAttr>();\n    return false;\n  case UTT_IsSigned:\n    // Enum types should always return false.\n    // Floating points should always return true.\n    return T->isFloatingType() ||\n           (T->isSignedIntegerType() && !T->isEnumeralType());\n  case UTT_IsUnsigned:\n    // Enum types should always return false.\n    return T->isUnsignedIntegerType() && !T->isEnumeralType();\n\n    // Type trait expressions which query classes regarding their construction,\n    // destruction, and copying. Rather than being based directly on the\n    // related type predicates in the standard, they are specified by both\n    // GCC[1] and the Embarcadero C++ compiler[2], and Clang implements those\n    // specifications.\n    //\n    //   1: http://gcc.gnu/.org/onlinedocs/gcc/Type-Traits.html\n    //   2: http://docwiki.embarcadero.com/RADStudio/XE/en/Type_Trait_Functions_(C%2B%2B0x)_Index\n    //\n    // Note that these builtins do not behave as documented in g++: if a class\n    // has both a trivial and a non-trivial special member of a particular kind,\n    // they return false! For now, we emulate this behavior.\n    // FIXME: This appears to be a g++ bug: more complex cases reveal that it\n    // does not correctly compute triviality in the presence of multiple special\n    // members of the same kind. Revisit this once the g++ bug is fixed.\n  case UTT_HasTrivialDefaultConstructor:\n    // http://gcc.gnu.org/onlinedocs/gcc/Type-Traits.html:\n    //   If __is_pod (type) is true then the trait is true, else if type is\n    //   a cv class or union type (or array thereof) with a trivial default\n    //   constructor ([class.ctor]) then the trait is true, else it is false.\n    if (T.isPODType(C))\n      return true;\n    if (CXXRecordDecl *RD = C.getBaseElementType(T)->getAsCXXRecordDecl())\n      return RD->hasTrivialDefaultConstructor() &&\n             !RD->hasNonTrivialDefaultConstructor();\n    return false;\n  case UTT_HasTrivialMoveConstructor:\n    //  This trait is implemented by MSVC 2012 and needed to parse the\n    //  standard library headers. Specifically this is used as the logic\n    //  behind std::is_trivially_move_constructible (20.9.4.3).\n    if (T.isPODType(C))\n      return true;\n    if (CXXRecordDecl *RD = C.getBaseElementType(T)->getAsCXXRecordDecl())\n      return RD->hasTrivialMoveConstructor() && !RD->hasNonTrivialMoveConstructor();\n    return false;\n  case UTT_HasTrivialCopy:\n    // http://gcc.gnu.org/onlinedocs/gcc/Type-Traits.html:\n    //   If __is_pod (type) is true or type is a reference type then\n    //   the trait is true, else if type is a cv class or union type\n    //   with a trivial copy constructor ([class.copy]) then the trait\n    //   is true, else it is false.\n    if (T.isPODType(C) || T->isReferenceType())\n      return true;\n    if (CXXRecordDecl *RD = T->getAsCXXRecordDecl())\n      return RD->hasTrivialCopyConstructor() &&\n             !RD->hasNonTrivialCopyConstructor();\n    return false;\n  case UTT_HasTrivialMoveAssign:\n    //  This trait is implemented by MSVC 2012 and needed to parse the\n    //  standard library headers. Specifically it is used as the logic\n    //  behind std::is_trivially_move_assignable (20.9.4.3)\n    if (T.isPODType(C))\n      return true;\n    if (CXXRecordDecl *RD = C.getBaseElementType(T)->getAsCXXRecordDecl())\n      return RD->hasTrivialMoveAssignment() && !RD->hasNonTrivialMoveAssignment();\n    return false;\n  case UTT_HasTrivialAssign:\n    // http://gcc.gnu.org/onlinedocs/gcc/Type-Traits.html:\n    //   If type is const qualified or is a reference type then the\n    //   trait is false. Otherwise if __is_pod (type) is true then the\n    //   trait is true, else if type is a cv class or union type with\n    //   a trivial copy assignment ([class.copy]) then the trait is\n    //   true, else it is false.\n    // Note: the const and reference restrictions are interesting,\n    // given that const and reference members don't prevent a class\n    // from having a trivial copy assignment operator (but do cause\n    // errors if the copy assignment operator is actually used, q.v.\n    // [class.copy]p12).\n\n    if (T.isConstQualified())\n      return false;\n    if (T.isPODType(C))\n      return true;\n    if (CXXRecordDecl *RD = T->getAsCXXRecordDecl())\n      return RD->hasTrivialCopyAssignment() &&\n             !RD->hasNonTrivialCopyAssignment();\n    return false;\n  case UTT_IsDestructible:\n  case UTT_IsTriviallyDestructible:\n  case UTT_IsNothrowDestructible:\n    // C++14 [meta.unary.prop]:\n    //   For reference types, is_destructible<T>::value is true.\n    if (T->isReferenceType())\n      return true;\n\n    // Objective-C++ ARC: autorelease types don't require destruction.\n    if (T->isObjCLifetimeType() &&\n        T.getObjCLifetime() == Qualifiers::OCL_Autoreleasing)\n      return true;\n\n    // C++14 [meta.unary.prop]:\n    //   For incomplete types and function types, is_destructible<T>::value is\n    //   false.\n    if (T->isIncompleteType() || T->isFunctionType())\n      return false;\n\n    // A type that requires destruction (via a non-trivial destructor or ARC\n    // lifetime semantics) is not trivially-destructible.\n    if (UTT == UTT_IsTriviallyDestructible && T.isDestructedType())\n      return false;\n\n    // C++14 [meta.unary.prop]:\n    //   For object types and given U equal to remove_all_extents_t<T>, if the\n    //   expression std::declval<U&>().~U() is well-formed when treated as an\n    //   unevaluated operand (Clause 5), then is_destructible<T>::value is true\n    if (auto *RD = C.getBaseElementType(T)->getAsCXXRecordDecl()) {\n      CXXDestructorDecl *Destructor = Self.LookupDestructor(RD);\n      if (!Destructor)\n        return false;\n      //  C++14 [dcl.fct.def.delete]p2:\n      //    A program that refers to a deleted function implicitly or\n      //    explicitly, other than to declare it, is ill-formed.\n      if (Destructor->isDeleted())\n        return false;\n      if (C.getLangOpts().AccessControl && Destructor->getAccess() != AS_public)\n        return false;\n      if (UTT == UTT_IsNothrowDestructible) {\n        auto *CPT = Destructor->getType()->castAs<FunctionProtoType>();\n        CPT = Self.ResolveExceptionSpec(KeyLoc, CPT);\n        if (!CPT || !CPT->isNothrow())\n          return false;\n      }\n    }\n    return true;\n\n  case UTT_HasTrivialDestructor:\n    // http://gcc.gnu.org/onlinedocs/gcc/Type-Traits.html\n    //   If __is_pod (type) is true or type is a reference type\n    //   then the trait is true, else if type is a cv class or union\n    //   type (or array thereof) with a trivial destructor\n    //   ([class.dtor]) then the trait is true, else it is\n    //   false.\n    if (T.isPODType(C) || T->isReferenceType())\n      return true;\n\n    // Objective-C++ ARC: autorelease types don't require destruction.\n    if (T->isObjCLifetimeType() &&\n        T.getObjCLifetime() == Qualifiers::OCL_Autoreleasing)\n      return true;\n\n    if (CXXRecordDecl *RD = C.getBaseElementType(T)->getAsCXXRecordDecl())\n      return RD->hasTrivialDestructor();\n    return false;\n  // TODO: Propagate nothrowness for implicitly declared special members.\n  case UTT_HasNothrowAssign:\n    // http://gcc.gnu.org/onlinedocs/gcc/Type-Traits.html:\n    //   If type is const qualified or is a reference type then the\n    //   trait is false. Otherwise if __has_trivial_assign (type)\n    //   is true then the trait is true, else if type is a cv class\n    //   or union type with copy assignment operators that are known\n    //   not to throw an exception then the trait is true, else it is\n    //   false.\n    if (C.getBaseElementType(T).isConstQualified())\n      return false;\n    if (T->isReferenceType())\n      return false;\n    if (T.isPODType(C) || T->isObjCLifetimeType())\n      return true;\n\n    if (const RecordType *RT = T->getAs<RecordType>())\n      return HasNoThrowOperator(RT, OO_Equal, Self, KeyLoc, C,\n                                &CXXRecordDecl::hasTrivialCopyAssignment,\n                                &CXXRecordDecl::hasNonTrivialCopyAssignment,\n                                &CXXMethodDecl::isCopyAssignmentOperator);\n    return false;\n  case UTT_HasNothrowMoveAssign:\n    //  This trait is implemented by MSVC 2012 and needed to parse the\n    //  standard library headers. Specifically this is used as the logic\n    //  behind std::is_nothrow_move_assignable (20.9.4.3).\n    if (T.isPODType(C))\n      return true;\n\n    if (const RecordType *RT = C.getBaseElementType(T)->getAs<RecordType>())\n      return HasNoThrowOperator(RT, OO_Equal, Self, KeyLoc, C,\n                                &CXXRecordDecl::hasTrivialMoveAssignment,\n                                &CXXRecordDecl::hasNonTrivialMoveAssignment,\n                                &CXXMethodDecl::isMoveAssignmentOperator);\n    return false;\n  case UTT_HasNothrowCopy:\n    // http://gcc.gnu.org/onlinedocs/gcc/Type-Traits.html:\n    //   If __has_trivial_copy (type) is true then the trait is true, else\n    //   if type is a cv class or union type with copy constructors that are\n    //   known not to throw an exception then the trait is true, else it is\n    //   false.\n    if (T.isPODType(C) || T->isReferenceType() || T->isObjCLifetimeType())\n      return true;\n    if (CXXRecordDecl *RD = T->getAsCXXRecordDecl()) {\n      if (RD->hasTrivialCopyConstructor() &&\n          !RD->hasNonTrivialCopyConstructor())\n        return true;\n\n      bool FoundConstructor = false;\n      unsigned FoundTQs;\n      for (const auto *ND : Self.LookupConstructors(RD)) {\n        // A template constructor is never a copy constructor.\n        // FIXME: However, it may actually be selected at the actual overload\n        // resolution point.\n        if (isa<FunctionTemplateDecl>(ND->getUnderlyingDecl()))\n          continue;\n        // UsingDecl itself is not a constructor\n        if (isa<UsingDecl>(ND))\n          continue;\n        auto *Constructor = cast<CXXConstructorDecl>(ND->getUnderlyingDecl());\n        if (Constructor->isCopyConstructor(FoundTQs)) {\n          FoundConstructor = true;\n          auto *CPT = Constructor->getType()->castAs<FunctionProtoType>();\n          CPT = Self.ResolveExceptionSpec(KeyLoc, CPT);\n          if (!CPT)\n            return false;\n          // TODO: check whether evaluating default arguments can throw.\n          // For now, we'll be conservative and assume that they can throw.\n          if (!CPT->isNothrow() || CPT->getNumParams() > 1)\n            return false;\n        }\n      }\n\n      return FoundConstructor;\n    }\n    return false;\n  case UTT_HasNothrowConstructor:\n    // http://gcc.gnu.org/onlinedocs/gcc/Type-Traits.html\n    //   If __has_trivial_constructor (type) is true then the trait is\n    //   true, else if type is a cv class or union type (or array\n    //   thereof) with a default constructor that is known not to\n    //   throw an exception then the trait is true, else it is false.\n    if (T.isPODType(C) || T->isObjCLifetimeType())\n      return true;\n    if (CXXRecordDecl *RD = C.getBaseElementType(T)->getAsCXXRecordDecl()) {\n      if (RD->hasTrivialDefaultConstructor() &&\n          !RD->hasNonTrivialDefaultConstructor())\n        return true;\n\n      bool FoundConstructor = false;\n      for (const auto *ND : Self.LookupConstructors(RD)) {\n        // FIXME: In C++0x, a constructor template can be a default constructor.\n        if (isa<FunctionTemplateDecl>(ND->getUnderlyingDecl()))\n          continue;\n        // UsingDecl itself is not a constructor\n        if (isa<UsingDecl>(ND))\n          continue;\n        auto *Constructor = cast<CXXConstructorDecl>(ND->getUnderlyingDecl());\n        if (Constructor->isDefaultConstructor()) {\n          FoundConstructor = true;\n          auto *CPT = Constructor->getType()->castAs<FunctionProtoType>();\n          CPT = Self.ResolveExceptionSpec(KeyLoc, CPT);\n          if (!CPT)\n            return false;\n          // FIXME: check whether evaluating default arguments can throw.\n          // For now, we'll be conservative and assume that they can throw.\n          if (!CPT->isNothrow() || CPT->getNumParams() > 0)\n            return false;\n        }\n      }\n      return FoundConstructor;\n    }\n    return false;\n  case UTT_HasVirtualDestructor:\n    // http://gcc.gnu.org/onlinedocs/gcc/Type-Traits.html:\n    //   If type is a class type with a virtual destructor ([class.dtor])\n    //   then the trait is true, else it is false.\n    if (CXXRecordDecl *RD = T->getAsCXXRecordDecl())\n      if (CXXDestructorDecl *Destructor = Self.LookupDestructor(RD))\n        return Destructor->isVirtual();\n    return false;\n\n    // These type trait expressions are modeled on the specifications for the\n    // Embarcadero C++0x type trait functions:\n    //   http://docwiki.embarcadero.com/RADStudio/XE/en/Type_Trait_Functions_(C%2B%2B0x)_Index\n  case UTT_IsCompleteType:\n    // http://docwiki.embarcadero.com/RADStudio/XE/en/Is_complete_type_(typename_T_):\n    //   Returns True if and only if T is a complete type at the point of the\n    //   function call.\n    return !T->isIncompleteType();\n  case UTT_HasUniqueObjectRepresentations:\n    return C.hasUniqueObjectRepresentations(T);\n  }\n}\n\nstatic bool EvaluateBinaryTypeTrait(Sema &Self, TypeTrait BTT, QualType LhsT,\n                                    QualType RhsT, SourceLocation KeyLoc);\n\nstatic bool evaluateTypeTrait(Sema &S, TypeTrait Kind, SourceLocation KWLoc,\n                              ArrayRef<TypeSourceInfo *> Args,\n                              SourceLocation RParenLoc) {\n  if (Kind <= UTT_Last)\n    return EvaluateUnaryTypeTrait(S, Kind, KWLoc, Args[0]->getType());\n\n  // Evaluate BTT_ReferenceBindsToTemporary alongside the IsConstructible\n  // traits to avoid duplication.\n  if (Kind <= BTT_Last && Kind != BTT_ReferenceBindsToTemporary)\n    return EvaluateBinaryTypeTrait(S, Kind, Args[0]->getType(),\n                                   Args[1]->getType(), RParenLoc);\n\n  switch (Kind) {\n  case clang::BTT_ReferenceBindsToTemporary:\n  case clang::TT_IsConstructible:\n  case clang::TT_IsNothrowConstructible:\n  case clang::TT_IsTriviallyConstructible: {\n    // C++11 [meta.unary.prop]:\n    //   is_trivially_constructible is defined as:\n    //\n    //     is_constructible<T, Args...>::value is true and the variable\n    //     definition for is_constructible, as defined below, is known to call\n    //     no operation that is not trivial.\n    //\n    //   The predicate condition for a template specialization\n    //   is_constructible<T, Args...> shall be satisfied if and only if the\n    //   following variable definition would be well-formed for some invented\n    //   variable t:\n    //\n    //     T t(create<Args>()...);\n    assert(!Args.empty());\n\n    // Precondition: T and all types in the parameter pack Args shall be\n    // complete types, (possibly cv-qualified) void, or arrays of\n    // unknown bound.\n    for (const auto *TSI : Args) {\n      QualType ArgTy = TSI->getType();\n      if (ArgTy->isVoidType() || ArgTy->isIncompleteArrayType())\n        continue;\n\n      if (S.RequireCompleteType(KWLoc, ArgTy,\n          diag::err_incomplete_type_used_in_type_trait_expr))\n        return false;\n    }\n\n    // Make sure the first argument is not incomplete nor a function type.\n    QualType T = Args[0]->getType();\n    if (T->isIncompleteType() || T->isFunctionType())\n      return false;\n\n    // Make sure the first argument is not an abstract type.\n    CXXRecordDecl *RD = T->getAsCXXRecordDecl();\n    if (RD && RD->isAbstract())\n      return false;\n\n    llvm::BumpPtrAllocator OpaqueExprAllocator;\n    SmallVector<Expr *, 2> ArgExprs;\n    ArgExprs.reserve(Args.size() - 1);\n    for (unsigned I = 1, N = Args.size(); I != N; ++I) {\n      QualType ArgTy = Args[I]->getType();\n      if (ArgTy->isObjectType() || ArgTy->isFunctionType())\n        ArgTy = S.Context.getRValueReferenceType(ArgTy);\n      ArgExprs.push_back(\n          new (OpaqueExprAllocator.Allocate<OpaqueValueExpr>())\n              OpaqueValueExpr(Args[I]->getTypeLoc().getBeginLoc(),\n                              ArgTy.getNonLValueExprType(S.Context),\n                              Expr::getValueKindForType(ArgTy)));\n    }\n\n    // Perform the initialization in an unevaluated context within a SFINAE\n    // trap at translation unit scope.\n    EnterExpressionEvaluationContext Unevaluated(\n        S, Sema::ExpressionEvaluationContext::Unevaluated);\n    Sema::SFINAETrap SFINAE(S, /*AccessCheckingSFINAE=*/true);\n    Sema::ContextRAII TUContext(S, S.Context.getTranslationUnitDecl());\n    InitializedEntity To(InitializedEntity::InitializeTemporary(Args[0]));\n    InitializationKind InitKind(InitializationKind::CreateDirect(KWLoc, KWLoc,\n                                                                 RParenLoc));\n    InitializationSequence Init(S, To, InitKind, ArgExprs);\n    if (Init.Failed())\n      return false;\n\n    ExprResult Result = Init.Perform(S, To, InitKind, ArgExprs);\n    if (Result.isInvalid() || SFINAE.hasErrorOccurred())\n      return false;\n\n    if (Kind == clang::TT_IsConstructible)\n      return true;\n\n    if (Kind == clang::BTT_ReferenceBindsToTemporary) {\n      if (!T->isReferenceType())\n        return false;\n\n      return !Init.isDirectReferenceBinding();\n    }\n\n    if (Kind == clang::TT_IsNothrowConstructible)\n      return S.canThrow(Result.get()) == CT_Cannot;\n\n    if (Kind == clang::TT_IsTriviallyConstructible) {\n      // Under Objective-C ARC and Weak, if the destination has non-trivial\n      // Objective-C lifetime, this is a non-trivial construction.\n      if (T.getNonReferenceType().hasNonTrivialObjCLifetime())\n        return false;\n\n      // The initialization succeeded; now make sure there are no non-trivial\n      // calls.\n      return !Result.get()->hasNonTrivialCall(S.Context);\n    }\n\n    llvm_unreachable(\"unhandled type trait\");\n    return false;\n  }\n    default: llvm_unreachable(\"not a TT\");\n  }\n\n  return false;\n}\n\nExprResult Sema::BuildTypeTrait(TypeTrait Kind, SourceLocation KWLoc,\n                                ArrayRef<TypeSourceInfo *> Args,\n                                SourceLocation RParenLoc) {\n  QualType ResultType = Context.getLogicalOperationType();\n\n  if (Kind <= UTT_Last && !CheckUnaryTypeTraitTypeCompleteness(\n                               *this, Kind, KWLoc, Args[0]->getType()))\n    return ExprError();\n\n  bool Dependent = false;\n  for (unsigned I = 0, N = Args.size(); I != N; ++I) {\n    if (Args[I]->getType()->isDependentType()) {\n      Dependent = true;\n      break;\n    }\n  }\n\n  bool Result = false;\n  if (!Dependent)\n    Result = evaluateTypeTrait(*this, Kind, KWLoc, Args, RParenLoc);\n\n  return TypeTraitExpr::Create(Context, ResultType, KWLoc, Kind, Args,\n                               RParenLoc, Result);\n}\n\nExprResult Sema::ActOnTypeTrait(TypeTrait Kind, SourceLocation KWLoc,\n                                ArrayRef<ParsedType> Args,\n                                SourceLocation RParenLoc) {\n  SmallVector<TypeSourceInfo *, 4> ConvertedArgs;\n  ConvertedArgs.reserve(Args.size());\n\n  for (unsigned I = 0, N = Args.size(); I != N; ++I) {\n    TypeSourceInfo *TInfo;\n    QualType T = GetTypeFromParser(Args[I], &TInfo);\n    if (!TInfo)\n      TInfo = Context.getTrivialTypeSourceInfo(T, KWLoc);\n\n    ConvertedArgs.push_back(TInfo);\n  }\n\n  return BuildTypeTrait(Kind, KWLoc, ConvertedArgs, RParenLoc);\n}\n\nstatic bool EvaluateBinaryTypeTrait(Sema &Self, TypeTrait BTT, QualType LhsT,\n                                    QualType RhsT, SourceLocation KeyLoc) {\n  assert(!LhsT->isDependentType() && !RhsT->isDependentType() &&\n         \"Cannot evaluate traits of dependent types\");\n\n  switch(BTT) {\n  case BTT_IsBaseOf: {\n    // C++0x [meta.rel]p2\n    // Base is a base class of Derived without regard to cv-qualifiers or\n    // Base and Derived are not unions and name the same class type without\n    // regard to cv-qualifiers.\n\n    const RecordType *lhsRecord = LhsT->getAs<RecordType>();\n    const RecordType *rhsRecord = RhsT->getAs<RecordType>();\n    if (!rhsRecord || !lhsRecord) {\n      const ObjCObjectType *LHSObjTy = LhsT->getAs<ObjCObjectType>();\n      const ObjCObjectType *RHSObjTy = RhsT->getAs<ObjCObjectType>();\n      if (!LHSObjTy || !RHSObjTy)\n        return false;\n\n      ObjCInterfaceDecl *BaseInterface = LHSObjTy->getInterface();\n      ObjCInterfaceDecl *DerivedInterface = RHSObjTy->getInterface();\n      if (!BaseInterface || !DerivedInterface)\n        return false;\n\n      if (Self.RequireCompleteType(\n              KeyLoc, RhsT, diag::err_incomplete_type_used_in_type_trait_expr))\n        return false;\n\n      return BaseInterface->isSuperClassOf(DerivedInterface);\n    }\n\n    assert(Self.Context.hasSameUnqualifiedType(LhsT, RhsT)\n             == (lhsRecord == rhsRecord));\n\n    // Unions are never base classes, and never have base classes.\n    // It doesn't matter if they are complete or not. See PR#41843\n    if (lhsRecord && lhsRecord->getDecl()->isUnion())\n      return false;\n    if (rhsRecord && rhsRecord->getDecl()->isUnion())\n      return false;\n\n    if (lhsRecord == rhsRecord)\n      return true;\n\n    // C++0x [meta.rel]p2:\n    //   If Base and Derived are class types and are different types\n    //   (ignoring possible cv-qualifiers) then Derived shall be a\n    //   complete type.\n    if (Self.RequireCompleteType(KeyLoc, RhsT,\n                          diag::err_incomplete_type_used_in_type_trait_expr))\n      return false;\n\n    return cast<CXXRecordDecl>(rhsRecord->getDecl())\n      ->isDerivedFrom(cast<CXXRecordDecl>(lhsRecord->getDecl()));\n  }\n  case BTT_IsSame:\n    return Self.Context.hasSameType(LhsT, RhsT);\n  case BTT_TypeCompatible: {\n    // GCC ignores cv-qualifiers on arrays for this builtin.\n    Qualifiers LhsQuals, RhsQuals;\n    QualType Lhs = Self.getASTContext().getUnqualifiedArrayType(LhsT, LhsQuals);\n    QualType Rhs = Self.getASTContext().getUnqualifiedArrayType(RhsT, RhsQuals);\n    return Self.Context.typesAreCompatible(Lhs, Rhs);\n  }\n  case BTT_IsConvertible:\n  case BTT_IsConvertibleTo: {\n    // C++0x [meta.rel]p4:\n    //   Given the following function prototype:\n    //\n    //     template <class T>\n    //       typename add_rvalue_reference<T>::type create();\n    //\n    //   the predicate condition for a template specialization\n    //   is_convertible<From, To> shall be satisfied if and only if\n    //   the return expression in the following code would be\n    //   well-formed, including any implicit conversions to the return\n    //   type of the function:\n    //\n    //     To test() {\n    //       return create<From>();\n    //     }\n    //\n    //   Access checking is performed as if in a context unrelated to To and\n    //   From. Only the validity of the immediate context of the expression\n    //   of the return-statement (including conversions to the return type)\n    //   is considered.\n    //\n    // We model the initialization as a copy-initialization of a temporary\n    // of the appropriate type, which for this expression is identical to the\n    // return statement (since NRVO doesn't apply).\n\n    // Functions aren't allowed to return function or array types.\n    if (RhsT->isFunctionType() || RhsT->isArrayType())\n      return false;\n\n    // A return statement in a void function must have void type.\n    if (RhsT->isVoidType())\n      return LhsT->isVoidType();\n\n    // A function definition requires a complete, non-abstract return type.\n    if (!Self.isCompleteType(KeyLoc, RhsT) || Self.isAbstractType(KeyLoc, RhsT))\n      return false;\n\n    // Compute the result of add_rvalue_reference.\n    if (LhsT->isObjectType() || LhsT->isFunctionType())\n      LhsT = Self.Context.getRValueReferenceType(LhsT);\n\n    // Build a fake source and destination for initialization.\n    InitializedEntity To(InitializedEntity::InitializeTemporary(RhsT));\n    OpaqueValueExpr From(KeyLoc, LhsT.getNonLValueExprType(Self.Context),\n                         Expr::getValueKindForType(LhsT));\n    Expr *FromPtr = &From;\n    InitializationKind Kind(InitializationKind::CreateCopy(KeyLoc,\n                                                           SourceLocation()));\n\n    // Perform the initialization in an unevaluated context within a SFINAE\n    // trap at translation unit scope.\n    EnterExpressionEvaluationContext Unevaluated(\n        Self, Sema::ExpressionEvaluationContext::Unevaluated);\n    Sema::SFINAETrap SFINAE(Self, /*AccessCheckingSFINAE=*/true);\n    Sema::ContextRAII TUContext(Self, Self.Context.getTranslationUnitDecl());\n    InitializationSequence Init(Self, To, Kind, FromPtr);\n    if (Init.Failed())\n      return false;\n\n    ExprResult Result = Init.Perform(Self, To, Kind, FromPtr);\n    return !Result.isInvalid() && !SFINAE.hasErrorOccurred();\n  }\n\n  case BTT_IsAssignable:\n  case BTT_IsNothrowAssignable:\n  case BTT_IsTriviallyAssignable: {\n    // C++11 [meta.unary.prop]p3:\n    //   is_trivially_assignable is defined as:\n    //     is_assignable<T, U>::value is true and the assignment, as defined by\n    //     is_assignable, is known to call no operation that is not trivial\n    //\n    //   is_assignable is defined as:\n    //     The expression declval<T>() = declval<U>() is well-formed when\n    //     treated as an unevaluated operand (Clause 5).\n    //\n    //   For both, T and U shall be complete types, (possibly cv-qualified)\n    //   void, or arrays of unknown bound.\n    if (!LhsT->isVoidType() && !LhsT->isIncompleteArrayType() &&\n        Self.RequireCompleteType(KeyLoc, LhsT,\n          diag::err_incomplete_type_used_in_type_trait_expr))\n      return false;\n    if (!RhsT->isVoidType() && !RhsT->isIncompleteArrayType() &&\n        Self.RequireCompleteType(KeyLoc, RhsT,\n          diag::err_incomplete_type_used_in_type_trait_expr))\n      return false;\n\n    // cv void is never assignable.\n    if (LhsT->isVoidType() || RhsT->isVoidType())\n      return false;\n\n    // Build expressions that emulate the effect of declval<T>() and\n    // declval<U>().\n    if (LhsT->isObjectType() || LhsT->isFunctionType())\n      LhsT = Self.Context.getRValueReferenceType(LhsT);\n    if (RhsT->isObjectType() || RhsT->isFunctionType())\n      RhsT = Self.Context.getRValueReferenceType(RhsT);\n    OpaqueValueExpr Lhs(KeyLoc, LhsT.getNonLValueExprType(Self.Context),\n                        Expr::getValueKindForType(LhsT));\n    OpaqueValueExpr Rhs(KeyLoc, RhsT.getNonLValueExprType(Self.Context),\n                        Expr::getValueKindForType(RhsT));\n\n    // Attempt the assignment in an unevaluated context within a SFINAE\n    // trap at translation unit scope.\n    EnterExpressionEvaluationContext Unevaluated(\n        Self, Sema::ExpressionEvaluationContext::Unevaluated);\n    Sema::SFINAETrap SFINAE(Self, /*AccessCheckingSFINAE=*/true);\n    Sema::ContextRAII TUContext(Self, Self.Context.getTranslationUnitDecl());\n    ExprResult Result = Self.BuildBinOp(/*S=*/nullptr, KeyLoc, BO_Assign, &Lhs,\n                                        &Rhs);\n    if (Result.isInvalid())\n      return false;\n\n    // Treat the assignment as unused for the purpose of -Wdeprecated-volatile.\n    Self.CheckUnusedVolatileAssignment(Result.get());\n\n    if (SFINAE.hasErrorOccurred())\n      return false;\n\n    if (BTT == BTT_IsAssignable)\n      return true;\n\n    if (BTT == BTT_IsNothrowAssignable)\n      return Self.canThrow(Result.get()) == CT_Cannot;\n\n    if (BTT == BTT_IsTriviallyAssignable) {\n      // Under Objective-C ARC and Weak, if the destination has non-trivial\n      // Objective-C lifetime, this is a non-trivial assignment.\n      if (LhsT.getNonReferenceType().hasNonTrivialObjCLifetime())\n        return false;\n\n      return !Result.get()->hasNonTrivialCall(Self.Context);\n    }\n\n    llvm_unreachable(\"unhandled type trait\");\n    return false;\n  }\n    default: llvm_unreachable(\"not a BTT\");\n  }\n  llvm_unreachable(\"Unknown type trait or not implemented\");\n}\n\nExprResult Sema::ActOnArrayTypeTrait(ArrayTypeTrait ATT,\n                                     SourceLocation KWLoc,\n                                     ParsedType Ty,\n                                     Expr* DimExpr,\n                                     SourceLocation RParen) {\n  TypeSourceInfo *TSInfo;\n  QualType T = GetTypeFromParser(Ty, &TSInfo);\n  if (!TSInfo)\n    TSInfo = Context.getTrivialTypeSourceInfo(T);\n\n  return BuildArrayTypeTrait(ATT, KWLoc, TSInfo, DimExpr, RParen);\n}\n\nstatic uint64_t EvaluateArrayTypeTrait(Sema &Self, ArrayTypeTrait ATT,\n                                           QualType T, Expr *DimExpr,\n                                           SourceLocation KeyLoc) {\n  assert(!T->isDependentType() && \"Cannot evaluate traits of dependent type\");\n\n  switch(ATT) {\n  case ATT_ArrayRank:\n    if (T->isArrayType()) {\n      unsigned Dim = 0;\n      while (const ArrayType *AT = Self.Context.getAsArrayType(T)) {\n        ++Dim;\n        T = AT->getElementType();\n      }\n      return Dim;\n    }\n    return 0;\n\n  case ATT_ArrayExtent: {\n    llvm::APSInt Value;\n    uint64_t Dim;\n    if (Self.VerifyIntegerConstantExpression(\n                DimExpr, &Value, diag::err_dimension_expr_not_constant_integer)\n            .isInvalid())\n      return 0;\n    if (Value.isSigned() && Value.isNegative()) {\n      Self.Diag(KeyLoc, diag::err_dimension_expr_not_constant_integer)\n        << DimExpr->getSourceRange();\n      return 0;\n    }\n    Dim = Value.getLimitedValue();\n\n    if (T->isArrayType()) {\n      unsigned D = 0;\n      bool Matched = false;\n      while (const ArrayType *AT = Self.Context.getAsArrayType(T)) {\n        if (Dim == D) {\n          Matched = true;\n          break;\n        }\n        ++D;\n        T = AT->getElementType();\n      }\n\n      if (Matched && T->isArrayType()) {\n        if (const ConstantArrayType *CAT = Self.Context.getAsConstantArrayType(T))\n          return CAT->getSize().getLimitedValue();\n      }\n    }\n    return 0;\n  }\n  }\n  llvm_unreachable(\"Unknown type trait or not implemented\");\n}\n\nExprResult Sema::BuildArrayTypeTrait(ArrayTypeTrait ATT,\n                                     SourceLocation KWLoc,\n                                     TypeSourceInfo *TSInfo,\n                                     Expr* DimExpr,\n                                     SourceLocation RParen) {\n  QualType T = TSInfo->getType();\n\n  // FIXME: This should likely be tracked as an APInt to remove any host\n  // assumptions about the width of size_t on the target.\n  uint64_t Value = 0;\n  if (!T->isDependentType())\n    Value = EvaluateArrayTypeTrait(*this, ATT, T, DimExpr, KWLoc);\n\n  // While the specification for these traits from the Embarcadero C++\n  // compiler's documentation says the return type is 'unsigned int', Clang\n  // returns 'size_t'. On Windows, the primary platform for the Embarcadero\n  // compiler, there is no difference. On several other platforms this is an\n  // important distinction.\n  return new (Context) ArrayTypeTraitExpr(KWLoc, ATT, TSInfo, Value, DimExpr,\n                                          RParen, Context.getSizeType());\n}\n\nExprResult Sema::ActOnExpressionTrait(ExpressionTrait ET,\n                                      SourceLocation KWLoc,\n                                      Expr *Queried,\n                                      SourceLocation RParen) {\n  // If error parsing the expression, ignore.\n  if (!Queried)\n    return ExprError();\n\n  ExprResult Result = BuildExpressionTrait(ET, KWLoc, Queried, RParen);\n\n  return Result;\n}\n\nstatic bool EvaluateExpressionTrait(ExpressionTrait ET, Expr *E) {\n  switch (ET) {\n  case ET_IsLValueExpr: return E->isLValue();\n  case ET_IsRValueExpr: return E->isRValue();\n  }\n  llvm_unreachable(\"Expression trait not covered by switch\");\n}\n\nExprResult Sema::BuildExpressionTrait(ExpressionTrait ET,\n                                      SourceLocation KWLoc,\n                                      Expr *Queried,\n                                      SourceLocation RParen) {\n  if (Queried->isTypeDependent()) {\n    // Delay type-checking for type-dependent expressions.\n  } else if (Queried->getType()->isPlaceholderType()) {\n    ExprResult PE = CheckPlaceholderExpr(Queried);\n    if (PE.isInvalid()) return ExprError();\n    return BuildExpressionTrait(ET, KWLoc, PE.get(), RParen);\n  }\n\n  bool Value = EvaluateExpressionTrait(ET, Queried);\n\n  return new (Context)\n      ExpressionTraitExpr(KWLoc, ET, Queried, Value, RParen, Context.BoolTy);\n}\n\nQualType Sema::CheckPointerToMemberOperands(ExprResult &LHS, ExprResult &RHS,\n                                            ExprValueKind &VK,\n                                            SourceLocation Loc,\n                                            bool isIndirect) {\n  assert(!LHS.get()->getType()->isPlaceholderType() &&\n         !RHS.get()->getType()->isPlaceholderType() &&\n         \"placeholders should have been weeded out by now\");\n\n  // The LHS undergoes lvalue conversions if this is ->*, and undergoes the\n  // temporary materialization conversion otherwise.\n  if (isIndirect)\n    LHS = DefaultLvalueConversion(LHS.get());\n  else if (LHS.get()->isRValue())\n    LHS = TemporaryMaterializationConversion(LHS.get());\n  if (LHS.isInvalid())\n    return QualType();\n\n  // The RHS always undergoes lvalue conversions.\n  RHS = DefaultLvalueConversion(RHS.get());\n  if (RHS.isInvalid()) return QualType();\n\n  const char *OpSpelling = isIndirect ? \"->*\" : \".*\";\n  // C++ 5.5p2\n  //   The binary operator .* [p3: ->*] binds its second operand, which shall\n  //   be of type \"pointer to member of T\" (where T is a completely-defined\n  //   class type) [...]\n  QualType RHSType = RHS.get()->getType();\n  const MemberPointerType *MemPtr = RHSType->getAs<MemberPointerType>();\n  if (!MemPtr) {\n    Diag(Loc, diag::err_bad_memptr_rhs)\n      << OpSpelling << RHSType << RHS.get()->getSourceRange();\n    return QualType();\n  }\n\n  QualType Class(MemPtr->getClass(), 0);\n\n  // Note: C++ [expr.mptr.oper]p2-3 says that the class type into which the\n  // member pointer points must be completely-defined. However, there is no\n  // reason for this semantic distinction, and the rule is not enforced by\n  // other compilers. Therefore, we do not check this property, as it is\n  // likely to be considered a defect.\n\n  // C++ 5.5p2\n  //   [...] to its first operand, which shall be of class T or of a class of\n  //   which T is an unambiguous and accessible base class. [p3: a pointer to\n  //   such a class]\n  QualType LHSType = LHS.get()->getType();\n  if (isIndirect) {\n    if (const PointerType *Ptr = LHSType->getAs<PointerType>())\n      LHSType = Ptr->getPointeeType();\n    else {\n      Diag(Loc, diag::err_bad_memptr_lhs)\n        << OpSpelling << 1 << LHSType\n        << FixItHint::CreateReplacement(SourceRange(Loc), \".*\");\n      return QualType();\n    }\n  }\n\n  if (!Context.hasSameUnqualifiedType(Class, LHSType)) {\n    // If we want to check the hierarchy, we need a complete type.\n    if (RequireCompleteType(Loc, LHSType, diag::err_bad_memptr_lhs,\n                            OpSpelling, (int)isIndirect)) {\n      return QualType();\n    }\n\n    if (!IsDerivedFrom(Loc, LHSType, Class)) {\n      Diag(Loc, diag::err_bad_memptr_lhs) << OpSpelling\n        << (int)isIndirect << LHS.get()->getType();\n      return QualType();\n    }\n\n    CXXCastPath BasePath;\n    if (CheckDerivedToBaseConversion(\n            LHSType, Class, Loc,\n            SourceRange(LHS.get()->getBeginLoc(), RHS.get()->getEndLoc()),\n            &BasePath))\n      return QualType();\n\n    // Cast LHS to type of use.\n    QualType UseType = Context.getQualifiedType(Class, LHSType.getQualifiers());\n    if (isIndirect)\n      UseType = Context.getPointerType(UseType);\n    ExprValueKind VK = isIndirect ? VK_RValue : LHS.get()->getValueKind();\n    LHS = ImpCastExprToType(LHS.get(), UseType, CK_DerivedToBase, VK,\n                            &BasePath);\n  }\n\n  if (isa<CXXScalarValueInitExpr>(RHS.get()->IgnoreParens())) {\n    // Diagnose use of pointer-to-member type which when used as\n    // the functional cast in a pointer-to-member expression.\n    Diag(Loc, diag::err_pointer_to_member_type) << isIndirect;\n     return QualType();\n  }\n\n  // C++ 5.5p2\n  //   The result is an object or a function of the type specified by the\n  //   second operand.\n  // The cv qualifiers are the union of those in the pointer and the left side,\n  // in accordance with 5.5p5 and 5.2.5.\n  QualType Result = MemPtr->getPointeeType();\n  Result = Context.getCVRQualifiedType(Result, LHSType.getCVRQualifiers());\n\n  // C++0x [expr.mptr.oper]p6:\n  //   In a .* expression whose object expression is an rvalue, the program is\n  //   ill-formed if the second operand is a pointer to member function with\n  //   ref-qualifier &. In a ->* expression or in a .* expression whose object\n  //   expression is an lvalue, the program is ill-formed if the second operand\n  //   is a pointer to member function with ref-qualifier &&.\n  if (const FunctionProtoType *Proto = Result->getAs<FunctionProtoType>()) {\n    switch (Proto->getRefQualifier()) {\n    case RQ_None:\n      // Do nothing\n      break;\n\n    case RQ_LValue:\n      if (!isIndirect && !LHS.get()->Classify(Context).isLValue()) {\n        // C++2a allows functions with ref-qualifier & if their cv-qualifier-seq\n        // is (exactly) 'const'.\n        if (Proto->isConst() && !Proto->isVolatile())\n          Diag(Loc, getLangOpts().CPlusPlus20\n                        ? diag::warn_cxx17_compat_pointer_to_const_ref_member_on_rvalue\n                        : diag::ext_pointer_to_const_ref_member_on_rvalue);\n        else\n          Diag(Loc, diag::err_pointer_to_member_oper_value_classify)\n              << RHSType << 1 << LHS.get()->getSourceRange();\n      }\n      break;\n\n    case RQ_RValue:\n      if (isIndirect || !LHS.get()->Classify(Context).isRValue())\n        Diag(Loc, diag::err_pointer_to_member_oper_value_classify)\n          << RHSType << 0 << LHS.get()->getSourceRange();\n      break;\n    }\n  }\n\n  // C++ [expr.mptr.oper]p6:\n  //   The result of a .* expression whose second operand is a pointer\n  //   to a data member is of the same value category as its\n  //   first operand. The result of a .* expression whose second\n  //   operand is a pointer to a member function is a prvalue. The\n  //   result of an ->* expression is an lvalue if its second operand\n  //   is a pointer to data member and a prvalue otherwise.\n  if (Result->isFunctionType()) {\n    VK = VK_RValue;\n    return Context.BoundMemberTy;\n  } else if (isIndirect) {\n    VK = VK_LValue;\n  } else {\n    VK = LHS.get()->getValueKind();\n  }\n\n  return Result;\n}\n\n/// Try to convert a type to another according to C++11 5.16p3.\n///\n/// This is part of the parameter validation for the ? operator. If either\n/// value operand is a class type, the two operands are attempted to be\n/// converted to each other. This function does the conversion in one direction.\n/// It returns true if the program is ill-formed and has already been diagnosed\n/// as such.\nstatic bool TryClassUnification(Sema &Self, Expr *From, Expr *To,\n                                SourceLocation QuestionLoc,\n                                bool &HaveConversion,\n                                QualType &ToType) {\n  HaveConversion = false;\n  ToType = To->getType();\n\n  InitializationKind Kind =\n      InitializationKind::CreateCopy(To->getBeginLoc(), SourceLocation());\n  // C++11 5.16p3\n  //   The process for determining whether an operand expression E1 of type T1\n  //   can be converted to match an operand expression E2 of type T2 is defined\n  //   as follows:\n  //   -- If E2 is an lvalue: E1 can be converted to match E2 if E1 can be\n  //      implicitly converted to type \"lvalue reference to T2\", subject to the\n  //      constraint that in the conversion the reference must bind directly to\n  //      an lvalue.\n  //   -- If E2 is an xvalue: E1 can be converted to match E2 if E1 can be\n  //      implicitly converted to the type \"rvalue reference to R2\", subject to\n  //      the constraint that the reference must bind directly.\n  if (To->isLValue() || To->isXValue()) {\n    QualType T = To->isLValue() ? Self.Context.getLValueReferenceType(ToType)\n                                : Self.Context.getRValueReferenceType(ToType);\n\n    InitializedEntity Entity = InitializedEntity::InitializeTemporary(T);\n\n    InitializationSequence InitSeq(Self, Entity, Kind, From);\n    if (InitSeq.isDirectReferenceBinding()) {\n      ToType = T;\n      HaveConversion = true;\n      return false;\n    }\n\n    if (InitSeq.isAmbiguous())\n      return InitSeq.Diagnose(Self, Entity, Kind, From);\n  }\n\n  //   -- If E2 is an rvalue, or if the conversion above cannot be done:\n  //      -- if E1 and E2 have class type, and the underlying class types are\n  //         the same or one is a base class of the other:\n  QualType FTy = From->getType();\n  QualType TTy = To->getType();\n  const RecordType *FRec = FTy->getAs<RecordType>();\n  const RecordType *TRec = TTy->getAs<RecordType>();\n  bool FDerivedFromT = FRec && TRec && FRec != TRec &&\n                       Self.IsDerivedFrom(QuestionLoc, FTy, TTy);\n  if (FRec && TRec && (FRec == TRec || FDerivedFromT ||\n                       Self.IsDerivedFrom(QuestionLoc, TTy, FTy))) {\n    //         E1 can be converted to match E2 if the class of T2 is the\n    //         same type as, or a base class of, the class of T1, and\n    //         [cv2 > cv1].\n    if (FRec == TRec || FDerivedFromT) {\n      if (TTy.isAtLeastAsQualifiedAs(FTy)) {\n        InitializedEntity Entity = InitializedEntity::InitializeTemporary(TTy);\n        InitializationSequence InitSeq(Self, Entity, Kind, From);\n        if (InitSeq) {\n          HaveConversion = true;\n          return false;\n        }\n\n        if (InitSeq.isAmbiguous())\n          return InitSeq.Diagnose(Self, Entity, Kind, From);\n      }\n    }\n\n    return false;\n  }\n\n  //     -- Otherwise: E1 can be converted to match E2 if E1 can be\n  //        implicitly converted to the type that expression E2 would have\n  //        if E2 were converted to an rvalue (or the type it has, if E2 is\n  //        an rvalue).\n  //\n  // This actually refers very narrowly to the lvalue-to-rvalue conversion, not\n  // to the array-to-pointer or function-to-pointer conversions.\n  TTy = TTy.getNonLValueExprType(Self.Context);\n\n  InitializedEntity Entity = InitializedEntity::InitializeTemporary(TTy);\n  InitializationSequence InitSeq(Self, Entity, Kind, From);\n  HaveConversion = !InitSeq.Failed();\n  ToType = TTy;\n  if (InitSeq.isAmbiguous())\n    return InitSeq.Diagnose(Self, Entity, Kind, From);\n\n  return false;\n}\n\n/// Try to find a common type for two according to C++0x 5.16p5.\n///\n/// This is part of the parameter validation for the ? operator. If either\n/// value operand is a class type, overload resolution is used to find a\n/// conversion to a common type.\nstatic bool FindConditionalOverload(Sema &Self, ExprResult &LHS, ExprResult &RHS,\n                                    SourceLocation QuestionLoc) {\n  Expr *Args[2] = { LHS.get(), RHS.get() };\n  OverloadCandidateSet CandidateSet(QuestionLoc,\n                                    OverloadCandidateSet::CSK_Operator);\n  Self.AddBuiltinOperatorCandidates(OO_Conditional, QuestionLoc, Args,\n                                    CandidateSet);\n\n  OverloadCandidateSet::iterator Best;\n  switch (CandidateSet.BestViableFunction(Self, QuestionLoc, Best)) {\n    case OR_Success: {\n      // We found a match. Perform the conversions on the arguments and move on.\n      ExprResult LHSRes = Self.PerformImplicitConversion(\n          LHS.get(), Best->BuiltinParamTypes[0], Best->Conversions[0],\n          Sema::AA_Converting);\n      if (LHSRes.isInvalid())\n        break;\n      LHS = LHSRes;\n\n      ExprResult RHSRes = Self.PerformImplicitConversion(\n          RHS.get(), Best->BuiltinParamTypes[1], Best->Conversions[1],\n          Sema::AA_Converting);\n      if (RHSRes.isInvalid())\n        break;\n      RHS = RHSRes;\n      if (Best->Function)\n        Self.MarkFunctionReferenced(QuestionLoc, Best->Function);\n      return false;\n    }\n\n    case OR_No_Viable_Function:\n\n      // Emit a better diagnostic if one of the expressions is a null pointer\n      // constant and the other is a pointer type. In this case, the user most\n      // likely forgot to take the address of the other expression.\n      if (Self.DiagnoseConditionalForNull(LHS.get(), RHS.get(), QuestionLoc))\n        return true;\n\n      Self.Diag(QuestionLoc, diag::err_typecheck_cond_incompatible_operands)\n        << LHS.get()->getType() << RHS.get()->getType()\n        << LHS.get()->getSourceRange() << RHS.get()->getSourceRange();\n      return true;\n\n    case OR_Ambiguous:\n      Self.Diag(QuestionLoc, diag::err_conditional_ambiguous_ovl)\n        << LHS.get()->getType() << RHS.get()->getType()\n        << LHS.get()->getSourceRange() << RHS.get()->getSourceRange();\n      // FIXME: Print the possible common types by printing the return types of\n      // the viable candidates.\n      break;\n\n    case OR_Deleted:\n      llvm_unreachable(\"Conditional operator has only built-in overloads\");\n  }\n  return true;\n}\n\n/// Perform an \"extended\" implicit conversion as returned by\n/// TryClassUnification.\nstatic bool ConvertForConditional(Sema &Self, ExprResult &E, QualType T) {\n  InitializedEntity Entity = InitializedEntity::InitializeTemporary(T);\n  InitializationKind Kind =\n      InitializationKind::CreateCopy(E.get()->getBeginLoc(), SourceLocation());\n  Expr *Arg = E.get();\n  InitializationSequence InitSeq(Self, Entity, Kind, Arg);\n  ExprResult Result = InitSeq.Perform(Self, Entity, Kind, Arg);\n  if (Result.isInvalid())\n    return true;\n\n  E = Result;\n  return false;\n}\n\n// Check the condition operand of ?: to see if it is valid for the GCC\n// extension.\nstatic bool isValidVectorForConditionalCondition(ASTContext &Ctx,\n                                                 QualType CondTy) {\n  if (!CondTy->isVectorType() && !CondTy->isExtVectorType())\n    return false;\n  const QualType EltTy =\n      cast<VectorType>(CondTy.getCanonicalType())->getElementType();\n  assert(!EltTy->isBooleanType() && !EltTy->isEnumeralType() &&\n         \"Vectors cant be boolean or enum types\");\n  return EltTy->isIntegralType(Ctx);\n}\n\nQualType Sema::CheckVectorConditionalTypes(ExprResult &Cond, ExprResult &LHS,\n                                           ExprResult &RHS,\n                                           SourceLocation QuestionLoc) {\n  LHS = DefaultFunctionArrayLvalueConversion(LHS.get());\n  RHS = DefaultFunctionArrayLvalueConversion(RHS.get());\n\n  QualType CondType = Cond.get()->getType();\n  const auto *CondVT = CondType->castAs<VectorType>();\n  QualType CondElementTy = CondVT->getElementType();\n  unsigned CondElementCount = CondVT->getNumElements();\n  QualType LHSType = LHS.get()->getType();\n  const auto *LHSVT = LHSType->getAs<VectorType>();\n  QualType RHSType = RHS.get()->getType();\n  const auto *RHSVT = RHSType->getAs<VectorType>();\n\n  QualType ResultType;\n\n\n  if (LHSVT && RHSVT) {\n    if (isa<ExtVectorType>(CondVT) != isa<ExtVectorType>(LHSVT)) {\n      Diag(QuestionLoc, diag::err_conditional_vector_cond_result_mismatch)\n          << /*isExtVector*/ isa<ExtVectorType>(CondVT);\n      return {};\n    }\n\n    // If both are vector types, they must be the same type.\n    if (!Context.hasSameType(LHSType, RHSType)) {\n      Diag(QuestionLoc, diag::err_conditional_vector_mismatched)\n          << LHSType << RHSType;\n      return {};\n    }\n    ResultType = LHSType;\n  } else if (LHSVT || RHSVT) {\n    ResultType = CheckVectorOperands(\n        LHS, RHS, QuestionLoc, /*isCompAssign*/ false, /*AllowBothBool*/ true,\n        /*AllowBoolConversions*/ false);\n    if (ResultType.isNull())\n      return {};\n  } else {\n    // Both are scalar.\n    QualType ResultElementTy;\n    LHSType = LHSType.getCanonicalType().getUnqualifiedType();\n    RHSType = RHSType.getCanonicalType().getUnqualifiedType();\n\n    if (Context.hasSameType(LHSType, RHSType))\n      ResultElementTy = LHSType;\n    else\n      ResultElementTy =\n          UsualArithmeticConversions(LHS, RHS, QuestionLoc, ACK_Conditional);\n\n    if (ResultElementTy->isEnumeralType()) {\n      Diag(QuestionLoc, diag::err_conditional_vector_operand_type)\n          << ResultElementTy;\n      return {};\n    }\n    if (CondType->isExtVectorType())\n      ResultType =\n          Context.getExtVectorType(ResultElementTy, CondVT->getNumElements());\n    else\n      ResultType = Context.getVectorType(\n          ResultElementTy, CondVT->getNumElements(), VectorType::GenericVector);\n\n    LHS = ImpCastExprToType(LHS.get(), ResultType, CK_VectorSplat);\n    RHS = ImpCastExprToType(RHS.get(), ResultType, CK_VectorSplat);\n  }\n\n  assert(!ResultType.isNull() && ResultType->isVectorType() &&\n         (!CondType->isExtVectorType() || ResultType->isExtVectorType()) &&\n         \"Result should have been a vector type\");\n  auto *ResultVectorTy = ResultType->castAs<VectorType>();\n  QualType ResultElementTy = ResultVectorTy->getElementType();\n  unsigned ResultElementCount = ResultVectorTy->getNumElements();\n\n  if (ResultElementCount != CondElementCount) {\n    Diag(QuestionLoc, diag::err_conditional_vector_size) << CondType\n                                                         << ResultType;\n    return {};\n  }\n\n  if (Context.getTypeSize(ResultElementTy) !=\n      Context.getTypeSize(CondElementTy)) {\n    Diag(QuestionLoc, diag::err_conditional_vector_element_size) << CondType\n                                                                 << ResultType;\n    return {};\n  }\n\n  return ResultType;\n}\n\n/// Check the operands of ?: under C++ semantics.\n///\n/// See C++ [expr.cond]. Note that LHS is never null, even for the GNU x ?: y\n/// extension. In this case, LHS == Cond. (But they're not aliases.)\n///\n/// This function also implements GCC's vector extension and the\n/// OpenCL/ext_vector_type extension for conditionals. The vector extensions\n/// permit the use of a?b:c where the type of a is that of a integer vector with\n/// the same number of elements and size as the vectors of b and c. If one of\n/// either b or c is a scalar it is implicitly converted to match the type of\n/// the vector. Otherwise the expression is ill-formed. If both b and c are\n/// scalars, then b and c are checked and converted to the type of a if\n/// possible.\n///\n/// The expressions are evaluated differently for GCC's and OpenCL's extensions.\n/// For the GCC extension, the ?: operator is evaluated as\n///   (a[0] != 0 ? b[0] : c[0], .. , a[n] != 0 ? b[n] : c[n]).\n/// For the OpenCL extensions, the ?: operator is evaluated as\n///   (most-significant-bit-set(a[0])  ? b[0] : c[0], .. ,\n///    most-significant-bit-set(a[n]) ? b[n] : c[n]).\nQualType Sema::CXXCheckConditionalOperands(ExprResult &Cond, ExprResult &LHS,\n                                           ExprResult &RHS, ExprValueKind &VK,\n                                           ExprObjectKind &OK,\n                                           SourceLocation QuestionLoc) {\n  // FIXME: Handle C99's complex types, block pointers and Obj-C++ interface\n  // pointers.\n\n  // Assume r-value.\n  VK = VK_RValue;\n  OK = OK_Ordinary;\n  bool IsVectorConditional =\n      isValidVectorForConditionalCondition(Context, Cond.get()->getType());\n\n  // C++11 [expr.cond]p1\n  //   The first expression is contextually converted to bool.\n  if (!Cond.get()->isTypeDependent()) {\n    ExprResult CondRes = IsVectorConditional\n                             ? DefaultFunctionArrayLvalueConversion(Cond.get())\n                             : CheckCXXBooleanCondition(Cond.get());\n    if (CondRes.isInvalid())\n      return QualType();\n    Cond = CondRes;\n  } else {\n    // To implement C++, the first expression typically doesn't alter the result\n    // type of the conditional, however the GCC compatible vector extension\n    // changes the result type to be that of the conditional. Since we cannot\n    // know if this is a vector extension here, delay the conversion of the\n    // LHS/RHS below until later.\n    return Context.DependentTy;\n  }\n\n\n  // Either of the arguments dependent?\n  if (LHS.get()->isTypeDependent() || RHS.get()->isTypeDependent())\n    return Context.DependentTy;\n\n  // C++11 [expr.cond]p2\n  //   If either the second or the third operand has type (cv) void, ...\n  QualType LTy = LHS.get()->getType();\n  QualType RTy = RHS.get()->getType();\n  bool LVoid = LTy->isVoidType();\n  bool RVoid = RTy->isVoidType();\n  if (LVoid || RVoid) {\n    //   ... one of the following shall hold:\n    //   -- The second or the third operand (but not both) is a (possibly\n    //      parenthesized) throw-expression; the result is of the type\n    //      and value category of the other.\n    bool LThrow = isa<CXXThrowExpr>(LHS.get()->IgnoreParenImpCasts());\n    bool RThrow = isa<CXXThrowExpr>(RHS.get()->IgnoreParenImpCasts());\n\n    // Void expressions aren't legal in the vector-conditional expressions.\n    if (IsVectorConditional) {\n      SourceRange DiagLoc =\n          LVoid ? LHS.get()->getSourceRange() : RHS.get()->getSourceRange();\n      bool IsThrow = LVoid ? LThrow : RThrow;\n      Diag(DiagLoc.getBegin(), diag::err_conditional_vector_has_void)\n          << DiagLoc << IsThrow;\n      return QualType();\n    }\n\n    if (LThrow != RThrow) {\n      Expr *NonThrow = LThrow ? RHS.get() : LHS.get();\n      VK = NonThrow->getValueKind();\n      // DR (no number yet): the result is a bit-field if the\n      // non-throw-expression operand is a bit-field.\n      OK = NonThrow->getObjectKind();\n      return NonThrow->getType();\n    }\n\n    //   -- Both the second and third operands have type void; the result is of\n    //      type void and is a prvalue.\n    if (LVoid && RVoid)\n      return Context.VoidTy;\n\n    // Neither holds, error.\n    Diag(QuestionLoc, diag::err_conditional_void_nonvoid)\n      << (LVoid ? RTy : LTy) << (LVoid ? 0 : 1)\n      << LHS.get()->getSourceRange() << RHS.get()->getSourceRange();\n    return QualType();\n  }\n\n  // Neither is void.\n  if (IsVectorConditional)\n    return CheckVectorConditionalTypes(Cond, LHS, RHS, QuestionLoc);\n\n  // C++11 [expr.cond]p3\n  //   Otherwise, if the second and third operand have different types, and\n  //   either has (cv) class type [...] an attempt is made to convert each of\n  //   those operands to the type of the other.\n  if (!Context.hasSameType(LTy, RTy) &&\n      (LTy->isRecordType() || RTy->isRecordType())) {\n    // These return true if a single direction is already ambiguous.\n    QualType L2RType, R2LType;\n    bool HaveL2R, HaveR2L;\n    if (TryClassUnification(*this, LHS.get(), RHS.get(), QuestionLoc, HaveL2R, L2RType))\n      return QualType();\n    if (TryClassUnification(*this, RHS.get(), LHS.get(), QuestionLoc, HaveR2L, R2LType))\n      return QualType();\n\n    //   If both can be converted, [...] the program is ill-formed.\n    if (HaveL2R && HaveR2L) {\n      Diag(QuestionLoc, diag::err_conditional_ambiguous)\n        << LTy << RTy << LHS.get()->getSourceRange() << RHS.get()->getSourceRange();\n      return QualType();\n    }\n\n    //   If exactly one conversion is possible, that conversion is applied to\n    //   the chosen operand and the converted operands are used in place of the\n    //   original operands for the remainder of this section.\n    if (HaveL2R) {\n      if (ConvertForConditional(*this, LHS, L2RType) || LHS.isInvalid())\n        return QualType();\n      LTy = LHS.get()->getType();\n    } else if (HaveR2L) {\n      if (ConvertForConditional(*this, RHS, R2LType) || RHS.isInvalid())\n        return QualType();\n      RTy = RHS.get()->getType();\n    }\n  }\n\n  // C++11 [expr.cond]p3\n  //   if both are glvalues of the same value category and the same type except\n  //   for cv-qualification, an attempt is made to convert each of those\n  //   operands to the type of the other.\n  // FIXME:\n  //   Resolving a defect in P0012R1: we extend this to cover all cases where\n  //   one of the operands is reference-compatible with the other, in order\n  //   to support conditionals between functions differing in noexcept. This\n  //   will similarly cover difference in array bounds after P0388R4.\n  // FIXME: If LTy and RTy have a composite pointer type, should we convert to\n  //   that instead?\n  ExprValueKind LVK = LHS.get()->getValueKind();\n  ExprValueKind RVK = RHS.get()->getValueKind();\n  if (!Context.hasSameType(LTy, RTy) &&\n      LVK == RVK && LVK != VK_RValue) {\n    // DerivedToBase was already handled by the class-specific case above.\n    // FIXME: Should we allow ObjC conversions here?\n    const ReferenceConversions AllowedConversions =\n        ReferenceConversions::Qualification |\n        ReferenceConversions::NestedQualification |\n        ReferenceConversions::Function;\n\n    ReferenceConversions RefConv;\n    if (CompareReferenceRelationship(QuestionLoc, LTy, RTy, &RefConv) ==\n            Ref_Compatible &&\n        !(RefConv & ~AllowedConversions) &&\n        // [...] subject to the constraint that the reference must bind\n        // directly [...]\n        !RHS.get()->refersToBitField() && !RHS.get()->refersToVectorElement()) {\n      RHS = ImpCastExprToType(RHS.get(), LTy, CK_NoOp, RVK);\n      RTy = RHS.get()->getType();\n    } else if (CompareReferenceRelationship(QuestionLoc, RTy, LTy, &RefConv) ==\n                   Ref_Compatible &&\n               !(RefConv & ~AllowedConversions) &&\n               !LHS.get()->refersToBitField() &&\n               !LHS.get()->refersToVectorElement()) {\n      LHS = ImpCastExprToType(LHS.get(), RTy, CK_NoOp, LVK);\n      LTy = LHS.get()->getType();\n    }\n  }\n\n  // C++11 [expr.cond]p4\n  //   If the second and third operands are glvalues of the same value\n  //   category and have the same type, the result is of that type and\n  //   value category and it is a bit-field if the second or the third\n  //   operand is a bit-field, or if both are bit-fields.\n  // We only extend this to bitfields, not to the crazy other kinds of\n  // l-values.\n  bool Same = Context.hasSameType(LTy, RTy);\n  if (Same && LVK == RVK && LVK != VK_RValue &&\n      LHS.get()->isOrdinaryOrBitFieldObject() &&\n      RHS.get()->isOrdinaryOrBitFieldObject()) {\n    VK = LHS.get()->getValueKind();\n    if (LHS.get()->getObjectKind() == OK_BitField ||\n        RHS.get()->getObjectKind() == OK_BitField)\n      OK = OK_BitField;\n\n    // If we have function pointer types, unify them anyway to unify their\n    // exception specifications, if any.\n    if (LTy->isFunctionPointerType() || LTy->isMemberFunctionPointerType()) {\n      Qualifiers Qs = LTy.getQualifiers();\n      LTy = FindCompositePointerType(QuestionLoc, LHS, RHS,\n                                     /*ConvertArgs*/false);\n      LTy = Context.getQualifiedType(LTy, Qs);\n\n      assert(!LTy.isNull() && \"failed to find composite pointer type for \"\n                              \"canonically equivalent function ptr types\");\n      assert(Context.hasSameType(LTy, RTy) && \"bad composite pointer type\");\n    }\n\n    return LTy;\n  }\n\n  // C++11 [expr.cond]p5\n  //   Otherwise, the result is a prvalue. If the second and third operands\n  //   do not have the same type, and either has (cv) class type, ...\n  if (!Same && (LTy->isRecordType() || RTy->isRecordType())) {\n    //   ... overload resolution is used to determine the conversions (if any)\n    //   to be applied to the operands. If the overload resolution fails, the\n    //   program is ill-formed.\n    if (FindConditionalOverload(*this, LHS, RHS, QuestionLoc))\n      return QualType();\n  }\n\n  // C++11 [expr.cond]p6\n  //   Lvalue-to-rvalue, array-to-pointer, and function-to-pointer standard\n  //   conversions are performed on the second and third operands.\n  LHS = DefaultFunctionArrayLvalueConversion(LHS.get());\n  RHS = DefaultFunctionArrayLvalueConversion(RHS.get());\n  if (LHS.isInvalid() || RHS.isInvalid())\n    return QualType();\n  LTy = LHS.get()->getType();\n  RTy = RHS.get()->getType();\n\n  //   After those conversions, one of the following shall hold:\n  //   -- The second and third operands have the same type; the result\n  //      is of that type. If the operands have class type, the result\n  //      is a prvalue temporary of the result type, which is\n  //      copy-initialized from either the second operand or the third\n  //      operand depending on the value of the first operand.\n  if (Context.getCanonicalType(LTy) == Context.getCanonicalType(RTy)) {\n    if (LTy->isRecordType()) {\n      // The operands have class type. Make a temporary copy.\n      InitializedEntity Entity = InitializedEntity::InitializeTemporary(LTy);\n\n      ExprResult LHSCopy = PerformCopyInitialization(Entity,\n                                                     SourceLocation(),\n                                                     LHS);\n      if (LHSCopy.isInvalid())\n        return QualType();\n\n      ExprResult RHSCopy = PerformCopyInitialization(Entity,\n                                                     SourceLocation(),\n                                                     RHS);\n      if (RHSCopy.isInvalid())\n        return QualType();\n\n      LHS = LHSCopy;\n      RHS = RHSCopy;\n    }\n\n    // If we have function pointer types, unify them anyway to unify their\n    // exception specifications, if any.\n    if (LTy->isFunctionPointerType() || LTy->isMemberFunctionPointerType()) {\n      LTy = FindCompositePointerType(QuestionLoc, LHS, RHS);\n      assert(!LTy.isNull() && \"failed to find composite pointer type for \"\n                              \"canonically equivalent function ptr types\");\n    }\n\n    return LTy;\n  }\n\n  // Extension: conditional operator involving vector types.\n  if (LTy->isVectorType() || RTy->isVectorType())\n    return CheckVectorOperands(LHS, RHS, QuestionLoc, /*isCompAssign*/false,\n                               /*AllowBothBool*/true,\n                               /*AllowBoolConversions*/false);\n\n  //   -- The second and third operands have arithmetic or enumeration type;\n  //      the usual arithmetic conversions are performed to bring them to a\n  //      common type, and the result is of that type.\n  if (LTy->isArithmeticType() && RTy->isArithmeticType()) {\n    QualType ResTy =\n        UsualArithmeticConversions(LHS, RHS, QuestionLoc, ACK_Conditional);\n    if (LHS.isInvalid() || RHS.isInvalid())\n      return QualType();\n    if (ResTy.isNull()) {\n      Diag(QuestionLoc,\n           diag::err_typecheck_cond_incompatible_operands) << LTy << RTy\n        << LHS.get()->getSourceRange() << RHS.get()->getSourceRange();\n      return QualType();\n    }\n\n    LHS = ImpCastExprToType(LHS.get(), ResTy, PrepareScalarCast(LHS, ResTy));\n    RHS = ImpCastExprToType(RHS.get(), ResTy, PrepareScalarCast(RHS, ResTy));\n\n    return ResTy;\n  }\n\n  //   -- The second and third operands have pointer type, or one has pointer\n  //      type and the other is a null pointer constant, or both are null\n  //      pointer constants, at least one of which is non-integral; pointer\n  //      conversions and qualification conversions are performed to bring them\n  //      to their composite pointer type. The result is of the composite\n  //      pointer type.\n  //   -- The second and third operands have pointer to member type, or one has\n  //      pointer to member type and the other is a null pointer constant;\n  //      pointer to member conversions and qualification conversions are\n  //      performed to bring them to a common type, whose cv-qualification\n  //      shall match the cv-qualification of either the second or the third\n  //      operand. The result is of the common type.\n  QualType Composite = FindCompositePointerType(QuestionLoc, LHS, RHS);\n  if (!Composite.isNull())\n    return Composite;\n\n  // Similarly, attempt to find composite type of two objective-c pointers.\n  Composite = FindCompositeObjCPointerType(LHS, RHS, QuestionLoc);\n  if (LHS.isInvalid() || RHS.isInvalid())\n    return QualType();\n  if (!Composite.isNull())\n    return Composite;\n\n  // Check if we are using a null with a non-pointer type.\n  if (DiagnoseConditionalForNull(LHS.get(), RHS.get(), QuestionLoc))\n    return QualType();\n\n  Diag(QuestionLoc, diag::err_typecheck_cond_incompatible_operands)\n    << LHS.get()->getType() << RHS.get()->getType()\n    << LHS.get()->getSourceRange() << RHS.get()->getSourceRange();\n  return QualType();\n}\n\nstatic FunctionProtoType::ExceptionSpecInfo\nmergeExceptionSpecs(Sema &S, FunctionProtoType::ExceptionSpecInfo ESI1,\n                    FunctionProtoType::ExceptionSpecInfo ESI2,\n                    SmallVectorImpl<QualType> &ExceptionTypeStorage) {\n  ExceptionSpecificationType EST1 = ESI1.Type;\n  ExceptionSpecificationType EST2 = ESI2.Type;\n\n  // If either of them can throw anything, that is the result.\n  if (EST1 == EST_None) return ESI1;\n  if (EST2 == EST_None) return ESI2;\n  if (EST1 == EST_MSAny) return ESI1;\n  if (EST2 == EST_MSAny) return ESI2;\n  if (EST1 == EST_NoexceptFalse) return ESI1;\n  if (EST2 == EST_NoexceptFalse) return ESI2;\n\n  // If either of them is non-throwing, the result is the other.\n  if (EST1 == EST_NoThrow) return ESI2;\n  if (EST2 == EST_NoThrow) return ESI1;\n  if (EST1 == EST_DynamicNone) return ESI2;\n  if (EST2 == EST_DynamicNone) return ESI1;\n  if (EST1 == EST_BasicNoexcept) return ESI2;\n  if (EST2 == EST_BasicNoexcept) return ESI1;\n  if (EST1 == EST_NoexceptTrue) return ESI2;\n  if (EST2 == EST_NoexceptTrue) return ESI1;\n\n  // If we're left with value-dependent computed noexcept expressions, we're\n  // stuck. Before C++17, we can just drop the exception specification entirely,\n  // since it's not actually part of the canonical type. And this should never\n  // happen in C++17, because it would mean we were computing the composite\n  // pointer type of dependent types, which should never happen.\n  if (EST1 == EST_DependentNoexcept || EST2 == EST_DependentNoexcept) {\n    assert(!S.getLangOpts().CPlusPlus17 &&\n           \"computing composite pointer type of dependent types\");\n    return FunctionProtoType::ExceptionSpecInfo();\n  }\n\n  // Switch over the possibilities so that people adding new values know to\n  // update this function.\n  switch (EST1) {\n  case EST_None:\n  case EST_DynamicNone:\n  case EST_MSAny:\n  case EST_BasicNoexcept:\n  case EST_DependentNoexcept:\n  case EST_NoexceptFalse:\n  case EST_NoexceptTrue:\n  case EST_NoThrow:\n    llvm_unreachable(\"handled above\");\n\n  case EST_Dynamic: {\n    // This is the fun case: both exception specifications are dynamic. Form\n    // the union of the two lists.\n    assert(EST2 == EST_Dynamic && \"other cases should already be handled\");\n    llvm::SmallPtrSet<QualType, 8> Found;\n    for (auto &Exceptions : {ESI1.Exceptions, ESI2.Exceptions})\n      for (QualType E : Exceptions)\n        if (Found.insert(S.Context.getCanonicalType(E)).second)\n          ExceptionTypeStorage.push_back(E);\n\n    FunctionProtoType::ExceptionSpecInfo Result(EST_Dynamic);\n    Result.Exceptions = ExceptionTypeStorage;\n    return Result;\n  }\n\n  case EST_Unevaluated:\n  case EST_Uninstantiated:\n  case EST_Unparsed:\n    llvm_unreachable(\"shouldn't see unresolved exception specifications here\");\n  }\n\n  llvm_unreachable(\"invalid ExceptionSpecificationType\");\n}\n\n/// Find a merged pointer type and convert the two expressions to it.\n///\n/// This finds the composite pointer type for \\p E1 and \\p E2 according to\n/// C++2a [expr.type]p3. It converts both expressions to this type and returns\n/// it.  It does not emit diagnostics (FIXME: that's not true if \\p ConvertArgs\n/// is \\c true).\n///\n/// \\param Loc The location of the operator requiring these two expressions to\n/// be converted to the composite pointer type.\n///\n/// \\param ConvertArgs If \\c false, do not convert E1 and E2 to the target type.\nQualType Sema::FindCompositePointerType(SourceLocation Loc,\n                                        Expr *&E1, Expr *&E2,\n                                        bool ConvertArgs) {\n  assert(getLangOpts().CPlusPlus && \"This function assumes C++\");\n\n  // C++1z [expr]p14:\n  //   The composite pointer type of two operands p1 and p2 having types T1\n  //   and T2\n  QualType T1 = E1->getType(), T2 = E2->getType();\n\n  //   where at least one is a pointer or pointer to member type or\n  //   std::nullptr_t is:\n  bool T1IsPointerLike = T1->isAnyPointerType() || T1->isMemberPointerType() ||\n                         T1->isNullPtrType();\n  bool T2IsPointerLike = T2->isAnyPointerType() || T2->isMemberPointerType() ||\n                         T2->isNullPtrType();\n  if (!T1IsPointerLike && !T2IsPointerLike)\n    return QualType();\n\n  //   - if both p1 and p2 are null pointer constants, std::nullptr_t;\n  // This can't actually happen, following the standard, but we also use this\n  // to implement the end of [expr.conv], which hits this case.\n  //\n  //   - if either p1 or p2 is a null pointer constant, T2 or T1, respectively;\n  if (T1IsPointerLike &&\n      E2->isNullPointerConstant(Context, Expr::NPC_ValueDependentIsNull)) {\n    if (ConvertArgs)\n      E2 = ImpCastExprToType(E2, T1, T1->isMemberPointerType()\n                                         ? CK_NullToMemberPointer\n                                         : CK_NullToPointer).get();\n    return T1;\n  }\n  if (T2IsPointerLike &&\n      E1->isNullPointerConstant(Context, Expr::NPC_ValueDependentIsNull)) {\n    if (ConvertArgs)\n      E1 = ImpCastExprToType(E1, T2, T2->isMemberPointerType()\n                                         ? CK_NullToMemberPointer\n                                         : CK_NullToPointer).get();\n    return T2;\n  }\n\n  // Now both have to be pointers or member pointers.\n  if (!T1IsPointerLike || !T2IsPointerLike)\n    return QualType();\n  assert(!T1->isNullPtrType() && !T2->isNullPtrType() &&\n         \"nullptr_t should be a null pointer constant\");\n\n  struct Step {\n    enum Kind { Pointer, ObjCPointer, MemberPointer, Array } K;\n    // Qualifiers to apply under the step kind.\n    Qualifiers Quals;\n    /// The class for a pointer-to-member; a constant array type with a bound\n    /// (if any) for an array.\n    const Type *ClassOrBound;\n\n    Step(Kind K, const Type *ClassOrBound = nullptr)\n        : K(K), Quals(), ClassOrBound(ClassOrBound) {}\n    QualType rebuild(ASTContext &Ctx, QualType T) const {\n      T = Ctx.getQualifiedType(T, Quals);\n      switch (K) {\n      case Pointer:\n        return Ctx.getPointerType(T);\n      case MemberPointer:\n        return Ctx.getMemberPointerType(T, ClassOrBound);\n      case ObjCPointer:\n        return Ctx.getObjCObjectPointerType(T);\n      case Array:\n        if (auto *CAT = cast_or_null<ConstantArrayType>(ClassOrBound))\n          return Ctx.getConstantArrayType(T, CAT->getSize(), nullptr,\n                                          ArrayType::Normal, 0);\n        else\n          return Ctx.getIncompleteArrayType(T, ArrayType::Normal, 0);\n      }\n      llvm_unreachable(\"unknown step kind\");\n    }\n  };\n\n  SmallVector<Step, 8> Steps;\n\n  //  - if T1 is \"pointer to cv1 C1\" and T2 is \"pointer to cv2 C2\", where C1\n  //    is reference-related to C2 or C2 is reference-related to C1 (8.6.3),\n  //    the cv-combined type of T1 and T2 or the cv-combined type of T2 and T1,\n  //    respectively;\n  //  - if T1 is \"pointer to member of C1 of type cv1 U1\" and T2 is \"pointer\n  //    to member of C2 of type cv2 U2\" for some non-function type U, where\n  //    C1 is reference-related to C2 or C2 is reference-related to C1, the\n  //    cv-combined type of T2 and T1 or the cv-combined type of T1 and T2,\n  //    respectively;\n  //  - if T1 and T2 are similar types (4.5), the cv-combined type of T1 and\n  //    T2;\n  //\n  // Dismantle T1 and T2 to simultaneously determine whether they are similar\n  // and to prepare to form the cv-combined type if so.\n  QualType Composite1 = T1;\n  QualType Composite2 = T2;\n  unsigned NeedConstBefore = 0;\n  while (true) {\n    assert(!Composite1.isNull() && !Composite2.isNull());\n\n    Qualifiers Q1, Q2;\n    Composite1 = Context.getUnqualifiedArrayType(Composite1, Q1);\n    Composite2 = Context.getUnqualifiedArrayType(Composite2, Q2);\n\n    // Top-level qualifiers are ignored. Merge at all lower levels.\n    if (!Steps.empty()) {\n      // Find the qualifier union: (approximately) the unique minimal set of\n      // qualifiers that is compatible with both types.\n      Qualifiers Quals = Qualifiers::fromCVRUMask(Q1.getCVRUQualifiers() |\n                                                  Q2.getCVRUQualifiers());\n\n      // Under one level of pointer or pointer-to-member, we can change to an\n      // unambiguous compatible address space.\n      if (Q1.getAddressSpace() == Q2.getAddressSpace()) {\n        Quals.setAddressSpace(Q1.getAddressSpace());\n      } else if (Steps.size() == 1) {\n        bool MaybeQ1 = Q1.isAddressSpaceSupersetOf(Q2);\n        bool MaybeQ2 = Q2.isAddressSpaceSupersetOf(Q1);\n        if (MaybeQ1 == MaybeQ2)\n          return QualType(); // No unique best address space.\n        Quals.setAddressSpace(MaybeQ1 ? Q1.getAddressSpace()\n                                      : Q2.getAddressSpace());\n      } else {\n        return QualType();\n      }\n\n      // FIXME: In C, we merge __strong and none to __strong at the top level.\n      if (Q1.getObjCGCAttr() == Q2.getObjCGCAttr())\n        Quals.setObjCGCAttr(Q1.getObjCGCAttr());\n      else if (T1->isVoidPointerType() || T2->isVoidPointerType())\n        assert(Steps.size() == 1);\n      else\n        return QualType();\n\n      // Mismatched lifetime qualifiers never compatibly include each other.\n      if (Q1.getObjCLifetime() == Q2.getObjCLifetime())\n        Quals.setObjCLifetime(Q1.getObjCLifetime());\n      else if (T1->isVoidPointerType() || T2->isVoidPointerType())\n        assert(Steps.size() == 1);\n      else\n        return QualType();\n\n      Steps.back().Quals = Quals;\n      if (Q1 != Quals || Q2 != Quals)\n        NeedConstBefore = Steps.size() - 1;\n    }\n\n    // FIXME: Can we unify the following with UnwrapSimilarTypes?\n    const PointerType *Ptr1, *Ptr2;\n    if ((Ptr1 = Composite1->getAs<PointerType>()) &&\n        (Ptr2 = Composite2->getAs<PointerType>())) {\n      Composite1 = Ptr1->getPointeeType();\n      Composite2 = Ptr2->getPointeeType();\n      Steps.emplace_back(Step::Pointer);\n      continue;\n    }\n\n    const ObjCObjectPointerType *ObjPtr1, *ObjPtr2;\n    if ((ObjPtr1 = Composite1->getAs<ObjCObjectPointerType>()) &&\n        (ObjPtr2 = Composite2->getAs<ObjCObjectPointerType>())) {\n      Composite1 = ObjPtr1->getPointeeType();\n      Composite2 = ObjPtr2->getPointeeType();\n      Steps.emplace_back(Step::ObjCPointer);\n      continue;\n    }\n\n    const MemberPointerType *MemPtr1, *MemPtr2;\n    if ((MemPtr1 = Composite1->getAs<MemberPointerType>()) &&\n        (MemPtr2 = Composite2->getAs<MemberPointerType>())) {\n      Composite1 = MemPtr1->getPointeeType();\n      Composite2 = MemPtr2->getPointeeType();\n\n      // At the top level, we can perform a base-to-derived pointer-to-member\n      // conversion:\n      //\n      //  - [...] where C1 is reference-related to C2 or C2 is\n      //    reference-related to C1\n      //\n      // (Note that the only kinds of reference-relatedness in scope here are\n      // \"same type or derived from\".) At any other level, the class must\n      // exactly match.\n      const Type *Class = nullptr;\n      QualType Cls1(MemPtr1->getClass(), 0);\n      QualType Cls2(MemPtr2->getClass(), 0);\n      if (Context.hasSameType(Cls1, Cls2))\n        Class = MemPtr1->getClass();\n      else if (Steps.empty())\n        Class = IsDerivedFrom(Loc, Cls1, Cls2) ? MemPtr1->getClass() :\n                IsDerivedFrom(Loc, Cls2, Cls1) ? MemPtr2->getClass() : nullptr;\n      if (!Class)\n        return QualType();\n\n      Steps.emplace_back(Step::MemberPointer, Class);\n      continue;\n    }\n\n    // Special case: at the top level, we can decompose an Objective-C pointer\n    // and a 'cv void *'. Unify the qualifiers.\n    if (Steps.empty() && ((Composite1->isVoidPointerType() &&\n                           Composite2->isObjCObjectPointerType()) ||\n                          (Composite1->isObjCObjectPointerType() &&\n                           Composite2->isVoidPointerType()))) {\n      Composite1 = Composite1->getPointeeType();\n      Composite2 = Composite2->getPointeeType();\n      Steps.emplace_back(Step::Pointer);\n      continue;\n    }\n\n    // FIXME: arrays\n\n    // FIXME: block pointer types?\n\n    // Cannot unwrap any more types.\n    break;\n  }\n\n  //  - if T1 or T2 is \"pointer to noexcept function\" and the other type is\n  //    \"pointer to function\", where the function types are otherwise the same,\n  //    \"pointer to function\";\n  //  - if T1 or T2 is \"pointer to member of C1 of type function\", the other\n  //    type is \"pointer to member of C2 of type noexcept function\", and C1\n  //    is reference-related to C2 or C2 is reference-related to C1, where\n  //    the function types are otherwise the same, \"pointer to member of C2 of\n  //    type function\" or \"pointer to member of C1 of type function\",\n  //    respectively;\n  //\n  // We also support 'noreturn' here, so as a Clang extension we generalize the\n  // above to:\n  //\n  //  - [Clang] If T1 and T2 are both of type \"pointer to function\" or\n  //    \"pointer to member function\" and the pointee types can be unified\n  //    by a function pointer conversion, that conversion is applied\n  //    before checking the following rules.\n  //\n  // We've already unwrapped down to the function types, and we want to merge\n  // rather than just convert, so do this ourselves rather than calling\n  // IsFunctionConversion.\n  //\n  // FIXME: In order to match the standard wording as closely as possible, we\n  // currently only do this under a single level of pointers. Ideally, we would\n  // allow this in general, and set NeedConstBefore to the relevant depth on\n  // the side(s) where we changed anything. If we permit that, we should also\n  // consider this conversion when determining type similarity and model it as\n  // a qualification conversion.\n  if (Steps.size() == 1) {\n    if (auto *FPT1 = Composite1->getAs<FunctionProtoType>()) {\n      if (auto *FPT2 = Composite2->getAs<FunctionProtoType>()) {\n        FunctionProtoType::ExtProtoInfo EPI1 = FPT1->getExtProtoInfo();\n        FunctionProtoType::ExtProtoInfo EPI2 = FPT2->getExtProtoInfo();\n\n        // The result is noreturn if both operands are.\n        bool Noreturn =\n            EPI1.ExtInfo.getNoReturn() && EPI2.ExtInfo.getNoReturn();\n        EPI1.ExtInfo = EPI1.ExtInfo.withNoReturn(Noreturn);\n        EPI2.ExtInfo = EPI2.ExtInfo.withNoReturn(Noreturn);\n\n        // The result is nothrow if both operands are.\n        SmallVector<QualType, 8> ExceptionTypeStorage;\n        EPI1.ExceptionSpec = EPI2.ExceptionSpec =\n            mergeExceptionSpecs(*this, EPI1.ExceptionSpec, EPI2.ExceptionSpec,\n                                ExceptionTypeStorage);\n\n        Composite1 = Context.getFunctionType(FPT1->getReturnType(),\n                                             FPT1->getParamTypes(), EPI1);\n        Composite2 = Context.getFunctionType(FPT2->getReturnType(),\n                                             FPT2->getParamTypes(), EPI2);\n      }\n    }\n  }\n\n  // There are some more conversions we can perform under exactly one pointer.\n  if (Steps.size() == 1 && Steps.front().K == Step::Pointer &&\n      !Context.hasSameType(Composite1, Composite2)) {\n    //  - if T1 or T2 is \"pointer to cv1 void\" and the other type is\n    //    \"pointer to cv2 T\", where T is an object type or void,\n    //    \"pointer to cv12 void\", where cv12 is the union of cv1 and cv2;\n    if (Composite1->isVoidType() && Composite2->isObjectType())\n      Composite2 = Composite1;\n    else if (Composite2->isVoidType() && Composite1->isObjectType())\n      Composite1 = Composite2;\n    //  - if T1 is \"pointer to cv1 C1\" and T2 is \"pointer to cv2 C2\", where C1\n    //    is reference-related to C2 or C2 is reference-related to C1 (8.6.3),\n    //    the cv-combined type of T1 and T2 or the cv-combined type of T2 and\n    //    T1, respectively;\n    //\n    // The \"similar type\" handling covers all of this except for the \"T1 is a\n    // base class of T2\" case in the definition of reference-related.\n    else if (IsDerivedFrom(Loc, Composite1, Composite2))\n      Composite1 = Composite2;\n    else if (IsDerivedFrom(Loc, Composite2, Composite1))\n      Composite2 = Composite1;\n  }\n\n  // At this point, either the inner types are the same or we have failed to\n  // find a composite pointer type.\n  if (!Context.hasSameType(Composite1, Composite2))\n    return QualType();\n\n  // Per C++ [conv.qual]p3, add 'const' to every level before the last\n  // differing qualifier.\n  for (unsigned I = 0; I != NeedConstBefore; ++I)\n    Steps[I].Quals.addConst();\n\n  // Rebuild the composite type.\n  QualType Composite = Composite1;\n  for (auto &S : llvm::reverse(Steps))\n    Composite = S.rebuild(Context, Composite);\n\n  if (ConvertArgs) {\n    // Convert the expressions to the composite pointer type.\n    InitializedEntity Entity =\n        InitializedEntity::InitializeTemporary(Composite);\n    InitializationKind Kind =\n        InitializationKind::CreateCopy(Loc, SourceLocation());\n\n    InitializationSequence E1ToC(*this, Entity, Kind, E1);\n    if (!E1ToC)\n      return QualType();\n\n    InitializationSequence E2ToC(*this, Entity, Kind, E2);\n    if (!E2ToC)\n      return QualType();\n\n    // FIXME: Let the caller know if these fail to avoid duplicate diagnostics.\n    ExprResult E1Result = E1ToC.Perform(*this, Entity, Kind, E1);\n    if (E1Result.isInvalid())\n      return QualType();\n    E1 = E1Result.get();\n\n    ExprResult E2Result = E2ToC.Perform(*this, Entity, Kind, E2);\n    if (E2Result.isInvalid())\n      return QualType();\n    E2 = E2Result.get();\n  }\n\n  return Composite;\n}\n\nExprResult Sema::MaybeBindToTemporary(Expr *E) {\n  if (!E)\n    return ExprError();\n\n  assert(!isa<CXXBindTemporaryExpr>(E) && \"Double-bound temporary?\");\n\n  // If the result is a glvalue, we shouldn't bind it.\n  if (!E->isRValue())\n    return E;\n\n  // In ARC, calls that return a retainable type can return retained,\n  // in which case we have to insert a consuming cast.\n  if (getLangOpts().ObjCAutoRefCount &&\n      E->getType()->isObjCRetainableType()) {\n\n    bool ReturnsRetained;\n\n    // For actual calls, we compute this by examining the type of the\n    // called value.\n    if (CallExpr *Call = dyn_cast<CallExpr>(E)) {\n      Expr *Callee = Call->getCallee()->IgnoreParens();\n      QualType T = Callee->getType();\n\n      if (T == Context.BoundMemberTy) {\n        // Handle pointer-to-members.\n        if (BinaryOperator *BinOp = dyn_cast<BinaryOperator>(Callee))\n          T = BinOp->getRHS()->getType();\n        else if (MemberExpr *Mem = dyn_cast<MemberExpr>(Callee))\n          T = Mem->getMemberDecl()->getType();\n      }\n\n      if (const PointerType *Ptr = T->getAs<PointerType>())\n        T = Ptr->getPointeeType();\n      else if (const BlockPointerType *Ptr = T->getAs<BlockPointerType>())\n        T = Ptr->getPointeeType();\n      else if (const MemberPointerType *MemPtr = T->getAs<MemberPointerType>())\n        T = MemPtr->getPointeeType();\n\n      auto *FTy = T->castAs<FunctionType>();\n      ReturnsRetained = FTy->getExtInfo().getProducesResult();\n\n    // ActOnStmtExpr arranges things so that StmtExprs of retainable\n    // type always produce a +1 object.\n    } else if (isa<StmtExpr>(E)) {\n      ReturnsRetained = true;\n\n    // We hit this case with the lambda conversion-to-block optimization;\n    // we don't want any extra casts here.\n    } else if (isa<CastExpr>(E) &&\n               isa<BlockExpr>(cast<CastExpr>(E)->getSubExpr())) {\n      return E;\n\n    // For message sends and property references, we try to find an\n    // actual method.  FIXME: we should infer retention by selector in\n    // cases where we don't have an actual method.\n    } else {\n      ObjCMethodDecl *D = nullptr;\n      if (ObjCMessageExpr *Send = dyn_cast<ObjCMessageExpr>(E)) {\n        D = Send->getMethodDecl();\n      } else if (ObjCBoxedExpr *BoxedExpr = dyn_cast<ObjCBoxedExpr>(E)) {\n        D = BoxedExpr->getBoxingMethod();\n      } else if (ObjCArrayLiteral *ArrayLit = dyn_cast<ObjCArrayLiteral>(E)) {\n        // Don't do reclaims if we're using the zero-element array\n        // constant.\n        if (ArrayLit->getNumElements() == 0 &&\n            Context.getLangOpts().ObjCRuntime.hasEmptyCollections())\n          return E;\n\n        D = ArrayLit->getArrayWithObjectsMethod();\n      } else if (ObjCDictionaryLiteral *DictLit\n                                        = dyn_cast<ObjCDictionaryLiteral>(E)) {\n        // Don't do reclaims if we're using the zero-element dictionary\n        // constant.\n        if (DictLit->getNumElements() == 0 &&\n            Context.getLangOpts().ObjCRuntime.hasEmptyCollections())\n          return E;\n\n        D = DictLit->getDictWithObjectsMethod();\n      }\n\n      ReturnsRetained = (D && D->hasAttr<NSReturnsRetainedAttr>());\n\n      // Don't do reclaims on performSelector calls; despite their\n      // return type, the invoked method doesn't necessarily actually\n      // return an object.\n      if (!ReturnsRetained &&\n          D && D->getMethodFamily() == OMF_performSelector)\n        return E;\n    }\n\n    // Don't reclaim an object of Class type.\n    if (!ReturnsRetained && E->getType()->isObjCARCImplicitlyUnretainedType())\n      return E;\n\n    Cleanup.setExprNeedsCleanups(true);\n\n    CastKind ck = (ReturnsRetained ? CK_ARCConsumeObject\n                                   : CK_ARCReclaimReturnedObject);\n    return ImplicitCastExpr::Create(Context, E->getType(), ck, E, nullptr,\n                                    VK_RValue, FPOptionsOverride());\n  }\n\n  if (E->getType().isDestructedType() == QualType::DK_nontrivial_c_struct)\n    Cleanup.setExprNeedsCleanups(true);\n\n  if (!getLangOpts().CPlusPlus)\n    return E;\n\n  // Search for the base element type (cf. ASTContext::getBaseElementType) with\n  // a fast path for the common case that the type is directly a RecordType.\n  const Type *T = Context.getCanonicalType(E->getType().getTypePtr());\n  const RecordType *RT = nullptr;\n  while (!RT) {\n    switch (T->getTypeClass()) {\n    case Type::Record:\n      RT = cast<RecordType>(T);\n      break;\n    case Type::ConstantArray:\n    case Type::IncompleteArray:\n    case Type::VariableArray:\n    case Type::DependentSizedArray:\n      T = cast<ArrayType>(T)->getElementType().getTypePtr();\n      break;\n    default:\n      return E;\n    }\n  }\n\n  // That should be enough to guarantee that this type is complete, if we're\n  // not processing a decltype expression.\n  CXXRecordDecl *RD = cast<CXXRecordDecl>(RT->getDecl());\n  if (RD->isInvalidDecl() || RD->isDependentContext())\n    return E;\n\n  bool IsDecltype = ExprEvalContexts.back().ExprContext ==\n                    ExpressionEvaluationContextRecord::EK_Decltype;\n  CXXDestructorDecl *Destructor = IsDecltype ? nullptr : LookupDestructor(RD);\n\n  if (Destructor) {\n    MarkFunctionReferenced(E->getExprLoc(), Destructor);\n    CheckDestructorAccess(E->getExprLoc(), Destructor,\n                          PDiag(diag::err_access_dtor_temp)\n                            << E->getType());\n    if (DiagnoseUseOfDecl(Destructor, E->getExprLoc()))\n      return ExprError();\n\n    // If destructor is trivial, we can avoid the extra copy.\n    if (Destructor->isTrivial())\n      return E;\n\n    // We need a cleanup, but we don't need to remember the temporary.\n    Cleanup.setExprNeedsCleanups(true);\n  }\n\n  CXXTemporary *Temp = CXXTemporary::Create(Context, Destructor);\n  CXXBindTemporaryExpr *Bind = CXXBindTemporaryExpr::Create(Context, Temp, E);\n\n  if (IsDecltype)\n    ExprEvalContexts.back().DelayedDecltypeBinds.push_back(Bind);\n\n  return Bind;\n}\n\nExprResult\nSema::MaybeCreateExprWithCleanups(ExprResult SubExpr) {\n  if (SubExpr.isInvalid())\n    return ExprError();\n\n  return MaybeCreateExprWithCleanups(SubExpr.get());\n}\n\nExpr *Sema::MaybeCreateExprWithCleanups(Expr *SubExpr) {\n  assert(SubExpr && \"subexpression can't be null!\");\n\n  CleanupVarDeclMarking();\n\n  unsigned FirstCleanup = ExprEvalContexts.back().NumCleanupObjects;\n  assert(ExprCleanupObjects.size() >= FirstCleanup);\n  assert(Cleanup.exprNeedsCleanups() ||\n         ExprCleanupObjects.size() == FirstCleanup);\n  if (!Cleanup.exprNeedsCleanups())\n    return SubExpr;\n\n  auto Cleanups = llvm::makeArrayRef(ExprCleanupObjects.begin() + FirstCleanup,\n                                     ExprCleanupObjects.size() - FirstCleanup);\n\n  auto *E = ExprWithCleanups::Create(\n      Context, SubExpr, Cleanup.cleanupsHaveSideEffects(), Cleanups);\n  DiscardCleanupsInEvaluationContext();\n\n  return E;\n}\n\nStmt *Sema::MaybeCreateStmtWithCleanups(Stmt *SubStmt) {\n  assert(SubStmt && \"sub-statement can't be null!\");\n\n  CleanupVarDeclMarking();\n\n  if (!Cleanup.exprNeedsCleanups())\n    return SubStmt;\n\n  // FIXME: In order to attach the temporaries, wrap the statement into\n  // a StmtExpr; currently this is only used for asm statements.\n  // This is hacky, either create a new CXXStmtWithTemporaries statement or\n  // a new AsmStmtWithTemporaries.\n  CompoundStmt *CompStmt = CompoundStmt::Create(\n      Context, SubStmt, SourceLocation(), SourceLocation());\n  Expr *E = new (Context)\n      StmtExpr(CompStmt, Context.VoidTy, SourceLocation(), SourceLocation(),\n               /*FIXME TemplateDepth=*/0);\n  return MaybeCreateExprWithCleanups(E);\n}\n\n/// Process the expression contained within a decltype. For such expressions,\n/// certain semantic checks on temporaries are delayed until this point, and\n/// are omitted for the 'topmost' call in the decltype expression. If the\n/// topmost call bound a temporary, strip that temporary off the expression.\nExprResult Sema::ActOnDecltypeExpression(Expr *E) {\n  assert(ExprEvalContexts.back().ExprContext ==\n             ExpressionEvaluationContextRecord::EK_Decltype &&\n         \"not in a decltype expression\");\n\n  ExprResult Result = CheckPlaceholderExpr(E);\n  if (Result.isInvalid())\n    return ExprError();\n  E = Result.get();\n\n  // C++11 [expr.call]p11:\n  //   If a function call is a prvalue of object type,\n  // -- if the function call is either\n  //   -- the operand of a decltype-specifier, or\n  //   -- the right operand of a comma operator that is the operand of a\n  //      decltype-specifier,\n  //   a temporary object is not introduced for the prvalue.\n\n  // Recursively rebuild ParenExprs and comma expressions to strip out the\n  // outermost CXXBindTemporaryExpr, if any.\n  if (ParenExpr *PE = dyn_cast<ParenExpr>(E)) {\n    ExprResult SubExpr = ActOnDecltypeExpression(PE->getSubExpr());\n    if (SubExpr.isInvalid())\n      return ExprError();\n    if (SubExpr.get() == PE->getSubExpr())\n      return E;\n    return ActOnParenExpr(PE->getLParen(), PE->getRParen(), SubExpr.get());\n  }\n  if (BinaryOperator *BO = dyn_cast<BinaryOperator>(E)) {\n    if (BO->getOpcode() == BO_Comma) {\n      ExprResult RHS = ActOnDecltypeExpression(BO->getRHS());\n      if (RHS.isInvalid())\n        return ExprError();\n      if (RHS.get() == BO->getRHS())\n        return E;\n      return BinaryOperator::Create(Context, BO->getLHS(), RHS.get(), BO_Comma,\n                                    BO->getType(), BO->getValueKind(),\n                                    BO->getObjectKind(), BO->getOperatorLoc(),\n                                    BO->getFPFeatures(getLangOpts()));\n    }\n  }\n\n  CXXBindTemporaryExpr *TopBind = dyn_cast<CXXBindTemporaryExpr>(E);\n  CallExpr *TopCall = TopBind ? dyn_cast<CallExpr>(TopBind->getSubExpr())\n                              : nullptr;\n  if (TopCall)\n    E = TopCall;\n  else\n    TopBind = nullptr;\n\n  // Disable the special decltype handling now.\n  ExprEvalContexts.back().ExprContext =\n      ExpressionEvaluationContextRecord::EK_Other;\n\n  Result = CheckUnevaluatedOperand(E);\n  if (Result.isInvalid())\n    return ExprError();\n  E = Result.get();\n\n  // In MS mode, don't perform any extra checking of call return types within a\n  // decltype expression.\n  if (getLangOpts().MSVCCompat)\n    return E;\n\n  // Perform the semantic checks we delayed until this point.\n  for (unsigned I = 0, N = ExprEvalContexts.back().DelayedDecltypeCalls.size();\n       I != N; ++I) {\n    CallExpr *Call = ExprEvalContexts.back().DelayedDecltypeCalls[I];\n    if (Call == TopCall)\n      continue;\n\n    if (CheckCallReturnType(Call->getCallReturnType(Context),\n                            Call->getBeginLoc(), Call, Call->getDirectCallee()))\n      return ExprError();\n  }\n\n  // Now all relevant types are complete, check the destructors are accessible\n  // and non-deleted, and annotate them on the temporaries.\n  for (unsigned I = 0, N = ExprEvalContexts.back().DelayedDecltypeBinds.size();\n       I != N; ++I) {\n    CXXBindTemporaryExpr *Bind =\n      ExprEvalContexts.back().DelayedDecltypeBinds[I];\n    if (Bind == TopBind)\n      continue;\n\n    CXXTemporary *Temp = Bind->getTemporary();\n\n    CXXRecordDecl *RD =\n      Bind->getType()->getBaseElementTypeUnsafe()->getAsCXXRecordDecl();\n    CXXDestructorDecl *Destructor = LookupDestructor(RD);\n    Temp->setDestructor(Destructor);\n\n    MarkFunctionReferenced(Bind->getExprLoc(), Destructor);\n    CheckDestructorAccess(Bind->getExprLoc(), Destructor,\n                          PDiag(diag::err_access_dtor_temp)\n                            << Bind->getType());\n    if (DiagnoseUseOfDecl(Destructor, Bind->getExprLoc()))\n      return ExprError();\n\n    // We need a cleanup, but we don't need to remember the temporary.\n    Cleanup.setExprNeedsCleanups(true);\n  }\n\n  // Possibly strip off the top CXXBindTemporaryExpr.\n  return E;\n}\n\n/// Note a set of 'operator->' functions that were used for a member access.\nstatic void noteOperatorArrows(Sema &S,\n                               ArrayRef<FunctionDecl *> OperatorArrows) {\n  unsigned SkipStart = OperatorArrows.size(), SkipCount = 0;\n  // FIXME: Make this configurable?\n  unsigned Limit = 9;\n  if (OperatorArrows.size() > Limit) {\n    // Produce Limit-1 normal notes and one 'skipping' note.\n    SkipStart = (Limit - 1) / 2 + (Limit - 1) % 2;\n    SkipCount = OperatorArrows.size() - (Limit - 1);\n  }\n\n  for (unsigned I = 0; I < OperatorArrows.size(); /**/) {\n    if (I == SkipStart) {\n      S.Diag(OperatorArrows[I]->getLocation(),\n             diag::note_operator_arrows_suppressed)\n          << SkipCount;\n      I += SkipCount;\n    } else {\n      S.Diag(OperatorArrows[I]->getLocation(), diag::note_operator_arrow_here)\n          << OperatorArrows[I]->getCallResultType();\n      ++I;\n    }\n  }\n}\n\nExprResult Sema::ActOnStartCXXMemberReference(Scope *S, Expr *Base,\n                                              SourceLocation OpLoc,\n                                              tok::TokenKind OpKind,\n                                              ParsedType &ObjectType,\n                                              bool &MayBePseudoDestructor) {\n  // Since this might be a postfix expression, get rid of ParenListExprs.\n  ExprResult Result = MaybeConvertParenListExprToParenExpr(S, Base);\n  if (Result.isInvalid()) return ExprError();\n  Base = Result.get();\n\n  Result = CheckPlaceholderExpr(Base);\n  if (Result.isInvalid()) return ExprError();\n  Base = Result.get();\n\n  QualType BaseType = Base->getType();\n  MayBePseudoDestructor = false;\n  if (BaseType->isDependentType()) {\n    // If we have a pointer to a dependent type and are using the -> operator,\n    // the object type is the type that the pointer points to. We might still\n    // have enough information about that type to do something useful.\n    if (OpKind == tok::arrow)\n      if (const PointerType *Ptr = BaseType->getAs<PointerType>())\n        BaseType = Ptr->getPointeeType();\n\n    ObjectType = ParsedType::make(BaseType);\n    MayBePseudoDestructor = true;\n    return Base;\n  }\n\n  // C++ [over.match.oper]p8:\n  //   [...] When operator->returns, the operator-> is applied  to the value\n  //   returned, with the original second operand.\n  if (OpKind == tok::arrow) {\n    QualType StartingType = BaseType;\n    bool NoArrowOperatorFound = false;\n    bool FirstIteration = true;\n    FunctionDecl *CurFD = dyn_cast<FunctionDecl>(CurContext);\n    // The set of types we've considered so far.\n    llvm::SmallPtrSet<CanQualType,8> CTypes;\n    SmallVector<FunctionDecl*, 8> OperatorArrows;\n    CTypes.insert(Context.getCanonicalType(BaseType));\n\n    while (BaseType->isRecordType()) {\n      if (OperatorArrows.size() >= getLangOpts().ArrowDepth) {\n        Diag(OpLoc, diag::err_operator_arrow_depth_exceeded)\n          << StartingType << getLangOpts().ArrowDepth << Base->getSourceRange();\n        noteOperatorArrows(*this, OperatorArrows);\n        Diag(OpLoc, diag::note_operator_arrow_depth)\n          << getLangOpts().ArrowDepth;\n        return ExprError();\n      }\n\n      Result = BuildOverloadedArrowExpr(\n          S, Base, OpLoc,\n          // When in a template specialization and on the first loop iteration,\n          // potentially give the default diagnostic (with the fixit in a\n          // separate note) instead of having the error reported back to here\n          // and giving a diagnostic with a fixit attached to the error itself.\n          (FirstIteration && CurFD && CurFD->isFunctionTemplateSpecialization())\n              ? nullptr\n              : &NoArrowOperatorFound);\n      if (Result.isInvalid()) {\n        if (NoArrowOperatorFound) {\n          if (FirstIteration) {\n            Diag(OpLoc, diag::err_typecheck_member_reference_suggestion)\n              << BaseType << 1 << Base->getSourceRange()\n              << FixItHint::CreateReplacement(OpLoc, \".\");\n            OpKind = tok::period;\n            break;\n          }\n          Diag(OpLoc, diag::err_typecheck_member_reference_arrow)\n            << BaseType << Base->getSourceRange();\n          CallExpr *CE = dyn_cast<CallExpr>(Base);\n          if (Decl *CD = (CE ? CE->getCalleeDecl() : nullptr)) {\n            Diag(CD->getBeginLoc(),\n                 diag::note_member_reference_arrow_from_operator_arrow);\n          }\n        }\n        return ExprError();\n      }\n      Base = Result.get();\n      if (CXXOperatorCallExpr *OpCall = dyn_cast<CXXOperatorCallExpr>(Base))\n        OperatorArrows.push_back(OpCall->getDirectCallee());\n      BaseType = Base->getType();\n      CanQualType CBaseType = Context.getCanonicalType(BaseType);\n      if (!CTypes.insert(CBaseType).second) {\n        Diag(OpLoc, diag::err_operator_arrow_circular) << StartingType;\n        noteOperatorArrows(*this, OperatorArrows);\n        return ExprError();\n      }\n      FirstIteration = false;\n    }\n\n    if (OpKind == tok::arrow) {\n      if (BaseType->isPointerType())\n        BaseType = BaseType->getPointeeType();\n      else if (auto *AT = Context.getAsArrayType(BaseType))\n        BaseType = AT->getElementType();\n    }\n  }\n\n  // Objective-C properties allow \".\" access on Objective-C pointer types,\n  // so adjust the base type to the object type itself.\n  if (BaseType->isObjCObjectPointerType())\n    BaseType = BaseType->getPointeeType();\n\n  // C++ [basic.lookup.classref]p2:\n  //   [...] If the type of the object expression is of pointer to scalar\n  //   type, the unqualified-id is looked up in the context of the complete\n  //   postfix-expression.\n  //\n  // This also indicates that we could be parsing a pseudo-destructor-name.\n  // Note that Objective-C class and object types can be pseudo-destructor\n  // expressions or normal member (ivar or property) access expressions, and\n  // it's legal for the type to be incomplete if this is a pseudo-destructor\n  // call.  We'll do more incomplete-type checks later in the lookup process,\n  // so just skip this check for ObjC types.\n  if (!BaseType->isRecordType()) {\n    ObjectType = ParsedType::make(BaseType);\n    MayBePseudoDestructor = true;\n    return Base;\n  }\n\n  // The object type must be complete (or dependent), or\n  // C++11 [expr.prim.general]p3:\n  //   Unlike the object expression in other contexts, *this is not required to\n  //   be of complete type for purposes of class member access (5.2.5) outside\n  //   the member function body.\n  if (!BaseType->isDependentType() &&\n      !isThisOutsideMemberFunctionBody(BaseType) &&\n      RequireCompleteType(OpLoc, BaseType, diag::err_incomplete_member_access))\n    return ExprError();\n\n  // C++ [basic.lookup.classref]p2:\n  //   If the id-expression in a class member access (5.2.5) is an\n  //   unqualified-id, and the type of the object expression is of a class\n  //   type C (or of pointer to a class type C), the unqualified-id is looked\n  //   up in the scope of class C. [...]\n  ObjectType = ParsedType::make(BaseType);\n  return Base;\n}\n\nstatic bool CheckArrow(Sema &S, QualType &ObjectType, Expr *&Base,\n                       tok::TokenKind &OpKind, SourceLocation OpLoc) {\n  if (Base->hasPlaceholderType()) {\n    ExprResult result = S.CheckPlaceholderExpr(Base);\n    if (result.isInvalid()) return true;\n    Base = result.get();\n  }\n  ObjectType = Base->getType();\n\n  // C++ [expr.pseudo]p2:\n  //   The left-hand side of the dot operator shall be of scalar type. The\n  //   left-hand side of the arrow operator shall be of pointer to scalar type.\n  //   This scalar type is the object type.\n  // Note that this is rather different from the normal handling for the\n  // arrow operator.\n  if (OpKind == tok::arrow) {\n    // The operator requires a prvalue, so perform lvalue conversions.\n    // Only do this if we might plausibly end with a pointer, as otherwise\n    // this was likely to be intended to be a '.'.\n    if (ObjectType->isPointerType() || ObjectType->isArrayType() ||\n        ObjectType->isFunctionType()) {\n      ExprResult BaseResult = S.DefaultFunctionArrayLvalueConversion(Base);\n      if (BaseResult.isInvalid())\n        return true;\n      Base = BaseResult.get();\n      ObjectType = Base->getType();\n    }\n\n    if (const PointerType *Ptr = ObjectType->getAs<PointerType>()) {\n      ObjectType = Ptr->getPointeeType();\n    } else if (!Base->isTypeDependent()) {\n      // The user wrote \"p->\" when they probably meant \"p.\"; fix it.\n      S.Diag(OpLoc, diag::err_typecheck_member_reference_suggestion)\n        << ObjectType << true\n        << FixItHint::CreateReplacement(OpLoc, \".\");\n      if (S.isSFINAEContext())\n        return true;\n\n      OpKind = tok::period;\n    }\n  }\n\n  return false;\n}\n\n/// Check if it's ok to try and recover dot pseudo destructor calls on\n/// pointer objects.\nstatic bool\ncanRecoverDotPseudoDestructorCallsOnPointerObjects(Sema &SemaRef,\n                                                   QualType DestructedType) {\n  // If this is a record type, check if its destructor is callable.\n  if (auto *RD = DestructedType->getAsCXXRecordDecl()) {\n    if (RD->hasDefinition())\n      if (CXXDestructorDecl *D = SemaRef.LookupDestructor(RD))\n        return SemaRef.CanUseDecl(D, /*TreatUnavailableAsInvalid=*/false);\n    return false;\n  }\n\n  // Otherwise, check if it's a type for which it's valid to use a pseudo-dtor.\n  return DestructedType->isDependentType() || DestructedType->isScalarType() ||\n         DestructedType->isVectorType();\n}\n\nExprResult Sema::BuildPseudoDestructorExpr(Expr *Base,\n                                           SourceLocation OpLoc,\n                                           tok::TokenKind OpKind,\n                                           const CXXScopeSpec &SS,\n                                           TypeSourceInfo *ScopeTypeInfo,\n                                           SourceLocation CCLoc,\n                                           SourceLocation TildeLoc,\n                                         PseudoDestructorTypeStorage Destructed) {\n  TypeSourceInfo *DestructedTypeInfo = Destructed.getTypeSourceInfo();\n\n  QualType ObjectType;\n  if (CheckArrow(*this, ObjectType, Base, OpKind, OpLoc))\n    return ExprError();\n\n  if (!ObjectType->isDependentType() && !ObjectType->isScalarType() &&\n      !ObjectType->isVectorType()) {\n    if (getLangOpts().MSVCCompat && ObjectType->isVoidType())\n      Diag(OpLoc, diag::ext_pseudo_dtor_on_void) << Base->getSourceRange();\n    else {\n      Diag(OpLoc, diag::err_pseudo_dtor_base_not_scalar)\n        << ObjectType << Base->getSourceRange();\n      return ExprError();\n    }\n  }\n\n  // C++ [expr.pseudo]p2:\n  //   [...] The cv-unqualified versions of the object type and of the type\n  //   designated by the pseudo-destructor-name shall be the same type.\n  if (DestructedTypeInfo) {\n    QualType DestructedType = DestructedTypeInfo->getType();\n    SourceLocation DestructedTypeStart\n      = DestructedTypeInfo->getTypeLoc().getLocalSourceRange().getBegin();\n    if (!DestructedType->isDependentType() && !ObjectType->isDependentType()) {\n      if (!Context.hasSameUnqualifiedType(DestructedType, ObjectType)) {\n        // Detect dot pseudo destructor calls on pointer objects, e.g.:\n        //   Foo *foo;\n        //   foo.~Foo();\n        if (OpKind == tok::period && ObjectType->isPointerType() &&\n            Context.hasSameUnqualifiedType(DestructedType,\n                                           ObjectType->getPointeeType())) {\n          auto Diagnostic =\n              Diag(OpLoc, diag::err_typecheck_member_reference_suggestion)\n              << ObjectType << /*IsArrow=*/0 << Base->getSourceRange();\n\n          // Issue a fixit only when the destructor is valid.\n          if (canRecoverDotPseudoDestructorCallsOnPointerObjects(\n                  *this, DestructedType))\n            Diagnostic << FixItHint::CreateReplacement(OpLoc, \"->\");\n\n          // Recover by setting the object type to the destructed type and the\n          // operator to '->'.\n          ObjectType = DestructedType;\n          OpKind = tok::arrow;\n        } else {\n          Diag(DestructedTypeStart, diag::err_pseudo_dtor_type_mismatch)\n              << ObjectType << DestructedType << Base->getSourceRange()\n              << DestructedTypeInfo->getTypeLoc().getLocalSourceRange();\n\n          // Recover by setting the destructed type to the object type.\n          DestructedType = ObjectType;\n          DestructedTypeInfo =\n              Context.getTrivialTypeSourceInfo(ObjectType, DestructedTypeStart);\n          Destructed = PseudoDestructorTypeStorage(DestructedTypeInfo);\n        }\n      } else if (DestructedType.getObjCLifetime() !=\n                                                ObjectType.getObjCLifetime()) {\n\n        if (DestructedType.getObjCLifetime() == Qualifiers::OCL_None) {\n          // Okay: just pretend that the user provided the correctly-qualified\n          // type.\n        } else {\n          Diag(DestructedTypeStart, diag::err_arc_pseudo_dtor_inconstant_quals)\n            << ObjectType << DestructedType << Base->getSourceRange()\n            << DestructedTypeInfo->getTypeLoc().getLocalSourceRange();\n        }\n\n        // Recover by setting the destructed type to the object type.\n        DestructedType = ObjectType;\n        DestructedTypeInfo = Context.getTrivialTypeSourceInfo(ObjectType,\n                                                           DestructedTypeStart);\n        Destructed = PseudoDestructorTypeStorage(DestructedTypeInfo);\n      }\n    }\n  }\n\n  // C++ [expr.pseudo]p2:\n  //   [...] Furthermore, the two type-names in a pseudo-destructor-name of the\n  //   form\n  //\n  //     ::[opt] nested-name-specifier[opt] type-name :: ~ type-name\n  //\n  //   shall designate the same scalar type.\n  if (ScopeTypeInfo) {\n    QualType ScopeType = ScopeTypeInfo->getType();\n    if (!ScopeType->isDependentType() && !ObjectType->isDependentType() &&\n        !Context.hasSameUnqualifiedType(ScopeType, ObjectType)) {\n\n      Diag(ScopeTypeInfo->getTypeLoc().getLocalSourceRange().getBegin(),\n           diag::err_pseudo_dtor_type_mismatch)\n        << ObjectType << ScopeType << Base->getSourceRange()\n        << ScopeTypeInfo->getTypeLoc().getLocalSourceRange();\n\n      ScopeType = QualType();\n      ScopeTypeInfo = nullptr;\n    }\n  }\n\n  Expr *Result\n    = new (Context) CXXPseudoDestructorExpr(Context, Base,\n                                            OpKind == tok::arrow, OpLoc,\n                                            SS.getWithLocInContext(Context),\n                                            ScopeTypeInfo,\n                                            CCLoc,\n                                            TildeLoc,\n                                            Destructed);\n\n  return Result;\n}\n\nExprResult Sema::ActOnPseudoDestructorExpr(Scope *S, Expr *Base,\n                                           SourceLocation OpLoc,\n                                           tok::TokenKind OpKind,\n                                           CXXScopeSpec &SS,\n                                           UnqualifiedId &FirstTypeName,\n                                           SourceLocation CCLoc,\n                                           SourceLocation TildeLoc,\n                                           UnqualifiedId &SecondTypeName) {\n  assert((FirstTypeName.getKind() == UnqualifiedIdKind::IK_TemplateId ||\n          FirstTypeName.getKind() == UnqualifiedIdKind::IK_Identifier) &&\n         \"Invalid first type name in pseudo-destructor\");\n  assert((SecondTypeName.getKind() == UnqualifiedIdKind::IK_TemplateId ||\n          SecondTypeName.getKind() == UnqualifiedIdKind::IK_Identifier) &&\n         \"Invalid second type name in pseudo-destructor\");\n\n  QualType ObjectType;\n  if (CheckArrow(*this, ObjectType, Base, OpKind, OpLoc))\n    return ExprError();\n\n  // Compute the object type that we should use for name lookup purposes. Only\n  // record types and dependent types matter.\n  ParsedType ObjectTypePtrForLookup;\n  if (!SS.isSet()) {\n    if (ObjectType->isRecordType())\n      ObjectTypePtrForLookup = ParsedType::make(ObjectType);\n    else if (ObjectType->isDependentType())\n      ObjectTypePtrForLookup = ParsedType::make(Context.DependentTy);\n  }\n\n  // Convert the name of the type being destructed (following the ~) into a\n  // type (with source-location information).\n  QualType DestructedType;\n  TypeSourceInfo *DestructedTypeInfo = nullptr;\n  PseudoDestructorTypeStorage Destructed;\n  if (SecondTypeName.getKind() == UnqualifiedIdKind::IK_Identifier) {\n    ParsedType T = getTypeName(*SecondTypeName.Identifier,\n                               SecondTypeName.StartLocation,\n                               S, &SS, true, false, ObjectTypePtrForLookup,\n                               /*IsCtorOrDtorName*/true);\n    if (!T &&\n        ((SS.isSet() && !computeDeclContext(SS, false)) ||\n         (!SS.isSet() && ObjectType->isDependentType()))) {\n      // The name of the type being destroyed is a dependent name, and we\n      // couldn't find anything useful in scope. Just store the identifier and\n      // it's location, and we'll perform (qualified) name lookup again at\n      // template instantiation time.\n      Destructed = PseudoDestructorTypeStorage(SecondTypeName.Identifier,\n                                               SecondTypeName.StartLocation);\n    } else if (!T) {\n      Diag(SecondTypeName.StartLocation,\n           diag::err_pseudo_dtor_destructor_non_type)\n        << SecondTypeName.Identifier << ObjectType;\n      if (isSFINAEContext())\n        return ExprError();\n\n      // Recover by assuming we had the right type all along.\n      DestructedType = ObjectType;\n    } else\n      DestructedType = GetTypeFromParser(T, &DestructedTypeInfo);\n  } else {\n    // Resolve the template-id to a type.\n    TemplateIdAnnotation *TemplateId = SecondTypeName.TemplateId;\n    ASTTemplateArgsPtr TemplateArgsPtr(TemplateId->getTemplateArgs(),\n                                       TemplateId->NumArgs);\n    TypeResult T = ActOnTemplateIdType(S,\n                                       SS,\n                                       TemplateId->TemplateKWLoc,\n                                       TemplateId->Template,\n                                       TemplateId->Name,\n                                       TemplateId->TemplateNameLoc,\n                                       TemplateId->LAngleLoc,\n                                       TemplateArgsPtr,\n                                       TemplateId->RAngleLoc,\n                                       /*IsCtorOrDtorName*/true);\n    if (T.isInvalid() || !T.get()) {\n      // Recover by assuming we had the right type all along.\n      DestructedType = ObjectType;\n    } else\n      DestructedType = GetTypeFromParser(T.get(), &DestructedTypeInfo);\n  }\n\n  // If we've performed some kind of recovery, (re-)build the type source\n  // information.\n  if (!DestructedType.isNull()) {\n    if (!DestructedTypeInfo)\n      DestructedTypeInfo = Context.getTrivialTypeSourceInfo(DestructedType,\n                                                  SecondTypeName.StartLocation);\n    Destructed = PseudoDestructorTypeStorage(DestructedTypeInfo);\n  }\n\n  // Convert the name of the scope type (the type prior to '::') into a type.\n  TypeSourceInfo *ScopeTypeInfo = nullptr;\n  QualType ScopeType;\n  if (FirstTypeName.getKind() == UnqualifiedIdKind::IK_TemplateId ||\n      FirstTypeName.Identifier) {\n    if (FirstTypeName.getKind() == UnqualifiedIdKind::IK_Identifier) {\n      ParsedType T = getTypeName(*FirstTypeName.Identifier,\n                                 FirstTypeName.StartLocation,\n                                 S, &SS, true, false, ObjectTypePtrForLookup,\n                                 /*IsCtorOrDtorName*/true);\n      if (!T) {\n        Diag(FirstTypeName.StartLocation,\n             diag::err_pseudo_dtor_destructor_non_type)\n          << FirstTypeName.Identifier << ObjectType;\n\n        if (isSFINAEContext())\n          return ExprError();\n\n        // Just drop this type. It's unnecessary anyway.\n        ScopeType = QualType();\n      } else\n        ScopeType = GetTypeFromParser(T, &ScopeTypeInfo);\n    } else {\n      // Resolve the template-id to a type.\n      TemplateIdAnnotation *TemplateId = FirstTypeName.TemplateId;\n      ASTTemplateArgsPtr TemplateArgsPtr(TemplateId->getTemplateArgs(),\n                                         TemplateId->NumArgs);\n      TypeResult T = ActOnTemplateIdType(S,\n                                         SS,\n                                         TemplateId->TemplateKWLoc,\n                                         TemplateId->Template,\n                                         TemplateId->Name,\n                                         TemplateId->TemplateNameLoc,\n                                         TemplateId->LAngleLoc,\n                                         TemplateArgsPtr,\n                                         TemplateId->RAngleLoc,\n                                         /*IsCtorOrDtorName*/true);\n      if (T.isInvalid() || !T.get()) {\n        // Recover by dropping this type.\n        ScopeType = QualType();\n      } else\n        ScopeType = GetTypeFromParser(T.get(), &ScopeTypeInfo);\n    }\n  }\n\n  if (!ScopeType.isNull() && !ScopeTypeInfo)\n    ScopeTypeInfo = Context.getTrivialTypeSourceInfo(ScopeType,\n                                                  FirstTypeName.StartLocation);\n\n\n  return BuildPseudoDestructorExpr(Base, OpLoc, OpKind, SS,\n                                   ScopeTypeInfo, CCLoc, TildeLoc,\n                                   Destructed);\n}\n\nExprResult Sema::ActOnPseudoDestructorExpr(Scope *S, Expr *Base,\n                                           SourceLocation OpLoc,\n                                           tok::TokenKind OpKind,\n                                           SourceLocation TildeLoc,\n                                           const DeclSpec& DS) {\n  QualType ObjectType;\n  if (CheckArrow(*this, ObjectType, Base, OpKind, OpLoc))\n    return ExprError();\n\n  if (DS.getTypeSpecType() == DeclSpec::TST_decltype_auto) {\n    Diag(DS.getTypeSpecTypeLoc(), diag::err_decltype_auto_invalid);\n    return true;\n  }\n\n  QualType T = BuildDecltypeType(DS.getRepAsExpr(), DS.getTypeSpecTypeLoc(),\n                                 false);\n\n  TypeLocBuilder TLB;\n  DecltypeTypeLoc DecltypeTL = TLB.push<DecltypeTypeLoc>(T);\n  DecltypeTL.setNameLoc(DS.getTypeSpecTypeLoc());\n  TypeSourceInfo *DestructedTypeInfo = TLB.getTypeSourceInfo(Context, T);\n  PseudoDestructorTypeStorage Destructed(DestructedTypeInfo);\n\n  return BuildPseudoDestructorExpr(Base, OpLoc, OpKind, CXXScopeSpec(),\n                                   nullptr, SourceLocation(), TildeLoc,\n                                   Destructed);\n}\n\nExprResult Sema::BuildCXXMemberCallExpr(Expr *E, NamedDecl *FoundDecl,\n                                        CXXConversionDecl *Method,\n                                        bool HadMultipleCandidates) {\n  // Convert the expression to match the conversion function's implicit object\n  // parameter.\n  ExprResult Exp = PerformObjectArgumentInitialization(E, /*Qualifier=*/nullptr,\n                                          FoundDecl, Method);\n  if (Exp.isInvalid())\n    return true;\n\n  if (Method->getParent()->isLambda() &&\n      Method->getConversionType()->isBlockPointerType()) {\n    // This is a lambda conversion to block pointer; check if the argument\n    // was a LambdaExpr.\n    Expr *SubE = E;\n    CastExpr *CE = dyn_cast<CastExpr>(SubE);\n    if (CE && CE->getCastKind() == CK_NoOp)\n      SubE = CE->getSubExpr();\n    SubE = SubE->IgnoreParens();\n    if (CXXBindTemporaryExpr *BE = dyn_cast<CXXBindTemporaryExpr>(SubE))\n      SubE = BE->getSubExpr();\n    if (isa<LambdaExpr>(SubE)) {\n      // For the conversion to block pointer on a lambda expression, we\n      // construct a special BlockLiteral instead; this doesn't really make\n      // a difference in ARC, but outside of ARC the resulting block literal\n      // follows the normal lifetime rules for block literals instead of being\n      // autoreleased.\n      PushExpressionEvaluationContext(\n          ExpressionEvaluationContext::PotentiallyEvaluated);\n      ExprResult BlockExp = BuildBlockForLambdaConversion(\n          Exp.get()->getExprLoc(), Exp.get()->getExprLoc(), Method, Exp.get());\n      PopExpressionEvaluationContext();\n\n      // FIXME: This note should be produced by a CodeSynthesisContext.\n      if (BlockExp.isInvalid())\n        Diag(Exp.get()->getExprLoc(), diag::note_lambda_to_block_conv);\n      return BlockExp;\n    }\n  }\n\n  MemberExpr *ME =\n      BuildMemberExpr(Exp.get(), /*IsArrow=*/false, SourceLocation(),\n                      NestedNameSpecifierLoc(), SourceLocation(), Method,\n                      DeclAccessPair::make(FoundDecl, FoundDecl->getAccess()),\n                      HadMultipleCandidates, DeclarationNameInfo(),\n                      Context.BoundMemberTy, VK_RValue, OK_Ordinary);\n\n  QualType ResultType = Method->getReturnType();\n  ExprValueKind VK = Expr::getValueKindForType(ResultType);\n  ResultType = ResultType.getNonLValueExprType(Context);\n\n  CXXMemberCallExpr *CE = CXXMemberCallExpr::Create(\n      Context, ME, /*Args=*/{}, ResultType, VK, Exp.get()->getEndLoc(),\n      CurFPFeatureOverrides());\n\n  if (CheckFunctionCall(Method, CE,\n                        Method->getType()->castAs<FunctionProtoType>()))\n    return ExprError();\n\n  return CE;\n}\n\nExprResult Sema::BuildCXXNoexceptExpr(SourceLocation KeyLoc, Expr *Operand,\n                                      SourceLocation RParen) {\n  // If the operand is an unresolved lookup expression, the expression is ill-\n  // formed per [over.over]p1, because overloaded function names cannot be used\n  // without arguments except in explicit contexts.\n  ExprResult R = CheckPlaceholderExpr(Operand);\n  if (R.isInvalid())\n    return R;\n\n  R = CheckUnevaluatedOperand(R.get());\n  if (R.isInvalid())\n    return ExprError();\n\n  Operand = R.get();\n\n  if (!inTemplateInstantiation() && !Operand->isInstantiationDependent() &&\n      Operand->HasSideEffects(Context, false)) {\n    // The expression operand for noexcept is in an unevaluated expression\n    // context, so side effects could result in unintended consequences.\n    Diag(Operand->getExprLoc(), diag::warn_side_effects_unevaluated_context);\n  }\n\n  CanThrowResult CanThrow = canThrow(Operand);\n  return new (Context)\n      CXXNoexceptExpr(Context.BoolTy, Operand, CanThrow, KeyLoc, RParen);\n}\n\nExprResult Sema::ActOnNoexceptExpr(SourceLocation KeyLoc, SourceLocation,\n                                   Expr *Operand, SourceLocation RParen) {\n  return BuildCXXNoexceptExpr(KeyLoc, Operand, RParen);\n}\n\n/// Perform the conversions required for an expression used in a\n/// context that ignores the result.\nExprResult Sema::IgnoredValueConversions(Expr *E) {\n  if (E->hasPlaceholderType()) {\n    ExprResult result = CheckPlaceholderExpr(E);\n    if (result.isInvalid()) return E;\n    E = result.get();\n  }\n\n  // C99 6.3.2.1:\n  //   [Except in specific positions,] an lvalue that does not have\n  //   array type is converted to the value stored in the\n  //   designated object (and is no longer an lvalue).\n  if (E->isRValue()) {\n    // In C, function designators (i.e. expressions of function type)\n    // are r-values, but we still want to do function-to-pointer decay\n    // on them.  This is both technically correct and convenient for\n    // some clients.\n    if (!getLangOpts().CPlusPlus && E->getType()->isFunctionType())\n      return DefaultFunctionArrayConversion(E);\n\n    return E;\n  }\n\n  if (getLangOpts().CPlusPlus) {\n    // The C++11 standard defines the notion of a discarded-value expression;\n    // normally, we don't need to do anything to handle it, but if it is a\n    // volatile lvalue with a special form, we perform an lvalue-to-rvalue\n    // conversion.\n    if (getLangOpts().CPlusPlus11 && E->isReadIfDiscardedInCPlusPlus11()) {\n      ExprResult Res = DefaultLvalueConversion(E);\n      if (Res.isInvalid())\n        return E;\n      E = Res.get();\n    } else {\n      // Per C++2a [expr.ass]p5, a volatile assignment is not deprecated if\n      // it occurs as a discarded-value expression.\n      CheckUnusedVolatileAssignment(E);\n    }\n\n    // C++1z:\n    //   If the expression is a prvalue after this optional conversion, the\n    //   temporary materialization conversion is applied.\n    //\n    // We skip this step: IR generation is able to synthesize the storage for\n    // itself in the aggregate case, and adding the extra node to the AST is\n    // just clutter.\n    // FIXME: We don't emit lifetime markers for the temporaries due to this.\n    // FIXME: Do any other AST consumers care about this?\n    return E;\n  }\n\n  // GCC seems to also exclude expressions of incomplete enum type.\n  if (const EnumType *T = E->getType()->getAs<EnumType>()) {\n    if (!T->getDecl()->isComplete()) {\n      // FIXME: stupid workaround for a codegen bug!\n      E = ImpCastExprToType(E, Context.VoidTy, CK_ToVoid).get();\n      return E;\n    }\n  }\n\n  ExprResult Res = DefaultFunctionArrayLvalueConversion(E);\n  if (Res.isInvalid())\n    return E;\n  E = Res.get();\n\n  if (!E->getType()->isVoidType())\n    RequireCompleteType(E->getExprLoc(), E->getType(),\n                        diag::err_incomplete_type);\n  return E;\n}\n\nExprResult Sema::CheckUnevaluatedOperand(Expr *E) {\n  // Per C++2a [expr.ass]p5, a volatile assignment is not deprecated if\n  // it occurs as an unevaluated operand.\n  CheckUnusedVolatileAssignment(E);\n\n  return E;\n}\n\n// If we can unambiguously determine whether Var can never be used\n// in a constant expression, return true.\n//  - if the variable and its initializer are non-dependent, then\n//    we can unambiguously check if the variable is a constant expression.\n//  - if the initializer is not value dependent - we can determine whether\n//    it can be used to initialize a constant expression.  If Init can not\n//    be used to initialize a constant expression we conclude that Var can\n//    never be a constant expression.\n//  - FXIME: if the initializer is dependent, we can still do some analysis and\n//    identify certain cases unambiguously as non-const by using a Visitor:\n//      - such as those that involve odr-use of a ParmVarDecl, involve a new\n//        delete, lambda-expr, dynamic-cast, reinterpret-cast etc...\nstatic inline bool VariableCanNeverBeAConstantExpression(VarDecl *Var,\n    ASTContext &Context) {\n  if (isa<ParmVarDecl>(Var)) return true;\n  const VarDecl *DefVD = nullptr;\n\n  // If there is no initializer - this can not be a constant expression.\n  if (!Var->getAnyInitializer(DefVD)) return true;\n  assert(DefVD);\n  if (DefVD->isWeak()) return false;\n  EvaluatedStmt *Eval = DefVD->ensureEvaluatedStmt();\n\n  Expr *Init = cast<Expr>(Eval->Value);\n\n  if (Var->getType()->isDependentType() || Init->isValueDependent()) {\n    // FIXME: Teach the constant evaluator to deal with the non-dependent parts\n    // of value-dependent expressions, and use it here to determine whether the\n    // initializer is a potential constant expression.\n    return false;\n  }\n\n  return !Var->isUsableInConstantExpressions(Context);\n}\n\n/// Check if the current lambda has any potential captures\n/// that must be captured by any of its enclosing lambdas that are ready to\n/// capture. If there is a lambda that can capture a nested\n/// potential-capture, go ahead and do so.  Also, check to see if any\n/// variables are uncaptureable or do not involve an odr-use so do not\n/// need to be captured.\n\nstatic void CheckIfAnyEnclosingLambdasMustCaptureAnyPotentialCaptures(\n    Expr *const FE, LambdaScopeInfo *const CurrentLSI, Sema &S) {\n\n  assert(!S.isUnevaluatedContext());\n  assert(S.CurContext->isDependentContext());\n#ifndef NDEBUG\n  DeclContext *DC = S.CurContext;\n  while (DC && isa<CapturedDecl>(DC))\n    DC = DC->getParent();\n  assert(\n      CurrentLSI->CallOperator == DC &&\n      \"The current call operator must be synchronized with Sema's CurContext\");\n#endif // NDEBUG\n\n  const bool IsFullExprInstantiationDependent = FE->isInstantiationDependent();\n\n  // All the potentially captureable variables in the current nested\n  // lambda (within a generic outer lambda), must be captured by an\n  // outer lambda that is enclosed within a non-dependent context.\n  CurrentLSI->visitPotentialCaptures([&] (VarDecl *Var, Expr *VarExpr) {\n    // If the variable is clearly identified as non-odr-used and the full\n    // expression is not instantiation dependent, only then do we not\n    // need to check enclosing lambda's for speculative captures.\n    // For e.g.:\n    // Even though 'x' is not odr-used, it should be captured.\n    // int test() {\n    //   const int x = 10;\n    //   auto L = [=](auto a) {\n    //     (void) +x + a;\n    //   };\n    // }\n    if (CurrentLSI->isVariableExprMarkedAsNonODRUsed(VarExpr) &&\n        !IsFullExprInstantiationDependent)\n      return;\n\n    // If we have a capture-capable lambda for the variable, go ahead and\n    // capture the variable in that lambda (and all its enclosing lambdas).\n    if (const Optional<unsigned> Index =\n            getStackIndexOfNearestEnclosingCaptureCapableLambda(\n                S.FunctionScopes, Var, S))\n      S.MarkCaptureUsedInEnclosingContext(Var, VarExpr->getExprLoc(),\n                                          Index.getValue());\n    const bool IsVarNeverAConstantExpression =\n        VariableCanNeverBeAConstantExpression(Var, S.Context);\n    if (!IsFullExprInstantiationDependent || IsVarNeverAConstantExpression) {\n      // This full expression is not instantiation dependent or the variable\n      // can not be used in a constant expression - which means\n      // this variable must be odr-used here, so diagnose a\n      // capture violation early, if the variable is un-captureable.\n      // This is purely for diagnosing errors early.  Otherwise, this\n      // error would get diagnosed when the lambda becomes capture ready.\n      QualType CaptureType, DeclRefType;\n      SourceLocation ExprLoc = VarExpr->getExprLoc();\n      if (S.tryCaptureVariable(Var, ExprLoc, S.TryCapture_Implicit,\n                          /*EllipsisLoc*/ SourceLocation(),\n                          /*BuildAndDiagnose*/false, CaptureType,\n                          DeclRefType, nullptr)) {\n        // We will never be able to capture this variable, and we need\n        // to be able to in any and all instantiations, so diagnose it.\n        S.tryCaptureVariable(Var, ExprLoc, S.TryCapture_Implicit,\n                          /*EllipsisLoc*/ SourceLocation(),\n                          /*BuildAndDiagnose*/true, CaptureType,\n                          DeclRefType, nullptr);\n      }\n    }\n  });\n\n  // Check if 'this' needs to be captured.\n  if (CurrentLSI->hasPotentialThisCapture()) {\n    // If we have a capture-capable lambda for 'this', go ahead and capture\n    // 'this' in that lambda (and all its enclosing lambdas).\n    if (const Optional<unsigned> Index =\n            getStackIndexOfNearestEnclosingCaptureCapableLambda(\n                S.FunctionScopes, /*0 is 'this'*/ nullptr, S)) {\n      const unsigned FunctionScopeIndexOfCapturableLambda = Index.getValue();\n      S.CheckCXXThisCapture(CurrentLSI->PotentialThisCaptureLocation,\n                            /*Explicit*/ false, /*BuildAndDiagnose*/ true,\n                            &FunctionScopeIndexOfCapturableLambda);\n    }\n  }\n\n  // Reset all the potential captures at the end of each full-expression.\n  CurrentLSI->clearPotentialCaptures();\n}\n\nstatic ExprResult attemptRecovery(Sema &SemaRef,\n                                  const TypoCorrectionConsumer &Consumer,\n                                  const TypoCorrection &TC) {\n  LookupResult R(SemaRef, Consumer.getLookupResult().getLookupNameInfo(),\n                 Consumer.getLookupResult().getLookupKind());\n  const CXXScopeSpec *SS = Consumer.getSS();\n  CXXScopeSpec NewSS;\n\n  // Use an approprate CXXScopeSpec for building the expr.\n  if (auto *NNS = TC.getCorrectionSpecifier())\n    NewSS.MakeTrivial(SemaRef.Context, NNS, TC.getCorrectionRange());\n  else if (SS && !TC.WillReplaceSpecifier())\n    NewSS = *SS;\n\n  if (auto *ND = TC.getFoundDecl()) {\n    R.setLookupName(ND->getDeclName());\n    R.addDecl(ND);\n    if (ND->isCXXClassMember()) {\n      // Figure out the correct naming class to add to the LookupResult.\n      CXXRecordDecl *Record = nullptr;\n      if (auto *NNS = TC.getCorrectionSpecifier())\n        Record = NNS->getAsType()->getAsCXXRecordDecl();\n      if (!Record)\n        Record =\n            dyn_cast<CXXRecordDecl>(ND->getDeclContext()->getRedeclContext());\n      if (Record)\n        R.setNamingClass(Record);\n\n      // Detect and handle the case where the decl might be an implicit\n      // member.\n      bool MightBeImplicitMember;\n      if (!Consumer.isAddressOfOperand())\n        MightBeImplicitMember = true;\n      else if (!NewSS.isEmpty())\n        MightBeImplicitMember = false;\n      else if (R.isOverloadedResult())\n        MightBeImplicitMember = false;\n      else if (R.isUnresolvableResult())\n        MightBeImplicitMember = true;\n      else\n        MightBeImplicitMember = isa<FieldDecl>(ND) ||\n                                isa<IndirectFieldDecl>(ND) ||\n                                isa<MSPropertyDecl>(ND);\n\n      if (MightBeImplicitMember)\n        return SemaRef.BuildPossibleImplicitMemberExpr(\n            NewSS, /*TemplateKWLoc*/ SourceLocation(), R,\n            /*TemplateArgs*/ nullptr, /*S*/ nullptr);\n    } else if (auto *Ivar = dyn_cast<ObjCIvarDecl>(ND)) {\n      return SemaRef.LookupInObjCMethod(R, Consumer.getScope(),\n                                        Ivar->getIdentifier());\n    }\n  }\n\n  return SemaRef.BuildDeclarationNameExpr(NewSS, R, /*NeedsADL*/ false,\n                                          /*AcceptInvalidDecl*/ true);\n}\n\nnamespace {\nclass FindTypoExprs : public RecursiveASTVisitor<FindTypoExprs> {\n  llvm::SmallSetVector<TypoExpr *, 2> &TypoExprs;\n\npublic:\n  explicit FindTypoExprs(llvm::SmallSetVector<TypoExpr *, 2> &TypoExprs)\n      : TypoExprs(TypoExprs) {}\n  bool VisitTypoExpr(TypoExpr *TE) {\n    TypoExprs.insert(TE);\n    return true;\n  }\n};\n\nclass TransformTypos : public TreeTransform<TransformTypos> {\n  typedef TreeTransform<TransformTypos> BaseTransform;\n\n  VarDecl *InitDecl; // A decl to avoid as a correction because it is in the\n                     // process of being initialized.\n  llvm::function_ref<ExprResult(Expr *)> ExprFilter;\n  llvm::SmallSetVector<TypoExpr *, 2> TypoExprs, AmbiguousTypoExprs;\n  llvm::SmallDenseMap<TypoExpr *, ExprResult, 2> TransformCache;\n  llvm::SmallDenseMap<OverloadExpr *, Expr *, 4> OverloadResolution;\n\n  /// Emit diagnostics for all of the TypoExprs encountered.\n  ///\n  /// If the TypoExprs were successfully corrected, then the diagnostics should\n  /// suggest the corrections. Otherwise the diagnostics will not suggest\n  /// anything (having been passed an empty TypoCorrection).\n  ///\n  /// If we've failed to correct due to ambiguous corrections, we need to\n  /// be sure to pass empty corrections and replacements. Otherwise it's\n  /// possible that the Consumer has a TypoCorrection that failed to ambiguity\n  /// and we don't want to report those diagnostics.\n  void EmitAllDiagnostics(bool IsAmbiguous) {\n    for (TypoExpr *TE : TypoExprs) {\n      auto &State = SemaRef.getTypoExprState(TE);\n      if (State.DiagHandler) {\n        TypoCorrection TC = IsAmbiguous\n            ? TypoCorrection() : State.Consumer->getCurrentCorrection();\n        ExprResult Replacement = IsAmbiguous ? ExprError() : TransformCache[TE];\n\n        // Extract the NamedDecl from the transformed TypoExpr and add it to the\n        // TypoCorrection, replacing the existing decls. This ensures the right\n        // NamedDecl is used in diagnostics e.g. in the case where overload\n        // resolution was used to select one from several possible decls that\n        // had been stored in the TypoCorrection.\n        if (auto *ND = getDeclFromExpr(\n                Replacement.isInvalid() ? nullptr : Replacement.get()))\n          TC.setCorrectionDecl(ND);\n\n        State.DiagHandler(TC);\n      }\n      SemaRef.clearDelayedTypo(TE);\n    }\n  }\n\n  /// Try to advance the typo correction state of the first unfinished TypoExpr.\n  /// We allow advancement of the correction stream by removing it from the\n  /// TransformCache which allows `TransformTypoExpr` to advance during the\n  /// next transformation attempt.\n  ///\n  /// Any substitution attempts for the previous TypoExprs (which must have been\n  /// finished) will need to be retried since it's possible that they will now\n  /// be invalid given the latest advancement.\n  ///\n  /// We need to be sure that we're making progress - it's possible that the\n  /// tree is so malformed that the transform never makes it to the\n  /// `TransformTypoExpr`.\n  ///\n  /// Returns true if there are any untried correction combinations.\n  bool CheckAndAdvanceTypoExprCorrectionStreams() {\n    for (auto TE : TypoExprs) {\n      auto &State = SemaRef.getTypoExprState(TE);\n      TransformCache.erase(TE);\n      if (!State.Consumer->hasMadeAnyCorrectionProgress())\n        return false;\n      if (!State.Consumer->finished())\n        return true;\n      State.Consumer->resetCorrectionStream();\n    }\n    return false;\n  }\n\n  NamedDecl *getDeclFromExpr(Expr *E) {\n    if (auto *OE = dyn_cast_or_null<OverloadExpr>(E))\n      E = OverloadResolution[OE];\n\n    if (!E)\n      return nullptr;\n    if (auto *DRE = dyn_cast<DeclRefExpr>(E))\n      return DRE->getFoundDecl();\n    if (auto *ME = dyn_cast<MemberExpr>(E))\n      return ME->getFoundDecl();\n    // FIXME: Add any other expr types that could be be seen by the delayed typo\n    // correction TreeTransform for which the corresponding TypoCorrection could\n    // contain multiple decls.\n    return nullptr;\n  }\n\n  ExprResult TryTransform(Expr *E) {\n    Sema::SFINAETrap Trap(SemaRef);\n    ExprResult Res = TransformExpr(E);\n    if (Trap.hasErrorOccurred() || Res.isInvalid())\n      return ExprError();\n\n    return ExprFilter(Res.get());\n  }\n\n  // Since correcting typos may intoduce new TypoExprs, this function\n  // checks for new TypoExprs and recurses if it finds any. Note that it will\n  // only succeed if it is able to correct all typos in the given expression.\n  ExprResult CheckForRecursiveTypos(ExprResult Res, bool &IsAmbiguous) {\n    if (Res.isInvalid()) {\n      return Res;\n    }\n    // Check to see if any new TypoExprs were created. If so, we need to recurse\n    // to check their validity.\n    Expr *FixedExpr = Res.get();\n\n    auto SavedTypoExprs = std::move(TypoExprs);\n    auto SavedAmbiguousTypoExprs = std::move(AmbiguousTypoExprs);\n    TypoExprs.clear();\n    AmbiguousTypoExprs.clear();\n\n    FindTypoExprs(TypoExprs).TraverseStmt(FixedExpr);\n    if (!TypoExprs.empty()) {\n      // Recurse to handle newly created TypoExprs. If we're not able to\n      // handle them, discard these TypoExprs.\n      ExprResult RecurResult =\n          RecursiveTransformLoop(FixedExpr, IsAmbiguous);\n      if (RecurResult.isInvalid()) {\n        Res = ExprError();\n        // Recursive corrections didn't work, wipe them away and don't add\n        // them to the TypoExprs set. Remove them from Sema's TypoExpr list\n        // since we don't want to clear them twice. Note: it's possible the\n        // TypoExprs were created recursively and thus won't be in our\n        // Sema's TypoExprs - they were created in our `RecursiveTransformLoop`.\n        auto &SemaTypoExprs = SemaRef.TypoExprs;\n        for (auto TE : TypoExprs) {\n          TransformCache.erase(TE);\n          SemaRef.clearDelayedTypo(TE);\n\n          auto SI = find(SemaTypoExprs, TE);\n          if (SI != SemaTypoExprs.end()) {\n            SemaTypoExprs.erase(SI);\n          }\n        }\n      } else {\n        // TypoExpr is valid: add newly created TypoExprs since we were\n        // able to correct them.\n        Res = RecurResult;\n        SavedTypoExprs.set_union(TypoExprs);\n      }\n    }\n\n    TypoExprs = std::move(SavedTypoExprs);\n    AmbiguousTypoExprs = std::move(SavedAmbiguousTypoExprs);\n\n    return Res;\n  }\n\n  // Try to transform the given expression, looping through the correction\n  // candidates with `CheckAndAdvanceTypoExprCorrectionStreams`.\n  //\n  // If valid ambiguous typo corrections are seen, `IsAmbiguous` is set to\n  // true and this method immediately will return an `ExprError`.\n  ExprResult RecursiveTransformLoop(Expr *E, bool &IsAmbiguous) {\n    ExprResult Res;\n    auto SavedTypoExprs = std::move(SemaRef.TypoExprs);\n    SemaRef.TypoExprs.clear();\n\n    while (true) {\n      Res = CheckForRecursiveTypos(TryTransform(E), IsAmbiguous);\n\n      // Recursion encountered an ambiguous correction. This means that our\n      // correction itself is ambiguous, so stop now.\n      if (IsAmbiguous)\n        break;\n\n      // If the transform is still valid after checking for any new typos,\n      // it's good to go.\n      if (!Res.isInvalid())\n        break;\n\n      // The transform was invalid, see if we have any TypoExprs with untried\n      // correction candidates.\n      if (!CheckAndAdvanceTypoExprCorrectionStreams())\n        break;\n    }\n\n    // If we found a valid result, double check to make sure it's not ambiguous.\n    if (!IsAmbiguous && !Res.isInvalid() && !AmbiguousTypoExprs.empty()) {\n      auto SavedTransformCache =\n          llvm::SmallDenseMap<TypoExpr *, ExprResult, 2>(TransformCache);\n\n      // Ensure none of the TypoExprs have multiple typo correction candidates\n      // with the same edit length that pass all the checks and filters.\n      while (!AmbiguousTypoExprs.empty()) {\n        auto TE  = AmbiguousTypoExprs.back();\n\n        // TryTransform itself can create new Typos, adding them to the TypoExpr map\n        // and invalidating our TypoExprState, so always fetch it instead of storing.\n        SemaRef.getTypoExprState(TE).Consumer->saveCurrentPosition();\n\n        TypoCorrection TC = SemaRef.getTypoExprState(TE).Consumer->peekNextCorrection();\n        TypoCorrection Next;\n        do {\n          // Fetch the next correction by erasing the typo from the cache and calling\n          // `TryTransform` which will iterate through corrections in\n          // `TransformTypoExpr`.\n          TransformCache.erase(TE);\n          ExprResult AmbigRes = CheckForRecursiveTypos(TryTransform(E), IsAmbiguous);\n\n          if (!AmbigRes.isInvalid() || IsAmbiguous) {\n            SemaRef.getTypoExprState(TE).Consumer->resetCorrectionStream();\n            SavedTransformCache.erase(TE);\n            Res = ExprError();\n            IsAmbiguous = true;\n            break;\n          }\n        } while ((Next = SemaRef.getTypoExprState(TE).Consumer->peekNextCorrection()) &&\n                 Next.getEditDistance(false) == TC.getEditDistance(false));\n\n        if (IsAmbiguous)\n          break;\n\n        AmbiguousTypoExprs.remove(TE);\n        SemaRef.getTypoExprState(TE).Consumer->restoreSavedPosition();\n      }\n      TransformCache = std::move(SavedTransformCache);\n    }\n\n    // Wipe away any newly created TypoExprs that we don't know about. Since we\n    // clear any invalid TypoExprs in `CheckForRecursiveTypos`, this is only\n    // possible if a `TypoExpr` is created during a transformation but then\n    // fails before we can discover it.\n    auto &SemaTypoExprs = SemaRef.TypoExprs;\n    for (auto Iterator = SemaTypoExprs.begin(); Iterator != SemaTypoExprs.end();) {\n      auto TE = *Iterator;\n      auto FI = find(TypoExprs, TE);\n      if (FI != TypoExprs.end()) {\n        Iterator++;\n        continue;\n      }\n      SemaRef.clearDelayedTypo(TE);\n      Iterator = SemaTypoExprs.erase(Iterator);\n    }\n    SemaRef.TypoExprs = std::move(SavedTypoExprs);\n\n    return Res;\n  }\n\npublic:\n  TransformTypos(Sema &SemaRef, VarDecl *InitDecl, llvm::function_ref<ExprResult(Expr *)> Filter)\n      : BaseTransform(SemaRef), InitDecl(InitDecl), ExprFilter(Filter) {}\n\n  ExprResult RebuildCallExpr(Expr *Callee, SourceLocation LParenLoc,\n                                   MultiExprArg Args,\n                                   SourceLocation RParenLoc,\n                                   Expr *ExecConfig = nullptr) {\n    auto Result = BaseTransform::RebuildCallExpr(Callee, LParenLoc, Args,\n                                                 RParenLoc, ExecConfig);\n    if (auto *OE = dyn_cast<OverloadExpr>(Callee)) {\n      if (Result.isUsable()) {\n        Expr *ResultCall = Result.get();\n        if (auto *BE = dyn_cast<CXXBindTemporaryExpr>(ResultCall))\n          ResultCall = BE->getSubExpr();\n        if (auto *CE = dyn_cast<CallExpr>(ResultCall))\n          OverloadResolution[OE] = CE->getCallee();\n      }\n    }\n    return Result;\n  }\n\n  ExprResult TransformLambdaExpr(LambdaExpr *E) { return Owned(E); }\n\n  ExprResult TransformBlockExpr(BlockExpr *E) { return Owned(E); }\n\n  ExprResult Transform(Expr *E) {\n    bool IsAmbiguous = false;\n    ExprResult Res = RecursiveTransformLoop(E, IsAmbiguous);\n\n    if (!Res.isUsable())\n      FindTypoExprs(TypoExprs).TraverseStmt(E);\n\n    EmitAllDiagnostics(IsAmbiguous);\n\n    return Res;\n  }\n\n  ExprResult TransformTypoExpr(TypoExpr *E) {\n    // If the TypoExpr hasn't been seen before, record it. Otherwise, return the\n    // cached transformation result if there is one and the TypoExpr isn't the\n    // first one that was encountered.\n    auto &CacheEntry = TransformCache[E];\n    if (!TypoExprs.insert(E) && !CacheEntry.isUnset()) {\n      return CacheEntry;\n    }\n\n    auto &State = SemaRef.getTypoExprState(E);\n    assert(State.Consumer && \"Cannot transform a cleared TypoExpr\");\n\n    // For the first TypoExpr and an uncached TypoExpr, find the next likely\n    // typo correction and return it.\n    while (TypoCorrection TC = State.Consumer->getNextCorrection()) {\n      if (InitDecl && TC.getFoundDecl() == InitDecl)\n        continue;\n      // FIXME: If we would typo-correct to an invalid declaration, it's\n      // probably best to just suppress all errors from this typo correction.\n      ExprResult NE = State.RecoveryHandler ?\n          State.RecoveryHandler(SemaRef, E, TC) :\n          attemptRecovery(SemaRef, *State.Consumer, TC);\n      if (!NE.isInvalid()) {\n        // Check whether there may be a second viable correction with the same\n        // edit distance; if so, remember this TypoExpr may have an ambiguous\n        // correction so it can be more thoroughly vetted later.\n        TypoCorrection Next;\n        if ((Next = State.Consumer->peekNextCorrection()) &&\n            Next.getEditDistance(false) == TC.getEditDistance(false)) {\n          AmbiguousTypoExprs.insert(E);\n        } else {\n          AmbiguousTypoExprs.remove(E);\n        }\n        assert(!NE.isUnset() &&\n               \"Typo was transformed into a valid-but-null ExprResult\");\n        return CacheEntry = NE;\n      }\n    }\n    return CacheEntry = ExprError();\n  }\n};\n}\n\nExprResult\nSema::CorrectDelayedTyposInExpr(Expr *E, VarDecl *InitDecl,\n                                bool RecoverUncorrectedTypos,\n                                llvm::function_ref<ExprResult(Expr *)> Filter) {\n  // If the current evaluation context indicates there are uncorrected typos\n  // and the current expression isn't guaranteed to not have typos, try to\n  // resolve any TypoExpr nodes that might be in the expression.\n  if (E && !ExprEvalContexts.empty() && ExprEvalContexts.back().NumTypos &&\n      (E->isTypeDependent() || E->isValueDependent() ||\n       E->isInstantiationDependent())) {\n    auto TyposResolved = DelayedTypos.size();\n    auto Result = TransformTypos(*this, InitDecl, Filter).Transform(E);\n    TyposResolved -= DelayedTypos.size();\n    if (Result.isInvalid() || Result.get() != E) {\n      ExprEvalContexts.back().NumTypos -= TyposResolved;\n      if (Result.isInvalid() && RecoverUncorrectedTypos) {\n        struct TyposReplace : TreeTransform<TyposReplace> {\n          TyposReplace(Sema &SemaRef) : TreeTransform(SemaRef) {}\n          ExprResult TransformTypoExpr(clang::TypoExpr *E) {\n            return this->SemaRef.CreateRecoveryExpr(E->getBeginLoc(),\n                                                    E->getEndLoc(), {});\n          }\n        } TT(*this);\n        return TT.TransformExpr(E);\n      }\n      return Result;\n    }\n    assert(TyposResolved == 0 && \"Corrected typo but got same Expr back?\");\n  }\n  return E;\n}\n\nExprResult Sema::ActOnFinishFullExpr(Expr *FE, SourceLocation CC,\n                                     bool DiscardedValue,\n                                     bool IsConstexpr) {\n  ExprResult FullExpr = FE;\n\n  if (!FullExpr.get())\n    return ExprError();\n\n  if (DiagnoseUnexpandedParameterPack(FullExpr.get()))\n    return ExprError();\n\n  if (DiscardedValue) {\n    // Top-level expressions default to 'id' when we're in a debugger.\n    if (getLangOpts().DebuggerCastResultToId &&\n        FullExpr.get()->getType() == Context.UnknownAnyTy) {\n      FullExpr = forceUnknownAnyToType(FullExpr.get(), Context.getObjCIdType());\n      if (FullExpr.isInvalid())\n        return ExprError();\n    }\n\n    FullExpr = CheckPlaceholderExpr(FullExpr.get());\n    if (FullExpr.isInvalid())\n      return ExprError();\n\n    FullExpr = IgnoredValueConversions(FullExpr.get());\n    if (FullExpr.isInvalid())\n      return ExprError();\n\n    DiagnoseUnusedExprResult(FullExpr.get());\n  }\n\n  FullExpr = CorrectDelayedTyposInExpr(FullExpr.get(), /*InitDecl=*/nullptr,\n                                       /*RecoverUncorrectedTypos=*/true);\n  if (FullExpr.isInvalid())\n    return ExprError();\n\n  CheckCompletedExpr(FullExpr.get(), CC, IsConstexpr);\n\n  // At the end of this full expression (which could be a deeply nested\n  // lambda), if there is a potential capture within the nested lambda,\n  // have the outer capture-able lambda try and capture it.\n  // Consider the following code:\n  // void f(int, int);\n  // void f(const int&, double);\n  // void foo() {\n  //  const int x = 10, y = 20;\n  //  auto L = [=](auto a) {\n  //      auto M = [=](auto b) {\n  //         f(x, b); <-- requires x to be captured by L and M\n  //         f(y, a); <-- requires y to be captured by L, but not all Ms\n  //      };\n  //   };\n  // }\n\n  // FIXME: Also consider what happens for something like this that involves\n  // the gnu-extension statement-expressions or even lambda-init-captures:\n  //   void f() {\n  //     const int n = 0;\n  //     auto L =  [&](auto a) {\n  //       +n + ({ 0; a; });\n  //     };\n  //   }\n  //\n  // Here, we see +n, and then the full-expression 0; ends, so we don't\n  // capture n (and instead remove it from our list of potential captures),\n  // and then the full-expression +n + ({ 0; }); ends, but it's too late\n  // for us to see that we need to capture n after all.\n\n  LambdaScopeInfo *const CurrentLSI =\n      getCurLambda(/*IgnoreCapturedRegions=*/true);\n  // FIXME: PR 17877 showed that getCurLambda() can return a valid pointer\n  // even if CurContext is not a lambda call operator. Refer to that Bug Report\n  // for an example of the code that might cause this asynchrony.\n  // By ensuring we are in the context of a lambda's call operator\n  // we can fix the bug (we only need to check whether we need to capture\n  // if we are within a lambda's body); but per the comments in that\n  // PR, a proper fix would entail :\n  //   \"Alternative suggestion:\n  //   - Add to Sema an integer holding the smallest (outermost) scope\n  //     index that we are *lexically* within, and save/restore/set to\n  //     FunctionScopes.size() in InstantiatingTemplate's\n  //     constructor/destructor.\n  //  - Teach the handful of places that iterate over FunctionScopes to\n  //    stop at the outermost enclosing lexical scope.\"\n  DeclContext *DC = CurContext;\n  while (DC && isa<CapturedDecl>(DC))\n    DC = DC->getParent();\n  const bool IsInLambdaDeclContext = isLambdaCallOperator(DC);\n  if (IsInLambdaDeclContext && CurrentLSI &&\n      CurrentLSI->hasPotentialCaptures() && !FullExpr.isInvalid())\n    CheckIfAnyEnclosingLambdasMustCaptureAnyPotentialCaptures(FE, CurrentLSI,\n                                                              *this);\n  return MaybeCreateExprWithCleanups(FullExpr);\n}\n\nStmtResult Sema::ActOnFinishFullStmt(Stmt *FullStmt) {\n  if (!FullStmt) return StmtError();\n\n  return MaybeCreateStmtWithCleanups(FullStmt);\n}\n\nSema::IfExistsResult\nSema::CheckMicrosoftIfExistsSymbol(Scope *S,\n                                   CXXScopeSpec &SS,\n                                   const DeclarationNameInfo &TargetNameInfo) {\n  DeclarationName TargetName = TargetNameInfo.getName();\n  if (!TargetName)\n    return IER_DoesNotExist;\n\n  // If the name itself is dependent, then the result is dependent.\n  if (TargetName.isDependentName())\n    return IER_Dependent;\n\n  // Do the redeclaration lookup in the current scope.\n  LookupResult R(*this, TargetNameInfo, Sema::LookupAnyName,\n                 Sema::NotForRedeclaration);\n  LookupParsedName(R, S, &SS);\n  R.suppressDiagnostics();\n\n  switch (R.getResultKind()) {\n  case LookupResult::Found:\n  case LookupResult::FoundOverloaded:\n  case LookupResult::FoundUnresolvedValue:\n  case LookupResult::Ambiguous:\n    return IER_Exists;\n\n  case LookupResult::NotFound:\n    return IER_DoesNotExist;\n\n  case LookupResult::NotFoundInCurrentInstantiation:\n    return IER_Dependent;\n  }\n\n  llvm_unreachable(\"Invalid LookupResult Kind!\");\n}\n\nSema::IfExistsResult\nSema::CheckMicrosoftIfExistsSymbol(Scope *S, SourceLocation KeywordLoc,\n                                   bool IsIfExists, CXXScopeSpec &SS,\n                                   UnqualifiedId &Name) {\n  DeclarationNameInfo TargetNameInfo = GetNameFromUnqualifiedId(Name);\n\n  // Check for an unexpanded parameter pack.\n  auto UPPC = IsIfExists ? UPPC_IfExists : UPPC_IfNotExists;\n  if (DiagnoseUnexpandedParameterPack(SS, UPPC) ||\n      DiagnoseUnexpandedParameterPack(TargetNameInfo, UPPC))\n    return IER_Error;\n\n  return CheckMicrosoftIfExistsSymbol(S, SS, TargetNameInfo);\n}\n\nconcepts::Requirement *Sema::ActOnSimpleRequirement(Expr *E) {\n  return BuildExprRequirement(E, /*IsSimple=*/true,\n                              /*NoexceptLoc=*/SourceLocation(),\n                              /*ReturnTypeRequirement=*/{});\n}\n\nconcepts::Requirement *\nSema::ActOnTypeRequirement(SourceLocation TypenameKWLoc, CXXScopeSpec &SS,\n                           SourceLocation NameLoc, IdentifierInfo *TypeName,\n                           TemplateIdAnnotation *TemplateId) {\n  assert(((!TypeName && TemplateId) || (TypeName && !TemplateId)) &&\n         \"Exactly one of TypeName and TemplateId must be specified.\");\n  TypeSourceInfo *TSI = nullptr;\n  if (TypeName) {\n    QualType T = CheckTypenameType(ETK_Typename, TypenameKWLoc,\n                                   SS.getWithLocInContext(Context), *TypeName,\n                                   NameLoc, &TSI, /*DeducedTypeContext=*/false);\n    if (T.isNull())\n      return nullptr;\n  } else {\n    ASTTemplateArgsPtr ArgsPtr(TemplateId->getTemplateArgs(),\n                               TemplateId->NumArgs);\n    TypeResult T = ActOnTypenameType(CurScope, TypenameKWLoc, SS,\n                                     TemplateId->TemplateKWLoc,\n                                     TemplateId->Template, TemplateId->Name,\n                                     TemplateId->TemplateNameLoc,\n                                     TemplateId->LAngleLoc, ArgsPtr,\n                                     TemplateId->RAngleLoc);\n    if (T.isInvalid())\n      return nullptr;\n    if (GetTypeFromParser(T.get(), &TSI).isNull())\n      return nullptr;\n  }\n  return BuildTypeRequirement(TSI);\n}\n\nconcepts::Requirement *\nSema::ActOnCompoundRequirement(Expr *E, SourceLocation NoexceptLoc) {\n  return BuildExprRequirement(E, /*IsSimple=*/false, NoexceptLoc,\n                              /*ReturnTypeRequirement=*/{});\n}\n\nconcepts::Requirement *\nSema::ActOnCompoundRequirement(\n    Expr *E, SourceLocation NoexceptLoc, CXXScopeSpec &SS,\n    TemplateIdAnnotation *TypeConstraint, unsigned Depth) {\n  // C++2a [expr.prim.req.compound] p1.3.3\n  //   [..] the expression is deduced against an invented function template\n  //   F [...] F is a void function template with a single type template\n  //   parameter T declared with the constrained-parameter. Form a new\n  //   cv-qualifier-seq cv by taking the union of const and volatile specifiers\n  //   around the constrained-parameter. F has a single parameter whose\n  //   type-specifier is cv T followed by the abstract-declarator. [...]\n  //\n  // The cv part is done in the calling function - we get the concept with\n  // arguments and the abstract declarator with the correct CV qualification and\n  // have to synthesize T and the single parameter of F.\n  auto &II = Context.Idents.get(\"expr-type\");\n  auto *TParam = TemplateTypeParmDecl::Create(Context, CurContext,\n                                              SourceLocation(),\n                                              SourceLocation(), Depth,\n                                              /*Index=*/0, &II,\n                                              /*Typename=*/true,\n                                              /*ParameterPack=*/false,\n                                              /*HasTypeConstraint=*/true);\n\n  if (ActOnTypeConstraint(SS, TypeConstraint, TParam,\n                          /*EllpsisLoc=*/SourceLocation()))\n    // Just produce a requirement with no type requirements.\n    return BuildExprRequirement(E, /*IsSimple=*/false, NoexceptLoc, {});\n\n  auto *TPL = TemplateParameterList::Create(Context, SourceLocation(),\n                                            SourceLocation(),\n                                            ArrayRef<NamedDecl *>(TParam),\n                                            SourceLocation(),\n                                            /*RequiresClause=*/nullptr);\n  return BuildExprRequirement(\n      E, /*IsSimple=*/false, NoexceptLoc,\n      concepts::ExprRequirement::ReturnTypeRequirement(TPL));\n}\n\nconcepts::ExprRequirement *\nSema::BuildExprRequirement(\n    Expr *E, bool IsSimple, SourceLocation NoexceptLoc,\n    concepts::ExprRequirement::ReturnTypeRequirement ReturnTypeRequirement) {\n  auto Status = concepts::ExprRequirement::SS_Satisfied;\n  ConceptSpecializationExpr *SubstitutedConstraintExpr = nullptr;\n  if (E->isInstantiationDependent() || ReturnTypeRequirement.isDependent())\n    Status = concepts::ExprRequirement::SS_Dependent;\n  else if (NoexceptLoc.isValid() && canThrow(E) == CanThrowResult::CT_Can)\n    Status = concepts::ExprRequirement::SS_NoexceptNotMet;\n  else if (ReturnTypeRequirement.isSubstitutionFailure())\n    Status = concepts::ExprRequirement::SS_TypeRequirementSubstitutionFailure;\n  else if (ReturnTypeRequirement.isTypeConstraint()) {\n    // C++2a [expr.prim.req]p1.3.3\n    //     The immediately-declared constraint ([temp]) of decltype((E)) shall\n    //     be satisfied.\n    TemplateParameterList *TPL =\n        ReturnTypeRequirement.getTypeConstraintTemplateParameterList();\n    QualType MatchedType =\n        BuildDecltypeType(E, E->getBeginLoc()).getCanonicalType();\n    llvm::SmallVector<TemplateArgument, 1> Args;\n    Args.push_back(TemplateArgument(MatchedType));\n    TemplateArgumentList TAL(TemplateArgumentList::OnStack, Args);\n    MultiLevelTemplateArgumentList MLTAL(TAL);\n    for (unsigned I = 0; I < TPL->getDepth(); ++I)\n      MLTAL.addOuterRetainedLevel();\n    Expr *IDC =\n        cast<TemplateTypeParmDecl>(TPL->getParam(0))->getTypeConstraint()\n            ->getImmediatelyDeclaredConstraint();\n    ExprResult Constraint = SubstExpr(IDC, MLTAL);\n    assert(!Constraint.isInvalid() &&\n           \"Substitution cannot fail as it is simply putting a type template \"\n           \"argument into a concept specialization expression's parameter.\");\n\n    SubstitutedConstraintExpr =\n        cast<ConceptSpecializationExpr>(Constraint.get());\n    if (!SubstitutedConstraintExpr->isSatisfied())\n      Status = concepts::ExprRequirement::SS_ConstraintsNotSatisfied;\n  }\n  return new (Context) concepts::ExprRequirement(E, IsSimple, NoexceptLoc,\n                                                 ReturnTypeRequirement, Status,\n                                                 SubstitutedConstraintExpr);\n}\n\nconcepts::ExprRequirement *\nSema::BuildExprRequirement(\n    concepts::Requirement::SubstitutionDiagnostic *ExprSubstitutionDiagnostic,\n    bool IsSimple, SourceLocation NoexceptLoc,\n    concepts::ExprRequirement::ReturnTypeRequirement ReturnTypeRequirement) {\n  return new (Context) concepts::ExprRequirement(ExprSubstitutionDiagnostic,\n                                                 IsSimple, NoexceptLoc,\n                                                 ReturnTypeRequirement);\n}\n\nconcepts::TypeRequirement *\nSema::BuildTypeRequirement(TypeSourceInfo *Type) {\n  return new (Context) concepts::TypeRequirement(Type);\n}\n\nconcepts::TypeRequirement *\nSema::BuildTypeRequirement(\n    concepts::Requirement::SubstitutionDiagnostic *SubstDiag) {\n  return new (Context) concepts::TypeRequirement(SubstDiag);\n}\n\nconcepts::Requirement *Sema::ActOnNestedRequirement(Expr *Constraint) {\n  return BuildNestedRequirement(Constraint);\n}\n\nconcepts::NestedRequirement *\nSema::BuildNestedRequirement(Expr *Constraint) {\n  ConstraintSatisfaction Satisfaction;\n  if (!Constraint->isInstantiationDependent() &&\n      CheckConstraintSatisfaction(nullptr, {Constraint}, /*TemplateArgs=*/{},\n                                  Constraint->getSourceRange(), Satisfaction))\n    return nullptr;\n  return new (Context) concepts::NestedRequirement(Context, Constraint,\n                                                   Satisfaction);\n}\n\nconcepts::NestedRequirement *\nSema::BuildNestedRequirement(\n    concepts::Requirement::SubstitutionDiagnostic *SubstDiag) {\n  return new (Context) concepts::NestedRequirement(SubstDiag);\n}\n\nRequiresExprBodyDecl *\nSema::ActOnStartRequiresExpr(SourceLocation RequiresKWLoc,\n                             ArrayRef<ParmVarDecl *> LocalParameters,\n                             Scope *BodyScope) {\n  assert(BodyScope);\n\n  RequiresExprBodyDecl *Body = RequiresExprBodyDecl::Create(Context, CurContext,\n                                                            RequiresKWLoc);\n\n  PushDeclContext(BodyScope, Body);\n\n  for (ParmVarDecl *Param : LocalParameters) {\n    if (Param->hasDefaultArg())\n      // C++2a [expr.prim.req] p4\n      //     [...] A local parameter of a requires-expression shall not have a\n      //     default argument. [...]\n      Diag(Param->getDefaultArgRange().getBegin(),\n           diag::err_requires_expr_local_parameter_default_argument);\n    // Ignore default argument and move on\n\n    Param->setDeclContext(Body);\n    // If this has an identifier, add it to the scope stack.\n    if (Param->getIdentifier()) {\n      CheckShadow(BodyScope, Param);\n      PushOnScopeChains(Param, BodyScope);\n    }\n  }\n  return Body;\n}\n\nvoid Sema::ActOnFinishRequiresExpr() {\n  assert(CurContext && \"DeclContext imbalance!\");\n  CurContext = CurContext->getLexicalParent();\n  assert(CurContext && \"Popped translation unit!\");\n}\n\nExprResult\nSema::ActOnRequiresExpr(SourceLocation RequiresKWLoc,\n                        RequiresExprBodyDecl *Body,\n                        ArrayRef<ParmVarDecl *> LocalParameters,\n                        ArrayRef<concepts::Requirement *> Requirements,\n                        SourceLocation ClosingBraceLoc) {\n  auto *RE = RequiresExpr::Create(Context, RequiresKWLoc, Body, LocalParameters,\n                                  Requirements, ClosingBraceLoc);\n  if (DiagnoseUnexpandedParameterPackInRequiresExpr(RE))\n    return ExprError();\n  return RE;\n}\n"}}, "reports": [{"events": [{"location": {"col": 7, "file": 20, "line": 1307}, "message": "default constructor 'ReferenceTypeLoc' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/TypeLoc.h", "reportHash": "f8c29486901847d7f6b0e396ff70fa56", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 18, "file": 30, "line": 48}, "message": "move constructor 'InitializedEntity' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Sema/Initialization.h", "reportHash": "d31c2d5c3f243cc1e10a8c1802706c0d", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 10, "file": 30, "line": 146}, "message": "default constructor 'LN' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Sema/Initialization.h", "reportHash": "b918c6ffe63ef77e99658e634db6752b", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 10, "file": 30, "line": 146}, "message": "move constructor 'LN' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Sema/Initialization.h", "reportHash": "2be42253d45b93ca0a8031d920bdd695", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 10, "file": 30, "line": 158}, "message": "move constructor 'VD' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Sema/Initialization.h", "reportHash": "45f69b2bb5e4429c1ad179b06a115741", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 10, "file": 30, "line": 172}, "message": "default constructor 'C' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Sema/Initialization.h", "reportHash": "1eb80fbb34986473d150d7de0d61cb59", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 10, "file": 30, "line": 172}, "message": "move constructor 'C' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Sema/Initialization.h", "reportHash": "223fdbc0a0777caf38a8b0ec978f0b4b", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 30, "line": 180}, "message": "move constructor '' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Sema/Initialization.h", "reportHash": "ec40b93e071b420264df1e1e1903c36c", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 30, "line": 562}, "message": "destructor '~InitializationKind' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Sema/Initialization.h", "reportHash": "1a01ce51789da676e15a9d6332c968b6", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 30, "line": 562}, "message": "move constructor 'InitializationKind' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Sema/Initialization.h", "reportHash": "9d15148d9eda9d900f7c657e946ef4d4", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 12, "file": 31, "line": 945}, "message": "destructor '~OperatorRewriteInfo' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Sema/Overload.h", "reportHash": "e348a79d8773ac8565883da50671ee6b", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 10, "file": 31, "line": 1164}, "message": "destructor '~ConstructorInfo' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Sema/Overload.h", "reportHash": "758bc7952e429e10bafc39e1723d683b", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 10, "file": 31, "line": 1164}, "message": "move constructor 'ConstructorInfo' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Sema/Overload.h", "reportHash": "a064644d2a5fde2b667f5cceadbd348b", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 9, "file": 32, "line": 1135}, "message": "destructor '~' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/lib/Sema/SemaExprCXX.cpp", "reportHash": "d99ef57877596107c20605365d7aedb6", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 9, "file": 32, "line": 1135}, "message": "move constructor '' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/lib/Sema/SemaExprCXX.cpp", "reportHash": "e25b79dcea78900c98c1466ac4f289b1", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 10, "file": 32, "line": 1588}, "message": "move constructor 'UsualDeallocFnInfo' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/lib/Sema/SemaExprCXX.cpp", "reportHash": "87c0126803bc475bdbefd9b4d54e9db9", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}]};
      window.onload = function() {
        if (!browserCompatible) {
          setNonCompatibleBrowserMessage();
        } else {
          BugViewer.init(data.files, data.reports);
          BugViewer.create();
          BugViewer.initByUrl();
        }
      };
    </script>
  </head>
  <body>
  <div class="container">
    <div id="content">
      <div id="side-bar">
        <div class="header">
          <a href="index.html" class="button">&#8249; Return to List</a>
        </div>
        <div id="report-nav">
          <div class="header">Reports</div>
        </div>
      </div>
      <div id="editor-wrapper">
        <div class="header">
          <div id="file">
            <span class="label">File:</span>
            <span id="file-path"></span>
          </div>
          <div id="checker">
            <span class="label">Checker name:</span>
            <span id="checker-name"></span>
          </div>
          <div id="review-status-wrapper">
            <span class="label">Review status:</span>
            <span id="review-status"></span>
          </div>
        </div>
        <div id="editor"></div>
      </div>
    </div>
  </div>
  </body>
</html>
